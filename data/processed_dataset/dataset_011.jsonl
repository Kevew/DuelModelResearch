{"declaration": "theorem image\u2082_singleton : image\u2082 f {a} {b} = {f a b} := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/NAry.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' \u03b6 \u03b6' \u03bd : Type*}", "[DecidableEq \u03b1'] [DecidableEq \u03b2'] [DecidableEq \u03b3] [DecidableEq \u03b3']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_14\nimage\u2082 : x\u271d\u00b9\nx\u271d : Sort u_15\nf : x\u271d\n\u22a2 sorry = {sorry}"}, {"line": "simp", "tactic_state": "x\u271d\u00b9 : Sort u_14\nimage\u2082 : x\u271d\u00b9\nx\u271d : Sort u_15\nf : x\u271d\n\u22a2 sorry () = {sorry ()}"}]}
{"declaration": "theorem card_antidiagonal (n : \u2115) : (antidiagonal n).card = n + 1 := by simp [antidiagonal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/NatAntidiagonal.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nantidiagonal : x\u271d\nn : \u2115\n\u22a2 sorry = n + 1"}, {"line": "simp [antidiagonal]", "tactic_state": "x\u271d : Sort u_1\nantidiagonal : x\u271d\nn : \u2115\n\u22a2 sorry () = n + 1"}]}
{"declaration": "theorem noncommFoldr_cons (s : Multiset \u03b1) (a : \u03b1) (h h') (b : \u03b2) :\n    noncommFoldr f (a ::\u2098 s) h b = f a (noncommFoldr f s h' b) := by\n  induction s using Quotient.inductionOn\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/NoncommProd.lean", "context": {"open": [], "variables": ["{F \u03b9 \u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nx\u271d : Sort u_6\nnoncommFoldr : x\u271d\ns : Multiset \u03b1\na : \u03b1\nh : ?m.915 f _fvar.54 s a\nh' : ?m.916 f _fvar.54 s a h\nb : \u03b2\n\u22a2 sorry = f a sorry"}, {"line": "induction s using Quotient.inductionOn", "tactic_state": "case h\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nx\u271d : Sort u_6\nnoncommFoldr : x\u271d\na : \u03b1\nb : \u03b2\na\u271d : List \u03b1\nh : ?m.915 f _fvar.54 \u27e6a\u271d\u27e7 a\nh' : ?m.916 f _fvar.54 \u27e6a\u271d\u27e7 a h\n\u22a2 sorry = f a sorry"}, {"line": "simp", "tactic_state": "case h\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nx\u271d : Sort u_6\nnoncommFoldr : x\u271d\na : \u03b1\nb : \u03b2\na\u271d : List \u03b1\nh : ?m.915 f _fvar.54 \u27e6a\u271d\u27e7 a\nh' : ?m.916 f _fvar.54 \u27e6a\u271d\u27e7 a h\n\u22a2 sorry () = f a (sorry ())"}]}
{"declaration": "theorem noncommFold_coe (l : List \u03b1) (comm) (a : \u03b1) :\n    noncommFold op (l : Multiset \u03b1) comm a = l.foldr op a := by simp [noncommFold]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/NoncommProd.lean", "context": {"open": [], "variables": ["{F \u03b9 \u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[assoc : Std.Associative op]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nassoc : Std.Associative op\nx\u271d : Sort u_6\nnoncommFold : x\u271d\nl : List \u03b1\ncomm : ?m.560 _fvar.85 op l\na : \u03b1\n\u22a2 sorry = List.foldr op a l"}, {"line": "simp [noncommFold]", "tactic_state": "\u03b1 : Type u_3\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nassoc : Std.Associative op\nx\u271d : Sort u_6\nnoncommFold : x\u271d\nl : List \u03b1\ncomm : ?m.560 _fvar.85 op l\na : \u03b1\n\u22a2 sorry () = List.foldr op a l"}]}
{"declaration": "theorem noncommFold_cons (s : Multiset \u03b1) (a : \u03b1) (h h') (x : \u03b1) :\n    noncommFold op (a ::\u2098 s) h x = op a (noncommFold op s h' x) := by\n  induction s using Quotient.inductionOn\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/NoncommProd.lean", "context": {"open": [], "variables": ["{F \u03b9 \u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[assoc : Std.Associative op]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nassoc : Std.Associative op\nx\u271d : Sort u_6\nnoncommFold : x\u271d\ns : Multiset \u03b1\na : \u03b1\nh : ?m.962 _fvar.85 op s a\nh' : ?m.963 _fvar.85 op s a h\nx : \u03b1\n\u22a2 sorry = op a sorry"}, {"line": "induction s using Quotient.inductionOn", "tactic_state": "case h\n\u03b1 : Type u_3\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nassoc : Std.Associative op\nx\u271d : Sort u_6\nnoncommFold : x\u271d\na x : \u03b1\na\u271d : List \u03b1\nh : ?m.962 _fvar.85 op \u27e6a\u271d\u27e7 a\nh' : ?m.963 _fvar.85 op \u27e6a\u271d\u27e7 a h\n\u22a2 sorry = op a sorry"}, {"line": "simp", "tactic_state": "case h\n\u03b1 : Type u_3\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nassoc : Std.Associative op\nx\u271d : Sort u_6\nnoncommFold : x\u271d\na x : \u03b1\na\u271d : List \u03b1\nh : ?m.962 _fvar.85 op \u27e6a\u271d\u27e7 a\nh' : ?m.963 _fvar.85 op \u27e6a\u271d\u27e7 a h\n\u22a2 sorry () = op a (sorry ())"}]}
{"declaration": "theorem noncommProd_cons (s : Multiset \u03b1) (a : \u03b1) (comm) :\n    noncommProd (a ::\u2098 s) comm = a * noncommProd s (comm.mono fun _ => mem_cons_of_mem) := by\n  induction s using Quotient.inductionOn\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/NoncommProd.lean", "context": {"open": [], "variables": ["{F \u03b9 \u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[assoc : Std.Associative op]", "[Monoid \u03b1] [Monoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : Monoid \u03b1\nx\u271d : Sort u_6\nnoncommProd : x\u271d\ns : Multiset \u03b1\na : \u03b1\ncomm : ?m.1928 _fvar.128 _fvar.134 s a\n\u22a2 sorry = a * sorry"}, {"line": "induction s using Quotient.inductionOn", "tactic_state": "case h\n\u03b1 : Type u_3\ninst\u271d : Monoid \u03b1\nx\u271d : Sort u_6\nnoncommProd : x\u271d\na : \u03b1\na\u271d : List \u03b1\ncomm : ?m.1928 _fvar.128 _fvar.134 \u27e6a\u271d\u27e7 a\n\u22a2 sorry = a * sorry"}, {"line": "simp", "tactic_state": "case h\n\u03b1 : Type u_3\ninst\u271d : Monoid \u03b1\nx\u271d : Sort u_6\nnoncommProd : x\u271d\na : \u03b1\na\u271d : List \u03b1\ncomm : ?m.1928 _fvar.128 _fvar.134 \u27e6a\u271d\u27e7 a\n\u22a2 sorry () = a * sorry ()"}]}
{"declaration": "theorem noncommProd_eq_prod {\u03b1 : Type*} [CommMonoid \u03b1] (s : Multiset \u03b1) :\n    (noncommProd s fun _ _ _ _ _ => Commute.all _ _) = prod s := by\n  induction s using Quotient.inductionOn\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/NoncommProd.lean", "context": {"open": [], "variables": ["{F \u03b9 \u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[assoc : Std.Associative op]", "[Monoid \u03b1] [Monoid \u03b2]", "[FunLike F \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_7\nnoncommProd : x\u271d\u00b9\nx\u271d : Sort u_8\nprod : x\u271d\n\u03b1 : Type u_6\ninst\u271d : CommMonoid \u03b1\ns : Multiset \u03b1\n\u22a2 sorry = sorry"}, {"line": "induction s using Quotient.inductionOn", "tactic_state": "case h\nx\u271d\u00b9 : Sort u_7\nnoncommProd : x\u271d\u00b9\nx\u271d : Sort u_8\nprod : x\u271d\n\u03b1 : Type u_6\ninst\u271d : CommMonoid \u03b1\na\u271d : List \u03b1\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "case h\nx\u271d\u00b9 : Sort u_7\nnoncommProd : x\u271d\u00b9\nx\u271d : Sort u_8\nprod : x\u271d\n\u03b1 : Type u_6\ninst\u271d : CommMonoid \u03b1\na\u271d : List \u03b1\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem noncommProd_lemma (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2)\n    (comm : (s : Set \u03b1).Pairwise (Commute on f)) :\n    Set.Pairwise { x | x \u2208 Multiset.map f s.val } Commute := by\n  simp_rw [Multiset.mem_map]\n  rintro _ \u27e8a, ha, rfl\u27e9 _ \u27e8b, hb, rfl\u27e9 _\n  exact comm.of_refl ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/NoncommProd.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation"], "variables": ["{F \u03b9 \u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[assoc : Std.Associative op]", "[Monoid \u03b1] [Monoid \u03b2]", "[FunLike F \u03b1 \u03b2]", "[Monoid \u03b2] [Monoid \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 inst\u271d : Monoid \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\ncomm : (\u2191s).Pairwise (Function.onFun Commute f)\n\u22a2 {x | x \u2208 Multiset.map f s.val}.Pairwise Commute"}, {"line": "simp_rw [Multiset.mem_map]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 inst\u271d : Monoid \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\ncomm : (\u2191s).Pairwise (Function.onFun Commute f)\n\u22a2 {x | \u2203 a \u2208 s.val, f a = x}.Pairwise Commute"}, {"line": "rintro _ \u27e8a, ha, rfl\u27e9 _ \u27e8b, hb, rfl\u27e9 _", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 inst\u271d : Monoid \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\ncomm : (\u2191s).Pairwise (Function.onFun Commute f)\na : \u03b1\nha : a \u2208 s.val\nb : \u03b1\nhb : b \u2208 s.val\na\u271d : f a \u2260 f b\n\u22a2 Commute (f a) (f b)"}, {"line": "exact comm.of_refl ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem noncommProd_toFinset [DecidableEq \u03b1] (l : List \u03b1) (f : \u03b1 \u2192 \u03b2) (comm) (hl : l.Nodup) :\n    noncommProd l.toFinset f comm = (l.map f).prod := by\n  rw [\u2190 List.dedup_eq_self] at hl\n  simp [noncommProd, hl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/NoncommProd.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation"], "variables": ["{F \u03b9 \u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[assoc : Std.Associative op]", "[Monoid \u03b1] [Monoid \u03b2]", "[FunLike F \u03b1 \u03b2]", "[Monoid \u03b2] [Monoid \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Monoid \u03b2\nx\u271d : Sort u_6\nnoncommProd : x\u271d\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\ncomm : ?m.1631 _fvar.230 _fvar.236 l f\nhl : l.Nodup\n\u22a2 sorry = (List.map f l).prod"}, {"line": "rw [\u2190 List.dedup_eq_self] at hl", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Monoid \u03b2\nx\u271d : Sort u_6\nnoncommProd : x\u271d\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\ncomm : ?m.1631 _fvar.230 _fvar.236 l f\nhl\u271d : l.Nodup\nhl : l.dedup = l\n\u22a2 sorry = (List.map f l).prod\n---\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Monoid \u03b2\nx\u271d : Sort u_6\nnoncommProd : x\u271d\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\ncomm : ?m.1631 _fvar.230 _fvar.236 l f\nhl : l.Nodup\n\u22a2 DecidableEq \u03b1"}, {"line": "simp [noncommProd, hl]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Monoid \u03b2\nx\u271d : Sort u_6\nnoncommProd : x\u271d\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\ncomm : ?m.1631 _fvar.230 _fvar.236 l f\nhl\u271d : l.Nodup\nhl : l.dedup = l\n\u22a2 sorry () = (List.map f l).prod\n---\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Monoid \u03b2\nx\u271d : Sort u_6\nnoncommProd : x\u271d\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\ncomm : ?m.1631 _fvar.230 _fvar.236 l f\nhl : l.Nodup\n\u22a2 DecidableEq \u03b1"}]}
{"declaration": "theorem noncommProd_eq_prod {\u03b2 : Type*} [CommMonoid \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    (noncommProd s f fun _ _ _ _ _ => Commute.all _ _) = s.prod f := by\n  induction' s using Finset.cons_induction_on with a s ha IH\n  \u00b7 simp\n  \u00b7 simp [ha, IH]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/NoncommProd.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation"], "variables": ["{F \u03b9 \u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "[assoc : Std.Associative op]", "[Monoid \u03b1] [Monoid \u03b2]", "[FunLike F \u03b1 \u03b2]", "[Monoid \u03b2] [Monoid \u03b3]", "[FunLike F \u03b2 \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b9 : Monoid \u03b1\nx\u271d : Sort u_7\nnoncommProd : x\u271d\n\u03b2 : Type u_6\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 sorry = s.prod f"}, {"line": "induction' s using Finset.cons_induction_on with a s ha IH", "tactic_state": "case empty\n\u03b1 : Type u_3\ninst\u271d\u00b9 : Monoid \u03b1\nx\u271d : Sort u_7\nnoncommProd : x\u271d\n\u03b2 : Type u_6\ninst\u271d : CommMonoid \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 sorry = \u2205.prod f\n---\ncase cons\n\u03b1 : Type u_3\ninst\u271d\u00b9 : Monoid \u03b1\nx\u271d : Sort u_7\nnoncommProd : x\u271d\n\u03b2 : Type u_6\ninst\u271d : CommMonoid \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : sorry = s.prod f\n\u22a2 sorry = (Finset.cons a s ha).prod f"}, {"line": "\u00b7 simp", "tactic_state": "case cons\n\u03b1 : Type u_3\ninst\u271d\u00b9 : Monoid \u03b1\nx\u271d : Sort u_7\nnoncommProd : x\u271d\n\u03b2 : Type u_6\ninst\u271d : CommMonoid \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : sorry = s.prod f\n\u22a2 sorry = (Finset.cons a s ha).prod f"}, {"line": "\u00b7 simp [ha, IH]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pi_nonempty : (s.pi t).Nonempty \u2194 \u2200 a \u2208 s, (t a).Nonempty := by\n  simp [Finset.Nonempty, Classical.skolem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Pi.lean", "context": {"open": ["Function", "Multiset"], "variables": ["{\u03b1 : Type*}", "{\u03b2 : \u03b1 \u2192 Type u} {\u03b4 : \u03b1 \u2192 Sort v} {s : Finset \u03b1} {t : \u2200 a, Finset (\u03b2 a)}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u\ns : Finset \u03b1\nt : (a : \u03b1) \u2192 Finset (\u03b2 a)\ninst\u271d : DecidableEq \u03b1\n\u22a2 (s.pi t).Nonempty \u2194 \u2200 a \u2208 s, (t a).Nonempty"}, {"line": "simp [Finset.Nonempty, Classical.skolem]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pi_eq_empty : s.pi t = \u2205 \u2194 \u2203 a \u2208 s, t a = \u2205 := by\n  simp [\u2190 not_nonempty_iff_eq_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Pi.lean", "context": {"open": ["Function", "Multiset"], "variables": ["{\u03b1 : Type*}", "{\u03b2 : \u03b1 \u2192 Type u} {\u03b4 : \u03b1 \u2192 Sort v} {s : Finset \u03b1} {t : \u2200 a, Finset (\u03b2 a)}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u\ns : Finset \u03b1\nt : (a : \u03b1) \u2192 Finset (\u03b2 a)\ninst\u271d : DecidableEq \u03b1\n\u22a2 s.pi t = \u2205 \u2194 \u2203 a \u2208 s, t a = \u2205"}, {"line": "simp [\u2190 not_nonempty_iff_eq_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma piecewise_insert_self [DecidableEq \u03b9] {j : \u03b9} [\u2200 i, Decidable (i \u2208 insert j s)] :\n    (insert j s).piecewise f g j = f j := by simp [piecewise]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Piecewise.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Sort*} (s : Finset \u03b9) (f g : \u2200 i, \u03c0 i)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Sort u_2\ns : Finset \u03b9\nf g : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d\u00b9 : DecidableEq \u03b9\nj : \u03b9\ninst\u271d : (i : \u03b9) \u2192 Decidable (i \u2208 insert j s)\n\u22a2 (insert j s).piecewise f g j = f j"}, {"line": "simp [piecewise]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma piecewise_empty [\u2200 i : \u03b9, Decidable (i \u2208 (\u2205 : Finset \u03b9))] : piecewise \u2205 f g = g := by\n  ext i\n  simp [piecewise]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Piecewise.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Sort*} (s : Finset \u03b9) (f g : \u2200 i, \u03c0 i)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Sort u_2\ng : (i : \u03b9) \u2192 \u03c0 i\nx\u271d : Sort u_3\npiecewise : x\u271d\ninst\u271d : (i : \u03b9) \u2192 Decidable (i \u2208 \u2205)\n\u22a2 sorry = g"}, {"line": "ext i", "tactic_state": "case h\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Sort u_2\ng : (i : \u03b9) \u2192 \u03c0 i\nx\u271d : Sort u_3\npiecewise : x\u271d\ninst\u271d : (i : \u03b9) \u2192 Decidable (i \u2208 \u2205)\ni : \u03b9\n\u22a2 sorry i = g i"}, {"line": "simp [piecewise]", "tactic_state": "case h\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Sort u_2\ng : (i : \u03b9) \u2192 \u03c0 i\nx\u271d : Sort u_3\npiecewise : x\u271d\ninst\u271d : (i : \u03b9) \u2192 Decidable (i \u2208 \u2205)\ni : \u03b9\n\u22a2 sorry () i = g i"}]}
{"declaration": "lemma piecewise_coe [\u2200 j, Decidable (j \u2208 (s : Set \u03b9))] :\n    (s : Set \u03b9).piecewise f g = s.piecewise f g := by\n  ext\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Piecewise.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Sort*} (s : Finset \u03b9) (f g : \u2200 i, \u03c0 i)", "[\u2200 j, Decidable (j \u2208 s)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Sort u_2\ns : Finset \u03b9\nf g : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d\u00b9 : (j : \u03b9) \u2192 Decidable (j \u2208 s)\ninst\u271d : (j : \u03b9) \u2192 Decidable (j \u2208 \u2191s)\n\u22a2 (\u2191s).piecewise f g = s.piecewise f g"}, {"line": "ext", "tactic_state": "case h\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Sort u_2\ns : Finset \u03b9\nf g : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d\u00b9 : (j : \u03b9) \u2192 Decidable (j \u2208 s)\ninst\u271d : (j : \u03b9) \u2192 Decidable (j \u2208 \u2191s)\nx\u271d : \u03b9\n\u22a2 (\u2191s).piecewise f g x\u271d = s.piecewise f g x\u271d"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "lemma piecewise_eq_of_mem {i : \u03b9} (hi : i \u2208 s) : s.piecewise f g i = f i := by\n  simp [piecewise, hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Piecewise.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Sort*} (s : Finset \u03b9) (f g : \u2200 i, \u03c0 i)", "[\u2200 j, Decidable (j \u2208 s)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Sort u_2\ns : Finset \u03b9\nf g : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d : (j : \u03b9) \u2192 Decidable (j \u2208 s)\ni : \u03b9\nhi : i \u2208 s\n\u22a2 s.piecewise f g i = f i"}, {"line": "simp [piecewise, hi]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma piecewise_eq_of_not_mem {i : \u03b9} (hi : i \u2209 s) : s.piecewise f g i = g i := by\n  simp [piecewise, hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Piecewise.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Sort*} (s : Finset \u03b9) (f g : \u2200 i, \u03c0 i)", "[\u2200 j, Decidable (j \u2208 s)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Sort u_2\ns : Finset \u03b9\nf g : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d : (j : \u03b9) \u2192 Decidable (j \u2208 s)\ni : \u03b9\nhi : i \u2209 s\n\u22a2 s.piecewise f g i = g i"}, {"line": "simp [piecewise, hi]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma piecewise_cases {i} (p : \u03c0 i \u2192 Prop) (hf : p (f i)) (hg : p (g i)) :\n    p (s.piecewise f g i) := by\n  by_cases hi : i \u2208 s <;> simpa [hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Piecewise.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Sort*} (s : Finset \u03b9) (f g : \u2200 i, \u03c0 i)", "[\u2200 j, Decidable (j \u2208 s)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Sort u_2\ns : Finset \u03b9\nf g : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d : (j : \u03b9) \u2192 Decidable (j \u2208 s)\ni : \u03b9\np : \u03c0 i \u2192 Prop\nhf : p (f i)\nhg : p (g i)\n\u22a2 p (s.piecewise f g i)"}, {"line": "by_cases hi : i \u2208 s <;> simpa [hi]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma update_piecewise [DecidableEq \u03b9] (i : \u03b9) (v : \u03c0 i) :\n    update (s.piecewise f g) i v = s.piecewise (update f i v) (update g i v) := by\n  ext j\n  rcases em (j = i) with (rfl | hj) <;> by_cases hs : j \u2208 s <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Piecewise.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Sort*} (s : Finset \u03b9) (f g : \u2200 i, \u03c0 i)", "[\u2200 j, Decidable (j \u2208 s)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Sort u_2\ns : Finset \u03b9\nf g : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d\u00b9 : (j : \u03b9) \u2192 Decidable (j \u2208 s)\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nv : \u03c0 i\n\u22a2 update (s.piecewise f g) i v = s.piecewise (update f i v) (update g i v)"}, {"line": "ext j", "tactic_state": "case h\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Sort u_2\ns : Finset \u03b9\nf g : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d\u00b9 : (j : \u03b9) \u2192 Decidable (j \u2208 s)\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nv : \u03c0 i\nj : \u03b9\n\u22a2 update (s.piecewise f g) i v j = s.piecewise (update f i v) (update g i v) j"}, {"line": "rcases em (j = i) with (rfl | hj) <;> by_cases hs : j \u2208 s <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma piecewise_same : s.piecewise f f = f := by\n  ext i\n  by_cases h : i \u2208 s <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Piecewise.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Sort*} (s : Finset \u03b9) (f g : \u2200 i, \u03c0 i)", "[\u2200 j, Decidable (j \u2208 s)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Sort u_2\ns : Finset \u03b9\nf : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d : (j : \u03b9) \u2192 Decidable (j \u2208 s)\n\u22a2 s.piecewise f f = f"}, {"line": "ext i", "tactic_state": "case h\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Sort u_2\ns : Finset \u03b9\nf : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d : (j : \u03b9) \u2192 Decidable (j \u2208 s)\ni : \u03b9\n\u22a2 s.piecewise f f i = f i"}, {"line": "by_cases h : i \u2208 s <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_powerset (s : Finset \u03b1) :\n    (s.powerset : Set (Finset \u03b1)) = ((\u2191) : Finset \u03b1 \u2192 Set \u03b1) \u207b\u00b9' (s : Set \u03b1).powerset := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Powerset.lean", "context": {"open": ["Function Multiset"], "variables": ["{\u03b1 : Type*} {s t : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\n\u22a2 \u2191s.powerset = Finset.toSet \u207b\u00b9' \ud835\udcab\u2191s"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ns x\u271d : Finset \u03b1\n\u22a2 x\u271d \u2208 \u2191s.powerset \u2194 x\u271d \u2208 Finset.toSet \u207b\u00b9' \ud835\udcab\u2191s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_val_val_powersetCard (s : Finset \u03b1) (i : \u2115) :\n    (s.powersetCard i).val.map Finset.val = s.1.powersetCard i := by\n  simp [Finset.powersetCard, map_pmap, pmap_eq_map, map_id']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Powerset.lean", "context": {"open": ["Function Multiset"], "variables": ["{\u03b1 : Type*} {s t : Finset \u03b1}", "[DecidableEq \u03b1]", "{n} {s t : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\ni : \u2115\n\u22a2 map Finset.val (Finset.powersetCard i s).val = powersetCard i s.val"}, {"line": "simp [Finset.powersetCard, map_pmap, pmap_eq_map, map_id']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem powerset_card_biUnion [DecidableEq (Finset \u03b1)] (s : Finset \u03b1) :\n    Finset.powerset s = (range (s.card + 1)).biUnion fun i => powersetCard i s := by\n  simpa only [disjiUnion_eq_biUnion] using powerset_card_disjiUnion s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Powerset.lean", "context": {"open": ["Function Multiset"], "variables": ["{\u03b1 : Type*} {s t : Finset \u03b1}", "[DecidableEq \u03b1]", "{n} {s t : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq (Finset \u03b1)\ns : Finset \u03b1\n\u22a2 s.powerset = sorry"}, {"line": "simpa only [disjiUnion_eq_biUnion] using powerset_card_disjiUnion s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem product_image_fst [DecidableEq \u03b1] (ht : t.Nonempty) : (s \u00d7\u02e2 t).image Prod.fst = s := by\n  ext i\n  simp [mem_image, ht.exists_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Prod.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s s' : Finset \u03b1} {t t' : Finset \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\nt : Finset \u03b2\ninst\u271d : DecidableEq \u03b1\nht : t.Nonempty\n\u22a2 Finset.image Prod.fst (s \u00d7\u02e2 t) = s"}, {"line": "ext i", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\nt : Finset \u03b2\ninst\u271d : DecidableEq \u03b1\nht : t.Nonempty\ni : \u03b1\n\u22a2 i \u2208 Finset.image Prod.fst (s \u00d7\u02e2 t) \u2194 i \u2208 s"}, {"line": "simp [mem_image, ht.exists_mem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem product_image_snd [DecidableEq \u03b2] (ht : s.Nonempty) : (s \u00d7\u02e2 t).image Prod.snd = t := by\n  ext i\n  simp [mem_image, ht.exists_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Prod.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s s' : Finset \u03b1} {t t' : Finset \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\nt : Finset \u03b2\ninst\u271d : DecidableEq \u03b2\nht : s.Nonempty\n\u22a2 Finset.image Prod.snd (s \u00d7\u02e2 t) = t"}, {"line": "ext i", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\nt : Finset \u03b2\ninst\u271d : DecidableEq \u03b2\nht : s.Nonempty\ni : \u03b2\n\u22a2 i \u2208 Finset.image Prod.snd (s \u00d7\u02e2 t) \u2194 i \u2208 t"}, {"line": "simp [mem_image, ht.exists_mem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem filter_product (p : \u03b1 \u2192 Prop) (q : \u03b2 \u2192 Prop) [DecidablePred p] [DecidablePred q] :\n    ((s \u00d7\u02e2 t).filter fun x : \u03b1 \u00d7 \u03b2 => p x.1 \u2227 q x.2) = s.filter p \u00d7\u02e2 t.filter q := by\n  ext \u27e8a, b\u27e9\n  simp [mem_filter, mem_product, decide_eq_true_eq, and_comm, and_left_comm, and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Prod.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s s' : Finset \u03b1} {t t' : Finset \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\nt : Finset \u03b2\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\n\u22a2 {x \u2208 s \u00d7\u02e2 t | p x.1 \u2227 q x.2} = Finset.filter p s \u00d7\u02e2 Finset.filter q t"}, {"line": "ext \u27e8a, b\u27e9", "tactic_state": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\nt : Finset \u03b2\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\na : \u03b1\nb : \u03b2\n\u22a2 (a, b) \u2208 {x \u2208 s \u00d7\u02e2 t | p x.1 \u2227 q x.2} \u2194 (a, b) \u2208 Finset.filter p s \u00d7\u02e2 Finset.filter q t"}, {"line": "simp [mem_filter, mem_product, decide_eq_true_eq, and_comm, and_left_comm, and_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem filter_product_left (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    ((s \u00d7\u02e2 t).filter fun x : \u03b1 \u00d7 \u03b2 => p x.1) = s.filter p \u00d7\u02e2 t := by\n  simpa using filter_product p fun _ => true\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Prod.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s s' : Finset \u03b1} {t t' : Finset \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\nt : Finset \u03b2\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 {x \u2208 s \u00d7\u02e2 t | p x.1} = Finset.filter p s \u00d7\u02e2 t"}, {"line": "simpa using filter_product p fun _ => true", "tactic_state": "No Goals!"}]}
{"declaration": "theorem filter_product_right (q : \u03b2 \u2192 Prop) [DecidablePred q] :\n    ((s \u00d7\u02e2 t).filter fun x : \u03b1 \u00d7 \u03b2 => q x.2) = s \u00d7\u02e2 t.filter q := by\n  simpa using filter_product (fun _ : \u03b1 => true) q\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Prod.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s s' : Finset \u03b1} {t t' : Finset \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\nt : Finset \u03b2\nq : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred q\n\u22a2 {x \u2208 s \u00d7\u02e2 t | q x.2} = s \u00d7\u02e2 Finset.filter q t"}, {"line": "simpa using filter_product (fun _ : \u03b1 => true) q", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singleton_product {a : \u03b1} :\n    ({a} : Finset \u03b1) \u00d7\u02e2 t = t.map \u27e8Prod.mk a, Prod.mk_right_injective _\u27e9 := by\n  ext \u27e8x, y\u27e9\n  simp [and_left_comm, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Prod.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s s' : Finset \u03b1} {t t' : Finset \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : Finset \u03b2\na : \u03b1\n\u22a2 {a} \u00d7\u02e2 t = Finset.map { toFun := Prod.mk a, inj' := \u22ef } t"}, {"line": "ext \u27e8x, y\u27e9", "tactic_state": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : Finset \u03b2\na x : \u03b1\ny : \u03b2\n\u22a2 (x, y) \u2208 {a} \u00d7\u02e2 t \u2194 (x, y) \u2208 Finset.map { toFun := Prod.mk a, inj' := \u22ef } t"}, {"line": "simp [and_left_comm, eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma product_singleton : s \u00d7\u02e2 {b} = s.map \u27e8fun i => (i, b), Prod.mk_left_injective _\u27e9 := by\n  ext \u27e8x, y\u27e9\n  simp [and_left_comm, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Prod.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s s' : Finset \u03b1} {t t' : Finset \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\nb : \u03b2\n\u22a2 s \u00d7\u02e2 {b} = Finset.map { toFun := fun i => (i, b), inj' := \u22ef } s"}, {"line": "ext \u27e8x, y\u27e9", "tactic_state": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\nb : \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 (x, y) \u2208 s \u00d7\u02e2 {b} \u2194 (x, y) \u2208 Finset.map { toFun := fun i => (i, b), inj' := \u22ef } s"}, {"line": "simp [and_left_comm, eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_diag : x \u2208 s.diag \u2194 x.1 \u2208 s \u2227 x.1 = x.2 := by\n  simp +contextual [diag]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Prod.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s s' : Finset \u03b1} {t t' : Finset \u03b2} {a : \u03b1} {b : \u03b2}", "[DecidableEq \u03b1] (s t : Finset \u03b1)", "{s} {x : \u03b1 \u00d7 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nx : \u03b1 \u00d7 \u03b1\n\u22a2 x \u2208 s.diag \u2194 x.1 \u2208 s \u2227 x.1 = x.2"}, {"line": "simp +contextual [diag]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_offDiag : x \u2208 s.offDiag \u2194 x.1 \u2208 s \u2227 x.2 \u2208 s \u2227 x.1 \u2260 x.2 := by\n  simp [offDiag, and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Prod.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s s' : Finset \u03b1} {t t' : Finset \u03b2} {a : \u03b1} {b : \u03b2}", "[DecidableEq \u03b1] (s t : Finset \u03b1)", "{s} {x : \u03b1 \u00d7 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nx : \u03b1 \u00d7 \u03b1\n\u22a2 x \u2208 s.offDiag \u2194 x.1 \u2208 s \u2227 x.2 \u2208 s \u2227 x.1 \u2260 x.2"}, {"line": "simp [offDiag, and_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem offDiag_singleton : ({a} : Finset \u03b1).offDiag = \u2205 := by simp [\u2190 Finset.card_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Prod.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s s' : Finset \u03b1} {t t' : Finset \u03b2} {a : \u03b1} {b : \u03b2}", "[DecidableEq \u03b1] (s t : Finset \u03b1)", "{s} {x : \u03b1 \u00d7 \u03b1}", "(s)", "{s t}", "(a : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\n\u22a2 {a}.offDiag = \u2205"}, {"line": "simp [\u2190 Finset.card_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma range_nontrivial {n : \u2115} (hn : 1 < n) : (Finset.range n).Nontrivial := by\n  rw [Finset.Nontrivial]\n  rw [Finset.coe_range]\n  exact \u27e80, Nat.zero_lt_one.trans hn, 1, hn, Nat.zero_ne_one\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Range.lean", "context": {"open": ["Multiset Subtype Function", "Nat"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{n m l : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : 1 < n\n\u22a2 (Finset.range n).Nontrivial"}, {"line": "rw [Finset.Nontrivial]", "tactic_state": "n : \u2115\nhn : 1 < n\n\u22a2 (\u2191(Finset.range n)).Nontrivial"}, {"line": "rw [Finset.coe_range]", "tactic_state": "n : \u2115\nhn : 1 < n\n\u22a2 (Set.Iio n).Nontrivial"}, {"line": "exact \u27e80, Nat.zero_lt_one.trans hn, 1, hn, Nat.zero_ne_one\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_mem_sdiff_of_not_mem_left (h : a \u2209 s) : a \u2209 s \\ t := by simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/SDiff.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\na : \u03b1\nh : a \u2209 s\n\u22a2 a \u2209 s \\ t"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem union_sdiff_symm : s \u222a t \\ s = t \u222a s \\ t := by simp [union_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/SDiff.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\n\u22a2 s \u222a t \\ s = t \u222a s \\ t"}, {"line": "simp [union_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\n\u22a2 s \u222a t = t \u222a s"}]}
{"declaration": "theorem Nontrivial.sdiff_singleton_nonempty {c : \u03b1} {s : Finset \u03b1} (hS : s.Nontrivial) :\n    (s \\ {c}).Nonempty := by\n  rw [Finset.sdiff_nonempty]\n  rw [Finset.subset_singleton_iff]\n  push_neg\n  exact \u27e8by rintro rfl; exact Finset.not_nontrivial_empty hS, hS.ne_singleton\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/SDiff.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nc : \u03b1\ns : Finset \u03b1\nhS : s.Nontrivial\n\u22a2 (s \\ {c}).Nonempty"}, {"line": "rw [Finset.sdiff_nonempty]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nc : \u03b1\ns : Finset \u03b1\nhS : s.Nontrivial\n\u22a2 \u00acs \u2286 {c}"}, {"line": "rw [Finset.subset_singleton_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nc : \u03b1\ns : Finset \u03b1\nhS : s.Nontrivial\n\u22a2 \u00ac(s = \u2205 \u2228 s = {c})"}, {"line": "push_neg", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nc : \u03b1\ns : Finset \u03b1\nhS : s.Nontrivial\n\u22a2 s \u2260 \u2205 \u2227 s \u2260 {c}"}, {"line": "exact \u27e8by rintro rfl; exact Finset.not_nontrivial_empty hS, hS.ne_singleton\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sigma_nonempty : (s.sigma t).Nonempty \u2194 \u2203 i \u2208 s, (t i).Nonempty := by simp [Finset.Nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sigma.lean", "context": {"open": ["Function Multiset"], "variables": ["{\u03b9 : Type*}", "{\u03b1 : \u03b9 \u2192 Type*} {\u03b2 : Type*} (s s\u2081 s\u2082 : Finset \u03b9) (t t\u2081 t\u2082 : \u2200 i, Finset (\u03b1 i))", "{s s\u2081 s\u2082 t t\u2081 t\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ns : Finset \u03b9\nt : (i : \u03b9) \u2192 Finset (\u03b1 i)\n\u22a2 (s.sigma t).Nonempty \u2194 \u2203 i \u2208 s, (t i).Nonempty"}, {"line": "simp [Finset.Nonempty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sigma_eq_biUnion [DecidableEq (\u03a3 i, \u03b1 i)] (s : Finset \u03b9) (t : \u2200 i, Finset (\u03b1 i)) :\n    s.sigma t = s.biUnion fun i => (t i).map <| Embedding.sigmaMk i := by\n  ext \u27e8x, y\u27e9\n  simp [and_left_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sigma.lean", "context": {"open": ["Function Multiset"], "variables": ["{\u03b9 : Type*}", "{\u03b1 : \u03b9 \u2192 Type*} {\u03b2 : Type*} (s s\u2081 s\u2082 : Finset \u03b9) (t t\u2081 t\u2082 : \u2200 i, Finset (\u03b1 i))", "{s s\u2081 s\u2082 t t\u2081 t\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d : DecidableEq ((i : \u03b9) \u00d7 \u03b1 i)\ns : Finset \u03b9\nt : (i : \u03b9) \u2192 Finset (\u03b1 i)\n\u22a2 s.sigma t = s.biUnion fun i => Finset.map (Embedding.sigmaMk i) (t i)"}, {"line": "ext \u27e8x, y\u27e9", "tactic_state": "case h.mk\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d : DecidableEq ((i : \u03b9) \u00d7 \u03b1 i)\ns : Finset \u03b9\nt : (i : \u03b9) \u2192 Finset (\u03b1 i)\nx : \u03b9\ny : \u03b1 x\n\u22a2 \u27e8x, y\u27e9 \u2208 s.sigma t \u2194 \u27e8x, y\u27e9 \u2208 s.biUnion fun i => Finset.map (Embedding.sigmaMk i) (t i)"}, {"line": "simp [and_left_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.biSup_finsetSigma [CompleteLattice \u03b2] (s : Finset \u03b9) (t : \u2200 i, Finset (\u03b1 i))\n    (f : Sigma \u03b1 \u2192 \u03b2) : \u2a06 ij \u2208 s.sigma t, f ij = \u2a06 (i \u2208 s) (j \u2208 t i), f \u27e8i, j\u27e9 := by\n  simp_rw [\u2190 Finset.iSup_coe, Finset.coe_sigma, biSup_sigma]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sigma.lean", "context": {"open": ["Function Multiset"], "variables": ["{\u03b9 : Type*}", "{\u03b1 : \u03b9 \u2192 Type*} {\u03b2 : Type*} (s s\u2081 s\u2082 : Finset \u03b9) (t t\u2081 t\u2082 : \u2200 i, Finset (\u03b1 i))", "{s s\u2081 s\u2082 t t\u2081 t\u2082}", "(s t) (f : (\u03a3 i, \u03b1 i) \u2192 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : Type u_3\ninst\u271d : CompleteLattice \u03b2\ns : Finset \u03b9\nt : (i : \u03b9) \u2192 Finset (\u03b1 i)\nf : Sigma \u03b1 \u2192 \u03b2\n\u22a2 \u2a06 ij \u2208 s.sigma t, f ij = \u2a06 i \u2208 s, \u2a06 j \u2208 t i, f \u27e8i, j\u27e9"}, {"line": "simp_rw [\u2190 Finset.iSup_coe, Finset.coe_sigma, biSup_sigma]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sized_iUnion {f : \u03b9 \u2192 Set (Finset \u03b1)} : (\u22c3 i, f i).Sized r \u2194 \u2200 i, (f i).Sized r := by\n  simp_rw [Set.Sized, Set.mem_iUnion, forall_exists_index]\n  exact forall_swap\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Slice.lean", "context": {"open": ["Finset Nat"], "variables": ["{\u03b1 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{A B : Set (Finset \u03b1)} {s : Finset \u03b1} {r : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_2\nr : \u2115\nf : \u03b9 \u2192 Set (Finset \u03b1)\n\u22a2 Set.Sized r (\u22c3 i, f i) \u2194 \u2200 (i : \u03b9), Set.Sized r (f i)"}, {"line": "simp_rw [Set.Sized, Set.mem_iUnion, forall_exists_index]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_2\nr : \u2115\nf : \u03b9 \u2192 Set (Finset \u03b1)\n\u22a2 (\u2200 \u2983x : Finset \u03b1\u2984 (x_1 : \u03b9), x \u2208 f x_1 \u2192 x.card = r) \u2194 \u2200 (i : \u03b9) \u2983x : Finset \u03b1\u2984, x \u2208 f i \u2192 x.card = r"}, {"line": "exact forall_swap", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sized_iUnion\u2082 {f : \u2200 i, \u03ba i \u2192 Set (Finset \u03b1)} :\n    (\u22c3 (i) (j), f i j).Sized r \u2194 \u2200 i j, (f i j).Sized r := by\n simp only [Set.sized_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Slice.lean", "context": {"open": ["Finset Nat"], "variables": ["{\u03b1 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{A B : Set (Finset \u03b1)} {s : Finset \u03b1} {r : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_2\n\u03ba : \u03b9 \u2192 Sort u_3\nr : \u2115\nf : (i : \u03b9) \u2192 \u03ba i \u2192 Set (Finset \u03b1)\n\u22a2 Set.Sized r (\u22c3 i, \u22c3 j, f i j) \u2194 \u2200 (i : \u03b9) (j : \u03ba i), Set.Sized r (f i j)"}, {"line": "simp only [Set.sized_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Set.Sized.card_le (h\ud835\udc9c : (\ud835\udc9c : Set (Finset \u03b1)).Sized r) :\n    #\ud835\udc9c \u2264 (Fintype.card \u03b1).choose r := by\n  rw [Fintype.card]\n  rw [\u2190 card_powersetCard]\n  exact card_le_card (subset_powersetCard_univ_iff.mpr h\ud835\udc9c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Slice.lean", "context": {"open": ["Finset Nat"], "variables": ["{\u03b1 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{A B : Set (Finset \u03b1)} {s : Finset \u03b1} {r : \u2115}", "[Fintype \u03b1] {\ud835\udc9c : Finset (Finset \u03b1)} {s : Finset \u03b1} {r : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Fintype \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\nr : \u2115\nh\ud835\udc9c : Set.Sized r \u2191\ud835\udc9c\n\u22a2 \ud835\udc9c.card \u2264 (Fintype.card \u03b1).choose r"}, {"line": "rw [Fintype.card]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Fintype \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\nr : \u2115\nh\ud835\udc9c : Set.Sized r \u2191\ud835\udc9c\n\u22a2 \ud835\udc9c.card \u2264 univ.card.choose r"}, {"line": "rw [\u2190 card_powersetCard]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Fintype \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\nr : \u2115\nh\ud835\udc9c : Set.Sized r \u2191\ud835\udc9c\n\u22a2 \ud835\udc9c.card \u2264 (powersetCard r univ).card"}, {"line": "exact card_le_card (subset_powersetCard_univ_iff.mpr h\ud835\udc9c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.List.toFinset_sort [DecidableEq \u03b1] {l : List \u03b1} (hl : l.Nodup) :\n    sort r l.toFinset = l \u2194 l.Sorted r := by\n  refine \u27e8?_, List.eq_of_perm_of_sorted ((sort_perm_toList r _).trans (List.toFinset_toList hl))\n    (sort_sorted r _)\u27e9\n  intro h\n  rw [\u2190 h]\n  exact sort_sorted r _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sort.lean", "context": {"open": ["Multiset Nat", "scoped List in"], "variables": ["{\u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r] [IsTrans \u03b1 r] [IsAntisymm \u03b1 r] [IsTotal \u03b1 r]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u2074 : DecidableRel r\ninst\u271d\u00b3 : IsTrans \u03b1 r\ninst\u271d\u00b2 : IsAntisymm \u03b1 r\ninst\u271d\u00b9 : IsTotal \u03b1 r\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nhl : l.Nodup\n\u22a2 sort r sorry = l \u2194 List.Sorted r l"}, {"line": "refine \u27e8?_, List.eq_of_perm_of_sorted ((sort_perm_toList r _).trans (List.toFinset_toList hl))\n    (sort_sorted r _)\u27e9", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u2074 : DecidableRel r\ninst\u271d\u00b3 : IsTrans \u03b1 r\ninst\u271d\u00b2 : IsAntisymm \u03b1 r\ninst\u271d\u00b9 : IsTotal \u03b1 r\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nhl : l.Nodup\n\u22a2 sort r sorry = l \u2192 List.Sorted r l"}, {"line": "intro h", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u2074 : DecidableRel r\ninst\u271d\u00b3 : IsTrans \u03b1 r\ninst\u271d\u00b2 : IsAntisymm \u03b1 r\ninst\u271d\u00b9 : IsTotal \u03b1 r\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nhl : l.Nodup\nh : sort r sorry = l\n\u22a2 List.Sorted r l"}, {"line": "rw [\u2190 h]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u2074 : DecidableRel r\ninst\u271d\u00b3 : IsTrans \u03b1 r\ninst\u271d\u00b2 : IsAntisymm \u03b1 r\ninst\u271d\u00b9 : IsTotal \u03b1 r\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nhl : l.Nodup\nh : sort r sorry = l\n\u22a2 List.Sorted r (sort r sorry)"}, {"line": "exact sort_sorted r _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_orderEmbOfFin_univ (s : Finset \u03b1) {k : \u2115} (h : s.card = k) :\n    Finset.image (s.orderEmbOfFin h) Finset.univ = s := by\n  apply Finset.coe_injective\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sort.lean", "context": {"open": ["Multiset Nat", "scoped List in"], "variables": ["{\u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r] [IsTrans \u03b1 r] [IsAntisymm \u03b1 r] [IsTotal \u03b1 r]", "[LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\ns : Finset \u03b1\nk : \u2115\nh : s.card = k\n\u22a2 Finset.image (\u21d1(s.orderEmbOfFin h)) Finset.univ = s"}, {"line": "apply Finset.coe_injective", "tactic_state": "case a\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\ns : Finset \u03b1\nk : \u2115\nh : s.card = k\n\u22a2 \u2191(Finset.image (\u21d1(s.orderEmbOfFin h)) Finset.univ) = \u2191s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_orderEmbOfFin_univ (s : Finset \u03b1) {k : \u2115} (h : s.card = k) :\n    Finset.map (s.orderEmbOfFin h).toEmbedding Finset.univ = s := by\n  simp [map_eq_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sort.lean", "context": {"open": ["Multiset Nat", "scoped List in"], "variables": ["{\u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r] [IsTrans \u03b1 r] [IsAntisymm \u03b1 r] [IsTotal \u03b1 r]", "[LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\ns : Finset \u03b1\nk : \u2115\nh : s.card = k\n\u22a2 Finset.map (s.orderEmbOfFin h).toEmbedding Finset.univ = s"}, {"line": "simp [map_eq_image]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orderEmbOfFin_last {s : Finset \u03b1} {k : \u2115} (h : s.card = k) (hz : 0 < k) :\n    orderEmbOfFin s h \u27e8k - 1, Nat.sub_lt hz (Nat.succ_pos 0)\u27e9 =\n      s.max' (card_pos.mp (h.symm \u25b8 hz)) := by\n  simp [orderEmbOfFin_apply, max'_eq_sorted_last, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sort.lean", "context": {"open": ["Multiset Nat", "scoped List in"], "variables": ["{\u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r] [IsTrans \u03b1 r] [IsAntisymm \u03b1 r] [IsTotal \u03b1 r]", "[LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : LinearOrder \u03b1\nx\u271d : Sort u_1\norderEmbOfFin : x\u271d\ns : Finset \u03b1\nk : \u2115\nh : s.card = k\nhz : 0 < k\n\u22a2 sorry = s.max' \u22ef"}, {"line": "simp [orderEmbOfFin_apply, max'_eq_sorted_last, h]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : LinearOrder \u03b1\nx\u271d : Sort u_1\norderEmbOfFin : x\u271d\ns : Finset \u03b1\nk : \u2115\nh : s.card = k\nhz : 0 < k\n\u22a2 sorry () = s.max' \u22ef"}]}
{"declaration": "theorem orderEmbOfFin_eq_orderEmbOfFin_iff {k l : \u2115} {s : Finset \u03b1} {i : Fin k} {j : Fin l}\n    {h : s.card = k} {h' : s.card = l} :\n    s.orderEmbOfFin h i = s.orderEmbOfFin h' j \u2194 (i : \u2115) = (j : \u2115) := by\n  substs k l\n  exact (s.orderEmbOfFin rfl).eq_iff_eq.trans Fin.ext_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sort.lean", "context": {"open": ["Multiset Nat", "scoped List in"], "variables": ["{\u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r] [IsTrans \u03b1 r] [IsAntisymm \u03b1 r] [IsTotal \u03b1 r]", "[LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nk l : \u2115\ns : Finset \u03b1\ni : Fin k\nj : Fin l\nh : s.card = k\nh' : s.card = l\n\u22a2 (s.orderEmbOfFin h) i = (s.orderEmbOfFin h') j \u2194 \u2191i = \u2191j"}, {"line": "substs k l", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\ns : Finset \u03b1\ni j : Fin s.card\n\u22a2 (s.orderEmbOfFin \u22ef) i = (s.orderEmbOfFin \u22ef) j \u2194 \u2191i = \u2191j"}, {"line": "exact (s.orderEmbOfFin rfl).eq_iff_eq.trans Fin.ext_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjSum_eq_empty : s.disjSum t = \u2205 \u2194 s = \u2205 \u2227 t = \u2205 := by simp [Finset.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sum.lean", "context": {"open": ["Function Multiset Sum"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)", "{s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\nt : Finset \u03b2\n\u22a2 s.disjSum t = \u2205 \u2194 s = \u2205 \u2227 t = \u2205"}, {"line": "simp [Finset.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toLeft_disjSum_toRight : u.toLeft.disjSum u.toRight = u := by\n  ext (x | x) <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sum.lean", "context": {"open": ["Function Multiset Sum"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)", "{s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}", "{u v : Finset (\u03b1 \u2295 \u03b2)} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nu : Finset (\u03b1 \u2295 \u03b2)\n\u22a2 u.toLeft.disjSum u.toRight = u"}, {"line": "ext (x | x) <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_sups : c \u2208 s \u22bb t \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, a \u2294 b = c := by simp [(\u00b7 \u22bb \u00b7)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sups.lean", "context": {"open": ["Function", "SetFamily", "FinsetFamily"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [FunLike F \u03b1 \u03b2] [SupHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : SemilatticeSup \u03b1\ns t : Finset \u03b1\nc : \u03b1\n\u22a2 c \u2208 s \u22bb t \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, a \u2294 b = c"}, {"line": "simp [(\u00b7 \u22bb \u00b7)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_infs : c \u2208 s \u22bc t \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, a \u2293 b = c := by simp [(\u00b7 \u22bc \u00b7)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sups.lean", "context": {"open": ["Function", "SetFamily", "FinsetFamily", "FinsetFamily"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [FunLike F \u03b1 \u03b2] [SupHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2] [FunLike F \u03b1 \u03b2] [InfHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : SemilatticeInf \u03b1\ns t : Finset \u03b1\nc : \u03b1\n\u22a2 c \u2208 s \u22bc t \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, a \u2293 b = c"}, {"line": "simp [(\u00b7 \u22bc \u00b7)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_disjSups : c \u2208 s \u25cb t \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, Disjoint a b \u2227 a \u2294 b = c := by\n  simp [disjSups, and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sups.lean", "context": {"open": ["Function", "SetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [FunLike F \u03b1 \u03b2] [SupHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2] [FunLike F \u03b1 \u03b2] [InfHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1]", "[DistribLattice \u03b1] (s t u : Finset \u03b1)", "[DecidableEq \u03b1]", "{\ud835\udc9c \u212c : Finset (Finset \u03b1)} {s t : Finset \u03b1}", "[DecidableEq \u03b1]", "[SemilatticeSup \u03b1] [OrderBot \u03b1] [DecidableRel (\u03b1 := \u03b1) Disjoint]", "{s t u} {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2070 : DecidableEq \u03b1\ninst\u271d\u2079 : SemilatticeSup \u03b1\ninst\u271d\u2078 : DecidableEq \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\nc : \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : DistribLattice \u03b1\ninst\u271d\u2074 : DecidableEq \u03b1\ns t : Finset \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : DecidableRel Disjoint\n\u22a2 c \u2208 sorry \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, Disjoint a b \u2227 a \u2294 b = c"}, {"line": "simp [disjSups, and_assoc]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2070 : DecidableEq \u03b1\ninst\u271d\u2079 : SemilatticeSup \u03b1\ninst\u271d\u2078 : DecidableEq \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\nc : \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : DistribLattice \u03b1\ninst\u271d\u2074 : DecidableEq \u03b1\ns t : Finset \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : DecidableRel Disjoint\n\u22a2 c \u2208 sorry () \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, Disjoint a b \u2227 a \u2294 b = c"}]}
{"declaration": "theorem disjSups_empty_left : \u2205 \u25cb t = \u2205 := by simp [disjSups]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sups.lean", "context": {"open": ["Function", "SetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [FunLike F \u03b1 \u03b2] [SupHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2] [FunLike F \u03b1 \u03b2] [InfHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1]", "[DistribLattice \u03b1] (s t u : Finset \u03b1)", "[DecidableEq \u03b1]", "{\ud835\udc9c \u212c : Finset (Finset \u03b1)} {s t : Finset \u03b1}", "[DecidableEq \u03b1]", "[SemilatticeSup \u03b1] [OrderBot \u03b1] [DecidableRel (\u03b1 := \u03b1) Disjoint]", "{s t u} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = \u2205"}, {"line": "simp [disjSups]", "tactic_state": "\u22a2 sorry () = \u2205"}]}
{"declaration": "theorem disjSups_empty_right : s \u25cb \u2205 = \u2205 := by simp [disjSups]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sups.lean", "context": {"open": ["Function", "SetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [FunLike F \u03b1 \u03b2] [SupHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2] [FunLike F \u03b1 \u03b2] [InfHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1]", "[DistribLattice \u03b1] (s t u : Finset \u03b1)", "[DecidableEq \u03b1]", "{\ud835\udc9c \u212c : Finset (Finset \u03b1)} {s t : Finset \u03b1}", "[DecidableEq \u03b1]", "[SemilatticeSup \u03b1] [OrderBot \u03b1] [DecidableRel (\u03b1 := \u03b1) Disjoint]", "{s t u} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = \u2205"}, {"line": "simp [disjSups]", "tactic_state": "\u22a2 sorry () = \u2205"}]}
{"declaration": "theorem disjSups_singleton : ({a} \u25cb {b} : Finset \u03b1) = if Disjoint a b then {a \u2294 b} else \u2205 := by\n  split_ifs with h <;> simp [disjSups, filter_singleton, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sups.lean", "context": {"open": ["Function", "SetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [FunLike F \u03b1 \u03b2] [SupHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2] [FunLike F \u03b1 \u03b2] [InfHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1]", "[DistribLattice \u03b1] (s t u : Finset \u03b1)", "[DecidableEq \u03b1]", "{\ud835\udc9c \u212c : Finset (Finset \u03b1)} {s t : Finset \u03b1}", "[DecidableEq \u03b1]", "[SemilatticeSup \u03b1] [OrderBot \u03b1] [DecidableRel (\u03b1 := \u03b1) Disjoint]", "{s t u} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2070 : DecidableEq \u03b1\ninst\u271d\u2079 : SemilatticeSup \u03b1\ninst\u271d\u2078 : DecidableEq \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\na b : \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : DistribLattice \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : DecidableRel Disjoint\n\u22a2 sorry = if Disjoint a b then {a \u2294 b} else \u2205"}, {"line": "split_ifs with h <;> simp [disjSups, filter_singleton, h]", "tactic_state": "case pos\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2070 : DecidableEq \u03b1\ninst\u271d\u2079 : SemilatticeSup \u03b1\ninst\u271d\u2078 : DecidableEq \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\na b : \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : DistribLattice \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : DecidableRel Disjoint\nh : Disjoint a b\n\u22a2 sorry () = {a \u2294 b}\n---\ncase neg\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2070 : DecidableEq \u03b1\ninst\u271d\u2079 : SemilatticeSup \u03b1\ninst\u271d\u2078 : DecidableEq \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\na b : \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : DistribLattice \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : DecidableRel Disjoint\nh : \u00acDisjoint a b\n\u22a2 sorry () = \u2205"}]}
{"declaration": "theorem disjSups_union_left : (s\u2081 \u222a s\u2082) \u25cb t = s\u2081 \u25cb t \u222a s\u2082 \u25cb t := by\n  simp [disjSups, filter_union, image_union]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sups.lean", "context": {"open": ["Function", "SetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [FunLike F \u03b1 \u03b2] [SupHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2] [FunLike F \u03b1 \u03b2] [InfHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1]", "[DistribLattice \u03b1] (s t u : Finset \u03b1)", "[DecidableEq \u03b1]", "{\ud835\udc9c \u212c : Finset (Finset \u03b1)} {s t : Finset \u03b1}", "[DecidableEq \u03b1]", "[SemilatticeSup \u03b1] [OrderBot \u03b1] [DecidableRel (\u03b1 := \u03b1) Disjoint]", "{s t u} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2070 : DecidableEq \u03b1\ninst\u271d\u2079 : SemilatticeSup \u03b1\ninst\u271d\u2078 : DecidableEq \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : DistribLattice \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : DecidableRel Disjoint\n\u22a2 sorry = sorry \u222a sorry"}, {"line": "simp [disjSups, filter_union, image_union]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjSups_union_right : s \u25cb (t\u2081 \u222a t\u2082) = s \u25cb t\u2081 \u222a s \u25cb t\u2082 := by\n  simp [disjSups, filter_union, image_union]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sups.lean", "context": {"open": ["Function", "SetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [FunLike F \u03b1 \u03b2] [SupHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2] [FunLike F \u03b1 \u03b2] [InfHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1]", "[DistribLattice \u03b1] (s t u : Finset \u03b1)", "[DecidableEq \u03b1]", "{\ud835\udc9c \u212c : Finset (Finset \u03b1)} {s t : Finset \u03b1}", "[DecidableEq \u03b1]", "[SemilatticeSup \u03b1] [OrderBot \u03b1] [DecidableRel (\u03b1 := \u03b1) Disjoint]", "{s t u} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2070 : DecidableEq \u03b1\ninst\u271d\u2079 : SemilatticeSup \u03b1\ninst\u271d\u2078 : DecidableEq \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : DistribLattice \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : DecidableRel Disjoint\n\u22a2 sorry = sorry \u222a sorry"}, {"line": "simp [disjSups, filter_union, image_union]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjSups_inter_subset_left : (s\u2081 \u2229 s\u2082) \u25cb t \u2286 s\u2081 \u25cb t \u2229 s\u2082 \u25cb t := by\n  simpa only [disjSups,inter_product,filter_inter_distrib] using image_inter_subset _ _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sups.lean", "context": {"open": ["Function", "SetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [FunLike F \u03b1 \u03b2] [SupHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2] [FunLike F \u03b1 \u03b2] [InfHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1]", "[DistribLattice \u03b1] (s t u : Finset \u03b1)", "[DecidableEq \u03b1]", "{\ud835\udc9c \u212c : Finset (Finset \u03b1)} {s t : Finset \u03b1}", "[DecidableEq \u03b1]", "[SemilatticeSup \u03b1] [OrderBot \u03b1] [DecidableRel (\u03b1 := \u03b1) Disjoint]", "{s t u} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2070 : DecidableEq \u03b1\ninst\u271d\u2079 : SemilatticeSup \u03b1\ninst\u271d\u2078 : DecidableEq \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : DistribLattice \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : DecidableRel Disjoint\n\u22a2 sorry \u2286 sorry \u2229 sorry"}, {"line": "simpa only [disjSups,inter_product,filter_inter_distrib] using image_inter_subset _ _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjSups_inter_subset_right : s \u25cb (t\u2081 \u2229 t\u2082) \u2286 s \u25cb t\u2081 \u2229 s \u25cb t\u2082 := by\n  simpa only [disjSups,product_inter,filter_inter_distrib] using image_inter_subset _ _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sups.lean", "context": {"open": ["Function", "SetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [FunLike F \u03b1 \u03b2] [SupHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2] [FunLike F \u03b1 \u03b2] [InfHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1]", "[DistribLattice \u03b1] (s t u : Finset \u03b1)", "[DecidableEq \u03b1]", "{\ud835\udc9c \u212c : Finset (Finset \u03b1)} {s t : Finset \u03b1}", "[DecidableEq \u03b1]", "[SemilatticeSup \u03b1] [OrderBot \u03b1] [DecidableRel (\u03b1 := \u03b1) Disjoint]", "{s t u} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2070 : DecidableEq \u03b1\ninst\u271d\u2079 : SemilatticeSup \u03b1\ninst\u271d\u2078 : DecidableEq \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : DistribLattice \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : DecidableRel Disjoint\n\u22a2 sorry \u2286 sorry \u2229 sorry"}, {"line": "simpa only [disjSups,product_inter,filter_inter_distrib] using image_inter_subset _ _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjSups_comm : s \u25cb t = t \u25cb s := by\n  aesop (add simp disjoint_comm, simp sup_comm)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sups.lean", "context": {"open": ["Function", "SetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily", "FinsetFamily"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [FunLike F \u03b1 \u03b2] [SupHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2] [FunLike F \u03b1 \u03b2] [InfHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1)", "{s t} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u}", "(s t u)", "[DecidableEq \u03b1]", "[DistribLattice \u03b1] (s t u : Finset \u03b1)", "[DecidableEq \u03b1]", "{\ud835\udc9c \u212c : Finset (Finset \u03b1)} {s t : Finset \u03b1}", "[DecidableEq \u03b1]", "[SemilatticeSup \u03b1] [OrderBot \u03b1] [DecidableRel (\u03b1 := \u03b1) Disjoint]", "{s t u} {a b c : \u03b1}", "(s t)", "{s s\u2081 s\u2082 t t\u2081 t\u2082}", "(s t)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = sorry"}, {"line": "aesop (add simp disjoint_comm, simp sup_comm)", "tactic_state": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9\u2078 : DecidableEq \u03b1\ninst\u271d\u00b9\u2077 : DecidableEq \u03b2\ninst\u271d\u00b9\u2076 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u2075 : SemilatticeSup \u03b2\ninst\u271d\u00b9\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b9\u00b3 : SupHomClass F \u03b1 \u03b2\ns\u271d\u00b2 s\u2081\u271d s\u2082\u271d t\u271d\u00b2 t\u2081\u271d t\u2082\u271d u\u271d\u00b9 v\u271d : Finset \u03b1\na\u271d b\u271d c\u271d : \u03b1\ninst\u271d\u00b9\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9\u00b9 : DecidableEq \u03b2\ninst\u271d\u00b9\u2070 : SemilatticeInf \u03b1\ninst\u271d\u2079 : SemilatticeInf \u03b2\ninst\u271d\u2078 : FunLike F \u03b1 \u03b2\ninst\u271d\u2077 : InfHomClass F \u03b1 \u03b2\ns\u271d\u00b9 s\u2081 s\u2082 t\u271d\u00b9 t\u2081 t\u2082 u\u271d v : Finset \u03b1\na b c : \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : DistribLattice \u03b1\ns\u271d t\u271d u : Finset \u03b1\ninst\u271d\u2074 : DecidableEq \u03b1\n\ud835\udc9c \u212c : Finset (Finset \u03b1)\ns t : Finset \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : DecidableRel Disjoint\n\u22a2 Sort u_4"}]}
{"declaration": "theorem injective_sym2 : Function.Injective (Finset.sym2 : Finset \u03b1 \u2192 _) := by\n  intro s t h\n  ext x\n  simpa using congr(s(x, x) \u2208 $h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sym.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 Function.Injective Finset.sym2"}, {"line": "intro s t h", "tactic_state": "\u03b1 : Type u_1\ns t : Finset \u03b1\nh : s.sym2 = t.sym2\n\u22a2 s = t"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\ns t : Finset \u03b1\nh : s.sym2 = t.sym2\nx : \u03b1\n\u22a2 x \u2208 s \u2194 x \u2208 t"}, {"line": "simpa using congr(s(x, x) \u2208 $h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_isDiag_mk_of_mem_offDiag {a : \u03b1 \u00d7 \u03b1} (h : a \u2208 s.offDiag) :\n    \u00ac (Sym2.mk a).IsDiag := by\n  rw [Sym2.isDiag_iff_proj_eq]\n  exact (mem_offDiag.1 h).2.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sym.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Finset \u03b1} {a b : \u03b1}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1 \u00d7 \u03b1\nh : a \u2208 s.offDiag\n\u22a2 \u00ac(Sym2.mk a).IsDiag"}, {"line": "rw [Sym2.isDiag_iff_proj_eq]", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1 \u00d7 \u03b1\nh : a \u2208 s.offDiag\n\u22a2 \u00aca.1 = a.2"}, {"line": "exact (mem_offDiag.1 h).2.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem diag_mem_sym2_iff : Sym2.diag a \u2208 s.sym2 \u2194 a \u2208 s := by simp [diag_mem_sym2_mem_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sym.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Finset \u03b1} {a b : \u03b1}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1]", "{m : Sym2 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 Sym2.diag a \u2208 s.sym2 \u2194 a \u2208 s"}, {"line": "simp [diag_mem_sym2_mem_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sym_eq_empty : s.sym n = \u2205 \u2194 n \u2260 0 \u2227 s = \u2205 := by\n  cases n\n  \u00b7 exact iff_of_false (singleton_ne_empty _) fun h \u21a6 (h.1 rfl).elim\n  \u00b7 refine \u27e8fun h \u21a6 \u27e8Nat.succ_ne_zero _, eq_empty_of_sym_eq_empty h\u27e9, ?_\u27e9\n    rintro \u27e8_, rfl\u27e9\n    exact sym_empty _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Sym.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "{s t : Finset \u03b1} {a b : \u03b1}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1]", "{m : Sym2 \u03b1}", "[DecidableEq \u03b1] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nn : \u2115\n\u22a2 s.sym n = \u2205 \u2194 n \u2260 0 \u2227 s = \u2205"}, {"line": "cases n", "tactic_state": "case zero\n\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\n\u22a2 s.sym 0 = \u2205 \u2194 0 \u2260 0 \u2227 s = \u2205\n---\ncase succ\n\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nn\u271d : \u2115\n\u22a2 s.sym (n\u271d + 1) = \u2205 \u2194 n\u271d + 1 \u2260 0 \u2227 s = \u2205"}, {"line": "\u00b7 exact iff_of_false (singleton_ne_empty _) fun h \u21a6 (h.1 rfl).elim", "tactic_state": "case succ\n\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nn\u271d : \u2115\n\u22a2 s.sym (n\u271d + 1) = \u2205 \u2194 n\u271d + 1 \u2260 0 \u2227 s = \u2205"}, {"line": "\u00b7 refine \u27e8fun h \u21a6 \u27e8Nat.succ_ne_zero _, eq_empty_of_sym_eq_empty h\u27e9, ?_\u27e9\n    rintro \u27e8_, rfl\u27e9\n    exact sym_empty _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inter_subset_inter {x y s t : Finset \u03b1} (h : x \u2286 y) (h' : s \u2286 t) : x \u2229 s \u2286 y \u2229 t := by\n  intro a a_in\n  rw [Finset.mem_inter] at a_in \u22a2\n  exact \u27e8h a_in.1, h' a_in.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Basic.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx y s t : Finset \u03b1\nh : x \u2286 y\nh' : s \u2286 t\n\u22a2 x \u2229 s \u2286 y \u2229 t"}, {"line": "intro a a_in", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx y s t : Finset \u03b1\nh : x \u2286 y\nh' : s \u2286 t\na : \u03b1\na_in : a \u2208 x \u2229 s\n\u22a2 a \u2208 y \u2229 t"}, {"line": "rw [Finset.mem_inter] at a_in \u22a2", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx y s t : Finset \u03b1\nh : x \u2286 y\nh' : s \u2286 t\na : \u03b1\na_in : a \u2208 x \u2227 a \u2208 s\n\u22a2 a \u2208 y \u2227 a \u2208 t"}, {"line": "exact \u27e8h a_in.1, h' a_in.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_congr {f g : \u03b2 \u2192 \u03b1} (hs : s\u2081 = s\u2082) (hfg : \u2200 a \u2208 s\u2082, f a = g a) :\n    s\u2081.sup f = s\u2082.sup g := by\n  subst hs\n  exact Finset.fold_congr hfg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : OrderBot \u03b1\ns\u2081 s\u2082 : Finset \u03b2\nf g : \u03b2 \u2192 \u03b1\nhs : s\u2081 = s\u2082\nhfg : \u2200 a \u2208 s\u2082, f a = g a\n\u22a2 s\u2081.sup f = s\u2082.sup g"}, {"line": "subst hs", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : OrderBot \u03b1\ns\u2081 : Finset \u03b2\nf g : \u03b2 \u2192 \u03b1\nhfg : \u2200 a \u2208 s\u2081, f a = g a\n\u22a2 s\u2081.sup f = s\u2081.sup g"}, {"line": "exact Finset.fold_congr hfg", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isLUB_sup : IsLUB (f '' s) (s.sup f) := by\n  simp +contextual [IsLUB, IsLeast, upperBounds, lowerBounds, le_sup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : OrderBot \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 IsLUB (f '' \u2191s) (s.sup f)"}, {"line": "simp +contextual [IsLUB, IsLeast, upperBounds, lowerBounds, le_sup]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : OrderBot \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u2200 a \u2208 s, f a \u2264 s.sup f"}]}
{"declaration": "lemma isLUB_sup_id {s : Finset \u03b1} : IsLUB s (s.sup id) := by simpa using isLUB_sup (f := id)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : OrderBot \u03b1\ns : Finset \u03b1\n\u22a2 IsLUB (\u2191s) (s.sup id)"}, {"line": "simpa using isLUB_sup (f := id)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_bot (s : Finset \u03b2) : (s.sup fun _ => \u22a5) = (\u22a5 : \u03b1) := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  \u00b7 exact sup_empty\n  \u00b7 exact sup_const hs _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : OrderBot \u03b1\ns : Finset \u03b2\n\u22a2 (s.sup fun x => \u22a5) = \u22a5"}, {"line": "obtain rfl | hs := s.eq_empty_or_nonempty", "tactic_state": "case inl\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : OrderBot \u03b1\n\u22a2 (\u2205.sup fun x => \u22a5) = \u22a5\n---\ncase inr\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : OrderBot \u03b1\ns : Finset \u03b2\nhs : s.Nonempty\n\u22a2 (s.sup fun x => \u22a5) = \u22a5"}, {"line": "\u00b7 exact sup_empty", "tactic_state": "case inr\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : OrderBot \u03b1\ns : Finset \u03b2\nhs : s.Nonempty\n\u22a2 (s.sup fun x => \u22a5) = \u22a5"}, {"line": "\u00b7 exact sup_const hs _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_le_of_le_directed {\u03b1 : Type*} [SemilatticeSup \u03b1] [OrderBot \u03b1] (s : Set \u03b1)\n    (hs : s.Nonempty) (hdir : DirectedOn (\u00b7 \u2264 \u00b7) s) (t : Finset \u03b1) :\n    (\u2200 x \u2208 t, \u2203 y \u2208 s, x \u2264 y) \u2192 \u2203 x \u2208 s, t.sup id \u2264 x := by\n  classical\n    induction t using Finset.induction_on with\n    | empty =>\n      simpa only [forall_prop_of_true,and_true,forall_prop_of_false,bot_le,not_false_iff,sup_empty,forall_true_iff,not_mem_empty]\n    | insert a r _ ih =>\n      intro h\n      have incs : (r : Set \u03b1) \u2286 \u2191(insert a r) := by\n        rw [Finset.coe_subset]\n        apply Finset.subset_insert\n      -- x \u2208 s is above the sup of r\n      obtain \u27e8x, \u27e8hxs, hsx_sup\u27e9\u27e9 := ih fun x hx => h x <| incs hx\n      -- y \u2208 s is above a\n      obtain \u27e8y, hys, hay\u27e9 := h a (Finset.mem_insert_self a r)\n      -- z \u2208 s is above x and y\n      obtain \u27e8z, hzs, \u27e8hxz, hyz\u27e9\u27e9 := hdir x hxs y hys\n      use z, hzs\n      rw [sup_insert]\n      rw [id]\n      rw [sup_le_iff]\n      exact \u27e8le_trans hay hyz, le_trans hsx_sup hxz\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b1\nhs : s.Nonempty\nhdir : DirectedOn (fun x1 x2 => x1 \u2264 x2) s\nt : Finset \u03b1\n\u22a2 (\u2200 x \u2208 t, \u2203 y \u2208 s, x \u2264 y) \u2192 \u2203 x \u2208 s, t.sup id \u2264 x"}, {"line": "classical\n    induction t using Finset.induction_on with\n    | empty =>\n      simpa only [forall_prop_of_true,and_true,forall_prop_of_false,bot_le,not_false_iff,sup_empty,forall_true_iff,not_mem_empty]\n    | insert a r _ ih =>\n      intro h\n      have incs : (r : Set \u03b1) \u2286 \u2191(insert a r) := by\n        rw [Finset.coe_subset]\n        apply Finset.subset_insert\n      obtain \u27e8x, \u27e8hxs, hsx_sup\u27e9\u27e9 := ih fun x hx => h x <| incs hx\n      obtain \u27e8y, hys, hay\u27e9 := h a (Finset.mem_insert_self a r)\n      obtain \u27e8z, hzs, \u27e8hxz, hyz\u27e9\u27e9 := hdir x hxs y hys\n      use z, hzs\n      rw [sup_insert]\n      rw [id]\n      rw [sup_le_iff]\n      exact \u27e8le_trans hay hyz, le_trans hsx_sup hxz\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_eq_bot_of_isEmpty [IsEmpty \u03b2] (f : \u03b2 \u2192 \u03b1) (S : Finset \u03b2) : S.sup f = \u22a5 := by\n  rw [Finset.sup_eq_bot_iff]\n  exact fun x _ => False.elim <| IsEmpty.false x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : IsEmpty \u03b2\nf : \u03b2 \u2192 \u03b1\nS : Finset \u03b2\n\u22a2 S.sup f = \u22a5"}, {"line": "rw [Finset.sup_eq_bot_iff]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : IsEmpty \u03b2\nf : \u03b2 \u2192 \u03b1\nS : Finset \u03b2\n\u22a2 \u2200 s \u2208 S, f s = \u22a5"}, {"line": "exact fun x _ => False.elim <| IsEmpty.false x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_sup_dite_pos (p : \u03b2 \u2192 Prop) [DecidablePred p]\n    {f : (b : \u03b2) \u2192 p b \u2192 \u03b1} {g : (b : \u03b2) \u2192 \u00acp b \u2192 \u03b1} {b : \u03b2} (h\u2080 : b \u2208 s) (h\u2081 : p b) :\n    f b h\u2081 \u2264 s.sup fun i \u21a6 if h : p i then f i h else g i h := by\n  have : f b h\u2081 = (fun i \u21a6 if h : p i then f i h else g i h) b := by simp [h\u2081]\n  rw [this]\n  apply le_sup h\u2080\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ns : Finset \u03b2\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : (b : \u03b2) \u2192 p b \u2192 \u03b1\ng : (b : \u03b2) \u2192 \u00acp b \u2192 \u03b1\nb : \u03b2\nh\u2080 : b \u2208 s\nh\u2081 : p b\n\u22a2 f b h\u2081 \u2264 s.sup fun i => if h : p i then f i h else g i h"}, {"line": "have : f b h\u2081 = (fun i \u21a6 if h : p i then f i h else g i h) b := by simp [h\u2081]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ns : Finset \u03b2\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : (b : \u03b2) \u2192 p b \u2192 \u03b1\ng : (b : \u03b2) \u2192 \u00acp b \u2192 \u03b1\nb : \u03b2\nh\u2080 : b \u2208 s\nh\u2081 : p b\nthis : f b h\u2081 = (fun i => sorry) b\n\u22a2 f b h\u2081 \u2264 s.sup fun i => if h : p i then f i h else g i h"}, {"line": "rw [this]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ns : Finset \u03b2\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : (b : \u03b2) \u2192 p b \u2192 \u03b1\ng : (b : \u03b2) \u2192 \u00acp b \u2192 \u03b1\nb : \u03b2\nh\u2080 : b \u2208 s\nh\u2081 : p b\nthis : f b h\u2081 = (fun i => sorry) b\n\u22a2 (fun i => sorry) b \u2264 s.sup fun i => if h : p i then f i h else g i h"}, {"line": "apply le_sup h\u2080", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_sup_dite_neg (p : \u03b2 \u2192 Prop) [DecidablePred p]\n    {f : (b : \u03b2) \u2192 p b \u2192 \u03b1} {g : (b : \u03b2) \u2192 \u00acp b \u2192 \u03b1} {b : \u03b2} (h\u2080 : b \u2208 s) (h\u2081 : \u00acp b) :\n    g b h\u2081 \u2264 s.sup fun i \u21a6 if h : p i then f i h else g i h := by\n  have : g b h\u2081 = (fun i \u21a6 if h : p i then f i h else g i h) b := by simp [h\u2081]\n  rw [this]\n  apply le_sup h\u2080\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ns : Finset \u03b2\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : (b : \u03b2) \u2192 p b \u2192 \u03b1\ng : (b : \u03b2) \u2192 \u00acp b \u2192 \u03b1\nb : \u03b2\nh\u2080 : b \u2208 s\nh\u2081 : \u00acp b\n\u22a2 g b h\u2081 \u2264 s.sup fun i => if h : p i then f i h else g i h"}, {"line": "have : g b h\u2081 = (fun i \u21a6 if h : p i then f i h else g i h) b := by simp [h\u2081]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ns : Finset \u03b2\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : (b : \u03b2) \u2192 p b \u2192 \u03b1\ng : (b : \u03b2) \u2192 \u00acp b \u2192 \u03b1\nb : \u03b2\nh\u2080 : b \u2208 s\nh\u2081 : \u00acp b\nthis : g b h\u2081 = (fun i => sorry) b\n\u22a2 g b h\u2081 \u2264 s.sup fun i => if h : p i then f i h else g i h"}, {"line": "rw [this]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ns : Finset \u03b2\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : (b : \u03b2) \u2192 p b \u2192 \u03b1\ng : (b : \u03b2) \u2192 \u00acp b \u2192 \u03b1\nb : \u03b2\nh\u2080 : b \u2208 s\nh\u2081 : \u00acp b\nthis : g b h\u2081 = (fun i => sorry) b\n\u22a2 (fun i => sorry) b \u2264 s.sup fun i => if h : p i then f i h else g i h"}, {"line": "apply le_sup h\u2080", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_id_eq_sSup [CompleteLattice \u03b1] (s : Finset \u03b1) : s.sup id = sSup s := by\n  simp [sSup_eq_iSup, sup_eq_iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Finset \u03b1\n\u22a2 s.sup id = sSup \u2191s"}, {"line": "simp [sSup_eq_iSup, sup_eq_iSup]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Finset \u03b1\n\u22a2 s.sup id = \u2a06 a \u2208 s, a"}]}
{"declaration": "theorem inf_congr {f g : \u03b2 \u2192 \u03b1} (hs : s\u2081 = s\u2082) (hfg : \u2200 a \u2208 s\u2082, f a = g a) :\n    s\u2081.inf f = s\u2082.inf g := by\n  subst hs\n  exact Finset.fold_congr hfg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderTop \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b3 : SemilatticeSup \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderTop \u03b1\ns\u2081 s\u2082 : Finset \u03b2\nf g : \u03b2 \u2192 \u03b1\nhs : s\u2081 = s\u2082\nhfg : \u2200 a \u2208 s\u2082, f a = g a\n\u22a2 s\u2081.inf f = s\u2082.inf g"}, {"line": "subst hs", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b3 : SemilatticeSup \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderTop \u03b1\ns\u2081 : Finset \u03b2\nf g : \u03b2 \u2192 \u03b1\nhfg : \u2200 a \u2208 s\u2081, f a = g a\n\u22a2 s\u2081.inf f = s\u2081.inf g"}, {"line": "exact Finset.fold_congr hfg", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isGLB_inf : IsGLB (f '' s) (s.inf f) := by\n  simp +contextual [IsGLB, IsGreatest, upperBounds, lowerBounds, inf_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderTop \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b3 : SemilatticeSup \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderTop \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 IsGLB (f '' \u2191s) (s.inf f)"}, {"line": "simp +contextual [IsGLB, IsGreatest, upperBounds, lowerBounds, inf_le]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b3 : SemilatticeSup \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderTop \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u2200 a \u2208 s, s.inf f \u2264 f a"}]}
{"declaration": "lemma isGLB_inf_id {s : Finset \u03b1} : IsGLB s (s.inf id) := by simpa using isGLB_inf (f := id)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderTop \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : SemilatticeSup \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderTop \u03b1\ns : Finset \u03b1\n\u22a2 IsGLB (\u2191s) (s.inf id)"}, {"line": "simpa using isGLB_inf (f := id)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_dite_pos_le (p : \u03b2 \u2192 Prop) [DecidablePred p]\n    {f : (b : \u03b2) \u2192 p b \u2192 \u03b1} {g : (b : \u03b2) \u2192 \u00acp b \u2192 \u03b1} {b : \u03b2} (h\u2080 : b \u2208 s) (h\u2081 : p b) :\n    (s.inf fun i \u21a6 if h : p i then f i h else g i h) \u2264 f b h\u2081 := by\n  have : f b h\u2081 = (fun i \u21a6 if h : p i then f i h else g i h) b := by simp [h\u2081]\n  rw [this]\n  apply inf_le h\u2080\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderTop \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2074 : SemilatticeSup \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ns : Finset \u03b2\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : (b : \u03b2) \u2192 p b \u2192 \u03b1\ng : (b : \u03b2) \u2192 \u00acp b \u2192 \u03b1\nb : \u03b2\nh\u2080 : b \u2208 s\nh\u2081 : p b\n\u22a2 (s.inf fun i => if h : p i then f i h else g i h) \u2264 f b h\u2081"}, {"line": "have : f b h\u2081 = (fun i \u21a6 if h : p i then f i h else g i h) b := by simp [h\u2081]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2074 : SemilatticeSup \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ns : Finset \u03b2\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : (b : \u03b2) \u2192 p b \u2192 \u03b1\ng : (b : \u03b2) \u2192 \u00acp b \u2192 \u03b1\nb : \u03b2\nh\u2080 : b \u2208 s\nh\u2081 : p b\nthis : f b h\u2081 = (fun i => sorry) b\n\u22a2 (s.inf fun i => if h : p i then f i h else g i h) \u2264 f b h\u2081"}, {"line": "rw [this]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2074 : SemilatticeSup \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ns : Finset \u03b2\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : (b : \u03b2) \u2192 p b \u2192 \u03b1\ng : (b : \u03b2) \u2192 \u00acp b \u2192 \u03b1\nb : \u03b2\nh\u2080 : b \u2208 s\nh\u2081 : p b\nthis : f b h\u2081 = (fun i => sorry) b\n\u22a2 (s.inf fun i => if h : p i then f i h else g i h) \u2264 (fun i => sorry) b"}, {"line": "apply inf_le h\u2080", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_dite_neg_le (p : \u03b2 \u2192 Prop) [DecidablePred p]\n    {f : (b : \u03b2) \u2192 p b \u2192 \u03b1} {g : (b : \u03b2) \u2192 \u00acp b \u2192 \u03b1} {b : \u03b2} (h\u2080 : b \u2208 s) (h\u2081 : \u00acp b) :\n    (s.inf fun i \u21a6 if h : p i then f i h else g i h) \u2264 g b h\u2081 := by\n  have : g b h\u2081 = (fun i \u21a6 if h : p i then f i h else g i h) b := by simp [h\u2081]\n  rw [this]\n  apply inf_le h\u2080\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderTop \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2074 : SemilatticeSup \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ns : Finset \u03b2\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : (b : \u03b2) \u2192 p b \u2192 \u03b1\ng : (b : \u03b2) \u2192 \u00acp b \u2192 \u03b1\nb : \u03b2\nh\u2080 : b \u2208 s\nh\u2081 : \u00acp b\n\u22a2 (s.inf fun i => if h : p i then f i h else g i h) \u2264 g b h\u2081"}, {"line": "have : g b h\u2081 = (fun i \u21a6 if h : p i then f i h else g i h) b := by simp [h\u2081]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2074 : SemilatticeSup \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ns : Finset \u03b2\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : (b : \u03b2) \u2192 p b \u2192 \u03b1\ng : (b : \u03b2) \u2192 \u00acp b \u2192 \u03b1\nb : \u03b2\nh\u2080 : b \u2208 s\nh\u2081 : \u00acp b\nthis : g b h\u2081 = (fun i => sorry) b\n\u22a2 (s.inf fun i => if h : p i then f i h else g i h) \u2264 g b h\u2081"}, {"line": "rw [this]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2074 : SemilatticeSup \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ns : Finset \u03b2\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : (b : \u03b2) \u2192 p b \u2192 \u03b1\ng : (b : \u03b2) \u2192 \u00acp b \u2192 \u03b1\nb : \u03b2\nh\u2080 : b \u2208 s\nh\u2081 : \u00acp b\nthis : g b h\u2081 = (fun i => sorry) b\n\u22a2 (s.inf fun i => if h : p i then f i h else g i h) \u2264 (fun i => sorry) b"}, {"line": "apply inf_le h\u2080", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Nonempty.sup_eq_top_iff {\u03b1 : Type*} [LinearOrder \u03b1] [BoundedOrder \u03b1]\n    {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} (hs : s.Nonempty) : s.sup f = \u22a4 \u2194 \u2203 b \u2208 s, f b = \u22a4 := by\n  cases subsingleton_or_nontrivial \u03b1\n  \u00b7 simpa [Subsingleton.elim _ (\u22a4 : \u03b1)]\n  \u00b7 exact Finset.sup_eq_top_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderTop \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[DistribLattice \u03b1]", "[OrderBot \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1} {a : \u03b1}", "[OrderTop \u03b1] {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1} {s : Finset \u03b9} {t : Finset \u03ba} {a : \u03b1}", "[BooleanAlgebra \u03b1] {s : Finset \u03b9}", "[LinearOrder \u03b1]", "[OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_5\n\u03b1 : Type u_7\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : BoundedOrder \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.Nonempty\n\u22a2 s.sup f = \u22a4 \u2194 \u2203 b \u2208 s, f b = \u22a4"}, {"line": "cases subsingleton_or_nontrivial \u03b1", "tactic_state": "case inl\n\u03b9 : Type u_5\n\u03b1 : Type u_7\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : BoundedOrder \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.Nonempty\nh\u271d : Subsingleton \u03b1\n\u22a2 s.sup f = \u22a4 \u2194 \u2203 b \u2208 s, f b = \u22a4\n---\ncase inr\n\u03b9 : Type u_5\n\u03b1 : Type u_7\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : BoundedOrder \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.Nonempty\nh\u271d : Nontrivial \u03b1\n\u22a2 s.sup f = \u22a4 \u2194 \u2203 b \u2208 s, f b = \u22a4"}, {"line": "\u00b7 simpa [Subsingleton.elim _ (\u22a4 : \u03b1)]", "tactic_state": "case inr\n\u03b9 : Type u_5\n\u03b1 : Type u_7\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : BoundedOrder \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.Nonempty\nh\u271d : Nontrivial \u03b1\n\u22a2 s.sup f = \u22a4 \u2194 \u2203 b \u2208 s, f b = \u22a4"}, {"line": "\u00b7 exact Finset.sup_eq_top_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup'_cons {b : \u03b2} {hb : b \u2209 s} :\n    (cons b s hb).sup' (cons_nonempty hb) f = f b \u2294 s.sup' H f := by\n  rw [\u2190 WithBot.coe_eq_coe]\n  simp [WithBot.coe_sup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderTop \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[DistribLattice \u03b1]", "[OrderBot \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1} {a : \u03b1}", "[OrderTop \u03b1] {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1} {s : Finset \u03b9} {t : Finset \u03ba} {a : \u03b1}", "[BooleanAlgebra \u03b1] {s : Finset \u03b9}", "[LinearOrder \u03b1]", "[OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[OrderTop \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeSup \u03b1]", "{s : Finset \u03b2} (H : s.Nonempty) (f : \u03b2 \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9\u00b9 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : SemilatticeInf \u03b1\ninst\u271d\u2078 : OrderTop \u03b1\ninst\u271d\u2077 : DistribLattice \u03b1\ninst\u271d\u2076 : OrderBot \u03b1\ninst\u271d\u2075 : OrderTop \u03b1\ninst\u271d\u2074 : BooleanAlgebra \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ninst\u271d : SemilatticeSup \u03b1\ns : Finset \u03b2\nH : s.Nonempty\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\nhb : b \u2209 s\n\u22a2 sorry = f b \u2294 s.sup' H f"}, {"line": "rw [\u2190 WithBot.coe_eq_coe]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9\u00b9 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : SemilatticeInf \u03b1\ninst\u271d\u2078 : OrderTop \u03b1\ninst\u271d\u2077 : DistribLattice \u03b1\ninst\u271d\u2076 : OrderBot \u03b1\ninst\u271d\u2075 : OrderTop \u03b1\ninst\u271d\u2074 : BooleanAlgebra \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ninst\u271d : SemilatticeSup \u03b1\ns : Finset \u03b2\nH : s.Nonempty\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\nhb : b \u2209 s\n\u22a2 \u2191sorry = \u2191(f b \u2294 s.sup' H f)"}, {"line": "simp [WithBot.coe_sup]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9\u00b9 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : SemilatticeInf \u03b1\ninst\u271d\u2078 : OrderTop \u03b1\ninst\u271d\u2077 : DistribLattice \u03b1\ninst\u271d\u2076 : OrderBot \u03b1\ninst\u271d\u2075 : OrderTop \u03b1\ninst\u271d\u2074 : BooleanAlgebra \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ninst\u271d : SemilatticeSup \u03b1\ns : Finset \u03b2\nH : s.Nonempty\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\nhb : b \u2209 s\n\u22a2 \u2191(sorry ()) = \u2191(f b) \u2294 s.sup (WithBot.some \u2218 f)"}]}
{"declaration": "theorem sup'_insert [DecidableEq \u03b2] {b : \u03b2} :\n    (insert b s).sup' (insert_nonempty _ _) f = f b \u2294 s.sup' H f := by\n  rw [\u2190 WithBot.coe_eq_coe]\n  simp [WithBot.coe_sup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderTop \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[DistribLattice \u03b1]", "[OrderBot \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1} {a : \u03b1}", "[OrderTop \u03b1] {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1} {s : Finset \u03b9} {t : Finset \u03ba} {a : \u03b1}", "[BooleanAlgebra \u03b1] {s : Finset \u03b9}", "[LinearOrder \u03b1]", "[OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[OrderTop \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeSup \u03b1]", "{s : Finset \u03b2} (H : s.Nonempty) (f : \u03b2 \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u00b9 : OrderBot \u03b1\ninst\u271d\u00b9\u2070 : SemilatticeInf \u03b1\ninst\u271d\u2079 : OrderTop \u03b1\ninst\u271d\u2078 : DistribLattice \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : OrderTop \u03b1\ninst\u271d\u2075 : BooleanAlgebra \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : OrderTop \u03b1\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ns : Finset \u03b2\nH : s.Nonempty\nf : \u03b2 \u2192 \u03b1\nx\u271d : Sort u_7\ninsert_nonempty : x\u271d\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\n\u22a2 (insert b s).sup' \u22ef f = f b \u2294 s.sup' H f"}, {"line": "rw [\u2190 WithBot.coe_eq_coe]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u00b9 : OrderBot \u03b1\ninst\u271d\u00b9\u2070 : SemilatticeInf \u03b1\ninst\u271d\u2079 : OrderTop \u03b1\ninst\u271d\u2078 : DistribLattice \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : OrderTop \u03b1\ninst\u271d\u2075 : BooleanAlgebra \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : OrderTop \u03b1\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ns : Finset \u03b2\nH : s.Nonempty\nf : \u03b2 \u2192 \u03b1\nx\u271d : Sort u_7\ninsert_nonempty : x\u271d\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\n\u22a2 \u2191((insert b s).sup' \u22ef f) = \u2191(f b \u2294 s.sup' H f)"}, {"line": "simp [WithBot.coe_sup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_sup'_eq_sup'_comp [SemilatticeSup \u03b3] {s : Finset \u03b2} (H : s.Nonempty) {f : \u03b2 \u2192 \u03b1}\n    (g : \u03b1 \u2192 \u03b3) (g_sup : \u2200 x y, g (x \u2294 y) = g x \u2294 g y) : g (s.sup' H f) = s.sup' H (g \u2218 f) := by\n  refine H.cons_induction ?_ ?_ <;> intros <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderTop \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[DistribLattice \u03b1]", "[OrderBot \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1} {a : \u03b1}", "[OrderTop \u03b1] {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1} {s : Finset \u03b9} {t : Finset \u03ba} {a : \u03b1}", "[BooleanAlgebra \u03b1] {s : Finset \u03b9}", "[LinearOrder \u03b1]", "[OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[OrderTop \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeSup \u03b1]", "{s : Finset \u03b2} (H : s.Nonempty) (f : \u03b2 \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u00b9 : OrderBot \u03b1\ninst\u271d\u00b9\u2070 : SemilatticeInf \u03b1\ninst\u271d\u2079 : OrderTop \u03b1\ninst\u271d\u2078 : DistribLattice \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : OrderTop \u03b1\ninst\u271d\u2075 : BooleanAlgebra \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : OrderTop \u03b1\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : SemilatticeSup \u03b3\ns : Finset \u03b2\nH : s.Nonempty\nf : \u03b2 \u2192 \u03b1\ng : \u03b1 \u2192 \u03b3\ng_sup : \u2200 (x y : \u03b1), g (x \u2294 y) = g x \u2294 g y\n\u22a2 g (s.sup' H f) = s.sup' H (g \u2218 f)"}, {"line": "refine H.cons_induction ?_ ?_ <;> intros <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.map_finset_sup' [SemilatticeSup \u03b2] [FunLike F \u03b1 \u03b2] [SupHomClass F \u03b1 \u03b2]\n    (f : F) {s : Finset \u03b9} (hs) (g : \u03b9 \u2192 \u03b1) :\n    f (s.sup' hs g) = s.sup' hs (f \u2218 g) := by\n  refine hs.cons_induction ?_ ?_ <;> intros <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderTop \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[DistribLattice \u03b1]", "[OrderBot \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1} {a : \u03b1}", "[OrderTop \u03b1] {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1} {s : Finset \u03b9} {t : Finset \u03ba} {a : \u03b1}", "[BooleanAlgebra \u03b1] {s : Finset \u03b9}", "[LinearOrder \u03b1]", "[OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[OrderTop \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeSup \u03b1]", "{s : Finset \u03b2} (H : s.Nonempty) (f : \u03b2 \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b9 : Type u_5\ninst\u271d\u00b9\u2074 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u00b3 : OrderBot \u03b1\ninst\u271d\u00b9\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9\u00b9 : OrderTop \u03b1\ninst\u271d\u00b9\u2070 : DistribLattice \u03b1\ninst\u271d\u2079 : OrderBot \u03b1\ninst\u271d\u2078 : OrderTop \u03b1\ninst\u271d\u2077 : BooleanAlgebra \u03b1\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : OrderTop \u03b1\ninst\u271d\u00b3 : SemilatticeSup \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : SupHomClass F \u03b1 \u03b2\nf : F\ns : Finset \u03b9\nhs : s.Nonempty\ng : \u03b9 \u2192 \u03b1\n\u22a2 f (s.sup' hs g) = s.sup' hs (\u21d1f \u2218 g)"}, {"line": "refine hs.cons_induction ?_ ?_ <;> intros <;> simp [*]", "tactic_state": "case refine_2\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b9 : Type u_5\ninst\u271d\u00b9\u2074 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u00b3 : OrderBot \u03b1\ninst\u271d\u00b9\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9\u00b9 : OrderTop \u03b1\ninst\u271d\u00b9\u2070 : DistribLattice \u03b1\ninst\u271d\u2079 : OrderBot \u03b1\ninst\u271d\u2078 : OrderTop \u03b1\ninst\u271d\u2077 : BooleanAlgebra \u03b1\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : OrderTop \u03b1\ninst\u271d\u00b3 : SemilatticeSup \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : SupHomClass F \u03b1 \u03b2\nf : F\ns : Finset \u03b9\nhs : s.Nonempty\ng : \u03b9 \u2192 \u03b1\na\u271d\u00b9 : \u03b9\ns\u271d : Finset \u03b9\nh\u271d : a\u271d\u00b9 \u2209 s\u271d\nhs\u271d : s\u271d.Nonempty\na\u271d : f (s\u271d.sup' hs\u271d g) = s\u271d.sup' hs\u271d (\u21d1f \u2218 g)\n\u22a2 f (g a\u271d\u00b9 \u2294 s\u271d.sup' hs\u271d g) = f (g a\u271d\u00b9) \u2294 s\u271d.sup' hs\u271d fun x => f (g x)"}]}
{"declaration": "theorem _root_.map_finset_inf' [SemilatticeInf \u03b2] [FunLike F \u03b1 \u03b2] [InfHomClass F \u03b1 \u03b2]\n    (f : F) {s : Finset \u03b9} (hs) (g : \u03b9 \u2192 \u03b1) :\n    f (s.inf' hs g) = s.inf' hs (f \u2218 g) := by\n  refine hs.cons_induction ?_ ?_ <;> intros <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderTop \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[DistribLattice \u03b1]", "[OrderBot \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1} {a : \u03b1}", "[OrderTop \u03b1] {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1} {s : Finset \u03b9} {t : Finset \u03ba} {a : \u03b1}", "[BooleanAlgebra \u03b1] {s : Finset \u03b9}", "[LinearOrder \u03b1]", "[OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[OrderTop \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeSup \u03b1]", "{s : Finset \u03b2} (H : s.Nonempty) (f : \u03b2 \u2192 \u03b1)", "[SemilatticeInf \u03b1]", "{s : Finset \u03b2} (H : s.Nonempty) (f : \u03b2 \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b9 : Type u_5\ninst\u271d\u00b9\u2075 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u2074 : OrderBot \u03b1\ninst\u271d\u00b9\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b9\u00b2 : OrderTop \u03b1\ninst\u271d\u00b9\u00b9 : DistribLattice \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : OrderTop \u03b1\ninst\u271d\u2078 : BooleanAlgebra \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : OrderBot \u03b1\ninst\u271d\u2075 : OrderTop \u03b1\ninst\u271d\u2074 : SemilatticeSup \u03b1\ninst\u271d\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : InfHomClass F \u03b1 \u03b2\nf : F\ns : Finset \u03b9\nhs : s.Nonempty\ng : \u03b9 \u2192 \u03b1\n\u22a2 f (s.inf' hs g) = s.inf' hs (\u21d1f \u2218 g)"}, {"line": "refine hs.cons_induction ?_ ?_ <;> intros <;> simp [*]", "tactic_state": "case refine_2\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b9 : Type u_5\ninst\u271d\u00b9\u2075 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u2074 : OrderBot \u03b1\ninst\u271d\u00b9\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b9\u00b2 : OrderTop \u03b1\ninst\u271d\u00b9\u00b9 : DistribLattice \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : OrderTop \u03b1\ninst\u271d\u2078 : BooleanAlgebra \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : OrderBot \u03b1\ninst\u271d\u2075 : OrderTop \u03b1\ninst\u271d\u2074 : SemilatticeSup \u03b1\ninst\u271d\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : InfHomClass F \u03b1 \u03b2\nf : F\ns : Finset \u03b9\nhs : s.Nonempty\ng : \u03b9 \u2192 \u03b1\na\u271d\u00b9 : \u03b9\ns\u271d : Finset \u03b9\nh\u271d : a\u271d\u00b9 \u2209 s\u271d\nhs\u271d : s\u271d.Nonempty\na\u271d : f (s\u271d.inf' hs\u271d g) = s\u271d.inf' hs\u271d (\u21d1f \u2218 g)\n\u22a2 f (g a\u271d\u00b9 \u2293 s\u271d.inf' hs\u271d g) = f (g a\u271d\u00b9) \u2293 s\u271d.inf' hs\u271d fun x => f (g x)"}]}
{"declaration": "theorem count_finset_sup [DecidableEq \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 Multiset \u03b2) (b : \u03b2) :\n    count b (s.sup f) = s.sup fun a => count b (f a) := by\n  letI := Classical.decEq \u03b1\n  refine s.induction ?_ ?_\n  \u00b7 exact count_zero _\n  \u00b7 intro i s _ ih\n    rw [Finset.sup_insert]\n    rw [sup_eq_union]\n    rw [count_union]\n    rw [Finset.sup_insert]\n    rw [ih]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderTop \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[DistribLattice \u03b1]", "[OrderBot \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1} {a : \u03b1}", "[OrderTop \u03b1] {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1} {s : Finset \u03b9} {t : Finset \u03ba} {a : \u03b1}", "[BooleanAlgebra \u03b1] {s : Finset \u03b9}", "[LinearOrder \u03b1]", "[OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[OrderTop \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeSup \u03b1]", "{s : Finset \u03b2} (H : s.Nonempty) (f : \u03b2 \u2192 \u03b1)", "[SemilatticeInf \u03b1]", "{s : Finset \u03b2} (H : s.Nonempty) (f : \u03b2 \u2192 \u03b1)", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "[SemilatticeInf \u03b1] [OrderTop \u03b1]", "[DistribLattice \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} (hs : s.Nonempty) (ht : t.Nonempty)", "[LinearOrder \u03b1] {s : Finset \u03b9} (H : s.Nonempty) {f : \u03b9 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9\u2079 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u2078 : OrderBot \u03b1\ninst\u271d\u00b9\u2077 : SemilatticeInf \u03b1\ninst\u271d\u00b9\u2076 : OrderTop \u03b1\ninst\u271d\u00b9\u2075 : DistribLattice \u03b1\ninst\u271d\u00b9\u2074 : OrderBot \u03b1\ninst\u271d\u00b9\u00b3 : OrderTop \u03b1\ninst\u271d\u00b9\u00b2 : BooleanAlgebra \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : OrderTop \u03b1\ninst\u271d\u2078 : SemilatticeSup \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\ninst\u271d\u2076 : SemilatticeSup \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : SemilatticeInf \u03b1\ninst\u271d\u00b3 : OrderTop \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : DecidableEq \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 Multiset \u03b2\nb : \u03b2\n\u22a2 count b (s.sup f) = s.sup fun a => count b (f a)"}, {"line": "letI := Classical.decEq \u03b1", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9\u2079 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u2078 : OrderBot \u03b1\ninst\u271d\u00b9\u2077 : SemilatticeInf \u03b1\ninst\u271d\u00b9\u2076 : OrderTop \u03b1\ninst\u271d\u00b9\u2075 : DistribLattice \u03b1\ninst\u271d\u00b9\u2074 : OrderBot \u03b1\ninst\u271d\u00b9\u00b3 : OrderTop \u03b1\ninst\u271d\u00b9\u00b2 : BooleanAlgebra \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : OrderTop \u03b1\ninst\u271d\u2078 : SemilatticeSup \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\ninst\u271d\u2076 : SemilatticeSup \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : SemilatticeInf \u03b1\ninst\u271d\u00b3 : OrderTop \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : DecidableEq \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 Multiset \u03b2\nb : \u03b2\nthis : DecidableEq \u03b1 := Classical.decEq \u03b1\n\u22a2 count b (s.sup f) = s.sup fun a => count b (f a)"}, {"line": "refine s.induction ?_ ?_", "tactic_state": "case refine_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9\u2079 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u2078 : OrderBot \u03b1\ninst\u271d\u00b9\u2077 : SemilatticeInf \u03b1\ninst\u271d\u00b9\u2076 : OrderTop \u03b1\ninst\u271d\u00b9\u2075 : DistribLattice \u03b1\ninst\u271d\u00b9\u2074 : OrderBot \u03b1\ninst\u271d\u00b9\u00b3 : OrderTop \u03b1\ninst\u271d\u00b9\u00b2 : BooleanAlgebra \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : OrderTop \u03b1\ninst\u271d\u2078 : SemilatticeSup \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\ninst\u271d\u2076 : SemilatticeSup \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : SemilatticeInf \u03b1\ninst\u271d\u00b3 : OrderTop \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : DecidableEq \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 Multiset \u03b2\nb : \u03b2\nthis : DecidableEq \u03b1 := Classical.decEq \u03b1\n\u22a2 count b (\u2205.sup f) = \u2205.sup fun a => count b (f a)\n---\ncase refine_2\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9\u2079 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u2078 : OrderBot \u03b1\ninst\u271d\u00b9\u2077 : SemilatticeInf \u03b1\ninst\u271d\u00b9\u2076 : OrderTop \u03b1\ninst\u271d\u00b9\u2075 : DistribLattice \u03b1\ninst\u271d\u00b9\u2074 : OrderBot \u03b1\ninst\u271d\u00b9\u00b3 : OrderTop \u03b1\ninst\u271d\u00b9\u00b2 : BooleanAlgebra \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : OrderTop \u03b1\ninst\u271d\u2078 : SemilatticeSup \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\ninst\u271d\u2076 : SemilatticeSup \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : SemilatticeInf \u03b1\ninst\u271d\u00b3 : OrderTop \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : DecidableEq \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 Multiset \u03b2\nb : \u03b2\nthis : DecidableEq \u03b1 := Classical.decEq \u03b1\n\u22a2 \u2200 (a : \u03b1) (s : Finset \u03b1),\n    a \u2209 s \u2192\n      (count b (s.sup f) = s.sup fun a => count b (f a)) \u2192\n        count b ((insert a s).sup f) = (insert a s).sup fun a => count b (f a)"}, {"line": "\u00b7 exact count_zero _", "tactic_state": "case refine_2\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9\u2079 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u2078 : OrderBot \u03b1\ninst\u271d\u00b9\u2077 : SemilatticeInf \u03b1\ninst\u271d\u00b9\u2076 : OrderTop \u03b1\ninst\u271d\u00b9\u2075 : DistribLattice \u03b1\ninst\u271d\u00b9\u2074 : OrderBot \u03b1\ninst\u271d\u00b9\u00b3 : OrderTop \u03b1\ninst\u271d\u00b9\u00b2 : BooleanAlgebra \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : OrderTop \u03b1\ninst\u271d\u2078 : SemilatticeSup \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\ninst\u271d\u2076 : SemilatticeSup \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : SemilatticeInf \u03b1\ninst\u271d\u00b3 : OrderTop \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : DecidableEq \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 Multiset \u03b2\nb : \u03b2\nthis : DecidableEq \u03b1 := Classical.decEq \u03b1\n\u22a2 \u2200 (a : \u03b1) (s : Finset \u03b1),\n    a \u2209 s \u2192\n      (count b (s.sup f) = s.sup fun a => count b (f a)) \u2192\n        count b ((insert a s).sup f) = (insert a s).sup fun a => count b (f a)"}, {"line": "\u00b7 intro i s _ ih\n    rw [Finset.sup_insert]\n    rw [sup_eq_union]\n    rw [count_union]\n    rw [Finset.sup_insert]\n    rw [ih]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_sup {\u03b1 \u03b2} [DecidableEq \u03b2] {s : Finset \u03b1} {f : \u03b1 \u2192 Multiset \u03b2} {x : \u03b2} :\n    x \u2208 s.sup f \u2194 \u2203 v \u2208 s, x \u2208 f v := by\n  induction s using Finset.cons_induction <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Fold.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderTop \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[DistribLattice \u03b1]", "[OrderBot \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1} {a : \u03b1}", "[OrderTop \u03b1] {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1} {s : Finset \u03b9} {t : Finset \u03ba} {a : \u03b1}", "[BooleanAlgebra \u03b1] {s : Finset \u03b9}", "[LinearOrder \u03b1]", "[OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[OrderTop \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[SemilatticeSup \u03b1]", "{s : Finset \u03b2} (H : s.Nonempty) (f : \u03b2 \u2192 \u03b1)", "[SemilatticeInf \u03b1]", "{s : Finset \u03b2} (H : s.Nonempty) (f : \u03b2 \u2192 \u03b1)", "[SemilatticeSup \u03b1] [OrderBot \u03b1]", "[SemilatticeInf \u03b1] [OrderTop \u03b1]", "[DistribLattice \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} (hs : s.Nonempty) (ht : t.Nonempty)", "[LinearOrder \u03b1] {s : Finset \u03b9} (H : s.Nonempty) {f : \u03b9 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\n\u03b2 : Type u_8\ninst\u271d : DecidableEq \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 Multiset \u03b2\nx : \u03b2\n\u22a2 x \u2208 s.sup f \u2194 \u2203 v \u2208 s, x \u2208 f v"}, {"line": "induction s using Finset.cons_induction <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma singleton_inter {a : \u03b1} {s : Finset \u03b1} :\n    {a} \u2229 s = if a \u2208 s then {a} else \u2205 := by\n  split_ifs with h <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Lemmas.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Finset \u03b1\n\u22a2 {a} \u2229 s = if a \u2208 s then {a} else \u2205"}, {"line": "split_ifs with h <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inter_singleton {a : \u03b1} {s : Finset \u03b1} :\n    s \u2229 {a} = if a \u2208 s then {a} else \u2205 := by\n  split_ifs with h <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Lemmas.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Finset \u03b1\n\u22a2 s \u2229 {a} = if a \u2208 s then {a} else \u2205"}, {"line": "split_ifs with h <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_append : toFinset (l ++ l') = l.toFinset \u222a l'.toFinset := by\n  induction' l with hd tl hl\n  \u00b7 simp\n  \u00b7 simp [hl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Lattice/Lemmas.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {l l' : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nl l' : List \u03b1\n\u22a2 (\u2191(l ++ l')).toFinset = l.toFinset \u222a l'.toFinset"}, {"line": "induction' l with hd tl hl", "tactic_state": "case nil\n\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nl l' : List \u03b1\n\u22a2 (\u2191([] ++ l')).toFinset = [].toFinset \u222a l'.toFinset\n---\ncase cons\n\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nl l' : List \u03b1\nhd : \u03b1\ntl : List \u03b1\nhl : (\u2191(tl ++ l')).toFinset = tl.toFinset \u222a l'.toFinset\n\u22a2 (\u2191(hd :: tl ++ l')).toFinset = (hd :: tl).toFinset \u222a l'.toFinset"}, {"line": "\u00b7 simp", "tactic_state": "case cons\n\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nl l' : List \u03b1\nhd : \u03b1\ntl : List \u03b1\nhl : (\u2191(tl ++ l')).toFinset = tl.toFinset \u222a l'.toFinset\n\u22a2 (\u2191(hd :: tl ++ l')).toFinset = (hd :: tl).toFinset \u222a l'.toFinset"}, {"line": "\u00b7 simp [hl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toAList_keys_toFinset [DecidableEq \u03b1] (f : \u03b1 \u2192\u2080 M) :\n    f.toAList.keys.toFinset = f.support := by\n  ext\n  simp [toAList, AList.mem_keys, AList.keys, List.keys]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/AList.lean", "context": {"open": [], "variables": ["{\u03b1 M : Type*} [Zero M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : Zero M\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192\u2080 M\n\u22a2 f.toAList.keys.toFinset = f.support"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : Zero M\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192\u2080 M\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 f.toAList.keys.toFinset \u2194 a\u271d \u2208 f.support"}, {"line": "simp [toAList, AList.mem_keys, AList.keys, List.keys]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tail_update_zero : tail (update t 0 y) = tail t := by simp [tail]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Fin.lean", "context": {"open": ["Function"], "variables": ["{n : \u2115} (i : Fin n) {M : Type*} [Zero M] (y : M) (t : Fin (n + 1) \u2192\u2080 M) (s : Fin n \u2192\u2080 M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\ntail : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [tail]", "tactic_state": "x\u271d : Sort u_2\ntail : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma cons_support : (s.cons y).support \u2286 insert 0 (s.support.map (Fin.succEmb n)) := by\n  intro i hi\n  suffices i = 0 \u2228 \u2203 a, \u00acs a = 0 \u2227 a.succ = i by simpa\n  apply (Fin.eq_zero_or_eq_succ i).imp id (Exists.imp _)\n  rintro i rfl\n  simpa [Finsupp.mem_support_iff] using hi\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Fin.lean", "context": {"open": ["Function"], "variables": ["{n : \u2115} (i : Fin n) {M : Type*} [Zero M] (y : M) (t : Fin (n + 1) \u2192\u2080 M) (s : Fin n \u2192\u2080 M)", "{s} {y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nM : Type u_1\ninst\u271d : Zero M\ny : M\ns : Fin n \u2192\u2080 M\n\u22a2 (Finsupp.cons y s).support \u2286 insert 0 (Finset.map (Fin.succEmb n) s.support)"}, {"line": "intro i hi", "tactic_state": "n : \u2115\nM : Type u_1\ninst\u271d : Zero M\ny : M\ns : Fin n \u2192\u2080 M\ni : Fin (n + 1)\nhi : i \u2208 (Finsupp.cons y s).support\n\u22a2 i \u2208 insert 0 (Finset.map (Fin.succEmb n) s.support)"}, {"line": "suffices i = 0 \u2228 \u2203 a, \u00acs a = 0 \u2227 a.succ = i by simpa", "tactic_state": "n : \u2115\nM : Type u_1\ninst\u271d : Zero M\ny : M\ns : Fin n \u2192\u2080 M\ni : Fin (n + 1)\nhi : i \u2208 (Finsupp.cons y s).support\n\u22a2 i = 0 \u2228 \u2203 a, \u00acs a = 0 \u2227 a.succ = i"}, {"line": "apply (Fin.eq_zero_or_eq_succ i).imp id (Exists.imp _)", "tactic_state": "n : \u2115\nM : Type u_1\ninst\u271d : Zero M\ny : M\ns : Fin n \u2192\u2080 M\ni : Fin (n + 1)\nhi : i \u2208 (Finsupp.cons y s).support\n\u22a2 \u2200 (a : Fin n), i = a.succ \u2192 \u00acs a = 0 \u2227 a.succ = i"}, {"line": "rintro i rfl", "tactic_state": "n : \u2115\nM : Type u_1\ninst\u271d : Zero M\ny : M\ns : Fin n \u2192\u2080 M\ni : Fin n\nhi : i.succ \u2208 (Finsupp.cons y s).support\n\u22a2 \u00acs i = 0 \u2227 i.succ = i.succ"}, {"line": "simpa [Finsupp.mem_support_iff] using hi", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_toMultiset (f : \u03b1 \u2192\u2080 \u2115) : Multiset.card (toMultiset f) = f.sum fun _ => id := by\n  simp [toMultiset_apply, map_finsuppSum, Function.id_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Multiset.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 \u03b2 \u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_4\ntoMultiset : x\u271d\nf : \u03b1 \u2192\u2080 \u2115\n\u22a2 sorry.card = f.sum fun x => id"}, {"line": "simp [toMultiset_apply, map_finsuppSum, Function.id_def]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_4\ntoMultiset : x\u271d\nf : \u03b1 \u2192\u2080 \u2115\n\u22a2 (sorry ()).card = f.sum fun x x => x"}]}
{"declaration": "theorem toMultiset_map (f : \u03b1 \u2192\u2080 \u2115) (g : \u03b1 \u2192 \u03b2) :\n    f.toMultiset.map g = toMultiset (f.mapDomain g) := by\n  refine f.induction ?_ ?_\n  \u00b7 rw [toMultiset_zero, Multiset.map_zero, mapDomain_zero, toMultiset_zero]\n  \u00b7 intro a n f _ _ ih\n    rw [toMultiset_add]\n    rw [Multiset.map_add]\n    rw [ih]\n    rw [mapDomain_add]\n    rw [mapDomain_single]\n    rw [toMultiset_single]\n    rw [toMultiset_add]\n    rw [toMultiset_single]\n    rw [\u2190 Multiset.coe_mapAddMonoidHom]\n    rw [(Multiset.mapAddMonoidHom g).map_nsmul]\n    rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Multiset.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 \u03b2 \u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_4\ntoMultiset : x\u271d\nf : \u03b1 \u2192\u2080 \u2115\ng : \u03b1 \u2192 \u03b2\n\u22a2 Multiset.map g (Finsupp.toMultiset f) = sorry"}, {"line": "refine f.induction ?_ ?_", "tactic_state": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_4\ntoMultiset : x\u271d\nf : \u03b1 \u2192\u2080 \u2115\ng : \u03b1 \u2192 \u03b2\n\u22a2 Multiset.map g (Finsupp.toMultiset 0) = sorry\n---\ncase refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_4\ntoMultiset : x\u271d\nf : \u03b1 \u2192\u2080 \u2115\ng : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (a : \u03b1) (b : \u2115) (f : \u03b1 \u2192\u2080 \u2115),\n    a \u2209 f.support \u2192\n      b \u2260 0 \u2192\n        Multiset.map g (Finsupp.toMultiset f) = sorry \u2192\n          Multiset.map g (Finsupp.toMultiset ((fun\u2080 | a => b) + f)) = sorry"}, {"line": "\u00b7 rw [toMultiset_zero, Multiset.map_zero, mapDomain_zero, toMultiset_zero]", "tactic_state": "case refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_4\ntoMultiset : x\u271d\nf : \u03b1 \u2192\u2080 \u2115\ng : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (a : \u03b1) (b : \u2115) (f : \u03b1 \u2192\u2080 \u2115),\n    a \u2209 f.support \u2192\n      b \u2260 0 \u2192\n        Multiset.map g (Finsupp.toMultiset f) = sorry \u2192\n          Multiset.map g (Finsupp.toMultiset ((fun\u2080 | a => b) + f)) = sorry"}, {"line": "\u00b7 intro a n f _ _ ih\n    rw [toMultiset_add]\n    rw [Multiset.map_add]\n    rw [ih]\n    rw [mapDomain_add]\n    rw [mapDomain_single]\n    rw [toMultiset_single]\n    rw [toMultiset_add]\n    rw [toMultiset_single]\n    rw [\u2190 Multiset.coe_mapAddMonoidHom]\n    rw [(Multiset.mapAddMonoidHom g).map_nsmul]\n    rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_toMultiset [CommMonoid \u03b1] (f : \u03b1 \u2192\u2080 \u2115) :\n    f.toMultiset.prod = f.prod fun a n => a ^ n := by\n  refine f.induction ?_ ?_\n  \u00b7 rw [toMultiset_zero, Multiset.prod_zero, Finsupp.prod_zero_index]\n  \u00b7 intro a n f _ _ ih\n    rw [toMultiset_add]\n    rw [Multiset.prod_add]\n    rw [ih]\n    rw [toMultiset_single]\n    rw [Multiset.prod_nsmul]\n    rw [Finsupp.prod_add_index' pow_zero pow_add]\n    rw [Finsupp.prod_single_index]\n    rw [Multiset.prod_singleton]\n    exact pow_zero a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Multiset.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 \u03b2 \u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommMonoid \u03b1\nf : \u03b1 \u2192\u2080 \u2115\n\u22a2 (Finsupp.toMultiset f).prod = f.prod fun a n => a ^ n"}, {"line": "refine f.induction ?_ ?_", "tactic_state": "case refine_1\n\u03b1 : Type u_1\ninst\u271d : CommMonoid \u03b1\nf : \u03b1 \u2192\u2080 \u2115\n\u22a2 (Finsupp.toMultiset 0).prod = Finsupp.prod 0 fun a n => a ^ n\n---\ncase refine_2\n\u03b1 : Type u_1\ninst\u271d : CommMonoid \u03b1\nf : \u03b1 \u2192\u2080 \u2115\n\u22a2 \u2200 (a : \u03b1) (b : \u2115) (f : \u03b1 \u2192\u2080 \u2115),\n    a \u2209 f.support \u2192\n      b \u2260 0 \u2192\n        ((Finsupp.toMultiset f).prod = f.prod fun a n => a ^ n) \u2192\n          (Finsupp.toMultiset ((fun\u2080 | a => b) + f)).prod = ((fun\u2080 | a => b) + f).prod fun a n => a ^ n"}, {"line": "\u00b7 rw [toMultiset_zero, Multiset.prod_zero, Finsupp.prod_zero_index]", "tactic_state": "case refine_2\n\u03b1 : Type u_1\ninst\u271d : CommMonoid \u03b1\nf : \u03b1 \u2192\u2080 \u2115\n\u22a2 \u2200 (a : \u03b1) (b : \u2115) (f : \u03b1 \u2192\u2080 \u2115),\n    a \u2209 f.support \u2192\n      b \u2260 0 \u2192\n        ((Finsupp.toMultiset f).prod = f.prod fun a n => a ^ n) \u2192\n          (Finsupp.toMultiset ((fun\u2080 | a => b) + f)).prod = ((fun\u2080 | a => b) + f).prod fun a n => a ^ n"}, {"line": "\u00b7 intro a n f _ _ ih\n    rw [toMultiset_add]\n    rw [Multiset.prod_add]\n    rw [ih]\n    rw [toMultiset_single]\n    rw [Multiset.prod_nsmul]\n    rw [Finsupp.prod_add_index' pow_zero pow_add]\n    rw [Finsupp.prod_single_index]\n    rw [Multiset.prod_singleton]\n    exact pow_zero a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_toMultiset [DecidableEq \u03b1] (f : \u03b1 \u2192\u2080 \u2115) : f.toMultiset.toFinset = f.support := by\n  refine f.induction ?_ ?_\n  \u00b7 rw [toMultiset_zero, Multiset.toFinset_zero, support_zero]\n  \u00b7 intro a n f ha hn ih\n    rw [toMultiset_add]\n    rw [Multiset.toFinset_add]\n    rw [ih]\n    rw [toMultiset_single]\n    rw [support_add_eq]\n    rw [support_single_ne_zero _ hn]\n    rw [Multiset.toFinset_nsmul _ _ hn]\n    rw [Multiset.toFinset_singleton]\n    refine Disjoint.mono_left support_single_subset ?_\n    rwa [Finset.disjoint_singleton_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Multiset.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 \u03b2 \u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192\u2080 \u2115\n\u22a2 (Finsupp.toMultiset f).toFinset = f.support"}, {"line": "refine f.induction ?_ ?_", "tactic_state": "case refine_1\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192\u2080 \u2115\n\u22a2 (Finsupp.toMultiset 0).toFinset = Finsupp.support 0\n---\ncase refine_2\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192\u2080 \u2115\n\u22a2 \u2200 (a : \u03b1) (b : \u2115) (f : \u03b1 \u2192\u2080 \u2115),\n    a \u2209 f.support \u2192\n      b \u2260 0 \u2192\n        (Finsupp.toMultiset f).toFinset = f.support \u2192\n          (Finsupp.toMultiset ((fun\u2080 | a => b) + f)).toFinset = ((fun\u2080 | a => b) + f).support"}, {"line": "\u00b7 rw [toMultiset_zero, Multiset.toFinset_zero, support_zero]", "tactic_state": "case refine_2\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192\u2080 \u2115\n\u22a2 \u2200 (a : \u03b1) (b : \u2115) (f : \u03b1 \u2192\u2080 \u2115),\n    a \u2209 f.support \u2192\n      b \u2260 0 \u2192\n        (Finsupp.toMultiset f).toFinset = f.support \u2192\n          (Finsupp.toMultiset ((fun\u2080 | a => b) + f)).toFinset = ((fun\u2080 | a => b) + f).support"}, {"line": "\u00b7 intro a n f ha hn ih\n    rw [toMultiset_add]\n    rw [Multiset.toFinset_add]\n    rw [ih]\n    rw [toMultiset_single]\n    rw [support_add_eq]\n    rw [support_single_ne_zero _ hn]\n    rw [Multiset.toFinset_nsmul _ _ hn]\n    rw [Multiset.toFinset_singleton]\n    refine Disjoint.mono_left support_single_subset ?_\n    rwa [Finset.disjoint_singleton_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_single' {_ : Semiring R} (c : R) (a : \u03b1) (b : R) :\n    c \u2022 Finsupp.single a b = Finsupp.single a (c * b) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/SMul.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 M N G R : Type*}", "[Zero M] [MonoidWithZero R] [MulActionWithZero R M]", "[Monoid G] [MulAction G \u03b1] [AddCommMonoid M]", "[Group G] [MulAction G \u03b1] [AddCommMonoid M]", "(\u03b1 M)", "{\u03b1 M}", "{p : \u03b1 \u2192 Prop} [DecidablePred p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : Type u_6\ninst\u271d : MonoidWithZero R\nx\u271d : Semiring R\nc : R\na : \u03b1\nb : R\n\u22a2 (c \u2022 fun\u2080 | a => b) = fun\u2080 | a => c * b"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\nR : Type u_6\ninst\u271d : MonoidWithZero R\nx\u271d : Semiring R\nc : R\na : \u03b1\nb : R\n\u22a2 ((fun\u2080 | a => c) * fun\u2080 | a => b) = fun\u2080 | a => c * b"}]}
{"declaration": "theorem toDFinsupp_support (f : \u03b9 \u2192\u2080 M) : f.toDFinsupp.support = f.support := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/ToDFinsupp.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*} {R : Type*} {M : Type*}", "[DecidableEq \u03b9] [Zero M]", "[\u2200 m : M, Decidable (m \u2260 0)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Zero M\ninst\u271d : (m : M) \u2192 Decidable (m \u2260 0)\nf : \u03b9 \u2192\u2080 M\n\u22a2 f.toDFinsupp.support = f.support"}, {"line": "ext", "tactic_state": "case h\n\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Zero M\ninst\u271d : (m : M) \u2192 Decidable (m \u2260 0)\nf : \u03b9 \u2192\u2080 M\na\u271d : \u03b9\n\u22a2 a\u271d \u2208 f.toDFinsupp.support \u2194 a\u271d \u2208 f.support"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DFinsupp.toFinsupp_support (f : \u03a0\u2080 _ : \u03b9, M) : f.toFinsupp.support = f.support := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/ToDFinsupp.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*} {R : Type*} {M : Type*}", "[DecidableEq \u03b9] [Zero M]", "[\u2200 m : M, Decidable (m \u2260 0)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Zero M\ninst\u271d : (m : M) \u2192 Decidable (m \u2260 0)\nf : \u03a0\u2080 (x : \u03b9), M\n\u22a2 f.toFinsupp.support = f.support"}, {"line": "ext", "tactic_state": "case h\n\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Zero M\ninst\u271d : (m : M) \u2192 Decidable (m \u2260 0)\nf : \u03a0\u2080 (x : \u03b9), M\na\u271d : \u03b9\n\u22a2 a\u271d \u2208 f.toFinsupp.support \u2194 a\u271d \u2208 f.support"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq \u03b9] [Zero N]\n    [\u2200 (i : \u03b9) (x : \u03b7 i \u2192\u2080 N), Decidable (x \u2260 0)] (f : (\u03a3 i, \u03b7 i) \u2192\u2080 N) :\n    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by\n  ext\n  rw [DFinsupp.mem_support_toFun]\n  exact (Finsupp.mem_splitSupport_iff_nonzero _ _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/ToDFinsupp.lean", "context": {"open": ["Finsupp"], "variables": ["{\u03b9 : Type*} {R : Type*} {M : Type*}", "[DecidableEq \u03b9] [Zero M]", "[\u2200 m : M, Decidable (m \u2260 0)]", "[DecidableEq \u03b9]", "(R)", "{\u03b7 : \u03b9 \u2192 Type*} {N : Type*} [Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b9\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Zero N\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b7 i \u2192\u2080 N) \u2192 Decidable (x \u2260 0)\nf : (i : \u03b9) \u00d7 \u03b7 i \u2192\u2080 N\n\u22a2 (sigmaFinsuppEquivDFinsupp f).support = f.splitSupport"}, {"line": "ext", "tactic_state": "case h\n\u03b9 : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b9\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Zero N\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b7 i \u2192\u2080 N) \u2192 Decidable (x \u2260 0)\nf : (i : \u03b9) \u00d7 \u03b7 i \u2192\u2080 N\na\u271d : \u03b9\n\u22a2 a\u271d \u2208 (sigmaFinsuppEquivDFinsupp f).support \u2194 a\u271d \u2208 f.splitSupport"}, {"line": "rw [DFinsupp.mem_support_toFun]", "tactic_state": "case h\n\u03b9 : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b9\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Zero N\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b7 i \u2192\u2080 N) \u2192 Decidable (x \u2260 0)\nf : (i : \u03b9) \u00d7 \u03b7 i \u2192\u2080 N\na\u271d : \u03b9\n\u22a2 (sigmaFinsuppEquivDFinsupp f) a\u271d \u2260 0 \u2194 a\u271d \u2208 f.splitSupport"}, {"line": "exact (Finsupp.mem_splitSupport_iff_nonzero _ _).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_graph_iff {c : \u03b1 \u00d7 M} {f : \u03b1 \u2192\u2080 M} : c \u2208 f.graph \u2194 f c.1 = c.2 \u2227 c.2 \u2260 0 := by\n  cases c\n  exact mk_mem_graph_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 M M' N P G H R S : Type*}", "[Zero M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_5\ninst\u271d : Zero M\nc : \u03b1 \u00d7 M\nf : \u03b1 \u2192\u2080 M\n\u22a2 c \u2208 f.graph \u2194 f c.1 = c.2 \u2227 c.2 \u2260 0"}, {"line": "cases c", "tactic_state": "case mk\n\u03b1 : Type u_1\nM : Type u_5\ninst\u271d : Zero M\nf : \u03b1 \u2192\u2080 M\nfst\u271d : \u03b1\nsnd\u271d : M\n\u22a2 (fst\u271d, snd\u271d) \u2208 f.graph \u2194 f (fst\u271d, snd\u271d).1 = (fst\u271d, snd\u271d).2 \u2227 (fst\u271d, snd\u271d).2 \u2260 0"}, {"line": "exact mk_mem_graph_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem graph_zero : graph (0 : \u03b1 \u2192\u2080 M) = \u2205 := by simp [graph]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 M M' N P G H R S : Type*}", "[Zero M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_5\ninst\u271d : Zero M\n\u22a2 graph \u21d10 = \u2205"}, {"line": "simp [graph]", "tactic_state": "\u03b1 : Type u_1\nM : Type u_5\ninst\u271d : Zero M\n\u22a2 graph 0 = \u2205"}]}
{"declaration": "lemma prod_sumElim {\u03b9\u2081 \u03b9\u2082 \u03b1 M : Type*} [Zero \u03b1] [CommMonoid M]\n    (f\u2081 : \u03b9\u2081 \u2192\u2080 \u03b1) (f\u2082 : \u03b9\u2082 \u2192\u2080 \u03b1) (g : \u03b9\u2081 \u2295 \u03b9\u2082 \u2192 \u03b1 \u2192 M) :\n    (f\u2081.sumElim f\u2082).prod g = f\u2081.prod (g \u2218 Sum.inl) * f\u2082.prod (g \u2218 Sum.inr) := by\n  simp [Finsupp.prod, Finset.prod_disj_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 M M' N P G H R S : Type*}", "[Zero M]", "[Zero M] [Zero N] [Zero P]", "[Zero M] [Zero N] [Zero P]", "[AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P]", "{F : Type*} [FunLike F M N] [AddMonoidHomClass F M N]", "[Zero M]", "[Zero M] (f : \u03b1 \u2192\u2080 M)", "[AddCommMonoid M] {v v\u2081 v\u2082 : \u03b1 \u2192\u2080 M}", "[Zero M]", "[AddZeroClass M] {f : \u03b1 \u2192 \u03b2}", "[AddCommMonoid M] (f : \u03b1 \u2192 \u03b2)", "[Zero M] (p : \u03b1 \u2192 Prop) [DecidablePred p] (f : \u03b1 \u2192\u2080 M)", "[Zero M]", "[Zero M] {p : \u03b1 \u2192 Prop}", "[AddZeroClass M] {p : \u03b1 \u2192 Prop} {v v' : \u03b1 \u2192\u2080 M}", "[AddCommMonoid M] {p : \u03b1 \u2192 Prop}", "[AddGroup G] {p : \u03b1 \u2192 Prop} {v v' : \u03b1 \u2192\u2080 G}", "[AddCommMonoid M] [AddCommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9\u2081 : Type u_14\n\u03b9\u2082 : Type u_15\n\u03b1 : Type u_16\nM : Type u_17\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : CommMonoid M\nf\u2081 : \u03b9\u2081 \u2192\u2080 \u03b1\nf\u2082 : \u03b9\u2082 \u2192\u2080 \u03b1\ng : \u03b9\u2081 \u2295 \u03b9\u2082 \u2192 \u03b1 \u2192 M\n\u22a2 (f\u2081.sumElim f\u2082).prod g = f\u2081.prod (g \u2218 Sum.inl) * f\u2082.prod (g \u2218 Sum.inr)"}, {"line": "simp [Finsupp.prod, Finset.prod_disj_sum]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Multiset.support_sum_subset [AddCommMonoid M] (s : Multiset (\u03b9 \u2192\u2080 M)) :\n    s.sum.support \u2286 (s.map Finsupp.support).sup := by\n  induction s using Quot.inductionOn\n  simpa only [Multiset.quot_mk_to_coe'',Multiset.sum_coe,Multiset.map_coe,Multiset.sup_coe,List.foldr_map] using List.support_sum_subset _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/BigOperators.lean", "context": {"open": [], "variables": ["{\u03b9 M : Type*} [DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : AddCommMonoid M\ns : Multiset (\u03b9 \u2192\u2080 M)\n\u22a2 s.sum.support \u2286 (map Finsupp.support s).sup"}, {"line": "induction s using Quot.inductionOn", "tactic_state": "case h\n\u03b9 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : AddCommMonoid M\na\u271d : List (\u03b9 \u2192\u2080 M)\n\u22a2 (sum (Quot.mk (\u21d1(List.isSetoid (\u03b9 \u2192\u2080 M))) a\u271d)).support \u2286\n    (map Finsupp.support (Quot.mk (\u21d1(List.isSetoid (\u03b9 \u2192\u2080 M))) a\u271d)).sup"}, {"line": "simpa only [Multiset.quot_mk_to_coe'',Multiset.sum_coe,Multiset.map_coe,Multiset.sup_coe,List.foldr_map] using List.support_sum_subset _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finset.support_sum_subset [AddCommMonoid M] (s : Finset (\u03b9 \u2192\u2080 M)) :\n    (s.sum id).support \u2286 Finset.sup s Finsupp.support := by\n  classical convert Multiset.support_sum_subset s.1; simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/BigOperators.lean", "context": {"open": [], "variables": ["{\u03b9 M : Type*} [DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : AddCommMonoid M\ns : Finset (\u03b9 \u2192\u2080 M)\n\u22a2 (s.sum id).support \u2286 s.sup Finsupp.support"}, {"line": "classical convert Multiset.support_sum_subset s.1; simp", "tactic_state": "case h.e'_4\n\u03b9 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : AddCommMonoid M\ns : Finset (\u03b9 \u2192\u2080 M)\n\u22a2 s.sup Finsupp.support = (Multiset.map Finsupp.support s.val).sup"}]}
{"declaration": "theorem card_support_eq_zero {f : \u03b1 \u2192\u2080 M} : #f.support = 0 \u2194 f = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Defs.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 M M' N P G H R S : Type*}", "[Zero M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_5\ninst\u271d : Zero M\nf : \u03b1 \u2192\u2080 M\n\u22a2 f.support.card = 0 \u2194 f = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_onFinset_subset {s : Finset \u03b1} {f : \u03b1 \u2192 M} {hf} :\n    (onFinset s f hf).support \u2286 s := by\n  classical convert filter_subset (f \u00b7 \u2260 0) s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Defs.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 M M' N P G H R S : Type*}", "[Zero M]", "[Zero M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_5\ninst\u271d\u00b9 inst\u271d : Zero M\nx\u271d : Sort u_13\nonFinset : x\u271d\ns : Finset \u03b1\nf : \u03b1 \u2192 M\nhf : ?m.651\n\u22a2 sorry \u2286 s"}, {"line": "classical convert filter_subset (f \u00b7 \u2260 0) s", "tactic_state": "case h.e'_3\n\u03b1 : Type u_1\nM : Type u_5\ninst\u271d\u00b9 inst\u271d : Zero M\nx\u271d : Sort u_13\nonFinset : x\u271d\ns : Finset \u03b1\nf : \u03b1 \u2192 M\nhf : ?m.651\n\u22a2 sorry = {x \u2208 s | f x \u2260 0}\n---\n\u03b1 : Type u_1\nM : Type u_5\ninst\u271d\u00b9 inst\u271d : Zero M\nx\u271d : Sort u_13\nonFinset : x\u271d\ns : Finset \u03b1\nf : \u03b1 \u2192 M\nhf : ?m.651\n\u22a2 \u03b1 \u2192 OfNat M 0"}]}
{"declaration": "theorem mem_support_onFinset {s : Finset \u03b1} {f : \u03b1 \u2192 M} (hf : \u2200 a : \u03b1, f a \u2260 0 \u2192 a \u2208 s) {a : \u03b1} :\n    a \u2208 (Finsupp.onFinset s f hf).support \u2194 f a \u2260 0 := by\n  rw [Finsupp.mem_support_iff]\n  rw [Finsupp.onFinset_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Defs.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 M M' N P G H R S : Type*}", "[Zero M]", "[Zero M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_5\ninst\u271d\u00b9 inst\u271d : Zero M\ns : Finset \u03b1\nf : \u03b1 \u2192 M\nhf : \u2200 (a : \u03b1), f a \u2260 0 \u2192 a \u2208 s\na : \u03b1\n\u22a2 a \u2208 (Finsupp.onFinset s f hf).support \u2194 f a \u2260 0"}, {"line": "rw [Finsupp.mem_support_iff]", "tactic_state": "\u03b1 : Type u_1\nM : Type u_5\ninst\u271d\u00b9 inst\u271d : Zero M\ns : Finset \u03b1\nf : \u03b1 \u2192 M\nhf : \u2200 (a : \u03b1), f a \u2260 0 \u2192 a \u2208 s\na : \u03b1\n\u22a2 (Finsupp.onFinset s f hf) a \u2260 0 \u2194 f a \u2260 0"}, {"line": "rw [Finsupp.onFinset_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_mapRange_of_injective {e : M \u2192 N} (he0 : e 0 = 0) (f : \u03b9 \u2192\u2080 M)\n    (he : Function.Injective e) : (Finsupp.mapRange e he0 f).support = f.support := by\n  ext\n  simp only [Finsupp.mem_support_iff]\n  simp only [Ne]\n  simp only [Finsupp.mapRange_apply]\n  exact he.ne_iff' he0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Defs.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 M M' N P G H R S : Type*}", "[Zero M]", "[Zero M]", "[Zero M]", "[Zero M] [Zero N] [Zero P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_4\nM : Type u_5\nN : Type u_7\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Zero M\ninst\u271d : Zero N\ne : M \u2192 N\nhe0 : e 0 = 0\nf : \u03b9 \u2192\u2080 M\nhe : Injective e\n\u22a2 (Finsupp.mapRange e he0 f).support = f.support"}, {"line": "ext", "tactic_state": "case h\n\u03b9 : Type u_4\nM : Type u_5\nN : Type u_7\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Zero M\ninst\u271d : Zero N\ne : M \u2192 N\nhe0 : e 0 = 0\nf : \u03b9 \u2192\u2080 M\nhe : Injective e\na\u271d : \u03b9\n\u22a2 a\u271d \u2208 (Finsupp.mapRange e he0 f).support \u2194 a\u271d \u2208 f.support"}, {"line": "simp only [Finsupp.mem_support_iff]", "tactic_state": "case h\n\u03b9 : Type u_4\nM : Type u_5\nN : Type u_7\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Zero M\ninst\u271d : Zero N\ne : M \u2192 N\nhe0 : e 0 = 0\nf : \u03b9 \u2192\u2080 M\nhe : Injective e\na\u271d : \u03b9\n\u22a2 (Finsupp.mapRange e he0 f) a\u271d \u2260 0 \u2194 f a\u271d \u2260 0"}, {"line": "simp only [Ne]", "tactic_state": "case h\n\u03b9 : Type u_4\nM : Type u_5\nN : Type u_7\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Zero M\ninst\u271d : Zero N\ne : M \u2192 N\nhe0 : e 0 = 0\nf : \u03b9 \u2192\u2080 M\nhe : Injective e\na\u271d : \u03b9\n\u22a2 \u00ac(Finsupp.mapRange e he0 f) a\u271d = 0 \u2194 \u00acf a\u271d = 0"}, {"line": "simp only [Finsupp.mapRange_apply]", "tactic_state": "case h\n\u03b9 : Type u_4\nM : Type u_5\nN : Type u_7\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Zero M\ninst\u271d : Zero N\ne : M \u2192 N\nhe0 : e 0 = 0\nf : \u03b9 \u2192\u2080 M\nhe : Injective e\na\u271d : \u03b9\n\u22a2 \u00ace (f a\u271d) = 0 \u2194 \u00acf a\u271d = 0"}, {"line": "exact he.ne_iff' he0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_Icc : #(Icc f g) = \u220f i \u2208 f.support \u222a g.support, #(Icc (f i) (g i)):= by\n  simp_rw [Icc_eq, card_finsupp, coe_rangeIcc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Interval.lean", "context": {"open": ["Finset Finsupp Function Pointwise"], "variables": ["{\u03b9 \u03b1 : Type*}", "[Zero \u03b1] {f : \u03b9 \u2192\u2080 \u03b1} {i : \u03b9} {a : \u03b1}", "[Zero \u03b1] [PartialOrder \u03b1] [LocallyFiniteOrder \u03b1] [DecidableEq \u03b9]", "{f g : \u03b9 \u2192\u2080 \u03b1} {i : \u03b9} {a : \u03b1}", "[PartialOrder \u03b1] [Zero \u03b1] [LocallyFiniteOrder \u03b1] [DecidableEq \u03b9] [DecidableEq \u03b1]", "(f g : \u03b9 \u2192\u2080 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2079 inst\u271d\u2078 : Zero \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u2075 : DecidableEq \u03b9\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : DecidableEq \u03b1\nf g : \u03b9 \u2192\u2080 \u03b1\n\u22a2 (Icc f g).card = \u220f i \u2208 f.support \u222a g.support, (Icc (f i) (g i)).card"}, {"line": "simp_rw [Icc_eq, card_finsupp, coe_rangeIcc]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_add_right (a b : \u03c3 \u2192\u2080 \u2115) :\n    m.toSyn a \u2264 m.toSyn a + m.toSyn b := by\n  rw [\u2190 map_add]\n  exact m.toSyn_monotone le_self_add\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/MonomialOrder.lean", "context": {"open": [], "variables": ["{\u03c3 : Type*} (m : MonomialOrder \u03c3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nm : MonomialOrder \u03c3\na b : \u03c3 \u2192\u2080 \u2115\n\u22a2 m.toSyn a \u2264 m.toSyn a + m.toSyn b"}, {"line": "rw [\u2190 map_add]", "tactic_state": "\u03c3 : Type u_1\nm : MonomialOrder \u03c3\na b : \u03c3 \u2192\u2080 \u2115\n\u22a2 m.toSyn a \u2264 m.toSyn (a + b)"}, {"line": "exact m.toSyn_monotone le_self_add", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toSyn_strictMono : StrictMono (m.toSyn) := by\n  apply m.toSyn_monotone.strictMono_of_injective m.toSyn.injective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/MonomialOrder.lean", "context": {"open": [], "variables": ["{\u03c3 : Type*} (m : MonomialOrder \u03c3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nm : MonomialOrder \u03c3\n\u22a2 StrictMono \u21d1m.toSyn"}, {"line": "apply m.toSyn_monotone.strictMono_of_injective m.toSyn.injective", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_neLocus : \u2191(f.neLocus g) = { x | f x \u2260 g x } := by\n  ext\n  exact mem_neLocus\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/NeLocus.lean", "context": {"open": [], "variables": ["{\u03b1 M N P : Type*}", "[DecidableEq \u03b1]", "[DecidableEq N] [Zero N] (f g : \u03b1 \u2192\u2080 N)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nN : Type u_3\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableEq N\ninst\u271d : Zero N\nf g : \u03b1 \u2192\u2080 N\n\u22a2 \u2191(f.neLocus g) = {x | f x \u2260 g x}"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\nN : Type u_3\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableEq N\ninst\u271d : Zero N\nf g : \u03b1 \u2192\u2080 N\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u2191(f.neLocus g) \u2194 x\u271d \u2208 {x | f x \u2260 g x}"}, {"line": "exact mem_neLocus", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mapDomain_mono : Monotone (mapDomain f : (\u03b9 \u2192\u2080 \u03b1) \u2192 (\u03ba \u2192\u2080 \u03b1)) := by\n  classical exact fun g\u2081 g\u2082 h \u21a6 sum_le_sum_index h (fun _ _ \u21a6 single_mono) (by simp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Order.lean", "context": {"open": ["Finset"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 : Type*}", "[Zero \u03b1]", "[AddCommMonoid \u03b2] [PartialOrder \u03b2] [IsOrderedAddMonoid \u03b2] {f : \u03b9 \u2192\u2080 \u03b1} {h\u2081 h\u2082 : \u03b9 \u2192 \u03b1 \u2192 \u03b2}", "[LE \u03b1] {f g : \u03b9 \u2192\u2080 \u03b1}", "[Preorder \u03b1] {f g : \u03b9 \u2192\u2080 \u03b1} {i : \u03b9} {a b : \u03b1}", "[AddCommMonoid \u03b2] [PartialOrder \u03b2] [IsOrderedAddMonoid \u03b2]", "[DecidableEq \u03b9] [Lattice \u03b1] (f g : \u03b9 \u2192\u2080 \u03b1)", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u2077 : Zero \u03b1\ninst\u271d\u2076 : LE \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : Lattice \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nx\u271d : Sort u_5\nmapDomain : x\u271d\n\u22a2 Monotone sorry"}, {"line": "classical exact fun g\u2081 g\u2082 h \u21a6 sum_le_sum_index h (fun _ _ \u21a6 single_mono) (by simp)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_eq_zero_iff (f g : \u03b9 \u2192\u2080 \u03b1) : f + g = 0 \u2194 f = 0 \u2227 g = 0 := by\n  simp [DFunLike.ext_iff, forall_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Order.lean", "context": {"open": ["Finset"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 : Type*}", "[Zero \u03b1]", "[AddCommMonoid \u03b2] [PartialOrder \u03b2] [IsOrderedAddMonoid \u03b2] {f : \u03b9 \u2192\u2080 \u03b1} {h\u2081 h\u2082 : \u03b9 \u2192 \u03b1 \u2192 \u03b2}", "[LE \u03b1] {f g : \u03b9 \u2192\u2080 \u03b1}", "[Preorder \u03b1] {f g : \u03b9 \u2192\u2080 \u03b1} {i : \u03b9} {a b : \u03b1}", "[AddCommMonoid \u03b2] [PartialOrder \u03b2] [IsOrderedAddMonoid \u03b2]", "[DecidableEq \u03b9] [Lattice \u03b1] (f g : \u03b9 \u2192\u2080 \u03b1)", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1]", "[Zero \u03b1] [Preorder \u03b1] [Zero \u03b2] [Preorder \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Zero \u03b1] [PartialOrder \u03b1] [Zero \u03b2] [PartialOrder \u03b2] [SMulWithZero \u03b1 \u03b2]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [CanonicallyOrderedAdd \u03b1] {f g : \u03b9 \u2192\u2080 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u00b9\u2074 : Zero \u03b1\ninst\u271d\u00b9\u00b3 : LE \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : DecidableEq \u03b9\ninst\u271d\u00b9\u2070 : Lattice \u03b1\ninst\u271d\u2079 : AddCommMonoid \u03b1\ninst\u271d\u2078 : PartialOrder \u03b1\ninst\u271d\u2077 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2076 : Zero \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : CanonicallyOrderedAdd \u03b1\nf g : \u03b9 \u2192\u2080 \u03b1\n\u22a2 sorry \u2194 f = 0 \u2227 g = 0"}, {"line": "simp [DFunLike.ext_iff, forall_and]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u00b9\u2074 : Zero \u03b1\ninst\u271d\u00b9\u00b3 : LE \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : DecidableEq \u03b9\ninst\u271d\u00b9\u2070 : Lattice \u03b1\ninst\u271d\u2079 : AddCommMonoid \u03b1\ninst\u271d\u2078 : PartialOrder \u03b1\ninst\u271d\u2077 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2076 : Zero \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : CanonicallyOrderedAdd \u03b1\nf g : \u03b9 \u2192\u2080 \u03b1\n\u22a2 sorry () \u2194 (\u2200 (x : \u03b9), f x = 0) \u2227 \u2200 (x : \u03b9), g x = 0"}]}
{"declaration": "theorem support_tsub {f1 f2 : \u03b9 \u2192\u2080 \u03b1} : (f1 - f2).support \u2286 f1.support := by\n  simp +contextual only [subset_iff, tsub_eq_zero_iff_le, mem_support_iff,\n    Ne, coe_tsub, Pi.sub_apply, not_imp_not, zero_le, imp_true_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Order.lean", "context": {"open": ["Finset"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 : Type*}", "[Zero \u03b1]", "[AddCommMonoid \u03b2] [PartialOrder \u03b2] [IsOrderedAddMonoid \u03b2] {f : \u03b9 \u2192\u2080 \u03b1} {h\u2081 h\u2082 : \u03b9 \u2192 \u03b1 \u2192 \u03b2}", "[LE \u03b1] {f g : \u03b9 \u2192\u2080 \u03b1}", "[Preorder \u03b1] {f g : \u03b9 \u2192\u2080 \u03b1} {i : \u03b9} {a b : \u03b1}", "[AddCommMonoid \u03b2] [PartialOrder \u03b2] [IsOrderedAddMonoid \u03b2]", "[DecidableEq \u03b9] [Lattice \u03b1] (f g : \u03b9 \u2192\u2080 \u03b1)", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1]", "[Zero \u03b1] [Preorder \u03b1] [Zero \u03b2] [Preorder \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Zero \u03b1] [PartialOrder \u03b1] [Zero \u03b2] [PartialOrder \u03b2] [SMulWithZero \u03b1 \u03b2]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [CanonicallyOrderedAdd \u03b1] {f g : \u03b9 \u2192\u2080 \u03b1}", "[Sub \u03b1] [OrderedSub \u03b1] {f g : \u03b9 \u2192\u2080 \u03b1} {i : \u03b9} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u00b9\u2076 : Zero \u03b1\ninst\u271d\u00b9\u2075 : LE \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b2 : Lattice \u03b1\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2078 : Zero \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Zero \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : CanonicallyOrderedAdd \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\nf1 f2 : \u03b9 \u2192\u2080 \u03b1\n\u22a2 sorry \u2286 f1.support"}, {"line": "simp +contextual only [subset_iff, tsub_eq_zero_iff_le, mem_support_iff,\n    Ne, coe_tsub, Pi.sub_apply, not_imp_not, zero_le, imp_true_iff]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u00b9\u2076 : Zero \u03b1\ninst\u271d\u00b9\u2075 : LE \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b2 : Lattice \u03b1\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2078 : Zero \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Zero \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : CanonicallyOrderedAdd \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\nf1 f2 : \u03b9 \u2192\u2080 \u03b1\n\u22a2 \u2200 \u2983x : \u03b9\u2984, x \u2208 sorry \u2192 x \u2208 f1.support"}]}
{"declaration": "theorem subset_support_tsub [DecidableEq \u03b9] {f1 f2 : \u03b9 \u2192\u2080 \u03b1} :\n    f1.support \\ f2.support \u2286 (f1 - f2).support := by\n  simp +contextual [subset_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Order.lean", "context": {"open": ["Finset"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 : Type*}", "[Zero \u03b1]", "[AddCommMonoid \u03b2] [PartialOrder \u03b2] [IsOrderedAddMonoid \u03b2] {f : \u03b9 \u2192\u2080 \u03b1} {h\u2081 h\u2082 : \u03b9 \u2192 \u03b1 \u2192 \u03b2}", "[LE \u03b1] {f g : \u03b9 \u2192\u2080 \u03b1}", "[Preorder \u03b1] {f g : \u03b9 \u2192\u2080 \u03b1} {i : \u03b9} {a b : \u03b1}", "[AddCommMonoid \u03b2] [PartialOrder \u03b2] [IsOrderedAddMonoid \u03b2]", "[DecidableEq \u03b9] [Lattice \u03b1] (f g : \u03b9 \u2192\u2080 \u03b1)", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1]", "[Zero \u03b1] [Preorder \u03b1] [Zero \u03b2] [Preorder \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Zero \u03b1] [PartialOrder \u03b1] [Zero \u03b2] [PartialOrder \u03b2] [SMulWithZero \u03b1 \u03b2]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [CanonicallyOrderedAdd \u03b1] {f g : \u03b9 \u2192\u2080 \u03b1}", "[Sub \u03b1] [OrderedSub \u03b1] {f g : \u03b9 \u2192\u2080 \u03b1} {i : \u03b9} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u00b9\u2077 : Zero \u03b1\ninst\u271d\u00b9\u2076 : LE \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b3 : Lattice \u03b1\ninst\u271d\u00b9\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b9 : PartialOrder \u03b1\ninst\u271d\u00b9\u2070 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2079 : Zero \u03b1\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Zero \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : CanonicallyOrderedAdd \u03b1\ninst\u271d\u00b2 : Sub \u03b1\ninst\u271d\u00b9 : OrderedSub \u03b1\ninst\u271d : DecidableEq \u03b9\nf1 f2 : \u03b9 \u2192\u2080 \u03b1\n\u22a2 f1.support \\ f2.support \u2286 sorry"}, {"line": "simp +contextual [subset_iff]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u00b9\u2077 : Zero \u03b1\ninst\u271d\u00b9\u2076 : LE \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b3 : Lattice \u03b1\ninst\u271d\u00b9\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b9 : PartialOrder \u03b1\ninst\u271d\u00b9\u2070 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2079 : Zero \u03b1\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Zero \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : CanonicallyOrderedAdd \u03b1\ninst\u271d\u00b2 : Sub \u03b1\ninst\u271d\u00b9 : OrderedSub \u03b1\ninst\u271d : DecidableEq \u03b9\nf1 f2 : \u03b9 \u2192\u2080 \u03b1\n\u22a2 \u2200 \u2983x : \u03b9\u2984, \u00acf1 x = 0 \u2192 f2 x = 0 \u2192 x \u2208 sorry ()"}]}
{"declaration": "theorem single_eq_same : (single a b : \u03b1 \u2192\u2080 M) a = b := by\n  classical exact Pi.single_eq_same (f := fun _ \u21a6 M) a b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Single.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 M M' N P G H R S : Type*}", "[Zero M] {a a' : \u03b1} {b : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_5\ninst\u271d : Zero M\na : \u03b1\nb : M\nx\u271d : Sort u_13\nsingle : x\u271d\n\u22a2 sorry a = b"}, {"line": "classical exact Pi.single_eq_same (f := fun _ \u21a6 M) a b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem single_apply_eq_zero {a x : \u03b1} {b : M} : single a b x = 0 \u2194 x = a \u2192 b = 0 := by\n  simp [single_eq_set_indicator]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Single.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 M M' N P G H R S : Type*}", "[Zero M] {a a' : \u03b1} {b : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_5\ninst\u271d : Zero M\nx\u271d : Sort u_13\nsingle : x\u271d\na x : \u03b1\nb : M\n\u22a2 sorry = 0 \u2194 x = a \u2192 b = 0"}, {"line": "simp [single_eq_set_indicator]", "tactic_state": "\u03b1 : Type u_1\nM : Type u_5\ninst\u271d : Zero M\nx\u271d : Sort u_13\nsingle : x\u271d\na x : \u03b1\nb : M\n\u22a2 sorry () = 0 \u2194 x = a \u2192 b = 0"}]}
{"declaration": "theorem single_apply_ne_zero {a x : \u03b1} {b : M} : single a b x \u2260 0 \u2194 x = a \u2227 b \u2260 0 := by\n  simp [single_apply_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Single.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 M M' N P G H R S : Type*}", "[Zero M] {a a' : \u03b1} {b : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_5\ninst\u271d : Zero M\nx\u271d : Sort u_13\nsingle : x\u271d\na x : \u03b1\nb : M\n\u22a2 sorry \u2260 0 \u2194 x = a \u2227 b \u2260 0"}, {"line": "simp [single_apply_eq_zero]", "tactic_state": "\u03b1 : Type u_1\nM : Type u_5\ninst\u271d : Zero M\nx\u271d : Sort u_13\nsingle : x\u271d\na x : \u03b1\nb : M\n\u22a2 \u00acsorry () = 0 \u2194 x = a \u2227 \u00acb = 0"}]}
{"declaration": "theorem single_eq_zero : single a b = 0 \u2194 b = 0 := by\n  simp [DFunLike.ext_iff, single_eq_set_indicator]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Single.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 M M' N P G H R S : Type*}", "[Zero M] {a a' : \u03b1} {b : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_5\ninst\u271d : Zero M\nb : M\nx\u271d : Sort u_13\nsingle : x\u271d\n\u22a2 sorry = 0 \u2194 b = 0"}, {"line": "simp [DFunLike.ext_iff, single_eq_set_indicator]", "tactic_state": "M : Type u_5\ninst\u271d : Zero M\nb : M\nx\u271d : Sort u_13\nsingle : x\u271d\n\u22a2 sorry () = 0 \u2194 b = 0"}]}
{"declaration": "theorem equivFunOnFinite_single [DecidableEq \u03b1] [Finite \u03b1] (x : \u03b1) (m : M) :\n    Finsupp.equivFunOnFinite (Finsupp.single x m) = Pi.single x m := by\n  ext\n  simp [Finsupp.single_eq_pi_single, equivFunOnFinite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Single.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 M M' N P G H R S : Type*}", "[Zero M] {a a' : \u03b1} {b : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_5\ninst\u271d\u00b2 : Zero M\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Finite \u03b1\nx : \u03b1\nm : M\n\u22a2 (Finsupp.equivFunOnFinite fun\u2080 | x => m) = Pi.single x m"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\nM : Type u_5\ninst\u271d\u00b2 : Zero M\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Finite \u03b1\nx : \u03b1\nm : M\nx\u271d : \u03b1\n\u22a2 Finsupp.equivFunOnFinite (fun\u2080 | x => m) x\u271d = Pi.single x m x\u271d"}, {"line": "simp [Finsupp.single_eq_pi_single, equivFunOnFinite]", "tactic_state": "case h\n\u03b1 : Type u_1\nM : Type u_5\ninst\u271d\u00b2 : Zero M\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Finite \u03b1\nx : \u03b1\nm : M\nx\u271d : \u03b1\n\u22a2 (fun\u2080 | x => m) x\u271d = Pi.single x m x\u271d"}]}
{"declaration": "theorem single_of_embDomain_single (l : \u03b1 \u2192\u2080 M) (f : \u03b1 \u21aa \u03b2) (a : \u03b2) (b : M) (hb : b \u2260 0)\n    (h : l.embDomain f = single a b) : \u2203 x, l = single x b \u2227 f x = a := by\n  classical\n    have h_map_support : Finset.map f l.support = {a} := by\n      rw [\u2190 support_embDomain]\n      rw [h]\n      rw [support_single_ne_zero _ hb]\n    have ha : a \u2208 Finset.map f l.support := by simp only [h_map_support, Finset.mem_singleton]\n    rcases Finset.mem_map.1 ha with \u27e8c, _hc\u2081, hc\u2082\u27e9\n    use c\n    constructor\n    \u00b7 ext d\n      rw [\u2190 embDomain_apply f l]\n      rw [h]\n      by_cases h_cases : c = d\n      \u00b7 simp only [Eq.symm h_cases, hc\u2082, single_eq_same]\n      \u00b7 rw [single_apply, single_apply, if_neg, if_neg h_cases]\n        by_contra hfd\n        exact h_cases (f.injective (hc\u2082.trans hfd))\n    \u00b7 exact hc\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Single.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 M M' N P G H R S : Type*}", "[Zero M] {a a' : \u03b1} {b : M}", "[Zero M] (f : \u03b1 \u2192\u2080 M) (a : \u03b1) (b : M) (i : \u03b1)", "{b}", "[Zero M]", "[Zero M] [Zero N] [Zero P]", "[Zero M] [Zero N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nM : Type u_5\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : Zero M\nx\u271d : Sort u_13\nsingle : x\u271d\nl : \u03b1 \u2192\u2080 M\nf : \u03b1 \u21aa \u03b2\na : \u03b2\nb : M\nhb : b \u2260 0\nh : Finsupp.embDomain f l = sorry\n\u22a2 \u2203 x, l = sorry \u2227 f x = a"}, {"line": "classical\n    have h_map_support : Finset.map f l.support = {a} := by\n      rw [\u2190 support_embDomain]\n      rw [h]\n      rw [support_single_ne_zero _ hb]\n    have ha : a \u2208 Finset.map f l.support := by simp only [h_map_support, Finset.mem_singleton]\n    rcases Finset.mem_map.1 ha with \u27e8c, _hc\u2081, hc\u2082\u27e9\n    use c\n    constructor\n    \u00b7 ext d\n      rw [\u2190 embDomain_apply f l]\n      rw [h]\n      by_cases h_cases : c = d\n      \u00b7 simp only [Eq.symm h_cases, hc\u2082, single_eq_same]\n      \u00b7 rw [single_apply, single_apply, if_neg, if_neg h_cases]\n        by_contra hfd\n        exact h_cases (f.injective (hc\u2082.trans hfd))\n    \u00b7 exact hc\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem degree_zero : degree (0 : \u03c3 \u2192\u2080 R) = 0 := by simp [degree]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/Weight.lean", "context": {"open": [], "variables": ["{\u03c3 M R : Type*} [Semiring R] (w : \u03c3 \u2192 M)", "[AddCommMonoid M] [Module R M]", "(R) in", "(R) in", "(R) in", "{w} in", "[AddCommMonoid M] [PartialOrder M] [IsOrderedAddMonoid M] (w : \u03c3 \u2192 M)", "{w} in", "{M : Type*} [AddCommMonoid M] [PartialOrder M] [IsOrderedAddMonoid M]", "{R : Type*} [AddCommMonoid R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_5\ndegree : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [degree]", "tactic_state": "x\u271d : Sort u_5\ndegree : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem wellFounded\n    {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsTrichotomous \u03b1 r] (hr : WellFounded (Function.swap r))\n    {s : \u2115 \u2192 \u2115 \u2192 Prop} (hs : WellFounded s) (hs0 : \u2200 \u2983n\u2984, \u00ac s n 0) :\n    WellFounded (Finsupp.DegLex r s) := by\n  have wft := WellFounded.prod_lex hs (Finsupp.Lex.wellFounded' hs0 hs hr)\n  rw [\u2190 Set.wellFoundedOn_univ] at wft\n  unfold Finsupp.DegLex\n  rw [\u2190 Set.wellFoundedOn_range]\n  exact Set.WellFoundedOn.mono wft (le_refl _) (fun _ _ \u21a6 trivial)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/MonomialOrder/DegLex.lean", "context": {"open": ["scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsTrichotomous \u03b1 r\nhr : WellFounded (Function.swap r)\ns : \u2115 \u2192 \u2115 \u2192 Prop\nhs : WellFounded s\nhs0 : \u2200 \u2983n : \u2115\u2984, \u00acs n 0\n\u22a2 WellFounded (Finsupp.DegLex r s)"}, {"line": "have wft := WellFounded.prod_lex hs (Finsupp.Lex.wellFounded' hs0 hs hr)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsTrichotomous \u03b1 r\nhr : WellFounded (Function.swap r)\ns : \u2115 \u2192 \u2115 \u2192 Prop\nhs : WellFounded s\nhs0 : \u2200 \u2983n : \u2115\u2984, \u00acs n 0\nwft : WellFounded (Prod.Lex s (Finsupp.Lex r s))\n\u22a2 WellFounded (Finsupp.DegLex r s)"}, {"line": "rw [\u2190 Set.wellFoundedOn_univ] at wft", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsTrichotomous \u03b1 r\nhr : WellFounded (Function.swap r)\ns : \u2115 \u2192 \u2115 \u2192 Prop\nhs : WellFounded s\nhs0 : \u2200 \u2983n : \u2115\u2984, \u00acs n 0\nwft : Set.univ.WellFoundedOn (Prod.Lex s (Finsupp.Lex r s))\n\u22a2 WellFounded (Finsupp.DegLex r s)"}, {"line": "unfold Finsupp.DegLex", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsTrichotomous \u03b1 r\nhr : WellFounded (Function.swap r)\ns : \u2115 \u2192 \u2115 \u2192 Prop\nhs : WellFounded s\nhs0 : \u2200 \u2983n : \u2115\u2984, \u00acs n 0\nwft : Set.univ.WellFoundedOn (Prod.Lex s (Finsupp.Lex r s))\n\u22a2 WellFounded (Function.onFun (Prod.Lex s (Finsupp.Lex r s)) fun x => (x.degree, x))"}, {"line": "rw [\u2190 Set.wellFoundedOn_range]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsTrichotomous \u03b1 r\nhr : WellFounded (Function.swap r)\ns : \u2115 \u2192 \u2115 \u2192 Prop\nhs : WellFounded s\nhs0 : \u2200 \u2983n : \u2115\u2984, \u00acs n 0\nwft : Set.univ.WellFoundedOn (Prod.Lex s (Finsupp.Lex r s))\n\u22a2 (Set.range fun x => (x.degree, x)).WellFoundedOn (Prod.Lex s (Finsupp.Lex r s))"}, {"line": "exact Set.WellFoundedOn.mono wft (le_refl _) (fun _ _ \u21a6 trivial)", "tactic_state": "No Goals!"}]}
{"declaration": "example : single (1 : Fin 2) 1 \u227a[degLex] single 0 1 := by\n  rw [degLex_lt_iff]\n  rw [single_lt_iff]\n  exact Nat.one_pos\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/MonomialOrder/DegLex.lean", "context": {"open": ["scoped Function in -- required for scoped `on` notation", "Finsupp", "Finsupp MonomialOrder DegLex"], "variables": ["{\u03b1 : Type*}", "[LinearOrder \u03b1]", "{\u03c3 : Type*} [LinearOrder \u03c3] [WellFoundedGT \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\n\u03c3 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03c3\ninst\u271d : WellFoundedGT \u03c3\n\u22a2 (degLex.toSyn fun\u2080 | 1 => 1) < degLex.toSyn fun\u2080 | 0 => 1"}, {"line": "rw [degLex_lt_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\n\u03c3 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03c3\ninst\u271d : WellFoundedGT \u03c3\n\u22a2 (toDegLex fun\u2080 | 1 => 1) < toDegLex fun\u2080 | 0 => 1"}, {"line": "rw [single_lt_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\n\u03c3 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03c3\ninst\u271d : WellFoundedGT \u03c3\n\u22a2 0 < 1"}, {"line": "exact Nat.one_pos", "tactic_state": "No Goals!"}]}
{"declaration": "example : (single 0 1 + single 1 1) \u227a[degLex] single (0 : Fin 2) 2  := by\n  simp only [degLex_lt_iff]\n  simp only [lt_iff]\n  simp only [ofDegLex_toDegLex]\n  simp only [degree_add]\n  simp only [degree_single]\n  simp only [Nat.reduceAdd]\n  simp only [lt_self_iff_false]\n  simp only [true_and]\n  simp only [false_or]\n  use 0\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/MonomialOrder/DegLex.lean", "context": {"open": ["scoped Function in -- required for scoped `on` notation", "Finsupp", "Finsupp MonomialOrder DegLex"], "variables": ["{\u03b1 : Type*}", "[LinearOrder \u03b1]", "{\u03c3 : Type*} [LinearOrder \u03c3] [WellFoundedGT \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\n\u03c3 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03c3\ninst\u271d : WellFoundedGT \u03c3\n\u22a2 degLex.toSyn ((fun\u2080 | 0 => 1) + fun\u2080 | 1 => 1) < degLex.toSyn fun\u2080 | 0 => 2"}, {"line": "simp only [degLex_lt_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\n\u03c3 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03c3\ninst\u271d : WellFoundedGT \u03c3\n\u22a2 toDegLex ((fun\u2080 | 0 => 1) + fun\u2080 | 1 => 1) < toDegLex fun\u2080 | 0 => 2"}, {"line": "simp only [lt_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\n\u03c3 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03c3\ninst\u271d : WellFoundedGT \u03c3\n\u22a2 (ofDegLex (toDegLex ((fun\u2080 | 0 => 1) + fun\u2080 | 1 => 1))).degree < (ofDegLex (toDegLex fun\u2080 | 0 => 2)).degree \u2228\n    (ofDegLex (toDegLex ((fun\u2080 | 0 => 1) + fun\u2080 | 1 => 1))).degree = (ofDegLex (toDegLex fun\u2080 | 0 => 2)).degree \u2227\n      toLex (ofDegLex (toDegLex ((fun\u2080 | 0 => 1) + fun\u2080 | 1 => 1))) < toLex (ofDegLex (toDegLex fun\u2080 | 0 => 2))"}, {"line": "simp only [ofDegLex_toDegLex]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\n\u03c3 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03c3\ninst\u271d : WellFoundedGT \u03c3\n\u22a2 ((fun\u2080 | 0 => 1) + fun\u2080 | 1 => 1).degree < (fun\u2080 | 0 => 2).degree \u2228\n    ((fun\u2080 | 0 => 1) + fun\u2080 | 1 => 1).degree = (fun\u2080 | 0 => 2).degree \u2227\n      toLex ((fun\u2080 | 0 => 1) + fun\u2080 | 1 => 1) < toLex fun\u2080 | 0 => 2"}, {"line": "simp only [degree_add]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\n\u03c3 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03c3\ninst\u271d : WellFoundedGT \u03c3\n\u22a2 (fun\u2080 | 0 => 1).degree + (fun\u2080 | 1 => 1).degree < (fun\u2080 | 0 => 2).degree \u2228\n    (fun\u2080 | 0 => 1).degree + (fun\u2080 | 1 => 1).degree = (fun\u2080 | 0 => 2).degree \u2227\n      toLex ((fun\u2080 | 0 => 1) + fun\u2080 | 1 => 1) < toLex fun\u2080 | 0 => 2"}, {"line": "simp only [degree_single]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\n\u03c3 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03c3\ninst\u271d : WellFoundedGT \u03c3\n\u22a2 1 + 1 < 2 \u2228 True \u2227 toLex ((fun\u2080 | 0 => 1) + fun\u2080 | 1 => 1) < toLex fun\u2080 | 0 => 2"}, {"line": "simp only [Nat.reduceAdd]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\n\u03c3 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03c3\ninst\u271d : WellFoundedGT \u03c3\n\u22a2 2 < 2 \u2228 True \u2227 toLex ((fun\u2080 | 0 => 1) + fun\u2080 | 1 => 1) < toLex fun\u2080 | 0 => 2"}, {"line": "simp only [lt_self_iff_false]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\n\u03c3 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03c3\ninst\u271d : WellFoundedGT \u03c3\n\u22a2 False \u2228 True \u2227 toLex ((fun\u2080 | 0 => 1) + fun\u2080 | 1 => 1) < toLex fun\u2080 | 0 => 2"}, {"line": "simp only [true_and]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\n\u03c3 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03c3\ninst\u271d : WellFoundedGT \u03c3\n\u22a2 False \u2228 toLex ((fun\u2080 | 0 => 1) + fun\u2080 | 1 => 1) < toLex fun\u2080 | 0 => 2"}, {"line": "simp only [false_or]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\n\u03c3 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03c3\ninst\u271d : WellFoundedGT \u03c3\n\u22a2 toLex ((fun\u2080 | 0 => 1) + fun\u2080 | 1 => 1) < toLex fun\u2080 | 0 => 2"}, {"line": "use 0", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\n\u03c3 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03c3\ninst\u271d : WellFoundedGT \u03c3\n\u22a2 (\u2200 (j : Fin 2),\n      (fun x1 x2 => x1 < x2) j 0 \u2192\n        (ofLex (toLex ((fun\u2080 | 0 => 1) + fun\u2080 | 1 => 1))) j = (ofLex (toLex fun\u2080 | 0 => 2)) j) \u2227\n    (fun {i} x1 x2 => x1 < x2) ((ofLex (toLex ((fun\u2080 | 0 => 1) + fun\u2080 | 1 => 1))) 0) ((ofLex (toLex fun\u2080 | 0 => 2)) 0)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "example : single (0 : Fin 2) 1 \u227a[degLex] single 1 2 := by\n  simp [degLex_lt_iff, lt_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finsupp/MonomialOrder/DegLex.lean", "context": {"open": ["scoped Function in -- required for scoped `on` notation", "Finsupp", "Finsupp MonomialOrder DegLex"], "variables": ["{\u03b1 : Type*}", "[LinearOrder \u03b1]", "{\u03c3 : Type*} [LinearOrder \u03c3] [WellFoundedGT \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\n\u03c3 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03c3\ninst\u271d : WellFoundedGT \u03c3\n\u22a2 (degLex.toSyn fun\u2080 | 0 => 1) < degLex.toSyn fun\u2080 | 1 => 2"}, {"line": "simp [degLex_lt_iff, lt_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Fin.univ_image_def {n : \u2115} [DecidableEq \u03b1] (f : Fin n \u2192 \u03b1) :\n    Finset.univ.image f = (List.ofFn f).toFinset := by\n  simp [Finset.image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Basic.lean", "context": {"open": ["Function", "Nat", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : \u2115\ninst\u271d : DecidableEq \u03b1\nf : Fin n \u2192 \u03b1\n\u22a2 image f univ = (List.ofFn f).toFinset"}, {"line": "simp [Finset.image]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Fin.univ_map_def {n : \u2115} (f : Fin n \u21aa \u03b1) :\n    Finset.univ.map f = \u27e8List.ofFn f, List.nodup_ofFn.mpr f.injective\u27e9 := by\n  simp [Finset.map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Basic.lean", "context": {"open": ["Function", "Nat", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : \u2115\nf : Fin n \u21aa \u03b1\n\u22a2 map f univ = { val := \u2191(List.ofFn \u21d1f), nodup := \u22ef }"}, {"line": "simp [Finset.map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Fin.image_succAbove_univ {n : \u2115} (i : Fin (n + 1)) : univ.image i.succAbove = {i}\u1d9c := by\n  ext m\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Basic.lean", "context": {"open": ["Function", "Nat", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin (n + 1)\n\u22a2 image i.succAbove univ = {i}\u1d9c"}, {"line": "ext m", "tactic_state": "case h\nn : \u2115\ni m : Fin (n + 1)\n\u22a2 m \u2208 image i.succAbove univ \u2194 m \u2208 {i}\u1d9c"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Fin.image_succ_univ (n : \u2115) : (univ : Finset (Fin n)).image Fin.succ = {0}\u1d9c := by\n  rw [\u2190 Fin.succAbove_zero]\n  rw [Fin.image_succAbove_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Basic.lean", "context": {"open": ["Function", "Nat", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 image succ univ = {0}\u1d9c"}, {"line": "rw [\u2190 Fin.succAbove_zero]", "tactic_state": "n : \u2115\n\u22a2 image (succAbove 0) univ = {0}\u1d9c"}, {"line": "rw [Fin.image_succAbove_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Fin.image_castSucc (n : \u2115) :\n    (univ : Finset (Fin n)).image Fin.castSucc = {Fin.last n}\u1d9c := by\n  rw [\u2190 Fin.succAbove_last]\n  rw [Fin.image_succAbove_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Basic.lean", "context": {"open": ["Function", "Nat", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 image castSucc univ = {last n}\u1d9c"}, {"line": "rw [\u2190 Fin.succAbove_last]", "tactic_state": "n : \u2115\n\u22a2 image (last n).succAbove univ = {last n}\u1d9c"}, {"line": "rw [Fin.image_succAbove_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Fin.univ_succ (n : \u2115) :\n    (univ : Finset (Fin (n + 1))) =\n      Finset.cons 0 (univ.map \u27e8Fin.succ, Fin.succ_injective _\u27e9) (by simp [map_eq_image]) := by\n  simp [map_eq_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Basic.lean", "context": {"open": ["Function", "Nat", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 univ = Finset.cons 0 (map { toFun := succ, inj' := \u22ef } univ) \u22ef"}, {"line": "simp [map_eq_image]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Fin.univ_castSuccEmb (n : \u2115) :\n    (univ : Finset (Fin (n + 1))) =\n      Finset.cons (Fin.last n) (univ.map Fin.castSuccEmb) (by simp [map_eq_image]) := by\n  simp [map_eq_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Basic.lean", "context": {"open": ["Function", "Nat", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 univ = Finset.cons (last n) (map castSuccEmb univ) \u22ef"}, {"line": "simp [map_eq_image]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Fin.univ_succAbove (n : \u2115) (p : Fin (n + 1)) :\n    (univ : Finset (Fin (n + 1))) = Finset.cons p (univ.map <| Fin.succAboveEmb p) (by simp) := by\n  simp [map_eq_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Basic.lean", "context": {"open": ["Function", "Nat", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np : Fin (n + 1)\n\u22a2 univ = Finset.cons p (map p.succAboveEmb univ) \u22ef"}, {"line": "simp [map_eq_image]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Fin.univ_image_get' [DecidableEq \u03b2] (l : List \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    Finset.univ.image (f <| l.get \u00b7) = (l.map f).toFinset := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Basic.lean", "context": {"open": ["Function", "Nat", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b2\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 image (fun x => f (l.get x)) univ = (List.map f l).toFinset"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_seq_of_forall_finset_exists {\u03b1 : Type*} (P : \u03b1 \u2192 Prop) (r : \u03b1 \u2192 \u03b1 \u2192 Prop)\n    (h : \u2200 s : Finset \u03b1, (\u2200 x \u2208 s, P x) \u2192 \u2203 y, P y \u2227 \u2200 x \u2208 s, r x y) :\n    \u2203 f : \u2115 \u2192 \u03b1, (\u2200 n, P (f n)) \u2227 \u2200 m n, m < n \u2192 r (f m) (f n) := by\n  classical\n    have : Nonempty \u03b1 := by\n      rcases h \u2205 (by simp) with \u27e8y, _\u27e9\n      exact \u27e8y\u27e9\n    choose! F hF using h\n    have h' : \u2200 s : Finset \u03b1, \u2203 y, (\u2200 x \u2208 s, P x) \u2192 P y \u2227 \u2200 x \u2208 s, r x y := fun s => \u27e8F s, hF s\u27e9\n    set f := seqOfForallFinsetExistsAux P r h' with hf\n    have A : \u2200 n : \u2115, P (f n) := by\n      intro n\n      induction' n using Nat.strong_induction_on with n IH\n      have IH' : \u2200 x : Fin n, P (f x) := fun n => IH n.1 n.2\n      rw [hf]\n      rw [seqOfForallFinsetExistsAux]\n      exact\n        (Classical.choose_spec\n            (h' (Finset.image (fun i : Fin n => f i) (Finset.univ : Finset (Fin n))))\n            (by simp [IH'])).1\n    refine \u27e8f, A, fun m n hmn => ?_\u27e9\n    conv_rhs => rw [hf]\n    rw [seqOfForallFinsetExistsAux]\n    apply\n      (Classical.choose_spec\n          (h' (Finset.image (fun i : Fin n => f i) (Finset.univ : Finset (Fin n)))) (by simp [A])).2\n    exact Finset.mem_image.2 \u27e8\u27e8m, hmn\u27e9, Finset.mem_univ _, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Basic.lean", "context": {"open": ["Function", "Nat", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[Fintype \u03b1] [Fintype \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\nP : \u03b1 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (s : Finset \u03b1), (\u2200 x \u2208 s, P x) \u2192 \u2203 y, P y \u2227 \u2200 x \u2208 s, r x y\n\u22a2 \u2203 f, (\u2200 (n : \u2115), P (f n)) \u2227 \u2200 (m n : \u2115), m < n \u2192 r (f m) (f n)"}, {"line": "classical\n    have : Nonempty \u03b1 := by\n      rcases h \u2205 (by simp) with \u27e8y, _\u27e9\n      exact \u27e8y\u27e9\n    choose! F hF using h\n    have h' : \u2200 s : Finset \u03b1, \u2203 y, (\u2200 x \u2208 s, P x) \u2192 P y \u2227 \u2200 x \u2208 s, r x y := fun s => \u27e8F s, hF s\u27e9\n    set f := seqOfForallFinsetExistsAux P r h' with hf\n    have A : \u2200 n : \u2115, P (f n) := by\n      intro n\n      induction' n using Nat.strong_induction_on with n IH\n      have IH' : \u2200 x : Fin n, P (f x) := fun n => IH n.1 n.2\n      rw [hf]\n      rw [seqOfForallFinsetExistsAux]\n      exact\n        (Classical.choose_spec\n            (h' (Finset.image (fun i : Fin n => f i) (Finset.univ : Finset (Fin n))))\n            (by simp [IH'])).1\n    refine \u27e8f, A, fun m n hmn => ?_\u27e9\n    conv_rhs => rw [hf]\n    rw [seqOfForallFinsetExistsAux]\n    apply\n      (Classical.choose_spec\n          (h' (Finset.image (fun i : Fin n => f i) (Finset.univ : Finset (Fin n)))) (by simp [A])).2\n    exact Finset.mem_image.2 \u27e8\u27e8m, hmn\u27e9, Finset.mem_univ _, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_seq_of_forall_finset_exists' {\u03b1 : Type*} (P : \u03b1 \u2192 Prop) (r : \u03b1 \u2192 \u03b1 \u2192 Prop)\n    [IsSymm \u03b1 r] (h : \u2200 s : Finset \u03b1, (\u2200 x \u2208 s, P x) \u2192 \u2203 y, P y \u2227 \u2200 x \u2208 s, r x y) :\n    \u2203 f : \u2115 \u2192 \u03b1, (\u2200 n, P (f n)) \u2227 Pairwise (r on f) := by\n  rcases exists_seq_of_forall_finset_exists P r h with \u27e8f, hf, hf'\u27e9\n  refine \u27e8f, hf, fun m n hmn => ?_\u27e9\n  rcases lt_trichotomy m n with (h | rfl | h)\n  \u00b7 exact hf' m n h\n  \u00b7 exact (hmn rfl).elim\n  \u00b7 unfold Function.onFun\n    apply symm\n    exact hf' n m h", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Basic.lean", "context": {"open": ["Function", "Nat", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[Fintype \u03b1] [Fintype \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\nP : \u03b1 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsSymm \u03b1 r\nh : \u2200 (s : Finset \u03b1), (\u2200 x \u2208 s, P x) \u2192 \u2203 y, P y \u2227 \u2200 x \u2208 s, r x y\n\u22a2 \u2203 f, (\u2200 (n : \u2115), P (f n)) \u2227 Pairwise (onFun r f)"}, {"line": "rcases exists_seq_of_forall_finset_exists P r h with \u27e8f, hf, hf'\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_4\nP : \u03b1 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsSymm \u03b1 r\nh : \u2200 (s : Finset \u03b1), (\u2200 x \u2208 s, P x) \u2192 \u2203 y, P y \u2227 \u2200 x \u2208 s, r x y\nf : \u2115 \u2192 \u03b1\nhf : \u2200 (n : \u2115), P (f n)\nhf' : \u2200 (m n : \u2115), m < n \u2192 r (f m) (f n)\n\u22a2 \u2203 f, (\u2200 (n : \u2115), P (f n)) \u2227 Pairwise (onFun r f)"}, {"line": "refine \u27e8f, hf, fun m n hmn => ?_\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_4\nP : \u03b1 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsSymm \u03b1 r\nh : \u2200 (s : Finset \u03b1), (\u2200 x \u2208 s, P x) \u2192 \u2203 y, P y \u2227 \u2200 x \u2208 s, r x y\nf : \u2115 \u2192 \u03b1\nhf : \u2200 (n : \u2115), P (f n)\nhf' : \u2200 (m n : \u2115), m < n \u2192 r (f m) (f n)\nm n : \u2115\nhmn : m \u2260 n\n\u22a2 onFun r f m n"}, {"line": "rcases lt_trichotomy m n with (h | rfl | h)", "tactic_state": "case intro.intro.inl\n\u03b1 : Type u_4\nP : \u03b1 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsSymm \u03b1 r\nh\u271d : \u2200 (s : Finset \u03b1), (\u2200 x \u2208 s, P x) \u2192 \u2203 y, P y \u2227 \u2200 x \u2208 s, r x y\nf : \u2115 \u2192 \u03b1\nhf : \u2200 (n : \u2115), P (f n)\nhf' : \u2200 (m n : \u2115), m < n \u2192 r (f m) (f n)\nm n : \u2115\nhmn : m \u2260 n\nh : m < n\n\u22a2 onFun r f m n\n---\ncase intro.intro.inr.inl\n\u03b1 : Type u_4\nP : \u03b1 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsSymm \u03b1 r\nh : \u2200 (s : Finset \u03b1), (\u2200 x \u2208 s, P x) \u2192 \u2203 y, P y \u2227 \u2200 x \u2208 s, r x y\nf : \u2115 \u2192 \u03b1\nhf : \u2200 (n : \u2115), P (f n)\nhf' : \u2200 (m n : \u2115), m < n \u2192 r (f m) (f n)\nm : \u2115\nhmn : m \u2260 m\n\u22a2 onFun r f m m\n---\ncase intro.intro.inr.inr\n\u03b1 : Type u_4\nP : \u03b1 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsSymm \u03b1 r\nh\u271d : \u2200 (s : Finset \u03b1), (\u2200 x \u2208 s, P x) \u2192 \u2203 y, P y \u2227 \u2200 x \u2208 s, r x y\nf : \u2115 \u2192 \u03b1\nhf : \u2200 (n : \u2115), P (f n)\nhf' : \u2200 (m n : \u2115), m < n \u2192 r (f m) (f n)\nm n : \u2115\nhmn : m \u2260 n\nh : n < m\n\u22a2 onFun r f m n"}, {"line": "\u00b7 exact hf' m n h", "tactic_state": "case intro.intro.inr.inl\n\u03b1 : Type u_4\nP : \u03b1 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsSymm \u03b1 r\nh : \u2200 (s : Finset \u03b1), (\u2200 x \u2208 s, P x) \u2192 \u2203 y, P y \u2227 \u2200 x \u2208 s, r x y\nf : \u2115 \u2192 \u03b1\nhf : \u2200 (n : \u2115), P (f n)\nhf' : \u2200 (m n : \u2115), m < n \u2192 r (f m) (f n)\nm : \u2115\nhmn : m \u2260 m\n\u22a2 onFun r f m m\n---\ncase intro.intro.inr.inr\n\u03b1 : Type u_4\nP : \u03b1 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsSymm \u03b1 r\nh\u271d : \u2200 (s : Finset \u03b1), (\u2200 x \u2208 s, P x) \u2192 \u2203 y, P y \u2227 \u2200 x \u2208 s, r x y\nf : \u2115 \u2192 \u03b1\nhf : \u2200 (n : \u2115), P (f n)\nhf' : \u2200 (m n : \u2115), m < n \u2192 r (f m) (f n)\nm n : \u2115\nhmn : m \u2260 n\nh : n < m\n\u22a2 onFun r f m n"}, {"line": "\u00b7 exact (hmn rfl).elim", "tactic_state": "case intro.intro.inr.inr\n\u03b1 : Type u_4\nP : \u03b1 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsSymm \u03b1 r\nh\u271d : \u2200 (s : Finset \u03b1), (\u2200 x \u2208 s, P x) \u2192 \u2203 y, P y \u2227 \u2200 x \u2208 s, r x y\nf : \u2115 \u2192 \u03b1\nhf : \u2200 (n : \u2115), P (f n)\nhf' : \u2200 (m n : \u2115), m < n \u2192 r (f m) (f n)\nm n : \u2115\nhmn : m \u2260 n\nh : n < m\n\u22a2 onFun r f m n"}, {"line": "\u00b7 unfold Function.onFun\n    apply symm\n    exact hf' n m h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_valEmbedding_univ : (Finset.univ : Finset (Fin n)).map Fin.valEmbedding = Iio n := by\n  ext\n  simp [orderIsoSubtype.symm.surjective.exists, OrderIso.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Fin.lean", "context": {"open": ["List (Vector)", "Finset", "Fintype"], "variables": ["{\u03b1 \u03b2 : Type*} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 map Fin.valEmbedding univ = Iio n"}, {"line": "ext", "tactic_state": "case h\nn a\u271d : \u2115\n\u22a2 a\u271d \u2208 map Fin.valEmbedding univ \u2194 a\u271d \u2208 Iio n"}, {"line": "simp [orderIsoSubtype.symm.surjective.exists, OrderIso.symm]", "tactic_state": "case h\nn a\u271d : \u2115\n\u22a2 (\u2203 a, \u2191a = a\u271d) \u2194 a\u271d < n"}]}
{"declaration": "theorem Ioi_succ (i : Fin n) : Ioi i.succ = (Ioi i).map (Fin.succEmb _) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Fin.lean", "context": {"open": ["List (Vector)", "Finset", "Fintype"], "variables": ["{\u03b1 \u03b2 : Type*} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 Ioi i.succ = map (Fin.succEmb n) (Ioi i)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Iio_castSucc (i : Fin n) : Iio (castSucc i) = (Iio i).map Fin.castSuccEmb := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Fin.lean", "context": {"open": ["List (Vector)", "Finset", "Fintype"], "variables": ["{\u03b1 \u03b2 : Type*} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_3\ncastSucc : x\u271d\ni : Fin n\n\u22a2 Iio sorry = map Fin.castSuccEmb (Iio i)"}, {"line": "simp", "tactic_state": "n : \u2115\nx\u271d : Sort u_3\ncastSucc : x\u271d\ni : Fin n\n\u22a2 Iio (sorry ()) = Iio i.castSucc"}]}
{"declaration": "theorem card_filter_univ_eq_vector_get_eq_count [DecidableEq \u03b1] (a : \u03b1) (v : List.Vector \u03b1 n) :\n    #{i | v.get i = a} = v.toList.count a := by\n  induction' v with n x xs hxs\n  \u00b7 simp\n  \u00b7 simp_rw [card_filter_univ_succ', Vector.get_cons_zero, Vector.toList_cons, Vector.get_cons_succ,\n      hxs, List.count_cons, add_comm (ite (x = a) 1 0), beq_iff_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Fin.lean", "context": {"open": ["List (Vector)", "Finset", "Fintype"], "variables": ["{\u03b1 \u03b2 : Type*} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : \u2115\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nv : List.Vector \u03b1 n\n\u22a2 {i | v.get i = a}.card = List.count a v.toList"}, {"line": "induction' v with n x xs hxs", "tactic_state": "case nil\n\u03b1 : Type u_1\nn : \u2115\ninst\u271d : DecidableEq \u03b1\na : \u03b1\n\u22a2 {i | Vector.nil.get i = a}.card = List.count a Vector.nil.toList\n---\ncase cons\n\u03b1 : Type u_1\nn\u271d : \u2115\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nn : \u2115\nx : \u03b1\nxs : List.Vector \u03b1 n\nhxs : {i | xs.get i = a}.card = List.count a xs.toList\n\u22a2 {i | (x ::\u1d65 xs).get i = a}.card = List.count a (x ::\u1d65 xs).toList"}, {"line": "\u00b7 simp", "tactic_state": "case cons\n\u03b1 : Type u_1\nn\u271d : \u2115\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nn : \u2115\nx : \u03b1\nxs : List.Vector \u03b1 n\nhxs : {i | xs.get i = a}.card = List.count a xs.toList\n\u22a2 {i | (x ::\u1d65 xs).get i = a}.card = List.count a (x ::\u1d65 xs).toList"}, {"line": "\u00b7 simp_rw [card_filter_univ_succ', Vector.get_cons_zero, Vector.toList_cons, Vector.get_cons_succ,\n      hxs, List.count_cons, add_comm (ite (x = a) 1 0), beq_iff_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Fintype.card_finset_len [Fintype \u03b1] (k : \u2115) :\n    Fintype.card { s : Finset \u03b1 // #s = k } = Nat.choose (Fintype.card \u03b1) k := by\n  simp [Fintype.subtype_card, Finset.card_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Powerset.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 : Type*}", "[Fintype \u03b1] {s : Finset \u03b1} {k : \u2115}", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : Fintype \u03b1\nk : \u2115\n\u22a2 card { s // s.card = k } = (card \u03b1).choose k"}, {"line": "simp [Fintype.subtype_card, Finset.card_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toLeft_eq_univ : u.toLeft = univ \u2194 univ.map .inl \u2286 u := by\n  simp [map_inl_subset_iff_subset_toLeft]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sum.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b1 \u03b2 : Type*} {u : Finset (\u03b1 \u2295 \u03b2)} {s : Finset \u03b1} {t : Finset \u03b2}", "[Fintype \u03b1] {u : Finset (\u03b1 \u2295 \u03b2)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : Fintype \u03b1\nu : Finset (\u03b1 \u2295 \u03b2)\n\u22a2 u.toLeft = univ \u2194 map Function.Embedding.inl univ \u2286 u"}, {"line": "simp [map_inl_subset_iff_subset_toLeft]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toRight_eq_empty : u.toRight = \u2205 \u2194 u \u2286 univ.map .inl := by simp [subset_map_inl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sum.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b1 \u03b2 : Type*} {u : Finset (\u03b1 \u2295 \u03b2)} {s : Finset \u03b1} {t : Finset \u03b2}", "[Fintype \u03b1] {u : Finset (\u03b1 \u2295 \u03b2)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : Fintype \u03b1\nu : Finset (\u03b1 \u2295 \u03b2)\n\u22a2 u.toRight = \u2205 \u2194 u \u2286 map Function.Embedding.inl univ"}, {"line": "simp [subset_map_inl]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toRight_eq_univ : u.toRight = univ \u2194 univ.map .inr \u2286 u := by\n  simp [map_inr_subset_iff_subset_toRight]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sum.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b1 \u03b2 : Type*} {u : Finset (\u03b1 \u2295 \u03b2)} {s : Finset \u03b1} {t : Finset \u03b2}", "[Fintype \u03b1] {u : Finset (\u03b1 \u2295 \u03b2)}", "[Fintype \u03b2] {u : Finset (\u03b1 \u2295 \u03b2)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nu : Finset (\u03b1 \u2295 \u03b2)\n\u22a2 u.toRight = univ \u2194 map Function.Embedding.inr univ \u2286 u"}, {"line": "simp [map_inr_subset_iff_subset_toRight]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toLeft_eq_empty : u.toLeft = \u2205 \u2194 u \u2286 univ.map .inr := by simp [subset_map_inr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sum.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b1 \u03b2 : Type*} {u : Finset (\u03b1 \u2295 \u03b2)} {s : Finset \u03b1} {t : Finset \u03b2}", "[Fintype \u03b1] {u : Finset (\u03b1 \u2295 \u03b2)}", "[Fintype \u03b2] {u : Finset (\u03b1 \u2295 \u03b2)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nu : Finset (\u03b1 \u2295 \u03b2)\n\u22a2 u.toLeft = \u2205 \u2194 u \u2286 map Function.Embedding.inr univ"}, {"line": "simp [subset_map_inr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Fintype.card_subtype_or (p q : \u03b1 \u2192 Prop) [Fintype { x // p x }] [Fintype { x // q x }]\n    [Fintype { x // p x \u2228 q x }] :\n    Fintype.card { x // p x \u2228 q x } \u2264 Fintype.card { x // p x } + Fintype.card { x // q x } := by\n  classical\n    convert Fintype.card_le_of_embedding (subtypeOrLeftEmbedding p q)\n    rw [Fintype.card_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sum.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b1 \u03b2 : Type*} {u : Finset (\u03b1 \u2295 \u03b2)} {s : Finset \u03b1} {t : Finset \u03b2}", "[Fintype \u03b1] {u : Finset (\u03b1 \u2295 \u03b2)}", "[Fintype \u03b2] {u : Finset (\u03b1 \u2295 \u03b2)}", "[Fintype \u03b1] [Fintype \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u2074 inst\u271d\u00b3 : Fintype \u03b1\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b2 : Fintype { x // p x }\ninst\u271d\u00b9 : Fintype { x // q x }\ninst\u271d : Fintype { x // p x \u2228 q x }\n\u22a2 card { x // p x \u2228 q x } \u2264 card { x // p x } + card { x // q x }"}, {"line": "classical\n    convert Fintype.card_le_of_embedding (subtypeOrLeftEmbedding p q)\n    rw [Fintype.card_sum]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nat.card_eq_card_units_add_one [GroupWithZero \u03b1] [Finite \u03b1] :\n    Nat.card \u03b1 = Nat.card \u03b1\u02e3 + 1 := by\n  rw [Nat.card_units]\n  rw [tsub_add_cancel_of_le Nat.card_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Units.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : GroupWithZero \u03b1\ninst\u271d : Finite \u03b1\n\u22a2 Nat.card \u03b1 = Nat.card \u03b1\u02e3 + 1"}, {"line": "rw [Nat.card_units]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : GroupWithZero \u03b1\ninst\u271d : Finite \u03b1\n\u22a2 Nat.card \u03b1 = Nat.card \u03b1 - 1 + 1"}, {"line": "rw [tsub_add_cancel_of_le Nat.card_pos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Fintype.card_units [GroupWithZero \u03b1] [Fintype \u03b1] [DecidableEq \u03b1] :\n    Fintype.card \u03b1\u02e3 = Fintype.card \u03b1 - 1 := by\n  rw [\u2190 Nat.card_eq_fintype_card]\n  rw [Nat.card_units]\n  rw [Nat.card_eq_fintype_card]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Units.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : GroupWithZero \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 card \u03b1\u02e3 = card \u03b1 - 1"}, {"line": "rw [\u2190 Nat.card_eq_fintype_card]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : GroupWithZero \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 Nat.card \u03b1\u02e3 = card \u03b1 - 1"}, {"line": "rw [Nat.card_units]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : GroupWithZero \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 Nat.card \u03b1 - 1 = card \u03b1 - 1"}, {"line": "rw [Nat.card_eq_fintype_card]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Fintype.card_eq_card_units_add_one [GroupWithZero \u03b1] [Fintype \u03b1] [DecidableEq \u03b1] :\n    Fintype.card \u03b1 = Fintype.card \u03b1\u02e3 + 1 := by\n  rw [Fintype.card_units]\n  rw [tsub_add_cancel_of_le Fintype.card_pos]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Units.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : GroupWithZero \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 card \u03b1 = card \u03b1\u02e3 + 1"}, {"line": "rw [Fintype.card_units]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : GroupWithZero \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 card \u03b1 = card \u03b1 - 1 + 1"}, {"line": "rw [tsub_add_cancel_of_le Fintype.card_pos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_bool [CommMonoid \u03b1] (f : Bool \u2192 \u03b1) : \u220f b, f b = f true * f false := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/BigOperators.lean", "context": {"open": ["Mathlib"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommMonoid \u03b1\nf : Bool \u2192 \u03b1\n\u22a2 \u220f b, f b = f true * f false"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_extend_by_one [CommMonoid \u03b1] (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) :\n    \u220f i, (if i \u2208 s then f i else 1) = \u220f i \u2208 s, f i := by\n  rw [\u2190 prod_filter]\n  rw [filter_mem_eq_inter]\n  rw [univ_inter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/BigOperators.lean", "context": {"open": ["Mathlib", "Finset"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : CommMonoid \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 (\u220f i, if i \u2208 s then f i else 1) = \u220f i \u2208 s, f i"}, {"line": "rw [\u2190 prod_filter]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : CommMonoid \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 \u220f a \u2208 {a | a \u2208 s}, f a = \u220f i \u2208 s, f i"}, {"line": "rw [filter_mem_eq_inter]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : CommMonoid \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 \u220f a \u2208 univ \u2229 s, f a = \u220f i \u2208 s, f i\n---\n\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : CommMonoid \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 DecidableEq \u03b9"}, {"line": "rw [univ_inter]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : CommMonoid \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 DecidableEq \u03b9"}]}
{"declaration": "theorem prod_eq_mul {f : \u03b1 \u2192 M} (a b : \u03b1) (h\u2081 : a \u2260 b) (h\u2082 : \u2200 x, x \u2260 a \u2227 x \u2260 b \u2192 f x = 1) :\n    \u220f x, f x = f a * f b := by\n  apply Finset.prod_eq_mul a b h\u2081 fun x _ hx => h\u2082 x hx <;>\n    exact fun hc => (hc (Finset.mem_univ _)).elim\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/BigOperators.lean", "context": {"open": ["Mathlib", "Finset"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]", "{M : Type*} [Fintype \u03b1] [CommMonoid M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_5\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\na b : \u03b1\nh\u2081 : a \u2260 b\nh\u2082 : \u2200 (x : \u03b1), x \u2260 a \u2227 x \u2260 b \u2192 f x = 1\n\u22a2 \u220f x, f x = f a * f b"}, {"line": "apply Finset.prod_eq_mul a b h\u2081 fun x _ hx => h\u2082 x hx <;>\n    exact fun hc => (hc (Finset.mem_univ _)).elim", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_piFinset_const {\u03b1 : Type*} (s : Finset \u03b1) (n : \u2115) :\n    #(piFinset fun _ : Fin n \u21a6 s) = #s ^ n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/BigOperators.lean", "context": {"open": ["Mathlib", "Finset", "Finset", "Finset"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]", "{M : Type*} [Fintype \u03b1] [CommMonoid M]", "{M : Type*} [Fintype \u03b1] [CommMonoid M]", "{\u03b9 \u03ba : Type*} {\u03b1 : \u03b9 \u2192 Type*} [DecidableEq \u03b9] [DecidableEq \u03ba]", "[Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_11\npiFinset : x\u271d\n\u03b1 : Type u_10\ns : Finset \u03b1\nn : \u2115\n\u22a2 sorry.card = s.card ^ n"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_11\npiFinset : x\u271d\n\u03b1 : Type u_10\ns : Finset \u03b1\nn : \u2115\n\u22a2 (sorry ()).card = s.card ^ n"}]}
{"declaration": "theorem Finset.prod_fin_eq_prod_range [CommMonoid \u03b2] {n : \u2115} (c : Fin n \u2192 \u03b2) :\n    \u220f i, c i = \u220f i \u2208 Finset.range n, if h : i < n then c \u27e8i, h\u27e9 else 1 := by\n  rw [\u2190 Fin.prod_univ_eq_prod_range]\n  rw [Finset.prod_congr rfl]\n  rintro \u27e8i, hi\u27e9 _\n  simp only [hi]\n  simp only [dif_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/BigOperators.lean", "context": {"open": ["Mathlib", "Finset", "Finset", "Finset"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]", "{M : Type*} [Fintype \u03b1] [CommMonoid M]", "{M : Type*} [Fintype \u03b1] [CommMonoid M]", "{\u03b9 \u03ba : Type*} {\u03b1 : \u03b9 \u2192 Type*} [DecidableEq \u03b9] [DecidableEq \u03ba]", "[Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\ninst\u271d : CommMonoid \u03b2\nn : \u2115\nc : Fin n \u2192 \u03b2\n\u22a2 \u220f i, c i = \u220f i \u2208 range n, if h : i < n then c \u27e8i, h\u27e9 else 1"}, {"line": "rw [\u2190 Fin.prod_univ_eq_prod_range]", "tactic_state": "\u03b2 : Type u_2\ninst\u271d : CommMonoid \u03b2\nn : \u2115\nc : Fin n \u2192 \u03b2\n\u22a2 \u220f i, c i = \u220f i, if h : \u2191i < n then c \u27e8\u2191i, h\u27e9 else 1"}, {"line": "rw [Finset.prod_congr rfl]", "tactic_state": "\u03b2 : Type u_2\ninst\u271d : CommMonoid \u03b2\nn : \u2115\nc : Fin n \u2192 \u03b2\n\u22a2 \u2200 x \u2208 univ, c x = if h : \u2191x < n then c \u27e8\u2191x, h\u27e9 else 1"}, {"line": "rintro \u27e8i, hi\u27e9 _", "tactic_state": "case mk\n\u03b2 : Type u_2\ninst\u271d : CommMonoid \u03b2\nn : \u2115\nc : Fin n \u2192 \u03b2\ni : \u2115\nhi : i < n\na\u271d : \u27e8i, hi\u27e9 \u2208 univ\n\u22a2 c \u27e8i, hi\u27e9 = if h : \u2191\u27e8i, hi\u27e9 < n then c \u27e8\u2191\u27e8i, hi\u27e9, h\u27e9 else 1"}, {"line": "simp only [hi]", "tactic_state": "case mk\n\u03b2 : Type u_2\ninst\u271d : CommMonoid \u03b2\nn : \u2115\nc : Fin n \u2192 \u03b2\ni : \u2115\nhi : i < n\na\u271d : \u27e8i, hi\u27e9 \u2208 univ\n\u22a2 c \u27e8i, hi\u27e9 = if h : True then c \u27e8i, \u22ef\u27e9 else 1"}, {"line": "simp only [dif_pos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finset.card_compl_add_card [DecidableEq \u03b1] [Fintype \u03b1] (s : Finset \u03b1) :\n    #s\u1d9c + #s = Fintype.card \u03b1 := by\n  rw [Nat.add_comm]\n  rw [card_add_card_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Card.lean", "context": {"open": ["Function", "Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\n\u22a2 s\u1d9c.card + s.card = Fintype.card \u03b1"}, {"line": "rw [Nat.add_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\n\u22a2 s.card + s\u1d9c.card = Fintype.card \u03b1"}, {"line": "rw [card_add_card_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem List.Nodup.length_le_card {\u03b1 : Type*} [Fintype \u03b1] {l : List \u03b1} (h : l.Nodup) :\n    l.length \u2264 Fintype.card \u03b1 := by\n  classical exact List.toFinset_card_of_nodup h \u25b8 l.toFinset.card_le_univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Card.lean", "context": {"open": ["Function", "Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d : Fintype \u03b1\nl : List \u03b1\nh : l.Nodup\n\u22a2 l.length \u2264 Fintype.card \u03b1"}, {"line": "classical exact List.toFinset_card_of_nodup h \u25b8 l.toFinset.card_le_univ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem injective_iff_bijective {f : \u03b1 \u2192 \u03b1} : Injective f \u2194 Bijective f := by\n  simp [Bijective, injective_iff_surjective]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Card.lean", "context": {"open": ["Function", "Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[Fintype \u03b1] [Fintype \u03b2]", "[Finite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Finite \u03b1\nf : \u03b1 \u2192 \u03b1\n\u22a2 Injective f \u2194 Bijective f"}, {"line": "simp [Bijective, injective_iff_surjective]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Finite \u03b1\nf : \u03b1 \u2192 \u03b1\n\u22a2 Injective f \u2192 Surjective f"}]}
{"declaration": "theorem surjective_iff_bijective {f : \u03b1 \u2192 \u03b1} : Surjective f \u2194 Bijective f := by\n  simp [Bijective, injective_iff_surjective]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Card.lean", "context": {"open": ["Function", "Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[Fintype \u03b1] [Fintype \u03b2]", "[Finite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Finite \u03b1\nf : \u03b1 \u2192 \u03b1\n\u22a2 Surjective f \u2194 Bijective f"}, {"line": "simp [Bijective, injective_iff_surjective]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Finite \u03b1\nf : \u03b1 \u2192 \u03b1\n\u22a2 Surjective f \u2192 Injective f"}]}
{"declaration": "lemma Finset.exists_superset_card_eq [Fintype \u03b1] {n : \u2115} {s : Finset \u03b1} (hsn : #s \u2264 n)\n    (hn\u03b1 : n \u2264 Fintype.card \u03b1) :\n    \u2203 t, s \u2286 t \u2227 #t = n := by simpa using exists_subsuperset_card_eq s.subset_univ hsn hn\u03b1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Card.lean", "context": {"open": ["Function", "Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[Fintype \u03b1] [Fintype \u03b2]", "[Finite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Fintype \u03b1\nn : \u2115\ns : Finset \u03b1\nhsn : s.card \u2264 n\nhn\u03b1 : n \u2264 Fintype.card \u03b1\n\u22a2 \u2203 t, s \u2286 t \u2227 t.card = n"}, {"line": "simpa using exists_subsuperset_card_eq s.subset_univ hsn hn\u03b1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem set_fintype_card_eq_univ_iff [Fintype \u03b1] (s : Set \u03b1) [Fintype s] :\n    Fintype.card s = Fintype.card \u03b1 \u2194 s = Set.univ := by\n  rw [\u2190 Set.toFinset_card]\n  rw [Finset.card_eq_iff_eq_univ]\n  rw [\u2190 Set.toFinset_univ]\n  rw [Set.toFinset_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Card.lean", "context": {"open": ["Function", "Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[Fintype \u03b1] [Fintype \u03b2]", "[Finite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : Finite \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\n\u22a2 Fintype.card \u2191s = Fintype.card \u03b1 \u2194 s = Set.univ"}, {"line": "rw [\u2190 Set.toFinset_card]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : Finite \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\n\u22a2 s.toFinset.card = Fintype.card \u03b1 \u2194 s = Set.univ"}, {"line": "rw [Finset.card_eq_iff_eq_univ]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : Finite \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\n\u22a2 s.toFinset = univ \u2194 s = Set.univ"}, {"line": "rw [\u2190 Set.toFinset_univ]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : Finite \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\n\u22a2 s.toFinset = Set.univ.toFinset \u2194 s = Set.univ\n---\n\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : Finite \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\n\u22a2 Fintype \u2191Set.univ"}, {"line": "rw [Set.toFinset_inj]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : Finite \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\n\u22a2 Fintype \u2191Set.univ"}]}
{"declaration": "theorem univ_eq_singleton_of_card_one {\u03b1} [Fintype \u03b1] (x : \u03b1) (h : Fintype.card \u03b1 = 1) :\n    (univ : Finset \u03b1) = {x} := by\n  symm\n  apply eq_of_subset_of_card_le (subset_univ {x})\n  apply le_of_eq\n  simp [h, Finset.card_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Card.lean", "context": {"open": ["Function", "Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[Fintype \u03b1] [Fintype \u03b2]", "[Finite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d : Fintype \u03b1\nx : \u03b1\nh : Fintype.card \u03b1 = 1\n\u22a2 univ = {x}"}, {"line": "symm", "tactic_state": "\u03b1 : Type u_4\ninst\u271d : Fintype \u03b1\nx : \u03b1\nh : Fintype.card \u03b1 = 1\n\u22a2 {x} = univ"}, {"line": "apply eq_of_subset_of_card_le (subset_univ {x})", "tactic_state": "\u03b1 : Type u_4\ninst\u271d : Fintype \u03b1\nx : \u03b1\nh : Fintype.card \u03b1 = 1\n\u22a2 univ.card \u2264 {x}.card"}, {"line": "apply le_of_eq", "tactic_state": "case hab\n\u03b1 : Type u_4\ninst\u271d : Fintype \u03b1\nx : \u03b1\nh : Fintype.card \u03b1 = 1\n\u22a2 univ.card = {x}.card"}, {"line": "simp [h, Finset.card_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finset.card_fin (n : \u2115) : #(univ : Finset (Fin n)) = n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Card.lean", "context": {"open": ["Function", "Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[Fintype \u03b1] [Fintype \u03b2]", "[Finite \u03b1]", "[Finite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 univ.card = n"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Fin.cast_eq_cast' {n m : \u2115} (h : Fin n = Fin m) :\n    _root_.cast h = Fin.cast (fin_injective h) := by\n  cases fin_injective h\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Card.lean", "context": {"open": ["Function", "Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[Fintype \u03b1] [Fintype \u03b2]", "[Finite \u03b1]", "[Finite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : Fin n = Fin m\n\u22a2 cast h = Fin.cast \u22ef"}, {"line": "cases fin_injective h", "tactic_state": "case refl\nn : \u2115\nh : Fin n = Fin n\n\u22a2 cast h = Fin.cast \u22ef"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_finset_fin_le {n : \u2115} (s : Finset (Fin n)) : #s \u2264 n := by\n  simpa only [Fintype.card_fin] using s.card_le_univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Card.lean", "context": {"open": ["Function", "Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[Fintype \u03b1] [Fintype \u03b2]", "[Finite \u03b1]", "[Finite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ns : Finset (Fin n)\n\u22a2 s.card \u2264 n"}, {"line": "simpa only [Fintype.card_fin] using s.card_le_univ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nodup_map_iff_injOn {f : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} :\n    (Multiset.map f s.val).Nodup \u2194 Set.InjOn f s := by\n  simp [Multiset.nodup_map_iff_inj_on s.nodup, Set.InjOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Defs.lean", "context": {"open": ["Function", "Nat"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\n\u22a2 (Multiset.map f s.val).Nodup \u2194 Set.InjOn f \u2191s"}, {"line": "simp [Multiset.nodup_map_iff_inj_on s.nodup, Set.InjOn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_univ_val : \u2200 x, x \u2208 (univ : Finset \u03b1).1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Defs.lean", "context": {"open": ["Function", "Nat"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[DecidableEq \u03b1] {a : \u03b1} {f : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} {t : Set \u03b2} {t' : Finset \u03b2}", "[Fintype \u03b1] {s t : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nuniv : Finset \u03b1\n\u22a2 \u2200 (x : \u03b1), x \u2208 univ.val"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nuniv : Finset \u03b1\n\u22a2 \u2200 (x : \u03b1), x \u2208 univ"}]}
{"declaration": "theorem eq_univ_iff_forall : s = univ \u2194 \u2200 x, x \u2208 s := by simp [Finset.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Defs.lean", "context": {"open": ["Function", "Nat"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[DecidableEq \u03b1] {a : \u03b1} {f : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} {t : Set \u03b2} {t' : Finset \u03b2}", "[Fintype \u03b1] {s t : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns univ : Finset \u03b1\n\u22a2 s = univ \u2194 \u2200 (x : \u03b1), x \u2208 s"}, {"line": "simp [Finset.ext_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns univ : Finset \u03b1\n\u22a2 (\u2200 (a : \u03b1), a \u2208 s \u2194 a \u2208 univ) \u2194 \u2200 (x : \u03b1), x \u2208 s"}]}
{"declaration": "theorem nodup_map_univ_iff_injective [Fintype \u03b1] {f : \u03b1 \u2192 \u03b2} :\n    (Multiset.map f univ.val).Nodup \u2194 Function.Injective f := by\n  rw [nodup_map_iff_injOn]\n  rw [coe_univ]\n  rw [Set.injective_iff_injOn_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Defs.lean", "context": {"open": ["Function", "Nat", "Lean Elab Term Meta Batteries.ExtendedBinder Parser.Term PrettyPrinter.Delaborator SubExpr", "Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[DecidableEq \u03b1] {a : \u03b1} {f : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} {t : Set \u03b2} {t' : Finset \u03b2}", "[Fintype \u03b1] {s t : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 inst\u271d : Fintype \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (Multiset.map f univ.val).Nodup \u2194 Injective f"}, {"line": "rw [nodup_map_iff_injOn]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 inst\u271d : Fintype \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 Set.InjOn f \u2191univ \u2194 Injective f"}, {"line": "rw [coe_univ]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 inst\u271d : Fintype \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 Set.InjOn f Set.univ \u2194 Injective f"}, {"line": "rw [Set.injective_iff_injOn_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toEmbedding_equivOfFiniteSelfEmbedding [Finite \u03b1] (e : \u03b1 \u21aa \u03b1) :\n    e.equivOfFiniteSelfEmbedding.toEmbedding = e := by\n  ext\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/EquivFin.lean", "context": {"open": ["Function", "Finset Function", "Fintype"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[Fintype \u03b1] [Fintype \u03b2]", "[Fintype \u03b1] [Fintype \u03b2]", "[Fintype \u03b1] [Fintype \u03b2]", "[Fintype \u03b1] [Fintype \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Finite \u03b1\ne : \u03b1 \u21aa \u03b1\n\u22a2 e.equivOfFiniteSelfEmbedding.toEmbedding = e"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Finite \u03b1\ne : \u03b1 \u21aa \u03b1\nx\u271d : \u03b1\n\u22a2 e.equivOfFiniteSelfEmbedding.toEmbedding x\u271d = e x\u271d"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonempty_of_card_le [Fintype \u03b1] [Fintype \u03b2] (h : Fintype.card \u03b1 \u2264 Fintype.card \u03b2) :\n    Nonempty (\u03b1 \u21aa \u03b2) := by classical exact (truncOfCardLE h).nonempty\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/EquivFin.lean", "context": {"open": ["Function", "Finset Function", "Fintype"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[Fintype \u03b1] [Fintype \u03b2]", "[Fintype \u03b1] [Fintype \u03b2]", "[Fintype \u03b1] [Fintype \u03b2]", "[Fintype \u03b1] [Fintype \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2079 : Fintype \u03b1\ninst\u271d\u2078 : Fintype \u03b2\ninst\u271d\u2077 : Fintype \u03b1\ninst\u271d\u2076 : Fintype \u03b2\ninst\u271d\u2075 : Fintype \u03b1\ninst\u271d\u2074 : Fintype \u03b2\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : Fintype \u03b2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nh : Fintype.card \u03b1 \u2264 Fintype.card \u03b2\n\u22a2 Nonempty (\u03b1 \u21aa \u03b2)"}, {"line": "classical exact (truncOfCardLE h).nonempty", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finset.exists_minimal {\u03b1 : Type*} [Preorder \u03b1] (s : Finset \u03b1) (h : s.Nonempty) :\n    \u2203 m \u2208 s, \u2200 x \u2208 s, \u00acx < m := by\n  obtain \u27e8c, hcs : c \u2208 s\u27e9 := h\n  have : WellFounded (@LT.lt { x // x \u2208 s } _) := Finite.wellFounded_of_trans_of_irrefl _\n  obtain \u27e8\u27e8m, hms : m \u2208 s\u27e9, -, H\u27e9 := this.has_min Set.univ \u27e8\u27e8c, hcs\u27e9, trivial\u27e9\n  exact \u27e8m, hms, fun x hx hxm => H \u27e8x, hx\u27e9 trivial hxm\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/EquivFin.lean", "context": {"open": ["Function", "Finset Function", "Fintype", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[Fintype \u03b1] [Fintype \u03b2]", "[Fintype \u03b1] [Fintype \u03b2]", "[Fintype \u03b1] [Fintype \u03b2]", "[Fintype \u03b1] [Fintype \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\ns : Finset \u03b1\nh : s.Nonempty\n\u22a2 \u2203 m \u2208 s, \u2200 x \u2208 s, \u00acx < m"}, {"line": "obtain \u27e8c, hcs : c \u2208 s\u27e9 := h", "tactic_state": "case intro\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\ns : Finset \u03b1\nc : \u03b1\nhcs : c \u2208 s\n\u22a2 \u2203 m \u2208 s, \u2200 x \u2208 s, \u00acx < m"}, {"line": "have : WellFounded (@LT.lt { x // x \u2208 s } _) := Finite.wellFounded_of_trans_of_irrefl _", "tactic_state": "case intro\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\ns : Finset \u03b1\nc : \u03b1\nhcs : c \u2208 s\nthis : WellFounded sorry\n\u22a2 \u2203 m \u2208 s, \u2200 x \u2208 s, \u00acx < m"}, {"line": "obtain \u27e8\u27e8m, hms : m \u2208 s\u27e9, -, H\u27e9 := this.has_min Set.univ \u27e8\u27e8c, hcs\u27e9, trivial\u27e9", "tactic_state": "case intro.intro.mk.intro\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\ns : Finset \u03b1\nc : \u03b1\nhcs : c \u2208 s\nthis : WellFounded sorry\nm : \u03b1\nhms : m \u2208 s\nH : \u2200 x \u2208 Set.univ, \u00acsorry x \u27e8m, hms\u27e9\n\u22a2 \u2203 m \u2208 s, \u2200 x \u2208 s, \u00acx < m"}, {"line": "exact \u27e8m, hms, fun x hx hxm => H \u27e8x, hx\u27e9 trivial hxm\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem invFun_restrict [Nonempty \u03b1] : (Set.range f).restrict (invFun f) = hf.invOfMemRange := by\n  ext \u27e8b, h\u27e9\n  apply hf\n  simp [hf.left_inv_of_invOfMemRange, @invFun_eq _ _ _ f b (Set.mem_range.mp h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Inv.lean", "context": {"open": ["Function", "Nat"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[Fintype \u03b1] [DecidableEq \u03b2]", "{f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ninst\u271d : Nonempty \u03b1\n\u22a2 (Set.range f).restrict (invFun f) = hf.invOfMemRange"}, {"line": "ext \u27e8b, h\u27e9", "tactic_state": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ninst\u271d : Nonempty \u03b1\nb : \u03b2\nh : b \u2208 Set.range f\n\u22a2 (Set.range f).restrict (invFun f) \u27e8b, h\u27e9 = hf.invOfMemRange \u27e8b, h\u27e9"}, {"line": "apply hf", "tactic_state": "case h.mk.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ninst\u271d : Nonempty \u03b1\nb : \u03b2\nh : b \u2208 Set.range f\n\u22a2 f ((Set.range f).restrict (invFun f) \u27e8b, h\u27e9) = f (hf.invOfMemRange \u27e8b, h\u27e9)"}, {"line": "simp [hf.left_inv_of_invOfMemRange, @invFun_eq _ _ _ f b (Set.mem_range.mp h)]", "tactic_state": "case h.mk.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ninst\u271d : Nonempty \u03b1\nb : \u03b2\nh : b \u2208 Set.range f\n\u22a2 f (invFun f b) = f (hf.invOfMemRange \u27e8b, h\u27e9)"}]}
{"declaration": "theorem invFun_restrict [Nonempty \u03b1] : (Set.range f).restrict (invFun f) = f.invOfMemRange := by\n  ext \u27e8b, h\u27e9\n  apply f.injective\n  simp [f.left_inv_of_invOfMemRange, @invFun_eq _ _ _ f b (Set.mem_range.mp h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Inv.lean", "context": {"open": ["Function", "Nat"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[Fintype \u03b1] [DecidableEq \u03b2]", "{f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f)", "(f : \u03b1 \u21aa \u03b2) (b : Set.range f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\nf : \u03b1 \u21aa \u03b2\ninst\u271d : Nonempty \u03b1\n\u22a2 (Set.range \u21d1f).restrict (invFun \u21d1f) = f.invOfMemRange"}, {"line": "ext \u27e8b, h\u27e9", "tactic_state": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\nf : \u03b1 \u21aa \u03b2\ninst\u271d : Nonempty \u03b1\nb : \u03b2\nh : b \u2208 Set.range \u21d1f\n\u22a2 (Set.range \u21d1f).restrict (invFun \u21d1f) \u27e8b, h\u27e9 = f.invOfMemRange \u27e8b, h\u27e9"}, {"line": "apply f.injective", "tactic_state": "case h.mk.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\nf : \u03b1 \u21aa \u03b2\ninst\u271d : Nonempty \u03b1\nb : \u03b2\nh : b \u2208 Set.range \u21d1f\n\u22a2 f ((Set.range \u21d1f).restrict (invFun \u21d1f) \u27e8b, h\u27e9) = f (f.invOfMemRange \u27e8b, h\u27e9)"}, {"line": "simp [f.left_inv_of_invOfMemRange, @invFun_eq _ _ _ f b (Set.mem_range.mp h)]", "tactic_state": "case h.mk.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\nf : \u03b1 \u21aa \u03b2\ninst\u271d : Nonempty \u03b1\nb : \u03b2\nh : b \u2208 Set.range \u21d1f\n\u22a2 f (invFun (\u21d1f) b) = b"}]}
{"declaration": "lemma piFinset_nonempty : (piFinset s).Nonempty \u2194 \u2200 a, (s a).Nonempty := by simp [piFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Pi.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [Fintype \u03b1] {\u03b3 \u03b4 : \u03b1 \u2192 Type*} {s : \u2200 a, Finset (\u03b3 a)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\n\u03b3 : \u03b1 \u2192 Type u_3\ns : (a : \u03b1) \u2192 Finset (\u03b3 a)\nx\u271d : Sort u_5\npiFinset : x\u271d\n\u22a2 sorry \u2194 \u2200 (a : \u03b1), (s a).Nonempty"}, {"line": "simp [piFinset]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\n\u03b3 : \u03b1 \u2192 Type u_3\ns : (a : \u03b1) \u2192 Finset (\u03b3 a)\nx\u271d : Sort u_5\npiFinset : x\u271d\n\u22a2 sorry () \u2194 \u2200 (a : \u03b1), (s a).Nonempty"}]}
{"declaration": "lemma eval_image_piFinset_const {\u03b2} [DecidableEq \u03b2] (t : Finset \u03b2) (a : \u03b1) :\n    ((piFinset fun _i : \u03b1 \u21a6 t).image fun f \u21a6 f a) = t := by\n  obtain rfl | ht := t.eq_empty_or_nonempty\n  \u00b7 haveI : Nonempty \u03b1 := \u27e8a\u27e9\n    simp\n  \u00b7 exact eval_image_piFinset (fun _ \u21a6 t) a fun _ _ \u21a6 ht\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Pi.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [Fintype \u03b1] {\u03b3 \u03b4 : \u03b1 \u2192 Type*} {s : \u2200 a, Finset (\u03b3 a)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\nx\u271d : Sort u_5\npiFinset : x\u271d\n\u03b2 : Type u_6\ninst\u271d : DecidableEq \u03b2\nt : Finset \u03b2\na : \u03b1\n\u22a2 sorry = t"}, {"line": "obtain rfl | ht := t.eq_empty_or_nonempty", "tactic_state": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\nx\u271d : Sort u_5\npiFinset : x\u271d\n\u03b2 : Type u_6\ninst\u271d : DecidableEq \u03b2\na : \u03b1\n\u22a2 sorry = \u2205\n---\ncase inr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\nx\u271d : Sort u_5\npiFinset : x\u271d\n\u03b2 : Type u_6\ninst\u271d : DecidableEq \u03b2\nt : Finset \u03b2\na : \u03b1\nht : t.Nonempty\n\u22a2 sorry = t"}, {"line": "\u00b7 haveI : Nonempty \u03b1 := \u27e8a\u27e9\n    simp", "tactic_state": "case inr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\nx\u271d : Sort u_5\npiFinset : x\u271d\n\u03b2 : Type u_6\ninst\u271d : DecidableEq \u03b2\nt : Finset \u03b2\na : \u03b1\nht : t.Nonempty\n\u22a2 sorry = t"}, {"line": "\u00b7 exact eval_image_piFinset (fun _ \u21a6 t) a fun _ _ \u21a6 ht", "tactic_state": "No Goals!"}]}
{"declaration": "lemma piFinset_filter_const [DecidableEq \u03b9] [Fintype \u03b9] :\n    {f \u2208 Fintype.piFinset fun _ : \u03b9 \u21a6 s | \u2203 a \u2208 s, const \u03b9 a = f} = s.piDiag \u03b9 := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Pi.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [Fintype \u03b1] {\u03b3 \u03b4 : \u03b1 \u2192 Type*} {s : \u2200 a, Finset (\u03b3 a)}", "[\u2200 a, DecidableEq (\u03b4 a)]", "{\u03b9 : Type*} [DecidableEq (\u03b9 \u2192 \u03b1)] {s : Finset \u03b1} {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : Fintype \u03b1\n\u03b9 : Type u_5\ninst\u271d\u00b2 : DecidableEq (\u03b9 \u2192 \u03b1)\ns : Finset \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\n\u22a2 {f \u2208 Fintype.piFinset fun x => s | \u2203 a \u2208 s, const \u03b9 a = f} = s.piDiag \u03b9"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Finite.pi' (ht : \u2200 i, (t i).Finite) : {f : \u2200 i, \u03ba i | \u2200 i, f i \u2208 t i}.Finite := by\n  simpa [Set.pi] using Finite.pi ht\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Pi.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [Fintype \u03b1] {\u03b3 \u03b4 : \u03b1 \u2192 Type*} {s : \u2200 a, Finset (\u03b3 a)}", "[\u2200 a, DecidableEq (\u03b4 a)]", "{\u03b9 : Type*} [DecidableEq (\u03b9 \u2192 \u03b1)] {s : Finset \u03b1} {f : \u03b9 \u2192 \u03b1}", "{\u03b9 : Type*} [Finite \u03b9] {\u03ba : \u03b9 \u2192 Type*} {t : \u2200 i, Set (\u03ba i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_6\ninst\u271d : Finite \u03b9\n\u03ba : \u03b9 \u2192 Type u_7\nt : (i : \u03b9) \u2192 Set (\u03ba i)\nht : \u2200 (i : \u03b9), (t i).Finite\n\u22a2 {f | \u2200 (i : \u03b9), f i \u2208 t i}.Finite"}, {"line": "simpa [Set.pi] using Finite.pi ht", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.exists_ne_map_eq_of_infinite {\u03b1 \u03b2} [Infinite \u03b1] [Finite \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    \u2203 x y : \u03b1, x \u2260 y \u2227 f x = f y := by\n  simpa [Injective, and_comm] using not_injective_infinite_finite f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Pigeonhole.lean", "context": {"open": ["Function", "Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[Fintype \u03b1] [Fintype \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_4\n\u03b2 : Sort u_5\ninst\u271d\u00b9 : Infinite \u03b1\ninst\u271d : Finite \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2203 x y, x \u2260 y \u2227 f x = f y"}, {"line": "simpa [Injective, and_comm] using not_injective_infinite_finite f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_prod (s : Set \u03b1) (t : Set \u03b2) [Fintype s] [Fintype t] [Fintype (s \u00d7\u02e2 t)] :\n    (s \u00d7\u02e2 t).toFinset = s.toFinset \u00d7\u02e2 t.toFinset := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Prod.lean", "context": {"open": ["Function", "Finset Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\ninst\u271d\u00b2 : Fintype \u2191s\ninst\u271d\u00b9 : Fintype \u2191t\ninst\u271d : Fintype \u2191(s \u00d7\u02e2 t)\n\u22a2 (s \u00d7\u02e2 t).toFinset = s.toFinset \u00d7\u02e2 t.toFinset"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\ninst\u271d\u00b2 : Fintype \u2191s\ninst\u271d\u00b9 : Fintype \u2191t\ninst\u271d : Fintype \u2191(s \u00d7\u02e2 t)\na\u271d : \u03b1 \u00d7 \u03b2\n\u22a2 a\u271d \u2208 (s \u00d7\u02e2 t).toFinset \u2194 a\u271d \u2208 s.toFinset \u00d7\u02e2 t.toFinset"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_toFinset {s : Set \u03b1} [Fintype s] {a : \u03b1} : a \u2208 s.toFinset \u2194 a \u2208 s := by\n  simp [toFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sets.lean", "context": {"open": ["Function", "Nat", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\na : \u03b1\n\u22a2 a \u2208 s.toFinset \u2194 a \u2208 s"}, {"line": "simp [toFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_subset_toFinset [Fintype s] [Fintype t] : s.toFinset \u2286 t.toFinset \u2194 s \u2286 t := by\n  simp [Finset.subset_iff, Set.subset_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sets.lean", "context": {"open": ["Function", "Nat", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\ninst\u271d\u00b9 : Fintype \u2191s\ninst\u271d : Fintype \u2191t\n\u22a2 s.toFinset \u2286 t.toFinset \u2194 s \u2286 t"}, {"line": "simp [Finset.subset_iff, Set.subset_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_toFinset [Fintype s] [Fintype t] :\n    Disjoint s.toFinset t.toFinset \u2194 Disjoint s t := by simp only [\u2190 disjoint_coe, coe_toFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sets.lean", "context": {"open": ["Function", "Nat", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\ninst\u271d\u00b9 : Fintype \u2191s\ninst\u271d : Fintype \u2191t\n\u22a2 Disjoint s.toFinset t.toFinset \u2194 Disjoint s t"}, {"line": "simp only [\u2190 disjoint_coe, coe_toFinset]", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\ninst\u271d\u00b9 : Fintype \u2191s\ninst\u271d : Fintype \u2191t\n\u22a2 Disjoint \u2191s.toFinset \u2191t.toFinset \u2194 Disjoint s t"}]}
{"declaration": "theorem toFinset_inter [Fintype (s \u2229 t : Set _)] : (s \u2229 t).toFinset = s.toFinset \u2229 t.toFinset := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sets.lean", "context": {"open": ["Function", "Nat", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[DecidableEq \u03b1] (s t) [Fintype s] [Fintype t]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u2191s\ninst\u271d\u00b9 : Fintype \u2191t\ninst\u271d : Fintype \u2191(s \u2229 t)\n\u22a2 (s \u2229 t).toFinset = s.toFinset \u2229 t.toFinset"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ns t : Set \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u2191s\ninst\u271d\u00b9 : Fintype \u2191t\ninst\u271d : Fintype \u2191(s \u2229 t)\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 (s \u2229 t).toFinset \u2194 a\u271d \u2208 s.toFinset \u2229 t.toFinset"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_union [Fintype (s \u222a t : Set _)] : (s \u222a t).toFinset = s.toFinset \u222a t.toFinset := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sets.lean", "context": {"open": ["Function", "Nat", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[DecidableEq \u03b1] (s t) [Fintype s] [Fintype t]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u2191s\ninst\u271d\u00b9 : Fintype \u2191t\ninst\u271d : Fintype \u2191(s \u222a t)\n\u22a2 (s \u222a t).toFinset = s.toFinset \u222a t.toFinset"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ns t : Set \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u2191s\ninst\u271d\u00b9 : Fintype \u2191t\ninst\u271d : Fintype \u2191(s \u222a t)\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 (s \u222a t).toFinset \u2194 a\u271d \u2208 s.toFinset \u222a t.toFinset"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_diff [Fintype (s \\ t : Set _)] : (s \\ t).toFinset = s.toFinset \\ t.toFinset := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sets.lean", "context": {"open": ["Function", "Nat", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[DecidableEq \u03b1] (s t) [Fintype s] [Fintype t]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u2191s\ninst\u271d\u00b9 : Fintype \u2191t\ninst\u271d : Fintype \u2191(s \\ t)\n\u22a2 (s \\ t).toFinset = s.toFinset \\ t.toFinset"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ns t : Set \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u2191s\ninst\u271d\u00b9 : Fintype \u2191t\ninst\u271d : Fintype \u2191(s \\ t)\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 (s \\ t).toFinset \u2194 a\u271d \u2208 s.toFinset \\ t.toFinset"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_compl [Fintype \u03b1] [Fintype (s\u1d9c : Set _)] : s\u1d9c.toFinset = s.toFinset\u1d9c := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sets.lean", "context": {"open": ["Function", "Nat", "Finset", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[DecidableEq \u03b1] (s t) [Fintype s] [Fintype t]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u2191s\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u2191s\u1d9c\n\u22a2 s\u1d9c.toFinset = s.toFinset\u1d9c"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ns : Set \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u2191s\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u2191s\u1d9c\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 s\u1d9c.toFinset \u2194 a\u271d \u2208 s.toFinset\u1d9c"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_empty [Fintype (\u2205 : Set \u03b1)] : (\u2205 : Set \u03b1).toFinset = \u2205 := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sets.lean", "context": {"open": ["Function", "Nat", "Finset", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[DecidableEq \u03b1] (s t) [Fintype s] [Fintype t]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u2191\u2205\n\u22a2 \u2205.toFinset = \u2205"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u2191\u2205\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 \u2205.toFinset \u2194 a\u271d \u2208 \u2205"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_univ [Fintype \u03b1] [Fintype (Set.univ : Set \u03b1)] :\n    (Set.univ : Set \u03b1).toFinset = Finset.univ := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sets.lean", "context": {"open": ["Function", "Nat", "Finset", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[DecidableEq \u03b1] (s t) [Fintype s] [Fintype t]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u2191Set.univ\n\u22a2 Set.univ.toFinset = univ"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u2191Set.univ\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 Set.univ.toFinset \u2194 a\u271d \u2208 univ"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_setOf [Fintype \u03b1] (p : \u03b1 \u2192 Prop) [DecidablePred p] [Fintype { x | p x }] :\n    Set.toFinset {x | p x} = Finset.univ.filter p := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sets.lean", "context": {"open": ["Function", "Nat", "Finset", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[DecidableEq \u03b1] (s t) [Fintype s] [Fintype t]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : Fintype \u2191{x | p x}\n\u22a2 {x | p x}.toFinset = filter p univ"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : Fintype \u2191{x | p x}\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 {x | p x}.toFinset \u2194 a\u271d \u2208 filter p univ"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_range [DecidableEq \u03b1] [Fintype \u03b2] (f : \u03b2 \u2192 \u03b1) [Fintype (Set.range f)] :\n    (Set.range f).toFinset = Finset.univ.image f := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sets.lean", "context": {"open": ["Function", "Nat", "Finset", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[DecidableEq \u03b1] (s t) [Fintype s] [Fintype t]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : DecidableEq \u03b1\n\u03b2 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b2\nf : \u03b2 \u2192 \u03b1\ninst\u271d : Fintype \u2191(Set.range f)\n\u22a2 (Set.range f).toFinset = image f univ"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b3 : DecidableEq \u03b1\n\u03b2 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b2\nf : \u03b2 \u2192 \u03b1\ninst\u271d : Fintype \u2191(Set.range f)\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 (Set.range f).toFinset \u2194 a\u271d \u2208 image f univ"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_insert [DecidableEq \u03b1] {a : \u03b1} {s : Set \u03b1} [Fintype (insert a s : Set \u03b1)]\n    [Fintype s] : (insert a s).toFinset = insert a s.toFinset := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sets.lean", "context": {"open": ["Function", "Nat", "Finset", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[DecidableEq \u03b1] (s t) [Fintype s] [Fintype t]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\na : \u03b1\ns : Set \u03b1\ninst\u271d\u00b9 : Fintype \u2191(insert a s)\ninst\u271d : Fintype \u2191s\n\u22a2 (insert a s).toFinset = insert a s.toFinset"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\na : \u03b1\ns : Set \u03b1\ninst\u271d\u00b9 : Fintype \u2191(insert a s)\ninst\u271d : Fintype \u2191s\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 (insert a s).toFinset \u2194 a\u271d \u2208 insert a s.toFinset"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Fintype.coe_image_univ [Fintype \u03b1] [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    \u2191(Finset.image f Finset.univ) = Set.range f := by\n  ext x\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sets.lean", "context": {"open": ["Function", "Nat", "Finset", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[DecidableEq \u03b1] (s t) [Fintype s] [Fintype t]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b1\n\u03b2 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2191(image f univ) = Set.range f"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b1\n\u03b2 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b2\n\u22a2 x \u2208 \u2191(image f univ) \u2194 x \u2208 Set.range f"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_image_univ_iff_mem_range {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2}\n    {b : \u03b2} : b \u2208 univ.image f \u2194 b \u2208 Set.range f := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sets.lean", "context": {"open": ["Function", "Nat", "Finset", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}", "[DecidableEq \u03b1] (s t) [Fintype s] [Fintype t]", "[Fintype \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\n\u22a2 b \u2208 image f univ \u2194 b \u2208 Set.range f"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Set.biUnion_finsetSigma_univ (s : Finset \u03b9) (f : Sigma \u03ba \u2192 Set \u03b1) :\n    \u22c3 ij \u2208 s.sigma fun _ \u21a6 Finset.univ, f ij = \u22c3 i \u2208 s, \u22c3 j, f \u27e8i, j\u27e9 := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sigma.lean", "context": {"open": ["Function", "Nat", "Finset Function"], "variables": ["{\u03b9 \u03b1 : Type*} {\u03ba : \u03b9 \u2192 Type*} [\u03a0 i, Fintype (\u03ba i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Fintype (\u03ba i)\ns : Finset \u03b9\nf : Sigma \u03ba \u2192 Set \u03b1\n\u22a2 \u22c3 ij \u2208 s.sigma fun x => Finset.univ, f ij = \u22c3 i \u2208 s, \u22c3 j, f \u27e8i, j\u27e9"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Set.biUnion_finsetSigma_univ' (s : Finset \u03b9) (f : \u03a0 i, \u03ba i \u2192 Set \u03b1) :\n    \u22c3 i \u2208 s, \u22c3 j, f i j = \u22c3 ij \u2208 s.sigma fun _ \u21a6 Finset.univ, f ij.1 ij.2 := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sigma.lean", "context": {"open": ["Function", "Nat", "Finset Function"], "variables": ["{\u03b9 \u03b1 : Type*} {\u03ba : \u03b9 \u2192 Type*} [\u03a0 i, Fintype (\u03ba i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Fintype (\u03ba i)\ns : Finset \u03b9\nf : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 \u22c3 i \u2208 s, \u22c3 j, f i j = \u22c3 ij \u2208 s.sigma fun x => Finset.univ, f ij.fst ij.snd"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Set.biInter_finsetSigma_univ (s : Finset \u03b9) (f : Sigma \u03ba \u2192 Set \u03b1) :\n    \u22c2 ij \u2208 s.sigma fun _ \u21a6 Finset.univ, f ij = \u22c2 i \u2208 s, \u22c2 j, f \u27e8i, j\u27e9 := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sigma.lean", "context": {"open": ["Function", "Nat", "Finset Function"], "variables": ["{\u03b9 \u03b1 : Type*} {\u03ba : \u03b9 \u2192 Type*} [\u03a0 i, Fintype (\u03ba i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Fintype (\u03ba i)\ns : Finset \u03b9\nf : Sigma \u03ba \u2192 Set \u03b1\n\u22a2 \u22c2 ij \u2208 s.sigma fun x => Finset.univ, f ij = \u22c2 i \u2208 s, \u22c2 j, f \u27e8i, j\u27e9"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Set.biInter_finsetSigma_univ' (s : Finset \u03b9) (f : \u03a0 i, \u03ba i \u2192 Set \u03b1) :\n    \u22c2 i \u2208 s, \u22c2 j, f i j = \u22c2 ij \u2208 s.sigma fun _ \u21a6 Finset.univ, f ij.1 ij.2 := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fintype/Sigma.lean", "context": {"open": ["Function", "Nat", "Finset Function"], "variables": ["{\u03b9 \u03b1 : Type*} {\u03ba : \u03b9 \u2192 Type*} [\u03a0 i, Fintype (\u03ba i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Fintype (\u03ba i)\ns : Finset \u03b9\nf : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 \u22c2 i \u2208 s, \u22c2 j, f i j = \u22c2 ij \u2208 s.sigma fun x => Finset.univ, f ij.fst ij.snd"}, {"line": "aesop", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ninst : (i : \u03b9) \u2192 Fintype (\u03ba i)\ns : Finset \u03b9\nf : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 \u22c2 i \u2208 s, \u22c2 j, f i j = \u22c2 ij, \u22c2 (_ : ij.fst \u2208 s), f ij.fst ij.snd"}]}
{"declaration": "lemma inv_apply_eq_iff_eq_apply {e : E} {b : \u03b2} {a : \u03b1} : (EquivLike.inv e b) = a \u2194 b = e a := by\n  constructor <;> rintro \u27e8_, rfl\u27e9 <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/FunLike/Equiv.lean", "context": {"open": [], "variables": ["{A B : Type*} [MyClass A] [MyClass B]", "{A B : Type*} [CoolClass A] [CoolClass B]", "{E F \u03b1 \u03b2 \u03b3 : Sort*} [EquivLike E \u03b1 \u03b2] [EquivLike F \u03b2 \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Sort u_1\n\u03b1 : Sort u_3\n\u03b2 : Sort u_4\ninst\u271d : EquivLike E \u03b1 \u03b2\ne : E\nb : \u03b2\na : \u03b1\n\u22a2 EquivLike.inv e b = a \u2194 b = e a"}, {"line": "constructor <;> rintro \u27e8_, rfl\u27e9 <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dite_apply {P : Prop} [Decidable P] (f : P \u2192 F) (g : \u00acP \u2192 F) (x : \u03b1) :\n    (if h : P then f h else g h) x = if h : P then f h x else g h x := by\n  split_ifs <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/FunLike/Basic.lean", "context": {"open": [], "variables": ["{A B : Type*} [CoolClass A] [CoolClass B]", "(F \u03b1 : Sort*) (\u03b2 : \u03b1 \u2192 Sort*)", "{F \u03b1 \u03b2} [i : DFunLike F \u03b1 \u03b2]", "{F \u03b1 \u03b2 : Sort*} [i : FunLike F \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Sort u_4\n\u03b1 : Sort u_5\n\u03b2 : Sort u_6\ni : FunLike F \u03b1 \u03b2\nP : Prop\ninst\u271d : Decidable P\nf : P \u2192 F\ng : \u00acP \u2192 F\nx : \u03b1\n\u22a2 (if h : P then f h else g h) x = if h : P then (f h) x else (g h) x"}, {"line": "split_ifs <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_div_charZero {k : Type*} [DivisionRing k] [CharZero k] {m n : \u2124} (n_dvd : n \u2223 m) :\n    ((m / n : \u2124) : k) = m / n := by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  \u00b7 simp [Int.ediv_zero]\n  \u00b7 exact cast_div n_dvd (cast_ne_zero.mpr hn)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/CharZero.lean", "context": {"open": ["Nat Set"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_3\ninst\u271d\u00b9 : DivisionRing k\ninst\u271d : CharZero k\nm n : \u2124\nn_dvd : n \u2223 m\n\u22a2 \u2191(m / n) = \u2191m / \u2191n"}, {"line": "rcases eq_or_ne n 0 with (rfl | hn)", "tactic_state": "case inl\nk : Type u_3\ninst\u271d\u00b9 : DivisionRing k\ninst\u271d : CharZero k\nm : \u2124\nn_dvd : 0 \u2223 m\n\u22a2 \u2191(m / 0) = \u2191m / \u21910\n---\ncase inr\nk : Type u_3\ninst\u271d\u00b9 : DivisionRing k\ninst\u271d : CharZero k\nm n : \u2124\nn_dvd : n \u2223 m\nhn : n \u2260 0\n\u22a2 \u2191(m / n) = \u2191m / \u2191n"}, {"line": "\u00b7 simp [Int.ediv_zero]", "tactic_state": "case inr\nk : Type u_3\ninst\u271d\u00b9 : DivisionRing k\ninst\u271d : CharZero k\nm n : \u2124\nn_dvd : n \u2223 m\nhn : n \u2260 0\n\u22a2 \u2191(m / n) = \u2191m / \u2191n"}, {"line": "\u00b7 exact cast_div n_dvd (cast_ne_zero.mpr hn)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem csSup_eq_greatest_of_bdd {s : Set \u2124} [DecidablePred (\u00b7 \u2208 s)] (b : \u2124) (Hb : \u2200 z \u2208 s, z \u2264 b)\n    (Hinh : \u2203 z : \u2124, z \u2208 s) : sSup s = greatestOfBdd b Hb Hinh := by\n  have : s.Nonempty \u2227 BddAbove s := \u27e8Hinh, b, Hb\u27e9\n  simp only [sSup]\n  simp only [dif_pos this]\n  convert (coe_greatestOfBdd_eq Hb (Classical.choose_spec (\u27e8b, Hb\u27e9 : BddAbove s)) Hinh).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/ConditionallyCompleteOrder.lean", "context": {"open": ["Int", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set \u2124\ninst\u271d : DecidablePred fun x => x \u2208 s\nb : \u2124\nHb : \u2200 z \u2208 s, z \u2264 b\nHinh : \u2203 z, z \u2208 s\n\u22a2 sSup s = \u2191(b.greatestOfBdd Hb Hinh)"}, {"line": "have : s.Nonempty \u2227 BddAbove s := \u27e8Hinh, b, Hb\u27e9", "tactic_state": "s : Set \u2124\ninst\u271d : DecidablePred fun x => x \u2208 s\nb : \u2124\nHb : \u2200 z \u2208 s, z \u2264 b\nHinh : \u2203 z, z \u2208 s\nthis : s.Nonempty \u2227 BddAbove s\n\u22a2 sSup s = \u2191(b.greatestOfBdd Hb Hinh)"}, {"line": "simp only [sSup]", "tactic_state": "s : Set \u2124\ninst\u271d : DecidablePred fun x => x \u2208 s\nb : \u2124\nHb : \u2200 z \u2208 s, z \u2264 b\nHinh : \u2203 z, z \u2208 s\nthis : s.Nonempty \u2227 BddAbove s\n\u22a2 (if h : s.Nonempty \u2227 BddAbove s then \u2191((Classical.choose \u22ef).greatestOfBdd \u22ef \u22ef) else 0) = \u2191(b.greatestOfBdd Hb Hinh)"}, {"line": "simp only [dif_pos this]", "tactic_state": "s : Set \u2124\ninst\u271d : DecidablePred fun x => x \u2208 s\nb : \u2124\nHb : \u2200 z \u2208 s, z \u2264 b\nHinh : \u2203 z, z \u2208 s\nthis : s.Nonempty \u2227 BddAbove s\n\u22a2 \u2191((Classical.choose \u22ef).greatestOfBdd \u22ef \u22ef) = \u2191(b.greatestOfBdd Hb Hinh)"}, {"line": "convert (coe_greatestOfBdd_eq Hb (Classical.choose_spec (\u27e8b, Hb\u27e9 : BddAbove s)) Hinh).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem csInf_eq_least_of_bdd {s : Set \u2124} [DecidablePred (\u00b7 \u2208 s)] (b : \u2124) (Hb : \u2200 z \u2208 s, b \u2264 z)\n    (Hinh : \u2203 z : \u2124, z \u2208 s) : sInf s = leastOfBdd b Hb Hinh := by\n  have : s.Nonempty \u2227 BddBelow s := \u27e8Hinh, b, Hb\u27e9\n  simp only [sInf]\n  simp only [dif_pos this]\n  convert (coe_leastOfBdd_eq Hb (Classical.choose_spec (\u27e8b, Hb\u27e9 : BddBelow s)) Hinh).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/ConditionallyCompleteOrder.lean", "context": {"open": ["Int", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set \u2124\ninst\u271d : DecidablePred fun x => x \u2208 s\nb : \u2124\nHb : \u2200 z \u2208 s, b \u2264 z\nHinh : \u2203 z, z \u2208 s\n\u22a2 sInf s = \u2191(b.leastOfBdd Hb Hinh)"}, {"line": "have : s.Nonempty \u2227 BddBelow s := \u27e8Hinh, b, Hb\u27e9", "tactic_state": "s : Set \u2124\ninst\u271d : DecidablePred fun x => x \u2208 s\nb : \u2124\nHb : \u2200 z \u2208 s, b \u2264 z\nHinh : \u2203 z, z \u2208 s\nthis : s.Nonempty \u2227 BddBelow s\n\u22a2 sInf s = \u2191(b.leastOfBdd Hb Hinh)"}, {"line": "simp only [sInf]", "tactic_state": "s : Set \u2124\ninst\u271d : DecidablePred fun x => x \u2208 s\nb : \u2124\nHb : \u2200 z \u2208 s, b \u2264 z\nHinh : \u2203 z, z \u2208 s\nthis : s.Nonempty \u2227 BddBelow s\n\u22a2 (if h : s.Nonempty \u2227 BddBelow s then \u2191((Classical.choose \u22ef).leastOfBdd \u22ef \u22ef) else 0) = \u2191(b.leastOfBdd Hb Hinh)"}, {"line": "simp only [dif_pos this]", "tactic_state": "s : Set \u2124\ninst\u271d : DecidablePred fun x => x \u2208 s\nb : \u2124\nHb : \u2200 z \u2208 s, b \u2264 z\nHinh : \u2203 z, z \u2208 s\nthis : s.Nonempty \u2227 BddBelow s\n\u22a2 \u2191((Classical.choose \u22ef).leastOfBdd \u22ef \u22ef) = \u2191(b.leastOfBdd Hb Hinh)"}, {"line": "convert (coe_leastOfBdd_eq Hb (Classical.choose_spec (\u27e8b, Hb\u27e9 : BddBelow s)) Hinh).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem csSup_mem {s : Set \u2124} (h1 : s.Nonempty) (h2 : BddAbove s) : sSup s \u2208 s := by\n  convert (greatestOfBdd _ (Classical.choose_spec h2) h1).2.1\n  exact dif_pos \u27e8h1, h2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/ConditionallyCompleteOrder.lean", "context": {"open": ["Int", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set \u2124\nh1 : s.Nonempty\nh2 : BddAbove s\n\u22a2 sSup s \u2208 s"}, {"line": "convert (greatestOfBdd _ (Classical.choose_spec h2) h1).2.1", "tactic_state": "case h.e'_5\ns : Set \u2124\nh1 : s.Nonempty\nh2 : BddAbove s\n\u22a2 sSup s = \u2191((Classical.choose h2).greatestOfBdd \u22ef h1)\n---\ns : Set \u2124\nh1 : s.Nonempty\nh2 : BddAbove s\n\u22a2 DecidablePred (Membership.mem s)"}, {"line": "exact dif_pos \u27e8h1, h2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem csInf_mem {s : Set \u2124} (h1 : s.Nonempty) (h2 : BddBelow s) : sInf s \u2208 s := by\n  convert (leastOfBdd _ (Classical.choose_spec h2) h1).2.1\n  exact dif_pos \u27e8h1, h2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/ConditionallyCompleteOrder.lean", "context": {"open": ["Int", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set \u2124\nh1 : s.Nonempty\nh2 : BddBelow s\n\u22a2 sInf s \u2208 s"}, {"line": "convert (leastOfBdd _ (Classical.choose_spec h2) h1).2.1", "tactic_state": "case h.e'_5\ns : Set \u2124\nh1 : s.Nonempty\nh2 : BddBelow s\n\u22a2 sInf s = \u2191((Classical.choose h2).leastOfBdd \u22ef h1)\n---\ns : Set \u2124\nh1 : s.Nonempty\nh2 : BddBelow s\n\u22a2 DecidablePred (Membership.mem s)"}, {"line": "exact dif_pos \u27e8h1, h2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma addSubmonoid_closure_range_mul_self : closure (range fun x : \u2124 \u21a6 x * x) = nonneg _ := by\n  simpa only [sq] using addSubmonoid_closure_range_pow even_two\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Star.lean", "context": {"open": ["AddSubmonoid Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = nonneg ?m.136"}, {"line": "simpa only [sq] using addSubmonoid_closure_range_pow even_two", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AbsoluteValue.map_units_int (abv : AbsoluteValue \u2124 S) (x : \u2124\u02e3) : abv x = 1 := by\n  rcases Int.units_eq_one_or x with (rfl | rfl) <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/AbsoluteValue.lean", "context": {"open": [], "variables": ["{R S : Type*} [Ring R] [CommRing S] [LinearOrder S] [IsStrictOrderedRing S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_2\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : LinearOrder S\ninst\u271d : IsStrictOrderedRing S\nabv : AbsoluteValue \u2124 S\nx : \u2124\u02e3\n\u22a2 abv \u2191x = 1"}, {"line": "rcases Int.units_eq_one_or x with (rfl | rfl) <;> simp", "tactic_state": "case inl\nS : Type u_2\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : LinearOrder S\ninst\u271d : IsStrictOrderedRing S\nabv : AbsoluteValue \u2124 S\n\u22a2 abv 1 = 1\n---\ncase inr\nS : Type u_2\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : LinearOrder S\ninst\u271d : IsStrictOrderedRing S\nabv : AbsoluteValue \u2124 S\n\u22a2 abv (-1) = 1"}]}
{"declaration": "theorem AbsoluteValue.map_units_intCast [Nontrivial R] (abv : AbsoluteValue R S) (x : \u2124\u02e3) :\n    abv ((x : \u2124) : R) = 1 := by rcases Int.units_eq_one_or x with (rfl | rfl) <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/AbsoluteValue.lean", "context": {"open": [], "variables": ["{R S : Type*} [Ring R] [CommRing S] [LinearOrder S] [IsStrictOrderedRing S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : LinearOrder S\ninst\u271d\u00b9 : IsStrictOrderedRing S\ninst\u271d : Nontrivial R\nabv : AbsoluteValue R S\nx : \u2124\u02e3\n\u22a2 abv \u2191\u2191x = 1"}, {"line": "rcases Int.units_eq_one_or x with (rfl | rfl) <;> simp", "tactic_state": "case inl\nR : Type u_1\nS : Type u_2\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : LinearOrder S\ninst\u271d\u00b9 : IsStrictOrderedRing S\ninst\u271d : Nontrivial R\nabv : AbsoluteValue R S\n\u22a2 abv 1 = 1\n---\ncase inr\nR : Type u_1\nS : Type u_2\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : LinearOrder S\ninst\u271d\u00b9 : IsStrictOrderedRing S\ninst\u271d : Nontrivial R\nabv : AbsoluteValue R S\n\u22a2 abv (-1) = 1"}]}
{"declaration": "theorem bodd_neg (n : \u2124) : bodd (-n) = bodd n := by\n  cases n <;> simp only [\u2190 negOfNat_eq, bodd_negOfNat, neg_negSucc] <;> simp [bodd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Bitwise.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbodd : x\u271d\nn : \u2124\n\u22a2 sorry = sorry"}, {"line": "cases n <;> simp only [\u2190 negOfNat_eq, bodd_negOfNat, neg_negSucc] <;> simp [bodd]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem shiftRight_natCast (m n : \u2115) : (m : \u2124) >>> (n : \u2124) = m >>> n := by cases n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Bitwise.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 \u2191m >>> \u2191n = \u2191(m >>> n)"}, {"line": "cases n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Ico_filter_modEq_eq (v : \u2124) :\n    {x \u2208 Ico a b | x \u2261 v [ZMOD r]} =\n    {x \u2208 Ico (a - v) (b - v) | r \u2223 x}.map \u27e8(\u00b7 + v), add_left_injective v\u27e9 := by\n  ext x\n  simp_rw [mem_map, mem_filter, mem_Ico, Function.Embedding.coeFn_mk, \u2190 eq_sub_iff_add_eq,\n    exists_eq_right, modEq_comm, modEq_iff_dvd, sub_lt_sub_iff_right, sub_le_sub_iff_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/CardIntervalMod.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124) {r : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b r v : \u2124\n\u22a2 {x \u2208 Ico a b | x \u2261 v [ZMOD r]} = map { toFun := fun x => x + v, inj' := \u22ef } ({x \u2208 Ico (a - v) (b - v) | r \u2223 x})"}, {"line": "ext x", "tactic_state": "case h\na b r v x : \u2124\n\u22a2 x \u2208 {x \u2208 Ico a b | x \u2261 v [ZMOD r]} \u2194\n    x \u2208 map { toFun := fun x => x + v, inj' := \u22ef } ({x \u2208 Ico (a - v) (b - v) | r \u2223 x})"}, {"line": "simp_rw [mem_map, mem_filter, mem_Ico, Function.Embedding.coeFn_mk, \u2190 eq_sub_iff_add_eq,\n    exists_eq_right, modEq_comm, modEq_iff_dvd, sub_lt_sub_iff_right, sub_le_sub_iff_right]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Ioc_filter_modEq_eq (v : \u2124) :\n    {x \u2208 Ioc a b | x \u2261 v [ZMOD r]} =\n    {x \u2208 Ioc (a - v) (b - v) | r \u2223 x}.map \u27e8(\u00b7 + v), add_left_injective v\u27e9 := by\n  ext x\n  simp_rw [mem_map, mem_filter, mem_Ioc, Function.Embedding.coeFn_mk, \u2190 eq_sub_iff_add_eq,\n    exists_eq_right, modEq_comm, modEq_iff_dvd, sub_lt_sub_iff_right, sub_le_sub_iff_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/CardIntervalMod.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124) {r : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b r v : \u2124\n\u22a2 {x \u2208 Ioc a b | x \u2261 v [ZMOD r]} = map { toFun := fun x => x + v, inj' := \u22ef } ({x \u2208 Ioc (a - v) (b - v) | r \u2223 x})"}, {"line": "ext x", "tactic_state": "case h\na b r v x : \u2124\n\u22a2 x \u2208 {x \u2208 Ioc a b | x \u2261 v [ZMOD r]} \u2194\n    x \u2208 map { toFun := fun x => x + v, inj' := \u22ef } ({x \u2208 Ioc (a - v) (b - v) | r \u2223 x})"}, {"line": "simp_rw [mem_map, mem_filter, mem_Ioc, Function.Embedding.coeFn_mk, \u2190 eq_sub_iff_add_eq,\n    exists_eq_right, modEq_comm, modEq_iff_dvd, sub_lt_sub_iff_right, sub_le_sub_iff_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ico_filter_modEq_card (v : \u2124) :\n    #{x \u2208 Ico a b | x \u2261 v [ZMOD r]} = max (\u2308(b - v) / (r : \u211a)\u2309 - \u2308(a - v) / (r : \u211a)\u2309) 0 := by\n  simp [Ico_filter_modEq_eq, Ico_filter_dvd_eq, toNat_eq_max, hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/CardIntervalMod.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124) {r : \u2124}", "(hr : 0 < r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b r v : \u2124\n\u22a2 \u2191{x \u2208 Ico a b | x \u2261 v [ZMOD r]}.card = max (\u2308(\u2191b - \u2191v) / \u2191r\u2309 - \u2308(\u2191a - \u2191v) / \u2191r\u2309) 0"}, {"line": "simp [Ico_filter_modEq_eq, Ico_filter_dvd_eq, toNat_eq_max, hr]", "tactic_state": "a b r v : \u2124\n\u22a2 \u2191{x \u2208 Ico (a - v) (b - v) | r \u2223 x}.card = max (\u2308(\u2191b - \u2191v) / \u2191r\u2309 - \u2308(\u2191a - \u2191v) / \u2191r\u2309) 0"}]}
{"declaration": "theorem Ioc_filter_modEq_card (v : \u2124) :\n    #{x \u2208 Ioc a b | x \u2261 v [ZMOD r]} = max (\u230a(b - v) / (r : \u211a)\u230b - \u230a(a - v) / (r : \u211a)\u230b) 0 := by\n  simp [Ioc_filter_modEq_eq, Ioc_filter_dvd_eq, toNat_eq_max, hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/CardIntervalMod.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124) {r : \u2124}", "(hr : 0 < r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b r v : \u2124\n\u22a2 \u2191{x \u2208 Ioc a b | x \u2261 v [ZMOD r]}.card = max (\u230a(\u2191b - \u2191v) / \u2191r\u230b - \u230a(\u2191a - \u2191v) / \u2191r\u230b) 0"}, {"line": "simp [Ioc_filter_modEq_eq, Ioc_filter_dvd_eq, toNat_eq_max, hr]", "tactic_state": "a b r v : \u2124\n\u22a2 \u2191{x \u2208 Ioc (a - v) (b - v) | r \u2223 x}.card = max (\u230a(\u2191b - \u2191v) / \u2191r\u230b - \u230a(\u2191a - \u2191v) / \u2191r\u230b) 0"}]}
{"declaration": "theorem xgcd_zero_left {s t r' s' t'} : xgcdAux 0 s t r' s' t' = (r', s', t') := by simp [xgcdAux]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/GCD.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nxgcdAux : x\u271d\ns : ?m.460\nt : ?m.461\nr' : ?m.462\ns' : ?m.463\nt' : ?m.464\n\u22a2 sorry = (r', s', t')"}, {"line": "simp [xgcdAux]", "tactic_state": "x\u271d : Sort u_1\nxgcdAux : x\u271d\ns : ?m.460\nt : ?m.461\nr' : ?m.462\ns' : ?m.463\nt' : ?m.464\n\u22a2 sorry () = (r', s', t')"}]}
{"declaration": "theorem gcd_self (i : \u2124) : gcd i i = natAbs i := by simp [gcd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/GCD.lean", "context": {"open": [], "variables": ["(x y : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nnatAbs : x\u271d\ni : \u2124\n\u22a2 gcd i i = sorry"}, {"line": "simp [gcd]", "tactic_state": "x\u271d : Sort u_1\nnatAbs : x\u271d\ni : \u2124\n\u22a2 |i| = sorry ()"}]}
{"declaration": "theorem gcd_zero_left (i : \u2124) : gcd 0 i = natAbs i := by simp [gcd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/GCD.lean", "context": {"open": [], "variables": ["(x y : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nnatAbs : x\u271d\ni : \u2124\n\u22a2 gcd 0 i = sorry"}, {"line": "simp [gcd]", "tactic_state": "x\u271d : Sort u_1\nnatAbs : x\u271d\ni : \u2124\n\u22a2 |i| = sorry ()"}]}
{"declaration": "theorem gcd_zero_right (i : \u2124) : gcd i 0 = natAbs i := by simp [gcd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/GCD.lean", "context": {"open": [], "variables": ["(x y : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nnatAbs : x\u271d\ni : \u2124\n\u22a2 gcd i 0 = sorry"}, {"line": "simp [gcd]", "tactic_state": "x\u271d : Sort u_1\nnatAbs : x\u271d\ni : \u2124\n\u22a2 |i| = sorry ()"}]}
{"declaration": "theorem dvd_of_dvd_mul_right_of_gcd_one {a b c : \u2124} (habc : a \u2223 b * c) (hab : gcd a b = 1) :\n    a \u2223 c := by\n  rw [mul_comm] at habc\n  exact dvd_of_dvd_mul_left_of_gcd_one habc hab\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/GCD.lean", "context": {"open": [], "variables": ["(x y : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2124\nhabc : a \u2223 b * c\nhab : gcd a b = 1\n\u22a2 a \u2223 c"}, {"line": "rw [mul_comm] at habc", "tactic_state": "a b c : \u2124\nhabc : a \u2223 c * b\nhab : gcd a b = 1\n\u22a2 a \u2223 c"}, {"line": "exact dvd_of_dvd_mul_left_of_gcd_one habc hab", "tactic_state": "No Goals!"}]}
{"declaration": "lemma natCast_ne_zero {n : \u2115} : (n : \u2124) \u2260 0 \u2194 n \u2260 0 := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat"], "variables": ["{a b c d m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2191n \u2260 0 \u2194 n \u2260 0"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma natCast_ne_zero_iff_pos {n : \u2115} : (n : \u2124) \u2260 0 \u2194 0 < n := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat"], "variables": ["{a b c d m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2191n \u2260 0 \u2194 0 < n"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_add_one_iff : m \u2264 n + 1 \u2194 m \u2264 n \u2228 m = n + 1 := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat"], "variables": ["{a b c d m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2124\n\u22a2 m \u2264 n + 1 \u2194 m \u2264 n \u2228 m = n + 1"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub_one_lt_iff : m - 1 < n \u2194 m \u2264 n := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat"], "variables": ["{a b c d m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2124\n\u22a2 m - 1 < n \u2194 m \u2264 n"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_sub_one_iff : m \u2264 n - 1 \u2194 m < n := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat"], "variables": ["{a b c d m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2124\n\u22a2 m \u2264 n - 1 \u2194 m < n"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma natAbs_sq (x : \u2124) : (x.natAbs : \u2124) ^ 2 = x ^ 2 := by\n  simp [Int.pow_succ, Int.pow_zero, Int.natAbs_mul_self']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat", "Lean.Omega.Int"], "variables": ["{a b c d m n : \u2124}", "{C : \u2124 \u2192 Sort*} (z b : \u2124)", "{z b H0 Hs Hp}", "{P : \u2124 \u2192 Sort*} (lt : \u2200 n < m, P n) (ge : \u2200 n \u2265 m, (\u2200 k < n, P k) \u2192 P n)", "{lt ge}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2124\n\u22a2 \u2191x.natAbs ^ 2 = x ^ 2"}, {"line": "simp [Int.pow_succ, Int.pow_zero, Int.natAbs_mul_self']", "tactic_state": "No Goals!"}]}
{"declaration": "lemma div_le_div_iff_of_dvd_of_pos_of_pos (hb : 0 < b) (hd : 0 < d) (hba : b \u2223 a)\n    (hdc : d \u2223 c) : a / b \u2264 c / d \u2194 d * a \u2264 c * b := by\n  obtain \u27e8\u27e8x, rfl\u27e9, y, rfl\u27e9 := hba, hdc\n  simp [*, Int.ne_of_lt, Int.ne_of_gt, d.mul_assoc, b.mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat", "Lean.Omega.Int"], "variables": ["{a b c d m n : \u2124}", "{C : \u2124 \u2192 Sort*} (z b : \u2124)", "{z b H0 Hs Hp}", "{P : \u2124 \u2192 Sort*} (lt : \u2200 n < m, P n) (ge : \u2200 n \u2265 m, (\u2200 k < n, P k) \u2192 P n)", "{lt ge}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a c d b : \u2124\nhb : 0 < b\nhd : 0 < d\nhba : b \u2223 a\nhdc : d \u2223 c\n\u22a2 a / b \u2264 c / d \u2194 d * a \u2264 c * b"}, {"line": "obtain \u27e8\u27e8x, rfl\u27e9, y, rfl\u27e9 := hba, hdc", "tactic_state": "case intro.intro\nd b : \u2124\nhb : 0 < b\nhd : 0 < d\nx y : \u2124\n\u22a2 b * x / b \u2264 d * y / d \u2194 d * (b * x) \u2264 d * y * b"}, {"line": "simp [*, Int.ne_of_lt, Int.ne_of_gt, d.mul_assoc, b.mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma div_le_div_iff_of_dvd_of_pos_of_neg (hb : 0 < b) (hd : d < 0) (hba : b \u2223 a) (hdc : d \u2223 c) :\n    a / b \u2264 c / d \u2194 c * b \u2264 d * a := by\n  obtain \u27e8\u27e8x, rfl\u27e9, y, rfl\u27e9 := hba, hdc\n  simp [*, Int.ne_of_lt, Int.ne_of_gt, d.mul_assoc, b.mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat", "Lean.Omega.Int"], "variables": ["{a b c d m n : \u2124}", "{C : \u2124 \u2192 Sort*} (z b : \u2124)", "{z b H0 Hs Hp}", "{P : \u2124 \u2192 Sort*} (lt : \u2200 n < m, P n) (ge : \u2200 n \u2265 m, (\u2200 k < n, P k) \u2192 P n)", "{lt ge}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a c d b : \u2124\nhb : 0 < b\nhd : d < 0\nhba : b \u2223 a\nhdc : d \u2223 c\n\u22a2 a / b \u2264 c / d \u2194 c * b \u2264 d * a"}, {"line": "obtain \u27e8\u27e8x, rfl\u27e9, y, rfl\u27e9 := hba, hdc", "tactic_state": "case intro.intro\nd b : \u2124\nhb : 0 < b\nhd : d < 0\nx y : \u2124\n\u22a2 b * x / b \u2264 d * y / d \u2194 d * y * b \u2264 d * (b * x)"}, {"line": "simp [*, Int.ne_of_lt, Int.ne_of_gt, d.mul_assoc, b.mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma div_le_div_iff_of_dvd_of_neg_of_pos (hb : b < 0) (hd : 0 < d) (hba : b \u2223 a)  (hdc : d \u2223 c) :\n    a / b \u2264 c / d \u2194 c * b \u2264 d * a := by\n  obtain \u27e8\u27e8x, rfl\u27e9, y, rfl\u27e9 := hba, hdc\n  simp [*, Int.ne_of_lt, Int.ne_of_gt, d.mul_assoc, b.mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat", "Lean.Omega.Int"], "variables": ["{a b c d m n : \u2124}", "{C : \u2124 \u2192 Sort*} (z b : \u2124)", "{z b H0 Hs Hp}", "{P : \u2124 \u2192 Sort*} (lt : \u2200 n < m, P n) (ge : \u2200 n \u2265 m, (\u2200 k < n, P k) \u2192 P n)", "{lt ge}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a c d b : \u2124\nhb : b < 0\nhd : 0 < d\nhba : b \u2223 a\nhdc : d \u2223 c\n\u22a2 a / b \u2264 c / d \u2194 c * b \u2264 d * a"}, {"line": "obtain \u27e8\u27e8x, rfl\u27e9, y, rfl\u27e9 := hba, hdc", "tactic_state": "case intro.intro\nd b : \u2124\nhb : b < 0\nhd : 0 < d\nx y : \u2124\n\u22a2 b * x / b \u2264 d * y / d \u2194 d * y * b \u2264 d * (b * x)"}, {"line": "simp [*, Int.ne_of_lt, Int.ne_of_gt, d.mul_assoc, b.mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma div_le_div_iff_of_dvd_of_neg_of_neg (hb : b < 0) (hd : d < 0) (hba : b \u2223 a) (hdc : d \u2223 c) :\n    a / b \u2264 c / d \u2194 d * a \u2264 c * b := by\n  obtain \u27e8\u27e8x, rfl\u27e9, y, rfl\u27e9 := hba, hdc\n  simp [*, Int.ne_of_lt, Int.ne_of_gt, d.mul_assoc, b.mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat", "Lean.Omega.Int"], "variables": ["{a b c d m n : \u2124}", "{C : \u2124 \u2192 Sort*} (z b : \u2124)", "{z b H0 Hs Hp}", "{P : \u2124 \u2192 Sort*} (lt : \u2200 n < m, P n) (ge : \u2200 n \u2265 m, (\u2200 k < n, P k) \u2192 P n)", "{lt ge}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a c d b : \u2124\nhb : b < 0\nhd : d < 0\nhba : b \u2223 a\nhdc : d \u2223 c\n\u22a2 a / b \u2264 c / d \u2194 d * a \u2264 c * b"}, {"line": "obtain \u27e8\u27e8x, rfl\u27e9, y, rfl\u27e9 := hba, hdc", "tactic_state": "case intro.intro\nd b : \u2124\nhb : b < 0\nhd : d < 0\nx y : \u2124\n\u22a2 b * x / b \u2264 d * y / d \u2194 d * (b * x) \u2264 d * y * b"}, {"line": "simp [*, Int.ne_of_lt, Int.ne_of_gt, d.mul_assoc, b.mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma div_lt_div_iff_of_dvd_of_pos (hb : 0 < b) (hd : 0 < d) (hba : b \u2223 a) (hdc : d \u2223 c) :\n    a / b < c / d \u2194 d * a < c * b := by\n  obtain \u27e8\u27e8x, rfl\u27e9, y, rfl\u27e9 := hba, hdc\n  simp [*, Int.ne_of_lt, Int.ne_of_gt, d.mul_assoc, b.mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat", "Lean.Omega.Int"], "variables": ["{a b c d m n : \u2124}", "{C : \u2124 \u2192 Sort*} (z b : \u2124)", "{z b H0 Hs Hp}", "{P : \u2124 \u2192 Sort*} (lt : \u2200 n < m, P n) (ge : \u2200 n \u2265 m, (\u2200 k < n, P k) \u2192 P n)", "{lt ge}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a c d b : \u2124\nhb : 0 < b\nhd : 0 < d\nhba : b \u2223 a\nhdc : d \u2223 c\n\u22a2 a / b < c / d \u2194 d * a < c * b"}, {"line": "obtain \u27e8\u27e8x, rfl\u27e9, y, rfl\u27e9 := hba, hdc", "tactic_state": "case intro.intro\nd b : \u2124\nhb : 0 < b\nhd : 0 < d\nx y : \u2124\n\u22a2 b * x / b < d * y / d \u2194 d * (b * x) < d * y * b"}, {"line": "simp [*, Int.ne_of_lt, Int.ne_of_gt, d.mul_assoc, b.mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma div_lt_div_iff_of_dvd_of_neg_of_pos (hb : b < 0) (hd : 0 < d) (hba : b \u2223 a) (hdc : d \u2223 c) :\n    a / b < c / d \u2194 c * b < d * a := by\n  obtain \u27e8\u27e8x, rfl\u27e9, y, rfl\u27e9 := hba, hdc\n  simp [*, Int.ne_of_lt, Int.ne_of_gt, d.mul_assoc, b.mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat", "Lean.Omega.Int"], "variables": ["{a b c d m n : \u2124}", "{C : \u2124 \u2192 Sort*} (z b : \u2124)", "{z b H0 Hs Hp}", "{P : \u2124 \u2192 Sort*} (lt : \u2200 n < m, P n) (ge : \u2200 n \u2265 m, (\u2200 k < n, P k) \u2192 P n)", "{lt ge}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a c d b : \u2124\nhb : b < 0\nhd : 0 < d\nhba : b \u2223 a\nhdc : d \u2223 c\n\u22a2 a / b < c / d \u2194 c * b < d * a"}, {"line": "obtain \u27e8\u27e8x, rfl\u27e9, y, rfl\u27e9 := hba, hdc", "tactic_state": "case intro.intro\nd b : \u2124\nhb : b < 0\nhd : 0 < d\nx y : \u2124\n\u22a2 b * x / b < d * y / d \u2194 d * y * b < d * (b * x)"}, {"line": "simp [*, Int.ne_of_lt, Int.ne_of_gt, d.mul_assoc, b.mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma div_lt_div_iff_of_dvd_of_neg_of_neg (hb : b < 0) (hd : d < 0) (hba : b \u2223 a) (hdc : d \u2223 c) :\n    a / b < c / d \u2194 d * a < c * b := by\n  obtain \u27e8\u27e8x, rfl\u27e9, y, rfl\u27e9 := hba, hdc\n  simp [*, Int.ne_of_lt, Int.ne_of_gt, d.mul_assoc, b.mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat", "Lean.Omega.Int"], "variables": ["{a b c d m n : \u2124}", "{C : \u2124 \u2192 Sort*} (z b : \u2124)", "{z b H0 Hs Hp}", "{P : \u2124 \u2192 Sort*} (lt : \u2200 n < m, P n) (ge : \u2200 n \u2265 m, (\u2200 k < n, P k) \u2192 P n)", "{lt ge}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a c d b : \u2124\nhb : b < 0\nhd : d < 0\nhba : b \u2223 a\nhdc : d \u2223 c\n\u22a2 a / b < c / d \u2194 d * a < c * b"}, {"line": "obtain \u27e8\u27e8x, rfl\u27e9, y, rfl\u27e9 := hba, hdc", "tactic_state": "case intro.intro\nd b : \u2124\nhb : b < 0\nhd : d < 0\nx y : \u2124\n\u22a2 b * x / b < d * y / d \u2194 d * (b * x) < d * y * b"}, {"line": "simp [*, Int.ne_of_lt, Int.ne_of_gt, d.mul_assoc, b.mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma emod_two_eq_zero_or_one (n : \u2124) : n % 2 = 0 \u2228 n % 2 = 1 := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat", "Lean.Omega.Int"], "variables": ["{a b c d m n : \u2124}", "{C : \u2124 \u2192 Sort*} (z b : \u2124)", "{z b H0 Hs Hp}", "{P : \u2124 \u2192 Sort*} (lt : \u2200 n < m, P n) (ge : \u2200 n \u2265 m, (\u2200 k < n, P k) \u2192 P n)", "{lt ge}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 n % 2 = 0 \u2228 n % 2 = 1"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dvd_mul_of_div_dvd (h : b \u2223 a) (hdiv : a / b \u2223 c) : a \u2223 b * c := by\n  obtain \u27e8e, rfl\u27e9 := hdiv\n  rw [\u2190 Int.mul_assoc]\n  rw [Int.mul_comm _ (a / b)]\n  rw [Int.ediv_mul_cancel h]\n  exact Int.dvd_mul_right a e\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat", "Lean.Omega.Int"], "variables": ["{a b c d m n : \u2124}", "{C : \u2124 \u2192 Sort*} (z b : \u2124)", "{z b H0 Hs Hp}", "{P : \u2124 \u2192 Sort*} (lt : \u2200 n < m, P n) (ge : \u2200 n \u2265 m, (\u2200 k < n, P k) \u2192 P n)", "{lt ge}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a c b : \u2124\nh : b \u2223 a\nhdiv : a / b \u2223 c\n\u22a2 a \u2223 b * c"}, {"line": "obtain \u27e8e, rfl\u27e9 := hdiv", "tactic_state": "case intro\na b : \u2124\nh : b \u2223 a\ne : \u2124\n\u22a2 a \u2223 b * (a / b * e)"}, {"line": "rw [\u2190 Int.mul_assoc]", "tactic_state": "case intro\na b : \u2124\nh : b \u2223 a\ne : \u2124\n\u22a2 a \u2223 b * (a / b) * e"}, {"line": "rw [Int.mul_comm _ (a / b)]", "tactic_state": "case intro\na b : \u2124\nh : b \u2223 a\ne : \u2124\n\u22a2 a \u2223 a / b * b * e"}, {"line": "rw [Int.ediv_mul_cancel h]", "tactic_state": "case intro\na b : \u2124\nh : b \u2223 a\ne : \u2124\n\u22a2 a \u2223 a * e"}, {"line": "exact Int.dvd_mul_right a e", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dvd_div_of_mul_dvd (h : a * b \u2223 c) : b \u2223 c / a := by\n  obtain rfl | ha := Decidable.em (a = 0)\n  \u00b7 simp\n  \u00b7 obtain \u27e8d, rfl\u27e9 := h\n    simp [Int.mul_assoc, ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat", "Lean.Omega.Int"], "variables": ["{a b c d m n : \u2124}", "{C : \u2124 \u2192 Sort*} (z b : \u2124)", "{z b H0 Hs Hp}", "{P : \u2124 \u2192 Sort*} (lt : \u2200 n < m, P n) (ge : \u2200 n \u2265 m, (\u2200 k < n, P k) \u2192 P n)", "{lt ge}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a c b : \u2124\nh : a * b \u2223 c\n\u22a2 b \u2223 c / a"}, {"line": "obtain rfl | ha := Decidable.em (a = 0)", "tactic_state": "case inl\nc b : \u2124\nh : 0 * b \u2223 c\n\u22a2 b \u2223 c / 0\n---\ncase inr\na c b : \u2124\nh : a * b \u2223 c\nha : \u00aca = 0\n\u22a2 b \u2223 c / a"}, {"line": "\u00b7 simp", "tactic_state": "case inr\na c b : \u2124\nh : a * b \u2223 c\nha : \u00aca = 0\n\u22a2 b \u2223 c / a"}, {"line": "\u00b7 obtain \u27e8d, rfl\u27e9 := h\n    simp [Int.mul_assoc, ha]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dvd_of_mul_dvd_mul_left (ha : a \u2260 0) (h : a * m \u2223 a * n) : m \u2223 n := by\n  obtain \u27e8b, hb\u27e9 := h\n  rw [Int.mul_assoc] at hb\n  rw [Int.mul_eq_mul_left_iff ha] at hb\n  exact \u27e8_, hb\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat", "Lean.Omega.Int"], "variables": ["{a b c d m n : \u2124}", "{C : \u2124 \u2192 Sort*} (z b : \u2124)", "{z b H0 Hs Hp}", "{P : \u2124 \u2192 Sort*} (lt : \u2200 n < m, P n) (ge : \u2200 n \u2265 m, (\u2200 k < n, P k) \u2192 P n)", "{lt ge}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a m n : \u2124\nha : a \u2260 0\nh : a * m \u2223 a * n\n\u22a2 m \u2223 n"}, {"line": "obtain \u27e8b, hb\u27e9 := h", "tactic_state": "case intro\na m n : \u2124\nha : a \u2260 0\nb : \u2124\nhb : a * n = a * m * b\n\u22a2 m \u2223 n"}, {"line": "rw [Int.mul_assoc] at hb", "tactic_state": "case intro\na m n : \u2124\nha : a \u2260 0\nb : \u2124\nhb : a * n = a * (m * b)\n\u22a2 m \u2223 n"}, {"line": "rw [Int.mul_eq_mul_left_iff ha] at hb", "tactic_state": "case intro\na m n : \u2124\nha : a \u2260 0\nb : \u2124\nhb : n = m * b\n\u22a2 m \u2223 n"}, {"line": "exact \u27e8_, hb\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_mul_div_of_mul_eq_mul_of_dvd_left (hb : b \u2260 0) (hbc : b \u2223 c) (h : b * a = c * d) :\n    a = c / b * d := by\n  obtain \u27e8k, rfl\u27e9 := hbc\n  rw [Int.mul_ediv_cancel_left _ hb]\n  rwa [Int.mul_assoc, Int.mul_eq_mul_left_iff hb] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat", "Lean.Omega.Int"], "variables": ["{a b c d m n : \u2124}", "{C : \u2124 \u2192 Sort*} (z b : \u2124)", "{z b H0 Hs Hp}", "{P : \u2124 \u2192 Sort*} (lt : \u2200 n < m, P n) (ge : \u2200 n \u2265 m, (\u2200 k < n, P k) \u2192 P n)", "{lt ge}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a c d b : \u2124\nhb : b \u2260 0\nhbc : b \u2223 c\nh : b * a = c * d\n\u22a2 a = c / b * d"}, {"line": "obtain \u27e8k, rfl\u27e9 := hbc", "tactic_state": "case intro\na d b : \u2124\nhb : b \u2260 0\nk : \u2124\nh : b * a = b * k * d\n\u22a2 a = b * k / b * d"}, {"line": "rw [Int.mul_ediv_cancel_left _ hb]", "tactic_state": "case intro\na d b : \u2124\nhb : b \u2260 0\nk : \u2124\nh : b * a = b * k * d\n\u22a2 a = k * d"}, {"line": "rwa [Int.mul_assoc, Int.mul_eq_mul_left_iff hb] at h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ediv_dvd_of_dvd (hmn : m \u2223 n) : n / m \u2223 n := by\n  obtain rfl | hm := Decidable.em (m = 0)\n  \u00b7 simpa using hmn\n  \u00b7 obtain \u27e8a, ha\u27e9 := hmn\n    simp [ha, Int.mul_ediv_cancel_left _ hm, Int.dvd_mul_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Init.lean", "context": {"open": ["Nat", "Lean.Omega.Int"], "variables": ["{a b c d m n : \u2124}", "{C : \u2124 \u2192 Sort*} (z b : \u2124)", "{z b H0 Hs Hp}", "{P : \u2124 \u2192 Sort*} (lt : \u2200 n < m, P n) (ge : \u2200 n \u2265 m, (\u2200 k < n, P k) \u2192 P n)", "{lt ge}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2124\nhmn : m \u2223 n\n\u22a2 n / m \u2223 n"}, {"line": "obtain rfl | hm := Decidable.em (m = 0)", "tactic_state": "case inl\nn : \u2124\nhmn : 0 \u2223 n\n\u22a2 n / 0 \u2223 n\n---\ncase inr\nm n : \u2124\nhmn : m \u2223 n\nhm : \u00acm = 0\n\u22a2 n / m \u2223 n"}, {"line": "\u00b7 simpa using hmn", "tactic_state": "case inr\nm n : \u2124\nhmn : m \u2223 n\nhm : \u00acm = 0\n\u22a2 n / m \u2223 n"}, {"line": "\u00b7 obtain \u27e8a, ha\u27e9 := hmn\n    simp [ha, Int.mul_ediv_cancel_left _ hm, Int.dvd_mul_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_Icc_of_le (h : a \u2264 b + 1) : (#(Icc a b) : \u2124) = b + 1 - a := by\n  rw [card_Icc]\n  rw [toNat_sub_of_le h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Interval.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\nh : a \u2264 b + 1\n\u22a2 \u2191(Icc a b).card = b + 1 - a"}, {"line": "rw [card_Icc]", "tactic_state": "a b : \u2124\nh : a \u2264 b + 1\n\u22a2 \u2191(b + 1 - a).toNat = b + 1 - a"}, {"line": "rw [toNat_sub_of_le h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_Ico_of_le (h : a \u2264 b) : (#(Ico a b) : \u2124) = b - a := by\n  rw [card_Ico]\n  rw [toNat_sub_of_le h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Interval.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\nh : a \u2264 b\n\u22a2 \u2191(Ico a b).card = b - a"}, {"line": "rw [card_Ico]", "tactic_state": "a b : \u2124\nh : a \u2264 b\n\u22a2 \u2191(b - a).toNat = b - a"}, {"line": "rw [toNat_sub_of_le h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_Ioc_of_le (h : a \u2264 b) : (#(Ioc a b) : \u2124) = b - a := by\n  rw [card_Ioc]\n  rw [toNat_sub_of_le h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Interval.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\nh : a \u2264 b\n\u22a2 \u2191(Ioc a b).card = b - a"}, {"line": "rw [card_Ioc]", "tactic_state": "a b : \u2124\nh : a \u2264 b\n\u22a2 \u2191(b - a).toNat = b - a"}, {"line": "rw [toNat_sub_of_le h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_Ioo_of_lt (h : a < b) : (#(Ioo a b) : \u2124) = b - a - 1 := by\n  rw [card_Ioo]\n  rw [sub_sub]\n  rw [toNat_sub_of_le h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Interval.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\nh : a < b\n\u22a2 \u2191(Ioo a b).card = b - a - 1"}, {"line": "rw [card_Ioo]", "tactic_state": "a b : \u2124\nh : a < b\n\u22a2 \u2191(b - a - 1).toNat = b - a - 1"}, {"line": "rw [sub_sub]", "tactic_state": "a b : \u2124\nh : a < b\n\u22a2 \u2191(b - (a + 1)).toNat = b - (a + 1)"}, {"line": "rw [toNat_sub_of_le h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Icc_eq_pair : Finset.Icc a (a + 1) = {a, a + 1} := by\n  ext\n  simp\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Interval.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2124\n\u22a2 Icc a (a + 1) = {a, a + 1}"}, {"line": "ext", "tactic_state": "case h\na a\u271d : \u2124\n\u22a2 a\u271d \u2208 Icc a (a + 1) \u2194 a\u271d \u2208 {a, a + 1}"}, {"line": "simp", "tactic_state": "case h\na a\u271d : \u2124\n\u22a2 a \u2264 a\u271d \u2227 a\u271d \u2264 a + 1 \u2194 a\u271d = a \u2228 a\u271d = a + 1"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Interval.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 Fintype.card \u2191(Set.Icc a b) = (b + 1 - a).toNat"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintype_Ico : Fintype.card (Set.Ico a b) = (b - a).toNat := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Interval.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 Fintype.card \u2191(Set.Ico a b) = (b - a).toNat"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintype_Ioc : Fintype.card (Set.Ioc a b) = (b - a).toNat := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Interval.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 Fintype.card \u2191(Set.Ioc a b) = (b - a).toNat"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintype_Ioo : Fintype.card (Set.Ioo a b) = (b - a - 1).toNat := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Interval.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 Fintype.card \u2191(Set.Ioo a b) = (b - a - 1).toNat"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintype_uIcc : Fintype.card (Set.uIcc a b) = (b - a).natAbs + 1 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Interval.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 Fintype.card \u2191(Set.uIcc a b) = (b - a).natAbs + 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintype_Icc_of_le (h : a \u2264 b + 1) : (Fintype.card (Set.Icc a b) : \u2124) = b + 1 - a := by\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Interval.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\nh : a \u2264 b + 1\n\u22a2 \u2191(Fintype.card \u2191(Set.Icc a b)) = b + 1 - a"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintype_Ico_of_le (h : a \u2264 b) : (Fintype.card (Set.Ico a b) : \u2124) = b - a := by\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Interval.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\nh : a \u2264 b\n\u22a2 \u2191(Fintype.card \u2191(Set.Ico a b)) = b - a"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintype_Ioc_of_le (h : a \u2264 b) : (Fintype.card (Set.Ioc a b) : \u2124) = b - a := by\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Interval.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\nh : a \u2264 b\n\u22a2 \u2191(Fintype.card \u2191(Set.Ioc a b)) = b - a"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintype_Ioo_of_lt (h : a < b) : (Fintype.card (Set.Ioo a b) : \u2124) = b - a - 1 := by\n  simp [h, h.le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Interval.lean", "context": {"open": ["Finset Int"], "variables": ["(a b : \u2124)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\nh : a < b\n\u22a2 \u2191(Fintype.card \u2191(Set.Ioo a b)) = b - a - 1"}, {"line": "simp [h, h.le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_natCast_sub (m n : \u2115) : (m - n : \u2124) \u2264 \u2191(m - n : \u2115) := by\n  by_cases h : m \u2265 n\n  \u00b7 exact le_of_eq (Int.ofNat_sub h).symm\n  \u00b7 simp [le_of_not_ge h, ofNat_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Lemmas.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 \u2191m - \u2191n \u2264 \u2191(m - n)"}, {"line": "by_cases h : m \u2265 n", "tactic_state": "case pos\nm n : \u2115\nh : m \u2265 n\n\u22a2 \u2191m - \u2191n \u2264 \u2191(m - n)\n---\ncase neg\nm n : \u2115\nh : \u00acm \u2265 n\n\u22a2 \u2191m - \u2191n \u2264 \u2191(m - n)"}, {"line": "\u00b7 exact le_of_eq (Int.ofNat_sub h).symm", "tactic_state": "case neg\nm n : \u2115\nh : \u00acm \u2265 n\n\u22a2 \u2191m - \u2191n \u2264 \u2191(m - n)"}, {"line": "\u00b7 simp [le_of_not_ge h, ofNat_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natAbs_eq_iff_sq_eq {a b : \u2124} : a.natAbs = b.natAbs \u2194 a ^ 2 = b ^ 2 := by\n  rw [sq]\n  rw [sq]\n  exact natAbs_eq_iff_mul_self_eq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Lemmas.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 a.natAbs = b.natAbs \u2194 a ^ 2 = b ^ 2"}, {"line": "rw [sq]", "tactic_state": "a b : \u2124\n\u22a2 a.natAbs = b.natAbs \u2194 a * a = b ^ 2"}, {"line": "rw [sq]", "tactic_state": "a b : \u2124\n\u22a2 a.natAbs = b.natAbs \u2194 a * a = b * b"}, {"line": "exact natAbs_eq_iff_mul_self_eq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natAbs_lt_iff_sq_lt {a b : \u2124} : a.natAbs < b.natAbs \u2194 a ^ 2 < b ^ 2 := by\n  rw [sq]\n  rw [sq]\n  exact natAbs_lt_iff_mul_self_lt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Lemmas.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 a.natAbs < b.natAbs \u2194 a ^ 2 < b ^ 2"}, {"line": "rw [sq]", "tactic_state": "a b : \u2124\n\u22a2 a.natAbs < b.natAbs \u2194 a * a < b ^ 2"}, {"line": "rw [sq]", "tactic_state": "a b : \u2124\n\u22a2 a.natAbs < b.natAbs \u2194 a * a < b * b"}, {"line": "exact natAbs_lt_iff_mul_self_lt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natAbs_le_iff_sq_le {a b : \u2124} : a.natAbs \u2264 b.natAbs \u2194 a ^ 2 \u2264 b ^ 2 := by\n  rw [sq]\n  rw [sq]\n  exact natAbs_le_iff_mul_self_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Lemmas.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 a.natAbs \u2264 b.natAbs \u2194 a ^ 2 \u2264 b ^ 2"}, {"line": "rw [sq]", "tactic_state": "a b : \u2124\n\u22a2 a.natAbs \u2264 b.natAbs \u2194 a * a \u2264 b ^ 2"}, {"line": "rw [sq]", "tactic_state": "a b : \u2124\n\u22a2 a.natAbs \u2264 b.natAbs \u2194 a * a \u2264 b * b"}, {"line": "exact natAbs_le_iff_mul_self_le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natAbs_inj_of_nonpos_of_nonpos {a b : \u2124} (ha : a \u2264 0) (hb : b \u2264 0) :\n    natAbs a = natAbs b \u2194 a = b := by\n  simpa only [Int.natAbs_neg,neg_inj] using\n    natAbs_inj_of_nonneg_of_nonneg (neg_nonneg_of_nonpos ha) (neg_nonneg_of_nonpos hb)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Lemmas.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nnatAbs : x\u271d\na b : \u2124\nha : a \u2264 0\nhb : b \u2264 0\n\u22a2 sorry = sorry \u2194 a = b"}, {"line": "simpa only [Int.natAbs_neg,neg_inj] using\n    natAbs_inj_of_nonneg_of_nonneg (neg_nonneg_of_nonpos ha) (neg_nonneg_of_nonpos hb)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natAbs_inj_of_nonneg_of_nonpos {a b : \u2124} (ha : 0 \u2264 a) (hb : b \u2264 0) :\n    natAbs a = natAbs b \u2194 a = -b := by\n  simpa only [Int.natAbs_neg] using natAbs_inj_of_nonneg_of_nonneg ha (neg_nonneg_of_nonpos hb)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Lemmas.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nnatAbs : x\u271d\na b : \u2124\nha : 0 \u2264 a\nhb : b \u2264 0\n\u22a2 sorry = sorry \u2194 a = -b"}, {"line": "simpa only [Int.natAbs_neg] using natAbs_inj_of_nonneg_of_nonneg ha (neg_nonneg_of_nonpos hb)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natAbs_inj_of_nonpos_of_nonneg {a b : \u2124} (ha : a \u2264 0) (hb : 0 \u2264 b) :\n    natAbs a = natAbs b \u2194 -a = b := by\n  simpa only [Int.natAbs_neg] using natAbs_inj_of_nonneg_of_nonneg (neg_nonneg_of_nonpos ha) hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Lemmas.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nnatAbs : x\u271d\na b : \u2124\nha : a \u2264 0\nhb : 0 \u2264 b\n\u22a2 sorry = sorry \u2194 -a = b"}, {"line": "simpa only [Int.natAbs_neg] using natAbs_inj_of_nonneg_of_nonneg (neg_nonneg_of_nonpos ha) hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ediv_emod_unique'' {a b r q : Int} (h : b \u2260 0) :\n    a / b = q \u2227 a % b = r \u2194 r + b * q = a \u2227 0 \u2264 r \u2227 r < |b| := by\n  constructor\n  \u00b7 intro \u27e8rfl, rfl\u27e9\n    exact \u27e8emod_add_ediv a b, emod_nonneg _ h, emod_lt_abs _ h\u27e9\n  \u00b7 intro \u27e8rfl, hz, hb\u27e9\n    constructor\n    \u00b7 rw [Int.add_mul_ediv_left r q h, ediv_eq_zero_of_lt_abs hz hb]\n      simp [Int.zero_add]\n    \u00b7 rw [add_mul_emod_self_left, \u2190 emod_abs, emod_eq_of_lt hz hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Lemmas.lean", "context": {"open": ["Nat", "Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b r q : \u2124\nh : b \u2260 0\n\u22a2 a / b = q \u2227 a % b = r \u2194 r + b * q = a \u2227 0 \u2264 r \u2227 r < |b|"}, {"line": "constructor", "tactic_state": "case mp\na b r q : \u2124\nh : b \u2260 0\n\u22a2 a / b = q \u2227 a % b = r \u2192 r + b * q = a \u2227 0 \u2264 r \u2227 r < |b|\n---\ncase mpr\na b r q : \u2124\nh : b \u2260 0\n\u22a2 r + b * q = a \u2227 0 \u2264 r \u2227 r < |b| \u2192 a / b = q \u2227 a % b = r"}, {"line": "\u00b7 intro \u27e8rfl, rfl\u27e9\n    exact \u27e8emod_add_ediv a b, emod_nonneg _ h, emod_lt_abs _ h\u27e9", "tactic_state": "case mpr\na b r q : \u2124\nh : b \u2260 0\n\u22a2 r + b * q = a \u2227 0 \u2264 r \u2227 r < |b| \u2192 a / b = q \u2227 a % b = r"}, {"line": "\u00b7 intro \u27e8rfl, hz, hb\u27e9\n    constructor\n    \u00b7 rw [Int.add_mul_ediv_left r q h, ediv_eq_zero_of_lt_abs hz hb]\n      simp [Int.zero_add]\n    \u00b7 rw [add_mul_emod_self_left, \u2190 emod_abs, emod_eq_of_lt hz hb]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem log_of_left_le_one {b : \u2115} (hb : b \u2264 1) (r : R) : log b r = 0 := by\n  rcases le_total 1 r with h | h\n  \u00b7 rw [log_of_one_le_right _ h, Nat.log_of_left_le_one hb, Int.ofNat_zero]\n  \u00b7 rw [log_of_right_le_one _ h, Nat.clog_of_left_le_one hb, Int.ofNat_zero, neg_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Log.lean", "context": {"open": [], "variables": ["{R : Type*} [Semifield R] [LinearOrder R] [IsStrictOrderedRing R] [FloorSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : Semifield R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\ninst\u271d : FloorSemiring R\nx\u271d : Sort u_2\nlog : x\u271d\nb : \u2115\nhb : b \u2264 1\nr : R\n\u22a2 sorry = 0"}, {"line": "rcases le_total 1 r with h | h", "tactic_state": "case zero\nR : Type u_1\ninst\u271d\u00b3 : Semifield R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\ninst\u271d : FloorSemiring R\nx\u271d : Sort u_2\nlog : x\u271d\nb : \u2115\nhb : b \u2264 1\nr : R\n\u22a2 0 = 0\n---\ncase succ\nR : Type u_1\ninst\u271d\u00b3 : Semifield R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\ninst\u271d : FloorSemiring R\nx\u271d : Sort u_2\nlog : x\u271d\nb : \u2115\nhb : b \u2264 1\nr : R\nh : \u2115\n\u22a2 h + 1 = 0"}, {"line": "\u00b7 rw [log_of_one_le_right _ h, Nat.log_of_left_le_one hb, Int.ofNat_zero]", "tactic_state": "case succ\nR : Type u_1\ninst\u271d\u00b3 : Semifield R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\ninst\u271d : FloorSemiring R\nx\u271d : Sort u_2\nlog : x\u271d\nb : \u2115\nhb : b \u2264 1\nr : R\nh : \u2115\n\u22a2 h + 1 = 0"}, {"line": "\u00b7 rw [log_of_right_le_one _ h, Nat.clog_of_left_le_one hb, Int.ofNat_zero, neg_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem log_one_left (r : R) : log 1 r = 0 := by\n  by_cases hr : 1 \u2264 r\n  \u00b7 simp_all only [log, \u2193reduceIte, Nat.log_one_left, Nat.cast_zero]\n  \u00b7 simp only [log, Nat.log_one_left, Nat.cast_zero, Nat.clog_one_left, neg_zero, ite_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Log.lean", "context": {"open": [], "variables": ["{R : Type*} [Semifield R] [LinearOrder R] [IsStrictOrderedRing R] [FloorSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : Semifield R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\ninst\u271d : FloorSemiring R\nx\u271d : Sort u_2\nlog : x\u271d\nr : R\n\u22a2 sorry = 0"}, {"line": "by_cases hr : 1 \u2264 r", "tactic_state": "case pos\nR : Type u_1\ninst\u271d\u00b3 : Semifield R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\ninst\u271d : FloorSemiring R\nx\u271d : Sort u_2\nlog : x\u271d\nr : R\nhr : sorry\n\u22a2 sorry = 0\n---\ncase neg\nR : Type u_1\ninst\u271d\u00b3 : Semifield R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\ninst\u271d : FloorSemiring R\nx\u271d : Sort u_2\nlog : x\u271d\nr : R\nhr : \u00acsorry\n\u22a2 sorry = 0"}, {"line": "\u00b7 simp_all only [log, \u2193reduceIte, Nat.log_one_left, Nat.cast_zero]", "tactic_state": "case neg\nR : Type u_1\ninst\u271d\u00b3 : Semifield R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\ninst\u271d : FloorSemiring R\nx\u271d : Sort u_2\nlog : x\u271d\nr : R\nhr : \u00acsorry\n\u22a2 sorry = 0"}, {"line": "\u00b7 simp only [log, Nat.log_one_left, Nat.cast_zero, Nat.clog_one_left, neg_zero, ite_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem log_zpow {b : \u2115} (hb : 1 < b) (z : \u2124) : log b (b ^ z : R) = z := by\n  obtain \u27e8n, rfl | rfl\u27e9 := Int.eq_nat_or_neg z\n  \u00b7 rw [log_of_one_le_right _ (one_le_zpow\u2080 (mod_cast hb.le) <| Int.natCast_nonneg _), zpow_natCast,\n      \u2190 Nat.cast_pow, Nat.floor_natCast, Nat.log_pow hb]\n  \u00b7 rw [log_of_right_le_one _ (zpow_le_one_of_nonpos\u2080 (mod_cast hb.le) <|\n      neg_nonpos.2 (Int.natCast_nonneg _)),\n      zpow_neg, inv_inv, zpow_natCast, \u2190 Nat.cast_pow, Nat.ceil_natCast, Nat.clog_pow _ _ hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Log.lean", "context": {"open": [], "variables": ["{R : Type*} [Semifield R] [LinearOrder R] [IsStrictOrderedRing R] [FloorSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nlog : x\u271d\nb : \u2115\nhb : 1 < b\nz : \u2124\n\u22a2 sorry = z"}, {"line": "obtain \u27e8n, rfl | rfl\u27e9 := Int.eq_nat_or_neg z", "tactic_state": "case intro.inl\nx\u271d : Sort u_2\nlog : x\u271d\nb : \u2115\nhb : 1 < b\nn : \u2115\n\u22a2 sorry = \u2191n\n---\ncase intro.inr\nx\u271d : Sort u_2\nlog : x\u271d\nb : \u2115\nhb : 1 < b\nn : \u2115\n\u22a2 sorry = -\u2191n"}, {"line": "\u00b7 rw [log_of_one_le_right _ (one_le_zpow\u2080 (mod_cast hb.le) <| Int.natCast_nonneg _), zpow_natCast,\n      \u2190 Nat.cast_pow, Nat.floor_natCast, Nat.log_pow hb]", "tactic_state": "case intro.inr\nx\u271d : Sort u_2\nlog : x\u271d\nb : \u2115\nhb : 1 < b\nn : \u2115\n\u22a2 sorry = -\u2191n"}, {"line": "\u00b7 rw [log_of_right_le_one _ (zpow_le_one_of_nonpos\u2080 (mod_cast hb.le) <|\n      neg_nonpos.2 (Int.natCast_nonneg _)),\n      zpow_neg, inv_inv, zpow_natCast, \u2190 Nat.cast_pow, Nat.ceil_natCast, Nat.clog_pow _ _ hb]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem clog_inv (b : \u2115) (r : R) : clog b r\u207b\u00b9 = -log b r := by\n  rcases lt_or_le 0 r with hrp | hrp\n  \u00b7 obtain hr | hr := le_total 1 r\n    \u00b7 rw [clog_of_right_le_one _ (inv_le_one_of_one_le\u2080 hr), log_of_one_le_right _ hr, inv_inv]\n    \u00b7 rw [clog_of_one_le_right _ ((one_le_inv\u2080 hrp).2 hr), log_of_right_le_one _ hr, neg_neg]\n  \u00b7 rw [clog_of_right_le_zero _ (inv_nonpos.mpr hrp), log_of_right_le_zero _ hrp, neg_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Log.lean", "context": {"open": [], "variables": ["{R : Type*} [Semifield R] [LinearOrder R] [IsStrictOrderedRing R] [FloorSemiring R]", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : Semifield R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\ninst\u271d : FloorSemiring R\nx\u271d\u00b9 : Sort u_2\nclog : x\u271d\u00b9\nx\u271d : Sort u_3\nlog : x\u271d\nb : \u2115\nr : R\n\u22a2 sorry = -sorry"}, {"line": "rcases lt_or_le 0 r with hrp | hrp", "tactic_state": "case ofNat\nR : Type u_1\ninst\u271d\u00b3 : Semifield R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\ninst\u271d : FloorSemiring R\nx\u271d\u00b9 : Sort u_2\nclog : x\u271d\u00b9\nx\u271d : Sort u_3\nlog : x\u271d\nb : \u2115\nr : R\nhrp : \u2115\n\u22a2 Int.ofNat hrp = -Int.ofNat hrp\n---\ncase negSucc\nR : Type u_1\ninst\u271d\u00b3 : Semifield R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\ninst\u271d : FloorSemiring R\nx\u271d\u00b9 : Sort u_2\nclog : x\u271d\u00b9\nx\u271d : Sort u_3\nlog : x\u271d\nb : \u2115\nr : R\nhrp : \u2115\n\u22a2 Int.negSucc hrp = -Int.negSucc hrp"}, {"line": "\u00b7 obtain hr | hr := le_total 1 r\n    \u00b7 rw [clog_of_right_le_one _ (inv_le_one_of_one_le\u2080 hr), log_of_one_le_right _ hr, inv_inv]\n    \u00b7 rw [clog_of_one_le_right _ ((one_le_inv\u2080 hrp).2 hr), log_of_right_le_one _ hr, neg_neg]", "tactic_state": "case negSucc\nR : Type u_1\ninst\u271d\u00b3 : Semifield R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\ninst\u271d : FloorSemiring R\nx\u271d\u00b9 : Sort u_2\nclog : x\u271d\u00b9\nx\u271d : Sort u_3\nlog : x\u271d\nb : \u2115\nr : R\nhrp : \u2115\n\u22a2 Int.negSucc hrp = -Int.negSucc hrp"}, {"line": "\u00b7 rw [clog_of_right_le_zero _ (inv_nonpos.mpr hrp), log_of_right_le_zero _ hrp, neg_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem clog_natCast (b : \u2115) (n : \u2115) : clog b (n : R) = Nat.clog b n := by\n  rcases n with - | n\n  \u00b7 simp [clog_of_right_le_one]\n  \u00b7 rw [clog_of_one_le_right, (Nat.ceil_eq_iff (Nat.succ_ne_zero n)).mpr] <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Log.lean", "context": {"open": [], "variables": ["{R : Type*} [Semifield R] [LinearOrder R] [IsStrictOrderedRing R] [FloorSemiring R]", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nclog : x\u271d\nb n : \u2115\n\u22a2 sorry = Nat.clog b n"}, {"line": "rcases n with - | n", "tactic_state": "case zero\nx\u271d : Sort u_2\nclog : x\u271d\nb : \u2115\n\u22a2 sorry = Nat.clog b 0\n---\ncase succ\nx\u271d : Sort u_2\nclog : x\u271d\nb n : \u2115\n\u22a2 sorry = Nat.clog b (n + 1)"}, {"line": "\u00b7 simp [clog_of_right_le_one]", "tactic_state": "case succ\nx\u271d : Sort u_2\nclog : x\u271d\nb n : \u2115\n\u22a2 sorry = Nat.clog b (n + 1)"}, {"line": "\u00b7 rw [clog_of_one_le_right, (Nat.ceil_eq_iff (Nat.succ_ne_zero n)).mpr] <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem modEq_neg : a \u2261 b [ZMOD -n] \u2194 a \u2261 b [ZMOD n] := by simp [modEq_iff_dvd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/ModEq.lean", "context": {"open": [], "variables": ["{m n a b c d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n a b : \u2124\n\u22a2 a \u2261 b [ZMOD -n] \u2194 a \u2261 b [ZMOD n]"}, {"line": "simp [modEq_iff_dvd]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_div (h : a / c \u2261 b / c [ZMOD m / c]) (ha : c \u2223 a) (ha : c \u2223 b) (ha : c \u2223 m) :\n    a \u2261 b [ZMOD m] := by convert h.mul_left' <;> rwa [Int.mul_ediv_cancel']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/ModEq.lean", "context": {"open": [], "variables": ["{m n a b c d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m a b c : \u2124\nh : a / c \u2261 b / c [ZMOD m / c]\nha\u271d\u00b9 : c \u2223 a\nha\u271d : c \u2223 b\nha : c \u2223 m\n\u22a2 a \u2261 b [ZMOD m]"}, {"line": "convert h.mul_left' <;> rwa [Int.mul_ediv_cancel']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gcd_a_modEq (a b : \u2115) : (a : \u2124) * Nat.gcdA a b \u2261 Nat.gcd a b [ZMOD b] := by\n  rw [\u2190 add_zero ((a : \u2124) * _)]\n  rw [Nat.gcd_eq_gcd_ab]\n  exact (dvd_mul_right _ _).zero_modEq_int.add_left _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/ModEq.lean", "context": {"open": [], "variables": ["{m n a b c d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 \u2191a * a.gcdA b \u2261 \u2191(a.gcd b) [ZMOD \u2191b]"}, {"line": "rw [\u2190 add_zero ((a : \u2124) * _)]", "tactic_state": "a b : \u2115\n\u22a2 \u2191a * a.gcdA b + 0 \u2261 \u2191(a.gcd b) [ZMOD \u2191b]"}, {"line": "rw [Nat.gcd_eq_gcd_ab]", "tactic_state": "a b : \u2115\n\u22a2 \u2191a * a.gcdA b + 0 \u2261 \u2191a * a.gcdA b + \u2191b * a.gcdB b [ZMOD \u2191b]"}, {"line": "exact (dvd_mul_right _ _).zero_modEq_int.add_left _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem modEq_add_fac {a b n : \u2124} (c : \u2124) (ha : a \u2261 b [ZMOD n]) : a + n * c \u2261 b [ZMOD n] :=\n  calc\n    a + n * c \u2261 b + n * c [ZMOD n] := ha.add_right _\n    _ \u2261 b + 0 [ZMOD n] := (dvd_mul_right _ _).modEq_zero_int.add_left _\n    _ \u2261 b [ZMOD n] := by rw [add_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/ModEq.lean", "context": {"open": [], "variables": ["{m n a b c d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b n c : \u2124\nha : a \u2261 b [ZMOD n]\n\u22a2 b + 0 \u2261 b [ZMOD n]"}, {"line": "rw [add_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_covBy {a b : \u2115} : (a : \u2124) \u22d6 b \u2194 a \u22d6 b := by\n  rw [Order.covBy_iff_add_one_eq]\n  rw [Order.covBy_iff_add_one_eq]\n  exact Int.natCast_inj\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/SuccPred.lean", "context": {"open": ["Function Order"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 \u2191a \u22d6 \u2191b \u2194 a \u22d6 b"}, {"line": "rw [Order.covBy_iff_add_one_eq]", "tactic_state": "a b : \u2115\n\u22a2 \u2191a + 1 = \u2191b \u2194 a \u22d6 b"}, {"line": "rw [Order.covBy_iff_add_one_eq]", "tactic_state": "a b : \u2115\n\u22a2 \u2191a + 1 = \u2191b \u2194 a + 1 = b"}, {"line": "exact Int.natCast_inj", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_ofNat (n : \u2115) [n.AtLeastTwo] :\n    ((ofNat(n) : \u2124) : R) = ofNat(n) := by\n  simpa only [OfNat.ofNat] using AddGroupWithOne.intCast_ofNat (R := R) n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Cast/Basic.lean", "context": {"open": ["Nat"], "variables": ["{R : Type u} [AddGroupWithOne R]", "{R : Type u} [AddGroupWithOne R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : AddGroupWithOne R\nn : \u2115\ninst\u271d : n.AtLeastTwo\n\u22a2 \u2191(OfNat.ofNat n) = OfNat.ofNat n"}, {"line": "simpa only [OfNat.ofNat] using AddGroupWithOne.intCast_ofNat (R := R) n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_negOfNat (n : \u2115) : ((negOfNat n : \u2124) : R) = -n := by simp [Int.cast_neg, negOfNat_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Cast/Basic.lean", "context": {"open": ["Nat"], "variables": ["{R : Type u} [AddGroupWithOne R]", "{R : Type u} [AddGroupWithOne R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : AddGroupWithOne R\nx\u271d : Sort u_1\nnegOfNat : x\u271d\nn : \u2115\n\u22a2 \u2191sorry = -\u2191n"}, {"line": "simp [Int.cast_neg, negOfNat_eq]", "tactic_state": "R : Type u\ninst\u271d : AddGroupWithOne R\nx\u271d : Sort u_1\nnegOfNat : x\u271d\nn : \u2115\n\u22a2 \u2191(sorry ()) = -\u2191n"}]}
{"declaration": "theorem cast_sub (m n) : ((m - n : \u2124) : R) = m - n := by\n  simp [Int.sub_eq_add_neg, sub_eq_add_neg, Int.cast_neg, Int.cast_add]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Cast/Basic.lean", "context": {"open": ["Nat"], "variables": ["{R : Type u} [AddGroupWithOne R]", "{R : Type u} [AddGroupWithOne R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : AddGroupWithOne R\nm n : \u2124\n\u22a2 \u2191(m - n) = \u2191m - \u2191n"}, {"line": "simp [Int.sub_eq_add_neg, sub_eq_add_neg, Int.cast_neg, Int.cast_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_neg_natCast {R} [DivisionRing R] (n : \u2115) : ((-n : \u2124) : R) = -n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Cast/Field.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d : DivisionRing R\nn : \u2115\n\u22a2 \u2191(-\u2191n) = -\u2191n"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma AddMonoidHom.apply_int (f : \u2124 \u2192+ \u03b2) (n : \u2124) : f n = n \u2022 f 1 := by\n  rw [\u2190 zmultiplesHom_symm_apply]\n  rw [\u2190 zmultiplesHom_apply]\n  rw [Equiv.apply_symm_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Cast/Lemmas.lean", "context": {"open": ["Additive Function Multiplicative Nat", "Int", "Multiplicative"], "variables": ["{F \u03b9 \u03b1 \u03b2 : Type*}", "[AddGroupWithOne \u03b1]", "[CharZero \u03b1] {m n : \u2124}", "[NonAssocRing \u03b1]", "(\u03b1) in", "[Ring \u03b1] {n : \u2124}", "[Ring \u03b1] {a x y : \u03b1}", "[NonAssocRing \u03b1] {a : \u03b1} {n : \u2124}", "[Ring \u03b1] {a b : \u03b1}", "(a) (m n : \u2124)", "{A : Type*}", "[AddGroupWithOne A]", "{M : Type*} [Monoid M]", "{M : Type*} [MonoidWithZero M]", "(\u03b1) [Group \u03b1] (\u03b2) [AddGroup \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_4\ninst\u271d : AddGroup \u03b2\nf : \u2124 \u2192+ \u03b2\nn : \u2124\n\u22a2 f n = n \u2022 f 1"}, {"line": "rw [\u2190 zmultiplesHom_symm_apply]", "tactic_state": "\u03b2 : Type u_4\ninst\u271d : AddGroup \u03b2\nf : \u2124 \u2192+ \u03b2\nn : \u2124\n\u22a2 f n = n \u2022 (zmultiplesHom \u03b2).symm f"}, {"line": "rw [\u2190 zmultiplesHom_apply]", "tactic_state": "\u03b2 : Type u_4\ninst\u271d : AddGroup \u03b2\nf : \u2124 \u2192+ \u03b2\nn : \u2124\n\u22a2 f n = ((zmultiplesHom \u03b2) ((zmultiplesHom \u03b2).symm f)) n"}, {"line": "rw [Equiv.apply_symm_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_one_pow_ne_zero {n : \u2115} : (-1 : \u2124) ^ n \u2260 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Int/Order/Units.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 (-1) ^ n \u2260 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem countP_lt_length_iff {l : List \u03b1} {p : \u03b1 \u2192 Bool} :\n    l.countP p < l.length \u2194 \u2203 a \u2208 l, p a = false := by\n  simp [Nat.lt_iff_le_and_ne, countP_le_length]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Count.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : List \u03b1\np : \u03b1 \u2192 Bool\n\u22a2 List.countP p l < l.length \u2194 \u2203 a \u2208 l, p a = false"}, {"line": "simp [Nat.lt_iff_le_and_ne, countP_le_length]", "tactic_state": "\u03b1 : Type u_1\nl : List \u03b1\np : \u03b1 \u2192 Bool\n\u22a2 \u2200 x \u2208 l, p x = false \u2192 List.countP p l \u2264 l.length"}]}
{"declaration": "theorem count_lt_length_iff {a : \u03b1} : l.count a < l.length \u2194 \u2203 b \u2208 l, b \u2260 a := by simp [count]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Count.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] {l l\u2081 l\u2082 : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\na : \u03b1\n\u22a2 List.count a l < l.length \u2194 \u2203 b \u2208 l, b \u2260 a"}, {"line": "simp [count]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] := by\n  split_ifs with h <;> simp! [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Destutter.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*} (l l\u2081 l\u2082 : List \u03b1) (R : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel R] {a b : \u03b1}", "{R\u2082 : \u03b2 \u2192 \u03b2 \u2192 Prop} [DecidableRel R\u2082]", "{R}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : DecidableRel R\na b : \u03b1\n\u22a2 List.destutter' R a [b] = if R a b then [a, b] else [a]"}, {"line": "split_ifs with h <;> simp! [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rdrop_nil : rdrop ([] : List \u03b1) n = [] := by simp [rdrop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/DropRight.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (p : \u03b1 \u2192 Bool) (l : List \u03b1) (n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nrdrop : x\u271d\n\u22a2 sorry = []"}, {"line": "simp [rdrop]", "tactic_state": "x\u271d : Sort u_2\nrdrop : x\u271d\n\u22a2 sorry () = []"}]}
{"declaration": "theorem rdrop_zero : rdrop l 0 = l := by simp [rdrop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/DropRight.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (p : \u03b1 \u2192 Bool) (l : List \u03b1) (n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : List \u03b1\nx\u271d : Sort u_2\nrdrop : x\u271d\n\u22a2 sorry = l"}, {"line": "simp [rdrop]", "tactic_state": "\u03b1 : Type u_1\nl : List \u03b1\nx\u271d : Sort u_2\nrdrop : x\u271d\n\u22a2 sorry () = l"}]}
{"declaration": "theorem rtake_nil : rtake ([] : List \u03b1) n = [] := by simp [rtake]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/DropRight.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (p : \u03b1 \u2192 Bool) (l : List \u03b1) (n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nrtake : x\u271d\n\u22a2 sorry = []"}, {"line": "simp [rtake]", "tactic_state": "x\u271d : Sort u_2\nrtake : x\u271d\n\u22a2 sorry () = []"}]}
{"declaration": "theorem rtake_zero : rtake l 0 = [] := by simp [rtake]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/DropRight.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (p : \u03b1 \u2192 Bool) (l : List \u03b1) (n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nrtake : x\u271d\n\u22a2 sorry = []"}, {"line": "simp [rtake]", "tactic_state": "x\u271d : Sort u_2\nrtake : x\u271d\n\u22a2 sorry () = []"}]}
{"declaration": "theorem rtake_concat_succ (x : \u03b1) : rtake (l ++ [x]) (n + 1) = rtake l n ++ [x] := by\n  simp [rtake_eq_reverse_take_reverse]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/DropRight.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (p : \u03b1 \u2192 Bool) (l : List \u03b1) (n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\nrtake : x\u271d\nx : \u03b1\n\u22a2 sorry = sorry ++ [x]"}, {"line": "simp [rtake_eq_reverse_take_reverse]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\nrtake : x\u271d\nx : \u03b1\n\u22a2 False"}]}
{"declaration": "theorem rdropWhile_nil : rdropWhile p ([] : List \u03b1) = [] := by simp [rdropWhile, dropWhile]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/DropRight.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (p : \u03b1 \u2192 Bool) (l : List \u03b1) (n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nrdropWhile : x\u271d\n\u22a2 sorry = []"}, {"line": "simp [rdropWhile, dropWhile]", "tactic_state": "x\u271d : Sort u_2\nrdropWhile : x\u271d\n\u22a2 sorry () = []"}]}
{"declaration": "theorem rdropWhile_eq_nil_iff : rdropWhile p l = [] \u2194 \u2200 x \u2208 l, p x := by simp [rdropWhile]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/DropRight.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (p : \u03b1 \u2192 Bool) (l : List \u03b1) (n : \u2115)", "{p} {l}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nx\u271d : Sort u_2\nrdropWhile : x\u271d\n\u22a2 sorry = [] \u2194 \u2200 x \u2208 l, p x = true"}, {"line": "simp [rdropWhile]", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nx\u271d : Sort u_2\nrdropWhile : x\u271d\n\u22a2 sorry () = [] \u2194 \u2200 x \u2208 l, p x = true"}]}
{"declaration": "theorem rdropWhile_eq_self_iff : rdropWhile p l = l \u2194 \u2200 hl : l \u2260 [], \u00acp (l.getLast hl) := by\n  simp [rdropWhile, reverse_eq_iff, getLast_eq_getElem, Nat.pos_iff_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/DropRight.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (p : \u03b1 \u2192 Bool) (l : List \u03b1) (n : \u2115)", "{p} {l}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nx\u271d : Sort u_2\nrdropWhile : x\u271d\n\u22a2 sorry = l \u2194 \u2200 (hl : l \u2260 []), \u00acp (l.getLast hl) = true"}, {"line": "simp [rdropWhile, reverse_eq_iff, getLast_eq_getElem, Nat.pos_iff_ne_zero]", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nx\u271d : Sort u_2\nrdropWhile : x\u271d\n\u22a2 sorry () = l \u2194 \u2200 (hl : \u00acl = []), p (l.getLast hl) = false"}]}
{"declaration": "theorem rtakeWhile_nil : rtakeWhile p ([] : List \u03b1) = [] := by simp [rtakeWhile, takeWhile]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/DropRight.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (p : \u03b1 \u2192 Bool) (l : List \u03b1) (n : \u2115)", "{p} {l}", "(p) (l)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nrtakeWhile : x\u271d\n\u22a2 sorry = []"}, {"line": "simp [rtakeWhile, takeWhile]", "tactic_state": "x\u271d : Sort u_2\nrtakeWhile : x\u271d\n\u22a2 sorry () = []"}]}
{"declaration": "theorem rtakeWhile_eq_self_iff : rtakeWhile p l = l \u2194 \u2200 x \u2208 l, p x := by\n  simp [rtakeWhile, reverse_eq_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/DropRight.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (p : \u03b1 \u2192 Bool) (l : List \u03b1) (n : \u2115)", "{p} {l}", "(p) (l)", "{p} {l}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nx\u271d : Sort u_2\nrtakeWhile : x\u271d\n\u22a2 sorry = l \u2194 \u2200 x \u2208 l, p x = true"}, {"line": "simp [rtakeWhile, reverse_eq_iff]", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nx\u271d : Sort u_2\nrtakeWhile : x\u271d\n\u22a2 sorry () = l \u2194 \u2200 x \u2208 l, p x = true"}]}
{"declaration": "theorem rtakeWhile_eq_nil_iff : rtakeWhile p l = [] \u2194 \u2200 hl : l \u2260 [], \u00acp (l.getLast hl) := by\n  induction' l using List.reverseRecOn with l a <;> simp [rtakeWhile]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/DropRight.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (p : \u03b1 \u2192 Bool) (l : List \u03b1) (n : \u2115)", "{p} {l}", "(p) (l)", "{p} {l}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nx\u271d : Sort u_2\nrtakeWhile : x\u271d\n\u22a2 sorry = [] \u2194 \u2200 (hl : l \u2260 []), \u00acp (l.getLast hl) = true"}, {"line": "induction' l using List.reverseRecOn with l a <;> simp [rtakeWhile]", "tactic_state": "case nil\n\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nx\u271d : Sort u_2\nrtakeWhile : x\u271d\n\u22a2 sorry () = [] \u2194 True\n---\ncase append_singleton\n\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl\u271d : List \u03b1\nx\u271d : Sort u_2\nrtakeWhile : x\u271d\nl : List \u03b1\na : \u03b1\na\u271d : sorry = [] \u2194 \u2200 (hl : l \u2260 []), \u00acp (l.getLast hl) = true\n\u22a2 sorry () = [] \u2194 p a = false"}]}
{"declaration": "lemma count_finRange {n : \u2115} (a : Fin n) : count a (finRange n) = 1 := by\n  simp [count_eq_of_nodup (nodup_finRange n)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/FinRange.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncount : x\u271d\nn : \u2115\na : Fin n\n\u22a2 sorry = 1"}, {"line": "simp [count_eq_of_nodup (nodup_finRange n)]", "tactic_state": "x\u271d : Sort u_1\ncount : x\u271d\nn : \u2115\na : Fin n\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem get_finRange {n : \u2115} {i : \u2115} (h) :\n    (finRange n).get \u27e8i, h\u27e9 = \u27e8i, length_finRange (n := n) \u25b8 h\u27e9 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/FinRange.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfinRange : x\u271d\nn i : \u2115\nh : ?m.458\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nfinRange : x\u271d\nn i : \u2115\nh : ?m.458\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem map_coe_finRange (n : \u2115) : ((finRange n) : List (Fin n)).map (Fin.val) = List.range n := by\n  apply List.ext_getElem <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/FinRange.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfinRange : x\u271d\nn : \u2115\n\u22a2 List.map Fin.val sorry = List.range n"}, {"line": "apply List.ext_getElem <;> simp", "tactic_state": "case hl\nx\u271d : Sort u_1\nfinRange : x\u271d\nn : \u2115\n\u22a2 (sorry ()).length = n\n---\ncase h\nx\u271d : Sort u_1\nfinRange : x\u271d\nn : \u2115\n\u22a2 \u2200 (i : \u2115) (h\u2081 : i < (sorry ()).length), i < n \u2192 \u2191(sorry ())[i] = i"}]}
{"declaration": "theorem Equiv.Perm.map_finRange_perm {n : \u2115} (\u03c3 : Equiv.Perm (Fin n)) :\n    map \u03c3 (finRange n) ~ finRange n := by\n  rw [perm_ext_iff_of_nodup ((nodup_finRange n).map \u03c3.injective) <| nodup_finRange n]\n  simpa [mem_map, mem_finRange] using \u03c3.surjective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/FinRange.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03c3 : Perm (Fin n)\n\u22a2 (map (\u21d1\u03c3) (finRange n)).Perm (finRange n)"}, {"line": "rw [perm_ext_iff_of_nodup ((nodup_finRange n).map \u03c3.injective) <| nodup_finRange n]", "tactic_state": "n : \u2115\n\u03c3 : Perm (Fin n)\n\u22a2 \u2200 (a : Fin n), a \u2208 map (\u21d1\u03c3) (finRange n) \u2194 a \u2208 finRange n"}, {"line": "simpa [mem_map, mem_finRange] using \u03c3.surjective", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Equiv.Perm.ofFn_comp_perm {n : \u2115} {\u03b1 : Type u} (\u03c3 : Equiv.Perm (Fin n)) (f : Fin n \u2192 \u03b1) :\n    ofFn (f \u2218 \u03c3) ~ ofFn f := by\n  rw [ofFn_eq_map]\n  rw [ofFn_eq_map]\n  rw [\u2190 map_map]\n  exact \u03c3.map_finRange_perm.map f", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/FinRange.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b1 : Type u\n\u03c3 : Perm (Fin n)\nf : Fin n \u2192 \u03b1\n\u22a2 (ofFn (f \u2218 \u21d1\u03c3)).Perm (ofFn f)"}, {"line": "rw [ofFn_eq_map]", "tactic_state": "n : \u2115\n\u03b1 : Type u\n\u03c3 : Perm (Fin n)\nf : Fin n \u2192 \u03b1\n\u22a2 (map (f \u2218 \u21d1\u03c3) (finRange n)).Perm (ofFn f)"}, {"line": "rw [ofFn_eq_map]", "tactic_state": "n : \u2115\n\u03b1 : Type u\n\u03c3 : Perm (Fin n)\nf : Fin n \u2192 \u03b1\n\u22a2 (map (f \u2218 \u21d1\u03c3) (finRange n)).Perm (map f (finRange n))"}, {"line": "rw [\u2190 map_map]", "tactic_state": "n : \u2115\n\u03b1 : Type u\n\u03c3 : Perm (Fin n)\nf : Fin n \u2192 \u03b1\n\u22a2 (map f (map (\u21d1\u03c3) (finRange n))).Perm (map f (finRange n))"}, {"line": "exact \u03c3.map_finRange_perm.map f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sublistForall\u2082_map_left_iff {f : \u03b3 \u2192 \u03b1} {l\u2081 : List \u03b3} {l\u2082 : List \u03b2} :\n    SublistForall\u2082 R (map f l\u2081) l\u2082 \u2194 SublistForall\u2082 (fun c b => R (f c) b) l\u2081 l\u2082 := by\n  simp [sublistForall\u2082_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Forall2.lean", "context": {"open": ["Nat Function", "Relator"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {R S : \u03b1 \u2192 \u03b2 \u2192 Prop} {P : \u03b3 \u2192 \u03b4 \u2192 Prop} {R\u2090 : \u03b1 \u2192 \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx\u271d : Sort u_5\nSublistForall\u2082 : x\u271d\nf : \u03b3 \u2192 \u03b1\nl\u2081 : List \u03b3\nl\u2082 : List \u03b2\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [sublistForall\u2082_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem insertIdx_eraseIdx {l : List \u03b1} {n : \u2115} (hn : n \u2260 length l) (a : \u03b1) :\n    (l.eraseIdx n).insertIdx n a = l.set n a := by\n  induction n generalizing l <;> cases l <;> simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/InsertIdx.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "{a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\nlength : x\u271d\nl : List \u03b1\nn : \u2115\nhn : n \u2260 sorry\na : \u03b1\n\u22a2 (l.eraseIdx n).insertIdx n a = l.set n a"}, {"line": "induction n generalizing l <;> cases l <;> simp_all", "tactic_state": "case zero.nil\n\u03b1 : Type u\nx\u271d : Sort u_1\nlength : x\u271d\na : \u03b1\nhn : \u00ac0 = sorry ()\n\u22a2 False\n---\ncase succ.cons\n\u03b1 : Type u\nx\u271d : Sort u_1\nlength : x\u271d\na : \u03b1\nn\u271d : \u2115\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\na\u271d : \u2200 {l : List \u03b1}, \u00acn\u271d = sorry () \u2192 (l.eraseIdx n\u271d).insertIdx n\u271d a = l.set n\u271d a\nhn : \u00acn\u271d + 1 = sorry ()\n\u22a2 (tail\u271d.eraseIdx n\u271d).insertIdx n\u271d a = tail\u271d.set n\u271d a"}]}
{"declaration": "theorem insertIdx_subset_cons (n : \u2115) (a : \u03b1) (l : List \u03b1) : l.insertIdx n a \u2286 a :: l := by\n  intro b hb\n  simpa using eq_or_mem_of_mem_insertIdx hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/InsertIdx.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "{a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nn : \u2115\na : \u03b1\nl : List \u03b1\n\u22a2 l.insertIdx n a \u2286 a :: l"}, {"line": "intro b hb", "tactic_state": "\u03b1 : Type u\nn : \u2115\na : \u03b1\nl : List \u03b1\nb : \u03b1\nhb : b \u2208 l.insertIdx n a\n\u22a2 b \u2208 a :: l"}, {"line": "simpa using eq_or_mem_of_mem_insertIdx hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eraseIdx_map (f : \u03b1 \u2192 \u03b2) (l : List \u03b1) (n : \u2115) :\n    (map f l).eraseIdx n = (l.eraseIdx n).map f := by\n  simpa only [pmap_eq_map] using eraseIdx_pmap (fun a _ \u21a6 f a) (fun _ _ \u21a6 trivial) n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/InsertIdx.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "{a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nx\u271d : Sort u_1\nmap : x\u271d\nf : \u03b1 \u2192 \u03b2\nl : List \u03b1\nn : \u2115\n\u22a2 sorry = List.map f (l.eraseIdx n)"}, {"line": "simpa only [pmap_eq_map] using eraseIdx_pmap (fun a _ \u21a6 f a) (fun _ _ \u21a6 trivial) n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem get_insertIdx_self (l : List \u03b1) (x : \u03b1) (n : \u2115) (hn : n \u2264 l.length)\n    (hn' : n < (l.insertIdx n x).length :=\n      (by rwa [length_insertIdx_of_le_length hn, Nat.lt_succ_iff])) :\n    (l.insertIdx n x).get \u27e8n, hn'\u27e9 = x := by\n  simp [hn, hn']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/InsertIdx.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "{a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl : List \u03b1\nx : \u03b1\nn : \u2115\nhn : n \u2264 l.length\nhn' : optParam (n < (l.insertIdx n x).length) \u22ef\n\u22a2 (l.insertIdx n x).get \u27e8n, hn'\u27e9 = x"}, {"line": "simp [hn, hn']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem get_insertIdx_add_succ (l : List \u03b1) (x : \u03b1) (n k : \u2115) (hk' : n + k < l.length)\n    (hk : n + k + 1 < (l.insertIdx n x).length := (by\n      rwa [length_insertIdx_of_le_length (by omega), Nat.succ_lt_succ_iff])) :\n    (l.insertIdx n x).get \u27e8n + k + 1, hk\u27e9 = get l \u27e8n + k, hk'\u27e9 := by\n  simp [getElem_insertIdx_add_succ, hk, hk']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/InsertIdx.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "{a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl : List \u03b1\nx : \u03b1\nn k : \u2115\nhk' : n + k < l.length\nhk : optParam (n + k + 1 < (l.insertIdx n x).length) \u22ef\n\u22a2 (l.insertIdx n x).get \u27e8n + k + 1, hk\u27e9 = sorry"}, {"line": "simp [getElem_insertIdx_add_succ, hk, hk']", "tactic_state": "\u03b1 : Type u\nl : List \u03b1\nx : \u03b1\nn k : \u2115\nhk' : n + k < l.length\nhk : optParam (n + k + 1 < (l.insertIdx n x).length) \u22ef\n\u22a2 (l.insertIdx n x)[n + k + 1] = sorry ()"}]}
{"declaration": "theorem length_iterate (f : \u03b1 \u2192 \u03b1) (a : \u03b1) (n : \u2115) : length (iterate f a n) = n := by\n  induction n generalizing a <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Iterate.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\nlength : x\u271d\nf : \u03b1 \u2192 \u03b1\na : \u03b1\nn : \u2115\n\u22a2 sorry = n"}, {"line": "induction n generalizing a <;> simp [*]", "tactic_state": "case zero\n\u03b1 : Type u_1\nx\u271d : Sort u_2\nlength : x\u271d\nf : \u03b1 \u2192 \u03b1\na : \u03b1\n\u22a2 sorry () = 0\n---\ncase succ\n\u03b1 : Type u_1\nx\u271d : Sort u_2\nlength : x\u271d\nf : \u03b1 \u2192 \u03b1\nn\u271d : \u2115\na\u271d : \u03b1 \u2192 sorry = n\u271d\na : \u03b1\n\u22a2 sorry () = n\u271d + 1"}]}
{"declaration": "theorem mem_iterate {f : \u03b1 \u2192 \u03b1} {a : \u03b1} {n : \u2115} {b : \u03b1} :\n    b \u2208 iterate f a n \u2194 \u2203 m < n, b = f^[m] a := by\n  simp [List.mem_iff_get, Fin.exists_iff, eq_comm (b := b)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Iterate.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\niterate : x\u271d\nf : \u03b1 \u2192 \u03b1\na : \u03b1\nn : \u2115\nb : \u03b1\n\u22a2 b \u2208 sorry \u2194 \u2203 m < n, b = f^[m] a"}, {"line": "simp [List.mem_iff_get, Fin.exists_iff, eq_comm (b := b)]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\niterate : x\u271d\nf : \u03b1 \u2192 \u03b1\na : \u03b1\nn : \u2115\nb : \u03b1\n\u22a2 b \u2208 sorry () \u2194 \u2203 m < n, b = f^[m] a"}]}
{"declaration": "theorem range_map_iterate (n : \u2115) (f : \u03b1 \u2192 \u03b1) (a : \u03b1) :\n    (List.range n).map (f^[\u00b7] a) = List.iterate f a n := by\n  apply List.ext_getElem <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Iterate.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : \u2115\nf : \u03b1 \u2192 \u03b1\na : \u03b1\n\u22a2 List.map (fun x => f^[x] a) (List.range n) = List.iterate f a n"}, {"line": "apply List.ext_getElem <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_antidiagonal (n : \u2115) : (antidiagonal n).length = n + 1 := by\n  rw [antidiagonal]\n  rw [length_map]\n  rw [length_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/NatAntidiagonal.lean", "context": {"open": ["List Function Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 (antidiagonal n).length = n + 1"}, {"line": "rw [antidiagonal]", "tactic_state": "n : \u2115\n\u22a2 (map (fun i => (i, n - i)) (range (n + 1))).length = n + 1"}, {"line": "rw [length_map]", "tactic_state": "n : \u2115\n\u22a2 (range (n + 1)).length = n + 1"}, {"line": "rw [length_range]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem antidiagonal_succ_succ' {n : \u2115} :\n    antidiagonal (n + 2) =\n      (0, n + 2) :: (antidiagonal n).map (Prod.map Nat.succ Nat.succ) ++ [(n + 2, 0)] := by\n  rw [antidiagonal_succ']\n  simp only [antidiagonal_succ]\n  simp only [map_cons]\n  simp only [Prod.map_apply]\n  simp only [id_eq]\n  simp only [map_map]\n  simp only [cons_append]\n  simp only [cons.injEq]\n  simp only [append_cancel_right_eq]\n  simp only [true_and]\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/NatAntidiagonal.lean", "context": {"open": ["List Function Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 antidiagonal (n + 2) = (0, n + 2) :: map (Prod.map succ succ) (antidiagonal n) ++ [(n + 2, 0)]"}, {"line": "rw [antidiagonal_succ']", "tactic_state": "n : \u2115\n\u22a2 map (Prod.map id succ) (antidiagonal (n + 1)) ++ [(n + 1 + 1, 0)] =\n    (0, n + 2) :: map (Prod.map succ succ) (antidiagonal n) ++ [(n + 2, 0)]"}, {"line": "simp only [antidiagonal_succ]", "tactic_state": "n : \u2115\n\u22a2 map (Prod.map id succ) ((0, n + 1) :: map (Prod.map succ id) (antidiagonal n)) ++ [(n + 1 + 1, 0)] =\n    (0, n + 2) :: map (Prod.map succ succ) (antidiagonal n) ++ [(n + 2, 0)]"}, {"line": "simp only [map_cons]", "tactic_state": "n : \u2115\n\u22a2 Prod.map id succ (0, n + 1) :: map (Prod.map id succ) (map (Prod.map succ id) (antidiagonal n)) ++ [(n + 1 + 1, 0)] =\n    (0, n + 2) :: map (Prod.map succ succ) (antidiagonal n) ++ [(n + 2, 0)]"}, {"line": "simp only [Prod.map_apply]", "tactic_state": "n : \u2115\n\u22a2 (id 0, (n + 1).succ) :: map (Prod.map id succ) (map (Prod.map succ id) (antidiagonal n)) ++ [(n + 1 + 1, 0)] =\n    (0, n + 2) :: map (Prod.map succ succ) (antidiagonal n) ++ [(n + 2, 0)]"}, {"line": "simp only [id_eq]", "tactic_state": "n : \u2115\n\u22a2 (0, (n + 1).succ) :: map (Prod.map id succ) (map (Prod.map succ id) (antidiagonal n)) ++ [(n + 1 + 1, 0)] =\n    (0, n + 2) :: map (Prod.map succ succ) (antidiagonal n) ++ [(n + 2, 0)]"}, {"line": "simp only [map_map]", "tactic_state": "n : \u2115\n\u22a2 (0, (n + 1).succ) :: map (Prod.map id succ \u2218 Prod.map succ id) (antidiagonal n) ++ [(n + 1 + 1, 0)] =\n    (0, n + 2) :: map (Prod.map succ succ) (antidiagonal n) ++ [(n + 2, 0)]"}, {"line": "simp only [cons_append]", "tactic_state": "n : \u2115\n\u22a2 (0, (n + 1).succ) :: (map (Prod.map id succ \u2218 Prod.map succ id) (antidiagonal n) ++ [(n + 1 + 1, 0)]) =\n    (0, n + 2) :: (map (Prod.map succ succ) (antidiagonal n) ++ [(n + 2, 0)])"}, {"line": "simp only [cons.injEq]", "tactic_state": "n : \u2115\n\u22a2 True \u2227\n    map (Prod.map id succ \u2218 Prod.map succ id) (antidiagonal n) ++ [(n + 1 + 1, 0)] =\n      map (Prod.map succ succ) (antidiagonal n) ++ [(n + 2, 0)]"}, {"line": "simp only [append_cancel_right_eq]", "tactic_state": "n : \u2115\n\u22a2 True \u2227 map (Prod.map id succ \u2218 Prod.map succ id) (antidiagonal n) = map (Prod.map succ succ) (antidiagonal n)"}, {"line": "simp only [true_and]", "tactic_state": "n : \u2115\n\u22a2 map (Prod.map id succ \u2218 Prod.map succ id) (antidiagonal n) = map (Prod.map succ succ) (antidiagonal n)"}, {"line": "ext", "tactic_state": "case h.a\nn i\u271d : \u2115\na\u271d : \u2115 \u00d7 \u2115\n\u22a2 a\u271d \u2208 (map (Prod.map id succ \u2218 Prod.map succ id) (antidiagonal n))[i\u271d]? \u2194\n    a\u271d \u2208 (map (Prod.map succ succ) (antidiagonal n))[i\u271d]?"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_swap_antidiagonal {n : \u2115} :\n    (antidiagonal n).map Prod.swap = (antidiagonal n).reverse := by\n  rw [antidiagonal]\n  rw [map_map]\n  rw [\u2190 List.map_reverse]\n  rw [range_eq_range']\n  rw [reverse_range']\n  rw [\u2190     range_eq_range']\n  rw [map_map]\n  apply map_congr_left\n  simp +contextual [Nat.sub_sub_self, Nat.lt_succ_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/NatAntidiagonal.lean", "context": {"open": ["List Function Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 map Prod.swap (antidiagonal n) = (antidiagonal n).reverse"}, {"line": "rw [antidiagonal]", "tactic_state": "n : \u2115\n\u22a2 map Prod.swap (map (fun i => (i, n - i)) (range (n + 1))) = (map (fun i => (i, n - i)) (range (n + 1))).reverse"}, {"line": "rw [map_map]", "tactic_state": "n : \u2115\n\u22a2 map (Prod.swap \u2218 fun i => (i, n - i)) (range (n + 1)) = (map (fun i => (i, n - i)) (range (n + 1))).reverse"}, {"line": "rw [\u2190 List.map_reverse]", "tactic_state": "n : \u2115\n\u22a2 map (Prod.swap \u2218 fun i => (i, n - i)) (range (n + 1)) = map (fun i => (i, n - i)) (range (n + 1)).reverse"}, {"line": "rw [range_eq_range']", "tactic_state": "n : \u2115\n\u22a2 map (Prod.swap \u2218 fun i => (i, n - i)) (range' 0 (n + 1)) = map (fun i => (i, n - i)) (range' 0 (n + 1)).reverse"}, {"line": "rw [reverse_range']", "tactic_state": "n : \u2115\n\u22a2 map (Prod.swap \u2218 fun i => (i, n - i)) (range' 0 (n + 1)) =\n    map (fun i => (i, n - i)) (map (fun x => 0 + (n + 1) - 1 - x) (range (n + 1)))"}, {"line": "rw [\u2190     range_eq_range']", "tactic_state": "n : \u2115\n\u22a2 map (Prod.swap \u2218 fun i => (i, n - i)) (range (n + 1)) =\n    map (fun i => (i, n - i)) (map (fun x => 0 + (n + 1) - 1 - x) (range (n + 1)))"}, {"line": "rw [map_map]", "tactic_state": "n : \u2115\n\u22a2 map (Prod.swap \u2218 fun i => (i, n - i)) (range (n + 1)) =\n    map ((fun i => (i, n - i)) \u2218 fun x => 0 + (n + 1) - 1 - x) (range (n + 1))"}, {"line": "apply map_congr_left", "tactic_state": "case h\nn : \u2115\n\u22a2 \u2200 a \u2208 range (n + 1), (Prod.swap \u2218 fun i => (i, n - i)) a = ((fun i => (i, n - i)) \u2218 fun x => 0 + (n + 1) - 1 - x) a"}, {"line": "simp +contextual [Nat.sub_sub_self, Nat.lt_succ_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.Multiset.pi_coe (l : List \u03b9) (fs : \u2200 i, List (\u03b1 i)) :\n    (l : Multiset \u03b9).pi (fs \u00b7) = (\u2191(pi l fs) : Multiset (\u2200 i \u2208 l, \u03b1 i)) := by\n  induction' l with i l ih\n  \u00b7 change Multiset.pi 0 _ = _\n    simp only [Multiset.coe_singleton]\n    simp only [Multiset.pi_zero]\n    simp only [pi_nil]\n    simp only [Multiset.singleton_inj]\n    ext i hi\n    simp at hi\n  \u00b7 change Multiset.pi (i ::\u2098 \u2191l) _ = _\n    simp [ih, Multiset.coe_bind, - Multiset.cons_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Pi.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*} [DecidableEq \u03b9] {\u03b1 : \u03b9 \u2192 Sort*}", "{i : \u03b9} {l : List \u03b9}", "(i l)", "{i l}", "{\u03b9 : Type*} [DecidableEq \u03b9] {\u03b1 : \u03b9 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\n\u03b1 : \u03b9 \u2192 Type u_4\nx\u271d : Sort u_5\npi : x\u271d\nl : List \u03b9\nfs : (i : \u03b9) \u2192 List (\u03b1 i)\n\u22a2 ((\u2191l).pi fun x => \u2191(fs x)) = sorry"}, {"line": "induction' l with i l ih", "tactic_state": "case nil\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\n\u03b1 : \u03b9 \u2192 Type u_4\nx\u271d : Sort u_5\npi : x\u271d\nfs : (i : \u03b9) \u2192 List (\u03b1 i)\n\u22a2 ((\u2191[]).pi fun x => \u2191(fs x)) = sorry\n---\ncase cons\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\n\u03b1 : \u03b9 \u2192 Type u_4\nx\u271d : Sort u_5\npi : x\u271d\nfs : (i : \u03b9) \u2192 List (\u03b1 i)\ni : \u03b9\nl : List \u03b9\nih : ((\u2191l).pi fun x => \u2191(fs x)) = sorry\n\u22a2 ((\u2191(i :: l)).pi fun x => \u2191(fs x)) = sorry"}, {"line": "\u00b7 change Multiset.pi 0 _ = _\n    simp only [Multiset.coe_singleton]\n    simp only [Multiset.pi_zero]\n    simp only [pi_nil]\n    simp only [Multiset.singleton_inj]\n    ext i hi\n    simp at hi", "tactic_state": "case cons\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\n\u03b1 : \u03b9 \u2192 Type u_4\nx\u271d : Sort u_5\npi : x\u271d\nfs : (i : \u03b9) \u2192 List (\u03b1 i)\ni : \u03b9\nl : List \u03b9\nih : ((\u2191l).pi fun x => \u2191(fs x)) = sorry\n\u22a2 ((\u2191(i :: l)).pi fun x => \u2191(fs x)) = sorry"}, {"line": "\u00b7 change Multiset.pi (i ::\u2098 \u2191l) _ = _\n    simp [ih, Multiset.coe_bind, - Multiset.cons_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_product {l\u2081 : List \u03b1} {l\u2082 : List \u03b2} {a : \u03b1} {b : \u03b2} :\n    (a, b) \u2208 l\u2081 \u00d7\u02e2 l\u2082 \u2194 a \u2208 l\u2081 \u2227 b \u2208 l\u2082 := by\n  simp_all [SProd.sprod, product, mem_flatMap, mem_map, Prod.ext_iff, exists_prop, and_left_comm,\n    exists_and_left, exists_eq_left, exists_eq_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/ProdSigma.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u2081 : List \u03b1\nl\u2082 : List \u03b2\na : \u03b1\nb : \u03b2\n\u22a2 (a, b) \u2208 l\u2081 \u00d7\u02e2 l\u2082 \u2194 a \u2208 l\u2081 \u2227 b \u2208 l\u2082"}, {"line": "simp_all [SProd.sprod, product, mem_flatMap, mem_map, Prod.ext_iff, exists_prop, and_left_comm,\n    exists_and_left, exists_eq_left, exists_eq_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_product (l\u2081 : List \u03b1) (l\u2082 : List \u03b2) :\n    length (l\u2081 \u00d7\u02e2 l\u2082) = length l\u2081 * length l\u2082 := by\n  induction' l\u2081 with x l\u2081 IH\n  \u00b7 exact (Nat.zero_mul _).symm\n  \u00b7 simp only [length, product_cons, length_append, IH, Nat.add_mul, Nat.one_mul, length_map,\n      Nat.add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/ProdSigma.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_3\nlength : x\u271d\nl\u2081 : List \u03b1\nl\u2082 : List \u03b2\n\u22a2 sorry = sorry * sorry"}, {"line": "induction' l\u2081 with x l\u2081 IH", "tactic_state": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_3\nlength : x\u271d\nl\u2082 : List \u03b2\n\u22a2 sorry = sorry * sorry\n---\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_3\nlength : x\u271d\nl\u2082 : List \u03b2\nx : \u03b1\nl\u2081 : List \u03b1\nIH : sorry = sorry * sorry\n\u22a2 sorry = sorry * sorry"}, {"line": "\u00b7 exact (Nat.zero_mul _).symm", "tactic_state": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_3\nlength : x\u271d\nl\u2082 : List \u03b2\nx : \u03b1\nl\u2081 : List \u03b1\nIH : sorry = sorry * sorry\n\u22a2 sorry = sorry * sorry"}, {"line": "\u00b7 simp only [length, product_cons, length_append, IH, Nat.add_mul, Nat.one_mul, length_map,\n      Nat.add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_sigma {l\u2081 : List \u03b1} {l\u2082 : \u2200 a, List (\u03c3 a)} {a : \u03b1} {b : \u03c3 a} :\n    Sigma.mk a b \u2208 l\u2081.sigma l\u2082 \u2194 a \u2208 l\u2081 \u2227 b \u2208 l\u2082 a := by\n  simp [List.sigma, mem_flatMap, mem_map, exists_prop, exists_and_left, and_left_comm,\n    exists_eq_left, heq_iff_eq, exists_eq_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/ProdSigma.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03c3 : \u03b1 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03c3 : \u03b1 \u2192 Type u_3\nl\u2081 : List \u03b1\nl\u2082 : (a : \u03b1) \u2192 List (\u03c3 a)\na : \u03b1\nb : \u03c3 a\n\u22a2 \u27e8a, b\u27e9 \u2208 l\u2081.sigma l\u2082 \u2194 a \u2208 l\u2081 \u2227 b \u2208 l\u2082 a"}, {"line": "simp [List.sigma, mem_flatMap, mem_map, exists_prop, exists_and_left, and_left_comm,\n    exists_eq_left, heq_iff_eq, exists_eq_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_map_swap (x : \u03b1) (y : \u03b2) (xs : List (\u03b1 \u00d7 \u03b2)) :\n    (y, x) \u2208 map Prod.swap xs \u2194 (x, y) \u2208 xs := by\n  induction' xs with x xs xs_ih\n  \u00b7 simp only [not_mem_nil, map_nil]\n  \u00b7 obtain \u27e8a, b\u27e9 := x\n    simp only [mem_cons]\n    simp only [Prod.mk_inj]\n    simp only [map]\n    simp only [Prod.swap_prod_mk]\n    simp only [Prod.exists]\n    simp only [xs_ih]\n    simp only [and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/ProdSigma.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03c3 : \u03b1 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_4\nmap : x\u271d\nx : \u03b1\ny : \u03b2\nxs : List (\u03b1 \u00d7 \u03b2)\n\u22a2 (y, x) \u2208 sorry \u2194 (x, y) \u2208 xs"}, {"line": "induction' xs with x xs xs_ih", "tactic_state": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_4\nmap : x\u271d\nx : \u03b1\ny : \u03b2\n\u22a2 (y, x) \u2208 sorry \u2194 (x, y) \u2208 []\n---\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_4\nmap : x\u271d\u00b9\nx\u271d : \u03b1\ny : \u03b2\nx : \u03b1 \u00d7 \u03b2\nxs : List (\u03b1 \u00d7 \u03b2)\nxs_ih : (y, x\u271d) \u2208 sorry \u2194 (x\u271d, y) \u2208 xs\n\u22a2 (y, x\u271d) \u2208 sorry \u2194 (x\u271d, y) \u2208 x :: xs"}, {"line": "\u00b7 simp only [not_mem_nil, map_nil]", "tactic_state": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_4\nmap : x\u271d\u00b9\nx\u271d : \u03b1\ny : \u03b2\nx : \u03b1 \u00d7 \u03b2\nxs : List (\u03b1 \u00d7 \u03b2)\nxs_ih : (y, x\u271d) \u2208 sorry \u2194 (x\u271d, y) \u2208 xs\n\u22a2 (y, x\u271d) \u2208 sorry \u2194 (x\u271d, y) \u2208 x :: xs"}, {"line": "\u00b7 obtain \u27e8a, b\u27e9 := x\n    simp only [mem_cons]\n    simp only [Prod.mk_inj]\n    simp only [map]\n    simp only [Prod.swap_prod_mk]\n    simp only [Prod.exists]\n    simp only [xs_ih]\n    simp only [and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem shortlex_iff_lex {s t : List \u03b1} (h : s.length = t.length) :\n    Shortlex r s t \u2194 List.Lex r s t := by\n  simp [shortlex_def, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Shortlex.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_2\nShortlex : x\u271d\ns t : List \u03b1\nh : s.length = t.length\n\u22a2 sorry \u2194 List.Lex r s t"}, {"line": "simp [shortlex_def, h]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_2\nShortlex : x\u271d\ns t : List \u03b1\nh : s.length = t.length\n\u22a2 sorry () \u2194 List.Lex r s t"}]}
{"declaration": "theorem length_splitLengths : (sz.splitLengths l).length = sz.length := by\n  induction sz generalizing l <;> simp [splitLengths, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/SplitLengths.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (l : List \u03b1) (sz : List \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : List \u03b1\nsz : List \u2115\n\u22a2 (sz.splitLengths l).length = sz.length"}, {"line": "induction sz generalizing l <;> simp [splitLengths, *]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma splitLengths_cons (n : \u2115) :\n    (n :: sz).splitLengths l = l.take n :: sz.splitLengths (l.drop n) := by\n  simp [splitLengths]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/SplitLengths.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (l : List \u03b1) (sz : List \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : List \u03b1\nsz : List \u2115\nn : \u2115\n\u22a2 (n :: sz).splitLengths l = List.take n l :: sz.splitLengths (List.drop n l)"}, {"line": "simp [splitLengths]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem take_splitLength (i : \u2115) : (sz.splitLengths l).take i = (sz.take i).splitLengths l := by\n  induction i generalizing sz l\n  case zero => simp\n  case succ i hi =>\n    cases sz\n    \u00b7 simp\n    \u00b7 simp only [splitLengths_cons, take_succ_cons, cons.injEq, true_and, hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/SplitLengths.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (l : List \u03b1) (sz : List \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : List \u03b1\nsz : List \u2115\ni : \u2115\n\u22a2 List.take i (sz.splitLengths l) = (List.take i sz).splitLengths l"}, {"line": "induction i generalizing sz l", "tactic_state": "case zero\n\u03b1 : Type u_1\nl : List \u03b1\nsz : List \u2115\n\u22a2 List.take 0 (sz.splitLengths l) = (List.take 0 sz).splitLengths l\n---\ncase succ\n\u03b1 : Type u_1\nn\u271d : \u2115\na\u271d : \u2200 (l : List \u03b1) (sz : List \u2115), List.take n\u271d (sz.splitLengths l) = (List.take n\u271d sz).splitLengths l\nl : List \u03b1\nsz : List \u2115\n\u22a2 List.take (n\u271d + 1) (sz.splitLengths l) = (List.take (n\u271d + 1) sz).splitLengths l"}, {"line": "case zero => simp", "tactic_state": "case succ\n\u03b1 : Type u_1\nn\u271d : \u2115\na\u271d : \u2200 (l : List \u03b1) (sz : List \u2115), List.take n\u271d (sz.splitLengths l) = (List.take n\u271d sz).splitLengths l\nl : List \u03b1\nsz : List \u2115\n\u22a2 List.take (n\u271d + 1) (sz.splitLengths l) = (List.take (n\u271d + 1) sz).splitLengths l"}, {"line": "case succ i hi =>\n    cases sz\n    \u00b7 simp\n    \u00b7 simp only [splitLengths_cons, take_succ_cons, cons.injEq, true_and, hi]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_splitLengths_getElem_le {i : \u2115} {hi : i < (sz.splitLengths l).length} :\n    (sz.splitLengths l)[i].length \u2264 sz[i]'(by simpa using hi) := by\n  induction sz generalizing l i\n  \u00b7 simp at hi\n  case cons head tail tail_ih =>\n    simp only [splitLengths_cons]\n    cases i\n    \u00b7 simp\n    \u00b7 simp only [getElem_cons_succ, tail_ih]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/SplitLengths.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (l : List \u03b1) (sz : List \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : List \u03b1\nsz : List \u2115\ni : \u2115\nhi : i < (sz.splitLengths l).length\n\u22a2 (sz.splitLengths l)[i].length \u2264 sz[i]"}, {"line": "induction sz generalizing l i", "tactic_state": "case nil\n\u03b1 : Type u_1\nl : List \u03b1\ni : \u2115\nhi : i < ([].splitLengths l).length\n\u22a2 ([].splitLengths l)[i].length \u2264 [][i]\n---\ncase cons\n\u03b1 : Type u_1\nhead\u271d : \u2115\ntail\u271d : List \u2115\ntail_ih\u271d : \u2200 (l : List \u03b1) {i : \u2115} {hi : i < (tail\u271d.splitLengths l).length}, (tail\u271d.splitLengths l)[i].length \u2264 tail\u271d[i]\nl : List \u03b1\ni : \u2115\nhi : i < ((head\u271d :: tail\u271d).splitLengths l).length\n\u22a2 ((head\u271d :: tail\u271d).splitLengths l)[i].length \u2264 (head\u271d :: tail\u271d)[i]"}, {"line": "\u00b7 simp at hi", "tactic_state": "case cons\n\u03b1 : Type u_1\nhead\u271d : \u2115\ntail\u271d : List \u2115\ntail_ih\u271d : \u2200 (l : List \u03b1) {i : \u2115} {hi : i < (tail\u271d.splitLengths l).length}, (tail\u271d.splitLengths l)[i].length \u2264 tail\u271d[i]\nl : List \u03b1\ni : \u2115\nhi : i < ((head\u271d :: tail\u271d).splitLengths l).length\n\u22a2 ((head\u271d :: tail\u271d).splitLengths l)[i].length \u2264 (head\u271d :: tail\u271d)[i]"}, {"line": "case cons head tail tail_ih =>\n    simp only [splitLengths_cons]\n    cases i\n    \u00b7 simp\n    \u00b7 simp only [getElem_cons_succ, tail_ih]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem flatten_splitLengths (h : l.length \u2264 sz.sum) : (sz.splitLengths l).flatten = l := by\n  induction sz generalizing l\n  \u00b7 simp_all\n  case cons head tail ih =>\n    simp only [splitLengths_cons]\n    simp only [flatten_cons]\n    rw [ih]\n    rw [take_append_drop]\n    simpa [add_comm] using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/SplitLengths.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (l : List \u03b1) (sz : List \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : List \u03b1\nsz : List \u2115\nh : l.length \u2264 sz.sum\n\u22a2 (sz.splitLengths l).flatten = l"}, {"line": "induction sz generalizing l", "tactic_state": "case nil\n\u03b1 : Type u_1\nl : List \u03b1\nh : l.length \u2264 [].sum\n\u22a2 ([].splitLengths l).flatten = l\n---\ncase cons\n\u03b1 : Type u_1\nhead\u271d : \u2115\ntail\u271d : List \u2115\ntail_ih\u271d : \u2200 (l : List \u03b1), l.length \u2264 tail\u271d.sum \u2192 (tail\u271d.splitLengths l).flatten = l\nl : List \u03b1\nh : l.length \u2264 (head\u271d :: tail\u271d).sum\n\u22a2 ((head\u271d :: tail\u271d).splitLengths l).flatten = l"}, {"line": "\u00b7 simp_all", "tactic_state": "case cons\n\u03b1 : Type u_1\nhead\u271d : \u2115\ntail\u271d : List \u2115\ntail_ih\u271d : \u2200 (l : List \u03b1), l.length \u2264 tail\u271d.sum \u2192 (tail\u271d.splitLengths l).flatten = l\nl : List \u03b1\nh : l.length \u2264 (head\u271d :: tail\u271d).sum\n\u22a2 ((head\u271d :: tail\u271d).splitLengths l).flatten = l"}, {"line": "case cons head tail ih =>\n    simp only [splitLengths_cons]\n    simp only [flatten_cons]\n    rw [ih]\n    rw [take_append_drop]\n    simpa [add_comm] using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_splitLengths_length (h : sz.sum \u2264 l.length) :\n    (sz.splitLengths l).map length = sz := by\n  induction sz generalizing l\n  \u00b7 simp\n  case cons head tail ih =>\n    simp only [sum_cons] at h\n    simp only [splitLengths_cons]\n    simp only [map_cons]\n    simp only [length_take]\n    simp only [cons.injEq]\n    simp only [min_eq_left_iff]\n    rw [ih]\n    \u00b7 simp [Nat.le_of_add_right_le h]\n    \u00b7 simp [Nat.le_sub_of_add_le' h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/SplitLengths.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (l : List \u03b1) (sz : List \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : List \u03b1\nsz : List \u2115\nlength : List \u03b1 \u2192 \u2115\nh : sz.sum \u2264 l.length\n\u22a2 List.map length (sz.splitLengths l) = sz"}, {"line": "induction sz generalizing l", "tactic_state": "case nil\n\u03b1 : Type u_1\nlength : List \u03b1 \u2192 \u2115\nl : List \u03b1\nh : [].sum \u2264 l.length\n\u22a2 List.map length ([].splitLengths l) = []\n---\ncase cons\n\u03b1 : Type u_1\nlength : List \u03b1 \u2192 \u2115\nhead\u271d : \u2115\ntail\u271d : List \u2115\ntail_ih\u271d : \u2200 (l : List \u03b1), tail\u271d.sum \u2264 l.length \u2192 List.map length (tail\u271d.splitLengths l) = tail\u271d\nl : List \u03b1\nh : (head\u271d :: tail\u271d).sum \u2264 l.length\n\u22a2 List.map length ((head\u271d :: tail\u271d).splitLengths l) = head\u271d :: tail\u271d"}, {"line": "\u00b7 simp", "tactic_state": "case cons\n\u03b1 : Type u_1\nlength : List \u03b1 \u2192 \u2115\nhead\u271d : \u2115\ntail\u271d : List \u2115\ntail_ih\u271d : \u2200 (l : List \u03b1), tail\u271d.sum \u2264 l.length \u2192 List.map length (tail\u271d.splitLengths l) = tail\u271d\nl : List \u03b1\nh : (head\u271d :: tail\u271d).sum \u2264 l.length\n\u22a2 List.map length ((head\u271d :: tail\u271d).splitLengths l) = head\u271d :: tail\u271d"}, {"line": "case cons head tail ih =>\n    simp only [sum_cons] at h\n    simp only [splitLengths_cons]\n    simp only [map_cons]\n    simp only [length_take]\n    simp only [cons.injEq]\n    simp only [min_eq_left_iff]\n    rw [ih]\n    \u00b7 simp [Nat.le_of_add_right_le h]\n    \u00b7 simp [Nat.le_sub_of_add_le' h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma take_concat_get' (l : List \u03b1) (i : \u2115) (h : i < l.length) :\n  l.take i ++ [l[i]] = l.take (i + 1) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/TakeDrop.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl : List \u03b1\ni : \u2115\nh : i < l.length\n\u22a2 List.take i l ++ [l[i]] = List.take (i + 1) l"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dropSlice_eq (xs : List \u03b1) (n m : \u2115) : dropSlice n m xs = xs.take n ++ xs.drop (n + m) := by\n  induction n generalizing xs\n  \u00b7 cases xs <;> simp [dropSlice]\n  \u00b7 cases xs <;> simp [dropSlice, *, Nat.succ_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/TakeDrop.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}", "[Inhabited \u03b1]", "(p)", "(p : \u03b1 \u2192 Bool)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Inhabited \u03b1\nx\u271d : Sort u_2\ndropSlice : x\u271d\nxs : List \u03b1\nn m : \u2115\n\u22a2 sorry = List.take n xs ++ List.drop (n + m) xs"}, {"line": "induction n generalizing xs", "tactic_state": "case zero\n\u03b1 : Type u\ninst\u271d : Inhabited \u03b1\nx\u271d : Sort u_2\ndropSlice : x\u271d\nm : \u2115\nxs : List \u03b1\n\u22a2 sorry = List.take 0 xs ++ List.drop (0 + m) xs\n---\ncase succ\n\u03b1 : Type u\ninst\u271d : Inhabited \u03b1\nx\u271d : Sort u_2\ndropSlice : x\u271d\nm n\u271d : \u2115\na\u271d : \u2200 (xs : List \u03b1), sorry = List.take n\u271d xs ++ List.drop (n\u271d + m) xs\nxs : List \u03b1\n\u22a2 sorry = List.take (n\u271d + 1) xs ++ List.drop (n\u271d + 1 + m) xs"}, {"line": "\u00b7 cases xs <;> simp [dropSlice]", "tactic_state": "case succ\n\u03b1 : Type u\ninst\u271d : Inhabited \u03b1\nx\u271d : Sort u_2\ndropSlice : x\u271d\nm n\u271d : \u2115\na\u271d : \u2200 (xs : List \u03b1), sorry = List.take n\u271d xs ++ List.drop (n\u271d + m) xs\nxs : List \u03b1\n\u22a2 sorry = List.take (n\u271d + 1) xs ++ List.drop (n\u271d + 1 + m) xs"}, {"line": "\u00b7 cases xs <;> simp [dropSlice, *, Nat.succ_add]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma find?_eq_head?_dropWhile_not :\n    l.find? p = (l.dropWhile (fun x \u21a6 ! (p x))).head? := by\n  induction l\n  case nil => simp\n  case cons head tail hi =>\n    set ph := p head with phh\n    rcases ph with rfl | rfl\n    \u00b7 have phh' : \u00ac(p head = true) := by simp [phh.symm]\n      rw [find?_cons_of_neg phh']\n      rw [dropWhile_cons_of_pos]\n      \u00b7 exact hi\n      \u00b7 simpa using phh\n    \u00b7 rw [find?_cons_of_pos phh.symm, dropWhile_cons_of_neg]\n      \u00b7 simp\n      \u00b7 simpa using phh\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/TakeWhile.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (p : \u03b1 \u2192 Bool)", "{p} {l : List \u03b1}", "(p) (l)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\n\u22a2 List.find? p l = (List.dropWhile (fun x => !p x) l).head?"}, {"line": "induction l", "tactic_state": "case nil\n\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\n\u22a2 List.find? p [] = (List.dropWhile (fun x => !p x) []).head?\n---\ncase cons\n\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : List.find? p tail\u271d = (List.dropWhile (fun x => !p x) tail\u271d).head?\n\u22a2 List.find? p (head\u271d :: tail\u271d) = (List.dropWhile (fun x => !p x) (head\u271d :: tail\u271d)).head?"}, {"line": "case nil => simp", "tactic_state": "case cons\n\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : List.find? p tail\u271d = (List.dropWhile (fun x => !p x) tail\u271d).head?\n\u22a2 List.find? p (head\u271d :: tail\u271d) = (List.dropWhile (fun x => !p x) (head\u271d :: tail\u271d)).head?"}, {"line": "case cons head tail hi =>\n    set ph := p head with phh\n    rcases ph with rfl | rfl\n    \u00b7 have phh' : \u00ac(p head = true) := by simp [phh.symm]\n      rw [find?_cons_of_neg phh']\n      rw [dropWhile_cons_of_pos]\n      \u00b7 exact hi\n      \u00b7 simpa using phh\n    \u00b7 rw [find?_cons_of_pos phh.symm, dropWhile_cons_of_neg]\n      \u00b7 simp\n      \u00b7 simpa using phh", "tactic_state": "No Goals!"}]}
{"declaration": "lemma find?_not_eq_head?_dropWhile :\n    l.find? (fun x \u21a6 ! (p x)) = (l.dropWhile p).head? := by\n  convert l.find?_eq_head?_dropWhile_not ?_\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/TakeWhile.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (p : \u03b1 \u2192 Bool)", "{p} {l : List \u03b1}", "(p) (l)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\n\u22a2 List.find? (fun x => !p x) l = (List.dropWhile p l).head?"}, {"line": "convert l.find?_eq_head?_dropWhile_not ?_", "tactic_state": "case h.e'_3.h.e'_2.h.e'_2.h\n\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nx\u271d : \u03b1\n\u22a2 p x\u271d = !!p x\u271d"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma find?_not_eq_head_dropWhile (h : \u2203 x \u2208 l, \u00acp x) :\n    l.find? (fun x \u21a6 ! (p x)) = some ((l.dropWhile p).head (by simpa using h)) := by\n  convert l.find?_eq_head_dropWhile_not ?_\n  \u00b7 simp\n  \u00b7 simpa using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/TakeWhile.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (p : \u03b1 \u2192 Bool)", "{p} {l : List \u03b1}", "(p) (l)", "{p} {l}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nh : \u2203 x \u2208 l, \u00acp x = true\n\u22a2 List.find? (fun x => !p x) l = some ((List.dropWhile p l).head \u22ef)"}, {"line": "convert l.find?_eq_head_dropWhile_not ?_", "tactic_state": "case h.e'_3.h.e'_2.h.e'_2.h.e'_2.h\n\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nh : \u2203 x \u2208 l, \u00acp x = true\nx\u271d : \u03b1\n\u22a2 p x\u271d = !!p x\u271d\n---\ncase convert_2\n\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nh : \u2203 x \u2208 l, \u00acp x = true\n\u22a2 \u2203 x \u2208 l, (!p x) = true"}, {"line": "\u00b7 simp", "tactic_state": "case convert_2\n\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nh : \u2203 x \u2208 l, \u00acp x = true\n\u22a2 \u2203 x \u2208 l, (!p x) = true"}, {"line": "\u00b7 simpa using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem revzip_swap (l : List \u03b1) : (revzip l).map Prod.swap = revzip l.reverse := by simp [revzip]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Zip.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type u} {\u03b2 \u03b3 \u03b4 \u03b5 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_5\nrevzip : x\u271d\nl : List \u03b1\n\u22a2 sorry = sorry"}, {"line": "simp [revzip]", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_5\nrevzip : x\u271d\nl : List \u03b1\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem keys_insert {a} {b : \u03b2 a} (s : AList \u03b2) : (insert a b s).keys = a :: s.keys.erase a := by\n  simp [insert, keys, keys_kerase]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/AList.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\na : \u03b1\nb : \u03b2 a\ns : AList \u03b2\n\u22a2 sorry = a :: s.keys.erase a"}, {"line": "simp [insert, keys, keys_kerase]", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\na : \u03b1\nb : \u03b2 a\ns : AList \u03b2\n\u22a2 sorry () = a :: s.keys.erase a"}]}
{"declaration": "theorem mk_cons_eq_insert (c : Sigma \u03b2) (l : List (Sigma \u03b2)) (h : (c :: l).NodupKeys) :\n    (\u27e8c :: l, h\u27e9 : AList \u03b2) = insert c.1 c.2 \u27e8l, nodupKeys_of_nodupKeys_cons h\u27e9 := by\n  simpa [insert] using (kerase_of_not_mem_keys <| not_mem_keys_of_nodupKeys_cons h).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/AList.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nc : Sigma \u03b2\nl : List (Sigma \u03b2)\nh : (c :: l).NodupKeys\n\u22a2 { entries := c :: l, nodupKeys := h } = sorry"}, {"line": "simpa [insert] using (kerase_of_not_mem_keys <| not_mem_keys_of_nodupKeys_cons h).symm", "tactic_state": "No Goals!"}]}
{"declaration": "example (l : AList \u03b2) : True := by induction l <;> trivial\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/AList.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nl : AList \u03b2\n\u22a2 True"}, {"line": "induction l <;> trivial", "tactic_state": "No Goals!"}]}
{"declaration": "theorem perm_union {s\u2081 s\u2082 s\u2083 s\u2084 : AList \u03b2} (p\u2081\u2082 : s\u2081.entries ~ s\u2082.entries)\n    (p\u2083\u2084 : s\u2083.entries ~ s\u2084.entries) : (s\u2081 \u222a s\u2083).entries ~ (s\u2082 \u222a s\u2084).entries := by\n  simp [p\u2081\u2082.kunion s\u2083.nodupKeys p\u2083\u2084]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/AList.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 s\u2083 s\u2084 : AList \u03b2\np\u2081\u2082 : s\u2081.entries.Perm s\u2082.entries\np\u2083\u2084 : s\u2083.entries.Perm s\u2084.entries\n\u22a2 (s\u2081 \u222a s\u2083).entries.Perm (s\u2082 \u222a s\u2084).entries"}, {"line": "simp [p\u2081\u2082.kunion s\u2083.nodupKeys p\u2083\u2084]", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 s\u2083 s\u2084 : AList \u03b2\np\u2081\u2082 : s\u2081.entries.Perm s\u2082.entries\np\u2083\u2084 : s\u2083.entries.Perm s\u2084.entries\n\u22a2 (s\u2081.entries.kunion s\u2083.entries).Perm (s\u2082.entries.kunion s\u2084.entries)"}]}
{"declaration": "theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq \u03b1]\n    {a b : \u03b1} {l : List \u03b1} (h : a \u2208 b :: l) : a = b \u2228 a \u2260 b \u2227 a \u2208 l := by\n  by_cases hab : a = b\n  \u00b7 exact Or.inl hab\n  \u00b7 exact ((List.mem_cons.1 h).elim Or.inl (fun h => Or.inr \u27e8hab, h\u27e9))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nl : List \u03b1\nh : a \u2208 b :: l\n\u22a2 a = b \u2228 a \u2260 b \u2227 a \u2208 l"}, {"line": "by_cases hab : a = b", "tactic_state": "case pos\n\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nl : List \u03b1\nh : a \u2208 b :: l\nhab : a = b\n\u22a2 a = b \u2228 a \u2260 b \u2227 a \u2208 l\n---\ncase neg\n\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nl : List \u03b1\nh : a \u2208 b :: l\nhab : \u00aca = b\n\u22a2 a = b \u2228 a \u2260 b \u2227 a \u2208 l"}, {"line": "\u00b7 exact Or.inl hab", "tactic_state": "case neg\n\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nl : List \u03b1\nh : a \u2208 b :: l\nhab : \u00aca = b\n\u22a2 a = b \u2228 a \u2260 b \u2227 a \u2208 l"}, {"line": "\u00b7 exact ((List.mem_cons.1 h).elim Or.inl (fun h => Or.inr \u27e8hab, h\u27e9))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem head?_flatten_replicate {n : \u2115} (h : n \u2260 0) (l : List \u03b1) :\n    (List.replicate n l).flatten.head? = l.head? := by\n  obtain \u27e8n, rfl\u27e9 := Nat.exists_eq_succ_of_ne_zero h\n  induction l <;> simp [replicate]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nn : \u2115\nh : n \u2260 0\nl : List \u03b1\n\u22a2 (List.replicate n l).flatten.head? = l.head?"}, {"line": "obtain \u27e8n, rfl\u27e9 := Nat.exists_eq_succ_of_ne_zero h", "tactic_state": "case intro\n\u03b1 : Type u\nl : List \u03b1\nn : \u2115\nh : n.succ \u2260 0\n\u22a2 (List.replicate n.succ l).flatten.head? = l.head?"}, {"line": "induction l <;> simp [replicate]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_pure (x y : \u03b1) : x \u2208 (pure y : List \u03b1) \u2194 x = y := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\n\u22a2 x \u2208 pure y \u2194 x = y"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem getLast_append_singleton {a : \u03b1} (l : List \u03b1) :\n    getLast (l ++ [a]) (append_ne_nil_of_right_ne_nil l (cons_ne_nil a _)) = a := by\n  simp [getLast_append]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_2\ngetLast : x\u271d\na : \u03b1\nl : List \u03b1\n\u22a2 sorry = a"}, {"line": "simp [getLast_append]", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_2\ngetLast : x\u271d\na : \u03b1\nl : List \u03b1\n\u22a2 sorry () = a"}]}
{"declaration": "theorem getLast_concat' {a : \u03b1} (l : List \u03b1) : getLast (concat l a) (by simp) = a := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_2\ngetLast : x\u271d\na : \u03b1\nl : List \u03b1\n\u22a2 sorry = a"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_2\ngetLast : x\u271d\na : \u03b1\nl : List \u03b1\n\u22a2 sorry () = a"}]}
{"declaration": "theorem head!_eq_head? [Inhabited \u03b1] (l : List \u03b1) : head! l = (head? l).iget := by cases l <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d\u00b9 : Sort u_2\nhead! : x\u271d\u00b9\nx\u271d : Sort u_3\nhead? : x\u271d\ninst\u271d : Inhabited \u03b1\nl : List \u03b1\n\u22a2 sorry = sorry"}, {"line": "cases l <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem head!_append [Inhabited \u03b1] (t : List \u03b1) {s : List \u03b1} (h : s \u2260 []) :\n    head! (s ++ t) = head! s := by\n  induction s\n  \u00b7 contradiction\n  \u00b7 rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_2\nhead! : x\u271d\ninst\u271d : Inhabited \u03b1\nt s : List \u03b1\nh : s \u2260 []\n\u22a2 sorry = sorry"}, {"line": "induction s", "tactic_state": "case nil\n\u03b1 : Type u\nx\u271d : Sort u_2\nhead! : x\u271d\ninst\u271d : Inhabited \u03b1\nt : List \u03b1\nh : [] \u2260 []\n\u22a2 sorry = sorry\n---\ncase cons\n\u03b1 : Type u\nx\u271d : Sort u_2\nhead! : x\u271d\ninst\u271d : Inhabited \u03b1\nt : List \u03b1\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : \u2200 (h : tail\u271d \u2260 []), sorry = sorry\nh : head\u271d :: tail\u271d \u2260 []\n\u22a2 sorry = sorry"}, {"line": "\u00b7 contradiction", "tactic_state": "case cons\n\u03b1 : Type u\nx\u271d : Sort u_2\nhead! : x\u271d\ninst\u271d : Inhabited \u03b1\nt : List \u03b1\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : \u2200 (h : tail\u271d \u2260 []), sorry = sorry\nh : head\u271d :: tail\u271d \u2260 []\n\u22a2 sorry = sorry"}, {"line": "\u00b7 rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_head?_append_of_mem_head? {s t : List \u03b1} {x : \u03b1} (h : x \u2208 s.head?) :\n    x \u2208 (s ++ t).head? := by\n  cases s\n  \u00b7 contradiction\n  \u00b7 exact h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns t : List \u03b1\nx : \u03b1\nh : x \u2208 s.head?\n\u22a2 x \u2208 (s ++ t).head?"}, {"line": "cases s", "tactic_state": "case nil\n\u03b1 : Type u\nt : List \u03b1\nx : \u03b1\nh : x \u2208 [].head?\n\u22a2 x \u2208 ([] ++ t).head?\n---\ncase cons\n\u03b1 : Type u\nt : List \u03b1\nx head\u271d : \u03b1\ntail\u271d : List \u03b1\nh : x \u2208 (head\u271d :: tail\u271d).head?\n\u22a2 x \u2208 (head\u271d :: tail\u271d ++ t).head?"}, {"line": "\u00b7 contradiction", "tactic_state": "case cons\n\u03b1 : Type u\nt : List \u03b1\nx head\u271d : \u03b1\ntail\u271d : List \u03b1\nh : x \u2208 (head\u271d :: tail\u271d).head?\n\u22a2 x \u2208 (head\u271d :: tail\u271d ++ t).head?"}, {"line": "\u00b7 exact h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tail_append_singleton_of_ne_nil {a : \u03b1} {l : List \u03b1} (h : l \u2260 nil) :\n    tail (l ++ [a]) = tail l ++ [a] := by\n  induction l\n  \u00b7 contradiction\n  \u00b7 rw [tail, cons_append, tail]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nnil : List \u03b1\nx\u271d : Sort u_2\ntail : x\u271d\na : \u03b1\nl : List \u03b1\nh : l \u2260 nil\n\u22a2 sorry = sorry ++ [a]"}, {"line": "induction l", "tactic_state": "case nil\n\u03b1 : Type u\nnil : List \u03b1\nx\u271d : Sort u_2\ntail : x\u271d\na : \u03b1\nh : [] \u2260 nil\n\u22a2 sorry = sorry ++ [a]\n---\ncase cons\n\u03b1 : Type u\nnil : List \u03b1\nx\u271d : Sort u_2\ntail : x\u271d\na head\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : tail\u271d \u2260 nil \u2192 sorry = sorry ++ [a]\nh : head\u271d :: tail\u271d \u2260 nil\n\u22a2 sorry = sorry ++ [a]"}, {"line": "\u00b7 contradiction", "tactic_state": "case cons\n\u03b1 : Type u\nnil : List \u03b1\nx\u271d : Sort u_2\ntail : x\u271d\na head\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : tail\u271d \u2260 nil \u2192 sorry = sorry ++ [a]\nh : head\u271d :: tail\u271d \u2260 nil\n\u22a2 sorry = sorry ++ [a]"}, {"line": "\u00b7 rw [tail, cons_append, tail]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem get_eq_getElem? (l : List \u03b1) (i : Fin l.length) :\n    l.get i = l[i]?.get (by simp [getElem?_eq_getElem]) := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl : List \u03b1\ni : Fin l.length\n\u22a2 l.get i = l[i]?.get \u22ef"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem get_tail (l : List \u03b1) (i) (h : i < l.tail.length)\n    (h' : i + 1 < l.length := (by simp only [length_tail] at h; omega)) :\n    l.tail.get \u27e8i, h\u27e9 = l.get \u27e8i + 1, h'\u27e9 := by\n  cases l <;> [cases h; rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl : List \u03b1\ni : \u2115\nh : i < l.tail.length\nh' : optParam (i + 1 < l.length) \u22ef\n\u22a2 l.tail.get \u27e8i, h\u27e9 = l.get \u27e8i + 1, h'\u27e9"}, {"line": "cases l <;> [cases h; rfl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem idxOf_get [DecidableEq \u03b1] {a : \u03b1} {l : List \u03b1} (h) : get l \u27e8idxOf a l, h\u27e9 = a := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nh : ?m.312\n\u22a2 sorry = a"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nh : ?m.312\n\u22a2 sorry () = a"}]}
{"declaration": "theorem get_reverse' (l : List \u03b1) (n) (hn') :\n    l.reverse.get n = l.get \u27e8l.length - 1 - n, hn'\u27e9 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nn : Fin l.reverse.length\nhn' : l.length - 1 - \u2191n < l.length\n\u22a2 l.reverse.get n = l.get \u27e8l.length - 1 - \u2191n, hn'\u27e9"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem getElem_set_of_ne {l : List \u03b1} {i j : \u2115} (h : i \u2260 j) (a : \u03b1)\n    (hj : j < (l.set i a).length) :\n    (l.set i a)[j] = l[j]'(by simpa using hj) := by\n  rw [\u2190 Option.some_inj]\n  rw [\u2190 List.getElem?_eq_getElem]\n  rw [List.getElem?_set_ne h]\n  rw [List.getElem?_eq_getElem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\ni j : \u2115\nh : i \u2260 j\na : \u03b1\nhj : j < (l.set i a).length\n\u22a2 (l.set i a)[j] = l[j]"}, {"line": "rw [\u2190 Option.some_inj]", "tactic_state": "\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\ni j : \u2115\nh : i \u2260 j\na : \u03b1\nhj : j < (l.set i a).length\n\u22a2 some (l.set i a)[j] = some l[j]"}, {"line": "rw [\u2190 List.getElem?_eq_getElem]", "tactic_state": "\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\ni j : \u2115\nh : i \u2260 j\na : \u03b1\nhj : j < (l.set i a).length\n\u22a2 (l.set i a)[j]? = some l[j]"}, {"line": "rw [List.getElem?_set_ne h]", "tactic_state": "\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\ni j : \u2115\nh : i \u2260 j\na : \u03b1\nhj : j < (l.set i a).length\n\u22a2 l[j]? = some l[j]"}, {"line": "rw [List.getElem?_eq_getElem]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_nil_or_concat' (l : List \u03b1) : l = [] \u2228 \u2203 L b, l = L ++ [b] := by\n  simpa using l.eq_nil_or_concat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\n\u22a2 l = [] \u2228 \u2203 L b, l = L ++ [b]"}, {"line": "simpa using l.eq_nil_or_concat", "tactic_state": "No Goals!"}]}
{"declaration": "theorem foldl_concat\n    (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (b : \u03b2) (x : \u03b1) (xs : List \u03b1) :\n    List.foldl f b (xs ++ [x]) = f (List.foldl f b xs) x := by\n  simp only [List.foldl_append]\n  simp only [List.foldl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nb : \u03b2\nx : \u03b1\nxs : List \u03b1\n\u22a2 List.foldl f b (xs ++ [x]) = f (List.foldl f b xs) x"}, {"line": "simp only [List.foldl_append]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nb : \u03b2\nx : \u03b1\nxs : List \u03b1\n\u22a2 List.foldl f (List.foldl f b xs) [x] = f (List.foldl f b xs) x"}, {"line": "simp only [List.foldl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem foldr_concat\n    (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b : \u03b2) (x : \u03b1) (xs : List \u03b1) :\n    List.foldr f b (xs ++ [x]) = (List.foldr f (f x b) xs) := by\n  simp only [List.foldr_append]\n  simp only [List.foldr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nb : \u03b2\nx : \u03b1\nxs : List \u03b1\n\u22a2 List.foldr f b (xs ++ [x]) = List.foldr f (f x b) xs"}, {"line": "simp only [List.foldr_append]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nb : \u03b2\nx : \u03b1\nxs : List \u03b1\n\u22a2 List.foldr f (List.foldr f b [x]) xs = List.foldr f (f x b) xs"}, {"line": "simp only [List.foldr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reverse_foldl {l : List \u03b1} : reverse (foldl (fun t h => h :: t) [] l) = l := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nreverse : x\u271d\nl : List \u03b1\n\u22a2 sorry = l"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nreverse : x\u271d\nl : List \u03b1\n\u22a2 sorry () = l"}]}
{"declaration": "theorem foldr_hom\u2082 (l : List \u03b9) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (op\u2081 : \u03b9 \u2192 \u03b1 \u2192 \u03b1) (op\u2082 : \u03b9 \u2192 \u03b2 \u2192 \u03b2)\n    (op\u2083 : \u03b9 \u2192 \u03b3 \u2192 \u03b3) (a : \u03b1) (b : \u03b2) (h : \u2200 a b i, f (op\u2081 i a) (op\u2082 i b) = op\u2083 i (f a b)) :\n    foldr op\u2083 (f a b) l = f (foldr op\u2081 a l) (foldr op\u2082 b l) := by\n  revert a\n  induction l <;> intros <;> [rfl; simp only [*, foldr]]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nfoldr : x\u271d\nl : List \u03b9\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nop\u2081 : \u03b9 \u2192 \u03b1 \u2192 \u03b1\nop\u2082 : \u03b9 \u2192 \u03b2 \u2192 \u03b2\nop\u2083 : \u03b9 \u2192 \u03b3 \u2192 \u03b3\na : \u03b1\nb : \u03b2\nh : \u2200 (a : \u03b1) (b : \u03b2) (i : \u03b9), f (op\u2081 i a) (op\u2082 i b) = op\u2083 i (f a b)\n\u22a2 sorry = f sorry sorry"}, {"line": "revert a", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nfoldr : x\u271d\nl : List \u03b9\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nop\u2081 : \u03b9 \u2192 \u03b1 \u2192 \u03b1\nop\u2082 : \u03b9 \u2192 \u03b2 \u2192 \u03b2\nop\u2083 : \u03b9 \u2192 \u03b3 \u2192 \u03b3\nb : \u03b2\nh : \u2200 (a : \u03b1) (b : \u03b2) (i : \u03b9), f (op\u2081 i a) (op\u2082 i b) = op\u2083 i (f a b)\n\u22a2 \u03b1 \u2192 sorry = f sorry sorry"}, {"line": "induction l <;> intros <;> [rfl; simp only [*, foldr]]", "tactic_state": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nfoldr : x\u271d\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nop\u2081 : \u03b9 \u2192 \u03b1 \u2192 \u03b1\nop\u2082 : \u03b9 \u2192 \u03b2 \u2192 \u03b2\nop\u2083 : \u03b9 \u2192 \u03b3 \u2192 \u03b3\nb : \u03b2\nh : \u2200 (a : \u03b1) (b : \u03b2) (i : \u03b9), f (op\u2081 i a) (op\u2082 i b) = op\u2083 i (f a b)\na\u271d : \u03b1\n\u22a2 sorry = f sorry sorry\n---\ncase cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nfoldr : x\u271d\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nop\u2081 : \u03b9 \u2192 \u03b1 \u2192 \u03b1\nop\u2082 : \u03b9 \u2192 \u03b2 \u2192 \u03b2\nop\u2083 : \u03b9 \u2192 \u03b3 \u2192 \u03b3\nb : \u03b2\nh : \u2200 (a : \u03b1) (b : \u03b2) (i : \u03b9), f (op\u2081 i a) (op\u2082 i b) = op\u2083 i (f a b)\nhead\u271d : \u03b9\ntail\u271d : List \u03b9\ntail_ih\u271d : \u03b1 \u2192 sorry = f sorry sorry\na\u271d : \u03b1\n\u22a2 sorry = f sorry sorry"}]}
{"declaration": "theorem length_eq_length_filter_add {l : List (\u03b1)} (f : \u03b1 \u2192 Bool) :\n    l.length = (l.filter f).length + (l.filter (! f \u00b7)).length := by\n  simp_rw [\u2190 List.countP_eq_length_filter, l.length_eq_countP_add_countP f, Bool.not_eq_true,\n    Bool.decide_eq_false]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}", "[DecidableEq \u03b1]", "{f : \u03b1 \u2192 \u03b1 \u2192 \u03b1}", "{f : \u03b1 \u2192 \u03b2 \u2192 \u03b1}", "(hf : \u2200 a b c, f (f a b) c = f (f a c) b)", "{f : \u03b1 \u2192 \u03b2 \u2192 \u03b2}", "{op : \u03b1 \u2192 \u03b1 \u2192 \u03b1} [ha : Std.Associative op]", "[hc : Std.Commutative op]", "{m : Type v \u2192 Type w} [Monad m]", "[LawfulMonad m]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nf : \u03b1 \u2192 Bool\n\u22a2 l.length = (List.filter f l).length + (List.filter (fun x => !f x) l).length"}, {"line": "simp_rw [\u2190 List.countP_eq_length_filter, l.length_eq_countP_add_countP f, Bool.not_eq_true,\n    Bool.decide_eq_false]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem filterMap_eq_flatMap_toList (f : \u03b1 \u2192 Option \u03b2) (l : List \u03b1) :\n    l.filterMap f = l.flatMap fun a \u21a6 (f a).toList := by\n  induction l with | nil => ?_ | cons a l ih => ?_ <;> simp [filterMap_cons]\n  rcases f a <;> simp [ih]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}", "[DecidableEq \u03b1]", "{f : \u03b1 \u2192 \u03b1 \u2192 \u03b1}", "{f : \u03b1 \u2192 \u03b2 \u2192 \u03b1}", "(hf : \u2200 a b c, f (f a b) c = f (f a c) b)", "{f : \u03b1 \u2192 \u03b2 \u2192 \u03b2}", "{op : \u03b1 \u2192 \u03b1 \u2192 \u03b1} [ha : Std.Associative op]", "[hc : Std.Commutative op]", "{m : Type v \u2192 Type w} [Monad m]", "[LawfulMonad m]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 Option \u03b2\nl : List \u03b1\n\u22a2 List.filterMap f l = List.flatMap (fun a => (f a).toList) l"}, {"line": "induction l with | nil => ?_ | cons a l ih => ?_ <;> simp [filterMap_cons]", "tactic_state": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 Option \u03b2\na : \u03b1\nl : List \u03b1\nih : List.filterMap f l = List.flatMap (fun a => (f a).toList) l\n\u22a2 List.filterMap f (a :: l) = (f a).toList ++ List.flatMap (fun a => (f a).toList) l"}, {"line": "rcases f a <;> simp [ih]", "tactic_state": "case cons.none\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 Option \u03b2\na : \u03b1\nl : List \u03b1\nih : List.filterMap f l = List.flatMap (fun a => (f a).toList) l\n\u22a2 List.filterMap f (a :: l) = List.flatMap (fun a => (f a).toList) l\n---\ncase cons.some\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 Option \u03b2\na : \u03b1\nl : List \u03b1\nih : List.filterMap f l = List.flatMap (fun a => (f a).toList) l\nval\u271d : \u03b2\n\u22a2 List.filterMap f (a :: l) = val\u271d :: List.flatMap (fun a => (f a).toList) l"}]}
{"declaration": "theorem filterMap_congr {f g : \u03b1 \u2192 Option \u03b2} {l : List \u03b1}\n    (h : \u2200 x \u2208 l, f x = g x) : l.filterMap f = l.filterMap g := by\n  induction l <;> simp_all [filterMap_cons]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}", "[DecidableEq \u03b1]", "{f : \u03b1 \u2192 \u03b1 \u2192 \u03b1}", "{f : \u03b1 \u2192 \u03b2 \u2192 \u03b1}", "(hf : \u2200 a b c, f (f a b) c = f (f a c) b)", "{f : \u03b1 \u2192 \u03b2 \u2192 \u03b2}", "{op : \u03b1 \u2192 \u03b1 \u2192 \u03b1} [ha : Std.Associative op]", "[hc : Std.Commutative op]", "{m : Type v \u2192 Type w} [Monad m]", "[LawfulMonad m]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 Option \u03b2\nl : List \u03b1\nh : \u2200 x \u2208 l, f x = g x\n\u22a2 List.filterMap f l = List.filterMap g l"}, {"line": "induction l <;> simp_all [filterMap_cons]", "tactic_state": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 Option \u03b2\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : List.filterMap f tail\u271d = List.filterMap g tail\u271d\nh : f head\u271d = g head\u271d \u2227 \u2200 a \u2208 tail\u271d, f a = g a\n\u22a2 List.filterMap f (head\u271d :: tail\u271d) = List.filterMap g (head\u271d :: tail\u271d)"}]}
{"declaration": "theorem filter_true (l : List \u03b1) :\n    filter (fun _ => true) l = l := by induction l <;> simp [*, filter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}", "[DecidableEq \u03b1]", "{f : \u03b1 \u2192 \u03b1 \u2192 \u03b1}", "{f : \u03b1 \u2192 \u03b2 \u2192 \u03b1}", "(hf : \u2200 a b c, f (f a b) c = f (f a c) b)", "{f : \u03b1 \u2192 \u03b2 \u2192 \u03b2}", "{op : \u03b1 \u2192 \u03b1 \u2192 \u03b1} [ha : Std.Associative op]", "[hc : Std.Commutative op]", "{m : Type v \u2192 Type w} [Monad m]", "[LawfulMonad m]", "{p : \u03b1 \u2192 Bool}", "(p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nfilter : x\u271d\nl : List \u03b1\n\u22a2 sorry = l"}, {"line": "induction l <;> simp [*, filter]", "tactic_state": "case nil\n\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nfilter : x\u271d\n\u22a2 sorry () = []\n---\ncase cons\n\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nfilter : x\u271d\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : sorry = tail\u271d\n\u22a2 False"}]}
{"declaration": "theorem map_foldl_erase [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} (finj : Injective f) {l\u2081 l\u2082 : List \u03b1} :\n    map f (foldl List.erase l\u2081 l\u2082) = foldl (fun l a => l.erase (f a)) (map f l\u2081) l\u2082 := by\n  induction l\u2082 generalizing l\u2081 <;> [rfl; simp only [foldl_cons, map_erase finj, *]]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}", "[DecidableEq \u03b1]", "{f : \u03b1 \u2192 \u03b1 \u2192 \u03b1}", "{f : \u03b1 \u2192 \u03b2 \u2192 \u03b1}", "(hf : \u2200 a b c, f (f a b) c = f (f a c) b)", "{f : \u03b1 \u2192 \u03b2 \u2192 \u03b2}", "{op : \u03b1 \u2192 \u03b1 \u2192 \u03b1} [ha : Std.Associative op]", "[hc : Std.Commutative op]", "{m : Type v \u2192 Type w} [Monad m]", "[LawfulMonad m]", "{p : \u03b1 \u2192 Bool}", "(p)", "{p : \u03b1 \u2192 Bool}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\nx\u271d\u00b9 : Sort u_2\nmap : x\u271d\u00b9\nx\u271d : Sort u_3\nfoldl : x\u271d\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nfinj : Injective f\nl\u2081 l\u2082 : List \u03b1\n\u22a2 sorry = sorry"}, {"line": "induction l\u2082 generalizing l\u2081 <;> [rfl; simp only [foldl_cons, map_erase finj, *]]", "tactic_state": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\nx\u271d\u00b9 : Sort u_2\nmap : x\u271d\u00b9\nx\u271d : Sort u_3\nfoldl : x\u271d\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nfinj : Injective f\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : \u2200 {l\u2081 : List \u03b1}, sorry = sorry\nl\u2081 : List \u03b1\n\u22a2 sorry = sorry"}]}
{"declaration": "theorem get_attach (l : List \u03b1) (i) :\n    (l.attach.get i).1 = l.get \u27e8i, length_attach (l := l) \u25b8 i.2\u27e9 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}", "[DecidableEq \u03b1]", "{f : \u03b1 \u2192 \u03b1 \u2192 \u03b1}", "{f : \u03b1 \u2192 \u03b2 \u2192 \u03b1}", "(hf : \u2200 a b c, f (f a b) c = f (f a c) b)", "{f : \u03b1 \u2192 \u03b2 \u2192 \u03b2}", "{op : \u03b1 \u2192 \u03b1 \u2192 \u03b1} [ha : Std.Associative op]", "[hc : Std.Commutative op]", "{m : Type v \u2192 Type w} [Monad m]", "[LawfulMonad m]", "{p : \u03b1 \u2192 Bool}", "(p)", "{p : \u03b1 \u2192 Bool}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]", "(p : \u03b1 \u2192 Prop) [DecidablePred p] (l : List \u03b1)", "{p q : \u03b1 \u2192 Prop} {l : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nlength_attach : x\u271d\nl : List \u03b1\ni : Fin l.attach.length\n\u22a2 \u2191(l.attach.get i) = l.get \u27e8\u2191i, \u22ef\u27e9"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma left_le_of_mem_range' {a b s x : \u2115}\n    (hx : x \u2208 List.range' a b s) : a \u2264 x := by\n  obtain \u27e8i, _, rfl\u27e9 := List.mem_range'.mp hx\n  exact le_add_right a (s * i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Basic.lean", "context": {"open": ["Function", "Nat hiding one_pos"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {l\u2081 l\u2082 : List \u03b1}", "[DecidableEq \u03b1]", "{f : \u03b1 \u2192 \u03b1 \u2192 \u03b1}", "{f : \u03b1 \u2192 \u03b2 \u2192 \u03b1}", "(hf : \u2200 a b c, f (f a b) c = f (f a c) b)", "{f : \u03b1 \u2192 \u03b2 \u2192 \u03b2}", "{op : \u03b1 \u2192 \u03b1 \u2192 \u03b1} [ha : Std.Associative op]", "[hc : Std.Commutative op]", "{m : Type v \u2192 Type w} [Monad m]", "[LawfulMonad m]", "{p : \u03b1 \u2192 Bool}", "(p)", "{p : \u03b1 \u2192 Bool}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]", "(p : \u03b1 \u2192 Prop) [DecidablePred p] (l : List \u03b1)", "{p q : \u03b1 \u2192 Prop} {l : List \u03b1}", "[BEq \u03b1] [LawfulBEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b s x : \u2115\nhx : x \u2208 List.range' a b s\n\u22a2 a \u2264 x"}, {"line": "obtain \u27e8i, _, rfl\u27e9 := List.mem_range'.mp hx", "tactic_state": "case intro.intro\na b s i : \u2115\nleft\u271d : i < b\nhx : a + s * i \u2208 List.range' a b s\n\u22a2 a \u2264 a + s * i"}, {"line": "exact le_add_right a (s * i)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem chain_append_singleton_iff_forall\u2082 :\n    Chain R a (l ++ [b]) \u2194 Forall\u2082 R (a :: l) (l ++ [b]) := by simp [chain_iff_forall\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Chain.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {R r : \u03b1 \u2192 \u03b1 \u2192 Prop} {l l\u2081 l\u2082 : List \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nChain : x\u271d\u00b9\nx\u271d : Sort u_2\nForall\u2082 : x\u271d\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [chain_iff_forall\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem chain_map (f : \u03b2 \u2192 \u03b1) {b : \u03b2} {l : List \u03b2} :\n    Chain R (f b) (map f l) \u2194 Chain (fun a b : \u03b2 => R (f a) (f b)) b l := by\n  induction l generalizing b <;> simp only [map, Chain.nil, chain_cons, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Chain.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {R r : \u03b1 \u2192 \u03b1 \u2192 Prop} {l l\u2081 l\u2082 : List \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nx\u271d : Sort u_1\nChain : x\u271d\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\nl : List \u03b2\n\u22a2 sorry \u2194 sorry"}, {"line": "induction l generalizing b <;> simp only [map, Chain.nil, chain_cons, *]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem chain_pmap_of_chain {S : \u03b2 \u2192 \u03b2 \u2192 Prop} {p : \u03b1 \u2192 Prop} {f : \u2200 a, p a \u2192 \u03b2}\n    (H : \u2200 a b ha hb, R a b \u2192 S (f a ha) (f b hb)) {a : \u03b1} {l : List \u03b1} (hl\u2081 : Chain R a l)\n    (ha : p a) (hl\u2082 : \u2200 a \u2208 l, p a) : Chain S (f a ha) (List.pmap f l hl\u2082) := by\n  induction' l with lh lt l_ih generalizing a\n  \u00b7 simp\n  \u00b7 simp [H _ _ _ _ (rel_of_chain_cons hl\u2081), l_ih (chain_of_chain_cons hl\u2081)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Chain.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {R r : \u03b1 \u2192 \u03b1 \u2192 Prop} {l l\u2081 l\u2082 : List \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_1\nChain : x\u271d\nS : \u03b2 \u2192 \u03b2 \u2192 Prop\np : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 p a \u2192 \u03b2\nH : \u2200 (a b : \u03b1) (ha : p a) (hb : p b), R a b \u2192 S (f a ha) (f b hb)\na : \u03b1\nl : List \u03b1\nhl\u2081 : sorry\nha : p a\nhl\u2082 : \u2200 a \u2208 l, p a\n\u22a2 sorry"}, {"line": "induction' l with lh lt l_ih generalizing a", "tactic_state": "case nil\n\u03b1 : Type u\n\u03b2 : Type v\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_1\nChain : x\u271d\nS : \u03b2 \u2192 \u03b2 \u2192 Prop\np : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 p a \u2192 \u03b2\nH : \u2200 (a b : \u03b1) (ha : p a) (hb : p b), R a b \u2192 S (f a ha) (f b hb)\nhl\u2081 : sorry\na : \u03b1\nha : p a\nhl\u2082 : \u2200 a \u2208 [], p a\n\u22a2 sorry\n---\ncase cons\n\u03b1 : Type u\n\u03b2 : Type v\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_1\nChain : x\u271d\nS : \u03b2 \u2192 \u03b2 \u2192 Prop\np : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 p a \u2192 \u03b2\nH : \u2200 (a b : \u03b1) (ha : p a) (hb : p b), R a b \u2192 S (f a ha) (f b hb)\nhl\u2081 : sorry\nlh : \u03b1\nlt : List \u03b1\nl_ih : {a : \u03b1} \u2192 p a \u2192 (\u2200 a \u2208 lt, p a) \u2192 sorry\na : \u03b1\nha : p a\nhl\u2082 : \u2200 a \u2208 lh :: lt, p a\n\u22a2 sorry"}, {"line": "\u00b7 simp", "tactic_state": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_1\nChain : x\u271d\nS : \u03b2 \u2192 \u03b2 \u2192 Prop\np : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 p a \u2192 \u03b2\nH : \u2200 (a b : \u03b1) (ha : p a) (hb : p b), R a b \u2192 S (f a ha) (f b hb)\nhl\u2081 : sorry\nlh : \u03b1\nlt : List \u03b1\nl_ih : {a : \u03b1} \u2192 p a \u2192 (\u2200 a \u2208 lt, p a) \u2192 sorry\na : \u03b1\nha : p a\nhl\u2082 : \u2200 a \u2208 lh :: lt, p a\n\u22a2 sorry"}, {"line": "\u00b7 simp [H _ _ _ _ (rel_of_chain_cons hl\u2081), l_ih (chain_of_chain_cons hl\u2081)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem chain_of_chain_pmap {S : \u03b2 \u2192 \u03b2 \u2192 Prop} {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) {l : List \u03b1}\n    (hl\u2081 : \u2200 a \u2208 l, p a) {a : \u03b1} (ha : p a) (hl\u2082 : Chain S (f a ha) (List.pmap f l hl\u2081))\n    (H : \u2200 a b ha hb, S (f a ha) (f b hb) \u2192 R a b) : Chain R a l := by\n  induction' l with lh lt l_ih generalizing a\n  \u00b7 simp\n  \u00b7 simp [H _ _ _ _ (rel_of_chain_cons hl\u2082), l_ih _ _ (chain_of_chain_cons hl\u2082)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Chain.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {R r : \u03b1 \u2192 \u03b1 \u2192 Prop} {l l\u2081 l\u2082 : List \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_1\nChain : x\u271d\nS : \u03b2 \u2192 \u03b2 \u2192 Prop\np : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 p a \u2192 \u03b2\nl : List \u03b1\nhl\u2081 : \u2200 a \u2208 l, p a\na : \u03b1\nha : p a\nhl\u2082 : sorry\nH : \u2200 (a b : \u03b1) (ha : p a) (hb : p b), S (f a ha) (f b hb) \u2192 R a b\n\u22a2 sorry"}, {"line": "induction' l with lh lt l_ih generalizing a", "tactic_state": "case nil\n\u03b1 : Type u\n\u03b2 : Type v\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_1\nChain : x\u271d\nS : \u03b2 \u2192 \u03b2 \u2192 Prop\np : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 p a \u2192 \u03b2\nhl\u2082 : sorry\nH : \u2200 (a b : \u03b1) (ha : p a) (hb : p b), S (f a ha) (f b hb) \u2192 R a b\nhl\u2081 : \u2200 a \u2208 [], p a\na : \u03b1\nha : p a\n\u22a2 sorry\n---\ncase cons\n\u03b1 : Type u\n\u03b2 : Type v\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_1\nChain : x\u271d\nS : \u03b2 \u2192 \u03b2 \u2192 Prop\np : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 p a \u2192 \u03b2\nhl\u2082 : sorry\nH : \u2200 (a b : \u03b1) (ha : p a) (hb : p b), S (f a ha) (f b hb) \u2192 R a b\nlh : \u03b1\nlt : List \u03b1\nl_ih : (\u2200 a \u2208 lt, p a) \u2192 {a : \u03b1} \u2192 p a \u2192 sorry\nhl\u2081 : \u2200 a \u2208 lh :: lt, p a\na : \u03b1\nha : p a\n\u22a2 sorry"}, {"line": "\u00b7 simp", "tactic_state": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_1\nChain : x\u271d\nS : \u03b2 \u2192 \u03b2 \u2192 Prop\np : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 p a \u2192 \u03b2\nhl\u2082 : sorry\nH : \u2200 (a b : \u03b1) (ha : p a) (hb : p b), S (f a ha) (f b hb) \u2192 R a b\nlh : \u03b1\nlt : List \u03b1\nl_ih : (\u2200 a \u2208 lt, p a) \u2192 {a : \u03b1} \u2192 p a \u2192 sorry\nhl\u2081 : \u2200 a \u2208 lh :: lt, p a\na : \u03b1\nha : p a\n\u22a2 sorry"}, {"line": "\u00b7 simp [H _ _ _ _ (rel_of_chain_cons hl\u2082), l_ih _ _ (chain_of_chain_cons hl\u2082)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Chain'.imp {S : \u03b1 \u2192 \u03b1 \u2192 Prop} (H : \u2200 a b, R a b \u2192 S a b) {l : List \u03b1} (p : Chain' R l) :\n    Chain' S l := by cases l <;> [trivial; exact Chain.imp H p]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Chain.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {R r : \u03b1 \u2192 \u03b1 \u2192 Prop} {l l\u2081 l\u2082 : List \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_1\nChain' : x\u271d\nS : \u03b1 \u2192 \u03b1 \u2192 Prop\nH : \u2200 (a b : \u03b1), R a b \u2192 S a b\nl : List \u03b1\np : sorry\n\u22a2 sorry"}, {"line": "cases l <;> [trivial; exact Chain.imp H p]", "tactic_state": "case nil\n\u03b1 : Type u\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_1\nChain' : x\u271d\nS : \u03b1 \u2192 \u03b1 \u2192 Prop\nH : \u2200 (a b : \u03b1), R a b \u2192 S a b\np : sorry\n\u22a2 sorry"}]}
{"declaration": "theorem chain'_map (f : \u03b2 \u2192 \u03b1) {l : List \u03b2} :\n    Chain' R (map f l) \u2194 Chain' (fun a b : \u03b2 => R (f a) (f b)) l := by\n  cases l <;> [rfl; exact chain_map _]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Chain.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {R r : \u03b1 \u2192 \u03b1 \u2192 Prop} {l l\u2081 l\u2082 : List \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nx\u271d : Sort u_1\nChain' : x\u271d\nf : \u03b2 \u2192 \u03b1\nl : List \u03b2\n\u22a2 sorry \u2194 sorry"}, {"line": "cases l <;> [rfl; exact chain_map _]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Chain'.chain {\u03b1 : Type*} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} {l : List \u03b1} {v : \u03b1}\n    (hl : l.Chain' R) (hv : (lne : l \u2260 []) \u2192 R v (l.head lne)) : l.Chain R v := by\n  rw [List.chain_iff_get]\n  constructor\n  \u00b7 intro h\n    rw [List.get_mk_zero]\n    apply hv\n  \u00b7 exact List.chain'_iff_get.mp hl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Chain.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {R r : \u03b1 \u2192 \u03b1 \u2192 Prop} {l l\u2081 l\u2082 : List \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\nl : List \u03b1\nv : \u03b1\nhl : List.Chain' R l\nhv : \u2200 (lne : l \u2260 []), R v (l.head lne)\n\u22a2 List.Chain R v l"}, {"line": "rw [List.chain_iff_get]", "tactic_state": "\u03b1 : Type u_1\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\nl : List \u03b1\nv : \u03b1\nhl : List.Chain' R l\nhv : \u2200 (lne : l \u2260 []), R v (l.head lne)\n\u22a2 (\u2200 (h : 0 < l.length), R v (l.get \u27e80, h\u27e9)) \u2227 \u2200 (i : \u2115) (h : i < l.length - 1), R (l.get \u27e8i, \u22ef\u27e9) (l.get \u27e8i + 1, \u22ef\u27e9)"}, {"line": "constructor", "tactic_state": "case left\n\u03b1 : Type u_1\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\nl : List \u03b1\nv : \u03b1\nhl : List.Chain' R l\nhv : \u2200 (lne : l \u2260 []), R v (l.head lne)\n\u22a2 \u2200 (h : 0 < l.length), R v (l.get \u27e80, h\u27e9)\n---\ncase right\n\u03b1 : Type u_1\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\nl : List \u03b1\nv : \u03b1\nhl : List.Chain' R l\nhv : \u2200 (lne : l \u2260 []), R v (l.head lne)\n\u22a2 \u2200 (i : \u2115) (h : i < l.length - 1), R (l.get \u27e8i, \u22ef\u27e9) (l.get \u27e8i + 1, \u22ef\u27e9)"}, {"line": "\u00b7 intro h\n    rw [List.get_mk_zero]\n    apply hv", "tactic_state": "case right\n\u03b1 : Type u_1\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\nl : List \u03b1\nv : \u03b1\nhl : List.Chain' R l\nhv : \u2200 (lne : l \u2260 []), R v (l.head lne)\n\u22a2 \u2200 (i : \u2115) (h : i < l.length - 1), R (l.get \u27e8i, \u22ef\u27e9) (l.get \u27e8i + 1, \u22ef\u27e9)"}, {"line": "\u00b7 exact List.chain'_iff_get.mp hl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nextOr_concat {xs : List \u03b1} {x : \u03b1} (d : \u03b1) (h : x \u2209 xs) : nextOr (xs ++ [x]) x d = d := by\n  induction' xs with z zs IH\n  \u00b7 simp\n  \u00b7 obtain \u27e8hz, hzs\u27e9 := not_or.mp (mt mem_cons.2 h)\n    rw [cons_append]\n    rw [nextOr_cons_of_ne _ _ _ _ hz]\n    rw [IH hzs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Cycle.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nnextOr : x\u271d\nxs : List \u03b1\nx d : \u03b1\nh : x \u2209 xs\n\u22a2 sorry = d"}, {"line": "induction' xs with z zs IH", "tactic_state": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nnextOr : x\u271d\nx d : \u03b1\nh : x \u2209 []\n\u22a2 sorry = d\n---\ncase cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nnextOr : x\u271d\nx d z : \u03b1\nzs : List \u03b1\nIH : x \u2209 zs \u2192 sorry = d\nh : x \u2209 z :: zs\n\u22a2 sorry = d"}, {"line": "\u00b7 simp", "tactic_state": "case cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nnextOr : x\u271d\nx d z : \u03b1\nzs : List \u03b1\nIH : x \u2209 zs \u2192 sorry = d\nh : x \u2209 z :: zs\n\u22a2 sorry = d"}, {"line": "\u00b7 obtain \u27e8hz, hzs\u27e9 := not_or.mp (mt mem_cons.2 h)\n    rw [cons_append]\n    rw [nextOr_cons_of_ne _ _ _ _ hz]\n    rw [IH hzs]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prev_getLast_cons' (y : \u03b1) (hxy : x \u2208 y :: l) (hx : x = y) :\n    prev (y :: l) x hxy = getLast (y :: l) (cons_ne_nil _ _) := by cases l <;> simp [prev, hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Cycle.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1]", "(l : List \u03b1) (x : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx : \u03b1\nx\u271d\u00b9 : Sort u_2\nprev : x\u271d\u00b9\nx\u271d : Sort u_3\ngetLast : x\u271d\ny : \u03b1\nhxy : x \u2208 y :: l\nhx : x = y\n\u22a2 sorry = sorry"}, {"line": "cases l <;> simp [prev, hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prev_cons_cons_of_ne' (y z : \u03b1) (h : x \u2208 y :: z :: l) (hy : x \u2260 y) (hz : x = z) :\n    prev (y :: z :: l) x h = y := by\n  cases l\n  \u00b7 simp [prev, hy, hz]\n  \u00b7 rw [prev, dif_neg hy, if_pos hz]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Cycle.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1]", "(l : List \u03b1) (x : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx : \u03b1\nx\u271d : Sort u_2\nprev : x\u271d\ny z : \u03b1\nh : x \u2208 y :: z :: l\nhy : x \u2260 y\nhz : x = z\n\u22a2 sorry = y"}, {"line": "cases l", "tactic_state": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx : \u03b1\nx\u271d : Sort u_2\nprev : x\u271d\ny z : \u03b1\nhy : x \u2260 y\nhz : x = z\nh : x \u2208 [y, z]\n\u22a2 sorry = y\n---\ncase cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx : \u03b1\nx\u271d : Sort u_2\nprev : x\u271d\ny z : \u03b1\nhy : x \u2260 y\nhz : x = z\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\nh : x \u2208 y :: z :: head\u271d :: tail\u271d\n\u22a2 sorry = y"}, {"line": "\u00b7 simp [prev, hy, hz]", "tactic_state": "case cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx : \u03b1\nx\u271d : Sort u_2\nprev : x\u271d\ny z : \u03b1\nhy : x \u2260 y\nhz : x = z\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\nh : x \u2208 y :: z :: head\u271d :: tail\u271d\n\u22a2 sorry = y"}, {"line": "\u00b7 rw [prev, dif_neg hy, if_pos hz]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prev_ne_cons_cons (y z : \u03b1) (h : x \u2208 y :: z :: l) (hy : x \u2260 y) (hz : x \u2260 z) :\n    prev (y :: z :: l) x h = prev (z :: l) x (by simpa [hy] using h) := by\n  cases l\n  \u00b7 simp [hy, hz] at h\n  \u00b7 rw [prev, dif_neg hy, if_neg hz]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Cycle.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1]", "(l : List \u03b1) (x : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx : \u03b1\nx\u271d : Sort u_2\nprev : x\u271d\ny z : \u03b1\nh : x \u2208 y :: z :: l\nhy : x \u2260 y\nhz : x \u2260 z\n\u22a2 sorry = sorry"}, {"line": "cases l", "tactic_state": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx : \u03b1\nx\u271d : Sort u_2\nprev : x\u271d\ny z : \u03b1\nhy : x \u2260 y\nhz : x \u2260 z\nh : x \u2208 [y, z]\n\u22a2 sorry = sorry\n---\ncase cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx : \u03b1\nx\u271d : Sort u_2\nprev : x\u271d\ny z : \u03b1\nhy : x \u2260 y\nhz : x \u2260 z\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\nh : x \u2208 y :: z :: head\u271d :: tail\u271d\n\u22a2 sorry = sorry"}, {"line": "\u00b7 simp [hy, hz] at h", "tactic_state": "case cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx : \u03b1\nx\u271d : Sort u_2\nprev : x\u271d\ny z : \u03b1\nhy : x \u2260 y\nhz : x \u2260 z\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\nh : x \u2208 y :: z :: head\u271d :: tail\u271d\n\u22a2 sorry = sorry"}, {"line": "\u00b7 rw [prev, dif_neg hy, if_neg hz]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pmap_prev_eq_rotate_length_sub_one (h : Nodup l) :\n    (l.pmap l.prev fun _ h => h) = l.rotate (l.length - 1) := by\n  apply List.ext_getElem\n  \u00b7 simp\n  \u00b7 intro n hn hn'\n    rw [getElem_rotate]\n    rw [getElem_pmap]\n    rw [prev_getElem _ h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Cycle.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1]", "(l : List \u03b1) (x : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d : Sort u_2\nNodup : x\u271d\nh : sorry\n\u22a2 List.pmap l.prev l \u22ef = l.rotate (l.length - 1)"}, {"line": "apply List.ext_getElem", "tactic_state": "case hl\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d : Sort u_2\nNodup : x\u271d\nh : sorry\n\u22a2 (List.pmap l.prev l \u22ef).length = (l.rotate (l.length - 1)).length\n---\ncase h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d : Sort u_2\nNodup : x\u271d\nh : sorry\n\u22a2 \u2200 (i : \u2115) (h\u2081 : i < (List.pmap l.prev l \u22ef).length) (h\u2082 : i < (l.rotate (l.length - 1)).length),\n    (List.pmap l.prev l \u22ef)[i] = (l.rotate (l.length - 1))[i]"}, {"line": "\u00b7 simp", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d : Sort u_2\nNodup : x\u271d\nh : sorry\n\u22a2 \u2200 (i : \u2115) (h\u2081 : i < (List.pmap l.prev l \u22ef).length) (h\u2082 : i < (l.rotate (l.length - 1)).length),\n    (List.pmap l.prev l \u22ef)[i] = (l.rotate (l.length - 1))[i]"}, {"line": "\u00b7 intro n hn hn'\n    rw [getElem_rotate]\n    rw [getElem_pmap]\n    rw [prev_getElem _ h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subsingleton_reverse_iff {s : Cycle \u03b1} : s.reverse.Subsingleton \u2194 s.Subsingleton := by\n  simp [length_subsingleton_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Cycle.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1]", "(l : List \u03b1) (x : \u03b1)", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ns : Cycle \u03b1\n\u22a2 s.reverse.Subsingleton \u2194 s.Subsingleton"}, {"line": "simp [length_subsingleton_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nontrivial_reverse_iff {s : Cycle \u03b1} : s.reverse.Nontrivial \u2194 s.Nontrivial := by\n  simp [Nontrivial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Cycle.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1]", "(l : List \u03b1) (x : \u03b1)", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ns : Cycle \u03b1\n\u22a2 s.reverse.Nontrivial \u2194 s.Nontrivial"}, {"line": "simp [Nontrivial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Chain.nil (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Cycle.Chain r (@nil \u03b1) := by trivial\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Cycle.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1]", "(l : List \u03b1) (x : \u03b1)", "{\u03b1 : Type*}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : DecidableEq \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 Cycle.Chain r \u2191[]"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iterate_eq_iterateTR : @iterate = @iterateTR := by\n  funext \u03b1 f a n\n  exact Eq.symm <| iterateTR_loop_eq f a n []\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Defs.lean", "context": {"open": ["Function Nat"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}", "{m : Type \u2192 Type v} [Monad m]", "{m : Type v \u2192 Type w} [Monad m]", "{m : Type v \u2192 Type w} [Monad m]", "(p : \u03b1 \u2192 Prop) [DecidablePred p] (l : List \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "iterateTR : {\u03b1 : Sort u_7} \u2192 (\u03b1 \u2192 \u03b1) \u2192 \u2115 \u2192 \u03b1 \u2192 \u03b1\n\u22a2 @iterate = iterateTR"}, {"line": "funext \u03b1 f a n", "tactic_state": "case h.h.h.h\niterateTR : {\u03b1 : Sort u_7} \u2192 (\u03b1 \u2192 \u03b1) \u2192 \u2115 \u2192 \u03b1 \u2192 \u03b1\n\u03b1 : Sort u_7\nf : \u03b1 \u2192 \u03b1\na : \u2115\nn : \u03b1\n\u22a2 f^[a] n = iterateTR f a n"}, {"line": "exact Eq.symm <| iterateTR_loop_eq f a n []", "tactic_state": "No Goals!"}]}
{"declaration": "theorem getD_map {n : \u2115} (f : \u03b1 \u2192 \u03b2) : (map f l).getD n (f d) = f (l.getD n d) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/GetD.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} (l : List \u03b1) (x : \u03b1) (xs : List \u03b1) (n : \u2115)", "(d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nl : List \u03b1\nd : \u03b1\nx\u271d : Sort u_1\nmap : x\u271d\nn : \u2115\nf : \u03b1 \u2192 \u03b2\n\u22a2 sorry = f (l.getD n d)"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nl : List \u03b1\nd : \u03b1\nx\u271d : Sort u_1\nmap : x\u271d\nn : \u2115\nf : \u03b1 \u2192 \u03b2\n\u22a2 sorry () = f (l[n]?.getD d)"}]}
{"declaration": "theorem getElem?_getD_singleton_default_eq (n : \u2115) : [d][n]?.getD d = d := by cases n <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/GetD.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} (l : List \u03b1) (x : \u03b1) (xs : List \u03b1) (n : \u2115)", "(d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nd : \u03b1\nn : \u2115\n\u22a2 [d][n]?.getD d = d"}, {"line": "cases n <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem getI_zero_eq_headI : l.getI 0 = l.headI := by cases l <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/GetD.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} (l : List \u03b1) (x : \u03b1) (xs : List \u03b1) (n : \u2115)", "(d : \u03b1)", "[Inhabited \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl : List \u03b1\ninst\u271d : Inhabited \u03b1\n\u22a2 l.getI 0 = l.headI"}, {"line": "cases l <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem get_mapIdx (l : List \u03b1) (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) (i : \u2115) (h : i < l.length)\n    (h' : i < (l.mapIdx f).length := h.trans_le length_mapIdx.ge) :\n    (l.mapIdx f).get \u27e8i, h'\u27e9 = f i (l.get \u27e8i, h\u27e9) := by\n  simp [mapIdx_eq_zipIdx_map, enum_eq_zip_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Indexes.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nl : List \u03b1\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\ni : \u2115\nh : i < l.length\nh' : optParam (i < (List.mapIdx f l).length) \u22ef\n\u22a2 (List.mapIdx f l).get \u27e8i, h'\u27e9 = f i (l.get \u27e8i, h\u27e9)"}, {"line": "simp [mapIdx_eq_zipIdx_map, enum_eq_zip_range]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem indexesValues_eq_filter_enum (p : \u03b1 \u2192 Prop) [DecidablePred p] (as : List \u03b1) :\n    indexesValues p as = filter (p \u2218 Prod.snd) (enum as) := by\n  simp +unfoldPartialApp [indexesValues, foldrIdx_eq_foldr_enum, uncurry,\n    filter_eq_foldr, cond_eq_if]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Indexes.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nindexesValues : x\u271d\u00b9\nx\u271d : Sort u_2\nfilter : x\u271d\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nas : List \u03b1\n\u22a2 sorry = sorry"}, {"line": "simp +unfoldPartialApp [indexesValues, foldrIdx_eq_foldr_enum, uncurry,\n    filter_eq_foldr, cond_eq_if]", "tactic_state": "\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nindexesValues : x\u271d\u00b9\nx\u271d : Sort u_2\nfilter : x\u271d\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nas : List \u03b1\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem bidirectionalRec_singleton {motive : List \u03b1 \u2192 Sort*}\n    (nil : motive []) (singleton : \u2200 a : \u03b1, motive [a])\n    (cons_append : \u2200 (a : \u03b1) (l : List \u03b1) (b : \u03b1), motive l \u2192 motive (a :: (l ++ [b]))) (a : \u03b1) :\n    bidirectionalRec nil singleton cons_append [a] = singleton a := by\n  simp [bidirectionalRec]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Induction.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\nbidirectionalRec : x\u271d\nmotive : List \u03b1 \u2192 Sort u_2\nnil : motive []\nsingleton : (a : \u03b1) \u2192 motive [a]\ncons_append : (a : \u03b1) \u2192 (l : List \u03b1) \u2192 (b : \u03b1) \u2192 motive l \u2192 motive (a :: (l ++ [b]))\na : \u03b1\n\u22a2 sorry = singleton a"}, {"line": "simp [bidirectionalRec]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\nbidirectionalRec : x\u271d\nmotive : List \u03b1 \u2192 Sort u_2\nnil : motive []\nsingleton : (a : \u03b1) \u2192 motive [a]\ncons_append : (a : \u03b1) \u2192 (l : List \u03b1) \u2192 (b : \u03b1) \u2192 motive l \u2192 motive (a :: (l ++ [b]))\na : \u03b1\n\u22a2 sorry () = singleton a"}]}
{"declaration": "protected theorem IsPrefix.flatten {l\u2081 l\u2082 : List (List \u03b1)} (h : l\u2081 <+: l\u2082) :\n    l\u2081.flatten <+: l\u2082.flatten := by\n  rcases h with \u27e8l, rfl\u27e9\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Infix.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "{l l\u2081 l\u2082 l\u2083 : List \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl\u2081 l\u2082 : List (List \u03b1)\nh : l\u2081 <+: l\u2082\n\u22a2 l\u2081.flatten <+: l\u2082.flatten"}, {"line": "rcases h with \u27e8l, rfl\u27e9", "tactic_state": "case intro\n\u03b1 : Type u_1\nl\u2081 l : List (List \u03b1)\n\u22a2 l\u2081.flatten <+: (l\u2081 ++ l).flatten"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsInfix.flatten {l\u2081 l\u2082 : List (List \u03b1)} (h : l\u2081 <:+: l\u2082) :\n    l\u2081.flatten <:+: l\u2082.flatten := by\n  rcases h with \u27e8l, l', rfl\u27e9\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Infix.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "{l l\u2081 l\u2082 l\u2083 : List \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl\u2081 l\u2082 : List (List \u03b1)\nh : l\u2081 <:+: l\u2082\n\u22a2 l\u2081.flatten <:+: l\u2082.flatten"}, {"line": "rcases h with \u27e8l, l', rfl\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nl\u2081 l l' : List (List \u03b1)\n\u22a2 l\u2081.flatten <:+: (l ++ l\u2081 ++ l').flatten"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inits_cons (a : \u03b1) (l : List \u03b1) : inits (a :: l) = [] :: l.inits.map fun t => a :: t := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Infix.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "{l l\u2081 l\u2082 l\u2083 : List \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\ninits : x\u271d\na : \u03b1\nl : List \u03b1\n\u22a2 sorry = [] :: List.map (fun t => a :: t) l.inits"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\ninits : x\u271d\na : \u03b1\nl : List \u03b1\n\u22a2 sorry () = [] :: List.map (fun t => a :: t) l.inits"}]}
{"declaration": "theorem tails_cons (a : \u03b1) (l : List \u03b1) : tails (a :: l) = (a :: l) :: l.tails := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Infix.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "{l l\u2081 l\u2082 l\u2083 : List \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\ntails : x\u271d\na : \u03b1\nl : List \u03b1\n\u22a2 sorry = (a :: l) :: l.tails"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\ntails : x\u271d\na : \u03b1\nl : List \u03b1\n\u22a2 sorry () = (a :: l) :: l.tails"}]}
{"declaration": "theorem length_tails (l : List \u03b1) : length (tails l) = length l + 1 := by\n  induction' l with x l IH\n  \u00b7 simp\n  \u00b7 simpa using IH\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Infix.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "{l l\u2081 l\u2082 l\u2083 : List \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\nlength : x\u271d\nl : List \u03b1\n\u22a2 sorry = sorry + 1"}, {"line": "induction' l with x l IH", "tactic_state": "case nil\n\u03b1 : Type u_1\nx\u271d : Sort u_3\nlength : x\u271d\n\u22a2 sorry = sorry + 1\n---\ncase cons\n\u03b1 : Type u_1\nx\u271d : Sort u_3\nlength : x\u271d\nx : \u03b1\nl : List \u03b1\nIH : sorry = sorry + 1\n\u22a2 sorry = sorry + 1"}, {"line": "\u00b7 simp", "tactic_state": "case cons\n\u03b1 : Type u_1\nx\u271d : Sort u_3\nlength : x\u271d\nx : \u03b1\nl : List \u03b1\nIH : sorry = sorry + 1\n\u22a2 sorry = sorry + 1"}, {"line": "\u00b7 simpa using IH", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_inits (l : List \u03b1) : length (inits l) = length l + 1 := by simp [inits_eq_tails]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Infix.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "{l l\u2081 l\u2082 l\u2083 : List \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\nlength : x\u271d\nl : List \u03b1\n\u22a2 sorry = sorry + 1"}, {"line": "simp [inits_eq_tails]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\nlength : x\u271d\nl : List \u03b1\n\u22a2 False"}]}
{"declaration": "theorem get_tails (l : List \u03b1) (n : Fin (length (tails l))) : (tails l).get n = l.drop n := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Infix.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "{l l\u2081 l\u2082 l\u2083 : List \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_3\nlength : x\u271d\u00b9\nx\u271d : Sort u_4\ntails : x\u271d\nl : List \u03b1\nn : Fin sorry\n\u22a2 sorry = List.drop (\u2191n) l"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_3\nlength : x\u271d\u00b9\nx\u271d : Sort u_4\ntails : x\u271d\nl : List \u03b1\nn : Fin sorry\n\u22a2 sorry () = List.drop (\u2191n) l"}]}
{"declaration": "theorem get_inits (l : List \u03b1) (n : Fin (length (inits l))) : (inits l).get n = l.take n := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Infix.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "{l l\u2081 l\u2082 l\u2083 : List \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_3\nlength : x\u271d\u00b9\nx\u271d : Sort u_4\ninits : x\u271d\nl : List \u03b1\nn : Fin sorry\n\u22a2 sorry = List.take (\u2191n) l"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_3\nlength : x\u271d\u00b9\nx\u271d : Sort u_4\ninits : x\u271d\nl : List \u03b1\nn : Fin sorry\n\u22a2 sorry () = List.take (\u2191n) l"}]}
{"declaration": "lemma take_inits {n} : (l.take n).inits = l.inits.take (n + 1) := by\n  apply ext_getElem <;> (simp [take_take] <;> omega)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Infix.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "{l l\u2081 l\u2082 l\u2083 : List \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : List \u03b1\nn : \u2115\n\u22a2 (List.take n l).inits = List.take (n + 1) l.inits"}, {"line": "apply ext_getElem <;> (simp [take_take] <;> omega)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem suffix_insert (a : \u03b1) (l : List \u03b1) : l <:+ l.insert a := by\n  by_cases h : a \u2208 l\n  \u00b7 simp only [insert_of_mem h, insert, suffix_refl]\n  \u00b7 simp only [insert_of_not_mem h, suffix_cons, insert]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Infix.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "{l l\u2081 l\u2082 l\u2083 : List \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\n\u22a2 l <:+ List.insert a l"}, {"line": "by_cases h : a \u2208 l", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nh : a \u2208 l\n\u22a2 l <:+ List.insert a l\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nh : a \u2209 l\n\u22a2 l <:+ List.insert a l"}, {"line": "\u00b7 simp only [insert_of_mem h, insert, suffix_refl]", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nh : a \u2209 l\n\u22a2 l <:+ List.insert a l"}, {"line": "\u00b7 simp only [insert_of_not_mem h, suffix_cons, insert]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem {n m l : \u2115} : l \u2208 Ico n m \u2194 n \u2264 l \u2227 l < m := by\n  suffices n \u2264 l \u2227 l < n + (m - n) \u2194 n \u2264 l \u2227 l < m by simp [Ico, this]\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Intervals.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nIco : x\u271d\nn m l : \u2115\n\u22a2 l \u2208 sorry \u2194 n \u2264 l \u2227 l < m"}, {"line": "suffices n \u2264 l \u2227 l < n + (m - n) \u2194 n \u2264 l \u2227 l < m by simp [Ico, this]", "tactic_state": "x\u271d : Sort u_1\nIco : x\u271d\nn m l : \u2115\n\u22a2 n \u2264 l \u2227 l < n + (m - n) \u2194 n \u2264 l \u2227 l < m"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_nil_of_le {n m : \u2115} (h : m \u2264 n) : Ico n m = [] := by\n  simp [Ico, Nat.sub_eq_zero_iff_le.mpr h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Intervals.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nIco : x\u271d\nn m : \u2115\nh : m \u2264 n\n\u22a2 sorry = []"}, {"line": "simp [Ico, Nat.sub_eq_zero_iff_le.mpr h]", "tactic_state": "x\u271d : Sort u_1\nIco : x\u271d\nn m : \u2115\nh : m \u2264 n\n\u22a2 sorry () = []"}]}
{"declaration": "theorem pred_singleton {m : \u2115} (h : 0 < m) : Ico (m - 1) m = [m - 1] := by\n  simp [Ico, Nat.sub_sub_self (succ_le_of_lt h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Intervals.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nIco : x\u271d\nm : \u2115\nh : 0 < m\n\u22a2 sorry = [m - 1]"}, {"line": "simp [Ico, Nat.sub_sub_self (succ_le_of_lt h)]", "tactic_state": "x\u271d : Sort u_1\nIco : x\u271d\nm : \u2115\nh : 0 < m\n\u22a2 sorry () = [m - 1]"}]}
{"declaration": "theorem not_mem_top {n m : \u2115} : m \u2209 Ico n m := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Intervals.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nIco : x\u271d\nn m : \u2115\n\u22a2 m \u2209 sorry"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nIco : x\u271d\nn m : \u2115\n\u22a2 m \u2209 sorry ()"}]}
{"declaration": "theorem filter_lt_of_succ_bot {n m : \u2115} (hnm : n < m) :\n    ((Ico n m).filter fun x => x < n + 1) = [n] := by\n  have r : min m (n + 1) = n + 1 := (@inf_eq_right _ _ m (n + 1)).mpr hnm\n  simp [filter_lt n m (n + 1), r]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Intervals.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nIco : x\u271d\nn m : \u2115\nhnm : n < m\n\u22a2 sorry = [n]"}, {"line": "have r : min m (n + 1) = n + 1 := (@inf_eq_right _ _ m (n + 1)).mpr hnm", "tactic_state": "x\u271d : Sort u_1\nIco : x\u271d\nn m : \u2115\nhnm : n < m\nr : min m (n + 1) = n + 1\n\u22a2 sorry = [n]"}, {"line": "simp [filter_lt n m (n + 1), r]", "tactic_state": "x\u271d : Sort u_1\nIco : x\u271d\nn m : \u2115\nhnm : n < m\nr : min m (n + 1) = n + 1\n\u22a2 sorry () = [n]"}]}
{"declaration": "theorem inter_cons_of_mem (l\u2081 : List \u03b1) (h : a \u2208 l\u2082) : (a :: l\u2081) \u2229 l\u2082 = a :: l\u2081 \u2229 l\u2082 := by\n  simp [Inter.inter, List.inter, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Lattice.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type*} {l\u2081 l\u2082 : List \u03b1} {p : \u03b1 \u2192 Prop} {a : \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl\u2082 : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 : List \u03b1\nh : a \u2208 l\u2082\n\u22a2 (a :: l\u2081) \u2229 l\u2082 = a :: l\u2081 \u2229 l\u2082"}, {"line": "simp [Inter.inter, List.inter, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inter_cons_of_not_mem (l\u2081 : List \u03b1) (h : a \u2209 l\u2082) : (a :: l\u2081) \u2229 l\u2082 = l\u2081 \u2229 l\u2082 := by\n  simp [Inter.inter, List.inter, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Lattice.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type*} {l\u2081 l\u2082 : List \u03b1} {p : \u03b1 \u2192 Prop} {a : \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl\u2082 : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 : List \u03b1\nh : a \u2209 l\u2082\n\u22a2 (a :: l\u2081) \u2229 l\u2082 = l\u2081 \u2229 l\u2082"}, {"line": "simp [Inter.inter, List.inter, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_of_mem_inter_right (h : a \u2208 l\u2081 \u2229 l\u2082) : a \u2208 l\u2082 := by simpa using of_mem_filter h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Lattice.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type*} {l\u2081 l\u2082 : List \u03b1} {p : \u03b1 \u2192 Prop} {a : \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nh : a \u2208 l\u2081 \u2229 l\u2082\n\u22a2 a \u2208 l\u2082"}, {"line": "simpa using of_mem_filter h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nil_bagInter (l : List \u03b1) : [].bagInter l = [] := by cases l <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Lattice.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type*} {l\u2081 l\u2082 : List \u03b1} {p : \u03b1 \u2192 Prop} {a : \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\n\u22a2 [].bagInter l = []"}, {"line": "cases l <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bagInter_nil (l : List \u03b1) : l.bagInter [] = [] := by cases l <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Lattice.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type*} {l\u2081 l\u2082 : List \u03b1} {p : \u03b1 \u2192 Prop} {a : \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\n\u22a2 l.bagInter [] = []"}, {"line": "cases l <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cons_bagInter_of_pos (l\u2081 : List \u03b1) (h : a \u2208 l\u2082) :\n    (a :: l\u2081).bagInter l\u2082 = a :: l\u2081.bagInter (l\u2082.erase a) := by\n  cases l\u2082\n  \u00b7 exact if_pos h\n  \u00b7 simp only [List.bagInter, if_pos (elem_eq_true_of_mem h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Lattice.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type*} {l\u2081 l\u2082 : List \u03b1} {p : \u03b1 \u2192 Prop} {a : \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl\u2082 : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 : List \u03b1\nh : a \u2208 l\u2082\n\u22a2 (a :: l\u2081).bagInter l\u2082 = a :: l\u2081.bagInter (l\u2082.erase a)"}, {"line": "cases l\u2082", "tactic_state": "case nil\n\u03b1 : Type u_1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 : List \u03b1\nh : a \u2208 []\n\u22a2 (a :: l\u2081).bagInter [] = a :: l\u2081.bagInter ([].erase a)\n---\ncase cons\n\u03b1 : Type u_1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 : List \u03b1\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\nh : a \u2208 head\u271d :: tail\u271d\n\u22a2 (a :: l\u2081).bagInter (head\u271d :: tail\u271d) = a :: l\u2081.bagInter ((head\u271d :: tail\u271d).erase a)"}, {"line": "\u00b7 exact if_pos h", "tactic_state": "case cons\n\u03b1 : Type u_1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 : List \u03b1\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\nh : a \u2208 head\u271d :: tail\u271d\n\u22a2 (a :: l\u2081).bagInter (head\u271d :: tail\u271d) = a :: l\u2081.bagInter ((head\u271d :: tail\u271d).erase a)"}, {"line": "\u00b7 simp only [List.bagInter, if_pos (elem_eq_true_of_mem h)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem foldl_range_subset_of_range_subset {f : \u03b1 \u2192 \u03b2 \u2192 \u03b1} {g : \u03b1 \u2192 \u03b3 \u2192 \u03b1}\n    (hfg : (Set.range fun a c => f c a) \u2286 Set.range fun b c => g c b) (a : \u03b1) :\n    Set.range (foldl f a) \u2286 Set.range (foldl g a) := by\n  change (Set.range fun l => _) \u2286 Set.range fun l => _\n  -- Porting note: have to write `(foldr_reverse)` instead of `foldr_reverse`.\n  simp_rw [\u2190 (foldr_reverse), Set.range_comp' _ reverse,\n    reverse_involutive.bijective.surjective.range_eq, Set.image_univ]\n  exact foldr_range_subset_of_range_subset hfg a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Lemmas.lean", "context": {"open": ["List"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b1\ng : \u03b1 \u2192 \u03b3 \u2192 \u03b1\nhfg : (Set.range fun a c => f c a) \u2286 Set.range fun b c => g c b\na : \u03b1\n\u22a2 Set.range (foldl f a) \u2286 Set.range (foldl g a)"}, {"line": "change (Set.range fun l => _) \u2286 Set.range fun l => _", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b1\ng : \u03b1 \u2192 \u03b3 \u2192 \u03b1\nhfg : (Set.range fun a c => f c a) \u2286 Set.range fun b c => g c b\na : \u03b1\n\u22a2 (Set.range fun l => foldl f a l) \u2286 Set.range fun l => foldl g a l"}, {"line": "simp_rw [\u2190 (foldr_reverse), Set.range_comp' _ reverse,\n    reverse_involutive.bijective.surjective.range_eq, Set.image_univ]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b1\ng : \u03b1 \u2192 \u03b3 \u2192 \u03b1\nhfg : (Set.range fun a c => f c a) \u2286 Set.range fun b c => g c b\na : \u03b1\n\u22a2 Set.range (foldr (fun y x => f x y) a) \u2286 Set.range (foldr (fun y x => g x y) a)"}, {"line": "exact foldr_range_subset_of_range_subset hfg a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_iff_lex_lt [LT \u03b1] (l l' : List \u03b1) : List.lt l l' \u2194 Lex (\u00b7 < \u00b7) l l' := by\n  rw [List.lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Lex.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : LT \u03b1\nl l' : List \u03b1\n\u22a2 l.lt l' \u2194 sorry"}, {"line": "rw [List.lt]", "tactic_state": "\u03b1 : Type u\ninst\u271d : LT \u03b1\nl l' : List \u03b1\n\u22a2 List.Lex (fun x1 x2 => x1 < x2) l l' \u2194 sorry"}]}
{"declaration": "theorem cons_le_cons [LinearOrder \u03b1] (a : \u03b1) {l l' : List \u03b1} (h : l' \u2264 l) :\n    a :: l' \u2264 a :: l := by\n  rw [le_iff_lt_or_eq] at h \u22a2\n  exact h.imp .cons (congr_arg _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Lex.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na : \u03b1\nl l' : List \u03b1\nh : l' \u2264 l\n\u22a2 a :: l' \u2264 a :: l"}, {"line": "rw [le_iff_lt_or_eq] at h \u22a2", "tactic_state": "\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na : \u03b1\nl l' : List \u03b1\nh : l' < l \u2228 l' = l\n\u22a2 a :: l' < a :: l \u2228 a :: l' = a :: l"}, {"line": "exact h.imp .cons (congr_arg _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem argmax_eq_none : l.argmax f = none \u2194 l = [] := by simp [argmax]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/MinMax.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r] {l : List \u03b1} {o : Option \u03b1} {a : \u03b1}", "[Preorder \u03b2] [DecidableLT \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} {a m : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : DecidableLT \u03b2\nf : \u03b1 \u2192 \u03b2\nl : List \u03b1\n\u22a2 List.argmax f l = none \u2194 l = []"}, {"line": "simp [argmax]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_maximum_lt_of_mem' (ha : a \u2208 l) : \u00acmaximum l < (a : WithBot \u03b1) := by\n  cases h : l.maximum <;> simp_all [not_maximum_lt_of_mem ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/MinMax.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r] {l : List \u03b1} {o : Option \u03b1} {a : \u03b1}", "[Preorder \u03b2] [DecidableLT \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} {a m : \u03b1}", "[LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} {a m : \u03b1}", "[DecidableEq \u03b1]", "[Preorder \u03b1] [DecidableLT \u03b1] {l : List \u03b1} {a m : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableLT \u03b1\nl : List \u03b1\na : \u03b1\nx\u271d : Sort u_3\nmaximum : x\u271d\nha : a \u2208 l\n\u22a2 \u00acsorry < \u2191a"}, {"line": "cases h : l.maximum <;> simp_all [not_maximum_lt_of_mem ha]", "tactic_state": "case bot\n\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableLT \u03b1\nl : List \u03b1\na : \u03b1\nx\u271d : Sort u_3\nmaximum : x\u271d\nha : a \u2208 l\nh : sorry () = \u22a5\n\u22a2 False\n---\ncase coe\n\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableLT \u03b1\nl : List \u03b1\na : \u03b1\nx\u271d : Sort u_3\nmaximum : x\u271d\nha : a \u2208 l\na\u271d : \u03b1\nh : sorry () = \u2191a\u271d\n\u22a2 \u00aca\u271d < a"}]}
{"declaration": "theorem not_lt_minimum_of_mem' (ha : a \u2208 l) : \u00ac(a : WithTop \u03b1) < minimum l := by\n  cases h : l.minimum <;> simp_all [not_lt_minimum_of_mem ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/MinMax.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r] {l : List \u03b1} {o : Option \u03b1} {a : \u03b1}", "[Preorder \u03b2] [DecidableLT \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} {a m : \u03b1}", "[LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} {a m : \u03b1}", "[DecidableEq \u03b1]", "[Preorder \u03b1] [DecidableLT \u03b1] {l : List \u03b1} {a m : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableLT \u03b1\nl : List \u03b1\na : \u03b1\nx\u271d : Sort u_3\nminimum : x\u271d\nha : a \u2208 l\n\u22a2 \u00ac\u2191a < sorry"}, {"line": "cases h : l.minimum <;> simp_all [not_lt_minimum_of_mem ha]", "tactic_state": "case top\n\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableLT \u03b1\nl : List \u03b1\na : \u03b1\nx\u271d : Sort u_3\nminimum : x\u271d\nha : a \u2208 l\nh : sorry () = \u22a4\n\u22a2 False\n---\ncase coe\n\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableLT \u03b1\nl : List \u03b1\na : \u03b1\nx\u271d : Sort u_3\nminimum : x\u271d\nha : a \u2208 l\na\u271d : \u03b1\nh : sorry () = \u2191a\u271d\n\u22a2 \u00aca < a\u271d"}]}
{"declaration": "theorem coe_le_maximum_iff : a \u2264 l.maximum \u2194 \u2203 b, b \u2208 l \u2227 a \u2264 b := by\n  induction' l <;> simp [maximum_cons, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/MinMax.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r] {l : List \u03b1} {o : Option \u03b1} {a : \u03b1}", "[Preorder \u03b2] [DecidableLT \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} {a m : \u03b1}", "[LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} {a m : \u03b1}", "[DecidableEq \u03b1]", "[Preorder \u03b1] [DecidableLT \u03b1] {l : List \u03b1} {a m : \u03b1}", "[LinearOrder \u03b1] {l : List \u03b1} {a m : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : DecidableLT \u03b1\ninst\u271d : LinearOrder \u03b1\nl : List \u03b1\na : \u03b1\n\u22a2 \u2191a \u2264 l.maximum \u2194 \u2203 b \u2208 l, a \u2264 b"}, {"line": "induction' l <;> simp [maximum_cons, *]", "tactic_state": "case cons\n\u03b1 : Type u_1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : DecidableLT \u03b1\ninst\u271d : LinearOrder \u03b1\nl : List \u03b1\na head\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : \u2191a \u2264 tail\u271d.maximum \u2194 \u2203 b \u2208 tail\u271d, a \u2264 b\n\u22a2 \u2191a \u2264 (head\u271d :: tail\u271d).maximum \u2194 a \u2264 head\u271d \u2228 \u2203 a_1 \u2208 tail\u271d, a \u2264 a_1"}]}
{"declaration": "theorem minimum_le_coe_iff : l.minimum \u2264 a \u2194 \u2203 b, b \u2208 l \u2227 b \u2264 a := by\n  induction' l <;> simp [minimum_cons, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/MinMax.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r] {l : List \u03b1} {o : Option \u03b1} {a : \u03b1}", "[Preorder \u03b2] [DecidableLT \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} {a m : \u03b1}", "[LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} {a m : \u03b1}", "[DecidableEq \u03b1]", "[Preorder \u03b1] [DecidableLT \u03b1] {l : List \u03b1} {a m : \u03b1}", "[LinearOrder \u03b1] {l : List \u03b1} {a m : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : DecidableLT \u03b1\ninst\u271d : LinearOrder \u03b1\nl : List \u03b1\na : \u03b1\n\u22a2 l.minimum \u2264 \u2191a \u2194 \u2203 b \u2208 l, b \u2264 a"}, {"line": "induction' l <;> simp [minimum_cons, *]", "tactic_state": "case cons\n\u03b1 : Type u_1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : DecidableLT \u03b1\ninst\u271d : LinearOrder \u03b1\nl : List \u03b1\na head\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : tail\u271d.minimum \u2264 \u2191a \u2194 \u2203 b \u2208 tail\u271d, b \u2264 a\n\u22a2 (head\u271d :: tail\u271d).minimum \u2264 \u2191a \u2194 head\u271d \u2264 a \u2228 \u2203 a_1 \u2208 tail\u271d, a_1 \u2264 a"}]}
{"declaration": "theorem max_le_of_forall_le (l : List \u03b1) (a : \u03b1) (h : \u2200 x \u2208 l, x \u2264 a) : l.foldr max \u22a5 \u2264 a := by\n  induction' l with y l IH\n  \u00b7 simp\n  \u00b7 simpa [h y mem_cons_self] using IH fun x hx => h x <| mem_cons_of_mem _ hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/MinMax.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r] {l : List \u03b1} {o : Option \u03b1} {a : \u03b1}", "[Preorder \u03b2] [DecidableLT \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} {a m : \u03b1}", "[LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} {a m : \u03b1}", "[DecidableEq \u03b1]", "[Preorder \u03b1] [DecidableLT \u03b1] {l : List \u03b1} {a m : \u03b1}", "[LinearOrder \u03b1] {l : List \u03b1} {a m : \u03b1}", "[LinearOrder \u03b1]", "[OrderBot \u03b1] {l : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : DecidableLT \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderBot \u03b1\nl : List \u03b1\na : \u03b1\nh : \u2200 x \u2208 l, x \u2264 a\n\u22a2 List.foldr max \u22a5 l \u2264 a"}, {"line": "induction' l with y l IH", "tactic_state": "case nil\n\u03b1 : Type u_1\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : DecidableLT \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderBot \u03b1\na : \u03b1\nh : \u2200 x \u2208 [], x \u2264 a\n\u22a2 List.foldr max \u22a5 [] \u2264 a\n---\ncase cons\n\u03b1 : Type u_1\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : DecidableLT \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderBot \u03b1\na y : \u03b1\nl : List \u03b1\nIH : (\u2200 x \u2208 l, x \u2264 a) \u2192 List.foldr max \u22a5 l \u2264 a\nh : \u2200 x \u2208 y :: l, x \u2264 a\n\u22a2 List.foldr max \u22a5 (y :: l) \u2264 a"}, {"line": "\u00b7 simp", "tactic_state": "case cons\n\u03b1 : Type u_1\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : DecidableLT \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderBot \u03b1\na y : \u03b1\nl : List \u03b1\nIH : (\u2200 x \u2208 l, x \u2264 a) \u2192 List.foldr max \u22a5 l \u2264 a\nh : \u2200 x \u2208 y :: l, x \u2264 a\n\u22a2 List.foldr max \u22a5 (y :: l) \u2264 a"}, {"line": "\u00b7 simpa [h y mem_cons_self] using IH fun x hx => h x <| mem_cons_of_mem _ hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_max_of_le {l : List \u03b1} {a x : \u03b1} (hx : x \u2208 l) (h : a \u2264 x) : a \u2264 l.foldr max \u22a5 := by\n  induction' l with y l IH\n  \u00b7 exact absurd hx not_mem_nil\n  \u00b7 obtain hl | hl := hx\n    \u00b7 simp only [foldr, foldr_cons]\n      exact le_max_of_le_left h\n    \u00b7 exact le_max_of_le_right (IH (by assumption))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/MinMax.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r] {l : List \u03b1} {o : Option \u03b1} {a : \u03b1}", "[Preorder \u03b2] [DecidableLT \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} {a m : \u03b1}", "[LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} {a m : \u03b1}", "[DecidableEq \u03b1]", "[Preorder \u03b1] [DecidableLT \u03b1] {l : List \u03b1} {a m : \u03b1}", "[LinearOrder \u03b1] {l : List \u03b1} {a m : \u03b1}", "[LinearOrder \u03b1]", "[OrderBot \u03b1] {l : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : DecidableLT \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderBot \u03b1\nl : List \u03b1\na x : \u03b1\nhx : x \u2208 l\nh : a \u2264 x\n\u22a2 a \u2264 List.foldr max \u22a5 l"}, {"line": "induction' l with y l IH", "tactic_state": "case nil\n\u03b1 : Type u_1\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : DecidableLT \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderBot \u03b1\na x : \u03b1\nh : a \u2264 x\nhx : x \u2208 []\n\u22a2 a \u2264 List.foldr max \u22a5 []\n---\ncase cons\n\u03b1 : Type u_1\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : DecidableLT \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderBot \u03b1\na x : \u03b1\nh : a \u2264 x\ny : \u03b1\nl : List \u03b1\nIH : x \u2208 l \u2192 a \u2264 List.foldr max \u22a5 l\nhx : x \u2208 y :: l\n\u22a2 a \u2264 List.foldr max \u22a5 (y :: l)"}, {"line": "\u00b7 exact absurd hx not_mem_nil", "tactic_state": "case cons\n\u03b1 : Type u_1\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : DecidableLT \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderBot \u03b1\na x : \u03b1\nh : a \u2264 x\ny : \u03b1\nl : List \u03b1\nIH : x \u2208 l \u2192 a \u2264 List.foldr max \u22a5 l\nhx : x \u2208 y :: l\n\u22a2 a \u2264 List.foldr max \u22a5 (y :: l)"}, {"line": "\u00b7 obtain hl | hl := hx\n    \u00b7 simp only [foldr, foldr_cons]\n      exact le_max_of_le_left h\n    \u00b7 exact le_max_of_le_right (IH (by assumption))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nodup_iff_get?_ne_get? {l : List \u03b1} :\n    l.Nodup \u2194 \u2200 i j : \u2115, i < j \u2192 j < l.length \u2192 l.get? i \u2260 l.get? j := by\n  simp [nodup_iff_getElem?_ne_getElem?]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Nodup.lean", "context": {"open": ["Function", "scoped Relator in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {l l\u2081 l\u2082 : List \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : List \u03b1\n\u22a2 l.Nodup \u2194 \u2200 (i j : \u2115), i < j \u2192 j < l.length \u2192 l.get? i \u2260 l.get? j"}, {"line": "simp [nodup_iff_getElem?_ne_getElem?]", "tactic_state": "\u03b1 : Type u_1\nl : List \u03b1\n\u22a2 l.Nodup \u2194 \u2200 (i j : \u2115), i < j \u2192 j < l.length \u2192 \u00acl[i]? = l[j]?"}]}
{"declaration": "theorem get_idxOf [DecidableEq \u03b1] {l : List \u03b1} (H : Nodup l) (i : Fin l.length) :\n    idxOf (get l i) l = i := by\n  simp [idxOf_getElem, H]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Nodup.lean", "context": {"open": ["Function", "scoped Relator in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {l l\u2081 l\u2082 : List \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_2\nNodup : x\u271d\u00b9\nx\u271d : Sort u_3\nidxOf : x\u271d\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nH : sorry\ni : Fin l.length\n\u22a2 sorry = i"}, {"line": "simp [idxOf_getElem, H]", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_2\nNodup : x\u271d\u00b9\nx\u271d : Sort u_3\nidxOf : x\u271d\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nH : sorry\ni : Fin l.length\n\u22a2 sorry () = i"}]}
{"declaration": "theorem count_eq_of_nodup [DecidableEq \u03b1] {a : \u03b1} {l : List \u03b1} (d : Nodup l) :\n    count a l = if a \u2208 l then 1 else 0 := by\n  split_ifs with h\n  \u00b7 exact count_eq_one_of_mem d h\n  \u00b7 exact count_eq_zero_of_not_mem h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Nodup.lean", "context": {"open": ["Function", "scoped Relator in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {l l\u2081 l\u2082 : List \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_2\nNodup : x\u271d\u00b9\nx\u271d : Sort u_3\ncount : x\u271d\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nd : sorry\n\u22a2 sorry = if a \u2208 l then 1 else 0"}, {"line": "split_ifs with h", "tactic_state": "case pos\n\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_2\nNodup : x\u271d\u00b9\nx\u271d : Sort u_3\ncount : x\u271d\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nd : sorry\nh : a \u2208 l\n\u22a2 sorry = 1\n---\ncase neg\n\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_2\nNodup : x\u271d\u00b9\nx\u271d : Sort u_3\ncount : x\u271d\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nd : sorry\nh : a \u2209 l\n\u22a2 sorry = 0"}, {"line": "\u00b7 exact count_eq_one_of_mem d h", "tactic_state": "case neg\n\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_2\nNodup : x\u271d\u00b9\nx\u271d : Sort u_3\ncount : x\u271d\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nd : sorry\nh : a \u2209 l\n\u22a2 sorry = 0"}, {"line": "\u00b7 exact count_eq_zero_of_not_mem h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nodup.filter (p : \u03b1 \u2192 Bool) {l} : Nodup l \u2192 Nodup (filter p l) := by\n  simpa using Pairwise.filter p\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Nodup.lean", "context": {"open": ["Function", "scoped Relator in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {l l\u2081 l\u2082 : List \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nx\u271d : Sort u_2\nNodup : x\u271d\np : \u03b1 \u2192 Bool\nl : ?m.865 p\n\u22a2 sorry \u2192 sorry"}, {"line": "simpa using Pairwise.filter p", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nodup.erase_get [DecidableEq \u03b1] {l : List \u03b1} (hl : l.Nodup) (i : Fin l.length) :\n    l.erase (l.get i) = l.eraseIdx \u2191i := by\n  simp [erase_getElem, hl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Nodup.lean", "context": {"open": ["Function", "scoped Relator in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {l l\u2081 l\u2082 : List \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nhl : l.Nodup\ni : Fin l.length\n\u22a2 l.erase (l.get i) = l.eraseIdx \u2191i"}, {"line": "simp [erase_getElem, hl]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nhl : l.Nodup\ni : Fin l.length\n\u22a2 l.erase l[\u2191i] = l.eraseIdx \u2191i"}]}
{"declaration": "theorem last_ofFn {n : \u2115} (f : Fin n \u2192 \u03b1) (h : ofFn f \u2260 [])\n    (hn : n - 1 < n := Nat.pred_lt <| ofFn_eq_nil_iff.not.mp h) :\n    getLast (ofFn f) h = f \u27e8n - 1, hn\u27e9 := by simp [getLast_eq_getElem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/OfFn.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nofFn : x\u271d\u00b9\nx\u271d : Sort u_2\ngetLast : x\u271d\nn : \u2115\nf : Fin n \u2192 \u03b1\nh : sorry \u2260 []\nhn : optParam (n - 1 < n) \u22ef\n\u22a2 sorry = f \u27e8n - 1, hn\u27e9"}, {"line": "simp [getLast_eq_getElem]", "tactic_state": "\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nofFn : x\u271d\u00b9\nx\u271d : Sort u_2\ngetLast : x\u271d\nn : \u2115\nf : Fin n \u2192 \u03b1\nh : sorry \u2260 []\nhn : optParam (n - 1 < n) \u22ef\n\u22a2 sorry () = f \u27e8n - 1, hn\u27e9"}]}
{"declaration": "theorem permutationsAux2_snd_cons (t : \u03b1) (ts : List \u03b1) (r : List \u03b2) (y : \u03b1) (ys : List \u03b1)\n    (f : List \u03b1 \u2192 \u03b2) :\n    (permutationsAux2 t ts r (y :: ys) f).2 =\n      f (t :: y :: ys ++ ts) :: (permutationsAux2 t ts r ys fun x : List \u03b1 => f (y :: x)).2 := by\n  simp [permutationsAux2, permutationsAux2_fst t _ _ ys]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Permutation.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_3\npermutationsAux2 : x\u271d\nt : \u03b1\nts : List \u03b1\nr : List \u03b2\ny : \u03b1\nys : List \u03b1\nf : List \u03b1 \u2192 \u03b2\n\u22a2 sorry = f (t :: y :: ys ++ ts) :: sorry"}, {"line": "simp [permutationsAux2, permutationsAux2_fst t _ _ ys]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_3\npermutationsAux2 : x\u271d\nt : \u03b1\nts : List \u03b1\nr : List \u03b2\ny : \u03b1\nys : List \u03b1\nf : List \u03b1 \u2192 \u03b2\n\u22a2 False"}]}
{"declaration": "theorem permutationsAux2_append (t : \u03b1) (ts : List \u03b1) (r : List \u03b2) (ys : List \u03b1) (f : List \u03b1 \u2192 \u03b2) :\n    (permutationsAux2 t ts nil ys f).2 ++ r = (permutationsAux2 t ts r ys f).2 := by\n  induction ys generalizing f <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Permutation.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_3\npermutationsAux2 : x\u271d\nt : \u03b1\nts : List \u03b1\nr : List \u03b2\nys : List \u03b1\nf : List \u03b1 \u2192 \u03b2\n\u22a2 sorry ++ r = sorry"}, {"line": "induction ys generalizing f <;> simp [*]", "tactic_state": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_3\npermutationsAux2 : x\u271d\nt : \u03b1\nts : List \u03b1\nr : List \u03b2\nf : List \u03b1 \u2192 \u03b2\n\u22a2 r = []\n---\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_3\npermutationsAux2 : x\u271d\nt : \u03b1\nts : List \u03b1\nr : List \u03b2\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : (List \u03b1 \u2192 \u03b2) \u2192 sorry ++ r = sorry\nf : List \u03b1 \u2192 \u03b2\n\u22a2 r = []"}]}
{"declaration": "theorem permutationsAux2_comp_append {t : \u03b1} {ts ys : List \u03b1} {r : List \u03b2} (f : List \u03b1 \u2192 \u03b2) :\n    ((permutationsAux2 t [] r ys) fun x => f (x ++ ts)).2 = (permutationsAux2 t ts r ys f).2 := by\n  induction' ys with ys_hd _ ys_ih generalizing f\n  \u00b7 simp\n  \u00b7 simp [ys_ih fun xs => f (ys_hd :: xs)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Permutation.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_3\npermutationsAux2 : x\u271d\nt : \u03b1\nts ys : List \u03b1\nr : List \u03b2\nf : List \u03b1 \u2192 \u03b2\n\u22a2 sorry = sorry"}, {"line": "induction' ys with ys_hd _ ys_ih generalizing f", "tactic_state": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_3\npermutationsAux2 : x\u271d\nt : \u03b1\nts : List \u03b1\nr : List \u03b2\nf : List \u03b1 \u2192 \u03b2\n\u22a2 sorry = sorry\n---\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_3\npermutationsAux2 : x\u271d\nt : \u03b1\nts : List \u03b1\nr : List \u03b2\nys_hd : \u03b1\ntail\u271d : List \u03b1\nys_ih : \u2200 (f : List \u03b1 \u2192 \u03b2), sorry = sorry\nf : List \u03b1 \u2192 \u03b2\n\u22a2 sorry = sorry"}, {"line": "\u00b7 simp", "tactic_state": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_3\npermutationsAux2 : x\u271d\nt : \u03b1\nts : List \u03b1\nr : List \u03b2\nys_hd : \u03b1\ntail\u271d : List \u03b1\nys_ih : \u2200 (f : List \u03b1 \u2192 \u03b2), sorry = sorry\nf : List \u03b1 \u2192 \u03b2\n\u22a2 sorry = sorry"}, {"line": "\u00b7 simp [ys_ih fun xs => f (ys_hd :: xs)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_map_permutations'Aux (f : \u03b1 \u2192 \u03b2) (t : \u03b1) (ts : List \u03b1) :\n    map (map f) (permutations'Aux t ts) = permutations'Aux (f t) (map f ts) := by\n  induction' ts with a ts ih\n  \u00b7 rfl\n  \u00b7 simp only [permutations'Aux, map_cons, map_map, \u2190 ih, cons.injEq, true_and, Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Permutation.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_3\nmap : x\u271d\u00b9\nx\u271d : Sort u_4\npermutations'Aux : x\u271d\nf : \u03b1 \u2192 \u03b2\nt : \u03b1\nts : List \u03b1\n\u22a2 sorry = sorry"}, {"line": "induction' ts with a ts ih", "tactic_state": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_3\nmap : x\u271d\u00b9\nx\u271d : Sort u_4\npermutations'Aux : x\u271d\nf : \u03b1 \u2192 \u03b2\nt : \u03b1\n\u22a2 sorry = sorry\n---\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_3\nmap : x\u271d\u00b9\nx\u271d : Sort u_4\npermutations'Aux : x\u271d\nf : \u03b1 \u2192 \u03b2\nt a : \u03b1\nts : List \u03b1\nih : sorry = sorry\n\u22a2 sorry = sorry"}, {"line": "\u00b7 rfl", "tactic_state": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_3\nmap : x\u271d\u00b9\nx\u271d : Sort u_4\npermutations'Aux : x\u271d\nf : \u03b1 \u2192 \u03b2\nt a : \u03b1\nts : List \u03b1\nih : sorry = sorry\n\u22a2 sorry = sorry"}, {"line": "\u00b7 simp only [permutations'Aux, map_cons, map_map, \u2190 ih, cons.injEq, true_and, Function.comp_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_permutationsAux2 (t : \u03b1) (ts : List \u03b1) (ys : List \u03b1) (f : List \u03b1 \u2192 \u03b2) :\n    length (permutationsAux2 t ts [] ys f).2 = length ys := by\n  induction ys generalizing f <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Permutation.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_3\nlength : x\u271d\nt : \u03b1\nts ys : List \u03b1\nf : List \u03b1 \u2192 \u03b2\n\u22a2 sorry = sorry"}, {"line": "induction ys generalizing f <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem foldr_permutationsAux2 (t : \u03b1) (ts : List \u03b1) (r L : List (List \u03b1)) :\n    foldr (fun y r => (permutationsAux2 t ts r y id).2) r L =\n      (L.flatMap fun y => (permutationsAux2 t ts [] y id).2) ++ r := by\n  induction' L with l L ih\n  \u00b7 rfl\n  \u00b7 simp_rw [foldr_cons, ih, flatMap_cons, append_assoc, permutationsAux2_append]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Permutation.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_3\nfoldr : x\u271d\u00b9\nx\u271d : Sort u_4\npermutationsAux2 : x\u271d\nt : \u03b1\nts : List \u03b1\nr L : List (List \u03b1)\n\u22a2 sorry = List.flatMap (fun y => sorry) L ++ r"}, {"line": "induction' L with l L ih", "tactic_state": "case nil\n\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_3\nfoldr : x\u271d\u00b9\nx\u271d : Sort u_4\npermutationsAux2 : x\u271d\nt : \u03b1\nts : List \u03b1\nr : List (List \u03b1)\n\u22a2 sorry = List.flatMap (fun y => sorry) [] ++ r\n---\ncase cons\n\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_3\nfoldr : x\u271d\u00b9\nx\u271d : Sort u_4\npermutationsAux2 : x\u271d\nt : \u03b1\nts : List \u03b1\nr : List (List \u03b1)\nl : List \u03b1\nL : List (List \u03b1)\nih : sorry = List.flatMap (fun y => sorry) L ++ r\n\u22a2 sorry = List.flatMap (fun y => sorry) (l :: L) ++ r"}, {"line": "\u00b7 rfl", "tactic_state": "case cons\n\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_3\nfoldr : x\u271d\u00b9\nx\u271d : Sort u_4\npermutationsAux2 : x\u271d\nt : \u03b1\nts : List \u03b1\nr : List (List \u03b1)\nl : List \u03b1\nL : List (List \u03b1)\nih : sorry = List.flatMap (fun y => sorry) L ++ r\n\u22a2 sorry = List.flatMap (fun y => sorry) (l :: L) ++ r"}, {"line": "\u00b7 simp_rw [foldr_cons, ih, flatMap_cons, append_assoc, permutationsAux2_append]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_foldr_permutationsAux2 (t : \u03b1) (ts : List \u03b1) (r L : List (List \u03b1)) :\n    length (foldr (fun y r => (permutationsAux2 t ts r y id).2) r L) =\n      (map length L).sum + length r := by\n  simp [foldr_permutationsAux2, Function.comp_def, length_permutationsAux2, length_flatMap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Permutation.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_3\nlength : x\u271d\u00b9\nx\u271d : Sort u_4\nmap : x\u271d\nt : \u03b1\nts : List \u03b1\nr L : List (List \u03b1)\n\u22a2 sorry = sorry + sorry"}, {"line": "simp [foldr_permutationsAux2, Function.comp_def, length_permutationsAux2, length_flatMap]", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_3\nlength : x\u271d\u00b9\nx\u271d : Sort u_4\nmap : x\u271d\nt : \u03b1\nts : List \u03b1\nr L : List (List \u03b1)\n\u22a2 sorry () = sorry () + sorry ()"}]}
{"declaration": "theorem map_permutations' (f : \u03b1 \u2192 \u03b2) (ts : List \u03b1) :\n    map (map f) (permutations' ts) = permutations' (map f ts) := by\n  induction' ts with t ts ih <;>\n    [rfl; simp [\u2190 ih, map_flatMap, \u2190 map_map_permutations'Aux, flatMap_map]]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Permutation.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_3\nmap : x\u271d\u00b9\nx\u271d : Sort u_4\npermutations' : x\u271d\nf : \u03b1 \u2192 \u03b2\nts : List \u03b1\n\u22a2 sorry = sorry"}, {"line": "induction' ts with t ts ih <;>\n    [rfl; simp [\u2190 ih, map_flatMap, \u2190 map_map_permutations'Aux, flatMap_map]]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem permutations_append (is ts : List \u03b1) :\n    permutations (is ++ ts) = (permutations is).map (\u00b7 ++ ts) ++ permutationsAux ts is.reverse := by\n  simp [permutations, permutationsAux_append]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Permutation.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_3\npermutations : x\u271d\u00b9\nx\u271d : Sort u_4\npermutationsAux : x\u271d\nis ts : List \u03b1\n\u22a2 sorry = sorry ++ sorry"}, {"line": "simp [permutations, permutationsAux_append]", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_3\npermutations : x\u271d\u00b9\nx\u271d : Sort u_4\npermutationsAux : x\u271d\nis ts : List \u03b1\n\u22a2 sorry () = sorry () ++ sorry ()"}]}
{"declaration": "theorem get_permutations'Aux (s : List \u03b1) (x : \u03b1) (n : \u2115)\n    (hn : n < length (permutations'Aux x s)) :\n    (permutations'Aux x s).get \u27e8n, hn\u27e9 = s.insertIdx n x := by\n  simp [getElem_permutations'Aux]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Permutation.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_3\nlength : x\u271d\u00b9\nx\u271d : Sort u_4\npermutations'Aux : x\u271d\ns : List \u03b1\nx : \u03b1\nn : \u2115\nhn : n < sorry\n\u22a2 sorry = s.insertIdx n x"}, {"line": "simp [getElem_permutations'Aux]", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_3\nlength : x\u271d\u00b9\nx\u271d : Sort u_4\npermutations'Aux : x\u271d\ns : List \u03b1\nx : \u03b1\nn : \u2115\nhn : n < sorry\n\u22a2 sorry () = s.insertIdx n x"}]}
{"declaration": "theorem length_permutations'Aux (s : List \u03b1) (x : \u03b1) :\n    length (permutations'Aux x s) = length s + 1 := by\n  induction' s with y s IH\n  \u00b7 simp\n  \u00b7 simpa using IH\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Permutation.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\nlength : x\u271d\ns : List \u03b1\nx : \u03b1\n\u22a2 sorry = sorry + 1"}, {"line": "induction' s with y s IH", "tactic_state": "case nil\n\u03b1 : Type u_1\nx\u271d : Sort u_3\nlength : x\u271d\nx : \u03b1\n\u22a2 sorry = sorry + 1\n---\ncase cons\n\u03b1 : Type u_1\nx\u271d : Sort u_3\nlength : x\u271d\nx y : \u03b1\ns : List \u03b1\nIH : sorry = sorry + 1\n\u22a2 sorry = sorry + 1"}, {"line": "\u00b7 simp", "tactic_state": "case cons\n\u03b1 : Type u_1\nx\u271d : Sort u_3\nlength : x\u271d\nx y : \u03b1\ns : List \u03b1\nIH : sorry = sorry + 1\n\u22a2 sorry = sorry + 1"}, {"line": "\u00b7 simpa using IH", "tactic_state": "No Goals!"}]}
{"declaration": "theorem getElem_range'_1 {n m} (i) (H : i < (range' n m).length) :\n    (range' n m)[i] = n + i := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Range.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nrange' : x\u271d\nn : ?m.3728\nm : ?m.3729\ni : ?m.3730\nH : i < sorry\n\u22a2 sorry[i] = n + i"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nrange' : x\u271d\nn : ?m.3728\nm : ?m.3729\ni : ?m.3730\nH : i < sorry\n\u22a2 (sorry ())[i] = n + i"}]}
{"declaration": "theorem reduceOption_map {l : List (Option \u03b1)} {f : \u03b1 \u2192 \u03b2} :\n    reduceOption (map (Option.map f) l) = map f (reduceOption l) := by\n  induction' l with hd tl hl\n  \u00b7 simp only [reduceOption_nil, map_nil]\n  \u00b7 cases hd <;>\n      simpa [Option.map_some', map, eq_self_iff_true, reduceOption_cons_of_some] using hl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/ReduceOption.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_3\nreduceOption : x\u271d\u00b9\nx\u271d : Sort u_4\nmap : x\u271d\nl : List (Option \u03b1)\nf : \u03b1 \u2192 \u03b2\n\u22a2 sorry = sorry"}, {"line": "induction' l with hd tl hl", "tactic_state": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_3\nreduceOption : x\u271d\u00b9\nx\u271d : Sort u_4\nmap : x\u271d\nf : \u03b1 \u2192 \u03b2\n\u22a2 sorry = sorry\n---\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_3\nreduceOption : x\u271d\u00b9\nx\u271d : Sort u_4\nmap : x\u271d\nf : \u03b1 \u2192 \u03b2\nhd : Option \u03b1\ntl : List (Option \u03b1)\nhl : sorry = sorry\n\u22a2 sorry = sorry"}, {"line": "\u00b7 simp only [reduceOption_nil, map_nil]", "tactic_state": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_3\nreduceOption : x\u271d\u00b9\nx\u271d : Sort u_4\nmap : x\u271d\nf : \u03b1 \u2192 \u03b2\nhd : Option \u03b1\ntl : List (Option \u03b1)\nhl : sorry = sorry\n\u22a2 sorry = sorry"}, {"line": "\u00b7 cases hd <;>\n      simpa [Option.map_some', map, eq_self_iff_true, reduceOption_cons_of_some] using hl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reduceOption_length_eq {l : List (Option \u03b1)} :\n    l.reduceOption.length = (l.filter Option.isSome).length := by\n  induction' l with hd tl hl\n  \u00b7 simp_rw [reduceOption_nil, filter_nil, length]\n  \u00b7 cases hd <;> simp [hl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/ReduceOption.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : List (Option \u03b1)\n\u22a2 l.reduceOption.length = (List.filter Option.isSome l).length"}, {"line": "induction' l with hd tl hl", "tactic_state": "case nil\n\u03b1 : Type u_1\n\u22a2 [].reduceOption.length = (List.filter Option.isSome []).length\n---\ncase cons\n\u03b1 : Type u_1\nhd : Option \u03b1\ntl : List (Option \u03b1)\nhl : tl.reduceOption.length = (List.filter Option.isSome tl).length\n\u22a2 (hd :: tl).reduceOption.length = (List.filter Option.isSome (hd :: tl)).length"}, {"line": "\u00b7 simp_rw [reduceOption_nil, filter_nil, length]", "tactic_state": "case cons\n\u03b1 : Type u_1\nhd : Option \u03b1\ntl : List (Option \u03b1)\nhl : tl.reduceOption.length = (List.filter Option.isSome tl).length\n\u22a2 (hd :: tl).reduceOption.length = (List.filter Option.isSome (hd :: tl)).length"}, {"line": "\u00b7 cases hd <;> simp [hl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reduceOption_singleton (x : Option \u03b1) : [x].reduceOption = x.toList := by cases x <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/ReduceOption.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : Option \u03b1\n\u22a2 [x].reduceOption = x.toList"}, {"line": "cases x <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rotate_nil (n : \u2115) : ([] : List \u03b1).rotate n = [] := by simp [rotate]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Rotate.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nn : \u2115\n\u22a2 [].rotate n = []"}, {"line": "simp [rotate]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rotate_zero (l : List \u03b1) : l.rotate 0 = l := by simp [rotate]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Rotate.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl : List \u03b1\n\u22a2 l.rotate 0 = l"}, {"line": "simp [rotate]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rotate'_nil (n : \u2115) : ([] : List \u03b1).rotate' n = [] := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Rotate.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nn : \u2115\n\u22a2 [].rotate' n = []"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rotate'_zero (l : List \u03b1) : l.rotate' 0 = l := by cases l <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Rotate.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl : List \u03b1\n\u22a2 l.rotate' 0 = l"}, {"line": "cases l <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rotate'_cons_succ (l : List \u03b1) (a : \u03b1) (n : \u2115) :\n    (a :: l : List \u03b1).rotate' n.succ = (l ++ [a]).rotate' n := by simp [rotate']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Rotate.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl : List \u03b1\na : \u03b1\nn : \u2115\n\u22a2 (a :: l).rotate' n.succ = (l ++ [a]).rotate' n"}, {"line": "simp [rotate']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zipWith_rotate_one {\u03b2 : Type*} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b2) (x y : \u03b1) (l : List \u03b1) :\n    zipWith f (x :: y :: l) ((x :: y :: l).rotate 1) = f x y :: zipWith f (y :: l) (l ++ [x]) := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Rotate.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_2\nzipWith : x\u271d\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b2\nx y : \u03b1\nl : List \u03b1\n\u22a2 sorry = f x y :: sorry"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_2\nzipWith : x\u271d\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b2\nx y : \u03b1\nl : List \u03b1\n\u22a2 False"}]}
{"declaration": "theorem get_rotate (l : List \u03b1) (n : \u2115) (k : Fin (l.rotate n).length) :\n    (l.rotate n).get k = l.get \u27e8(k + n) % l.length, mod_lt _ (length_rotate l n \u25b8 k.pos)\u27e9 := by\n  simp [getElem_rotate]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Rotate.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\nlength_rotate : x\u271d\nl : List \u03b1\nn : \u2115\nk : Fin (l.rotate n).length\n\u22a2 (l.rotate n).get k = l.get \u27e8(\u2191k + n) % l.length, \u22ef\u27e9"}, {"line": "simp [getElem_rotate]", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\nlength_rotate : x\u271d\nl : List \u03b1\nn : \u2115\nk : Fin (l.rotate n).length\n\u22a2 (l.rotate n)[\u2191k] = l[(\u2191k + n) % l.length]"}]}
{"declaration": "theorem IsRotated.symm (h : l ~r l') : l' ~r l := by\n  obtain \u27e8n, rfl\u27e9 := h\n  rcases l with - | \u27e8hd, tl\u27e9\n  \u00b7 exists 0\n  \u00b7 use (hd :: tl).length * n - n\n    rw [rotate_rotate]\n    rw [Nat.add_sub_cancel']\n    rw [rotate_length_mul]\n    exact Nat.le_mul_of_pos_left _ (by simp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Rotate.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 : Type u}", "(l l' : List \u03b1)", "{l l'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl l' : List \u03b1\nh : l ~r l'\n\u22a2 l' ~r l"}, {"line": "obtain \u27e8n, rfl\u27e9 := h", "tactic_state": "case intro\n\u03b1 : Type u\nl : List \u03b1\nn : \u2115\n\u22a2 l.rotate n ~r l"}, {"line": "rcases l with - | \u27e8hd, tl\u27e9", "tactic_state": "case intro.nil\n\u03b1 : Type u\nn : \u2115\n\u22a2 [].rotate n ~r []\n---\ncase intro.cons\n\u03b1 : Type u\nn : \u2115\nhd : \u03b1\ntl : List \u03b1\n\u22a2 (hd :: tl).rotate n ~r hd :: tl"}, {"line": "\u00b7 exists 0", "tactic_state": "case intro.cons\n\u03b1 : Type u\nn : \u2115\nhd : \u03b1\ntl : List \u03b1\n\u22a2 (hd :: tl).rotate n ~r hd :: tl"}, {"line": "\u00b7 use (hd :: tl).length * n - n\n    rw [rotate_rotate]\n    rw [Nat.add_sub_cancel']\n    rw [rotate_length_mul]\n    exact Nat.le_mul_of_pos_left _ (by simp)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isRotated_reverse_comm_iff : l.reverse ~r l' \u2194 l ~r l'.reverse := by\n  constructor <;>\n    \u00b7 intro h\n      simpa using h.reverse\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Rotate.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 : Type u}", "(l l' : List \u03b1)", "{l l'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl l' : List \u03b1\n\u22a2 l.reverse ~r l' \u2194 l ~r l'.reverse"}, {"line": "constructor <;>\n    \u00b7 intro h\n      simpa using h.reverse", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isRotated_reverse_iff : l.reverse ~r l'.reverse \u2194 l ~r l' := by\n  simp [isRotated_reverse_comm_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Rotate.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 : Type u}", "(l l' : List \u03b1)", "{l l'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl l' : List \u03b1\n\u22a2 l.reverse ~r l'.reverse \u2194 l ~r l'"}, {"line": "simp [isRotated_reverse_comm_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isRotated_iff_mod : l ~r l' \u2194 \u2203 n \u2264 l.length, l.rotate n = l' := by\n  refine \u27e8fun h => ?_, fun \u27e8n, _, h\u27e9 => \u27e8n, h\u27e9\u27e9\n  obtain \u27e8n, rfl\u27e9 := h\n  rcases l with - | \u27e8hd, tl\u27e9\n  \u00b7 simp\n  \u00b7 refine \u27e8n % (hd :: tl).length, ?_, rotate_mod _ _\u27e9\n    refine (Nat.mod_lt _ ?_).le\n    simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Rotate.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 : Type u}", "(l l' : List \u03b1)", "{l l'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl l' : List \u03b1\n\u22a2 l ~r l' \u2194 \u2203 n \u2264 l.length, l.rotate n = l'"}, {"line": "refine \u27e8fun h => ?_, fun \u27e8n, _, h\u27e9 => \u27e8n, h\u27e9\u27e9", "tactic_state": "\u03b1 : Type u\nl l' : List \u03b1\nh : l ~r l'\n\u22a2 \u2203 n \u2264 l.length, l.rotate n = l'"}, {"line": "obtain \u27e8n, rfl\u27e9 := h", "tactic_state": "case intro\n\u03b1 : Type u\nl : List \u03b1\nn : \u2115\n\u22a2 \u2203 n_1 \u2264 l.length, l.rotate n_1 = l.rotate n"}, {"line": "rcases l with - | \u27e8hd, tl\u27e9", "tactic_state": "case intro.nil\n\u03b1 : Type u\nn : \u2115\n\u22a2 \u2203 n_1 \u2264 [].length, [].rotate n_1 = [].rotate n\n---\ncase intro.cons\n\u03b1 : Type u\nn : \u2115\nhd : \u03b1\ntl : List \u03b1\n\u22a2 \u2203 n_1 \u2264 (hd :: tl).length, (hd :: tl).rotate n_1 = (hd :: tl).rotate n"}, {"line": "\u00b7 simp", "tactic_state": "case intro.cons\n\u03b1 : Type u\nn : \u2115\nhd : \u03b1\ntl : List \u03b1\n\u22a2 \u2203 n_1 \u2264 (hd :: tl).length, (hd :: tl).rotate n_1 = (hd :: tl).rotate n"}, {"line": "\u00b7 refine \u27e8n % (hd :: tl).length, ?_, rotate_mod _ _\u27e9\n    refine (Nat.mod_lt _ ?_).le\n    simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_cyclicPermutations_cons (x : \u03b1) (l : List \u03b1) :\n    length (cyclicPermutations (x :: l)) = length l + 1 := by simp [cyclicPermutations_cons]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Rotate.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 : Type u}", "(l l' : List \u03b1)", "{l l'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\nlength : x\u271d\nx : \u03b1\nl : List \u03b1\n\u22a2 sorry = sorry + 1"}, {"line": "simp [cyclicPermutations_cons]", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\nlength : x\u271d\nx : \u03b1\nl : List \u03b1\n\u22a2 False"}]}
{"declaration": "theorem get_cyclicPermutations (l : List \u03b1) (n : Fin (length (cyclicPermutations l))) :\n    (cyclicPermutations l).get n = l.rotate n := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Rotate.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 : Type u}", "(l l' : List \u03b1)", "{l l'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nlength : x\u271d\u00b9\nx\u271d : Sort u_2\ncyclicPermutations : x\u271d\nl : List \u03b1\nn : Fin sorry\n\u22a2 sorry = l.rotate \u2191n"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nlength : x\u271d\u00b9\nx\u271d : Sort u_2\ncyclicPermutations : x\u271d\nl : List \u03b1\nn : Fin sorry\n\u22a2 sorry () = l.rotate \u2191n"}]}
{"declaration": "protected theorem IsRotated.cyclicPermutations {l l' : List \u03b1} (h : l ~r l') :\n    l.cyclicPermutations ~r l'.cyclicPermutations := by\n  obtain \u27e8k, rfl\u27e9 := h\n  exact \u27e8k, by simp\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Rotate.lean", "context": {"open": ["Nat Function"], "variables": ["{\u03b1 : Type u}", "(l l' : List \u03b1)", "{l l'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl l' : List \u03b1\nh : l ~r l'\n\u22a2 l.cyclicPermutations ~r l'.cyclicPermutations"}, {"line": "obtain \u27e8k, rfl\u27e9 := h", "tactic_state": "case intro\n\u03b1 : Type u\nl : List \u03b1\nk : \u2115\n\u22a2 l.cyclicPermutations ~r (l.rotate k).cyclicPermutations"}, {"line": "exact \u27e8k, by simp\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nodup_zipIdx_map_snd (l : List \u03b1) : (l.zipIdx.map Prod.snd).Nodup := by\n  simp [List.nodup_range']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sigma.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b1' : Type u'} {\u03b2 : \u03b1 \u2192 Type v} {\u03b2' : \u03b1' \u2192 Type v'} {l l\u2081 l\u2082 : List (Sigma \u03b2)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl : List \u03b1\n\u22a2 (List.map Prod.snd l.zipIdx).Nodup"}, {"line": "simp [List.nodup_range']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem kreplace_nodupKeys (a : \u03b1) (b : \u03b2 a) {l : List (Sigma \u03b2)} :\n    (kreplace a b l).NodupKeys \u2194 l.NodupKeys := by simp [NodupKeys, keys_kreplace]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sigma.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b1' : Type u'} {\u03b2 : \u03b1 \u2192 Type v} {\u03b2' : \u03b1' \u2192 Type v'} {l l\u2081 l\u2082 : List (Sigma \u03b2)}", "[DecidableEq \u03b1] [DecidableEq \u03b1']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_1\nkreplace : x\u271d\na : \u03b1\nb : \u03b2 a\nl : List (Sigma \u03b2)\n\u22a2 sorry \u2194 l.NodupKeys"}, {"line": "simp [NodupKeys, keys_kreplace]", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_1\nkreplace : x\u271d\na : \u03b1\nb : \u03b2 a\nl : List (Sigma \u03b2)\n\u22a2 sorry () \u2194 l.NodupKeys"}]}
{"declaration": "theorem kerase_cons_eq {a} {s : Sigma \u03b2} {l : List (Sigma \u03b2)} (h : a = s.1) :\n    kerase a (s :: l) = l := by simp [kerase, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sigma.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b1' : Type u'} {\u03b2 : \u03b1 \u2192 Type v} {\u03b2' : \u03b1' \u2192 Type v'} {l l\u2081 l\u2082 : List (Sigma \u03b2)}", "[DecidableEq \u03b1] [DecidableEq \u03b1']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_1\nkerase : x\u271d\na : \u03b1\ns : Sigma \u03b2\nl : List (Sigma \u03b2)\nh : a = s.fst\n\u22a2 sorry = l"}, {"line": "simp [kerase, h]", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_1\nkerase : x\u271d\na : \u03b1\ns : Sigma \u03b2\nl : List (Sigma \u03b2)\nh : a = s.fst\n\u22a2 sorry () = l"}]}
{"declaration": "theorem kerase_cons_ne {a} {s : Sigma \u03b2} {l : List (Sigma \u03b2)} (h : a \u2260 s.1) :\n    kerase a (s :: l) = s :: kerase a l := by simp [kerase, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sigma.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b1' : Type u'} {\u03b2 : \u03b1 \u2192 Type v} {\u03b2' : \u03b1' \u2192 Type v'} {l l\u2081 l\u2082 : List (Sigma \u03b2)}", "[DecidableEq \u03b1] [DecidableEq \u03b1']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_1\nkerase : x\u271d\na : \u03b1\ns : Sigma \u03b2\nl : List (Sigma \u03b2)\nh : a \u2260 s.fst\n\u22a2 sorry = s :: sorry"}, {"line": "simp [kerase, h]", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_1\nkerase : x\u271d\na : \u03b1\ns : Sigma \u03b2\nl : List (Sigma \u03b2)\nh : a \u2260 s.fst\n\u22a2 False"}]}
{"declaration": "theorem sorted_cons_cons {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsTrans \u03b1 r] {l : List \u03b1} {a b : \u03b1} :\n    Sorted r (b :: a :: l) \u2194 r b a \u2227 Sorted r (a :: l) := by\n  constructor\n  \u00b7 intro h\n    exact \u27e8rel_of_sorted_cons h _ mem_cons_self, h.of_cons\u27e9\n  \u00b7 rintro \u27e8h, ha\u27e9\n    exact ha.cons h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sort.lean", "context": {"open": ["List.Perm"], "variables": ["{\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a : \u03b1} {l : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\nSorted : x\u271d\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsTrans \u03b1 r\nl : List \u03b1\na b : \u03b1\n\u22a2 sorry \u2194 r b a \u2227 sorry"}, {"line": "constructor", "tactic_state": "case mp\n\u03b1 : Type u\nx\u271d : Sort u_1\nSorted : x\u271d\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsTrans \u03b1 r\nl : List \u03b1\na b : \u03b1\n\u22a2 sorry \u2192 r b a \u2227 sorry\n---\ncase mpr\n\u03b1 : Type u\nx\u271d : Sort u_1\nSorted : x\u271d\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsTrans \u03b1 r\nl : List \u03b1\na b : \u03b1\n\u22a2 r b a \u2227 sorry \u2192 sorry"}, {"line": "\u00b7 intro h\n    exact \u27e8rel_of_sorted_cons h _ mem_cons_self, h.of_cons\u27e9", "tactic_state": "case mpr\n\u03b1 : Type u\nx\u271d : Sort u_1\nSorted : x\u271d\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsTrans \u03b1 r\nl : List \u03b1\na b : \u03b1\n\u22a2 r b a \u2227 sorry \u2192 sorry"}, {"line": "\u00b7 rintro \u27e8h, ha\u27e9\n    exact ha.cons h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sorted_singleton (a : \u03b1) : Sorted r [a] := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sort.lean", "context": {"open": ["List.Perm"], "variables": ["{\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a : \u03b1} {l : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\nSorted : x\u271d\na : \u03b1\n\u22a2 sorry"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\nSorted : x\u271d\na : \u03b1\n\u22a2 sorry ()"}]}
{"declaration": "theorem sorted_le_replicate (n : \u2115) (a : \u03b1) [Preorder \u03b1] : Sorted (\u00b7 \u2264 \u00b7) (replicate n a) := by\n  simp [sorted_replicate]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sort.lean", "context": {"open": ["List.Perm"], "variables": ["{\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a : \u03b1} {l : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\nSorted : x\u271d\nn : \u2115\na : \u03b1\ninst\u271d : Preorder \u03b1\n\u22a2 sorry"}, {"line": "simp [sorted_replicate]", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\nSorted : x\u271d\nn : \u2115\na : \u03b1\ninst\u271d : Preorder \u03b1\n\u22a2 sorry ()"}]}
{"declaration": "theorem Sorted.decide [DecidableRel r] (l : List \u03b1) (h : Sorted r l) :\n    Sorted (fun a b => decide (r a b) = true) l := by\n  refine h.imp fun {a b} h => by simpa using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sort.lean", "context": {"open": ["List.Perm"], "variables": ["{\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a : \u03b1} {l : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_1\nSorted : x\u271d\ninst\u271d : DecidableRel r\nl : List \u03b1\nh : sorry\n\u22a2 sorry"}, {"line": "refine h.imp fun {a b} h => by simpa using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sorted_listMap (e : ra \u21aar rb) {l : List \u03b1} : (l.map e).Sorted rb \u2194 l.Sorted ra := by\n  simp [Sorted, pairwise_map, e.map_rel_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sort.lean", "context": {"open": ["List.Perm", "scoped Relator in", "List"], "variables": ["{\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a : \u03b1} {l : List \u03b1}", "{n : \u2115} {\u03b1 : Type u} {f : Fin n \u2192 \u03b1}", "[Preorder \u03b1]", "{\u03b1 \u03b2 : Type*} {ra : \u03b1 \u2192 \u03b1 \u2192 Prop} {rb : \u03b2 \u2192 \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nra : \u03b1 \u2192 \u03b1 \u2192 Prop\nrb : \u03b2 \u2192 \u03b2 \u2192 Prop\ne : ra \u21aar rb\nl : List \u03b1\n\u22a2 List.Sorted rb (List.map (\u21d1e) l) \u2194 List.Sorted ra l"}, {"line": "simp [Sorted, pairwise_map, e.map_rel_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sorted_swap_listMap (e : ra \u21aar rb) {l : List \u03b1} :\n    (l.map e).Sorted (Function.swap rb) \u2194 l.Sorted (Function.swap ra) := by\n  simp [Sorted, pairwise_map, e.map_rel_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sort.lean", "context": {"open": ["List.Perm", "scoped Relator in", "List"], "variables": ["{\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a : \u03b1} {l : List \u03b1}", "{n : \u2115} {\u03b1 : Type u} {f : Fin n \u2192 \u03b1}", "[Preorder \u03b1]", "{\u03b1 \u03b2 : Type*} {ra : \u03b1 \u2192 \u03b1 \u2192 Prop} {rb : \u03b2 \u2192 \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nra : \u03b1 \u2192 \u03b1 \u2192 Prop\nrb : \u03b2 \u2192 \u03b2 \u2192 Prop\ne : ra \u21aar rb\nl : List \u03b1\n\u22a2 List.Sorted (Function.swap rb) (List.map (\u21d1e) l) \u2194 List.Sorted (Function.swap ra) l"}, {"line": "simp [Sorted, pairwise_map, e.map_rel_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "example :\n    mergeSort [5, 27, 221, 95, 17, 43, 7, 2, 98, 567, 23, 12] (fun m n => m / 10 \u2264 n / 10) =\n      [5, 7, 2, 17, 12, 27, 23, 43, 95, 98, 221, 567] := by simp [mergeSort]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sort.lean", "context": {"open": ["List.Perm", "scoped Relator in", "List", "Perm"], "variables": ["{\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a : \u03b1} {l : List \u03b1}", "{n : \u2115} {\u03b1 : Type u} {f : Fin n \u2192 \u03b1}", "[Preorder \u03b1]", "{\u03b1 \u03b2 : Type*} {ra : \u03b1 \u2192 \u03b1 \u2192 Prop} {rb : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]", "{\u03b1 \u03b2 : Type*} {ra : \u03b1 \u2192 \u03b1 \u2192 Prop} {rb : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]", "{\u03b1 \u03b2 : Type*} [LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1}", "{\u03b1 \u03b2 : Type*} [LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop)", "[DecidableRel r] [DecidableRel s]", "{r}", "[IsTotal \u03b1 r] [IsTrans \u03b1 r]", "(r)", "[IsAntisymm \u03b1 r] [IsTotal \u03b1 r] [IsTrans \u03b1 r]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2077 : Type u\nr\u271d : \u03b1\u271d\u2077 \u2192 \u03b1\u271d\u2077 \u2192 Prop\na : \u03b1\u271d\u2077\nl\u271d\u00b9 : List \u03b1\u271d\u2077\nn : \u2115\n\u03b1\u271d\u2076 : Type u\nf\u271d\u00b9 : Fin n \u2192 \u03b1\u271d\u2076\ninst\u271d\u00b9\u2075 : Preorder \u03b1\u271d\u2076\n\u03b1\u271d\u2075 : Type u_1\n\u03b2\u271d\u2075 : Type u_2\nra\u271d : \u03b1\u271d\u2075 \u2192 \u03b1\u271d\u2075 \u2192 Prop\nrb\u271d : \u03b2\u271d\u2075 \u2192 \u03b2\u271d\u2075 \u2192 Prop\n\u03b1\u271d\u2074 : Type u_3\n\u03b2\u271d\u2074 : Type u_4\ninst\u271d\u00b9\u2074 : Preorder \u03b1\u271d\u2074\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\u271d\u2074\n\u03b1\u271d\u00b3 : Type u_5\n\u03b2\u271d\u00b3 : Type u_6\nra : \u03b1\u271d\u00b3 \u2192 \u03b1\u271d\u00b3 \u2192 Prop\nrb : \u03b2\u271d\u00b3 \u2192 \u03b2\u271d\u00b3 \u2192 Prop\n\u03b1\u271d\u00b2 : Type u_7\n\u03b2\u271d\u00b2 : Type u_8\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\u271d\u00b2\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\u271d\u00b2\n\u03b1\u271d\u00b9 : Type u_9\n\u03b2\u271d\u00b9 : Type u_10\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2079 : Preorder \u03b2\u271d\u00b9\nf\u271d : \u03b1\u271d\u00b9 \u2192 \u03b2\u271d\u00b9\nl\u271d : List \u03b1\u271d\u00b9\n\u03b1\u271d : Type u_11\n\u03b2\u271d : Type u_12\ninst\u271d\u2078 : LinearOrder \u03b1\u271d\ninst\u271d\u2077 : Preorder \u03b2\u271d\nf : \u03b1\u271d \u2192 \u03b2\u271d\nl : List \u03b1\u271d\n\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u2076 : DecidableRel r\ninst\u271d\u2075 : DecidableRel s\ninst\u271d\u2074 : IsTotal \u03b1 r\ninst\u271d\u00b3 : IsTrans \u03b1 r\ninst\u271d\u00b2 : IsAntisymm \u03b1 r\ninst\u271d\u00b9 : IsTotal \u03b1 r\ninst\u271d : IsTrans \u03b1 r\nx\u271d : Sort u_13\nmergeSort : x\u271d\n\u22a2 sorry = [5, 7, 2, 17, 12, 27, 23, 43, 95, 98, 221, 567]"}, {"line": "simp [mergeSort]", "tactic_state": "\u03b1\u271d\u2077 : Type u\nr\u271d : \u03b1\u271d\u2077 \u2192 \u03b1\u271d\u2077 \u2192 Prop\na : \u03b1\u271d\u2077\nl\u271d\u00b9 : List \u03b1\u271d\u2077\nn : \u2115\n\u03b1\u271d\u2076 : Type u\nf\u271d\u00b9 : Fin n \u2192 \u03b1\u271d\u2076\ninst\u271d\u00b9\u2075 : Preorder \u03b1\u271d\u2076\n\u03b1\u271d\u2075 : Type u_1\n\u03b2\u271d\u2075 : Type u_2\nra\u271d : \u03b1\u271d\u2075 \u2192 \u03b1\u271d\u2075 \u2192 Prop\nrb\u271d : \u03b2\u271d\u2075 \u2192 \u03b2\u271d\u2075 \u2192 Prop\n\u03b1\u271d\u2074 : Type u_3\n\u03b2\u271d\u2074 : Type u_4\ninst\u271d\u00b9\u2074 : Preorder \u03b1\u271d\u2074\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\u271d\u2074\n\u03b1\u271d\u00b3 : Type u_5\n\u03b2\u271d\u00b3 : Type u_6\nra : \u03b1\u271d\u00b3 \u2192 \u03b1\u271d\u00b3 \u2192 Prop\nrb : \u03b2\u271d\u00b3 \u2192 \u03b2\u271d\u00b3 \u2192 Prop\n\u03b1\u271d\u00b2 : Type u_7\n\u03b2\u271d\u00b2 : Type u_8\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\u271d\u00b2\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\u271d\u00b2\n\u03b1\u271d\u00b9 : Type u_9\n\u03b2\u271d\u00b9 : Type u_10\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\u271d\u00b9\ninst\u271d\u2079 : Preorder \u03b2\u271d\u00b9\nf\u271d : \u03b1\u271d\u00b9 \u2192 \u03b2\u271d\u00b9\nl\u271d : List \u03b1\u271d\u00b9\n\u03b1\u271d : Type u_11\n\u03b2\u271d : Type u_12\ninst\u271d\u2078 : LinearOrder \u03b1\u271d\ninst\u271d\u2077 : Preorder \u03b2\u271d\nf : \u03b1\u271d \u2192 \u03b2\u271d\nl : List \u03b1\u271d\n\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u2076 : DecidableRel r\ninst\u271d\u2075 : DecidableRel s\ninst\u271d\u2074 : IsTotal \u03b1 r\ninst\u271d\u00b3 : IsTrans \u03b1 r\ninst\u271d\u00b2 : IsAntisymm \u03b1 r\ninst\u271d\u00b9 : IsTotal \u03b1 r\ninst\u271d : IsTrans \u03b1 r\nx\u271d : Sort u_13\nmergeSort : x\u271d\n\u22a2 sorry () = [5, 7, 2, 17, 12, 27, 23, 43, 95, 98, 221, 567]"}]}
{"declaration": "theorem Sorted.merge {l l' : List \u03b1} (h : Sorted r l) (h' : Sorted r l') :\n    Sorted r (merge l l' (r \u00b7 \u00b7)) := by\n  simpa using sorted_merge (le := (r \u00b7 \u00b7))\n    (fun a b c h\u2081 h\u2082 => by simpa using _root_.trans (by simpa using h\u2081) (by simpa using h\u2082))\n    (fun a b => by simpa using IsTotal.total a b)\n    l l' (by simpa using h) (by simpa using h')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sort.lean", "context": {"open": ["List.Perm", "scoped Relator in", "List", "Perm"], "variables": ["{\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a : \u03b1} {l : List \u03b1}", "{n : \u2115} {\u03b1 : Type u} {f : Fin n \u2192 \u03b1}", "[Preorder \u03b1]", "{\u03b1 \u03b2 : Type*} {ra : \u03b1 \u2192 \u03b1 \u2192 Prop} {rb : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]", "{\u03b1 \u03b2 : Type*} {ra : \u03b1 \u2192 \u03b1 \u2192 Prop} {rb : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]", "{\u03b1 \u03b2 : Type*} [LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1}", "{\u03b1 \u03b2 : Type*} [LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop)", "[DecidableRel r] [DecidableRel s]", "{r}", "[IsTotal \u03b1 r] [IsTrans \u03b1 r]", "(r)", "[IsAntisymm \u03b1 r] [IsTotal \u03b1 r] [IsTrans \u03b1 r]", "{r} [IsTotal \u03b1 r] [IsTrans \u03b1 r]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_13\nSorted : x\u271d\nl l' : List \u03b1\nh : sorry\nh' : sorry\n\u22a2 sorry"}, {"line": "simpa using sorted_merge (le := (r \u00b7 \u00b7))\n    (fun a b c h\u2081 h\u2082 => by simpa using _root_.trans (by simpa using h\u2081) (by simpa using h\u2082))\n    (fun a b => by simpa using IsTotal.total a b)\n    l l' (by simpa using h) (by simpa using h')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sorted_mergeSort' (l : List \u03b1) : Sorted r (mergeSort l (r \u00b7 \u00b7)) := by\n  simpa using sorted_mergeSort (le := (r \u00b7 \u00b7))\n    (fun _ _ _ => by simpa using trans_of r)\n    (by simpa using total_of r)\n    l\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sort.lean", "context": {"open": ["List.Perm", "scoped Relator in", "List", "Perm"], "variables": ["{\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a : \u03b1} {l : List \u03b1}", "{n : \u2115} {\u03b1 : Type u} {f : Fin n \u2192 \u03b1}", "[Preorder \u03b1]", "{\u03b1 \u03b2 : Type*} {ra : \u03b1 \u2192 \u03b1 \u2192 Prop} {rb : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]", "{\u03b1 \u03b2 : Type*} {ra : \u03b1 \u2192 \u03b1 \u2192 Prop} {rb : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]", "{\u03b1 \u03b2 : Type*} [LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1}", "{\u03b1 \u03b2 : Type*} [LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : List \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop)", "[DecidableRel r] [DecidableRel s]", "{r}", "[IsTotal \u03b1 r] [IsTrans \u03b1 r]", "(r)", "[IsAntisymm \u03b1 r] [IsTotal \u03b1 r] [IsTrans \u03b1 r]", "{r} [IsTotal \u03b1 r] [IsTrans \u03b1 r]", "(r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_13\nSorted : x\u271d\nl : List \u03b1\n\u22a2 sorry"}, {"line": "simpa using sorted_mergeSort (le := (r \u00b7 \u00b7))\n    (fun _ _ _ => by simpa using trans_of r)\n    (by simpa using total_of r)\n    l", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ne_nil_of_mem_splitBy (r : \u03b1 \u2192 \u03b1 \u2192 Bool) {l : List \u03b1} (h : m \u2208 l.splitBy r) : m \u2260 [] := by\n  rintro rfl\n  exact nil_not_mem_splitBy r l h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/SplitBy.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {m : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Bool\nl : List \u03b1\nh : m \u2208 List.splitBy r l\n\u22a2 m \u2260 []"}, {"line": "rintro rfl", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Bool\nl : List \u03b1\nh : [] \u2208 List.splitBy r l\n\u22a2 False"}, {"line": "exact nil_not_mem_splitBy r l h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sublists'_cons (a : \u03b1) (l : List \u03b1) :\n    sublists' (a :: l) = sublists' l ++ map (cons a) (sublists' l) := by\n  simp [sublists'_eq_sublists'Aux, foldr_cons, sublists'Aux_eq_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sublists.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nsublists' : x\u271d\u00b9\nx\u271d : Sort u_2\nmap : x\u271d\na : \u03b1\nl : List \u03b1\n\u22a2 sorry = sorry ++ sorry"}, {"line": "simp [sublists'_eq_sublists'Aux, foldr_cons, sublists'Aux_eq_map]", "tactic_state": "\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nsublists' : x\u271d\u00b9\nx\u271d : Sort u_2\nmap : x\u271d\na : \u03b1\nl : List \u03b1\n\u22a2 sorry () = sorry () ++ sorry ()"}]}
{"declaration": "theorem nodup_sublistsLen (n : \u2115) {l : List \u03b1} (h : Nodup l) : (sublistsLen n l).Nodup := by\n  have : Pairwise (\u00b7 \u2260 \u00b7) l.sublists' := Pairwise.imp\n    (fun h => Lex.to_ne (by convert h using 3; simp [swap, eq_comm])) h.sublists'\n  exact this.sublist (sublistsLen_sublist_sublists' _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sublists.lean", "context": {"open": ["Nat", "Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nNodup : x\u271d\u00b9\nx\u271d : Sort u_2\nsublistsLen : x\u271d\nn : \u2115\nl : List \u03b1\nh : sorry\n\u22a2 sorry"}, {"line": "have : Pairwise (\u00b7 \u2260 \u00b7) l.sublists' := Pairwise.imp\n    (fun h => Lex.to_ne (by convert h using 3; simp [swap, eq_comm])) h.sublists'", "tactic_state": "\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nNodup : x\u271d\u00b9\nx\u271d : Sort u_2\nsublistsLen : x\u271d\nn : \u2115\nl : List \u03b1\nh : sorry\nthis : sorry\n\u22a2 sorry"}, {"line": "exact this.sublist (sublistsLen_sublist_sublists' _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sym2_eq_nil_iff {xs : List \u03b1} : xs.sym2 = [] \u2194 xs = [] := by\n  cases xs <;> simp [List.sym2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sym.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nxs : List \u03b1\n\u22a2 xs.sym2 = [] \u2194 xs = []"}, {"line": "cases xs <;> simp [List.sym2]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem right_mem_of_mk_mem_sym2 {xs : List \u03b1} {a b : \u03b1}\n    (h : s(a, b) \u2208 xs.sym2) : b \u2208 xs := by\n  rw [Sym2.eq_swap] at h\n  exact left_mem_of_mk_mem_sym2 h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sym.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nxs : List \u03b1\na b : \u03b1\nh : s(a, b) \u2208 xs.sym2\n\u22a2 b \u2208 xs"}, {"line": "rw [Sym2.eq_swap] at h", "tactic_state": "\u03b1 : Type u_1\nxs : List \u03b1\na b : \u03b1\nh : s(b, a) \u2208 xs.sym2\n\u22a2 b \u2208 xs"}, {"line": "exact left_mem_of_mk_mem_sym2 h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_mem_sym2_iff {xs : List \u03b1} {a b : \u03b1} :\n    s(a, b) \u2208 xs.sym2 \u2194 a \u2208 xs \u2227 b \u2208 xs := by\n  constructor\n  \u00b7 intro h\n    exact \u27e8left_mem_of_mk_mem_sym2 h, right_mem_of_mk_mem_sym2 h\u27e9\n  \u00b7 rintro \u27e8ha, hb\u27e9\n    exact mk_mem_sym2 ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sym.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nxs : List \u03b1\na b : \u03b1\n\u22a2 s(a, b) \u2208 xs.sym2 \u2194 a \u2208 xs \u2227 b \u2208 xs"}, {"line": "constructor", "tactic_state": "case mp\n\u03b1 : Type u_1\nxs : List \u03b1\na b : \u03b1\n\u22a2 s(a, b) \u2208 xs.sym2 \u2192 a \u2208 xs \u2227 b \u2208 xs\n---\ncase mpr\n\u03b1 : Type u_1\nxs : List \u03b1\na b : \u03b1\n\u22a2 a \u2208 xs \u2227 b \u2208 xs \u2192 s(a, b) \u2208 xs.sym2"}, {"line": "\u00b7 intro h\n    exact \u27e8left_mem_of_mk_mem_sym2 h, right_mem_of_mk_mem_sym2 h\u27e9", "tactic_state": "case mpr\n\u03b1 : Type u_1\nxs : List \u03b1\na b : \u03b1\n\u22a2 a \u2208 xs \u2227 b \u2208 xs \u2192 s(a, b) \u2208 xs.sym2"}, {"line": "\u00b7 rintro \u27e8ha, hb\u27e9\n    exact mk_mem_sym2 ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_sym2_iff {xs : List \u03b1} {z : Sym2 \u03b1} :\n    z \u2208 xs.sym2 \u2194 \u2200 y \u2208 z, y \u2208 xs := by\n  refine z.ind (fun a b => ?_)\n  simp [mk_mem_sym2_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/Sym.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nxs : List \u03b1\nz : Sym2 \u03b1\n\u22a2 z \u2208 xs.sym2 \u2194 \u2200 y \u2208 z, y \u2208 xs"}, {"line": "refine z.ind (fun a b => ?_)", "tactic_state": "\u03b1 : Type u_1\nxs : List \u03b1\nz : Sym2 \u03b1\na b : \u03b1\n\u22a2 s(a, b) \u2208 xs.sym2 \u2194 \u2200 y \u2208 s(a, b), y \u2208 xs"}, {"line": "simp [mk_mem_sym2_iff]", "tactic_state": "\u03b1 : Type u_1\nxs : List \u03b1\nz : Sym2 \u03b1\na b : \u03b1\n\u22a2 s(a, b) \u2208 xs.sym2 \u2194 a \u2208 xs \u2227 b \u2208 xs"}]}
{"declaration": "theorem tfae_singleton (p) : TFAE [p] := by simp [TFAE, -eq_iff_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/TFAE.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nTFAE : x\u271d\np : ?m.419\n\u22a2 sorry"}, {"line": "simp [TFAE, -eq_iff_iff]", "tactic_state": "x\u271d : Sort u_1\nTFAE : x\u271d\np : ?m.419\n\u22a2 sorry ()"}]}
{"declaration": "theorem tfae_cons_self {a} {l : List Prop} : TFAE (a :: a :: l) \u2194 TFAE (a :: l) := by\n  simp [tfae_cons_cons]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/TFAE.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nTFAE : x\u271d\na : ?m.830\nl : List Prop\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [tfae_cons_cons]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem suffixLevenshtein_eq (xs : List \u03b1) (y ys) :\n    impl C xs y (suffixLevenshtein C xs ys) = suffixLevenshtein C xs (y :: ys) := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/EditDistance/Defs.lean", "context": {"open": ["Levenshtein"], "variables": ["{\u03b1 \u03b2 \u03b4 : Type*} [AddZeroClass \u03b4] [Min \u03b4]", "(C : Cost \u03b1 \u03b2 \u03b4)", "{C}", "(x : \u03b1) (xs : List \u03b1) (y : \u03b2) (d : \u03b4) (ds : List \u03b4) (w : 0 < (d :: ds).length)", "(C : Cost \u03b1 \u03b2 \u03b4)", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\ninst\u271d\u00b9 : AddZeroClass \u03b4\ninst\u271d : Min \u03b4\nC : Cost \u03b1 \u03b2 \u03b4\nxs : List \u03b1\ny : \u03b2\nys : List \u03b2\n\u22a2 Levenshtein.impl C xs y (suffixLevenshtein C xs ys) = suffixLevenshtein C xs (y :: ys)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem suffixLevenshtein_nil_nil : (suffixLevenshtein C [] []).1 = [0] := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/EditDistance/Defs.lean", "context": {"open": ["Levenshtein"], "variables": ["{\u03b1 \u03b2 \u03b4 : Type*} [AddZeroClass \u03b4] [Min \u03b4]", "(C : Cost \u03b1 \u03b2 \u03b4)", "{C}", "(x : \u03b1) (xs : List \u03b1) (y : \u03b2) (d : \u03b4) (ds : List \u03b4) (w : 0 < (d :: ds).length)", "(C : Cost \u03b1 \u03b2 \u03b4)", "{C}", "(C)", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\ninst\u271d\u00b9 : AddZeroClass \u03b4\ninst\u271d : Min \u03b4\nC : Cost \u03b1 \u03b2 \u03b4\n\u22a2 \u2191(suffixLevenshtein C [] []) = [0]"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem suffixLevenshtein_cons\u2081_fst (x : \u03b1) (xs ys) :\n    (suffixLevenshtein C (x :: xs) ys).1 =\n      levenshtein C (x :: xs) ys ::\n        (suffixLevenshtein C xs ys).1 := by\n  simp [suffixLevenshtein_cons\u2081]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/EditDistance/Defs.lean", "context": {"open": ["Levenshtein"], "variables": ["{\u03b1 \u03b2 \u03b4 : Type*} [AddZeroClass \u03b4] [Min \u03b4]", "(C : Cost \u03b1 \u03b2 \u03b4)", "{C}", "(x : \u03b1) (xs : List \u03b1) (y : \u03b2) (d : \u03b4) (ds : List \u03b4) (w : 0 < (d :: ds).length)", "(C : Cost \u03b1 \u03b2 \u03b4)", "{C}", "(C)", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\ninst\u271d\u00b9 : AddZeroClass \u03b4\ninst\u271d : Min \u03b4\nC : Cost \u03b1 \u03b2 \u03b4\nx : \u03b1\nxs : List \u03b1\nys : List \u03b2\n\u22a2 \u2191(suffixLevenshtein C (x :: xs) ys) = levenshtein C (x :: xs) ys :: \u2191(suffixLevenshtein C xs ys)"}, {"line": "simp [suffixLevenshtein_cons\u2081]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem levenshtein_nil_nil : levenshtein C [] [] = 0 := by\n  simp [levenshtein, suffixLevenshtein]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/List/EditDistance/Defs.lean", "context": {"open": ["Levenshtein"], "variables": ["{\u03b1 \u03b2 \u03b4 : Type*} [AddZeroClass \u03b4] [Min \u03b4]", "(C : Cost \u03b1 \u03b2 \u03b4)", "{C}", "(x : \u03b1) (xs : List \u03b1) (y : \u03b2) (d : \u03b4) (ds : List \u03b4) (w : 0 < (d :: ds).length)", "(C : Cost \u03b1 \u03b2 \u03b4)", "{C}", "(C)", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\ninst\u271d\u00b9 : AddZeroClass \u03b4\ninst\u271d : Min \u03b4\nC : Cost \u03b1 \u03b2 \u03b4\n\u22a2 levenshtein C [] [] = 0"}, {"line": "simp [levenshtein, suffixLevenshtein]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zero_le_one_elem [Preorder \u03b1] [ZeroLEOneClass \u03b1] (i j : n) :\n    0 \u2264 (1 : Matrix n n \u03b1) i j := by\n  by_cases hi : i = j\n  \u00b7 subst hi\n    simp\n  \u00b7 simp [hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Basic.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "(R)", "[DecidableEq n]", "(n \u03b1)", "(R)", "{n \u03b1 R}", "[Zero \u03b1] [One \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\n\u03b1 : Type v\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ZeroLEOneClass \u03b1\ni j : n\n\u22a2 0 \u2264 1 i j"}, {"line": "by_cases hi : i = j", "tactic_state": "case pos\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ZeroLEOneClass \u03b1\ni j : n\nhi : i = j\n\u22a2 0 \u2264 1 i j\n---\ncase neg\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ZeroLEOneClass \u03b1\ni j : n\nhi : \u00aci = j\n\u22a2 0 \u2264 1 i j"}, {"line": "\u00b7 subst hi\n    simp", "tactic_state": "case neg\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ZeroLEOneClass \u03b1\ni j : n\nhi : \u00aci = j\n\u22a2 0 \u2264 1 i j"}, {"line": "\u00b7 simp [hi]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem algebraMap_matrix_apply {r : R} {i j : n} :\n    algebraMap R (Matrix n n \u03b1) r i j = if i = j then algebraMap R \u03b1 r else 0 := by\n  dsimp [algebraMap, Algebra.algebraMap, Matrix.scalar]\n  split_ifs with h <;> simp [h, Matrix.one_apply_ne]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Basic.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "(R)", "[DecidableEq n]", "(n \u03b1)", "(R)", "{n \u03b1 R}", "[Zero \u03b1] [One \u03b1]", "(n \u03b1)", "(R)", "{n \u03b1 R}", "[AddCommMonoid \u03b1] [Mul \u03b1]", "[NonAssocSemiring \u03b1]", "(\u03b1 n)", "[Semiring \u03b1]", "[DecidableEq n] [Fintype n]", "[Fintype n] [DecidableEq n]", "[CommSemiring R] [Semiring \u03b1] [Semiring \u03b2] [Algebra R \u03b1] [Algebra R \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\nR : Type u_7\n\u03b1 : Type v\ninst\u271d\u00b9\u00b3 : DecidableEq n\ninst\u271d\u00b9\u00b2 : Zero \u03b1\ninst\u271d\u00b9\u00b9 : One \u03b1\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 : NonAssocSemiring \u03b1\ninst\u271d\u2077 : Semiring \u03b1\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 inst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : Algebra R \u03b1\nr : R\ni j : n\n\u22a2 (algebraMap R (Matrix n n \u03b1)) r i j = if i = j then (algebraMap R \u03b1) r else 0"}, {"line": "dsimp [algebraMap, Algebra.algebraMap, Matrix.scalar]", "tactic_state": "n : Type u_3\nR : Type u_7\n\u03b1 : Type v\ninst\u271d\u00b9\u00b3 : DecidableEq n\ninst\u271d\u00b9\u00b2 : Zero \u03b1\ninst\u271d\u00b9\u00b9 : One \u03b1\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 : NonAssocSemiring \u03b1\ninst\u271d\u2077 : Semiring \u03b1\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 inst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : Algebra R \u03b1\nr : R\ni j : n\n\u22a2 diagonal ((Pi.constRingHom n \u03b1) (Algebra.algebraMap r)) i j = if i = j then Algebra.algebraMap r else 0"}, {"line": "split_ifs with h <;> simp [h, Matrix.one_apply_ne]", "tactic_state": "case neg\nn : Type u_3\nR : Type u_7\n\u03b1 : Type v\ninst\u271d\u00b9\u00b3 : DecidableEq n\ninst\u271d\u00b9\u00b2 : Zero \u03b1\ninst\u271d\u00b9\u00b9 : One \u03b1\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 : NonAssocSemiring \u03b1\ninst\u271d\u2077 : Semiring \u03b1\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 inst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : Algebra R \u03b1\nr : R\ni j : n\nh : \u00aci = j\n\u22a2 0 = 0"}]}
{"declaration": "lemma entryAddMonoidHom_eq_comp {i : m} {j : n} :\n    entryAddMonoidHom \u03b1 i j =\n      ((Pi.evalAddMonoidHom (fun _ => \u03b1) j).comp (Pi.evalAddMonoidHom _ i)).comp\n        (AddMonoidHomClass.toAddMonoidHom ofAddEquiv.symm) := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Basic.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "(R)", "[DecidableEq n]", "(n \u03b1)", "(R)", "{n \u03b1 R}", "[Zero \u03b1] [One \u03b1]", "(n \u03b1)", "(R)", "{n \u03b1 R}", "[AddCommMonoid \u03b1] [Mul \u03b1]", "[NonAssocSemiring \u03b1]", "(\u03b1 n)", "[Semiring \u03b1]", "[DecidableEq n] [Fintype n]", "[Fintype n] [DecidableEq n]", "[CommSemiring R] [Semiring \u03b1] [Semiring \u03b2] [Algebra R \u03b1] [Algebra R \u03b2]", "(R)", "[Add \u03b1]", "(R \u03b1) in", "[AddZeroClass \u03b1]", "(R \u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b9\u00b2 : DecidableEq n\ninst\u271d\u00b9\u00b9 : Zero \u03b1\ninst\u271d\u00b9\u2070 : One \u03b1\ninst\u271d\u2079 : AddCommMonoid \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 : NonAssocSemiring \u03b1\ninst\u271d\u2076 : Semiring \u03b1\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 inst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : Add \u03b1\ni : m\nj : n\n\u22a2 entryAddMonoidHom \u03b1 i j =\n    ((Pi.evalAddMonoidHom (fun x => \u03b1) j).comp (Pi.evalAddMonoidHom (fun i => n \u2192 \u03b1) i)).comp \u2191ofAddEquiv.symm"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fromBlocks_toBlocks (M : Matrix (n \u2295 o) (l \u2295 m) \u03b1) :\n    fromBlocks M.toBlocks\u2081\u2081 M.toBlocks\u2081\u2082 M.toBlocks\u2082\u2081 M.toBlocks\u2082\u2082 = M := by\n  ext i j\n  rcases i with \u27e8\u27e9 <;> rcases j with \u27e8\u27e9 <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\nM : Matrix (n \u2295 o) (l \u2295 m) \u03b1\n\u22a2 fromBlocks M.toBlocks\u2081\u2081 M.toBlocks\u2081\u2082 M.toBlocks\u2082\u2081 M.toBlocks\u2082\u2082 = M"}, {"line": "ext i j", "tactic_state": "case a\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\nM : Matrix (n \u2295 o) (l \u2295 m) \u03b1\ni : n \u2295 o\nj : l \u2295 m\n\u22a2 fromBlocks M.toBlocks\u2081\u2081 M.toBlocks\u2081\u2082 M.toBlocks\u2082\u2081 M.toBlocks\u2082\u2082 i j = M i j"}, {"line": "rcases i with \u27e8\u27e9 <;> rcases j with \u27e8\u27e9 <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fromBlocks_transpose (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) : (fromBlocks A B C D)\u1d40 = fromBlocks A\u1d40 C\u1d40 B\u1d40 D\u1d40 := by\n  ext i j\n  rcases i with \u27e8\u27e9 <;> rcases j with \u27e8\u27e9 <;> simp [fromBlocks]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\n\u22a2 (fromBlocks A B C D).transpose = fromBlocks A.transpose C.transpose B.transpose D.transpose"}, {"line": "ext i j", "tactic_state": "case a\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\ni : l \u2295 m\nj : n \u2295 o\n\u22a2 (fromBlocks A B C D).transpose i j = fromBlocks A.transpose C.transpose B.transpose D.transpose i j"}, {"line": "rcases i with \u27e8\u27e9 <;> rcases j with \u27e8\u27e9 <;> simp [fromBlocks]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fromBlocks_conjTranspose [Star \u03b1] (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) : (fromBlocks A B C D)\u1d34 = fromBlocks A\u1d34 C\u1d34 B\u1d34 D\u1d34 := by\n  simp only [conjTranspose]\n  simp only [fromBlocks_transpose]\n  simp only [fromBlocks_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d : Star \u03b1\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\n\u22a2 (fromBlocks A B C D).conjTranspose = fromBlocks A.conjTranspose C.conjTranspose B.conjTranspose D.conjTranspose"}, {"line": "simp only [conjTranspose]", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d : Star \u03b1\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\n\u22a2 (fromBlocks A B C D).transpose.map star =\n    fromBlocks (A.transpose.map star) (C.transpose.map star) (B.transpose.map star) (D.transpose.map star)"}, {"line": "simp only [fromBlocks_transpose]", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d : Star \u03b1\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\n\u22a2 (fromBlocks A.transpose C.transpose B.transpose D.transpose).map star =\n    fromBlocks (A.transpose.map star) (C.transpose.map star) (B.transpose.map star) (D.transpose.map star)"}, {"line": "simp only [fromBlocks_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fromBlocks_submatrix_sum_swap_left (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) (f : p \u2192 l \u2295 m) :\n    (fromBlocks A B C D).submatrix Sum.swap f = (fromBlocks C D A B).submatrix id f := by\n  ext i j\n  cases i <;> dsimp <;> cases f j <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\n\u03b1 : Type u_12\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\nf : p \u2192 l \u2295 m\n\u22a2 (fromBlocks A B C D).submatrix Sum.swap f = (fromBlocks C D A B).submatrix id f"}, {"line": "ext i j", "tactic_state": "case a\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\n\u03b1 : Type u_12\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\nf : p \u2192 l \u2295 m\ni : o \u2295 n\nj : p\n\u22a2 (fromBlocks A B C D).submatrix Sum.swap f i j = (fromBlocks C D A B).submatrix id f i j"}, {"line": "cases i <;> dsimp <;> cases f j <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fromBlocks_submatrix_sum_swap_right (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) (f : p \u2192 n \u2295 o) :\n    (fromBlocks A B C D).submatrix f Sum.swap = (fromBlocks B A D C).submatrix f id := by\n  ext i j\n  cases j <;> dsimp <;> cases f i <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\n\u03b1 : Type u_12\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\nf : p \u2192 n \u2295 o\n\u22a2 (fromBlocks A B C D).submatrix f Sum.swap = (fromBlocks B A D C).submatrix f id"}, {"line": "ext i j", "tactic_state": "case a\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\n\u03b1 : Type u_12\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\nf : p \u2192 n \u2295 o\ni : p\nj : m \u2295 l\n\u22a2 (fromBlocks A B C D).submatrix f Sum.swap i j = (fromBlocks B A D C).submatrix f id i j"}, {"line": "cases j <;> dsimp <;> cases f i <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fromBlocks_submatrix_sum_swap_sum_swap {l m n o \u03b1 : Type*} (A : Matrix n l \u03b1)\n    (B : Matrix n m \u03b1) (C : Matrix o l \u03b1) (D : Matrix o m \u03b1) :\n    (fromBlocks A B C D).submatrix Sum.swap Sum.swap = fromBlocks D C B A := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_14\nm : Type u_15\nn : Type u_16\no : Type u_17\n\u03b1 : Type u_18\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\n\u22a2 (fromBlocks A B C D).submatrix Sum.swap Sum.swap = fromBlocks D C B A"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fromBlocks_neg [Neg R] (A : Matrix n l R) (B : Matrix n m R) (C : Matrix o l R)\n    (D : Matrix o m R) : -fromBlocks A B C D = fromBlocks (-A) (-B) (-C) (-D) := by\n  ext i j\n  cases i <;> cases j <;> simp [fromBlocks]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_10\ninst\u271d : Neg R\nA : Matrix n l R\nB : Matrix n m R\nC : Matrix o l R\nD : Matrix o m R\n\u22a2 -fromBlocks A B C D = fromBlocks (-A) (-B) (-C) (-D)"}, {"line": "ext i j", "tactic_state": "case a\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_10\ninst\u271d : Neg R\nA : Matrix n l R\nB : Matrix n m R\nC : Matrix o l R\nD : Matrix o m R\ni : n \u2295 o\nj : l \u2295 m\n\u22a2 (-fromBlocks A B C D) i j = fromBlocks (-A) (-B) (-C) (-D) i j"}, {"line": "cases i <;> cases j <;> simp [fromBlocks]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fromBlocks_zero [Zero \u03b1] : fromBlocks (0 : Matrix n l \u03b1) 0 0 (0 : Matrix o m \u03b1) = 0 := by\n  ext i j\n  rcases i with \u27e8\u27e9 <;> rcases j with \u27e8\u27e9 <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d : Zero \u03b1\n\u22a2 fromBlocks 0 0 0 0 = 0"}, {"line": "ext i j", "tactic_state": "case a\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d : Zero \u03b1\ni : n \u2295 o\nj : l \u2295 m\n\u22a2 fromBlocks 0 0 0 0 i j = 0 i j"}, {"line": "rcases i with \u27e8\u27e9 <;> rcases j with \u27e8\u27e9 <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fromBlocks_multiply [Fintype l] [Fintype m] [NonUnitalNonAssocSemiring \u03b1] (A : Matrix n l \u03b1)\n    (B : Matrix n m \u03b1) (C : Matrix o l \u03b1) (D : Matrix o m \u03b1) (A' : Matrix l p \u03b1) (B' : Matrix l q \u03b1)\n    (C' : Matrix m p \u03b1) (D' : Matrix m q \u03b1) :\n    fromBlocks A B C D * fromBlocks A' B' C' D' =\n      fromBlocks (A * A' + B * C') (A * B' + B * D') (C * A' + D * C') (C * B' + D * D') := by\n  ext i j\n  rcases i with \u27e8\u27e9 <;> rcases j with \u27e8\u27e9 <;> simp only [fromBlocks, mul_apply, of_apply,\n      Sum.elim_inr, Fintype.sum_sum_type, Sum.elim_inl, add_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nq : Type u_6\n\u03b1 : Type u_12\ninst\u271d\u00b2 : Fintype l\ninst\u271d\u00b9 : Fintype m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\nA' : Matrix l p \u03b1\nB' : Matrix l q \u03b1\nC' : Matrix m p \u03b1\nD' : Matrix m q \u03b1\n\u22a2 fromBlocks A B C D * fromBlocks A' B' C' D' =\n    fromBlocks (A * A' + B * C') (A * B' + B * D') (C * A' + D * C') (C * B' + D * D')"}, {"line": "ext i j", "tactic_state": "case a\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nq : Type u_6\n\u03b1 : Type u_12\ninst\u271d\u00b2 : Fintype l\ninst\u271d\u00b9 : Fintype m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\nA' : Matrix l p \u03b1\nB' : Matrix l q \u03b1\nC' : Matrix m p \u03b1\nD' : Matrix m q \u03b1\ni : n \u2295 o\nj : p \u2295 q\n\u22a2 (fromBlocks A B C D * fromBlocks A' B' C' D') i j =\n    fromBlocks (A * A' + B * C') (A * B' + B * D') (C * A' + D * C') (C * B' + D * D') i j"}, {"line": "rcases i with \u27e8\u27e9 <;> rcases j with \u27e8\u27e9 <;> simp only [fromBlocks, mul_apply, of_apply,\n      Sum.elim_inr, Fintype.sum_sum_type, Sum.elim_inl, add_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fromBlocks_mulVec [Fintype l] [Fintype m] [NonUnitalNonAssocSemiring \u03b1] (A : Matrix n l \u03b1)\n    (B : Matrix n m \u03b1) (C : Matrix o l \u03b1) (D : Matrix o m \u03b1) (x : l \u2295 m \u2192 \u03b1) :\n    (fromBlocks A B C D) *\u1d65 x =\n      Sum.elim (A *\u1d65 (x \u2218 Sum.inl) + B *\u1d65 (x \u2218 Sum.inr))\n        (C *\u1d65 (x \u2218 Sum.inl) + D *\u1d65 (x \u2218 Sum.inr)) := by\n  ext i\n  cases i <;> simp [mulVec, dotProduct]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u00b2 : Fintype l\ninst\u271d\u00b9 : Fintype m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\nx : l \u2295 m \u2192 \u03b1\n\u22a2 (fromBlocks A B C D).mulVec x =\n    Sum.elim (A.mulVec (x \u2218 Sum.inl) + B.mulVec (x \u2218 Sum.inr)) (C.mulVec (x \u2218 Sum.inl) + D.mulVec (x \u2218 Sum.inr))"}, {"line": "ext i", "tactic_state": "case h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u00b2 : Fintype l\ninst\u271d\u00b9 : Fintype m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\nx : l \u2295 m \u2192 \u03b1\ni : n \u2295 o\n\u22a2 (fromBlocks A B C D).mulVec x i =\n    Sum.elim (A.mulVec (x \u2218 Sum.inl) + B.mulVec (x \u2218 Sum.inr)) (C.mulVec (x \u2218 Sum.inl) + D.mulVec (x \u2218 Sum.inr)) i"}, {"line": "cases i <;> simp [mulVec, dotProduct]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vecMul_fromBlocks [Fintype n] [Fintype o] [NonUnitalNonAssocSemiring \u03b1] (A : Matrix n l \u03b1)\n    (B : Matrix n m \u03b1) (C : Matrix o l \u03b1) (D : Matrix o m \u03b1) (x : n \u2295 o \u2192 \u03b1) :\n    x \u1d65* fromBlocks A B C D =\n      Sum.elim ((x \u2218 Sum.inl) \u1d65* A + (x \u2218 Sum.inr) \u1d65* C)\n        ((x \u2218 Sum.inl) \u1d65* B + (x \u2218 Sum.inr) \u1d65* D) := by\n  ext i\n  cases i <;> simp [vecMul, dotProduct]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : Fintype o\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\nx : n \u2295 o \u2192 \u03b1\n\u22a2 vecMul x (fromBlocks A B C D) =\n    Sum.elim (vecMul (x \u2218 Sum.inl) A + vecMul (x \u2218 Sum.inr) C) (vecMul (x \u2218 Sum.inl) B + vecMul (x \u2218 Sum.inr) D)"}, {"line": "ext i", "tactic_state": "case h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : Fintype o\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\nx : n \u2295 o \u2192 \u03b1\ni : l \u2295 m\n\u22a2 vecMul x (fromBlocks A B C D) i =\n    Sum.elim (vecMul (x \u2218 Sum.inl) A + vecMul (x \u2218 Sum.inr) C) (vecMul (x \u2218 Sum.inl) B + vecMul (x \u2218 Sum.inr) D) i"}, {"line": "cases i <;> simp [vecMul, dotProduct]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toBlock_diagonal_self (d : m \u2192 \u03b1) (p : m \u2192 Prop) :\n    Matrix.toBlock (diagonal d) p p = diagonal fun i : Subtype p => d \u2191i := by\n  ext i j\n  by_cases h : i = j\n  \u00b7 simp [h]\n  \u00b7 simp [One.one, h, Subtype.val_injective.ne h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}", "[DecidableEq l] [DecidableEq m]", "[Zero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\n\u03b1 : Type u_12\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : Zero \u03b1\nd : m \u2192 \u03b1\np : m \u2192 Prop\n\u22a2 (diagonal d).toBlock p p = diagonal fun i => d \u2191i"}, {"line": "ext i j", "tactic_state": "case a\nm : Type u_2\n\u03b1 : Type u_12\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : Zero \u03b1\nd : m \u2192 \u03b1\np : m \u2192 Prop\ni j : { a // p a }\n\u22a2 (diagonal d).toBlock p p i j = diagonal (fun i => d \u2191i) i j"}, {"line": "by_cases h : i = j", "tactic_state": "case pos\nm : Type u_2\n\u03b1 : Type u_12\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : Zero \u03b1\nd : m \u2192 \u03b1\np : m \u2192 Prop\ni j : { a // p a }\nh : i = j\n\u22a2 (diagonal d).toBlock p p i j = diagonal (fun i => d \u2191i) i j\n---\ncase neg\nm : Type u_2\n\u03b1 : Type u_12\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : Zero \u03b1\nd : m \u2192 \u03b1\np : m \u2192 Prop\ni j : { a // p a }\nh : \u00aci = j\n\u22a2 (diagonal d).toBlock p p i j = diagonal (fun i => d \u2191i) i j"}, {"line": "\u00b7 simp [h]", "tactic_state": "case neg\nm : Type u_2\n\u03b1 : Type u_12\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : Zero \u03b1\nd : m \u2192 \u03b1\np : m \u2192 Prop\ni j : { a // p a }\nh : \u00aci = j\n\u22a2 (diagonal d).toBlock p p i j = diagonal (fun i => d \u2191i) i j"}, {"line": "\u00b7 simp [One.one, h, Subtype.val_injective.ne h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toBlock_diagonal_disjoint (d : m \u2192 \u03b1) {p q : m \u2192 Prop} (hpq : Disjoint p q) :\n    Matrix.toBlock (diagonal d) p q = 0 := by\n  ext \u27e8i, hi\u27e9 \u27e8j, hj\u27e9\n  have : i \u2260 j := fun heq => hpq.le_bot i \u27e8hi, heq.symm \u25b8 hj\u27e9\n  simp [diagonal_apply_ne d this]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}", "[DecidableEq l] [DecidableEq m]", "[Zero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\n\u03b1 : Type u_12\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : Zero \u03b1\nd : m \u2192 \u03b1\np q : m \u2192 Prop\nhpq : Disjoint p q\n\u22a2 (diagonal d).toBlock p q = 0"}, {"line": "ext \u27e8i, hi\u27e9 \u27e8j, hj\u27e9", "tactic_state": "case a.mk.mk\nm : Type u_2\n\u03b1 : Type u_12\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : Zero \u03b1\nd : m \u2192 \u03b1\np q : m \u2192 Prop\nhpq : Disjoint p q\ni : m\nhi : p i\nj : m\nhj : q j\n\u22a2 (diagonal d).toBlock p q \u27e8i, hi\u27e9 \u27e8j, hj\u27e9 = 0 \u27e8i, hi\u27e9 \u27e8j, hj\u27e9"}, {"line": "have : i \u2260 j := fun heq => hpq.le_bot i \u27e8hi, heq.symm \u25b8 hj\u27e9", "tactic_state": "case a.mk.mk\nm : Type u_2\n\u03b1 : Type u_12\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : Zero \u03b1\nd : m \u2192 \u03b1\np q : m \u2192 Prop\nhpq : Disjoint p q\ni : m\nhi : p i\nj : m\nhj : q j\nthis : i \u2260 j\n\u22a2 (diagonal d).toBlock p q \u27e8i, hi\u27e9 \u27e8j, hj\u27e9 = 0 \u27e8i, hi\u27e9 \u27e8j, hj\u27e9"}, {"line": "simp [diagonal_apply_ne d this]", "tactic_state": "case a.mk.mk\nm : Type u_2\n\u03b1 : Type u_12\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : Zero \u03b1\nd : m \u2192 \u03b1\np q : m \u2192 Prop\nhpq : Disjoint p q\ni : m\nhi : p i\nj : m\nhj : q j\nthis : i \u2260 j\n\u22a2 diagonal d i j = 0"}]}
{"declaration": "theorem fromBlocks_diagonal (d\u2081 : l \u2192 \u03b1) (d\u2082 : m \u2192 \u03b1) :\n    fromBlocks (diagonal d\u2081) 0 0 (diagonal d\u2082) = diagonal (Sum.elim d\u2081 d\u2082) := by\n  ext i j\n  rcases i with \u27e8\u27e9 <;> rcases j with \u27e8\u27e9 <;> simp [diagonal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}", "[DecidableEq l] [DecidableEq m]", "[Zero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nm : Type u_2\n\u03b1 : Type u_12\ninst\u271d\u00b2 : DecidableEq l\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : Zero \u03b1\nd\u2081 : l \u2192 \u03b1\nd\u2082 : m \u2192 \u03b1\n\u22a2 fromBlocks (diagonal d\u2081) 0 0 (diagonal d\u2082) = diagonal (Sum.elim d\u2081 d\u2082)"}, {"line": "ext i j", "tactic_state": "case a\nl : Type u_1\nm : Type u_2\n\u03b1 : Type u_12\ninst\u271d\u00b2 : DecidableEq l\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : Zero \u03b1\nd\u2081 : l \u2192 \u03b1\nd\u2082 : m \u2192 \u03b1\ni j : l \u2295 m\n\u22a2 fromBlocks (diagonal d\u2081) 0 0 (diagonal d\u2082) i j = diagonal (Sum.elim d\u2081 d\u2082) i j"}, {"line": "rcases i with \u27e8\u27e9 <;> rcases j with \u27e8\u27e9 <;> simp [diagonal]", "tactic_state": "case a.inl.inl\nl : Type u_1\nm : Type u_2\n\u03b1 : Type u_12\ninst\u271d\u00b2 : DecidableEq l\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : Zero \u03b1\nd\u2081 : l \u2192 \u03b1\nd\u2082 : m \u2192 \u03b1\nval\u271d\u00b9 val\u271d : l\n\u22a2 (if val\u271d\u00b9 = val\u271d then d\u2081 val\u271d\u00b9 else 0) = if Sum.inl val\u271d\u00b9 = Sum.inl val\u271d then d\u2081 val\u271d\u00b9 else 0\n---\ncase a.inr.inr\nl : Type u_1\nm : Type u_2\n\u03b1 : Type u_12\ninst\u271d\u00b2 : DecidableEq l\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : Zero \u03b1\nd\u2081 : l \u2192 \u03b1\nd\u2082 : m \u2192 \u03b1\nval\u271d\u00b9 val\u271d : m\n\u22a2 (if val\u271d\u00b9 = val\u271d then d\u2082 val\u271d\u00b9 else 0) = if Sum.inr val\u271d\u00b9 = Sum.inr val\u271d then d\u2082 val\u271d\u00b9 else 0"}]}
{"declaration": "theorem fromBlocks_one : fromBlocks (1 : Matrix l l \u03b1) 0 0 (1 : Matrix m m \u03b1) = 1 := by\n  ext i j\n  rcases i with \u27e8\u27e9 <;> rcases j with \u27e8\u27e9 <;> simp [one_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}", "[DecidableEq l] [DecidableEq m]", "[Zero \u03b1]", "[Zero \u03b1] [One \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nm : Type u_2\n\u03b1 : Type u_12\ninst\u271d\u2074 : DecidableEq l\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 inst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\n\u22a2 fromBlocks 1 0 0 1 = 1"}, {"line": "ext i j", "tactic_state": "case a\nl : Type u_1\nm : Type u_2\n\u03b1 : Type u_12\ninst\u271d\u2074 : DecidableEq l\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 inst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\ni j : l \u2295 m\n\u22a2 fromBlocks 1 0 0 1 i j = 1 i j"}, {"line": "rcases i with \u27e8\u27e9 <;> rcases j with \u27e8\u27e9 <;> simp [one_apply]", "tactic_state": "case a.inl.inl\nl : Type u_1\nm : Type u_2\n\u03b1 : Type u_12\ninst\u271d\u2074 : DecidableEq l\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 inst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\nval\u271d\u00b9 val\u271d : l\n\u22a2 (if val\u271d\u00b9 = val\u271d then 1 else 0) = if Sum.inl val\u271d\u00b9 = Sum.inl val\u271d then 1 else 0\n---\ncase a.inr.inr\nl : Type u_1\nm : Type u_2\n\u03b1 : Type u_12\ninst\u271d\u2074 : DecidableEq l\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 inst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\nval\u271d\u00b9 val\u271d : m\n\u22a2 (if val\u271d\u00b9 = val\u271d then 1 else 0) = if Sum.inr val\u271d\u00b9 = Sum.inr val\u271d then 1 else 0"}]}
{"declaration": "theorem blockDiagonal_apply (M : o \u2192 Matrix m n \u03b1) (ik jk) :\n    blockDiagonal M ik jk = if ik.2 = jk.2 then M ik.2 ik.1 jk.1 else 0 := by\n  cases ik\n  cases jk\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}", "[DecidableEq l] [DecidableEq m]", "[Zero \u03b1]", "[Zero \u03b1] [One \u03b1]", "[DecidableEq o]", "[Zero \u03b1] [Zero \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : o \u2192 Matrix m n \u03b1\nik : m \u00d7 o\njk : n \u00d7 o\n\u22a2 blockDiagonal M ik jk = if ik.2 = jk.2 then M ik.2 ik.1 jk.1 else 0"}, {"line": "cases ik", "tactic_state": "case mk\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : o \u2192 Matrix m n \u03b1\njk : n \u00d7 o\nfst\u271d : m\nsnd\u271d : o\n\u22a2 blockDiagonal M (fst\u271d, snd\u271d) jk = if (fst\u271d, snd\u271d).2 = jk.2 then M (fst\u271d, snd\u271d).2 (fst\u271d, snd\u271d).1 jk.1 else 0"}, {"line": "cases jk", "tactic_state": "case mk.mk\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : o \u2192 Matrix m n \u03b1\nfst\u271d\u00b9 : m\nsnd\u271d\u00b9 : o\nfst\u271d : n\nsnd\u271d : o\n\u22a2 blockDiagonal M (fst\u271d\u00b9, snd\u271d\u00b9) (fst\u271d, snd\u271d) =\n    if (fst\u271d\u00b9, snd\u271d\u00b9).2 = (fst\u271d, snd\u271d).2 then M (fst\u271d\u00b9, snd\u271d\u00b9).2 (fst\u271d\u00b9, snd\u271d\u00b9).1 (fst\u271d, snd\u271d).1 else 0"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem blockDiagonal_transpose (M : o \u2192 Matrix m n \u03b1) :\n    (blockDiagonal M)\u1d40 = blockDiagonal fun k => (M k)\u1d40 := by\n  ext\n  simp only [transpose_apply]\n  simp only [blockDiagonal_apply]\n  simp only [eq_comm]\n  split_ifs with h\n  \u00b7 rw [h]\n  \u00b7 rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}", "[DecidableEq l] [DecidableEq m]", "[Zero \u03b1]", "[Zero \u03b1] [One \u03b1]", "[DecidableEq o]", "[Zero \u03b1] [Zero \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : o \u2192 Matrix m n \u03b1\n\u22a2 (blockDiagonal M).transpose = blockDiagonal fun k => (M k).transpose"}, {"line": "ext", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : o \u2192 Matrix m n \u03b1\ni\u271d : n \u00d7 o\nj\u271d : m \u00d7 o\n\u22a2 (blockDiagonal M).transpose i\u271d j\u271d = blockDiagonal (fun k => (M k).transpose) i\u271d j\u271d"}, {"line": "simp only [transpose_apply]", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : o \u2192 Matrix m n \u03b1\ni\u271d : n \u00d7 o\nj\u271d : m \u00d7 o\n\u22a2 blockDiagonal M j\u271d i\u271d = blockDiagonal (fun k => (M k).transpose) i\u271d j\u271d"}, {"line": "simp only [blockDiagonal_apply]", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : o \u2192 Matrix m n \u03b1\ni\u271d : n \u00d7 o\nj\u271d : m \u00d7 o\n\u22a2 (if j\u271d.2 = i\u271d.2 then M j\u271d.2 j\u271d.1 i\u271d.1 else 0) = if i\u271d.2 = j\u271d.2 then (M i\u271d.2).transpose i\u271d.1 j\u271d.1 else 0"}, {"line": "simp only [eq_comm]", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : o \u2192 Matrix m n \u03b1\ni\u271d : n \u00d7 o\nj\u271d : m \u00d7 o\n\u22a2 (if i\u271d.2 = j\u271d.2 then (M i\u271d.2).transpose i\u271d.1 j\u271d.1 else 0) = if j\u271d.2 = i\u271d.2 then M j\u271d.2 j\u271d.1 i\u271d.1 else 0"}, {"line": "split_ifs with h", "tactic_state": "case pos\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : o \u2192 Matrix m n \u03b1\ni\u271d : n \u00d7 o\nj\u271d : m \u00d7 o\nh : i\u271d.2 = j\u271d.2\nh\u271d : j\u271d.2 = i\u271d.2\n\u22a2 (M i\u271d.2).transpose i\u271d.1 j\u271d.1 = M j\u271d.2 j\u271d.1 i\u271d.1\n---\ncase neg\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : o \u2192 Matrix m n \u03b1\ni\u271d : n \u00d7 o\nj\u271d : m \u00d7 o\nh : i\u271d.2 = j\u271d.2\nh\u271d : \u00acj\u271d.2 = i\u271d.2\n\u22a2 (M i\u271d.2).transpose i\u271d.1 j\u271d.1 = 0\n---\ncase pos\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : o \u2192 Matrix m n \u03b1\ni\u271d : n \u00d7 o\nj\u271d : m \u00d7 o\nh : \u00aci\u271d.2 = j\u271d.2\nh\u271d : j\u271d.2 = i\u271d.2\n\u22a2 0 = M j\u271d.2 j\u271d.1 i\u271d.1\n---\ncase neg\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : o \u2192 Matrix m n \u03b1\ni\u271d : n \u00d7 o\nj\u271d : m \u00d7 o\nh : \u00aci\u271d.2 = j\u271d.2\nh\u271d : \u00acj\u271d.2 = i\u271d.2\n\u22a2 0 = 0"}, {"line": "\u00b7 rw [h]", "tactic_state": "case neg\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : o \u2192 Matrix m n \u03b1\ni\u271d : n \u00d7 o\nj\u271d : m \u00d7 o\nh : i\u271d.2 = j\u271d.2\nh\u271d : \u00acj\u271d.2 = i\u271d.2\n\u22a2 (M i\u271d.2).transpose i\u271d.1 j\u271d.1 = 0\n---\ncase pos\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : o \u2192 Matrix m n \u03b1\ni\u271d : n \u00d7 o\nj\u271d : m \u00d7 o\nh : \u00aci\u271d.2 = j\u271d.2\nh\u271d : j\u271d.2 = i\u271d.2\n\u22a2 0 = M j\u271d.2 j\u271d.1 i\u271d.1\n---\ncase neg\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : o \u2192 Matrix m n \u03b1\ni\u271d : n \u00d7 o\nj\u271d : m \u00d7 o\nh : \u00aci\u271d.2 = j\u271d.2\nh\u271d : \u00acj\u271d.2 = i\u271d.2\n\u22a2 0 = 0"}, {"line": "\u00b7 rfl", "tactic_state": "case pos\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : o \u2192 Matrix m n \u03b1\ni\u271d : n \u00d7 o\nj\u271d : m \u00d7 o\nh : \u00aci\u271d.2 = j\u271d.2\nh\u271d : j\u271d.2 = i\u271d.2\n\u22a2 0 = M j\u271d.2 j\u271d.1 i\u271d.1\n---\ncase neg\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : o \u2192 Matrix m n \u03b1\ni\u271d : n \u00d7 o\nj\u271d : m \u00d7 o\nh : \u00aci\u271d.2 = j\u271d.2\nh\u271d : \u00acj\u271d.2 = i\u271d.2\n\u22a2 0 = 0"}]}
{"declaration": "theorem blockDiagonal_zero : blockDiagonal (0 : o \u2192 Matrix m n \u03b1) = 0 := by\n  ext\n  simp [blockDiagonal_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}", "[DecidableEq l] [DecidableEq m]", "[Zero \u03b1]", "[Zero \u03b1] [One \u03b1]", "[DecidableEq o]", "[Zero \u03b1] [Zero \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\n\u22a2 blockDiagonal 0 = 0"}, {"line": "ext", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type u_12\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 inst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\ni\u271d : m \u00d7 o\nj\u271d : n \u00d7 o\n\u22a2 blockDiagonal 0 i\u271d j\u271d = 0 i\u271d j\u271d"}, {"line": "simp [blockDiagonal_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem blockDiagonal'_apply (M : \u2200 i, Matrix (m' i) (n' i) \u03b1) (ik jk) :\n    blockDiagonal' M ik jk =\n      if h : ik.1 = jk.1 then M ik.1 ik.2 (cast (congr_arg n' h.symm) jk.2) else 0 := by\n  cases ik\n  cases jk\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}", "[DecidableEq l] [DecidableEq m]", "[Zero \u03b1]", "[Zero \u03b1] [One \u03b1]", "[DecidableEq o]", "[Zero \u03b1] [Zero \u03b2]", "(o m n \u03b1)", "(\u03b1 m o)", "[Zero \u03b1] [Zero \u03b2]", "(o m n \u03b1)", "[DecidableEq o]", "[Zero \u03b1] [Zero \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Type u_4\nm' : o \u2192 Type u_7\nn' : o \u2192 Type u_8\n\u03b1 : Type u_12\ninst\u271d\u2077 inst\u271d\u2076 : Zero \u03b1\ninst\u271d\u2075 : One \u03b1\ninst\u271d\u2074 : DecidableEq o\ninst\u271d\u00b3 inst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : (i : o) \u2192 Matrix (m' i) (n' i) \u03b1\nik : (i : o) \u00d7 m' i\njk : (i : o) \u00d7 n' i\n\u22a2 blockDiagonal' M ik jk = if h : ik.fst = jk.fst then M ik.fst ik.snd (cast \u22ef jk.snd) else 0"}, {"line": "cases ik", "tactic_state": "case mk\no : Type u_4\nm' : o \u2192 Type u_7\nn' : o \u2192 Type u_8\n\u03b1 : Type u_12\ninst\u271d\u2077 inst\u271d\u2076 : Zero \u03b1\ninst\u271d\u2075 : One \u03b1\ninst\u271d\u2074 : DecidableEq o\ninst\u271d\u00b3 inst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : (i : o) \u2192 Matrix (m' i) (n' i) \u03b1\njk : (i : o) \u00d7 n' i\nfst\u271d : o\nsnd\u271d : m' fst\u271d\n\u22a2 blockDiagonal' M \u27e8fst\u271d, snd\u271d\u27e9 jk =\n    if h : \u27e8fst\u271d, snd\u271d\u27e9.fst = jk.fst then M \u27e8fst\u271d, snd\u271d\u27e9.fst \u27e8fst\u271d, snd\u271d\u27e9.snd (cast \u22ef jk.snd) else 0"}, {"line": "cases jk", "tactic_state": "case mk.mk\no : Type u_4\nm' : o \u2192 Type u_7\nn' : o \u2192 Type u_8\n\u03b1 : Type u_12\ninst\u271d\u2077 inst\u271d\u2076 : Zero \u03b1\ninst\u271d\u2075 : One \u03b1\ninst\u271d\u2074 : DecidableEq o\ninst\u271d\u00b3 inst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\nM : (i : o) \u2192 Matrix (m' i) (n' i) \u03b1\nfst\u271d\u00b9 : o\nsnd\u271d\u00b9 : m' fst\u271d\u00b9\nfst\u271d : o\nsnd\u271d : n' fst\u271d\n\u22a2 blockDiagonal' M \u27e8fst\u271d\u00b9, snd\u271d\u00b9\u27e9 \u27e8fst\u271d, snd\u271d\u27e9 =\n    if h : \u27e8fst\u271d\u00b9, snd\u271d\u00b9\u27e9.fst = \u27e8fst\u271d, snd\u271d\u27e9.fst then M \u27e8fst\u271d\u00b9, snd\u271d\u00b9\u27e9.fst \u27e8fst\u271d\u00b9, snd\u271d\u00b9\u27e9.snd (cast \u22ef \u27e8fst\u271d, snd\u271d\u27e9.snd)\n    else 0"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem blockDiagonal'_conjTranspose {\u03b1} [AddMonoid \u03b1] [StarAddMonoid \u03b1]\n    (M : \u2200 i, Matrix (m' i) (n' i) \u03b1) : (blockDiagonal' M)\u1d34 = blockDiagonal' fun k => (M k)\u1d34 := by\n  simp only [conjTranspose]\n  simp only [blockDiagonal'_transpose]\n  exact blockDiagonal'_map _ star (star_zero \u03b1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}", "[DecidableEq l] [DecidableEq m]", "[Zero \u03b1]", "[Zero \u03b1] [One \u03b1]", "[DecidableEq o]", "[Zero \u03b1] [Zero \u03b2]", "(o m n \u03b1)", "(\u03b1 m o)", "[Zero \u03b1] [Zero \u03b2]", "(o m n \u03b1)", "[DecidableEq o]", "[Zero \u03b1] [Zero \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Type u_4\nm' : o \u2192 Type u_7\nn' : o \u2192 Type u_8\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq o\n\u03b1 : Type u_14\ninst\u271d\u00b9 : AddMonoid \u03b1\ninst\u271d : StarAddMonoid \u03b1\nM : (i : o) \u2192 Matrix (m' i) (n' i) \u03b1\n\u22a2 (blockDiagonal' M).conjTranspose = blockDiagonal' fun k => (M k).conjTranspose"}, {"line": "simp only [conjTranspose]", "tactic_state": "o : Type u_4\nm' : o \u2192 Type u_7\nn' : o \u2192 Type u_8\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq o\n\u03b1 : Type u_14\ninst\u271d\u00b9 : AddMonoid \u03b1\ninst\u271d : StarAddMonoid \u03b1\nM : (i : o) \u2192 Matrix (m' i) (n' i) \u03b1\n\u22a2 (blockDiagonal' M).transpose.map star = blockDiagonal' fun k => (M k).transpose.map star"}, {"line": "simp only [blockDiagonal'_transpose]", "tactic_state": "o : Type u_4\nm' : o \u2192 Type u_7\nn' : o \u2192 Type u_8\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq o\n\u03b1 : Type u_14\ninst\u271d\u00b9 : AddMonoid \u03b1\ninst\u271d : StarAddMonoid \u03b1\nM : (i : o) \u2192 Matrix (m' i) (n' i) \u03b1\n\u22a2 (blockDiagonal' fun k => (M k).transpose).map star = blockDiagonal' fun k => (M k).transpose.map star"}, {"line": "exact blockDiagonal'_map _ star (star_zero \u03b1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem blockDiagonal'_zero : blockDiagonal' (0 : \u2200 i, Matrix (m' i) (n' i) \u03b1) = 0 := by\n  ext\n  simp [blockDiagonal'_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}", "[DecidableEq l] [DecidableEq m]", "[Zero \u03b1]", "[Zero \u03b1] [One \u03b1]", "[DecidableEq o]", "[Zero \u03b1] [Zero \u03b2]", "(o m n \u03b1)", "(\u03b1 m o)", "[Zero \u03b1] [Zero \u03b2]", "(o m n \u03b1)", "[DecidableEq o]", "[Zero \u03b1] [Zero \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "o : Type u_4\nm' : o \u2192 Type u_7\nn' : o \u2192 Type u_8\n\u03b1 : Type u_12\ninst\u271d\u2077 inst\u271d\u2076 : Zero \u03b1\ninst\u271d\u2075 : One \u03b1\ninst\u271d\u2074 : DecidableEq o\ninst\u271d\u00b3 inst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\n\u22a2 blockDiagonal' 0 = 0"}, {"line": "ext", "tactic_state": "case a\no : Type u_4\nm' : o \u2192 Type u_7\nn' : o \u2192 Type u_8\n\u03b1 : Type u_12\ninst\u271d\u2077 inst\u271d\u2076 : Zero \u03b1\ninst\u271d\u2075 : One \u03b1\ninst\u271d\u2074 : DecidableEq o\ninst\u271d\u00b3 inst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : DecidableEq o\ninst\u271d : Zero \u03b1\ni\u271d : (i : o) \u00d7 m' i\nj\u271d : (i : o) \u00d7 n' i\n\u22a2 blockDiagonal' 0 i\u271d j\u271d = 0 i\u271d j\u271d"}, {"line": "simp [blockDiagonal'_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toBlock_mul_eq_mul {m n k : Type*} [Fintype n] (p : m \u2192 Prop) (q : k \u2192 Prop)\n    (A : Matrix m n R) (B : Matrix n k R) :\n    (A * B).toBlock p q = A.toBlock p \u22a4 * B.toBlock \u22a4 q := by\n  ext i k\n  simp only [toBlock_apply]\n  simp only [mul_apply]\n  rw [Finset.sum_subtype]\n  simp [Pi.top_apply, Prop.top_eq_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}", "[DecidableEq l] [DecidableEq m]", "[Zero \u03b1]", "[Zero \u03b1] [One \u03b1]", "[DecidableEq o]", "[Zero \u03b1] [Zero \u03b2]", "(o m n \u03b1)", "(\u03b1 m o)", "[Zero \u03b1] [Zero \u03b2]", "(o m n \u03b1)", "[DecidableEq o]", "[Zero \u03b1] [Zero \u03b2]", "(m' n' \u03b1)", "(\u03b1 m')", "[Zero \u03b1] [Zero \u03b2]", "(m' n' \u03b1)", "[CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_10\ninst\u271d\u00b9 : CommRing R\nm : Type u_14\nn : Type u_15\nk : Type u_16\ninst\u271d : Fintype n\np : m \u2192 Prop\nq : k \u2192 Prop\nA : Matrix m n R\nB : Matrix n k R\n\u22a2 (A * B).toBlock p q = A.toBlock p \u22a4 * B.toBlock \u22a4 q"}, {"line": "ext i k", "tactic_state": "case a\nR : Type u_10\ninst\u271d\u00b9 : CommRing R\nm : Type u_14\nn : Type u_15\nk\u271d : Type u_16\ninst\u271d : Fintype n\np : m \u2192 Prop\nq : k\u271d \u2192 Prop\nA : Matrix m n R\nB : Matrix n k\u271d R\ni : { a // p a }\nk : { a // q a }\n\u22a2 (A * B).toBlock p q i k = (A.toBlock p \u22a4 * B.toBlock \u22a4 q) i k"}, {"line": "simp only [toBlock_apply]", "tactic_state": "case a\nR : Type u_10\ninst\u271d\u00b9 : CommRing R\nm : Type u_14\nn : Type u_15\nk\u271d : Type u_16\ninst\u271d : Fintype n\np : m \u2192 Prop\nq : k\u271d \u2192 Prop\nA : Matrix m n R\nB : Matrix n k\u271d R\ni : { a // p a }\nk : { a // q a }\n\u22a2 (A * B) \u2191i \u2191k = (A.toBlock p \u22a4 * B.toBlock \u22a4 q) i k"}, {"line": "simp only [mul_apply]", "tactic_state": "case a\nR : Type u_10\ninst\u271d\u00b9 : CommRing R\nm : Type u_14\nn : Type u_15\nk\u271d : Type u_16\ninst\u271d : Fintype n\np : m \u2192 Prop\nq : k\u271d \u2192 Prop\nA : Matrix m n R\nB : Matrix n k\u271d R\ni : { a // p a }\nk : { a // q a }\n\u22a2 \u2211 j, A (\u2191i) j * B j \u2191k = \u2211 j, A.toBlock p \u22a4 i j * B.toBlock \u22a4 q j k"}, {"line": "rw [Finset.sum_subtype]", "tactic_state": "case a\nR : Type u_10\ninst\u271d\u00b9 : CommRing R\nm : Type u_14\nn : Type u_15\nk\u271d : Type u_16\ninst\u271d : Fintype n\np : m \u2192 Prop\nq : k\u271d \u2192 Prop\nA : Matrix m n R\nB : Matrix n k\u271d R\ni : { a // p a }\nk : { a // q a }\n\u22a2 \u2211 a, A \u2191i \u2191a * B \u2191a \u2191k = \u2211 j, A.toBlock p \u22a4 i j * B.toBlock \u22a4 q j k\n---\ncase a.h\nR : Type u_10\ninst\u271d\u00b9 : CommRing R\nm : Type u_14\nn : Type u_15\nk\u271d : Type u_16\ninst\u271d : Fintype n\np : m \u2192 Prop\nq : k\u271d \u2192 Prop\nA : Matrix m n R\nB : Matrix n k\u271d R\ni : { a // p a }\nk : { a // q a }\n\u22a2 \u2200 (x : n), x \u2208 Finset.univ \u2194 ?m.11623 x\n---\nR : Type u_10\ninst\u271d\u00b9 : CommRing R\nm : Type u_14\nn : Type u_15\nk\u271d : Type u_16\ninst\u271d : Fintype n\np : m \u2192 Prop\nq : k\u271d \u2192 Prop\nA : Matrix m n R\nB : Matrix n k\u271d R\ni : { a // p a }\nk : { a // q a }\n\u22a2 n \u2192 Prop\n---\nR : Type u_10\ninst\u271d\u00b9 : CommRing R\nm : Type u_14\nn : Type u_15\nk\u271d : Type u_16\ninst\u271d : Fintype n\np : m \u2192 Prop\nq : k\u271d \u2192 Prop\nA : Matrix m n R\nB : Matrix n k\u271d R\ni : { a // p a }\nk : { a // q a }\n\u22a2 Fintype (Subtype ?m.11623)"}, {"line": "simp [Pi.top_apply, Prop.top_eq_true]", "tactic_state": "case a\nR : Type u_10\ninst\u271d\u00b9 : CommRing R\nm : Type u_14\nn : Type u_15\nk\u271d : Type u_16\ninst\u271d : Fintype n\np : m \u2192 Prop\nq : k\u271d \u2192 Prop\nA : Matrix m n R\nB : Matrix n k\u271d R\ni : { a // p a }\nk : { a // q a }\n\u22a2 \u2211 a, A \u2191i \u2191a * B \u2191a \u2191k = \u2211 x, A \u2191i \u2191x * B \u2191x \u2191k\n---\ncase a.h\nR : Type u_10\ninst\u271d\u00b9 : CommRing R\nm : Type u_14\nn : Type u_15\nk\u271d : Type u_16\ninst\u271d : Fintype n\np : m \u2192 Prop\nq : k\u271d \u2192 Prop\nA : Matrix m n R\nB : Matrix n k\u271d R\ni : { a // p a }\nk : { a // q a }\n\u22a2 \u2200 (x : n), x \u2208 Finset.univ \u2194 ?m.11623 x\n---\nR : Type u_10\ninst\u271d\u00b9 : CommRing R\nm : Type u_14\nn : Type u_15\nk\u271d : Type u_16\ninst\u271d : Fintype n\np : m \u2192 Prop\nq : k\u271d \u2192 Prop\nA : Matrix m n R\nB : Matrix n k\u271d R\ni : { a // p a }\nk : { a // q a }\n\u22a2 n \u2192 Prop\n---\nR : Type u_10\ninst\u271d\u00b9 : CommRing R\nm : Type u_14\nn : Type u_15\nk\u271d : Type u_16\ninst\u271d : Fintype n\np : m \u2192 Prop\nq : k\u271d \u2192 Prop\nA : Matrix m n R\nB : Matrix n k\u271d R\ni : { a // p a }\nk : { a // q a }\n\u22a2 Fintype (Subtype ?m.11623)"}]}
{"declaration": "lemma Matrix.comp_diagonal (d) :\n    comp m m n n R (diagonal d) =\n      (blockDiagonal d).reindex (.prodComm ..) (.prodComm ..) := by\n  ext\n  simp [diagonal, blockDiagonal, Matrix.ite_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Block.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o p q : Type*} {m' n' p' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type*} {\u03b2 : Type*}", "[DecidableEq l] [DecidableEq m]", "[Zero \u03b1]", "[Zero \u03b1] [One \u03b1]", "[DecidableEq o]", "[Zero \u03b1] [Zero \u03b2]", "(o m n \u03b1)", "(\u03b1 m o)", "[Zero \u03b1] [Zero \u03b2]", "(o m n \u03b1)", "[DecidableEq o]", "[Zero \u03b1] [Zero \u03b2]", "(m' n' \u03b1)", "(\u03b1 m')", "[Zero \u03b1] [Zero \u03b2]", "(m' n' \u03b1)", "[CommRing R]", "{R \u03b1 \u03b2 \u03b9 : Type*}", "[Zero R] [DecidableEq m]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\ninst\u271d\u00b2 : DecidableEq m\nR : Type u_14\ninst\u271d\u00b9 : Zero R\ninst\u271d : DecidableEq m\nd : m \u2192 Matrix n n R\n\u22a2 (comp m m n n R) (diagonal d) = (reindex (Equiv.prodComm n m) (Equiv.prodComm n m)) (blockDiagonal d)"}, {"line": "ext", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\ninst\u271d\u00b2 : DecidableEq m\nR : Type u_14\ninst\u271d\u00b9 : Zero R\ninst\u271d : DecidableEq m\nd : m \u2192 Matrix n n R\ni\u271d j\u271d : m \u00d7 n\n\u22a2 (comp m m n n R) (diagonal d) i\u271d j\u271d = (reindex (Equiv.prodComm n m) (Equiv.prodComm n m)) (blockDiagonal d) i\u271d j\u271d"}, {"line": "simp [diagonal, blockDiagonal, Matrix.ite_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma fromRows_toRows (A : Matrix (m\u2081 \u2295 m\u2082) n R) : fromRows A.toRows\u2081 A.toRows\u2082 = A := by\n  ext (i | i) j <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/ColumnRowPartitioned.lean", "context": {"open": [], "variables": ["{R : Type*}", "{m m\u2081 m\u2082 n n\u2081 n\u2082 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nm\u2081 : Type u_3\nm\u2082 : Type u_4\nn : Type u_5\nx\u271d : Sort u_8\nfromRows : x\u271d\nA : Matrix (m\u2081 \u2295 m\u2082) n R\n\u22a2 sorry = A"}, {"line": "ext (i | i) j <;> simp", "tactic_state": "case a.inl\nR : Type u_1\nm\u2081 : Type u_3\nm\u2082 : Type u_4\nn : Type u_5\nx\u271d : Sort u_8\nfromRows : x\u271d\nA : Matrix (m\u2081 \u2295 m\u2082) n R\ni : m\u2081\nj : n\n\u22a2 sorry () (Sum.inl i) j = A (Sum.inl i) j\n---\ncase a.inr\nR : Type u_1\nm\u2081 : Type u_3\nm\u2082 : Type u_4\nn : Type u_5\nx\u271d : Sort u_8\nfromRows : x\u271d\nA : Matrix (m\u2081 \u2295 m\u2082) n R\ni : m\u2082\nj : n\n\u22a2 sorry () (Sum.inr i) j = A (Sum.inr i) j"}]}
{"declaration": "lemma fromRows_inj : Function.Injective2 (@fromRows R m\u2081 m\u2082 n) := by\n  intros x1 x2 y1 y2\n  simp [\u2190 Matrix.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/ColumnRowPartitioned.lean", "context": {"open": [], "variables": ["{R : Type*}", "{m m\u2081 m\u2082 n n\u2081 n\u2082 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_8\nfromRows : x\u271d\n\u22a2 Function.Injective2 sorry"}, {"line": "intros x1 x2 y1 y2", "tactic_state": "x\u271d : Sort u_8\nfromRows : x\u271d\nx1 x2 : ?m.474\ny1 y2 : ?m.475\n\u22a2 sorry x1 y1 = sorry x2 y2 \u2192 x1 = x2 \u2227 y1 = y2"}, {"line": "simp [\u2190 Matrix.ext_iff]", "tactic_state": "x\u271d : Sort u_8\nfromRows : x\u271d\nx1 x2 : ?m.474\ny1 y2 : ?m.475\n\u22a2 sorry () x1 y1 = sorry () x2 y2 \u2192 x1 = x2 \u2227 y1 = y2"}]}
{"declaration": "lemma mem_doublyStochastic_iff_sum :\n    M \u2208 doublyStochastic R n \u2194\n      (\u2200 i j, 0 \u2264 M i j) \u2227 (\u2200 i, \u2211 j, M i j = 1) \u2227 \u2200 j, \u2211 i, M i j = 1 := by\n  simp [funext_iff, doublyStochastic, mulVec, vecMul, dotProduct]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/DoublyStochastic.lean", "context": {"open": ["Finset Function Matrix"], "variables": ["{R n : Type*} [Fintype n] [DecidableEq n]", "[Semiring R] [PartialOrder R] [IsOrderedRing R] {M : Matrix n n R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\nM : Matrix n n R\n\u22a2 M \u2208 doublyStochastic R n \u2194 (\u2200 (i j : n), 0 \u2264 M i j) \u2227 (\u2200 (i : n), \u2211 j, M i j = 1) \u2227 \u2200 (j : n), \u2211 i, M i j = 1"}, {"line": "simp [funext_iff, doublyStochastic, mulVec, vecMul, dotProduct]", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\nM : Matrix n n R\n\u22a2 (\u2200 (i j : n), 0 \u2264 M i j) \u2192\n    (((\u2200 (x : n), \u2211 x_1, M x x_1 * 1 = 1) \u2227 \u2200 (x : n), \u2211 x_1, 1 * M x_1 x = 1) \u2194\n      (\u2200 (i : n), \u2211 j, M i j = 1) \u2227 \u2200 (j : n), \u2211 i, M i j = 1)"}]}
{"declaration": "lemma convex_doublyStochastic : Convex R (doublyStochastic R n : Set (Matrix n n R)) := by\n  intro x hx y hy a b ha hb h\n  simp only [SetLike.mem_coe] at hx hy \u22a2\n  simp only [mem_doublyStochastic_iff_sum] at hx hy \u22a2\n  simp [add_nonneg, ha, hb, mul_nonneg, hx, hy, sum_add_distrib, \u2190 mul_sum, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/DoublyStochastic.lean", "context": {"open": ["Finset Function Matrix"], "variables": ["{R n : Type*} [Fintype n] [DecidableEq n]", "[Semiring R] [PartialOrder R] [IsOrderedRing R] {M : Matrix n n R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\n\u22a2 Convex R \u2191(doublyStochastic R n)"}, {"line": "intro x hx y hy a b ha hb h", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\nx : Matrix n n R\nhx : x \u2208 \u2191(doublyStochastic R n)\ny : Matrix n n R\nhy : y \u2208 \u2191(doublyStochastic R n)\na b : R\nha : 0 \u2264 a\nhb : 0 \u2264 b\nh : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 \u2191(doublyStochastic R n)"}, {"line": "simp only [SetLike.mem_coe] at hx hy \u22a2", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\nx y : Matrix n n R\na b : R\nha : 0 \u2264 a\nhb : 0 \u2264 b\nh : a + b = 1\nhx : x \u2208 doublyStochastic R n\nhy : y \u2208 doublyStochastic R n\n\u22a2 a \u2022 x + b \u2022 y \u2208 doublyStochastic R n"}, {"line": "simp only [mem_doublyStochastic_iff_sum] at hx hy \u22a2", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\nx y : Matrix n n R\na b : R\nha : 0 \u2264 a\nhb : 0 \u2264 b\nh : a + b = 1\nhx : (\u2200 (i j : n), 0 \u2264 x i j) \u2227 (\u2200 (i : n), \u2211 j, x i j = 1) \u2227 \u2200 (j : n), \u2211 i, x i j = 1\nhy : (\u2200 (i j : n), 0 \u2264 y i j) \u2227 (\u2200 (i : n), \u2211 j, y i j = 1) \u2227 \u2200 (j : n), \u2211 i, y i j = 1\n\u22a2 (\u2200 (i j : n), 0 \u2264 (a \u2022 x + b \u2022 y) i j) \u2227\n    (\u2200 (i : n), \u2211 j, (a \u2022 x + b \u2022 y) i j = 1) \u2227 \u2200 (j : n), \u2211 i, (a \u2022 x + b \u2022 y) i j = 1"}, {"line": "simp [add_nonneg, ha, hb, mul_nonneg, hx, hy, sum_add_distrib, \u2190 mul_sum, h]", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\nx y : Matrix n n R\na b : R\nha : 0 \u2264 a\nhb : 0 \u2264 b\nh : a + b = 1\nhx : (\u2200 (i j : n), 0 \u2264 x i j) \u2227 (\u2200 (i : n), \u2211 j, x i j = 1) \u2227 \u2200 (j : n), \u2211 i, x i j = 1\nhy : (\u2200 (i j : n), 0 \u2264 y i j) \u2227 (\u2200 (i : n), \u2211 j, y i j = 1) \u2227 \u2200 (j : n), \u2211 i, y i j = 1\n\u22a2 (\u2200 (i j : n), 0 \u2264 a * x i j + b * y i j) \u2227 (n \u2192 a * 1 + b * 1 = 1)"}]}
{"declaration": "lemma permMatrix_mem_doublyStochastic {\u03c3 : Equiv.Perm n} :\n    \u03c3.permMatrix R \u2208 doublyStochastic R n := by\n  rw [mem_doublyStochastic_iff_sum]\n  refine \u27e8fun i j => ?g1, ?g2, ?g3\u27e9\n  case g1 => aesop\n  case g2 => simp [Equiv.toPEquiv_apply]\n  case g3 => simp [Equiv.toPEquiv_apply, \u2190 Equiv.eq_symm_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/DoublyStochastic.lean", "context": {"open": ["Finset Function Matrix"], "variables": ["{R n : Type*} [Fintype n] [DecidableEq n]", "[Semiring R] [PartialOrder R] [IsOrderedRing R] {M : Matrix n n R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\n\u03c3 : Equiv.Perm n\n\u22a2 Equiv.Perm.permMatrix R \u03c3 \u2208 doublyStochastic R n"}, {"line": "rw [mem_doublyStochastic_iff_sum]", "tactic_state": "R : Type u_1\nn : Type u_2\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\n\u03c3 : Equiv.Perm n\n\u22a2 (\u2200 (i j : n), 0 \u2264 Equiv.Perm.permMatrix R \u03c3 i j) \u2227\n    (\u2200 (i : n), \u2211 j, Equiv.Perm.permMatrix R \u03c3 i j = 1) \u2227 \u2200 (j : n), \u2211 i, Equiv.Perm.permMatrix R \u03c3 i j = 1"}, {"line": "refine \u27e8fun i j => ?g1, ?g2, ?g3\u27e9", "tactic_state": "case g1\nR : Type u_1\nn : Type u_2\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\n\u03c3 : Equiv.Perm n\ni j : n\n\u22a2 0 \u2264 Equiv.Perm.permMatrix R \u03c3 i j\n---\ncase g2\nR : Type u_1\nn : Type u_2\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\n\u03c3 : Equiv.Perm n\n\u22a2 \u2200 (i : n), \u2211 j, Equiv.Perm.permMatrix R \u03c3 i j = 1\n---\ncase g3\nR : Type u_1\nn : Type u_2\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\n\u03c3 : Equiv.Perm n\n\u22a2 \u2200 (j : n), \u2211 i, Equiv.Perm.permMatrix R \u03c3 i j = 1"}, {"line": "case g1 => aesop", "tactic_state": "case g2\nR : Type u_1\nn : Type u_2\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\n\u03c3 : Equiv.Perm n\n\u22a2 \u2200 (i : n), \u2211 j, Equiv.Perm.permMatrix R \u03c3 i j = 1\n---\ncase g3\nR : Type u_1\nn : Type u_2\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\n\u03c3 : Equiv.Perm n\n\u22a2 \u2200 (j : n), \u2211 i, Equiv.Perm.permMatrix R \u03c3 i j = 1"}, {"line": "case g2 => simp [Equiv.toPEquiv_apply]", "tactic_state": "case g3\nR : Type u_1\nn : Type u_2\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\n\u03c3 : Equiv.Perm n\n\u22a2 \u2200 (j : n), \u2211 i, Equiv.Perm.permMatrix R \u03c3 i j = 1"}, {"line": "case g3 => simp [Equiv.toPEquiv_apply, \u2190 Equiv.eq_symm_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toMatrix_mul_apply [Fintype m] [DecidableEq m] [NonAssocSemiring \u03b1] (f : l \u2243. m) (i j)\n    (M : Matrix m n \u03b1) : (f.toMatrix * M :) i j = Option.casesOn (f i) 0 fun fi => M fi j := by\n  dsimp [toMatrix, Matrix.mul_apply]\n  rcases h : f i with - | fi\n  \u00b7 simp [h]\n  \u00b7 rw [Finset.sum_eq_single fi] <;> simp +contextual [h, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/PEquiv.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{k l m n : Type*}", "{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_2\nm : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : NonAssocSemiring \u03b1\nf : l \u2243. m\ni : l\nj : n\nM : Matrix m n \u03b1\n\u22a2 (f.toMatrix * M) i j = Option.casesOn (f i) 0 fun fi => M fi j"}, {"line": "dsimp [toMatrix, Matrix.mul_apply]", "tactic_state": "l : Type u_2\nm : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : NonAssocSemiring \u03b1\nf : l \u2243. m\ni : l\nj : n\nM : Matrix m n \u03b1\n\u22a2 (f.toMatrix * M) i j = Option.rec 0 (fun val => M val j) (f i)"}, {"line": "rcases h : f i with - | fi", "tactic_state": "case none\nl : Type u_2\nm : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : NonAssocSemiring \u03b1\nf : l \u2243. m\ni : l\nj : n\nM : Matrix m n \u03b1\nh : f i = none\n\u22a2 (f.toMatrix * M) i j = Option.rec 0 (fun val => M val j) none\n---\ncase some\nl : Type u_2\nm : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : NonAssocSemiring \u03b1\nf : l \u2243. m\ni : l\nj : n\nM : Matrix m n \u03b1\nfi : m\nh : f i = some fi\n\u22a2 (f.toMatrix * M) i j = Option.rec 0 (fun val => M val j) (some fi)"}, {"line": "\u00b7 simp [h]", "tactic_state": "case some\nl : Type u_2\nm : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : NonAssocSemiring \u03b1\nf : l \u2243. m\ni : l\nj : n\nM : Matrix m n \u03b1\nfi : m\nh : f i = some fi\n\u22a2 (f.toMatrix * M) i j = Option.rec 0 (fun val => M val j) (some fi)"}, {"line": "\u00b7 rw [Finset.sum_eq_single fi] <;> simp +contextual [h, eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toMatrix_refl [DecidableEq n] [Zero \u03b1] [One \u03b1] :\n    ((PEquiv.refl n).toMatrix : Matrix n n \u03b1) = 1 := by\n  ext\n  simp [toMatrix_apply, one_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/PEquiv.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{k l m n : Type*}", "{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\n\u22a2 (PEquiv.refl n).toMatrix = 1"}, {"line": "ext", "tactic_state": "case a\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\ni\u271d j\u271d : n\n\u22a2 (PEquiv.refl n).toMatrix i\u271d j\u271d = 1 i\u271d j\u271d"}, {"line": "simp [toMatrix_apply, one_apply]", "tactic_state": "case a\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\ni\u271d j\u271d : n\n\u22a2 (if j\u271d \u2208 some i\u271d then 1 else 0) = if i\u271d = j\u271d then 1 else 0"}]}
{"declaration": "theorem toMatrix_toPEquiv_apply [DecidableEq n] [Zero \u03b1] [One \u03b1] (f : m \u2243 n) (i) :\n    f.toPEquiv.toMatrix i = Pi.single (f i) (1 : \u03b1) := by\n  ext\n  simp [toMatrix_apply, Pi.single_apply, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/PEquiv.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{k l m n : Type*}", "{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\nf : m \u2243 n\ni : m\n\u22a2 f.toPEquiv.toMatrix i = Pi.single (f i) 1"}, {"line": "ext", "tactic_state": "case h\nm : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\nf : m \u2243 n\ni : m\nx\u271d : n\n\u22a2 f.toPEquiv.toMatrix i x\u271d = Pi.single (f i) 1 x\u271d"}, {"line": "simp [toMatrix_apply, Pi.single_apply, eq_comm]", "tactic_state": "case h\nm : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\nf : m \u2243 n\ni : m\nx\u271d : n\n\u22a2 (if x\u271d = f i then 1 else 0) = if x\u271d \u2208 some (f i) then 1 else 0"}]}
{"declaration": "theorem transpose_toMatrix_toPEquiv_apply\n    [DecidableEq m] [DecidableEq n] [Zero \u03b1] [One \u03b1] (f : m \u2243 n) (j) :\n    f.toPEquiv.toMatrix\u1d40 j = Pi.single (f.symm j) (1 : \u03b1) := by\n  ext\n  simp [toMatrix_apply, Pi.single_apply, eq_comm, \u2190 Equiv.apply_eq_iff_eq_symm_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/PEquiv.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{k l m n : Type*}", "{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\nf : m \u2243 n\nj : n\n\u22a2 f.toPEquiv.toMatrix.transpose j = Pi.single (f.symm j) 1"}, {"line": "ext", "tactic_state": "case h\nm : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\nf : m \u2243 n\nj : n\nx\u271d : m\n\u22a2 f.toPEquiv.toMatrix.transpose j x\u271d = Pi.single (f.symm j) 1 x\u271d"}, {"line": "simp [toMatrix_apply, Pi.single_apply, eq_comm, \u2190 Equiv.apply_eq_iff_eq_symm_apply]", "tactic_state": "case h\nm : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\nf : m \u2243 n\nj : n\nx\u271d : m\n\u22a2 (if j \u2208 some (f x\u271d) then 1 else 0) = if x\u271d = f.symm j then 1 else 0"}]}
{"declaration": "lemma toMatrix_toPEquiv_mulVec [DecidableEq n] [Fintype n]\n    [NonAssocSemiring \u03b1] (\u03c3 : m \u2243 n) (a : n \u2192 \u03b1) :\n    \u03c3.toPEquiv.toMatrix *\u1d65 a = a \u2218 \u03c3 := by\n  ext j\n  simp [toMatrix, mulVec, dotProduct]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/PEquiv.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{k l m n : Type*}", "{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : NonAssocSemiring \u03b1\n\u03c3 : m \u2243 n\na : n \u2192 \u03b1\n\u22a2 \u03c3.toPEquiv.toMatrix.mulVec a = a \u2218 \u21d1\u03c3"}, {"line": "ext j", "tactic_state": "case h\nm : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : NonAssocSemiring \u03b1\n\u03c3 : m \u2243 n\na : n \u2192 \u03b1\nj : m\n\u22a2 \u03c3.toPEquiv.toMatrix.mulVec a j = (a \u2218 \u21d1\u03c3) j"}, {"line": "simp [toMatrix, mulVec, dotProduct]", "tactic_state": "case h\nm : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : NonAssocSemiring \u03b1\n\u03c3 : m \u2243 n\na : n \u2192 \u03b1\nj : m\n\u22a2 (\u2211 x, if x \u2208 some (\u03c3 j) then 1 * a x else 0) = a (\u03c3 j)"}]}
{"declaration": "theorem toMatrix_swap [DecidableEq n] [AddGroupWithOne \u03b1] (i j : n) :\n    (Equiv.swap i j).toPEquiv.toMatrix =\n      (1 : Matrix n n \u03b1) - (single i i).toMatrix - (single j j).toMatrix + (single i j).toMatrix +\n        (single j i).toMatrix := by\n  ext\n  dsimp [toMatrix, single, Equiv.swap_apply_def, Equiv.toPEquiv, one_apply]\n  split_ifs <;> simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/PEquiv.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{k l m n : Type*}", "{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_4\n\u03b1 : Type u_5\nx\u271d : Sort u_7\nsingle : x\u271d\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : AddGroupWithOne \u03b1\ni j : n\n\u22a2 (Equiv.toPEquiv (Equiv.swap i j)).toMatrix = 1 - sorry - sorry + sorry + sorry"}, {"line": "ext", "tactic_state": "case a\nn : Type u_4\n\u03b1 : Type u_5\nx\u271d : Sort u_7\nsingle : x\u271d\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : AddGroupWithOne \u03b1\ni j i\u271d j\u271d : n\n\u22a2 (Equiv.toPEquiv (Equiv.swap i j)).toMatrix i\u271d j\u271d = (1 - sorry - sorry + sorry + sorry) i\u271d j\u271d"}, {"line": "dsimp [toMatrix, single, Equiv.swap_apply_def, Equiv.toPEquiv, one_apply]", "tactic_state": "case a\nn : Type u_4\n\u03b1 : Type u_5\nx\u271d : Sort u_7\nsingle : x\u271d\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : AddGroupWithOne \u03b1\ni j i\u271d j\u271d : n\n\u22a2 (if j\u271d \u2208 some (if i\u271d = i then j else if i\u271d = j then i else i\u271d) then 1 else 0) =\n    (if i\u271d = j\u271d then 1 else 0) - sorry () i\u271d j\u271d - sorry () i\u271d j\u271d + sorry () i\u271d j\u271d + sorry () i\u271d j\u271d"}, {"line": "split_ifs <;> simp_all", "tactic_state": "case pos\nn : Type u_4\n\u03b1 : Type u_5\nx\u271d : Sort u_7\nsingle : x\u271d\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : AddGroupWithOne \u03b1\ni j i\u271d j\u271d : n\nh\u271d : i\u271d = i\n\u22a2 (if j\u271d \u2208 some (if i\u271d = i then j else if i\u271d = j then i else i\u271d) then 1 else 0) = if i\u271d = j\u271d then 1 else 0\n---\ncase neg\nn : Type u_4\n\u03b1 : Type u_5\nx\u271d : Sort u_7\nsingle : x\u271d\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : AddGroupWithOne \u03b1\ni j i\u271d j\u271d : n\nh\u271d : \u00aci\u271d = i\n\u22a2 (if j\u271d \u2208 some (if i\u271d = i then j else if i\u271d = j then i else i\u271d) then 1 else 0) = if i\u271d = j\u271d then 1 else 0"}]}
{"declaration": "lemma map_toMatrix [DecidableEq n] [NonAssocSemiring \u03b1] [NonAssocSemiring \u03b2]\n    (f : \u03b1 \u2192+* \u03b2) (\u03c3 : m \u2243. n) : \u03c3.toMatrix.map f = \u03c3.toMatrix := by\n  ext i j\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/PEquiv.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{k l m n : Type*}", "{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : NonAssocSemiring \u03b2\nf : \u03b1 \u2192+* \u03b2\n\u03c3 : m \u2243. n\n\u22a2 \u03c3.toMatrix.map \u21d1f = \u03c3.toMatrix"}, {"line": "ext i j", "tactic_state": "case a\nm : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : NonAssocSemiring \u03b2\nf : \u03b1 \u2192+* \u03b2\n\u03c3 : m \u2243. n\ni : m\nj : n\n\u22a2 \u03c3.toMatrix.map (\u21d1f) i j = \u03c3.toMatrix i j"}, {"line": "simp", "tactic_state": "case a\nm : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : NonAssocSemiring \u03b2\nf : \u03b1 \u2192+* \u03b2\n\u03c3 : m \u2243. n\ni : m\nj : n\n\u22a2 f (if j \u2208 \u03c3 i then 1 else 0) = if j \u2208 \u03c3 i then 1 else 0"}]}
{"declaration": "lemma cRank_submatrix_le {m m\u2080 : Type um} (A : Matrix m n R) (r : m\u2080 \u2192 m) (c : n\u2080 \u2192 n) :\n    (A.submatrix r c).cRank \u2264 A.cRank := by\n  simpa using lift_cRank_submatrix_le A r c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Rank.lean", "context": {"open": ["Matrix", "Module Cardinal Set Submodule"], "variables": ["{l : Type ul} {m : Type um} {m\u2080 : Type um\u2080} {n : Type un} {n\u2080 : Type un\u2080} {o : Type uo}", "{R : Type uR}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type un\nn\u2080 : Type un\u2080\nR : Type uR\ninst\u271d : Semiring R\nm m\u2080 : Type um\nA : Matrix m n R\nr : m\u2080 \u2192 m\nc : n\u2080 \u2192 n\n\u22a2 (A.submatrix r c).cRank \u2264 A.cRank"}, {"line": "simpa using lift_cRank_submatrix_le A r c", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eRank_submatrix_le (A : Matrix m n R) (r : m\u2080 \u2192 m) (c : n\u2080 \u2192 n) :\n    (A.submatrix r c).eRank \u2264 A.eRank := by\n  simpa using OrderHom.mono (\u03b2 := \u2115\u221e) Cardinal.toENat <| lift_cRank_submatrix_le A r c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Rank.lean", "context": {"open": ["Matrix", "Module Cardinal Set Submodule"], "variables": ["{l : Type ul} {m : Type um} {m\u2080 : Type um\u2080} {n : Type un} {n\u2080 : Type un\u2080} {o : Type uo}", "{R : Type uR}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type um\nm\u2080 : Type um\u2080\nn : Type un\nn\u2080 : Type un\u2080\nR : Type uR\ninst\u271d : Semiring R\nA : Matrix m n R\nr : m\u2080 \u2192 m\nc : n\u2080 \u2192 n\n\u22a2 (A.submatrix r c).eRank \u2264 A.eRank"}, {"line": "simpa using OrderHom.mono (\u03b2 := \u2115\u221e) Cardinal.toENat <| lift_cRank_submatrix_le A r c", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eRank_le_card_width [StrongRankCondition R] (A : Matrix m n R) : A.eRank \u2264 ENat.card n := by\n  wlog hfin : Finite n\n  \u00b7 simp [ENat.card_eq_top.2 (by simpa using hfin)]\n  have _ := Fintype.ofFinite n\n  rw [ENat.card_eq_coe_fintype_card]\n  rw [eRank]\n  rw [toENat_le_nat]\n  exact A.cRank_le_card_width\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Rank.lean", "context": {"open": ["Matrix", "Module Cardinal Set Submodule"], "variables": ["{l : Type ul} {m : Type um} {m\u2080 : Type um\u2080} {n : Type un} {n\u2080 : Type un\u2080} {o : Type uo}", "{R : Type uR}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type um\nn : Type un\nR : Type uR\ninst\u271d\u00b9 : Semiring R\ninst\u271d : StrongRankCondition R\nA : Matrix m n R\n\u22a2 A.eRank \u2264 ENat.card n"}, {"line": "wlog hfin : Finite n", "tactic_state": "case inr\nm : Type um\nn : Type un\nR : Type uR\ninst\u271d\u00b9 : Semiring R\ninst\u271d : StrongRankCondition R\nA : Matrix m n R\nthis :\n  \u2200 {m : Type um} {n : Type un} {R : Type uR} [inst : Semiring R] [inst_1 : StrongRankCondition R] (A : Matrix m n R),\n    Finite n \u2192 A.eRank \u2264 ENat.card n\nhfin : \u00acFinite n\n\u22a2 A.eRank \u2264 ENat.card n\n---\nm\u271d : Type um\nn\u271d : Type un\nR\u271d : Type uR\ninst\u271d\u00b2 : Semiring R\u271d\nm : Type um\nn : Type un\nR : Type uR\ninst\u271d\u00b9 : Semiring R\ninst\u271d : StrongRankCondition R\nA : Matrix m n R\nhfin : Finite n\n\u22a2 A.eRank \u2264 ENat.card n"}, {"line": "\u00b7 simp [ENat.card_eq_top.2 (by simpa using hfin)]", "tactic_state": "m\u271d : Type um\nn\u271d : Type un\nR\u271d : Type uR\ninst\u271d\u00b2 : Semiring R\u271d\nm : Type um\nn : Type un\nR : Type uR\ninst\u271d\u00b9 : Semiring R\ninst\u271d : StrongRankCondition R\nA : Matrix m n R\nhfin : Finite n\n\u22a2 A.eRank \u2264 ENat.card n"}, {"line": "have _ := Fintype.ofFinite n", "tactic_state": "m\u271d : Type um\nn\u271d : Type un\nR\u271d : Type uR\ninst\u271d\u00b2 : Semiring R\u271d\nm : Type um\nn : Type un\nR : Type uR\ninst\u271d\u00b9 : Semiring R\ninst\u271d : StrongRankCondition R\nA : Matrix m n R\nhfin : Finite n\nx\u271d : Fintype n\n\u22a2 A.eRank \u2264 ENat.card n"}, {"line": "rw [ENat.card_eq_coe_fintype_card]", "tactic_state": "m\u271d : Type um\nn\u271d : Type un\nR\u271d : Type uR\ninst\u271d\u00b2 : Semiring R\u271d\nm : Type um\nn : Type un\nR : Type uR\ninst\u271d\u00b9 : Semiring R\ninst\u271d : StrongRankCondition R\nA : Matrix m n R\nhfin : Finite n\nx\u271d : Fintype n\n\u22a2 A.eRank \u2264 \u2191(Fintype.card n)"}, {"line": "rw [eRank]", "tactic_state": "m\u271d : Type um\nn\u271d : Type un\nR\u271d : Type uR\ninst\u271d\u00b2 : Semiring R\u271d\nm : Type um\nn : Type un\nR : Type uR\ninst\u271d\u00b9 : Semiring R\ninst\u271d : StrongRankCondition R\nA : Matrix m n R\nhfin : Finite n\nx\u271d : Fintype n\n\u22a2 toENat A.cRank \u2264 \u2191(Fintype.card n)"}, {"line": "rw [toENat_le_nat]", "tactic_state": "m\u271d : Type um\nn\u271d : Type un\nR\u271d : Type uR\ninst\u271d\u00b2 : Semiring R\u271d\nm : Type um\nn : Type un\nR : Type uR\ninst\u271d\u00b9 : Semiring R\ninst\u271d : StrongRankCondition R\nA : Matrix m n R\nhfin : Finite n\nx\u271d : Fintype n\n\u22a2 A.cRank \u2264 \u2191(Fintype.card n)"}, {"line": "exact A.cRank_le_card_width", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eRank_zero {m n : Type*} [Nontrivial R] : eRank (0 : Matrix m n R) = 0 := by\n  simp [eRank]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Rank.lean", "context": {"open": ["Matrix", "Module Cardinal Set Submodule"], "variables": ["{l : Type ul} {m : Type um} {m\u2080 : Type um\u2080} {n : Type un} {n\u2080 : Type un\u2080} {o : Type uo}", "{R : Type uR}", "[Semiring R]", "[Fintype n] [Fintype o]", "[CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type uR\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommRing R\nm : Type u_1\nn : Type u_2\ninst\u271d : Nontrivial R\n\u22a2 eRank 0 = 0"}, {"line": "simp [eRank]", "tactic_state": "R : Type uR\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommRing R\nm : Type u_1\nn : Type u_2\ninst\u271d : Nontrivial R\n\u22a2 cRank 0 = 0"}]}
{"declaration": "theorem rank_le_card_width [StrongRankCondition R] (A : Matrix m n R) :\n    A.rank \u2264 Fintype.card n := by\n  haveI : Module.Finite R (n \u2192 R) := Module.Finite.pi\n  haveI : Module.Free R (n \u2192 R) := Module.Free.pi _ _\n  exact A.mulVecLin.finrank_range_le.trans_eq (finrank_pi _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Rank.lean", "context": {"open": ["Matrix", "Module Cardinal Set Submodule"], "variables": ["{l : Type ul} {m : Type um} {m\u2080 : Type um\u2080} {n : Type un} {n\u2080 : Type un\u2080} {o : Type uo}", "{R : Type uR}", "[Semiring R]", "[Fintype n] [Fintype o]", "[CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type um\nn : Type un\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing R\ninst\u271d : StrongRankCondition R\nA : Matrix m n R\n\u22a2 A.rank \u2264 Fintype.card n"}, {"line": "haveI : Module.Finite R (n \u2192 R) := Module.Finite.pi", "tactic_state": "m : Type um\nn : Type un\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing R\ninst\u271d : StrongRankCondition R\nA : Matrix m n R\nthis : sorry\n\u22a2 A.rank \u2264 Fintype.card n"}, {"line": "haveI : Module.Free R (n \u2192 R) := Module.Free.pi _ _", "tactic_state": "m : Type um\nn : Type un\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing R\ninst\u271d : StrongRankCondition R\nA : Matrix m n R\nthis\u271d : sorry\nthis : sorry\n\u22a2 A.rank \u2264 Fintype.card n"}, {"line": "exact A.mulVecLin.finrank_range_le.trans_eq (finrank_pi _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rank_reindex [Fintype n\u2080] (em : m \u2243 m\u2080) (en : n \u2243 n\u2080) (A : Matrix m n R) :\n    rank (A.reindex em en) = rank A := by\n  rw [rank]\n  rw [rank]\n  rw [mulVecLin_reindex]\n  rw [LinearMap.range_comp]\n  rw [LinearMap.range_comp]\n  rw [LinearEquiv.range]\n  rw [Submodule.map_top]\n  rw [LinearEquiv.finrank_map_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Rank.lean", "context": {"open": ["Matrix", "Module Cardinal Set Submodule"], "variables": ["{l : Type ul} {m : Type um} {m\u2080 : Type um\u2080} {n : Type un} {n\u2080 : Type un\u2080} {o : Type uo}", "{R : Type uR}", "[Semiring R]", "[Fintype n] [Fintype o]", "[CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type um\nm\u2080 : Type um\u2080\nn : Type un\nn\u2080 : Type un\u2080\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype n\u2080\nem : m \u2243 m\u2080\nen : n \u2243 n\u2080\nA : Matrix m n R\n\u22a2 ((reindex em en) A).rank = A.rank"}, {"line": "rw [rank]", "tactic_state": "m : Type um\nm\u2080 : Type um\u2080\nn : Type un\nn\u2080 : Type un\u2080\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype n\u2080\nem : m \u2243 m\u2080\nen : n \u2243 n\u2080\nA : Matrix m n R\n\u22a2 finrank R \u21a5(LinearMap.range ((reindex em en) A).mulVecLin) = A.rank"}, {"line": "rw [rank]", "tactic_state": "m : Type um\nm\u2080 : Type um\u2080\nn : Type un\nn\u2080 : Type un\u2080\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype n\u2080\nem : m \u2243 m\u2080\nen : n \u2243 n\u2080\nA : Matrix m n R\n\u22a2 finrank R \u21a5(LinearMap.range ((reindex em en) A).mulVecLin) = finrank R \u21a5(LinearMap.range A.mulVecLin)"}, {"line": "rw [mulVecLin_reindex]", "tactic_state": "m : Type um\nm\u2080 : Type um\u2080\nn : Type un\nn\u2080 : Type un\u2080\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype n\u2080\nem : m \u2243 m\u2080\nen : n \u2243 n\u2080\nA : Matrix m n R\n\u22a2 finrank R\n      \u21a5(LinearMap.range\n          (\u2191(LinearEquiv.funCongrLeft R R em.symm) \u2218\u2097 A.mulVecLin \u2218\u2097 \u2191(LinearEquiv.funCongrLeft R R en))) =\n    finrank R \u21a5(LinearMap.range A.mulVecLin)\n---\nm : Type um\nm\u2080 : Type um\u2080\nn : Type un\nn\u2080 : Type un\u2080\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype n\u2080\nem : m \u2243 m\u2080\nen : n \u2243 n\u2080\nA : Matrix m n R\n\u22a2 Fintype n"}, {"line": "rw [LinearMap.range_comp]", "tactic_state": "m : Type um\nm\u2080 : Type um\u2080\nn : Type un\nn\u2080 : Type un\u2080\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype n\u2080\nem : m \u2243 m\u2080\nen : n \u2243 n\u2080\nA : Matrix m n R\n\u22a2 finrank R\n      \u21a5(Submodule.map (\u2191(LinearEquiv.funCongrLeft R R em.symm))\n          (LinearMap.range (A.mulVecLin \u2218\u2097 \u2191(LinearEquiv.funCongrLeft R R en)))) =\n    finrank R \u21a5(LinearMap.range A.mulVecLin)\n---\nm : Type um\nm\u2080 : Type um\u2080\nn : Type un\nn\u2080 : Type un\u2080\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype n\u2080\nem : m \u2243 m\u2080\nen : n \u2243 n\u2080\nA : Matrix m n R\n\u22a2 Fintype n"}, {"line": "rw [LinearMap.range_comp]", "tactic_state": "m : Type um\nm\u2080 : Type um\u2080\nn : Type un\nn\u2080 : Type un\u2080\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype n\u2080\nem : m \u2243 m\u2080\nen : n \u2243 n\u2080\nA : Matrix m n R\n\u22a2 finrank R\n      \u21a5(Submodule.map (\u2191(LinearEquiv.funCongrLeft R R em.symm))\n          (Submodule.map A.mulVecLin (LinearMap.range \u2191(LinearEquiv.funCongrLeft R R en)))) =\n    finrank R \u21a5(LinearMap.range A.mulVecLin)\n---\nm : Type um\nm\u2080 : Type um\u2080\nn : Type un\nn\u2080 : Type un\u2080\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype n\u2080\nem : m \u2243 m\u2080\nen : n \u2243 n\u2080\nA : Matrix m n R\n\u22a2 Fintype n"}, {"line": "rw [LinearEquiv.range]", "tactic_state": "m : Type um\nm\u2080 : Type um\u2080\nn : Type un\nn\u2080 : Type un\u2080\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype n\u2080\nem : m \u2243 m\u2080\nen : n \u2243 n\u2080\nA : Matrix m n R\n\u22a2 finrank R \u21a5(Submodule.map (\u2191(LinearEquiv.funCongrLeft R R em.symm)) (Submodule.map A.mulVecLin \u22a4)) =\n    finrank R \u21a5(LinearMap.range A.mulVecLin)\n---\nm : Type um\nm\u2080 : Type um\u2080\nn : Type un\nn\u2080 : Type un\u2080\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype n\u2080\nem : m \u2243 m\u2080\nen : n \u2243 n\u2080\nA : Matrix m n R\n\u22a2 Fintype n"}, {"line": "rw [Submodule.map_top]", "tactic_state": "m : Type um\nm\u2080 : Type um\u2080\nn : Type un\nn\u2080 : Type un\u2080\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype n\u2080\nem : m \u2243 m\u2080\nen : n \u2243 n\u2080\nA : Matrix m n R\n\u22a2 finrank R \u21a5(Submodule.map (\u2191(LinearEquiv.funCongrLeft R R em.symm)) (LinearMap.range A.mulVecLin)) =\n    finrank R \u21a5(LinearMap.range A.mulVecLin)\n---\nm : Type um\nm\u2080 : Type um\u2080\nn : Type un\nn\u2080 : Type un\u2080\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype n\u2080\nem : m \u2243 m\u2080\nen : n \u2243 n\u2080\nA : Matrix m n R\n\u22a2 Fintype n"}, {"line": "rw [LinearEquiv.finrank_map_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rank_submatrix [Fintype n\u2080] (A : Matrix m n R) (em : m\u2080 \u2243 m) (en : n\u2080 \u2243 n) :\n    rank (A.submatrix em en) = rank A := by\n  simpa only [reindex_apply] using rank_reindex em.symm en.symm A\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Rank.lean", "context": {"open": ["Matrix", "Module Cardinal Set Submodule"], "variables": ["{l : Type ul} {m : Type um} {m\u2080 : Type um\u2080} {n : Type un} {n\u2080 : Type un\u2080} {o : Type uo}", "{R : Type uR}", "[Semiring R]", "[Fintype n] [Fintype o]", "[CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type um\nm\u2080 : Type um\u2080\nn : Type un\nn\u2080 : Type un\u2080\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype n\u2080\nA : Matrix m n R\nem : m\u2080 \u2243 m\nen : n\u2080 \u2243 n\n\u22a2 (A.submatrix \u21d1em \u21d1en).rank = A.rank"}, {"line": "simpa only [reindex_apply] using rank_reindex em.symm en.symm A", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cRank_submatrix {m\u2080 : Type um} {n : Type un} (A : Matrix m n R) (em : m\u2080 \u2243 m)\n    (en : n\u2080 \u2243 n) : cRank (A.submatrix em en) = cRank A := by\n  simpa [-lift_cRank_submatrix] using A.lift_cRank_submatrix em en\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Rank.lean", "context": {"open": ["Matrix", "Module Cardinal Set Submodule"], "variables": ["{l : Type ul} {m : Type um} {m\u2080 : Type um\u2080} {n : Type un} {n\u2080 : Type un\u2080} {o : Type uo}", "{R : Type uR}", "[Semiring R]", "[Fintype n] [Fintype o]", "[CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type um\nn\u2080 : Type un\u2080\nR : Type uR\ninst\u271d\u00b9 : Semiring R\ninst\u271d : CommRing R\nm\u2080 : Type um\nn : Type un\nA : Matrix m n R\nem : m\u2080 \u2243 m\nen : n\u2080 \u2243 n\n\u22a2 (A.submatrix \u21d1em \u21d1en).cRank = A.cRank"}, {"line": "simpa [-lift_cRank_submatrix] using A.lift_cRank_submatrix em en", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rank_eq_finrank_span_cols (A : Matrix m n R) :\n    A.rank = finrank R (Submodule.span R (Set.range A.col)) := by rw [rank, Matrix.range_mulVecLin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Rank.lean", "context": {"open": ["Matrix", "Module Cardinal Set Submodule"], "variables": ["{l : Type ul} {m : Type um} {m\u2080 : Type um\u2080} {n : Type un} {n\u2080 : Type un\u2080} {o : Type uo}", "{R : Type uR}", "[Semiring R]", "[Fintype n] [Fintype o]", "[CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type um\nn : Type un\nR : Type uR\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing R\nA : Matrix m n R\n\u22a2 A.rank = sorry"}, {"line": "rw [rank, Matrix.range_mulVecLin]", "tactic_state": "m : Type um\nn : Type un\nR : Type uR\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommRing R\nA : Matrix m n R\n\u22a2 finrank R \u21a5(span R (range A.col)) = sorry"}]}
{"declaration": "theorem eRank_diagonal [DecidableEq m] (w : m \u2192 R) :\n    (diagonal w).eRank = {i | (w i) \u2260 0}.encard := by\n  simp [eRank, cRank_diagonal, toENat_cardinalMk_subtype]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Rank.lean", "context": {"open": ["Matrix", "Module Cardinal Set Submodule"], "variables": ["{l : Type ul} {m : Type um} {m\u2080 : Type um\u2080} {n : Type un} {n\u2080 : Type un\u2080} {o : Type uo}", "{R : Type uR}", "[Semiring R]", "[Fintype n] [Fintype o]", "[CommRing R]", "[Field R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type um\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Field R\ninst\u271d : DecidableEq m\nw : m \u2192 R\n\u22a2 (Matrix.diagonal w).eRank = {i | w i \u2260 0}.encard"}, {"line": "simp [eRank, cRank_diagonal, toENat_cardinalMk_subtype]", "tactic_state": "m : Type um\nR : Type uR\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Field R\ninst\u271d : DecidableEq m\nw : m \u2192 R\n\u22a2 toENat (Matrix.diagonal w).cRank = {i | \u00acw i = 0}.encard"}]}
{"declaration": "theorem mulVec_stdBasisMatrix [NonUnitalNonAssocSemiring \u03b1] [Fintype m]\n    (i : n) (j : m) (c : \u03b1) (x : m \u2192 \u03b1) :\n    mulVec (stdBasisMatrix i j c) x = Function.update (0 : n \u2192 \u03b1) i (c * x j) := by\n  ext i'\n  simp [stdBasisMatrix, mulVec, dotProduct]\n  rcases eq_or_ne i i' with rfl|h\n  \u00b7 simp\n  simp [h, h.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Basis.lean", "context": {"open": [], "variables": ["{l m n o : Type*}", "{R \u03b1 \u03b2 : Type*}", "[DecidableEq l] [DecidableEq m] [DecidableEq n] [DecidableEq o]", "[Zero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Zero \u03b1\nx\u271d : Sort u_8\nmulVec : x\u271d\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype m\ni : n\nj : m\nc : \u03b1\nx : m \u2192 \u03b1\n\u22a2 sorry = Function.update 0 i (c * x j)"}, {"line": "ext i'", "tactic_state": "case h\nm : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Zero \u03b1\nx\u271d : Sort u_8\nmulVec : x\u271d\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype m\ni : n\nj : m\nc : \u03b1\nx : m \u2192 \u03b1\ni' : n\n\u22a2 sorry i' = Function.update 0 i (c * x j) i'"}, {"line": "simp [stdBasisMatrix, mulVec, dotProduct]", "tactic_state": "case h\nm : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Zero \u03b1\nx\u271d : Sort u_8\nmulVec : x\u271d\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype m\ni : n\nj : m\nc : \u03b1\nx : m \u2192 \u03b1\ni' : n\n\u22a2 sorry () i' = Function.update 0 i (c * x j) i'"}, {"line": "rcases eq_or_ne i i' with rfl|h", "tactic_state": "case h.inl\nm : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Zero \u03b1\nx\u271d : Sort u_8\nmulVec : x\u271d\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype m\ni : n\nj : m\nc : \u03b1\nx : m \u2192 \u03b1\n\u22a2 sorry () i = Function.update 0 i (c * x j) i\n---\ncase h.inr\nm : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Zero \u03b1\nx\u271d : Sort u_8\nmulVec : x\u271d\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype m\ni : n\nj : m\nc : \u03b1\nx : m \u2192 \u03b1\ni' : n\nh : i \u2260 i'\n\u22a2 sorry () i' = Function.update 0 i (c * x j) i'"}, {"line": "\u00b7 simp", "tactic_state": "case h.inr\nm : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Zero \u03b1\nx\u271d : Sort u_8\nmulVec : x\u271d\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype m\ni : n\nj : m\nc : \u03b1\nx : m \u2192 \u03b1\ni' : n\nh : i \u2260 i'\n\u22a2 sorry () i' = Function.update 0 i (c * x j) i'"}, {"line": "simp [h, h.symm]", "tactic_state": "case h.inr\nm : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Zero \u03b1\nx\u271d : Sort u_8\nmulVec : x\u271d\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype m\ni : n\nj : m\nc : \u03b1\nx : m \u2192 \u03b1\ni' : n\nh : i \u2260 i'\n\u22a2 sorry () i' = 0"}]}
{"declaration": "theorem matrix_eq_sum_stdBasisMatrix [AddCommMonoid \u03b1] [Fintype m] [Fintype n] (x : Matrix m n \u03b1) :\n    x = \u2211 i : m, \u2211 j : n, stdBasisMatrix i j (x i j) := by\n  ext i j\n  rw [\u2190 Fintype.sum_prod_type']\n  simp [stdBasisMatrix, Matrix.sum_apply, Matrix.of_apply, \u2190 Prod.mk_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Basis.lean", "context": {"open": [], "variables": ["{l m n o : Type*}", "{R \u03b1 \u03b2 : Type*}", "[DecidableEq l] [DecidableEq m] [DecidableEq n] [DecidableEq o]", "[Zero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Zero \u03b1\nx\u271d : Sort u_8\nstdBasisMatrix : x\u271d\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nx : Matrix m n \u03b1\n\u22a2 x = \u2211 i, \u2211 j, sorry"}, {"line": "ext i j", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Zero \u03b1\nx\u271d : Sort u_8\nstdBasisMatrix : x\u271d\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nx : Matrix m n \u03b1\ni : m\nj : n\n\u22a2 x i j = (\u2211 i, \u2211 j, sorry) i j"}, {"line": "rw [\u2190 Fintype.sum_prod_type']", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Zero \u03b1\nx\u271d : Sort u_8\nstdBasisMatrix : x\u271d\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nx : Matrix m n \u03b1\ni : m\nj : n\n\u22a2 x i j = (\u2211 x, sorry) i j"}, {"line": "simp [stdBasisMatrix, Matrix.sum_apply, Matrix.of_apply, \u2190 Prod.mk_inj]", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Zero \u03b1\nx\u271d : Sort u_8\nstdBasisMatrix : x\u271d\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nx : Matrix m n \u03b1\ni : m\nj : n\n\u22a2 x i j = (Fintype.card m * Fintype.card n) \u2022 sorry () i j"}]}
{"declaration": "theorem apply_of_row_ne {i i' : m} (hi : i \u2260 i') (j j' : n) (a : \u03b1) :\n    stdBasisMatrix i j a i' j' = 0 := by simp [hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Basis.lean", "context": {"open": [], "variables": ["{l m n o : Type*}", "{R \u03b1 \u03b2 : Type*}", "[DecidableEq l] [DecidableEq m] [DecidableEq n] [DecidableEq o]", "[Zero \u03b1]", "(R)", "[Zero \u03b1] (i : m) (j : n) (c : \u03b1) (i' : m) (j' : n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 inst\u271d : Zero \u03b1\nx\u271d : Sort u_8\nstdBasisMatrix : x\u271d\ni i' : m\nhi : i \u2260 i'\nj j' : n\na : \u03b1\n\u22a2 sorry = 0"}, {"line": "simp [hi]", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 inst\u271d : Zero \u03b1\nx\u271d : Sort u_8\nstdBasisMatrix : x\u271d\ni i' : m\nhi : i \u2260 i'\nj j' : n\na : \u03b1\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem apply_of_col_ne (i i' : m) {j j' : n} (hj : j \u2260 j') (a : \u03b1) :\n    stdBasisMatrix i j a i' j' = 0 := by simp [hj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Basis.lean", "context": {"open": [], "variables": ["{l m n o : Type*}", "{R \u03b1 \u03b2 : Type*}", "[DecidableEq l] [DecidableEq m] [DecidableEq n] [DecidableEq o]", "[Zero \u03b1]", "(R)", "[Zero \u03b1] (i : m) (j : n) (c : \u03b1) (i' : m) (j' : n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 inst\u271d : Zero \u03b1\nx\u271d : Sort u_8\nstdBasisMatrix : x\u271d\ni i' : m\nj j' : n\nhj : j \u2260 j'\na : \u03b1\n\u22a2 sorry = 0"}, {"line": "simp [hj]", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 inst\u271d : Zero \u03b1\nx\u271d : Sort u_8\nstdBasisMatrix : x\u271d\ni i' : m\nj j' : n\nhj : j \u2260 j'\na : \u03b1\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem mul_left_apply_same (i : l) (j : m) (b : n) (M : Matrix m n \u03b1) :\n    (stdBasisMatrix i j c * M) i b = c * M j b := by simp [mul_apply, stdBasisMatrix]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Basis.lean", "context": {"open": [], "variables": ["{l m n o : Type*}", "{R \u03b1 \u03b2 : Type*}", "[DecidableEq l] [DecidableEq m] [DecidableEq n] [DecidableEq o]", "[Zero \u03b1]", "(R)", "[Zero \u03b1] (i : m) (j : n) (c : \u03b1) (i' : m) (j' : n)", "[Zero \u03b1] (i j : n) (c : \u03b1)", "[Fintype m] [NonUnitalNonAssocSemiring \u03b1] (c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2077 : DecidableEq l\ninst\u271d\u2076 : DecidableEq m\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Fintype m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nc : \u03b1\nx\u271d : Sort u_8\nstdBasisMatrix : x\u271d\ni : l\nj : m\nb : n\nM : Matrix m n \u03b1\n\u22a2 sorry = c * M j b"}, {"line": "simp [mul_apply, stdBasisMatrix]", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2077 : DecidableEq l\ninst\u271d\u2076 : DecidableEq m\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Fintype m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nc : \u03b1\nx\u271d : Sort u_8\nstdBasisMatrix : x\u271d\ni : l\nj : m\nb : n\nM : Matrix m n \u03b1\n\u22a2 sorry () = c * M j b"}]}
{"declaration": "theorem mul_right_apply_same (i : m) (j : n) (a : l) (M : Matrix l m \u03b1) :\n    (M * stdBasisMatrix i j c) a j = M a i * c := by simp [mul_apply, stdBasisMatrix, mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Basis.lean", "context": {"open": [], "variables": ["{l m n o : Type*}", "{R \u03b1 \u03b2 : Type*}", "[DecidableEq l] [DecidableEq m] [DecidableEq n] [DecidableEq o]", "[Zero \u03b1]", "(R)", "[Zero \u03b1] (i : m) (j : n) (c : \u03b1) (i' : m) (j' : n)", "[Zero \u03b1] (i j : n) (c : \u03b1)", "[Fintype m] [NonUnitalNonAssocSemiring \u03b1] (c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2077 : DecidableEq l\ninst\u271d\u2076 : DecidableEq m\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Fintype m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nc : \u03b1\nx\u271d : Sort u_8\nstdBasisMatrix : x\u271d\ni : m\nj : n\na : l\nM : Matrix l m \u03b1\n\u22a2 sorry = M a i * c"}, {"line": "simp [mul_apply, stdBasisMatrix, mul_comm]", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2077 : DecidableEq l\ninst\u271d\u2076 : DecidableEq m\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Fintype m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nc : \u03b1\nx\u271d : Sort u_8\nstdBasisMatrix : x\u271d\ni : m\nj : n\na : l\nM : Matrix l m \u03b1\n\u22a2 sorry () = M a i * c"}]}
{"declaration": "theorem mul_left_apply_of_ne (i : l) (j : m) (a : l) (b : n) (h : a \u2260 i) (M : Matrix m n \u03b1) :\n    (stdBasisMatrix i j c * M) a b = 0 := by simp [mul_apply, h.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Basis.lean", "context": {"open": [], "variables": ["{l m n o : Type*}", "{R \u03b1 \u03b2 : Type*}", "[DecidableEq l] [DecidableEq m] [DecidableEq n] [DecidableEq o]", "[Zero \u03b1]", "(R)", "[Zero \u03b1] (i : m) (j : n) (c : \u03b1) (i' : m) (j' : n)", "[Zero \u03b1] (i j : n) (c : \u03b1)", "[Fintype m] [NonUnitalNonAssocSemiring \u03b1] (c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2077 : DecidableEq l\ninst\u271d\u2076 : DecidableEq m\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Fintype m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nx\u271d : Sort u_8\nstdBasisMatrix : x\u271d\ni : l\nj : m\na : l\nb : n\nh : a \u2260 i\nM : Matrix m n \u03b1\n\u22a2 sorry = 0"}, {"line": "simp [mul_apply, h.symm]", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2077 : DecidableEq l\ninst\u271d\u2076 : DecidableEq m\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Fintype m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nx\u271d : Sort u_8\nstdBasisMatrix : x\u271d\ni : l\nj : m\na : l\nb : n\nh : a \u2260 i\nM : Matrix m n \u03b1\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem mul_right_apply_of_ne (i : m) (j : n) (a : l) (b : n) (hbj : b \u2260 j) (M : Matrix l m \u03b1) :\n    (M * stdBasisMatrix i j c) a b = 0 := by simp [mul_apply, hbj.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Basis.lean", "context": {"open": [], "variables": ["{l m n o : Type*}", "{R \u03b1 \u03b2 : Type*}", "[DecidableEq l] [DecidableEq m] [DecidableEq n] [DecidableEq o]", "[Zero \u03b1]", "(R)", "[Zero \u03b1] (i : m) (j : n) (c : \u03b1) (i' : m) (j' : n)", "[Zero \u03b1] (i j : n) (c : \u03b1)", "[Fintype m] [NonUnitalNonAssocSemiring \u03b1] (c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2077 : DecidableEq l\ninst\u271d\u2076 : DecidableEq m\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Fintype m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nx\u271d : Sort u_8\nstdBasisMatrix : x\u271d\ni : m\nj : n\na : l\nb : n\nhbj : b \u2260 j\nM : Matrix l m \u03b1\n\u22a2 sorry = 0"}, {"line": "simp [mul_apply, hbj.symm]", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\n\u03b1 : Type u_6\ninst\u271d\u2077 : DecidableEq l\ninst\u271d\u2076 : DecidableEq m\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Fintype m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nx\u271d : Sort u_8\nstdBasisMatrix : x\u271d\ni : m\nj : n\na : l\nb : n\nhbj : b \u2260 j\nM : Matrix l m \u03b1\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem star_dotProduct : star v \u2b1d\u1d65 w = star (star w \u2b1d\u1d65 v) := by simp [dotProduct]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/ConjTranspose.lean", "context": {"open": [], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[DecidableEq n]", "[Fintype m] [Fintype n]", "[NonUnitalSemiring \u03b1] [StarRing \u03b1] (v w : m \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : NonUnitalSemiring \u03b1\ninst\u271d : StarRing \u03b1\nv w : m \u2192 \u03b1\n\u22a2 star v \u2b1d\u1d65 w = star (star w \u2b1d\u1d65 v)"}, {"line": "simp [dotProduct]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dotProduct_star : v \u2b1d\u1d65 star w = star (w \u2b1d\u1d65 star v) := by simp [dotProduct]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/ConjTranspose.lean", "context": {"open": [], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[DecidableEq n]", "[Fintype m] [Fintype n]", "[NonUnitalSemiring \u03b1] [StarRing \u03b1] (v w : m \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : NonUnitalSemiring \u03b1\ninst\u271d : StarRing \u03b1\nv w : m \u2192 \u03b1\n\u22a2 v \u2b1d\u1d65 star w = star (w \u2b1d\u1d65 star v)"}, {"line": "simp [dotProduct]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem conjTranspose_one [DecidableEq n] [NonAssocSemiring \u03b1] [StarRing \u03b1] :\n    (1 : Matrix n n \u03b1)\u1d34 = 1 := by\n  simp [conjTranspose]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/ConjTranspose.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[DecidableEq n]", "[Fintype m] [Fintype n]", "[NonUnitalSemiring \u03b1] [StarRing \u03b1] (v w : m \u2192 \u03b1)", "[NonUnitalSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\n\u03b1 : Type v\ninst\u271d\u2077 : DecidableEq n\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : NonUnitalSemiring \u03b1\ninst\u271d\u2074 : StarRing \u03b1\ninst\u271d\u00b3 : NonUnitalSemiring \u03b1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : StarRing \u03b1\n\u22a2 conjTranspose 1 = 1"}, {"line": "simp [conjTranspose]", "tactic_state": "n : Type u_3\n\u03b1 : Type v\ninst\u271d\u2077 : DecidableEq n\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : NonUnitalSemiring \u03b1\ninst\u271d\u2074 : StarRing \u03b1\ninst\u271d\u00b3 : NonUnitalSemiring \u03b1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : StarRing \u03b1\n\u22a2 map 1 star = 1"}]}
{"declaration": "theorem conjTranspose_natCast [DecidableEq n] [NonAssocSemiring \u03b1] [StarRing \u03b1] (d : \u2115) :\n    (d : Matrix n n \u03b1)\u1d34 = d := by\n  simp [conjTranspose, Matrix.map_natCast, diagonal_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/ConjTranspose.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[DecidableEq n]", "[Fintype m] [Fintype n]", "[NonUnitalSemiring \u03b1] [StarRing \u03b1] (v w : m \u2192 \u03b1)", "[NonUnitalSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\n\u03b1 : Type v\ninst\u271d\u2077 : DecidableEq n\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : NonUnitalSemiring \u03b1\ninst\u271d\u2074 : StarRing \u03b1\ninst\u271d\u00b3 : NonUnitalSemiring \u03b1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : StarRing \u03b1\nd : \u2115\n\u22a2 (\u2191d).conjTranspose = \u2191d"}, {"line": "simp [conjTranspose, Matrix.map_natCast, diagonal_natCast]", "tactic_state": "n : Type u_3\n\u03b1 : Type v\ninst\u271d\u2077 : DecidableEq n\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : NonUnitalSemiring \u03b1\ninst\u271d\u2074 : StarRing \u03b1\ninst\u271d\u00b3 : NonUnitalSemiring \u03b1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : StarRing \u03b1\nd : \u2115\n\u22a2 (\u2191d).map star = \u2191d"}]}
{"declaration": "theorem conjTranspose_intCast [DecidableEq n] [Ring \u03b1] [StarRing \u03b1] (d : \u2124) :\n    (d : Matrix n n \u03b1)\u1d34 = d := by\n  simp [conjTranspose, Matrix.map_intCast, diagonal_intCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/ConjTranspose.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[DecidableEq n]", "[Fintype m] [Fintype n]", "[NonUnitalSemiring \u03b1] [StarRing \u03b1] (v w : m \u2192 \u03b1)", "[NonUnitalSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\n\u03b1 : Type v\ninst\u271d\u2077 : DecidableEq n\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : NonUnitalSemiring \u03b1\ninst\u271d\u2074 : StarRing \u03b1\ninst\u271d\u00b3 : NonUnitalSemiring \u03b1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Ring \u03b1\ninst\u271d : StarRing \u03b1\nd : \u2124\n\u22a2 (\u2191d).conjTranspose = \u2191d"}, {"line": "simp [conjTranspose, Matrix.map_intCast, diagonal_intCast]", "tactic_state": "n : Type u_3\n\u03b1 : Type v\ninst\u271d\u2077 : DecidableEq n\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : NonUnitalSemiring \u03b1\ninst\u271d\u2074 : StarRing \u03b1\ninst\u271d\u00b3 : NonUnitalSemiring \u03b1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Ring \u03b1\ninst\u271d : StarRing \u03b1\nd : \u2124\n\u22a2 (\u2191d).map star = \u2191d"}]}
{"declaration": "theorem map_id (M : Matrix m n \u03b1) : M.map id = M := by\n  ext\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Defs.lean", "context": {"open": [], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "{M N : Matrix m n \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\nM : Matrix m n \u03b1\n\u22a2 M.map id = M"}, {"line": "ext", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\nM : Matrix m n \u03b1\ni\u271d : m\nj\u271d : n\n\u22a2 M.map id i\u271d j\u271d = M i\u271d j\u271d"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_map {M : Matrix m n \u03b1} {\u03b2 \u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} :\n    (M.map f).map g = M.map (g \u2218 f) := by\n  ext\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Defs.lean", "context": {"open": [], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "{M N : Matrix m n \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\nM : Matrix m n \u03b1\n\u03b2 : Type u_10\n\u03b3 : Type u_11\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\n\u22a2 (M.map f).map g = M.map (g \u2218 f)"}, {"line": "ext", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\nM : Matrix m n \u03b1\n\u03b2 : Type u_10\n\u03b3 : Type u_11\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\ni\u271d : m\nj\u271d : n\n\u22a2 (M.map f).map g i\u271d j\u271d = M.map (g \u2218 f) i\u271d j\u271d"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transpose_transpose (M : Matrix m n \u03b1) : M\u1d40\u1d40 = M := by\n  ext\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Defs.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "{M N : Matrix m n \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\nM : Matrix m n \u03b1\n\u22a2 M.transpose.transpose = M"}, {"line": "ext", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\nM : Matrix m n \u03b1\ni\u271d : m\nj\u271d : n\n\u22a2 M.transpose.transpose i\u271d j\u271d = M i\u271d j\u271d"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transpose_add [Add \u03b1] (M : Matrix m n \u03b1) (N : Matrix m n \u03b1) : (M + N)\u1d40 = M\u1d40 + N\u1d40 := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Defs.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "{M N : Matrix m n \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d : Add \u03b1\nM N : Matrix m n \u03b1\n\u22a2 (M + N).transpose = M.transpose + N.transpose"}, {"line": "ext", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d : Add \u03b1\nM N : Matrix m n \u03b1\ni\u271d : n\nj\u271d : m\n\u22a2 (M + N).transpose i\u271d j\u271d = (M.transpose + N.transpose) i\u271d j\u271d"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transpose_sub [Sub \u03b1] (M : Matrix m n \u03b1) (N : Matrix m n \u03b1) : (M - N)\u1d40 = M\u1d40 - N\u1d40 := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Defs.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "{M N : Matrix m n \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d : Sub \u03b1\nM N : Matrix m n \u03b1\n\u22a2 (M - N).transpose = M.transpose - N.transpose"}, {"line": "ext", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d : Sub \u03b1\nM N : Matrix m n \u03b1\ni\u271d : n\nj\u271d : m\n\u22a2 (M - N).transpose i\u271d j\u271d = (M.transpose - N.transpose) i\u271d j\u271d"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transpose_smul {R : Type*} [SMul R \u03b1] (c : R) (M : Matrix m n \u03b1) : (c \u2022 M)\u1d40 = c \u2022 M\u1d40 := by\n  ext\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Defs.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "{M N : Matrix m n \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\nR : Type u_10\ninst\u271d : SMul R \u03b1\nc : R\nM : Matrix m n \u03b1\n\u22a2 (c \u2022 M).transpose = c \u2022 M.transpose"}, {"line": "ext", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\nR : Type u_10\ninst\u271d : SMul R \u03b1\nc : R\nM : Matrix m n \u03b1\ni\u271d : n\nj\u271d : m\n\u22a2 (c \u2022 M).transpose i\u271d j\u271d = (c \u2022 M.transpose) i\u271d j\u271d"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transpose_neg [Neg \u03b1] (M : Matrix m n \u03b1) : (-M)\u1d40 = -M\u1d40 := by\n  ext\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Defs.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "{M N : Matrix m n \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d : Neg \u03b1\nM : Matrix m n \u03b1\n\u22a2 (-M).transpose = -M.transpose"}, {"line": "ext", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d : Neg \u03b1\nM : Matrix m n \u03b1\ni\u271d : n\nj\u271d : m\n\u22a2 (-M).transpose i\u271d j\u271d = (-M.transpose) i\u271d j\u271d"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transpose_map {f : \u03b1 \u2192 \u03b2} {M : Matrix m n \u03b1} : M\u1d40.map f = (M.map f)\u1d40 := by\n  ext\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Defs.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "{M N : Matrix m n \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\n\u03b2 : Type w\nf : \u03b1 \u2192 \u03b2\nM : Matrix m n \u03b1\n\u22a2 M.transpose.map f = (M.map f).transpose"}, {"line": "ext", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\n\u03b2 : Type w\nf : \u03b1 \u2192 \u03b2\nM : Matrix m n \u03b1\ni\u271d : n\nj\u271d : m\n\u22a2 M.transpose.map f i\u271d j\u271d = (M.map f).transpose i\u271d j\u271d"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem diagonal_apply_ne [Zero \u03b1] (d : n \u2192 \u03b1) {i j : n} (h : i \u2260 j) : (diagonal d) i j = 0 := by\n  simp [diagonal, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Diagonal.lean", "context": {"open": [], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[DecidableEq n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b9 : DecidableEq n\nx\u271d : Sort u_10\ndiagonal : x\u271d\ninst\u271d : Zero \u03b1\nd : n \u2192 \u03b1\ni j : n\nh : i \u2260 j\n\u22a2 sorry = 0"}, {"line": "simp [diagonal, h]", "tactic_state": "n : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b9 : DecidableEq n\nx\u271d : Sort u_10\ndiagonal : x\u271d\ninst\u271d : Zero \u03b1\nd : n \u2192 \u03b1\ni j : n\nh : i \u2260 j\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem diagonal_zero [Zero \u03b1] : (diagonal fun _ => 0 : Matrix n n \u03b1) = 0 := by\n  ext\n  simp [diagonal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Diagonal.lean", "context": {"open": [], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[DecidableEq n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b9 : DecidableEq n\nx\u271d : Sort u_10\ndiagonal : x\u271d\ninst\u271d : Zero \u03b1\n\u22a2 sorry = 0"}, {"line": "ext", "tactic_state": "case a\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b9 : DecidableEq n\nx\u271d : Sort u_10\ndiagonal : x\u271d\ninst\u271d : Zero \u03b1\ni\u271d j\u271d : n\n\u22a2 sorry i\u271d j\u271d = 0 i\u271d j\u271d"}, {"line": "simp [diagonal]", "tactic_state": "case a\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b9 : DecidableEq n\nx\u271d : Sort u_10\ndiagonal : x\u271d\ninst\u271d : Zero \u03b1\ni\u271d j\u271d : n\n\u22a2 sorry () i\u271d j\u271d = 0"}]}
{"declaration": "theorem dotProduct_comm [AddCommMonoid \u03b1] [CommMagma \u03b1] (v w : m \u2192 \u03b1) : v \u2b1d\u1d65 w = w \u2b1d\u1d65 v := by\n  simp_rw [dotProduct, mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : CommMagma \u03b1\nv w : m \u2192 \u03b1\n\u22a2 v \u2b1d\u1d65 w = w \u2b1d\u1d65 v"}, {"line": "simp_rw [dotProduct, mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dotProduct_pUnit [AddCommMonoid \u03b1] [Mul \u03b1] (v w : PUnit \u2192 \u03b1) : v \u2b1d\u1d65 w = v \u27e8\u27e9 * w \u27e8\u27e9 := by\n  simp [dotProduct]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type v\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\nv w : PUnit.{u_10 + 1} \u2192 \u03b1\n\u22a2 v \u2b1d\u1d65 w = v PUnit.unit * w PUnit.unit"}, {"line": "simp [dotProduct]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dotProduct_one (v : n \u2192 \u03b1) : v \u2b1d\u1d65 1 = \u2211 i, v i := by simp [(\u00b7 \u2b1d\u1d65 \u00b7)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : AddCommMonoid \u03b1\nv : n \u2192 \u03b1\n\u22a2 v \u2b1d\u1d65 1 = \u2211 i, v i"}, {"line": "simp [(\u00b7 \u2b1d\u1d65 \u00b7)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_dotProduct (v : n \u2192 \u03b1) : 1 \u2b1d\u1d65 v = \u2211 i, v i := by simp [(\u00b7 \u2b1d\u1d65 \u00b7)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : AddCommMonoid \u03b1\nv : n \u2192 \u03b1\n\u22a2 1 \u2b1d\u1d65 v = \u2211 i, v i"}, {"line": "simp [(\u00b7 \u2b1d\u1d65 \u00b7)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dotProduct_zero : v \u2b1d\u1d65 0 = 0 := by simp [dotProduct]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nv : m \u2192 \u03b1\n\u22a2 v \u2b1d\u1d65 0 = 0"}, {"line": "simp [dotProduct]", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nv : m \u2192 \u03b1\n\u22a2 Fintype.card m \u2022 0 = 0"}]}
{"declaration": "theorem zero_dotProduct : 0 \u2b1d\u1d65 v = 0 := by simp [dotProduct]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nv : m \u2192 \u03b1\n\u22a2 0 \u2b1d\u1d65 v = 0"}, {"line": "simp [dotProduct]", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nv : m \u2192 \u03b1\n\u22a2 Fintype.card m \u2022 0 = 0"}]}
{"declaration": "theorem add_dotProduct : (u + v) \u2b1d\u1d65 w = u \u2b1d\u1d65 w + v \u2b1d\u1d65 w := by\n  simp [dotProduct, add_mul, Finset.sum_add_distrib]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nu v w : m \u2192 \u03b1\n\u22a2 (u + v) \u2b1d\u1d65 w = u \u2b1d\u1d65 w + v \u2b1d\u1d65 w"}, {"line": "simp [dotProduct, add_mul, Finset.sum_add_distrib]", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nu v w : m \u2192 \u03b1\n\u22a2 \u2211 x, (u x * w x + v x * w x) = \u2211 i, u i * w i + \u2211 i, v i * w i"}]}
{"declaration": "theorem dotProduct_add : u \u2b1d\u1d65 (v + w) = u \u2b1d\u1d65 v + u \u2b1d\u1d65 w := by\n  simp [dotProduct, mul_add, Finset.sum_add_distrib]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nu v w : m \u2192 \u03b1\n\u22a2 u \u2b1d\u1d65 (v + w) = u \u2b1d\u1d65 v + u \u2b1d\u1d65 w"}, {"line": "simp [dotProduct, mul_add, Finset.sum_add_distrib]", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nu v w : m \u2192 \u03b1\n\u22a2 \u2211 x, (u x * v x + u x * w x) = \u2211 i, u i * v i + \u2211 i, u i * w i"}]}
{"declaration": "theorem sumElim_dotProduct_sumElim : Sum.elim u x \u2b1d\u1d65 Sum.elim v y = u \u2b1d\u1d65 v + x \u2b1d\u1d65 y := by\n  simp [dotProduct]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nu v : m \u2192 \u03b1\nx y : n \u2192 \u03b1\n\u22a2 Sum.elim u x \u2b1d\u1d65 Sum.elim v y = u \u2b1d\u1d65 v + x \u2b1d\u1d65 y"}, {"line": "simp [dotProduct]", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nu v : m \u2192 \u03b1\nx y : n \u2192 \u03b1\n\u22a2 \u2211 x, u x * v x + \u2211 x_1, x x_1 * y x_1 = \u2211 x, u x * v x + \u2211 x_1, x x_1 * y x_1"}]}
{"declaration": "theorem dotProduct_comp_equiv_symm (e : n \u2243 m) : u \u2b1d\u1d65 x \u2218 e.symm = u \u2218 e \u2b1d\u1d65 x := by\n  simpa only [Equiv.symm_symm] using (comp_equiv_symm_dotProduct u x e.symm).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nu : m \u2192 \u03b1\nx : n \u2192 \u03b1\ne : n \u2243 m\n\u22a2 u \u2b1d\u1d65 x \u2218 \u21d1e.symm = u \u2218 \u21d1e \u2b1d\u1d65 x"}, {"line": "simpa only [Equiv.symm_symm] using (comp_equiv_symm_dotProduct u x e.symm).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_dotProduct_one : (1 : n \u2192 \u03b1) \u2b1d\u1d65 1 = Fintype.card n := by\n  simp [dotProduct]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : MulOneClass \u03b1\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : NonAssocSemiring \u03b1\n\u22a2 1 \u2b1d\u1d65 1 = \u2191(Fintype.card n)"}, {"line": "simp [dotProduct]", "tactic_state": "n : Type u_3\n\u03b1 : Type v\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : MulOneClass \u03b1\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : NonAssocSemiring \u03b1\n\u22a2 Fintype.card n \u2022 (1 * 1) = \u2191(Fintype.card n)"}]}
{"declaration": "theorem neg_dotProduct : -v \u2b1d\u1d65 w = -(v \u2b1d\u1d65 w) := by simp [dotProduct]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : MulOneClass \u03b1\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : NonUnitalNonAssocRing \u03b1\nv w : m \u2192 \u03b1\n\u22a2 -v \u2b1d\u1d65 w = -(v \u2b1d\u1d65 w)"}, {"line": "simp [dotProduct]", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : MulOneClass \u03b1\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : NonUnitalNonAssocRing \u03b1\nv w : m \u2192 \u03b1\n\u22a2 \u2211 x, -v x * w x = -\u2211 i, v i * w i"}]}
{"declaration": "theorem dotProduct_neg : v \u2b1d\u1d65 -w = -(v \u2b1d\u1d65 w) := by simp [dotProduct]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : MulOneClass \u03b1\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : NonUnitalNonAssocRing \u03b1\nv w : m \u2192 \u03b1\n\u22a2 v \u2b1d\u1d65 -w = -(v \u2b1d\u1d65 w)"}, {"line": "simp [dotProduct]", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : MulOneClass \u03b1\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : NonUnitalNonAssocRing \u03b1\nv w : m \u2192 \u03b1\n\u22a2 \u2211 x, v x * -w x = -\u2211 i, v i * w i"}]}
{"declaration": "theorem sub_dotProduct : (u - v) \u2b1d\u1d65 w = u \u2b1d\u1d65 w - v \u2b1d\u1d65 w := by simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : MulOneClass \u03b1\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : NonUnitalNonAssocRing \u03b1\nu v w : m \u2192 \u03b1\n\u22a2 (u - v) \u2b1d\u1d65 w = u \u2b1d\u1d65 w - v \u2b1d\u1d65 w"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : MulOneClass \u03b1\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : NonUnitalNonAssocRing \u03b1\nu v w : m \u2192 \u03b1\n\u22a2 (u - v) \u2b1d\u1d65 w = u \u2b1d\u1d65 w + -(v \u2b1d\u1d65 w)"}]}
{"declaration": "theorem dotProduct_sub : u \u2b1d\u1d65 (v - w) = u \u2b1d\u1d65 v - u \u2b1d\u1d65 w := by simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : MulOneClass \u03b1\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : NonUnitalNonAssocRing \u03b1\nu v w : m \u2192 \u03b1\n\u22a2 u \u2b1d\u1d65 (v - w) = u \u2b1d\u1d65 v - u \u2b1d\u1d65 w"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "m : Type u_2\n\u03b1 : Type v\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : MulOneClass \u03b1\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : NonUnitalNonAssocRing \u03b1\nu v w : m \u2192 \u03b1\n\u22a2 u \u2b1d\u1d65 (v - w) = u \u2b1d\u1d65 v + -(u \u2b1d\u1d65 w)"}]}
{"declaration": "theorem smul_dotProduct [IsScalarTower R \u03b1 \u03b1] (x : R) (v w : m \u2192 \u03b1) :\n    x \u2022 v \u2b1d\u1d65 w = x \u2022 (v \u2b1d\u1d65 w) := by simp [dotProduct, Finset.smul_sum, smul_mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)", "[Monoid R] [Mul \u03b1] [AddCommMonoid \u03b1] [DistribMulAction R \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nR : Type u_7\n\u03b1 : Type v\ninst\u271d\u00b9\u00b2 : Fintype m\ninst\u271d\u00b9\u00b9 : MulOneClass \u03b1\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2078 : DecidableEq m\ninst\u271d\u2077 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2076 : NonAssocSemiring \u03b1\ninst\u271d\u2075 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2074 : Monoid R\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : DistribMulAction R \u03b1\ninst\u271d : IsScalarTower R \u03b1 \u03b1\nx : R\nv w : m \u2192 \u03b1\n\u22a2 x \u2022 v \u2b1d\u1d65 w = x \u2022 (v \u2b1d\u1d65 w)"}, {"line": "simp [dotProduct, Finset.smul_sum, smul_mul_assoc]", "tactic_state": "m : Type u_2\nR : Type u_7\n\u03b1 : Type v\ninst\u271d\u00b9\u00b2 : Fintype m\ninst\u271d\u00b9\u00b9 : MulOneClass \u03b1\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2078 : DecidableEq m\ninst\u271d\u2077 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2076 : NonAssocSemiring \u03b1\ninst\u271d\u2075 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2074 : Monoid R\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : DistribMulAction R \u03b1\ninst\u271d : IsScalarTower R \u03b1 \u03b1\nx : R\nv w : m \u2192 \u03b1\n\u22a2 \u2211 x_1, x \u2022 v x_1 * w x_1 = x \u2022 \u2211 i, v i * w i"}]}
{"declaration": "theorem dotProduct_smul [SMulCommClass R \u03b1 \u03b1] (x : R) (v w : m \u2192 \u03b1) :\n    v \u2b1d\u1d65 x \u2022 w = x \u2022 (v \u2b1d\u1d65 w) := by simp [dotProduct, Finset.smul_sum, mul_smul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)", "[Monoid R] [Mul \u03b1] [AddCommMonoid \u03b1] [DistribMulAction R \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nR : Type u_7\n\u03b1 : Type v\ninst\u271d\u00b9\u00b2 : Fintype m\ninst\u271d\u00b9\u00b9 : MulOneClass \u03b1\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2078 : DecidableEq m\ninst\u271d\u2077 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2076 : NonAssocSemiring \u03b1\ninst\u271d\u2075 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2074 : Monoid R\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : DistribMulAction R \u03b1\ninst\u271d : SMulCommClass R \u03b1 \u03b1\nx : R\nv w : m \u2192 \u03b1\n\u22a2 v \u2b1d\u1d65 x \u2022 w = x \u2022 (v \u2b1d\u1d65 w)"}, {"line": "simp [dotProduct, Finset.smul_sum, mul_smul_comm]", "tactic_state": "m : Type u_2\nR : Type u_7\n\u03b1 : Type v\ninst\u271d\u00b9\u00b2 : Fintype m\ninst\u271d\u00b9\u00b9 : MulOneClass \u03b1\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2078 : DecidableEq m\ninst\u271d\u2077 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2076 : NonAssocSemiring \u03b1\ninst\u271d\u2075 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2074 : Monoid R\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : DistribMulAction R \u03b1\ninst\u271d : SMulCommClass R \u03b1 \u03b1\nx : R\nv w : m \u2192 \u03b1\n\u22a2 \u2211 x_1, v x_1 * x \u2022 w x_1 = x \u2022 \u2211 i, v i * w i"}]}
{"declaration": "theorem smul_eq_diagonal_mul [Fintype m] [DecidableEq m] (M : Matrix m n \u03b1) (a : \u03b1) :\n    a \u2022 M = (diagonal fun _ => a) * M := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)", "[Monoid R] [Mul \u03b1] [AddCommMonoid \u03b1] [DistribMulAction R \u03b1]", "[AddCommMonoid \u03b1] [Mul \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b9\u2075 : Fintype m\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b9\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2070 : DecidableEq m\ninst\u271d\u2079 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2078 : NonAssocSemiring \u03b1\ninst\u271d\u2077 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : Fintype m\ninst\u271d : DecidableEq m\nM : Matrix m n \u03b1\na : \u03b1\n\u22a2 a \u2022 M = (diagonal fun x => a) * M"}, {"line": "ext", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b9\u2075 : Fintype m\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b9\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2070 : DecidableEq m\ninst\u271d\u2079 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2078 : NonAssocSemiring \u03b1\ninst\u271d\u2077 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : Fintype m\ninst\u271d : DecidableEq m\nM : Matrix m n \u03b1\na : \u03b1\ni\u271d : m\nj\u271d : n\n\u22a2 (a \u2022 M) i\u271d j\u271d = ((diagonal fun x => a) * M) i\u271d j\u271d"}, {"line": "simp", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b9\u2075 : Fintype m\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b9\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2070 : DecidableEq m\ninst\u271d\u2079 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2078 : NonAssocSemiring \u03b1\ninst\u271d\u2077 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : Fintype m\ninst\u271d : DecidableEq m\nM : Matrix m n \u03b1\na : \u03b1\ni\u271d : m\nj\u271d : n\n\u22a2 a * M i\u271d j\u271d = ((diagonal fun x => a) * M) i\u271d j\u271d"}]}
{"declaration": "theorem op_smul_eq_mul_diagonal [Fintype n] [DecidableEq n] (M : Matrix m n \u03b1) (a : \u03b1) :\n    MulOpposite.op a \u2022 M = M * (diagonal fun _ : n => a) := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)", "[Monoid R] [Mul \u03b1] [AddCommMonoid \u03b1] [DistribMulAction R \u03b1]", "[AddCommMonoid \u03b1] [Mul \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b9\u2075 : Fintype m\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b9\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2070 : DecidableEq m\ninst\u271d\u2079 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2078 : NonAssocSemiring \u03b1\ninst\u271d\u2077 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nM : Matrix m n \u03b1\na : \u03b1\n\u22a2 MulOpposite.op a \u2022 M = M * diagonal fun x => a"}, {"line": "ext", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b9\u2075 : Fintype m\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b9\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2070 : DecidableEq m\ninst\u271d\u2079 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2078 : NonAssocSemiring \u03b1\ninst\u271d\u2077 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nM : Matrix m n \u03b1\na : \u03b1\ni\u271d : m\nj\u271d : n\n\u22a2 (MulOpposite.op a \u2022 M) i\u271d j\u271d = (M * diagonal fun x => a) i\u271d j\u271d"}, {"line": "simp", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b9\u2075 : Fintype m\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b9\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2070 : DecidableEq m\ninst\u271d\u2079 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2078 : NonAssocSemiring \u03b1\ninst\u271d\u2077 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nM : Matrix m n \u03b1\na : \u03b1\ni\u271d : m\nj\u271d : n\n\u22a2 M i\u271d j\u271d * a = (M * diagonal fun x => a) i\u271d j\u271d"}]}
{"declaration": "theorem smul_eq_mul_diagonal [Fintype n] [DecidableEq n] (M : Matrix m n \u03b1) (a : \u03b1) :\n    a \u2022 M = M * diagonal fun _ => a := by\n  ext\n  simp [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)", "[Monoid R] [Mul \u03b1] [AddCommMonoid \u03b1] [DistribMulAction R \u03b1]", "[AddCommMonoid \u03b1] [Mul \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonAssocSemiring \u03b1]", "(\u03b1 n)", "[NonUnitalSemiring \u03b1] [Fintype m] [Fintype n]", "[Semiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] [Fintype n]", "[Semiring \u03b1]", "[CommSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b2\u2074 : Fintype m\ninst\u271d\u00b2\u00b3 : Fintype n\ninst\u271d\u00b2\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b2\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2070 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2079 : DecidableEq m\ninst\u271d\u00b9\u2078 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2077 : NonAssocSemiring \u03b1\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b2 : Mul \u03b1\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2070 : NonAssocSemiring \u03b1\ninst\u271d\u2079 : NonUnitalSemiring \u03b1\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : Semiring \u03b1\ninst\u271d\u2075 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : Semiring \u03b1\ninst\u271d\u00b2 : CommSemiring \u03b1\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nM : Matrix m n \u03b1\na : \u03b1\n\u22a2 a \u2022 M = M * diagonal fun x => a"}, {"line": "ext", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b2\u2074 : Fintype m\ninst\u271d\u00b2\u00b3 : Fintype n\ninst\u271d\u00b2\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b2\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2070 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2079 : DecidableEq m\ninst\u271d\u00b9\u2078 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2077 : NonAssocSemiring \u03b1\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b2 : Mul \u03b1\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2070 : NonAssocSemiring \u03b1\ninst\u271d\u2079 : NonUnitalSemiring \u03b1\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : Semiring \u03b1\ninst\u271d\u2075 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : Semiring \u03b1\ninst\u271d\u00b2 : CommSemiring \u03b1\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nM : Matrix m n \u03b1\na : \u03b1\ni\u271d : m\nj\u271d : n\n\u22a2 (a \u2022 M) i\u271d j\u271d = (M * diagonal fun x => a) i\u271d j\u271d"}, {"line": "simp [mul_comm]", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b2\u2074 : Fintype m\ninst\u271d\u00b2\u00b3 : Fintype n\ninst\u271d\u00b2\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b2\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2070 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2079 : DecidableEq m\ninst\u271d\u00b9\u2078 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2077 : NonAssocSemiring \u03b1\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b2 : Mul \u03b1\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2070 : NonAssocSemiring \u03b1\ninst\u271d\u2079 : NonUnitalSemiring \u03b1\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : Semiring \u03b1\ninst\u271d\u2075 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : Semiring \u03b1\ninst\u271d\u00b2 : CommSemiring \u03b1\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nM : Matrix m n \u03b1\na : \u03b1\ni\u271d : m\nj\u271d : n\n\u22a2 a * M i\u271d j\u271d = (M * diagonal fun x => a) i\u271d j\u271d"}]}
{"declaration": "theorem mulVec_zero [Fintype n] (A : Matrix m n \u03b1) : A *\u1d65 0 = 0 := by\n  ext\n  simp [mulVec]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix", "Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)", "[Monoid R] [Mul \u03b1] [AddCommMonoid \u03b1] [DistribMulAction R \u03b1]", "[AddCommMonoid \u03b1] [Mul \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonAssocSemiring \u03b1]", "(\u03b1 n)", "[NonUnitalSemiring \u03b1] [Fintype m] [Fintype n]", "[Semiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] [Fintype n]", "[Semiring \u03b1]", "[CommSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b2\u2074 : Fintype m\ninst\u271d\u00b2\u00b3 : Fintype n\ninst\u271d\u00b2\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b2\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2070 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2079 : DecidableEq m\ninst\u271d\u00b9\u2078 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2077 : NonAssocSemiring \u03b1\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b2 : Mul \u03b1\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2070 : NonAssocSemiring \u03b1\ninst\u271d\u2079 : NonUnitalSemiring \u03b1\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : Semiring \u03b1\ninst\u271d\u2075 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : Semiring \u03b1\ninst\u271d\u00b2 : CommSemiring \u03b1\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype n\nA : Matrix m n \u03b1\n\u22a2 A.mulVec 0 = 0"}, {"line": "ext", "tactic_state": "case h\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b2\u2074 : Fintype m\ninst\u271d\u00b2\u00b3 : Fintype n\ninst\u271d\u00b2\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b2\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2070 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2079 : DecidableEq m\ninst\u271d\u00b9\u2078 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2077 : NonAssocSemiring \u03b1\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b2 : Mul \u03b1\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2070 : NonAssocSemiring \u03b1\ninst\u271d\u2079 : NonUnitalSemiring \u03b1\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : Semiring \u03b1\ninst\u271d\u2075 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : Semiring \u03b1\ninst\u271d\u00b2 : CommSemiring \u03b1\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype n\nA : Matrix m n \u03b1\nx\u271d : m\n\u22a2 A.mulVec 0 x\u271d = 0 x\u271d"}, {"line": "simp [mulVec]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_vecMul [Fintype m] (A : Matrix m n \u03b1) : 0 \u1d65* A = 0 := by\n  ext\n  simp [vecMul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix", "Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)", "[Monoid R] [Mul \u03b1] [AddCommMonoid \u03b1] [DistribMulAction R \u03b1]", "[AddCommMonoid \u03b1] [Mul \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonAssocSemiring \u03b1]", "(\u03b1 n)", "[NonUnitalSemiring \u03b1] [Fintype m] [Fintype n]", "[Semiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] [Fintype n]", "[Semiring \u03b1]", "[CommSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b2\u2074 : Fintype m\ninst\u271d\u00b2\u00b3 : Fintype n\ninst\u271d\u00b2\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b2\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2070 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2079 : DecidableEq m\ninst\u271d\u00b9\u2078 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2077 : NonAssocSemiring \u03b1\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b2 : Mul \u03b1\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2070 : NonAssocSemiring \u03b1\ninst\u271d\u2079 : NonUnitalSemiring \u03b1\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : Semiring \u03b1\ninst\u271d\u2075 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : Semiring \u03b1\ninst\u271d\u00b2 : CommSemiring \u03b1\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype m\nA : Matrix m n \u03b1\n\u22a2 vecMul 0 A = 0"}, {"line": "ext", "tactic_state": "case h\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b2\u2074 : Fintype m\ninst\u271d\u00b2\u00b3 : Fintype n\ninst\u271d\u00b2\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b2\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2070 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2079 : DecidableEq m\ninst\u271d\u00b9\u2078 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2077 : NonAssocSemiring \u03b1\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b2 : Mul \u03b1\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2070 : NonAssocSemiring \u03b1\ninst\u271d\u2079 : NonUnitalSemiring \u03b1\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : Semiring \u03b1\ninst\u271d\u2075 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : Semiring \u03b1\ninst\u271d\u00b2 : CommSemiring \u03b1\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype m\nA : Matrix m n \u03b1\nx\u271d : n\n\u22a2 vecMul 0 A x\u271d = 0 x\u271d"}, {"line": "simp [vecMul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_mulVec [Fintype n] (v : n \u2192 \u03b1) : (0 : Matrix m n \u03b1) *\u1d65 v = 0 := by\n  ext\n  simp [mulVec]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix", "Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)", "[Monoid R] [Mul \u03b1] [AddCommMonoid \u03b1] [DistribMulAction R \u03b1]", "[AddCommMonoid \u03b1] [Mul \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonAssocSemiring \u03b1]", "(\u03b1 n)", "[NonUnitalSemiring \u03b1] [Fintype m] [Fintype n]", "[Semiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] [Fintype n]", "[Semiring \u03b1]", "[CommSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b2\u2074 : Fintype m\ninst\u271d\u00b2\u00b3 : Fintype n\ninst\u271d\u00b2\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b2\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2070 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2079 : DecidableEq m\ninst\u271d\u00b9\u2078 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2077 : NonAssocSemiring \u03b1\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b2 : Mul \u03b1\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2070 : NonAssocSemiring \u03b1\ninst\u271d\u2079 : NonUnitalSemiring \u03b1\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : Semiring \u03b1\ninst\u271d\u2075 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : Semiring \u03b1\ninst\u271d\u00b2 : CommSemiring \u03b1\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype n\nv : n \u2192 \u03b1\n\u22a2 mulVec 0 v = 0"}, {"line": "ext", "tactic_state": "case h\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b2\u2074 : Fintype m\ninst\u271d\u00b2\u00b3 : Fintype n\ninst\u271d\u00b2\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b2\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2070 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2079 : DecidableEq m\ninst\u271d\u00b9\u2078 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2077 : NonAssocSemiring \u03b1\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b2 : Mul \u03b1\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2070 : NonAssocSemiring \u03b1\ninst\u271d\u2079 : NonUnitalSemiring \u03b1\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : Semiring \u03b1\ninst\u271d\u2075 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : Semiring \u03b1\ninst\u271d\u00b2 : CommSemiring \u03b1\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype n\nv : n \u2192 \u03b1\nx\u271d : m\n\u22a2 mulVec 0 v x\u271d = 0 x\u271d"}, {"line": "simp [mulVec]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vecMul_zero [Fintype m] (v : m \u2192 \u03b1) : v \u1d65* (0 : Matrix m n \u03b1) = 0 := by\n  ext\n  simp [vecMul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix", "Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)", "[Monoid R] [Mul \u03b1] [AddCommMonoid \u03b1] [DistribMulAction R \u03b1]", "[AddCommMonoid \u03b1] [Mul \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonAssocSemiring \u03b1]", "(\u03b1 n)", "[NonUnitalSemiring \u03b1] [Fintype m] [Fintype n]", "[Semiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] [Fintype n]", "[Semiring \u03b1]", "[CommSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b2\u2074 : Fintype m\ninst\u271d\u00b2\u00b3 : Fintype n\ninst\u271d\u00b2\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b2\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2070 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2079 : DecidableEq m\ninst\u271d\u00b9\u2078 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2077 : NonAssocSemiring \u03b1\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b2 : Mul \u03b1\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2070 : NonAssocSemiring \u03b1\ninst\u271d\u2079 : NonUnitalSemiring \u03b1\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : Semiring \u03b1\ninst\u271d\u2075 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : Semiring \u03b1\ninst\u271d\u00b2 : CommSemiring \u03b1\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype m\nv : m \u2192 \u03b1\n\u22a2 vecMul v 0 = 0"}, {"line": "ext", "tactic_state": "case h\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b2\u2074 : Fintype m\ninst\u271d\u00b2\u00b3 : Fintype n\ninst\u271d\u00b2\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b2\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2070 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2079 : DecidableEq m\ninst\u271d\u00b9\u2078 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2077 : NonAssocSemiring \u03b1\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b2 : Mul \u03b1\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2070 : NonAssocSemiring \u03b1\ninst\u271d\u2079 : NonUnitalSemiring \u03b1\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : Semiring \u03b1\ninst\u271d\u2075 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : Semiring \u03b1\ninst\u271d\u00b2 : CommSemiring \u03b1\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype m\nv : m \u2192 \u03b1\nx\u271d : n\n\u22a2 vecMul v 0 x\u271d = 0 x\u271d"}, {"line": "simp [vecMul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem diagonal_mulVec_single [Fintype n] [DecidableEq n] [NonUnitalNonAssocSemiring R] (v : n \u2192 R)\n    (j : n) (x : R) : diagonal v *\u1d65 Pi.single j x = Pi.single j (v j * x) := by\n  ext i\n  rw [mulVec_diagonal]\n  exact Pi.apply_single (fun i x => v i * x) (fun i => mul_zero _) j x i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix", "Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)", "[Monoid R] [Mul \u03b1] [AddCommMonoid \u03b1] [DistribMulAction R \u03b1]", "[AddCommMonoid \u03b1] [Mul \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonAssocSemiring \u03b1]", "(\u03b1 n)", "[NonUnitalSemiring \u03b1] [Fintype m] [Fintype n]", "[Semiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] [Fintype n]", "[Semiring \u03b1]", "[CommSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\nR : Type u_7\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Monoid R\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : NonUnitalNonAssocSemiring R\nv : n \u2192 R\nj : n\nx : R\n\u22a2 (diagonal v).mulVec (Pi.single j x) = Pi.single j (v j * x)"}, {"line": "ext i", "tactic_state": "case h\nn : Type u_3\nR : Type u_7\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Monoid R\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : NonUnitalNonAssocSemiring R\nv : n \u2192 R\nj : n\nx : R\ni : n\n\u22a2 (diagonal v).mulVec (Pi.single j x) i = Pi.single j (v j * x) i"}, {"line": "rw [mulVec_diagonal]", "tactic_state": "case h\nn : Type u_3\nR : Type u_7\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Monoid R\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : NonUnitalNonAssocSemiring R\nv : n \u2192 R\nj : n\nx : R\ni : n\n\u22a2 v i * Pi.single j x i = Pi.single j (v j * x) i"}, {"line": "exact Pi.apply_single (fun i x => v i * x) (fun i => mul_zero _) j x i", "tactic_state": "No Goals!"}]}
{"declaration": "theorem single_vecMul_diagonal [Fintype n] [DecidableEq n] [NonUnitalNonAssocSemiring R] (v : n \u2192 R)\n    (j : n) (x : R) : (Pi.single j x) \u1d65* (diagonal v) = Pi.single j (x * v j) := by\n  ext i\n  rw [vecMul_diagonal]\n  exact Pi.apply_single (fun i x => x * v i) (fun i => zero_mul _) j x i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix", "Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)", "[Monoid R] [Mul \u03b1] [AddCommMonoid \u03b1] [DistribMulAction R \u03b1]", "[AddCommMonoid \u03b1] [Mul \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonAssocSemiring \u03b1]", "(\u03b1 n)", "[NonUnitalSemiring \u03b1] [Fintype m] [Fintype n]", "[Semiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] [Fintype n]", "[Semiring \u03b1]", "[CommSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\nR : Type u_7\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Monoid R\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : NonUnitalNonAssocSemiring R\nv : n \u2192 R\nj : n\nx : R\n\u22a2 vecMul (Pi.single j x) (diagonal v) = Pi.single j (x * v j)"}, {"line": "ext i", "tactic_state": "case h\nn : Type u_3\nR : Type u_7\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Monoid R\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : NonUnitalNonAssocSemiring R\nv : n \u2192 R\nj : n\nx : R\ni : n\n\u22a2 vecMul (Pi.single j x) (diagonal v) i = Pi.single j (x * v j) i"}, {"line": "rw [vecMul_diagonal]", "tactic_state": "case h\nn : Type u_3\nR : Type u_7\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Monoid R\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : NonUnitalNonAssocSemiring R\nv : n \u2192 R\nj : n\nx : R\ni : n\n\u22a2 Pi.single j x i * v i = Pi.single j (x * v j) i"}, {"line": "exact Pi.apply_single (fun i x => x * v i) (fun i => zero_mul _) j x i", "tactic_state": "No Goals!"}]}
{"declaration": "theorem submatrix_mul_transpose_submatrix [Fintype m] [Fintype n] [AddCommMonoid \u03b1] [Mul \u03b1]\n    (e : m \u2243 n) (M : Matrix m n \u03b1) : M.submatrix id e * M\u1d40.submatrix e id = M * M\u1d40 := by\n  rw [submatrix_mul_equiv]\n  rw [submatrix_id_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix", "Matrix", "Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)", "[Monoid R] [Mul \u03b1] [AddCommMonoid \u03b1] [DistribMulAction R \u03b1]", "[AddCommMonoid \u03b1] [Mul \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonAssocSemiring \u03b1]", "(\u03b1 n)", "[NonUnitalSemiring \u03b1] [Fintype m] [Fintype n]", "[Semiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] [Fintype n]", "[Semiring \u03b1]", "[CommSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalSemiring \u03b1]", "[NonAssocSemiring \u03b1]", "[Fintype m] [Fintype n] [DecidableEq m]", "[NonUnitalNonAssocRing \u03b1]", "[NonUnitalCommSemiring \u03b1]", "[Semiring R]", "[CommSemiring \u03b1]", "[NonAssocRing \u03b1]", "[Fintype m] [DecidableEq m]", "(m n \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b3\u2078 : Fintype m\ninst\u271d\u00b3\u2077 : Fintype n\ninst\u271d\u00b3\u2076 : MulOneClass \u03b1\ninst\u271d\u00b3\u2075 : AddCommMonoid \u03b1\ninst\u271d\u00b3\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3\u00b3 : DecidableEq m\ninst\u271d\u00b3\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3\u00b9 : NonAssocSemiring \u03b1\ninst\u271d\u00b3\u2070 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b2\u2079 : Mul \u03b1\ninst\u271d\u00b2\u2078 inst\u271d\u00b2\u2077 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2076 : Mul \u03b1\ninst\u271d\u00b2\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2\u2074 : NonAssocSemiring \u03b1\ninst\u271d\u00b2\u00b3 : NonUnitalSemiring \u03b1\ninst\u271d\u00b2\u00b2 : Fintype m\ninst\u271d\u00b2\u00b9 : Fintype n\ninst\u271d\u00b2\u2070 : Semiring \u03b1\ninst\u271d\u00b9\u2079 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b9\u2078 : Fintype n\ninst\u271d\u00b9\u2077 : Semiring \u03b1\ninst\u271d\u00b9\u2076 : CommSemiring \u03b1\ninst\u271d\u00b9\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2074 : NonUnitalSemiring \u03b1\ninst\u271d\u00b9\u00b3 : NonAssocSemiring \u03b1\ninst\u271d\u00b9\u00b2 : Fintype m\ninst\u271d\u00b9\u00b9 : Fintype n\ninst\u271d\u00b9\u2070 : DecidableEq m\ninst\u271d\u2079 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2078 : NonUnitalCommSemiring \u03b1\ninst\u271d\u2077 : CommSemiring \u03b1\ninst\u271d\u2076 : NonAssocRing \u03b1\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\ne : m \u2243 n\nM : Matrix m n \u03b1\n\u22a2 M.submatrix id \u21d1e * M.transpose.submatrix (\u21d1e) id = M * M.transpose"}, {"line": "rw [submatrix_mul_equiv]", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b3\u2078 : Fintype m\ninst\u271d\u00b3\u2077 : Fintype n\ninst\u271d\u00b3\u2076 : MulOneClass \u03b1\ninst\u271d\u00b3\u2075 : AddCommMonoid \u03b1\ninst\u271d\u00b3\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3\u00b3 : DecidableEq m\ninst\u271d\u00b3\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3\u00b9 : NonAssocSemiring \u03b1\ninst\u271d\u00b3\u2070 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b2\u2079 : Mul \u03b1\ninst\u271d\u00b2\u2078 inst\u271d\u00b2\u2077 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2076 : Mul \u03b1\ninst\u271d\u00b2\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2\u2074 : NonAssocSemiring \u03b1\ninst\u271d\u00b2\u00b3 : NonUnitalSemiring \u03b1\ninst\u271d\u00b2\u00b2 : Fintype m\ninst\u271d\u00b2\u00b9 : Fintype n\ninst\u271d\u00b2\u2070 : Semiring \u03b1\ninst\u271d\u00b9\u2079 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b9\u2078 : Fintype n\ninst\u271d\u00b9\u2077 : Semiring \u03b1\ninst\u271d\u00b9\u2076 : CommSemiring \u03b1\ninst\u271d\u00b9\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2074 : NonUnitalSemiring \u03b1\ninst\u271d\u00b9\u00b3 : NonAssocSemiring \u03b1\ninst\u271d\u00b9\u00b2 : Fintype m\ninst\u271d\u00b9\u00b9 : Fintype n\ninst\u271d\u00b9\u2070 : DecidableEq m\ninst\u271d\u2079 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2078 : NonUnitalCommSemiring \u03b1\ninst\u271d\u2077 : CommSemiring \u03b1\ninst\u271d\u2076 : NonAssocRing \u03b1\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\ne : m \u2243 n\nM : Matrix m n \u03b1\n\u22a2 (M * M.transpose).submatrix id id = M * M.transpose\n---\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\ninst\u271d\u00b3\u2078 : Fintype m\ninst\u271d\u00b3\u2077 : Fintype n\ninst\u271d\u00b3\u2076 : MulOneClass \u03b1\ninst\u271d\u00b3\u2075 : AddCommMonoid \u03b1\ninst\u271d\u00b3\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3\u00b3 : DecidableEq m\ninst\u271d\u00b3\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3\u00b9 : NonAssocSemiring \u03b1\ninst\u271d\u00b3\u2070 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b2\u2079 : Mul \u03b1\ninst\u271d\u00b2\u2078 inst\u271d\u00b2\u2077 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2076 : Mul \u03b1\ninst\u271d\u00b2\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2\u2074 : NonAssocSemiring \u03b1\ninst\u271d\u00b2\u00b3 : NonUnitalSemiring \u03b1\ninst\u271d\u00b2\u00b2 : Fintype m\ninst\u271d\u00b2\u00b9 : Fintype n\ninst\u271d\u00b2\u2070 : Semiring \u03b1\ninst\u271d\u00b9\u2079 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b9\u2078 : Fintype n\ninst\u271d\u00b9\u2077 : Semiring \u03b1\ninst\u271d\u00b9\u2076 : CommSemiring \u03b1\ninst\u271d\u00b9\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2074 : NonUnitalSemiring \u03b1\ninst\u271d\u00b9\u00b3 : NonAssocSemiring \u03b1\ninst\u271d\u00b9\u00b2 : Fintype m\ninst\u271d\u00b9\u00b9 : Fintype n\ninst\u271d\u00b9\u2070 : DecidableEq m\ninst\u271d\u2079 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2078 : NonUnitalCommSemiring \u03b1\ninst\u271d\u2077 : CommSemiring \u03b1\ninst\u271d\u2076 : NonAssocRing \u03b1\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\ne : m \u2243 n\nM : Matrix m n \u03b1\n\u22a2 Fintype n"}, {"line": "rw [submatrix_id_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_matrix_mul (M : Matrix m n \u03b1) (N : Matrix n o \u03b1) (i : m) (j : o) (f : \u03b1 \u2192+* \u03b2) :\n    f ((M * N) i j) = (M.map f * N.map f) i j := by\n  simp [Matrix.mul_apply, map_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix", "Matrix", "Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)", "[Monoid R] [Mul \u03b1] [AddCommMonoid \u03b1] [DistribMulAction R \u03b1]", "[AddCommMonoid \u03b1] [Mul \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonAssocSemiring \u03b1]", "(\u03b1 n)", "[NonUnitalSemiring \u03b1] [Fintype m] [Fintype n]", "[Semiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] [Fintype n]", "[Semiring \u03b1]", "[CommSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalSemiring \u03b1]", "[NonAssocSemiring \u03b1]", "[Fintype m] [Fintype n] [DecidableEq m]", "[NonUnitalNonAssocRing \u03b1]", "[NonUnitalCommSemiring \u03b1]", "[Semiring R]", "[CommSemiring \u03b1]", "[NonAssocRing \u03b1]", "[Fintype m] [DecidableEq m]", "(m n \u03b1)", "[Fintype n] [NonAssocSemiring \u03b1] [NonAssocSemiring \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type v\n\u03b2 : Type w\ninst\u271d\u00b3\u2077 : Fintype m\ninst\u271d\u00b3\u2076 : Fintype n\ninst\u271d\u00b3\u2075 : MulOneClass \u03b1\ninst\u271d\u00b3\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3\u00b2 : DecidableEq m\ninst\u271d\u00b3\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3\u2070 : NonAssocSemiring \u03b1\ninst\u271d\u00b2\u2079 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b2\u2078 : Mul \u03b1\ninst\u271d\u00b2\u2077 inst\u271d\u00b2\u2076 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2075 : Mul \u03b1\ninst\u271d\u00b2\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2\u00b3 : NonAssocSemiring \u03b1\ninst\u271d\u00b2\u00b2 : NonUnitalSemiring \u03b1\ninst\u271d\u00b2\u00b9 : Fintype m\ninst\u271d\u00b2\u2070 : Fintype n\ninst\u271d\u00b9\u2079 : Semiring \u03b1\ninst\u271d\u00b9\u2078 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b9\u2077 : Fintype n\ninst\u271d\u00b9\u2076 : Semiring \u03b1\ninst\u271d\u00b9\u2075 : CommSemiring \u03b1\ninst\u271d\u00b9\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u00b3 : NonUnitalSemiring \u03b1\ninst\u271d\u00b9\u00b2 : NonAssocSemiring \u03b1\ninst\u271d\u00b9\u00b9 : Fintype m\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq m\ninst\u271d\u2078 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2077 : NonUnitalCommSemiring \u03b1\ninst\u271d\u2076 : CommSemiring \u03b1\ninst\u271d\u2075 : NonAssocRing \u03b1\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : NonAssocSemiring \u03b2\nM : Matrix m n \u03b1\nN : Matrix n o \u03b1\ni : m\nj : o\nf : \u03b1 \u2192+* \u03b2\n\u22a2 f ((M * N) i j) = (M.map \u21d1f * N.map \u21d1f) i j"}, {"line": "simp [Matrix.mul_apply, map_sum]", "tactic_state": "m : Type u_2\nn : Type u_3\no : Type u_4\n\u03b1 : Type v\n\u03b2 : Type w\ninst\u271d\u00b3\u2077 : Fintype m\ninst\u271d\u00b3\u2076 : Fintype n\ninst\u271d\u00b3\u2075 : MulOneClass \u03b1\ninst\u271d\u00b3\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3\u00b2 : DecidableEq m\ninst\u271d\u00b3\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3\u2070 : NonAssocSemiring \u03b1\ninst\u271d\u00b2\u2079 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b2\u2078 : Mul \u03b1\ninst\u271d\u00b2\u2077 inst\u271d\u00b2\u2076 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2075 : Mul \u03b1\ninst\u271d\u00b2\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2\u00b3 : NonAssocSemiring \u03b1\ninst\u271d\u00b2\u00b2 : NonUnitalSemiring \u03b1\ninst\u271d\u00b2\u00b9 : Fintype m\ninst\u271d\u00b2\u2070 : Fintype n\ninst\u271d\u00b9\u2079 : Semiring \u03b1\ninst\u271d\u00b9\u2078 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u00b9\u2077 : Fintype n\ninst\u271d\u00b9\u2076 : Semiring \u03b1\ninst\u271d\u00b9\u2075 : CommSemiring \u03b1\ninst\u271d\u00b9\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u00b3 : NonUnitalSemiring \u03b1\ninst\u271d\u00b9\u00b2 : NonAssocSemiring \u03b1\ninst\u271d\u00b9\u00b9 : Fintype m\ninst\u271d\u00b9\u2070 : Fintype n\ninst\u271d\u2079 : DecidableEq m\ninst\u271d\u2078 : NonUnitalNonAssocRing \u03b1\ninst\u271d\u2077 : NonUnitalCommSemiring \u03b1\ninst\u271d\u2076 : CommSemiring \u03b1\ninst\u271d\u2075 : NonAssocRing \u03b1\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : NonAssocSemiring \u03b2\nM : Matrix m n \u03b1\nN : Matrix n o \u03b1\ni : m\nj : o\nf : \u03b1 \u2192+* \u03b2\n\u22a2 f (\u2211 j_1, M i j_1 * N j_1 j) = \u2211 x, f (M i x) * f (N x j)"}]}
{"declaration": "theorem map_dotProduct [NonAssocSemiring R] [NonAssocSemiring S] (f : R \u2192+* S) (v w : n \u2192 R) :\n    f (v \u2b1d\u1d65 w) = f \u2218 v \u2b1d\u1d65 f \u2218 w := by\n  simp only [dotProduct]\n  simp only [map_sum f]\n  simp only [f.map_mul]\n  simp only [Function.comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix", "Matrix", "Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)", "[Monoid R] [Mul \u03b1] [AddCommMonoid \u03b1] [DistribMulAction R \u03b1]", "[AddCommMonoid \u03b1] [Mul \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonAssocSemiring \u03b1]", "(\u03b1 n)", "[NonUnitalSemiring \u03b1] [Fintype m] [Fintype n]", "[Semiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] [Fintype n]", "[Semiring \u03b1]", "[CommSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalSemiring \u03b1]", "[NonAssocSemiring \u03b1]", "[Fintype m] [Fintype n] [DecidableEq m]", "[NonUnitalNonAssocRing \u03b1]", "[NonUnitalCommSemiring \u03b1]", "[Semiring R]", "[CommSemiring \u03b1]", "[NonAssocRing \u03b1]", "[Fintype m] [DecidableEq m]", "(m n \u03b1)", "[Fintype n] [NonAssocSemiring \u03b1] [NonAssocSemiring \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\nR : Type u_7\nS : Type u_8\ninst\u271d\u2078 : Fintype n\ninst\u271d\u2077 : Monoid R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : NonAssocSemiring S\nf : R \u2192+* S\nv w : n \u2192 R\n\u22a2 f (v \u2b1d\u1d65 w) = \u21d1f \u2218 v \u2b1d\u1d65 \u21d1f \u2218 w"}, {"line": "simp only [dotProduct]", "tactic_state": "n : Type u_3\nR : Type u_7\nS : Type u_8\ninst\u271d\u2078 : Fintype n\ninst\u271d\u2077 : Monoid R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : NonAssocSemiring S\nf : R \u2192+* S\nv w : n \u2192 R\n\u22a2 f (\u2211 i, v i * w i) = \u2211 i, (\u21d1f \u2218 v) i * (\u21d1f \u2218 w) i"}, {"line": "simp only [map_sum f]", "tactic_state": "n : Type u_3\nR : Type u_7\nS : Type u_8\ninst\u271d\u2078 : Fintype n\ninst\u271d\u2077 : Monoid R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : NonAssocSemiring S\nf : R \u2192+* S\nv w : n \u2192 R\n\u22a2 \u2211 x, f (v x * w x) = \u2211 i, (\u21d1f \u2218 v) i * (\u21d1f \u2218 w) i"}, {"line": "simp only [f.map_mul]", "tactic_state": "n : Type u_3\nR : Type u_7\nS : Type u_8\ninst\u271d\u2078 : Fintype n\ninst\u271d\u2077 : Monoid R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : NonAssocSemiring S\nf : R \u2192+* S\nv w : n \u2192 R\n\u22a2 \u2211 x, f (v x) * f (w x) = \u2211 i, (\u21d1f \u2218 v) i * (\u21d1f \u2218 w) i"}, {"line": "simp only [Function.comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_vecMul [NonAssocSemiring R] [NonAssocSemiring S] (f : R \u2192+* S) (M : Matrix n m R)\n    (v : n \u2192 R) (i : m) : f ((v \u1d65* M) i) =  ((f \u2218 v) \u1d65* M.map f) i := by\n  simp only [Matrix.vecMul]\n  simp only [Matrix.map_apply]\n  simp only [RingHom.map_dotProduct]\n  simp only [Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix", "Matrix", "Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)", "[Monoid R] [Mul \u03b1] [AddCommMonoid \u03b1] [DistribMulAction R \u03b1]", "[AddCommMonoid \u03b1] [Mul \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonAssocSemiring \u03b1]", "(\u03b1 n)", "[NonUnitalSemiring \u03b1] [Fintype m] [Fintype n]", "[Semiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] [Fintype n]", "[Semiring \u03b1]", "[CommSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalSemiring \u03b1]", "[NonAssocSemiring \u03b1]", "[Fintype m] [Fintype n] [DecidableEq m]", "[NonUnitalNonAssocRing \u03b1]", "[NonUnitalCommSemiring \u03b1]", "[Semiring R]", "[CommSemiring \u03b1]", "[NonAssocRing \u03b1]", "[Fintype m] [DecidableEq m]", "(m n \u03b1)", "[Fintype n] [NonAssocSemiring \u03b1] [NonAssocSemiring \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\nR : Type u_7\nS : Type u_8\ninst\u271d\u00b9\u2075 : Fintype m\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : DecidableEq m\ninst\u271d\u00b9\u00b2 : Monoid R\ninst\u271d\u00b9\u00b9 : Fintype m\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : Fintype n\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq m\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : NonAssocSemiring S\nf : R \u2192+* S\nM : Matrix n m R\nv : n \u2192 R\ni : m\n\u22a2 f (vecMul v M i) = vecMul (\u21d1f \u2218 v) (M.map \u21d1f) i"}, {"line": "simp only [Matrix.vecMul]", "tactic_state": "m : Type u_2\nn : Type u_3\nR : Type u_7\nS : Type u_8\ninst\u271d\u00b9\u2075 : Fintype m\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : DecidableEq m\ninst\u271d\u00b9\u00b2 : Monoid R\ninst\u271d\u00b9\u00b9 : Fintype m\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : Fintype n\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq m\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : NonAssocSemiring S\nf : R \u2192+* S\nM : Matrix n m R\nv : n \u2192 R\ni : m\n\u22a2 f (v \u2b1d\u1d65 fun i_1 => M i_1 i) = \u21d1f \u2218 v \u2b1d\u1d65 fun i_1 => M.map (\u21d1f) i_1 i"}, {"line": "simp only [Matrix.map_apply]", "tactic_state": "m : Type u_2\nn : Type u_3\nR : Type u_7\nS : Type u_8\ninst\u271d\u00b9\u2075 : Fintype m\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : DecidableEq m\ninst\u271d\u00b9\u00b2 : Monoid R\ninst\u271d\u00b9\u00b9 : Fintype m\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : Fintype n\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq m\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : NonAssocSemiring S\nf : R \u2192+* S\nM : Matrix n m R\nv : n \u2192 R\ni : m\n\u22a2 f (v \u2b1d\u1d65 fun i_1 => M i_1 i) = \u21d1f \u2218 v \u2b1d\u1d65 fun i_1 => f (M i_1 i)"}, {"line": "simp only [RingHom.map_dotProduct]", "tactic_state": "m : Type u_2\nn : Type u_3\nR : Type u_7\nS : Type u_8\ninst\u271d\u00b9\u2075 : Fintype m\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : DecidableEq m\ninst\u271d\u00b9\u00b2 : Monoid R\ninst\u271d\u00b9\u00b9 : Fintype m\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : Fintype n\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq m\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : NonAssocSemiring S\nf : R \u2192+* S\nM : Matrix n m R\nv : n \u2192 R\ni : m\n\u22a2 (\u21d1f \u2218 v \u2b1d\u1d65 \u21d1f \u2218 fun i_1 => M i_1 i) = \u21d1f \u2218 v \u2b1d\u1d65 fun i_1 => f (M i_1 i)"}, {"line": "simp only [Function.comp_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_mulVec [NonAssocSemiring R] [NonAssocSemiring S] (f : R \u2192+* S) (M : Matrix m n R)\n    (v : n \u2192 R) (i : m) : f ((M *\u1d65 v) i) = (M.map f *\u1d65 (f \u2218 v)) i := by\n  simp only [Matrix.mulVec]\n  simp only [Matrix.map_apply]\n  simp only [RingHom.map_dotProduct]\n  simp only [Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Mul.lean", "context": {"open": ["Matrix", "Matrix", "Matrix", "Matrix"], "variables": ["{l m n o : Type*} {m' : o \u2192 Type*} {n' : o \u2192 Type*}", "{R : Type*} {S : Type*} {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type*}", "[Fintype m] [Fintype n]", "[MulOneClass \u03b1] [AddCommMonoid \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1) (x y : n \u2192 \u03b1)", "[DecidableEq m] [NonUnitalNonAssocSemiring \u03b1] (u v w : m \u2192 \u03b1)", "[NonAssocSemiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] (u v w : m \u2192 \u03b1)", "[Monoid R] [Mul \u03b1] [AddCommMonoid \u03b1] [DistribMulAction R \u03b1]", "[AddCommMonoid \u03b1] [Mul \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonAssocSemiring \u03b1]", "(\u03b1 n)", "[NonUnitalSemiring \u03b1] [Fintype m] [Fintype n]", "[Semiring \u03b1]", "[NonUnitalNonAssocRing \u03b1] [Fintype n]", "[Semiring \u03b1]", "[CommSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalSemiring \u03b1]", "[NonAssocSemiring \u03b1]", "[Fintype m] [Fintype n] [DecidableEq m]", "[NonUnitalNonAssocRing \u03b1]", "[NonUnitalCommSemiring \u03b1]", "[Semiring R]", "[CommSemiring \u03b1]", "[NonAssocRing \u03b1]", "[Fintype m] [DecidableEq m]", "(m n \u03b1)", "[Fintype n] [NonAssocSemiring \u03b1] [NonAssocSemiring \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\nR : Type u_7\nS : Type u_8\ninst\u271d\u00b9\u2075 : Fintype m\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : DecidableEq m\ninst\u271d\u00b9\u00b2 : Monoid R\ninst\u271d\u00b9\u00b9 : Fintype m\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : Fintype n\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq m\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : NonAssocSemiring S\nf : R \u2192+* S\nM : Matrix m n R\nv : n \u2192 R\ni : m\n\u22a2 f (M.mulVec v i) = (M.map \u21d1f).mulVec (\u21d1f \u2218 v) i"}, {"line": "simp only [Matrix.mulVec]", "tactic_state": "m : Type u_2\nn : Type u_3\nR : Type u_7\nS : Type u_8\ninst\u271d\u00b9\u2075 : Fintype m\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : DecidableEq m\ninst\u271d\u00b9\u00b2 : Monoid R\ninst\u271d\u00b9\u00b9 : Fintype m\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : Fintype n\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq m\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : NonAssocSemiring S\nf : R \u2192+* S\nM : Matrix m n R\nv : n \u2192 R\ni : m\n\u22a2 f ((fun j => M i j) \u2b1d\u1d65 v) = (fun j => M.map (\u21d1f) i j) \u2b1d\u1d65 \u21d1f \u2218 v"}, {"line": "simp only [Matrix.map_apply]", "tactic_state": "m : Type u_2\nn : Type u_3\nR : Type u_7\nS : Type u_8\ninst\u271d\u00b9\u2075 : Fintype m\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : DecidableEq m\ninst\u271d\u00b9\u00b2 : Monoid R\ninst\u271d\u00b9\u00b9 : Fintype m\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : Fintype n\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq m\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : NonAssocSemiring S\nf : R \u2192+* S\nM : Matrix m n R\nv : n \u2192 R\ni : m\n\u22a2 f ((fun j => M i j) \u2b1d\u1d65 v) = (fun j => f (M i j)) \u2b1d\u1d65 \u21d1f \u2218 v"}, {"line": "simp only [RingHom.map_dotProduct]", "tactic_state": "m : Type u_2\nn : Type u_3\nR : Type u_7\nS : Type u_8\ninst\u271d\u00b9\u2075 : Fintype m\ninst\u271d\u00b9\u2074 : Fintype n\ninst\u271d\u00b9\u00b3 : DecidableEq m\ninst\u271d\u00b9\u00b2 : Monoid R\ninst\u271d\u00b9\u00b9 : Fintype m\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : Fintype n\ninst\u271d\u2078 : Fintype m\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq m\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : NonAssocSemiring S\nf : R \u2192+* S\nM : Matrix m n R\nv : n \u2192 R\ni : m\n\u22a2 (\u21d1f \u2218 fun j => M i j) \u2b1d\u1d65 \u21d1f \u2218 v = (fun j => f (M i j)) \u2b1d\u1d65 \u21d1f \u2218 v"}, {"line": "simp only [Function.comp_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cons_val' (v : n' \u2192 \u03b1) (B : Fin m \u2192 n' \u2192 \u03b1) (i j) :\n    vecCons v B i j = vecCons (v j) (fun i => B i j) i := by refine Fin.cases ?_ ?_ i <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nm : \u2115\nn' : Type u\u2099\nv : n' \u2192 \u03b1\nB : Fin m \u2192 n' \u2192 \u03b1\ni : Fin m.succ\nj : n'\n\u22a2 vecCons v B i j = vecCons (v j) (fun i => B i j) i"}, {"line": "refine Fin.cases ?_ ?_ i <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dotProduct_cons (v : Fin n.succ \u2192 \u03b1) (x : \u03b1) (w : Fin n \u2192 \u03b1) :\n    dotProduct v (vecCons x w) = vecHead v * x + dotProduct (vecTail v) w := by\n  simp [dotProduct, Fin.sum_univ_succ, vecHead, vecTail]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nn : \u2115\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\nv : Fin n.succ \u2192 \u03b1\nx : \u03b1\nw : Fin n \u2192 \u03b1\n\u22a2 v \u2b1d\u1d65 vecCons x w = vecHead v * x + vecTail v \u2b1d\u1d65 w"}, {"line": "simp [dotProduct, Fin.sum_univ_succ, vecHead, vecTail]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cons_dotProduct_cons (x : \u03b1) (v : Fin n \u2192 \u03b1) (y : \u03b1) (w : Fin n \u2192 \u03b1) :\n    dotProduct (vecCons x v) (vecCons y w) = x * y + dotProduct v w := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nn : \u2115\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\nx : \u03b1\nv : Fin n \u2192 \u03b1\ny : \u03b1\nw : Fin n \u2192 \u03b1\n\u22a2 vecCons x v \u2b1d\u1d65 vecCons y w = x * y + v \u2b1d\u1d65 w"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem replicateCol_cons (x : \u03b1) (u : Fin m \u2192 \u03b1) :\n    replicateCol \u03b9 (vecCons x u) = of (vecCons (fun _ => x) (replicateCol \u03b9 u)) := by\n  ext i j\n  refine Fin.cases ?_ ?_ i <;> simp [vecHead, vecTail]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nm : \u2115\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\n\u03b9 : Type u_1\nx : \u03b1\nu : Fin m \u2192 \u03b1\n\u22a2 replicateCol \u03b9 (vecCons x u) = of (vecCons (fun x_1 => x) (replicateCol \u03b9 u))"}, {"line": "ext i j", "tactic_state": "case a\n\u03b1 : Type u\nm : \u2115\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\n\u03b9 : Type u_1\nx : \u03b1\nu : Fin m \u2192 \u03b1\ni : Fin m.succ\nj : \u03b9\n\u22a2 replicateCol \u03b9 (vecCons x u) i j = of (vecCons (fun x_1 => x) (replicateCol \u03b9 u)) i j"}, {"line": "refine Fin.cases ?_ ?_ i <;> simp [vecHead, vecTail]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cons_transpose (v : n' \u2192 \u03b1) (A : Matrix (Fin m) n' \u03b1) :\n    (of (vecCons v A))\u1d40 = of fun i => vecCons (v i) (A\u1d40 i) := by\n  ext i j\n  refine Fin.cases ?_ ?_ j <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nm : \u2115\nn' : Type u\u2099\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\nv : n' \u2192 \u03b1\nA : Matrix (Fin m) n' \u03b1\n\u22a2 (of (vecCons v A)).transpose = of fun i => vecCons (v i) (A.transpose i)"}, {"line": "ext i j", "tactic_state": "case a\n\u03b1 : Type u\nm : \u2115\nn' : Type u\u2099\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\nv : n' \u2192 \u03b1\nA : Matrix (Fin m) n' \u03b1\ni : n'\nj : Fin m.succ\n\u22a2 (of (vecCons v A)).transpose i j = of (fun i => vecCons (v i) (A.transpose i)) i j"}, {"line": "refine Fin.cases ?_ ?_ j <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tail_transpose (A : Matrix m' (Fin n.succ) \u03b1) : vecTail (of.symm A\u1d40) = (vecTail \u2218 A)\u1d40 := by\n  ext i j\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nn : \u2115\nm' : Type u\u2098\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\nA : Matrix m' (Fin n.succ) \u03b1\n\u22a2 vecTail (of.symm A.transpose) = transpose (vecTail \u2218 A)"}, {"line": "ext i j", "tactic_state": "case h.h\n\u03b1 : Type u\nn : \u2115\nm' : Type u\u2098\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\nA : Matrix m' (Fin n.succ) \u03b1\ni : Fin n\nj : m'\n\u22a2 vecTail (of.symm A.transpose) i j = transpose (vecTail \u2218 A) i j"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cons_mul [Fintype n'] (v : n' \u2192 \u03b1) (A : Fin m \u2192 n' \u2192 \u03b1) (B : Matrix n' o' \u03b1) :\n    of (vecCons v A) * B = of (vecCons (v \u1d65* B) (of.symm (of A * B))) := by\n  ext i j\n  refine Fin.cases ?_ ?_ i\n  \u00b7 rfl\n  simp [mul_val_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nm : \u2115\nn' : Type u\u2099\no' : Type u\u2092\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype n'\nv : n' \u2192 \u03b1\nA : Fin m \u2192 n' \u2192 \u03b1\nB : Matrix n' o' \u03b1\n\u22a2 of (vecCons v A) * B = of (vecCons (vecMul v B) (of.symm (of A * B)))"}, {"line": "ext i j", "tactic_state": "case a\n\u03b1 : Type u\nm : \u2115\nn' : Type u\u2099\no' : Type u\u2092\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype n'\nv : n' \u2192 \u03b1\nA : Fin m \u2192 n' \u2192 \u03b1\nB : Matrix n' o' \u03b1\ni : Fin m.succ\nj : o'\n\u22a2 (of (vecCons v A) * B) i j = of (vecCons (vecMul v B) (of.symm (of A * B))) i j"}, {"line": "refine Fin.cases ?_ ?_ i", "tactic_state": "case a.refine_1\n\u03b1 : Type u\nm : \u2115\nn' : Type u\u2099\no' : Type u\u2092\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype n'\nv : n' \u2192 \u03b1\nA : Fin m \u2192 n' \u2192 \u03b1\nB : Matrix n' o' \u03b1\ni : Fin m.succ\nj : o'\n\u22a2 (of (vecCons v A) * B) 0 j = of (vecCons (vecMul v B) (of.symm (of A * B))) 0 j\n---\ncase a.refine_2\n\u03b1 : Type u\nm : \u2115\nn' : Type u\u2099\no' : Type u\u2092\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype n'\nv : n' \u2192 \u03b1\nA : Fin m \u2192 n' \u2192 \u03b1\nB : Matrix n' o' \u03b1\ni : Fin m.succ\nj : o'\n\u22a2 \u2200 (i : Fin m), (of (vecCons v A) * B) i.succ j = of (vecCons (vecMul v B) (of.symm (of A * B))) i.succ j"}, {"line": "\u00b7 rfl", "tactic_state": "case a.refine_2\n\u03b1 : Type u\nm : \u2115\nn' : Type u\u2099\no' : Type u\u2092\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype n'\nv : n' \u2192 \u03b1\nA : Fin m \u2192 n' \u2192 \u03b1\nB : Matrix n' o' \u03b1\ni : Fin m.succ\nj : o'\n\u22a2 \u2200 (i : Fin m), (of (vecCons v A) * B) i.succ j = of (vecCons (vecMul v B) (of.symm (of A * B))) i.succ j"}, {"line": "simp [mul_val_succ]", "tactic_state": "case a.refine_2\n\u03b1 : Type u\nm : \u2115\nn' : Type u\u2099\no' : Type u\u2092\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype n'\nv : n' \u2192 \u03b1\nA : Fin m \u2192 n' \u2192 \u03b1\nB : Matrix n' o' \u03b1\ni : Fin m.succ\nj : o'\n\u22a2 \u2200 (i : Fin m), (of (vecCons v A) * B) i.succ j = (of A * B) i j"}]}
{"declaration": "theorem cons_vecMul (x : \u03b1) (v : Fin n \u2192 \u03b1) (B : Fin n.succ \u2192 o' \u2192 \u03b1) :\n    vecCons x v \u1d65* of B = x \u2022 vecHead B + v \u1d65* of (vecTail B) := by\n  ext i\n  simp [vecMul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nn : \u2115\no' : Type u\u2092\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 inst\u271d : NonUnitalNonAssocSemiring \u03b1\nx : \u03b1\nv : Fin n \u2192 \u03b1\nB : Fin n.succ \u2192 o' \u2192 \u03b1\n\u22a2 vecMul (vecCons x v) (of B) = x \u2022 vecHead B + vecMul v (of (vecTail B))"}, {"line": "ext i", "tactic_state": "case h\n\u03b1 : Type u\nn : \u2115\no' : Type u\u2092\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 inst\u271d : NonUnitalNonAssocSemiring \u03b1\nx : \u03b1\nv : Fin n \u2192 \u03b1\nB : Fin n.succ \u2192 o' \u2192 \u03b1\ni : o'\n\u22a2 vecMul (vecCons x v) (of B) i = (x \u2022 vecHead B + vecMul v (of (vecTail B))) i"}, {"line": "simp [vecMul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vecMul_cons (v : Fin n.succ \u2192 \u03b1) (w : o' \u2192 \u03b1) (B : Fin n \u2192 o' \u2192 \u03b1) :\n    v \u1d65* of (vecCons w B) = vecHead v \u2022 w + vecTail v \u1d65* of B := by\n  ext i\n  simp [vecMul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nn : \u2115\no' : Type u\u2092\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 inst\u271d : NonUnitalNonAssocSemiring \u03b1\nv : Fin n.succ \u2192 \u03b1\nw : o' \u2192 \u03b1\nB : Fin n \u2192 o' \u2192 \u03b1\n\u22a2 vecMul v (of (vecCons w B)) = vecHead v \u2022 w + vecMul (vecTail v) (of B)"}, {"line": "ext i", "tactic_state": "case h\n\u03b1 : Type u\nn : \u2115\no' : Type u\u2092\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 inst\u271d : NonUnitalNonAssocSemiring \u03b1\nv : Fin n.succ \u2192 \u03b1\nw : o' \u2192 \u03b1\nB : Fin n \u2192 o' \u2192 \u03b1\ni : o'\n\u22a2 vecMul v (of (vecCons w B)) i = (vecHead v \u2022 w + vecMul (vecTail v) (of B)) i"}, {"line": "simp [vecMul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cons_vecMul_cons (x : \u03b1) (v : Fin n \u2192 \u03b1) (w : o' \u2192 \u03b1) (B : Fin n \u2192 o' \u2192 \u03b1) :\n    vecCons x v \u1d65* of (vecCons w B) = x \u2022 w + v \u1d65* of B := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nn : \u2115\no' : Type u\u2092\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 inst\u271d : NonUnitalNonAssocSemiring \u03b1\nx : \u03b1\nv : Fin n \u2192 \u03b1\nw : o' \u2192 \u03b1\nB : Fin n \u2192 o' \u2192 \u03b1\n\u22a2 vecMul (vecCons x v) (of (vecCons w B)) = x \u2022 w + vecMul v (of B)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cons_mulVec [Fintype n'] (v : n' \u2192 \u03b1) (A : Fin m \u2192 n' \u2192 \u03b1) (w : n' \u2192 \u03b1) :\n    (of <| vecCons v A) *\u1d65 w = vecCons (dotProduct v w) (of A *\u1d65 w) := by\n  ext i\n  refine Fin.cases ?_ ?_ i <;> simp [mulVec]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nm : \u2115\nn' : Type u\u2099\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : Mul \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype n'\nv : n' \u2192 \u03b1\nA : Fin m \u2192 n' \u2192 \u03b1\nw : n' \u2192 \u03b1\n\u22a2 (of (vecCons v A)).mulVec w = vecCons (v \u2b1d\u1d65 w) ((of A).mulVec w)"}, {"line": "ext i", "tactic_state": "case h\n\u03b1 : Type u\nm : \u2115\nn' : Type u\u2099\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : Mul \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype n'\nv : n' \u2192 \u03b1\nA : Fin m \u2192 n' \u2192 \u03b1\nw : n' \u2192 \u03b1\ni : Fin m.succ\n\u22a2 (of (vecCons v A)).mulVec w i = vecCons (v \u2b1d\u1d65 w) ((of A).mulVec w) i"}, {"line": "refine Fin.cases ?_ ?_ i <;> simp [mulVec]", "tactic_state": "case h.refine_1\n\u03b1 : Type u\nm : \u2115\nn' : Type u\u2099\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : Mul \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype n'\nv : n' \u2192 \u03b1\nA : Fin m \u2192 n' \u2192 \u03b1\nw : n' \u2192 \u03b1\ni : Fin m.succ\n\u22a2 (fun j => v j) \u2b1d\u1d65 w = v \u2b1d\u1d65 w"}]}
{"declaration": "theorem mulVec_cons {\u03b1} [NonUnitalCommSemiring \u03b1] (A : m' \u2192 Fin n.succ \u2192 \u03b1) (x : \u03b1)\n    (v : Fin n \u2192 \u03b1) : (of A) *\u1d65 (vecCons x v) = x \u2022 vecHead \u2218 A + (of (vecTail \u2218 A)) *\u1d65 v := by\n  ext i\n  simp [mulVec, mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nm' : Type u\u2098\n\u03b1 : Type u_2\ninst\u271d : NonUnitalCommSemiring \u03b1\nA : m' \u2192 Fin n.succ \u2192 \u03b1\nx : \u03b1\nv : Fin n \u2192 \u03b1\n\u22a2 (of A).mulVec (vecCons x v) = x \u2022 vecHead \u2218 A + (of (vecTail \u2218 A)).mulVec v"}, {"line": "ext i", "tactic_state": "case h\nn : \u2115\nm' : Type u\u2098\n\u03b1 : Type u_2\ninst\u271d : NonUnitalCommSemiring \u03b1\nA : m' \u2192 Fin n.succ \u2192 \u03b1\nx : \u03b1\nv : Fin n \u2192 \u03b1\ni : m'\n\u22a2 (of A).mulVec (vecCons x v) i = (x \u2022 vecHead \u2218 A + (of (vecTail \u2218 A)).mulVec v) i"}, {"line": "simp [mulVec, mul_comm]", "tactic_state": "case h\nn : \u2115\nm' : Type u\u2098\n\u03b1 : Type u_2\ninst\u271d : NonUnitalCommSemiring \u03b1\nA : m' \u2192 Fin n.succ \u2192 \u03b1\nx : \u03b1\nv : Fin n \u2192 \u03b1\ni : m'\n\u22a2 (vecHead fun j => A i j) * x + (vecTail fun j => A i j) \u2b1d\u1d65 v = x * vecHead (A i) + (fun j => vecTail (A i) j) \u2b1d\u1d65 v"}]}
{"declaration": "theorem cons_vecMulVec (x : \u03b1) (v : Fin m \u2192 \u03b1) (w : n' \u2192 \u03b1) :\n    vecMulVec (vecCons x v) w = vecCons (x \u2022 w) (vecMulVec v w) := by\n  ext i\n  refine Fin.cases ?_ ?_ i <;> simp [vecMulVec]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nm : \u2115\nn' : Type u\u2099\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : Mul \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : NonUnitalNonAssocSemiring \u03b1\nx : \u03b1\nv : Fin m \u2192 \u03b1\nw : n' \u2192 \u03b1\n\u22a2 vecMulVec (vecCons x v) w = vecCons (x \u2022 w) (vecMulVec v w)"}, {"line": "ext i", "tactic_state": "case a\n\u03b1 : Type u\nm : \u2115\nn' : Type u\u2099\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : Mul \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : NonUnitalNonAssocSemiring \u03b1\nx : \u03b1\nv : Fin m \u2192 \u03b1\nw : n' \u2192 \u03b1\ni : Fin m.succ\nj\u271d : n'\n\u22a2 vecMulVec (vecCons x v) w i j\u271d = vecCons (x \u2022 w) (vecMulVec v w) i j\u271d"}, {"line": "refine Fin.cases ?_ ?_ i <;> simp [vecMulVec]", "tactic_state": "case a.refine_1\n\u03b1 : Type u\nm : \u2115\nn' : Type u\u2099\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : Mul \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : NonUnitalNonAssocSemiring \u03b1\nx : \u03b1\nv : Fin m \u2192 \u03b1\nw : n' \u2192 \u03b1\ni : Fin m.succ\nj\u271d : n'\n\u22a2 x * w j\u271d = x * w j\u271d"}]}
{"declaration": "theorem smul_mat_cons (x : \u03b1) (v : n' \u2192 \u03b1) (A : Fin m \u2192 n' \u2192 \u03b1) :\n    x \u2022 vecCons v A = vecCons (x \u2022 v) (x \u2022 A) := by\n  ext i\n  refine Fin.cases ?_ ?_ i <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nm : \u2115\nn' : Type u\u2099\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : NonUnitalNonAssocSemiring \u03b1\nx : \u03b1\nv : n' \u2192 \u03b1\nA : Fin m \u2192 n' \u2192 \u03b1\n\u22a2 x \u2022 vecCons v A = vecCons (x \u2022 v) (x \u2022 A)"}, {"line": "ext i", "tactic_state": "case h.h\n\u03b1 : Type u\nm : \u2115\nn' : Type u\u2099\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : NonUnitalNonAssocSemiring \u03b1\nx : \u03b1\nv : n' \u2192 \u03b1\nA : Fin m \u2192 n' \u2192 \u03b1\ni : Fin m.succ\nx\u271d : n'\n\u22a2 (x \u2022 vecCons v A) i x\u271d = vecCons (x \u2022 v) (x \u2022 A) i x\u271d"}, {"line": "refine Fin.cases ?_ ?_ i <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem submatrix_cons_row (A : Matrix m' n' \u03b1) (i : m') (row : Fin m \u2192 m') (col : o' \u2192 n') :\n    submatrix A (vecCons i row) col = vecCons (fun j => A i (col j)) (submatrix A row col) := by\n  ext i j\n  refine Fin.cases ?_ ?_ i <;> simp [submatrix]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nm : \u2115\nm' : Type u\u2098\nn' : Type u\u2099\no' : Type u\u2092\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : NonUnitalNonAssocSemiring \u03b1\nA : Matrix m' n' \u03b1\ni : m'\nrow : Fin m \u2192 m'\ncol : o' \u2192 n'\n\u22a2 A.submatrix (vecCons i row) col = vecCons (fun j => A i (col j)) (A.submatrix row col)"}, {"line": "ext i j", "tactic_state": "case a\n\u03b1 : Type u\nm : \u2115\nm' : Type u\u2098\nn' : Type u\u2099\no' : Type u\u2092\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : NonUnitalNonAssocSemiring \u03b1\nA : Matrix m' n' \u03b1\ni\u271d : m'\nrow : Fin m \u2192 m'\ncol : o' \u2192 n'\ni : Fin m.succ\nj : o'\n\u22a2 A.submatrix (vecCons i\u271d row) col i j = vecCons (fun j => A i\u271d (col j)) (A.submatrix row col) i j"}, {"line": "refine Fin.cases ?_ ?_ i <;> simp [submatrix]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_fin_two : (1 : Matrix (Fin 2) (Fin 2) \u03b1) = !![1, 0; 0, 1] := by\n  ext i j\n  fin_cases i <;> fin_cases j <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[Zero \u03b1] [One \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2078 : AddCommMonoid \u03b1\ninst\u271d\u2077 : Mul \u03b1\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\n\u22a2 1 = !![1, 0; 0, 1]"}, {"line": "ext i j", "tactic_state": "case a\n\u03b1 : Type u\ninst\u271d\u2078 : AddCommMonoid \u03b1\ninst\u271d\u2077 : Mul \u03b1\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\ni j : Fin 2\n\u22a2 1 i j = !![1, 0; 0, 1] i j"}, {"line": "fin_cases i <;> fin_cases j <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_fin_three : (1 : Matrix (Fin 3) (Fin 3) \u03b1) = !![1, 0, 0; 0, 1, 0; 0, 0, 1] := by\n  ext i j\n  fin_cases i <;> fin_cases j <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[Zero \u03b1] [One \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2078 : AddCommMonoid \u03b1\ninst\u271d\u2077 : Mul \u03b1\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\n\u22a2 1 = !![1, 0, 0; 0, 1, 0; 0, 0, 1]"}, {"line": "ext i j", "tactic_state": "case a\n\u03b1 : Type u\ninst\u271d\u2078 : AddCommMonoid \u03b1\ninst\u271d\u2077 : Mul \u03b1\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\ni j : Fin 3\n\u22a2 1 i j = !![1, 0, 0; 0, 1, 0; 0, 0, 1] i j"}, {"line": "fin_cases i <;> fin_cases j <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_fin_two (n : \u2115) : (n : Matrix (Fin 2) (Fin 2) \u03b1) = !![\u2191n, 0; 0, \u2191n] := by\n  ext i j\n  fin_cases i <;> fin_cases j <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[Zero \u03b1] [One \u03b1]", "[AddMonoidWithOne \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2079 : AddCommMonoid \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\nn : \u2115\n\u22a2 \u2191n = !![\u2191n, 0; 0, \u2191n]"}, {"line": "ext i j", "tactic_state": "case a\n\u03b1 : Type u\ninst\u271d\u2079 : AddCommMonoid \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\nn : \u2115\ni j : Fin 2\n\u22a2 \u2191n i j = !![\u2191n, 0; 0, \u2191n] i j"}, {"line": "fin_cases i <;> fin_cases j <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_fin_three (n : \u2115) :\n    (n : Matrix (Fin 3) (Fin 3) \u03b1) = !![\u2191n, 0, 0; 0, \u2191n, 0; 0, 0, \u2191n] := by\n  ext i j\n  fin_cases i <;> fin_cases j <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[Zero \u03b1] [One \u03b1]", "[AddMonoidWithOne \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2079 : AddCommMonoid \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\nn : \u2115\n\u22a2 \u2191n = !![\u2191n, 0, 0; 0, \u2191n, 0; 0, 0, \u2191n]"}, {"line": "ext i j", "tactic_state": "case a\n\u03b1 : Type u\ninst\u271d\u2079 : AddCommMonoid \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\nn : \u2115\ni j : Fin 3\n\u22a2 \u2191n i j = !![\u2191n, 0, 0; 0, \u2191n, 0; 0, 0, \u2191n] i j"}, {"line": "fin_cases i <;> fin_cases j <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eta_fin_two (A : Matrix (Fin 2) (Fin 2) \u03b1) : A = !![A 0 0, A 0 1; A 1 0, A 1 1] := by\n  ext i j\n  fin_cases i <;> fin_cases j <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[Zero \u03b1] [One \u03b1]", "[AddMonoidWithOne \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2079 : AddCommMonoid \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\nA : Matrix (Fin 2) (Fin 2) \u03b1\n\u22a2 A = !![A 0 0, A 0 1; A 1 0, A 1 1]"}, {"line": "ext i j", "tactic_state": "case a\n\u03b1 : Type u\ninst\u271d\u2079 : AddCommMonoid \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\nA : Matrix (Fin 2) (Fin 2) \u03b1\ni j : Fin 2\n\u22a2 A i j = !![A 0 0, A 0 1; A 1 0, A 1 1] i j"}, {"line": "fin_cases i <;> fin_cases j <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eta_fin_three (A : Matrix (Fin 3) (Fin 3) \u03b1) :\n    A = !![A 0 0, A 0 1, A 0 2;\n           A 1 0, A 1 1, A 1 2;\n           A 2 0, A 2 1, A 2 2] := by\n  ext i j\n  fin_cases i <;> fin_cases j <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[Zero \u03b1] [One \u03b1]", "[AddMonoidWithOne \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2079 : AddCommMonoid \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\nA : Matrix (Fin 3) (Fin 3) \u03b1\n\u22a2 A = !![A 0 0, A 0 1, A 0 2; A 1 0, A 1 1, A 1 2; A 2 0, A 2 1, A 2 2]"}, {"line": "ext i j", "tactic_state": "case a\n\u03b1 : Type u\ninst\u271d\u2079 : AddCommMonoid \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\nA : Matrix (Fin 3) (Fin 3) \u03b1\ni j : Fin 3\n\u22a2 A i j = !![A 0 0, A 0 1, A 0 2; A 1 0, A 1 1, A 1 2; A 2 0, A 2 1, A 2 2] i j"}, {"line": "fin_cases i <;> fin_cases j <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_fin_two [AddCommMonoid \u03b1] [Mul \u03b1] (a\u2081\u2081 a\u2081\u2082 a\u2082\u2081 a\u2082\u2082 b\u2081\u2081 b\u2081\u2082 b\u2082\u2081 b\u2082\u2082 : \u03b1) :\n    !![a\u2081\u2081, a\u2081\u2082;\n       a\u2082\u2081, a\u2082\u2082] * !![b\u2081\u2081, b\u2081\u2082;\n                      b\u2082\u2081, b\u2082\u2082] = !![a\u2081\u2081 * b\u2081\u2081 + a\u2081\u2082 * b\u2082\u2081, a\u2081\u2081 * b\u2081\u2082 + a\u2081\u2082 * b\u2082\u2082;\n                                     a\u2082\u2081 * b\u2081\u2081 + a\u2082\u2082 * b\u2082\u2081, a\u2082\u2081 * b\u2081\u2082 + a\u2082\u2082 * b\u2082\u2082] := by\n  ext i j\n  fin_cases i <;> fin_cases j <;> simp [Matrix.mul_apply, dotProduct, Fin.sum_univ_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[Zero \u03b1] [One \u03b1]", "[AddMonoidWithOne \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2082\u2081 a\u2082\u2082 b\u2081\u2081 b\u2081\u2082 b\u2082\u2081 b\u2082\u2082 : \u03b1\n\u22a2 !![a\u2081\u2081, a\u2081\u2082; a\u2082\u2081, a\u2082\u2082] * !![b\u2081\u2081, b\u2081\u2082; b\u2082\u2081, b\u2082\u2082] =\n    !![a\u2081\u2081 * b\u2081\u2081 + a\u2081\u2082 * b\u2082\u2081, a\u2081\u2081 * b\u2081\u2082 + a\u2081\u2082 * b\u2082\u2082; a\u2082\u2081 * b\u2081\u2081 + a\u2082\u2082 * b\u2082\u2081, a\u2082\u2081 * b\u2081\u2082 + a\u2082\u2082 * b\u2082\u2082]"}, {"line": "ext i j", "tactic_state": "case a\n\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2082\u2081 a\u2082\u2082 b\u2081\u2081 b\u2081\u2082 b\u2082\u2081 b\u2082\u2082 : \u03b1\ni j : Fin 2\n\u22a2 (!![a\u2081\u2081, a\u2081\u2082; a\u2082\u2081, a\u2082\u2082] * !![b\u2081\u2081, b\u2081\u2082; b\u2082\u2081, b\u2082\u2082]) i j =\n    !![a\u2081\u2081 * b\u2081\u2081 + a\u2081\u2082 * b\u2082\u2081, a\u2081\u2081 * b\u2081\u2082 + a\u2081\u2082 * b\u2082\u2082; a\u2082\u2081 * b\u2081\u2081 + a\u2082\u2082 * b\u2082\u2081, a\u2082\u2081 * b\u2081\u2082 + a\u2082\u2082 * b\u2082\u2082] i j"}, {"line": "fin_cases i <;> fin_cases j <;> simp [Matrix.mul_apply, dotProduct, Fin.sum_univ_succ]", "tactic_state": "case a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab0\u00bb.\u00ab0\u00bb\n\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2082\u2081 a\u2082\u2082 b\u2081\u2081 b\u2081\u2082 b\u2082\u2081 b\u2082\u2082 : \u03b1\n\u22a2 a\u2081\u2081 * b\u2081\u2081 + a\u2081\u2082 * b\u2082\u2081 = a\u2081\u2081 * b\u2081\u2081 + a\u2081\u2082 * b\u2082\u2081\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab0\u00bb.\u00ab1\u00bb\n\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2082\u2081 a\u2082\u2082 b\u2081\u2081 b\u2081\u2082 b\u2082\u2081 b\u2082\u2082 : \u03b1\n\u22a2 a\u2081\u2081 * b\u2081\u2082 + a\u2081\u2082 * b\u2082\u2082 = a\u2081\u2081 * b\u2081\u2082 + a\u2081\u2082 * b\u2082\u2082\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab1\u00bb.\u00ab0\u00bb\n\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2082\u2081 a\u2082\u2082 b\u2081\u2081 b\u2081\u2082 b\u2082\u2081 b\u2082\u2082 : \u03b1\n\u22a2 a\u2082\u2081 * b\u2081\u2081 + a\u2082\u2082 * b\u2082\u2081 = a\u2082\u2081 * b\u2081\u2081 + a\u2082\u2082 * b\u2082\u2081\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab1\u00bb.\u00ab1\u00bb\n\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2082\u2081 a\u2082\u2082 b\u2081\u2081 b\u2081\u2082 b\u2082\u2081 b\u2082\u2082 : \u03b1\n\u22a2 a\u2082\u2081 * b\u2081\u2082 + a\u2082\u2082 * b\u2082\u2082 = a\u2082\u2081 * b\u2081\u2082 + a\u2082\u2082 * b\u2082\u2082"}]}
{"declaration": "theorem mul_fin_three [AddCommMonoid \u03b1] [Mul \u03b1]\n    (a\u2081\u2081 a\u2081\u2082 a\u2081\u2083 a\u2082\u2081 a\u2082\u2082 a\u2082\u2083 a\u2083\u2081 a\u2083\u2082 a\u2083\u2083 b\u2081\u2081 b\u2081\u2082 b\u2081\u2083 b\u2082\u2081 b\u2082\u2082 b\u2082\u2083 b\u2083\u2081 b\u2083\u2082 b\u2083\u2083 : \u03b1) :\n    !![a\u2081\u2081, a\u2081\u2082, a\u2081\u2083;\n       a\u2082\u2081, a\u2082\u2082, a\u2082\u2083;\n       a\u2083\u2081, a\u2083\u2082, a\u2083\u2083] * !![b\u2081\u2081, b\u2081\u2082, b\u2081\u2083;\n                           b\u2082\u2081, b\u2082\u2082, b\u2082\u2083;\n                           b\u2083\u2081, b\u2083\u2082, b\u2083\u2083] =\n    !![a\u2081\u2081*b\u2081\u2081 + a\u2081\u2082*b\u2082\u2081 + a\u2081\u2083*b\u2083\u2081, a\u2081\u2081*b\u2081\u2082 + a\u2081\u2082*b\u2082\u2082 + a\u2081\u2083*b\u2083\u2082, a\u2081\u2081*b\u2081\u2083 + a\u2081\u2082*b\u2082\u2083 + a\u2081\u2083*b\u2083\u2083;\n       a\u2082\u2081*b\u2081\u2081 + a\u2082\u2082*b\u2082\u2081 + a\u2082\u2083*b\u2083\u2081, a\u2082\u2081*b\u2081\u2082 + a\u2082\u2082*b\u2082\u2082 + a\u2082\u2083*b\u2083\u2082, a\u2082\u2081*b\u2081\u2083 + a\u2082\u2082*b\u2082\u2083 + a\u2082\u2083*b\u2083\u2083;\n       a\u2083\u2081*b\u2081\u2081 + a\u2083\u2082*b\u2082\u2081 + a\u2083\u2083*b\u2083\u2081, a\u2083\u2081*b\u2081\u2082 + a\u2083\u2082*b\u2082\u2082 + a\u2083\u2083*b\u2083\u2082, a\u2083\u2081*b\u2081\u2083 + a\u2083\u2082*b\u2082\u2083 + a\u2083\u2083*b\u2083\u2083] := by\n  ext i j\n  fin_cases i <;> fin_cases j\n    <;> simp [Matrix.mul_apply, dotProduct, Fin.sum_univ_succ, \u2190 add_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[Zero \u03b1] [One \u03b1]", "[AddMonoidWithOne \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2081\u2083 a\u2082\u2081 a\u2082\u2082 a\u2082\u2083 a\u2083\u2081 a\u2083\u2082 a\u2083\u2083 b\u2081\u2081 b\u2081\u2082 b\u2081\u2083 b\u2082\u2081 b\u2082\u2082 b\u2082\u2083 b\u2083\u2081 b\u2083\u2082 b\u2083\u2083 : \u03b1\n\u22a2 !![a\u2081\u2081, a\u2081\u2082, a\u2081\u2083; a\u2082\u2081, a\u2082\u2082, a\u2082\u2083; a\u2083\u2081, a\u2083\u2082, a\u2083\u2083] * !![b\u2081\u2081, b\u2081\u2082, b\u2081\u2083; b\u2082\u2081, b\u2082\u2082, b\u2082\u2083; b\u2083\u2081, b\u2083\u2082, b\u2083\u2083] =\n    !![a\u2081\u2081 * b\u2081\u2081 + a\u2081\u2082 * b\u2082\u2081 + a\u2081\u2083 * b\u2083\u2081, a\u2081\u2081 * b\u2081\u2082 + a\u2081\u2082 * b\u2082\u2082 + a\u2081\u2083 * b\u2083\u2082, a\u2081\u2081 * b\u2081\u2083 + a\u2081\u2082 * b\u2082\u2083 + a\u2081\u2083 * b\u2083\u2083;\n      a\u2082\u2081 * b\u2081\u2081 + a\u2082\u2082 * b\u2082\u2081 + a\u2082\u2083 * b\u2083\u2081, a\u2082\u2081 * b\u2081\u2082 + a\u2082\u2082 * b\u2082\u2082 + a\u2082\u2083 * b\u2083\u2082, a\u2082\u2081 * b\u2081\u2083 + a\u2082\u2082 * b\u2082\u2083 + a\u2082\u2083 * b\u2083\u2083;\n      a\u2083\u2081 * b\u2081\u2081 + a\u2083\u2082 * b\u2082\u2081 + a\u2083\u2083 * b\u2083\u2081, a\u2083\u2081 * b\u2081\u2082 + a\u2083\u2082 * b\u2082\u2082 + a\u2083\u2083 * b\u2083\u2082, a\u2083\u2081 * b\u2081\u2083 + a\u2083\u2082 * b\u2082\u2083 + a\u2083\u2083 * b\u2083\u2083]"}, {"line": "ext i j", "tactic_state": "case a\n\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2081\u2083 a\u2082\u2081 a\u2082\u2082 a\u2082\u2083 a\u2083\u2081 a\u2083\u2082 a\u2083\u2083 b\u2081\u2081 b\u2081\u2082 b\u2081\u2083 b\u2082\u2081 b\u2082\u2082 b\u2082\u2083 b\u2083\u2081 b\u2083\u2082 b\u2083\u2083 : \u03b1\ni j : Fin 3\n\u22a2 (!![a\u2081\u2081, a\u2081\u2082, a\u2081\u2083; a\u2082\u2081, a\u2082\u2082, a\u2082\u2083; a\u2083\u2081, a\u2083\u2082, a\u2083\u2083] * !![b\u2081\u2081, b\u2081\u2082, b\u2081\u2083; b\u2082\u2081, b\u2082\u2082, b\u2082\u2083; b\u2083\u2081, b\u2083\u2082, b\u2083\u2083]) i j =\n    !![a\u2081\u2081 * b\u2081\u2081 + a\u2081\u2082 * b\u2082\u2081 + a\u2081\u2083 * b\u2083\u2081, a\u2081\u2081 * b\u2081\u2082 + a\u2081\u2082 * b\u2082\u2082 + a\u2081\u2083 * b\u2083\u2082, a\u2081\u2081 * b\u2081\u2083 + a\u2081\u2082 * b\u2082\u2083 + a\u2081\u2083 * b\u2083\u2083;\n        a\u2082\u2081 * b\u2081\u2081 + a\u2082\u2082 * b\u2082\u2081 + a\u2082\u2083 * b\u2083\u2081, a\u2082\u2081 * b\u2081\u2082 + a\u2082\u2082 * b\u2082\u2082 + a\u2082\u2083 * b\u2083\u2082, a\u2082\u2081 * b\u2081\u2083 + a\u2082\u2082 * b\u2082\u2083 + a\u2082\u2083 * b\u2083\u2083;\n        a\u2083\u2081 * b\u2081\u2081 + a\u2083\u2082 * b\u2082\u2081 + a\u2083\u2083 * b\u2083\u2081, a\u2083\u2081 * b\u2081\u2082 + a\u2083\u2082 * b\u2082\u2082 + a\u2083\u2083 * b\u2083\u2082, a\u2083\u2081 * b\u2081\u2083 + a\u2083\u2082 * b\u2082\u2083 + a\u2083\u2083 * b\u2083\u2083]\n      i j"}, {"line": "fin_cases i <;> fin_cases j\n    <;> simp [Matrix.mul_apply, dotProduct, Fin.sum_univ_succ, \u2190 add_assoc]", "tactic_state": "case a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab0\u00bb.\u00ab0\u00bb\n\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2081\u2083 a\u2082\u2081 a\u2082\u2082 a\u2082\u2083 a\u2083\u2081 a\u2083\u2082 a\u2083\u2083 b\u2081\u2081 b\u2081\u2082 b\u2081\u2083 b\u2082\u2081 b\u2082\u2082 b\u2082\u2083 b\u2083\u2081 b\u2083\u2082 b\u2083\u2083 : \u03b1\n\u22a2 a\u2081\u2081 * b\u2081\u2081 + a\u2081\u2082 * b\u2082\u2081 + a\u2081\u2083 * b\u2083\u2081 = a\u2081\u2081 * b\u2081\u2081 + a\u2081\u2082 * b\u2082\u2081 + a\u2081\u2083 * b\u2083\u2081\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab0\u00bb.\u00ab1\u00bb\n\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2081\u2083 a\u2082\u2081 a\u2082\u2082 a\u2082\u2083 a\u2083\u2081 a\u2083\u2082 a\u2083\u2083 b\u2081\u2081 b\u2081\u2082 b\u2081\u2083 b\u2082\u2081 b\u2082\u2082 b\u2082\u2083 b\u2083\u2081 b\u2083\u2082 b\u2083\u2083 : \u03b1\n\u22a2 a\u2081\u2081 * b\u2081\u2082 + a\u2081\u2082 * b\u2082\u2082 + a\u2081\u2083 * b\u2083\u2082 = a\u2081\u2081 * b\u2081\u2082 + a\u2081\u2082 * b\u2082\u2082 + a\u2081\u2083 * b\u2083\u2082\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab0\u00bb.\u00ab2\u00bb\n\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2081\u2083 a\u2082\u2081 a\u2082\u2082 a\u2082\u2083 a\u2083\u2081 a\u2083\u2082 a\u2083\u2083 b\u2081\u2081 b\u2081\u2082 b\u2081\u2083 b\u2082\u2081 b\u2082\u2082 b\u2082\u2083 b\u2083\u2081 b\u2083\u2082 b\u2083\u2083 : \u03b1\n\u22a2 a\u2081\u2081 * b\u2081\u2083 + a\u2081\u2082 * b\u2082\u2083 + a\u2081\u2083 * b\u2083\u2083 = a\u2081\u2081 * b\u2081\u2083 + a\u2081\u2082 * b\u2082\u2083 + a\u2081\u2083 * b\u2083\u2083\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab1\u00bb.\u00ab0\u00bb\n\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2081\u2083 a\u2082\u2081 a\u2082\u2082 a\u2082\u2083 a\u2083\u2081 a\u2083\u2082 a\u2083\u2083 b\u2081\u2081 b\u2081\u2082 b\u2081\u2083 b\u2082\u2081 b\u2082\u2082 b\u2082\u2083 b\u2083\u2081 b\u2083\u2082 b\u2083\u2083 : \u03b1\n\u22a2 a\u2082\u2081 * b\u2081\u2081 + a\u2082\u2082 * b\u2082\u2081 + a\u2082\u2083 * b\u2083\u2081 = a\u2082\u2081 * b\u2081\u2081 + a\u2082\u2082 * b\u2082\u2081 + a\u2082\u2083 * b\u2083\u2081\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab1\u00bb.\u00ab1\u00bb\n\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2081\u2083 a\u2082\u2081 a\u2082\u2082 a\u2082\u2083 a\u2083\u2081 a\u2083\u2082 a\u2083\u2083 b\u2081\u2081 b\u2081\u2082 b\u2081\u2083 b\u2082\u2081 b\u2082\u2082 b\u2082\u2083 b\u2083\u2081 b\u2083\u2082 b\u2083\u2083 : \u03b1\n\u22a2 a\u2082\u2081 * b\u2081\u2082 + a\u2082\u2082 * b\u2082\u2082 + a\u2082\u2083 * b\u2083\u2082 = a\u2082\u2081 * b\u2081\u2082 + a\u2082\u2082 * b\u2082\u2082 + a\u2082\u2083 * b\u2083\u2082\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab1\u00bb.\u00ab2\u00bb\n\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2081\u2083 a\u2082\u2081 a\u2082\u2082 a\u2082\u2083 a\u2083\u2081 a\u2083\u2082 a\u2083\u2083 b\u2081\u2081 b\u2081\u2082 b\u2081\u2083 b\u2082\u2081 b\u2082\u2082 b\u2082\u2083 b\u2083\u2081 b\u2083\u2082 b\u2083\u2083 : \u03b1\n\u22a2 a\u2082\u2081 * b\u2081\u2083 + a\u2082\u2082 * b\u2082\u2083 + a\u2082\u2083 * b\u2083\u2083 = a\u2082\u2081 * b\u2081\u2083 + a\u2082\u2082 * b\u2082\u2083 + a\u2082\u2083 * b\u2083\u2083\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab2\u00bb.\u00ab0\u00bb\n\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2081\u2083 a\u2082\u2081 a\u2082\u2082 a\u2082\u2083 a\u2083\u2081 a\u2083\u2082 a\u2083\u2083 b\u2081\u2081 b\u2081\u2082 b\u2081\u2083 b\u2082\u2081 b\u2082\u2082 b\u2082\u2083 b\u2083\u2081 b\u2083\u2082 b\u2083\u2083 : \u03b1\n\u22a2 a\u2083\u2081 * b\u2081\u2081 + a\u2083\u2082 * b\u2082\u2081 + a\u2083\u2083 * b\u2083\u2081 = a\u2083\u2081 * b\u2081\u2081 + a\u2083\u2082 * b\u2082\u2081 + a\u2083\u2083 * b\u2083\u2081\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab2\u00bb.\u00ab1\u00bb\n\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2081\u2083 a\u2082\u2081 a\u2082\u2082 a\u2082\u2083 a\u2083\u2081 a\u2083\u2082 a\u2083\u2083 b\u2081\u2081 b\u2081\u2082 b\u2081\u2083 b\u2082\u2081 b\u2082\u2082 b\u2082\u2083 b\u2083\u2081 b\u2083\u2082 b\u2083\u2083 : \u03b1\n\u22a2 a\u2083\u2081 * b\u2081\u2082 + a\u2083\u2082 * b\u2082\u2082 + a\u2083\u2083 * b\u2083\u2082 = a\u2083\u2081 * b\u2081\u2082 + a\u2083\u2082 * b\u2082\u2082 + a\u2083\u2083 * b\u2083\u2082\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab2\u00bb.\u00ab2\u00bb\n\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2081\u2083 a\u2082\u2081 a\u2082\u2082 a\u2082\u2083 a\u2083\u2081 a\u2083\u2082 a\u2083\u2083 b\u2081\u2081 b\u2081\u2082 b\u2081\u2083 b\u2082\u2081 b\u2082\u2082 b\u2082\u2083 b\u2083\u2081 b\u2083\u2082 b\u2083\u2083 : \u03b1\n\u22a2 a\u2083\u2081 * b\u2081\u2083 + a\u2083\u2082 * b\u2082\u2083 + a\u2083\u2083 * b\u2083\u2083 = a\u2083\u2081 * b\u2081\u2083 + a\u2083\u2082 * b\u2082\u2083 + a\u2083\u2083 * b\u2083\u2083"}]}
{"declaration": "theorem vec2_eq {a\u2080 a\u2081 b\u2080 b\u2081 : \u03b1} (h\u2080 : a\u2080 = b\u2080) (h\u2081 : a\u2081 = b\u2081) : ![a\u2080, a\u2081] = ![b\u2080, b\u2081] := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[Zero \u03b1] [One \u03b1]", "[AddMonoidWithOne \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2079 : AddCommMonoid \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\na\u2080 a\u2081 b\u2080 b\u2081 : \u03b1\nh\u2080 : a\u2080 = b\u2080\nh\u2081 : a\u2081 = b\u2081\n\u22a2 ![a\u2080, a\u2081] = ![b\u2080, b\u2081]"}, {"line": "subst_vars", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2079 : AddCommMonoid \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\nb\u2080 b\u2081 : \u03b1\n\u22a2 ![b\u2080, b\u2081] = ![b\u2080, b\u2081]"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vec3_eq {a\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1} (h\u2080 : a\u2080 = b\u2080) (h\u2081 : a\u2081 = b\u2081) (h\u2082 : a\u2082 = b\u2082) :\n    ![a\u2080, a\u2081, a\u2082] = ![b\u2080, b\u2081, b\u2082] := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[Zero \u03b1] [One \u03b1]", "[AddMonoidWithOne \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2079 : AddCommMonoid \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\na\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1\nh\u2080 : a\u2080 = b\u2080\nh\u2081 : a\u2081 = b\u2081\nh\u2082 : a\u2082 = b\u2082\n\u22a2 ![a\u2080, a\u2081, a\u2082] = ![b\u2080, b\u2081, b\u2082]"}, {"line": "subst_vars", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2079 : AddCommMonoid \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\nb\u2080 b\u2081 b\u2082 : \u03b1\n\u22a2 ![b\u2080, b\u2081, b\u2082] = ![b\u2080, b\u2081, b\u2082]"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vec2_add [Add \u03b1] (a\u2080 a\u2081 b\u2080 b\u2081 : \u03b1) : ![a\u2080, a\u2081] + ![b\u2080, b\u2081] = ![a\u2080 + b\u2080, a\u2081 + b\u2081] := by\n  rw [cons_add_cons]\n  rw [cons_add_cons]\n  rw [empty_add_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[Zero \u03b1] [One \u03b1]", "[AddMonoidWithOne \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : AddMonoidWithOne \u03b1\ninst\u271d : Add \u03b1\na\u2080 a\u2081 b\u2080 b\u2081 : \u03b1\n\u22a2 ![a\u2080, a\u2081] + ![b\u2080, b\u2081] = ![a\u2080 + b\u2080, a\u2081 + b\u2081]"}, {"line": "rw [cons_add_cons]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : AddMonoidWithOne \u03b1\ninst\u271d : Add \u03b1\na\u2080 a\u2081 b\u2080 b\u2081 : \u03b1\n\u22a2 vecCons (a\u2080 + b\u2080) (![a\u2081] + ![b\u2081]) = ![a\u2080 + b\u2080, a\u2081 + b\u2081]"}, {"line": "rw [cons_add_cons]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : AddMonoidWithOne \u03b1\ninst\u271d : Add \u03b1\na\u2080 a\u2081 b\u2080 b\u2081 : \u03b1\n\u22a2 vecCons (a\u2080 + b\u2080) (vecCons (a\u2081 + b\u2081) (![] + ![])) = ![a\u2080 + b\u2080, a\u2081 + b\u2081]"}, {"line": "rw [empty_add_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vec3_add [Add \u03b1] (a\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1) :\n    ![a\u2080, a\u2081, a\u2082] + ![b\u2080, b\u2081, b\u2082] = ![a\u2080 + b\u2080, a\u2081 + b\u2081, a\u2082 + b\u2082] := by\n  rw [cons_add_cons]\n  rw [cons_add_cons]\n  rw [cons_add_cons]\n  rw [empty_add_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[Zero \u03b1] [One \u03b1]", "[AddMonoidWithOne \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : AddMonoidWithOne \u03b1\ninst\u271d : Add \u03b1\na\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1\n\u22a2 ![a\u2080, a\u2081, a\u2082] + ![b\u2080, b\u2081, b\u2082] = ![a\u2080 + b\u2080, a\u2081 + b\u2081, a\u2082 + b\u2082]"}, {"line": "rw [cons_add_cons]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : AddMonoidWithOne \u03b1\ninst\u271d : Add \u03b1\na\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1\n\u22a2 vecCons (a\u2080 + b\u2080) (![a\u2081, a\u2082] + ![b\u2081, b\u2082]) = ![a\u2080 + b\u2080, a\u2081 + b\u2081, a\u2082 + b\u2082]"}, {"line": "rw [cons_add_cons]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : AddMonoidWithOne \u03b1\ninst\u271d : Add \u03b1\na\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1\n\u22a2 vecCons (a\u2080 + b\u2080) (vecCons (a\u2081 + b\u2081) (![a\u2082] + ![b\u2082])) = ![a\u2080 + b\u2080, a\u2081 + b\u2081, a\u2082 + b\u2082]"}, {"line": "rw [cons_add_cons]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : AddMonoidWithOne \u03b1\ninst\u271d : Add \u03b1\na\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1\n\u22a2 vecCons (a\u2080 + b\u2080) (vecCons (a\u2081 + b\u2081) (vecCons (a\u2082 + b\u2082) (![] + ![]))) = ![a\u2080 + b\u2080, a\u2081 + b\u2081, a\u2082 + b\u2082]"}, {"line": "rw [empty_add_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_vec2 {R : Type*} [SMul R \u03b1] (x : R) (a\u2080 a\u2081 : \u03b1) :\n    x \u2022 ![a\u2080, a\u2081] = ![x \u2022 a\u2080, x \u2022 a\u2081] := by rw [smul_cons, smul_cons, smul_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[Zero \u03b1] [One \u03b1]", "[AddMonoidWithOne \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : AddMonoidWithOne \u03b1\nR : Type u_2\ninst\u271d : SMul R \u03b1\nx : R\na\u2080 a\u2081 : \u03b1\n\u22a2 x \u2022 ![a\u2080, a\u2081] = ![x \u2022 a\u2080, x \u2022 a\u2081]"}, {"line": "rw [smul_cons, smul_cons, smul_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_vec3 {R : Type*} [SMul R \u03b1] (x : R) (a\u2080 a\u2081 a\u2082 : \u03b1) :\n    x \u2022 ![a\u2080, a\u2081, a\u2082] = ![x \u2022 a\u2080, x \u2022 a\u2081, x \u2022 a\u2082] := by\n  rw [smul_cons]\n  rw [smul_cons]\n  rw [smul_cons]\n  rw [smul_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[Zero \u03b1] [One \u03b1]", "[AddMonoidWithOne \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : AddMonoidWithOne \u03b1\nR : Type u_2\ninst\u271d : SMul R \u03b1\nx : R\na\u2080 a\u2081 a\u2082 : \u03b1\n\u22a2 x \u2022 ![a\u2080, a\u2081, a\u2082] = ![x \u2022 a\u2080, x \u2022 a\u2081, x \u2022 a\u2082]"}, {"line": "rw [smul_cons]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : AddMonoidWithOne \u03b1\nR : Type u_2\ninst\u271d : SMul R \u03b1\nx : R\na\u2080 a\u2081 a\u2082 : \u03b1\n\u22a2 vecCons (x \u2022 a\u2080) (x \u2022 ![a\u2081, a\u2082]) = ![x \u2022 a\u2080, x \u2022 a\u2081, x \u2022 a\u2082]"}, {"line": "rw [smul_cons]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : AddMonoidWithOne \u03b1\nR : Type u_2\ninst\u271d : SMul R \u03b1\nx : R\na\u2080 a\u2081 a\u2082 : \u03b1\n\u22a2 vecCons (x \u2022 a\u2080) (vecCons (x \u2022 a\u2081) (x \u2022 ![a\u2082])) = ![x \u2022 a\u2080, x \u2022 a\u2081, x \u2022 a\u2082]"}, {"line": "rw [smul_cons]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : AddMonoidWithOne \u03b1\nR : Type u_2\ninst\u271d : SMul R \u03b1\nx : R\na\u2080 a\u2081 a\u2082 : \u03b1\n\u22a2 vecCons (x \u2022 a\u2080) (vecCons (x \u2022 a\u2081) (vecCons (x \u2022 a\u2082) (x \u2022 ![]))) = ![x \u2022 a\u2080, x \u2022 a\u2081, x \u2022 a\u2082]"}, {"line": "rw [smul_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vec2_dotProduct' {a\u2080 a\u2081 b\u2080 b\u2081 : \u03b1} : ![a\u2080, a\u2081] \u2b1d\u1d65 ![b\u2080, b\u2081] = a\u2080 * b\u2080 + a\u2081 * b\u2081 := by\n  rw [cons_dotProduct_cons]\n  rw [cons_dotProduct_cons]\n  rw [dotProduct_empty]\n  rw [add_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[Zero \u03b1] [One \u03b1]", "[AddMonoidWithOne \u03b1]", "[AddCommMonoid \u03b1] [Mul \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2080 a\u2081 b\u2080 b\u2081 : \u03b1\n\u22a2 ![a\u2080, a\u2081] \u2b1d\u1d65 ![b\u2080, b\u2081] = a\u2080 * b\u2080 + a\u2081 * b\u2081"}, {"line": "rw [cons_dotProduct_cons]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2080 a\u2081 b\u2080 b\u2081 : \u03b1\n\u22a2 a\u2080 * b\u2080 + ![a\u2081] \u2b1d\u1d65 ![b\u2081] = a\u2080 * b\u2080 + a\u2081 * b\u2081"}, {"line": "rw [cons_dotProduct_cons]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2080 a\u2081 b\u2080 b\u2081 : \u03b1\n\u22a2 a\u2080 * b\u2080 + (a\u2081 * b\u2081 + ![] \u2b1d\u1d65 ![]) = a\u2080 * b\u2080 + a\u2081 * b\u2081"}, {"line": "rw [dotProduct_empty]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2080 a\u2081 b\u2080 b\u2081 : \u03b1\n\u22a2 a\u2080 * b\u2080 + (a\u2081 * b\u2081 + 0) = a\u2080 * b\u2080 + a\u2081 * b\u2081"}, {"line": "rw [add_zero]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2080 a\u2081 b\u2080 b\u2081 : \u03b1\n\u22a2 a\u2080 * b\u2080 + a\u2081 * b\u2081 = a\u2080 * b\u2080 + a\u2081 * b\u2081"}]}
{"declaration": "theorem vec3_dotProduct' {a\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1} :\n    ![a\u2080, a\u2081, a\u2082] \u2b1d\u1d65 ![b\u2080, b\u2081, b\u2082] = a\u2080 * b\u2080 + a\u2081 * b\u2081 + a\u2082 * b\u2082 := by\n  rw [cons_dotProduct_cons]\n  rw [cons_dotProduct_cons]\n  rw [cons_dotProduct_cons]\n  rw [dotProduct_empty]\n  rw [add_zero]\n  rw [add_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Notation.lean", "context": {"open": ["Matrix", "Lean Qq", "Qq in", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr"], "variables": ["{\u03b1 : Type u} {o n m : \u2115} {m' : Type u\u2098} {n' : Type u\u2099} {o' : Type u\u2092}", "(a b : \u2115)", "[AddCommMonoid \u03b1] [Mul \u03b1]", "{\u03b9 : Type*}", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[Zero \u03b1] [One \u03b1]", "[AddMonoidWithOne \u03b1]", "[AddCommMonoid \u03b1] [Mul \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1\n\u22a2 ![a\u2080, a\u2081, a\u2082] \u2b1d\u1d65 ![b\u2080, b\u2081, b\u2082] = a\u2080 * b\u2080 + a\u2081 * b\u2081 + a\u2082 * b\u2082"}, {"line": "rw [cons_dotProduct_cons]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1\n\u22a2 a\u2080 * b\u2080 + ![a\u2081, a\u2082] \u2b1d\u1d65 ![b\u2081, b\u2082] = a\u2080 * b\u2080 + a\u2081 * b\u2081 + a\u2082 * b\u2082"}, {"line": "rw [cons_dotProduct_cons]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1\n\u22a2 a\u2080 * b\u2080 + (a\u2081 * b\u2081 + ![a\u2082] \u2b1d\u1d65 ![b\u2082]) = a\u2080 * b\u2080 + a\u2081 * b\u2081 + a\u2082 * b\u2082"}, {"line": "rw [cons_dotProduct_cons]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1\n\u22a2 a\u2080 * b\u2080 + (a\u2081 * b\u2081 + (a\u2082 * b\u2082 + ![] \u2b1d\u1d65 ![])) = a\u2080 * b\u2080 + a\u2081 * b\u2081 + a\u2082 * b\u2082"}, {"line": "rw [dotProduct_empty]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1\n\u22a2 a\u2080 * b\u2080 + (a\u2081 * b\u2081 + (a\u2082 * b\u2082 + 0)) = a\u2080 * b\u2080 + a\u2081 * b\u2081 + a\u2082 * b\u2082"}, {"line": "rw [add_zero]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1\n\u22a2 a\u2080 * b\u2080 + (a\u2081 * b\u2081 + a\u2082 * b\u2082) = a\u2080 * b\u2080 + a\u2081 * b\u2081 + a\u2082 * b\u2082"}, {"line": "rw [add_assoc]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1\n\u22a2 a\u2080 * b\u2080 + (a\u2081 * b\u2081 + a\u2082 * b\u2082) = a\u2080 * b\u2080 + (a\u2081 * b\u2081 + a\u2082 * b\u2082)"}]}
{"declaration": "theorem dotProduct\u1d63_eq [Mul \u03b1] [AddCommMonoid \u03b1] {m} (a b : Fin m \u2192 \u03b1) :\n    dotProduct\u1d63 a b = dotProduct a b := by\n  simp_rw [dotProduct\u1d63, dotProduct, FinVec.sum_eq, FinVec.seq_eq, FinVec.map_eq,\n      Function.comp_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Reflection.lean", "context": {"open": ["Matrix"], "variables": ["{l m n : \u2115} {\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : AddCommMonoid \u03b1\nm : \u2115\na b : Fin m \u2192 \u03b1\n\u22a2 dotProduct\u1d63 a b = a \u2b1d\u1d65 b"}, {"line": "simp_rw [dotProduct\u1d63, dotProduct, FinVec.sum_eq, FinVec.seq_eq, FinVec.map_eq,\n      Function.comp_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul\u1d63_eq [Mul \u03b1] [AddCommMonoid \u03b1] (A : Matrix (Fin l) (Fin m) \u03b1)\n    (B : Matrix (Fin m) (Fin n) \u03b1) : mul\u1d63 A B = A * B := by\n  simp [mul\u1d63, Function.comp, Matrix.transpose]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Reflection.lean", "context": {"open": ["Matrix"], "variables": ["{l m n : \u2115} {\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l m n : \u2115\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : AddCommMonoid \u03b1\nA : Matrix (Fin l) (Fin m) \u03b1\nB : Matrix (Fin m) (Fin n) \u03b1\n\u22a2 A.mul\u1d63 B = A * B"}, {"line": "simp [mul\u1d63, Function.comp, Matrix.transpose]", "tactic_state": "l m n : \u2115\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : AddCommMonoid \u03b1\nA : Matrix (Fin l) (Fin m) \u03b1\nB : Matrix (Fin m) (Fin n) \u03b1\n\u22a2 of ((fun v\u2081 => (fun v\u2082 => v\u2081 \u2b1d\u1d65 v\u2082) \u2218 of fun x y => B y x) \u2218 A) = A * B"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mulVec\u1d63_eq [NonUnitalNonAssocSemiring \u03b1] (A : Matrix (Fin l) (Fin m) \u03b1) (v : Fin m \u2192 \u03b1) :\n    mulVec\u1d63 A v = A *\u1d65 v := by\n  simp [mulVec\u1d63, Function.comp]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Reflection.lean", "context": {"open": ["Matrix"], "variables": ["{l m n : \u2115} {\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l m : \u2115\n\u03b1 : Type u_1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nA : Matrix (Fin l) (Fin m) \u03b1\nv : Fin m \u2192 \u03b1\n\u22a2 A.mulVec\u1d63 v = A.mulVec v"}, {"line": "simp [mulVec\u1d63, Function.comp]", "tactic_state": "l m : \u2115\n\u03b1 : Type u_1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nA : Matrix (Fin l) (Fin m) \u03b1\nv : Fin m \u2192 \u03b1\n\u22a2 (fun a => a \u2b1d\u1d65 v) \u2218 A = A.mulVec v"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vecMul\u1d63_eq [NonUnitalNonAssocSemiring \u03b1] (v : Fin l \u2192 \u03b1) (A : Matrix (Fin l) (Fin m) \u03b1) :\n    vecMul\u1d63 v A = v \u1d65* A := by\n  simp [vecMul\u1d63, Function.comp]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Reflection.lean", "context": {"open": ["Matrix"], "variables": ["{l m n : \u2115} {\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l m : \u2115\n\u03b1 : Type u_1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nv : Fin l \u2192 \u03b1\nA : Matrix (Fin l) (Fin m) \u03b1\n\u22a2 vecMul\u1d63 v A = vecMul v A"}, {"line": "simp [vecMul\u1d63, Function.comp]", "tactic_state": "l m : \u2115\n\u03b1 : Type u_1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nv : Fin l \u2192 \u03b1\nA : Matrix (Fin l) (Fin m) \u03b1\n\u22a2 (fun a => v \u2b1d\u1d65 a) \u2218 A.transpose = vecMul v A"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem etaExpand_eq {m n} (A : Matrix (Fin m) (Fin n) \u03b1) : etaExpand A = A := by\n  simp_rw [etaExpand, FinVec.etaExpand_eq, Matrix.of]\n  -- This to be in the above `simp_rw` before https://github.com/leanprover/lean4/pull/2644\n  erw [Equiv.refl_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/Reflection.lean", "context": {"open": ["Matrix"], "variables": ["{l m n : \u2115} {\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm n : \u2115\nA : Matrix (Fin m) (Fin n) \u03b1\n\u22a2 A.etaExpand = A"}, {"line": "simp_rw [etaExpand, FinVec.etaExpand_eq, Matrix.of]", "tactic_state": "\u03b1 : Type u_1\nm n : \u2115\nA : Matrix (Fin m) (Fin n) \u03b1\n\u22a2 ((Equiv.refl (Fin m \u2192 Fin n \u2192 \u03b1)) fun i j => A i j) = A"}, {"line": "erw [Equiv.refl_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem diag_replicateCol_mul_replicateRow [Mul \u03b1] [AddCommMonoid \u03b1] [Unique \u03b9] (a b : n \u2192 \u03b1) :\n    diag (replicateCol \u03b9 a * replicateRow \u03b9 b) = a * b := by\n  ext\n  simp [Matrix.mul_apply, replicateCol, replicateRow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/RowCol.lean", "context": {"open": [], "variables": ["{l m n o : Type*}", "{R : Type*} {\u03b1 : Type v} {\u03b2 : Type w}", "{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\n\u03b1 : Type v\n\u03b9 : Type u_6\nx\u271d : Sort u_7\ndiag : x\u271d\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Unique \u03b9\na b : n \u2192 \u03b1\n\u22a2 sorry = a * b"}, {"line": "ext", "tactic_state": "case h\nn : Type u_3\n\u03b1 : Type v\n\u03b9 : Type u_6\nx\u271d\u00b9 : Sort u_7\ndiag : x\u271d\u00b9\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Unique \u03b9\na b : n \u2192 \u03b1\nx\u271d : n\n\u22a2 sorry x\u271d = (a * b) x\u271d"}, {"line": "simp [Matrix.mul_apply, replicateCol, replicateRow]", "tactic_state": "case h\nn : Type u_3\n\u03b1 : Type v\n\u03b9 : Type u_6\nx\u271d\u00b9 : Sort u_7\ndiag : x\u271d\u00b9\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Unique \u03b9\na b : n \u2192 \u03b1\nx\u271d : n\n\u22a2 sorry () x\u271d = a x\u271d * b x\u271d"}]}
{"declaration": "theorem updateCol_apply [DecidableEq n] {j' : n} :\n    updateCol M j c i j' = if j' = j then c i else M i j' := by\n  by_cases h : j' = j\n  \u00b7 rw [h, updateCol_self, if_pos rfl]\n  \u00b7 rw [updateCol_ne h, if_neg h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/RowCol.lean", "context": {"open": [], "variables": ["{l m n o : Type*}", "{R : Type*} {\u03b1 : Type v} {\u03b2 : Type w}", "{\u03b9 : Type*}", "(\u03b9)", "{M : Matrix m n \u03b1} {i : m} {j : n} {b : n \u2192 \u03b1} {c : m \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\n\u03b1 : Type v\nM : Matrix m n \u03b1\ni : m\nj : n\nc : m \u2192 \u03b1\nx\u271d : Sort u_7\nupdateCol : x\u271d\ninst\u271d : DecidableEq n\nj' : n\n\u22a2 sorry = if j' = j then c i else M i j'"}, {"line": "by_cases h : j' = j", "tactic_state": "case pos\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\nM : Matrix m n \u03b1\ni : m\nj : n\nc : m \u2192 \u03b1\nx\u271d : Sort u_7\nupdateCol : x\u271d\ninst\u271d : DecidableEq n\nj' : n\nh : j' = j\n\u22a2 sorry = if j' = j then c i else M i j'\n---\ncase neg\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\nM : Matrix m n \u03b1\ni : m\nj : n\nc : m \u2192 \u03b1\nx\u271d : Sort u_7\nupdateCol : x\u271d\ninst\u271d : DecidableEq n\nj' : n\nh : \u00acj' = j\n\u22a2 sorry = if j' = j then c i else M i j'"}, {"line": "\u00b7 rw [h, updateCol_self, if_pos rfl]", "tactic_state": "case neg\nm : Type u_2\nn : Type u_3\n\u03b1 : Type v\nM : Matrix m n \u03b1\ni : m\nj : n\nc : m \u2192 \u03b1\nx\u271d : Sort u_7\nupdateCol : x\u271d\ninst\u271d : DecidableEq n\nj' : n\nh : \u00acj' = j\n\u22a2 sorry = if j' = j then c i else M i j'"}, {"line": "\u00b7 rw [updateCol_ne h, if_neg h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem updateCol_subsingleton [Subsingleton n] (A : Matrix m n R) (i : n) (b : m \u2192 R) :\n    A.updateCol i b = (replicateCol (Fin 1) b).submatrix id (Function.const n 0) := by\n  ext x y\n  simp [updateCol_apply, Subsingleton.elim i y]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/RowCol.lean", "context": {"open": [], "variables": ["{l m n o : Type*}", "{R : Type*} {\u03b1 : Type v} {\u03b2 : Type w}", "{\u03b9 : Type*}", "(\u03b9)", "{M : Matrix m n \u03b1} {i : m} {j : n} {b : n \u2192 \u03b1} {c : m \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\nR : Type u_5\nx\u271d : Sort u_7\nreplicateCol : x\u271d\ninst\u271d : Subsingleton n\nA : Matrix m n R\ni : n\nb : m \u2192 R\n\u22a2 A.updateCol i b = sorry"}, {"line": "ext x y", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\nR : Type u_5\nx\u271d : Sort u_7\nreplicateCol : x\u271d\ninst\u271d : Subsingleton n\nA : Matrix m n R\ni : n\nb : m \u2192 R\nx : m\ny : n\n\u22a2 A.updateCol i b x y = sorry x y"}, {"line": "simp [updateCol_apply, Subsingleton.elim i y]", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\nR : Type u_5\nx\u271d : Sort u_7\nreplicateCol : x\u271d\ninst\u271d : Subsingleton n\nA : Matrix m n R\ni : n\nb : m \u2192 R\nx : m\ny : n\n\u22a2 b x = sorry () x y"}]}
{"declaration": "theorem updateRow_subsingleton [Subsingleton m] (A : Matrix m n R) (i : m) (b : n \u2192 R) :\n    A.updateRow i b = (replicateRow (Fin 1) b).submatrix (Function.const m 0) id := by\n  ext x y\n  simp [updateCol_apply, Subsingleton.elim i x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matrix/RowCol.lean", "context": {"open": [], "variables": ["{l m n o : Type*}", "{R : Type*} {\u03b1 : Type v} {\u03b2 : Type w}", "{\u03b9 : Type*}", "(\u03b9)", "{M : Matrix m n \u03b1} {i : m} {j : n} {b : n \u2192 \u03b1} {c : m \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\nR : Type u_5\nx\u271d : Sort u_7\nreplicateRow : x\u271d\ninst\u271d : Subsingleton m\nA : Matrix m n R\ni : m\nb : n \u2192 R\n\u22a2 A.updateRow i b = sorry"}, {"line": "ext x y", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\nR : Type u_5\nx\u271d : Sort u_7\nreplicateRow : x\u271d\ninst\u271d : Subsingleton m\nA : Matrix m n R\ni : m\nb : n \u2192 R\nx : m\ny : n\n\u22a2 A.updateRow i b x y = sorry x y"}, {"line": "simp [updateCol_apply, Subsingleton.elim i x]", "tactic_state": "case a\nm : Type u_2\nn : Type u_3\nR : Type u_5\nx\u271d : Sort u_7\nreplicateRow : x\u271d\ninst\u271d : Subsingleton m\nA : Matrix m n R\ni : m\nb : n \u2192 R\nx : m\ny : n\n\u22a2 b y = sorry () x y"}]}
{"declaration": "theorem ground_indep_iff_eq_freeOn : M.Indep M.E \u2194 M = freeOn M.E := by\n  simp [eq_freeOn_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Constructions.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {E B I X R J : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nx\u271d : Sort u_2\nfreeOn : x\u271d\n\u22a2 M.Indep M.E \u2194 M = sorry"}, {"line": "simp [eq_freeOn_iff]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nx\u271d : Sort u_2\nfreeOn : x\u271d\n\u22a2 M.Indep M.E \u2194 M = sorry ()"}]}
{"declaration": "lemma freeOn_rankPos (hE : E.Nonempty) : RankPos (freeOn E) := by\n  simp [rankPos_iff, hE.ne_empty.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Constructions.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {E B I X R J : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Set \u03b1\nx\u271d : Sort u_2\nRankPos : x\u271d\nhE : E.Nonempty\n\u22a2 sorry"}, {"line": "simp [rankPos_iff, hE.ne_empty.symm]", "tactic_state": "\u03b1 : Type u_1\nE : Set \u03b1\nx\u271d : Sort u_2\nRankPos : x\u271d\nhE : E.Nonempty\n\u22a2 sorry ()"}]}
{"declaration": "theorem IsBase.exchange_mem {e : \u03b1}\n    (hB\u2081 : M.IsBase B\u2081) (hB\u2082 : M.IsBase B\u2082) (hxB\u2081 : e \u2208 B\u2081) (hxB\u2082 : e \u2209 B\u2082) :\n    \u2203 y, (y \u2208 B\u2082 \u2227 y \u2209 B\u2081) \u2227 M.IsBase (insert y (B\u2081 \\ {e})) := by\n  simpa using hB\u2081.exchange hB\u2082 \u27e8hxB\u2081, hxB\u2082\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB\u2081 B\u2082 : Set \u03b1\ne : \u03b1\nhB\u2081 : M.IsBase B\u2081\nhB\u2082 : M.IsBase B\u2082\nhxB\u2081 : e \u2208 B\u2081\nhxB\u2082 : e \u2209 B\u2082\n\u22a2 \u2203 y, (y \u2208 B\u2082 \u2227 y \u2209 B\u2081) \u2227 M.IsBase (insert y (B\u2081 \\ {e}))"}, {"line": "simpa using hB\u2081.exchange hB\u2082 \u27e8hxB\u2081, hxB\u2082\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsBase.ncard_diff_comm (hB\u2081 : M.IsBase B\u2081) (hB\u2082 : M.IsBase B\u2082) :\n    (B\u2081 \\ B\u2082).ncard = (B\u2082 \\ B\u2081).ncard := by\n  rw [ncard_def]\n  rw [hB\u2081.encard_diff_comm hB\u2082]\n  rw [\u2190 ncard_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB\u2081 B\u2082 : Set \u03b1\nhB\u2081 : M.IsBase B\u2081\nhB\u2082 : M.IsBase B\u2082\n\u22a2 (B\u2081 \\ B\u2082).ncard = (B\u2082 \\ B\u2081).ncard"}, {"line": "rw [ncard_def]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB\u2081 B\u2082 : Set \u03b1\nhB\u2081 : M.IsBase B\u2081\nhB\u2082 : M.IsBase B\u2082\n\u22a2 (B\u2081 \\ B\u2082).encard.toNat = (B\u2082 \\ B\u2081).ncard"}, {"line": "rw [hB\u2081.encard_diff_comm hB\u2082]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB\u2081 B\u2082 : Set \u03b1\nhB\u2081 : M.IsBase B\u2081\nhB\u2082 : M.IsBase B\u2082\n\u22a2 (B\u2082 \\ B\u2081).encard.toNat = (B\u2082 \\ B\u2081).ncard"}, {"line": "rw [\u2190 ncard_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsBase.encard_eq_encard_of_isBase (hB\u2081 : M.IsBase B\u2081) (hB\u2082 : M.IsBase B\u2082) :\n    B\u2081.encard = B\u2082.encard := by\n  rw [M.isBase_exchange.encard_isBase_eq hB\u2081 hB\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB\u2081 B\u2082 : Set \u03b1\nhB\u2081 : M.IsBase B\u2081\nhB\u2082 : M.IsBase B\u2082\n\u22a2 B\u2081.encard = B\u2082.encard"}, {"line": "rw [M.isBase_exchange.encard_isBase_eq hB\u2081 hB\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsBase.ncard_eq_ncard_of_isBase (hB\u2081 : M.IsBase B\u2081) (hB\u2082 : M.IsBase B\u2082) :\n    B\u2081.ncard = B\u2082.ncard := by\n  rw [ncard_def B\u2081]\n  rw [hB\u2081.encard_eq_encard_of_isBase hB\u2082]\n  rw [\u2190 ncard_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB\u2081 B\u2082 : Set \u03b1\nhB\u2081 : M.IsBase B\u2081\nhB\u2082 : M.IsBase B\u2082\n\u22a2 B\u2081.ncard = B\u2082.ncard"}, {"line": "rw [ncard_def B\u2081]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB\u2081 B\u2082 : Set \u03b1\nhB\u2081 : M.IsBase B\u2081\nhB\u2082 : M.IsBase B\u2082\n\u22a2 B\u2081.encard.toNat = B\u2082.ncard"}, {"line": "rw [hB\u2081.encard_eq_encard_of_isBase hB\u2082]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB\u2081 B\u2082 : Set \u03b1\nhB\u2081 : M.IsBase B\u2081\nhB\u2082 : M.IsBase B\u2082\n\u22a2 B\u2082.encard.toNat = B\u2082.ncard"}, {"line": "rw [\u2190 ncard_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ext_isBase {M\u2081 M\u2082 : Matroid \u03b1} (hE : M\u2081.E = M\u2082.E)\n    (h : \u2200 \u2983B\u2984, B \u2286 M\u2081.E \u2192 (M\u2081.IsBase B \u2194 M\u2082.IsBase B)) : M\u2081 = M\u2082 := by\n  have h' : \u2200 B, M\u2081.IsBase B \u2194 M\u2082.IsBase B :=\n    fun B \u21a6 \u27e8fun hB \u21a6 (h hB.subset_ground).1 hB,\n      fun hB \u21a6 (h <| hB.subset_ground.trans_eq hE.symm).2 hB\u27e9\n  ext <;> simp [hE, M\u2081.indep_iff', M\u2082.indep_iff', h']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM\u2081 M\u2082 : Matroid \u03b1\nhE : M\u2081.E = M\u2082.E\nh : \u2200 \u2983B : Set \u03b1\u2984, B \u2286 M\u2081.E \u2192 (M\u2081.IsBase B \u2194 M\u2082.IsBase B)\n\u22a2 M\u2081 = M\u2082"}, {"line": "have h' : \u2200 B, M\u2081.IsBase B \u2194 M\u2082.IsBase B :=\n    fun B \u21a6 \u27e8fun hB \u21a6 (h hB.subset_ground).1 hB,\n      fun hB \u21a6 (h <| hB.subset_ground.trans_eq hE.symm).2 hB\u27e9", "tactic_state": "\u03b1 : Type u_1\nM\u2081 M\u2082 : Matroid \u03b1\nhE : M\u2081.E = M\u2082.E\nh : \u2200 \u2983B : Set \u03b1\u2984, B \u2286 M\u2081.E \u2192 (M\u2081.IsBase B \u2194 M\u2082.IsBase B)\nh' : \u2200 (B : Set \u03b1), M\u2081.IsBase B \u2194 M\u2082.IsBase B\n\u22a2 M\u2081 = M\u2082"}, {"line": "ext <;> simp [hE, M\u2081.indep_iff', M\u2082.indep_iff', h']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Indep.subset_ground (hI : M.Indep I) : I \u2286 M.E := by\n  obtain \u27e8B, hB, hIB\u27e9 := hI.exists_isBase_superset\n  exact hIB.trans hB.subset_ground\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\nhI : M.Indep I\n\u22a2 I \u2286 M.E"}, {"line": "obtain \u27e8B, hB, hIB\u27e9 := hI.exists_isBase_superset", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\nhI : M.Indep I\nB : Set \u03b1\nhB : M.IsBase B\nhIB : I \u2286 B\n\u22a2 I \u2286 M.E"}, {"line": "exact hIB.trans hB.subset_ground", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Indep.subset (hJ : M.Indep J) (hIJ : I \u2286 J) : M.Indep I := by\n  obtain \u27e8B, hB, hJB\u27e9 := hJ.exists_isBase_superset\n  exact indep_iff.2 \u27e8B, hB, hIJ.trans hJB\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI J : Set \u03b1\nhJ : M.Indep J\nhIJ : I \u2286 J\n\u22a2 M.Indep I"}, {"line": "obtain \u27e8B, hB, hJB\u27e9 := hJ.exists_isBase_superset", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI J : Set \u03b1\nhJ : M.Indep J\nhIJ : I \u2286 J\nB : Set \u03b1\nhB : M.IsBase B\nhJB : J \u2286 B\n\u22a2 M.Indep I"}, {"line": "exact indep_iff.2 \u27e8B, hB, hIJ.trans hJB\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Indep.rankPos_of_nonempty (hI : M.Indep I) (hne : I.Nonempty) : M.RankPos := by\n  obtain \u27e8B, hB, hIB\u27e9 := hI.exists_isBase_superset\n  exact hB.rankPos_of_nonempty (hne.mono hIB)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\nhI : M.Indep I\nhne : I.Nonempty\n\u22a2 M.RankPos"}, {"line": "obtain \u27e8B, hB, hIB\u27e9 := hI.exists_isBase_superset", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\nhI : M.Indep I\nhne : I.Nonempty\nB : Set \u03b1\nhB : M.IsBase B\nhIB : I \u2286 B\n\u22a2 M.RankPos"}, {"line": "exact hB.rankPos_of_nonempty (hne.mono hIB)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isBase_iff_maximal_indep : M.IsBase B \u2194 Maximal M.Indep B := by\n  rw [maximal_subset_iff]\n  refine \u27e8fun h \u21a6 \u27e8h.indep, fun _ \u21a6 h.eq_of_subset_indep\u27e9, fun \u27e8h, h'\u27e9 \u21a6 ?_\u27e9\n  obtain \u27e8B', hB', hBB'\u27e9 := h.exists_isBase_superset\n  rwa [h' hB'.indep hBB']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\n\u22a2 M.IsBase B \u2194 Maximal M.Indep B"}, {"line": "rw [maximal_subset_iff]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\n\u22a2 M.IsBase B \u2194 M.Indep B \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2192 B \u2286 t \u2192 B = t"}, {"line": "refine \u27e8fun h \u21a6 \u27e8h.indep, fun _ \u21a6 h.eq_of_subset_indep\u27e9, fun \u27e8h, h'\u27e9 \u21a6 ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\nx\u271d : M.Indep B \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2192 B \u2286 t \u2192 B = t\nh : M.Indep B\nh' : \u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2192 B \u2286 t \u2192 B = t\n\u22a2 M.IsBase B"}, {"line": "obtain \u27e8B', hB', hBB'\u27e9 := h.exists_isBase_superset", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\nx\u271d : M.Indep B \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2192 B \u2286 t \u2192 B = t\nh : M.Indep B\nh' : \u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2192 B \u2286 t \u2192 B = t\nB' : Set \u03b1\nhB' : M.IsBase B'\nhBB' : B \u2286 B'\n\u22a2 M.IsBase B"}, {"line": "rwa [h' hB'.indep hBB']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsBase.eq_exchange_of_diff_eq_singleton (hB : M.IsBase B) (hB' : M.IsBase B')\n    (h : B \\ B' = {e}) : \u2203 f \u2208 B' \\ B, B' = (insert f B) \\ {e} := by\n  obtain \u27e8f, hf, hb\u27e9 := hB.exchange hB' (h.symm.subset (mem_singleton e))\n  have hne : f \u2260 e := by rintro rfl; exact hf.2 (h.symm.subset (mem_singleton f)).1\n  rw [insert_diff_singleton_comm hne] at hb\n  refine \u27e8f, hf, (hb.eq_of_subset_isBase hB' ?_).symm\u27e9\n  rw [diff_subset_iff]\n  rw [insert_subset_iff]\n  rw [union_comm]\n  rw [\u2190 diff_subset_iff]\n  rw [h]\n  rw [and_iff_left rfl.subset]\n  exact Or.inl hf.1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB B' : Set \u03b1\ne : \u03b1\nhB : M.IsBase B\nhB' : M.IsBase B'\nh : B \\ B' = {e}\n\u22a2 \u2203 f \u2208 B' \\ B, B' = insert f B \\ {e}"}, {"line": "obtain \u27e8f, hf, hb\u27e9 := hB.exchange hB' (h.symm.subset (mem_singleton e))", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB B' : Set \u03b1\ne : \u03b1\nhB : M.IsBase B\nhB' : M.IsBase B'\nh : B \\ B' = {e}\nf : \u03b1\nhf : f \u2208 B' \\ B\nhb : M.IsBase (insert f (B \\ {e}))\n\u22a2 \u2203 f \u2208 B' \\ B, B' = insert f B \\ {e}"}, {"line": "have hne : f \u2260 e := sorry", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB B' : Set \u03b1\ne : \u03b1\nhB : M.IsBase B\nhB' : M.IsBase B'\nh : B \\ B' = {e}\nf : \u03b1\nhf : f \u2208 B' \\ B\nhb : M.IsBase (insert f (B \\ {e}))\nhne : f \u2260 e\n\u22a2 \u2203 f \u2208 B' \\ B, B' = insert f B \\ {e}"}, {"line": "rw [insert_diff_singleton_comm hne] at hb", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB B' : Set \u03b1\ne : \u03b1\nhB : M.IsBase B\nhB' : M.IsBase B'\nh : B \\ B' = {e}\nf : \u03b1\nhf : f \u2208 B' \\ B\nhb : M.IsBase (insert f B \\ {e})\nhne : f \u2260 e\n\u22a2 \u2203 f \u2208 B' \\ B, B' = insert f B \\ {e}"}, {"line": "refine \u27e8f, hf, (hb.eq_of_subset_isBase hB' ?_).symm\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB B' : Set \u03b1\ne : \u03b1\nhB : M.IsBase B\nhB' : M.IsBase B'\nh : B \\ B' = {e}\nf : \u03b1\nhf : f \u2208 B' \\ B\nhb : M.IsBase (insert f B \\ {e})\nhne : f \u2260 e\n\u22a2 insert f B \\ {e} \u2286 B'"}, {"line": "rw [diff_subset_iff]", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB B' : Set \u03b1\ne : \u03b1\nhB : M.IsBase B\nhB' : M.IsBase B'\nh : B \\ B' = {e}\nf : \u03b1\nhf : f \u2208 B' \\ B\nhb : M.IsBase (insert f B \\ {e})\nhne : f \u2260 e\n\u22a2 insert f B \u2286 {e} \u222a B'"}, {"line": "rw [insert_subset_iff]", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB B' : Set \u03b1\ne : \u03b1\nhB : M.IsBase B\nhB' : M.IsBase B'\nh : B \\ B' = {e}\nf : \u03b1\nhf : f \u2208 B' \\ B\nhb : M.IsBase (insert f B \\ {e})\nhne : f \u2260 e\n\u22a2 f \u2208 {e} \u222a B' \u2227 B \u2286 {e} \u222a B'"}, {"line": "rw [union_comm]", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB B' : Set \u03b1\ne : \u03b1\nhB : M.IsBase B\nhB' : M.IsBase B'\nh : B \\ B' = {e}\nf : \u03b1\nhf : f \u2208 B' \\ B\nhb : M.IsBase (insert f B \\ {e})\nhne : f \u2260 e\n\u22a2 f \u2208 B' \u222a {e} \u2227 B \u2286 B' \u222a {e}"}, {"line": "rw [\u2190 diff_subset_iff]", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB B' : Set \u03b1\ne : \u03b1\nhB : M.IsBase B\nhB' : M.IsBase B'\nh : B \\ B' = {e}\nf : \u03b1\nhf : f \u2208 B' \\ B\nhb : M.IsBase (insert f B \\ {e})\nhne : f \u2260 e\n\u22a2 f \u2208 B' \u222a {e} \u2227 B \\ B' \u2286 {e}"}, {"line": "rw [h]", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB B' : Set \u03b1\ne : \u03b1\nhB : M.IsBase B\nhB' : M.IsBase B'\nh : B \\ B' = {e}\nf : \u03b1\nhf : f \u2208 B' \\ B\nhb : M.IsBase (insert f B \\ {e})\nhne : f \u2260 e\n\u22a2 f \u2208 B' \u222a {e} \u2227 {e} \u2286 {e}"}, {"line": "rw [and_iff_left rfl.subset]", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB B' : Set \u03b1\ne : \u03b1\nhB : M.IsBase B\nhB' : M.IsBase B'\nh : B \\ B' = {e}\nf : \u03b1\nhf : f \u2208 B' \\ B\nhb : M.IsBase (insert f B \\ {e})\nhne : f \u2260 e\n\u22a2 f \u2208 B' \u222a {e}"}, {"line": "exact Or.inl hf.1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsBase.exchange_isBase_of_indep' (hB : M.IsBase B) (he : e \u2208 B) (hf : f \u2209 B)\n    (hI : M.Indep (insert f B \\ {e})) : M.IsBase (insert f B \\ {e}) := by\n  have hfe : f \u2260 e := ne_of_mem_of_not_mem he hf |>.symm\n  rw [\u2190 insert_diff_singleton_comm hfe] at *\n  exact hB.exchange_isBase_of_indep hf hI\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\ne f : \u03b1\nhB : M.IsBase B\nhe : e \u2208 B\nhf : f \u2209 B\nhI : M.Indep (insert f B \\ {e})\n\u22a2 M.IsBase (insert f B \\ {e})"}, {"line": "have hfe : f \u2260 e := ne_of_mem_of_not_mem he hf |>.symm", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\ne f : \u03b1\nhB : M.IsBase B\nhe : e \u2208 B\nhf : f \u2209 B\nhI : M.Indep (insert f B \\ {e})\nhfe : f \u2260 e\n\u22a2 M.IsBase (insert f B \\ {e})"}, {"line": "rw [\u2190 insert_diff_singleton_comm hfe] at *", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\ne f : \u03b1\nhB : M.IsBase B\nhe : e \u2208 B\nhf : f \u2209 B\nhI : M.Indep (insert f (B \\ {e}))\nhfe : f \u2260 e\n\u22a2 M.IsBase (insert f (B \\ {e}))"}, {"line": "exact hB.exchange_isBase_of_indep hf hI", "tactic_state": "No Goals!"}]}
{"declaration": "lemma insert_isBase_of_insert_indep {M : Matroid \u03b1} {I : Set \u03b1} {e f : \u03b1}\n    (he : e \u2209 I) (hf : f \u2209 I) (heI : M.IsBase (insert e I)) (hfI : M.Indep (insert f I)) :\n    M.IsBase (insert f I) := by\n  obtain rfl | hef := eq_or_ne e f\n  \u00b7 assumption\n  simpa [diff_singleton_eq_self he, hfI]\n    using heI.exchange_isBase_of_indep (e := e) (f := f) (by simp [hef.symm, hf])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\ne f : \u03b1\nhe : e \u2209 I\nhf : f \u2209 I\nheI : M.IsBase (insert e I)\nhfI : M.Indep (insert f I)\n\u22a2 M.IsBase (insert f I)"}, {"line": "obtain rfl | hef := eq_or_ne e f", "tactic_state": "case inl\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\ne : \u03b1\nhe : e \u2209 I\nheI : M.IsBase (insert e I)\nhf : e \u2209 I\nhfI : M.Indep (insert e I)\n\u22a2 M.IsBase (insert e I)\n---\ncase inr\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\ne f : \u03b1\nhe : e \u2209 I\nhf : f \u2209 I\nheI : M.IsBase (insert e I)\nhfI : M.Indep (insert f I)\nhef : e \u2260 f\n\u22a2 M.IsBase (insert f I)"}, {"line": "\u00b7 assumption", "tactic_state": "case inr\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\ne f : \u03b1\nhe : e \u2209 I\nhf : f \u2209 I\nheI : M.IsBase (insert e I)\nhfI : M.Indep (insert f I)\nhef : e \u2260 f\n\u22a2 M.IsBase (insert f I)"}, {"line": "simpa [diff_singleton_eq_self he, hfI]\n    using heI.exchange_isBase_of_indep (e := e) (f := f) (by simp [hef.symm, hf])", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Indep.exists_insert_of_not_isBase (hI : M.Indep I) (hI' : \u00acM.IsBase I) (hB : M.IsBase B) :\n    \u2203 e \u2208 B \\ I, M.Indep (insert e I) := by\n  obtain \u27e8B', hB', hIB'\u27e9 := hI.exists_isBase_superset\n  obtain \u27e8x, hxB', hx\u27e9 := exists_of_ssubset (hIB'.ssubset_of_ne (by (rintro rfl; exact hI' hB')))\n  by_cases hxB : x \u2208 B\n  \u00b7 exact \u27e8x, \u27e8hxB, hx\u27e9, hB'.indep.subset (insert_subset hxB' hIB')\u27e9\n  obtain \u27e8e,he, hBase\u27e9 := hB'.exchange hB \u27e8hxB',hxB\u27e9\n  exact \u27e8e, \u27e8he.1, not_mem_subset hIB' he.2\u27e9,\n    indep_iff.2 \u27e8_, hBase, insert_subset_insert (subset_diff_singleton hIB' hx)\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB I : Set \u03b1\nhI : M.Indep I\nhI' : \u00acM.IsBase I\nhB : M.IsBase B\n\u22a2 \u2203 e \u2208 B \\ I, M.Indep (insert e I)"}, {"line": "obtain \u27e8B', hB', hIB'\u27e9 := hI.exists_isBase_superset", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB I : Set \u03b1\nhI : M.Indep I\nhI' : \u00acM.IsBase I\nhB : M.IsBase B\nB' : Set \u03b1\nhB' : M.IsBase B'\nhIB' : I \u2286 B'\n\u22a2 \u2203 e \u2208 B \\ I, M.Indep (insert e I)"}, {"line": "obtain \u27e8x, hxB', hx\u27e9 := exists_of_ssubset (hIB'.ssubset_of_ne (by (rintro rfl; exact hI' hB')))", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB I : Set \u03b1\nhI : M.Indep I\nhI' : \u00acM.IsBase I\nhB : M.IsBase B\nB' : Set \u03b1\nhB' : M.IsBase B'\nhIB' : I \u2286 B'\nx : \u03b1\nhxB' : x \u2208 B'\nhx : x \u2209 I\n\u22a2 \u2203 e \u2208 B \\ I, M.Indep (insert e I)"}, {"line": "by_cases hxB : x \u2208 B", "tactic_state": "case pos\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB I : Set \u03b1\nhI : M.Indep I\nhI' : \u00acM.IsBase I\nhB : M.IsBase B\nB' : Set \u03b1\nhB' : M.IsBase B'\nhIB' : I \u2286 B'\nx : \u03b1\nhxB' : x \u2208 B'\nhx : x \u2209 I\nhxB : x \u2208 B\n\u22a2 \u2203 e \u2208 B \\ I, M.Indep (insert e I)\n---\ncase neg\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB I : Set \u03b1\nhI : M.Indep I\nhI' : \u00acM.IsBase I\nhB : M.IsBase B\nB' : Set \u03b1\nhB' : M.IsBase B'\nhIB' : I \u2286 B'\nx : \u03b1\nhxB' : x \u2208 B'\nhx : x \u2209 I\nhxB : x \u2209 B\n\u22a2 \u2203 e \u2208 B \\ I, M.Indep (insert e I)"}, {"line": "\u00b7 exact \u27e8x, \u27e8hxB, hx\u27e9, hB'.indep.subset (insert_subset hxB' hIB')\u27e9", "tactic_state": "case neg\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB I : Set \u03b1\nhI : M.Indep I\nhI' : \u00acM.IsBase I\nhB : M.IsBase B\nB' : Set \u03b1\nhB' : M.IsBase B'\nhIB' : I \u2286 B'\nx : \u03b1\nhxB' : x \u2208 B'\nhx : x \u2209 I\nhxB : x \u2209 B\n\u22a2 \u2203 e \u2208 B \\ I, M.Indep (insert e I)"}, {"line": "obtain \u27e8e,he, hBase\u27e9 := hB'.exchange hB \u27e8hxB',hxB\u27e9", "tactic_state": "case neg.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB I : Set \u03b1\nhI : M.Indep I\nhI' : \u00acM.IsBase I\nhB : M.IsBase B\nB' : Set \u03b1\nhB' : M.IsBase B'\nhIB' : I \u2286 B'\nx : \u03b1\nhxB' : x \u2208 B'\nhx : x \u2209 I\nhxB : x \u2209 B\ne : \u03b1\nhe : e \u2208 B \\ B'\nhBase : M.IsBase (insert e (B' \\ {x}))\n\u22a2 \u2203 e \u2208 B \\ I, M.Indep (insert e I)"}, {"line": "exact \u27e8e, \u27e8he.1, not_mem_subset hIB' he.2\u27e9,\n    indep_iff.2 \u27e8_, hBase, insert_subset_insert (subset_diff_singleton hIB' hx)\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Indep.exists_insert_of_not_maximal (M : Matroid \u03b1) \u2983I B : Set \u03b1\u2984 (hI : M.Indep I)\n    (hInotmax : \u00ac Maximal M.Indep I) (hB : Maximal M.Indep B) :\n    \u2203 x \u2208 B \\ I, M.Indep (insert x I) := by\n  simp only [maximal_subset_iff] at hB hInotmax\n  simp only [hI] at hB hInotmax\n  simp only [not_and] at hB hInotmax\n  simp only [not_forall] at hB hInotmax\n  simp only [exists_prop] at hB hInotmax\n  simp only [true_imp_iff] at hB hInotmax\n  refine hI.exists_insert_of_not_isBase (fun hIb \u21a6 ?_) ?_\n  \u00b7 obtain \u27e8I', hII', hI', hne\u27e9 := hInotmax\n    exact hne <| hIb.eq_of_subset_indep hII' hI'\n  exact hB.1.isBase_of_maximal fun J hJ hBJ \u21a6 hB.2 hJ hBJ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI B : Set \u03b1\nhI : M.Indep I\nhInotmax : \u00acMaximal M.Indep I\nhB : Maximal M.Indep B\n\u22a2 \u2203 x \u2208 B \\ I, M.Indep (insert x I)"}, {"line": "simp only [maximal_subset_iff] at hB hInotmax", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI B : Set \u03b1\nhI : M.Indep I\nhB : M.Indep B \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2192 B \u2286 t \u2192 B = t\nhInotmax : \u00ac(M.Indep I \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2192 I \u2286 t \u2192 I = t)\n\u22a2 \u2203 x \u2208 B \\ I, M.Indep (insert x I)"}, {"line": "simp only [hI] at hB hInotmax", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI B : Set \u03b1\nhI : M.Indep I\nhB : M.Indep B \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2192 B \u2286 t \u2192 B = t\nhInotmax : \u00ac(True \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2192 I \u2286 t \u2192 I = t)\n\u22a2 \u2203 x \u2208 B \\ I, M.Indep (insert x I)"}, {"line": "simp only [not_and] at hB hInotmax", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI B : Set \u03b1\nhI : M.Indep I\nhB : M.Indep B \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2192 B \u2286 t \u2192 B = t\nhInotmax : True \u2192 \u00ac\u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2192 I \u2286 t \u2192 I = t\n\u22a2 \u2203 x \u2208 B \\ I, M.Indep (insert x I)"}, {"line": "simp only [not_forall] at hB hInotmax", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI B : Set \u03b1\nhI : M.Indep I\nhB : M.Indep B \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2192 B \u2286 t \u2192 B = t\nhInotmax : True \u2192 \u2203 x, \u2203 (_ : M.Indep x) (_ : I \u2286 x), \u00acI = x\n\u22a2 \u2203 x \u2208 B \\ I, M.Indep (insert x I)"}, {"line": "simp only [exists_prop] at hB hInotmax", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI B : Set \u03b1\nhI : M.Indep I\nhB : M.Indep B \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2192 B \u2286 t \u2192 B = t\nhInotmax : True \u2192 \u2203 x, M.Indep x \u2227 I \u2286 x \u2227 \u00acI = x\n\u22a2 \u2203 x \u2208 B \\ I, M.Indep (insert x I)"}, {"line": "simp only [true_imp_iff] at hB hInotmax", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI B : Set \u03b1\nhI : M.Indep I\nhB : M.Indep B \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2192 B \u2286 t \u2192 B = t\nhInotmax : \u2203 x, M.Indep x \u2227 I \u2286 x \u2227 \u00acI = x\n\u22a2 \u2203 x \u2208 B \\ I, M.Indep (insert x I)"}, {"line": "refine hI.exists_insert_of_not_isBase (fun hIb \u21a6 ?_) ?_", "tactic_state": "case refine_1\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI B : Set \u03b1\nhI : M.Indep I\nhB : M.Indep B \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2192 B \u2286 t \u2192 B = t\nhInotmax : \u2203 x, M.Indep x \u2227 I \u2286 x \u2227 \u00acI = x\nhIb : M.IsBase I\n\u22a2 False\n---\ncase refine_2\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI B : Set \u03b1\nhI : M.Indep I\nhB : M.Indep B \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2192 B \u2286 t \u2192 B = t\nhInotmax : \u2203 x, M.Indep x \u2227 I \u2286 x \u2227 \u00acI = x\n\u22a2 M.IsBase B"}, {"line": "\u00b7 obtain \u27e8I', hII', hI', hne\u27e9 := hInotmax\n    exact hne <| hIb.eq_of_subset_indep hII' hI'", "tactic_state": "case refine_2\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI B : Set \u03b1\nhI : M.Indep I\nhB : M.Indep B \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2192 B \u2286 t \u2192 B = t\nhInotmax : \u2203 x, M.Indep x \u2227 I \u2286 x \u2227 \u00acI = x\n\u22a2 M.IsBase B"}, {"line": "exact hB.1.isBase_of_maximal fun J hJ hBJ \u21a6 hB.2 hJ hBJ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Indep.isBase_of_forall_insert (hB : M.Indep B)\n    (hBmax : \u2200 e \u2208 M.E \\ B, \u00ac M.Indep (insert e B)) : M.IsBase B := by\n  refine by_contra fun hnb \u21a6 ?_\n  obtain \u27e8B', hB'\u27e9 := M.exists_isBase\n  obtain \u27e8e, he, h\u27e9 := hB.exists_insert_of_not_isBase hnb hB'\n  exact hBmax e \u27e8hB'.subset_ground he.1, he.2\u27e9 h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\nhB : M.Indep B\nhBmax : \u2200 e \u2208 M.E \\ B, \u00acM.Indep (insert e B)\n\u22a2 M.IsBase B"}, {"line": "refine by_contra fun hnb \u21a6 ?_", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\nhB : M.Indep B\nhBmax : \u2200 e \u2208 M.E \\ B, \u00acM.Indep (insert e B)\nhnb : \u00acM.IsBase B\n\u22a2 False"}, {"line": "obtain \u27e8B', hB'\u27e9 := M.exists_isBase", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\nhB : M.Indep B\nhBmax : \u2200 e \u2208 M.E \\ B, \u00acM.Indep (insert e B)\nhnb : \u00acM.IsBase B\nB' : Set \u03b1\nhB' : M.IsBase B'\n\u22a2 False"}, {"line": "obtain \u27e8e, he, h\u27e9 := hB.exists_insert_of_not_isBase hnb hB'", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\nhB : M.Indep B\nhBmax : \u2200 e \u2208 M.E \\ B, \u00acM.Indep (insert e B)\nhnb : \u00acM.IsBase B\nB' : Set \u03b1\nhB' : M.IsBase B'\ne : \u03b1\nhe : e \u2208 B' \\ B\nh : M.Indep (insert e B)\n\u22a2 False"}, {"line": "exact hBmax e \u27e8hB'.subset_ground he.1, he.2\u27e9 h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsBasis.isBasis_inter_ground (hI : M.IsBasis I X) : M.IsBasis I (X \u2229 M.E) := by\n  convert hI\n  rw [inter_eq_self_of_subset_left hI.subset_ground]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}", "{B I J X Y : Set \u03b1} {e : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\nhI : M.IsBasis I X\n\u22a2 M.IsBasis I (X \u2229 M.E)"}, {"line": "convert hI", "tactic_state": "case h.e'_4\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\nhI : M.IsBasis I X\n\u22a2 X \u2229 M.E = X"}, {"line": "rw [inter_eq_self_of_subset_left hI.subset_ground]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsBasis.iUnion_isBasis_iUnion {\u03b9 : Type _} (X I : \u03b9 \u2192 Set \u03b1)\n    (hI : \u2200 i, M.IsBasis (I i) (X i)) (h_ind : M.Indep (\u22c3 i, I i)) :\n    M.IsBasis (\u22c3 i, I i) (\u22c3 i, X i) := by\n  refine h_ind.isBasis_of_forall_insert\n    (iUnion_subset (fun i \u21a6 (hI i).subset.trans (subset_iUnion _ _))) ?_\n  rintro e \u27e8\u27e8_, \u27e8\u27e8i, hi, rfl\u27e9, (hes : e \u2208 X i)\u27e9\u27e9, he'\u27e9\n  rw [mem_iUnion] at he'\n  rw [not_exists] at he'\n  refine ((hI i).insert_dep \u27e8hes, he' _\u27e9).superset (insert_subset_insert (subset_iUnion _ _)) ?_\n  rw [insert_subset_iff]\n  rw [iUnion_subset_iff]\n  rw [and_iff_left (fun i \u21a6 (hI i).indep.subset_ground)]\n  exact (hI i).subset_ground hes\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}", "{B I J X Y : Set \u03b1} {e : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\n\u03b9 : Type u_2\nX I : \u03b9 \u2192 Set \u03b1\nhI : \u2200 (i : \u03b9), M.IsBasis (I i) (X i)\nh_ind : M.Indep (\u22c3 i, I i)\n\u22a2 M.IsBasis (\u22c3 i, I i) (\u22c3 i, X i)"}, {"line": "refine h_ind.isBasis_of_forall_insert\n    (iUnion_subset (fun i \u21a6 (hI i).subset.trans (subset_iUnion _ _))) ?_", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\n\u03b9 : Type u_2\nX I : \u03b9 \u2192 Set \u03b1\nhI : \u2200 (i : \u03b9), M.IsBasis (I i) (X i)\nh_ind : M.Indep (\u22c3 i, I i)\n\u22a2 \u2200 e \u2208 (\u22c3 i, X i) \\ \u22c3 i, I i, M.Dep (insert e (\u22c3 i, I i))"}, {"line": "rintro e \u27e8\u27e8_, \u27e8\u27e8i, hi, rfl\u27e9, (hes : e \u2208 X i)\u27e9\u27e9, he'\u27e9", "tactic_state": "case intro.intro.intro.intro.refl\n\u03b1 : Type u_1\nM : Matroid \u03b1\n\u03b9 : Type u_2\nX I : \u03b9 \u2192 Set \u03b1\nhI : \u2200 (i : \u03b9), M.IsBasis (I i) (X i)\nh_ind : M.Indep (\u22c3 i, I i)\ne : \u03b1\nhe' : e \u2209 \u22c3 i, I i\ni : \u03b9\nhes : e \u2208 X i\n\u22a2 M.Dep (insert e (\u22c3 i, I i))"}, {"line": "rw [mem_iUnion] at he'", "tactic_state": "case intro.intro.intro.intro.refl\n\u03b1 : Type u_1\nM : Matroid \u03b1\n\u03b9 : Type u_2\nX I : \u03b9 \u2192 Set \u03b1\nhI : \u2200 (i : \u03b9), M.IsBasis (I i) (X i)\nh_ind : M.Indep (\u22c3 i, I i)\ne : \u03b1\nhe' : \u00ac\u2203 i, e \u2208 I i\ni : \u03b9\nhes : e \u2208 X i\n\u22a2 M.Dep (insert e (\u22c3 i, I i))"}, {"line": "rw [not_exists] at he'", "tactic_state": "case intro.intro.intro.intro.refl\n\u03b1 : Type u_1\nM : Matroid \u03b1\n\u03b9 : Type u_2\nX I : \u03b9 \u2192 Set \u03b1\nhI : \u2200 (i : \u03b9), M.IsBasis (I i) (X i)\nh_ind : M.Indep (\u22c3 i, I i)\ne : \u03b1\nhe' : \u2200 (x : \u03b9), e \u2209 I x\ni : \u03b9\nhes : e \u2208 X i\n\u22a2 M.Dep (insert e (\u22c3 i, I i))"}, {"line": "refine ((hI i).insert_dep \u27e8hes, he' _\u27e9).superset (insert_subset_insert (subset_iUnion _ _)) ?_", "tactic_state": "case intro.intro.intro.intro.refl\n\u03b1 : Type u_1\nM : Matroid \u03b1\n\u03b9 : Type u_2\nX I : \u03b9 \u2192 Set \u03b1\nhI : \u2200 (i : \u03b9), M.IsBasis (I i) (X i)\nh_ind : M.Indep (\u22c3 i, I i)\ne : \u03b1\nhe' : \u2200 (x : \u03b9), e \u2209 I x\ni : \u03b9\nhes : e \u2208 X i\n\u22a2 insert e (\u22c3 i, I i) \u2286 M.E"}, {"line": "rw [insert_subset_iff]", "tactic_state": "case intro.intro.intro.intro.refl\n\u03b1 : Type u_1\nM : Matroid \u03b1\n\u03b9 : Type u_2\nX I : \u03b9 \u2192 Set \u03b1\nhI : \u2200 (i : \u03b9), M.IsBasis (I i) (X i)\nh_ind : M.Indep (\u22c3 i, I i)\ne : \u03b1\nhe' : \u2200 (x : \u03b9), e \u2209 I x\ni : \u03b9\nhes : e \u2208 X i\n\u22a2 e \u2208 M.E \u2227 \u22c3 i, I i \u2286 M.E"}, {"line": "rw [iUnion_subset_iff]", "tactic_state": "case intro.intro.intro.intro.refl\n\u03b1 : Type u_1\nM : Matroid \u03b1\n\u03b9 : Type u_2\nX I : \u03b9 \u2192 Set \u03b1\nhI : \u2200 (i : \u03b9), M.IsBasis (I i) (X i)\nh_ind : M.Indep (\u22c3 i, I i)\ne : \u03b1\nhe' : \u2200 (x : \u03b9), e \u2209 I x\ni : \u03b9\nhes : e \u2208 X i\n\u22a2 e \u2208 M.E \u2227 \u2200 (i : \u03b9), I i \u2286 M.E"}, {"line": "rw [and_iff_left (fun i \u21a6 (hI i).indep.subset_ground)]", "tactic_state": "case intro.intro.intro.intro.refl\n\u03b1 : Type u_1\nM : Matroid \u03b1\n\u03b9 : Type u_2\nX I : \u03b9 \u2192 Set \u03b1\nhI : \u2200 (i : \u03b9), M.IsBasis (I i) (X i)\nh_ind : M.Indep (\u22c3 i, I i)\ne : \u03b1\nhe' : \u2200 (x : \u03b9), e \u2209 I x\ni : \u03b9\nhes : e \u2208 X i\n\u22a2 e \u2208 M.E"}, {"line": "exact (hI i).subset_ground hes", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsBasis.isBasis_sUnion {Xs : Set (Set \u03b1)} (hne : Xs.Nonempty)\n    (h : \u2200 X \u2208 Xs, M.IsBasis I X) : M.IsBasis I (\u22c3\u2080 Xs) := by\n  rw [sUnion_eq_iUnion]\n  have := Iff.mpr nonempty_coe_sort hne\n  exact IsBasis.isBasis_iUnion _ fun X \u21a6 h X X.prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}", "{B I J X Y : Set \u03b1} {e : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\nXs : Set (Set \u03b1)\nhne : Xs.Nonempty\nh : \u2200 X \u2208 Xs, M.IsBasis I X\n\u22a2 M.IsBasis I (\u22c3\u2080 Xs)"}, {"line": "rw [sUnion_eq_iUnion]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\nXs : Set (Set \u03b1)\nhne : Xs.Nonempty\nh : \u2200 X \u2208 Xs, M.IsBasis I X\n\u22a2 M.IsBasis I (\u22c3 i, \u2191i)"}, {"line": "have := Iff.mpr nonempty_coe_sort hne", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\nXs : Set (Set \u03b1)\nhne : Xs.Nonempty\nh : \u2200 X \u2208 Xs, M.IsBasis I X\nthis : Nonempty \u2191Xs\n\u22a2 M.IsBasis I (\u22c3 i, \u2191i)"}, {"line": "exact IsBasis.isBasis_iUnion _ fun X \u21a6 h X X.prop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Indep.isBasis_setOf_insert_isBasis (hI : M.Indep I) :\n    M.IsBasis I {x | M.IsBasis I (insert x I)} := by\n  refine hI.isBasis_of_forall_insert (fun e he \u21a6 (?_ : M.IsBasis _ _))\n    (fun e he \u21a6 \u27e8fun hu \u21a6 he.2 ?_, he.1.subset_ground\u27e9)\n  \u00b7 rw [insert_eq_of_mem he]; exact hI.isBasis_self\n  simpa using (hu.eq_of_isBasis he.1).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}", "{B I J X Y : Set \u03b1} {e : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\nhI : M.Indep I\n\u22a2 M.IsBasis I {x | M.IsBasis I (insert x I)}"}, {"line": "refine hI.isBasis_of_forall_insert (fun e he \u21a6 (?_ : M.IsBasis _ _))\n    (fun e he \u21a6 \u27e8fun hu \u21a6 he.2 ?_, he.1.subset_ground\u27e9)", "tactic_state": "case refine_1\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\nhI : M.Indep I\ne : \u03b1\nhe : e \u2208 I\n\u22a2 M.IsBasis I (insert e I)\n---\ncase refine_2\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\nhI : M.Indep I\ne : \u03b1\nhe : e \u2208 {x | M.IsBasis I (insert x I)} \\ I\nhu : M.Indep (insert e I)\n\u22a2 e \u2208 I"}, {"line": "\u00b7 rw [insert_eq_of_mem he]; exact hI.isBasis_self", "tactic_state": "case refine_2\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\nhI : M.Indep I\ne : \u03b1\nhe : e \u2208 {x | M.IsBasis I (insert x I)} \\ I\nhu : M.Indep (insert e I)\n\u22a2 e \u2208 I"}, {"line": "simpa using (hu.eq_of_isBasis he.1).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsBasis.insert_isBasis_insert (hI : M.IsBasis I X) (h : M.Indep (insert e I)) :\n    M.IsBasis (insert e I) (insert e X) := by\n  simp_rw [\u2190 union_singleton] at *\n  exact hI.union_isBasis_union (h.subset subset_union_right).isBasis_self h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}", "{B I J X Y : Set \u03b1} {e : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\ne : \u03b1\nhI : M.IsBasis I X\nh : M.Indep (insert e I)\n\u22a2 M.IsBasis (insert e I) (insert e X)"}, {"line": "simp_rw [\u2190 union_singleton] at *", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\ne : \u03b1\nhI : M.IsBasis I X\nh : M.Indep (I \u222a {e})\n\u22a2 M.IsBasis (I \u222a {e}) (X \u222a {e})"}, {"line": "exact hI.union_isBasis_union (h.subset subset_union_right).isBasis_self h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsBase.isBase_of_isBasis_superset (hB : M.IsBase B) (hBX : B \u2286 X) (hIX : M.IsBasis I X) :\n    M.IsBase I := by\n  by_contra h\n  obtain \u27e8e,heBI,he\u27e9 := hIX.indep.exists_insert_of_not_isBase h hB\n  exact heBI.2 (hIX.mem_of_insert_indep (hBX heBI.1) he)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}", "{B I J X Y : Set \u03b1} {e : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB I X : Set \u03b1\nhB : M.IsBase B\nhBX : B \u2286 X\nhIX : M.IsBasis I X\n\u22a2 M.IsBase I"}, {"line": "by_contra h", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB I X : Set \u03b1\nhB : M.IsBase B\nhBX : B \u2286 X\nhIX : M.IsBasis I X\nh : \u00acM.IsBase I\n\u22a2 False"}, {"line": "obtain \u27e8e,heBI,he\u27e9 := hIX.indep.exists_insert_of_not_isBase h hB", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB I X : Set \u03b1\nhB : M.IsBase B\nhBX : B \u2286 X\nhIX : M.IsBasis I X\nh : \u00acM.IsBase I\ne : \u03b1\nheBI : e \u2208 B \\ I\nhe : M.Indep (insert e I)\n\u22a2 False"}, {"line": "exact heBI.2 (hIX.mem_of_insert_indep (hBX heBI.1) he)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Indep.exists_isBase_subset_union_isBase (hI : M.Indep I) (hB : M.IsBase B) :\n    \u2203 B', M.IsBase B' \u2227 I \u2286 B' \u2227 B' \u2286 I \u222a B := by\n  obtain \u27e8B', hB', hIB'\u27e9 := hI.subset_isBasis_of_subset <| subset_union_left (t := B)\n  exact \u27e8B', hB.isBase_of_isBasis_superset subset_union_right hB', hIB', hB'.subset\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}", "{B I J X Y : Set \u03b1} {e : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB I : Set \u03b1\nhI : M.Indep I\nhB : M.IsBase B\n\u22a2 \u2203 B', M.IsBase B' \u2227 I \u2286 B' \u2227 B' \u2286 I \u222a B"}, {"line": "obtain \u27e8B', hB', hIB'\u27e9 := hI.subset_isBasis_of_subset <| subset_union_left (t := B)", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB I : Set \u03b1\nhI : M.Indep I\nhB : M.IsBase B\nB' : Set \u03b1\nhB' : M.IsBasis B' (I \u222a B)\nhIB' : I \u2286 B'\n\u22a2 \u2203 B', M.IsBase B' \u2227 I \u2286 B' \u2227 B' \u2286 I \u222a B"}, {"line": "exact \u27e8B', hB.isBase_of_isBasis_superset subset_union_right hB', hIB', hB'.subset\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsBasis'.inter_eq_of_subset_indep (hI : M.IsBasis' I X) (hIJ : I \u2286 J) (hJ : M.Indep J) :\n    J \u2229 X = I := by\n  rw [\u2190 hI.isBasis_inter_ground.inter_eq_of_subset_indep hIJ hJ]\n  rw [inter_comm X]\n  rw [\u2190 inter_assoc]\n  rw [inter_eq_self_of_subset_left hJ.subset_ground]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}", "{B I J X Y : Set \u03b1} {e : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI J X : Set \u03b1\nhI : M.IsBasis' I X\nhIJ : I \u2286 J\nhJ : M.Indep J\n\u22a2 J \u2229 X = I"}, {"line": "rw [\u2190 hI.isBasis_inter_ground.inter_eq_of_subset_indep hIJ hJ]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI J X : Set \u03b1\nhI : M.IsBasis' I X\nhIJ : I \u2286 J\nhJ : M.Indep J\n\u22a2 J \u2229 X = J \u2229 (X \u2229 M.E)"}, {"line": "rw [inter_comm X]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI J X : Set \u03b1\nhI : M.IsBasis' I X\nhIJ : I \u2286 J\nhJ : M.Indep J\n\u22a2 J \u2229 X = J \u2229 (M.E \u2229 X)"}, {"line": "rw [\u2190 inter_assoc]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI J X : Set \u03b1\nhI : M.IsBasis' I X\nhIJ : I \u2286 J\nhJ : M.Indep J\n\u22a2 J \u2229 X = J \u2229 M.E \u2229 X"}, {"line": "rw [inter_eq_self_of_subset_left hJ.subset_ground]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCircuit.minimal_not_indep (hC : M.IsCircuit C) : Minimal (\u00ac M.Indep \u00b7) C := by\n  simp_rw [minimal_iff_forall_ssubset, and_iff_right hC.not_indep, not_not]\n  exact fun \u2983t\u2984 a \u21a6 ssubset_indep hC a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Circuit.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {C C' I X Y R : Set \u03b1} {e f x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC : Set \u03b1\nhC : M.IsCircuit C\n\u22a2 Minimal (fun x => \u00acM.Indep x) C"}, {"line": "simp_rw [minimal_iff_forall_ssubset, and_iff_right hC.not_indep, not_not]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC : Set \u03b1\nhC : M.IsCircuit C\n\u22a2 \u2200 \u2983t : Set \u03b1\u2984, t \u2282 C \u2192 M.Indep t"}, {"line": "exact fun \u2983t\u2984 a \u21a6 ssubset_indep hC a", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Indep.insert_isCircuit_of_forall_of_nontrivial (hI : M.Indep I) (hInt : I.Nontrivial)\n    (he : e \u2208 M.closure I) (h : \u2200 f \u2208 I, e \u2209 M.closure (I \\ {f})) : M.IsCircuit (insert e I) := by\n  refine hI.insert_isCircuit_of_forall (fun heI \u21a6 ?_) he h\n  obtain \u27e8f, hf, hne\u27e9 := hInt.exists_ne e\n  exact h f hf (mem_closure_of_mem' _ (by simp [heI, hne.symm]))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Circuit.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {C C' I X Y R : Set \u03b1} {e f x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\ne : \u03b1\nhI : M.Indep I\nhInt : I.Nontrivial\nhe : e \u2208 M.closure I\nh : \u2200 f \u2208 I, e \u2209 M.closure (I \\ {f})\n\u22a2 M.IsCircuit (insert e I)"}, {"line": "refine hI.insert_isCircuit_of_forall (fun heI \u21a6 ?_) he h", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\ne : \u03b1\nhI : M.Indep I\nhInt : I.Nontrivial\nhe : e \u2208 M.closure I\nh : \u2200 f \u2208 I, e \u2209 M.closure (I \\ {f})\nheI : e \u2208 I\n\u22a2 False"}, {"line": "obtain \u27e8f, hf, hne\u27e9 := hInt.exists_ne e", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\ne : \u03b1\nhI : M.Indep I\nhInt : I.Nontrivial\nhe : e \u2208 M.closure I\nh : \u2200 f \u2208 I, e \u2209 M.closure (I \\ {f})\nheI : e \u2208 I\nf : \u03b1\nhf : f \u2208 I\nhne : f \u2260 e\n\u22a2 False"}, {"line": "exact h f hf (mem_closure_of_mem' _ (by simp [heI, hne.symm]))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCircuit.diff_singleton_isBasis (hC : M.IsCircuit C) (he : e \u2208 C) :\n    M.IsBasis (C \\ {e}) C := by\n  nth_rw 2 [\u2190 insert_eq_of_mem he]\n  rw [\u2190 insert_diff_singleton]\n  rw [(hC.diff_singleton_indep he).isBasis_insert_iff]\n  rw [insert_diff_singleton]\n  rw [insert_eq_of_mem he]\n  exact Or.inl hC.dep\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Circuit.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {C C' I X Y R : Set \u03b1} {e f x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC : Set \u03b1\ne : \u03b1\nhC : M.IsCircuit C\nhe : e \u2208 C\n\u22a2 M.IsBasis (C \\ {e}) C"}, {"line": "nth_rw 2 [\u2190 insert_eq_of_mem he]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC : Set \u03b1\ne : \u03b1\nhC : M.IsCircuit C\nhe : e \u2208 C\n\u22a2 M.IsBasis (C \\ {e}) (insert e C)"}, {"line": "rw [\u2190 insert_diff_singleton]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC : Set \u03b1\ne : \u03b1\nhC : M.IsCircuit C\nhe : e \u2208 C\n\u22a2 M.IsBasis (C \\ {e}) (insert e (C \\ {e}))"}, {"line": "rw [(hC.diff_singleton_indep he).isBasis_insert_iff]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC : Set \u03b1\ne : \u03b1\nhC : M.IsCircuit C\nhe : e \u2208 C\n\u22a2 M.Dep (insert e (C \\ {e})) \u2228 e \u2208 C \\ {e}"}, {"line": "rw [insert_diff_singleton]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC : Set \u03b1\ne : \u03b1\nhC : M.IsCircuit C\nhe : e \u2208 C\n\u22a2 M.Dep (insert e C) \u2228 e \u2208 C \\ {e}"}, {"line": "rw [insert_eq_of_mem he]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC : Set \u03b1\ne : \u03b1\nhC : M.IsCircuit C\nhe : e \u2208 C\n\u22a2 M.Dep C \u2228 e \u2208 C \\ {e}"}, {"line": "exact Or.inl hC.dep", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCircuit.isBasis_iff_eq_diff_singleton (hC : M.IsCircuit C) :\n    M.IsBasis I C \u2194 \u2203 e \u2208 C, I = C \\ {e} := by\n  refine \u27e8fun h \u21a6 ?_, ?_\u27e9\n  \u00b7 obtain \u27e8e, he\u27e9 := exists_of_ssubset\n      (h.subset.ssubset_of_ne (by rintro rfl; exact hC.dep.not_indep h.indep))\n    exact \u27e8e, he.1, h.eq_of_subset_indep (hC.diff_singleton_indep he.1)\n      (subset_diff_singleton h.subset he.2) diff_subset\u27e9\n  rintro \u27e8e, he, rfl\u27e9\n  exact hC.diff_singleton_isBasis he\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Circuit.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {C C' I X Y R : Set \u03b1} {e f x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC I : Set \u03b1\nhC : M.IsCircuit C\n\u22a2 M.IsBasis I C \u2194 \u2203 e \u2208 C, I = C \\ {e}"}, {"line": "refine \u27e8fun h \u21a6 ?_, ?_\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u_1\nM : Matroid \u03b1\nC I : Set \u03b1\nhC : M.IsCircuit C\nh : M.IsBasis I C\n\u22a2 \u2203 e \u2208 C, I = C \\ {e}\n---\ncase refine_2\n\u03b1 : Type u_1\nM : Matroid \u03b1\nC I : Set \u03b1\nhC : M.IsCircuit C\n\u22a2 (\u2203 e \u2208 C, I = C \\ {e}) \u2192 M.IsBasis I C"}, {"line": "\u00b7 obtain \u27e8e, he\u27e9 := exists_of_ssubset\n      (h.subset.ssubset_of_ne (by rintro rfl; exact hC.dep.not_indep h.indep))\n    exact \u27e8e, he.1, h.eq_of_subset_indep (hC.diff_singleton_indep he.1)\n      (subset_diff_singleton h.subset he.2) diff_subset\u27e9", "tactic_state": "case refine_2\n\u03b1 : Type u_1\nM : Matroid \u03b1\nC I : Set \u03b1\nhC : M.IsCircuit C\n\u22a2 (\u2203 e \u2208 C, I = C \\ {e}) \u2192 M.IsBasis I C"}, {"line": "rintro \u27e8e, he, rfl\u27e9", "tactic_state": "case refine_2.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nC : Set \u03b1\nhC : M.IsCircuit C\ne : \u03b1\nhe : e \u2208 C\n\u22a2 M.IsBasis (C \\ {e}) C"}, {"line": "exact hC.diff_singleton_isBasis he", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCircuit.isBasis_iff_insert_eq (hC : M.IsCircuit C) :\n    M.IsBasis I C \u2194 \u2203 e \u2208 C \\ I, C = insert e I := by\n  rw [hC.isBasis_iff_eq_diff_singleton]\n  refine \u27e8fun \u27e8e, he, hI\u27e9 \u21a6 \u27e8e, \u27e8he, fun heI \u21a6 (hI.subset heI).2 rfl\u27e9, ?_\u27e9,\n    fun \u27e8e, he, hC\u27e9 \u21a6 \u27e8e, he.1, ?_\u27e9\u27e9\n  \u00b7 rw [hI, insert_diff_singleton, insert_eq_of_mem he]\n  rw [hC]\n  rw [insert_diff_self_of_not_mem he.2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Circuit.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {C C' I X Y R : Set \u03b1} {e f x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC I : Set \u03b1\nhC : M.IsCircuit C\n\u22a2 M.IsBasis I C \u2194 \u2203 e \u2208 C \\ I, C = insert e I"}, {"line": "rw [hC.isBasis_iff_eq_diff_singleton]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC I : Set \u03b1\nhC : M.IsCircuit C\n\u22a2 (\u2203 e \u2208 C, I = C \\ {e}) \u2194 \u2203 e \u2208 C \\ I, C = insert e I"}, {"line": "refine \u27e8fun \u27e8e, he, hI\u27e9 \u21a6 \u27e8e, \u27e8he, fun heI \u21a6 (hI.subset heI).2 rfl\u27e9, ?_\u27e9,\n    fun \u27e8e, he, hC\u27e9 \u21a6 \u27e8e, he.1, ?_\u27e9\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u_1\nM : Matroid \u03b1\nC I : Set \u03b1\nhC : M.IsCircuit C\nx\u271d : \u2203 e \u2208 C, I = C \\ {e}\ne : \u03b1\nhe : e \u2208 C\nhI : I = C \\ {e}\n\u22a2 C = insert e I\n---\ncase refine_2\n\u03b1 : Type u_1\nM : Matroid \u03b1\nC I : Set \u03b1\nhC\u271d : M.IsCircuit C\nx\u271d : \u2203 e \u2208 C \\ I, C = insert e I\ne : \u03b1\nhe : e \u2208 C \\ I\nhC : C = insert e I\n\u22a2 I = C \\ {e}"}, {"line": "\u00b7 rw [hI, insert_diff_singleton, insert_eq_of_mem he]", "tactic_state": "case refine_2\n\u03b1 : Type u_1\nM : Matroid \u03b1\nC I : Set \u03b1\nhC\u271d : M.IsCircuit C\nx\u271d : \u2203 e \u2208 C \\ I, C = insert e I\ne : \u03b1\nhe : e \u2208 C \\ I\nhC : C = insert e I\n\u22a2 I = C \\ {e}"}, {"line": "rw [hC]", "tactic_state": "case refine_2\n\u03b1 : Type u_1\nM : Matroid \u03b1\nC I : Set \u03b1\nhC\u271d : M.IsCircuit C\nx\u271d : \u2203 e \u2208 C \\ I, C = insert e I\ne : \u03b1\nhe : e \u2208 C \\ I\nhC : C = insert e I\n\u22a2 I = insert e I \\ {e}"}, {"line": "rw [insert_diff_self_of_not_mem he.2]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma fundCircuit_eq_of_mem (heX : e \u2208 X) : M.fundCircuit e X = {e} := by\n  suffices h : \u2200 a \u2208 X, (\u2200 t \u2286 X, M.closure {e} \u2286 M.closure t \u2192 a \u2208 t) \u2192 a = e by\n    simpa [subset_antisymm_iff, fundCircuit]\n  exact fun b hbX h \u21a6 h _ (singleton_subset_iff.2 heX) Subset.rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Circuit.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {C C' I X Y R : Set \u03b1} {e f x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\ne : \u03b1\nheX : e \u2208 X\n\u22a2 M.fundCircuit e X = {e}"}, {"line": "suffices h : \u2200 a \u2208 X, (\u2200 t \u2286 X, M.closure {e} \u2286 M.closure t \u2192 a \u2208 t) \u2192 a = e by\n    simpa [subset_antisymm_iff, fundCircuit]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\ne : \u03b1\nheX : e \u2208 X\n\u22a2 \u2200 a \u2208 X, (\u2200 t \u2286 X, M.closure {e} \u2286 M.closure t \u2192 a \u2208 t) \u2192 a = e"}, {"line": "exact fun b hbX h \u21a6 h _ (singleton_subset_iff.2 heX) Subset.rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma fundCircuit_eq_of_not_mem_ground (heX : e \u2209 M.E) : M.fundCircuit e X = {e} := by\n  suffices h : \u2200 a \u2208 X, (\u2200 t \u2286 X, M.closure {e} \u2286 M.closure t \u2192 a \u2208 t) \u2192 a = e by\n    simpa [subset_antisymm_iff, fundCircuit]\n  simp_rw [\u2190 M.closure_inter_ground {e}, singleton_inter_eq_empty.2 heX]\n  exact fun a haX h \u21a6 by simpa using h \u2205 (empty_subset X) rfl.subset\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Circuit.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {C C' I X Y R : Set \u03b1} {e f x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\ne : \u03b1\nheX : e \u2209 M.E\n\u22a2 M.fundCircuit e X = {e}"}, {"line": "suffices h : \u2200 a \u2208 X, (\u2200 t \u2286 X, M.closure {e} \u2286 M.closure t \u2192 a \u2208 t) \u2192 a = e by\n    simpa [subset_antisymm_iff, fundCircuit]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\ne : \u03b1\nheX : e \u2209 M.E\n\u22a2 \u2200 a \u2208 X, (\u2200 t \u2286 X, M.closure {e} \u2286 M.closure t \u2192 a \u2208 t) \u2192 a = e"}, {"line": "simp_rw [\u2190 M.closure_inter_ground {e}, singleton_inter_eq_empty.2 heX]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\ne : \u03b1\nheX : e \u2209 M.E\n\u22a2 \u2200 a \u2208 X, (\u2200 t \u2286 X, M.closure \u2205 \u2286 M.closure t \u2192 a \u2208 t) \u2192 a = e"}, {"line": "exact fun a haX h \u21a6 by simpa using h \u2205 (empty_subset X) rfl.subset", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Indep.mem_fundCircuit_iff (hI : M.Indep I) (hecl : e \u2208 M.closure I) (heI : e \u2209 I) :\n    x \u2208 M.fundCircuit e I \u2194 M.Indep (insert e I \\ {x}) := by\n  obtain rfl | hne := eq_or_ne x e\n  \u00b7 simp [hI.diff, mem_fundCircuit]\n  suffices (\u2200 t \u2286 I, e \u2208 M.closure t \u2192 x \u2208 t) \u2194 e \u2209 M.closure (I \\ {x}) by\n    simpa [fundCircuit_eq_sInter hecl, hne, \u2190 insert_diff_singleton_comm hne.symm,\n      (hI.diff _).insert_indep_iff, mem_ground_of_mem_closure hecl, heI]\n  refine \u27e8fun h hecl \u21a6 (h _ diff_subset hecl).2 rfl, fun h J hJ heJ \u21a6 by_contra fun hxJ \u21a6 h ?_\u27e9\n  exact M.closure_subset_closure (subset_diff_singleton hJ hxJ) heJ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Circuit.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {C C' I X Y R : Set \u03b1} {e f x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\ne x : \u03b1\nhI : M.Indep I\nhecl : e \u2208 M.closure I\nheI : e \u2209 I\n\u22a2 x \u2208 M.fundCircuit e I \u2194 M.Indep (insert e I \\ {x})"}, {"line": "obtain rfl | hne := eq_or_ne x e", "tactic_state": "case inl\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\nx : \u03b1\nhI : M.Indep I\nhecl : x \u2208 M.closure I\nheI : x \u2209 I\n\u22a2 x \u2208 M.fundCircuit x I \u2194 M.Indep (insert x I \\ {x})\n---\ncase inr\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\ne x : \u03b1\nhI : M.Indep I\nhecl : e \u2208 M.closure I\nheI : e \u2209 I\nhne : x \u2260 e\n\u22a2 x \u2208 M.fundCircuit e I \u2194 M.Indep (insert e I \\ {x})"}, {"line": "\u00b7 simp [hI.diff, mem_fundCircuit]", "tactic_state": "case inr\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\ne x : \u03b1\nhI : M.Indep I\nhecl : e \u2208 M.closure I\nheI : e \u2209 I\nhne : x \u2260 e\n\u22a2 x \u2208 M.fundCircuit e I \u2194 M.Indep (insert e I \\ {x})"}, {"line": "suffices (\u2200 t \u2286 I, e \u2208 M.closure t \u2192 x \u2208 t) \u2194 e \u2209 M.closure (I \\ {x}) by\n    simpa [fundCircuit_eq_sInter hecl, hne, \u2190 insert_diff_singleton_comm hne.symm,\n      (hI.diff _).insert_indep_iff, mem_ground_of_mem_closure hecl, heI]", "tactic_state": "case inr\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\ne x : \u03b1\nhI : M.Indep I\nhecl : e \u2208 M.closure I\nheI : e \u2209 I\nhne : x \u2260 e\n\u22a2 (\u2200 t \u2286 I, e \u2208 M.closure t \u2192 x \u2208 t) \u2194 e \u2209 M.closure (I \\ {x})"}, {"line": "refine \u27e8fun h hecl \u21a6 (h _ diff_subset hecl).2 rfl, fun h J hJ heJ \u21a6 by_contra fun hxJ \u21a6 h ?_\u27e9", "tactic_state": "case inr\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\ne x : \u03b1\nhI : M.Indep I\nhecl : e \u2208 M.closure I\nheI : e \u2209 I\nhne : x \u2260 e\nh : e \u2209 M.closure (I \\ {x})\nJ : Set \u03b1\nhJ : J \u2286 I\nheJ : e \u2208 M.closure J\nhxJ : x \u2209 J\n\u22a2 e \u2208 M.closure (I \\ {x})"}, {"line": "exact M.closure_subset_closure (subset_diff_singleton hJ hxJ) heJ", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Dep.exists_isCircuit_subset (hX : M.Dep X) : \u2203 C, C \u2286 X \u2227 M.IsCircuit C := by\n  obtain \u27e8I, hI\u27e9 := M.exists_isBasis X\n  obtain \u27e8e, heX, heI\u27e9 := exists_of_ssubset\n    (hI.subset.ssubset_of_ne (by rintro rfl; exact hI.indep.not_dep hX))\n  exact \u27e8M.fundCircuit e I, (M.fundCircuit_subset_insert e I).trans (insert_subset heX hI.subset),\n    hI.indep.fundCircuit_isCircuit (hI.subset_closure heX) heI\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Circuit.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {C C' I X Y R : Set \u03b1} {e f x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\nhX : M.Dep X\n\u22a2 \u2203 C \u2286 X, M.IsCircuit C"}, {"line": "obtain \u27e8I, hI\u27e9 := M.exists_isBasis X", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\nhX : M.Dep X\nI : Set \u03b1\nhI : M.IsBasis I X\n\u22a2 \u2203 C \u2286 X, M.IsCircuit C"}, {"line": "obtain \u27e8e, heX, heI\u27e9 := exists_of_ssubset\n    (hI.subset.ssubset_of_ne (by rintro rfl; exact hI.indep.not_dep hX))", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\nhX : M.Dep X\nI : Set \u03b1\nhI : M.IsBasis I X\ne : \u03b1\nheX : e \u2208 X\nheI : e \u2209 I\n\u22a2 \u2203 C \u2286 X, M.IsCircuit C"}, {"line": "exact \u27e8M.fundCircuit e I, (M.fundCircuit_subset_insert e I).trans (insert_subset heX hI.subset),\n    hI.indep.fundCircuit_isCircuit (hI.subset_closure heX) heI\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCircuit.subset_closure_diff_singleton (hC : M.IsCircuit C) (e : \u03b1) :\n    C \u2286 M.closure (C \\ {e}) := by\n  rw [hC.closure_diff_singleton_eq]\n  exact M.subset_closure _ hC.subset_ground\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Circuit.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {C C' I X Y R : Set \u03b1} {e f x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC : Set \u03b1\nhC : M.IsCircuit C\ne : \u03b1\n\u22a2 C \u2286 M.closure (C \\ {e})"}, {"line": "rw [hC.closure_diff_singleton_eq]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC : Set \u03b1\nhC : M.IsCircuit C\ne : \u03b1\n\u22a2 C \u2286 M.closure C"}, {"line": "exact M.subset_closure _ hC.subset_ground", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCircuit.strong_elimination (hC\u2081 : M.IsCircuit C\u2081) (hC\u2082 : M.IsCircuit C\u2082) (heC\u2081 : e \u2208 C\u2081)\n    (heC\u2082 : e \u2208 C\u2082) (hfC\u2081 : f \u2208 C\u2081) (hfC\u2082 : f \u2209 C\u2082) :\n    \u2203 C \u2286 (C\u2081 \u222a C\u2082) \\ {e}, M.IsCircuit C \u2227 f \u2208 C := by\n  obtain \u27e8C, hCs, hC, hfC\u27e9 := hC\u2081.strong_multi_elimination (fun i : Unit \u21a6 e) (fun _ \u21a6 C\u2082) f\n    (by simpa) (by simpa) (by simpa) (by simp) (by simpa) (by simpa)\n  exact \u27e8C, hCs.trans (diff_subset_diff (by simp) (by simp)), hC, hfC\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Circuit.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {C C' I X Y R : Set \u03b1} {e f x y : \u03b1}", "{\u03b9 : Type*} {J C\u2080 C\u2081 C\u2082 : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne f : \u03b1\nC\u2081 C\u2082 : Set \u03b1\nhC\u2081 : M.IsCircuit C\u2081\nhC\u2082 : M.IsCircuit C\u2082\nheC\u2081 : e \u2208 C\u2081\nheC\u2082 : e \u2208 C\u2082\nhfC\u2081 : f \u2208 C\u2081\nhfC\u2082 : f \u2209 C\u2082\n\u22a2 \u2203 C \u2286 (C\u2081 \u222a C\u2082) \\ {e}, M.IsCircuit C \u2227 f \u2208 C"}, {"line": "obtain \u27e8C, hCs, hC, hfC\u27e9 := hC\u2081.strong_multi_elimination (fun i : Unit \u21a6 e) (fun _ \u21a6 C\u2082) f\n    (by simpa) (by simpa) (by simpa) (by simp) (by simpa) (by simpa)", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\ne f : \u03b1\nC\u2081 C\u2082 : Set \u03b1\nhC\u2081 : M.IsCircuit C\u2081\nhC\u2082 : M.IsCircuit C\u2082\nheC\u2081 : e \u2208 C\u2081\nheC\u2082 : e \u2208 C\u2082\nhfC\u2081 : f \u2208 C\u2081\nhfC\u2082 : f \u2209 C\u2082\nC : Set \u03b1\nhCs : C \u2286 (C\u2081 \u222a \u22c3 i, C\u2082) \\ range fun i => e\nhC : M.IsCircuit C\nhfC : f \u2208 C\n\u22a2 \u2203 C \u2286 (C\u2081 \u222a C\u2082) \\ {e}, M.IsCircuit C \u2227 f \u2208 C"}, {"line": "exact \u27e8C, hCs.trans (diff_subset_diff (by simp) (by simp)), hC, hfC\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCircuit.isCocircuit_inter_nontrivial (hC : M.IsCircuit C) (hK : M.IsCocircuit K)\n    (hCK : (C \u2229 K).Nonempty) : (C \u2229 K).Nontrivial := by\n  obtain \u27e8e, heCK\u27e9 := hCK\n  rw [nontrivial_iff_ne_singleton heCK]\n  exact hC.inter_isCocircuit_ne_singleton hK\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Circuit.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {C C' I X Y R : Set \u03b1} {e f x y : \u03b1}", "{\u03b9 : Type*} {J C\u2080 C\u2081 C\u2082 : Set \u03b1}", "{K B : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC K : Set \u03b1\nhC : M.IsCircuit C\nhK : M.IsCocircuit K\nhCK : (C \u2229 K).Nonempty\n\u22a2 (C \u2229 K).Nontrivial"}, {"line": "obtain \u27e8e, heCK\u27e9 := hCK", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nC K : Set \u03b1\nhC : M.IsCircuit C\nhK : M.IsCocircuit K\ne : \u03b1\nheCK : e \u2208 C \u2229 K\n\u22a2 (C \u2229 K).Nontrivial"}, {"line": "rw [nontrivial_iff_ne_singleton heCK]", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nC K : Set \u03b1\nhC : M.IsCircuit C\nhK : M.IsCocircuit K\ne : \u03b1\nheCK : e \u2208 C \u2229 K\n\u22a2 C \u2229 K \u2260 {e}"}, {"line": "exact hC.inter_isCocircuit_ne_singleton hK", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCircuit.isCocircuit_disjoint_or_nontrivial_inter (hC : M.IsCircuit C)\n    (hK : M.IsCocircuit K) : Disjoint C K \u2228 (C \u2229 K).Nontrivial := by\n  rw [or_iff_not_imp_left]\n  rw [disjoint_iff_inter_eq_empty]\n  rw [\u2190 ne_eq]\n  rw [\u2190 nonempty_iff_ne_empty]\n  exact hC.isCocircuit_inter_nontrivial hK\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Circuit.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {C C' I X Y R : Set \u03b1} {e f x y : \u03b1}", "{\u03b9 : Type*} {J C\u2080 C\u2081 C\u2082 : Set \u03b1}", "{K B : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC K : Set \u03b1\nhC : M.IsCircuit C\nhK : M.IsCocircuit K\n\u22a2 Disjoint C K \u2228 (C \u2229 K).Nontrivial"}, {"line": "rw [or_iff_not_imp_left]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC K : Set \u03b1\nhC : M.IsCircuit C\nhK : M.IsCocircuit K\n\u22a2 \u00acDisjoint C K \u2192 (C \u2229 K).Nontrivial"}, {"line": "rw [disjoint_iff_inter_eq_empty]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC K : Set \u03b1\nhC : M.IsCircuit C\nhK : M.IsCocircuit K\n\u22a2 \u00acC \u2229 K = \u2205 \u2192 (C \u2229 K).Nontrivial"}, {"line": "rw [\u2190 ne_eq]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC K : Set \u03b1\nhC : M.IsCircuit C\nhK : M.IsCocircuit K\n\u22a2 C \u2229 K \u2260 \u2205 \u2192 (C \u2229 K).Nontrivial"}, {"line": "rw [\u2190 nonempty_iff_ne_empty]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nC K : Set \u03b1\nhC : M.IsCircuit C\nhK : M.IsCocircuit K\n\u22a2 (C \u2229 K).Nonempty \u2192 (C \u2229 K).Nontrivial"}, {"line": "exact hC.isCocircuit_inter_nontrivial hK", "tactic_state": "No Goals!"}]}
{"declaration": "lemma fundCocircuit_inter_eq (M : Matroid \u03b1) {B : Set \u03b1} (he : e \u2208 B) :\n    (M.fundCocircuit e B) \u2229 B = {e} := by\n  refine subset_antisymm ?_ (singleton_subset_iff.2 \u27e8M.mem_fundCocircuit _ _, he\u27e9)\n  refine (inter_subset_inter_left _ (M.fundCocircuit_subset_insert_compl _ _)).trans ?_\n  simp +contextual\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Circuit.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {C C' I X Y R : Set \u03b1} {e f x y : \u03b1}", "{\u03b9 : Type*} {J C\u2080 C\u2081 C\u2082 : Set \u03b1}", "{K B : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ne : \u03b1\nM : Matroid \u03b1\nB : Set \u03b1\nhe : e \u2208 B\n\u22a2 M.fundCocircuit e B \u2229 B = {e}"}, {"line": "refine subset_antisymm ?_ (singleton_subset_iff.2 \u27e8M.mem_fundCocircuit _ _, he\u27e9)", "tactic_state": "\u03b1 : Type u_1\ne : \u03b1\nM : Matroid \u03b1\nB : Set \u03b1\nhe : e \u2208 B\n\u22a2 M.fundCocircuit e B \u2229 B \u2286 {e}"}, {"line": "refine (inter_subset_inter_left _ (M.fundCocircuit_subset_insert_compl _ _)).trans ?_", "tactic_state": "\u03b1 : Type u_1\ne : \u03b1\nM : Matroid \u03b1\nB : Set \u03b1\nhe : e \u2208 B\n\u22a2 insert e (M.E \\ B) \u2229 B \u2286 {e}"}, {"line": "simp +contextual", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsFlat.iInter {\u03b9 : Type*} [Nonempty \u03b9] {Fs : \u03b9 \u2192 Set \u03b1}\n    (hFs : \u2200 i, M.IsFlat (Fs i)) : M.IsFlat (\u22c2 i, Fs i) := by\n  refine \u27e8fun I X hI hIX \u21a6 subset_iInter fun i \u21a6 ?_,\n    (iInter_subset _ (Classical.arbitrary _)).trans (hFs _).subset_ground\u27e9\n  obtain \u27e8J, hIJ, hJ\u27e9 := hI.indep.subset_isBasis_of_subset (hI.subset.trans (iInter_subset _ i))\n  refine subset_union_right.trans ((hFs i).1 (X := Fs i \u222a X) hIJ ?_)\n  convert hIJ.isBasis_union (hIX.isBasis_union_of_subset hIJ.indep hJ) using 1\n  rw [\u2190 union_assoc]\n  rw [union_eq_self_of_subset_right hIJ.subset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\n\u03b9 : Type u_3\ninst\u271d : Nonempty \u03b9\nFs : \u03b9 \u2192 Set \u03b1\nhFs : \u2200 (i : \u03b9), M.IsFlat (Fs i)\n\u22a2 M.IsFlat (\u22c2 i, Fs i)"}, {"line": "refine \u27e8fun I X hI hIX \u21a6 subset_iInter fun i \u21a6 ?_,\n    (iInter_subset _ (Classical.arbitrary _)).trans (hFs _).subset_ground\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u_2\nM : Matroid \u03b1\n\u03b9 : Type u_3\ninst\u271d : Nonempty \u03b9\nFs : \u03b9 \u2192 Set \u03b1\nhFs : \u2200 (i : \u03b9), M.IsFlat (Fs i)\nI X : Set \u03b1\nhI : M.IsBasis I (\u22c2 i, Fs i)\nhIX : M.IsBasis I X\ni : \u03b9\n\u22a2 X \u2286 Fs i\n---\ncase refine_2\n\u03b1 : Type u_2\nM : Matroid \u03b1\n\u03b9 : Type u_3\ninst\u271d : Nonempty \u03b9\nFs : \u03b9 \u2192 Set \u03b1\nhFs : \u2200 (i : \u03b9), M.IsFlat (Fs i)\n\u22a2 Nonempty \u03b9"}, {"line": "obtain \u27e8J, hIJ, hJ\u27e9 := hI.indep.subset_isBasis_of_subset (hI.subset.trans (iInter_subset _ i))", "tactic_state": "case refine_1.intro.intro\n\u03b1 : Type u_2\nM : Matroid \u03b1\n\u03b9 : Type u_3\ninst\u271d : Nonempty \u03b9\nFs : \u03b9 \u2192 Set \u03b1\nhFs : \u2200 (i : \u03b9), M.IsFlat (Fs i)\nI X : Set \u03b1\nhI : M.IsBasis I (\u22c2 i, Fs i)\nhIX : M.IsBasis I X\ni : \u03b9\nJ : Set \u03b1\nhIJ : M.IsBasis J (Fs i)\nhJ : I \u2286 J\n\u22a2 X \u2286 Fs i\n---\ncase refine_2\n\u03b1 : Type u_2\nM : Matroid \u03b1\n\u03b9 : Type u_3\ninst\u271d : Nonempty \u03b9\nFs : \u03b9 \u2192 Set \u03b1\nhFs : \u2200 (i : \u03b9), M.IsFlat (Fs i)\n\u22a2 Nonempty \u03b9"}, {"line": "refine subset_union_right.trans ((hFs i).1 (X := Fs i \u222a X) hIJ ?_)", "tactic_state": "case refine_1.intro.intro\n\u03b1 : Type u_2\nM : Matroid \u03b1\n\u03b9 : Type u_3\ninst\u271d : Nonempty \u03b9\nFs : \u03b9 \u2192 Set \u03b1\nhFs : \u2200 (i : \u03b9), M.IsFlat (Fs i)\nI X : Set \u03b1\nhI : M.IsBasis I (\u22c2 i, Fs i)\nhIX : M.IsBasis I X\ni : \u03b9\nJ : Set \u03b1\nhIJ : M.IsBasis J (Fs i)\nhJ : I \u2286 J\n\u22a2 M.IsBasis J (Fs i \u222a X)\n---\ncase refine_2\n\u03b1 : Type u_2\nM : Matroid \u03b1\n\u03b9 : Type u_3\ninst\u271d : Nonempty \u03b9\nFs : \u03b9 \u2192 Set \u03b1\nhFs : \u2200 (i : \u03b9), M.IsFlat (Fs i)\n\u22a2 Nonempty \u03b9"}, {"line": "convert hIJ.isBasis_union (hIX.isBasis_union_of_subset hIJ.indep hJ) using 1", "tactic_state": "case h.e'_4\n\u03b1 : Type u_2\nM : Matroid \u03b1\n\u03b9 : Type u_3\ninst\u271d : Nonempty \u03b9\nFs : \u03b9 \u2192 Set \u03b1\nhFs : \u2200 (i : \u03b9), M.IsFlat (Fs i)\nI X : Set \u03b1\nhI : M.IsBasis I (\u22c2 i, Fs i)\nhIX : M.IsBasis I X\ni : \u03b9\nJ : Set \u03b1\nhIJ : M.IsBasis J (Fs i)\nhJ : I \u2286 J\n\u22a2 Fs i \u222a X = Fs i \u222a (J \u222a X)\n---\ncase refine_2\n\u03b1 : Type u_2\nM : Matroid \u03b1\n\u03b9 : Type u_3\ninst\u271d : Nonempty \u03b9\nFs : \u03b9 \u2192 Set \u03b1\nhFs : \u2200 (i : \u03b9), M.IsFlat (Fs i)\n\u22a2 Nonempty \u03b9"}, {"line": "rw [\u2190 union_assoc]", "tactic_state": "case h.e'_4\n\u03b1 : Type u_2\nM : Matroid \u03b1\n\u03b9 : Type u_3\ninst\u271d : Nonempty \u03b9\nFs : \u03b9 \u2192 Set \u03b1\nhFs : \u2200 (i : \u03b9), M.IsFlat (Fs i)\nI X : Set \u03b1\nhI : M.IsBasis I (\u22c2 i, Fs i)\nhIX : M.IsBasis I X\ni : \u03b9\nJ : Set \u03b1\nhIJ : M.IsBasis J (Fs i)\nhJ : I \u2286 J\n\u22a2 Fs i \u222a X = Fs i \u222a J \u222a X\n---\ncase refine_2\n\u03b1 : Type u_2\nM : Matroid \u03b1\n\u03b9 : Type u_3\ninst\u271d : Nonempty \u03b9\nFs : \u03b9 \u2192 Set \u03b1\nhFs : \u2200 (i : \u03b9), M.IsFlat (Fs i)\n\u22a2 Nonempty \u03b9"}, {"line": "rw [union_eq_self_of_subset_right hIJ.subset]", "tactic_state": "case refine_2\n\u03b1 : Type u_2\nM : Matroid \u03b1\n\u03b9 : Type u_3\ninst\u271d : Nonempty \u03b9\nFs : \u03b9 \u2192 Set \u03b1\nhFs : \u2200 (i : \u03b9), M.IsFlat (Fs i)\n\u22a2 Nonempty \u03b9"}]}
{"declaration": "lemma isFlat_iff_isClosed : M.IsFlat F \u2194 \u2203 h : F \u2286 M.E, M.subtypeClosure.IsClosed \u27e8F, h\u27e9 := by\n  simpa [subtypeClosure] using IsFlat.subset_ground\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nF : Set \u03b1\n\u22a2 M.IsFlat F \u2194 \u2203 (h : F \u2286 M.E), M.subtypeClosure.IsClosed \u27e8F, h\u27e9"}, {"line": "simpa [subtypeClosure] using IsFlat.subset_ground", "tactic_state": "No Goals!"}]}
{"declaration": "lemma closure_eq_subtypeClosure (M : Matroid \u03b1) (X : Set \u03b1) :\n    M.closure X = M.subtypeClosure \u27e8X \u2229 M.E, inter_subset_right\u27e9  := by\n  suffices \u2200 (x : \u03b1), (\u2200 (t : Set \u03b1), M.IsFlat t \u2192 X \u2229 M.E \u2286 t \u2192 x \u2208 t) \u2194\n    (x \u2208 M.E \u2227 \u2200 a \u2286 M.E, X \u2229 M.E \u2286 a \u2192 M.IsFlat a \u2192 x \u2208 a) by\n    simpa [closure, subtypeClosure, Set.ext_iff]\n  exact fun x \u21a6 \u27e8fun h \u21a6 \u27e8h _ M.ground_isFlat inter_subset_right, fun F _ hXF hF \u21a6 h F hF hXF\u27e9,\n    fun \u27e8_, h\u27e9 F hF hXF \u21a6 h F hF.subset_ground hXF hF\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX : Set \u03b1\n\u22a2 M.closure X = \u2191(M.subtypeClosure \u27e8X \u2229 M.E, \u22ef\u27e9)"}, {"line": "suffices \u2200 (x : \u03b1), (\u2200 (t : Set \u03b1), M.IsFlat t \u2192 X \u2229 M.E \u2286 t \u2192 x \u2208 t) \u2194\n    (x \u2208 M.E \u2227 \u2200 a \u2286 M.E, X \u2229 M.E \u2286 a \u2192 M.IsFlat a \u2192 x \u2208 a) by\n    simpa [closure, subtypeClosure, Set.ext_iff]", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX : Set \u03b1\n\u22a2 \u2200 (x : \u03b1), (\u2200 (t : Set \u03b1), M.IsFlat t \u2192 X \u2229 M.E \u2286 t \u2192 x \u2208 t) \u2194 x \u2208 M.E \u2227 \u2200 a \u2286 M.E, X \u2229 M.E \u2286 a \u2192 M.IsFlat a \u2192 x \u2208 a"}, {"line": "exact fun x \u21a6 \u27e8fun h \u21a6 \u27e8h _ M.ground_isFlat inter_subset_right, fun F _ hXF hF \u21a6 h F hF hXF\u27e9,\n    fun \u27e8_, h\u27e9 F hF hXF \u21a6 h F hF.subset_ground hXF hF\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_of_closure_ssubset (hXY : M.closure X \u2282 M.closure Y) : \u2203 e \u2208 Y, e \u2209 M.closure X := by\n  by_contra! hcon\n  exact hXY.not_subset (M.closure_subset_closure_of_subset_closure hcon)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX Y : Set \u03b1\nhXY : M.closure X \u2282 M.closure Y\n\u22a2 \u2203 e \u2208 Y, e \u2209 M.closure X"}, {"line": "by_contra! hcon", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX Y : Set \u03b1\nhXY : M.closure X \u2282 M.closure Y\nhcon : \u2200 e \u2208 Y, e \u2208 M.closure X\n\u22a2 False"}, {"line": "exact hXY.not_subset (M.closure_subset_closure_of_subset_closure hcon)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma closure_iUnion_congr (Xs Ys : \u03b9 \u2192 Set \u03b1) (h : \u2200 i, M.closure (Xs i) = M.closure (Ys i)) :\n    M.closure (\u22c3 i, Xs i) = M.closure (\u22c3 i, Ys i) := by\n  simp [h, \u2190 M.closure_iUnion_closure_eq_closure_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Matroid \u03b1\nXs Ys : \u03b9 \u2192 Set \u03b1\nh : \u2200 (i : \u03b9), M.closure (Xs i) = M.closure (Ys i)\n\u22a2 M.closure (\u22c3 i, Xs i) = M.closure (\u22c3 i, Ys i)"}, {"line": "simp [h, \u2190 M.closure_iUnion_closure_eq_closure_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma closure_biUnion_closure_eq_closure_biUnion (M : Matroid \u03b1) (Xs : \u03b9 \u2192 Set \u03b1) (A : Set \u03b9) :\n    M.closure (\u22c3 i \u2208 A, M.closure (Xs i)) = M.closure (\u22c3 i \u2208 A, Xs i) := by\n  rw [biUnion_eq_iUnion]\n  rw [M.closure_iUnion_closure_eq_closure_iUnion]\n  rw [biUnion_eq_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Matroid \u03b1\nXs : \u03b9 \u2192 Set \u03b1\nA : Set \u03b9\n\u22a2 M.closure (\u22c3 i \u2208 A, M.closure (Xs i)) = M.closure (\u22c3 i \u2208 A, Xs i)"}, {"line": "rw [biUnion_eq_iUnion]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Matroid \u03b1\nXs : \u03b9 \u2192 Set \u03b1\nA : Set \u03b9\n\u22a2 M.closure (\u22c3 x, M.closure (Xs \u2191x)) = M.closure (\u22c3 i \u2208 A, Xs i)"}, {"line": "rw [M.closure_iUnion_closure_eq_closure_iUnion]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Matroid \u03b1\nXs : \u03b9 \u2192 Set \u03b1\nA : Set \u03b9\n\u22a2 M.closure (\u22c3 i, Xs \u2191i) = M.closure (\u22c3 i \u2208 A, Xs i)"}, {"line": "rw [biUnion_eq_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma closure_union_congr_left {X' : Set \u03b1} (h : M.closure X = M.closure X') :\n    M.closure (X \u222a Y) = M.closure (X' \u222a Y) := by\n  rw [\u2190 M.closure_union_closure_left_eq]\n  rw [h]\n  rw [M.closure_union_closure_left_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX Y X' : Set \u03b1\nh : M.closure X = M.closure X'\n\u22a2 M.closure (X \u222a Y) = M.closure (X' \u222a Y)"}, {"line": "rw [\u2190 M.closure_union_closure_left_eq]", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX Y X' : Set \u03b1\nh : M.closure X = M.closure X'\n\u22a2 M.closure (M.closure X \u222a Y) = M.closure (X' \u222a Y)"}, {"line": "rw [h]", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX Y X' : Set \u03b1\nh : M.closure X = M.closure X'\n\u22a2 M.closure (M.closure X' \u222a Y) = M.closure (X' \u222a Y)"}, {"line": "rw [M.closure_union_closure_left_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma closure_union_congr_right {Y' : Set \u03b1} (h : M.closure Y = M.closure Y') :\n    M.closure (X \u222a Y) = M.closure (X \u222a Y') := by\n  rw [\u2190 M.closure_union_closure_right_eq]\n  rw [h]\n  rw [M.closure_union_closure_right_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX Y Y' : Set \u03b1\nh : M.closure Y = M.closure Y'\n\u22a2 M.closure (X \u222a Y) = M.closure (X \u222a Y')"}, {"line": "rw [\u2190 M.closure_union_closure_right_eq]", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX Y Y' : Set \u03b1\nh : M.closure Y = M.closure Y'\n\u22a2 M.closure (X \u222a M.closure Y) = M.closure (X \u222a Y')"}, {"line": "rw [h]", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX Y Y' : Set \u03b1\nh : M.closure Y = M.closure Y'\n\u22a2 M.closure (X \u222a M.closure Y') = M.closure (X \u222a Y')"}, {"line": "rw [M.closure_union_closure_right_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma closure_insert_congr_right (h : M.closure X = M.closure Y) :\n    M.closure (insert e X) = M.closure (insert e Y) := by\n  simp [\u2190 union_singleton, closure_union_congr_left h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX Y : Set \u03b1\ne : \u03b1\nh : M.closure X = M.closure Y\n\u22a2 M.closure (insert e X) = M.closure (insert e Y)"}, {"line": "simp [\u2190 union_singleton, closure_union_congr_left h]", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX Y : Set \u03b1\ne : \u03b1\nh : M.closure X = M.closure Y\n\u22a2 M.closure (X \u222a {e}) = M.closure (Y \u222a {e})"}]}
{"declaration": "lemma Indep.insert_isBasis_iff_mem_closure (hI : M.Indep I) :\n    M.IsBasis I (insert e I) \u2194 e \u2208 M.closure I := by\n  rw [hI.closure_eq_setOf_isBasis_insert]\n  rw [mem_setOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhI : M.Indep I\n\u22a2 M.IsBasis I (insert e I) \u2194 e \u2208 M.closure I"}, {"line": "rw [hI.closure_eq_setOf_isBasis_insert]", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhI : M.Indep I\n\u22a2 M.IsBasis I (insert e I) \u2194 e \u2208 {x | M.IsBasis I (insert x I)}"}, {"line": "rw [mem_setOf]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsBasis.closure_eq_closure (h : M.IsBasis I X) : M.closure I = M.closure X := by\n  refine subset_antisymm (M.closure_subset_closure h.subset) ?_\n  rw [\u2190 M.closure_closure I]\n  rw [h.indep.closure_eq_setOf_isBasis_insert]\n  exact M.closure_subset_closure fun e he \u21a6 (h.isBasis_subset (subset_insert _ _)\n    (insert_subset he h.subset))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX I : Set \u03b1\nh : M.IsBasis I X\n\u22a2 M.closure I = M.closure X"}, {"line": "refine subset_antisymm (M.closure_subset_closure h.subset) ?_", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX I : Set \u03b1\nh : M.IsBasis I X\n\u22a2 M.closure X \u2286 M.closure I"}, {"line": "rw [\u2190 M.closure_closure I]", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX I : Set \u03b1\nh : M.IsBasis I X\n\u22a2 M.closure X \u2286 M.closure (M.closure I)"}, {"line": "rw [h.indep.closure_eq_setOf_isBasis_insert]", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX I : Set \u03b1\nh : M.IsBasis I X\n\u22a2 M.closure X \u2286 M.closure {x | M.IsBasis I (insert x I)}"}, {"line": "exact M.closure_subset_closure fun e he \u21a6 (h.isBasis_subset (subset_insert _ _)\n    (insert_subset he h.subset))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Indep.mem_closure_iff_of_not_mem (hI : M.Indep I) (heI : e \u2209 I) :\n    e \u2208 M.closure I \u2194 M.Dep (insert e I) := by\n  rw [hI.insert_dep_iff]\n  rw [mem_diff]\n  rw [and_iff_left heI]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhI : M.Indep I\nheI : e \u2209 I\n\u22a2 e \u2208 M.closure I \u2194 M.Dep (insert e I)"}, {"line": "rw [hI.insert_dep_iff]", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhI : M.Indep I\nheI : e \u2209 I\n\u22a2 e \u2208 M.closure I \u2194 e \u2208 M.closure I \\ I"}, {"line": "rw [mem_diff]", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhI : M.Indep I\nheI : e \u2209 I\n\u22a2 e \u2208 M.closure I \u2194 e \u2208 M.closure I \u2227 e \u2209 I"}, {"line": "rw [and_iff_left heI]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Indep.insert_indep_iff (hI : M.Indep I) :\n    M.Indep (insert e I) \u2194 e \u2208 M.E \\ M.closure I \u2228 e \u2208 I := by\n  obtain (h | h) := em (e \u2208 I)\n  \u00b7 simp_rw [insert_eq_of_mem h, iff_true_intro hI, true_iff, iff_true_intro h, or_true]\n  rw [hI.insert_indep_iff_of_not_mem h]\n  rw [or_iff_left h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhI : M.Indep I\n\u22a2 M.Indep (insert e I) \u2194 e \u2208 M.E \\ M.closure I \u2228 e \u2208 I"}, {"line": "obtain (h | h) := em (e \u2208 I)", "tactic_state": "case inl\n\u03b1 : Type u_2\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhI : M.Indep I\nh : e \u2208 I\n\u22a2 M.Indep (insert e I) \u2194 e \u2208 M.E \\ M.closure I \u2228 e \u2208 I\n---\ncase inr\n\u03b1 : Type u_2\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhI : M.Indep I\nh : e \u2209 I\n\u22a2 M.Indep (insert e I) \u2194 e \u2208 M.E \\ M.closure I \u2228 e \u2208 I"}, {"line": "\u00b7 simp_rw [insert_eq_of_mem h, iff_true_intro hI, true_iff, iff_true_intro h, or_true]", "tactic_state": "case inr\n\u03b1 : Type u_2\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhI : M.Indep I\nh : e \u2209 I\n\u22a2 M.Indep (insert e I) \u2194 e \u2208 M.E \\ M.closure I \u2228 e \u2208 I"}, {"line": "rw [hI.insert_indep_iff_of_not_mem h]", "tactic_state": "case inr\n\u03b1 : Type u_2\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhI : M.Indep I\nh : e \u2209 I\n\u22a2 e \u2208 M.E \\ M.closure I \u2194 e \u2208 M.E \\ M.closure I \u2228 e \u2208 I"}, {"line": "rw [or_iff_left h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma insert_indep_iff : M.Indep (insert e I) \u2194 M.Indep I \u2227 (e \u2209 I \u2192 e \u2208 M.E \\ M.closure I) := by\n  by_cases hI : M.Indep I\n  \u00b7 rw [hI.insert_indep_iff, and_iff_right hI, or_iff_not_imp_right]\n  simp [hI, show \u00ac M.Indep (insert e I) from fun h \u21a6 hI <| h.subset <| subset_insert _ _]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\n\u22a2 M.Indep (insert e I) \u2194 M.Indep I \u2227 (e \u2209 I \u2192 e \u2208 M.E \\ M.closure I)"}, {"line": "by_cases hI : M.Indep I", "tactic_state": "case pos\n\u03b1 : Type u_2\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhI : M.Indep I\n\u22a2 M.Indep (insert e I) \u2194 M.Indep I \u2227 (e \u2209 I \u2192 e \u2208 M.E \\ M.closure I)\n---\ncase neg\n\u03b1 : Type u_2\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhI : \u00acM.Indep I\n\u22a2 M.Indep (insert e I) \u2194 M.Indep I \u2227 (e \u2209 I \u2192 e \u2208 M.E \\ M.closure I)"}, {"line": "\u00b7 rw [hI.insert_indep_iff, and_iff_right hI, or_iff_not_imp_right]", "tactic_state": "case neg\n\u03b1 : Type u_2\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhI : \u00acM.Indep I\n\u22a2 M.Indep (insert e I) \u2194 M.Indep I \u2227 (e \u2209 I \u2192 e \u2208 M.E \\ M.closure I)"}, {"line": "simp [hI, show \u00ac M.Indep (insert e I) from fun h \u21a6 hI <| h.subset <| subset_insert _ _]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Indep.insert_diff_indep_iff (hI : M.Indep (I \\ {e})) (heI : e \u2208 I) :\n    M.Indep (insert f I \\ {e}) \u2194 f \u2208 M.E \\ M.closure (I \\ {e}) \u2228 f \u2208 I := by\n  obtain rfl | hne := eq_or_ne e f\n  \u00b7 simp [hI, heI]\n  rw [\u2190 insert_diff_singleton_comm hne.symm]\n  rw [hI.insert_indep_iff]\n  rw [mem_diff_singleton]\n  rw [and_iff_left hne.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\ne f : \u03b1\nI : Set \u03b1\nhI : M.Indep (I \\ {e})\nheI : e \u2208 I\n\u22a2 M.Indep (insert f I \\ {e}) \u2194 f \u2208 M.E \\ M.closure (I \\ {e}) \u2228 f \u2208 I"}, {"line": "obtain rfl | hne := eq_or_ne e f", "tactic_state": "case inl\n\u03b1 : Type u_2\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhI : M.Indep (I \\ {e})\nheI : e \u2208 I\n\u22a2 M.Indep (insert e I \\ {e}) \u2194 e \u2208 M.E \\ M.closure (I \\ {e}) \u2228 e \u2208 I\n---\ncase inr\n\u03b1 : Type u_2\nM : Matroid \u03b1\ne f : \u03b1\nI : Set \u03b1\nhI : M.Indep (I \\ {e})\nheI : e \u2208 I\nhne : e \u2260 f\n\u22a2 M.Indep (insert f I \\ {e}) \u2194 f \u2208 M.E \\ M.closure (I \\ {e}) \u2228 f \u2208 I"}, {"line": "\u00b7 simp [hI, heI]", "tactic_state": "case inr\n\u03b1 : Type u_2\nM : Matroid \u03b1\ne f : \u03b1\nI : Set \u03b1\nhI : M.Indep (I \\ {e})\nheI : e \u2208 I\nhne : e \u2260 f\n\u22a2 M.Indep (insert f I \\ {e}) \u2194 f \u2208 M.E \\ M.closure (I \\ {e}) \u2228 f \u2208 I"}, {"line": "rw [\u2190 insert_diff_singleton_comm hne.symm]", "tactic_state": "case inr\n\u03b1 : Type u_2\nM : Matroid \u03b1\ne f : \u03b1\nI : Set \u03b1\nhI : M.Indep (I \\ {e})\nheI : e \u2208 I\nhne : e \u2260 f\n\u22a2 M.Indep (insert f (I \\ {e})) \u2194 f \u2208 M.E \\ M.closure (I \\ {e}) \u2228 f \u2208 I"}, {"line": "rw [hI.insert_indep_iff]", "tactic_state": "case inr\n\u03b1 : Type u_2\nM : Matroid \u03b1\ne f : \u03b1\nI : Set \u03b1\nhI : M.Indep (I \\ {e})\nheI : e \u2208 I\nhne : e \u2260 f\n\u22a2 f \u2208 M.E \\ M.closure (I \\ {e}) \u2228 f \u2208 I \\ {e} \u2194 f \u2208 M.E \\ M.closure (I \\ {e}) \u2228 f \u2208 I"}, {"line": "rw [mem_diff_singleton]", "tactic_state": "case inr\n\u03b1 : Type u_2\nM : Matroid \u03b1\ne f : \u03b1\nI : Set \u03b1\nhI : M.Indep (I \\ {e})\nheI : e \u2208 I\nhne : e \u2260 f\n\u22a2 f \u2208 M.E \\ M.closure (I \\ {e}) \u2228 f \u2208 I \u2227 f \u2260 e \u2194 f \u2208 M.E \\ M.closure (I \\ {e}) \u2228 f \u2208 I"}, {"line": "rw [and_iff_left hne.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Indep.closure_inter_eq_self_of_subset (hI : M.Indep I) (hJI : J \u2286 I) :\n    M.closure J \u2229 I = J := by\n  have hJ := hI.subset hJI\n  rw [subset_antisymm_iff]\n  rw [and_iff_left (subset_inter (M.subset_closure _) hJI)]\n  rintro e \u27e8heJ, heI\u27e9\n  exact hJ.isBasis_closure.mem_of_insert_indep heJ (hI.subset (insert_subset heI hJI))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJI : J \u2286 I\n\u22a2 M.closure J \u2229 I = J"}, {"line": "have hJ := hI.subset hJI", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJI : J \u2286 I\nhJ : M.Indep J\n\u22a2 M.closure J \u2229 I = J"}, {"line": "rw [subset_antisymm_iff]", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJI : J \u2286 I\nhJ : M.Indep J\n\u22a2 M.closure J \u2229 I \u2286 J \u2227 J \u2286 M.closure J \u2229 I"}, {"line": "rw [and_iff_left (subset_inter (M.subset_closure _) hJI)]", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJI : J \u2286 I\nhJ : M.Indep J\n\u22a2 M.closure J \u2229 I \u2286 J"}, {"line": "rintro e \u27e8heJ, heI\u27e9", "tactic_state": "case intro\n\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJI : J \u2286 I\nhJ : M.Indep J\ne : \u03b1\nheJ : e \u2208 M.closure J\nheI : e \u2208 I\n\u22a2 e \u2208 J"}, {"line": "exact hJ.isBasis_closure.mem_of_insert_indep heJ (hI.subset (insert_subset heI hJI))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma closure_iInter_eq_iInter_closure_of_iUnion_indep [h\u03b9 : Nonempty \u03b9] (Is : \u03b9 \u2192 Set \u03b1)\n    (h : M.Indep (\u22c3 i, Is i)) : M.closure (\u22c2 i, Is i) = (\u22c2 i, M.closure (Is i)) := by\n  convert h.closure_sInter_eq_biInter_closure_of_forall_subset (range_nonempty Is)\n    (by simp [subset_iUnion])\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Matroid \u03b1\nh\u03b9 : Nonempty \u03b9\nIs : \u03b9 \u2192 Set \u03b1\nh : M.Indep (\u22c3 i, Is i)\n\u22a2 M.closure (\u22c2 i, Is i) = \u22c2 i, M.closure (Is i)"}, {"line": "convert h.closure_sInter_eq_biInter_closure_of_forall_subset (range_nonempty Is)\n    (by simp [subset_iUnion])", "tactic_state": "case h.e'_3\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Matroid \u03b1\nh\u03b9 : Nonempty \u03b9\nIs : \u03b9 \u2192 Set \u03b1\nh : M.Indep (\u22c3 i, Is i)\n\u22a2 \u22c2 i, M.closure (Is i) = \u22c2 J \u2208 range Is, M.closure J\n---\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Matroid \u03b1\nh\u03b9 : Nonempty \u03b9\nIs : \u03b9 \u2192 Set \u03b1\nh : M.Indep (\u22c3 i, Is i)\n\u22a2 Nonempty \u03b9"}, {"line": "simp", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Matroid \u03b1\nh\u03b9 : Nonempty \u03b9\nIs : \u03b9 \u2192 Set \u03b1\nh : M.Indep (\u22c3 i, Is i)\n\u22a2 Nonempty \u03b9"}]}
{"declaration": "lemma Indep.inter_isBasis_sInter {Xs : Set (Set \u03b1)} (hI : M.Indep I) (hXs : Xs.Nonempty)\n    (h : \u2200 X \u2208 Xs, M.IsBasis (X \u2229 I) X) : M.IsBasis (\u22c2\u2080 Xs \u2229 I) (\u22c2\u2080 Xs) := by\n  rw [sInter_eq_biInter]\n  exact hI.inter_isBasis_biInter hXs h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nI : Set \u03b1\nXs : Set (Set \u03b1)\nhI : M.Indep I\nhXs : Xs.Nonempty\nh : \u2200 X \u2208 Xs, M.IsBasis (X \u2229 I) X\n\u22a2 M.IsBasis (\u22c2\u2080 Xs \u2229 I) (\u22c2\u2080 Xs)"}, {"line": "rw [sInter_eq_biInter]", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nI : Set \u03b1\nXs : Set (Set \u03b1)\nhI : M.Indep I\nhXs : Xs.Nonempty\nh : \u2200 X \u2208 Xs, M.IsBasis (X \u2229 I) X\n\u22a2 M.IsBasis ((\u22c2 i \u2208 Xs, i) \u2229 I) (\u22c2 i \u2208 Xs, i)"}, {"line": "exact hI.inter_isBasis_biInter hXs h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsBasis.closure_inter_isBasis_closure (h : M.IsBasis (X \u2229 I) X) (hI : M.Indep I) :\n    M.IsBasis (M.closure X \u2229 I) (M.closure X) := by\n  rw [hI.inter_isBasis_closure_iff_subset_closure_inter] at h \u22a2\n  exact (M.closure_subset_closure_of_subset_closure h).trans (M.closure_subset_closure\n    (inter_subset_inter_left _ (h.trans (M.closure_subset_closure inter_subset_left))))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX I : Set \u03b1\nh : M.IsBasis (X \u2229 I) X\nhI : M.Indep I\n\u22a2 M.IsBasis (M.closure X \u2229 I) (M.closure X)"}, {"line": "rw [hI.inter_isBasis_closure_iff_subset_closure_inter] at h \u22a2", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX I : Set \u03b1\nh : X \u2286 M.closure (X \u2229 I)\nhI : M.Indep I\n\u22a2 M.closure X \u2286 M.closure (M.closure X \u2229 I)"}, {"line": "exact (M.closure_subset_closure_of_subset_closure h).trans (M.closure_subset_closure\n    (inter_subset_inter_left _ (h.trans (M.closure_subset_closure inter_subset_left))))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsBasis.eq_of_closure_subset (hI : M.IsBasis I X) (hJI : J \u2286 I) (hJ : X \u2286 M.closure J) :\n    J = I := by\n  rw [\u2190 hI.indep.closure_inter_eq_self_of_subset hJI]\n  rw [inter_eq_self_of_subset_right]\n  exact hI.subset.trans hJ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX I J : Set \u03b1\nhI : M.IsBasis I X\nhJI : J \u2286 I\nhJ : X \u2286 M.closure J\n\u22a2 J = I"}, {"line": "rw [\u2190 hI.indep.closure_inter_eq_self_of_subset hJI]", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX I J : Set \u03b1\nhI : M.IsBasis I X\nhJI : J \u2286 I\nhJ : X \u2286 M.closure J\n\u22a2 M.closure J \u2229 I = I"}, {"line": "rw [inter_eq_self_of_subset_right]", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX I J : Set \u03b1\nhI : M.IsBasis I X\nhJI : J \u2286 I\nhJ : X \u2286 M.closure J\n\u22a2 I \u2286 M.closure J"}, {"line": "exact hI.subset.trans hJ", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Indep.union_indep_iff_forall_not_mem_closure_right (hI : M.Indep I) (hJ : M.Indep J) :\n    M.Indep (I \u222a J) \u2194 \u2200 e \u2208 J \\ I, e \u2209 M.closure (I \u222a (J \\ {e})) := by\n  refine \u27e8fun h e heJ hecl \u21a6 h.not_mem_closure_diff_of_mem (.inr heJ.1) ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 rwa [union_diff_distrib, diff_singleton_eq_self heJ.2]\n  obtain \u27e8K, hKIJ, hK\u27e9 := hI.subset_isBasis_of_subset (show I \u2286 I \u222a J from subset_union_left)\n  obtain rfl | hssu := hKIJ.subset.eq_or_ssubset\n  \u00b7 exact hKIJ.indep\n  exfalso\n  obtain \u27e8e, heI, heK\u27e9 := exists_of_ssubset hssu\n  have heJI : e \u2208 J \\ I := by\n    rw [\u2190 union_diff_right]\n    rw [union_comm]\n    exact \u27e8heI, not_mem_subset hK heK\u27e9\n  refine h _ heJI ?_\n  rw [\u2190 diff_singleton_eq_self heJI.2]\n  rw [\u2190 union_diff_distrib]\n  exact M.closure_subset_closure (subset_diff_singleton hKIJ.subset heK) <| hKIJ.subset_closure heI\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\n\u22a2 M.Indep (I \u222a J) \u2194 \u2200 e \u2208 J \\ I, e \u2209 M.closure (I \u222a J \\ {e})"}, {"line": "refine \u27e8fun h e heJ hecl \u21a6 h.not_mem_closure_diff_of_mem (.inr heJ.1) ?_, fun h \u21a6 ?_\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nh : M.Indep (I \u222a J)\ne : \u03b1\nheJ : e \u2208 J \\ I\nhecl : e \u2208 M.closure (I \u222a J \\ {e})\n\u22a2 e \u2208 M.closure ((I \u222a J) \\ {e})\n---\ncase refine_2\n\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nh : \u2200 e \u2208 J \\ I, e \u2209 M.closure (I \u222a J \\ {e})\n\u22a2 M.Indep (I \u222a J)"}, {"line": "\u00b7 rwa [union_diff_distrib, diff_singleton_eq_self heJ.2]", "tactic_state": "case refine_2\n\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nh : \u2200 e \u2208 J \\ I, e \u2209 M.closure (I \u222a J \\ {e})\n\u22a2 M.Indep (I \u222a J)"}, {"line": "obtain \u27e8K, hKIJ, hK\u27e9 := hI.subset_isBasis_of_subset (show I \u2286 I \u222a J from subset_union_left)", "tactic_state": "case refine_2.intro.intro\n\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nh : \u2200 e \u2208 J \\ I, e \u2209 M.closure (I \u222a J \\ {e})\nK : Set \u03b1\nhKIJ : M.IsBasis K (I \u222a J)\nhK : I \u2286 K\n\u22a2 M.Indep (I \u222a J)"}, {"line": "obtain rfl | hssu := hKIJ.subset.eq_or_ssubset", "tactic_state": "case refine_2.intro.intro.inl\n\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nh : \u2200 e \u2208 J \\ I, e \u2209 M.closure (I \u222a J \\ {e})\nhKIJ : M.IsBasis (I \u222a J) (I \u222a J)\nhK : I \u2286 I \u222a J\n\u22a2 M.Indep (I \u222a J)\n---\ncase refine_2.intro.intro.inr\n\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nh : \u2200 e \u2208 J \\ I, e \u2209 M.closure (I \u222a J \\ {e})\nK : Set \u03b1\nhKIJ : M.IsBasis K (I \u222a J)\nhK : I \u2286 K\nhssu : K \u2282 I \u222a J\n\u22a2 M.Indep (I \u222a J)"}, {"line": "\u00b7 exact hKIJ.indep", "tactic_state": "case refine_2.intro.intro.inr\n\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nh : \u2200 e \u2208 J \\ I, e \u2209 M.closure (I \u222a J \\ {e})\nK : Set \u03b1\nhKIJ : M.IsBasis K (I \u222a J)\nhK : I \u2286 K\nhssu : K \u2282 I \u222a J\n\u22a2 M.Indep (I \u222a J)"}, {"line": "exfalso", "tactic_state": "case refine_2.intro.intro.inr\n\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nh : \u2200 e \u2208 J \\ I, e \u2209 M.closure (I \u222a J \\ {e})\nK : Set \u03b1\nhKIJ : M.IsBasis K (I \u222a J)\nhK : I \u2286 K\nhssu : K \u2282 I \u222a J\n\u22a2 False"}, {"line": "obtain \u27e8e, heI, heK\u27e9 := exists_of_ssubset hssu", "tactic_state": "case refine_2.intro.intro.inr.intro.intro\n\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nh : \u2200 e \u2208 J \\ I, e \u2209 M.closure (I \u222a J \\ {e})\nK : Set \u03b1\nhKIJ : M.IsBasis K (I \u222a J)\nhK : I \u2286 K\nhssu : K \u2282 I \u222a J\ne : \u03b1\nheI : e \u2208 I \u222a J\nheK : e \u2209 K\n\u22a2 False"}, {"line": "have heJI : e \u2208 J \\ I := sorry", "tactic_state": "case refine_2.intro.intro.inr.intro.intro\n\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nh : \u2200 e \u2208 J \\ I, e \u2209 M.closure (I \u222a J \\ {e})\nK : Set \u03b1\nhKIJ : M.IsBasis K (I \u222a J)\nhK : I \u2286 K\nhssu : K \u2282 I \u222a J\ne : \u03b1\nheI : e \u2208 I \u222a J\nheK : e \u2209 K\nheJI : e \u2208 J \\ I\n\u22a2 False"}, {"line": "refine h _ heJI ?_", "tactic_state": "case refine_2.intro.intro.inr.intro.intro\n\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nh : \u2200 e \u2208 J \\ I, e \u2209 M.closure (I \u222a J \\ {e})\nK : Set \u03b1\nhKIJ : M.IsBasis K (I \u222a J)\nhK : I \u2286 K\nhssu : K \u2282 I \u222a J\ne : \u03b1\nheI : e \u2208 I \u222a J\nheK : e \u2209 K\nheJI : e \u2208 J \\ I\n\u22a2 e \u2208 M.closure (I \u222a J \\ {e})"}, {"line": "rw [\u2190 diff_singleton_eq_self heJI.2]", "tactic_state": "case refine_2.intro.intro.inr.intro.intro\n\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nh : \u2200 e \u2208 J \\ I, e \u2209 M.closure (I \u222a J \\ {e})\nK : Set \u03b1\nhKIJ : M.IsBasis K (I \u222a J)\nhK : I \u2286 K\nhssu : K \u2282 I \u222a J\ne : \u03b1\nheI : e \u2208 I \u222a J\nheK : e \u2209 K\nheJI : e \u2208 J \\ I\n\u22a2 e \u2208 M.closure (I \\ {e} \u222a J \\ {e})"}, {"line": "rw [\u2190 union_diff_distrib]", "tactic_state": "case refine_2.intro.intro.inr.intro.intro\n\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nh : \u2200 e \u2208 J \\ I, e \u2209 M.closure (I \u222a J \\ {e})\nK : Set \u03b1\nhKIJ : M.IsBasis K (I \u222a J)\nhK : I \u2286 K\nhssu : K \u2282 I \u222a J\ne : \u03b1\nheI : e \u2208 I \u222a J\nheK : e \u2209 K\nheJI : e \u2208 J \\ I\n\u22a2 e \u2208 M.closure ((I \u222a J) \\ {e})"}, {"line": "exact M.closure_subset_closure (subset_diff_singleton hKIJ.subset heK) <| hKIJ.subset_closure heI", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Indep.union_indep_iff_forall_not_mem_closure_left (hI : M.Indep I) (hJ : M.Indep J) :\n    M.Indep (I \u222a J) \u2194 \u2200 e \u2208 I \\ J, e \u2209 M.closure ((I \\ {e}) \u222a J) := by\n  simp_rw [union_comm I J, hJ.union_indep_iff_forall_not_mem_closure_right hI, union_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\n\u22a2 M.Indep (I \u222a J) \u2194 \u2200 e \u2208 I \\ J, e \u2209 M.closure (I \\ {e} \u222a J)"}, {"line": "simp_rw [union_comm I J, hJ.union_indep_iff_forall_not_mem_closure_right hI, union_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Indep.closure_ssubset_closure (hI : M.Indep I) (hJI : J \u2282 I) : M.closure J \u2282 M.closure I := by\n  obtain \u27e8e, heI, heJ\u27e9 := exists_of_ssubset hJI\n  exact (M.closure_subset_closure hJI.subset).ssubset_of_not_subset fun hss \u21a6 heJ <|\n    (hI.closure_inter_eq_self_of_subset hJI.subset).subset \u27e8hss (M.mem_closure_of_mem heI), heI\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJI : J \u2282 I\n\u22a2 M.closure J \u2282 M.closure I"}, {"line": "obtain \u27e8e, heI, heJ\u27e9 := exists_of_ssubset hJI", "tactic_state": "case intro.intro\n\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJI : J \u2282 I\ne : \u03b1\nheI : e \u2208 I\nheJ : e \u2209 J\n\u22a2 M.closure J \u2282 M.closure I"}, {"line": "exact (M.closure_subset_closure hJI.subset).ssubset_of_not_subset fun hss \u21a6 heJ <|\n    (hI.closure_inter_eq_self_of_subset hJI.subset).subset \u27e8hss (M.mem_closure_of_mem heI), heI\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Indep.closure_diff_ssubset (hI : M.Indep I) (hX : (I \u2229 X).Nonempty) :\n    M.closure (I \\ X) \u2282 M.closure I := by\n  refine hI.closure_ssubset_closure <| diff_subset.ssubset_of_ne fun h \u21a6 ?_\n  rw [sdiff_eq_left] at h\n  rw [disjoint_iff_inter_eq_empty] at h\n  simp [h] at hX\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX I : Set \u03b1\nhI : M.Indep I\nhX : (I \u2229 X).Nonempty\n\u22a2 M.closure (I \\ X) \u2282 M.closure I"}, {"line": "refine hI.closure_ssubset_closure <| diff_subset.ssubset_of_ne fun h \u21a6 ?_", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX I : Set \u03b1\nhI : M.Indep I\nhX : (I \u2229 X).Nonempty\nh : I \\ X = I\n\u22a2 False"}, {"line": "rw [sdiff_eq_left] at h", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX I : Set \u03b1\nhI : M.Indep I\nhX : (I \u2229 X).Nonempty\nh : Disjoint I X\n\u22a2 False"}, {"line": "rw [disjoint_iff_inter_eq_empty] at h", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nX I : Set \u03b1\nhI : M.Indep I\nhX : (I \u2229 X).Nonempty\nh : I \u2229 X = \u2205\n\u22a2 False"}, {"line": "simp [h] at hX", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Indep.exists_isBase_subset_spanning (hI : M.Indep I) (hS : M.Spanning S) (hIS : I \u2286 S) :\n    \u2203 B, M.IsBase B \u2227 I \u2286 B \u2227 B \u2286 S := by\n  obtain \u27e8B, hB\u27e9 := hI.subset_isBasis_of_subset hIS\n  exact \u27e8B, hB.1.isBase_of_spanning hS, hB.2, hB.1.subset\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}", "{S T I B : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nS I : Set \u03b1\nhI : M.Indep I\nhS : M.Spanning S\nhIS : I \u2286 S\n\u22a2 \u2203 B, M.IsBase B \u2227 I \u2286 B \u2227 B \u2286 S"}, {"line": "obtain \u27e8B, hB\u27e9 := hI.subset_isBasis_of_subset hIS", "tactic_state": "case intro\n\u03b1 : Type u_2\nM : Matroid \u03b1\nS I : Set \u03b1\nhI : M.Indep I\nhS : M.Spanning S\nhIS : I \u2286 S\nB : Set \u03b1\nhB : M.IsBasis B S \u2227 I \u2286 B\n\u22a2 \u2203 B, M.IsBase B \u2227 I \u2286 B \u2227 B \u2286 S"}, {"line": "exact \u27e8B, hB.1.isBase_of_spanning hS, hB.2, hB.1.subset\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isBase_iff_minimal_spanning : M.IsBase B \u2194 Minimal M.Spanning B := by\n  rw [minimal_subset_iff]\n  refine \u27e8fun h \u21a6 \u27e8h.spanning, fun _ \u21a6 h.eq_of_superset_spanning\u27e9, fun \u27e8h, h'\u27e9 \u21a6 ?_\u27e9\n  obtain \u27e8B', hB', hBB'\u27e9 := h.exists_isBase_subset\n  rwa [h' hB'.spanning hBB']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Closure.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}", "{S T I B : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nB : Set \u03b1\n\u22a2 M.IsBase B \u2194 Minimal M.Spanning B"}, {"line": "rw [minimal_subset_iff]", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nB : Set \u03b1\n\u22a2 M.IsBase B \u2194 M.Spanning B \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Spanning t \u2192 t \u2286 B \u2192 B = t"}, {"line": "refine \u27e8fun h \u21a6 \u27e8h.spanning, fun _ \u21a6 h.eq_of_superset_spanning\u27e9, fun \u27e8h, h'\u27e9 \u21a6 ?_\u27e9", "tactic_state": "\u03b1 : Type u_2\nM : Matroid \u03b1\nB : Set \u03b1\nx\u271d : M.Spanning B \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Spanning t \u2192 t \u2286 B \u2192 B = t\nh : M.Spanning B\nh' : \u2200 \u2983t : Set \u03b1\u2984, M.Spanning t \u2192 t \u2286 B \u2192 B = t\n\u22a2 M.IsBase B"}, {"line": "obtain \u27e8B', hB', hBB'\u27e9 := h.exists_isBase_subset", "tactic_state": "case intro.intro\n\u03b1 : Type u_2\nM : Matroid \u03b1\nB : Set \u03b1\nx\u271d : M.Spanning B \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Spanning t \u2192 t \u2286 B \u2192 B = t\nh : M.Spanning B\nh' : \u2200 \u2983t : Set \u03b1\u2984, M.Spanning t \u2192 t \u2286 B \u2192 B = t\nB' : Set \u03b1\nhB' : M.IsBase B'\nhBB' : B' \u2286 B\n\u22a2 M.IsBase B"}, {"line": "rwa [h' hB'.spanning hBB']", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isLoop_tfae (M : Matroid \u03b1) (e : \u03b1) : List.TFAE [\n    M.IsLoop e,\n    e \u2208 M.closure \u2205,\n    M.IsCircuit {e},\n    M.Dep {e},\n    \u2200 \u2983B\u2984, M.IsBase B \u2192 e \u2208 M.E \\ B] := by\n  tfae_have 1 \u2194 2 := Iff.rfl\n  tfae_have 2 \u2194 3 := by simp [M.empty_indep.mem_closure_iff_of_not_mem (not_mem_empty e),\n    isCircuit_def, minimal_iff_forall_ssubset, ssubset_singleton_iff]\n  tfae_have 2 \u2194 4 := by simp [M.empty_indep.mem_closure_iff_of_not_mem (not_mem_empty e)]\n  tfae_have 4 \u2194 5 := by\n    simp only [dep_iff]\n    simp only [singleton_subset_iff]\n    simp only [mem_diff]\n    simp only [forall_and]\n    refine \u27e8fun h \u21a6 \u27e8fun _ _ \u21a6 h.2, fun B hB heB \u21a6 h.1 (hB.indep.subset (by simpa))\u27e9,\n      fun h \u21a6 \u27e8fun hi \u21a6 ?_, h.1 _ M.exists_isBase.choose_spec\u27e9\u27e9\n    obtain \u27e8B, hB, heB\u27e9 := hi.exists_isBase_superset\n    exact h.2 _ hB (by simpa using heB)\n  tfae_finish\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\n\u22a2 [M.IsLoop e, e \u2208 M.closure \u2205, M.IsCircuit {e}, M.Dep {e}, \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 M.E \\ B].TFAE"}, {"line": "tfae_have 1 \u2194 2 := Iff.rfl", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\ntfae_1_iff_2 : M.IsLoop e \u2194 e \u2208 M.closure \u2205\n\u22a2 [M.IsLoop e, e \u2208 M.closure \u2205, M.IsCircuit {e}, M.Dep {e}, \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 M.E \\ B].TFAE"}, {"line": "tfae_have 2 \u2194 3 := by simp [M.empty_indep.mem_closure_iff_of_not_mem (not_mem_empty e),\n    isCircuit_def, minimal_iff_forall_ssubset, ssubset_singleton_iff]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\ntfae_1_iff_2 : M.IsLoop e \u2194 e \u2208 M.closure \u2205\ntfae_2_iff_3 : e \u2208 M.closure \u2205 \u2194 M.IsCircuit {e}\n\u22a2 [M.IsLoop e, e \u2208 M.closure \u2205, M.IsCircuit {e}, M.Dep {e}, \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 M.E \\ B].TFAE"}, {"line": "tfae_have 2 \u2194 4 := by simp [M.empty_indep.mem_closure_iff_of_not_mem (not_mem_empty e)]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\ntfae_1_iff_2 : M.IsLoop e \u2194 e \u2208 M.closure \u2205\ntfae_2_iff_3 : e \u2208 M.closure \u2205 \u2194 M.IsCircuit {e}\ntfae_2_iff_4 : e \u2208 M.closure \u2205 \u2194 M.Dep {e}\n\u22a2 [M.IsLoop e, e \u2208 M.closure \u2205, M.IsCircuit {e}, M.Dep {e}, \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 M.E \\ B].TFAE"}, {"line": "tfae_have 4 \u2194 5 := by\n    simp only [dep_iff]\n    simp only [singleton_subset_iff]\n    simp only [mem_diff]\n    simp only [forall_and]\n    refine \u27e8fun h \u21a6 \u27e8fun _ _ \u21a6 h.2, fun B hB heB \u21a6 h.1 (hB.indep.subset (by simpa))\u27e9,\n      fun h \u21a6 \u27e8fun hi \u21a6 ?_, h.1 _ M.exists_isBase.choose_spec\u27e9\u27e9\n    obtain \u27e8B, hB, heB\u27e9 := hi.exists_isBase_superset\n    exact h.2 _ hB (by simpa using heB)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\ntfae_1_iff_2 : M.IsLoop e \u2194 e \u2208 M.closure \u2205\ntfae_2_iff_3 : e \u2208 M.closure \u2205 \u2194 M.IsCircuit {e}\ntfae_2_iff_4 : e \u2208 M.closure \u2205 \u2194 M.Dep {e}\ntfae_4_iff_5 : M.Dep {e} \u2194 \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 M.E \\ B\n\u22a2 [M.IsLoop e, e \u2208 M.closure \u2205, M.IsCircuit {e}, M.Dep {e}, \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 M.E \\ B].TFAE"}, {"line": "tfae_finish", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsLoop.eq_of_isCircuit_mem (he : M.IsLoop e) (hC : M.IsCircuit C) (h : e \u2208 C) : C = {e} := by\n  rw [he.isCircuit.eq_of_subset_isCircuit hC (singleton_subset_iff.mpr h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\nC : Set \u03b1\nhe : M.IsLoop e\nhC : M.IsCircuit C\nh : e \u2208 C\n\u22a2 C = {e}"}, {"line": "rw [he.isCircuit.eq_of_subset_isCircuit hC (singleton_subset_iff.mpr h)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma closure_loops_union_eq (M : Matroid \u03b1) (X : Set \u03b1) :\n    M.closure (M.loops \u222a X) = M.closure X := by\n  simp [union_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\n\u22a2 M.closure (M.loops \u222a X) = M.closure X"}, {"line": "simp [union_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_loops {f : \u03b1 \u2192 \u03b2} {hf : InjOn f M.E} : (M.map f hf).loops = f '' M.loops := by\n  simp [loops]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nM : Matroid \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : InjOn f M.E\n\u22a2 (M.map f hf).loops = f '' M.loops"}, {"line": "simp [loops]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mapEmbedding_isLoop_iff {f : \u03b1 \u21aa \u03b2} : (M.mapEmbedding f).IsLoop (f e) \u2194 M.IsLoop e := by\n  simp [mapEmbedding, isLoop_iff, isLoop_iff, map_closure_eq, preimage_empty, \u2190 closure_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nM : Matroid \u03b1\ne : \u03b1\nf : \u03b1 \u21aa \u03b2\n\u22a2 (M.mapEmbedding f).IsLoop (f e) \u2194 M.IsLoop e"}, {"line": "simp [mapEmbedding, isLoop_iff, isLoop_iff, map_closure_eq, preimage_empty, \u2190 closure_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comap_isLoop_iff {M : Matroid \u03b2} {f : \u03b1 \u2192 \u03b2} : (M.comap f).IsLoop e \u2194 M.IsLoop (f e) := by\n  simp [isLoop_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ne : \u03b1\nM : Matroid \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 (M.comap f).IsLoop e \u2194 M.IsLoop (f e)"}, {"line": "simp [isLoop_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma loopyOn_isLoop_iff {E : Set \u03b1} : (loopyOn E).IsLoop e \u2194 e \u2208 E := by\n  simp [isLoop_iff, loops]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ne : \u03b1\nx\u271d : Sort u_3\nloopyOn : x\u271d\nE : Set \u03b1\n\u22a2 sorry \u2194 e \u2208 E"}, {"line": "simp [isLoop_iff, loops]", "tactic_state": "\u03b1 : Type u_1\ne : \u03b1\nx\u271d : Sort u_3\nloopyOn : x\u271d\nE : Set \u03b1\n\u22a2 sorry () \u2194 e \u2208 E"}]}
{"declaration": "lemma freeOn_not_isLoop (E : Set \u03b1) (e : \u03b1) : \u00ac (freeOn E).IsLoop e := by\n  simp [isLoop_iff, loops]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\nfreeOn : x\u271d\nE : Set \u03b1\ne : \u03b1\n\u22a2 \u00acsorry"}, {"line": "simp [isLoop_iff, loops]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\nfreeOn : x\u271d\nE : Set \u03b1\ne : \u03b1\n\u22a2 \u00acsorry ()"}]}
{"declaration": "lemma uniqueBaseOn_isLoop_iff {I E : Set \u03b1} : (uniqueBaseOn I E).IsLoop e \u2194 e \u2208 E \\ I := by\n  simp [isLoop_iff, loops]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ne : \u03b1\nx\u271d : Sort u_3\nuniqueBaseOn : x\u271d\nI E : Set \u03b1\n\u22a2 sorry \u2194 e \u2208 E \\ I"}, {"line": "simp [isLoop_iff, loops]", "tactic_state": "\u03b1 : Type u_1\ne : \u03b1\nx\u271d : Sort u_3\nuniqueBaseOn : x\u271d\nI E : Set \u03b1\n\u22a2 sorry () \u2194 e \u2208 E \u2227 e \u2209 I"}]}
{"declaration": "lemma compl_loops_eq (M : Matroid \u03b1) : M.E \\ M.loops = {e | M.IsNonloop e} := by\n  simp [Set.ext_iff, isNonloop_iff, and_comm, isLoop_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\n\u22a2 M.E \\ M.loops = {e | M.IsNonloop e}"}, {"line": "simp [Set.ext_iff, isNonloop_iff, and_comm, isLoop_iff]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\n\u22a2 \u2200 (x : \u03b1), x \u2208 M.E \u2227 x \u2209 M.loops \u2194 M.IsNonloop x"}]}
{"declaration": "lemma not_isNonloop_iff_closure : \u00ac M.IsNonloop e \u2194 M.closure {e} = M.loops := by\n  by_cases he : e \u2208 M.E\n  \u00b7 simp [IsNonloop, isLoop_iff_closure_eq_loops_and_mem_ground, he]\n  simp [\u2190 closure_inter_ground, singleton_inter_eq_empty.2 he, loops,\n    (show \u00ac M.IsNonloop e from fun h \u21a6 he h.mem_ground)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\n\u22a2 \u00acM.IsNonloop e \u2194 M.closure {e} = M.loops"}, {"line": "by_cases he : e \u2208 M.E", "tactic_state": "case pos\n\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\nhe : e \u2208 M.E\n\u22a2 \u00acM.IsNonloop e \u2194 M.closure {e} = M.loops\n---\ncase neg\n\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\nhe : e \u2209 M.E\n\u22a2 \u00acM.IsNonloop e \u2194 M.closure {e} = M.loops"}, {"line": "\u00b7 simp [IsNonloop, isLoop_iff_closure_eq_loops_and_mem_ground, he]", "tactic_state": "case neg\n\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\nhe : e \u2209 M.E\n\u22a2 \u00acM.IsNonloop e \u2194 M.closure {e} = M.loops"}, {"line": "simp [\u2190 closure_inter_ground, singleton_inter_eq_empty.2 he, loops,\n    (show \u00ac M.IsNonloop e from fun h \u21a6 he h.mem_ground)]", "tactic_state": "case neg\n\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\nhe : e \u2209 M.E\n\u22a2 M.closure {e} = M.loops"}]}
{"declaration": "lemma IsNonloop.exists_mem_isBase (he : M.IsNonloop e) : \u2203 B, M.IsBase B \u2227 e \u2208 B := by\n  simpa using (indep_singleton.2 he).exists_isBase_superset\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\nhe : M.IsNonloop e\n\u22a2 \u2203 B, M.IsBase B \u2227 e \u2208 B"}, {"line": "simpa using (indep_singleton.2 he).exists_isBase_superset", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsNonloop.mem_closure_singleton (he : M.IsNonloop e) (hef : e \u2208 M.closure {f}) :\n    f \u2208 M.closure {e} := by\n  rw [\u2190 union_empty {_}] at *\n  rw [singleton_union] at *\n  exact (M.closure_exchange (X := \u2205)\n    \u27e8hef, (isNonloop_iff_not_mem_loops he.mem_ground).1 he\u27e9).1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne f : \u03b1\nhe : M.IsNonloop e\nhef : e \u2208 M.closure {f}\n\u22a2 f \u2208 M.closure {e}"}, {"line": "rw [\u2190 union_empty {_}] at *", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne f : \u03b1\nhe : M.IsNonloop e\nhef : e \u2208 M.closure ({f} \u222a \u2205)\n\u22a2 f \u2208 M.closure ({e} \u222a \u2205)"}, {"line": "rw [singleton_union] at *", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne f : \u03b1\nhe : M.IsNonloop e\nhef : e \u2208 M.closure (insert f \u2205)\n\u22a2 f \u2208 M.closure (insert e \u2205)"}, {"line": "exact (M.closure_exchange (X := \u2205)\n    \u27e8hef, (isNonloop_iff_not_mem_loops he.mem_ground).1 he\u27e9).1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma singleton_isCocircuit : M.IsCocircuit {e} \u2194 M.IsColoop e := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}", "{B K : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\n\u22a2 M.IsCocircuit {e} \u2194 M.IsColoop e"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isColoop_tfae (M : Matroid \u03b1) (e : \u03b1) : List.TFAE [\n    M.IsColoop e,\n    e \u2208 M.coloops,\n    M.IsCocircuit {e},\n    \u2200 \u2983B\u2984, M.IsBase B \u2192 e \u2208 B,\n    (\u2200 \u2983C\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E,\n    \u2200 X, e \u2208 M.closure X \u2194 e \u2208 X,\n    \u00ac M.Spanning (M.E \\ {e}) ] := by\n  tfae_have 1 <-> 2 := Iff.rfl\n  tfae_have 1 <-> 3 := singleton_isCocircuit.symm\n  tfae_have 1 <-> 4 := by\n    simp_rw [\u2190 dual_isLoop_iff_isColoop, isLoop_iff_forall_mem_compl_isBase]\n    refine \u27e8fun h B hB \u21a6 ?_, fun h B hB \u21a6 h hB.compl_isBase_of_dual\u27e9\n    obtain \u27e8-, heB : e \u2208 B\u27e9 := by simpa using h (M.E \\ B) hB.compl_isBase_dual\n    assumption\n  tfae_have 3 -> 5 := fun h \u21a6\n    \u27e8fun C hC heC \u21a6 hC.inter_isCocircuit_ne_singleton h (e := e) (by simpa), h.subset_ground rfl\u27e9\n  tfae_have 5 -> 4 := by\n    refine fun \u27e8h, heE\u27e9 B hB \u21a6 by_contra fun heB \u21a6 ?_\n    rw [\u2190 hB.closure_eq] at heE\n    obtain \u27e8C, -, hC, heC\u27e9 := (mem_closure_iff_exists_isCircuit heB).1 heE\n    exact h hC heC\n  tfae_have 5 <-> 6 := by\n    refine \u27e8fun h X \u21a6 \u27e8fun heX \u21a6 by_contra fun heX' \u21a6 ?_, fun heX \u21a6 M.mem_closure_of_mem' heX h.2\u27e9,\n      fun h \u21a6 \u27e8fun C hC heC \u21a6 ?_, M.closure_subset_ground _ <| (h {e}).2 rfl\u27e9\u27e9\n    \u00b7 obtain \u27e8C, -, hC, heC\u27e9 := (mem_closure_iff_exists_isCircuit heX').1 heX\n      exact h.1 hC heC\n    \u00b7 simpa [hC.mem_closure_diff_singleton_of_mem heC] using h (C \\ {e})\n  tfae_have 1 <-> 7 := by\n    wlog he : e \u2208 M.E\n    \u00b7 exact iff_of_false (fun h \u21a6 he h.mem_ground) <| by simp [he, M.ground_spanning]\n    rw [spanning_iff_compl_coindep diff_subset]\n    rw [\u2190 dual_isLoop_iff_isColoop]\n    rw [\u2190 singleton_dep]\n    rw [diff_diff_cancel_left (by simpa)]\n    rw [\u2190 not_indep_iff (by simpa)]\n  tfae_finish\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}", "{B K : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\n\u22a2 [M.IsColoop e, e \u2208 M.coloops, M.IsCocircuit {e}, \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 B,\n      (\u2200 \u2983C : Set \u03b1\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E, \u2200 (X : Set \u03b1), e \u2208 M.closure X \u2194 e \u2208 X,\n      \u00acM.Spanning (M.E \\ {e})].TFAE"}, {"line": "tfae_have 1 <-> 2 := Iff.rfl", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\ntfae_1_iff_2 : M.IsColoop e \u2194 e \u2208 M.coloops\n\u22a2 [M.IsColoop e, e \u2208 M.coloops, M.IsCocircuit {e}, \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 B,\n      (\u2200 \u2983C : Set \u03b1\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E, \u2200 (X : Set \u03b1), e \u2208 M.closure X \u2194 e \u2208 X,\n      \u00acM.Spanning (M.E \\ {e})].TFAE"}, {"line": "tfae_have 1 <-> 3 := singleton_isCocircuit.symm", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\ntfae_1_iff_2 : M.IsColoop e \u2194 e \u2208 M.coloops\ntfae_1_iff_3 : M.IsColoop e \u2194 M.IsCocircuit {e}\n\u22a2 [M.IsColoop e, e \u2208 M.coloops, M.IsCocircuit {e}, \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 B,\n      (\u2200 \u2983C : Set \u03b1\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E, \u2200 (X : Set \u03b1), e \u2208 M.closure X \u2194 e \u2208 X,\n      \u00acM.Spanning (M.E \\ {e})].TFAE"}, {"line": "tfae_have 1 <-> 4 := by\n    simp_rw [\u2190 dual_isLoop_iff_isColoop, isLoop_iff_forall_mem_compl_isBase]\n    refine \u27e8fun h B hB \u21a6 ?_, fun h B hB \u21a6 h hB.compl_isBase_of_dual\u27e9\n    obtain \u27e8-, heB : e \u2208 B\u27e9 := by simpa using h (M.E \\ B) hB.compl_isBase_dual\n    assumption", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\ntfae_1_iff_2 : M.IsColoop e \u2194 e \u2208 M.coloops\ntfae_1_iff_3 : M.IsColoop e \u2194 M.IsCocircuit {e}\ntfae_1_iff_4 : M.IsColoop e \u2194 \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 B\n\u22a2 [M.IsColoop e, e \u2208 M.coloops, M.IsCocircuit {e}, \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 B,\n      (\u2200 \u2983C : Set \u03b1\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E, \u2200 (X : Set \u03b1), e \u2208 M.closure X \u2194 e \u2208 X,\n      \u00acM.Spanning (M.E \\ {e})].TFAE"}, {"line": "tfae_have 3 -> 5 := fun h \u21a6\n    \u27e8fun C hC heC \u21a6 hC.inter_isCocircuit_ne_singleton h (e := e) (by simpa), h.subset_ground rfl\u27e9", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\ntfae_1_iff_2 : M.IsColoop e \u2194 e \u2208 M.coloops\ntfae_1_iff_3 : M.IsColoop e \u2194 M.IsCocircuit {e}\ntfae_1_iff_4 : M.IsColoop e \u2194 \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 B\ntfae_3_to_5 : M.IsCocircuit {e} \u2192 (\u2200 \u2983C : Set \u03b1\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E\n\u22a2 [M.IsColoop e, e \u2208 M.coloops, M.IsCocircuit {e}, \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 B,\n      (\u2200 \u2983C : Set \u03b1\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E, \u2200 (X : Set \u03b1), e \u2208 M.closure X \u2194 e \u2208 X,\n      \u00acM.Spanning (M.E \\ {e})].TFAE"}, {"line": "tfae_have 5 -> 4 := by\n    refine fun \u27e8h, heE\u27e9 B hB \u21a6 by_contra fun heB \u21a6 ?_\n    rw [\u2190 hB.closure_eq] at heE\n    obtain \u27e8C, -, hC, heC\u27e9 := (mem_closure_iff_exists_isCircuit heB).1 heE\n    exact h hC heC", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\ntfae_1_iff_2 : M.IsColoop e \u2194 e \u2208 M.coloops\ntfae_1_iff_3 : M.IsColoop e \u2194 M.IsCocircuit {e}\ntfae_1_iff_4 : M.IsColoop e \u2194 \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 B\ntfae_3_to_5 : M.IsCocircuit {e} \u2192 (\u2200 \u2983C : Set \u03b1\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E\ntfae_5_to_4 : (\u2200 \u2983C : Set \u03b1\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E \u2192 \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 B\n\u22a2 [M.IsColoop e, e \u2208 M.coloops, M.IsCocircuit {e}, \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 B,\n      (\u2200 \u2983C : Set \u03b1\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E, \u2200 (X : Set \u03b1), e \u2208 M.closure X \u2194 e \u2208 X,\n      \u00acM.Spanning (M.E \\ {e})].TFAE"}, {"line": "tfae_have 5 <-> 6 := by\n    refine \u27e8fun h X \u21a6 \u27e8fun heX \u21a6 by_contra fun heX' \u21a6 ?_, fun heX \u21a6 M.mem_closure_of_mem' heX h.2\u27e9,\n      fun h \u21a6 \u27e8fun C hC heC \u21a6 ?_, M.closure_subset_ground _ <| (h {e}).2 rfl\u27e9\u27e9\n    \u00b7 obtain \u27e8C, -, hC, heC\u27e9 := (mem_closure_iff_exists_isCircuit heX').1 heX\n      exact h.1 hC heC\n    \u00b7 simpa [hC.mem_closure_diff_singleton_of_mem heC] using h (C \\ {e})", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\ntfae_1_iff_2 : M.IsColoop e \u2194 e \u2208 M.coloops\ntfae_1_iff_3 : M.IsColoop e \u2194 M.IsCocircuit {e}\ntfae_1_iff_4 : M.IsColoop e \u2194 \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 B\ntfae_3_to_5 : M.IsCocircuit {e} \u2192 (\u2200 \u2983C : Set \u03b1\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E\ntfae_5_to_4 : (\u2200 \u2983C : Set \u03b1\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E \u2192 \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 B\ntfae_5_iff_6 : (\u2200 \u2983C : Set \u03b1\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E \u2194 \u2200 (X : Set \u03b1), e \u2208 M.closure X \u2194 e \u2208 X\n\u22a2 [M.IsColoop e, e \u2208 M.coloops, M.IsCocircuit {e}, \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 B,\n      (\u2200 \u2983C : Set \u03b1\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E, \u2200 (X : Set \u03b1), e \u2208 M.closure X \u2194 e \u2208 X,\n      \u00acM.Spanning (M.E \\ {e})].TFAE"}, {"line": "tfae_have 1 <-> 7 := by\n    wlog he : e \u2208 M.E\n    \u00b7 exact iff_of_false (fun h \u21a6 he h.mem_ground) <| by simp [he, M.ground_spanning]\n    rw [spanning_iff_compl_coindep diff_subset]\n    rw [\u2190 dual_isLoop_iff_isColoop]\n    rw [\u2190 singleton_dep]\n    rw [diff_diff_cancel_left (by simpa)]\n    rw [\u2190 not_indep_iff (by simpa)]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\ntfae_1_iff_2 : M.IsColoop e \u2194 e \u2208 M.coloops\ntfae_1_iff_3 : M.IsColoop e \u2194 M.IsCocircuit {e}\ntfae_1_iff_4 : M.IsColoop e \u2194 \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 B\ntfae_3_to_5 : M.IsCocircuit {e} \u2192 (\u2200 \u2983C : Set \u03b1\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E\ntfae_5_to_4 : (\u2200 \u2983C : Set \u03b1\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E \u2192 \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 B\ntfae_5_iff_6 : (\u2200 \u2983C : Set \u03b1\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E \u2194 \u2200 (X : Set \u03b1), e \u2208 M.closure X \u2194 e \u2208 X\ntfae_1_iff_7 : M.IsColoop e \u2194 \u00acM.Spanning (M.E \\ {e})\n\u22a2 [M.IsColoop e, e \u2208 M.coloops, M.IsCocircuit {e}, \u2200 \u2983B : Set \u03b1\u2984, M.IsBase B \u2192 e \u2208 B,\n      (\u2200 \u2983C : Set \u03b1\u2984, M.IsCircuit C \u2192 e \u2209 C) \u2227 e \u2208 M.E, \u2200 (X : Set \u03b1), e \u2208 M.closure X \u2194 e \u2208 X,\n      \u00acM.Spanning (M.E \\ {e})].TFAE"}, {"line": "tfae_finish", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsBasis'.inter_coloops_subset (hIX : M.IsBasis' I X) : X \u2229 M.coloops \u2286 I := by\n  intro e \u27e8heX, (heI : M.IsColoop e)\u27e9\n  rwa [\u2190 heI.mem_closure_iff_mem, hIX.isBasis_closure_right.closure_eq_right,\n    heI.mem_closure_iff_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}", "{B K : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX I : Set \u03b1\nhIX : M.IsBasis' I X\n\u22a2 X \u2229 M.coloops \u2286 I"}, {"line": "intro e \u27e8heX, (heI : M.IsColoop e)\u27e9", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX I : Set \u03b1\nhIX : M.IsBasis' I X\ne : \u03b1\nheX : e \u2208 X\nheI : M.IsColoop e\n\u22a2 e \u2208 I"}, {"line": "rwa [\u2190 heI.mem_closure_iff_mem, hIX.isBasis_closure_right.closure_eq_right,\n    heI.mem_closure_iff_mem]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsColoop.insert_indep_of_indep (he : M.IsColoop e) (hI : M.Indep I) :\n    M.Indep (insert e I) := by\n  refine (em (e \u2208 I)).elim (fun h \u21a6 by rwa [insert_eq_of_mem h]) fun h \u21a6 ?_\n  rw [\u2190 hI.not_mem_closure_iff_of_not_mem h]\n  exact he.not_mem_closure_of_not_mem h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}", "{B K : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhe : M.IsColoop e\nhI : M.Indep I\n\u22a2 M.Indep (insert e I)"}, {"line": "refine (em (e \u2208 I)).elim (fun h \u21a6 by rwa [insert_eq_of_mem h]) fun h \u21a6 ?_", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhe : M.IsColoop e\nhI : M.Indep I\nh : e \u2209 I\n\u22a2 M.Indep (insert e I)"}, {"line": "rw [\u2190 hI.not_mem_closure_iff_of_not_mem h]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhe : M.IsColoop e\nhI : M.Indep I\nh : e \u2209 I\n\u22a2 e \u2209 M.closure I"}, {"line": "exact he.not_mem_closure_of_not_mem h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma union_indep_iff_indep_of_subset_coloops (hK : K \u2286 M.coloops) :\n    M.Indep (I \u222a K) \u2194 M.Indep I := by\n  refine \u27e8fun h \u21a6 h.subset subset_union_left, fun h \u21a6 ?_\u27e9\n  obtain \u27e8B, hB, hIB\u27e9 := h.exists_isBase_superset\n  exact hB.indep.subset (union_subset hIB (hK.trans fun e he \u21a6 IsColoop.mem_of_isBase he hB))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}", "{B K : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI K : Set \u03b1\nhK : K \u2286 M.coloops\n\u22a2 M.Indep (I \u222a K) \u2194 M.Indep I"}, {"line": "refine \u27e8fun h \u21a6 h.subset subset_union_left, fun h \u21a6 ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI K : Set \u03b1\nhK : K \u2286 M.coloops\nh : M.Indep I\n\u22a2 M.Indep (I \u222a K)"}, {"line": "obtain \u27e8B, hB, hIB\u27e9 := h.exists_isBase_superset", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI K : Set \u03b1\nhK : K \u2286 M.coloops\nh : M.Indep I\nB : Set \u03b1\nhB : M.IsBase B\nhIB : I \u2286 B\n\u22a2 M.Indep (I \u222a K)"}, {"line": "exact hB.indep.subset (union_subset hIB (hK.trans fun e he \u21a6 IsColoop.mem_of_isBase he hB))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma loopless_iff_forall_isCircuit : M.Loopless \u2194 \u2200 C, M.IsCircuit C \u2192 C.Nontrivial := by\n  suffices (\u2203 x \u2208 M.E, M.IsLoop x) \u2194 \u2203 x, M.IsCircuit x \u2227 x.Subsingleton by\n    simpa [loopless_iff_forall_not_isLoop, \u2190 not_iff_not (a := \u2200 _, _)]\n  refine \u27e8fun \u27e8e, _, he\u27e9 \u21a6 \u27e8{e}, he.isCircuit, by simp\u27e9, fun \u27e8C, hC, hCs\u27e9 \u21a6 ?_\u27e9\n  obtain (rfl | \u27e8e, rfl\u27e9) := hCs.eq_empty_or_singleton\n  \u00b7 simpa using hC.nonempty\n  exact \u27e8e, (singleton_isCircuit.1 hC).mem_ground, singleton_isCircuit.1 hC\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}", "{B K : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\n\u22a2 M.Loopless \u2194 \u2200 (C : Set \u03b1), M.IsCircuit C \u2192 C.Nontrivial"}, {"line": "suffices (\u2203 x \u2208 M.E, M.IsLoop x) \u2194 \u2203 x, M.IsCircuit x \u2227 x.Subsingleton by\n    simpa [loopless_iff_forall_not_isLoop, \u2190 not_iff_not (a := \u2200 _, _)]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\n\u22a2 (\u2203 x \u2208 M.E, M.IsLoop x) \u2194 \u2203 x, M.IsCircuit x \u2227 x.Subsingleton"}, {"line": "refine \u27e8fun \u27e8e, _, he\u27e9 \u21a6 \u27e8{e}, he.isCircuit, by simp\u27e9, fun \u27e8C, hC, hCs\u27e9 \u21a6 ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nx\u271d : \u2203 x, M.IsCircuit x \u2227 x.Subsingleton\nC : Set \u03b1\nhC : M.IsCircuit C\nhCs : C.Subsingleton\n\u22a2 \u2203 x \u2208 M.E, M.IsLoop x"}, {"line": "obtain (rfl | \u27e8e, rfl\u27e9) := hCs.eq_empty_or_singleton", "tactic_state": "case inl\n\u03b1 : Type u_1\nM : Matroid \u03b1\nx\u271d : \u2203 x, M.IsCircuit x \u2227 x.Subsingleton\nhC : M.IsCircuit \u2205\nhCs : \u2205.Subsingleton\n\u22a2 \u2203 x \u2208 M.E, M.IsLoop x\n---\ncase inr.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nx\u271d : \u2203 x, M.IsCircuit x \u2227 x.Subsingleton\ne : \u03b1\nhC : M.IsCircuit {e}\nhCs : {e}.Subsingleton\n\u22a2 \u2203 x \u2208 M.E, M.IsLoop x"}, {"line": "\u00b7 simpa using hC.nonempty", "tactic_state": "case inr.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nx\u271d : \u2203 x, M.IsCircuit x \u2227 x.Subsingleton\ne : \u03b1\nhC : M.IsCircuit {e}\nhCs : {e}.Subsingleton\n\u22a2 \u2203 x \u2208 M.E, M.IsLoop x"}, {"line": "exact \u27e8e, (singleton_isCircuit.1 hC).mem_ground, singleton_isCircuit.1 hC\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma removeLoops_eq_self_iff : M.removeLoops = M \u2194 M.Loopless := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 M.removeLoops_eq_self\u27e9\n  rw [\u2190 h]\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}", "{B K : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\n\u22a2 M.removeLoops = M \u2194 M.Loopless"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 M.removeLoops_eq_self\u27e9", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nh : M.removeLoops = M\n\u22a2 M.Loopless"}, {"line": "rw [\u2190 h]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nh : M.removeLoops = M\n\u22a2 M.removeLoops.Loopless"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "lemma removeLoops_isBasis'_eq : M.removeLoops.IsBasis' = M.IsBasis' := by\n  ext\n  simp [IsBasis']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}", "{B K : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\n\u22a2 M.removeLoops.IsBasis' = M.IsBasis'"}, {"line": "ext", "tactic_state": "case h.h.a\n\u03b1 : Type u_1\nM : Matroid \u03b1\nx\u271d\u00b9 x\u271d : Set \u03b1\n\u22a2 M.removeLoops.IsBasis' x\u271d\u00b9 x\u271d \u2194 M.IsBasis' x\u271d\u00b9 x\u271d"}, {"line": "simp [IsBasis']", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsNonloop.removeLoops_isNonloop (he : M.IsNonloop e) : M.removeLoops.IsNonloop e := by\n  simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}", "{B K : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\nhe : M.IsNonloop e\n\u22a2 M.removeLoops.IsNonloop e"}, {"line": "simpa", "tactic_state": "No Goals!"}]}
{"declaration": "lemma removeLoops_idem (M : Matroid \u03b1) : M.removeLoops.removeLoops = M.removeLoops := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Loop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {M N : Matroid \u03b1} {e f : \u03b1} {F X C I : Set \u03b1}", "{B K : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\n\u22a2 M.removeLoops.removeLoops = M.removeLoops"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Indep.exists_bijOn_of_map {I : Set \u03b2} (hf) (hI : (M.map f hf).Indep I) :\n    \u2203 I\u2080, M.Indep I\u2080 \u2227 BijOn f I\u2080 I := by\n  obtain \u27e8I\u2080, hI\u2080, rfl\u27e9 := hI\n  exact \u27e8I\u2080, hI\u2080, (hf.mono hI\u2080.subset_ground).bijOn_image\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Map.lean", "context": {"open": ["Set Function Set.Notation"], "variables": ["{\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} {E I : Set \u03b1} {M : Matroid \u03b1} {N : Matroid \u03b2}", "{E B I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nM : Matroid \u03b1\nI : Set \u03b2\nhf : InjOn f M.E\nhI : (M.map f hf).Indep I\n\u22a2 \u2203 I\u2080, M.Indep I\u2080 \u2227 BijOn f I\u2080 I"}, {"line": "obtain \u27e8I\u2080, hI\u2080, rfl\u27e9 := hI", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nM : Matroid \u03b1\nhf : InjOn f M.E\nI\u2080 : Set \u03b1\nhI\u2080 : M.Indep I\u2080\n\u22a2 \u2203 I\u2080_1, M.Indep I\u2080_1 \u2227 BijOn f I\u2080_1 (f '' I\u2080)"}, {"line": "exact \u27e8I\u2080, hI\u2080, (hf.mono hI\u2080.subset_ground).bijOn_image\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Indep.mapEmbedding (hI : M.Indep I) (f : \u03b1 \u21aa \u03b2) : (M.mapEmbedding f).Indep (f '' I) := by\n  simpa [preimage_image_eq I f.injective]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Map.lean", "context": {"open": ["Set Function Set.Notation"], "variables": ["{\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} {E I : Set \u03b1} {M : Matroid \u03b1} {N : Matroid \u03b2}", "{E B I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nM : Matroid \u03b1\nI : Set \u03b1\nhI : M.Indep I\nf : \u03b1 \u21aa \u03b2\n\u22a2 (M.mapEmbedding f).Indep (\u21d1f '' I)"}, {"line": "simpa [preimage_image_eq I f.injective]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsBasis.mapEmbedding {X : Set \u03b1} (hIX : M.IsBasis I X) (f : \u03b1 \u21aa \u03b2) :\n    (M.mapEmbedding f).IsBasis (f '' I) (f '' X) := by\n  apply hIX.map\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Map.lean", "context": {"open": ["Set Function Set.Notation"], "variables": ["{\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} {E I : Set \u03b1} {M : Matroid \u03b1} {N : Matroid \u03b2}", "{E B I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nM : Matroid \u03b1\nI X : Set \u03b1\nhIX : M.IsBasis I X\nf : \u03b1 \u21aa \u03b2\n\u22a2 (M.mapEmbedding f).IsBasis (\u21d1f '' I) (\u21d1f '' X)"}, {"line": "apply hIX.map", "tactic_state": "No Goals!"}]}
{"declaration": "lemma restrictSubtype_inter_indep_iff :\n    (M.restrictSubtype X).Indep (X \u2193\u2229 I) \u2194 M.Indep (X \u2229 I) := by\n  simp [restrictSubtype, Subtype.val_injective.injOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Map.lean", "context": {"open": ["Set Function Set.Notation"], "variables": ["{\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} {E I : Set \u03b1} {M : Matroid \u03b1} {N : Matroid \u03b2}", "{E B I : Set \u03b1}", "{f : \u03b1 \u2243 \u03b2}", "{E X I : Set \u03b1} {M : Matroid \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nX I : Set \u03b1\nM : Matroid \u03b1\n\u22a2 (M.restrictSubtype X).Indep (Subtype.val \u207b\u00b9' I) \u2194 M.Indep (X \u2229 I)"}, {"line": "simp [restrictSubtype, Subtype.val_injective.injOn]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_val_restrictSubtype_ground_eq (M : Matroid \u03b1) :\n    (M.restrictSubtype M.E).map (\u2191) Subtype.val_injective.injOn = M := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Map.lean", "context": {"open": ["Set Function Set.Notation"], "variables": ["{\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} {E I : Set \u03b1} {M : Matroid \u03b1} {N : Matroid \u03b2}", "{E B I : Set \u03b1}", "{f : \u03b1 \u2243 \u03b2}", "{E X I : Set \u03b1} {M : Matroid \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\n\u22a2 (M.restrictSubtype M.E).map Subtype.val \u22ef = M"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma disjointSum_comm {h} : M.disjointSum N h = N.disjointSum M h.symm := by\n  ext\n  \u00b7 simp [union_comm]\n  repeat simpa [union_comm] using \u27e8fun \u27e8m, n, h\u27e9 \u21a6 \u27e8n, m, M.E.union_comm N.E \u25b8 h\u27e9,\n    fun \u27e8n, m, h\u27e9 \u21a6 \u27e8m, n, M.E.union_comm N.E \u25b8 h\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Sum.lean", "context": {"open": ["Set", "scoped Function -- required for scoped `on` notation"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {M : (i : \u03b9) \u2192 Matroid (\u03b1 i)}", "{\u03b1 \u03b9 : Type*} {M : \u03b9 \u2192 Matroid \u03b1}", "{\u03b1 \u03b9 : Type*} {M : \u03b9 \u2192 Matroid \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {M N : Matroid \u03b1}", "{\u03b1 : Type*} {M N : Matroid \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM N : Matroid \u03b1\nh : Disjoint M.E N.E\n\u22a2 M.disjointSum N h = N.disjointSum M \u22ef"}, {"line": "ext", "tactic_state": "case hE.h\n\u03b1 : Type u_7\nM N : Matroid \u03b1\nh : Disjoint M.E N.E\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 (M.disjointSum N h).E \u2194 x\u271d \u2208 (N.disjointSum M \u22ef).E\n---\ncase h\n\u03b1 : Type u_7\nM N : Matroid \u03b1\nh : Disjoint M.E N.E\nI\u271d : Set \u03b1\na\u271d : I\u271d \u2286 (M.disjointSum N h).E\n\u22a2 (M.disjointSum N h).Indep I\u271d \u2194 (N.disjointSum M \u22ef).Indep I\u271d"}, {"line": "\u00b7 simp [union_comm]", "tactic_state": "case h\n\u03b1 : Type u_7\nM N : Matroid \u03b1\nh : Disjoint M.E N.E\nI\u271d : Set \u03b1\na\u271d : I\u271d \u2286 (M.disjointSum N h).E\n\u22a2 (M.disjointSum N h).Indep I\u271d \u2194 (N.disjointSum M \u22ef).Indep I\u271d"}, {"line": "repeat simpa [union_comm] using \u27e8fun \u27e8m, n, h\u27e9 \u21a6 \u27e8n, m, M.E.union_comm N.E \u25b8 h\u27e9,\n    fun \u27e8n, m, h\u27e9 \u21a6 \u27e8m, n, M.E.union_comm N.E \u25b8 h\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsMinor.subset (h : N \u2264m M) : N.E \u2286 M.E := by\n  obtain \u27e8C, D, rfl\u27e9 := h\n  exact diff_subset.trans diff_subset\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Minor/Order.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M M' N : Matroid \u03b1} {e f : \u03b1} {I C D : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM N : Matroid \u03b1\nh : N \u2264m M\n\u22a2 N.E \u2286 M.E"}, {"line": "obtain \u27e8C, D, rfl\u27e9 := h", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nC D : Set \u03b1\n\u22a2 ((M.contract C).delete D).E \u2286 M.E"}, {"line": "exact diff_subset.trans diff_subset", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsMinor.trans {M\u2081 M\u2082 M\u2083 : Matroid \u03b1} (h : M\u2081 \u2264m M\u2082) (h' : M\u2082 \u2264m M\u2083) : M\u2081 \u2264m M\u2083 := by\n  obtain \u27e8C\u2081, D\u2081, rfl\u27e9 := h\n  obtain \u27e8C\u2082, D\u2082, rfl\u27e9 := h'\n  exact \u27e8C\u2082 \u222a C\u2081 \\ D\u2082, D\u2082 \u222a D\u2081, by rw [contract_delete_contract_delete']\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Minor/Order.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M M' N : Matroid \u03b1} {e f : \u03b1} {I C D : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM\u2081 M\u2082 M\u2083 : Matroid \u03b1\nh : M\u2081 \u2264m M\u2082\nh' : M\u2082 \u2264m M\u2083\n\u22a2 M\u2081 \u2264m M\u2083"}, {"line": "obtain \u27e8C\u2081, D\u2081, rfl\u27e9 := h", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM\u2082 M\u2083 : Matroid \u03b1\nh' : M\u2082 \u2264m M\u2083\nC\u2081 D\u2081 : Set \u03b1\n\u22a2 (M\u2082.contract C\u2081).delete D\u2081 \u2264m M\u2083"}, {"line": "obtain \u27e8C\u2082, D\u2082, rfl\u27e9 := h'", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\nM\u2083 : Matroid \u03b1\nC\u2081 D\u2081 C\u2082 D\u2082 : Set \u03b1\n\u22a2 (((M\u2083.contract C\u2082).delete D\u2082).contract C\u2081).delete D\u2081 \u2264m M\u2083"}, {"line": "exact \u27e8C\u2082 \u222a C\u2081 \\ D\u2082, D\u2082 \u222a D\u2081, by rw [contract_delete_contract_delete']\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Indep.of_isMinor (hI : N.Indep I) (hNM : N \u2264m M) : M.Indep I := by\n  obtain \u27e8C, D, rfl\u27e9 := hNM\n  exact hI.of_delete.of_contract\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Minor/Order.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M M' N : Matroid \u03b1} {e f : \u03b1} {I C D : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM N : Matroid \u03b1\nI : Set \u03b1\nhI : N.Indep I\nhNM : N \u2264m M\n\u22a2 M.Indep I"}, {"line": "obtain \u27e8C, D, rfl\u27e9 := hNM", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI C D : Set \u03b1\nhI : ((M.contract C).delete D).Indep I\n\u22a2 M.Indep I"}, {"line": "exact hI.of_delete.of_contract", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsNonloop.of_isMinor (h : N.IsNonloop e) (hNM : N \u2264m M) : M.IsNonloop e := by\n  obtain \u27e8C, D, rfl\u27e9 := hNM\n  exact h.of_delete.of_contract\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Minor/Order.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M M' N : Matroid \u03b1} {e f : \u03b1} {I C D : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM N : Matroid \u03b1\ne : \u03b1\nh : N.IsNonloop e\nhNM : N \u2264m M\n\u22a2 M.IsNonloop e"}, {"line": "obtain \u27e8C, D, rfl\u27e9 := hNM", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\nC D : Set \u03b1\nh : ((M.contract C).delete D).IsNonloop e\n\u22a2 M.IsNonloop e"}, {"line": "exact h.of_delete.of_contract", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsRestriction.antisymm {M' : Matroid \u03b1} (h : M \u2264r M') (h' : M' \u2264r M) : M = M' := by\n  simpa using (ofMatroid_le_iff.2 h).antisymm (ofMatroid_le_iff.2 h')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Minor/Restrict.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {R I X Y : Set \u03b1}", "{N : Matroid \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nx\u271d : Sort u_2\nr : x\u271d\nM' : Matroid \u03b1\nh : M \u2264 sorry\nh' : M' \u2264 sorry\n\u22a2 M = M'"}, {"line": "simpa using (ofMatroid_le_iff.2 h).antisymm (ofMatroid_le_iff.2 h')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsRestriction.finite {M : Matroid \u03b1} [M.Finite] (h : N \u2264r M) : N.Finite := by\n  obtain \u27e8R, hR, rfl\u27e9 := h\n  exact restrict_finite <| M.ground_finite.subset hR\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Minor/Restrict.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {R I X Y : Set \u03b1}", "{N : Matroid \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nN : Matroid \u03b1\nx\u271d : Sort u_2\nr : x\u271d\nM : Matroid \u03b1\ninst\u271d : M.Finite\nh : N \u2264 sorry\n\u22a2 N.Finite"}, {"line": "obtain \u27e8R, hR, rfl\u27e9 := h", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nx\u271d : Sort u_2\nr : x\u271d\nM : Matroid \u03b1\ninst\u271d : M.Finite\nR hR : Set \u03b1\n\u22a2 ((sorry.contract R).delete hR).Finite"}, {"line": "exact restrict_finite <| M.ground_finite.subset hR", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsBasis.isBasis_of_isBasis_of_subset_of_subset (hI : M.IsBasis I X) (hJ : M.IsBasis J Y)\n    (hJX : J \u2286 X) (hIY : I \u2286 Y) : M.IsBasis I Y := by\n  have hI' := hI.isBasis_subset (subset_inter hI.subset hIY) inter_subset_left\n  have hJ' := hJ.isBasis_subset (subset_inter hJX hJ.subset) inter_subset_right\n  exact hI'.transfer hJ' inter_subset_right hJ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Minor/Restrict.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {R I X Y : Set \u03b1}", "{N : Matroid \u03b1}", "{B J : Set \u03b1} {e : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X Y J : Set \u03b1\nhI : M.IsBasis I X\nhJ : M.IsBasis J Y\nhJX : J \u2286 X\nhIY : I \u2286 Y\n\u22a2 M.IsBasis I Y"}, {"line": "have hI' := hI.isBasis_subset (subset_inter hI.subset hIY) inter_subset_left", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X Y J : Set \u03b1\nhI : M.IsBasis I X\nhJ : M.IsBasis J Y\nhJX : J \u2286 X\nhIY : I \u2286 Y\nhI' : M.IsBasis I (X \u2229 Y)\n\u22a2 M.IsBasis I Y"}, {"line": "have hJ' := hJ.isBasis_subset (subset_inter hJX hJ.subset) inter_subset_right", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X Y J : Set \u03b1\nhI : M.IsBasis I X\nhJ : M.IsBasis J Y\nhJX : J \u2286 X\nhIY : I \u2286 Y\nhI' : M.IsBasis I (X \u2229 Y)\nhJ' : M.IsBasis J (X \u2229 Y)\n\u22a2 M.IsBasis I Y"}, {"line": "exact hI'.transfer hJ' inter_subset_right hJ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsBasis.exchange (hIX : M.IsBasis I X) (hJX : M.IsBasis J X) (he : e \u2208 I \\ J) :\n    \u2203 f \u2208 J \\ I, M.IsBasis (insert f (I \\ {e})) X := by\n  obtain \u27e8y,hy, h\u27e9 := hIX.restrict_isBase.exchange hJX.restrict_isBase he\n  exact \u27e8y, hy, by rwa [isBase_restrict_iff] at h\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Minor/Restrict.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {R I X Y : Set \u03b1}", "{N : Matroid \u03b1}", "{B J : Set \u03b1} {e : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X J : Set \u03b1\ne : \u03b1\nhIX : M.IsBasis I X\nhJX : M.IsBasis J X\nhe : e \u2208 I \\ J\n\u22a2 \u2203 f \u2208 J \\ I, M.IsBasis (insert f (I \\ {e})) X"}, {"line": "obtain \u27e8y,hy, h\u27e9 := hIX.restrict_isBase.exchange hJX.restrict_isBase he", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI X J : Set \u03b1\ne : \u03b1\nhIX : M.IsBasis I X\nhJX : M.IsBasis J X\nhe : e \u2208 I \\ J\ny : \u03b1\nhy : y \u2208 J \\ I\nh : (M.restrict X).IsBase (insert y (I \\ {e}))\n\u22a2 \u2203 f \u2208 J \\ I, M.IsBasis (insert f (I \\ {e})) X"}, {"line": "exact \u27e8y, hy, by rwa [isBase_restrict_iff] at h\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Indep.augment (hI : M.Indep I) (hJ : M.Indep J) (hIJ : I.encard < J.encard) :\n    \u2203 e \u2208 J \\ I, M.Indep (insert e I) := by\n  by_contra! he\n  have hb : M.IsBasis I (I \u222a J) := by\n    simp_rw [hI.isBasis_iff_forall_insert_dep subset_union_left, union_diff_left, mem_diff,\n      and_imp, dep_iff, insert_subset_iff, and_iff_left hI.subset_ground]\n    exact fun e heJ heI \u21a6 \u27e8he e \u27e8heJ, heI\u27e9, hJ.subset_ground heJ\u27e9\n  obtain \u27e8J', hJ', hJJ'\u27e9 := hJ.subset_isBasis_of_subset I.subset_union_right\n  rw [\u2190 hJ'.encard_eq_encard hb] at hIJ\n  exact hIJ.not_le (encard_mono hJJ')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Minor/Restrict.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {R I X Y : Set \u03b1}", "{N : Matroid \u03b1}", "{B J : Set \u03b1} {e : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nhIJ : I.encard < J.encard\n\u22a2 \u2203 e \u2208 J \\ I, M.Indep (insert e I)"}, {"line": "by_contra! he", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nhIJ : I.encard < J.encard\nhe : \u2200 e \u2208 J \\ I, \u00acM.Indep (insert e I)\n\u22a2 False"}, {"line": "have hb : M.IsBasis I (I \u222a J) := sorry", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nhIJ : I.encard < J.encard\nhe : \u2200 e \u2208 J \\ I, \u00acM.Indep (insert e I)\nhb : M.IsBasis I (I \u222a J)\n\u22a2 False"}, {"line": "obtain \u27e8J', hJ', hJJ'\u27e9 := hJ.subset_isBasis_of_subset I.subset_union_right", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nhIJ : I.encard < J.encard\nhe : \u2200 e \u2208 J \\ I, \u00acM.Indep (insert e I)\nhb : M.IsBasis I (I \u222a J)\nJ' : Set \u03b1\nhJ' : M.IsBasis J' (I \u222a J)\nhJJ' : J \u2286 J'\n\u22a2 False"}, {"line": "rw [\u2190 hJ'.encard_eq_encard hb] at hIJ", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI J : Set \u03b1\nhI : M.Indep I\nhJ : M.Indep J\nhe : \u2200 e \u2208 J \\ I, \u00acM.Indep (insert e I)\nhb : M.IsBasis I (I \u222a J)\nJ' : Set \u03b1\nhIJ : J'.encard < J.encard\nhJ' : M.IsBasis J' (I \u222a J)\nhJJ' : J \u2286 J'\n\u22a2 False"}, {"line": "exact hIJ.not_le (encard_mono hJJ')", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Indep.augment_finset {I J : Finset \u03b1} (hI : M.Indep I) (hJ : M.Indep J)\n    (hIJ : I.card < J.card) : \u2203 e \u2208 J, e \u2209 I \u2227 M.Indep (insert e I) := by\n  obtain \u27e8x, hx, hxI\u27e9 := hI.augment hJ (by simpa [encard_eq_coe_toFinset_card])\n  simp only [mem_diff] at hx\n  simp only [Finset.mem_coe] at hx\n  exact \u27e8x, hx.1, hx.2, hxI\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Minor/Restrict.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {R I X Y : Set \u03b1}", "{N : Matroid \u03b1}", "{B J : Set \u03b1} {e : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI J : Finset \u03b1\nhI : M.Indep \u2191I\nhJ : M.Indep \u2191J\nhIJ : I.card < J.card\n\u22a2 \u2203 e \u2208 J, e \u2209 I \u2227 M.Indep (insert e \u2191I)"}, {"line": "obtain \u27e8x, hx, hxI\u27e9 := hI.augment hJ (by simpa [encard_eq_coe_toFinset_card])", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI J : Finset \u03b1\nhI : M.Indep \u2191I\nhJ : M.Indep \u2191J\nhIJ : I.card < J.card\nx : \u03b1\nhx : x \u2208 \u2191J \\ \u2191I\nhxI : M.Indep (insert x \u2191I)\n\u22a2 \u2203 e \u2208 J, e \u2209 I \u2227 M.Indep (insert e \u2191I)"}, {"line": "simp only [mem_diff] at hx", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI J : Finset \u03b1\nhI : M.Indep \u2191I\nhJ : M.Indep \u2191J\nhIJ : I.card < J.card\nx : \u03b1\nhxI : M.Indep (insert x \u2191I)\nhx : x \u2208 \u2191J \u2227 x \u2209 \u2191I\n\u22a2 \u2203 e \u2208 J, e \u2209 I \u2227 M.Indep (insert e \u2191I)"}, {"line": "simp only [Finset.mem_coe] at hx", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nI J : Finset \u03b1\nhI : M.Indep \u2191I\nhJ : M.Indep \u2191J\nhIJ : I.card < J.card\nx : \u03b1\nhxI : M.Indep (insert x \u2191I)\nhx : x \u2208 J \u2227 x \u2209 I\n\u22a2 \u2203 e \u2208 J, e \u2209 I \u2227 M.Indep (insert e \u2191I)"}, {"line": "exact \u27e8x, hx.1, hx.2, hxI\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rankFinite_iff_cRank_lt_aleph0 : M.RankFinite \u2194 M.cRank < \u2135\u2080 := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 \u27e8?_\u27e9\u27e9\n  \u00b7 have \u27e8B, hB, fin\u27e9 := h\n    exact hB.cardinalMk_eq_cRank \u25b8 lt_aleph0_iff_finite.mpr fin\n  have \u27e8B, hB\u27e9 := M.exists_isBase\n  simp_rw [\u2190 finite_coe_iff, \u2190 lt_aleph0_iff_finite]\n  exact \u27e8B, hB, hB.cardinalMk_le_cRank.trans_lt h\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/Cardinal.lean", "context": {"open": ["Cardinal Set"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {M : Matroid \u03b1} {I J B B' X Y : Set \u03b1}", "{\u03ba : Cardinal}", "[InvariantCardinalRank M]", "(M : Matroid \u03b1) [InvariantCardinalRank M] (e : \u03b1) (X Y : Set \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nM : Matroid \u03b1\n\u22a2 M.RankFinite \u2194 M.cRank < aleph0"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 \u27e8?_\u27e9\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u\nM : Matroid \u03b1\nh : M.RankFinite\n\u22a2 M.cRank < aleph0\n---\ncase refine_2\n\u03b1 : Type u\nM : Matroid \u03b1\nh : M.cRank < aleph0\n\u22a2 \u2203 B, M.IsBase B \u2227 B.Finite"}, {"line": "\u00b7 have \u27e8B, hB, fin\u27e9 := h\n    exact hB.cardinalMk_eq_cRank \u25b8 lt_aleph0_iff_finite.mpr fin", "tactic_state": "case refine_2\n\u03b1 : Type u\nM : Matroid \u03b1\nh : M.cRank < aleph0\n\u22a2 \u2203 B, M.IsBase B \u2227 B.Finite"}, {"line": "have \u27e8B, hB\u27e9 := M.exists_isBase", "tactic_state": "case refine_2\n\u03b1 : Type u\nM : Matroid \u03b1\nh : M.cRank < aleph0\nB : Set \u03b1\nhB : M.IsBase B\n\u22a2 \u2203 B, M.IsBase B \u2227 B.Finite"}, {"line": "simp_rw [\u2190 finite_coe_iff, \u2190 lt_aleph0_iff_finite]", "tactic_state": "case refine_2\n\u03b1 : Type u\nM : Matroid \u03b1\nh : M.cRank < aleph0\nB : Set \u03b1\nhB : M.IsBase B\n\u22a2 \u2203 B, M.IsBase B \u2227 mk \u2191B < aleph0"}, {"line": "exact \u27e8B, hB, hB.cardinalMk_le_cRank.trans_lt h\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toENat_cRank_eq (M : Matroid \u03b1) : M.cRank.toENat = M.eRank := by\n  obtain h | h := M.rankFinite_or_rankInfinite\n  \u00b7 obtain \u27e8B, hB\u27e9 := M.exists_isBase\n    rw [\u2190 hB.cardinalMk_eq_cRank]\n    rw [\u2190 hB.encard_eq_eRank]\n    rw [toENat_cardinalMk]\n  simp [rankInfinite_iff_aleph0_le_cRank.1 h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/Cardinal.lean", "context": {"open": ["Cardinal Set"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {M : Matroid \u03b1} {I J B B' X Y : Set \u03b1}", "{\u03ba : Cardinal}", "[InvariantCardinalRank M]", "(M : Matroid \u03b1) [InvariantCardinalRank M] (e : \u03b1) (X Y : Set \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nM : Matroid \u03b1\n\u22a2 toENat M.cRank = M.eRank"}, {"line": "obtain h | h := M.rankFinite_or_rankInfinite", "tactic_state": "case inl\n\u03b1 : Type u\nM : Matroid \u03b1\nh : M.RankFinite\n\u22a2 toENat M.cRank = M.eRank\n---\ncase inr\n\u03b1 : Type u\nM : Matroid \u03b1\nh : M.RankInfinite\n\u22a2 toENat M.cRank = M.eRank"}, {"line": "\u00b7 obtain \u27e8B, hB\u27e9 := M.exists_isBase\n    rw [\u2190 hB.cardinalMk_eq_cRank]\n    rw [\u2190 hB.encard_eq_eRank]\n    rw [toENat_cardinalMk]", "tactic_state": "case inr\n\u03b1 : Type u\nM : Matroid \u03b1\nh : M.RankInfinite\n\u22a2 toENat M.cRank = M.eRank"}, {"line": "simp [rankInfinite_iff_aleph0_le_cRank.1 h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsBasis'.eRk_eq_eRk (hIX : M.IsBasis' I X) : M.eRk I = M.eRk X := by\n  rw [\u2190 hIX.encard_eq_eRk]\n  rw [hIX.indep.eRk_eq_encard]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/ENat.lean", "context": {"open": ["Set ENat"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {I B X Y : Set \u03b1} {n : \u2115\u221e} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\nhIX : M.IsBasis' I X\n\u22a2 M.eRk I = M.eRk X"}, {"line": "rw [\u2190 hIX.encard_eq_eRk]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\nhIX : M.IsBasis' I X\n\u22a2 M.eRk I = I.encard"}, {"line": "rw [hIX.indep.eRk_eq_encard]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsBasis.eRk_eq_eRk (hIX : M.IsBasis I X) : M.eRk I = M.eRk X := by\n  rw [\u2190 hIX.encard_eq_eRk]\n  rw [hIX.indep.eRk_eq_encard]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/ENat.lean", "context": {"open": ["Set ENat"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {I B X Y : Set \u03b1} {n : \u2115\u221e} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\nhIX : M.IsBasis I X\n\u22a2 M.eRk I = M.eRk X"}, {"line": "rw [\u2190 hIX.encard_eq_eRk]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\nhIX : M.IsBasis I X\n\u22a2 M.eRk I = I.encard"}, {"line": "rw [hIX.indep.eRk_eq_encard]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsBasis'.eRk_eq_encard (hIX : M.IsBasis' I X) : M.eRk X = I.encard := by\n  rw [\u2190 hIX.eRk_eq_eRk]\n  rw [hIX.indep.eRk_eq_encard]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/ENat.lean", "context": {"open": ["Set ENat"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {I B X Y : Set \u03b1} {n : \u2115\u221e} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\nhIX : M.IsBasis' I X\n\u22a2 M.eRk X = I.encard"}, {"line": "rw [\u2190 hIX.eRk_eq_eRk]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\nhIX : M.IsBasis' I X\n\u22a2 M.eRk I = I.encard"}, {"line": "rw [hIX.indep.eRk_eq_encard]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsBasis.eRk_eq_encard (hIX : M.IsBasis I X) : M.eRk X = I.encard := by\n  rw [\u2190 hIX.eRk_eq_eRk]\n  rw [hIX.indep.eRk_eq_encard]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/ENat.lean", "context": {"open": ["Set ENat"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {I B X Y : Set \u03b1} {n : \u2115\u221e} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\nhIX : M.IsBasis I X\n\u22a2 M.eRk X = I.encard"}, {"line": "rw [\u2190 hIX.eRk_eq_eRk]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\nhIX : M.IsBasis I X\n\u22a2 M.eRk I = I.encard"}, {"line": "rw [hIX.indep.eRk_eq_encard]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eRank_loopyOn (E : Set \u03b1) : (loopyOn E).eRank = 0 := by\n  simp [\u2190 (show (loopyOn E).IsBase \u2205 by simp).encard_eq_eRank]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/ENat.lean", "context": {"open": ["Set ENat"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {I B X Y : Set \u03b1} {n : \u2115\u221e} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\nloopyOn : x\u271d\nE : Set \u03b1\n\u22a2 sorry = 0"}, {"line": "simp [\u2190 (show (loopyOn E).IsBase \u2205 by simp).encard_eq_eRank]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\nloopyOn : x\u271d\nE : Set \u03b1\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma eRank_emptyOn (\u03b1 : Type*) : (emptyOn \u03b1).eRank = 0 := by\n  simp [\u2190 (show (emptyOn \u03b1).IsBase \u2205 by simp).encard_eq_eRank]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/ENat.lean", "context": {"open": ["Set ENat"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {I B X Y : Set \u03b1} {n : \u2115\u221e} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nemptyOn : x\u271d\n\u03b1 : Type u_2\n\u22a2 sorry = 0"}, {"line": "simp [\u2190 (show (emptyOn \u03b1).IsBase \u2205 by simp).encard_eq_eRank]", "tactic_state": "x\u271d : Sort u_3\nemptyOn : x\u271d\n\u03b1 : Type u_2\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma eRk_inter_ground (M : Matroid \u03b1) (X : Set \u03b1) : M.eRk (X \u2229 M.E) = M.eRk X := by\n  obtain \u27e8I, hI\u27e9 := M.exists_isBasis' X\n  rw [\u2190 hI.eRk_eq_eRk]\n  rw [hI.isBasis_inter_ground.eRk_eq_eRk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/ENat.lean", "context": {"open": ["Set ENat"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {I B X Y : Set \u03b1} {n : \u2115\u221e} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\n\u22a2 M.eRk (X \u2229 M.E) = M.eRk X"}, {"line": "obtain \u27e8I, hI\u27e9 := M.exists_isBasis' X", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX I : Set \u03b1\nhI : M.IsBasis' I X\n\u22a2 M.eRk (X \u2229 M.E) = M.eRk X"}, {"line": "rw [\u2190 hI.eRk_eq_eRk]", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX I : Set \u03b1\nhI : M.IsBasis' I X\n\u22a2 M.eRk (X \u2229 M.E) = M.eRk I"}, {"line": "rw [hI.isBasis_inter_ground.eRk_eq_eRk]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rankFinite_iff_eRank_ne_top (M : Matroid \u03b1) : M.RankFinite \u2194 M.eRank \u2260 \u22a4 := by\n  obtain \u27e8B, hB\u27e9 := M.exists_isBase\n  rw [\u2190 hB.encard_eq_eRank]\n  rw [encard_ne_top_iff]\n  exact \u27e8fun h \u21a6 hB.finite, fun h \u21a6 hB.rankFinite_of_finite h\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/ENat.lean", "context": {"open": ["Set ENat"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {I B X Y : Set \u03b1} {n : \u2115\u221e} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\n\u22a2 M.RankFinite \u2194 M.eRank \u2260 \u22a4"}, {"line": "obtain \u27e8B, hB\u27e9 := M.exists_isBase", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\nhB : M.IsBase B\n\u22a2 M.RankFinite \u2194 M.eRank \u2260 \u22a4"}, {"line": "rw [\u2190 hB.encard_eq_eRank]", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\nhB : M.IsBase B\n\u22a2 M.RankFinite \u2194 B.encard \u2260 \u22a4"}, {"line": "rw [encard_ne_top_iff]", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\nhB : M.IsBase B\n\u22a2 M.RankFinite \u2194 B.Finite"}, {"line": "exact \u27e8fun h \u21a6 hB.finite, fun h \u21a6 hB.rankFinite_of_finite h\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eRk_empty (M : Matroid \u03b1) : M.eRk \u2205 = 0 := by\n  rw [\u2190 M.empty_indep.isBasis_self.encard_eq_eRk]\n  rw [encard_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/ENat.lean", "context": {"open": ["Set ENat"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {I B X Y : Set \u03b1} {n : \u2115\u221e} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\n\u22a2 M.eRk \u2205 = 0"}, {"line": "rw [\u2190 M.empty_indep.isBasis_self.encard_eq_eRk]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\n\u22a2 \u2205.encard = 0"}, {"line": "rw [encard_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eRk_closure_eq (M : Matroid \u03b1) (X : Set \u03b1) : M.eRk (M.closure X) = M.eRk X := by\n  obtain \u27e8I, hI\u27e9 := M.exists_isBasis' X\n  rw [\u2190 hI.closure_eq_closure]\n  rw [\u2190 hI.indep.isBasis_closure.encard_eq_eRk]\n  rw [hI.encard_eq_eRk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/ENat.lean", "context": {"open": ["Set ENat"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {I B X Y : Set \u03b1} {n : \u2115\u221e} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\n\u22a2 M.eRk (M.closure X) = M.eRk X"}, {"line": "obtain \u27e8I, hI\u27e9 := M.exists_isBasis' X", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX I : Set \u03b1\nhI : M.IsBasis' I X\n\u22a2 M.eRk (M.closure X) = M.eRk X"}, {"line": "rw [\u2190 hI.closure_eq_closure]", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX I : Set \u03b1\nhI : M.IsBasis' I X\n\u22a2 M.eRk (M.closure I) = M.eRk X"}, {"line": "rw [\u2190 hI.indep.isBasis_closure.encard_eq_eRk]", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX I : Set \u03b1\nhI : M.IsBasis' I X\n\u22a2 I.encard = M.eRk X"}, {"line": "rw [hI.encard_eq_eRk]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eRk_lt_top_of_finite (M : Matroid \u03b1) (hX : X.Finite) : M.eRk X < \u22a4 := by\n  obtain \u27e8I, hI\u27e9 := M.exists_isBasis' X\n  rw [hI.eRk_eq_encard]\n  rw [encard_lt_top_iff]\n  exact hX.subset hI.subset\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/ENat.lean", "context": {"open": ["Set ENat"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {I B X Y : Set \u03b1} {n : \u2115\u221e} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nX : Set \u03b1\nM : Matroid \u03b1\nhX : X.Finite\n\u22a2 M.eRk X < \u22a4"}, {"line": "obtain \u27e8I, hI\u27e9 := M.exists_isBasis' X", "tactic_state": "case intro\n\u03b1 : Type u_1\nX : Set \u03b1\nM : Matroid \u03b1\nhX : X.Finite\nI : Set \u03b1\nhI : M.IsBasis' I X\n\u22a2 M.eRk X < \u22a4"}, {"line": "rw [hI.eRk_eq_encard]", "tactic_state": "case intro\n\u03b1 : Type u_1\nX : Set \u03b1\nM : Matroid \u03b1\nhX : X.Finite\nI : Set \u03b1\nhI : M.IsBasis' I X\n\u22a2 I.encard < \u22a4"}, {"line": "rw [encard_lt_top_iff]", "tactic_state": "case intro\n\u03b1 : Type u_1\nX : Set \u03b1\nM : Matroid \u03b1\nhX : X.Finite\nI : Set \u03b1\nhI : M.IsBasis' I X\n\u22a2 I.Finite"}, {"line": "exact hX.subset hI.subset", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsBasis'.eRk_eq_eRk_insert (hIX : M.IsBasis' I X) (e : \u03b1) :\n    M.eRk (insert e I) = M.eRk (insert e X) := by\n  rw [\u2190 union_singleton]\n  rw [hIX.eRk_eq_eRk_union]\n  rw [union_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/ENat.lean", "context": {"open": ["Set ENat"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {I B X Y : Set \u03b1} {n : \u2115\u221e} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\nhIX : M.IsBasis' I X\ne : \u03b1\n\u22a2 M.eRk (insert e I) = M.eRk (insert e X)"}, {"line": "rw [\u2190 union_singleton]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\nhIX : M.IsBasis' I X\ne : \u03b1\n\u22a2 M.eRk (I \u222a {e}) = M.eRk (insert e X)"}, {"line": "rw [hIX.eRk_eq_eRk_union]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\nhIX : M.IsBasis' I X\ne : \u03b1\n\u22a2 M.eRk (X \u222a {e}) = M.eRk (insert e X)"}, {"line": "rw [union_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsBasis.eRk_eq_eRk_insert (hIX : M.IsBasis I X) (e : \u03b1) :\n    M.eRk (insert e I) = M.eRk (insert e X) := by\n  rw [\u2190 union_singleton]\n  rw [hIX.eRk_eq_eRk_union]\n  rw [union_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/ENat.lean", "context": {"open": ["Set ENat"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {I B X Y : Set \u03b1} {n : \u2115\u221e} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\nhIX : M.IsBasis I X\ne : \u03b1\n\u22a2 M.eRk (insert e I) = M.eRk (insert e X)"}, {"line": "rw [\u2190 union_singleton]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\nhIX : M.IsBasis I X\ne : \u03b1\n\u22a2 M.eRk (I \u222a {e}) = M.eRk (insert e X)"}, {"line": "rw [hIX.eRk_eq_eRk_union]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\nhIX : M.IsBasis I X\ne : \u03b1\n\u22a2 M.eRk (X \u222a {e}) = M.eRk (insert e X)"}, {"line": "rw [union_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eRk_le_encard (M : Matroid \u03b1) (X : Set \u03b1) : M.eRk X \u2264 X.encard := by\n  obtain \u27e8I, hI\u27e9 := M.exists_isBasis' X\n  rw [hI.eRk_eq_encard]\n  exact encard_mono hI.subset\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/ENat.lean", "context": {"open": ["Set ENat"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {I B X Y : Set \u03b1} {n : \u2115\u221e} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\n\u22a2 M.eRk X \u2264 X.encard"}, {"line": "obtain \u27e8I, hI\u27e9 := M.exists_isBasis' X", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX I : Set \u03b1\nhI : M.IsBasis' I X\n\u22a2 M.eRk X \u2264 X.encard"}, {"line": "rw [hI.eRk_eq_encard]", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX I : Set \u03b1\nhI : M.IsBasis' I X\n\u22a2 I.encard \u2264 X.encard"}, {"line": "exact encard_mono hI.subset", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eRk_mono (M : Matroid \u03b1) : Monotone M.eRk := by\n  rintro X Y (hXY : X \u2286 Y)\n  obtain \u27e8I, hI\u27e9 := M.exists_isBasis' X\n  obtain \u27e8J, hJ, hIJ\u27e9 := hI.indep.subset_isBasis'_of_subset (hI.subset.trans hXY)\n  rw [hI.eRk_eq_encard]\n  rw [hJ.eRk_eq_encard]\n  exact encard_mono hIJ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/ENat.lean", "context": {"open": ["Set ENat"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {I B X Y : Set \u03b1} {n : \u2115\u221e} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\n\u22a2 Monotone M.eRk"}, {"line": "rintro X Y (hXY : X \u2286 Y)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y : Set \u03b1\nhXY : X \u2286 Y\n\u22a2 M.eRk X \u2264 M.eRk Y"}, {"line": "obtain \u27e8I, hI\u27e9 := M.exists_isBasis' X", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y : Set \u03b1\nhXY : X \u2286 Y\nI : Set \u03b1\nhI : M.IsBasis' I X\n\u22a2 M.eRk X \u2264 M.eRk Y"}, {"line": "obtain \u27e8J, hJ, hIJ\u27e9 := hI.indep.subset_isBasis'_of_subset (hI.subset.trans hXY)", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y : Set \u03b1\nhXY : X \u2286 Y\nI : Set \u03b1\nhI : M.IsBasis' I X\nJ : Set \u03b1\nhJ : M.IsBasis' J Y\nhIJ : I \u2286 J\n\u22a2 M.eRk X \u2264 M.eRk Y"}, {"line": "rw [hI.eRk_eq_encard]", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y : Set \u03b1\nhXY : X \u2286 Y\nI : Set \u03b1\nhI : M.IsBasis' I X\nJ : Set \u03b1\nhJ : M.IsBasis' J Y\nhIJ : I \u2286 J\n\u22a2 I.encard \u2264 M.eRk Y"}, {"line": "rw [hJ.eRk_eq_encard]", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y : Set \u03b1\nhXY : X \u2286 Y\nI : Set \u03b1\nhI : M.IsBasis' I X\nJ : Set \u03b1\nhJ : M.IsBasis' J Y\nhIJ : I \u2286 J\n\u22a2 I.encard \u2264 J.encard"}, {"line": "exact encard_mono hIJ", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eRk_le_iff : M.eRk X \u2264 n \u2194 \u2200 \u2983I\u2984, I \u2286 X \u2192 M.Indep I \u2192 I.encard \u2264 n := by\n  refine \u27e8fun h I hIX hI \u21a6 (hI.eRk_eq_encard.symm.trans_le ((M.eRk_mono hIX).trans h)), fun h \u21a6 ?_\u27e9\n  obtain \u27e8I, hI\u27e9 := M.exists_isBasis' X\n  rw [\u2190 hI.encard_eq_eRk]\n  exact h hI.subset hI.indep\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/ENat.lean", "context": {"open": ["Set ENat"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {I B X Y : Set \u03b1} {n : \u2115\u221e} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\nn : \u2115\u221e\n\u22a2 M.eRk X \u2264 n \u2194 \u2200 \u2983I : Set \u03b1\u2984, I \u2286 X \u2192 M.Indep I \u2192 I.encard \u2264 n"}, {"line": "refine \u27e8fun h I hIX hI \u21a6 (hI.eRk_eq_encard.symm.trans_le ((M.eRk_mono hIX).trans h)), fun h \u21a6 ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\nn : \u2115\u221e\nh : \u2200 \u2983I : Set \u03b1\u2984, I \u2286 X \u2192 M.Indep I \u2192 I.encard \u2264 n\n\u22a2 M.eRk X \u2264 n"}, {"line": "obtain \u27e8I, hI\u27e9 := M.exists_isBasis' X", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\nn : \u2115\u221e\nh : \u2200 \u2983I : Set \u03b1\u2984, I \u2286 X \u2192 M.Indep I \u2192 I.encard \u2264 n\nI : Set \u03b1\nhI : M.IsBasis' I X\n\u22a2 M.eRk X \u2264 n"}, {"line": "rw [\u2190 hI.encard_eq_eRk]", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\nn : \u2115\u221e\nh : \u2200 \u2983I : Set \u03b1\u2984, I \u2286 X \u2192 M.Indep I \u2192 I.encard \u2264 n\nI : Set \u03b1\nhI : M.IsBasis' I X\n\u22a2 I.encard \u2264 n"}, {"line": "exact h hI.subset hI.indep", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eRk_inter_add_eRk_union_le (M : Matroid \u03b1) (X Y : Set \u03b1) :\n    M.eRk (X \u2229 Y) + M.eRk (X \u222a Y) \u2264 M.eRk X + M.eRk Y := by\n  obtain \u27e8Ii, hIi\u27e9 := M.exists_isBasis' (X \u2229 Y)\n  obtain \u27e8IX, hIX, hIX'\u27e9 :=\n    hIi.indep.subset_isBasis'_of_subset (hIi.subset.trans inter_subset_left)\n  obtain \u27e8IY, hIY, hIY'\u27e9 :=\n    hIi.indep.subset_isBasis'_of_subset (hIi.subset.trans inter_subset_right)\n  rw [\u2190 hIX.eRk_eq_eRk_union]\n  rw [union_comm]\n  rw [\u2190 hIY.eRk_eq_eRk_union]\n  rw [\u2190 hIi.encard_eq_eRk]\n  rw [\u2190 hIX.encard_eq_eRk]\n  rw [\u2190 hIY.encard_eq_eRk]\n  rw [union_comm]\n  rw [\u2190 encard_union_add_encard_inter]\n  rw [add_comm]\n  exact add_le_add (eRk_le_encard _ _) (encard_mono (subset_inter hIX' hIY'))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/ENat.lean", "context": {"open": ["Set ENat"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {I B X Y : Set \u03b1} {n : \u2115\u221e} {e f : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y : Set \u03b1\n\u22a2 M.eRk (X \u2229 Y) + M.eRk (X \u222a Y) \u2264 M.eRk X + M.eRk Y"}, {"line": "obtain \u27e8Ii, hIi\u27e9 := M.exists_isBasis' (X \u2229 Y)", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y Ii : Set \u03b1\nhIi : M.IsBasis' Ii (X \u2229 Y)\n\u22a2 M.eRk (X \u2229 Y) + M.eRk (X \u222a Y) \u2264 M.eRk X + M.eRk Y"}, {"line": "obtain \u27e8IX, hIX, hIX'\u27e9 :=\n    hIi.indep.subset_isBasis'_of_subset (hIi.subset.trans inter_subset_left)", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y Ii : Set \u03b1\nhIi : M.IsBasis' Ii (X \u2229 Y)\nIX : Set \u03b1\nhIX : M.IsBasis' IX X\nhIX' : Ii \u2286 IX\n\u22a2 M.eRk (X \u2229 Y) + M.eRk (X \u222a Y) \u2264 M.eRk X + M.eRk Y"}, {"line": "obtain \u27e8IY, hIY, hIY'\u27e9 :=\n    hIi.indep.subset_isBasis'_of_subset (hIi.subset.trans inter_subset_right)", "tactic_state": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y Ii : Set \u03b1\nhIi : M.IsBasis' Ii (X \u2229 Y)\nIX : Set \u03b1\nhIX : M.IsBasis' IX X\nhIX' : Ii \u2286 IX\nIY : Set \u03b1\nhIY : M.IsBasis' IY Y\nhIY' : Ii \u2286 IY\n\u22a2 M.eRk (X \u2229 Y) + M.eRk (X \u222a Y) \u2264 M.eRk X + M.eRk Y"}, {"line": "rw [\u2190 hIX.eRk_eq_eRk_union]", "tactic_state": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y Ii : Set \u03b1\nhIi : M.IsBasis' Ii (X \u2229 Y)\nIX : Set \u03b1\nhIX : M.IsBasis' IX X\nhIX' : Ii \u2286 IX\nIY : Set \u03b1\nhIY : M.IsBasis' IY Y\nhIY' : Ii \u2286 IY\n\u22a2 M.eRk (X \u2229 Y) + M.eRk (IX \u222a Y) \u2264 M.eRk X + M.eRk Y"}, {"line": "rw [union_comm]", "tactic_state": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y Ii : Set \u03b1\nhIi : M.IsBasis' Ii (X \u2229 Y)\nIX : Set \u03b1\nhIX : M.IsBasis' IX X\nhIX' : Ii \u2286 IX\nIY : Set \u03b1\nhIY : M.IsBasis' IY Y\nhIY' : Ii \u2286 IY\n\u22a2 M.eRk (X \u2229 Y) + M.eRk (Y \u222a IX) \u2264 M.eRk X + M.eRk Y"}, {"line": "rw [\u2190 hIY.eRk_eq_eRk_union]", "tactic_state": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y Ii : Set \u03b1\nhIi : M.IsBasis' Ii (X \u2229 Y)\nIX : Set \u03b1\nhIX : M.IsBasis' IX X\nhIX' : Ii \u2286 IX\nIY : Set \u03b1\nhIY : M.IsBasis' IY Y\nhIY' : Ii \u2286 IY\n\u22a2 M.eRk (X \u2229 Y) + M.eRk (IY \u222a IX) \u2264 M.eRk X + M.eRk Y"}, {"line": "rw [\u2190 hIi.encard_eq_eRk]", "tactic_state": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y Ii : Set \u03b1\nhIi : M.IsBasis' Ii (X \u2229 Y)\nIX : Set \u03b1\nhIX : M.IsBasis' IX X\nhIX' : Ii \u2286 IX\nIY : Set \u03b1\nhIY : M.IsBasis' IY Y\nhIY' : Ii \u2286 IY\n\u22a2 Ii.encard + M.eRk (IY \u222a IX) \u2264 M.eRk X + M.eRk Y"}, {"line": "rw [\u2190 hIX.encard_eq_eRk]", "tactic_state": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y Ii : Set \u03b1\nhIi : M.IsBasis' Ii (X \u2229 Y)\nIX : Set \u03b1\nhIX : M.IsBasis' IX X\nhIX' : Ii \u2286 IX\nIY : Set \u03b1\nhIY : M.IsBasis' IY Y\nhIY' : Ii \u2286 IY\n\u22a2 Ii.encard + M.eRk (IY \u222a IX) \u2264 IX.encard + M.eRk Y"}, {"line": "rw [\u2190 hIY.encard_eq_eRk]", "tactic_state": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y Ii : Set \u03b1\nhIi : M.IsBasis' Ii (X \u2229 Y)\nIX : Set \u03b1\nhIX : M.IsBasis' IX X\nhIX' : Ii \u2286 IX\nIY : Set \u03b1\nhIY : M.IsBasis' IY Y\nhIY' : Ii \u2286 IY\n\u22a2 Ii.encard + M.eRk (IY \u222a IX) \u2264 IX.encard + IY.encard"}, {"line": "rw [union_comm]", "tactic_state": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y Ii : Set \u03b1\nhIi : M.IsBasis' Ii (X \u2229 Y)\nIX : Set \u03b1\nhIX : M.IsBasis' IX X\nhIX' : Ii \u2286 IX\nIY : Set \u03b1\nhIY : M.IsBasis' IY Y\nhIY' : Ii \u2286 IY\n\u22a2 Ii.encard + M.eRk (IX \u222a IY) \u2264 IX.encard + IY.encard"}, {"line": "rw [\u2190 encard_union_add_encard_inter]", "tactic_state": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y Ii : Set \u03b1\nhIi : M.IsBasis' Ii (X \u2229 Y)\nIX : Set \u03b1\nhIX : M.IsBasis' IX X\nhIX' : Ii \u2286 IX\nIY : Set \u03b1\nhIY : M.IsBasis' IY Y\nhIY' : Ii \u2286 IY\n\u22a2 Ii.encard + M.eRk (IX \u222a IY) \u2264 (IX \u222a IY).encard + (IX \u2229 IY).encard"}, {"line": "rw [add_comm]", "tactic_state": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y Ii : Set \u03b1\nhIi : M.IsBasis' Ii (X \u2229 Y)\nIX : Set \u03b1\nhIX : M.IsBasis' IX X\nhIX' : Ii \u2286 IX\nIY : Set \u03b1\nhIY : M.IsBasis' IY Y\nhIY' : Ii \u2286 IY\n\u22a2 M.eRk (IX \u222a IY) + Ii.encard \u2264 (IX \u222a IY).encard + (IX \u2229 IY).encard"}, {"line": "exact add_le_add (eRk_le_encard _ _) (encard_mono (subset_inter hIX' hIY'))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsRkFinite.subset (h : M.IsRkFinite X) (hXY : Y \u2286 X) : M.IsRkFinite Y := by\n  obtain \u27e8I, hI\u27e9 := M.exists_isBasis' Y\n  obtain \u27e8J, hJ, hIJ\u27e9 := hI.indep.subset_isBasis'_of_subset (hI.subset.trans hXY)\n  exact hI.isRkFinite_of_finite <| (hJ.finite_of_isRkFinite h).subset hIJ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/Finite.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {X Y I : Set \u03b1} {e : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y : Set \u03b1\nh : M.IsRkFinite X\nhXY : Y \u2286 X\n\u22a2 M.IsRkFinite Y"}, {"line": "obtain \u27e8I, hI\u27e9 := M.exists_isBasis' Y", "tactic_state": "case intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y : Set \u03b1\nh : M.IsRkFinite X\nhXY : Y \u2286 X\nI : Set \u03b1\nhI : M.IsBasis' I Y\n\u22a2 M.IsRkFinite Y"}, {"line": "obtain \u27e8J, hJ, hIJ\u27e9 := hI.indep.subset_isBasis'_of_subset (hI.subset.trans hXY)", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y : Set \u03b1\nh : M.IsRkFinite X\nhXY : Y \u2286 X\nI : Set \u03b1\nhI : M.IsBasis' I Y\nJ : Set \u03b1\nhJ : M.IsBasis' J X\nhIJ : I \u2286 J\n\u22a2 M.IsRkFinite Y"}, {"line": "exact hI.isRkFinite_of_finite <| (hJ.finite_of_isRkFinite h).subset hIJ", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsRkFinite.isRkFinite_diff_iff (hX : M.IsRkFinite X) :\n    M.IsRkFinite (Y \\ X) \u2194 M.IsRkFinite Y := by\n  rw [\u2190 hX.isRkFinite_union_iff]\n  rw [union_diff_self]\n  rw [hX.isRkFinite_union_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/Finite.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {X Y I : Set \u03b1} {e : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y : Set \u03b1\nhX : M.IsRkFinite X\n\u22a2 M.IsRkFinite (Y \\ X) \u2194 M.IsRkFinite Y"}, {"line": "rw [\u2190 hX.isRkFinite_union_iff]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y : Set \u03b1\nhX : M.IsRkFinite X\n\u22a2 M.IsRkFinite (X \u222a Y \\ X) \u2194 M.IsRkFinite Y"}, {"line": "rw [union_diff_self]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX Y : Set \u03b1\nhX : M.IsRkFinite X\n\u22a2 M.IsRkFinite (X \u222a Y) \u2194 M.IsRkFinite Y"}, {"line": "rw [hX.isRkFinite_union_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsRkFinite.insert (hX : M.IsRkFinite X) (e : \u03b1) : M.IsRkFinite (insert e X) := by\n  rw [\u2190 union_singleton]\n  exact hX.union M.isRkFinite_singleton\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Matroid/Rank/Finite.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {X Y I : Set \u03b1} {e : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\nhX : M.IsRkFinite X\ne : \u03b1\n\u22a2 M.IsRkFinite (Insert.insert e X)"}, {"line": "rw [\u2190 union_singleton]", "tactic_state": "\u03b1 : Type u_1\nM : Matroid \u03b1\nX : Set \u03b1\nhX : M.IsRkFinite X\ne : \u03b1\n\u22a2 M.IsRkFinite (X \u222a {e})"}, {"line": "exact hX.union M.isRkFinite_singleton", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cons_bind : (a ::\u2098 s).bind f = f a + s.bind f := by simp [bind]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Bind.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 \u03b4 : Type*}", "(a : \u03b1) (s t : Multiset \u03b1) (f g : \u03b1 \u2192 Multiset \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type v\na : \u03b1\ns : Multiset \u03b1\nf : \u03b1 \u2192 Multiset \u03b2\n\u22a2 (a ::\u2098 s).bind f = f a + s.bind f"}, {"line": "simp [bind]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_bind : (s + t).bind f = s.bind f + t.bind f := by simp [bind]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Bind.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 \u03b4 : Type*}", "(a : \u03b1) (s t : Multiset \u03b1) (f g : \u03b1 \u2192 Multiset \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type v\ns t : Multiset \u03b1\nf : \u03b1 \u2192 Multiset \u03b2\n\u22a2 (s + t).bind f = s.bind f + t.bind f"}, {"line": "simp [bind]", "tactic_state": "No Goals!"}]}
