{"declaration": "theorem pi_lift_\u03c0_apply' {\u03b2 : Type v} (f : \u03b2 \u2192 Type v) {P : Type v}\n    (s : \u2200 b, P \u27f6 f b) (b : \u03b2) (x : P) :\n    (Pi.\u03c0 f b : (piObj f) \u2192 f b) (@Pi.lift \u03b2 _ _ f _ P s x) = s b x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Types/Shapes.lean", "context": {"open": ["CategoryTheory Limits"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type v\nf : \u03b2 \u2192 Type v\nP : Type v\ns : (b : \u03b2) \u2192 P \u27f6 f b\nb : \u03b2\nx : P\n\u22a2 Pi.\u03c0 f b (Pi.lift s x) = s b x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_map_\u03c0_apply' {\u03b2 : Type v} {f g : \u03b2 \u2192 Type v} (\u03b1 : \u2200 j, f j \u27f6 g j) (b : \u03b2) (x) :\n    (Pi.\u03c0 g b : \u220f\u1d9c g \u2192 g b) (Pi.map \u03b1 x) = \u03b1 b ((Pi.\u03c0 f b : \u220f\u1d9c f \u2192 f b) x) := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Types/Shapes.lean", "context": {"open": ["CategoryTheory Limits"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type v\nf g : \u03b2 \u2192 Type v\n\u03b1 : (j : \u03b2) \u2192 f j \u27f6 g j\nb : \u03b2\nx : (i : \u03b2) \u2192 f i\n\u22a2 Pi.\u03c0 g b sorry = \u03b1 b (Pi.\u03c0 f b sorry)"}, {"line": "simp", "tactic_state": "\u03b2 : Type v\nf g : \u03b2 \u2192 Type v\n\u03b1 : (j : \u03b2) \u2192 f j \u27f6 g j\nb : \u03b2\nx : (i : \u03b2) \u2192 f i\n\u22a2 Pi.\u03c0 g b (sorry ()) = \u03b1 b (Pi.\u03c0 f b (sorry ()))"}]}
{"declaration": "lemma initial_iff_empty (X : Type u) : Nonempty (IsInitial X) \u2194 IsEmpty X := by\n  constructor\n  \u00b7 intro \u27e8h\u27e9\n    exact Function.isEmpty (IsInitial.to h PEmpty)\n  \u00b7 intro h\n    exact \u27e8IsInitial.ofIso Types.isInitialPunit <| Equiv.toIso <| Equiv.equivOfIsEmpty PEmpty X\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Types/Shapes.lean", "context": {"open": ["CategoryTheory Limits"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\n\u22a2 Nonempty (IsInitial X) \u2194 IsEmpty X"}, {"line": "constructor", "tactic_state": "case mp\nX : Type u\n\u22a2 Nonempty (IsInitial X) \u2192 IsEmpty X\n---\ncase mpr\nX : Type u\n\u22a2 IsEmpty X \u2192 Nonempty (IsInitial X)"}, {"line": "\u00b7 intro \u27e8h\u27e9\n    exact Function.isEmpty (IsInitial.to h PEmpty)", "tactic_state": "case mpr\nX : Type u\n\u22a2 IsEmpty X \u2192 Nonempty (IsInitial X)"}, {"line": "\u00b7 intro h\n    exact \u27e8IsInitial.ofIso Types.isInitialPunit <| Equiv.toIso <| Equiv.equivOfIsEmpty PEmpty X\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem binaryCofan_isColimit_iff {X Y : Type u} (c : BinaryCofan X Y) :\n    Nonempty (IsColimit c) \u2194\n      Injective c.inl \u2227 Injective c.inr \u2227 IsCompl (Set.range c.inl) (Set.range c.inr) := by\n  classical\n    constructor\n    \u00b7 rintro \u27e8h\u27e9\n      rw [\u2190 show _ = c.inl from           h.comp_coconePointUniqueUpToIso_inv (binaryCoproductColimit X Y) \u27e8WalkingPair.left\u27e9]\n      rw [\u2190 show _ = c.inr from           h.comp_coconePointUniqueUpToIso_inv (binaryCoproductColimit X Y) \u27e8WalkingPair.right\u27e9]\n      dsimp [binaryCoproductCocone]\n      refine\n        \u27e8(h.coconePointUniqueUpToIso (binaryCoproductColimit X Y)).symm.toEquiv.injective.comp\n            Sum.inl_injective,\n          (h.coconePointUniqueUpToIso (binaryCoproductColimit X Y)).symm.toEquiv.injective.comp\n            Sum.inr_injective, ?_\u27e9\n      rw [types_comp]\n      rw [Set.range_comp]\n      rw [\u2190 eq_compl_iff_isCompl]\n      rw [types_comp]\n      rw [Set.range_comp _ Sum.inr]\n      erw [\u2190 Set.image_compl_eq\n          (h.coconePointUniqueUpToIso (binaryCoproductColimit X Y)).symm.toEquiv.bijective]\n      simp\n    \u00b7 rintro \u27e8h\u2081, h\u2082, h\u2083\u27e9\n      have : \u2200 x, x \u2208 Set.range c.inl \u2228 x \u2208 Set.range c.inr := by\n        rw [eq_compl_iff_isCompl.mpr h\u2083.symm]\n        exact fun _ => or_not\n      refine \u27e8BinaryCofan.IsColimit.mk _ ?_ ?_ ?_ ?_\u27e9\n      \u00b7 intro T f g x\n        exact\n          if h : x \u2208 Set.range c.inl then f ((Equiv.ofInjective _ h\u2081).symm \u27e8x, h\u27e9)\n          else g ((Equiv.ofInjective _ h\u2082).symm \u27e8x, (this x).resolve_left h\u27e9)\n      \u00b7 intro T f g\n        funext x\n        dsimp\n        simp [h\u2081.eq_iff]\n      \u00b7 intro T f g\n        funext x\n        dsimp\n        simp only [Set.mem_range]\n        simp only [Equiv.ofInjective_symm_apply]\n        simp only [dite_eq_right_iff]\n        simp only [forall_exists_index]\n        intro y e\n        have : c.inr x \u2208 Set.range c.inl \u2293 Set.range c.inr := \u27e8\u27e8_, e\u27e9, \u27e8_, rfl\u27e9\u27e9\n        rw [disjoint_iff.mp h\u2083.1] at this\n        exact this.elim\n      \u00b7 rintro T _ _ m rfl rfl\n        funext x\n        dsimp\n        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ \u27e8_, _\u27e9).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Types/Shapes.lean", "context": {"open": ["CategoryTheory Limits", "CategoryTheory.Limits.WalkingPair", "Function (Injective)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Type u\nc : BinaryCofan X Y\n\u22a2 Nonempty (IsColimit c) \u2194\n    Function.Injective c.inl \u2227 Function.Injective c.inr \u2227 IsCompl (Set.range c.inl) (Set.range c.inr)"}, {"line": "classical\n    constructor\n    \u00b7 rintro \u27e8h\u27e9\n      rw [\u2190 show _ = c.inl from           h.comp_coconePointUniqueUpToIso_inv (binaryCoproductColimit X Y) \u27e8WalkingPair.left\u27e9]\n      rw [\u2190 show _ = c.inr from           h.comp_coconePointUniqueUpToIso_inv (binaryCoproductColimit X Y) \u27e8WalkingPair.right\u27e9]\n      dsimp [binaryCoproductCocone]\n      refine\n        \u27e8(h.coconePointUniqueUpToIso (binaryCoproductColimit X Y)).symm.toEquiv.injective.comp\n            Sum.inl_injective,\n          (h.coconePointUniqueUpToIso (binaryCoproductColimit X Y)).symm.toEquiv.injective.comp\n            Sum.inr_injective, ?_\u27e9\n      rw [types_comp]\n      rw [Set.range_comp]\n      rw [\u2190 eq_compl_iff_isCompl]\n      rw [types_comp]\n      rw [Set.range_comp _ Sum.inr]\n      erw [\u2190 Set.image_compl_eq\n          (h.coconePointUniqueUpToIso (binaryCoproductColimit X Y)).symm.toEquiv.bijective]\n      simp\n    \u00b7 rintro \u27e8h\u2081, h\u2082, h\u2083\u27e9\n      have : \u2200 x, x \u2208 Set.range c.inl \u2228 x \u2208 Set.range c.inr := by\n        rw [eq_compl_iff_isCompl.mpr h\u2083.symm]\n        exact fun _ => or_not\n      refine \u27e8BinaryCofan.IsColimit.mk _ ?_ ?_ ?_ ?_\u27e9\n      \u00b7 intro T f g x\n        exact\n          if h : x \u2208 Set.range c.inl then f ((Equiv.ofInjective _ h\u2081).symm \u27e8x, h\u27e9)\n          else g ((Equiv.ofInjective _ h\u2082).symm \u27e8x, (this x).resolve_left h\u27e9)\n      \u00b7 intro T f g\n        funext x\n        dsimp\n        simp [h\u2081.eq_iff]\n      \u00b7 intro T f g\n        funext x\n        dsimp\n        simp only [Set.mem_range]\n        simp only [Equiv.ofInjective_symm_apply]\n        simp only [dite_eq_right_iff]\n        simp only [forall_exists_index]\n        intro y e\n        have : c.inr x \u2208 Set.range c.inl \u2293 Set.range c.inr := \u27e8\u27e8_, e\u27e9, \u27e8_, rfl\u27e9\u27e9\n        rw [disjoint_iff.mp h\u2083.1] at this\n        exact this.elim\n      \u00b7 rintro T _ _ m rfl rfl\n        funext x\n        dsimp\n        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ \u27e8_, _\u27e9).symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inl_rel'_inr_iff (x\u2081 : X\u2081) (x\u2082 : X\u2082) :\n    Rel' f g (Sum.inl x\u2081) (Sum.inr x\u2082) \u2194\n      \u2203 (s : S), x\u2081 = f s \u2227 x\u2082 = g s := by\n  constructor\n  \u00b7 rintro \u27e8_\u27e9\n    exact \u27e8_, rfl, rfl\u27e9\n  \u00b7 rintro \u27e8s, rfl, rfl\u27e9\n    exact Rel'.inl_inr _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Types/Shapes.lean", "context": {"open": ["CategoryTheory Limits", "CategoryTheory.Limits.WalkingPair", "Function (Injective)", "CategoryTheory.Limits.WalkingCospan"], "variables": ["{J : Type v} (F : J \u2192 Type u) [Small.{u} J]", "{X Y Z : Type u} (f : X \u27f6 Y) {g h : Y \u27f6 Z} (w : f \u226b g = f \u226b h)", "(g h)", "{X Y Z : Type u} (f g : X \u27f6 Y)", "{X Y Z : Type u} {X' Y' Z' : Type v}", "(f : X \u27f6 Z) (g : Y \u27f6 Z) (f' : X' \u27f6 Z') (g' : Y' \u27f6 Z')", "{X Y S : Type v} {f : X \u27f6 S} {g : Y \u27f6 S} {c : PullbackCone f g}", "(hc : IsLimit c)", "(c)", "{W X Y Z : Type u}", "(f : X \u27f6 Z) (g : Y \u27f6 Z)", "{S X\u2081 X\u2082 : Type u} (f : S \u27f6 X\u2081) (g : S \u27f6 X\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S X\u2081 X\u2082 : Type u\nf : S \u27f6 X\u2081\ng : S \u27f6 X\u2082\nx\u271d : Sort u_1\nRel' : x\u271d\nx\u2081 : X\u2081\nx\u2082 : X\u2082\n\u22a2 sorry \u2194 \u2203 s, x\u2081 = f s \u2227 x\u2082 = g s"}, {"line": "constructor", "tactic_state": "case mp\nS X\u2081 X\u2082 : Type u\nf : S \u27f6 X\u2081\ng : S \u27f6 X\u2082\nx\u271d : Sort u_1\nRel' : x\u271d\nx\u2081 : X\u2081\nx\u2082 : X\u2082\n\u22a2 sorry \u2192 \u2203 s, x\u2081 = f s \u2227 x\u2082 = g s\n---\ncase mpr\nS X\u2081 X\u2082 : Type u\nf : S \u27f6 X\u2081\ng : S \u27f6 X\u2082\nx\u271d : Sort u_1\nRel' : x\u271d\nx\u2081 : X\u2081\nx\u2082 : X\u2082\n\u22a2 (\u2203 s, x\u2081 = f s \u2227 x\u2082 = g s) \u2192 sorry"}, {"line": "\u00b7 rintro \u27e8_\u27e9\n    exact \u27e8_, rfl, rfl\u27e9", "tactic_state": "case mpr\nS X\u2081 X\u2082 : Type u\nf : S \u27f6 X\u2081\ng : S \u27f6 X\u2082\nx\u271d : Sort u_1\nRel' : x\u271d\nx\u2081 : X\u2081\nx\u2082 : X\u2082\n\u22a2 (\u2203 s, x\u2081 = f s \u2227 x\u2082 = g s) \u2192 sorry"}, {"line": "\u00b7 rintro \u27e8s, rfl, rfl\u27e9\n    exact Rel'.inl_inr _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inr_rel'_inr_iff (x\u2082 y\u2082 : X\u2082) :\n    Rel' f g (Sum.inr x\u2082) (Sum.inr y\u2082) \u2194 x\u2082 = y\u2082 := by\n  constructor\n  \u00b7 rintro \u27e8_\u27e9\n    rfl\n  \u00b7 rintro rfl\n    apply Rel'.refl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Types/Shapes.lean", "context": {"open": ["CategoryTheory Limits", "CategoryTheory.Limits.WalkingPair", "Function (Injective)", "CategoryTheory.Limits.WalkingCospan"], "variables": ["{J : Type v} (F : J \u2192 Type u) [Small.{u} J]", "{X Y Z : Type u} (f : X \u27f6 Y) {g h : Y \u27f6 Z} (w : f \u226b g = f \u226b h)", "(g h)", "{X Y Z : Type u} (f g : X \u27f6 Y)", "{X Y Z : Type u} {X' Y' Z' : Type v}", "(f : X \u27f6 Z) (g : Y \u27f6 Z) (f' : X' \u27f6 Z') (g' : Y' \u27f6 Z')", "{X Y S : Type v} {f : X \u27f6 S} {g : Y \u27f6 S} {c : PullbackCone f g}", "(hc : IsLimit c)", "(c)", "{W X Y Z : Type u}", "(f : X \u27f6 Z) (g : Y \u27f6 Z)", "{S X\u2081 X\u2082 : Type u} (f : S \u27f6 X\u2081) (g : S \u27f6 X\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X\u2082 : Type u\nx\u271d : Sort u_1\nRel' : x\u271d\nx\u2082 y\u2082 : X\u2082\n\u22a2 sorry \u2194 x\u2082 = y\u2082"}, {"line": "constructor", "tactic_state": "case mp\nX\u2082 : Type u\nx\u271d : Sort u_1\nRel' : x\u271d\nx\u2082 y\u2082 : X\u2082\n\u22a2 sorry \u2192 x\u2082 = y\u2082\n---\ncase mpr\nX\u2082 : Type u\nx\u271d : Sort u_1\nRel' : x\u271d\nx\u2082 y\u2082 : X\u2082\n\u22a2 x\u2082 = y\u2082 \u2192 sorry"}, {"line": "\u00b7 rintro \u27e8_\u27e9\n    rfl", "tactic_state": "case mpr\nX\u2082 : Type u\nx\u271d : Sort u_1\nRel' : x\u271d\nx\u2082 y\u2082 : X\u2082\n\u22a2 x\u2082 = y\u2082 \u2192 sorry"}, {"line": "\u00b7 rintro rfl\n    apply Rel'.refl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pushoutCocone_inl_eq_inr_imp_of_iso {c c' : PushoutCocone f g} (e : c \u2245 c')\n    (x\u2081 : X\u2081) (x\u2082 : X\u2082) (h : c.inl x\u2081 = c.inr x\u2082) :\n    c'.inl x\u2081 = c'.inr x\u2082 := by\n  convert congr_arg e.hom.hom h\n  \u00b7 exact congr_fun (e.hom.w WalkingSpan.left).symm x\u2081\n  \u00b7 exact congr_fun (e.hom.w WalkingSpan.right).symm x\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Types/Shapes.lean", "context": {"open": ["CategoryTheory Limits", "CategoryTheory.Limits.WalkingPair", "Function (Injective)", "CategoryTheory.Limits.WalkingCospan"], "variables": ["{J : Type v} (F : J \u2192 Type u) [Small.{u} J]", "{X Y Z : Type u} (f : X \u27f6 Y) {g h : Y \u27f6 Z} (w : f \u226b g = f \u226b h)", "(g h)", "{X Y Z : Type u} (f g : X \u27f6 Y)", "{X Y Z : Type u} {X' Y' Z' : Type v}", "(f : X \u27f6 Z) (g : Y \u27f6 Z) (f' : X' \u27f6 Z') (g' : Y' \u27f6 Z')", "{X Y S : Type v} {f : X \u27f6 S} {g : Y \u27f6 S} {c : PullbackCone f g}", "(hc : IsLimit c)", "(c)", "{W X Y Z : Type u}", "(f : X \u27f6 Z) (g : Y \u27f6 Z)", "{S X\u2081 X\u2082 : Type u} (f : S \u27f6 X\u2081) (g : S \u27f6 X\u2082)", "{f g}", "(f g)", "{f g}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S X\u2081 X\u2082 : Type u\nf : S \u27f6 X\u2081\ng : S \u27f6 X\u2082\nc c' : PushoutCocone f g\ne : c \u2245 c'\nx\u2081 : X\u2081\nx\u2082 : X\u2082\nh : c.inl x\u2081 = c.inr x\u2082\n\u22a2 c'.inl x\u2081 = c'.inr x\u2082"}, {"line": "convert congr_arg e.hom.hom h", "tactic_state": "case h.e'_2\nS X\u2081 X\u2082 : Type u\nf : S \u27f6 X\u2081\ng : S \u27f6 X\u2082\nc c' : PushoutCocone f g\ne : c \u2245 c'\nx\u2081 : X\u2081\nx\u2082 : X\u2082\nh : c.inl x\u2081 = c.inr x\u2082\n\u22a2 c'.inl x\u2081 = e.hom.hom (c.inl x\u2081)\n---\ncase h.e'_3\nS X\u2081 X\u2082 : Type u\nf : S \u27f6 X\u2081\ng : S \u27f6 X\u2082\nc c' : PushoutCocone f g\ne : c \u2245 c'\nx\u2081 : X\u2081\nx\u2082 : X\u2082\nh : c.inl x\u2081 = c.inr x\u2082\n\u22a2 c'.inr x\u2082 = e.hom.hom (c.inr x\u2082)"}, {"line": "\u00b7 exact congr_fun (e.hom.w WalkingSpan.left).symm x\u2081", "tactic_state": "case h.e'_3\nS X\u2081 X\u2082 : Type u\nf : S \u27f6 X\u2081\ng : S \u27f6 X\u2082\nc c' : PushoutCocone f g\ne : c \u2245 c'\nx\u2081 : X\u2081\nx\u2082 : X\u2082\nh : c.inl x\u2081 = c.inr x\u2082\n\u22a2 c'.inr x\u2082 = e.hom.hom (c.inr x\u2082)"}, {"line": "\u00b7 exact congr_fun (e.hom.w WalkingSpan.right).symm x\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pushoutCocone_inl_eq_inr_iff_of_iso {c c' : PushoutCocone f g} (e : c \u2245 c')\n    (x\u2081 : X\u2081) (x\u2082 : X\u2082) :\n    c.inl x\u2081 = c.inr x\u2082 \u2194 c'.inl x\u2081 = c'.inr x\u2082 := by\n  constructor\n  \u00b7 apply pushoutCocone_inl_eq_inr_imp_of_iso e\n  \u00b7 apply pushoutCocone_inl_eq_inr_imp_of_iso e.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Limits/Types/Shapes.lean", "context": {"open": ["CategoryTheory Limits", "CategoryTheory.Limits.WalkingPair", "Function (Injective)", "CategoryTheory.Limits.WalkingCospan"], "variables": ["{J : Type v} (F : J \u2192 Type u) [Small.{u} J]", "{X Y Z : Type u} (f : X \u27f6 Y) {g h : Y \u27f6 Z} (w : f \u226b g = f \u226b h)", "(g h)", "{X Y Z : Type u} (f g : X \u27f6 Y)", "{X Y Z : Type u} {X' Y' Z' : Type v}", "(f : X \u27f6 Z) (g : Y \u27f6 Z) (f' : X' \u27f6 Z') (g' : Y' \u27f6 Z')", "{X Y S : Type v} {f : X \u27f6 S} {g : Y \u27f6 S} {c : PullbackCone f g}", "(hc : IsLimit c)", "(c)", "{W X Y Z : Type u}", "(f : X \u27f6 Z) (g : Y \u27f6 Z)", "{S X\u2081 X\u2082 : Type u} (f : S \u27f6 X\u2081) (g : S \u27f6 X\u2082)", "{f g}", "(f g)", "{f g}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S X\u2081 X\u2082 : Type u\nf : S \u27f6 X\u2081\ng : S \u27f6 X\u2082\nc c' : PushoutCocone f g\ne : c \u2245 c'\nx\u2081 : X\u2081\nx\u2082 : X\u2082\n\u22a2 c.inl x\u2081 = c.inr x\u2082 \u2194 c'.inl x\u2081 = c'.inr x\u2082"}, {"line": "constructor", "tactic_state": "case mp\nS X\u2081 X\u2082 : Type u\nf : S \u27f6 X\u2081\ng : S \u27f6 X\u2082\nc c' : PushoutCocone f g\ne : c \u2245 c'\nx\u2081 : X\u2081\nx\u2082 : X\u2082\n\u22a2 c.inl x\u2081 = c.inr x\u2082 \u2192 c'.inl x\u2081 = c'.inr x\u2082\n---\ncase mpr\nS X\u2081 X\u2082 : Type u\nf : S \u27f6 X\u2081\ng : S \u27f6 X\u2082\nc c' : PushoutCocone f g\ne : c \u2245 c'\nx\u2081 : X\u2081\nx\u2082 : X\u2082\n\u22a2 c'.inl x\u2081 = c'.inr x\u2082 \u2192 c.inl x\u2081 = c.inr x\u2082"}, {"line": "\u00b7 apply pushoutCocone_inl_eq_inr_imp_of_iso e", "tactic_state": "case mpr\nS X\u2081 X\u2082 : Type u\nf : S \u27f6 X\u2081\ng : S \u27f6 X\u2082\nc c' : PushoutCocone f g\ne : c \u2245 c'\nx\u2081 : X\u2081\nx\u2082 : X\u2082\n\u22a2 c'.inl x\u2081 = c'.inr x\u2082 \u2192 c.inl x\u2081 = c.inr x\u2082"}, {"line": "\u00b7 apply pushoutCocone_inl_eq_inr_imp_of_iso e.symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma homEquiv_map (f : X \u27f6 Y) : homEquiv W L\u2081 L\u2082 (L\u2081.map f) = L\u2082.map f := by\n  simp [homEquiv_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Localization/HomEquiv.lean", "context": {"open": ["Category"], "variables": ["{C C\u2081 C\u2082 C\u2083 D\u2081 D\u2082 D\u2083 : Type*} [Category C]", "{W\u2081 : MorphismProperty C\u2081} {W\u2082 : MorphismProperty C\u2082} {W\u2083 : MorphismProperty C\u2083}", "(X) in", "(W : MorphismProperty C) (L\u2081 : C \u2964 D\u2081) [L\u2081.IsLocalization W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MorphismProperty : ?m.3837\nW\u2081 : sorry\nW\u2082 : sorry\nW\u2083 : sorry\nV\u271d : Type u_1\nX Y : V\u271d\nx\u271d : Sort u_2\nhomEquiv : x\u271d\nf : X \u27f6 Y\n\u22a2 sorry = sorry"}, {"line": "simp [homEquiv_apply]", "tactic_state": "MorphismProperty : ?m.3837\nW\u2081 : sorry\nW\u2082 : sorry\nW\u2083 : sorry\nV\u271d : Type u_1\nX Y : V\u271d\nx\u271d : Sort u_2\nhomEquiv : x\u271d\nf : X \u27f6 Y\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma hasRightCalculusOfFractions (adj : F \u22a3 G) :\n    ((isomorphisms C\u2082).inverseImage G).HasRightCalculusOfFractions := by\n  suffices ((isomorphisms C\u2082).inverseImage G).op.HasLeftCalculusOfFractions from\n    inferInstanceAs ((isomorphisms C\u2082).inverseImage G).op.unop.HasRightCalculusOfFractions\n  simpa only [\u2190 isomorphisms_op] using adj.op.hasLeftCalculusOfFractions\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Localization/CalculusOfFractions/OfAdjunction.lean", "context": {"open": ["MorphismProperty"], "variables": ["{C\u2081 C\u2082 : Type*} [Category C\u2081] [Category C\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "obj\u271d\u00b9 : Type u_1\ninst\u271d\u00b9 : CategoryTheory.Category.{u_2, u_1} obj\u271d\u00b9\nobj\u271d : Type u_3\ninst\u271d : CategoryTheory.Category.{u_4, u_3} obj\u271d\nF : CategoryTheory.Functor obj\u271d\u00b9 obj\u271d\nG : CategoryTheory.Functor obj\u271d obj\u271d\u00b9\nx\u271d : Sort u_5\nisomorphisms : x\u271d\nadj : F \u22a3 G\n\u22a2 sorry"}, {"line": "suffices ((isomorphisms C\u2082).inverseImage G).op.HasLeftCalculusOfFractions from\n    inferInstanceAs ((isomorphisms C\u2082).inverseImage G).op.unop.HasRightCalculusOfFractions", "tactic_state": "obj\u271d\u00b9 : Type u_1\ninst\u271d\u00b9 : CategoryTheory.Category.{u_2, u_1} obj\u271d\u00b9\nobj\u271d : Type u_3\ninst\u271d : CategoryTheory.Category.{u_4, u_3} obj\u271d\nF : CategoryTheory.Functor obj\u271d\u00b9 obj\u271d\nG : CategoryTheory.Functor obj\u271d obj\u271d\u00b9\nx\u271d : Sort u_5\nisomorphisms : x\u271d\nadj : F \u22a3 G\n\u22a2 sorry"}, {"line": "simpa only [\u2190 isomorphisms_op] using adj.op.hasLeftCalculusOfFractions", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_eq (f\u2081 f\u2082 : X' \u27f6 Y') :\n    letI := addCommGroup L W X' Y'\n    f\u2081 + f\u2082 = add W eX eY f\u2081 f\u2082 := by\n  apply add_eq_add\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Localization/CalculusOfFractions/Preadditive.lean", "context": {"open": ["MorphismProperty Preadditive Limits Category"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] (L : C \u2964 D)", "{X Y : C} (\u03c6 : W.LeftFraction\u2082 X Y)", "(W)", "[W.HasLeftCalculusOfFractions] {X Y Z : C}", "{L}", "(L X Y)", "{X Y}", "{L}", "{X' Y' Z' : D} (eX : L.obj X \u2245 X') (eY : L.obj Y \u2245 Y') (eZ : L.obj Z \u2245 Z')", "(L X' Y') in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\naddCommGroup : x\u271d\u00b9\nx\u271d : Sort u_2\nadd : x\u271d\nf\u2081 : sorry\nf\u2082 : sorry\n\u22a2 sorry"}, {"line": "apply add_eq_add", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_counit (M : Bimon_ C) :\n    M.X.mul \u226b M.counit.hom = (M.counit.hom \u2297 M.counit.hom) \u226b (\u03bb_ _).hom := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Bimon_.lean", "context": {"open": ["CategoryTheory MonoidalCategory", "scoped Mon_Class Comon_Class"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [MonoidalCategory.{v\u2081} C] [BraidedCategory C]", "(M : C) [Bimon_Class M]", "(C)", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : MonoidalCategory C\ninst\u271d : BraidedCategory C\nM : Bimon_ C\n\u22a2 CategoryStruct.comp M.X.mul M.counit.hom =\n    CategoryStruct.comp (tensorHom M.counit.hom M.counit.hom) (leftUnitor (tensorUnit (Mon_ C)).X).hom"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tensorLeftTensor_inv_app (X Y Z : C) :\n    (tensorLeftTensor X Y).inv.app Z = (associator X Y Z).inv := by simp [tensorLeftTensor]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Category.lean", "context": {"open": ["CategoryTheory.Category", "CategoryTheory.Iso", "MonoidalCategory"], "variables": ["{C : Type u} [\ud835\udc9e : Category.{v} C] [MonoidalCategory C]", "{W X Y Z : C}", "(C)", "{C}", "(C)", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Sort u_4\nx\u271d\u00b9 : Sort u_1\ntensorLeftTensor : x\u271d\u00b9\nx\u271d : Sort u_2\nassociator : x\u271d\nX Y Z : C\n\u22a2 sorry = sorry"}, {"line": "simp [tensorLeftTensor]", "tactic_state": "C : Sort u_4\nx\u271d\u00b9 : Sort u_1\ntensorLeftTensor : x\u271d\u00b9\nx\u271d : Sort u_2\nassociator : x\u271d\nX Y Z : C\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem tensorObj_comul' (A B : Comon_ C) :\n    (A \u2297 B).comul =\n      (A.comul \u2297 B.comul) \u226b (tensor\u03bc (op A.X) (op B.X) (op A.X) (op B.X)).unop := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Comon_.lean", "context": {"open": ["CategoryTheory MonoidalCategory", "scoped Comon_Class", "CategoryTheory.Limits", "Opposite"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [MonoidalCategory.{v\u2081} C]", "{M N : C} [Comon_Class M] [Comon_Class N]", "(C)", "{C}", "(C)", "{C}", "{M : Comon_ C}", "(C)", "(C)", "[BraidedCategory C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : MonoidalCategory C\ninst\u271d : BraidedCategory C\nA B : Comon_ C\n\u22a2 (tensorObj A B).comul =\n    CategoryStruct.comp (tensorHom A.comul B.comul) (tensor\u03bc (op A.X) (op B.X) (op A.X) (op B.X)).unop"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_lift_inv_left {A : C} {B : Grp_ C} (f g h : A \u27f6 B.X) :\n    f = lift (g \u226b B.inv) h \u226b B.mul \u2194 lift g f \u226b B.mul = h := by\n  refine \u27e8?_, ?_\u27e9 <;> (rintro rfl; simp [\u2190 lift_lift_assoc])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Grp_.lean", "context": {"open": ["CategoryTheory Category Limits MonoidalCategory ChosenFiniteProducts Mon_", "scoped Mon_Class"], "variables": ["(C : Type u\u2081) [Category.{v\u2081} C] [ChosenFiniteProducts.{v\u2081} C]", "{C}", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : ChosenFiniteProducts C\nA : C\nB : Grp_ C\nf g h : A \u27f6 B.X\n\u22a2 f = CategoryStruct.comp (lift (CategoryStruct.comp g B.inv) h) B.mul \u2194 CategoryStruct.comp (lift g f) B.mul = h"}, {"line": "refine \u27e8?_, ?_\u27e9 <;> (rintro rfl; simp [\u2190 lift_lift_assoc])", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_lift_inv_right {A : C} {B : Grp_ C} (f g h : A \u27f6 B.X) :\n    f = lift g (h \u226b B.inv) \u226b B.mul \u2194 lift f h \u226b B.mul = g := by\n  refine \u27e8?_, ?_\u27e9 <;> (rintro rfl; simp [lift_lift_assoc])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Grp_.lean", "context": {"open": ["CategoryTheory Category Limits MonoidalCategory ChosenFiniteProducts Mon_", "scoped Mon_Class"], "variables": ["(C : Type u\u2081) [Category.{v\u2081} C] [ChosenFiniteProducts.{v\u2081} C]", "{C}", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : ChosenFiniteProducts C\nA : C\nB : Grp_ C\nf g h : A \u27f6 B.X\n\u22a2 f = CategoryStruct.comp (lift g (CategoryStruct.comp h B.inv)) B.mul \u2194 CategoryStruct.comp (lift f h) B.mul = g"}, {"line": "refine \u27e8?_, ?_\u27e9 <;> (rintro rfl; simp [lift_lift_assoc])", "tactic_state": "No Goals!"}]}
{"declaration": "theorem assoc_flip :\n    (A.X \u25c1 M.act) \u226b M.act = (\u03b1_ A.X A.X M.X).inv \u226b (A.mul \u25b7 M.X) \u226b M.act := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Mod_.lean", "context": {"open": ["CategoryTheory MonoidalCategory"], "variables": ["(C : Type u\u2081) [Category.{v\u2081} C] [MonoidalCategory.{v\u2081} C]", "{C}", "{A : Mon_ C} (M : Mod_ A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : MonoidalCategory C\nA : Mon_ C\nM : Mod_ A\n\u22a2 CategoryStruct.comp (MonoidalCategoryStruct.whiskerLeft A.X M.act) M.act =\n    CategoryStruct.comp (associator A.X A.X M.X).inv\n      (CategoryStruct.comp (MonoidalCategoryStruct.whiskerRight A.mul M.X) M.act)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem id_hom' (M : Mod_ A) : (\ud835\udfd9 M : M \u27f6 M).hom = \ud835\udfd9 M.X := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Mod_.lean", "context": {"open": ["CategoryTheory MonoidalCategory"], "variables": ["(C : Type u\u2081) [Category.{v\u2081} C] [MonoidalCategory.{v\u2081} C]", "{C}", "{A : Mon_ C} (M : Mod_ A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : MonoidalCategory C\nA : Mon_ C\nM : Mod_ A\n\u22a2 (CategoryStruct.id M).hom = CategoryStruct.id M.X"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_assoc_flip :\n    (M.X \u25c1 M.mul) \u226b M.mul = (\u03b1_ M.X M.X M.X).inv \u226b (M.mul \u25b7 M.X) \u226b M.mul := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Mon_.lean", "context": {"open": ["CategoryTheory MonoidalCategory Functor.LaxMonoidal Functor.OplaxMonoidal", "scoped Mon_Class"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [MonoidalCategory.{v\u2081} C]", "{M N : C} [Mon_Class M] [Mon_Class N]", "(C)", "{C}", "(C)", "{C}", "{M : Mon_ C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : MonoidalCategory C\nM : Mon_ C\n\u22a2 CategoryStruct.comp (MonoidalCategoryStruct.whiskerLeft M.X M.mul) M.mul =\n    CategoryStruct.comp (associator M.X M.X M.X).inv\n      (CategoryStruct.comp (MonoidalCategoryStruct.whiskerRight M.mul M.X) M.mul)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_leftUnitor {M : Mon_ C} :\n    ((\u03bb_ (\ud835\udfd9_ C)).inv \u226b (\ud835\udfd9 (\ud835\udfd9_ C) \u2297 M.one)) \u226b (\u03bb_ M.X).hom = M.one := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Mon_.lean", "context": {"open": ["CategoryTheory MonoidalCategory Functor.LaxMonoidal Functor.OplaxMonoidal", "scoped Mon_Class", "CategoryTheory.Limits", "EquivLaxMonoidalFunctorPUnit"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [MonoidalCategory.{v\u2081} C]", "{M N : C} [Mon_Class M] [Mon_Class N]", "(C)", "{C}", "(C)", "{C}", "{M : Mon_ C}", "(C)", "{C} {D : Type u\u2082} [Category.{v\u2082} D] [MonoidalCategory.{v\u2082} D] (F : C \u2964 D)", "[F.LaxMonoidal] (X Y : C) [Mon_Class X] [Mon_Class Y] (f : X \u27f6 Y) [IsMon_Hom f]", "[F.Monoidal]", "(C D)", "{C}", "(C)", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : MonoidalCategory C\nM : Mon_ C\n\u22a2 CategoryStruct.comp\n      (CategoryStruct.comp (leftUnitor (tensorUnit C)).inv (tensorHom (CategoryStruct.id (tensorUnit C)) M.one))\n      (leftUnitor M.X).hom =\n    M.one"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_rightUnitor {M : Mon_ C} :\n    ((\u03bb_ (\ud835\udfd9_ C)).inv \u226b (M.one \u2297 \ud835\udfd9 (\ud835\udfd9_ C))) \u226b (\u03c1_ M.X).hom = M.one := by\n  simp [\u2190 unitors_equal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Mon_.lean", "context": {"open": ["CategoryTheory MonoidalCategory Functor.LaxMonoidal Functor.OplaxMonoidal", "scoped Mon_Class", "CategoryTheory.Limits", "EquivLaxMonoidalFunctorPUnit"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [MonoidalCategory.{v\u2081} C]", "{M N : C} [Mon_Class M] [Mon_Class N]", "(C)", "{C}", "(C)", "{C}", "{M : Mon_ C}", "(C)", "{C} {D : Type u\u2082} [Category.{v\u2082} D] [MonoidalCategory.{v\u2082} D] (F : C \u2964 D)", "[F.LaxMonoidal] (X Y : C) [Mon_Class X] [Mon_Class Y] (f : X \u27f6 Y) [IsMon_Hom f]", "[F.Monoidal]", "(C D)", "{C}", "(C)", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : MonoidalCategory C\nM : Mon_ C\n\u22a2 CategoryStruct.comp\n      (CategoryStruct.comp (leftUnitor (tensorUnit C)).inv (tensorHom M.one (CategoryStruct.id (tensorUnit C))))\n      (rightUnitor M.X).hom =\n    M.one"}, {"line": "simp [\u2190 unitors_equal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_tensor {W X Y Z : C} (f : Y \u27f6 Z) : (0 : W \u27f6 X) \u2297 f = 0 := by\n  simp [tensorHom_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Preadditive.lean", "context": {"open": ["CategoryTheory.Limits", "CategoryTheory.MonoidalCategory"], "variables": ["(C : Type*) [Category C] [Preadditive C] [MonoidalCategory C]", "{C}", "[MonoidalPreadditive C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_2\nW X Y Z : C\nf : sorry\n\u22a2 sorry = 0"}, {"line": "simp [tensorHom_def]", "tactic_state": "C : Type u_2\nW X Y Z : C\nf : sorry\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem tensor_add {W X Y Z : C} (f : W \u27f6 X) (g h : Y \u27f6 Z) : f \u2297 (g + h) = f \u2297 g + f \u2297 h := by\n  simp [tensorHom_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Preadditive.lean", "context": {"open": ["CategoryTheory.Limits", "CategoryTheory.MonoidalCategory"], "variables": ["(C : Type*) [Category C] [Preadditive C] [MonoidalCategory C]", "{C}", "[MonoidalPreadditive C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_7\nW X Y Z : C\nf : sorry\ng : sorry\nh : sorry\n\u22a2 sorry = sorry + sorry"}, {"line": "simp [tensorHom_def]", "tactic_state": "C : Type u_7\nW X Y Z : C\nf : sorry\ng : sorry\nh : sorry\n\u22a2 sorry () = sorry () + sorry ()"}]}
{"declaration": "theorem add_tensor {W X Y Z : C} (f g : W \u27f6 X) (h : Y \u27f6 Z) : (f + g) \u2297 h = f \u2297 h + g \u2297 h := by\n  simp [tensorHom_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Preadditive.lean", "context": {"open": ["CategoryTheory.Limits", "CategoryTheory.MonoidalCategory"], "variables": ["(C : Type*) [Category C] [Preadditive C] [MonoidalCategory C]", "{C}", "[MonoidalPreadditive C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_7\nW X Y Z : C\nf : sorry\ng : sorry\nh : sorry\n\u22a2 sorry = sorry + sorry"}, {"line": "simp [tensorHom_def]", "tactic_state": "C : Type u_7\nW X Y Z : C\nf : sorry\ng : sorry\nh : sorry\n\u22a2 sorry () = sorry () + sorry ()"}]}
{"declaration": "lemma coevaluation_evaluation'' :\n    Y \u25c1 \u03b7_ X Y \u2297\u226b \u03b5_ X Y \u25b7 Y = \u2297\ud835\udfd9.hom := by\n  convert coevaluation_evaluation X Y <;> simp [monoidalComp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean", "context": {"open": ["CategoryTheory MonoidalCategory"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [MonoidalCategory C]", "(X Y : C)", "[ExactPairing X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : MonoidalCategory C\nX Y : C\ninst\u271d : ExactPairing X Y\n\u22a2 monoidalComp (MonoidalCategoryStruct.whiskerLeft Y (\u03b7_ X Y)) (MonoidalCategoryStruct.whiskerRight (\u03b5_ X Y) Y) =\n    MonoidalCoherence.iso.hom"}, {"line": "convert coevaluation_evaluation X Y <;> simp [monoidalComp]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma evaluation_coevaluation'' :\n    \u03b7_ X Y \u25b7 X \u2297\u226b X \u25c1 \u03b5_ X Y = \u2297\ud835\udfd9.hom := by\n  convert evaluation_coevaluation X Y <;> simp [monoidalComp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean", "context": {"open": ["CategoryTheory MonoidalCategory"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [MonoidalCategory C]", "(X Y : C)", "[ExactPairing X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : MonoidalCategory C\nX Y : C\ninst\u271d : ExactPairing X Y\n\u22a2 monoidalComp (MonoidalCategoryStruct.whiskerRight (\u03b7_ X Y) X) (MonoidalCategoryStruct.whiskerLeft X (\u03b5_ X Y)) =\n    MonoidalCoherence.iso.hom"}, {"line": "convert evaluation_coevaluation X Y <;> simp [monoidalComp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rightAdjointMate_id {X : C} [HasRightDual X] : (\ud835\udfd9 X)\u1601 = \ud835\udfd9 (X\u1601) := by\n  simp [rightAdjointMate]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean", "context": {"open": ["CategoryTheory MonoidalCategory", "ExactPairing HasRightDual HasLeftDual MonoidalCategory"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [MonoidalCategory C]", "(X Y : C)", "[ExactPairing X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : MonoidalCategory C\nX : C\ninst\u271d : HasRightDual X\n\u22a2 CategoryStruct.id X\u1601 = CategoryStruct.id X\u1601"}, {"line": "simp [rightAdjointMate]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leftAdjointMate_id {X : C} [HasLeftDual X] : (\u1601(\ud835\udfd9 X)) = \ud835\udfd9 (\u1601X) := by\n  simp [leftAdjointMate]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean", "context": {"open": ["CategoryTheory MonoidalCategory", "ExactPairing HasRightDual HasLeftDual MonoidalCategory"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [MonoidalCategory C]", "(X Y : C)", "[ExactPairing X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : MonoidalCategory C\nX : C\ninst\u271d : HasLeftDual X\n\u22a2 (\u1601CategoryStruct.id X) = CategoryStruct.id \u1601X"}, {"line": "simp [leftAdjointMate]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tensorLeftHomEquiv_naturality {X Y Y' Z Z' : C} [ExactPairing Y Y'] (f : Y' \u2297 X \u27f6 Z)\n    (g : Z \u27f6 Z') :\n    (tensorLeftHomEquiv X Y Y' Z') (f \u226b g) = (tensorLeftHomEquiv X Y Y' Z) f \u226b Y \u25c1 g := by\n  simp [tensorLeftHomEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean", "context": {"open": ["CategoryTheory MonoidalCategory", "ExactPairing HasRightDual HasLeftDual MonoidalCategory"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [MonoidalCategory C]", "(X Y : C)", "[ExactPairing X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : MonoidalCategory C\nX Y Y' Z Z' : C\ninst\u271d : ExactPairing Y Y'\nf : tensorObj Y' X \u27f6 Z\ng : Z \u27f6 Z'\n\u22a2 (tensorLeftHomEquiv X Y Y' Z') (CategoryStruct.comp f g) =\n    CategoryStruct.comp ((tensorLeftHomEquiv X Y Y' Z) f) (MonoidalCategoryStruct.whiskerLeft Y g)"}, {"line": "simp [tensorLeftHomEquiv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tensorLeftHomEquiv_symm_naturality {X X' Y Y' Z : C} [ExactPairing Y Y'] (f : X \u27f6 X')\n    (g : X' \u27f6 Y \u2297 Z) :\n    (tensorLeftHomEquiv X Y Y' Z).symm (f \u226b g) =\n      _ \u25c1 f \u226b (tensorLeftHomEquiv X' Y Y' Z).symm g := by\n  simp [tensorLeftHomEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean", "context": {"open": ["CategoryTheory MonoidalCategory", "ExactPairing HasRightDual HasLeftDual MonoidalCategory"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [MonoidalCategory C]", "(X Y : C)", "[ExactPairing X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : MonoidalCategory C\nX X' Y Y' Z : C\ninst\u271d : ExactPairing Y Y'\nf : X \u27f6 X'\ng : X' \u27f6 tensorObj Y Z\n\u22a2 (tensorLeftHomEquiv X Y Y' Z).symm (CategoryStruct.comp f g) =\n    CategoryStruct.comp (MonoidalCategoryStruct.whiskerLeft Y' f) ((tensorLeftHomEquiv X' Y Y' Z).symm g)"}, {"line": "simp [tensorLeftHomEquiv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tensorRightHomEquiv_naturality {X Y Y' Z Z' : C} [ExactPairing Y Y'] (f : X \u2297 Y \u27f6 Z)\n    (g : Z \u27f6 Z') :\n    (tensorRightHomEquiv X Y Y' Z') (f \u226b g) = (tensorRightHomEquiv X Y Y' Z) f \u226b g \u25b7 Y' := by\n  simp [tensorRightHomEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean", "context": {"open": ["CategoryTheory MonoidalCategory", "ExactPairing HasRightDual HasLeftDual MonoidalCategory"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [MonoidalCategory C]", "(X Y : C)", "[ExactPairing X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : MonoidalCategory C\nX Y Y' Z Z' : C\ninst\u271d : ExactPairing Y Y'\nf : tensorObj X Y \u27f6 Z\ng : Z \u27f6 Z'\n\u22a2 (tensorRightHomEquiv X Y Y' Z') (CategoryStruct.comp f g) =\n    CategoryStruct.comp ((tensorRightHomEquiv X Y Y' Z) f) (MonoidalCategoryStruct.whiskerRight g Y')"}, {"line": "simp [tensorRightHomEquiv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tensorRightHomEquiv_symm_naturality {X X' Y Y' Z : C} [ExactPairing Y Y'] (f : X \u27f6 X')\n    (g : X' \u27f6 Z \u2297 Y') :\n    (tensorRightHomEquiv X Y Y' Z).symm (f \u226b g) =\n      f \u25b7 Y \u226b (tensorRightHomEquiv X' Y Y' Z).symm g := by\n  simp [tensorRightHomEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean", "context": {"open": ["CategoryTheory MonoidalCategory", "ExactPairing HasRightDual HasLeftDual MonoidalCategory"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [MonoidalCategory C]", "(X Y : C)", "[ExactPairing X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : MonoidalCategory C\nX X' Y Y' Z : C\ninst\u271d : ExactPairing Y Y'\nf : X \u27f6 X'\ng : X' \u27f6 tensorObj Z Y'\n\u22a2 (tensorRightHomEquiv X Y Y' Z).symm (CategoryStruct.comp f g) =\n    CategoryStruct.comp (MonoidalCategoryStruct.whiskerRight f Y) ((tensorRightHomEquiv X' Y Y' Z).symm g)"}, {"line": "simp [tensorRightHomEquiv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tensorLeftHomEquiv_tensor {X X' Y Y' Z Z' : C} [ExactPairing Y Y'] (f : X \u27f6 Y \u2297 Z)\n    (g : X' \u27f6 Z') :\n    (tensorLeftHomEquiv (X \u2297 X') Y Y' (Z \u2297 Z')).symm ((f \u2297 g) \u226b (\u03b1_ _ _ _).hom) =\n      (\u03b1_ _ _ _).inv \u226b ((tensorLeftHomEquiv X Y Y' Z).symm f \u2297 g) := by\n  simp [tensorLeftHomEquiv, tensorHom_def']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean", "context": {"open": ["CategoryTheory MonoidalCategory", "ExactPairing HasRightDual HasLeftDual MonoidalCategory"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [MonoidalCategory C]", "(X Y : C)", "[ExactPairing X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : MonoidalCategory C\nX X' Y Y' Z Z' : C\ninst\u271d : ExactPairing Y Y'\nf : X \u27f6 tensorObj Y Z\ng : X' \u27f6 Z'\n\u22a2 (tensorLeftHomEquiv (tensorObj X X') Y Y' (tensorObj Z Z')).symm\n      (CategoryStruct.comp (tensorHom f g) (associator Y Z Z').hom) =\n    CategoryStruct.comp (associator Y' X X').inv (tensorHom ((tensorLeftHomEquiv X Y Y' Z).symm f) g)"}, {"line": "simp [tensorLeftHomEquiv, tensorHom_def']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tensorRightHomEquiv_tensor {X X' Y Y' Z Z' : C} [ExactPairing Y Y'] (f : X \u27f6 Z \u2297 Y')\n    (g : X' \u27f6 Z') :\n    (tensorRightHomEquiv (X' \u2297 X) Y Y' (Z' \u2297 Z)).symm ((g \u2297 f) \u226b (\u03b1_ _ _ _).inv) =\n      (\u03b1_ _ _ _).hom \u226b (g \u2297 (tensorRightHomEquiv X Y Y' Z).symm f) := by\n  simp [tensorRightHomEquiv, tensorHom_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean", "context": {"open": ["CategoryTheory MonoidalCategory", "ExactPairing HasRightDual HasLeftDual MonoidalCategory"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [MonoidalCategory C]", "(X Y : C)", "[ExactPairing X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : MonoidalCategory C\nX X' Y Y' Z Z' : C\ninst\u271d : ExactPairing Y Y'\nf : X \u27f6 tensorObj Z Y'\ng : X' \u27f6 Z'\n\u22a2 (tensorRightHomEquiv (tensorObj X' X) Y Y' (tensorObj Z' Z)).symm\n      (CategoryStruct.comp (tensorHom g f) (associator Z' Z Y').inv) =\n    CategoryStruct.comp (associator X' X Y).hom (tensorHom g ((tensorRightHomEquiv X Y Y' Z).symm f))"}, {"line": "simp [tensorRightHomEquiv, tensorHom_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tensorRightHomEquiv_symm_coevaluation_comp_whiskerLeft {X Y : C} [HasLeftDual X]\n    [HasLeftDual Y] (f : X \u27f6 Y) :\n    (tensorRightHomEquiv _ (\u1601Y) _ _).symm (\u03b7_ (\u1601X : C) X \u226b (\u1601X : C) \u25c1 f) = (\u03bb_ _).hom \u226b \u1601f := by\n  dsimp [tensorRightHomEquiv, leftAdjointMate]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean", "context": {"open": ["CategoryTheory MonoidalCategory", "ExactPairing HasRightDual HasLeftDual MonoidalCategory"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] [MonoidalCategory C]", "(X Y : C)", "[ExactPairing X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b2 : MonoidalCategory C\nX Y : C\ninst\u271d\u00b9 : HasLeftDual X\ninst\u271d : HasLeftDual Y\nf : X \u27f6 Y\n\u22a2 (tensorRightHomEquiv (tensorUnit C) (\u1601Y) Y \u1601X).symm\n      (CategoryStruct.comp (\u03b7_ (\u1601X) X) (MonoidalCategoryStruct.whiskerLeft (\u1601X) f)) =\n    CategoryStruct.comp (leftUnitor \u1601Y).hom (\u1601f)"}, {"line": "dsimp [tensorRightHomEquiv, leftAdjointMate]", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b2 : MonoidalCategory C\nX Y : C\ninst\u271d\u00b9 : HasLeftDual X\ninst\u271d : HasLeftDual Y\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp\n      (MonoidalCategoryStruct.whiskerRight (CategoryStruct.comp (\u03b7_ (\u1601X) X) (MonoidalCategoryStruct.whiskerLeft (\u1601X) f))\n        \u1601Y)\n      (CategoryStruct.comp (associator (\u1601X) Y \u1601Y).hom\n        (CategoryStruct.comp (MonoidalCategoryStruct.whiskerLeft (\u1601X) (\u03b5_ (\u1601Y) Y)) (rightUnitor \u1601X).hom)) =\n    CategoryStruct.comp (leftUnitor \u1601Y).hom\n      (CategoryStruct.comp (leftUnitor \u1601Y).inv\n        (CategoryStruct.comp (MonoidalCategoryStruct.whiskerRight (\u03b7_ (\u1601X) X) \u1601Y)\n          (CategoryStruct.comp (MonoidalCategoryStruct.whiskerRight (MonoidalCategoryStruct.whiskerLeft (\u1601X) f) \u1601Y)\n            (CategoryStruct.comp (associator (\u1601X) Y \u1601Y).hom\n              (CategoryStruct.comp (MonoidalCategoryStruct.whiskerLeft (\u1601X) (\u03b5_ (\u1601Y) Y)) (rightUnitor \u1601X).hom)))))"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ext (W W' : MorphismProperty C) (h : \u2200 \u2983X Y : C\u2984 (f : X \u27f6 Y), W f \u2194 W' f) :\n    W = W' := by\n  funext X Y f\n  rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/MorphismProperty/Basic.lean", "context": {"open": ["CategoryTheory Opposite"], "variables": ["(C : Type u) [Category.{v} C] {D : Type*} [Category D]", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nW W' : MorphismProperty C\nh : \u2200 \u2983X Y : C\u2984 (f : X \u27f6 Y), W f \u2194 W' f\n\u22a2 W = W'"}, {"line": "funext X Y f", "tactic_state": "case h.h.h\nC : Type u\ninst\u271d : Category.{v, u} C\nW W' : MorphismProperty C\nh : \u2200 \u2983X Y : C\u2984 (f : X \u27f6 Y), W f \u2194 W' f\nX Y : C\nf : X \u27f6 Y\n\u22a2 W f = W' f"}, {"line": "rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma of_eq_top {P : MorphismProperty C} (h : P = \u22a4) {X Y : C} (f : X \u27f6 Y) : P f := by\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/MorphismProperty/Basic.lean", "context": {"open": ["CategoryTheory Opposite"], "variables": ["(C : Type u) [Category.{v} C] {D : Type*} [Category D]", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nP : MorphismProperty C\nh : P = \u22a4\nX Y : C\nf : X \u27f6 Y\n\u22a2 P f"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sSup_iff (S : Set (MorphismProperty C)) {X Y : C} (f : X \u27f6 Y) :\n    sSup S f \u2194 \u2203 (W : S), W.1 f := by\n  dsimp [sSup, iSup]\n  constructor\n  \u00b7 rintro \u27e8_, \u27e8\u27e8_, \u27e8\u27e8_, \u27e8_, h\u27e9, rfl\u27e9, rfl\u27e9\u27e9, rfl\u27e9, hf\u27e9\n    exact \u27e8\u27e8_, h\u27e9, hf\u27e9\n  \u00b7 rintro \u27e8\u27e8W, hW\u27e9, hf\u27e9\n    exact \u27e8_, \u27e8\u27e8_, \u27e8_, \u27e8\u27e8W, hW\u27e9, rfl\u27e9\u27e9, rfl\u27e9, rfl\u27e9, hf\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/MorphismProperty/Basic.lean", "context": {"open": ["CategoryTheory Opposite"], "variables": ["(C : Type u) [Category.{v} C] {D : Type*} [Category D]", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nS : Set (MorphismProperty C)\nX Y : C\nf : X \u27f6 Y\n\u22a2 sSup S f \u2194 \u2203 W, \u2191W f"}, {"line": "dsimp [sSup, iSup]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nS : Set (MorphismProperty C)\nX Y : C\nf : X \u27f6 Y\n\u22a2 (\u2203 a \u2208 Set.range fun f_1 => \u2191f_1 f, a) \u2194 \u2203 W, \u2191W f"}, {"line": "constructor", "tactic_state": "case mp\nC : Type u\ninst\u271d : Category.{v, u} C\nS : Set (MorphismProperty C)\nX Y : C\nf : X \u27f6 Y\n\u22a2 (\u2203 a \u2208 Set.range fun f_1 => \u2191f_1 f, a) \u2192 \u2203 W, \u2191W f\n---\ncase mpr\nC : Type u\ninst\u271d : Category.{v, u} C\nS : Set (MorphismProperty C)\nX Y : C\nf : X \u27f6 Y\n\u22a2 (\u2203 W, \u2191W f) \u2192 \u2203 a \u2208 Set.range fun f_1 => \u2191f_1 f, a"}, {"line": "\u00b7 rintro \u27e8_, \u27e8\u27e8_, \u27e8\u27e8_, \u27e8_, h\u27e9, rfl\u27e9, rfl\u27e9\u27e9, rfl\u27e9, hf\u27e9\n    exact \u27e8\u27e8_, h\u27e9, hf\u27e9", "tactic_state": "case mpr\nC : Type u\ninst\u271d : Category.{v, u} C\nS : Set (MorphismProperty C)\nX Y : C\nf : X \u27f6 Y\n\u22a2 (\u2203 W, \u2191W f) \u2192 \u2203 a \u2208 Set.range fun f_1 => \u2191f_1 f, a"}, {"line": "\u00b7 rintro \u27e8\u27e8W, hW\u27e9, hf\u27e9\n    exact \u27e8_, \u27e8\u27e8_, \u27e8_, \u27e8\u27e8W, hW\u27e9, rfl\u27e9\u27e9, rfl\u27e9, rfl\u27e9, hf\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inverseImage_iff (P : MorphismProperty D) (F : C \u2964 D) {X Y : C} (f : X \u27f6 Y) :\n    P.inverseImage F f \u2194 P (F.map f) := by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/MorphismProperty/Basic.lean", "context": {"open": ["CategoryTheory Opposite"], "variables": ["(C : Type u) [Category.{v} C] {D : Type*} [Category D]", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u_1\ninst\u271d : Category.{u_2, u_1} D\nP : MorphismProperty D\nF : CategoryTheory.Functor C D\nX Y : C\nf : X \u27f6 Y\n\u22a2 P.inverseImage F f \u2194 P (F.map f)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isoClosure_eq_iff (P : MorphismProperty C) :\n    P.isoClosure = P \u2194 P.RespectsIso := by\n  refine \u27e8(\u00b7 \u25b8 P.isoClosure_respectsIso), fun hP \u21a6 le_antisymm ?_ (P.le_isoClosure)\u27e9\n  intro X Y f \u27e8X', Y', f', hf', \u27e8e\u27e9\u27e9\n  exact (P.arrow_mk_iso_iff e).1 hf'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/MorphismProperty/Basic.lean", "context": {"open": ["CategoryTheory Opposite"], "variables": ["(C : Type u) [Category.{v} C] {D : Type*} [Category D]", "{C}", "(P : MorphismProperty C)", "(C)", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nP : MorphismProperty C\n\u22a2 P.isoClosure = P \u2194 P.RespectsIso"}, {"line": "refine \u27e8(\u00b7 \u25b8 P.isoClosure_respectsIso), fun hP \u21a6 le_antisymm ?_ (P.le_isoClosure)\u27e9", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nP : MorphismProperty C\nhP : P.RespectsIso\n\u22a2 P.isoClosure \u2264 P"}, {"line": "intro X Y f \u27e8X', Y', f', hf', \u27e8e\u27e9\u27e9", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nP : MorphismProperty C\nhP : P.RespectsIso\nX Y : C\nf : X \u27f6 Y\nX' Y' : C\nf' : X' \u27f6 Y'\nhf' : P f'\ne : Arrow.mk f' \u2245 Arrow.mk f\n\u22a2 P f"}, {"line": "exact (P.arrow_mk_iso_iff e).1 hf'", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isoClosure_le_iff (P Q : MorphismProperty C) [Q.RespectsIso] :\n    P.isoClosure \u2264 Q \u2194 P \u2264 Q := by\n  constructor\n  \u00b7 exact P.le_isoClosure.trans\n  \u00b7 intro h\n    exact (monotone_isoClosure h).trans (by rw [Q.isoClosure_eq_self])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/MorphismProperty/Basic.lean", "context": {"open": ["CategoryTheory Opposite"], "variables": ["(C : Type u) [Category.{v} C] {D : Type*} [Category D]", "{C}", "(P : MorphismProperty C)", "(C)", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nP Q : MorphismProperty C\ninst\u271d : Q.RespectsIso\n\u22a2 P.isoClosure \u2264 Q \u2194 P \u2264 Q"}, {"line": "constructor", "tactic_state": "case mp\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nP Q : MorphismProperty C\ninst\u271d : Q.RespectsIso\n\u22a2 P.isoClosure \u2264 Q \u2192 P \u2264 Q\n---\ncase mpr\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nP Q : MorphismProperty C\ninst\u271d : Q.RespectsIso\n\u22a2 P \u2264 Q \u2192 P.isoClosure \u2264 Q"}, {"line": "\u00b7 exact P.le_isoClosure.trans", "tactic_state": "case mpr\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nP Q : MorphismProperty C\ninst\u271d : Q.RespectsIso\n\u22a2 P \u2264 Q \u2192 P.isoClosure \u2264 Q"}, {"line": "\u00b7 intro h\n    exact (monotone_isoClosure h).trans (by rw [Q.isoClosure_eq_self])", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eqToHom_left {X Y : P.Comma L R Q W} (h : X = Y) :\n    (eqToHom h).left = eqToHom (by rw [h]) := by\n  subst h\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/MorphismProperty/Comma.lean", "context": {"open": ["Limits"], "variables": ["{A : Type*} [Category A] {B : Type*} [Category B] {T : Type*} [Category T]", "(P : MorphismProperty T) (Q : MorphismProperty A) (W : MorphismProperty B)", "{L R P Q W}", "[Q.IsMultiplicative] [W.IsMultiplicative]", "(L R P Q W) in", "(L R P Q W)", "{L R P Q W}", "(L R P Q W)", "{L R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MorphismProperty : ?m.7456\nP : sorry\nQ : sorry\nW : sorry\nL : ?m.8688 P Q W\nR : ?m.8689 P Q W\nx\u271d : Sort u_1\neqToHom : x\u271d\nX : sorry\nY : sorry\nh : X = Y\n\u22a2 sorry = sorry"}, {"line": "subst h", "tactic_state": "MorphismProperty : ?m.7456\nP : sorry\nQ : sorry\nW : sorry\nL : ?m.8688 P Q W\nR : ?m.8689 P Q W\nx\u271d : Sort u_1\neqToHom : x\u271d\nX : sorry\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eqToHom_right {X Y : P.Comma L R Q W} (h : X = Y) :\n    (eqToHom h).right = eqToHom (by rw [h]) := by\n  subst h\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/MorphismProperty/Comma.lean", "context": {"open": ["Limits"], "variables": ["{A : Type*} [Category A] {B : Type*} [Category B] {T : Type*} [Category T]", "(P : MorphismProperty T) (Q : MorphismProperty A) (W : MorphismProperty B)", "{L R P Q W}", "[Q.IsMultiplicative] [W.IsMultiplicative]", "(L R P Q W) in", "(L R P Q W)", "{L R P Q W}", "(L R P Q W)", "{L R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MorphismProperty : ?m.7456\nP : sorry\nQ : sorry\nW : sorry\nL : ?m.8688 P Q W\nR : ?m.8689 P Q W\nx\u271d : Sort u_1\neqToHom : x\u271d\nX : sorry\nY : sorry\nh : X = Y\n\u22a2 sorry = sorry"}, {"line": "subst h", "tactic_state": "MorphismProperty : ?m.7456\nP : sorry\nQ : sorry\nW : sorry\nL : ?m.8688 P Q W\nR : ?m.8689 P Q W\nx\u271d : Sort u_1\neqToHom : x\u271d\nX : sorry\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isSmall_iff_eq_ofHoms :\n    IsSmall.{w} W \u2194 \u2203 (\u03b9 : Type w) (A B : \u03b9 \u2192 C) (f : \u2200 i, A i \u27f6 B i),\n      W = ofHoms f := by\n  constructor\n  \u00b7 intro\n    refine \u27e8Shrink.{w} W.toSet, _, _, fun i \u21a6 ((equivShrink _).symm i).1.hom, ?_\u27e9\n    ext A B f\n    rw [ofHoms_iff]\n    constructor\n    \u00b7 intro hf\n      exact \u27e8equivShrink _ \u27e8f, hf\u27e9, by simp\u27e9\n    \u00b7 rintro \u27e8i, hi\u27e9\n      simp only [\u2190 W.arrow_mk_mem_toSet_iff]\n      simp only [hi]\n      simp only [Arrow.mk_eq]\n      simp only [Subtype.coe_prop]\n  \u00b7 rintro \u27e8_, _, _, _, rfl\u27e9\n    infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/MorphismProperty/IsSmall.lean", "context": {"open": [], "variables": ["{C : Type u} [Category.{v} C]", "(W : MorphismProperty C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MorphismProperty : ?m.425\nW\u271d W : sorry\nx\u271d\u00b9 : Sort u_1\nIsSmall : x\u271d\u00b9\nC : Type u_2\nx\u271d : Sort u_3\nofHoms : x\u271d\n\u22a2 sorry \u2194 \u2203 \u03b9 A B f, W = sorry"}, {"line": "constructor", "tactic_state": "case mp\nMorphismProperty : ?m.425\nW\u271d W : sorry\nx\u271d\u00b9 : Sort u_1\nIsSmall : x\u271d\u00b9\nC : Type u_2\nx\u271d : Sort u_3\nofHoms : x\u271d\n\u22a2 sorry \u2192 \u2203 \u03b9 A B f, W = sorry\n---\ncase mpr\nMorphismProperty : ?m.425\nW\u271d W : sorry\nx\u271d\u00b9 : Sort u_1\nIsSmall : x\u271d\u00b9\nC : Type u_2\nx\u271d : Sort u_3\nofHoms : x\u271d\n\u22a2 (\u2203 \u03b9 A B f, W = sorry) \u2192 sorry"}, {"line": "\u00b7 intro\n    refine \u27e8Shrink.{w} W.toSet, _, _, fun i \u21a6 ((equivShrink _).symm i).1.hom, ?_\u27e9\n    ext A B f\n    rw [ofHoms_iff]\n    constructor\n    \u00b7 intro hf\n      exact \u27e8equivShrink _ \u27e8f, hf\u27e9, by simp\u27e9\n    \u00b7 rintro \u27e8i, hi\u27e9\n      simp only [\u2190 W.arrow_mk_mem_toSet_iff]\n      simp only [hi]\n      simp only [Arrow.mk_eq]\n      simp only [Subtype.coe_prop]", "tactic_state": "case mpr\nMorphismProperty : ?m.425\nW\u271d W : sorry\nx\u271d\u00b9 : Sort u_1\nIsSmall : x\u271d\u00b9\nC : Type u_2\nx\u271d : Sort u_3\nofHoms : x\u271d\n\u22a2 (\u2203 \u03b9 A B f, W = sorry) \u2192 sorry"}, {"line": "\u00b7 rintro \u27e8_, _, _, _, rfl\u27e9\n    infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isStableUnderCobaseChange_iff_pushouts_le :\n    P.IsStableUnderCobaseChange \u2194 P.pushouts \u2264 P := by\n  constructor\n  \u00b7 intro h _ _ _ \u27e8_, _, _, _, _, h\u2081, h\u2082\u27e9\n    exact of_isPushout h\u2082 h\u2081\n  \u00b7 intro h\n    constructor\n    intro _ _ _ _ _ _ _ _ h\u2081 h\u2082\n    exact h _ \u27e8_, _, _, _, _, h\u2082, h\u2081\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/MorphismProperty/Limits.lean", "context": {"open": ["Category Limits"], "variables": ["{C : Type u} [Category.{v} C]", "(P : MorphismProperty C)", "{P} in", "{P} in", "(C)", "{C P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MorphismProperty : ?m.1676\nP : sorry\nC : ?m.2089\n\u22a2 sorry \u2194 sorry"}, {"line": "constructor", "tactic_state": "case mp\nMorphismProperty : ?m.1676\nP : sorry\nC : ?m.2089\n\u22a2 sorry \u2192 sorry\n---\ncase mpr\nMorphismProperty : ?m.1676\nP : sorry\nC : ?m.2089\n\u22a2 sorry \u2192 sorry"}, {"line": "\u00b7 intro h _ _ _ \u27e8_, _, _, _, _, h\u2081, h\u2082\u27e9\n    exact of_isPushout h\u2082 h\u2081", "tactic_state": "case mpr\nMorphismProperty : ?m.1676\nP : sorry\nC : ?m.2089\n\u22a2 sorry \u2192 sorry"}, {"line": "\u00b7 intro h\n    constructor\n    intro _ _ _ _ _ _ _ _ h\u2081 h\u2082\n    exact h _ \u27e8_, _, _, _, _, h\u2082, h\u2081\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma shift_zero [P.IsClosedUnderIsomorphisms] : P.shift (0 : A) = P := by\n  ext X\n  exact P.prop_iff_of_iso ((shiftFunctorZero C A).app X)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/ObjectProperty/Shift.lean", "context": {"open": ["CategoryTheory Category"], "variables": ["{C : Type*} [Category C] (P : ObjectProperty C)", "(A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\nP : ObjectProperty C\ninst\u271d : P.IsClosedUnderIsomorphisms\n\u22a2 sorry = P"}, {"line": "ext X", "tactic_state": "case h.a\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\nP : ObjectProperty C\ninst\u271d : P.IsClosedUnderIsomorphisms\nX : C\n\u22a2 sorry X \u2194 P X"}, {"line": "exact P.prop_iff_of_iso ((shiftFunctorZero C A).app X)", "tactic_state": "No Goals!"}]}
{"declaration": "example (g : J \u2192 I) : (j : J) \u2192 Category (C (g j)) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Pi/Basic.lean", "context": {"open": [], "variables": ["{I : Type w\u2080} {J : Type w\u2081} (C : I \u2192 Type u\u2081) [\u2200 i, Category.{v\u2081} (C i)]", "{J : Type w\u2081}", "(I)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Type w\u2081\nI : Sort u_1\nx\u271d : Sort u_2\nCategory : x\u271d\ng : J \u2192 I\n\u22a2 J \u2192 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_comp_neg : (-f) \u226b (-g) = f \u226b g := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Preadditive/Basic.lean", "context": {"open": ["CategoryTheory.Limits", "CategoryTheory", "AddMonoidHom"], "variables": ["(C : Type u) [Category.{v} C]", "{C : Type u} [Category.{v} C] [Preadditive C]", "{D : Type u'} (F : D \u2192 C)", "{P Q R : C} (f f' : P \u27f6 Q) (g g' : Q \u27f6 R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nP Q R : C\nf : P \u27f6 Q\ng : Q \u27f6 R\n\u22a2 CategoryStruct.comp (-f) (-g) = CategoryStruct.comp f g"}, {"line": "simp", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nP Q R : C\nf : P \u27f6 Q\ng : Q \u27f6 R\n\u22a2 - -CategoryStruct.comp f g = CategoryStruct.comp f g"}]}
{"declaration": "theorem sum_comp' {P Q R S : C} {J : Type*} (s : Finset J) (f : J \u2192 (P \u27f6 Q)) (g : J \u2192 (Q \u27f6 R))\n    (h : R \u27f6 S) : (\u2211 j \u2208 s, f j \u226b g j) \u226b h = \u2211 j \u2208 s, f j \u226b g j \u226b h := by\n  simp only [\u2190 Category.assoc]\n  apply sum_comp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Preadditive/Basic.lean", "context": {"open": ["CategoryTheory.Limits", "CategoryTheory", "AddMonoidHom"], "variables": ["(C : Type u) [Category.{v} C]", "{C : Type u} [Category.{v} C] [Preadditive C]", "{D : Type u'} (F : D \u2192 C)", "{P Q R : C} (f f' : P \u27f6 Q) (g g' : Q \u27f6 R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nP Q R S : C\nJ : Type u_1\ns : Finset J\nf : J \u2192 (P \u27f6 Q)\ng : J \u2192 (Q \u27f6 R)\nh : R \u27f6 S\n\u22a2 CategoryStruct.comp (\u2211 j \u2208 s, CategoryStruct.comp (f j) (g j)) h =\n    \u2211 j \u2208 s, CategoryStruct.comp (f j) (CategoryStruct.comp (g j) h)"}, {"line": "simp only [\u2190 Category.assoc]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nP Q R S : C\nJ : Type u_1\ns : Finset J\nf : J \u2192 (P \u27f6 Q)\ng : J \u2192 (Q \u27f6 R)\nh : R \u27f6 S\n\u22a2 CategoryStruct.comp (\u2211 j \u2208 s, CategoryStruct.comp (f j) (g j)) h =\n    \u2211 x \u2208 s, CategoryStruct.comp (CategoryStruct.comp (f x) (g x)) h"}, {"line": "apply sum_comp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem id_apply_self (M : Mat R) (i : M) : (\ud835\udfd9 M : Matrix M M R) i i = 1 := by simp [id_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Preadditive/Mat.lean", "context": {"open": ["CategoryTheory CategoryTheory.Preadditive", "scoped Classical in", "scoped Classical in", "scoped Classical in", "CategoryTheory.Limits", "scoped Classical in", "CategoryTheory.Limits", "scoped Classical in", "Matrix", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(C : Type u\u2081) [Category.{v\u2081} C] [Preadditive C]", "{C}", "{C} {D : Type*} [Category.{v\u2081} D] [Preadditive D]", "{C}", "{D : Type u\u2081} [Category.{v\u2081} D] [Preadditive D]", "[HasFiniteBiproducts D]", "{R : Type u} [Semiring R]", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nM : Mat R\ni : M.carrier\n\u22a2 CategoryStruct.id M i i = 1"}, {"line": "simp [id_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem id_apply_of_ne (M : Mat R) (i j : M) (h : i \u2260 j) : (\ud835\udfd9 M : Matrix M M R) i j = 0 := by\n  simp [id_apply, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Preadditive/Mat.lean", "context": {"open": ["CategoryTheory CategoryTheory.Preadditive", "scoped Classical in", "scoped Classical in", "scoped Classical in", "CategoryTheory.Limits", "scoped Classical in", "CategoryTheory.Limits", "scoped Classical in", "Matrix", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(C : Type u\u2081) [Category.{v\u2081} C] [Preadditive C]", "{C}", "{C} {D : Type*} [Category.{v\u2081} D] [Preadditive D]", "{C}", "{D : Type u\u2081} [Category.{v\u2081} D] [Preadditive D]", "[HasFiniteBiproducts D]", "{R : Type u} [Semiring R]", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nM : Mat R\ni j : M.carrier\nh : i \u2260 j\n\u22a2 CategoryStruct.id M i j = 0"}, {"line": "simp [id_apply, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biprod.lift_desc {T U : C} {f : T \u27f6 X} {g : T \u27f6 Y} {h : X \u27f6 U} {i : Y \u27f6 U} :\n    biprod.lift f g \u226b biprod.desc h i = f \u226b h + g \u226b i := by simp [biprod.lift_eq, biprod.desc_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Preadditive/Biproducts.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Preadditive", "CategoryTheory.Limits", "CategoryTheory.Functor", "CategoryTheory.Preadditive"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C]", "{J : Type} [Fintype J]", "{J : Type} [Finite J]", "{J : Type} [Fintype J] {f : J \u2192 C} [HasBiproduct f]", "{J K : Type} [Finite J] {f : J \u2192 C} [HasFiniteBiproducts C]", "[Finite K]", "{X Y : C} [HasBinaryBiproduct X Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasFiniteBiproducts C\nX Y : C\ninst\u271d : HasBinaryBiproduct X Y\nT U : C\nf : T \u27f6 X\ng : T \u27f6 Y\nh : X \u27f6 U\ni : Y \u27f6 U\n\u22a2 CategoryStruct.comp (biprod.lift f g) (biprod.desc h i) = CategoryStruct.comp f h + CategoryStruct.comp g i"}, {"line": "simp [biprod.lift_eq, biprod.desc_eq]", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasFiniteBiproducts C\nX Y : C\ninst\u271d : HasBinaryBiproduct X Y\nT U : C\nf : T \u27f6 X\ng : T \u27f6 Y\nh : X \u27f6 U\ni : Y \u27f6 U\n\u22a2 CategoryStruct.comp f h + 0 + (0 + CategoryStruct.comp g i) = CategoryStruct.comp f h + CategoryStruct.comp g i"}]}
{"declaration": "lemma biprod.ext_to_iff {f g : Z \u27f6 X \u229e Y} :\n    f = g \u2194 f \u226b biprod.fst = g \u226b biprod.fst \u2227 f \u226b biprod.snd = g \u226b biprod.snd := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Preadditive/Biproducts.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Preadditive", "CategoryTheory.Limits", "CategoryTheory.Functor", "CategoryTheory.Preadditive"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C]", "{J : Type} [Fintype J]", "{J : Type} [Finite J]", "{J : Type} [Fintype J] {f : J \u2192 C} [HasBiproduct f]", "{J K : Type} [Finite J] {f : J \u2192 C} [HasFiniteBiproducts C]", "[Finite K]", "{X Y : C} [HasBinaryBiproduct X Y]", "{Z : C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasFiniteBiproducts C\nX Y : C\ninst\u271d : HasBinaryBiproduct X Y\nZ : C\nf g : Z \u27f6 X \u229e Y\n\u22a2 f = g \u2194\n    CategoryStruct.comp f biprod.fst = CategoryStruct.comp g biprod.fst \u2227\n      CategoryStruct.comp f biprod.snd = CategoryStruct.comp g biprod.snd"}, {"line": "aesop", "tactic_state": "case mpr\nC : Type u\ninst : Category.{v, u} C\ninst_1 : Preadditive C\ninst_2 : HasFiniteBiproducts C\nX Y : C\ninst_3 : HasBinaryBiproduct X Y\nZ : C\nf g : Z \u27f6 X \u229e Y\nleft : CategoryStruct.comp f biprod.fst = CategoryStruct.comp g biprod.fst\nright : CategoryStruct.comp f biprod.snd = CategoryStruct.comp g biprod.snd\n\u22a2 f = g"}]}
{"declaration": "lemma biprod.ext_from_iff {f g : X \u229e Y \u27f6 Z} :\n    f = g \u2194 biprod.inl \u226b f = biprod.inl \u226b g \u2227 biprod.inr \u226b f = biprod.inr \u226b g := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Preadditive/Biproducts.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Preadditive", "CategoryTheory.Limits", "CategoryTheory.Functor", "CategoryTheory.Preadditive"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C]", "{J : Type} [Fintype J]", "{J : Type} [Finite J]", "{J : Type} [Fintype J] {f : J \u2192 C} [HasBiproduct f]", "{J K : Type} [Finite J] {f : J \u2192 C} [HasFiniteBiproducts C]", "[Finite K]", "{X Y : C} [HasBinaryBiproduct X Y]", "{Z : C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasFiniteBiproducts C\nX Y : C\ninst\u271d : HasBinaryBiproduct X Y\nZ : C\nf g : X \u229e Y \u27f6 Z\n\u22a2 f = g \u2194\n    CategoryStruct.comp biprod.inl f = CategoryStruct.comp biprod.inl g \u2227\n      CategoryStruct.comp biprod.inr f = CategoryStruct.comp biprod.inr g"}, {"line": "aesop", "tactic_state": "case mpr\nC : Type u\ninst : Category.{v, u} C\ninst_1 : Preadditive C\ninst_2 : HasFiniteBiproducts C\nX Y : C\ninst_3 : HasBinaryBiproduct X Y\nZ : C\nf g : X \u229e Y \u27f6 Z\nleft : CategoryStruct.comp biprod.inl f = CategoryStruct.comp biprod.inl g\nright : CategoryStruct.comp biprod.inr f = CategoryStruct.comp biprod.inr g\n\u22a2 f = g"}]}
{"declaration": "theorem biprod.add_eq_lift_id_desc [HasBinaryBiproduct X X] :\n    f + g = biprod.lift (\ud835\udfd9 X) (\ud835\udfd9 X) \u226b biprod.desc f g := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Preadditive/Biproducts.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Preadditive", "CategoryTheory.Limits", "CategoryTheory.Functor", "CategoryTheory.Preadditive"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C]", "{J : Type} [Fintype J]", "{J : Type} [Finite J]", "{J : Type} [Fintype J] {f : J \u2192 C} [HasBiproduct f]", "{J K : Type} [Finite J] {f : J \u2192 C} [HasFiniteBiproducts C]", "[Finite K]", "{X Y : C} [HasBinaryBiproduct X Y]", "{Z : C}", "{X Y : C} (f g : X \u27f6 Y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasFiniteBiproducts C\nX Y : C\nf g : X \u27f6 Y\ninst\u271d : HasBinaryBiproduct X X\n\u22a2 f + g = CategoryStruct.comp (biprod.lift (CategoryStruct.id X) (CategoryStruct.id X)) (biprod.desc f g)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biprod.add_eq_lift_desc_id [HasBinaryBiproduct Y Y] :\n    f + g = biprod.lift f g \u226b biprod.desc (\ud835\udfd9 Y) (\ud835\udfd9 Y) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Preadditive/Biproducts.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Preadditive", "CategoryTheory.Limits", "CategoryTheory.Functor", "CategoryTheory.Preadditive"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C]", "{J : Type} [Fintype J]", "{J : Type} [Finite J]", "{J : Type} [Fintype J] {f : J \u2192 C} [HasBiproduct f]", "{J K : Type} [Finite J] {f : J \u2192 C} [HasFiniteBiproducts C]", "[Finite K]", "{X Y : C} [HasBinaryBiproduct X Y]", "{Z : C}", "{X Y : C} (f g : X \u27f6 Y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasFiniteBiproducts C\nX Y : C\nf g : X \u27f6 Y\ninst\u271d : HasBinaryBiproduct Y Y\n\u22a2 f + g = CategoryStruct.comp (biprod.lift f g) (biprod.desc (CategoryStruct.id Y) (CategoryStruct.id Y))"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Biprod.inl_ofComponents :\n    biprod.inl \u226b Biprod.ofComponents f\u2081\u2081 f\u2081\u2082 f\u2082\u2081 f\u2082\u2082 = f\u2081\u2081 \u226b biprod.inl + f\u2081\u2082 \u226b biprod.inr := by\n  simp [Biprod.ofComponents]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Preadditive/Biproducts.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Preadditive", "CategoryTheory.Limits", "CategoryTheory.Functor", "CategoryTheory.Preadditive", "CategoryTheory.Limits"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C]", "{J : Type} [Fintype J]", "{J : Type} [Finite J]", "{J : Type} [Fintype J] {f : J \u2192 C} [HasBiproduct f]", "{J K : Type} [Finite J] {f : J \u2192 C} [HasFiniteBiproducts C]", "[Finite K]", "{X Y : C} [HasBinaryBiproduct X Y]", "{Z : C}", "{X Y : C} (f g : X \u27f6 Y)", "[HasBinaryBiproducts.{v} C]", "{X\u2081 X\u2082 Y\u2081 Y\u2082 : C}", "(f\u2081\u2081 : X\u2081 \u27f6 Y\u2081) (f\u2081\u2082 : X\u2081 \u27f6 Y\u2082) (f\u2082\u2081 : X\u2082 \u27f6 Y\u2081) (f\u2082\u2082 : X\u2082 \u27f6 Y\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasFiniteBiproducts C\ninst\u271d : HasBinaryBiproducts C\nX\u2081 X\u2082 Y\u2081 Y\u2082 : C\nf\u2081\u2081 : X\u2081 \u27f6 Y\u2081\nf\u2081\u2082 : X\u2081 \u27f6 Y\u2082\nf\u2082\u2081 : X\u2082 \u27f6 Y\u2081\nf\u2082\u2082 : X\u2082 \u27f6 Y\u2082\n\u22a2 CategoryStruct.comp biprod.inl (Biprod.ofComponents f\u2081\u2081 f\u2081\u2082 f\u2082\u2081 f\u2082\u2082) =\n    CategoryStruct.comp f\u2081\u2081 biprod.inl + CategoryStruct.comp f\u2081\u2082 biprod.inr"}, {"line": "simp [Biprod.ofComponents]", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasFiniteBiproducts C\ninst\u271d : HasBinaryBiproducts C\nX\u2081 X\u2082 Y\u2081 Y\u2082 : C\nf\u2081\u2081 : X\u2081 \u27f6 Y\u2081\nf\u2081\u2082 : X\u2081 \u27f6 Y\u2082\nf\u2082\u2081 : X\u2082 \u27f6 Y\u2081\nf\u2082\u2082 : X\u2082 \u27f6 Y\u2082\n\u22a2 CategoryStruct.comp f\u2081\u2081 biprod.inl + CategoryStruct.comp f\u2081\u2082 biprod.inr + 0 + 0 =\n    CategoryStruct.comp f\u2081\u2081 biprod.inl + CategoryStruct.comp f\u2081\u2082 biprod.inr"}]}
{"declaration": "theorem Biprod.inr_ofComponents :\n    biprod.inr \u226b Biprod.ofComponents f\u2081\u2081 f\u2081\u2082 f\u2082\u2081 f\u2082\u2082 = f\u2082\u2081 \u226b biprod.inl + f\u2082\u2082 \u226b biprod.inr := by\n  simp [Biprod.ofComponents]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Preadditive/Biproducts.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Preadditive", "CategoryTheory.Limits", "CategoryTheory.Functor", "CategoryTheory.Preadditive", "CategoryTheory.Limits"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C]", "{J : Type} [Fintype J]", "{J : Type} [Finite J]", "{J : Type} [Fintype J] {f : J \u2192 C} [HasBiproduct f]", "{J K : Type} [Finite J] {f : J \u2192 C} [HasFiniteBiproducts C]", "[Finite K]", "{X Y : C} [HasBinaryBiproduct X Y]", "{Z : C}", "{X Y : C} (f g : X \u27f6 Y)", "[HasBinaryBiproducts.{v} C]", "{X\u2081 X\u2082 Y\u2081 Y\u2082 : C}", "(f\u2081\u2081 : X\u2081 \u27f6 Y\u2081) (f\u2081\u2082 : X\u2081 \u27f6 Y\u2082) (f\u2082\u2081 : X\u2082 \u27f6 Y\u2081) (f\u2082\u2082 : X\u2082 \u27f6 Y\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasFiniteBiproducts C\ninst\u271d : HasBinaryBiproducts C\nX\u2081 X\u2082 Y\u2081 Y\u2082 : C\nf\u2081\u2081 : X\u2081 \u27f6 Y\u2081\nf\u2081\u2082 : X\u2081 \u27f6 Y\u2082\nf\u2082\u2081 : X\u2082 \u27f6 Y\u2081\nf\u2082\u2082 : X\u2082 \u27f6 Y\u2082\n\u22a2 CategoryStruct.comp biprod.inr (Biprod.ofComponents f\u2081\u2081 f\u2081\u2082 f\u2082\u2081 f\u2082\u2082) =\n    CategoryStruct.comp f\u2082\u2081 biprod.inl + CategoryStruct.comp f\u2082\u2082 biprod.inr"}, {"line": "simp [Biprod.ofComponents]", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasFiniteBiproducts C\ninst\u271d : HasBinaryBiproducts C\nX\u2081 X\u2082 Y\u2081 Y\u2082 : C\nf\u2081\u2081 : X\u2081 \u27f6 Y\u2081\nf\u2081\u2082 : X\u2081 \u27f6 Y\u2082\nf\u2082\u2081 : X\u2082 \u27f6 Y\u2081\nf\u2082\u2082 : X\u2082 \u27f6 Y\u2082\n\u22a2 0 + 0 + CategoryStruct.comp f\u2082\u2081 biprod.inl + CategoryStruct.comp f\u2082\u2082 biprod.inr =\n    CategoryStruct.comp f\u2082\u2081 biprod.inl + CategoryStruct.comp f\u2082\u2082 biprod.inr"}]}
{"declaration": "theorem Biprod.ofComponents_fst :\n    Biprod.ofComponents f\u2081\u2081 f\u2081\u2082 f\u2082\u2081 f\u2082\u2082 \u226b biprod.fst = biprod.fst \u226b f\u2081\u2081 + biprod.snd \u226b f\u2082\u2081 := by\n  simp [Biprod.ofComponents]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Preadditive/Biproducts.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Preadditive", "CategoryTheory.Limits", "CategoryTheory.Functor", "CategoryTheory.Preadditive", "CategoryTheory.Limits"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C]", "{J : Type} [Fintype J]", "{J : Type} [Finite J]", "{J : Type} [Fintype J] {f : J \u2192 C} [HasBiproduct f]", "{J K : Type} [Finite J] {f : J \u2192 C} [HasFiniteBiproducts C]", "[Finite K]", "{X Y : C} [HasBinaryBiproduct X Y]", "{Z : C}", "{X Y : C} (f g : X \u27f6 Y)", "[HasBinaryBiproducts.{v} C]", "{X\u2081 X\u2082 Y\u2081 Y\u2082 : C}", "(f\u2081\u2081 : X\u2081 \u27f6 Y\u2081) (f\u2081\u2082 : X\u2081 \u27f6 Y\u2082) (f\u2082\u2081 : X\u2082 \u27f6 Y\u2081) (f\u2082\u2082 : X\u2082 \u27f6 Y\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasFiniteBiproducts C\ninst\u271d : HasBinaryBiproducts C\nX\u2081 X\u2082 Y\u2081 Y\u2082 : C\nf\u2081\u2081 : X\u2081 \u27f6 Y\u2081\nf\u2081\u2082 : X\u2081 \u27f6 Y\u2082\nf\u2082\u2081 : X\u2082 \u27f6 Y\u2081\nf\u2082\u2082 : X\u2082 \u27f6 Y\u2082\n\u22a2 CategoryStruct.comp (Biprod.ofComponents f\u2081\u2081 f\u2081\u2082 f\u2082\u2081 f\u2082\u2082) biprod.fst =\n    CategoryStruct.comp biprod.fst f\u2081\u2081 + CategoryStruct.comp biprod.snd f\u2082\u2081"}, {"line": "simp [Biprod.ofComponents]", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasFiniteBiproducts C\ninst\u271d : HasBinaryBiproducts C\nX\u2081 X\u2082 Y\u2081 Y\u2082 : C\nf\u2081\u2081 : X\u2081 \u27f6 Y\u2081\nf\u2081\u2082 : X\u2081 \u27f6 Y\u2082\nf\u2082\u2081 : X\u2082 \u27f6 Y\u2081\nf\u2082\u2082 : X\u2082 \u27f6 Y\u2082\n\u22a2 CategoryStruct.comp biprod.fst f\u2081\u2081 + 0 + CategoryStruct.comp biprod.snd f\u2082\u2081 + 0 =\n    CategoryStruct.comp biprod.fst f\u2081\u2081 + CategoryStruct.comp biprod.snd f\u2082\u2081"}]}
{"declaration": "theorem Biprod.ofComponents_snd :\n    Biprod.ofComponents f\u2081\u2081 f\u2081\u2082 f\u2082\u2081 f\u2082\u2082 \u226b biprod.snd = biprod.fst \u226b f\u2081\u2082 + biprod.snd \u226b f\u2082\u2082 := by\n  simp [Biprod.ofComponents]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Preadditive/Biproducts.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Preadditive", "CategoryTheory.Limits", "CategoryTheory.Functor", "CategoryTheory.Preadditive", "CategoryTheory.Limits"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C]", "{J : Type} [Fintype J]", "{J : Type} [Finite J]", "{J : Type} [Fintype J] {f : J \u2192 C} [HasBiproduct f]", "{J K : Type} [Finite J] {f : J \u2192 C} [HasFiniteBiproducts C]", "[Finite K]", "{X Y : C} [HasBinaryBiproduct X Y]", "{Z : C}", "{X Y : C} (f g : X \u27f6 Y)", "[HasBinaryBiproducts.{v} C]", "{X\u2081 X\u2082 Y\u2081 Y\u2082 : C}", "(f\u2081\u2081 : X\u2081 \u27f6 Y\u2081) (f\u2081\u2082 : X\u2081 \u27f6 Y\u2082) (f\u2082\u2081 : X\u2082 \u27f6 Y\u2081) (f\u2082\u2082 : X\u2082 \u27f6 Y\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasFiniteBiproducts C\ninst\u271d : HasBinaryBiproducts C\nX\u2081 X\u2082 Y\u2081 Y\u2082 : C\nf\u2081\u2081 : X\u2081 \u27f6 Y\u2081\nf\u2081\u2082 : X\u2081 \u27f6 Y\u2082\nf\u2082\u2081 : X\u2082 \u27f6 Y\u2081\nf\u2082\u2082 : X\u2082 \u27f6 Y\u2082\n\u22a2 CategoryStruct.comp (Biprod.ofComponents f\u2081\u2081 f\u2081\u2082 f\u2082\u2081 f\u2082\u2082) biprod.snd =\n    CategoryStruct.comp biprod.fst f\u2081\u2082 + CategoryStruct.comp biprod.snd f\u2082\u2082"}, {"line": "simp [Biprod.ofComponents]", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasFiniteBiproducts C\ninst\u271d : HasBinaryBiproducts C\nX\u2081 X\u2082 Y\u2081 Y\u2082 : C\nf\u2081\u2081 : X\u2081 \u27f6 Y\u2081\nf\u2081\u2082 : X\u2081 \u27f6 Y\u2082\nf\u2082\u2081 : X\u2082 \u27f6 Y\u2081\nf\u2082\u2082 : X\u2082 \u27f6 Y\u2082\n\u22a2 0 + CategoryStruct.comp biprod.fst f\u2081\u2082 + 0 + CategoryStruct.comp biprod.snd f\u2082\u2082 =\n    CategoryStruct.comp biprod.fst f\u2081\u2082 + CategoryStruct.comp biprod.snd f\u2082\u2082"}]}
{"declaration": "theorem app_units_zsmul (X : C) (\u03b1 : F \u27f6 G) (n : \u2124\u02e3) : (n \u2022 \u03b1).app X = n \u2022 \u03b1.app X := by\n  apply app_zsmul\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Preadditive/FunctorCategory.lean", "context": {"open": ["CategoryTheory.Limits Preadditive"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive D]", "{F G : C \u2964 D}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_4\nX : C\n\u03b1 : sorry\nn : \u2124\u02e3\n\u22a2 sorry = n \u2022 sorry"}, {"line": "apply app_zsmul", "tactic_state": "\u22a2 Type u_2\n---\n\u22a2 Type u_3\n---\n\u22a2 HSMul \u2124\u02e3 ?m.41033 ?m.41019"}]}
{"declaration": "lemma HasCardinalFilteredColimits_iff_hasFilteredColimitsOfSize :\n    HasCardinalFilteredColimits.{w} C \u2135\u2080 \u2194 HasFilteredColimitsOfSize.{w, w} C := by\n  refine \u27e8fun \u27e8H\u27e9 \u21a6 \u27e8?_\u27e9, fun \u27e8H\u27e9 \u21a6 \u27e8?_\u27e9\u27e9 <;>\n    simp only [isCardinalFiltered_aleph0_iff] at * <;>\n    exact H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Presentable/Finite.lean", "context": {"open": ["Limits Opposite Cardinal"], "variables": ["{C : Type u} [Category.{v} C] {D : Type u'} [Category.{v'} D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nHasCardinalFilteredColimits : x\u271d\u00b9\nx\u271d : Sort u_2\nHasFilteredColimitsOfSize : x\u271d\n\u22a2 sorry \u2194 sorry"}, {"line": "refine \u27e8fun \u27e8H\u27e9 \u21a6 \u27e8?_\u27e9, fun \u27e8H\u27e9 \u21a6 \u27e8?_\u27e9\u27e9 <;>\n    simp only [isCardinalFiltered_aleph0_iff] at * <;>\n    exact H", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_id_comp (F : C \u00d7 D \u2964 E) (W : C) {X Y Z : D} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    F.map ((\ud835\udfd9 W, f \u226b g) : (W, X) \u27f6 (W, Z)) =\n      F.map ((\ud835\udfd9 W, f) : (W, X) \u27f6 (W, Y)) \u226b F.map ((\ud835\udfd9 W, g) : (W, Y) \u27f6 (W, Z)) := by\n  rw [\u2190 Functor.map_comp]\n  rw [prod_comp]\n  rw [Category.comp_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Products/Bifunctor.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type u\u2081} {D : Type u\u2082} {E : Type u\u2083}", "[Category.{v\u2081} C] [Category.{v\u2082} D] [Category.{v\u2083} E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\nD : Type u\u2082\nE : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : CategoryTheory.Functor (C \u00d7 D) E\nW : C\nX Y Z : D\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 F.map (CategoryStruct.id W, CategoryStruct.comp f g) =\n    CategoryStruct.comp (F.map (CategoryStruct.id W, f)) (F.map (CategoryStruct.id W, g))"}, {"line": "rw [\u2190 Functor.map_comp]", "tactic_state": "C : Type u\u2081\nD : Type u\u2082\nE : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : CategoryTheory.Functor (C \u00d7 D) E\nW : C\nX Y Z : D\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 F.map (CategoryStruct.id W, CategoryStruct.comp f g) =\n    F.map (CategoryStruct.comp (CategoryStruct.id W, f) (CategoryStruct.id W, g))"}, {"line": "rw [prod_comp]", "tactic_state": "C : Type u\u2081\nD : Type u\u2082\nE : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : CategoryTheory.Functor (C \u00d7 D) E\nW : C\nX Y Z : D\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 F.map (CategoryStruct.id W, CategoryStruct.comp f g) =\n    F.map\n      (CategoryStruct.comp (CategoryStruct.id W, f).1 (CategoryStruct.id W, g).1,\n        CategoryStruct.comp (CategoryStruct.id W, f).2 (CategoryStruct.id W, g).2)"}, {"line": "rw [Category.comp_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_comp_id (F : C \u00d7 D \u2964 E) (X Y Z : C) (W : D) (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    F.map ((f \u226b g, \ud835\udfd9 W) : (X, W) \u27f6 (Z, W)) =\n      F.map ((f, \ud835\udfd9 W) : (X, W) \u27f6 (Y, W)) \u226b F.map ((g, \ud835\udfd9 W) : (Y, W) \u27f6 (Z, W)) := by\n  rw [\u2190 Functor.map_comp]\n  rw [prod_comp]\n  rw [Category.comp_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Products/Bifunctor.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type u\u2081} {D : Type u\u2082} {E : Type u\u2083}", "[Category.{v\u2081} C] [Category.{v\u2082} D] [Category.{v\u2083} E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\nD : Type u\u2082\nE : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : CategoryTheory.Functor (C \u00d7 D) E\nX Y Z : C\nW : D\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 F.map (CategoryStruct.comp f g, CategoryStruct.id W) =\n    CategoryStruct.comp (F.map (f, CategoryStruct.id W)) (F.map (g, CategoryStruct.id W))"}, {"line": "rw [\u2190 Functor.map_comp]", "tactic_state": "C : Type u\u2081\nD : Type u\u2082\nE : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : CategoryTheory.Functor (C \u00d7 D) E\nX Y Z : C\nW : D\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 F.map (CategoryStruct.comp f g, CategoryStruct.id W) =\n    F.map (CategoryStruct.comp (f, CategoryStruct.id W) (g, CategoryStruct.id W))"}, {"line": "rw [prod_comp]", "tactic_state": "C : Type u\u2081\nD : Type u\u2082\nE : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : CategoryTheory.Functor (C \u00d7 D) E\nX Y Z : C\nW : D\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 F.map (CategoryStruct.comp f g, CategoryStruct.id W) =\n    F.map\n      (CategoryStruct.comp (f, CategoryStruct.id W).1 (g, CategoryStruct.id W).1,\n        CategoryStruct.comp (f, CategoryStruct.id W).2 (g, CategoryStruct.id W).2)"}, {"line": "rw [Category.comp_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem diagonal (F : C \u00d7 D \u2964 E) (X X' : C) (f : X \u27f6 X') (Y Y' : D) (g : Y \u27f6 Y') :\n    F.map ((\ud835\udfd9 X, g) : (X, Y) \u27f6 (X, Y')) \u226b F.map ((f, \ud835\udfd9 Y') : (X, Y') \u27f6 (X', Y')) =\n      F.map ((f, g) : (X, Y) \u27f6 (X', Y')) := by\n  rw [\u2190 Functor.map_comp]\n  rw [prod_comp]\n  rw [Category.id_comp]\n  rw [Category.comp_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Products/Bifunctor.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type u\u2081} {D : Type u\u2082} {E : Type u\u2083}", "[Category.{v\u2081} C] [Category.{v\u2082} D] [Category.{v\u2083} E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\nD : Type u\u2082\nE : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : CategoryTheory.Functor (C \u00d7 D) E\nX X' : C\nf : X \u27f6 X'\nY Y' : D\ng : Y \u27f6 Y'\n\u22a2 CategoryStruct.comp (F.map (CategoryStruct.id X, g)) (F.map (f, CategoryStruct.id Y')) = F.map (f, g)"}, {"line": "rw [\u2190 Functor.map_comp]", "tactic_state": "C : Type u\u2081\nD : Type u\u2082\nE : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : CategoryTheory.Functor (C \u00d7 D) E\nX X' : C\nf : X \u27f6 X'\nY Y' : D\ng : Y \u27f6 Y'\n\u22a2 F.map (CategoryStruct.comp (CategoryStruct.id X, g) (f, CategoryStruct.id Y')) = F.map (f, g)"}, {"line": "rw [prod_comp]", "tactic_state": "C : Type u\u2081\nD : Type u\u2082\nE : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : CategoryTheory.Functor (C \u00d7 D) E\nX X' : C\nf : X \u27f6 X'\nY Y' : D\ng : Y \u27f6 Y'\n\u22a2 F.map\n      (CategoryStruct.comp (CategoryStruct.id X, g).1 (f, CategoryStruct.id Y').1,\n        CategoryStruct.comp (CategoryStruct.id X, g).2 (f, CategoryStruct.id Y').2) =\n    F.map (f, g)"}, {"line": "rw [Category.id_comp]", "tactic_state": "C : Type u\u2081\nD : Type u\u2082\nE : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : CategoryTheory.Functor (C \u00d7 D) E\nX X' : C\nf : X \u27f6 X'\nY Y' : D\ng : Y \u27f6 Y'\n\u22a2 F.map ((f, CategoryStruct.id Y').1, CategoryStruct.comp (CategoryStruct.id X, g).2 (f, CategoryStruct.id Y').2) =\n    F.map (f, g)"}, {"line": "rw [Category.comp_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem diagonal' (F : C \u00d7 D \u2964 E) (X X' : C) (f : X \u27f6 X') (Y Y' : D) (g : Y \u27f6 Y') :\n    F.map ((f, \ud835\udfd9 Y) : (X, Y) \u27f6 (X', Y)) \u226b F.map ((\ud835\udfd9 X', g) : (X', Y) \u27f6 (X', Y')) =\n      F.map ((f, g) : (X, Y) \u27f6 (X', Y')) := by\n  rw [\u2190 Functor.map_comp]\n  rw [prod_comp]\n  rw [Category.id_comp]\n  rw [Category.comp_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Products/Bifunctor.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type u\u2081} {D : Type u\u2082} {E : Type u\u2083}", "[Category.{v\u2081} C] [Category.{v\u2082} D] [Category.{v\u2083} E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\nD : Type u\u2082\nE : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : CategoryTheory.Functor (C \u00d7 D) E\nX X' : C\nf : X \u27f6 X'\nY Y' : D\ng : Y \u27f6 Y'\n\u22a2 CategoryStruct.comp (F.map (f, CategoryStruct.id Y)) (F.map (CategoryStruct.id X', g)) = F.map (f, g)"}, {"line": "rw [\u2190 Functor.map_comp]", "tactic_state": "C : Type u\u2081\nD : Type u\u2082\nE : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : CategoryTheory.Functor (C \u00d7 D) E\nX X' : C\nf : X \u27f6 X'\nY Y' : D\ng : Y \u27f6 Y'\n\u22a2 F.map (CategoryStruct.comp (f, CategoryStruct.id Y) (CategoryStruct.id X', g)) = F.map (f, g)"}, {"line": "rw [prod_comp]", "tactic_state": "C : Type u\u2081\nD : Type u\u2082\nE : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : CategoryTheory.Functor (C \u00d7 D) E\nX X' : C\nf : X \u27f6 X'\nY Y' : D\ng : Y \u27f6 Y'\n\u22a2 F.map\n      (CategoryStruct.comp (f, CategoryStruct.id Y).1 (CategoryStruct.id X', g).1,\n        CategoryStruct.comp (f, CategoryStruct.id Y).2 (CategoryStruct.id X', g).2) =\n    F.map (f, g)"}, {"line": "rw [Category.id_comp]", "tactic_state": "C : Type u\u2081\nD : Type u\u2082\nE : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : CategoryTheory.Functor (C \u00d7 D) E\nX X' : C\nf : X \u27f6 X'\nY Y' : D\ng : Y \u27f6 Y'\n\u22a2 F.map (CategoryStruct.comp (f, CategoryStruct.id Y).1 (CategoryStruct.id X', g).1, (CategoryStruct.id X', g).2) =\n    F.map (f, g)"}, {"line": "rw [Category.comp_id]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mk\u2080_zero (m\u2080 : M) (hm\u2080 : m\u2080 = 0) : mk\u2080 m\u2080 hm\u2080 (0 : X \u27f6 Y) = 0 := by simp [mk\u2080]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Shift/ShiftedHom.lean", "context": {"open": ["Category"], "variables": ["{C : Type*} [Category C] {D : Type*} [Category D] {E : Type*} [Category E]", "{X Y Z T : C}", "[Preadditive C]", "(X Y) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nx\u271d : Sort u_2\nmk\u2080 : x\u271d\nm\u2080 : M\nhm\u2080 : m\u2080 = 0\n\u22a2 sorry = 0"}, {"line": "simp [mk\u2080]", "tactic_state": "M : Type u_1\nx\u271d : Sort u_2\nmk\u2080 : x\u271d\nm\u2080 : M\nhm\u2080 : m\u2080 = 0\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma shiftFunctorAdd'_zero_add_hom_app (a : A) (X : C) :\n    (shiftFunctorAdd' C 0 a a (zero_add a)).hom.app X =\n    ((shiftFunctorZero C A).inv.app X)\u27e6a\u27e7' := by\n  simpa using NatTrans.congr_app (congr_arg Iso.hom (shiftFunctorAdd'_zero_add C a)) X\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Shift/Basic.lean", "context": {"open": ["Functor.Monoidal"], "variables": ["(C : Type u) (A : Type*) [Category.{v} C]", "{A C}", "(A C) [AddMonoid A]", "{C A}", "[HasShift C A]", "{A}", "(A) in", "{C A}", "(C)", "[HasShift C A]", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_5\nC : Sort u_6\ninst\u271d : AddMonoid A\nx\u271d\u00b9 : Sort u_1\nshiftFunctorAdd' : x\u271d\u00b9\nx\u271d : Sort u_2\nshiftFunctorZero : x\u271d\na : A\nX : C\n\u22a2 sorry = (CategoryTheory.shiftFunctor (?m.20620 a X) a).map sorry"}, {"line": "simpa using NatTrans.congr_app (congr_arg Iso.hom (shiftFunctorAdd'_zero_add C a)) X", "tactic_state": "No Goals!"}]}
{"declaration": "lemma shiftFunctorAdd'_zero_add_inv_app (a : A) (X : C) :\n    (shiftFunctorAdd' C 0 a a (zero_add a)).inv.app X =\n    ((shiftFunctorZero C A).hom.app X)\u27e6a\u27e7' := by\n  simpa using NatTrans.congr_app (congr_arg Iso.inv (shiftFunctorAdd'_zero_add C a)) X\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Shift/Basic.lean", "context": {"open": ["Functor.Monoidal"], "variables": ["(C : Type u) (A : Type*) [Category.{v} C]", "{A C}", "(A C) [AddMonoid A]", "{C A}", "[HasShift C A]", "{A}", "(A) in", "{C A}", "(C)", "[HasShift C A]", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_5\nC : Sort u_6\ninst\u271d : AddMonoid A\nx\u271d\u00b9 : Sort u_1\nshiftFunctorAdd' : x\u271d\u00b9\nx\u271d : Sort u_2\nshiftFunctorZero : x\u271d\na : A\nX : C\n\u22a2 sorry = (CategoryTheory.shiftFunctor (?m.20620 a X) a).map sorry"}, {"line": "simpa using NatTrans.congr_app (congr_arg Iso.inv (shiftFunctorAdd'_zero_add C a)) X", "tactic_state": "No Goals!"}]}
{"declaration": "lemma shiftFunctorAdd'_add_zero_hom_app (a : A) (X : C) :\n    (shiftFunctorAdd' C a 0 a (add_zero a)).hom.app X =\n    (shiftFunctorZero C A).inv.app (X\u27e6a\u27e7) := by\n  simpa using NatTrans.congr_app (congr_arg Iso.hom (shiftFunctorAdd'_add_zero C a)) X\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Shift/Basic.lean", "context": {"open": ["Functor.Monoidal"], "variables": ["(C : Type u) (A : Type*) [Category.{v} C]", "{A C}", "(A C) [AddMonoid A]", "{C A}", "[HasShift C A]", "{A}", "(A) in", "{C A}", "(C)", "[HasShift C A]", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_4\nC : Sort u_5\ninst\u271d : AddMonoid A\nx\u271d\u00b9 : Sort u_1\nshiftFunctorAdd' : x\u271d\u00b9\nx\u271d : Sort u_2\nshiftFunctorZero : x\u271d\na : A\nX : C\n\u22a2 sorry = sorry"}, {"line": "simpa using NatTrans.congr_app (congr_arg Iso.hom (shiftFunctorAdd'_add_zero C a)) X", "tactic_state": "No Goals!"}]}
{"declaration": "lemma shiftIso_add_hom_app (n m a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (F.shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha''])).hom.app X =\n      (shiftFunctorAdd D m n).hom.app ((F.functor a'').obj X) \u226b\n        ((F.shiftIso m a' a'' ha'').hom.app X)\u27e6n\u27e7' \u226b\n        (F.shiftIso n a a' ha').hom.app X := by\n  simp [F.shiftIso_add n m a a' a'' ha' ha'']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Shift/SingleFunctors.lean", "context": {"open": ["CategoryTheory Category ZeroObject Limits"], "variables": ["(C D E E' : Type*) [Category C] [Category D] [Category E] [Category E']", "{C D E A}", "(F G H : SingleFunctors C D A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d : Category.{u_9, u_1} C\nA : Type u_10\nn m a a' a'' : A\nha' : sorry\nha'' : sorry\nX : C\n\u22a2 sorry = CategoryStruct.comp sorry (CategoryStruct.comp sorry sorry)"}, {"line": "simp [F.shiftIso_add n m a a' a'' ha' ha'']", "tactic_state": "C : Type u_1\ninst\u271d : Category.{u_9, u_1} C\nA : Type u_10\nn m a a' a'' : A\nha' : sorry\nha'' : sorry\nX : C\n\u22a2 sorry () = CategoryStruct.comp (sorry ()) (CategoryStruct.comp (sorry ()) (sorry ()))"}]}
{"declaration": "lemma shiftIso_add_inv_app (n m a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (F.shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha''])).inv.app X =\n      (F.shiftIso n a a' ha').inv.app X \u226b\n      ((F.shiftIso m a' a'' ha'').inv.app X)\u27e6n\u27e7' \u226b\n      (shiftFunctorAdd D m n).inv.app ((F.functor a'').obj X) := by\n  simp [F.shiftIso_add n m a a' a'' ha' ha'']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Shift/SingleFunctors.lean", "context": {"open": ["CategoryTheory Category ZeroObject Limits"], "variables": ["(C D E E' : Type*) [Category C] [Category D] [Category E] [Category E']", "{C D E A}", "(F G H : SingleFunctors C D A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d : Category.{u_9, u_1} C\nA : Type u_10\nn m a a' a'' : A\nha' : sorry\nha'' : sorry\nX : C\n\u22a2 sorry = CategoryStruct.comp sorry (CategoryStruct.comp sorry sorry)"}, {"line": "simp [F.shiftIso_add n m a a' a'' ha' ha'']", "tactic_state": "C : Type u_1\ninst\u271d : Category.{u_9, u_1} C\nA : Type u_10\nn m a a' a'' : A\nha' : sorry\nha'' : sorry\nX : C\n\u22a2 sorry () = CategoryStruct.comp (sorry ()) (CategoryStruct.comp (sorry ()) (sorry ()))"}]}
{"declaration": "lemma shiftIso_add'_hom_app (n m mn : A) (hnm : m + n = mn) (a a' a'' : A)\n    (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (F.shiftIso mn a a'' (by rw [\u2190 hnm, \u2190 ha'', \u2190 ha', add_assoc])).hom.app X =\n      (shiftFunctorAdd' D m n mn hnm).hom.app ((F.functor a'').obj X) \u226b\n        ((F.shiftIso m a' a'' ha'').hom.app X)\u27e6n\u27e7' \u226b (F.shiftIso n a a' ha').hom.app X := by\n  simp [F.shiftIso_add' n m mn hnm a a' a'' ha' ha'']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Shift/SingleFunctors.lean", "context": {"open": ["CategoryTheory Category ZeroObject Limits"], "variables": ["(C D E E' : Type*) [Category C] [Category D] [Category E] [Category E']", "{C D E A}", "(F G H : SingleFunctors C D A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d : Category.{u_10, u_1} C\nA : Type u_11\nn m mn : A\nhnm : sorry\na a' a'' : A\nha' : sorry\nha'' : sorry\nX : C\n\u22a2 sorry = CategoryStruct.comp sorry (CategoryStruct.comp sorry sorry)"}, {"line": "simp [F.shiftIso_add' n m mn hnm a a' a'' ha' ha'']", "tactic_state": "C : Type u_1\ninst\u271d : Category.{u_10, u_1} C\nA : Type u_11\nn m mn : A\nhnm : sorry\na a' a'' : A\nha' : sorry\nha'' : sorry\nX : C\n\u22a2 sorry () = CategoryStruct.comp (sorry ()) (CategoryStruct.comp (sorry ()) (sorry ()))"}]}
{"declaration": "lemma shiftIso_add'_inv_app (n m mn : A) (hnm : m + n = mn) (a a' a'' : A)\n    (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (F.shiftIso mn a a'' (by rw [\u2190 hnm, \u2190 ha'', \u2190 ha', add_assoc])).inv.app X =\n        (F.shiftIso n a a' ha').inv.app X \u226b\n        ((F.shiftIso m a' a'' ha'').inv.app X)\u27e6n\u27e7' \u226b\n      (shiftFunctorAdd' D m n mn hnm).inv.app ((F.functor a'').obj X) := by\n  simp [F.shiftIso_add' n m mn hnm a a' a'' ha' ha'']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Shift/SingleFunctors.lean", "context": {"open": ["CategoryTheory Category ZeroObject Limits"], "variables": ["(C D E E' : Type*) [Category C] [Category D] [Category E] [Category E']", "{C D E A}", "(F G H : SingleFunctors C D A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d : Category.{u_10, u_1} C\nA : Type u_11\nn m mn : A\nhnm : sorry\na a' a'' : A\nha' : sorry\nha'' : sorry\nX : C\n\u22a2 sorry = CategoryStruct.comp sorry (CategoryStruct.comp sorry sorry)"}, {"line": "simp [F.shiftIso_add' n m mn hnm a a' a'' ha' ha'']", "tactic_state": "C : Type u_1\ninst\u271d : Category.{u_10, u_1} C\nA : Type u_11\nn m mn : A\nhnm : sorry\na a' a'' : A\nha' : sorry\nha'' : sorry\nX : C\n\u22a2 sorry () = CategoryStruct.comp (sorry ()) (CategoryStruct.comp (sorry ()) (sorry ()))"}]}
{"declaration": "theorem ran_isSheaf_of_isCocontinuous (\u2131 : Sheaf J A) :\n    Presheaf.IsSheaf K (G.op.ran.obj \u2131.val) := by\n  rw [Presheaf.isSheaf_iff_multifork]\n  intros X S\n  exact \u27e8RanIsSheafOfIsCocontinuous.isLimitMultifork \u2131.2\n    (G.op.isPointwiseRightKanExtensionRanCounit \u2131.val) S\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/CoverLifting.lean", "context": {"open": ["CategoryTheory", "Opposite", "CategoryTheory.Presieve.FamilyOfElements", "CategoryTheory.Presieve", "CategoryTheory.Limits"], "variables": ["{C : Type*} [Category C] {D : Type*} [Category D] {E : Type*} [Category E] (G : C \u2964 D)", "(J : GrothendieckTopology C) (K : GrothendieckTopology D)", "{L : GrothendieckTopology E}", "{C D : Type*} [Category C] [Category D] (G : C \u2964 D)", "{A : Type w} [Category.{w'} A]", "{J : GrothendieckTopology C} {K : GrothendieckTopology D} [G.IsCocontinuous J K]", "{G}", "{F : C\u1d52\u1d56 \u2964 A} (hF : Presheaf.IsSheaf J F)", "{R : D\u1d52\u1d56 \u2964 A} (\u03b1 : G.op \u22d9 R \u27f6 F)", "(hR : (Functor.RightExtension.mk _ \u03b1).IsPointwiseRightKanExtension)", "{X : D} {S : K.Cover X} (s : Multifork (S.index R))", "{\u03b1}", "(K) in", "(S)", "(K)", "[\u2200 (F : C\u1d52\u1d56 \u2964 A), G.op.HasPointwiseRightKanExtension F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_4\nD : Type u_5\ninst\u271d\u2074 : Category.{u_6, u_4} C\ninst\u271d\u00b3 : Category.{u_7, u_5} D\nG : CategoryTheory.Functor C D\nA : Type w\ninst\u271d\u00b2 : Category.{w', w} A\nJ : GrothendieckTopology C\nK : GrothendieckTopology D\ninst\u271d\u00b9 : G.IsCocontinuous J K\ninst\u271d : \u2200 (F : CategoryTheory.Functor C\u1d52\u1d56 A), G.op.HasPointwiseRightKanExtension F\n\u2131 : Sheaf J A\n\u22a2 Presheaf.IsSheaf K (G.op.ran.obj \u2131.val)"}, {"line": "rw [Presheaf.isSheaf_iff_multifork]", "tactic_state": "C : Type u_4\nD : Type u_5\ninst\u271d\u2074 : Category.{u_6, u_4} C\ninst\u271d\u00b3 : Category.{u_7, u_5} D\nG : CategoryTheory.Functor C D\nA : Type w\ninst\u271d\u00b2 : Category.{w', w} A\nJ : GrothendieckTopology C\nK : GrothendieckTopology D\ninst\u271d\u00b9 : G.IsCocontinuous J K\ninst\u271d : \u2200 (F : CategoryTheory.Functor C\u1d52\u1d56 A), G.op.HasPointwiseRightKanExtension F\n\u2131 : Sheaf J A\n\u22a2 \u2200 (X : D) (S : K.Cover X), Nonempty (IsLimit (S.multifork (G.op.ran.obj \u2131.val)))"}, {"line": "intros X S", "tactic_state": "C : Type u_4\nD : Type u_5\ninst\u271d\u2074 : Category.{u_6, u_4} C\ninst\u271d\u00b3 : Category.{u_7, u_5} D\nG : CategoryTheory.Functor C D\nA : Type w\ninst\u271d\u00b2 : Category.{w', w} A\nJ : GrothendieckTopology C\nK : GrothendieckTopology D\ninst\u271d\u00b9 : G.IsCocontinuous J K\ninst\u271d : \u2200 (F : CategoryTheory.Functor C\u1d52\u1d56 A), G.op.HasPointwiseRightKanExtension F\n\u2131 : Sheaf J A\nX : D\nS : K.Cover X\n\u22a2 Nonempty (IsLimit (S.multifork (G.op.ran.obj \u2131.val)))"}, {"line": "exact \u27e8RanIsSheafOfIsCocontinuous.isLimitMultifork \u2131.2\n    (G.op.isPointwiseRightKanExtensionRanCounit \u2131.val) S\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coversTop_iff_of_isTerminal (X : C) (hX : IsTerminal X)\n    {I : Type*} (Y : I \u2192 C) :\n    J.CoversTop Y \u2194 Sieve.ofObjects Y X \u2208 J X := by\n  constructor\n  \u00b7 tauto\n  \u00b7 intro h W\n    apply J.superset_covering _ (J.pullback_stable (hX.from W) h)\n    rintro T a \u27e8i, \u27e8b\u27e9\u27e9\n    exact \u27e8i, \u27e8b\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/CoversTop.lean", "context": {"open": ["Limits"], "variables": ["{C : Type u} [Category.{v} C] (J : GrothendieckTopology C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Sort u_2\nx\u271d\u00b9 : Sort u_3\nIsTerminal : x\u271d\u00b9\nx\u271d : Sort u_4\nJ : x\u271d\nX : C\nhX : sorry\nI : Type u_1\nY : I \u2192 C\n\u22a2 sorry \u2194 sorry \u2208 sorry"}, {"line": "constructor", "tactic_state": "case mp\nC : Sort u_2\nx\u271d\u00b9 : Sort u_3\nIsTerminal : x\u271d\u00b9\nx\u271d : Sort u_4\nJ : x\u271d\nX : C\nhX : sorry\nI : Type u_1\nY : I \u2192 C\n\u22a2 sorry \u2192 sorry \u2208 sorry\n---\ncase mpr\nC : Sort u_2\nx\u271d\u00b9 : Sort u_3\nIsTerminal : x\u271d\u00b9\nx\u271d : Sort u_4\nJ : x\u271d\nX : C\nhX : sorry\nI : Type u_1\nY : I \u2192 C\n\u22a2 sorry \u2208 sorry \u2192 sorry"}, {"line": "\u00b7 tauto", "tactic_state": "case mpr\nC : Sort u_2\nx\u271d\u00b9 : Sort u_3\nIsTerminal : x\u271d\u00b9\nx\u271d : Sort u_4\nJ : x\u271d\nX : C\nhX : sorry\nI : Type u_1\nY : I \u2192 C\n\u22a2 sorry \u2208 sorry \u2192 sorry"}, {"line": "\u00b7 intro h W\n    apply J.superset_covering _ (J.pullback_stable (hX.from W) h)\n    rintro T a \u27e8i, \u27e8b\u27e9\u27e9\n    exact \u27e8i, \u27e8b\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Sheaf.\u0393ObjEquivSections_naturality [HasWeakSheafify J (Type w)]\n    [HasGlobalSectionsFunctor J (Type w)] {F G : Sheaf J (Type w)} (f : F \u27f6 G) (x : (\u0393 J _).obj F) :\n    (\u0393ObjEquivSections J G) ((\u0393 J _).map f x) =\n      (Functor.sectionsFunctor _).map f.val ((\u0393ObjEquivSections J F) x) := by\n  dsimp [\u0393ObjEquivSections]\n  exact (congr_arg _ (\u0393HomEquiv_naturality_right_symm _ _)).trans\n    (Functor.sectionsEquivHom_naturality_symm _ _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/GlobalSections.lean", "context": {"open": ["CategoryTheory Limits Sheaf Opposite GrothendieckTopology"], "variables": ["{C : Type u} [Category.{v} C] (J : GrothendieckTopology C)", "{J A}", "(J A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nJ : GrothendieckTopology C\ninst\u271d\u00b9 : HasWeakSheafify J (Type w)\ninst\u271d : HasGlobalSectionsFunctor J (Type w)\nF G : Sheaf J (Type w)\nf : F \u27f6 G\nx : (\u0393 J (Type w)).obj F\n\u22a2 (\u0393ObjEquivSections J G) ((\u0393 J (Type w)).map f x) = (Functor.sectionsFunctor C\u1d52\u1d56).map f.val ((\u0393ObjEquivSections J F) x)"}, {"line": "dsimp [\u0393ObjEquivSections]", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nJ : GrothendieckTopology C\ninst\u271d\u00b9 : HasWeakSheafify J (Type w)\ninst\u271d : HasGlobalSectionsFunctor J (Type w)\nF G : Sheaf J (Type w)\nf : F \u27f6 G\nx : (\u0393 J (Type w)).obj F\n\u22a2 (G.val.sectionsEquivHom PUnit.{w + 1}).symm\n      (\u0393HomEquiv.symm ((Equiv.funUnique PUnit.{w + 1} ((\u0393 J (Type w)).obj G)).symm ((\u0393 J (Type w)).map f x))) =\n    (Functor.sectionsFunctor C\u1d52\u1d56).map f.val\n      ((F.val.sectionsEquivHom PUnit.{w + 1}).symm\n        (\u0393HomEquiv.symm ((Equiv.funUnique PUnit.{w + 1} ((\u0393 J (Type w)).obj F)).symm x)))"}, {"line": "exact (congr_arg _ (\u0393HomEquiv_naturality_right_symm _ _)).trans\n    (Functor.sectionsEquivHom_naturality_symm _ _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma W_iff_isLocallyBijective :\n    J.W f \u2194 Presheaf.IsLocallyInjective J f \u2227 Presheaf.IsLocallySurjective J f := by\n  apply WEqualsLocallyBijective.iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/LocallyBijective.lean", "context": {"open": [], "variables": ["{C : Type u} [Category.{v} C] {J : GrothendieckTopology C}", "{A : Type u'} [Category.{v'} A] {FA : A \u2192 A \u2192 Type*} {CA : A \u2192 Type w'}", "[\u2200 X Y, FunLike (FA X Y) (CA X) (CA Y)] [ConcreteCategory.{w'} A FA]", "{F G : Sheaf J (Type w)} (f : F \u27f6 G)", "{F G : Sheaf J A} (f : F \u27f6 G) [(forget A).ReflectsIsomorphisms]", "(J A)", "{A}", "[J.WEqualsLocallyBijective A] {X Y : C\u1d52\u1d56 \u2964 A} (f : X \u27f6 Y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Sheaf : ?m.7776\nF : sorry\nG : sorry\nf : F \u27f6 G\nJ : ?m.9124 f\nA : ?m.9125 f J\n\u22a2 sorry \u2194 sorry \u2227 sorry"}, {"line": "apply WEqualsLocallyBijective.iff", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isLocallyInjective_forget_iff :\n    IsLocallyInjective J (whiskerRight \u03c6 (forget D)) \u2194 IsLocallyInjective J \u03c6 := by\n  constructor\n  \u00b7 intro\n    exact \u27e8fun x y h => equalizerSieve_mem J (whiskerRight \u03c6 (forget D)) x y h\u27e9\n  \u00b7 intro\n    infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/LocallyInjective.lean", "context": {"open": ["Opposite Limits"], "variables": ["{C : Type u} [Category.{v} C]", "{F\u2081 F\u2082 F\u2083 : C\u1d52\u1d56 \u2964 D} (\u03c6 : F\u2081 \u27f6 F\u2082) (\u03c8 : F\u2082 \u27f6 F\u2083)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Type u_1\nx\u271d : Type u_2\nJ : x\u271d\u00b9 \u2192 x\u271d\n\u22a2 sorry \u2194 sorry"}, {"line": "constructor", "tactic_state": "case mp\nx\u271d\u00b9 : Type u_1\nx\u271d : Type u_2\nJ : x\u271d\u00b9 \u2192 x\u271d\n\u22a2 sorry \u2192 sorry\n---\ncase mpr\nx\u271d\u00b9 : Type u_1\nx\u271d : Type u_2\nJ : x\u271d\u00b9 \u2192 x\u271d\n\u22a2 sorry \u2192 sorry"}, {"line": "\u00b7 intro\n    exact \u27e8fun x y h => equalizerSieve_mem J (whiskerRight \u03c6 (forget D)) x y h\u27e9", "tactic_state": "case mpr\nx\u271d\u00b9 : Type u_1\nx\u271d : Type u_2\nJ : x\u271d\u00b9 \u2192 x\u271d\n\u22a2 sorry \u2192 sorry"}, {"line": "\u00b7 intro\n    infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLocallySurjective_iff_range_sheafify_eq_top {F G : C\u1d52\u1d56 \u2964 A} (f : F \u27f6 G) :\n    IsLocallySurjective J f \u2194 (Subpresheaf.range (whiskerRight f (forget A))).sheafify J = \u22a4 := by\n  simp only [Subpresheaf.ext_iff]\n  simp only [funext_iff]\n  simp only [Set.ext_iff]\n  simp only [Subpresheaf.top_obj]\n  simp only [Set.top_eq_univ]\n  simp only [Set.mem_univ]\n  simp only [iff_true]\n  exact \u27e8fun H _ => H.imageSieve_mem, fun H => \u27e8H _\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/LocallySurjective.lean", "context": {"open": ["Opposite CategoryTheory CategoryTheory.GrothendieckTopology"], "variables": ["{C : Type u} [Category.{v} C] (J : GrothendieckTopology C)", "{A : Type u'} [Category.{v'} A] {FA : A \u2192 A \u2192 Type*} {CA : A \u2192 Type w'}", "[\u2200 X Y, FunLike (FA X Y) (CA X) (CA Y)] [ConcreteCategory.{w'} A FA]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nJ : GrothendieckTopology C\nA : Type u'\ninst\u271d\u00b2 : Category.{v', u'} A\nFA : A \u2192 A \u2192 Type u_1\nCA : A \u2192 Type w'\ninst\u271d\u00b9 : (X Y : A) \u2192 FunLike (FA X Y) (CA X) (CA Y)\ninst\u271d : ConcreteCategory A FA\nx\u271d : Sort u_2\nIsLocallySurjective : x\u271d\nF G : CategoryTheory.Functor C\u1d52\u1d56 A\nf : F \u27f6 G\n\u22a2 sorry \u2194 Subpresheaf.sheafify J (Subpresheaf.range (whiskerRight f (forget A))) = \u22a4"}, {"line": "simp only [Subpresheaf.ext_iff]", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nJ : GrothendieckTopology C\nA : Type u'\ninst\u271d\u00b2 : Category.{v', u'} A\nFA : A \u2192 A \u2192 Type u_1\nCA : A \u2192 Type w'\ninst\u271d\u00b9 : (X Y : A) \u2192 FunLike (FA X Y) (CA X) (CA Y)\ninst\u271d : ConcreteCategory A FA\nx\u271d : Sort u_2\nIsLocallySurjective : x\u271d\nF G : CategoryTheory.Functor C\u1d52\u1d56 A\nf : F \u27f6 G\n\u22a2 sorry \u2194 (Subpresheaf.sheafify J (Subpresheaf.range (whiskerRight f (forget A)))).obj = \u22a4.obj"}, {"line": "simp only [funext_iff]", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nJ : GrothendieckTopology C\nA : Type u'\ninst\u271d\u00b2 : Category.{v', u'} A\nFA : A \u2192 A \u2192 Type u_1\nCA : A \u2192 Type w'\ninst\u271d\u00b9 : (X Y : A) \u2192 FunLike (FA X Y) (CA X) (CA Y)\ninst\u271d : ConcreteCategory A FA\nx\u271d : Sort u_2\nIsLocallySurjective : x\u271d\nF G : CategoryTheory.Functor C\u1d52\u1d56 A\nf : F \u27f6 G\n\u22a2 sorry \u2194 \u2200 (x : C\u1d52\u1d56), (Subpresheaf.sheafify J (Subpresheaf.range (whiskerRight f (forget A)))).obj x = \u22a4.obj x"}, {"line": "simp only [Set.ext_iff]", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nJ : GrothendieckTopology C\nA : Type u'\ninst\u271d\u00b2 : Category.{v', u'} A\nFA : A \u2192 A \u2192 Type u_1\nCA : A \u2192 Type w'\ninst\u271d\u00b9 : (X Y : A) \u2192 FunLike (FA X Y) (CA X) (CA Y)\ninst\u271d : ConcreteCategory A FA\nx\u271d : Sort u_2\nIsLocallySurjective : x\u271d\nF G : CategoryTheory.Functor C\u1d52\u1d56 A\nf : F \u27f6 G\n\u22a2 sorry \u2194\n    \u2200 (x : C\u1d52\u1d56) (x_1 : (G.comp (forget A)).obj x),\n      x_1 \u2208 (Subpresheaf.sheafify J (Subpresheaf.range (whiskerRight f (forget A)))).obj x \u2194 x_1 \u2208 \u22a4.obj x"}, {"line": "simp only [Subpresheaf.top_obj]", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nJ : GrothendieckTopology C\nA : Type u'\ninst\u271d\u00b2 : Category.{v', u'} A\nFA : A \u2192 A \u2192 Type u_1\nCA : A \u2192 Type w'\ninst\u271d\u00b9 : (X Y : A) \u2192 FunLike (FA X Y) (CA X) (CA Y)\ninst\u271d : ConcreteCategory A FA\nx\u271d : Sort u_2\nIsLocallySurjective : x\u271d\nF G : CategoryTheory.Functor C\u1d52\u1d56 A\nf : F \u27f6 G\n\u22a2 sorry \u2194\n    \u2200 (x : C\u1d52\u1d56) (x_1 : (G.comp (forget A)).obj x),\n      x_1 \u2208 (Subpresheaf.sheafify J (Subpresheaf.range (whiskerRight f (forget A)))).obj x \u2194 x_1 \u2208 \u22a4"}, {"line": "simp only [Set.top_eq_univ]", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nJ : GrothendieckTopology C\nA : Type u'\ninst\u271d\u00b2 : Category.{v', u'} A\nFA : A \u2192 A \u2192 Type u_1\nCA : A \u2192 Type w'\ninst\u271d\u00b9 : (X Y : A) \u2192 FunLike (FA X Y) (CA X) (CA Y)\ninst\u271d : ConcreteCategory A FA\nx\u271d : Sort u_2\nIsLocallySurjective : x\u271d\nF G : CategoryTheory.Functor C\u1d52\u1d56 A\nf : F \u27f6 G\n\u22a2 sorry \u2194\n    \u2200 (x : C\u1d52\u1d56) (x_1 : (G.comp (forget A)).obj x),\n      x_1 \u2208 (Subpresheaf.sheafify J (Subpresheaf.range (whiskerRight f (forget A)))).obj x \u2194 x_1 \u2208 Set.univ"}, {"line": "simp only [Set.mem_univ]", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nJ : GrothendieckTopology C\nA : Type u'\ninst\u271d\u00b2 : Category.{v', u'} A\nFA : A \u2192 A \u2192 Type u_1\nCA : A \u2192 Type w'\ninst\u271d\u00b9 : (X Y : A) \u2192 FunLike (FA X Y) (CA X) (CA Y)\ninst\u271d : ConcreteCategory A FA\nx\u271d : Sort u_2\nIsLocallySurjective : x\u271d\nF G : CategoryTheory.Functor C\u1d52\u1d56 A\nf : F \u27f6 G\n\u22a2 sorry \u2194\n    \u2200 (x : C\u1d52\u1d56) (x_1 : (G.comp (forget A)).obj x),\n      x_1 \u2208 (Subpresheaf.sheafify J (Subpresheaf.range (whiskerRight f (forget A)))).obj x \u2194 True"}, {"line": "simp only [iff_true]", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nJ : GrothendieckTopology C\nA : Type u'\ninst\u271d\u00b2 : Category.{v', u'} A\nFA : A \u2192 A \u2192 Type u_1\nCA : A \u2192 Type w'\ninst\u271d\u00b9 : (X Y : A) \u2192 FunLike (FA X Y) (CA X) (CA Y)\ninst\u271d : ConcreteCategory A FA\nx\u271d : Sort u_2\nIsLocallySurjective : x\u271d\nF G : CategoryTheory.Functor C\u1d52\u1d56 A\nf : F \u27f6 G\n\u22a2 sorry \u2194\n    \u2200 (x : C\u1d52\u1d56) (x_1 : (G.comp (forget A)).obj x),\n      x_1 \u2208 (Subpresheaf.sheafify J (Subpresheaf.range (whiskerRight f (forget A)))).obj x"}, {"line": "exact \u27e8fun H _ => H.imageSieve_mem, fun H => \u27e8H _\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLocallySurjective_iff_range_sheafify_eq_top' {F G : C\u1d52\u1d56 \u2964 Type w} (f : F \u27f6 G) :\n    IsLocallySurjective J f \u2194 (Subpresheaf.range f).sheafify J = \u22a4 := by\n  apply isLocallySurjective_iff_range_sheafify_eq_top\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/LocallySurjective.lean", "context": {"open": ["Opposite CategoryTheory CategoryTheory.GrothendieckTopology"], "variables": ["{C : Type u} [Category.{v} C] (J : GrothendieckTopology C)", "{A : Type u'} [Category.{v'} A] {FA : A \u2192 A \u2192 Type*} {CA : A \u2192 Type w'}", "[\u2200 X Y, FunLike (FA X Y) (CA X) (CA Y)] [ConcreteCategory.{w'} A FA]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nJ : GrothendieckTopology C\nx\u271d : Sort u_2\nIsLocallySurjective : x\u271d\nF G : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nf : F \u27f6 G\n\u22a2 sorry \u2194 Subpresheaf.sheafify J (Subpresheaf.range f) = \u22a4"}, {"line": "apply isLocallySurjective_iff_range_sheafify_eq_top", "tactic_state": "No Goals!"}]}
{"declaration": "lemma overEquiv_symm_iff {X : C} {Y : Over X} (S : Sieve Y.left) {Z : Over X} (f : Z \u27f6 Y) :\n    (overEquiv Y).symm S f \u2194 S f.left := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/Over.lean", "context": {"open": ["Category"], "variables": ["{C : Type u} [Category.{v} C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Sort u_1\nx\u271d\u00b2 : Sort u_2\nOver : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_3\nSieve : x\u271d\u00b9\nx\u271d : Sort u_4\noverEquiv : x\u271d\nX : C\nY : sorry\nS : sorry\nZ : sorry\nf : Z \u27f6 Y\n\u22a2 sorry \u2194 sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singleton_eq_iff_domain (f g : Y \u27f6 X) : singleton f g \u2194 f = g := by\n  constructor\n  \u00b7 rintro \u27e8a, rfl\u27e9\n    rfl\n  \u00b7 rintro rfl\n    apply singleton.mk\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/Sieves.lean", "context": {"open": ["Category Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D] (F : C \u2964 D)", "{X Y Z : C} (f : Y \u27f6 X)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : sorry\ng : sorry\n\u22a2 sorry \u2194 f = g"}, {"line": "constructor", "tactic_state": "case mp\nf : sorry\ng : sorry\n\u22a2 sorry \u2192 f = g\n---\ncase mpr\nf : sorry\ng : sorry\n\u22a2 f = g \u2192 sorry"}, {"line": "\u00b7 rintro \u27e8a, rfl\u27e9\n    rfl", "tactic_state": "case mpr\nf : sorry\ng : sorry\n\u22a2 f = g \u2192 sorry"}, {"line": "\u00b7 rintro rfl\n    apply singleton.mk", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pullback_inter {f : Y \u27f6 X} (S R : Sieve X) :\n    (S \u2293 R).pullback f = S.pullback f \u2293 R.pullback f := by simp [Sieve.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/Sieves.lean", "context": {"open": ["Category Limits", "Lattice", "Order Lattice"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D] (F : C \u2964 D)", "{X Y Z : C} (f : Y \u27f6 X)", "{E : Type u\u2083} [Category.{v\u2083} E] (G : D \u2964 E)", "{S R : Sieve X}", "{I : Type*} {X : C} (Y : I \u2192 C) (f : \u2200 i, Y i \u27f6 X)", "{Y f} {W : C} {g : W \u27f6 X} (hg : ofArrows Y f g)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type ?u.8180\nSieve : ?m.7163\nofArrows : ?m.8171\nX\u271d Y\u271d Z : C\nf\u271d\u00b9 : sorry\nS\u271d : sorry\nR\u271d : sorry\nI : Type u_1\nX : C\nY : I \u2192 C\nf\u271d : I \u2192 sorry\nW : C\ng : sorry\nhg : sorry\nf : sorry\nS : sorry\nR : sorry\n\u22a2 sorry = sorry \u2293 sorry"}, {"line": "simp [Sieve.ext_iff]", "tactic_state": "C : Type ?u.8180\nSieve : ?m.7163\nofArrows : ?m.8171\nX\u271d Y\u271d Z : C\nf\u271d\u00b9 : sorry\nS\u271d : sorry\nR\u271d : sorry\nI : Type u_1\nX : C\nY : I \u2192 C\nf\u271d : I \u2192 sorry\nW : C\ng : sorry\nhg : sorry\nf : sorry\nS : sorry\nR : sorry\n\u22a2 sorry () = sorry () \u2293 sorry ()"}]}
{"declaration": "theorem Subpresheaf.le_sheafify : G \u2264 G.sheafify J := by\n  intro U s hs\n  change _ \u2208 J _\n  convert J.top_mem U.unop -- Porting note: `U.unop` can not be inferred now\n  rw [eq_top_iff]\n  rintro V i -\n  exact G.map i.op hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/Subsheaf.lean", "context": {"open": ["Opposite CategoryTheory"], "variables": ["{C : Type u} [Category.{v} C] (J : GrothendieckTopology C)", "{F F' F'' : C\u1d52\u1d56 \u2964 Type w} (G G' : Subpresheaf F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nJ : GrothendieckTopology C\nF : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nG : Subpresheaf F\n\u22a2 G \u2264 Subpresheaf.sheafify J G"}, {"line": "intro U s hs", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nJ : GrothendieckTopology C\nF : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nG : Subpresheaf F\nU : C\u1d52\u1d56\ns : F.obj U\nhs : s \u2208 G.obj U\n\u22a2 s \u2208 (Subpresheaf.sheafify J G).obj U"}, {"line": "change _ \u2208 J _", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nJ : GrothendieckTopology C\nF : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nG : Subpresheaf F\nU : C\u1d52\u1d56\ns : F.obj U\nhs : s \u2208 G.obj U\n\u22a2 G.sieveOfSection s \u2208 J (unop U)"}, {"line": "convert J.top_mem U.unop -- Porting note: `U.unop` can not be inferred now", "tactic_state": "case h.e'_5\nC : Type u\ninst\u271d : Category.{v, u} C\nJ : GrothendieckTopology C\nF : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nG : Subpresheaf F\nU : C\u1d52\u1d56\ns : F.obj U\nhs : s \u2208 G.obj U\n\u22a2 G.sieveOfSection s = \u22a4"}, {"line": "rw [eq_top_iff]", "tactic_state": "case h.e'_5\nC : Type u\ninst\u271d : Category.{v, u} C\nJ : GrothendieckTopology C\nF : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nG : Subpresheaf F\nU : C\u1d52\u1d56\ns : F.obj U\nhs : s \u2208 G.obj U\n\u22a2 \u22a4 \u2264 G.sieveOfSection s"}, {"line": "rintro V i -", "tactic_state": "case h.e'_5\nC : Type u\ninst\u271d : Category.{v, u} C\nJ : GrothendieckTopology C\nF : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nG : Subpresheaf F\nU : C\u1d52\u1d56\ns : F.obj U\nhs : s \u2208 G.obj U\nV : C\ni : V \u27f6 unop U\n\u22a2 (G.sieveOfSection s).arrows i"}, {"line": "exact G.map i.op hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toPlus_comp_plusCompIso_inv :\n    J.toPlus _ \u226b (J.plusCompIso F P).inv = whiskerRight (J.toPlus _) _ := by simp [Iso.comp_inv_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/CompatiblePlus.lean", "context": {"open": ["CategoryTheory Limits Opposite"], "variables": ["{C : Type u} [Category.{v} C] (J : GrothendieckTopology C)", "{D : Type w\u2081} [Category.{max v u} D]", "{E : Type w\u2082} [Category.{max v u} E]", "(F : D \u2964 E)", "[\u2200 (J : MulticospanShape.{max v u, max v u}), HasLimitsOfShape (WalkingMulticospan J) D]", "[\u2200 (J : MulticospanShape.{max v u, max v u}), HasLimitsOfShape (WalkingMulticospan J) E]", "[\u2200 (X : C) (W : J.Cover X) (P : C\u1d52\u1d56 \u2964 D), PreservesLimit (W.index P).multicospan F]", "(P : C\u1d52\u1d56 \u2964 D)", "[\u2200 X : C, HasColimitsOfShape (J.Cover X)\u1d52\u1d56 D]", "[\u2200 X : C, HasColimitsOfShape (J.Cover X)\u1d52\u1d56 E]", "[\u2200 X : C, PreservesColimitsOfShape (J.Cover X)\u1d52\u1d56 F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u2078 : Category.{v, u} C\nJ : GrothendieckTopology C\nD : Type w\u2081\ninst\u271d\u2077 : Category.{max v u, w\u2081} D\nE : Type w\u2082\ninst\u271d\u2076 : Category.{max v u, w\u2082} E\nF : CategoryTheory.Functor D E\ninst\u271d\u2075 : \u2200 (J : MulticospanShape), HasLimitsOfShape (WalkingMulticospan J) D\ninst\u271d\u2074 : \u2200 (J : MulticospanShape), HasLimitsOfShape (WalkingMulticospan J) E\ninst\u271d\u00b3 : \u2200 (X : C) (W : J.Cover X) (P : CategoryTheory.Functor C\u1d52\u1d56 D), PreservesLimit (W.index P).multicospan F\nP : CategoryTheory.Functor C\u1d52\u1d56 D\ninst\u271d\u00b2 : \u2200 (X : C), HasColimitsOfShape (J.Cover X)\u1d52\u1d56 D\ninst\u271d\u00b9 : \u2200 (X : C), HasColimitsOfShape (J.Cover X)\u1d52\u1d56 E\ninst\u271d : \u2200 (X : C), PreservesColimitsOfShape (J.Cover X)\u1d52\u1d56 F\n\u22a2 CategoryStruct.comp (J.toPlus (P.comp F)) (J.plusCompIso F P).inv = whiskerRight (J.toPlus P) F"}, {"line": "simp [Iso.comp_inv_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Sheaf.isConstant_iff_of_equivalence (F : Sheaf K D) :\n    ((sheafEquiv G J K D).inverse.obj F).IsConstant J \u2194 IsConstant K F := by\n  constructor\n  \u00b7 exact fun \u27e8Y, \u27e8i\u27e9\u27e9 \u21a6 \u27e8_, \u27e8(equivCommuteConstant J D K G hT hT').symm.app _ \u226a\u226b\n      (sheafEquiv G J K D).functor.mapIso i \u226a\u226b (sheafEquiv G J K D).counitIso.app _\u27e9\u27e9\n  \u00b7 exact fun \u27e8Y, \u27e8i\u27e9\u27e9 \u21a6 \u27e8_, \u27e8(equivCommuteConstant' J D K G hT hT').app _ \u226a\u226b\n      (sheafEquiv G J K D).inverse.mapIso i\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/ConstantSheaf.lean", "context": {"open": ["Limits Opposite Category Functor Sheaf Adjunction", "IsDenseSubsite"], "variables": ["{C : Type*} [Category C] (J : GrothendieckTopology C)", "(D : Type*) [Category D]", "[HasWeakSheafify J D]", "{D}", "{C' : Type*} [Category C'] (K : GrothendieckTopology C') [HasWeakSheafify K D]", "(G : C \u2964 C') [\u2200 (X : (C')\u1d52\u1d56), HasLimitsOfShape (StructuredArrow X G.op) D]", "(D) in", "(D) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_1\nSheaf : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nsheafEquiv : x\u271d\u00b9\nx\u271d : Sort u_3\nIsConstant : x\u271d\nF : sorry\n\u22a2 sorry \u2194 sorry"}, {"line": "constructor", "tactic_state": "case mp\nx\u271d\u00b2 : Sort u_1\nSheaf : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nsheafEquiv : x\u271d\u00b9\nx\u271d : Sort u_3\nIsConstant : x\u271d\nF : sorry\n\u22a2 sorry \u2192 sorry\n---\ncase mpr\nx\u271d\u00b2 : Sort u_1\nSheaf : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nsheafEquiv : x\u271d\u00b9\nx\u271d : Sort u_3\nIsConstant : x\u271d\nF : sorry\n\u22a2 sorry \u2192 sorry"}, {"line": "\u00b7 exact fun \u27e8Y, \u27e8i\u27e9\u27e9 \u21a6 \u27e8_, \u27e8(equivCommuteConstant J D K G hT hT').symm.app _ \u226a\u226b\n      (sheafEquiv G J K D).functor.mapIso i \u226a\u226b (sheafEquiv G J K D).counitIso.app _\u27e9\u27e9", "tactic_state": "case mpr\nx\u271d\u00b2 : Sort u_1\nSheaf : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nsheafEquiv : x\u271d\u00b9\nx\u271d : Sort u_3\nIsConstant : x\u271d\nF : sorry\n\u22a2 sorry \u2192 sorry"}, {"line": "\u00b7 exact fun \u27e8Y, \u27e8i\u27e9\u27e9 \u21a6 \u27e8_, \u27e8(equivCommuteConstant' J D K G hT hT').app _ \u226a\u226b\n      (sheafEquiv G J K D).inverse.mapIso i\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem top_covers (S : Sieve X) (f : Y \u27f6 X) : (\u22a4 : GrothendieckTopology C).Covers S f := by\n  simp [covers_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/Grothendieck.lean", "context": {"open": ["Category"], "variables": ["(C : Type u) [Category.{v} C]", "{C}", "{X Y : C} {S R : Sieve X}", "(J : GrothendieckTopology C)", "{J} in", "(C)", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Sieve : ?m.4645\nGrothendieckTopology : ?m.4662\nC : Type ?u.5945\nX Y : C\nS\u271d : sorry\nR : sorry\nJ : sorry\nS : sorry\nf : sorry\n\u22a2 sorry"}, {"line": "simp [covers_iff]", "tactic_state": "Sieve : ?m.4645\nGrothendieckTopology : ?m.4662\nC : Type ?u.5945\nX Y : C\nS\u271d : sorry\nR : sorry\nJ : sorry\nS : sorry\nf : sorry\n\u22a2 sorry ()"}]}
{"declaration": "theorem pullbackCompatible_iff (x : FamilyOfElements P R) [R.hasPullbacks] :\n    x.Compatible \u2194 x.PullbackCompatible := by\n  constructor\n  \u00b7 intro t Y\u2081 Y\u2082 f\u2081 f\u2082 hf\u2081 hf\u2082\n    apply t\n    haveI := hasPullbacks.has_pullbacks hf\u2081 hf\u2082\n    apply pullback.condition\n  \u00b7 intro t Y\u2081 Y\u2082 Z g\u2081 g\u2082 f\u2081 f\u2082 hf\u2081 hf\u2082 comm\n    haveI := hasPullbacks.has_pullbacks hf\u2081 hf\u2082\n    rw [\u2190 pullback.lift_fst _ _ comm]\n    rw [op_comp]\n    rw [FunctorToTypes.map_comp_apply]\n    rw [t hf\u2081 hf\u2082]\n    rw [\u2190 FunctorToTypes.map_comp_apply]\n    rw [\u2190 op_comp]\n    rw [pullback.lift_snd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/IsSheafFor.lean", "context": {"open": ["Opposite CategoryTheory Category Limits Sieve"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{P Q U : C\u1d52\u1d56 \u2964 Type w}", "{X Y : C} {S : Sieve X} {R : Presieve X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nX : C\nR : Presieve X\nx\u271d : Sort u_1\nFamilyOfElements : x\u271d\nx : sorry\ninst\u271d : R.hasPullbacks\n\u22a2 sorry \u2194 sorry"}, {"line": "constructor", "tactic_state": "case mp\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nX : C\nR : Presieve X\nx\u271d : Sort u_1\nFamilyOfElements : x\u271d\nx : sorry\ninst\u271d : R.hasPullbacks\n\u22a2 sorry \u2192 sorry\n---\ncase mpr\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nX : C\nR : Presieve X\nx\u271d : Sort u_1\nFamilyOfElements : x\u271d\nx : sorry\ninst\u271d : R.hasPullbacks\n\u22a2 sorry \u2192 sorry"}, {"line": "\u00b7 intro t Y\u2081 Y\u2082 f\u2081 f\u2082 hf\u2081 hf\u2082\n    apply t\n    haveI := hasPullbacks.has_pullbacks hf\u2081 hf\u2082\n    apply pullback.condition", "tactic_state": "case mpr\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nX : C\nR : Presieve X\nx\u271d : Sort u_1\nFamilyOfElements : x\u271d\nx : sorry\ninst\u271d : R.hasPullbacks\n\u22a2 sorry \u2192 sorry"}, {"line": "\u00b7 intro t Y\u2081 Y\u2082 Z g\u2081 g\u2082 f\u2081 f\u2082 hf\u2081 hf\u2082 comm\n    haveI := hasPullbacks.has_pullbacks hf\u2081 hf\u2082\n    rw [\u2190 pullback.lift_fst _ _ comm]\n    rw [op_comp]\n    rw [FunctorToTypes.map_comp_apply]\n    rw [t hf\u2081 hf\u2082]\n    rw [\u2190 FunctorToTypes.map_comp_apply]\n    rw [\u2190 op_comp]\n    rw [pullback.lift_snd]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isSeparatedFor_iff_generate :\n    IsSeparatedFor P R \u2194 IsSeparatedFor P (generate R : Presieve X) := by\n  constructor\n  \u00b7 intro h x t\u2081 t\u2082 ht\u2081 ht\u2082\n    apply h (x.restrict (le_generate R)) t\u2081 t\u2082 _ _\n    \u00b7 exact isAmalgamation_restrict _ x t\u2081 ht\u2081\n    \u00b7 exact isAmalgamation_restrict _ x t\u2082 ht\u2082\n  \u00b7 intro h x t\u2081 t\u2082 ht\u2081 ht\u2082\n    apply h x.sieveExtend\n    \u00b7 exact isAmalgamation_sieveExtend x t\u2081 ht\u2081\n    \u00b7 exact isAmalgamation_sieveExtend x t\u2082 ht\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/IsSheafFor.lean", "context": {"open": ["Opposite CategoryTheory Category Limits Sieve"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{P Q U : C\u1d52\u1d56 \u2964 Type w}", "{X Y : C} {S : Sieve X} {R : Presieve X}", "{D : Type u\u2082} [Category.{v\u2082} D] (F : D \u2964 C) {Z : D}", "{T : Presieve (F.obj Z)} {x : FamilyOfElements P T}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "FamilyOfElements : ?m.7338\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nP Q U : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nX Y : C\nS : Sieve X\nR : Presieve X\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : CategoryTheory.Functor D C\nZ : D\nT : Presieve (F.obj Z)\nx : sorry\nx\u271d : Sort u_1\nIsSeparatedFor : x\u271d\n\u22a2 sorry \u2194 sorry"}, {"line": "constructor", "tactic_state": "case mp\nFamilyOfElements : ?m.7338\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nP Q U : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nX Y : C\nS : Sieve X\nR : Presieve X\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : CategoryTheory.Functor D C\nZ : D\nT : Presieve (F.obj Z)\nx : sorry\nx\u271d : Sort u_1\nIsSeparatedFor : x\u271d\n\u22a2 sorry \u2192 sorry\n---\ncase mpr\nFamilyOfElements : ?m.7338\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nP Q U : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nX Y : C\nS : Sieve X\nR : Presieve X\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : CategoryTheory.Functor D C\nZ : D\nT : Presieve (F.obj Z)\nx : sorry\nx\u271d : Sort u_1\nIsSeparatedFor : x\u271d\n\u22a2 sorry \u2192 sorry"}, {"line": "\u00b7 intro h x t\u2081 t\u2082 ht\u2081 ht\u2082\n    apply h (x.restrict (le_generate R)) t\u2081 t\u2082 _ _\n    \u00b7 exact isAmalgamation_restrict _ x t\u2081 ht\u2081\n    \u00b7 exact isAmalgamation_restrict _ x t\u2082 ht\u2082", "tactic_state": "case mpr\nFamilyOfElements : ?m.7338\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nP Q U : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nX Y : C\nS : Sieve X\nR : Presieve X\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : CategoryTheory.Functor D C\nZ : D\nT : Presieve (F.obj Z)\nx : sorry\nx\u271d : Sort u_1\nIsSeparatedFor : x\u271d\n\u22a2 sorry \u2192 sorry"}, {"line": "\u00b7 intro h x t\u2081 t\u2082 ht\u2081 ht\u2082\n    apply h x.sieveExtend\n    \u00b7 exact isAmalgamation_sieveExtend x t\u2081 ht\u2081\n    \u00b7 exact isAmalgamation_sieveExtend x t\u2082 ht\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toSheafify_plusPlusIsoSheafify_hom (P : C\u1d52\u1d56 \u2964 D) :\n    J.toSheafify P \u226b (plusPlusIsoSheafify J D P).hom = toSheafify J P := by\n  convert Adjunction.unit_leftAdjointUniq_hom_app\n    (plusPlusAdjunction J D) (sheafificationAdjunction J D) P\n  ext1 P\n  dsimp [GrothendieckTopology.toSheafify, plusPlusAdjunction]\n  rw [Category.comp_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/LeftExact.lean", "context": {"open": ["CategoryTheory Limits Opposite"], "variables": ["{C : Type u} [Category.{v} C] {J : GrothendieckTopology C}", "{D : Type w} [Category.{max v u} D]", "[\u2200 (P : C\u1d52\u1d56 \u2964 D) (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)]", "[\u2200 X : C, HasColimitsOfShape (J.Cover X)\u1d52\u1d56 D]", "[HasForget.{max v u} D]", "[\u2200 X : C, PreservesColimitsOfShape (J.Cover X)\u1d52\u1d56 (forget D)]", "{D : Type w} [Category.{max v u} D]", "[\u2200 (P : C\u1d52\u1d56 \u2964 D) (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)]", "[\u2200 X : C, HasColimitsOfShape (J.Cover X)\u1d52\u1d56 D]", "{FD : D \u2192 D \u2192 Type*} {CD : D \u2192 Type (max v u)}", "[\u2200 X Y, FunLike (FD X Y) (CD X) (CD Y)] [ConcreteCategory.{max v u} D FD]", "[\u2200 X : C, PreservesColimitsOfShape (J.Cover X)\u1d52\u1d56 (forget D)]", "[PreservesLimits (forget D)]", "[(forget D).ReflectsIsomorphisms]", "(K : Type w')", "[SmallCategory K] [FinCategory K] [HasLimitsOfShape K D]", "(J D)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u2078 : Category.{v, u} C\nJ : GrothendieckTopology C\nD : Type w\ninst\u271d\u2077 : Category.{max v u, w} D\ninst\u271d\u2076 : \u2200 (P : CategoryTheory.Functor C\u1d52\u1d56 D) (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)\ninst\u271d\u2075 : \u2200 (X : C), HasColimitsOfShape (J.Cover X)\u1d52\u1d56 D\nFD : D \u2192 D \u2192 Type u_1\nCD : D \u2192 Type (max v u)\ninst\u271d\u2074 : (X Y : D) \u2192 FunLike (FD X Y) (CD X) (CD Y)\ninst\u271d\u00b3 : ConcreteCategory D FD\ninst\u271d\u00b2 : \u2200 (X : C), PreservesColimitsOfShape (J.Cover X)\u1d52\u1d56 (forget D)\ninst\u271d\u00b9 : PreservesLimits (forget D)\ninst\u271d : (forget D).ReflectsIsomorphisms\nP : CategoryTheory.Functor C\u1d52\u1d56 D\n\u22a2 CategoryStruct.comp (J.toSheafify P) (plusPlusIsoSheafify J D P).hom = toSheafify J P"}, {"line": "convert Adjunction.unit_leftAdjointUniq_hom_app\n    (plusPlusAdjunction J D) (sheafificationAdjunction J D) P", "tactic_state": "case h.e'_2.h.h.e'_6.h.h.e\nC : Type u\ninst\u271d\u2078 : Category.{v, u} C\nJ : GrothendieckTopology C\nD : Type w\ninst\u271d\u2077 : Category.{max v u, w} D\ninst\u271d\u2076 : \u2200 (P : CategoryTheory.Functor C\u1d52\u1d56 D) (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)\ninst\u271d\u2075 : \u2200 (X : C), HasColimitsOfShape (J.Cover X)\u1d52\u1d56 D\nFD : D \u2192 D \u2192 Type u_1\nCD : D \u2192 Type (max v u)\ninst\u271d\u2074 : (X Y : D) \u2192 FunLike (FD X Y) (CD X) (CD Y)\ninst\u271d\u00b3 : ConcreteCategory D FD\ninst\u271d\u00b2 : \u2200 (X : C), PreservesColimitsOfShape (J.Cover X)\u1d52\u1d56 (forget D)\ninst\u271d\u00b9 : PreservesLimits (forget D)\ninst\u271d : (forget D).ReflectsIsomorphisms\nP : CategoryTheory.Functor C\u1d52\u1d56 D\ne_1\u271d :\n  (P \u27f6 sheafify J P) =\n    ((Functor.id (CategoryTheory.Functor C\u1d52\u1d56 D)).obj P \u27f6 (sheafToPresheaf J D).obj ((presheafToSheaf J D).obj P))\ne_3\u271d : P = (Functor.id (CategoryTheory.Functor C\u1d52\u1d56 D)).obj P\ne_4\u271d : J.sheafify P = ((plusPlusSheaf J D).comp (sheafToPresheaf J D)).obj P\n\u22a2 J.toSheafify = (plusPlusAdjunction J D).unit.app"}, {"line": "ext1 P", "tactic_state": "case h.e'_2.h.h.e'_6.h.h.e.h\nC : Type u\ninst\u271d\u2078 : Category.{v, u} C\nJ : GrothendieckTopology C\nD : Type w\ninst\u271d\u2077 : Category.{max v u, w} D\ninst\u271d\u2076 : \u2200 (P : CategoryTheory.Functor C\u1d52\u1d56 D) (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)\ninst\u271d\u2075 : \u2200 (X : C), HasColimitsOfShape (J.Cover X)\u1d52\u1d56 D\nFD : D \u2192 D \u2192 Type u_1\nCD : D \u2192 Type (max v u)\ninst\u271d\u2074 : (X Y : D) \u2192 FunLike (FD X Y) (CD X) (CD Y)\ninst\u271d\u00b3 : ConcreteCategory D FD\ninst\u271d\u00b2 : \u2200 (X : C), PreservesColimitsOfShape (J.Cover X)\u1d52\u1d56 (forget D)\ninst\u271d\u00b9 : PreservesLimits (forget D)\ninst\u271d : (forget D).ReflectsIsomorphisms\nP\u271d : CategoryTheory.Functor C\u1d52\u1d56 D\ne_1\u271d :\n  (P\u271d \u27f6 sheafify J P\u271d) =\n    ((Functor.id (CategoryTheory.Functor C\u1d52\u1d56 D)).obj P\u271d \u27f6 (sheafToPresheaf J D).obj ((presheafToSheaf J D).obj P\u271d))\ne_3\u271d : P\u271d = (Functor.id (CategoryTheory.Functor C\u1d52\u1d56 D)).obj P\u271d\ne_4\u271d : J.sheafify P\u271d = ((plusPlusSheaf J D).comp (sheafToPresheaf J D)).obj P\u271d\nP : CategoryTheory.Functor C\u1d52\u1d56 D\n\u22a2 J.toSheafify P = (plusPlusAdjunction J D).unit.app P"}, {"line": "dsimp [GrothendieckTopology.toSheafify, plusPlusAdjunction]", "tactic_state": "case h.e'_2.h.h.e'_6.h.h.e.h\nC : Type u\ninst\u271d\u2078 : Category.{v, u} C\nJ : GrothendieckTopology C\nD : Type w\ninst\u271d\u2077 : Category.{max v u, w} D\ninst\u271d\u2076 : \u2200 (P : CategoryTheory.Functor C\u1d52\u1d56 D) (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)\ninst\u271d\u2075 : \u2200 (X : C), HasColimitsOfShape (J.Cover X)\u1d52\u1d56 D\nFD : D \u2192 D \u2192 Type u_1\nCD : D \u2192 Type (max v u)\ninst\u271d\u2074 : (X Y : D) \u2192 FunLike (FD X Y) (CD X) (CD Y)\ninst\u271d\u00b3 : ConcreteCategory D FD\ninst\u271d\u00b2 : \u2200 (X : C), PreservesColimitsOfShape (J.Cover X)\u1d52\u1d56 (forget D)\ninst\u271d\u00b9 : PreservesLimits (forget D)\ninst\u271d : (forget D).ReflectsIsomorphisms\nP\u271d : CategoryTheory.Functor C\u1d52\u1d56 D\ne_1\u271d :\n  (P\u271d \u27f6 sheafify J P\u271d) =\n    ((Functor.id (CategoryTheory.Functor C\u1d52\u1d56 D)).obj P\u271d \u27f6 (sheafToPresheaf J D).obj ((presheafToSheaf J D).obj P\u271d))\ne_3\u271d : P\u271d = (Functor.id (CategoryTheory.Functor C\u1d52\u1d56 D)).obj P\u271d\ne_4\u271d : J.sheafify P\u271d = ((plusPlusSheaf J D).comp (sheafToPresheaf J D)).obj P\u271d\nP : CategoryTheory.Functor C\u1d52\u1d56 D\n\u22a2 CategoryStruct.comp (J.toPlus P) (J.plusMap (J.toPlus P)) =\n    CategoryStruct.comp (CategoryStruct.comp (J.toPlus P) (J.plusMap (J.toPlus P))) (CategoryStruct.id (J.sheafify P))"}, {"line": "rw [Category.comp_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsSheaf.amalgamate_map {A : Type u\u2082} [Category.{v\u2082} A] {E : A} {X : C} {P : C\u1d52\u1d56 \u2964 A}\n    (hP : Presheaf.IsSheaf J P) (S : J.Cover X) (x : \u2200 I : S.Arrow, E \u27f6 P.obj (op I.Y))\n    (hx : \u2200 \u2983I\u2081 I\u2082 : S.Arrow\u2984 (r : I\u2081.Relation I\u2082),\n       x I\u2081 \u226b P.map r.g\u2081.op = x I\u2082 \u226b P.map r.g\u2082.op)\n    (I : S.Arrow) :\n    hP.amalgamate S x hx \u226b P.map I.f.op = x _ := by\n  apply (hP _ _ S.condition).valid_glue\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/Sheaf.lean", "context": {"open": ["Opposite CategoryTheory Category Limits Sieve", "Presieve Presieve.FamilyOfElements Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{A : Type u\u2082} [Category.{v\u2082} A]", "(J : GrothendieckTopology C)", "(P : C\u1d52\u1d56 \u2964 A) {X : C} (S : Sieve X) (R : Presieve X) (E : A\u1d52\u1d56)", "{P S E}", "{x : FamilyOfElements (P \u22d9 coyoneda.obj E) S.arrows} (hx : SieveCompatible x)", "(P S)", "{J}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nJ : GrothendieckTopology C\nA : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} A\nE : A\nX : C\nP : CategoryTheory.Functor C\u1d52\u1d56 A\nhP : Presheaf.IsSheaf J P\nS : J.Cover X\nx : (I : S.Arrow) \u2192 E \u27f6 P.obj (op I.Y)\nhx :\n  \u2200 \u2983I\u2081 I\u2082 : S.Arrow\u2984 (r : I\u2081.Relation I\u2082),\n    CategoryStruct.comp (x I\u2081) (P.map r.g\u2081.op) = CategoryStruct.comp (x I\u2082) (P.map r.g\u2082.op)\nI : S.Arrow\n\u22a2 CategoryStruct.comp (hP.amalgamate S x hx) (P.map I.f.op) = x I"}, {"line": "apply (hP _ _ S.condition).valid_glue", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Presheaf.IsSheaf.isSheafFor {P : C\u1d52\u1d56 \u2964 Type w} (hP : Presheaf.IsSheaf J P)\n    {X : C} (S : Sieve X) (hS : S \u2208 J X) : Presieve.IsSheafFor P S.arrows := by\n  rw [isSheaf_iff_isSheaf_of_type] at hP\n  exact hP S hS\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/Sheaf.lean", "context": {"open": ["Opposite CategoryTheory Category Limits Sieve", "Presieve Presieve.FamilyOfElements Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{A : Type u\u2082} [Category.{v\u2082} A]", "(J : GrothendieckTopology C)", "(P : C\u1d52\u1d56 \u2964 A) {X : C} (S : Sieve X) (R : Presieve X) (E : A\u1d52\u1d56)", "{P S E}", "{x : FamilyOfElements (P \u22d9 coyoneda.obj E) S.arrows} (hx : SieveCompatible x)", "(P S)", "{J}", "{P : C\u1d52\u1d56 \u2964 A} (hP : Presheaf.IsSheaf J P) {I : Type*} {S : C} {X : I \u2192 C}", "(J)", "{C : Type u\u2081} [Category.{v\u2081} C]", "(J : GrothendieckTopology C)", "(A : Type u\u2082) [Category.{v\u2082} A]", "{J A}", "{J A} in", "{J} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nJ : GrothendieckTopology C\nP : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nhP : Presheaf.IsSheaf J P\nX : C\nS : Sieve X\nhS : S \u2208 J X\n\u22a2 IsSheafFor P S.arrows"}, {"line": "rw [isSheaf_iff_isSheaf_of_type] at hP", "tactic_state": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nJ : GrothendieckTopology C\nP : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nhP : IsSheaf J P\nX : C\nS : Sieve X\nhS : S \u2208 J X\n\u22a2 IsSheafFor P S.arrows"}, {"line": "exact hP S hS", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isSheaf_iff_isSheaf_comp (s : A \u2964 B) [HasLimitsOfSize.{v\u2081, max v\u2081 u\u2081} A]\n    [PreservesLimitsOfSize.{v\u2081, max v\u2081 u\u2081} s] [s.ReflectsIsomorphisms] :\n    IsSheaf J P \u2194 IsSheaf J (P \u22d9 s) := by\n  letI : ReflectsLimitsOfSize s := reflectsLimits_of_reflectsIsomorphisms\n  exact \u27e8isSheaf_comp_of_isSheaf J P s, isSheaf_of_isSheaf_comp J P s\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/Sheaf.lean", "context": {"open": ["Opposite CategoryTheory Category Limits Sieve", "Presieve Presieve.FamilyOfElements Limits", "Preadditive", "Opposite CategoryTheory Category Limits Sieve"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{A : Type u\u2082} [Category.{v\u2082} A]", "(J : GrothendieckTopology C)", "(P : C\u1d52\u1d56 \u2964 A) {X : C} (S : Sieve X) (R : Presieve X) (E : A\u1d52\u1d56)", "{P S E}", "{x : FamilyOfElements (P \u22d9 coyoneda.obj E) S.arrows} (hx : SieveCompatible x)", "(P S)", "{J}", "{P : C\u1d52\u1d56 \u2964 A} (hP : Presheaf.IsSheaf J P) {I : Type*} {S : C} {X : I \u2192 C}", "(J)", "{C : Type u\u2081} [Category.{v\u2081} C]", "(J : GrothendieckTopology C)", "(A : Type u\u2082) [Category.{v\u2082} A]", "{J A}", "{J A} in", "{J} in", "{A} in", "{J} {A}", "[Preadditive A] {P Q : Sheaf J A}", "{C : Type u\u2081} [Category.{v\u2081} C]", "{A : Type u\u2082} [Category.{v\u2082} A]", "{A' : Type u\u2082} [Category.{max v\u2081 u\u2081} A']", "{B : Type u\u2083} [Category.{v\u2083} B]", "(J : GrothendieckTopology C)", "{U : C} (R : Presieve U)", "(P : C\u1d52\u1d56 \u2964 A) (P' : C\u1d52\u1d56 \u2964 A')", "{J P} in", "[HasProducts.{max u\u2081 v\u2081} A]", "[HasProducts.{max u\u2081 v\u2081} A']", "[HasPullbacks C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2076 : Category.{v\u2081, u\u2081} C\nA : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} A\nB : Type u\u2083\ninst\u271d\u2074 : Category.{v\u2083, u\u2083} B\nJ : GrothendieckTopology C\nP : CategoryTheory.Functor C\u1d52\u1d56 A\ninst\u271d\u00b3 : HasPullbacks C\ns : CategoryTheory.Functor A B\ninst\u271d\u00b2 : HasLimitsOfSize.{v\u2081, max v\u2081 u\u2081, v\u2082, u\u2082} A\ninst\u271d\u00b9 : PreservesLimitsOfSize.{v\u2081, max v\u2081 u\u2081, v\u2082, v\u2083, u\u2082, u\u2083} s\ninst\u271d : s.ReflectsIsomorphisms\n\u22a2 IsSheaf J sorry \u2194 IsSheaf J (P.comp sorry)"}, {"line": "letI : ReflectsLimitsOfSize s := reflectsLimits_of_reflectsIsomorphisms", "tactic_state": "C : Type u\u2081\ninst\u271d\u2076 : Category.{v\u2081, u\u2081} C\nA : Type u\u2082\ninst\u271d\u2075 : Category.{v\u2082, u\u2082} A\nB : Type u\u2083\ninst\u271d\u2074 : Category.{v\u2083, u\u2083} B\nJ : GrothendieckTopology C\nP : CategoryTheory.Functor C\u1d52\u1d56 A\ninst\u271d\u00b3 : HasPullbacks C\ns : CategoryTheory.Functor A B\ninst\u271d\u00b2 : HasLimitsOfSize.{v\u2081, max v\u2081 u\u2081, v\u2082, u\u2082} A\ninst\u271d\u00b9 : PreservesLimitsOfSize.{v\u2081, max v\u2081 u\u2081, v\u2082, v\u2083, u\u2082, u\u2083} s\ninst\u271d : s.ReflectsIsomorphisms\nthis : sorry := sorry\n\u22a2 IsSheaf J sorry \u2194 IsSheaf J (P.comp sorry)"}, {"line": "exact \u27e8isSheaf_comp_of_isSheaf J P s, isSheaf_of_isSheaf_comp J P s\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isSheaf_iff_isSheaf_forget (s : A' \u2964 Type max v\u2081 u\u2081) [HasLimits A'] [PreservesLimits s]\n    [s.ReflectsIsomorphisms] : IsSheaf J P' \u2194 IsSheaf J (P' \u22d9 s) := by\n  have : HasLimitsOfSize.{v\u2081, max v\u2081 u\u2081} A' := hasLimitsOfSizeShrink.{_, _, u\u2081, 0} A'\n  have : PreservesLimitsOfSize.{v\u2081, max v\u2081 u\u2081} s := preservesLimitsOfSize_shrink.{_, 0, _, u\u2081} s\n  apply isSheaf_iff_isSheaf_comp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/Sheaf.lean", "context": {"open": ["Opposite CategoryTheory Category Limits Sieve", "Presieve Presieve.FamilyOfElements Limits", "Preadditive", "Opposite CategoryTheory Category Limits Sieve"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C]", "{A : Type u\u2082} [Category.{v\u2082} A]", "(J : GrothendieckTopology C)", "(P : C\u1d52\u1d56 \u2964 A) {X : C} (S : Sieve X) (R : Presieve X) (E : A\u1d52\u1d56)", "{P S E}", "{x : FamilyOfElements (P \u22d9 coyoneda.obj E) S.arrows} (hx : SieveCompatible x)", "(P S)", "{J}", "{P : C\u1d52\u1d56 \u2964 A} (hP : Presheaf.IsSheaf J P) {I : Type*} {S : C} {X : I \u2192 C}", "(J)", "{C : Type u\u2081} [Category.{v\u2081} C]", "(J : GrothendieckTopology C)", "(A : Type u\u2082) [Category.{v\u2082} A]", "{J A}", "{J A} in", "{J} in", "{A} in", "{J} {A}", "[Preadditive A] {P Q : Sheaf J A}", "{C : Type u\u2081} [Category.{v\u2081} C]", "{A : Type u\u2082} [Category.{v\u2082} A]", "{A' : Type u\u2082} [Category.{max v\u2081 u\u2081} A']", "{B : Type u\u2083} [Category.{v\u2083} B]", "(J : GrothendieckTopology C)", "{U : C} (R : Presieve U)", "(P : C\u1d52\u1d56 \u2964 A) (P' : C\u1d52\u1d56 \u2964 A')", "{J P} in", "[HasProducts.{max u\u2081 v\u2081} A]", "[HasProducts.{max u\u2081 v\u2081} A']", "[HasPullbacks C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u2076 : Category.{v\u2081, u\u2081} C\nA' : Type u\u2082\ninst\u271d\u2075 : Category.{max v\u2081 u\u2081, u\u2082} A'\nJ : GrothendieckTopology C\nP' : CategoryTheory.Functor C\u1d52\u1d56 A'\ninst\u271d\u2074 : HasProducts A'\ninst\u271d\u00b3 : HasPullbacks C\ns : CategoryTheory.Functor A' (Type (max v\u2081 u\u2081))\ninst\u271d\u00b2 : HasLimits A'\ninst\u271d\u00b9 : PreservesLimits s\ninst\u271d : s.ReflectsIsomorphisms\n\u22a2 IsSheaf J sorry \u2194 IsSheaf J (P'.comp s)"}, {"line": "have : HasLimitsOfSize.{v\u2081, max v\u2081 u\u2081} A' := hasLimitsOfSizeShrink.{_, _, u\u2081, 0} A'", "tactic_state": "C : Type u\u2081\ninst\u271d\u2076 : Category.{v\u2081, u\u2081} C\nA' : Type u\u2082\ninst\u271d\u2075 : Category.{max v\u2081 u\u2081, u\u2082} A'\nJ : GrothendieckTopology C\nP' : CategoryTheory.Functor C\u1d52\u1d56 A'\ninst\u271d\u2074 : HasProducts A'\ninst\u271d\u00b3 : HasPullbacks C\ns : CategoryTheory.Functor A' (Type (max v\u2081 u\u2081))\ninst\u271d\u00b2 : HasLimits A'\ninst\u271d\u00b9 : PreservesLimits s\ninst\u271d : s.ReflectsIsomorphisms\nthis : sorry\n\u22a2 IsSheaf J sorry \u2194 IsSheaf J (P'.comp s)"}, {"line": "have : PreservesLimitsOfSize.{v\u2081, max v\u2081 u\u2081} s := preservesLimitsOfSize_shrink.{_, 0, _, u\u2081} s", "tactic_state": "C : Type u\u2081\ninst\u271d\u2076 : Category.{v\u2081, u\u2081} C\nA' : Type u\u2082\ninst\u271d\u2075 : Category.{max v\u2081 u\u2081, u\u2082} A'\nJ : GrothendieckTopology C\nP' : CategoryTheory.Functor C\u1d52\u1d56 A'\ninst\u271d\u2074 : HasProducts A'\ninst\u271d\u00b3 : HasPullbacks C\ns : CategoryTheory.Functor A' (Type (max v\u2081 u\u2081))\ninst\u271d\u00b2 : HasLimits A'\ninst\u271d\u00b9 : PreservesLimits s\ninst\u271d : s.ReflectsIsomorphisms\nthis\u271d : sorry\nthis : sorry\n\u22a2 IsSheaf J sorry \u2194 IsSheaf J (P'.comp s)"}, {"line": "apply isSheaf_iff_isSheaf_comp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_sieves_of_hasEffectiveEpi (S : Sieve X) :\n    (\u2203 (Y : C) (\u03c0 : Y \u27f6 X), EffectiveEpi \u03c0 \u2227 S.arrows \u03c0) \u2192 (S \u2208 (regularTopology C) X) := by\n  rintro \u27e8Y, \u03c0, h\u27e9\n  have h_le : Sieve.generate (Presieve.ofArrows (fun () \u21a6 Y) (fun _ \u21a6 \u03c0)) \u2264 S := by\n    rw [Sieve.generate_le_iff (Presieve.ofArrows _ _) S]\n    apply Presieve.le_of_factorsThru_sieve (Presieve.ofArrows _ _) S _\n    intro W g f\n    refine \u27e8W, \ud835\udfd9 W, ?_\u27e9\n    cases f\n    exact \u27e8\u03c0, \u27e8h.2, Category.id_comp \u03c0\u27e9\u27e9\n  apply Coverage.saturate_of_superset (regularCoverage C) h_le\n  exact Coverage.Saturate.of X _ \u27e8Y, \u03c0, rfl, h.1\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Sites/Coherent/RegularTopology.lean", "context": {"open": ["Limits"], "variables": ["{C : Type*} [Category C] [Preregular C] {X : C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_1\nSieve : x\u271d\u00b2\nC : Type u_2\nX : C\nx\u271d\u00b9 : Sort u_3\nEffectiveEpi : x\u271d\u00b9\nx\u271d : Sort u_4\nregularTopology : x\u271d\nS : sorry\n\u22a2 (\u2203 Y \u03c0, sorry \u2227 sorry) \u2192 S \u2208 sorry"}, {"line": "rintro \u27e8Y, \u03c0, h\u27e9", "tactic_state": "case intro.intro\nx\u271d\u00b2 : Sort u_1\nSieve : x\u271d\u00b2\nC : Type u_2\nX : C\nx\u271d\u00b9 : Sort u_3\nEffectiveEpi : x\u271d\u00b9\nx\u271d : Sort u_4\nregularTopology : x\u271d\nS : sorry\nY : C\n\u03c0 : sorry\nh : sorry \u2227 sorry\n\u22a2 S \u2208 sorry"}, {"line": "have h_le : Sieve.generate (Presieve.ofArrows (fun () \u21a6 Y) (fun _ \u21a6 \u03c0)) \u2264 S := sorry", "tactic_state": "case intro.intro\nx\u271d\u00b2 : Sort u_1\nSieve : x\u271d\u00b2\nC : Type u_2\nX : C\nx\u271d\u00b9 : Sort u_3\nEffectiveEpi : x\u271d\u00b9\nx\u271d : Sort u_4\nregularTopology : x\u271d\nS : sorry\nY : C\n\u03c0 : sorry\nh : sorry \u2227 sorry\nh_le : sorry\n\u22a2 S \u2208 sorry"}, {"line": "apply Coverage.saturate_of_superset (regularCoverage C) h_le", "tactic_state": "\u22a2 {Sieve : ?m.15} \u2192 {C : Type u_2} \u2192 {X : C} \u2192 {EffectiveEpi : ?m.457} \u2192 {regularTopology : ?m.941} \u2192 sorry \u2192 Type u_7\n---\n\u22a2 {Sieve : ?m.15} \u2192\n    {C : Type u_2} \u2192\n      {X : C} \u2192 {EffectiveEpi : ?m.457} \u2192 {regularTopology : ?m.941} \u2192 (S : sorry) \u2192 Membership sorry (?m.3626 S)"}, {"line": "exact Coverage.Saturate.of X _ \u27e8Y, \u03c0, rfl, h.1\u27e9", "tactic_state": "\u22a2 {Sieve : ?m.15} \u2192\n    {C : Type u_2} \u2192\n      {X : C} \u2192 {EffectiveEpi : ?m.4027} \u2192 {regularTopology : ?m.4028} \u2192 (S : sorry) \u2192 Membership sorry (sorry S)"}]}
{"declaration": "lemma sectionsMk_val_op_bot (val\u2080 : F.obj (op \u22a5)) :\n    (d.sectionsMk val\u2080).val (op \u22a5) = val\u2080 := by\n  simpa using (default : d.Extension val\u2080 \u22a5).map_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/SmallObject/WellOrderInductionData.lean", "context": {"open": ["Opposite"], "variables": ["{J : Type u} [LinearOrder J] [SuccOrder J]", "{F} (d : F.WellOrderInductionData) [OrderBot J]", "{d} {val\u2080 : F.obj (op \u22a5)}", "(d val\u2080) in", "[WellFoundedLT J]", "[WellFoundedLT J]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "val\u2080 : sorry\n\u22a2 sorry = val\u2080"}, {"line": "simpa using (default : d.Extension val\u2080 \u22a5).map_zero", "tactic_state": "No Goals!"}]}
{"declaration": "lemma arrowMap_extendToSucc (i\u2081 i\u2082 : J) (hi : i\u2081 \u2264 i\u2082) (hi\u2082 : i\u2082 \u2264 j) :\n    arrowMap (extendToSucc hj F \u03c4) i\u2081 i\u2082 hi (hi\u2082.trans (Order.le_succ j)) =\n      arrowMap F i\u2081 i\u2082 hi hi\u2082 := by\n  simp [arrowMap, extendToSucc_map hj F \u03c4 i\u2081 i\u2082 hi hi\u2082,\n    extendToSuccObjIso, extendToSucc.objIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/SmallObject/Iteration/ExtendToSucc.lean", "context": {"open": ["Category", "extendToSucc in"], "variables": ["{C : Type*} [Category C]", "(X)", "{X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Type u_1\nj : J\nx\u271d : Sort u_2\narrowMap : x\u271d\ni\u2081 i\u2082 : J\nhi : sorry\nhi\u2082 : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [arrowMap, extendToSucc_map hj F \u03c4 i\u2081 i\u2082 hi hi\u2082,\n    extendToSuccObjIso, extendToSucc.objIso]", "tactic_state": "J : Type u_1\nj : J\nx\u271d : Sort u_2\narrowMap : x\u271d\ni\u2081 i\u2082 : J\nhi : sorry\nhi\u2082 : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma arrowSucc_extendToSucc :\n    arrowSucc (extendToSucc hj F \u03c4) j (Order.lt_succ_of_not_isMax hj) =\n      Arrow.mk \u03c4 := by\n  simp [arrowSucc, arrowMap, extendToSucc_map_le_succ, extendToSuccObjIso,\n    extendToSucc.objIso, extendToSuccObjSuccIso, extendToSucc.objSuccIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/SmallObject/Iteration/ExtendToSucc.lean", "context": {"open": ["Category", "extendToSucc in"], "variables": ["{C : Type*} [Category C]", "(X)", "{X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\narrowSucc : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [arrowSucc, arrowMap, extendToSucc_map_le_succ, extendToSuccObjIso,\n    extendToSucc.objIso, extendToSuccObjSuccIso, extendToSucc.objSuccIso]", "tactic_state": "x\u271d : Sort u_1\narrowSucc : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem factorThru_zero [HasZeroMorphisms C] {X Y : C} {P : Subobject Y}\n    (h : P.Factors (0 : X \u27f6 Y)) : P.factorThru 0 h = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/FactorThru.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {X Y Z : C}", "{D : Type u\u2082} [Category.{v\u2082} D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : HasZeroMorphisms C\nX Y : C\nP : Subobject Y\nh : P.Factors 0\n\u22a2 P.factorThru 0 h = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem equalizerSubobject_arrow :\n    (equalizerSubobjectIso f g).hom \u226b equalizer.\u03b9 f g = (equalizerSubobject f g).arrow := by\n  simp [equalizerSubobjectIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y : C\nf g : X \u27f6 Y\ninst\u271d : HasEqualizer f g\n\u22a2 CategoryStruct.comp (equalizerSubobjectIso f g).hom (equalizer.\u03b9 f g) = (equalizerSubobject f g).arrow"}, {"line": "simp [equalizerSubobjectIso]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem equalizerSubobject_arrow' :\n    (equalizerSubobjectIso f g).inv \u226b (equalizerSubobject f g).arrow = equalizer.\u03b9 f g := by\n  simp [equalizerSubobjectIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y : C\nf g : X \u27f6 Y\ninst\u271d : HasEqualizer f g\n\u22a2 CategoryStruct.comp (equalizerSubobjectIso f g).inv (equalizerSubobject f g).arrow = equalizer.\u03b9 f g"}, {"line": "simp [equalizerSubobjectIso]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem equalizerSubobject_arrow_comp :\n    (equalizerSubobject f g).arrow \u226b f = (equalizerSubobject f g).arrow \u226b g := by\n  rw [\u2190 equalizerSubobject_arrow]\n  rw [Category.assoc]\n  rw [Category.assoc]\n  rw [equalizer.condition]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y : C\nf g : X \u27f6 Y\ninst\u271d : HasEqualizer f g\n\u22a2 CategoryStruct.comp (equalizerSubobject f g).arrow f = CategoryStruct.comp (equalizerSubobject f g).arrow g"}, {"line": "rw [\u2190 equalizerSubobject_arrow]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y : C\nf g : X \u27f6 Y\ninst\u271d : HasEqualizer f g\n\u22a2 CategoryStruct.comp (CategoryStruct.comp (equalizerSubobjectIso f g).hom (equalizer.\u03b9 f g)) f =\n    CategoryStruct.comp (CategoryStruct.comp (equalizerSubobjectIso f g).hom (equalizer.\u03b9 f g)) g"}, {"line": "rw [Category.assoc]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y : C\nf g : X \u27f6 Y\ninst\u271d : HasEqualizer f g\n\u22a2 CategoryStruct.comp (equalizerSubobjectIso f g).hom (CategoryStruct.comp (equalizer.\u03b9 f g) f) =\n    CategoryStruct.comp (CategoryStruct.comp (equalizerSubobjectIso f g).hom (equalizer.\u03b9 f g)) g"}, {"line": "rw [Category.assoc]", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y : C\nf g : X \u27f6 Y\ninst\u271d : HasEqualizer f g\n\u22a2 CategoryStruct.comp (equalizerSubobjectIso f g).hom (CategoryStruct.comp (equalizer.\u03b9 f g) f) =\n    CategoryStruct.comp (equalizerSubobjectIso f g).hom (CategoryStruct.comp (equalizer.\u03b9 f g) g)"}, {"line": "rw [equalizer.condition]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem kernelSubobject_arrow :\n    (kernelSubobjectIso f).hom \u226b kernel.\u03b9 f = (kernelSubobject f).arrow := by\n  simp [kernelSubobjectIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]", "[HasZeroMorphisms C] (f : X \u27f6 Y) [HasKernel f]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b9 : HasZeroMorphisms C\nf : X \u27f6 Y\ninst\u271d : HasKernel f\n\u22a2 CategoryStruct.comp (kernelSubobjectIso f).hom (kernel.\u03b9 f) = (kernelSubobject f).arrow"}, {"line": "simp [kernelSubobjectIso]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem kernelSubobject_arrow' :\n    (kernelSubobjectIso f).inv \u226b (kernelSubobject f).arrow = kernel.\u03b9 f := by\n  simp [kernelSubobjectIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]", "[HasZeroMorphisms C] (f : X \u27f6 Y) [HasKernel f]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b9 : HasZeroMorphisms C\nf : X \u27f6 Y\ninst\u271d : HasKernel f\n\u22a2 CategoryStruct.comp (kernelSubobjectIso f).inv (kernelSubobject f).arrow = kernel.\u03b9 f"}, {"line": "simp [kernelSubobjectIso]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem kernelSubobject_arrow_comp : (kernelSubobject f).arrow \u226b f = 0 := by\n  rw [\u2190 kernelSubobject_arrow]\n  simp only [Category.assoc]\n  simp only [kernel.condition]\n  simp only [comp_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]", "[HasZeroMorphisms C] (f : X \u27f6 Y) [HasKernel f]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b9 : HasZeroMorphisms C\nf : X \u27f6 Y\ninst\u271d : HasKernel f\n\u22a2 CategoryStruct.comp (kernelSubobject f).arrow f = 0"}, {"line": "rw [\u2190 kernelSubobject_arrow]", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b9 : HasZeroMorphisms C\nf : X \u27f6 Y\ninst\u271d : HasKernel f\n\u22a2 CategoryStruct.comp (CategoryStruct.comp (kernelSubobjectIso f).hom (kernel.\u03b9 f)) f = 0"}, {"line": "simp only [Category.assoc]", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b9 : HasZeroMorphisms C\nf : X \u27f6 Y\ninst\u271d : HasKernel f\n\u22a2 CategoryStruct.comp (kernelSubobjectIso f).hom (CategoryStruct.comp (kernel.\u03b9 f) f) = 0"}, {"line": "simp only [kernel.condition]", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b9 : HasZeroMorphisms C\nf : X \u27f6 Y\ninst\u271d : HasKernel f\n\u22a2 CategoryStruct.comp (kernelSubobjectIso f).hom 0 = 0"}, {"line": "simp only [comp_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorThruKernelSubobject_comp_arrow {W : C} (h : W \u27f6 X) (w : h \u226b f = 0) :\n    factorThruKernelSubobject f h w \u226b (kernelSubobject f).arrow = h := by\n  dsimp [factorThruKernelSubobject]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]", "[HasZeroMorphisms C] (f : X \u27f6 Y) [HasKernel f]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b9 : HasZeroMorphisms C\nf : X \u27f6 Y\ninst\u271d : HasKernel f\nW : C\nh : W \u27f6 X\nw : CategoryStruct.comp h f = 0\n\u22a2 CategoryStruct.comp (factorThruKernelSubobject f h w) (kernelSubobject f).arrow = h"}, {"line": "dsimp [factorThruKernelSubobject]", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b9 : HasZeroMorphisms C\nf : X \u27f6 Y\ninst\u271d : HasKernel f\nW : C\nh : W \u27f6 X\nw : CategoryStruct.comp h f = 0\n\u22a2 CategoryStruct.comp ((kernelSubobject f).factorThru h \u22ef) (kernelSubobject f).arrow = h"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem kernelSubobjectMap_arrow (sq : Arrow.mk f \u27f6 Arrow.mk f') :\n    kernelSubobjectMap sq \u226b (kernelSubobject f').arrow = (kernelSubobject f).arrow \u226b sq.left := by\n  simp [kernelSubobjectMap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]", "[HasZeroMorphisms C] (f : X \u27f6 Y) [HasKernel f]", "{f} {X' Y' : C} {f' : X' \u27f6 Y'} [HasKernel f']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b2 : HasZeroMorphisms C\nf : X \u27f6 Y\ninst\u271d\u00b9 : HasKernel f\nX' Y' : C\nf' : X' \u27f6 Y'\ninst\u271d : HasKernel f'\nsq : Arrow.mk f \u27f6 Arrow.mk f'\n\u22a2 CategoryStruct.comp (kernelSubobjectMap sq) (kernelSubobject f').arrow =\n    CategoryStruct.comp (kernelSubobject f).arrow sq.left"}, {"line": "simp [kernelSubobjectMap]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem kernelSubobjectMap_id : kernelSubobjectMap (\ud835\udfd9 (Arrow.mk f)) = \ud835\udfd9 _ := by aesop_cat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]", "[HasZeroMorphisms C] (f : X \u27f6 Y) [HasKernel f]", "{f} {X' Y' : C} {f' : X' \u27f6 Y'} [HasKernel f']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b9 : HasZeroMorphisms C\nf : X \u27f6 Y\ninst\u271d : HasKernel f\n\u22a2 kernelSubobjectMap (CategoryStruct.id (Arrow.mk f)) = CategoryStruct.id (underlying.obj (kernelSubobject f))"}, {"line": "aesop_cat", "tactic_state": "No Goals!"}]}
{"declaration": "theorem kernelSubobjectMap_comp {X'' Y'' : C} {f'' : X'' \u27f6 Y''} [HasKernel f'']\n    (sq : Arrow.mk f \u27f6 Arrow.mk f') (sq' : Arrow.mk f' \u27f6 Arrow.mk f'') :\n    kernelSubobjectMap (sq \u226b sq') = kernelSubobjectMap sq \u226b kernelSubobjectMap sq' := by\n  aesop_cat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]", "[HasZeroMorphisms C] (f : X \u27f6 Y) [HasKernel f]", "{f} {X' Y' : C} {f' : X' \u27f6 Y'} [HasKernel f']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u2074 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b3 : HasZeroMorphisms C\nf : X \u27f6 Y\ninst\u271d\u00b2 : HasKernel f\nX' Y' : C\nf' : X' \u27f6 Y'\ninst\u271d\u00b9 : HasKernel f'\nX'' Y'' : C\nf'' : X'' \u27f6 Y''\ninst\u271d : HasKernel f''\nsq : Arrow.mk f \u27f6 Arrow.mk f'\nsq' : Arrow.mk f' \u27f6 Arrow.mk f''\n\u22a2 kernelSubobjectMap (CategoryStruct.comp sq sq') = CategoryStruct.comp (kernelSubobjectMap sq) (kernelSubobjectMap sq')"}, {"line": "aesop_cat", "tactic_state": "No Goals!"}]}
{"declaration": "theorem kernelSubobjectIso_comp_kernel_map (sq : Arrow.mk f \u27f6 Arrow.mk f') :\n    (kernelSubobjectIso _).hom \u226b kernel.map f f' sq.1 sq.2 sq.3.symm =\n      kernelSubobjectMap sq \u226b (kernelSubobjectIso _).hom := by\n  simp [\u2190 Iso.comp_inv_eq, kernel_map_comp_kernelSubobjectIso_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]", "[HasZeroMorphisms C] (f : X \u27f6 Y) [HasKernel f]", "{f} {X' Y' : C} {f' : X' \u27f6 Y'} [HasKernel f']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b2 : HasZeroMorphisms C\nf : X \u27f6 Y\ninst\u271d\u00b9 : HasKernel f\nX' Y' : C\nf' : X' \u27f6 Y'\ninst\u271d : HasKernel f'\nsq : Arrow.mk f \u27f6 Arrow.mk f'\n\u22a2 CategoryStruct.comp (kernelSubobjectIso f).hom (kernel.map f f' sq.left sq.right \u22ef) =\n    CategoryStruct.comp (kernelSubobjectMap sq) (kernelSubobjectIso f').hom"}, {"line": "simp [\u2190 Iso.comp_inv_eq, kernel_map_comp_kernelSubobjectIso_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem kernelSubobjectIsoComp_hom_arrow {X' : C} (f : X' \u27f6 X) [IsIso f] (g : X \u27f6 Y) [HasKernel g] :\n    (kernelSubobjectIsoComp f g).hom \u226b (kernelSubobject g).arrow =\n      (kernelSubobject (f \u226b g)).arrow \u226b f := by\n  simp [kernelSubobjectIsoComp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]", "[HasZeroMorphisms C] (f : X \u27f6 Y) [HasKernel f]", "{f} {X' Y' : C} {f' : X' \u27f6 Y'} [HasKernel f']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b2 : HasZeroMorphisms C\nX' : C\nf : X' \u27f6 X\ninst\u271d\u00b9 : IsIso f\ng : X \u27f6 Y\ninst\u271d : HasKernel g\n\u22a2 CategoryStruct.comp (kernelSubobjectIsoComp f g).hom (kernelSubobject g).arrow =\n    CategoryStruct.comp (kernelSubobject (CategoryStruct.comp f g)).arrow f"}, {"line": "simp [kernelSubobjectIsoComp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem kernelSubobjectIsoComp_inv_arrow {X' : C} (f : X' \u27f6 X) [IsIso f] (g : X \u27f6 Y) [HasKernel g] :\n    (kernelSubobjectIsoComp f g).inv \u226b (kernelSubobject (f \u226b g)).arrow =\n      (kernelSubobject g).arrow \u226b inv f := by\n  simp [kernelSubobjectIsoComp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]", "[HasZeroMorphisms C] (f : X \u27f6 Y) [HasKernel f]", "{f} {X' Y' : C} {f' : X' \u27f6 Y'} [HasKernel f']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b2 : HasZeroMorphisms C\nX' : C\nf : X' \u27f6 X\ninst\u271d\u00b9 : IsIso f\ng : X \u27f6 Y\ninst\u271d : HasKernel g\n\u22a2 CategoryStruct.comp (kernelSubobjectIsoComp f g).inv (kernelSubobject (CategoryStruct.comp f g)).arrow =\n    CategoryStruct.comp (kernelSubobject g).arrow (inv f)"}, {"line": "simp [kernelSubobjectIsoComp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem imageSubobject_arrow :\n    (imageSubobjectIso f).hom \u226b image.\u03b9 f = (imageSubobject f).arrow := by simp [imageSubobjectIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]", "[HasZeroMorphisms C] (f : X \u27f6 Y) [HasKernel f]", "{f} {X' Y' : C} {f' : X' \u27f6 Y'} [HasKernel f']", "(f : X \u27f6 Y) [HasImage f]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b9 : HasZeroMorphisms C\nf : X \u27f6 Y\ninst\u271d : HasImage f\n\u22a2 CategoryStruct.comp (imageSubobjectIso f).hom (image.\u03b9 f) = (imageSubobject f).arrow"}, {"line": "simp [imageSubobjectIso]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem imageSubobject_arrow' :\n    (imageSubobjectIso f).inv \u226b (imageSubobject f).arrow = image.\u03b9 f := by simp [imageSubobjectIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]", "[HasZeroMorphisms C] (f : X \u27f6 Y) [HasKernel f]", "{f} {X' Y' : C} {f' : X' \u27f6 Y'} [HasKernel f']", "(f : X \u27f6 Y) [HasImage f]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b9 : HasZeroMorphisms C\nf : X \u27f6 Y\ninst\u271d : HasImage f\n\u22a2 CategoryStruct.comp (imageSubobjectIso f).inv (imageSubobject f).arrow = image.\u03b9 f"}, {"line": "simp [imageSubobjectIso]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem imageSubobject_arrow_comp : factorThruImageSubobject f \u226b (imageSubobject f).arrow = f := by\n  simp [factorThruImageSubobject, imageSubobject_arrow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]", "[HasZeroMorphisms C] (f : X \u27f6 Y) [HasKernel f]", "{f} {X' Y' : C} {f' : X' \u27f6 Y'} [HasKernel f']", "(f : X \u27f6 Y) [HasImage f]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b9 : HasZeroMorphisms C\nf : X \u27f6 Y\ninst\u271d : HasImage f\n\u22a2 CategoryStruct.comp (factorThruImageSubobject f) (imageSubobject f).arrow = f"}, {"line": "simp [factorThruImageSubobject, imageSubobject_arrow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem imageSubobject_zero_arrow : (imageSubobject (0 : X \u27f6 Y)).arrow = 0 := by\n  rw [\u2190 imageSubobject_arrow]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite", "ZeroObject"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]", "[HasZeroMorphisms C] (f : X \u27f6 Y) [HasKernel f]", "{f} {X' Y' : C} {f' : X' \u27f6 Y'} [HasKernel f']", "(f : X \u27f6 Y) [HasImage f]", "[HasZeroMorphisms C] [HasZeroObject C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b2 inst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasZeroObject C\n\u22a2 (imageSubobject 0).arrow = 0"}, {"line": "rw [\u2190 imageSubobject_arrow]", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b2 inst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasZeroObject C\n\u22a2 CategoryStruct.comp (imageSubobjectIso 0).hom (image.\u03b9 0) = 0"}, {"line": "simp", "tactic_state": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nX Y : C\ninst\u271d\u00b2 inst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasZeroObject C\n\u22a2 (imageSubobject 0).arrow = 0"}]}
{"declaration": "theorem imageSubobjectCompIso_hom_arrow (f : X \u27f6 Y) [HasImage f] {Y' : C} (h : Y \u27f6 Y') [IsIso h] :\n    (imageSubobjectCompIso f h).hom \u226b (imageSubobject f).arrow =\n      (imageSubobject (f \u226b h)).arrow \u226b inv h := by\n  simp [imageSubobjectCompIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite", "ZeroObject"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]", "[HasZeroMorphisms C] (f : X \u27f6 Y) [HasKernel f]", "{f} {X' Y' : C} {f' : X' \u27f6 Y'} [HasKernel f']", "(f : X \u27f6 Y) [HasImage f]", "[HasZeroMorphisms C] [HasZeroObject C]", "[HasEqualizers C]", "[HasEqualizers C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u2077 : Category.{v, u} C\nX Y : C\ninst\u271d\u2076 inst\u271d\u2075 : HasZeroMorphisms C\ninst\u271d\u2074 : HasZeroObject C\ninst\u271d\u00b3 inst\u271d\u00b2 : HasEqualizers C\nf : X \u27f6 Y\ninst\u271d\u00b9 : HasImage f\nY' : C\nh : Y \u27f6 Y'\ninst\u271d : IsIso h\n\u22a2 CategoryStruct.comp (imageSubobjectCompIso f h).hom (imageSubobject f).arrow =\n    CategoryStruct.comp (imageSubobject (CategoryStruct.comp f h)).arrow (inv h)"}, {"line": "simp [imageSubobjectCompIso]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem imageSubobjectCompIso_inv_arrow (f : X \u27f6 Y) [HasImage f] {Y' : C} (h : Y \u27f6 Y') [IsIso h] :\n    (imageSubobjectCompIso f h).inv \u226b (imageSubobject (f \u226b h)).arrow =\n      (imageSubobject f).arrow \u226b h := by\n  simp [imageSubobjectCompIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite", "ZeroObject"], "variables": ["{C : Type u} [Category.{v} C] {X Y Z : C}", "(f g : X \u27f6 Y) [HasEqualizer f g]", "[HasZeroMorphisms C] (f : X \u27f6 Y) [HasKernel f]", "{f} {X' Y' : C} {f' : X' \u27f6 Y'} [HasKernel f']", "(f : X \u27f6 Y) [HasImage f]", "[HasZeroMorphisms C] [HasZeroObject C]", "[HasEqualizers C]", "[HasEqualizers C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u2077 : Category.{v, u} C\nX Y : C\ninst\u271d\u2076 inst\u271d\u2075 : HasZeroMorphisms C\ninst\u271d\u2074 : HasZeroObject C\ninst\u271d\u00b3 inst\u271d\u00b2 : HasEqualizers C\nf : X \u27f6 Y\ninst\u271d\u00b9 : HasImage f\nY' : C\nh : Y \u27f6 Y'\ninst\u271d : IsIso h\n\u22a2 CategoryStruct.comp (imageSubobjectCompIso f h).inv (imageSubobject (CategoryStruct.comp f h)).arrow =\n    CategoryStruct.comp (imageSubobject f).arrow h"}, {"line": "simp [imageSubobjectCompIso]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arrow_congr {A : C} (X Y : Subobject A) (h : X = Y) :\n    eqToHom (congr_arg (fun X : Subobject A => (X : C)) h) \u226b Y.arrow = X.arrow := by\n  induction h\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Basic.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {X Y Z : C}", "{D : Type u\u2082} [Category.{v\u2082} D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nA : C\nX Y : Subobject A\nh : X = Y\n\u22a2 CategoryStruct.comp (eqToHom \u22ef) Y.arrow = X.arrow"}, {"line": "induction h", "tactic_state": "case refl\nC : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nA : C\nX Y : Subobject A\n\u22a2 CategoryStruct.comp (eqToHom \u22ef) X.arrow = X.arrow"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_of_comm {B : C} {X Y : Subobject B} (f : (X : C) \u27f6 (Y : C)) (w : f \u226b Y.arrow = X.arrow) :\n    X \u2264 Y := by\n  convert mk_le_mk_of_comm _ w <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Basic.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {X Y Z : C}", "{D : Type u\u2082} [Category.{v\u2082} D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nB : C\nX Y : Subobject B\nf : Subobject.underlying.obj X \u27f6 Subobject.underlying.obj Y\nw : CategoryStruct.comp f Y.arrow = X.arrow\n\u22a2 X \u2264 Y"}, {"line": "convert mk_le_mk_of_comm _ w <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofLEMk_comp {B A : C} {X : Subobject B} {f : A \u27f6 B} [Mono f] (h : X \u2264 mk f) :\n    ofLEMk X f h \u226b f = X.arrow := by simp [ofLEMk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Basic.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {X Y Z : C}", "{D : Type u\u2082} [Category.{v\u2082} D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nx\u271d : Sort u_1\nofLEMk : x\u271d\nB A : C\nX : Subobject B\nf : A \u27f6 B\ninst\u271d : Mono f\nh : X \u2264 sorry\n\u22a2 CategoryStruct.comp sorry f = X.arrow"}, {"line": "simp [ofLEMk]", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nx\u271d : Sort u_1\nofLEMk : x\u271d\nB A : C\nX : Subobject B\nf : A \u27f6 B\ninst\u271d : Mono f\nh : X \u2264 sorry\n\u22a2 CategoryStruct.comp (sorry ()) f = X.arrow"}]}
{"declaration": "theorem ofMkLE_arrow {B A : C} {f : A \u27f6 B} [Mono f] {X : Subobject B} (h : mk f \u2264 X) :\n    ofMkLE f X h \u226b X.arrow = f := by simp [ofMkLE]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Basic.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {X Y Z : C}", "{D : Type u\u2082} [Category.{v\u2082} D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nx\u271d : Sort u_1\nofMkLE : x\u271d\nB A : C\nf : A \u27f6 B\ninst\u271d : Mono f\nX : Subobject B\nh : sorry \u2264 X\n\u22a2 CategoryStruct.comp sorry X.arrow = f"}, {"line": "simp [ofMkLE]", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nx\u271d : Sort u_1\nofMkLE : x\u271d\nB A : C\nf : A \u27f6 B\ninst\u271d : Mono f\nX : Subobject B\nh : sorry \u2264 X\n\u22a2 CategoryStruct.comp (sorry ()) X.arrow = f"}]}
{"declaration": "theorem ofMkLEMk_comp {B A\u2081 A\u2082 : C} {f : A\u2081 \u27f6 B} {g : A\u2082 \u27f6 B} [Mono f] [Mono g] (h : mk f \u2264 mk g) :\n    ofMkLEMk f g h \u226b g = f := by simp [ofMkLEMk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Basic.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {X Y Z : C}", "{D : Type u\u2082} [Category.{v\u2082} D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\nx\u271d : Sort u_1\nofMkLEMk : x\u271d\nB A\u2081 A\u2082 : C\nf : A\u2081 \u27f6 B\ng : A\u2082 \u27f6 B\ninst\u271d\u00b9 : Mono f\ninst\u271d : Mono g\nh : sorry \u2264 sorry\n\u22a2 CategoryStruct.comp sorry g = f"}, {"line": "simp [ofMkLEMk]", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\nx\u271d : Sort u_1\nofMkLEMk : x\u271d\nB A\u2081 A\u2082 : C\nf : A\u2081 \u27f6 B\ng : A\u2082 \u27f6 B\ninst\u271d\u00b9 : Mono f\ninst\u271d : Mono g\nh : sorry \u2264 sorry\n\u22a2 CategoryStruct.comp (sorry ()) g = f"}]}
{"declaration": "theorem pullback_map_self [HasPullbacks C] (f : X \u27f6 Y) [Mono f] (g : Subobject X) :\n    (pullback f).obj ((map f).obj g) = g := by\n  revert g\n  exact Quotient.ind (fun g' => Quotient.sound \u27e8(MonoOver.pullbackMapSelf f).app _\u27e9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Basic.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits", "CategoryTheory.Limits"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {X Y Z : C}", "{D : Type u\u2082} [Category.{v\u2082} D]", "{P Q : MonoOver X} (f : P \u27f6 Q)", "[HasPullbacks C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nX Y : C\ninst\u271d\u00b2 inst\u271d\u00b9 : HasPullbacks C\nf : X \u27f6 Y\ninst\u271d : Mono f\ng : Subobject X\n\u22a2 sorry = g"}, {"line": "revert g", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nX Y : C\ninst\u271d\u00b2 inst\u271d\u00b9 : HasPullbacks C\nf : X \u27f6 Y\ninst\u271d : Mono f\n\u22a2 \u2200 (g : Subobject X), sorry = g"}, {"line": "exact Quotient.ind (fun g' => Quotient.sound \u27e8(MonoOver.pullbackMapSelf f).app _\u27e9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_eq_map_pullback' {A : C} (f\u2081 : MonoOver A) (f\u2082 : Subobject A) :\n    (Subobject.inf.obj (Quotient.mk'' f\u2081)).obj f\u2082 =\n      (Subobject.map f\u2081.arrow).obj ((Subobject.pullback f\u2081.arrow).obj f\u2082) := by\n  induction' f\u2082 using Quotient.inductionOn' with f\u2082\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Lattice.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits", "ZeroObject", "ZeroObject"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {X Y Z : C}", "{D : Type u\u2082} [Category.{v\u2082} D]", "[HasPullbacks C]", "[HasInitial C] [InitialMonoClass C]", "[HasZeroObject C]", "[HasPullbacks C]", "[HasImages C] [HasBinaryCoproducts C]", "[HasPullbacks C]", "[HasInitial C] [InitialMonoClass C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "(C)", "[HasPullbacks C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9\u00b3 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9\u00b2 : HasPullbacks C\ninst\u271d\u00b9\u00b9 : HasInitial C\ninst\u271d\u00b9\u2070 : InitialMonoClass C\ninst\u271d\u2079 : HasZeroObject C\ninst\u271d\u2078 : HasPullbacks C\ninst\u271d\u2077 : HasImages C\ninst\u271d\u2076 : HasBinaryCoproducts C\ninst\u271d\u2075 : HasPullbacks C\ninst\u271d\u2074 : HasInitial C\ninst\u271d\u00b3 : InitialMonoClass C\ninst\u271d\u00b2 : HasZeroObject C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasPullbacks C\nA : C\nf\u2081 : MonoOver A\nf\u2082 : Subobject A\n\u22a2 (Subobject.inf.obj (Quotient.mk'' f\u2081)).obj f\u2082 = (Subobject.map f\u2081.arrow).obj ((Subobject.pullback f\u2081.arrow).obj f\u2082)"}, {"line": "induction' f\u2082 using Quotient.inductionOn' with f\u2082", "tactic_state": "case h\nC : Type u\u2081\ninst\u271d\u00b9\u00b3 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9\u00b2 : HasPullbacks C\ninst\u271d\u00b9\u00b9 : HasInitial C\ninst\u271d\u00b9\u2070 : InitialMonoClass C\ninst\u271d\u2079 : HasZeroObject C\ninst\u271d\u2078 : HasPullbacks C\ninst\u271d\u2077 : HasImages C\ninst\u271d\u2076 : HasBinaryCoproducts C\ninst\u271d\u2075 : HasPullbacks C\ninst\u271d\u2074 : HasInitial C\ninst\u271d\u00b3 : InitialMonoClass C\ninst\u271d\u00b2 : HasZeroObject C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasPullbacks C\nA : C\nf\u2081 f\u2082 : MonoOver A\n\u22a2 (Subobject.inf.obj (Quotient.mk'' f\u2081)).obj (Quotient.mk'' f\u2082) =\n    (Subobject.map f\u2081.arrow).obj ((Subobject.pullback f\u2081.arrow).obj (Quotient.mk'' f\u2082))"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_eq_inf {A : C} {f\u2081 f\u2082 : Subobject A} [HasBinaryProduct f\u2081 f\u2082] :\n    (f\u2081 \u2a2f f\u2082) = f\u2081 \u2293 f\u2082 := by\n  apply le_antisymm\n  \u00b7 refine le_inf _ _ _ (Limits.prod.fst.le) (Limits.prod.snd.le)\n  \u00b7 apply leOfHom\n    exact prod.lift (inf_le_left _ _).hom (inf_le_right _ _).hom\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subobject/Lattice.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits", "ZeroObject", "ZeroObject"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {X Y Z : C}", "{D : Type u\u2082} [Category.{v\u2082} D]", "[HasPullbacks C]", "[HasInitial C] [InitialMonoClass C]", "[HasZeroObject C]", "[HasPullbacks C]", "[HasImages C] [HasBinaryCoproducts C]", "[HasPullbacks C]", "[HasInitial C] [InitialMonoClass C]", "[HasZeroObject C]", "[HasZeroMorphisms C]", "(C)", "[HasPullbacks C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d\u00b9\u2074 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9\u00b3 : HasPullbacks C\ninst\u271d\u00b9\u00b2 : HasInitial C\ninst\u271d\u00b9\u00b9 : InitialMonoClass C\ninst\u271d\u00b9\u2070 : HasZeroObject C\ninst\u271d\u2079 : HasPullbacks C\ninst\u271d\u2078 : HasImages C\ninst\u271d\u2077 : HasBinaryCoproducts C\ninst\u271d\u2076 : HasPullbacks C\ninst\u271d\u2075 : HasInitial C\ninst\u271d\u2074 : InitialMonoClass C\ninst\u271d\u00b3 : HasZeroObject C\ninst\u271d\u00b2 : HasZeroMorphisms C\ninst\u271d\u00b9 : HasPullbacks C\nA : C\nf\u2081 f\u2082 : Subobject A\ninst\u271d : HasBinaryProduct f\u2081 f\u2082\n\u22a2 (f\u2081 \u2a2f f\u2082) = f\u2081 \u2293 f\u2082"}, {"line": "apply le_antisymm", "tactic_state": "case a\nC : Type u\u2081\ninst\u271d\u00b9\u2074 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9\u00b3 : HasPullbacks C\ninst\u271d\u00b9\u00b2 : HasInitial C\ninst\u271d\u00b9\u00b9 : InitialMonoClass C\ninst\u271d\u00b9\u2070 : HasZeroObject C\ninst\u271d\u2079 : HasPullbacks C\ninst\u271d\u2078 : HasImages C\ninst\u271d\u2077 : HasBinaryCoproducts C\ninst\u271d\u2076 : HasPullbacks C\ninst\u271d\u2075 : HasInitial C\ninst\u271d\u2074 : InitialMonoClass C\ninst\u271d\u00b3 : HasZeroObject C\ninst\u271d\u00b2 : HasZeroMorphisms C\ninst\u271d\u00b9 : HasPullbacks C\nA : C\nf\u2081 f\u2082 : Subobject A\ninst\u271d : HasBinaryProduct f\u2081 f\u2082\n\u22a2 (f\u2081 \u2a2f f\u2082) \u2264 f\u2081 \u2293 f\u2082\n---\ncase a\nC : Type u\u2081\ninst\u271d\u00b9\u2074 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9\u00b3 : HasPullbacks C\ninst\u271d\u00b9\u00b2 : HasInitial C\ninst\u271d\u00b9\u00b9 : InitialMonoClass C\ninst\u271d\u00b9\u2070 : HasZeroObject C\ninst\u271d\u2079 : HasPullbacks C\ninst\u271d\u2078 : HasImages C\ninst\u271d\u2077 : HasBinaryCoproducts C\ninst\u271d\u2076 : HasPullbacks C\ninst\u271d\u2075 : HasInitial C\ninst\u271d\u2074 : InitialMonoClass C\ninst\u271d\u00b3 : HasZeroObject C\ninst\u271d\u00b2 : HasZeroMorphisms C\ninst\u271d\u00b9 : HasPullbacks C\nA : C\nf\u2081 f\u2082 : Subobject A\ninst\u271d : HasBinaryProduct f\u2081 f\u2082\n\u22a2 f\u2081 \u2293 f\u2082 \u2264 (f\u2081 \u2a2f f\u2082)"}, {"line": "\u00b7 refine le_inf _ _ _ (Limits.prod.fst.le) (Limits.prod.snd.le)", "tactic_state": "case a\nC : Type u\u2081\ninst\u271d\u00b9\u2074 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9\u00b3 : HasPullbacks C\ninst\u271d\u00b9\u00b2 : HasInitial C\ninst\u271d\u00b9\u00b9 : InitialMonoClass C\ninst\u271d\u00b9\u2070 : HasZeroObject C\ninst\u271d\u2079 : HasPullbacks C\ninst\u271d\u2078 : HasImages C\ninst\u271d\u2077 : HasBinaryCoproducts C\ninst\u271d\u2076 : HasPullbacks C\ninst\u271d\u2075 : HasInitial C\ninst\u271d\u2074 : InitialMonoClass C\ninst\u271d\u00b3 : HasZeroObject C\ninst\u271d\u00b2 : HasZeroMorphisms C\ninst\u271d\u00b9 : HasPullbacks C\nA : C\nf\u2081 f\u2082 : Subobject A\ninst\u271d : HasBinaryProduct f\u2081 f\u2082\n\u22a2 f\u2081 \u2293 f\u2082 \u2264 (f\u2081 \u2a2f f\u2082)"}, {"line": "\u00b7 apply leOfHom\n    exact prod.lift (inf_le_left _ _).hom (inf_le_right _ _).hom", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iSup_obj {\u03b9 : Type*} (S : \u03b9 \u2192 Subpresheaf F) (U : C\u1d52\u1d56) :\n    (\u2a06 i, S i).obj U = \u22c3 i, (S i).obj U := by\n  simp [iSup, sSup_obj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subpresheaf/Basic.lean", "context": {"open": ["Opposite CategoryTheory"], "variables": ["{C : Type u} [Category.{v} C]", "{F F' F'' : C\u1d52\u1d56 \u2964 Type w} (G G' : Subpresheaf F)", "(F)", "{F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nF : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\n\u03b9 : Type u_1\nS : \u03b9 \u2192 Subpresheaf F\nU : C\u1d52\u1d56\n\u22a2 (\u2a06 i, S i).obj U = \u22c3 i, (S i).obj U"}, {"line": "simp [iSup, sSup_obj]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nF : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\n\u03b9 : Type u_1\nS : \u03b9 \u2192 Subpresheaf F\nU : C\u1d52\u1d56\n\u22a2 (sSup (Set.range fun i => S i)).obj U = \u22c3 i, (S i).obj U"}]}
{"declaration": "lemma iInf_obj {\u03b9 : Type*} (S : \u03b9 \u2192 Subpresheaf F) (U : C\u1d52\u1d56) :\n    (\u2a05 i, S i).obj U = \u22c2 i, (S i).obj U := by\n  simp [iInf, sInf_obj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subpresheaf/Basic.lean", "context": {"open": ["Opposite CategoryTheory"], "variables": ["{C : Type u} [Category.{v} C]", "{F F' F'' : C\u1d52\u1d56 \u2964 Type w} (G G' : Subpresheaf F)", "(F)", "{F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nF : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\n\u03b9 : Type u_1\nS : \u03b9 \u2192 Subpresheaf F\nU : C\u1d52\u1d56\n\u22a2 (\u2a05 i, S i).obj U = \u22c2 i, (S i).obj U"}, {"line": "simp [iInf, sInf_obj]", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nF : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\n\u03b9 : Type u_1\nS : \u03b9 \u2192 Subpresheaf F\nU : C\u1d52\u1d56\n\u22a2 (sInf (Set.range fun i => S i)).obj U = \u22c2 i, (S i).obj U"}]}
{"declaration": "lemma max_min (S\u2081 S\u2082 T : Subpresheaf F) :\n    (S\u2081 \u2294 S\u2082) \u2293 T = (S\u2081 \u2293 T) \u2294 (S\u2082 \u2293 T) := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subpresheaf/Basic.lean", "context": {"open": ["Opposite CategoryTheory"], "variables": ["{C : Type u} [Category.{v} C]", "{F F' F'' : C\u1d52\u1d56 \u2964 Type w} (G G' : Subpresheaf F)", "(F)", "{F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nF : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nS\u2081 S\u2082 T : Subpresheaf F\n\u22a2 (S\u2081 \u2294 S\u2082) \u2293 T = S\u2081 \u2293 T \u2294 S\u2082 \u2293 T"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iSup_min {\u03b9 : Type*} (S : \u03b9 \u2192 Subpresheaf F) (T : Subpresheaf F) :\n    (\u2a06 i, S i) \u2293 T = \u2a06 i, S i \u2293 T := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subpresheaf/Basic.lean", "context": {"open": ["Opposite CategoryTheory"], "variables": ["{C : Type u} [Category.{v} C]", "{F F' F'' : C\u1d52\u1d56 \u2964 Type w} (G G' : Subpresheaf F)", "(F)", "{F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nF : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\n\u03b9 : Type u_1\nS : \u03b9 \u2192 Subpresheaf F\nT : Subpresheaf F\n\u22a2 (\u2a06 i, S i) \u2293 T = \u2a06 i, S i \u2293 T"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_top_iff_isIso : G = \u22a4 \u2194 IsIso G.\u03b9 := by\n  constructor\n  \u00b7 rintro rfl\n    infer_instance\n  \u00b7 intro H\n    ext U x\n    apply (iff_of_eq (iff_true _)).mpr\n    rw [\u2190 IsIso.inv_hom_id_apply (G.\u03b9.app U) x]\n    exact ((inv (G.\u03b9.app U)) x).2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subpresheaf/Basic.lean", "context": {"open": ["Opposite CategoryTheory"], "variables": ["{C : Type u} [Category.{v} C]", "{F F' F'' : C\u1d52\u1d56 \u2964 Type w} (G G' : Subpresheaf F)", "(F)", "{F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nF : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nG : Subpresheaf F\n\u22a2 G = \u22a4 \u2194 IsIso G.\u03b9"}, {"line": "constructor", "tactic_state": "case mp\nC : Type u\ninst\u271d : Category.{v, u} C\nF : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nG : Subpresheaf F\n\u22a2 G = \u22a4 \u2192 IsIso G.\u03b9\n---\ncase mpr\nC : Type u\ninst\u271d : Category.{v, u} C\nF : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nG : Subpresheaf F\n\u22a2 IsIso G.\u03b9 \u2192 G = \u22a4"}, {"line": "\u00b7 rintro rfl\n    infer_instance", "tactic_state": "case mpr\nC : Type u\ninst\u271d : Category.{v, u} C\nF : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nG : Subpresheaf F\n\u22a2 IsIso G.\u03b9 \u2192 G = \u22a4"}, {"line": "\u00b7 intro H\n    ext U x\n    apply (iff_of_eq (iff_true _)).mpr\n    rw [\u2190 IsIso.inv_hom_id_apply (G.\u03b9.app U) x]\n    exact ((inv (G.\u03b9.app U)) x).2", "tactic_state": "No Goals!"}]}
{"declaration": "lemma equalizer_self : Subpresheaf.equalizer f f = A := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subpresheaf/Equalizer.lean", "context": {"open": [], "variables": ["{C : Type u} [Category.{v} C] {F\u2081 F\u2082 : C\u1d52\u1d56 \u2964 Type w} {A : Subpresheaf F\u2081}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Sort u_1\nA : \u03b1\u271d\n\u22a2 sorry = A"}, {"line": "aesop", "tactic_state": "\u03b1 : Sort u_1\nA : \u03b1\n\u22a2 sorry () = A"}]}
{"declaration": "lemma mem_equalizer_iff {i : C\u1d52\u1d56} (x : A.toPresheaf.obj i) :\n    x.1 \u2208 (Subpresheaf.equalizer f g).obj i \u2194 f.app i x = g.app i x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subpresheaf/Equalizer.lean", "context": {"open": [], "variables": ["{C : Type u} [Category.{v} C] {F\u2081 F\u2082 : C\u1d52\u1d56 \u2964 Type w} {A : Subpresheaf F\u2081}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Sort u_1\ni : C\u1d52\u1d56\nx : sorry\n\u22a2 sorry \u2208 sorry \u2194 sorry = sorry"}, {"line": "simp", "tactic_state": "C : Sort u_1\ni : C\u1d52\u1d56\nx : sorry\n\u22a2 sorry () \u2208 sorry ()"}]}
{"declaration": "lemma range : (Subpresheaf.range f).IsGeneratedBy (fun i \u21a6 f.app _ (x i)) := by\n  simpa only [\u2190 Subpresheaf.image_top] using h.image f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subpresheaf/Finite.lean", "context": {"open": ["Opposite"], "variables": ["{C : Type u} [Category.{v} C] {F : C\u1d52\u1d56 \u2964 Type w}", "(G : Subpresheaf F)", "{\u03b9 : Type w'} {X : \u03b9 \u2192 C\u1d52\u1d56} (x : (i : \u03b9) \u2192 F.obj (X i))", "{G x} (h : G.IsGeneratedBy x)", "[hG : G.IsFinite]", "{G}", "(F)", "{\u03b9 : Type w'} {X : \u03b9 \u2192 C\u1d52\u1d56} (x : (i : \u03b9) \u2192 F.obj (X i))", "{F x} (h : PresheafIsGeneratedBy F x) {F' : C\u1d52\u1d56 \u2964 Type w} (f : F \u27f6 F')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Subpresheaf : ?m.3569\nC : Sort ?u.3631\nPresheafIsGeneratedBy : ?m.3621\nG : sorry\n\u03b9\u271d : Type w'\nX\u271d : \u03b9\u271d \u2192 C\u1d52\u1d56\nx\u271d : \u03b9\u271d \u2192 sorry\nh\u271d : sorry\nF : ?m.4477 h\u271d\n\u03b9 : Type w'\nX : \u03b9 \u2192 C\u1d52\u1d56\nx : \u03b9 \u2192 sorry\nh : sorry\nF' : C\u1d52\u1d56\n\u22a2 sorry"}, {"line": "simpa only [\u2190 Subpresheaf.image_top] using h.image f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma range_\u03b9 (G : Subpresheaf F) : range G.\u03b9 = G := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subpresheaf/Image.lean", "context": {"open": [], "variables": ["{C : Type u} [Category.{v} C] {F F' F'' : C\u1d52\u1d56 \u2964 Type w}", "(F) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nSubpresheaf : x\u271d\u00b9\nx\u271d : Sort u_2\nrange : x\u271d\nG : sorry\n\u22a2 sorry = G"}, {"line": "aesop", "tactic_state": "x : Sort u_1\nSubpresheaf : x\nx_1 : Sort u_2\nrange : x_1\nG : sorry\n\u22a2 sorry () = G"}]}
{"declaration": "lemma toRange_app_val {i : C\u1d52\u1d56} (x : F'.obj i) :\n    ((toRange p).app i x).val = p.app i x := by\n  simp [toRange]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subpresheaf/Image.lean", "context": {"open": [], "variables": ["{C : Type u} [Category.{v} C] {F F' F'' : C\u1d52\u1d56 \u2964 Type w}", "(F) in", "(f : F' \u27f6 F) {G : Subpresheaf F} (hf : range f \u2264 G)", "(p : F' \u27f6 F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Sort u_1\nx\u271d : Sort u_2\ntoRange : x\u271d\ni : C\u1d52\u1d56\nx : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [toRange]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma epi_iff_range_eq_top :\n    Epi p \u2194 range p = \u22a4 := by\n  simp [NatTrans.epi_iff_epi_app, epi_iff_surjective, Subpresheaf.ext_iff, funext_iff,\n    Set.range_eq_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subpresheaf/Image.lean", "context": {"open": [], "variables": ["{C : Type u} [Category.{v} C] {F F' F'' : C\u1d52\u1d56 \u2964 Type w}", "(F) in", "(f : F' \u27f6 F) {G : Subpresheaf F} (hf : range f \u2264 G)", "(p : F' \u27f6 F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nEpi : x\u271d\u00b9\nx\u271d : Sort u_2\nrange : x\u271d\n\u22a2 sorry \u2194 sorry = \u22a4"}, {"line": "simp [NatTrans.epi_iff_epi_app, epi_iff_surjective, Subpresheaf.ext_iff, funext_iff,\n    Set.range_eq_univ]", "tactic_state": "x\u271d\u00b9 : Sort u_1\nEpi : x\u271d\u00b9\nx\u271d : Sort u_2\nrange : x\u271d\n\u22a2 sorry () \u2194 sorry () = \u22a4"}]}
{"declaration": "lemma image_top : (\u22a4 : Subpresheaf F).image f = range f := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subpresheaf/Image.lean", "context": {"open": [], "variables": ["{C : Type u} [Category.{v} C] {F F' F'' : C\u1d52\u1d56 \u2964 Type w}", "(F) in", "(f : F' \u27f6 F) {G : Subpresheaf F} (hf : range f \u2264 G)", "(p : F' \u27f6 F)", "(G : Subpresheaf F) (f : F \u27f6 F')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Subpresheaf : ?m.3299\nF F' : ?m.3430\nG : sorry\nf : F \u27f6 F'\nx\u271d : Sort u_1\nrange : x\u271d\n\u22a2 sorry = sorry"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma image_iSup {\u03b9 : Type*} (G : \u03b9 \u2192 Subpresheaf F) (f : F \u27f6 F') :\n    (\u2a06 i, G i).image f = \u2a06 i, (G i).image f := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subpresheaf/Image.lean", "context": {"open": [], "variables": ["{C : Type u} [Category.{v} C] {F F' F'' : C\u1d52\u1d56 \u2964 Type w}", "(F) in", "(f : F' \u27f6 F) {G : Subpresheaf F} (hf : range f \u2264 G)", "(p : F' \u27f6 F)", "(G : Subpresheaf F) (f : F \u27f6 F')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Subpresheaf : ?m.3299\nF F' : ?m.3430\nG\u271d : sorry\nf\u271d : F \u27f6 F'\n\u03b9 : Type u_1\nG : \u03b9 \u2192 sorry\nf : sorry\n\u22a2 sorry = \u2a06 i, sorry"}, {"line": "aesop", "tactic_state": "Subpresheaf : ?m.3299\nF F' : ?m.3430\nG_1 : sorry\nf_1 : F \u27f6 F'\n\u03b9 : Type u_1\nG : \u03b9 \u2192 sorry\nf : sorry\n\u22a2 sorry () = \u2a06 i, sorry ()"}]}
{"declaration": "lemma image_le_iff (G : Subpresheaf F) (f : F \u27f6 F') (G' : Subpresheaf F') :\n    G.image f \u2264 G' \u2194 G \u2264 G'.preimage f := by\n  simp [Subpresheaf.le_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/CategoryTheory/Subpresheaf/Image.lean", "context": {"open": [], "variables": ["{C : Type u} [Category.{v} C] {F F' F'' : C\u1d52\u1d56 \u2964 Type w}", "(F) in", "(f : F' \u27f6 F) {G : Subpresheaf F} (hf : range f \u2264 G)", "(p : F' \u27f6 F)", "(G : Subpresheaf F) (f : F \u27f6 F')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Subpresheaf : ?m.3299\nF F' : ?m.3430\nG\u271d : sorry\nf\u271d : F \u27f6 F'\nG : sorry\nf : sorry\nG' : sorry\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [Subpresheaf.le_def]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toColex_inj {s t : Finset \u03b1} : toColex s = toColex t \u2194 s = t := by simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Colex.lean", "context": {"open": ["Finset Function", "Colex"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Finset \u03b1\n\u22a2 { ofColex := s } = { ofColex := t } \u2194 s = t"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toColex_ne_toColex {s t : Finset \u03b1} : toColex s \u2260 toColex t \u2194 s \u2260 t := by simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Colex.lean", "context": {"open": ["Finset Function", "Colex"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Finset \u03b1\n\u22a2 { ofColex := s } \u2260 { ofColex := t } \u2194 s \u2260 t"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ofColex_ne_ofColex {s t : Colex \u03b1} : ofColex s \u2260 ofColex t \u2194 s \u2260 t := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Colex.lean", "context": {"open": ["Finset Function", "Colex"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Colex \u03b1\n\u22a2 s.ofColex \u2260 t.ofColex \u2194 s \u2260 t"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma singleton_le_singleton : (toColex {a} : Colex \u03b1) \u2264 toColex {b} \u2194 a \u2264 b := by\n  simp [toColex_le_singleton, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Colex.lean", "context": {"open": ["Finset Function", "Colex"], "variables": ["{\u03b1 \u03b2 : Type*}", "[PartialOrder \u03b1] [PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {\ud835\udc9c \ud835\udc9c\u2081 \ud835\udc9c\u2082 : Finset (Finset \u03b1)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\n\u22a2 { ofColex := {a} } \u2264 { ofColex := {b} } \u2194 a \u2264 b"}, {"line": "simp [toColex_le_singleton, eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma singleton_lt_singleton : (toColex {a} : Colex \u03b1) < toColex {b} \u2194 a < b := by\n  simp [toColex_lt_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Colex.lean", "context": {"open": ["Finset Function", "Colex"], "variables": ["{\u03b1 \u03b2 : Type*}", "[PartialOrder \u03b1] [PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {\ud835\udc9c \ud835\udc9c\u2081 \ud835\udc9c\u2082 : Finset (Finset \u03b1)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\n\u22a2 { ofColex := {a} } < { ofColex := {b} } \u2194 a < b"}, {"line": "simp [toColex_lt_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_iff_sdiff_subset_lowerClosure {s t : Colex \u03b1} :\n    s \u2264 t \u2194 (ofColex s : Set \u03b1) \\ ofColex t \u2286 lowerClosure (ofColex t \\ ofColex s : Set \u03b1) := by\n  simp [le_def, Set.subset_def, and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Colex.lean", "context": {"open": ["Finset Function", "Colex"], "variables": ["{\u03b1 \u03b2 : Type*}", "[PartialOrder \u03b1] [PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {\ud835\udc9c \ud835\udc9c\u2081 \ud835\udc9c\u2082 : Finset (Finset \u03b1)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PartialOrder \u03b1\ns t : Colex \u03b1\n\u22a2 s \u2264 t \u2194 \u2191s.ofColex \\ \u2191t.ofColex \u2286 \u2191(lowerClosure (\u2191t.ofColex \\ \u2191s.ofColex))"}, {"line": "simp [le_def, Set.subset_def, and_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma max_mem_aux {s t : Colex \u03b1} (hst : s \u2260 t) : (ofColex s \u2206 ofColex t).Nonempty := by\n  simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Colex.lean", "context": {"open": ["Finset Function", "Colex", "scoped symmDiff"], "variables": ["{\u03b1 \u03b2 : Type*}", "[PartialOrder \u03b1] [PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {\ud835\udc9c \ud835\udc9c\u2081 \ud835\udc9c\u2082 : Finset (Finset \u03b1)}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]", "[LinearOrder \u03b1] [LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {\ud835\udc9c \ud835\udc9c\u2081 \ud835\udc9c\u2082 : Finset (Finset \u03b1)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : LinearOrder \u03b1\ns t : Colex \u03b1\nhst : s \u2260 t\n\u22a2 (symmDiff s.ofColex t.ofColex).Nonempty"}, {"line": "simpa", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toColex_image_le_toColex_image (hf : StrictMono f) :\n    toColex (s.image f) \u2264 toColex (t.image f) \u2194 toColex s \u2264 toColex t := by\n  simp [toColex_le_toColex, hf.le_iff_le, hf.injective.eq_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Colex.lean", "context": {"open": ["Finset Function", "Colex", "scoped symmDiff"], "variables": ["{\u03b1 \u03b2 : Type*}", "[PartialOrder \u03b1] [PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {\ud835\udc9c \ud835\udc9c\u2081 \ud835\udc9c\u2082 : Finset (Finset \u03b1)}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]", "[LinearOrder \u03b1] [LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {\ud835\udc9c \ud835\udc9c\u2081 \ud835\udc9c\u2082 : Finset (Finset \u03b1)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b2\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns t : Finset \u03b1\nhf : StrictMono f\n\u22a2 { ofColex := image f s } \u2264 { ofColex := image f t } \u2194 { ofColex := s } \u2264 { ofColex := t }"}, {"line": "simp [toColex_le_toColex, hf.le_iff_le, hf.injective.eq_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b2\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns t : Finset \u03b1\nhf : StrictMono f\n\u22a2 (\u2200 a \u2208 s, (\u2200 x \u2208 t, \u00acf x = f a) \u2192 \u2203 a_3 \u2208 t, (\u2200 x \u2208 s, \u00acf x = f a_3) \u2227 f a \u2264 f a_3) \u2194\n    \u2200 \u2983a : \u03b1\u2984, a \u2208 s \u2192 a \u2209 t \u2192 \u2203 b \u2208 t, b \u2209 s \u2227 a \u2264 b"}]}
{"declaration": "lemma isInitSeg_iff_exists_initSeg :\n    IsInitSeg \ud835\udc9c r \u2227 \ud835\udc9c.Nonempty \u2194 \u2203 s : Finset \u03b1, #s = r \u2227 \ud835\udc9c = initSeg s := by\n  refine \u27e8fun h\ud835\udc9c \u21a6 h\ud835\udc9c.1.exists_initSeg h\ud835\udc9c.2, ?_\u27e9\n  rintro \u27e8s, rfl, rfl\u27e9\n  exact \u27e8isInitSeg_initSeg, initSeg_nonempty\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Colex.lean", "context": {"open": ["Finset Function", "Colex", "scoped symmDiff"], "variables": ["{\u03b1 \u03b2 : Type*}", "[PartialOrder \u03b1] [PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {\ud835\udc9c \ud835\udc9c\u2081 \ud835\udc9c\u2082 : Finset (Finset \u03b1)}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]", "[LinearOrder \u03b1] [LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {\ud835\udc9c \ud835\udc9c\u2081 \ud835\udc9c\u2082 : Finset (Finset \u03b1)}", "[Fintype \u03b1]", "[Fintype \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\ninst\u271d\u00b9 inst\u271d : Fintype \u03b1\nr : \u2115\n\u22a2 IsInitSeg \ud835\udc9c r \u2227 \ud835\udc9c.Nonempty \u2194 \u2203 s, s.card = r \u2227 \ud835\udc9c = initSeg s"}, {"line": "refine \u27e8fun h\ud835\udc9c \u21a6 h\ud835\udc9c.1.exists_initSeg h\ud835\udc9c.2, ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\ninst\u271d\u00b9 inst\u271d : Fintype \u03b1\nr : \u2115\n\u22a2 (\u2203 s, s.card = r \u2227 \ud835\udc9c = initSeg s) \u2192 IsInitSeg \ud835\udc9c r \u2227 \ud835\udc9c.Nonempty"}, {"line": "rintro \u27e8s, rfl, rfl\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 inst\u271d : Fintype \u03b1\ns : Finset \u03b1\n\u22a2 IsInitSeg (initSeg s) s.card \u2227 (initSeg s).Nonempty"}, {"line": "exact \u27e8isInitSeg_initSeg, initSeg_nonempty\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma geomSum_ofColex_strictMono (hn : 2 \u2264 n) : StrictMono fun s \u21a6 \u2211 k \u2208 ofColex s, n ^ k := by\n  rintro \u27e8s\u27e9 \u27e8t\u27e9 hst\n  rw [toColex_lt_toColex_iff_exists_forall_lt] at hst\n  obtain \u27e8a, hat, has, ha\u27e9 := hst\n  rw [\u2190 sum_sdiff_lt_sum_sdiff]\n  exact (Nat.geomSum_lt hn <| by simpa).trans_le <| single_le_sum (fun _ _ \u21a6 by positivity) <|\n    mem_sdiff.2 \u27e8hat, has\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Colex.lean", "context": {"open": ["Finset Function", "Colex", "scoped symmDiff", "Colex"], "variables": ["{\u03b1 \u03b2 : Type*}", "[PartialOrder \u03b1] [PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {\ud835\udc9c \ud835\udc9c\u2081 \ud835\udc9c\u2082 : Finset (Finset \u03b1)}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]", "[LinearOrder \u03b1] [LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {\ud835\udc9c \ud835\udc9c\u2081 \ud835\udc9c\u2082 : Finset (Finset \u03b1)}", "[Fintype \u03b1]", "[Fintype \u03b1]", "{s t : Finset \u2115} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : 2 \u2264 n\n\u22a2 StrictMono fun s => \u2211 k \u2208 s.ofColex, n ^ k"}, {"line": "rintro \u27e8s\u27e9 \u27e8t\u27e9 hst", "tactic_state": "case toColex.toColex\nn : \u2115\nhn : 2 \u2264 n\ns t : Finset \u2115\nhst : { ofColex := s } < { ofColex := t }\n\u22a2 (fun s => \u2211 k \u2208 s.ofColex, n ^ k) { ofColex := s } < (fun s => \u2211 k \u2208 s.ofColex, n ^ k) { ofColex := t }"}, {"line": "rw [toColex_lt_toColex_iff_exists_forall_lt] at hst", "tactic_state": "case toColex.toColex\nn : \u2115\nhn : 2 \u2264 n\ns t : Finset \u2115\nhst : \u2203 a \u2208 t, a \u2209 s \u2227 \u2200 b \u2208 s, b \u2209 t \u2192 b < a\n\u22a2 (fun s => \u2211 k \u2208 s.ofColex, n ^ k) { ofColex := s } < (fun s => \u2211 k \u2208 s.ofColex, n ^ k) { ofColex := t }"}, {"line": "obtain \u27e8a, hat, has, ha\u27e9 := hst", "tactic_state": "case toColex.toColex.intro.intro.intro\nn : \u2115\nhn : 2 \u2264 n\ns t : Finset \u2115\na : \u2115\nhat : a \u2208 t\nhas : a \u2209 s\nha : \u2200 b \u2208 s, b \u2209 t \u2192 b < a\n\u22a2 (fun s => \u2211 k \u2208 s.ofColex, n ^ k) { ofColex := s } < (fun s => \u2211 k \u2208 s.ofColex, n ^ k) { ofColex := t }"}, {"line": "rw [\u2190 sum_sdiff_lt_sum_sdiff]", "tactic_state": "case toColex.toColex.intro.intro.intro\nn : \u2115\nhn : 2 \u2264 n\ns t : Finset \u2115\na : \u2115\nhat : a \u2208 t\nhas : a \u2209 s\nha : \u2200 b \u2208 s, b \u2209 t \u2192 b < a\n\u22a2 \u2211 i \u2208 { ofColex := s }.ofColex \\ { ofColex := t }.ofColex, n ^ i <\n    \u2211 i \u2208 { ofColex := t }.ofColex \\ { ofColex := s }.ofColex, n ^ i"}, {"line": "exact (Nat.geomSum_lt hn <| by simpa).trans_le <| single_le_sum (fun _ _ \u21a6 by positivity) <|\n    mem_sdiff.2 \u27e8hat, has\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem geomSum_injective {n : \u2115} (hn : 2 \u2264 n) :\n    Function.Injective (fun s : Finset \u2115 \u21a6 \u2211 i \u2208 s, n ^ i) := by\n  intro _ _ h\n  rwa [le_antisymm_iff, geomSum_le_geomSum_iff_toColex_le_toColex hn,\n    geomSum_le_geomSum_iff_toColex_le_toColex hn, \u2190 le_antisymm_iff, Colex.toColex.injEq] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Colex.lean", "context": {"open": ["Finset Function", "Colex", "scoped symmDiff", "Colex"], "variables": ["{\u03b1 \u03b2 : Type*}", "[PartialOrder \u03b1] [PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {\ud835\udc9c \ud835\udc9c\u2081 \ud835\udc9c\u2082 : Finset (Finset \u03b1)}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]", "[LinearOrder \u03b1] [LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {\ud835\udc9c \ud835\udc9c\u2081 \ud835\udc9c\u2082 : Finset (Finset \u03b1)}", "[Fintype \u03b1]", "[Fintype \u03b1]", "{s t : Finset \u2115} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : 2 \u2264 n\n\u22a2 Injective fun s => \u2211 i \u2208 s, n ^ i"}, {"line": "intro _ _ h", "tactic_state": "n : \u2115\nhn : 2 \u2264 n\na\u2081\u271d a\u2082\u271d : Finset \u2115\nh : (fun s => \u2211 i \u2208 s, n ^ i) a\u2081\u271d = (fun s => \u2211 i \u2208 s, n ^ i) a\u2082\u271d\n\u22a2 a\u2081\u271d = a\u2082\u271d"}, {"line": "rwa [le_antisymm_iff, geomSum_le_geomSum_iff_toColex_le_toColex hn,\n    geomSum_le_geomSum_iff_toColex_le_toColex hn, \u2190 le_antisymm_iff, Colex.toColex.injEq] at h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pointCount_eq_pointCount [Finite P] [Finite L] (l m : L) :\n    pointCount P l = pointCount P m := by\n  apply lineCount_eq_lineCount (Dual P)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Configuration.lean", "context": {"open": ["Finset", "Nondegenerate", "HasPoints (mkPoint mkPoint_ax)", "HasLines (mkLine mkLine_ax)"], "variables": ["(P L : Type*) [Membership P L]", "{P L}", "(L)", "(P) {L}", "(L)", "{P L}", "(P L)", "{P L}", "(P L)", "[ProjectivePlane P L]", "{P}", "(P) {L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Membership P L\nx\u271d : Sort u_3\npointCount : x\u271d\ninst\u271d\u00b9 : Finite P\ninst\u271d : Finite L\nl m : L\n\u22a2 sorry = sorry"}, {"line": "apply lineCount_eq_lineCount (Dual P)", "tactic_state": "\u22a2 (P : Type u_1) \u2192\n    {L : Type u_2} \u2192\n      [inst : Membership P L] \u2192 {pointCount : ?m.991 P} \u2192 [inst : Finite P] \u2192 [inst : Finite L] \u2192 L \u2192 L \u2192 Sort u_4"}]}
{"declaration": "theorem two_lt_lineCount [Finite P] [Finite L] (p : P) : 2 < lineCount L p := by\n  simpa only [lineCount_eq L p,Nat.succ_lt_succ_iff] using one_lt_order P L\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Configuration.lean", "context": {"open": ["Finset", "Nondegenerate", "HasPoints (mkPoint mkPoint_ax)", "HasLines (mkLine mkLine_ax)"], "variables": ["(P L : Type*) [Membership P L]", "{P L}", "(L)", "(P) {L}", "(L)", "{P L}", "(P L)", "{P L}", "(P L)", "[ProjectivePlane P L]", "{P}", "(P) {L}", "{P}", "(P L)", "{P}", "(P) {L}", "(L)", "{P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Membership P L\nx\u271d : Sort u_3\nlineCount : x\u271d\ninst\u271d\u00b9 : Finite P\ninst\u271d : Finite L\np : P\n\u22a2 2 < sorry"}, {"line": "simpa only [lineCount_eq L p,Nat.succ_lt_succ_iff] using one_lt_order P L", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_lt_pointCount [Finite P] [Finite L] (l : L) : 2 < pointCount P l := by\n  simpa only [pointCount_eq P l,Nat.succ_lt_succ_iff] using one_lt_order P L\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Configuration.lean", "context": {"open": ["Finset", "Nondegenerate", "HasPoints (mkPoint mkPoint_ax)", "HasLines (mkLine mkLine_ax)"], "variables": ["(P L : Type*) [Membership P L]", "{P L}", "(L)", "(P) {L}", "(L)", "{P L}", "(P L)", "{P L}", "(P L)", "[ProjectivePlane P L]", "{P}", "(P) {L}", "{P}", "(P L)", "{P}", "(P) {L}", "(L)", "{P}", "(P) {L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Membership P L\nx\u271d : Sort u_3\npointCount : x\u271d\ninst\u271d\u00b9 : Finite P\ninst\u271d : Finite L\nl : L\n\u22a2 2 < sorry"}, {"line": "simpa only [pointCount_eq P l,Nat.succ_lt_succ_iff] using one_lt_order P L", "tactic_state": "No Goals!"}]}
{"declaration": "lemma apply_inl (h : l.idxFun i = Sum.inl a) : l x i = a := by simp [apply_def, h]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/HalesJewett.lean", "context": {"open": ["Function", "scoped Finset"], "variables": ["{\u03b7 \u03b1 \u03b9 \u03ba : Type*}", "{\u03b7 \u03b1 \u03b9 \u03ba : Type*} {l : Subspace \u03b7 \u03b1 \u03b9} {x : \u03b7 \u2192 \u03b1} {i : \u03b9} {a : \u03b1} {e : \u03b7}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\na : \u03b1\nh : sorry = Sum.inl a\n\u22a2 sorry = a"}, {"line": "simp [apply_def, h]", "tactic_state": "\u03b1 : Type u_6\na : \u03b1\nh : sorry = Sum.inl a\n\u22a2 sorry () = a"}]}
{"declaration": "lemma apply_inr (h : l.idxFun i = Sum.inr e) : l x i = x e := by simp [apply_def, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/HalesJewett.lean", "context": {"open": ["Function", "scoped Finset"], "variables": ["{\u03b7 \u03b1 \u03b9 \u03ba : Type*}", "{\u03b7 \u03b1 \u03b9 \u03ba : Type*} {l : Subspace \u03b7 \u03b1 \u03b9} {x : \u03b7 \u2192 \u03b1} {i : \u03b9} {a : \u03b1} {e : \u03b7}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b7 : Type u_5\n\u03b1 : Type u_6\nx : \u03b7 \u2192 \u03b1\ne : \u03b7\nh : sorry = Sum.inr e\n\u22a2 sorry = x e"}, {"line": "simp [apply_def, h]", "tactic_state": "\u03b7 : Type u_5\n\u03b1 : Type u_6\nx : \u03b7 \u2192 \u03b1\ne : \u03b7\nh : sorry = Sum.inr e\n\u22a2 sorry () = x e"}]}
{"declaration": "lemma apply_some (h : l.idxFun i = some a) : l x i = a := by simp [l.apply_def, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/HalesJewett.lean", "context": {"open": ["Function", "scoped Finset"], "variables": ["{\u03b7 \u03b1 \u03b9 \u03ba : Type*}", "{\u03b7 \u03b1 \u03b9 \u03ba : Type*} {l : Subspace \u03b7 \u03b1 \u03b9} {x : \u03b7 \u2192 \u03b1} {i : \u03b9} {a : \u03b1} {e : \u03b7}", "{\u03b7' \u03b1' \u03b9' : Type*}", "{l : Line \u03b1 \u03b9} {i : \u03b9} {a x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Line : ?m.2640\n\u03b7\u271d : Type u_1\n\u03b1\u271d\u00b9 : Type u_2\n\u03b9\u271d : Type u_3\n\u03ba\u271d : Type u_4\n\u03b7 : Type u_5\n\u03b1\u271d : Type u_6\n\u03b9 : Type u_7\n\u03ba : Type u_8\nl\u271d : sorry\nx\u271d : \u03b7 \u2192 \u03b1\u271d\ni\u271d : \u03b9\na\u271d\u00b9 : \u03b1\u271d\ne : \u03b7\n\u03b7' : Type u_9\n\u03b1' : Type u_10\n\u03b9' : Type u_11\nl : sorry\ni : \u03b9\na\u271d x : \u03b1\u271d\n\u03b1 : Type u_6\na : \u03b1\nh : sorry = some a\n\u22a2 sorry = a"}, {"line": "simp [l.apply_def, h]", "tactic_state": "Line : ?m.2640\n\u03b7\u271d : Type u_1\n\u03b1\u271d\u00b9 : Type u_2\n\u03b9\u271d : Type u_3\n\u03ba\u271d : Type u_4\n\u03b7 : Type u_5\n\u03b1\u271d : Type u_6\n\u03b9 : Type u_7\n\u03ba : Type u_8\nl\u271d : sorry\nx\u271d : \u03b7 \u2192 \u03b1\u271d\ni\u271d : \u03b9\na\u271d\u00b9 : \u03b1\u271d\ne : \u03b7\n\u03b7' : Type u_9\n\u03b1' : Type u_10\n\u03b9' : Type u_11\nl : sorry\ni : \u03b9\na\u271d x : \u03b1\u271d\n\u03b1 : Type u_6\na : \u03b1\nh : sorry = some a\n\u22a2 sorry () = a"}]}
{"declaration": "lemma schnirelmannDensity_mul_le_card_filter {n : \u2115} :\n    schnirelmannDensity A * n \u2264 #{a \u2208 Ioc 0 n | a \u2208 A} := by\n  rcases eq_or_ne n 0 with rfl | hn\n  \u00b7 simp\n  exact (le_div_iff\u2080 (by positivity)).1 (schnirelmannDensity_le_div hn)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Schnirelmann.lean", "context": {"open": ["Finset"], "variables": ["{A : Set \u2115} [DecidablePred (\u00b7 \u2208 A)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Set \u2115\ninst\u271d : DecidablePred fun x => x \u2208 A\nn : \u2115\n\u22a2 schnirelmannDensity A * \u2191n \u2264 \u2191{a \u2208 Ioc 0 n | a \u2208 A}.card"}, {"line": "rcases eq_or_ne n 0 with rfl | hn", "tactic_state": "case inl\nA : Set \u2115\ninst\u271d : DecidablePred fun x => x \u2208 A\n\u22a2 schnirelmannDensity A * \u21910 \u2264 \u2191{a \u2208 Ioc 0 0 | a \u2208 A}.card\n---\ncase inr\nA : Set \u2115\ninst\u271d : DecidablePred fun x => x \u2208 A\nn : \u2115\nhn : n \u2260 0\n\u22a2 schnirelmannDensity A * \u2191n \u2264 \u2191{a \u2208 Ioc 0 n | a \u2208 A}.card"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nA : Set \u2115\ninst\u271d : DecidablePred fun x => x \u2208 A\nn : \u2115\nhn : n \u2260 0\n\u22a2 schnirelmannDensity A * \u2191n \u2264 \u2191{a \u2208 Ioc 0 n | a \u2208 A}.card"}, {"line": "exact (le_div_iff\u2080 (by positivity)).1 (schnirelmannDensity_le_div hn)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma schnirelmannDensity_le_iff_forall {x : \u211d} :\n    schnirelmannDensity A \u2264 x \u2194\n      \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 n : \u2115, 0 < n \u2227 #{a \u2208 Ioc 0 n | a \u2208 A} / n < x + \u03b5 := by\n  rw [le_iff_forall_pos_lt_add]\n  simp only [schnirelmannDensity_lt_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Schnirelmann.lean", "context": {"open": ["Finset"], "variables": ["{A : Set \u2115} [DecidablePred (\u00b7 \u2208 A)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Set \u2115\ninst\u271d : DecidablePred fun x => x \u2208 A\nx : \u211d\n\u22a2 schnirelmannDensity A \u2264 x \u2194 \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2203 n, 0 < n \u2227 \u2191{a \u2208 Ioc 0 n | a \u2208 A}.card / \u2191n < x + \u03b5"}, {"line": "rw [le_iff_forall_pos_lt_add]", "tactic_state": "A : Set \u2115\ninst\u271d : DecidablePred fun x => x \u2208 A\nx : \u211d\n\u22a2 (\u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 schnirelmannDensity A < x + \u03b5) \u2194\n    \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2203 n, 0 < n \u2227 \u2191{a \u2208 Ioc 0 n | a \u2208 A}.card / \u2191n < x + \u03b5"}, {"line": "simp only [schnirelmannDensity_lt_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_of_schnirelmannDensity_eq_zero {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) (hA : schnirelmannDensity A = 0) :\n    \u2203 n, 0 < n \u2227 #{a \u2208 Ioc 0 n | a \u2208 A} / n < \u03b5 := by\n  by_contra! h\n  rw [\u2190 le_schnirelmannDensity_iff] at h\n  linarith\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Schnirelmann.lean", "context": {"open": ["Finset"], "variables": ["{A : Set \u2115} [DecidablePred (\u00b7 \u2208 A)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Set \u2115\ninst\u271d : DecidablePred fun x => x \u2208 A\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhA : schnirelmannDensity A = 0\n\u22a2 \u2203 n, 0 < n \u2227 \u2191{a \u2208 Ioc 0 n | a \u2208 A}.card / \u2191n < \u03b5"}, {"line": "by_contra! h", "tactic_state": "A : Set \u2115\ninst\u271d : DecidablePred fun x => x \u2208 A\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhA : schnirelmannDensity A = 0\nh : \u2200 (n : \u2115), 0 < n \u2192 \u03b5 \u2264 \u2191{a \u2208 Ioc 0 n | a \u2208 A}.card / \u2191n\n\u22a2 False"}, {"line": "rw [\u2190 le_schnirelmannDensity_iff] at h", "tactic_state": "A : Set \u2115\ninst\u271d : DecidablePred fun x => x \u2208 A\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhA : schnirelmannDensity A = 0\nh : \u03b5 \u2264 schnirelmannDensity A\n\u22a2 False"}, {"line": "linarith", "tactic_state": "No Goals!"}]}
{"declaration": "lemma schnirelmannDensity_setOf_modeq_one {m : \u2115} :\n    schnirelmannDensity {n | n \u2261 1 [MOD m]} = (m\u207b\u00b9 : \u211d) := by\n  rcases eq_or_ne m 1 with rfl | hm\n  \u00b7 simp [Nat.modEq_one]\n  rw [\u2190 schnirelmannDensity_setOf_mod_eq_one hm]\n  apply schnirelmannDensity_congr\n  ext n\n  simp only [Set.mem_setOf_eq]\n  simp only [Nat.ModEq]\n  simp only [Nat.one_mod_eq_one.mpr hm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Schnirelmann.lean", "context": {"open": ["Finset"], "variables": ["{A : Set \u2115} [DecidablePred (\u00b7 \u2208 A)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\n\u22a2 schnirelmannDensity {n | n \u2261 1 [MOD m]} = (\u2191m)\u207b\u00b9"}, {"line": "rcases eq_or_ne m 1 with rfl | hm", "tactic_state": "case inl\n\u22a2 schnirelmannDensity {n | n \u2261 1 [MOD 1]} = (\u21911)\u207b\u00b9\n---\ncase inr\nm : \u2115\nhm : m \u2260 1\n\u22a2 schnirelmannDensity {n | n \u2261 1 [MOD m]} = (\u2191m)\u207b\u00b9"}, {"line": "\u00b7 simp [Nat.modEq_one]", "tactic_state": "case inr\nm : \u2115\nhm : m \u2260 1\n\u22a2 schnirelmannDensity {n | n \u2261 1 [MOD m]} = (\u2191m)\u207b\u00b9"}, {"line": "rw [\u2190 schnirelmannDensity_setOf_mod_eq_one hm]", "tactic_state": "case inr\nm : \u2115\nhm : m \u2260 1\n\u22a2 schnirelmannDensity {n | n \u2261 1 [MOD m]} = schnirelmannDensity {n | n % m = 1}"}, {"line": "apply schnirelmannDensity_congr", "tactic_state": "case inr.h\nm : \u2115\nhm : m \u2260 1\n\u22a2 {n | n \u2261 1 [MOD m]} = {n | n % m = 1}"}, {"line": "ext n", "tactic_state": "case inr.h.h\nm : \u2115\nhm : m \u2260 1\nn : \u2115\n\u22a2 n \u2208 {n | n \u2261 1 [MOD m]} \u2194 n \u2208 {n | n % m = 1}"}, {"line": "simp only [Set.mem_setOf_eq]", "tactic_state": "case inr.h.h\nm : \u2115\nhm : m \u2260 1\nn : \u2115\n\u22a2 n \u2261 1 [MOD m] \u2194 n % m = 1"}, {"line": "simp only [Nat.ModEq]", "tactic_state": "case inr.h.h\nm : \u2115\nhm : m \u2260 1\nn : \u2115\n\u22a2 n % m = 1 % m \u2194 n % m = 1"}, {"line": "simp only [Nat.one_mod_eq_one.mpr hm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma schnirelmannDensity_setOf_Odd : schnirelmannDensity (setOf Odd) = 2\u207b\u00b9 := by\n  have h : setOf Odd = {n | n % 2 = 1} := Set.ext fun _ => Nat.odd_iff\n  simp only [h]\n  rw [schnirelmannDensity_setOf_mod_eq_one (by norm_num1)]\n  rw [Nat.cast_two]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Schnirelmann.lean", "context": {"open": ["Finset"], "variables": ["{A : Set \u2115} [DecidablePred (\u00b7 \u2208 A)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 schnirelmannDensity (setOf Odd) = 2\u207b\u00b9"}, {"line": "have h : setOf Odd = {n | n % 2 = 1} := Set.ext fun _ => Nat.odd_iff", "tactic_state": "h : setOf Odd = {n | n % 2 = 1}\n\u22a2 schnirelmannDensity (setOf Odd) = 2\u207b\u00b9"}, {"line": "simp only [h]", "tactic_state": "h : setOf Odd = {n | n % 2 = 1}\n\u22a2 schnirelmannDensity {n | n % 2 = 1} = 2\u207b\u00b9"}, {"line": "rw [schnirelmannDensity_setOf_mod_eq_one (by norm_num1)]", "tactic_state": "h : setOf Odd = {n | n % 2 = 1}\n\u22a2 (\u21912)\u207b\u00b9 = 2\u207b\u00b9"}, {"line": "rw [Nat.cast_two]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_mul_self_le [DecidableEq G] {A : Finset G} (hA : IsApproximateSubgroup K (A : Set G)) :\n    #(A * A) \u2264 K * #A := by simpa [sq] using hA.card_pow_le (n := 2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/ApproximateSubgroup.lean", "context": {"open": ["scoped Finset Pointwise"], "variables": ["{G : Type*} [Group G] {A B : Set G} {K L : \u211d} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nK : \u211d\ninst\u271d : DecidableEq G\nA : Finset G\nhA : IsApproximateSubgroup K \u2191A\n\u22a2 \u2191(A * A).card \u2264 K * \u2191A.card"}, {"line": "simpa [sq] using hA.card_pow_le (n := 2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mulETransformLeft_one : mulETransformLeft 1 x = x := by simp [mulETransformLeft]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/ETransform.lean", "context": {"open": ["MulOpposite", "Pointwise"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1]", "[CommGroup \u03b1] (e : \u03b1) (x : Finset \u03b1 \u00d7 Finset \u03b1)", "{e x}", "[Group \u03b1] (e : \u03b1) (x : Finset \u03b1 \u00d7 Finset \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : CommGroup \u03b1\ninst\u271d : Group \u03b1\nx : Finset \u03b1 \u00d7 Finset \u03b1\nx\u271d : Sort u_2\nmulETransformLeft : x\u271d\n\u22a2 sorry = x"}, {"line": "simp [mulETransformLeft]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : CommGroup \u03b1\ninst\u271d : Group \u03b1\nx : Finset \u03b1 \u00d7 Finset \u03b1\nx\u271d : Sort u_2\nmulETransformLeft : x\u271d\n\u22a2 sorry () = x"}]}
{"declaration": "theorem mulETransformRight_one : mulETransformRight 1 x = x := by simp [mulETransformRight]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/ETransform.lean", "context": {"open": ["MulOpposite", "Pointwise"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1]", "[CommGroup \u03b1] (e : \u03b1) (x : Finset \u03b1 \u00d7 Finset \u03b1)", "{e x}", "[Group \u03b1] (e : \u03b1) (x : Finset \u03b1 \u00d7 Finset \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : CommGroup \u03b1\ninst\u271d : Group \u03b1\nx : Finset \u03b1 \u00d7 Finset \u03b1\nx\u271d : Sort u_2\nmulETransformRight : x\u271d\n\u22a2 sorry = x"}, {"line": "simp [mulETransformRight]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : CommGroup \u03b1\ninst\u271d : Group \u03b1\nx : Finset \u03b1 \u00d7 Finset \u03b1\nx\u271d : Sort u_2\nmulETransformRight : x\u271d\n\u22a2 sorry () = x"}]}
{"declaration": "theorem mulETransformLeft_inv : mulETransformLeft e\u207b\u00b9 x = (mulETransformRight e x.swap).swap := by\n  simp [-op_inv, op_smul_eq_smul, mulETransformLeft, mulETransformRight]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/ETransform.lean", "context": {"open": ["MulOpposite", "Pointwise"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1]", "[CommGroup \u03b1] (e : \u03b1) (x : Finset \u03b1 \u00d7 Finset \u03b1)", "{e x}", "[Group \u03b1] (e : \u03b1) (x : Finset \u03b1 \u00d7 Finset \u03b1)", "[CommGroup \u03b1] (e : \u03b1) (x : Finset \u03b1 \u00d7 Finset \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nmulETransformLeft : x\u271d\u00b9\nx\u271d : Sort u_3\nmulETransformRight : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [-op_inv, op_smul_eq_smul, mulETransformLeft, mulETransformRight]", "tactic_state": "x\u271d\u00b9 : Sort u_2\nmulETransformLeft : x\u271d\u00b9\nx\u271d : Sort u_3\nmulETransformRight : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem mulETransformRight_inv : mulETransformRight e\u207b\u00b9 x = (mulETransformLeft e x.swap).swap := by\n  simp [-op_inv, op_smul_eq_smul, mulETransformLeft, mulETransformRight]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/ETransform.lean", "context": {"open": ["MulOpposite", "Pointwise"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1]", "[CommGroup \u03b1] (e : \u03b1) (x : Finset \u03b1 \u00d7 Finset \u03b1)", "{e x}", "[Group \u03b1] (e : \u03b1) (x : Finset \u03b1 \u00d7 Finset \u03b1)", "[CommGroup \u03b1] (e : \u03b1) (x : Finset \u03b1 \u00d7 Finset \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nmulETransformRight : x\u271d\u00b9\nx\u271d : Sort u_3\nmulETransformLeft : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [-op_inv, op_smul_eq_smul, mulETransformLeft, mulETransformRight]", "tactic_state": "x\u271d\u00b9 : Sort u_2\nmulETransformRight : x\u271d\u00b9\nx\u271d : Sort u_3\nmulETransformLeft : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "private lemma totalDegree_f\u2081_add_totalDegree_f\u2082 {a : \u03b9 \u2192 ZMod p} :\n    (f\u2081 s a).totalDegree + (f\u2082 s a).totalDegree < 2 * p - 1 := by\n  calc\n    _ \u2264 (p - 1) + (p - 1) := by\n      gcongr <;> apply totalDegree_finsetSum_le <;> rintro i _\n      \u00b7 exact (totalDegree_X_pow ..).le\n      \u00b7 exact (totalDegree_smul_le ..).trans (totalDegree_X_pow ..).le\n    _ < 2 * p - 1 := by have := (Fact.out : p.Prime).two_le; omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/ErdosGinzburgZiv.lean", "context": {"open": ["Finset MvPolynomial"], "variables": ["{\u03b9 : Type*}", "{p : \u2115} [Fact p.Prime] {s : Finset \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nx\u271d\u00b9 : Sort u_2\nf\u2081 : x\u271d\u00b9\nx\u271d : Sort u_3\nf\u2082 : x\u271d\na : \u03b9 \u2192 ZMod p\n\u22a2 sorry + sorry < 2 * p - 1"}, {"line": "calc\n    _ \u2264 (p - 1) + (p - 1) := by\n      gcongr <;> apply totalDegree_finsetSum_le <;> rintro i _\n      \u00b7 exact (totalDegree_X_pow ..).le\n      \u00b7 exact (totalDegree_smul_le ..).trans (totalDegree_X_pow ..).le\n    _ < 2 * p - 1 := by have := (Fact.out : p.Prime).two_le; omega", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem Int.erdos_ginzburg_ziv_prime (a : \u03b9 \u2192 \u2124) (hs : #s = 2 * p - 1) :\n    \u2203 t \u2286 s, #t = p \u2227 \u2191p \u2223 \u2211 i \u2208 t, a i := by\n  simpa [\u2190 Int.cast_sum, ZMod.intCast_zmod_eq_zero_iff_dvd]\n    using ZMod.erdos_ginzburg_ziv_prime (Int.cast \u2218 a) hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/ErdosGinzburgZiv.lean", "context": {"open": ["Finset MvPolynomial"], "variables": ["{\u03b9 : Type*}", "{p : \u2115} [Fact p.Prime] {s : Finset \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\ns : Finset \u03b9\na : \u03b9 \u2192 \u2124\nhs : s.card = 2 * p - 1\n\u22a2 \u2203 t \u2286 s, t.card = p \u2227 \u2191p \u2223 \u2211 i \u2208 t, a i"}, {"line": "simpa [\u2190 Int.cast_sum, ZMod.intCast_zmod_eq_zero_iff_dvd]\n    using ZMod.erdos_ginzburg_ziv_prime (Int.cast \u2218 a) hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ZMod.erdos_ginzburg_ziv (a : \u03b9 \u2192 ZMod n) (hs : 2 * n - 1 \u2264 #s) :\n    \u2203 t \u2286 s, #t = n \u2227 \u2211 i \u2208 t, a i = 0 := by\n  simpa [\u2190 ZMod.intCast_zmod_eq_zero_iff_dvd] using Int.erdos_ginzburg_ziv (ZMod.cast \u2218 a) hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/ErdosGinzburgZiv.lean", "context": {"open": ["Finset MvPolynomial"], "variables": ["{\u03b9 : Type*}", "{p : \u2115} [Fact p.Prime] {s : Finset \u03b9}", "{n : \u2115} {s : Finset \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nn : \u2115\ns : Finset \u03b9\na : \u03b9 \u2192 ZMod n\nhs : 2 * n - 1 \u2264 s.card\n\u22a2 \u2203 t \u2286 s, t.card = n \u2227 \u2211 i \u2208 t, a i = 0"}, {"line": "simpa [\u2190 ZMod.intCast_zmod_eq_zero_iff_dvd] using Int.erdos_ginzburg_ziv (ZMod.cast \u2218 a) hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Int.erdos_ginzburg_ziv_multiset (s : Multiset \u2124) (hs : 2 * n - 1 \u2264 Multiset.card s) :\n    \u2203 t \u2264 s, Multiset.card t = n \u2227 \u2191n \u2223 t.sum := by\n  obtain \u27e8t, hts, ht\u27e9 := Int.erdos_ginzburg_ziv (s := s.toEnumFinset) Prod.fst (by simpa using hs)\n  exact \u27e8t.1.map Prod.fst, Multiset.map_fst_le_of_subset_toEnumFinset hts, by simpa using ht\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/ErdosGinzburgZiv.lean", "context": {"open": ["Finset MvPolynomial"], "variables": ["{\u03b9 : Type*}", "{p : \u2115} [Fact p.Prime] {s : Finset \u03b9}", "{n : \u2115} {s : Finset \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ns : Multiset \u2124\nhs : 2 * n - 1 \u2264 s.card\n\u22a2 \u2203 t \u2264 s, t.card = n \u2227 \u2191n \u2223 t.sum"}, {"line": "obtain \u27e8t, hts, ht\u27e9 := Int.erdos_ginzburg_ziv (s := s.toEnumFinset) Prod.fst (by simpa using hs)", "tactic_state": "case intro.intro\nn : \u2115\ns : Multiset \u2124\nhs : 2 * n - 1 \u2264 s.card\nt : Finset (\u2124 \u00d7 \u2115)\nhts : t \u2286 s.toEnumFinset\nht : t.card = n \u2227 \u2191n \u2223 \u2211 i \u2208 t, i.1\n\u22a2 \u2203 t \u2264 s, t.card = n \u2227 \u2191n \u2223 t.sum"}, {"line": "exact \u27e8t.1.map Prod.fst, Multiset.map_fst_le_of_subset_toEnumFinset hts, by simpa using ht\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ZMod.erdos_ginzburg_ziv_multiset (s : Multiset (ZMod n))\n    (hs : 2 * n - 1 \u2264 Multiset.card s) : \u2203 t \u2264 s, Multiset.card t = n \u2227 t.sum = 0 := by\n  obtain \u27e8t, hts, ht\u27e9 := ZMod.erdos_ginzburg_ziv (s := s.toEnumFinset) Prod.fst (by simpa using hs)\n  exact \u27e8t.1.map Prod.fst, Multiset.map_fst_le_of_subset_toEnumFinset hts, by simpa using ht\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/ErdosGinzburgZiv.lean", "context": {"open": ["Finset MvPolynomial"], "variables": ["{\u03b9 : Type*}", "{p : \u2115} [Fact p.Prime] {s : Finset \u03b9}", "{n : \u2115} {s : Finset \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ns : Multiset (ZMod n)\nhs : 2 * n - 1 \u2264 s.card\n\u22a2 \u2203 t \u2264 s, t.card = n \u2227 t.sum = 0"}, {"line": "obtain \u27e8t, hts, ht\u27e9 := ZMod.erdos_ginzburg_ziv (s := s.toEnumFinset) Prod.fst (by simpa using hs)", "tactic_state": "case intro.intro\nn : \u2115\ns : Multiset (ZMod n)\nhs : 2 * n - 1 \u2264 s.card\nt : Finset (ZMod n \u00d7 \u2115)\nhts : t \u2286 s.toEnumFinset\nht : t.card = n \u2227 \u2211 i \u2208 t, i.1 = 0\n\u22a2 \u2203 t \u2264 s, t.card = n \u2227 t.sum = 0"}, {"line": "exact \u27e8t.1.map Prod.fst, Multiset.map_fst_le_of_subset_toEnumFinset hts, by simpa using ht\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma A_subset_aH (a : G) (ha : a \u2208 A) : A \u2286 a \u2022 (A\u207b\u00b9 * A) := by\n  rw [\u2190 smul_mul_assoc]\n  exact subset_mul_right _ (by simp [\u2190 inv_smul_mem_iff, inv_mem_inv ha])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/VerySmallDoubling.lean", "context": {"open": ["MulOpposite MulAction", "scoped Pointwise RightActions"], "variables": ["{G : Type*} [Group G] [DecidableEq G] {A : Finset G} {a : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA : Finset G\na : G\nha : a \u2208 A\n\u22a2 A \u2286 a \u2022 (A\u207b\u00b9 * A)"}, {"line": "rw [\u2190 smul_mul_assoc]", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA : Finset G\na : G\nha : a \u2208 A\n\u22a2 A \u2286 a \u2022 A\u207b\u00b9 * A\n---\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA : Finset G\na : G\nha : a \u2208 A\n\u22a2 IsScalarTower G (Finset G) (Finset G)"}, {"line": "exact subset_mul_right _ (by simp [\u2190 inv_smul_mem_iff, inv_mem_inv ha])", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA : Finset G\na : G\nha : a \u2208 A\n\u22a2 IsScalarTower G (Finset G) (Finset G)"}]}
{"declaration": "private lemma devosMulRel_iff :\n    DevosMulRel x y \u2194\n      #(x.1 * x.2) < #(y.1 * y.2) \u2228\n        #(x.1 * x.2) = #(y.1 * y.2) \u2227 #y.1 + #y.2 < #x.1 + #x.2 \u2228\n          #(x.1 * x.2) = #(y.1 * y.2) \u2227 #x.1 + #x.2 = #y.1 + #y.2 \u2227 #x.1 < #y.1 := by\n  simp [DevosMulRel, Prod.lex_iff, and_or_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/CauchyDavenport.lean", "context": {"open": ["Finset Function Monoid MulOpposite Subgroup", "scoped Pointwise"], "variables": ["{\u03b1 : Type*}", "[Group \u03b1] [DecidableEq \u03b1] {x y : Finset \u03b1 \u00d7 Finset \u03b1} {s t : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : DecidableEq \u03b1\nx y : Finset \u03b1 \u00d7 Finset \u03b1\nx\u271d : Sort u_2\nDevosMulRel : x\u271d\n\u22a2 sorry \u2194\n    (x.1 * x.2).card < (y.1 * y.2).card \u2228\n      (x.1 * x.2).card = (y.1 * y.2).card \u2227 y.1.card + y.2.card < x.1.card + x.2.card \u2228\n        (x.1 * x.2).card = (y.1 * y.2).card \u2227 x.1.card + x.2.card = y.1.card + y.2.card \u2227 x.1.card < y.1.card"}, {"line": "simp [DevosMulRel, Prod.lex_iff, and_or_left]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : DecidableEq \u03b1\nx y : Finset \u03b1 \u00d7 Finset \u03b1\nx\u271d : Sort u_2\nDevosMulRel : x\u271d\n\u22a2 sorry () \u2194\n    (x.1 * x.2).card < (y.1 * y.2).card \u2228\n      (x.1 * x.2).card = (y.1 * y.2).card \u2227 y.1.card + y.2.card < x.1.card + x.2.card \u2228\n        (x.1 * x.2).card = (y.1 * y.2).card \u2227 x.1.card + x.2.card = y.1.card + y.2.card \u2227 x.1.card < y.1.card"}]}
{"declaration": "lemma cauchy_davenport_mul_of_isTorsionFree (h : IsTorsionFree \u03b1)\n    (hs : s.Nonempty) (ht : t.Nonempty) : #s + #t - 1 \u2264 #(s * t) := by\n  simpa only [h.minOrder,min_eq_right,le_top,Nat.cast_le]\n    using cauchy_davenport_minOrder_mul hs ht\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/CauchyDavenport.lean", "context": {"open": ["Finset Function Monoid MulOpposite Subgroup", "scoped Pointwise"], "variables": ["{\u03b1 : Type*}", "[Group \u03b1] [DecidableEq \u03b1] {x y : Finset \u03b1 \u00d7 Finset \u03b1} {s t : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nh : IsTorsionFree \u03b1\nhs : s.Nonempty\nht : t.Nonempty\n\u22a2 s.card + t.card - 1 \u2264 (s * t).card"}, {"line": "simpa only [h.minOrder,min_eq_right,le_top,Nat.cast_le]\n    using cauchy_davenport_minOrder_mul hs ht", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ZMod.cauchy_davenport {p : \u2115} (hp : p.Prime) {s t : Finset (ZMod p)} (hs : s.Nonempty)\n    (ht : t.Nonempty) : min p (#s + #t - 1) \u2264 #(s + t) := by\n  simpa only [ZMod.minOrder_of_prime hp,min_le_iff,Nat.cast_le]\n    using cauchy_davenport_minOrder_add hs ht\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/CauchyDavenport.lean", "context": {"open": ["Finset Function Monoid MulOpposite Subgroup", "scoped Pointwise"], "variables": ["{\u03b1 : Type*}", "[Group \u03b1] [DecidableEq \u03b1] {x y : Finset \u03b1 \u00d7 Finset \u03b1} {s t : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Nat.Prime p\ns t : Finset (ZMod p)\nhs : s.Nonempty\nht : t.Nonempty\n\u22a2 min p (s.card + t.card - 1) \u2264 (s + t).card"}, {"line": "simpa only [ZMod.minOrder_of_prime hp,min_le_iff,Nat.cast_le]\n    using cauchy_davenport_minOrder_add hs ht", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mulDissociated_singleton : MulDissociated ({a} : Set \u03b1) \u2194 a \u2260 1 := by\n  simp [MulDissociated, setOf_or, (Finset.singleton_ne_empty _).symm, -subset_singleton_iff,\n    Finset.coe_subset_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/Dissociation.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} [CommGroup \u03b1] [CommGroup \u03b2]", "{s : Set \u03b1} {t u : Finset \u03b1} {d : \u2115} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommGroup \u03b1\na : \u03b1\n\u22a2 MulDissociated {a} \u2194 a \u2260 1"}, {"line": "simp [MulDissociated, setOf_or, (Finset.singleton_ne_empty _).symm, -subset_singleton_iff,\n    Finset.coe_subset_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mulConst_mul_card (A B : Finset G) : \u03c3\u2098[A, B] * #A = #(A * B) := by\n  obtain rfl | hA := A.eq_empty_or_nonempty\n  \u00b7 simp\n  \u00b7 exact div_mul_cancel\u2080 _ (by positivity)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/DoublingConst.lean", "context": {"open": ["Finset", "scoped Pointwise", "scoped Combinatorics.Additive"], "variables": ["{G G' : Type*} [Group G] [AddGroup G'] [DecidableEq G] [DecidableEq G'] {A B : Finset G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA B : Finset G\n\u22a2 A.mulConst B * \u2191A.card = \u2191(A * B).card"}, {"line": "obtain rfl | hA := A.eq_empty_or_nonempty", "tactic_state": "case inl\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nB : Finset G\n\u22a2 \u2205.mulConst B * \u2191\u2205.card = \u2191(\u2205 * B).card\n---\ncase inr\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA B : Finset G\nhA : A.Nonempty\n\u22a2 A.mulConst B * \u2191A.card = \u2191(A * B).card"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA B : Finset G\nhA : A.Nonempty\n\u22a2 A.mulConst B * \u2191A.card = \u2191(A * B).card"}, {"line": "\u00b7 exact div_mul_cancel\u2080 _ (by positivity)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma divConst_mul_card (A B : Finset G) : \u03b4\u2098[A, B] * #A = #(A / B) := by\n  obtain rfl | hA := A.eq_empty_or_nonempty\n  \u00b7 simp\n  \u00b7 exact div_mul_cancel\u2080 _ (by positivity)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/DoublingConst.lean", "context": {"open": ["Finset", "scoped Pointwise", "scoped Combinatorics.Additive"], "variables": ["{G G' : Type*} [Group G] [AddGroup G'] [DecidableEq G] [DecidableEq G'] {A B : Finset G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA B : Finset G\n\u22a2 A.divConst B * \u2191A.card = \u2191(A / B).card"}, {"line": "obtain rfl | hA := A.eq_empty_or_nonempty", "tactic_state": "case inl\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nB : Finset G\n\u22a2 \u2205.divConst B * \u2191\u2205.card = \u2191(\u2205 / B).card\n---\ncase inr\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA B : Finset G\nhA : A.Nonempty\n\u22a2 A.divConst B * \u2191A.card = \u2191(A / B).card"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA B : Finset G\nhA : A.Nonempty\n\u22a2 A.divConst B * \u2191A.card = \u2191(A / B).card"}, {"line": "\u00b7 exact div_mul_cancel\u2080 _ (by positivity)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_mul_mulConst (A B : Finset G) : #A * \u03c3\u2098[A, B] = #(A * B) := by\n  rw [mul_comm]\n  rw [mulConst_mul_card]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/DoublingConst.lean", "context": {"open": ["Finset", "scoped Pointwise", "scoped Combinatorics.Additive"], "variables": ["{G G' : Type*} [Group G] [AddGroup G'] [DecidableEq G] [DecidableEq G'] {A B : Finset G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA B : Finset G\n\u22a2 \u2191A.card * A.mulConst B = \u2191(A * B).card"}, {"line": "rw [mul_comm]", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA B : Finset G\n\u22a2 A.mulConst B * \u2191A.card = \u2191(A * B).card"}, {"line": "rw [mulConst_mul_card]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_mul_divConst (A B : Finset G) : #A * \u03b4\u2098[A, B] = #(A / B) := by\n  rw [mul_comm]\n  rw [divConst_mul_card]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/DoublingConst.lean", "context": {"open": ["Finset", "scoped Pointwise", "scoped Combinatorics.Additive"], "variables": ["{G G' : Type*} [Group G] [AddGroup G'] [DecidableEq G] [DecidableEq G'] {A B : Finset G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA B : Finset G\n\u22a2 \u2191A.card * A.divConst B = \u2191(A / B).card"}, {"line": "rw [mul_comm]", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA B : Finset G\n\u22a2 A.divConst B * \u2191A.card = \u2191(A / B).card"}, {"line": "rw [divConst_mul_card]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mulConst_empty_left (B : Finset G) : \u03c3\u2098[\u2205, B] = 0 := by simp [mulConst]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/DoublingConst.lean", "context": {"open": ["Finset", "scoped Pointwise", "scoped Combinatorics.Additive"], "variables": ["{G G' : Type*} [Group G] [AddGroup G'] [DecidableEq G] [DecidableEq G'] {A B : Finset G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nB : Finset G\n\u22a2 \u2205.mulConst B = 0"}, {"line": "simp [mulConst]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma divConst_empty_left (B : Finset G) : \u03b4\u2098[\u2205, B] = 0 := by simp [divConst]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/DoublingConst.lean", "context": {"open": ["Finset", "scoped Pointwise", "scoped Combinatorics.Additive"], "variables": ["{G G' : Type*} [Group G] [AddGroup G'] [DecidableEq G] [DecidableEq G'] {A B : Finset G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nB : Finset G\n\u22a2 \u2205.divConst B = 0"}, {"line": "simp [divConst]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mulConst_empty_right (A : Finset G) : \u03c3\u2098[A, \u2205] = 0 := by simp [mulConst]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/DoublingConst.lean", "context": {"open": ["Finset", "scoped Pointwise", "scoped Combinatorics.Additive"], "variables": ["{G G' : Type*} [Group G] [AddGroup G'] [DecidableEq G] [DecidableEq G'] {A B : Finset G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA : Finset G\n\u22a2 A.mulConst \u2205 = 0"}, {"line": "simp [mulConst]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma divConst_empty_right (A : Finset G) : \u03b4\u2098[A, \u2205] = 0 := by simp [divConst]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/DoublingConst.lean", "context": {"open": ["Finset", "scoped Pointwise", "scoped Combinatorics.Additive"], "variables": ["{G G' : Type*} [Group G] [AddGroup G'] [DecidableEq G] [DecidableEq G'] {A B : Finset G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA : Finset G\n\u22a2 A.divConst \u2205 = 0"}, {"line": "simp [divConst]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cast_addConst (A B : Finset G') : (\u03c3[A, B] : \ud835\udd5c) = #(A + B) / #A := by\n  simp [addConst]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/DoublingConst.lean", "context": {"open": ["Finset", "scoped Pointwise", "scoped Combinatorics.Additive"], "variables": ["{G G' : Type*} [Group G] [AddGroup G'] [DecidableEq G] [DecidableEq G'] {A B : Finset G}", "[Fintype G]", "{\ud835\udd5c : Type*} [Semifield \ud835\udd5c] [CharZero \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G' : Type u_2\ninst\u271d\u00b3 : AddGroup G'\ninst\u271d\u00b2 : DecidableEq G'\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Semifield \ud835\udd5c\ninst\u271d : CharZero \ud835\udd5c\nA B : Finset G'\n\u22a2 \u2191(A.addConst B) = \u2191(A + B).card / \u2191A.card"}, {"line": "simp [addConst]", "tactic_state": "G' : Type u_2\ninst\u271d\u00b3 : AddGroup G'\ninst\u271d\u00b2 : DecidableEq G'\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Semifield \ud835\udd5c\ninst\u271d : CharZero \ud835\udd5c\nA B : Finset G'\n\u22a2 \u2191(\u2191(A + B).card / \u2191A.card) = \u2191(A + B).card / \u2191A.card"}]}
{"declaration": "lemma cast_subConst (A B : Finset G') : (\u03b4[A, B] : \ud835\udd5c) = #(A - B) / #A := by\n  simp [subConst]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/DoublingConst.lean", "context": {"open": ["Finset", "scoped Pointwise", "scoped Combinatorics.Additive"], "variables": ["{G G' : Type*} [Group G] [AddGroup G'] [DecidableEq G] [DecidableEq G'] {A B : Finset G}", "[Fintype G]", "{\ud835\udd5c : Type*} [Semifield \ud835\udd5c] [CharZero \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G' : Type u_2\ninst\u271d\u00b3 : AddGroup G'\ninst\u271d\u00b2 : DecidableEq G'\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Semifield \ud835\udd5c\ninst\u271d : CharZero \ud835\udd5c\nA B : Finset G'\n\u22a2 \u2191(A.subConst B) = \u2191(A - B).card / \u2191A.card"}, {"line": "simp [subConst]", "tactic_state": "G' : Type u_2\ninst\u271d\u00b3 : AddGroup G'\ninst\u271d\u00b2 : DecidableEq G'\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Semifield \ud835\udd5c\ninst\u271d : CharZero \ud835\udd5c\nA B : Finset G'\n\u22a2 \u2191(\u2191(A - B).card / \u2191A.card) = \u2191(A - B).card / \u2191A.card"}]}
{"declaration": "lemma cast_divConst (A B : Finset G) : (\u03b4\u2098[A, B] : \ud835\udd5c) = #(A / B) / #A := by simp [divConst]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/DoublingConst.lean", "context": {"open": ["Finset", "scoped Pointwise", "scoped Combinatorics.Additive"], "variables": ["{G G' : Type*} [Group G] [AddGroup G'] [DecidableEq G] [DecidableEq G'] {A B : Finset G}", "[Fintype G]", "{\ud835\udd5c : Type*} [Semifield \ud835\udd5c] [CharZero \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : DecidableEq G\ninst\u271d\u00b2 : Fintype G\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Semifield \ud835\udd5c\ninst\u271d : CharZero \ud835\udd5c\nA B : Finset G\n\u22a2 \u2191(A.divConst B) = \u2191(A / B).card / \u2191A.card"}, {"line": "simp [divConst]", "tactic_state": "G : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : DecidableEq G\ninst\u271d\u00b2 : Fintype G\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Semifield \ud835\udd5c\ninst\u271d : CharZero \ud835\udd5c\nA B : Finset G\n\u22a2 \u2191(\u2191(A / B).card / \u2191A.card) = \u2191(A / B).card / \u2191A.card"}]}
{"declaration": "lemma isMulFreimanHom_const {b : \u03b2} (hb : b \u2208 B) : IsMulFreimanHom n A B fun _ \u21a6 b where\n  mapsTo _ _ := hb\n  map_prod_eq_map_prod s t _ _ hs ht _ := by simp only [map_const', hs, prod_replicate, ht]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/FreimanHom.lean", "context": {"open": ["Multiset Set", "scoped Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [CommMonoid \u03b2] [CommMonoid \u03b3] {A A\u2081 A\u2082 : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : CommMonoid \u03b2\nA : Set \u03b1\nB : Set \u03b2\nn : \u2115\nb : \u03b2\nhb : b \u2208 B\ns t : Multiset \u03b1\nx\u271d\u00b2 : \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 x \u2208 A\nx\u271d\u00b9 : \u2200 \u2983x : \u03b1\u2984, x \u2208 t \u2192 x \u2208 A\nhs : s.card = n\nht : t.card = n\nx\u271d : s.prod = t.prod\n\u22a2 (map (fun x => b) s).prod = (map (fun x => b) t).prod"}, {"line": "simp only [map_const', hs, prod_replicate, ht]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isMulFreimanIso_empty : IsMulFreimanIso n (\u2205 : Set \u03b1) (\u2205 : Set \u03b2) f where\n  bijOn := bijOn_empty _\n  map_prod_eq_map_prod s t hs ht := by\n    simp [eq_zero_of_forall_not_mem hs, eq_zero_of_forall_not_mem ht]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/FreimanHom.lean", "context": {"open": ["Multiset Set", "scoped Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [CommMonoid \u03b2] [CommMonoid \u03b3] {A A\u2081 A\u2082 : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : CommMonoid \u03b2\nn : \u2115\nf : \u03b1 \u2192 \u03b2\ns t : Multiset \u03b1\nhs : \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 x \u2208 \u2205\nht : \u2200 \u2983x : \u03b1\u2984, x \u2208 t \u2192 x \u2208 \u2205\n\u22a2 s.card = n \u2192 t.card = n \u2192 ((map f s).prod = (map f t).prod \u2194 s.prod = t.prod)"}, {"line": "simp [eq_zero_of_forall_not_mem hs, eq_zero_of_forall_not_mem ht]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem box_zero : box (n + 1) 0 = \u2205 := by simp [box]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/AP/Three/Behrend.lean", "context": {"open": ["Nat hiding log", "Finset Metric Real", "scoped Pointwise"], "variables": ["{n d k N : \u2115} {x : Fin n \u2192 \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = \u2205"}, {"line": "simp [box]", "tactic_state": "\u22a2 sorry () = \u2205"}]}
{"declaration": "theorem sphere_zero_right (n k : \u2115) : sphere (n + 1) 0 k = \u2205 := by simp [sphere]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/AP/Three/Behrend.lean", "context": {"open": ["Nat hiding log", "Finset Metric Real", "scoped Pointwise"], "variables": ["{n d k N : \u2115} {x : Fin n \u2192 \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\n\u22a2 sphere (n + 1) 0 k = \u2205"}, {"line": "simp [sphere]", "tactic_state": "n k : \u2115\n\u22a2 {n + 1} k = \u2205"}]}
{"declaration": "theorem sum_eq : (\u2211 i : Fin n, d * (2 * d + 1) ^ (i : \u2115)) = ((2 * d + 1) ^ n - 1) / 2 := by\n  refine (Nat.div_eq_of_eq_mul_left zero_lt_two ?_).symm\n  rw [\u2190 sum_range fun i => d * (2 * d + 1) ^ (i : \u2115)]\n  rw [\u2190 mul_sum]\n  rw [mul_right_comm]\n  rw [mul_comm d]\n  rw [\u2190     geom_sum_mul_add]\n  rw [add_tsub_cancel_right]\n  rw [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/AP/Three/Behrend.lean", "context": {"open": ["Nat hiding log", "Finset Metric Real", "scoped Pointwise"], "variables": ["{n d k N : \u2115} {x : Fin n \u2192 \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n d : \u2115\n\u22a2 \u2211 i, d * (2 * d + 1) ^ \u2191i = ((2 * d + 1) ^ n - 1) / 2"}, {"line": "refine (Nat.div_eq_of_eq_mul_left zero_lt_two ?_).symm", "tactic_state": "n d : \u2115\n\u22a2 (2 * d + 1) ^ n - 1 = (\u2211 i, d * (2 * d + 1) ^ \u2191i) * 2"}, {"line": "rw [\u2190 sum_range fun i => d * (2 * d + 1) ^ (i : \u2115)]", "tactic_state": "n d : \u2115\n\u22a2 (2 * d + 1) ^ n - 1 = (\u2211 i \u2208 range n, d * (2 * d + 1) ^ i) * 2"}, {"line": "rw [\u2190 mul_sum]", "tactic_state": "n d : \u2115\n\u22a2 (2 * d + 1) ^ n - 1 = (d * \u2211 i \u2208 range n, (2 * d + 1) ^ i) * 2"}, {"line": "rw [mul_right_comm]", "tactic_state": "n d : \u2115\n\u22a2 (2 * d + 1) ^ n - 1 = d * 2 * \u2211 i \u2208 range n, (2 * d + 1) ^ i"}, {"line": "rw [mul_comm d]", "tactic_state": "n d : \u2115\n\u22a2 (2 * d + 1) ^ n - 1 = 2 * d * \u2211 i \u2208 range n, (2 * d + 1) ^ i"}, {"line": "rw [\u2190     geom_sum_mul_add]", "tactic_state": "n d : \u2115\n\u22a2 (\u2211 i \u2208 range n, (2 * d + 1) ^ i) * (2 * d) + 1 - 1 = 2 * d * \u2211 i \u2208 range n, (2 * d + 1) ^ i"}, {"line": "rw [add_tsub_cancel_right]", "tactic_state": "n d : \u2115\n\u22a2 (\u2211 i \u2208 range n, (2 * d + 1) ^ i) * (2 * d) = 2 * d * \u2211 i \u2208 range n, (2 * d + 1) ^ i"}, {"line": "rw [mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem log_two_mul_two_le_sqrt_log_eight : log 2 * 2 \u2264 \u221a(log 8) := by\n  have : (8 : \u211d) = 2 ^ ((3 : \u2115) : \u211d) := by rw [rpow_natCast]; norm_num\n  rw [this]\n  rw [log_rpow zero_lt_two (3 : \u2115)]\n  apply le_sqrt_of_sq_le\n  rw [mul_pow]\n  rw [sq (log 2)]\n  rw [mul_assoc]\n  rw [mul_comm]\n  refine mul_le_mul_of_nonneg_right ?_ (log_nonneg one_le_two)\n  rw [\u2190 le_div_iff\u2080]\n  on_goal 1 => apply log_two_lt_d9.le.trans\n  all_goals norm_num1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/AP/Three/Behrend.lean", "context": {"open": ["Nat hiding log", "Finset Metric Real", "scoped Pointwise", "scoped Filter Topology", "Real"], "variables": ["{n d k N : \u2115} {x : Fin n \u2192 \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 log 2 * 2 \u2264 \u221a(log 8)"}, {"line": "have : (8 : \u211d) = 2 ^ ((3 : \u2115) : \u211d) := by rw [rpow_natCast]; norm_num", "tactic_state": "this : 8 = 2 ^ \u21913\n\u22a2 log 2 * 2 \u2264 \u221a(log 8)"}, {"line": "rw [this]", "tactic_state": "this : 8 = 2 ^ \u21913\n\u22a2 log 2 * 2 \u2264 \u221a(log (2 ^ \u21913))"}, {"line": "rw [log_rpow zero_lt_two (3 : \u2115)]", "tactic_state": "this : 8 = 2 ^ \u21913\n\u22a2 log 2 * 2 \u2264 \u221a(\u21913 * log 2)"}, {"line": "apply le_sqrt_of_sq_le", "tactic_state": "case h\nthis : 8 = 2 ^ \u21913\n\u22a2 (log 2 * 2) ^ 2 \u2264 \u21913 * log 2"}, {"line": "rw [mul_pow]", "tactic_state": "case h\nthis : 8 = 2 ^ \u21913\n\u22a2 log 2 ^ 2 * 2 ^ 2 \u2264 \u21913 * log 2"}, {"line": "rw [sq (log 2)]", "tactic_state": "case h\nthis : 8 = 2 ^ \u21913\n\u22a2 log 2 * log 2 * 2 ^ 2 \u2264 \u21913 * log 2"}, {"line": "rw [mul_assoc]", "tactic_state": "case h\nthis : 8 = 2 ^ \u21913\n\u22a2 log 2 * (log 2 * 2 ^ 2) \u2264 \u21913 * log 2"}, {"line": "rw [mul_comm]", "tactic_state": "case h\nthis : 8 = 2 ^ \u21913\n\u22a2 log 2 * 2 ^ 2 * log 2 \u2264 \u21913 * log 2"}, {"line": "refine mul_le_mul_of_nonneg_right ?_ (log_nonneg one_le_two)", "tactic_state": "case h\nthis : 8 = 2 ^ \u21913\n\u22a2 log 2 * 2 ^ 2 \u2264 \u21913"}, {"line": "rw [\u2190 le_div_iff\u2080]", "tactic_state": "case h\nthis : 8 = 2 ^ \u21913\n\u22a2 log 2 \u2264 \u21913 / 2 ^ 2\n---\ncase h\nthis : 8 = 2 ^ \u21913\n\u22a2 0 < 2 ^ 2"}, {"line": "on_goal 1 => apply log_two_lt_d9.le.trans", "tactic_state": "case h\nthis : 8 = 2 ^ \u21913\n\u22a2 0.6931471808 \u2264 \u21913 / 2 ^ 2\n---\ncase h\nthis : 8 = 2 ^ \u21913\n\u22a2 0 < 2 ^ 2"}, {"line": "all_goals norm_num1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_neg_two_mul_le {x : \u211d} (hx : 0 < x) : exp (-2 * x) < exp (2 - \u2308x\u2309\u208a) / \u2308x\u2309\u208a := by\n  have h\u2081 := ceil_lt_add_one hx.le\n  have h\u2082 : 1 - x \u2264 2 - \u2308x\u2309\u208a := by linarith\n  calc\n    _ \u2264 exp (1 - x) / (x + 1) := ?_\n    _ \u2264 exp (2 - \u2308x\u2309\u208a) / (x + 1) := by gcongr\n    _ < _ := by gcongr\n  rw [le_div_iff\u2080  (add_pos hx zero_lt_one)]\n  rw [\u2190 le_div_iff\u2080' (exp_pos _)]\n  rw [\u2190 exp_sub]\n  rw [neg_mul]\n  rw [sub_neg_eq_add]\n  rw [two_mul]\n  rw [sub_add_add_cancel]\n  rw [add_comm _ x]\n  exact le_trans (le_add_of_nonneg_right zero_le_one) (add_one_le_exp _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/AP/Three/Behrend.lean", "context": {"open": ["Nat hiding log", "Finset Metric Real", "scoped Pointwise", "scoped Filter Topology", "Real"], "variables": ["{n d k N : \u2115} {x : Fin n \u2192 \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 < x\n\u22a2 exp (-2 * x) < exp (2 - \u2191\u2308x\u2309\u208a) / \u2191\u2308x\u2309\u208a"}, {"line": "have h\u2081 := ceil_lt_add_one hx.le", "tactic_state": "x : \u211d\nhx : 0 < x\nh\u2081 : \u2191\u2308x\u2309\u208a < x + 1\n\u22a2 exp (-2 * x) < exp (2 - \u2191\u2308x\u2309\u208a) / \u2191\u2308x\u2309\u208a"}, {"line": "have h\u2082 : 1 - x \u2264 2 - \u2308x\u2309\u208a := sorry", "tactic_state": "x : \u211d\nhx : 0 < x\nh\u2081 : \u2191\u2308x\u2309\u208a < x + 1\nh\u2082 : 1 - x \u2264 2 - \u2191\u2308x\u2309\u208a\n\u22a2 exp (-2 * x) < exp (2 - \u2191\u2308x\u2309\u208a) / \u2191\u2308x\u2309\u208a"}, {"line": "calc\n    _ \u2264 exp (1 - x) / (x + 1) := ?_\n    _ \u2264 exp (2 - \u2308x\u2309\u208a) / (x + 1) := by gcongr\n    _ < _ := by gcongr", "tactic_state": "x : \u211d\nhx : 0 < x\nh\u2081 : \u2191\u2308x\u2309\u208a < x + 1\nh\u2082 : 1 - x \u2264 2 - \u2191\u2308x\u2309\u208a\n\u22a2 exp (-2 * x) \u2264 exp (1 - x) / (x + 1)"}, {"line": "rw [le_div_iff\u2080  (add_pos hx zero_lt_one)]", "tactic_state": "x : \u211d\nhx : 0 < x\nh\u2081 : \u2191\u2308x\u2309\u208a < x + 1\nh\u2082 : 1 - x \u2264 2 - \u2191\u2308x\u2309\u208a\n\u22a2 exp (-2 * x) * (x + 1) \u2264 exp (1 - x)"}, {"line": "rw [\u2190 le_div_iff\u2080' (exp_pos _)]", "tactic_state": "x : \u211d\nhx : 0 < x\nh\u2081 : \u2191\u2308x\u2309\u208a < x + 1\nh\u2082 : 1 - x \u2264 2 - \u2191\u2308x\u2309\u208a\n\u22a2 x + 1 \u2264 exp (1 - x) / exp (-2 * x)"}, {"line": "rw [\u2190 exp_sub]", "tactic_state": "x : \u211d\nhx : 0 < x\nh\u2081 : \u2191\u2308x\u2309\u208a < x + 1\nh\u2082 : 1 - x \u2264 2 - \u2191\u2308x\u2309\u208a\n\u22a2 x + 1 \u2264 exp (1 - x - -2 * x)"}, {"line": "rw [neg_mul]", "tactic_state": "x : \u211d\nhx : 0 < x\nh\u2081 : \u2191\u2308x\u2309\u208a < x + 1\nh\u2082 : 1 - x \u2264 2 - \u2191\u2308x\u2309\u208a\n\u22a2 x + 1 \u2264 exp (1 - x - -(2 * x))"}, {"line": "rw [sub_neg_eq_add]", "tactic_state": "x : \u211d\nhx : 0 < x\nh\u2081 : \u2191\u2308x\u2309\u208a < x + 1\nh\u2082 : 1 - x \u2264 2 - \u2191\u2308x\u2309\u208a\n\u22a2 x + 1 \u2264 exp (1 - x + 2 * x)"}, {"line": "rw [two_mul]", "tactic_state": "x : \u211d\nhx : 0 < x\nh\u2081 : \u2191\u2308x\u2309\u208a < x + 1\nh\u2082 : 1 - x \u2264 2 - \u2191\u2308x\u2309\u208a\n\u22a2 x + 1 \u2264 exp (1 - x + (x + x))"}, {"line": "rw [sub_add_add_cancel]", "tactic_state": "x : \u211d\nhx : 0 < x\nh\u2081 : \u2191\u2308x\u2309\u208a < x + 1\nh\u2082 : 1 - x \u2264 2 - \u2191\u2308x\u2309\u208a\n\u22a2 x + 1 \u2264 exp (1 + x)"}, {"line": "rw [add_comm _ x]", "tactic_state": "x : \u211d\nhx : 0 < x\nh\u2081 : \u2191\u2308x\u2309\u208a < x + 1\nh\u2082 : 1 - x \u2264 2 - \u2191\u2308x\u2309\u208a\n\u22a2 x + 1 \u2264 exp (x + 1)"}, {"line": "exact le_trans (le_add_of_nonneg_right zero_le_one) (add_one_le_exp _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_N (hN : 2 \u2264 N) : (2 * dValue N - 1) ^ nValue N \u2264 N := by\n  have : (2 * dValue N - 1) ^ nValue N \u2264 (2 * dValue N) ^ nValue N :=\n    Nat.pow_le_pow_left (Nat.sub_le _ _) _\n  apply this.trans\n  suffices ((2 * dValue N) ^ nValue N : \u211d) \u2264 N from mod_cast this\n  suffices i : (2 * dValue N : \u211d) \u2264 (N : \u211d) ^ (nValue N : \u211d)\u207b\u00b9 by\n    rw [\u2190 rpow_natCast]\n    apply (rpow_le_rpow (mul_nonneg zero_le_two (cast_nonneg _)) i (cast_nonneg _)).trans\n    rw [\u2190 rpow_mul (cast_nonneg _)]\n    rw [inv_mul_cancel\u2080]\n    rw [rpow_one]\n    rw [cast_ne_zero]\n    apply (nValue_pos hN).ne'\n  rw [\u2190 le_div_iff\u2080']\n  \u00b7 exact floor_le (div_nonneg (rpow_nonneg (cast_nonneg _) _) zero_le_two)\n  apply zero_lt_two\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/AP/Three/Behrend.lean", "context": {"open": ["Nat hiding log", "Finset Metric Real", "scoped Pointwise", "scoped Filter Topology", "Real"], "variables": ["{n d k N : \u2115} {x : Fin n \u2192 \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\nx\u271d\u00b9 : Sort u_1\ndValue : x\u271d\u00b9\nx\u271d : Sort u_2\nnValue : x\u271d\nhN : 2 \u2264 N\n\u22a2 (2 * sorry - 1) ^ sorry \u2264 N"}, {"line": "have : (2 * dValue N - 1) ^ nValue N \u2264 (2 * dValue N) ^ nValue N :=\n    Nat.pow_le_pow_left (Nat.sub_le _ _) _", "tactic_state": "N : \u2115\nx\u271d\u00b9 : Sort u_1\ndValue : x\u271d\u00b9\nx\u271d : Sort u_2\nnValue : x\u271d\nhN : 2 \u2264 N\nthis : (2 * sorry - 1) ^ sorry \u2264 (2 * sorry) ^ sorry\n\u22a2 (2 * sorry - 1) ^ sorry \u2264 N"}, {"line": "apply this.trans", "tactic_state": "N : \u2115\nx\u271d\u00b9 : Sort u_1\ndValue : x\u271d\u00b9\nx\u271d : Sort u_2\nnValue : x\u271d\nhN : 2 \u2264 N\nthis : (2 * sorry - 1) ^ sorry \u2264 (2 * sorry) ^ sorry\n\u22a2 (2 * sorry) ^ sorry \u2264 N"}, {"line": "suffices ((2 * dValue N) ^ nValue N : \u211d) \u2264 N from mod_cast this", "tactic_state": "N : \u2115\nx\u271d\u00b9 : Sort u_1\ndValue : x\u271d\u00b9\nx\u271d : Sort u_2\nnValue : x\u271d\nhN : 2 \u2264 N\nthis : (2 * sorry - 1) ^ sorry \u2264 (2 * sorry) ^ sorry\n\u22a2 (2 * sorry) ^ sorry \u2264 \u2191N"}, {"line": "suffices i : (2 * dValue N : \u211d) \u2264 (N : \u211d) ^ (nValue N : \u211d)\u207b\u00b9 by\n    rw [\u2190 rpow_natCast]\n    apply (rpow_le_rpow (mul_nonneg zero_le_two (cast_nonneg _)) i (cast_nonneg _)).trans\n    rw [\u2190 rpow_mul (cast_nonneg _)]\n    rw [inv_mul_cancel\u2080]\n    rw [rpow_one]\n    rw [cast_ne_zero]\n    apply (nValue_pos hN).ne'", "tactic_state": "N : \u2115\nx\u271d\u00b9 : Sort u_1\ndValue : x\u271d\u00b9\nx\u271d : Sort u_2\nnValue : x\u271d\nhN : 2 \u2264 N\nthis : (2 * sorry - 1) ^ sorry \u2264 (2 * sorry) ^ sorry\n\u22a2 2 * sorry \u2264 \u2191N ^ sorry\u207b\u00b9"}, {"line": "rw [\u2190 le_div_iff\u2080']", "tactic_state": "N : \u2115\nx\u271d\u00b9 : Sort u_1\ndValue : x\u271d\u00b9\nx\u271d : Sort u_2\nnValue : x\u271d\nhN : 2 \u2264 N\nthis : (2 * sorry - 1) ^ sorry \u2264 (2 * sorry) ^ sorry\n\u22a2 sorry \u2264 \u2191N ^ sorry\u207b\u00b9 / 2\n---\nN : \u2115\nx\u271d\u00b9 : Sort u_1\ndValue : x\u271d\u00b9\nx\u271d : Sort u_2\nnValue : x\u271d\nhN : 2 \u2264 N\nthis : (2 * sorry - 1) ^ sorry \u2264 (2 * sorry) ^ sorry\n\u22a2 0 < 2"}, {"line": "\u00b7 exact floor_le (div_nonneg (rpow_nonneg (cast_nonneg _) _) zero_le_two)", "tactic_state": "N : \u2115\nx\u271d\u00b9 : Sort u_1\ndValue : x\u271d\u00b9\nx\u271d : Sort u_2\nnValue : x\u271d\nhN : 2 \u2264 N\nthis : (2 * sorry - 1) ^ sorry \u2264 (2 * sorry) ^ sorry\n\u22a2 0 < 2"}, {"line": "apply zero_lt_two", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_four_lt : exp 4 < 64 := by\n  rw [show (64 : \u211d) = 2 ^ ((6 : \u2115) : \u211d) by rw [rpow_natCast]; norm_num1,\n    \u2190 lt_log_iff_exp_lt (rpow_pos_of_pos zero_lt_two _), log_rpow zero_lt_two, \u2190 div_lt_iff\u2080']\n  \u00b7 exact log_two_gt_d9.trans_le' (by norm_num1)\n  \u00b7 norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/AP/Three/Behrend.lean", "context": {"open": ["Nat hiding log", "Finset Metric Real", "scoped Pointwise", "scoped Filter Topology", "Real"], "variables": ["{n d k N : \u2115} {x : Fin n \u2192 \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 exp 4 < 64"}, {"line": "rw [show (64 : \u211d) = 2 ^ ((6 : \u2115) : \u211d) by rw [rpow_natCast]; norm_num1,\n    \u2190 lt_log_iff_exp_lt (rpow_pos_of_pos zero_lt_two _), log_rpow zero_lt_two, \u2190 div_lt_iff\u2080']", "tactic_state": "\u22a2 4 / \u21916 < log 2\n---\n\u22a2 0 < \u21916"}, {"line": "\u00b7 exact log_two_gt_d9.trans_le' (by norm_num1)", "tactic_state": "\u22a2 0 < \u21916"}, {"line": "\u00b7 norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem four_zero_nine_six_lt_exp_sixteen : 4096 < exp 16 := by\n  rw [\u2190 log_lt_iff_lt_exp (show (0 : \u211d) < 4096 by norm_num)]\n  rw [show (4096 : \u211d) = 2 ^ 12 by norm_cast]\n  rw [\u2190 rpow_natCast]\n  rw [log_rpow zero_lt_two]\n  rw [cast_ofNat]\n  linarith [log_two_lt_d9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/AP/Three/Behrend.lean", "context": {"open": ["Nat hiding log", "Finset Metric Real", "scoped Pointwise", "scoped Filter Topology", "Real"], "variables": ["{n d k N : \u2115} {x : Fin n \u2192 \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 4096 < exp 16"}, {"line": "rw [\u2190 log_lt_iff_lt_exp (show (0 : \u211d) < 4096 by norm_num)]", "tactic_state": "\u22a2 log 4096 < 16"}, {"line": "rw [show (4096 : \u211d) = 2 ^ 12 by norm_cast]", "tactic_state": "\u22a2 log (2 ^ 12) < 16"}, {"line": "rw [\u2190 rpow_natCast]", "tactic_state": "\u22a2 log (2 ^ \u219112) < 16"}, {"line": "rw [log_rpow zero_lt_two]", "tactic_state": "\u22a2 \u219112 * log 2 < 16"}, {"line": "rw [cast_ofNat]", "tactic_state": "\u22a2 12 * log 2 < 16"}, {"line": "linarith [log_two_lt_d9]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lower_bound_le_one' (hN : 2 \u2264 N) (hN' : N \u2264 4096) :\n    (N : \u211d) * exp (-4 * \u221a(log N)) \u2264 1 := by\n  rw [\u2190 log_le_log_iff (mul_pos (cast_pos.2 (zero_lt_two.trans_le hN)) (exp_pos _)) zero_lt_one]\n  rw [log_one]\n  rw [log_mul (cast_pos.2 (zero_lt_two.trans_le hN)).ne' (exp_pos _).ne']\n  rw [log_exp]\n  rw [neg_mul]\n  rw [\u2190     sub_eq_add_neg]\n  rw [sub_nonpos]\n  rw [\u2190     div_le_iff\u2080 (Real.sqrt_pos.2 <| log_pos <| one_lt_cast.2 <| one_lt_two.trans_le hN)]\n  rw [div_sqrt]\n  rw [sqrt_le_left zero_le_four]\n  rw [log_le_iff_le_exp (cast_pos.2 (zero_lt_two.trans_le hN))]\n  norm_num1\n  apply le_trans _ four_zero_nine_six_lt_exp_sixteen.le\n  exact mod_cast hN'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/AP/Three/Behrend.lean", "context": {"open": ["Nat hiding log", "Finset Metric Real", "scoped Pointwise", "scoped Filter Topology", "Real"], "variables": ["{n d k N : \u2115} {x : Fin n \u2192 \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\nhN : 2 \u2264 N\nhN' : N \u2264 4096\n\u22a2 \u2191N * exp (-4 * \u221a(log \u2191N)) \u2264 1"}, {"line": "rw [\u2190 log_le_log_iff (mul_pos (cast_pos.2 (zero_lt_two.trans_le hN)) (exp_pos _)) zero_lt_one]", "tactic_state": "N : \u2115\nhN : 2 \u2264 N\nhN' : N \u2264 4096\n\u22a2 log (\u2191N * exp (-4 * \u221a(log \u2191N))) \u2264 log 1"}, {"line": "rw [log_one]", "tactic_state": "N : \u2115\nhN : 2 \u2264 N\nhN' : N \u2264 4096\n\u22a2 log (\u2191N * exp (-4 * \u221a(log \u2191N))) \u2264 0"}, {"line": "rw [log_mul (cast_pos.2 (zero_lt_two.trans_le hN)).ne' (exp_pos _).ne']", "tactic_state": "N : \u2115\nhN : 2 \u2264 N\nhN' : N \u2264 4096\n\u22a2 log \u2191N + log (exp (-4 * \u221a(log \u2191N))) \u2264 0"}, {"line": "rw [log_exp]", "tactic_state": "N : \u2115\nhN : 2 \u2264 N\nhN' : N \u2264 4096\n\u22a2 log \u2191N + -4 * \u221a(log \u2191N) \u2264 0"}, {"line": "rw [neg_mul]", "tactic_state": "N : \u2115\nhN : 2 \u2264 N\nhN' : N \u2264 4096\n\u22a2 log \u2191N + -(4 * \u221a(log \u2191N)) \u2264 0"}, {"line": "rw [\u2190     sub_eq_add_neg]", "tactic_state": "N : \u2115\nhN : 2 \u2264 N\nhN' : N \u2264 4096\n\u22a2 log \u2191N - 4 * \u221a(log \u2191N) \u2264 0"}, {"line": "rw [sub_nonpos]", "tactic_state": "N : \u2115\nhN : 2 \u2264 N\nhN' : N \u2264 4096\n\u22a2 log \u2191N \u2264 4 * \u221a(log \u2191N)"}, {"line": "rw [\u2190     div_le_iff\u2080 (Real.sqrt_pos.2 <| log_pos <| one_lt_cast.2 <| one_lt_two.trans_le hN)]", "tactic_state": "N : \u2115\nhN : 2 \u2264 N\nhN' : N \u2264 4096\n\u22a2 log \u2191N / \u221a(log \u2191N) \u2264 4"}, {"line": "rw [div_sqrt]", "tactic_state": "N : \u2115\nhN : 2 \u2264 N\nhN' : N \u2264 4096\n\u22a2 \u221a(log \u2191N) \u2264 4"}, {"line": "rw [sqrt_le_left zero_le_four]", "tactic_state": "N : \u2115\nhN : 2 \u2264 N\nhN' : N \u2264 4096\n\u22a2 log \u2191N \u2264 4 ^ 2"}, {"line": "rw [log_le_iff_le_exp (cast_pos.2 (zero_lt_two.trans_le hN))]", "tactic_state": "N : \u2115\nhN : 2 \u2264 N\nhN' : N \u2264 4096\n\u22a2 \u2191N \u2264 exp (4 ^ 2)"}, {"line": "norm_num1", "tactic_state": "N : \u2115\nhN : 2 \u2264 N\nhN' : N \u2264 4096\n\u22a2 \u2191N \u2264 exp 16"}, {"line": "apply le_trans _ four_zero_nine_six_lt_exp_sixteen.le", "tactic_state": "N : \u2115\nhN : 2 \u2264 N\nhN' : N \u2264 4096\n\u22a2 \u211d\n---\nN : \u2115\nhN : 2 \u2264 N\nhN' : N \u2264 4096\n\u22a2 \u2191N \u2264 ?m.11390"}, {"line": "exact mod_cast hN'", "tactic_state": "N : \u2115\nhN : 2 \u2264 N\nhN' : N \u2264 4096\n\u22a2 \u2191N \u2264 sorry"}]}
{"declaration": "theorem lower_bound_le_one (hN : 1 \u2264 N) (hN' : N \u2264 4096) :\n    (N : \u211d) * exp (-4 * \u221a(log N)) \u2264 1 := by\n  obtain rfl | hN := hN.eq_or_lt\n  \u00b7 norm_num\n  \u00b7 exact lower_bound_le_one' hN hN'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/AP/Three/Behrend.lean", "context": {"open": ["Nat hiding log", "Finset Metric Real", "scoped Pointwise", "scoped Filter Topology", "Real"], "variables": ["{n d k N : \u2115} {x : Fin n \u2192 \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\nhN : 1 \u2264 N\nhN' : N \u2264 4096\n\u22a2 \u2191N * exp (-4 * \u221a(log \u2191N)) \u2264 1"}, {"line": "obtain rfl | hN := hN.eq_or_lt", "tactic_state": "case inl\nhN : 1 \u2264 1\nhN' : 1 \u2264 4096\n\u22a2 \u21911 * exp (-4 * \u221a(log \u21911)) \u2264 1\n---\ncase inr\nN : \u2115\nhN\u271d : 1 \u2264 N\nhN' : N \u2264 4096\nhN : 1 < N\n\u22a2 \u2191N * exp (-4 * \u221a(log \u2191N)) \u2264 1"}, {"line": "\u00b7 norm_num", "tactic_state": "case inr\nN : \u2115\nhN\u271d : 1 \u2264 N\nhN' : N \u2264 4096\nhN : 1 < N\n\u22a2 \u2191N * exp (-4 * \u221a(log \u2191N)) \u2264 1"}, {"line": "\u00b7 exact lower_bound_le_one' hN hN'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ThreeGPFree.smul_set (hs : ThreeGPFree s) : ThreeGPFree (a \u2022 s) := by\n  rintro _ \u27e8b, hb, rfl\u27e9 _ \u27e8c, hc, rfl\u27e9 _ \u27e8d, hd, rfl\u27e9 h\n  exact congr_arg (a \u2022 \u00b7) <| hs hb hc hd <| by simpa [mul_mul_mul_comm _ _ a] using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/AP/Three/Defs.lean", "context": {"open": ["Finset Function", "scoped Pointwise", "Set"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] (s t : Set \u03b1)", "{s t}", "[CommMonoid \u03b1] [CommMonoid \u03b2] {s A : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b1] [IsCancelMul \u03b1] {s : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : IsCancelMul \u03b1\ns : Set \u03b1\na : \u03b1\nhs : ThreeGPFree s\n\u22a2 ThreeGPFree (a \u2022 s)"}, {"line": "rintro _ \u27e8b, hb, rfl\u27e9 _ \u27e8c, hc, rfl\u27e9 _ \u27e8d, hd, rfl\u27e9 h", "tactic_state": "case intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : IsCancelMul \u03b1\ns : Set \u03b1\na : \u03b1\nhs : ThreeGPFree s\nb : \u03b1\nhb : b \u2208 s\nc : \u03b1\nhc : c \u2208 s\nd : \u03b1\nhd : d \u2208 s\nh : (fun x => a \u2022 x) b * (fun x => a \u2022 x) d = (fun x => a \u2022 x) c * (fun x => a \u2022 x) c\n\u22a2 (fun x => a \u2022 x) b = (fun x => a \u2022 x) c"}, {"line": "exact congr_arg (a \u2022 \u00b7) <| hs hb hc hd <| by simpa [mul_mul_mul_comm _ _ a] using h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ThreeGPFree.smul_set\u2080 (hs : ThreeGPFree s) (ha : a \u2260 0) : ThreeGPFree (a \u2022 s) := by\n  rintro _ \u27e8b, hb, rfl\u27e9 _ \u27e8c, hc, rfl\u27e9 _ \u27e8d, hd, rfl\u27e9 h\n  exact congr_arg (a \u2022 \u00b7) <| hs hb hc hd <| by simpa [mul_mul_mul_comm _ _ a, ha] using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/AP/Three/Defs.lean", "context": {"open": ["Finset Function", "scoped Pointwise", "Set"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] (s t : Set \u03b1)", "{s t}", "[CommMonoid \u03b1] [CommMonoid \u03b2] {s A : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b1] [IsCancelMul \u03b1] {s : Set \u03b1} {a : \u03b1}", "[CommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedCancelMonoid \u03b1] {s : Set \u03b1} {a : \u03b1}", "[CancelCommMonoidWithZero \u03b1] [NoZeroDivisors \u03b1] {s : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2078 : Monoid \u03b1\ninst\u271d\u2077 inst\u271d\u2076 : CommMonoid \u03b1\ninst\u271d\u2075 : IsCancelMul \u03b1\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : IsOrderedCancelMonoid \u03b1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NoZeroDivisors \u03b1\ns : Set \u03b1\na : \u03b1\nhs : ThreeGPFree s\nha : a \u2260 0\n\u22a2 ThreeGPFree (a \u2022 s)"}, {"line": "rintro _ \u27e8b, hb, rfl\u27e9 _ \u27e8c, hc, rfl\u27e9 _ \u27e8d, hd, rfl\u27e9 h", "tactic_state": "case intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_2\ninst\u271d\u2078 : Monoid \u03b1\ninst\u271d\u2077 inst\u271d\u2076 : CommMonoid \u03b1\ninst\u271d\u2075 : IsCancelMul \u03b1\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : IsOrderedCancelMonoid \u03b1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NoZeroDivisors \u03b1\ns : Set \u03b1\na : \u03b1\nhs : ThreeGPFree s\nha : a \u2260 0\nb : \u03b1\nhb : b \u2208 s\nc : \u03b1\nhc : c \u2208 s\nd : \u03b1\nhd : d \u2208 s\nh : (fun x => a \u2022 x) b * (fun x => a \u2022 x) d = (fun x => a \u2022 x) c * (fun x => a \u2022 x) c\n\u22a2 (fun x => a \u2022 x) b = (fun x => a \u2022 x) c"}, {"line": "exact congr_arg (a \u2022 \u00b7) <| hs hb hc hd <| by simpa [mul_mul_mul_comm _ _ a, ha] using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rothNumberNat_add_le (M N : \u2115) :\n    rothNumberNat (M + N) \u2264 rothNumberNat M + rothNumberNat N := by\n  simp_rw [rothNumberNat_def]\n  rw [range_add_eq_union]\n  rw [\u2190 addRothNumber_map_add_left (range N) M]\n  exact addRothNumber_union_le _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/AP/Three/Defs.lean", "context": {"open": ["Finset Function", "scoped Pointwise", "Set", "Finset"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] (s t : Set \u03b1)", "{s t}", "[CommMonoid \u03b1] [CommMonoid \u03b2] {s A : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b1] [IsCancelMul \u03b1] {s : Set \u03b1} {a : \u03b1}", "[CommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedCancelMonoid \u03b1] {s : Set \u03b1} {a : \u03b1}", "[CancelCommMonoidWithZero \u03b1] [NoZeroDivisors \u03b1] {s : Set \u03b1} {a : \u03b1}", "[DecidableEq \u03b1]", "[Monoid \u03b1] [DecidableEq \u03b2] [Monoid \u03b2] (s t : Finset \u03b1)", "{s t} {n : \u2115}", "[CommMonoid \u03b1] [CommMonoid \u03b2] [DecidableEq \u03b2] {A : Finset \u03b1} {B : Finset \u03b2} {f : \u03b1 \u2192 \u03b2}", "[CancelCommMonoid \u03b1] (s : Finset \u03b1) (a : \u03b1)", "{k n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N : \u2115\n\u22a2 rothNumberNat (M + N) \u2264 rothNumberNat M + rothNumberNat N"}, {"line": "simp_rw [rothNumberNat_def]", "tactic_state": "M N : \u2115\n\u22a2 addRothNumber (Finset.range (M + N)) \u2264 addRothNumber (Finset.range M) + addRothNumber (Finset.range N)"}, {"line": "rw [range_add_eq_union]", "tactic_state": "M N : \u2115\n\u22a2 addRothNumber (Finset.range M \u222a map (addLeftEmbedding M) (Finset.range N)) \u2264\n    addRothNumber (Finset.range M) + addRothNumber (Finset.range N)"}, {"line": "rw [\u2190 addRothNumber_map_add_left (range N) M]", "tactic_state": "M N : \u2115\n\u22a2 addRothNumber (Finset.range M \u222a map (addLeftEmbedding M) (Finset.range N)) \u2264\n    addRothNumber (Finset.range M) + addRothNumber (map (addLeftEmbedding M) (Finset.range N))"}, {"line": "exact addRothNumber_union_le _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem addRothNumber_Ico (a b : \u2115) : addRothNumber (Ico a b) = rothNumberNat (b - a) := by\n  obtain h | h := le_total b a\n  \u00b7 rw [Nat.sub_eq_zero_of_le h, Ico_eq_empty_of_le h, rothNumberNat_zero, addRothNumber_empty]\n  convert addRothNumber_map_add_left _ a\n  rw [range_eq_Ico]\n  rw [map_eq_image]\n  convert (image_add_left_Ico 0 (b - a) _).symm\n  exact (add_tsub_cancel_of_le h).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/AP/Three/Defs.lean", "context": {"open": ["Finset Function", "scoped Pointwise", "Set", "Finset"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] (s t : Set \u03b1)", "{s t}", "[CommMonoid \u03b1] [CommMonoid \u03b2] {s A : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b1] [IsCancelMul \u03b1] {s : Set \u03b1} {a : \u03b1}", "[CommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedCancelMonoid \u03b1] {s : Set \u03b1} {a : \u03b1}", "[CancelCommMonoidWithZero \u03b1] [NoZeroDivisors \u03b1] {s : Set \u03b1} {a : \u03b1}", "[DecidableEq \u03b1]", "[Monoid \u03b1] [DecidableEq \u03b2] [Monoid \u03b2] (s t : Finset \u03b1)", "{s t} {n : \u2115}", "[CommMonoid \u03b1] [CommMonoid \u03b2] [DecidableEq \u03b2] {A : Finset \u03b1} {B : Finset \u03b2} {f : \u03b1 \u2192 \u03b2}", "[CancelCommMonoid \u03b1] (s : Finset \u03b1) (a : \u03b1)", "{k n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 addRothNumber (Finset.Ico a b) = rothNumberNat (b - a)"}, {"line": "obtain h | h := le_total b a", "tactic_state": "case inl\na b : \u2115\nh : b \u2264 a\n\u22a2 addRothNumber (Finset.Ico a b) = rothNumberNat (b - a)\n---\ncase inr\na b : \u2115\nh : a \u2264 b\n\u22a2 addRothNumber (Finset.Ico a b) = rothNumberNat (b - a)"}, {"line": "\u00b7 rw [Nat.sub_eq_zero_of_le h, Ico_eq_empty_of_le h, rothNumberNat_zero, addRothNumber_empty]", "tactic_state": "case inr\na b : \u2115\nh : a \u2264 b\n\u22a2 addRothNumber (Finset.Ico a b) = rothNumberNat (b - a)"}, {"line": "convert addRothNumber_map_add_left _ a", "tactic_state": "case h.e'_2.h.e'_6\na b : \u2115\nh : a \u2264 b\n\u22a2 Finset.Ico a b = map (addLeftEmbedding a) (Finset.range (b - a))"}, {"line": "rw [range_eq_Ico]", "tactic_state": "case h.e'_2.h.e'_6\na b : \u2115\nh : a \u2264 b\n\u22a2 Finset.Ico a b = map (addLeftEmbedding a) (Finset.Ico 0 (b - a))"}, {"line": "rw [map_eq_image]", "tactic_state": "case h.e'_2.h.e'_6\na b : \u2115\nh : a \u2264 b\n\u22a2 Finset.Ico a b = Finset.image (\u21d1(addLeftEmbedding a)) (Finset.Ico 0 (b - a))"}, {"line": "convert (image_add_left_Ico 0 (b - a) _).symm", "tactic_state": "case h.e'_2.h.e'_5\na b : \u2115\nh : a \u2264 b\n\u22a2 b = a + (b - a)"}, {"line": "exact (add_tsub_cancel_of_le h).symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCorner.image (hf : IsAddFreimanHom 2 s t f) (hAs : (A : Set (G \u00d7 G)) \u2286 s \u00d7\u02e2 s)\n    (hA : IsCorner A x\u2081 y\u2081 x\u2082 y\u2082) : IsCorner (Prod.map f f '' A) (f x\u2081) (f y\u2081) (f x\u2082) (f y\u2082) := by\n  obtain \u27e8hx\u2081y\u2081, hx\u2081y\u2082, hx\u2082y\u2081, hxy\u27e9 := hA\n  exact \u27e8mem_image_of_mem _ hx\u2081y\u2081, mem_image_of_mem _ hx\u2081y\u2082, mem_image_of_mem _ hx\u2082y\u2081,\n    hf.add_eq_add (hAs hx\u2081y\u2081).1 (hAs hx\u2081y\u2082).2 (hAs hx\u2082y\u2081).1 (hAs hx\u2081y\u2081).2 hxy\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/Corner/Defs.lean", "context": {"open": ["Set"], "variables": ["{G H : Type*}", "[AddCommMonoid G] [AddCommMonoid H] {A B : Set (G \u00d7 G)} {s : Set G} {t : Set H} {f : G \u2192 H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\nH : Type u_2\ninst\u271d\u00b9 : AddCommMonoid G\ninst\u271d : AddCommMonoid H\nA : Set (G \u00d7 G)\ns : Set G\nt : Set H\nf : G \u2192 H\nx\u2081 y\u2081 x\u2082 y\u2082 : G\nhf : IsAddFreimanHom 2 s t f\nhAs : A \u2286 s \u00d7\u02e2 s\nhA : IsCorner A x\u2081 y\u2081 x\u2082 y\u2082\n\u22a2 IsCorner (Prod.map f f '' A) (f x\u2081) (f y\u2081) (f x\u2082) (f y\u2082)"}, {"line": "obtain \u27e8hx\u2081y\u2081, hx\u2081y\u2082, hx\u2082y\u2081, hxy\u27e9 := hA", "tactic_state": "case mk\nG : Type u_1\nH : Type u_2\ninst\u271d\u00b9 : AddCommMonoid G\ninst\u271d : AddCommMonoid H\nA : Set (G \u00d7 G)\ns : Set G\nt : Set H\nf : G \u2192 H\nx\u2081 y\u2081 x\u2082 y\u2082 : G\nhf : IsAddFreimanHom 2 s t f\nhAs : A \u2286 s \u00d7\u02e2 s\nhx\u2081y\u2081 : (x\u2081, y\u2081) \u2208 A\nhx\u2081y\u2082 : (x\u2081, y\u2082) \u2208 A\nhx\u2082y\u2081 : (x\u2082, y\u2081) \u2208 A\nhxy : x\u2081 + y\u2082 = x\u2082 + y\u2081\n\u22a2 IsCorner (Prod.map f f '' A) (f x\u2081) (f y\u2081) (f x\u2082) (f y\u2082)"}, {"line": "exact \u27e8mem_image_of_mem _ hx\u2081y\u2081, mem_image_of_mem _ hx\u2081y\u2082, mem_image_of_mem _ hx\u2082y\u2081,\n    hf.add_eq_add (hAs hx\u2081y\u2081).1 (hAs hx\u2081y\u2082).2 (hAs hx\u2082y\u2081).1 (hAs hx\u2081y\u2081).2 hxy\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rothNumberNat_isLittleO_id :\n    IsLittleO atTop (fun N \u21a6 (rothNumberNat N : \u211d)) (fun N \u21a6 (N : \u211d)) := by\n  simp only [isLittleO_iff]\n  simp only [eventually_atTop]\n  simp only [RCLike.norm_natCast]\n  refine fun \u03b5 h\u03b5 \u21a6 \u27e8cornersTheoremBound (\u03b5 / 3), fun n hn \u21a6 ?_\u27e9\n  obtain \u27e8A, hs\u2081, hs\u2082, hs\u2083\u27e9 := rothNumberNat_spec n\n  rw [\u2190 hs\u2082]\n  rw [\u2190 not_lt]\n  exact fun h\u03b4n \u21a6 roth_3ap_theorem_nat \u03b5 h\u03b5 hn _ hs\u2081 h\u03b4n.le hs\u2083", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Additive/Corner/Roth.lean", "context": {"open": ["Finset SimpleGraph TripartiteFromTriangles", "Function hiding graph", "Fintype (card)", "Corners", "Asymptotics Filter"], "variables": ["{G : Type*} [AddCommGroup G] {A : Finset (G \u00d7 G)} {a b c : G} {n : \u2115} {\u03b5 : \u211d}", "[Fintype G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun N => \u2191(rothNumberNat N)) =o[atTop] fun N => \u2191N"}, {"line": "simp only [isLittleO_iff]", "tactic_state": "\u22a2 \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x : \u2115) in atTop, \u2016\u2191(rothNumberNat x)\u2016 \u2264 c * \u2016\u2191x\u2016"}, {"line": "simp only [eventually_atTop]", "tactic_state": "\u22a2 \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2203 a, \u2200 b \u2265 a, \u2016\u2191(rothNumberNat b)\u2016 \u2264 c * \u2016\u2191b\u2016"}, {"line": "simp only [RCLike.norm_natCast]", "tactic_state": "\u22a2 \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2203 a, \u2200 b \u2265 a, \u2191(rothNumberNat b) \u2264 c * \u2191b"}, {"line": "refine fun \u03b5 h\u03b5 \u21a6 \u27e8cornersTheoremBound (\u03b5 / 3), fun n hn \u21a6 ?_\u27e9", "tactic_state": "\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nn : \u2115\nhn : n \u2265 cornersTheoremBound (\u03b5 / 3)\n\u22a2 \u2191(rothNumberNat n) \u2264 \u03b5 * \u2191n"}, {"line": "obtain \u27e8A, hs\u2081, hs\u2082, hs\u2083\u27e9 := rothNumberNat_spec n", "tactic_state": "case intro.intro.intro\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nn : \u2115\nhn : n \u2265 cornersTheoremBound (\u03b5 / 3)\nA : Finset \u2115\nhs\u2081 : A \u2286 range n\nhs\u2082 : A.card = rothNumberNat n\nhs\u2083 : ThreeAPFree \u2191A\n\u22a2 \u2191(rothNumberNat n) \u2264 \u03b5 * \u2191n"}, {"line": "rw [\u2190 hs\u2082]", "tactic_state": "case intro.intro.intro\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nn : \u2115\nhn : n \u2265 cornersTheoremBound (\u03b5 / 3)\nA : Finset \u2115\nhs\u2081 : A \u2286 range n\nhs\u2082 : A.card = rothNumberNat n\nhs\u2083 : ThreeAPFree \u2191A\n\u22a2 \u2191A.card \u2264 \u03b5 * \u2191n"}, {"line": "rw [\u2190 not_lt]", "tactic_state": "case intro.intro.intro\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nn : \u2115\nhn : n \u2265 cornersTheoremBound (\u03b5 / 3)\nA : Finset \u2115\nhs\u2081 : A \u2286 range n\nhs\u2082 : A.card = rothNumberNat n\nhs\u2083 : ThreeAPFree \u2191A\n\u22a2 \u00ac\u03b5 * \u2191n < \u2191A.card"}, {"line": "exact fun h\u03b4n \u21a6 roth_3ap_theorem_nat \u03b5 h\u03b5 hn _ hs\u2081 h\u03b4n.le hs\u2083", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_derangements_eq_numDerangements (\u03b1 : Type*) [Fintype \u03b1] [DecidableEq \u03b1] :\n    card (derangements \u03b1) = numDerangements (card \u03b1) := by\n  rw [\u2190 card_derangements_invariant (card_fin _)]\n  exact card_derangements_fin_eq_numDerangements\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Derangements/Finite.lean", "context": {"open": ["derangements Equiv Fintype"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] [Fintype \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 card \u2191(derangements \u03b1) = numDerangements (card \u03b1)"}, {"line": "rw [\u2190 card_derangements_invariant (card_fin _)]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 card \u2191(derangements (Fin (card \u03b1))) = numDerangements (card \u03b1)"}, {"line": "exact card_derangements_fin_eq_numDerangements", "tactic_state": "No Goals!"}]}
{"declaration": "theorem RemoveNone.mem_fiber (a : Option \u03b1) (f : Perm \u03b1) :\n    f \u2208 RemoveNone.fiber a \u2194\n      \u2203 F : Perm (Option \u03b1), F \u2208 derangements (Option \u03b1) \u2227 F none = a \u2227 removeNone F = f := by\n  simp [RemoveNone.fiber, derangements]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Derangements/Basic.lean", "context": {"open": ["Equiv Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : Option \u03b1\nf : Perm \u03b1\n\u22a2 f \u2208 sorry \u2194 \u2203 F \u2208 derangements (Option \u03b1), F none = a \u2227 removeNone F = f"}, {"line": "simp [RemoveNone.fiber, derangements]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : Option \u03b1\nf : Perm \u03b1\n\u22a2 f \u2208 sorry () \u2194 \u2203 F, (\u2200 (x : Option \u03b1), \u00acF x = x) \u2227 F none = a \u2227 removeNone F = f"}]}
{"declaration": "theorem iSup_adj {f : \u03b9 \u2192 Digraph V} : (\u2a06 i, f i).Adj a b \u2194 \u2203 i, (f i).Adj a b := by simp [iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Digraph/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b9 : Sort*} {V : Type*} (G : Digraph V) {a b : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nV : Type u_2\na b : V\nf : \u03b9 \u2192 Digraph V\n\u22a2 (\u2a06 i, f i).Adj a b \u2194 \u2203 i, (f i).Adj a b"}, {"line": "simp [iSup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iInf_adj {f : \u03b9 \u2192 Digraph V} : (\u2a05 i, f i).Adj a b \u2194 (\u2200 i, (f i).Adj a b) := by simp [iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Digraph/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b9 : Sort*} {V : Type*} (G : Digraph V) {a b : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nV : Type u_2\na b : V\nf : \u03b9 \u2192 Digraph V\n\u22a2 (\u2a05 i, f i).Adj a b \u2194 \u2200 (i : \u03b9), (f i).Adj a b"}, {"line": "simp [iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem catalan_zero : catalan 0 = 1 := by rw [catalan]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Catalan.lean", "context": {"open": ["Finset", "Finset.antidiagonal (fst_le snd_le)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 catalan 0 = 1"}, {"line": "rw [catalan]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem catalan_succ (n : \u2115) : catalan (n + 1) = \u2211 i : Fin n.succ, catalan i * catalan (n - i) := by\n  rw [catalan]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Catalan.lean", "context": {"open": ["Finset", "Finset.antidiagonal (fst_le snd_le)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 catalan (n + 1) = \u2211 i, catalan \u2191i * catalan (n - \u2191i)"}, {"line": "rw [catalan]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem catalan_succ' (n : \u2115) :\n    catalan (n + 1) = \u2211 ij \u2208 antidiagonal n, catalan ij.1 * catalan ij.2 := by\n  rw [catalan_succ]\n  rw [Nat.sum_antidiagonal_eq_sum_range_succ (fun x y => catalan x * catalan y) n]\n  rw [sum_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Catalan.lean", "context": {"open": ["Finset", "Finset.antidiagonal (fst_le snd_le)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 catalan (n + 1) = \u2211 ij \u2208 antidiagonal n, catalan ij.1 * catalan ij.2"}, {"line": "rw [catalan_succ]", "tactic_state": "n : \u2115\n\u22a2 \u2211 i, catalan \u2191i * catalan (n - \u2191i) = \u2211 ij \u2208 antidiagonal n, catalan ij.1 * catalan ij.2"}, {"line": "rw [Nat.sum_antidiagonal_eq_sum_range_succ (fun x y => catalan x * catalan y) n]", "tactic_state": "n : \u2115\n\u22a2 \u2211 i, catalan \u2191i * catalan (n - \u2191i) = \u2211 k \u2208 range n.succ, catalan k * catalan (n - k)"}, {"line": "rw [sum_range]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem catalan_two : catalan 2 = 2 := by\n  norm_num [catalan_eq_centralBinom_div, Nat.centralBinom, Nat.choose]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Catalan.lean", "context": {"open": ["Finset", "Finset.antidiagonal (fst_le snd_le)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 catalan 2 = 2"}, {"line": "norm_num [catalan_eq_centralBinom_div, Nat.centralBinom, Nat.choose]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem catalan_three : catalan 3 = 5 := by\n  norm_num [catalan_eq_centralBinom_div, Nat.centralBinom, Nat.choose]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Catalan.lean", "context": {"open": ["Finset", "Finset.antidiagonal (fst_le snd_le)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 catalan 3 = 5"}, {"line": "norm_num [catalan_eq_centralBinom_div, Nat.centralBinom, Nat.choose]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_treesOfNumNodesEq {x : Tree Unit} {n : \u2115} :\n    x \u2208 treesOfNumNodesEq n \u2194 x.numNodes = n := by\n  induction x using Tree.unitRecOn generalizing n <;> cases n <;>\n    simp [treesOfNumNodesEq_succ, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Catalan.lean", "context": {"open": ["Finset", "Finset.antidiagonal (fst_le snd_le)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntreesOfNumNodesEq : x\u271d\nx : Tree Unit\nn : \u2115\n\u22a2 x \u2208 sorry \u2194 x.numNodes = n"}, {"line": "induction x using Tree.unitRecOn generalizing n <;> cases n <;>\n    simp [treesOfNumNodesEq_succ, *]", "tactic_state": "case base.zero\nx\u271d : Sort u_1\ntreesOfNumNodesEq : x\u271d\n\u22a2 Tree.nil \u2208 sorry ()\n---\ncase base.succ\nx\u271d : Sort u_1\ntreesOfNumNodesEq : x\u271d\nn\u271d : \u2115\n\u22a2 Tree.nil \u2209 sorry ()\n---\ncase ind.zero\nx\u271d\u00b9 : Sort u_1\ntreesOfNumNodesEq : x\u271d\u00b9\nx\u271d y\u271d : Tree Unit\na\u271d\u00b9 : \u2200 {n : \u2115}, x\u271d \u2208 sorry \u2194 x\u271d.numNodes = n\na\u271d : \u2200 {n : \u2115}, y\u271d \u2208 sorry \u2194 y\u271d.numNodes = n\n\u22a2 Tree.node () x\u271d y\u271d \u2209 sorry ()\n---\ncase ind.succ\nx\u271d\u00b9 : Sort u_1\ntreesOfNumNodesEq : x\u271d\u00b9\nx\u271d y\u271d : Tree Unit\na\u271d\u00b9 : \u2200 {n : \u2115}, x\u271d \u2208 sorry \u2194 x\u271d.numNodes = n\na\u271d : \u2200 {n : \u2115}, y\u271d \u2208 sorry \u2194 y\u271d.numNodes = n\nn\u271d : \u2115\n\u22a2 Tree.node () x\u271d y\u271d \u2208 sorry () \u2194 x\u271d.numNodes + y\u271d.numNodes = n\u271d"}]}
{"declaration": "theorem uniformBell_eq (m n : \u2115) : m.uniformBell n =\n    \u220f p \u2208 (Finset.range m), Nat.choose (p * n + n - 1) (n - 1) := by\n  unfold uniformBell bell\n  rw [toFinset_replicate]\n  split_ifs with hm\n  \u00b7 simp  [hm]\n  \u00b7 by_cases hn : n = 0\n    \u00b7 simp [hn]\n    \u00b7 rw [show ({n} : Finset \u2115).erase 0 = {n} by simp [Ne.symm hn]]\n      simp [count_replicate]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Bell.lean", "context": {"open": ["Multiset Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 m.uniformBell n = \u220f p \u2208 Finset.range m, (p * n + n - 1).choose (n - 1)"}, {"line": "unfold uniformBell bell", "tactic_state": "m n : \u2115\n\u22a2 (Nat.multinomial (replicate m n).toFinset fun k => k * Multiset.count k (replicate m n)) *\n      \u220f k \u2208 (replicate m n).toFinset.erase 0,\n        \u220f j \u2208 Finset.range (Multiset.count k (replicate m n)), (j * k + k - 1).choose (k - 1) =\n    \u220f p \u2208 Finset.range m, (p * n + n - 1).choose (n - 1)"}, {"line": "rw [toFinset_replicate]", "tactic_state": "m n : \u2115\n\u22a2 (Nat.multinomial (if m = 0 then \u2205 else {n}) fun k => k * Multiset.count k (replicate m n)) *\n      \u220f k \u2208 (if m = 0 then \u2205 else {n}).erase 0,\n        \u220f j \u2208 Finset.range (Multiset.count k (replicate m n)), (j * k + k - 1).choose (k - 1) =\n    \u220f p \u2208 Finset.range m, (p * n + n - 1).choose (n - 1)"}, {"line": "split_ifs with hm", "tactic_state": "case pos\nm n : \u2115\nhm : m = 0\n\u22a2 (Nat.multinomial \u2205 fun k => k * Multiset.count k (replicate m n)) *\n      \u220f x \u2208 \u2205.erase 0, \u220f j \u2208 Finset.range (Multiset.count x (replicate m n)), (j * x + x - 1).choose (x - 1) =\n    \u220f p \u2208 Finset.range m, (p * n + n - 1).choose (n - 1)\n---\ncase neg\nm n : \u2115\nhm : \u00acm = 0\n\u22a2 (Nat.multinomial {n} fun k => k * Multiset.count k (replicate m n)) *\n      \u220f x \u2208 {n}.erase 0, \u220f j \u2208 Finset.range (Multiset.count x (replicate m n)), (j * x + x - 1).choose (x - 1) =\n    \u220f p \u2208 Finset.range m, (p * n + n - 1).choose (n - 1)"}, {"line": "\u00b7 simp  [hm]", "tactic_state": "case neg\nm n : \u2115\nhm : \u00acm = 0\n\u22a2 (Nat.multinomial {n} fun k => k * Multiset.count k (replicate m n)) *\n      \u220f x \u2208 {n}.erase 0, \u220f j \u2208 Finset.range (Multiset.count x (replicate m n)), (j * x + x - 1).choose (x - 1) =\n    \u220f p \u2208 Finset.range m, (p * n + n - 1).choose (n - 1)"}, {"line": "\u00b7 by_cases hn : n = 0\n    \u00b7 simp [hn]\n    \u00b7 rw [show ({n} : Finset \u2115).erase 0 = {n} by simp [Ne.symm hn]]\n      simp [count_replicate]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformBell_zero_left (n : \u2115) : uniformBell 0 n = 1 := by\n  simp [uniformBell_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Bell.lean", "context": {"open": ["Multiset Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 uniformBell 0 n = 1"}, {"line": "simp [uniformBell_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformBell_zero_right (m : \u2115) : uniformBell m 0 = 1 := by\n  simp [uniformBell_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Bell.lean", "context": {"open": ["Multiset Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\n\u22a2 m.uniformBell 0 = 1"}, {"line": "simp [uniformBell_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformBell_succ_left (m n : \u2115) :\n    uniformBell (m+1) n = choose (m * n + n - 1) (n - 1) * uniformBell m n := by\n  simp only [uniformBell_eq]\n  simp only [Finset.prod_range_succ]\n  simp only [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Bell.lean", "context": {"open": ["Multiset Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 (m + 1).uniformBell n = (m * n + n - 1).choose (n - 1) * m.uniformBell n"}, {"line": "simp only [uniformBell_eq]", "tactic_state": "m n : \u2115\n\u22a2 \u220f p \u2208 Finset.range (m + 1), (p * n + n - 1).choose (n - 1) =\n    (m * n + n - 1).choose (n - 1) * \u220f p \u2208 Finset.range m, (p * n + n - 1).choose (n - 1)"}, {"line": "simp only [Finset.prod_range_succ]", "tactic_state": "m n : \u2115\n\u22a2 (\u220f p \u2208 Finset.range m, (p * n + n - 1).choose (n - 1)) * (m * n + n - 1).choose (n - 1) =\n    (m * n + n - 1).choose (n - 1) * \u220f p \u2208 Finset.range m, (p * n + n - 1).choose (n - 1)"}, {"line": "simp only [mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformBell_one_left (n : \u2115) : uniformBell 1 n = 1 := by\n  simp only [uniformBell_eq]\n  simp only [Finset.range_one]\n  simp only [Finset.prod_singleton]\n  simp only [zero_mul]\n  simp only [zero_add]\n  simp only [choose_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Bell.lean", "context": {"open": ["Multiset Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 uniformBell 1 n = 1"}, {"line": "simp only [uniformBell_eq]", "tactic_state": "n : \u2115\n\u22a2 \u220f p \u2208 Finset.range 1, (p * n + n - 1).choose (n - 1) = 1"}, {"line": "simp only [Finset.range_one]", "tactic_state": "n : \u2115\n\u22a2 \u220f p \u2208 {0}, (p * n + n - 1).choose (n - 1) = 1"}, {"line": "simp only [Finset.prod_singleton]", "tactic_state": "n : \u2115\n\u22a2 (0 * n + n - 1).choose (n - 1) = 1"}, {"line": "simp only [zero_mul]", "tactic_state": "n : \u2115\n\u22a2 (0 + n - 1).choose (n - 1) = 1"}, {"line": "simp only [zero_add]", "tactic_state": "n : \u2115\n\u22a2 (n - 1).choose (n - 1) = 1"}, {"line": "simp only [choose_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformBell_eq_div (m : \u2115) {n : \u2115} (hn : n \u2260 0) :\n    uniformBell m n = (m * n) ! / (n ! ^ m * m !) := by\n  rw [eq_comm]\n  apply Nat.div_eq_of_eq_mul_left\n  \u00b7 exact Nat.mul_pos (Nat.pow_pos (Nat.factorial_pos n)) m.factorial_pos\n  \u00b7 rw [\u2190 mul_assoc, \u2190 uniformBell_mul_eq _ hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Bell.lean", "context": {"open": ["Multiset Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nhn : n \u2260 0\n\u22a2 m.uniformBell n = (m * n).factorial / (n.factorial ^ m * m.factorial)"}, {"line": "rw [eq_comm]", "tactic_state": "m n : \u2115\nhn : n \u2260 0\n\u22a2 (m * n).factorial / (n.factorial ^ m * m.factorial) = m.uniformBell n"}, {"line": "apply Nat.div_eq_of_eq_mul_left", "tactic_state": "case H1\nm n : \u2115\nhn : n \u2260 0\n\u22a2 0 < n.factorial ^ m * m.factorial\n---\ncase H2\nm n : \u2115\nhn : n \u2260 0\n\u22a2 (m * n).factorial = m.uniformBell n * (n.factorial ^ m * m.factorial)"}, {"line": "\u00b7 exact Nat.mul_pos (Nat.pow_pos (Nat.factorial_pos n)) m.factorial_pos", "tactic_state": "case H2\nm n : \u2115\nhn : n \u2260 0\n\u22a2 (m * n).factorial = m.uniformBell n * (n.factorial ^ m * m.factorial)"}, {"line": "\u00b7 rw [\u2190 mul_assoc, \u2190 uniformBell_mul_eq _ hn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem blocks_le {i : \u2115} (h : i \u2208 c.blocks) : i \u2264 n := by\n  rw [\u2190 c.blocks_sum]\n  exact List.le_sum_of_mem h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Composition n\ni : \u2115\nh : i \u2208 c.blocks\n\u22a2 i \u2264 n"}, {"line": "rw [\u2190 c.blocks_sum]", "tactic_state": "n : \u2115\nc : Composition n\ni : \u2115\nh : i \u2208 c.blocks\n\u22a2 i \u2264 c.blocks.sum"}, {"line": "exact List.le_sum_of_mem h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_le : c.length \u2264 n := by\n  conv_rhs => rw [\u2190 c.blocks_sum]\n  exact length_le_sum_of_one_le _ fun i hi => c.one_le_blocks hi\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Composition n\n\u22a2 c.length \u2264 n"}, {"line": "conv_rhs => rw [\u2190 c.blocks_sum]", "tactic_state": "n : \u2115\nc : Composition n\n\u22a2 c.length \u2264 c.blocks.sum"}, {"line": "exact length_le_sum_of_one_le _ fun i hi => c.one_le_blocks hi", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_pos_iff : 0 < c.length \u2194 0 < n := by\n  simp [pos_iff_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Composition n\n\u22a2 0 < c.length \u2194 0 < n"}, {"line": "simp [pos_iff_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sizeUpTo_zero : c.sizeUpTo 0 = 0 := by simp [sizeUpTo]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Composition n\n\u22a2 c.sizeUpTo 0 = 0"}, {"line": "simp [sizeUpTo]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sizeUpTo_le (i : \u2115) : c.sizeUpTo i \u2264 n := by\n  conv_rhs => rw [\u2190 c.blocks_sum, \u2190 sum_take_add_sum_drop _ i]\n  exact Nat.le_add_right _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Composition n\ni : \u2115\n\u22a2 c.sizeUpTo i \u2264 n"}, {"line": "conv_rhs => rw [\u2190 c.blocks_sum, \u2190 sum_take_add_sum_drop _ i]", "tactic_state": "n : \u2115\nc : Composition n\ni : \u2115\n\u22a2 c.sizeUpTo i \u2264 (take i c.blocks).sum + (drop i c.blocks).sum"}, {"line": "exact Nat.le_add_right _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sizeUpTo_strict_mono {i : \u2115} (h : i < c.length) : c.sizeUpTo i < c.sizeUpTo (i + 1) := by\n  rw [c.sizeUpTo_succ h]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Composition n\ni : \u2115\nh : i < c.length\n\u22a2 c.sizeUpTo i < c.sizeUpTo (i + 1)"}, {"line": "rw [c.sizeUpTo_succ h]", "tactic_state": "n : \u2115\nc : Composition n\ni : \u2115\nh : i < c.length\n\u22a2 c.sizeUpTo i < c.sizeUpTo i + c.blocks[i]"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem boundary_zero : c.boundary 0 = 0 := by simp [boundary, Fin.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Composition n\n\u22a2 c.boundary 0 = 0"}, {"line": "simp [boundary, Fin.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem boundary_last : c.boundary (Fin.last c.length) = Fin.last n := by\n  simp [boundary, Fin.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Composition n\n\u22a2 c.boundary (Fin.last c.length) = Fin.last n"}, {"line": "simp [boundary, Fin.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orderEmbOfFin_boundaries :\n    c.boundaries.orderEmbOfFin c.card_boundaries_eq_succ_length = c.boundary := by\n  refine (Finset.orderEmbOfFin_unique' _ ?_).symm\n  exact fun i => (Finset.mem_map' _).2 (Finset.mem_univ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Composition n\n\u22a2 c.boundaries.orderEmbOfFin \u22ef = c.boundary"}, {"line": "refine (Finset.orderEmbOfFin_unique' _ ?_).symm", "tactic_state": "n : \u2115\nc : Composition n\n\u22a2 \u2200 (x : Fin (c.length + 1)), c.boundary x \u2208 c.boundaries"}, {"line": "exact fun i => (Finset.mem_map' _).2 (Finset.mem_univ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sizeUpTo_index_le (j : Fin n) : c.sizeUpTo (c.index j) \u2264 j := by\n  by_contra H\n  set i := c.index j\n  push_neg at H\n  have i_pos : (0 : \u2115) < i := by\n    by_contra! i_pos\n    revert H\n    simp [nonpos_iff_eq_zero.1 i_pos, c.sizeUpTo_zero]\n  let i\u2081 := (i : \u2115).pred\n  have i\u2081_lt_i : i\u2081 < i := Nat.pred_lt (ne_of_gt i_pos)\n  have i\u2081_succ : i\u2081 + 1 = i := Nat.succ_pred_eq_of_pos i_pos\n  have := Nat.find_min (c.index_exists j.2) i\u2081_lt_i\n  simp [lt_trans i\u2081_lt_i (c.index j).2, i\u2081_succ] at this\n  exact Nat.lt_le_asymm H this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Composition n\nj : Fin n\n\u22a2 c.sizeUpTo \u2191(c.index j) \u2264 \u2191j"}, {"line": "by_contra H", "tactic_state": "n : \u2115\nc : Composition n\nj : Fin n\nH : \u00acc.sizeUpTo \u2191(c.index j) \u2264 \u2191j\n\u22a2 False"}, {"line": "set i := c.index j", "tactic_state": "n : \u2115\nc : Composition n\nj : Fin n\ni : Fin c.length := c.index j\nH : \u00acc.sizeUpTo \u2191i \u2264 \u2191j\n\u22a2 False"}, {"line": "push_neg at H", "tactic_state": "n : \u2115\nc : Composition n\nj : Fin n\ni : Fin c.length := c.index j\nH : \u2191j < c.sizeUpTo \u2191i\n\u22a2 False"}, {"line": "have i_pos : (0 : \u2115) < i := sorry", "tactic_state": "n : \u2115\nc : Composition n\nj : Fin n\ni : Fin c.length := c.index j\nH : \u2191j < c.sizeUpTo \u2191i\ni_pos : 0 < \u2191i\n\u22a2 False"}, {"line": "let i\u2081 := (i : \u2115).pred", "tactic_state": "n : \u2115\nc : Composition n\nj : Fin n\ni : Fin c.length := c.index j\nH : \u2191j < c.sizeUpTo \u2191i\ni_pos : 0 < \u2191i\ni\u2081 : \u2115 := (\u2191i).pred\n\u22a2 False"}, {"line": "have i\u2081_lt_i : i\u2081 < i := Nat.pred_lt (ne_of_gt i_pos)", "tactic_state": "n : \u2115\nc : Composition n\nj : Fin n\ni : Fin c.length := c.index j\nH : \u2191j < c.sizeUpTo \u2191i\ni_pos : 0 < \u2191i\ni\u2081 : \u2115 := (\u2191i).pred\ni\u2081_lt_i : i\u2081 < \u2191i\n\u22a2 False"}, {"line": "have i\u2081_succ : i\u2081 + 1 = i := Nat.succ_pred_eq_of_pos i_pos", "tactic_state": "n : \u2115\nc : Composition n\nj : Fin n\ni : Fin c.length := c.index j\nH : \u2191j < c.sizeUpTo \u2191i\ni_pos : 0 < \u2191i\ni\u2081 : \u2115 := (\u2191i).pred\ni\u2081_lt_i : i\u2081 < \u2191i\ni\u2081_succ : i\u2081 + 1 = \u2191i\n\u22a2 False"}, {"line": "have := Nat.find_min (c.index_exists j.2) i\u2081_lt_i", "tactic_state": "n : \u2115\nc : Composition n\nj : Fin n\ni : Fin c.length := c.index j\nH : \u2191j < c.sizeUpTo \u2191i\ni_pos : 0 < \u2191i\ni\u2081 : \u2115 := (\u2191i).pred\ni\u2081_lt_i : i\u2081 < \u2191i\ni\u2081_succ : i\u2081 + 1 = \u2191i\nthis : \u00ac(\u2191j < c.sizeUpTo (i\u2081 + 1) \u2227 i\u2081 < c.length)\n\u22a2 False"}, {"line": "simp [lt_trans i\u2081_lt_i (c.index j).2, i\u2081_succ] at this", "tactic_state": "n : \u2115\nc : Composition n\nj : Fin n\ni : Fin c.length := c.index j\nH : \u2191j < c.sizeUpTo \u2191i\ni_pos : 0 < \u2191i\ni\u2081 : \u2115 := (\u2191i).pred\ni\u2081_lt_i : i\u2081 < \u2191i\ni\u2081_succ : i\u2081 + 1 = \u2191i\nthis : c.sizeUpTo \u2191i \u2264 \u2191j\n\u22a2 False"}, {"line": "exact Nat.lt_le_asymm H this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem embedding_comp_inv (j : Fin n) : c.embedding (c.index j) (c.invEmbedding j) = j := by\n  rw [Fin.ext_iff]\n  apply add_tsub_cancel_of_le (c.sizeUpTo_index_le j)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Composition n\nj : Fin n\n\u22a2 (c.embedding (c.index j)) (c.invEmbedding j) = j"}, {"line": "rw [Fin.ext_iff]", "tactic_state": "n : \u2115\nc : Composition n\nj : Fin n\n\u22a2 \u2191((c.embedding (c.index j)) (c.invEmbedding j)) = \u2191j"}, {"line": "apply add_tsub_cancel_of_le (c.sizeUpTo_index_le j)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_range {i\u2081 i\u2082 : Fin c.length} (h : i\u2081 \u2260 i\u2082) :\n    Disjoint (Set.range (c.embedding i\u2081)) (Set.range (c.embedding i\u2082)) := by\n  classical\n    wlog h' : i\u2081 < i\u2082\n    \u00b7 exact (this c h.symm (h.lt_or_lt.resolve_left h')).symm\n    by_contra d\n    obtain \u27e8x, hx\u2081, hx\u2082\u27e9 :\n      \u2203 x : Fin n, x \u2208 Set.range (c.embedding i\u2081) \u2227 x \u2208 Set.range (c.embedding i\u2082) :=\n      Set.not_disjoint_iff.1 d\n    have A : (i\u2081 : \u2115).succ \u2264 i\u2082 := Nat.succ_le_of_lt h'\n    apply lt_irrefl (x : \u2115)\n    calc\n      (x : \u2115) < c.sizeUpTo (i\u2081 : \u2115).succ := (c.mem_range_embedding_iff.1 hx\u2081).2\n      _ \u2264 c.sizeUpTo (i\u2082 : \u2115) := monotone_sum_take _ A\n      _ \u2264 x := (c.mem_range_embedding_iff.1 hx\u2082).1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Composition n\ni\u2081 i\u2082 : Fin c.length\nh : i\u2081 \u2260 i\u2082\n\u22a2 _root_.Disjoint (Set.range \u21d1(c.embedding i\u2081)) (Set.range \u21d1(c.embedding i\u2082))"}, {"line": "classical\n    wlog h' : i\u2081 < i\u2082\n    \u00b7 exact (this c h.symm (h.lt_or_lt.resolve_left h')).symm\n    by_contra d\n    obtain \u27e8x, hx\u2081, hx\u2082\u27e9 :\n      \u2203 x : Fin n, x \u2208 Set.range (c.embedding i\u2081) \u2227 x \u2208 Set.range (c.embedding i\u2082) :=\n      Set.not_disjoint_iff.1 d\n    have A : (i\u2081 : \u2115).succ \u2264 i\u2082 := Nat.succ_le_of_lt h'\n    apply lt_irrefl (x : \u2115)\n    calc\n      (x : \u2115) < c.sizeUpTo (i\u2081 : \u2115).succ := (c.mem_range_embedding_iff.1 hx\u2081).2\n      _ \u2264 c.sizeUpTo (i\u2082 : \u2115) := monotone_sum_take _ A\n      _ \u2264 x := (c.mem_range_embedding_iff.1 hx\u2082).1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_range_embedding (j : Fin n) : j \u2208 Set.range (c.embedding (c.index j)) := by\n  have : c.embedding (c.index j) (c.invEmbedding j) \u2208 Set.range (c.embedding (c.index j)) :=\n    Set.mem_range_self _\n  rwa [c.embedding_comp_inv j] at this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Composition n\nj : Fin n\n\u22a2 j \u2208 Set.range \u21d1(c.embedding (c.index j))"}, {"line": "have : c.embedding (c.index j) (c.invEmbedding j) \u2208 Set.range (c.embedding (c.index j)) :=\n    Set.mem_range_self _", "tactic_state": "n : \u2115\nc : Composition n\nj : Fin n\nthis : (c.embedding (c.index j)) (c.invEmbedding j) \u2208 Set.range \u21d1(c.embedding (c.index j))\n\u22a2 j \u2208 Set.range \u21d1(c.embedding (c.index j))"}, {"line": "rwa [c.embedding_comp_inv j] at this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem blocksFun_congr {n\u2081 n\u2082 : \u2115} (c\u2081 : Composition n\u2081) (c\u2082 : Composition n\u2082) (i\u2081 : Fin c\u2081.length)\n    (i\u2082 : Fin c\u2082.length) (hn : n\u2081 = n\u2082) (hc : c\u2081.blocks = c\u2082.blocks) (hi : (i\u2081 : \u2115) = i\u2082) :\n    c\u2081.blocksFun i\u2081 = c\u2082.blocksFun i\u2082 := by\n  cases hn\n  rw [\u2190 Composition.ext_iff] at hc\n  cases hc\n  congr\n  rwa [Fin.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n\u2081 n\u2082 : \u2115\nc\u2081 : Composition n\u2081\nc\u2082 : Composition n\u2082\ni\u2081 : Fin c\u2081.length\ni\u2082 : Fin c\u2082.length\nhn : n\u2081 = n\u2082\nhc : c\u2081.blocks = c\u2082.blocks\nhi : \u2191i\u2081 = \u2191i\u2082\n\u22a2 c\u2081.blocksFun i\u2081 = c\u2082.blocksFun i\u2082"}, {"line": "cases hn", "tactic_state": "case refl\nn\u2081 : \u2115\nc\u2081 : Composition n\u2081\ni\u2081 : Fin c\u2081.length\nc\u2082 : Composition n\u2081\ni\u2082 : Fin c\u2082.length\nhc : c\u2081.blocks = c\u2082.blocks\nhi : \u2191i\u2081 = \u2191i\u2082\n\u22a2 c\u2081.blocksFun i\u2081 = c\u2082.blocksFun i\u2082"}, {"line": "rw [\u2190 Composition.ext_iff] at hc", "tactic_state": "case refl\nn\u2081 : \u2115\nc\u2081 : Composition n\u2081\ni\u2081 : Fin c\u2081.length\nc\u2082 : Composition n\u2081\ni\u2082 : Fin c\u2082.length\nhc : c\u2081 = c\u2082\nhi : \u2191i\u2081 = \u2191i\u2082\n\u22a2 c\u2081.blocksFun i\u2081 = c\u2082.blocksFun i\u2082"}, {"line": "cases hc", "tactic_state": "case refl.refl\nn\u2081 : \u2115\nc\u2081 : Composition n\u2081\ni\u2081 i\u2082 : Fin c\u2081.length\nhi : \u2191i\u2081 = \u2191i\u2082\n\u22a2 c\u2081.blocksFun i\u2081 = c\u2081.blocksFun i\u2082"}, {"line": "congr", "tactic_state": "case refl.refl.e_a\nn\u2081 : \u2115\nc\u2081 : Composition n\u2081\ni\u2081 i\u2082 : Fin c\u2081.length\nhi : \u2191i\u2081 = \u2191i\u2082\n\u22a2 i\u2081 = i\u2082"}, {"line": "rwa [Fin.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sigma_eq_iff_blocks_eq {c : \u03a3 n, Composition n} {c' : \u03a3 n, Composition n} :\n    c = c' \u2194 c.2.blocks = c'.2.blocks := by\n  refine \u27e8fun H => by rw [H], fun H => ?_\u27e9\n  rcases c with \u27e8n, c\u27e9\n  rcases c' with \u27e8n', c'\u27e9\n  have : n = n' := by rw [\u2190 c.blocks_sum, \u2190 c'.blocks_sum, H]\n  induction this\n  congr\n  ext1\n  exact H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c c' : (n : \u2115) \u00d7 Composition n\n\u22a2 c = c' \u2194 c.snd.blocks = c'.snd.blocks"}, {"line": "refine \u27e8fun H => by rw [H], fun H => ?_\u27e9", "tactic_state": "c c' : (n : \u2115) \u00d7 Composition n\nH : c.snd.blocks = c'.snd.blocks\n\u22a2 c = c'"}, {"line": "rcases c with \u27e8n, c\u27e9", "tactic_state": "case mk\nc' : (n : \u2115) \u00d7 Composition n\nn : \u2115\nc : Composition n\nH : \u27e8n, c\u27e9.snd.blocks = c'.snd.blocks\n\u22a2 \u27e8n, c\u27e9 = c'"}, {"line": "rcases c' with \u27e8n', c'\u27e9", "tactic_state": "case mk.mk\nn : \u2115\nc : Composition n\nn' : \u2115\nc' : Composition n'\nH : \u27e8n, c\u27e9.snd.blocks = \u27e8n', c'\u27e9.snd.blocks\n\u22a2 \u27e8n, c\u27e9 = \u27e8n', c'\u27e9"}, {"line": "have : n = n' := by rw [\u2190 c.blocks_sum, \u2190 c'.blocks_sum, H]", "tactic_state": "case mk.mk\nn : \u2115\nc : Composition n\nn' : \u2115\nc' : Composition n'\nH : \u27e8n, c\u27e9.snd.blocks = \u27e8n', c'\u27e9.snd.blocks\nthis : n = n'\n\u22a2 \u27e8n, c\u27e9 = \u27e8n', c'\u27e9"}, {"line": "induction this", "tactic_state": "case mk.mk.refl\nn : \u2115\nc : Composition n\nn' : \u2115\nc' : Composition n\nH : \u27e8n, c\u27e9.snd.blocks = \u27e8n, c'\u27e9.snd.blocks\n\u22a2 \u27e8n, c\u27e9 = \u27e8n, c'\u27e9"}, {"line": "congr", "tactic_state": "case mk.mk.refl.e_snd\nn : \u2115\nc : Composition n\nn' : \u2115\nc' : Composition n\nH : \u27e8n, c\u27e9.snd.blocks = \u27e8n, c'\u27e9.snd.blocks\n\u22a2 c = c'"}, {"line": "ext1", "tactic_state": "case mk.mk.refl.e_snd.blocks\nn : \u2115\nc : Composition n\nn' : \u2115\nc' : Composition n\nH : \u27e8n, c\u27e9.snd.blocks = \u27e8n, c'\u27e9.snd.blocks\n\u22a2 c.blocks = c'.blocks"}, {"line": "exact H", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ones_sizeUpTo (n : \u2115) (i : \u2115) : (ones n).sizeUpTo i = min i n := by\n  simp [sizeUpTo, ones_blocks, take_replicate]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nones : x\u271d\nn i : \u2115\n\u22a2 sorry = min i n"}, {"line": "simp [sizeUpTo, ones_blocks, take_replicate]", "tactic_state": "x\u271d : Sort u_1\nones : x\u271d\nn i : \u2115\n\u22a2 sorry () = min i n"}]}
{"declaration": "theorem eq_ones_iff_le_length {c : Composition n} : c = ones n \u2194 n \u2264 c.length := by\n  simp [eq_ones_iff_length, le_antisymm_iff, c.length_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nones : x\u271d\nc : Composition n\n\u22a2 c = sorry \u2194 n \u2264 c.length"}, {"line": "simp [eq_ones_iff_length, le_antisymm_iff, c.length_le]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nones : x\u271d\nc : Composition n\n\u22a2 c = sorry () \u2194 n \u2264 c.length"}]}
{"declaration": "theorem single_blocksFun {n : \u2115} (h : 0 < n) (i : Fin (single n h).length) :\n    (single n h).blocksFun i = n := by simp [blocksFun, single, blocks, i.2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsingle : x\u271d\nn : \u2115\nh : 0 < n\ni : Fin sorry\n\u22a2 sorry = n"}, {"line": "simp [blocksFun, single, blocks, i.2]", "tactic_state": "x\u271d : Sort u_1\nsingle : x\u271d\nn : \u2115\nh : 0 < n\ni : Fin sorry\n\u22a2 sorry () = n"}]}
{"declaration": "theorem single_embedding {n : \u2115} (h : 0 < n) (i : Fin n) :\n    ((single n h).embedding (0 : Fin 1)) i = i := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsingle : x\u271d\nn : \u2115\nh : 0 < n\ni : Fin n\n\u22a2 sorry = i"}, {"line": "ext", "tactic_state": "case h\nx\u271d : Sort u_1\nsingle : x\u271d\nn : \u2115\nh : 0 < n\ni : Fin n\n\u22a2 \u2191sorry = \u2191i"}, {"line": "simp", "tactic_state": "case h\nx\u271d : Sort u_1\nsingle : x\u271d\nn : \u2115\nh : 0 < n\ni : Fin n\n\u22a2 \u2191(sorry ()) = \u2191i"}]}
{"declaration": "theorem cast_eq_cast (c : Composition m) (hmn : m = n) :\n    c.cast hmn = cast (hmn \u25b8 rfl) c := by\n  subst m\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)", "{m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nc : Composition m\nhmn : m = n\n\u22a2 c.cast hmn = cast \u22ef c"}, {"line": "subst m", "tactic_state": "n : \u2115\nc : Composition n\n\u22a2 c.cast \u22ef = cast \u22ef c"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem splitWrtCompositionAux_cons (l : List \u03b1) (n ns) :\n    l.splitWrtCompositionAux (n::ns) = take n l::(drop n l).splitWrtCompositionAux ns := by\n  simp [splitWrtCompositionAux]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)", "{m : \u2115}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : List \u03b1\nn : \u2115\nns : List \u2115\n\u22a2 l.splitWrtCompositionAux (n :: ns) = take n l :: (drop n l).splitWrtCompositionAux ns"}, {"line": "simp [splitWrtCompositionAux]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_pos_of_mem_splitWrtComposition {l l' : List \u03b1} {c : Composition l.length}\n    (h : l' \u2208 l.splitWrtComposition c) : 0 < length l' := by\n  have : l'.length \u2208 (l.splitWrtComposition c).map List.length :=\n    List.mem_map_of_mem h\n  rw [map_length_splitWrtComposition] at this\n  exact c.blocks_pos this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)", "{m : \u2115}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl l' : List \u03b1\nc : Composition l.length\nh : l' \u2208 l.splitWrtComposition c\n\u22a2 0 < l'.length"}, {"line": "have : l'.length \u2208 (l.splitWrtComposition c).map List.length :=\n    List.mem_map_of_mem h", "tactic_state": "\u03b1 : Type u_1\nl l' : List \u03b1\nc : Composition l.length\nh : l' \u2208 l.splitWrtComposition c\nthis : l'.length \u2208 map length (l.splitWrtComposition c)\n\u22a2 0 < l'.length"}, {"line": "rw [map_length_splitWrtComposition] at this", "tactic_state": "\u03b1 : Type u_1\nl l' : List \u03b1\nc : Composition l.length\nh : l' \u2208 l.splitWrtComposition c\nthis : l'.length \u2208 c.blocks\n\u22a2 0 < l'.length"}, {"line": "exact c.blocks_pos this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_take_map_length_splitWrtComposition (l : List \u03b1) (c : Composition l.length) (i : \u2115) :\n    (((l.splitWrtComposition c).map length).take i).sum = c.sizeUpTo i := by\n  congr\n  exact map_length_splitWrtComposition l c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)", "{m : \u2115}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : List \u03b1\nc : Composition l.length\ni : \u2115\n\u22a2 (take i (map length (l.splitWrtComposition c))).sum = c.sizeUpTo i"}, {"line": "congr", "tactic_state": "case e_a.e_xs\n\u03b1 : Type u_1\nl : List \u03b1\nc : Composition l.length\ni : \u2115\n\u22a2 map length (l.splitWrtComposition c) = c.blocks"}, {"line": "exact map_length_splitWrtComposition l c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compositionAsSet_card (n : \u2115) : Fintype.card (CompositionAsSet n) = 2 ^ (n - 1) := by\n  have : Fintype.card (Finset (Fin (n - 1))) = 2 ^ (n - 1) := by simp\n  rw [\u2190 this]\n  exact Fintype.card_congr (compositionAsSetEquiv n)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)", "{m : \u2115}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 Fintype.card (CompositionAsSet n) = 2 ^ (n - 1)"}, {"line": "have : Fintype.card (Finset (Fin (n - 1))) = 2 ^ (n - 1) := by simp", "tactic_state": "n : \u2115\nthis : Fintype.card (Finset (Fin (n - 1))) = 2 ^ (n - 1)\n\u22a2 Fintype.card (CompositionAsSet n) = 2 ^ (n - 1)"}, {"line": "rw [\u2190 this]", "tactic_state": "n : \u2115\nthis : Fintype.card (Finset (Fin (n - 1))) = 2 ^ (n - 1)\n\u22a2 Fintype.card (CompositionAsSet n) = Fintype.card (Finset (Fin (n - 1)))"}, {"line": "exact Fintype.card_congr (compositionAsSetEquiv n)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_lt_card_boundaries : c.length < c.boundaries.card := by\n  rw [c.card_boundaries_eq_succ_length]\n  exact Nat.lt_add_one _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)", "{m : \u2115}", "{\u03b1 : Type*}", "(c : CompositionAsSet n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : CompositionAsSet n\n\u22a2 c.length < c.boundaries.card"}, {"line": "rw [c.card_boundaries_eq_succ_length]", "tactic_state": "n : \u2115\nc : CompositionAsSet n\n\u22a2 c.length < c.length + 1"}, {"line": "exact Nat.lt_add_one _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem boundary_length : c.boundary \u27e8c.length, c.length_lt_card_boundaries\u27e9 = Fin.last n := by\n  convert Finset.orderEmbOfFin_last rfl c.card_boundaries_pos\n  exact le_antisymm (Finset.le_max' _ _ c.getLast_mem) (Fin.le_last _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)", "{m : \u2115}", "{\u03b1 : Type*}", "(c : CompositionAsSet n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : CompositionAsSet n\n\u22a2 c.boundary \u27e8c.length, \u22ef\u27e9 = Fin.last n"}, {"line": "convert Finset.orderEmbOfFin_last rfl c.card_boundaries_pos", "tactic_state": "case h.e'_3\nn : \u2115\nc : CompositionAsSet n\n\u22a2 Fin.last n = c.boundaries.max' \u22ef"}, {"line": "exact le_antisymm (Finset.le_max' _ _ c.getLast_mem) (Fin.le_last _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem blocks_sum : c.blocks.sum = n := by\n  have : c.blocks.take c.length = c.blocks := take_of_length_le (by simp [blocks])\n  rw [\u2190 this]\n  rw [c.blocks_partial_sum c.length_lt_card_boundaries]\n  rw [c.boundary_length]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)", "{m : \u2115}", "{\u03b1 : Type*}", "(c : CompositionAsSet n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : CompositionAsSet n\n\u22a2 c.blocks.sum = n"}, {"line": "have : c.blocks.take c.length = c.blocks := take_of_length_le (by simp [blocks])", "tactic_state": "n : \u2115\nc : CompositionAsSet n\nthis : take c.length c.blocks = c.blocks\n\u22a2 c.blocks.sum = n"}, {"line": "rw [\u2190 this]", "tactic_state": "n : \u2115\nc : CompositionAsSet n\nthis : take c.length c.blocks = c.blocks\n\u22a2 (take c.length c.blocks).sum = n"}, {"line": "rw [c.blocks_partial_sum c.length_lt_card_boundaries]", "tactic_state": "n : \u2115\nc : CompositionAsSet n\nthis : take c.length c.blocks = c.blocks\n\u22a2 \u2191(c.boundary \u27e8c.length, \u22ef\u27e9) = n"}, {"line": "rw [c.boundary_length]", "tactic_state": "n : \u2115\nc : CompositionAsSet n\nthis : take c.length c.blocks = c.blocks\n\u22a2 \u2191(Fin.last n) = n"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Composition.toCompositionAsSet_length (c : Composition n) :\n    c.toCompositionAsSet.length = c.length := by\n  simp [Composition.toCompositionAsSet, CompositionAsSet.length, c.card_boundaries_eq_succ_length]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)", "{m : \u2115}", "{\u03b1 : Type*}", "(c : CompositionAsSet n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Composition n\n\u22a2 c.toCompositionAsSet.length = c.length"}, {"line": "simp [Composition.toCompositionAsSet, CompositionAsSet.length, c.card_boundaries_eq_succ_length]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem CompositionAsSet.toComposition_length (c : CompositionAsSet n) :\n    c.toComposition.length = c.length := by\n  simp [CompositionAsSet.toComposition, Composition.length, Composition.blocks]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)", "{m : \u2115}", "{\u03b1 : Type*}", "(c : CompositionAsSet n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : CompositionAsSet n\n\u22a2 c.toComposition.length = c.length"}, {"line": "simp [CompositionAsSet.toComposition, Composition.length, Composition.blocks]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem composition_card (n : \u2115) : Fintype.card (Composition n) = 2 ^ (n - 1) := by\n  rw [\u2190 compositionAsSet_card n]\n  exact Fintype.card_congr (compositionEquiv n)", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/Composition.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)", "{m : \u2115}", "{\u03b1 : Type*}", "(c : CompositionAsSet n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 Fintype.card (Composition n) = 2 ^ (n - 1)"}, {"line": "rw [\u2190 compositionAsSet_card n]", "tactic_state": "n : \u2115\n\u22a2 Fintype.card (Composition n) = Fintype.card (CompositionAsSet n)"}, {"line": "exact Fintype.card_congr (compositionEquiv n)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_prod_bipartiteAbove_eq_prod_prod_bipartiteBelow\n    [CommMonoid R] (f : \u03b1 \u2192 \u03b2 \u2192 R) [\u2200 a b, Decidable (r a b)] :\n    \u220f a \u2208 s, \u220f b \u2208 t.bipartiteAbove r a, f a b = \u220f b \u2208 t, \u220f a \u2208 s.bipartiteBelow r b, f a b := by\n  simp_rw [bipartiteAbove, bipartiteBelow, prod_filter]\n  exact prod_comm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/DoubleCounting.lean", "context": {"open": ["Finset Function Relator"], "variables": ["{R \u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b2 \u2192 Prop) (s : Finset \u03b1) (t : Finset \u03b2) (a : \u03b1) (b : \u03b2)", "{s t a b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\ns : Finset \u03b1\nt : Finset \u03b2\ninst\u271d\u00b9 : CommMonoid R\nf : \u03b1 \u2192 \u03b2 \u2192 R\ninst\u271d : (a : \u03b1) \u2192 (b : \u03b2) \u2192 Decidable (r a b)\n\u22a2 \u220f a \u2208 s, \u220f b \u2208 bipartiteAbove r t a, f a b = \u220f b \u2208 t, \u220f a \u2208 bipartiteBelow r s b, f a b"}, {"line": "simp_rw [bipartiteAbove, bipartiteBelow, prod_filter]", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\ns : Finset \u03b1\nt : Finset \u03b2\ninst\u271d\u00b9 : CommMonoid R\nf : \u03b1 \u2192 \u03b2 \u2192 R\ninst\u271d : (a : \u03b1) \u2192 (b : \u03b2) \u2192 Decidable (r a b)\n\u22a2 (\u220f x \u2208 s, \u220f a \u2208 t, if r x a then f x a else 1) = \u220f x \u2208 t, \u220f a \u2208 s, if r a x then f a x else 1"}, {"line": "exact prod_comm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_card_bipartiteAbove_eq_sum_card_bipartiteBelow [\u2200 a b, Decidable (r a b)] :\n    (\u2211 a \u2208 s, #(t.bipartiteAbove r a)) = \u2211 b \u2208 t, #(s.bipartiteBelow r b) := by\n  simp_rw [card_eq_sum_ones, sum_sum_bipartiteAbove_eq_sum_sum_bipartiteBelow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/DoubleCounting.lean", "context": {"open": ["Finset Function Relator"], "variables": ["{R \u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b2 \u2192 Prop) (s : Finset \u03b1) (t : Finset \u03b2) (a : \u03b1) (b : \u03b2)", "{s t a b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\ns : Finset \u03b1\nt : Finset \u03b2\ninst\u271d : (a : \u03b1) \u2192 (b : \u03b2) \u2192 Decidable (r a b)\n\u22a2 \u2211 a \u2208 s, (bipartiteAbove r t a).card = \u2211 b \u2208 t, (bipartiteBelow r s b).card"}, {"line": "simp_rw [card_eq_sum_ones, sum_sum_bipartiteAbove_eq_sum_sum_bipartiteBelow]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma DyckStep.dichotomy (s : DyckStep) : s = U \u2228 s = D := by cases s <;> tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/DyckWord.lean", "context": {"open": ["List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : DyckStep\n\u22a2 s = U \u2228 s = D"}, {"line": "cases s <;> tauto", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nest_denest (hn) : (p.denest hn).nest = p := by\n  simpa [DyckWord.ext_iff] using p.cons_tail_dropLast_concat hn.1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/DyckWord.lean", "context": {"open": ["List", "DyckStep"], "variables": ["{p q : DyckWord}", "(h : p \u2260 0)", "(p) in", "(p) in", "(p) in", "(p) in", "(p) in", "(p) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : DyckWord\nhn : p.IsNested\n\u22a2 (p.denest hn).nest = p"}, {"line": "simpa [DyckWord.ext_iff] using p.cons_tail_dropLast_concat hn.1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma count_D_lt_count_U_of_lt_firstReturn {i : \u2115} (hi : i < p.firstReturn) :\n    (p.toList.take (i + 1)).count D < (p.toList.take (i + 1)).count U := by\n  have ne := not_of_lt_findIdx hi\n  rw [decide_eq_false_iff_not] at ne\n  rw [\u2190 ne_eq] at ne\n  rw [getElem_range] at ne\n  exact lt_of_le_of_ne (p.count_D_le_count_U (i + 1)) ne.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/DyckWord.lean", "context": {"open": ["List", "DyckStep"], "variables": ["{p q : DyckWord}", "(h : p \u2260 0)", "(p) in", "(p) in", "(p) in", "(p) in", "(p) in", "(p) in", "(p) in", "(p) in", "(p) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : DyckWord\ni : \u2115\nhi : i < p.firstReturn\n\u22a2 count D (take (i + 1) \u2191p) < count U (take (i + 1) \u2191p)"}, {"line": "have ne := not_of_lt_findIdx hi", "tactic_state": "p : DyckWord\ni : \u2115\nhi : i < p.firstReturn\nne : decide (count U (take ((range (\u2191p).length)[i] + 1) \u2191p) = count D (take ((range (\u2191p).length)[i] + 1) \u2191p)) = false\n\u22a2 count D (take (i + 1) \u2191p) < count U (take (i + 1) \u2191p)"}, {"line": "rw [decide_eq_false_iff_not] at ne", "tactic_state": "p : DyckWord\ni : \u2115\nhi : i < p.firstReturn\nne : \u00account U (take ((range (\u2191p).length)[i] + 1) \u2191p) = count D (take ((range (\u2191p).length)[i] + 1) \u2191p)\n\u22a2 count D (take (i + 1) \u2191p) < count U (take (i + 1) \u2191p)"}, {"line": "rw [\u2190 ne_eq] at ne", "tactic_state": "p : DyckWord\ni : \u2115\nhi : i < p.firstReturn\nne : count U (take ((range (\u2191p).length)[i] + 1) \u2191p) \u2260 count D (take ((range (\u2191p).length)[i] + 1) \u2191p)\n\u22a2 count D (take (i + 1) \u2191p) < count U (take (i + 1) \u2191p)"}, {"line": "rw [getElem_range] at ne", "tactic_state": "p : DyckWord\ni : \u2115\nhi : i < p.firstReturn\nne : count U (take (i + 1) \u2191p) \u2260 count D (take (i + 1) \u2191p)\n\u22a2 count D (take (i + 1) \u2191p) < count U (take (i + 1) \u2191p)"}, {"line": "exact lt_of_le_of_ne (p.count_D_le_count_U (i + 1)) ne.symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_add_self (p q : DyckWord) : q \u2264 p + q := by\n  by_cases h : p = 0\n  \u00b7 simp [h]\n  \u00b7 have := semilength_outsidePart_lt h\n    exact (le_add_self p.outsidePart q).trans\n      (Relation.ReflTransGen.single (Or.inr (outsidePart_add h).symm))", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/DyckWord.lean", "context": {"open": ["List", "DyckStep"], "variables": ["{p q : DyckWord}", "(h : p \u2260 0)", "(p) in", "(p) in", "(p) in", "(p) in", "(p) in", "(p) in", "(p) in", "(p) in", "(p) in", "(p) in", "(p) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : DyckWord\n\u22a2 q \u2264 p + q"}, {"line": "by_cases h : p = 0", "tactic_state": "case pos\np q : DyckWord\nh : p = 0\n\u22a2 q \u2264 p + q\n---\ncase neg\np q : DyckWord\nh : \u00acp = 0\n\u22a2 q \u2264 p + q"}, {"line": "\u00b7 simp [h]", "tactic_state": "case neg\np q : DyckWord\nh : \u00acp = 0\n\u22a2 q \u2264 p + q"}, {"line": "\u00b7 have := semilength_outsidePart_lt h\n    exact (le_add_self p.outsidePart q).trans\n      (Relation.ReflTransGen.single (Or.inr (outsidePart_add h).symm))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ext \u2983f g : IncidenceAlgebra \ud835\udd5c \u03b1\u2984 (h : \u2200 a b, a \u2264 b \u2192 f a b = g a b) : f = g := by\n  refine DFunLike.coe_injective' (funext\u2082 fun a b \u21a6 ?_)\n  by_cases hab : a \u2264 b\n  \u00b7 exact h _ _ hab\n  \u00b7 rw [apply_eq_zero_of_not_le hab, apply_eq_zero_of_not_le hab]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/IncidenceAlgebra.lean", "context": {"open": ["Finset OrderDual"], "variables": ["{F \ud835\udd5c \ud835\udd5d \ud835\udd5e \u03b1 \u03b2 : Type*}", "[Zero \ud835\udd5c] [LE \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_2\n\u03b1 : Type u_5\ninst\u271d\u00b9 : Zero \ud835\udd5c\ninst\u271d : LE \u03b1\nf g : IncidenceAlgebra \ud835\udd5c \u03b1\nh : \u2200 (a b : \u03b1), a \u2264 b \u2192 f a b = g a b\n\u22a2 f = g"}, {"line": "refine DFunLike.coe_injective' (funext\u2082 fun a b \u21a6 ?_)", "tactic_state": "\ud835\udd5c : Type u_2\n\u03b1 : Type u_5\ninst\u271d\u00b9 : Zero \ud835\udd5c\ninst\u271d : LE \u03b1\nf g : IncidenceAlgebra \ud835\udd5c \u03b1\nh : \u2200 (a b : \u03b1), a \u2264 b \u2192 f a b = g a b\na b : \u03b1\n\u22a2 f a b = g a b"}, {"line": "by_cases hab : a \u2264 b", "tactic_state": "case pos\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_5\ninst\u271d\u00b9 : Zero \ud835\udd5c\ninst\u271d : LE \u03b1\nf g : IncidenceAlgebra \ud835\udd5c \u03b1\nh : \u2200 (a b : \u03b1), a \u2264 b \u2192 f a b = g a b\na b : \u03b1\nhab : sorry\n\u22a2 f a b = g a b\n---\ncase neg\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_5\ninst\u271d\u00b9 : Zero \ud835\udd5c\ninst\u271d : LE \u03b1\nf g : IncidenceAlgebra \ud835\udd5c \u03b1\nh : \u2200 (a b : \u03b1), a \u2264 b \u2192 f a b = g a b\na b : \u03b1\nhab : \u00acsorry\n\u22a2 f a b = g a b"}, {"line": "\u00b7 exact h _ _ hab", "tactic_state": "case neg\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_5\ninst\u271d\u00b9 : Zero \ud835\udd5c\ninst\u271d : LE \u03b1\nf g : IncidenceAlgebra \ud835\udd5c \u03b1\nh : \u2200 (a b : \u03b1), a \u2264 b \u2192 f a b = g a b\na b : \u03b1\nhab : \u00acsorry\n\u22a2 f a b = g a b"}, {"line": "\u00b7 rw [apply_eq_zero_of_not_le hab, apply_eq_zero_of_not_le hab]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sum_Icc_mu_right (a b : \u03b1) : \u2211 x \u2208 Icc a b, mu \ud835\udd5c a x = if a = b then 1 else 0 := by\n  split_ifs with hab\n  \u00b7 simp [hab]\n  by_cases hab : a \u2264 b\n  \u00b7 simp [Icc_eq_cons_Ico hab, mu_eq_neg_sum_Ico_of_ne \u2039_\u203a]\n  \u00b7 exact sum_eq_zero fun x hx \u21a6 apply_eq_zero_of_not_le\n      (fun hax \u21a6 hab <| hax.trans (mem_Icc.1 hx).2) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/IncidenceAlgebra.lean", "context": {"open": ["Finset OrderDual"], "variables": ["{F \ud835\udd5c \ud835\udd5d \ud835\udd5e \u03b1 \u03b2 : Type*}", "[Zero \ud835\udd5c] [LE \u03b1] {a b : \u03b1}", "[AddZeroClass \ud835\udd5c] [LE \u03b1]", "{M : Type*} [Zero \ud835\udd5c] [LE \u03b1] [SMulZeroClass M \ud835\udd5c]", "[AddGroup \ud835\udd5c] [LE \u03b1]", "[Preorder \u03b1] [DecidableEq \u03b1] [Zero \ud835\udd5c] [One \ud835\udd5c]", "[Preorder \u03b1] [LocallyFiniteOrder \u03b1] [AddCommMonoid \ud835\udd5c] [Mul \ud835\udd5c]", "[Preorder \u03b1] [LocallyFiniteOrder \u03b1] [AddCommMonoid \ud835\udd5c] [AddCommMonoid \ud835\udd5d] [SMul \ud835\udd5c \ud835\udd5d]", "(\ud835\udd5c) [Zero \ud835\udd5c] [One \ud835\udd5c] [Preorder \u03b1] [DecidableRel (\u03b1 := \u03b1) (\u00b7 \u2a7f \u00b7)]", "(\ud835\udd5c) [Zero \ud835\udd5c] [One \ud835\udd5c] [LE \u03b1] [DecidableLE \u03b1] {a b : \u03b1}", "{\ud835\udd5c}", "(\ud835\udd5c) [AddCommGroup \ud835\udd5c] [One \ud835\udd5c] [Preorder \u03b1] [LocallyFiniteOrder \u03b1] [DecidableEq \u03b1]", "{\ud835\udd5c} {a b : \u03b1}", "(\ud835\udd5c \u03b1)", "[AddCommGroup \ud835\udd5c] [One \ud835\udd5c] [PartialOrder \u03b1] [LocallyFiniteOrder \u03b1] [DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b9\u2077 inst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 inst\u271d\u00b9\u2074 : LE \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b1\ninst\u271d\u00b9\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : DecidableRel fun x1 x2 => x1 \u2a7f x2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_8\nmu : x\u271d\na b : \u03b1\n\u22a2 \u2211 x \u2208 Icc a b, sorry = if a = b then 1 else 0"}, {"line": "split_ifs with hab", "tactic_state": "case pos\n\u03b1 : Type u_5\ninst\u271d\u00b9\u2077 inst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 inst\u271d\u00b9\u2074 : LE \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b1\ninst\u271d\u00b9\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : DecidableRel fun x1 x2 => x1 \u2a7f x2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_8\nmu : x\u271d\na b : \u03b1\nhab : a = b\n\u22a2 \u2211 x \u2208 Icc a b, sorry = 1\n---\ncase neg\n\u03b1 : Type u_5\ninst\u271d\u00b9\u2077 inst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 inst\u271d\u00b9\u2074 : LE \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b1\ninst\u271d\u00b9\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : DecidableRel fun x1 x2 => x1 \u2a7f x2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_8\nmu : x\u271d\na b : \u03b1\nhab : \u00aca = b\n\u22a2 \u2211 x \u2208 Icc a b, sorry = 0"}, {"line": "\u00b7 simp [hab]", "tactic_state": "case neg\n\u03b1 : Type u_5\ninst\u271d\u00b9\u2077 inst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 inst\u271d\u00b9\u2074 : LE \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b1\ninst\u271d\u00b9\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : DecidableRel fun x1 x2 => x1 \u2a7f x2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_8\nmu : x\u271d\na b : \u03b1\nhab : \u00aca = b\n\u22a2 \u2211 x \u2208 Icc a b, sorry = 0"}, {"line": "by_cases hab : a \u2264 b", "tactic_state": "case pos\n\u03b1 : Type u_5\ninst\u271d\u00b9\u2077 inst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 inst\u271d\u00b9\u2074 : LE \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b1\ninst\u271d\u00b9\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : DecidableRel fun x1 x2 => x1 \u2a7f x2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_8\nmu : x\u271d\na b : \u03b1\nhab\u271d : \u00aca = b\nhab : sorry\n\u22a2 \u2211 x \u2208 Icc a b, sorry = 0\n---\ncase neg\n\u03b1 : Type u_5\ninst\u271d\u00b9\u2077 inst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 inst\u271d\u00b9\u2074 : LE \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b1\ninst\u271d\u00b9\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : DecidableRel fun x1 x2 => x1 \u2a7f x2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_8\nmu : x\u271d\na b : \u03b1\nhab\u271d : \u00aca = b\nhab : \u00acsorry\n\u22a2 \u2211 x \u2208 Icc a b, sorry = 0"}, {"line": "\u00b7 simp [Icc_eq_cons_Ico hab, mu_eq_neg_sum_Ico_of_ne \u2039_\u203a]", "tactic_state": "case neg\n\u03b1 : Type u_5\ninst\u271d\u00b9\u2077 inst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 inst\u271d\u00b9\u2074 : LE \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b1\ninst\u271d\u00b9\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : DecidableRel fun x1 x2 => x1 \u2a7f x2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_8\nmu : x\u271d\na b : \u03b1\nhab\u271d : \u00aca = b\nhab : \u00acsorry\n\u22a2 \u2211 x \u2208 Icc a b, sorry = 0"}, {"line": "\u00b7 exact sum_eq_zero fun x hx \u21a6 apply_eq_zero_of_not_le\n      (fun hax \u21a6 hab <| hax.trans (mem_Icc.1 hx).2) _", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma sum_Icc_mu'_left (a b : \u03b1) : \u2211 x \u2208 Icc a b, mu' \ud835\udd5c x b = if a = b then 1 else 0 := by\n  split_ifs with hab\n  \u00b7 simp [hab]\n  by_cases hab : a \u2264 b\n  \u00b7 simp [Icc_eq_cons_Ioc hab, mu'_eq_sum_Ioc_of_ne \u2039_\u203a]\n  \u00b7 exact sum_eq_zero fun x hx \u21a6 apply_eq_zero_of_not_le\n      (fun hxb \u21a6 hab <| (mem_Icc.1 hx).1.trans hxb) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Enumerative/IncidenceAlgebra.lean", "context": {"open": ["Finset OrderDual"], "variables": ["{F \ud835\udd5c \ud835\udd5d \ud835\udd5e \u03b1 \u03b2 : Type*}", "[Zero \ud835\udd5c] [LE \u03b1] {a b : \u03b1}", "[AddZeroClass \ud835\udd5c] [LE \u03b1]", "{M : Type*} [Zero \ud835\udd5c] [LE \u03b1] [SMulZeroClass M \ud835\udd5c]", "[AddGroup \ud835\udd5c] [LE \u03b1]", "[Preorder \u03b1] [DecidableEq \u03b1] [Zero \ud835\udd5c] [One \ud835\udd5c]", "[Preorder \u03b1] [LocallyFiniteOrder \u03b1] [AddCommMonoid \ud835\udd5c] [Mul \ud835\udd5c]", "[Preorder \u03b1] [LocallyFiniteOrder \u03b1] [AddCommMonoid \ud835\udd5c] [AddCommMonoid \ud835\udd5d] [SMul \ud835\udd5c \ud835\udd5d]", "(\ud835\udd5c) [Zero \ud835\udd5c] [One \ud835\udd5c] [Preorder \u03b1] [DecidableRel (\u03b1 := \u03b1) (\u00b7 \u2a7f \u00b7)]", "(\ud835\udd5c) [Zero \ud835\udd5c] [One \ud835\udd5c] [LE \u03b1] [DecidableLE \u03b1] {a b : \u03b1}", "{\ud835\udd5c}", "(\ud835\udd5c) [AddCommGroup \ud835\udd5c] [One \ud835\udd5c] [Preorder \u03b1] [LocallyFiniteOrder \u03b1] [DecidableEq \u03b1]", "{\ud835\udd5c} {a b : \u03b1}", "(\ud835\udd5c \u03b1)", "[AddCommGroup \ud835\udd5c] [One \ud835\udd5c] [PartialOrder \u03b1] [LocallyFiniteOrder \u03b1] [DecidableEq \u03b1]", "(\ud835\udd5c) [AddCommGroup \ud835\udd5c] [One \ud835\udd5c] [Preorder \u03b1] [LocallyFiniteOrder \u03b1] [DecidableEq \u03b1]", "{\ud835\udd5c} {a b : \u03b1}", "[AddCommGroup \ud835\udd5c] [One \ud835\udd5c] [PartialOrder \u03b1] [LocallyFiniteOrder \u03b1] [DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b2\u2070 inst\u271d\u00b9\u2079 inst\u271d\u00b9\u2078 inst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : DecidableEq \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : DecidableRel fun x1 x2 => x1 \u2a7f x2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_8\nmu' : x\u271d\na b : \u03b1\n\u22a2 \u2211 x \u2208 Icc a b, sorry = if a = b then 1 else 0"}, {"line": "split_ifs with hab", "tactic_state": "case pos\n\u03b1 : Type u_5\ninst\u271d\u00b2\u2070 inst\u271d\u00b9\u2079 inst\u271d\u00b9\u2078 inst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : DecidableEq \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : DecidableRel fun x1 x2 => x1 \u2a7f x2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_8\nmu' : x\u271d\na b : \u03b1\nhab : a = b\n\u22a2 \u2211 x \u2208 Icc a b, sorry = 1\n---\ncase neg\n\u03b1 : Type u_5\ninst\u271d\u00b2\u2070 inst\u271d\u00b9\u2079 inst\u271d\u00b9\u2078 inst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : DecidableEq \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : DecidableRel fun x1 x2 => x1 \u2a7f x2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_8\nmu' : x\u271d\na b : \u03b1\nhab : \u00aca = b\n\u22a2 \u2211 x \u2208 Icc a b, sorry = 0"}, {"line": "\u00b7 simp [hab]", "tactic_state": "case neg\n\u03b1 : Type u_5\ninst\u271d\u00b2\u2070 inst\u271d\u00b9\u2079 inst\u271d\u00b9\u2078 inst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : DecidableEq \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : DecidableRel fun x1 x2 => x1 \u2a7f x2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_8\nmu' : x\u271d\na b : \u03b1\nhab : \u00aca = b\n\u22a2 \u2211 x \u2208 Icc a b, sorry = 0"}, {"line": "by_cases hab : a \u2264 b", "tactic_state": "case pos\n\u03b1 : Type u_5\ninst\u271d\u00b2\u2070 inst\u271d\u00b9\u2079 inst\u271d\u00b9\u2078 inst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : DecidableEq \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : DecidableRel fun x1 x2 => x1 \u2a7f x2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_8\nmu' : x\u271d\na b : \u03b1\nhab\u271d : \u00aca = b\nhab : sorry\n\u22a2 \u2211 x \u2208 Icc a b, sorry = 0\n---\ncase neg\n\u03b1 : Type u_5\ninst\u271d\u00b2\u2070 inst\u271d\u00b9\u2079 inst\u271d\u00b9\u2078 inst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : DecidableEq \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : DecidableRel fun x1 x2 => x1 \u2a7f x2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_8\nmu' : x\u271d\na b : \u03b1\nhab\u271d : \u00aca = b\nhab : \u00acsorry\n\u22a2 \u2211 x \u2208 Icc a b, sorry = 0"}, {"line": "\u00b7 simp [Icc_eq_cons_Ioc hab, mu'_eq_sum_Ioc_of_ne \u2039_\u203a]", "tactic_state": "case neg\n\u03b1 : Type u_5\ninst\u271d\u00b2\u2070 inst\u271d\u00b9\u2079 inst\u271d\u00b9\u2078 inst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : DecidableEq \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : DecidableRel fun x1 x2 => x1 \u2a7f x2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_8\nmu' : x\u271d\na b : \u03b1\nhab\u271d : \u00aca = b\nhab : \u00acsorry\n\u22a2 \u2211 x \u2208 Icc a b, sorry = 0"}, {"line": "\u00b7 exact sum_eq_zero fun x hx \u21a6 apply_eq_zero_of_not_le\n      (fun hxb \u21a6 hab <| (mem_Icc.1 hx).1.trans hxb) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ruzsaSzemerediNumberNat_lower_bound (n : \u2115) :\n    (n / 3 - 2 : \u211d) * \u2191((n - 3) / 6) * exp (-4 * sqrt (log \u2191((n - 3) / 6))) \u2264\n      ruzsaSzemerediNumberNat n := by\n  rw [mul_assoc]\n  obtain hn | hn := le_total (n / 3 - 2 : \u211d) 0\n  \u00b7 exact (mul_nonpos_of_nonpos_of_nonneg hn <| by positivity).trans (Nat.cast_nonneg _)\n  exact\n    (mul_le_mul_of_nonneg_left Behrend.roth_lower_bound hn).trans\n      (rothNumberNat_le_ruzsaSzemerediNumberNat' _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Extremal/RuzsaSzemeredi.lean", "context": {"open": ["Finset Nat Real SimpleGraph Sum3 SimpleGraph.TripartiteFromTriangles", "Fintype (card)", "scoped Pointwise", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [DecidableEq \u03b2] [Fintype \u03b1] [Fintype \u03b2] {G H : SimpleGraph \u03b1}", "(\u03b1) in", "{n : \u2115}", "[Fintype \u03b1] [CommRing \u03b1] {s : Finset \u03b1} {x : \u03b1 \u00d7 \u03b1 \u00d7 \u03b1}", "[Fact <| IsUnit (2 : \u03b1)]", "(\u03b1) [Fintype \u03b1] [DecidableEq \u03b1] [CommRing \u03b1] [Fact <| IsUnit (2 : \u03b1)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 (\u2191n / 3 - 2) * \u2191((n - 3) / 6) * exp (-4 * \u221a(Real.log \u2191((n - 3) / 6))) \u2264 \u2191(ruzsaSzemerediNumberNat n)"}, {"line": "rw [mul_assoc]", "tactic_state": "n : \u2115\n\u22a2 (\u2191n / 3 - 2) * (\u2191((n - 3) / 6) * exp (-4 * \u221a(Real.log \u2191((n - 3) / 6)))) \u2264 \u2191(ruzsaSzemerediNumberNat n)"}, {"line": "obtain hn | hn := le_total (n / 3 - 2 : \u211d) 0", "tactic_state": "case inl\nn : \u2115\nhn : \u2191n / 3 - 2 \u2264 0\n\u22a2 (\u2191n / 3 - 2) * (\u2191((n - 3) / 6) * exp (-4 * \u221a(Real.log \u2191((n - 3) / 6)))) \u2264 \u2191(ruzsaSzemerediNumberNat n)\n---\ncase inr\nn : \u2115\nhn : 0 \u2264 \u2191n / 3 - 2\n\u22a2 (\u2191n / 3 - 2) * (\u2191((n - 3) / 6) * exp (-4 * \u221a(Real.log \u2191((n - 3) / 6)))) \u2264 \u2191(ruzsaSzemerediNumberNat n)"}, {"line": "\u00b7 exact (mul_nonpos_of_nonpos_of_nonneg hn <| by positivity).trans (Nat.cast_nonneg _)", "tactic_state": "case inr\nn : \u2115\nhn : 0 \u2264 \u2191n / 3 - 2\n\u22a2 (\u2191n / 3 - 2) * (\u2191((n - 3) / 6) * exp (-4 * \u221a(Real.log \u2191((n - 3) / 6)))) \u2264 \u2191(ruzsaSzemerediNumberNat n)"}, {"line": "exact\n    (mul_le_mul_of_nonneg_left Behrend.roth_lower_bound hn).trans\n      (rothNumberNat_le_ruzsaSzemerediNumberNat' _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hallMatchingsOn.nonempty {\u03b9 : Type u} {\u03b1 : Type v} [DecidableEq \u03b1] (t : \u03b9 \u2192 Finset \u03b1)\n    (h : \u2200 s : Finset \u03b9, #s \u2264 #(s.biUnion t)) (\u03b9' : Finset \u03b9) :\n    Nonempty (hallMatchingsOn t \u03b9') := by\n  classical\n    refine \u27e8Classical.indefiniteDescription _ ?_\u27e9\n    apply (all_card_le_biUnion_card_iff_existsInjective' fun i : \u03b9' => t i).mp\n    intro s'\n    convert h (s'.image (\u2191)) using 1\n    \u00b7 simp only [card_image_of_injective s' Subtype.coe_injective]\n    \u00b7 rw [image_biUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Hall/Basic.lean", "context": {"open": ["Finset Function CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b1 : Type v\ninst\u271d : DecidableEq \u03b1\nt : \u03b9 \u2192 Finset \u03b1\nh : \u2200 (s : Finset \u03b9), s.card \u2264 (s.biUnion t).card\n\u03b9' : Finset \u03b9\n\u22a2 Nonempty \u2191(hallMatchingsOn t \u03b9')"}, {"line": "classical\n    refine \u27e8Classical.indefiniteDescription _ ?_\u27e9\n    apply (all_card_le_biUnion_card_iff_existsInjective' fun i : \u03b9' => t i).mp\n    intro s'\n    convert h (s'.image (\u2191)) using 1\n    \u00b7 simp only [card_image_of_injective s' Subtype.coe_injective]\n    \u00b7 rw [image_biUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hall_cond_of_restrict {\u03b9 : Type u} {t : \u03b9 \u2192 Finset \u03b1} {s : Finset \u03b9}\n    (ht : \u2200 s : Finset \u03b9, #s \u2264 #(s.biUnion t)) (s' : Finset (s : Set \u03b9)) :\n    #s' \u2264 #(s'.biUnion fun a' => t a') := by\n  classical\n    rw [\u2190 card_image_of_injective s' Subtype.coe_injective]\n    convert ht (s'.image fun z => z.1) using 1\n    apply congr_arg\n    ext y\n    simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Hall/Finite.lean", "context": {"open": ["Finset"], "variables": ["{\u03b9 : Type u} {\u03b1 : Type v} [DecidableEq \u03b1] {t : \u03b9 \u2192 Finset \u03b1}", "[Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type v\ninst\u271d : DecidableEq \u03b1\n\u03b9 : Type u\nt : \u03b9 \u2192 Finset \u03b1\ns : Finset \u03b9\nht : \u2200 (s : Finset \u03b9), s.card \u2264 (s.biUnion t).card\ns' : Finset \u2191\u2191s\n\u22a2 s'.card \u2264 (s'.biUnion fun a' => t \u2191a').card"}, {"line": "classical\n    rw [\u2190 card_image_of_injective s' Subtype.coe_injective]\n    convert ht (s'.image fun z => z.1) using 1\n    apply congr_arg\n    ext y\n    simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Hom.cast_eq_cast {u v u' v' : U} (hu : u = u') (hv : v = v') (e : u \u27f6 v) :\n    e.cast hu hv = _root_.cast (by {rw [hu, hv]}) e := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Quiver/Cast.lean", "context": {"open": [], "variables": ["{U : Type*} [Quiver.{u + 1} U]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "U : Type u_1\ninst\u271d : Quiver U\nu v u' v' : U\nhu : u = u'\nhv : v = v'\ne : u \u27f6 v\n\u22a2 Quiver.Hom.cast hu hv e = cast \u22ef e"}, {"line": "subst_vars", "tactic_state": "U : Type u_1\ninst\u271d : Quiver U\nu' v' : U\ne : u' \u27f6 v'\n\u22a2 Quiver.Hom.cast \u22ef \u22ef e = cast \u22ef e"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Hom.cast_cast {u v u' v' u'' v'' : U} (e : u \u27f6 v) (hu : u = u') (hv : v = v')\n    (hu' : u' = u'') (hv' : v' = v'') :\n    (e.cast hu hv).cast hu' hv' = e.cast (hu.trans hu') (hv.trans hv') := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Quiver/Cast.lean", "context": {"open": [], "variables": ["{U : Type*} [Quiver.{u + 1} U]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "U : Type u_1\ninst\u271d : Quiver U\nu v u' v' u'' v'' : U\ne : u \u27f6 v\nhu : u = u'\nhv : v = v'\nhu' : u' = u''\nhv' : v' = v''\n\u22a2 Quiver.Hom.cast hu' hv' (Quiver.Hom.cast hu hv e) = Quiver.Hom.cast \u22ef \u22ef e"}, {"line": "subst_vars", "tactic_state": "U : Type u_1\ninst\u271d : Quiver U\nu'' v'' : U\ne : u'' \u27f6 v''\n\u22a2 Quiver.Hom.cast \u22ef \u22ef (Quiver.Hom.cast \u22ef \u22ef e) = Quiver.Hom.cast \u22ef \u22ef e"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Hom.cast_heq {u v u' v' : U} (hu : u = u') (hv : v = v') (e : u \u27f6 v) :\n    HEq (e.cast hu hv) e := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Quiver/Cast.lean", "context": {"open": [], "variables": ["{U : Type*} [Quiver.{u + 1} U]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "U : Type u_1\ninst\u271d : Quiver U\nu v u' v' : U\nhu : u = u'\nhv : v = v'\ne : u \u27f6 v\n\u22a2 HEq (Quiver.Hom.cast hu hv e) e"}, {"line": "subst_vars", "tactic_state": "U : Type u_1\ninst\u271d : Quiver U\nu' v' : U\ne : u' \u27f6 v'\n\u22a2 HEq (Quiver.Hom.cast \u22ef \u22ef e) e"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Path.cast_cast {u v u' v' u'' v'' : U} (p : Path u v) (hu : u = u') (hv : v = v')\n    (hu' : u' = u'') (hv' : v' = v'') :\n    (p.cast hu hv).cast hu' hv' = p.cast (hu.trans hu') (hv.trans hv') := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Quiver/Cast.lean", "context": {"open": ["Path"], "variables": ["{U : Type*} [Quiver.{u + 1} U]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "U : Type u_1\ninst\u271d : Quiver U\nu v u' v' u'' v'' : U\np : sorry\nhu : u = u'\nhv : v = v'\nhu' : u' = u''\nhv' : v' = v''\n\u22a2 sorry = sorry"}, {"line": "subst_vars", "tactic_state": "U : Type u_1\ninst\u271d : Quiver U\nu'' v'' : U\np : sorry\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Path.cast_nil {u u' : U} (hu : u = u') : (Path.nil : Path u u).cast hu hu = Path.nil := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Quiver/Cast.lean", "context": {"open": ["Path"], "variables": ["{U : Type*} [Quiver.{u + 1} U]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "U : Type u_1\ninst\u271d : Quiver U\nu u' : U\nhu : u = u'\n\u22a2 sorry = sorry"}, {"line": "subst_vars", "tactic_state": "U : Type u_1\ninst\u271d : Quiver U\nu' : U\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Path.cast_cons {u v w u' w' : U} (p : Path u v) (e : v \u27f6 w) (hu : u = u') (hw : w = w') :\n    (p.cons e).cast hu hw = (p.cast hu rfl).cons (e.cast rfl hw) := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Quiver/Cast.lean", "context": {"open": ["Path"], "variables": ["{U : Type*} [Quiver.{u + 1} U]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "U : Type u_1\ninst\u271d : Quiver U\nu v w u' w' : U\np : sorry\ne : v \u27f6 w\nhu : u = u'\nhw : w = w'\n\u22a2 sorry = sorry"}, {"line": "subst_vars", "tactic_state": "U : Type u_1\ninst\u271d : Quiver U\nv u' w' : U\np : sorry\ne : v \u27f6 w'\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ext {V : Type u} [Quiver.{v\u2081} V] {W : Type u\u2082} [Quiver.{v\u2082} W] {F G : Prefunctor V W}\n    (h_obj : \u2200 X, F.obj X = G.obj X)\n    (h_map : \u2200 (X Y : V) (f : X \u27f6 Y),\n      F.map f = Eq.recOn (h_obj Y).symm (Eq.recOn (h_obj X).symm (G.map f))) : F = G := by\n  obtain \u27e8F_obj, _\u27e9 := F\n  obtain \u27e8G_obj, _\u27e9 := G\n  obtain rfl : F_obj = G_obj := by\n    ext X\n    apply h_obj\n  congr\n  funext X Y f\n  simpa using h_map X Y f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Quiver/Prefunctor.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Quiver V\nW : Type u\u2082\ninst\u271d : Quiver W\nF G : V \u2964q W\nh_obj : \u2200 (X : V), F.obj X = G.obj X\nh_map : \u2200 (X Y : V) (f : X \u27f6 Y), F.map f = Eq.recOn \u22ef (Eq.recOn \u22ef (G.map f))\n\u22a2 F = G"}, {"line": "obtain \u27e8F_obj, _\u27e9 := F", "tactic_state": "case mk\nV : Type u\ninst\u271d\u00b9 : Quiver V\nW : Type u\u2082\ninst\u271d : Quiver W\nG : V \u2964q W\nF_obj : V \u2192 W\nmap\u271d : {X Y : V} \u2192 (X \u27f6 Y) \u2192 (F_obj X \u27f6 F_obj Y)\nh_obj : \u2200 (X : V), { obj := F_obj, map := map\u271d }.obj X = G.obj X\nh_map : \u2200 (X Y : V) (f : X \u27f6 Y), { obj := F_obj, map := map\u271d }.map f = Eq.recOn \u22ef (Eq.recOn \u22ef (G.map f))\n\u22a2 { obj := F_obj, map := map\u271d } = G"}, {"line": "obtain \u27e8G_obj, _\u27e9 := G", "tactic_state": "case mk.mk\nV : Type u\ninst\u271d\u00b9 : Quiver V\nW : Type u\u2082\ninst\u271d : Quiver W\nF_obj : V \u2192 W\nmap\u271d\u00b9 : {X Y : V} \u2192 (X \u27f6 Y) \u2192 (F_obj X \u27f6 F_obj Y)\nG_obj : V \u2192 W\nmap\u271d : {X Y : V} \u2192 (X \u27f6 Y) \u2192 (G_obj X \u27f6 G_obj Y)\nh_obj : \u2200 (X : V), { obj := F_obj, map := map\u271d\u00b9 }.obj X = { obj := G_obj, map := map\u271d }.obj X\nh_map :\n  \u2200 (X Y : V) (f : X \u27f6 Y),\n    { obj := F_obj, map := map\u271d\u00b9 }.map f = Eq.recOn \u22ef (Eq.recOn \u22ef ({ obj := G_obj, map := map\u271d }.map f))\n\u22a2 { obj := F_obj, map := map\u271d\u00b9 } = { obj := G_obj, map := map\u271d }"}, {"line": "obtain rfl : F_obj = G_obj := by\n    ext X\n    apply h_obj", "tactic_state": "case mk.mk\nV : Type u\ninst\u271d\u00b9 : Quiver V\nW : Type u\u2082\ninst\u271d : Quiver W\nF_obj : V \u2192 W\nmap\u271d\u00b9 map\u271d : {X Y : V} \u2192 (X \u27f6 Y) \u2192 (F_obj X \u27f6 F_obj Y)\nh_obj : \u2200 (X : V), { obj := F_obj, map := map\u271d\u00b9 }.obj X = { obj := F_obj, map := map\u271d }.obj X\nh_map :\n  \u2200 (X Y : V) (f : X \u27f6 Y),\n    { obj := F_obj, map := map\u271d\u00b9 }.map f = Eq.recOn \u22ef (Eq.recOn \u22ef ({ obj := F_obj, map := map\u271d }.map f))\n\u22a2 { obj := F_obj, map := map\u271d\u00b9 } = { obj := F_obj, map := map\u271d }"}, {"line": "congr", "tactic_state": "case mk.mk.e_map\nV : Type u\ninst\u271d\u00b9 : Quiver V\nW : Type u\u2082\ninst\u271d : Quiver W\nF_obj : V \u2192 W\nmap\u271d\u00b9 map\u271d : {X Y : V} \u2192 (X \u27f6 Y) \u2192 (F_obj X \u27f6 F_obj Y)\nh_obj : \u2200 (X : V), { obj := F_obj, map := map\u271d\u00b9 }.obj X = { obj := F_obj, map := map\u271d }.obj X\nh_map :\n  \u2200 (X Y : V) (f : X \u27f6 Y),\n    { obj := F_obj, map := map\u271d\u00b9 }.map f = Eq.recOn \u22ef (Eq.recOn \u22ef ({ obj := F_obj, map := map\u271d }.map f))\n\u22a2 map\u271d\u00b9 = map\u271d"}, {"line": "funext X Y f", "tactic_state": "case mk.mk.e_map.h.h.h\nV : Type u\ninst\u271d\u00b9 : Quiver V\nW : Type u\u2082\ninst\u271d : Quiver W\nF_obj : V \u2192 W\nmap\u271d\u00b9 map\u271d : {X Y : V} \u2192 (X \u27f6 Y) \u2192 (F_obj X \u27f6 F_obj Y)\nh_obj : \u2200 (X : V), { obj := F_obj, map := map\u271d\u00b9 }.obj X = { obj := F_obj, map := map\u271d }.obj X\nh_map :\n  \u2200 (X Y : V) (f : X \u27f6 Y),\n    { obj := F_obj, map := map\u271d\u00b9 }.map f = Eq.recOn \u22ef (Eq.recOn \u22ef ({ obj := F_obj, map := map\u271d }.map f))\nX Y : V\nf : X \u27f6 Y\n\u22a2 map\u271d\u00b9 f = map\u271d f"}, {"line": "simpa using h_map X Y f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem congr_map {U V : Type*} [Quiver U] [Quiver V] (F : U \u2964q V) {X Y : U} {f g : X \u27f6 Y}\n    (h : f = g) : F.map f = F.map g := by\n  rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Quiver/Prefunctor.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "U : Type u_1\nV : Type u_2\ninst\u271d\u00b9 : Quiver U\ninst\u271d : Quiver V\nF : U \u2964q V\nX Y : U\nf g : X \u27f6 Y\nh : f = g\n\u22a2 F.map f = F.map g"}, {"line": "rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem congr_hom {U V : Type*} [Quiver U] [Quiver V] {F G : U \u2964q V} (e : F = G) {X Y : U}\n    (f : X \u27f6 Y) : Quiver.homOfEq (F.map f) (congr_obj e X) (congr_obj e Y) = G.map f := by\n  subst e\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Quiver/Prefunctor.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\ncongr_obj : x\u271d\nU : Type u_1\nV : Type u_2\ninst\u271d\u00b9 : Quiver U\ninst\u271d : Quiver V\nF G : U \u2964q V\ne : F = G\nX Y : U\nf : X \u27f6 Y\n\u22a2 Quiver.homOfEq (F.map f) \u22ef \u22ef = G.map f"}, {"line": "subst e", "tactic_state": "x\u271d : Sort u_3\ncongr_obj : x\u271d\nU : Type u_1\nV : Type u_2\ninst\u271d\u00b9 : Quiver U\ninst\u271d : Quiver V\nF : U \u2964q V\nX Y : U\nf : X \u27f6 Y\n\u22a2 Quiver.homOfEq (F.map f) \u22ef \u22ef = F.map f"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma homOfEq_trans {X Y : V} (f : X \u27f6 Y) {X' Y' : V} (hX : X = X') (hY : Y = Y')\n    {X'' Y'' : V} (hX' : X' = X'') (hY' : Y' = Y'') :\n    homOfEq (homOfEq f hX hY) hX' hY' = homOfEq f (hX.trans hX') (hY.trans hY') := by\n  subst hX hY hX' hY'\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Quiver/Basic.lean", "context": {"open": ["Opposite"], "variables": ["{V : Type*} [Quiver V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d : Quiver V\nx\u271d : Sort u_2\nhomOfEq : x\u271d\nX Y : V\nf : X \u27f6 Y\nX' Y' : V\nhX : X = X'\nhY : Y = Y'\nX'' Y'' : V\nhX' : X' = X''\nhY' : Y' = Y''\n\u22a2 sorry = sorry"}, {"line": "subst hX hY hX' hY'", "tactic_state": "V : Type u_1\ninst\u271d : Quiver V\nx\u271d : Sort u_2\nhomOfEq : x\u271d\nX Y : V\nf : X \u27f6 Y\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma homOfEq_injective {X X' Y Y' : V} (hX : X = X') (hY : Y = Y')\n    {f g : X \u27f6 Y} (h : Quiver.homOfEq f hX hY = Quiver.homOfEq g hX hY) : f = g := by\n  subst hX hY\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Quiver/Basic.lean", "context": {"open": ["Opposite"], "variables": ["{V : Type*} [Quiver V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d : Quiver V\nX X' Y Y' : V\nhX : X = X'\nhY : Y = Y'\nf g : X \u27f6 Y\nh : Quiver.homOfEq f hX hY = Quiver.homOfEq g hX hY\n\u22a2 f = g"}, {"line": "subst hX hY", "tactic_state": "V : Type u_1\ninst\u271d : Quiver V\nX Y : V\nf g : X \u27f6 Y\nh : Quiver.homOfEq f \u22ef \u22ef = Quiver.homOfEq g \u22ef \u22ef\n\u22a2 f = g"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma heq_of_homOfEq_ext {X Y X' Y' : V} (hX : X = X') (hY : Y = Y') {f : X \u27f6 Y} {f' : X' \u27f6 Y'}\n    (e : Quiver.homOfEq f hX hY = f') : HEq f f' := by\n  subst hX hY\n  rw [Quiver.homOfEq_rfl] at e\n  rw [e]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Quiver/Basic.lean", "context": {"open": ["Opposite"], "variables": ["{V : Type*} [Quiver V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d : Quiver V\nX Y X' Y' : V\nhX : X = X'\nhY : Y = Y'\nf : X \u27f6 Y\nf' : X' \u27f6 Y'\ne : Quiver.homOfEq f hX hY = f'\n\u22a2 HEq f f'"}, {"line": "subst hX hY", "tactic_state": "V : Type u_1\ninst\u271d : Quiver V\nX Y : V\nf f' : X \u27f6 Y\ne : Quiver.homOfEq f \u22ef \u22ef = f'\n\u22a2 HEq f f'"}, {"line": "rw [Quiver.homOfEq_rfl] at e", "tactic_state": "V : Type u_1\ninst\u271d : Quiver V\nX Y : V\nf f' : X \u27f6 Y\ne : f = f'\n\u22a2 HEq f f'"}, {"line": "rw [e]", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma binomial_sum_eq (h : n < m) :\n    \u2211 i \u2208 range (n + 1), (n.choose i * (m - n) / ((m - i) * m.choose i) : \u211a) = 1 := by\n  set f : \u2115 \u2192 \u211a := fun i \u21a6 n.choose i * (m.choose i : \u211a)\u207b\u00b9 with hf\n  suffices \u2200 i \u2208 range (n + 1), f i - f (i + 1) = n.choose i * (m - n) / ((m - i) * m.choose i) by\n    rw [\u2190 sum_congr rfl this]\n    rw [sum_range_sub']\n    rw [hf]\n    simp [choose_self, choose_zero_right, choose_eq_zero_of_lt h]\n  intro i h\u2081\n  rw [mem_range] at h\u2081\n  have h\u2081 := le_of_lt_succ h\u2081\n  have h\u2082 := h\u2081.trans_lt h\n  have h\u2083 := h\u2082.le\n  have hi\u2084 : (i + 1 : \u211a) \u2260 0 := i.cast_add_one_ne_zero\n  have := congr_arg ((\u2191) : \u2115 \u2192 \u211a) (choose_succ_right_eq m i)\n  push_cast at this\n  dsimp [f, hf]\n  rw [(eq_mul_inv_iff_mul_eq\u2080 hi\u2084).mpr this]\n  have := congr_arg ((\u2191) : \u2115 \u2192 \u211a) (choose_succ_right_eq n i)\n  push_cast at this\n  rw [(eq_mul_inv_iff_mul_eq\u2080 hi\u2084).mpr this]\n  have : (m - i : \u211a) \u2260 0 := sub_ne_zero_of_ne (cast_lt.mpr h\u2082).ne'\n  have : (m.choose i : \u211a) \u2260 0 := cast_ne_zero.2 (choose_pos h\u2082.le).ne'\n  field_simp\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/AhlswedeZhang.lean", "context": {"open": ["Finset Fintype Nat"], "variables": ["(\u03b1 : Type*) [Fintype \u03b1] [Nonempty \u03b1] {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nh : n < m\n\u22a2 \u2211 i \u2208 range (n + 1), \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i)) = 1"}, {"line": "set f : \u2115 \u2192 \u211a := fun i \u21a6 n.choose i * (m.choose i : \u211a)\u207b\u00b9 with hf", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\n\u22a2 \u2211 i \u2208 range (n + 1), \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i)) = 1"}, {"line": "suffices \u2200 i \u2208 range (n + 1), f i - f (i + 1) = n.choose i * (m - n) / ((m - i) * m.choose i) by\n    rw [\u2190 sum_congr rfl this]\n    rw [sum_range_sub']\n    rw [hf]\n    simp [choose_self, choose_zero_right, choose_eq_zero_of_lt h]", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\n\u22a2 \u2200 i \u2208 range (n + 1), f i - f (i + 1) = \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i))"}, {"line": "intro i h\u2081", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\ni : \u2115\nh\u2081 : i \u2208 range (n + 1)\n\u22a2 f i - f (i + 1) = \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i))"}, {"line": "rw [mem_range] at h\u2081", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\ni : \u2115\nh\u2081 : i < n + 1\n\u22a2 f i - f (i + 1) = \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i))"}, {"line": "have h\u2081 := le_of_lt_succ h\u2081", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\ni : \u2115\nh\u2081\u271d : i < n + 1\nh\u2081 : i \u2264 n\n\u22a2 f i - f (i + 1) = \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i))"}, {"line": "have h\u2082 := h\u2081.trans_lt h", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\ni : \u2115\nh\u2081\u271d : i < n + 1\nh\u2081 : i \u2264 n\nh\u2082 : i < m\n\u22a2 f i - f (i + 1) = \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i))"}, {"line": "have h\u2083 := h\u2082.le", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\ni : \u2115\nh\u2081\u271d : i < n + 1\nh\u2081 : i \u2264 n\nh\u2082 : i < m\nh\u2083 : i \u2264 m\n\u22a2 f i - f (i + 1) = \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i))"}, {"line": "have hi\u2084 : (i + 1 : \u211a) \u2260 0 := i.cast_add_one_ne_zero", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\ni : \u2115\nh\u2081\u271d : i < n + 1\nh\u2081 : i \u2264 n\nh\u2082 : i < m\nh\u2083 : i \u2264 m\nhi\u2084 : \u2191i + 1 \u2260 0\n\u22a2 f i - f (i + 1) = \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i))"}, {"line": "have := congr_arg ((\u2191) : \u2115 \u2192 \u211a) (choose_succ_right_eq m i)", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\ni : \u2115\nh\u2081\u271d : i < n + 1\nh\u2081 : i \u2264 n\nh\u2082 : i < m\nh\u2083 : i \u2264 m\nhi\u2084 : \u2191i + 1 \u2260 0\nthis : \u2191(m.choose (i + 1) * (i + 1)) = \u2191(m.choose i * (m - i))\n\u22a2 f i - f (i + 1) = \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i))"}, {"line": "push_cast at this", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\ni : \u2115\nh\u2081\u271d : i < n + 1\nh\u2081 : i \u2264 n\nh\u2082 : i < m\nh\u2083 : i \u2264 m\nhi\u2084 : \u2191i + 1 \u2260 0\nthis : \u2191(m.choose (i + 1)) * (\u2191i + 1) = \u2191(m.choose i) * \u2191(m - i)\n\u22a2 f i - f (i + 1) = \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i))"}, {"line": "dsimp [f, hf]", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\ni : \u2115\nh\u2081\u271d : i < n + 1\nh\u2081 : i \u2264 n\nh\u2082 : i < m\nh\u2083 : i \u2264 m\nhi\u2084 : \u2191i + 1 \u2260 0\nthis : \u2191(m.choose (i + 1)) * (\u2191i + 1) = \u2191(m.choose i) * \u2191(m - i)\n\u22a2 \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9 - \u2191(n.choose (i + 1)) * (\u2191(m.choose (i + 1)))\u207b\u00b9 =\n    \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i))"}, {"line": "rw [(eq_mul_inv_iff_mul_eq\u2080 hi\u2084).mpr this]", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\ni : \u2115\nh\u2081\u271d : i < n + 1\nh\u2081 : i \u2264 n\nh\u2082 : i < m\nh\u2083 : i \u2264 m\nhi\u2084 : \u2191i + 1 \u2260 0\nthis : \u2191(m.choose (i + 1)) * (\u2191i + 1) = \u2191(m.choose i) * \u2191(m - i)\n\u22a2 \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9 - \u2191(n.choose (i + 1)) * (\u2191(m.choose i) * \u2191(m - i) * (\u2191i + 1)\u207b\u00b9)\u207b\u00b9 =\n    \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i))"}, {"line": "have := congr_arg ((\u2191) : \u2115 \u2192 \u211a) (choose_succ_right_eq n i)", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\ni : \u2115\nh\u2081\u271d : i < n + 1\nh\u2081 : i \u2264 n\nh\u2082 : i < m\nh\u2083 : i \u2264 m\nhi\u2084 : \u2191i + 1 \u2260 0\nthis\u271d : \u2191(m.choose (i + 1)) * (\u2191i + 1) = \u2191(m.choose i) * \u2191(m - i)\nthis : \u2191(n.choose (i + 1) * (i + 1)) = \u2191(n.choose i * (n - i))\n\u22a2 \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9 - \u2191(n.choose (i + 1)) * (\u2191(m.choose i) * \u2191(m - i) * (\u2191i + 1)\u207b\u00b9)\u207b\u00b9 =\n    \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i))"}, {"line": "push_cast at this", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\ni : \u2115\nh\u2081\u271d : i < n + 1\nh\u2081 : i \u2264 n\nh\u2082 : i < m\nh\u2083 : i \u2264 m\nhi\u2084 : \u2191i + 1 \u2260 0\nthis\u271d : \u2191(m.choose (i + 1)) * (\u2191i + 1) = \u2191(m.choose i) * \u2191(m - i)\nthis : \u2191(n.choose (i + 1)) * (\u2191i + 1) = \u2191(n.choose i) * \u2191(n - i)\n\u22a2 \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9 - \u2191(n.choose (i + 1)) * (\u2191(m.choose i) * \u2191(m - i) * (\u2191i + 1)\u207b\u00b9)\u207b\u00b9 =\n    \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i))"}, {"line": "rw [(eq_mul_inv_iff_mul_eq\u2080 hi\u2084).mpr this]", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\ni : \u2115\nh\u2081\u271d : i < n + 1\nh\u2081 : i \u2264 n\nh\u2082 : i < m\nh\u2083 : i \u2264 m\nhi\u2084 : \u2191i + 1 \u2260 0\nthis\u271d : \u2191(m.choose (i + 1)) * (\u2191i + 1) = \u2191(m.choose i) * \u2191(m - i)\nthis : \u2191(n.choose (i + 1)) * (\u2191i + 1) = \u2191(n.choose i) * \u2191(n - i)\n\u22a2 \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9 -\n      \u2191(n.choose i) * \u2191(n - i) * (\u2191i + 1)\u207b\u00b9 * (\u2191(m.choose i) * \u2191(m - i) * (\u2191i + 1)\u207b\u00b9)\u207b\u00b9 =\n    \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i))"}, {"line": "have : (m - i : \u211a) \u2260 0 := sub_ne_zero_of_ne (cast_lt.mpr h\u2082).ne'", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\ni : \u2115\nh\u2081\u271d : i < n + 1\nh\u2081 : i \u2264 n\nh\u2082 : i < m\nh\u2083 : i \u2264 m\nhi\u2084 : \u2191i + 1 \u2260 0\nthis\u271d\u00b9 : \u2191(m.choose (i + 1)) * (\u2191i + 1) = \u2191(m.choose i) * \u2191(m - i)\nthis\u271d : \u2191(n.choose (i + 1)) * (\u2191i + 1) = \u2191(n.choose i) * \u2191(n - i)\nthis : \u2191m - \u2191i \u2260 0\n\u22a2 \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9 -\n      \u2191(n.choose i) * \u2191(n - i) * (\u2191i + 1)\u207b\u00b9 * (\u2191(m.choose i) * \u2191(m - i) * (\u2191i + 1)\u207b\u00b9)\u207b\u00b9 =\n    \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i))"}, {"line": "have : (m.choose i : \u211a) \u2260 0 := cast_ne_zero.2 (choose_pos h\u2082.le).ne'", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\ni : \u2115\nh\u2081\u271d : i < n + 1\nh\u2081 : i \u2264 n\nh\u2082 : i < m\nh\u2083 : i \u2264 m\nhi\u2084 : \u2191i + 1 \u2260 0\nthis\u271d\u00b2 : \u2191(m.choose (i + 1)) * (\u2191i + 1) = \u2191(m.choose i) * \u2191(m - i)\nthis\u271d\u00b9 : \u2191(n.choose (i + 1)) * (\u2191i + 1) = \u2191(n.choose i) * \u2191(n - i)\nthis\u271d : \u2191m - \u2191i \u2260 0\nthis : \u2191(m.choose i) \u2260 0\n\u22a2 \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9 -\n      \u2191(n.choose i) * \u2191(n - i) * (\u2191i + 1)\u207b\u00b9 * (\u2191(m.choose i) * \u2191(m - i) * (\u2191i + 1)\u207b\u00b9)\u207b\u00b9 =\n    \u2191(n.choose i) * (\u2191m - \u2191n) / ((\u2191m - \u2191i) * \u2191(m.choose i))"}, {"line": "field_simp", "tactic_state": "m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i => \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\ni : \u2115\nh\u2081\u271d : i < n + 1\nh\u2081 : i \u2264 n\nh\u2082 : i < m\nh\u2083 : i \u2264 m\nhi\u2084 : \u2191i + 1 \u2260 0\nthis\u271d\u00b2 : \u2191(m.choose (i + 1)) * (\u2191i + 1) = \u2191(m.choose i) * \u2191(m - i)\nthis\u271d\u00b9 : \u2191(n.choose (i + 1)) * (\u2191i + 1) = \u2191(n.choose i) * \u2191(n - i)\nthis\u271d : \u2191m - \u2191i \u2260 0\nthis : \u2191(m.choose i) \u2260 0\n\u22a2 (\u2191(n.choose i) * (\u2191(m.choose i) * (\u2191m - \u2191i)) - \u2191(m.choose i) * (\u2191(n.choose i) * (\u2191n - \u2191i))) *\n      ((\u2191m - \u2191i) * \u2191(m.choose i)) =\n    \u2191(n.choose i) * (\u2191m - \u2191n) * (\u2191(m.choose i) * (\u2191(m.choose i) * (\u2191m - \u2191i)))"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma lower_aux [DecidableEq \u03b1] :\n    a \u2208 lowerClosure \u2191(s \u222a t) \u2194 a \u2208 lowerClosure s \u2228 a \u2208 lowerClosure t := by\n  rw [coe_union]\n  rw [lowerClosure_union]\n  rw [LowerSet.mem_sup_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/AhlswedeZhang.lean", "context": {"open": ["Finset Fintype Nat", "scoped FinsetFamily"], "variables": ["(\u03b1 : Type*) [Fintype \u03b1] [Nonempty \u03b1] {m n : \u2115}", "{\u03b1 \u03b2 : Type*}", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [BoundedOrder \u03b2] {s t : Finset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ns t : Finset \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 a \u2208 lowerClosure \u2191(s \u222a t) \u2194 a \u2208 lowerClosure \u2191s \u2228 a \u2208 lowerClosure \u2191t"}, {"line": "rw [coe_union]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ns t : Finset \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 a \u2208 lowerClosure (\u2191s \u222a \u2191t) \u2194 a \u2208 lowerClosure \u2191s \u2228 a \u2208 lowerClosure \u2191t"}, {"line": "rw [lowerClosure_union]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ns t : Finset \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 a \u2208 lowerClosure \u2191s \u2294 lowerClosure \u2191t \u2194 a \u2208 lowerClosure \u2191s \u2228 a \u2208 lowerClosure \u2191t"}, {"line": "rw [LowerSet.mem_sup_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_truncatedSup : a \u2264 truncatedSup s a := by\n  rw [truncatedSup]\n  split_ifs with h\n  \u00b7 obtain \u27e8\u212c, hb, h\u27e9 := h\n    exact h.trans <| le_sup' id <| mem_filter.2 \u27e8hb, h\u27e9\n  \u00b7 exact le_top\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/AhlswedeZhang.lean", "context": {"open": ["Finset Fintype Nat", "scoped FinsetFamily"], "variables": ["(\u03b1 : Type*) [Fintype \u03b1] [Nonempty \u03b1] {m n : \u2115}", "{\u03b1 \u03b2 : Type*}", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [BoundedOrder \u03b2] {s t : Finset \u03b1} {a : \u03b1}", "[DecidableLE \u03b1] [OrderTop \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ns : Finset \u03b1\na : \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : OrderTop \u03b1\n\u22a2 a \u2264 s.truncatedSup a"}, {"line": "rw [truncatedSup]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ns : Finset \u03b1\na : \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : OrderTop \u03b1\n\u22a2 a \u2264 if h : a \u2208 lowerClosure \u2191s then {b \u2208 s | a \u2264 b}.sup' \u22ef id else \u22a4"}, {"line": "split_ifs with h", "tactic_state": "case pos\n\u03b1 : Type u_2\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ns : Finset \u03b1\na : \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : OrderTop \u03b1\nh : a \u2208 lowerClosure \u2191s\n\u22a2 a \u2264 {b \u2208 s | a \u2264 b}.sup' \u22ef id\n---\ncase neg\n\u03b1 : Type u_2\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ns : Finset \u03b1\na : \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : OrderTop \u03b1\nh : a \u2209 lowerClosure \u2191s\n\u22a2 a \u2264 \u22a4"}, {"line": "\u00b7 obtain \u27e8\u212c, hb, h\u27e9 := h\n    exact h.trans <| le_sup' id <| mem_filter.2 \u27e8hb, h\u27e9", "tactic_state": "case neg\n\u03b1 : Type u_2\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ns : Finset \u03b1\na : \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : OrderTop \u03b1\nh : a \u2209 lowerClosure \u2191s\n\u22a2 a \u2264 \u22a4"}, {"line": "\u00b7 exact le_top", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma upper_aux [DecidableEq \u03b1] :\n    a \u2208 upperClosure \u2191(s \u222a t) \u2194 a \u2208 upperClosure s \u2228 a \u2208 upperClosure t := by\n  rw [coe_union]\n  rw [upperClosure_union]\n  rw [UpperSet.mem_inf_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/AhlswedeZhang.lean", "context": {"open": ["Finset Fintype Nat", "scoped FinsetFamily"], "variables": ["(\u03b1 : Type*) [Fintype \u03b1] [Nonempty \u03b1] {m n : \u2115}", "{\u03b1 \u03b2 : Type*}", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [BoundedOrder \u03b2] {s t : Finset \u03b1} {a : \u03b1}", "[DecidableLE \u03b1] [OrderTop \u03b1]", "[DecidableEq \u03b1]", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : SemilatticeSup \u03b1\ns t : Finset \u03b1\na : \u03b1\ninst\u271d\u2074 : DecidableLE \u03b1\ninst\u271d\u00b3 : OrderTop \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 a \u2208 upperClosure \u2191(s \u222a t) \u2194 a \u2208 upperClosure \u2191s \u2228 a \u2208 upperClosure \u2191t"}, {"line": "rw [coe_union]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : SemilatticeSup \u03b1\ns t : Finset \u03b1\na : \u03b1\ninst\u271d\u2074 : DecidableLE \u03b1\ninst\u271d\u00b3 : OrderTop \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 a \u2208 upperClosure (\u2191s \u222a \u2191t) \u2194 a \u2208 upperClosure \u2191s \u2228 a \u2208 upperClosure \u2191t"}, {"line": "rw [upperClosure_union]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : SemilatticeSup \u03b1\ns t : Finset \u03b1\na : \u03b1\ninst\u271d\u2074 : DecidableLE \u03b1\ninst\u271d\u00b3 : OrderTop \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 a \u2208 upperClosure \u2191s \u2293 upperClosure \u2191t \u2194 a \u2208 upperClosure \u2191s \u2228 a \u2208 upperClosure \u2191t"}, {"line": "rw [UpperSet.mem_inf_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma truncatedInf_le : truncatedInf s a \u2264 a := by\n  unfold truncatedInf\n  split_ifs with h\n  \u00b7 obtain \u27e8b, hb, hba\u27e9 := h\n    exact hba.trans' <| inf'_le id <| mem_filter.2 \u27e8hb, \u2039_\u203a\u27e9\n  \u00b7 exact bot_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/AhlswedeZhang.lean", "context": {"open": ["Finset Fintype Nat", "scoped FinsetFamily"], "variables": ["(\u03b1 : Type*) [Fintype \u03b1] [Nonempty \u03b1] {m n : \u2115}", "{\u03b1 \u03b2 : Type*}", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [BoundedOrder \u03b2] {s t : Finset \u03b1} {a : \u03b1}", "[DecidableLE \u03b1] [OrderTop \u03b1]", "[DecidableEq \u03b1]", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2]", "[DecidableLE \u03b1] [BoundedOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2076 : SemilatticeSup \u03b1\ns : Finset \u03b1\na : \u03b1\ninst\u271d\u2075 : DecidableLE \u03b1\ninst\u271d\u2074 : OrderTop \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : BoundedOrder \u03b1\n\u22a2 s.truncatedInf a \u2264 a"}, {"line": "unfold truncatedInf", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2076 : SemilatticeSup \u03b1\ns : Finset \u03b1\na : \u03b1\ninst\u271d\u2075 : DecidableLE \u03b1\ninst\u271d\u2074 : OrderTop \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : BoundedOrder \u03b1\n\u22a2 (if h : a \u2208 upperClosure \u2191s then {b \u2208 s | b \u2264 a}.inf' \u22ef id else \u22a5) \u2264 a"}, {"line": "split_ifs with h", "tactic_state": "case pos\n\u03b1 : Type u_2\ninst\u271d\u2076 : SemilatticeSup \u03b1\ns : Finset \u03b1\na : \u03b1\ninst\u271d\u2075 : DecidableLE \u03b1\ninst\u271d\u2074 : OrderTop \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : BoundedOrder \u03b1\nh : a \u2208 upperClosure \u2191s\n\u22a2 {b \u2208 s | b \u2264 a}.inf' \u22ef id \u2264 a\n---\ncase neg\n\u03b1 : Type u_2\ninst\u271d\u2076 : SemilatticeSup \u03b1\ns : Finset \u03b1\na : \u03b1\ninst\u271d\u2075 : DecidableLE \u03b1\ninst\u271d\u2074 : OrderTop \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : BoundedOrder \u03b1\nh : a \u2209 upperClosure \u2191s\n\u22a2 \u22a5 \u2264 a"}, {"line": "\u00b7 obtain \u27e8b, hb, hba\u27e9 := h\n    exact hba.trans' <| inf'_le id <| mem_filter.2 \u27e8hb, \u2039_\u203a\u27e9", "tactic_state": "case neg\n\u03b1 : Type u_2\ninst\u271d\u2076 : SemilatticeSup \u03b1\ns : Finset \u03b1\na : \u03b1\ninst\u271d\u2075 : DecidableLE \u03b1\ninst\u271d\u2074 : OrderTop \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : BoundedOrder \u03b1\nh : a \u2209 upperClosure \u2191s\n\u22a2 \u22a5 \u2264 a"}, {"line": "\u00b7 exact bot_le", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma infs_aux : a \u2208 lowerClosure \u2191(s \u22bc t) \u2194 a \u2208 lowerClosure s \u2227 a \u2208 lowerClosure t := by\n  rw [coe_infs]\n  rw [lowerClosure_infs]\n  rw [LowerSet.mem_inf_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/AhlswedeZhang.lean", "context": {"open": ["Finset Fintype Nat", "scoped FinsetFamily"], "variables": ["(\u03b1 : Type*) [Fintype \u03b1] [Nonempty \u03b1] {m n : \u2115}", "{\u03b1 \u03b2 : Type*}", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [BoundedOrder \u03b2] {s t : Finset \u03b1} {a : \u03b1}", "[DecidableLE \u03b1] [OrderTop \u03b1]", "[DecidableEq \u03b1]", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2]", "[DecidableLE \u03b1] [BoundedOrder \u03b1]", "[DecidableEq \u03b1]", "[DistribLattice \u03b1] [DecidableEq \u03b1] {s t : Finset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2079 : SemilatticeSup \u03b1\ninst\u271d\u2078 : DecidableLE \u03b1\ninst\u271d\u2077 : OrderTop \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : SemilatticeInf \u03b1\ninst\u271d\u2074 : DecidableLE \u03b1\ninst\u271d\u00b3 : BoundedOrder \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DistribLattice \u03b1\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\na : \u03b1\n\u22a2 a \u2208 lowerClosure \u2191(s \u22bc t) \u2194 a \u2208 lowerClosure \u2191s \u2227 a \u2208 lowerClosure \u2191t"}, {"line": "rw [coe_infs]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2079 : SemilatticeSup \u03b1\ninst\u271d\u2078 : DecidableLE \u03b1\ninst\u271d\u2077 : OrderTop \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : SemilatticeInf \u03b1\ninst\u271d\u2074 : DecidableLE \u03b1\ninst\u271d\u00b3 : BoundedOrder \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DistribLattice \u03b1\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\na : \u03b1\n\u22a2 a \u2208 lowerClosure (\u2191s \u22bc \u2191t) \u2194 a \u2208 lowerClosure \u2191s \u2227 a \u2208 lowerClosure \u2191t"}, {"line": "rw [lowerClosure_infs]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2079 : SemilatticeSup \u03b1\ninst\u271d\u2078 : DecidableLE \u03b1\ninst\u271d\u2077 : OrderTop \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 : SemilatticeInf \u03b1\ninst\u271d\u2074 : DecidableLE \u03b1\ninst\u271d\u00b3 : BoundedOrder \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DistribLattice \u03b1\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\na : \u03b1\n\u22a2 a \u2208 lowerClosure \u2191s \u2293 lowerClosure \u2191t \u2194 a \u2208 lowerClosure \u2191s \u2227 a \u2208 lowerClosure \u2191t"}, {"line": "rw [LowerSet.mem_inf_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Finset.le_card_infs_mul_card_sups [DecidableEq \u03b1] (s t : Finset \u03b1) :\n    #s * #t \u2264 #(s \u22bc t) * #(s \u22bb t) := by\n  simpa using four_functions_theorem (1 : \u03b1 \u2192 \u2115) 1 1 1 zero_le_one zero_le_one zero_le_one\n    zero_le_one (fun _ _ \u21a6 le_rfl) s t\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/FourFunctions.lean", "context": {"open": ["Finset Fintype Function", "scoped FinsetFamily"], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [CommSemiring \u03b2] [LinearOrder \u03b2] [IsStrictOrderedRing \u03b2]", "[ExistsAddOfLE \u03b2]", "(f\u2081 f\u2082 f\u2083 f\u2084) [Fintype \u03b1]", "[DistribLattice \u03b1] [CommSemiring \u03b2] [LinearOrder \u03b2] [IsStrictOrderedRing \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DistribLattice \u03b1\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\n\u22a2 s.card * t.card \u2264 (s \u22bc t).card * (s \u22bb t).card"}, {"line": "simpa using four_functions_theorem (1 : \u03b1 \u2192 \u2115) 1 1 1 zero_le_one zero_le_one zero_le_one\n    zero_le_one (fun _ _ \u21a6 le_rfl) s t", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsLowerSet.memberSubfamily (h : IsLowerSet (\ud835\udc9c : Set (Finset \u03b1))) :\n    IsLowerSet (\ud835\udc9c.memberSubfamily a : Set (Finset \u03b1)) := by\n  rintro s t hts\n  simp_rw [mem_coe, mem_memberSubfamily]\n  exact And.imp (h <| insert_subset_insert _ hts) (mt <| @hts _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/HarrisKleitman.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] {\ud835\udc9c \u212c : Finset (Finset \u03b1)} {s : Finset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\na : \u03b1\nh : IsLowerSet \u2191\ud835\udc9c\n\u22a2 IsLowerSet \u2191(Finset.memberSubfamily a \ud835\udc9c)"}, {"line": "rintro s t hts", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\na : \u03b1\nh : IsLowerSet \u2191\ud835\udc9c\ns t : Finset \u03b1\nhts : t \u2264 s\n\u22a2 s \u2208 \u2191(Finset.memberSubfamily a \ud835\udc9c) \u2192 t \u2208 \u2191(Finset.memberSubfamily a \ud835\udc9c)"}, {"line": "simp_rw [mem_coe, mem_memberSubfamily]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\na : \u03b1\nh : IsLowerSet \u2191\ud835\udc9c\ns t : Finset \u03b1\nhts : t \u2264 s\n\u22a2 insert a s \u2208 \ud835\udc9c \u2227 a \u2209 s \u2192 insert a t \u2208 \ud835\udc9c \u2227 a \u2209 t"}, {"line": "exact And.imp (h <| insert_subset_insert _ hts) (mt <| @hts _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intersecting_singleton : ({a} : Set \u03b1).Intersecting \u2194 a \u2260 \u22a5 := by simp [Intersecting]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/Intersecting.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 : Type*}", "[SemilatticeInf \u03b1] [OrderBot \u03b1] {s t : Set \u03b1} {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\na : \u03b1\n\u22a2 {a}.Intersecting \u2194 a \u2260 \u22a5"}, {"line": "simp [Intersecting]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Intersecting.insert (hs : s.Intersecting) (ha : a \u2260 \u22a5)\n    (h : \u2200 b \u2208 s, \u00acDisjoint a b) : (insert a s).Intersecting := by\n  rintro b (rfl | hb) c (rfl | hc)\n  \u00b7 rwa [disjoint_self]\n  \u00b7 exact h _ hc\n  \u00b7 exact fun H => h _ hb H.symm\n  \u00b7 exact hs hb hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/Intersecting.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 : Type*}", "[SemilatticeInf \u03b1] [OrderBot \u03b1] {s t : Set \u03b1} {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b1\na : \u03b1\nhs : s.Intersecting\nha : a \u2260 \u22a5\nh : \u2200 b \u2208 s, \u00acDisjoint a b\n\u22a2 (insert a s).Intersecting"}, {"line": "rintro b (rfl | hb) c (rfl | hc)", "tactic_state": "case inl.inl\n\u03b1 : Type u_1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b1\nhs : s.Intersecting\nc : \u03b1\nha : c \u2260 \u22a5\nh : \u2200 b \u2208 s, \u00acDisjoint c b\n\u22a2 \u00acDisjoint c c\n---\ncase inl.inr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b1\nhs : s.Intersecting\nb : \u03b1\nha : b \u2260 \u22a5\nh : \u2200 b_1 \u2208 s, \u00acDisjoint b b_1\nc : \u03b1\nhc : c \u2208 s\n\u22a2 \u00acDisjoint b c\n---\ncase inr.inl\n\u03b1 : Type u_1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b1\nhs : s.Intersecting\nb : \u03b1\nhb : b \u2208 s\nc : \u03b1\nha : c \u2260 \u22a5\nh : \u2200 b \u2208 s, \u00acDisjoint c b\n\u22a2 \u00acDisjoint b c\n---\ncase inr.inr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b1\na : \u03b1\nhs : s.Intersecting\nha : a \u2260 \u22a5\nh : \u2200 b \u2208 s, \u00acDisjoint a b\nb : \u03b1\nhb : b \u2208 s\nc : \u03b1\nhc : c \u2208 s\n\u22a2 \u00acDisjoint b c"}, {"line": "\u00b7 rwa [disjoint_self]", "tactic_state": "case inl.inr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b1\nhs : s.Intersecting\nb : \u03b1\nha : b \u2260 \u22a5\nh : \u2200 b_1 \u2208 s, \u00acDisjoint b b_1\nc : \u03b1\nhc : c \u2208 s\n\u22a2 \u00acDisjoint b c\n---\ncase inr.inl\n\u03b1 : Type u_1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b1\nhs : s.Intersecting\nb : \u03b1\nhb : b \u2208 s\nc : \u03b1\nha : c \u2260 \u22a5\nh : \u2200 b \u2208 s, \u00acDisjoint c b\n\u22a2 \u00acDisjoint b c\n---\ncase inr.inr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b1\na : \u03b1\nhs : s.Intersecting\nha : a \u2260 \u22a5\nh : \u2200 b \u2208 s, \u00acDisjoint a b\nb : \u03b1\nhb : b \u2208 s\nc : \u03b1\nhc : c \u2208 s\n\u22a2 \u00acDisjoint b c"}, {"line": "\u00b7 exact h _ hc", "tactic_state": "case inr.inl\n\u03b1 : Type u_1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b1\nhs : s.Intersecting\nb : \u03b1\nhb : b \u2208 s\nc : \u03b1\nha : c \u2260 \u22a5\nh : \u2200 b \u2208 s, \u00acDisjoint c b\n\u22a2 \u00acDisjoint b c\n---\ncase inr.inr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b1\na : \u03b1\nhs : s.Intersecting\nha : a \u2260 \u22a5\nh : \u2200 b \u2208 s, \u00acDisjoint a b\nb : \u03b1\nhb : b \u2208 s\nc : \u03b1\nhc : c \u2208 s\n\u22a2 \u00acDisjoint b c"}, {"line": "\u00b7 exact fun H => h _ hb H.symm", "tactic_state": "case inr.inr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b1\na : \u03b1\nhs : s.Intersecting\nha : a \u2260 \u22a5\nh : \u2200 b \u2208 s, \u00acDisjoint a b\nb : \u03b1\nhb : b \u2208 s\nc : \u03b1\nhc : c \u2208 s\n\u22a2 \u00acDisjoint b c"}, {"line": "\u00b7 exact hs hb hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Intersecting.isUpperSet' {s : Finset \u03b1} (hs : (s : Set \u03b1).Intersecting)\n    (h : \u2200 t : Finset \u03b1, (t : Set \u03b1).Intersecting \u2192 s \u2286 t \u2192 s = t) : IsUpperSet (s : Set \u03b1) := by\n  classical\n    rintro a b hab ha\n    rw [h (Insert.insert b s) _ (Finset.subset_insert _ _)]\n    \u00b7 exact mem_insert_self _ _\n    rw [coe_insert]\n    exact\n      hs.insert (mt (eq_bot_mono hab) <| hs.ne_bot ha) fun c hc hbc => hs ha hc <| hbc.mono_left hab\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/Intersecting.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 : Type*}", "[SemilatticeInf \u03b1] [OrderBot \u03b1] {s t : Set \u03b1} {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Finset \u03b1\nhs : (\u2191s).Intersecting\nh : \u2200 (t : Finset \u03b1), (\u2191t).Intersecting \u2192 s \u2286 t \u2192 s = t\n\u22a2 IsUpperSet \u2191s"}, {"line": "classical\n    rintro a b hab ha\n    rw [h (Insert.insert b s) _ (Finset.subset_insert _ _)]\n    \u00b7 exact mem_insert_self _ _\n    rw [coe_insert]\n    exact\n      hs.insert (mt (eq_bot_mono hab) <| hs.ne_bot ha) fun c hc hbc => hs ha hc <| hbc.mono_left hab", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_falling : s \u2208 falling k \ud835\udc9c \u2194 (\u2203 t \u2208 \ud835\udc9c, s \u2286 t) \u2227 #s = k := by\n  simp_rw [falling, mem_sup, mem_powersetCard]\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/LYM.lean", "context": {"open": ["Finset Nat", "scoped FinsetFamily"], "variables": ["{\ud835\udd5c \u03b1 : Type*} [Semifield \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[DecidableEq \u03b1] [Fintype \u03b1] {\ud835\udc9c : Finset (Finset \u03b1)} {r : \u2115}", "[DecidableEq \u03b1] (k : \u2115) (\ud835\udc9c : Finset (Finset \u03b1))", "{\ud835\udc9c k} {s : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nk : \u2115\n\ud835\udc9c : Finset (Finset \u03b1)\ns : Finset \u03b1\n\u22a2 s \u2208 falling k \ud835\udc9c \u2194 (\u2203 t \u2208 \ud835\udc9c, s \u2286 t) \u2227 s.card = k"}, {"line": "simp_rw [falling, mem_sup, mem_powersetCard]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nk : \u2115\n\ud835\udc9c : Finset (Finset \u03b1)\ns : Finset \u03b1\n\u22a2 (\u2203 i \u2208 \ud835\udc9c, s \u2286 i \u2227 s.card = k) \u2194 (\u2203 t \u2208 \ud835\udc9c, s \u2286 t) \u2227 s.card = k"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_shadow_iff : t \u2208 \u2202 \ud835\udc9c \u2194 \u2203 s \u2208 \ud835\udc9c, \u2203 a \u2208 s, erase s a = t := by\n  simp only [shadow]\n  simp only [mem_sup]\n  simp only [mem_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/Shadow.lean", "context": {"open": ["Finset Nat", "FinsetFamily"], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1] {\ud835\udc9c \u212c : Finset (Finset \u03b1)} {s t : Finset \u03b1} {a : \u03b1} {k r : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\nt : Finset \u03b1\n\u22a2 t \u2208 \ud835\udc9c.shadow \u2194 \u2203 s \u2208 \ud835\udc9c, \u2203 a \u2208 s, s.erase a = t"}, {"line": "simp only [shadow]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\nt : Finset \u03b1\n\u22a2 (t \u2208 \ud835\udc9c.sup fun s => image s.erase s) \u2194 \u2203 s \u2208 \ud835\udc9c, \u2203 a \u2208 s, s.erase a = t"}, {"line": "simp only [mem_sup]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\nt : Finset \u03b1\n\u22a2 (\u2203 i \u2208 \ud835\udc9c, t \u2208 image i.erase i) \u2194 \u2203 s \u2208 \ud835\udc9c, \u2203 a \u2208 s, s.erase a = t"}, {"line": "simp only [mem_image]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_upShadow_iff : t \u2208 \u2202\u207a \ud835\udc9c \u2194 \u2203 s \u2208 \ud835\udc9c, \u2203 a \u2209 s, insert a s = t := by\n  simp_rw [upShadow, mem_sup, mem_image, mem_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/Shadow.lean", "context": {"open": ["Finset Nat", "FinsetFamily", "FinsetFamily"], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1] {\ud835\udc9c \u212c : Finset (Finset \u03b1)} {s t : Finset \u03b1} {a : \u03b1} {k r : \u2115}", "[DecidableEq \u03b1] [Fintype \u03b1] {\ud835\udc9c : Finset (Finset \u03b1)} {s t : Finset \u03b1} {a : \u03b1} {k r : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\nt : Finset \u03b1\n\u22a2 t \u2208 \ud835\udc9c.upShadow \u2194 \u2203 s \u2208 \ud835\udc9c, \u2203 a \u2209 s, insert a s = t"}, {"line": "simp_rw [upShadow, mem_sup, mem_image, mem_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_nonMemberSubfamily : s \u2208 \ud835\udc9c.nonMemberSubfamily a \u2194 s \u2208 \ud835\udc9c \u2227 a \u2209 s := by\n  simp [nonMemberSubfamily]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/Compression/Down.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] {\ud835\udc9c : Finset (Finset \u03b1)} {s : Finset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\ns : Finset \u03b1\na : \u03b1\n\u22a2 s \u2208 Finset.nonMemberSubfamily a \ud835\udc9c \u2194 s \u2208 \ud835\udc9c \u2227 a \u2209 s"}, {"line": "simp [nonMemberSubfamily]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem memberSubfamily_memberSubfamily : (\ud835\udc9c.memberSubfamily a).memberSubfamily a = \u2205 := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/Compression/Down.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] {\ud835\udc9c : Finset (Finset \u03b1)} {s : Finset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\na : \u03b1\n\u22a2 Finset.memberSubfamily a (Finset.memberSubfamily a \ud835\udc9c) = \u2205"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\na : \u03b1\na\u271d : Finset \u03b1\n\u22a2 a\u271d \u2208 Finset.memberSubfamily a (Finset.memberSubfamily a \ud835\udc9c) \u2194 a\u271d \u2208 \u2205"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem memberSubfamily_nonMemberSubfamily : (\ud835\udc9c.nonMemberSubfamily a).memberSubfamily a = \u2205 := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/Compression/Down.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] {\ud835\udc9c : Finset (Finset \u03b1)} {s : Finset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\na : \u03b1\n\u22a2 Finset.memberSubfamily a (Finset.nonMemberSubfamily a \ud835\udc9c) = \u2205"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\na : \u03b1\na\u271d : Finset \u03b1\n\u22a2 a\u271d \u2208 Finset.memberSubfamily a (Finset.nonMemberSubfamily a \ud835\udc9c) \u2194 a\u271d \u2208 \u2205"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonMemberSubfamily_memberSubfamily :\n    (\ud835\udc9c.memberSubfamily a).nonMemberSubfamily a = \ud835\udc9c.memberSubfamily a := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/Compression/Down.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] {\ud835\udc9c : Finset (Finset \u03b1)} {s : Finset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\na : \u03b1\n\u22a2 Finset.nonMemberSubfamily a (Finset.memberSubfamily a \ud835\udc9c) = Finset.memberSubfamily a \ud835\udc9c"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\na : \u03b1\na\u271d : Finset \u03b1\n\u22a2 a\u271d \u2208 Finset.nonMemberSubfamily a (Finset.memberSubfamily a \ud835\udc9c) \u2194 a\u271d \u2208 Finset.memberSubfamily a \ud835\udc9c"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonMemberSubfamily_nonMemberSubfamily :\n    (\ud835\udc9c.nonMemberSubfamily a).nonMemberSubfamily a = \ud835\udc9c.nonMemberSubfamily a := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SetFamily/Compression/Down.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] {\ud835\udc9c : Finset (Finset \u03b1)} {s : Finset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\na : \u03b1\n\u22a2 Finset.nonMemberSubfamily a (Finset.nonMemberSubfamily a \ud835\udc9c) = Finset.nonMemberSubfamily a \ud835\udc9c"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\na : \u03b1\na\u271d : Finset \u03b1\n\u22a2 a\u271d \u2208 Finset.nonMemberSubfamily a (Finset.nonMemberSubfamily a \ud835\udc9c) \u2194 a\u271d \u2208 Finset.nonMemberSubfamily a \ud835\udc9c"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem circulantGraph_adj_translate {s : Set G} {u v d : G} :\n    (circulantGraph s).Adj (u + d) (v + d) \u2194 (circulantGraph s).Adj u v := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Circulant.lean", "context": {"open": [], "variables": ["{G : Type*} [AddGroup G] (s : Set G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : AddGroup G\nx\u271d : Sort u_2\ncirculantGraph : x\u271d\ns : Set G\nu v d : G\n\u22a2 sorry \u2194 sorry"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cycleGraph_neighborFinset {n : \u2115} {v : Fin (n + 2)} :\n    (cycleGraph (n + 2)).neighborFinset v = {v - 1, v + 1} := by\n  simp [neighborFinset, cycleGraph_neighborSet]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Circulant.lean", "context": {"open": [], "variables": ["{G : Type*} [AddGroup G] (s : Set G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\ncycleGraph : x\u271d\nn : \u2115\nv : Fin (n + 2)\n\u22a2 sorry = {v - 1, v + 1}"}, {"line": "simp [neighborFinset, cycleGraph_neighborSet]", "tactic_state": "x\u271d : Sort u_2\ncycleGraph : x\u271d\nn : \u2115\nv : Fin (n + 2)\n\u22a2 sorry () = {v - 1, v + 1}"}]}
{"declaration": "theorem singletonFinsubgraph_le_adj_left {u v : V} {e : G.Adj u v} :\n    singletonFinsubgraph u \u2264 finsubgraphOfAdj e := by\n  simp [singletonFinsubgraph, finsubgraphOfAdj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Finsubgraph.lean", "context": {"open": ["Set CategoryTheory"], "variables": ["{V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W}", "[Finite V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : Finite V\nx\u271d\u00b9 : Sort u_1\nsingletonFinsubgraph : x\u271d\u00b9\nx\u271d : Sort u_2\nfinsubgraphOfAdj : x\u271d\nu v : V\ne : G.Adj u v\n\u22a2 sorry \u2264 sorry"}, {"line": "simp [singletonFinsubgraph, finsubgraphOfAdj]", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : Finite V\nx\u271d\u00b9 : Sort u_1\nsingletonFinsubgraph : x\u271d\u00b9\nx\u271d : Sort u_2\nfinsubgraphOfAdj : x\u271d\nu v : V\ne : G.Adj u v\n\u22a2 sorry () \u2264 sorry ()"}]}
{"declaration": "theorem singletonFinsubgraph_le_adj_right {u v : V} {e : G.Adj u v} :\n    singletonFinsubgraph v \u2264 finsubgraphOfAdj e := by\n  simp [singletonFinsubgraph, finsubgraphOfAdj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Finsubgraph.lean", "context": {"open": ["Set CategoryTheory"], "variables": ["{V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W}", "[Finite V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : Finite V\nx\u271d\u00b9 : Sort u_1\nsingletonFinsubgraph : x\u271d\u00b9\nx\u271d : Sort u_2\nfinsubgraphOfAdj : x\u271d\nu v : V\ne : G.Adj u v\n\u22a2 sorry \u2264 sorry"}, {"line": "simp [singletonFinsubgraph, finsubgraphOfAdj]", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : Finite V\nx\u271d\u00b9 : Sort u_1\nsingletonFinsubgraph : x\u271d\u00b9\nx\u271d : Sort u_2\nfinsubgraphOfAdj : x\u271d\nu v : V\ne : G.Adj u v\n\u22a2 sorry () \u2264 sorry ()"}]}
{"declaration": "lemma IsHamiltonian.map {H : SimpleGraph \u03b2} (f : G \u2192g H) (hf : Bijective f) (hp : p.IsHamiltonian) :\n    (p.map f).IsHamiltonian := by\n  simp [IsHamiltonian, hf.surjective.forall, hf.injective, hp _]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Hamiltonian.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2] {G : SimpleGraph \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nf : G \u2192g H\nhf : Bijective \u21d1f\nhp : sorry\n\u22a2 sorry"}, {"line": "simp [IsHamiltonian, hf.surjective.forall, hf.injective, hp _]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nf : G \u2192g H\nhf : Bijective \u21d1f\nhp : sorry\n\u22a2 sorry ()"}]}
{"declaration": "lemma IsHamiltonian.support_toFinset (hp : p.IsHamiltonian) : p.support.toFinset = Finset.univ := by\n  simp [eq_univ_iff_forall, hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Hamiltonian.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2] {G : SimpleGraph \u03b1}", "[Fintype \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "hp : sorry\n\u22a2 sorry = univ"}, {"line": "simp [eq_univ_iff_forall, hp]", "tactic_state": "hp : sorry\n\u22a2 sorry () = univ"}]}
{"declaration": "lemma lineGraph_adj_iff_exists {e\u2081 e\u2082 : G.edgeSet} :\n    (G.lineGraph).Adj e\u2081 e\u2082 \u2194 e\u2081 \u2260 e\u2082 \u2227 \u2203 v, v \u2208 (e\u2081 : Sym2 V) \u2227 v \u2208 (e\u2082 : Sym2 V) := by\n  simp [Set.Nonempty, lineGraph]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/LineGraph.lean", "context": {"open": [], "variables": ["{V : Type*} {G : SimpleGraph V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ne\u2081 e\u2082 : \u2191G.edgeSet\n\u22a2 G.lineGraph.Adj e\u2081 e\u2082 \u2194 e\u2081 \u2260 e\u2082 \u2227 \u2203 v \u2208 \u2191e\u2081, v \u2208 \u2191e\u2082"}, {"line": "simp [Set.Nonempty, lineGraph]", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ne\u2081 e\u2082 : \u2191G.edgeSet\n\u22a2 G.lineGraph.Adj e\u2081 e\u2082 \u2194 \u00ace\u2081 = e\u2082 \u2227 \u2203 v \u2208 \u2191e\u2081, v \u2208 \u2191e\u2082"}]}
{"declaration": "theorem edist_eq_zero_iff :\n    G.edist u v = 0 \u2194 u = v := by\n  apply Iff.intro <;> simp [edist, ENat.iInf_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "context": {"open": [], "variables": ["{V : Type*} (G : SimpleGraph V)", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\nu v : V\n\u22a2 G.edist u v = 0 \u2194 u = v"}, {"line": "apply Iff.intro <;> simp [edist, ENat.iInf_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma edist_bot [DecidableEq V] : (\u22a5 : SimpleGraph V).edist u v = (if u = v then 0 else \u22a4) := by\n  by_cases h : u = v <;> simp [h, edist_bot_of_ne]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "context": {"open": [], "variables": ["{V : Type*} (G : SimpleGraph V)", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nu v : V\ninst\u271d : DecidableEq V\n\u22a2 \u22a5.edist u v = if u = v then 0 else \u22a4"}, {"line": "by_cases h : u = v <;> simp [h, edist_bot_of_ne]", "tactic_state": "case neg\nV : Type u_1\nu v : V\ninst\u271d : DecidableEq V\nh : \u00acu = v\n\u22a2 \u22a5.edist u v = \u22a4"}]}
{"declaration": "lemma edist_top_of_ne (h : u \u2260 v) : (\u22a4 : SimpleGraph V).edist u v = 1 := by\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "context": {"open": [], "variables": ["{V : Type*} (G : SimpleGraph V)", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nu v : V\nh : u \u2260 v\n\u22a2 \u22a4.edist u v = 1"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma edist_top [DecidableEq V] : (\u22a4 : SimpleGraph V).edist u v = (if u = v then 0 else 1) := by\n  by_cases h : u = v <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "context": {"open": [], "variables": ["{V : Type*} (G : SimpleGraph V)", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nu v : V\ninst\u271d : DecidableEq V\n\u22a2 \u22a4.edist u v = if u = v then 0 else 1"}, {"line": "by_cases h : u = v <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_anti {G' : SimpleGraph V} (h : G \u2264 G') :\n    G'.edist u v \u2264 G.edist u v := by\n  by_cases hr : G.Reachable u v\n  \u00b7 obtain \u27e8_, hw\u27e9 := hr.exists_walk_length_eq_edist\n    rw [\u2190 hw]\n    rw [\u2190 Walk.length_map (.ofLE h)]\n    apply edist_le\n  \u00b7 exact edist_eq_top_of_not_reachable hr \u25b8 le_top\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "context": {"open": [], "variables": ["{V : Type*} (G : SimpleGraph V)", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\nu v : V\nG' : SimpleGraph V\nh : G \u2264 G'\n\u22a2 G'.edist u v \u2264 G.edist u v"}, {"line": "by_cases hr : G.Reachable u v", "tactic_state": "case pos\nV : Type u_1\nG : SimpleGraph V\nu v : V\nG' : SimpleGraph V\nh : G \u2264 G'\nhr : G.Reachable u v\n\u22a2 G'.edist u v \u2264 G.edist u v\n---\ncase neg\nV : Type u_1\nG : SimpleGraph V\nu v : V\nG' : SimpleGraph V\nh : G \u2264 G'\nhr : \u00acG.Reachable u v\n\u22a2 G'.edist u v \u2264 G.edist u v"}, {"line": "\u00b7 obtain \u27e8_, hw\u27e9 := hr.exists_walk_length_eq_edist\n    rw [\u2190 hw]\n    rw [\u2190 Walk.length_map (.ofLE h)]\n    apply edist_le", "tactic_state": "case neg\nV : Type u_1\nG : SimpleGraph V\nu v : V\nG' : SimpleGraph V\nh : G \u2264 G'\nhr : \u00acG.Reachable u v\n\u22a2 G'.edist u v \u2264 G.edist u v"}, {"line": "\u00b7 exact edist_eq_top_of_not_reachable hr \u25b8 le_top", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_eq_zero_iff_eq_or_not_reachable :\n    G.dist u v = 0 \u2194 u = v \u2228 \u00acG.Reachable u v := by simp [dist_eq_sInf, Nat.sInf_eq_zero, Reachable]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "context": {"open": [], "variables": ["{V : Type*} (G : SimpleGraph V)", "{G} {u v w : V}", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\nu v : V\n\u22a2 G.dist u v = 0 \u2194 u = v \u2228 \u00acG.Reachable u v"}, {"line": "simp [dist_eq_sInf, Nat.sInf_eq_zero, Reachable]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_self : dist G v v = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "context": {"open": [], "variables": ["{V : Type*} (G : SimpleGraph V)", "{G} {u v w : V}", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = 0"}, {"line": "simp", "tactic_state": "\u22a2 sorry () = 0"}]}
{"declaration": "protected theorem Reachable.dist_eq_zero_iff (hr : G.Reachable u v) :\n    G.dist u v = 0 \u2194 u = v := by simp [hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "context": {"open": [], "variables": ["{V : Type*} (G : SimpleGraph V)", "{G} {u v w : V}", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\nu v : V\nhr : G.Reachable u v\n\u22a2 G.dist u v = 0 \u2194 u = v"}, {"line": "simp [hr]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Connected.dist_eq_zero_iff (hconn : G.Connected) :\n    G.dist u v = 0 \u2194 u = v := by simp [hconn u v]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "context": {"open": [], "variables": ["{V : Type*} (G : SimpleGraph V)", "{G} {u v w : V}", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\nu v : V\nhconn : G.Connected\n\u22a2 G.dist u v = 0 \u2194 u = v"}, {"line": "simp [hconn u v]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_eq_zero_of_not_reachable (h : \u00acG.Reachable u v) : G.dist u v = 0 := by\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "context": {"open": [], "variables": ["{V : Type*} (G : SimpleGraph V)", "{G} {u v w : V}", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\nu v : V\nh : \u00acG.Reachable u v\n\u22a2 G.dist u v = 0"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Reachable.exists_path_of_dist (hr : G.Reachable u v) :\n    \u2203 (p : G.Walk u v), p.IsPath \u2227 p.length = G.dist u v := by\n  obtain \u27e8p, h\u27e9 := hr.exists_walk_length_eq_dist\n  exact \u27e8p, p.isPath_of_length_eq_dist h, h\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "context": {"open": [], "variables": ["{V : Type*} (G : SimpleGraph V)", "{G} {u v w : V}", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\nu v : V\nhr : G.Reachable u v\n\u22a2 \u2203 p, p.IsPath \u2227 p.length = G.dist u v"}, {"line": "obtain \u27e8p, h\u27e9 := hr.exists_walk_length_eq_dist", "tactic_state": "case intro\nV : Type u_1\nG : SimpleGraph V\nu v : V\nhr : G.Reachable u v\np : G.Walk u v\nh : p.length = G.dist u v\n\u22a2 \u2203 p, p.IsPath \u2227 p.length = G.dist u v"}, {"line": "exact \u27e8p, p.isPath_of_length_eq_dist h, h\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Connected.exists_path_of_dist (hconn : G.Connected) (u v : V) :\n    \u2203 (p : G.Walk u v), p.IsPath \u2227 p.length = G.dist u v := by\n  obtain \u27e8p, h\u27e9 := hconn.exists_walk_length_eq_dist  u v\n  exact \u27e8p, p.isPath_of_length_eq_dist h, h\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "context": {"open": [], "variables": ["{V : Type*} (G : SimpleGraph V)", "{G} {u v w : V}", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\nhconn : G.Connected\nu v : V\n\u22a2 \u2203 p, p.IsPath \u2227 p.length = G.dist u v"}, {"line": "obtain \u27e8p, h\u27e9 := hconn.exists_walk_length_eq_dist  u v", "tactic_state": "case intro\nV : Type u_1\nG : SimpleGraph V\nhconn : G.Connected\nu v : V\np : G.Walk u v\nh : p.length = G.dist u v\n\u22a2 \u2203 p, p.IsPath \u2227 p.length = G.dist u v"}, {"line": "exact \u27e8p, p.isPath_of_length_eq_dist h, h\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_bot : (\u22a5 : SimpleGraph V).dist u v = 0 := by\n  by_cases h : u = v <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "context": {"open": [], "variables": ["{V : Type*} (G : SimpleGraph V)", "{G} {u v w : V}", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nu v : V\n\u22a2 \u22a5.dist u v = 0"}, {"line": "by_cases h : u = v <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_top_of_ne (h : u \u2260 v) : (\u22a4 : SimpleGraph V).dist u v = 1 := by\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "context": {"open": [], "variables": ["{V : Type*} (G : SimpleGraph V)", "{G} {u v w : V}", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nu v : V\nh : u \u2260 v\n\u22a2 \u22a4.dist u v = 1"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_top [DecidableEq V] : (\u22a4 : SimpleGraph V).dist u v = (if u = v then 0 else 1) := by\n  by_cases h : u = v <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "context": {"open": [], "variables": ["{V : Type*} (G : SimpleGraph V)", "{G} {u v w : V}", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nu v : V\ninst\u271d : DecidableEq V\n\u22a2 \u22a4.dist u v = if u = v then 0 else 1"}, {"line": "by_cases h : u = v <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isEulerian_iff {u v : V} (p : G.Walk u v) :\n    p.IsEulerian \u2194 p.IsTrail \u2227 \u2200 e, e \u2208 G.edgeSet \u2192 e \u2208 p.edges := by\n  constructor\n  \u00b7 intro h\n    exact \u27e8h.isTrail, fun _ => h.mem_edges_iff.mpr\u27e9\n  \u00b7 rintro \u27e8h, hl\u27e9\n    exact h.isEulerian_of_forall_mem hl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Trails.lean", "context": {"open": [], "variables": ["{V : Type*} {G : SimpleGraph V}", "[DecidableEq V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu v : V\np : G.Walk u v\n\u22a2 p.IsEulerian \u2194 p.IsTrail \u2227 \u2200 e \u2208 G.edgeSet, e \u2208 p.edges"}, {"line": "constructor", "tactic_state": "case mp\nV : Type u_1\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu v : V\np : G.Walk u v\n\u22a2 p.IsEulerian \u2192 p.IsTrail \u2227 \u2200 e \u2208 G.edgeSet, e \u2208 p.edges\n---\ncase mpr\nV : Type u_1\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu v : V\np : G.Walk u v\n\u22a2 (p.IsTrail \u2227 \u2200 e \u2208 G.edgeSet, e \u2208 p.edges) \u2192 p.IsEulerian"}, {"line": "\u00b7 intro h\n    exact \u27e8h.isTrail, fun _ => h.mem_edges_iff.mpr\u27e9", "tactic_state": "case mpr\nV : Type u_1\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu v : V\np : G.Walk u v\n\u22a2 (p.IsTrail \u2227 \u2200 e \u2208 G.edgeSet, e \u2208 p.edges) \u2192 p.IsEulerian"}, {"line": "\u00b7 rintro \u27e8h, hl\u27e9\n    exact h.isEulerian_of_forall_mem hl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsEulerian.edgesFinset_eq [Fintype G.edgeSet] {u v : V} {p : G.Walk u v}\n    (h : p.IsEulerian) : h.isTrail.edgesFinset = G.edgeFinset := by\n  ext e\n  simp [h.mem_edges_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Trails.lean", "context": {"open": [], "variables": ["{V : Type*} {G : SimpleGraph V}", "[DecidableEq V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableEq V\ninst\u271d : Fintype \u2191G.edgeSet\nu v : V\np : G.Walk u v\nh : p.IsEulerian\n\u22a2 \u22ef.edgesFinset = G.edgeFinset"}, {"line": "ext e", "tactic_state": "case h\nV : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableEq V\ninst\u271d : Fintype \u2191G.edgeSet\nu v : V\np : G.Walk u v\nh : p.IsEulerian\ne : Sym2 V\n\u22a2 e \u2208 \u22ef.edgesFinset \u2194 e \u2208 G.edgeFinset"}, {"line": "simp [h.mem_edges_iff]", "tactic_state": "case h\nV : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableEq V\ninst\u271d : Fintype \u2191G.edgeSet\nu v : V\np : G.Walk u v\nh : p.IsEulerian\ne : Sym2 V\n\u22a2 e \u2208 p.edges \u2194 e \u2208 G.edgeSet"}]}
{"declaration": "lemma Subgraph.IsMatching.exists_of_universalVerts [Finite V] {s : Set V}\n    (h : Disjoint G.universalVerts s) (hc : s.ncard \u2264 G.universalVerts.ncard) :\n    \u2203 t \u2286 G.universalVerts, \u2203 (M : Subgraph G), M.verts = s \u222a t \u2227 M.IsMatching := by\n  obtain \u27e8t, ht\u27e9 := Set.exists_subset_card_eq hc\n  refine \u27e8t, ht.1, ?_\u27e9\n  obtain \u27e8f\u27e9 : Nonempty (s \u2243 t) := by\n    rw [\u2190 Cardinal.eq]\n    rw [\u2190 t.cast_ncard t.toFinite]\n    rw [\u2190 s.cast_ncard s.toFinite]\n    rw [ht.2]\n  letI hd := Set.disjoint_of_subset_left ht.1 h\n  have hadj (v : s) : G.Adj v (f v) := ht.1 (f v).2 (hd.ne_of_mem (f v).2 v.2)\n  exact Subgraph.IsMatching.exists_of_disjoint_sets_of_equiv hd.symm f hadj\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/UniversalVerts.lean", "context": {"open": [], "variables": ["{V : Type*} {G : SimpleGraph V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\nx\u271d : Sort u_2\nSubgraph : x\u271d\ninst\u271d : Finite V\ns : Set V\nh : Disjoint G.universalVerts s\nhc : s.ncard \u2264 G.universalVerts.ncard\n\u22a2 \u2203 t \u2286 G.universalVerts, \u2203 M, sorry = s \u222a t \u2227 sorry"}, {"line": "obtain \u27e8t, ht\u27e9 := Set.exists_subset_card_eq hc", "tactic_state": "case intro\nV : Type u_1\nG : SimpleGraph V\nx\u271d : Sort u_2\nSubgraph : x\u271d\ninst\u271d : Finite V\ns : Set V\nh : Disjoint G.universalVerts s\nhc : s.ncard \u2264 G.universalVerts.ncard\nt : Set V\nht : t \u2286 G.universalVerts \u2227 t.ncard = s.ncard\n\u22a2 \u2203 t \u2286 G.universalVerts, \u2203 M, sorry = s \u222a t \u2227 sorry"}, {"line": "refine \u27e8t, ht.1, ?_\u27e9", "tactic_state": "case intro\nV : Type u_1\nG : SimpleGraph V\nx\u271d : Sort u_2\nSubgraph : x\u271d\ninst\u271d : Finite V\ns : Set V\nh : Disjoint G.universalVerts s\nhc : s.ncard \u2264 G.universalVerts.ncard\nt : Set V\nht : t \u2286 G.universalVerts \u2227 t.ncard = s.ncard\n\u22a2 \u2203 M, sorry = s \u222a t \u2227 sorry"}, {"line": "obtain \u27e8f\u27e9 : Nonempty (s \u2243 t) := by\n    rw [\u2190 Cardinal.eq]\n    rw [\u2190 t.cast_ncard t.toFinite]\n    rw [\u2190 s.cast_ncard s.toFinite]\n    rw [ht.2]", "tactic_state": "case intro.intro\nV : Type u_1\nG : SimpleGraph V\nx\u271d : Sort u_2\nSubgraph : x\u271d\ninst\u271d : Finite V\ns : Set V\nh : Disjoint G.universalVerts s\nhc : s.ncard \u2264 G.universalVerts.ncard\nt : Set V\nht : t \u2286 G.universalVerts \u2227 t.ncard = s.ncard\nf : \u2191s \u2243 \u2191t\n\u22a2 \u2203 M, sorry = s \u222a t \u2227 sorry"}, {"line": "letI hd := Set.disjoint_of_subset_left ht.1 h", "tactic_state": "case intro.intro\nV : Type u_1\nG : SimpleGraph V\nx\u271d : Sort u_2\nSubgraph : x\u271d\ninst\u271d : Finite V\ns : Set V\nh : Disjoint G.universalVerts s\nhc : s.ncard \u2264 G.universalVerts.ncard\nt : Set V\nht : t \u2286 G.universalVerts \u2227 t.ncard = s.ncard\nf : \u2191s \u2243 \u2191t\nhd : Disjoint t s := Set.disjoint_of_subset_left ht.left h\n\u22a2 \u2203 M, sorry = s \u222a t \u2227 sorry"}, {"line": "have hadj (v : s) : G.Adj v (f v) := ht.1 (f v).2 (hd.ne_of_mem (f v).2 v.2)", "tactic_state": "case intro.intro\nV : Type u_1\nG : SimpleGraph V\nx\u271d : Sort u_2\nSubgraph : x\u271d\ninst\u271d : Finite V\ns : Set V\nh : Disjoint G.universalVerts s\nhc : s.ncard \u2264 G.universalVerts.ncard\nt : Set V\nht : t \u2286 G.universalVerts \u2227 t.ncard = s.ncard\nf : \u2191s \u2243 \u2191t\nhd : Disjoint t s := Set.disjoint_of_subset_left ht.left h\nhadj : \u2200 (v : \u2191s), G.Adj \u2191v \u2191(f v)\n\u22a2 \u2203 M, sorry = s \u222a t \u2227 sorry"}, {"line": "exact Subgraph.IsMatching.exists_of_disjoint_sets_of_equiv hd.symm f hadj", "tactic_state": "No Goals!"}]}
{"declaration": "lemma disjoint_image_val_universalVerts (s : Set G.deleteUniversalVerts.verts) :\n    Disjoint (Subtype.val '' s) G.universalVerts := by\n  simpa [\u2190 Set.disjoint_compl_right_iff_subset, Set.compl_eq_univ_diff] using\n    Subtype.coe_image_subset _ s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/UniversalVerts.lean", "context": {"open": [], "variables": ["{V : Type*} {G : SimpleGraph V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ns : Set \u2191G.deleteUniversalVerts.verts\n\u22a2 Disjoint (Subtype.val '' s) G.universalVerts"}, {"line": "simpa [\u2190 Set.disjoint_compl_right_iff_subset, Set.compl_eq_univ_diff] using\n    Subtype.coe_image_subset _ s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isAcyclic_iff_forall_edge_isBridge :\n    G.IsAcyclic \u2194 \u2200 \u2983e\u2984, e \u2208 (G.edgeSet) \u2192 G.IsBridge e := by\n  simp [isAcyclic_iff_forall_adj_isBridge, Sym2.forall]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Acyclic.lean", "context": {"open": ["Walk"], "variables": ["{V : Type u} (G : SimpleGraph V)", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\n\u22a2 G.IsAcyclic \u2194 \u2200 \u2983e : Sym2 V\u2984, e \u2208 G.edgeSet \u2192 G.IsBridge e"}, {"line": "simp [isAcyclic_iff_forall_adj_isBridge, Sym2.forall]", "tactic_state": "V : Type u\nG : SimpleGraph V\n\u22a2 G.IsAcyclic \u2194 \u2200 (x y : V), G.Adj x y \u2192 G.IsBridge s(x, y)"}]}
{"declaration": "theorem compl_apply_diag [Zero \u03b1] [One \u03b1] (i : V) : A.compl i i = 0 := by simp [compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean", "context": {"open": ["Matrix", "Finset Matrix SimpleGraph"], "variables": ["{V \u03b1 : Type*}", "{A : Matrix V V \u03b1}", "[DecidableEq \u03b1] [DecidableEq V] (A : Matrix V V \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : DecidableEq V\nA : Matrix V V \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\ni : V\n\u22a2 A.compl i i = 0"}, {"line": "simp [compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isSymm_compl [Zero \u03b1] [One \u03b1] (h : A.IsSymm) : A.compl.IsSymm := by\n  ext\n  simp [compl, h.apply, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean", "context": {"open": ["Matrix", "Finset Matrix SimpleGraph"], "variables": ["{V \u03b1 : Type*}", "{A : Matrix V V \u03b1}", "[DecidableEq \u03b1] [DecidableEq V] (A : Matrix V V \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : DecidableEq V\nA : Matrix V V \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\nh : A.IsSymm\n\u22a2 A.compl.IsSymm"}, {"line": "ext", "tactic_state": "case a\nV : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : DecidableEq V\nA : Matrix V V \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\nh : A.IsSymm\ni\u271d j\u271d : V\n\u22a2 A.compl.transpose i\u271d j\u271d = A.compl i\u271d j\u271d"}, {"line": "simp [compl, h.apply, eq_comm]", "tactic_state": "case a\nV : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : DecidableEq V\nA : Matrix V V \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\nh : A.IsSymm\ni\u271d j\u271d : V\n\u22a2 A.compl i\u271d j\u271d = A.compl j\u271d i\u271d"}]}
{"declaration": "theorem transpose_adjMatrix [Zero \u03b1] [One \u03b1] : (G.adjMatrix \u03b1)\u1d40 = G.adjMatrix \u03b1 := by\n  ext\n  simp [adj_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean", "context": {"open": ["Matrix", "Finset Matrix SimpleGraph", "Matrix"], "variables": ["{V \u03b1 : Type*}", "{A : Matrix V V \u03b1}", "[DecidableEq \u03b1] [DecidableEq V] (A : Matrix V V \u03b1)", "{A}", "(G : SimpleGraph V) [DecidableRel G.Adj]", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\n\u22a2 (adjMatrix \u03b1 G).transpose = adjMatrix \u03b1 G"}, {"line": "ext", "tactic_state": "case a\nV : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\ni\u271d j\u271d : V\n\u22a2 (adjMatrix \u03b1 G).transpose i\u271d j\u271d = adjMatrix \u03b1 G i\u271d j\u271d"}, {"line": "simp [adj_comm]", "tactic_state": "case a\nV : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\ni\u271d j\u271d : V\n\u22a2 (if G.Adj j\u271d i\u271d then 1 else 0) = if G.Adj i\u271d j\u271d then 1 else 0"}]}
{"declaration": "theorem one_add_adjMatrix_add_compl_adjMatrix_eq_allOnes [DecidableEq V] [DecidableEq \u03b1]\n    [AddMonoidWithOne \u03b1] : 1 + G.adjMatrix \u03b1 + (G.adjMatrix \u03b1).compl = Matrix.of fun _ _ \u21a6 1 := by\n  ext i j\n  unfold Matrix.compl\n  rw [of_apply]\n  rw [add_apply]\n  rw [adjMatrix_apply]\n  rw [add_apply]\n  rw [adjMatrix_apply]\n  rw [one_apply]\n  by_cases h : G.Adj i j\n  \u00b7 aesop\n  \u00b7 split_ifs <;> simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean", "context": {"open": ["Matrix", "Finset Matrix SimpleGraph", "Matrix"], "variables": ["{V \u03b1 : Type*}", "{A : Matrix V V \u03b1}", "[DecidableEq \u03b1] [DecidableEq V] (A : Matrix V V \u03b1)", "{A}", "(G : SimpleGraph V) [DecidableRel G.Adj]", "(\u03b1) in", "(\u03b1)", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b3 : DecidableRel G.Adj\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\n\u22a2 1 + adjMatrix \u03b1 G + (adjMatrix \u03b1 G).compl = of fun x x => 1"}, {"line": "ext i j", "tactic_state": "case a\nV : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b3 : DecidableRel G.Adj\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\ni j : V\n\u22a2 (1 + adjMatrix \u03b1 G + (adjMatrix \u03b1 G).compl) i j = of (fun x x => 1) i j"}, {"line": "unfold Matrix.compl", "tactic_state": "case a\nV : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b3 : DecidableRel G.Adj\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\ni j : V\n\u22a2 (1 + adjMatrix \u03b1 G + fun i j => if i = j then 0 else if adjMatrix \u03b1 G i j = 0 then 1 else 0) i j =\n    of (fun x x => 1) i j"}, {"line": "rw [of_apply]", "tactic_state": "case a\nV : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b3 : DecidableRel G.Adj\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\ni j : V\n\u22a2 (1 + adjMatrix \u03b1 G + fun i j => if i = j then 0 else if adjMatrix \u03b1 G i j = 0 then 1 else 0) i j = 1"}, {"line": "rw [add_apply]", "tactic_state": "case a\nV : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b3 : DecidableRel G.Adj\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\ni j : V\n\u22a2 ((1 + adjMatrix \u03b1 G) i j + if i = j then 0 else if adjMatrix \u03b1 G i j = 0 then 1 else 0) = 1"}, {"line": "rw [adjMatrix_apply]", "tactic_state": "case a\nV : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b3 : DecidableRel G.Adj\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\ni j : V\n\u22a2 ((1 + adjMatrix \u03b1 G) i j + if i = j then 0 else if (if G.Adj i j then 1 else 0) = 0 then 1 else 0) = 1"}, {"line": "rw [add_apply]", "tactic_state": "case a\nV : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b3 : DecidableRel G.Adj\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\ni j : V\n\u22a2 (1 i j + adjMatrix \u03b1 G i j + if i = j then 0 else if (if G.Adj i j then 1 else 0) = 0 then 1 else 0) = 1"}, {"line": "rw [adjMatrix_apply]", "tactic_state": "case a\nV : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b3 : DecidableRel G.Adj\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\ni j : V\n\u22a2 ((1 i j + if G.Adj i j then 1 else 0) + if i = j then 0 else if (if G.Adj i j then 1 else 0) = 0 then 1 else 0) = 1"}, {"line": "rw [one_apply]", "tactic_state": "case a\nV : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b3 : DecidableRel G.Adj\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\ni j : V\n\u22a2 (((if i = j then 1 else 0) + if G.Adj i j then 1 else 0) +\n      if i = j then 0 else if (if G.Adj i j then 1 else 0) = 0 then 1 else 0) =\n    1"}, {"line": "by_cases h : G.Adj i j", "tactic_state": "case pos\nV : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b3 : DecidableRel G.Adj\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\ni j : V\nh : G.Adj i j\n\u22a2 (((if i = j then 1 else 0) + if G.Adj i j then 1 else 0) +\n      if i = j then 0 else if (if G.Adj i j then 1 else 0) = 0 then 1 else 0) =\n    1\n---\ncase neg\nV : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b3 : DecidableRel G.Adj\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\ni j : V\nh : \u00acG.Adj i j\n\u22a2 (((if i = j then 1 else 0) + if G.Adj i j then 1 else 0) +\n      if i = j then 0 else if (if G.Adj i j then 1 else 0) = 0 then 1 else 0) =\n    1"}, {"line": "\u00b7 aesop", "tactic_state": "case neg\nV : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b3 : DecidableRel G.Adj\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : AddMonoidWithOne \u03b1\ni j : V\nh : \u00acG.Adj i j\n\u22a2 (((if i = j then 1 else 0) + if G.Adj i j then 1 else 0) +\n      if i = j then 0 else if (if G.Adj i j then 1 else 0) = 0 then 1 else 0) =\n    1"}, {"line": "\u00b7 split_ifs <;> simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "theorem adjMatrix_dotProduct [NonAssocSemiring \u03b1] (v : V) (vec : V \u2192 \u03b1) :\n    dotProduct (G.adjMatrix \u03b1 v) vec = \u2211 u \u2208 G.neighborFinset v, vec u := by\n  simp [neighborFinset_eq_filter, dotProduct, sum_filter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean", "context": {"open": ["Matrix", "Finset Matrix SimpleGraph", "Matrix"], "variables": ["{V \u03b1 : Type*}", "{A : Matrix V V \u03b1}", "[DecidableEq \u03b1] [DecidableEq V] (A : Matrix V V \u03b1)", "{A}", "(G : SimpleGraph V) [DecidableRel G.Adj]", "(\u03b1) in", "(\u03b1)", "{\u03b1}", "[Fintype V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Fintype V\ninst\u271d : NonAssocSemiring \u03b1\nv : V\nvec : V \u2192 \u03b1\n\u22a2 adjMatrix \u03b1 G v \u2b1d\u1d65 vec = \u2211 u \u2208 G.neighborFinset v, vec u"}, {"line": "simp [neighborFinset_eq_filter, dotProduct, sum_filter]", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Fintype V\ninst\u271d : NonAssocSemiring \u03b1\nv : V\nvec : V \u2192 \u03b1\n\u22a2 (\u2211 x, if G.Adj v x then 1 * vec x else 0) = \u2211 a, if G.Adj v a then vec a else 0"}]}
{"declaration": "theorem dotProduct_adjMatrix [NonAssocSemiring \u03b1] (v : V) (vec : V \u2192 \u03b1) :\n    dotProduct vec (G.adjMatrix \u03b1 v) = \u2211 u \u2208 G.neighborFinset v, vec u := by\n  simp [neighborFinset_eq_filter, dotProduct, sum_filter, Finset.sum_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean", "context": {"open": ["Matrix", "Finset Matrix SimpleGraph", "Matrix"], "variables": ["{V \u03b1 : Type*}", "{A : Matrix V V \u03b1}", "[DecidableEq \u03b1] [DecidableEq V] (A : Matrix V V \u03b1)", "{A}", "(G : SimpleGraph V) [DecidableRel G.Adj]", "(\u03b1) in", "(\u03b1)", "{\u03b1}", "[Fintype V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Fintype V\ninst\u271d : NonAssocSemiring \u03b1\nv : V\nvec : V \u2192 \u03b1\n\u22a2 vec \u2b1d\u1d65 adjMatrix \u03b1 G v = \u2211 u \u2208 G.neighborFinset v, vec u"}, {"line": "simp [neighborFinset_eq_filter, dotProduct, sum_filter, Finset.sum_apply]", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Fintype V\ninst\u271d : NonAssocSemiring \u03b1\nv : V\nvec : V \u2192 \u03b1\n\u22a2 (\u2211 x, if G.Adj v x then vec x * 1 else 0) = \u2211 a, if G.Adj v a then vec a else 0"}]}
{"declaration": "theorem adjMatrix_mulVec_apply [NonAssocSemiring \u03b1] (v : V) (vec : V \u2192 \u03b1) :\n    (G.adjMatrix \u03b1 *\u1d65 vec) v = \u2211 u \u2208 G.neighborFinset v, vec u := by\n  rw [mulVec]\n  rw [adjMatrix_dotProduct]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean", "context": {"open": ["Matrix", "Finset Matrix SimpleGraph", "Matrix"], "variables": ["{V \u03b1 : Type*}", "{A : Matrix V V \u03b1}", "[DecidableEq \u03b1] [DecidableEq V] (A : Matrix V V \u03b1)", "{A}", "(G : SimpleGraph V) [DecidableRel G.Adj]", "(\u03b1) in", "(\u03b1)", "{\u03b1}", "[Fintype V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Fintype V\ninst\u271d : NonAssocSemiring \u03b1\nv : V\nvec : V \u2192 \u03b1\n\u22a2 (adjMatrix \u03b1 G).mulVec vec v = \u2211 u \u2208 G.neighborFinset v, vec u"}, {"line": "rw [mulVec]", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Fintype V\ninst\u271d : NonAssocSemiring \u03b1\nv : V\nvec : V \u2192 \u03b1\n\u22a2 (fun j => adjMatrix \u03b1 G v j) \u2b1d\u1d65 vec = \u2211 u \u2208 G.neighborFinset v, vec u"}, {"line": "rw [adjMatrix_dotProduct]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem adjMatrix_mul_apply [NonAssocSemiring \u03b1] (M : Matrix V V \u03b1) (v w : V) :\n    (G.adjMatrix \u03b1 * M) v w = \u2211 u \u2208 G.neighborFinset v, M u w := by\n  simp [mul_apply, neighborFinset_eq_filter, sum_filter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean", "context": {"open": ["Matrix", "Finset Matrix SimpleGraph", "Matrix"], "variables": ["{V \u03b1 : Type*}", "{A : Matrix V V \u03b1}", "[DecidableEq \u03b1] [DecidableEq V] (A : Matrix V V \u03b1)", "{A}", "(G : SimpleGraph V) [DecidableRel G.Adj]", "(\u03b1) in", "(\u03b1)", "{\u03b1}", "[Fintype V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Fintype V\ninst\u271d : NonAssocSemiring \u03b1\nM : Matrix V V \u03b1\nv w : V\n\u22a2 (adjMatrix \u03b1 G * M) v w = \u2211 u \u2208 G.neighborFinset v, M u w"}, {"line": "simp [mul_apply, neighborFinset_eq_filter, sum_filter]", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Fintype V\ninst\u271d : NonAssocSemiring \u03b1\nM : Matrix V V \u03b1\nv w : V\n\u22a2 (\u2211 x, if G.Adj v x then 1 * M x w else 0) = \u2211 a, if G.Adj v a then M a w else 0"}]}
{"declaration": "theorem mul_adjMatrix_apply [NonAssocSemiring \u03b1] (M : Matrix V V \u03b1) (v w : V) :\n    (M * G.adjMatrix \u03b1) v w = \u2211 u \u2208 G.neighborFinset w, M v u := by\n  simp [mul_apply, neighborFinset_eq_filter, sum_filter, adj_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean", "context": {"open": ["Matrix", "Finset Matrix SimpleGraph", "Matrix"], "variables": ["{V \u03b1 : Type*}", "{A : Matrix V V \u03b1}", "[DecidableEq \u03b1] [DecidableEq V] (A : Matrix V V \u03b1)", "{A}", "(G : SimpleGraph V) [DecidableRel G.Adj]", "(\u03b1) in", "(\u03b1)", "{\u03b1}", "[Fintype V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Fintype V\ninst\u271d : NonAssocSemiring \u03b1\nM : Matrix V V \u03b1\nv w : V\n\u22a2 (M * adjMatrix \u03b1 G) v w = \u2211 u \u2208 G.neighborFinset w, M v u"}, {"line": "simp [mul_apply, neighborFinset_eq_filter, sum_filter, adj_comm]", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Fintype V\ninst\u271d : NonAssocSemiring \u03b1\nM : Matrix V V \u03b1\nv w : V\n\u22a2 (\u2211 x, if G.Adj x w then M v x * 1 else 0) = \u2211 a, if G.Adj w a then M v a else 0"}]}
{"declaration": "theorem trace_adjMatrix [AddCommMonoid \u03b1] [One \u03b1] : Matrix.trace (G.adjMatrix \u03b1) = 0 := by\n  simp [Matrix.trace]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean", "context": {"open": ["Matrix", "Finset Matrix SimpleGraph", "Matrix"], "variables": ["{V \u03b1 : Type*}", "{A : Matrix V V \u03b1}", "[DecidableEq \u03b1] [DecidableEq V] (A : Matrix V V \u03b1)", "{A}", "(G : SimpleGraph V) [DecidableRel G.Adj]", "(\u03b1) in", "(\u03b1)", "{\u03b1}", "[Fintype V]", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b3 : DecidableRel G.Adj\ninst\u271d\u00b2 : Fintype V\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : One \u03b1\n\u22a2 (adjMatrix \u03b1 G).trace = 0"}, {"line": "simp [Matrix.trace]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem adjMatrix_mul_self_apply_self [NonAssocSemiring \u03b1] (i : V) :\n    (G.adjMatrix \u03b1 * G.adjMatrix \u03b1) i i = degree G i := by simp [filter_true_of_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean", "context": {"open": ["Matrix", "Finset Matrix SimpleGraph", "Matrix"], "variables": ["{V \u03b1 : Type*}", "{A : Matrix V V \u03b1}", "[DecidableEq \u03b1] [DecidableEq V] (A : Matrix V V \u03b1)", "{A}", "(G : SimpleGraph V) [DecidableRel G.Adj]", "(\u03b1) in", "(\u03b1)", "{\u03b1}", "[Fintype V]", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Fintype V\ninst\u271d : NonAssocSemiring \u03b1\ni : V\n\u22a2 (adjMatrix \u03b1 G * adjMatrix \u03b1 G) i i = \u2191(G.degree i)"}, {"line": "simp [filter_true_of_mem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem adjMatrix_mulVec_const_apply [NonAssocSemiring \u03b1] {a : \u03b1} {v : V} :\n    (G.adjMatrix \u03b1 *\u1d65 Function.const _ a) v = G.degree v * a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean", "context": {"open": ["Matrix", "Finset Matrix SimpleGraph", "Matrix"], "variables": ["{V \u03b1 : Type*}", "{A : Matrix V V \u03b1}", "[DecidableEq \u03b1] [DecidableEq V] (A : Matrix V V \u03b1)", "{A}", "(G : SimpleGraph V) [DecidableRel G.Adj]", "(\u03b1) in", "(\u03b1)", "{\u03b1}", "[Fintype V]", "(\u03b1) in", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Fintype V\ninst\u271d : NonAssocSemiring \u03b1\na : \u03b1\nv : V\n\u22a2 (adjMatrix \u03b1 G).mulVec (Function.const V a) v = \u2191(G.degree v) * a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem adjMatrix_mulVec_const_apply_of_regular [NonAssocSemiring \u03b1] {d : \u2115} {a : \u03b1}\n    (hd : G.IsRegularOfDegree d) {v : V} : (G.adjMatrix \u03b1 *\u1d65 Function.const _ a) v = d * a := by\n  simp [hd v]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean", "context": {"open": ["Matrix", "Finset Matrix SimpleGraph", "Matrix"], "variables": ["{V \u03b1 : Type*}", "{A : Matrix V V \u03b1}", "[DecidableEq \u03b1] [DecidableEq V] (A : Matrix V V \u03b1)", "{A}", "(G : SimpleGraph V) [DecidableRel G.Adj]", "(\u03b1) in", "(\u03b1)", "{\u03b1}", "[Fintype V]", "(\u03b1) in", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : DecidableEq V\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Fintype V\ninst\u271d : NonAssocSemiring \u03b1\nd : \u2115\na : \u03b1\nhd : G.IsRegularOfDegree d\nv : V\n\u22a2 (adjMatrix \u03b1 G).mulVec (Function.const V a) v = \u2191d * a"}, {"line": "simp [hd v]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ne_of_adj (h : G.Adj a b) : a \u2260 b := by\n  rintro rfl\n  exact G.irrefl h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b9 : Sort*} {V : Type u} (G : SimpleGraph V) {a b c u v w : V} {e : Sym2 V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\na b : V\nh : G.Adj a b\n\u22a2 a \u2260 b"}, {"line": "rintro rfl", "tactic_state": "V : Type u\nG : SimpleGraph V\na : V\nh : G.Adj a a\n\u22a2 False"}, {"line": "exact G.irrefl h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem adj_congr_of_sym2 {u v w x : V} (h : s(u, v) = s(w, x)) : G.Adj u v \u2194 G.Adj w x := by\n  simp only [Sym2.eq] at h\n  simp only [Sym2.rel_iff'] at h\n  simp only [Prod.mk.injEq] at h\n  simp only [Prod.swap_prod_mk] at h\n  rcases h with hl | hr\n  \u00b7 rw [hl.1, hl.2]\n  \u00b7 rw [hr.1, hr.2, adj_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b9 : Sort*} {V : Type u} (G : SimpleGraph V) {a b c u v w : V} {e : Sym2 V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w x : V\nh : s(u, v) = s(w, x)\n\u22a2 G.Adj u v \u2194 G.Adj w x"}, {"line": "simp only [Sym2.eq] at h", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w x : V\nh : Sym2.Rel V (u, v) (w, x)\n\u22a2 G.Adj u v \u2194 G.Adj w x"}, {"line": "simp only [Sym2.rel_iff'] at h", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w x : V\nh : (u, v) = (w, x) \u2228 (u, v) = (w, x).swap\n\u22a2 G.Adj u v \u2194 G.Adj w x"}, {"line": "simp only [Prod.mk.injEq] at h", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w x : V\nh : u = w \u2227 v = x \u2228 (u, v) = (w, x).swap\n\u22a2 G.Adj u v \u2194 G.Adj w x"}, {"line": "simp only [Prod.swap_prod_mk] at h", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w x : V\nh : u = w \u2227 v = x \u2228 (u, v) = (x, w)\n\u22a2 G.Adj u v \u2194 G.Adj w x"}, {"line": "rcases h with hl | hr", "tactic_state": "case inl\nV : Type u\nG : SimpleGraph V\nu v w x : V\nhl : u = w \u2227 v = x\n\u22a2 G.Adj u v \u2194 G.Adj w x\n---\ncase inr\nV : Type u\nG : SimpleGraph V\nu v w x : V\nhr : (u, v) = (x, w)\n\u22a2 G.Adj u v \u2194 G.Adj w x"}, {"line": "\u00b7 rw [hl.1, hl.2]", "tactic_state": "case inr\nV : Type u\nG : SimpleGraph V\nu v w x : V\nhr : (u, v) = (x, w)\n\u22a2 G.Adj u v \u2194 G.Adj w x"}, {"line": "\u00b7 rw [hr.1, hr.2, adj_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_adj {f : \u03b9 \u2192 SimpleGraph V} : (\u2a06 i, f i).Adj a b \u2194 \u2203 i, (f i).Adj a b := by simp [iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b9 : Sort*} {V : Type u} (G : SimpleGraph V) {a b c u v w : V} {e : Sym2 V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nV : Type u\na b : V\nf : \u03b9 \u2192 SimpleGraph V\n\u22a2 (\u2a06 i, f i).Adj a b \u2194 \u2203 i, (f i).Adj a b"}, {"line": "simp [iSup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iInf_adj {f : \u03b9 \u2192 SimpleGraph V} : (\u2a05 i, f i).Adj a b \u2194 (\u2200 i, (f i).Adj a b) \u2227 a \u2260 b := by\n  simp [iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b9 : Sort*} {V : Type u} (G : SimpleGraph V) {a b c u v w : V} {e : Sym2 V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nV : Type u\na b : V\nf : \u03b9 \u2192 SimpleGraph V\n\u22a2 (\u2a05 i, f i).Adj a b \u2194 (\u2200 (i : \u03b9), (f i).Adj a b) \u2227 a \u2260 b"}, {"line": "simp [iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edgeSet_sup : (G\u2081 \u2294 G\u2082).edgeSet = G\u2081.edgeSet \u222a G\u2082.edgeSet := by\n  ext \u27e8x, y\u27e9\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b9 : Sort*} {V : Type u} (G : SimpleGraph V) {a b c u v w : V} {e : Sym2 V}", "(V) (H : SimpleGraph V) [DecidableRel G.Adj] [DecidableRel H.Adj]", "[DecidableEq V]", "{G\u2081 G\u2082 : SimpleGraph V}", "(G\u2081 G\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d : DecidableEq V\nG\u2081 G\u2082 : SimpleGraph V\n\u22a2 (G\u2081 \u2294 G\u2082).edgeSet = G\u2081.edgeSet \u222a G\u2082.edgeSet"}, {"line": "ext \u27e8x, y\u27e9", "tactic_state": "case h.mk.mk\nV : Type u\ninst\u271d : DecidableEq V\nG\u2081 G\u2082 : SimpleGraph V\nx\u271d : Sym2 V\nx y : V\n\u22a2 Quot.mk (Sym2.Rel V) (x, y) \u2208 (G\u2081 \u2294 G\u2082).edgeSet \u2194 Quot.mk (Sym2.Rel V) (x, y) \u2208 G\u2081.edgeSet \u222a G\u2082.edgeSet"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edgeSet_inf : (G\u2081 \u2293 G\u2082).edgeSet = G\u2081.edgeSet \u2229 G\u2082.edgeSet := by\n  ext \u27e8x, y\u27e9\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b9 : Sort*} {V : Type u} (G : SimpleGraph V) {a b c u v w : V} {e : Sym2 V}", "(V) (H : SimpleGraph V) [DecidableRel G.Adj] [DecidableRel H.Adj]", "[DecidableEq V]", "{G\u2081 G\u2082 : SimpleGraph V}", "(G\u2081 G\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d : DecidableEq V\nG\u2081 G\u2082 : SimpleGraph V\n\u22a2 (G\u2081 \u2293 G\u2082).edgeSet = G\u2081.edgeSet \u2229 G\u2082.edgeSet"}, {"line": "ext \u27e8x, y\u27e9", "tactic_state": "case h.mk.mk\nV : Type u\ninst\u271d : DecidableEq V\nG\u2081 G\u2082 : SimpleGraph V\nx\u271d : Sym2 V\nx y : V\n\u22a2 Quot.mk (Sym2.Rel V) (x, y) \u2208 (G\u2081 \u2293 G\u2082).edgeSet \u2194 Quot.mk (Sym2.Rel V) (x, y) \u2208 G\u2081.edgeSet \u2229 G\u2082.edgeSet"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edgeSet_sdiff : (G\u2081 \\ G\u2082).edgeSet = G\u2081.edgeSet \\ G\u2082.edgeSet := by\n  ext \u27e8x, y\u27e9\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b9 : Sort*} {V : Type u} (G : SimpleGraph V) {a b c u v w : V} {e : Sym2 V}", "(V) (H : SimpleGraph V) [DecidableRel G.Adj] [DecidableRel H.Adj]", "[DecidableEq V]", "{G\u2081 G\u2082 : SimpleGraph V}", "(G\u2081 G\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d : DecidableEq V\nG\u2081 G\u2082 : SimpleGraph V\n\u22a2 (G\u2081 \\ G\u2082).edgeSet = G\u2081.edgeSet \\ G\u2082.edgeSet"}, {"line": "ext \u27e8x, y\u27e9", "tactic_state": "case h.mk.mk\nV : Type u\ninst\u271d : DecidableEq V\nG\u2081 G\u2082 : SimpleGraph V\nx\u271d : Sym2 V\nx y : V\n\u22a2 Quot.mk (Sym2.Rel V) (x, y) \u2208 (G\u2081 \\ G\u2082).edgeSet \u2194 Quot.mk (Sym2.Rel V) (x, y) \u2208 G\u2081.edgeSet \\ G\u2082.edgeSet"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edge_other_ne {e : Sym2 V} (he : e \u2208 G.edgeSet) {v : V} (h : v \u2208 e) :\n    Sym2.Mem.other h \u2260 v := by\n  rw [\u2190 Sym2.other_spec h] at he\n  rw [Sym2.eq_swap] at he\n  exact G.ne_of_adj he\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b9 : Sort*} {V : Type u} (G : SimpleGraph V) {a b c u v w : V} {e : Sym2 V}", "(V) (H : SimpleGraph V) [DecidableRel G.Adj] [DecidableRel H.Adj]", "[DecidableEq V]", "{G\u2081 G\u2082 : SimpleGraph V}", "(G\u2081 G\u2082)", "{G G\u2081 G\u2082}", "(G G\u2081 G\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\ne : Sym2 V\nhe : e \u2208 G.edgeSet\nv : V\nh : v \u2208 e\n\u22a2 Sym2.Mem.other h \u2260 v"}, {"line": "rw [\u2190 Sym2.other_spec h] at he", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\ne : Sym2 V\nv : V\nh : v \u2208 e\nhe : s(v, Sym2.Mem.other h) \u2208 G.edgeSet\n\u22a2 Sym2.Mem.other h \u2260 v"}, {"line": "rw [Sym2.eq_swap] at he", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\ne : Sym2 V\nv : V\nh : v \u2208 e\nhe : s(Sym2.Mem.other h, v) \u2208 G.edgeSet\n\u22a2 Sym2.Mem.other h \u2260 v"}, {"line": "exact G.ne_of_adj he", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fromEdgeSet_edgeSet : fromEdgeSet G.edgeSet = G := by\n  ext v w\n  exact \u27e8fun h => h.1, fun h => \u27e8h, G.ne_of_adj h\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b9 : Sort*} {V : Type u} (G : SimpleGraph V) {a b c u v w : V} {e : Sym2 V}", "(V) (H : SimpleGraph V) [DecidableRel G.Adj] [DecidableRel H.Adj]", "[DecidableEq V]", "{G\u2081 G\u2082 : SimpleGraph V}", "(G\u2081 G\u2082)", "{G G\u2081 G\u2082}", "(G G\u2081 G\u2082)", "(s : Set (Sym2 V))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\nx\u271d : Sort u_2\nfromEdgeSet : x\u271d\n\u22a2 sorry = G"}, {"line": "ext v w", "tactic_state": "case Adj.h.h.a\nV : Type u\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\nx\u271d : Sort u_2\nfromEdgeSet : x\u271d\nv w : V\n\u22a2 sorry.Adj v w \u2194 G.Adj v w"}, {"line": "exact \u27e8fun h => h.1, fun h => \u27e8h, G.ne_of_adj h\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem incidenceSet_inter_incidenceSet_of_adj (h : G.Adj a b) :\n    G.incidenceSet a \u2229 G.incidenceSet b = {s(a, b)} := by\n  refine (G.incidenceSet_inter_incidenceSet_subset <| h.ne).antisymm ?_\n  rintro _ (rfl : _ = s(a, b))\n  exact \u27e8G.mk'_mem_incidenceSet_left_iff.2 h, G.mk'_mem_incidenceSet_right_iff.2 h\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b9 : Sort*} {V : Type u} (G : SimpleGraph V) {a b c u v w : V} {e : Sym2 V}", "(V) (H : SimpleGraph V) [DecidableRel G.Adj] [DecidableRel H.Adj]", "[DecidableEq V]", "{G\u2081 G\u2082 : SimpleGraph V}", "(G\u2081 G\u2082)", "{G G\u2081 G\u2082}", "(G G\u2081 G\u2082)", "(s : Set (Sym2 V))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\na b : V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\nh : G.Adj a b\n\u22a2 G.incidenceSet a \u2229 G.incidenceSet b = {s(a, b)}"}, {"line": "refine (G.incidenceSet_inter_incidenceSet_subset <| h.ne).antisymm ?_", "tactic_state": "V : Type u\nG : SimpleGraph V\na b : V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\nh : G.Adj a b\n\u22a2 {s(a, b)} \u2286 G.incidenceSet a \u2229 G.incidenceSet b"}, {"line": "rintro _ (rfl : _ = s(a, b))", "tactic_state": "V : Type u\nG : SimpleGraph V\na b : V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\nh : G.Adj a b\n\u22a2 s(a, b) \u2208 G.incidenceSet a \u2229 G.incidenceSet b"}, {"line": "exact \u27e8G.mk'_mem_incidenceSet_left_iff.2 h, G.mk'_mem_incidenceSet_right_iff.2 h\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem incidenceSet_inter_incidenceSet_of_not_adj (h : \u00acG.Adj a b) (hn : a \u2260 b) :\n    G.incidenceSet a \u2229 G.incidenceSet b = \u2205 := by\n  simp_rw [Set.eq_empty_iff_forall_not_mem, Set.mem_inter_iff, not_and]\n  intro u ha hb\n  exact h (G.adj_of_mem_incidenceSet hn ha hb)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b9 : Sort*} {V : Type u} (G : SimpleGraph V) {a b c u v w : V} {e : Sym2 V}", "(V) (H : SimpleGraph V) [DecidableRel G.Adj] [DecidableRel H.Adj]", "[DecidableEq V]", "{G\u2081 G\u2082 : SimpleGraph V}", "(G\u2081 G\u2082)", "{G G\u2081 G\u2082}", "(G G\u2081 G\u2082)", "(s : Set (Sym2 V))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\na b : V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\nh : \u00acG.Adj a b\nhn : a \u2260 b\n\u22a2 G.incidenceSet a \u2229 G.incidenceSet b = \u2205"}, {"line": "simp_rw [Set.eq_empty_iff_forall_not_mem, Set.mem_inter_iff, not_and]", "tactic_state": "V : Type u\nG : SimpleGraph V\na b : V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\nh : \u00acG.Adj a b\nhn : a \u2260 b\n\u22a2 \u2200 x \u2208 G.incidenceSet a, x \u2209 G.incidenceSet b"}, {"line": "intro u ha hb", "tactic_state": "V : Type u\nG : SimpleGraph V\na b : V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\nh : \u00acG.Adj a b\nhn : a \u2260 b\nu : Sym2 V\nha : u \u2208 G.incidenceSet a\nhb : u \u2208 G.incidenceSet b\n\u22a2 False"}, {"line": "exact h (G.adj_of_mem_incidenceSet hn ha hb)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_mem_neighborSet_self : a \u2209 G.neighborSet a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b9 : Sort*} {V : Type u} (G : SimpleGraph V) {a b c u v w : V} {e : Sym2 V}", "(V) (H : SimpleGraph V) [DecidableRel G.Adj] [DecidableRel H.Adj]", "[DecidableEq V]", "{G\u2081 G\u2082 : SimpleGraph V}", "(G\u2081 G\u2082)", "{G G\u2081 G\u2082}", "(G G\u2081 G\u2082)", "(s : Set (Sym2 V))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\na : V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\n\u22a2 a \u2209 G.neighborSet a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_incidenceSet (v w : V) : s(v, w) \u2208 G.incidenceSet v \u2194 G.Adj v w := by\n  simp [incidenceSet]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b9 : Sort*} {V : Type u} (G : SimpleGraph V) {a b c u v w : V} {e : Sym2 V}", "(V) (H : SimpleGraph V) [DecidableRel G.Adj] [DecidableRel H.Adj]", "[DecidableEq V]", "{G\u2081 G\u2082 : SimpleGraph V}", "(G\u2081 G\u2082)", "{G G\u2081 G\u2082}", "(G G\u2081 G\u2082)", "(s : Set (Sym2 V))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\nv w : V\n\u22a2 s(v, w) \u2208 G.incidenceSet v \u2194 G.Adj v w"}, {"line": "simp [incidenceSet]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neighborSet_compl (G : SimpleGraph V) (v : V) :\n    G\u1d9c.neighborSet v = (G.neighborSet v)\u1d9c \\ {v} := by\n  ext w\n  simp [and_comm, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b9 : Sort*} {V : Type u} (G : SimpleGraph V) {a b c u v w : V} {e : Sym2 V}", "(V) (H : SimpleGraph V) [DecidableRel G.Adj] [DecidableRel H.Adj]", "[DecidableEq V]", "{G\u2081 G\u2082 : SimpleGraph V}", "(G\u2081 G\u2082)", "{G G\u2081 G\u2082}", "(G G\u2081 G\u2082)", "(s : Set (Sym2 V))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d : DecidableEq V\nG : SimpleGraph V\nv : V\n\u22a2 G\u1d9c.neighborSet v = (G.neighborSet v)\u1d9c \\ {v}"}, {"line": "ext w", "tactic_state": "case h\nV : Type u\ninst\u271d : DecidableEq V\nG : SimpleGraph V\nv w : V\n\u22a2 w \u2208 G\u1d9c.neighborSet v \u2194 w \u2208 (G.neighborSet v)\u1d9c \\ {v}"}, {"line": "simp [and_comm, eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem commonNeighbors_top_eq {v w : V} :\n    (\u22a4 : SimpleGraph V).commonNeighbors v w = Set.univ \\ {v, w} := by\n  ext u\n  simp [commonNeighbors, eq_comm, not_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b9 : Sort*} {V : Type u} (G : SimpleGraph V) {a b c u v w : V} {e : Sym2 V}", "(V) (H : SimpleGraph V) [DecidableRel G.Adj] [DecidableRel H.Adj]", "[DecidableEq V]", "{G\u2081 G\u2082 : SimpleGraph V}", "(G\u2081 G\u2082)", "{G G\u2081 G\u2082}", "(G G\u2081 G\u2082)", "(s : Set (Sym2 V))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d : DecidableEq V\nv w : V\n\u22a2 \u22a4.commonNeighbors v w = Set.univ \\ {v, w}"}, {"line": "ext u", "tactic_state": "case h\nV : Type u\ninst\u271d : DecidableEq V\nv w u : V\n\u22a2 u \u2208 \u22a4.commonNeighbors v w \u2194 u \u2208 Set.univ \\ {v, w}"}, {"line": "simp [commonNeighbors, eq_comm, not_or]", "tactic_state": "case h\nV : Type u\ninst\u271d : DecidableEq V\nv w u : V\n\u22a2 u \u2208 \u22a4.commonNeighbors v w \u2194 \u00acv = u \u2227 \u00acw = u"}]}
{"declaration": "theorem IsBipartiteWith.symm (h : G.IsBipartiteWith s t) : G.IsBipartiteWith t s where\n  disjoint := h.disjoint.symm\n  mem_of_adj v w hadj := by\n    rw [@and_comm (v \u2208 t) (w \u2208 s)]\n    rw [@and_comm (v \u2208 s) (w \u2208 t)]\n    exact h.mem_of_adj hadj.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Bipartite.lean", "context": {"open": ["BigOperators Finset Fintype"], "variables": ["{V : Type*} {v w : V} {G : SimpleGraph V} {s t : Set V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ns t : Set V\nh : G.IsBipartiteWith s t\nv w : V\nhadj : G.Adj v w\n\u22a2 v \u2208 t \u2227 w \u2208 s \u2228 v \u2208 s \u2227 w \u2208 t"}, {"line": "rw [@and_comm (v \u2208 t) (w \u2208 s)]", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ns t : Set V\nh : G.IsBipartiteWith s t\nv w : V\nhadj : G.Adj v w\n\u22a2 w \u2208 s \u2227 v \u2208 t \u2228 v \u2208 s \u2227 w \u2208 t"}, {"line": "rw [@and_comm (v \u2208 s) (w \u2208 t)]", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ns t : Set V\nh : G.IsBipartiteWith s t\nv w : V\nhadj : G.Adj v w\n\u22a2 w \u2208 s \u2227 v \u2208 t \u2228 w \u2208 t \u2227 v \u2208 s"}, {"line": "exact h.mem_of_adj hadj.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsBipartiteWith.mem_of_mem_adj\n    (h : G.IsBipartiteWith s t) (hv : v \u2208 s) (hadj : G.Adj v w) : w \u2208 t := by\n  apply h.mem_of_adj at hadj\n  have nhv : v \u2209 t := Set.disjoint_left.mp h.disjoint hv\n  simpa [hv, nhv] using hadj\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Bipartite.lean", "context": {"open": ["BigOperators Finset Fintype"], "variables": ["{V : Type*} {v w : V} {G : SimpleGraph V} {s t : Set V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nv w : V\nG : SimpleGraph V\ns t : Set V\nh : G.IsBipartiteWith s t\nhv : v \u2208 s\nhadj : G.Adj v w\n\u22a2 w \u2208 t"}, {"line": "apply h.mem_of_adj at hadj", "tactic_state": "V : Type u_1\nv w : V\nG : SimpleGraph V\ns t : Set V\nh : G.IsBipartiteWith s t\nhv : v \u2208 s\nhadj : v \u2208 s \u2227 w \u2208 t \u2228 v \u2208 t \u2227 w \u2208 s\n\u22a2 w \u2208 t"}, {"line": "have nhv : v \u2209 t := Set.disjoint_left.mp h.disjoint hv", "tactic_state": "V : Type u_1\nv w : V\nG : SimpleGraph V\ns t : Set V\nh : G.IsBipartiteWith s t\nhv : v \u2208 s\nhadj : v \u2208 s \u2227 w \u2208 t \u2228 v \u2208 t \u2227 w \u2208 s\nnhv : v \u2209 t\n\u22a2 w \u2208 t"}, {"line": "simpa [hv, nhv] using hadj", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsBipartiteWith.mem_of_mem_adj'\n    (h : G.IsBipartiteWith s t) (hw : w \u2208 t) (hadj : G.Adj v w) : v \u2208 s := by\n  apply h.mem_of_adj at hadj\n  have nhw : w \u2209 s := Set.disjoint_right.mp h.disjoint hw\n  simpa [hw, nhw] using hadj\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Bipartite.lean", "context": {"open": ["BigOperators Finset Fintype"], "variables": ["{V : Type*} {v w : V} {G : SimpleGraph V} {s t : Set V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nv w : V\nG : SimpleGraph V\ns t : Set V\nh : G.IsBipartiteWith s t\nhw : w \u2208 t\nhadj : G.Adj v w\n\u22a2 v \u2208 s"}, {"line": "apply h.mem_of_adj at hadj", "tactic_state": "V : Type u_1\nv w : V\nG : SimpleGraph V\ns t : Set V\nh : G.IsBipartiteWith s t\nhw : w \u2208 t\nhadj : v \u2208 s \u2227 w \u2208 t \u2228 v \u2208 t \u2227 w \u2208 s\n\u22a2 v \u2208 s"}, {"line": "have nhw : w \u2209 s := Set.disjoint_right.mp h.disjoint hw", "tactic_state": "V : Type u_1\nv w : V\nG : SimpleGraph V\ns t : Set V\nh : G.IsBipartiteWith s t\nhw : w \u2208 t\nhadj : v \u2208 s \u2227 w \u2208 t \u2228 v \u2208 t \u2227 w \u2208 s\nnhw : w \u2209 s\n\u22a2 v \u2208 s"}, {"line": "simpa [hw, nhw] using hadj", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isBipartiteWith_support_subset (h : G.IsBipartiteWith s t) : G.support \u2286 s \u222a t := by\n  intro v \u27e8w, hadj\u27e9\n  apply h.mem_of_adj at hadj\n  tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Bipartite.lean", "context": {"open": ["BigOperators Finset Fintype"], "variables": ["{V : Type*} {v w : V} {G : SimpleGraph V} {s t : Set V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ns t : Set V\nh : G.IsBipartiteWith s t\n\u22a2 G.support \u2286 s \u222a t"}, {"line": "intro v \u27e8w, hadj\u27e9", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ns t : Set V\nh : G.IsBipartiteWith s t\nv w : V\nhadj : G.Adj v w\n\u22a2 v \u2208 s \u222a t"}, {"line": "apply h.mem_of_adj at hadj", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ns t : Set V\nh : G.IsBipartiteWith s t\nv w : V\nhadj : v \u2208 s \u2227 w \u2208 t \u2228 v \u2208 t \u2227 w \u2208 s\n\u22a2 v \u2208 s \u222a t"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isClique_empty : G.IsClique \u2205 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Clique.lean", "context": {"open": ["Finset Fintype Function SimpleGraph.Walk"], "variables": ["{\u03b1 \u03b2 : Type*} (G H : SimpleGraph \u03b1)", "{s t : Set \u03b1}", "{G H} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\n\u22a2 G.IsClique \u2205"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isClique_singleton (a : \u03b1) : G.IsClique {a} := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Clique.lean", "context": {"open": ["Finset Fintype Function SimpleGraph.Walk"], "variables": ["{\u03b1 \u03b2 : Type*} (G H : SimpleGraph \u03b1)", "{s t : Set \u03b1}", "{G H} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\na : \u03b1\n\u22a2 G.IsClique {a}"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsClique.map (h : G.IsClique s) {f : \u03b1 \u21aa \u03b2} : (G.map f).IsClique (f '' s) := by\n  rintro _ \u27e8a, ha, rfl\u27e9 _ \u27e8b, hb, rfl\u27e9 hab\n  exact \u27e8a, b, h ha hb <| ne_of_apply_ne _ hab, rfl, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Clique.lean", "context": {"open": ["Finset Fintype Function SimpleGraph.Walk"], "variables": ["{\u03b1 \u03b2 : Type*} (G H : SimpleGraph \u03b1)", "{s t : Set \u03b1}", "{G H} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\ns : Set \u03b1\nh : G.IsClique s\nf : \u03b1 \u21aa \u03b2\n\u22a2 (SimpleGraph.map f G).IsClique (\u21d1f '' s)"}, {"line": "rintro _ \u27e8a, ha, rfl\u27e9 _ \u27e8b, hb, rfl\u27e9 hab", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\ns : Set \u03b1\nh : G.IsClique s\nf : \u03b1 \u21aa \u03b2\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : f a \u2260 f b\n\u22a2 (SimpleGraph.map f G).Adj (f a) (f b)"}, {"line": "exact \u27e8a, b, h ha hb <| ne_of_apply_ne _ hab, rfl, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClique_map_iff {f : \u03b1 \u21aa \u03b2} {t : Set \u03b2} :\n    (G.map f).IsClique t \u2194 t.Subsingleton \u2228 \u2203 (s : Set \u03b1), G.IsClique s \u2227 f '' s = t := by\n  obtain (ht | ht) := t.subsingleton_or_nontrivial\n  \u00b7 simp [IsClique.of_subsingleton, ht]\n  simp [isClique_map_iff_of_nontrivial ht, ht.not_subsingleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Clique.lean", "context": {"open": ["Finset Fintype Function SimpleGraph.Walk"], "variables": ["{\u03b1 \u03b2 : Type*} (G H : SimpleGraph \u03b1)", "{s t : Set \u03b1}", "{G H} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nf : \u03b1 \u21aa \u03b2\nt : Set \u03b2\n\u22a2 (SimpleGraph.map f G).IsClique t \u2194 t.Subsingleton \u2228 \u2203 s, G.IsClique s \u2227 \u21d1f '' s = t"}, {"line": "obtain (ht | ht) := t.subsingleton_or_nontrivial", "tactic_state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nf : \u03b1 \u21aa \u03b2\nt : Set \u03b2\nht : t.Subsingleton\n\u22a2 (SimpleGraph.map f G).IsClique t \u2194 t.Subsingleton \u2228 \u2203 s, G.IsClique s \u2227 \u21d1f '' s = t\n---\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nf : \u03b1 \u21aa \u03b2\nt : Set \u03b2\nht : t.Nontrivial\n\u22a2 (SimpleGraph.map f G).IsClique t \u2194 t.Subsingleton \u2228 \u2203 s, G.IsClique s \u2227 \u21d1f '' s = t"}, {"line": "\u00b7 simp [IsClique.of_subsingleton, ht]", "tactic_state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nf : \u03b1 \u21aa \u03b2\nt : Set \u03b2\nht : t.Nontrivial\n\u22a2 (SimpleGraph.map f G).IsClique t \u2194 t.Subsingleton \u2228 \u2203 s, G.IsClique s \u2227 \u21d1f '' s = t"}, {"line": "simp [isClique_map_iff_of_nontrivial ht, ht.not_subsingleton]", "tactic_state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nf : \u03b1 \u21aa \u03b2\nt : Set \u03b2\nht : t.Nontrivial\n\u22a2 (SimpleGraph.map f G).IsClique t \u2194 \u2203 s, G.IsClique s \u2227 \u21d1f '' s = t"}]}
{"declaration": "protected theorem IsClique.finsetMap {f : \u03b1 \u21aa \u03b2} {s : Finset \u03b1} (h : G.IsClique s) :\n    (G.map f).IsClique (s.map f) := by\n  simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Clique.lean", "context": {"open": ["Finset Fintype Function SimpleGraph.Walk"], "variables": ["{\u03b1 \u03b2 : Type*} (G H : SimpleGraph \u03b1)", "{s t : Set \u03b1}", "{G H} {a b : \u03b1}", "{f : \u03b1 \u21aa \u03b2} {t : Finset \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nf : \u03b1 \u21aa \u03b2\ns : Finset \u03b1\nh : G.IsClique \u2191s\n\u22a2 (SimpleGraph.map f G).IsClique \u2191(map f s)"}, {"line": "simpa", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsClique.of_induce {S : Subgraph G} {F : Set \u03b1} {A : Set F}\n    (c : (S.induce F).coe.IsClique A) : G.IsClique (Subtype.val '' A) := by\n  simp only [Set.Pairwise]\n  simp only [Set.mem_image]\n  simp only [Subtype.exists]\n  simp only [exists_and_right]\n  simp only [exists_eq_right]\n  intro _ \u27e8_, ainA\u27e9 _ \u27e8_, binA\u27e9 anb\n  exact S.adj_sub (c ainA binA (Subtype.coe_ne_coe.mp anb)).2.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Clique.lean", "context": {"open": ["Finset Fintype Function SimpleGraph.Walk"], "variables": ["{\u03b1 \u03b2 : Type*} (G H : SimpleGraph \u03b1)", "{s t : Set \u03b1}", "{G H} {a b : \u03b1}", "{f : \u03b1 \u21aa \u03b2} {t : Finset \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nx\u271d : Sort u_3\nSubgraph : x\u271d\nS : sorry\nF : Set \u03b1\nA : Set \u2191F\nc : sorry\n\u22a2 G.IsClique (Subtype.val '' A)"}, {"line": "simp only [Set.Pairwise]", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nx\u271d : Sort u_3\nSubgraph : x\u271d\nS : sorry\nF : Set \u03b1\nA : Set \u2191F\nc : sorry\n\u22a2 \u2200 \u2983x : \u03b1\u2984, x \u2208 Subtype.val '' A \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 Subtype.val '' A \u2192 x \u2260 y \u2192 G.Adj x y"}, {"line": "simp only [Set.mem_image]", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nx\u271d : Sort u_3\nSubgraph : x\u271d\nS : sorry\nF : Set \u03b1\nA : Set \u2191F\nc : sorry\n\u22a2 \u2200 \u2983x : \u03b1\u2984, (\u2203 x_1 \u2208 A, \u2191x_1 = x) \u2192 \u2200 \u2983y : \u03b1\u2984, (\u2203 x \u2208 A, \u2191x = y) \u2192 x \u2260 y \u2192 G.Adj x y"}, {"line": "simp only [Subtype.exists]", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nx\u271d : Sort u_3\nSubgraph : x\u271d\nS : sorry\nF : Set \u03b1\nA : Set \u2191F\nc : sorry\n\u22a2 \u2200 \u2983x : \u03b1\u2984,\n    (\u2203 a, \u2203 (h : a \u2208 F), \u27e8a, \u22ef\u27e9 \u2208 A \u2227 a = x) \u2192 \u2200 \u2983y : \u03b1\u2984, (\u2203 a, \u2203 (h : a \u2208 F), \u27e8a, \u22ef\u27e9 \u2208 A \u2227 a = y) \u2192 x \u2260 y \u2192 G.Adj x y"}, {"line": "simp only [exists_and_right]", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nx\u271d : Sort u_3\nSubgraph : x\u271d\nS : sorry\nF : Set \u03b1\nA : Set \u2191F\nc : sorry\n\u22a2 \u2200 \u2983x : \u03b1\u2984,\n    (\u2203 a, (\u2203 (x : a \u2208 F), \u27e8a, \u22ef\u27e9 \u2208 A) \u2227 a = x) \u2192\n      \u2200 \u2983y : \u03b1\u2984, (\u2203 a, (\u2203 (x : a \u2208 F), \u27e8a, \u22ef\u27e9 \u2208 A) \u2227 a = y) \u2192 x \u2260 y \u2192 G.Adj x y"}, {"line": "simp only [exists_eq_right]", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nx\u271d : Sort u_3\nSubgraph : x\u271d\nS : sorry\nF : Set \u03b1\nA : Set \u2191F\nc : sorry\n\u22a2 \u2200 \u2983x : \u03b1\u2984, (\u2203 (x_1 : x \u2208 F), \u27e8x, \u22ef\u27e9 \u2208 A) \u2192 \u2200 \u2983y : \u03b1\u2984, (\u2203 (x : y \u2208 F), \u27e8y, \u22ef\u27e9 \u2208 A) \u2192 x \u2260 y \u2192 G.Adj x y"}, {"line": "intro _ \u27e8_, ainA\u27e9 _ \u27e8_, binA\u27e9 anb", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nx\u271d\u00b9 : Sort u_3\nSubgraph : x\u271d\u00b9\nS : sorry\nF : Set \u03b1\nA : Set \u2191F\nc : sorry\nx\u271d : \u03b1\nw\u271d\u00b9 : x\u271d \u2208 F\nainA : \u27e8x\u271d, \u22ef\u27e9 \u2208 A\ny\u271d : \u03b1\nw\u271d : y\u271d \u2208 F\nbinA : \u27e8y\u271d, \u22ef\u27e9 \u2208 A\nanb : x\u271d \u2260 y\u271d\n\u22a2 G.Adj x\u271d y\u271d"}, {"line": "exact S.adj_sub (c ainA binA (Subtype.coe_ne_coe.mp anb)).2.2", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsClique.sdiff_of_sup_edge {v w : \u03b1} {s : Set \u03b1} (hc : (G \u2294 edge v w).IsClique s) :\n    G.IsClique (s \\ {v}) := by\n  intro _ hx _ hy hxy\n  have := hc hx.1 hy.1 hxy\n  simp_all [sup_adj, edge_adj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Clique.lean", "context": {"open": ["Finset Fintype Function SimpleGraph.Walk"], "variables": ["{\u03b1 \u03b2 : Type*} (G H : SimpleGraph \u03b1)", "{s t : Set \u03b1}", "{G H} {a b : \u03b1}", "{f : \u03b1 \u21aa \u03b2} {t : Finset \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nx\u271d : Sort u_3\nedge : x\u271d\nv w : \u03b1\ns : Set \u03b1\nhc : (G \u2294 sorry).IsClique s\n\u22a2 G.IsClique (s \\ {v})"}, {"line": "intro _ hx _ hy hxy", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nx\u271d\u00b9 : Sort u_3\nedge : x\u271d\u00b9\nv w : \u03b1\ns : Set \u03b1\nhc : (G \u2294 sorry).IsClique s\nx\u271d : \u03b1\nhx : x\u271d \u2208 s \\ {v}\ny\u271d : \u03b1\nhy : y\u271d \u2208 s \\ {v}\nhxy : x\u271d \u2260 y\u271d\n\u22a2 G.Adj x\u271d y\u271d"}, {"line": "have := hc hx.1 hy.1 hxy", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nx\u271d\u00b9 : Sort u_3\nedge : x\u271d\u00b9\nv w : \u03b1\ns : Set \u03b1\nhc : (G \u2294 sorry).IsClique s\nx\u271d : \u03b1\nhx : x\u271d \u2208 s \\ {v}\ny\u271d : \u03b1\nhy : y\u271d \u2208 s \\ {v}\nhxy : x\u271d \u2260 y\u271d\nthis : (G \u2294 sorry).Adj x\u271d y\u271d\n\u22a2 G.Adj x\u271d y\u271d"}, {"line": "simp_all [sup_adj, edge_adj]", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nx\u271d\u00b9 : Sort u_3\nedge : x\u271d\u00b9\nv w : \u03b1\ns : Set \u03b1\nx\u271d y\u271d : \u03b1\nhc : (G \u2294 sorry ()).IsClique s\nhx : x\u271d \u2208 s \u2227 \u00acx\u271d = v\nhy : y\u271d \u2208 s \u2227 \u00acy\u271d = v\nhxy : \u00acx\u271d = y\u271d\nthis : G.Adj x\u271d y\u271d \u2228 (sorry ()).Adj x\u271d y\u271d\n\u22a2 G.Adj x\u271d y\u271d"}]}
{"declaration": "lemma isClique_sup_edge_of_ne_sdiff {v w : \u03b1} {s : Set \u03b1} (h : v \u2260 w ) (hv : G.IsClique (s \\ {v}))\n    (hw : G.IsClique (s \\ {w})) : (G \u2294 edge v w).IsClique s := by\n  intro x hx y hy hxy\n  by_cases h' : x \u2208 s \\ {v} \u2227 y \u2208 s \\ {v} \u2228 x \u2208 s \\ {w} \u2227 y \u2208 s \\ {w}\n  \u00b7 obtain (\u27e8hx, hy\u27e9 | \u27e8hx, hy\u27e9) := h'\n    \u00b7 exact hv.mono le_sup_left hx hy hxy\n    \u00b7 exact hw.mono le_sup_left hx hy hxy\n  \u00b7 exact Or.inr \u27e8by by_cases x = v <;> aesop, hxy\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Clique.lean", "context": {"open": ["Finset Fintype Function SimpleGraph.Walk"], "variables": ["{\u03b1 \u03b2 : Type*} (G H : SimpleGraph \u03b1)", "{s t : Set \u03b1}", "{G H} {a b : \u03b1}", "{f : \u03b1 \u21aa \u03b2} {t : Finset \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nx\u271d : Sort u_3\nedge : x\u271d\nv w : \u03b1\ns : Set \u03b1\nh : v \u2260 w\nhv : G.IsClique (s \\ {v})\nhw : G.IsClique (s \\ {w})\n\u22a2 (G \u2294 sorry).IsClique s"}, {"line": "intro x hx y hy hxy", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nx\u271d : Sort u_3\nedge : x\u271d\nv w : \u03b1\ns : Set \u03b1\nh : v \u2260 w\nhv : G.IsClique (s \\ {v})\nhw : G.IsClique (s \\ {w})\nx : \u03b1\nhx : x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nhxy : x \u2260 y\n\u22a2 (G \u2294 sorry).Adj x y"}, {"line": "by_cases h' : x \u2208 s \\ {v} \u2227 y \u2208 s \\ {v} \u2228 x \u2208 s \\ {w} \u2227 y \u2208 s \\ {w}", "tactic_state": "case pos\n\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nx\u271d : Sort u_3\nedge : x\u271d\nv w : \u03b1\ns : Set \u03b1\nh : v \u2260 w\nhv : G.IsClique (s \\ {v})\nhw : G.IsClique (s \\ {w})\nx : \u03b1\nhx : x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nhxy : x \u2260 y\nh' : x \u2208 s \\ {v} \u2227 y \u2208 s \\ {v} \u2228 x \u2208 s \\ {w} \u2227 y \u2208 s \\ {w}\n\u22a2 (G \u2294 sorry).Adj x y\n---\ncase neg\n\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nx\u271d : Sort u_3\nedge : x\u271d\nv w : \u03b1\ns : Set \u03b1\nh : v \u2260 w\nhv : G.IsClique (s \\ {v})\nhw : G.IsClique (s \\ {w})\nx : \u03b1\nhx : x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nhxy : x \u2260 y\nh' : \u00ac(x \u2208 s \\ {v} \u2227 y \u2208 s \\ {v} \u2228 x \u2208 s \\ {w} \u2227 y \u2208 s \\ {w})\n\u22a2 (G \u2294 sorry).Adj x y"}, {"line": "\u00b7 obtain (\u27e8hx, hy\u27e9 | \u27e8hx, hy\u27e9) := h'\n    \u00b7 exact hv.mono le_sup_left hx hy hxy\n    \u00b7 exact hw.mono le_sup_left hx hy hxy", "tactic_state": "case neg\n\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nx\u271d : Sort u_3\nedge : x\u271d\nv w : \u03b1\ns : Set \u03b1\nh : v \u2260 w\nhv : G.IsClique (s \\ {v})\nhw : G.IsClique (s \\ {w})\nx : \u03b1\nhx : x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nhxy : x \u2260 y\nh' : \u00ac(x \u2208 s \\ {v} \u2227 y \u2208 s \\ {v} \u2228 x \u2208 s \\ {w} \u2227 y \u2208 s \\ {w})\n\u22a2 (G \u2294 sorry).Adj x y"}, {"line": "\u00b7 exact Or.inr \u27e8by by_cases x = v <;> aesop, hxy\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isNClique_singleton : G.IsNClique n {a} \u2194 n = 1 := by simp [isNClique_iff, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Clique.lean", "context": {"open": ["Finset Fintype Function SimpleGraph.Walk"], "variables": ["{\u03b1 \u03b2 : Type*} (G H : SimpleGraph \u03b1)", "{s t : Set \u03b1}", "{G H} {a b : \u03b1}", "{f : \u03b1 \u21aa \u03b2} {t : Finset \u03b2}", "{n : \u2115} {s : Finset \u03b1}", "{G H} {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\na : \u03b1\nn : \u2115\n\u22a2 G.IsNClique n {a} \u2194 n = 1"}, {"line": "simp [isNClique_iff, eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem CliqueFree.mono (h : m \u2264 n) : G.CliqueFree m \u2192 G.CliqueFree n := by\n  intro hG s hs\n  obtain \u27e8t, hts, ht\u27e9 := exists_subset_card_eq (h.trans hs.card_eq.ge)\n  exact hG _ \u27e8hs.isClique.subset hts, ht\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Clique.lean", "context": {"open": ["Finset Fintype Function SimpleGraph.Walk"], "variables": ["{\u03b1 \u03b2 : Type*} (G H : SimpleGraph \u03b1)", "{s t : Set \u03b1}", "{G H} {a b : \u03b1}", "{f : \u03b1 \u21aa \u03b2} {t : Finset \u03b2}", "{n : \u2115} {s : Finset \u03b1}", "{G H} {a b c : \u03b1}", "[DecidableEq \u03b1]", "{m n : \u2115}", "{G H} {s : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d : DecidableEq \u03b1\nm n : \u2115\nh : m \u2264 n\n\u22a2 G.CliqueFree m \u2192 G.CliqueFree n"}, {"line": "intro hG s hs", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d : DecidableEq \u03b1\nm n : \u2115\nh : m \u2264 n\nhG : G.CliqueFree m\ns : Finset \u03b1\nhs : G.IsNClique n s\n\u22a2 False"}, {"line": "obtain \u27e8t, hts, ht\u27e9 := exists_subset_card_eq (h.trans hs.card_eq.ge)", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d : DecidableEq \u03b1\nm n : \u2115\nh : m \u2264 n\nhG : G.CliqueFree m\ns : Finset \u03b1\nhs : G.IsNClique n s\nt : Finset \u03b1\nhts : t \u2286 s\nht : t.card = m\n\u22a2 False"}, {"line": "exact hG _ \u27e8hs.isClique.subset hts, ht\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cliqueFree_one : G.CliqueFree 1 \u2194 IsEmpty \u03b1 := by\n  simp [CliqueFree, isEmpty_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Clique.lean", "context": {"open": ["Finset Fintype Function SimpleGraph.Walk"], "variables": ["{\u03b1 \u03b2 : Type*} (G H : SimpleGraph \u03b1)", "{s t : Set \u03b1}", "{G H} {a b : \u03b1}", "{f : \u03b1 \u21aa \u03b2} {t : Finset \u03b2}", "{n : \u2115} {s : Finset \u03b1}", "{G H} {a b c : \u03b1}", "[DecidableEq \u03b1]", "{m n : \u2115}", "{G H} {s : Finset \u03b1}", "{\u03b9 : Type*} (V : \u03b9 \u2192 Type*)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 G.CliqueFree 1 \u2194 IsEmpty \u03b1"}, {"line": "simp [CliqueFree, isEmpty_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cliqueFreeOn_empty : G.CliqueFreeOn \u2205 n \u2194 n \u2260 0 := by\n  simp [CliqueFreeOn, Set.subset_empty_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Clique.lean", "context": {"open": ["Finset Fintype Function SimpleGraph.Walk", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*} (G H : SimpleGraph \u03b1)", "{s t : Set \u03b1}", "{G H} {a b : \u03b1}", "{f : \u03b1 \u21aa \u03b2} {t : Finset \u03b2}", "{n : \u2115} {s : Finset \u03b1}", "{G H} {a b c : \u03b1}", "[DecidableEq \u03b1]", "{m n : \u2115}", "{G H} {s : Finset \u03b1}", "{\u03b9 : Type*} (V : \u03b9 \u2192 Type*)", "{s s\u2081 s\u2082 : Set \u03b1} {a : \u03b1} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 sorry \u2194 n \u2260 0"}, {"line": "simp [CliqueFreeOn, Set.subset_empty_iff]", "tactic_state": "n : \u2115\n\u22a2 sorry () \u2194 \u00acn = 0"}]}
{"declaration": "theorem cliqueFreeOn_singleton : G.CliqueFreeOn {a} n \u2194 1 < n := by\n  obtain _ | _ | n := n <;>\n    simp [CliqueFreeOn, isNClique_iff, \u2190 subset_singleton_iff', (Nat.succ_ne_zero _).symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Clique.lean", "context": {"open": ["Finset Fintype Function SimpleGraph.Walk", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*} (G H : SimpleGraph \u03b1)", "{s t : Set \u03b1}", "{G H} {a b : \u03b1}", "{f : \u03b1 \u21aa \u03b2} {t : Finset \u03b2}", "{n : \u2115} {s : Finset \u03b1}", "{G H} {a b c : \u03b1}", "[DecidableEq \u03b1]", "{m n : \u2115}", "{G H} {s : Finset \u03b1}", "{\u03b9 : Type*} (V : \u03b9 \u2192 Type*)", "{s s\u2081 s\u2082 : Set \u03b1} {a : \u03b1} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 sorry \u2194 1 < n"}, {"line": "obtain _ | _ | n := n <;>\n    simp [CliqueFreeOn, isNClique_iff, \u2190 subset_singleton_iff', (Nat.succ_ne_zero _).symm]", "tactic_state": "case zero\n\u22a2 \u00acsorry ()\n---\ncase succ.zero\n\u22a2 \u00acsorry ()\n---\ncase succ.succ\nn : \u2115\n\u22a2 sorry ()"}]}
{"declaration": "theorem cliqueFreeOn_univ : G.CliqueFreeOn Set.univ n \u2194 G.CliqueFree n := by\n  simp [CliqueFree, CliqueFreeOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Clique.lean", "context": {"open": ["Finset Fintype Function SimpleGraph.Walk", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*} (G H : SimpleGraph \u03b1)", "{s t : Set \u03b1}", "{G H} {a b : \u03b1}", "{f : \u03b1 \u21aa \u03b2} {t : Finset \u03b2}", "{n : \u2115} {s : Finset \u03b1}", "{G H} {a b c : \u03b1}", "[DecidableEq \u03b1]", "{m n : \u2115}", "{G H} {s : Finset \u03b1}", "{\u03b9 : Type*} (V : \u03b9 \u2192 Type*)", "{s s\u2081 s\u2082 : Set \u03b1} {a : \u03b1} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry \u2194 sorry"}, {"line": "simp [CliqueFree, CliqueFreeOn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_cliqueFinset_le : #(G.cliqueFinset n) \u2264 (card \u03b1).choose n := by\n  rw [\u2190 card_univ]\n  rw [\u2190 card_powersetCard]\n  refine card_mono fun s => ?_\n  simpa [mem_powersetCard_univ] using IsNClique.card_eq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Clique.lean", "context": {"open": ["Finset Fintype Function SimpleGraph.Walk", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*} (G H : SimpleGraph \u03b1)", "{s t : Set \u03b1}", "{G H} {a b : \u03b1}", "{f : \u03b1 \u21aa \u03b2} {t : Finset \u03b2}", "{n : \u2115} {s : Finset \u03b1}", "{G H} {a b c : \u03b1}", "[DecidableEq \u03b1]", "{m n : \u2115}", "{G H} {s : Finset \u03b1}", "{\u03b9 : Type*} (V : \u03b9 \u2192 Type*)", "{s s\u2081 s\u2082 : Set \u03b1} {a : \u03b1} {m n : \u2115}", "{n : \u2115} {s : Finset \u03b1}", "{G H}", "{\u03b1 : Type*} {G : SimpleGraph \u03b1}", "[Fintype \u03b1] [DecidableEq \u03b1] [DecidableRel G.Adj] {n : \u2115} {s : Finset \u03b1}", "{G} in", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nG : SimpleGraph \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableRel G.Adj\nn : \u2115\n\u22a2 (G.cliqueFinset n).card \u2264 (Fintype.card \u03b1).choose n"}, {"line": "rw [\u2190 card_univ]", "tactic_state": "\u03b1 : Type u_3\nG : SimpleGraph \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableRel G.Adj\nn : \u2115\n\u22a2 (G.cliqueFinset n).card \u2264 univ.card.choose n"}, {"line": "rw [\u2190 card_powersetCard]", "tactic_state": "\u03b1 : Type u_3\nG : SimpleGraph \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableRel G.Adj\nn : \u2115\n\u22a2 (G.cliqueFinset n).card \u2264 (powersetCard n univ).card"}, {"line": "refine card_mono fun s => ?_", "tactic_state": "\u03b1 : Type u_3\nG : SimpleGraph \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableRel G.Adj\nn : \u2115\ns : Finset \u03b1\n\u22a2 s \u2208 G.cliqueFinset n \u2192 s \u2208 powersetCard n univ"}, {"line": "simpa [mem_powersetCard_univ] using IsNClique.card_eq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isIndepSet_induce {F : Set \u03b1} {s : Set F} :\n    ((\u22a4 : Subgraph G).induce F).coe.IsIndepSet s \u2194 G.IsIndepSet (Subtype.val '' s) := by\n  simp [Set.Pairwise]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Clique.lean", "context": {"open": ["Finset Fintype Function SimpleGraph.Walk", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*} (G H : SimpleGraph \u03b1)", "{s t : Set \u03b1}", "{G H} {a b : \u03b1}", "{f : \u03b1 \u21aa \u03b2} {t : Finset \u03b2}", "{n : \u2115} {s : Finset \u03b1}", "{G H} {a b c : \u03b1}", "[DecidableEq \u03b1]", "{m n : \u2115}", "{G H} {s : Finset \u03b1}", "{\u03b9 : Type*} (V : \u03b9 \u2192 Type*)", "{s s\u2081 s\u2082 : Set \u03b1} {a : \u03b1} {m n : \u2115}", "{n : \u2115} {s : Finset \u03b1}", "{G H}", "{\u03b1 : Type*} {G : SimpleGraph \u03b1}", "[Fintype \u03b1] [DecidableEq \u03b1] [DecidableRel G.Adj] {n : \u2115} {s : Finset \u03b1}", "{G} in", "{G}", "[DecidableRel H.Adj]", "[Fintype \u03b2] [DecidableEq \u03b2] (G)", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nG : SimpleGraph \u03b1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableRel sorry\nx\u271d : Sort u_4\nSubgraph : x\u271d\nF : Set \u03b1\ns : Set \u2191F\n\u22a2 sorry \u2194 G.IsIndepSet (Subtype.val '' s)"}, {"line": "simp [Set.Pairwise]", "tactic_state": "\u03b1 : Type u_3\nG : SimpleGraph \u03b1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableRel sorry\nx\u271d : Sort u_4\nSubgraph : x\u271d\nF : Set \u03b1\ns : Set \u2191F\n\u22a2 sorry () \u2194 \u2200 \u2983x : \u03b1\u2984 (x_1 : x \u2208 F), \u27e8x, \u22ef\u27e9 \u2208 s \u2192 \u2200 \u2983y : \u03b1\u2984 (x_2 : y \u2208 F), \u27e8y, \u22ef\u27e9 \u2208 s \u2192 \u00acx = y \u2192 \u00acG.Adj x y"}]}
{"declaration": "theorem isNIndepSet_induce {F : Set \u03b1} {s : Finset { x // x \u2208 F }} {n : \u2115} :\n    ((\u22a4 : Subgraph G).induce F).coe.IsNIndepSet n \u2191s \u2194\n    G.IsNIndepSet n (Finset.map \u27e8Subtype.val, Subtype.val_injective\u27e9 s) := by\n  simp [isNIndepSet_iff, (isIndepSet_induce)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Clique.lean", "context": {"open": ["Finset Fintype Function SimpleGraph.Walk", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*} (G H : SimpleGraph \u03b1)", "{s t : Set \u03b1}", "{G H} {a b : \u03b1}", "{f : \u03b1 \u21aa \u03b2} {t : Finset \u03b2}", "{n : \u2115} {s : Finset \u03b1}", "{G H} {a b c : \u03b1}", "[DecidableEq \u03b1]", "{m n : \u2115}", "{G H} {s : Finset \u03b1}", "{\u03b9 : Type*} (V : \u03b9 \u2192 Type*)", "{s s\u2081 s\u2082 : Set \u03b1} {a : \u03b1} {m n : \u2115}", "{n : \u2115} {s : Finset \u03b1}", "{G H}", "{\u03b1 : Type*} {G : SimpleGraph \u03b1}", "[Fintype \u03b1] [DecidableEq \u03b1] [DecidableRel G.Adj] {n : \u2115} {s : Finset \u03b1}", "{G} in", "{G}", "[DecidableRel H.Adj]", "[Fintype \u03b2] [DecidableEq \u03b2] (G)", "{s : Set \u03b1}", "{n : \u2115} {s : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nG : SimpleGraph \u03b1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableRel sorry\nx\u271d : Sort u_4\nSubgraph : x\u271d\nF : Set \u03b1\ns : Finset { x // x \u2208 F }\nn : \u2115\n\u22a2 sorry \u2194 G.IsNIndepSet n (map { toFun := Subtype.val, inj' := \u22ef } s)"}, {"line": "simp [isNIndepSet_iff, (isIndepSet_induce)]", "tactic_state": "\u03b1 : Type u_3\nG : SimpleGraph \u03b1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableRel sorry\nx\u271d : Sort u_4\nSubgraph : x\u271d\nF : Set \u03b1\ns : Finset { x // x \u2208 F }\nn : \u2115\n\u22a2 sorry () \u2194 G.IsNIndepSet n (map { toFun := Subtype.val, inj' := \u22ef } s)"}]}
{"declaration": "theorem isEmpty_of_colorable_zero (h : G.Colorable 0) : IsEmpty V := by\n  constructor\n  intro v\n  obtain \u27e8i, hi\u27e9 := h.some v\n  exact Nat.not_lt_zero _ hi\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Coloring.lean", "context": {"open": ["Fintype Function"], "variables": ["{V : Type u} (G : SimpleGraph V) {n : \u2115}", "{G}", "{\u03b1 \u03b2 : Type*} (C : G.Coloring \u03b1)", "(G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nh : G.Colorable 0\n\u22a2 IsEmpty V"}, {"line": "constructor", "tactic_state": "case false\nV : Type u\nG : SimpleGraph V\nh : G.Colorable 0\n\u22a2 V \u2192 False"}, {"line": "intro v", "tactic_state": "case false\nV : Type u\nG : SimpleGraph V\nh : G.Colorable 0\nv : V\n\u22a2 False"}, {"line": "obtain \u27e8i, hi\u27e9 := h.some v", "tactic_state": "case false.mk\nV : Type u\nG : SimpleGraph V\nh : G.Colorable 0\nv : V\ni : \u2115\nhi : i < 0\n\u22a2 False"}, {"line": "exact Nat.not_lt_zero _ hi", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Colorable.chromaticNumber_le {n : \u2115} (hc : G.Colorable n) : G.chromaticNumber \u2264 n := by\n  rw [hc.chromaticNumber_eq_sInf]\n  norm_cast\n  apply csInf_le chromaticNumber_bddBelow\n  exact hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Coloring.lean", "context": {"open": ["Fintype Function"], "variables": ["{V : Type u} (G : SimpleGraph V) {n : \u2115}", "{G}", "{\u03b1 \u03b2 : Type*} (C : G.Coloring \u03b1)", "(G)", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nn : \u2115\nhc : G.Colorable n\n\u22a2 G.chromaticNumber \u2264 \u2191n"}, {"line": "rw [hc.chromaticNumber_eq_sInf]", "tactic_state": "V : Type u\nG : SimpleGraph V\nn : \u2115\nhc : G.Colorable n\n\u22a2 \u2191(sInf {n' | G.Colorable n'}) \u2264 \u2191n"}, {"line": "norm_cast", "tactic_state": "V : Type u\nG : SimpleGraph V\nn : \u2115\nhc : G.Colorable n\n\u22a2 sInf {n' | G.Colorable n'} \u2264 n"}, {"line": "apply csInf_le chromaticNumber_bddBelow", "tactic_state": "V : Type u\nG : SimpleGraph V\nn : \u2115\nhc : G.Colorable n\n\u22a2 n \u2208 {n' | G.Colorable n'}"}, {"line": "exact hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isEmpty_of_chromaticNumber_eq_zero (G : SimpleGraph V) [Finite V]\n    (h : G.chromaticNumber = 0) : IsEmpty V := by\n  have h' := G.colorable_chromaticNumber_of_fintype\n  rw [h] at h'\n  exact G.isEmpty_of_colorable_zero h'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Coloring.lean", "context": {"open": ["Fintype Function"], "variables": ["{V : Type u} (G : SimpleGraph V) {n : \u2115}", "{G}", "{\u03b1 \u03b2 : Type*} (C : G.Coloring \u03b1)", "(G)", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : Finite V\nh : G.chromaticNumber = 0\n\u22a2 IsEmpty V"}, {"line": "have h' := G.colorable_chromaticNumber_of_fintype", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : Finite V\nh : G.chromaticNumber = 0\nh' : G.Colorable G.chromaticNumber.toNat\n\u22a2 IsEmpty V"}, {"line": "rw [h] at h'", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : Finite V\nh : G.chromaticNumber = 0\nh' : G.Colorable (ENat.toNat 0)\n\u22a2 IsEmpty V"}, {"line": "exact G.isEmpty_of_colorable_zero h'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem chromaticNumber_bot [Nonempty V] : (\u22a5 : SimpleGraph V).chromaticNumber = 1 := by\n  have : (\u22a5 : SimpleGraph V).Colorable 1 := \u27e8.mk 0 <| by simp\u27e9\n  exact this.chromaticNumber_le.antisymm <| Order.one_le_iff_pos.2 <| chromaticNumber_pos this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Coloring.lean", "context": {"open": ["Fintype Function"], "variables": ["{V : Type u} (G : SimpleGraph V) {n : \u2115}", "{G}", "{\u03b1 \u03b2 : Type*} (C : G.Coloring \u03b1)", "(G)", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d : Nonempty V\n\u22a2 \u22a5.chromaticNumber = 1"}, {"line": "have : (\u22a5 : SimpleGraph V).Colorable 1 := \u27e8.mk 0 <| by simp\u27e9", "tactic_state": "V : Type u\ninst\u271d : Nonempty V\nthis : \u22a5.Colorable 1\n\u22a2 \u22a5.chromaticNumber = 1"}, {"line": "exact this.chromaticNumber_le.antisymm <| Order.one_le_iff_pos.2 <| chromaticNumber_pos this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsClique.card_le_of_colorable {s : Finset V} (h : G.IsClique s) {n : \u2115}\n    (hc : G.Colorable n) : s.card \u2264 n := by\n  convert h.card_le_of_coloring hc.some\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Coloring.lean", "context": {"open": ["Fintype Function"], "variables": ["{V : Type u} (G : SimpleGraph V) {n : \u2115}", "{G}", "{\u03b1 \u03b2 : Type*} (C : G.Coloring \u03b1)", "(G)", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ns : Finset V\nh : G.IsClique \u2191s\nn : \u2115\nhc : G.Colorable n\n\u22a2 s.card \u2264 n"}, {"line": "convert h.card_le_of_coloring hc.some", "tactic_state": "case h.e'_4\nV : Type u\nG : SimpleGraph V\ns : Finset V\nh : G.IsClique \u2191s\nn : \u2115\nhc : G.Colorable n\n\u22a2 n = card (Fin n)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem chromaticNumber [Fintype \u03b9] (f : \u2200 (i : \u03b9), V i) :\n    (completeMultipartiteGraph V).chromaticNumber = Fintype.card \u03b9 := by\n  apply le_antisymm (colorable V).chromaticNumber_le\n  by_contra! h\n  exact not_cliqueFree_of_le_card V f le_rfl <| cliqueFree_of_chromaticNumber_lt h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Coloring.lean", "context": {"open": ["Fintype Function"], "variables": ["{V : Type u} (G : SimpleGraph V) {n : \u2115}", "{G}", "{\u03b1 \u03b2 : Type*} (C : G.Coloring \u03b1)", "(G)", "{G}", "{\u03b9 : Type*} (V : \u03b9 \u2192 Type*)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_3\nV : \u03b9 \u2192 Type u_4\nx\u271d : Sort u_5\ncompleteMultipartiteGraph : x\u271d\ninst\u271d : Fintype \u03b9\nf : (i : \u03b9) \u2192 V i\n\u22a2 sorry = card \u03b9"}, {"line": "apply le_antisymm (colorable V).chromaticNumber_le", "tactic_state": "\u03b9 : Type u_3\nV : \u03b9 \u2192 Type u_4\nx\u271d : Sort u_5\ncompleteMultipartiteGraph : x\u271d\ninst\u271d : Fintype \u03b9\nf : (i : \u03b9) \u2192 V i\n\u22a2 card \u03b9 \u2264 sorry"}, {"line": "by_contra! h", "tactic_state": "case refine_1\n\u03b9 : Type u_3\nV : \u03b9 \u2192 Type u_4\nx\u271d : Sort u_5\ncompleteMultipartiteGraph : x\u271d\ninst\u271d : Fintype \u03b9\nf : (i : \u03b9) \u2192 V i\n\u22a2 Decidable (card \u03b9 \u2264 sorry)\n---\ncase refine_2\n\u03b9 : Type u_3\nV : \u03b9 \u2192 Type u_4\nx\u271d : Sort u_5\ncompleteMultipartiteGraph : x\u271d\ninst\u271d : Fintype \u03b9\nf : (i : \u03b9) \u2192 V i\nh : \u00accard \u03b9 \u2264 sorry\n\u22a2 False"}, {"line": "exact not_cliqueFree_of_le_card V f le_rfl <| cliqueFree_of_chromaticNumber_lt h", "tactic_state": "case refine_2\n\u03b9 : Type u_3\nV : \u03b9 \u2192 Type u_4\nx\u271d : Sort u_5\ncompleteMultipartiteGraph : x\u271d\ninst\u271d : Fintype \u03b9\nf : (i : \u03b9) \u2192 V i\nh : \u00accard \u03b9 \u2264 sorry\n\u22a2 False"}]}
{"declaration": "theorem two_le_chromaticNumber_of_adj {\u03b1} {G : SimpleGraph \u03b1} {u v : \u03b1} (hadj : G.Adj u v) :\n    2 \u2264 G.chromaticNumber := by\n  refine le_of_not_lt ?_\n  intro h\n  have hc : G.Colorable 1 := chromaticNumber_le_iff_colorable.mp (Order.le_of_lt_add_one h)\n  let c : G.Coloring (Fin 1) := hc.some\n  exact c.valid hadj (Subsingleton.elim (c u) (c v))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/ConcreteColorings.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nu v : \u03b1\nhadj : G.Adj u v\n\u22a2 2 \u2264 G.chromaticNumber"}, {"line": "refine le_of_not_lt ?_", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nu v : \u03b1\nhadj : G.Adj u v\n\u22a2 \u00acG.chromaticNumber < 2"}, {"line": "intro h", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nu v : \u03b1\nhadj : G.Adj u v\nh : G.chromaticNumber < 2\n\u22a2 False"}, {"line": "have hc : G.Colorable 1 := chromaticNumber_le_iff_colorable.mp (Order.le_of_lt_add_one h)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nu v : \u03b1\nhadj : G.Adj u v\nh : G.chromaticNumber < 2\nhc : G.Colorable 1\n\u22a2 False"}, {"line": "let c : G.Coloring (Fin 1) := hc.some", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nu v : \u03b1\nhadj : G.Adj u v\nh : G.chromaticNumber < 2\nhc : G.Colorable 1\nc : G.Coloring (Fin 1) := Nonempty.some hc\n\u22a2 False"}, {"line": "exact c.valid hadj (Subsingleton.elim (c u) (c v))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Coloring.odd_length_iff_not_congr {\u03b1} {G : SimpleGraph \u03b1}\n    (c : G.Coloring Bool) {u v : \u03b1} (p : G.Walk u v) :\n    Odd p.length \u2194 (\u00acc u \u2194 c v) := by\n  rw [\u2190 Nat.not_even_iff_odd]\n  rw [c.even_length_iff_congr p]\n  tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/ConcreteColorings.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nc : G.Coloring Bool\nu v : \u03b1\np : G.Walk u v\n\u22a2 Odd p.length \u2194 (\u00acc u = true \u2194 c v = true)"}, {"line": "rw [\u2190 Nat.not_even_iff_odd]", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nc : G.Coloring Bool\nu v : \u03b1\np : G.Walk u v\n\u22a2 \u00acEven p.length \u2194 (\u00acc u = true \u2194 c v = true)"}, {"line": "rw [c.even_length_iff_congr p]", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nc : G.Coloring Bool\nu v : \u03b1\np : G.Walk u v\n\u22a2 \u00ac(c u = true \u2194 c v = true) \u2194 (\u00acc u = true \u2194 c v = true)"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma Free.killCopies_eq_left (hHG : H.Free G) : G.killCopies H = G := by\n  obtain rfl | hH := eq_or_ne H \u22a5\n  \u00b7 exact killCopies_bot _\n  \u00b7 exact (killCopies_eq_left hH).2 hHG\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Copy.lean", "context": {"open": ["Finset Function", "Fintype (card)"], "variables": ["{V W X \u03b1 \u03b2 \u03b3 : Type*} {G G\u2081 G\u2082 G\u2083 : SimpleGraph V} {H : SimpleGraph W} {I : SimpleGraph X}", "[Fintype V] [Fintype W]", "[Fintype V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nH : SimpleGraph W\ninst\u271d\u00b2 : Fintype V\ninst\u271d\u00b9 : Fintype W\ninst\u271d : Fintype V\nhHG : H.Free G\n\u22a2 G.killCopies H = G"}, {"line": "obtain rfl | hH := eq_or_ne H \u22a5", "tactic_state": "case inl\nV : Type u_1\nW : Type u_2\nG : SimpleGraph V\ninst\u271d\u00b2 : Fintype V\ninst\u271d\u00b9 : Fintype W\ninst\u271d : Fintype V\nhHG : \u22a5.Free G\n\u22a2 G.killCopies \u22a5 = G\n---\ncase inr\nV : Type u_1\nW : Type u_2\nG : SimpleGraph V\nH : SimpleGraph W\ninst\u271d\u00b2 : Fintype V\ninst\u271d\u00b9 : Fintype W\ninst\u271d : Fintype V\nhHG : H.Free G\nhH : H \u2260 \u22a5\n\u22a2 G.killCopies H = G"}, {"line": "\u00b7 exact killCopies_bot _", "tactic_state": "case inr\nV : Type u_1\nW : Type u_2\nG : SimpleGraph V\nH : SimpleGraph W\ninst\u271d\u00b2 : Fintype V\ninst\u271d\u00b9 : Fintype W\ninst\u271d : Fintype V\nhHG : H.Free G\nhH : H \u2260 \u22a5\n\u22a2 G.killCopies H = G"}, {"line": "\u00b7 exact (killCopies_eq_left hH).2 hHG", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dart_edge_eq_iff : \u2200 d\u2081 d\u2082 : G.Dart, d\u2081.edge = d\u2082.edge \u2194 d\u2081 = d\u2082 \u2228 d\u2081 = d\u2082.symm := by\n  rintro \u27e8p, hp\u27e9 \u27e8q, hq\u27e9\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Dart.lean", "context": {"open": [], "variables": ["{V : Type*} (G : SimpleGraph V)", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\n\u22a2 \u2200 (d\u2081 d\u2082 : G.Dart), d\u2081.edge = d\u2082.edge \u2194 d\u2081 = d\u2082 \u2228 d\u2081 = d\u2082.symm"}, {"line": "rintro \u27e8p, hp\u27e9 \u27e8q, hq\u27e9", "tactic_state": "case mk.mk\nV : Type u_1\nG : SimpleGraph V\np : V \u00d7 V\nhp : G.Adj p.1 p.2\nq : V \u00d7 V\nhq : G.Adj q.1 q.2\n\u22a2 { toProd := p, adj := hp }.edge = { toProd := q, adj := hq }.edge \u2194\n    { toProd := p, adj := hp } = { toProd := q, adj := hq } \u2228\n      { toProd := p, adj := hp } = { toProd := q, adj := hq }.symm"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dart_fst_fiber_card_eq_degree [DecidableEq V] (v : V) :\n    #{d : G.Dart | d.fst = v} = G.degree v := by\n  simpa only [dart_fst_fiber,Finset.card_univ,card_neighborSet_eq_degree] using\n    card_image_of_injective univ (G.dartOfNeighborSet_injective v)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/DegreeSum.lean", "context": {"open": ["Finset"], "variables": ["{V : Type u} (G : SimpleGraph V)", "[Fintype V] [DecidableRel G.Adj]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d\u00b2 : Fintype V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\nv : V\n\u22a2 {d | d.toProd.1 = v}.card = G.degree v"}, {"line": "simpa only [dart_fst_fiber,Finset.card_univ,card_neighborSet_eq_degree] using\n    card_image_of_injective univ (G.dartOfNeighborSet_injective v)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deleteEdges_deleteEdges (s s' : Set (Sym2 V)) :\n    (G.deleteEdges s).deleteEdges s' = G.deleteEdges (s \u222a s') := by simp [deleteEdges, sdiff_sdiff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/DeleteEdges.lean", "context": {"open": ["Finset Fintype"], "variables": ["{V : Type*} {v w : V} (G : SimpleGraph V)", "{G} {H : SimpleGraph V} {s s\u2081 s\u2082 : Set (Sym2 V)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ns s' : Set (Sym2 V)\n\u22a2 (G.deleteEdges s).deleteEdges s' = G.deleteEdges (s \u222a s')"}, {"line": "simp [deleteEdges, sdiff_sdiff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deleteEdges_eq_inter_edgeSet (s : Set (Sym2 V)) :\n    G.deleteEdges s = G.deleteEdges (s \u2229 G.edgeSet) := by\n  ext\n  simp +contextual [imp_false]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/DeleteEdges.lean", "context": {"open": ["Finset Fintype"], "variables": ["{V : Type*} {v w : V} (G : SimpleGraph V)", "{G} {H : SimpleGraph V} {s s\u2081 s\u2082 : Set (Sym2 V)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ns : Set (Sym2 V)\n\u22a2 G.deleteEdges s = G.deleteEdges (s \u2229 G.edgeSet)"}, {"line": "ext", "tactic_state": "case Adj.h.h.a\nV : Type u_1\nG : SimpleGraph V\ns : Set (Sym2 V)\nx\u271d\u00b9 x\u271d : V\n\u22a2 (G.deleteEdges s).Adj x\u271d\u00b9 x\u271d \u2194 (G.deleteEdges (s \u2229 G.edgeSet)).Adj x\u271d\u00b9 x\u271d"}, {"line": "simp +contextual [imp_false]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edgeFinset_deleteEdges [DecidableEq V] [Fintype G.edgeSet] (s : Finset (Sym2 V))\n    [Fintype (G.deleteEdges s).edgeSet] :\n    (G.deleteEdges s).edgeFinset = G.edgeFinset \\ s := by\n  ext e\n  simp [edgeSet_deleteEdges]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/DeleteEdges.lean", "context": {"open": ["Finset Fintype"], "variables": ["{V : Type*} {v w : V} (G : SimpleGraph V)", "{G} {H : SimpleGraph V} {s s\u2081 s\u2082 : Set (Sym2 V)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : Fintype \u2191G.edgeSet\ns : Finset (Sym2 V)\ninst\u271d : Fintype \u2191(G.deleteEdges \u2191s).edgeSet\n\u22a2 (G.deleteEdges \u2191s).edgeFinset = G.edgeFinset \\ s"}, {"line": "ext e", "tactic_state": "case h\nV : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : Fintype \u2191G.edgeSet\ns : Finset (Sym2 V)\ninst\u271d : Fintype \u2191(G.deleteEdges \u2191s).edgeSet\ne : Sym2 V\n\u22a2 e \u2208 (G.deleteEdges \u2191s).edgeFinset \u2194 e \u2208 G.edgeFinset \\ s"}, {"line": "simp [edgeSet_deleteEdges]", "tactic_state": "case h\nV : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : Fintype \u2191G.edgeSet\ns : Finset (Sym2 V)\ninst\u271d : Fintype \u2191(G.deleteEdges \u2191s).edgeSet\ne : Sym2 V\n\u22a2 e \u2208 (G.deleteEdges \u2191s).edgeSet \u2194 e \u2208 G.edgeSet \u2227 e \u2209 s"}]}
{"declaration": "lemma eccent_eq_zero_iff (u : \u03b1) : G.eccent u = 0 \u2194 Subsingleton \u03b1 := by\n  refine \u27e8fun h \u21a6 ?_, fun _ \u21a6 eccent_eq_zero_of_subsingleton u\u27e9\n  contrapose! h\n  rw [not_subsingleton_iff_nontrivial] at h\n  exact eccent_ne_zero u\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Diam.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {G G' : SimpleGraph \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nu : \u03b1\n\u22a2 G.eccent u = 0 \u2194 Subsingleton \u03b1"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun _ \u21a6 eccent_eq_zero_of_subsingleton u\u27e9", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nu : \u03b1\nh : G.eccent u = 0\n\u22a2 Subsingleton \u03b1"}, {"line": "contrapose! h", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nu : \u03b1\nh : \u00acSubsingleton \u03b1\n\u22a2 G.eccent u \u2260 0"}, {"line": "rw [not_subsingleton_iff_nontrivial] at h", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nu : \u03b1\nh : Nontrivial \u03b1\n\u22a2 G.eccent u \u2260 0"}, {"line": "exact eccent_ne_zero u", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nontrivial_of_ediam_ne_zero (h : G.ediam \u2260 0) : Nontrivial \u03b1 := by\n  contrapose! h\n  rw [not_nontrivial_iff_subsingleton] at h\n  exact ediam_eq_zero_of_subsingleton\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Diam.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {G G' : SimpleGraph \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nh : G.ediam \u2260 0\n\u22a2 Nontrivial \u03b1"}, {"line": "contrapose! h", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nh : \u00acNontrivial \u03b1\n\u22a2 G.ediam = 0"}, {"line": "rw [not_nontrivial_iff_subsingleton] at h", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nh : Subsingleton \u03b1\n\u22a2 G.ediam = 0"}, {"line": "exact ediam_eq_zero_of_subsingleton", "tactic_state": "No Goals!"}]}
{"declaration": "lemma subsingleton_of_ediam_eq_zero (h : G.ediam = 0) : Subsingleton \u03b1 := by\n  contrapose! h\n  apply not_subsingleton_iff_nontrivial.mp at h\n  exact ediam_ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Diam.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {G G' : SimpleGraph \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nh : G.ediam = 0\n\u22a2 Subsingleton \u03b1"}, {"line": "contrapose! h", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nh : \u00acSubsingleton \u03b1\n\u22a2 G.ediam \u2260 0"}, {"line": "apply not_subsingleton_iff_nontrivial.mp at h", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nh : Nontrivial \u03b1\n\u22a2 G.ediam \u2260 0"}, {"line": "exact ediam_ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nontrivial_of_diam_ne_zero (h : G.diam \u2260 0) : Nontrivial \u03b1 := by\n  apply G.nontrivial_of_ediam_ne_zero\n  contrapose! h\n  simp [diam, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Diam.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {G G' : SimpleGraph \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nh : G.diam \u2260 0\n\u22a2 Nontrivial \u03b1"}, {"line": "apply G.nontrivial_of_ediam_ne_zero", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nh : G.diam \u2260 0\n\u22a2 G.ediam \u2260 0"}, {"line": "contrapose! h", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nh : G.ediam = 0\n\u22a2 G.diam = 0"}, {"line": "simp [diam, h]", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nh : G.ediam = 0\n\u22a2 Subsingleton \u03b1"}]}
{"declaration": "lemma diam_eq_zero_of_not_connected (h : \u00ac G.Connected) : G.diam = 0 := by\n  cases isEmpty_or_nonempty \u03b1\n  \u00b7 rw [diam, ediam, ciSup_of_empty, bot_eq_zero']; rfl\n  \u00b7 rw [diam, ediam_eq_top_of_not_connected h, ENat.toNat_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Diam.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {G G' : SimpleGraph \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nh : \u00acG.Connected\n\u22a2 G.diam = 0"}, {"line": "cases isEmpty_or_nonempty \u03b1", "tactic_state": "case inl\n\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nh : \u00acG.Connected\nh\u271d : IsEmpty \u03b1\n\u22a2 G.diam = 0\n---\ncase inr\n\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nh : \u00acG.Connected\nh\u271d : Nonempty \u03b1\n\u22a2 G.diam = 0"}, {"line": "\u00b7 rw [diam, ediam, ciSup_of_empty, bot_eq_zero']; rfl", "tactic_state": "case inr\n\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nh : \u00acG.Connected\nh\u271d : Nonempty \u03b1\n\u22a2 G.diam = 0"}, {"line": "\u00b7 rw [diam, ediam_eq_top_of_not_connected h, ENat.toNat_top]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_dist_eq_diam [Nonempty \u03b1] :\n    \u2203 u v, G.dist u v = G.diam := by\n  by_cases h : G.diam = 0\n  \u00b7 simp [h]\n  \u00b7 obtain \u27e8u, v, huv\u27e9 := exists_edist_eq_ediam_of_ne_top <| ediam_ne_top_of_diam_ne_zero h\n    use u, v\n    rw [diam]\n    rw [dist]\n    rw [congrArg ENat.toNat huv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Diam.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {G G' : SimpleGraph \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2203 u v, G.dist u v = G.diam"}, {"line": "by_cases h : G.diam = 0", "tactic_state": "case pos\n\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d : Nonempty \u03b1\nh : G.diam = 0\n\u22a2 \u2203 u v, G.dist u v = G.diam\n---\ncase neg\n\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d : Nonempty \u03b1\nh : \u00acG.diam = 0\n\u22a2 \u2203 u v, G.dist u v = G.diam"}, {"line": "\u00b7 simp [h]", "tactic_state": "case neg\n\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d : Nonempty \u03b1\nh : \u00acG.diam = 0\n\u22a2 \u2203 u v, G.dist u v = G.diam"}, {"line": "\u00b7 obtain \u27e8u, v, huv\u27e9 := exists_edist_eq_ediam_of_ne_top <| ediam_ne_top_of_diam_ne_zero h\n    use u, v\n    rw [diam]\n    rw [dist]\n    rw [congrArg ENat.toNat huv]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma diam_eq_zero_iff_ediam_eq_top [Nontrivial \u03b1] : G.diam = 0 \u2194 G.ediam = \u22a4 := by\n  rw [\u2190 not_iff_not]\n  exact \u27e8ediam_ne_top_of_diam_ne_zero, diam_ne_zero_of_ediam_ne_top\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Diam.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {G G' : SimpleGraph \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d : Nontrivial \u03b1\n\u22a2 G.diam = 0 \u2194 G.ediam = \u22a4"}, {"line": "rw [\u2190 not_iff_not]", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d : Nontrivial \u03b1\n\u22a2 \u00acG.diam = 0 \u2194 \u00acG.ediam = \u22a4"}, {"line": "exact \u27e8ediam_ne_top_of_diam_ne_zero, diam_ne_zero_of_ediam_ne_top\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma radius_ne_zero_of_nontrivial [Nontrivial \u03b1] : G.radius \u2260 0 := by\n  rw [\u2190 ENat.one_le_iff_ne_zero]\n  apply le_iInf\n  simp [ENat.one_le_iff_ne_zero, G.eccent_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Diam.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {G G' : SimpleGraph \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d : Nontrivial \u03b1\n\u22a2 G.radius \u2260 0"}, {"line": "rw [\u2190 ENat.one_le_iff_ne_zero]", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d : Nontrivial \u03b1\n\u22a2 1 \u2264 G.radius"}, {"line": "apply le_iInf", "tactic_state": "case h\n\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d : Nontrivial \u03b1\n\u22a2 \u2200 (i : \u03b1), 1 \u2264 G.eccent i"}, {"line": "simp [ENat.one_le_iff_ne_zero, G.eccent_ne_zero]", "tactic_state": "case h\n\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d : Nontrivial \u03b1\n\u22a2 \u2200 (i : \u03b1), \u00acG.eccent i = 0"}]}
{"declaration": "theorem edgeFinset_inj : G\u2081.edgeFinset = G\u2082.edgeFinset \u2194 G\u2081 = G\u2082 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Finite.lean", "context": {"open": ["Finset Function"], "variables": ["{V : Type*} (G : SimpleGraph V) {e : Sym2 V}", "{G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG\u2081 G\u2082 : SimpleGraph V\ninst\u271d\u00b9 : Fintype \u2191G\u2081.edgeSet\ninst\u271d : Fintype \u2191G\u2082.edgeSet\n\u22a2 G\u2081.edgeFinset = G\u2082.edgeFinset \u2194 G\u2081 = G\u2082"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edgeFinset_subset_edgeFinset : G\u2081.edgeFinset \u2286 G\u2082.edgeFinset \u2194 G\u2081 \u2264 G\u2082 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Finite.lean", "context": {"open": ["Finset Function"], "variables": ["{V : Type*} (G : SimpleGraph V) {e : Sym2 V}", "{G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG\u2081 G\u2082 : SimpleGraph V\ninst\u271d\u00b9 : Fintype \u2191G\u2081.edgeSet\ninst\u271d : Fintype \u2191G\u2082.edgeSet\n\u22a2 G\u2081.edgeFinset \u2286 G\u2082.edgeFinset \u2194 G\u2081 \u2264 G\u2082"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edgeFinset_ssubset_edgeFinset : G\u2081.edgeFinset \u2282 G\u2082.edgeFinset \u2194 G\u2081 < G\u2082 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Finite.lean", "context": {"open": ["Finset Function"], "variables": ["{V : Type*} (G : SimpleGraph V) {e : Sym2 V}", "{G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG\u2081 G\u2082 : SimpleGraph V\ninst\u271d\u00b9 : Fintype \u2191G\u2081.edgeSet\ninst\u271d : Fintype \u2191G\u2082.edgeSet\n\u22a2 G\u2081.edgeFinset \u2282 G\u2082.edgeFinset \u2194 G\u2081 < G\u2082"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edgeFinset_bot : (\u22a5 : SimpleGraph V).edgeFinset = \u2205 := by simp [edgeFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Finite.lean", "context": {"open": ["Finset Function"], "variables": ["{V : Type*} (G : SimpleGraph V) {e : Sym2 V}", "{G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\n\u22a2 \u22a5.edgeFinset = \u2205"}, {"line": "simp [edgeFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edgeFinset_inf [DecidableEq V] : (G\u2081 \u2293 G\u2082).edgeFinset = G\u2081.edgeFinset \u2229 G\u2082.edgeFinset := by\n  simp [edgeFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Finite.lean", "context": {"open": ["Finset Function"], "variables": ["{V : Type*} (G : SimpleGraph V) {e : Sym2 V}", "{G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG\u2081 G\u2082 : SimpleGraph V\ninst\u271d\u00b2 : Fintype \u2191G\u2081.edgeSet\ninst\u271d\u00b9 : Fintype \u2191G\u2082.edgeSet\ninst\u271d : DecidableEq V\n\u22a2 (G\u2081 \u2293 G\u2082).edgeFinset = G\u2081.edgeFinset \u2229 G\u2082.edgeFinset"}, {"line": "simp [edgeFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edgeFinset_sdiff [DecidableEq V] :\n    (G\u2081 \\ G\u2082).edgeFinset = G\u2081.edgeFinset \\ G\u2082.edgeFinset := by simp [edgeFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Finite.lean", "context": {"open": ["Finset Function"], "variables": ["{V : Type*} (G : SimpleGraph V) {e : Sym2 V}", "{G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG\u2081 G\u2082 : SimpleGraph V\ninst\u271d\u00b2 : Fintype \u2191G\u2081.edgeSet\ninst\u271d\u00b9 : Fintype \u2191G\u2082.edgeSet\ninst\u271d : DecidableEq V\n\u22a2 (G\u2081 \\ G\u2082).edgeFinset = G\u2081.edgeFinset \\ G\u2082.edgeFinset"}, {"line": "simp [edgeFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edgeFinset_top [DecidableEq V] :\n    (\u22a4 : SimpleGraph V).edgeFinset = ({e | \u00ace.IsDiag} : Finset _) := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Finite.lean", "context": {"open": ["Finset Function"], "variables": ["{V : Type*} (G : SimpleGraph V) {e : Sym2 V}", "{G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]", "{G}", "[Fintype V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b9 : Fintype V\ninst\u271d : DecidableEq V\n\u22a2 \u22a4.edgeFinset = {e | \u00ace.IsDiag}"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_mem_neighborFinset_self : v \u2209 G.neighborFinset v := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Finite.lean", "context": {"open": ["Finset Function"], "variables": ["{V : Type*} (G : SimpleGraph V) {e : Sym2 V}", "{G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]", "{G}", "[Fintype V]", "(v) [Fintype (G.neighborSet v)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b2 : Fintype \u2191G.edgeSet\ninst\u271d\u00b9 : Fintype V\nv : V\ninst\u271d : Fintype \u2191(G.neighborSet v)\n\u22a2 v \u2209 G.neighborFinset v"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem incidenceFinset_eq_filter [DecidableEq V] [Fintype G.edgeSet] :\n    G.incidenceFinset v = {e \u2208 G.edgeFinset | v \u2208 e} := by\n  ext e\n  induction e\n  simp [mk'_mem_incidenceSet_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Finite.lean", "context": {"open": ["Finset Function"], "variables": ["{V : Type*} (G : SimpleGraph V) {e : Sym2 V}", "{G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]", "{G}", "[Fintype V]", "(v) [Fintype (G.neighborSet v)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ninst\u271d\u2074 : Fintype \u2191G.edgeSet\ninst\u271d\u00b3 : Fintype V\nv : V\ninst\u271d\u00b2 : Fintype \u2191(G.neighborSet v)\ninst\u271d\u00b9 : DecidableEq V\ninst\u271d : Fintype \u2191G.edgeSet\n\u22a2 G.incidenceFinset v = {e \u2208 G.edgeFinset | v \u2208 e}"}, {"line": "ext e", "tactic_state": "case h\nV : Type u_1\nG : SimpleGraph V\ninst\u271d\u2074 : Fintype \u2191G.edgeSet\ninst\u271d\u00b3 : Fintype V\nv : V\ninst\u271d\u00b2 : Fintype \u2191(G.neighborSet v)\ninst\u271d\u00b9 : DecidableEq V\ninst\u271d : Fintype \u2191G.edgeSet\ne : Sym2 V\n\u22a2 e \u2208 G.incidenceFinset v \u2194 e \u2208 {e \u2208 G.edgeFinset | v \u2208 e}"}, {"line": "induction e", "tactic_state": "case h.h\nV : Type u_1\nG : SimpleGraph V\ninst\u271d\u2074 : Fintype \u2191G.edgeSet\ninst\u271d\u00b3 : Fintype V\nv : V\ninst\u271d\u00b2 : Fintype \u2191(G.neighborSet v)\ninst\u271d\u00b9 : DecidableEq V\ninst\u271d : Fintype \u2191G.edgeSet\nx\u271d y\u271d : V\n\u22a2 s(x\u271d, y\u271d) \u2208 G.incidenceFinset v \u2194 s(x\u271d, y\u271d) \u2208 {e \u2208 G.edgeFinset | v \u2208 e}"}, {"line": "simp [mk'_mem_incidenceSet_iff]", "tactic_state": "case h.h\nV : Type u_1\nG : SimpleGraph V\ninst\u271d\u2074 : Fintype \u2191G.edgeSet\ninst\u271d\u00b3 : Fintype V\nv : V\ninst\u271d\u00b2 : Fintype \u2191(G.neighborSet v)\ninst\u271d\u00b9 : DecidableEq V\ninst\u271d : Fintype \u2191G.edgeSet\nx\u271d y\u271d : V\n\u22a2 s(x\u271d, y\u271d) \u2208 G.incidenceSet v \u2194 G.Adj x\u271d y\u271d \u2227 (v = x\u271d \u2228 v = y\u271d)"}]}
{"declaration": "theorem IsRegularOfDegree.top [DecidableEq V] :\n    (\u22a4 : SimpleGraph V).IsRegularOfDegree (Fintype.card V - 1) := by\n  intro v\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Finite.lean", "context": {"open": ["Finset Function"], "variables": ["{V : Type*} (G : SimpleGraph V) {e : Sym2 V}", "{G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]", "{G}", "[Fintype V]", "(v) [Fintype (G.neighborSet v)]", "{G v}", "[LocallyFinite G]", "{G}", "[Fintype V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype V\ninst\u271d : DecidableEq V\n\u22a2 \u22a4.IsRegularOfDegree (Fintype.card V - 1)"}, {"line": "intro v", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype V\ninst\u271d : DecidableEq V\nv : V\n\u22a2 \u22a4.degree v = Fintype.card V - 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_minimal_degree_vertex [DecidableRel G.Adj] [Nonempty V] :\n    \u2203 v, G.minDegree = G.degree v := by\n  obtain \u27e8t, ht : _ = _\u27e9 := min_of_nonempty (univ_nonempty.image fun v => G.degree v)\n  obtain \u27e8v, _, rfl\u27e9 := mem_image.mp (mem_of_min ht)\n  exact \u27e8v, by simp [minDegree, ht]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Finite.lean", "context": {"open": ["Finset Function"], "variables": ["{V : Type*} (G : SimpleGraph V) {e : Sym2 V}", "{G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]", "{G}", "[Fintype V]", "(v) [Fintype (G.neighborSet v)]", "{G v}", "[LocallyFinite G]", "{G}", "[Fintype V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ninst\u271d\u2074 : Fintype \u2191G.edgeSet\ninst\u271d\u00b3 inst\u271d\u00b2 : Fintype V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : Nonempty V\n\u22a2 \u2203 v, G.minDegree = G.degree v"}, {"line": "obtain \u27e8t, ht : _ = _\u27e9 := min_of_nonempty (univ_nonempty.image fun v => G.degree v)", "tactic_state": "case intro\nV : Type u_1\nG : SimpleGraph V\ninst\u271d\u2074 : Fintype \u2191G.edgeSet\ninst\u271d\u00b3 inst\u271d\u00b2 : Fintype V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : Nonempty V\nt : \u2115\nht : (image (fun v => sorry) univ).min = \u2191t\n\u22a2 \u2203 v, G.minDegree = G.degree v"}, {"line": "obtain \u27e8v, _, rfl\u27e9 := mem_image.mp (mem_of_min ht)", "tactic_state": "case intro.intro.intro\nV : Type u_1\nG : SimpleGraph V\ninst\u271d\u2074 : Fintype \u2191G.edgeSet\ninst\u271d\u00b3 inst\u271d\u00b2 : Fintype V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : Nonempty V\nv : V\nleft\u271d : v \u2208 univ\nht : (image (fun v => sorry) univ).min = \u2191sorry\n\u22a2 \u2203 v, G.minDegree = G.degree v"}, {"line": "exact \u27e8v, by simp [minDegree, ht]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_edgeFinset_induce_of_support_subset (h : G.support \u2286 s) :\n    (G.induce s).edgeFinset.map (Embedding.subtype s).sym2Map = G.edgeFinset := by\n  simpa [map_edgeFinset_induce] using edgeFinset_subset_sym2_of_support_subset h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Finite.lean", "context": {"open": ["Finset Function"], "variables": ["{V : Type*} (G : SimpleGraph V) {e : Sym2 V}", "{G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]", "{G}", "[Fintype V]", "(v) [Fintype (G.neighborSet v)]", "{G v}", "[LocallyFinite G]", "{G}", "[Fintype V]", "{G} in", "{s : Set V} [DecidablePred (\u00b7 \u2208 s)] [Fintype V] {G : SimpleGraph V} [DecidableRel G.Adj]", "[DecidableEq V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b3 : Fintype \u2191G.edgeSet\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype V\ninst\u271d : DecidableEq V\ns : Set V\nh : G.support \u2286 s\n\u22a2 sorry = G.edgeFinset"}, {"line": "simpa [map_edgeFinset_induce] using edgeFinset_subset_sym2_of_support_subset h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_egirth {n : \u2115\u221e} : n \u2264 G.egirth \u2194 \u2200 a (w : G.Walk a a), w.IsCycle \u2192 n \u2264 w.length := by\n  simp [egirth]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Girth.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {G : SimpleGraph \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nn : \u2115\u221e\n\u22a2 n \u2264 G.egirth \u2194 \u2200 (a : \u03b1) (w : G.Walk a a), w.IsCycle \u2192 n \u2264 \u2191w.length"}, {"line": "simp [egirth]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma egirth_eq_top : G.egirth = \u22a4 \u2194 G.IsAcyclic := by simp [egirth, IsAcyclic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Girth.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {G : SimpleGraph \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG : SimpleGraph \u03b1\n\u22a2 G.egirth = \u22a4 \u2194 G.IsAcyclic"}, {"line": "simp [egirth, IsAcyclic]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem incMatrix_apply' [Zero R] [One R] [DecidableEq \u03b1] [DecidableRel G.Adj] {a : \u03b1}\n    {e : Sym2 \u03b1} : G.incMatrix R a e = if e \u2208 G.incidenceSet a then 1 else 0 := by\n  simp only [incMatrix]\n  simp only [Set.indicator]\n  simp only [Pi.one_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/IncMatrix.lean", "context": {"open": ["Finset Matrix SimpleGraph Sym2"], "variables": ["(R : Type*) {\u03b1 : Type*} (G : SimpleGraph \u03b1)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableRel G.Adj\na : \u03b1\ne : Sym2 \u03b1\n\u22a2 incMatrix R G a e = if e \u2208 G.incidenceSet a then 1 else 0"}, {"line": "simp only [incMatrix]", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableRel G.Adj\na : \u03b1\ne : Sym2 \u03b1\n\u22a2 (G.incidenceSet a).indicator 1 e = if e \u2208 G.incidenceSet a then 1 else 0"}, {"line": "simp only [Set.indicator]", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableRel G.Adj\na : \u03b1\ne : Sym2 \u03b1\n\u22a2 (if e \u2208 G.incidenceSet a then 1 e else 0) = if e \u2208 G.incidenceSet a then 1 else 0"}, {"line": "simp only [Pi.one_apply]", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableRel G.Adj\na : \u03b1\ne : Sym2 \u03b1\n\u22a2 (if e \u2208 G.incidenceSet a then 1 else 0) = if e \u2208 G.incidenceSet a then 1 else 0"}]}
{"declaration": "theorem incMatrix_apply_mul_incMatrix_apply : G.incMatrix R a e * G.incMatrix R b e =\n    (G.incidenceSet a \u2229 G.incidenceSet b).indicator 1 e := by\n  classical simp only [incMatrix, Set.indicator_apply, ite_zero_mul_ite_zero, Pi.one_apply, mul_one,\n    Set.mem_inter_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/IncMatrix.lean", "context": {"open": ["Finset Matrix SimpleGraph Sym2"], "variables": ["(R : Type*) {\u03b1 : Type*} (G : SimpleGraph \u03b1)", "{R}", "[MulZeroOneClass R] {a b : \u03b1} {e : Sym2 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d : MulZeroOneClass R\na b : \u03b1\ne : Sym2 \u03b1\n\u22a2 incMatrix R G a e * incMatrix R G b e = (G.incidenceSet a \u2229 G.incidenceSet b).indicator 1 e"}, {"line": "classical simp only [incMatrix, Set.indicator_apply, ite_zero_mul_ite_zero, Pi.one_apply, mul_one,\n    Set.mem_inter_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem incMatrix_apply_mul_incMatrix_apply_of_not_adj (hab : a \u2260 b) (h : \u00acG.Adj a b) :\n    G.incMatrix R a e * G.incMatrix R b e = 0 := by\n  rw [incMatrix_apply_mul_incMatrix_apply]\n  rw [Set.indicator_of_not_mem]\n  rw [G.incidenceSet_inter_incidenceSet_of_not_adj h hab]\n  exact Set.not_mem_empty e\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/IncMatrix.lean", "context": {"open": ["Finset Matrix SimpleGraph Sym2"], "variables": ["(R : Type*) {\u03b1 : Type*} (G : SimpleGraph \u03b1)", "{R}", "[MulZeroOneClass R] {a b : \u03b1} {e : Sym2 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d : MulZeroOneClass R\na b : \u03b1\ne : Sym2 \u03b1\nhab : a \u2260 b\nh : \u00acG.Adj a b\n\u22a2 incMatrix R G a e * incMatrix R G b e = 0"}, {"line": "rw [incMatrix_apply_mul_incMatrix_apply]", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d : MulZeroOneClass R\na b : \u03b1\ne : Sym2 \u03b1\nhab : a \u2260 b\nh : \u00acG.Adj a b\n\u22a2 (G.incidenceSet a \u2229 G.incidenceSet b).indicator 1 e = 0"}, {"line": "rw [Set.indicator_of_not_mem]", "tactic_state": "case h\nR : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d : MulZeroOneClass R\na b : \u03b1\ne : Sym2 \u03b1\nhab : a \u2260 b\nh : \u00acG.Adj a b\n\u22a2 e \u2209 G.incidenceSet a \u2229 G.incidenceSet b"}, {"line": "rw [G.incidenceSet_inter_incidenceSet_of_not_adj h hab]", "tactic_state": "case h\nR : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d : MulZeroOneClass R\na b : \u03b1\ne : Sym2 \u03b1\nhab : a \u2260 b\nh : \u00acG.Adj a b\n\u22a2 e \u2209 \u2205"}, {"line": "exact Set.not_mem_empty e", "tactic_state": "No Goals!"}]}
{"declaration": "theorem incMatrix_of_not_mem_incidenceSet (h : e \u2209 G.incidenceSet a) : G.incMatrix R a e = 0 := by\n  rw [incMatrix_apply]\n  rw [Set.indicator_of_not_mem h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/IncMatrix.lean", "context": {"open": ["Finset Matrix SimpleGraph Sym2"], "variables": ["(R : Type*) {\u03b1 : Type*} (G : SimpleGraph \u03b1)", "{R}", "[MulZeroOneClass R] {a b : \u03b1} {e : Sym2 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d : MulZeroOneClass R\na : \u03b1\ne : Sym2 \u03b1\nh : e \u2209 G.incidenceSet a\n\u22a2 incMatrix R G a e = 0"}, {"line": "rw [incMatrix_apply]", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d : MulZeroOneClass R\na : \u03b1\ne : Sym2 \u03b1\nh : e \u2209 G.incidenceSet a\n\u22a2 (G.incidenceSet a).indicator 1 e = 0"}, {"line": "rw [Set.indicator_of_not_mem h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem incMatrix_of_mem_incidenceSet (h : e \u2208 G.incidenceSet a) : G.incMatrix R a e = 1 := by\n  rw [incMatrix_apply]\n  rw [Set.indicator_of_mem h]\n  rw [Pi.one_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/IncMatrix.lean", "context": {"open": ["Finset Matrix SimpleGraph Sym2"], "variables": ["(R : Type*) {\u03b1 : Type*} (G : SimpleGraph \u03b1)", "{R}", "[MulZeroOneClass R] {a b : \u03b1} {e : Sym2 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d : MulZeroOneClass R\na : \u03b1\ne : Sym2 \u03b1\nh : e \u2208 G.incidenceSet a\n\u22a2 incMatrix R G a e = 1"}, {"line": "rw [incMatrix_apply]", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d : MulZeroOneClass R\na : \u03b1\ne : Sym2 \u03b1\nh : e \u2208 G.incidenceSet a\n\u22a2 (G.incidenceSet a).indicator 1 e = 1"}, {"line": "rw [Set.indicator_of_mem h]", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d : MulZeroOneClass R\na : \u03b1\ne : Sym2 \u03b1\nh : e \u2208 G.incidenceSet a\n\u22a2 1 e = 1"}, {"line": "rw [Pi.one_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem incMatrix_apply_eq_one_iff : G.incMatrix R a e = 1 \u2194 e \u2208 G.incidenceSet a := by\n  convert one_ne_zero.ite_eq_left_iff\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/IncMatrix.lean", "context": {"open": ["Finset Matrix SimpleGraph Sym2"], "variables": ["(R : Type*) {\u03b1 : Type*} (G : SimpleGraph \u03b1)", "{R}", "[MulZeroOneClass R] {a b : \u03b1} {e : Sym2 \u03b1}", "[Nontrivial R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : MulZeroOneClass R\na : \u03b1\ne : Sym2 \u03b1\ninst\u271d : Nontrivial R\n\u22a2 incMatrix R G a e = 1 \u2194 e \u2208 G.incidenceSet a"}, {"line": "convert one_ne_zero.ite_eq_left_iff", "tactic_state": "case convert_3\nR : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : MulZeroOneClass R\na : \u03b1\ne : Sym2 \u03b1\ninst\u271d : Nontrivial R\n\u22a2 NeZero 1"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_incMatrix_apply [Fintype (Sym2 \u03b1)] [Fintype (neighborSet G a)] :\n    \u2211 e, G.incMatrix R a e = G.degree a := by\n  classical simp [incMatrix_apply', sum_boole, Set.filter_mem_univ_eq_toFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/IncMatrix.lean", "context": {"open": ["Finset Matrix SimpleGraph Sym2"], "variables": ["(R : Type*) {\u03b1 : Type*} (G : SimpleGraph \u03b1)", "{R}", "[MulZeroOneClass R] {a b : \u03b1} {e : Sym2 \u03b1}", "[Nontrivial R]", "[NonAssocSemiring R] {a : \u03b1} {e : Sym2 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d\u2074 : MulZeroOneClass R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : NonAssocSemiring R\na : \u03b1\ninst\u271d\u00b9 : Fintype (Sym2 \u03b1)\ninst\u271d : Fintype \u2191(G.neighborSet a)\n\u22a2 \u2211 e, incMatrix R G a e = \u2191(G.degree a)"}, {"line": "classical simp [incMatrix_apply', sum_boole, Set.filter_mem_univ_eq_toFinset]", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d\u2074 : MulZeroOneClass R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : NonAssocSemiring R\na : \u03b1\ninst\u271d\u00b9 : Fintype (Sym2 \u03b1)\ninst\u271d : Fintype \u2191(G.neighborSet a)\n\u22a2 \u2191{x | x \u2208 G.incidenceSet a}.card = \u2191(G.degree a)"}]}
{"declaration": "theorem sum_incMatrix_apply_of_mem_edgeSet [Fintype \u03b1] :\n    e \u2208 G.edgeSet \u2192 \u2211 a, G.incMatrix R a e = 2 := by\n  classical\n    refine e.ind ?_\n    intro a b h\n    rw [mem_edgeSet] at h\n    rw [\u2190 Nat.cast_two]\n    rw [\u2190 card_pair h.ne]\n    simp only [incMatrix_apply']\n    simp only [sum_boole]\n    simp only [mk'_mem_incidenceSet_iff]\n    simp only [h]\n    congr 2\n    ext e\n    simp only [mem_filter]\n    simp only [mem_univ]\n    simp only [true_and]\n    simp only [mem_insert]\n    simp only [mem_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/IncMatrix.lean", "context": {"open": ["Finset Matrix SimpleGraph Sym2"], "variables": ["(R : Type*) {\u03b1 : Type*} (G : SimpleGraph \u03b1)", "{R}", "[MulZeroOneClass R] {a b : \u03b1} {e : Sym2 \u03b1}", "[Nontrivial R]", "[NonAssocSemiring R] {a : \u03b1} {e : Sym2 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d\u00b3 : MulZeroOneClass R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : NonAssocSemiring R\ne : Sym2 \u03b1\ninst\u271d : Fintype \u03b1\n\u22a2 e \u2208 G.edgeSet \u2192 \u2211 a, incMatrix R G a e = 2"}, {"line": "classical\n    refine e.ind ?_\n    intro a b h\n    rw [mem_edgeSet] at h\n    rw [\u2190 Nat.cast_two]\n    rw [\u2190 card_pair h.ne]\n    simp only [incMatrix_apply']\n    simp only [sum_boole]\n    simp only [mk'_mem_incidenceSet_iff]\n    simp only [h]\n    congr 2\n    ext e\n    simp only [mem_filter]\n    simp only [mem_univ]\n    simp only [true_and]\n    simp only [mem_insert]\n    simp only [mem_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem posSemidef_lapMatrix [Field R] [LinearOrder R] [IsStrictOrderedRing R] [StarRing R]\n    [TrivialStar R] : PosSemidef (G.lapMatrix R) := by\n  constructor\n  \u00b7 rw [IsHermitian, conjTranspose_eq_transpose_of_trivial, isSymm_lapMatrix]\n  \u00b7 intro x\n    rw [star_trivial]\n    rw [\u2190 toLinearMap\u2082'_apply']\n    rw [lapMatrix_toLinearMap\u2082']\n    positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/LapMatrix.lean", "context": {"open": ["Finset Matrix"], "variables": ["{V : Type*} (R : Type*)", "[Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj]", "[DecidableEq V]", "{R}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nR : Type u_2\ninst\u271d\u2077 : Fintype V\nG : SimpleGraph V\ninst\u271d\u2076 : DecidableRel G.Adj\ninst\u271d\u2075 : DecidableEq V\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : TrivialStar R\n\u22a2 (SimpleGraph.lapMatrix R G).PosSemidef"}, {"line": "constructor", "tactic_state": "case left\nV : Type u_1\nR : Type u_2\ninst\u271d\u2077 : Fintype V\nG : SimpleGraph V\ninst\u271d\u2076 : DecidableRel G.Adj\ninst\u271d\u2075 : DecidableEq V\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : TrivialStar R\n\u22a2 (SimpleGraph.lapMatrix R G).IsHermitian\n---\ncase right\nV : Type u_1\nR : Type u_2\ninst\u271d\u2077 : Fintype V\nG : SimpleGraph V\ninst\u271d\u2076 : DecidableRel G.Adj\ninst\u271d\u2075 : DecidableEq V\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : TrivialStar R\n\u22a2 \u2200 (x : V \u2192 R), 0 \u2264 star x \u2b1d\u1d65 (SimpleGraph.lapMatrix R G).mulVec x"}, {"line": "\u00b7 rw [IsHermitian, conjTranspose_eq_transpose_of_trivial, isSymm_lapMatrix]", "tactic_state": "case right\nV : Type u_1\nR : Type u_2\ninst\u271d\u2077 : Fintype V\nG : SimpleGraph V\ninst\u271d\u2076 : DecidableRel G.Adj\ninst\u271d\u2075 : DecidableEq V\ninst\u271d\u2074 : Field R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : TrivialStar R\n\u22a2 \u2200 (x : V \u2192 R), 0 \u2264 star x \u2b1d\u1d65 (SimpleGraph.lapMatrix R G).mulVec x"}, {"line": "\u00b7 intro x\n    rw [star_trivial]\n    rw [\u2190 toLinearMap\u2082'_apply']\n    rw [lapMatrix_toLinearMap\u2082']\n    positivity", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_adj_apply {G : SimpleGraph V} {f : V \u21aa W} {a b : V} :\n    (G.map f).Adj (f a) (f b) \u2194 G.Adj a b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Maps.lean", "context": {"open": ["Function"], "variables": ["{V W X : Type*} (G : SimpleGraph V) (G' : SimpleGraph W) {u v : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nf : V \u21aa W\na b : V\n\u22a2 (SimpleGraph.map f G).Adj (f a) (f b) \u2194 G.Adj a b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_monotone (f : V \u21aa W) : Monotone (SimpleGraph.map f) := by\n  rintro G G' h _ _ \u27e8u, v, ha, rfl, rfl\u27e9\n  exact \u27e8_, _, h ha, rfl, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Maps.lean", "context": {"open": ["Function"], "variables": ["{V W X : Type*} (G : SimpleGraph V) (G' : SimpleGraph W) {u v : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nW : Type u_2\nf : V \u21aa W\n\u22a2 Monotone (SimpleGraph.map f)"}, {"line": "rintro G G' h _ _ \u27e8u, v, ha, rfl, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro\nV : Type u_1\nW : Type u_2\nf : V \u21aa W\nG G' : SimpleGraph V\nh : G \u2264 G'\nu v : V\nha : G.Adj u v\n\u22a2 (SimpleGraph.map f G').Adj (f u) (f v)"}, {"line": "exact \u27e8_, _, h ha, rfl, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_monotone (f : V \u21aa W) : Monotone (SimpleGraph.comap f) := by\n  intro G G' h _ _ ha\n  exact h ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Maps.lean", "context": {"open": ["Function"], "variables": ["{V W X : Type*} (G : SimpleGraph V) (G' : SimpleGraph W) {u v : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nW : Type u_2\nf : V \u21aa W\n\u22a2 Monotone (SimpleGraph.comap \u21d1f)"}, {"line": "intro G G' h _ _ ha", "tactic_state": "V : Type u_1\nW : Type u_2\nf : V \u21aa W\nG G' : SimpleGraph W\nh : G \u2264 G'\nv\u271d w\u271d : V\nha : (SimpleGraph.comap (\u21d1f) G).Adj v\u271d w\u271d\n\u22a2 (SimpleGraph.comap (\u21d1f) G').Adj v\u271d w\u271d"}, {"line": "exact h ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_map_eq (f : V \u21aa W) (G : SimpleGraph V) : (G.map f).comap f = G := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Maps.lean", "context": {"open": ["Function"], "variables": ["{V W X : Type*} (G : SimpleGraph V) (G' : SimpleGraph W) {u v : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nW : Type u_2\nf : V \u21aa W\nG : SimpleGraph V\n\u22a2 SimpleGraph.comap (\u21d1f) (SimpleGraph.map f G) = G"}, {"line": "ext", "tactic_state": "case Adj.h.h.a\nV : Type u_1\nW : Type u_2\nf : V \u21aa W\nG : SimpleGraph V\nx\u271d\u00b9 x\u271d : V\n\u22a2 (SimpleGraph.comap (\u21d1f) (SimpleGraph.map f G)).Adj x\u271d\u00b9 x\u271d \u2194 G.Adj x\u271d\u00b9 x\u271d"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem injective_of_top_hom (f : (\u22a4 : SimpleGraph V) \u2192g G') : Function.Injective f := by\n  intro v w h\n  contrapose! h\n  exact G'.ne_of_adj (map_adj _ ((top_adj _ _).mpr h))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Maps.lean", "context": {"open": ["Function"], "variables": ["{V W X : Type*} (G : SimpleGraph V) (G' : SimpleGraph W) {u v : V}", "{G G'} {G\u2081 G\u2082 : SimpleGraph V} {H : SimpleGraph W} (f : G \u2192g G')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nW : Type u_2\nG' : SimpleGraph W\nf : \u22a4 \u2192g G'\n\u22a2 Injective \u21d1f"}, {"line": "intro v w h", "tactic_state": "V : Type u_1\nW : Type u_2\nG' : SimpleGraph W\nf : \u22a4 \u2192g G'\nv w : V\nh : f v = f w\n\u22a2 v = w"}, {"line": "contrapose! h", "tactic_state": "V : Type u_1\nW : Type u_2\nG' : SimpleGraph W\nf : \u22a4 \u2192g G'\nv w : V\nh : v \u2260 w\n\u22a2 f v \u2260 f w"}, {"line": "exact G'.ne_of_adj (map_adj _ ((top_adj _ _).mpr h))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsPerfectMatching.induce_connectedComponent_isMatching (h : M.IsPerfectMatching)\n    (c : ConnectedComponent G) : (M.induce c.supp).IsMatching := by\n  simpa [h.2.verts_eq_univ] using h.1.induce_connectedComponent c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Matching.lean", "context": {"open": ["Function"], "variables": ["{V W : Type*} {G G' : SimpleGraph V} {M M' : Subgraph G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Subgraph : ?m.865\nV : Type u_1\nW : Type u_2\nG G' : SimpleGraph V\nM : sorry\nM' : sorry\nu v w : V\nx\u271d : Sort u_3\nConnectedComponent : x\u271d\nh : sorry\nc : sorry\n\u22a2 sorry"}, {"line": "simpa [h.2.verts_eq_univ] using h.1.induce_connectedComponent c", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsClique.even_iff_exists_isMatching {u : Set V} (hc : G.IsClique u)\n    (hu : u.Finite) : Even u.ncard \u2194 \u2203 (M : Subgraph G), M.verts = u \u2227 M.IsMatching := by\n  refine \u27e8fun h \u21a6 ?_, by\n    rintro \u27e8M, rfl, hMr\u27e9\n    simpa [Set.ncard_eq_toFinset_card _ hu, Set.toFinite_toFinset,\n      \u2190 Set.toFinset_card] using @hMr.even_card _ _ _ hu.fintype\u27e9\n  obtain \u27e8t, u, rfl, hd, hcard\u27e9 := Set.exists_union_disjoint_ncard_eq_of_even h\n  obtain \u27e8f\u27e9 : Nonempty (t \u2243 u) := by\n    rw [\u2190 Cardinal.eq]\n    rw [\u2190 t.cast_ncard (Set.finite_union.mp hu).1]\n    rw [\u2190 u.cast_ncard (Set.finite_union.mp hu).2]\n    exact congrArg Nat.cast hcard\n  exact Subgraph.IsMatching.exists_of_disjoint_sets_of_equiv hd f\n    fun v \u21a6 hc (by simp) (by simp) <| hd.ne_of_mem (by simp) (by simp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Matching.lean", "context": {"open": ["Function"], "variables": ["{V W : Type*} {G G' : SimpleGraph V} {M M' : Subgraph G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Subgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu\u271d v w : V\u271d\nV : Type u_1\nG : SimpleGraph V\nu : Set V\nhc : G.IsClique u\nhu : u.Finite\n\u22a2 Even u.ncard \u2194 \u2203 M, sorry = u \u2227 sorry"}, {"line": "refine \u27e8fun h \u21a6 ?_, by\n    rintro \u27e8M, rfl, hMr\u27e9\n    simpa [Set.ncard_eq_toFinset_card _ hu, Set.toFinite_toFinset,\n      \u2190 Set.toFinset_card] using @hMr.even_card _ _ _ hu.fintype\u27e9", "tactic_state": "Subgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu\u271d v w : V\u271d\nV : Type u_1\nG : SimpleGraph V\nu : Set V\nhc : G.IsClique u\nhu : u.Finite\nh : Even u.ncard\n\u22a2 \u2203 M, sorry = u \u2227 sorry"}, {"line": "obtain \u27e8t, u, rfl, hd, hcard\u27e9 := Set.exists_union_disjoint_ncard_eq_of_even h", "tactic_state": "case intro.intro.intro.intro\nSubgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu\u271d v w : V\u271d\nV : Type u_1\nG : SimpleGraph V\nt u : Set V\nhc : G.IsClique (t \u222a u)\nhu : (t \u222a u).Finite\nh : Even (t \u222a u).ncard\nhd : Disjoint t u\nhcard : t.ncard = u.ncard\n\u22a2 \u2203 M, sorry = t \u222a u \u2227 sorry"}, {"line": "obtain \u27e8f\u27e9 : Nonempty (t \u2243 u) := by\n    rw [\u2190 Cardinal.eq]\n    rw [\u2190 t.cast_ncard (Set.finite_union.mp hu).1]\n    rw [\u2190 u.cast_ncard (Set.finite_union.mp hu).2]\n    exact congrArg Nat.cast hcard", "tactic_state": "case intro.intro.intro.intro.intro\nSubgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu\u271d v w : V\u271d\nV : Type u_1\nG : SimpleGraph V\nt u : Set V\nhc : G.IsClique (t \u222a u)\nhu : (t \u222a u).Finite\nh : Even (t \u222a u).ncard\nhd : Disjoint t u\nhcard : t.ncard = u.ncard\nf : \u2191t \u2243 \u2191u\n\u22a2 \u2203 M, sorry = t \u222a u \u2227 sorry"}, {"line": "exact Subgraph.IsMatching.exists_of_disjoint_sets_of_equiv hd f\n    fun v \u21a6 hc (by simp) (by simp) <| hd.ne_of_mem (by simp) (by simp)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCycles.other_adj_of_adj (h : G.IsCycles) (hadj : G.Adj v w) :\n    \u2203 w', w \u2260 w' \u2227 G.Adj v w' := by\n  simp_rw [\u2190 SimpleGraph.mem_neighborSet] at hadj \u22a2\n  have := h \u27e8w, hadj\u27e9\n  obtain \u27e8w', hww'\u27e9 := (G.neighborSet v).exists_ne_of_one_lt_ncard (by omega) w\n  exact \u27e8w', \u27e8hww'.2.symm, hww'.1\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Matching.lean", "context": {"open": ["Function"], "variables": ["{V W : Type*} {G G' : SimpleGraph V} {M M' : Subgraph G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Subgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu v\u271d w\u271d : V\u271d\nV : Type u_1\nG : SimpleGraph V\nv w : V\nh : G.IsCycles\nhadj : G.Adj v w\n\u22a2 \u2203 w', w \u2260 w' \u2227 G.Adj v w'"}, {"line": "simp_rw [\u2190 SimpleGraph.mem_neighborSet] at hadj \u22a2", "tactic_state": "Subgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu v\u271d w\u271d : V\u271d\nV : Type u_1\nG : SimpleGraph V\nv w : V\nh : G.IsCycles\nhadj : w \u2208 G.neighborSet v\n\u22a2 \u2203 w', w \u2260 w' \u2227 w' \u2208 G.neighborSet v"}, {"line": "have := h \u27e8w, hadj\u27e9", "tactic_state": "Subgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu v\u271d w\u271d : V\u271d\nV : Type u_1\nG : SimpleGraph V\nv w : V\nh : G.IsCycles\nhadj : w \u2208 G.neighborSet v\nthis : (G.neighborSet v).ncard = 2\n\u22a2 \u2203 w', w \u2260 w' \u2227 w' \u2208 G.neighborSet v"}, {"line": "obtain \u27e8w', hww'\u27e9 := (G.neighborSet v).exists_ne_of_one_lt_ncard (by omega) w", "tactic_state": "case intro\nSubgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu v\u271d w\u271d : V\u271d\nV : Type u_1\nG : SimpleGraph V\nv w : V\nh : G.IsCycles\nhadj : w \u2208 G.neighborSet v\nthis : (G.neighborSet v).ncard = 2\nw' : V\nhww' : w' \u2208 G.neighborSet v \u2227 w' \u2260 w\n\u22a2 \u2203 w', w \u2260 w' \u2227 w' \u2208 G.neighborSet v"}, {"line": "exact \u27e8w', \u27e8hww'.2.symm, hww'.1\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCycles.existsUnique_ne_adj (h : G.IsCycles) (hadj : G.Adj v w) :\n    \u2203! w', w \u2260 w' \u2227 G.Adj v w' := by\n  obtain \u27e8w', \u27e8hww, hww'\u27e9\u27e9 := h.other_adj_of_adj hadj\n  use w'\n  refine \u27e8\u27e8hww, hww'\u27e9, ?_\u27e9\n  intro y \u27e8hwy, hwy'\u27e9\n  obtain \u27e8x, y', hxy'\u27e9 := Set.ncard_eq_two.mp (h \u27e8w, hadj\u27e9)\n  simp_rw [\u2190 SimpleGraph.mem_neighborSet] at *\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Matching.lean", "context": {"open": ["Function"], "variables": ["{V W : Type*} {G G' : SimpleGraph V} {M M' : Subgraph G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Subgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu v\u271d w\u271d : V\u271d\nV : Type u_1\nG : SimpleGraph V\nv w : V\nh : G.IsCycles\nhadj : G.Adj v w\n\u22a2 \u2203! w', w \u2260 w' \u2227 G.Adj v w'"}, {"line": "obtain \u27e8w', \u27e8hww, hww'\u27e9\u27e9 := h.other_adj_of_adj hadj", "tactic_state": "case intro.intro\nSubgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu v\u271d w\u271d : V\u271d\nV : Type u_1\nG : SimpleGraph V\nv w : V\nh : G.IsCycles\nhadj : G.Adj v w\nw' : V\nhww : w \u2260 w'\nhww' : G.Adj v w'\n\u22a2 \u2203! w', w \u2260 w' \u2227 G.Adj v w'"}, {"line": "use w'", "tactic_state": "case h\nSubgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu v\u271d w\u271d : V\u271d\nV : Type u_1\nG : SimpleGraph V\nv w : V\nh : G.IsCycles\nhadj : G.Adj v w\nw' : V\nhww : w \u2260 w'\nhww' : G.Adj v w'\n\u22a2 (fun w' => w \u2260 w' \u2227 G.Adj v w') w' \u2227 \u2200 (y : V), (fun w' => w \u2260 w' \u2227 G.Adj v w') y \u2192 y = w'"}, {"line": "refine \u27e8\u27e8hww, hww'\u27e9, ?_\u27e9", "tactic_state": "case h\nSubgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu v\u271d w\u271d : V\u271d\nV : Type u_1\nG : SimpleGraph V\nv w : V\nh : G.IsCycles\nhadj : G.Adj v w\nw' : V\nhww : w \u2260 w'\nhww' : G.Adj v w'\n\u22a2 \u2200 (y : V), (fun w' => w \u2260 w' \u2227 G.Adj v w') y \u2192 y = w'"}, {"line": "intro y \u27e8hwy, hwy'\u27e9", "tactic_state": "case h\nSubgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu v\u271d w\u271d : V\u271d\nV : Type u_1\nG : SimpleGraph V\nv w : V\nh : G.IsCycles\nhadj : G.Adj v w\nw' : V\nhww : w \u2260 w'\nhww' : G.Adj v w'\ny : V\nhwy : w \u2260 y\nhwy' : G.Adj v y\n\u22a2 y = w'"}, {"line": "obtain \u27e8x, y', hxy'\u27e9 := Set.ncard_eq_two.mp (h \u27e8w, hadj\u27e9)", "tactic_state": "case h.intro.intro\nSubgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu v\u271d w\u271d : V\u271d\nV : Type u_1\nG : SimpleGraph V\nv w : V\nh : G.IsCycles\nhadj : G.Adj v w\nw' : V\nhww : w \u2260 w'\nhww' : G.Adj v w'\ny : V\nhwy : w \u2260 y\nhwy' : G.Adj v y\nx y' : V\nhxy' : x \u2260 y' \u2227 G.neighborSet v = {x, y'}\n\u22a2 y = w'"}, {"line": "simp_rw [\u2190 SimpleGraph.mem_neighborSet] at *", "tactic_state": "case h.intro.intro\nSubgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu v\u271d w\u271d : V\u271d\nV : Type u_1\nG : SimpleGraph V\nv w : V\nh : G.IsCycles\nw' : V\nhww : w \u2260 w'\ny : V\nhwy : w \u2260 y\nx y' : V\nhxy' : x \u2260 y' \u2227 G.neighborSet v = {x, y'}\nhadj : w \u2208 G.neighborSet v\nhww' : w' \u2208 G.neighborSet v\nhwy' : y \u2208 G.neighborSet v\n\u22a2 y = w'"}, {"line": "aesop", "tactic_state": "Subgraph : ?m.865\nV_1 : Type u_1\nW : Type u_2\nG_1 G' : SimpleGraph V_1\nM : sorry\nM' : sorry\nu v_1 w_1 : V_1\nV : Type u_1\nG : SimpleGraph V\nv w : V\nh : G.IsCycles\nw' y x y' : V\nhww : \u00acw = w'\nhwy : \u00acw = y\nhadj : w = x \u2228 w = y'\nhww' : w' = x \u2228 w' = y'\nhwy' : y = x \u2228 y = y'\nleft : \u00acx = y'\nright : G.neighborSet v = {x, y'}\n\u22a2 y = w'"}]}
{"declaration": "lemma Walk.IsCycle.isCycles_spanningCoe_toSubgraph {u : V} {p : G.Walk u u} (hpc : p.IsCycle) :\n    p.toSubgraph.spanningCoe.IsCycles := by\n  intro v hv\n  apply hpc.ncard_neighborSet_toSubgraph_eq_two\n  obtain \u27e8_, hw\u27e9 := hv\n  exact p.mem_verts_toSubgraph.mp <| p.toSubgraph.edge_vert hw\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Matching.lean", "context": {"open": ["Function"], "variables": ["{V W : Type*} {G G' : SimpleGraph V} {M M' : Subgraph G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Subgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu\u271d v w : V\u271d\nV : Type u_1\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhpc : p.IsCycle\n\u22a2 p.toSubgraph.spanningCoe.IsCycles"}, {"line": "intro v hv", "tactic_state": "Subgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu\u271d v\u271d w : V\u271d\nV : Type u_1\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhpc : p.IsCycle\nv : V\nhv : (p.toSubgraph.spanningCoe.neighborSet v).Nonempty\n\u22a2 (p.toSubgraph.spanningCoe.neighborSet v).ncard = 2"}, {"line": "apply hpc.ncard_neighborSet_toSubgraph_eq_two", "tactic_state": "Subgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu\u271d v\u271d w : V\u271d\nV : Type u_1\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhpc : p.IsCycle\nv : V\nhv : (p.toSubgraph.spanningCoe.neighborSet v).Nonempty\n\u22a2 v \u2208 p.support"}, {"line": "obtain \u27e8_, hw\u27e9 := hv", "tactic_state": "case intro\nSubgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu\u271d v\u271d w : V\u271d\nV : Type u_1\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhpc : p.IsCycle\nv w\u271d : V\nhw : w\u271d \u2208 p.toSubgraph.spanningCoe.neighborSet v\n\u22a2 v \u2208 p.support"}, {"line": "exact p.mem_verts_toSubgraph.mp <| p.toSubgraph.edge_vert hw", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Walk.IsPath.isCycles_spanningCoe_toSubgraph_sup_edge {u v} {p : G.Walk u v} (hp : p.IsPath)\n    (h : u \u2260 v) (hs : s(v, u) \u2209 p.edges) : (p.toSubgraph.spanningCoe \u2294 edge v u).IsCycles := by\n  let c := (p.mapLe (OrderTop.le_top G)).cons (by simp [h.symm] : (completeGraph V).Adj v u)\n  have : p.toSubgraph.spanningCoe \u2294 edge v u = c.toSubgraph.spanningCoe := by\n    ext w x\n    simp only [sup_adj]\n    simp only [Subgraph.spanningCoe_adj]\n    simp only [completeGraph_eq_top]\n    simp only [edge_adj]\n    simp only [c]\n    simp only [Walk.toSubgraph]\n    simp only [Subgraph.sup_adj]\n    simp only [subgraphOfAdj_adj]\n    simp only [adj_toSubgraph_mapLe]\n    aesop\n  exact this \u25b8 IsCycle.isCycles_spanningCoe_toSubgraph (by simp [Walk.cons_isCycle_iff, c, hp, hs])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Matching.lean", "context": {"open": ["Function"], "variables": ["{V W : Type*} {G G' : SimpleGraph V} {M M' : Subgraph G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Subgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu\u271d v\u271d w : V\u271d\nV : Type u_1\nG : SimpleGraph V\nx\u271d : Sort u_3\nedge : x\u271d\nu v : V\np : G.Walk u v\nhp : p.IsPath\nh : u \u2260 v\nhs : s(v, u) \u2209 p.edges\n\u22a2 (p.toSubgraph.spanningCoe \u2294 sorry).IsCycles"}, {"line": "let c := (p.mapLe (OrderTop.le_top G)).cons (by simp [h.symm] : (completeGraph V).Adj v u)", "tactic_state": "Subgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu\u271d v\u271d w : V\u271d\nV : Type u_1\nG : SimpleGraph V\nx\u271d : Sort u_3\nedge : x\u271d\nu v : V\np : G.Walk u v\nhp : p.IsPath\nh : u \u2260 v\nhs : s(v, u) \u2209 p.edges\nc : (completeGraph V).Walk v v := SimpleGraph.Walk.cons \u22ef (SimpleGraph.Walk.mapLe \u22ef p)\n\u22a2 (p.toSubgraph.spanningCoe \u2294 sorry).IsCycles"}, {"line": "have : p.toSubgraph.spanningCoe \u2294 edge v u = c.toSubgraph.spanningCoe := by\n    ext w x\n    simp only [sup_adj]\n    simp only [Subgraph.spanningCoe_adj]\n    simp only [completeGraph_eq_top]\n    simp only [edge_adj]\n    simp only [c]\n    simp only [Walk.toSubgraph]\n    simp only [Subgraph.sup_adj]\n    simp only [subgraphOfAdj_adj]\n    simp only [adj_toSubgraph_mapLe]\n    aesop", "tactic_state": "Subgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu\u271d v\u271d w : V\u271d\nV : Type u_1\nG : SimpleGraph V\nx\u271d : Sort u_3\nedge : x\u271d\nu v : V\np : G.Walk u v\nhp : p.IsPath\nh : u \u2260 v\nhs : s(v, u) \u2209 p.edges\nc : (completeGraph V).Walk v v := SimpleGraph.Walk.cons \u22ef (SimpleGraph.Walk.mapLe \u22ef p)\nthis : p.toSubgraph.spanningCoe \u2294 sorry = c.toSubgraph.spanningCoe\n\u22a2 (p.toSubgraph.spanningCoe \u2294 sorry).IsCycles"}, {"line": "exact this \u25b8 IsCycle.isCycles_spanningCoe_toSubgraph (by simp [Walk.cons_isCycle_iff, c, hp, hs])", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCycles.reachable_sdiff_toSubgraph_spanningCoe [Finite V] {v w : V} (hcyc : G.IsCycles)\n    (p : G.Walk v w) (hp : p.IsPath) : (G \\ p.toSubgraph.spanningCoe).Reachable w v := by\n  have : Fintype V := Fintype.ofFinite V\n  exact reachable_sdiff_toSubgraph_spanningCoe_aux hcyc p hp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Matching.lean", "context": {"open": ["Function", "scoped symmDiff"], "variables": ["{V W : Type*} {G G' : SimpleGraph V} {M M' : Subgraph G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Subgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu v\u271d w\u271d : V\u271d\nV : Type u_1\nG : SimpleGraph V\ninst\u271d : Finite V\nv w : V\nhcyc : G.IsCycles\np : G.Walk v w\nhp : p.IsPath\n\u22a2 (G \\ p.toSubgraph.spanningCoe).Reachable w v"}, {"line": "have : Fintype V := Fintype.ofFinite V", "tactic_state": "Subgraph : ?m.865\nV\u271d : Type u_1\nW : Type u_2\nG\u271d G' : SimpleGraph V\u271d\nM : sorry\nM' : sorry\nu v\u271d w\u271d : V\u271d\nV : Type u_1\nG : SimpleGraph V\ninst\u271d : Finite V\nv w : V\nhcyc : G.IsCycles\np : G.Walk v w\nhp : p.IsPath\nthis : Fintype V\n\u22a2 (G \\ p.toSubgraph.spanningCoe).Reachable w v"}, {"line": "exact reachable_sdiff_toSubgraph_spanningCoe_aux hcyc p hp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsPerfectMatching.isAlternating_symmDiff_right\n    {M' : Subgraph G'} (hM : M.IsPerfectMatching) (hM' : M'.IsPerfectMatching) :\n    (M.spanningCoe \u2206 M'.spanningCoe).IsAlternating M'.spanningCoe := by\n  simpa [symmDiff_comm] using isAlternating_symmDiff_left hM' hM\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Matching.lean", "context": {"open": ["Function", "scoped symmDiff"], "variables": ["{V W : Type*} {G G' : SimpleGraph V} {M M' : Subgraph G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Subgraph : ?m.865\nV : Type u_1\nW : Type u_2\nG G' : SimpleGraph V\nM : sorry\nM'\u271d : sorry\nu v w : V\nM' : sorry\nhM : sorry\nhM' : sorry\n\u22a2 sorry"}, {"line": "simpa [symmDiff_comm] using isAlternating_symmDiff_left hM' hM", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_edgeFinset_eq [Fintype G.edgeSet] [Fintype G'.edgeSet] :\n    #G.edgeFinset = #G'.edgeFinset := by\n  apply Finset.card_eq_of_equiv\n  simp only [Set.mem_toFinset]\n  exact f.mapEdgeSet\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Operations.lean", "context": {"open": ["Finset"], "variables": ["{V : Type*} (G : SimpleGraph V) (s t : V)", "{G} {W : Type*} {G' : SimpleGraph W} (f : G \u2243g G')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\nW : Type u_2\nG' : SimpleGraph W\ninst\u271d\u00b9 : Fintype \u2191G.edgeSet\ninst\u271d : Fintype \u2191G'.edgeSet\n\u22a2 G.edgeFinset.card = G'.edgeFinset.card"}, {"line": "apply Finset.card_eq_of_equiv", "tactic_state": "case i\nV : Type u_1\nG : SimpleGraph V\nW : Type u_2\nG' : SimpleGraph W\ninst\u271d\u00b9 : Fintype \u2191G.edgeSet\ninst\u271d : Fintype \u2191G'.edgeSet\n\u22a2 { x // x \u2208 G.edgeFinset } \u2243 { x // x \u2208 G'.edgeFinset }"}, {"line": "simp only [Set.mem_toFinset]", "tactic_state": "case i\nV : Type u_1\nG : SimpleGraph V\nW : Type u_2\nG' : SimpleGraph W\ninst\u271d\u00b9 : Fintype \u2191G.edgeSet\ninst\u271d : Fintype \u2191G'.edgeSet\n\u22a2 { x // x \u2208 G.edgeSet } \u2243 { x // x \u2208 G'.edgeSet }"}, {"line": "exact f.mapEdgeSet", "tactic_state": "No Goals!"}]}
{"declaration": "lemma disjoint_edge {u v : V} : Disjoint G (edge u v) \u2194 \u00acG.Adj u v := by\n  by_cases h : u = v\n  \u00b7 subst h\n    simp [edge_self_eq_bot]\n  simp [\u2190 disjoint_edgeSet, edge_edgeSet_of_ne h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Operations.lean", "context": {"open": ["Finset"], "variables": ["{V : Type*} (G : SimpleGraph V) (s t : V)", "{G} {W : Type*} {G' : SimpleGraph W} (f : G \u2243g G')", "[DecidableEq V]", "{t}", "{s}", "[Fintype V] [DecidableRel G.Adj]", "[DecidableEq V] in", "{s t}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : Fintype V\ninst\u271d : DecidableRel G.Adj\nx\u271d : Sort u_3\nedge : x\u271d\nu v : V\n\u22a2 Disjoint G sorry \u2194 \u00acG.Adj u v"}, {"line": "by_cases h : u = v", "tactic_state": "case pos\nV : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : Fintype V\ninst\u271d : DecidableRel G.Adj\nx\u271d : Sort u_3\nedge : x\u271d\nu v : V\nh : u = v\n\u22a2 Disjoint G sorry \u2194 \u00acG.Adj u v\n---\ncase neg\nV : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : Fintype V\ninst\u271d : DecidableRel G.Adj\nx\u271d : Sort u_3\nedge : x\u271d\nu v : V\nh : \u00acu = v\n\u22a2 Disjoint G sorry \u2194 \u00acG.Adj u v"}, {"line": "\u00b7 subst h\n    simp [edge_self_eq_bot]", "tactic_state": "case neg\nV : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : Fintype V\ninst\u271d : DecidableRel G.Adj\nx\u271d : Sort u_3\nedge : x\u271d\nu v : V\nh : \u00acu = v\n\u22a2 Disjoint G sorry \u2194 \u00acG.Adj u v"}, {"line": "simp [\u2190 disjoint_edgeSet, edge_edgeSet_of_ne h]", "tactic_state": "case neg\nV : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : Fintype V\ninst\u271d : DecidableRel G.Adj\nx\u271d : Sort u_3\nedge : x\u271d\nu v : V\nh : \u00acu = v\n\u22a2 Disjoint G (sorry ()) \u2194 \u00acG.Adj u v"}]}
{"declaration": "lemma sdiff_edge {u v : V} (h : \u00acG.Adj u v) : G \\ edge u v = G := by\n  simp [disjoint_edge, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Operations.lean", "context": {"open": ["Finset"], "variables": ["{V : Type*} (G : SimpleGraph V) (s t : V)", "{G} {W : Type*} {G' : SimpleGraph W} (f : G \u2243g G')", "[DecidableEq V]", "{t}", "{s}", "[Fintype V] [DecidableRel G.Adj]", "[DecidableEq V] in", "{s t}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : Fintype V\ninst\u271d : DecidableRel G.Adj\nx\u271d : Sort u_3\nedge : x\u271d\nu v : V\nh : \u00acG.Adj u v\n\u22a2 G \\ sorry = G"}, {"line": "simp [disjoint_edge, h]", "tactic_state": "V : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : Fintype V\ninst\u271d : DecidableRel G.Adj\nx\u271d : Sort u_3\nedge : x\u271d\nu v : V\nh : \u00acG.Adj u v\n\u22a2 Disjoint G (sorry ())"}]}
{"declaration": "theorem partOfVertex_mem (v : V) : P.partOfVertex v \u2208 P.parts := by\n  obtain \u27e8h, -\u27e9 := (P.isPartition.2 v).choose_spec.1\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Partition.lean", "context": {"open": [], "variables": ["{V : Type u} (G : SimpleGraph V)", "{G}", "(P : G.Partition)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nP : G.Partition\nv : V\n\u22a2 P.partOfVertex v \u2208 P.parts"}, {"line": "obtain \u27e8h, -\u27e9 := (P.isPartition.2 v).choose_spec.1", "tactic_state": "case intro\nV : Type u\nG : SimpleGraph V\nP : G.Partition\nv : V\nh : Exists.choose \u22ef \u2208 P.parts\n\u22a2 P.partOfVertex v \u2208 P.parts"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_partOfVertex (v : V) : v \u2208 P.partOfVertex v := by\n  obtain \u27e8\u27e8_, h\u27e9, _\u27e9 := (P.isPartition.2 v).choose_spec\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Partition.lean", "context": {"open": [], "variables": ["{V : Type u} (G : SimpleGraph V)", "{G}", "(P : G.Partition)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nP : G.Partition\nv : V\n\u22a2 v \u2208 P.partOfVertex v"}, {"line": "obtain \u27e8\u27e8_, h\u27e9, _\u27e9 := (P.isPartition.2 v).choose_spec", "tactic_state": "case intro.intro\nV : Type u\nG : SimpleGraph V\nP : G.Partition\nv : V\nright\u271d : \u2200 (y : Set V), (fun b => b \u2208 P.parts \u2227 v \u2208 b) y \u2192 y = Exists.choose \u22ef\nleft\u271d : Exists.choose \u22ef \u2208 P.parts\nh : v \u2208 Exists.choose \u22ef\n\u22a2 v \u2208 P.partOfVertex v"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem partOfVertex_ne_of_adj {v w : V} (h : G.Adj v w) : P.partOfVertex v \u2260 P.partOfVertex w := by\n  intro hn\n  have hw := P.mem_partOfVertex w\n  rw [\u2190 hn] at hw\n  exact P.independent _ (P.partOfVertex_mem v) (P.mem_partOfVertex v) hw (G.ne_of_adj h) h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Partition.lean", "context": {"open": [], "variables": ["{V : Type u} (G : SimpleGraph V)", "{G}", "(P : G.Partition)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nP : G.Partition\nv w : V\nh : G.Adj v w\n\u22a2 P.partOfVertex v \u2260 P.partOfVertex w"}, {"line": "intro hn", "tactic_state": "V : Type u\nG : SimpleGraph V\nP : G.Partition\nv w : V\nh : G.Adj v w\nhn : P.partOfVertex v = P.partOfVertex w\n\u22a2 False"}, {"line": "have hw := P.mem_partOfVertex w", "tactic_state": "V : Type u\nG : SimpleGraph V\nP : G.Partition\nv w : V\nh : G.Adj v w\nhn : P.partOfVertex v = P.partOfVertex w\nhw : w \u2208 P.partOfVertex w\n\u22a2 False"}, {"line": "rw [\u2190 hn] at hw", "tactic_state": "V : Type u\nG : SimpleGraph V\nP : G.Partition\nv w : V\nh : G.Adj v w\nhn : P.partOfVertex v = P.partOfVertex w\nhw : w \u2208 P.partOfVertex v\n\u22a2 False"}, {"line": "exact P.independent _ (P.partOfVertex_mem v) (P.mem_partOfVertex v) hw (G.ne_of_adj h) h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isTrail_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).IsTrail \u2194 p.IsTrail := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v u' v' : V\np : G.Walk u v\nhu : u = u'\nhv : v = v'\n\u22a2 (p.copy hu hv).IsTrail \u2194 p.IsTrail"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\nu' v' : V\np : G.Walk u' v'\n\u22a2 (p.copy \u22ef \u22ef).IsTrail \u2194 p.IsTrail"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPath_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).IsPath \u2194 p.IsPath := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v u' v' : V\np : G.Walk u v\nhu : u = u'\nhv : v = v'\n\u22a2 (p.copy hu hv).IsPath \u2194 p.IsPath"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\nu' v' : V\np : G.Walk u' v'\n\u22a2 (p.copy \u22ef \u22ef).IsPath \u2194 p.IsPath"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isCircuit_copy {u u'} (p : G.Walk u u) (hu : u = u') :\n    (p.copy hu hu).IsCircuit \u2194 p.IsCircuit := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu u' : V\np : G.Walk u u\nhu : u = u'\n\u22a2 (p.copy hu hu).IsCircuit \u2194 p.IsCircuit"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\nu' : V\np : G.Walk u' u'\n\u22a2 (p.copy \u22ef \u22ef).IsCircuit \u2194 p.IsCircuit"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isCycle_copy {u u'} (p : G.Walk u u) (hu : u = u') :\n    (p.copy hu hu).IsCycle \u2194 p.IsCycle := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu u' : V\np : G.Walk u u\nhu : u = u'\n\u22a2 (p.copy hu hu).IsCycle \u2194 p.IsCycle"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\nu' : V\np : G.Walk u' u'\n\u22a2 (p.copy \u22ef \u22ef).IsCycle \u2194 p.IsCycle"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsTrail.of_cons {u v w : V} {h : G.Adj u v} {p : G.Walk v w} :\n    (cons h p).IsTrail \u2192 p.IsTrail := by simp [isTrail_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nx\u271d : Sort u_1\ncons : x\u271d\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n\u22a2 sorry \u2192 p.IsTrail"}, {"line": "simp [isTrail_def]", "tactic_state": "V : Type u\nG : SimpleGraph V\nx\u271d : Sort u_1\ncons : x\u271d\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n\u22a2 sorry () \u2192 p.IsTrail"}]}
{"declaration": "theorem cons_isTrail_iff {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).IsTrail \u2194 p.IsTrail \u2227 s(u, v) \u2209 p.edges := by simp [isTrail_def, and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nx\u271d : Sort u_1\ncons : x\u271d\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n\u22a2 sorry \u2194 p.IsTrail \u2227 s(u, v) \u2209 p.edges"}, {"line": "simp [isTrail_def, and_comm]", "tactic_state": "V : Type u\nG : SimpleGraph V\nx\u271d : Sort u_1\ncons : x\u271d\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n\u22a2 sorry () \u2194 p.IsTrail \u2227 s(u, v) \u2209 p.edges"}]}
{"declaration": "theorem IsTrail.reverse {u v : V} (p : G.Walk u v) (h : p.IsTrail) : p.reverse.IsTrail := by\n  simpa [isTrail_def] using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nh : p.IsTrail\n\u22a2 p.reverse.IsTrail"}, {"line": "simpa [isTrail_def] using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reverse_isTrail_iff {u v : V} (p : G.Walk u v) : p.reverse.IsTrail \u2194 p.IsTrail := by\n  constructor <;>\n    \u00b7 intro h\n      convert h.reverse _\n      try rw [reverse_reverse]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 p.reverse.IsTrail \u2194 p.IsTrail"}, {"line": "constructor <;>\n    \u00b7 intro h\n      convert h.reverse _\n      try rw [reverse_reverse]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPath.nil {u : V} : (nil : G.Walk u u).IsPath := by constructor <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu : V\n\u22a2 sorry.IsPath"}, {"line": "constructor <;> simp", "tactic_state": "case toIsTrail\nV : Type u\nG : SimpleGraph V\nu : V\n\u22a2 (sorry ()).IsTrail\n---\ncase support_nodup\nV : Type u\nG : SimpleGraph V\nu : V\n\u22a2 (sorry ()).support.Nodup"}]}
{"declaration": "theorem IsPath.of_cons {u v w : V} {h : G.Adj u v} {p : G.Walk v w} :\n    (cons h p).IsPath \u2192 p.IsPath := by simp [isPath_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nx\u271d : Sort u_1\ncons : x\u271d\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n\u22a2 sorry \u2192 p.IsPath"}, {"line": "simp [isPath_def]", "tactic_state": "V : Type u\nG : SimpleGraph V\nx\u271d : Sort u_1\ncons : x\u271d\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n\u22a2 sorry () \u2192 p.IsPath"}]}
{"declaration": "theorem cons_isPath_iff {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).IsPath \u2194 p.IsPath \u2227 u \u2209 p.support := by\n  constructor <;> simp +contextual [isPath_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nx\u271d : Sort u_1\ncons : x\u271d\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n\u22a2 sorry \u2194 p.IsPath \u2227 u \u2209 p.support"}, {"line": "constructor <;> simp +contextual [isPath_def]", "tactic_state": "case mp\nV : Type u\nG : SimpleGraph V\nx\u271d : Sort u_1\ncons : x\u271d\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n\u22a2 sorry () \u2192 p.IsPath \u2227 u \u2209 p.support\n---\ncase mpr\nV : Type u\nG : SimpleGraph V\nx\u271d : Sort u_1\ncons : x\u271d\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n\u22a2 p.IsPath \u2192 u \u2209 p.support \u2192 sorry ()"}]}
{"declaration": "theorem IsPath.reverse {u v : V} {p : G.Walk u v} (h : p.IsPath) : p.reverse.IsPath := by\n  simpa [isPath_def] using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nh : p.IsPath\n\u22a2 p.reverse.IsPath"}, {"line": "simpa [isPath_def] using h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsPath.of_adj {G : SimpleGraph V} {u v : V} (h : G.Adj u v) : h.toWalk.IsPath := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n\u22a2 h.toWalk.IsPath"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCycle.snd_ne_penultimate {p : G.Walk u u} (hp : p.IsCycle) : p.snd \u2260 p.penultimate := by\n  intro h\n  have := hp.three_le_length\n  apply hp.getVert_injOn (by simp; omega) (by simp; omega) at h\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhp : p.IsCycle\n\u22a2 p.snd \u2260 p.penultimate"}, {"line": "intro h", "tactic_state": "V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhp : p.IsCycle\nh : p.snd = p.penultimate\n\u22a2 False"}, {"line": "have := hp.three_le_length", "tactic_state": "V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhp : p.IsCycle\nh : p.snd = p.penultimate\nthis : 3 \u2264 p.length\n\u22a2 False"}, {"line": "apply hp.getVert_injOn (by simp; omega) (by simp; omega) at h", "tactic_state": "V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhp : p.IsCycle\nthis : 3 \u2264 p.length\nh : 1 = p.length - 1\n\u22a2 False"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCycle.getVert_endpoint_iff {i : \u2115} {p : G.Walk u u} (hpc : p.IsCycle) (hl : i \u2264 p.length) :\n    p.getVert i = u \u2194 i = 0 \u2228 i = p.length := by\n  refine \u27e8?_, by aesop\u27e9\n  rw [or_iff_not_imp_left]\n  intro h hi\n  exact hpc.getVert_injOn (by simp only [Set.mem_setOf_eq]; omega)\n    (by simp only [Set.mem_setOf_eq]; omega) (h.symm \u25b8 (Walk.getVert_length p).symm)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu : V\ni : \u2115\np : G.Walk u u\nhpc : p.IsCycle\nhl : i \u2264 p.length\n\u22a2 p.getVert i = u \u2194 i = 0 \u2228 i = p.length"}, {"line": "refine \u27e8?_, by aesop\u27e9", "tactic_state": "V : Type u\nG : SimpleGraph V\nu : V\ni : \u2115\np : G.Walk u u\nhpc : p.IsCycle\nhl : i \u2264 p.length\n\u22a2 p.getVert i = u \u2192 i = 0 \u2228 i = p.length"}, {"line": "rw [or_iff_not_imp_left]", "tactic_state": "V : Type u\nG : SimpleGraph V\nu : V\ni : \u2115\np : G.Walk u u\nhpc : p.IsCycle\nhl : i \u2264 p.length\n\u22a2 p.getVert i = u \u2192 \u00aci = 0 \u2192 i = p.length"}, {"line": "intro h hi", "tactic_state": "V : Type u\nG : SimpleGraph V\nu : V\ni : \u2115\np : G.Walk u u\nhpc : p.IsCycle\nhl : i \u2264 p.length\nh : p.getVert i = u\nhi : \u00aci = 0\n\u22a2 i = p.length"}, {"line": "exact hpc.getVert_injOn (by simp only [Set.mem_setOf_eq]; omega)\n    (by simp only [Set.mem_setOf_eq]; omega) (h.symm \u25b8 (Walk.getVert_length p).symm)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem loop_eq {v : V} (p : G.Path v v) : p = Path.nil := by\n  obtain \u27e8_ | _, h\u27e9 := p\n  \u00b7 rfl\n  \u00b7 simp at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}", "[DecidableEq V]", "{G G'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nv : V\np : G.Path v v\n\u22a2 p = sorry"}, {"line": "obtain \u27e8_ | _, h\u27e9 := p", "tactic_state": "case mk.nil\nV : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nv : V\nh : SimpleGraph.Walk.nil.IsPath\n\u22a2 \u27e8SimpleGraph.Walk.nil, h\u27e9 = sorry\n---\ncase mk.cons\nV : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nv v\u271d : V\nh\u271d : G.Adj v v\u271d\np\u271d : G.Walk v\u271d v\nh : (SimpleGraph.Walk.cons h\u271d p\u271d).IsPath\n\u22a2 \u27e8SimpleGraph.Walk.cons h\u271d p\u271d, h\u27e9 = sorry"}, {"line": "\u00b7 rfl", "tactic_state": "case mk.cons\nV : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nv v\u271d : V\nh\u271d : G.Adj v v\u271d\np\u271d : G.Walk v\u271d v\nh : (SimpleGraph.Walk.cons h\u271d p\u271d).IsPath\n\u22a2 \u27e8SimpleGraph.Walk.cons h\u271d p\u271d, h\u27e9 = sorry"}, {"line": "\u00b7 simp at h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_mem_edges_of_loop {v : V} {e : Sym2 V} {p : G.Path v v} :\n    \u00ace \u2208 (p : G.Walk v v).edges := by simp [p.loop_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}", "[DecidableEq V]", "{G G'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nv : V\ne : Sym2 V\np : G.Path v v\n\u22a2 e \u2209 (\u2191p).edges"}, {"line": "simp [p.loop_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cons_isCycle {u v : V} (p : G.Path v u) (h : G.Adj u v)\n    (he : \u00acs(u, v) \u2208 (p : G.Walk v u).edges) : (Walk.cons h \u2191p).IsCycle := by\n  simp [Walk.isCycle_def, Walk.cons_isTrail_iff, he]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}", "[DecidableEq V]", "{G G'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu v : V\np : G.Path v u\nh : G.Adj u v\nhe : s(u, v) \u2209 (\u2191p).edges\n\u22a2 sorry"}, {"line": "simp [Walk.isCycle_def, Walk.cons_isTrail_iff, he]", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu v : V\np : G.Path v u\nh : G.Adj u v\nhe : s(u, v) \u2209 (\u2191p).edges\n\u22a2 sorry ()"}]}
{"declaration": "theorem bypass_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).bypass = p.bypass.copy hu hv := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}", "[DecidableEq V]", "{G G'}", "{G} [DecidableEq V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu v u' v' : V\np : G.Walk u v\nhu : u = u'\nhv : v = v'\n\u22a2 (p.copy hu hv).bypass = p.bypass.copy hu hv"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu' v' : V\np : G.Walk u' v'\n\u22a2 (p.copy \u22ef \u22ef).bypass = p.bypass.copy \u22ef \u22ef"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toDeleteEdges_copy {v u u' v' : V} (s : Set (Sym2 V))\n    (p : G.Walk u v) (hu : u = u') (hv : v = v') (h) :\n    (p.copy hu hv).toDeleteEdges s h =\n      (p.toDeleteEdges s (by subst_vars; exact h)).copy hu hv := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}", "[DecidableEq V]", "{G G'}", "{G} [DecidableEq V]", "{G G' G''}", "(f : G \u2192g G') {u v : V} (p : G.Walk u v)", "{p f}", "{G G'}", "{G} {u v : V} {H : SimpleGraph V}", "{p : G.Walk u v}", "{v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nv u u' v' : V\ns : Set (Sym2 V)\np : G.Walk u v\nhu : u = u'\nhv : v = v'\nh : \u2200 e \u2208 (p.copy hu hv).edges, e \u2209 s\n\u22a2 SimpleGraph.Walk.toDeleteEdges s (p.copy hu hv) h = (SimpleGraph.Walk.toDeleteEdges s p \u22ef).copy hu hv"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu' v' : V\ns : Set (Sym2 V)\np : G.Walk u' v'\nh : \u2200 e \u2208 (p.copy \u22ef \u22ef).edges, e \u2209 s\n\u22a2 SimpleGraph.Walk.toDeleteEdges s (p.copy \u22ef \u22ef) h = (SimpleGraph.Walk.toDeleteEdges s p \u22ef).copy \u22ef \u22ef"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Reachable.elim_path {p : Prop} {u v : V} (h : G.Reachable u v)\n    (hp : G.Path u v \u2192 p) : p := by classical exact h.elim fun q => hp q.toPath\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}", "[DecidableEq V]", "{G G'}", "{G} [DecidableEq V]", "{G G' G''}", "(f : G \u2192g G') {u v : V} (p : G.Walk u v)", "{p f}", "{G G'}", "{G} {u v : V} {H : SimpleGraph V}", "{p : G.Walk u v}", "{v w : V}", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\np : Prop\nu v : V\nh : G.Reachable u v\nhp : G.Path u v \u2192 p\n\u22a2 p"}, {"line": "classical exact h.elim fun q => hp q.toPath", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_comp (C : G.ConnectedComponent) (\u03c6 : G \u2192g G') (\u03c8 : G' \u2192g G'') :\n    (C.map \u03c6).map \u03c8 = C.map (\u03c8.comp \u03c6) := by\n  refine C.ind ?_\n  exact fun _ => rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}", "[DecidableEq V]", "{G G'}", "{G} [DecidableEq V]", "{G G' G''}", "(f : G \u2192g G') {u v : V} (p : G.Walk u v)", "{p f}", "{G G'}", "{G} {u v : V} {H : SimpleGraph V}", "{p : G.Walk u v}", "{v w : V}", "{G}", "(G)", "{G G' G''}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\ninst\u271d : DecidableEq V\nC : G.ConnectedComponent\n\u03c6 : G \u2192g G'\n\u03c8 : G' \u2192g G''\n\u22a2 SimpleGraph.ConnectedComponent.map \u03c8 (SimpleGraph.ConnectedComponent.map \u03c6 C) =\n    SimpleGraph.ConnectedComponent.map (\u03c8.comp \u03c6) C"}, {"line": "refine C.ind ?_", "tactic_state": "V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\ninst\u271d : DecidableEq V\nC : G.ConnectedComponent\n\u03c6 : G \u2192g G'\n\u03c8 : G' \u2192g G''\n\u22a2 \u2200 (v : V),\n    SimpleGraph.ConnectedComponent.map \u03c8 (SimpleGraph.ConnectedComponent.map \u03c6 (G.connectedComponentMk v)) =\n      SimpleGraph.ConnectedComponent.map (\u03c8.comp \u03c6) (G.connectedComponentMk v)"}, {"line": "exact fun _ => rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem connectedComponentEquiv_symm (\u03c6 : G \u2243g G') :\n    \u03c6.symm.connectedComponentEquiv = \u03c6.connectedComponentEquiv.symm := by\n  ext \u27e8_\u27e9\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}", "[DecidableEq V]", "{G G'}", "{G} [DecidableEq V]", "{G G' G''}", "(f : G \u2192g G') {u v : V} (p : G.Walk u v)", "{p f}", "{G G'}", "{G} {u v : V} {H : SimpleGraph V}", "{p : G.Walk u v}", "{v w : V}", "{G}", "(G)", "{G G' G''}", "{\u03c6 : G \u2243g G'} {v : V} {v' : V'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\ninst\u271d : DecidableEq V\n\u03c6 : G \u2243g G'\n\u22a2 \u03c6.symm.connectedComponentEquiv = \u03c6.connectedComponentEquiv.symm"}, {"line": "ext \u27e8_\u27e9", "tactic_state": "case H.mk.a.h\nV : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\ninst\u271d : DecidableEq V\n\u03c6 : G \u2243g G'\nx\u271d\u00b9 : G'.ConnectedComponent\na\u271d : V'\nx\u271d : V\n\u22a2 x\u271d \u2208 (\u03c6.symm.connectedComponentEquiv (Quot.mk G'.Reachable a\u271d)).supp \u2194\n    x\u271d \u2208 (\u03c6.connectedComponentEquiv.symm (Quot.mk G'.Reachable a\u271d)).supp"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iUnion_connectedComponentSupp (G : SimpleGraph V) :\n    \u22c3 c : G.ConnectedComponent, c.supp = Set.univ := by\n  refine Set.eq_univ_of_forall fun v \u21a6 \u27e8G.connectedComponentMk v, ?_\u27e9\n  simp only [Set.mem_range]\n  simp only [SetLike.mem_coe]\n  exact \u27e8by use G.connectedComponentMk v; exact rfl, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}", "[DecidableEq V]", "{G G'}", "{G} [DecidableEq V]", "{G G' G''}", "(f : G \u2192g G') {u v : V} (p : G.Walk u v)", "{p f}", "{G G'}", "{G} {u v : V} {H : SimpleGraph V}", "{p : G.Walk u v}", "{v w : V}", "{G}", "(G)", "{G G' G''}", "{\u03c6 : G \u2243g G'} {v : V} {v' : V'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d : DecidableEq V\nG : SimpleGraph V\n\u22a2 \u22c3 c, c.supp = Set.univ"}, {"line": "refine Set.eq_univ_of_forall fun v \u21a6 \u27e8G.connectedComponentMk v, ?_\u27e9", "tactic_state": "V : Type u\ninst\u271d : DecidableEq V\nG : SimpleGraph V\nv : V\n\u22a2 (\u2191(G.connectedComponentMk v) \u2208 Set.range fun c => c.supp) \u2227 v \u2208 \u2191(G.connectedComponentMk v)"}, {"line": "simp only [Set.mem_range]", "tactic_state": "V : Type u\ninst\u271d : DecidableEq V\nG : SimpleGraph V\nv : V\n\u22a2 (\u2203 y, y.supp = \u2191(G.connectedComponentMk v)) \u2227 v \u2208 \u2191(G.connectedComponentMk v)"}, {"line": "simp only [SetLike.mem_coe]", "tactic_state": "V : Type u\ninst\u271d : DecidableEq V\nG : SimpleGraph V\nv : V\n\u22a2 (\u2203 y, y.supp = \u2191(G.connectedComponentMk v)) \u2227 v \u2208 G.connectedComponentMk v"}, {"line": "exact \u27e8by use G.connectedComponentMk v; exact rfl, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Preconnected.set_univ_walk_nonempty (hconn : G.Preconnected) (u v : V) :\n    (Set.univ : Set (G.Walk u v)).Nonempty := by\n  rw [\u2190 Set.nonempty_iff_univ_nonempty]\n  exact hconn u v\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Path.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G} {u v w : V}", "[DecidableEq V]", "{G G'}", "{G} [DecidableEq V]", "{G G' G''}", "(f : G \u2192g G') {u v : V} (p : G.Walk u v)", "{p f}", "{G G'}", "{G} {u v : V} {H : SimpleGraph V}", "{p : G.Walk u v}", "{v w : V}", "{G}", "(G)", "{G G' G''}", "{\u03c6 : G \u2243g G'} {v : V} {v' : V'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nhconn : G.Preconnected\nu v : V\n\u22a2 Set.univ.Nonempty"}, {"line": "rw [\u2190 Set.nonempty_iff_univ_nonempty]", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nhconn : G.Preconnected\nu v : V\n\u22a2 Nonempty (G.Walk u v)"}, {"line": "exact hconn u v", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Preconnected.boxProd (hG : G.Preconnected) (hH : H.Preconnected) :\n    (G \u25a1 H).Preconnected := by\n  rintro x y\n  obtain \u27e8w\u2081\u27e9 := hG x.1 y.1\n  obtain \u27e8w\u2082\u27e9 := hH x.2 y.2\n  exact \u27e8(w\u2081.boxProdLeft _ _).append (w\u2082.boxProdRight _ _)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Prod.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{G : SimpleGraph \u03b1} {H : SimpleGraph \u03b2}", "(G H)", "{G}", "(G) {H}", "{G}", "{G H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nhG : G.Preconnected\nhH : H.Preconnected\n\u22a2 (G \u25a1 H).Preconnected"}, {"line": "rintro x y", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nhG : G.Preconnected\nhH : H.Preconnected\nx y : \u03b1 \u00d7 \u03b2\n\u22a2 (G \u25a1 H).Reachable x y"}, {"line": "obtain \u27e8w\u2081\u27e9 := hG x.1 y.1", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nhG : G.Preconnected\nhH : H.Preconnected\nx y : \u03b1 \u00d7 \u03b2\nw\u2081 : G.Walk x.1 y.1\n\u22a2 (G \u25a1 H).Reachable x y"}, {"line": "obtain \u27e8w\u2082\u27e9 := hH x.2 y.2", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nhG : G.Preconnected\nhH : H.Preconnected\nx y : \u03b1 \u00d7 \u03b2\nw\u2081 : G.Walk x.1 y.1\nw\u2082 : H.Walk x.2 y.2\n\u22a2 (G \u25a1 H).Reachable x y"}, {"line": "exact \u27e8(w\u2081.boxProdLeft _ _).append (w\u2082.boxProdRight _ _)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Connected.boxProd (hG : G.Connected) (hH : H.Connected) : (G \u25a1 H).Connected := by\n  haveI := hG.nonempty\n  haveI := hH.nonempty\n  exact \u27e8hG.preconnected.boxProd hH.preconnected\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Prod.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{G : SimpleGraph \u03b1} {H : SimpleGraph \u03b2}", "(G H)", "{G}", "(G) {H}", "{G}", "{G H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nhG : G.Connected\nhH : H.Connected\n\u22a2 (G \u25a1 H).Connected"}, {"line": "haveI := hG.nonempty", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nhG : G.Connected\nhH : H.Connected\nthis : Nonempty \u03b1\n\u22a2 (G \u25a1 H).Connected"}, {"line": "haveI := hH.nonempty", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nhG : G.Connected\nhH : H.Connected\nthis\u271d : Nonempty \u03b1\nthis : Nonempty \u03b2\n\u22a2 (G \u25a1 H).Connected"}, {"line": "exact \u27e8hG.preconnected.boxProd hH.preconnected\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Connected.ofBoxProdLeft (h : (G \u25a1 H).Connected) : G.Connected := by\n  haveI := (nonempty_prod.1 h.nonempty).1\n  haveI := (nonempty_prod.1 h.nonempty).2\n  exact \u27e8h.preconnected.ofBoxProdLeft\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Prod.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{G : SimpleGraph \u03b1} {H : SimpleGraph \u03b2}", "(G H)", "{G}", "(G) {H}", "{G}", "{G H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nh : (G \u25a1 H).Connected\n\u22a2 G.Connected"}, {"line": "haveI := (nonempty_prod.1 h.nonempty).1", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nh : (G \u25a1 H).Connected\nthis : Nonempty \u03b1\n\u22a2 G.Connected"}, {"line": "haveI := (nonempty_prod.1 h.nonempty).2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nh : (G \u25a1 H).Connected\nthis\u271d : Nonempty \u03b1\nthis : Nonempty \u03b2\n\u22a2 G.Connected"}, {"line": "exact \u27e8h.preconnected.ofBoxProdLeft\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Connected.ofBoxProdRight (h : (G \u25a1 H).Connected) : H.Connected := by\n  haveI := (nonempty_prod.1 h.nonempty).1\n  haveI := (nonempty_prod.1 h.nonempty).2\n  exact \u27e8h.preconnected.ofBoxProdRight\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Prod.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{G : SimpleGraph \u03b1} {H : SimpleGraph \u03b2}", "(G H)", "{G}", "(G) {H}", "{G}", "{G H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nh : (G \u25a1 H).Connected\n\u22a2 H.Connected"}, {"line": "haveI := (nonempty_prod.1 h.nonempty).1", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nh : (G \u25a1 H).Connected\nthis : Nonempty \u03b1\n\u22a2 H.Connected"}, {"line": "haveI := (nonempty_prod.1 h.nonempty).2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nh : (G \u25a1 H).Connected\nthis\u271d : Nonempty \u03b1\nthis : Nonempty \u03b2\n\u22a2 H.Connected"}, {"line": "exact \u27e8h.preconnected.ofBoxProdRight\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem boxProd_neighborFinset (x : \u03b1 \u00d7 \u03b2)\n    [Fintype (G.neighborSet x.1)] [Fintype (H.neighborSet x.2)] [Fintype ((G \u25a1 H).neighborSet x)] :\n    (G \u25a1 H).neighborFinset x =\n      (G.neighborFinset x.1 \u00d7\u02e2 {x.2}).disjUnion ({x.1} \u00d7\u02e2 H.neighborFinset x.2)\n        (Finset.disjoint_product.mpr <| Or.inl <| neighborFinset_disjoint_singleton _ _) := by\n  -- swap out the fintype instance for the canonical one\n  letI : Fintype ((G \u25a1 H).neighborSet x) := SimpleGraph.boxProdFintypeNeighborSet _\n  convert_to (G \u25a1 H).neighborFinset x = _ using 2\n  exact Eq.trans (Finset.map_map _ _ _) Finset.attach_map_val\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Prod.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{G : SimpleGraph \u03b1} {H : SimpleGraph \u03b2}", "(G H)", "{G}", "(G) {H}", "{G}", "{G H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nx\u271d : Sort u_4\nneighborFinset_disjoint_singleton : x\u271d\nx : \u03b1 \u00d7 \u03b2\ninst\u271d\u00b2 : Fintype \u2191(G.neighborSet x.1)\ninst\u271d\u00b9 : Fintype \u2191(H.neighborSet x.2)\ninst\u271d : Fintype \u2191((G \u25a1 H).neighborSet x)\n\u22a2 (G \u25a1 H).neighborFinset x = (G.neighborFinset x.1 \u00d7\u02e2 {x.2}).disjUnion ({x.1} \u00d7\u02e2 H.neighborFinset x.2) \u22ef"}, {"line": "letI : Fintype ((G \u25a1 H).neighborSet x) := SimpleGraph.boxProdFintypeNeighborSet _", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nx\u271d : Sort u_4\nneighborFinset_disjoint_singleton : x\u271d\nx : \u03b1 \u00d7 \u03b2\ninst\u271d\u00b2 : Fintype \u2191(G.neighborSet x.1)\ninst\u271d\u00b9 : Fintype \u2191(H.neighborSet x.2)\ninst\u271d : Fintype \u2191((G \u25a1 H).neighborSet x)\nthis : Fintype \u2191((G \u25a1 H).neighborSet x) := sorry\n\u22a2 (G \u25a1 H).neighborFinset x = (G.neighborFinset x.1 \u00d7\u02e2 {x.2}).disjUnion ({x.1} \u00d7\u02e2 H.neighborFinset x.2) \u22ef"}, {"line": "convert_to (G \u25a1 H).neighborFinset x = _ using 2", "tactic_state": "case convert_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nx\u271d : Sort u_4\nneighborFinset_disjoint_singleton : x\u271d\nx : \u03b1 \u00d7 \u03b2\ninst\u271d\u00b2 : Fintype \u2191(G.neighborSet x.1)\ninst\u271d\u00b9 : Fintype \u2191(H.neighborSet x.2)\ninst\u271d : Fintype \u2191((G \u25a1 H).neighborSet x)\nthis : Fintype \u2191((G \u25a1 H).neighborSet x) := sorry\n\u22a2 (G \u25a1 H).neighborFinset x = (G.neighborFinset x.1 \u00d7\u02e2 {x.2}).disjUnion ({x.1} \u00d7\u02e2 H.neighborFinset x.2) \u22ef"}, {"line": "exact Eq.trans (Finset.map_map _ _ _) Finset.attach_map_val", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_neighborFinset_sdiff_inter_eq {v w : V} :\n    (G.neighborFinset v)\u1d9c \\ {v} \u2229 ((G.neighborFinset w)\u1d9c \\ {w}) =\n      ((G.neighborFinset v)\u1d9c \u2229 (G.neighborFinset w)\u1d9c) \\ ({w} \u222a {v}) := by\n  ext\n  rw [\u2190 not_iff_not]\n  simp [imp_iff_not_or, or_assoc, or_comm, or_left_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/StronglyRegular.lean", "context": {"open": ["Finset"], "variables": ["{V : Type u} [Fintype V]", "(G : SimpleGraph V) [DecidableRel G.Adj]", "{G} {n k \u2113 \u03bc : \u2115}", "[DecidableEq V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d\u00b2 : Fintype V\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\nv w : V\n\u22a2 (G.neighborFinset v)\u1d9c \\ {v} \u2229 ((G.neighborFinset w)\u1d9c \\ {w}) =\n    ((G.neighborFinset v)\u1d9c \u2229 (G.neighborFinset w)\u1d9c) \\ ({w} \u222a {v})"}, {"line": "ext", "tactic_state": "case h\nV : Type u\ninst\u271d\u00b2 : Fintype V\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\nv w a\u271d : V\n\u22a2 a\u271d \u2208 (G.neighborFinset v)\u1d9c \\ {v} \u2229 ((G.neighborFinset w)\u1d9c \\ {w}) \u2194\n    a\u271d \u2208 ((G.neighborFinset v)\u1d9c \u2229 (G.neighborFinset w)\u1d9c) \\ ({w} \u222a {v})"}, {"line": "rw [\u2190 not_iff_not]", "tactic_state": "case h\nV : Type u\ninst\u271d\u00b2 : Fintype V\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\nv w a\u271d : V\n\u22a2 a\u271d \u2209 (G.neighborFinset v)\u1d9c \\ {v} \u2229 ((G.neighborFinset w)\u1d9c \\ {w}) \u2194\n    a\u271d \u2209 ((G.neighborFinset v)\u1d9c \u2229 (G.neighborFinset w)\u1d9c) \\ ({w} \u222a {v})"}, {"line": "simp [imp_iff_not_or, or_assoc, or_comm, or_left_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem adj_congr_of_sym2 {H : G.Subgraph} {u v w x : V} (h2 : s(u, v) = s(w, x)) :\n    H.Adj u v \u2194 H.Adj w x := by\n  simp only [Sym2.eq] at h2\n  simp only [Sym2.rel_iff'] at h2\n  simp only [Prod.mk.injEq] at h2\n  simp only [Prod.swap_prod_mk] at h2\n  rcases h2 with hl | hr\n  \u00b7 rw [hl.1, hl.2]\n  \u00b7 rw [hr.1, hr.2, Subgraph.adj_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nu v w x : V\nh2 : s(u, v) = s(w, x)\n\u22a2 H.Adj u v \u2194 H.Adj w x"}, {"line": "simp only [Sym2.eq] at h2", "tactic_state": "V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nu v w x : V\nh2 : Sym2.Rel V (u, v) (w, x)\n\u22a2 H.Adj u v \u2194 H.Adj w x"}, {"line": "simp only [Sym2.rel_iff'] at h2", "tactic_state": "V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nu v w x : V\nh2 : (u, v) = (w, x) \u2228 (u, v) = (w, x).swap\n\u22a2 H.Adj u v \u2194 H.Adj w x"}, {"line": "simp only [Prod.mk.injEq] at h2", "tactic_state": "V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nu v w x : V\nh2 : u = w \u2227 v = x \u2228 (u, v) = (w, x).swap\n\u22a2 H.Adj u v \u2194 H.Adj w x"}, {"line": "simp only [Prod.swap_prod_mk] at h2", "tactic_state": "V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nu v w x : V\nh2 : u = w \u2227 v = x \u2228 (u, v) = (x, w)\n\u22a2 H.Adj u v \u2194 H.Adj w x"}, {"line": "rcases h2 with hl | hr", "tactic_state": "case inl\nV : Type u\nG : SimpleGraph V\nH : G.Subgraph\nu v w x : V\nhl : u = w \u2227 v = x\n\u22a2 H.Adj u v \u2194 H.Adj w x\n---\ncase inr\nV : Type u\nG : SimpleGraph V\nH : G.Subgraph\nu v w x : V\nhr : (u, v) = (x, w)\n\u22a2 H.Adj u v \u2194 H.Adj w x"}, {"line": "\u00b7 rw [hl.1, hl.2]", "tactic_state": "case inr\nV : Type u\nG : SimpleGraph V\nH : G.Subgraph\nu v w x : V\nhr : (u, v) = (x, w)\n\u22a2 H.Adj u v \u2194 H.Adj w x"}, {"line": "\u00b7 rw [hr.1, hr.2, Subgraph.adj_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_of_adj_spanningCoe {v w : V} {s : Set V} (G : SimpleGraph s)\n    (hadj : G.spanningCoe.Adj v w) : v \u2208 s := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nv w : V\ns : Set V\nG : SimpleGraph \u2191s\nhadj : G.spanningCoe.Adj v w\n\u22a2 v \u2208 s"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma spanningCoe_subgraphOfAdj {v w : V} (hadj : G.Adj v w) :\n    (G.subgraphOfAdj hadj).spanningCoe = fromEdgeSet {s(v, w)} := by\n  ext v w\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nx\u271d : Sort u_2\nfromEdgeSet : x\u271d\nv w : V\nhadj : G.Adj v w\n\u22a2 (G.subgraphOfAdj hadj).spanningCoe = sorry"}, {"line": "ext v w", "tactic_state": "case Adj.h.h.a\nV : Type u\nG : SimpleGraph V\nx\u271d : Sort u_2\nfromEdgeSet : x\u271d\nv\u271d w\u271d : V\nhadj : G.Adj v\u271d w\u271d\nv w : V\n\u22a2 (G.subgraphOfAdj hadj).spanningCoe.Adj v w \u2194 sorry.Adj v w"}, {"line": "aesop", "tactic_state": "case mp.inl\nV : Type u\nG : SimpleGraph V\nx : Sort u_2\nfromEdgeSet : x\nv w : V\nhadj : G.Adj v w\nright : \u00acv = w\n\u22a2 (sorry ()).Adj v w\n---\ncase mp.inr\nV : Type u\nG : SimpleGraph V\nx : Sort u_2\nfromEdgeSet : x\nv w : V\nhadj : G.Adj w v\nright : \u00acv = w\n\u22a2 (sorry ()).Adj v w\n---\ncase mpr.left\nV : Type u\nG : SimpleGraph V\nx : Sort u_2\nfromEdgeSet : x\nv_1 w_1 : V\nhadj : G.Adj v_1 w_1\nv w : V\na : (sorry ()).Adj v w\n\u22a2 v = v_1 \u2227 w = w_1 \u2228 v = w_1 \u2227 w = v_1"}]}
{"declaration": "theorem iInf_adj {f : \u03b9 \u2192 G.Subgraph} : (\u2a05 i, f i).Adj a b \u2194 (\u2200 i, (f i).Adj a b) \u2227 G.Adj a b := by\n  simp [iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\na b : V\nf : \u03b9 \u2192 G.Subgraph\n\u22a2 (\u2a05 i, f i).Adj a b \u2194 (\u2200 (i : \u03b9), (f i).Adj a b) \u2227 G.Adj a b"}, {"line": "simp [iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem verts_iSup {f : \u03b9 \u2192 G.Subgraph} : (\u2a06 i, f i).verts = \u22c3 i, (f i).verts := by simp [iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\nf : \u03b9 \u2192 G.Subgraph\n\u22a2 (\u2a06 i, f i).verts = \u22c3 i, (f i).verts"}, {"line": "simp [iSup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem verts_iInf {f : \u03b9 \u2192 G.Subgraph} : (\u2a05 i, f i).verts = \u22c2 i, (f i).verts := by simp [iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\nf : \u03b9 \u2192 G.Subgraph\n\u22a2 (\u2a05 i, f i).verts = \u22c2 i, (f i).verts"}, {"line": "simp [iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neighborSet_sSup (s : Set G.Subgraph) (v : V) :\n    (sSup s).neighborSet v = \u22c3 G' \u2208 s, neighborSet G' v := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nx\u271d : Sort u_2\nneighborSet : x\u271d\ns : Set G.Subgraph\nv : V\n\u22a2 (sSup s).neighborSet v = \u22c3 G' \u2208 s, sorry"}, {"line": "ext", "tactic_state": "case h\nV : Type u\nG : SimpleGraph V\nx\u271d\u00b9 : Sort u_2\nneighborSet : x\u271d\u00b9\ns : Set G.Subgraph\nv x\u271d : V\n\u22a2 x\u271d \u2208 (sSup s).neighborSet v \u2194 x\u271d \u2208 \u22c3 G' \u2208 s, sorry"}, {"line": "simp", "tactic_state": "case h\nV : Type u\nG : SimpleGraph V\nx\u271d\u00b9 : Sort u_2\nneighborSet : x\u271d\u00b9\ns : Set G.Subgraph\nv x\u271d : V\n\u22a2 (\u2203 i \u2208 s, i.Adj v x\u271d) \u2194 (\u2203 x, x \u2208 s) \u2227 x\u271d \u2208 sorry ()"}]}
{"declaration": "theorem neighborSet_sInf (s : Set G.Subgraph) (v : V) :\n    (sInf s).neighborSet v = (\u22c2 G' \u2208 s, neighborSet G' v) \u2229 G.neighborSet v := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nx\u271d : Sort u_2\nneighborSet : x\u271d\ns : Set G.Subgraph\nv : V\n\u22a2 (sInf s).neighborSet v = (\u22c2 G' \u2208 s, sorry) \u2229 G.neighborSet v"}, {"line": "ext", "tactic_state": "case h\nV : Type u\nG : SimpleGraph V\nx\u271d\u00b9 : Sort u_2\nneighborSet : x\u271d\u00b9\ns : Set G.Subgraph\nv x\u271d : V\n\u22a2 x\u271d \u2208 (sInf s).neighborSet v \u2194 x\u271d \u2208 (\u22c2 G' \u2208 s, sorry) \u2229 G.neighborSet v"}, {"line": "simp", "tactic_state": "case h\nV : Type u\nG : SimpleGraph V\nx\u271d\u00b9 : Sort u_2\nneighborSet : x\u271d\u00b9\ns : Set G.Subgraph\nv x\u271d : V\n\u22a2 G.Adj v x\u271d \u2192 ((\u2200 i \u2208 s, i.Adj v x\u271d) \u2194 \u2200 i \u2208 s, x\u271d \u2208 sorry ())"}]}
{"declaration": "theorem neighborSet_iSup (f : \u03b9 \u2192 G.Subgraph) (v : V) :\n    (\u2a06 i, f i).neighborSet v = \u22c3 i, (f i).neighborSet v := by simp [iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\nf : \u03b9 \u2192 G.Subgraph\nv : V\n\u22a2 (\u2a06 i, f i).neighborSet v = \u22c3 i, (f i).neighborSet v"}, {"line": "simp [iSup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neighborSet_iInf (f : \u03b9 \u2192 G.Subgraph) (v : V) :\n    (\u2a05 i, f i).neighborSet v = (\u22c2 i, (f i).neighborSet v) \u2229 G.neighborSet v := by simp [iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\nf : \u03b9 \u2192 G.Subgraph\nv : V\n\u22a2 (\u2a05 i, f i).neighborSet v = (\u22c2 i, (f i).neighborSet v) \u2229 G.neighborSet v"}, {"line": "simp [iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edgeSet_sSup (s : Set G.Subgraph) : (sSup s).edgeSet = \u22c3 G' \u2208 s, edgeSet G' := by\n  ext e\n  induction e\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nx\u271d : Sort u_2\nedgeSet : x\u271d\ns : Set G.Subgraph\n\u22a2 (sSup s).edgeSet = \u22c3 G' \u2208 s, sorry"}, {"line": "ext e", "tactic_state": "case h\nV : Type u\nG : SimpleGraph V\nx\u271d : Sort u_2\nedgeSet : x\u271d\ns : Set G.Subgraph\ne : Sym2 V\n\u22a2 e \u2208 (sSup s).edgeSet \u2194 e \u2208 \u22c3 G' \u2208 s, sorry"}, {"line": "induction e", "tactic_state": "case h.h\nV : Type u\nG : SimpleGraph V\nx\u271d\u00b9 : Sort u_2\nedgeSet : x\u271d\u00b9\ns : Set G.Subgraph\nx\u271d y\u271d : V\n\u22a2 s(x\u271d, y\u271d) \u2208 (sSup s).edgeSet \u2194 s(x\u271d, y\u271d) \u2208 \u22c3 G' \u2208 s, sorry"}, {"line": "simp", "tactic_state": "case h.h\nV : Type u\nG : SimpleGraph V\nx\u271d\u00b9 : Sort u_2\nedgeSet : x\u271d\u00b9\ns : Set G.Subgraph\nx\u271d y\u271d : V\n\u22a2 (\u2203 i \u2208 s, i.Adj x\u271d y\u271d) \u2194 (\u2203 x, x \u2208 s) \u2227 s(x\u271d, y\u271d) \u2208 sorry ()"}]}
{"declaration": "theorem edgeSet_sInf (s : Set G.Subgraph) :\n    (sInf s).edgeSet = (\u22c2 G' \u2208 s, edgeSet G') \u2229 G.edgeSet := by\n  ext e\n  induction e\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nx\u271d : Sort u_2\nedgeSet : x\u271d\ns : Set G.Subgraph\n\u22a2 (sInf s).edgeSet = (\u22c2 G' \u2208 s, sorry) \u2229 G.edgeSet"}, {"line": "ext e", "tactic_state": "case h\nV : Type u\nG : SimpleGraph V\nx\u271d : Sort u_2\nedgeSet : x\u271d\ns : Set G.Subgraph\ne : Sym2 V\n\u22a2 e \u2208 (sInf s).edgeSet \u2194 e \u2208 (\u22c2 G' \u2208 s, sorry) \u2229 G.edgeSet"}, {"line": "induction e", "tactic_state": "case h.h\nV : Type u\nG : SimpleGraph V\nx\u271d\u00b9 : Sort u_2\nedgeSet : x\u271d\u00b9\ns : Set G.Subgraph\nx\u271d y\u271d : V\n\u22a2 s(x\u271d, y\u271d) \u2208 (sInf s).edgeSet \u2194 s(x\u271d, y\u271d) \u2208 (\u22c2 G' \u2208 s, sorry) \u2229 G.edgeSet"}, {"line": "simp", "tactic_state": "case h.h\nV : Type u\nG : SimpleGraph V\nx\u271d\u00b9 : Sort u_2\nedgeSet : x\u271d\u00b9\ns : Set G.Subgraph\nx\u271d y\u271d : V\n\u22a2 G.Adj x\u271d y\u271d \u2192 ((\u2200 i \u2208 s, i.Adj x\u271d y\u271d) \u2194 \u2200 i \u2208 s, s(x\u271d, y\u271d) \u2208 sorry ())"}]}
{"declaration": "theorem edgeSet_iSup (f : \u03b9 \u2192 G.Subgraph) :\n    (\u2a06 i, f i).edgeSet = \u22c3 i, (f i).edgeSet := by simp [iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\nf : \u03b9 \u2192 G.Subgraph\n\u22a2 (\u2a06 i, f i).edgeSet = \u22c3 i, (f i).edgeSet"}, {"line": "simp [iSup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edgeSet_iInf (f : \u03b9 \u2192 G.Subgraph) :\n    (\u2a05 i, f i).edgeSet = (\u22c2 i, (f i).edgeSet) \u2229 G.edgeSet := by\n  simp [iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\nf : \u03b9 \u2192 G.Subgraph\n\u22a2 (\u2a05 i, f i).edgeSet = (\u22c2 i, (f i).edgeSet) \u2229 G.edgeSet"}, {"line": "simp [iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_comp {U : Type*} {G'' : SimpleGraph U} (H : G.Subgraph) (f : G \u2192g G') (g : G' \u2192g G'') :\n    H.map (g.comp f) = (H.map f).map g := by ext <;> simp [Subgraph.map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nU : Type u_2\nG'' : SimpleGraph U\nH : G.Subgraph\nf : G \u2192g G'\ng : G' \u2192g G''\n\u22a2 SimpleGraph.Subgraph.map (g.comp f) H = SimpleGraph.Subgraph.map g (SimpleGraph.Subgraph.map f H)"}, {"line": "ext <;> simp [Subgraph.map]", "tactic_state": "case Adj.h.h.a\nV : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nU : Type u_2\nG'' : SimpleGraph U\nH : G.Subgraph\nf : G \u2192g G'\ng : G' \u2192g G''\nx\u271d\u00b9 x\u271d : U\n\u22a2 Relation.Map H.Adj (\u21d1g \u2218 \u21d1f) (\u21d1g \u2218 \u21d1f) x\u271d\u00b9 x\u271d \u2194 Relation.Map (SimpleGraph.Subgraph.map f H).Adj (\u21d1g) (\u21d1g) x\u271d\u00b9 x\u271d"}]}
{"declaration": "theorem map_sup (f : G \u2192g G') (H\u2081 H\u2082 : G.Subgraph) : (H\u2081 \u2294 H\u2082).map f = H\u2081.map f \u2294 H\u2082.map f := by\n  ext <;> simp [Set.image_union, map_adj, sup_adj, Relation.Map, or_and_right, exists_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G \u2192g G'\nH\u2081 H\u2082 : G.Subgraph\n\u22a2 SimpleGraph.Subgraph.map f (H\u2081 \u2294 H\u2082) = SimpleGraph.Subgraph.map f H\u2081 \u2294 SimpleGraph.Subgraph.map f H\u2082"}, {"line": "ext <;> simp [Set.image_union, map_adj, sup_adj, Relation.Map, or_and_right, exists_or]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singletonSubgraph_le_iff (v : V) (H : G.Subgraph) :\n    G.singletonSubgraph v \u2264 H \u2194 v \u2208 H.verts := by\n  refine \u27e8fun h \u21a6 h.1 (Set.mem_singleton v), ?_\u27e9\n  intro h\n  constructor\n  \u00b7 rwa [singletonSubgraph_verts, Set.singleton_subset_iff]\n  \u00b7 exact fun _ _ \u21a6 False.elim\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nv : V\nH : G.Subgraph\n\u22a2 G.singletonSubgraph v \u2264 H \u2194 v \u2208 H.verts"}, {"line": "refine \u27e8fun h \u21a6 h.1 (Set.mem_singleton v), ?_\u27e9", "tactic_state": "V : Type u\nG : SimpleGraph V\nv : V\nH : G.Subgraph\n\u22a2 v \u2208 H.verts \u2192 G.singletonSubgraph v \u2264 H"}, {"line": "intro h", "tactic_state": "V : Type u\nG : SimpleGraph V\nv : V\nH : G.Subgraph\nh : v \u2208 H.verts\n\u22a2 G.singletonSubgraph v \u2264 H"}, {"line": "constructor", "tactic_state": "case left\nV : Type u\nG : SimpleGraph V\nv : V\nH : G.Subgraph\nh : v \u2208 H.verts\n\u22a2 (G.singletonSubgraph v).verts \u2286 H.verts\n---\ncase right\nV : Type u\nG : SimpleGraph V\nv : V\nH : G.Subgraph\nh : v \u2208 H.verts\n\u22a2 \u2200 \u2983v_1 w : V\u2984, (G.singletonSubgraph v).Adj v_1 w \u2192 H.Adj v_1 w"}, {"line": "\u00b7 rwa [singletonSubgraph_verts, Set.singleton_subset_iff]", "tactic_state": "case right\nV : Type u\nG : SimpleGraph V\nv : V\nH : G.Subgraph\nh : v \u2208 H.verts\n\u22a2 \u2200 \u2983v_1 w : V\u2984, (G.singletonSubgraph v).Adj v_1 w \u2192 H.Adj v_1 w"}, {"line": "\u00b7 exact fun _ _ \u21a6 False.elim", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subgraphOfAdj_symm {v w : V} (hvw : G.Adj v w) :\n    G.subgraphOfAdj hvw.symm = G.subgraphOfAdj hvw := by\n  ext <;> simp [or_comm, and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nv w : V\nhvw : G.Adj v w\n\u22a2 G.subgraphOfAdj \u22ef = G.subgraphOfAdj hvw"}, {"line": "ext <;> simp [or_comm, and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neighborSet_fst_subgraphOfAdj {v w : V} (hvw : G.Adj v w) :\n    (G.subgraphOfAdj hvw).neighborSet v = {w} := by\n  ext u\n  suffices w = u \u2194 u = w by simpa [hvw.ne.symm] using this\n  rw [eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nv w : V\nhvw : G.Adj v w\n\u22a2 (G.subgraphOfAdj hvw).neighborSet v = {w}"}, {"line": "ext u", "tactic_state": "case h\nV : Type u\nG : SimpleGraph V\nv w : V\nhvw : G.Adj v w\nu : V\n\u22a2 u \u2208 (G.subgraphOfAdj hvw).neighborSet v \u2194 u \u2208 {w}"}, {"line": "suffices w = u \u2194 u = w by simpa [hvw.ne.symm] using this", "tactic_state": "case h\nV : Type u\nG : SimpleGraph V\nv w : V\nhvw : G.Adj v w\nu : V\n\u22a2 w = u \u2194 u = w"}, {"line": "rw [eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neighborSet_subgraphOfAdj_of_ne_of_ne {u v w : V} (hvw : G.Adj v w) (hv : u \u2260 v)\n    (hw : u \u2260 w) : (G.subgraphOfAdj hvw).neighborSet u = \u2205 := by\n  ext\n  simp [hv.symm, hw.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w : V\nhvw : G.Adj v w\nhv : u \u2260 v\nhw : u \u2260 w\n\u22a2 (G.subgraphOfAdj hvw).neighborSet u = \u2205"}, {"line": "ext", "tactic_state": "case h\nV : Type u\nG : SimpleGraph V\nu v w : V\nhvw : G.Adj v w\nhv : u \u2260 v\nhw : u \u2260 w\nx\u271d : V\n\u22a2 x\u271d \u2208 (G.subgraphOfAdj hvw).neighborSet u \u2194 x\u271d \u2208 \u2205"}, {"line": "simp [hv.symm, hw.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neighborSet_subgraphOfAdj [DecidableEq V] {u v w : V} (hvw : G.Adj v w) :\n    (G.subgraphOfAdj hvw).neighborSet u =\n    (if u = v then {w} else \u2205) \u222a if u = w then {v} else \u2205 := by\n  split_ifs <;> subst_vars <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu v w : V\nhvw : G.Adj v w\n\u22a2 (G.subgraphOfAdj hvw).neighborSet u = (if u = v then {w} else \u2205) \u222a if u = w then {v} else \u2205"}, {"line": "split_ifs <;> subst_vars <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singletonSubgraph_fst_le_subgraphOfAdj {u v : V} {h : G.Adj u v} :\n    G.singletonSubgraph u \u2264 G.subgraphOfAdj h := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n\u22a2 G.singletonSubgraph u \u2264 G.subgraphOfAdj h"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singletonSubgraph_snd_le_subgraphOfAdj {u v : V} {h : G.Adj u v} :\n    G.singletonSubgraph v \u2264 G.subgraphOfAdj h := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n\u22a2 G.singletonSubgraph v \u2264 G.subgraphOfAdj h"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coeSubgraph_adj {G' : G.Subgraph} (G'' : G'.coe.Subgraph) (v w : V) :\n    (G'.coeSubgraph G'').Adj v w \u2194\n      \u2203 (hv : v \u2208 G'.verts) (hw : w \u2208 G'.verts), G''.Adj \u27e8v, hv\u27e9 \u27e8w, hw\u27e9 := by\n  simp [Relation.Map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}", "{G : SimpleGraph V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nG'' : G'.coe.Subgraph\nv w : V\n\u22a2 (SimpleGraph.Subgraph.coeSubgraph G'').Adj v w \u2194 \u2203 (hv : v \u2208 G'.verts) (hw : w \u2208 G'.verts), G''.Adj \u27e8v, hv\u27e9 \u27e8w, hw\u27e9"}, {"line": "simp [Relation.Map]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coeSubgraph_le {H : G.Subgraph} (H' : H.coe.Subgraph) :\n    Subgraph.coeSubgraph H' \u2264 H := by\n  constructor\n  \u00b7 simp\n  \u00b7 rintro v w \u27e8_, _, h, rfl, rfl\u27e9\n    exact H'.adj_sub h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}", "{G : SimpleGraph V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nH' : H.coe.Subgraph\n\u22a2 sorry \u2264 H"}, {"line": "constructor", "tactic_state": "case left\nV : Type u\nG : SimpleGraph V\nH : G.Subgraph\nH' : H.coe.Subgraph\n\u22a2 sorry.verts \u2286 H.verts\n---\ncase right\nV : Type u\nG : SimpleGraph V\nH : G.Subgraph\nH' : H.coe.Subgraph\n\u22a2 \u2200 \u2983v w : V\u2984, sorry.Adj v w \u2192 H.Adj v w"}, {"line": "\u00b7 simp", "tactic_state": "case right\nV : Type u\nG : SimpleGraph V\nH : G.Subgraph\nH' : H.coe.Subgraph\n\u22a2 \u2200 \u2983v w : V\u2984, sorry.Adj v w \u2192 H.Adj v w"}, {"line": "\u00b7 rintro v w \u27e8_, _, h, rfl, rfl\u27e9\n    exact H'.adj_sub h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deleteEdges_deleteEdges (s s' : Set (Sym2 V)) :\n    (G'.deleteEdges s).deleteEdges s' = G'.deleteEdges (s \u222a s') := by\n  ext <;> simp [and_assoc, not_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}", "{G : SimpleGraph V}", "{G' : G.Subgraph} (s : Set (Sym2 V))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns s' : Set (Sym2 V)\n\u22a2 (G'.deleteEdges s).deleteEdges s' = G'.deleteEdges (s \u222a s')"}, {"line": "ext <;> simp [and_assoc, not_or]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deleteEdges_empty_eq : G'.deleteEdges \u2205 = G' := by\n  ext <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}", "{G : SimpleGraph V}", "{G' : G.Subgraph} (s : Set (Sym2 V))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\n\u22a2 G'.deleteEdges \u2205 = G'"}, {"line": "ext <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deleteEdges_spanningCoe_eq :\n    G'.spanningCoe.deleteEdges s = (G'.deleteEdges s).spanningCoe := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}", "{G : SimpleGraph V}", "{G' : G.Subgraph} (s : Set (Sym2 V))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set (Sym2 V)\n\u22a2 G'.spanningCoe.deleteEdges s = (G'.deleteEdges s).spanningCoe"}, {"line": "ext", "tactic_state": "case Adj.h.h.a\nV : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set (Sym2 V)\nx\u271d\u00b9 x\u271d : V\n\u22a2 (G'.spanningCoe.deleteEdges s).Adj x\u271d\u00b9 x\u271d \u2194 (G'.deleteEdges s).spanningCoe.Adj x\u271d\u00b9 x\u271d"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_deleteEdges_eq (s : Set (Sym2 V)) :\n    (G'.deleteEdges s).coe = G'.coe.deleteEdges (Sym2.map (\u2191) \u207b\u00b9' s) := by\n  ext \u27e8v, hv\u27e9 \u27e8w, hw\u27e9\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}", "{G : SimpleGraph V}", "{G' : G.Subgraph} (s : Set (Sym2 V))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set (Sym2 V)\n\u22a2 (G'.deleteEdges s).coe = G'.coe.deleteEdges (Sym2.map Subtype.val \u207b\u00b9' s)"}, {"line": "ext \u27e8v, hv\u27e9 \u27e8w, hw\u27e9", "tactic_state": "case Adj.h.mk.h.mk.a\nV : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set (Sym2 V)\nv : V\nhv : v \u2208 (G'.deleteEdges s).verts\nw : V\nhw : w \u2208 (G'.deleteEdges s).verts\n\u22a2 (G'.deleteEdges s).coe.Adj \u27e8v, hv\u27e9 \u27e8w, hw\u27e9 \u2194 (G'.coe.deleteEdges (Sym2.map Subtype.val \u207b\u00b9' s)).Adj \u27e8v, hv\u27e9 \u27e8w, hw\u27e9"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deleteEdges_le : G'.deleteEdges s \u2264 G' := by\n  constructor <;> simp +contextual [subset_rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}", "{G : SimpleGraph V}", "{G' : G.Subgraph} (s : Set (Sym2 V))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set (Sym2 V)\n\u22a2 G'.deleteEdges s \u2264 G'"}, {"line": "constructor <;> simp +contextual [subset_rfl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deleteEdges_inter_edgeSet_left_eq :\n    G'.deleteEdges (G'.edgeSet \u2229 s) = G'.deleteEdges s := by\n  ext <;> simp +contextual [imp_false]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}", "{G : SimpleGraph V}", "{G' : G.Subgraph} (s : Set (Sym2 V))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set (Sym2 V)\n\u22a2 G'.deleteEdges (G'.edgeSet \u2229 s) = G'.deleteEdges s"}, {"line": "ext <;> simp +contextual [imp_false]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem induce_empty : G'.induce \u2205 = \u22a5 := by\n  ext <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}", "{G : SimpleGraph V}", "{G' : G.Subgraph} (s : Set (Sym2 V))", "{G' G'' : G.Subgraph} {s s' : Set V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\n\u22a2 G'.induce \u2205 = \u22a5"}, {"line": "ext <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singletonSubgraph_eq_induce {v : V} :\n    G.singletonSubgraph v = (\u22a4 : G.Subgraph).induce {v} := by\n  ext <;> simp +contextual [-Set.bot_eq_empty, Prop.bot_eq_false]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}", "{G : SimpleGraph V}", "{G' : G.Subgraph} (s : Set (Sym2 V))", "{G' G'' : G.Subgraph} {s s' : Set V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nv : V\n\u22a2 G.singletonSubgraph v = \u22a4.induce {v}"}, {"line": "ext <;> simp +contextual [-Set.bot_eq_empty, Prop.bot_eq_false]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deleteVerts_adj {u v : V} :\n    (G'.deleteVerts s).Adj u v \u2194 u \u2208 G'.verts \u2227 \u00acu \u2208 s \u2227 v \u2208 G'.verts \u2227 \u00acv \u2208 s \u2227 G'.Adj u v := by\n  simp [and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}", "{G : SimpleGraph V}", "{G' : G.Subgraph} (s : Set (Sym2 V))", "{G' G'' : G.Subgraph} {s s' : Set V}", "{G' : G.Subgraph} {s : Set V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set V\nu v : V\n\u22a2 (G'.deleteVerts s).Adj u v \u2194 u \u2208 G'.verts \u2227 u \u2209 s \u2227 v \u2208 G'.verts \u2227 v \u2209 s \u2227 G'.Adj u v"}, {"line": "simp [and_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deleteVerts_deleteVerts (s s' : Set V) :\n    (G'.deleteVerts s).deleteVerts s' = G'.deleteVerts (s \u222a s') := by\n  ext <;> simp +contextual [not_or, and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}", "{G : SimpleGraph V}", "{G' : G.Subgraph} (s : Set (Sym2 V))", "{G' G'' : G.Subgraph} {s s' : Set V}", "{G' : G.Subgraph} {s : Set V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns s' : Set V\n\u22a2 (G'.deleteVerts s).deleteVerts s' = G'.deleteVerts (s \u222a s')"}, {"line": "ext <;> simp +contextual [not_or, and_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deleteVerts_empty : G'.deleteVerts \u2205 = G' := by\n  simp [deleteVerts]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}", "{G : SimpleGraph V}", "{G' : G.Subgraph} (s : Set (Sym2 V))", "{G' G'' : G.Subgraph} {s s' : Set V}", "{G' : G.Subgraph} {s : Set V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\n\u22a2 G'.deleteVerts \u2205 = G'"}, {"line": "simp [deleteVerts]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deleteVerts_le : G'.deleteVerts s \u2264 G' := by\n  constructor <;> simp [Set.diff_subset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}", "{G : SimpleGraph V}", "{G' : G.Subgraph} (s : Set (Sym2 V))", "{G' G'' : G.Subgraph} {s s' : Set V}", "{G' : G.Subgraph} {s : Set V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set V\n\u22a2 G'.deleteVerts s \u2264 G'"}, {"line": "constructor <;> simp [Set.diff_subset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deleteVerts_inter_verts_left_eq : G'.deleteVerts (G'.verts \u2229 s) = G'.deleteVerts s := by\n  ext <;> simp +contextual [imp_false]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}", "{G : SimpleGraph V}", "{G' : G.Subgraph} (s : Set (Sym2 V))", "{G' G'' : G.Subgraph} {s s' : Set V}", "{G' : G.Subgraph} {s : Set V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set V\n\u22a2 G'.deleteVerts (G'.verts \u2229 s) = G'.deleteVerts s"}, {"line": "ext <;> simp +contextual [imp_false]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deleteVerts_inter_verts_set_right_eq :\n    G'.deleteVerts (s \u2229 G'.verts) = G'.deleteVerts s := by\n  ext <;> simp +contextual [imp_false]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {V : Type u} {W : Type v}", "{G : SimpleGraph V} {G\u2081 G\u2082 : G.Subgraph} {a b : V}", "{G' : SimpleGraph W} {f : G \u2192g G'}", "{G : SimpleGraph V} {G' : SimpleGraph W}", "{G : SimpleGraph V}", "{G' : G.Subgraph} (s : Set (Sym2 V))", "{G' G'' : G.Subgraph} {s s' : Set V}", "{G' : G.Subgraph} {s : Set V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set V\n\u22a2 G'.deleteVerts (s \u2229 G'.verts) = G'.deleteVerts s"}, {"line": "ext <;> simp +contextual [imp_false]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Coloring.sum_sumLeft_sumRight (c : (G \u2295g H).Coloring \u03b3) : c.sumLeft.sum c.sumRight = c := by\n  ext (u | u) <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Sum.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{G : SimpleGraph \u03b1} {H : SimpleGraph \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nc : (G \u2295g H).Coloring \u03b3\n\u22a2 c.sumLeft.sum c.sumRight = c"}, {"line": "ext (u | u) <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsTuranMaximal.le_iff_eq (hG : G.IsTuranMaximal r) (hH : H.CliqueFree (r + 1)) :\n    G \u2264 H \u2194 G = H := by\n  classical exact \u27e8fun hGH \u21a6 edgeFinset_inj.1 <| eq_of_subset_of_card_le\n    (edgeFinset_subset_edgeFinset.2 hGH) (hG.2 _ hH), le_of_eq\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Turan.lean", "context": {"open": ["Finset"], "variables": ["{V : Type*} [Fintype V] {G : SimpleGraph V} [DecidableRel G.Adj] {n r : \u2115}", "(G) in", "{H : SimpleGraph V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b9 : Fintype V\nG : SimpleGraph V\ninst\u271d : DecidableRel G.Adj\nr : \u2115\nH : SimpleGraph V\nhG : G.IsTuranMaximal r\nhH : H.CliqueFree (r + 1)\n\u22a2 G \u2264 H \u2194 G = H"}, {"line": "classical exact \u27e8fun hGH \u21a6 edgeFinset_inj.1 <| eq_of_subset_of_card_le\n    (edgeFinset_subset_edgeFinset.2 hGH) (hG.2 _ hH), le_of_eq\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_cliqueFree_of_isTuranMaximal (hn : r \u2264 Fintype.card V) (hG : G.IsTuranMaximal r) :\n    \u00acG.CliqueFree r := by\n  rintro h\n  obtain \u27e8K, _, rfl\u27e9 := exists_subset_card_eq hn\n  obtain \u27e8a, -, b, -, hab, hGab\u27e9 : \u2203 a \u2208 K, \u2203 b \u2208 K, a \u2260 b \u2227 \u00ac G.Adj a b := by\n    simpa only [isNClique_iff,IsClique,Set.Pairwise,mem_coe,ne_eq,and_true,not_forall,exists_prop,exists_and_right] using h K\n  exact hGab <| le_sup_right.trans_eq ((hG.le_iff_eq <| h.sup_edge _ _).1 le_sup_left).symm <|\n    (edge_adj ..).2 \u27e8Or.inl \u27e8rfl, rfl\u27e9, hab\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Turan.lean", "context": {"open": ["Finset"], "variables": ["{V : Type*} [Fintype V] {G : SimpleGraph V} [DecidableRel G.Adj] {n r : \u2115}", "(G) in", "{H : SimpleGraph V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b9 : Fintype V\nG : SimpleGraph V\ninst\u271d : DecidableRel G.Adj\nr : \u2115\nhn : r \u2264 Fintype.card V\nhG : G.IsTuranMaximal r\n\u22a2 \u00acG.CliqueFree r"}, {"line": "rintro h", "tactic_state": "V : Type u_1\ninst\u271d\u00b9 : Fintype V\nG : SimpleGraph V\ninst\u271d : DecidableRel G.Adj\nr : \u2115\nhn : r \u2264 Fintype.card V\nhG : G.IsTuranMaximal r\nh : G.CliqueFree r\n\u22a2 False"}, {"line": "obtain \u27e8K, _, rfl\u27e9 := exists_subset_card_eq hn", "tactic_state": "case intro.intro\nV : Type u_1\ninst\u271d\u00b9 : Fintype V\nG : SimpleGraph V\ninst\u271d : DecidableRel G.Adj\nK : Finset V\nleft\u271d : K \u2286 univ\nhn : K.card \u2264 Fintype.card V\nhG : G.IsTuranMaximal K.card\nh : G.CliqueFree K.card\n\u22a2 False"}, {"line": "obtain \u27e8a, -, b, -, hab, hGab\u27e9 : \u2203 a \u2208 K, \u2203 b \u2208 K, a \u2260 b \u2227 \u00ac G.Adj a b := by\n    simpa only [isNClique_iff,IsClique,Set.Pairwise,mem_coe,ne_eq,and_true,not_forall,exists_prop,exists_and_right] using h K", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro\nV : Type u_1\ninst\u271d\u00b9 : Fintype V\nG : SimpleGraph V\ninst\u271d : DecidableRel G.Adj\nK : Finset V\nleft\u271d : K \u2286 univ\nhn : K.card \u2264 Fintype.card V\nhG : G.IsTuranMaximal K.card\nh : G.CliqueFree K.card\na b : V\nhab : a \u2260 b\nhGab : \u00acG.Adj a b\n\u22a2 False"}, {"line": "exact hGab <| le_sup_right.trans_eq ((hG.le_iff_eq <| h.sup_edge _ _).1 le_sup_left).symm <|\n    (edge_adj ..).2 \u27e8Or.inl \u27e8rfl, rfl\u27e9, hab\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem copy_copy {u v u' v' u'' v''} (p : G.Walk u v)\n    (hu : u = u') (hv : v = v') (hu' : u' = u'') (hv' : v' = v'') :\n    (p.copy hu hv).copy hu' hv' = p.copy (hu.trans hu') (hv.trans hv') := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v u' v' u'' v'' : V\np : G.Walk u v\nhu : u = u'\nhv : v = v'\nhu' : u' = u''\nhv' : v' = v''\n\u22a2 (p.copy hu hv).copy hu' hv' = p.copy \u22ef \u22ef"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\nu'' v'' : V\np : G.Walk u'' v''\n\u22a2 (p.copy \u22ef \u22ef).copy \u22ef \u22ef = p.copy \u22ef \u22ef"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem copy_nil {u u'} (hu : u = u') : (Walk.nil : G.Walk u u).copy hu hu = Walk.nil := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu u' : V\nhu : u = u'\n\u22a2 sorry.copy hu hu = sorry"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\nu' : V\n\u22a2 sorry.copy \u22ef \u22ef = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem copy_cons {u v w u' w'} (h : G.Adj u v) (p : G.Walk v w) (hu : u = u') (hw : w = w') :\n    (Walk.cons h p).copy hu hw = Walk.cons (hu \u25b8 h) (p.copy rfl hw) := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w u' w' : V\nh : G.Adj u v\np : G.Walk v w\nhu : u = u'\nhw : w = w'\n\u22a2 sorry = sorry"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\nv u' w' : V\nh : G.Adj u' v\np : G.Walk v w'\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cons_copy {u v w v' w'} (h : G.Adj u v) (p : G.Walk v' w') (hv : v' = v) (hw : w' = w) :\n    Walk.cons h (p.copy hv hw) = (Walk.cons (hv \u25b8 h) p).copy rfl hw := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w v' w' : V\nh : G.Adj u v\np : G.Walk v' w'\nhv : v' = v\nhw : w' = w\n\u22a2 sorry = sorry"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v' w' : V\np : G.Walk v' w'\nh : G.Adj u v'\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem getVert_zero {u v} (w : G.Walk u v) : w.getVert 0 = u := by cases w <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\nw : G.Walk u v\n\u22a2 w.getVert 0 = u"}, {"line": "cases w <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem append_copy_copy {u v w u' v' w'} (p : G.Walk u v) (q : G.Walk v w)\n    (hu : u = u') (hv : v = v') (hw : w = w') :\n    (p.copy hu hv).append (q.copy hv hw) = (p.append q).copy hu hw := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w u' v' w' : V\np : G.Walk u v\nq : G.Walk v w\nhu : u = u'\nhv : v = v'\nhw : w = w'\n\u22a2 (p.copy hu hv).append (q.copy hv hw) = (p.append q).copy hu hw"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\nu' v' w' : V\np : G.Walk u' v'\nq : G.Walk v' w'\n\u22a2 (p.copy \u22ef \u22ef).append (q.copy \u22ef \u22ef) = (p.append q).copy \u22ef \u22ef"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reverse_cons {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).reverse = p.reverse.append (cons (G.symm h) nil) := by simp [reverse]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nx\u271d : Sort u_1\ncons : x\u271d\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n\u22a2 sorry = p.reverse.append sorry"}, {"line": "simp [reverse]", "tactic_state": "V : Type u\nG : SimpleGraph V\nx\u271d : Sort u_1\ncons : x\u271d\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n\u22a2 sorry () = p.reverse.append (sorry ())"}]}
{"declaration": "theorem reverse_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).reverse = p.reverse.copy hv hu := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v u' v' : V\np : G.Walk u v\nhu : u = u'\nhv : v = v'\n\u22a2 (p.copy hu hv).reverse = p.reverse.copy hv hu"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\nu' v' : V\np : G.Walk u' v'\n\u22a2 (p.copy \u22ef \u22ef).reverse = p.reverse.copy \u22ef \u22ef"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reverse_append {u v w : V} (p : G.Walk u v) (q : G.Walk v w) :\n    (p.append q).reverse = q.reverse.append p.reverse := by simp [reverse]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nq : G.Walk v w\n\u22a2 (p.append q).reverse = q.reverse.append p.reverse"}, {"line": "simp [reverse]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reverse_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).reverse = cons (G.symm h) p.reverse := by simp [concat_eq_append]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nx\u271d : Sort u_1\ncons : x\u271d\nu v w : V\np : G.Walk u v\nh : G.Adj v w\n\u22a2 (p.concat h).reverse = sorry"}, {"line": "simp [concat_eq_append]", "tactic_state": "V : Type u\nG : SimpleGraph V\nx\u271d : Sort u_1\ncons : x\u271d\nu v w : V\np : G.Walk u v\nh : G.Adj v w\n\u22a2 SimpleGraph.Walk.cons \u22ef p.reverse = sorry ()"}]}
{"declaration": "theorem length_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).length = p.length := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v u' v' : V\np : G.Walk u v\nhu : u = u'\nhv : v = v'\n\u22a2 (p.copy hu hv).length = p.length"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\nu' v' : V\np : G.Walk u' v'\n\u22a2 (p.copy \u22ef \u22ef).length = p.length"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_reverse {u v : V} (p : G.Walk u v) : p.reverse.length = p.length := by simp [reverse]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 p.reverse.length = p.length"}, {"line": "simp [reverse]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_length_eq_zero_iff {u v : V} : (\u2203 p : G.Walk u v, p.length = 0) \u2194 u = v := by\n  constructor\n  \u00b7 rintro \u27e8p, hp\u27e9\n    exact eq_of_length_eq_zero hp\n  \u00b7 rintro rfl\n    exact \u27e8nil, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\n\u22a2 (\u2203 p, p.length = 0) \u2194 u = v"}, {"line": "constructor", "tactic_state": "case mp\nV : Type u\nG : SimpleGraph V\nu v : V\n\u22a2 (\u2203 p, p.length = 0) \u2192 u = v\n---\ncase mpr\nV : Type u\nG : SimpleGraph V\nu v : V\n\u22a2 u = v \u2192 \u2203 p, p.length = 0"}, {"line": "\u00b7 rintro \u27e8p, hp\u27e9\n    exact eq_of_length_eq_zero hp", "tactic_state": "case mpr\nV : Type u\nG : SimpleGraph V\nu v : V\n\u22a2 u = v \u2192 \u2203 p, p.length = 0"}, {"line": "\u00b7 rintro rfl\n    exact \u27e8nil, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).support = p.support.concat w := by\n  induction p <;> simp [*, concat_nil]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nh : G.Adj v w\n\u22a2 (p.concat h).support = p.support.concat w"}, {"line": "induction p <;> simp [*, concat_nil]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).support = p.support := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v u' v' : V\np : G.Walk u v\nhu : u = u'\nhv : v = v'\n\u22a2 (p.copy hu hv).support = p.support"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\nu' v' : V\np : G.Walk u' v'\n\u22a2 (p.copy \u22ef \u22ef).support = p.support"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    (p.append p').support = p.support ++ p'.support.tail := by\n  induction p <;> cases p' <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\np' : G.Walk v w\n\u22a2 (p.append p').support = p.support ++ p'.support.tail"}, {"line": "induction p <;> cases p' <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_reverse {u v : V} (p : G.Walk u v) : p.reverse.support = p.support.reverse := by\n  induction p <;> simp [support_append, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 p.reverse.support = p.support.reverse"}, {"line": "induction p <;> simp [support_append, *]", "tactic_state": "case cons\nV : Type u\nG : SimpleGraph V\nu v u\u271d v\u271d w\u271d : V\nh\u271d : G.Adj u\u271d v\u271d\np\u271d : G.Walk v\u271d w\u271d\np_ih\u271d : p\u271d.reverse.support = p\u271d.support.reverse\n\u22a2 (p\u271d.reverse.append (SimpleGraph.Walk.cons \u22ef SimpleGraph.Walk.nil)).support = p\u271d.support.reverse ++ [u\u271d]"}]}
{"declaration": "theorem support_ne_nil {u v : V} (p : G.Walk u v) : p.support \u2260 [] := by cases p <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 p.support \u2260 []"}, {"line": "cases p <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem head_support {G : SimpleGraph V} {a b : V} (p : G.Walk a b) :\n    p.support.head (by simp) = a := by cases p <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\na b : V\np : G.Walk a b\n\u22a2 p.support.head \u22ef = a"}, {"line": "cases p <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem getLast_support {G : SimpleGraph V} {a b : V} (p : G.Walk a b) :\n    p.support.getLast (by simp) = b := by\n  induction p\n  \u00b7 simp\n  \u00b7 simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\na b : V\np : G.Walk a b\n\u22a2 p.support.getLast \u22ef = b"}, {"line": "induction p", "tactic_state": "case nil\nV : Type u\nG : SimpleGraph V\na b u\u271d : V\n\u22a2 SimpleGraph.Walk.nil.support.getLast \u22ef = u\u271d\n---\ncase cons\nV : Type u\nG : SimpleGraph V\na b u\u271d v\u271d w\u271d : V\nh\u271d : G.Adj u\u271d v\u271d\np\u271d : G.Walk v\u271d w\u271d\np_ih\u271d : p\u271d.support.getLast \u22ef = w\u271d\n\u22a2 (SimpleGraph.Walk.cons h\u271d p\u271d).support.getLast \u22ef = w\u271d"}, {"line": "\u00b7 simp", "tactic_state": "case cons\nV : Type u\nG : SimpleGraph V\na b u\u271d v\u271d w\u271d : V\nh\u271d : G.Adj u\u271d v\u271d\np\u271d : G.Walk v\u271d w\u271d\np_ih\u271d : p\u271d.support.getLast \u22ef = w\u271d\n\u22a2 (SimpleGraph.Walk.cons h\u271d p\u271d).support.getLast \u22ef = w\u271d"}, {"line": "\u00b7 simpa", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_eq_cons {u v : V} (p : G.Walk u v) : p.support = u :: p.support.tail := by\n  cases p <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 p.support = u :: p.support.tail"}, {"line": "cases p <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem start_mem_support {u v : V} (p : G.Walk u v) : u \u2208 p.support := by cases p <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 u \u2208 p.support"}, {"line": "cases p <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem end_mem_support {u v : V} (p : G.Walk u v) : v \u2208 p.support := by induction p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 v \u2208 p.support"}, {"line": "induction p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_support_iff {u v w : V} (p : G.Walk u v) :\n    w \u2208 p.support \u2194 w = u \u2228 w \u2208 p.support.tail := by cases p <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\n\u22a2 w \u2208 p.support \u2194 w = u \u2228 w \u2208 p.support.tail"}, {"line": "cases p <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_support {u v : V} (p : G.Walk u v) :\n    (p.support : Multiset V) = {u} + p.support.tail := by cases p <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 \u2191p.support = {u} + \u2191p.support.tail"}, {"line": "cases p <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem darts_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).darts = p.darts.concat \u27e8(v, w), h\u27e9 := by\n  induction p <;> simp [*, concat_nil]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nh : G.Adj v w\n\u22a2 (p.concat h).darts = p.darts.concat { fst := v, snd := w, adj := h }"}, {"line": "induction p <;> simp [*, concat_nil]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem darts_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).darts = p.darts := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v u' v' : V\np : G.Walk u v\nhu : u = u'\nhv : v = v'\n\u22a2 (p.copy hu hv).darts = p.darts"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\nu' v' : V\np : G.Walk u' v'\n\u22a2 (p.copy \u22ef \u22ef).darts = p.darts"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem darts_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    (p.append p').darts = p.darts ++ p'.darts := by\n  induction p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\np' : G.Walk v w\n\u22a2 (p.append p').darts = p.darts ++ p'.darts"}, {"line": "induction p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem darts_reverse {u v : V} (p : G.Walk u v) :\n    p.reverse.darts = (p.darts.map Dart.symm).reverse := by\n  induction p <;> simp [*, Sym2.eq_swap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 p.reverse.darts = (List.map sorry p.darts).reverse"}, {"line": "induction p <;> simp [*, Sym2.eq_swap]", "tactic_state": "case cons\nV : Type u\nG : SimpleGraph V\nu v u\u271d v\u271d w\u271d : V\nh\u271d : G.Adj u\u271d v\u271d\np\u271d : G.Walk v\u271d w\u271d\np_ih\u271d : p\u271d.reverse.darts = (List.map sorry p\u271d.darts).reverse\n\u22a2 { fst := v\u271d, snd := u\u271d, adj := \u22ef } = sorry () { fst := u\u271d, snd := v\u271d, adj := h\u271d }"}]}
{"declaration": "theorem mem_darts_reverse {u v : V} {d : G.Dart} {p : G.Walk u v} :\n    d \u2208 p.reverse.darts \u2194 d.symm \u2208 p.darts := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\nd : G.Dart\np : G.Walk u v\n\u22a2 d \u2208 p.reverse.darts \u2194 d.symm \u2208 p.darts"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cons_map_snd_darts {u v : V} (p : G.Walk u v) : (u :: p.darts.map (\u00b7.snd)) = p.support := by\n  induction p <;> simp! [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 u :: List.map (fun x => x.toProd.2) p.darts = p.support"}, {"line": "induction p <;> simp! [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_fst_darts_append {u v : V} (p : G.Walk u v) :\n    p.darts.map (\u00b7.fst) ++ [v] = p.support := by\n  induction p <;> simp! [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 List.map (fun x => x.toProd.1) p.darts ++ [v] = p.support"}, {"line": "induction p <;> simp! [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem head_darts_fst {G : SimpleGraph V} {a b : V} (p : G.Walk a b) (hp : p.darts \u2260 []) :\n    (p.darts.head hp).fst = a := by\n  cases p\n  \u00b7 contradiction\n  \u00b7 simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\na b : V\np : G.Walk a b\nhp : p.darts \u2260 []\n\u22a2 (p.darts.head hp).toProd.1 = a"}, {"line": "cases p", "tactic_state": "case nil\nV : Type u\nG : SimpleGraph V\na : V\nhp : SimpleGraph.Walk.nil.darts \u2260 []\n\u22a2 (SimpleGraph.Walk.nil.darts.head hp).toProd.1 = a\n---\ncase cons\nV : Type u\nG : SimpleGraph V\na b v\u271d : V\nh\u271d : G.Adj a v\u271d\np\u271d : G.Walk v\u271d b\nhp : (SimpleGraph.Walk.cons h\u271d p\u271d).darts \u2260 []\n\u22a2 ((SimpleGraph.Walk.cons h\u271d p\u271d).darts.head hp).toProd.1 = a"}, {"line": "\u00b7 contradiction", "tactic_state": "case cons\nV : Type u\nG : SimpleGraph V\na b v\u271d : V\nh\u271d : G.Adj a v\u271d\np\u271d : G.Walk v\u271d b\nhp : (SimpleGraph.Walk.cons h\u271d p\u271d).darts \u2260 []\n\u22a2 ((SimpleGraph.Walk.cons h\u271d p\u271d).darts.head hp).toProd.1 = a"}, {"line": "\u00b7 simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem getLast_darts_snd {G : SimpleGraph V} {a b : V} (p : G.Walk a b) (hp : p.darts \u2260 []) :\n    (p.darts.getLast hp).snd = b := by\n  rw [\u2190 List.getLast_map (f := fun x : G.Dart \u21a6 x.snd)]\n  \u00b7 simp_rw [p.map_snd_darts, List.getLast_tail, p.getLast_support]\n  \u00b7 simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\na b : V\np : G.Walk a b\nhp : p.darts \u2260 []\n\u22a2 (p.darts.getLast hp).toProd.2 = b"}, {"line": "rw [\u2190 List.getLast_map (f := fun x : G.Dart \u21a6 x.snd)]", "tactic_state": "V : Type u\nG : SimpleGraph V\na b : V\np : G.Walk a b\nhp : p.darts \u2260 []\n\u22a2 (List.map (fun x => x.toProd.2) p.darts).getLast ?m.256 = b\n---\nV : Type u\nG : SimpleGraph V\na b : V\np : G.Walk a b\nhp : p.darts \u2260 []\n\u22a2 List.map (fun x => x.toProd.2) p.darts \u2260 []"}, {"line": "\u00b7 simp_rw [p.map_snd_darts, List.getLast_tail, p.getLast_support]", "tactic_state": "V : Type u\nG : SimpleGraph V\na b : V\np : G.Walk a b\nhp : p.darts \u2260 []\n\u22a2 List.map (fun x => x.toProd.2) p.darts \u2260 []"}, {"line": "\u00b7 simpa", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edges_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).edges = p.edges.concat s(v, w) := by simp [edges]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nh : G.Adj v w\n\u22a2 (p.concat h).edges = p.edges.concat s(v, w)"}, {"line": "simp [edges]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edges_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).edges = p.edges := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v u' v' : V\np : G.Walk u v\nhu : u = u'\nhv : v = v'\n\u22a2 (p.copy hu hv).edges = p.edges"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\nu' v' : V\np : G.Walk u' v'\n\u22a2 (p.copy \u22ef \u22ef).edges = p.edges"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edges_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    (p.append p').edges = p.edges ++ p'.edges := by simp [edges]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\np' : G.Walk v w\n\u22a2 (p.append p').edges = p.edges ++ p'.edges"}, {"line": "simp [edges]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edges_reverse {u v : V} (p : G.Walk u v) : p.reverse.edges = p.edges.reverse := by\n  simp [edges, List.map_reverse]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 p.reverse.edges = p.edges.reverse"}, {"line": "simp [edges, List.map_reverse]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_support {u v : V} (p : G.Walk u v) : p.support.length = p.length + 1 := by\n  induction p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 p.support.length = p.length + 1"}, {"line": "induction p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_darts {u v : V} (p : G.Walk u v) : p.darts.length = p.length := by\n  induction p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 p.darts.length = p.length"}, {"line": "induction p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nil_iff_length_eq {p : G.Walk v w} : p.Nil \u2194 p.length = 0 := by\n  cases p <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\n\u22a2 p.Nil \u2194 p.length = 0"}, {"line": "cases p <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_nil_iff_lt_length {p : G.Walk v w} : \u00ac p.Nil \u2194 0 < p.length := by\n  cases p <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\n\u22a2 \u00acp.Nil \u2194 0 < p.length"}, {"line": "cases p <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_nil_iff {p : G.Walk v w} :\n    \u00ac p.Nil \u2194 \u2203 (u : V) (h : G.Adj v u) (q : G.Walk u w), p = cons h q := by\n  cases p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nv w : V\nx\u271d : Sort u_1\ncons : x\u271d\np : G.Walk v w\n\u22a2 \u00acp.Nil \u2194 \u2203 u, \u2203 (_ : G.Adj v u), \u2203 q, p = sorry"}, {"line": "cases p <;> simp [*]", "tactic_state": "case nil\nV : Type u\nG : SimpleGraph V\nv : V\nx\u271d : Sort u_1\ncons : x\u271d\n\u22a2 \u2200 (x : V), G.Walk x v \u2192 G.Adj v x \u2192 \u00acSimpleGraph.Walk.nil = sorry ()\n---\ncase cons\nV : Type u\nG : SimpleGraph V\nv w : V\nx\u271d : Sort u_1\ncons : x\u271d\nv\u271d : V\nh\u271d : G.Adj v v\u271d\np\u271d : G.Walk v\u271d w\n\u22a2 \u2203 u, Nonempty (G.Walk u w) \u2227 G.Adj v u \u2227 SimpleGraph.Walk.cons h\u271d p\u271d = sorry ()"}]}
{"declaration": "lemma nil_append_iff {p : G.Walk u v} {q : G.Walk v w} : (p.append q).Nil \u2194 p.Nil \u2227 q.Nil := by\n  cases p <;> cases q <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nq : G.Walk v w\n\u22a2 (p.append q).Nil \u2194 p.Nil \u2227 q.Nil"}, {"line": "cases p <;> cases q <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Nil.append {p : G.Walk u v} {q : G.Walk v w} (hp : p.Nil) (hq : q.Nil) : (p.append q).Nil :=\n  by simp [hp, hq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nq : G.Walk v w\nhp : p.Nil\nhq : q.Nil\n\u22a2 (p.append q).Nil"}, {"line": "simp [hp, hq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nil_reverse {p : G.Walk v w} : p.reverse.Nil \u2194 p.Nil := by\n  cases p <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\n\u22a2 p.reverse.Nil \u2194 p.Nil"}, {"line": "cases p <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma snd_cons {u v w} (q : G.Walk v w) (hadj : G.Adj u v) :\n    (q.cons hadj).snd = v := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w : V\nq : G.Walk v w\nhadj : G.Adj u v\n\u22a2 (SimpleGraph.Walk.cons hadj q).snd = v"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma penultimate_concat {t u v} (p : G.Walk u v) (h : G.Adj v t) :\n    (p.concat h).penultimate = v := by simp [penultimate, concat_eq_append, getVert_append]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nt u v : V\np : G.Walk u v\nh : G.Adj v t\n\u22a2 (p.concat h).penultimate = v"}, {"line": "simp [penultimate, concat_eq_append, getVert_append]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma snd_reverse (p : G.Walk u v) : p.reverse.snd = p.penultimate := by\n  simpa using getVert_reverse p 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 p.reverse.snd = p.penultimate"}, {"line": "simpa using getVert_reverse p 1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma penultimate_reverse (p : G.Walk u v) : p.reverse.penultimate = p.snd := by\n  cases p <;> simp [snd, penultimate, getVert_append]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 p.reverse.penultimate = p.snd"}, {"line": "cases p <;> simp [snd, penultimate, getVert_append]", "tactic_state": "case cons\nV : Type u\nG : SimpleGraph V\nu v v\u271d : V\nh\u271d : G.Adj u v\u271d\np\u271d : G.Walk v\u271d v\n\u22a2 (p\u271d.reverse.append (SimpleGraph.Walk.cons \u22ef SimpleGraph.Walk.nil)).penultimate = v\u271d"}]}
{"declaration": "protected lemma Nil.tail {p : G.Walk v w} (hp : p.Nil) : p.tail.Nil := by cases p <;> aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}", "{x y : V} -- TODO: rename to u, v, w instead?"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\nhp : p.Nil\n\u22a2 p.tail.Nil"}, {"line": "cases p <;> aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_copy (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).map f = (p.map f).copy (hu \u25b8 rfl) (hv \u25b8 rfl) := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}", "{x y : V} -- TODO: rename to u, v, w instead?", "{G G' G''}", "(f : G \u2192g G') (f' : G' \u2192g G'') {u v u' v' : V} (p : G.Walk u v)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G \u2192g G'\nu v u' v' : V\np : G.Walk u v\nhu : u = u'\nhv : v = v'\n\u22a2 SimpleGraph.Walk.map f (p.copy hu hv) = (SimpleGraph.Walk.map f p).copy \u22ef \u22ef"}, {"line": "subst_vars", "tactic_state": "V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G \u2192g G'\nu' v' : V\np : G.Walk u' v'\n\u22a2 SimpleGraph.Walk.map f (p.copy \u22ef \u22ef) = (SimpleGraph.Walk.map f p).copy \u22ef \u22ef"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_eq_of_eq {f : G \u2192g G'} (f' : G \u2192g G') (h : f = f') :\n    p.map f = (p.map f').copy (h \u25b8 rfl) (h \u25b8 rfl) := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}", "{x y : V} -- TODO: rename to u, v, w instead?", "{G G' G''}", "(f : G \u2192g G') (f' : G' \u2192g G'') {u v u' v' : V} (p : G.Walk u v)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nu v : V\np : G.Walk u v\nf f' : G \u2192g G'\nh : f = f'\n\u22a2 SimpleGraph.Walk.map f p = (SimpleGraph.Walk.map f' p).copy \u22ef \u22ef"}, {"line": "subst_vars", "tactic_state": "V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nu v : V\np : G.Walk u v\nf' : G \u2192g G'\n\u22a2 SimpleGraph.Walk.map f' p = (SimpleGraph.Walk.map f' p).copy \u22ef \u22ef"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_eq_nil_iff {p : G.Walk u u} : p.map f = nil \u2194 p = nil := by cases p <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}", "{x y : V} -- TODO: rename to u, v, w instead?", "{G G' G''}", "(f : G \u2192g G') (f' : G' \u2192g G'') {u v u' v' : V} (p : G.Walk u v)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G \u2192g G'\nu : V\nnil : G'.Walk (f u) (f u)\np : G.Walk u u\n\u22a2 SimpleGraph.Walk.map f p = nil \u2194 sorry"}, {"line": "cases p <;> simp", "tactic_state": "case nil\nV : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G \u2192g G'\nu : V\nnil : G'.Walk (f u) (f u)\n\u22a2 SimpleGraph.Walk.nil = nil \u2194 sorry ()\n---\ncase cons\nV : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G \u2192g G'\nu : V\nnil : G'.Walk (f u) (f u)\nv\u271d : V\nh\u271d : G.Adj u v\u271d\np\u271d : G.Walk v\u271d u\n\u22a2 SimpleGraph.Walk.cons \u22ef (SimpleGraph.Walk.map f p\u271d) = nil \u2194 sorry ()"}]}
{"declaration": "theorem length_map : (p.map f).length = p.length := by induction p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}", "{x y : V} -- TODO: rename to u, v, w instead?", "{G G' G''}", "(f : G \u2192g G') (f' : G' \u2192g G'') {u v u' v' : V} (p : G.Walk u v)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G \u2192g G'\nu v : V\np : G.Walk u v\n\u22a2 (SimpleGraph.Walk.map f p).length = p.length"}, {"line": "induction p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_append {u v w : V} (p : G.Walk u v) (q : G.Walk v w) :\n    (p.append q).map f = (p.map f).append (q.map f) := by induction p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}", "{x y : V} -- TODO: rename to u, v, w instead?", "{G G' G''}", "(f : G \u2192g G') (f' : G' \u2192g G'') {u v u' v' : V} (p : G.Walk u v)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G \u2192g G'\nu v w : V\np : G.Walk u v\nq : G.Walk v w\n\u22a2 SimpleGraph.Walk.map f (p.append q) = (SimpleGraph.Walk.map f p).append (SimpleGraph.Walk.map f q)"}, {"line": "induction p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reverse_map : (p.map f).reverse = p.reverse.map f := by induction p <;> simp [map_append, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}", "{x y : V} -- TODO: rename to u, v, w instead?", "{G G' G''}", "(f : G \u2192g G') (f' : G' \u2192g G'') {u v u' v' : V} (p : G.Walk u v)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G \u2192g G'\nu v : V\np : G.Walk u v\n\u22a2 (SimpleGraph.Walk.map f p).reverse = SimpleGraph.Walk.map f p.reverse"}, {"line": "induction p <;> simp [map_append, *]", "tactic_state": "case cons\nV : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G \u2192g G'\nu v : V\np : G.Walk u v\nu\u271d v\u271d w\u271d : V\nh\u271d : G.Adj u\u271d v\u271d\np\u271d : G.Walk v\u271d w\u271d\np_ih\u271d : (SimpleGraph.Walk.map f p\u271d).reverse = SimpleGraph.Walk.map f p\u271d.reverse\n\u22a2 (SimpleGraph.Walk.map f p\u271d.reverse).append (SimpleGraph.Walk.cons \u22ef SimpleGraph.Walk.nil) =\n    SimpleGraph.Walk.map f (p\u271d.reverse.append (SimpleGraph.Walk.cons \u22ef SimpleGraph.Walk.nil))"}]}
{"declaration": "theorem support_map : (p.map f).support = p.support.map f := by induction p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}", "{x y : V} -- TODO: rename to u, v, w instead?", "{G G' G''}", "(f : G \u2192g G') (f' : G' \u2192g G'') {u v u' v' : V} (p : G.Walk u v)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G \u2192g G'\nu v : V\np : G.Walk u v\n\u22a2 (SimpleGraph.Walk.map f p).support = List.map (\u21d1f) p.support"}, {"line": "induction p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem darts_map : (p.map f).darts = p.darts.map f.mapDart := by induction p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}", "{x y : V} -- TODO: rename to u, v, w instead?", "{G G' G''}", "(f : G \u2192g G') (f' : G' \u2192g G'') {u v u' v' : V} (p : G.Walk u v)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G \u2192g G'\nu v : V\np : G.Walk u v\n\u22a2 (SimpleGraph.Walk.map f p).darts = List.map f.mapDart p.darts"}, {"line": "induction p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transfer_self : p.transfer G p.edges_subset_edgeSet = p := by\n  induction p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}", "{x y : V} -- TODO: rename to u, v, w instead?", "{G G' G''}", "(f : G \u2192g G') (f' : G' \u2192g G'') {u v u' v' : V} (p : G.Walk u v)", "{u v : V} (p : G.Walk u v)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 p.transfer G \u22ef = p"}, {"line": "induction p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transfer_eq_map_ofLE (hp) (GH : G \u2264 H) : p.transfer H hp = p.map (.ofLE GH) := by\n  induction p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}", "{x y : V} -- TODO: rename to u, v, w instead?", "{G G' G''}", "(f : G \u2192g G') (f' : G' \u2192g G'') {u v u' v' : V} (p : G.Walk u v)", "{u v : V} (p : G.Walk u v)", "{H : SimpleGraph V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nH : SimpleGraph V\nhp : \u2200 e \u2208 p.edges, e \u2208 H.edgeSet\nGH : G \u2264 H\n\u22a2 p.transfer H hp = SimpleGraph.Walk.map (SimpleGraph.Hom.ofLE GH) p"}, {"line": "induction p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edges_transfer (hp) : (p.transfer H hp).edges = p.edges := by\n  induction p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}", "{x y : V} -- TODO: rename to u, v, w instead?", "{G G' G''}", "(f : G \u2192g G') (f' : G' \u2192g G'') {u v u' v' : V} (p : G.Walk u v)", "{u v : V} (p : G.Walk u v)", "{H : SimpleGraph V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nH : SimpleGraph V\nhp : \u2200 e \u2208 p.edges, e \u2208 H.edgeSet\n\u22a2 (p.transfer H hp).edges = p.edges"}, {"line": "induction p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_transfer (hp) : (p.transfer H hp).support = p.support := by\n  induction p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}", "{x y : V} -- TODO: rename to u, v, w instead?", "{G G' G''}", "(f : G \u2192g G') (f' : G' \u2192g G'') {u v u' v' : V} (p : G.Walk u v)", "{u v : V} (p : G.Walk u v)", "{H : SimpleGraph V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nH : SimpleGraph V\nhp : \u2200 e \u2208 p.edges, e \u2208 H.edgeSet\n\u22a2 (p.transfer H hp).support = p.support"}, {"line": "induction p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_transfer (hp) : (p.transfer H hp).length = p.length := by\n  induction p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Walk.lean", "context": {"open": ["Function"], "variables": ["{V : Type u} {V' : Type v} {V'' : Type w}", "(G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')", "{G}", "{motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)", "{u v w : V}", "{x y : V} -- TODO: rename to u, v, w instead?", "{G G' G''}", "(f : G \u2192g G') (f' : G' \u2192g G'') {u v u' v' : V} (p : G.Walk u v)", "{u v : V} (p : G.Walk u v)", "{H : SimpleGraph V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nH : SimpleGraph V\nhp : \u2200 e \u2208 p.edges, e \u2208 H.edgeSet\n\u22a2 (p.transfer H hp).length = p.length"}, {"line": "induction p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ncard_inter (hrep : Represents s C) (h : c \u2208 C) : (s \u2229 c.supp).ncard = 1 := by\n  rw [Set.ncard_eq_one]\n  exact exists_inter_eq_singleton hrep h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/Represents.lean", "context": {"open": [], "variables": ["{V : Type u}", "{G : SimpleGraph V}", "{C : Set G.ConnectedComponent} {s : Set V} {c : G.ConnectedComponent}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nC : Set G.ConnectedComponent\ns : Set V\nc : G.ConnectedComponent\nx\u271d : Sort u_1\nRepresents : x\u271d\nhrep : sorry\nh : c \u2208 C\n\u22a2 (s \u2229 c.supp).ncard = 1"}, {"line": "rw [Set.ncard_eq_one]", "tactic_state": "V : Type u\nG : SimpleGraph V\nC : Set G.ConnectedComponent\ns : Set V\nc : G.ConnectedComponent\nx\u271d : Sort u_1\nRepresents : x\u271d\nhrep : sorry\nh : c \u2208 C\n\u22a2 \u2203 a, s \u2229 c.supp = {a}"}, {"line": "exact exists_inter_eq_singleton hrep h", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma Connected.mono' {H H' : G.Subgraph}\n    (hle : \u2200 v w, H.Adj v w \u2192 H'.Adj v w) (hv : H.verts = H'.verts)\n    (h : H.Connected) : H'.Connected := by\n  exact h.mono \u27e8hv.le, hle\u27e9 hv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean", "context": {"open": [], "variables": ["{V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nH H' : G.Subgraph\nhle : \u2200 (v w : V), H.Adj v w \u2192 H'.Adj v w\nhv : H.verts = H'.verts\nh : H.Connected\n\u22a2 H'.Connected"}, {"line": "exact h.mono \u27e8hv.le, hle\u27e9 hv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSubgraph_cons_nil_eq_subgraphOfAdj (h : G.Adj u v) :\n    (cons h nil).toSubgraph = G.subgraphOfAdj h := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean", "context": {"open": [], "variables": ["{V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'}", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\nx\u271d : Sort u_1\ncons : x\u271d\nh : G.Adj u v\n\u22a2 sorry = G.subgraphOfAdj h"}, {"line": "simp", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\nx\u271d : Sort u_1\ncons : x\u271d\nh : G.Adj u v\n\u22a2 sorry () = G.subgraphOfAdj h"}]}
{"declaration": "lemma not_nil_of_adj_toSubgraph {u v} {x : V} {p : G.Walk u v} (hadj : p.toSubgraph.Adj w x) :\n    \u00acp.Nil := by\n  cases p <;> simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean", "context": {"open": [], "variables": ["{V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'}", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nw u v x : V\np : G.Walk u v\nhadj : p.toSubgraph.Adj w x\n\u22a2 \u00acp.Nil"}, {"line": "cases p <;> simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "lemma start_mem_verts_toSubgraph (p : G.Walk u v) : u \u2208 p.toSubgraph.verts := by\n  simp [mem_verts_toSubgraph]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean", "context": {"open": [], "variables": ["{V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'}", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 u \u2208 p.toSubgraph.verts"}, {"line": "simp [mem_verts_toSubgraph]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma end_mem_verts_toSubgraph (p : G.Walk u v) : v \u2208 p.toSubgraph.verts := by\n  simp [mem_verts_toSubgraph]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean", "context": {"open": [], "variables": ["{V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'}", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n\u22a2 v \u2208 p.toSubgraph.verts"}, {"line": "simp [mem_verts_toSubgraph]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_edges_toSubgraph (p : G.Walk u v) {e : Sym2 V} :\n    e \u2208 p.toSubgraph.edgeSet \u2194 e \u2208 p.edges := by induction p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean", "context": {"open": [], "variables": ["{V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'}", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\ne : Sym2 V\n\u22a2 e \u2208 p.toSubgraph.edgeSet \u2194 e \u2208 p.edges"}, {"line": "induction p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSubgraph_append (p : G.Walk u v) (q : G.Walk v w) :\n    (p.append q).toSubgraph = p.toSubgraph \u2294 q.toSubgraph := by induction p <;> simp [*, sup_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean", "context": {"open": [], "variables": ["{V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'}", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nq : G.Walk v w\n\u22a2 (p.append q).toSubgraph = p.toSubgraph \u2294 q.toSubgraph"}, {"line": "induction p <;> simp [*, sup_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSubgraph_map (f : G \u2192g G') (p : G.Walk u v) :\n    (p.map f).toSubgraph = p.toSubgraph.map f := by induction p <;> simp [*, Subgraph.map_sup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean", "context": {"open": [], "variables": ["{V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'}", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nu v : V\nf : G \u2192g G'\np : G.Walk u v\n\u22a2 (SimpleGraph.Walk.map f p).toSubgraph = SimpleGraph.Subgraph.map f p.toSubgraph"}, {"line": "induction p <;> simp [*, Subgraph.map_sup]", "tactic_state": "case cons\nV : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nu v : V\nf : G \u2192g G'\nu\u271d v\u271d w\u271d : V\nh\u271d : G.Adj u\u271d v\u271d\np\u271d : G.Walk v\u271d w\u271d\np_ih\u271d : (SimpleGraph.Walk.map f p\u271d).toSubgraph = SimpleGraph.Subgraph.map f p\u271d.toSubgraph\n\u22a2 G'.subgraphOfAdj \u22ef \u2294 SimpleGraph.Subgraph.map f p\u271d.toSubgraph =\n    SimpleGraph.Subgraph.map f (G.subgraphOfAdj h\u271d \u2294 p\u271d.toSubgraph)"}]}
{"declaration": "lemma neighborSet_toSubgraph_endpoint {u v} {p : G.Walk u v}\n    (hp : p.IsPath) (hnp : \u00ac p.Nil) : p.toSubgraph.neighborSet v = {p.penultimate} := by\n  simpa using IsPath.neighborSet_toSubgraph_startpoint hp.reverse\n      (by rw [Walk.not_nil_iff_lt_length, Walk.length_reverse]; exact\n        Walk.not_nil_iff_lt_length.mp hnp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean", "context": {"open": [], "variables": ["{V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'}", "{u v w : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nhp : p.IsPath\nhnp : \u00acp.Nil\n\u22a2 p.toSubgraph.neighborSet v = {p.penultimate}"}, {"line": "simpa using IsPath.neighborSet_toSubgraph_startpoint hp.reverse\n      (by rw [Walk.not_nil_iff_lt_length, Walk.length_reverse]; exact\n        Walk.not_nil_iff_lt_length.mp hnp)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma induce_union_connected {H : G.Subgraph} {s t : Set V}\n    (sconn : (H.induce s).Connected) (tconn : (H.induce t).Connected)\n    (sintert : (s \u2293 t).Nonempty) :\n    (H.induce (s \u222a t)).Connected := by\n  refine (sconn.sup tconn sintert).mono ?_ ?_\n  \u00b7 apply le_induce_union\n  \u00b7 simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean", "context": {"open": ["Finset"], "variables": ["{V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'}", "{u v w : V}", "[DecidableEq V] {u v : V} {p : G.Walk u v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nH : G.Subgraph\ns t : Set V\nsconn : (H.induce s).Connected\ntconn : (H.induce t).Connected\nsintert : (s \u2293 t).Nonempty\n\u22a2 (H.induce (s \u222a t)).Connected"}, {"line": "refine (sconn.sup tconn sintert).mono ?_ ?_", "tactic_state": "case refine_1\nV : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nH : G.Subgraph\ns t : Set V\nsconn : (H.induce s).Connected\ntconn : (H.induce t).Connected\nsintert : (s \u2293 t).Nonempty\n\u22a2 H.induce s \u2294 H.induce t \u2264 H.induce (s \u222a t)\n---\ncase refine_2\nV : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nH : G.Subgraph\ns t : Set V\nsconn : (H.induce s).Connected\ntconn : (H.induce t).Connected\nsintert : (s \u2293 t).Nonempty\n\u22a2 (H.induce s \u2294 H.induce t).verts = (H.induce (s \u222a t)).verts"}, {"line": "\u00b7 apply le_induce_union", "tactic_state": "case refine_2\nV : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nH : G.Subgraph\ns t : Set V\nsconn : (H.induce s).Connected\ntconn : (H.induce t).Connected\nsintert : (s \u2293 t).Nonempty\n\u22a2 (H.induce s \u2294 H.induce t).verts = (H.induce (s \u222a t)).verts"}, {"line": "\u00b7 simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Walk.connected_induce_support {u v : V} (p : G.Walk u v) :\n    (G.induce {v | v \u2208 p.support}).Connected := by\n  rw [\u2190 p.verts_toSubgraph]\n  exact p.toSubgraph_connected.induce_verts\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean", "context": {"open": ["Finset"], "variables": ["{V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'}", "{u v w : V}", "[DecidableEq V] {u v : V} {p : G.Walk u v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu v : V\np : G.Walk u v\n\u22a2 (SimpleGraph.induce {v_1 | v_1 \u2208 p.support} G).Connected"}, {"line": "rw [\u2190 p.verts_toSubgraph]", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu v : V\np : G.Walk u v\n\u22a2 (SimpleGraph.induce p.toSubgraph.verts G).Connected"}, {"line": "exact p.toSubgraph_connected.induce_verts", "tactic_state": "No Goals!"}]}
{"declaration": "theorem set_walk_self_length_zero_eq (u : V) : {p : G.Walk u u | p.length = 0} = {Walk.nil} := by\n  ext p\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/WalkCounting.lean", "context": {"open": ["Finset Function"], "variables": ["{V : Type u} (G : SimpleGraph V)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu : V\n\u22a2 {p | p.length = 0} = sorry"}, {"line": "ext p", "tactic_state": "case h\nV : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\n\u22a2 p \u2208 {p | p.length = 0} \u2194 p \u2208 sorry"}, {"line": "simp", "tactic_state": "case h\nV : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\n\u22a2 p = SimpleGraph.Walk.nil \u2194 p \u2208 sorry ()"}]}
{"declaration": "theorem set_walk_length_zero_eq_of_ne {u v : V} (h : u \u2260 v) :\n    {p : G.Walk u v | p.length = 0} = \u2205 := by\n  ext p\n  simp only [Set.mem_setOf_eq]\n  simp only [Set.mem_empty_iff_false]\n  simp only [iff_false]\n  exact fun h' => absurd (Walk.eq_of_length_eq_zero h') h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/WalkCounting.lean", "context": {"open": ["Finset Function"], "variables": ["{V : Type u} (G : SimpleGraph V)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nu v : V\nh : u \u2260 v\n\u22a2 {p | p.length = 0} = \u2205"}, {"line": "ext p", "tactic_state": "case h\nV : Type u\nG : SimpleGraph V\nu v : V\nh : u \u2260 v\np : G.Walk u v\n\u22a2 p \u2208 {p | p.length = 0} \u2194 p \u2208 \u2205"}, {"line": "simp only [Set.mem_setOf_eq]", "tactic_state": "case h\nV : Type u\nG : SimpleGraph V\nu v : V\nh : u \u2260 v\np : G.Walk u v\n\u22a2 p.length = 0 \u2194 p \u2208 \u2205"}, {"line": "simp only [Set.mem_empty_iff_false]", "tactic_state": "case h\nV : Type u\nG : SimpleGraph V\nu v : V\nh : u \u2260 v\np : G.Walk u v\n\u22a2 p.length = 0 \u2194 False"}, {"line": "simp only [iff_false]", "tactic_state": "case h\nV : Type u\nG : SimpleGraph V\nu v : V\nh : u \u2260 v\np : G.Walk u v\n\u22a2 \u00acp.length = 0"}, {"line": "exact fun h' => absurd (Walk.eq_of_length_eq_zero h') h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_finsetWalkLengthLT_eq (n : \u2115) (u v : V) :\n    (G.finsetWalkLengthLT n u v : Set (G.Walk u v)) = {p : G.Walk u v | p.length < n} := by\n  ext p\n  simp [finsetWalkLengthLT, mem_coe, mem_disjiUnion, mem_finsetWalkLength_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/WalkCounting.lean", "context": {"open": ["Finset Function", "Finset in"], "variables": ["{V : Type u} (G : SimpleGraph V)", "[DecidableEq V] [LocallyFinite G]", "{G} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Sort u_1\nn : \u2115\nu v : V\n\u22a2 sorry = {p | sorry < n}"}, {"line": "ext p", "tactic_state": "case h\nV : Sort u_1\nn : \u2115\nu v : V\np : sorry\n\u22a2 p \u2208 sorry \u2194 p \u2208 {p | sorry < n}"}, {"line": "simp [finsetWalkLengthLT, mem_coe, mem_disjiUnion, mem_finsetWalkLength_iff]", "tactic_state": "case h\nV : Sort u_1\nn : \u2115\nu v : V\np : sorry\n\u22a2 p \u2208 sorry () \u2194 sorry () < n"}]}
{"declaration": "theorem reachable_iff_exists_finsetWalkLength_nonempty (u v : V) :\n    G.Reachable u v \u2194 \u2203 n : Fin (Fintype.card V), (G.finsetWalkLength n u v).Nonempty := by\n  constructor\n  \u00b7 intro r\n    refine r.elim_path fun p => ?_\n    refine \u27e8\u27e8_, p.isPath.length_lt\u27e9, p, ?_\u27e9\n    simp [mem_finsetWalkLength_iff]\n  \u00b7 rintro \u27e8_, p, _\u27e9\n    exact \u27e8p\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/WalkCounting.lean", "context": {"open": ["Finset Function", "Finset in"], "variables": ["{V : Type u} (G : SimpleGraph V)", "[DecidableEq V] [LocallyFinite G]", "{G} in", "{G} in", "[DecidableEq V] [Fintype V] [DecidableRel G.Adj]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nu v : V\n\u22a2 sorry \u2194 \u2203 n, sorry"}, {"line": "constructor", "tactic_state": "case mp\nV : Type u_1\nu v : V\n\u22a2 sorry \u2192 \u2203 n, sorry\n---\ncase mpr\nV : Type u_1\nu v : V\n\u22a2 (\u2203 n, sorry) \u2192 sorry"}, {"line": "\u00b7 intro r\n    refine r.elim_path fun p => ?_\n    refine \u27e8\u27e8_, p.isPath.length_lt\u27e9, p, ?_\u27e9\n    simp [mem_finsetWalkLength_iff]", "tactic_state": "case mpr\nV : Type u_1\nu v : V\n\u22a2 (\u2203 n, sorry) \u2192 sorry"}, {"line": "\u00b7 rintro \u27e8_, p, _\u27e9\n    exact \u27e8p\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma takeUntil_first (p : G.Walk u v) :\n    p.takeUntil u p.start_mem_support = .nil := by cases p <;> simp [Walk.takeUntil]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/WalkDecomp.lean", "context": {"open": [], "variables": ["{V : Type u} {G : SimpleGraph V} {v w u : V}", "[DecidableEq V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nv u : V\ninst\u271d : DecidableEq V\np : G.Walk u v\n\u22a2 p.takeUntil u \u22ef = SimpleGraph.Walk.nil"}, {"line": "cases p <;> simp [Walk.takeUntil]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem takeUntil_copy {u v w v' w'} (p : G.Walk v w) (hv : v = v') (hw : w = w')\n    (h : u \u2208 (p.copy hv hw).support) :\n    (p.copy hv hw).takeUntil u h = (p.takeUntil u (by subst_vars; exact h)).copy hv rfl := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/WalkDecomp.lean", "context": {"open": [], "variables": ["{V : Type u} {G : SimpleGraph V} {v w u : V}", "[DecidableEq V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu v w v' w' : V\np : G.Walk v w\nhv : v = v'\nhw : w = w'\nh : u \u2208 (p.copy hv hw).support\n\u22a2 (p.copy hv hw).takeUntil u h = (p.takeUntil u \u22ef).copy hv \u22ef"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu v' w' : V\np : G.Walk v' w'\nh : u \u2208 (p.copy \u22ef \u22ef).support\n\u22a2 (p.copy \u22ef \u22ef).takeUntil u h = (p.takeUntil u \u22ef).copy \u22ef \u22ef"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dropUntil_copy {u v w v' w'} (p : G.Walk v w) (hv : v = v') (hw : w = w')\n    (h : u \u2208 (p.copy hv hw).support) :\n    (p.copy hv hw).dropUntil u h = (p.dropUntil u (by subst_vars; exact h)).copy rfl hw := by\n  subst_vars\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity/WalkDecomp.lean", "context": {"open": [], "variables": ["{V : Type u} {G : SimpleGraph V} {v w u : V}", "[DecidableEq V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu v w v' w' : V\np : G.Walk v w\nhv : v = v'\nhw : w = w'\nh : u \u2208 (p.copy hv hw).support\n\u22a2 (p.copy hv hw).dropUntil u h = (p.dropUntil u \u22ef).copy \u22ef hw"}, {"line": "subst_vars", "tactic_state": "V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu v' w' : V\np : G.Walk v' w'\nh : u \u2208 (p.copy \u22ef \u22ef).support\n\u22a2 (p.copy \u22ef \u22ef).dropUntil u h = (p.dropUntil u \u22ef).copy \u22ef \u22ef"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma end_componentCompl_infinite (e : G.end) (K : (Finset V)\u1d52\u1d56) :\n    ((e : (j : (Finset V)\u1d52\u1d56) \u2192 G.componentComplFunctor.obj j) K).supp.Infinite := by\n  refine (e.val K).infinite_iff_in_all_ranges.mpr (fun L h => ?_)\n  change Opposite.unop K \u2286 Opposite.unop (Opposite.op L) at h\n  exact \u27e8e.val (Opposite.op L), (e.prop (CategoryTheory.opHomOfLE h))\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Ends/Properties.lean", "context": {"open": [], "variables": ["{V : Type} (G : SimpleGraph V)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type\nG : SimpleGraph V\ne : \u2191G.end\nK : (Finset V)\u1d52\u1d56\n\u22a2 (SimpleGraph.ComponentCompl.supp (\u2191e K)).Infinite"}, {"line": "refine (e.val K).infinite_iff_in_all_ranges.mpr (fun L h => ?_)", "tactic_state": "V : Type\nG : SimpleGraph V\ne : \u2191G.end\nK : (Finset V)\u1d52\u1d56\nL : Finset V\nh : Opposite.unop K \u2286 L\n\u22a2 \u2203 D, SimpleGraph.ComponentCompl.hom h D = \u2191e K"}, {"line": "change Opposite.unop K \u2286 Opposite.unop (Opposite.op L) at h", "tactic_state": "V : Type\nG : SimpleGraph V\ne : \u2191G.end\nK : (Finset V)\u1d52\u1d56\nL : Finset V\nh : Opposite.unop K \u2286 Opposite.unop (Opposite.op L)\n\u22a2 \u2203 D, SimpleGraph.ComponentCompl.hom h D = \u2191e K"}, {"line": "exact \u27e8e.val (Opposite.op L), (e.prop (CategoryTheory.opHomOfLE h))\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subset_hom (C : G.ComponentCompl L) (h : K \u2286 L) : (C : Set V) \u2286 (C.hom h : Set V) := by\n  rintro c \u27e8cL, rfl\u27e9\n  exact \u27e8fun h' => cL (h h'), rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Ends/Defs.lean", "context": {"open": [], "variables": ["{V : Type u} (G : SimpleGraph V) (K L M : Set V)", "{G} {K L M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nK L : Set V\nC : G.ComponentCompl L\nh : K \u2286 L\n\u22a2 \u2191C \u2286 \u2191(SimpleGraph.ComponentCompl.hom h C)"}, {"line": "rintro c \u27e8cL, rfl\u27e9", "tactic_state": "case intro\nV : Type u\nG : SimpleGraph V\nK L : Set V\nh : K \u2286 L\nc : V\ncL : c \u2209 L\n\u22a2 c \u2208 \u2191(SimpleGraph.ComponentCompl.hom h (G.componentComplMk cL))"}, {"line": "exact \u27e8fun h' => cL (h h'), rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem infinite_iff_in_all_ranges {K : Finset V} (C : G.ComponentCompl K) :\n    C.supp.Infinite \u2194 \u2200 (L) (h : K \u2286 L), \u2203 D : G.ComponentCompl L, D.hom h = C := by\n  classical\n    constructor\n    \u00b7 rintro Cinf L h\n      obtain \u27e8v, \u27e8vK, rfl\u27e9, vL\u27e9 := Set.Infinite.nonempty (Set.Infinite.diff Cinf L.finite_toSet)\n      exact \u27e8componentComplMk _ vL, rfl\u27e9\n    \u00b7 rintro h Cfin\n      obtain \u27e8D, e\u27e9 := h (K \u222a Cfin.toFinset) Finset.subset_union_left\n      obtain \u27e8v, vD\u27e9 := D.nonempty\n      let Ddis := D.disjoint_right\n      simp_rw [Finset.coe_union, Set.Finite.coe_toFinset, Set.disjoint_union_left,\n        Set.disjoint_iff] at Ddis\n      exact Ddis.right \u27e8(ComponentCompl.hom_eq_iff_le _ _ _).mp e vD, vD\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Ends/Defs.lean", "context": {"open": [], "variables": ["{V : Type u} (G : SimpleGraph V) (K L M : Set V)", "{G} {K L M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\nK : Finset V\nC : G.ComponentCompl \u2191K\n\u22a2 C.supp.Infinite \u2194 \u2200 (L : Finset V) (h : K \u2286 L), \u2203 D, SimpleGraph.ComponentCompl.hom h D = C"}, {"line": "classical\n    constructor\n    \u00b7 rintro Cinf L h\n      obtain \u27e8v, \u27e8vK, rfl\u27e9, vL\u27e9 := Set.Infinite.nonempty (Set.Infinite.diff Cinf L.finite_toSet)\n      exact \u27e8componentComplMk _ vL, rfl\u27e9\n    \u00b7 rintro h Cfin\n      obtain \u27e8D, e\u27e9 := h (K \u222a Cfin.toFinset) Finset.subset_union_left\n      obtain \u27e8v, vD\u27e9 := D.nonempty\n      let Ddis := D.disjoint_right\n      simp_rw [Finset.coe_union, Set.Finite.coe_toFinset, Set.disjoint_union_left,\n        Set.disjoint_iff] at Ddis\n      exact Ddis.right \u27e8(ComponentCompl.hom_eq_iff_le _ _ _).mp e vD, vD\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem end_hom_mk_of_mk {s} (sec : s \u2208 G.end) {K L : (Finset V)\u1d52\u1d56} (h : L \u27f6 K) {v : V}\n    (vnL : v \u2209 L.unop) (hs : s L = G.componentComplMk vnL) :\n    s K = G.componentComplMk (Set.not_mem_subset (le_of_op_hom h : _ \u2286 _) vnL) := by\n  rw [\u2190 sec h]\n  rw [hs]\n  apply ComponentCompl.hom_mk _ (le_of_op_hom h : _ \u2286 _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Ends/Defs.lean", "context": {"open": ["CategoryTheory"], "variables": ["{V : Type u} (G : SimpleGraph V) (K L M : Set V)", "{G} {K L M}", "(G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\nG : SimpleGraph V\ns : (j : (Finset V)\u1d52\u1d56) \u2192 G.componentComplFunctor.obj j\nsec : s \u2208 G.end\nK L : (Finset V)\u1d52\u1d56\nh : L \u27f6 K\nv : V\nvnL : v \u2209 Opposite.unop L\nhs : s L = G.componentComplMk vnL\n\u22a2 s K = G.componentComplMk \u22ef"}, {"line": "rw [\u2190 sec h]", "tactic_state": "V : Type u\nG : SimpleGraph V\ns : (j : (Finset V)\u1d52\u1d56) \u2192 G.componentComplFunctor.obj j\nsec : s \u2208 G.end\nK L : (Finset V)\u1d52\u1d56\nh : L \u27f6 K\nv : V\nvnL : v \u2209 Opposite.unop L\nhs : s L = G.componentComplMk vnL\n\u22a2 G.componentComplFunctor.map h (s L) = G.componentComplMk \u22ef"}, {"line": "rw [hs]", "tactic_state": "V : Type u\nG : SimpleGraph V\ns : (j : (Finset V)\u1d52\u1d56) \u2192 G.componentComplFunctor.obj j\nsec : s \u2208 G.end\nK L : (Finset V)\u1d52\u1d56\nh : L \u27f6 K\nv : V\nvnL : v \u2209 Opposite.unop L\nhs : s L = G.componentComplMk vnL\n\u22a2 G.componentComplFunctor.map h (G.componentComplMk vnL) = G.componentComplMk \u22ef"}, {"line": "apply ComponentCompl.hom_mk _ (le_of_op_hom h : _ \u2286 _)", "tactic_state": "No Goals!"}]}
