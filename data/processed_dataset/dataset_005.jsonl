{"declaration": "theorem Spec_zeroLocus_eq_zeroLocus {R : CommRingCat} (s : Set R) :\n    (Spec R).zeroLocus ((Scheme.\u0393SpecIso R).inv '' s) = PrimeSpectrum.zeroLocus s := by\n  ext x\n  suffices (\u2200 a \u2208 s, x \u2209 PrimeSpectrum.basicOpen a) \u2194 x \u2208 PrimeSpectrum.zeroLocus s by simpa\n  simp [Spec_carrier, PrimeSpectrum.mem_zeroLocus, Set.subset_def,\n    PrimeSpectrum.mem_basicOpen _ x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/Scheme.lean", "context": {"open": ["TopologicalSpace", "CategoryTheory", "TopCat", "Opposite"], "variables": ["{X Y : Scheme.{u}} (f : Hom X Y) {U U' : Y.Opens} {V V' : X.Opens}", "{R S : CommRingCat.{u}} (f : R \u27f6 S)", "(R : CommRingCat.{u})", "(X : Scheme) {V U : X.Opens} (f g : \u0393(X, U))", "(X : Scheme.{u})"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Scheme : ?m.13489\nX\u271d : sorry\nY : sorry\nf\u271d : sorry.Hom sorry\nU : sorry\nU' : sorry\nV : sorry\nV' : sorry\nR\u271d\u00b9 S : CommRingCat\nf : R\u271d\u00b9 \u27f6 S\nR\u271d : CommRingCat\nX : sorry\nx\u271d : Sort u_1\nSpec : x\u271d\nR : CommRingCat\ns : Set \u2191R\n\u22a2 sorry = PrimeSpectrum.zeroLocus s"}, {"line": "ext x", "tactic_state": "case h\nScheme : ?m.13489\nX\u271d : sorry\nY : sorry\nf\u271d : sorry.Hom sorry\nU : sorry\nU' : sorry\nV : sorry\nV' : sorry\nR\u271d\u00b9 S : CommRingCat\nf : R\u271d\u00b9 \u27f6 S\nR\u271d : CommRingCat\nX : sorry\nx\u271d : Sort u_1\nSpec : x\u271d\nR : CommRingCat\ns : Set \u2191R\nx : PrimeSpectrum \u2191R\n\u22a2 x \u2208 sorry \u2194 x \u2208 PrimeSpectrum.zeroLocus s"}, {"line": "suffices (\u2200 a \u2208 s, x \u2209 PrimeSpectrum.basicOpen a) \u2194 x \u2208 PrimeSpectrum.zeroLocus s by simpa", "tactic_state": "case h\nScheme : ?m.13489\nX\u271d : sorry\nY : sorry\nf\u271d : sorry.Hom sorry\nU : sorry\nU' : sorry\nV : sorry\nV' : sorry\nR\u271d\u00b9 S : CommRingCat\nf : R\u271d\u00b9 \u27f6 S\nR\u271d : CommRingCat\nX : sorry\nx\u271d : Sort u_1\nSpec : x\u271d\nR : CommRingCat\ns : Set \u2191R\nx : PrimeSpectrum \u2191R\n\u22a2 (\u2200 a \u2208 s, x \u2209 PrimeSpectrum.basicOpen a) \u2194 x \u2208 PrimeSpectrum.zeroLocus s"}, {"line": "simp [Spec_carrier, PrimeSpectrum.mem_zeroLocus, Set.subset_def,\n    PrimeSpectrum.mem_basicOpen _ x]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toShortNFOfCharThree_spec (hb\u2082 : W.b\u2082 = 0) : (W.toShortNFOfCharThree \u2022 W).IsShortNF := by\n  have h : (2 : R) * 2 = 1 := by linear_combination CharP.cast_eq_zero R 3\n  letI : Invertible (2 : R) := \u27e82, h, h\u27e9\n  have H := W.toCharNeTwoNF_spec\n  exact \u27e8H.a\u2081, hb\u2082 \u25b8 W.toShortNFOfCharThree_a\u2082, H.a\u2083\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/EllipticCurve/NormalForms.lean", "context": {"open": [], "variables": ["{R : Type*} [CommRing R] {F : Type*} [Field F] (W : WeierstrassCurve R)", "[W.IsCharNeTwoNF]", "[Invertible (2 : R)]", "[W.IsShortNF]", "[CharP R 3]", "(W : WeierstrassCurve F) [W.IsElliptic] [W.IsShortNF]", "[Invertible (2 : R)] [Invertible (3 : R)]", "[W.IsCharThreeJNeZeroNF]", "[CharP R 3]", "(W : WeierstrassCurve F) [W.IsElliptic] [W.IsCharThreeJNeZeroNF] [CharP F 3]", "[CharP R 3] [CharP F 3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_2\ninst\u271d\u2074 : Field F\nW : WeierstrassCurve F\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : W.IsCharThreeJNeZeroNF\ninst\u271d\u00b9 inst\u271d : CharP F 3\nhb\u2082 : W.b\u2082 = 0\n\u22a2 (W.toShortNFOfCharThree \u2022 W).IsShortNF"}, {"line": "have h : (2 : R) * 2 = 1 := by linear_combination CharP.cast_eq_zero R 3", "tactic_state": "case refine_1\nF : Type u_2\ninst\u271d\u2074 : Field F\nW : WeierstrassCurve F\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : W.IsCharThreeJNeZeroNF\ninst\u271d\u00b9 inst\u271d : CharP F 3\nhb\u2082 : W.b\u2082 = 0\n\u22a2 OfNat sorry 1\n---\ncase refine_2\nF : Type u_2\ninst\u271d\u2074 : Field F\nW : WeierstrassCurve F\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : W.IsCharThreeJNeZeroNF\ninst\u271d\u00b9 inst\u271d : CharP F 3\nhb\u2082 : W.b\u2082 = 0\n\u22a2 HMul sorry \u2115 sorry\n---\ncase refine_3\nF : Type u_2\ninst\u271d\u2074 : Field F\nW : WeierstrassCurve F\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : W.IsCharThreeJNeZeroNF\ninst\u271d\u00b9 inst\u271d : CharP F 3\nhb\u2082 : W.b\u2082 = 0\nh : sorry * 2 = 1\n\u22a2 (W.toShortNFOfCharThree \u2022 W).IsShortNF"}, {"line": "letI : Invertible (2 : R) := \u27e82, h, h\u27e9", "tactic_state": "case refine_1\nF : Type u_2\ninst\u271d\u2074 : Field F\nW : WeierstrassCurve F\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : W.IsCharThreeJNeZeroNF\ninst\u271d\u00b9 inst\u271d : CharP F 3\nhb\u2082 : W.b\u2082 = 0\nthis : sorry := sorry\n\u22a2 OfNat sorry 1\n---\ncase refine_2\nF : Type u_2\ninst\u271d\u2074 : Field F\nW : WeierstrassCurve F\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : W.IsCharThreeJNeZeroNF\ninst\u271d\u00b9 inst\u271d : CharP F 3\nhb\u2082 : W.b\u2082 = 0\n\u22a2 HMul sorry \u2115 sorry\n---\ncase refine_3\nF : Type u_2\ninst\u271d\u2074 : Field F\nW : WeierstrassCurve F\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : W.IsCharThreeJNeZeroNF\ninst\u271d\u00b9 inst\u271d : CharP F 3\nhb\u2082 : W.b\u2082 = 0\nh : sorry * 2 = 1\n\u22a2 (W.toShortNFOfCharThree \u2022 W).IsShortNF"}, {"line": "have H := W.toCharNeTwoNF_spec", "tactic_state": "case refine_1.refine_3\nF : Type u_2\ninst\u271d\u2074 : Field F\nW : WeierstrassCurve F\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : W.IsCharThreeJNeZeroNF\ninst\u271d\u00b9 inst\u271d : CharP F 3\nhb\u2082 : W.b\u2082 = 0\nthis : sorry := sorry\nH : (W.toCharNeTwoNF \u2022 W).IsCharNeTwoNF\n\u22a2 OfNat sorry 1\n---\ncase refine_1.refine_1\nF : Type u_2\ninst\u271d\u2074 : Field F\nW : WeierstrassCurve F\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : W.IsCharThreeJNeZeroNF\ninst\u271d\u00b9 inst\u271d : CharP F 3\nhb\u2082 : W.b\u2082 = 0\nthis : sorry := sorry\n\u22a2 CommRing F\n---\ncase refine_1.refine_2\nF : Type u_2\ninst\u271d\u2074 : Field F\nW : WeierstrassCurve F\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : W.IsCharThreeJNeZeroNF\ninst\u271d\u00b9 inst\u271d : CharP F 3\nhb\u2082 : W.b\u2082 = 0\nthis : sorry := sorry\n\u22a2 Invertible 2\n---\ncase refine_2\nF : Type u_2\ninst\u271d\u2074 : Field F\nW : WeierstrassCurve F\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : W.IsCharThreeJNeZeroNF\ninst\u271d\u00b9 inst\u271d : CharP F 3\nhb\u2082 : W.b\u2082 = 0\n\u22a2 HMul sorry \u2115 sorry\n---\ncase refine_3\nF : Type u_2\ninst\u271d\u2074 : Field F\nW : WeierstrassCurve F\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : W.IsCharThreeJNeZeroNF\ninst\u271d\u00b9 inst\u271d : CharP F 3\nhb\u2082 : W.b\u2082 = 0\nh : sorry * 2 = 1\n\u22a2 (W.toShortNFOfCharThree \u2022 W).IsShortNF"}, {"line": "exact \u27e8H.a\u2081, hb\u2082 \u25b8 W.toShortNFOfCharThree_a\u2082, H.a\u2083\u27e9", "tactic_state": "case refine_1.refine_1\nF : Type u_2\ninst\u271d\u2074 : Field F\nW : WeierstrassCurve F\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : W.IsCharThreeJNeZeroNF\ninst\u271d\u00b9 inst\u271d : CharP F 3\nhb\u2082 : W.b\u2082 = 0\nthis : sorry := sorry\n\u22a2 CommRing F\n---\ncase refine_1.refine_2\nF : Type u_2\ninst\u271d\u2074 : Field F\nW : WeierstrassCurve F\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : W.IsCharThreeJNeZeroNF\ninst\u271d\u00b9 inst\u271d : CharP F 3\nhb\u2082 : W.b\u2082 = 0\nthis : sorry := sorry\n\u22a2 Invertible 2\n---\ncase refine_2\nF : Type u_2\ninst\u271d\u2074 : Field F\nW : WeierstrassCurve F\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : W.IsCharThreeJNeZeroNF\ninst\u271d\u00b9 inst\u271d : CharP F 3\nhb\u2082 : W.b\u2082 = 0\n\u22a2 HMul sorry \u2115 sorry\n---\ncase refine_3\nF : Type u_2\ninst\u271d\u2074 : Field F\nW : WeierstrassCurve F\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : W.IsCharThreeJNeZeroNF\ninst\u271d\u00b9 inst\u271d : CharP F 3\nhb\u2082 : W.b\u2082 = 0\nh : sorry * 2 = 1\n\u22a2 (W.toShortNFOfCharThree \u2022 W).IsShortNF"}]}
{"declaration": "lemma inv_map_\u0394' : (W.map f).\u0394'\u207b\u00b9 = Units.map f W.\u0394'\u207b\u00b9 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/EllipticCurve/Weierstrass.lean", "context": {"open": [], "variables": ["{R : Type u} [CommRing R] (W : WeierstrassCurve R)", "[CharP R 2]", "[CharP R 3]", "{A : Type v} [CommRing A] (f : R \u2192+* A)", "(A) in", "[CharP R 2]", "[CharP R 3]", "[W.IsElliptic]", "[CharP R 2]", "[CharP R 3]", "{A : Type v} [CommRing A] (f : R \u2192+* A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2077 : CommRing R\nW : WeierstrassCurve R\ninst\u271d\u2076 : CharP R 2\ninst\u271d\u2075 inst\u271d\u2074 : CharP R 3\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : CharP R 2\ninst\u271d\u00b9 : CharP R 3\nA : Type v\ninst\u271d : CommRing A\nf : R \u2192+* A\n\u22a2 (W.map f).\u0394'\u207b\u00b9 = (Units.map \u2191f) W.\u0394'\u207b\u00b9"}, {"line": "simp", "tactic_state": "R : Type u\ninst\u271d\u2077 : CommRing R\nW : WeierstrassCurve R\ninst\u271d\u2076 : CharP R 2\ninst\u271d\u2075 inst\u271d\u2074 : CharP R 3\ninst\u271d\u00b3 : W.IsElliptic\ninst\u271d\u00b2 : CharP R 2\ninst\u271d\u00b9 : CharP R 3\nA : Type v\ninst\u271d : CommRing A\nf : R \u2192+* A\n\u22a2 (W.map f).\u0394' = (Units.map \u2191f) W.\u0394'"}]}
{"declaration": "private lemma expCoeff_cast (n : \u2115) : (expCoeff n : \u211a) = if Even n then (n / 2 : \u211a) else n := by\n  rcases n.even_or_odd' with \u27e8n, rfl | rfl\u27e9 <;> simp [expCoeff, n.not_even_two_mul_add_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Degree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type u} [CommRing R] (W : WeierstrassCurve R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nexpCoeff : x\u271d\nn : \u2115\n\u22a2 sorry = if Even n then \u2191n / 2 else \u2191n"}, {"line": "rcases n.even_or_odd' with \u27e8n, rfl | rfl\u27e9 <;> simp [expCoeff, n.not_even_two_mul_add_one]", "tactic_state": "case intro.inl\nx\u271d : Sort u_1\nexpCoeff : x\u271d\nn : \u2115\n\u22a2 sorry () = \u2191n\n---\ncase intro.inr\nx\u271d : Sort u_1\nexpCoeff : x\u271d\nn : \u2115\n\u22a2 sorry () = 2 * \u2191n + 1"}]}
{"declaration": "lemma pre\u03a8'_ne_zero [Nontrivial R] {n : \u2115} (h : (n : R) \u2260 0) : W.pre\u03a8' n \u2260 0 := by\n  by_cases hn : 2 < n\n  \u00b7 exact ne_zero_of_natDegree_gt <| W.natDegree_pre\u03a8'_pos hn h\n  \u00b7 rcases n with _ | _ | _ <;> aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Degree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type u} [CommRing R] (W : WeierstrassCurve R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : CommRing R\nW : WeierstrassCurve R\ninst\u271d : Nontrivial R\nn : \u2115\nh : \u2191n \u2260 0\n\u22a2 W.pre\u03a8' n \u2260 0"}, {"line": "by_cases hn : 2 < n", "tactic_state": "case pos\nR : Type u\ninst\u271d\u00b9 : CommRing R\nW : WeierstrassCurve R\ninst\u271d : Nontrivial R\nn : \u2115\nh : \u2191n \u2260 0\nhn : 2 < n\n\u22a2 W.pre\u03a8' n \u2260 0\n---\ncase neg\nR : Type u\ninst\u271d\u00b9 : CommRing R\nW : WeierstrassCurve R\ninst\u271d : Nontrivial R\nn : \u2115\nh : \u2191n \u2260 0\nhn : \u00ac2 < n\n\u22a2 W.pre\u03a8' n \u2260 0"}, {"line": "\u00b7 exact ne_zero_of_natDegree_gt <| W.natDegree_pre\u03a8'_pos hn h", "tactic_state": "case neg\nR : Type u\ninst\u271d\u00b9 : CommRing R\nW : WeierstrassCurve R\ninst\u271d : Nontrivial R\nn : \u2115\nh : \u2191n \u2260 0\nhn : \u00ac2 < n\n\u22a2 W.pre\u03a8' n \u2260 0"}, {"line": "\u00b7 rcases n with _ | _ | _ <;> aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma \u03a6_ne_zero [Nontrivial R] (n : \u2124) : W.\u03a6 n \u2260 0 := by\n  by_cases hn : n = 0\n  \u00b7 simpa only [hn,\u03a6_zero] using one_ne_zero\n  \u00b7 exact ne_zero_of_natDegree_gt <| W.natDegree_\u03a6_pos hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Degree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type u} [CommRing R] (W : WeierstrassCurve R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : CommRing R\nW : WeierstrassCurve R\ninst\u271d : Nontrivial R\nn : \u2124\n\u22a2 W.\u03a6 n \u2260 0"}, {"line": "by_cases hn : n = 0", "tactic_state": "case pos\nR : Type u\ninst\u271d\u00b9 : CommRing R\nW : WeierstrassCurve R\ninst\u271d : Nontrivial R\nn : \u2124\nhn : n = 0\n\u22a2 W.\u03a6 n \u2260 0\n---\ncase neg\nR : Type u\ninst\u271d\u00b9 : CommRing R\nW : WeierstrassCurve R\ninst\u271d : Nontrivial R\nn : \u2124\nhn : \u00acn = 0\n\u22a2 W.\u03a6 n \u2260 0"}, {"line": "\u00b7 simpa only [hn,\u03a6_zero] using one_ne_zero", "tactic_state": "case neg\nR : Type u\ninst\u271d\u00b9 : CommRing R\nW : WeierstrassCurve R\ninst\u271d : Nontrivial R\nn : \u2124\nhn : \u00acn = 0\n\u22a2 W.\u03a6 n \u2260 0"}, {"line": "\u00b7 exact ne_zero_of_natDegree_gt <| W.natDegree_\u03a6_pos hn", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nonsingular_neg {P : Fin 3 \u2192 F} (hP : W.Nonsingular P) : W.Nonsingular <| W.neg P := by\n  by_cases hPz : P z = 0\n  \u00b7 simp only [neg_of_Z_eq_zero hP hPz, nonsingular_smul _\n        ((isUnit_Y_of_Z_eq_zero hP hPz).div <| isUnit_X_of_Z_eq_zero hP hPz).neg, nonsingular_zero]\n  \u00b7 simp only [neg_of_Z_ne_zero hPz, nonsingular_smul _ <| Ne.isUnit hPz,\n      nonsingular_neg_of_Z_ne_zero hP hPz]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian/Point.lean", "context": {"open": ["MvPolynomial"], "variables": ["{R : Type r} {S : Type s} {A F : Type u} {B K : Type v} [CommRing R] [CommRing S]", "(W') in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nP : Fin 3 \u2192 F\nhP : sorry\n\u22a2 sorry"}, {"line": "by_cases hPz : P z = 0", "tactic_state": "F : Type u\nP : Fin 3 \u2192 F\nhP : sorry\n\u22a2 OfNat F 0\n---\ncase pos\nF : Type u\nP : Fin 3 \u2192 F\nhP : sorry\nhPz : P sorry = 0\n\u22a2 sorry\n---\ncase neg\nF : Type u\nP : Fin 3 \u2192 F\nhP : sorry\nhPz : \u00acP sorry = 0\n\u22a2 sorry"}, {"line": "\u00b7 simp only [neg_of_Z_eq_zero hP hPz, nonsingular_smul _\n        ((isUnit_Y_of_Z_eq_zero hP hPz).div <| isUnit_X_of_Z_eq_zero hP hPz).neg, nonsingular_zero]", "tactic_state": "case pos\nF : Type u\nP : Fin 3 \u2192 F\nhP : sorry\nhPz : P sorry = 0\n\u22a2 sorry\n---\ncase neg\nF : Type u\nP : Fin 3 \u2192 F\nhP : sorry\nhPz : \u00acP sorry = 0\n\u22a2 sorry"}, {"line": "\u00b7 simp only [neg_of_Z_ne_zero hPz, nonsingular_smul _ <| Ne.isUnit hPz,\n      nonsingular_neg_of_Z_ne_zero hP hPz]", "tactic_state": "case neg\nF : Type u\nP : Fin 3 \u2192 F\nhP : sorry\nhPz : \u00acP sorry = 0\n\u22a2 sorry"}]}
{"declaration": "lemma smul_fin3 (P : Fin 3 \u2192 R) (u : R) : u \u2022 P = ![u * P x, u * P y, u * P z] := by\n  simp [\u2190 List.ofFn_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/EllipticCurve/Projective/Basic.lean", "context": {"open": ["MvPolynomial"], "variables": ["{R : Type r} {S : Type s} {A F : Type u} {B K : Type v}", "(R) in", "(W') in", "[CommRing R] [CommRing S] [CommRing A] [CommRing B] [Field F] [Field K] {W' : Projective R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type r\nx y z : Fin 3\nP : Fin 3 \u2192 R\nu : R\n\u22a2 sorry"}, {"line": "simp [\u2190 List.ofFn_inj]", "tactic_state": "R : Type r\nx y z : Fin 3\nP : Fin 3 \u2192 R\nu : R\n\u22a2 sorry ()"}]}
{"declaration": "lemma nonsingular_neg {P : Fin 3 \u2192 F} (hP : W.Nonsingular P) : W.Nonsingular <| W.neg P := by\n  by_cases hPz : P z = 0\n  \u00b7 simp only [neg_of_Z_eq_zero hP.left hPz, nonsingular_smul _ (isUnit_Y_of_Z_eq_zero hP hPz).neg,\n      nonsingular_zero]\n  \u00b7 simp only [neg_of_Z_ne_zero hPz, nonsingular_smul _ <| Ne.isUnit hPz,\n      nonsingular_neg_of_Z_ne_zero hP hPz]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/EllipticCurve/Projective/Point.lean", "context": {"open": ["MvPolynomial"], "variables": ["{R : Type r} {S : Type s} {A F : Type u} {B K : Type v} [CommRing R] [CommRing S]", "(W') in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nP : Fin 3 \u2192 F\nhP : sorry\n\u22a2 sorry"}, {"line": "by_cases hPz : P z = 0", "tactic_state": "F : Type u\nP : Fin 3 \u2192 F\nhP : sorry\n\u22a2 OfNat F 0\n---\ncase pos\nF : Type u\nP : Fin 3 \u2192 F\nhP : sorry\nhPz : P sorry = 0\n\u22a2 sorry\n---\ncase neg\nF : Type u\nP : Fin 3 \u2192 F\nhP : sorry\nhPz : \u00acP sorry = 0\n\u22a2 sorry"}, {"line": "\u00b7 simp only [neg_of_Z_eq_zero hP.left hPz, nonsingular_smul _ (isUnit_Y_of_Z_eq_zero hP hPz).neg,\n      nonsingular_zero]", "tactic_state": "case pos\nF : Type u\nP : Fin 3 \u2192 F\nhP : sorry\nhPz : P sorry = 0\n\u22a2 sorry\n---\ncase neg\nF : Type u\nP : Fin 3 \u2192 F\nhP : sorry\nhPz : \u00acP sorry = 0\n\u22a2 sorry"}, {"line": "\u00b7 simp only [neg_of_Z_ne_zero hPz, nonsingular_smul _ <| Ne.isUnit hPz,\n      nonsingular_neg_of_Z_ne_zero hP hPz]", "tactic_state": "case neg\nF : Type u\nP : Fin 3 \u2192 F\nhP : sorry\nhPz : \u00acP sorry = 0\n\u22a2 sorry"}]}
{"declaration": "lemma stalkwise_Spec_map_iff (hP : RingHom.RespectsIso P) {R S : CommRingCat} (\u03c6 : R \u27f6 S) :\n    stalkwise P (Spec.map \u03c6) \u2194 \u2200 (p : Ideal S) (_ : p.IsPrime),\n      P (Localization.localRingHom _ p \u03c6.hom rfl) := by\n  have hP' : (RingHom.toMorphismProperty P).RespectsIso :=\n    RingHom.toMorphismProperty_respectsIso_iff.mp hP\n  trans \u2200 (p : PrimeSpectrum S), P (Localization.localRingHom _ p.asIdeal \u03c6.hom rfl)\n  \u00b7 exact forall_congr' fun p \u21a6\n      (RingHom.toMorphismProperty P).arrow_mk_iso_iff (Scheme.arrowStalkMapSpecIso _ _)\n  \u00b7 exact \u27e8fun H p hp \u21a6 H \u27e8p, hp\u27e9, fun H p \u21a6 H p.1 p.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/Morphisms/Constructors.lean", "context": {"open": ["TopologicalSpace CategoryTheory CategoryTheory.Limits Opposite", "MorphismProperty in"], "variables": ["(P : \u2200 {\u03b1 \u03b2 : Type u} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] (_ : \u03b1 \u2192 \u03b2), Prop)", "{P : \u2200 {R S : Type u} [CommRing R] [CommRing S], (R \u2192+* S) \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nx\u271d : Sort u_1\nstalkwise : x\u271d\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nR S : CommRingCat\n\u03c6 : R \u27f6 S\n\u22a2 sorry \u2194\n    \u2200 (p : Ideal \u2191S) (x : p.IsPrime),\n      P (Localization.localRingHom (Ideal.comap (CommRingCat.Hom.hom \u03c6) p) p (CommRingCat.Hom.hom \u03c6) \u22ef)"}, {"line": "have hP' : (RingHom.toMorphismProperty P).RespectsIso :=\n    RingHom.toMorphismProperty_respectsIso_iff.mp hP", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nx\u271d : Sort u_1\nstalkwise : x\u271d\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nR S : CommRingCat\n\u03c6 : R \u27f6 S\nhP' : (RingHom.toMorphismProperty fun {R S} [CommRing R] [CommRing S] => P).RespectsIso\n\u22a2 sorry \u2194\n    \u2200 (p : Ideal \u2191S) (x : p.IsPrime),\n      P (Localization.localRingHom (Ideal.comap (CommRingCat.Hom.hom \u03c6) p) p (CommRingCat.Hom.hom \u03c6) \u22ef)"}, {"line": "trans \u2200 (p : PrimeSpectrum S), P (Localization.localRingHom _ p.asIdeal \u03c6.hom rfl)", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nx\u271d : Sort u_1\nstalkwise : x\u271d\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nR S : CommRingCat\n\u03c6 : R \u27f6 S\nhP' : (RingHom.toMorphismProperty fun {R S} [CommRing R] [CommRing S] => P).RespectsIso\n\u22a2 sorry \u2194\n    \u2200 (p : PrimeSpectrum \u2191S),\n      P (Localization.localRingHom (Ideal.comap (CommRingCat.Hom.hom \u03c6) p.asIdeal) p.asIdeal (CommRingCat.Hom.hom \u03c6) \u22ef)\n---\nP : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nx\u271d : Sort u_1\nstalkwise : x\u271d\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nR S : CommRingCat\n\u03c6 : R \u27f6 S\nhP' : (RingHom.toMorphismProperty fun {R S} [CommRing R] [CommRing S] => P).RespectsIso\n\u22a2 (\u2200 (p : PrimeSpectrum \u2191S),\n      P\n        (Localization.localRingHom (Ideal.comap (CommRingCat.Hom.hom \u03c6) p.asIdeal) p.asIdeal (CommRingCat.Hom.hom \u03c6)\n          \u22ef)) \u2194\n    \u2200 (p : Ideal \u2191S) (x : p.IsPrime),\n      P (Localization.localRingHom (Ideal.comap (CommRingCat.Hom.hom \u03c6) p) p (CommRingCat.Hom.hom \u03c6) \u22ef)"}, {"line": "\u00b7 exact forall_congr' fun p \u21a6\n      (RingHom.toMorphismProperty P).arrow_mk_iso_iff (Scheme.arrowStalkMapSpecIso _ _)", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nx\u271d : Sort u_1\nstalkwise : x\u271d\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nR S : CommRingCat\n\u03c6 : R \u27f6 S\nhP' : (RingHom.toMorphismProperty fun {R S} [CommRing R] [CommRing S] => P).RespectsIso\n\u22a2 (\u2200 (p : PrimeSpectrum \u2191S),\n      P\n        (Localization.localRingHom (Ideal.comap (CommRingCat.Hom.hom \u03c6) p.asIdeal) p.asIdeal (CommRingCat.Hom.hom \u03c6)\n          \u22ef)) \u2194\n    \u2200 (p : Ideal \u2191S) (x : p.IsPrime),\n      P (Localization.localRingHom (Ideal.comap (CommRingCat.Hom.hom \u03c6) p) p (CommRingCat.Hom.hom \u03c6) \u22ef)"}, {"line": "\u00b7 exact \u27e8fun H p hp \u21a6 H \u27e8p, hp\u27e9, fun H p \u21a6 H p.1 p.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Scheme.zeroLocus_eq_univ_iff_subset_nilradical_of_isCompact {X : Scheme.{u}} {U : X.Opens}\n    (hU : IsCompact (U : Set X)) (s : Set \u0393(X, U)) :\n    X.zeroLocus s = Set.univ \u2194 s \u2286 nilradical \u0393(X, U) := by\n  simp [Scheme.zeroLocus_def, \u2190 Scheme.isNilpotent_iff_basicOpen_eq_bot_of_isCompact hU,\n    \u2190 mem_nilradical, Set.subset_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/Morphisms/QuasiCompact.lean", "context": {"open": ["CategoryTheory CategoryTheory.Limits Opposite TopologicalSpace", "scoped AlgebraicGeometry"], "variables": ["{X Y : Scheme.{u}} (f : X \u27f6 Y)", "{Z : Scheme.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Scheme : ?m.767\nX\u271d : sorry\nY : sorry\nf : sorry\nZ : sorry\nX : sorry\nU : sorry\nhU : IsCompact sorry\ns : Set \u2191(sorry.presheaf.obj (op sorry))\n\u22a2 sorry = Set.univ \u2194 s \u2286 \u2191(nilradical \u2191(sorry.presheaf.obj (op sorry)))"}, {"line": "simp [Scheme.zeroLocus_def, \u2190 Scheme.isNilpotent_iff_basicOpen_eq_bot_of_isCompact hU,\n    \u2190 mem_nilradical, Set.subset_def]", "tactic_state": "Scheme : ?m.767\nX\u271d : sorry\nY : sorry\nf : sorry\nZ : sorry\nX : sorry\nU : sorry\nhU : IsCompact sorry\ns : Set \u2191(sorry.presheaf.obj (op sorry))\n\u22a2 sorry () = Set.univ \u2194 \u2200 x \u2208 s, x \u2208 nilradical \u2191((sorry ()).presheaf.obj (op (sorry ())))"}]}
{"declaration": "lemma exists_affineOpens_le_appLE_of_appLE\n    (hPa : StableUnderCompositionWithLocalizationAwayTarget P) (hPl : LocalizationAwayPreserves P)\n    (x : X) (U\u2081 : Y.Opens) (U\u2082 : Y.affineOpens) (V\u2081 : X.Opens) (V\u2082 : X.affineOpens)\n    (hx\u2081 : x \u2208 V\u2081) (hx\u2082 : x \u2208 V\u2082.1) (e\u2082 : V\u2082.1 \u2264 f \u207b\u00b9\u1d41 U\u2082.1) (h\u2082 : P (f.appLE U\u2082 V\u2082 e\u2082).hom)\n    (hfx\u2081 : f.base x \u2208 U\u2081.1) :\n    \u2203 (U' : Y.affineOpens) (V' : X.affineOpens) (_ : U'.1 \u2264 U\u2081) (_ : V'.1 \u2264 V\u2081) (_ : x \u2208 V'.1)\n      (e : V'.1 \u2264 f\u207b\u00b9\u1d41 U'.1), P (f.appLE U' V' e).hom := by\n  obtain \u27e8r, hBr, hBfx\u27e9 := U\u2082.2.exists_basicOpen_le \u27e8f.base x, hfx\u2081\u27e9 (e\u2082 hx\u2082)\n  obtain \u27e8s, hBs, hBx\u27e9 := V\u2082.2.exists_basicOpen_le \u27e8x, hx\u2081\u27e9 hx\u2082\n  obtain \u27e8r', s', hBx', e', hf'\u27e9 := exists_basicOpen_le_appLE_of_appLE_of_isAffine hPa hPl x\n    \u27e8Y.basicOpen r, U\u2082.2.basicOpen _\u27e9 U\u2082 \u27e8X.basicOpen s, V\u2082.2.basicOpen _\u27e9 V\u2082 hBx hx\u2082 e\u2082 h\u2082 hBfx\n  exact \u27e8\u27e8Y.basicOpen r', (U\u2082.2.basicOpen _).basicOpen _\u27e9,\n    \u27e8X.basicOpen s', (V\u2082.2.basicOpen _).basicOpen _\u27e9, le_trans (Y.basicOpen_le _) hBr,\n    le_trans (X.basicOpen_le _) hBs, hBx', e', hf'\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean", "context": {"open": ["CategoryTheory Opposite TopologicalSpace CategoryTheory.Limits AlgebraicGeometry", "Scheme in", "RingHom"], "variables": ["(P : \u2200 {R S : Type u} [CommRing R] [CommRing S], (R \u2192+* S) \u2192 Prop)", "(P : \u2200 {R S : Type u} [CommRing R] [CommRing S], (R \u2192+* S) \u2192 Prop)", "{P}", "{X Y : Scheme.{u}} {f : X \u27f6 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nX Y : Scheme\nf : X \u27f6 Y\nx\u271d\u00b9 : Sort u_1\nStableUnderCompositionWithLocalizationAwayTarget : x\u271d\u00b9\nx\u271d : Sort u_2\nLocalizationAwayPreserves : x\u271d\nhPa : sorry\nhPl : sorry\nx : \u2191\u2191X.toPresheafedSpace\nU\u2081 : Y.Opens\nU\u2082 : \u2191Y.affineOpens\nV\u2081 : X.Opens\nV\u2082 : \u2191X.affineOpens\nhx\u2081 : x \u2208 V\u2081\nhx\u2082 : x \u2208 \u2191V\u2082\ne\u2082 : \u2191V\u2082 \u2264 (Opens.map f.base).obj \u2191U\u2082\nh\u2082 : P (CommRingCat.Hom.hom (Scheme.Hom.appLE f (\u2191U\u2082) (\u2191V\u2082) e\u2082))\nhfx\u2081 : (ConcreteCategory.hom f.base) x \u2208 U\u2081.carrier\n\u22a2 \u2203 U' V',\n    \u2203 (_ : \u2191U' \u2264 U\u2081) (_ : \u2191V' \u2264 V\u2081) (_ : x \u2208 \u2191V') (e : \u2191V' \u2264 (Opens.map f.base).obj \u2191U'),\n      P (CommRingCat.Hom.hom (Scheme.Hom.appLE f (\u2191U') (\u2191V') e))"}, {"line": "obtain \u27e8r, hBr, hBfx\u27e9 := U\u2082.2.exists_basicOpen_le \u27e8f.base x, hfx\u2081\u27e9 (e\u2082 hx\u2082)", "tactic_state": "case intro.intro\nP : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nX Y : Scheme\nf : X \u27f6 Y\nx\u271d\u00b9 : Sort u_1\nStableUnderCompositionWithLocalizationAwayTarget : x\u271d\u00b9\nx\u271d : Sort u_2\nLocalizationAwayPreserves : x\u271d\nhPa : sorry\nhPl : sorry\nx : \u2191\u2191X.toPresheafedSpace\nU\u2081 : Y.Opens\nU\u2082 : \u2191Y.affineOpens\nV\u2081 : X.Opens\nV\u2082 : \u2191X.affineOpens\nhx\u2081 : x \u2208 V\u2081\nhx\u2082 : x \u2208 \u2191V\u2082\ne\u2082 : \u2191V\u2082 \u2264 (Opens.map f.base).obj \u2191U\u2082\nh\u2082 : P (CommRingCat.Hom.hom (Scheme.Hom.appLE f (\u2191U\u2082) (\u2191V\u2082) e\u2082))\nhfx\u2081 : (ConcreteCategory.hom f.base) x \u2208 U\u2081.carrier\nr : \u2191(Y.presheaf.obj (op \u2191U\u2082))\nhBr : Y.basicOpen r \u2264 U\u2081\nhBfx : \u2191\u27e8(ConcreteCategory.hom f.base) x, hfx\u2081\u27e9 \u2208 Y.basicOpen r\n\u22a2 \u2203 U' V',\n    \u2203 (_ : \u2191U' \u2264 U\u2081) (_ : \u2191V' \u2264 V\u2081) (_ : x \u2208 \u2191V') (e : \u2191V' \u2264 (Opens.map f.base).obj \u2191U'),\n      P (CommRingCat.Hom.hom (Scheme.Hom.appLE f (\u2191U') (\u2191V') e))"}, {"line": "obtain \u27e8s, hBs, hBx\u27e9 := V\u2082.2.exists_basicOpen_le \u27e8x, hx\u2081\u27e9 hx\u2082", "tactic_state": "case intro.intro.intro.intro\nP : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nX Y : Scheme\nf : X \u27f6 Y\nx\u271d\u00b9 : Sort u_1\nStableUnderCompositionWithLocalizationAwayTarget : x\u271d\u00b9\nx\u271d : Sort u_2\nLocalizationAwayPreserves : x\u271d\nhPa : sorry\nhPl : sorry\nx : \u2191\u2191X.toPresheafedSpace\nU\u2081 : Y.Opens\nU\u2082 : \u2191Y.affineOpens\nV\u2081 : X.Opens\nV\u2082 : \u2191X.affineOpens\nhx\u2081 : x \u2208 V\u2081\nhx\u2082 : x \u2208 \u2191V\u2082\ne\u2082 : \u2191V\u2082 \u2264 (Opens.map f.base).obj \u2191U\u2082\nh\u2082 : P (CommRingCat.Hom.hom (Scheme.Hom.appLE f (\u2191U\u2082) (\u2191V\u2082) e\u2082))\nhfx\u2081 : (ConcreteCategory.hom f.base) x \u2208 U\u2081.carrier\nr : \u2191(Y.presheaf.obj (op \u2191U\u2082))\nhBr : Y.basicOpen r \u2264 U\u2081\nhBfx : \u2191\u27e8(ConcreteCategory.hom f.base) x, hfx\u2081\u27e9 \u2208 Y.basicOpen r\ns : \u2191(X.presheaf.obj (op \u2191V\u2082))\nhBs : X.basicOpen s \u2264 V\u2081\nhBx : \u2191\u27e8x, hx\u2081\u27e9 \u2208 X.basicOpen s\n\u22a2 \u2203 U' V',\n    \u2203 (_ : \u2191U' \u2264 U\u2081) (_ : \u2191V' \u2264 V\u2081) (_ : x \u2208 \u2191V') (e : \u2191V' \u2264 (Opens.map f.base).obj \u2191U'),\n      P (CommRingCat.Hom.hom (Scheme.Hom.appLE f (\u2191U') (\u2191V') e))"}, {"line": "obtain \u27e8r', s', hBx', e', hf'\u27e9 := exists_basicOpen_le_appLE_of_appLE_of_isAffine hPa hPl x\n    \u27e8Y.basicOpen r, U\u2082.2.basicOpen _\u27e9 U\u2082 \u27e8X.basicOpen s, V\u2082.2.basicOpen _\u27e9 V\u2082 hBx hx\u2082 e\u2082 h\u2082 hBfx", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro\nP : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nX Y : Scheme\nf : X \u27f6 Y\nx\u271d\u00b9 : Sort u_1\nStableUnderCompositionWithLocalizationAwayTarget : x\u271d\u00b9\nx\u271d : Sort u_2\nLocalizationAwayPreserves : x\u271d\nhPa : sorry\nhPl : sorry\nx : \u2191\u2191X.toPresheafedSpace\nU\u2081 : Y.Opens\nU\u2082 : \u2191Y.affineOpens\nV\u2081 : X.Opens\nV\u2082 : \u2191X.affineOpens\nhx\u2081 : x \u2208 V\u2081\nhx\u2082 : x \u2208 \u2191V\u2082\ne\u2082 : \u2191V\u2082 \u2264 (Opens.map f.base).obj \u2191U\u2082\nh\u2082 : P (CommRingCat.Hom.hom (Scheme.Hom.appLE f (\u2191U\u2082) (\u2191V\u2082) e\u2082))\nhfx\u2081 : (ConcreteCategory.hom f.base) x \u2208 U\u2081.carrier\nr : \u2191(Y.presheaf.obj (op \u2191U\u2082))\nhBr : Y.basicOpen r \u2264 U\u2081\nhBfx : \u2191\u27e8(ConcreteCategory.hom f.base) x, hfx\u2081\u27e9 \u2208 Y.basicOpen r\ns : \u2191(X.presheaf.obj (op \u2191V\u2082))\nhBs : X.basicOpen s \u2264 V\u2081\nhBx : \u2191\u27e8x, hx\u2081\u27e9 \u2208 X.basicOpen s\nr' : \u2191(Y.presheaf.obj (op \u2191\u27e8Y.basicOpen r, \u22ef\u27e9))\ns' : \u2191(X.presheaf.obj (op \u2191\u27e8X.basicOpen s, \u22ef\u27e9))\nhBx' : x \u2208 X.basicOpen s'\ne' : X.basicOpen s' \u2264 (Opens.map f.base).obj (Y.basicOpen r')\nhf' : P (CommRingCat.Hom.hom (Scheme.Hom.appLE f (Y.basicOpen r') (X.basicOpen s') e'))\n\u22a2 \u2203 U' V',\n    \u2203 (_ : \u2191U' \u2264 U\u2081) (_ : \u2191V' \u2264 V\u2081) (_ : x \u2208 \u2191V') (e : \u2191V' \u2264 (Opens.map f.base).obj \u2191U'),\n      P (CommRingCat.Hom.hom (Scheme.Hom.appLE f (\u2191U') (\u2191V') e))"}, {"line": "exact \u27e8\u27e8Y.basicOpen r', (U\u2082.2.basicOpen _).basicOpen _\u27e9,\n    \u27e8X.basicOpen s', (V\u2082.2.basicOpen _).basicOpen _\u27e9, le_trans (Y.basicOpen_le _) hBr,\n    le_trans (X.basicOpen_le _) hBs, hBx', e', hf'\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma copy {P' : MorphismProperty Scheme.{u}}\n    {Q' : \u2200 {R S : Type u} [CommRing R] [CommRing S], (R \u2192+* S) \u2192 Prop}\n    (e : P = P') (e' : \u2200 {R S : Type u} [CommRing R] [CommRing S] (f : R \u2192+* S), Q f \u2194 Q' f) :\n    HasRingHomProperty P' Q' := by\n  subst e\n  have heq : @Q = @Q' := by\n    ext R S _ _ f\n    exact (e' f)\n  rw [\u2190 heq]\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean", "context": {"open": ["CategoryTheory Opposite TopologicalSpace CategoryTheory.Limits AlgebraicGeometry", "Scheme in", "RingHom"], "variables": ["(P : \u2200 {R S : Type u} [CommRing R] [CommRing S], (R \u2192+* S) \u2192 Prop)", "(P : \u2200 {R S : Type u} [CommRing R] [CommRing S], (R \u2192+* S) \u2192 Prop)", "{P}", "{X Y : Scheme.{u}} {f : X \u27f6 Y}", "(P : MorphismProperty Scheme.{u}) {Q} [HasRingHomProperty P Q]", "{X Y Z : Scheme.{u}} (f : X \u27f6 Y) (g : Y \u27f6 Z)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : MorphismProperty Scheme\nQ : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\ninst\u271d : HasRingHomProperty P Q\nP' : MorphismProperty Scheme\nQ' : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\ne : P = P'\ne' : \u2200 {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (f : R \u2192+* S), Q f \u2194 Q' f\n\u22a2 HasRingHomProperty P' fun {R S} [CommRing R] [CommRing S] => Q'"}, {"line": "subst e", "tactic_state": "P : MorphismProperty Scheme\nQ : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\ninst\u271d : HasRingHomProperty P Q\nQ' : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\ne' : \u2200 {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (f : R \u2192+* S), Q f \u2194 Q' f\n\u22a2 HasRingHomProperty P fun {R S} [CommRing R] [CommRing S] => Q'"}, {"line": "have heq : @Q = @Q' := by\n    ext R S _ _ f\n    exact (e' f)", "tactic_state": "P : MorphismProperty Scheme\nQ : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\ninst\u271d : HasRingHomProperty P Q\nQ' : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\ne' : \u2200 {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (f : R \u2192+* S), Q f \u2194 Q' f\nheq : Q = Q'\n\u22a2 HasRingHomProperty P fun {R S} [CommRing R] [CommRing S] => Q'"}, {"line": "rw [\u2190 heq]", "tactic_state": "P : MorphismProperty Scheme\nQ : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\ninst\u271d : HasRingHomProperty P Q\nQ' : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\ne' : \u2200 {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (f : R \u2192+* S), Q f \u2194 Q' f\nheq : Q = Q'\n\u22a2 HasRingHomProperty P fun {R S} [CommRing R] [CommRing S] => Q"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem appTop (H : P f) [IsAffine X] [IsAffine Y] : Q f.appTop.hom := by\n  rw [Scheme.Hom.appTop]\n  rw [Scheme.Hom.app_eq_appLE]\n  exact appLE P f H \u27e8_, isAffineOpen_top _\u27e9 \u27e8_, isAffineOpen_top _\u27e9 _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean", "context": {"open": ["CategoryTheory Opposite TopologicalSpace CategoryTheory.Limits AlgebraicGeometry", "Scheme in", "RingHom"], "variables": ["(P : \u2200 {R S : Type u} [CommRing R] [CommRing S], (R \u2192+* S) \u2192 Prop)", "(P : \u2200 {R S : Type u} [CommRing R] [CommRing S], (R \u2192+* S) \u2192 Prop)", "{P}", "{X Y : Scheme.{u}} {f : X \u27f6 Y}", "(P : MorphismProperty Scheme.{u}) {Q} [HasRingHomProperty P Q]", "{X Y Z : Scheme.{u}} (f : X \u27f6 Y) (g : Y \u27f6 Z)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : MorphismProperty Scheme\nQ : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\ninst\u271d\u00b2 : HasRingHomProperty P Q\nX Y : Scheme\nf : X \u27f6 Y\nH : P f\ninst\u271d\u00b9 : IsAffine X\ninst\u271d : IsAffine Y\n\u22a2 Q (CommRingCat.Hom.hom (Scheme.Hom.appTop f))"}, {"line": "rw [Scheme.Hom.appTop]", "tactic_state": "P : MorphismProperty Scheme\nQ : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\ninst\u271d\u00b2 : HasRingHomProperty P Q\nX Y : Scheme\nf : X \u27f6 Y\nH : P f\ninst\u271d\u00b9 : IsAffine X\ninst\u271d : IsAffine Y\n\u22a2 Q (CommRingCat.Hom.hom (Scheme.Hom.app f \u22a4))"}, {"line": "rw [Scheme.Hom.app_eq_appLE]", "tactic_state": "P : MorphismProperty Scheme\nQ : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\ninst\u271d\u00b2 : HasRingHomProperty P Q\nX Y : Scheme\nf : X \u27f6 Y\nH : P f\ninst\u271d\u00b9 : IsAffine X\ninst\u271d : IsAffine Y\n\u22a2 Q (CommRingCat.Hom.hom (Scheme.Hom.appLE f \u22a4 ((Opens.map f.base).obj \u22a4) \u22ef))"}, {"line": "exact appLE P f H \u27e8_, isAffineOpen_top _\u27e9 \u27e8_, isAffineOpen_top _\u27e9 _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vanishingIdeal_singleton (x : ProjectiveSpectrum \ud835\udc9c) :\n    vanishingIdeal ({x} : Set (ProjectiveSpectrum \ud835\udc9c)) = x.asHomogeneousIdeal := by\n  simp [vanishingIdeal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/ProjectiveSpectrum/Topology.lean", "context": {"open": ["DirectSum Pointwise SetLike TopCat TopologicalSpace CategoryTheory Opposite"], "variables": ["{R A : Type*}", "[CommSemiring R] [CommRing A] [Algebra R A]", "(\ud835\udc9c : \u2115 \u2192 Submodule R A) [GradedAlgebra \ud835\udc9c]", "{\ud835\udc9c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Algebra R A\n\ud835\udc9c : \u2115 \u2192 Submodule R A\ninst\u271d : GradedAlgebra \ud835\udc9c\nx\u271d : Sort u_3\nvanishingIdeal : x\u271d\nx : ProjectiveSpectrum \ud835\udc9c\n\u22a2 sorry = x.asHomogeneousIdeal"}, {"line": "simp [vanishingIdeal]", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Algebra R A\n\ud835\udc9c : \u2115 \u2192 Submodule R A\ninst\u271d : GradedAlgebra \ud835\udc9c\nx\u271d : Sort u_3\nvanishingIdeal : x\u271d\nx : ProjectiveSpectrum \ud835\udc9c\n\u22a2 sorry () = x.asHomogeneousIdeal"}]}
{"declaration": "lemma toTopObj_zero_apply_zero (f : \u298b0\u298c.toTopObj) : f 0 = 1 := by\n  simpa [toType_apply] using show \u2211 _, _ = _ from f.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/TopologicalSimplex.lean", "context": {"open": ["Simplicial NNReal CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2191(SimplexCategory.mk 0).toTopObj\n\u22a2 \u2191f 0 = 1"}, {"line": "simpa [toType_apply] using show \u2211 _, _ = _ from f.2", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toTopObj_one_add_eq_one (f : \u298b1\u298c.toTopObj) : f 0 + f 1 = 1 := by\n  simpa [toType_apply, Finset.sum] using show \u2211 _, _ = _ from f.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/TopologicalSimplex.lean", "context": {"open": ["Simplicial NNReal CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2191(SimplexCategory.mk 1).toTopObj\n\u22a2 \u2191f 0 + \u2191f 1 = 1"}, {"line": "simpa [toType_apply, Finset.sum] using show \u2211 _, _ = _ from f.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem P_f_0_eq (q : \u2115) : ((P q).f 0 : X _\u298b0\u298c \u27f6 X _\u298b0\u298c) = \ud835\udfd9 _ := by\n  induction' q with q hq\n  \u00b7 rfl\n  \u00b7 simp only [P_succ, HomologicalComplex.add_f_apply, HomologicalComplex.comp_f,\n      HomologicalComplex.id_f, id_comp, hq, H\u03c3_eq_zero, add_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/DoldKan/Projections.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Preadditive", "Simplicial DoldKan"], "variables": ["{C : Type*} [Category C] [Preadditive C] {X : SimplicialObject C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d\u00b9 : Category.{u_3, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nx\u271d : Sort u_2\nP : x\u271d\nq : \u2115\n\u22a2 sorry = CategoryStruct.id (X.obj (Opposite.op (SimplexCategory.mk 0)))"}, {"line": "induction' q with q hq", "tactic_state": "case zero\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_3, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nx\u271d : Sort u_2\nP : x\u271d\n\u22a2 sorry = CategoryStruct.id (X.obj (Opposite.op (SimplexCategory.mk 0)))\n---\ncase succ\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_3, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nx\u271d : Sort u_2\nP : x\u271d\nq : \u2115\nhq : sorry = CategoryStruct.id (X.obj (Opposite.op (SimplexCategory.mk 0)))\n\u22a2 sorry = CategoryStruct.id (X.obj (Opposite.op (SimplexCategory.mk 0)))"}, {"line": "\u00b7 rfl", "tactic_state": "case succ\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_3, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nx\u271d : Sort u_2\nP : x\u271d\nq : \u2115\nhq : sorry = CategoryStruct.id (X.obj (Opposite.op (SimplexCategory.mk 0)))\n\u22a2 sorry = CategoryStruct.id (X.obj (Opposite.op (SimplexCategory.mk 0)))"}, {"line": "\u00b7 simp only [P_succ, HomologicalComplex.add_f_apply, HomologicalComplex.comp_f,\n      HomologicalComplex.id_f, id_comp, hq, H\u03c3_eq_zero, add_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_P_eq_self_iff {Y : C} {n q : \u2115} {\u03c6 : Y \u27f6 X _\u298bn + 1\u298c} :\n    \u03c6 \u226b (P q).f (n + 1) = \u03c6 \u2194 HigherFacesVanish q \u03c6 := by\n  constructor\n  \u00b7 intro h\u03c6\n    rw [\u2190 h\u03c6]\n    apply HigherFacesVanish.of_comp\n    apply HigherFacesVanish.of_P\n  \u00b7 exact HigherFacesVanish.comp_P_eq_self\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/DoldKan/Projections.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Preadditive", "Simplicial DoldKan"], "variables": ["{C : Type*} [Category C] [Preadditive C] {X : SimplicialObject C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nx\u271d\u00b9 : Sort u_2\nP : x\u271d\u00b9\nx\u271d : Sort u_3\nHigherFacesVanish : x\u271d\nY : C\nn q : \u2115\n\u03c6 : Y \u27f6 X.obj (Opposite.op (SimplexCategory.mk (n + 1)))\n\u22a2 CategoryStruct.comp \u03c6 sorry = \u03c6 \u2194 sorry"}, {"line": "constructor", "tactic_state": "case mp\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nx\u271d\u00b9 : Sort u_2\nP : x\u271d\u00b9\nx\u271d : Sort u_3\nHigherFacesVanish : x\u271d\nY : C\nn q : \u2115\n\u03c6 : Y \u27f6 X.obj (Opposite.op (SimplexCategory.mk (n + 1)))\n\u22a2 CategoryStruct.comp \u03c6 sorry = \u03c6 \u2192 sorry\n---\ncase mpr\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nx\u271d\u00b9 : Sort u_2\nP : x\u271d\u00b9\nx\u271d : Sort u_3\nHigherFacesVanish : x\u271d\nY : C\nn q : \u2115\n\u03c6 : Y \u27f6 X.obj (Opposite.op (SimplexCategory.mk (n + 1)))\n\u22a2 sorry \u2192 CategoryStruct.comp \u03c6 sorry = \u03c6"}, {"line": "\u00b7 intro h\u03c6\n    rw [\u2190 h\u03c6]\n    apply HigherFacesVanish.of_comp\n    apply HigherFacesVanish.of_P", "tactic_state": "case mpr\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nx\u271d\u00b9 : Sort u_2\nP : x\u271d\u00b9\nx\u271d : Sort u_3\nHigherFacesVanish : x\u271d\nY : C\nn q : \u2115\n\u03c6 : Y \u27f6 X.obj (Opposite.op (SimplexCategory.mk (n + 1)))\n\u22a2 sorry \u2192 CategoryStruct.comp \u03c6 sorry = \u03c6"}, {"line": "\u00b7 exact HigherFacesVanish.comp_P_eq_self", "tactic_state": "No Goals!"}]}
{"declaration": "theorem simply_connected_iff_unique_homotopic (X : Type*) [TopologicalSpace X] :\n    SimplyConnectedSpace X \u2194\n      Nonempty X \u2227 \u2200 x y : X, Nonempty (Unique (Path.Homotopic.Quotient x y)) := by\n  simp only [simply_connected_def]\n  simp only [equiv_punit_iff_unique]\n  simp only [FundamentalGroupoid.nonempty_iff X]\n  simp only [and_congr_right_iff]\n  simp only [Nonempty.forall]\n  intros\n  exact \u27e8fun h _ _ => h _ _, fun h _ _ => h _ _\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/FundamentalGroupoid/SimplyConnected.lean", "context": {"open": ["CategoryTheory", "ContinuousMap", "scoped ContinuousMap"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 SimplyConnectedSpace X \u2194 Nonempty X \u2227 \u2200 (x y : X), Nonempty (Unique (Path.Homotopic.Quotient x y))"}, {"line": "simp only [simply_connected_def]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 Nonempty (FundamentalGroupoid X \u224c Discrete Unit) \u2194\n    Nonempty X \u2227 \u2200 (x y : X), Nonempty (Unique (Path.Homotopic.Quotient x y))"}, {"line": "simp only [equiv_punit_iff_unique]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 (Nonempty (FundamentalGroupoid X) \u2227 \u2200 (x y : FundamentalGroupoid X), Nonempty (Unique (x \u27f6 y))) \u2194\n    Nonempty X \u2227 \u2200 (x y : X), Nonempty (Unique (Path.Homotopic.Quotient x y))"}, {"line": "simp only [FundamentalGroupoid.nonempty_iff X]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 (Nonempty X \u2227 \u2200 (x y : FundamentalGroupoid X), Nonempty (Unique (x \u27f6 y))) \u2194\n    Nonempty X \u2227 \u2200 (x y : X), Nonempty (Unique (Path.Homotopic.Quotient x y))"}, {"line": "simp only [and_congr_right_iff]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 Nonempty X \u2192\n    ((\u2200 (x y : FundamentalGroupoid X), Nonempty (Unique (x \u27f6 y))) \u2194\n      \u2200 (x y : X), Nonempty (Unique (Path.Homotopic.Quotient x y)))"}, {"line": "simp only [Nonempty.forall]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 X \u2192\n    ((\u2200 (x y : FundamentalGroupoid X), Nonempty (Unique (x \u27f6 y))) \u2194\n      \u2200 (x y : X), Nonempty (Unique (Path.Homotopic.Quotient x y)))"}, {"line": "intros", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\na\u271d : X\n\u22a2 (\u2200 (x y : FundamentalGroupoid X), Nonempty (Unique (x \u27f6 y))) \u2194\n    \u2200 (x y : X), Nonempty (Unique (Path.Homotopic.Quotient x y))"}, {"line": "exact \u27e8fun h _ _ => h _ _, fun h _ _ => h _ _\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transReflReparamAux_zero : transReflReparamAux 0 = 0 := by\n  norm_num [transReflReparamAux]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean", "context": {"open": ["CategoryTheory", "unitInterval"], "variables": ["{X : Type u} [TopologicalSpace X]", "{x\u2080 x\u2081 : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntransReflReparamAux : x\u271d\n\u22a2 sorry = 0"}, {"line": "norm_num [transReflReparamAux]", "tactic_state": "x\u271d : Sort u_1\ntransReflReparamAux : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem transReflReparamAux_one : transReflReparamAux 1 = 1 := by\n  norm_num [transReflReparamAux]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean", "context": {"open": ["CategoryTheory", "unitInterval"], "variables": ["{X : Type u} [TopologicalSpace X]", "{x\u2080 x\u2081 : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntransReflReparamAux : x\u271d\n\u22a2 sorry = 1"}, {"line": "norm_num [transReflReparamAux]", "tactic_state": "x\u271d : Sort u_1\ntransReflReparamAux : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem transAssocReparamAux_zero : transAssocReparamAux 0 = 0 := by\n  norm_num [transAssocReparamAux]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean", "context": {"open": ["CategoryTheory", "unitInterval"], "variables": ["{X : Type u} [TopologicalSpace X]", "{x\u2080 x\u2081 : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntransAssocReparamAux : x\u271d\n\u22a2 sorry = 0"}, {"line": "norm_num [transAssocReparamAux]", "tactic_state": "x\u271d : Sort u_1\ntransAssocReparamAux : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem transAssocReparamAux_one : transAssocReparamAux 1 = 1 := by\n  norm_num [transAssocReparamAux]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean", "context": {"open": ["CategoryTheory", "unitInterval"], "variables": ["{X : Type u} [TopologicalSpace X]", "{x\u2080 x\u2081 : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntransAssocReparamAux : x\u271d\n\u22a2 sorry = 1"}, {"line": "norm_num [transAssocReparamAux]", "tactic_state": "x\u271d : Sort u_1\ntransAssocReparamAux : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "private theorem start_path : f x\u2080 = g x\u2082 := by convert hfg 0 <;> simp only [Path.source]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean", "context": {"open": ["FundamentalGroupoid", "CategoryTheory", "FundamentalGroupoidFunctor", "scoped FundamentalGroupoid", "scoped unitInterval", "unitInterval (uhpath01)"], "variables": ["{X\u2081 X\u2082 Y : TopCat.{u}} {f : C(X\u2081, Y)} {g : C(X\u2082, Y)} {x\u2080 x\u2081 : X\u2081} {x\u2082 x\u2083 : X\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X\u2081 X\u2082 Y : TopCat\nf : C(\u2191X\u2081, \u2191Y)\ng : C(\u2191X\u2082, \u2191Y)\nx\u2080 : \u2191X\u2081\nx\u2082 : \u2191X\u2082\n\u22a2 f x\u2080 = g x\u2082"}, {"line": "convert hfg 0 <;> simp only [Path.source]", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem end_path : f x\u2081 = g x\u2083 := by convert hfg 1 <;> simp only [Path.target]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean", "context": {"open": ["FundamentalGroupoid", "CategoryTheory", "FundamentalGroupoidFunctor", "scoped FundamentalGroupoid", "scoped unitInterval", "unitInterval (uhpath01)"], "variables": ["{X\u2081 X\u2082 Y : TopCat.{u}} {f : C(X\u2081, Y)} {g : C(X\u2082, Y)} {x\u2080 x\u2081 : X\u2081} {x\u2082 x\u2083 : X\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X\u2081 X\u2082 Y : TopCat\nf : C(\u2191X\u2081, \u2191Y)\ng : C(\u2191X\u2082, \u2191Y)\nx\u2081 : \u2191X\u2081\nx\u2083 : \u2191X\u2082\n\u22a2 f x\u2081 = g x\u2083"}, {"line": "convert hfg 1 <;> simp only [Path.target]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma const_eq_id : const \u298b0\u298c \u298b0\u298c 0 = \ud835\udfd9 _ := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplexCategory/Basic.lean", "context": {"open": ["Simplicial CategoryTheory Limits"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nconst : x\u271d\n\u22a2 sorry = CategoryStruct.id ?m.917"}, {"line": "aesop", "tactic_state": "x : Sort u_1\nconst : x\n\u22a2 sorry () = CategoryStruct.id ?m.917"}]}
{"declaration": "theorem eq_const_to_zero {n : SimplexCategory} (f : n \u27f6 \u298b0\u298c) :\n    f = const n _ 0 := by\n  ext : 3\n  apply @Subsingleton.elim (Fin 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplexCategory/Basic.lean", "context": {"open": ["Simplicial CategoryTheory Limits"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nconst : x\u271d\nn : SimplexCategory\nf : n \u27f6 SimplexCategory.mk 0\n\u22a2 f = sorry"}, {"line": "ext : 3", "tactic_state": "case a.h.h\nx\u271d\u00b9 : Sort u_1\nconst : x\u271d\u00b9\nn : SimplexCategory\nf : n \u27f6 SimplexCategory.mk 0\nx\u271d : Fin (n.len + 1)\n\u22a2 (SimplexCategory.Hom.toOrderHom f) x\u271d = (SimplexCategory.Hom.toOrderHom sorry) x\u271d"}, {"line": "apply @Subsingleton.elim (Fin 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hom_zero_zero (f : \u298b0\u298c \u27f6 \u298b0\u298c) : f = \ud835\udfd9 _ := by\n  apply Subsingleton.elim\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplexCategory/Basic.lean", "context": {"open": ["Simplicial CategoryTheory Limits"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : SimplexCategory.mk 0 \u27f6 SimplexCategory.mk 0\n\u22a2 f = CategoryStruct.id (SimplexCategory.mk 0)"}, {"line": "apply Subsingleton.elim", "tactic_state": "No Goals!"}]}
{"declaration": "theorem len_le_of_mono {x y : SimplexCategory} {f : x \u27f6 y} : Mono f \u2192 x.len \u2264 y.len := by\n  intro hyp_f_mono\n  have f_inj : Function.Injective f.toOrderHom.toFun := mono_iff_injective.1 hyp_f_mono\n  simpa using Fintype.card_le_of_injective f.toOrderHom.toFun f_inj\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplexCategory/Basic.lean", "context": {"open": ["Simplicial CategoryTheory Limits", "Fin in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : SimplexCategory\nf : x \u27f6 y\n\u22a2 Mono f \u2192 x.len \u2264 y.len"}, {"line": "intro hyp_f_mono", "tactic_state": "x y : SimplexCategory\nf : x \u27f6 y\nhyp_f_mono : Mono f\n\u22a2 x.len \u2264 y.len"}, {"line": "have f_inj : Function.Injective f.toOrderHom.toFun := mono_iff_injective.1 hyp_f_mono", "tactic_state": "x y : SimplexCategory\nf : x \u27f6 y\nhyp_f_mono : Mono f\nf_inj : Function.Injective (SimplexCategory.Hom.toOrderHom f).toFun\n\u22a2 x.len \u2264 y.len"}, {"line": "simpa using Fintype.card_le_of_injective f.toOrderHom.toFun f_inj", "tactic_state": "No Goals!"}]}
{"declaration": "theorem len_le_of_epi {x y : SimplexCategory} {f : x \u27f6 y} : Epi f \u2192 y.len \u2264 x.len := by\n  intro hyp_f_epi\n  have f_surj : Function.Surjective f.toOrderHom.toFun := epi_iff_surjective.1 hyp_f_epi\n  simpa using Fintype.card_le_of_surjective f.toOrderHom.toFun f_surj\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplexCategory/Basic.lean", "context": {"open": ["Simplicial CategoryTheory Limits", "Fin in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : SimplexCategory\nf : x \u27f6 y\n\u22a2 Epi f \u2192 y.len \u2264 x.len"}, {"line": "intro hyp_f_epi", "tactic_state": "x y : SimplexCategory\nf : x \u27f6 y\nhyp_f_epi : Epi f\n\u22a2 y.len \u2264 x.len"}, {"line": "have f_surj : Function.Surjective f.toOrderHom.toFun := epi_iff_surjective.1 hyp_f_epi", "tactic_state": "x y : SimplexCategory\nf : x \u27f6 y\nhyp_f_epi : Epi f\nf_surj : Function.Surjective (SimplexCategory.Hom.toOrderHom f).toFun\n\u22a2 y.len \u2264 x.len"}, {"line": "simpa using Fintype.card_le_of_surjective f.toOrderHom.toFun f_surj", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_comp_\u03b4_of_not_surjective {n : \u2115} {\u0394 : SimplexCategory} (\u03b8 : \u0394 \u27f6 mk (n + 1))\n    (h\u03b8 : \u00acFunction.Surjective \u03b8.toOrderHom) :\n    \u2203 (i : Fin (n + 2)) (\u03b8' : \u0394 \u27f6 mk n), \u03b8 = \u03b8' \u226b \u03b4 i := by\n  obtain \u27e8i, hi\u27e9 := not_forall.mp h\u03b8\n  use i\n  exact eq_comp_\u03b4_of_not_surjective' \u03b8 i (not_exists.mp hi)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplexCategory/Basic.lean", "context": {"open": ["Simplicial CategoryTheory Limits", "Fin in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\n\u03b4 : x\u271d\nn : \u2115\n\u0394 : SimplexCategory\n\u03b8 : \u0394 \u27f6 sorry\nh\u03b8 : \u00acFunction.Surjective \u21d1(SimplexCategory.Hom.toOrderHom \u03b8)\n\u22a2 \u2203 i \u03b8', \u03b8 = CategoryStruct.comp \u03b8' sorry"}, {"line": "obtain \u27e8i, hi\u27e9 := not_forall.mp h\u03b8", "tactic_state": "case intro\nx\u271d : Sort u_1\n\u03b4 : x\u271d\nn : \u2115\n\u0394 : SimplexCategory\n\u03b8 : \u0394 \u27f6 sorry\nh\u03b8 : \u00acFunction.Surjective \u21d1(SimplexCategory.Hom.toOrderHom \u03b8)\ni : Fin (sorry.len + 1)\nhi : \u00ac\u2203 a, (SimplexCategory.Hom.toOrderHom \u03b8) a = i\n\u22a2 \u2203 i \u03b8', \u03b8 = CategoryStruct.comp \u03b8' sorry"}, {"line": "use i", "tactic_state": "case h\nx\u271d : Sort u_1\n\u03b4 : x\u271d\nn : \u2115\n\u0394 : SimplexCategory\n\u03b8 : \u0394 \u27f6 sorry\nh\u03b8 : \u00acFunction.Surjective \u21d1(SimplexCategory.Hom.toOrderHom \u03b8)\ni : Fin (sorry.len + 1)\nhi : \u00ac\u2203 a, (SimplexCategory.Hom.toOrderHom \u03b8) a = i\n\u22a2 \u2203 \u03b8', \u03b8 = CategoryStruct.comp \u03b8' sorry"}, {"line": "exact eq_comp_\u03b4_of_not_surjective' \u03b8 i (not_exists.mp hi)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_eq {\u0394 \u0394' \u0394'' : SimplexCategory} {\u03c6 : \u0394 \u27f6 \u0394''} {e : \u0394 \u27f6 \u0394'} [Epi e] {i : \u0394' \u27f6 \u0394''}\n    [Mono i] (fac : e \u226b i = \u03c6) : image \u03c6 = \u0394' := by\n  haveI := strongEpi_of_epi e\n  let e := image.isoStrongEpiMono e i fac\n  ext\n  exact\n    le_antisymm (len_le_of_epi (inferInstance : Epi e.hom))\n      (len_le_of_mono (inferInstance : Mono e.hom))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplexCategory/Basic.lean", "context": {"open": ["Simplicial CategoryTheory Limits", "Fin in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0394 \u0394' \u0394'' : SimplexCategory\n\u03c6 : \u0394 \u27f6 \u0394''\ne : \u0394 \u27f6 \u0394'\ninst\u271d\u00b9 : Epi e\ni : \u0394' \u27f6 \u0394''\ninst\u271d : Mono i\nfac : CategoryStruct.comp e i = \u03c6\n\u22a2 image \u03c6 = \u0394'"}, {"line": "haveI := strongEpi_of_epi e", "tactic_state": "\u0394 \u0394' \u0394'' : SimplexCategory\n\u03c6 : \u0394 \u27f6 \u0394''\ne : \u0394 \u27f6 \u0394'\ninst\u271d\u00b9 : Epi e\ni : \u0394' \u27f6 \u0394''\ninst\u271d : Mono i\nfac : CategoryStruct.comp e i = \u03c6\nthis : StrongEpi e\n\u22a2 image \u03c6 = \u0394'"}, {"line": "let e := image.isoStrongEpiMono e i fac", "tactic_state": "\u0394 \u0394' \u0394'' : SimplexCategory\n\u03c6 : \u0394 \u27f6 \u0394''\ne\u271d : \u0394 \u27f6 \u0394'\ninst\u271d\u00b9 : Epi e\u271d\ni : \u0394' \u27f6 \u0394''\ninst\u271d : Mono i\nfac : CategoryStruct.comp e\u271d i = \u03c6\nthis : StrongEpi e\u271d\ne : \u0394' \u2245 image \u03c6 := sorry\n\u22a2 image \u03c6 = \u0394'"}, {"line": "ext", "tactic_state": "case a\n\u0394 \u0394' \u0394'' : SimplexCategory\n\u03c6 : \u0394 \u27f6 \u0394''\ne\u271d : \u0394 \u27f6 \u0394'\ninst\u271d\u00b9 : Epi e\u271d\ni : \u0394' \u27f6 \u0394''\ninst\u271d : Mono i\nfac : CategoryStruct.comp e\u271d i = \u03c6\nthis : StrongEpi e\u271d\ne : \u0394' \u2245 image \u03c6 := sorry\n\u22a2 (image \u03c6).len = \u0394'.len"}, {"line": "exact\n    le_antisymm (len_le_of_epi (inferInstance : Epi e.hom))\n      (len_le_of_mono (inferInstance : Mono e.hom))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nil : IsAdmissible m [] := by simp [IsAdmissible]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplexCategory/GeneratorsRelations/NormalForms.lean", "context": {"open": [], "variables": ["(m : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nIsAdmissible : x\u271d\n\u22a2 sorry"}, {"line": "simp [IsAdmissible]", "tactic_state": "x\u271d : Sort u_1\nIsAdmissible : x\u271d\n\u22a2 sorry ()"}]}
{"declaration": "theorem cofan_inj_id (n : \u2115) : (s.cofan _).inj (IndexSet.id (op \u298bn\u298c)) = s.\u03b9 n := by\n  simp [IndexSet.id, IndexSet.e, cofan_inj_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplicialObject/Split.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits Opposite SimplexCategory", "Simplicial"], "variables": ["{C : Type*} [Category C]", "{\u0394 : SimplexCategory\u1d52\u1d56} (A : IndexSet \u0394)", "(\u0394)", "{\u0394}", "{\u0394' : SimplexCategory\u1d52\u1d56} (\u03b8 : \u0394 \u27f6 \u0394')", "(N : \u2115 \u2192 C) (\u0394 : SimplexCategory\u1d52\u1d56) (X : SimplicialObject C) (\u03c6 : \u2200 n, N n \u27f6 X _\u298bn\u298c)", "{X Y : SimplicialObject C} (s : Splitting X)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "IndexSet : ?m.6953\nSplitting : ?m.8878\nC : Type u_1\ninst\u271d : Category.{?u.8885, u_1} C\n\u0394\u271d : SimplexCategory\u1d52\u1d56\nA : sorry\n\u0394' : SimplexCategory\u1d52\u1d56\n\u03b8 : \u0394\u271d \u27f6 \u0394'\nN : \u2115 \u2192 C\n\u0394 : SimplexCategory\u1d52\u1d56\nX\u271d : SimplicialObject C\n\u03c6 : (n : \u2115) \u2192 N n \u27f6 X\u271d.obj (op (SimplexCategory.mk n))\nX Y : SimplicialObject C\ns : sorry\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "simp [IndexSet.id, IndexSet.e, cofan_inj_eq]", "tactic_state": "IndexSet : ?m.6953\nSplitting : ?m.8878\nC : Type u_1\ninst\u271d : Category.{?u.8885, u_1} C\n\u0394\u271d : SimplexCategory\u1d52\u1d56\nA : sorry\n\u0394' : SimplexCategory\u1d52\u1d56\n\u03b8 : \u0394\u271d \u27f6 \u0394'\nN : \u2115 \u2192 C\n\u0394 : SimplexCategory\u1d52\u1d56\nX\u271d : SimplicialObject C\n\u03c6 : (n : \u2115) \u2192 N n \u27f6 X\u271d.obj (op (SimplexCategory.mk n))\nX Y : SimplicialObject C\ns : sorry\nn : \u2115\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem augment_hom_zero (X : CosimplicialObject C) (X\u2080 : C) (f : X\u2080 \u27f6 X.obj \u298b0\u298c) (w) :\n    (X.augment X\u2080 f w).hom.app \u298b0\u298c = f := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplicialObject/Basic.lean", "context": {"open": ["Opposite", "CategoryTheory", "CategoryTheory.Limits CategoryTheory.Functor", "Simplicial", "Simplicial", "Mathlib.Tactic (subscriptTerm) in", "scoped SimplexCategory.Truncated in", "Simplicial", "Mathlib.Tactic (subscriptTerm) in", "scoped SimplexCategory.Truncated in", "Simplicial"], "variables": ["(C : Type u) [Category.{v} C]", "{C}", "(X : SimplicialObject C)", "(C)", "{C}", "(C) in", "(C) in", "(n : \u2115)", "[\u2200 (F : (SimplexCategory.Truncated n)\u1d52\u1d56 \u2964 C),", "[\u2200 (F : (SimplexCategory.Truncated n)\u1d52\u1d56 \u2964 C),", "[\u2200 (F : (SimplexCategory.Truncated n)\u1d52\u1d56 \u2964 C),", "[\u2200 (F : (SimplexCategory.Truncated n)\u1d52\u1d56 \u2964 C),", "(C)", "{C}", "(C)", "{C}", "{C}", "(X : CosimplicialObject C)", "(C)", "{C}", "(C) in", "(C) in", "(C)", "{C}", "(C)", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX : CosimplicialObject C\nX\u2080 : C\nf : X\u2080 \u27f6 X.obj (SimplexCategory.mk 0)\nw :\n  \u2200 (i : SimplexCategory) (g\u2081 g\u2082 : SimplexCategory.mk 0 \u27f6 i),\n    CategoryStruct.comp f (X.map g\u2081) = CategoryStruct.comp f (X.map g\u2082)\n\u22a2 (X.augment X\u2080 f w).hom.app (SimplexCategory.mk 0) = f"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma const_comp {X Y Z : SSet.{u}} (y : Y _\u298b0\u298c) (g : Y \u27f6 Z) :\n    const (X := X) y \u226b g = const (g.app _ y) := by\n  ext m x\n  simp [FunctorToTypes.naturality]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplicialSet/Basic.lean", "context": {"open": ["CategoryTheory CategoryTheory.Limits CategoryTheory.Functor", "Simplicial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : SSet\ny : Y.obj (Opposite.op (SimplexCategory.mk 0))\ng : Y \u27f6 Z\n\u22a2 CategoryStruct.comp sorry g = sorry"}, {"line": "ext m x", "tactic_state": "case w.h\nX Y Z : SSet\ny : Y.obj (Opposite.op (SimplexCategory.mk 0))\ng : Y \u27f6 Z\nm : SimplexCategory\u1d52\u1d56\nx : (toPrefunctor (?m.5874 y g)).obj m\n\u22a2 (CategoryStruct.comp sorry g).app m x = sorry.app m x"}, {"line": "simp [FunctorToTypes.naturality]", "tactic_state": "case w.h\nX Y Z : SSet\ny : Y.obj (Opposite.op (SimplexCategory.mk 0))\ng : Y \u27f6 Z\nm : SimplexCategory\u1d52\u1d56\nx : (toPrefunctor (?m.5874 y g)).obj m\n\u22a2 g.app m ((sorry ()).app m x) = (sorry ()).app m x"}]}
{"declaration": "lemma degenerate_zero : X.degenerate 0 = \u22a5 := by\n  ext x\n  simp only [Set.bot_eq_empty]\n  simp only [Set.mem_empty_iff_false]\n  simp only [iff_false]\n  rintro \u27e8m, hm, _\u27e9\n  simp at hm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplicialSet/Degenerate.lean", "context": {"open": ["CategoryTheory Simplicial Limits Opposite"], "variables": ["(X : SSet.{u})"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : SSet\n\u22a2 X.degenerate 0 = \u22a5"}, {"line": "ext x", "tactic_state": "case h\nX : SSet\nx : X.obj (op (SimplexCategory.mk 0))\n\u22a2 x \u2208 X.degenerate 0 \u2194 x \u2208 \u22a5"}, {"line": "simp only [Set.bot_eq_empty]", "tactic_state": "case h\nX : SSet\nx : X.obj (op (SimplexCategory.mk 0))\n\u22a2 x \u2208 X.degenerate 0 \u2194 x \u2208 \u2205"}, {"line": "simp only [Set.mem_empty_iff_false]", "tactic_state": "case h\nX : SSet\nx : X.obj (op (SimplexCategory.mk 0))\n\u22a2 x \u2208 X.degenerate 0 \u2194 False"}, {"line": "simp only [iff_false]", "tactic_state": "case h\nX : SSet\nx : X.obj (op (SimplexCategory.mk 0))\n\u22a2 x \u2209 X.degenerate 0"}, {"line": "rintro \u27e8m, hm, _\u27e9", "tactic_state": "case h.intro.intro\nX : SSet\nx : X.obj (op (SimplexCategory.mk 0))\nm : \u2115\nhm : m < 0\nh\u271d : \u2203 f, x \u2208 Set.range (X.map f.op)\n\u22a2 False"}, {"line": "simp at hm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nondegenerate_zero : X.nonDegenerate 0 = \u22a4 := by\n  simp [nonDegenerate]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplicialSet/Degenerate.lean", "context": {"open": ["CategoryTheory Simplicial Limits Opposite"], "variables": ["(X : SSet.{u})"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : SSet\n\u22a2 X.nonDegenerate 0 = \u22a4"}, {"line": "simp [nonDegenerate]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma OneTruncation\u2082.homOfEq_edge\n    {X : SSet.Truncated.{u} 2} {x\u2081 y\u2081 x\u2082 y\u2082 : OneTruncation\u2082 X}\n    (f : x\u2081 \u27f6 y\u2081) (hx : x\u2081 = x\u2082) (hy : y\u2081 = y\u2082) :\n    (Quiver.homOfEq f hx hy).edge = f.edge := by\n  subst hx hy\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplicialSet/HomotopyCat.lean", "context": {"open": ["CategoryTheory Category Limits Functor Opposite Simplicial Nerve", "SimplexCategory.Truncated SimplicialObject.Truncated"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nOneTruncation\u2082 : x\u271d\nX : SSet.Truncated 2\nx\u2081 : sorry\ny\u2081 : sorry\nx\u2082 : sorry\ny\u2082 : sorry\nf : x\u2081 \u27f6 y\u2081\nhx : x\u2081 = x\u2082\nhy : y\u2081 = y\u2082\n\u22a2 sorry = sorry"}, {"line": "subst hx hy", "tactic_state": "x\u271d : Sort u_1\nOneTruncation\u2082 : x\u271d\nX : SSet.Truncated 2\nx\u2081 : sorry\ny\u2081 : sorry\nf : x\u2081 \u27f6 y\u2081\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma map_map_of_eq.{w}  {C : Type u} [Category.{v} C] (V : C\u1d52\u1d56 \u2964 Type w) {X Y Z : C}\n    {\u03b1 : X \u27f6 Y} {\u03b2 : Y \u27f6 Z} {\u03b3 : X \u27f6 Z} {\u03c6} :\n    \u03b1 \u226b \u03b2 = \u03b3 \u2192 V.map \u03b1.op (V.map \u03b2.op \u03c6) = V.map \u03b3.op \u03c6 := by\n  rintro rfl\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplicialSet/HomotopyCat.lean", "context": {"open": ["CategoryTheory Category Limits Functor Opposite Simplicial Nerve", "SimplexCategory.Truncated SimplicialObject.Truncated"], "variables": ["{C : Type u} [Category.{v} C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nV : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nX Y Z : C\n\u03b1 : X \u27f6 Y\n\u03b2 : Y \u27f6 Z\n\u03b3 : X \u27f6 Z\n\u03c6 : V.obj (op Z)\n\u22a2 CategoryStruct.comp \u03b1 \u03b2 = \u03b3 \u2192 V.map \u03b1.op (V.map \u03b2.op \u03c6) = V.map \u03b3.op \u03c6"}, {"line": "rintro rfl", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nV : CategoryTheory.Functor C\u1d52\u1d56 (Type w)\nX Y Z : C\n\u03b1 : X \u27f6 Y\n\u03b2 : Y \u27f6 Z\n\u03c6 : V.obj (op Z)\n\u22a2 V.map \u03b1.op (V.map \u03b2.op \u03c6) = V.map (CategoryStruct.comp \u03b1 \u03b2).op \u03c6"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_apply {m\u2081 m\u2082 : SimplexCategory\u1d52\u1d56} (f : m\u2081 \u27f6 m\u2082) {n : SimplexCategory}\n    (x : (stdSimplex.{u}.obj n).obj m\u2081) :\n    (stdSimplex.{u}.obj n).map f x = objEquiv.symm (f.unop \u226b objEquiv x) := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplicialSet/StdSimplex.lean", "context": {"open": ["CategoryTheory Limits Simplicial Opposite", "Finset Opposite SimplexCategory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m\u2081 m\u2082 : SimplexCategory\u1d52\u1d56\nf : m\u2081 \u27f6 m\u2082\nn : SimplexCategory\nx : sorry\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_face_iff {n : \u2115} (S : Finset (Fin (n + 1))) {d : \u2115} (x : (\u0394[n] : SSet.{u}) _\u298bd\u298c) :\n    x \u2208 (face S).obj _ \u2194 \u2200 (i : Fin (d + 1)), x i \u2208 S := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplicialSet/StdSimplex.lean", "context": {"open": ["CategoryTheory Limits Simplicial Opposite", "Finset Opposite SimplexCategory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nface : x\u271d\nn : \u2115\nS : Finset (Fin (n + 1))\nd : \u2115\nx : (SSet.stdSimplex.obj (SimplexCategory.mk n)).obj (op (SimplexCategory.mk d))\n\u22a2 x \u2208 sorry \u2194 \u2200 (i : Fin (d + 1)), x i \u2208 S"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nface : x\u271d\nn : \u2115\nS : Finset (Fin (n + 1))\nd : \u2115\nx : (SSet.stdSimplex.obj (SimplexCategory.mk n)).obj (op (SimplexCategory.mk d))\n\u22a2 x \u2208 sorry () \u2194 \u2200 (i : Fin (d + 1)), x i \u2208 S"}]}
{"declaration": "lemma face_inter_face {n : \u2115} (S\u2081 S\u2082 : Finset (Fin (n + 1))) :\n    face S\u2081 \u2293 face S\u2082 = face (S\u2081 \u2293 S\u2082) := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicTopology/SimplicialSet/StdSimplex.lean", "context": {"open": ["CategoryTheory Limits Simplicial Opposite", "Finset Opposite SimplexCategory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nface : x\u271d\nn : \u2115\nS\u2081 S\u2082 : Finset (Fin (n + 1))\n\u22a2 sorry \u2293 sorry = sorry"}, {"line": "aesop", "tactic_state": "x : Sort u_1\nface : x\nn : \u2115\nS\u2081 S\u2082 : Finset (Fin (n + 1))\n\u22a2 sorry () \u2293 sorry () = sorry ()"}]}
{"declaration": "theorem ae_differentiableWithinAt_of_mem_real {f : \u211d \u2192 \u211d} {s : Set \u211d}\n    (h : LocallyBoundedVariationOn f s) : \u2200\u1d50 x, x \u2208 s \u2192 DifferentiableWithinAt \u211d f s x := by\n  obtain \u27e8p, q, hp, hq, rfl\u27e9 : \u2203 p q, MonotoneOn p s \u2227 MonotoneOn q s \u2227 f = p - q :=\n    h.exists_monotoneOn_sub_monotoneOn\n  filter_upwards [hp.ae_differentiableWithinAt_of_mem, hq.ae_differentiableWithinAt_of_mem] with\n    x hxp hxq xs\n  exact (hxp xs).sub (hxq xs)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoundedVariation.lean", "context": {"open": ["scoped NNReal ENNReal Topology", "Set MeasureTheory Filter"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] {E : Type*} [PseudoEMetricSpace E]", "{V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] [FiniteDimensional \u211d V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\ns : Set \u211d\nh : LocallyBoundedVariationOn f s\n\u22a2 \u2200\u1d50 (x : \u211d), x \u2208 s \u2192 DifferentiableWithinAt \u211d f s x"}, {"line": "obtain \u27e8p, q, hp, hq, rfl\u27e9 : \u2203 p q, MonotoneOn p s \u2227 MonotoneOn q s \u2227 f = p - q :=\n    h.exists_monotoneOn_sub_monotoneOn", "tactic_state": "case intro.intro.intro.intro\ns : Set \u211d\np q : \u211d \u2192 \u211d\nhp : MonotoneOn p s\nhq : MonotoneOn q s\nh : LocallyBoundedVariationOn (p - q) s\n\u22a2 \u2200\u1d50 (x : \u211d), x \u2208 s \u2192 DifferentiableWithinAt \u211d (p - q) s x"}, {"line": "filter_upwards [hp.ae_differentiableWithinAt_of_mem, hq.ae_differentiableWithinAt_of_mem] with\n    x hxp hxq xs", "tactic_state": "case h\ns : Set \u211d\np q : \u211d \u2192 \u211d\nhp : MonotoneOn p s\nhq : MonotoneOn q s\nh : LocallyBoundedVariationOn (p - q) s\nx : \u211d\nhxp : x \u2208 s \u2192 DifferentiableWithinAt \u211d p s x\nhxq : x \u2208 s \u2192 DifferentiableWithinAt \u211d q s x\nxs : x \u2208 s\n\u22a2 DifferentiableWithinAt \u211d (p - q) s x"}, {"line": "exact (hxp xs).sub (hxq xs)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_differentiableWithinAt {f : \u211d \u2192 V} {s : Set \u211d} (h : LocallyBoundedVariationOn f s)\n    (hs : MeasurableSet s) : \u2200\u1d50 x \u2202volume.restrict s, DifferentiableWithinAt \u211d f s x := by\n  rw [ae_restrict_iff' hs]\n  exact h.ae_differentiableWithinAt_of_mem\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoundedVariation.lean", "context": {"open": ["scoped NNReal ENNReal Topology", "Set MeasureTheory Filter"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] {E : Type*} [PseudoEMetricSpace E]", "{V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] [FiniteDimensional \u211d V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : NormedSpace \u211d V\ninst\u271d : FiniteDimensional \u211d V\nf : \u211d \u2192 V\ns : Set \u211d\nh : LocallyBoundedVariationOn f s\nhs : MeasurableSet s\n\u22a2 \u2200\u1d50 (x : \u211d) \u2202volume.restrict s, DifferentiableWithinAt \u211d f s x"}, {"line": "rw [ae_restrict_iff' hs]", "tactic_state": "V : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : NormedSpace \u211d V\ninst\u271d : FiniteDimensional \u211d V\nf : \u211d \u2192 V\ns : Set \u211d\nh : LocallyBoundedVariationOn f s\nhs : MeasurableSet s\n\u22a2 \u2200\u1d50 (x : \u211d), x \u2208 s \u2192 DifferentiableWithinAt \u211d f s x"}, {"line": "exact h.ae_differentiableWithinAt_of_mem", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_differentiableAt {f : \u211d \u2192 V} (h : LocallyBoundedVariationOn f univ) :\n    \u2200\u1d50 x, DifferentiableAt \u211d f x := by\n  filter_upwards [h.ae_differentiableWithinAt_of_mem] with x hx\n  rw [differentiableWithinAt_univ] at hx\n  exact hx (mem_univ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoundedVariation.lean", "context": {"open": ["scoped NNReal ENNReal Topology", "Set MeasureTheory Filter"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] {E : Type*} [PseudoEMetricSpace E]", "{V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] [FiniteDimensional \u211d V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : NormedSpace \u211d V\ninst\u271d : FiniteDimensional \u211d V\nf : \u211d \u2192 V\nh : LocallyBoundedVariationOn f univ\n\u22a2 \u2200\u1d50 (x : \u211d), DifferentiableAt \u211d f x"}, {"line": "filter_upwards [h.ae_differentiableWithinAt_of_mem] with x hx", "tactic_state": "case h\nV : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : NormedSpace \u211d V\ninst\u271d : FiniteDimensional \u211d V\nf : \u211d \u2192 V\nh : LocallyBoundedVariationOn f univ\nx : \u211d\nhx : x \u2208 univ \u2192 DifferentiableWithinAt \u211d f univ x\n\u22a2 DifferentiableAt \u211d f x"}, {"line": "rw [differentiableWithinAt_univ] at hx", "tactic_state": "case h\nV : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : NormedSpace \u211d V\ninst\u271d : FiniteDimensional \u211d V\nf : \u211d \u2192 V\nh : LocallyBoundedVariationOn f univ\nx : \u211d\nhx : x \u2208 univ \u2192 DifferentiableAt \u211d f x\n\u22a2 DifferentiableAt \u211d f x\n---\nV : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : NormedSpace \u211d V\ninst\u271d : FiniteDimensional \u211d V\nf : \u211d \u2192 V\nh : LocallyBoundedVariationOn f univ\n\u22a2 NormedSpace \u211d V"}, {"line": "exact hx (mem_univ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasConstantSpeedOnWith.ratio {l' : \u211d\u22650} (hl' : l' \u2260 0) {\u03c6 : \u211d \u2192 \u211d} (\u03c6m : MonotoneOn \u03c6 s)\n    (hf\u03c6 : HasConstantSpeedOnWith (f \u2218 \u03c6) s l) (hf : HasConstantSpeedOnWith f (\u03c6 '' s) l') \u2983x : \u211d\u2984\n    (xs : x \u2208 s) : EqOn \u03c6 (fun y => l / l' * (y - x) + \u03c6 x) s := by\n  rintro y ys\n  rw [\u2190 sub_eq_iff_eq_add]\n  rw [mul_comm]\n  rw [\u2190 mul_div_assoc]\n  rw [eq_div_iff (NNReal.coe_ne_zero.mpr hl')]\n  rw [hasConstantSpeedOnWith_iff_variationOnFromTo_eq] at hf\n  rw [hasConstantSpeedOnWith_iff_variationOnFromTo_eq] at hf\u03c6\n  symm\n  calc\n    (y - x) * l = l * (y - x) := by rw [mul_comm]\n    _ = variationOnFromTo (f \u2218 \u03c6) s x y := (hf\u03c6.2 xs ys).symm\n    _ = variationOnFromTo f (\u03c6 '' s) (\u03c6 x) (\u03c6 y) :=\n      (variationOnFromTo.comp_eq_of_monotoneOn f \u03c6 \u03c6m xs ys)\n    _ = l' * (\u03c6 y - \u03c6 x) := (hf.2 \u27e8x, xs, rfl\u27e9 \u27e8y, ys, rfl\u27e9)\n    _ = (\u03c6 y - \u03c6 x) * l' := by rw [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/ConstantSpeed.lean", "context": {"open": ["scoped NNReal ENNReal", "Set"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] {E : Type*} [PseudoEMetricSpace E]", "(f : \u211d \u2192 E) (s : Set \u211d) (l : \u211d\u22650)", "{f s l}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns : Set \u211d\nl l' : NNReal\nhl' : l' \u2260 0\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 s\nhf\u03c6 : HasConstantSpeedOnWith (f \u2218 \u03c6) s l\nhf : HasConstantSpeedOnWith f (\u03c6 '' s) l'\nx : \u211d\nxs : x \u2208 s\n\u22a2 EqOn \u03c6 (fun y => \u2191l / \u2191l' * (y - x) + \u03c6 x) s"}, {"line": "rintro y ys", "tactic_state": "E : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns : Set \u211d\nl l' : NNReal\nhl' : l' \u2260 0\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 s\nhf\u03c6 : HasConstantSpeedOnWith (f \u2218 \u03c6) s l\nhf : HasConstantSpeedOnWith f (\u03c6 '' s) l'\nx : \u211d\nxs : x \u2208 s\ny : \u211d\nys : y \u2208 s\n\u22a2 \u03c6 y = (fun y => \u2191l / \u2191l' * (y - x) + \u03c6 x) y"}, {"line": "rw [\u2190 sub_eq_iff_eq_add]", "tactic_state": "E : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns : Set \u211d\nl l' : NNReal\nhl' : l' \u2260 0\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 s\nhf\u03c6 : HasConstantSpeedOnWith (f \u2218 \u03c6) s l\nhf : HasConstantSpeedOnWith f (\u03c6 '' s) l'\nx : \u211d\nxs : x \u2208 s\ny : \u211d\nys : y \u2208 s\n\u22a2 \u03c6 y - \u03c6 x = \u2191l / \u2191l' * (y - x)"}, {"line": "rw [mul_comm]", "tactic_state": "E : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns : Set \u211d\nl l' : NNReal\nhl' : l' \u2260 0\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 s\nhf\u03c6 : HasConstantSpeedOnWith (f \u2218 \u03c6) s l\nhf : HasConstantSpeedOnWith f (\u03c6 '' s) l'\nx : \u211d\nxs : x \u2208 s\ny : \u211d\nys : y \u2208 s\n\u22a2 \u03c6 y - \u03c6 x = (y - x) * (\u2191l / \u2191l')"}, {"line": "rw [\u2190 mul_div_assoc]", "tactic_state": "E : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns : Set \u211d\nl l' : NNReal\nhl' : l' \u2260 0\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 s\nhf\u03c6 : HasConstantSpeedOnWith (f \u2218 \u03c6) s l\nhf : HasConstantSpeedOnWith f (\u03c6 '' s) l'\nx : \u211d\nxs : x \u2208 s\ny : \u211d\nys : y \u2208 s\n\u22a2 \u03c6 y - \u03c6 x = (y - x) * \u2191l / \u2191l'"}, {"line": "rw [eq_div_iff (NNReal.coe_ne_zero.mpr hl')]", "tactic_state": "E : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns : Set \u211d\nl l' : NNReal\nhl' : l' \u2260 0\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 s\nhf\u03c6 : HasConstantSpeedOnWith (f \u2218 \u03c6) s l\nhf : HasConstantSpeedOnWith f (\u03c6 '' s) l'\nx : \u211d\nxs : x \u2208 s\ny : \u211d\nys : y \u2208 s\n\u22a2 (\u03c6 y - \u03c6 x) * \u2191l' = (y - x) * \u2191l"}, {"line": "rw [hasConstantSpeedOnWith_iff_variationOnFromTo_eq] at hf", "tactic_state": "E : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns : Set \u211d\nl l' : NNReal\nhl' : l' \u2260 0\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 s\nhf\u03c6 : HasConstantSpeedOnWith (f \u2218 \u03c6) s l\nhf :\n  LocallyBoundedVariationOn f (\u03c6 '' s) \u2227\n    \u2200 \u2983x : \u211d\u2984, x \u2208 \u03c6 '' s \u2192 \u2200 \u2983y : \u211d\u2984, y \u2208 \u03c6 '' s \u2192 variationOnFromTo f (\u03c6 '' s) x y = \u2191l' * (y - x)\nx : \u211d\nxs : x \u2208 s\ny : \u211d\nys : y \u2208 s\n\u22a2 (\u03c6 y - \u03c6 x) * \u2191l' = (y - x) * \u2191l"}, {"line": "rw [hasConstantSpeedOnWith_iff_variationOnFromTo_eq] at hf\u03c6", "tactic_state": "E : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns : Set \u211d\nl l' : NNReal\nhl' : l' \u2260 0\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 s\nhf\u03c6 :\n  LocallyBoundedVariationOn (f \u2218 \u03c6) s \u2227\n    \u2200 \u2983x : \u211d\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u211d\u2984, y \u2208 s \u2192 variationOnFromTo (f \u2218 \u03c6) s x y = \u2191l * (y - x)\nhf :\n  LocallyBoundedVariationOn f (\u03c6 '' s) \u2227\n    \u2200 \u2983x : \u211d\u2984, x \u2208 \u03c6 '' s \u2192 \u2200 \u2983y : \u211d\u2984, y \u2208 \u03c6 '' s \u2192 variationOnFromTo f (\u03c6 '' s) x y = \u2191l' * (y - x)\nx : \u211d\nxs : x \u2208 s\ny : \u211d\nys : y \u2208 s\n\u22a2 (\u03c6 y - \u03c6 x) * \u2191l' = (y - x) * \u2191l"}, {"line": "symm", "tactic_state": "E : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns : Set \u211d\nl l' : NNReal\nhl' : l' \u2260 0\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 s\nhf\u03c6 :\n  LocallyBoundedVariationOn (f \u2218 \u03c6) s \u2227\n    \u2200 \u2983x : \u211d\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u211d\u2984, y \u2208 s \u2192 variationOnFromTo (f \u2218 \u03c6) s x y = \u2191l * (y - x)\nhf :\n  LocallyBoundedVariationOn f (\u03c6 '' s) \u2227\n    \u2200 \u2983x : \u211d\u2984, x \u2208 \u03c6 '' s \u2192 \u2200 \u2983y : \u211d\u2984, y \u2208 \u03c6 '' s \u2192 variationOnFromTo f (\u03c6 '' s) x y = \u2191l' * (y - x)\nx : \u211d\nxs : x \u2208 s\ny : \u211d\nys : y \u2208 s\n\u22a2 (y - x) * \u2191l = (\u03c6 y - \u03c6 x) * \u2191l'"}, {"line": "calc\n    (y - x) * l = l * (y - x) := by rw [mul_comm]\n    _ = variationOnFromTo (f \u2218 \u03c6) s x y := (hf\u03c6.2 xs ys).symm\n    _ = variationOnFromTo f (\u03c6 '' s) (\u03c6 x) (\u03c6 y) :=\n      (variationOnFromTo.comp_eq_of_monotoneOn f \u03c6 \u03c6m xs ys)\n    _ = l' * (\u03c6 y - \u03c6 x) := (hf.2 \u27e8x, xs, rfl\u27e9 \u27e8y, ys, rfl\u27e9)\n    _ = (\u03c6 y - \u03c6 x) * l' := by rw [mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem unique_unit_speed {\u03c6 : \u211d \u2192 \u211d} (\u03c6m : MonotoneOn \u03c6 s) (hf\u03c6 : HasUnitSpeedOn (f \u2218 \u03c6) s)\n    (hf : HasUnitSpeedOn f (\u03c6 '' s)) \u2983x : \u211d\u2984 (xs : x \u2208 s) : EqOn \u03c6 (fun y => y - x + \u03c6 x) s := by\n  dsimp only [HasUnitSpeedOn] at hf hf\u03c6\n  convert HasConstantSpeedOnWith.ratio one_ne_zero \u03c6m hf\u03c6 hf xs using 3\n  norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/ConstantSpeed.lean", "context": {"open": ["scoped NNReal ENNReal", "Set"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] {E : Type*} [PseudoEMetricSpace E]", "(f : \u211d \u2192 E) (s : Set \u211d) (l : \u211d\u22650)", "{f s l}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns : Set \u211d\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 s\nhf\u03c6 : HasUnitSpeedOn (f \u2218 \u03c6) s\nhf : HasUnitSpeedOn f (\u03c6 '' s)\nx : \u211d\nxs : x \u2208 s\n\u22a2 EqOn \u03c6 (fun y => y - x + \u03c6 x) s"}, {"line": "dsimp only [HasUnitSpeedOn] at hf hf\u03c6", "tactic_state": "E : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns : Set \u211d\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 s\nhf\u03c6 : HasConstantSpeedOnWith (f \u2218 \u03c6) s 1\nhf : HasConstantSpeedOnWith f (\u03c6 '' s) 1\nx : \u211d\nxs : x \u2208 s\n\u22a2 EqOn \u03c6 (fun y => y - x + \u03c6 x) s"}, {"line": "convert HasConstantSpeedOnWith.ratio one_ne_zero \u03c6m hf\u03c6 hf xs using 3", "tactic_state": "case h.e'_4.h.h.e'_5\nE : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns : Set \u211d\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 s\nhf\u03c6 : HasConstantSpeedOnWith (f \u2218 \u03c6) s 1\nhf : HasConstantSpeedOnWith f (\u03c6 '' s) 1\nx : \u211d\nxs : x \u2208 s\nx\u271d : \u211d\n\u22a2 x\u271d - x = \u21911 / \u21911 * (x\u271d - x)"}, {"line": "norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem unique_unit_speed_on_Icc_zero {s t : \u211d} (hs : 0 \u2264 s) (ht : 0 \u2264 t) {\u03c6 : \u211d \u2192 \u211d}\n    (\u03c6m : MonotoneOn \u03c6 <| Icc 0 s) (\u03c6st : \u03c6 '' Icc 0 s = Icc 0 t)\n    (hf\u03c6 : HasUnitSpeedOn (f \u2218 \u03c6) (Icc 0 s)) (hf : HasUnitSpeedOn f (Icc 0 t)) :\n    EqOn \u03c6 id (Icc 0 s) := by\n  rw [\u2190 \u03c6st] at hf\n  convert unique_unit_speed \u03c6m hf\u03c6 hf \u27e8le_rfl, hs\u27e9 using 1\n  have : \u03c6 0 = 0 := by\n    have hm : 0 \u2208 \u03c6 '' Icc 0 s := by simp only [\u03c6st, ht, mem_Icc, le_refl, and_self]\n    obtain \u27e8x, xs, hx\u27e9 := hm\n    apply le_antisymm ((\u03c6m \u27e8le_rfl, hs\u27e9 xs xs.1).trans_eq hx) _\n    have := \u03c6st \u25b8 mapsTo_image \u03c6 (Icc 0 s)\n    exact (mem_Icc.mp (@this 0 (by rw [mem_Icc]; exact \u27e8le_rfl, hs\u27e9))).1\n  simp only [tsub_zero]\n  simp only [this]\n  simp only [add_zero]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/ConstantSpeed.lean", "context": {"open": ["scoped NNReal ENNReal", "Set"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] {E : Type*} [PseudoEMetricSpace E]", "(f : \u211d \u2192 E) (s : Set \u211d) (l : \u211d\u22650)", "{f s l}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns t : \u211d\nhs : 0 \u2264 s\nht : 0 \u2264 t\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 (Icc 0 s)\n\u03c6st : \u03c6 '' Icc 0 s = Icc 0 t\nhf\u03c6 : HasUnitSpeedOn (f \u2218 \u03c6) (Icc 0 s)\nhf : HasUnitSpeedOn f (Icc 0 t)\n\u22a2 EqOn \u03c6 id (Icc 0 s)"}, {"line": "rw [\u2190 \u03c6st] at hf", "tactic_state": "E : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns t : \u211d\nhs : 0 \u2264 s\nht : 0 \u2264 t\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 (Icc 0 s)\n\u03c6st : \u03c6 '' Icc 0 s = Icc 0 t\nhf\u03c6 : HasUnitSpeedOn (f \u2218 \u03c6) (Icc 0 s)\nhf : HasUnitSpeedOn f (\u03c6 '' Icc 0 s)\n\u22a2 EqOn \u03c6 id (Icc 0 s)"}, {"line": "convert unique_unit_speed \u03c6m hf\u03c6 hf \u27e8le_rfl, hs\u27e9 using 1", "tactic_state": "case h.e'_4\nE : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns t : \u211d\nhs : 0 \u2264 s\nht : 0 \u2264 t\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 (Icc 0 s)\n\u03c6st : \u03c6 '' Icc 0 s = Icc 0 t\nhf\u03c6 : HasUnitSpeedOn (f \u2218 \u03c6) (Icc 0 s)\nhf : HasUnitSpeedOn f (\u03c6 '' Icc 0 s)\n\u22a2 id = fun y => y - 0 + \u03c6 0"}, {"line": "have : \u03c6 0 = 0 := by\n    have hm : 0 \u2208 \u03c6 '' Icc 0 s := by simp only [\u03c6st, ht, mem_Icc, le_refl, and_self]\n    obtain \u27e8x, xs, hx\u27e9 := hm\n    apply le_antisymm ((\u03c6m \u27e8le_rfl, hs\u27e9 xs xs.1).trans_eq hx) _\n    have := \u03c6st \u25b8 mapsTo_image \u03c6 (Icc 0 s)\n    exact (mem_Icc.mp (@this 0 (by rw [mem_Icc]; exact \u27e8le_rfl, hs\u27e9))).1", "tactic_state": "case h.e'_4\nE : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns t : \u211d\nhs : 0 \u2264 s\nht : 0 \u2264 t\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 (Icc 0 s)\n\u03c6st : \u03c6 '' Icc 0 s = Icc 0 t\nhf\u03c6 : HasUnitSpeedOn (f \u2218 \u03c6) (Icc 0 s)\nhf : HasUnitSpeedOn f (\u03c6 '' Icc 0 s)\nthis : \u03c6 0 = 0\n\u22a2 id = fun y => y - 0 + \u03c6 0"}, {"line": "simp only [tsub_zero]", "tactic_state": "case h.e'_4\nE : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns t : \u211d\nhs : 0 \u2264 s\nht : 0 \u2264 t\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 (Icc 0 s)\n\u03c6st : \u03c6 '' Icc 0 s = Icc 0 t\nhf\u03c6 : HasUnitSpeedOn (f \u2218 \u03c6) (Icc 0 s)\nhf : HasUnitSpeedOn f (\u03c6 '' Icc 0 s)\nthis : \u03c6 0 = 0\n\u22a2 id = fun y => y + \u03c6 0"}, {"line": "simp only [this]", "tactic_state": "case h.e'_4\nE : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns t : \u211d\nhs : 0 \u2264 s\nht : 0 \u2264 t\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 (Icc 0 s)\n\u03c6st : \u03c6 '' Icc 0 s = Icc 0 t\nhf\u03c6 : HasUnitSpeedOn (f \u2218 \u03c6) (Icc 0 s)\nhf : HasUnitSpeedOn f (\u03c6 '' Icc 0 s)\nthis : \u03c6 0 = 0\n\u22a2 id = fun y => y + 0"}, {"line": "simp only [add_zero]", "tactic_state": "case h.e'_4\nE : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns t : \u211d\nhs : 0 \u2264 s\nht : 0 \u2264 t\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 (Icc 0 s)\n\u03c6st : \u03c6 '' Icc 0 s = Icc 0 t\nhf\u03c6 : HasUnitSpeedOn (f \u2218 \u03c6) (Icc 0 s)\nhf : HasUnitSpeedOn f (\u03c6 '' Icc 0 s)\nthis : \u03c6 0 = 0\n\u22a2 id = fun y => y"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_add_le_mul_rpow_add_rpow (z\u2081 z\u2082 : \u211d\u22650) {p : \u211d} (hp : 1 \u2264 p) :\n    (z\u2081 + z\u2082) ^ p \u2264 (2 : \u211d\u22650) ^ (p - 1) * (z\u2081 ^ p + z\u2082 ^ p) := by\n  rcases eq_or_lt_of_le hp with (rfl | h'p)\n  \u00b7 simp only [rpow_one, sub_self, rpow_zero, one_mul]; rfl\n  convert rpow_arith_mean_le_arith_mean2_rpow (1 / 2) (1 / 2) (2 * z\u2081) (2 * z\u2082) (add_halves 1) hp\n    using 1\n  \u00b7 simp only [one_div, inv_mul_cancel_left\u2080, Ne, mul_eq_zero, two_ne_zero, one_ne_zero,\n      not_false_iff]\n  \u00b7 have A : p - 1 \u2260 0 := ne_of_gt (sub_pos.2 h'p)\n    simp only [mul_rpow]\n    simp only [rpow_sub' A]\n    simp only [div_eq_inv_mul]\n    simp only [rpow_one]\n    simp only [mul_one]\n    ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalitiesPow.lean", "context": {"open": ["Finset NNReal ENNReal"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z\u2081 z\u2082 : NNReal\np : \u211d\nhp : 1 \u2264 p\n\u22a2 (z\u2081 + z\u2082) ^ p \u2264 2 ^ (p - 1) * (z\u2081 ^ p + z\u2082 ^ p)"}, {"line": "rcases eq_or_lt_of_le hp with (rfl | h'p)", "tactic_state": "case inl\nz\u2081 z\u2082 : NNReal\nhp : 1 \u2264 1\n\u22a2 (z\u2081 + z\u2082) ^ 1 \u2264 2 ^ (1 - 1) * (z\u2081 ^ 1 + z\u2082 ^ 1)\n---\ncase inr\nz\u2081 z\u2082 : NNReal\np : \u211d\nhp : 1 \u2264 p\nh'p : 1 < p\n\u22a2 (z\u2081 + z\u2082) ^ p \u2264 2 ^ (p - 1) * (z\u2081 ^ p + z\u2082 ^ p)"}, {"line": "\u00b7 simp only [rpow_one, sub_self, rpow_zero, one_mul]; rfl", "tactic_state": "case inr\nz\u2081 z\u2082 : NNReal\np : \u211d\nhp : 1 \u2264 p\nh'p : 1 < p\n\u22a2 (z\u2081 + z\u2082) ^ p \u2264 2 ^ (p - 1) * (z\u2081 ^ p + z\u2082 ^ p)"}, {"line": "convert rpow_arith_mean_le_arith_mean2_rpow (1 / 2) (1 / 2) (2 * z\u2081) (2 * z\u2082) (add_halves 1) hp\n    using 1", "tactic_state": "case h.e'_3\nz\u2081 z\u2082 : NNReal\np : \u211d\nhp : 1 \u2264 p\nh'p : 1 < p\n\u22a2 (z\u2081 + z\u2082) ^ p = (1 / 2 * (2 * z\u2081) + 1 / 2 * (2 * z\u2082)) ^ p\n---\ncase h.e'_4\nz\u2081 z\u2082 : NNReal\np : \u211d\nhp : 1 \u2264 p\nh'p : 1 < p\n\u22a2 2 ^ (p - 1) * (z\u2081 ^ p + z\u2082 ^ p) = 1 / 2 * (2 * z\u2081) ^ p + 1 / 2 * (2 * z\u2082) ^ p"}, {"line": "\u00b7 simp only [one_div, inv_mul_cancel_left\u2080, Ne, mul_eq_zero, two_ne_zero, one_ne_zero,\n      not_false_iff]", "tactic_state": "case h.e'_4\nz\u2081 z\u2082 : NNReal\np : \u211d\nhp : 1 \u2264 p\nh'p : 1 < p\n\u22a2 2 ^ (p - 1) * (z\u2081 ^ p + z\u2082 ^ p) = 1 / 2 * (2 * z\u2081) ^ p + 1 / 2 * (2 * z\u2082) ^ p"}, {"line": "\u00b7 have A : p - 1 \u2260 0 := ne_of_gt (sub_pos.2 h'p)\n    simp only [mul_rpow]\n    simp only [rpow_sub' A]\n    simp only [div_eq_inv_mul]\n    simp only [rpow_one]\n    simp only [mul_one]\n    ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_add_rpow_le_add {p : \u211d} (a b : \u211d\u22650) (hp1 : 1 \u2264 p) :\n    (a ^ p + b ^ p) ^ (1 / p) \u2264 a + b := by\n  rw [one_div]\n  rw [\u2190 @NNReal.le_rpow_inv_iff _ _ p\u207b\u00b9 (by simp [lt_of_lt_of_le zero_lt_one hp1])]\n  rw [inv_inv]\n  exact add_rpow_le_rpow_add _ _ hp1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalitiesPow.lean", "context": {"open": ["Finset NNReal ENNReal"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\na b : NNReal\nhp1 : 1 \u2264 p\n\u22a2 (a ^ p + b ^ p) ^ (1 / p) \u2264 a + b"}, {"line": "rw [one_div]", "tactic_state": "p : \u211d\na b : NNReal\nhp1 : 1 \u2264 p\n\u22a2 (a ^ p + b ^ p) ^ p\u207b\u00b9 \u2264 a + b"}, {"line": "rw [\u2190 @NNReal.le_rpow_inv_iff _ _ p\u207b\u00b9 (by simp [lt_of_lt_of_le zero_lt_one hp1])]", "tactic_state": "p : \u211d\na b : NNReal\nhp1 : 1 \u2264 p\n\u22a2 a ^ p + b ^ p \u2264 (a + b) ^ p\u207b\u00b9\u207b\u00b9"}, {"line": "rw [inv_inv]", "tactic_state": "p : \u211d\na b : NNReal\nhp1 : 1 \u2264 p\n\u22a2 a ^ p + b ^ p \u2264 (a + b) ^ p"}, {"line": "exact add_rpow_le_rpow_add _ _ hp1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_add_le_add_rpow {p : \u211d} (a b : \u211d\u22650) (hp : 0 \u2264 p) (hp1 : p \u2264 1) :\n    (a + b) ^ p \u2264 a ^ p + b ^ p := by\n  rcases hp.eq_or_lt with (rfl | hp_pos)\n  \u00b7 simp\n  have h := rpow_add_rpow_le a b hp_pos hp1\n  rw [one_div_one] at h\n  rw [one_div] at h\n  repeat' rw [NNReal.rpow_one] at h\n  exact (NNReal.le_rpow_inv_iff hp_pos).mp h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalitiesPow.lean", "context": {"open": ["Finset NNReal ENNReal"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\na b : NNReal\nhp : 0 \u2264 p\nhp1 : p \u2264 1\n\u22a2 (a + b) ^ p \u2264 a ^ p + b ^ p"}, {"line": "rcases hp.eq_or_lt with (rfl | hp_pos)", "tactic_state": "case inl\na b : NNReal\nhp : 0 \u2264 0\nhp1 : 0 \u2264 1\n\u22a2 (a + b) ^ 0 \u2264 a ^ 0 + b ^ 0\n---\ncase inr\np : \u211d\na b : NNReal\nhp : 0 \u2264 p\nhp1 : p \u2264 1\nhp_pos : 0 < p\n\u22a2 (a + b) ^ p \u2264 a ^ p + b ^ p"}, {"line": "\u00b7 simp", "tactic_state": "case inr\np : \u211d\na b : NNReal\nhp : 0 \u2264 p\nhp1 : p \u2264 1\nhp_pos : 0 < p\n\u22a2 (a + b) ^ p \u2264 a ^ p + b ^ p"}, {"line": "have h := rpow_add_rpow_le a b hp_pos hp1", "tactic_state": "case inr\np : \u211d\na b : NNReal\nhp : 0 \u2264 p\nhp1 : p \u2264 1\nhp_pos : 0 < p\nh : (a ^ 1 + b ^ 1) ^ (1 / 1) \u2264 (a ^ p + b ^ p) ^ (1 / p)\n\u22a2 (a + b) ^ p \u2264 a ^ p + b ^ p"}, {"line": "rw [one_div_one] at h", "tactic_state": "case inr\np : \u211d\na b : NNReal\nhp : 0 \u2264 p\nhp1 : p \u2264 1\nhp_pos : 0 < p\nh : (a ^ 1 + b ^ 1) ^ 1 \u2264 (a ^ p + b ^ p) ^ (1 / p)\n\u22a2 (a + b) ^ p \u2264 a ^ p + b ^ p"}, {"line": "rw [one_div] at h", "tactic_state": "case inr\np : \u211d\na b : NNReal\nhp : 0 \u2264 p\nhp1 : p \u2264 1\nhp_pos : 0 < p\nh : (a ^ 1 + b ^ 1) ^ 1 \u2264 (a ^ p + b ^ p) ^ p\u207b\u00b9\n\u22a2 (a + b) ^ p \u2264 a ^ p + b ^ p"}, {"line": "repeat' rw [NNReal.rpow_one] at h", "tactic_state": "case inr\np : \u211d\na b : NNReal\nhp : 0 \u2264 p\nhp1 : p \u2264 1\nhp_pos : 0 < p\nh : a + b \u2264 (a ^ p + b ^ p) ^ p\u207b\u00b9\n\u22a2 (a + b) ^ p \u2264 a ^ p + b ^ p"}, {"line": "exact (NNReal.le_rpow_inv_iff hp_pos).mp h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_rpow_le_rpow_add {p : \u211d} {a b : \u211d} (ha : 0 \u2264 a) (hb : 0 \u2264 b) (hp1 : 1 \u2264 p) :\n     a ^ p + b ^ p \u2264 (a + b) ^ p := by\n  lift a to NNReal using ha\n  lift b to NNReal using hb\n  exact_mod_cast NNReal.add_rpow_le_rpow_add a b hp1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalitiesPow.lean", "context": {"open": ["Finset NNReal ENNReal"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p a b : \u211d\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhp1 : 1 \u2264 p\n\u22a2 a ^ p + b ^ p \u2264 (a + b) ^ p"}, {"line": "lift a to NNReal using ha", "tactic_state": "case intro\np b : \u211d\nhb : 0 \u2264 b\nhp1 : 1 \u2264 p\na : NNReal\n\u22a2 \u2191a ^ p + b ^ p \u2264 (\u2191a + b) ^ p"}, {"line": "lift b to NNReal using hb", "tactic_state": "case intro.intro\np : \u211d\nhp1 : 1 \u2264 p\na b : NNReal\n\u22a2 \u2191a ^ p + \u2191b ^ p \u2264 (\u2191a + \u2191b) ^ p"}, {"line": "exact_mod_cast NNReal.add_rpow_le_rpow_add a b hp1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_add_rpow_le_add {p : \u211d} {a b : \u211d} (ha : 0 \u2264 a) (hb : 0 \u2264 b) (hp1 : 1 \u2264 p) :\n    (a ^ p + b ^ p) ^ (1 / p) \u2264 a + b := by\n  lift a to NNReal using ha\n  lift b to NNReal using hb\n  exact_mod_cast NNReal.rpow_add_rpow_le_add a b hp1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalitiesPow.lean", "context": {"open": ["Finset NNReal ENNReal"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p a b : \u211d\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhp1 : 1 \u2264 p\n\u22a2 (a ^ p + b ^ p) ^ (1 / p) \u2264 a + b"}, {"line": "lift a to NNReal using ha", "tactic_state": "case intro\np b : \u211d\nhb : 0 \u2264 b\nhp1 : 1 \u2264 p\na : NNReal\n\u22a2 (\u2191a ^ p + b ^ p) ^ (1 / p) \u2264 \u2191a + b"}, {"line": "lift b to NNReal using hb", "tactic_state": "case intro.intro\np : \u211d\nhp1 : 1 \u2264 p\na b : NNReal\n\u22a2 (\u2191a ^ p + \u2191b ^ p) ^ (1 / p) \u2264 \u2191a + \u2191b"}, {"line": "exact_mod_cast NNReal.rpow_add_rpow_le_add a b hp1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_add_rpow_le {p q : \u211d} {a b : \u211d} (ha : 0 \u2264 a) (hb : 0 \u2264 b) (hp_pos : 0 < p)\n    (hpq : p \u2264 q) :\n    (a ^ q + b ^ q) ^ (1 / q) \u2264 (a ^ p + b ^ p) ^ (1 / p) := by\n  lift a to NNReal using ha\n  lift b to NNReal using hb\n  exact_mod_cast NNReal.rpow_add_rpow_le a b hp_pos hpq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalitiesPow.lean", "context": {"open": ["Finset NNReal ENNReal"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q a b : \u211d\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhp_pos : 0 < p\nhpq : p \u2264 q\n\u22a2 (a ^ q + b ^ q) ^ (1 / q) \u2264 (a ^ p + b ^ p) ^ (1 / p)"}, {"line": "lift a to NNReal using ha", "tactic_state": "case intro\np q b : \u211d\nhb : 0 \u2264 b\nhp_pos : 0 < p\nhpq : p \u2264 q\na : NNReal\n\u22a2 (\u2191a ^ q + b ^ q) ^ (1 / q) \u2264 (\u2191a ^ p + b ^ p) ^ (1 / p)"}, {"line": "lift b to NNReal using hb", "tactic_state": "case intro.intro\np q : \u211d\nhp_pos : 0 < p\nhpq : p \u2264 q\na b : NNReal\n\u22a2 (\u2191a ^ q + \u2191b ^ q) ^ (1 / q) \u2264 (\u2191a ^ p + \u2191b ^ p) ^ (1 / p)"}, {"line": "exact_mod_cast NNReal.rpow_add_rpow_le a b hp_pos hpq", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_add_le_add_rpow {p : \u211d} {a b : \u211d} (ha : 0 \u2264 a) (hb : 0 \u2264 b) (hp : 0 \u2264 p)\n    (hp1 : p \u2264 1) :\n    (a + b) ^ p \u2264 a ^ p + b ^ p := by\n  lift a to NNReal using ha\n  lift b to NNReal using hb\n  exact_mod_cast NNReal.rpow_add_le_add_rpow a b hp hp1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalitiesPow.lean", "context": {"open": ["Finset NNReal ENNReal"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p a b : \u211d\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhp : 0 \u2264 p\nhp1 : p \u2264 1\n\u22a2 (a + b) ^ p \u2264 a ^ p + b ^ p"}, {"line": "lift a to NNReal using ha", "tactic_state": "case intro\np b : \u211d\nhb : 0 \u2264 b\nhp : 0 \u2264 p\nhp1 : p \u2264 1\na : NNReal\n\u22a2 (\u2191a + b) ^ p \u2264 \u2191a ^ p + b ^ p"}, {"line": "lift b to NNReal using hb", "tactic_state": "case intro.intro\np : \u211d\nhp : 0 \u2264 p\nhp1 : p \u2264 1\na b : NNReal\n\u22a2 (\u2191a + \u2191b) ^ p \u2264 \u2191a ^ p + \u2191b ^ p"}, {"line": "exact_mod_cast NNReal.rpow_add_le_add_rpow a b hp hp1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_arith_mean_le_arith_mean_rpow (w z : \u03b9 \u2192 \u211d\u22650\u221e) (hw' : \u2211 i \u2208 s, w i = 1) {p : \u211d}\n    (hp : 1 \u2264 p) : (\u2211 i \u2208 s, w i * z i) ^ p \u2264 \u2211 i \u2208 s, w i * z i ^ p := by\n  have hp_pos : 0 < p := by positivity\n  have hp_nonneg : 0 \u2264 p := by positivity\n  have hp_not_neg : \u00acp < 0 := by simp [hp_nonneg]\n  have h_top_iff_rpow_top : \u2200 (i : \u03b9), i \u2208 s \u2192 (w i * z i = \u22a4 \u2194 w i * z i ^ p = \u22a4) := by\n    simp [ENNReal.mul_eq_top, hp_pos, hp_nonneg, hp_not_neg]\n  refine le_of_top_imp_top_of_toNNReal_le ?_ ?_\n  \u00b7 -- first, prove `(\u2211 i \u2208 s, w i * z i) ^ p = \u22a4 \u2192 \u2211 i \u2208 s, (w i * z i ^ p) = \u22a4`\n    rw [rpow_eq_top_iff]\n    rw [sum_eq_top]\n    rw [sum_eq_top]\n    intro h\n    simp only [and_false] at h\n    simp only [hp_not_neg] at h\n    simp only [false_or] at h\n    rcases h.left with \u27e8a, H, ha\u27e9\n    use a, H\n    rwa [\u2190 h_top_iff_rpow_top a H]\n  \u00b7 -- second, suppose both `(\u2211 i \u2208 s, w i * z i) ^ p \u2260 \u22a4` and `\u2211 i \u2208 s, (w i * z i ^ p) \u2260 \u22a4`,\n    -- and prove `((\u2211 i \u2208 s, w i * z i) ^ p).toNNReal \u2264 (\u2211 i \u2208 s, (w i * z i ^ p)).toNNReal`,\n    -- by using `NNReal.rpow_arith_mean_le_arith_mean_rpow`.\n    intro h_top_rpow_sum _\n    -- show hypotheses needed to put the `.toNNReal` inside the sums.\n    have h_top : \u2200 a : \u03b9, a \u2208 s \u2192 w a * z a \u2260 \u22a4 :=\n      haveI h_top_sum : \u2211 i \u2208 s, w i * z i \u2260 \u22a4 := by\n        intro h\n        rw [h] at h_top_rpow_sum\n        rw [top_rpow_of_pos hp_pos] at h_top_rpow_sum\n        exact h_top_rpow_sum rfl\n      fun a ha => (lt_top_of_sum_ne_top h_top_sum ha).ne\n    have h_top_rpow : \u2200 a : \u03b9, a \u2208 s \u2192 w a * z a ^ p \u2260 \u22a4 := by\n      intro i hi\n      specialize h_top i hi\n      rwa [Ne, \u2190 h_top_iff_rpow_top i hi]\n    -- put the `.toNNReal` inside the sums.\n    simp_rw [toNNReal_sum h_top_rpow, toNNReal_rpow, toNNReal_sum h_top, toNNReal_mul,\n      toNNReal_rpow]\n    -- use corresponding nnreal result\n    refine\n      NNReal.rpow_arith_mean_le_arith_mean_rpow s (fun i => (w i).toNNReal)\n        (fun i => (z i).toNNReal) ?_ hp\n    -- verify the hypothesis `\u2211 i \u2208 s, (w i).toNNReal = 1`, using `\u2211 i \u2208 s, w i = 1` .\n    have h_sum_nnreal : \u2211 i \u2208 s, w i = \u2191(\u2211 i \u2208 s, (w i).toNNReal) := by\n      rw [coe_finset_sum]\n      refine sum_congr rfl fun i hi => (coe_toNNReal ?_).symm\n      refine (lt_top_of_sum_ne_top ?_ hi).ne\n      exact hw'.symm \u25b8 ENNReal.one_ne_top\n    rwa [\u2190 coe_inj, \u2190 h_sum_nnreal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalitiesPow.lean", "context": {"open": ["Finset NNReal ENNReal"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\ns : Finset \u03b9\nw z : \u03b9 \u2192 ENNReal\nhw' : \u2211 i \u2208 s, w i = 1\np : \u211d\nhp : 1 \u2264 p\n\u22a2 (\u2211 i \u2208 s, w i * z i) ^ p \u2264 \u2211 i \u2208 s, w i * z i ^ p"}, {"line": "have hp_pos : 0 < p := sorry", "tactic_state": "\u03b9 : Type u\ns : Finset \u03b9\nw z : \u03b9 \u2192 ENNReal\nhw' : \u2211 i \u2208 s, w i = 1\np : \u211d\nhp : 1 \u2264 p\nhp_pos : 0 < p\n\u22a2 (\u2211 i \u2208 s, w i * z i) ^ p \u2264 \u2211 i \u2208 s, w i * z i ^ p"}, {"line": "have hp_nonneg : 0 \u2264 p := sorry", "tactic_state": "\u03b9 : Type u\ns : Finset \u03b9\nw z : \u03b9 \u2192 ENNReal\nhw' : \u2211 i \u2208 s, w i = 1\np : \u211d\nhp : 1 \u2264 p\nhp_pos : 0 < p\nhp_nonneg : 0 \u2264 p\n\u22a2 (\u2211 i \u2208 s, w i * z i) ^ p \u2264 \u2211 i \u2208 s, w i * z i ^ p"}, {"line": "have hp_not_neg : \u00acp < 0 := sorry", "tactic_state": "\u03b9 : Type u\ns : Finset \u03b9\nw z : \u03b9 \u2192 ENNReal\nhw' : \u2211 i \u2208 s, w i = 1\np : \u211d\nhp : 1 \u2264 p\nhp_pos : 0 < p\nhp_nonneg : 0 \u2264 p\nhp_not_neg : \u00acp < 0\n\u22a2 (\u2211 i \u2208 s, w i * z i) ^ p \u2264 \u2211 i \u2208 s, w i * z i ^ p"}, {"line": "have h_top_iff_rpow_top : \u2200 (i : \u03b9), i \u2208 s \u2192 (w i * z i = \u22a4 \u2194 w i * z i ^ p = \u22a4) := by\n    simp [ENNReal.mul_eq_top, hp_pos, hp_nonneg, hp_not_neg]", "tactic_state": "\u03b9 : Type u\ns : Finset \u03b9\nw z : \u03b9 \u2192 ENNReal\nhw' : \u2211 i \u2208 s, w i = 1\np : \u211d\nhp : 1 \u2264 p\nhp_pos : 0 < p\nhp_nonneg : 0 \u2264 p\nhp_not_neg : \u00acp < 0\nh_top_iff_rpow_top : \u2200 i \u2208 s, w i * z i = \u22a4 \u2194 w i * z i ^ p = \u22a4\n\u22a2 (\u2211 i \u2208 s, w i * z i) ^ p \u2264 \u2211 i \u2208 s, w i * z i ^ p"}, {"line": "refine le_of_top_imp_top_of_toNNReal_le ?_ ?_", "tactic_state": "case refine_1\n\u03b9 : Type u\ns : Finset \u03b9\nw z : \u03b9 \u2192 ENNReal\nhw' : \u2211 i \u2208 s, w i = 1\np : \u211d\nhp : 1 \u2264 p\nhp_pos : 0 < p\nhp_nonneg : 0 \u2264 p\nhp_not_neg : \u00acp < 0\nh_top_iff_rpow_top : \u2200 i \u2208 s, w i * z i = \u22a4 \u2194 w i * z i ^ p = \u22a4\n\u22a2 (\u2211 i \u2208 s, w i * z i) ^ p = \u22a4 \u2192 \u2211 i \u2208 s, w i * z i ^ p = \u22a4\n---\ncase refine_2\n\u03b9 : Type u\ns : Finset \u03b9\nw z : \u03b9 \u2192 ENNReal\nhw' : \u2211 i \u2208 s, w i = 1\np : \u211d\nhp : 1 \u2264 p\nhp_pos : 0 < p\nhp_nonneg : 0 \u2264 p\nhp_not_neg : \u00acp < 0\nh_top_iff_rpow_top : \u2200 i \u2208 s, w i * z i = \u22a4 \u2194 w i * z i ^ p = \u22a4\n\u22a2 (\u2211 i \u2208 s, w i * z i) ^ p \u2260 \u22a4 \u2192\n    \u2211 i \u2208 s, w i * z i ^ p \u2260 \u22a4 \u2192 ((\u2211 i \u2208 s, w i * z i) ^ p).toNNReal \u2264 (\u2211 i \u2208 s, w i * z i ^ p).toNNReal"}, {"line": "\u00b7 -- first, prove `(\u2211 i \u2208 s, w i * z i) ^ p = \u22a4 \u2192 \u2211 i \u2208 s, (w i * z i ^ p) = \u22a4`\n    rw [rpow_eq_top_iff]\n    rw [sum_eq_top]\n    rw [sum_eq_top]\n    intro h\n    simp only [and_false] at h\n    simp only [hp_not_neg] at h\n    simp only [false_or] at h\n    rcases h.left with \u27e8a, H, ha\u27e9\n    use a, H\n    rwa [\u2190 h_top_iff_rpow_top a H]", "tactic_state": "case refine_2\n\u03b9 : Type u\ns : Finset \u03b9\nw z : \u03b9 \u2192 ENNReal\nhw' : \u2211 i \u2208 s, w i = 1\np : \u211d\nhp : 1 \u2264 p\nhp_pos : 0 < p\nhp_nonneg : 0 \u2264 p\nhp_not_neg : \u00acp < 0\nh_top_iff_rpow_top : \u2200 i \u2208 s, w i * z i = \u22a4 \u2194 w i * z i ^ p = \u22a4\n\u22a2 (\u2211 i \u2208 s, w i * z i) ^ p \u2260 \u22a4 \u2192\n    \u2211 i \u2208 s, w i * z i ^ p \u2260 \u22a4 \u2192 ((\u2211 i \u2208 s, w i * z i) ^ p).toNNReal \u2264 (\u2211 i \u2208 s, w i * z i ^ p).toNNReal"}, {"line": "\u00b7 -- second, suppose both `(\u2211 i \u2208 s, w i * z i) ^ p \u2260 \u22a4` and `\u2211 i \u2208 s, (w i * z i ^ p) \u2260 \u22a4`,\n    intro h_top_rpow_sum _\n    have h_top : \u2200 a : \u03b9, a \u2208 s \u2192 w a * z a \u2260 \u22a4 :=\n      haveI h_top_sum : \u2211 i \u2208 s, w i * z i \u2260 \u22a4 := by\n        intro h\n        rw [h] at h_top_rpow_sum\n        rw [top_rpow_of_pos hp_pos] at h_top_rpow_sum\n        exact h_top_rpow_sum rfl\n      fun a ha => (lt_top_of_sum_ne_top h_top_sum ha).ne\n    have h_top_rpow : \u2200 a : \u03b9, a \u2208 s \u2192 w a * z a ^ p \u2260 \u22a4 := by\n      intro i hi\n      specialize h_top i hi\n      rwa [Ne, \u2190 h_top_iff_rpow_top i hi]\n    simp_rw [toNNReal_sum h_top_rpow, toNNReal_rpow, toNNReal_sum h_top, toNNReal_mul,\n      toNNReal_rpow]\n    refine\n      NNReal.rpow_arith_mean_le_arith_mean_rpow s (fun i => (w i).toNNReal)\n        (fun i => (z i).toNNReal) ?_ hp\n    have h_sum_nnreal : \u2211 i \u2208 s, w i = \u2191(\u2211 i \u2208 s, (w i).toNNReal) := by\n      rw [coe_finset_sum]\n      refine sum_congr rfl fun i hi => (coe_toNNReal ?_).symm\n      refine (lt_top_of_sum_ne_top ?_ hi).ne\n      exact hw'.symm \u25b8 ENNReal.one_ne_top\n    rwa [\u2190 coe_inj, \u2190 h_sum_nnreal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_arith_mean_le_arith_mean2_rpow (w\u2081 w\u2082 z\u2081 z\u2082 : \u211d\u22650\u221e) (hw' : w\u2081 + w\u2082 = 1) {p : \u211d}\n    (hp : 1 \u2264 p) : (w\u2081 * z\u2081 + w\u2082 * z\u2082) ^ p \u2264 w\u2081 * z\u2081 ^ p + w\u2082 * z\u2082 ^ p := by\n  have h := rpow_arith_mean_le_arith_mean_rpow univ ![w\u2081, w\u2082] ![z\u2081, z\u2082] ?_ hp\n  \u00b7 simpa [Fin.sum_univ_succ] using h\n  \u00b7 simp [hw', Fin.sum_univ_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalitiesPow.lean", "context": {"open": ["Finset NNReal ENNReal"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "w\u2081 w\u2082 z\u2081 z\u2082 : ENNReal\nhw' : w\u2081 + w\u2082 = 1\np : \u211d\nhp : 1 \u2264 p\n\u22a2 (w\u2081 * z\u2081 + w\u2082 * z\u2082) ^ p \u2264 w\u2081 * z\u2081 ^ p + w\u2082 * z\u2082 ^ p"}, {"line": "have h := rpow_arith_mean_le_arith_mean_rpow univ ![w\u2081, w\u2082] ![z\u2081, z\u2082] ?_ hp", "tactic_state": "case refine_2\nw\u2081 w\u2082 z\u2081 z\u2082 : ENNReal\nhw' : w\u2081 + w\u2082 = 1\np : \u211d\nhp : 1 \u2264 p\nh : (\u2211 i, ![w\u2081, w\u2082] i * ![z\u2081, z\u2082] i) ^ p \u2264 \u2211 i, ![w\u2081, w\u2082] i * ![z\u2081, z\u2082] i ^ p\n\u22a2 (w\u2081 * z\u2081 + w\u2082 * z\u2082) ^ p \u2264 w\u2081 * z\u2081 ^ p + w\u2082 * z\u2082 ^ p\n---\ncase refine_1\nw\u2081 w\u2082 z\u2081 z\u2082 : ENNReal\nhw' : w\u2081 + w\u2082 = 1\np : \u211d\nhp : 1 \u2264 p\n\u22a2 \u2211 i, ![w\u2081, w\u2082] i = 1"}, {"line": "\u00b7 simpa [Fin.sum_univ_succ] using h", "tactic_state": "case refine_1\nw\u2081 w\u2082 z\u2081 z\u2082 : ENNReal\nhw' : w\u2081 + w\u2082 = 1\np : \u211d\nhp : 1 \u2264 p\n\u22a2 \u2211 i, ![w\u2081, w\u2082] i = 1"}, {"line": "\u00b7 simp [hw', Fin.sum_univ_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_add_le_add_rpow {p : \u211d} (a b : \u211d\u22650\u221e) (hp : 0 \u2264 p) (hp1 : p \u2264 1) :\n    (a + b) ^ p \u2264 a ^ p + b ^ p := by\n  rcases hp.eq_or_lt with (rfl | hp_pos)\n  \u00b7 simp\n  have h := rpow_add_rpow_le a b hp_pos hp1\n  rw [one_div_one] at h\n  rw [one_div] at h\n  repeat' rw [ENNReal.rpow_one] at h\n  exact (ENNReal.le_rpow_inv_iff hp_pos).mp h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalitiesPow.lean", "context": {"open": ["Finset NNReal ENNReal"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\na b : ENNReal\nhp : 0 \u2264 p\nhp1 : p \u2264 1\n\u22a2 (a + b) ^ p \u2264 a ^ p + b ^ p"}, {"line": "rcases hp.eq_or_lt with (rfl | hp_pos)", "tactic_state": "case inl\na b : ENNReal\nhp : 0 \u2264 0\nhp1 : 0 \u2264 1\n\u22a2 (a + b) ^ 0 \u2264 a ^ 0 + b ^ 0\n---\ncase inr\np : \u211d\na b : ENNReal\nhp : 0 \u2264 p\nhp1 : p \u2264 1\nhp_pos : 0 < p\n\u22a2 (a + b) ^ p \u2264 a ^ p + b ^ p"}, {"line": "\u00b7 simp", "tactic_state": "case inr\np : \u211d\na b : ENNReal\nhp : 0 \u2264 p\nhp1 : p \u2264 1\nhp_pos : 0 < p\n\u22a2 (a + b) ^ p \u2264 a ^ p + b ^ p"}, {"line": "have h := rpow_add_rpow_le a b hp_pos hp1", "tactic_state": "case inr\np : \u211d\na b : ENNReal\nhp : 0 \u2264 p\nhp1 : p \u2264 1\nhp_pos : 0 < p\nh : (a ^ 1 + b ^ 1) ^ (1 / 1) \u2264 (a ^ p + b ^ p) ^ (1 / p)\n\u22a2 (a + b) ^ p \u2264 a ^ p + b ^ p"}, {"line": "rw [one_div_one] at h", "tactic_state": "case inr\np : \u211d\na b : ENNReal\nhp : 0 \u2264 p\nhp1 : p \u2264 1\nhp_pos : 0 < p\nh : (a ^ 1 + b ^ 1) ^ 1 \u2264 (a ^ p + b ^ p) ^ (1 / p)\n\u22a2 (a + b) ^ p \u2264 a ^ p + b ^ p"}, {"line": "rw [one_div] at h", "tactic_state": "case inr\np : \u211d\na b : ENNReal\nhp : 0 \u2264 p\nhp1 : p \u2264 1\nhp_pos : 0 < p\nh : (a ^ 1 + b ^ 1) ^ 1 \u2264 (a ^ p + b ^ p) ^ p\u207b\u00b9\n\u22a2 (a + b) ^ p \u2264 a ^ p + b ^ p"}, {"line": "repeat' rw [ENNReal.rpow_one] at h", "tactic_state": "case inr\np : \u211d\na b : ENNReal\nhp : 0 \u2264 p\nhp1 : p \u2264 1\nhp_pos : 0 < p\nh : a + b \u2264 (a ^ p + b ^ p) ^ p\u207b\u00b9\n\u22a2 (a + b) ^ p \u2264 a ^ p + b ^ p"}, {"line": "exact (ENNReal.le_rpow_inv_iff hp_pos).mp h", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem rexp_neg_image_aux : rexp \u2218 Neg.neg '' univ = Ioi 0 := by\n  rw [Set.image_comp]\n  rw [Set.image_univ_of_surjective neg_surjective]\n  rw [Set.image_univ]\n  rw [Real.range_exp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MellinInversion.lean", "context": {"open": ["Real Complex Set MeasureTheory", "scoped FourierTransform"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Real.exp \u2218 Neg.neg '' univ = Ioi 0"}, {"line": "rw [Set.image_comp]", "tactic_state": "\u22a2 Real.exp '' (Neg.neg '' univ) = Ioi 0"}, {"line": "rw [Set.image_univ_of_surjective neg_surjective]", "tactic_state": "\u22a2 Real.exp '' univ = Ioi 0"}, {"line": "rw [Set.image_univ]", "tactic_state": "\u22a2 range Real.exp = Ioi 0"}, {"line": "rw [Real.range_exp]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Complex.summable_one_div_nat_cpow {p : \u2102} :\n    Summable (fun n : \u2115 \u21a6 1 / (n : \u2102) ^ p) \u2194 1 < re p := by\n  rw [\u2190 Real.summable_one_div_nat_rpow]\n  rw [\u2190 summable_nat_add_iff 1 (G := \u211d)]\n  rw [\u2190 summable_nat_add_iff 1 (G := \u2102)]\n  rw [\u2190 summable_norm_iff]\n  simp only [norm_div]\n  simp only [norm_one]\n  simp only [\u2190 ofReal_natCast]\n  simp only [norm_cpow_eq_rpow_re_of_pos     (Nat.cast_pos.mpr <| Nat.succ_pos _)]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/PSeriesComplex.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2102\n\u22a2 (Summable fun n => 1 / \u2191n ^ p) \u2194 1 < p.re"}, {"line": "rw [\u2190 Real.summable_one_div_nat_rpow]", "tactic_state": "p : \u2102\n\u22a2 (Summable fun n => 1 / \u2191n ^ p) \u2194 Summable fun n => 1 / \u2191n ^ p.re"}, {"line": "rw [\u2190 summable_nat_add_iff 1 (G := \u211d)]", "tactic_state": "p : \u2102\n\u22a2 (Summable fun n => 1 / \u2191n ^ p) \u2194 Summable fun n => 1 / \u2191(n + 1) ^ p.re"}, {"line": "rw [\u2190 summable_nat_add_iff 1 (G := \u2102)]", "tactic_state": "p : \u2102\n\u22a2 (Summable fun n => 1 / \u2191(n + 1) ^ p) \u2194 Summable fun n => 1 / \u2191(n + 1) ^ p.re"}, {"line": "rw [\u2190 summable_norm_iff]", "tactic_state": "p : \u2102\n\u22a2 (Summable fun x => \u20161 / \u2191(x + 1) ^ p\u2016) \u2194 Summable fun n => 1 / \u2191(n + 1) ^ p.re"}, {"line": "simp only [norm_div]", "tactic_state": "p : \u2102\n\u22a2 (Summable fun x => \u20161\u2016 / \u2016\u2191(x + 1) ^ p\u2016) \u2194 Summable fun n => 1 / \u2191(n + 1) ^ p.re"}, {"line": "simp only [norm_one]", "tactic_state": "p : \u2102\n\u22a2 (Summable fun x => 1 / \u2016\u2191(x + 1) ^ p\u2016) \u2194 Summable fun n => 1 / \u2191(n + 1) ^ p.re"}, {"line": "simp only [\u2190 ofReal_natCast]", "tactic_state": "p : \u2102\n\u22a2 (Summable fun x => 1 / \u2016\u2191\u2191(x + 1) ^ p\u2016) \u2194 Summable fun n => 1 / \u2191(n + 1) ^ p.re"}, {"line": "simp only [norm_cpow_eq_rpow_re_of_pos     (Nat.cast_pos.mpr <| Nat.succ_pos _)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_normSq : Continuous (normSq : \u210d \u2192 \u211d) := by\n  simpa [\u2190 normSq_eq_norm_mul_self] using\n    (continuous_norm.mul continuous_norm : Continuous fun q : \u210d => \u2016q\u2016 * \u2016q\u2016)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Quaternion.lean", "context": {"open": ["scoped RealInnerProductSpace"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u210d : Type u_1\nnormSq : \u210d \u2192 \u211d\n\u22a2 sorry"}, {"line": "simpa [\u2190 normSq_eq_norm_mul_self] using\n    (continuous_norm.mul continuous_norm : Continuous fun q : \u210d => \u2016q\u2016 * \u2016q\u2016)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tsum_coe (f : \u03b1 \u2192 \u211d) : (\u2211' a, (f a : \u210d)) = \u2191(\u2211' a, f a) := by\n  by_cases hf : Summable f\n  \u00b7 exact (hasSum_coe.mpr hf.hasSum).tsum_eq\n  \u00b7 simp [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable (summable_coe.not.mpr hf)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Quaternion.lean", "context": {"open": ["scoped RealInnerProductSpace"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u210d : Sort u_2\nf : \u03b1 \u2192 \u211d\n\u22a2 \u2211' (a : \u03b1), sorry = \u2211' (a : \u03b1), f a"}, {"line": "by_cases hf : Summable f", "tactic_state": "case pos\n\u03b1 : Type u_1\n\u210d : Sort u_2\nf : \u03b1 \u2192 \u211d\nhf : Summable f\n\u22a2 \u2211' (a : \u03b1), sorry = \u2211' (a : \u03b1), f a\n---\ncase neg\n\u03b1 : Type u_1\n\u210d : Sort u_2\nf : \u03b1 \u2192 \u211d\nhf : \u00acSummable f\n\u22a2 \u2211' (a : \u03b1), sorry = \u2211' (a : \u03b1), f a"}, {"line": "\u00b7 exact (hasSum_coe.mpr hf.hasSum).tsum_eq", "tactic_state": "case neg\n\u03b1 : Type u_1\n\u210d : Sort u_2\nf : \u03b1 \u2192 \u211d\nhf : \u00acSummable f\n\u22a2 \u2211' (a : \u03b1), sorry = \u2211' (a : \u03b1), f a"}, {"line": "\u00b7 simp [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable (summable_coe.not.mpr hf)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Finset.sum_indicator_mod {R : Type*} [AddCommMonoid R] (m : \u2115) [NeZero m] (f : \u2115 \u2192 R) :\n    f = \u2211 a : ZMod m, {n : \u2115 | (n : ZMod m) = a}.indicator f := by\n  ext n\n  simp only [Finset.sum_apply]\n  simp only [Set.indicator_apply]\n  simp only [Set.mem_setOf_eq]\n  simp only [Finset.sum_ite_eq]\n  simp only [Finset.mem_univ]\n  simp only [\u2193reduceIte]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SumOverResidueClass.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : AddCommMonoid R\nm : \u2115\ninst\u271d : NeZero m\nf : \u2115 \u2192 R\n\u22a2 f = \u2211 a, {n | \u2191n = a}.indicator f"}, {"line": "ext n", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u00b9 : AddCommMonoid R\nm : \u2115\ninst\u271d : NeZero m\nf : \u2115 \u2192 R\nn : \u2115\n\u22a2 f n = (\u2211 a, {n | \u2191n = a}.indicator f) n"}, {"line": "simp only [Finset.sum_apply]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u00b9 : AddCommMonoid R\nm : \u2115\ninst\u271d : NeZero m\nf : \u2115 \u2192 R\nn : \u2115\n\u22a2 f n = \u2211 c, {n | \u2191n = c}.indicator f n"}, {"line": "simp only [Set.indicator_apply]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u00b9 : AddCommMonoid R\nm : \u2115\ninst\u271d : NeZero m\nf : \u2115 \u2192 R\nn : \u2115\n\u22a2 f n = \u2211 x, if n \u2208 {n | \u2191n = x} then f n else 0"}, {"line": "simp only [Set.mem_setOf_eq]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u00b9 : AddCommMonoid R\nm : \u2115\ninst\u271d : NeZero m\nf : \u2115 \u2192 R\nn : \u2115\n\u22a2 f n = \u2211 x, if \u2191n = x then f n else 0"}, {"line": "simp only [Finset.sum_ite_eq]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u00b9 : AddCommMonoid R\nm : \u2115\ninst\u271d : NeZero m\nf : \u2115 \u2192 R\nn : \u2115\n\u22a2 f n = if \u2191n \u2208 univ then f n else 0"}, {"line": "simp only [Finset.mem_univ]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u00b9 : AddCommMonoid R\nm : \u2115\ninst\u271d : NeZero m\nf : \u2115 \u2192 R\nn : \u2115\n\u22a2 f n = if True then f n else 0"}, {"line": "simp only [\u2193reduceIte]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frobenius_nnnorm_one [DecidableEq n] [SeminormedAddCommGroup \u03b1] [One \u03b1] :\n    \u2016(1 : Matrix n n \u03b1)\u2016\u208a = .sqrt (Fintype.card n) * \u2016(1 : \u03b1)\u2016\u208a := by\n  calc\n    \u2016(diagonal 1 : Matrix n n \u03b1)\u2016\u208a\n    _ = \u2016(WithLp.equiv 2 (n \u2192 \u03b1)).symm (Function.const _ 1)\u2016\u208a := frobenius_nnnorm_diagonal _\n    _ = .sqrt (Fintype.card n) * \u2016(1 : \u03b1)\u2016\u208a := by\n      rw [PiLp.nnnorm_equiv_symm_const (ENNReal.ofNat_ne_top (n := 2))]\n      simp [NNReal.sqrt_eq_rpow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Matrix.lean", "context": {"open": ["scoped NNReal Matrix", "scoped Matrix"], "variables": ["{R l m n \u03b1 \u03b2 \u03b9 : Type*} [Fintype l] [Fintype m] [Fintype n] [Unique \u03b9]", "[SeminormedAddCommGroup \u03b1] [SeminormedAddCommGroup \u03b2]", "[NormedField R] [SeminormedAddCommGroup \u03b1] [NormedSpace R \u03b1]", "[SeminormedAddCommGroup \u03b1]", "[NonUnitalSeminormedRing \u03b1]", "[NormedDivisionRing \u03b1] [NormedAlgebra \u211d \u03b1]", "[NontriviallyNormedField \u03b1] [NormedAlgebra \u211d \u03b1]", "[DecidableEq n]", "[SeminormedAddCommGroup \u03b1] [SeminormedAddCommGroup \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b9\u00b3 : Fintype n\ninst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 : SeminormedAddCommGroup \u03b1\ninst\u271d\u2079 : NonUnitalSeminormedRing \u03b1\ninst\u271d\u2078 : NormedDivisionRing \u03b1\ninst\u271d\u2077 : NormedAlgebra \u211d \u03b1\ninst\u271d\u2076 : NontriviallyNormedField \u03b1\ninst\u271d\u2075 : NormedAlgebra \u211d \u03b1\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : SeminormedAddCommGroup \u03b1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : SeminormedAddCommGroup \u03b1\ninst\u271d : One \u03b1\n\u22a2 sorry = NNReal.sqrt \u2191(Fintype.card n) * \u20161\u2016\u208a"}, {"line": "calc\n    \u2016(diagonal 1 : Matrix n n \u03b1)\u2016\u208a\n    _ = \u2016(WithLp.equiv 2 (n \u2192 \u03b1)).symm (Function.const _ 1)\u2016\u208a := frobenius_nnnorm_diagonal _\n    _ = .sqrt (Fintype.card n) * \u2016(1 : \u03b1)\u2016\u208a := by\n      rw [PiLp.nnnorm_equiv_symm_const (ENNReal.ofNat_ne_top (n := 2))]\n      simp [NNReal.sqrt_eq_rpow]", "tactic_state": "case calc.step\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b9\u00b3 : Fintype n\ninst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 : SeminormedAddCommGroup \u03b1\ninst\u271d\u2079 : NonUnitalSeminormedRing \u03b1\ninst\u271d\u2078 : NormedDivisionRing \u03b1\ninst\u271d\u2077 : NormedAlgebra \u211d \u03b1\ninst\u271d\u2076 : NontriviallyNormedField \u03b1\ninst\u271d\u2075 : NormedAlgebra \u211d \u03b1\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : SeminormedAddCommGroup \u03b1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : SeminormedAddCommGroup \u03b1\ninst\u271d : One \u03b1\n\u22a2 NNReal.sqrt sorry * sorry = NNReal.sqrt \u2191(Fintype.card n) * \u20161\u2016\u208a"}]}
{"declaration": "theorem geom_mean_le_arith_mean2_weighted (w\u2081 w\u2082 p\u2081 p\u2082 : \u211d\u22650) :\n    w\u2081 + w\u2082 = 1 \u2192 p\u2081 ^ (w\u2081 : \u211d) * p\u2082 ^ (w\u2082 : \u211d) \u2264 w\u2081 * p\u2081 + w\u2082 * p\u2082 := by\n  simpa only [Fin.prod_univ_succ,Fin.sum_univ_succ,Finset.prod_empty,Finset.sum_empty,Finset.univ_eq_empty,Fin.cons_succ,Fin.cons_zero,add_zero,mul_one] using\n    geom_mean_le_arith_mean_weighted univ ![w\u2081, w\u2082] ![p\u2081, p\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalities.lean", "context": {"open": ["Finset NNReal ENNReal", "scoped BigOperators"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "w\u2081 w\u2082 p\u2081 p\u2082 : NNReal\n\u22a2 w\u2081 + w\u2082 = 1 \u2192 p\u2081 ^ \u2191w\u2081 * p\u2082 ^ \u2191w\u2082 \u2264 w\u2081 * p\u2081 + w\u2082 * p\u2082"}, {"line": "simpa only [Fin.prod_univ_succ,Fin.sum_univ_succ,Finset.prod_empty,Finset.sum_empty,Finset.univ_eq_empty,Fin.cons_succ,Fin.cons_zero,add_zero,mul_one] using\n    geom_mean_le_arith_mean_weighted univ ![w\u2081, w\u2082] ![p\u2081, p\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem geom_mean_le_arith_mean3_weighted (w\u2081 w\u2082 w\u2083 p\u2081 p\u2082 p\u2083 : \u211d\u22650) :\n    w\u2081 + w\u2082 + w\u2083 = 1 \u2192\n      p\u2081 ^ (w\u2081 : \u211d) * p\u2082 ^ (w\u2082 : \u211d) * p\u2083 ^ (w\u2083 : \u211d) \u2264 w\u2081 * p\u2081 + w\u2082 * p\u2082 + w\u2083 * p\u2083 := by\n  simpa only [Fin.prod_univ_succ,Fin.sum_univ_succ,Finset.prod_empty,Finset.sum_empty,Finset.univ_eq_empty,Fin.cons_succ,Fin.cons_zero,add_zero,mul_one,\u2190 add_assoc,mul_assoc] using geom_mean_le_arith_mean_weighted univ ![w\u2081, w\u2082, w\u2083] ![p\u2081, p\u2082, p\u2083]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalities.lean", "context": {"open": ["Finset NNReal ENNReal", "scoped BigOperators"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "w\u2081 w\u2082 w\u2083 p\u2081 p\u2082 p\u2083 : NNReal\n\u22a2 w\u2081 + w\u2082 + w\u2083 = 1 \u2192 p\u2081 ^ \u2191w\u2081 * p\u2082 ^ \u2191w\u2082 * p\u2083 ^ \u2191w\u2083 \u2264 w\u2081 * p\u2081 + w\u2082 * p\u2082 + w\u2083 * p\u2083"}, {"line": "simpa only [Fin.prod_univ_succ,Fin.sum_univ_succ,Finset.prod_empty,Finset.sum_empty,Finset.univ_eq_empty,Fin.cons_succ,Fin.cons_zero,add_zero,mul_one,\u2190 add_assoc,mul_assoc] using geom_mean_le_arith_mean_weighted univ ![w\u2081, w\u2082, w\u2083] ![p\u2081, p\u2082, p\u2083]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem geom_mean_le_arith_mean4_weighted (w\u2081 w\u2082 w\u2083 w\u2084 p\u2081 p\u2082 p\u2083 p\u2084 : \u211d\u22650) :\n    w\u2081 + w\u2082 + w\u2083 + w\u2084 = 1 \u2192\n      p\u2081 ^ (w\u2081 : \u211d) * p\u2082 ^ (w\u2082 : \u211d) * p\u2083 ^ (w\u2083 : \u211d) * p\u2084 ^ (w\u2084 : \u211d) \u2264\n        w\u2081 * p\u2081 + w\u2082 * p\u2082 + w\u2083 * p\u2083 + w\u2084 * p\u2084 := by\n  simpa only [Fin.prod_univ_succ,Fin.sum_univ_succ,Finset.prod_empty,Finset.sum_empty,Finset.univ_eq_empty,Fin.cons_succ,Fin.cons_zero,add_zero,mul_one,\u2190 add_assoc,mul_assoc] using geom_mean_le_arith_mean_weighted univ ![w\u2081, w\u2082, w\u2083, w\u2084] ![p\u2081, p\u2082, p\u2083, p\u2084]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalities.lean", "context": {"open": ["Finset NNReal ENNReal", "scoped BigOperators"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "w\u2081 w\u2082 w\u2083 w\u2084 p\u2081 p\u2082 p\u2083 p\u2084 : NNReal\n\u22a2 w\u2081 + w\u2082 + w\u2083 + w\u2084 = 1 \u2192 p\u2081 ^ \u2191w\u2081 * p\u2082 ^ \u2191w\u2082 * p\u2083 ^ \u2191w\u2083 * p\u2084 ^ \u2191w\u2084 \u2264 w\u2081 * p\u2081 + w\u2082 * p\u2082 + w\u2083 * p\u2083 + w\u2084 * p\u2084"}, {"line": "simpa only [Fin.prod_univ_succ,Fin.sum_univ_succ,Finset.prod_empty,Finset.sum_empty,Finset.univ_eq_empty,Fin.cons_succ,Fin.cons_zero,add_zero,mul_one,\u2190 add_assoc,mul_assoc] using geom_mean_le_arith_mean_weighted univ ![w\u2081, w\u2082, w\u2083, w\u2084] ![p\u2081, p\u2082, p\u2083, p\u2084]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem young_inequality_real (a b : \u211d\u22650) {p q : \u211d} (hpq : p.HolderConjugate q) :\n    a * b \u2264 a ^ p / Real.toNNReal p + b ^ q / Real.toNNReal q := by\n  simpa [Real.coe_toNNReal, hpq.nonneg, hpq.symm.nonneg] using young_inequality a b hpq.toNNReal\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalities.lean", "context": {"open": ["Finset NNReal ENNReal", "scoped BigOperators"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : NNReal\np q : \u211d\nhpq : p.HolderConjugate q\n\u22a2 a * b \u2264 a ^ p / p.toNNReal + b ^ q / q.toNNReal"}, {"line": "simpa [Real.coe_toNNReal, hpq.nonneg, hpq.symm.nonneg] using young_inequality a b hpq.toNNReal", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem inner_le_Lp_mul_Lp_of_norm_le_one (f g : \u03b9 \u2192 \u211d\u22650) {p q : \u211d}\n    (hpq : p.HolderConjugate q) (hf : \u2211 i \u2208 s, f i ^ p \u2264 1) (hg : \u2211 i \u2208 s, g i ^ q \u2264 1) :\n    \u2211 i \u2208 s, f i * g i \u2264 1 := by\n  have hp : 0 < p.toNNReal := zero_lt_one.trans hpq.toNNReal.lt\n  have hq : 0 < q.toNNReal := zero_lt_one.trans hpq.toNNReal.symm.lt\n  calc\n    \u2211 i \u2208 s, f i * g i \u2264 \u2211 i \u2208 s, (f i ^ p / Real.toNNReal p + g i ^ q / Real.toNNReal q) :=\n      Finset.sum_le_sum fun i _ => young_inequality_real (f i) (g i) hpq\n    _ = (\u2211 i \u2208 s, f i ^ p) / Real.toNNReal p + (\u2211 i \u2208 s, g i ^ q) / Real.toNNReal q := by\n      rw [sum_add_distrib]\n      rw [sum_div]\n      rw [sum_div]\n    _ \u2264 1 / Real.toNNReal p + 1 / Real.toNNReal q := by\n      refine add_le_add ?_ ?_ <;> rwa [div_le_iff\u2080, div_mul_cancel\u2080] <;> positivity\n    _ = 1 := by simp_rw [one_div, hpq.toNNReal.inv_add_inv_eq_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalities.lean", "context": {"open": ["Finset NNReal ENNReal", "scoped BigOperators"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 NNReal\np q : \u211d\nhpq : p.HolderConjugate q\nhf : \u2211 i \u2208 s, f i ^ p \u2264 1\nhg : \u2211 i \u2208 s, g i ^ q \u2264 1\n\u22a2 \u2211 i \u2208 s, f i * g i \u2264 1"}, {"line": "have hp : 0 < p.toNNReal := zero_lt_one.trans hpq.toNNReal.lt", "tactic_state": "\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 NNReal\np q : \u211d\nhpq : p.HolderConjugate q\nhf : \u2211 i \u2208 s, f i ^ p \u2264 1\nhg : \u2211 i \u2208 s, g i ^ q \u2264 1\nhp : 0 < p.toNNReal\n\u22a2 \u2211 i \u2208 s, f i * g i \u2264 1"}, {"line": "have hq : 0 < q.toNNReal := zero_lt_one.trans hpq.toNNReal.symm.lt", "tactic_state": "\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 NNReal\np q : \u211d\nhpq : p.HolderConjugate q\nhf : \u2211 i \u2208 s, f i ^ p \u2264 1\nhg : \u2211 i \u2208 s, g i ^ q \u2264 1\nhp : 0 < p.toNNReal\nhq : 0 < q.toNNReal\n\u22a2 \u2211 i \u2208 s, f i * g i \u2264 1"}, {"line": "calc\n    \u2211 i \u2208 s, f i * g i \u2264 \u2211 i \u2208 s, (f i ^ p / Real.toNNReal p + g i ^ q / Real.toNNReal q) :=\n      Finset.sum_le_sum fun i _ => young_inequality_real (f i) (g i) hpq\n    _ = (\u2211 i \u2208 s, f i ^ p) / Real.toNNReal p + (\u2211 i \u2208 s, g i ^ q) / Real.toNNReal q := by\n      rw [sum_add_distrib]\n      rw [sum_div]\n      rw [sum_div]\n    _ \u2264 1 / Real.toNNReal p + 1 / Real.toNNReal q := by\n      refine add_le_add ?_ ?_ <;> rwa [div_le_iff\u2080, div_mul_cancel\u2080] <;> positivity\n    _ = 1 := by simp_rw [one_div, hpq.toNNReal.inv_add_inv_eq_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inner_le_Lp_mul_Lq_tsum {f g : \u03b9 \u2192 \u211d\u22650} {p q : \u211d} (hpq : p.HolderConjugate q)\n    (hf : Summable fun i => f i ^ p) (hg : Summable fun i => g i ^ q) :\n    (Summable fun i => f i * g i) \u2227\n      \u2211' i, f i * g i \u2264 (\u2211' i, f i ^ p) ^ (1 / p) * (\u2211' i, g i ^ q) ^ (1 / q) := by\n  have H\u2081 : \u2200 s : Finset \u03b9,\n      \u2211 i \u2208 s, f i * g i \u2264 (\u2211' i, f i ^ p) ^ (1 / p) * (\u2211' i, g i ^ q) ^ (1 / q) := by\n    intro s\n    refine le_trans (inner_le_Lp_mul_Lq s f g hpq) (mul_le_mul ?_ ?_ bot_le bot_le)\n    \u00b7 rw [NNReal.rpow_le_rpow_iff (one_div_pos.mpr hpq.pos)]\n      exact hf.sum_le_tsum _ (fun _ _ => zero_le _)\n    \u00b7 rw [NNReal.rpow_le_rpow_iff (one_div_pos.mpr hpq.symm.pos)]\n      exact hg.sum_le_tsum _ (fun _ _ => zero_le _)\n  have bdd : BddAbove (Set.range fun s => \u2211 i \u2208 s, f i * g i) := by\n    refine \u27e8(\u2211' i, f i ^ p) ^ (1 / p) * (\u2211' i, g i ^ q) ^ (1 / q), ?_\u27e9\n    rintro a \u27e8s, rfl\u27e9\n    exact H\u2081 s\n  have H\u2082 : Summable _ := (hasSum_of_isLUB _ (isLUB_ciSup bdd)).summable\n  exact \u27e8H\u2082, H\u2082.tsum_le_of_sum_le H\u2081\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalities.lean", "context": {"open": ["Finset NNReal ENNReal", "scoped BigOperators"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\np q : \u211d\nhpq : p.HolderConjugate q\nhf : Summable fun i => f i ^ p\nhg : Summable fun i => g i ^ q\n\u22a2 (Summable fun i => f i * g i) \u2227\n    \u2211' (i : \u03b9), f i * g i \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) * (\u2211' (i : \u03b9), g i ^ q) ^ (1 / q)"}, {"line": "have H\u2081 : \u2200 s : Finset \u03b9,\n      \u2211 i \u2208 s, f i * g i \u2264 (\u2211' i, f i ^ p) ^ (1 / p) * (\u2211' i, g i ^ q) ^ (1 / q) := sorry", "tactic_state": "\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\np q : \u211d\nhpq : p.HolderConjugate q\nhf : Summable fun i => f i ^ p\nhg : Summable fun i => g i ^ q\nH\u2081 : \u2200 (s : Finset \u03b9), \u2211 i \u2208 s, f i * g i \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) * (\u2211' (i : \u03b9), g i ^ q) ^ (1 / q)\n\u22a2 (Summable fun i => f i * g i) \u2227\n    \u2211' (i : \u03b9), f i * g i \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) * (\u2211' (i : \u03b9), g i ^ q) ^ (1 / q)"}, {"line": "have bdd : BddAbove (Set.range fun s => \u2211 i \u2208 s, f i * g i) := by\n    refine \u27e8(\u2211' i, f i ^ p) ^ (1 / p) * (\u2211' i, g i ^ q) ^ (1 / q), ?_\u27e9\n    rintro a \u27e8s, rfl\u27e9\n    exact H\u2081 s", "tactic_state": "\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\np q : \u211d\nhpq : p.HolderConjugate q\nhf : Summable fun i => f i ^ p\nhg : Summable fun i => g i ^ q\nH\u2081 : \u2200 (s : Finset \u03b9), \u2211 i \u2208 s, f i * g i \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) * (\u2211' (i : \u03b9), g i ^ q) ^ (1 / q)\nbdd : BddAbove (Set.range fun s => \u2211 i \u2208 s, f i * g i)\n\u22a2 (Summable fun i => f i * g i) \u2227\n    \u2211' (i : \u03b9), f i * g i \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) * (\u2211' (i : \u03b9), g i ^ q) ^ (1 / q)"}, {"line": "have H\u2082 : Summable _ := (hasSum_of_isLUB _ (isLUB_ciSup bdd)).summable", "tactic_state": "\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\np q : \u211d\nhpq : p.HolderConjugate q\nhf : Summable fun i => f i ^ p\nhg : Summable fun i => g i ^ q\nH\u2081 : \u2200 (s : Finset \u03b9), \u2211 i \u2208 s, f i * g i \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) * (\u2211' (i : \u03b9), g i ^ q) ^ (1 / q)\nbdd : BddAbove (Set.range fun s => \u2211 i \u2208 s, f i * g i)\nH\u2082 : Summable fun i => f i * g i\n\u22a2 (Summable fun i => f i * g i) \u2227\n    \u2211' (i : \u03b9), f i * g i \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) * (\u2211' (i : \u03b9), g i ^ q) ^ (1 / q)"}, {"line": "exact \u27e8H\u2082, H\u2082.tsum_le_of_sum_le H\u2081\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inner_le_Lp_mul_Lq_hasSum {f g : \u03b9 \u2192 \u211d\u22650} {A B : \u211d\u22650} {p q : \u211d}\n    (hpq : p.HolderConjugate q) (hf : HasSum (fun i => f i ^ p) (A ^ p))\n    (hg : HasSum (fun i => g i ^ q) (B ^ q)) : \u2203 C, C \u2264 A * B \u2227 HasSum (fun i => f i * g i) C := by\n  obtain \u27e8H\u2081, H\u2082\u27e9 := inner_le_Lp_mul_Lq_tsum hpq hf.summable hg.summable\n  have hA : A = (\u2211' i : \u03b9, f i ^ p) ^ (1 / p) := by rw [hf.tsum_eq, rpow_inv_rpow_self hpq.ne_zero]\n  have hB : B = (\u2211' i : \u03b9, g i ^ q) ^ (1 / q) := by\n    rw [hg.tsum_eq]\n    rw [rpow_inv_rpow_self hpq.symm.ne_zero]\n  refine \u27e8\u2211' i, f i * g i, ?_, ?_\u27e9\n  \u00b7 simpa [hA, hB] using H\u2082\n  \u00b7 simpa only [rpow_self_rpow_inv hpq.ne_zero] using H\u2081.hasSum\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalities.lean", "context": {"open": ["Finset NNReal ENNReal", "scoped BigOperators"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\nA B : NNReal\np q : \u211d\nhpq : p.HolderConjugate q\nhf : HasSum (fun i => f i ^ p) (A ^ p)\nhg : HasSum (fun i => g i ^ q) (B ^ q)\n\u22a2 \u2203 C \u2264 A * B, HasSum (fun i => f i * g i) C"}, {"line": "obtain \u27e8H\u2081, H\u2082\u27e9 := inner_le_Lp_mul_Lq_tsum hpq hf.summable hg.summable", "tactic_state": "case intro\n\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\nA B : NNReal\np q : \u211d\nhpq : p.HolderConjugate q\nhf : HasSum (fun i => f i ^ p) (A ^ p)\nhg : HasSum (fun i => g i ^ q) (B ^ q)\nH\u2081 : Summable fun i => f i * g i\nH\u2082 : \u2211' (i : \u03b9), f i * g i \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) * (\u2211' (i : \u03b9), g i ^ q) ^ (1 / q)\n\u22a2 \u2203 C \u2264 A * B, HasSum (fun i => f i * g i) C"}, {"line": "have hA : A = (\u2211' i : \u03b9, f i ^ p) ^ (1 / p) := by rw [hf.tsum_eq, rpow_inv_rpow_self hpq.ne_zero]", "tactic_state": "case intro\n\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\nA B : NNReal\np q : \u211d\nhpq : p.HolderConjugate q\nhf : HasSum (fun i => f i ^ p) (A ^ p)\nhg : HasSum (fun i => g i ^ q) (B ^ q)\nH\u2081 : Summable fun i => f i * g i\nH\u2082 : \u2211' (i : \u03b9), f i * g i \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) * (\u2211' (i : \u03b9), g i ^ q) ^ (1 / q)\nhA : A = (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p)\n\u22a2 \u2203 C \u2264 A * B, HasSum (fun i => f i * g i) C"}, {"line": "have hB : B = (\u2211' i : \u03b9, g i ^ q) ^ (1 / q) := by\n    rw [hg.tsum_eq]\n    rw [rpow_inv_rpow_self hpq.symm.ne_zero]", "tactic_state": "case intro\n\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\nA B : NNReal\np q : \u211d\nhpq : p.HolderConjugate q\nhf : HasSum (fun i => f i ^ p) (A ^ p)\nhg : HasSum (fun i => g i ^ q) (B ^ q)\nH\u2081 : Summable fun i => f i * g i\nH\u2082 : \u2211' (i : \u03b9), f i * g i \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) * (\u2211' (i : \u03b9), g i ^ q) ^ (1 / q)\nhA : A = (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p)\nhB : B = (\u2211' (i : \u03b9), g i ^ q) ^ (1 / q)\n\u22a2 \u2203 C \u2264 A * B, HasSum (fun i => f i * g i) C"}, {"line": "refine \u27e8\u2211' i, f i * g i, ?_, ?_\u27e9", "tactic_state": "case intro.refine_1\n\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\nA B : NNReal\np q : \u211d\nhpq : p.HolderConjugate q\nhf : HasSum (fun i => f i ^ p) (A ^ p)\nhg : HasSum (fun i => g i ^ q) (B ^ q)\nH\u2081 : Summable fun i => f i * g i\nH\u2082 : \u2211' (i : \u03b9), f i * g i \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) * (\u2211' (i : \u03b9), g i ^ q) ^ (1 / q)\nhA : A = (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p)\nhB : B = (\u2211' (i : \u03b9), g i ^ q) ^ (1 / q)\n\u22a2 \u2211' (i : \u03b9), f i * g i \u2264 A * B\n---\ncase intro.refine_2\n\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\nA B : NNReal\np q : \u211d\nhpq : p.HolderConjugate q\nhf : HasSum (fun i => f i ^ p) (A ^ p)\nhg : HasSum (fun i => g i ^ q) (B ^ q)\nH\u2081 : Summable fun i => f i * g i\nH\u2082 : \u2211' (i : \u03b9), f i * g i \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) * (\u2211' (i : \u03b9), g i ^ q) ^ (1 / q)\nhA : A = (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p)\nhB : B = (\u2211' (i : \u03b9), g i ^ q) ^ (1 / q)\n\u22a2 HasSum (fun i => f i * g i) (\u2211' (i : \u03b9), f i * g i)"}, {"line": "\u00b7 simpa [hA, hB] using H\u2082", "tactic_state": "case intro.refine_2\n\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\nA B : NNReal\np q : \u211d\nhpq : p.HolderConjugate q\nhf : HasSum (fun i => f i ^ p) (A ^ p)\nhg : HasSum (fun i => g i ^ q) (B ^ q)\nH\u2081 : Summable fun i => f i * g i\nH\u2082 : \u2211' (i : \u03b9), f i * g i \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) * (\u2211' (i : \u03b9), g i ^ q) ^ (1 / q)\nhA : A = (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p)\nhB : B = (\u2211' (i : \u03b9), g i ^ q) ^ (1 / q)\n\u22a2 HasSum (fun i => f i * g i) (\u2211' (i : \u03b9), f i * g i)"}, {"line": "\u00b7 simpa only [rpow_self_rpow_inv hpq.ne_zero] using H\u2081.hasSum", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Lp_add_le (f g : \u03b9 \u2192 \u211d\u22650) {p : \u211d} (hp : 1 \u2264 p) :\n    (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264\n      (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p) := by\n  -- The result is trivial when `p = 1`, so we can assume `1 < p`.\n  rcases eq_or_lt_of_le hp with (rfl | hp)\n  \u00b7 simp [Finset.sum_add_distrib]\n  have hpq := Real.HolderConjugate.conjExponent hp\n  have := isGreatest_Lp s (f + g) hpq\n  simp only [Pi.add_apply] at this\n  simp only [add_mul] at this\n  simp only [sum_add_distrib] at this\n  rcases this.1 with \u27e8\u03c6, h\u03c6, H\u27e9\n  rw [\u2190 H]\n  exact\n    add_le_add ((isGreatest_Lp s f hpq).2 \u27e8\u03c6, h\u03c6, rfl\u27e9) ((isGreatest_Lp s g hpq).2 \u27e8\u03c6, h\u03c6, rfl\u27e9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalities.lean", "context": {"open": ["Finset NNReal ENNReal", "scoped BigOperators"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp : 1 \u2264 p\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)"}, {"line": "rcases eq_or_lt_of_le hp with (rfl | hp)", "tactic_state": "case inl\n\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 NNReal\nhp : 1 \u2264 1\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ 1) ^ (1 / 1) \u2264 (\u2211 i \u2208 s, f i ^ 1) ^ (1 / 1) + (\u2211 i \u2208 s, g i ^ 1) ^ (1 / 1)\n---\ncase inr\n\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)"}, {"line": "\u00b7 simp [Finset.sum_add_distrib]", "tactic_state": "case inr\n\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)"}, {"line": "have hpq := Real.HolderConjugate.conjExponent hp", "tactic_state": "case inr\n\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\nhpq : p.HolderConjugate p.conjExponent\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)"}, {"line": "have := isGreatest_Lp s (f + g) hpq", "tactic_state": "case inr\n\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\nhpq : p.HolderConjugate p.conjExponent\nthis :\n  IsGreatest ((fun g_1 => \u2211 i \u2208 s, (f + g) i * g_1 i) '' {g | \u2211 i \u2208 s, g i ^ p.conjExponent \u2264 1})\n    ((\u2211 i \u2208 s, (f + g) i ^ p) ^ (1 / p))\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)"}, {"line": "simp only [Pi.add_apply] at this", "tactic_state": "case inr\n\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\nhpq : p.HolderConjugate p.conjExponent\nthis :\n  IsGreatest ((fun a => \u2211 x \u2208 s, (f x + g x) * a x) '' {g | \u2211 i \u2208 s, g i ^ p.conjExponent \u2264 1})\n    ((\u2211 x \u2208 s, (f x + g x) ^ p) ^ (1 / p))\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)"}, {"line": "simp only [add_mul] at this", "tactic_state": "case inr\n\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\nhpq : p.HolderConjugate p.conjExponent\nthis :\n  IsGreatest ((fun a => \u2211 x \u2208 s, (f x * a x + g x * a x)) '' {g | \u2211 i \u2208 s, g i ^ p.conjExponent \u2264 1})\n    ((\u2211 x \u2208 s, (f x + g x) ^ p) ^ (1 / p))\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)"}, {"line": "simp only [sum_add_distrib] at this", "tactic_state": "case inr\n\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\nhpq : p.HolderConjugate p.conjExponent\nthis :\n  IsGreatest ((fun a => \u2211 x \u2208 s, f x * a x + \u2211 x \u2208 s, g x * a x) '' {g | \u2211 i \u2208 s, g i ^ p.conjExponent \u2264 1})\n    ((\u2211 x \u2208 s, (f x + g x) ^ p) ^ (1 / p))\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)"}, {"line": "rcases this.1 with \u27e8\u03c6, h\u03c6, H\u27e9", "tactic_state": "case inr.intro.intro\n\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\nhpq : p.HolderConjugate p.conjExponent\nthis :\n  IsGreatest ((fun a => \u2211 x \u2208 s, f x * a x + \u2211 x \u2208 s, g x * a x) '' {g | \u2211 i \u2208 s, g i ^ p.conjExponent \u2264 1})\n    ((\u2211 x \u2208 s, (f x + g x) ^ p) ^ (1 / p))\n\u03c6 : \u03b9 \u2192 NNReal\nh\u03c6 : \u03c6 \u2208 {g | \u2211 i \u2208 s, g i ^ p.conjExponent \u2264 1}\nH : (fun a => \u2211 x \u2208 s, f x * a x + \u2211 x \u2208 s, g x * a x) \u03c6 = (\u2211 x \u2208 s, (f x + g x) ^ p) ^ (1 / p)\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)"}, {"line": "rw [\u2190 H]", "tactic_state": "case inr.intro.intro\n\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\nhpq : p.HolderConjugate p.conjExponent\nthis :\n  IsGreatest ((fun a => \u2211 x \u2208 s, f x * a x + \u2211 x \u2208 s, g x * a x) '' {g | \u2211 i \u2208 s, g i ^ p.conjExponent \u2264 1})\n    ((\u2211 x \u2208 s, (f x + g x) ^ p) ^ (1 / p))\n\u03c6 : \u03b9 \u2192 NNReal\nh\u03c6 : \u03c6 \u2208 {g | \u2211 i \u2208 s, g i ^ p.conjExponent \u2264 1}\nH : (fun a => \u2211 x \u2208 s, f x * a x + \u2211 x \u2208 s, g x * a x) \u03c6 = (\u2211 x \u2208 s, (f x + g x) ^ p) ^ (1 / p)\n\u22a2 (fun a => \u2211 x \u2208 s, f x * a x + \u2211 x \u2208 s, g x * a x) \u03c6 \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)"}, {"line": "exact\n    add_le_add ((isGreatest_Lp s f hpq).2 \u27e8\u03c6, h\u03c6, rfl\u27e9) ((isGreatest_Lp s g hpq).2 \u27e8\u03c6, h\u03c6, rfl\u27e9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Lp_add_le_tsum {f g : \u03b9 \u2192 \u211d\u22650} {p : \u211d} (hp : 1 \u2264 p) (hf : Summable fun i => f i ^ p)\n    (hg : Summable fun i => g i ^ p) :\n    (Summable fun i => (f i + g i) ^ p) \u2227\n      (\u2211' i, (f i + g i) ^ p) ^ (1 / p) \u2264\n        (\u2211' i, f i ^ p) ^ (1 / p) + (\u2211' i, g i ^ p) ^ (1 / p) := by\n  have pos : 0 < p := lt_of_lt_of_le zero_lt_one hp\n  have H\u2081 : \u2200 s : Finset \u03b9,\n      (\u2211 i \u2208 s, (f i + g i) ^ p) \u2264\n        ((\u2211' i, f i ^ p) ^ (1 / p) + (\u2211' i, g i ^ p) ^ (1 / p)) ^ p := by\n    intro s\n    rw [one_div]\n    rw [\u2190 NNReal.rpow_inv_le_iff pos]\n    rw [\u2190 one_div]\n    refine le_trans (Lp_add_le s f g hp) (add_le_add ?_ ?_) <;>\n        rw [NNReal.rpow_le_rpow_iff (one_div_pos.mpr pos)] <;>\n      refine Summable.sum_le_tsum _ (fun _ _ => zero_le _) ?_\n    exacts [hf, hg]\n  have bdd : BddAbove (Set.range fun s => \u2211 i \u2208 s, (f i + g i) ^ p) := by\n    refine \u27e8((\u2211' i, f i ^ p) ^ (1 / p) + (\u2211' i, g i ^ p) ^ (1 / p)) ^ p, ?_\u27e9\n    rintro a \u27e8s, rfl\u27e9\n    exact H\u2081 s\n  have H\u2082 : Summable _ := (hasSum_of_isLUB _ (isLUB_ciSup bdd)).summable\n  refine \u27e8H\u2082, ?_\u27e9\n  rw [one_div]\n  rw [NNReal.rpow_inv_le_iff pos]\n  rw [\u2190 one_div]\n  exact H\u2082.tsum_le_of_sum_le H\u2081\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalities.lean", "context": {"open": ["Finset NNReal ENNReal", "scoped BigOperators"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp : 1 \u2264 p\nhf : Summable fun i => f i ^ p\nhg : Summable fun i => g i ^ p\n\u22a2 (Summable fun i => (f i + g i) ^ p) \u2227\n    (\u2211' (i : \u03b9), (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)"}, {"line": "have pos : 0 < p := lt_of_lt_of_le zero_lt_one hp", "tactic_state": "\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp : 1 \u2264 p\nhf : Summable fun i => f i ^ p\nhg : Summable fun i => g i ^ p\npos : 0 < p\n\u22a2 (Summable fun i => (f i + g i) ^ p) \u2227\n    (\u2211' (i : \u03b9), (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)"}, {"line": "have H\u2081 : \u2200 s : Finset \u03b9,\n      (\u2211 i \u2208 s, (f i + g i) ^ p) \u2264\n        ((\u2211' i, f i ^ p) ^ (1 / p) + (\u2211' i, g i ^ p) ^ (1 / p)) ^ p := sorry", "tactic_state": "\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp : 1 \u2264 p\nhf : Summable fun i => f i ^ p\nhg : Summable fun i => g i ^ p\npos : 0 < p\nH\u2081 :\n  \u2200 (s : Finset \u03b9), \u2211 i \u2208 s, (f i + g i) ^ p \u2264 ((\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)) ^ p\n\u22a2 (Summable fun i => (f i + g i) ^ p) \u2227\n    (\u2211' (i : \u03b9), (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)"}, {"line": "have bdd : BddAbove (Set.range fun s => \u2211 i \u2208 s, (f i + g i) ^ p) := by\n    refine \u27e8((\u2211' i, f i ^ p) ^ (1 / p) + (\u2211' i, g i ^ p) ^ (1 / p)) ^ p, ?_\u27e9\n    rintro a \u27e8s, rfl\u27e9\n    exact H\u2081 s", "tactic_state": "\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp : 1 \u2264 p\nhf : Summable fun i => f i ^ p\nhg : Summable fun i => g i ^ p\npos : 0 < p\nH\u2081 :\n  \u2200 (s : Finset \u03b9), \u2211 i \u2208 s, (f i + g i) ^ p \u2264 ((\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)) ^ p\nbdd : BddAbove (Set.range fun s => \u2211 i \u2208 s, (f i + g i) ^ p)\n\u22a2 (Summable fun i => (f i + g i) ^ p) \u2227\n    (\u2211' (i : \u03b9), (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)"}, {"line": "have H\u2082 : Summable _ := (hasSum_of_isLUB _ (isLUB_ciSup bdd)).summable", "tactic_state": "\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp : 1 \u2264 p\nhf : Summable fun i => f i ^ p\nhg : Summable fun i => g i ^ p\npos : 0 < p\nH\u2081 :\n  \u2200 (s : Finset \u03b9), \u2211 i \u2208 s, (f i + g i) ^ p \u2264 ((\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)) ^ p\nbdd : BddAbove (Set.range fun s => \u2211 i \u2208 s, (f i + g i) ^ p)\nH\u2082 : Summable fun i => (f i + g i) ^ p\n\u22a2 (Summable fun i => (f i + g i) ^ p) \u2227\n    (\u2211' (i : \u03b9), (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)"}, {"line": "refine \u27e8H\u2082, ?_\u27e9", "tactic_state": "\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp : 1 \u2264 p\nhf : Summable fun i => f i ^ p\nhg : Summable fun i => g i ^ p\npos : 0 < p\nH\u2081 :\n  \u2200 (s : Finset \u03b9), \u2211 i \u2208 s, (f i + g i) ^ p \u2264 ((\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)) ^ p\nbdd : BddAbove (Set.range fun s => \u2211 i \u2208 s, (f i + g i) ^ p)\nH\u2082 : Summable fun i => (f i + g i) ^ p\n\u22a2 (\u2211' (i : \u03b9), (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)"}, {"line": "rw [one_div]", "tactic_state": "\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp : 1 \u2264 p\nhf : Summable fun i => f i ^ p\nhg : Summable fun i => g i ^ p\npos : 0 < p\nH\u2081 :\n  \u2200 (s : Finset \u03b9), \u2211 i \u2208 s, (f i + g i) ^ p \u2264 ((\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)) ^ p\nbdd : BddAbove (Set.range fun s => \u2211 i \u2208 s, (f i + g i) ^ p)\nH\u2082 : Summable fun i => (f i + g i) ^ p\n\u22a2 (\u2211' (i : \u03b9), (f i + g i) ^ p) ^ p\u207b\u00b9 \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ p\u207b\u00b9 + (\u2211' (i : \u03b9), g i ^ p) ^ p\u207b\u00b9"}, {"line": "rw [NNReal.rpow_inv_le_iff pos]", "tactic_state": "\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp : 1 \u2264 p\nhf : Summable fun i => f i ^ p\nhg : Summable fun i => g i ^ p\npos : 0 < p\nH\u2081 :\n  \u2200 (s : Finset \u03b9), \u2211 i \u2208 s, (f i + g i) ^ p \u2264 ((\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)) ^ p\nbdd : BddAbove (Set.range fun s => \u2211 i \u2208 s, (f i + g i) ^ p)\nH\u2082 : Summable fun i => (f i + g i) ^ p\n\u22a2 \u2211' (i : \u03b9), (f i + g i) ^ p \u2264 ((\u2211' (i : \u03b9), f i ^ p) ^ p\u207b\u00b9 + (\u2211' (i : \u03b9), g i ^ p) ^ p\u207b\u00b9) ^ p"}, {"line": "rw [\u2190 one_div]", "tactic_state": "\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\np : \u211d\nhp : 1 \u2264 p\nhf : Summable fun i => f i ^ p\nhg : Summable fun i => g i ^ p\npos : 0 < p\nH\u2081 :\n  \u2200 (s : Finset \u03b9), \u2211 i \u2208 s, (f i + g i) ^ p \u2264 ((\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)) ^ p\nbdd : BddAbove (Set.range fun s => \u2211 i \u2208 s, (f i + g i) ^ p)\nH\u2082 : Summable fun i => (f i + g i) ^ p\n\u22a2 \u2211' (i : \u03b9), (f i + g i) ^ p \u2264 ((\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)) ^ p"}, {"line": "exact H\u2082.tsum_le_of_sum_le H\u2081", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Lp_add_le_hasSum {f g : \u03b9 \u2192 \u211d\u22650} {A B : \u211d\u22650} {p : \u211d} (hp : 1 \u2264 p)\n    (hf : HasSum (fun i => f i ^ p) (A ^ p)) (hg : HasSum (fun i => g i ^ p) (B ^ p)) :\n    \u2203 C, C \u2264 A + B \u2227 HasSum (fun i => (f i + g i) ^ p) (C ^ p) := by\n  have hp' : p \u2260 0 := (lt_of_lt_of_le zero_lt_one hp).ne'\n  obtain \u27e8H\u2081, H\u2082\u27e9 := Lp_add_le_tsum hp hf.summable hg.summable\n  have hA : A = (\u2211' i : \u03b9, f i ^ p) ^ (1 / p) := by rw [hf.tsum_eq, rpow_inv_rpow_self hp']\n  have hB : B = (\u2211' i : \u03b9, g i ^ p) ^ (1 / p) := by rw [hg.tsum_eq, rpow_inv_rpow_self hp']\n  refine \u27e8(\u2211' i, (f i + g i) ^ p) ^ (1 / p), ?_, ?_\u27e9\n  \u00b7 simpa [hA, hB] using H\u2082\n  \u00b7 simpa only [rpow_self_rpow_inv hp'] using H\u2081.hasSum\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalities.lean", "context": {"open": ["Finset NNReal ENNReal", "scoped BigOperators"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\nA B : NNReal\np : \u211d\nhp : 1 \u2264 p\nhf : HasSum (fun i => f i ^ p) (A ^ p)\nhg : HasSum (fun i => g i ^ p) (B ^ p)\n\u22a2 \u2203 C \u2264 A + B, HasSum (fun i => (f i + g i) ^ p) (C ^ p)"}, {"line": "have hp' : p \u2260 0 := (lt_of_lt_of_le zero_lt_one hp).ne'", "tactic_state": "\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\nA B : NNReal\np : \u211d\nhp : 1 \u2264 p\nhf : HasSum (fun i => f i ^ p) (A ^ p)\nhg : HasSum (fun i => g i ^ p) (B ^ p)\nhp' : p \u2260 0\n\u22a2 \u2203 C \u2264 A + B, HasSum (fun i => (f i + g i) ^ p) (C ^ p)"}, {"line": "obtain \u27e8H\u2081, H\u2082\u27e9 := Lp_add_le_tsum hp hf.summable hg.summable", "tactic_state": "case intro\n\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\nA B : NNReal\np : \u211d\nhp : 1 \u2264 p\nhf : HasSum (fun i => f i ^ p) (A ^ p)\nhg : HasSum (fun i => g i ^ p) (B ^ p)\nhp' : p \u2260 0\nH\u2081 : Summable fun i => (f i + g i) ^ p\nH\u2082 : (\u2211' (i : \u03b9), (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)\n\u22a2 \u2203 C \u2264 A + B, HasSum (fun i => (f i + g i) ^ p) (C ^ p)"}, {"line": "have hA : A = (\u2211' i : \u03b9, f i ^ p) ^ (1 / p) := by rw [hf.tsum_eq, rpow_inv_rpow_self hp']", "tactic_state": "case intro\n\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\nA B : NNReal\np : \u211d\nhp : 1 \u2264 p\nhf : HasSum (fun i => f i ^ p) (A ^ p)\nhg : HasSum (fun i => g i ^ p) (B ^ p)\nhp' : p \u2260 0\nH\u2081 : Summable fun i => (f i + g i) ^ p\nH\u2082 : (\u2211' (i : \u03b9), (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)\nhA : A = (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p)\n\u22a2 \u2203 C \u2264 A + B, HasSum (fun i => (f i + g i) ^ p) (C ^ p)"}, {"line": "have hB : B = (\u2211' i : \u03b9, g i ^ p) ^ (1 / p) := by rw [hg.tsum_eq, rpow_inv_rpow_self hp']", "tactic_state": "case intro\n\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\nA B : NNReal\np : \u211d\nhp : 1 \u2264 p\nhf : HasSum (fun i => f i ^ p) (A ^ p)\nhg : HasSum (fun i => g i ^ p) (B ^ p)\nhp' : p \u2260 0\nH\u2081 : Summable fun i => (f i + g i) ^ p\nH\u2082 : (\u2211' (i : \u03b9), (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)\nhA : A = (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p)\nhB : B = (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)\n\u22a2 \u2203 C \u2264 A + B, HasSum (fun i => (f i + g i) ^ p) (C ^ p)"}, {"line": "refine \u27e8(\u2211' i, (f i + g i) ^ p) ^ (1 / p), ?_, ?_\u27e9", "tactic_state": "case intro.refine_1\n\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\nA B : NNReal\np : \u211d\nhp : 1 \u2264 p\nhf : HasSum (fun i => f i ^ p) (A ^ p)\nhg : HasSum (fun i => g i ^ p) (B ^ p)\nhp' : p \u2260 0\nH\u2081 : Summable fun i => (f i + g i) ^ p\nH\u2082 : (\u2211' (i : \u03b9), (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)\nhA : A = (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p)\nhB : B = (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)\n\u22a2 (\u2211' (i : \u03b9), (f i + g i) ^ p) ^ (1 / p) \u2264 A + B\n---\ncase intro.refine_2\n\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\nA B : NNReal\np : \u211d\nhp : 1 \u2264 p\nhf : HasSum (fun i => f i ^ p) (A ^ p)\nhg : HasSum (fun i => g i ^ p) (B ^ p)\nhp' : p \u2260 0\nH\u2081 : Summable fun i => (f i + g i) ^ p\nH\u2082 : (\u2211' (i : \u03b9), (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)\nhA : A = (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p)\nhB : B = (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)\n\u22a2 HasSum (fun i => (f i + g i) ^ p) (((\u2211' (i : \u03b9), (f i + g i) ^ p) ^ (1 / p)) ^ p)"}, {"line": "\u00b7 simpa [hA, hB] using H\u2082", "tactic_state": "case intro.refine_2\n\u03b9 : Type u\nf g : \u03b9 \u2192 NNReal\nA B : NNReal\np : \u211d\nhp : 1 \u2264 p\nhf : HasSum (fun i => f i ^ p) (A ^ p)\nhg : HasSum (fun i => g i ^ p) (B ^ p)\nhp' : p \u2260 0\nH\u2081 : Summable fun i => (f i + g i) ^ p\nH\u2082 : (\u2211' (i : \u03b9), (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p) + (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)\nhA : A = (\u2211' (i : \u03b9), f i ^ p) ^ (1 / p)\nhB : B = (\u2211' (i : \u03b9), g i ^ p) ^ (1 / p)\n\u22a2 HasSum (fun i => (f i + g i) ^ p) (((\u2211' (i : \u03b9), (f i + g i) ^ p) ^ (1 / p)) ^ p)"}, {"line": "\u00b7 simpa only [rpow_self_rpow_inv hp'] using H\u2081.hasSum", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_sum_le_const_mul_sum_rpow (hp : 1 \u2264 p) :\n    (\u2211 i \u2208 s, |f i|) ^ p \u2264 (#s : \u211d) ^ (p - 1) * \u2211 i \u2208 s, |f i| ^ p := by\n  have :=\n    NNReal.coe_le_coe.2\n      (NNReal.rpow_sum_le_const_mul_sum_rpow s (fun i => \u27e8_, abs_nonneg (f i)\u27e9) hp)\n  push_cast at this\n  exact this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalities.lean", "context": {"open": ["Finset NNReal ENNReal", "scoped BigOperators"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)", "(f g : \u03b9 \u2192 \u211d) {p q : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\ns : Finset \u03b9\nf : \u03b9 \u2192 \u211d\np : \u211d\nhp : 1 \u2264 p\n\u22a2 (\u2211 i \u2208 s, |f i|) ^ p \u2264 \u2191s.card ^ (p - 1) * \u2211 i \u2208 s, |f i| ^ p"}, {"line": "have :=\n    NNReal.coe_le_coe.2\n      (NNReal.rpow_sum_le_const_mul_sum_rpow s (fun i => \u27e8_, abs_nonneg (f i)\u27e9) hp)", "tactic_state": "\u03b9 : Type u\ns : Finset \u03b9\nf : \u03b9 \u2192 \u211d\np : \u211d\nhp : 1 \u2264 p\nthis : \u2191((\u2211 i \u2208 s, (fun i => \u27e8|f i|, \u22ef\u27e9) i) ^ p) \u2264 \u2191(\u2191s.card ^ (p - 1) * \u2211 i \u2208 s, (fun i => \u27e8|f i|, \u22ef\u27e9) i ^ p)\n\u22a2 (\u2211 i \u2208 s, |f i|) ^ p \u2264 \u2191s.card ^ (p - 1) * \u2211 i \u2208 s, |f i| ^ p"}, {"line": "push_cast at this", "tactic_state": "\u03b9 : Type u\ns : Finset \u03b9\nf : \u03b9 \u2192 \u211d\np : \u211d\nhp : 1 \u2264 p\nthis : (\u2211 x \u2208 s, |f x|) ^ p \u2264 \u2191s.card ^ (p - 1) * \u2211 x \u2208 s, |f x| ^ p\n\u22a2 (\u2211 i \u2208 s, |f i|) ^ p \u2264 \u2191s.card ^ (p - 1) * \u2211 i \u2208 s, |f i| ^ p"}, {"line": "exact this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Lp_add_le (hp : 1 \u2264 p) :\n    (\u2211 i \u2208 s, |f i + g i| ^ p) ^ (1 / p) \u2264\n      (\u2211 i \u2208 s, |f i| ^ p) ^ (1 / p) + (\u2211 i \u2208 s, |g i| ^ p) ^ (1 / p) := by\n  have :=\n    NNReal.coe_le_coe.2\n      (NNReal.Lp_add_le s (fun i => \u27e8_, abs_nonneg (f i)\u27e9) (fun i => \u27e8_, abs_nonneg (g i)\u27e9) hp)\n  push_cast at this\n  refine le_trans (rpow_le_rpow ?_ (sum_le_sum fun i _ => ?_) ?_) this <;>\n    simp [sum_nonneg, rpow_nonneg, abs_nonneg, le_trans zero_le_one hp, abs_add,\n      rpow_le_rpow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalities.lean", "context": {"open": ["Finset NNReal ENNReal", "scoped BigOperators"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)", "(f g : \u03b9 \u2192 \u211d) {p q : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 \u211d\np : \u211d\nhp : 1 \u2264 p\n\u22a2 (\u2211 i \u2208 s, |f i + g i| ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, |f i| ^ p) ^ (1 / p) + (\u2211 i \u2208 s, |g i| ^ p) ^ (1 / p)"}, {"line": "have :=\n    NNReal.coe_le_coe.2\n      (NNReal.Lp_add_le s (fun i => \u27e8_, abs_nonneg (f i)\u27e9) (fun i => \u27e8_, abs_nonneg (g i)\u27e9) hp)", "tactic_state": "\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 \u211d\np : \u211d\nhp : 1 \u2264 p\nthis :\n  \u2191((\u2211 i \u2208 s, ((fun i => \u27e8|f i|, \u22ef\u27e9) i + (fun i => \u27e8|g i|, \u22ef\u27e9) i) ^ p) ^ (1 / p)) \u2264\n    \u2191((\u2211 i \u2208 s, (fun i => \u27e8|f i|, \u22ef\u27e9) i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, (fun i => \u27e8|g i|, \u22ef\u27e9) i ^ p) ^ (1 / p))\n\u22a2 (\u2211 i \u2208 s, |f i + g i| ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, |f i| ^ p) ^ (1 / p) + (\u2211 i \u2208 s, |g i| ^ p) ^ (1 / p)"}, {"line": "push_cast at this", "tactic_state": "\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 \u211d\np : \u211d\nhp : 1 \u2264 p\nthis : (\u2211 x \u2208 s, (|f x| + |g x|) ^ p) ^ (1 / p) \u2264 (\u2211 x \u2208 s, |f x| ^ p) ^ (1 / p) + (\u2211 x \u2208 s, |g x| ^ p) ^ (1 / p)\n\u22a2 (\u2211 i \u2208 s, |f i + g i| ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, |f i| ^ p) ^ (1 / p) + (\u2211 i \u2208 s, |g i| ^ p) ^ (1 / p)"}, {"line": "refine le_trans (rpow_le_rpow ?_ (sum_le_sum fun i _ => ?_) ?_) this <;>\n    simp [sum_nonneg, rpow_nonneg, abs_nonneg, le_trans zero_le_one hp, abs_add,\n      rpow_le_rpow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Lp_add_le (hp : 1 \u2264 p) :\n    (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264\n      (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p) := by\n  by_cases H' : (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) = \u22a4 \u2228 (\u2211 i \u2208 s, g i ^ p) ^ (1 / p) = \u22a4\n  \u00b7 rcases H' with H' | H' <;> simp [H', -one_div]\n  have pos : 0 < p := lt_of_lt_of_le zero_lt_one hp\n  replace H' : (\u2200 i \u2208 s, f i \u2260 \u22a4) \u2227 \u2200 i \u2208 s, g i \u2260 \u22a4 := by\n    simpa [ENNReal.rpow_eq_top_iff, asymm pos, pos, ENNReal.sum_eq_top, not_or] using H'\n  have :=\n    ENNReal.coe_le_coe.2\n      (@NNReal.Lp_add_le _ s (fun i => ENNReal.toNNReal (f i)) (fun i => ENNReal.toNNReal (g i)) _\n        hp)\n  push_cast [ENNReal.coe_rpow_of_nonneg, le_of_lt pos, le_of_lt (one_div_pos.2 pos)] at this\n  convert this using 2 <;> [skip; congr 1; congr 1] <;>\n    \u00b7 refine Finset.sum_congr rfl fun i hi => ?_\n      simp [H'.1 i hi, H'.2 i hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MeanInequalities.lean", "context": {"open": ["Finset NNReal ENNReal", "scoped BigOperators"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)", "(f g : \u03b9 \u2192 \u211d) {p q : \u211d}", "{f g}", "(f g : \u03b9 \u2192 \u211d\u22650\u221e) {p q : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 ENNReal\np : \u211d\nhp : 1 \u2264 p\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)"}, {"line": "by_cases H' : (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) = \u22a4 \u2228 (\u2211 i \u2208 s, g i ^ p) ^ (1 / p) = \u22a4", "tactic_state": "case pos\n\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 ENNReal\np : \u211d\nhp : 1 \u2264 p\nH' : (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) = \u22a4 \u2228 (\u2211 i \u2208 s, g i ^ p) ^ (1 / p) = \u22a4\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)\n---\ncase neg\n\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 ENNReal\np : \u211d\nhp : 1 \u2264 p\nH' : \u00ac((\u2211 i \u2208 s, f i ^ p) ^ (1 / p) = \u22a4 \u2228 (\u2211 i \u2208 s, g i ^ p) ^ (1 / p) = \u22a4)\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)"}, {"line": "\u00b7 rcases H' with H' | H' <;> simp [H', -one_div]", "tactic_state": "case neg\n\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 ENNReal\np : \u211d\nhp : 1 \u2264 p\nH' : \u00ac((\u2211 i \u2208 s, f i ^ p) ^ (1 / p) = \u22a4 \u2228 (\u2211 i \u2208 s, g i ^ p) ^ (1 / p) = \u22a4)\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)"}, {"line": "have pos : 0 < p := lt_of_lt_of_le zero_lt_one hp", "tactic_state": "case neg\n\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 ENNReal\np : \u211d\nhp : 1 \u2264 p\nH' : \u00ac((\u2211 i \u2208 s, f i ^ p) ^ (1 / p) = \u22a4 \u2228 (\u2211 i \u2208 s, g i ^ p) ^ (1 / p) = \u22a4)\npos : 0 < p\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)"}, {"line": "replace H' : (\u2200 i \u2208 s, f i \u2260 \u22a4) \u2227 \u2200 i \u2208 s, g i \u2260 \u22a4 := by\n    simpa [ENNReal.rpow_eq_top_iff, asymm pos, pos, ENNReal.sum_eq_top, not_or] using H'", "tactic_state": "case neg\n\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 ENNReal\np : \u211d\nhp : 1 \u2264 p\npos : 0 < p\nH' : (\u2200 i \u2208 s, f i \u2260 \u22a4) \u2227 \u2200 i \u2208 s, g i \u2260 \u22a4\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)"}, {"line": "have :=\n    ENNReal.coe_le_coe.2\n      (@NNReal.Lp_add_le _ s (fun i => ENNReal.toNNReal (f i)) (fun i => ENNReal.toNNReal (g i)) _\n        hp)", "tactic_state": "case neg\n\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 ENNReal\np : \u211d\nhp : 1 \u2264 p\npos : 0 < p\nH' : (\u2200 i \u2208 s, f i \u2260 \u22a4) \u2227 \u2200 i \u2208 s, g i \u2260 \u22a4\nthis :\n  \u2191((\u2211 i \u2208 s, ((fun i => (f i).toNNReal) i + (fun i => (g i).toNNReal) i) ^ p) ^ (1 / p)) \u2264\n    \u2191((\u2211 i \u2208 s, (fun i => (f i).toNNReal) i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, (fun i => (g i).toNNReal) i ^ p) ^ (1 / p))\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)"}, {"line": "push_cast [ENNReal.coe_rpow_of_nonneg, le_of_lt pos, le_of_lt (one_div_pos.2 pos)] at this", "tactic_state": "case neg\n\u03b9 : Type u\ns : Finset \u03b9\nf g : \u03b9 \u2192 ENNReal\np : \u211d\nhp : 1 \u2264 p\npos : 0 < p\nH' : (\u2200 i \u2208 s, f i \u2260 \u22a4) \u2227 \u2200 i \u2208 s, g i \u2260 \u22a4\nthis :\n  (\u2211 x \u2208 s, (\u2191(f x).toNNReal + \u2191(g x).toNNReal) ^ p) ^ (1 / p) \u2264\n    (\u2211 x \u2208 s, \u2191(f x).toNNReal ^ p) ^ (1 / p) + (\u2211 x \u2208 s, \u2191(g x).toNNReal ^ p) ^ (1 / p)\n\u22a2 (\u2211 i \u2208 s, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211 i \u2208 s, f i ^ p) ^ (1 / p) + (\u2211 i \u2208 s, g i ^ p) ^ (1 / p)"}, {"line": "convert this using 2 <;> [skip; congr 1; congr 1] <;>\n    \u00b7 refine Finset.sum_congr rfl fun i hi => ?_\n      simp [H'.1 i hi, H'.2 i hi]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MellinConvergent.const_smul {f : \u211d \u2192 E} {s : \u2102} (hf : MellinConvergent f s) {\ud835\udd5c : Type*}\n    [NontriviallyNormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] [SMulCommClass \u2102 \ud835\udd5c E] (c : \ud835\udd5c) :\n    MellinConvergent (fun t => c \u2022 f t) s := by\n  simpa only [MellinConvergent,smul_comm] using hf.smul c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MellinTransform.lean", "context": {"open": ["MeasureTheory Set Filter Asymptotics TopologicalSpace", "Real", "Complex hiding exp log abs_of_nonneg", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u2102 E\nf : \u211d \u2192 E\ns : \u2102\nhf : MellinConvergent f s\n\ud835\udd5c : Type u_2\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : SMulCommClass \u2102 \ud835\udd5c E\nc : \ud835\udd5c\n\u22a2 MellinConvergent (fun t => c \u2022 f t) s"}, {"line": "simpa only [MellinConvergent,smul_comm] using hf.smul c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mellin_const_smul (f : \u211d \u2192 E) (s : \u2102) {\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]\n    [NormedSpace \ud835\udd5c E] [SMulCommClass \u2102 \ud835\udd5c E] (c : \ud835\udd5c) :\n    mellin (fun t => c \u2022 f t) s = c \u2022 mellin f s := by simp only [mellin, smul_comm, integral_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MellinTransform.lean", "context": {"open": ["MeasureTheory Set Filter Asymptotics TopologicalSpace", "Real", "Complex hiding exp log abs_of_nonneg", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u2102 E\nf : \u211d \u2192 E\ns : \u2102\n\ud835\udd5c : Type u_2\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : SMulCommClass \u2102 \ud835\udd5c E\nc : \ud835\udd5c\n\u22a2 mellin (fun t => c \u2022 f t) s = c \u2022 mellin f s"}, {"line": "simp only [mellin, smul_comm, integral_smul]", "tactic_state": "E : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u2102 E\nf : \u211d \u2192 E\ns : \u2102\n\ud835\udd5c : Type u_2\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : SMulCommClass \u2102 \ud835\udd5c E\nc : \ud835\udd5c\n\u22a2 \u222b (t : \u211d) in Ioi 0, \u2191t ^ (s - 1) \u2022 c \u2022 f t = c \u2022 \u222b (t : \u211d) in Ioi 0, \u2191t ^ (s - 1) \u2022 f t"}]}
{"declaration": "theorem mellin_div_const (f : \u211d \u2192 \u2102) (s a : \u2102) : mellin (fun t => f t / a) s = mellin f s / a := by\n  simp_rw [mellin, smul_eq_mul, \u2190 mul_div_assoc, integral_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MellinTransform.lean", "context": {"open": ["MeasureTheory Set Filter Asymptotics TopologicalSpace", "Real", "Complex hiding exp log abs_of_nonneg", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u2102\ns a : \u2102\n\u22a2 mellin (fun t => f t / a) s = mellin f s / a"}, {"line": "simp_rw [mellin, smul_eq_mul, \u2190 mul_div_assoc, integral_div]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mellin_comp_mul_right (f : \u211d \u2192 E) (s : \u2102) {a : \u211d} (ha : 0 < a) :\n    mellin (fun t => f (t * a)) s = (a : \u2102) ^ (-s) \u2022 mellin f s := by\n  simpa only [mul_comm] using mellin_comp_mul_left f s ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MellinTransform.lean", "context": {"open": ["MeasureTheory Set Filter Asymptotics TopologicalSpace", "Real", "Complex hiding exp log abs_of_nonneg", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u211d \u2192 E\ns : \u2102\na : \u211d\nha : 0 < a\n\u22a2 mellin (fun t => f (t * a)) s = \u2191a ^ (-s) \u2022 mellin f s"}, {"line": "simpa only [mul_comm] using mellin_comp_mul_left f s ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mellin_comp_inv (f : \u211d \u2192 E) (s : \u2102) : mellin (fun t => f t\u207b\u00b9) s = mellin f (-s) := by\n  simp_rw [\u2190 rpow_neg_one, mellin_comp_rpow _ _ _, abs_neg, abs_one,\n    inv_one, one_smul, ofReal_neg, ofReal_one, div_neg, div_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MellinTransform.lean", "context": {"open": ["MeasureTheory Set Filter Asymptotics TopologicalSpace", "Real", "Complex hiding exp log abs_of_nonneg", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u211d \u2192 E\ns : \u2102\n\u22a2 mellin (fun t => f t\u207b\u00b9) s = mellin f (-s)"}, {"line": "simp_rw [\u2190 rpow_neg_one, mellin_comp_rpow _ _ _, abs_neg, abs_one,\n    inv_one, one_smul, ofReal_neg, ofReal_one, div_neg, div_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mellin_convergent_of_isBigO_scalar {a b : \u211d} {f : \u211d \u2192 \u211d} {s : \u211d}\n    (hfc : LocallyIntegrableOn f <| Ioi 0) (hf_top : f =O[atTop] (\u00b7 ^ (-a)))\n    (hs_top : s < a) (hf_bot : f =O[\ud835\udcdd[>] 0] (\u00b7 ^ (-b))) (hs_bot : b < s) :\n    IntegrableOn (fun t : \u211d => t ^ (s - 1) * f t) (Ioi 0) := by\n  obtain \u27e8c1, hc1, hc1'\u27e9 := mellin_convergent_top_of_isBigO hfc.aestronglyMeasurable hf_top hs_top\n  obtain \u27e8c2, hc2, hc2'\u27e9 :=\n    mellin_convergent_zero_of_isBigO hfc.aestronglyMeasurable hf_bot hs_bot\n  have : Ioi 0 = Ioc 0 c2 \u222a Ioc c2 c1 \u222a Ioi c1 := by\n    rw [union_assoc]\n    rw [Ioc_union_Ioi (le_max_right _ _)]\n    rw [Ioc_union_Ioi ((min_le_left _ _).trans (le_max_right _ _))]\n    rw [min_eq_left (lt_min hc2 hc1).le]\n  rw [this]\n  rw [integrableOn_union]\n  rw [integrableOn_union]\n  refine \u27e8\u27e8hc2', integrableOn_Icc_iff_integrableOn_Ioc.mp ?_\u27e9, hc1'\u27e9\n  refine\n    (hfc.continuousOn_mul ?_ isOpen_Ioi.isLocallyClosed).integrableOn_compact_subset\n      (fun t ht => (hc2.trans_le ht.1 : 0 < t)) isCompact_Icc\n  exact continuousOn_of_forall_continuousAt\n    fun t ht \u21a6 continuousAt_rpow_const _ _ <| Or.inl <| ne_of_gt ht\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MellinTransform.lean", "context": {"open": ["MeasureTheory Set Filter Asymptotics TopologicalSpace", "Real", "Complex hiding exp log abs_of_nonneg", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "{E : Type*} [NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nf : \u211d \u2192 \u211d\ns : \u211d\nhfc : LocallyIntegrableOn f (Ioi 0) volume\nhf_top : f =O[atTop] fun x => x ^ (-a)\nhs_top : s < a\nhf_bot : f =O[nhdsWithin 0 (Ioi 0)] fun x => x ^ (-b)\nhs_bot : b < s\n\u22a2 IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioi 0) volume"}, {"line": "obtain \u27e8c1, hc1, hc1'\u27e9 := mellin_convergent_top_of_isBigO hfc.aestronglyMeasurable hf_top hs_top", "tactic_state": "case intro.intro\na b : \u211d\nf : \u211d \u2192 \u211d\ns : \u211d\nhfc : LocallyIntegrableOn f (Ioi 0) volume\nhf_top : f =O[atTop] fun x => x ^ (-a)\nhs_top : s < a\nhf_bot : f =O[nhdsWithin 0 (Ioi 0)] fun x => x ^ (-b)\nhs_bot : b < s\nc1 : \u211d\nhc1 : 0 < c1\nhc1' : IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioi c1) volume\n\u22a2 IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioi 0) volume"}, {"line": "obtain \u27e8c2, hc2, hc2'\u27e9 :=\n    mellin_convergent_zero_of_isBigO hfc.aestronglyMeasurable hf_bot hs_bot", "tactic_state": "case intro.intro.intro.intro\na b : \u211d\nf : \u211d \u2192 \u211d\ns : \u211d\nhfc : LocallyIntegrableOn f (Ioi 0) volume\nhf_top : f =O[atTop] fun x => x ^ (-a)\nhs_top : s < a\nhf_bot : f =O[nhdsWithin 0 (Ioi 0)] fun x => x ^ (-b)\nhs_bot : b < s\nc1 : \u211d\nhc1 : 0 < c1\nhc1' : IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioi c1) volume\nc2 : \u211d\nhc2 : 0 < c2\nhc2' : IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioc 0 c2) volume\n\u22a2 IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioi 0) volume"}, {"line": "have : Ioi 0 = Ioc 0 c2 \u222a Ioc c2 c1 \u222a Ioi c1 := by\n    rw [union_assoc]\n    rw [Ioc_union_Ioi (le_max_right _ _)]\n    rw [Ioc_union_Ioi ((min_le_left _ _).trans (le_max_right _ _))]\n    rw [min_eq_left (lt_min hc2 hc1).le]", "tactic_state": "case intro.intro.intro.intro\na b : \u211d\nf : \u211d \u2192 \u211d\ns : \u211d\nhfc : LocallyIntegrableOn f (Ioi 0) volume\nhf_top : f =O[atTop] fun x => x ^ (-a)\nhs_top : s < a\nhf_bot : f =O[nhdsWithin 0 (Ioi 0)] fun x => x ^ (-b)\nhs_bot : b < s\nc1 : \u211d\nhc1 : 0 < c1\nhc1' : IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioi c1) volume\nc2 : \u211d\nhc2 : 0 < c2\nhc2' : IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioc 0 c2) volume\nthis : Ioi 0 = Ioc 0 c2 \u222a Ioc c2 c1 \u222a Ioi c1\n\u22a2 IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioi 0) volume"}, {"line": "rw [this]", "tactic_state": "case intro.intro.intro.intro\na b : \u211d\nf : \u211d \u2192 \u211d\ns : \u211d\nhfc : LocallyIntegrableOn f (Ioi 0) volume\nhf_top : f =O[atTop] fun x => x ^ (-a)\nhs_top : s < a\nhf_bot : f =O[nhdsWithin 0 (Ioi 0)] fun x => x ^ (-b)\nhs_bot : b < s\nc1 : \u211d\nhc1 : 0 < c1\nhc1' : IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioi c1) volume\nc2 : \u211d\nhc2 : 0 < c2\nhc2' : IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioc 0 c2) volume\nthis : Ioi 0 = Ioc 0 c2 \u222a Ioc c2 c1 \u222a Ioi c1\n\u22a2 IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioc 0 c2 \u222a Ioc c2 c1 \u222a Ioi c1) volume"}, {"line": "rw [integrableOn_union]", "tactic_state": "case intro.intro.intro.intro\na b : \u211d\nf : \u211d \u2192 \u211d\ns : \u211d\nhfc : LocallyIntegrableOn f (Ioi 0) volume\nhf_top : f =O[atTop] fun x => x ^ (-a)\nhs_top : s < a\nhf_bot : f =O[nhdsWithin 0 (Ioi 0)] fun x => x ^ (-b)\nhs_bot : b < s\nc1 : \u211d\nhc1 : 0 < c1\nhc1' : IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioi c1) volume\nc2 : \u211d\nhc2 : 0 < c2\nhc2' : IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioc 0 c2) volume\nthis : Ioi 0 = Ioc 0 c2 \u222a Ioc c2 c1 \u222a Ioi c1\n\u22a2 IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioc 0 c2 \u222a Ioc c2 c1) volume \u2227\n    IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioi c1) volume"}, {"line": "rw [integrableOn_union]", "tactic_state": "case intro.intro.intro.intro\na b : \u211d\nf : \u211d \u2192 \u211d\ns : \u211d\nhfc : LocallyIntegrableOn f (Ioi 0) volume\nhf_top : f =O[atTop] fun x => x ^ (-a)\nhs_top : s < a\nhf_bot : f =O[nhdsWithin 0 (Ioi 0)] fun x => x ^ (-b)\nhs_bot : b < s\nc1 : \u211d\nhc1 : 0 < c1\nhc1' : IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioi c1) volume\nc2 : \u211d\nhc2 : 0 < c2\nhc2' : IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioc 0 c2) volume\nthis : Ioi 0 = Ioc 0 c2 \u222a Ioc c2 c1 \u222a Ioi c1\n\u22a2 (IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioc 0 c2) volume \u2227\n      IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioc c2 c1) volume) \u2227\n    IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioi c1) volume"}, {"line": "refine \u27e8\u27e8hc2', integrableOn_Icc_iff_integrableOn_Ioc.mp ?_\u27e9, hc1'\u27e9", "tactic_state": "case intro.intro.intro.intro\na b : \u211d\nf : \u211d \u2192 \u211d\ns : \u211d\nhfc : LocallyIntegrableOn f (Ioi 0) volume\nhf_top : f =O[atTop] fun x => x ^ (-a)\nhs_top : s < a\nhf_bot : f =O[nhdsWithin 0 (Ioi 0)] fun x => x ^ (-b)\nhs_bot : b < s\nc1 : \u211d\nhc1 : 0 < c1\nhc1' : IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioi c1) volume\nc2 : \u211d\nhc2 : 0 < c2\nhc2' : IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioc 0 c2) volume\nthis : Ioi 0 = Ioc 0 c2 \u222a Ioc c2 c1 \u222a Ioi c1\n\u22a2 IntegrableOn (fun t => t ^ (s - 1) * f t) (Icc c2 c1) volume"}, {"line": "refine\n    (hfc.continuousOn_mul ?_ isOpen_Ioi.isLocallyClosed).integrableOn_compact_subset\n      (fun t ht => (hc2.trans_le ht.1 : 0 < t)) isCompact_Icc", "tactic_state": "case intro.intro.intro.intro\na b : \u211d\nf : \u211d \u2192 \u211d\ns : \u211d\nhfc : LocallyIntegrableOn f (Ioi 0) volume\nhf_top : f =O[atTop] fun x => x ^ (-a)\nhs_top : s < a\nhf_bot : f =O[nhdsWithin 0 (Ioi 0)] fun x => x ^ (-b)\nhs_bot : b < s\nc1 : \u211d\nhc1 : 0 < c1\nhc1' : IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioi c1) volume\nc2 : \u211d\nhc2 : 0 < c2\nhc2' : IntegrableOn (fun t => t ^ (s - 1) * f t) (Ioc 0 c2) volume\nthis : Ioi 0 = Ioc 0 c2 \u222a Ioc c2 c1 \u222a Ioi c1\n\u22a2 ContinuousOn (fun t => t ^ (s - 1)) (Ioi 0)"}, {"line": "exact continuousOn_of_forall_continuousAt\n    fun t ht \u21a6 continuousAt_rpow_const _ _ <| Or.inl <| ne_of_gt ht", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasMellin_one_Ioc {s : \u2102} (hs : 0 < re s) :\n    HasMellin (indicator (Ioc 0 1) (fun _ => 1 : \u211d \u2192 \u2102)) s (1 / s) := by\n  have aux1 : -1 < (s - 1).re := by\n    simpa only [sub_re,one_re,sub_eq_add_neg] using lt_add_of_pos_left _ hs\n  have aux2 : s \u2260 0 := by contrapose! hs; rw [hs, zero_re]\n  have aux3 : MeasurableSet (Ioc (0 : \u211d) 1) := measurableSet_Ioc\n  simp_rw [HasMellin, mellin, MellinConvergent, \u2190 indicator_smul, IntegrableOn,\n    integrable_indicator_iff aux3, smul_eq_mul, integral_indicator aux3, mul_one, IntegrableOn,\n    Measure.restrict_restrict_of_subset Ioc_subset_Ioi_self]\n  rw [\u2190 IntegrableOn]\n  rw [\u2190 intervalIntegrable_iff_integrableOn_Ioc_of_le zero_le_one]\n  refine \u27e8intervalIntegral.intervalIntegrable_cpow' aux1, ?_\u27e9\n  rw [\u2190 intervalIntegral.integral_of_le zero_le_one]\n  rw [integral_cpow (Or.inl aux1)]\n  rw [sub_add_cancel]\n  rw [ofReal_zero]\n  rw [ofReal_one]\n  rw [one_cpow]\n  rw [zero_cpow aux2]\n  rw [sub_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MellinTransform.lean", "context": {"open": ["MeasureTheory Set Filter Asymptotics TopologicalSpace", "Real", "Complex hiding exp log abs_of_nonneg", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "{E : Type*} [NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u2102\nhs : 0 < s.re\n\u22a2 HasMellin ((Ioc 0 1).indicator fun x => 1) s (1 / s)"}, {"line": "have aux1 : -1 < (s - 1).re := sorry", "tactic_state": "s : \u2102\nhs : 0 < s.re\naux1 : -1 < (s - 1).re\n\u22a2 HasMellin ((Ioc 0 1).indicator fun x => 1) s (1 / s)"}, {"line": "have aux2 : s \u2260 0 := sorry", "tactic_state": "s : \u2102\nhs : 0 < s.re\naux1 : -1 < (s - 1).re\naux2 : s \u2260 0\n\u22a2 HasMellin ((Ioc 0 1).indicator fun x => 1) s (1 / s)"}, {"line": "have aux3 : MeasurableSet (Ioc (0 : \u211d) 1) := measurableSet_Ioc", "tactic_state": "s : \u2102\nhs : 0 < s.re\naux1 : -1 < (s - 1).re\naux2 : s \u2260 0\naux3 : MeasurableSet (Ioc 0 1)\n\u22a2 HasMellin ((Ioc 0 1).indicator fun x => 1) s (1 / s)"}, {"line": "simp_rw [HasMellin, mellin, MellinConvergent, \u2190 indicator_smul, IntegrableOn,\n    integrable_indicator_iff aux3, smul_eq_mul, integral_indicator aux3, mul_one, IntegrableOn,\n    Measure.restrict_restrict_of_subset Ioc_subset_Ioi_self]", "tactic_state": "s : \u2102\nhs : 0 < s.re\naux1 : -1 < (s - 1).re\naux2 : s \u2260 0\naux3 : MeasurableSet (Ioc 0 1)\n\u22a2 Integrable (fun a => \u2191a ^ (s - 1)) (volume.restrict (Ioc 0 1)) \u2227 \u222b (a : \u211d) in Ioc 0 1, \u2191a ^ (s - 1) \u2202volume = 1 / s"}, {"line": "rw [\u2190 IntegrableOn]", "tactic_state": "s : \u2102\nhs : 0 < s.re\naux1 : -1 < (s - 1).re\naux2 : s \u2260 0\naux3 : MeasurableSet (Ioc 0 1)\n\u22a2 IntegrableOn (fun a => \u2191a ^ (s - 1)) (Ioc 0 1) volume \u2227 \u222b (a : \u211d) in Ioc 0 1, \u2191a ^ (s - 1) \u2202volume = 1 / s"}, {"line": "rw [\u2190 intervalIntegrable_iff_integrableOn_Ioc_of_le zero_le_one]", "tactic_state": "s : \u2102\nhs : 0 < s.re\naux1 : -1 < (s - 1).re\naux2 : s \u2260 0\naux3 : MeasurableSet (Ioc 0 1)\n\u22a2 IntervalIntegrable (fun a => \u2191a ^ (s - 1)) volume 0 1 \u2227 \u222b (a : \u211d) in Ioc 0 1, \u2191a ^ (s - 1) \u2202volume = 1 / s"}, {"line": "refine \u27e8intervalIntegral.intervalIntegrable_cpow' aux1, ?_\u27e9", "tactic_state": "s : \u2102\nhs : 0 < s.re\naux1 : -1 < (s - 1).re\naux2 : s \u2260 0\naux3 : MeasurableSet (Ioc 0 1)\n\u22a2 \u222b (a : \u211d) in Ioc 0 1, \u2191a ^ (s - 1) \u2202volume = 1 / s"}, {"line": "rw [\u2190 intervalIntegral.integral_of_le zero_le_one]", "tactic_state": "s : \u2102\nhs : 0 < s.re\naux1 : -1 < (s - 1).re\naux2 : s \u2260 0\naux3 : MeasurableSet (Ioc 0 1)\n\u22a2 \u222b (x : \u211d) in 0 ..1, \u2191x ^ (s - 1) = 1 / s"}, {"line": "rw [integral_cpow (Or.inl aux1)]", "tactic_state": "s : \u2102\nhs : 0 < s.re\naux1 : -1 < (s - 1).re\naux2 : s \u2260 0\naux3 : MeasurableSet (Ioc 0 1)\n\u22a2 (\u21911 ^ (s - 1 + 1) - \u21910 ^ (s - 1 + 1)) / (s - 1 + 1) = 1 / s"}, {"line": "rw [sub_add_cancel]", "tactic_state": "s : \u2102\nhs : 0 < s.re\naux1 : -1 < (s - 1).re\naux2 : s \u2260 0\naux3 : MeasurableSet (Ioc 0 1)\n\u22a2 (\u21911 ^ s - \u21910 ^ s) / s = 1 / s"}, {"line": "rw [ofReal_zero]", "tactic_state": "s : \u2102\nhs : 0 < s.re\naux1 : -1 < (s - 1).re\naux2 : s \u2260 0\naux3 : MeasurableSet (Ioc 0 1)\n\u22a2 (\u21911 ^ s - 0 ^ s) / s = 1 / s"}, {"line": "rw [ofReal_one]", "tactic_state": "s : \u2102\nhs : 0 < s.re\naux1 : -1 < (s - 1).re\naux2 : s \u2260 0\naux3 : MeasurableSet (Ioc 0 1)\n\u22a2 (1 ^ s - 0 ^ s) / s = 1 / s"}, {"line": "rw [one_cpow]", "tactic_state": "s : \u2102\nhs : 0 < s.re\naux1 : -1 < (s - 1).re\naux2 : s \u2260 0\naux3 : MeasurableSet (Ioc 0 1)\n\u22a2 (1 - 0 ^ s) / s = 1 / s"}, {"line": "rw [zero_cpow aux2]", "tactic_state": "s : \u2102\nhs : 0 < s.re\naux1 : -1 < (s - 1).re\naux2 : s \u2260 0\naux3 : MeasurableSet (Ioc 0 1)\n\u22a2 (1 - 0) / s = 1 / s"}, {"line": "rw [sub_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasMellin_cpow_Ioc (a : \u2102) {s : \u2102} (hs : 0 < re s + re a) :\n    HasMellin (indicator (Ioc 0 1) (fun t => \u2191t ^ a : \u211d \u2192 \u2102)) s (1 / (s + a)) := by\n  have := hasMellin_one_Ioc (by rwa [add_re] : 0 < (s + a).re)\n  simp_rw [HasMellin, \u2190 MellinConvergent.cpow_smul, \u2190 mellin_cpow_smul, \u2190 indicator_smul,\n    smul_eq_mul, mul_one] at this\n  exact this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/MellinTransform.lean", "context": {"open": ["MeasureTheory Set Filter Asymptotics TopologicalSpace", "Real", "Complex hiding exp log abs_of_nonneg", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "{E : Type*} [NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a s : \u2102\nhs : 0 < s.re + a.re\n\u22a2 HasMellin ((Ioc 0 1).indicator fun t => \u2191t ^ a) s (1 / (s + a))"}, {"line": "have := hasMellin_one_Ioc (by rwa [add_re] : 0 < (s + a).re)", "tactic_state": "a s : \u2102\nhs : 0 < s.re + a.re\nthis : HasMellin ((Ioc 0 1).indicator fun x => 1) (s + a) (1 / (s + a))\n\u22a2 HasMellin ((Ioc 0 1).indicator fun t => \u2191t ^ a) s (1 / (s + a))"}, {"line": "simp_rw [HasMellin, \u2190 MellinConvergent.cpow_smul, \u2190 mellin_cpow_smul, \u2190 indicator_smul,\n    smul_eq_mul, mul_one] at this", "tactic_state": "a s : \u2102\nhs : 0 < s.re + a.re\nthis :\n  MellinConvergent ((Ioc 0 1).indicator fun a_1 => \u2191a_1 ^ a) s \u2227\n    mellin ((Ioc 0 1).indicator fun a_1 => \u2191a_1 ^ a) s = 1 / (s + a)\n\u22a2 HasMellin ((Ioc 0 1).indicator fun t => \u2191t ^ a) s (1 / (s + a))"}, {"line": "exact this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oscillationWithin_nhd_eq_oscillation [TopologicalSpace E] (f : E \u2192 F) (D : Set E) (x : E)\n    (hD : D \u2208 \ud835\udcdd x) : oscillationWithin f D x = oscillation f x := by\n  rw [oscillation]\n  rw [oscillationWithin]\n  rw [nhdsWithin_eq_nhds.2 hD]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Oscillation.lean", "context": {"open": ["Topology EMetric Set ENNReal"], "variables": ["{E : Type u} {F : Type v} [PseudoEMetricSpace F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u\nF : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace F\ninst\u271d : TopologicalSpace E\nf : E \u2192 F\nD : Set E\nx : E\nhD : D \u2208 nhds x\n\u22a2 oscillationWithin f D x = oscillation f x"}, {"line": "rw [oscillation]", "tactic_state": "E : Type u\nF : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace F\ninst\u271d : TopologicalSpace E\nf : E \u2192 F\nD : Set E\nx : E\nhD : D \u2208 nhds x\n\u22a2 oscillationWithin f D x = \u2a05 S \u2208 Filter.map f (nhds x), diam S"}, {"line": "rw [oscillationWithin]", "tactic_state": "E : Type u\nF : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace F\ninst\u271d : TopologicalSpace E\nf : E \u2192 F\nD : Set E\nx : E\nhD : D \u2208 nhds x\n\u22a2 \u2a05 S \u2208 Filter.map f (nhdsWithin x D), diam S = \u2a05 S \u2208 Filter.map f (nhds x), diam S"}, {"line": "rw [nhdsWithin_eq_nhds.2 hD]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniform_oscillationWithin (comp : IsCompact K) (hK : \u2200 x \u2208 K, oscillationWithin f D x < \u03b5) :\n    \u2203 \u03b4 > 0, \u2200 x \u2208 K, diam (f '' (ball x (ENNReal.ofReal \u03b4) \u2229 D)) \u2264 \u03b5 := by\n  let S := fun r \u21a6 { x : E | \u2203 (a : \u211d), (a > r \u2227 diam (f '' (ball x (ENNReal.ofReal a) \u2229 D)) \u2264 \u03b5) }\n  have S_open : \u2200 r > 0, IsOpen (S r) := by\n    refine fun r _ \u21a6 isOpen_iff.mpr fun x \u27e8a, ar, ha\u27e9 \u21a6\n      \u27e8ENNReal.ofReal ((a - r) / 2), by simp [ar], ?_\u27e9\n    refine fun y hy \u21a6 \u27e8a - (a - r) / 2, by linarith,\n      le_trans (diam_mono (image_mono fun z hz \u21a6 ?_)) ha\u27e9\n    refine \u27e8lt_of_le_of_lt (edist_triangle z y x) (lt_of_lt_of_eq (ENNReal.add_lt_add hz.1 hy) ?_),\n      hz.2\u27e9\n    rw [\u2190 ofReal_add (by linarith) (by linarith)]\n    rw [sub_add_cancel]\n  have S_cover : K \u2286 \u22c3 r > 0, S r := by\n    intro x hx\n    have : oscillationWithin f D x < \u03b5 := hK x hx\n    simp only [oscillationWithin] at this\n    simp only [Filter.mem_map] at this\n    simp only [iInf_lt_iff] at this\n    obtain \u27e8n, hn\u2081, hn\u2082\u27e9 := this\n    obtain \u27e8r, r0, hr\u27e9 := mem_nhdsWithin_iff.1 hn\u2081\n    simp only [gt_iff_lt]\n    simp only [mem_iUnion]\n    simp only [exists_prop]\n    have : \u2200 r', (ENNReal.ofReal r') \u2264 r \u2192 diam (f '' (ball x (ENNReal.ofReal r') \u2229 D)) \u2264 \u03b5 := by\n      intro r' hr'\n      refine le_trans (diam_mono (subset_trans ?_ (image_subset_iff.2 hr))) (le_of_lt hn\u2082)\n      exact image_mono (inter_subset_inter_left D (ball_subset_ball hr'))\n    by_cases r_top : r = \u22a4\n    \u00b7 use 1, one_pos, 2, one_lt_two, this 2 (by simp only [r_top, le_top])\n    \u00b7 obtain \u27e8r', hr'\u27e9 := exists_between (toReal_pos (ne_of_gt r0) r_top)\n      use r', hr'.1, r.toReal, hr'.2, this r.toReal ofReal_toReal_le\n  have S_antitone : \u2200 (r\u2081 r\u2082 : \u211d), r\u2081 \u2264 r\u2082 \u2192 S r\u2082 \u2286 S r\u2081 :=\n    fun r\u2081 r\u2082 hr x \u27e8a, ar\u2082, ha\u27e9 \u21a6 \u27e8a, lt_of_le_of_lt hr ar\u2082, ha\u27e9\n  obtain \u27e8\u03b4, \u03b40, h\u03b4\u27e9 : \u2203 r > 0, K \u2286 S r := by\n    obtain \u27e8T, Tb, Tfin, hT\u27e9 := comp.elim_finite_subcover_image S_open S_cover\n    by_cases T_nonempty : T.Nonempty\n    \u00b7 use Tfin.isWF.min T_nonempty, Tb (Tfin.isWF.min_mem T_nonempty)\n      intro x hx\n      obtain \u27e8r, hr\u27e9 := mem_iUnion.1 (hT hx)\n      simp only [mem_iUnion] at hr\n      simp only [exists_prop] at hr\n      exact (S_antitone _ r (IsWF.min_le Tfin.isWF T_nonempty hr.1)) hr.2\n    \u00b7 rw [not_nonempty_iff_eq_empty] at T_nonempty\n      use 1, one_pos, subset_trans hT (by simp [T_nonempty])\n  use \u03b4, \u03b40\n  intro x xK\n  obtain \u27e8a, \u03b4a, ha\u27e9 := h\u03b4 xK\n  exact (diam_mono <| image_mono <| inter_subset_inter_left D <| ball_subset_ball <|\n    coe_le_coe.2 <| Real.toNNReal_mono (le_of_lt \u03b4a)).trans ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Oscillation.lean", "context": {"open": ["Topology EMetric Set ENNReal"], "variables": ["{E : Type u} {F : Type v} [PseudoEMetricSpace F]", "[PseudoEMetricSpace E] {K : Set E}", "{f : E \u2192 F} {D : Set E} {\u03b5 : ENNReal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u\nF : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace F\ninst\u271d : PseudoEMetricSpace E\nK : Set E\nf : E \u2192 F\nD : Set E\n\u03b5 : ENNReal\ncomp : IsCompact K\nhK : \u2200 x \u2208 K, oscillationWithin f D x < \u03b5\n\u22a2 \u2203 \u03b4 > 0, \u2200 x \u2208 K, diam (f '' (ball x (ENNReal.ofReal \u03b4) \u2229 D)) \u2264 \u03b5"}, {"line": "let S := fun r \u21a6 { x : E | \u2203 (a : \u211d), (a > r \u2227 diam (f '' (ball x (ENNReal.ofReal a) \u2229 D)) \u2264 \u03b5) }", "tactic_state": "E : Type u\nF : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace F\ninst\u271d : PseudoEMetricSpace E\nK : Set E\nf : E \u2192 F\nD : Set E\n\u03b5 : ENNReal\ncomp : IsCompact K\nhK : \u2200 x \u2208 K, oscillationWithin f D x < \u03b5\nS : \u211d \u2192 Set E := fun r => {x | \u2203 a > r, sorry \u2264 \u03b5}\n\u22a2 \u2203 \u03b4 > 0, \u2200 x \u2208 K, diam (f '' (ball x (ENNReal.ofReal \u03b4) \u2229 D)) \u2264 \u03b5"}, {"line": "have S_open : \u2200 r > 0, IsOpen (S r) := sorry", "tactic_state": "E : Type u\nF : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace F\ninst\u271d : PseudoEMetricSpace E\nK : Set E\nf : E \u2192 F\nD : Set E\n\u03b5 : ENNReal\ncomp : IsCompact K\nhK : \u2200 x \u2208 K, oscillationWithin f D x < \u03b5\nS : \u211d \u2192 Set E := fun r => {x | \u2203 a > r, sorry \u2264 \u03b5}\nS_open : \u2200 r > 0, sorry\n\u22a2 \u2203 \u03b4 > 0, \u2200 x \u2208 K, diam (f '' (ball x (ENNReal.ofReal \u03b4) \u2229 D)) \u2264 \u03b5"}, {"line": "have S_cover : K \u2286 \u22c3 r > 0, S r := sorry", "tactic_state": "E : Type u\nF : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace F\ninst\u271d : PseudoEMetricSpace E\nK : Set E\nf : E \u2192 F\nD : Set E\n\u03b5 : ENNReal\ncomp : IsCompact K\nhK : \u2200 x \u2208 K, oscillationWithin f D x < \u03b5\nS : \u211d \u2192 Set E := fun r => {x | \u2203 a > r, sorry \u2264 \u03b5}\nS_open : \u2200 r > 0, sorry\nS_cover : K \u2286 \u22c3 r, \u22c3 (_ : r > 0), S r\n\u22a2 \u2203 \u03b4 > 0, \u2200 x \u2208 K, diam (f '' (ball x (ENNReal.ofReal \u03b4) \u2229 D)) \u2264 \u03b5"}, {"line": "have S_antitone : \u2200 (r\u2081 r\u2082 : \u211d), r\u2081 \u2264 r\u2082 \u2192 S r\u2082 \u2286 S r\u2081 :=\n    fun r\u2081 r\u2082 hr x \u27e8a, ar\u2082, ha\u27e9 \u21a6 \u27e8a, lt_of_le_of_lt hr ar\u2082, ha\u27e9", "tactic_state": "E : Type u\nF : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace F\ninst\u271d : PseudoEMetricSpace E\nK : Set E\nf : E \u2192 F\nD : Set E\n\u03b5 : ENNReal\ncomp : IsCompact K\nhK : \u2200 x \u2208 K, oscillationWithin f D x < \u03b5\nS : \u211d \u2192 Set E := fun r => {x | \u2203 a > r, sorry \u2264 \u03b5}\nS_open : \u2200 r > 0, sorry\nS_cover : K \u2286 \u22c3 r, \u22c3 (_ : r > 0), S r\nS_antitone : \u2200 (r\u2081 r\u2082 : \u211d), r\u2081 \u2264 r\u2082 \u2192 S r\u2082 \u2286 S r\u2081\n\u22a2 \u2203 \u03b4 > 0, \u2200 x \u2208 K, diam (f '' (ball x (ENNReal.ofReal \u03b4) \u2229 D)) \u2264 \u03b5"}, {"line": "obtain \u27e8\u03b4, \u03b40, h\u03b4\u27e9 : \u2203 r > 0, K \u2286 S r := by\n    obtain \u27e8T, Tb, Tfin, hT\u27e9 := comp.elim_finite_subcover_image S_open S_cover\n    by_cases T_nonempty : T.Nonempty\n    \u00b7 use Tfin.isWF.min T_nonempty, Tb (Tfin.isWF.min_mem T_nonempty)\n      intro x hx\n      obtain \u27e8r, hr\u27e9 := mem_iUnion.1 (hT hx)\n      simp only [mem_iUnion] at hr\n      simp only [exists_prop] at hr\n      exact (S_antitone _ r (IsWF.min_le Tfin.isWF T_nonempty hr.1)) hr.2\n    \u00b7 rw [not_nonempty_iff_eq_empty] at T_nonempty\n      use 1, one_pos, subset_trans hT (by simp [T_nonempty])", "tactic_state": "case intro.intro\nE : Type u\nF : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace F\ninst\u271d : PseudoEMetricSpace E\nK : Set E\nf : E \u2192 F\nD : Set E\n\u03b5 : ENNReal\ncomp : IsCompact K\nhK : \u2200 x \u2208 K, oscillationWithin f D x < \u03b5\nS : \u211d \u2192 Set E := fun r => {x | \u2203 a > r, sorry \u2264 \u03b5}\nS_open : \u2200 r > 0, sorry\nS_cover : K \u2286 \u22c3 r, \u22c3 (_ : r > 0), S r\nS_antitone : \u2200 (r\u2081 r\u2082 : \u211d), r\u2081 \u2264 r\u2082 \u2192 S r\u2082 \u2286 S r\u2081\n\u03b4 : \u211d\n\u03b40 : \u03b4 > 0\nh\u03b4 : K \u2286 S \u03b4\n\u22a2 \u2203 \u03b4 > 0, \u2200 x \u2208 K, diam (f '' (ball x (ENNReal.ofReal \u03b4) \u2229 D)) \u2264 \u03b5"}, {"line": "use \u03b4, \u03b40", "tactic_state": "case right\nE : Type u\nF : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace F\ninst\u271d : PseudoEMetricSpace E\nK : Set E\nf : E \u2192 F\nD : Set E\n\u03b5 : ENNReal\ncomp : IsCompact K\nhK : \u2200 x \u2208 K, oscillationWithin f D x < \u03b5\nS : \u211d \u2192 Set E := fun r => {x | \u2203 a > r, sorry \u2264 \u03b5}\nS_open : \u2200 r > 0, sorry\nS_cover : K \u2286 \u22c3 r, \u22c3 (_ : r > 0), S r\nS_antitone : \u2200 (r\u2081 r\u2082 : \u211d), r\u2081 \u2264 r\u2082 \u2192 S r\u2082 \u2286 S r\u2081\n\u03b4 : \u211d\n\u03b40 : \u03b4 > 0\nh\u03b4 : K \u2286 S \u03b4\n\u22a2 \u2200 x \u2208 K, diam (f '' (ball x (ENNReal.ofReal \u03b4) \u2229 D)) \u2264 \u03b5"}, {"line": "intro x xK", "tactic_state": "case right\nE : Type u\nF : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace F\ninst\u271d : PseudoEMetricSpace E\nK : Set E\nf : E \u2192 F\nD : Set E\n\u03b5 : ENNReal\ncomp : IsCompact K\nhK : \u2200 x \u2208 K, oscillationWithin f D x < \u03b5\nS : \u211d \u2192 Set E := fun r => {x | \u2203 a > r, sorry \u2264 \u03b5}\nS_open : \u2200 r > 0, sorry\nS_cover : K \u2286 \u22c3 r, \u22c3 (_ : r > 0), S r\nS_antitone : \u2200 (r\u2081 r\u2082 : \u211d), r\u2081 \u2264 r\u2082 \u2192 S r\u2082 \u2286 S r\u2081\n\u03b4 : \u211d\n\u03b40 : \u03b4 > 0\nh\u03b4 : K \u2286 S \u03b4\nx : E\nxK : x \u2208 K\n\u22a2 diam (f '' (ball x (ENNReal.ofReal \u03b4) \u2229 D)) \u2264 \u03b5"}, {"line": "obtain \u27e8a, \u03b4a, ha\u27e9 := h\u03b4 xK", "tactic_state": "case right.intro.intro\nE : Type u\nF : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace F\ninst\u271d : PseudoEMetricSpace E\nK : Set E\nf : E \u2192 F\nD : Set E\n\u03b5 : ENNReal\ncomp : IsCompact K\nhK : \u2200 x \u2208 K, oscillationWithin f D x < \u03b5\nS : \u211d \u2192 Set E := fun r => {x | \u2203 a > r, sorry \u2264 \u03b5}\nS_open : \u2200 r > 0, sorry\nS_cover : K \u2286 \u22c3 r, \u22c3 (_ : r > 0), S r\nS_antitone : \u2200 (r\u2081 r\u2082 : \u211d), r\u2081 \u2264 r\u2082 \u2192 S r\u2082 \u2286 S r\u2081\n\u03b4 : \u211d\n\u03b40 : \u03b4 > 0\nh\u03b4 : K \u2286 S \u03b4\nx : E\nxK : x \u2208 K\na : \u211d\n\u03b4a : a > \u03b4\nha : sorry \u2264 \u03b5\n\u22a2 diam (f '' (ball x (ENNReal.ofReal \u03b4) \u2229 D)) \u2264 \u03b5"}, {"line": "exact (diam_mono <| image_mono <| inter_subset_inter_left D <| ball_subset_ball <|\n    coe_le_coe.2 <| Real.toNNReal_mono (le_of_lt \u03b4a)).trans ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniform_oscillation {K : Set E} (comp : IsCompact K)\n    {f : E \u2192 F} {\u03b5 : ENNReal} (hK : \u2200 x \u2208 K, oscillation f x < \u03b5) :\n    \u2203 \u03b4 > 0, \u2200 x \u2208 K, diam (f '' (ball x (ENNReal.ofReal \u03b4))) \u2264 \u03b5 := by\n  simp only [\u2190 oscillationWithin_univ_eq_oscillation] at hK\n  convert \u2190 comp.uniform_oscillationWithin hK\n  exact inter_univ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Oscillation.lean", "context": {"open": ["Topology EMetric Set ENNReal"], "variables": ["{E : Type u} {F : Type v} [PseudoEMetricSpace F]", "[PseudoEMetricSpace E] {K : Set E}", "{f : E \u2192 F} {D : Set E} {\u03b5 : ENNReal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u\nF : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace F\ninst\u271d : PseudoEMetricSpace E\nK : Set E\ncomp : IsCompact K\nf : E \u2192 F\n\u03b5 : ENNReal\nhK : \u2200 x \u2208 K, oscillation f x < \u03b5\n\u22a2 \u2203 \u03b4 > 0, \u2200 x \u2208 K, diam (f '' ball x (ENNReal.ofReal \u03b4)) \u2264 \u03b5"}, {"line": "simp only [\u2190 oscillationWithin_univ_eq_oscillation] at hK", "tactic_state": "E : Type u\nF : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace F\ninst\u271d : PseudoEMetricSpace E\nK : Set E\ncomp : IsCompact K\nf : E \u2192 F\n\u03b5 : ENNReal\nhK : \u2200 x \u2208 K, oscillationWithin f univ x < \u03b5\n\u22a2 \u2203 \u03b4 > 0, \u2200 x \u2208 K, diam (f '' ball x (ENNReal.ofReal \u03b4)) \u2264 \u03b5"}, {"line": "convert \u2190 comp.uniform_oscillationWithin hK", "tactic_state": "case h.e'_2.h.h.e'_2.h.h'.h.e'_3.h.e'_3.h.e'_4\nE : Type u\nF : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace F\ninst\u271d : PseudoEMetricSpace E\nK : Set E\ncomp : IsCompact K\nf : E \u2192 F\n\u03b5 : ENNReal\nhK : \u2200 x \u2208 K, oscillationWithin f univ x < \u03b5\nx\u271d : \u211d\na\u271d\u00b9 : E\na\u271d : a\u271d\u00b9 \u2208 K\n\u22a2 ball a\u271d\u00b9 (ENNReal.ofReal x\u271d) \u2229 univ = ball a\u271d\u00b9 (ENNReal.ofReal x\u271d)"}, {"line": "exact inter_univ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem summable_condensed_iff_of_nonneg {f : \u2115 \u2192 \u211d} (h_nonneg : \u2200 n, 0 \u2264 f n)\n    (h_mono : \u2200 \u2983m n\u2984, 0 < m \u2192 m \u2264 n \u2192 f n \u2264 f m) :\n    (Summable fun k : \u2115 => (2 : \u211d) ^ k * f (2 ^ k)) \u2194 Summable f := by\n  have h_succ_diff : SuccDiffBounded 2 (2 ^ \u00b7) := by\n    intro n\n    simp [pow_succ, mul_two, two_mul]\n  convert summable_schlomilch_iff_of_nonneg h_nonneg h_mono (pow_pos zero_lt_two)\n    (pow_right_strictMono\u2080 one_lt_two) two_ne_zero h_succ_diff\n  simp [pow_succ, mul_two, two_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/PSeries.lean", "context": {"open": ["Filter Finset", "NNReal in", "Finset", "ENNReal in", "ENNReal in", "NNReal in"], "variables": ["{M : Type*} [AddCommMonoid M] [PartialOrder M] [IsOrderedAddMonoid M]", "{u : \u2115 \u2192 \u2115} {f : \u2115 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u211d\nh_nonneg : \u2200 (n : \u2115), 0 \u2264 f n\nh_mono : \u2200 \u2983m n : \u2115\u2984, 0 < m \u2192 m \u2264 n \u2192 f n \u2264 f m\n\u22a2 (Summable fun k => 2 ^ k * f (2 ^ k)) \u2194 Summable f"}, {"line": "have h_succ_diff : SuccDiffBounded 2 (2 ^ \u00b7) := sorry", "tactic_state": "f : \u2115 \u2192 \u211d\nh_nonneg : \u2200 (n : \u2115), 0 \u2264 f n\nh_mono : \u2200 \u2983m n : \u2115\u2984, 0 < m \u2192 m \u2264 n \u2192 f n \u2264 f m\nh_succ_diff : SuccDiffBounded 2 fun x => 2 ^ x\n\u22a2 (Summable fun k => 2 ^ k * f (2 ^ k)) \u2194 Summable f"}, {"line": "convert summable_schlomilch_iff_of_nonneg h_nonneg h_mono (pow_pos zero_lt_two)\n    (pow_right_strictMono\u2080 one_lt_two) two_ne_zero h_succ_diff", "tactic_state": "case h.e'_1.h.e'_5.h.h.e'_5\nf : \u2115 \u2192 \u211d\nh_nonneg : \u2200 (n : \u2115), 0 \u2264 f n\nh_mono : \u2200 \u2983m n : \u2115\u2984, 0 < m \u2192 m \u2264 n \u2192 f n \u2264 f m\nh_succ_diff : SuccDiffBounded 2 fun x => 2 ^ x\nx\u271d : \u2115\n\u22a2 2 ^ x\u271d = \u2191(2 ^ (x\u271d + 1)) - \u2191(2 ^ x\u271d)"}, {"line": "simp [pow_succ, mul_two, two_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem summable_nat_rpow {p : \u211d} : Summable (fun n => (n : \u211d) ^ p : \u2115 \u2192 \u211d) \u2194 p < -1 := by\n  rcases neg_surjective p with \u27e8p, rfl\u27e9\n  simp [rpow_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/PSeries.lean", "context": {"open": ["Filter Finset", "NNReal in", "Finset", "ENNReal in", "ENNReal in", "NNReal in", "Filter"], "variables": ["{M : Type*} [AddCommMonoid M] [PartialOrder M] [IsOrderedAddMonoid M]", "{u : \u2115 \u2192 \u2115} {f : \u2115 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\n\u22a2 (Summable fun n => \u2191n ^ p) \u2194 p < -1"}, {"line": "rcases neg_surjective p with \u27e8p, rfl\u27e9", "tactic_state": "case intro\np : \u211d\n\u22a2 (Summable fun n => \u2191n ^ (-p)) \u2194 -p < -1"}, {"line": "simp [rpow_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem summable_one_div_nat_rpow {p : \u211d} :\n    Summable (fun n => 1 / (n : \u211d) ^ p : \u2115 \u2192 \u211d) \u2194 1 < p := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/PSeries.lean", "context": {"open": ["Filter Finset", "NNReal in", "Finset", "ENNReal in", "ENNReal in", "NNReal in", "Filter"], "variables": ["{M : Type*} [AddCommMonoid M] [PartialOrder M] [IsOrderedAddMonoid M]", "{u : \u2115 \u2192 \u2115} {f : \u2115 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\n\u22a2 (Summable fun n => 1 / \u2191n ^ p) \u2194 1 < p"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem summable_one_div_nat_pow {p : \u2115} :\n    Summable (fun n => 1 / (n : \u211d) ^ p : \u2115 \u2192 \u211d) \u2194 1 < p := by\n  simp only [one_div]\n  simp only [Real.summable_nat_pow_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/PSeries.lean", "context": {"open": ["Filter Finset", "NNReal in", "Finset", "ENNReal in", "ENNReal in", "NNReal in", "Filter"], "variables": ["{M : Type*} [AddCommMonoid M] [PartialOrder M] [IsOrderedAddMonoid M]", "{u : \u2115 \u2192 \u2115} {f : \u2115 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\n\u22a2 (Summable fun n => 1 / \u2191n ^ p) \u2194 1 < p"}, {"line": "simp only [one_div]", "tactic_state": "p : \u2115\n\u22a2 (Summable fun n => (\u2191n ^ p)\u207b\u00b9) \u2194 1 < p"}, {"line": "simp only [Real.summable_nat_pow_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_summable_natCast_inv : \u00acSummable (fun n => n\u207b\u00b9 : \u2115 \u2192 \u211d) := by\n  have : \u00acSummable (fun n => ((n : \u211d) ^ 1)\u207b\u00b9 : \u2115 \u2192 \u211d) :=\n    mt (summable_nat_pow_inv (p := 1)).1 (lt_irrefl 1)\n  simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/PSeries.lean", "context": {"open": ["Filter Finset", "NNReal in", "Finset", "ENNReal in", "ENNReal in", "NNReal in", "Filter"], "variables": ["{M : Type*} [AddCommMonoid M] [PartialOrder M] [IsOrderedAddMonoid M]", "{u : \u2115 \u2192 \u2115} {f : \u2115 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00acSummable fun n => (\u2191n)\u207b\u00b9"}, {"line": "have : \u00acSummable (fun n => ((n : \u211d) ^ 1)\u207b\u00b9 : \u2115 \u2192 \u211d) :=\n    mt (summable_nat_pow_inv (p := 1)).1 (lt_irrefl 1)", "tactic_state": "this : \u00acSummable fun n => (\u2191n ^ 1)\u207b\u00b9\n\u22a2 \u00acSummable fun n => (\u2191n)\u207b\u00b9"}, {"line": "simpa", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_summable_one_div_natCast : \u00acSummable (fun n => 1 / n : \u2115 \u2192 \u211d) := by\n  simpa only [inv_eq_one_div] using not_summable_natCast_inv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/PSeries.lean", "context": {"open": ["Filter Finset", "NNReal in", "Finset", "ENNReal in", "ENNReal in", "NNReal in", "Filter"], "variables": ["{M : Type*} [AddCommMonoid M] [PartialOrder M] [IsOrderedAddMonoid M]", "{u : \u2115 \u2192 \u2115} {f : \u2115 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00acSummable fun n => 1 / \u2191n"}, {"line": "simpa only [inv_eq_one_div] using not_summable_natCast_inv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem summable_rpow_inv {p : \u211d} :\n    Summable (fun n => ((n : \u211d\u22650) ^ p)\u207b\u00b9 : \u2115 \u2192 \u211d\u22650) \u2194 1 < p := by\n  simp [\u2190 NNReal.summable_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/PSeries.lean", "context": {"open": ["Filter Finset", "NNReal in", "Finset", "ENNReal in", "ENNReal in", "NNReal in", "Filter"], "variables": ["{M : Type*} [AddCommMonoid M] [PartialOrder M] [IsOrderedAddMonoid M]", "{u : \u2115 \u2192 \u2115} {f : \u2115 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\n\u22a2 sorry \u2194 1 < p"}, {"line": "simp [\u2190 NNReal.summable_coe]", "tactic_state": "p : \u211d\n\u22a2 sorry () \u2194 1 < p"}]}
{"declaration": "theorem summable_rpow {p : \u211d} : Summable (fun n => (n : \u211d\u22650) ^ p : \u2115 \u2192 \u211d\u22650) \u2194 p < -1 := by\n  simp [\u2190 NNReal.summable_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/PSeries.lean", "context": {"open": ["Filter Finset", "NNReal in", "Finset", "ENNReal in", "ENNReal in", "NNReal in", "Filter"], "variables": ["{M : Type*} [AddCommMonoid M] [PartialOrder M] [IsOrderedAddMonoid M]", "{u : \u2115 \u2192 \u2115} {f : \u2115 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\n\u22a2 sorry \u2194 p < -1"}, {"line": "simp [\u2190 NNReal.summable_coe]", "tactic_state": "p : \u211d\n\u22a2 sorry () \u2194 p < -1"}]}
{"declaration": "theorem summable_one_div_rpow {p : \u211d} :\n    Summable (fun n => 1 / (n : \u211d\u22650) ^ p : \u2115 \u2192 \u211d\u22650) \u2194 1 < p := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/PSeries.lean", "context": {"open": ["Filter Finset", "NNReal in", "Finset", "ENNReal in", "ENNReal in", "NNReal in", "Filter"], "variables": ["{M : Type*} [AddCommMonoid M] [PartialOrder M] [IsOrderedAddMonoid M]", "{u : \u2115 \u2192 \u2115} {f : \u2115 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\n\u22a2 sorry \u2194 1 < p"}, {"line": "simp", "tactic_state": "p : \u211d\n\u22a2 sorry () \u2194 1 < p"}]}
{"declaration": "lemma Real.summable_one_div_int_add_rpow (a : \u211d) (s : \u211d) :\n    Summable (fun n : \u2124 \u21a6 1 / |n + a| ^ s) \u2194 1 < s := by\n  simp_rw [summable_int_iff_summable_nat_and_neg, \u2190 abs_neg (\u2191(-_ : \u2124) + a), neg_add,\n    Int.cast_neg, neg_neg, Int.cast_natCast, summable_one_div_nat_add_rpow, and_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/PSeries.lean", "context": {"open": ["Filter Finset", "NNReal in", "Finset", "ENNReal in", "ENNReal in", "NNReal in", "Filter", "Finset", "Set Nat in", "Filter Asymptotics Topology"], "variables": ["{M : Type*} [AddCommMonoid M] [PartialOrder M] [IsOrderedAddMonoid M]", "{u : \u2115 \u2192 \u2115} {f : \u2115 \u2192 \u211d\u22650\u221e}", "{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a s : \u211d\n\u22a2 (Summable fun n => 1 / |\u2191n + a| ^ s) \u2194 1 < s"}, {"line": "simp_rw [summable_int_iff_summable_nat_and_neg, \u2190 abs_neg (\u2191(-_ : \u2124) + a), neg_add,\n    Int.cast_neg, neg_neg, Int.cast_natCast, summable_one_div_nat_add_rpow, and_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_or_exists_apply_eq_finset_sup (p : \u03b9 \u2192 Seminorm \ud835\udd5c E) (s : Finset \u03b9) (x : E) :\n    s.sup p x = 0 \u2228 \u2203 i \u2208 s, s.sup p x = p i x := by\n  rcases Finset.eq_empty_or_nonempty s with (rfl|hs)\n  \u00b7 left; rfl\n  \u00b7 right; exact exists_apply_eq_finset_sup p hs x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Seminorm.lean", "context": {"open": ["NormedField Set Filter", "scoped NNReal Pointwise Topology Uniformity"], "variables": ["{R R' \ud835\udd5c \ud835\udd5c\u2082 \ud835\udd5c\u2083 \ud835\udd5d E E\u2082 E\u2083 F \u03b9 : Type*}", "[SeminormedRing \ud835\udd5c]", "[AddGroup E]", "[SMul \ud835\udd5c E]", "(p : Seminorm \ud835\udd5c E) (x : E) (r : \u211d)", "(\ud835\udd5c E)", "{\ud835\udd5c E}", "[SeminormedRing \ud835\udd5c\u2082] [SeminormedRing \ud835\udd5c\u2083]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "{\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083} [RingHomIsometric \u03c3\u2082\u2083]", "{\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083} [RingHomIsometric \u03c3\u2081\u2083]", "[AddCommGroup E] [AddCommGroup E\u2082] [AddCommGroup E\u2083]", "[Module \ud835\udd5c E] [Module \ud835\udd5c\u2082 E\u2082] [Module \ud835\udd5c\u2083 E\u2083]", "[SMul R \u211d] [SMul R \u211d\u22650] [IsScalarTower R \u211d\u22650 \u211d]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_3\nE : Type u_7\n\u03b9 : Type u_11\ninst\u271d\u2074 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b3 : AddGroup E\ninst\u271d\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\ns : Finset \u03b9\nx : E\n\u22a2 sorry = 0 \u2228 \u2203 i \u2208 s, sorry = (p i) x"}, {"line": "rcases Finset.eq_empty_or_nonempty s with (rfl|hs)", "tactic_state": "case inl\n\ud835\udd5c : Type u_3\nE : Type u_7\n\u03b9 : Type u_11\ninst\u271d\u2074 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b3 : AddGroup E\ninst\u271d\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nx : E\n\u22a2 sorry = 0 \u2228 \u2203 i \u2208 \u2205, sorry = (p i) x\n---\ncase inr\n\ud835\udd5c : Type u_3\nE : Type u_7\n\u03b9 : Type u_11\ninst\u271d\u2074 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b3 : AddGroup E\ninst\u271d\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\ns : Finset \u03b9\nx : E\nhs : s.Nonempty\n\u22a2 sorry = 0 \u2228 \u2203 i \u2208 s, sorry = (p i) x"}, {"line": "\u00b7 left; rfl", "tactic_state": "case inr\n\ud835\udd5c : Type u_3\nE : Type u_7\n\u03b9 : Type u_11\ninst\u271d\u2074 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b3 : AddGroup E\ninst\u271d\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\ns : Finset \u03b9\nx : E\nhs : s.Nonempty\n\u22a2 sorry = 0 \u2228 \u2203 i \u2208 s, sorry = (p i) x"}, {"line": "\u00b7 right; exact exists_apply_eq_finset_sup p hs x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ball_eq_emptyset (p : Seminorm \ud835\udd5c E) {x : E} {r : \u211d} (hr : r \u2264 0) : p.ball x r = \u2205 := by\n  ext\n  rw [Seminorm.mem_ball]\n  rw [Set.mem_empty_iff_false]\n  rw [iff_false]\n  rw [not_lt]\n  exact hr.trans (apply_nonneg p _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Seminorm.lean", "context": {"open": ["NormedField Set Filter", "scoped NNReal Pointwise Topology Uniformity", "Classical in"], "variables": ["{R R' \ud835\udd5c \ud835\udd5c\u2082 \ud835\udd5c\u2083 \ud835\udd5d E E\u2082 E\u2083 F \u03b9 : Type*}", "[SeminormedRing \ud835\udd5c]", "[AddGroup E]", "[SMul \ud835\udd5c E]", "(p : Seminorm \ud835\udd5c E) (x : E) (r : \u211d)", "(\ud835\udd5c E)", "{\ud835\udd5c E}", "[SeminormedRing \ud835\udd5c\u2082] [SeminormedRing \ud835\udd5c\u2083]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "{\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083} [RingHomIsometric \u03c3\u2082\u2083]", "{\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083} [RingHomIsometric \u03c3\u2081\u2083]", "[AddCommGroup E] [AddCommGroup E\u2082] [AddCommGroup E\u2083]", "[Module \ud835\udd5c E] [Module \ud835\udd5c\u2082 E\u2082] [Module \ud835\udd5c\u2083 E\u2083]", "[SMul R \u211d] [SMul R \u211d\u22650] [IsScalarTower R \u211d\u22650 \u211d]", "[SeminormedRing \ud835\udd5c] [SeminormedCommRing \ud835\udd5c\u2082]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "[AddCommGroup E] [AddCommGroup E\u2082] [Module \ud835\udd5c E] [Module \ud835\udd5c\u2082 E\u2082]", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {p q : Seminorm \ud835\udd5c E} {x : E}", "[SeminormedRing \ud835\udd5c]", "[AddCommGroup E]", "[SMul \ud835\udd5c E] (p : Seminorm \ud835\udd5c E)", "{x y : E} {r : \u211d}", "[Module \ud835\udd5c E]", "[SeminormedRing \ud835\udd5c\u2082] [AddCommGroup E\u2082] [Module \ud835\udd5c\u2082 E\u2082]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "(p : Seminorm \ud835\udd5c E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : SeminormedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nx : E\nr : \u211d\nhr : r \u2264 0\n\u22a2 p.ball x r = \u2205"}, {"line": "ext", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : SeminormedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nx : E\nr : \u211d\nhr : r \u2264 0\nx\u271d : E\n\u22a2 x\u271d \u2208 p.ball x r \u2194 x\u271d \u2208 \u2205"}, {"line": "rw [Seminorm.mem_ball]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : SeminormedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nx : E\nr : \u211d\nhr : r \u2264 0\nx\u271d : E\n\u22a2 p (x\u271d - x) < r \u2194 x\u271d \u2208 \u2205"}, {"line": "rw [Set.mem_empty_iff_false]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : SeminormedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nx : E\nr : \u211d\nhr : r \u2264 0\nx\u271d : E\n\u22a2 p (x\u271d - x) < r \u2194 False"}, {"line": "rw [iff_false]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : SeminormedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nx : E\nr : \u211d\nhr : r \u2264 0\nx\u271d : E\n\u22a2 \u00acp (x\u271d - x) < r"}, {"line": "rw [not_lt]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : SeminormedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nx : E\nr : \u211d\nhr : r \u2264 0\nx\u271d : E\n\u22a2 r \u2264 p (x\u271d - x)"}, {"line": "exact hr.trans (apply_nonneg p _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closedBall_eq_emptyset (p : Seminorm \ud835\udd5c E) {x : E} {r : \u211d} (hr : r < 0) :\n    p.closedBall x r = \u2205 := by\n  ext\n  rw [Seminorm.mem_closedBall]\n  rw [Set.mem_empty_iff_false]\n  rw [iff_false]\n  rw [not_le]\n  exact hr.trans_le (apply_nonneg _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Seminorm.lean", "context": {"open": ["NormedField Set Filter", "scoped NNReal Pointwise Topology Uniformity", "Classical in"], "variables": ["{R R' \ud835\udd5c \ud835\udd5c\u2082 \ud835\udd5c\u2083 \ud835\udd5d E E\u2082 E\u2083 F \u03b9 : Type*}", "[SeminormedRing \ud835\udd5c]", "[AddGroup E]", "[SMul \ud835\udd5c E]", "(p : Seminorm \ud835\udd5c E) (x : E) (r : \u211d)", "(\ud835\udd5c E)", "{\ud835\udd5c E}", "[SeminormedRing \ud835\udd5c\u2082] [SeminormedRing \ud835\udd5c\u2083]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "{\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083} [RingHomIsometric \u03c3\u2082\u2083]", "{\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083} [RingHomIsometric \u03c3\u2081\u2083]", "[AddCommGroup E] [AddCommGroup E\u2082] [AddCommGroup E\u2083]", "[Module \ud835\udd5c E] [Module \ud835\udd5c\u2082 E\u2082] [Module \ud835\udd5c\u2083 E\u2083]", "[SMul R \u211d] [SMul R \u211d\u22650] [IsScalarTower R \u211d\u22650 \u211d]", "[SeminormedRing \ud835\udd5c] [SeminormedCommRing \ud835\udd5c\u2082]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "[AddCommGroup E] [AddCommGroup E\u2082] [Module \ud835\udd5c E] [Module \ud835\udd5c\u2082 E\u2082]", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {p q : Seminorm \ud835\udd5c E} {x : E}", "[SeminormedRing \ud835\udd5c]", "[AddCommGroup E]", "[SMul \ud835\udd5c E] (p : Seminorm \ud835\udd5c E)", "{x y : E} {r : \u211d}", "[Module \ud835\udd5c E]", "[SeminormedRing \ud835\udd5c\u2082] [AddCommGroup E\u2082] [Module \ud835\udd5c\u2082 E\u2082]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "(p : Seminorm \ud835\udd5c E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : SeminormedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nx : E\nr : \u211d\nhr : r < 0\n\u22a2 p.closedBall x r = \u2205"}, {"line": "ext", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : SeminormedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nx : E\nr : \u211d\nhr : r < 0\nx\u271d : E\n\u22a2 x\u271d \u2208 p.closedBall x r \u2194 x\u271d \u2208 \u2205"}, {"line": "rw [Seminorm.mem_closedBall]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : SeminormedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nx : E\nr : \u211d\nhr : r < 0\nx\u271d : E\n\u22a2 p (x\u271d - x) \u2264 r \u2194 x\u271d \u2208 \u2205"}, {"line": "rw [Set.mem_empty_iff_false]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : SeminormedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nx : E\nr : \u211d\nhr : r < 0\nx\u271d : E\n\u22a2 p (x\u271d - x) \u2264 r \u2194 False"}, {"line": "rw [iff_false]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : SeminormedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nx : E\nr : \u211d\nhr : r < 0\nx\u271d : E\n\u22a2 \u00acp (x\u271d - x) \u2264 r"}, {"line": "rw [not_le]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : SeminormedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nx : E\nr : \u211d\nhr : r < 0\nx\u271d : E\n\u22a2 r < p (x\u271d - x)"}, {"line": "exact hr.trans_le (apply_nonneg _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ball_smul_ball (p : Seminorm \ud835\udd5c E) (r\u2081 r\u2082 : \u211d) :\n    Metric.ball (0 : \ud835\udd5c) r\u2081 \u2022 p.ball 0 r\u2082 \u2286 p.ball 0 (r\u2081 * r\u2082) := by\n  rcases eq_or_ne r\u2082 0 with rfl | hr\u2082\n  \u00b7 simp\n  \u00b7 exact (smul_subset_smul_left (ball_subset_closedBall _ _ _)).trans\n      (ball_smul_closedBall _ _ hr\u2082)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Seminorm.lean", "context": {"open": ["NormedField Set Filter", "scoped NNReal Pointwise Topology Uniformity", "Classical in"], "variables": ["{R R' \ud835\udd5c \ud835\udd5c\u2082 \ud835\udd5c\u2083 \ud835\udd5d E E\u2082 E\u2083 F \u03b9 : Type*}", "[SeminormedRing \ud835\udd5c]", "[AddGroup E]", "[SMul \ud835\udd5c E]", "(p : Seminorm \ud835\udd5c E) (x : E) (r : \u211d)", "(\ud835\udd5c E)", "{\ud835\udd5c E}", "[SeminormedRing \ud835\udd5c\u2082] [SeminormedRing \ud835\udd5c\u2083]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "{\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083} [RingHomIsometric \u03c3\u2082\u2083]", "{\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083} [RingHomIsometric \u03c3\u2081\u2083]", "[AddCommGroup E] [AddCommGroup E\u2082] [AddCommGroup E\u2083]", "[Module \ud835\udd5c E] [Module \ud835\udd5c\u2082 E\u2082] [Module \ud835\udd5c\u2083 E\u2083]", "[SMul R \u211d] [SMul R \u211d\u22650] [IsScalarTower R \u211d\u22650 \u211d]", "[SeminormedRing \ud835\udd5c] [SeminormedCommRing \ud835\udd5c\u2082]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "[AddCommGroup E] [AddCommGroup E\u2082] [Module \ud835\udd5c E] [Module \ud835\udd5c\u2082 E\u2082]", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {p q : Seminorm \ud835\udd5c E} {x : E}", "[SeminormedRing \ud835\udd5c]", "[AddCommGroup E]", "[SMul \ud835\udd5c E] (p : Seminorm \ud835\udd5c E)", "{x y : E} {r : \u211d}", "[Module \ud835\udd5c E]", "[SeminormedRing \ud835\udd5c\u2082] [AddCommGroup E\u2082] [Module \ud835\udd5c\u2082 E\u2082]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "(p : Seminorm \ud835\udd5c E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : SeminormedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nr\u2081 r\u2082 : \u211d\n\u22a2 Metric.ball 0 r\u2081 \u2022 p.ball 0 r\u2082 \u2286 p.ball 0 (r\u2081 * r\u2082)"}, {"line": "rcases eq_or_ne r\u2082 0 with rfl | hr\u2082", "tactic_state": "case inl\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : SeminormedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nr\u2081 : \u211d\n\u22a2 Metric.ball 0 r\u2081 \u2022 p.ball 0 0 \u2286 p.ball 0 (r\u2081 * 0)\n---\ncase inr\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : SeminormedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nr\u2081 r\u2082 : \u211d\nhr\u2082 : r\u2082 \u2260 0\n\u22a2 Metric.ball 0 r\u2081 \u2022 p.ball 0 r\u2082 \u2286 p.ball 0 (r\u2081 * r\u2082)"}, {"line": "\u00b7 simp", "tactic_state": "case inr\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : SeminormedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nr\u2081 r\u2082 : \u211d\nhr\u2082 : r\u2082 \u2260 0\n\u22a2 Metric.ball 0 r\u2081 \u2022 p.ball 0 r\u2082 \u2286 p.ball 0 (r\u2081 * r\u2082)"}, {"line": "\u00b7 exact (smul_subset_smul_left (ball_subset_closedBall _ _ _)).trans\n      (ball_smul_closedBall _ _ hr\u2082)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_closedBall_subset {p : Seminorm \ud835\udd5c E} {k : \ud835\udd5c} {r : \u211d} :\n    k \u2022 p.closedBall 0 r \u2286 p.closedBall 0 (\u2016k\u2016 * r) := by\n  rintro x \u27e8y, hy, h\u27e9\n  rw [Seminorm.mem_closedBall_zero]\n  rw [\u2190 h]\n  rw [map_smul_eq_mul]\n  rw [Seminorm.mem_closedBall_zero] at hy\n  gcongr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Seminorm.lean", "context": {"open": ["NormedField Set Filter", "scoped NNReal Pointwise Topology Uniformity", "Classical in"], "variables": ["{R R' \ud835\udd5c \ud835\udd5c\u2082 \ud835\udd5c\u2083 \ud835\udd5d E E\u2082 E\u2083 F \u03b9 : Type*}", "[SeminormedRing \ud835\udd5c]", "[AddGroup E]", "[SMul \ud835\udd5c E]", "(p : Seminorm \ud835\udd5c E) (x : E) (r : \u211d)", "(\ud835\udd5c E)", "{\ud835\udd5c E}", "[SeminormedRing \ud835\udd5c\u2082] [SeminormedRing \ud835\udd5c\u2083]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "{\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083} [RingHomIsometric \u03c3\u2082\u2083]", "{\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083} [RingHomIsometric \u03c3\u2081\u2083]", "[AddCommGroup E] [AddCommGroup E\u2082] [AddCommGroup E\u2083]", "[Module \ud835\udd5c E] [Module \ud835\udd5c\u2082 E\u2082] [Module \ud835\udd5c\u2083 E\u2083]", "[SMul R \u211d] [SMul R \u211d\u22650] [IsScalarTower R \u211d\u22650 \u211d]", "[SeminormedRing \ud835\udd5c] [SeminormedCommRing \ud835\udd5c\u2082]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "[AddCommGroup E] [AddCommGroup E\u2082] [Module \ud835\udd5c E] [Module \ud835\udd5c\u2082 E\u2082]", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {p q : Seminorm \ud835\udd5c E} {x : E}", "[SeminormedRing \ud835\udd5c]", "[AddCommGroup E]", "[SMul \ud835\udd5c E] (p : Seminorm \ud835\udd5c E)", "{x y : E} {r : \u211d}", "[Module \ud835\udd5c E]", "[SeminormedRing \ud835\udd5c\u2082] [AddCommGroup E\u2082] [Module \ud835\udd5c\u2082 E\u2082]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "(p : Seminorm \ud835\udd5c E)", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] (p : Seminorm \ud835\udd5c E) {r : \u211d} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u00b3 : AddCommGroup E\ninst\u271d\u00b9\u00b2 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : NormedField \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : SeminormedRing \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : SMul \ud835\udd5c E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nk : \ud835\udd5c\nr : \u211d\n\u22a2 k \u2022 p.closedBall 0 r \u2286 p.closedBall 0 (\u2016k\u2016 * r)"}, {"line": "rintro x \u27e8y, hy, h\u27e9", "tactic_state": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u00b3 : AddCommGroup E\ninst\u271d\u00b9\u00b2 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : NormedField \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : SeminormedRing \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : SMul \ud835\udd5c E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nk : \ud835\udd5c\nr : \u211d\nx y : E\nhy : y \u2208 p.closedBall 0 r\nh : (fun x => k \u2022 x) y = x\n\u22a2 x \u2208 p.closedBall 0 (\u2016k\u2016 * r)"}, {"line": "rw [Seminorm.mem_closedBall_zero]", "tactic_state": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u00b3 : AddCommGroup E\ninst\u271d\u00b9\u00b2 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : NormedField \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : SeminormedRing \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : SMul \ud835\udd5c E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nk : \ud835\udd5c\nr : \u211d\nx y : E\nhy : y \u2208 p.closedBall 0 r\nh : (fun x => k \u2022 x) y = x\n\u22a2 p x \u2264 \u2016k\u2016 * r"}, {"line": "rw [\u2190 h]", "tactic_state": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u00b3 : AddCommGroup E\ninst\u271d\u00b9\u00b2 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : NormedField \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : SeminormedRing \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : SMul \ud835\udd5c E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nk : \ud835\udd5c\nr : \u211d\nx y : E\nhy : y \u2208 p.closedBall 0 r\nh : (fun x => k \u2022 x) y = x\n\u22a2 p ((fun x => k \u2022 x) y) \u2264 \u2016k\u2016 * r"}, {"line": "rw [map_smul_eq_mul]", "tactic_state": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u00b3 : AddCommGroup E\ninst\u271d\u00b9\u00b2 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : NormedField \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : SeminormedRing \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : SMul \ud835\udd5c E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nk : \ud835\udd5c\nr : \u211d\nx y : E\nhy : y \u2208 p.closedBall 0 r\nh : (fun x => k \u2022 x) y = x\n\u22a2 \u2016k\u2016 * p y \u2264 \u2016k\u2016 * r"}, {"line": "rw [Seminorm.mem_closedBall_zero] at hy", "tactic_state": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u00b3 : AddCommGroup E\ninst\u271d\u00b9\u00b2 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : NormedField \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : SeminormedRing \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : SMul \ud835\udd5c E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nk : \ud835\udd5c\nr : \u211d\nx y : E\nhy : p y \u2264 r\nh : (fun x => k \u2022 x) y = x\n\u22a2 \u2016k\u2016 * p y \u2264 \u2016k\u2016 * r"}, {"line": "gcongr", "tactic_state": "case intro.intro.c0\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u00b3 : AddCommGroup E\ninst\u271d\u00b9\u00b2 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : NormedField \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : SeminormedRing \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : SMul \ud835\udd5c E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nk : \ud835\udd5c\nr : \u211d\nx y : E\nhy : p y \u2264 r\nh : (fun x => k \u2022 x) y = x\n\u22a2 0 \u2264 p y\n---\ncase intro.intro.b0\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u00b3 : AddCommGroup E\ninst\u271d\u00b9\u00b2 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : NormedField \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : SeminormedRing \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : SMul \ud835\udd5c E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nk : \ud835\udd5c\nr : \u211d\nx y : E\nhy : p y \u2264 r\nh : (fun x => k \u2022 x) y = x\n\u22a2 0 \u2264 \u2016k\u2016\n---\ncase intro.intro.h\u2081\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u00b3 : AddCommGroup E\ninst\u271d\u00b9\u00b2 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : NormedField \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : SeminormedRing \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : SMul \ud835\udd5c E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nk : \ud835\udd5c\nr : \u211d\nx y : E\nhy : p y \u2264 r\nh : (fun x => k \u2022 x) y = x\n\u22a2 \u2016k\u2016 \u2264 \u2016k\u2016"}]}
{"declaration": "theorem continuousAt_zero_of_forall' [TopologicalSpace E] {p : Seminorm \ud835\udd5d E}\n    (hp : \u2200 r > 0, p.closedBall 0 r \u2208 (\ud835\udcdd 0 : Filter E)) :\n    ContinuousAt p 0 := by\n  simp_rw [Seminorm.closedBall_zero_eq_preimage_closedBall] at hp\n  rwa [ContinuousAt, Metric.nhds_basis_closedBall.tendsto_right_iff, map_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Seminorm.lean", "context": {"open": ["NormedField Set Filter", "scoped NNReal Pointwise Topology Uniformity", "Classical in"], "variables": ["{R R' \ud835\udd5c \ud835\udd5c\u2082 \ud835\udd5c\u2083 \ud835\udd5d E E\u2082 E\u2083 F \u03b9 : Type*}", "[SeminormedRing \ud835\udd5c]", "[AddGroup E]", "[SMul \ud835\udd5c E]", "(p : Seminorm \ud835\udd5c E) (x : E) (r : \u211d)", "(\ud835\udd5c E)", "{\ud835\udd5c E}", "[SeminormedRing \ud835\udd5c\u2082] [SeminormedRing \ud835\udd5c\u2083]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "{\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083} [RingHomIsometric \u03c3\u2082\u2083]", "{\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083} [RingHomIsometric \u03c3\u2081\u2083]", "[AddCommGroup E] [AddCommGroup E\u2082] [AddCommGroup E\u2083]", "[Module \ud835\udd5c E] [Module \ud835\udd5c\u2082 E\u2082] [Module \ud835\udd5c\u2083 E\u2083]", "[SMul R \u211d] [SMul R \u211d\u22650] [IsScalarTower R \u211d\u22650 \u211d]", "[SeminormedRing \ud835\udd5c] [SeminormedCommRing \ud835\udd5c\u2082]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "[AddCommGroup E] [AddCommGroup E\u2082] [Module \ud835\udd5c E] [Module \ud835\udd5c\u2082 E\u2082]", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {p q : Seminorm \ud835\udd5c E} {x : E}", "[SeminormedRing \ud835\udd5c]", "[AddCommGroup E]", "[SMul \ud835\udd5c E] (p : Seminorm \ud835\udd5c E)", "{x y : E} {r : \u211d}", "[Module \ud835\udd5c E]", "[SeminormedRing \ud835\udd5c\u2082] [AddCommGroup E\u2082] [Module \ud835\udd5c\u2082 E\u2082]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "(p : Seminorm \ud835\udd5c E)", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] (p : Seminorm \ud835\udd5c E) {r : \u211d} {x : E}", "[NormedField \ud835\udd5c] [AddCommGroup E] [NormedSpace \u211d \ud835\udd5c] [Module \ud835\udd5c E]", "[SMul \u211d E] [IsScalarTower \u211d \ud835\udd5c E] (p : Seminorm \ud835\udd5c E)", "[Module \u211d E] [IsScalarTower \u211d \ud835\udd5c E] (p : Seminorm \ud835\udd5c E) (x : E) (r : \u211d)", "(\ud835\udd5c) {\ud835\udd5c' : Type*} [NormedField \ud835\udd5c] [SeminormedRing \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c']", "[NontriviallyNormedField \ud835\udd5c] [SeminormedRing \ud835\udd5d] [AddCommGroup E] [Module \ud835\udd5c E]", "[Module \ud835\udd5d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5d : Type u_3\nE : Type u_2\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5d\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module \ud835\udd5d E\ninst\u271d : TopologicalSpace E\np : Seminorm \ud835\udd5d E\nhp : \u2200 r > 0, p.closedBall 0 r \u2208 nhds 0\n\u22a2 ContinuousAt (\u21d1p) 0"}, {"line": "simp_rw [Seminorm.closedBall_zero_eq_preimage_closedBall] at hp", "tactic_state": "\ud835\udd5d : Type u_3\nE : Type u_2\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5d\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module \ud835\udd5d E\ninst\u271d : TopologicalSpace E\np : Seminorm \ud835\udd5d E\nhp : \u2200 r > 0, \u21d1p \u207b\u00b9' Metric.closedBall 0 r \u2208 nhds 0\n\u22a2 ContinuousAt (\u21d1p) 0"}, {"line": "rwa [ContinuousAt, Metric.nhds_basis_closedBall.tendsto_right_iff, map_zero]", "tactic_state": "\ud835\udd5d : Type u_3\nE : Type u_2\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5d\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module \ud835\udd5d E\ninst\u271d : TopologicalSpace E\np : Seminorm \ud835\udd5d E\nhp : \u2200 r > 0, \u21d1p \u207b\u00b9' Metric.closedBall 0 r \u2208 nhds 0\n\u22a2 ZeroHomClass (Seminorm \ud835\udd5d E) E \u211d"}]}
{"declaration": "theorem lim_le_div (hbdd : BddBelow (range fun n => u n / n)) {n : \u2115} (hn : n \u2260 0) :\n    h.lim \u2264 u n / n := by\n  rw [Subadditive.lim]\n  exact csInf_le (hbdd.mono <| image_subset_range _ _) \u27e8n, hn.bot_lt, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Subadditive.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{u : \u2115 \u2192 \u211d} (h : Subadditive u)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "u : \u2115 \u2192 \u211d\nh : Subadditive u\nhbdd : BddBelow (range fun n => u n / \u2191n)\nn : \u2115\nhn : n \u2260 0\n\u22a2 h.lim \u2264 u n / \u2191n"}, {"line": "rw [Subadditive.lim]", "tactic_state": "u : \u2115 \u2192 \u211d\nh : Subadditive u\nhbdd : BddBelow (range fun n => u n / \u2191n)\nn : \u2115\nhn : n \u2260 0\n\u22a2 sInf ((fun n => u n / \u2191n) '' Ici 1) \u2264 u n / \u2191n"}, {"line": "exact csInf_le (hbdd.mono <| image_subset_range _ _) \u27e8n, hn.bot_lt, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AntitoneOn.integral_le_sum (hf : AntitoneOn f (Icc x\u2080 (x\u2080 + a))) :\n    (\u222b x in x\u2080..x\u2080 + a, f x) \u2264 \u2211 i \u2208 Finset.range a, f (x\u2080 + i) := by\n  have hint : \u2200 k : \u2115, k < a \u2192 IntervalIntegrable f volume (x\u2080 + k) (x\u2080 + (k + 1 : \u2115)) := by\n    intro k hk\n    refine (hf.mono ?_).intervalIntegrable\n    rw [uIcc_of_le]\n    \u00b7 apply Icc_subset_Icc\n      \u00b7 simp only [le_add_iff_nonneg_right, Nat.cast_nonneg]\n      \u00b7 simp only [add_le_add_iff_left, Nat.cast_le, Nat.succ_le_of_lt hk]\n    \u00b7 simp only [add_le_add_iff_left, Nat.cast_le, Nat.le_succ]\n  calc\n    \u222b x in x\u2080..x\u2080 + a, f x = \u2211 i \u2208 Finset.range a, \u222b x in x\u2080 + i..x\u2080 + (i + 1 : \u2115), f x := by\n      convert (intervalIntegral.sum_integral_adjacent_intervals hint).symm\n      simp only [Nat.cast_zero]\n      simp only [add_zero]\n    _ \u2264 \u2211 i \u2208 Finset.range a, \u222b _ in x\u2080 + i..x\u2080 + (i + 1 : \u2115), f (x\u2080 + i) := by\n      apply Finset.sum_le_sum fun i hi => ?_\n      have ia : i < a := Finset.mem_range.1 hi\n      refine intervalIntegral.integral_mono_on (by simp) (hint _ ia) (by simp) fun x hx => ?_\n      apply hf _ _ hx.1\n      \u00b7 simp only [ia.le, mem_Icc, le_add_iff_nonneg_right, Nat.cast_nonneg, add_le_add_iff_left,\n          Nat.cast_le, and_self_iff]\n      \u00b7 refine mem_Icc.2 \u27e8le_trans (by simp) hx.1, le_trans hx.2 ?_\u27e9\n        simp only [add_le_add_iff_left]\n        simp only [Nat.cast_le]\n        simp only [Nat.succ_le_of_lt ia]\n    _ = \u2211 i \u2208 Finset.range a, f (x\u2080 + i) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SumIntegralComparisons.lean", "context": {"open": ["Set MeasureTheory MeasureSpace"], "variables": ["{x\u2080 : \u211d} {a b : \u2115} {f g : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u2080 : \u211d\na : \u2115\nf : \u211d \u2192 \u211d\nhf : AntitoneOn f (Icc x\u2080 (x\u2080 + \u2191a))\n\u22a2 \u222b (x : \u211d) in x\u2080..x\u2080 + \u2191a, f x \u2264 \u2211 i \u2208 Finset.range a, f (x\u2080 + \u2191i)"}, {"line": "have hint : \u2200 k : \u2115, k < a \u2192 IntervalIntegrable f volume (x\u2080 + k) (x\u2080 + (k + 1 : \u2115)) := sorry", "tactic_state": "x\u2080 : \u211d\na : \u2115\nf : \u211d \u2192 \u211d\nhf : AntitoneOn f (Icc x\u2080 (x\u2080 + \u2191a))\nhint : \u2200 k < a, IntervalIntegrable f volume (x\u2080 + \u2191k) (x\u2080 + \u2191(k + 1))\n\u22a2 \u222b (x : \u211d) in x\u2080..x\u2080 + \u2191a, f x \u2264 \u2211 i \u2208 Finset.range a, f (x\u2080 + \u2191i)"}, {"line": "calc\n    \u222b x in x\u2080..x\u2080 + a, f x = \u2211 i \u2208 Finset.range a, \u222b x in x\u2080 + i..x\u2080 + (i + 1 : \u2115), f x := by\n      convert (intervalIntegral.sum_integral_adjacent_intervals hint).symm\n      simp only [Nat.cast_zero]\n      simp only [add_zero]\n    _ \u2264 \u2211 i \u2208 Finset.range a, \u222b _ in x\u2080 + i..x\u2080 + (i + 1 : \u2115), f (x\u2080 + i) := by\n      apply Finset.sum_le_sum fun i hi => ?_\n      have ia : i < a := Finset.mem_range.1 hi\n      refine intervalIntegral.integral_mono_on (by simp) (hint _ ia) (by simp) fun x hx => ?_\n      apply hf _ _ hx.1\n      \u00b7 simp only [ia.le, mem_Icc, le_add_iff_nonneg_right, Nat.cast_nonneg, add_le_add_iff_left,\n          Nat.cast_le, and_self_iff]\n      \u00b7 refine mem_Icc.2 \u27e8le_trans (by simp) hx.1, le_trans hx.2 ?_\u27e9\n        simp only [add_le_add_iff_left]\n        simp only [Nat.cast_le]\n        simp only [Nat.succ_le_of_lt ia]\n    _ = \u2211 i \u2208 Finset.range a, f (x\u2080 + i) := by simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AntitoneOn.sum_le_integral (hf : AntitoneOn f (Icc x\u2080 (x\u2080 + a))) :\n    (\u2211 i \u2208 Finset.range a, f (x\u2080 + (i + 1 : \u2115))) \u2264 \u222b x in x\u2080..x\u2080 + a, f x := by\n  have hint : \u2200 k : \u2115, k < a \u2192 IntervalIntegrable f volume (x\u2080 + k) (x\u2080 + (k + 1 : \u2115)) := by\n    intro k hk\n    refine (hf.mono ?_).intervalIntegrable\n    rw [uIcc_of_le]\n    \u00b7 apply Icc_subset_Icc\n      \u00b7 simp only [le_add_iff_nonneg_right, Nat.cast_nonneg]\n      \u00b7 simp only [add_le_add_iff_left, Nat.cast_le, Nat.succ_le_of_lt hk]\n    \u00b7 simp only [add_le_add_iff_left, Nat.cast_le, Nat.le_succ]\n  calc\n    (\u2211 i \u2208 Finset.range a, f (x\u2080 + (i + 1 : \u2115))) =\n        \u2211 i \u2208 Finset.range a, \u222b _ in x\u2080 + i..x\u2080 + (i + 1 : \u2115), f (x\u2080 + (i + 1 : \u2115)) := by simp\n    _ \u2264 \u2211 i \u2208 Finset.range a, \u222b x in x\u2080 + i..x\u2080 + (i + 1 : \u2115), f x := by\n      apply Finset.sum_le_sum fun i hi => ?_\n      have ia : i + 1 \u2264 a := Finset.mem_range.1 hi\n      refine intervalIntegral.integral_mono_on (by simp) (by simp) (hint _ ia) fun x hx => ?_\n      apply hf _ _ hx.2\n      \u00b7 refine mem_Icc.2 \u27e8le_trans (le_add_of_nonneg_right (Nat.cast_nonneg _)) hx.1,\n          le_trans hx.2 ?_\u27e9\n        simp only [Nat.cast_le]\n        simp only [add_le_add_iff_left]\n        simp only [ia]\n      \u00b7 refine mem_Icc.2 \u27e8le_add_of_nonneg_right (Nat.cast_nonneg _), ?_\u27e9\n        simp only [add_le_add_iff_left]\n        simp only [Nat.cast_le]\n        simp only [ia]\n    _ = \u222b x in x\u2080..x\u2080 + a, f x := by\n      convert intervalIntegral.sum_integral_adjacent_intervals hint\n      simp only [Nat.cast_zero]\n      simp only [add_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SumIntegralComparisons.lean", "context": {"open": ["Set MeasureTheory MeasureSpace"], "variables": ["{x\u2080 : \u211d} {a b : \u2115} {f g : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u2080 : \u211d\na : \u2115\nf : \u211d \u2192 \u211d\nhf : AntitoneOn f (Icc x\u2080 (x\u2080 + \u2191a))\n\u22a2 \u2211 i \u2208 Finset.range a, f (x\u2080 + \u2191(i + 1)) \u2264 \u222b (x : \u211d) in x\u2080..x\u2080 + \u2191a, f x"}, {"line": "have hint : \u2200 k : \u2115, k < a \u2192 IntervalIntegrable f volume (x\u2080 + k) (x\u2080 + (k + 1 : \u2115)) := sorry", "tactic_state": "x\u2080 : \u211d\na : \u2115\nf : \u211d \u2192 \u211d\nhf : AntitoneOn f (Icc x\u2080 (x\u2080 + \u2191a))\nhint : \u2200 k < a, IntervalIntegrable f volume (x\u2080 + \u2191k) (x\u2080 + \u2191(k + 1))\n\u22a2 \u2211 i \u2208 Finset.range a, f (x\u2080 + \u2191(i + 1)) \u2264 \u222b (x : \u211d) in x\u2080..x\u2080 + \u2191a, f x"}, {"line": "calc\n    (\u2211 i \u2208 Finset.range a, f (x\u2080 + (i + 1 : \u2115))) =\n        \u2211 i \u2208 Finset.range a, \u222b _ in x\u2080 + i..x\u2080 + (i + 1 : \u2115), f (x\u2080 + (i + 1 : \u2115)) := by simp\n    _ \u2264 \u2211 i \u2208 Finset.range a, \u222b x in x\u2080 + i..x\u2080 + (i + 1 : \u2115), f x := by\n      apply Finset.sum_le_sum fun i hi => ?_\n      have ia : i + 1 \u2264 a := Finset.mem_range.1 hi\n      refine intervalIntegral.integral_mono_on (by simp) (by simp) (hint _ ia) fun x hx => ?_\n      apply hf _ _ hx.2\n      \u00b7 refine mem_Icc.2 \u27e8le_trans (le_add_of_nonneg_right (Nat.cast_nonneg _)) hx.1,\n          le_trans hx.2 ?_\u27e9\n        simp only [Nat.cast_le]\n        simp only [add_le_add_iff_left]\n        simp only [ia]\n      \u00b7 refine mem_Icc.2 \u27e8le_add_of_nonneg_right (Nat.cast_nonneg _), ?_\u27e9\n        simp only [add_le_add_iff_left]\n        simp only [Nat.cast_le]\n        simp only [ia]\n    _ = \u222b x in x\u2080..x\u2080 + a, f x := by\n      convert intervalIntegral.sum_integral_adjacent_intervals hint\n      simp only [Nat.cast_zero]\n      simp only [add_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MonotoneOn.sum_le_integral (hf : MonotoneOn f (Icc x\u2080 (x\u2080 + a))) :\n    (\u2211 i \u2208 Finset.range a, f (x\u2080 + i)) \u2264 \u222b x in x\u2080..x\u2080 + a, f x := by\n  rw [\u2190 neg_le_neg_iff]\n  rw [\u2190 Finset.sum_neg_distrib]\n  rw [\u2190 intervalIntegral.integral_neg]\n  exact hf.neg.integral_le_sum\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SumIntegralComparisons.lean", "context": {"open": ["Set MeasureTheory MeasureSpace"], "variables": ["{x\u2080 : \u211d} {a b : \u2115} {f g : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u2080 : \u211d\na : \u2115\nf : \u211d \u2192 \u211d\nhf : MonotoneOn f (Icc x\u2080 (x\u2080 + \u2191a))\n\u22a2 \u2211 i \u2208 Finset.range a, f (x\u2080 + \u2191i) \u2264 \u222b (x : \u211d) in x\u2080..x\u2080 + \u2191a, f x"}, {"line": "rw [\u2190 neg_le_neg_iff]", "tactic_state": "x\u2080 : \u211d\na : \u2115\nf : \u211d \u2192 \u211d\nhf : MonotoneOn f (Icc x\u2080 (x\u2080 + \u2191a))\n\u22a2 -\u222b (x : \u211d) in x\u2080..x\u2080 + \u2191a, f x \u2264 -\u2211 i \u2208 Finset.range a, f (x\u2080 + \u2191i)"}, {"line": "rw [\u2190 Finset.sum_neg_distrib]", "tactic_state": "x\u2080 : \u211d\na : \u2115\nf : \u211d \u2192 \u211d\nhf : MonotoneOn f (Icc x\u2080 (x\u2080 + \u2191a))\n\u22a2 -\u222b (x : \u211d) in x\u2080..x\u2080 + \u2191a, f x \u2264 \u2211 x \u2208 Finset.range a, -f (x\u2080 + \u2191x)"}, {"line": "rw [\u2190 intervalIntegral.integral_neg]", "tactic_state": "x\u2080 : \u211d\na : \u2115\nf : \u211d \u2192 \u211d\nhf : MonotoneOn f (Icc x\u2080 (x\u2080 + \u2191a))\n\u22a2 \u222b (x : \u211d) in x\u2080..x\u2080 + \u2191a, -f x \u2264 \u2211 x \u2208 Finset.range a, -f (x\u2080 + \u2191x)"}, {"line": "exact hf.neg.integral_le_sum", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MonotoneOn.sum_le_integral_Ico (hab : a \u2264 b) (hf : MonotoneOn f (Set.Icc a b)) :\n    \u2211 x \u2208 Finset.Ico a b, f x \u2264 \u222b x in a..b, f x := by\n  rw [\u2190 neg_le_neg_iff]\n  rw [\u2190 Finset.sum_neg_distrib]\n  rw [\u2190 intervalIntegral.integral_neg]\n  exact hf.neg.integral_le_sum_Ico hab\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SumIntegralComparisons.lean", "context": {"open": ["Set MeasureTheory MeasureSpace"], "variables": ["{x\u2080 : \u211d} {a b : \u2115} {f g : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nf : \u211d \u2192 \u211d\nhab : a \u2264 b\nhf : MonotoneOn f (Icc \u2191a \u2191b)\n\u22a2 \u2211 x \u2208 Finset.Ico a b, f \u2191x \u2264 \u222b (x : \u211d) in \u2191a..\u2191b, f x"}, {"line": "rw [\u2190 neg_le_neg_iff]", "tactic_state": "a b : \u2115\nf : \u211d \u2192 \u211d\nhab : a \u2264 b\nhf : MonotoneOn f (Icc \u2191a \u2191b)\n\u22a2 -\u222b (x : \u211d) in \u2191a..\u2191b, f x \u2264 -\u2211 x \u2208 Finset.Ico a b, f \u2191x"}, {"line": "rw [\u2190 Finset.sum_neg_distrib]", "tactic_state": "a b : \u2115\nf : \u211d \u2192 \u211d\nhab : a \u2264 b\nhf : MonotoneOn f (Icc \u2191a \u2191b)\n\u22a2 -\u222b (x : \u211d) in \u2191a..\u2191b, f x \u2264 \u2211 x \u2208 Finset.Ico a b, -f \u2191x"}, {"line": "rw [\u2190 intervalIntegral.integral_neg]", "tactic_state": "a b : \u2115\nf : \u211d \u2192 \u211d\nhab : a \u2264 b\nhf : MonotoneOn f (Icc \u2191a \u2191b)\n\u22a2 \u222b (x : \u211d) in \u2191a..\u2191b, -f x \u2264 \u2211 x \u2208 Finset.Ico a b, -f \u2191x"}, {"line": "exact hf.neg.integral_le_sum_Ico hab", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MonotoneOn.integral_le_sum (hf : MonotoneOn f (Icc x\u2080 (x\u2080 + a))) :\n    (\u222b x in x\u2080..x\u2080 + a, f x) \u2264 \u2211 i \u2208 Finset.range a, f (x\u2080 + (i + 1 : \u2115)) := by\n  rw [\u2190 neg_le_neg_iff]\n  rw [\u2190 Finset.sum_neg_distrib]\n  rw [\u2190 intervalIntegral.integral_neg]\n  exact hf.neg.sum_le_integral\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SumIntegralComparisons.lean", "context": {"open": ["Set MeasureTheory MeasureSpace"], "variables": ["{x\u2080 : \u211d} {a b : \u2115} {f g : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u2080 : \u211d\na : \u2115\nf : \u211d \u2192 \u211d\nhf : MonotoneOn f (Icc x\u2080 (x\u2080 + \u2191a))\n\u22a2 \u222b (x : \u211d) in x\u2080..x\u2080 + \u2191a, f x \u2264 \u2211 i \u2208 Finset.range a, f (x\u2080 + \u2191(i + 1))"}, {"line": "rw [\u2190 neg_le_neg_iff]", "tactic_state": "x\u2080 : \u211d\na : \u2115\nf : \u211d \u2192 \u211d\nhf : MonotoneOn f (Icc x\u2080 (x\u2080 + \u2191a))\n\u22a2 -\u2211 i \u2208 Finset.range a, f (x\u2080 + \u2191(i + 1)) \u2264 -\u222b (x : \u211d) in x\u2080..x\u2080 + \u2191a, f x"}, {"line": "rw [\u2190 Finset.sum_neg_distrib]", "tactic_state": "x\u2080 : \u211d\na : \u2115\nf : \u211d \u2192 \u211d\nhf : MonotoneOn f (Icc x\u2080 (x\u2080 + \u2191a))\n\u22a2 \u2211 x \u2208 Finset.range a, -f (x\u2080 + \u2191(x + 1)) \u2264 -\u222b (x : \u211d) in x\u2080..x\u2080 + \u2191a, f x"}, {"line": "rw [\u2190 intervalIntegral.integral_neg]", "tactic_state": "x\u2080 : \u211d\na : \u2115\nf : \u211d \u2192 \u211d\nhf : MonotoneOn f (Icc x\u2080 (x\u2080 + \u2191a))\n\u22a2 \u2211 x \u2208 Finset.range a, -f (x\u2080 + \u2191(x + 1)) \u2264 \u222b (x : \u211d) in x\u2080..x\u2080 + \u2191a, -f x"}, {"line": "exact hf.neg.sum_le_integral", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MonotoneOn.integral_le_sum_Ico (hab : a \u2264 b) (hf : MonotoneOn f (Set.Icc a b)) :\n    (\u222b x in a..b, f x) \u2264 \u2211 i \u2208 Finset.Ico a b, f (i + 1 : \u2115) := by\n  rw [\u2190 neg_le_neg_iff]\n  rw [\u2190 Finset.sum_neg_distrib]\n  rw [\u2190 intervalIntegral.integral_neg]\n  exact hf.neg.sum_le_integral_Ico hab\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SumIntegralComparisons.lean", "context": {"open": ["Set MeasureTheory MeasureSpace"], "variables": ["{x\u2080 : \u211d} {a b : \u2115} {f g : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nf : \u211d \u2192 \u211d\nhab : a \u2264 b\nhf : MonotoneOn f (Icc \u2191a \u2191b)\n\u22a2 \u222b (x : \u211d) in \u2191a..\u2191b, f x \u2264 \u2211 i \u2208 Finset.Ico a b, f \u2191(i + 1)"}, {"line": "rw [\u2190 neg_le_neg_iff]", "tactic_state": "a b : \u2115\nf : \u211d \u2192 \u211d\nhab : a \u2264 b\nhf : MonotoneOn f (Icc \u2191a \u2191b)\n\u22a2 -\u2211 i \u2208 Finset.Ico a b, f \u2191(i + 1) \u2264 -\u222b (x : \u211d) in \u2191a..\u2191b, f x"}, {"line": "rw [\u2190 Finset.sum_neg_distrib]", "tactic_state": "a b : \u2115\nf : \u211d \u2192 \u211d\nhab : a \u2264 b\nhf : MonotoneOn f (Icc \u2191a \u2191b)\n\u22a2 \u2211 x \u2208 Finset.Ico a b, -f \u2191(x + 1) \u2264 -\u222b (x : \u211d) in \u2191a..\u2191b, f x"}, {"line": "rw [\u2190 intervalIntegral.integral_neg]", "tactic_state": "a b : \u2115\nf : \u211d \u2192 \u211d\nhab : a \u2264 b\nhf : MonotoneOn f (Icc \u2191a \u2191b)\n\u22a2 \u2211 x \u2208 Finset.Ico a b, -f \u2191(x + 1) \u2264 \u222b (x : \u211d) in \u2191a..\u2191b, -f x"}, {"line": "exact hf.neg.sum_le_integral_Ico hab", "tactic_state": "No Goals!"}]}
{"declaration": "theorem removeZero_applyComposition (p : FormalMultilinearSeries \ud835\udd5c E F) {n : \u2115}\n    (c : Composition n) : p.removeZero.applyComposition c = p.applyComposition c := by\n  ext v i\n  simp [applyComposition, zero_lt_one.trans_le (c.one_le_blocksFun i), removeZero_of_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Composition.lean", "context": {"open": ["Filter List", "scoped Topology NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} {E F G H : Type*}", "[CommRing \ud835\udd5c] [AddCommGroup E] [AddCommGroup F] [AddCommGroup G]", "[Module \ud835\udd5c E] [Module \ud835\udd5c F] [Module \ud835\udd5c G]", "[TopologicalSpace E] [TopologicalSpace F] [TopologicalSpace G]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup G] [ContinuousConstSMul \ud835\udd5c G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b9\u2070 : CommRing \ud835\udd5c\ninst\u271d\u2079 : AddCommGroup E\ninst\u271d\u2078 : AddCommGroup F\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : Module \ud835\udd5c F\ninst\u271d\u2075 : TopologicalSpace E\ninst\u271d\u2074 : TopologicalSpace F\ninst\u271d\u00b3 : IsTopologicalAddGroup E\ninst\u271d\u00b2 : ContinuousConstSMul \ud835\udd5c E\ninst\u271d\u00b9 : IsTopologicalAddGroup F\ninst\u271d : ContinuousConstSMul \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nc : Composition n\n\u22a2 p.removeZero.applyComposition c = p.applyComposition c"}, {"line": "ext v i", "tactic_state": "case h.h\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b9\u2070 : CommRing \ud835\udd5c\ninst\u271d\u2079 : AddCommGroup E\ninst\u271d\u2078 : AddCommGroup F\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : Module \ud835\udd5c F\ninst\u271d\u2075 : TopologicalSpace E\ninst\u271d\u2074 : TopologicalSpace F\ninst\u271d\u00b3 : IsTopologicalAddGroup E\ninst\u271d\u00b2 : ContinuousConstSMul \ud835\udd5c E\ninst\u271d\u00b9 : IsTopologicalAddGroup F\ninst\u271d : ContinuousConstSMul \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nc : Composition n\nv : Fin n \u2192 E\ni : Fin c.length\n\u22a2 p.removeZero.applyComposition c v i = p.applyComposition c v i"}, {"line": "simp [applyComposition, zero_lt_one.trans_le (c.one_le_blocksFun i), removeZero_of_pos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem id_apply_of_one_lt (x : E) {n : \u2115} (h : 1 < n) :\n    (FormalMultilinearSeries.id \ud835\udd5c E x) n = 0 := by\n  match n with\n    | 0 => contradiction\n    | 1 => contradiction\n    | n + 2 => rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Composition.lean", "context": {"open": ["Filter List", "scoped Topology NNReal ENNReal", "FormalMultilinearSeries"], "variables": ["{\ud835\udd5c : Type*} {E F G H : Type*}", "[CommRing \ud835\udd5c] [AddCommGroup E] [AddCommGroup F] [AddCommGroup G]", "[Module \ud835\udd5c E] [Module \ud835\udd5c F] [Module \ud835\udd5c G]", "[TopologicalSpace E] [TopologicalSpace F] [TopologicalSpace G]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup G] [ContinuousConstSMul \ud835\udd5c G]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup G] [ContinuousConstSMul \ud835\udd5c G]", "[NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "(\ud835\udd5c E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u00b2 : CommRing \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : TopologicalSpace E\ninst\u271d\u2078 : IsTopologicalAddGroup E\ninst\u271d\u2077 : ContinuousConstSMul \ud835\udd5c E\ninst\u271d\u2076 : IsTopologicalAddGroup E\ninst\u271d\u2075 : ContinuousConstSMul \ud835\udd5c E\ninst\u271d\u2074 : IsTopologicalAddGroup E\ninst\u271d\u00b3 : ContinuousConstSMul \ud835\udd5c E\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nh : 1 < n\n\u22a2 FormalMultilinearSeries.id \ud835\udd5c E x n = 0"}, {"line": "match n with\n    | 0 => contradiction\n    | 1 => contradiction\n    | n + 2 => rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem id_comp' (p : FormalMultilinearSeries \ud835\udd5c E F) (x : F) (v0 : Fin 0 \u2192 E) (h : x = p 0 v0) :\n    (id \ud835\udd5c F x).comp p = p := by\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Composition.lean", "context": {"open": ["Filter List", "scoped Topology NNReal ENNReal", "FormalMultilinearSeries"], "variables": ["{\ud835\udd5c : Type*} {E F G H : Type*}", "[CommRing \ud835\udd5c] [AddCommGroup E] [AddCommGroup F] [AddCommGroup G]", "[Module \ud835\udd5c E] [Module \ud835\udd5c F] [Module \ud835\udd5c G]", "[TopologicalSpace E] [TopologicalSpace F] [TopologicalSpace G]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup G] [ContinuousConstSMul \ud835\udd5c G]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup G] [ContinuousConstSMul \ud835\udd5c G]", "[NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "(\ud835\udd5c E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\nF : Type u_3\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : AddCommGroup F\ninst\u271d\u2079 : TopologicalSpace E\ninst\u271d\u2078 : TopologicalSpace F\ninst\u271d\u2077 : IsTopologicalAddGroup E\ninst\u271d\u2076 : IsTopologicalAddGroup F\ninst\u271d\u2075 : IsTopologicalAddGroup E\ninst\u271d\u2074 : IsTopologicalAddGroup F\ninst\u271d\u00b3 : IsTopologicalAddGroup E\ninst\u271d\u00b2 : IsTopologicalAddGroup F\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedAddCommGroup F\np : sorry\nx : F\nv0 : Fin 0 \u2192 E\nh : x = sorry\n\u22a2 sorry = p"}, {"line": "simp [h]", "tactic_state": "E : Type u_2\nF : Type u_3\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : AddCommGroup F\ninst\u271d\u2079 : TopologicalSpace E\ninst\u271d\u2078 : TopologicalSpace F\ninst\u271d\u2077 : IsTopologicalAddGroup E\ninst\u271d\u2076 : IsTopologicalAddGroup F\ninst\u271d\u2075 : IsTopologicalAddGroup E\ninst\u271d\u2074 : IsTopologicalAddGroup F\ninst\u271d\u00b3 : IsTopologicalAddGroup E\ninst\u271d\u00b2 : IsTopologicalAddGroup F\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedAddCommGroup F\np : sorry\nx : F\nv0 : Fin 0 \u2192 E\nh : x = sorry\n\u22a2 sorry () = p"}]}
{"declaration": "theorem mem_compPartialSumTarget_iff {m M N : \u2115} {a : \u03a3 n, Composition n} :\n    a \u2208 compPartialSumTarget m M N \u2194\n      m \u2264 a.2.length \u2227 a.2.length < M \u2227 \u2200 j : Fin a.2.length, a.2.blocksFun j < N := by\n  simp [compPartialSumTarget, compPartialSumTargetSet]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Composition.lean", "context": {"open": ["Filter List", "scoped Topology NNReal ENNReal", "FormalMultilinearSeries"], "variables": ["{\ud835\udd5c : Type*} {E F G H : Type*}", "[CommRing \ud835\udd5c] [AddCommGroup E] [AddCommGroup F] [AddCommGroup G]", "[Module \ud835\udd5c E] [Module \ud835\udd5c F] [Module \ud835\udd5c G]", "[TopologicalSpace E] [TopologicalSpace F] [TopologicalSpace G]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup G] [ContinuousConstSMul \ud835\udd5c G]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup G] [ContinuousConstSMul \ud835\udd5c G]", "[NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "(\ud835\udd5c E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m M N : \u2115\na : (n : \u2115) \u00d7 Composition n\n\u22a2 a \u2208 compPartialSumTarget m M N \u2194 m \u2264 a.snd.length \u2227 a.snd.length < M \u2227 \u2200 (j : Fin a.snd.length), a.snd.blocksFun j < N"}, {"line": "simp [compPartialSumTarget, compPartialSumTargetSet]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compPartialSumTarget_tendsto_atTop :\n    Tendsto (fun N => compPartialSumTarget 0 N N) atTop atTop := by\n  apply Tendsto.comp compPartialSumTarget_tendsto_prod_atTop tendsto_atTop_diagonal\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Composition.lean", "context": {"open": ["Filter List", "scoped Topology NNReal ENNReal", "FormalMultilinearSeries"], "variables": ["{\ud835\udd5c : Type*} {E F G H : Type*}", "[CommRing \ud835\udd5c] [AddCommGroup E] [AddCommGroup F] [AddCommGroup G]", "[Module \ud835\udd5c E] [Module \ud835\udd5c F] [Module \ud835\udd5c G]", "[TopologicalSpace E] [TopologicalSpace F] [TopologicalSpace G]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup G] [ContinuousConstSMul \ud835\udd5c G]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup G] [ContinuousConstSMul \ud835\udd5c G]", "[NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "(\ud835\udd5c E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Tendsto (fun N => compPartialSumTarget 0 N N) atTop atTop"}, {"line": "apply Tendsto.comp compPartialSumTarget_tendsto_prod_atTop tendsto_atTop_diagonal", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AnalyticAt.comp_of_eq' {g : F \u2192 G} {f : E \u2192 F} {y : F} {x : E} (hg : AnalyticAt \ud835\udd5c g y)\n    (hf : AnalyticAt \ud835\udd5c f x) (hy : f x = y) : AnalyticAt \ud835\udd5c (fun z \u21a6 g (f z)) x := by\n  apply hg.comp_of_eq hf hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Composition.lean", "context": {"open": ["Filter List", "scoped Topology NNReal ENNReal", "FormalMultilinearSeries", "FormalMultilinearSeries"], "variables": ["{\ud835\udd5c : Type*} {E F G H : Type*}", "[CommRing \ud835\udd5c] [AddCommGroup E] [AddCommGroup F] [AddCommGroup G]", "[Module \ud835\udd5c E] [Module \ud835\udd5c F] [Module \ud835\udd5c G]", "[TopologicalSpace E] [TopologicalSpace F] [TopologicalSpace G]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup G] [ContinuousConstSMul \ud835\udd5c G]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup G] [ContinuousConstSMul \ud835\udd5c G]", "[NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "(\ud835\udd5c E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\nF : Type u_3\nG : Type u_4\ninst\u271d\u00b9\u2075 : AddCommGroup E\ninst\u271d\u00b9\u2074 : AddCommGroup F\ninst\u271d\u00b9\u00b3 : AddCommGroup G\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalSpace F\ninst\u271d\u00b9\u2070 : TopologicalSpace G\ninst\u271d\u2079 : IsTopologicalAddGroup E\ninst\u271d\u2078 : IsTopologicalAddGroup F\ninst\u271d\u2077 : IsTopologicalAddGroup G\ninst\u271d\u2076 : IsTopologicalAddGroup E\ninst\u271d\u2075 : IsTopologicalAddGroup F\ninst\u271d\u2074 : IsTopologicalAddGroup E\ninst\u271d\u00b3 : IsTopologicalAddGroup F\ninst\u271d\u00b2 : IsTopologicalAddGroup G\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedAddCommGroup F\ng : F \u2192 G\nf : E \u2192 F\ny : F\nx : E\nhg : sorry\nhf : sorry\nhy : f x = y\n\u22a2 sorry"}, {"line": "apply hg.comp_of_eq hf hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sigma_composition_eq_iff (i j : \u03a3 a : Composition n, Composition a.length) :\n    i = j \u2194 i.1.blocks = j.1.blocks \u2227 i.2.blocks = j.2.blocks := by\n  refine \u27e8by rintro rfl; exact \u27e8rfl, rfl\u27e9, ?_\u27e9\n  rcases i with \u27e8a, b\u27e9\n  rcases j with \u27e8a', b'\u27e9\n  rintro \u27e8h, h'\u27e9\n  obtain rfl : a = a' := by ext1; exact h\n  obtain rfl : b = b' := by ext1; exact h'\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Composition.lean", "context": {"open": ["Filter List", "scoped Topology NNReal ENNReal", "FormalMultilinearSeries", "FormalMultilinearSeries"], "variables": ["{\ud835\udd5c : Type*} {E F G H : Type*}", "[CommRing \ud835\udd5c] [AddCommGroup E] [AddCommGroup F] [AddCommGroup G]", "[Module \ud835\udd5c E] [Module \ud835\udd5c F] [Module \ud835\udd5c G]", "[TopologicalSpace E] [TopologicalSpace F] [TopologicalSpace G]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup G] [ContinuousConstSMul \ud835\udd5c G]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]", "[IsTopologicalAddGroup F] [ContinuousConstSMul \ud835\udd5c F]", "[IsTopologicalAddGroup G] [ContinuousConstSMul \ud835\udd5c G]", "[NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "(\ud835\udd5c E)", "{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni j : (a : Composition n) \u00d7 Composition a.length\n\u22a2 i = j \u2194 i.fst.blocks = j.fst.blocks \u2227 i.snd.blocks = j.snd.blocks"}, {"line": "refine \u27e8by rintro rfl; exact \u27e8rfl, rfl\u27e9, ?_\u27e9", "tactic_state": "n : \u2115\ni j : (a : Composition n) \u00d7 Composition a.length\n\u22a2 i.fst.blocks = j.fst.blocks \u2227 i.snd.blocks = j.snd.blocks \u2192 i = j"}, {"line": "rcases i with \u27e8a, b\u27e9", "tactic_state": "case mk\nn : \u2115\nj : (a : Composition n) \u00d7 Composition a.length\na : Composition n\nb : Composition a.length\n\u22a2 \u27e8a, b\u27e9.fst.blocks = j.fst.blocks \u2227 \u27e8a, b\u27e9.snd.blocks = j.snd.blocks \u2192 \u27e8a, b\u27e9 = j"}, {"line": "rcases j with \u27e8a', b'\u27e9", "tactic_state": "case mk.mk\nn : \u2115\na : Composition n\nb : Composition a.length\na' : Composition n\nb' : Composition a'.length\n\u22a2 \u27e8a, b\u27e9.fst.blocks = \u27e8a', b'\u27e9.fst.blocks \u2227 \u27e8a, b\u27e9.snd.blocks = \u27e8a', b'\u27e9.snd.blocks \u2192 \u27e8a, b\u27e9 = \u27e8a', b'\u27e9"}, {"line": "rintro \u27e8h, h'\u27e9", "tactic_state": "case mk.mk.intro\nn : \u2115\na : Composition n\nb : Composition a.length\na' : Composition n\nb' : Composition a'.length\nh : \u27e8a, b\u27e9.fst.blocks = \u27e8a', b'\u27e9.fst.blocks\nh' : \u27e8a, b\u27e9.snd.blocks = \u27e8a', b'\u27e9.snd.blocks\n\u22a2 \u27e8a, b\u27e9 = \u27e8a', b'\u27e9"}, {"line": "obtain rfl : a = a' := by ext1; exact h", "tactic_state": "case mk.mk.intro\nn : \u2115\na : Composition n\nb b' : Composition a.length\nh : \u27e8a, b\u27e9.fst.blocks = \u27e8a, b'\u27e9.fst.blocks\nh' : \u27e8a, b\u27e9.snd.blocks = \u27e8a, b'\u27e9.snd.blocks\n\u22a2 \u27e8a, b\u27e9 = \u27e8a, b'\u27e9"}, {"line": "obtain rfl : b = b' := by ext1; exact h'", "tactic_state": "case mk.mk.intro\nn : \u2115\na : Composition n\nb : Composition a.length\nh : \u27e8a, b\u27e9.fst.blocks = \u27e8a, b\u27e9.fst.blocks\nh' : \u27e8a, b\u27e9.snd.blocks = \u27e8a, b\u27e9.snd.blocks\n\u22a2 \u27e8a, b\u27e9 = \u27e8a, b\u27e9"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AnalyticAt.fun_sub (hf : AnalyticAt \ud835\udd5c f x) (hg : AnalyticAt \ud835\udd5c g x) :\n    AnalyticAt \ud835\udd5c (fun z \u21a6 f z - g z) x := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Constructions.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics ENNReal NNReal"], "variables": ["{\u03b1 : Type*}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E F G H : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "{\ud835\udd5d : Type*} [NontriviallyNormedField \ud835\udd5d] [NormedAlgebra \ud835\udd5c \ud835\udd5d]", "{A : Type*} [NormedRing A] [NormedAlgebra \ud835\udd5c A]", "{f g : E \u2192 F} {pf pg : FormalMultilinearSeries \ud835\udd5c E F} {s : Set E} {x : E} {r : \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "hf : sorry\nhg : sorry\n\u22a2 sorry"}, {"line": "simpa only [sub_eq_add_neg] using hf.add hg.neg", "tactic_state": "No Goals!"}]}
{"declaration": "lemma AnalyticAt.fun_pow {f : E \u2192 A} {z : E} (hf : AnalyticAt \ud835\udd5c f z) (n : \u2115) :\n    AnalyticAt \ud835\udd5c (fun x \u21a6 f x ^ n) z := by\n  rw [\u2190 analyticWithinAt_univ] at hf \u22a2\n  exact hf.pow n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Constructions.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics ENNReal NNReal"], "variables": ["{\u03b1 : Type*}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E F G H : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "{\ud835\udd5d : Type*} [NontriviallyNormedField \ud835\udd5d] [NormedAlgebra \ud835\udd5c \ud835\udd5d]", "{A : Type*} [NormedRing A] [NormedAlgebra \ud835\udd5c A]", "{f g : E \u2192 F} {pf pg : FormalMultilinearSeries \ud835\udd5c E F} {s : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\u03b9 : Type*} [Fintype \u03b9] {e : E} {Fm : \u03b9 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_2\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nA : Type u_8\ninst\u271d\u00b9 : NormedRing A\ninst\u271d : NormedAlgebra \ud835\udd5c A\nf : E \u2192 A\nz : E\nhf : AnalyticAt \ud835\udd5c f z\nn : \u2115\n\u22a2 AnalyticAt \ud835\udd5c (fun x => f x ^ n) z"}, {"line": "rw [\u2190 analyticWithinAt_univ] at hf \u22a2", "tactic_state": "\ud835\udd5c : Type u_2\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nA : Type u_8\ninst\u271d\u00b9 : NormedRing A\ninst\u271d : NormedAlgebra \ud835\udd5c A\nf : E \u2192 A\nz : E\nhf : AnalyticWithinAt \ud835\udd5c f Set.univ z\nn : \u2115\n\u22a2 AnalyticWithinAt \ud835\udd5c (fun x => f x ^ n) Set.univ z"}, {"line": "exact hf.pow n", "tactic_state": "No Goals!"}]}
{"declaration": "lemma AnalyticWithinAt.fun_zpow_nonneg {f : E \u2192 \ud835\udd5d} {z : E} {s : Set E} {n : \u2124}\n    (hf : AnalyticWithinAt \ud835\udd5c f s z) (hn : 0 \u2264 n) :\n    AnalyticWithinAt \ud835\udd5c (fun x \u21a6 f x ^ n) s z := by\n  simpa [\u2190 zpow_natCast, hn] using hf.pow n.toNat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Constructions.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics ENNReal NNReal"], "variables": ["{\u03b1 : Type*}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E F G H : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "{\ud835\udd5d : Type*} [NontriviallyNormedField \ud835\udd5d] [NormedAlgebra \ud835\udd5c \ud835\udd5d]", "{A : Type*} [NormedRing A] [NormedAlgebra \ud835\udd5c A]", "{f g : E \u2192 F} {pf pg : FormalMultilinearSeries \ud835\udd5c E F} {s : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\u03b9 : Type*} [Fintype \u03b9] {e : E} {Fm : \u03b9 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_2\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\n\ud835\udd5d : Type u_7\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5d\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd5d\nf : E \u2192 \ud835\udd5d\nz : E\ns : Set E\nn : \u2124\nhf : AnalyticWithinAt \ud835\udd5c f s z\nhn : 0 \u2264 n\n\u22a2 AnalyticWithinAt \ud835\udd5c (fun x => f x ^ n) s z"}, {"line": "simpa [\u2190 zpow_natCast, hn] using hf.pow n.toNat", "tactic_state": "No Goals!"}]}
{"declaration": "lemma AnalyticAt.fun_zpow_nonneg {f : E \u2192 \ud835\udd5d} {z : E} {n : \u2124} (hf : AnalyticAt \ud835\udd5c f z) (hn : 0 \u2264 n) :\n    AnalyticAt \ud835\udd5c (fun x \u21a6 f x ^ n) z := by\n  simpa [\u2190 zpow_natCast, hn] using hf.pow n.toNat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Constructions.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics ENNReal NNReal"], "variables": ["{\u03b1 : Type*}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E F G H : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "{\ud835\udd5d : Type*} [NontriviallyNormedField \ud835\udd5d] [NormedAlgebra \ud835\udd5c \ud835\udd5d]", "{A : Type*} [NormedRing A] [NormedAlgebra \ud835\udd5c A]", "{f g : E \u2192 F} {pf pg : FormalMultilinearSeries \ud835\udd5c E F} {s : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\u03b9 : Type*} [Fintype \u03b9] {e : E} {Fm : \u03b9 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_2\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\n\ud835\udd5d : Type u_7\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5d\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd5d\nf : E \u2192 \ud835\udd5d\nz : E\nn : \u2124\nhf : AnalyticAt \ud835\udd5c f z\nhn : 0 \u2264 n\n\u22a2 AnalyticAt \ud835\udd5c (fun x => f x ^ n) z"}, {"line": "simpa [\u2190 zpow_natCast, hn] using hf.pow n.toNat", "tactic_state": "No Goals!"}]}
{"declaration": "lemma AnalyticOn.fun_zpow_nonneg {f : E \u2192 \ud835\udd5d} {s : Set E} {n : \u2124} (hf : AnalyticOn \ud835\udd5c f s)\n    (hn : 0 \u2264 n) :\n    AnalyticOn \ud835\udd5c (fun x \u21a6 f x ^ n) s := by\n  simpa [\u2190 zpow_natCast, hn] using hf.pow n.toNat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Constructions.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics ENNReal NNReal"], "variables": ["{\u03b1 : Type*}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E F G H : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "{\ud835\udd5d : Type*} [NontriviallyNormedField \ud835\udd5d] [NormedAlgebra \ud835\udd5c \ud835\udd5d]", "{A : Type*} [NormedRing A] [NormedAlgebra \ud835\udd5c A]", "{f g : E \u2192 F} {pf pg : FormalMultilinearSeries \ud835\udd5c E F} {s : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\u03b9 : Type*} [Fintype \u03b9] {e : E} {Fm : \u03b9 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_2\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\n\ud835\udd5d : Type u_7\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5d\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd5d\nf : E \u2192 \ud835\udd5d\ns : Set E\nn : \u2124\nhf : AnalyticOn \ud835\udd5c f s\nhn : 0 \u2264 n\n\u22a2 AnalyticOn \ud835\udd5c (fun x => f x ^ n) s"}, {"line": "simpa [\u2190 zpow_natCast, hn] using hf.pow n.toNat", "tactic_state": "No Goals!"}]}
{"declaration": "lemma AnalyticOnNhd.fun_zpow_nonneg {f : E \u2192 \ud835\udd5d} {s : Set E} {n : \u2124} (hf : AnalyticOnNhd \ud835\udd5c f s)\n    (hn : 0 \u2264 n) :\n    AnalyticOnNhd \ud835\udd5c (fun x \u21a6 f x ^ n) s := by\n  simp_rw [(Eq.symm (Int.toNat_of_nonneg hn) : n = OfNat.ofNat n.toNat), zpow_ofNat]\n  apply pow hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Constructions.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics ENNReal NNReal"], "variables": ["{\u03b1 : Type*}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E F G H : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "{\ud835\udd5d : Type*} [NontriviallyNormedField \ud835\udd5d] [NormedAlgebra \ud835\udd5c \ud835\udd5d]", "{A : Type*} [NormedRing A] [NormedAlgebra \ud835\udd5c A]", "{f g : E \u2192 F} {pf pg : FormalMultilinearSeries \ud835\udd5c E F} {s : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\u03b9 : Type*} [Fintype \u03b9] {e : E} {Fm : \u03b9 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_2\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\n\ud835\udd5d : Type u_7\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5d\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd5d\nf : E \u2192 \ud835\udd5d\ns : Set E\nn : \u2124\nhf : AnalyticOnNhd \ud835\udd5c f s\nhn : 0 \u2264 n\n\u22a2 AnalyticOnNhd \ud835\udd5c (fun x => f x ^ n) s"}, {"line": "simp_rw [(Eq.symm (Int.toNat_of_nonneg hn) : n = OfNat.ofNat n.toNat), zpow_ofNat]", "tactic_state": "\ud835\udd5c : Type u_2\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\n\ud835\udd5d : Type u_7\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5d\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd5d\nf : E \u2192 \ud835\udd5d\ns : Set E\nn : \u2124\nhf : AnalyticOnNhd \ud835\udd5c f s\nhn : 0 \u2264 n\n\u22a2 AnalyticOnNhd \ud835\udd5c (fun x => f x ^ OfNat.ofNat n.toNat) s"}, {"line": "apply pow hf", "tactic_state": "No Goals!"}]}
{"declaration": "lemma HasFPowerSeriesWithinAt.restrictScalars (hf : HasFPowerSeriesWithinAt f p s x) :\n    HasFPowerSeriesWithinAt f (p.restrictScalars \ud835\udd5c) s x := by\n  rcases hf with \u27e8r, hr\u27e9\n  exact \u27e8r, hr.restrictScalars\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Constructions.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics ENNReal NNReal"], "variables": ["{\u03b1 : Type*}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E F G H : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "{\ud835\udd5d : Type*} [NontriviallyNormedField \ud835\udd5d] [NormedAlgebra \ud835\udd5c \ud835\udd5d]", "{A : Type*} [NormedRing A] [NormedAlgebra \ud835\udd5c A]", "{f g : E \u2192 F} {pf pg : FormalMultilinearSeries \ud835\udd5c E F} {s : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\u03b9 : Type*} [Fintype \u03b9] {e : E} {Fm : \u03b9 \u2192 Type*}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\nF : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedAddCommGroup F\nf : E \u2192 F\ns : Set E\nx : E\n\u03b1\u271d : Type u_12\nself\u271d\u00b2 : NontriviallyNormedField \u03b1\u271d\nself\u271d\u00b9 : NormedSpace \u03b1\u271d E\nself\u271d : NormedSpace \u03b1\u271d F\np : FormalMultilinearSeries \u03b1\u271d E F\nhf : HasFPowerSeriesWithinAt f p s x\n\u22a2 sorry"}, {"line": "rcases hf with \u27e8r, hr\u27e9", "tactic_state": "case intro\nE : Type u_3\nF : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedAddCommGroup F\nf : E \u2192 F\ns : Set E\nx : E\n\u03b1\u271d : Type u_12\nself\u271d\u00b2 : NontriviallyNormedField \u03b1\u271d\nself\u271d\u00b9 : NormedSpace \u03b1\u271d E\nself\u271d : NormedSpace \u03b1\u271d F\np : FormalMultilinearSeries \u03b1\u271d E F\nr : ENNReal\nhr : HasFPowerSeriesWithinOnBall f p s x r\n\u22a2 sorry"}, {"line": "exact \u27e8r, hr.restrictScalars\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma HasFPowerSeriesAt.restrictScalars (hf : HasFPowerSeriesAt f p x) :\n    HasFPowerSeriesAt f (p.restrictScalars \ud835\udd5c) x := by\n  rcases hf with \u27e8r, hr\u27e9\n  exact \u27e8r, hr.restrictScalars\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Constructions.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics ENNReal NNReal"], "variables": ["{\u03b1 : Type*}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E F G H : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "{\ud835\udd5d : Type*} [NontriviallyNormedField \ud835\udd5d] [NormedAlgebra \ud835\udd5c \ud835\udd5d]", "{A : Type*} [NormedRing A] [NormedAlgebra \ud835\udd5c A]", "{f g : E \u2192 F} {pf pg : FormalMultilinearSeries \ud835\udd5c E F} {s : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\u03b9 : Type*} [Fintype \u03b9] {e : E} {Fm : \u03b9 \u2192 Type*}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\nF : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedAddCommGroup F\nf : E \u2192 F\nx : E\n\u03b1\u271d : Type u_12\nself\u271d\u00b2 : NontriviallyNormedField \u03b1\u271d\nself\u271d\u00b9 : NormedSpace \u03b1\u271d E\nself\u271d : NormedSpace \u03b1\u271d F\np : FormalMultilinearSeries \u03b1\u271d E F\nhf : HasFPowerSeriesAt f p x\n\u22a2 sorry"}, {"line": "rcases hf with \u27e8r, hr\u27e9", "tactic_state": "case intro\nE : Type u_3\nF : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedAddCommGroup F\nf : E \u2192 F\nx : E\n\u03b1\u271d : Type u_12\nself\u271d\u00b2 : NontriviallyNormedField \u03b1\u271d\nself\u271d\u00b9 : NormedSpace \u03b1\u271d E\nself\u271d : NormedSpace \u03b1\u271d F\np : FormalMultilinearSeries \u03b1\u271d E F\nr : ENNReal\nhr : HasFPowerSeriesOnBall f p x r\n\u22a2 sorry"}, {"line": "exact \u27e8r, hr.restrictScalars\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma AnalyticAt.zpow {f : E \u2192 \ud835\udd5d} {z : E} {n : \u2124} (h\u2081f : AnalyticAt \ud835\udd5c f z) (h\u2082f : f z \u2260 0) :\n    AnalyticAt \ud835\udd5c (f ^ n) z := by\n  exact fun_zpow h\u2081f h\u2082f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Constructions.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics ENNReal NNReal"], "variables": ["{\u03b1 : Type*}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E F G H : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "{\ud835\udd5d : Type*} [NontriviallyNormedField \ud835\udd5d] [NormedAlgebra \ud835\udd5c \ud835\udd5d]", "{A : Type*} [NormedRing A] [NormedAlgebra \ud835\udd5c A]", "{f g : E \u2192 F} {pf pg : FormalMultilinearSeries \ud835\udd5c E F} {s : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\u03b9 : Type*} [Fintype \u03b9] {e : E} {Fm : \u03b9 \u2192 Type*}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c']", "(\ud835\udd5c A : Type*) [NontriviallyNormedField \ud835\udd5c] [NormedRing A] [NormedAlgebra \ud835\udd5c A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\n\ud835\udd5d : Type u_7\ninst\u271d : NontriviallyNormedField \ud835\udd5d\nf : E \u2192 \ud835\udd5d\nz : E\nn : \u2124\nh\u2081f : sorry\nh\u2082f : f z \u2260 0\n\u22a2 sorry"}, {"line": "exact fun_zpow h\u2081f h\u2082f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma AnalyticOn.zpow {f : E \u2192 \ud835\udd5d} {s : Set E} {n : \u2124}  (h\u2081f : AnalyticOn \ud835\udd5c f s)\n    (h\u2082f : \u2200 z \u2208 s, f z \u2260 0) :\n    AnalyticOn \ud835\udd5c (f ^ n) s := by\n  exact fun_zpow h\u2081f h\u2082f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Constructions.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics ENNReal NNReal"], "variables": ["{\u03b1 : Type*}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E F G H : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "{\ud835\udd5d : Type*} [NontriviallyNormedField \ud835\udd5d] [NormedAlgebra \ud835\udd5c \ud835\udd5d]", "{A : Type*} [NormedRing A] [NormedAlgebra \ud835\udd5c A]", "{f g : E \u2192 F} {pf pg : FormalMultilinearSeries \ud835\udd5c E F} {s : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\u03b9 : Type*} [Fintype \u03b9] {e : E} {Fm : \u03b9 \u2192 Type*}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c']", "(\ud835\udd5c A : Type*) [NontriviallyNormedField \ud835\udd5c] [NormedRing A] [NormedAlgebra \ud835\udd5c A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\n\ud835\udd5d : Type u_7\ninst\u271d : NontriviallyNormedField \ud835\udd5d\nf : E \u2192 \ud835\udd5d\ns : Set E\nn : \u2124\nh\u2081f : sorry\nh\u2082f : \u2200 z \u2208 s, f z \u2260 0\n\u22a2 sorry"}, {"line": "exact fun_zpow h\u2081f h\u2082f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasSum_at_zero (a : \u2115 \u2192 E) : HasSum (fun n => (0 : \ud835\udd5c) ^ n \u2022 a n) (a 0) := by\n  convert hasSum_single (\u03b1 := E) 0 fun b h \u21a6 _ <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/IsolatedZeros.lean", "context": {"open": ["Filter Function Nat FormalMultilinearSeries EMetric Set", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {E : Type*} [NormedAddCommGroup E]", "{a : \u2115 \u2192 E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d : NormedAddCommGroup E\na : \u2115 \u2192 E\n\u22a2 HasSum (fun n => sorry) (a 0)"}, {"line": "convert hasSum_single (\u03b1 := E) 0 fun b h \u21a6 _ <;> simp [*]", "tactic_state": "case h.e'_6\nE : Type u_2\ninst\u271d : NormedAddCommGroup E\na : \u2115 \u2192 E\n\u22a2 a 0 = sorry ()\n---\ncase convert_4\nE : Type u_2\ninst\u271d : NormedAddCommGroup E\na : \u2115 \u2192 E\nb : \u2115\nh : b \u2260 0\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem ofScalars_series_eq_zero [Nontrivial E] : ofScalars E c = 0 \u2194 c = 0 := by\n  simp [FormalMultilinearSeries.ext_iff, funext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/OfScalars.lean", "context": {"open": ["ContinuousMultilinearMap"], "variables": ["{\ud835\udd5c : Type*} (E : Type*) [Field \ud835\udd5c] [Ring E] [Algebra \ud835\udd5c E] [TopologicalSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : TopologicalSpace E\nx\u271d : Sort u_3\nofScalars : x\u271d\nc : \u2115\ninst\u271d : Nontrivial E\n\u22a2 sorry = 0 \u2194 c = 0"}, {"line": "simp [FormalMultilinearSeries.ext_iff, funext_iff]", "tactic_state": "E : Type u_2\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : TopologicalSpace E\nx\u271d : Sort u_3\nofScalars : x\u271d\nc : \u2115\ninst\u271d : Nontrivial E\n\u22a2 sorry () = 0 \u2194 c = 0"}]}
{"declaration": "theorem ofScalars_series_eq_zero_of_scalar_zero : ofScalars E (0 : \u2115 \u2192 \ud835\udd5c) = 0 := by\n  simp [FormalMultilinearSeries.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/OfScalars.lean", "context": {"open": ["ContinuousMultilinearMap"], "variables": ["{\ud835\udd5c : Type*} (E : Type*) [Field \ud835\udd5c] [Ring E] [Algebra \ud835\udd5c E] [TopologicalSpace E]", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nofScalars : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [FormalMultilinearSeries.ext_iff]", "tactic_state": "x\u271d : Sort u_3\nofScalars : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma coeff_ofScalars {\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {p : \u2115 \u2192 \ud835\udd5c} {n : \u2115} :\n    (FormalMultilinearSeries.ofScalars \ud835\udd5c p).coeff n = p n := by\n  simp [FormalMultilinearSeries.coeff, FormalMultilinearSeries.ofScalars, List.prod_ofFn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/OfScalars.lean", "context": {"open": ["ContinuousMultilinearMap"], "variables": ["{\ud835\udd5c : Type*} (E : Type*) [Field \ud835\udd5c] [Ring E] [Algebra \ud835\udd5c E] [TopologicalSpace E]", "(\ud835\udd5c) in", "(\ud835\udd5c) in", "(c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_3\ninst\u271d : NontriviallyNormedField \ud835\udd5c\np : \u2115 \u2192 \ud835\udd5c\nn : \u2115\n\u22a2 (FormalMultilinearSeries.ofScalars \ud835\udd5c p).coeff n = p n"}, {"line": "simp [FormalMultilinearSeries.coeff, FormalMultilinearSeries.ofScalars, List.prod_ofFn]", "tactic_state": "\ud835\udd5c : Type u_3\ninst\u271d : NontriviallyNormedField \ud835\udd5c\np : \u2115 \u2192 \ud835\udd5c\nn : \u2115\n\u22a2 p n * (List.ofFn 1).prod = p n"}]}
{"declaration": "theorem ofScalarsSum_zero : ofScalarsSum c (0 : E) = c 0 \u2022 1 := by\n  simp [ofScalarsSum_eq_tsum, \u2190 ofScalars_apply_eq, ofScalars_apply_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/OfScalars.lean", "context": {"open": ["ContinuousMultilinearMap"], "variables": ["{\ud835\udd5c : Type*} (E : Type*) [Field \ud835\udd5c] [Ring E] [Algebra \ud835\udd5c E] [TopologicalSpace E]", "(\ud835\udd5c) in", "(\ud835\udd5c) in", "(c)", "(\ud835\udd5c) in", "{E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_3\nofScalarsSum : x\u271d\u00b9\nx\u271d : Sort u_4\nc : x\u271d\n\u22a2 sorry = sorry \u2022 1"}, {"line": "simp [ofScalarsSum_eq_tsum, \u2190 ofScalars_apply_eq, ofScalars_apply_zero]", "tactic_state": "x\u271d\u00b9 : Sort u_3\nofScalarsSum : x\u271d\u00b9\nx\u271d : Sort u_4\nc : x\u271d\n\u22a2 sorry () = sorry () \u2022 1"}]}
{"declaration": "theorem ofScalarsSum_of_subsingleton [Subsingleton E] {x : E} : ofScalarsSum c x = 0 := by\n  simp [Subsingleton.eq_zero x, Subsingleton.eq_zero (1 : E)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/OfScalars.lean", "context": {"open": ["ContinuousMultilinearMap"], "variables": ["{\ud835\udd5c : Type*} (E : Type*) [Field \ud835\udd5c] [Ring E] [Algebra \ud835\udd5c E] [TopologicalSpace E]", "(\ud835\udd5c) in", "(\ud835\udd5c) in", "(c)", "(\ud835\udd5c) in", "{E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : TopologicalSpace E\nx\u271d : Sort u_3\nofScalarsSum : x\u271d\ninst\u271d : Subsingleton E\nx : E\n\u22a2 sorry = 0"}, {"line": "simp [Subsingleton.eq_zero x, Subsingleton.eq_zero (1 : E)]", "tactic_state": "E : Type u_2\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : TopologicalSpace E\nx\u271d : Sort u_3\nofScalarsSum : x\u271d\ninst\u271d : Subsingleton E\nx : E\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem ofScalars_norm [NormOneClass E] : \u2016ofScalars E c n\u2016 = \u2016c n\u2016 := by\n  simp [ofScalars_norm_eq_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/OfScalars.lean", "context": {"open": ["ContinuousMultilinearMap", "Filter ENNReal", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} (E : Type*) [Field \ud835\udd5c] [Ring E] [Algebra \ud835\udd5c E] [TopologicalSpace E]", "(\ud835\udd5c) in", "(\ud835\udd5c) in", "(c)", "(\ud835\udd5c) in", "{E}", "{\ud835\udd5c : Type*} (E : Type*) [NontriviallyNormedField \ud835\udd5c] [SeminormedRing E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_4\ninst\u271d\u00b9 : SeminormedRing E\nx\u271d\u00b9 : Sort u_5\nofScalars : x\u271d\u00b9\nx\u271d : Sort u_6\nc : x\u271d\ninst\u271d : NormOneClass E\n\u22a2 \u2016sorry\u2016 = \u2016sorry\u2016"}, {"line": "simp [ofScalars_norm_eq_mul]", "tactic_state": "E : Type u_4\ninst\u271d\u00b9 : SeminormedRing E\nx\u271d\u00b9 : Sort u_5\nofScalars : x\u271d\u00b9\nx\u271d : Sort u_6\nc : x\u271d\ninst\u271d : NormOneClass E\n\u22a2 \u2016sorry ()\u2016 = \u2016sorry ()\u2016"}]}
{"declaration": "theorem order_pow {f : \ud835\udd5c \u2192 \ud835\udd5c} (hf : AnalyticAt \ud835\udd5c f z\u2080) {n : \u2115} :\n    (hf.pow n).order = n \u2022 hf.order := by\n  induction n\n  case zero =>\n    simp [AnalyticAt.order_eq_zero_iff]\n  case succ n hn =>\n    simp [add_mul, pow_add, (hf.pow n).order_mul hf, hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Analytic/Order.lean", "context": {"open": ["Filter  Set", "scoped Topology", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nz\u2080 : \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : sorry\nn : \u2115\n\u22a2 sorry = n \u2022 sorry"}, {"line": "induction n", "tactic_state": "case zero\n\ud835\udd5c : Type u_1\nz\u2080 : \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : sorry\n\u22a2 sorry = 0 \u2022 sorry\n---\ncase succ\n\ud835\udd5c : Type u_1\nz\u2080 : \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : sorry\nn\u271d : \u2115\na\u271d : sorry = n\u271d \u2022 sorry\n\u22a2 sorry = (n\u271d + 1) \u2022 sorry"}, {"line": "case zero =>\n    simp [AnalyticAt.order_eq_zero_iff]", "tactic_state": "case succ\n\ud835\udd5c : Type u_1\nz\u2080 : \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : sorry\nn\u271d : \u2115\na\u271d : sorry = n\u271d \u2022 sorry\n\u22a2 sorry = (n\u271d + 1) \u2022 sorry"}, {"line": "case succ n hn =>\n    simp [add_mul, pow_add, (hf.pow n).order_mul hf, hn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isTheta_bot : f =\u0398[\u22a5] g := by simp [IsTheta]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Theta.lean", "context": {"open": ["Filter", "Topology"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "[NormedField \ud835\udd5c] [NormedField \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''}", "{l l' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_3\nF : Type u_4\ninst\u271d\u00b9 : Norm E\ninst\u271d : Norm F\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\n\u22a2 f =\u0398[\u22a5] g"}, {"line": "simp [IsTheta]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isTheta_norm_left : (fun x \u21a6 \u2016f' x\u2016) =\u0398[l] g \u2194 f' =\u0398[l] g := by simp [IsTheta]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Theta.lean", "context": {"open": ["Filter", "Topology"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "[NormedField \ud835\udd5c] [NormedField \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''}", "{l l' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nF : Type u_4\nE' : Type u_6\ninst\u271d\u00b9 : Norm F\ninst\u271d : SeminormedAddCommGroup E'\ng : \u03b1 \u2192 F\nf' : \u03b1 \u2192 E'\nl : Filter \u03b1\n\u22a2 (fun x => \u2016f' x\u2016) =\u0398[l] g \u2194 f' =\u0398[l] g"}, {"line": "simp [IsTheta]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isTheta_norm_right : (f =\u0398[l] fun x \u21a6 \u2016g' x\u2016) \u2194 f =\u0398[l] g' := by simp [IsTheta]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Theta.lean", "context": {"open": ["Filter", "Topology"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "[NormedField \ud835\udd5c] [NormedField \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''}", "{l l' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F' : Type u_7\n\u03b1 : Type u_1\nE : Type u_3\ninst\u271d\u00b9 : Norm E\ninst\u271d : SeminormedAddCommGroup F'\nf : \u03b1 \u2192 E\ng' : \u03b1 \u2192 F'\nl : Filter \u03b1\n\u22a2 (f =\u0398[l] fun x => \u2016g' x\u2016) \u2194 f =\u0398[l] g'"}, {"line": "simp [IsTheta]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsTheta.div {f\u2081 f\u2082 : \u03b1 \u2192 \ud835\udd5c} {g\u2081 g\u2082 : \u03b1 \u2192 \ud835\udd5c'} (h\u2081 : f\u2081 =\u0398[l] g\u2081) (h\u2082 : f\u2082 =\u0398[l] g\u2082) :\n    (fun x \u21a6 f\u2081 x / f\u2082 x) =\u0398[l] fun x \u21a6 g\u2081 x / g\u2082 x := by\n  simpa only [div_eq_mul_inv] using h\u2081.mul h\u2082.inv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Theta.lean", "context": {"open": ["Filter", "Topology"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "[NormedField \ud835\udd5c] [NormedField \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''}", "{l l' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_7\n\ud835\udd5c' : Type u_8\n\u03b1 : Type u_1\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : NormedField \ud835\udd5c'\nl : Filter \u03b1\nf\u2081 f\u2082 : \u03b1 \u2192 \ud835\udd5c\ng\u2081 g\u2082 : \u03b1 \u2192 \ud835\udd5c'\nh\u2081 : f\u2081 =\u0398[l] g\u2081\nh\u2082 : f\u2082 =\u0398[l] g\u2082\n\u22a2 (fun x => f\u2081 x / f\u2082 x) =\u0398[l] fun x => g\u2081 x / g\u2082 x"}, {"line": "simpa only [div_eq_mul_inv] using h\u2081.mul h\u2082.inv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsTheta.zpow {f : \u03b1 \u2192 \ud835\udd5c} {g : \u03b1 \u2192 \ud835\udd5c'} (h : f =\u0398[l] g) (n : \u2124) :\n    (fun x \u21a6 f x ^ n) =\u0398[l] fun x \u21a6 g x ^ n := by\n  cases n\n  \u00b7 simpa only [Int.ofNat_eq_coe,zpow_natCast] using h.pow _\n  \u00b7 simpa only [zpow_negSucc] using (h.pow _).inv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Theta.lean", "context": {"open": ["Filter", "Topology"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "[NormedField \ud835\udd5c] [NormedField \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''}", "{l l' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_7\n\ud835\udd5c' : Type u_8\n\u03b1 : Type u_1\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : NormedField \ud835\udd5c'\nl : Filter \u03b1\nf : \u03b1 \u2192 \ud835\udd5c\ng : \u03b1 \u2192 \ud835\udd5c'\nh : f =\u0398[l] g\nn : \u2124\n\u22a2 (fun x => f x ^ n) =\u0398[l] fun x => g x ^ n"}, {"line": "cases n", "tactic_state": "case ofNat\n\ud835\udd5c : Type u_7\n\ud835\udd5c' : Type u_8\n\u03b1 : Type u_1\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : NormedField \ud835\udd5c'\nl : Filter \u03b1\nf : \u03b1 \u2192 \ud835\udd5c\ng : \u03b1 \u2192 \ud835\udd5c'\nh : f =\u0398[l] g\na\u271d : \u2115\n\u22a2 (fun x => f x ^ Int.ofNat a\u271d) =\u0398[l] fun x => g x ^ Int.ofNat a\u271d\n---\ncase negSucc\n\ud835\udd5c : Type u_7\n\ud835\udd5c' : Type u_8\n\u03b1 : Type u_1\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : NormedField \ud835\udd5c'\nl : Filter \u03b1\nf : \u03b1 \u2192 \ud835\udd5c\ng : \u03b1 \u2192 \ud835\udd5c'\nh : f =\u0398[l] g\na\u271d : \u2115\n\u22a2 (fun x => f x ^ Int.negSucc a\u271d) =\u0398[l] fun x => g x ^ Int.negSucc a\u271d"}, {"line": "\u00b7 simpa only [Int.ofNat_eq_coe,zpow_natCast] using h.pow _", "tactic_state": "case negSucc\n\ud835\udd5c : Type u_7\n\ud835\udd5c' : Type u_8\n\u03b1 : Type u_1\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : NormedField \ud835\udd5c'\nl : Filter \u03b1\nf : \u03b1 \u2192 \ud835\udd5c\ng : \u03b1 \u2192 \ud835\udd5c'\nh : f =\u0398[l] g\na\u271d : \u2115\n\u22a2 (fun x => f x ^ Int.negSucc a\u271d) =\u0398[l] fun x => g x ^ Int.negSucc a\u271d"}, {"line": "\u00b7 simpa only [zpow_negSucc] using (h.pow _).inv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isTheta_const_mul_left {c : \ud835\udd5c} {f : \u03b1 \u2192 \ud835\udd5c} (hc : c \u2260 0) :\n    (fun x \u21a6 c * f x) =\u0398[l] g \u2194 f =\u0398[l] g := by\n  simpa only [\u2190 smul_eq_mul] using isTheta_const_smul_left hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Theta.lean", "context": {"open": ["Filter", "Topology"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "[NormedField \ud835\udd5c] [NormedField \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''}", "{l l' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_7\n\u03b1 : Type u_1\nF : Type u_4\ninst\u271d\u00b9 : Norm F\ninst\u271d : NormedField \ud835\udd5c\ng : \u03b1 \u2192 F\nl : Filter \u03b1\nc : \ud835\udd5c\nf : \u03b1 \u2192 \ud835\udd5c\nhc : c \u2260 0\n\u22a2 (fun x => c * f x) =\u0398[l] g \u2194 f =\u0398[l] g"}, {"line": "simpa only [\u2190 smul_eq_mul] using isTheta_const_smul_left hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isTheta_const_mul_right {c : \ud835\udd5c} {g : \u03b1 \u2192 \ud835\udd5c} (hc : c \u2260 0) :\n    (f =\u0398[l] fun x \u21a6 c * g x) \u2194 f =\u0398[l] g := by\n  simpa only [\u2190 smul_eq_mul] using isTheta_const_smul_right hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Theta.lean", "context": {"open": ["Filter", "Topology"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "[NormedField \ud835\udd5c] [NormedField \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''}", "{l l' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_7\n\u03b1 : Type u_1\nE : Type u_3\ninst\u271d\u00b9 : Norm E\ninst\u271d : NormedField \ud835\udd5c\nf : \u03b1 \u2192 E\nl : Filter \u03b1\nc : \ud835\udd5c\ng : \u03b1 \u2192 \ud835\udd5c\nhc : c \u2260 0\n\u22a2 (f =\u0398[l] fun x => c * g x) \u2194 f =\u0398[l] g"}, {"line": "simpa only [\u2190 smul_eq_mul] using isTheta_const_smul_right hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsEquivalent.multisetProd {s : Multiset \u03b9} {f g : \u03b9 \u2192 \u03b1 \u2192 \u03b2} (h : \u2200 i \u2208 s, f i ~[l] g i) :\n    (fun x \u21a6 (s.map (f \u00b7 x)).prod) ~[l] (fun x \u21a6 (s.map (g \u00b7 x)).prod) := by\n  obtain \u27e8l, rfl\u27e9 : \u2203 l : List \u03b9, \u2191l = s := Quotient.mk_surjective s\n  exact listProd h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/AsymptoticEquivalent.lean", "context": {"open": ["Filter Function", "Topology", "Asymptotics"], "variables": ["{\u03b1 \u03b2 : Type*} [NormedAddCommGroup \u03b2]", "{u v w : \u03b1 \u2192 \u03b2} {l : Filter \u03b1}", "{\u03b1 \u03b2 : Type*} [NormedField \u03b2] {u v : \u03b1 \u2192 \u03b2} {l : Filter \u03b1}", "{\u03b1 \u03b9 \u03b2 : Type*} [NormedField \u03b2] {t u v w : \u03b1 \u2192 \u03b2} {l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b9 : Type u_6\n\u03b2 : Type u_7\ninst\u271d : NormedField \u03b2\nl : Filter \u03b1\ns : Multiset \u03b9\nf g : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nh : \u2200 i \u2208 s, IsEquivalent l (f i) (g i)\n\u22a2 IsEquivalent l (fun x => (Multiset.map (fun x_1 => f x_1 x) s).prod) fun x =>\n    (Multiset.map (fun x_1 => g x_1 x) s).prod"}, {"line": "obtain \u27e8l, rfl\u27e9 : \u2203 l : List \u03b9, \u2191l = s := Quotient.mk_surjective s", "tactic_state": "case intro\n\u03b1 : Type u_5\n\u03b9 : Type u_6\n\u03b2 : Type u_7\ninst\u271d : NormedField \u03b2\nl\u271d : Filter \u03b1\nf g : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nl : List \u03b9\nh : \u2200 i \u2208 \u2191l, IsEquivalent l\u271d (f i) (g i)\n\u22a2 IsEquivalent l\u271d (fun x => (Multiset.map (fun x_1 => f x_1 x) \u2191l).prod) fun x =>\n    (Multiset.map (fun x_1 => g x_1 x) \u2191l).prod"}, {"line": "exact listProd h", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsEquivalent.div (htu : t ~[l] u) (hvw : v ~[l] w) :\n    (fun x \u21a6 t x / v x) ~[l] fun x \u21a6 u x / w x := by\n  simpa only [div_eq_mul_inv] using htu.mul hvw.inv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/AsymptoticEquivalent.lean", "context": {"open": ["Filter Function", "Topology", "Asymptotics"], "variables": ["{\u03b1 \u03b2 : Type*} [NormedAddCommGroup \u03b2]", "{u v w : \u03b1 \u2192 \u03b2} {l : Filter \u03b1}", "{\u03b1 \u03b2 : Type*} [NormedField \u03b2] {u v : \u03b1 \u2192 \u03b2} {l : Filter \u03b1}", "{\u03b1 \u03b9 \u03b2 : Type*} [NormedField \u03b2] {t u v w : \u03b1 \u2192 \u03b2} {l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_7\ninst\u271d : NormedField \u03b2\nt u v w : \u03b1 \u2192 \u03b2\nl : Filter \u03b1\nhtu : IsEquivalent l t u\nhvw : IsEquivalent l v w\n\u22a2 IsEquivalent l (fun x => t x / v x) fun x => u x / w x"}, {"line": "simpa only [div_eq_mul_inv] using htu.mul hvw.inv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsEquivalent.tendsto_atBot [OrderTopology \u03b2] (huv : u ~[l] v) (hu : Tendsto u l atBot) :\n    Tendsto v l atBot := by\n  convert tendsto_neg_atTop_atBot.comp (huv.neg.tendsto_atTop <| tendsto_neg_atBot_atTop.comp hu)\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/AsymptoticEquivalent.lean", "context": {"open": ["Filter Function", "Topology", "Asymptotics"], "variables": ["{\u03b1 \u03b2 : Type*} [NormedAddCommGroup \u03b2]", "{u v w : \u03b1 \u2192 \u03b2} {l : Filter \u03b1}", "{\u03b1 \u03b2 : Type*} [NormedField \u03b2] {u v : \u03b1 \u2192 \u03b2} {l : Filter \u03b1}", "{\u03b1 \u03b9 \u03b2 : Type*} [NormedField \u03b2] {t u v w : \u03b1 \u2192 \u03b2} {l : Filter \u03b1}", "{\u03b1 \u03b2 : Type*} [NormedField \u03b2] [LinearOrder \u03b2] [IsStrictOrderedRing \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 Tendsto v l sorry"}, {"line": "convert tendsto_neg_atTop_atBot.comp (huv.neg.tendsto_atTop <| tendsto_neg_atBot_atTop.comp hu)", "tactic_state": "case h.e'_3\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 v = Neg.neg \u2218 fun x => -v x\n---\ncase h.e'_5\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 sorry = atBot\n---\ncase convert_1\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 AddCommGroup \u03b2\u271d\n---\ncase convert_2\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 IsOrderedAddMonoid \u03b2\u271d\n---\ncase convert_3\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 LinearOrder \u03b2\u271d\n---\ncase convert_4\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 IsStrictOrderedRing \u03b2\u271d\n---\ncase convert_5\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 OrderTopology \u03b2\u271d\n---\ncase convert_6\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 IsOrderedAddMonoid \u03b2\u271d"}, {"line": "ext", "tactic_state": "case h.e'_3.h\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\nx\u271d : \u03b1\n\u22a2 v x\u271d = (Neg.neg \u2218 fun x => -v x) x\u271d\n---\ncase h.e'_5\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 sorry = atBot\n---\ncase convert_1\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 AddCommGroup \u03b2\u271d\n---\ncase convert_2\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 IsOrderedAddMonoid \u03b2\u271d\n---\ncase convert_3\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 LinearOrder \u03b2\u271d\n---\ncase convert_4\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 IsStrictOrderedRing \u03b2\u271d\n---\ncase convert_5\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 OrderTopology \u03b2\u271d\n---\ncase convert_6\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 IsOrderedAddMonoid \u03b2\u271d"}, {"line": "simp", "tactic_state": "case h.e'_3.h\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\nx\u271d : \u03b1\n\u22a2 v x\u271d = - -v x\u271d\n---\ncase h.e'_5\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 sorry = atBot\n---\ncase convert_1\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 AddCommGroup \u03b2\u271d\n---\ncase convert_2\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 IsOrderedAddMonoid \u03b2\u271d\n---\ncase convert_3\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 LinearOrder \u03b2\u271d\n---\ncase convert_4\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 IsStrictOrderedRing \u03b2\u271d\n---\ncase convert_5\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 OrderTopology \u03b2\u271d\n---\ncase convert_6\n\u03b1 : Type u_5\n\u03b2\u271d : Type u_7\ninst\u271d\u2074 : NormedField \u03b2\u271d\nu v : \u03b1 \u2192 \u03b2\u271d\nl : Filter \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b3 : NormedField \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nhuv : IsEquivalent l u v\nhu : Tendsto u l sorry\n\u22a2 IsOrderedAddMonoid \u03b2\u271d"}]}
{"declaration": "theorem isBigO_iff' {g : \u03b1 \u2192 E'''} :\n    f =O[l] g \u2194 \u2203 c > 0, \u2200\u1da0 x in l, \u2016f x\u2016 \u2264 c * \u2016g x\u2016 := by\n  refine \u27e8fun h => ?mp, fun h => ?mpr\u27e9\n  case mp =>\n    rw [isBigO_iff] at h\n    obtain \u27e8c, hc\u27e9 := h\n    refine \u27e8max c 1, zero_lt_one.trans_le (le_max_right _ _), ?_\u27e9\n    filter_upwards [hc] with x hx\n    apply hx.trans\n    gcongr\n    exact le_max_left _ _\n  case mpr =>\n    rw [isBigO_iff]\n    obtain \u27e8c, \u27e8_, hc\u27e9\u27e9 := h\n    exact \u27e8c, hc\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Defs.lean", "context": {"open": ["Set Topology Filter NNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "{S : Type*} [NormedRing S] [NormMulClass S]", "[NormedDivisionRing \ud835\udd5c] [NormedDivisionRing \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''} {k'' : \u03b1 \u2192 G''}", "{l l' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_3\ninst\u271d : Norm E\nf : \u03b1 \u2192 E\nl : Filter \u03b1\nE''' : Type u_8\ng : \u03b1 \u2192 E'''\n\u22a2 sorry \u2194 \u2203 c > 0, \u2200\u1da0 (x : \u03b1) in l, \u2016f x\u2016 \u2264 c * sorry"}, {"line": "refine \u27e8fun h => ?mp, fun h => ?mpr\u27e9", "tactic_state": "case mp\n\u03b1 : Type u_1\nE : Type u_3\ninst\u271d : Norm E\nf : \u03b1 \u2192 E\nl : Filter \u03b1\nE''' : Type u_8\ng : \u03b1 \u2192 E'''\nh : sorry\n\u22a2 \u2203 c > 0, \u2200\u1da0 (x : \u03b1) in l, \u2016f x\u2016 \u2264 c * sorry\n---\ncase mpr\n\u03b1 : Type u_1\nE : Type u_3\ninst\u271d : Norm E\nf : \u03b1 \u2192 E\nl : Filter \u03b1\nE''' : Type u_8\ng : \u03b1 \u2192 E'''\nh : \u2203 c > 0, \u2200\u1da0 (x : \u03b1) in l, \u2016f x\u2016 \u2264 c * sorry\n\u22a2 sorry"}, {"line": "case mp =>\n    rw [isBigO_iff] at h\n    obtain \u27e8c, hc\u27e9 := h\n    refine \u27e8max c 1, zero_lt_one.trans_le (le_max_right _ _), ?_\u27e9\n    filter_upwards [hc] with x hx\n    apply hx.trans\n    gcongr\n    exact le_max_left _ _", "tactic_state": "case mpr\n\u03b1 : Type u_1\nE : Type u_3\ninst\u271d : Norm E\nf : \u03b1 \u2192 E\nl : Filter \u03b1\nE''' : Type u_8\ng : \u03b1 \u2192 E'''\nh : \u2203 c > 0, \u2200\u1da0 (x : \u03b1) in l, \u2016f x\u2016 \u2264 c * sorry\n\u22a2 sorry"}, {"line": "case mpr =>\n    rw [isBigO_iff]\n    obtain \u27e8c, \u27e8_, hc\u27e9\u27e9 := h\n    exact \u27e8c, hc\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isBigO_iff'' {g : \u03b1 \u2192 E'''} :\n    f =O[l] g \u2194 \u2203 c > 0, \u2200\u1da0 x in l, c * \u2016f x\u2016 \u2264 \u2016g x\u2016 := by\n  refine \u27e8fun h => ?mp, fun h => ?mpr\u27e9\n  case mp =>\n    rw [isBigO_iff'] at h\n    obtain \u27e8c, \u27e8hc_pos, hc\u27e9\u27e9 := h\n    refine \u27e8c\u207b\u00b9, \u27e8by positivity, ?_\u27e9\u27e9\n    filter_upwards [hc] with x hx\n    rwa [inv_mul_le_iff\u2080 (by positivity)]\n  case mpr =>\n    rw [isBigO_iff']\n    obtain \u27e8c, \u27e8hc_pos, hc\u27e9\u27e9 := h\n    refine \u27e8c\u207b\u00b9, \u27e8by positivity, ?_\u27e9\u27e9\n    filter_upwards [hc] with x hx\n    rwa [\u2190 inv_inv c, inv_mul_le_iff\u2080 (by positivity)] at hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Defs.lean", "context": {"open": ["Set Topology Filter NNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "{S : Type*} [NormedRing S] [NormMulClass S]", "[NormedDivisionRing \ud835\udd5c] [NormedDivisionRing \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''} {k'' : \u03b1 \u2192 G''}", "{l l' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_3\ninst\u271d : Norm E\nf : \u03b1 \u2192 E\nl : Filter \u03b1\nE''' : Type u_8\ng : \u03b1 \u2192 E'''\n\u22a2 sorry \u2194 \u2203 c > 0, \u2200\u1da0 (x : \u03b1) in l, c * \u2016f x\u2016 \u2264 sorry"}, {"line": "refine \u27e8fun h => ?mp, fun h => ?mpr\u27e9", "tactic_state": "case mp\n\u03b1 : Type u_1\nE : Type u_3\ninst\u271d : Norm E\nf : \u03b1 \u2192 E\nl : Filter \u03b1\nE''' : Type u_8\ng : \u03b1 \u2192 E'''\nh : sorry\n\u22a2 \u2203 c > 0, \u2200\u1da0 (x : \u03b1) in l, c * \u2016f x\u2016 \u2264 sorry\n---\ncase mpr\n\u03b1 : Type u_1\nE : Type u_3\ninst\u271d : Norm E\nf : \u03b1 \u2192 E\nl : Filter \u03b1\nE''' : Type u_8\ng : \u03b1 \u2192 E'''\nh : \u2203 c > 0, \u2200\u1da0 (x : \u03b1) in l, c * \u2016f x\u2016 \u2264 sorry\n\u22a2 sorry"}, {"line": "case mp =>\n    rw [isBigO_iff'] at h\n    obtain \u27e8c, \u27e8hc_pos, hc\u27e9\u27e9 := h\n    refine \u27e8c\u207b\u00b9, \u27e8by positivity, ?_\u27e9\u27e9\n    filter_upwards [hc] with x hx\n    rwa [inv_mul_le_iff\u2080 (by positivity)]", "tactic_state": "case mpr\n\u03b1 : Type u_1\nE : Type u_3\ninst\u271d : Norm E\nf : \u03b1 \u2192 E\nl : Filter \u03b1\nE''' : Type u_8\ng : \u03b1 \u2192 E'''\nh : \u2203 c > 0, \u2200\u1da0 (x : \u03b1) in l, c * \u2016f x\u2016 \u2264 sorry\n\u22a2 sorry"}, {"line": "case mpr =>\n    rw [isBigO_iff']\n    obtain \u27e8c, \u27e8hc_pos, hc\u27e9\u27e9 := h\n    refine \u27e8c\u207b\u00b9, \u27e8by positivity, ?_\u27e9\u27e9\n    filter_upwards [hc] with x hx\n    rwa [\u2190 inv_inv c, inv_mul_le_iff\u2080 (by positivity)] at hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isBigO_fst_prod' {f' : \u03b1 \u2192 E' \u00d7 F'} : (fun x => (f' x).1) =O[l] f' := by\n  simpa [IsBigO_def, IsBigOWith_def] using isBigO_fst_prod (E' := E') (F' := F')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Defs.lean", "context": {"open": ["Set Topology Filter NNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "{S : Type*} [NormedRing S] [NormMulClass S]", "[NormedDivisionRing \ud835\udd5c] [NormedDivisionRing \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''} {k'' : \u03b1 \u2192 G''}", "{l l' : Filter \u03b1}", "{f\u2081 f\u2082 : \u03b1 \u2192 E} {g\u2081 g\u2082 : \u03b1 \u2192 F}", "(l)", "(c f g)", "{u v : \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F' : Type u_8\n\u03b1 : Type u_1\nE' : Type u_6\ninst\u271d\u00b9 : SeminormedAddCommGroup E'\ninst\u271d : SeminormedAddCommGroup F'\nl : Filter \u03b1\nf' : \u03b1 \u2192 E' \u00d7 F'\n\u22a2 (fun x => (f' x).1) =O[l] f'"}, {"line": "simpa [IsBigO_def, IsBigOWith_def] using isBigO_fst_prod (E' := E') (F' := F')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isBigO_snd_prod' {f' : \u03b1 \u2192 E' \u00d7 F'} : (fun x => (f' x).2) =O[l] f' := by\n  simpa [IsBigO_def, IsBigOWith_def] using isBigO_snd_prod (E' := E') (F' := F')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Defs.lean", "context": {"open": ["Set Topology Filter NNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "{S : Type*} [NormedRing S] [NormMulClass S]", "[NormedDivisionRing \ud835\udd5c] [NormedDivisionRing \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''} {k'' : \u03b1 \u2192 G''}", "{l l' : Filter \u03b1}", "{f\u2081 f\u2082 : \u03b1 \u2192 E} {g\u2081 g\u2082 : \u03b1 \u2192 F}", "(l)", "(c f g)", "{u v : \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F' : Type u_8\n\u03b1 : Type u_1\nE' : Type u_6\ninst\u271d\u00b9 : SeminormedAddCommGroup E'\ninst\u271d : SeminormedAddCommGroup F'\nl : Filter \u03b1\nf' : \u03b1 \u2192 E' \u00d7 F'\n\u22a2 (fun x => (f' x).2) =O[l] f'"}, {"line": "simpa [IsBigO_def, IsBigOWith_def] using isBigO_snd_prod (E' := E') (F' := F')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsLittleO.add_add (h\u2081 : f\u2081 =o[l] g\u2081) (h\u2082 : f\u2082 =o[l] g\u2082) :\n    (fun x => f\u2081 x + f\u2082 x) =o[l] fun x => \u2016g\u2081 x\u2016 + \u2016g\u2082 x\u2016 := by\n  refine (h\u2081.trans_le fun x => ?_).add (h\u2082.trans_le ?_) <;> simp [abs_of_nonneg, add_nonneg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Defs.lean", "context": {"open": ["Set Topology Filter NNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "{S : Type*} [NormedRing S] [NormMulClass S]", "[NormedDivisionRing \ud835\udd5c] [NormedDivisionRing \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''} {k'' : \u03b1 \u2192 G''}", "{l l' : Filter \u03b1}", "{f\u2081 f\u2082 : \u03b1 \u2192 E} {g\u2081 g\u2082 : \u03b1 \u2192 F}", "(l)", "(c f g)", "{u v : \u03b1 \u2192 \u211d}", "(f' k')", "{f : \u03b1 \u00d7 \u03b2 \u2192 E} {g : \u03b1 \u00d7 \u03b2 \u2192 F} {l' : Filter \u03b2}", "(l' : Filter \u03b2)", "{f\u2081 f\u2082 : \u03b1 \u2192 E'} {g\u2081 g\u2082 : \u03b1 \u2192 F'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F' : Type u_8\n\u03b1 : Type u_1\nE' : Type u_6\ninst\u271d\u00b9 : SeminormedAddCommGroup E'\ninst\u271d : SeminormedAddCommGroup F'\nl : Filter \u03b1\nf\u2081 f\u2082 : \u03b1 \u2192 E'\ng\u2081 g\u2082 : \u03b1 \u2192 F'\nh\u2081 : f\u2081 =o[l] g\u2081\nh\u2082 : f\u2082 =o[l] g\u2082\n\u22a2 (fun x => f\u2081 x + f\u2082 x) =o[l] fun x => \u2016g\u2081 x\u2016 + \u2016g\u2082 x\u2016"}, {"line": "refine (h\u2081.trans_le fun x => ?_).add (h\u2082.trans_le ?_) <;> simp [abs_of_nonneg, add_nonneg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsBigOWith.sub (h\u2081 : IsBigOWith c\u2081 l f\u2081 g) (h\u2082 : IsBigOWith c\u2082 l f\u2082 g) :\n    IsBigOWith (c\u2081 + c\u2082) l (fun x => f\u2081 x - f\u2082 x) g := by\n  simpa only [sub_eq_add_neg] using h\u2081.add h\u2082.neg_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Defs.lean", "context": {"open": ["Set Topology Filter NNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "{S : Type*} [NormedRing S] [NormMulClass S]", "[NormedDivisionRing \ud835\udd5c] [NormedDivisionRing \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''} {k'' : \u03b1 \u2192 G''}", "{l l' : Filter \u03b1}", "{f\u2081 f\u2082 : \u03b1 \u2192 E} {g\u2081 g\u2082 : \u03b1 \u2192 F}", "(l)", "(c f g)", "{u v : \u03b1 \u2192 \u211d}", "(f' k')", "{f : \u03b1 \u00d7 \u03b2 \u2192 E} {g : \u03b1 \u00d7 \u03b2 \u2192 F} {l' : Filter \u03b2}", "(l' : Filter \u03b2)", "{f\u2081 f\u2082 : \u03b1 \u2192 E'} {g\u2081 g\u2082 : \u03b1 \u2192 F'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_8\nIsBigOWith : x\u271d\nh\u2081 : sorry\nh\u2082 : sorry\n\u22a2 sorry"}, {"line": "simpa only [sub_eq_add_neg] using h\u2081.add h\u2082.neg_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isBigOWith_self_const_mul {c : S} (hc : c \u2260 0) (f : \u03b1 \u2192 S) (l : Filter \u03b1) :\n    IsBigOWith \u2016c\u2016\u207b\u00b9 l f fun x \u21a6 c * f x := by\n  simp [IsBigOWith, inv_mul_cancel_left\u2080 (norm_ne_zero_iff.mpr hc)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Defs.lean", "context": {"open": ["Set Topology Filter NNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "{S : Type*} [NormedRing S] [NormMulClass S]", "[NormedDivisionRing \ud835\udd5c] [NormedDivisionRing \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''} {k'' : \u03b1 \u2192 G''}", "{l l' : Filter \u03b1}", "{f\u2081 f\u2082 : \u03b1 \u2192 E} {g\u2081 g\u2082 : \u03b1 \u2192 F}", "(l)", "(c f g)", "{u v : \u03b1 \u2192 \u211d}", "(f' k')", "{f : \u03b1 \u00d7 \u03b2 \u2192 E} {g : \u03b1 \u00d7 \u03b2 \u2192 F} {l' : Filter \u03b2}", "(l' : Filter \u03b2)", "{f\u2081 f\u2082 : \u03b1 \u2192 E'} {g\u2081 g\u2082 : \u03b1 \u2192 F'}", "{f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 E'}", "(g g' l)", "{g g' l}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nS : Type u_7\ninst\u271d\u00b9 : NormedRing S\ninst\u271d : NormMulClass S\nx\u271d : Sort u_8\nIsBigOWith : x\u271d\nc : S\nhc : c \u2260 0\nf : \u03b1 \u2192 S\nl : Filter \u03b1\n\u22a2 sorry"}, {"line": "simp [IsBigOWith, inv_mul_cancel_left\u2080 (norm_ne_zero_iff.mpr hc)]", "tactic_state": "\u03b1 : Type u_1\nS : Type u_7\ninst\u271d\u00b9 : NormedRing S\ninst\u271d : NormMulClass S\nx\u271d : Sort u_8\nIsBigOWith : x\u271d\nc : S\nhc : c \u2260 0\nf : \u03b1 \u2192 S\nl : Filter \u03b1\n\u22a2 sorry ()"}]}
{"declaration": "lemma Real.eventually_atTop_exists_int_between {a b : \u211d} (h : a < b) :\n    \u2200\u1da0 x : \u211d in atTop, \u2203 n : \u2124, a * x \u2264 n \u2227 n \u2264 b * x := by\n  refine (eventually_ge_atTop (b-a)\u207b\u00b9).mono fun x ab_x \u21a6 ?_\n  rw [inv_le_iff_one_le_mul\u2080 (sub_pos_of_lt h)] at ab_x\n  rw [mul_comm] at ab_x\n  rw [sub_mul] at ab_x\n  rw [le_sub_iff_add_le'] at ab_x\n  obtain \u27e8n, n_bx, hn\u27e9 := (b * x).exists_floor\n  refine \u27e8n, ?_, n_bx\u27e9\n  specialize hn (n + 1)\n  simp only [Int.cast_add] at hn\n  simp only [Int.cast_one] at hn\n  simp only [add_le_iff_nonpos_right] at hn\n  simp only [Int.reduceLE] at hn\n  simp only [imp_false] at hn\n  simp only [not_le] at hn\n  exact le_of_add_le_add_right (ab_x.trans hn.le)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/ExpGrowth.lean", "context": {"open": ["ENNReal EReal Filter Function Set", "scoped Topology"], "variables": ["{u v : \u2115 \u2192 \u211d\u22650\u221e} {a : EReal} {b : \u211d\u22650\u221e}", "{u : \u2115 \u2192 \u211d\u22650\u221e} {v : \u2115 \u2192 \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nh : a < b\n\u22a2 \u2200\u1da0 (x : \u211d) in atTop, \u2203 n, a * x \u2264 \u2191n \u2227 \u2191n \u2264 b * x"}, {"line": "refine (eventually_ge_atTop (b-a)\u207b\u00b9).mono fun x ab_x \u21a6 ?_", "tactic_state": "a b : \u211d\nh : a < b\nx : \u211d\nab_x : (b - a)\u207b\u00b9 \u2264 x\n\u22a2 \u2203 n, a * x \u2264 \u2191n \u2227 \u2191n \u2264 b * x"}, {"line": "rw [inv_le_iff_one_le_mul\u2080 (sub_pos_of_lt h)] at ab_x", "tactic_state": "a b : \u211d\nh : a < b\nx : \u211d\nab_x : 1 \u2264 x * (b - a)\n\u22a2 \u2203 n, a * x \u2264 \u2191n \u2227 \u2191n \u2264 b * x"}, {"line": "rw [mul_comm] at ab_x", "tactic_state": "a b : \u211d\nh : a < b\nx : \u211d\nab_x : 1 \u2264 (b - a) * x\n\u22a2 \u2203 n, a * x \u2264 \u2191n \u2227 \u2191n \u2264 b * x"}, {"line": "rw [sub_mul] at ab_x", "tactic_state": "a b : \u211d\nh : a < b\nx : \u211d\nab_x : 1 \u2264 b * x - a * x\n\u22a2 \u2203 n, a * x \u2264 \u2191n \u2227 \u2191n \u2264 b * x"}, {"line": "rw [le_sub_iff_add_le'] at ab_x", "tactic_state": "a b : \u211d\nh : a < b\nx : \u211d\nab_x : a * x + 1 \u2264 b * x\n\u22a2 \u2203 n, a * x \u2264 \u2191n \u2227 \u2191n \u2264 b * x"}, {"line": "obtain \u27e8n, n_bx, hn\u27e9 := (b * x).exists_floor", "tactic_state": "case intro.intro\na b : \u211d\nh : a < b\nx : \u211d\nab_x : a * x + 1 \u2264 b * x\nn : \u2124\nn_bx : \u2191n \u2264 b * x\nhn : \u2200 (z : \u2124), \u2191z \u2264 b * x \u2192 z \u2264 n\n\u22a2 \u2203 n, a * x \u2264 \u2191n \u2227 \u2191n \u2264 b * x"}, {"line": "refine \u27e8n, ?_, n_bx\u27e9", "tactic_state": "case intro.intro\na b : \u211d\nh : a < b\nx : \u211d\nab_x : a * x + 1 \u2264 b * x\nn : \u2124\nn_bx : \u2191n \u2264 b * x\nhn : \u2200 (z : \u2124), \u2191z \u2264 b * x \u2192 z \u2264 n\n\u22a2 a * x \u2264 \u2191n"}, {"line": "specialize hn (n + 1)", "tactic_state": "case intro.intro\na b : \u211d\nh : a < b\nx : \u211d\nab_x : a * x + 1 \u2264 b * x\nn : \u2124\nn_bx : \u2191n \u2264 b * x\nhn : \u2191(n + 1) \u2264 b * x \u2192 n + 1 \u2264 n\n\u22a2 a * x \u2264 \u2191n"}, {"line": "simp only [Int.cast_add] at hn", "tactic_state": "case intro.intro\na b : \u211d\nh : a < b\nx : \u211d\nab_x : a * x + 1 \u2264 b * x\nn : \u2124\nn_bx : \u2191n \u2264 b * x\nhn : \u2191n + \u21911 \u2264 b * x \u2192 n + 1 \u2264 n\n\u22a2 a * x \u2264 \u2191n"}, {"line": "simp only [Int.cast_one] at hn", "tactic_state": "case intro.intro\na b : \u211d\nh : a < b\nx : \u211d\nab_x : a * x + 1 \u2264 b * x\nn : \u2124\nn_bx : \u2191n \u2264 b * x\nhn : \u2191n + 1 \u2264 b * x \u2192 n + 1 \u2264 n\n\u22a2 a * x \u2264 \u2191n"}, {"line": "simp only [add_le_iff_nonpos_right] at hn", "tactic_state": "case intro.intro\na b : \u211d\nh : a < b\nx : \u211d\nab_x : a * x + 1 \u2264 b * x\nn : \u2124\nn_bx : \u2191n \u2264 b * x\nhn : \u2191n + 1 \u2264 b * x \u2192 1 \u2264 0\n\u22a2 a * x \u2264 \u2191n"}, {"line": "simp only [Int.reduceLE] at hn", "tactic_state": "case intro.intro\na b : \u211d\nh : a < b\nx : \u211d\nab_x : a * x + 1 \u2264 b * x\nn : \u2124\nn_bx : \u2191n \u2264 b * x\nhn : \u2191n + 1 \u2264 b * x \u2192 False\n\u22a2 a * x \u2264 \u2191n"}, {"line": "simp only [imp_false] at hn", "tactic_state": "case intro.intro\na b : \u211d\nh : a < b\nx : \u211d\nab_x : a * x + 1 \u2264 b * x\nn : \u2124\nn_bx : \u2191n \u2264 b * x\nhn : \u00ac\u2191n + 1 \u2264 b * x\n\u22a2 a * x \u2264 \u2191n"}, {"line": "simp only [not_le] at hn", "tactic_state": "case intro.intro\na b : \u211d\nh : a < b\nx : \u211d\nab_x : a * x + 1 \u2264 b * x\nn : \u2124\nn_bx : \u2191n \u2264 b * x\nhn : b * x < \u2191n + 1\n\u22a2 a * x \u2264 \u2191n"}, {"line": "exact le_of_add_le_add_right (ab_x.trans hn.le)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tendsto_atTop_of_linGrowthInf_pos (h : liminf (fun n \u21a6 (v n : EReal) / n) atTop \u2260 0) :\n    Tendsto v atTop atTop := by\n  refine tendsto_atTop_atTop.2 fun M \u21a6 eventually_atTop.1 ?_\n  obtain \u27e8a, a_0, a_v\u27e9 := exists_between (h.symm.lt_of_le (linGrowthInf_nonneg v))\n  have h\u2081 : \u2200\u1da0 n : \u2115 in atTop, M \u2264 a * n := by\n    obtain \u27e8n, hn\u27e9 := EReal.exists_nat_ge_mul a.inv_lt_top.ne M\n    rw [\u2190 EReal.div_eq_inv_mul] at hn\n    rw [EReal.div_le_iff_le_mul a_0 (ne_top_of_lt a_v)] at hn\n    refine eventually_atTop.2 \u27e8n, fun k k_n \u21a6 ?_\u27e9\n    exact hn.trans (mul_le_mul_of_nonneg_left (Nat.cast_le.2 k_n) a_0.le)\n  have h\u2082 : \u2200\u1da0 n : \u2115 in atTop, a * n \u2264 v n := by\n    refine (eventually_lt_of_lt_liminf a_v).mp (eventually_atTop.2 \u27e81, fun n n_1 a_vn \u21a6 ?_\u27e9)\n    rw [lt_div_iff (Nat.cast_pos'.2 n_1) (natCast_ne_top n)] at a_vn\n    exact a_vn.le\n  filter_upwards [h\u2081, h\u2082] with n M_a a_vn\n  exact Nat.cast_le.1 (M_a.trans a_vn)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/ExpGrowth.lean", "context": {"open": ["ENNReal EReal Filter Function Set", "scoped Topology"], "variables": ["{u v : \u2115 \u2192 \u211d\u22650\u221e} {a : EReal} {b : \u211d\u22650\u221e}", "{u : \u2115 \u2192 \u211d\u22650\u221e} {v : \u2115 \u2192 \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "v : \u2115 \u2192 \u2115\nh : liminf (fun n => \u2191(v n) / \u2191n) atTop \u2260 0\n\u22a2 Tendsto v atTop atTop"}, {"line": "refine tendsto_atTop_atTop.2 fun M \u21a6 eventually_atTop.1 ?_", "tactic_state": "v : \u2115 \u2192 \u2115\nh : liminf (fun n => \u2191(v n) / \u2191n) atTop \u2260 0\nM : \u2115\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, M \u2264 v x"}, {"line": "obtain \u27e8a, a_0, a_v\u27e9 := exists_between (h.symm.lt_of_le (linGrowthInf_nonneg v))", "tactic_state": "case intro.intro\nv : \u2115 \u2192 \u2115\nh : liminf (fun n => \u2191(v n) / \u2191n) atTop \u2260 0\nM : \u2115\na : EReal\na_0 : 0 < a\na_v : a < liminf (fun n => \u2191(v n) / \u2191n) atTop\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, M \u2264 v x"}, {"line": "have h\u2081 : \u2200\u1da0 n : \u2115 in atTop, M \u2264 a * n := sorry", "tactic_state": "case intro.intro\nv : \u2115 \u2192 \u2115\nh : liminf (fun n => \u2191(v n) / \u2191n) atTop \u2260 0\nM : \u2115\na : EReal\na_0 : 0 < a\na_v : a < liminf (fun n => \u2191(v n) / \u2191n) atTop\nh\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2191M \u2264 a * \u2191n\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, M \u2264 v x"}, {"line": "have h\u2082 : \u2200\u1da0 n : \u2115 in atTop, a * n \u2264 v n := sorry", "tactic_state": "case intro.intro\nv : \u2115 \u2192 \u2115\nh : liminf (fun n => \u2191(v n) / \u2191n) atTop \u2260 0\nM : \u2115\na : EReal\na_0 : 0 < a\na_v : a < liminf (fun n => \u2191(v n) / \u2191n) atTop\nh\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2191M \u2264 a * \u2191n\nh\u2082 : \u2200\u1da0 (n : \u2115) in atTop, a * \u2191n \u2264 \u2191(v n)\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, M \u2264 v x"}, {"line": "filter_upwards [h\u2081, h\u2082] with n M_a a_vn", "tactic_state": "case h\nv : \u2115 \u2192 \u2115\nh : liminf (fun n => \u2191(v n) / \u2191n) atTop \u2260 0\nM : \u2115\na : EReal\na_0 : 0 < a\na_v : a < liminf (fun n => \u2191(v n) / \u2191n) atTop\nh\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2191M \u2264 a * \u2191n\nh\u2082 : \u2200\u1da0 (n : \u2115) in atTop, a * \u2191n \u2264 \u2191(v n)\nn : \u2115\nM_a : \u2191M \u2264 a * \u2191n\na_vn : a * \u2191n \u2264 \u2191(v n)\n\u22a2 M \u2264 v n"}, {"line": "exact Nat.cast_le.1 (M_a.trans a_vn)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isBigOWith_const_one (c : E) (l : Filter \u03b1) :\n    IsBigOWith \u2016c\u2016 l (fun _x : \u03b1 => c) fun _x => (1 : F) := by simp [isBigOWith_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Lemmas.lean", "context": {"open": ["Set Topology Filter NNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "[NormedDivisionRing \ud835\udd5c] [NormedDivisionRing \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''} {k'' : \u03b1 \u2192 G''}", "{l l' : Filter \u03b1}", "(F)", "[One F] [NormOneClass F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_3\ninst\u271d : Norm E\nx\u271d : Sort u_7\nIsBigOWith : x\u271d\nc : E\nl : Filter \u03b1\n\u22a2 sorry"}, {"line": "simp [isBigOWith_iff]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_3\ninst\u271d : Norm E\nx\u271d : Sort u_7\nIsBigOWith : x\u271d\nc : E\nl : Filter \u03b1\n\u22a2 sorry ()"}]}
{"declaration": "theorem continuousAt_iff_isLittleO {\u03b1 : Type*} {E : Type*} [NormedRing E] [NormOneClass E]\n    [TopologicalSpace \u03b1] {f : \u03b1 \u2192 E} {x : \u03b1} :\n    (ContinuousAt f x) \u2194 (fun (y : \u03b1) \u21a6 f y - f x) =o[\ud835\udcdd x] (fun (_ : \u03b1) \u21a6 (1 : E)) := by\n  simp [ContinuousAt, \u2190 tendsto_sub_nhds_zero_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Lemmas.lean", "context": {"open": ["Set Topology Filter NNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "[NormedDivisionRing \ud835\udd5c] [NormedDivisionRing \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''} {k'' : \u03b1 \u2192 G''}", "{l l' : Filter \u03b1}", "(F)", "[One F] [NormOneClass F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nE : Type u_8\ninst\u271d\u00b2 : NormedRing E\ninst\u271d\u00b9 : NormOneClass E\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b1 \u2192 E\nx : \u03b1\n\u22a2 ContinuousAt f x \u2194 (fun y => f y - f x) =o[nhds x] fun x => 1"}, {"line": "simp [ContinuousAt, \u2190 tendsto_sub_nhds_zero_iff]", "tactic_state": "\u03b1 : Type u_7\nE : Type u_8\ninst\u271d\u00b2 : NormedRing E\ninst\u271d\u00b9 : NormOneClass E\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b1 \u2192 E\nx : \u03b1\n\u22a2 Tendsto f (nhds x) (nhds (f x)) \u2194 (fun y => f y - f x) =o[nhds x] fun x => 1"}]}
{"declaration": "theorem IsBigO.multisetProd {R \ud835\udd5c : Type*} [SeminormedCommRing R] [NormedField \ud835\udd5c]\n    {s : Multiset \u03b9} {f : \u03b9 \u2192 \u03b1 \u2192 R} {g : \u03b9 \u2192 \u03b1 \u2192 \ud835\udd5c} (hf : \u2200 i \u2208 s, f i =O[l] g i) :\n    (fun x \u21a6 (s.map (f \u00b7 x)).prod) =O[l] (fun x \u21a6 (s.map (g \u00b7 x)).prod) := by\n  obtain \u27e8l, rfl\u27e9 : \u2203 l : List \u03b9, \u2191l = s := Quotient.mk_surjective s\n  exact mod_cast IsBigO.listProd hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Lemmas.lean", "context": {"open": ["Set Topology Filter NNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "[NormedDivisionRing \ud835\udd5c] [NormedDivisionRing \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''} {k'' : \u03b1 \u2192 G''}", "{l l' : Filter \u03b1}", "(F)", "[One F] [NormOneClass F]", "[Module R E'] [IsBoundedSMul R E']", "[Module \ud835\udd5c E'] [IsBoundedSMul \ud835\udd5c E']", "[Module R E'] [IsBoundedSMul R E'] [Module \ud835\udd5c' F'] [IsBoundedSMul \ud835\udd5c' F']", "{k\u2081 : \u03b1 \u2192 R} {k\u2082 : \u03b1 \u2192 \ud835\udd5c'}", "{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\n\u03b9 : Type u_7\nR : Type u_8\n\ud835\udd5c : Type u_9\ninst\u271d\u00b9 : SeminormedCommRing R\ninst\u271d : NormedField \ud835\udd5c\ns : Multiset \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 R\ng : \u03b9 \u2192 \u03b1 \u2192 \ud835\udd5c\nhf : \u2200 i \u2208 s, f i =O[l] g i\n\u22a2 (fun x => (Multiset.map (fun x_1 => f x_1 x) s).prod) =O[l] fun x => (Multiset.map (fun x_1 => g x_1 x) s).prod"}, {"line": "obtain \u27e8l, rfl\u27e9 : \u2203 l : List \u03b9, \u2191l = s := Quotient.mk_surjective s", "tactic_state": "case intro\n\u03b1 : Type u_1\nl\u271d : Filter \u03b1\n\u03b9 : Type u_7\nR : Type u_8\n\ud835\udd5c : Type u_9\ninst\u271d\u00b9 : SeminormedCommRing R\ninst\u271d : NormedField \ud835\udd5c\nf : \u03b9 \u2192 \u03b1 \u2192 R\ng : \u03b9 \u2192 \u03b1 \u2192 \ud835\udd5c\nl : List \u03b9\nhf : \u2200 i \u2208 \u2191l, f i =O[l\u271d] g i\n\u22a2 (fun x => (Multiset.map (fun x_1 => f x_1 x) \u2191l).prod) =O[l\u271d] fun x => (Multiset.map (fun x_1 => g x_1 x) \u2191l).prod"}, {"line": "exact mod_cast IsBigO.listProd hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsLittleO.multisetProd {R \ud835\udd5c : Type*} [SeminormedCommRing R] [NormedField \ud835\udd5c]\n    {s : Multiset \u03b9} {f : \u03b9 \u2192 \u03b1 \u2192 R} {g : \u03b9 \u2192 \u03b1 \u2192 \ud835\udd5c} (h\u2081 : \u2200 i \u2208 s, f i =O[l] g i)\n    (h\u2082 : \u2203 i \u2208 s, f i =o[l] g i) :\n    (fun x \u21a6 (s.map (f \u00b7 x)).prod) =o[l] (fun x \u21a6 (s.map (g \u00b7 x)).prod) := by\n  obtain \u27e8l, rfl\u27e9 : \u2203 l : List \u03b9, \u2191l = s := Quotient.mk_surjective s\n  exact mod_cast IsLittleO.listProd h\u2081 h\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Lemmas.lean", "context": {"open": ["Set Topology Filter NNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "[NormedDivisionRing \ud835\udd5c] [NormedDivisionRing \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''} {k'' : \u03b1 \u2192 G''}", "{l l' : Filter \u03b1}", "(F)", "[One F] [NormOneClass F]", "[Module R E'] [IsBoundedSMul R E']", "[Module \ud835\udd5c E'] [IsBoundedSMul \ud835\udd5c E']", "[Module R E'] [IsBoundedSMul R E'] [Module \ud835\udd5c' F'] [IsBoundedSMul \ud835\udd5c' F']", "{k\u2081 : \u03b1 \u2192 R} {k\u2082 : \u03b1 \u2192 \ud835\udd5c'}", "{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\n\u03b9 : Type u_7\nR : Type u_8\n\ud835\udd5c : Type u_9\ninst\u271d\u00b9 : SeminormedCommRing R\ninst\u271d : NormedField \ud835\udd5c\ns : Multiset \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 R\ng : \u03b9 \u2192 \u03b1 \u2192 \ud835\udd5c\nh\u2081 : \u2200 i \u2208 s, f i =O[l] g i\nh\u2082 : \u2203 i \u2208 s, f i =o[l] g i\n\u22a2 (fun x => (Multiset.map (fun x_1 => f x_1 x) s).prod) =o[l] fun x => (Multiset.map (fun x_1 => g x_1 x) s).prod"}, {"line": "obtain \u27e8l, rfl\u27e9 : \u2203 l : List \u03b9, \u2191l = s := Quotient.mk_surjective s", "tactic_state": "case intro\n\u03b1 : Type u_1\nl\u271d : Filter \u03b1\n\u03b9 : Type u_7\nR : Type u_8\n\ud835\udd5c : Type u_9\ninst\u271d\u00b9 : SeminormedCommRing R\ninst\u271d : NormedField \ud835\udd5c\nf : \u03b9 \u2192 \u03b1 \u2192 R\ng : \u03b9 \u2192 \u03b1 \u2192 \ud835\udd5c\nl : List \u03b9\nh\u2081 : \u2200 i \u2208 \u2191l, f i =O[l\u271d] g i\nh\u2082 : \u2203 i \u2208 \u2191l, f i =o[l\u271d] g i\n\u22a2 (fun x => (Multiset.map (fun x_1 => f x_1 x) \u2191l).prod) =o[l\u271d] fun x => (Multiset.map (fun x_1 => g x_1 x) \u2191l).prod"}, {"line": "exact mod_cast IsLittleO.listProd h\u2081 h\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLittleO_pow_sub_sub (x\u2080 : E') {m : \u2115} (h : 1 < m) :\n    (fun x => \u2016x - x\u2080\u2016 ^ m) =o[\ud835\udcdd x\u2080] fun x => x - x\u2080 := by\n  simpa only [isLittleO_norm_right,pow_one] using isLittleO_pow_sub_pow_sub x\u2080 h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Lemmas.lean", "context": {"open": ["Set Topology Filter NNReal"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "[NormedDivisionRing \ud835\udd5c] [NormedDivisionRing \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''} {k'' : \u03b1 \u2192 G''}", "{l l' : Filter \u03b1}", "(F)", "[One F] [NormOneClass F]", "[Module R E'] [IsBoundedSMul R E']", "[Module \ud835\udd5c E'] [IsBoundedSMul \ud835\udd5c E']", "[Module R E'] [IsBoundedSMul R E'] [Module \ud835\udd5c' F'] [IsBoundedSMul \ud835\udd5c' F']", "{k\u2081 : \u03b1 \u2192 R} {k\u2082 : \u03b1 \u2192 \ud835\udd5c'}", "{\u03b9 : Type*}", "{u v : \u03b1 \u2192 \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E' : Type u_6\ninst\u271d : SeminormedAddCommGroup E'\nx\u2080 : E'\nm : \u2115\nh : 1 < m\n\u22a2 (fun x => \u2016x - x\u2080\u2016 ^ m) =o[nhds x\u2080] fun x => x - x\u2080"}, {"line": "simpa only [isLittleO_norm_right,pow_one] using isLittleO_pow_sub_pow_sub x\u2080 h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLittleO_congr (e : PartialHomeomorph \u03b1 \u03b2) {b : \u03b2} (hb : b \u2208 e.target) {f : \u03b2 \u2192 E}\n    {g : \u03b2 \u2192 F} : f =o[\ud835\udcdd b] g \u2194 (f \u2218 e) =o[\ud835\udcdd (e.symm b)] (g \u2218 e) := by\n  simp only [IsLittleO_def]\n  exact forall\u2082_congr fun c _hc => e.isBigOWith_congr hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Lemmas.lean", "context": {"open": ["Set Topology Filter NNReal", "Asymptotics"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "[NormedDivisionRing \ud835\udd5c] [NormedDivisionRing \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''} {k'' : \u03b1 \u2192 G''}", "{l l' : Filter \u03b1}", "(F)", "[One F] [NormOneClass F]", "[Module R E'] [IsBoundedSMul R E']", "[Module \ud835\udd5c E'] [IsBoundedSMul \ud835\udd5c E']", "[Module R E'] [IsBoundedSMul R E'] [Module \ud835\udd5c' F'] [IsBoundedSMul \ud835\udd5c' F']", "{k\u2081 : \u03b1 \u2192 R} {k\u2082 : \u03b1 \u2192 \ud835\udd5c'}", "{\u03b9 : Type*}", "{u v : \u03b1 \u2192 \ud835\udd5c}", "{\u03b1 : Type*} {\u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "{E : Type*} [Norm E] {F : Type*} [Norm F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nE : Type u_10\ninst\u271d\u00b9 : Norm E\nF : Type u_11\ninst\u271d : Norm F\ne : PartialHomeomorph \u03b1 \u03b2\nb : \u03b2\nhb : b \u2208 e.target\nf : \u03b2 \u2192 E\ng : \u03b2 \u2192 F\n\u22a2 f =o[nhds b] g \u2194 (f \u2218 \u2191e) =o[nhds (\u2191e.symm b)] (g \u2218 \u2191e)"}, {"line": "simp only [IsLittleO_def]", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nE : Type u_10\ninst\u271d\u00b9 : Norm E\nF : Type u_11\ninst\u271d : Norm F\ne : PartialHomeomorph \u03b1 \u03b2\nb : \u03b2\nhb : b \u2208 e.target\nf : \u03b2 \u2192 E\ng : \u03b2 \u2192 F\n\u22a2 (\u2200 \u2983c : \u211d\u2984, 0 < c \u2192 IsBigOWith c (nhds b) f g) \u2194 \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 IsBigOWith c (nhds (\u2191e.symm b)) (f \u2218 \u2191e) (g \u2218 \u2191e)"}, {"line": "exact forall\u2082_congr fun c _hc => e.isBigOWith_congr hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isBigO_congr (e : \u03b1 \u2243\u209c \u03b2) {b : \u03b2} {f : \u03b2 \u2192 E} {g : \u03b2 \u2192 F} :\n    f =O[\ud835\udcdd b] g \u2194 (f \u2218 e) =O[\ud835\udcdd (e.symm b)] (g \u2218 e) := by\n  simp only [IsBigO_def]\n  exact exists_congr fun C => e.isBigOWith_congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Lemmas.lean", "context": {"open": ["Set Topology Filter NNReal", "Asymptotics", "Asymptotics"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "[NormedDivisionRing \ud835\udd5c] [NormedDivisionRing \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''} {k'' : \u03b1 \u2192 G''}", "{l l' : Filter \u03b1}", "(F)", "[One F] [NormOneClass F]", "[Module R E'] [IsBoundedSMul R E']", "[Module \ud835\udd5c E'] [IsBoundedSMul \ud835\udd5c E']", "[Module R E'] [IsBoundedSMul R E'] [Module \ud835\udd5c' F'] [IsBoundedSMul \ud835\udd5c' F']", "{k\u2081 : \u03b1 \u2192 R} {k\u2082 : \u03b1 \u2192 \ud835\udd5c'}", "{\u03b9 : Type*}", "{u v : \u03b1 \u2192 \ud835\udd5c}", "{\u03b1 : Type*} {\u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "{E : Type*} [Norm E] {F : Type*} [Norm F]", "{\u03b1 : Type*} {\u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "{E : Type*} [Norm E] {F : Type*} [Norm F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_12\n\u03b2 : Type u_13\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nE : Type u_14\ninst\u271d\u00b9 : Norm E\nF : Type u_15\ninst\u271d : Norm F\ne : \u03b1 \u2243\u209c \u03b2\nb : \u03b2\nf : \u03b2 \u2192 E\ng : \u03b2 \u2192 F\n\u22a2 f =O[nhds b] g \u2194 (f \u2218 \u21d1e) =O[nhds (e.symm b)] (g \u2218 \u21d1e)"}, {"line": "simp only [IsBigO_def]", "tactic_state": "\u03b1 : Type u_12\n\u03b2 : Type u_13\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nE : Type u_14\ninst\u271d\u00b9 : Norm E\nF : Type u_15\ninst\u271d : Norm F\ne : \u03b1 \u2243\u209c \u03b2\nb : \u03b2\nf : \u03b2 \u2192 E\ng : \u03b2 \u2192 F\n\u22a2 (\u2203 c, IsBigOWith c (nhds b) f g) \u2194 \u2203 c, IsBigOWith c (nhds (e.symm b)) (f \u2218 \u21d1e) (g \u2218 \u21d1e)"}, {"line": "exact exists_congr fun C => e.isBigOWith_congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLittleO_congr (e : \u03b1 \u2243\u209c \u03b2) {b : \u03b2} {f : \u03b2 \u2192 E} {g : \u03b2 \u2192 F} :\n    f =o[\ud835\udcdd b] g \u2194 (f \u2218 e) =o[\ud835\udcdd (e.symm b)] (g \u2218 e) := by\n  simp only [IsLittleO_def]\n  exact forall\u2082_congr fun c _hc => e.isBigOWith_congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/Lemmas.lean", "context": {"open": ["Set Topology Filter NNReal", "Asymptotics", "Asymptotics"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {E : Type*} {F : Type*} {G : Type*} {E' : Type*}", "[Norm E] [Norm F] [Norm G]", "[SeminormedAddCommGroup E'] [SeminormedAddCommGroup F'] [SeminormedAddCommGroup G']", "[NormedDivisionRing \ud835\udd5c] [NormedDivisionRing \ud835\udd5c']", "{c c' c\u2081 c\u2082 : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G}", "{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {k' : \u03b1 \u2192 G'}", "{f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''} {k'' : \u03b1 \u2192 G''}", "{l l' : Filter \u03b1}", "(F)", "[One F] [NormOneClass F]", "[Module R E'] [IsBoundedSMul R E']", "[Module \ud835\udd5c E'] [IsBoundedSMul \ud835\udd5c E']", "[Module R E'] [IsBoundedSMul R E'] [Module \ud835\udd5c' F'] [IsBoundedSMul \ud835\udd5c' F']", "{k\u2081 : \u03b1 \u2192 R} {k\u2082 : \u03b1 \u2192 \ud835\udd5c'}", "{\u03b9 : Type*}", "{u v : \u03b1 \u2192 \ud835\udd5c}", "{\u03b1 : Type*} {\u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "{E : Type*} [Norm E] {F : Type*} [Norm F]", "{\u03b1 : Type*} {\u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "{E : Type*} [Norm E] {F : Type*} [Norm F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_12\n\u03b2 : Type u_13\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nE : Type u_14\ninst\u271d\u00b9 : Norm E\nF : Type u_15\ninst\u271d : Norm F\ne : \u03b1 \u2243\u209c \u03b2\nb : \u03b2\nf : \u03b2 \u2192 E\ng : \u03b2 \u2192 F\n\u22a2 f =o[nhds b] g \u2194 (f \u2218 \u21d1e) =o[nhds (e.symm b)] (g \u2218 \u21d1e)"}, {"line": "simp only [IsLittleO_def]", "tactic_state": "\u03b1 : Type u_12\n\u03b2 : Type u_13\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nE : Type u_14\ninst\u271d\u00b9 : Norm E\nF : Type u_15\ninst\u271d : Norm F\ne : \u03b1 \u2243\u209c \u03b2\nb : \u03b2\nf : \u03b2 \u2192 E\ng : \u03b2 \u2192 F\n\u22a2 (\u2200 \u2983c : \u211d\u2984, 0 < c \u2192 IsBigOWith c (nhds b) f g) \u2194 \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 IsBigOWith c (nhds (e.symm b)) (f \u2218 \u21d1e) (g \u2218 \u21d1e)"}, {"line": "exact forall\u2082_congr fun c _hc => e.isBigOWith_congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem SuperpolynomialDecay.inv_param_mul (hk : Tendsto k l atTop)\n    (hf : SuperpolynomialDecay l k f) : SuperpolynomialDecay l k (k\u207b\u00b9 * f) := by\n  simpa using hf.param_zpow_mul hk (-1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/SuperpolynomialDecay.lean", "context": {"open": ["Topology Polynomial", "Filter"], "variables": ["{\u03b1 \u03b2 : Type*} {l : Filter \u03b1} {k : \u03b1 \u2192 \u03b2} {f g g' : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2] [CommSemiring \u03b2]", "[TopologicalSpace \u03b2] [CommSemiring \u03b2] [PartialOrder \u03b2] [IsOrderedRing \u03b2] [OrderTopology \u03b2]", "[TopologicalSpace \u03b2] [CommRing \u03b2] [LinearOrder \u03b2] [IsStrictOrderedRing \u03b2] [OrderTopology \u03b2]", "(l k f)", "{l k f}", "[TopologicalSpace \u03b2] [Field \u03b2] (l k f)", "{l k f}", "[TopologicalSpace \u03b2] [Field \u03b2] [LinearOrder \u03b2] [IsStrictOrderedRing \u03b2] [OrderTopology \u03b2]", "(f)", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\nk : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2077 : CommSemiring \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2075 : CommSemiring \u03b2\ninst\u271d\u00b9\u2074 : PartialOrder \u03b2\ninst\u271d\u00b9\u00b3 : IsOrderedRing \u03b2\ninst\u271d\u00b9\u00b2 : OrderTopology \u03b2\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2070 : CommRing \u03b2\ninst\u271d\u2079 : LinearOrder \u03b2\ninst\u271d\u2078 : IsStrictOrderedRing \u03b2\ninst\u271d\u2077 : OrderTopology \u03b2\ninst\u271d\u2076 : TopologicalSpace \u03b2\ninst\u271d\u2075 : Field \u03b2\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Field \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nx\u271d : Sort u_3\nSuperpolynomialDecay : x\u271d\nhk : Tendsto k l atTop\nhf : sorry\n\u22a2 sorry"}, {"line": "simpa using hf.param_zpow_mul hk (-1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem superpolynomialDecay_mul_param_iff (hk : Tendsto k l atTop) :\n    SuperpolynomialDecay l k (f * k) \u2194 SuperpolynomialDecay l k f := by\n  simpa [mul_comm k] using superpolynomialDecay_param_mul_iff f hk\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/SuperpolynomialDecay.lean", "context": {"open": ["Topology Polynomial", "Filter"], "variables": ["{\u03b1 \u03b2 : Type*} {l : Filter \u03b1} {k : \u03b1 \u2192 \u03b2} {f g g' : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2] [CommSemiring \u03b2]", "[TopologicalSpace \u03b2] [CommSemiring \u03b2] [PartialOrder \u03b2] [IsOrderedRing \u03b2] [OrderTopology \u03b2]", "[TopologicalSpace \u03b2] [CommRing \u03b2] [LinearOrder \u03b2] [IsStrictOrderedRing \u03b2] [OrderTopology \u03b2]", "(l k f)", "{l k f}", "[TopologicalSpace \u03b2] [Field \u03b2] (l k f)", "{l k f}", "[TopologicalSpace \u03b2] [Field \u03b2] [LinearOrder \u03b2] [IsStrictOrderedRing \u03b2] [OrderTopology \u03b2]", "(f)", "{f}", "(f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\nk : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2077 : CommSemiring \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2075 : CommSemiring \u03b2\ninst\u271d\u00b9\u2074 : PartialOrder \u03b2\ninst\u271d\u00b9\u00b3 : IsOrderedRing \u03b2\ninst\u271d\u00b9\u00b2 : OrderTopology \u03b2\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2070 : CommRing \u03b2\ninst\u271d\u2079 : LinearOrder \u03b2\ninst\u271d\u2078 : IsStrictOrderedRing \u03b2\ninst\u271d\u2077 : OrderTopology \u03b2\ninst\u271d\u2076 : TopologicalSpace \u03b2\ninst\u271d\u2075 : Field \u03b2\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Field \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nx\u271d : Sort u_3\nSuperpolynomialDecay : x\u271d\nhk : Tendsto k l atTop\n\u22a2 sorry \u2194 sorry"}, {"line": "simpa [mul_comm k] using superpolynomialDecay_param_mul_iff f hk", "tactic_state": "No Goals!"}]}
{"declaration": "theorem superpolynomialDecay_mul_param_pow_iff (hk : Tendsto k l atTop) (n : \u2115) :\n    SuperpolynomialDecay l k (f * k ^ n) \u2194 SuperpolynomialDecay l k f := by\n  simpa [mul_comm f] using superpolynomialDecay_param_pow_mul_iff f hk n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/SuperpolynomialDecay.lean", "context": {"open": ["Topology Polynomial", "Filter"], "variables": ["{\u03b1 \u03b2 : Type*} {l : Filter \u03b1} {k : \u03b1 \u2192 \u03b2} {f g g' : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2] [CommSemiring \u03b2]", "[TopologicalSpace \u03b2] [CommSemiring \u03b2] [PartialOrder \u03b2] [IsOrderedRing \u03b2] [OrderTopology \u03b2]", "[TopologicalSpace \u03b2] [CommRing \u03b2] [LinearOrder \u03b2] [IsStrictOrderedRing \u03b2] [OrderTopology \u03b2]", "(l k f)", "{l k f}", "[TopologicalSpace \u03b2] [Field \u03b2] (l k f)", "{l k f}", "[TopologicalSpace \u03b2] [Field \u03b2] [LinearOrder \u03b2] [IsStrictOrderedRing \u03b2] [OrderTopology \u03b2]", "(f)", "{f}", "(f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\nk : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2077 : CommSemiring \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2075 : CommSemiring \u03b2\ninst\u271d\u00b9\u2074 : PartialOrder \u03b2\ninst\u271d\u00b9\u00b3 : IsOrderedRing \u03b2\ninst\u271d\u00b9\u00b2 : OrderTopology \u03b2\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2070 : CommRing \u03b2\ninst\u271d\u2079 : LinearOrder \u03b2\ninst\u271d\u2078 : IsStrictOrderedRing \u03b2\ninst\u271d\u2077 : OrderTopology \u03b2\ninst\u271d\u2076 : TopologicalSpace \u03b2\ninst\u271d\u2075 : Field \u03b2\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Field \u03b2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b2\ninst\u271d : OrderTopology \u03b2\nx\u271d : Sort u_3\nSuperpolynomialDecay : x\u271d\nhk : Tendsto k l atTop\nn : \u2115\n\u22a2 sorry \u2194 sorry"}, {"line": "simpa [mul_comm f] using superpolynomialDecay_param_pow_mul_iff f hk n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLittleOTVS_map {k : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} :\n    f =o[\ud835\udd5c; map k l] g \u2194 (f \u2218 k) =o[\ud835\udd5c; l] (g \u2218 k) := by\n  simp [IsLittleOTVS]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Asymptotics/TVS.lean", "context": {"open": ["Set Filter Asymptotics Metric", "scoped Topology Pointwise ENNReal NNReal"], "variables": ["{\u03b1 \u03b2 \ud835\udd5c E F G : Type*}", "[NontriviallyNormedField \ud835\udd5c]", "{f f\u2081 f\u2082 : \u03b1 \u2192 E} {g g\u2081 g\u2082 : \u03b1 \u2192 F} {l : Filter \u03b1}", "{l l\u2081 l\u2082 : Filter \u03b1} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b2 \u2192 \u03b1\nl : Filter \u03b2\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [IsLittleOTVS]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasIntegral.sub (h : HasIntegral I l f vol y) (h' : HasIntegral I l g vol y') :\n    HasIntegral I l (f - g) vol (y - y') := by simpa only [sub_eq_add_neg] using h.add h'.neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/Basic.lean", "context": {"open": ["scoped Topology NNReal Filter Uniformity BoxIntegral", "Set Finset Function Filter Metric BoxIntegral.IntegrationParams", "TaggedPrepartition", "Classical in", "Classical in"], "variables": ["{\u03b9 : Type u} {E : Type v} {F : Type w} [NormedAddCommGroup E] [NormedSpace \u211d E]", "[Fintype \u03b9]", "{l : IntegrationParams} {f g : (\u03b9 \u2192 \u211d) \u2192 E} {vol : \u03b9 \u2192\u1d47\u1d43 E \u2192L[\u211d] F} {y y' : F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nHasIntegral : x\u271d\nh : sorry\nh' : sorry\n\u22a2 sorry"}, {"line": "simpa only [sub_eq_add_neg] using h.add h'.neg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasIntegral_zero : HasIntegral I l (fun _ => (0 : E)) vol 0 := by\n  simpa only [\u2190 (vol I).map_zero] using hasIntegral_const (0 : E)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/Basic.lean", "context": {"open": ["scoped Topology NNReal Filter Uniformity BoxIntegral", "Set Finset Function Filter Metric BoxIntegral.IntegrationParams", "TaggedPrepartition", "Classical in", "Classical in"], "variables": ["{\u03b9 : Type u} {E : Type v} {F : Type w} [NormedAddCommGroup E] [NormedSpace \u211d E]", "[Fintype \u03b9]", "{l : IntegrationParams} {f g : (\u03b9 \u2192 \u211d) \u2192 E} {vol : \u03b9 \u2192\u1d47\u1d43 E \u2192L[\u211d] F} {y y' : F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nHasIntegral : x\u271d\n\u22a2 sorry"}, {"line": "simpa only [\u2190 (vol I).map_zero] using hasIntegral_const (0 : E)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Integrable.of_smul {c : \u211d} (hf : Integrable I l (c \u2022 f) vol) (hc : c \u2260 0) :\n    Integrable I l f vol := by\n  simpa [inv_smul_smul\u2080 hc] using hf.smul c\u207b\u00b9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/Basic.lean", "context": {"open": ["scoped Topology NNReal Filter Uniformity BoxIntegral", "Set Finset Function Filter Metric BoxIntegral.IntegrationParams", "TaggedPrepartition", "Classical in", "Classical in"], "variables": ["{\u03b9 : Type u} {E : Type v} {F : Type w} [NormedAddCommGroup E] [NormedSpace \u211d E]", "[Fintype \u03b9]", "{l : IntegrationParams} {f g : (\u03b9 \u2192 \u211d) \u2192 E} {vol : \u03b9 \u2192\u1d47\u1d43 E \u2192L[\u211d] F} {y y' : F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nIntegrable : x\u271d\nc : \u211d\nhf : sorry\nhc : c \u2260 0\n\u22a2 sorry"}, {"line": "simpa [inv_smul_smul\u2080 hc] using hf.smul c\u207b\u00b9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem BoxIntegral.le_hasIntegralVertices_of_isBounded [Finite \u03b9] {s : Set (\u03b9 \u2192 \u211d)}\n    (h : IsBounded s) :\n    \u2203 B : BoxIntegral.Box \u03b9, hasIntegralVertices B \u2227 s \u2264 B := by\n  have := Fintype.ofFinite \u03b9\n  obtain \u27e8R, hR\u2081, hR\u2082\u27e9 := IsBounded.subset_ball_lt h 0 0\n  let C : \u2115 := \u2308R\u2309\u208a\n  have hC := Nat.ceil_pos.mpr hR\u2081\n  let I : Box \u03b9 := Box.mk (fun _ \u21a6 - C) (fun _ \u21a6 C )\n    (fun _ \u21a6 by simp [C, neg_lt_self_iff, Nat.cast_pos, hC])\n  refine \u27e8I, \u27e8fun _ \u21a6 - C, fun _ \u21a6 C, fun i \u21a6 (Int.cast_neg_natCast C).symm, fun _ \u21a6 rfl\u27e9,\n    le_trans hR\u2082 ?_\u27e9\n  suffices Metric.ball (0 : \u03b9 \u2192 \u211d) C \u2264 I from\n    le_trans (Metric.ball_subset_ball (Nat.le_ceil R)) this\n  intro x hx\n  simp_rw [C, mem_ball_zero_iff, pi_norm_lt_iff (Nat.cast_pos.mpr hC),\n    Real.norm_eq_abs, abs_lt] at hx\n  exact fun i \u21a6 \u27e8(hx i).1, le_of_lt (hx i).2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/UnitPartition.lean", "context": {"open": ["scoped Topology", "Bornology"], "variables": ["{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d : Finite \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nh : IsBounded s\n\u22a2 \u2203 B, hasIntegralVertices B \u2227 s \u2264 \u2191B"}, {"line": "have := Fintype.ofFinite \u03b9", "tactic_state": "\u03b9 : Type u_1\ninst\u271d : Finite \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nh : IsBounded s\nthis : Fintype \u03b9\n\u22a2 \u2203 B, hasIntegralVertices B \u2227 s \u2264 \u2191B"}, {"line": "obtain \u27e8R, hR\u2081, hR\u2082\u27e9 := IsBounded.subset_ball_lt h 0 0", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\ninst\u271d : Finite \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nh : IsBounded s\nthis : Fintype \u03b9\nR : \u211d\nhR\u2081 : 0 < R\nhR\u2082 : s \u2286 Metric.ball 0 R\n\u22a2 \u2203 B, hasIntegralVertices B \u2227 s \u2264 \u2191B"}, {"line": "let C : \u2115 := \u2308R\u2309\u208a", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\ninst\u271d : Finite \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nh : IsBounded s\nthis : Fintype \u03b9\nR : \u211d\nhR\u2081 : 0 < R\nhR\u2082 : s \u2286 Metric.ball 0 R\nC : \u2115 := \u2308R\u2309\u208a\n\u22a2 \u2203 B, hasIntegralVertices B \u2227 s \u2264 \u2191B"}, {"line": "have hC := Nat.ceil_pos.mpr hR\u2081", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\ninst\u271d : Finite \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nh : IsBounded s\nthis : Fintype \u03b9\nR : \u211d\nhR\u2081 : 0 < R\nhR\u2082 : s \u2286 Metric.ball 0 R\nC : \u2115 := \u2308R\u2309\u208a\nhC : 0 < \u2308R\u2309\u208a\n\u22a2 \u2203 B, hasIntegralVertices B \u2227 s \u2264 \u2191B"}, {"line": "let I : Box \u03b9 := Box.mk (fun _ \u21a6 - C) (fun _ \u21a6 C )\n    (fun _ \u21a6 by simp [C, neg_lt_self_iff, Nat.cast_pos, hC])", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\ninst\u271d : Finite \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nh : IsBounded s\nthis : Fintype \u03b9\nR : \u211d\nhR\u2081 : 0 < R\nhR\u2082 : s \u2286 Metric.ball 0 R\nC : \u2115 := \u2308R\u2309\u208a\nhC : 0 < \u2308R\u2309\u208a\nI : Box \u03b9 := { lower := fun x => -\u2191C, upper := fun x => \u2191C, lower_lt_upper := \u22ef }\n\u22a2 \u2203 B, hasIntegralVertices B \u2227 s \u2264 \u2191B"}, {"line": "refine \u27e8I, \u27e8fun _ \u21a6 - C, fun _ \u21a6 C, fun i \u21a6 (Int.cast_neg_natCast C).symm, fun _ \u21a6 rfl\u27e9,\n    le_trans hR\u2082 ?_\u27e9", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\ninst\u271d : Finite \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nh : IsBounded s\nthis : Fintype \u03b9\nR : \u211d\nhR\u2081 : 0 < R\nhR\u2082 : s \u2286 Metric.ball 0 R\nC : \u2115 := \u2308R\u2309\u208a\nhC : 0 < \u2308R\u2309\u208a\nI : Box \u03b9 := { lower := fun x => -\u2191C, upper := fun x => \u2191C, lower_lt_upper := \u22ef }\n\u22a2 Metric.ball 0 R \u2264 \u2191I"}, {"line": "suffices Metric.ball (0 : \u03b9 \u2192 \u211d) C \u2264 I from\n    le_trans (Metric.ball_subset_ball (Nat.le_ceil R)) this", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\ninst\u271d : Finite \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nh : IsBounded s\nthis : Fintype \u03b9\nR : \u211d\nhR\u2081 : 0 < R\nhR\u2082 : s \u2286 Metric.ball 0 R\nC : \u2115 := \u2308R\u2309\u208a\nhC : 0 < \u2308R\u2309\u208a\nI : Box \u03b9 := { lower := fun x => -\u2191C, upper := fun x => \u2191C, lower_lt_upper := \u22ef }\n\u22a2 Metric.ball 0 \u2191C \u2264 \u2191I"}, {"line": "intro x hx", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\ninst\u271d : Finite \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nh : IsBounded s\nthis : Fintype \u03b9\nR : \u211d\nhR\u2081 : 0 < R\nhR\u2082 : s \u2286 Metric.ball 0 R\nC : \u2115 := \u2308R\u2309\u208a\nhC : 0 < \u2308R\u2309\u208a\nI : Box \u03b9 := { lower := fun x => -\u2191C, upper := fun x => \u2191C, lower_lt_upper := \u22ef }\nx : \u03b9 \u2192 \u211d\nhx : x \u2208 Metric.ball 0 \u2191C\n\u22a2 x \u2208 \u2191I"}, {"line": "simp_rw [C, mem_ball_zero_iff, pi_norm_lt_iff (Nat.cast_pos.mpr hC),\n    Real.norm_eq_abs, abs_lt] at hx", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\ninst\u271d : Finite \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nh : IsBounded s\nthis : Fintype \u03b9\nR : \u211d\nhR\u2081 : 0 < R\nhR\u2082 : s \u2286 Metric.ball 0 R\nC : \u2115 := \u2308R\u2309\u208a\nhC : 0 < \u2308R\u2309\u208a\nI : Box \u03b9 := { lower := fun x => -\u2191C, upper := fun x => \u2191C, lower_lt_upper := \u22ef }\nx : \u03b9 \u2192 \u211d\nhx : \u2200 (i : \u03b9), -\u2191\u2308R\u2309\u208a < x i \u2227 x i < \u2191\u2308R\u2309\u208a\n\u22a2 x \u2208 \u2191I"}, {"line": "exact fun i \u21a6 \u27e8(hx i).1, le_of_lt (hx i).2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem setFinite_index {s : Set (\u03b9 \u2192 \u211d)} (hs\u2081 : NullMeasurableSet s) (hs\u2082 : volume s \u2260 \u22a4) :\n    Set.Finite {\u03bd : \u03b9 \u2192 \u2124 | \u2191(box n \u03bd) \u2286 s} := by\n  refine (Measure.finite_const_le_meas_of_disjoint_iUnion\u2080 volume (\u03b5 := 1 / n ^ card \u03b9)\n    (by norm_num) (As := fun \u03bd : \u03b9 \u2192 \u2124 \u21a6 (box n \u03bd) \u2229 s) (fun \u03bd \u21a6 ?_) (fun _ _ h \u21a6 ?_) ?_).subset\n      (fun _ h\u03bd \u21a6 ?_)\n  \u00b7 refine NullMeasurableSet.inter ?_ hs\u2081\n    exact (box n \u03bd).measurableSet_coe.nullMeasurableSet\n  \u00b7 exact ((Disjoint.inter_right _ (disjoint.mp h)).inter_left _ ).aedisjoint\n  \u00b7 exact lt_top_iff_ne_top.mp <| measure_lt_top_of_subset\n      (by simp only [Set.iUnion_subset_iff, Set.inter_subset_right, implies_true]) hs\u2082\n  \u00b7 rw [Set.mem_setOf, Set.inter_eq_self_of_subset_left h\u03bd, volume_box]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/UnitPartition.lean", "context": {"open": ["scoped Topology", "Bornology", "Bornology MeasureTheory Fintype BoxIntegral"], "variables": ["{\u03b9 : Type*}", "(n : \u2115)", "{n} in", "{n} in", "[NeZero n]", "{n} in", "{n} in", "[Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nx\u271d : Sort u_2\nbox : x\u271d\ns : Set (\u03b9 \u2192 \u211d)\nhs\u2081 : NullMeasurableSet s sorry\nhs\u2082 : sorry \u2260 \u22a4\n\u22a2 {\u03bd | sorry \u2286 s}.Finite"}, {"line": "refine (Measure.finite_const_le_meas_of_disjoint_iUnion\u2080 volume (\u03b5 := 1 / n ^ card \u03b9)\n    (by norm_num) (As := fun \u03bd : \u03b9 \u2192 \u2124 \u21a6 (box n \u03bd) \u2229 s) (fun \u03bd \u21a6 ?_) (fun _ _ h \u21a6 ?_) ?_).subset\n      (fun _ h\u03bd \u21a6 ?_)", "tactic_state": "case refine_1\n\u03b9 : Type u_1\nx\u271d : Sort u_2\nbox : x\u271d\ns : Set (\u03b9 \u2192 \u211d)\nhs\u2081 : NullMeasurableSet s sorry\nhs\u2082 : sorry \u2260 \u22a4\n\u22a2 MeasureSpace (\u03b9 \u2192 \u211d)\n---\ncase refine_2\n\u03b9 : Type u_1\nx\u271d : Sort u_2\nbox : x\u271d\ns : Set (\u03b9 \u2192 \u211d)\nhs\u2081 : NullMeasurableSet s sorry\nhs\u2082 : sorry \u2260 \u22a4\n\u03bd : \u03b9 \u2192 \u2124\n\u22a2 NullMeasurableSet ((fun \u03bd => sorry \u2229 s) \u03bd) volume\n---\ncase refine_3\n\u03b9 : Type u_1\nx\u271d\u00b2 : Sort u_2\nbox : x\u271d\u00b2\ns : Set (\u03b9 \u2192 \u211d)\nhs\u2081 : NullMeasurableSet s sorry\nhs\u2082 : sorry \u2260 \u22a4\nx\u271d\u00b9 x\u271d : \u03b9 \u2192 \u2124\nh : x\u271d\u00b9 \u2260 x\u271d\n\u22a2 Function.onFun (AEDisjoint volume) (fun \u03bd => sorry \u2229 s) x\u271d\u00b9 x\u271d\n---\ncase refine_4\n\u03b9 : Type u_1\nx\u271d : Sort u_2\nbox : x\u271d\ns : Set (\u03b9 \u2192 \u211d)\nhs\u2081 : NullMeasurableSet s sorry\nhs\u2082 : sorry \u2260 \u22a4\n\u22a2 volume (\u22c3 i, (fun \u03bd => sorry \u2229 s) i) \u2260 \u22a4\n---\ncase refine_5\n\u03b9 : Type u_1\nx\u271d\u00b9 : Sort u_2\nbox : x\u271d\u00b9\ns : Set (\u03b9 \u2192 \u211d)\nhs\u2081 : NullMeasurableSet s sorry\nhs\u2082 : sorry \u2260 \u22a4\nx\u271d : \u03b9 \u2192 \u2124\nh\u03bd : x\u271d \u2208 {\u03bd | sorry \u2286 s}\n\u22a2 x\u271d \u2208 {i | 1 / sorry ^ sorry \u2264 volume (sorry \u2229 s)}"}, {"line": "\u00b7 refine NullMeasurableSet.inter ?_ hs\u2081\n    exact (box n \u03bd).measurableSet_coe.nullMeasurableSet", "tactic_state": "case refine_2\n\u03b9 : Type u_1\nx\u271d : Sort u_2\nbox : x\u271d\ns : Set (\u03b9 \u2192 \u211d)\nhs\u2081 : NullMeasurableSet s sorry\nhs\u2082 : sorry \u2260 \u22a4\n\u03bd : \u03b9 \u2192 \u2124\n\u22a2 NullMeasurableSet ((fun \u03bd => sorry \u2229 s) \u03bd) volume\n---\ncase refine_3\n\u03b9 : Type u_1\nx\u271d\u00b2 : Sort u_2\nbox : x\u271d\u00b2\ns : Set (\u03b9 \u2192 \u211d)\nhs\u2081 : NullMeasurableSet s sorry\nhs\u2082 : sorry \u2260 \u22a4\nx\u271d\u00b9 x\u271d : \u03b9 \u2192 \u2124\nh : x\u271d\u00b9 \u2260 x\u271d\n\u22a2 Function.onFun (AEDisjoint volume) (fun \u03bd => sorry \u2229 s) x\u271d\u00b9 x\u271d\n---\ncase refine_4\n\u03b9 : Type u_1\nx\u271d : Sort u_2\nbox : x\u271d\ns : Set (\u03b9 \u2192 \u211d)\nhs\u2081 : NullMeasurableSet s sorry\nhs\u2082 : sorry \u2260 \u22a4\n\u22a2 volume (\u22c3 i, (fun \u03bd => sorry \u2229 s) i) \u2260 \u22a4\n---\ncase refine_5\n\u03b9 : Type u_1\nx\u271d\u00b9 : Sort u_2\nbox : x\u271d\u00b9\ns : Set (\u03b9 \u2192 \u211d)\nhs\u2081 : NullMeasurableSet s sorry\nhs\u2082 : sorry \u2260 \u22a4\nx\u271d : \u03b9 \u2192 \u2124\nh\u03bd : x\u271d \u2208 {\u03bd | sorry \u2286 s}\n\u22a2 x\u271d \u2208 {i | 1 / sorry ^ sorry \u2264 volume (sorry \u2229 s)}"}, {"line": "\u00b7 exact ((Disjoint.inter_right _ (disjoint.mp h)).inter_left _ ).aedisjoint", "tactic_state": "case refine_3\n\u03b9 : Type u_1\nx\u271d\u00b2 : Sort u_2\nbox : x\u271d\u00b2\ns : Set (\u03b9 \u2192 \u211d)\nhs\u2081 : NullMeasurableSet s sorry\nhs\u2082 : sorry \u2260 \u22a4\nx\u271d\u00b9 x\u271d : \u03b9 \u2192 \u2124\nh : x\u271d\u00b9 \u2260 x\u271d\n\u22a2 Function.onFun (AEDisjoint volume) (fun \u03bd => sorry \u2229 s) x\u271d\u00b9 x\u271d\n---\ncase refine_4\n\u03b9 : Type u_1\nx\u271d : Sort u_2\nbox : x\u271d\ns : Set (\u03b9 \u2192 \u211d)\nhs\u2081 : NullMeasurableSet s sorry\nhs\u2082 : sorry \u2260 \u22a4\n\u22a2 volume (\u22c3 i, (fun \u03bd => sorry \u2229 s) i) \u2260 \u22a4\n---\ncase refine_5\n\u03b9 : Type u_1\nx\u271d\u00b9 : Sort u_2\nbox : x\u271d\u00b9\ns : Set (\u03b9 \u2192 \u211d)\nhs\u2081 : NullMeasurableSet s sorry\nhs\u2082 : sorry \u2260 \u22a4\nx\u271d : \u03b9 \u2192 \u2124\nh\u03bd : x\u271d \u2208 {\u03bd | sorry \u2286 s}\n\u22a2 x\u271d \u2208 {i | 1 / sorry ^ sorry \u2264 volume (sorry \u2229 s)}"}, {"line": "\u00b7 exact lt_top_iff_ne_top.mp <| measure_lt_top_of_subset\n      (by simp only [Set.iUnion_subset_iff, Set.inter_subset_right, implies_true]) hs\u2082", "tactic_state": "case refine_4\n\u03b9 : Type u_1\nx\u271d : Sort u_2\nbox : x\u271d\ns : Set (\u03b9 \u2192 \u211d)\nhs\u2081 : NullMeasurableSet s sorry\nhs\u2082 : sorry \u2260 \u22a4\n\u22a2 volume (\u22c3 i, (fun \u03bd => sorry \u2229 s) i) \u2260 \u22a4\n---\ncase refine_5\n\u03b9 : Type u_1\nx\u271d\u00b9 : Sort u_2\nbox : x\u271d\u00b9\ns : Set (\u03b9 \u2192 \u211d)\nhs\u2081 : NullMeasurableSet s sorry\nhs\u2082 : sorry \u2260 \u22a4\nx\u271d : \u03b9 \u2192 \u2124\nh\u03bd : x\u271d \u2208 {\u03bd | sorry \u2286 s}\n\u22a2 x\u271d \u2208 {i | 1 / sorry ^ sorry \u2264 volume (sorry \u2229 s)}"}, {"line": "\u00b7 rw [Set.mem_setOf, Set.inter_eq_self_of_subset_left h\u03bd, volume_box]", "tactic_state": "case refine_5\n\u03b9 : Type u_1\nx\u271d\u00b9 : Sort u_2\nbox : x\u271d\u00b9\ns : Set (\u03b9 \u2192 \u211d)\nhs\u2081 : NullMeasurableSet s sorry\nhs\u2082 : sorry \u2260 \u22a4\nx\u271d : \u03b9 \u2192 \u2124\nh\u03bd : x\u271d \u2208 {\u03bd | sorry \u2286 s}\n\u22a2 x\u271d \u2208 {i | 1 / sorry ^ sorry \u2264 volume (sorry \u2229 s)}"}]}
{"declaration": "private theorem mem_admissibleIndex_of_mem_box_aux\u2081 (x : \u211d) (a : \u2124) :\n    a < x \u2194 a \u2264 (\u2308n * x\u2309 - 1) / (n : \u211d) := by\n  have h : 0 < (n : \u211d) := Nat.cast_pos.mpr <| n.pos_of_neZero\n  rw [le_div_iff\u2080' h]\n  rw [le_sub_iff_add_le]\n  rw [show (n : \u211d) * a + 1 = (n * a + 1 : \u2124) by norm_cast]\n  rw [Int.cast_le]\n  rw [Int.add_one_le_ceil_iff]\n  rw [Int.cast_mul]\n  rw [Int.cast_natCast]\n  rw [mul_lt_mul_left h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/UnitPartition.lean", "context": {"open": ["scoped Topology", "Bornology", "Bornology MeasureTheory Fintype BoxIntegral", "Classical in"], "variables": ["{\u03b9 : Type*}", "(n : \u2115)", "{n} in", "{n} in", "[NeZero n]", "{n} in", "{n} in", "[Fintype \u03b9]", "{n} in", "{n} in", "{n} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\n\u22a2 \u2191a < x \u2194 \u2191a \u2264 (\u2191\u2308\u2191n * x\u2309 - 1) / \u2191n"}, {"line": "have h : 0 < (n : \u211d) := Nat.cast_pos.mpr <| n.pos_of_neZero", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\nh : 0 < \u2191n\n\u22a2 \u2191a < x \u2194 \u2191a \u2264 (\u2191\u2308\u2191n * x\u2309 - 1) / \u2191n"}, {"line": "rw [le_div_iff\u2080' h]", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\nh : 0 < \u2191n\n\u22a2 \u2191a < x \u2194 \u2191n * \u2191a \u2264 \u2191\u2308\u2191n * x\u2309 - 1"}, {"line": "rw [le_sub_iff_add_le]", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\nh : 0 < \u2191n\n\u22a2 \u2191a < x \u2194 \u2191n * \u2191a + 1 \u2264 \u2191\u2308\u2191n * x\u2309"}, {"line": "rw [show (n : \u211d) * a + 1 = (n * a + 1 : \u2124) by norm_cast]", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\nh : 0 < \u2191n\n\u22a2 \u2191a < x \u2194 \u2191(\u2191n * a + 1) \u2264 \u2191\u2308\u2191n * x\u2309"}, {"line": "rw [Int.cast_le]", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\nh : 0 < \u2191n\n\u22a2 \u2191a < x \u2194 \u2191n * a + 1 \u2264 \u2308\u2191n * x\u2309"}, {"line": "rw [Int.add_one_le_ceil_iff]", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\nh : 0 < \u2191n\n\u22a2 \u2191a < x \u2194 \u2191(\u2191n * a) < \u2191n * x"}, {"line": "rw [Int.cast_mul]", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\nh : 0 < \u2191n\n\u22a2 \u2191a < x \u2194 \u2191\u2191n * \u2191a < \u2191n * x"}, {"line": "rw [Int.cast_natCast]", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\nh : 0 < \u2191n\n\u22a2 \u2191a < x \u2194 \u2191n * \u2191a < \u2191n * x"}, {"line": "rw [mul_lt_mul_left h]", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem mem_admissibleIndex_of_mem_box_aux\u2082 (x : \u211d) (a : \u2124) :\n    x \u2264 a \u2194 (\u2308n * x\u2309 - 1 + 1) / (n : \u211d) \u2264 a := by\n  have h : 0 < (n : \u211d) := Nat.cast_pos.mpr <| n.pos_of_neZero\n  rw [sub_add_cancel]\n  rw [div_le_iff\u2080' h]\n  rw [show (n : \u211d) * a = (n * a : \u2124) by norm_cast]\n  rw [Int.cast_le]\n  rw [Int.ceil_le]\n  rw [Int.cast_mul]\n  rw [Int.cast_natCast]\n  rw [mul_le_mul_left h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/UnitPartition.lean", "context": {"open": ["scoped Topology", "Bornology", "Bornology MeasureTheory Fintype BoxIntegral", "Classical in"], "variables": ["{\u03b9 : Type*}", "(n : \u2115)", "{n} in", "{n} in", "[NeZero n]", "{n} in", "{n} in", "[Fintype \u03b9]", "{n} in", "{n} in", "{n} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\n\u22a2 x \u2264 \u2191a \u2194 (\u2191\u2308\u2191n * x\u2309 - 1 + 1) / \u2191n \u2264 \u2191a"}, {"line": "have h : 0 < (n : \u211d) := Nat.cast_pos.mpr <| n.pos_of_neZero", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\nh : 0 < \u2191n\n\u22a2 x \u2264 \u2191a \u2194 (\u2191\u2308\u2191n * x\u2309 - 1 + 1) / \u2191n \u2264 \u2191a"}, {"line": "rw [sub_add_cancel]", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\nh : 0 < \u2191n\n\u22a2 x \u2264 \u2191a \u2194 \u2191\u2308\u2191n * x\u2309 / \u2191n \u2264 \u2191a"}, {"line": "rw [div_le_iff\u2080' h]", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\nh : 0 < \u2191n\n\u22a2 x \u2264 \u2191a \u2194 \u2191\u2308\u2191n * x\u2309 \u2264 \u2191n * \u2191a"}, {"line": "rw [show (n : \u211d) * a = (n * a : \u2124) by norm_cast]", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\nh : 0 < \u2191n\n\u22a2 x \u2264 \u2191a \u2194 \u2191\u2308\u2191n * x\u2309 \u2264 \u2191(\u2191n * a)"}, {"line": "rw [Int.cast_le]", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\nh : 0 < \u2191n\n\u22a2 x \u2264 \u2191a \u2194 \u2308\u2191n * x\u2309 \u2264 \u2191n * a"}, {"line": "rw [Int.ceil_le]", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\nh : 0 < \u2191n\n\u22a2 x \u2264 \u2191a \u2194 \u2191n * x \u2264 \u2191(\u2191n * a)"}, {"line": "rw [Int.cast_mul]", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\nh : 0 < \u2191n\n\u22a2 x \u2264 \u2191a \u2194 \u2191n * x \u2264 \u2191\u2191n * \u2191a"}, {"line": "rw [Int.cast_natCast]", "tactic_state": "n : \u2115\nx : \u211d\na : \u2124\nh : 0 < \u2191n\n\u22a2 x \u2264 \u2191a \u2194 \u2191n * x \u2264 \u2191n * \u2191a"}, {"line": "rw [mul_le_mul_left h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem upper_sub_lower_splitCenterBox (I : Box \u03b9) (s : Set \u03b9) (i : \u03b9) :\n    (I.splitCenterBox s).upper i - (I.splitCenterBox s).lower i = (I.upper i - I.lower i) / 2 := by\n  by_cases i \u2208 s <;> field_simp [splitCenterBox] <;> field_simp [mul_two, two_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/Box/SubboxInduction.lean", "context": {"open": ["Set Function Filter Topology", "Classical in"], "variables": ["{\u03b9 : Type*} {I J : Box \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nBox : x\u271d\n\u03b9 : Type u_2\nI : sorry\ns : Set \u03b9\ni : \u03b9\n\u22a2 sorry - sorry = (sorry - sorry) / 2"}, {"line": "by_cases i \u2208 s <;> field_simp [splitCenterBox] <;> field_simp [mul_two, two_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_splitCenter : J \u2208 splitCenter I \u2194 \u2203 s, I.splitCenterBox s = J := by simp [splitCenter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/Partition/SubboxInduction.lean", "context": {"open": ["Set Metric", "Topology"], "variables": ["{\u03b9 : Type*} [Fintype \u03b9] {I J : Box \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Box : ?m.841\n\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\nI : sorry\nJ\u271d J : sorry\nx\u271d : Sort u_2\nsplitCenter : x\u271d\n\u22a2 J \u2208 sorry \u2194 \u2203 s, sorry = J"}, {"line": "simp [splitCenter]", "tactic_state": "Box : ?m.841\n\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\nI : sorry\nJ\u271d J : sorry\nx\u271d : Sort u_2\nsplitCenter : x\u271d\n\u22a2 J \u2208 sorry () \u2194 \u2203 s, sorry () = J"}]}
{"declaration": "theorem distortion_unionComplToSubordinate (\u03c0\u2081 : TaggedPrepartition I) (\u03c0\u2082 : Prepartition I)\n    (hU : \u03c0\u2082.iUnion = \u2191I \\ \u03c0\u2081.iUnion) (r : (\u03b9 \u2192 \u211d) \u2192 Ioi (0 : \u211d)) :\n    (\u03c0\u2081.unionComplToSubordinate \u03c0\u2082 hU r).distortion = max \u03c0\u2081.distortion \u03c0\u2082.distortion := by\n  simp [unionComplToSubordinate]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/Partition/SubboxInduction.lean", "context": {"open": ["Set Metric", "Topology", "Prepartition TaggedPrepartition", "TaggedPrepartition Finset Function", "scoped Classical in"], "variables": ["{\u03b9 : Type*} [Fintype \u03b9] {I J : Box \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nTaggedPrepartition : x\u271d\u00b9\nx\u271d : Sort u_2\nPrepartition : x\u271d\n\u03b9 : Sort u_3\n\u03b1\u271d : Type u_4\nI : \u03b1\u271d\n\u03c0\u2081 : sorry\n\u03c0\u2082 : sorry\nhU : sorry = I \\ sorry\nr : (\u03b9 \u2192 \u211d) \u2192 \u2191(Ioi 0)\n\u22a2 sorry = sorry \u2294 sorry"}, {"line": "simp [unionComplToSubordinate]", "tactic_state": "x\u271d\u00b9 : Sort u_1\nTaggedPrepartition : x\u271d\u00b9\nx\u271d : Sort u_2\nPrepartition : x\u271d\n\u03b9 : Sort u_3\n\u03b1\u271d : Type u_4\nI : \u03b1\u271d\n\u03c0\u2081 : sorry\n\u03c0\u2082 : sorry\nhU : sorry = I \\ sorry\nr : (\u03b9 \u2192 \u211d) \u2192 \u2191(Ioi 0)\n\u22a2 sorry () = sorry () \u2294 sorry ()"}]}
{"declaration": "theorem iUnion_single (h : J \u2264 I) : (single I J h).iUnion = J := by simp [iUnion_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/Partition/Basic.lean", "context": {"open": ["Set Finset Function", "scoped NNReal", "scoped Classical in"], "variables": ["{\u03b9 : Type*}", "{I J J\u2081 J\u2082 : Box \u03b9} (\u03c0 : Prepartition I) {\u03c0\u2081 \u03c0\u2082 : Prepartition I} {x : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Box : ?m.2912\nPrepartition : ?m.2928\n\u03b9 : Sort ?u.2978\nI : sorry\nJ\u271d : sorry\nJ\u2081 : sorry\nJ\u2082 : sorry\n\u03c0 : sorry\n\u03c0\u2081 : sorry\n\u03c0\u2082 : sorry\nx : \u03b9 \u2192 \u211d\nJ : sorry\nx\u271d : Sort u_1\nsingle : x\u271d\nh : sorry\n\u22a2 sorry = J"}, {"line": "simp [iUnion_def]", "tactic_state": "Box : ?m.2912\nPrepartition : ?m.2928\n\u03b9 : Sort ?u.2978\nI : sorry\nJ\u271d : sorry\nJ\u2081 : sorry\nJ\u2082 : sorry\n\u03c0 : sorry\n\u03c0\u2081 : sorry\n\u03c0\u2082 : sorry\nx : \u03b9 \u2192 \u211d\nJ : sorry\nx\u271d : Sort u_1\nsingle : x\u271d\nh : sorry\n\u22a2 sorry () = J"}]}
{"declaration": "theorem iUnion_top : (\u22a4 : Prepartition I).iUnion = I := by simp [Prepartition.iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/Partition/Basic.lean", "context": {"open": ["Set Finset Function", "scoped NNReal", "scoped Classical in"], "variables": ["{\u03b9 : Type*}", "{I J J\u2081 J\u2082 : Box \u03b9} (\u03c0 : Prepartition I) {\u03c0\u2081 \u03c0\u2082 : Prepartition I} {x : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Box : ?m.2912\nPrepartition : ?m.2928\n\u03b9 : Sort ?u.2978\nI\u271d : sorry\nJ : sorry\nJ\u2081 : sorry\nJ\u2082 : sorry\n\u03c0 : sorry\n\u03c0\u2081 : sorry\n\u03c0\u2082 : sorry\nx : \u03b9 \u2192 \u211d\nI : sorry\n\u22a2 sorry = I"}, {"line": "simp [Prepartition.iUnion]", "tactic_state": "Box : ?m.2912\nPrepartition : ?m.2928\n\u03b9 : Sort ?u.2978\nI\u271d : sorry\nJ : sorry\nJ\u2081 : sorry\nJ\u2082 : sorry\n\u03c0 : sorry\n\u03c0\u2081 : sorry\n\u03c0\u2082 : sorry\nx : \u03b9 \u2192 \u211d\nI : sorry\n\u22a2 sorry () = I"}]}
{"declaration": "theorem iUnion_biUnion (\u03c0i : \u2200 J : Box \u03b9, Prepartition J) :\n    (\u03c0.biUnion \u03c0i).iUnion = \u22c3 J \u2208 \u03c0, (\u03c0i J).iUnion := by simp [Prepartition.iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/Partition/Basic.lean", "context": {"open": ["Set Finset Function", "scoped NNReal", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b9 : Type*}", "{I J J\u2081 J\u2082 : Box \u03b9} (\u03c0 : Prepartition I) {\u03c0\u2081 \u03c0\u2082 : Prepartition I} {x : \u03b9 \u2192 \u211d}", "{\u03c0i \u03c0i\u2081 \u03c0i\u2082 : \u2200 J : Box \u03b9, Prepartition J}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Box : ?m.6068\nPrepartition : ?m.6084\n\u03b9 : Sort ?u.6134\nI : sorry\nJ : sorry\nJ\u2081 : sorry\nJ\u2082 : sorry\n\u03c0 : sorry\n\u03c0\u2081 : sorry\n\u03c0\u2082 : sorry\nx : \u03b9 \u2192 \u211d\n\u03c0i\u271d : sorry \u2192 sorry\n\u03c0i\u2081 : sorry \u2192 sorry\n\u03c0i\u2082 : sorry \u2192 sorry\n\u03c0i : sorry \u2192 sorry\n\u22a2 sorry = \u22c3 J, \u22c3 (_ : sorry), sorry"}, {"line": "simp [Prepartition.iUnion]", "tactic_state": "Box : ?m.6068\nPrepartition : ?m.6084\n\u03b9 : Sort ?u.6134\nI : sorry\nJ : sorry\nJ\u2081 : sorry\nJ\u2082 : sorry\n\u03c0 : sorry\n\u03c0\u2081 : sorry\n\u03c0\u2082 : sorry\nx : \u03b9 \u2192 \u211d\n\u03c0i\u271d : sorry \u2192 sorry\n\u03c0i\u2081 : sorry \u2192 sorry\n\u03c0i\u2082 : sorry \u2192 sorry\n\u03c0i : sorry \u2192 sorry\n\u22a2 sorry () = \u22c3 J, \u22c3 (_ : sorry ()), sorry ()"}]}
{"declaration": "theorem isPartition_single_iff (h : J \u2264 I) : IsPartition (single I J h) \u2194 J = I := by\n  simp [isPartition_iff_iUnion_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/Partition/Basic.lean", "context": {"open": ["Set Finset Function", "scoped NNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b9 : Type*}", "{I J J\u2081 J\u2082 : Box \u03b9} (\u03c0 : Prepartition I) {\u03c0\u2081 \u03c0\u2082 : Prepartition I} {x : \u03b9 \u2192 \u211d}", "{\u03c0i \u03c0i\u2081 \u03c0i\u2082 : \u2200 J : Box \u03b9, Prepartition J}", "[Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Box : ?m.11454\nPrepartition : ?m.11470\n\u03b9 : Type ?u.11548\nI\u271d : sorry\nJ\u271d : sorry\nJ\u2081 : sorry\nJ\u2082 : sorry\n\u03c0 : sorry\n\u03c0\u2081 : sorry\n\u03c0\u2082 : sorry\nx : \u03b9 \u2192 \u211d\n\u03c0i : sorry \u2192 sorry\n\u03c0i\u2081 : sorry \u2192 sorry\n\u03c0i\u2082 : sorry \u2192 sorry\ninst\u271d : Fintype \u03b9\nI : sorry\nJ : sorry\nx\u271d : Sort u_1\nIsPartition : x\u271d\nh : sorry\n\u22a2 sorry \u2194 J = I"}, {"line": "simp [isPartition_iff_iUnion_eq]", "tactic_state": "Box : ?m.11454\nPrepartition : ?m.11470\n\u03b9 : Type ?u.11548\nI\u271d : sorry\nJ\u271d : sorry\nJ\u2081 : sorry\nJ\u2082 : sorry\n\u03c0 : sorry\n\u03c0\u2081 : sorry\n\u03c0\u2082 : sorry\nx : \u03b9 \u2192 \u211d\n\u03c0i : sorry \u2192 sorry\n\u03c0i\u2081 : sorry \u2192 sorry\n\u03c0i\u2082 : sorry \u2192 sorry\ninst\u271d : Fintype \u03b9\nI : sorry\nJ : sorry\nx\u271d : Sort u_1\nIsPartition : x\u271d\nh : sorry\n\u22a2 sorry () \u2194 J = I"}]}
{"declaration": "theorem rCond_of_bRiemann_eq_false {\u03b9} (l : IntegrationParams) (hl : l.bRiemann = false)\n    {r : (\u03b9 \u2192 \u211d) \u2192 Ioi (0 : \u211d)} : l.RCond r := by\n  simp [RCond, hl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/Partition/Filter.lean", "context": {"open": ["Set Function Filter Metric Finset Bool", "scoped Topology Filter NNReal", "TaggedPrepartition"], "variables": ["{\u03b9 : Type*} [Fintype \u03b9] {I J : Box \u03b9} {c c\u2081 c\u2082 : \u211d\u22650}", "{l l\u2081 l\u2082 : IntegrationParams}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Box : ?m.1704\nIntegrationParams\u271d : Sort ?u.1746\n\u03b9\u271d : Type u_1\ninst\u271d : Fintype \u03b9\u271d\nI : sorry\nJ : sorry\nc c\u2081 c\u2082 : NNReal\nl\u271d l\u2081 l\u2082 : IntegrationParams\u271d\nIntegrationParams : Sort ?u.1746\n\u03b9 : Sort u_2\nl : IntegrationParams\nhl : sorry = false\nr : (\u03b9 \u2192 \u211d) \u2192 \u2191(Set.Ioi 0)\n\u22a2 sorry"}, {"line": "simp [RCond, hl]", "tactic_state": "Box : ?m.1704\nIntegrationParams\u271d : Sort ?u.1746\n\u03b9\u271d : Type u_1\ninst\u271d : Fintype \u03b9\u271d\nI : sorry\nJ : sorry\nc c\u2081 c\u2082 : NNReal\nl\u271d l\u2081 l\u2082 : IntegrationParams\u271d\nIntegrationParams : Sort ?u.1746\n\u03b9 : Sort u_2\nl : IntegrationParams\nhl : sorry = false\nr : (\u03b9 \u2192 \u211d) \u2192 \u2191(Set.Ioi 0)\n\u22a2 sorry ()"}]}
{"declaration": "theorem hasBasis_toFilteriUnion_top (l : IntegrationParams) (I : Box \u03b9) :\n    (l.toFilteriUnion I \u22a4).HasBasis (fun r : \u211d\u22650 \u2192 (\u03b9 \u2192 \u211d) \u2192 Ioi (0 : \u211d) => \u2200 c, l.RCond (r c))\n      fun r => { \u03c0 | \u2203 c, l.MemBaseSet I c (r c) \u03c0 \u2227 \u03c0.IsPartition } := by\n  simpa only [TaggedPrepartition.isPartition_iff_iUnion_eq,Prepartition.iUnion_top] using\n    l.hasBasis_toFilteriUnion I \u22a4\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/Partition/Filter.lean", "context": {"open": ["Set Function Filter Metric Finset Bool", "scoped Topology Filter NNReal", "TaggedPrepartition"], "variables": ["{\u03b9 : Type*} [Fintype \u03b9] {I J : Box \u03b9} {c c\u2081 c\u2082 : \u211d\u22650}", "{l l\u2081 l\u2082 : IntegrationParams}", "{r\u2081 r\u2082 : (\u03b9 \u2192 \u211d) \u2192 Ioi (0 : \u211d)} {\u03c0 \u03c0\u2081 \u03c0\u2082 : TaggedPrepartition I}", "(I) in", "(I) in", "{r : (\u03b9 \u2192 \u211d) \u2192 Ioi (0 : \u211d)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Box : ?m.13381\nIntegrationParams\u271d : Sort ?u.14278\nTaggedPrepartition : ?m.14258\n\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\nI\u271d : sorry\nJ : sorry\nc c\u2081 c\u2082 : NNReal\nl\u271d l\u2081 l\u2082 : IntegrationParams\u271d\nr\u2081 r\u2082 : (\u03b9 \u2192 \u211d) \u2192 \u2191(Set.Ioi 0)\n\u03c0 : sorry\n\u03c0\u2081 : sorry\n\u03c0\u2082 : sorry\nIntegrationParams : Sort ?u.14278\nl : IntegrationParams\nI : sorry\n\u22a2 sorry"}, {"line": "simpa only [TaggedPrepartition.isPartition_iff_iUnion_eq,Prepartition.iUnion_top] using\n    l.hasBasis_toFilteriUnion I \u22a4", "tactic_state": "No Goals!"}]}
{"declaration": "theorem splitLower_eq_self : I.splitLower i x = I \u2194 I.upper i \u2264 x := by\n  simp [splitLower, update_eq_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/Partition/Split.lean", "context": {"open": ["Function Set Filter", "scoped Classical in"], "variables": ["{\u03b9 M : Type*} {n : \u2115}", "{I : Box \u03b9} {i : \u03b9} {x : \u211d} {y : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Box : ?m.438\n\u03b9 : Sort ?u.450\nI\u271d : sorry\ni : \u03b9\nx\u271d : \u211d\ny : \u03b9 \u2192 \u211d\nI : sorry\nx : \u211d\n\u22a2 sorry = I \u2194 sorry \u2264 x"}, {"line": "simp [splitLower, update_eq_iff]", "tactic_state": "Box : ?m.438\n\u03b9 : Sort ?u.450\nI\u271d : sorry\ni : \u03b9\nx\u271d : \u211d\ny : \u03b9 \u2192 \u211d\nI : sorry\nx : \u211d\n\u22a2 sorry () = I \u2194 sorry () \u2264 x"}]}
{"declaration": "theorem splitUpper_eq_self : I.splitUpper i x = I \u2194 x \u2264 I.lower i := by\n  simp [splitUpper, update_eq_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/Partition/Split.lean", "context": {"open": ["Function Set Filter", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b9 M : Type*} {n : \u2115}", "{I : Box \u03b9} {i : \u03b9} {x : \u211d} {y : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Box : ?m.438\n\u03b9 : Sort ?u.450\nI\u271d : sorry\ni : \u03b9\nx\u271d : \u211d\ny : \u03b9 \u2192 \u211d\nI : sorry\nx : \u211d\n\u22a2 sorry = I \u2194 x \u2264 sorry"}, {"line": "simp [splitUpper, update_eq_iff]", "tactic_state": "Box : ?m.438\n\u03b9 : Sort ?u.450\nI\u271d : sorry\ni : \u03b9\nx\u271d : \u211d\ny : \u03b9 \u2192 \u211d\nI : sorry\nx : \u211d\n\u22a2 sorry () = I \u2194 x \u2264 sorry ()"}]}
{"declaration": "theorem mem_split_iff : J \u2208 split I i x \u2194 \u2191J = I.splitLower i x \u2228 \u2191J = I.splitUpper i x := by\n  simp [split]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/Partition/Split.lean", "context": {"open": ["Function Set Filter", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b9 M : Type*} {n : \u2115}", "{I : Box \u03b9} {i : \u03b9} {x : \u211d} {y : \u03b9 \u2192 \u211d}", "{I J : Box \u03b9} {i : \u03b9} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Box : ?m.954\n\u03b9 : Sort ?u.966\nI\u271d : sorry\ni\u271d : \u03b9\nx\u271d\u00b9 : \u211d\ny : \u03b9 \u2192 \u211d\nI : sorry\nJ\u271d : sorry\ni : \u03b9\nx : \u211d\nJ : sorry\nx\u271d : Sort u_1\nsplit : x\u271d\n\u22a2 J \u2208 sorry \u2194 J = sorry \u2228 J = sorry"}, {"line": "simp [split]", "tactic_state": "Box : ?m.954\n\u03b9 : Sort ?u.966\nI\u271d : sorry\ni\u271d : \u03b9\nx\u271d\u00b9 : \u211d\ny : \u03b9 \u2192 \u211d\nI : sorry\nJ\u271d : sorry\ni : \u03b9\nx : \u211d\nJ : sorry\nx\u271d : Sort u_1\nsplit : x\u271d\n\u22a2 J \u2208 sorry () \u2194 J = sorry ()"}]}
{"declaration": "theorem iUnion_split (I : Box \u03b9) (i : \u03b9) (x : \u211d) : (split I i x).iUnion = I := by\n  simp [split, \u2190 inter_union_distrib_left, \u2190 setOf_or, le_or_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/BoxIntegral/Partition/Split.lean", "context": {"open": ["Function Set Filter", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b9 M : Type*} {n : \u2115}", "{I : Box \u03b9} {i : \u03b9} {x : \u211d} {y : \u03b9 \u2192 \u211d}", "{I J : Box \u03b9} {i : \u03b9} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Box : ?m.954\n\u03b9\u271d : Sort u_3\nI\u271d\u00b9 : sorry\ni\u271d\u00b9 : \u03b9\u271d\nx\u271d\u00b2 : \u211d\ny : \u03b9\u271d \u2192 \u211d\nI\u271d : sorry\nJ : sorry\ni\u271d : \u03b9\u271d\nx\u271d\u00b9 : \u211d\n\u03b9 : Sort u_3\nx\u271d : Sort u_1\nsplit : x\u271d\nI : sorry\ni : \u03b9\nx : \u211d\n\u22a2 sorry = I"}, {"line": "simp [split, \u2190 inter_union_distrib_left, \u2190 setOf_or, le_or_lt]", "tactic_state": "Box : ?m.954\n\u03b9\u271d : Sort u_3\nI\u271d\u00b9 : sorry\ni\u271d\u00b9 : \u03b9\u271d\nx\u271d\u00b2 : \u211d\ny : \u03b9\u271d \u2192 \u211d\nI\u271d : sorry\nJ : sorry\ni\u271d : \u03b9\u271d\nx\u271d\u00b9 : \u211d\n\u03b9 : Sort u_3\nx\u271d : Sort u_1\nsplit : x\u271d\nI : sorry\ni : \u03b9\nx : \u211d\n\u22a2 sorry () = I"}]}
{"declaration": "theorem spectrum.gelfandTransform_eq (a : A) :\n    spectrum \u2102 (gelfandTransform \u2102 A a) = spectrum \u2102 a := by\n  ext z\n  rw [ContinuousMap.spectrum_eq_range]\n  rw [WeakDual.CharacterSpace.mem_spectrum_iff_exists]\n  exact Iff.rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/CStarAlgebra/GelfandDuality.lean", "context": {"open": ["WeakDual", "scoped NNReal", "Ideal"], "variables": ["{A : Type*} [NormedCommRing A] [NormedAlgebra \u2102 A] [CompleteSpace A] (I : Ideal A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\ninst\u271d\u00b2 : NormedCommRing A\ninst\u271d\u00b9 : NormedAlgebra \u2102 A\ninst\u271d : CompleteSpace A\na : A\n\u22a2 spectrum \u2102 ((gelfandTransform \u2102 A) a) = spectrum \u2102 a"}, {"line": "ext z", "tactic_state": "case h\nA : Type u_1\ninst\u271d\u00b2 : NormedCommRing A\ninst\u271d\u00b9 : NormedAlgebra \u2102 A\ninst\u271d : CompleteSpace A\na : A\nz : \u2102\n\u22a2 z \u2208 spectrum \u2102 ((gelfandTransform \u2102 A) a) \u2194 z \u2208 spectrum \u2102 a"}, {"line": "rw [ContinuousMap.spectrum_eq_range]", "tactic_state": "case h\nA : Type u_1\ninst\u271d\u00b2 : NormedCommRing A\ninst\u271d\u00b9 : NormedAlgebra \u2102 A\ninst\u271d : CompleteSpace A\na : A\nz : \u2102\n\u22a2 z \u2208 Set.range \u21d1((gelfandTransform \u2102 A) a) \u2194 z \u2208 spectrum \u2102 a"}, {"line": "rw [WeakDual.CharacterSpace.mem_spectrum_iff_exists]", "tactic_state": "case h\nA : Type u_1\ninst\u271d\u00b2 : NormedCommRing A\ninst\u271d\u00b9 : NormedAlgebra \u2102 A\ninst\u271d : CompleteSpace A\na : A\nz : \u2102\n\u22a2 z \u2208 Set.range \u21d1((gelfandTransform \u2102 A) a) \u2194 \u2203 f, f a = z\n---\nA : Type u_1\ninst\u271d\u00b2 : NormedCommRing A\ninst\u271d\u00b9 : NormedAlgebra \u2102 A\ninst\u271d : CompleteSpace A\na : A\nz : \u2102\n\u22a2 CompleteSpace A"}, {"line": "exact Iff.rfl", "tactic_state": "A : Type u_1\ninst\u271d\u00b2 : NormedCommRing A\ninst\u271d\u00b9 : NormedAlgebra \u2102 A\ninst\u271d : CompleteSpace A\na : A\nz : \u2102\n\u22a2 CompleteSpace A"}]}
{"declaration": "theorem map_id (M : CStarMatrix m n A) : M.map id = M := by\n  ext\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/CStarAlgebra/CStarMatrix.lean", "context": {"open": ["scoped ComplexOrder Topology Uniformity Bornology Matrix NNReal InnerProductSpace"], "variables": ["{m n A B R S : Type*}", "(m n A) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_1\nn : Type u_2\nA : Type u_3\nM : CStarMatrix m n A\n\u22a2 M.map id = M"}, {"line": "ext", "tactic_state": "case h\nm : Type u_1\nn : Type u_2\nA : Type u_3\nM : CStarMatrix m n A\ni\u271d : m\nj\u271d : n\n\u22a2 M.map id i\u271d j\u271d = M i\u271d j\u271d"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toCLM_apply_single_apply [DecidableEq m] {M : CStarMatrix m n A}{i : m} {j : n} (a : A) :\n    (toCLM M) (equiv _ _ |>.symm <| Pi.single i a) j = a * M i j := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/CStarAlgebra/CStarMatrix.lean", "context": {"open": ["scoped ComplexOrder Topology Uniformity Bornology Matrix NNReal InnerProductSpace", "WithCStarModule in", "WithCStarModule in"], "variables": ["{m n A B R S : Type*}", "(m n A) in", "[Zero A] [One A] [DecidableEq n]", "[Fintype m] [NonUnitalCStarAlgebra A] [PartialOrder A] [StarOrderedRing A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_3\nA : Type u_4\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 : NonUnitalCStarAlgebra A\ninst\u271d\u00b2 : PartialOrder A\ninst\u271d\u00b9 : StarOrderedRing A\nn : Type u_1\nx\u271d : Sort u_2\ntoCLM : x\u271d\ninst\u271d : DecidableEq m\nM : CStarMatrix m n A\ni : m\nj : n\na : A\n\u22a2 sorry = a * M i j"}, {"line": "simp", "tactic_state": "m : Type u_3\nA : Type u_4\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 : NonUnitalCStarAlgebra A\ninst\u271d\u00b2 : PartialOrder A\ninst\u271d\u00b9 : StarOrderedRing A\nn : Type u_1\nx\u271d : Sort u_2\ntoCLM : x\u271d\ninst\u271d : DecidableEq m\nM : CStarMatrix m n A\ni : m\nj : n\na : A\n\u22a2 sorry () = a * M i j"}]}
{"declaration": "lemma mul_entry_mul_eq_inner_toCLM [Fintype n] [DecidableEq m] [DecidableEq n]\n    {M : CStarMatrix m n A} {i : m} {j : n} (a b : A) :\n    a * M i j * star b\n      = \u27eaequiv _ _ |>.symm (Pi.single j b), toCLM M (equiv _ _ |>.symm <| Pi.single i a)\u27eb_A := by\n  simp [mul_assoc, inner_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/CStarAlgebra/CStarMatrix.lean", "context": {"open": ["scoped ComplexOrder Topology Uniformity Bornology Matrix NNReal InnerProductSpace", "WithCStarModule in", "WithCStarModule in", "WithCStarModule in"], "variables": ["{m n A B R S : Type*}", "(m n A) in", "[Zero A] [One A] [DecidableEq n]", "[Fintype m] [NonUnitalCStarAlgebra A] [PartialOrder A] [StarOrderedRing A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_4\nA : Type u_5\ninst\u271d\u2076 : Fintype m\ninst\u271d\u2075 : NonUnitalCStarAlgebra A\ninst\u271d\u2074 : PartialOrder A\ninst\u271d\u00b3 : StarOrderedRing A\nn : Type u_1\nx\u271d\u00b9 : Sort u_2\nequiv : x\u271d\u00b9\nx\u271d : Sort u_3\ntoCLM : x\u271d\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq n\nM : CStarMatrix m n A\ni : m\nj : n\na b : A\n\u22a2 a * M i j * star b = inner sorry sorry"}, {"line": "simp [mul_assoc, inner_def]", "tactic_state": "m : Type u_4\nA : Type u_5\ninst\u271d\u2076 : Fintype m\ninst\u271d\u2075 : NonUnitalCStarAlgebra A\ninst\u271d\u2074 : PartialOrder A\ninst\u271d\u00b3 : StarOrderedRing A\nn : Type u_1\nx\u271d\u00b9 : Sort u_2\nequiv : x\u271d\u00b9\nx\u271d : Sort u_3\ntoCLM : x\u271d\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq n\nM : CStarMatrix m n A\ni : m\nj : n\na b : A\n\u22a2 a * M i j * star b = inner (sorry ()) (sorry ())"}]}
{"declaration": "lemma DoubleCentralizer.ext (\ud835\udd5c : Type u) (A : Type v) [NontriviallyNormedField \ud835\udd5c]\n    [NonUnitalNormedRing A] [NormedSpace \ud835\udd5c A] [SMulCommClass \ud835\udd5c A A] [IsScalarTower \ud835\udd5c A A]\n    (a b : \ud835\udcdc(\ud835\udd5c, A)) (h : a.toProd = b.toProd) : a = b := by\n  cases a\n  cases b\n  simpa using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/CStarAlgebra/Multiplier.lean", "context": {"open": ["NNReal ENNReal ContinuousLinearMap MulOpposite", "MultiplierAlgebra"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\nA : Type v\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NonUnitalNormedRing A\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c A\ninst\u271d\u00b9 : SMulCommClass \ud835\udd5c A A\ninst\u271d : IsScalarTower \ud835\udd5c A A\na b : DoubleCentralizer \ud835\udd5c A\nh : a.toProd = b.toProd\n\u22a2 a = b"}, {"line": "cases a", "tactic_state": "case mk\n\ud835\udd5c : Type u\nA : Type v\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NonUnitalNormedRing A\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c A\ninst\u271d\u00b9 : SMulCommClass \ud835\udd5c A A\ninst\u271d : IsScalarTower \ud835\udd5c A A\nb : DoubleCentralizer \ud835\udd5c A\ntoProd\u271d : (A \u2192L[\ud835\udd5c] A) \u00d7 (A \u2192L[\ud835\udd5c] A)\ncentral\u271d : \u2200 (x y : A), toProd\u271d.2 x * y = x * toProd\u271d.1 y\nh : { toProd := toProd\u271d, central := central\u271d }.toProd = b.toProd\n\u22a2 { toProd := toProd\u271d, central := central\u271d } = b"}, {"line": "cases b", "tactic_state": "case mk.mk\n\ud835\udd5c : Type u\nA : Type v\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NonUnitalNormedRing A\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c A\ninst\u271d\u00b9 : SMulCommClass \ud835\udd5c A A\ninst\u271d : IsScalarTower \ud835\udd5c A A\ntoProd\u271d\u00b9 : (A \u2192L[\ud835\udd5c] A) \u00d7 (A \u2192L[\ud835\udd5c] A)\ncentral\u271d\u00b9 : \u2200 (x y : A), toProd\u271d\u00b9.2 x * y = x * toProd\u271d\u00b9.1 y\ntoProd\u271d : (A \u2192L[\ud835\udd5c] A) \u00d7 (A \u2192L[\ud835\udd5c] A)\ncentral\u271d : \u2200 (x y : A), toProd\u271d.2 x * y = x * toProd\u271d.1 y\nh : { toProd := toProd\u271d\u00b9, central := central\u271d\u00b9 }.toProd = { toProd := toProd\u271d, central := central\u271d }.toProd\n\u22a2 { toProd := toProd\u271d\u00b9, central := central\u271d\u00b9 } = { toProd := toProd\u271d, central := central\u271d }"}, {"line": "simpa using h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma norm_apply_le (\u03c6 : F) (a : A) : \u2016\u03c6 a\u2016 \u2264 \u2016a\u2016 := by\n  exact_mod_cast nnnorm_apply_le \u03c6 a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/CStarAlgebra/Spectrum.lean", "context": {"open": ["scoped Topology ENNReal", "Filter ENNReal spectrum CStarRing NormedSpace", "scoped NNReal in", "Complex", "Unitization"], "variables": ["{\ud835\udd5c : Type*} [NormedField \ud835\udd5c] {E : Type*} [NormedRing E] [StarRing E] [CStarRing E]", "{A : Type*} [CStarAlgebra A]", "[StarModule \u2102 A]", "(S : StarSubalgebra \u2102 A) [hS : IsClosed (S : Set A)]", "{F A B : Type*} [NonUnitalCStarAlgebra A] [NonUnitalCStarAlgebra B]", "[FunLike F A B] [NonUnitalAlgHomClass F \u2102 A B] [StarHomClass F A B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_4\nA : Type u_5\nB : Type u_6\ninst\u271d\u2074 : NonUnitalCStarAlgebra A\ninst\u271d\u00b3 : NonUnitalCStarAlgebra B\ninst\u271d\u00b2 : FunLike F A B\ninst\u271d\u00b9 : NonUnitalAlgHomClass F \u2102 A B\ninst\u271d : StarHomClass F A B\n\u03c6 : F\na : A\n\u22a2 \u2016\u03c6 a\u2016 \u2264 \u2016a\u2016"}, {"line": "exact_mod_cast nnnorm_apply_le \u03c6 a", "tactic_state": "No Goals!"}]}
{"declaration": "lemma compactSpace {R S A : Type*} [Semifield R] [Semifield S] [Ring A]\n    [Algebra R S] [Algebra R A] [Algebra S A] [IsScalarTower R S A] [TopologicalSpace R]\n    [TopologicalSpace S] {a : A} (f : C(S, R)) (h : SpectrumRestricts a f)\n    [h_cpct : CompactSpace (spectrum S a)] : CompactSpace (spectrum R a) := by\n  rw [\u2190 isCompact_iff_compactSpace] at h_cpct \u22a2\n  exact h.image \u25b8 h_cpct.image (map_continuous f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Restrict.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\nA : Type u_3\ninst\u271d\u2078 : Semifield R\ninst\u271d\u2077 : Semifield S\ninst\u271d\u2076 : Ring A\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Algebra S A\ninst\u271d\u00b2 : IsScalarTower R S A\ninst\u271d\u00b9 : TopologicalSpace R\ninst\u271d : TopologicalSpace S\na : A\nf : C(S, R)\nh : SpectrumRestricts a \u21d1f\nh_cpct : CompactSpace \u2191(spectrum S a)\n\u22a2 CompactSpace \u2191(spectrum R a)"}, {"line": "rw [\u2190 isCompact_iff_compactSpace] at h_cpct \u22a2", "tactic_state": "R : Type u_1\nS : Type u_2\nA : Type u_3\ninst\u271d\u2078 : Semifield R\ninst\u271d\u2077 : Semifield S\ninst\u271d\u2076 : Ring A\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Algebra S A\ninst\u271d\u00b2 : IsScalarTower R S A\ninst\u271d\u00b9 : TopologicalSpace R\ninst\u271d : TopologicalSpace S\na : A\nf : C(S, R)\nh : SpectrumRestricts a \u21d1f\nh_cpct : IsCompact (spectrum S a)\n\u22a2 IsCompact (spectrum R a)"}, {"line": "exact h.image \u25b8 h_cpct.image (map_continuous f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma norm_cfc_le {f : \ud835\udd5c \u2192 \ud835\udd5c} {a : A} {c : \u211d} (hc : 0 \u2264 c) (h : \u2200 x \u2208 \u03c3 \ud835\udd5c a, \u2016f x\u2016 \u2264 c) :\n    \u2016cfc f a\u2016 \u2264 c := by\n  obtain (_ | _) := subsingleton_or_nontrivial A\n  \u00b7 simpa [Subsingleton.elim (cfc f a) 0]\n  \u00b7 refine cfc_cases (\u2016\u00b7\u2016 \u2264 c) a f (by simpa) fun hf ha \u21a6 ?_\n    simp only [\u2190 cfc_apply f a]\n    simp only [isLUB_le_iff (IsGreatest.norm_cfc f a hf ha |>.isLUB)]\n    rintro - \u27e8x, hx, rfl\u27e9\n    exact h x hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Isometric.lean", "context": {"open": ["scoped ContinuousFunctionalCalculus", "scoped ContinuousFunctionalCalculus"], "variables": ["{\ud835\udd5c A : Type*} {p : outParam (A \u2192 Prop)}", "[RCLike \ud835\udd5c] [NormedRing A] [StarRing A] [NormedAlgebra \ud835\udd5c A]", "[IsometricContinuousFunctionalCalculus \ud835\udd5c A p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nA : Type u_2\np : outParam (A \u2192 Prop)\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedRing A\ninst\u271d\u00b2 : StarRing A\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c A\ninst\u271d : IsometricContinuousFunctionalCalculus \ud835\udd5c A p\nx\u271d : Sort u_3\n\u03c3 : x\u271d\nf : \ud835\udd5c \u2192 \ud835\udd5c\na : A\nc : \u211d\nhc : 0 \u2264 c\nh : \u2200 x \u2208 ?m.2409, \u2016f x\u2016 \u2264 c\n\u22a2 \u2016cfc f a\u2016 \u2264 c"}, {"line": "obtain (_ | _) := subsingleton_or_nontrivial A", "tactic_state": "case inl\n\ud835\udd5c : Type u_1\nA : Type u_2\np : outParam (A \u2192 Prop)\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedRing A\ninst\u271d\u00b2 : StarRing A\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c A\ninst\u271d : IsometricContinuousFunctionalCalculus \ud835\udd5c A p\nx\u271d : Sort u_3\n\u03c3 : x\u271d\nf : \ud835\udd5c \u2192 \ud835\udd5c\na : A\nc : \u211d\nhc : 0 \u2264 c\nh : \u2200 x \u2208 ?m.2409, \u2016f x\u2016 \u2264 c\nh\u271d : Subsingleton A\n\u22a2 \u2016cfc f a\u2016 \u2264 c\n---\ncase inr\n\ud835\udd5c : Type u_1\nA : Type u_2\np : outParam (A \u2192 Prop)\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedRing A\ninst\u271d\u00b2 : StarRing A\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c A\ninst\u271d : IsometricContinuousFunctionalCalculus \ud835\udd5c A p\nx\u271d : Sort u_3\n\u03c3 : x\u271d\nf : \ud835\udd5c \u2192 \ud835\udd5c\na : A\nc : \u211d\nhc : 0 \u2264 c\nh : \u2200 x \u2208 ?m.2409, \u2016f x\u2016 \u2264 c\nh\u271d : Nontrivial A\n\u22a2 \u2016cfc f a\u2016 \u2264 c"}, {"line": "\u00b7 simpa [Subsingleton.elim (cfc f a) 0]", "tactic_state": "case inr\n\ud835\udd5c : Type u_1\nA : Type u_2\np : outParam (A \u2192 Prop)\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedRing A\ninst\u271d\u00b2 : StarRing A\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c A\ninst\u271d : IsometricContinuousFunctionalCalculus \ud835\udd5c A p\nx\u271d : Sort u_3\n\u03c3 : x\u271d\nf : \ud835\udd5c \u2192 \ud835\udd5c\na : A\nc : \u211d\nhc : 0 \u2264 c\nh : \u2200 x \u2208 ?m.2409, \u2016f x\u2016 \u2264 c\nh\u271d : Nontrivial A\n\u22a2 \u2016cfc f a\u2016 \u2264 c"}, {"line": "\u00b7 refine cfc_cases (\u2016\u00b7\u2016 \u2264 c) a f (by simpa) fun hf ha \u21a6 ?_\n    simp only [\u2190 cfc_apply f a]\n    simp only [isLUB_le_iff (IsGreatest.norm_cfc f a hf ha |>.isLUB)]\n    rintro - \u27e8x, hx, rfl\u27e9\n    exact h x hx", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inr_nonneg_iff {a : A} : 0 \u2264 (a : A\u207a\u00b9) \u2194 0 \u2264 a := by\n  by_cases ha : IsSelfAdjoint a\n  \u00b7 exact inr_zero \u2102 (A := A) \u25b8 inr_le_iff 0 a\n  \u00b7 refine \u27e8?_, ?_\u27e9\n    all_goals refine fun h \u21a6 (ha ?_).elim\n    \u00b7 exact isSelfAdjoint_inr (R := \u2102) |>.mp <| .of_nonneg h\n    \u00b7 exact .of_nonneg h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Order.lean", "context": {"open": ["scoped NNReal CStarAlgebra"], "variables": ["{A : Type*} [NonUnitalCStarAlgebra A] [PartialOrder A] [StarOrderedRing A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\ninst\u271d\u00b2 : NonUnitalCStarAlgebra A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\na : A\n\u22a2 0 \u2264 \u2191a \u2194 0 \u2264 a"}, {"line": "by_cases ha : IsSelfAdjoint a", "tactic_state": "case pos\nA : Type u_1\ninst\u271d\u00b2 : NonUnitalCStarAlgebra A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\na : A\nha : sorry\n\u22a2 0 \u2264 \u2191a \u2194 0 \u2264 a\n---\ncase neg\nA : Type u_1\ninst\u271d\u00b2 : NonUnitalCStarAlgebra A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\na : A\nha : \u00acsorry\n\u22a2 0 \u2264 \u2191a \u2194 0 \u2264 a"}, {"line": "\u00b7 exact inr_zero \u2102 (A := A) \u25b8 inr_le_iff 0 a", "tactic_state": "case neg\nA : Type u_1\ninst\u271d\u00b2 : NonUnitalCStarAlgebra A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\na : A\nha : \u00acsorry\n\u22a2 0 \u2264 \u2191a \u2194 0 \u2264 a"}, {"line": "\u00b7 refine \u27e8?_, ?_\u27e9\n    all_goals refine fun h \u21a6 (ha ?_).elim\n    \u00b7 exact isSelfAdjoint_inr (R := \u2102) |>.mp <| .of_nonneg h\n    \u00b7 exact .of_nonneg h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_le_iff {a b : A\u02e3} (ha : 0 \u2264 (a : A)) (hb : 0 \u2264 (\u2191b : A)) :\n    (\u2191a\u207b\u00b9 : A) \u2264 b \u2194 (\u2191b\u207b\u00b9 : A) \u2264 a := by\n  simpa using CStarAlgebra.inv_le_inv_iff ha (inv_nonneg_of_nonneg b hb)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Order.lean", "context": {"open": ["scoped NNReal CStarAlgebra", "ContinuousFunctionalCalculus in", "Set", "CFC"], "variables": ["{A : Type*} [NonUnitalCStarAlgebra A] [PartialOrder A] [StarOrderedRing A]", "{A : Type*} [CStarAlgebra A]", "[PartialOrder A] [StarOrderedRing A]", "[PartialOrder A] [StarOrderedRing A]", "[PartialOrder A] [StarOrderedRing A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\ninst\u271d\u2076 : CStarAlgebra A\ninst\u271d\u2075 : PartialOrder A\ninst\u271d\u2074 : StarOrderedRing A\ninst\u271d\u00b3 : PartialOrder A\ninst\u271d\u00b2 : StarOrderedRing A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\na b : A\u02e3\nha : 0 \u2264 \u2191a\nhb : 0 \u2264 \u2191b\n\u22a2 \u2191a\u207b\u00b9 \u2264 \u2191b \u2194 \u2191b\u207b\u00b9 \u2264 \u2191a"}, {"line": "simpa using CStarAlgebra.inv_le_inv_iff ha (inv_nonneg_of_nonneg b hb)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_inv_iff {a b : A\u02e3} (ha : 0 \u2264 (a : A)) (hb : 0 \u2264 (\u2191b : A)) :\n    a \u2264 (\u2191b\u207b\u00b9 : A) \u2194 b \u2264 (\u2191a\u207b\u00b9 : A) := by\n  simpa using CStarAlgebra.inv_le_inv_iff (inv_nonneg_of_nonneg a ha) hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Order.lean", "context": {"open": ["scoped NNReal CStarAlgebra", "ContinuousFunctionalCalculus in", "Set", "CFC"], "variables": ["{A : Type*} [NonUnitalCStarAlgebra A] [PartialOrder A] [StarOrderedRing A]", "{A : Type*} [CStarAlgebra A]", "[PartialOrder A] [StarOrderedRing A]", "[PartialOrder A] [StarOrderedRing A]", "[PartialOrder A] [StarOrderedRing A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\ninst\u271d\u2076 : CStarAlgebra A\ninst\u271d\u2075 : PartialOrder A\ninst\u271d\u2074 : StarOrderedRing A\ninst\u271d\u00b3 : PartialOrder A\ninst\u271d\u00b2 : StarOrderedRing A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\na b : A\u02e3\nha : 0 \u2264 \u2191a\nhb : 0 \u2264 \u2191b\n\u22a2 \u2191a \u2264 \u2191b\u207b\u00b9 \u2194 \u2191b \u2264 \u2191a\u207b\u00b9"}, {"line": "simpa using CStarAlgebra.inv_le_inv_iff (inv_nonneg_of_nonneg a ha) hb", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_le_inv_iff_le_one {a : A\u02e3} (ha : 0 \u2264 (a : A)) :\n    1 \u2264 (\u2191a\u207b\u00b9 : A) \u2194 a \u2264 1 := by\n  simpa using CStarAlgebra.le_inv_iff (a := 1) (by simp) ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Order.lean", "context": {"open": ["scoped NNReal CStarAlgebra", "ContinuousFunctionalCalculus in", "Set", "CFC"], "variables": ["{A : Type*} [NonUnitalCStarAlgebra A] [PartialOrder A] [StarOrderedRing A]", "{A : Type*} [CStarAlgebra A]", "[PartialOrder A] [StarOrderedRing A]", "[PartialOrder A] [StarOrderedRing A]", "[PartialOrder A] [StarOrderedRing A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\ninst\u271d\u2076 : CStarAlgebra A\ninst\u271d\u2075 : PartialOrder A\ninst\u271d\u2074 : StarOrderedRing A\ninst\u271d\u00b3 : PartialOrder A\ninst\u271d\u00b2 : StarOrderedRing A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\na : A\u02e3\nha : 0 \u2264 \u2191a\n\u22a2 1 \u2264 \u2191a\u207b\u00b9 \u2194 a \u2264 1"}, {"line": "simpa using CStarAlgebra.le_inv_iff (a := 1) (by simp) ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_le_one_iff_one_le {a : A\u02e3} (ha : 0 \u2264 (a : A)) :\n    (\u2191a\u207b\u00b9 : A) \u2264 1 \u2194 1 \u2264 a := by\n  simpa using CStarAlgebra.inv_le_iff ha (b := 1) (by simp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Order.lean", "context": {"open": ["scoped NNReal CStarAlgebra", "ContinuousFunctionalCalculus in", "Set", "CFC"], "variables": ["{A : Type*} [NonUnitalCStarAlgebra A] [PartialOrder A] [StarOrderedRing A]", "{A : Type*} [CStarAlgebra A]", "[PartialOrder A] [StarOrderedRing A]", "[PartialOrder A] [StarOrderedRing A]", "[PartialOrder A] [StarOrderedRing A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\ninst\u271d\u2076 : CStarAlgebra A\ninst\u271d\u2075 : PartialOrder A\ninst\u271d\u2074 : StarOrderedRing A\ninst\u271d\u00b3 : PartialOrder A\ninst\u271d\u00b2 : StarOrderedRing A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\na : A\u02e3\nha : 0 \u2264 \u2191a\n\u22a2 \u2191a\u207b\u00b9 \u2264 1 \u2194 1 \u2264 a"}, {"line": "simpa using CStarAlgebra.inv_le_iff ha (b := 1) (by simp)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_one_of_one_le_inv {a : A\u02e3} (ha : 1 \u2264 (\u2191a\u207b\u00b9 : A)) : (a : A) \u2264 1 := by\n  simpa using CStarAlgebra.inv_le_one ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Order.lean", "context": {"open": ["scoped NNReal CStarAlgebra", "ContinuousFunctionalCalculus in", "Set", "CFC"], "variables": ["{A : Type*} [NonUnitalCStarAlgebra A] [PartialOrder A] [StarOrderedRing A]", "{A : Type*} [CStarAlgebra A]", "[PartialOrder A] [StarOrderedRing A]", "[PartialOrder A] [StarOrderedRing A]", "[PartialOrder A] [StarOrderedRing A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\ninst\u271d\u2076 : CStarAlgebra A\ninst\u271d\u2075 : PartialOrder A\ninst\u271d\u2074 : StarOrderedRing A\ninst\u271d\u00b3 : PartialOrder A\ninst\u271d\u00b2 : StarOrderedRing A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\na : A\u02e3\nha : 1 \u2264 \u2191a\u207b\u00b9\n\u22a2 \u2191a \u2264 1"}, {"line": "simpa using CStarAlgebra.inv_le_one ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_inr_Icc_zero_one :\n    ((\u2191) : A \u2192 A\u207a\u00b9) \u207b\u00b9' Icc 0 1 = {x : A | 0 \u2264 x} \u2229 closedBall 0 1 := by\n  ext\n  simp [- mem_Icc, inr_mem_Icc_iff_norm_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Order.lean", "context": {"open": ["scoped NNReal CStarAlgebra", "ContinuousFunctionalCalculus in", "Set", "CFC", "ComplexOrder in", "Unitization Set Metric"], "variables": ["{A : Type*} [NonUnitalCStarAlgebra A] [PartialOrder A] [StarOrderedRing A]", "{A : Type*} [CStarAlgebra A]", "[PartialOrder A] [StarOrderedRing A]", "[PartialOrder A] [StarOrderedRing A]", "[PartialOrder A] [StarOrderedRing A]", "{A : Type*} [NonUnitalCStarAlgebra A] [PartialOrder A] [StarOrderedRing A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_3\ninst\u271d\u00b2 : NonUnitalCStarAlgebra A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\nx\u271d\u00b9 : Sort u_4\nIcc : x\u271d\u00b9\nx\u271d : Sort u_5\nclosedBall : x\u271d\n\u22a2 Unitization.inr \u207b\u00b9' sorry = {x | 0 \u2264 x} \u2229 sorry"}, {"line": "ext", "tactic_state": "case h\nA : Type u_3\ninst\u271d\u00b2 : NonUnitalCStarAlgebra A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\nx\u271d\u00b2 : Sort u_4\nIcc : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\nclosedBall : x\u271d\u00b9\nx\u271d : A\n\u22a2 x\u271d \u2208 Unitization.inr \u207b\u00b9' sorry \u2194 x\u271d \u2208 {x | 0 \u2264 x} \u2229 sorry"}, {"line": "simp [- mem_Icc, inr_mem_Icc_iff_norm_le]", "tactic_state": "case h\nA : Type u_3\ninst\u271d\u00b2 : NonUnitalCStarAlgebra A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\nx\u271d\u00b2 : Sort u_4\nIcc : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\nclosedBall : x\u271d\u00b9\nx\u271d : A\n\u22a2 \u2191x\u271d \u2208 sorry () \u2194 0 \u2264 x\u271d \u2227 x\u271d \u2208 sorry ()"}]}
{"declaration": "private lemma antilipschitzWith_card_equiv_pi_aux :\n    AntilipschitzWith (Fintype.card \u03b9) (equiv A (\u03a0 i, E i)) :=\n  AddMonoidHomClass.antilipschitz_of_bound (linearEquiv \u2102 A (\u03a0 i, E i)) fun x \u21a6 by\n    simp only [NNReal.coe_natCast]\n    simp only [linearEquiv_apply]\n    calc \u2016x\u2016 \u2264 \u2211 i, \u2016x i\u2016 := pi_norm_le_sum_norm x\n      _ \u2264 \u2211 _, \u2016\u21d1x\u2016 := Finset.sum_le_sum fun _ _ \u21a6 norm_le_pi_norm ..\n      _ \u2264 Fintype.card \u03b9 * \u2016\u21d1x\u2016 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/CStarAlgebra/Module/Constructions.lean", "context": {"open": ["CStarModule CStarRing", "scoped InnerProductSpace in", "scoped InnerProductSpace", "Filter Uniformity Bornology", "scoped InnerProductSpace", "Finset in", "Finset in", "Finset in", "Uniformity Bornology"], "variables": ["{A : Type*} [NonUnitalCStarAlgebra A] [PartialOrder A]", "[StarOrderedRing A]", "{E F : Type*}", "[NormedAddCommGroup E] [Module \u2102 E] [SMul A E]", "[NormedAddCommGroup F] [Module \u2102 F] [SMul A F]", "[CStarModule A E] [CStarModule A F]", "[StarOrderedRing A]", "{\u03b9 : Type*} {E : \u03b9 \u2192 Type*} [Fintype \u03b9]", "[\u2200 i, NormedAddCommGroup (E i)] [\u2200 i, Module \u2102 (E i)] [\u2200 i, SMul A (E i)]", "[\u2200 i, CStarModule A (E i)]", "[StarOrderedRing A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_4\ninst\u271d : Fintype \u03b9\nx\u271d : Sort u_6\nequiv : x\u271d\nx : ?m.23857\n\u22a2 \u2016x\u2016 \u2264 \u2191?m.23864 * \u2016sorry x\u2016"}, {"line": "simp", "tactic_state": "\u03b9 : Type u_4\ninst\u271d : Fintype \u03b9\nx\u271d : Sort u_6\nequiv : x\u271d\nx : ?m.23857\n\u22a2 \u2016x\u2016 \u2264 \u2191?m.23864 * \u2016(sorry ()) x\u2016"}]}
{"declaration": "theorem lhopital_zero_right_on_Ioo (hab : a < b) (hff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x)\n    (hgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x) (hg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0)\n    (hfa : Tendsto f (\ud835\udcdd[>] a) (\ud835\udcdd 0)) (hga : Tendsto g (\ud835\udcdd[>] a) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (\ud835\udcdd[>] a) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[>] a) l := by\n  have sub : \u2200 x \u2208 Ioo a b, Ioo a x \u2286 Ioo a b := fun x hx =>\n    Ioo_subset_Ioo (le_refl a) (le_of_lt hx.2)\n  have hg : \u2200 x \u2208 Ioo a b, g x \u2260 0 := by\n    intro x hx h\n    have : Tendsto g (\ud835\udcdd[<] x) (\ud835\udcdd 0) := by\n      rw [\u2190 h]\n      rw [\u2190 nhdsWithin_Ioo_eq_nhdsLT hx.1]\n      exact ((hgg' x hx).continuousAt.continuousWithinAt.mono <| sub x hx).tendsto\n    obtain \u27e8y, hyx, hy\u27e9 : \u2203 c \u2208 Ioo a x, g' c = 0 :=\n      exists_hasDerivAt_eq_zero' hx.1 hga this fun y hy => hgg' y <| sub x hx hy\n    exact hg' y (sub x hx hyx) hy\n  have : \u2200 x \u2208 Ioo a b, \u2203 c \u2208 Ioo a x, f x * g' c = g x * f' c := by\n    intro x hx\n    rw [\u2190 sub_zero (f x)]\n    rw [\u2190 sub_zero (g x)]\n    exact exists_ratio_hasDerivAt_eq_ratio_slope' g g' hx.1 f f' (fun y hy => hgg' y <| sub x hx hy)\n      (fun y hy => hff' y <| sub x hx hy) hga hfa\n      (tendsto_nhdsWithin_of_tendsto_nhds (hgg' x hx).continuousAt.tendsto)\n      (tendsto_nhdsWithin_of_tendsto_nhds (hff' x hx).continuousAt.tendsto)\n  choose! c hc using this\n  have : \u2200 x \u2208 Ioo a b, ((fun x' => f' x' / g' x') \u2218 c) x = f x / g x := by\n    intro x hx\n    rcases hc x hx with \u27e8h\u2081, h\u2082\u27e9\n    field_simp [hg x hx, hg' (c x) ((sub x hx) h\u2081)]\n    simp only [h\u2082]\n    rw [mul_comm]\n  have cmp : \u2200 x \u2208 Ioo a b, a < c x \u2227 c x < x := fun x hx => (hc x hx).1\n  rw [\u2190 nhdsWithin_Ioo_eq_nhdsGT hab]\n  apply tendsto_nhdsWithin_congr this\n  apply hdiv.comp\n  refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _\n    (tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds\n      (tendsto_nhdsWithin_of_tendsto_nhds tendsto_id) ?_ ?_) ?_\n  all_goals\n    apply eventually_nhdsWithin_of_forall\n    intro x hx\n    have := cmp x hx\n    try simp\n    linarith [this]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LHopital.lean", "context": {"open": ["Filter Set", "scoped Filter Topology Pointwise"], "variables": ["{a b : \u211d} {l : Filter \u211d} {f f' g g' : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhab : a < b\nhff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x\nhg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Ioi a)) l\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Ioi a)) l"}, {"line": "have sub : \u2200 x \u2208 Ioo a b, Ioo a x \u2286 Ioo a b := fun x hx =>\n    Ioo_subset_Ioo (le_refl a) (le_of_lt hx.2)", "tactic_state": "a b : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhab : a < b\nhff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x\nhg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Ioi a)) l\nsub : \u2200 x \u2208 Ioo a b, Ioo a x \u2286 Ioo a b\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Ioi a)) l"}, {"line": "have hg : \u2200 x \u2208 Ioo a b, g x \u2260 0 := sorry", "tactic_state": "a b : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhab : a < b\nhff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x\nhg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Ioi a)) l\nsub : \u2200 x \u2208 Ioo a b, Ioo a x \u2286 Ioo a b\nhg : \u2200 x \u2208 Ioo a b, g x \u2260 0\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Ioi a)) l"}, {"line": "have : \u2200 x \u2208 Ioo a b, \u2203 c \u2208 Ioo a x, f x * g' c = g x * f' c := by\n    intro x hx\n    rw [\u2190 sub_zero (f x)]\n    rw [\u2190 sub_zero (g x)]\n    exact exists_ratio_hasDerivAt_eq_ratio_slope' g g' hx.1 f f' (fun y hy => hgg' y <| sub x hx hy)\n      (fun y hy => hff' y <| sub x hx hy) hga hfa\n      (tendsto_nhdsWithin_of_tendsto_nhds (hgg' x hx).continuousAt.tendsto)\n      (tendsto_nhdsWithin_of_tendsto_nhds (hff' x hx).continuousAt.tendsto)", "tactic_state": "a b : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhab : a < b\nhff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x\nhg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Ioi a)) l\nsub : \u2200 x \u2208 Ioo a b, Ioo a x \u2286 Ioo a b\nhg : \u2200 x \u2208 Ioo a b, g x \u2260 0\nthis : \u2200 x \u2208 Ioo a b, \u2203 c \u2208 Ioo a x, f x * g' c = g x * f' c\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Ioi a)) l"}, {"line": "choose! c hc using this", "tactic_state": "a b : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhab : a < b\nhff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x\nhg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Ioi a)) l\nsub : \u2200 x \u2208 Ioo a b, Ioo a x \u2286 Ioo a b\nhg : \u2200 x \u2208 Ioo a b, g x \u2260 0\nc : \u211d \u2192 \u211d\nhc : \u2200 x \u2208 Ioo a b, c x \u2208 Ioo a x \u2227 f x * g' (c x) = g x * f' (c x)\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Ioi a)) l"}, {"line": "have : \u2200 x \u2208 Ioo a b, ((fun x' => f' x' / g' x') \u2218 c) x = f x / g x := by\n    intro x hx\n    rcases hc x hx with \u27e8h\u2081, h\u2082\u27e9\n    field_simp [hg x hx, hg' (c x) ((sub x hx) h\u2081)]\n    simp only [h\u2082]\n    rw [mul_comm]", "tactic_state": "a b : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhab : a < b\nhff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x\nhg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Ioi a)) l\nsub : \u2200 x \u2208 Ioo a b, Ioo a x \u2286 Ioo a b\nhg : \u2200 x \u2208 Ioo a b, g x \u2260 0\nc : \u211d \u2192 \u211d\nhc : \u2200 x \u2208 Ioo a b, c x \u2208 Ioo a x \u2227 f x * g' (c x) = g x * f' (c x)\nthis : \u2200 x \u2208 Ioo a b, ((fun x' => f' x' / g' x') \u2218 c) x = f x / g x\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Ioi a)) l"}, {"line": "have cmp : \u2200 x \u2208 Ioo a b, a < c x \u2227 c x < x := fun x hx => (hc x hx).1", "tactic_state": "a b : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhab : a < b\nhff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x\nhg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Ioi a)) l\nsub : \u2200 x \u2208 Ioo a b, Ioo a x \u2286 Ioo a b\nhg : \u2200 x \u2208 Ioo a b, g x \u2260 0\nc : \u211d \u2192 \u211d\nhc : \u2200 x \u2208 Ioo a b, c x \u2208 Ioo a x \u2227 f x * g' (c x) = g x * f' (c x)\nthis : \u2200 x \u2208 Ioo a b, ((fun x' => f' x' / g' x') \u2218 c) x = f x / g x\ncmp : \u2200 x \u2208 Ioo a b, a < c x \u2227 c x < x\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Ioi a)) l"}, {"line": "rw [\u2190 nhdsWithin_Ioo_eq_nhdsGT hab]", "tactic_state": "a b : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhab : a < b\nhff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x\nhg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Ioi a)) l\nsub : \u2200 x \u2208 Ioo a b, Ioo a x \u2286 Ioo a b\nhg : \u2200 x \u2208 Ioo a b, g x \u2260 0\nc : \u211d \u2192 \u211d\nhc : \u2200 x \u2208 Ioo a b, c x \u2208 Ioo a x \u2227 f x * g' (c x) = g x * f' (c x)\nthis : \u2200 x \u2208 Ioo a b, ((fun x' => f' x' / g' x') \u2218 c) x = f x / g x\ncmp : \u2200 x \u2208 Ioo a b, a < c x \u2227 c x < x\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Ioo a b)) l"}, {"line": "apply tendsto_nhdsWithin_congr this", "tactic_state": "a b : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhab : a < b\nhff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x\nhg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Ioi a)) l\nsub : \u2200 x \u2208 Ioo a b, Ioo a x \u2286 Ioo a b\nhg : \u2200 x \u2208 Ioo a b, g x \u2260 0\nc : \u211d \u2192 \u211d\nhc : \u2200 x \u2208 Ioo a b, c x \u2208 Ioo a x \u2227 f x * g' (c x) = g x * f' (c x)\nthis : \u2200 x \u2208 Ioo a b, ((fun x' => f' x' / g' x') \u2218 c) x = f x / g x\ncmp : \u2200 x \u2208 Ioo a b, a < c x \u2227 c x < x\n\u22a2 Tendsto ((fun x' => f' x' / g' x') \u2218 c) (nhdsWithin a (Ioo a b)) l"}, {"line": "apply hdiv.comp", "tactic_state": "a b : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhab : a < b\nhff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x\nhg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Ioi a)) l\nsub : \u2200 x \u2208 Ioo a b, Ioo a x \u2286 Ioo a b\nhg : \u2200 x \u2208 Ioo a b, g x \u2260 0\nc : \u211d \u2192 \u211d\nhc : \u2200 x \u2208 Ioo a b, c x \u2208 Ioo a x \u2227 f x * g' (c x) = g x * f' (c x)\nthis : \u2200 x \u2208 Ioo a b, ((fun x' => f' x' / g' x') \u2218 c) x = f x / g x\ncmp : \u2200 x \u2208 Ioo a b, a < c x \u2227 c x < x\n\u22a2 Tendsto c (nhdsWithin a (Ioo a b)) (nhdsWithin a (Ioi a))"}, {"line": "refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _\n    (tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds\n      (tendsto_nhdsWithin_of_tendsto_nhds tendsto_id) ?_ ?_) ?_", "tactic_state": "case refine_1\na b : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhab : a < b\nhff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x\nhg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Ioi a)) l\nsub : \u2200 x \u2208 Ioo a b, Ioo a x \u2286 Ioo a b\nhg : \u2200 x \u2208 Ioo a b, g x \u2260 0\nc : \u211d \u2192 \u211d\nhc : \u2200 x \u2208 Ioo a b, c x \u2208 Ioo a x \u2227 f x * g' (c x) = g x * f' (c x)\nthis : \u2200 x \u2208 Ioo a b, ((fun x' => f' x' / g' x') \u2218 c) x = f x / g x\ncmp : \u2200 x \u2208 Ioo a b, a < c x \u2227 c x < x\n\u22a2 \u2200\u1da0 (b : \u211d) in nhdsWithin a (Ioo a b), a \u2264 c b\n---\ncase refine_2\na b : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhab : a < b\nhff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x\nhg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Ioi a)) l\nsub : \u2200 x \u2208 Ioo a b, Ioo a x \u2286 Ioo a b\nhg : \u2200 x \u2208 Ioo a b, g x \u2260 0\nc : \u211d \u2192 \u211d\nhc : \u2200 x \u2208 Ioo a b, c x \u2208 Ioo a x \u2227 f x * g' (c x) = g x * f' (c x)\nthis : \u2200 x \u2208 Ioo a b, ((fun x' => f' x' / g' x') \u2218 c) x = f x / g x\ncmp : \u2200 x \u2208 Ioo a b, a < c x \u2227 c x < x\n\u22a2 \u2200\u1da0 (b : \u211d) in nhdsWithin a (Ioo a b), c b \u2264 id b\n---\ncase refine_3\na b : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhab : a < b\nhff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x\nhg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Ioi a)) l\nsub : \u2200 x \u2208 Ioo a b, Ioo a x \u2286 Ioo a b\nhg : \u2200 x \u2208 Ioo a b, g x \u2260 0\nc : \u211d \u2192 \u211d\nhc : \u2200 x \u2208 Ioo a b, c x \u2208 Ioo a x \u2227 f x * g' (c x) = g x * f' (c x)\nthis : \u2200 x \u2208 Ioo a b, ((fun x' => f' x' / g' x') \u2218 c) x = f x / g x\ncmp : \u2200 x \u2208 Ioo a b, a < c x \u2227 c x < x\n\u22a2 \u2200\u1da0 (x : \u211d) in nhdsWithin a (Ioo a b), c x \u2208 Ioi a"}, {"line": "all_goals\n    apply eventually_nhdsWithin_of_forall\n    intro x hx\n    have := cmp x hx\n    try simp\n    linarith [this]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lhopital_zero_right_on_Ioo (hab : a < b) (hdf : DifferentiableOn \u211d f (Ioo a b))\n    (hg' : \u2200 x \u2208 Ioo a b, deriv g x \u2260 0) (hfa : Tendsto f (\ud835\udcdd[>] a) (\ud835\udcdd 0))\n    (hga : Tendsto g (\ud835\udcdd[>] a) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (\ud835\udcdd[>] a) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[>] a) l := by\n  have hdf : \u2200 x \u2208 Ioo a b, DifferentiableAt \u211d f x := fun x hx =>\n    (hdf x hx).differentiableAt (Ioo_mem_nhds hx.1 hx.2)\n  have hdg : \u2200 x \u2208 Ioo a b, DifferentiableAt \u211d g x := fun x hx =>\n    by_contradiction fun h => hg' x hx (deriv_zero_of_not_differentiableAt h)\n  exact HasDerivAt.lhopital_zero_right_on_Ioo hab (fun x hx => (hdf x hx).hasDerivAt)\n    (fun x hx => (hdg x hx).hasDerivAt) hg' hfa hga hdiv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LHopital.lean", "context": {"open": ["Filter Set", "scoped Filter Topology Pointwise"], "variables": ["{a b : \u211d} {l : Filter \u211d} {f f' g g' : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhab : a < b\nhdf : DifferentiableOn \u211d f (Ioo a b)\nhg' : \u2200 x \u2208 Ioo a b, deriv g x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) (nhdsWithin a (Ioi a)) l\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Ioi a)) l"}, {"line": "have hdf : \u2200 x \u2208 Ioo a b, DifferentiableAt \u211d f x := fun x hx =>\n    (hdf x hx).differentiableAt (Ioo_mem_nhds hx.1 hx.2)", "tactic_state": "a b : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhab : a < b\nhdf\u271d : DifferentiableOn \u211d f (Ioo a b)\nhg' : \u2200 x \u2208 Ioo a b, deriv g x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) (nhdsWithin a (Ioi a)) l\nhdf : \u2200 x \u2208 Ioo a b, DifferentiableAt \u211d f x\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Ioi a)) l"}, {"line": "have hdg : \u2200 x \u2208 Ioo a b, DifferentiableAt \u211d g x := fun x hx =>\n    by_contradiction fun h => hg' x hx (deriv_zero_of_not_differentiableAt h)", "tactic_state": "a b : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhab : a < b\nhdf\u271d : DifferentiableOn \u211d f (Ioo a b)\nhg' : \u2200 x \u2208 Ioo a b, deriv g x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) (nhdsWithin a (Ioi a)) l\nhdf : \u2200 x \u2208 Ioo a b, DifferentiableAt \u211d f x\nhdg : \u2200 x \u2208 Ioo a b, DifferentiableAt \u211d g x\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Ioi a)) l"}, {"line": "exact HasDerivAt.lhopital_zero_right_on_Ioo hab (fun x hx => (hdf x hx).hasDerivAt)\n    (fun x hx => (hdg x hx).hasDerivAt) hg' hfa hga hdiv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lhopital_zero_left_on_Ioo (hab : a < b) (hdf : DifferentiableOn \u211d f (Ioo a b))\n    (hg' : \u2200 x \u2208 Ioo a b, (deriv g) x \u2260 0) (hfb : Tendsto f (\ud835\udcdd[<] b) (\ud835\udcdd 0))\n    (hgb : Tendsto g (\ud835\udcdd[<] b) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (\ud835\udcdd[<] b) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[<] b) l := by\n  have hdf : \u2200 x \u2208 Ioo a b, DifferentiableAt \u211d f x := fun x hx =>\n    (hdf x hx).differentiableAt (Ioo_mem_nhds hx.1 hx.2)\n  have hdg : \u2200 x \u2208 Ioo a b, DifferentiableAt \u211d g x := fun x hx =>\n    by_contradiction fun h => hg' x hx (deriv_zero_of_not_differentiableAt h)\n  exact HasDerivAt.lhopital_zero_left_on_Ioo hab (fun x hx => (hdf x hx).hasDerivAt)\n    (fun x hx => (hdg x hx).hasDerivAt) hg' hfb hgb hdiv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LHopital.lean", "context": {"open": ["Filter Set", "scoped Filter Topology Pointwise"], "variables": ["{a b : \u211d} {l : Filter \u211d} {f f' g g' : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhab : a < b\nhdf : DifferentiableOn \u211d f (Ioo a b)\nhg' : \u2200 x \u2208 Ioo a b, deriv g x \u2260 0\nhfb : Tendsto f (nhdsWithin b (Iio b)) (nhds 0)\nhgb : Tendsto g (nhdsWithin b (Iio b)) (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) (nhdsWithin b (Iio b)) l\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin b (Iio b)) l"}, {"line": "have hdf : \u2200 x \u2208 Ioo a b, DifferentiableAt \u211d f x := fun x hx =>\n    (hdf x hx).differentiableAt (Ioo_mem_nhds hx.1 hx.2)", "tactic_state": "a b : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhab : a < b\nhdf\u271d : DifferentiableOn \u211d f (Ioo a b)\nhg' : \u2200 x \u2208 Ioo a b, deriv g x \u2260 0\nhfb : Tendsto f (nhdsWithin b (Iio b)) (nhds 0)\nhgb : Tendsto g (nhdsWithin b (Iio b)) (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) (nhdsWithin b (Iio b)) l\nhdf : \u2200 x \u2208 Ioo a b, DifferentiableAt \u211d f x\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin b (Iio b)) l"}, {"line": "have hdg : \u2200 x \u2208 Ioo a b, DifferentiableAt \u211d g x := fun x hx =>\n    by_contradiction fun h => hg' x hx (deriv_zero_of_not_differentiableAt h)", "tactic_state": "a b : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhab : a < b\nhdf\u271d : DifferentiableOn \u211d f (Ioo a b)\nhg' : \u2200 x \u2208 Ioo a b, deriv g x \u2260 0\nhfb : Tendsto f (nhdsWithin b (Iio b)) (nhds 0)\nhgb : Tendsto g (nhdsWithin b (Iio b)) (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) (nhdsWithin b (Iio b)) l\nhdf : \u2200 x \u2208 Ioo a b, DifferentiableAt \u211d f x\nhdg : \u2200 x \u2208 Ioo a b, DifferentiableAt \u211d g x\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin b (Iio b)) l"}, {"line": "exact HasDerivAt.lhopital_zero_left_on_Ioo hab (fun x hx => (hdf x hx).hasDerivAt)\n    (fun x hx => (hdg x hx).hasDerivAt) hg' hfb hgb hdiv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lhopital_zero_atTop_on_Ioi (hdf : DifferentiableOn \u211d f (Ioi a))\n    (hg' : \u2200 x \u2208 Ioi a, (deriv g) x \u2260 0) (hftop : Tendsto f atTop (\ud835\udcdd 0))\n    (hgtop : Tendsto g atTop (\ud835\udcdd 0)) (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) atTop l) :\n    Tendsto (fun x => f x / g x) atTop l := by\n  have hdf : \u2200 x \u2208 Ioi a, DifferentiableAt \u211d f x := fun x hx =>\n    (hdf x hx).differentiableAt (Ioi_mem_nhds hx)\n  have hdg : \u2200 x \u2208 Ioi a, DifferentiableAt \u211d g x := fun x hx =>\n    by_contradiction fun h => hg' x hx (deriv_zero_of_not_differentiableAt h)\n  exact HasDerivAt.lhopital_zero_atTop_on_Ioi (fun x hx => (hdf x hx).hasDerivAt)\n    (fun x hx => (hdg x hx).hasDerivAt) hg' hftop hgtop hdiv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LHopital.lean", "context": {"open": ["Filter Set", "scoped Filter Topology Pointwise"], "variables": ["{a b : \u211d} {l : Filter \u211d} {f f' g g' : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf : DifferentiableOn \u211d f (Ioi a)\nhg' : \u2200 x \u2208 Ioi a, deriv g x \u2260 0\nhftop : Tendsto f atTop (nhds 0)\nhgtop : Tendsto g atTop (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) atTop l\n\u22a2 Tendsto (fun x => f x / g x) atTop l"}, {"line": "have hdf : \u2200 x \u2208 Ioi a, DifferentiableAt \u211d f x := fun x hx =>\n    (hdf x hx).differentiableAt (Ioi_mem_nhds hx)", "tactic_state": "a : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf\u271d : DifferentiableOn \u211d f (Ioi a)\nhg' : \u2200 x \u2208 Ioi a, deriv g x \u2260 0\nhftop : Tendsto f atTop (nhds 0)\nhgtop : Tendsto g atTop (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) atTop l\nhdf : \u2200 x \u2208 Ioi a, DifferentiableAt \u211d f x\n\u22a2 Tendsto (fun x => f x / g x) atTop l"}, {"line": "have hdg : \u2200 x \u2208 Ioi a, DifferentiableAt \u211d g x := fun x hx =>\n    by_contradiction fun h => hg' x hx (deriv_zero_of_not_differentiableAt h)", "tactic_state": "a : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf\u271d : DifferentiableOn \u211d f (Ioi a)\nhg' : \u2200 x \u2208 Ioi a, deriv g x \u2260 0\nhftop : Tendsto f atTop (nhds 0)\nhgtop : Tendsto g atTop (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) atTop l\nhdf : \u2200 x \u2208 Ioi a, DifferentiableAt \u211d f x\nhdg : \u2200 x \u2208 Ioi a, DifferentiableAt \u211d g x\n\u22a2 Tendsto (fun x => f x / g x) atTop l"}, {"line": "exact HasDerivAt.lhopital_zero_atTop_on_Ioi (fun x hx => (hdf x hx).hasDerivAt)\n    (fun x hx => (hdg x hx).hasDerivAt) hg' hftop hgtop hdiv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lhopital_zero_atBot_on_Iio (hdf : DifferentiableOn \u211d f (Iio a))\n    (hg' : \u2200 x \u2208 Iio a, (deriv g) x \u2260 0) (hfbot : Tendsto f atBot (\ud835\udcdd 0))\n    (hgbot : Tendsto g atBot (\ud835\udcdd 0)) (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) atBot l) :\n    Tendsto (fun x => f x / g x) atBot l := by\n  have hdf : \u2200 x \u2208 Iio a, DifferentiableAt \u211d f x := fun x hx =>\n    (hdf x hx).differentiableAt (Iio_mem_nhds hx)\n  have hdg : \u2200 x \u2208 Iio a, DifferentiableAt \u211d g x := fun x hx =>\n    by_contradiction fun h => hg' x hx (deriv_zero_of_not_differentiableAt h)\n  exact HasDerivAt.lhopital_zero_atBot_on_Iio (fun x hx => (hdf x hx).hasDerivAt)\n    (fun x hx => (hdg x hx).hasDerivAt) hg' hfbot hgbot hdiv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LHopital.lean", "context": {"open": ["Filter Set", "scoped Filter Topology Pointwise"], "variables": ["{a b : \u211d} {l : Filter \u211d} {f f' g g' : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf : DifferentiableOn \u211d f (Iio a)\nhg' : \u2200 x \u2208 Iio a, deriv g x \u2260 0\nhfbot : Tendsto f atBot (nhds 0)\nhgbot : Tendsto g atBot (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) atBot l\n\u22a2 Tendsto (fun x => f x / g x) atBot l"}, {"line": "have hdf : \u2200 x \u2208 Iio a, DifferentiableAt \u211d f x := fun x hx =>\n    (hdf x hx).differentiableAt (Iio_mem_nhds hx)", "tactic_state": "a : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf\u271d : DifferentiableOn \u211d f (Iio a)\nhg' : \u2200 x \u2208 Iio a, deriv g x \u2260 0\nhfbot : Tendsto f atBot (nhds 0)\nhgbot : Tendsto g atBot (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) atBot l\nhdf : \u2200 x \u2208 Iio a, DifferentiableAt \u211d f x\n\u22a2 Tendsto (fun x => f x / g x) atBot l"}, {"line": "have hdg : \u2200 x \u2208 Iio a, DifferentiableAt \u211d g x := fun x hx =>\n    by_contradiction fun h => hg' x hx (deriv_zero_of_not_differentiableAt h)", "tactic_state": "a : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf\u271d : DifferentiableOn \u211d f (Iio a)\nhg' : \u2200 x \u2208 Iio a, deriv g x \u2260 0\nhfbot : Tendsto f atBot (nhds 0)\nhgbot : Tendsto g atBot (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) atBot l\nhdf : \u2200 x \u2208 Iio a, DifferentiableAt \u211d f x\nhdg : \u2200 x \u2208 Iio a, DifferentiableAt \u211d g x\n\u22a2 Tendsto (fun x => f x / g x) atBot l"}, {"line": "exact HasDerivAt.lhopital_zero_atBot_on_Iio (fun x hx => (hdf x hx).hasDerivAt)\n    (fun x hx => (hdg x hx).hasDerivAt) hg' hfbot hgbot hdiv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lhopital_zero_nhdsNE (hff' : \u2200\u1da0 x in \ud835\udcdd[\u2260] a, HasDerivAt f (f' x) x)\n    (hgg' : \u2200\u1da0 x in \ud835\udcdd[\u2260] a, HasDerivAt g (g' x) x) (hg' : \u2200\u1da0 x in \ud835\udcdd[\u2260] a, g' x \u2260 0)\n    (hfa : Tendsto f (\ud835\udcdd[\u2260] a) (\ud835\udcdd 0)) (hga : Tendsto g (\ud835\udcdd[\u2260] a) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (\ud835\udcdd[\u2260] a) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[\u2260] a) l := by\n  simp only [\u2190 Iio_union_Ioi] at *\n  simp only [nhdsWithin_union] at *\n  simp only [tendsto_sup] at *\n  simp only [eventually_sup] at *\n  exact \u27e8lhopital_zero_nhdsLT hff'.1 hgg'.1 hg'.1 hfa.1 hga.1 hdiv.1,\n    lhopital_zero_nhdsGT hff'.2 hgg'.2 hg'.2 hfa.2 hga.2 hdiv.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LHopital.lean", "context": {"open": ["Filter Set", "scoped Filter Topology Pointwise"], "variables": ["{a b : \u211d} {l : Filter \u211d} {f f' g g' : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhff' : \u2200\u1da0 (x : \u211d) in nhdsWithin a {a}\u1d9c, HasDerivAt f (f' x) x\nhgg' : \u2200\u1da0 (x : \u211d) in nhdsWithin a {a}\u1d9c, HasDerivAt g (g' x) x\nhg' : \u2200\u1da0 (x : \u211d) in nhdsWithin a {a}\u1d9c, g' x \u2260 0\nhfa : Tendsto f (nhdsWithin a {a}\u1d9c) (nhds 0)\nhga : Tendsto g (nhdsWithin a {a}\u1d9c) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a {a}\u1d9c) l\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a {a}\u1d9c) l"}, {"line": "simp only [\u2190 Iio_union_Ioi] at *", "tactic_state": "a : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhff' : \u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a \u222a Ioi a), HasDerivAt f (f' x) x\nhgg' : \u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a \u222a Ioi a), HasDerivAt g (g' x) x\nhg' : \u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a \u222a Ioi a), g' x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Iio a \u222a Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Iio a \u222a Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Iio a \u222a Ioi a)) l\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Iio a \u222a Ioi a)) l"}, {"line": "simp only [nhdsWithin_union] at *", "tactic_state": "a : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhff' : \u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a), HasDerivAt f (f' x) x\nhgg' : \u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a), HasDerivAt g (g' x) x\nhg' : \u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a), g' x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a)) l\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a)) l"}, {"line": "simp only [tendsto_sup] at *", "tactic_state": "a : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhff' : \u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a), HasDerivAt f (f' x) x\nhgg' : \u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a), HasDerivAt g (g' x) x\nhg' : \u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a), g' x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Iio a)) (nhds 0) \u2227 Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Iio a)) (nhds 0) \u2227 Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Iio a)) l \u2227 Tendsto (fun x => f' x / g' x) (nhdsWithin a (Ioi a)) l\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Iio a)) l \u2227 Tendsto (fun x => f x / g x) (nhdsWithin a (Ioi a)) l"}, {"line": "simp only [eventually_sup] at *", "tactic_state": "a : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhfa : Tendsto f (nhdsWithin a (Iio a)) (nhds 0) \u2227 Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Iio a)) (nhds 0) \u2227 Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Iio a)) l \u2227 Tendsto (fun x => f' x / g' x) (nhdsWithin a (Ioi a)) l\nhff' :\n  (\u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a), HasDerivAt f (f' x) x) \u2227\n    \u2200\u1da0 (x : \u211d) in nhdsWithin a (Ioi a), HasDerivAt f (f' x) x\nhgg' :\n  (\u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a), HasDerivAt g (g' x) x) \u2227\n    \u2200\u1da0 (x : \u211d) in nhdsWithin a (Ioi a), HasDerivAt g (g' x) x\nhg' : (\u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a), g' x \u2260 0) \u2227 \u2200\u1da0 (x : \u211d) in nhdsWithin a (Ioi a), g' x \u2260 0\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Iio a)) l \u2227 Tendsto (fun x => f x / g x) (nhdsWithin a (Ioi a)) l"}, {"line": "exact \u27e8lhopital_zero_nhdsLT hff'.1 hgg'.1 hg'.1 hfa.1 hga.1 hdiv.1,\n    lhopital_zero_nhdsGT hff'.2 hgg'.2 hg'.2 hfa.2 hga.2 hdiv.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lhopital_zero_nhds (hff' : \u2200\u1da0 x in \ud835\udcdd a, HasDerivAt f (f' x) x)\n    (hgg' : \u2200\u1da0 x in \ud835\udcdd a, HasDerivAt g (g' x) x) (hg' : \u2200\u1da0 x in \ud835\udcdd a, g' x \u2260 0)\n    (hfa : Tendsto f (\ud835\udcdd a) (\ud835\udcdd 0)) (hga : Tendsto g (\ud835\udcdd a) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (\ud835\udcdd a) l) : Tendsto (fun x => f x / g x) (\ud835\udcdd[\u2260] a) l := by\n  apply @lhopital_zero_nhdsNE _ _ _ f' _ g' <;>\n    (first | apply eventually_nhdsWithin_of_eventually_nhds |\n      apply tendsto_nhdsWithin_of_tendsto_nhds) <;> assumption\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LHopital.lean", "context": {"open": ["Filter Set", "scoped Filter Topology Pointwise"], "variables": ["{a b : \u211d} {l : Filter \u211d} {f f' g g' : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhff' : \u2200\u1da0 (x : \u211d) in nhds a, HasDerivAt f (f' x) x\nhgg' : \u2200\u1da0 (x : \u211d) in nhds a, HasDerivAt g (g' x) x\nhg' : \u2200\u1da0 (x : \u211d) in nhds a, g' x \u2260 0\nhfa : Tendsto f (nhds a) (nhds 0)\nhga : Tendsto g (nhds a) (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) (nhds a) l\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a {a}\u1d9c) l"}, {"line": "apply @lhopital_zero_nhdsNE _ _ _ f' _ g' <;>\n    (first | apply eventually_nhdsWithin_of_eventually_nhds |\n      apply tendsto_nhdsWithin_of_tendsto_nhds) <;> assumption", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lhopital_zero_atTop (hff' : \u2200\u1da0 x in atTop, HasDerivAt f (f' x) x)\n    (hgg' : \u2200\u1da0 x in atTop, HasDerivAt g (g' x) x) (hg' : \u2200\u1da0 x in atTop, g' x \u2260 0)\n    (hftop : Tendsto f atTop (\ud835\udcdd 0)) (hgtop : Tendsto g atTop (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) atTop l) : Tendsto (fun x => f x / g x) atTop l := by\n  rw [eventually_iff_exists_mem] at *\n  rcases hff' with \u27e8s\u2081, hs\u2081, hff'\u27e9\n  rcases hgg' with \u27e8s\u2082, hs\u2082, hgg'\u27e9\n  rcases hg' with \u27e8s\u2083, hs\u2083, hg'\u27e9\n  let s := s\u2081 \u2229 s\u2082 \u2229 s\u2083\n  have hs : s \u2208 atTop := inter_mem (inter_mem hs\u2081 hs\u2082) hs\u2083\n  rw [mem_atTop_sets] at hs\n  rcases hs with \u27e8l, hl\u27e9\n  have hl' : Ioi l \u2286 s := fun x hx => hl x (le_of_lt hx)\n  refine lhopital_zero_atTop_on_Ioi ?_ ?_ (fun x hx => hg' x <| (hl' hx).2) hftop hgtop hdiv <;>\n    intro x hx <;> apply_assumption <;> first | exact (hl' hx).1.1| exact (hl' hx).1.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LHopital.lean", "context": {"open": ["Filter Set", "scoped Filter Topology Pointwise"], "variables": ["{a b : \u211d} {l : Filter \u211d} {f f' g g' : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhff' : \u2200\u1da0 (x : \u211d) in atTop, HasDerivAt f (f' x) x\nhgg' : \u2200\u1da0 (x : \u211d) in atTop, HasDerivAt g (g' x) x\nhg' : \u2200\u1da0 (x : \u211d) in atTop, g' x \u2260 0\nhftop : Tendsto f atTop (nhds 0)\nhgtop : Tendsto g atTop (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atTop l\n\u22a2 Tendsto (fun x => f x / g x) atTop l"}, {"line": "rw [eventually_iff_exists_mem] at *", "tactic_state": "l : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhff' : \u2203 v \u2208 atTop, \u2200 y \u2208 v, HasDerivAt f (f' y) y\nhgg' : \u2203 v \u2208 atTop, \u2200 y \u2208 v, HasDerivAt g (g' y) y\nhg' : \u2203 v \u2208 atTop, \u2200 y \u2208 v, g' y \u2260 0\nhftop : Tendsto f atTop (nhds 0)\nhgtop : Tendsto g atTop (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atTop l\n\u22a2 Tendsto (fun x => f x / g x) atTop l"}, {"line": "rcases hff' with \u27e8s\u2081, hs\u2081, hff'\u27e9", "tactic_state": "case intro.intro\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhgg' : \u2203 v \u2208 atTop, \u2200 y \u2208 v, HasDerivAt g (g' y) y\nhg' : \u2203 v \u2208 atTop, \u2200 y \u2208 v, g' y \u2260 0\nhftop : Tendsto f atTop (nhds 0)\nhgtop : Tendsto g atTop (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atTop l\ns\u2081 : Set \u211d\nhs\u2081 : s\u2081 \u2208 atTop\nhff' : \u2200 y \u2208 s\u2081, HasDerivAt f (f' y) y\n\u22a2 Tendsto (fun x => f x / g x) atTop l"}, {"line": "rcases hgg' with \u27e8s\u2082, hs\u2082, hgg'\u27e9", "tactic_state": "case intro.intro.intro.intro\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhg' : \u2203 v \u2208 atTop, \u2200 y \u2208 v, g' y \u2260 0\nhftop : Tendsto f atTop (nhds 0)\nhgtop : Tendsto g atTop (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atTop l\ns\u2081 : Set \u211d\nhs\u2081 : s\u2081 \u2208 atTop\nhff' : \u2200 y \u2208 s\u2081, HasDerivAt f (f' y) y\ns\u2082 : Set \u211d\nhs\u2082 : s\u2082 \u2208 atTop\nhgg' : \u2200 y \u2208 s\u2082, HasDerivAt g (g' y) y\n\u22a2 Tendsto (fun x => f x / g x) atTop l"}, {"line": "rcases hg' with \u27e8s\u2083, hs\u2083, hg'\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhftop : Tendsto f atTop (nhds 0)\nhgtop : Tendsto g atTop (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atTop l\ns\u2081 : Set \u211d\nhs\u2081 : s\u2081 \u2208 atTop\nhff' : \u2200 y \u2208 s\u2081, HasDerivAt f (f' y) y\ns\u2082 : Set \u211d\nhs\u2082 : s\u2082 \u2208 atTop\nhgg' : \u2200 y \u2208 s\u2082, HasDerivAt g (g' y) y\ns\u2083 : Set \u211d\nhs\u2083 : s\u2083 \u2208 atTop\nhg' : \u2200 y \u2208 s\u2083, g' y \u2260 0\n\u22a2 Tendsto (fun x => f x / g x) atTop l"}, {"line": "let s := s\u2081 \u2229 s\u2082 \u2229 s\u2083", "tactic_state": "case intro.intro.intro.intro.intro.intro\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhftop : Tendsto f atTop (nhds 0)\nhgtop : Tendsto g atTop (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atTop l\ns\u2081 : Set \u211d\nhs\u2081 : s\u2081 \u2208 atTop\nhff' : \u2200 y \u2208 s\u2081, HasDerivAt f (f' y) y\ns\u2082 : Set \u211d\nhs\u2082 : s\u2082 \u2208 atTop\nhgg' : \u2200 y \u2208 s\u2082, HasDerivAt g (g' y) y\ns\u2083 : Set \u211d\nhs\u2083 : s\u2083 \u2208 atTop\nhg' : \u2200 y \u2208 s\u2083, g' y \u2260 0\ns : Set \u211d := s\u2081 \u2229 s\u2082 \u2229 s\u2083\n\u22a2 Tendsto (fun x => f x / g x) atTop l"}, {"line": "have hs : s \u2208 atTop := inter_mem (inter_mem hs\u2081 hs\u2082) hs\u2083", "tactic_state": "case intro.intro.intro.intro.intro.intro\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhftop : Tendsto f atTop (nhds 0)\nhgtop : Tendsto g atTop (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atTop l\ns\u2081 : Set \u211d\nhs\u2081 : s\u2081 \u2208 atTop\nhff' : \u2200 y \u2208 s\u2081, HasDerivAt f (f' y) y\ns\u2082 : Set \u211d\nhs\u2082 : s\u2082 \u2208 atTop\nhgg' : \u2200 y \u2208 s\u2082, HasDerivAt g (g' y) y\ns\u2083 : Set \u211d\nhs\u2083 : s\u2083 \u2208 atTop\nhg' : \u2200 y \u2208 s\u2083, g' y \u2260 0\ns : Set \u211d := s\u2081 \u2229 s\u2082 \u2229 s\u2083\nhs : s \u2208 atTop\n\u22a2 Tendsto (fun x => f x / g x) atTop l"}, {"line": "rw [mem_atTop_sets] at hs", "tactic_state": "case intro.intro.intro.intro.intro.intro\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhftop : Tendsto f atTop (nhds 0)\nhgtop : Tendsto g atTop (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atTop l\ns\u2081 : Set \u211d\nhs\u2081 : s\u2081 \u2208 atTop\nhff' : \u2200 y \u2208 s\u2081, HasDerivAt f (f' y) y\ns\u2082 : Set \u211d\nhs\u2082 : s\u2082 \u2208 atTop\nhgg' : \u2200 y \u2208 s\u2082, HasDerivAt g (g' y) y\ns\u2083 : Set \u211d\nhs\u2083 : s\u2083 \u2208 atTop\nhg' : \u2200 y \u2208 s\u2083, g' y \u2260 0\ns : Set \u211d := s\u2081 \u2229 s\u2082 \u2229 s\u2083\nhs : \u2203 a, \u2200 b \u2265 a, b \u2208 s\n\u22a2 Tendsto (fun x => f x / g x) atTop l"}, {"line": "rcases hs with \u27e8l, hl\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro\nl\u271d : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhftop : Tendsto f atTop (nhds 0)\nhgtop : Tendsto g atTop (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atTop l\u271d\ns\u2081 : Set \u211d\nhs\u2081 : s\u2081 \u2208 atTop\nhff' : \u2200 y \u2208 s\u2081, HasDerivAt f (f' y) y\ns\u2082 : Set \u211d\nhs\u2082 : s\u2082 \u2208 atTop\nhgg' : \u2200 y \u2208 s\u2082, HasDerivAt g (g' y) y\ns\u2083 : Set \u211d\nhs\u2083 : s\u2083 \u2208 atTop\nhg' : \u2200 y \u2208 s\u2083, g' y \u2260 0\ns : Set \u211d := s\u2081 \u2229 s\u2082 \u2229 s\u2083\nl : \u211d\nhl : \u2200 b \u2265 l, b \u2208 s\n\u22a2 Tendsto (fun x => f x / g x) atTop l\u271d"}, {"line": "have hl' : Ioi l \u2286 s := fun x hx => hl x (le_of_lt hx)", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro\nl\u271d : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhftop : Tendsto f atTop (nhds 0)\nhgtop : Tendsto g atTop (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atTop l\u271d\ns\u2081 : Set \u211d\nhs\u2081 : s\u2081 \u2208 atTop\nhff' : \u2200 y \u2208 s\u2081, HasDerivAt f (f' y) y\ns\u2082 : Set \u211d\nhs\u2082 : s\u2082 \u2208 atTop\nhgg' : \u2200 y \u2208 s\u2082, HasDerivAt g (g' y) y\ns\u2083 : Set \u211d\nhs\u2083 : s\u2083 \u2208 atTop\nhg' : \u2200 y \u2208 s\u2083, g' y \u2260 0\ns : Set \u211d := s\u2081 \u2229 s\u2082 \u2229 s\u2083\nl : \u211d\nhl : \u2200 b \u2265 l, b \u2208 s\nhl' : Ioi l \u2286 s\n\u22a2 Tendsto (fun x => f x / g x) atTop l\u271d"}, {"line": "refine lhopital_zero_atTop_on_Ioi ?_ ?_ (fun x hx => hg' x <| (hl' hx).2) hftop hgtop hdiv <;>\n    intro x hx <;> apply_assumption <;> first | exact (hl' hx).1.1| exact (hl' hx).1.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lhopital_zero_atBot (hff' : \u2200\u1da0 x in atBot, HasDerivAt f (f' x) x)\n    (hgg' : \u2200\u1da0 x in atBot, HasDerivAt g (g' x) x) (hg' : \u2200\u1da0 x in atBot, g' x \u2260 0)\n    (hfbot : Tendsto f atBot (\ud835\udcdd 0)) (hgbot : Tendsto g atBot (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) atBot l) : Tendsto (fun x => f x / g x) atBot l := by\n  rw [eventually_iff_exists_mem] at *\n  rcases hff' with \u27e8s\u2081, hs\u2081, hff'\u27e9\n  rcases hgg' with \u27e8s\u2082, hs\u2082, hgg'\u27e9\n  rcases hg' with \u27e8s\u2083, hs\u2083, hg'\u27e9\n  let s := s\u2081 \u2229 s\u2082 \u2229 s\u2083\n  have hs : s \u2208 atBot := inter_mem (inter_mem hs\u2081 hs\u2082) hs\u2083\n  rw [mem_atBot_sets] at hs\n  rcases hs with \u27e8l, hl\u27e9\n  have hl' : Iio l \u2286 s := fun x hx => hl x (le_of_lt hx)\n  refine lhopital_zero_atBot_on_Iio ?_ ?_ (fun x hx => hg' x <| (hl' hx).2) hfbot hgbot hdiv <;>\n    intro x hx <;> apply_assumption <;> first | exact (hl' hx).1.1| exact (hl' hx).1.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LHopital.lean", "context": {"open": ["Filter Set", "scoped Filter Topology Pointwise"], "variables": ["{a b : \u211d} {l : Filter \u211d} {f f' g g' : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhff' : \u2200\u1da0 (x : \u211d) in atBot, HasDerivAt f (f' x) x\nhgg' : \u2200\u1da0 (x : \u211d) in atBot, HasDerivAt g (g' x) x\nhg' : \u2200\u1da0 (x : \u211d) in atBot, g' x \u2260 0\nhfbot : Tendsto f atBot (nhds 0)\nhgbot : Tendsto g atBot (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atBot l\n\u22a2 Tendsto (fun x => f x / g x) atBot l"}, {"line": "rw [eventually_iff_exists_mem] at *", "tactic_state": "l : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhff' : \u2203 v \u2208 atBot, \u2200 y \u2208 v, HasDerivAt f (f' y) y\nhgg' : \u2203 v \u2208 atBot, \u2200 y \u2208 v, HasDerivAt g (g' y) y\nhg' : \u2203 v \u2208 atBot, \u2200 y \u2208 v, g' y \u2260 0\nhfbot : Tendsto f atBot (nhds 0)\nhgbot : Tendsto g atBot (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atBot l\n\u22a2 Tendsto (fun x => f x / g x) atBot l"}, {"line": "rcases hff' with \u27e8s\u2081, hs\u2081, hff'\u27e9", "tactic_state": "case intro.intro\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhgg' : \u2203 v \u2208 atBot, \u2200 y \u2208 v, HasDerivAt g (g' y) y\nhg' : \u2203 v \u2208 atBot, \u2200 y \u2208 v, g' y \u2260 0\nhfbot : Tendsto f atBot (nhds 0)\nhgbot : Tendsto g atBot (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atBot l\ns\u2081 : Set \u211d\nhs\u2081 : s\u2081 \u2208 atBot\nhff' : \u2200 y \u2208 s\u2081, HasDerivAt f (f' y) y\n\u22a2 Tendsto (fun x => f x / g x) atBot l"}, {"line": "rcases hgg' with \u27e8s\u2082, hs\u2082, hgg'\u27e9", "tactic_state": "case intro.intro.intro.intro\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhg' : \u2203 v \u2208 atBot, \u2200 y \u2208 v, g' y \u2260 0\nhfbot : Tendsto f atBot (nhds 0)\nhgbot : Tendsto g atBot (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atBot l\ns\u2081 : Set \u211d\nhs\u2081 : s\u2081 \u2208 atBot\nhff' : \u2200 y \u2208 s\u2081, HasDerivAt f (f' y) y\ns\u2082 : Set \u211d\nhs\u2082 : s\u2082 \u2208 atBot\nhgg' : \u2200 y \u2208 s\u2082, HasDerivAt g (g' y) y\n\u22a2 Tendsto (fun x => f x / g x) atBot l"}, {"line": "rcases hg' with \u27e8s\u2083, hs\u2083, hg'\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhfbot : Tendsto f atBot (nhds 0)\nhgbot : Tendsto g atBot (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atBot l\ns\u2081 : Set \u211d\nhs\u2081 : s\u2081 \u2208 atBot\nhff' : \u2200 y \u2208 s\u2081, HasDerivAt f (f' y) y\ns\u2082 : Set \u211d\nhs\u2082 : s\u2082 \u2208 atBot\nhgg' : \u2200 y \u2208 s\u2082, HasDerivAt g (g' y) y\ns\u2083 : Set \u211d\nhs\u2083 : s\u2083 \u2208 atBot\nhg' : \u2200 y \u2208 s\u2083, g' y \u2260 0\n\u22a2 Tendsto (fun x => f x / g x) atBot l"}, {"line": "let s := s\u2081 \u2229 s\u2082 \u2229 s\u2083", "tactic_state": "case intro.intro.intro.intro.intro.intro\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhfbot : Tendsto f atBot (nhds 0)\nhgbot : Tendsto g atBot (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atBot l\ns\u2081 : Set \u211d\nhs\u2081 : s\u2081 \u2208 atBot\nhff' : \u2200 y \u2208 s\u2081, HasDerivAt f (f' y) y\ns\u2082 : Set \u211d\nhs\u2082 : s\u2082 \u2208 atBot\nhgg' : \u2200 y \u2208 s\u2082, HasDerivAt g (g' y) y\ns\u2083 : Set \u211d\nhs\u2083 : s\u2083 \u2208 atBot\nhg' : \u2200 y \u2208 s\u2083, g' y \u2260 0\ns : Set \u211d := s\u2081 \u2229 s\u2082 \u2229 s\u2083\n\u22a2 Tendsto (fun x => f x / g x) atBot l"}, {"line": "have hs : s \u2208 atBot := inter_mem (inter_mem hs\u2081 hs\u2082) hs\u2083", "tactic_state": "case intro.intro.intro.intro.intro.intro\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhfbot : Tendsto f atBot (nhds 0)\nhgbot : Tendsto g atBot (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atBot l\ns\u2081 : Set \u211d\nhs\u2081 : s\u2081 \u2208 atBot\nhff' : \u2200 y \u2208 s\u2081, HasDerivAt f (f' y) y\ns\u2082 : Set \u211d\nhs\u2082 : s\u2082 \u2208 atBot\nhgg' : \u2200 y \u2208 s\u2082, HasDerivAt g (g' y) y\ns\u2083 : Set \u211d\nhs\u2083 : s\u2083 \u2208 atBot\nhg' : \u2200 y \u2208 s\u2083, g' y \u2260 0\ns : Set \u211d := s\u2081 \u2229 s\u2082 \u2229 s\u2083\nhs : s \u2208 atBot\n\u22a2 Tendsto (fun x => f x / g x) atBot l"}, {"line": "rw [mem_atBot_sets] at hs", "tactic_state": "case intro.intro.intro.intro.intro.intro\nl : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhfbot : Tendsto f atBot (nhds 0)\nhgbot : Tendsto g atBot (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atBot l\ns\u2081 : Set \u211d\nhs\u2081 : s\u2081 \u2208 atBot\nhff' : \u2200 y \u2208 s\u2081, HasDerivAt f (f' y) y\ns\u2082 : Set \u211d\nhs\u2082 : s\u2082 \u2208 atBot\nhgg' : \u2200 y \u2208 s\u2082, HasDerivAt g (g' y) y\ns\u2083 : Set \u211d\nhs\u2083 : s\u2083 \u2208 atBot\nhg' : \u2200 y \u2208 s\u2083, g' y \u2260 0\ns : Set \u211d := s\u2081 \u2229 s\u2082 \u2229 s\u2083\nhs : \u2203 a, \u2200 b \u2264 a, b \u2208 s\n\u22a2 Tendsto (fun x => f x / g x) atBot l"}, {"line": "rcases hs with \u27e8l, hl\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro\nl\u271d : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhfbot : Tendsto f atBot (nhds 0)\nhgbot : Tendsto g atBot (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atBot l\u271d\ns\u2081 : Set \u211d\nhs\u2081 : s\u2081 \u2208 atBot\nhff' : \u2200 y \u2208 s\u2081, HasDerivAt f (f' y) y\ns\u2082 : Set \u211d\nhs\u2082 : s\u2082 \u2208 atBot\nhgg' : \u2200 y \u2208 s\u2082, HasDerivAt g (g' y) y\ns\u2083 : Set \u211d\nhs\u2083 : s\u2083 \u2208 atBot\nhg' : \u2200 y \u2208 s\u2083, g' y \u2260 0\ns : Set \u211d := s\u2081 \u2229 s\u2082 \u2229 s\u2083\nl : \u211d\nhl : \u2200 b \u2264 l, b \u2208 s\n\u22a2 Tendsto (fun x => f x / g x) atBot l\u271d"}, {"line": "have hl' : Iio l \u2286 s := fun x hx => hl x (le_of_lt hx)", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro\nl\u271d : Filter \u211d\nf f' g g' : \u211d \u2192 \u211d\nhfbot : Tendsto f atBot (nhds 0)\nhgbot : Tendsto g atBot (nhds 0)\nhdiv : Tendsto (fun x => f' x / g' x) atBot l\u271d\ns\u2081 : Set \u211d\nhs\u2081 : s\u2081 \u2208 atBot\nhff' : \u2200 y \u2208 s\u2081, HasDerivAt f (f' y) y\ns\u2082 : Set \u211d\nhs\u2082 : s\u2082 \u2208 atBot\nhgg' : \u2200 y \u2208 s\u2082, HasDerivAt g (g' y) y\ns\u2083 : Set \u211d\nhs\u2083 : s\u2083 \u2208 atBot\nhg' : \u2200 y \u2208 s\u2083, g' y \u2260 0\ns : Set \u211d := s\u2081 \u2229 s\u2082 \u2229 s\u2083\nl : \u211d\nhl : \u2200 b \u2264 l, b \u2208 s\nhl' : Iio l \u2286 s\n\u22a2 Tendsto (fun x => f x / g x) atBot l\u271d"}, {"line": "refine lhopital_zero_atBot_on_Iio ?_ ?_ (fun x hx => hg' x <| (hl' hx).2) hfbot hgbot hdiv <;>\n    intro x hx <;> apply_assumption <;> first | exact (hl' hx).1.1| exact (hl' hx).1.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lhopital_zero_nhdsNE (hdf : \u2200\u1da0 x in \ud835\udcdd[\u2260] a, DifferentiableAt \u211d f x)\n    (hg' : \u2200\u1da0 x in \ud835\udcdd[\u2260] a, deriv g x \u2260 0) (hfa : Tendsto f (\ud835\udcdd[\u2260] a) (\ud835\udcdd 0))\n    (hga : Tendsto g (\ud835\udcdd[\u2260] a) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (\ud835\udcdd[\u2260] a) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[\u2260] a) l := by\n  simp only [\u2190 Iio_union_Ioi] at *\n  simp only [nhdsWithin_union] at *\n  simp only [tendsto_sup] at *\n  simp only [eventually_sup] at *\n  exact \u27e8lhopital_zero_nhdsLT hdf.1 hg'.1 hfa.1 hga.1 hdiv.1,\n    lhopital_zero_nhdsGT hdf.2 hg'.2 hfa.2 hga.2 hdiv.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LHopital.lean", "context": {"open": ["Filter Set", "scoped Filter Topology Pointwise"], "variables": ["{a b : \u211d} {l : Filter \u211d} {f f' g g' : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf : \u2200\u1da0 (x : \u211d) in nhdsWithin a {a}\u1d9c, DifferentiableAt \u211d f x\nhg' : \u2200\u1da0 (x : \u211d) in nhdsWithin a {a}\u1d9c, deriv g x \u2260 0\nhfa : Tendsto f (nhdsWithin a {a}\u1d9c) (nhds 0)\nhga : Tendsto g (nhdsWithin a {a}\u1d9c) (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) (nhdsWithin a {a}\u1d9c) l\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a {a}\u1d9c) l"}, {"line": "simp only [\u2190 Iio_union_Ioi] at *", "tactic_state": "a : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf : \u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a \u222a Ioi a), DifferentiableAt \u211d f x\nhg' : \u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a \u222a Ioi a), deriv g x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Iio a \u222a Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Iio a \u222a Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) (nhdsWithin a (Iio a \u222a Ioi a)) l\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Iio a \u222a Ioi a)) l"}, {"line": "simp only [nhdsWithin_union] at *", "tactic_state": "a : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf : \u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a), DifferentiableAt \u211d f x\nhg' : \u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a), deriv g x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a)) (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) (nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a)) l\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a)) l"}, {"line": "simp only [tendsto_sup] at *", "tactic_state": "a : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf : \u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a), DifferentiableAt \u211d f x\nhg' : \u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a), deriv g x \u2260 0\nhfa : Tendsto f (nhdsWithin a (Iio a)) (nhds 0) \u2227 Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Iio a)) (nhds 0) \u2227 Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv :\n  Tendsto (fun x => deriv f x / deriv g x) (nhdsWithin a (Iio a)) l \u2227\n    Tendsto (fun x => deriv f x / deriv g x) (nhdsWithin a (Ioi a)) l\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Iio a)) l \u2227 Tendsto (fun x => f x / g x) (nhdsWithin a (Ioi a)) l"}, {"line": "simp only [eventually_sup] at *", "tactic_state": "a : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhfa : Tendsto f (nhdsWithin a (Iio a)) (nhds 0) \u2227 Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)\nhga : Tendsto g (nhdsWithin a (Iio a)) (nhds 0) \u2227 Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)\nhdiv :\n  Tendsto (fun x => deriv f x / deriv g x) (nhdsWithin a (Iio a)) l \u2227\n    Tendsto (fun x => deriv f x / deriv g x) (nhdsWithin a (Ioi a)) l\nhdf :\n  (\u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a), DifferentiableAt \u211d f x) \u2227\n    \u2200\u1da0 (x : \u211d) in nhdsWithin a (Ioi a), DifferentiableAt \u211d f x\nhg' : (\u2200\u1da0 (x : \u211d) in nhdsWithin a (Iio a), deriv g x \u2260 0) \u2227 \u2200\u1da0 (x : \u211d) in nhdsWithin a (Ioi a), deriv g x \u2260 0\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a (Iio a)) l \u2227 Tendsto (fun x => f x / g x) (nhdsWithin a (Ioi a)) l"}, {"line": "exact \u27e8lhopital_zero_nhdsLT hdf.1 hg'.1 hfa.1 hga.1 hdiv.1,\n    lhopital_zero_nhdsGT hdf.2 hg'.2 hfa.2 hga.2 hdiv.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lhopital_zero_nhds (hdf : \u2200\u1da0 x in \ud835\udcdd a, DifferentiableAt \u211d f x)\n    (hg' : \u2200\u1da0 x in \ud835\udcdd a, deriv g x \u2260 0) (hfa : Tendsto f (\ud835\udcdd a) (\ud835\udcdd 0)) (hga : Tendsto g (\ud835\udcdd a) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (\ud835\udcdd a) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[\u2260] a) l := by\n  apply lhopital_zero_nhdsNE <;>\n    (first | apply eventually_nhdsWithin_of_eventually_nhds |\n      apply tendsto_nhdsWithin_of_tendsto_nhds) <;> assumption\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LHopital.lean", "context": {"open": ["Filter Set", "scoped Filter Topology Pointwise"], "variables": ["{a b : \u211d} {l : Filter \u211d} {f f' g g' : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\nl : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf : \u2200\u1da0 (x : \u211d) in nhds a, DifferentiableAt \u211d f x\nhg' : \u2200\u1da0 (x : \u211d) in nhds a, deriv g x \u2260 0\nhfa : Tendsto f (nhds a) (nhds 0)\nhga : Tendsto g (nhds a) (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) (nhds a) l\n\u22a2 Tendsto (fun x => f x / g x) (nhdsWithin a {a}\u1d9c) l"}, {"line": "apply lhopital_zero_nhdsNE <;>\n    (first | apply eventually_nhdsWithin_of_eventually_nhds |\n      apply tendsto_nhdsWithin_of_tendsto_nhds) <;> assumption", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lhopital_zero_atTop (hdf : \u2200\u1da0 x : \u211d in atTop, DifferentiableAt \u211d f x)\n    (hg' : \u2200\u1da0 x : \u211d in atTop, deriv g x \u2260 0) (hftop : Tendsto f atTop (\ud835\udcdd 0))\n    (hgtop : Tendsto g atTop (\ud835\udcdd 0)) (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) atTop l) :\n    Tendsto (fun x => f x / g x) atTop l := by\n  have hdg : \u2200\u1da0 x in atTop, DifferentiableAt \u211d g x := hg'.mp\n    (Eventually.of_forall fun _ hg' =>\n      by_contradiction fun h => hg' (deriv_zero_of_not_differentiableAt h))\n  have hdf' : \u2200\u1da0 x in atTop, HasDerivAt f (deriv f x) x :=\n    hdf.mono fun _ => DifferentiableAt.hasDerivAt\n  have hdg' : \u2200\u1da0 x in atTop, HasDerivAt g (deriv g x) x :=\n    hdg.mono fun _ => DifferentiableAt.hasDerivAt\n  exact HasDerivAt.lhopital_zero_atTop hdf' hdg' hg' hftop hgtop hdiv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LHopital.lean", "context": {"open": ["Filter Set", "scoped Filter Topology Pointwise"], "variables": ["{a b : \u211d} {l : Filter \u211d} {f f' g g' : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf : \u2200\u1da0 (x : \u211d) in atTop, DifferentiableAt \u211d f x\nhg' : \u2200\u1da0 (x : \u211d) in atTop, deriv g x \u2260 0\nhftop : Tendsto f atTop (nhds 0)\nhgtop : Tendsto g atTop (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) atTop l\n\u22a2 Tendsto (fun x => f x / g x) atTop l"}, {"line": "have hdg : \u2200\u1da0 x in atTop, DifferentiableAt \u211d g x := hg'.mp\n    (Eventually.of_forall fun _ hg' =>\n      by_contradiction fun h => hg' (deriv_zero_of_not_differentiableAt h))", "tactic_state": "l : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf : \u2200\u1da0 (x : \u211d) in atTop, DifferentiableAt \u211d f x\nhg' : \u2200\u1da0 (x : \u211d) in atTop, deriv g x \u2260 0\nhftop : Tendsto f atTop (nhds 0)\nhgtop : Tendsto g atTop (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) atTop l\nhdg : \u2200\u1da0 (x : \u211d) in atTop, DifferentiableAt \u211d g x\n\u22a2 Tendsto (fun x => f x / g x) atTop l"}, {"line": "have hdf' : \u2200\u1da0 x in atTop, HasDerivAt f (deriv f x) x :=\n    hdf.mono fun _ => DifferentiableAt.hasDerivAt", "tactic_state": "l : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf : \u2200\u1da0 (x : \u211d) in atTop, DifferentiableAt \u211d f x\nhg' : \u2200\u1da0 (x : \u211d) in atTop, deriv g x \u2260 0\nhftop : Tendsto f atTop (nhds 0)\nhgtop : Tendsto g atTop (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) atTop l\nhdg : \u2200\u1da0 (x : \u211d) in atTop, DifferentiableAt \u211d g x\nhdf' : \u2200\u1da0 (x : \u211d) in atTop, HasDerivAt f (deriv f x) x\n\u22a2 Tendsto (fun x => f x / g x) atTop l"}, {"line": "have hdg' : \u2200\u1da0 x in atTop, HasDerivAt g (deriv g x) x :=\n    hdg.mono fun _ => DifferentiableAt.hasDerivAt", "tactic_state": "l : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf : \u2200\u1da0 (x : \u211d) in atTop, DifferentiableAt \u211d f x\nhg' : \u2200\u1da0 (x : \u211d) in atTop, deriv g x \u2260 0\nhftop : Tendsto f atTop (nhds 0)\nhgtop : Tendsto g atTop (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) atTop l\nhdg : \u2200\u1da0 (x : \u211d) in atTop, DifferentiableAt \u211d g x\nhdf' : \u2200\u1da0 (x : \u211d) in atTop, HasDerivAt f (deriv f x) x\nhdg' : \u2200\u1da0 (x : \u211d) in atTop, HasDerivAt g (deriv g x) x\n\u22a2 Tendsto (fun x => f x / g x) atTop l"}, {"line": "exact HasDerivAt.lhopital_zero_atTop hdf' hdg' hg' hftop hgtop hdiv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lhopital_zero_atBot (hdf : \u2200\u1da0 x : \u211d in atBot, DifferentiableAt \u211d f x)\n    (hg' : \u2200\u1da0 x : \u211d in atBot, deriv g x \u2260 0) (hfbot : Tendsto f atBot (\ud835\udcdd 0))\n    (hgbot : Tendsto g atBot (\ud835\udcdd 0)) (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) atBot l) :\n    Tendsto (fun x => f x / g x) atBot l := by\n  have hdg : \u2200\u1da0 x in atBot, DifferentiableAt \u211d g x :=\n    hg'.mono fun _ hg' => by_contradiction fun h => hg' (deriv_zero_of_not_differentiableAt h)\n  have hdf' : \u2200\u1da0 x in atBot, HasDerivAt f (deriv f x) x :=\n    hdf.mono fun _ => DifferentiableAt.hasDerivAt\n  have hdg' : \u2200\u1da0 x in atBot, HasDerivAt g (deriv g x) x :=\n    hdg.mono fun _ => DifferentiableAt.hasDerivAt\n  exact HasDerivAt.lhopital_zero_atBot hdf' hdg' hg' hfbot hgbot hdiv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LHopital.lean", "context": {"open": ["Filter Set", "scoped Filter Topology Pointwise"], "variables": ["{a b : \u211d} {l : Filter \u211d} {f f' g g' : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf : \u2200\u1da0 (x : \u211d) in atBot, DifferentiableAt \u211d f x\nhg' : \u2200\u1da0 (x : \u211d) in atBot, deriv g x \u2260 0\nhfbot : Tendsto f atBot (nhds 0)\nhgbot : Tendsto g atBot (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) atBot l\n\u22a2 Tendsto (fun x => f x / g x) atBot l"}, {"line": "have hdg : \u2200\u1da0 x in atBot, DifferentiableAt \u211d g x :=\n    hg'.mono fun _ hg' => by_contradiction fun h => hg' (deriv_zero_of_not_differentiableAt h)", "tactic_state": "l : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf : \u2200\u1da0 (x : \u211d) in atBot, DifferentiableAt \u211d f x\nhg' : \u2200\u1da0 (x : \u211d) in atBot, deriv g x \u2260 0\nhfbot : Tendsto f atBot (nhds 0)\nhgbot : Tendsto g atBot (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) atBot l\nhdg : \u2200\u1da0 (x : \u211d) in atBot, DifferentiableAt \u211d g x\n\u22a2 Tendsto (fun x => f x / g x) atBot l"}, {"line": "have hdf' : \u2200\u1da0 x in atBot, HasDerivAt f (deriv f x) x :=\n    hdf.mono fun _ => DifferentiableAt.hasDerivAt", "tactic_state": "l : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf : \u2200\u1da0 (x : \u211d) in atBot, DifferentiableAt \u211d f x\nhg' : \u2200\u1da0 (x : \u211d) in atBot, deriv g x \u2260 0\nhfbot : Tendsto f atBot (nhds 0)\nhgbot : Tendsto g atBot (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) atBot l\nhdg : \u2200\u1da0 (x : \u211d) in atBot, DifferentiableAt \u211d g x\nhdf' : \u2200\u1da0 (x : \u211d) in atBot, HasDerivAt f (deriv f x) x\n\u22a2 Tendsto (fun x => f x / g x) atBot l"}, {"line": "have hdg' : \u2200\u1da0 x in atBot, HasDerivAt g (deriv g x) x :=\n    hdg.mono fun _ => DifferentiableAt.hasDerivAt", "tactic_state": "l : Filter \u211d\nf g : \u211d \u2192 \u211d\nhdf : \u2200\u1da0 (x : \u211d) in atBot, DifferentiableAt \u211d f x\nhg' : \u2200\u1da0 (x : \u211d) in atBot, deriv g x \u2260 0\nhfbot : Tendsto f atBot (nhds 0)\nhgbot : Tendsto g atBot (nhds 0)\nhdiv : Tendsto (fun x => deriv f x / deriv g x) atBot l\nhdg : \u2200\u1da0 (x : \u211d) in atBot, DifferentiableAt \u211d g x\nhdf' : \u2200\u1da0 (x : \u211d) in atBot, HasDerivAt f (deriv f x) x\nhdg' : \u2200\u1da0 (x : \u211d) in atBot, HasDerivAt g (deriv g x) x\n\u22a2 Tendsto (fun x => f x / g x) atBot l"}, {"line": "exact HasDerivAt.lhopital_zero_atBot hdf' hdg' hg' hfbot hgbot hdiv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem logDeriv_id (x : \ud835\udd5c) : logDeriv id x = 1 / x := by\n  simp [logDeriv_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LogDeriv.lean", "context": {"open": ["Filter Function", "scoped Topology"], "variables": ["{\ud835\udd5c \ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c] [NontriviallyNormedField \ud835\udd5c']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\n\u22a2 logDeriv id x = 1 / x"}, {"line": "simp [logDeriv_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivWithinAt_forall_lt_or_forall_gt_of_forall_ne {s : Set \u211d} (hs : Convex \u211d s)\n    (hf : \u2200 x \u2208 s, HasDerivWithinAt f (f' x) s x) {m : \u211d} (hf' : \u2200 x \u2208 s, f' x \u2260 m) :\n    (\u2200 x \u2208 s, f' x < m) \u2228 \u2200 x \u2208 s, m < f' x := by\n  contrapose! hf'\n  rcases hf' with \u27e8\u27e8b, hb, hmb\u27e9, \u27e8a, ha, hma\u27e9\u27e9\n  exact (hs.ordConnected.image_hasDerivWithinAt hf).out (mem_image_of_mem f' ha)\n    (mem_image_of_mem f' hb) \u27e8hma, hmb\u27e9", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Darboux.lean", "context": {"open": ["Filter Set", "scoped Topology"], "variables": ["{a b : \u211d} {f f' : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f f' : \u211d \u2192 \u211d\ns : Set \u211d\nhs : Convex \u211d s\nhf : \u2200 x \u2208 s, HasDerivWithinAt f (f' x) s x\nm : \u211d\nhf' : \u2200 x \u2208 s, f' x \u2260 m\n\u22a2 (\u2200 x \u2208 s, f' x < m) \u2228 \u2200 x \u2208 s, m < f' x"}, {"line": "contrapose! hf'", "tactic_state": "f f' : \u211d \u2192 \u211d\ns : Set \u211d\nhs : Convex \u211d s\nhf : \u2200 x \u2208 s, HasDerivWithinAt f (f' x) s x\nm : \u211d\nhf' : (\u2203 x \u2208 s, m \u2264 f' x) \u2227 \u2203 x \u2208 s, f' x \u2264 m\n\u22a2 \u2203 x \u2208 s, f' x = m"}, {"line": "rcases hf' with \u27e8\u27e8b, hb, hmb\u27e9, \u27e8a, ha, hma\u27e9\u27e9", "tactic_state": "case intro.intro.intro.intro.intro\nf f' : \u211d \u2192 \u211d\ns : Set \u211d\nhs : Convex \u211d s\nhf : \u2200 x \u2208 s, HasDerivWithinAt f (f' x) s x\nm b : \u211d\nhb : b \u2208 s\nhmb : m \u2264 f' b\na : \u211d\nha : a \u2208 s\nhma : f' a \u2264 m\n\u22a2 \u2203 x \u2208 s, f' x = m"}, {"line": "exact (hs.ordConnected.image_hasDerivWithinAt hf).out (mem_image_of_mem f' ha)\n    (mem_image_of_mem f' hb) \u27e8hma, hmb\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isLocalMin_of_deriv_Ioo {f : \u211d \u2192 \u211d} {a b c : \u211d}\n    (g\u2080 : a < b) (g\u2081 : b < c) (h : ContinuousAt f b)\n    (hd\u2080 : DifferentiableOn \u211d f (Ioo a b)) (hd\u2081 : DifferentiableOn \u211d f (Ioo b c))\n    (h\u2080 : \u2200 x \u2208 Ioo a b, deriv f x \u2264 0)\n    (h\u2081 : \u2200 x \u2208 Ioo b c, 0 \u2264 deriv f x) : IsLocalMin f b := by\n  have := isLocalMax_of_deriv_Ioo (f := -f) g\u2080 g\u2081\n    (by simp_all) hd\u2080.neg hd\u2081.neg\n    (fun x hx => deriv.neg (f := f) \u25b8 Left.nonneg_neg_iff.mpr <|h\u2080 x hx)\n    (fun x hx => deriv.neg (f := f) \u25b8 Left.neg_nonpos_iff.mpr <|h\u2081 x hx)\n  exact (neg_neg f) \u25b8 IsLocalMax.neg this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FirstDerivativeTest.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\na b c : \u211d\ng\u2080 : a < b\ng\u2081 : b < c\nh : ContinuousAt f b\nhd\u2080 : DifferentiableOn \u211d f (Ioo a b)\nhd\u2081 : DifferentiableOn \u211d f (Ioo b c)\nh\u2080 : \u2200 x \u2208 Ioo a b, deriv f x \u2264 0\nh\u2081 : \u2200 x \u2208 Ioo b c, 0 \u2264 deriv f x\n\u22a2 IsLocalMin f b"}, {"line": "have := isLocalMax_of_deriv_Ioo (f := -f) g\u2080 g\u2081\n    (by simp_all) hd\u2080.neg hd\u2081.neg\n    (fun x hx => deriv.neg (f := f) \u25b8 Left.nonneg_neg_iff.mpr <|h\u2080 x hx)\n    (fun x hx => deriv.neg (f := f) \u25b8 Left.neg_nonpos_iff.mpr <|h\u2081 x hx)", "tactic_state": "f : \u211d \u2192 \u211d\na b c : \u211d\ng\u2080 : a < b\ng\u2081 : b < c\nh : ContinuousAt f b\nhd\u2080 : DifferentiableOn \u211d f (Ioo a b)\nhd\u2081 : DifferentiableOn \u211d f (Ioo b c)\nh\u2080 : \u2200 x \u2208 Ioo a b, deriv f x \u2264 0\nh\u2081 : \u2200 x \u2208 Ioo b c, 0 \u2264 deriv f x\nthis : IsLocalMax (-f) b\n\u22a2 IsLocalMin f b"}, {"line": "exact (neg_neg f) \u25b8 IsLocalMax.neg this", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isLocalMax_of_deriv' {f : \u211d \u2192 \u211d} {b : \u211d} (h : ContinuousAt f b)\n    (hd\u2080 : \u2200\u1da0 x in \ud835\udcdd[<] b, DifferentiableAt \u211d f x) (hd\u2081 : \u2200\u1da0 x in \ud835\udcdd[>] b, DifferentiableAt \u211d f x)\n    (h\u2080 : \u2200\u1da0 x in \ud835\udcdd[<] b, 0 \u2264 deriv f x) (h\u2081 : \u2200\u1da0 x in \ud835\udcdd[>] b, deriv f x \u2264 0) :\n    IsLocalMax f b := by\n  obtain \u27e8a, ha\u27e9 := (nhdsLT_basis b).eventually_iff.mp <| hd\u2080.and h\u2080\n  obtain \u27e8c, hc\u27e9 := (nhdsGT_basis b).eventually_iff.mp <| hd\u2081.and h\u2081\n  exact isLocalMax_of_deriv_Ioo ha.1 hc.1 h\n    (fun _ hx => (ha.2 hx).1.differentiableWithinAt)\n    (fun _ hx => (hc.2 hx).1.differentiableWithinAt)\n    (fun _ hx => (ha.2 hx).2) (fun x hx => (hc.2 hx).2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FirstDerivativeTest.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\nb : \u211d\nh : ContinuousAt f b\nhd\u2080 : \u2200\u1da0 (x : \u211d) in nhdsWithin b (Iio b), DifferentiableAt \u211d f x\nhd\u2081 : \u2200\u1da0 (x : \u211d) in nhdsWithin b (Ioi b), DifferentiableAt \u211d f x\nh\u2080 : \u2200\u1da0 (x : \u211d) in nhdsWithin b (Iio b), 0 \u2264 deriv f x\nh\u2081 : \u2200\u1da0 (x : \u211d) in nhdsWithin b (Ioi b), deriv f x \u2264 0\n\u22a2 IsLocalMax f b"}, {"line": "obtain \u27e8a, ha\u27e9 := (nhdsLT_basis b).eventually_iff.mp <| hd\u2080.and h\u2080", "tactic_state": "case intro\nf : \u211d \u2192 \u211d\nb : \u211d\nh : ContinuousAt f b\nhd\u2080 : \u2200\u1da0 (x : \u211d) in nhdsWithin b (Iio b), DifferentiableAt \u211d f x\nhd\u2081 : \u2200\u1da0 (x : \u211d) in nhdsWithin b (Ioi b), DifferentiableAt \u211d f x\nh\u2080 : \u2200\u1da0 (x : \u211d) in nhdsWithin b (Iio b), 0 \u2264 deriv f x\nh\u2081 : \u2200\u1da0 (x : \u211d) in nhdsWithin b (Ioi b), deriv f x \u2264 0\na : \u211d\nha : a < b \u2227 \u2200 \u2983x : \u211d\u2984, x \u2208 Ioo a b \u2192 DifferentiableAt \u211d f x \u2227 0 \u2264 deriv f x\n\u22a2 IsLocalMax f b"}, {"line": "obtain \u27e8c, hc\u27e9 := (nhdsGT_basis b).eventually_iff.mp <| hd\u2081.and h\u2081", "tactic_state": "case intro.intro\nf : \u211d \u2192 \u211d\nb : \u211d\nh : ContinuousAt f b\nhd\u2080 : \u2200\u1da0 (x : \u211d) in nhdsWithin b (Iio b), DifferentiableAt \u211d f x\nhd\u2081 : \u2200\u1da0 (x : \u211d) in nhdsWithin b (Ioi b), DifferentiableAt \u211d f x\nh\u2080 : \u2200\u1da0 (x : \u211d) in nhdsWithin b (Iio b), 0 \u2264 deriv f x\nh\u2081 : \u2200\u1da0 (x : \u211d) in nhdsWithin b (Ioi b), deriv f x \u2264 0\na : \u211d\nha : a < b \u2227 \u2200 \u2983x : \u211d\u2984, x \u2208 Ioo a b \u2192 DifferentiableAt \u211d f x \u2227 0 \u2264 deriv f x\nc : \u211d\nhc : b < c \u2227 \u2200 \u2983x : \u211d\u2984, x \u2208 Ioo b c \u2192 DifferentiableAt \u211d f x \u2227 deriv f x \u2264 0\n\u22a2 IsLocalMax f b"}, {"line": "exact isLocalMax_of_deriv_Ioo ha.1 hc.1 h\n    (fun _ hx => (ha.2 hx).1.differentiableWithinAt)\n    (fun _ hx => (hc.2 hx).1.differentiableWithinAt)\n    (fun _ hx => (ha.2 hx).2) (fun x hx => (hc.2 hx).2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem order_zero : (0 : FormalMultilinearSeries \ud835\udd5c E F).order = 0 := by simp [order]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FormalMultilinearSeries.lean", "context": {"open": ["Set Fin Topology"], "variables": ["{\ud835\udd5c : Type u} {\ud835\udd5c' : Type u'} {E : Type v} {F : Type w} {G : Type x}", "[Semiring \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E] [TopologicalSpace E] [ContinuousAdd E]", "(\ud835\udd5c) [Semiring \ud835\udd5c'] [SMul \ud835\udd5c \ud835\udd5c']", "[Module \ud835\udd5c' E] [ContinuousConstSMul \ud835\udd5c' E] [IsScalarTower \ud835\udd5c \ud835\udd5c' E]", "[Module \ud835\udd5c' F] [ContinuousConstSMul \ud835\udd5c' F] [IsScalarTower \ud835\udd5c \ud835\udd5c' F]", "[Ring \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E] [IsTopologicalAddGroup E]", "[NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "(p : FormalMultilinearSeries \ud835\udd5c E F)", "[Semiring \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E] [TopologicalSpace E] [ContinuousAdd E]", "{\u03b9 : Type*} {E : \u03b9 \u2192 Type*} [\u2200 i, AddCommGroup (E i)] [\u2200 i, Module \ud835\udd5c (E i)]", "[Semiring \ud835\udd5c] {n : \u2115} [AddCommMonoid E] [Module \ud835\udd5c E] [TopologicalSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "inst\u271d\u00b9 : AddCommMonoid sorry\ninst\u271d : TopologicalSpace sorry\n\u22a2 sorry = 0"}, {"line": "simp [order]", "tactic_state": "inst\u271d\u00b9 : AddCommMonoid sorry\ninst\u271d : TopologicalSpace sorry\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem order_eq_find [DecidablePred fun n => p n \u2260 0] (hp : \u2203 n, p n \u2260 0) :\n    p.order = Nat.find hp := by convert Nat.sInf_def hp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FormalMultilinearSeries.lean", "context": {"open": ["Set Fin Topology"], "variables": ["{\ud835\udd5c : Type u} {\ud835\udd5c' : Type u'} {E : Type v} {F : Type w} {G : Type x}", "[Semiring \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E] [TopologicalSpace E] [ContinuousAdd E]", "(\ud835\udd5c) [Semiring \ud835\udd5c'] [SMul \ud835\udd5c \ud835\udd5c']", "[Module \ud835\udd5c' E] [ContinuousConstSMul \ud835\udd5c' E] [IsScalarTower \ud835\udd5c \ud835\udd5c' E]", "[Module \ud835\udd5c' F] [ContinuousConstSMul \ud835\udd5c' F] [IsScalarTower \ud835\udd5c \ud835\udd5c' F]", "[Ring \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E] [IsTopologicalAddGroup E]", "[NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "(p : FormalMultilinearSeries \ud835\udd5c E F)", "[Semiring \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E] [TopologicalSpace E] [ContinuousAdd E]", "{\u03b9 : Type*} {E : \u03b9 \u2192 Type*} [\u2200 i, AddCommGroup (E i)] [\u2200 i, Module \ud835\udd5c (E i)]", "[Semiring \ud835\udd5c] {n : \u2115} [AddCommMonoid E] [Module \ud835\udd5c E] [TopologicalSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "inst\u271d\u00b2 : AddCommMonoid sorry\ninst\u271d\u00b9 : TopologicalSpace sorry\ninst\u271d : DecidablePred fun n => sorry \u2260 0\nhp : \u2203 n, sorry \u2260 0\n\u22a2 sorry = Nat.find hp"}, {"line": "convert Nat.sInf_def hp", "tactic_state": "case h.e'_2\ninst\u271d\u00b2 : AddCommMonoid sorry\ninst\u271d\u00b9 : TopologicalSpace sorry\ninst\u271d : DecidablePred fun n => sorry \u2260 0\nhp : \u2203 n, sorry \u2260 0\n\u22a2 sorry = sInf fun x => sorry = 0 \u2192 False\n---\ncase h.e'_3.h.e'_1.h.h.e\ninst\u271d\u00b2 : AddCommMonoid sorry\ninst\u271d\u00b9 : TopologicalSpace sorry\ninst\u271d : DecidablePred fun n => sorry \u2260 0\nhp : \u2203 n, sorry \u2260 0\nx\u271d : \u2115\n\u22a2 Ne sorry = Membership.mem fun x => sorry = 0 \u2192 False\n---\ncase h.e'_3.h.e'_1.h.h.e'_1\ninst\u271d\u00b2 : AddCommMonoid sorry\ninst\u271d\u00b9 : TopologicalSpace sorry\ninst\u271d : DecidablePred fun n => sorry \u2260 0\nhp : \u2203 n, sorry \u2260 0\nx\u271d : \u2115\n\u22a2 0 = x\u271d"}]}
{"declaration": "theorem order_eq_zero_iff (hp : p \u2260 0) : p.order = 0 \u2194 p 0 \u2260 0 := by\n  simp [order_eq_zero_iff', hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FormalMultilinearSeries.lean", "context": {"open": ["Set Fin Topology"], "variables": ["{\ud835\udd5c : Type u} {\ud835\udd5c' : Type u'} {E : Type v} {F : Type w} {G : Type x}", "[Semiring \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E] [TopologicalSpace E] [ContinuousAdd E]", "(\ud835\udd5c) [Semiring \ud835\udd5c'] [SMul \ud835\udd5c \ud835\udd5c']", "[Module \ud835\udd5c' E] [ContinuousConstSMul \ud835\udd5c' E] [IsScalarTower \ud835\udd5c \ud835\udd5c' E]", "[Module \ud835\udd5c' F] [ContinuousConstSMul \ud835\udd5c' F] [IsScalarTower \ud835\udd5c \ud835\udd5c' F]", "[Ring \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E] [IsTopologicalAddGroup E]", "[NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F]", "(p : FormalMultilinearSeries \ud835\udd5c E F)", "[Semiring \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E] [TopologicalSpace E] [ContinuousAdd E]", "{\u03b9 : Type*} {E : \u03b9 \u2192 Type*} [\u2200 i, AddCommGroup (E i)] [\u2200 i, Module \ud835\udd5c (E i)]", "[Semiring \ud835\udd5c] {n : \u2115} [AddCommMonoid E] [Module \ud835\udd5c E] [TopologicalSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : sorry\ninst\u271d\u00b9 : AddCommMonoid sorry\ninst\u271d : TopologicalSpace sorry\nhp : p \u2260 0\n\u22a2 sorry = 0 \u2194 sorry \u2260 0"}, {"line": "simp [order_eq_zero_iff', hp]", "tactic_state": "p : sorry\ninst\u271d\u00b9 : AddCommMonoid sorry\ninst\u271d : TopologicalSpace sorry\nhp : p \u2260 0\n\u22a2 False"}]}
{"declaration": "theorem image_le_of_liminf_slope_right_le_deriv_boundary {f : \u211d \u2192 \u211d} {a b : \u211d}\n    (hf : ContinuousOn f (Icc a b)) {B B' : \u211d \u2192 \u211d} (ha : f a \u2264 B a) (hB : ContinuousOn B (Icc a b))\n    (hB' : \u2200 x \u2208 Ico a b, HasDerivWithinAt B (B' x) (Ici x) x)\n    -- `bound` actually says `liminf (f z - f x) / (z - x) \u2264 B' x`\n    (bound : \u2200 x \u2208 Ico a b, \u2200 r, B' x < r \u2192 \u2203\u1da0 z in \ud835\udcdd[>] x, slope f x z < r) :\n    \u2200 \u2983x\u2984, x \u2208 Icc a b \u2192 f x \u2264 B x := by\n  have Hr : \u2200 x \u2208 Icc a b, \u2200 r > 0, f x \u2264 B x + r * (x - a) := fun x hx r hr => by\n    apply image_le_of_liminf_slope_right_lt_deriv_boundary' hf bound\n    \u00b7 rwa [sub_self, mul_zero, add_zero]\n    \u00b7 exact hB.add (continuousOn_const.mul (continuousOn_id.sub continuousOn_const))\n    \u00b7 intro x hx\n      exact (hB' x hx).add (((hasDerivWithinAt_id x (Ici x)).sub_const a).const_mul r)\n    \u00b7 intro x _ _\n      rw [mul_one]\n      exact (lt_add_iff_pos_right _).2 hr\n    exact hx\n  intro x hx\n  have : ContinuousWithinAt (fun r => B x + r * (x - a)) (Ioi 0) 0 :=\n    continuousWithinAt_const.add (continuousWithinAt_id.mul continuousWithinAt_const)\n  convert continuousWithinAt_const.closure_le _ this (Hr x hx) using 1 <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/MeanValue.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {F : Type*} [NormedAddCommGroup F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\na b : \u211d\nhf : ContinuousOn f (Icc a b)\nB B' : \u211d \u2192 \u211d\nha : f a \u2264 B a\nhB : ContinuousOn B (Icc a b)\nhB' : \u2200 x \u2208 Ico a b, HasDerivWithinAt B (B' x) (Ici x) x\nbound : \u2200 x \u2208 Ico a b, \u2200 (r : \u211d), B' x < r \u2192 \u2203\u1da0 (z : \u211d) in nhdsWithin x (Ioi x), slope f x z < r\n\u22a2 \u2200 \u2983x : \u211d\u2984, x \u2208 Icc a b \u2192 f x \u2264 B x"}, {"line": "have Hr : \u2200 x \u2208 Icc a b, \u2200 r > 0, f x \u2264 B x + r * (x - a) := fun x hx r hr => by\n    apply image_le_of_liminf_slope_right_lt_deriv_boundary' hf bound\n    \u00b7 rwa [sub_self, mul_zero, add_zero]\n    \u00b7 exact hB.add (continuousOn_const.mul (continuousOn_id.sub continuousOn_const))\n    \u00b7 intro x hx\n      exact (hB' x hx).add (((hasDerivWithinAt_id x (Ici x)).sub_const a).const_mul r)\n    \u00b7 intro x _ _\n      rw [mul_one]\n      exact (lt_add_iff_pos_right _).2 hr\n    exact hx", "tactic_state": "f : \u211d \u2192 \u211d\na b : \u211d\nhf : ContinuousOn f (Icc a b)\nB B' : \u211d \u2192 \u211d\nha : f a \u2264 B a\nhB : ContinuousOn B (Icc a b)\nhB' : \u2200 x \u2208 Ico a b, HasDerivWithinAt B (B' x) (Ici x) x\nbound : \u2200 x \u2208 Ico a b, \u2200 (r : \u211d), B' x < r \u2192 \u2203\u1da0 (z : \u211d) in nhdsWithin x (Ioi x), slope f x z < r\nHr : \u2200 x \u2208 Icc a b, \u2200 r > 0, f x \u2264 B x + r * (x - a)\n\u22a2 \u2200 \u2983x : \u211d\u2984, x \u2208 Icc a b \u2192 f x \u2264 B x"}, {"line": "intro x hx", "tactic_state": "f : \u211d \u2192 \u211d\na b : \u211d\nhf : ContinuousOn f (Icc a b)\nB B' : \u211d \u2192 \u211d\nha : f a \u2264 B a\nhB : ContinuousOn B (Icc a b)\nhB' : \u2200 x \u2208 Ico a b, HasDerivWithinAt B (B' x) (Ici x) x\nbound : \u2200 x \u2208 Ico a b, \u2200 (r : \u211d), B' x < r \u2192 \u2203\u1da0 (z : \u211d) in nhdsWithin x (Ioi x), slope f x z < r\nHr : \u2200 x \u2208 Icc a b, \u2200 r > 0, f x \u2264 B x + r * (x - a)\nx : \u211d\nhx : x \u2208 Icc a b\n\u22a2 f x \u2264 B x"}, {"line": "have : ContinuousWithinAt (fun r => B x + r * (x - a)) (Ioi 0) 0 :=\n    continuousWithinAt_const.add (continuousWithinAt_id.mul continuousWithinAt_const)", "tactic_state": "f : \u211d \u2192 \u211d\na b : \u211d\nhf : ContinuousOn f (Icc a b)\nB B' : \u211d \u2192 \u211d\nha : f a \u2264 B a\nhB : ContinuousOn B (Icc a b)\nhB' : \u2200 x \u2208 Ico a b, HasDerivWithinAt B (B' x) (Ici x) x\nbound : \u2200 x \u2208 Ico a b, \u2200 (r : \u211d), B' x < r \u2192 \u2203\u1da0 (z : \u211d) in nhdsWithin x (Ioi x), slope f x z < r\nHr : \u2200 x \u2208 Icc a b, \u2200 r > 0, f x \u2264 B x + r * (x - a)\nx : \u211d\nhx : x \u2208 Icc a b\nthis : ContinuousWithinAt (fun r => B x + r * (x - a)) (Ioi 0) 0\n\u22a2 f x \u2264 B x"}, {"line": "convert continuousWithinAt_const.closure_le _ this (Hr x hx) using 1 <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_image_sub_le_of_norm_deriv_le_segment_01' {f' : \u211d \u2192 E} {C : \u211d}\n    (hf : \u2200 x \u2208 Icc (0 : \u211d) 1, HasDerivWithinAt f (f' x) (Icc (0 : \u211d) 1) x)\n    (bound : \u2200 x \u2208 Ico (0 : \u211d) 1, \u2016f' x\u2016 \u2264 C) : \u2016f 1 - f 0\u2016 \u2264 C := by\n  simpa only [sub_zero,mul_one] using\n    norm_image_sub_le_of_norm_deriv_le_segment' hf bound 1 (right_mem_Icc.2 zero_le_one)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/MeanValue.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {F : Type*} [NormedAddCommGroup F]", "{f : \u211d \u2192 E} {a b : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf f' : \u211d \u2192 E\nC : \u211d\nhf : \u2200 x \u2208 Icc 0 1, HasDerivWithinAt f (f' x) (Icc 0 1) x\nbound : \u2200 x \u2208 Ico 0 1, \u2016f' x\u2016 \u2264 C\n\u22a2 \u2016f 1 - f 0\u2016 \u2264 C"}, {"line": "simpa only [sub_zero,mul_one] using\n    norm_image_sub_le_of_norm_deriv_le_segment' hf bound 1 (right_mem_Icc.2 zero_le_one)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_image_sub_le_of_norm_deriv_le_segment_01 {C : \u211d}\n    (hf : DifferentiableOn \u211d f (Icc (0 : \u211d) 1))\n    (bound : \u2200 x \u2208 Ico (0 : \u211d) 1, \u2016derivWithin f (Icc (0 : \u211d) 1) x\u2016 \u2264 C) : \u2016f 1 - f 0\u2016 \u2264 C := by\n  simpa only [sub_zero,mul_one] using\n    norm_image_sub_le_of_norm_deriv_le_segment hf bound 1 (right_mem_Icc.2 zero_le_one)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/MeanValue.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {F : Type*} [NormedAddCommGroup F]", "{f : \u211d \u2192 E} {a b : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nC : \u211d\nhf : DifferentiableOn \u211d f (Icc 0 1)\nbound : \u2200 x \u2208 Ico 0 1, \u2016derivWithin f (Icc 0 1) x\u2016 \u2264 C\n\u22a2 \u2016f 1 - f 0\u2016 \u2264 C"}, {"line": "simpa only [sub_zero,mul_one] using\n    norm_image_sub_le_of_norm_deriv_le_segment hf bound 1 (right_mem_Icc.2 zero_le_one)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_of_derivWithin_eq (fdiff : DifferentiableOn \u211d f (Icc a b))\n    (gdiff : DifferentiableOn \u211d g (Icc a b))\n    (hderiv : EqOn (derivWithin f (Icc a b)) (derivWithin g (Icc a b)) (Ico a b)) (hi : f a = g a) :\n    \u2200 y \u2208 Icc a b, f y = g y := by\n  have A : \u2200 y \u2208 Ico a b, HasDerivWithinAt f (derivWithin f (Icc a b) y) (Ici y) y := fun y hy =>\n    (fdiff y (mem_Icc_of_Ico hy)).hasDerivWithinAt.mono_of_mem_nhdsWithin\n    (Icc_mem_nhdsGE_of_mem hy)\n  have B : \u2200 y \u2208 Ico a b, HasDerivWithinAt g (derivWithin g (Icc a b) y) (Ici y) y := fun y hy =>\n    (gdiff y (mem_Icc_of_Ico hy)).hasDerivWithinAt.mono_of_mem_nhdsWithin\n    (Icc_mem_nhdsGE_of_mem hy)\n  exact eq_of_has_deriv_right_eq A (fun y hy => (hderiv hy).symm \u25b8 B y hy) fdiff.continuousOn\n    gdiff.continuousOn hi\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/MeanValue.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {F : Type*} [NormedAddCommGroup F]", "{f : \u211d \u2192 E} {a b : \u211d}", "{f' g : \u211d \u2192 E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\ng : \u211d \u2192 E\nfdiff : DifferentiableOn \u211d f (Icc a b)\ngdiff : DifferentiableOn \u211d g (Icc a b)\nhderiv : EqOn (derivWithin f (Icc a b)) (derivWithin g (Icc a b)) (Ico a b)\nhi : f a = g a\n\u22a2 \u2200 y \u2208 Icc a b, f y = g y"}, {"line": "have A : \u2200 y \u2208 Ico a b, HasDerivWithinAt f (derivWithin f (Icc a b) y) (Ici y) y := fun y hy =>\n    (fdiff y (mem_Icc_of_Ico hy)).hasDerivWithinAt.mono_of_mem_nhdsWithin\n    (Icc_mem_nhdsGE_of_mem hy)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\ng : \u211d \u2192 E\nfdiff : DifferentiableOn \u211d f (Icc a b)\ngdiff : DifferentiableOn \u211d g (Icc a b)\nhderiv : EqOn (derivWithin f (Icc a b)) (derivWithin g (Icc a b)) (Ico a b)\nhi : f a = g a\nA : \u2200 y \u2208 Ico a b, sorry\n\u22a2 \u2200 y \u2208 Icc a b, f y = g y"}, {"line": "have B : \u2200 y \u2208 Ico a b, HasDerivWithinAt g (derivWithin g (Icc a b) y) (Ici y) y := fun y hy =>\n    (gdiff y (mem_Icc_of_Ico hy)).hasDerivWithinAt.mono_of_mem_nhdsWithin\n    (Icc_mem_nhdsGE_of_mem hy)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\ng : \u211d \u2192 E\nfdiff : DifferentiableOn \u211d f (Icc a b)\ngdiff : DifferentiableOn \u211d g (Icc a b)\nhderiv : EqOn (derivWithin f (Icc a b)) (derivWithin g (Icc a b)) (Ico a b)\nhi : f a = g a\nA : \u2200 y \u2208 Ico a b, sorry\nB : \u2200 y \u2208 Ico a b, sorry\n\u22a2 \u2200 y \u2208 Icc a b, f y = g y"}, {"line": "exact eq_of_has_deriv_right_eq A (fun y hy => (hderiv hy).symm \u25b8 B y hy) fdiff.continuousOn\n    gdiff.continuousOn hi", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.is_const_of_fderiv_eq_zero\n    {E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] {f : E \u2192 G}\n    (hf : Differentiable \ud835\udd5c f) (hf' : \u2200 x, fderiv \ud835\udd5c f x = 0)\n    (x y : E) : f x = f y := by\n  letI : RCLike \ud835\udd5c := IsRCLikeNormedField.rclike \ud835\udd5c\n  let A : NormedSpace \u211d E := RestrictScalars.normedSpace \u211d \ud835\udd5c E\n  exact convex_univ.is_const_of_fderivWithin_eq_zero hf.differentiableOn\n    (fun x _ => by rw [fderivWithin_univ]; exact hf' x) trivial trivial\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/MeanValue.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {F : Type*} [NormedAddCommGroup F]", "{f : \u211d \u2192 E} {a b : \u211d}", "{f' g : \u211d \u2192 E}", "{\ud835\udd5c G : Type*} [NontriviallyNormedField \ud835\udd5c] [IsRCLikeNormedField \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_3\nG : Type u_4\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b2 : IsRCLikeNormedField \ud835\udd5c\nE : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : E \u2192 G\nhf : sorry\nhf' : E \u2192 sorry = 0\nx y : E\n\u22a2 f x = f y"}, {"line": "letI : RCLike \ud835\udd5c := IsRCLikeNormedField.rclike \ud835\udd5c", "tactic_state": "\ud835\udd5c : Type u_3\nG : Type u_4\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b2 : IsRCLikeNormedField \ud835\udd5c\nE : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : E \u2192 G\nhf : sorry\nhf' : E \u2192 sorry = 0\nx y : E\nthis : RCLike \ud835\udd5c := sorry\n\u22a2 f x = f y"}, {"line": "let A : NormedSpace \u211d E := RestrictScalars.normedSpace \u211d \ud835\udd5c E", "tactic_state": "\ud835\udd5c : Type u_3\nG : Type u_4\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b2 : IsRCLikeNormedField \ud835\udd5c\nE : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : E \u2192 G\nhf : sorry\nhf' : E \u2192 sorry = 0\nx y : E\nthis : RCLike \ud835\udd5c := sorry\nA : sorry := sorry\n\u22a2 f x = f y"}, {"line": "exact convex_univ.is_const_of_fderivWithin_eq_zero hf.differentiableOn\n    (fun x _ => by rw [fderivWithin_univ]; exact hf' x) trivial trivial", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.eq_of_fderiv_eq\n    {E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] {f g : E \u2192 G}\n    (hf : Differentiable \ud835\udd5c f) (hg : Differentiable \ud835\udd5c g)\n    (hf' : \u2200 x, fderiv \ud835\udd5c f x = fderiv \ud835\udd5c g x) (x : E) (hfgx : f x = g x) : f = g := by\n  letI : RCLike \ud835\udd5c := IsRCLikeNormedField.rclike \ud835\udd5c\n  let A : NormedSpace \u211d E := RestrictScalars.normedSpace \u211d \ud835\udd5c E\n  suffices Set.univ.EqOn f g from funext fun x => this <| mem_univ x\n  exact convex_univ.eqOn_of_fderivWithin_eq hf.differentiableOn hg.differentiableOn\n    uniqueDiffOn_univ (fun x _ => by simpa using hf' _) (mem_univ _) hfgx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/MeanValue.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {F : Type*} [NormedAddCommGroup F]", "{f : \u211d \u2192 E} {a b : \u211d}", "{f' g : \u211d \u2192 E}", "{\ud835\udd5c G : Type*} [NontriviallyNormedField \ud835\udd5c] [IsRCLikeNormedField \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_3\nG : Type u_4\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b2 : IsRCLikeNormedField \ud835\udd5c\nE : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf g : E \u2192 G\nhf : sorry\nhg : sorry\nhf' : \u2200 (x : E), sorry = sorry\nx : E\nhfgx : f x = g x\n\u22a2 f = g"}, {"line": "letI : RCLike \ud835\udd5c := IsRCLikeNormedField.rclike \ud835\udd5c", "tactic_state": "\ud835\udd5c : Type u_3\nG : Type u_4\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b2 : IsRCLikeNormedField \ud835\udd5c\nE : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf g : E \u2192 G\nhf : sorry\nhg : sorry\nhf' : \u2200 (x : E), sorry = sorry\nx : E\nhfgx : f x = g x\nthis : RCLike \ud835\udd5c := sorry\n\u22a2 f = g"}, {"line": "let A : NormedSpace \u211d E := RestrictScalars.normedSpace \u211d \ud835\udd5c E", "tactic_state": "\ud835\udd5c : Type u_3\nG : Type u_4\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b2 : IsRCLikeNormedField \ud835\udd5c\nE : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf g : E \u2192 G\nhf : sorry\nhg : sorry\nhf' : \u2200 (x : E), sorry = sorry\nx : E\nhfgx : f x = g x\nthis : RCLike \ud835\udd5c := sorry\nA : sorry := sorry\n\u22a2 f = g"}, {"line": "suffices Set.univ.EqOn f g from funext fun x => this <| mem_univ x", "tactic_state": "\ud835\udd5c : Type u_3\nG : Type u_4\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b2 : IsRCLikeNormedField \ud835\udd5c\nE : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf g : E \u2192 G\nhf : sorry\nhg : sorry\nhf' : \u2200 (x : E), sorry = sorry\nx : E\nhfgx : f x = g x\nthis : RCLike \ud835\udd5c := sorry\nA : sorry := sorry\n\u22a2 EqOn f g univ"}, {"line": "exact convex_univ.eqOn_of_fderivWithin_eq hf.differentiableOn hg.differentiableOn\n    uniqueDiffOn_univ (fun x _ => by simpa using hf' _) (mem_univ _) hfgx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Monotone.ae_differentiableAt {f : \u211d \u2192 \u211d} (hf : Monotone f) :\n    \u2200\u1d50 x, DifferentiableAt \u211d f x := by\n  filter_upwards [hf.ae_hasDerivAt] with x hx using hx.differentiableAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Monotone.lean", "context": {"open": ["Set Filter Function Metric MeasureTheory MeasureTheory.Measure IsUnifLocDoublingMeasure", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\nhf : Monotone f\n\u22a2 \u2200\u1d50 (x : \u211d), DifferentiableAt \u211d f x"}, {"line": "filter_upwards [hf.ae_hasDerivAt] with x hx using hx.differentiableAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MonotoneOn.ae_differentiableWithinAt {f : \u211d \u2192 \u211d} {s : Set \u211d} (hf : MonotoneOn f s)\n    (hs : MeasurableSet s) : \u2200\u1d50 x \u2202volume.restrict s, DifferentiableWithinAt \u211d f s x := by\n  rw [ae_restrict_iff' hs]\n  exact hf.ae_differentiableWithinAt_of_mem", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Monotone.lean", "context": {"open": ["Set Filter Function Metric MeasureTheory MeasureTheory.Measure IsUnifLocDoublingMeasure", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\ns : Set \u211d\nhf : MonotoneOn f s\nhs : MeasurableSet s\n\u22a2 \u2200\u1d50 (x : \u211d) \u2202volume.restrict s, DifferentiableWithinAt \u211d f s x"}, {"line": "rw [ae_restrict_iff' hs]", "tactic_state": "f : \u211d \u2192 \u211d\ns : Set \u211d\nhf : MonotoneOn f s\nhs : MeasurableSet s\n\u22a2 \u2200\u1d50 (x : \u211d), x \u2208 s \u2192 DifferentiableWithinAt \u211d f s x"}, {"line": "exact hf.ae_differentiableWithinAt_of_mem", "tactic_state": "No Goals!"}]}
{"declaration": "theorem summable_of_summable_hasDerivAt (hu : Summable u)\n    (hg : \u2200 n y, HasDerivAt (g n) (g' n y) y) (hg' : \u2200 n y, \u2016g' n y\u2016 \u2264 u n)\n    (hg0 : Summable fun n => g n y\u2080) (y : \ud835\udd5c) : Summable fun n => g n y := by\n  exact summable_of_summable_hasDerivAt_of_isPreconnected hu isOpen_univ isPreconnected_univ\n    (fun n x _ => hg n x) (fun n x _ => hg' n x) (mem_univ _) hg0 (mem_univ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/SmoothSeries.lean", "context": {"open": ["Set Metric TopologicalSpace Function Asymptotics Filter", "scoped Topology NNReal"], "variables": ["{\u03b1 \u03b2 \ud835\udd5c E F : Type*} [NontriviallyNormedField \ud835\udd5c] [IsRCLikeNormedField \ud835\udd5c]", "[NormedSpace \ud835\udd5c F]", "{f : \u03b1 \u2192 E \u2192 F} {f' : \u03b1 \u2192 E \u2192 E \u2192L[\ud835\udd5c] F} {g : \u03b1 \u2192 \ud835\udd5c \u2192 F} {g' : \u03b1 \u2192 \ud835\udd5c \u2192 F} {v : \u2115 \u2192 \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c\ninst\u271d : IsRCLikeNormedField \ud835\udd5c\n\u03b1\u271d : Type u_6\nu : \u03b1 \u2192 \u03b1\u271d\ny\u2080 : \ud835\udd5c\nhu : Summable u\nhg : \u03b1 \u2192 \ud835\udd5c \u2192 sorry\nhg' : \u2200 (n : \u03b1) (y : \ud835\udd5c), sorry \u2264 u n\nhg0 : sorry\ny : \ud835\udd5c\n\u22a2 sorry"}, {"line": "exact summable_of_summable_hasDerivAt_of_isPreconnected hu isOpen_univ isPreconnected_univ\n    (fun n x _ => hg n x) (fun n x _ => hg' n x) (mem_univ _) hg0 (mem_univ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivAt_tsum (hu : Summable u) (hg : \u2200 n y, HasDerivAt (g n) (g' n y) y)\n    (hg' : \u2200 n y, \u2016g' n y\u2016 \u2264 u n) (hg0 : Summable fun n => g n y\u2080) (y : \ud835\udd5c) :\n    HasDerivAt (fun z => \u2211' n, g n z) (\u2211' n, g' n y) y := by\n  exact hasDerivAt_tsum_of_isPreconnected hu isOpen_univ isPreconnected_univ\n    (fun n y _ => hg n y) (fun n y _ => hg' n y) (mem_univ _) hg0 (mem_univ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/SmoothSeries.lean", "context": {"open": ["Set Metric TopologicalSpace Function Asymptotics Filter", "scoped Topology NNReal"], "variables": ["{\u03b1 \u03b2 \ud835\udd5c E F : Type*} [NontriviallyNormedField \ud835\udd5c] [IsRCLikeNormedField \ud835\udd5c]", "[NormedSpace \ud835\udd5c F]", "{f : \u03b1 \u2192 E \u2192 F} {f' : \u03b1 \u2192 E \u2192 E \u2192L[\ud835\udd5c] F} {g : \u03b1 \u2192 \ud835\udd5c \u2192 F} {g' : \u03b1 \u2192 \ud835\udd5c \u2192 F} {v : \u2115 \u2192 \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c\ninst\u271d : IsRCLikeNormedField \ud835\udd5c\n\u03b1\u271d : Type u_6\nu : \u03b1 \u2192 \u03b1\u271d\ny\u2080 : \ud835\udd5c\nhu : Summable u\nhg : \u03b1 \u2192 \ud835\udd5c \u2192 sorry\nhg' : \u2200 (n : \u03b1) (y : \ud835\udd5c), sorry \u2264 u n\nhg0 : sorry\ny : \ud835\udd5c\n\u22a2 sorry"}, {"line": "exact hasDerivAt_tsum_of_isPreconnected hu isOpen_univ isPreconnected_univ\n    (fun n y _ => hg n y) (fun n y _ => hg' n y) (mem_univ _) hg0 (mem_univ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tangentConeAt_mono (h : s \u2286 t) : tangentConeAt \ud835\udd5c s x \u2286 tangentConeAt \ud835\udd5c t x := by\n  rintro y \u27e8c, d, ds, ctop, clim\u27e9\n  exact \u27e8c, d, mem_of_superset ds fun n hn => h hn, ctop, clim\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/TangentCone.lean", "context": {"open": ["Filter Set Metric", "scoped Topology Pointwise", "NormedField"], "variables": ["(\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommMonoid E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{\ud835\udd5c}", "{E F G : Type*}", "[AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{x y : E} {s t : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : TopologicalSpace E\nx : E\ns t : Set E\nh : s \u2286 t\n\u22a2 tangentConeAt \ud835\udd5c s x \u2286 tangentConeAt \ud835\udd5c t x"}, {"line": "rintro y \u27e8c, d, ds, ctop, clim\u27e9", "tactic_state": "case intro.intro.intro.intro\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : TopologicalSpace E\nx : E\ns t : Set E\nh : s \u2286 t\ny : E\nc : \u2115 \u2192 \ud835\udd5c\nd : \u2115 \u2192 E\nds : \u2200\u1da0 (n : \u2115) in atTop, x + d n \u2208 s\nctop : Tendsto (fun n => \u2016c n\u2016) atTop atTop\nclim : Tendsto (fun n => c n \u2022 d n) atTop (nhds y)\n\u22a2 y \u2208 tangentConeAt \ud835\udd5c t x"}, {"line": "exact \u27e8c, d, mem_of_superset ds fun n hn => h hn, ctop, clim\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UniqueDiffWithinAt.accPt [Nontrivial E] (h : UniqueDiffWithinAt \ud835\udd5c s x) : AccPt x (\ud835\udcdf s) := by\n  by_contra! h'\n  have : Dense (Submodule.span \ud835\udd5c (0 : Set E) : Set E) :=\n    h.1.mono <| by gcongr; exact tangentConeAt_subset_zero h'\n  simp [dense_iff_closure_eq] at this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/TangentCone.lean", "context": {"open": ["Filter Set Metric", "scoped Topology Pointwise", "NormedField"], "variables": ["(\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommMonoid E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{\ud835\udd5c}", "{E F G : Type*}", "[AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{x y : E} {s t : Set E}", "[NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "[NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedAddCommGroup G] [NormedSpace \u211d G]", "{x y : E} {s t : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\nx : E\ns : Set E\ninst\u271d : Nontrivial E\nh : UniqueDiffWithinAt \ud835\udd5c s x\n\u22a2 AccPt x (principal s)"}, {"line": "by_contra! h'", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\nx : E\ns : Set E\ninst\u271d : Nontrivial E\nh : UniqueDiffWithinAt \ud835\udd5c s x\nh' : \u00acAccPt x (principal s)\n\u22a2 False"}, {"line": "have : Dense (Submodule.span \ud835\udd5c (0 : Set E) : Set E) :=\n    h.1.mono <| by gcongr; exact tangentConeAt_subset_zero h'", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\nx : E\ns : Set E\ninst\u271d : Nontrivial E\nh : UniqueDiffWithinAt \ud835\udd5c s x\nh' : \u00acAccPt x (principal s)\nthis : sorry\n\u22a2 False"}, {"line": "simp [dense_iff_closure_eq] at this", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\nx : E\ns : Set E\ninst\u271d : Nontrivial E\nh : UniqueDiffWithinAt \ud835\udd5c s x\nh' : \u00acAccPt x (principal s)\nthis : sorry ()\n\u22a2 False"}]}
{"declaration": "theorem uniqueDiffWithinAt_univ : UniqueDiffWithinAt \ud835\udd5c univ x := by\n  rw [uniqueDiffWithinAt_iff]\n  rw [tangentConeAt_univ]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/TangentCone.lean", "context": {"open": ["Filter Set Metric", "scoped Topology Pointwise", "NormedField"], "variables": ["(\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommMonoid E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{\ud835\udd5c}", "{E F G : Type*}", "[AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{x y : E} {s t : Set E}", "[NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "[NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedAddCommGroup G] [NormedSpace \u211d G]", "{x y : E} {s t : Set E}", "[AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{x y : E} {s t : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : Module \ud835\udd5c E\ninst\u271d\u2075 : TopologicalSpace E\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : TopologicalSpace E\nx : E\n\u22a2 UniqueDiffWithinAt \ud835\udd5c univ x"}, {"line": "rw [uniqueDiffWithinAt_iff]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : Module \ud835\udd5c E\ninst\u271d\u2075 : TopologicalSpace E\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : TopologicalSpace E\nx : E\n\u22a2 Dense \u2191(Submodule.span \ud835\udd5c (tangentConeAt \ud835\udd5c univ x)) \u2227 x \u2208 closure univ"}, {"line": "rw [tangentConeAt_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : Module \ud835\udd5c E\ninst\u271d\u2075 : TopologicalSpace E\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : TopologicalSpace E\nx : E\n\u22a2 Dense \u2191(Submodule.span \ud835\udd5c univ) \u2227 x \u2208 closure univ"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniqueDiffWithinAt_closure :\n    UniqueDiffWithinAt \ud835\udd5c (closure s) x \u2194 UniqueDiffWithinAt \ud835\udd5c s x := by\n  simp [uniqueDiffWithinAt_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/TangentCone.lean", "context": {"open": ["Filter Set Metric", "scoped Topology Pointwise", "NormedField"], "variables": ["(\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommMonoid E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{\ud835\udd5c}", "{E F G : Type*}", "[AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{x y : E} {s t : Set E}", "[NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "[NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedAddCommGroup G] [NormedSpace \u211d G]", "{x y : E} {s t : Set E}", "[AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{x y : E} {s t : Set E}", "[NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "[NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{x y : E} {s t : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u2079 : AddCommGroup E\ninst\u271d\u2078 : Module \ud835\udd5c E\ninst\u271d\u2077 : TopologicalSpace E\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nx : E\ns : Set E\n\u22a2 UniqueDiffWithinAt \ud835\udd5c (closure s) x \u2194 UniqueDiffWithinAt \ud835\udd5c s x"}, {"line": "simp [uniqueDiffWithinAt_iff]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nE : Type u_3\ninst\u271d\u2079 : AddCommGroup E\ninst\u271d\u2078 : Module \ud835\udd5c E\ninst\u271d\u2077 : TopologicalSpace E\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nx : E\ns : Set E\n\u22a2 x \u2208 closure s \u2192\n    (Dense \u2191(Submodule.span \ud835\udd5c (tangentConeAt \ud835\udd5c (closure s) x)) \u2194 Dense \u2191(Submodule.span \ud835\udd5c (tangentConeAt \ud835\udd5c s x)))"}]}
{"declaration": "theorem taylorWithinEval_succ (f : \u211d \u2192 E) (n : \u2115) (s : Set \u211d) (x\u2080 x : \u211d) :\n    taylorWithinEval f (n + 1) s x\u2080 x = taylorWithinEval f n s x\u2080 x +\n      (((n + 1 : \u211d) * n !)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080 := by\n  simp_rw [taylorWithinEval, taylorWithin_succ, LinearMap.map_add, PolynomialModule.comp_eval]\n  congr\n  simp only [Polynomial.eval_sub]\n  simp only [Polynomial.eval_X]\n  simp only [Polynomial.eval_C]\n  simp only [PolynomialModule.eval_single]\n  simp only [mul_inv_rev]\n  dsimp only [taylorCoeffWithin]\n  rw [\u2190 mul_smul]\n  rw [mul_comm]\n  rw [Nat.factorial_succ]\n  rw [Nat.cast_mul]\n  rw [Nat.cast_add]\n  rw [Nat.cast_one]\n  rw [mul_inv_rev]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Taylor.lean", "context": {"open": ["scoped Interval Topology Nat", "Set"], "variables": ["{\ud835\udd5c E F : Type*}", "[NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nn : \u2115\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 taylorWithinEval f (n + 1) s x\u2080 x =\n    taylorWithinEval f n s x\u2080 x +\n      (((\u2191n + 1) * \u2191n.factorial)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080"}, {"line": "simp_rw [taylorWithinEval, taylorWithin_succ, LinearMap.map_add, PolynomialModule.comp_eval]", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nn : \u2115\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 (PolynomialModule.eval x) (taylorWithin f n s x\u2080) +\n      (PolynomialModule.eval (Polynomial.eval x (Polynomial.X - Polynomial.C x\u2080)))\n        ((PolynomialModule.single \u211d (n + 1)) (taylorCoeffWithin f (n + 1) s x\u2080)) =\n    (PolynomialModule.eval x) (taylorWithin f n s x\u2080) +\n      (((\u2191n + 1) * \u2191n.factorial)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080"}, {"line": "congr", "tactic_state": "case e_a\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nn : \u2115\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 (PolynomialModule.eval (Polynomial.eval x (Polynomial.X - Polynomial.C x\u2080)))\n      ((PolynomialModule.single \u211d (n + 1)) (taylorCoeffWithin f (n + 1) s x\u2080)) =\n    (((\u2191n + 1) * \u2191n.factorial)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080"}, {"line": "simp only [Polynomial.eval_sub]", "tactic_state": "case e_a\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nn : \u2115\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 (PolynomialModule.eval (Polynomial.eval x Polynomial.X - Polynomial.eval x (Polynomial.C x\u2080)))\n      ((PolynomialModule.single \u211d (n + 1)) (taylorCoeffWithin f (n + 1) s x\u2080)) =\n    (((\u2191n + 1) * \u2191n.factorial)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080"}, {"line": "simp only [Polynomial.eval_X]", "tactic_state": "case e_a\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nn : \u2115\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 (PolynomialModule.eval (x - Polynomial.eval x (Polynomial.C x\u2080)))\n      ((PolynomialModule.single \u211d (n + 1)) (taylorCoeffWithin f (n + 1) s x\u2080)) =\n    (((\u2191n + 1) * \u2191n.factorial)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080"}, {"line": "simp only [Polynomial.eval_C]", "tactic_state": "case e_a\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nn : \u2115\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 (PolynomialModule.eval (x - x\u2080)) ((PolynomialModule.single \u211d (n + 1)) (taylorCoeffWithin f (n + 1) s x\u2080)) =\n    (((\u2191n + 1) * \u2191n.factorial)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080"}, {"line": "simp only [PolynomialModule.eval_single]", "tactic_state": "case e_a\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nn : \u2115\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 (x - x\u2080) ^ (n + 1) \u2022 taylorCoeffWithin f (n + 1) s x\u2080 =\n    (((\u2191n + 1) * \u2191n.factorial)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080"}, {"line": "simp only [mul_inv_rev]", "tactic_state": "case e_a\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nn : \u2115\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 (x - x\u2080) ^ (n + 1) \u2022 taylorCoeffWithin f (n + 1) s x\u2080 =\n    ((\u2191n.factorial)\u207b\u00b9 * (\u2191n + 1)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080"}, {"line": "dsimp only [taylorCoeffWithin]", "tactic_state": "case e_a\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nn : \u2115\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 (x - x\u2080) ^ (n + 1) \u2022 (\u2191(n + 1).factorial)\u207b\u00b9 \u2022 iteratedDerivWithin (n + 1) f s x\u2080 =\n    ((\u2191n.factorial)\u207b\u00b9 * (\u2191n + 1)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080"}, {"line": "rw [\u2190 mul_smul]", "tactic_state": "case e_a\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nn : \u2115\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 ((x - x\u2080) ^ (n + 1) * (\u2191(n + 1).factorial)\u207b\u00b9) \u2022 iteratedDerivWithin (n + 1) f s x\u2080 =\n    ((\u2191n.factorial)\u207b\u00b9 * (\u2191n + 1)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080"}, {"line": "rw [mul_comm]", "tactic_state": "case e_a\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nn : \u2115\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 ((\u2191(n + 1).factorial)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080 =\n    ((\u2191n.factorial)\u207b\u00b9 * (\u2191n + 1)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080"}, {"line": "rw [Nat.factorial_succ]", "tactic_state": "case e_a\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nn : \u2115\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 ((\u2191((n + 1) * n.factorial))\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080 =\n    ((\u2191n.factorial)\u207b\u00b9 * (\u2191n + 1)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080"}, {"line": "rw [Nat.cast_mul]", "tactic_state": "case e_a\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nn : \u2115\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 ((\u2191(n + 1) * \u2191n.factorial)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080 =\n    ((\u2191n.factorial)\u207b\u00b9 * (\u2191n + 1)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080"}, {"line": "rw [Nat.cast_add]", "tactic_state": "case e_a\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nn : \u2115\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 (((\u2191n + \u21911) * \u2191n.factorial)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080 =\n    ((\u2191n.factorial)\u207b\u00b9 * (\u2191n + 1)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080"}, {"line": "rw [Nat.cast_one]", "tactic_state": "case e_a\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nn : \u2115\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 (((\u2191n + 1) * \u2191n.factorial)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080 =\n    ((\u2191n.factorial)\u207b\u00b9 * (\u2191n + 1)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080"}, {"line": "rw [mul_inv_rev]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem taylor_within_zero_eval (f : \u211d \u2192 E) (s : Set \u211d) (x\u2080 x : \u211d) :\n    taylorWithinEval f 0 s x\u2080 x = f x\u2080 := by\n  dsimp only [taylorWithinEval]\n  dsimp only [taylorWithin]\n  dsimp only [taylorCoeffWithin]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Taylor.lean", "context": {"open": ["scoped Interval Topology Nat", "Set"], "variables": ["{\ud835\udd5c E F : Type*}", "[NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 taylorWithinEval f 0 s x\u2080 x = f x\u2080"}, {"line": "dsimp only [taylorWithinEval]", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 (PolynomialModule.eval x) (taylorWithin f 0 s x\u2080) = f x\u2080"}, {"line": "dsimp only [taylorWithin]", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 (PolynomialModule.eval x)\n      (\u2211 k \u2208 Finset.range (0 + 1),\n        (PolynomialModule.comp (Polynomial.X - Polynomial.C x\u2080))\n          ((PolynomialModule.single \u211d k) (taylorCoeffWithin f k s x\u2080))) =\n    f x\u2080"}, {"line": "dsimp only [taylorCoeffWithin]", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\ns : Set \u211d\nx\u2080 x : \u211d\n\u22a2 (PolynomialModule.eval x)\n      (\u2211 k \u2208 Finset.range (0 + 1),\n        (PolynomialModule.comp (Polynomial.X - Polynomial.C x\u2080))\n          ((PolynomialModule.single \u211d k) ((\u2191k.factorial)\u207b\u00b9 \u2022 iteratedDerivWithin k f s x\u2080))) =\n    f x\u2080"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem monomial_has_deriv_aux (t x : \u211d) (n : \u2115) :\n    HasDerivAt (fun y => (x - y) ^ (n + 1)) (-(n + 1) * (x - t) ^ n) t := by\n  simp_rw [sub_eq_neg_add]\n  rw [\u2190 neg_one_mul]\n  rw [mul_comm (-1 : \u211d)]\n  rw [mul_assoc]\n  rw [mul_comm (-1 : \u211d)]\n  rw [\u2190 mul_assoc]\n  convert HasDerivAt.pow (n + 1) ((hasDerivAt_id t).neg.add_const x)\n  simp only [Nat.cast_add]\n  simp only [Nat.cast_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Taylor.lean", "context": {"open": ["scoped Interval Topology Nat", "Set"], "variables": ["{\ud835\udd5c E F : Type*}", "[NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "t x : \u211d\nn : \u2115\n\u22a2 HasDerivAt (fun y => (x - y) ^ (n + 1)) (-(\u2191n + 1) * (x - t) ^ n) t"}, {"line": "simp_rw [sub_eq_neg_add]", "tactic_state": "t x : \u211d\nn : \u2115\n\u22a2 HasDerivAt (fun y => (-y + x) ^ (n + 1)) (-(\u2191n + 1) * (-t + x) ^ n) t"}, {"line": "rw [\u2190 neg_one_mul]", "tactic_state": "t x : \u211d\nn : \u2115\n\u22a2 HasDerivAt (fun y => (-y + x) ^ (n + 1)) (-1 * (\u2191n + 1) * (-t + x) ^ n) t"}, {"line": "rw [mul_comm (-1 : \u211d)]", "tactic_state": "t x : \u211d\nn : \u2115\n\u22a2 HasDerivAt (fun y => (-y + x) ^ (n + 1)) ((\u2191n + 1) * -1 * (-t + x) ^ n) t"}, {"line": "rw [mul_assoc]", "tactic_state": "t x : \u211d\nn : \u2115\n\u22a2 HasDerivAt (fun y => (-y + x) ^ (n + 1)) ((\u2191n + 1) * (-1 * (-t + x) ^ n)) t"}, {"line": "rw [mul_comm (-1 : \u211d)]", "tactic_state": "t x : \u211d\nn : \u2115\n\u22a2 HasDerivAt (fun y => (-y + x) ^ (n + 1)) ((\u2191n + 1) * ((-t + x) ^ n * -1)) t"}, {"line": "rw [\u2190 mul_assoc]", "tactic_state": "t x : \u211d\nn : \u2115\n\u22a2 HasDerivAt (fun y => (-y + x) ^ (n + 1)) ((\u2191n + 1) * (-t + x) ^ n * -1) t"}, {"line": "convert HasDerivAt.pow (n + 1) ((hasDerivAt_id t).neg.add_const x)", "tactic_state": "case h.e'_9.h.e'_5.h.e'_5\nt x : \u211d\nn : \u2115\n\u22a2 \u2191n + 1 = \u2191(n + 1)"}, {"line": "simp only [Nat.cast_add]", "tactic_state": "case h.e'_9.h.e'_5.h.e'_5\nt x : \u211d\nn : \u2115\n\u22a2 \u2191n + 1 = \u2191n + \u21911"}, {"line": "simp only [Nat.cast_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.taylor_tendsto {f : \u211d \u2192 \u211d} {x\u2080 : \u211d} {n : \u2115} {s : Set \u211d}\n    (hs : Convex \u211d s) (hx\u2080s : x\u2080 \u2208 s) (hf : ContDiffOn \u211d n f s) :\n    Filter.Tendsto (fun x \u21a6 (f x - taylorWithinEval f n s x\u2080 x) / (x - x\u2080) ^ n)\n      (\ud835\udcdd[s] x\u2080) (\ud835\udcdd 0) := by\n  convert _root_.taylor_tendsto hs hx\u2080s hf using 2 with x\n  simp [div_eq_inv_mul]\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Taylor.lean", "context": {"open": ["scoped Interval Topology Nat", "Set"], "variables": ["{\ud835\udd5c E F : Type*}", "[NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\nx\u2080 : \u211d\nn : \u2115\ns : Set \u211d\nhs : Convex \u211d s\nhx\u2080s : x\u2080 \u2208 s\nhf : ContDiffOn \u211d (\u2191n) f s\n\u22a2 Filter.Tendsto (fun x => (f x - taylorWithinEval f n s x\u2080 x) / (x - x\u2080) ^ n) (nhdsWithin x\u2080 s) (nhds 0)"}, {"line": "convert _root_.taylor_tendsto hs hx\u2080s hf using 2 with x", "tactic_state": "case h.e'_3.h\nf : \u211d \u2192 \u211d\nx\u2080 : \u211d\nn : \u2115\ns : Set \u211d\nhs : Convex \u211d s\nhx\u2080s : x\u2080 \u2208 s\nhf : ContDiffOn \u211d (\u2191n) f s\nx : \u211d\n\u22a2 (f x - taylorWithinEval f n s x\u2080 x) / (x - x\u2080) ^ n = ((x - x\u2080) ^ n)\u207b\u00b9 \u2022 (f x - taylorWithinEval f n s x\u2080 x)"}, {"line": "simp [div_eq_inv_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem taylor_mean_remainder_cauchy {f : \u211d \u2192 \u211d} {x x\u2080 : \u211d} {n : \u2115} (hx : x\u2080 < x)\n    (hf : ContDiffOn \u211d n f (Icc x\u2080 x))\n    (hf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc x\u2080 x)) (Ioo x\u2080 x)) :\n    \u2203 x' \u2208 Ioo x\u2080 x, f x - taylorWithinEval f n (Icc x\u2080 x) x\u2080 x =\n      iteratedDerivWithin (n + 1) f (Icc x\u2080 x) x' * (x - x') ^ n / n ! * (x - x\u2080) := by\n  have gcont : ContinuousOn id (Icc x\u2080 x) := by fun_prop\n  have gdiff : \u2200 x_1 : \u211d, x_1 \u2208 Ioo x\u2080 x \u2192 HasDerivAt id ((fun _ : \u211d => (1 : \u211d)) x_1) x_1 :=\n    fun _ _ => hasDerivAt_id _\n  -- We apply the general theorem with g = id\n  rcases taylor_mean_remainder hx hf hf' gcont gdiff fun _ _ => by simp with \u27e8y, hy, h\u27e9\n  use y, hy\n  rw [h]\n  field_simp [n.factorial_ne_zero]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Taylor.lean", "context": {"open": ["scoped Interval Topology Nat", "Set"], "variables": ["{\ud835\udd5c E F : Type*}", "[NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\nx x\u2080 : \u211d\nn : \u2115\nhx : x\u2080 < x\nhf : ContDiffOn \u211d (\u2191n) f (Icc x\u2080 x)\nhf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc x\u2080 x)) (Ioo x\u2080 x)\n\u22a2 \u2203 x' \u2208 Ioo x\u2080 x,\n    f x - taylorWithinEval f n (Icc x\u2080 x) x\u2080 x =\n      iteratedDerivWithin (n + 1) f (Icc x\u2080 x) x' * (x - x') ^ n / \u2191n.factorial * (x - x\u2080)"}, {"line": "have gcont : ContinuousOn id (Icc x\u2080 x) := sorry", "tactic_state": "f : \u211d \u2192 \u211d\nx x\u2080 : \u211d\nn : \u2115\nhx : x\u2080 < x\nhf : ContDiffOn \u211d (\u2191n) f (Icc x\u2080 x)\nhf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc x\u2080 x)) (Ioo x\u2080 x)\ngcont : ContinuousOn id (Icc x\u2080 x)\n\u22a2 \u2203 x' \u2208 Ioo x\u2080 x,\n    f x - taylorWithinEval f n (Icc x\u2080 x) x\u2080 x =\n      iteratedDerivWithin (n + 1) f (Icc x\u2080 x) x' * (x - x') ^ n / \u2191n.factorial * (x - x\u2080)"}, {"line": "have gdiff : \u2200 x_1 : \u211d, x_1 \u2208 Ioo x\u2080 x \u2192 HasDerivAt id ((fun _ : \u211d => (1 : \u211d)) x_1) x_1 :=\n    fun _ _ => hasDerivAt_id _", "tactic_state": "f : \u211d \u2192 \u211d\nx x\u2080 : \u211d\nn : \u2115\nhx : x\u2080 < x\nhf : ContDiffOn \u211d (\u2191n) f (Icc x\u2080 x)\nhf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc x\u2080 x)) (Ioo x\u2080 x)\ngcont : ContinuousOn id (Icc x\u2080 x)\ngdiff : \u2200 x_1 \u2208 Ioo x\u2080 x, HasDerivAt id ((fun x => 1) x_1) x_1\n\u22a2 \u2203 x' \u2208 Ioo x\u2080 x,\n    f x - taylorWithinEval f n (Icc x\u2080 x) x\u2080 x =\n      iteratedDerivWithin (n + 1) f (Icc x\u2080 x) x' * (x - x') ^ n / \u2191n.factorial * (x - x\u2080)"}, {"line": "rcases taylor_mean_remainder hx hf hf' gcont gdiff fun _ _ => by simp with \u27e8y, hy, h\u27e9", "tactic_state": "case intro.intro\nf : \u211d \u2192 \u211d\nx x\u2080 : \u211d\nn : \u2115\nhx : x\u2080 < x\nhf : ContDiffOn \u211d (\u2191n) f (Icc x\u2080 x)\nhf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc x\u2080 x)) (Ioo x\u2080 x)\ngcont : ContinuousOn id (Icc x\u2080 x)\ngdiff : \u2200 x_1 \u2208 Ioo x\u2080 x, HasDerivAt id ((fun x => 1) x_1) x_1\ny : \u211d\nhy : y \u2208 Ioo x\u2080 x\nh :\n  f x - taylorWithinEval f n (Icc x\u2080 x) x\u2080 x =\n    ((x - y) ^ n / \u2191n.factorial * (id x - id x\u2080) / 1) \u2022 iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y\n\u22a2 \u2203 x' \u2208 Ioo x\u2080 x,\n    f x - taylorWithinEval f n (Icc x\u2080 x) x\u2080 x =\n      iteratedDerivWithin (n + 1) f (Icc x\u2080 x) x' * (x - x') ^ n / \u2191n.factorial * (x - x\u2080)"}, {"line": "use y, hy", "tactic_state": "case right\nf : \u211d \u2192 \u211d\nx x\u2080 : \u211d\nn : \u2115\nhx : x\u2080 < x\nhf : ContDiffOn \u211d (\u2191n) f (Icc x\u2080 x)\nhf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc x\u2080 x)) (Ioo x\u2080 x)\ngcont : ContinuousOn id (Icc x\u2080 x)\ngdiff : \u2200 x_1 \u2208 Ioo x\u2080 x, HasDerivAt id ((fun x => 1) x_1) x_1\ny : \u211d\nhy : y \u2208 Ioo x\u2080 x\nh :\n  f x - taylorWithinEval f n (Icc x\u2080 x) x\u2080 x =\n    ((x - y) ^ n / \u2191n.factorial * (id x - id x\u2080) / 1) \u2022 iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y\n\u22a2 f x - taylorWithinEval f n (Icc x\u2080 x) x\u2080 x =\n    iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y * (x - y) ^ n / \u2191n.factorial * (x - x\u2080)"}, {"line": "rw [h]", "tactic_state": "case right\nf : \u211d \u2192 \u211d\nx x\u2080 : \u211d\nn : \u2115\nhx : x\u2080 < x\nhf : ContDiffOn \u211d (\u2191n) f (Icc x\u2080 x)\nhf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc x\u2080 x)) (Ioo x\u2080 x)\ngcont : ContinuousOn id (Icc x\u2080 x)\ngdiff : \u2200 x_1 \u2208 Ioo x\u2080 x, HasDerivAt id ((fun x => 1) x_1) x_1\ny : \u211d\nhy : y \u2208 Ioo x\u2080 x\nh :\n  f x - taylorWithinEval f n (Icc x\u2080 x) x\u2080 x =\n    ((x - y) ^ n / \u2191n.factorial * (id x - id x\u2080) / 1) \u2022 iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y\n\u22a2 ((x - y) ^ n / \u2191n.factorial * (id x - id x\u2080) / 1) \u2022 iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y =\n    iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y * (x - y) ^ n / \u2191n.factorial * (x - x\u2080)"}, {"line": "field_simp [n.factorial_ne_zero]", "tactic_state": "case right\nf : \u211d \u2192 \u211d\nx x\u2080 : \u211d\nn : \u2115\nhx : x\u2080 < x\nhf : ContDiffOn \u211d (\u2191n) f (Icc x\u2080 x)\nhf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc x\u2080 x)) (Ioo x\u2080 x)\ngcont : ContinuousOn id (Icc x\u2080 x)\ngdiff : \u2200 x_1 \u2208 Ioo x\u2080 x, HasDerivAt id ((fun x => 1) x_1) x_1\ny : \u211d\nhy : y \u2208 Ioo x\u2080 x\nh :\n  f x - taylorWithinEval f n (Icc x\u2080 x) x\u2080 x =\n    ((x - y) ^ n / \u2191n.factorial * (id x - id x\u2080) / 1) \u2022 iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y\n\u22a2 (x - y) ^ n * (x - x\u2080) * iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y =\n    iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y * (x - y) ^ n * (x - x\u2080)"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lieBracketWithin_eq_zero_of_eq_zero (hV : V x = 0) (hW : W x = 0) :\n    lieBracketWithin \ud835\udd5c V W s x = 0 := by\n  simp [lieBracketWithin, hV, hW]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/VectorField.lean", "context": {"open": ["Set", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "(\ud835\udd5c) in", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_2\nV : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_3\nW : x\u271d\u00b9\nx\u271d : Sort u_4\nlieBracketWithin : x\u271d\nhV : sorry = 0\nhW : sorry = 0\n\u22a2 sorry = 0"}, {"line": "simp [lieBracketWithin, hV, hW]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lieBracket_eq_zero_of_eq_zero (hV : V x = 0) (hW : W x = 0) :\n    lieBracket \ud835\udd5c V W x = 0 := by\n  simp [lieBracket, hV, hW]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/VectorField.lean", "context": {"open": ["Set", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "(\ud835\udd5c) in", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_2\nV : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_3\nW : x\u271d\u00b9\nx\u271d : Sort u_4\nlieBracket : x\u271d\nhV : sorry = 0\nhW : sorry = 0\n\u22a2 sorry = 0"}, {"line": "simp [lieBracket, hV, hW]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lieBracket_swap : lieBracket \ud835\udd5c V W x = - lieBracket \ud835\udd5c W V x := by\n  simp [lieBracket]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/VectorField.lean", "context": {"open": ["Set", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "(\ud835\udd5c) in", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nlieBracket : x\u271d\n\u22a2 sorry = -sorry"}, {"line": "simp [lieBracket]", "tactic_state": "x\u271d : Sort u_2\nlieBracket : x\u271d\n\u22a2 sorry () = -sorry ()"}]}
{"declaration": "theorem lieBracketWithin_of_mem_nhdsWithin (st : t \u2208 \ud835\udcdd[s] x) (hs : UniqueDiffWithinAt \ud835\udd5c s x)\n    (hV : DifferentiableWithinAt \ud835\udd5c V t x) (hW : DifferentiableWithinAt \ud835\udd5c W t x) :\n    lieBracketWithin \ud835\udd5c V W s x = lieBracketWithin \ud835\udd5c V W t x := by\n  simp [lieBracketWithin, fderivWithin_of_mem_nhdsWithin st hs hV,\n    fderivWithin_of_mem_nhdsWithin st hs hW]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/VectorField.lean", "context": {"open": ["Set", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "(\ud835\udd5c) in", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\n\u03b1\u271d : Type u_2\nx : \u03b1\u271d\ns t : Set \u03b1\u271d\nF\u271d\u00b9 : Type u_3\nV : \u03b1\u271d \u2192 F\u271d\u00b9\nF\u271d : Type u_4\nW : \u03b1\u271d \u2192 F\u271d\nx\u271d : Sort u_5\nlieBracketWithin : x\u271d\nst : t \u2208 nhdsWithin x s\nhs : UniqueDiffWithinAt \ud835\udd5c s x\nhV : DifferentiableWithinAt \ud835\udd5c V t x\nhW : DifferentiableWithinAt \ud835\udd5c W t x\n\u22a2 sorry = sorry"}, {"line": "simp [lieBracketWithin, fderivWithin_of_mem_nhdsWithin st hs hV,\n    fderivWithin_of_mem_nhdsWithin st hs hW]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\n\u03b1\u271d : Type u_2\nx : \u03b1\u271d\ns t : Set \u03b1\u271d\nF\u271d\u00b9 : Type u_3\nV : \u03b1\u271d \u2192 F\u271d\u00b9\nF\u271d : Type u_4\nW : \u03b1\u271d \u2192 F\u271d\nx\u271d : Sort u_5\nlieBracketWithin : x\u271d\nst : t \u2208 nhdsWithin x s\nhs : UniqueDiffWithinAt \ud835\udd5c s x\nhV : DifferentiableWithinAt \ud835\udd5c V t x\nhW : DifferentiableWithinAt \ud835\udd5c W t x\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem lieBracketWithin_inter (ht : t \u2208 \ud835\udcdd x) :\n    lieBracketWithin \ud835\udd5c V W (s \u2229 t) x = lieBracketWithin \ud835\udd5c V W s x := by\n  simp [lieBracketWithin, fderivWithin_inter, ht]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/VectorField.lean", "context": {"open": ["Set", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "(\ud835\udd5c) in", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Type u_2\nx : \u03b1\u271d\nt : Set \u03b1\u271d\nx\u271d : Sort u_3\nlieBracketWithin : x\u271d\nht : t \u2208 nhds x\n\u22a2 sorry = sorry"}, {"line": "simp [lieBracketWithin, fderivWithin_inter, ht]", "tactic_state": "\u03b1\u271d : Type u_2\nx : \u03b1\u271d\nt : Set \u03b1\u271d\nx\u271d : Sort u_3\nlieBracketWithin : x\u271d\nht : t \u2208 nhds x\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem lieBracketWithin_eq_lieBracket (hs : UniqueDiffWithinAt \ud835\udd5c s x)\n    (hV : DifferentiableAt \ud835\udd5c V x) (hW : DifferentiableAt \ud835\udd5c W x) :\n    lieBracketWithin \ud835\udd5c V W s x = lieBracket \ud835\udd5c V W x := by\n  simp [lieBracketWithin, lieBracket, fderivWithin_eq_fderiv, hs, hV, hW]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/VectorField.lean", "context": {"open": ["Set", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "(\ud835\udd5c) in", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\n\u03b1\u271d : Type u_2\ns : Set \u03b1\u271d\nx : \u03b1\u271d\nF\u271d\u00b9 : Type u_3\nV : \u03b1\u271d \u2192 F\u271d\u00b9\nF\u271d : Type u_4\nW : \u03b1\u271d \u2192 F\u271d\nx\u271d\u00b9 : Sort u_5\nlieBracketWithin : x\u271d\u00b9\nx\u271d : Sort u_6\nlieBracket : x\u271d\nhs : UniqueDiffWithinAt \ud835\udd5c s x\nhV : DifferentiableAt \ud835\udd5c V x\nhW : DifferentiableAt \ud835\udd5c W x\n\u22a2 sorry = sorry"}, {"line": "simp [lieBracketWithin, lieBracket, fderivWithin_eq_fderiv, hs, hV, hW]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\n\u03b1\u271d : Type u_2\ns : Set \u03b1\u271d\nx : \u03b1\u271d\nF\u271d\u00b9 : Type u_3\nV : \u03b1\u271d \u2192 F\u271d\u00b9\nF\u271d : Type u_4\nW : \u03b1\u271d \u2192 F\u271d\nx\u271d\u00b9 : Sort u_5\nlieBracketWithin : x\u271d\u00b9\nx\u271d : Sort u_6\nlieBracket : x\u271d\nhs : UniqueDiffWithinAt \ud835\udd5c s x\nhV : DifferentiableAt \ud835\udd5c V x\nhW : DifferentiableAt \ud835\udd5c W x\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem lieBracketWithin_congr_set' (y : E) (h : s =\u1da0[\ud835\udcdd[{y}\u1d9c] x] t) :\n    lieBracketWithin \ud835\udd5c V W s x = lieBracketWithin \ud835\udd5c V W t x := by\n  simp [lieBracketWithin, fderivWithin_congr_set' _ h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/VectorField.lean", "context": {"open": ["Set", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "(\ud835\udd5c) in", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\nx : E\n\u03b2\u271d : Type u_3\ns t : E \u2192 \u03b2\u271d\nx\u271d : Sort u_4\nlieBracketWithin : x\u271d\ny : E\nh : s =\u1da0[sorry] t\n\u22a2 sorry = sorry"}, {"line": "simp [lieBracketWithin, fderivWithin_congr_set' _ h]", "tactic_state": "E : Type u_2\nx : E\n\u03b2\u271d : Type u_3\ns t : E \u2192 \u03b2\u271d\nx\u271d : Sort u_4\nlieBracketWithin : x\u271d\ny : E\nh : s =\u1da0[sorry] t\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem _root_.DifferentiableWithinAt.lieBracketWithin_congr_mono\n    (hV : DifferentiableWithinAt \ud835\udd5c V s x) (hVs : EqOn V\u2081 V t) (hVx : V\u2081 x = V x)\n    (hW : DifferentiableWithinAt \ud835\udd5c W s x) (hWs : EqOn W\u2081 W t) (hWx : W\u2081 x = W x)\n    (hxt : UniqueDiffWithinAt \ud835\udd5c t x) (h\u2081 : t \u2286 s) :\n    lieBracketWithin \ud835\udd5c V\u2081 W\u2081 t x = lieBracketWithin \ud835\udd5c V W s x := by\n  simp [lieBracketWithin, hV.fderivWithin_congr_mono, hW.fderivWithin_congr_mono, hVs, hVx,\n    hWs, hWx, hxt, h\u2081]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/VectorField.lean", "context": {"open": ["Set", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "(\ud835\udd5c) in", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\n\u03b1\u271d : Type u_2\nF\u271d\u00b9 : Type u_3\nV : \u03b1\u271d \u2192 F\u271d\u00b9\ns : Set \u03b1\u271d\nx : \u03b1\u271d\nV\u2081 : \u03b1\u271d \u2192 F\u271d\u00b9\nt : Set \u03b1\u271d\nF\u271d : Type u_4\nW W\u2081 : \u03b1\u271d \u2192 F\u271d\nx\u271d : Sort u_5\nlieBracketWithin : x\u271d\nhV : DifferentiableWithinAt \ud835\udd5c V s x\nhVs : EqOn V\u2081 V t\nhVx : V\u2081 x = V x\nhW : DifferentiableWithinAt \ud835\udd5c W s x\nhWs : EqOn W\u2081 W t\nhWx : W\u2081 x = W x\nhxt : UniqueDiffWithinAt \ud835\udd5c t x\nh\u2081 : t \u2286 s\n\u22a2 sorry = sorry"}, {"line": "simp [lieBracketWithin, hV.fderivWithin_congr_mono, hW.fderivWithin_congr_mono, hVs, hVx,\n    hWs, hWx, hxt, h\u2081]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\n\u03b1\u271d : Type u_2\nF\u271d\u00b9 : Type u_3\nV : \u03b1\u271d \u2192 F\u271d\u00b9\ns : Set \u03b1\u271d\nx : \u03b1\u271d\nV\u2081 : \u03b1\u271d \u2192 F\u271d\u00b9\nt : Set \u03b1\u271d\nF\u271d : Type u_4\nW W\u2081 : \u03b1\u271d \u2192 F\u271d\nx\u271d : Sort u_5\nlieBracketWithin : x\u271d\nhV : DifferentiableWithinAt \ud835\udd5c V s x\nhVs : EqOn V\u2081 V t\nhVx : V\u2081 x = V x\nhW : DifferentiableWithinAt \ud835\udd5c W s x\nhWs : EqOn W\u2081 W t\nhWx : W\u2081 x = W x\nhxt : UniqueDiffWithinAt \ud835\udd5c t x\nh\u2081 : t \u2286 s\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma leibniz_identity_lieBracketWithin (hn : minSmoothness \ud835\udd5c 2 \u2264 n)\n    {U V W : E \u2192 E} {s : Set E} {x : E}\n    (hs : UniqueDiffOn \ud835\udd5c s) (h'x : x \u2208 closure (interior s)) (hx : x \u2208 s)\n    (hU : ContDiffWithinAt \ud835\udd5c n U s x) (hV : ContDiffWithinAt \ud835\udd5c n V s x)\n    (hW : ContDiffWithinAt \ud835\udd5c n W s x) :\n    lieBracketWithin \ud835\udd5c U (lieBracketWithin \ud835\udd5c V W s) s x =\n      lieBracketWithin \ud835\udd5c (lieBracketWithin \ud835\udd5c U V s) W s x\n      + lieBracketWithin \ud835\udd5c V (lieBracketWithin \ud835\udd5c U W s) s x := by\n  apply leibniz_identity_lieBracketWithin_of_isSymmSndFDerivWithinAt hs hx\n    (hU.of_le (le_minSmoothness.trans hn)) (hV.of_le (le_minSmoothness.trans hn))\n    (hW.of_le (le_minSmoothness.trans hn))\n  \u00b7 exact hU.isSymmSndFDerivWithinAt hn hs h'x hx\n  \u00b7 exact hV.isSymmSndFDerivWithinAt hn hs h'x hx\n  \u00b7 exact hW.isSymmSndFDerivWithinAt hn hs h'x hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/VectorField.lean", "context": {"open": ["Set", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "(\ud835\udd5c) in", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nn : WithTop \u2115\u221e\nE : Type u_2\nx\u271d : Sort u_3\nlieBracketWithin : x\u271d\nhn : minSmoothness \ud835\udd5c 2 \u2264 n\nU V W : E \u2192 E\ns : Set E\nx : E\nhs : sorry\nh'x : x \u2208 sorry\nhx : x \u2208 s\nhU : sorry\nhV : sorry\nhW : sorry\n\u22a2 sorry = sorry + sorry"}, {"line": "apply leibniz_identity_lieBracketWithin_of_isSymmSndFDerivWithinAt hs hx\n    (hU.of_le (le_minSmoothness.trans hn)) (hV.of_le (le_minSmoothness.trans hn))\n    (hW.of_le (le_minSmoothness.trans hn))", "tactic_state": "\u22a2 (\ud835\udd5c : Type u_1) \u2192\n    [inst : NontriviallyNormedField \ud835\udd5c] \u2192\n      {n : WithTop \u2115\u221e} \u2192\n        {E : Type u_2} \u2192\n          {lieBracketWithin : ?m.7654 \ud835\udd5c} \u2192\n            minSmoothness \ud835\udd5c 2 \u2264 n \u2192\n              {U V W : E \u2192 E} \u2192 {s : Set E} \u2192 {x : E} \u2192 sorry \u2192 x \u2208 sorry \u2192 x \u2208 s \u2192 sorry \u2192 sorry \u2192 sorry \u2192 Type u_4\n---\n\u22a2 (\ud835\udd5c : Type u_1) \u2192\n    [inst : NontriviallyNormedField \ud835\udd5c] \u2192\n      {n : WithTop \u2115\u221e} \u2192\n        {E : Type u_2} \u2192\n          {lieBracketWithin : ?m.7654 \ud835\udd5c} \u2192\n            minSmoothness \ud835\udd5c 2 \u2264 n \u2192\n              {U V W : E \u2192 E} \u2192 {s : Set E} \u2192 {x : E} \u2192 sorry \u2192 x \u2208 sorry \u2192 x \u2208 s \u2192 sorry \u2192 sorry \u2192 sorry \u2192 Type u_5\n---\n\u22a2 (\ud835\udd5c : Type u_1) \u2192\n    [inst : NontriviallyNormedField \ud835\udd5c] \u2192\n      {n : WithTop \u2115\u221e} \u2192\n        {E : Type u_2} \u2192\n          {lieBracketWithin : ?m.7654 \ud835\udd5c} \u2192\n            minSmoothness \ud835\udd5c 2 \u2264 n \u2192\n              {U V W : E \u2192 E} \u2192 {s : Set E} \u2192 {x : E} \u2192 sorry \u2192 x \u2208 sorry \u2192 x \u2208 s \u2192 sorry \u2192 sorry \u2192 sorry \u2192 Type u_6\n---\n\u22a2 (\ud835\udd5c : Type u_1) \u2192\n    [inst : NontriviallyNormedField \ud835\udd5c] \u2192\n      {n : WithTop \u2115\u221e} \u2192\n        {E : Type u_2} \u2192\n          {lieBracketWithin : ?m.7654 \ud835\udd5c} \u2192\n            (hn : minSmoothness \ud835\udd5c 2 \u2264 n) \u2192\n              {U V W : E \u2192 E} \u2192\n                {s : Set E} \u2192\n                  {x : E} \u2192\n                    (hs : sorry) \u2192\n                      (h'x : x \u2208 sorry) \u2192\n                        (hx : x \u2208 s) \u2192\n                          (hU : sorry) \u2192\n                            (hV : sorry) \u2192\n                              (hW : sorry) \u2192\n                                HAdd (?m.7656 \ud835\udd5c hn hs h'x hx hU hV hW) (?m.7657 \ud835\udd5c hn hs h'x hx hU hV hW)\n                                  (?m.7655 \ud835\udd5c hn hs h'x hx hU hV hW)"}, {"line": "\u00b7 exact hU.isSymmSndFDerivWithinAt hn hs h'x hx", "tactic_state": "\u22a2 (\ud835\udd5c : Type u_1) \u2192\n    [inst : NontriviallyNormedField \ud835\udd5c] \u2192\n      {n : WithTop \u2115\u221e} \u2192\n        {E : Type u_2} \u2192\n          {lieBracketWithin : ?m.7728 \ud835\udd5c} \u2192\n            minSmoothness \ud835\udd5c 2 \u2264 n \u2192\n              {U V W : E \u2192 E} \u2192 {s : Set E} \u2192 {x : E} \u2192 sorry \u2192 x \u2208 sorry \u2192 x \u2208 s \u2192 sorry \u2192 sorry \u2192 sorry \u2192 Type u_5\n---\n\u22a2 (\ud835\udd5c : Type u_1) \u2192\n    [inst : NontriviallyNormedField \ud835\udd5c] \u2192\n      {n : WithTop \u2115\u221e} \u2192\n        {E : Type u_2} \u2192\n          {lieBracketWithin : ?m.7728 \ud835\udd5c} \u2192\n            minSmoothness \ud835\udd5c 2 \u2264 n \u2192\n              {U V W : E \u2192 E} \u2192 {s : Set E} \u2192 {x : E} \u2192 sorry \u2192 x \u2208 sorry \u2192 x \u2208 s \u2192 sorry \u2192 sorry \u2192 sorry \u2192 Type u_6\n---\n\u22a2 (\ud835\udd5c : Type u_1) \u2192\n    [inst : NontriviallyNormedField \ud835\udd5c] \u2192\n      {n : WithTop \u2115\u221e} \u2192\n        {E : Type u_2} \u2192\n          {lieBracketWithin : ?m.7728 \ud835\udd5c} \u2192\n            (hn : minSmoothness \ud835\udd5c 2 \u2264 n) \u2192\n              {U V W : E \u2192 E} \u2192\n                {s : Set E} \u2192\n                  {x : E} \u2192\n                    (hs : sorry) \u2192\n                      (h'x : x \u2208 sorry) \u2192\n                        (hx : x \u2208 s) \u2192\n                          (hU : sorry) \u2192\n                            (hV : sorry) \u2192\n                              (hW : sorry) \u2192\n                                HAdd (?m.7656 \ud835\udd5c hn hs h'x hx hU hV hW) (?m.7657 \ud835\udd5c hn hs h'x hx hU hV hW)\n                                  (sorry \ud835\udd5c hn hs h'x hx hU hV hW)"}, {"line": "\u00b7 exact hV.isSymmSndFDerivWithinAt hn hs h'x hx", "tactic_state": "\u22a2 (\ud835\udd5c : Type u_1) \u2192\n    [inst : NontriviallyNormedField \ud835\udd5c] \u2192\n      {n : WithTop \u2115\u221e} \u2192\n        {E : Type u_2} \u2192\n          {lieBracketWithin : ?m.7728 \ud835\udd5c} \u2192\n            minSmoothness \ud835\udd5c 2 \u2264 n \u2192\n              {U V W : E \u2192 E} \u2192 {s : Set E} \u2192 {x : E} \u2192 sorry \u2192 x \u2208 sorry \u2192 x \u2208 s \u2192 sorry \u2192 sorry \u2192 sorry \u2192 Type u_6\n---\n\u22a2 (\ud835\udd5c : Type u_1) \u2192\n    [inst : NontriviallyNormedField \ud835\udd5c] \u2192\n      {n : WithTop \u2115\u221e} \u2192\n        {E : Type u_2} \u2192\n          {lieBracketWithin : ?m.7728 \ud835\udd5c} \u2192\n            (hn : minSmoothness \ud835\udd5c 2 \u2264 n) \u2192\n              {U V W : E \u2192 E} \u2192\n                {s : Set E} \u2192\n                  {x : E} \u2192\n                    (hs : sorry) \u2192\n                      (h'x : x \u2208 sorry) \u2192\n                        (hx : x \u2208 s) \u2192\n                          (hU : sorry) \u2192\n                            (hV : sorry) \u2192\n                              (hW : sorry) \u2192\n                                HAdd (sorry \ud835\udd5c hn hs h'x hx hU hV hW) (?m.7657 \ud835\udd5c hn hs h'x hx hU hV hW)\n                                  (sorry \ud835\udd5c hn hs h'x hx hU hV hW)"}, {"line": "\u00b7 exact hW.isSymmSndFDerivWithinAt hn hs h'x hx", "tactic_state": "\u22a2 (\ud835\udd5c : Type u_1) \u2192\n    [inst : NontriviallyNormedField \ud835\udd5c] \u2192\n      {n : WithTop \u2115\u221e} \u2192\n        {E : Type u_2} \u2192\n          {lieBracketWithin : ?m.7728 \ud835\udd5c} \u2192\n            (hn : minSmoothness \ud835\udd5c 2 \u2264 n) \u2192\n              {U V W : E \u2192 E} \u2192\n                {s : Set E} \u2192\n                  {x : E} \u2192\n                    (hs : sorry) \u2192\n                      (h'x : x \u2208 sorry) \u2192\n                        (hx : x \u2208 s) \u2192\n                          (hU : sorry) \u2192\n                            (hV : sorry) \u2192\n                              (hW : sorry) \u2192\n                                HAdd (sorry \ud835\udd5c hn hs h'x hx hU hV hW) (sorry \ud835\udd5c hn hs h'x hx hU hV hW)\n                                  (sorry \ud835\udd5c hn hs h'x hx hU hV hW)"}]}
{"declaration": "lemma pullback_eq_of_fderiv_eq\n    {f : E \u2192 F} {M : E \u2243L[\ud835\udd5c] F} {x : E} (hf : M = fderiv \ud835\udd5c f x) (V : F \u2192 F) :\n    pullback \ud835\udd5c f V x = M.symm (V (f x)) := by\n  simp [pullback, \u2190 hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/VectorField.lean", "context": {"open": ["Set", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "(\ud835\udd5c) in", "(\ud835\udd5c) in", "(\ud835\udd5c) in", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\nF : Type u_3\nx\u271d : Sort u_4\npullback : x\u271d\nf : E \u2192 F\nM : sorry\nx : E\nhf : M = sorry\nV : F \u2192 F\n\u22a2 sorry = sorry"}, {"line": "simp [pullback, \u2190 hf]", "tactic_state": "E : Type u_2\nF : Type u_3\nx\u271d : Sort u_4\npullback : x\u271d\nf : E \u2192 F\nM : sorry\nx : E\nhf : M = sorry\nV : F \u2192 F\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma pullback_eq_of_not_isInvertible {f : E \u2192 F} {x : E}\n    (h : \u00ac(fderiv \ud835\udd5c f x).IsInvertible) (V : F \u2192 F) :\n    pullback \ud835\udd5c f V x = 0 := by\n  simp [pullback, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/VectorField.lean", "context": {"open": ["Set", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "(\ud835\udd5c) in", "(\ud835\udd5c) in", "(\ud835\udd5c) in", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\nF : Type u_3\nx\u271d : Sort u_4\npullback : x\u271d\nf : E \u2192 F\nx : E\nh : \u00acsorry\nV : F \u2192 F\n\u22a2 sorry = 0"}, {"line": "simp [pullback, h]", "tactic_state": "E : Type u_2\nF : Type u_3\nx\u271d : Sort u_4\npullback : x\u271d\nf : E \u2192 F\nx : E\nh : \u00acsorry\nV : F \u2192 F\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma pullbackWithin_eq_of_not_isInvertible {f : E \u2192 F} {x : E}\n    (h : \u00ac(fderivWithin \ud835\udd5c f s x).IsInvertible) (V : F \u2192 F) :\n    pullbackWithin \ud835\udd5c f V s x = 0 := by\n  simp [pullbackWithin, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/VectorField.lean", "context": {"open": ["Set", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "(\ud835\udd5c) in", "(\ud835\udd5c) in", "(\ud835\udd5c) in", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\nF : Type u_3\ns : Set E\nx\u271d : Sort u_4\npullbackWithin : x\u271d\nf : E \u2192 F\nx : E\nh : \u00acsorry\nV : F \u2192 F\n\u22a2 sorry = 0"}, {"line": "simp [pullbackWithin, h]", "tactic_state": "E : Type u_2\nF : Type u_3\ns : Set E\nx\u271d : Sort u_4\npullbackWithin : x\u271d\nf : E \u2192 F\nx : E\nh : \u00acsorry\nV : F \u2192 F\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma pullbackWithin_eq_of_fderivWithin_eq\n    {f : E \u2192 F} {M : E \u2243L[\ud835\udd5c] F} {x : E} (hf : M = fderivWithin \ud835\udd5c f s x) (V : F \u2192 F) :\n    pullbackWithin \ud835\udd5c f V s x = M.symm (V (f x)) := by\n  simp [pullbackWithin, \u2190 hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/VectorField.lean", "context": {"open": ["Set", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "(\ud835\udd5c) in", "(\ud835\udd5c) in", "(\ud835\udd5c) in", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\nF : Type u_3\ns : Set E\nx\u271d : Sort u_4\npullbackWithin : x\u271d\nf : E \u2192 F\nM : sorry\nx : E\nhf : M = sorry\nV : F \u2192 F\n\u22a2 sorry = sorry"}, {"line": "simp [pullbackWithin, \u2190 hf]", "tactic_state": "E : Type u_2\nF : Type u_3\ns : Set E\nx\u271d : Sort u_4\npullbackWithin : x\u271d\nf : E \u2192 F\nM : sorry\nx : E\nhf : M = sorry\nV : F \u2192 F\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem Continuous.exists_contDiff_dist_le_of_forall_mem_ball_dist_le (hf : Continuous f)\n    (h\u03b5 : 0 < \u03b5) :\n    \u2203 g : E \u2192 F, ContDiff \u211d \u221e g \u2227 \u2200 a, \u2200 \u03b4, (\u2200 x \u2208 ball a \u03b5, dist (f x) (f a) \u2264 \u03b4) \u2192\n      dist (g a) (f a) \u2264 \u03b4 := by\n  borelize E\n  exact (hf.locallyIntegrable (\u03bc := .addHaar)).exists_contDiff_dist_le_of_forall_mem_ball_dist_le h\u03b5\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/BumpFunction/SmoothApprox.lean", "context": {"open": ["scoped ContDiff unitInterval Topology", "Function Set Metric MeasureTheory"], "variables": ["{E F : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\nF : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nf : E \u2192 F\n\u03b5 : \u211d\nhf : Continuous f\nh\u03b5 : 0 < \u03b5\n\u22a2 \u2203 g, sorry \u2227 \u2200 (a : E) (\u03b4 : \u211d), (\u2200 x \u2208 ball a \u03b5, dist (f x) (f a) \u2264 \u03b4) \u2192 sorry \u2264 \u03b4"}, {"line": "borelize E", "tactic_state": "E : Type u_1\nF : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nf : E \u2192 F\n\u03b5 : \u211d\nhf : Continuous f\nh\u03b5 : 0 < \u03b5\nthis\u271d\u00b9 : MeasurableSpace E := sorry\nthis\u271d : sorry\n\u22a2 \u2203 g, sorry \u2227 \u2200 (a : E) (\u03b4 : \u211d), (\u2200 x \u2208 ball a \u03b5, dist (f x) (f a) \u2264 \u03b4) \u2192 sorry \u2264 \u03b4"}, {"line": "exact (hf.locallyIntegrable (\u03bc := .addHaar)).exists_contDiff_dist_le_of_forall_mem_ball_dist_le h\u03b5", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_rOut_div_rIn {c : E} (f : ContDiffBump c) : 1 < f.rOut / f.rIn := by\n  rw [one_lt_div f.rIn_pos]\n  exact f.rIn_lt_rOut\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/BumpFunction/Basic.lean", "context": {"open": ["Function Set Filter", "scoped Topology Filter ContDiff"], "variables": ["{E X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\nc : E\nf : ContDiffBump c\n\u22a2 1 < f.rOut / f.rIn"}, {"line": "rw [one_lt_div f.rIn_pos]", "tactic_state": "E : Type u_1\nc : E\nf : ContDiffBump c\n\u22a2 f.rIn < f.rOut"}, {"line": "exact f.rIn_lt_rOut", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.ContDiff.contDiffBump {c g : X \u2192 E} {f : \u2200 x, ContDiffBump (c x)}\n    (hc : ContDiff \u211d n c) (hr : ContDiff \u211d n fun x => (f x).rIn)\n    (hR : ContDiff \u211d n fun x => (f x).rOut) (hg : ContDiff \u211d n g) :\n    ContDiff \u211d n fun x => f x (g x) := by\n  rw [contDiff_iff_contDiffAt] at *\n  exact fun x => (hc x).contDiffBump (hr x) (hR x) (hg x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/BumpFunction/Basic.lean", "context": {"open": ["Function Set Filter", "scoped Topology Filter ContDiff", "Metric"], "variables": ["{E X : Type*}", "[NormedAddCommGroup E] [NormedSpace \u211d E] [NormedAddCommGroup X] [NormedSpace \u211d X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\nX : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \u211d X\nn : WithTop \u2115\u221e\nc g : X \u2192 E\nf : (x : X) \u2192 ContDiffBump (c x)\nhc : ContDiff \u211d n c\nhr : ContDiff \u211d n fun x => (f x).rIn\nhR : ContDiff \u211d n fun x => (f x).rOut\nhg : ContDiff \u211d n g\n\u22a2 ContDiff \u211d n fun x => sorry"}, {"line": "rw [contDiff_iff_contDiffAt] at *", "tactic_state": "E : Type u_1\nX : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \u211d X\nn : WithTop \u2115\u221e\nc g : X \u2192 E\nf : (x : X) \u2192 ContDiffBump (c x)\nhc\u271d : ContDiff \u211d n c\nhc : \u2200 (x : X), ContDiffAt \u211d n c x\nhr\u271d : ContDiff \u211d n fun x => (f x).rIn\nhr : \u2200 (x : X), ContDiffAt \u211d n (fun x => (f x).rIn) x\nhR\u271d : ContDiff \u211d n fun x => (f x).rOut\nhR : \u2200 (x : X), ContDiffAt \u211d n (fun x => (f x).rOut) x\nhg\u271d : ContDiff \u211d n g\nhg : \u2200 (x : X), ContDiffAt \u211d n g x\n\u22a2 \u2200 (x : X), ContDiffAt \u211d n (fun x => sorry) x\n---\n\u22a2 {E : Type u_1} \u2192\n    {X : Type u_2} \u2192\n      [inst : NormedAddCommGroup E] \u2192\n        [inst_1 : NormedSpace \u211d E] \u2192\n          [inst_2 : NormedAddCommGroup X] \u2192\n            [inst_3 : NormedSpace \u211d X] \u2192\n              {n : WithTop \u2115\u221e} \u2192\n                {c g : X \u2192 E} \u2192\n                  {f : (x : X) \u2192 ContDiffBump (c x)} \u2192\n                    ContDiff \u211d n c \u2192\n                      (ContDiff \u211d n fun x => (f x).rIn) \u2192 (ContDiff \u211d n fun x => (f x).rOut) \u2192 ContDiff \u211d n g \u2192 Type u_3\n---\n\u22a2 {E : Type u_1} \u2192\n    {X : Type u_2} \u2192\n      [inst : NormedAddCommGroup E] \u2192\n        [inst_1 : NormedSpace \u211d E] \u2192\n          [inst_2 : NormedAddCommGroup X] \u2192\n            [inst_3 : NormedSpace \u211d X] \u2192\n              {n : WithTop \u2115\u221e} \u2192\n                {c g : X \u2192 E} \u2192\n                  {f : (x : X) \u2192 ContDiffBump (c x)} \u2192\n                    (hc : ContDiff \u211d n c) \u2192\n                      (hr : ContDiff \u211d n fun x => (f x).rIn) \u2192\n                        (hR : ContDiff \u211d n fun x => (f x).rOut) \u2192\n                          (hg : ContDiff \u211d n g) \u2192 NormedAddCommGroup (?m.4623 hc hr hR hg)\n---\n\u22a2 {E : Type u_1} \u2192\n    {X : Type u_2} \u2192\n      [inst : NormedAddCommGroup E] \u2192\n        [inst_1 : NormedSpace \u211d E] \u2192\n          [inst_2 : NormedAddCommGroup X] \u2192\n            [inst_3 : NormedSpace \u211d X] \u2192\n              {n : WithTop \u2115\u221e} \u2192\n                {c g : X \u2192 E} \u2192\n                  {f : (x : X) \u2192 ContDiffBump (c x)} \u2192\n                    (hc : ContDiff \u211d n c) \u2192\n                      (hr : ContDiff \u211d n fun x => (f x).rIn) \u2192\n                        (hR : ContDiff \u211d n fun x => (f x).rOut) \u2192\n                          (hg : ContDiff \u211d n g) \u2192 NormedSpace \u211d (?m.4623 hc hr hR hg)"}, {"line": "exact fun x => (hc x).contDiffBump (hr x) (hR x) (hg x)", "tactic_state": "\u22a2 {E : Type u_1} \u2192\n    {X : Type u_2} \u2192\n      [inst : NormedAddCommGroup E] \u2192\n        [inst_1 : NormedSpace \u211d E] \u2192\n          [inst_2 : NormedAddCommGroup X] \u2192\n            [inst_3 : NormedSpace \u211d X] \u2192\n              {n : WithTop \u2115\u221e} \u2192\n                {c g : X \u2192 E} \u2192\n                  {f : (x : X) \u2192 ContDiffBump (c x)} \u2192\n                    ContDiff \u211d n c \u2192\n                      (ContDiff \u211d n fun x => (f x).rIn) \u2192 (ContDiff \u211d n fun x => (f x).rOut) \u2192 ContDiff \u211d n g \u2192 Type u_3\n---\n\u22a2 {E : Type u_1} \u2192\n    {X : Type u_2} \u2192\n      [inst : NormedAddCommGroup E] \u2192\n        [inst_1 : NormedSpace \u211d E] \u2192\n          [inst_2 : NormedAddCommGroup X] \u2192\n            [inst_3 : NormedSpace \u211d X] \u2192\n              {n : WithTop \u2115\u221e} \u2192\n                {c g : X \u2192 E} \u2192\n                  {f : (x : X) \u2192 ContDiffBump (c x)} \u2192\n                    (hc : ContDiff \u211d n c) \u2192\n                      (hr : ContDiff \u211d n fun x => (f x).rIn) \u2192\n                        (hR : ContDiff \u211d n fun x => (f x).rOut) \u2192\n                          (hg : ContDiff \u211d n g) \u2192 NormedAddCommGroup (?m.4623 hc hr hR hg)\n---\n\u22a2 {E : Type u_1} \u2192\n    {X : Type u_2} \u2192\n      [inst : NormedAddCommGroup E] \u2192\n        [inst_1 : NormedSpace \u211d E] \u2192\n          [inst_2 : NormedAddCommGroup X] \u2192\n            [inst_3 : NormedSpace \u211d X] \u2192\n              {n : WithTop \u2115\u221e} \u2192\n                {c g : X \u2192 E} \u2192\n                  {f : (x : X) \u2192 ContDiffBump (c x)} \u2192\n                    (hc : ContDiff \u211d n c) \u2192\n                      (hr : ContDiff \u211d n fun x => (f x).rIn) \u2192\n                        (hR : ContDiff \u211d n fun x => (f x).rOut) \u2192\n                          (hg : ContDiff \u211d n g) \u2192 NormedSpace \u211d (?m.4623 hc hr hR hg)"}]}
{"declaration": "theorem conformalAt_iff' {f : E \u2192 F} {x : E} : ConformalAt f x \u2194\n    \u2203 c : \u211d, 0 < c \u2227 \u2200 u v : E, \u27eafderiv \u211d f x u, fderiv \u211d f x v\u27eb = c * \u27eau, v\u27eb := by\n  rw [conformalAt_iff_isConformalMap_fderiv]\n  rw [isConformalMap_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Conformal/InnerProduct.lean", "context": {"open": ["RealInnerProductSpace"], "variables": ["{E F : Type*}", "[NormedAddCommGroup E] [NormedAddCommGroup F]", "[InnerProductSpace \u211d E] [InnerProductSpace \u211d F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : InnerProductSpace \u211d F\nf : E \u2192 F\nx : E\n\u22a2 ConformalAt f x \u2194 \u2203 c, 0 < c \u2227 \u2200 (u v : E), inner ((fderiv \u211d f x) u) ((fderiv \u211d f x) v) = c * inner u v"}, {"line": "rw [conformalAt_iff_isConformalMap_fderiv]", "tactic_state": "E : Type u_1\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : InnerProductSpace \u211d F\nf : E \u2192 F\nx : E\n\u22a2 IsConformalMap (fderiv \u211d f x) \u2194 \u2203 c, 0 < c \u2227 \u2200 (u v : E), inner ((fderiv \u211d f x) u) ((fderiv \u211d f x) v) = c * inner u v"}, {"line": "rw [isConformalMap_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContDiffOn.continuousOn_derivWithin (h : ContDiffOn \ud835\udd5c n f\u2082 s\u2082) (hs : UniqueDiffOn \ud835\udd5c s\u2082)\n    (hn : 1 \u2264 n) : ContinuousOn (derivWithin f\u2082 s\u2082) s\u2082 := by\n  rw [show (1 : WithTop \u2115\u221e) = 0 + 1 from rfl] at hn\n  exact ((contDiffOn_succ_iff_derivWithin hs).1 (h.of_le hn)).2.2.continuousOn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "context": {"open": ["scoped NNReal Nat ContDiff", "Set Fin Filter Function", "scoped Topology", "ContinuousLinearMap (smulRight)"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E\u2081 E\u2082 E\u2083 : Type*}", "[NormedAddCommGroup E\u2081] [NormedAddCommGroup E\u2082] [NormedAddCommGroup E\u2083]", "{f\u2082 : \ud835\udd5c \u2192 F} {s\u2082 : Set \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\ns\u2082 : Set \ud835\udd5c\nn : WithTop \u2115\u221e\nh : sorry\nhs : UniqueDiffOn \ud835\udd5c s\u2082\nhn : 1 \u2264 n\n\u22a2 sorry"}, {"line": "rw [show (1 : WithTop \u2115\u221e) = 0 + 1 from rfl] at hn", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\ns\u2082 : Set \ud835\udd5c\nn : WithTop \u2115\u221e\nh : sorry\nhs : UniqueDiffOn \ud835\udd5c s\u2082\nhn : 0 + 1 \u2264 n\n\u22a2 sorry"}, {"line": "exact ((contDiffOn_succ_iff_derivWithin hs).1 (h.of_le hn)).2.2.continuousOn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContDiffOn.continuousOn_deriv_of_isOpen (h : ContDiffOn \ud835\udd5c n f\u2082 s\u2082) (hs : IsOpen s\u2082)\n    (hn : 1 \u2264 n) : ContinuousOn (deriv f\u2082) s\u2082 := by\n  rw [show (1 : WithTop \u2115\u221e) = 0 + 1 from rfl] at hn\n  exact ((contDiffOn_succ_iff_deriv_of_isOpen hs).1 (h.of_le hn)).2.2.continuousOn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "context": {"open": ["scoped NNReal Nat ContDiff", "Set Fin Filter Function", "scoped Topology", "ContinuousLinearMap (smulRight)"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E\u2081 E\u2082 E\u2083 : Type*}", "[NormedAddCommGroup E\u2081] [NormedAddCommGroup E\u2082] [NormedAddCommGroup E\u2083]", "{f\u2082 : \ud835\udd5c \u2192 F} {s\u2082 : Set \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\ns\u2082 : Set \ud835\udd5c\nn : WithTop \u2115\u221e\nh : sorry\nhs : IsOpen s\u2082\nhn : 1 \u2264 n\n\u22a2 sorry"}, {"line": "rw [show (1 : WithTop \u2115\u221e) = 0 + 1 from rfl] at hn", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\ns\u2082 : Set \ud835\udd5c\nn : WithTop \u2115\u221e\nh : sorry\nhs : IsOpen s\u2082\nhn : 0 + 1 \u2264 n\n\u22a2 sorry"}, {"line": "exact ((contDiffOn_succ_iff_deriv_of_isOpen hs).1 (h.of_le hn)).2.2.continuousOn", "tactic_state": "No Goals!"}]}
