{"declaration": "example (a b: Nat) (h1: a + b = a): a + b = a := by\n  exact h1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/test.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh1 : a + b = a\n\u22a2 a + b = a"}, {"line": "  exact h1", "tactic_state": ""}]}
{"declaration": "theorem not_irrational_rpow :\n   \u00ac \u2200 a b : \u211d, Irrational a \u2192 Irrational b \u2192 0 < a \u2192 Irrational (a ^ b) := by\n  push_neg\n  by_cases hc : Irrational (\u221a2 ^ \u221a2)\n  \u00b7 use (\u221a2 ^ \u221a2), \u221a2, hc, irrational_sqrt_two, by positivity\n    rw [\u2190 rpow_mul, mul_self_sqrt, rpow_two, sq_sqrt] <;> norm_num\n  \u00b7 use \u221a2, \u221a2, irrational_sqrt_two, irrational_sqrt_two, by positivity, hc\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Counterexamples/IrrationalPowerOfIrrational.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00ac\u2200 (a b : \u211d), Irrational a \u2192 Irrational b \u2192 0 < a \u2192 Irrational (a ^ b)"}, {"line": "  push_neg", "tactic_state": "\u22a2 \u2203 a b, Irrational a \u2227 Irrational b \u2227 0 < a \u2227 \u00acIrrational (a ^ b)"}, {"line": "  by_cases hc : Irrational (\u221a2 ^ \u221a2)", "tactic_state": "case pos\nhc : Irrational (\u221a2 ^ \u221a2)\n\u22a2 \u2203 a b, Irrational a \u2227 Irrational b \u2227 0 < a \u2227 \u00acIrrational (a ^ b)\n---\ncase neg\nhc : \u00acIrrational (\u221a2 ^ \u221a2)\n\u22a2 \u2203 a b, Irrational a \u2227 Irrational b \u2227 0 < a \u2227 \u00acIrrational (a ^ b)"}, {"line": "  \u00b7 use (\u221a2 ^ \u221a2), \u221a2, hc, irrational_sqrt_two, by positivity", "tactic_state": "case right\nhc : Irrational (\u221a2 ^ \u221a2)\n\u22a2 \u00acIrrational ((\u221a2 ^ \u221a2) ^ \u221a2)"}, {"line": "    rw [\u2190 rpow_mul, mul_self_sqrt, rpow_two, sq_sqrt] <;> norm_num", "tactic_state": ""}, {"line": "  \u00b7 use \u221a2, \u221a2, irrational_sqrt_two, irrational_sqrt_two, by positivity, hc", "tactic_state": ""}]}
{"declaration": "theorem euclid (n : \u2115) : \u2203 N, n < N \u2227 N.Prime := by\n  let N := n.factorial + 1\n  let p := minFac N\n  use p\n  have prime : p.Prime := by\n    apply minFac_prime\n    observe : n.factorial > 0\n    omega\n  constructor\n  \u00b7 by_contra!\n    observe : p \u2223 n.factorial\n    observe : p \u2223 N\n    observe : p \u2223 1\n    observe : \u00ac p \u2223 1\n    contradiction\n  \u00b7 exact prime", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/observe.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2203 N, n < N \u2227 Nat.Prime N"}, {"line": "  let N := n.factorial + 1", "tactic_state": "n : \u2115\nN : \u2115 := n ! + 1\n\u22a2 \u2203 N, n < N \u2227 Nat.Prime N"}, {"line": "  let p := minFac N", "tactic_state": "n : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\n\u22a2 \u2203 N, n < N \u2227 Nat.Prime N"}, {"line": "  use p", "tactic_state": "case h\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\n\u22a2 n < p \u2227 Nat.Prime p"}, {"line": "  have prime : p.Prime := by", "tactic_state": "case h\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\nprime : Nat.Prime p\n\u22a2 n < p \u2227 Nat.Prime p"}, {"line": "    apply minFac_prime", "tactic_state": "case h.left\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\nprime : Nat.Prime p\n\u22a2 n < p\n---\ncase h.right\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\nprime : Nat.Prime p\n\u22a2 Nat.Prime p"}, {"line": "    observe : n.factorial > 0", "tactic_state": "case h.left\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\nprime : Nat.Prime p\nthis : p \u2264 n\n\u22a2 False"}, {"line": "    omega", "tactic_state": "case h.left\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\nprime : Nat.Prime p\nthis\u271d : p \u2264 n\nthis : p \u2223 n !\n\u22a2 False"}, {"line": "  constructor", "tactic_state": "case h.left\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\nprime : Nat.Prime p\nthis\u271d\u00b9 : p \u2264 n\nthis\u271d : p \u2223 n !\nthis : N.minFac \u2223 N\n\u22a2 False"}, {"line": "  \u00b7 by_contra!", "tactic_state": "case h.left\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\nprime : Nat.Prime p\nthis\u271d\u00b2 : p \u2264 n\nthis\u271d\u00b9 : p \u2223 n !\nthis\u271d : N.minFac \u2223 N\nthis : p \u2223 1\n\u22a2 False"}, {"line": "    observe : p \u2223 n.factorial", "tactic_state": "case h.left\nn : \u2115\nN : \u2115 := n ! + 1\np : \u2115 := N.minFac\nprime : Nat.Prime p\nthis\u271d\u00b3 : p \u2264 n\nthis\u271d\u00b2 : p \u2223 n !\nthis\u271d\u00b9 : N.minFac \u2223 N\nthis\u271d : p \u2223 1\nthis : \u00acp \u2223 1\n\u22a2 False"}, {"line": "    observe : p \u2223 N", "tactic_state": ""}, {"line": "    observe : p \u2223 1", "tactic_state": ""}]}
{"declaration": "example : \u2203 x : Nat, x = x := by use 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}]}
{"declaration": "example : \u2203 x : Nat, x = x := by use 42, rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}]}
{"declaration": "example : \u2203 x : Nat, x = x := by use! 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}]}
{"declaration": "example (h : 42 = y) : \u2203 x : Nat, x = y := by use 42, h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u2115\nh : 42 = y\n\u22a2 \u2203 x, x = y"}]}
{"declaration": "example (h : 42 = y) : \u2203 x : Nat, x = y := by use 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u2115\nh : 42 = y\n\u22a2 \u2203 x, x = y"}]}
{"declaration": "example (n : Fin 3) : \u2203 x : Nat, x = x := show_term by use n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Fin 3\n\u22a2 \u2203 x, x = x"}]}
{"declaration": "example : \u2203 x : Nat, \u2203 y : Nat, x = y := by use 42, 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x y, x = y"}]}
{"declaration": "example : \u2203 p : Nat \u00d7 Nat, p.1 = p.2 := by use 42; sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 p, p.1 = p.2"}]}
{"declaration": "example : \u2203 p : Nat \u00d7 Nat, p.1 = p.2 := by use! 42, 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 p, p.1 = p.2"}]}
{"declaration": "example : \u2203 p : Nat \u00d7 Nat, p.1 = p.2 := by use! (42, 42)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 p, p.1 = p.2"}]}
{"declaration": "example (r : Nat \u2192 Nat \u2192 Prop) (h : \u2200 x, r x x) :\n    \u2203 p : Nat \u00d7 Nat, r p.1 p.2 := by use! 42; use! 42; apply h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115 \u2192 \u2115 \u2192 Prop\nh : \u2200 (x : \u2115), r x x\n\u22a2 \u2203 p, r p.1 p.2"}]}
{"declaration": "example (r : Nat \u2192 Nat \u2192 Prop) (h : \u2200 x, r x x) :\n    \u2203 p : Nat \u00d7 Nat, r p.1 p.2 := by use! 42, 42; apply h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115 \u2192 \u2115 \u2192 Prop\nh : \u2200 (x : \u2115), r x x\n\u22a2 \u2203 p, r p.1 p.2"}]}
{"declaration": "example (r : Nat \u2192 Nat \u2192 Prop) (h : \u2200 x, r x x) :\n    \u2203 p : Nat \u00d7 Nat, r p.1 p.2 := by use! 42, 42, h _\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115 \u2192 \u2115 \u2192 Prop\nh : \u2200 (x : \u2115), r x x\n\u22a2 \u2203 p, r p.1 p.2"}]}
{"declaration": "example : \u2203 x : String \u00d7 String, x.1 = x.2 := by use (\"a\", \"a\")\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x.1 = x.2"}]}
{"declaration": "example : \u2203 x : String \u00d7 String, x.1 = x.2 := by use! \"a\", \"a\"\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x.1 = x.2"}]}
{"declaration": "example : \u2203 x : Nat, x = x := by\n  use ?_\n  exact 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}, {"line": "  use ?_", "tactic_state": "case w\n\u22a2 \u2115"}, {"line": "  exact 42", "tactic_state": ""}]}
{"declaration": "example (\u03b1 : Type) : \u2203 S : List \u03b1, S = S := by use \u2205\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\n\u22a2 \u2203 S, S = S"}]}
{"declaration": "example : \u2203 x : Int, x = x := by use 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}]}
{"declaration": "example : \u2203 a b c : Int, a + b + c = 6 := by\n  use 1, 2, 3\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 a b c, a + b + c = 6"}, {"line": "  use 1, 2, 3", "tactic_state": "case h\n\u22a2 1 + 2 + 3 = 6"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : \u2203 p : Int \u00d7 Int, p.1 = 1 := by use \u27e81, 42\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 p, p.1 = 1"}]}
{"declaration": "example : \u2203 p : Int \u00d7 Int, p.1 = 1 := by use! 1, 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 p, p.1 = 1"}]}
{"declaration": "example : \u2203 n : Int, n * 3 = 3 * 2 := by\n  use 2\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 n, n * 3 = 3 * 2"}, {"line": "  use 2", "tactic_state": "case h\n\u22a2 2 * 3 = 3 * 2"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : \u03a3 _x _y : Int, Int \u00d7 Int \u00d7 Int := by\n  use 1, 2, 3, 4, 5\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (_ : \u2124) \u00d7 (_ : \u2124) \u00d7 \u2124 \u00d7 \u2124 \u00d7 \u2124"}, {"line": "  use 1, 2, 3, 4, 5", "tactic_state": ""}]}
{"declaration": "example : \u03a3 _x _y : Int, (Int \u00d7 Int) \u00d7 Int := by\n  use! 1, 2, 3, 4, 5\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (_ : \u2124) \u00d7 (_ : \u2124) \u00d7 (\u2124 \u00d7 \u2124) \u00d7 \u2124"}, {"line": "  use! 1, 2, 3, 4, 5", "tactic_state": ""}]}
{"declaration": "example : Option Nat := by use 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Option \u2115"}]}
{"declaration": "example : Nat \u2192 Nat := by use 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2115 \u2192 \u2115"}]}
{"declaration": "example : foo := by\n  use 100, \u27e8true, 4\u27e9, 3\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "foo : Sort ?u.5\n\u22a2 foo"}, {"line": "  use 100, \u27e8true, 4\u27e9, 3", "tactic_state": ""}]}
{"declaration": "example : foo := by\n  use! 100, true, 4, 3\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "foo : Sort ?u.5\n\u22a2 foo"}, {"line": "  use! 100, true, 4, 3", "tactic_state": ""}]}
{"declaration": "example : foo := show_term by\n  use ?x, \u27e8?b, 4\u27e9\n  exact (3 : Nat)\n  exact (100 : Nat)\n  exact true\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "foo : Sort ?u.5\n\u22a2 foo"}, {"line": "  use ?x, \u27e8?b, 4\u27e9", "tactic_state": ""}]}
{"declaration": "example : foo := show_term by\n  -- Type ascriptions keep refinement from occurring before applying the constructor\n  use! (?x : Nat), (?b : Bool), 4\n  exact (3 : Nat)\n  exact (100 : Nat)\n  exact true\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "foo : Sort ?u.5\n\u22a2 foo"}, {"line": "  -- Type ascriptions keep refinement from occurring before applying the constructor", "tactic_state": ""}]}
{"declaration": "example : \u2203 p : {x : Nat // 0 < x}, 1 < p.1 := by use! 2 <;> decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 p, 1 < \u2191p"}]}
{"declaration": "example : Baz 0 3 := by use _\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort ?u.2\nBaz : x\u271d\n\u22a2 sorry"}]}
{"declaration": "example : Baz 0 3 := by use 3\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort ?u.2\nBaz : x\u271d\n\u22a2 sorry"}]}
{"declaration": "example : Baz 0 3 := by use 4\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort ?u.2\nBaz : x\u271d\n\u22a2 sorry"}]}
{"declaration": "example : Baz 1 3 := by use (3 : Nat)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort ?u.2\nBaz : x\u271d\n\u22a2 sorry"}]}
{"declaration": "example : DecidableType := by\n  use Nat\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "DecidableType : Sort ?u.5\n\u22a2 DecidableType"}, {"line": "  use Nat", "tactic_state": ""}]}
{"declaration": "example (\u03b2 : Type) [DecidableEq \u03b2] : DecidableType := by\n  use \u03b2\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "DecidableType : Sort ?u.27\n\u03b2 : Type\ninst\u271d : DecidableEq \u03b2\n\u22a2 DecidableType"}, {"line": "  use \u03b2", "tactic_state": ""}]}
{"declaration": "example (\u03b2 : Type) : DecidableType := by\n  use \u03b2\n  guard_target = DecidableEq \u03b2\n  apply Classical.typeDecidableEq\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "DecidableType : Sort ?u.9\n\u03b2 : Type\n\u22a2 DecidableType"}, {"line": "  use \u03b2", "tactic_state": ""}, {"line": "  guard_target = DecidableEq \u03b2", "tactic_state": ""}]}
{"declaration": "example (n : Nat) : Nat := by use n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2115"}]}
{"declaration": "example (\u03b1 : Type u) : Embedding \u03b1 \u03b1 \u00d7 Unit := by\n  constructor\n  -- testing that `use` actually focuses on the main goal\n  use id\n  \u00b7 simp\n  constructor\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort ?u.6\nEmbedding : x\u271d\n\u03b1 : Type u\n\u22a2 sorry \u00d7 Unit"}, {"line": "  constructor", "tactic_state": "case fst\nx\u271d : Sort ?u.6\nEmbedding : x\u271d\n\u03b1 : Type u\n\u22a2 sorry\n---\ncase snd\nx\u271d : Sort ?u.6\nEmbedding : x\u271d\n\u03b1 : Type u\n\u22a2 Unit"}, {"line": "  -- testing that `use` actually focuses on the main goal", "tactic_state": "case snd\nx\u271d : Sort ?u.6\nEmbedding : x\u271d\n\u03b1 : Type u\n\u22a2 Unit"}, {"line": "  use id", "tactic_state": "case snd\nx\u271d : Sort ?u.6\nEmbedding : x\u271d\n\u03b1 : Type u\n\u22a2 Unit"}, {"line": "  \u00b7 simp", "tactic_state": ""}]}
{"declaration": "example (h1 : 1 > 0) : \u2203 (n : Nat) (_h : n > 0), n = n := by\n  use 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h1 : 1 > 0\n\u22a2 \u2203 n, \u2203 (_ : n > 0), n = n"}, {"line": "  use 1", "tactic_state": ""}]}
{"declaration": "example : let P : Nat \u2192 Prop := fun _x => \u2203 _n : Nat, True; P 1 := by\n  intro P\n  use 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 let P := fun _x => \u2203 _n, True;\n  P 1"}, {"line": "  intro P", "tactic_state": "P : \u2115 \u2192 Prop := fun _x => \u2203 _n, True\n\u22a2 P 1"}, {"line": "  use 1", "tactic_state": ""}]}
{"declaration": "example : \u2203 f : Nat \u2192 Nat, f 1 = 1 := by\n  use \u00b7\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 f, f 1 = 1"}, {"line": "  use \u00b7", "tactic_state": "case h\n\u22a2 sorry 1 = 1"}]}
{"declaration": "example : \u2203 f : Nat \u2192 Nat, f 1 = 1 := by\n  use (\u00b7)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 f, f 1 = 1"}, {"line": "  use (\u00b7)", "tactic_state": ""}]}
{"declaration": "example {F : \u2115 \u2192 \u03b1 \u2192 \u03b2} (hF : \u2200 i, Measurable (F i)) : Measurable (F 0) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\nF : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhF : \u2200 (i : \u2115), Measurable (F i)\n\u22a2 Measurable (F 0)"}]}
{"declaration": "example {\u03b9} [Encodable \u03b9] {S\u2081 S\u2082 : \u03b9 \u2192 Set \u03b1} (hS\u2081 : \u2200 i, MeasurableSet (S\u2081 i))\n    (hS\u2082 : \u2200 i, MeasurableSet (S\u2082 i)) : MeasurableSet (\u22c3 i, (S\u2081 i) \u222a (S\u2082 i)) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03b9 : Type u_3\ninst\u271d : Encodable \u03b9\nS\u2081 S\u2082 : \u03b9 \u2192 Set \u03b1\nhS\u2081 : \u2200 (i : \u03b9), MeasurableSet (S\u2081 i)\nhS\u2082 : \u2200 (i : \u03b9), MeasurableSet (S\u2082 i)\n\u22a2 MeasurableSet (\u22c3 i, S\u2081 i \u222a S\u2082 i)"}]}
{"declaration": "example {\u03b9} [Encodable \u03b9] {S : \u03b9 \u2192 Set \u03b1} (hs : \u2200 i, MeasurableSet (S i)) :\n    MeasurableSet (\u22c3 i, S i) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03b9 : Type u_3\ninst\u271d : Encodable \u03b9\nS : \u03b9 \u2192 Set \u03b1\nhs : \u2200 (i : \u03b9), MeasurableSet (S i)\n\u22a2 MeasurableSet (\u22c3 i, S i)"}]}
{"declaration": "example {F : \u2115 \u2192 \u03b1 \u2192 \u03b2} (hF : \u2200 i, StronglyMeasurable (F i)) : Measurable (F 0) := by\n  measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\nF : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhF : \u2200 (i : \u2115), StronglyMeasurable (F i)\n\u22a2 Measurable (F 0)"}, {"line": "  measurability", "tactic_state": ""}]}
{"declaration": "example [Zero \u03b2] {F : \u2115 \u2192 \u03b1 \u2192 \u03b2} (hF : \u2200 i, AEFinStronglyMeasurable (F i) \u03bc) :\n    AEMeasurable (F 0) \u03bc := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : PseudoMetrizableSpace \u03b2\ninst\u271d\u00b2 : BorelSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : Zero \u03b2\nF : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhF : \u2200 (i : \u2115), AEFinStronglyMeasurable (F i) \u03bc\n\u22a2 AEMeasurable (F 0) \u03bc"}]}
{"declaration": "example {\u03b9} [Encodable \u03b9] {S\u2081 S\u2082 : \u03b9 \u2192 Set \u03b1} (hS\u2081 : \u2200 i, MeasurableSet (S\u2081 i))\n    (hS\u2082 : \u2200 i, MeasurableSet (S\u2082 i)) : MeasurableSet (\u22c3 i, (S\u2081 i) \u222a (S\u2082 i)) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\ninst\u271d\u00b2 : PseudoMetrizableSpace \u03b2\ninst\u271d\u00b9 : BorelSpace \u03b2\n\u03b9 : Type u_3\ninst\u271d : Encodable \u03b9\nS\u2081 S\u2082 : \u03b9 \u2192 Set \u03b1\nhS\u2081 : \u2200 (i : \u03b9), MeasurableSet (S\u2081 i)\nhS\u2082 : \u2200 (i : \u03b9), MeasurableSet (S\u2082 i)\n\u22a2 MeasurableSet (\u22c3 i, S\u2081 i \u222a S\u2082 i)"}]}
{"declaration": "example {a b : \u211d} : MeasurableSet (Set.Icc a b) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\na b : \u211d\n\u22a2 MeasurableSet (Set.Icc a b)"}]}
{"declaration": "example [AddCommMonoid \u03b2] [MeasurableAdd\u2082 \u03b2] {s : Finset \u2115} {F : \u2115 \u2192 \u03b1 \u2192 \u03b2}\n    (hF : \u2200 i, Measurable (F i)) : Measurable (\u2211 i \u2208 s, (fun x => F (i+1) x + F i x)) := by\n  fun_prop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : PseudoMetrizableSpace \u03b2\ninst\u271d\u00b2 : BorelSpace \u03b2\ninst\u271d\u00b9 : AddCommMonoid \u03b2\ninst\u271d : MeasurableAdd\u2082 \u03b2\ns : Finset \u2115\nF : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhF : \u2200 (i : \u2115), Measurable (F i)\n\u22a2 Measurable (\u2211 i \u2208 s, fun x => F (i + 1) x + F i x)"}, {"line": "  fun_prop", "tactic_state": ""}]}
{"declaration": "example [AddCommMonoid \u03b2] [MeasurableAdd\u2082 \u03b2] {s : Finset \u2115} {F : \u2115 \u2192 \u03b1 \u2192 \u03b2}\n    (hF : \u2200 i, AEMeasurable (F i) \u03bc) : AEMeasurable (\u2211 i \u2208 s, (fun x => F (i+1) x + F i x)) \u03bc := by\n  measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\ninst\u271d\u2075 : TopologicalSpace \u03b2\ninst\u271d\u2074 : PseudoMetrizableSpace \u03b2\ninst\u271d\u00b3 : BorelSpace \u03b2\ninst\u271d\u00b2 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b2\ninst\u271d : MeasurableAdd\u2082 \u03b2\ns : Finset \u2115\nF : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhF : \u2200 (i : \u2115), AEMeasurable (F i) \u03bc\n\u22a2 AEMeasurable (\u2211 i \u2208 s, fun x => F (i + 1) x + F i x) \u03bc"}, {"line": "  measurability", "tactic_state": ""}]}
{"declaration": "example [TopologicalSpace \u03b1] [BorelSpace \u03b1] [NormedAddCommGroup \u03b2] [BorelSpace \u03b2]\n    [MeasurableAdd\u2082 \u03b2] [MeasurableSub\u2082 \u03b2] {s : Finset \u2115} {F : \u2115 \u2192 \u03b1 \u2192 \u03b2}\n    (hF : \u2200 i, Measurable (F i)) : AEMeasurable (\u2211 i \u2208 s, (fun x => F (i+1) x - F i x)) \u03bc := by\n  measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b9 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b2\ninst\u271d\u2079 : TopologicalSpace \u03b2\ninst\u271d\u2078 : PseudoMetrizableSpace \u03b2\ninst\u271d\u2077 : BorelSpace \u03b2\ninst\u271d\u2076 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : BorelSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup \u03b2\ninst\u271d\u00b2 : BorelSpace \u03b2\ninst\u271d\u00b9 : MeasurableAdd\u2082 \u03b2\ninst\u271d : MeasurableSub\u2082 \u03b2\ns : Finset \u2115\nF : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhF : \u2200 (i : \u2115), Measurable (F i)\n\u22a2 AEMeasurable (\u2211 i \u2208 s, fun x => F (i + 1) x - F i x) \u03bc"}, {"line": "  measurability", "tactic_state": ""}]}
{"declaration": "example : Measurable (fun x : \u211d => Real.exp (2 * inner 3 x)) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\n\u22a2 Measurable fun x => Real.exp (2 * inner 3 x)"}]}
{"declaration": "example : StronglyMeasurable (fun x : \u211d => Real.exp (2 * inner 3 x)) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\n\u22a2 StronglyMeasurable fun x => Real.exp (2 * inner 3 x)"}]}
{"declaration": "example {\u03b3 : MeasureTheory.Measure \u211d} :\n  AEMeasurable (fun x : \u211d => Real.exp (2 * inner 3 x)) \u03b3 := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\n\u03b3 : Measure \u211d\n\u22a2 AEMeasurable (fun x => Real.exp (2 * inner 3 x)) \u03b3"}]}
{"declaration": "example {\u03b3 : MeasureTheory.Measure \u211d} :\n  AEStronglyMeasurable (fun x : \u211d => Real.exp (2 * inner 3 x)) \u03b3 := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\n\u03b3 : Measure \u211d\n\u22a2 AEStronglyMeasurable (fun x => Real.exp (2 * inner 3 x)) \u03b3"}]}
{"declaration": "example {\u03b3 : MeasureTheory.Measure \u211d} [SigmaFinite \u03b3] :\n  FinStronglyMeasurable (fun x : \u211d => Real.exp (2 * inner 3 x)) \u03b3 := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\ninst\u271d\u00b2 : PseudoMetrizableSpace \u03b2\ninst\u271d\u00b9 : BorelSpace \u03b2\n\u03b3 : Measure \u211d\ninst\u271d : SigmaFinite \u03b3\n\u22a2 FinStronglyMeasurable (fun x => Real.exp (2 * inner 3 x)) \u03b3"}]}
{"declaration": "example {\u03b3 : MeasureTheory.Measure \u211d} [SigmaFinite \u03b3] :\n  AEFinStronglyMeasurable (fun x : \u211d => Real.exp (2 * inner 3 x)) \u03b3 := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\ninst\u271d\u00b2 : PseudoMetrizableSpace \u03b2\ninst\u271d\u00b9 : BorelSpace \u03b2\n\u03b3 : Measure \u211d\ninst\u271d : SigmaFinite \u03b3\n\u22a2 AEFinStronglyMeasurable (fun x => Real.exp (2 * inner 3 x)) \u03b3"}]}
{"declaration": "example {\u03b9 : Type _} (i k : \u03b9) (hik : i \u2260 k) : Measurable (id : \u03b1 \u2192 \u03b1) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\n\u03b9 : Type u_3\ni k : \u03b9\nhik : i \u2260 k\n\u22a2 Measurable id"}]}
{"declaration": "example {a b c d e : Nat} (h1 : a \u2264 b) (h2 : c \u2264 d) (h3 : 0 \u2264 e) :\n    a + c * e + a + c + 0 \u2264 b + d * e + b + d + e := by\n  apply_rules [Nat.add_le_add, Nat.mul_le_mul_right]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d e : \u2115\nh1 : a \u2264 b\nh2 : c \u2264 d\nh3 : 0 \u2264 e\n\u22a2 a + c * e + a + c + 0 \u2264 b + d * e + b + d + e"}, {"line": "  apply_rules [Nat.add_le_add, Nat.mul_le_mul_right]", "tactic_state": ""}]}
{"declaration": "example {a b c d e : Nat} (h1 : a \u2264 b) (h2 : c \u2264 d) (h3 : 0 \u2264 e) :\n    a + c * e + a + c + 0 \u2264 b + d * e + b + d + e := by\n  apply_rules (config := {maxDepth := 9}) [Nat.add_le_add, Nat.mul_le_mul_right]\n  guard_target = 0 \u2264 e\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d e : \u2115\nh1 : a \u2264 b\nh2 : c \u2264 d\nh3 : 0 \u2264 e\n\u22a2 a + c * e + a + c + 0 \u2264 b + d * e + b + d + e"}, {"line": "  apply_rules (config := {maxDepth := 9}) [Nat.add_le_add, Nat.mul_le_mul_right]", "tactic_state": "case h\u2082\na b c d e : \u2115\nh1 : a \u2264 b\nh2 : c \u2264 d\nh3 : 0 \u2264 e\n\u22a2 0 \u2264 e"}, {"line": "  guard_target = 0 \u2264 e", "tactic_state": "case h\u2082\na b c d e : \u2115\nh1 : a \u2264 b\nh2 : c \u2264 d\nh3 : 0 \u2264 e\n\u22a2 0 \u2264 e"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example {P Q : Prop} (p : P) (f : P \u2192 Q) : Q := by\n  apply_rules only [f]\n  exact p\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\np : P\nf : P \u2192 Q\n\u22a2 Q"}, {"line": "  apply_rules only [f]", "tactic_state": "P Q : Prop\np : P\nf : P \u2192 Q\n\u22a2 P"}, {"line": "  exact p", "tactic_state": ""}]}
{"declaration": "example {P Q : Prop} (p : P) (f : P \u2192 Q) : Q := by\n  apply_rules [-p]\n  exact p\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\np : P\nf : P \u2192 Q\n\u22a2 Q"}, {"line": "  apply_rules [-p]", "tactic_state": "P Q : Prop\np : P\nf : P \u2192 Q\n\u22a2 P"}, {"line": "  exact p", "tactic_state": ""}]}
{"declaration": "example (P : Nat \u2192 Type) (f : {n : Nat} \u2192 P n \u2192 P (n + 1)) (g : P 0) : P 2 := by\n  apply_rules only [f, g]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : \u2115 \u2192 Type\nf : {n : \u2115} \u2192 P n \u2192 P (n + 1)\ng : P 0\n\u22a2 P 2"}, {"line": "  apply_rules only [f, g]", "tactic_state": ""}]}
{"declaration": "example (Q : Type) (f : Nat \u2192 Q) : Int \u00d7 Q := by\n  apply_rules only [Prod.mk, f]\n  guard_target = Int\n  exact 0\n  guard_target = Nat\n  exact 37\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Q : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2124 \u00d7 Q"}, {"line": "  apply_rules only [Prod.mk, f]", "tactic_state": "case fst\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2124\n---\ncase snd\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2115"}, {"line": "  guard_target = Int", "tactic_state": "case fst\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2124\n---\ncase snd\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2115"}, {"line": "  exact 0", "tactic_state": "case snd\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2115"}, {"line": "  guard_target = Nat", "tactic_state": "case snd\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2115"}, {"line": "  exact 37", "tactic_state": ""}]}
{"declaration": "example [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b : \u03b1} (hb : 0 \u2264 b) (hab : a \u2264 b) :\n    a / 2 \u2264 b / 2 := by\n  fail_if_success\n    apply_rules (config := { transparency := .reducible }) [mul_le_mul]\n  guard_target = a / 2 \u2264 b / 2\n  exact div_le_div\u2080 hb hab zero_lt_two le_rfl", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\nhb : 0 \u2264 b\nhab : a \u2264 b\n\u22a2 a / 2 \u2264 b / 2"}, {"line": "  fail_if_success", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\nhb : 0 \u2264 b\nhab : a \u2264 b\n\u22a2 a / 2 \u2264 b / 2"}, {"line": "    apply_rules (config := { transparency := .reducible }) [mul_le_mul]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\nhb : 0 \u2264 b\nhab : a \u2264 b\n\u22a2 a / 2 \u2264 b / 2"}, {"line": "  guard_target = a / 2 \u2264 b / 2", "tactic_state": ""}]}
{"declaration": "example : True := by\n  refine' (by refine' .intro)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  refine' (by refine' .intro)", "tactic_state": ""}]}
{"declaration": "example : True := by\n  refine' (by refine' .intro)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  refine' (by refine' .intro)", "tactic_state": ""}]}
{"declaration": "example : True := by\n  refine' (by refine' .intro)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  refine' (by refine' .intro)", "tactic_state": ""}]}
{"declaration": "example (a : (True \u2228 True) \u2228 (True \u2228 True)): True := by\n  cases' a with b b <;> cases' b <;> trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : (True \u2228 True) \u2228 True \u2228 True\n\u22a2 True"}, {"line": "  cases' a with b b <;> cases' b <;> trivial", "tactic_state": ""}]}
{"declaration": "example (a : (True \u2228 True) \u2228 (True \u2228 True)): True := by\n  cases' a with b b <;> cases' b <;> trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : (True \u2228 True) \u2228 True \u2228 True\n\u22a2 True"}, {"line": "  cases' a with b b <;> cases' b <;> trivial", "tactic_state": ""}]}
{"declaration": "example : False := by admit\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 False"}]}
{"declaration": "example : True \u2227 True := by\n  have : True := by\n    \u00b7 admit\n  let foo : Nat := by admit\n  refine \u27e8?_, ?_\u27e9\n  \u00b7 admit\n  \u00b7 admit\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True \u2227 True"}, {"line": "  have : True := by", "tactic_state": "this : True\n\u22a2 True \u2227 True"}, {"line": "    \u00b7 admit", "tactic_state": "this : True\nfoo : \u2115 := sorry\n\u22a2 True \u2227 True"}, {"line": "  let foo : Nat := by admit", "tactic_state": "case refine_1\nthis : True\nfoo : \u2115 := sorry\n\u22a2 True\n---\ncase refine_2\nthis : True\nfoo : \u2115 := sorry\n\u22a2 True"}, {"line": "  refine \u27e8?_, ?_\u27e9", "tactic_state": ""}, {"line": "  \u00b7 admit", "tactic_state": ""}]}
{"declaration": "example : False := by admit\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 False"}]}
{"declaration": "example : p \u2227 p := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : Prop\nh : p \u2227 q \u2228 p \u2227 r\n\u22a2 p \u2227 p"}]}
{"declaration": "example : \u2203 x, p x := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh\u271d : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\n\u03b1 : Type\np q r : \u03b1 \u2192 Prop\nh : (\u2203 x, p x \u2227 q x) \u2228 \u2203 x, p x \u2227 r x\n\u22a2 \u2203 x, p x"}]}
{"declaration": "example : \u2203 x, r x := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b9 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b9 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p x\nh\u2082 : q x\n\u22a2 \u2203 x, r x"}]}
{"declaration": "example (p : Prop) : p \u2227 True \u2194 p := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\n\u22a2 p \u2227 True \u2194 p"}]}
{"declaration": "example (p : Prop) : p \u2228 False \u2194 p := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\n\u22a2 p \u2228 False \u2194 p"}]}
{"declaration": "example (p q : Prop) (h : p \u2260 q) : \u00ac p \u2194 q := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : p \u2260 q\n\u22a2 \u00acp \u2194 q"}]}
{"declaration": "example (p q : Prop) (h : \u00ac p = q) : \u00ac p \u2194 q := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00acp = q\n\u22a2 \u00acp \u2194 q"}]}
{"declaration": "example (p q r : Prop) : p \u2228 (q \u2227 r) \u2194 (p \u2228 q) \u2227 (r \u2228 p \u2228 r) := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r\u271d : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q r : Prop\n\u22a2 p \u2228 q \u2227 r \u2194 (p \u2228 q) \u2227 (r \u2228 p \u2228 r)"}]}
{"declaration": "example (p q r : Prop) : p \u2228 (q \u2227 r) \u2194 (p \u2228 q) \u2227 (r \u2228 p \u2228 r) := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r\u271d : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q r : Prop\n\u22a2 p \u2228 q \u2227 r \u2194 (p \u2228 q) \u2227 (r \u2228 p \u2228 r)"}]}
{"declaration": "example (p q : Prop) (h : \u00ac (p \u2194 q)) (h' : \u00ac p) : q := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : \u00acp\n\u22a2 q"}]}
{"declaration": "example (p q : Prop) (h : \u00ac (p \u2194 q)) (h' : p) : \u00ac q := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : p\n\u22a2 \u00acq"}]}
{"declaration": "example (p q : Prop) (h : \u00ac (p \u2194 q)) (h' : q) : \u00ac p := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : q\n\u22a2 \u00acp"}]}
{"declaration": "example (p q : Prop) (h : \u00ac (p \u2194 q)) (h' : \u00ac q) : p := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : \u00acq\n\u22a2 p"}]}
{"declaration": "example (p q : Prop) (h : \u00ac (p \u2194 q)) (h' : \u00ac q) (h'' : \u00ac p) : False := by\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : \u00acq\nh'' : \u00acp\n\u22a2 False"}, {"line": "  tauto", "tactic_state": ""}]}
{"declaration": "example (p q r : Prop) (h : p \u2194 q) (h' : r \u2194 q) (h'' : \u00ac r) : \u00ac p := by\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r\u271d : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q r : Prop\nh : p \u2194 q\nh' : r \u2194 q\nh'' : \u00acr\n\u22a2 \u00acp"}, {"line": "  tauto", "tactic_state": ""}]}
{"declaration": "example (p q r : Prop) (h : p \u2194 q) (h' : r \u2194 q) : p \u2194 r := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r\u271d : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q r : Prop\nh : p \u2194 q\nh' : r \u2194 q\n\u22a2 p \u2194 r"}]}
{"declaration": "example (p q r : Prop) (h : \u00ac p = q) (h' : r = q) : p \u2194 \u00ac r := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r\u271d : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q r : Prop\nh : \u00acp = q\nh' : r = q\n\u22a2 p \u2194 \u00acr"}]}
{"declaration": "example (p : Prop) : p \u2192 \u00ac (p \u2192 \u00ac p) := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\n\u22a2 p \u2192 \u00ac(p \u2192 \u00acp)"}]}
{"declaration": "example (p : Prop) (em : p \u2228 \u00ac p) : \u00ac (p \u2194 \u00ac p) := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\nem : p \u2228 \u00acp\n\u22a2 \u00ac(p \u2194 \u00acp)"}]}
{"declaration": "example (p : Prop) (h : False) : p := by\n  -- causes `h'` to have a type that's a metavariable:\n  have h' := h\n  clear h\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\nh : False\n\u22a2 p"}, {"line": "  -- causes `h'` to have a type that's a metavariable:", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\nh h' : False\n\u22a2 p"}, {"line": "  have h' := h", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\nh' : False\n\u22a2 p"}, {"line": "  clear h", "tactic_state": ""}]}
{"declaration": "example (P : Nat \u2192 Prop) (n : Nat) : P n \u2192 n = 7 \u2228 n = 0 \u2228 \u00ac (n = 7 \u2228 n = 0) \u2227 P n := by\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b9 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b9 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p x\nh\u2082 : q x\nP : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 P n \u2192 n = 7 \u2228 n = 0 \u2228 \u00ac(n = 7 \u2228 n = 0) \u2227 P n"}, {"line": "  tauto", "tactic_state": ""}]}
{"declaration": "example : \u00ac(\u00aca \u2264 b \u2227 a \u2264 c \u2228 \u00aca \u2264 c \u2227 a \u2264 b) \u2194 a \u2264 b \u2227 a \u2264 c \u2228 \u00aca \u2264 c \u2227 \u00aca \u2264 b := by\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b9 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b9 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p x\nh\u2082 : q x\na b c : \u2115\n\u22a2 \u00ac(\u00aca \u2264 b \u2227 a \u2264 c \u2228 \u00aca \u2264 c \u2227 a \u2264 b) \u2194 a \u2264 b \u2227 a \u2264 c \u2228 \u00aca \u2264 c \u2227 \u00aca \u2264 b"}, {"line": "  tauto", "tactic_state": ""}]}
{"declaration": "example (h' : p \u2227 \u00ac y = x) : p \u2227 q := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d\u00b9 : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b9 \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1\u271d : Type\nx\u271d : \u03b1\u271d\np\u271d q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\u271d\nh\u2081 : p\u271d x\u271d\nh\u2082 : q\u271d x\u271d\na b c : \u2115\np q r : Prop\n\u03b1 : Type\nx y : \u03b1\nh : x = y\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\nh' : p \u2227 \u00acy = x\n\u22a2 p \u2227 q"}]}
{"declaration": "example : y = x := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d\u00b9 : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b9 \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1\u271d : Type\nx\u271d : \u03b1\u271d\np\u271d q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\u271d\nh\u2081 : p\u271d x\u271d\nh\u2082 : q\u271d x\u271d\na b c : \u2115\np q r : Prop\n\u03b1 : Type\nx y : \u03b1\nh : x = y\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\n\u22a2 y = x"}]}
{"declaration": "example (h' : \u00ac x = y) : p \u2227 q := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d\u00b9 : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b9 \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1\u271d : Type\nx\u271d : \u03b1\u271d\np\u271d q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\u271d\nh\u2081 : p\u271d x\u271d\nh\u2082 : q\u271d x\u271d\na b c : \u2115\np q r : Prop\n\u03b1 : Type\nx y : \u03b1\nh : x = y\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\nh' : \u00acx = y\n\u22a2 p \u2227 q"}]}
{"declaration": "example : x = y := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d\u00b9 : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b9 \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1\u271d : Type\nx\u271d : \u03b1\u271d\np\u271d q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\u271d\nh\u2081 : p\u271d x\u271d\nh\u2082 : q\u271d x\u271d\na b c : \u2115\np q r : Prop\n\u03b1 : Type\nx y : \u03b1\nh : x = y\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\n\u22a2 x = y"}]}
{"declaration": "example {\u03b1 : Type*} {\u03b2 : Type*} (a : \u03b1) {s_1 : Set \u03b1} :\n    (\u2203 (a_1 : \u03b1), a_1 = a \u2228 a_1 \u2208 s_1) := by\n  tauto {closer := `[simp]}\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))", "(\u03b1 : Type)", "(x y z w : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d\u00b3 : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b3 \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1\u271d\u00b2 : Type\nx\u271d\u00b9 : \u03b1\u271d\u00b2\np\u271d q\u271d r\u271d : \u03b1\u271d\u00b2 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d\u00b2), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\u271d\u00b9\nh\u2081 : p\u271d x\u271d\u00b9\nh\u2082 : q\u271d x\u271d\u00b9\na\u271d b c : \u2115\np q r : Prop\n\u03b1\u271d\u00b9 : Type\nx\u271d y\u271d : \u03b1\u271d\u00b9\nh : x\u271d = y\u271d\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\n\u03b1\u271d : Type\nx y z w : \u03b1\u271d\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\ns_1 : Set \u03b1\n\u22a2 \u2203 a_1, a_1 = a \u2228 a_1 \u2208 s_1"}, {"line": "  tauto {closer := `[simp]}", "tactic_state": ""}]}
{"declaration": "example : (((r \u2227 p \u2194 r \u2228 q) \u2227 (q \u2228 r)) \u2192 (p \u2227 (x = w) \u2227 (\u00ac x = w \u2192 p \u2227 q \u2227 r))) := by\n  tauto {closer := `[cc]}\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))", "(\u03b1 : Type)", "(x y z w : \u03b1)", "{p q r : Prop} {\u03b1 : Type} {x y z w : \u03b1}", "(h : x = y) (h\u2081 : y = z) (h\u2082 : z = w)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b3 q\u271d\u00b3 r\u271d\u00b3 : Prop\nh\u271d\u00b2 : p\u271d\u00b3 \u2227 q\u271d\u00b3 \u2228 p\u271d\u00b3 \u2227 r\u271d\u00b3\n\u03b1\u271d\u00b3 : Type\np\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : \u03b1\u271d\u00b3 \u2192 Prop\nh\u271d\u00b9 : (\u2203 x, p\u271d\u00b2 x \u2227 q\u271d\u00b2 x) \u2228 \u2203 x, p\u271d\u00b2 x \u2227 r\u271d\u00b2 x\n\u03b1\u271d\u00b2 : Type\nx\u271d\u00b2 : \u03b1\u271d\u00b2\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b2 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d\u00b2), p\u271d\u00b9 x \u2192 q\u271d\u00b9 x \u2192 r\u271d\u00b9 x) \u2228 r\u271d\u00b9 x\u271d\u00b2\nh\u2081\u271d : p\u271d\u00b9 x\u271d\u00b2\nh\u2082\u271d : q\u271d\u00b9 x\u271d\u00b2\na b c : \u2115\np\u271d q\u271d r\u271d : Prop\n\u03b1\u271d\u00b9 : Type\nx\u271d\u00b9 y\u271d\u00b9 : \u03b1\u271d\u00b9\nh\u271d : x\u271d\u00b9 = y\u271d\u00b9\nh''\u271d : (p\u271d \u2227 q\u271d \u2194 q\u271d \u2228 r\u271d) \u2194 (r\u271d \u2227 p\u271d \u2194 r\u271d \u2228 q\u271d)\n\u03b1\u271d : Type\nx\u271d y\u271d z\u271d w\u271d : \u03b1\u271d\np q r : Prop\n\u03b1 : Type\nx y z w : \u03b1\nh : x = y\nh\u2081 : y = z\nh\u2082 : z = w\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\n\u22a2 (r \u2227 p \u2194 r \u2228 q) \u2227 (q \u2228 r) \u2192 p \u2227 x = w \u2227 (\u00acx = w \u2192 p \u2227 q \u2227 r)"}, {"line": "  tauto {closer := `[cc]}", "tactic_state": ""}]}
{"declaration": "example {x y : Nat} (h : \u00acx \u2260 y) : x = y := by\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))", "(\u03b1 : Type)", "(x y z w : \u03b1)", "{p q r : Prop} {\u03b1 : Type} {x y z w : \u03b1}", "(h : x = y) (h\u2081 : y = z) (h\u2082 : z = w)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b3 q\u271d\u00b3 r\u271d\u00b3 : Prop\nh\u271d\u00b3 : p\u271d\u00b3 \u2227 q\u271d\u00b3 \u2228 p\u271d\u00b3 \u2227 r\u271d\u00b3\n\u03b1\u271d\u00b3 : Type\np\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : \u03b1\u271d\u00b3 \u2192 Prop\nh\u271d\u00b2 : (\u2203 x, p\u271d\u00b2 x \u2227 q\u271d\u00b2 x) \u2228 \u2203 x, p\u271d\u00b2 x \u2227 r\u271d\u00b2 x\n\u03b1\u271d\u00b2 : Type\nx\u271d\u00b3 : \u03b1\u271d\u00b2\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b2 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d\u00b2), p\u271d\u00b9 x \u2192 q\u271d\u00b9 x \u2192 r\u271d\u00b9 x) \u2228 r\u271d\u00b9 x\u271d\u00b3\nh\u2081\u271d : p\u271d\u00b9 x\u271d\u00b3\nh\u2082\u271d : q\u271d\u00b9 x\u271d\u00b3\na b c : \u2115\np\u271d q\u271d r\u271d : Prop\n\u03b1\u271d\u00b9 : Type\nx\u271d\u00b2 y\u271d\u00b2 : \u03b1\u271d\u00b9\nh\u271d\u00b9 : x\u271d\u00b2 = y\u271d\u00b2\nh''\u271d : (p\u271d \u2227 q\u271d \u2194 q\u271d \u2228 r\u271d) \u2194 (r\u271d \u2227 p\u271d \u2194 r\u271d \u2228 q\u271d)\n\u03b1\u271d : Type\nx\u271d\u00b9 y\u271d\u00b9 z\u271d w\u271d : \u03b1\u271d\np q r : Prop\n\u03b1 : Type\nx\u271d y\u271d z w : \u03b1\nh\u271d : x\u271d = y\u271d\nh\u2081 : y\u271d = z\nh\u2082 : z = w\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\nx y : \u2115\nh : \u00acx \u2260 y\n\u22a2 x = y"}, {"line": "  tauto", "tactic_state": ""}]}
{"declaration": "example (p : Prop) (o : Part \u03b1) (h : p \u2192 o.Dom) (a : \u03b1) :\n    a \u2208 restrict p o h \u2194 p \u2227 a \u2208 o := by\n  dsimp [restrict, mem_eq]\n  tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in", "Part"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))", "(\u03b1 : Type)", "(x y z w : \u03b1)", "{p q r : Prop} {\u03b1 : Type} {x y z w : \u03b1}", "(h : x = y) (h\u2081 : y = z) (h\u2082 : z = w)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u2074 q\u271d\u00b3 r\u271d\u00b3 : Prop\nh\u271d\u00b3 : p\u271d\u2074 \u2227 q\u271d\u00b3 \u2228 p\u271d\u2074 \u2227 r\u271d\u00b3\n\u03b1\u271d\u00b3 : Type\np\u271d\u00b3 q\u271d\u00b2 r\u271d\u00b2 : \u03b1\u271d\u00b3 \u2192 Prop\nh\u271d\u00b2 : (\u2203 x, p\u271d\u00b3 x \u2227 q\u271d\u00b2 x) \u2228 \u2203 x, p\u271d\u00b3 x \u2227 r\u271d\u00b2 x\n\u03b1\u271d\u00b2 : Type\nx\u271d\u00b3 : \u03b1\u271d\u00b2\np\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b2 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d\u00b2), p\u271d\u00b2 x \u2192 q\u271d\u00b9 x \u2192 r\u271d\u00b9 x) \u2228 r\u271d\u00b9 x\u271d\u00b3\nh\u2081\u271d : p\u271d\u00b2 x\u271d\u00b3\nh\u2082\u271d : q\u271d\u00b9 x\u271d\u00b3\na\u271d b c : \u2115\np\u271d\u00b9 q\u271d r\u271d : Prop\n\u03b1\u271d\u00b9 : Type\nx\u271d\u00b2 y\u271d\u00b9 : \u03b1\u271d\u00b9\nh\u271d\u00b9 : x\u271d\u00b2 = y\u271d\u00b9\nh''\u271d : (p\u271d\u00b9 \u2227 q\u271d \u2194 q\u271d \u2228 r\u271d) \u2194 (r\u271d \u2227 p\u271d\u00b9 \u2194 r\u271d \u2228 q\u271d)\n\u03b1\u271d : Type\nx\u271d\u00b9 y\u271d z\u271d w\u271d : \u03b1\u271d\np\u271d q r : Prop\n\u03b1 : Type\nx y z w : \u03b1\nh\u271d : x = y\nh\u2081 : y = z\nh\u2082 : z = w\nh'' : (p\u271d \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p\u271d \u2194 r \u2228 q)\nx\u271d : Sort u_1\nrestrict : x\u271d\np : Prop\no : Part \u03b1\nh : p \u2192 o.Dom\na : \u03b1\n\u22a2 a \u2208 sorry \u2194 p \u2227 a \u2208 o"}, {"line": "  dsimp [restrict, mem_eq]", "tactic_state": "p\u271d\u2074 q\u271d\u00b3 r\u271d\u00b3 : Prop\nh\u271d\u00b3 : p\u271d\u2074 \u2227 q\u271d\u00b3 \u2228 p\u271d\u2074 \u2227 r\u271d\u00b3\n\u03b1\u271d\u00b3 : Type\np\u271d\u00b3 q\u271d\u00b2 r\u271d\u00b2 : \u03b1\u271d\u00b3 \u2192 Prop\nh\u271d\u00b2 : (\u2203 x, p\u271d\u00b3 x \u2227 q\u271d\u00b2 x) \u2228 \u2203 x, p\u271d\u00b3 x \u2227 r\u271d\u00b2 x\n\u03b1\u271d\u00b2 : Type\nx\u271d\u00b3 : \u03b1\u271d\u00b2\np\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b2 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d\u00b2), p\u271d\u00b2 x \u2192 q\u271d\u00b9 x \u2192 r\u271d\u00b9 x) \u2228 r\u271d\u00b9 x\u271d\u00b3\nh\u2081\u271d : p\u271d\u00b2 x\u271d\u00b3\nh\u2082\u271d : q\u271d\u00b9 x\u271d\u00b3\na\u271d b c : \u2115\np\u271d\u00b9 q\u271d r\u271d : Prop\n\u03b1\u271d\u00b9 : Type\nx\u271d\u00b2 y\u271d\u00b9 : \u03b1\u271d\u00b9\nh\u271d\u00b9 : x\u271d\u00b2 = y\u271d\u00b9\nh''\u271d : (p\u271d\u00b9 \u2227 q\u271d \u2194 q\u271d \u2228 r\u271d) \u2194 (r\u271d \u2227 p\u271d\u00b9 \u2194 r\u271d \u2228 q\u271d)\n\u03b1\u271d : Type\nx\u271d\u00b9 y\u271d z\u271d w\u271d : \u03b1\u271d\np\u271d q r : Prop\n\u03b1 : Type\nx y z w : \u03b1\nh\u271d : x = y\nh\u2081 : y = z\nh\u2082 : z = w\nh'' : (p\u271d \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p\u271d \u2194 r \u2228 q)\nx\u271d : Sort u_1\nrestrict : x\u271d\np : Prop\no : Part \u03b1\nh : p \u2192 o.Dom\na : \u03b1\n\u22a2 a \u2208 sorry () \u2194 p \u2227 a \u2208 o"}, {"line": "  tauto", "tactic_state": ""}]}
{"declaration": "example (x : Nat) (h : x = x) : x = x := by\n  set! p := h\n  set q : x = x := p\n  apply q\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Set.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x = x\n\u22a2 x = x"}, {"line": "  set! p := h", "tactic_state": "x : \u2115\nh : x = x\np : x = x := h\n\u22a2 x = x"}, {"line": "  set q : x = x := p", "tactic_state": "x : \u2115\nh : x = x\np : x = x := h\nq : x = x := p\n\u22a2 x = x"}, {"line": "  apply q", "tactic_state": ""}]}
{"declaration": "example (x : Nat) (h : x + x - x = 3) : x + x - x = 3 := by\n  set! y := x with \u2190 h2\n  set w := x\n  guard_hyp y := x\n  guard_hyp w := x\n  guard_hyp h : w + w - w = 3\n  guard_hyp h2 : w = y\n  set z := w with _h3\n  set a := 3\n  guard_target = z + z - z = a\n  set i'm_the_goal : Prop := z + z - z = a\n  guard_target = i'm_the_goal\n  apply h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Set.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x + x - x = 3\n\u22a2 x + x - x = 3"}, {"line": "  set! y := x with \u2190 h2", "tactic_state": "x : \u2115\nh : x + x - x = 3\ny : \u2115 := x\nh2 : x = y\n\u22a2 x + x - x = 3"}, {"line": "  set w := x", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nh : w + w - w = 3\nh2 : w = y\n\u22a2 w + w - w = 3"}, {"line": "  guard_hyp y := x", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nh : w + w - w = 3\nh2 : w = y\n\u22a2 w + w - w = 3"}, {"line": "  guard_hyp w := x", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nh : w + w - w = 3\nh2 : w = y\n\u22a2 w + w - w = 3"}, {"line": "  guard_hyp h : w + w - w = 3", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nh : w + w - w = 3\nh2 : w = y\n\u22a2 w + w - w = 3"}, {"line": "  guard_hyp h2 : w = y", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nh : w + w - w = 3\nh2 : w = y\n\u22a2 w + w - w = 3"}, {"line": "  set z := w with _h3", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nz : \u2115 := w\nh : z + z - z = 3\nh2 : z = y\n_h3 : z = w\n\u22a2 z + z - z = 3"}, {"line": "  set a := 3", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nz : \u2115 := w\nh2 : z = y\n_h3 : z = w\na : \u2115 := 3\nh : z + z - z = a\n\u22a2 z + z - z = a"}, {"line": "  guard_target = z + z - z = a", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nz : \u2115 := w\nh2 : z = y\n_h3 : z = w\na : \u2115 := 3\nh : z + z - z = a\n\u22a2 z + z - z = a"}, {"line": "  set i'm_the_goal : Prop := z + z - z = a", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nz : \u2115 := w\nh2 : z = y\n_h3 : z = w\na : \u2115 := 3\ni'm_the_goal : Prop := z + z - z = a\nh : i'm_the_goal\n\u22a2 i'm_the_goal"}, {"line": "  guard_target = i'm_the_goal", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nz : \u2115 := w\nh2 : z = y\n_h3 : z = w\na : \u2115 := 3\ni'm_the_goal : Prop := z + z - z = a\nh : i'm_the_goal\n\u22a2 i'm_the_goal"}, {"line": "  apply h", "tactic_state": ""}]}
{"declaration": "example (x : Nat) (h : x - x = 0) : x = x := by\n  set y : Nat := x\n  set! z := y + 1 with \u2190 _eq1\n  set! p : x - x = 0 := h with _eq2\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Set.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x - x = 0\n\u22a2 x = x"}, {"line": "  set y : Nat := x", "tactic_state": "x : \u2115\ny : \u2115 := x\nh : y - y = 0\n\u22a2 y = y"}, {"line": "  set! z := y + 1 with \u2190 _eq1", "tactic_state": "x : \u2115\ny : \u2115 := x\nh : y - y = 0\nz : \u2115 := y + 1\n_eq1 : y + 1 = z\n\u22a2 y = y"}, {"line": "  set! p : x - x = 0 := h with _eq2", "tactic_state": "x : \u2115\ny : \u2115 := x\nh : y - y = 0\nz : \u2115 := y + 1\n_eq1 : y + 1 = z\np : x - x = 0 := h\n_eq2 : p = h\n\u22a2 y = y"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : True := by\n  set g : Nat \u2192 Int := (fun \u03b5 => \u03b5) with _h\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Set.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  set g : Nat \u2192 Int := (fun \u03b5 => \u03b5) with _h", "tactic_state": "g : \u2115 \u2192 \u2124 := fun \u03b5 => \u2191\u03b5\n_h : g = fun \u03b5 => \u2191\u03b5\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example {_a _b _c _d _e _f _g _h : Nat} : 1 = 1 := by\n  set a : Nat := test with _h\n  trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Set.lean", "context": {"open": ["Qq in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_a _b _c _d _e _f _g _h : \u2115\n\u22a2 1 = 1"}, {"line": "  set a : Nat := test with _h", "tactic_state": "_a _b _c _d _e _f _g _h\u271d : \u2115\na : \u2115 := sorry\n_h : a = sorry\n\u22a2 1 = 1"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : True := by\n  classical\n  let zero' := 0\n  replace _zero := zero'\n  let eq := (rfl : 0 = 0)\n  replace _eq := eq\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  classical", "tactic_state": ""}]}
{"declaration": "example : True := by\n  noise\n  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  noise", "tactic_state": "\u22a2 True"}]}
{"declaration": "example : True := by\n  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9", "tactic_state": "_zero : \u2115\nisLt\u271d : _zero < 1\n\u22a2 True"}, {"line": "  exact .intro", "tactic_state": ""}]}
{"declaration": "example : True := by\n  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9", "tactic_state": "_zero : \u2115\nisLt\u271d : _zero < 1\n\u22a2 True"}, {"line": "  exact .intro", "tactic_state": ""}]}
{"declaration": "example : True := by\n  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9\n  noise\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9", "tactic_state": "_zero : \u2115\nisLt\u271d : _zero < 1\n\u22a2 True"}, {"line": "  noise", "tactic_state": "_zero : \u2115\nisLt\u271d : _zero < 1\n\u22a2 True"}]}
{"declaration": "example : True := by\n  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9\n  noise\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9", "tactic_state": "_zero : \u2115\nisLt\u271d : _zero < 1\n\u22a2 True"}, {"line": "  noise", "tactic_state": "_zero : \u2115\nisLt\u271d : _zero < 1\n\u22a2 True"}]}
{"declaration": "example : True := by\n  noise\n  have _a := 0\n  have _b : Nat := 0\n  have _b : 0 = 0 := rfl\n  have _oh : Nat := 0\n  have _b : Nat := 2\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  noise", "tactic_state": "\u22a2 True"}]}
{"declaration": "example : True := by\n  have := Nat.succ ?_;\n  noise\n  exact .intro\n  exact 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  have := Nat.succ ?_;", "tactic_state": "case refine_2\nthis : \u2115\n\u22a2 True\n---\ncase refine_1\n\u22a2 \u2115"}, {"line": "  noise", "tactic_state": "case refine_2\nthis : \u2115\n\u22a2 True\n---\ncase refine_1\n\u22a2 \u2115"}]}
{"declaration": "example : True := by\n  have := And.intro (Nat.add_comm ?_ ?_) (Nat.add_comm ?_ ?_)\n  apply True.intro\n  noise\n  repeat exact 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  have := And.intro (Nat.add_comm ?_ ?_) (Nat.add_comm ?_ ?_)", "tactic_state": "case refine_5\nthis : ?refine_1 + ?refine_2 = ?refine_2 + ?refine_1 \u2227 ?refine_3 + ?refine_4 = ?refine_4 + ?refine_3\n\u22a2 True\n---\ncase refine_1\n\u22a2 \u2115\n---\ncase refine_2\n\u22a2 \u2115\n---\ncase refine_3\n\u22a2 \u2115\n---\ncase refine_4\n\u22a2 \u2115"}, {"line": "  apply True.intro", "tactic_state": "case refine_1\n\u22a2 \u2115\n---\ncase refine_2\n\u22a2 \u2115\n---\ncase refine_3\n\u22a2 \u2115\n---\ncase refine_4\n\u22a2 \u2115"}, {"line": "  noise", "tactic_state": "case refine_1\n\u22a2 \u2115\n---\ncase refine_2\n\u22a2 \u2115\n---\ncase refine_3\n\u22a2 \u2115\n---\ncase refine_4\n\u22a2 \u2115"}]}
{"declaration": "example (h : False) : True := by\n  have : False := h\n  noise\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : False\n\u22a2 True"}, {"line": "  have : False := h", "tactic_state": "h this : False\n\u22a2 True"}, {"line": "  noise", "tactic_state": "h this : False\n\u22a2 True"}]}
{"declaration": "theorem ghi : True := by\n  noise\n  have : Nat := Nat.succ 1;\n  exact .intro", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  noise", "tactic_state": "\u22a2 True"}]}
{"declaration": "example : 0 = 0 := by\n  rw [] -- this goal is closed by the `rfl` implied by `rw`", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/PPRoundtrip.lean", "context": {"open": [], "variables": ["{a: Nat}", "{a :Nat}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a\u271d a : \u2115\n\u22a2 0 = 0"}, {"line": "  rw [] -- this goal is closed by the `rfl` implied by `rw`", "tactic_state": ""}]}
{"declaration": "example [AddCommMonoid \u03b1] : a + (b + a) = a + a + b := by abel", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommMonoid \u03b1\n\u22a2 a + (b + a) = a + a + b"}]}
{"declaration": "example [AddCommGroup \u03b1] : (a + b) - ((b + a) + a) = -a := by abel", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\n\u22a2 a + b - (b + a + a) = -a"}]}
{"declaration": "example [AddCommGroup \u03b1] (x : \u03b1) : x - 0 = x := by abel", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\n\u22a2 x - 0 = x"}]}
{"declaration": "example [AddCommMonoid \u03b1] : (3 : \u2115) \u2022 a = a + (2 : \u2115) \u2022 a := by abel", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommMonoid \u03b1\n\u22a2 3 \u2022 a = a + 2 \u2022 a"}]}
{"declaration": "example [AddCommGroup \u03b1] : (3 : \u2124) \u2022 a = a + (2 : \u2124) \u2022 a := by abel", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\n\u22a2 3 \u2022 a = a + 2 \u2022 a"}]}
{"declaration": "example [AddCommGroup \u03b1] (a b : \u03b1) : a-2\u2022b = a -2\u2022b := by abel\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b : \u03b1\n\u22a2 a - 2 \u2022 b = a - 2 \u2022 b"}]}
{"declaration": "example [AddCommMonoid \u03b1] (a b : \u03b1) : a + (b + a) = a + a + b := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommMonoid \u03b1\na b : \u03b1\n\u22a2 a + (b + a) = a + a + b"}]}
{"declaration": "example [AddCommGroup \u03b1] (a b : \u03b1) : (a + b) - ((b + a) + a) = -a := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b : \u03b1\n\u22a2 a + b - (b + a + a) = -a"}]}
{"declaration": "example [AddCommGroup \u03b1] (x : \u03b1) : x - 0 = x := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\n\u22a2 x - 0 = x"}]}
{"declaration": "example [AddCommMonoid \u03b1] (a : \u03b1) : (3 : \u2115) \u2022 a = a + (2 : \u2115) \u2022 a := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b : \u03b1\ninst\u271d : AddCommMonoid \u03b1\na : \u03b1\n\u22a2 3 \u2022 a = a + 2 \u2022 a"}]}
{"declaration": "example [AddCommGroup \u03b1] (a : \u03b1) : (3 : \u2124) \u2022 a = a + (2 : \u2124) \u2022 a := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b : \u03b1\ninst\u271d : AddCommGroup \u03b1\na : \u03b1\n\u22a2 3 \u2022 a = a + 2 \u2022 a"}]}
{"declaration": "example [AddCommGroup \u03b1] (a b : \u03b1) : a - 2\u2022b = a - 2\u2022b := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b : \u03b1\n\u22a2 a - 2 \u2022 b = a - 2 \u2022 b"}]}
{"declaration": "example [AddCommGroup \u03b1] (a : \u03b1) : 0 + a = a := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b : \u03b1\ninst\u271d : AddCommGroup \u03b1\na : \u03b1\n\u22a2 0 + a = a"}]}
{"declaration": "example [AddCommGroup \u03b1] (n : \u2115) (a : \u03b1) : n \u2022 a = n \u2022 a := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nn : \u2115\na : \u03b1\n\u22a2 n \u2022 a = n \u2022 a"}]}
{"declaration": "example [AddCommGroup \u03b1] (n : \u2115) (a : \u03b1) : 0 + n \u2022 a = n \u2022 a := by abel1\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nn : \u2115\na : \u03b1\n\u22a2 0 + n \u2022 a = n \u2022 a"}, {"line": "", "tactic_state": ""}]}
{"declaration": "example [AddCommMonoid \u03b1] (a b c d e : \u03b1) :\n  a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 \u2022 a := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommMonoid \u03b1\na b c d e : \u03b1\n\u22a2 a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 \u2022 a"}]}
{"declaration": "example [AddCommGroup \u03b1] (a b c d e : \u03b1) :\n  a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 \u2022 a := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c d e : \u03b1\n\u22a2 a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 \u2022 a"}]}
{"declaration": "example [AddCommGroup \u03b1] (a b c d : \u03b1) :\n  a + b + (c + d - a) = b + c + d := by abel1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c d : \u03b1\n\u22a2 a + b + (c + d - a) = b + c + d"}]}
{"declaration": "example [AddCommGroup \u03b1] (a b c : \u03b1) :\n  a + b + c + (c - a - a) = (-1)\u2022a + b + 2\u2022c := by abel1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c : \u03b1\n\u22a2 a + b + c + (c - a - a) = -1 \u2022 a + b + 2 \u2022 c"}]}
{"declaration": "example [AddCommMonoid \u03b1] (a b c d e : \u03b1) :\n    a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 \u2022 a \u2228 True := by\n  fail_if_success\n    left; abel1\n  right; trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommMonoid \u03b1\na b c d e : \u03b1\n\u22a2 a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 \u2022 a \u2228 True"}, {"line": "  fail_if_success", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommMonoid \u03b1\na b c d e : \u03b1\n\u22a2 a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 \u2022 a \u2228 True"}, {"line": "    left; abel1", "tactic_state": "case h\n\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommMonoid \u03b1\na b c d e : \u03b1\n\u22a2 True"}, {"line": "  right; trivial", "tactic_state": ""}]}
{"declaration": "example [AddCommGroup \u03b1] (a b c d e : \u03b1) :\n    a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 \u2022 a \u2228 True := by\n  fail_if_success\n    left; abel1\n  right; trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c d e : \u03b1\n\u22a2 a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 \u2022 a \u2228 True"}, {"line": "  fail_if_success", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c d e : \u03b1\n\u22a2 a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 \u2022 a \u2228 True"}, {"line": "    left; abel1", "tactic_state": "case h\n\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c d e : \u03b1\n\u22a2 True"}, {"line": "  right; trivial", "tactic_state": ""}]}
{"declaration": "example [AddCommGroup \u03b1] (a b c d : \u03b1) :\n    a + b + (c + d - a) = b + c - d \u2228 True := by\n  fail_if_success\n    left; abel1\n  right; trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c d : \u03b1\n\u22a2 a + b + (c + d - a) = b + c - d \u2228 True"}, {"line": "  fail_if_success", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c d : \u03b1\n\u22a2 a + b + (c + d - a) = b + c - d \u2228 True"}, {"line": "    left; abel1", "tactic_state": "case h\n\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c d : \u03b1\n\u22a2 True"}, {"line": "  right; trivial", "tactic_state": ""}]}
{"declaration": "example [AddCommGroup \u03b1] (a b c : \u03b1) :\n    a + b + c + (c - a - a) = (-1)\u2022a + b + c \u2228 True := by\n  fail_if_success\n    left; abel1\n  right; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c : \u03b1\n\u22a2 a + b + c + (c - a - a) = -1 \u2022 a + b + c \u2228 True"}, {"line": "  fail_if_success", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c : \u03b1\n\u22a2 a + b + c + (c - a - a) = -1 \u2022 a + b + c \u2228 True"}, {"line": "    left; abel1", "tactic_state": "case h\n\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b c : \u03b1\n\u22a2 True"}, {"line": "  right; trivial", "tactic_state": ""}]}
{"declaration": "example : MyTrue := by\n  abel_nf\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\nMyTrue : Sort ?u.19\n\u22a2 MyTrue"}, {"line": "  abel_nf", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\nMyTrue : Sort ?u.19\n\u22a2 MyTrue"}]}
{"declaration": "example [AddCommGroup \u03b1] (a b : \u03b1) : a + b - b - id' a = 0 := by\n  fail_if_success\n    abel1\n  abel1!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\na\u271d b\u271d : \u03b1\nx\u271d : Sort u_1\nid' : x\u271d\ninst\u271d : AddCommGroup \u03b1\na b : \u03b1\n\u22a2 a + b - b - sorry = 0"}, {"line": "  fail_if_success", "tactic_state": "\u03b1 : Type u_2\na\u271d b\u271d : \u03b1\nx\u271d : Sort u_1\nid' : x\u271d\ninst\u271d : AddCommGroup \u03b1\na b : \u03b1\n\u22a2 a + b - b - sorry = 0"}, {"line": "    abel1", "tactic_state": "\u03b1 : Type u_2\na\u271d b\u271d : \u03b1\nx\u271d : Sort u_1\nid' : x\u271d\ninst\u271d : AddCommGroup \u03b1\na b : \u03b1\n\u22a2 a + b - b - sorry = 0"}]}
{"declaration": "example [AddCommGroup \u03b1] : True := by\n  have : \u2200 (p q r s : \u03b1), s + p - q = s - r - (q - r - p) := by\n    intro p q r s\n    abel\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\n\u22a2 True"}, {"line": "  have : \u2200 (p q r s : \u03b1), s + p - q = s - r - (q - r - p) := by", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nthis : \u2200 (p q r s : \u03b1), s + p - q = s - r - (q - r - p)\n\u22a2 True"}, {"line": "    intro p q r s", "tactic_state": ""}]}
{"declaration": "example [AddCommGroup \u03b1] (x y z : \u03b1) : y = x + z - (x - y + z) := by\n  have : True := trivial\n  abel\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\n\u22a2 y = x + z - (x - y + z)"}, {"line": "  have : True := trivial", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nthis : True\n\u22a2 y = x + z - (x - y + z)"}, {"line": "  abel", "tactic_state": ""}]}
{"declaration": "example [AddCommGroup \u03b1] (a b s : \u03b1) : -b + (s - a) = s - b - a := by abel_nf\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b s : \u03b1\n\u22a2 -b + (s - a) = s - b - a"}]}
{"declaration": "example : True := by\n  have := 0\n  abel_nf\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\n\u22a2 True"}, {"line": "  have := 0", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\nthis : \u2115\n\u22a2 True"}, {"line": "  abel_nf", "tactic_state": ""}]}
{"declaration": "example : False := by abel_nf\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\n\u22a2 False"}]}
{"declaration": "example [AddCommGroup \u03b1] (x y z : \u03b1) (w : x = y + z) : False := by\n  abel_nf at w\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nw : x = y + z\n\u22a2 False"}, {"line": "  abel_nf at w", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nw : x = y + z\n\u22a2 False"}]}
{"declaration": "example [AddCommGroup \u03b1] (x y z : \u03b1) (h : False) (w : x - x = y + z) : False := by\n  abel_nf at w\n  guard_hyp w : 0 = y + z\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nh : False\nw : x - x = y + z\n\u22a2 False"}, {"line": "  abel_nf at w", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nh : False\nw : 0 = y + z\n\u22a2 False"}, {"line": "  guard_hyp w : 0 = y + z", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nh : False\nw : 0 = y + z\n\u22a2 False"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example [AddCommGroup \u03b1] (x y z : \u03b1) (_w : x = y + z) : False := by\n  abel_nf at *\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\n_w : x = y + z\n\u22a2 False"}, {"line": "  abel_nf at *", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\n_w : x = y + z\n\u22a2 False"}]}
{"declaration": "example [AddCommGroup \u03b1] (x y z : \u03b1) (_w : x = y + z) : x - x = 0 := by\n  abel_nf at *\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\n_w : x = y + z\n\u22a2 x - x = 0"}, {"line": "  abel_nf at *", "tactic_state": ""}]}
{"declaration": "example [AddCommGroup \u03b1] (x y z : \u03b1) (w : x = y + z) : x - x = 0 := by\n  abel_nf at w \u22a2\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nw : x = y + z\n\u22a2 x - x = 0"}, {"line": "  abel_nf at w \u22a2", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nw : x = y + z\n\u22a2 x - x = 0"}]}
{"declaration": "example [AddCommGroup \u03b1] (x y z : \u03b1) (w : x - x = y + z) : x = 0 := by\n  abel_nf at w \u22a2\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nw : x - x = y + z\n\u22a2 x = 0"}, {"line": "  abel_nf at w \u22a2", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nw : 0 = y + z\n\u22a2 x = 0"}]}
{"declaration": "example [AddCommGroup \u03b1] (x y z : \u03b1) (h : False) (w : x - x = y + z) : False := by\n  abel_nf at *\n  guard_hyp w : 0 = y + z\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nh : False\nw : x - x = y + z\n\u22a2 False"}, {"line": "  abel_nf at *", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nh : False\nw : 0 = y + z\n\u22a2 False"}, {"line": "  guard_hyp w : 0 = y + z", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx y z : \u03b1\nh : False\nw : 0 = y + z\n\u22a2 False"}, {"line": "  assumption", "tactic_state": ""}]}
{"declaration": "example (x : \u2124) (R : \u2124 \u2192 \u2124 \u2192 Prop) (hR : Reflexive R) : True := by\n  have h : R (myId x + x) (x + myId x) := hR ..\n  abel_nf at h\n  trace_state\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\nx : \u2124\nR : \u2124 \u2192 \u2124 \u2192 Prop\nhR : Reflexive R\n\u22a2 True"}, {"line": "  have h : R (myId x + x) (x + myId x) := hR ..", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\nx : \u2124\nR : \u2124 \u2192 \u2124 \u2192 Prop\nhR : Reflexive R\n\u22a2 True"}]}
{"declaration": "example [AddCommGroup \u03b1] (x : \u03b1) (f : \u03b1 \u2192 \u03b1) : True := by\n  let y := x\n  have : x = y := by\n    fail_if_success abel_nf\n    abel_nf!\n  have : x - y = 0 := by\n    abel_nf\n    abel_nf!\n  have : f x = f y := by\n    fail_if_success abel_nf\n    abel_nf!\n  have : f x - f y = 0 := by\n    abel_nf\n    abel_nf!\n  trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\n\u22a2 True"}, {"line": "  let y := x", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\ny : \u03b1 := x\n\u22a2 True"}, {"line": "  have : x = y := by", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\ny : \u03b1 := x\nthis : x = y\n\u22a2 True"}, {"line": "    fail_if_success abel_nf", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\ny : \u03b1 := x\nthis\u271d : x = y\nthis : x - y = 0\n\u22a2 True"}, {"line": "    abel_nf!", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\ny : \u03b1 := x\nthis\u271d\u00b9 : x = y\nthis\u271d : x - y = 0\nthis : f x = f y\n\u22a2 True"}, {"line": "  have : x - y = 0 := by", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\ny : \u03b1 := x\nthis\u271d\u00b2 : x = y\nthis\u271d\u00b9 : x - y = 0\nthis\u271d : f x = f y\nthis : f x - f y = 0\n\u22a2 True"}, {"line": "    abel_nf", "tactic_state": ""}]}
{"declaration": "example : True := by\n  run_tac\n    let t : Option Bool := (\u2190 Lean.MonadOptions.getOptions).get? `pp.all\n    -- should be true as set\n    guard (t == true)\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/UnsetOption.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  run_tac", "tactic_state": "\u22a2 True"}]}
{"declaration": "example : True := by\n  run_tac\n    let t : Option Bool := (\u2190 Lean.MonadOptions.getOptions).get? `pp.all\n    -- should be none as unset\n    guard (t == Option.none)\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/UnsetOption.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  run_tac", "tactic_state": "\u22a2 True"}, {"line": "    let t : Option Bool := (\u2190 Lean.MonadOptions.getOptions).get? `pp.all", "tactic_state": ""}]}
{"declaration": "example : True := by\n  run_tac\n    let t : Option Bool := (\u2190 Lean.MonadOptions.getOptions).get? `pp.all\n    -- should be true as only unset within section\n    guard (t == true)\n  trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/UnsetOption.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  run_tac", "tactic_state": "\u22a2 True"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2227 d) (h2 : e \u2227 f) : True := by\n  casesm* _\u2228_, _\u2227_\n  \u00b7 clear \u2039a\u203a \u2039b\u203a \u2039e\u203a \u2039f\u203a; (fail_if_success clear \u2039c\u203a); trivial\n  \u00b7 clear \u2039c\u203a \u2039d\u203a \u2039e\u203a \u2039f\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d e f : Prop\nh : a \u2227 b \u2228 c \u2227 d\nh2 : e \u2227 f\n\u22a2 True"}, {"line": "  casesm* _\u2228_, _\u2227_", "tactic_state": "case inl.intro.intro\na b c d e f : Prop\nleft\u271d\u00b9 : e\nright\u271d\u00b9 : f\nleft\u271d : a\nright\u271d : b\n\u22a2 True\n---\ncase inr.intro.intro\na b c d e f : Prop\nleft\u271d\u00b9 : e\nright\u271d\u00b9 : f\nleft\u271d : c\nright\u271d : d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a\u203a \u2039b\u203a \u2039e\u203a \u2039f\u203a; (fail_if_success clear \u2039c\u203a); trivial", "tactic_state": "case inl.intro.intro\na b c d e f : Prop\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039c\u203a \u2039d\u203a \u2039e\u203a \u2039f\u203a; trivial", "tactic_state": "case inl.intro.intro\na b c d e f : Prop\n\u22a2 True"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2227 d) : True := by\n  fail_if_success casesm* _\u2227_ -- no match expected\n  clear \u2039a \u2227 b \u2228 c \u2227 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2227 d\n\u22a2 True"}, {"line": "  fail_if_success casesm* _\u2227_ -- no match expected", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2227 d\n\u22a2 True"}, {"line": "  clear \u2039a \u2227 b \u2228 c \u2227 d\u203a; trivial", "tactic_state": "a b c d : Prop\n\u22a2 True"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  casesm* _\u2228_\n  \u00b7 clear \u2039a \u2227 b\u203a; trivial\n  \u00b7 clear \u2039c\u203a; trivial\n  \u00b7 clear \u2039d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  casesm* _\u2228_", "tactic_state": "case inl\na b c d : Prop\nh : a \u2227 b\n\u22a2 True\n---\ncase inr.inl\na b c d : Prop\nh : c\n\u22a2 True\n---\ncase inr.inr\na b c d : Prop\nh : d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a \u2227 b\u203a; trivial", "tactic_state": "case inl\na b c d : Prop\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039c\u203a; trivial", "tactic_state": ""}, {"line": "  \u00b7 clear \u2039d\u203a; trivial", "tactic_state": "case inr.inl\na b c d : Prop\n\u22a2 True"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  casesm _\u2228_\n  \u00b7 clear \u2039a \u2227 b\u203a; trivial\n  \u00b7 clear \u2039c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  casesm _\u2228_", "tactic_state": "case inl\na b c d : Prop\nh : a \u2227 b\n\u22a2 True\n---\ncase inr\na b c d : Prop\nh : c \u2228 d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a \u2227 b\u203a; trivial", "tactic_state": "case inl\na b c d : Prop\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039c \u2228 d\u203a; trivial", "tactic_state": ""}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  cases_type And Or\n  \u00b7 clear \u2039a \u2227 b\u203a; trivial\n  \u00b7 clear \u2039c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  cases_type And Or", "tactic_state": "case inl\na b c d : Prop\nh : a \u2227 b\n\u22a2 True\n---\ncase inr\na b c d : Prop\nh : c \u2228 d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a \u2227 b\u203a; trivial", "tactic_state": "case inl\na b c d : Prop\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039c \u2228 d\u203a; trivial", "tactic_state": ""}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  fail_if_success cases_type* And -- no match expected\n  \u00b7 clear \u2039a \u2227 b \u2228 c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  fail_if_success cases_type* And -- no match expected", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a \u2227 b \u2228 c \u2228 d\u203a; trivial", "tactic_state": "a b c d : Prop\n\u22a2 True"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  cases_type Or\n  \u00b7 clear \u2039a \u2227 b\u203a; trivial\n  \u00b7 clear \u2039c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  cases_type Or", "tactic_state": "case inl\na b c d : Prop\nh : a \u2227 b\n\u22a2 True\n---\ncase inr\na b c d : Prop\nh : c \u2228 d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a \u2227 b\u203a; trivial", "tactic_state": "case inl\na b c d : Prop\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039c \u2228 d\u203a; trivial", "tactic_state": ""}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  cases_type* Or\n  \u00b7 clear \u2039a \u2227 b\u203a; trivial\n  \u00b7 clear \u2039c\u203a; trivial\n  \u00b7 clear \u2039d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  cases_type* Or", "tactic_state": "case inl\na b c d : Prop\nh : a \u2227 b\n\u22a2 True\n---\ncase inr.inl\na b c d : Prop\nh : c\n\u22a2 True\n---\ncase inr.inr\na b c d : Prop\nh : d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a \u2227 b\u203a; trivial", "tactic_state": "case inl\na b c d : Prop\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039c\u203a; trivial", "tactic_state": ""}, {"line": "  \u00b7 clear \u2039d\u203a; trivial", "tactic_state": "case inr.inl\na b c d : Prop\n\u22a2 True"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  fail_if_success cases_type!* And Or -- no match expected\n  \u00b7 clear \u2039a \u2227 b \u2228 c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  fail_if_success cases_type!* And Or -- no match expected", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a \u2227 b \u2228 c \u2228 d\u203a; trivial", "tactic_state": "a b c d : Prop\n\u22a2 True"}]}
{"declaration": "example (h : a \u2227 b \u2227 (c \u2228 d)) : True := by\n  cases_type! And Or\n  \u00b7 clear \u2039a\u203a \u2039b \u2227 (c \u2228 d)\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2227 (c \u2228 d)\n\u22a2 True"}, {"line": "  cases_type! And Or", "tactic_state": "case intro\na b c d : Prop\nh : a\nright\u271d : b \u2227 (c \u2228 d)\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a\u203a \u2039b \u2227 (c \u2228 d)\u203a; trivial", "tactic_state": "case intro\na b c d : Prop\n\u22a2 True"}]}
{"declaration": "example (h : a \u2227 b \u2227 (c \u2228 d)) : True := by\n  cases_type!* And Or\n  \u00b7 clear \u2039a\u203a \u2039b\u203a \u2039c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2227 (c \u2228 d)\n\u22a2 True"}, {"line": "  cases_type!* And Or", "tactic_state": "case intro.intro\na b c d : Prop\nh : a\nright\u271d\u00b9 : b\nright\u271d : c \u2228 d\n\u22a2 True"}, {"line": "  \u00b7 clear \u2039a\u203a \u2039b\u203a \u2039c \u2228 d\u203a; trivial", "tactic_state": "case intro.intro\na b c d : Prop\n\u22a2 True"}]}
{"declaration": "example (_ : Test n) (h2 : Test (m + 1)) : True := by\n  cases_type!* Test\n  \u00b7 clear \u2039Test n\u203a \u2039False\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nTest : x\u271d\u00b9\nx\u271d : sorry\nh2 : sorry\n\u22a2 True"}, {"line": "  cases_type!* Test", "tactic_state": "x\u271d\u00b9 : Sort u_1\nTest : x\u271d\u00b9\nx\u271d : sorry\nh2 : sorry\n\u22a2 True"}]}
{"declaration": "example (_ : Test n) (h2 : Test (m + 1)) : True := by\n  cases_type Test\n  \u00b7 clear \u2039Test (m + 1)\u203a; trivial\n  \u00b7 clear \u2039False\u203a \u2039Test (m + 1)\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nTest : x\u271d\u00b9\nx\u271d : sorry\nh2 : sorry\n\u22a2 True"}, {"line": "  cases_type Test", "tactic_state": "x\u271d\u00b9 : Sort u_1\nTest : x\u271d\u00b9\nx\u271d : sorry\nh2 : sorry\n\u22a2 True"}]}
{"declaration": "example (_ : Test n) (h2 : Test (m + 1)) : True := by\n  cases_type* Test\n  \u00b7 clear \u2039False\u203a; trivial\n  \u00b7 clear \u2039False\u203a; clear \u2039False\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nTest : x\u271d\u00b9\nx\u271d : sorry\nh2 : sorry\n\u22a2 True"}, {"line": "  cases_type* Test", "tactic_state": "x\u271d\u00b9 : Sort u_1\nTest : x\u271d\u00b9\nx\u271d : sorry\nh2 : sorry\n\u22a2 True"}]}
{"declaration": "example : True \u2227 True \u2227 True := by\n  fail_if_success constructorm* True, _\u2228_ -- no match expected\n  guard_target = True \u2227 True \u2227 True\n  constructorm _\u2227_\n  \u00b7 guard_target = True; constructorm True\n  \u00b7 guard_target = True \u2227 True; constructorm* True, _\u2227_\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True \u2227 True \u2227 True"}, {"line": "  fail_if_success constructorm* True, _\u2228_ -- no match expected", "tactic_state": "\u22a2 True \u2227 True \u2227 True"}, {"line": "  guard_target = True \u2227 True \u2227 True", "tactic_state": "\u22a2 True \u2227 True \u2227 True"}, {"line": "  constructorm _\u2227_", "tactic_state": "case left\n\u22a2 True\n---\ncase right\n\u22a2 True \u2227 True"}, {"line": "  \u00b7 guard_target = True; constructorm True", "tactic_state": "case left\n\u22a2 True"}, {"line": "  \u00b7 guard_target = True \u2227 True; constructorm* True, _\u2227_", "tactic_state": ""}]}
{"declaration": "example (n : Nat) : True := by\n  fail_if_success casesm! Nat  -- two constructors, so `casesm!` doesn't fire\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "  fail_if_success casesm! Nat  -- two constructors, so `casesm!` doesn't fire", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (h : Array Nat) : True := by\n  casesm! Array _\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : Array \u2115\n\u22a2 True"}, {"line": "  casesm! Array _", "tactic_state": "case mk\nh : List \u2115\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example (h : Array Nat) : True := by\n  casesm Array _\n  -- user facing name is preserved:\n  guard_hyp h : List Nat\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : Array \u2115\n\u22a2 True"}, {"line": "  casesm Array _", "tactic_state": "case mk\nh : List \u2115\n\u22a2 True"}, {"line": "  -- user facing name is preserved:", "tactic_state": "case mk\nh : List \u2115\n\u22a2 True"}, {"line": "  guard_hyp h : List Nat", "tactic_state": ""}]}
{"declaration": "example (n : Nat) (h : n = 0) : True := by\n  casesm Nat\n  \u00b7 trivial\n  \u00b7 -- user facing name is preserved:\n    guard_hyp h : n + 1 = 0\n    trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh : n = 0\n\u22a2 True"}, {"line": "  casesm Nat", "tactic_state": "case zero\nh : Nat.zero = 0\n\u22a2 True\n---\ncase succ\nn : \u2115\nh : n.succ = 0\n\u22a2 True"}, {"line": "  \u00b7 trivial", "tactic_state": ""}, {"line": "  \u00b7 -- user facing name is preserved:", "tactic_state": "case succ\nn : \u2115\nh : n.succ = 0\n\u22a2 True"}, {"line": "    guard_hyp h : n + 1 = 0", "tactic_state": ""}]}
{"declaration": "example (h : P \u2227 Q) : True := by\n  casesm _ \u2227 _\n  -- user facing name is not used here, because there are multiple new hypotheses.\n  fail_if_success guard_hyp h : P\n  rename_i p q\n  guard_hyp p : P\n  guard_hyp q : Q\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\nh : P \u2227 Q\n\u22a2 True"}, {"line": "  casesm _ \u2227 _", "tactic_state": "case intro\nP Q : Prop\nleft\u271d : P\nright\u271d : Q\n\u22a2 True"}, {"line": "  -- user facing name is not used here, because there are multiple new hypotheses.", "tactic_state": "case intro\nP Q : Prop\nleft\u271d : P\nright\u271d : Q\n\u22a2 True"}, {"line": "  fail_if_success guard_hyp h : P", "tactic_state": "case intro\nP Q : Prop\np : P\nq : Q\n\u22a2 True"}, {"line": "  rename_i p q", "tactic_state": "case intro\nP Q : Prop\np : P\nq : Q\n\u22a2 True"}, {"line": "  guard_hyp p : P", "tactic_state": "case intro\nP Q : Prop\np : P\nq : Q\n\u22a2 True"}, {"line": "  guard_hyp q : Q", "tactic_state": ""}]}
{"declaration": "theorem foo : p \u2227 p := by\n  cases h\n  \u00b7 casesm (_ \u2227 _)\n    constructor <;> assumption\n  \u00b7 casesm (_ \u2227 _)\n    constructor <;> assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": ["{p q r : Prop}", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\n\u22a2 p \u2227 p"}, {"line": "  cases h", "tactic_state": "p : Prop\nx\u271d : ?m.27\n\u22a2 p \u2227 p"}]}
{"declaration": "example : (2 : \u211d) ^ (3 : \u211d) = 8 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 2 ^ 3 = 8"}]}
{"declaration": "example : (1 : \u211d) ^ (20 : \u211d) = 1 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 ^ 20 = 1"}]}
{"declaration": "example : (-2 : \u211d) ^ (3 : \u211d) = -8 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (-2) ^ 3 = -8"}]}
{"declaration": "example : (1/5 : \u211d) ^ (2 : \u211d) = 1/25 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (1 / 5) ^ 2 = 1 / 25"}]}
{"declaration": "example : (-1/3 : \u211d) ^ (-3 : \u211d) = -27 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (-1 / 3) ^ (-3) = -27"}]}
{"declaration": "example : (1/2 : \u211d) ^ (-3 : \u211d) = 8 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (1 / 2) ^ (-3) = 8"}]}
{"declaration": "example : (2 : \u211d) ^ (-3 : \u211d) = 1/8 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 2 ^ (-3) = 1 / 8"}]}
{"declaration": "example : (-2 : \u211d) ^ (-3 : \u211d) = -1/8 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (-2) ^ (-3) = -1 / 8"}]}
{"declaration": "example (a b : \u2115) : (a : \u211a) \u2264 b \u2194 a \u2264 b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 \u2191a \u2264 \u2191b \u2194 a \u2264 b"}]}
{"declaration": "example (a b : \u2115) : (a : \u211a) < b \u2194 a < b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 \u2191a < \u2191b \u2194 a < b"}]}
{"declaration": "example (a b : \u2115) : (a : \u211a) = b \u2194 a = b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 \u2191a = \u2191b \u2194 a = b"}]}
{"declaration": "example (a b : \u2115) : (a : \u211a) \u2260 b \u2194 a \u2260 b := by qify\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 \u2191a \u2260 \u2191b \u2194 a \u2260 b"}]}
{"declaration": "example (a b : \u2124) : (a : \u211a) \u2264 b \u2194 a \u2264 b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 \u2191a \u2264 \u2191b \u2194 a \u2264 b"}]}
{"declaration": "example (a b : \u2124) : (a : \u211a) < b \u2194 a < b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 \u2191a < \u2191b \u2194 a < b"}]}
{"declaration": "example (a b : \u2124) : (a : \u211a) = b \u2194 a = b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 \u2191a = \u2191b \u2194 a = b"}]}
{"declaration": "example (a b : \u2124) : (a : \u211a) \u2260 b \u2194 a \u2260 b := by qify\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 \u2191a \u2260 \u2191b \u2194 a \u2260 b"}]}
{"declaration": "example (a b : \u211a\u22650) : (a : \u211a) \u2264 b \u2194 a \u2264 b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211a\u22650\n\u22a2 \u2191a \u2264 \u2191b \u2194 a \u2264 b"}]}
{"declaration": "example (a b : \u211a\u22650) : (a : \u211a) < b \u2194 a < b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211a\u22650\n\u22a2 \u2191a < \u2191b \u2194 a < b"}]}
{"declaration": "example (a b : \u211a\u22650) : (a : \u211a) = b \u2194 a = b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211a\u22650\n\u22a2 \u2191a = \u2191b \u2194 a = b"}]}
{"declaration": "example (a b : \u211a\u22650) : (a : \u211a) \u2260 b \u2194 a \u2260 b := by qify\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211a\u22650\n\u22a2 \u2191a \u2260 \u2191b \u2194 a \u2260 b"}]}
{"declaration": "example (a b c : \u2115) (h : a - b = c) (hab : b \u2264 a) : a = c + b := by\n  qify [hab] at h \u22a2 -- `zify` does the same thing here.\n  exact sub_eq_iff_eq_add.1 h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : a - b = c\nhab : b \u2264 a\n\u22a2 a = c + b"}, {"line": "  qify [hab] at h \u22a2 -- `zify` does the same thing here.", "tactic_state": "a b c : \u2115\nhab : b \u2264 a\nh : \u2191a - \u2191b = \u2191c\n\u22a2 \u2191a = \u2191c + \u2191b"}, {"line": "  exact sub_eq_iff_eq_add.1 h", "tactic_state": ""}]}
{"declaration": "example (a b c : \u211a\u22650) (h : a - b = c) (hab : b \u2264 a) : a = c + b := by\n  qify [hab] at h \u22a2\n  exact sub_eq_iff_eq_add.1 h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u211a\u22650\nh : a - b = c\nhab : b \u2264 a\n\u22a2 a = c + b"}, {"line": "  qify [hab] at h \u22a2", "tactic_state": "a b c : \u211a\u22650\nhab : b \u2264 a\nh : \u2191a - \u2191b = \u2191c\n\u22a2 \u2191a = \u2191c + \u2191b"}, {"line": "  exact sub_eq_iff_eq_add.1 h", "tactic_state": ""}]}
{"declaration": "example (a b c : \u2124) (h : a / b = c) (hab : b \u2223 a) (hb : b \u2260 0) : a = c * b := by\n  qify [hab] at h hb \u22a2\n  exact (div_eq_iff hb).1 h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2124\nh : a / b = c\nhab : b \u2223 a\nhb : b \u2260 0\n\u22a2 a = c * b"}, {"line": "  qify [hab] at h hb \u22a2", "tactic_state": "a b c : \u2124\nhab : b \u2223 a\nh : \u2191a / \u2191b = \u2191c\nhb : \u2191b \u2260 0\n\u22a2 \u2191a = \u2191c * \u2191b"}, {"line": "  exact (div_eq_iff hb).1 h", "tactic_state": ""}]}
{"declaration": "example (a b c : \u2115) (h : a / b = c) (hab : b \u2223 a) (hb : b \u2260 0) : a = c * b := by\n  qify [hab] at h hb \u22a2\n  exact (div_eq_iff hb).1 h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : a / b = c\nhab : b \u2223 a\nhb : b \u2260 0\n\u22a2 a = c * b"}, {"line": "  qify [hab] at h hb \u22a2", "tactic_state": "a b c : \u2115\nhab : b \u2223 a\nh : \u2191a / \u2191b = \u2191c\nhb : \u2191b \u2260 0\n\u22a2 \u2191a = \u2191c * \u2191b"}, {"line": "  exact (div_eq_iff hb).1 h", "tactic_state": ""}]}
{"declaration": "example : \u2203 x : Nat, x = x := by\n  existsi 42\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExistsI.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}, {"line": "  existsi 42", "tactic_state": "\u22a2 42 = 42"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : \u2203 x : Nat, \u2203 y : Nat, x = y := by\n  existsi 42, 42\n  rfl", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExistsI.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x y, x = y"}, {"line": "  existsi 42, 42", "tactic_state": "\u22a2 42 = 42"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : Nat := by\n  have h : Nat\n  exact 5\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2115"}, {"line": "  have h : Nat", "tactic_state": "case h\n\u22a2 \u2115\n---\nh : \u2115\n\u22a2 \u2115"}, {"line": "  exact 5", "tactic_state": "h : \u2115\n\u22a2 \u2115"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example : Nat := by\n  have : Nat\n  \u00b7 exact 5\n  exact this\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2115"}, {"line": "  have : Nat", "tactic_state": "case this\n\u22a2 \u2115\n---\nthis : \u2115\n\u22a2 \u2115"}, {"line": "  \u00b7 exact 5", "tactic_state": ""}, {"line": "  exact this", "tactic_state": ""}]}
{"declaration": "example {a : Nat} : a = a := by\n  have h : a = a\n  \u00b7 rfl\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 a = a"}, {"line": "  have h : a = a", "tactic_state": "case h\na : \u2115\n\u22a2 a = a\n---\na : \u2115\nh : a = a\n\u22a2 a = a"}, {"line": "  \u00b7 rfl", "tactic_state": ""}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example {a : Nat} : a = a := by\n  have : a = a\n  \u00b7 rfl\n  exact this\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 a = a"}, {"line": "  have : a = a", "tactic_state": "case this\na : \u2115\n\u22a2 a = a\n---\na : \u2115\nthis : a = a\n\u22a2 a = a"}, {"line": "  \u00b7 rfl", "tactic_state": ""}, {"line": "  exact this", "tactic_state": ""}]}
{"declaration": "example : True := by\n  let _N; -- FIXME: https://github.com/leanprover/lean4/issues/1670\n  exact Nat\n  have\n  \u00b7 exact 0\n  have _h : Nat\n  \u00b7 exact this\n  have _h' x : x < x + 1\n  \u00b7 exact Nat.lt.base x\n  have _h'' (x : Nat) : x < x + 1\n  \u00b7 exact Nat.lt.base x\n  let _m\n  \u00b7 exact 6\n  let _m' x (y : Nat) : x + y = y + x\n  rw [Nat.add_comm]\n  have _q\n  \u00b7 exact 6\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  let _N; -- FIXME: https://github.com/leanprover/lean4/issues/1670", "tactic_state": "case _N\n\u22a2 ?m.5\n---\n_N : ?m.5 := ?_N\n\u22a2 True"}, {"line": "  exact Nat", "tactic_state": "_N : Type := \u2115\n\u22a2 True"}, {"line": "  have", "tactic_state": "case this\n_N : Type := \u2115\n\u22a2 ?m.12\n---\n_N : Type := \u2115\nthis : ?m.12\n\u22a2 True"}, {"line": "  \u00b7 exact 0", "tactic_state": ""}, {"line": "  have _h : Nat", "tactic_state": "case _h\n_N : Type := \u2115\nthis : \u2115\n\u22a2 \u2115\n---\n_N : Type := \u2115\nthis _h : \u2115\n\u22a2 True"}, {"line": "  \u00b7 exact this", "tactic_state": ""}, {"line": "  have _h' x : x < x + 1", "tactic_state": "case _h'\n_N : Type := \u2115\nthis _h x : \u2115\n\u22a2 x < x + 1\n---\n_N : Type := \u2115\nthis _h : \u2115\n_h' : \u2200 (x : \u2115), x < x + 1\n\u22a2 True"}, {"line": "  \u00b7 exact Nat.lt.base x", "tactic_state": ""}, {"line": "  have _h'' (x : Nat) : x < x + 1", "tactic_state": "case _h''\n_N : Type := \u2115\nthis _h : \u2115\n_h' : \u2200 (x : \u2115), x < x + 1\nx : \u2115\n\u22a2 x < x + 1\n---\n_N : Type := \u2115\nthis _h : \u2115\n_h' _h'' : \u2200 (x : \u2115), x < x + 1\n\u22a2 True"}, {"line": "  \u00b7 exact Nat.lt.base x", "tactic_state": ""}, {"line": "  let _m", "tactic_state": "case _m\n_N : Type := \u2115\nthis _h : \u2115\n_h' _h'' : \u2200 (x : \u2115), x < x + 1\n\u22a2 ?m.883\n---\n_N : Type := \u2115\nthis _h : \u2115\n_h' _h'' : \u2200 (x : \u2115), x < x + 1\n_m : ?m.883 := ?_m\n\u22a2 True"}, {"line": "  \u00b7 exact 6", "tactic_state": ""}, {"line": "  let _m' x (y : Nat) : x + y = y + x", "tactic_state": "case _m'\n_N : Type := \u2115\nthis _h : \u2115\n_h' _h'' : \u2200 (x : \u2115), x < x + 1\n_m : \u2115 := 6\nx y : \u2115\n\u22a2 x + y = y + x\n---\n_N : Type := \u2115\nthis _h : \u2115\n_h' _h'' : \u2200 (x : \u2115), x < x + 1\n_m : \u2115 := 6\n_m' : \u2200 (x y : \u2115), x + y = y + x := fun x y => ?_m'\n\u22a2 True"}, {"line": "  rw [Nat.add_comm]", "tactic_state": "_N : Type := \u2115\nthis _h : \u2115\n_h' _h'' : \u2200 (x : \u2115), x < x + 1\n_m : \u2115 := 6\n_m' : \u2200 (x y : \u2115), x + y = y + x :=\n  fun x y => Eq.mpr (id (congrArg (fun _a => _a = y + x) (Nat.add_comm x y))) (Eq.refl (y + x))\n\u22a2 True"}, {"line": "  have _q", "tactic_state": "case _q\n_N : Type := \u2115\nthis _h : \u2115\n_h' _h'' : \u2200 (x : \u2115), x < x + 1\n_m : \u2115 := 6\n_m' : \u2200 (x y : \u2115), x + y = y + x :=\n  fun x y => Eq.mpr (id (congrArg (fun _a => _a = y + x) (Nat.add_comm x y))) (Eq.refl (y + x))\n\u22a2 ?m.1001\n---\n_N : Type := \u2115\nthis _h : \u2115\n_h' _h'' : \u2200 (x : \u2115), x < x + 1\n_m : \u2115 := 6\n_m' : \u2200 (x y : \u2115), x + y = y + x :=\n  fun x y => Eq.mpr (id (congrArg (fun _a => _a = y + x) (Nat.add_comm x y))) (Eq.refl (y + x))\n_q : ?m.1001\n\u22a2 True"}, {"line": "  \u00b7 exact 6", "tactic_state": ""}, {"line": "  simp", "tactic_state": ""}]}
{"declaration": "example : True := by have h : Nat.zero", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}]}
{"declaration": "theorem ex1 (a b c : Nat) (h : a = b) : a + c = b + c := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : a = b\n\u22a2 a + c = b + c"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex2 (a b : Nat) (h : a = b) : \u2200 c, a + c = b + c := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 \u2200 (c : \u2115), a + c = b + c"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex3 (a b : Nat) (h : a = b) : (fun c => a + c) = (fun c => b + c) := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 (fun c => a + c) = fun c => b + c"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex4 (a b : Nat) : Fin (a + b) = Fin (b + a) := by\n  congr! 1\n  guard_target = a + b = b + a\n  apply Nat.add_comm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 Fin (a + b) = Fin (b + a)"}, {"line": "  congr! 1", "tactic_state": "case h.e'_1\na b : \u2115\n\u22a2 a + b = b + a"}, {"line": "  guard_target = a + b = b + a", "tactic_state": "case h.e'_1\na b : \u2115\n\u22a2 a + b = b + a"}, {"line": "  apply Nat.add_comm", "tactic_state": ""}]}
{"declaration": "theorem ex5 : ((a : Nat) \u2192 Fin (a + 1)) = ((a : Nat) \u2192 Fin (1 + a)) := by\n  congr! 2 with a\n  guard_target = a + 1 = 1 + a\n  apply Nat.add_comm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 ((a : \u2115) \u2192 Fin (a + 1)) = ((a : \u2115) \u2192 Fin (1 + a))"}, {"line": "  congr! 2 with a", "tactic_state": "case h.h.e'_1\na : \u2115\n\u22a2 a + 1 = 1 + a"}, {"line": "  guard_target = a + 1 = 1 + a", "tactic_state": "case h.h.e'_1\na : \u2115\n\u22a2 a + 1 = 1 + a"}, {"line": "  apply Nat.add_comm", "tactic_state": ""}]}
{"declaration": "theorem ex6 : ((a : Nat) \u00d7 Fin (a + 1)) = ((a : Nat) \u00d7 Fin (1 + a)) := by\n  congr! 3 with a\n  guard_target = a + 1 = 1 + a\n  apply Nat.add_comm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 ((a : \u2115) \u00d7 Fin (a + 1)) = ((a : \u2115) \u00d7 Fin (1 + a))"}, {"line": "  congr! 3 with a", "tactic_state": "case h.e'_2.h.h.e'_1\na : \u2115\n\u22a2 a + 1 = 1 + a"}, {"line": "  guard_target = a + 1 = 1 + a", "tactic_state": "case h.e'_2.h.h.e'_1\na : \u2115\n\u22a2 a + 1 = 1 + a"}, {"line": "  apply Nat.add_comm", "tactic_state": ""}]}
{"declaration": "theorem ex7 (p : Prop) (h1 h2 : p) : h1 = h2 := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\nh1 h2 : p\n\u22a2 h1 = h2"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex8 (p q : Prop) (h1 : p) (h2 : q) : HEq h1 h2 := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh1 : p\nh2 : q\n\u22a2 HEq h1 h2"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex9 (a b : Nat) (h : a = b) : a + 1 \u2264 b + 1 := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a + 1 \u2264 b + 1"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex10 (x y : Unit) : x = y := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : Unit\n\u22a2 x = y"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex11 (p q r : Nat \u2192 Prop) (h : q = r) : (\u2200 n, p n \u2192 q n) \u2194 (\u2200 n, p n \u2192 r n) := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : \u2115 \u2192 Prop\nh : q = r\n\u22a2 (\u2200 (n : \u2115), p n \u2192 q n) \u2194 \u2200 (n : \u2115), p n \u2192 r n"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex12 (p q : Prop) (h : p \u2194 q) : p = q := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh : p \u2194 q\n\u22a2 p = q"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex13 (x y : \u03b1) (h : x = y) (f : \u03b1 \u2192 Nat) : f x = f y := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nx y : \u03b1\nh : x = y\nf : \u03b1 \u2192 \u2115\n\u22a2 f x = f y"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "theorem ex14 {\u03b1 : Type} (f : Nat \u2192 Nat) (h : \u2200 x, f x = 0) (z : \u03b1) (hz : HEq z 0) :\n    HEq f (fun (_ : \u03b1) => z) := by\n  congr!\n  \u00b7 guard_target = Nat = \u03b1\n    exact type_eq_of_heq hz.symm\n  next n x _ =>\n    guard_target = HEq (f n) z\n    rw [h]\n    exact hz.symm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nf : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = 0\nz : \u03b1\nhz : HEq z 0\n\u22a2 HEq f fun x => z"}, {"line": "  congr!", "tactic_state": "case h\u03b1\n\u03b1 : Type\nf : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = 0\nz : \u03b1\nhz : HEq z 0\n\u22a2 \u2115 = \u03b1\n---\ncase h\n\u03b1 : Type\nf : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = 0\nz : \u03b1\nhz : HEq z 0\na\u271d\u00b9 : \u2115\na'\u271d : \u03b1\na\u271d : HEq a\u271d\u00b9 a'\u271d\n\u22a2 HEq (f a\u271d\u00b9) z"}, {"line": "  \u00b7 guard_target = Nat = \u03b1", "tactic_state": "case h\u03b1\n\u03b1 : Type\nf : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = 0\nz : \u03b1\nhz : HEq z 0\n\u22a2 \u2115 = \u03b1"}, {"line": "    exact type_eq_of_heq hz.symm", "tactic_state": ""}, {"line": "  next n x _ =>", "tactic_state": ""}]}
{"declaration": "theorem ex15 (p q : Nat \u2192 Prop) :\n    (\u2200 \u03b5 > 0, p \u03b5) \u2194 \u2200 \u03b5 > 0, q \u03b5 := by\n  congr! 2 with \u03b5 h\u03b5\n  guard_hyp h\u03b5 : \u03b5 > 0\n  guard_target = p \u03b5 \u2194 q \u03b5\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u2115 \u2192 Prop\n\u22a2 (\u2200 \u03b5 > 0, p \u03b5) \u2194 \u2200 \u03b5 > 0, q \u03b5"}, {"line": "  congr! 2 with \u03b5 h\u03b5", "tactic_state": "case a.h.h'.a\np q : \u2115 \u2192 Prop\n\u03b5 : \u2115\nh\u03b5 : \u03b5 > 0\n\u22a2 p \u03b5 \u2194 q \u03b5"}, {"line": "  guard_hyp h\u03b5 : \u03b5 > 0", "tactic_state": "case a.h.h'.a\np q : \u2115 \u2192 Prop\n\u03b5 : \u2115\nh\u03b5 : \u03b5 > 0\n\u22a2 p \u03b5 \u2194 q \u03b5"}, {"line": "  guard_target = p \u03b5 \u2194 q \u03b5", "tactic_state": "case a.h.h'.a\np q : \u2115 \u2192 Prop\n\u03b5 : \u2115\nh\u03b5 : \u03b5 > 0\n\u22a2 p \u03b5 \u2194 q \u03b5"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (s t : Set \u03b1) : (\u2115 \u00d7 Subtype s) = (\u2115 \u00d7 Subtype t) := by\n  congr! 1\n  guard_target = Subtype s = Subtype t\n  congr! 1\n  guard_target = s = t\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 (\u2115 \u00d7 Subtype s) = (\u2115 \u00d7 Subtype t)"}, {"line": "  congr! 1", "tactic_state": "case h.e'_2\n\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 Subtype s = Subtype t"}, {"line": "  guard_target = Subtype s = Subtype t", "tactic_state": "case h.e'_2\n\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 Subtype s = Subtype t"}, {"line": "  congr! 1", "tactic_state": "case h.e'_2.h.e'_2\n\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 s = t"}, {"line": "  guard_target = s = t", "tactic_state": "case h.e'_2.h.e'_2\n\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 s = t"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (s t : Set \u03b1) (f : Subtype s \u2192 \u03b1) (g : Subtype t \u2192 \u03b1) :\n    Set.image f Set.univ = Set.image g Set.univ := by\n  congr!\n  \u00b7 guard_target = s = t\n    exact test_sorry\n  \u00b7 guard_target = HEq f g\n    exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\nf : Subtype s \u2192 \u03b1\ng : Subtype t \u2192 \u03b1\n\u22a2 f '' Set.univ = g '' Set.univ"}, {"line": "  congr!", "tactic_state": "case h.e'_1.h.e'_2\n\u03b1 : Type u_1\ns t : Set \u03b1\nf : Subtype s \u2192 \u03b1\ng : Subtype t \u2192 \u03b1\n\u22a2 s = t\n---\ncase h.e'_3\n\u03b1 : Type u_1\ns t : Set \u03b1\nf : Subtype s \u2192 \u03b1\ng : Subtype t \u2192 \u03b1\ne_1\u271d : Subtype s = Subtype t\n\u22a2 HEq f g"}, {"line": "  \u00b7 guard_target = s = t", "tactic_state": "case h.e'_1.h.e'_2\n\u03b1 : Type u_1\ns t : Set \u03b1\nf : Subtype s \u2192 \u03b1\ng : Subtype t \u2192 \u03b1\n\u22a2 s = t"}, {"line": "    exact test_sorry", "tactic_state": ""}, {"line": "  \u00b7 guard_target = HEq f g", "tactic_state": "case h.e'_3\n\u03b1 : Type u_1\ns t : Set \u03b1\nf : Subtype s \u2192 \u03b1\ng : Subtype t \u2192 \u03b1\ne_1\u271d : Subtype s = Subtype t\n\u22a2 HEq f g"}, {"line": "    exact test_sorry", "tactic_state": ""}]}
{"declaration": "example {\u03b9 \u03ba : Type u} (f : \u03b9 \u2192 \u03b1) (g : \u03ba \u2192 \u03b1) :\n    Set.image f Set.univ = Set.image g Set.univ := by\n  congr!\n  guard_target = Set.image f Set.univ = Set.image g Set.univ\n  congr! (config := {typeEqs := true})\n  \u00b7 guard_target = \u03b9 = \u03ba\n    exact test_sorry\n  \u00b7 guard_target = HEq f g\n    exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\n\u22a2 f '' Set.univ = g '' Set.univ"}, {"line": "  congr!", "tactic_state": "\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\n\u22a2 f '' Set.univ = g '' Set.univ"}, {"line": "  guard_target = Set.image f Set.univ = Set.image g Set.univ", "tactic_state": "\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\n\u22a2 f '' Set.univ = g '' Set.univ"}, {"line": "  congr! (config := {typeEqs := true})", "tactic_state": "case h.e'_1\n\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\n\u22a2 \u03b9 = \u03ba\n---\ncase h.e'_3\n\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\ne_1\u271d : \u03b9 = \u03ba\n\u22a2 HEq f g"}, {"line": "  \u00b7 guard_target = \u03b9 = \u03ba", "tactic_state": "case h.e'_1\n\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\n\u22a2 \u03b9 = \u03ba"}, {"line": "    exact test_sorry", "tactic_state": ""}, {"line": "  \u00b7 guard_target = HEq f g", "tactic_state": "case h.e'_3\n\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\ne_1\u271d : \u03b9 = \u03ba\n\u22a2 HEq f g"}, {"line": "    exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (s : Set \u03b1) (t : Set \u03b2) : (\u2115 \u00d7 Subtype s) = (\u2115 \u00d7 Subtype t) := by\n  congr!\n  guard_target = Subtype s = Subtype t\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type u_1\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 (\u2115 \u00d7 Subtype s) = (\u2115 \u00d7 Subtype t)"}, {"line": "  congr!", "tactic_state": "case h.e'_2\n\u03b1 \u03b2 : Type u_1\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 Subtype s = Subtype t"}, {"line": "  guard_target = Subtype s = Subtype t", "tactic_state": "case h.e'_2\n\u03b1 \u03b2 : Type u_1\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 Subtype s = Subtype t"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (m n : Nat) (h : m = n) (x : Fin m) (y : Fin n) : HEq (x + x) (y + y) := by\n  congr!\n  guard_target = HEq x y\n  exact test_sorry\n  guard_target = HEq x y\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\n\u22a2 HEq (x + x) (y + y)"}, {"line": "  congr!", "tactic_state": "case e'_5\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_1\u271d : Fin m = Fin n\n\u22a2 HEq x y\n---\ncase e'_6\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_2\u271d : Fin m = Fin n\n\u22a2 HEq x y"}, {"line": "  guard_target = HEq x y", "tactic_state": "case e'_5\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_1\u271d : Fin m = Fin n\n\u22a2 HEq x y\n---\ncase e'_6\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_2\u271d : Fin m = Fin n\n\u22a2 HEq x y"}, {"line": "  exact test_sorry", "tactic_state": "case e'_6\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_2\u271d : Fin m = Fin n\n\u22a2 HEq x y"}, {"line": "  guard_target = HEq x y", "tactic_state": "case e'_6\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_2\u271d : Fin m = Fin n\n\u22a2 HEq x y"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (p q r : Prop) : p \u2227 q \u2194 p \u2227 r := by\n  congr!\n  guard_target = q \u2194 r\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : Prop\n\u22a2 p \u2227 q \u2194 p \u2227 r"}, {"line": "  congr!", "tactic_state": "case a.h.e'_2.a\np q r : Prop\n\u22a2 q \u2194 r"}, {"line": "  guard_target = q \u2194 r", "tactic_state": "case a.h.e'_2.a\np q r : Prop\n\u22a2 q \u2194 r"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (\u03b1 \u03b2) [inst1 : Add \u03b1] [inst2 : Add \u03b2] (x : \u03b1) (y : \u03b2) : HEq (x + x) (y + y) := by\n  congr!\n  guard_target = HEq (x + x) (y + y)\n  -- But with typeEqs we can get it to generate the congruence anyway:\n  have : \u03b1 = \u03b2 := test_sorry\n  have : HEq inst1 inst2 := test_sorry\n  congr! (config := { typeEqs := true })\n  guard_target = HEq x y\n  exact test_sorry\n  guard_target = HEq x y\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 HEq (x + x) (y + y)"}, {"line": "  congr!", "tactic_state": "\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 HEq (x + x) (y + y)"}, {"line": "  guard_target = HEq (x + x) (y + y)", "tactic_state": "\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 HEq (x + x) (y + y)"}, {"line": "  -- But with typeEqs we can get it to generate the congruence anyway:", "tactic_state": "\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\nthis : \u03b1 = \u03b2\n\u22a2 HEq (x + x) (y + y)"}, {"line": "  have : \u03b1 = \u03b2 := test_sorry", "tactic_state": "\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\nthis\u271d : \u03b1 = \u03b2\nthis : HEq inst1 inst2\n\u22a2 HEq (x + x) (y + y)"}, {"line": "  have : HEq inst1 inst2 := test_sorry", "tactic_state": "case e'_5\n\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\nthis\u271d : \u03b1 = \u03b2\nthis : HEq inst1 inst2\n\u22a2 HEq x y\n---\ncase e'_6\n\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\nthis\u271d : \u03b1 = \u03b2\nthis : HEq inst1 inst2\n\u22a2 HEq x y"}, {"line": "  congr! (config := { typeEqs := true })", "tactic_state": "case e'_5\n\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\nthis\u271d : \u03b1 = \u03b2\nthis : HEq inst1 inst2\n\u22a2 HEq x y\n---\ncase e'_6\n\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\nthis\u271d : \u03b1 = \u03b2\nthis : HEq inst1 inst2\n\u22a2 HEq x y"}, {"line": "  guard_target = HEq x y", "tactic_state": "case e'_6\n\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\nthis\u271d : \u03b1 = \u03b2\nthis : HEq inst1 inst2\n\u22a2 HEq x y"}, {"line": "  exact test_sorry", "tactic_state": "case e'_6\n\u03b1 \u03b2 : Type u_1\ninst1 : Add \u03b1\ninst2 : Add \u03b2\nx : \u03b1\ny : \u03b2\nthis\u271d : \u03b1 = \u03b2\nthis : HEq inst1 inst2\n\u22a2 HEq x y"}, {"line": "  guard_target = HEq x y", "tactic_state": ""}]}
{"declaration": "example (prime : Nat \u2192 Prop) (n : Nat) :\n    prime (2 * n + 1) = prime (n + n + 1) := by\n  congr!\n  \u00b7 guard_target =\u209b (HMul.hMul : Nat \u2192 Nat \u2192 Nat) = HAdd.hAdd\n    exact test_sorry\n  \u00b7 guard_target = 2 = n\n    exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "prime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 prime (2 * n + 1) = prime (n + n + 1)"}, {"line": "  congr!", "tactic_state": "case h.e'_1.h.e'_5.h.e\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 HMul.hMul = HAdd.hAdd\n---\ncase h.e'_1.h.e'_5.h.e'_1\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 = n"}, {"line": "  \u00b7 guard_target =\u209b (HMul.hMul : Nat \u2192 Nat \u2192 Nat) = HAdd.hAdd", "tactic_state": "case h.e'_1.h.e'_5.h.e\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 HMul.hMul = HAdd.hAdd"}, {"line": "    exact test_sorry", "tactic_state": ""}, {"line": "  \u00b7 guard_target = 2 = n", "tactic_state": "case h.e'_1.h.e'_5.h.e'_1\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 = n"}, {"line": "    exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (prime : Nat \u2192 Prop) (n : Nat) :\n    prime (2 * n + 1) = prime (n + n + 1) := by\n  congr! (config := {etaExpand := true})\n  \u00b7 guard_target =\u209b (fun (x y : Nat) => x * y) = (fun (x y : Nat) => x + y)\n    exact test_sorry\n  \u00b7 guard_target = 2 = n\n    exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "prime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 prime (2 * n + 1) = prime (n + n + 1)"}, {"line": "  congr! (config := {etaExpand := true})", "tactic_state": "case h.e'_1.h.e'_5.h.e\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 (fun a a_1 => a * a_1) = fun a a_1 => a + a_1\n---\ncase h.e'_1.h.e'_5.h.e'_1\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 = n"}, {"line": "  \u00b7 guard_target =\u209b (fun (x y : Nat) => x * y) = (fun (x y : Nat) => x + y)", "tactic_state": "case h.e'_1.h.e'_5.h.e\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 (fun a a_1 => a * a_1) = fun a a_1 => a + a_1"}, {"line": "    exact test_sorry", "tactic_state": ""}, {"line": "  \u00b7 guard_target = 2 = n", "tactic_state": "case h.e'_1.h.e'_5.h.e'_1\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 = n"}, {"line": "    exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (prime : Nat \u2192 Prop) (n : Nat) :\n    prime (2 * n + 1) = prime (n + n + 1) := by\n  congr! 2\n  guard_target = 2 * n = n + n\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "prime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 prime (2 * n + 1) = prime (n + n + 1)"}, {"line": "  congr! 2", "tactic_state": "case h.e'_1.h.e'_5\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 * n = n + n"}, {"line": "  guard_target = 2 * n = n + n", "tactic_state": "case h.e'_1.h.e'_5\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 * n = n + n"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (prime : Nat \u2192 Prop) (n : Nat) :\n    prime (2 * n + 1) = prime (n + n + 1) := by\n  congr! (config := .unfoldSameFun)\n  guard_target = 2 * n = n + n\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "prime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 prime (2 * n + 1) = prime (n + n + 1)"}, {"line": "  congr! (config := .unfoldSameFun)", "tactic_state": "case h.e'_1.h.e'_5\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 * n = n + n"}, {"line": "  guard_target = 2 * n = n + n", "tactic_state": "case h.e'_1.h.e'_5\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 * n = n + n"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example : partiallyApplied (True \u2227 True) = partiallyApplied True := by\n  congr!\n  decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\npartiallyApplied : x\u271d\n\u22a2 sorry = sorry"}, {"line": "  congr!", "tactic_state": ""}, {"line": "  decide", "tactic_state": ""}]}
{"declaration": "example (w : walk \u03b1 x y) (w' : walk \u03b1 x' y') (f : \u03b1 \u2192 \u03b2) : HEq (w.map f) (w'.map f) := by\n  congr!\n  guard_target = x = x'\n  exact test_sorry\n  guard_target = y = y'\n  exact test_sorry\n  -- get x = y and y = y' in context for `HEq w w'` goal.\n  have : x = x' := by assumption\n  have : y = y' := by assumption\n  guard_target = HEq w w'\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nwalk : x\u271d\n\u03b1 : Sort u_2\n\u03b2 : Sort u_3\nw : sorry\nw' : sorry\nf : \u03b1 \u2192 \u03b2\n\u22a2 HEq sorry sorry"}, {"line": "  congr!", "tactic_state": ""}, {"line": "  guard_target = x = x'", "tactic_state": ""}]}
{"declaration": "example (w : walk \u03b1 x y) (w' : walk \u03b1 x' y') (f : \u03b1 \u2192 \u03b2) : HEq (w.map f) (w'.map f) := by\n  congr! with rfl rfl\n  guard_target = x = x'\n  exact test_sorry\n  guard_target = y = y'\n  exact test_sorry\n  guard_target = w = w'\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nwalk : x\u271d\n\u03b1 : Sort u_2\n\u03b2 : Sort u_3\nw : sorry\nw' : sorry\nf : \u03b1 \u2192 \u03b2\n\u22a2 HEq sorry sorry"}, {"line": "  congr! with rfl rfl", "tactic_state": ""}, {"line": "  guard_target = x = x'", "tactic_state": ""}]}
{"declaration": "example (s t : MySet \u03b1) (f g : \u03b1 \u2192 \u03b2) (h1 : s = t) (h2 : f = g) :\n    MySet.image f s = MySet.image g t := by\n  congr!\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nMySet : x\u271d\n\u03b1 : Sort u_2\n\u03b2 : Sort u_3\ns : sorry\nt : sorry\nf g : \u03b1 \u2192 \u03b2\nh1 : s = t\nh2 : f = g\n\u22a2 sorry = sorry"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "example (c : Prop \u2192 Prop \u2192 Prop \u2192 Prop) (x x' y z z' : Prop)\n    (h\u2080 : x \u2194 x') (h\u2081 : z \u2194 z') : c x y z \u2194 c x' y z' := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Prop \u2192 Prop \u2192 Prop \u2192 Prop\nx x' y z z' : Prop\nh\u2080 : x \u2194 x'\nh\u2081 : z \u2194 z'\n\u22a2 c x y z \u2194 c x' y z'"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 \u03b4} {F : \u2200 {\u03b1 \u03b2}, (\u03b1 \u2192 \u03b2) \u2192 \u03b3 \u2192 \u03b4} {f g : \u03b1 \u2192 \u03b2} {s : \u03b3} (h : \u2200 (x : \u03b1), f x = g x) :\n    F f s = F g s := by\n  congr!\n  funext\n  apply h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\n\u03b4 : Sort u_4\nF : {\u03b1 : Sort u_1} \u2192 {\u03b2 : Sort u_2} \u2192 (\u03b1 \u2192 \u03b2) \u2192 \u03b3 \u2192 \u03b4\nf g : \u03b1 \u2192 \u03b2\ns : \u03b3\nh : \u2200 (x : \u03b1), f x = g x\n\u22a2 F f s = F g s"}, {"line": "  congr!", "tactic_state": "case h.e'_3\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\n\u03b4 : Sort u_4\nF : {\u03b1 : Sort u_1} \u2192 {\u03b2 : Sort u_2} \u2192 (\u03b1 \u2192 \u03b2) \u2192 \u03b3 \u2192 \u03b4\nf g : \u03b1 \u2192 \u03b2\ns : \u03b3\nh : \u2200 (x : \u03b1), f x = g x\n\u22a2 f = g"}, {"line": "  funext", "tactic_state": "case h.e'_3.h\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\n\u03b4 : Sort u_4\nF : {\u03b1 : Sort u_1} \u2192 {\u03b2 : Sort u_2} \u2192 (\u03b1 \u2192 \u03b2) \u2192 \u03b3 \u2192 \u03b4\nf g : \u03b1 \u2192 \u03b2\ns : \u03b3\nh : \u2200 (x : \u03b1), f x = g x\nx\u271d : \u03b1\n\u22a2 f x\u271d = g x\u271d"}, {"line": "  apply h", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2} {f : _ \u2192 \u03b2} {x y : {x : {x : \u03b1 // x = x} // x = x}} (h : x.1 = y.1) :\n    f x = f y := by\n  congr! 1\n  ext1\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : { x // x = x } \u2192 \u03b2\nx y : { x // x = x }\nh : \u2191x = \u2191y\n\u22a2 f x = f y"}, {"line": "  congr! 1", "tactic_state": "case h.e'_1\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : { x // x = x } \u2192 \u03b2\nx y : { x // x = x }\nh : \u2191x = \u2191y\n\u22a2 x = y"}, {"line": "  ext1", "tactic_state": "case h.e'_1.a\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : { x // x = x } \u2192 \u03b2\nx y : { x // x = x }\nh : \u2191x = \u2191y\n\u22a2 \u2191x = \u2191y"}, {"line": "  exact h", "tactic_state": ""}]}
{"declaration": "example {\u03b1 \u03b2} {F : _ \u2192 \u03b2} {f g : {f : \u03b1 \u2192 \u03b2 // f = f}}\n    (h : \u2200 x : \u03b1, (f : \u03b1 \u2192 \u03b2) x = (g : \u03b1 \u2192 \u03b2) x) :\n    F f = F g := by\n  congr!\n  ext x\n  apply h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nF : { f // f = f } \u2192 \u03b2\nf g : { f // f = f }\nh : \u2200 (x : \u03b1), \u2191f x = \u2191g x\n\u22a2 F f = F g"}, {"line": "  congr!", "tactic_state": "case h.e'_1\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nF : { f // f = f } \u2192 \u03b2\nf g : { f // f = f }\nh : \u2200 (x : \u03b1), \u2191f x = \u2191g x\n\u22a2 f = g"}, {"line": "  ext x", "tactic_state": "case h.e'_1.a.h\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nF : { f // f = f } \u2192 \u03b2\nf g : { f // f = f }\nh : \u2200 (x : \u03b1), \u2191f x = \u2191g x\nx : \u03b1\n\u22a2 \u2191f x = \u2191g x"}, {"line": "  apply h", "tactic_state": ""}]}
{"declaration": "example {ls : List \u2115} :\n    ls.map (fun x => (ls.map (fun y => 1 + y)).sum + 1) =\n      ls.map (fun x => (ls.map (fun y => Nat.succ y)).sum + 1) := by\n  congr! 6 with - y\n  guard_target = 1 + y = y.succ\n  rw [Nat.add_comm]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "ls : List \u2115\n\u22a2 List.map (fun x => (List.map (fun y => 1 + y) ls).sum + 1) ls =\n    List.map (fun x => (List.map (fun y => y.succ) ls).sum + 1) ls"}, {"line": "  congr! 6 with - y", "tactic_state": "case h.e'_3.h.h.e'_5.h.e'_4.h.e'_3.h\nls : List \u2115\ny : \u2115\n\u22a2 1 + y = y.succ"}, {"line": "  guard_target = 1 + y = y.succ", "tactic_state": "case h.e'_3.h.h.e'_5.h.e'_4.h.e'_3.h\nls : List \u2115\ny : \u2115\n\u22a2 1 + y = y.succ"}, {"line": "  rw [Nat.add_comm]", "tactic_state": ""}]}
{"declaration": "example {ls : List \u2115} {f g : \u2115 \u2192 \u2115} {h : \u2200 x, f x = g x} :\n    ls.map (fun x => f x + 3) = ls.map (fun x => g x + 3) := by\n  congr! 3 with x -- it's a little too powerful and will get to `f = g`\n  exact h x\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "ls : List \u2115\nf g : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = g x\n\u22a2 List.map (fun x => f x + 3) ls = List.map (fun x => g x + 3) ls"}, {"line": "  congr! 3 with x -- it's a little too powerful and will get to `f = g`", "tactic_state": "case h.e'_3.h.h.e'_5\nls : List \u2115\nf g : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = g x\nx : \u2115\n\u22a2 f x = g x"}, {"line": "  exact h x", "tactic_state": ""}]}
{"declaration": "example : () = () := by congr!", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 () = ()"}]}
{"declaration": "example : 0 = 0 := by congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 = 0"}]}
{"declaration": "example {\u03b1} (a : \u03b1) : a = a := by congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\na : \u03b1\n\u22a2 a = a"}]}
{"declaration": "example {\u03b1} (a b : \u03b1) (h : false) : a = b := by\n  fail_if_success { congr! }\n  cases h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\na b : \u03b1\nh : false = true\n\u22a2 a = b"}, {"line": "  fail_if_success { congr! }", "tactic_state": "\u03b1 : Sort u_1\na b : \u03b1\nh : false = true\n\u22a2 a = b"}, {"line": "  cases h", "tactic_state": ""}]}
{"declaration": "example (x y z : Nat) (h : x = z) (hy : y = 2) : 1 + x + y = g z + 2 := by\n  congr!\n  guard_target = HAdd.hAdd 1 = g\n  funext\n  simp [g, Nat.add_comm]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ng : x\u271d\nx y z : \u2115\nh : x = z\nhy : y = 2\n\u22a2 1 + x + y = sorry + 2"}, {"line": "  congr!", "tactic_state": "case h.e'_5\nx\u271d : Sort u_1\ng : x\u271d\nx y z : \u2115\nh : x = z\nhy : y = 2\n\u22a2 1 + x = sorry"}, {"line": "  guard_target = HAdd.hAdd 1 = g", "tactic_state": "case h.e'_5\nx\u271d : Sort u_1\ng : x\u271d\nx y z : \u2115\nh : x = z\nhy : y = 2\n\u22a2 1 + x = sorry"}]}
{"declaration": "example (Fintype : Type \u2192 Type)\n    (\u03b1 \u03b2 : Type) (inst : Fintype \u03b1) (inst' : Fintype \u03b2) : HEq inst inst' := by\n  congr!\n  guard_target = HEq inst inst'\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Fintype : Type \u2192 Type\n\u03b1 \u03b2 : Type\ninst : Fintype \u03b1\ninst' : Fintype \u03b2\n\u22a2 HEq inst inst'"}, {"line": "  congr!", "tactic_state": "Fintype : Type \u2192 Type\n\u03b1 \u03b2 : Type\ninst : Fintype \u03b1\ninst' : Fintype \u03b2\n\u22a2 HEq inst inst'"}, {"line": "  guard_target = HEq inst inst'", "tactic_state": "Fintype : Type \u2192 Type\n\u03b1 \u03b2 : Type\ninst : Fintype \u03b1\ninst' : Fintype \u03b2\n\u22a2 HEq inst inst'"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (Fintype : Type \u2192 Type) [\u2200 \u03b3, Subsingleton (Fintype \u03b3)]\n    (\u03b1 \u03b2 : Type) (inst : Fintype \u03b1) (inst' : Fintype \u03b2) : HEq inst inst' := by\n  congr!\n  guard_target = \u03b1 = \u03b2\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Fintype : Type \u2192 Type\ninst\u271d : \u2200 (\u03b3 : Type), Subsingleton (Fintype \u03b3)\n\u03b1 \u03b2 : Type\ninst : Fintype \u03b1\ninst' : Fintype \u03b2\n\u22a2 HEq inst inst'"}, {"line": "  congr!", "tactic_state": "case h.e'_1\nFintype : Type \u2192 Type\ninst\u271d\u00b9 : \u2200 (\u03b3 : Type), Subsingleton (Fintype \u03b3)\n\u03b1 \u03b2 : Type\ninst\u271d : Fintype \u03b1\ninst' : Fintype \u03b2\ninst : \u2200 (\u03b3 : Type), Lean.Meta.FastSubsingleton (Fintype \u03b3)\n\u22a2 \u03b1 = \u03b2"}, {"line": "  guard_target = \u03b1 = \u03b2", "tactic_state": "case h.e'_1\nFintype : Type \u2192 Type\ninst\u271d\u00b9 : \u2200 (\u03b3 : Type), Subsingleton (Fintype \u03b3)\n\u03b1 \u03b2 : Type\ninst\u271d : Fintype \u03b1\ninst' : Fintype \u03b2\ninst : \u2200 (\u03b3 : Type), Lean.Meta.FastSubsingleton (Fintype \u03b3)\n\u22a2 \u03b1 = \u03b2"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example : n = m \u2192 3 + n = m + 3 := by\n  congr! 0 with rfl\n  guard_target = 3 + n = n + 3\n  apply add_comm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\n\u22a2 n = m \u2192 3 + n = m + 3"}, {"line": "  congr! 0 with rfl", "tactic_state": "n : \u2115\n\u22a2 3 + n = n + 3"}, {"line": "  guard_target = 3 + n = n + 3", "tactic_state": "n : \u2115\n\u22a2 3 + n = n + 3"}, {"line": "  apply add_comm", "tactic_state": ""}]}
{"declaration": "example (x y x' y' : Nat) (hx : x = x') (hy : y = y') : x + y = x' + y' := by\n  congr! (config := { closePre := false, closePost := false })\n  exact hx\n  exact hy\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y x' y' : \u2115\nhx : x = x'\nhy : y = y'\n\u22a2 x + y = x' + y'"}, {"line": "  congr! (config := { closePre := false, closePost := false })", "tactic_state": "case h.e'_5\nx y x' y' : \u2115\nhx : x = x'\nhy : y = y'\n\u22a2 x = x'\n---\ncase h.e'_6\nx y x' y' : \u2115\nhx : x = x'\nhy : y = y'\n\u22a2 y = y'"}, {"line": "  exact hx", "tactic_state": "case h.e'_6\nx y x' y' : \u2115\nhx : x = x'\nhy : y = y'\n\u22a2 y = y'"}, {"line": "  exact hy", "tactic_state": ""}]}
{"declaration": "example (x y x' : Nat) (hx : id x = id x') : x + y = x' + y := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y x' : \u2115\nhx : id x = id x'\n\u22a2 x + y = x' + y"}, {"line": "  congr!", "tactic_state": ""}]}
{"declaration": "example (x y x' : Nat) (hx : id x = id x') : x + y = x' + y := by\n  congr! (config := { closePost := false })\n  exact hx\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y x' : \u2115\nhx : id x = id x'\n\u22a2 x + y = x' + y"}, {"line": "  congr! (config := { closePost := false })", "tactic_state": "case h.e'_5\nx y x' : \u2115\nhx : id x = id x'\n\u22a2 x = x'"}, {"line": "  exact hx", "tactic_state": ""}]}
{"declaration": "example : { f : Nat \u2192 Nat // f = id } :=\n  \u27e8?_, by\n    -- prevents `rfl` from solving for `?m` in `?m = id`:\n    congr! (config := { closePre := false, closePost := false })\n    ext x\n    exact Nat.zero_add x\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 ?m.58 = id"}, {"line": "  \u27e8?_, by", "tactic_state": "\u22a2 ?m.58 = id"}, {"line": "    -- prevents `rfl` from solving for `?m` in `?m = id`:", "tactic_state": "case h\nx : \u2115\n\u22a2 ?m.58 x = id x"}, {"line": "    congr! (config := { closePre := false, closePost := false })", "tactic_state": ""}]}
{"declaration": "example (h : z = y) : (x = y \u2228 x = z) \u2192 x = y := by\n  congr! with (rfl|rfl)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Sort u_1\nz y x : \u03b1\u271d\nh : z = y\n\u22a2 x = y \u2228 x = z \u2192 x = y"}, {"line": "  congr! with (rfl|rfl)", "tactic_state": ""}]}
{"declaration": "example {\u03b1} [AddCommMonoid \u03b1] [PartialOrder \u03b1] {a b c d e f g : \u03b1} :\n    (a + b) + (c + d) + (e + f) + g \u2264 a + d + e + f + c + g + b := by\n  ac_change a + d + e + f + c + g + b \u2264 _; rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + b + (c + d) + (e + f) + g \u2264 a + d + e + f + c + g + b"}, {"line": "  ac_change a + d + e + f + c + g + b \u2264 _; rfl", "tactic_state": "case h.e'_3\n\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + b + (c + d) + (e + f) + g = a + d + e + f + c + g + b\n---\ncase convert_2\n\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + d + e + f + c + g + b \u2264 a + d + e + f + c + g + b"}]}
{"declaration": "example {\u03b1} [AddCommMonoid \u03b1] [PartialOrder \u03b1] {a b c d e f g : \u03b1} :\n    (a + b) + (c + d) + (e + f) + g \u2264 a + d + e + f + c + b + g := by\n  ac_change a + d + e + f + c + g + b \u2264 a + d + e + f + c + g + b\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + b + (c + d) + (e + f) + g \u2264 a + d + e + f + c + b + g"}, {"line": "  ac_change a + d + e + f + c + g + b \u2264 a + d + e + f + c + g + b", "tactic_state": "case h.e'_3\n\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + b + (c + d) + (e + f) + g = a + d + e + f + c + g + b\n---\ncase h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + d + e + f + c + b + g = a + d + e + f + c + g + b\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + d + e + f + c + g + b \u2264 a + d + e + f + c + g + b"}, {"line": "  rfl", "tactic_state": "case h.e'_3\n\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + b + (c + d) + (e + f) + g = a + d + e + f + c + g + b\n---\ncase h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + d + e + f + c + b + g = a + d + e + f + c + g + b\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : PartialOrder \u03b1\na b c d e f g : \u03b1\n\u22a2 a + d + e + f + c + g + b \u2264 a + d + e + f + c + g + b"}]}
{"declaration": "example : True := by\n  rsuffices \u27e8n : \u2115, h : n = n, -\u27e9 : \u2203 n : \u2115, n = n \u2227 True\n  \u00b7 guard_hyp n : \u2115\n    guard_hyp h : n = n\n    trivial\n  \u00b7 existsi 0\n    simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rsuffices.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  rsuffices \u27e8n : \u2115, h : n = n, -\u27e9 : \u2203 n : \u2115, n = n \u2227 True", "tactic_state": "case intro.intro\nn : \u2115\nh : n = n\n\u22a2 True\n---\n\u22a2 \u2203 n, n = n \u2227 True"}, {"line": "  \u00b7 guard_hyp n : \u2115", "tactic_state": "case intro.intro\nn : \u2115\nh : n = n\n\u22a2 True"}, {"line": "    guard_hyp h : n = n", "tactic_state": "case intro.intro\nn : \u2115\nh : n = n\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  \u00b7 existsi 0", "tactic_state": "\u22a2 0 = 0 \u2227 True"}, {"line": "    simp", "tactic_state": ""}]}
{"declaration": "example : True := by\n  rsuffices : \u2203 n : \u2115, n = n \u2227 True\n  \u00b7 trivial\n  \u00b7 existsi 0\n    simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rsuffices.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  rsuffices : \u2203 n : \u2115, n = n \u2227 True", "tactic_state": "this\u271d : \u2203 n, n = n \u2227 True\n\u22a2 True\n---\n\u22a2 \u2203 n, n = n \u2227 True"}, {"line": "  \u00b7 trivial", "tactic_state": ""}, {"line": "  \u00b7 existsi 0", "tactic_state": "\u22a2 0 = 0 \u2227 True"}, {"line": "    simp", "tactic_state": ""}]}
{"declaration": "example : True := by\n  rsuffices (h : True) | \u27e8\u27e8\u27e9\u27e9 : True \u2228 False\n  \u00b7 guard_hyp h : True\n    trivial\n  \u00b7 left\n    trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rsuffices.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  rsuffices (h : True) | \u27e8\u27e8\u27e9\u27e9 : True \u2228 False", "tactic_state": "case inl\nh : True\n\u22a2 True\n---\n\u22a2 True \u2228 False"}, {"line": "  \u00b7 guard_hyp h : True", "tactic_state": "case inl\nh : True\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  \u00b7 left", "tactic_state": "case h\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}]}
{"declaration": "example (x y : \u03b1 \u00d7 \u03b2) : True := by\n  rsuffices \u27e8\u27e8a, b\u27e9, c, d\u27e9 : (\u03b1 \u00d7 \u03b2) \u00d7 (\u03b1 \u00d7 \u03b2)\n  \u00b7 guard_hyp a : \u03b1\n    guard_hyp b : \u03b2\n    guard_hyp c : \u03b1\n    guard_hyp d : \u03b2\n    trivial\n  \u00b7 exact \u27e8x, y\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rsuffices.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u00d7 \u03b2\n\u22a2 True"}, {"line": "  rsuffices \u27e8\u27e8a, b\u27e9, c, d\u27e9 : (\u03b1 \u00d7 \u03b2) \u00d7 (\u03b1 \u00d7 \u03b2)", "tactic_state": "case mk.mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u00d7 \u03b2\na : \u03b1\nb : \u03b2\nc : \u03b1\nd : \u03b2\n\u22a2 True\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u00d7 \u03b2\n\u22a2 (\u03b1 \u00d7 \u03b2) \u00d7 \u03b1 \u00d7 \u03b2"}, {"line": "  \u00b7 guard_hyp a : \u03b1", "tactic_state": "case mk.mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u00d7 \u03b2\na : \u03b1\nb : \u03b2\nc : \u03b1\nd : \u03b2\n\u22a2 True"}, {"line": "    guard_hyp b : \u03b2", "tactic_state": "case mk.mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u00d7 \u03b2\na : \u03b1\nb : \u03b2\nc : \u03b1\nd : \u03b2\n\u22a2 True"}, {"line": "    guard_hyp c : \u03b1", "tactic_state": "case mk.mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u00d7 \u03b2\na : \u03b1\nb : \u03b2\nc : \u03b1\nd : \u03b2\n\u22a2 True"}, {"line": "    guard_hyp d : \u03b2", "tactic_state": "case mk.mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u00d7 \u03b2\na : \u03b1\nb : \u03b2\nc : \u03b1\nd : \u03b2\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  \u00b7 exact \u27e8x, y\u27e9", "tactic_state": ""}]}
{"declaration": "example (x y : \u03b1 \u2295 \u03b2) : True := by\n  rsuffices \u27e8a|b, c|d\u27e9 : (\u03b1 \u2295 \u03b2) \u00d7 (\u03b1 \u2295 \u03b2)\n  \u00b7 guard_hyp a : \u03b1\n    guard_hyp c : \u03b1\n    trivial\n  \u00b7 guard_hyp a : \u03b1\n    guard_hyp d : \u03b2\n    trivial\n  \u00b7 guard_hyp b : \u03b2\n    guard_hyp c : \u03b1\n    trivial\n  \u00b7 guard_hyp b : \u03b2\n    guard_hyp d : \u03b2\n    trivial\n  exact \u27e8x, y\u27e9\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rsuffices.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\n\u22a2 True"}, {"line": "  rsuffices \u27e8a|b, c|d\u27e9 : (\u03b1 \u2295 \u03b2) \u00d7 (\u03b1 \u2295 \u03b2)", "tactic_state": "case mk.inl.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\na c : \u03b1\n\u22a2 True\n---\ncase mk.inl.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\na : \u03b1\nd : \u03b2\n\u22a2 True\n---\ncase mk.inr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\nb : \u03b2\nc : \u03b1\n\u22a2 True\n---\ncase mk.inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\nb d : \u03b2\n\u22a2 True\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\n\u22a2 (\u03b1 \u2295 \u03b2) \u00d7 (\u03b1 \u2295 \u03b2)"}, {"line": "  \u00b7 guard_hyp a : \u03b1", "tactic_state": "case mk.inl.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\na c : \u03b1\n\u22a2 True"}, {"line": "    guard_hyp c : \u03b1", "tactic_state": "case mk.inl.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\na c : \u03b1\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  \u00b7 guard_hyp a : \u03b1", "tactic_state": "case mk.inl.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\na : \u03b1\nd : \u03b2\n\u22a2 True"}, {"line": "    guard_hyp d : \u03b2", "tactic_state": "case mk.inl.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\na : \u03b1\nd : \u03b2\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  \u00b7 guard_hyp b : \u03b2", "tactic_state": "case mk.inr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\nb : \u03b2\nc : \u03b1\n\u22a2 True"}, {"line": "    guard_hyp c : \u03b1", "tactic_state": "case mk.inr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\nb : \u03b2\nc : \u03b1\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  \u00b7 guard_hyp b : \u03b2", "tactic_state": "case mk.inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\nb d : \u03b2\n\u22a2 True"}, {"line": "    guard_hyp d : \u03b2", "tactic_state": "case mk.inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx y : \u03b1 \u2295 \u03b2\nb d : \u03b2\n\u22a2 True"}, {"line": "    trivial", "tactic_state": ""}, {"line": "  exact \u27e8x, y\u27e9", "tactic_state": ""}]}
{"declaration": "example {\u03b1} (V : Set \u03b1) (w : True \u2192 \u2203 p, p \u2208 (V.foo V) \u2229 (V.foo V)) : True := by\n  rsuffices \u27e8_, _\u27e9 : \u2203 p, p \u2208 (V.foo V) \u2229 (V.foo V)\n  \u00b7 trivial\n  \u00b7 exact w trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/rsuffices.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nV : Set \u03b1\nw : True \u2192 \u2203 p, p \u2208 sorry \u2229 sorry\n\u22a2 True"}, {"line": "  rsuffices \u27e8_, _\u27e9 : \u2203 p, p \u2208 (V.foo V) \u2229 (V.foo V)", "tactic_state": "case intro\n\u03b1 : Type u_1\nV : Set \u03b1\nw : True \u2192 \u2203 p, p \u2208 sorry \u2229 sorry\nw\u271d : ?m.625\nh\u271d : w\u271d \u2208 sorry \u2229 sorry\n\u22a2 True\n---\n\u03b1 : Type u_1\nV : Set \u03b1\nw : True \u2192 \u2203 p, p \u2208 sorry \u2229 sorry\n\u22a2 \u2203 p, p \u2208 sorry \u2229 sorry"}, {"line": "  \u00b7 trivial", "tactic_state": ""}, {"line": "  \u00b7 exact w trivial", "tactic_state": ""}]}
{"declaration": "example (a : Nat) (b : Int) : Int \u00d7 Nat := by\n  rename' a => c, b => d\n  exact (d, c)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Rename.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\nb : \u2124\n\u22a2 \u2124 \u00d7 \u2115"}, {"line": "  rename' a => c, b => d", "tactic_state": "c : \u2115\nd : \u2124\n\u22a2 \u2124 \u00d7 \u2115"}, {"line": "  exact (d, c)", "tactic_state": ""}]}
{"declaration": "example (a : Nat) (b : Int) : Int \u00d7 Nat := by\n  rename' a => b, b => a\n  exact (a, b)", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Rename.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\nb : \u2124\n\u22a2 \u2124 \u00d7 \u2115"}, {"line": "  rename' a => b, b => a", "tactic_state": "b : \u2115\na : \u2124\n\u22a2 \u2124 \u00d7 \u2115"}, {"line": "  exact (a, b)", "tactic_state": ""}]}
{"declaration": "example (a b : ENat) (h : a = b) : a - b = b - a := by\n  enat_to_nat\n  omega\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/enat_to_nat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\u221e\nh : a = b\n\u22a2 a - b = b - a"}, {"line": "  enat_to_nat", "tactic_state": "case coe.coe\na b : \u2115\nh : a = b\n\u22a2 a - b = b - a"}, {"line": "  omega", "tactic_state": ""}]}
{"declaration": "example (a b : ENat) (h : a \u2264 b) : a - b < b + 1 := by\n  enat_to_nat\n  omega\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/enat_to_nat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\u221e\nh : a \u2264 b\n\u22a2 a - b < b + 1"}, {"line": "  enat_to_nat", "tactic_state": "case coe.coe\na b : \u2115\nh : a \u2264 b\n\u22a2 a - b < b + 1"}, {"line": "  omega", "tactic_state": ""}]}
{"declaration": "example (a b : ENat) (h : a \u2264 b) : a - 2 * b \u2264 b + 1 := by\n  enat_to_nat\n  omega\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/enat_to_nat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\u221e\nh : a \u2264 b\n\u22a2 a - 2 * b \u2264 b + 1"}, {"line": "  enat_to_nat", "tactic_state": "case coe.coe\na b : \u2115\nh : a \u2264 b\n\u22a2 a - 2 * b \u2264 b + 1"}, {"line": "  omega", "tactic_state": ""}]}
{"declaration": "example (a b c : ENat) (hab : a \u2265 b) (hbc : b \u2265 c) : a \u2265 c := by\n  enat_to_nat\n  omega\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/enat_to_nat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\u221e\nhab : a \u2265 b\nhbc : b \u2265 c\n\u22a2 a \u2265 c"}, {"line": "  enat_to_nat", "tactic_state": "case coe.coe.coe\na b c : \u2115\nhab : b \u2264 a\nhbc : c \u2264 b\n\u22a2 c \u2264 a"}, {"line": "  omega", "tactic_state": ""}]}
{"declaration": "example (a b : ENat) (h : a = b) : a - b = b - a := by\n  -- to test if the tactic works with inaccessible names\n  let a : \u2124 := 42\n  let b : \u2124 := 32\n  enat_to_nat\n  omega", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/enat_to_nat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\u221e\nh : a = b\n\u22a2 a - b = b - a"}, {"line": "  -- to test if the tactic works with inaccessible names", "tactic_state": "a\u271d b : \u2115\u221e\nh : a\u271d = b\na : \u2124 := 42\n\u22a2 a\u271d - b = b - a\u271d"}, {"line": "  let a : \u2124 := 42", "tactic_state": "a\u271d b\u271d : \u2115\u221e\nh : a\u271d = b\u271d\na : \u2124 := 42\nb : \u2124 := 32\n\u22a2 a\u271d - b\u271d = b\u271d - a\u271d"}, {"line": "  let b : \u2124 := 32", "tactic_state": "case coe.coe\na : \u2124 := 42\nb : \u2124 := 32\na\u271d\u00b9 a\u271d : \u2115\nh : a\u271d\u00b9 = a\u271d\n\u22a2 a\u271d\u00b9 - a\u271d = a\u271d - a\u271d\u00b9"}, {"line": "  enat_to_nat", "tactic_state": ""}]}
{"declaration": "example {x : Nat} (h : x \u2208 [0, 2, 37]) : x \u2264 57 := by\n  fin_cases h\n  repeat decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x \u2208 [0, 2, 37]\n\u22a2 x \u2264 57"}, {"line": "  fin_cases h", "tactic_state": "case \u00ab0\u00bb\n\u22a2 0 \u2264 57\n---\ncase \u00ab1\u00bb\n\u22a2 2 \u2264 57\n---\ncase \u00ab2\u00bb\n\u22a2 37 \u2264 57"}, {"line": "  repeat decide", "tactic_state": ""}]}
{"declaration": "example {x : Nat} (h : x \u2208 [0, 2, 37]) : x = 0 \u2228 x = 2 \u2228 x = 37 := by\n  fin_cases h\n  repeat simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x \u2208 [0, 2, 37]\n\u22a2 x = 0 \u2228 x = 2 \u2228 x = 37"}, {"line": "  fin_cases h", "tactic_state": "case \u00ab0\u00bb\n\u22a2 0 = 0 \u2228 0 = 2 \u2228 0 = 37\n---\ncase \u00ab1\u00bb\n\u22a2 2 = 0 \u2228 2 = 2 \u2228 2 = 37\n---\ncase \u00ab2\u00bb\n\u22a2 37 = 0 \u2228 37 = 2 \u2228 37 = 37"}, {"line": "  repeat simp", "tactic_state": ""}]}
{"declaration": "example {x : Nat} (h : x \u2208 List.range 5) : x \u2264 4 := by\n  fin_cases h\n  repeat decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x \u2208 List.range 5\n\u22a2 x \u2264 4"}, {"line": "  fin_cases h", "tactic_state": "case \u00ab0\u00bb\n\u22a2 0 \u2264 4\n---\ncase \u00ab1\u00bb\n\u22a2 1 \u2264 4\n---\ncase \u00ab2\u00bb\n\u22a2 2 \u2264 4\n---\ncase \u00ab3\u00bb\n\u22a2 3 \u2264 4\n---\ncase \u00ab4\u00bb\n\u22a2 4 \u2264 4"}, {"line": "  repeat decide", "tactic_state": ""}]}
{"declaration": "example {p : Fin 4 \u2192 Prop} (i : Fin 4) (h : p i) : p i := by\n  fin_cases i\n  repeat exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Fin 4 \u2192 Prop\ni : Fin 4\nh : p i\n\u22a2 p i"}, {"line": "  fin_cases i", "tactic_state": "case \u00ab0\u00bb\np : Fin 4 \u2192 Prop\nh : p ((fun i => i) \u27e80, \u22ef\u27e9)\n\u22a2 p ((fun i => i) \u27e80, \u22ef\u27e9)\n---\ncase \u00ab1\u00bb\np : Fin 4 \u2192 Prop\nh : p ((fun i => i) \u27e81, \u22ef\u27e9)\n\u22a2 p ((fun i => i) \u27e81, \u22ef\u27e9)\n---\ncase \u00ab2\u00bb\np : Fin 4 \u2192 Prop\nh : p ((fun i => i) \u27e82, \u22ef\u27e9)\n\u22a2 p ((fun i => i) \u27e82, \u22ef\u27e9)\n---\ncase \u00ab3\u00bb\np : Fin 4 \u2192 Prop\nh : p ((fun i => i) \u27e83, \u22ef\u27e9)\n\u22a2 p ((fun i => i) \u27e83, \u22ef\u27e9)"}, {"line": "  repeat exact h", "tactic_state": ""}]}
{"declaration": "example (f : Nat \u2192 Prop) (p : Fin 3) (h0 : f 0) (h1 : f 1) (h2 : f 2) : f p.val := by\n  fin_cases p\n  all_goals\n    assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 Prop\np : Fin 3\nh0 : f 0\nh1 : f 1\nh2 : f 2\n\u22a2 f \u2191p"}, {"line": "  fin_cases p", "tactic_state": "case \u00ab0\u00bb\nf : \u2115 \u2192 Prop\nh0 : f 0\nh1 : f 1\nh2 : f 2\n\u22a2 f \u2191((fun i => i) \u27e80, \u22ef\u27e9)\n---\ncase \u00ab1\u00bb\nf : \u2115 \u2192 Prop\nh0 : f 0\nh1 : f 1\nh2 : f 2\n\u22a2 f \u2191((fun i => i) \u27e81, \u22ef\u27e9)\n---\ncase \u00ab2\u00bb\nf : \u2115 \u2192 Prop\nh0 : f 0\nh1 : f 1\nh2 : f 2\n\u22a2 f \u2191((fun i => i) \u27e82, \u22ef\u27e9)"}, {"line": "  all_goals", "tactic_state": ""}]}
{"declaration": "example (f : Nat \u2192 Prop) (p : Fin 0) : f p.val := by\n  fin_cases p\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 Prop\np : Fin 0\n\u22a2 f \u2191p"}, {"line": "  fin_cases p", "tactic_state": ""}]}
{"declaration": "example (x2 : Fin 2) (x3 : Fin 3) : True := by\n  fin_cases x2, x3\n  all_goals trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x2 : Fin 2\nx3 : Fin 3\n\u22a2 True"}, {"line": "  fin_cases x2, x3", "tactic_state": "case \u00ab0\u00bb.\u00ab0\u00bb\n\u22a2 True\n---\ncase \u00ab0\u00bb.\u00ab1\u00bb\n\u22a2 True\n---\ncase \u00ab0\u00bb.\u00ab2\u00bb\n\u22a2 True\n---\ncase \u00ab1\u00bb.\u00ab0\u00bb\n\u22a2 True\n---\ncase \u00ab1\u00bb.\u00ab1\u00bb\n\u22a2 True\n---\ncase \u00ab1\u00bb.\u00ab2\u00bb\n\u22a2 True"}, {"line": "  all_goals trivial", "tactic_state": ""}]}
{"declaration": "example (p : \u2115) (h2 : 2 < p) (h5 : p < 5) : p = 3 \u2228 p = 4 := by\n  have hp : ?_ := ?foo\n  case foo => exact (Finset.mem_Ioo).2 \u27e8h2, h5\u27e9\n  fin_cases hp\n  \u00b7 norm_num\n  \u00b7 norm_num\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nh2 : 2 < p\nh5 : p < 5\n\u22a2 p = 3 \u2228 p = 4"}, {"line": "  have hp : ?_ := ?foo", "tactic_state": "case refine_2\np : \u2115\nh2 : 2 < p\nh5 : p < 5\nhp : ?refine_1\n\u22a2 p = 3 \u2228 p = 4\n---\ncase refine_1\np : \u2115\nh2 : 2 < p\nh5 : p < 5\n\u22a2 Sort ?u.129\n---\ncase foo\np : \u2115\nh2 : 2 < p\nh5 : p < 5\n\u22a2 ?refine_1"}, {"line": "  case foo => exact (Finset.mem_Ioo).2 \u27e8h2, h5\u27e9", "tactic_state": "case refine_2\np : \u2115\nh2 : 2 < p\nh5 : p < 5\nhp : p \u2208 Finset.Ioo 2 5\n\u22a2 p = 3 \u2228 p = 4"}, {"line": "  fin_cases hp", "tactic_state": "case refine_2.\u00ab0\u00bb\nh2 : 2 < 2 + 1\nh5 : 2 + 1 < 5\n\u22a2 2 + 1 = 3 \u2228 2 + 1 = 4\n---\ncase refine_2.\u00ab1\u00bb\nh2 : 2 < 2 + 1 + 1\nh5 : 2 + 1 + 1 < 5\n\u22a2 2 + 1 + 1 = 3 \u2228 2 + 1 + 1 = 4"}, {"line": "  \u00b7 norm_num", "tactic_state": ""}, {"line": "  \u00b7 norm_num", "tactic_state": ""}]}
{"declaration": "example (x y : Fin 2): True := by\n  fin_cases x, y\n  trace_state\n  all_goals trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : Fin 2\n\u22a2 True"}, {"line": "  fin_cases x, y", "tactic_state": "case \u00ab0\u00bb.\u00ab0\u00bb\n\u22a2 True\n---\ncase \u00ab0\u00bb.\u00ab1\u00bb\n\u22a2 True\n---\ncase \u00ab1\u00bb.\u00ab0\u00bb\n\u22a2 True\n---\ncase \u00ab1\u00bb.\u00ab1\u00bb\n\u22a2 True"}, {"line": "  trace_state", "tactic_state": "case \u00ab0\u00bb.\u00ab0\u00bb\n\u22a2 True\n---\ncase \u00ab0\u00bb.\u00ab1\u00bb\n\u22a2 True\n---\ncase \u00ab1\u00bb.\u00ab0\u00bb\n\u22a2 True\n---\ncase \u00ab1\u00bb.\u00ab1\u00bb\n\u22a2 True"}, {"line": "  all_goals trivial", "tactic_state": ""}]}
{"declaration": "example (x2 : Fin 2) (x3 : Fin 3) (n : Nat) (y : Fin n) : x2.val * x3.val = x3.val * x2.val := by\n  fin_cases x2 <;> fin_cases x3\n  fail_if_success\n    fin_cases y\n  all_goals rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fin_cases.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x2 : Fin 2\nx3 : Fin 3\nn : \u2115\ny : Fin n\n\u22a2 \u2191x2 * \u2191x3 = \u2191x3 * \u2191x2"}, {"line": "  fin_cases x2 <;> fin_cases x3", "tactic_state": "case \u00ab0\u00bb.\u00ab0\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9) = \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9)\n---\ncase \u00ab0\u00bb.\u00ab1\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9) = \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9)\n---\ncase \u00ab0\u00bb.\u00ab2\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e82, \u22ef\u27e9) = \u2191((fun i => i) \u27e82, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9)\n---\ncase \u00ab1\u00bb.\u00ab0\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9) = \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9)\n---\ncase \u00ab1\u00bb.\u00ab1\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9) = \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9)\n---\ncase \u00ab1\u00bb.\u00ab2\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e82, \u22ef\u27e9) = \u2191((fun i => i) \u27e82, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9)"}, {"line": "  fail_if_success", "tactic_state": "case \u00ab0\u00bb.\u00ab0\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9) = \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9)\n---\ncase \u00ab0\u00bb.\u00ab1\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9) = \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9)\n---\ncase \u00ab0\u00bb.\u00ab2\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e82, \u22ef\u27e9) = \u2191((fun i => i) \u27e82, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9)\n---\ncase \u00ab1\u00bb.\u00ab0\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e80, \u22ef\u27e9) = \u2191((fun i => i) \u27e80, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9)\n---\ncase \u00ab1\u00bb.\u00ab1\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9) = \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9)\n---\ncase \u00ab1\u00bb.\u00ab2\u00bb\nn : \u2115\ny : Fin n\n\u22a2 \u2191((fun i => i) \u27e81, \u22ef\u27e9) * \u2191((fun i => i) \u27e82, \u22ef\u27e9) = \u2191((fun i => i) \u27e82, \u22ef\u27e9) * \u2191((fun i => i) \u27e81, \u22ef\u27e9)"}, {"line": "    fin_cases y", "tactic_state": ""}]}
{"declaration": "example : List.nthLe [1, 2] 1 (by simp) = 2 := by\n  generalize_proofs h\n  guard_hyp h :\u209b 1 < List.length [1, 2]\n  guard_target =\u209b [1, 2].nthLe 1 h = 2\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = 2"}, {"line": "  generalize_proofs h", "tactic_state": "\u22a2 sorry = 2"}, {"line": "  guard_hyp h :\u209b 1 < List.length [1, 2]", "tactic_state": "\u22a2 sorry = 2"}]}
{"declaration": "example (x : \u2115) (h : x < 2) : Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) < 2 := by\n  generalize_proofs a\n  guard_hyp a :\u209b \u2203 x, x < 2\n  guard_target =\u209b Classical.choose a < 2\n  exact Classical.choose_spec a\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef < 2"}, {"line": "  generalize_proofs a", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  guard_hyp a :\u209b \u2203 x, x < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  guard_target =\u209b Classical.choose a < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  exact Classical.choose_spec a", "tactic_state": ""}]}
{"declaration": "example (x : \u2115) (h : x < 2) :\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) := by\n  generalize_proofs a\n  guard_hyp a :\u209b \u2203 x, x < 2\n  guard_target =\u209b Classical.choose a = Classical.choose a\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  generalize_proofs a", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "  guard_hyp a :\u209b \u2203 x, x < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "  guard_target =\u209b Classical.choose a = Classical.choose a", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example (x : \u2115) (h : x < 2) (h' : x < 1) :\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)\n      = Classical.choose (\u27e8x, (by clear h; omega)\u27e9 : \u2203 x, x < 2) := by\n  generalize_proofs a\n  guard_hyp a :\u209b \u2203 x, x < 2\n  guard_target =\u209b Classical.choose a = Classical.choose a\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\nh' : x < 1\n\u22a2 x < 2"}, {"line": "  generalize_proofs a", "tactic_state": "x : \u2115\nh' : x < 1\n\u22a2 x < 2"}, {"line": "  guard_hyp a :\u209b \u2203 x, x < 2", "tactic_state": ""}, {"line": "  guard_target =\u209b Classical.choose a = Classical.choose a", "tactic_state": "x : \u2115\nh : x < 2\nh' : x < 1\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "  rfl", "tactic_state": "x : \u2115\nh : x < 2\nh' : x < 1\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}]}
{"declaration": "example (x : \u2115) (h h' : x < 2) :\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h'\u27e9 : \u2203 x, x < 2) := by\n  change _ at h'\n  fail_if_success guard_target =\u209b\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)\n  generalize_proofs at h'\n  fail_if_success change _ at h'\n  guard_target =\u209b Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)\n  generalize_proofs a\n  guard_target =\u209b Classical.choose a = Classical.choose a\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh h' : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  change _ at h'", "tactic_state": "x : \u2115\nh h' : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  fail_if_success guard_target =\u209b", "tactic_state": "x : \u2115\nh h' : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  generalize_proofs at h'", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  fail_if_success change _ at h'", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  guard_target =\u209b Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "  generalize_proofs a", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "  guard_target =\u209b Classical.choose a = Classical.choose a", "tactic_state": ""}]}
{"declaration": "example (x : \u2115) (h : x < 2) :\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)\n      = Classical.choose (\u27e8x, Nat.lt_succ_of_lt h\u27e9 : \u2203 x, x < 3) := by\n  generalize_proofs a a'\n  guard_hyp a :\u209b \u2203 x, x < 2\n  guard_hyp a' :\u209b \u2203 x, x < 3\n  guard_target =\u209b Classical.choose a = Classical.choose a'\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  generalize_proofs a a'", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\na' : \u2203 x, x < 3\n\u22a2 Classical.choose a = Classical.choose a'"}, {"line": "  guard_hyp a :\u209b \u2203 x, x < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\na' : \u2203 x, x < 3\n\u22a2 Classical.choose a = Classical.choose a'"}, {"line": "  guard_hyp a' :\u209b \u2203 x, x < 3", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\na' : \u2203 x, x < 3\n\u22a2 Classical.choose a = Classical.choose a'"}, {"line": "  guard_target =\u209b Classical.choose a = Classical.choose a'", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\na' : \u2203 x, x < 3\n\u22a2 Classical.choose a = Classical.choose a'"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (x : \u2115) (h : x < 2) : Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) =\n  Classical.choose (\u27e8x, Nat.lt_succ_of_lt h\u27e9 : \u2203 x, x < 3) := by\n  generalize_proofs\n  guard_target = Classical.choose _ = Classical.choose _\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  generalize_proofs", "tactic_state": "x : \u2115\nh : x < 2\npf\u271d\u00b9 : \u2203 x, x < 2\npf\u271d : \u2203 x, x < 3\n\u22a2 Classical.choose pf\u271d\u00b9 = Classical.choose pf\u271d"}, {"line": "  guard_target = Classical.choose _ = Classical.choose _", "tactic_state": "x : \u2115\nh : x < 2\npf\u271d\u00b9 : \u2203 x, x < 2\npf\u271d : \u2203 x, x < 3\n\u22a2 Classical.choose pf\u271d\u00b9 = Classical.choose pf\u271d"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (x : \u2115) (h : x < 2) : Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) =\n  Classical.choose (\u27e8x, Nat.lt_succ_of_lt h\u27e9 : \u2203 x, x < 3) := by\n  generalize_proofs _ a\n  guard_hyp a : \u2203 x, x < 3\n  guard_target = Classical.choose _ = Classical.choose a\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "  generalize_proofs _ a", "tactic_state": "x : \u2115\nh : x < 2\npf\u271d : \u2203 x, x < 2\na : \u2203 x, x < 3\n\u22a2 Classical.choose pf\u271d = Classical.choose a"}, {"line": "  guard_hyp a : \u2203 x, x < 3", "tactic_state": "x : \u2115\nh : x < 2\npf\u271d : \u2203 x, x < 2\na : \u2203 x, x < 3\n\u22a2 Classical.choose pf\u271d = Classical.choose a"}, {"line": "  guard_target = Classical.choose _ = Classical.choose a", "tactic_state": "x : \u2115\nh : x < 2\npf\u271d : \u2203 x, x < 2\na : \u2203 x, x < 3\n\u22a2 Classical.choose pf\u271d = Classical.choose a"}, {"line": "  exact test_sorry", "tactic_state": ""}]}
{"declaration": "example (a : \u2203 x, x < 2) : Classical.choose a < 2 := by\n  generalize_proofs\n  guard_target =\u209b Classical.choose a < 2\n  exact Classical.choose_spec a\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  generalize_proofs", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  guard_target =\u209b Classical.choose a < 2", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  exact Classical.choose_spec a", "tactic_state": ""}]}
{"declaration": "example (a : \u2203 x, x < 2) : Classical.choose a < 2 := by\n  generalize_proofs t\n  guard_target =\u209b Classical.choose a < 2\n  exact Classical.choose_spec a\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  generalize_proofs t", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  guard_target =\u209b Classical.choose a < 2", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  exact Classical.choose_spec a", "tactic_state": ""}]}
{"declaration": "example (x : \u2115) (h : x < 2) (H : Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) < 2) :\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) < 2 := by\n  generalize_proofs a at H \u22a2\n  guard_hyp a :\u209b \u2203 x, x < 2\n  guard_hyp H :\u209b Classical.choose a < 2\n  guard_target =\u209b Classical.choose a < 2\n  exact H\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\nH : Classical.choose \u22ef < 2\n\u22a2 Classical.choose \u22ef < 2"}, {"line": "  generalize_proofs a at H \u22a2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\nH : Classical.choose a < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  guard_hyp a :\u209b \u2203 x, x < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\nH : Classical.choose a < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  guard_hyp H :\u209b Classical.choose a < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\nH : Classical.choose a < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  guard_target =\u209b Classical.choose a < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\nH : Classical.choose a < 2\n\u22a2 Classical.choose a < 2"}, {"line": "  exact H", "tactic_state": ""}]}
{"declaration": "example (H : \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y) :\n    \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y := by\n  generalize_proofs (config := { abstract := false })\n  guard_target =\u209b \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y\n  generalize_proofs a at H \u22a2\n  guard_hyp a :\u209b \u2200 (y w : \u2115), w < y \u2192 \u2203 x, x < y\n  guard_hyp H :\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y\n  guard_target =\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y\n  exact H\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  generalize_proofs (config := { abstract := false })", "tactic_state": "H : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  guard_target =\u209b \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y", "tactic_state": "H : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  generalize_proofs a at H \u22a2", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  guard_hyp a :\u209b \u2200 (y w : \u2115), w < y \u2192 \u2203 x, x < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  guard_hyp H :\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  guard_target =\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  exact H", "tactic_state": ""}]}
{"declaration": "example (H : \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y) :\n    \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y := by\n  generalize_proofs a at *\n  guard_hyp a :\u209b \u2200 (y w : \u2115), w < y \u2192 \u2203 x, x < y\n  guard_hyp H :\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y\n  guard_target =\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y\n  exact H\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  generalize_proofs a at *", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  guard_hyp a :\u209b \u2200 (y w : \u2115), w < y \u2192 \u2203 x, x < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  guard_hyp H :\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  guard_target =\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "  exact H", "tactic_state": ""}]}
{"declaration": "example [Ring R] (S : Subring R) (hx : x \u2208 S) (hy : y \u2208 S) (hz : z \u2208 S) (n m : \u2115) :\n    n \u2022 x ^ 3 - 2 \u2022 y + z ^ m \u2208 S := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS\u271d S' : Submonoid M\nR : Type u_1\nx y z : R\ninst\u271d : Ring R\nS : Subring R\nhx : x \u2208 S\nhy : y \u2208 S\nhz : z \u2208 S\nn m : \u2115\n\u22a2 n \u2022 x ^ 3 - 2 \u2022 y + z ^ m \u2208 S"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Ring R] (S : Set R) (hx : x \u2208 S) (hy : y \u2208 S) (hz : z \u2208 S) (n m : \u2115) :\n    n \u2022 x ^ 3 - y + z ^ m \u2208 Subring.closure S := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS\u271d S' : Submonoid M\nR : Type u_1\nx y z : R\ninst\u271d : Ring R\nS : Set R\nhx : x \u2208 S\nhy : y \u2208 S\nhz : z \u2208 S\nn m : \u2115\n\u22a2 n \u2022 x ^ 3 - y + z ^ m \u2208 Subring.closure S"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [CommRing R] [Ring A] [Algebra R A] [StarRing R] [StarRing A] [StarModule R A]\n    (r : R) (a b c : A) (n : \u2115) :\n    -b + star (algebraMap R A r) + a ^ n * c \u2208 StarAlgebra.adjoin R {a, b, c} := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u2076 : Monoid M\nS S' : Submonoid M\nR : Type u_1\nA : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : StarRing R\ninst\u271d\u00b9 : StarRing A\ninst\u271d : StarModule R A\nr : R\na b c : A\nn : \u2115\n\u22a2 -b + star ((algebraMap R A) r) + a ^ n * c \u2208 StarAlgebra.adjoin R {a, b, c}"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Monoid M] (x : M) (n : \u2115) : x ^ n \u2208 Submonoid.closure {x} := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS S' : Submonoid M\ninst\u271d : Monoid M\nx : M\nn : \u2115\n\u22a2 x ^ n \u2208 Submonoid.closure {x}"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Monoid M] (x y z w : M) (n : \u2115) : (x * y) ^ n * w \u2208 Submonoid.closure {x, y, z, w} := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS S' : Submonoid M\ninst\u271d : Monoid M\nx y z w : M\nn : \u2115\n\u22a2 (x * y) ^ n * w \u2208 Submonoid.closure {x, y, z, w}"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Group M] (x : M) (n : \u2124) : x ^ n \u2208 Subgroup.closure {x} := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS S' : Submonoid M\ninst\u271d : Group M\nx : M\nn : \u2124\n\u22a2 x ^ n \u2208 Subgroup.closure {x}"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Monoid M] (x y z : M) (S\u2081 S\u2082 : Submonoid M) (h : S\u2081 \u2264 S\u2082) (hx : x \u2208 S\u2081)\n    (hy : y \u2208 S\u2081) (hz : z \u2208 S\u2082) :\n    x * y * z \u2208 S\u2082 := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS S' : Submonoid M\ninst\u271d : Monoid M\nx y z : M\nS\u2081 S\u2082 : Submonoid M\nh : S\u2081 \u2264 S\u2082\nhx : x \u2208 S\u2081\nhy : y \u2208 S\u2081\nhz : z \u2208 S\u2082\n\u22a2 x * y * z \u2208 S\u2082"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Monoid M] (x y z : M) (S\u2081 S\u2082 : Submonoid M) (h : S\u2081 \u2264 S\u2082) (hx : x \u2208 S\u2081)\n    (hy : y \u2208 S\u2081) (hz : z \u2208 S\u2082) :\n    x * y * z \u2208 S\u2081 \u2294 S\u2082 := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS S' : Submonoid M\ninst\u271d : Monoid M\nx y z : M\nS\u2081 S\u2082 : Submonoid M\nh : S\u2081 \u2264 S\u2082\nhx : x \u2208 S\u2081\nhy : y \u2208 S\u2081\nhz : z \u2208 S\u2082\n\u22a2 x * y * z \u2208 S\u2081 \u2294 S\u2082"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Monoid M] (x y z : M) (S : Submonoid M) (hxy : x * y \u2208 S) (hz : z \u2208 S) :\n    z * (x * y) \u2208 S := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS\u271d S' : Submonoid M\ninst\u271d : Monoid M\nx y z : M\nS : Submonoid M\nhxy : x * y \u2208 S\nhz : z \u2208 S\n\u22a2 z * (x * y) \u2208 S"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Field F] (S : Subfield F) (q : \u211a) : (q : F) \u2208 S := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS\u271d S' : Submonoid M\nF : Type u_1\ninst\u271d : Field F\nS : Subfield F\nq : \u211a\n\u22a2 \u2191q \u2208 S"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Field F] (S : Subfield F) : (1.2 : F) \u2208 S := by\n  aesop\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS\u271d S' : Submonoid M\nF : Type u_1\ninst\u271d : Field F\nS : Subfield F\n\u22a2 1.2 \u2208 S"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "example [Field F] (S : Subfield F) (x : F) (hx : x \u2208 S) : ((12e-100 : F) \u2022 x\u207b\u00b9) \u2208 S := by\n  aesop", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/set_like.lean", "context": {"open": [], "variables": ["{M : Type u} [Monoid M] (S S' : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b9 : Monoid M\nS\u271d S' : Submonoid M\nF : Type u_1\ninst\u271d : Field F\nS : Subfield F\nx : F\nhx : x \u2208 S\n\u22a2 12e-100 \u2022 x\u207b\u00b9 \u2208 S"}, {"line": "  aesop", "tactic_state": ""}]}
{"declaration": "theorem bar0_works : bar0 3 4 = 7 := by decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbar0 : x\u271d\n\u22a2 sorry = 7"}]}
{"declaration": "theorem foo1_works : foo1 3 4 = Nat.pow 3 4 := by decide", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfoo1 : x\u271d\n\u22a2 sorry = Nat.pow 3 4"}]}
{"declaration": "theorem bar1_works : bar1 3 4 = 3 * 4 := by decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbar1 : x\u271d\n\u22a2 sorry = 3 * 4"}]}
{"declaration": "theorem foo2_works : foo2 2 3 (PLift.up 2) = Nat.pow 2 5 := by decide", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfoo2 : x\u271d\n\u22a2 sorry = Nat.pow 2 5"}]}
{"declaration": "theorem bar2_works : bar2 2 3 (PLift.up 2) = 2 * 5 := by decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbar2 : x\u271d\n\u22a2 sorry = 2 * 5"}]}
{"declaration": "theorem foo3_works : foo3 2 3 = Nat.pow 2 3 := by decide", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfoo3 : x\u271d\n\u22a2 sorry = Nat.pow 2 3"}]}
{"declaration": "theorem bar3_works : bar3 2 3 = 2 * 3 := by decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbar3 : x\u271d\n\u22a2 sorry = 2 * 3"}]}
{"declaration": "theorem bar8_works : bar8 2 3 = 6 := by decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbar8 : x\u271d\n\u22a2 sorry = 6"}]}
{"declaration": "theorem bar9_works : bar9 = 1 := by decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "bar9 : \u2115\n\u22a2 bar9 = 1"}]}
{"declaration": "example [Group \u03b1] (x : \u03b1) : foo17 x = 1 * x := by simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\nfoo17 : x\u271d\ninst\u271d : Group \u03b1\nx : \u03b1\n\u22a2 sorry = 1 * x"}]}
{"declaration": "example [Group \u03b1] (x : \u03b1) : foo17 x = x := by simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\nfoo17 : x\u271d\ninst\u271d : Group \u03b1\nx : \u03b1\n\u22a2 sorry = x"}]}
{"declaration": "example [AddGroup \u03b1] (x : \u03b1) : bar17 x = 0 + x := by simp", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\nbar17 : x\u271d\ninst\u271d : AddGroup \u03b1\nx : \u03b1\n\u22a2 sorry = 0 + x"}]}
{"declaration": "example [AddGroup \u03b1] (x : \u03b1) : bar17 x = x := by simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\nbar17 : x\u271d\ninst\u271d : AddGroup \u03b1\nx : \u03b1\n\u22a2 sorry = x"}]}
{"declaration": "example {x} (h : 1 = x) : foo19 = x := by simp; guard_target = 1 = x; exact h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "foo19 x : \u2115\nh : 1 = x\n\u22a2 foo19 = x"}]}
{"declaration": "example {x} (h : 1 = x) : bar19 = x := by simp; guard_target = 1 = x; exact h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "bar19 x : \u2115\nh : 1 = x\n\u22a2 bar19 = x"}]}
{"declaration": "example {x} (h : 1 = x) : baz19 = x := by simp; guard_target = 1 = x; exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "baz19 x : \u2115\nh : 1 = x\n\u22a2 baz19 = x"}]}
{"declaration": "example {x} (h : 1 = x) : foo20 = x := by simp; guard_target = 1 = x; exact h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "foo20 x : \u2115\nh : 1 = x\n\u22a2 foo20 = x"}]}
{"declaration": "example {x} (h : 1 = x) : bar20 = x := by simp; guard_target = 1 = x; exact h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "bar20 x : \u2115\nh : 1 = x\n\u22a2 bar20 = x"}]}
{"declaration": "example {x} (h : 1 = x) : baz20 = x := by simp; guard_target = 1 = x; exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/toAdditive.lean", "context": {"open": ["Qq Lean Meta Elab Command ToAdditive"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "baz20 x : \u2115\nh : 1 = x\n\u22a2 baz20 = x"}]}
{"declaration": "example [TopologicalSpace \u03b1] [inst : MeasurableSpace \u03b1] [BorelSpace \u03b1] :\n    MeasurableSet (\u2205 : Set \u03b1) := by\n  guard_target = @MeasurableSet \u03b1 inst \u2205\n  borelize \u03b1\n  guard_target = @MeasurableSet \u03b1 (borel \u03b1) \u2205\n  apply MeasurableSet.empty\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/borelize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst : MeasurableSpace \u03b1\ninst\u271d : BorelSpace \u03b1\n\u22a2 MeasurableSet \u2205"}, {"line": "  guard_target = @MeasurableSet \u03b1 inst \u2205", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst : MeasurableSpace \u03b1\ninst\u271d : BorelSpace \u03b1\n\u22a2 MeasurableSet \u2205"}, {"line": "  borelize \u03b1", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : BorelSpace \u03b1\nthis\u271d : MeasurableSpace \u03b1 := borel \u03b1\n\u22a2 MeasurableSet \u2205"}, {"line": "  guard_target = @MeasurableSet \u03b1 (borel \u03b1) \u2205", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : BorelSpace \u03b1\nthis\u271d : MeasurableSpace \u03b1 := borel \u03b1\n\u22a2 MeasurableSet \u2205"}, {"line": "  apply MeasurableSet.empty", "tactic_state": ""}]}
{"declaration": "example [TopologicalSpace \u03b1] : True := by\n  borelize \u03b1\n  have h : MeasurableSet (\u2205 : Set \u03b1) := MeasurableSet.empty\n  guard_hyp h : @MeasurableSet \u03b1 (borel \u03b1) \u2205\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/borelize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 True"}, {"line": "  borelize \u03b1", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\n\u22a2 True"}, {"line": "  have h : MeasurableSet (\u2205 : Set \u03b1) := MeasurableSet.empty", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\nh : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  guard_hyp h : @MeasurableSet \u03b1 (borel \u03b1) \u2205", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\nh : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : True := by\n  obtain \u27e8\u03b1, \u27e8h\u03b1\u27e9\u27e9 : \u2203 \u03b1 : Type, Nonempty (TopologicalSpace \u03b1) := \u27e8\u2115, \u27e8inferInstance\u27e9\u27e9\n  borelize \u03b1\n  have h : MeasurableSet (\u2205 : Set \u03b1) := MeasurableSet.empty\n  guard_hyp h : @MeasurableSet \u03b1 (borel \u03b1) \u2205\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/borelize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  obtain \u27e8\u03b1, \u27e8h\u03b1\u27e9\u27e9 : \u2203 \u03b1 : Type, Nonempty (TopologicalSpace \u03b1) := \u27e8\u2115, \u27e8inferInstance\u27e9\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type\nh\u03b1 : TopologicalSpace \u03b1\n\u22a2 True"}, {"line": "  borelize \u03b1", "tactic_state": "case intro.intro\n\u03b1 : Type\nh\u03b1 : TopologicalSpace \u03b1\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\n\u22a2 True"}, {"line": "  have h : MeasurableSet (\u2205 : Set \u03b1) := MeasurableSet.empty", "tactic_state": "case intro.intro\n\u03b1 : Type\nh\u03b1 : TopologicalSpace \u03b1\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\nh : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  guard_hyp h : @MeasurableSet \u03b1 (borel \u03b1) \u2205", "tactic_state": "case intro.intro\n\u03b1 : Type\nh\u03b1 : TopologicalSpace \u03b1\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\nh : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : True := by\n  set \u03b1 := \u2115\n  borelize \u03b1\n  have h : MeasurableSet (\u2205 : Set \u03b1) := MeasurableSet.empty\n  guard_hyp h : @MeasurableSet \u03b1 (borel \u03b1) \u2205\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/borelize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  set \u03b1 := \u2115", "tactic_state": "\u03b1 : Type := \u2115\n\u22a2 True"}, {"line": "  borelize \u03b1", "tactic_state": "\u03b1 : Type := \u2115\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\n\u22a2 True"}, {"line": "  have h : MeasurableSet (\u2205 : Set \u03b1) := MeasurableSet.empty", "tactic_state": "\u03b1 : Type := \u2115\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\nh : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  guard_hyp h : @MeasurableSet \u03b1 (borel \u03b1) \u2205", "tactic_state": "\u03b1 : Type := \u2115\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := borel \u03b1\nthis\u271d : BorelSpace \u03b1\nh : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : True := by\n  have h1 : MeasurableSet (\u2205 : Set \u2115) := MeasurableSet.empty\n  guard_hyp h1 : @MeasurableSet \u2115 Nat.instMeasurableSpace \u2205\n  borelize \u2115\n  have h2 : MeasurableSet (\u2205 : Set \u2115) := MeasurableSet.empty\n  guard_hyp h2 : @MeasurableSet \u2115 (borel \u2115) \u2205\n  trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/borelize.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "  have h1 : MeasurableSet (\u2205 : Set \u2115) := MeasurableSet.empty", "tactic_state": "h1 : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  guard_hyp h1 : @MeasurableSet \u2115 Nat.instMeasurableSpace \u2205", "tactic_state": "h1 : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  borelize \u2115", "tactic_state": "h1 : MeasurableSet \u2205\nthis\u271d\u00b9 : MeasurableSpace \u2115 := borel \u2115\nthis\u271d : BorelSpace \u2115\n\u22a2 True"}, {"line": "  have h2 : MeasurableSet (\u2205 : Set \u2115) := MeasurableSet.empty", "tactic_state": "h1 : MeasurableSet \u2205\nthis\u271d\u00b9 : MeasurableSpace \u2115 := borel \u2115\nthis\u271d : BorelSpace \u2115\nh2 : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  guard_hyp h2 : @MeasurableSet \u2115 (borel \u2115) \u2205", "tactic_state": "h1 : MeasurableSet \u2205\nthis\u271d\u00b9 : MeasurableSpace \u2115 := borel \u2115\nthis\u271d : BorelSpace \u2115\nh2 : MeasurableSet \u2205\n\u22a2 True"}, {"line": "  trivial", "tactic_state": ""}]}
{"declaration": "example : id (1 = 1) := by\n  with_reducible whnf\n  guard_target =\u209b id (1 = 1)\n  whnf\n  guard_target =\u209b 1 = 1\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 id (1 = 1)"}, {"line": "  with_reducible whnf", "tactic_state": "\u22a2 id (1 = 1)"}, {"line": "  guard_target =\u209b id (1 = 1)", "tactic_state": "\u22a2 id (1 = 1)"}, {"line": "  whnf", "tactic_state": "\u22a2 1 = 1"}, {"line": "  guard_target =\u209b 1 = 1", "tactic_state": "\u22a2 1 = 1"}, {"line": "  rfl", "tactic_state": ""}]}
{"declaration": "example : (fun x => 1 + x) 1 = 2 := by\n  beta_reduce\n  guard_target =\u209b 1 + 1 = 2\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun x => 1 + x) 1 = 2"}, {"line": "  beta_reduce", "tactic_state": "\u22a2 1 + 1 = 2"}, {"line": "  guard_target =\u209b 1 + 1 = 2", "tactic_state": "\u22a2 1 + 1 = 2"}, {"line": "  rfl", "tactic_state": ""}]}
