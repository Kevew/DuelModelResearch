{"declaration": "theorem leftDual_mem_rightFixedPoint (J : Set \u03b1) : R.leftDual J \u2208 R.rightFixedPoints := by\n  apply le_antisymm\n  \u00b7 apply R.gc_leftDual_rightDual.monotone_l; exact R.gc_leftDual_rightDual.le_u_l J\n  \u00b7 exact R.gc_leftDual_rightDual.l_u_le (R.leftDual J)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Rel/GaloisConnection.lean", "context": {"open": ["OrderDual", "GaloisConnection"], "variables": ["{\u03b1 \u03b2 : Type*} (R : Rel \u03b1 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Rel \u03b1 \u03b2\nJ : Set \u03b1\n\u22a2 R.leftDual J \u2208 R.rightFixedPoints"}, {"line": "apply le_antisymm", "tactic_state": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Rel \u03b1 \u03b2\nJ : Set \u03b1\n\u22a2 R.leftDual (R.rightDual (R.leftDual J)) \u2264 R.leftDual J\n---\ncase a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Rel \u03b1 \u03b2\nJ : Set \u03b1\n\u22a2 R.leftDual J \u2264 R.leftDual (R.rightDual (R.leftDual J))"}, {"line": "\u00b7 apply R.gc_leftDual_rightDual.monotone_l; exact R.gc_leftDual_rightDual.le_u_l J", "tactic_state": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Rel \u03b1 \u03b2\nJ : Set \u03b1\n\u22a2 R.leftDual J \u2264 R.leftDual (R.rightDual (R.leftDual J))"}, {"line": "\u00b7 exact R.gc_leftDual_rightDual.l_u_le (R.leftDual J)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rightDual_mem_leftFixedPoint (I : Set \u03b2) : R.rightDual I \u2208 R.leftFixedPoints := by\n  apply le_antisymm\n  \u00b7 apply R.gc_leftDual_rightDual.monotone_u; exact R.gc_leftDual_rightDual.l_u_le I\n  \u00b7 exact R.gc_leftDual_rightDual.le_u_l (R.rightDual I)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Rel/GaloisConnection.lean", "context": {"open": ["OrderDual", "GaloisConnection"], "variables": ["{\u03b1 \u03b2 : Type*} (R : Rel \u03b1 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Rel \u03b1 \u03b2\nI : Set \u03b2\n\u22a2 R.rightDual I \u2208 R.leftFixedPoints"}, {"line": "apply le_antisymm", "tactic_state": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Rel \u03b1 \u03b2\nI : Set \u03b2\n\u22a2 R.rightDual (R.leftDual (R.rightDual I)) \u2264 R.rightDual I\n---\ncase a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Rel \u03b1 \u03b2\nI : Set \u03b2\n\u22a2 R.rightDual I \u2264 R.rightDual (R.leftDual (R.rightDual I))"}, {"line": "\u00b7 apply R.gc_leftDual_rightDual.monotone_u; exact R.gc_leftDual_rightDual.l_u_le I", "tactic_state": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Rel \u03b1 \u03b2\nI : Set \u03b2\n\u22a2 R.rightDual I \u2264 R.rightDual (R.leftDual (R.rightDual I))"}, {"line": "\u00b7 exact R.gc_leftDual_rightDual.le_u_l (R.rightDual I)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rightDual_leftDual_le_of_le {J J' : Set \u03b1} (h : J' \u2208 R.leftFixedPoints) (h\u2081 : J \u2264 J') :\n    R.rightDual (R.leftDual J) \u2264 J' := by\n  rw [\u2190 h]\n  apply R.gc_leftDual_rightDual.monotone_u\n  apply R.gc_leftDual_rightDual.monotone_l\n  exact h\u2081\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Rel/GaloisConnection.lean", "context": {"open": ["OrderDual", "GaloisConnection"], "variables": ["{\u03b1 \u03b2 : Type*} (R : Rel \u03b1 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Rel \u03b1 \u03b2\nJ J' : Set \u03b1\nh : J' \u2208 R.leftFixedPoints\nh\u2081 : J \u2264 J'\n\u22a2 R.rightDual (R.leftDual J) \u2264 J'"}, {"line": "rw [\u2190 h]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Rel \u03b1 \u03b2\nJ J' : Set \u03b1\nh : J' \u2208 R.leftFixedPoints\nh\u2081 : J \u2264 J'\n\u22a2 R.rightDual (R.leftDual J) \u2264 R.rightDual (R.leftDual J')"}, {"line": "apply R.gc_leftDual_rightDual.monotone_u", "tactic_state": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Rel \u03b1 \u03b2\nJ J' : Set \u03b1\nh : J' \u2208 R.leftFixedPoints\nh\u2081 : J \u2264 J'\n\u22a2 (fun b => \u2200 \u2983a : \u03b1\u2984, a \u2208 J \u2192 R a b) \u2264 fun b => \u2200 \u2983a : \u03b1\u2984, a \u2208 J' \u2192 R a b"}, {"line": "apply R.gc_leftDual_rightDual.monotone_l", "tactic_state": "case a.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Rel \u03b1 \u03b2\nJ J' : Set \u03b1\nh : J' \u2208 R.leftFixedPoints\nh\u2081 : J \u2264 J'\n\u22a2 J \u2264 J'"}, {"line": "exact h\u2081", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leftDual_rightDual_le_of_le {I I' : Set \u03b2} (h : I' \u2208 R.rightFixedPoints) (h\u2081 : I \u2264 I') :\n    R.leftDual (R.rightDual I) \u2264 I' := by\n  rw [\u2190 h]\n  apply R.gc_leftDual_rightDual.monotone_l\n  apply R.gc_leftDual_rightDual.monotone_u\n  exact h\u2081\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Rel/GaloisConnection.lean", "context": {"open": ["OrderDual", "GaloisConnection"], "variables": ["{\u03b1 \u03b2 : Type*} (R : Rel \u03b1 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Rel \u03b1 \u03b2\nI I' : Set \u03b2\nh : I' \u2208 R.rightFixedPoints\nh\u2081 : I \u2264 I'\n\u22a2 R.leftDual (R.rightDual I) \u2264 I'"}, {"line": "rw [\u2190 h]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Rel \u03b1 \u03b2\nI I' : Set \u03b2\nh : I' \u2208 R.rightFixedPoints\nh\u2081 : I \u2264 I'\n\u22a2 R.leftDual (R.rightDual I) \u2264 R.leftDual (R.rightDual I')"}, {"line": "apply R.gc_leftDual_rightDual.monotone_l", "tactic_state": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Rel \u03b1 \u03b2\nI I' : Set \u03b2\nh : I' \u2208 R.rightFixedPoints\nh\u2081 : I \u2264 I'\n\u22a2 R.rightDual I' \u2264 R.rightDual I"}, {"line": "apply R.gc_leftDual_rightDual.monotone_u", "tactic_state": "case a.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Rel \u03b1 \u03b2\nI I' : Set \u03b2\nh : I' \u2208 R.rightFixedPoints\nh\u2081 : I \u2264 I'\n\u22a2 I' \u2264 I"}, {"line": "exact h\u2081", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_eq (e : r \u2243r s) : Set.range e = Set.univ := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelIso/Set.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{F : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ne : r \u2243r s\n\u22a2 Set.range \u21d1e = Set.univ"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_preimage (f : r \u21aar s) : r = f \u207b\u00b9'o s := by\n  ext a b\n  exact f.map_rel_iff.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelIso/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{F : Type*} [FunLike F \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : r \u21aar s\n\u22a2 r = \u21d1f \u207b\u00b9'o s"}, {"line": "ext a b", "tactic_state": "case h.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : r \u21aar s\na b : \u03b1\n\u22a2 r a b \u2194 (\u21d1f \u207b\u00b9'o s) a b"}, {"line": "exact f.map_rel_iff.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem symm_apply_rel (e : r \u2243r s) {x y} : r (e.symm x) y \u2194 s x (e y) := by\n  rw [\u2190 e.map_rel_iff]\n  rw [e.apply_symm_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelIso/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{F : Type*} [FunLike F \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ne : r \u2243r s\nx : \u03b2\ny : \u03b1\n\u22a2 r (e.symm x) y \u2194 s x (e y)"}, {"line": "rw [\u2190 e.map_rel_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ne : r \u2243r s\nx : \u03b2\ny : \u03b1\n\u22a2 s (e (e.symm x)) (e y) \u2194 s x (e y)"}, {"line": "rw [e.apply_symm_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem apply_wCovBy_apply_iff (f : \u03b1 \u2264i \u03b2) : f a \u2a7f f b \u2194 a \u2a7f b := by\n  simp [wcovBy_iff_eq_or_covBy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/InitialSeg.lean", "context": {"open": ["Order"], "variables": ["{\u03b1 \u03b2 : Type*} {a b : \u03b1} [PartialOrder \u03b1] [PartialOrder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na b : \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nf : InitialSeg (fun x1 x2 => x1 < x2) fun x1 x2 => x1 < x2\n\u22a2 f a \u2a7f f b \u2194 a \u2a7f b"}, {"line": "simp [wcovBy_iff_eq_or_covBy]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isSuccLimit_apply_iff (f : \u03b1 \u2264i \u03b2) : IsSuccLimit (f a) \u2194 IsSuccLimit a := by\n  simp [IsSuccLimit]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/InitialSeg.lean", "context": {"open": ["Order"], "variables": ["{\u03b1 \u03b2 : Type*} {a b : \u03b1} [PartialOrder \u03b1] [PartialOrder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nf : InitialSeg (fun x1 x2 => x1 < x2) fun x1 x2 => x1 < x2\n\u22a2 IsSuccLimit (f a) \u2194 IsSuccLimit a"}, {"line": "simp [IsSuccLimit]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reflTransGen_of_succ_of_ge (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {n m : \u03b1} (h : \u2200 i \u2208 Ico m n, r (succ i) i)\n    (hmn : m \u2264 n) : ReflTransGen r n m := by\n  rw [\u2190 reflTransGen_swap]\n  exact reflTransGen_of_succ_of_le (swap r) h hmn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Relation.lean", "context": {"open": ["Function Order Relation Set"], "variables": ["{\u03b1 : Type*} [PartialOrder \u03b1] [SuccOrder \u03b1] [IsSuccArchimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nn m : \u03b1\nh : \u2200 i \u2208 Ico m n, r (succ i) i\nhmn : m \u2264 n\n\u22a2 ReflTransGen r n m"}, {"line": "rw [\u2190 reflTransGen_swap]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nn m : \u03b1\nh : \u2200 i \u2208 Ico m n, r (succ i) i\nhmn : m \u2264 n\n\u22a2 ReflTransGen (swap r) m n"}, {"line": "exact reflTransGen_of_succ_of_le (swap r) h hmn", "tactic_state": "No Goals!"}]}
{"declaration": "lemma SubRootedTree.bot_mem_iff {t : RootedTree} (r : SubRootedTree t) :\n    \u22a5 \u2208 r \u2194 r.root = \u22a5 := by\n  simp [mem_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Tree.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [PartialOrder \u03b1] [PredOrder \u03b1] [IsPredArchimedean \u03b1]", "[OrderBot \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "t : RootedTree\nr : SubRootedTree t\n\u22a2 \u22a5 \u2208 r \u2194 r.root = \u22a5"}, {"line": "simp [mem_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma SubRootedTree.root_ne_bot_of_mem_subtrees (r : SubRootedTree t) (hr : r \u2208 t.subtrees) :\n    r.root \u2260 \u22a5 := by\n  simp only [RootedTree.subtrees] at hr\n  simp only [Set.mem_setOf_eq] at hr\n  exact hr.1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Tree.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [PartialOrder \u03b1] [PredOrder \u03b1] [IsPredArchimedean \u03b1]", "[OrderBot \u03b1]", "[DecidableEq \u03b1]", "{t : RootedTree}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "t : RootedTree\nr : SubRootedTree t\nhr : r \u2208 t.subtrees\n\u22a2 r.root \u2260 \u22a5"}, {"line": "simp only [RootedTree.subtrees] at hr", "tactic_state": "t : RootedTree\nr : SubRootedTree t\nhr : r \u2208 {x | IsAtom x.root}\n\u22a2 r.root \u2260 \u22a5"}, {"line": "simp only [Set.mem_setOf_eq] at hr", "tactic_state": "t : RootedTree\nr : SubRootedTree t\nhr : IsAtom r.root\n\u22a2 r.root \u2260 \u22a5"}, {"line": "exact hr.1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma RootedTree.subtrees_disjoint : t.subtrees.PairwiseDisjoint ((\u2191) : _ \u2192 Set t) := by\n  intro t\u2081 ht\u2081 t\u2082 ht\u2082 h\n  rw [Function.onFun_apply]\n  rw [Set.disjoint_left]\n  intro a ha hb\n  rw [\u2190 mem_subtrees_disjoint_iff ht\u2081 ht\u2082 a a ha hb] at h\n  rw [disjoint_self] at h\n  subst h\n  simp only [SetLike.mem_coe] at ha\n  simp only [SubRootedTree.bot_mem_iff] at ha\n  exact t\u2081.root_ne_bot_of_mem_subtrees ht\u2081 ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Tree.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [PartialOrder \u03b1] [PredOrder \u03b1] [IsPredArchimedean \u03b1]", "[OrderBot \u03b1]", "[DecidableEq \u03b1]", "{t : RootedTree}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "t : RootedTree\n\u22a2 t.subtrees.PairwiseDisjoint SetLike.coe"}, {"line": "intro t\u2081 ht\u2081 t\u2082 ht\u2082 h", "tactic_state": "t : RootedTree\nt\u2081 : SubRootedTree t\nht\u2081 : t\u2081 \u2208 t.subtrees\nt\u2082 : SubRootedTree t\nht\u2082 : t\u2082 \u2208 t.subtrees\nh : t\u2081 \u2260 t\u2082\n\u22a2 Function.onFun Disjoint SetLike.coe t\u2081 t\u2082"}, {"line": "rw [Function.onFun_apply]", "tactic_state": "t : RootedTree\nt\u2081 : SubRootedTree t\nht\u2081 : t\u2081 \u2208 t.subtrees\nt\u2082 : SubRootedTree t\nht\u2082 : t\u2082 \u2208 t.subtrees\nh : t\u2081 \u2260 t\u2082\n\u22a2 Disjoint \u2191t\u2081 \u2191t\u2082"}, {"line": "rw [Set.disjoint_left]", "tactic_state": "t : RootedTree\nt\u2081 : SubRootedTree t\nht\u2081 : t\u2081 \u2208 t.subtrees\nt\u2082 : SubRootedTree t\nht\u2082 : t\u2082 \u2208 t.subtrees\nh : t\u2081 \u2260 t\u2082\n\u22a2 \u2200 \u2983a : \u2191t\u2984, a \u2208 \u2191t\u2081 \u2192 a \u2209 \u2191t\u2082"}, {"line": "intro a ha hb", "tactic_state": "t : RootedTree\nt\u2081 : SubRootedTree t\nht\u2081 : t\u2081 \u2208 t.subtrees\nt\u2082 : SubRootedTree t\nht\u2082 : t\u2082 \u2208 t.subtrees\nh : t\u2081 \u2260 t\u2082\na : \u2191t\nha : a \u2208 \u2191t\u2081\nhb : a \u2208 \u2191t\u2082\n\u22a2 False"}, {"line": "rw [\u2190 mem_subtrees_disjoint_iff ht\u2081 ht\u2082 a a ha hb] at h", "tactic_state": "t : RootedTree\nt\u2081 : SubRootedTree t\nht\u2081 : t\u2081 \u2208 t.subtrees\nt\u2082 : SubRootedTree t\nht\u2082 : t\u2082 \u2208 t.subtrees\na : \u2191t\nh : Disjoint a a\nha : a \u2208 \u2191t\u2081\nhb : a \u2208 \u2191t\u2082\n\u22a2 False"}, {"line": "rw [disjoint_self] at h", "tactic_state": "t : RootedTree\nt\u2081 : SubRootedTree t\nht\u2081 : t\u2081 \u2208 t.subtrees\nt\u2082 : SubRootedTree t\nht\u2082 : t\u2082 \u2208 t.subtrees\na : \u2191t\nh : a = \u22a5\nha : a \u2208 \u2191t\u2081\nhb : a \u2208 \u2191t\u2082\n\u22a2 False"}, {"line": "subst h", "tactic_state": "t : RootedTree\nt\u2081 : SubRootedTree t\nht\u2081 : t\u2081 \u2208 t.subtrees\nt\u2082 : SubRootedTree t\nht\u2082 : t\u2082 \u2208 t.subtrees\nha : \u22a5 \u2208 \u2191t\u2081\nhb : \u22a5 \u2208 \u2191t\u2082\n\u22a2 False"}, {"line": "simp only [SetLike.mem_coe] at ha", "tactic_state": "t : RootedTree\nt\u2081 : SubRootedTree t\nht\u2081 : t\u2081 \u2208 t.subtrees\nt\u2082 : SubRootedTree t\nht\u2082 : t\u2082 \u2208 t.subtrees\nhb : \u22a5 \u2208 \u2191t\u2082\nha : \u22a5 \u2208 t\u2081\n\u22a2 False"}, {"line": "simp only [SubRootedTree.bot_mem_iff] at ha", "tactic_state": "t : RootedTree\nt\u2081 : SubRootedTree t\nht\u2081 : t\u2081 \u2208 t.subtrees\nt\u2082 : SubRootedTree t\nht\u2082 : t\u2082 \u2208 t.subtrees\nhb : \u22a5 \u2208 \u2191t\u2082\nha : t\u2081.root = \u22a5\n\u22a2 False"}, {"line": "exact t\u2081.root_ne_bot_of_mem_subtrees ht\u2081 ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma RootedTree.mem_subtreeOf [DecidableEq t] {v : t} :\n    v \u2208 t.subtreeOf v := by\n  simp [SubRootedTree.mem_iff, RootedTree.subtreeOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Tree.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [PartialOrder \u03b1] [PredOrder \u03b1] [IsPredArchimedean \u03b1]", "[OrderBot \u03b1]", "[DecidableEq \u03b1]", "{t : RootedTree}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "t : RootedTree\ninst\u271d : DecidableEq \u2191t\nv : \u2191t\n\u22a2 v \u2208 t.subtreeOf v"}, {"line": "simp [SubRootedTree.mem_iff, RootedTree.subtreeOf]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma RootedTree.subtreeOf_mem_subtrees [DecidableEq t] {v : t} (hr : v \u2260 \u22a5) :\n    t.subtreeOf v \u2208 t.subtrees := by\n  simpa [RootedTree.subtrees, RootedTree.subtreeOf]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Tree.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [PartialOrder \u03b1] [PredOrder \u03b1] [IsPredArchimedean \u03b1]", "[OrderBot \u03b1]", "[DecidableEq \u03b1]", "{t : RootedTree}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "t : RootedTree\ninst\u271d : DecidableEq \u2191t\nv : \u2191t\nhr : v \u2260 \u22a5\n\u22a2 t.subtreeOf v \u2208 t.subtrees"}, {"line": "simpa [RootedTree.subtrees, RootedTree.subtreeOf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_succ_iterate_iff_le : (\u2203 n, succ^[n] a = b) \u2194 a \u2264 b := by\n  refine \u27e8?_, exists_succ_iterate_of_le\u27e9\n  rintro \u27e8n, rfl\u27e9\n  exact id_le_iterate_of_id_le le_succ n a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Archimedean.lean", "context": {"open": ["Order Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[SuccOrder \u03b1] [IsSuccArchimedean \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\na b : \u03b1\n\u22a2 (\u2203 n, succ^[n] a = b) \u2194 a \u2264 b"}, {"line": "refine \u27e8?_, exists_succ_iterate_of_le\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\na b : \u03b1\n\u22a2 (\u2203 n, succ^[n] a = b) \u2192 a \u2264 b"}, {"line": "rintro \u27e8n, rfl\u27e9", "tactic_state": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\na : \u03b1\nn : \u2115\n\u22a2 a \u2264 succ^[n] a"}, {"line": "exact id_le_iterate_of_id_le le_succ n a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Icc_subset_Ico_succ_right_of_not_isMax (hb : \u00acIsMax b) : Icc a b \u2286 Ico a (succ b) := by\n  rw [\u2190 Ici_inter_Iio]\n  rw [\u2190 Ici_inter_Iic]\n  gcongr\n  intro _ h\n  apply lt_succ_of_le_of_not_isMax h hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Basic.lean", "context": {"open": ["Function OrderDual Set", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LinearOrder \u03b1]", "(\u03b1)", "[Preorder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\nhb : \u00acIsMax b\n\u22a2 Icc a b \u2286 Ico a sorry"}, {"line": "rw [\u2190 Ici_inter_Iio]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\nhb : \u00acIsMax b\n\u22a2 Icc a b \u2286 Ici a \u2229 Iio sorry"}, {"line": "rw [\u2190 Ici_inter_Iic]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\nhb : \u00acIsMax b\n\u22a2 Ici a \u2229 Iic b \u2286 Ici a \u2229 Iio sorry"}, {"line": "gcongr", "tactic_state": "case H\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\nhb : \u00acIsMax b\n\u22a2 Iic b \u2286 Iio sorry"}, {"line": "intro _ h", "tactic_state": "case H\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\nhb : \u00acIsMax b\na\u271d : \u03b1\nh : a\u271d \u2208 Iic b\n\u22a2 a\u271d \u2208 Iio sorry"}, {"line": "apply lt_succ_of_le_of_not_isMax h hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ioc_subset_Ioo_succ_right_of_not_isMax (hb : \u00acIsMax b) : Ioc a b \u2286 Ioo a (succ b) := by\n  rw [\u2190 Ioi_inter_Iio]\n  rw [\u2190 Ioi_inter_Iic]\n  gcongr\n  intro _ h\n  apply Iic_subset_Iio_succ_of_not_isMax hb h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Basic.lean", "context": {"open": ["Function OrderDual Set", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LinearOrder \u03b1]", "(\u03b1)", "[Preorder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\nhb : \u00acIsMax b\n\u22a2 Ioc a b \u2286 Ioo a sorry"}, {"line": "rw [\u2190 Ioi_inter_Iio]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\nhb : \u00acIsMax b\n\u22a2 Ioc a b \u2286 Ioi a \u2229 Iio sorry"}, {"line": "rw [\u2190 Ioi_inter_Iic]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\nhb : \u00acIsMax b\n\u22a2 Ioi a \u2229 Iic b \u2286 Ioi a \u2229 Iio sorry"}, {"line": "gcongr", "tactic_state": "case H\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\nhb : \u00acIsMax b\n\u22a2 Iic b \u2286 Iio sorry"}, {"line": "intro _ h", "tactic_state": "case H\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\nhb : \u00acIsMax b\na\u271d : \u03b1\nh : a\u271d \u2208 Iic b\n\u22a2 a\u271d \u2208 Iio sorry"}, {"line": "apply Iic_subset_Iio_succ_of_not_isMax hb h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Iic_subset_Iio_succ (a : \u03b1) : Iic a \u2286 Iio (succ a) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Basic.lean", "context": {"open": ["Function OrderDual Set", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LinearOrder \u03b1]", "(\u03b1)", "[Preorder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\na : \u03b1\n\u22a2 Iic a \u2286 Iio sorry"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\na : \u03b1\n\u22a2 a < sorry ()"}]}
{"declaration": "lemma le_iff_eq_or_succ_le : a \u2264 b \u2194 a = b \u2228 succ a \u2264 b := by\n  by_cases ha : IsMax a\n  \u00b7 simpa [ha.succ_eq] using le_of_eq\n  \u00b7 rw [succ_le_iff_of_not_isMax ha, le_iff_eq_or_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Basic.lean", "context": {"open": ["Function OrderDual Set", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LinearOrder \u03b1]", "(\u03b1)", "[Preorder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[PartialOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\n\u22a2 a \u2264 b \u2194 a = b \u2228 sorry \u2264 b"}, {"line": "by_cases ha : IsMax a", "tactic_state": "case pos\n\u03b1 : Type u_2\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\nha : sorry\n\u22a2 a \u2264 b \u2194 a = b \u2228 sorry \u2264 b\n---\ncase neg\n\u03b1 : Type u_2\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\nha : \u00acsorry\n\u22a2 a \u2264 b \u2194 a = b \u2228 sorry \u2264 b"}, {"line": "\u00b7 simpa [ha.succ_eq] using le_of_eq", "tactic_state": "case neg\n\u03b1 : Type u_2\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\nha : \u00acsorry\n\u22a2 a \u2264 b \u2194 a = b \u2228 sorry \u2264 b"}, {"line": "\u00b7 rw [succ_le_iff_of_not_isMax ha, le_iff_eq_or_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.OrderIso.map_succ [PartialOrder \u03b2] [SuccOrder \u03b2] (f : \u03b1 \u2243o \u03b2) (a : \u03b1) :\n    f (succ a) = succ (f a) := by\n  by_cases h : IsMax a\n  \u00b7 rw [h.succ_eq, (f.isMax_apply.2 h).succ_eq]\n  \u00b7 exact (f.map_covBy.2 <| covBy_succ_of_not_isMax h).succ_eq.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Basic.lean", "context": {"open": ["Function OrderDual Set", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LinearOrder \u03b1]", "(\u03b1)", "[Preorder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[PartialOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : SuccOrder \u03b1\ninst\u271d\u2074 : NoMaxOrder \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : SuccOrder \u03b1\n\u03b2 : Type u_1\nx\u271d : Sort u_2\nsucc : x\u271d\ninst\u271d\u00b9 : PartialOrder \u03b2\ninst\u271d : SuccOrder \u03b2\nf : \u03b1 \u2243o \u03b2\na : \u03b1\n\u22a2 f sorry = sorry"}, {"line": "by_cases h : IsMax a", "tactic_state": "case pos\n\u03b1 : Type u_3\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : SuccOrder \u03b1\ninst\u271d\u2074 : NoMaxOrder \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : SuccOrder \u03b1\n\u03b2 : Type u_1\nx\u271d : Sort u_2\nsucc : x\u271d\ninst\u271d\u00b9 : PartialOrder \u03b2\ninst\u271d : SuccOrder \u03b2\nf : \u03b1 \u2243o \u03b2\na : \u03b1\nh : sorry\n\u22a2 f sorry = sorry\n---\ncase neg\n\u03b1 : Type u_3\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : SuccOrder \u03b1\ninst\u271d\u2074 : NoMaxOrder \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : SuccOrder \u03b1\n\u03b2 : Type u_1\nx\u271d : Sort u_2\nsucc : x\u271d\ninst\u271d\u00b9 : PartialOrder \u03b2\ninst\u271d : SuccOrder \u03b2\nf : \u03b1 \u2243o \u03b2\na : \u03b1\nh : \u00acsorry\n\u22a2 f sorry = sorry"}, {"line": "\u00b7 rw [h.succ_eq, (f.isMax_apply.2 h).succ_eq]", "tactic_state": "case neg\n\u03b1 : Type u_3\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : SuccOrder \u03b1\ninst\u271d\u2074 : NoMaxOrder \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : SuccOrder \u03b1\n\u03b2 : Type u_1\nx\u271d : Sort u_2\nsucc : x\u271d\ninst\u271d\u00b9 : PartialOrder \u03b2\ninst\u271d : SuccOrder \u03b2\nf : \u03b1 \u2243o \u03b2\na : \u03b1\nh : \u00acsorry\n\u22a2 f sorry = sorry"}, {"line": "\u00b7 exact (f.map_covBy.2 <| covBy_succ_of_not_isMax h).succ_eq.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_succ_iff_eq_or_le : a \u2264 succ b \u2194 a = succ b \u2228 a \u2264 b := by\n  by_cases hb : IsMax b\n  \u00b7 rw [hb.succ_eq, or_iff_right_of_imp le_of_eq]\n  \u00b7 rw [\u2190 lt_succ_iff_of_not_isMax hb, le_iff_eq_or_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Basic.lean", "context": {"open": ["Function OrderDual Set", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LinearOrder \u03b1]", "(\u03b1)", "[Preorder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[PartialOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[OrderTop \u03b1]", "[OrderBot \u03b1] [Nontrivial \u03b1]", "[LinearOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : SuccOrder \u03b1\ninst\u271d\u2078 : NoMaxOrder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : SuccOrder \u03b1\ninst\u271d\u2075 : NoMaxOrder \u03b1\ninst\u271d\u2074 : OrderTop \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : Nontrivial \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\n\u22a2 a \u2264 sorry \u2194 a = sorry \u2228 a \u2264 b"}, {"line": "by_cases hb : IsMax b", "tactic_state": "case pos\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : SuccOrder \u03b1\ninst\u271d\u2078 : NoMaxOrder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : SuccOrder \u03b1\ninst\u271d\u2075 : NoMaxOrder \u03b1\ninst\u271d\u2074 : OrderTop \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : Nontrivial \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\nhb : sorry\n\u22a2 a \u2264 sorry \u2194 a = sorry \u2228 a \u2264 b\n---\ncase neg\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : SuccOrder \u03b1\ninst\u271d\u2078 : NoMaxOrder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : SuccOrder \u03b1\ninst\u271d\u2075 : NoMaxOrder \u03b1\ninst\u271d\u2074 : OrderTop \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : Nontrivial \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\nhb : \u00acsorry\n\u22a2 a \u2264 sorry \u2194 a = sorry \u2228 a \u2264 b"}, {"line": "\u00b7 rw [hb.succ_eq, or_iff_right_of_imp le_of_eq]", "tactic_state": "case neg\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : SuccOrder \u03b1\ninst\u271d\u2078 : NoMaxOrder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : SuccOrder \u03b1\ninst\u271d\u2075 : NoMaxOrder \u03b1\ninst\u271d\u2074 : OrderTop \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : Nontrivial \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\nsucc : x\u271d\nhb : \u00acsorry\n\u22a2 a \u2264 sorry \u2194 a = sorry \u2228 a \u2264 b"}, {"line": "\u00b7 rw [\u2190 lt_succ_iff_of_not_isMax hb, le_iff_eq_or_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pred_iterate_le (k : \u2115) (x : \u03b1) : pred^[k] x \u2264 x := by\n  conv_rhs => rw [(by simp only [Function.iterate_id, id] : x = id^[k] x)]\n  exact Monotone.iterate_le_of_le pred_mono pred_le k x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Basic.lean", "context": {"open": ["Function OrderDual Set", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LinearOrder \u03b1]", "(\u03b1)", "[Preorder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[PartialOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[OrderTop \u03b1]", "[OrderBot \u03b1] [Nontrivial \u03b1]", "[LinearOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[OrderBot \u03b1]", "[Preorder \u03b1] [PredOrder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : PartialOrder \u03b1\ninst\u271d\u00b9\u2070 : SuccOrder \u03b1\ninst\u271d\u2079 : NoMaxOrder \u03b1\ninst\u271d\u2078 : OrderTop \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : Nontrivial \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : SuccOrder \u03b1\ninst\u271d\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PredOrder \u03b1\npred : \u03b1 \u2192 \u03b1\nk : \u2115\nx : \u03b1\n\u22a2 pred^[k] x \u2264 x"}, {"line": "conv_rhs => rw [(by simp only [Function.iterate_id, id] : x = id^[k] x)]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : PartialOrder \u03b1\ninst\u271d\u00b9\u2070 : SuccOrder \u03b1\ninst\u271d\u2079 : NoMaxOrder \u03b1\ninst\u271d\u2078 : OrderTop \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : Nontrivial \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : SuccOrder \u03b1\ninst\u271d\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PredOrder \u03b1\npred : \u03b1 \u2192 \u03b1\nk : \u2115\nx : \u03b1\n\u22a2 pred^[k] x \u2264 id^[k] x"}, {"line": "exact Monotone.iterate_le_of_le pred_mono pred_le k x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Icc_subset_Ioc_pred_left_of_not_isMin (ha : \u00acIsMin a) : Icc a b \u2286 Ioc (pred a) b := by\n rw [\u2190 Ioi_inter_Iic]\n rw [\u2190 Ici_inter_Iic]\n gcongr\n apply Ici_subset_Ioi_pred_of_not_isMin ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Basic.lean", "context": {"open": ["Function OrderDual Set", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LinearOrder \u03b1]", "(\u03b1)", "[Preorder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[PartialOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[OrderTop \u03b1]", "[OrderBot \u03b1] [Nontrivial \u03b1]", "[LinearOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[OrderBot \u03b1]", "[Preorder \u03b1] [PredOrder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : PartialOrder \u03b1\ninst\u271d\u00b9\u2070 : SuccOrder \u03b1\ninst\u271d\u2079 : NoMaxOrder \u03b1\ninst\u271d\u2078 : OrderTop \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : Nontrivial \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : SuccOrder \u03b1\ninst\u271d\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\npred : x\u271d\nha : \u00acIsMin a\n\u22a2 Icc a b \u2286 Ioc sorry b"}, {"line": "rw [\u2190 Ioi_inter_Iic]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : PartialOrder \u03b1\ninst\u271d\u00b9\u2070 : SuccOrder \u03b1\ninst\u271d\u2079 : NoMaxOrder \u03b1\ninst\u271d\u2078 : OrderTop \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : Nontrivial \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : SuccOrder \u03b1\ninst\u271d\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\npred : x\u271d\nha : \u00acIsMin a\n\u22a2 Icc a b \u2286 Ioi sorry \u2229 Iic b"}, {"line": "rw [\u2190 Ici_inter_Iic]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : PartialOrder \u03b1\ninst\u271d\u00b9\u2070 : SuccOrder \u03b1\ninst\u271d\u2079 : NoMaxOrder \u03b1\ninst\u271d\u2078 : OrderTop \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : Nontrivial \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : SuccOrder \u03b1\ninst\u271d\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\npred : x\u271d\nha : \u00acIsMin a\n\u22a2 Ici a \u2229 Iic b \u2286 Ioi sorry \u2229 Iic b"}, {"line": "gcongr", "tactic_state": "case H\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : PartialOrder \u03b1\ninst\u271d\u00b9\u2070 : SuccOrder \u03b1\ninst\u271d\u2079 : NoMaxOrder \u03b1\ninst\u271d\u2078 : OrderTop \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : Nontrivial \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : SuccOrder \u03b1\ninst\u271d\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\npred : x\u271d\nha : \u00acIsMin a\n\u22a2 Ici a \u2286 Ioi sorry"}, {"line": "apply Ici_subset_Ioi_pred_of_not_isMin ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ico_subset_Ioo_pred_left_of_not_isMin (ha : \u00acIsMin a) : Ico a b \u2286 Ioo (pred a) b  := by\n  rw [\u2190 Ioi_inter_Iio]\n  rw [\u2190 Ici_inter_Iio]\n  gcongr\n  apply Ici_subset_Ioi_pred_of_not_isMin ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Basic.lean", "context": {"open": ["Function OrderDual Set", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LinearOrder \u03b1]", "(\u03b1)", "[Preorder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[PartialOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[OrderTop \u03b1]", "[OrderBot \u03b1] [Nontrivial \u03b1]", "[LinearOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[OrderBot \u03b1]", "[Preorder \u03b1] [PredOrder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : PartialOrder \u03b1\ninst\u271d\u00b9\u2070 : SuccOrder \u03b1\ninst\u271d\u2079 : NoMaxOrder \u03b1\ninst\u271d\u2078 : OrderTop \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : Nontrivial \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : SuccOrder \u03b1\ninst\u271d\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\npred : x\u271d\nha : \u00acIsMin a\n\u22a2 Ico a b \u2286 Ioo sorry b"}, {"line": "rw [\u2190 Ioi_inter_Iio]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : PartialOrder \u03b1\ninst\u271d\u00b9\u2070 : SuccOrder \u03b1\ninst\u271d\u2079 : NoMaxOrder \u03b1\ninst\u271d\u2078 : OrderTop \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : Nontrivial \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : SuccOrder \u03b1\ninst\u271d\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\npred : x\u271d\nha : \u00acIsMin a\n\u22a2 Ico a b \u2286 Ioi sorry \u2229 Iio b"}, {"line": "rw [\u2190 Ici_inter_Iio]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : PartialOrder \u03b1\ninst\u271d\u00b9\u2070 : SuccOrder \u03b1\ninst\u271d\u2079 : NoMaxOrder \u03b1\ninst\u271d\u2078 : OrderTop \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : Nontrivial \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : SuccOrder \u03b1\ninst\u271d\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\npred : x\u271d\nha : \u00acIsMin a\n\u22a2 Ici a \u2229 Iio b \u2286 Ioi sorry \u2229 Iio b"}, {"line": "gcongr", "tactic_state": "case H\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : PartialOrder \u03b1\ninst\u271d\u00b9\u2070 : SuccOrder \u03b1\ninst\u271d\u2079 : NoMaxOrder \u03b1\ninst\u271d\u2078 : OrderTop \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : Nontrivial \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : SuccOrder \u03b1\ninst\u271d\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\npred : x\u271d\nha : \u00acIsMin a\n\u22a2 Ici a \u2286 Ioi sorry"}, {"line": "apply Ici_subset_Ioi_pred_of_not_isMin ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ici_subset_Ioi_pred (a : \u03b1) : Ici a \u2286 Ioi (pred a) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Basic.lean", "context": {"open": ["Function OrderDual Set", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LinearOrder \u03b1]", "(\u03b1)", "[Preorder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[PartialOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[OrderTop \u03b1]", "[OrderBot \u03b1] [Nontrivial \u03b1]", "[LinearOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[OrderBot \u03b1]", "[Preorder \u03b1] [PredOrder \u03b1] {a b : \u03b1}", "[NoMinOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b9 : SuccOrder \u03b1\ninst\u271d\u00b9\u2070 : NoMaxOrder \u03b1\ninst\u271d\u2079 : OrderTop \u03b1\ninst\u271d\u2078 : OrderBot \u03b1\ninst\u271d\u2077 : Nontrivial \u03b1\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : SuccOrder \u03b1\ninst\u271d\u2074 : NoMaxOrder \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : NoMinOrder \u03b1\nx\u271d : Sort u_1\npred : x\u271d\na : \u03b1\n\u22a2 Ici a \u2286 Ioi sorry"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b9 : SuccOrder \u03b1\ninst\u271d\u00b9\u2070 : NoMaxOrder \u03b1\ninst\u271d\u2079 : OrderTop \u03b1\ninst\u271d\u2078 : OrderBot \u03b1\ninst\u271d\u2077 : Nontrivial \u03b1\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : SuccOrder \u03b1\ninst\u271d\u2074 : NoMaxOrder \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : NoMinOrder \u03b1\nx\u271d : Sort u_1\npred : x\u271d\na : \u03b1\n\u22a2 sorry () < a"}]}
{"declaration": "lemma le_iff_eq_or_le_pred : a \u2264 b \u2194 a = b \u2228 a \u2264 pred b := by\n  by_cases hb : IsMin b\n  \u00b7 simpa [hb.pred_eq] using le_of_eq\n  \u00b7 rw [le_pred_iff_of_not_isMin hb, le_iff_eq_or_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Basic.lean", "context": {"open": ["Function OrderDual Set", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LinearOrder \u03b1]", "(\u03b1)", "[Preorder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[PartialOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[OrderTop \u03b1]", "[OrderBot \u03b1] [Nontrivial \u03b1]", "[LinearOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[OrderBot \u03b1]", "[Preorder \u03b1] [PredOrder \u03b1] {a b : \u03b1}", "[NoMinOrder \u03b1]", "[PartialOrder \u03b1] [PredOrder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : SuccOrder \u03b1\ninst\u271d\u00b9\u2075 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : OrderTop \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : Nontrivial \u03b1\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : SuccOrder \u03b1\ninst\u271d\u2076 : NoMaxOrder \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : NoMinOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\npred : x\u271d\n\u22a2 a \u2264 b \u2194 a = b \u2228 a \u2264 sorry"}, {"line": "by_cases hb : IsMin b", "tactic_state": "case pos\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : SuccOrder \u03b1\ninst\u271d\u00b9\u2075 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : OrderTop \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : Nontrivial \u03b1\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : SuccOrder \u03b1\ninst\u271d\u2076 : NoMaxOrder \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : NoMinOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\npred : x\u271d\nhb : sorry\n\u22a2 a \u2264 b \u2194 a = b \u2228 a \u2264 sorry\n---\ncase neg\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : SuccOrder \u03b1\ninst\u271d\u00b9\u2075 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : OrderTop \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : Nontrivial \u03b1\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : SuccOrder \u03b1\ninst\u271d\u2076 : NoMaxOrder \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : NoMinOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\npred : x\u271d\nhb : \u00acsorry\n\u22a2 a \u2264 b \u2194 a = b \u2228 a \u2264 sorry"}, {"line": "\u00b7 simpa [hb.pred_eq] using le_of_eq", "tactic_state": "case neg\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : SuccOrder \u03b1\ninst\u271d\u00b9\u2075 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : OrderTop \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : Nontrivial \u03b1\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : SuccOrder \u03b1\ninst\u271d\u2076 : NoMaxOrder \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : NoMinOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\npred : x\u271d\nhb : \u00acsorry\n\u22a2 a \u2264 b \u2194 a = b \u2228 a \u2264 sorry"}, {"line": "\u00b7 rw [le_pred_iff_of_not_isMin hb, le_iff_eq_or_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pred_le_le_iff {a b : \u03b1} : pred a \u2264 b \u2227 b \u2264 a \u2194 b = a \u2228 b = pred a := by\n  refine\n    \u27e8fun h =>\n      or_iff_not_imp_left.2 fun hba : b \u2260 a => (le_pred_of_lt <| h.2.lt_of_ne hba).antisymm h.1, ?_\u27e9\n  rintro (rfl | rfl)\n  \u00b7 exact \u27e8pred_le b, le_rfl\u27e9\n  \u00b7 exact \u27e8le_rfl, pred_le a\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Basic.lean", "context": {"open": ["Function OrderDual Set", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LinearOrder \u03b1]", "(\u03b1)", "[Preorder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[PartialOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[OrderTop \u03b1]", "[OrderBot \u03b1] [Nontrivial \u03b1]", "[LinearOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[OrderBot \u03b1]", "[Preorder \u03b1] [PredOrder \u03b1] {a b : \u03b1}", "[NoMinOrder \u03b1]", "[PartialOrder \u03b1] [PredOrder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : SuccOrder \u03b1\ninst\u271d\u00b9\u2075 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : OrderTop \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : Nontrivial \u03b1\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : SuccOrder \u03b1\ninst\u271d\u2076 : NoMaxOrder \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : NoMinOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PredOrder \u03b1\nx\u271d : Sort u_1\npred : x\u271d\na b : \u03b1\n\u22a2 sorry \u2264 b \u2227 b \u2264 a \u2194 b = a \u2228 b = sorry"}, {"line": "refine\n    \u27e8fun h =>\n      or_iff_not_imp_left.2 fun hba : b \u2260 a => (le_pred_of_lt <| h.2.lt_of_ne hba).antisymm h.1, ?_\u27e9", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : SuccOrder \u03b1\ninst\u271d\u00b9\u2075 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : OrderTop \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : Nontrivial \u03b1\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : SuccOrder \u03b1\ninst\u271d\u2076 : NoMaxOrder \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : NoMinOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PredOrder \u03b1\nx\u271d : Sort u_1\npred : x\u271d\na b : \u03b1\n\u22a2 b = a \u2228 b = sorry \u2192 sorry \u2264 b \u2227 b \u2264 a"}, {"line": "rintro (rfl | rfl)", "tactic_state": "case inl\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : SuccOrder \u03b1\ninst\u271d\u00b9\u2075 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : OrderTop \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : Nontrivial \u03b1\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : SuccOrder \u03b1\ninst\u271d\u2076 : NoMaxOrder \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : NoMinOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PredOrder \u03b1\nx\u271d : Sort u_1\npred : x\u271d\nb : \u03b1\n\u22a2 sorry \u2264 b \u2227 b \u2264 b\n---\ncase inr\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : SuccOrder \u03b1\ninst\u271d\u00b9\u2075 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : OrderTop \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : Nontrivial \u03b1\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : SuccOrder \u03b1\ninst\u271d\u2076 : NoMaxOrder \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : NoMinOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PredOrder \u03b1\nx\u271d : Sort u_1\npred : x\u271d\na : \u03b1\n\u22a2 sorry \u2264 sorry \u2227 sorry \u2264 a"}, {"line": "\u00b7 exact \u27e8pred_le b, le_rfl\u27e9", "tactic_state": "case inr\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : SuccOrder \u03b1\ninst\u271d\u00b9\u2075 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : OrderTop \u03b1\ninst\u271d\u00b9\u2070 : OrderBot \u03b1\ninst\u271d\u2079 : Nontrivial \u03b1\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : SuccOrder \u03b1\ninst\u271d\u2076 : NoMaxOrder \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : NoMinOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PredOrder \u03b1\nx\u271d : Sort u_1\npred : x\u271d\na : \u03b1\n\u22a2 sorry \u2264 sorry \u2227 sorry \u2264 a"}, {"line": "\u00b7 exact \u27e8le_rfl, pred_le a\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pred_le_iff_eq_or_le : pred a \u2264 b \u2194 b = pred a \u2228 a \u2264 b := by\n  by_cases ha : IsMin a\n  \u00b7 rw [ha.pred_eq, or_iff_right_of_imp ge_of_eq]\n  \u00b7 rw [\u2190 pred_lt_iff_of_not_isMin ha, le_iff_eq_or_lt, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Basic.lean", "context": {"open": ["Function OrderDual Set", "Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LinearOrder \u03b1]", "(\u03b1)", "[Preorder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[PartialOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[OrderTop \u03b1]", "[OrderBot \u03b1] [Nontrivial \u03b1]", "[LinearOrder \u03b1] [SuccOrder \u03b1] {a b : \u03b1}", "[NoMaxOrder \u03b1]", "[OrderBot \u03b1]", "[Preorder \u03b1] [PredOrder \u03b1] {a b : \u03b1}", "[NoMinOrder \u03b1]", "[PartialOrder \u03b1] [PredOrder \u03b1] {a b : \u03b1}", "[NoMinOrder \u03b1]", "[OrderBot \u03b1]", "[OrderTop \u03b1] [Nontrivial \u03b1]", "[LinearOrder \u03b1] [PredOrder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : SuccOrder \u03b1\ninst\u271d\u00b2\u00b9 : NoMaxOrder \u03b1\ninst\u271d\u00b2\u2070 : PartialOrder \u03b1\ninst\u271d\u00b9\u2079 : SuccOrder \u03b1\ninst\u271d\u00b9\u2078 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2077 : OrderTop \u03b1\ninst\u271d\u00b9\u2076 : OrderBot \u03b1\ninst\u271d\u00b9\u2075 : Nontrivial \u03b1\ninst\u271d\u00b9\u2074 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : OrderBot \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : PredOrder \u03b1\ninst\u271d\u2078 : NoMinOrder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : PredOrder \u03b1\ninst\u271d\u2075 : NoMinOrder \u03b1\ninst\u271d\u2074 : OrderBot \u03b1\ninst\u271d\u00b3 : OrderTop \u03b1\ninst\u271d\u00b2 : Nontrivial \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\npred : x\u271d\n\u22a2 sorry \u2264 b \u2194 b = sorry \u2228 a \u2264 b"}, {"line": "by_cases ha : IsMin a", "tactic_state": "case pos\n\u03b1 : Type u_2\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : SuccOrder \u03b1\ninst\u271d\u00b2\u00b9 : NoMaxOrder \u03b1\ninst\u271d\u00b2\u2070 : PartialOrder \u03b1\ninst\u271d\u00b9\u2079 : SuccOrder \u03b1\ninst\u271d\u00b9\u2078 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2077 : OrderTop \u03b1\ninst\u271d\u00b9\u2076 : OrderBot \u03b1\ninst\u271d\u00b9\u2075 : Nontrivial \u03b1\ninst\u271d\u00b9\u2074 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : OrderBot \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : PredOrder \u03b1\ninst\u271d\u2078 : NoMinOrder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : PredOrder \u03b1\ninst\u271d\u2075 : NoMinOrder \u03b1\ninst\u271d\u2074 : OrderBot \u03b1\ninst\u271d\u00b3 : OrderTop \u03b1\ninst\u271d\u00b2 : Nontrivial \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\npred : x\u271d\nha : sorry\n\u22a2 sorry \u2264 b \u2194 b = sorry \u2228 a \u2264 b\n---\ncase neg\n\u03b1 : Type u_2\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : SuccOrder \u03b1\ninst\u271d\u00b2\u00b9 : NoMaxOrder \u03b1\ninst\u271d\u00b2\u2070 : PartialOrder \u03b1\ninst\u271d\u00b9\u2079 : SuccOrder \u03b1\ninst\u271d\u00b9\u2078 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2077 : OrderTop \u03b1\ninst\u271d\u00b9\u2076 : OrderBot \u03b1\ninst\u271d\u00b9\u2075 : Nontrivial \u03b1\ninst\u271d\u00b9\u2074 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : OrderBot \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : PredOrder \u03b1\ninst\u271d\u2078 : NoMinOrder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : PredOrder \u03b1\ninst\u271d\u2075 : NoMinOrder \u03b1\ninst\u271d\u2074 : OrderBot \u03b1\ninst\u271d\u00b3 : OrderTop \u03b1\ninst\u271d\u00b2 : Nontrivial \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\npred : x\u271d\nha : \u00acsorry\n\u22a2 sorry \u2264 b \u2194 b = sorry \u2228 a \u2264 b"}, {"line": "\u00b7 rw [ha.pred_eq, or_iff_right_of_imp ge_of_eq]", "tactic_state": "case neg\n\u03b1 : Type u_2\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : SuccOrder \u03b1\ninst\u271d\u00b2\u00b9 : NoMaxOrder \u03b1\ninst\u271d\u00b2\u2070 : PartialOrder \u03b1\ninst\u271d\u00b9\u2079 : SuccOrder \u03b1\ninst\u271d\u00b9\u2078 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2077 : OrderTop \u03b1\ninst\u271d\u00b9\u2076 : OrderBot \u03b1\ninst\u271d\u00b9\u2075 : Nontrivial \u03b1\ninst\u271d\u00b9\u2074 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b9 : OrderBot \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : PredOrder \u03b1\ninst\u271d\u2078 : NoMinOrder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : PredOrder \u03b1\ninst\u271d\u2075 : NoMinOrder \u03b1\ninst\u271d\u2074 : OrderBot \u03b1\ninst\u271d\u00b3 : OrderTop \u03b1\ninst\u271d\u00b2 : Nontrivial \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nx\u271d : Sort u_1\npred : x\u271d\nha : \u00acsorry\n\u22a2 sorry \u2264 b \u2194 b = sorry \u2228 a \u2264 b"}, {"line": "\u00b7 rw [\u2190 pred_lt_iff_of_not_isMin ha, le_iff_eq_or_lt, eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sSup_mem_of_not_isSuccPrelimit (hlim : \u00ac IsSuccPrelimit (sSup s)) : sSup s \u2208 s := by\n  obtain \u27e8y, hy\u27e9 := not_forall_not.mp hlim\n  obtain \u27e8i, his, hi\u27e9 := lt_sSup_iff.mp hy.lt\n  exact eq_of_le_of_not_lt (le_sSup his) (hy.2 hi) \u25b8 his\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/CompleteLinearOrder.lean", "context": {"open": ["Order Set", "Classical in"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*}", "[ConditionallyCompleteLinearOrder \u03b1] [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} {s : Set \u03b1} {x : \u03b1}", "[ConditionallyCompleteLinearOrderBot \u03b1] {f : \u03b9 \u2192 \u03b1} {s : Set \u03b1} {x : \u03b1}", "[CompleteLinearOrder \u03b1] {s : Set \u03b1} {f : \u03b9 \u2192 \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrderBot \u03b1\ninst\u271d : CompleteLinearOrder \u03b1\ns : Set \u03b1\nhlim : \u00acIsSuccPrelimit (sSup s)\n\u22a2 sSup s \u2208 s"}, {"line": "obtain \u27e8y, hy\u27e9 := not_forall_not.mp hlim", "tactic_state": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrderBot \u03b1\ninst\u271d : CompleteLinearOrder \u03b1\ns : Set \u03b1\nhlim : \u00acIsSuccPrelimit (sSup s)\ny : \u03b1\nhy : y \u22d6 sSup s\n\u22a2 sSup s \u2208 s"}, {"line": "obtain \u27e8i, his, hi\u27e9 := lt_sSup_iff.mp hy.lt", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrderBot \u03b1\ninst\u271d : CompleteLinearOrder \u03b1\ns : Set \u03b1\nhlim : \u00acIsSuccPrelimit (sSup s)\ny : \u03b1\nhy : y \u22d6 sSup s\ni : \u03b1\nhis : i \u2208 s\nhi : y < i\n\u22a2 sSup s \u2208 s"}, {"line": "exact eq_of_le_of_not_lt (le_sSup his) (hy.2 hi) \u25b8 his", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sInf_mem_of_not_isPredPrelimit (hlim : \u00ac IsPredPrelimit (sInf s)) : sInf s \u2208 s := by\n  obtain \u27e8y, hy\u27e9 := not_forall_not.mp hlim\n  obtain \u27e8i, his, hi\u27e9 := sInf_lt_iff.mp hy.lt\n  exact eq_of_le_of_not_lt (sInf_le his) (hy.2 \u00b7 hi) \u25b8 his\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/CompleteLinearOrder.lean", "context": {"open": ["Order Set", "Classical in"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*}", "[ConditionallyCompleteLinearOrder \u03b1] [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} {s : Set \u03b1} {x : \u03b1}", "[ConditionallyCompleteLinearOrderBot \u03b1] {f : \u03b9 \u2192 \u03b1} {s : Set \u03b1} {x : \u03b1}", "[CompleteLinearOrder \u03b1] {s : Set \u03b1} {f : \u03b9 \u2192 \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrderBot \u03b1\ninst\u271d : CompleteLinearOrder \u03b1\ns : Set \u03b1\nhlim : \u00acIsPredPrelimit (sInf s)\n\u22a2 sInf s \u2208 s"}, {"line": "obtain \u27e8y, hy\u27e9 := not_forall_not.mp hlim", "tactic_state": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrderBot \u03b1\ninst\u271d : CompleteLinearOrder \u03b1\ns : Set \u03b1\nhlim : \u00acIsPredPrelimit (sInf s)\ny : \u03b1\nhy : sInf s \u22d6 y\n\u22a2 sInf s \u2208 s"}, {"line": "obtain \u27e8i, his, hi\u27e9 := sInf_lt_iff.mp hy.lt", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrderBot \u03b1\ninst\u271d : CompleteLinearOrder \u03b1\ns : Set \u03b1\nhlim : \u00acIsPredPrelimit (sInf s)\ny : \u03b1\nhy : sInf s \u22d6 y\ni : ?m.594\nhis : i \u2208 ?m.608\nhi : i < ?m.609\n\u22a2 sInf s \u2208 s"}, {"line": "exact eq_of_le_of_not_lt (sInf_le his) (hy.2 \u00b7 hi) \u25b8 his", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pairwise_disjoint_on_Ioc_pred [PredOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) :\n    Pairwise (Disjoint on fun n => Ioc (f (pred n)) (f n)) := by\n  simpa using hf.dual.pairwise_disjoint_on_Ico_succ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/IntervalSucc.lean", "context": {"open": ["Set Order", "scoped Function -- required for scoped `on` notation"], "variables": ["{\u03b1 \u03b2 : Type*} [LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Monotone f\n\u22a2 Pairwise (Function.onFun Disjoint fun n => Ioc (f (pred n)) (f n))"}, {"line": "simpa using hf.dual.pairwise_disjoint_on_Ico_succ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pairwise_disjoint_on_Ico_pred [PredOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) :\n    Pairwise (Disjoint on fun n => Ico (f (pred n)) (f n)) := by\n  simpa using hf.dual.pairwise_disjoint_on_Ioc_succ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/IntervalSucc.lean", "context": {"open": ["Set Order", "scoped Function -- required for scoped `on` notation"], "variables": ["{\u03b1 \u03b2 : Type*} [LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Monotone f\n\u22a2 Pairwise (Function.onFun Disjoint fun n => Ico (f (pred n)) (f n))"}, {"line": "simpa using hf.dual.pairwise_disjoint_on_Ioc_succ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pairwise_disjoint_on_Ioo_pred [PredOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) :\n    Pairwise (Disjoint on fun n => Ioo (f (pred n)) (f n)) := by\n  simpa using hf.dual.pairwise_disjoint_on_Ioo_succ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/IntervalSucc.lean", "context": {"open": ["Set Order", "scoped Function -- required for scoped `on` notation"], "variables": ["{\u03b1 \u03b2 : Type*} [LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Monotone f\n\u22a2 Pairwise (Function.onFun Disjoint fun n => Ioo (f (pred n)) (f n))"}, {"line": "simpa using hf.dual.pairwise_disjoint_on_Ioo_succ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_isSuccPrelimit_iff_exists_covBy (a : \u03b1) : \u00acIsSuccPrelimit a \u2194 \u2203 b, b \u22d6 a := by\n  simp [IsSuccPrelimit]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Limit.lean", "context": {"open": ["Function Set OrderDual"], "variables": ["{\u03b1 : Type*} {a b : \u03b1}", "[LT \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LT \u03b1\nx\u271d : Sort u_2\nIsSuccPrelimit : x\u271d\na : \u03b1\n\u22a2 \u00acsorry \u2194 \u2203 b, b \u22d6 a"}, {"line": "simp [IsSuccPrelimit]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LT \u03b1\nx\u271d : Sort u_2\nIsSuccPrelimit : x\u271d\na : \u03b1\n\u22a2 \u00acsorry () \u2194 \u2203 b, b \u22d6 a"}]}
{"declaration": "theorem IsSuccLimit.ne_bot [OrderBot \u03b1] (h : IsSuccLimit a) : a \u2260 \u22a5 := by\n  rintro rfl\n  exact not_isSuccLimit_bot h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Limit.lean", "context": {"open": ["Function Set OrderDual"], "variables": ["{\u03b1 : Type*} {a b : \u03b1}", "[LT \u03b1]", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\nx\u271d : Sort u_2\nIsSuccLimit : x\u271d\ninst\u271d : OrderBot \u03b1\nh : sorry\n\u22a2 a \u2260 \u22a5"}, {"line": "rintro rfl", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\nx\u271d : Sort u_2\nIsSuccLimit : x\u271d\ninst\u271d : OrderBot \u03b1\nh : sorry\n\u22a2 False"}, {"line": "exact not_isSuccLimit_bot h", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsSuccPrelimit.isMax (h : IsSuccPrelimit (succ a)) : IsMax a := by\n  by_contra H\n  exact h a (covBy_succ_of_not_isMax H)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Limit.lean", "context": {"open": ["Function Set OrderDual"], "variables": ["{\u03b1 : Type*} {a b : \u03b1}", "[LT \u03b1]", "[Preorder \u03b1]", "[SuccOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\nx\u271d : Sort u_2\nIsSuccPrelimit : x\u271d\nh : sorry\n\u22a2 IsMax a"}, {"line": "by_contra H", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\nx\u271d : Sort u_2\nIsSuccPrelimit : x\u271d\nh : sorry\nH : \u00acIsMax a\n\u22a2 False"}, {"line": "exact h a (covBy_succ_of_not_isMax H)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_isSuccPrelimit_of_noMax [NoMinOrder \u03b1] : \u00ac IsSuccPrelimit a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Limit.lean", "context": {"open": ["Function Set OrderDual"], "variables": ["{\u03b1 : Type*} {a b : \u03b1}", "[LT \u03b1]", "[Preorder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1] [NoMaxOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : SuccOrder \u03b1\ninst\u271d\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b2 : IsSuccArchimedean \u03b1\ninst\u271d\u00b9 : NoMaxOrder \u03b1\nx\u271d : Sort u_2\nIsSuccPrelimit : x\u271d\ninst\u271d : NoMinOrder \u03b1\n\u22a2 \u00acsorry"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : SuccOrder \u03b1\ninst\u271d\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b2 : IsSuccArchimedean \u03b1\ninst\u271d\u00b9 : NoMaxOrder \u03b1\nx\u271d : Sort u_2\nIsSuccPrelimit : x\u271d\ninst\u271d : NoMinOrder \u03b1\n\u22a2 \u00acsorry ()"}]}
{"declaration": "theorem not_isSuccPrelimit [NoMinOrder \u03b1] : \u00ac IsSuccPrelimit a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Limit.lean", "context": {"open": ["Function Set OrderDual"], "variables": ["{\u03b1 : Type*} {a b : \u03b1}", "[LT \u03b1]", "[Preorder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1] [NoMaxOrder \u03b1]", "[PartialOrder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2070 : LT \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : SuccOrder \u03b1\ninst\u271d\u2077 : NoMaxOrder \u03b1\ninst\u271d\u2076 : IsSuccArchimedean \u03b1\ninst\u271d\u2075 : NoMaxOrder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : IsSuccArchimedean \u03b1\nx\u271d : Sort u_2\nIsSuccPrelimit : x\u271d\ninst\u271d : NoMinOrder \u03b1\n\u22a2 \u00acsorry"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2070 : LT \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : SuccOrder \u03b1\ninst\u271d\u2077 : NoMaxOrder \u03b1\ninst\u271d\u2076 : IsSuccArchimedean \u03b1\ninst\u271d\u2075 : NoMaxOrder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : IsSuccArchimedean \u03b1\nx\u271d : Sort u_2\nIsSuccPrelimit : x\u271d\ninst\u271d : NoMinOrder \u03b1\n\u22a2 \u00acsorry ()"}]}
{"declaration": "theorem IsSuccPrelimit.lt_iff_exists_lt (h : IsSuccPrelimit b) : a < b \u2194 \u2203 c < b, a < c := by\n  rw [\u2190 not_iff_not]\n  simp [h.le_iff_forall_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Limit.lean", "context": {"open": ["Function Set OrderDual"], "variables": ["{\u03b1 : Type*} {a b : \u03b1}", "[LT \u03b1]", "[Preorder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1] [NoMaxOrder \u03b1]", "[PartialOrder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1]", "[LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d\u00b9\u2070 : LT \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : SuccOrder \u03b1\ninst\u271d\u2077 : NoMaxOrder \u03b1\ninst\u271d\u2076 : IsSuccArchimedean \u03b1\ninst\u271d\u2075 : NoMaxOrder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : IsSuccArchimedean \u03b1\ninst\u271d : LinearOrder \u03b1\nx\u271d : Sort u_2\nIsSuccPrelimit : x\u271d\nh : sorry\n\u22a2 a < b \u2194 \u2203 c < b, a < c"}, {"line": "rw [\u2190 not_iff_not]", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d\u00b9\u2070 : LT \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : SuccOrder \u03b1\ninst\u271d\u2077 : NoMaxOrder \u03b1\ninst\u271d\u2076 : IsSuccArchimedean \u03b1\ninst\u271d\u2075 : NoMaxOrder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : IsSuccArchimedean \u03b1\ninst\u271d : LinearOrder \u03b1\nx\u271d : Sort u_2\nIsSuccPrelimit : x\u271d\nh : sorry\n\u22a2 \u00aca < b \u2194 \u00ac\u2203 c < b, a < c"}, {"line": "simp [h.le_iff_forall_le]", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d\u00b9\u2070 : LT \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : SuccOrder \u03b1\ninst\u271d\u2077 : NoMaxOrder \u03b1\ninst\u271d\u2076 : IsSuccArchimedean \u03b1\ninst\u271d\u2075 : NoMaxOrder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : SuccOrder \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : IsSuccArchimedean \u03b1\ninst\u271d : LinearOrder \u03b1\nx\u271d : Sort u_2\nIsSuccPrelimit : x\u271d\nh : sorry\n\u22a2 \u00aca < b \u2194 \u2200 x < b, \u00aca < x"}]}
{"declaration": "theorem not_isPredPrelimit_iff_exists_covBy (a : \u03b1) : \u00acIsPredPrelimit a \u2194 \u2203 b, a \u22d6 b := by\n  simp [IsPredPrelimit]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Limit.lean", "context": {"open": ["Function Set OrderDual"], "variables": ["{\u03b1 : Type*} {a b : \u03b1}", "[LT \u03b1]", "[Preorder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1] [NoMaxOrder \u03b1]", "[PartialOrder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1]", "[LinearOrder \u03b1]", "[SuccOrder \u03b1]", "[LT \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u00b2 : LT \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : SuccOrder \u03b1\ninst\u271d\u2079 : NoMaxOrder \u03b1\ninst\u271d\u2078 : IsSuccArchimedean \u03b1\ninst\u271d\u2077 : NoMaxOrder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : SuccOrder \u03b1\ninst\u271d\u2074 : NoMaxOrder \u03b1\ninst\u271d\u00b3 : IsSuccArchimedean \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : LT \u03b1\nx\u271d : Sort u_2\nIsPredPrelimit : x\u271d\na : \u03b1\n\u22a2 \u00acsorry \u2194 \u2203 b, a \u22d6 b"}, {"line": "simp [IsPredPrelimit]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u00b2 : LT \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : SuccOrder \u03b1\ninst\u271d\u2079 : NoMaxOrder \u03b1\ninst\u271d\u2078 : IsSuccArchimedean \u03b1\ninst\u271d\u2077 : NoMaxOrder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : SuccOrder \u03b1\ninst\u271d\u2074 : NoMaxOrder \u03b1\ninst\u271d\u00b3 : IsSuccArchimedean \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : LT \u03b1\nx\u271d : Sort u_2\nIsPredPrelimit : x\u271d\na : \u03b1\n\u22a2 \u00acsorry () \u2194 \u2203 b, a \u22d6 b"}]}
{"declaration": "theorem isSuccPrelimit_toDual_iff : IsSuccPrelimit (toDual a) \u2194 IsPredPrelimit a := by\n  simp [IsSuccPrelimit, IsPredPrelimit]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Limit.lean", "context": {"open": ["Function Set OrderDual"], "variables": ["{\u03b1 : Type*} {a b : \u03b1}", "[LT \u03b1]", "[Preorder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1] [NoMaxOrder \u03b1]", "[PartialOrder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1]", "[LinearOrder \u03b1]", "[SuccOrder \u03b1]", "[LT \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nIsSuccPrelimit : x\u271d\u00b9\nx\u271d : Sort u_3\nIsPredPrelimit : x\u271d\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [IsSuccPrelimit, IsPredPrelimit]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPredPrelimit_toDual_iff : IsPredPrelimit (toDual a) \u2194 IsSuccPrelimit a := by\n  simp [IsSuccPrelimit, IsPredPrelimit]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Limit.lean", "context": {"open": ["Function Set OrderDual"], "variables": ["{\u03b1 : Type*} {a b : \u03b1}", "[LT \u03b1]", "[Preorder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1] [NoMaxOrder \u03b1]", "[PartialOrder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1]", "[LinearOrder \u03b1]", "[SuccOrder \u03b1]", "[LT \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nIsPredPrelimit : x\u271d\u00b9\nx\u271d : Sort u_3\nIsSuccPrelimit : x\u271d\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [IsSuccPrelimit, IsPredPrelimit]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isSuccLimit_toDual_iff : IsSuccLimit (toDual a) \u2194 IsPredLimit a := by\n  simp [IsSuccLimit, IsPredLimit]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Limit.lean", "context": {"open": ["Function Set OrderDual"], "variables": ["{\u03b1 : Type*} {a b : \u03b1}", "[LT \u03b1]", "[Preorder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1] [NoMaxOrder \u03b1]", "[PartialOrder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1]", "[LinearOrder \u03b1]", "[SuccOrder \u03b1]", "[LT \u03b1]", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nIsSuccLimit : x\u271d\u00b9\nx\u271d : Sort u_3\nIsPredLimit : x\u271d\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [IsSuccLimit, IsPredLimit]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPredLimit_toDual_iff : IsPredLimit (toDual a) \u2194 IsSuccLimit a := by\n  simp [IsSuccLimit, IsPredLimit]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Limit.lean", "context": {"open": ["Function Set OrderDual"], "variables": ["{\u03b1 : Type*} {a b : \u03b1}", "[LT \u03b1]", "[Preorder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1] [NoMaxOrder \u03b1]", "[PartialOrder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1]", "[LinearOrder \u03b1]", "[SuccOrder \u03b1]", "[LT \u03b1]", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nIsPredLimit : x\u271d\u00b9\nx\u271d : Sort u_3\nIsSuccLimit : x\u271d\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [IsSuccLimit, IsPredLimit]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_isPredPrelimit_of_noMin [NoMaxOrder \u03b1] : \u00ac IsPredPrelimit a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Limit.lean", "context": {"open": ["Function Set OrderDual"], "variables": ["{\u03b1 : Type*} {a b : \u03b1}", "[LT \u03b1]", "[Preorder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1] [NoMaxOrder \u03b1]", "[PartialOrder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1]", "[LinearOrder \u03b1]", "[SuccOrder \u03b1]", "[LT \u03b1]", "[Preorder \u03b1]", "[PredOrder \u03b1]", "[NoMinOrder \u03b1]", "[IsPredArchimedean \u03b1] [NoMinOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : LT \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : SuccOrder \u03b1\ninst\u271d\u00b9\u2075 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2074 : IsSuccArchimedean \u03b1\ninst\u271d\u00b9\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b9 : SuccOrder \u03b1\ninst\u271d\u00b9\u2070 : NoMaxOrder \u03b1\ninst\u271d\u2079 : IsSuccArchimedean \u03b1\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : SuccOrder \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : PredOrder \u03b1\ninst\u271d\u00b3 : NoMinOrder \u03b1\ninst\u271d\u00b2 : IsPredArchimedean \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\nx\u271d : Sort u_2\nIsPredPrelimit : x\u271d\ninst\u271d : NoMaxOrder \u03b1\n\u22a2 \u00acsorry"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : LT \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : SuccOrder \u03b1\ninst\u271d\u00b9\u2075 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2074 : IsSuccArchimedean \u03b1\ninst\u271d\u00b9\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b9 : SuccOrder \u03b1\ninst\u271d\u00b9\u2070 : NoMaxOrder \u03b1\ninst\u271d\u2079 : IsSuccArchimedean \u03b1\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : SuccOrder \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : PredOrder \u03b1\ninst\u271d\u00b3 : NoMinOrder \u03b1\ninst\u271d\u00b2 : IsPredArchimedean \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\nx\u271d : Sort u_2\nIsPredPrelimit : x\u271d\ninst\u271d : NoMaxOrder \u03b1\n\u22a2 \u00acsorry ()"}]}
{"declaration": "theorem not_isPredPrelimit [NoMaxOrder \u03b1] : \u00ac IsPredPrelimit a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Limit.lean", "context": {"open": ["Function Set OrderDual"], "variables": ["{\u03b1 : Type*} {a b : \u03b1}", "[LT \u03b1]", "[Preorder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1] [NoMaxOrder \u03b1]", "[PartialOrder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1]", "[LinearOrder \u03b1]", "[SuccOrder \u03b1]", "[LT \u03b1]", "[Preorder \u03b1]", "[PredOrder \u03b1]", "[NoMinOrder \u03b1]", "[IsPredArchimedean \u03b1] [NoMinOrder \u03b1]", "[PartialOrder \u03b1]", "[PredOrder \u03b1]", "[NoMinOrder \u03b1]", "[IsPredArchimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u00b2 : LT \u03b1\ninst\u271d\u00b2\u00b9 : Preorder \u03b1\ninst\u271d\u00b2\u2070 : SuccOrder \u03b1\ninst\u271d\u00b9\u2079 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2078 : IsSuccArchimedean \u03b1\ninst\u271d\u00b9\u2077 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2076 : PartialOrder \u03b1\ninst\u271d\u00b9\u2075 : SuccOrder \u03b1\ninst\u271d\u00b9\u2074 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b3 : IsSuccArchimedean \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : SuccOrder \u03b1\ninst\u271d\u00b9\u2070 : LT \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : PredOrder \u03b1\ninst\u271d\u2077 : NoMinOrder \u03b1\ninst\u271d\u2076 : IsPredArchimedean \u03b1\ninst\u271d\u2075 : NoMinOrder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : NoMinOrder \u03b1\ninst\u271d\u00b9 : IsPredArchimedean \u03b1\nx\u271d : Sort u_2\nIsPredPrelimit : x\u271d\ninst\u271d : NoMaxOrder \u03b1\n\u22a2 \u00acsorry"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u00b2 : LT \u03b1\ninst\u271d\u00b2\u00b9 : Preorder \u03b1\ninst\u271d\u00b2\u2070 : SuccOrder \u03b1\ninst\u271d\u00b9\u2079 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2078 : IsSuccArchimedean \u03b1\ninst\u271d\u00b9\u2077 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2076 : PartialOrder \u03b1\ninst\u271d\u00b9\u2075 : SuccOrder \u03b1\ninst\u271d\u00b9\u2074 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b3 : IsSuccArchimedean \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : SuccOrder \u03b1\ninst\u271d\u00b9\u2070 : LT \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : PredOrder \u03b1\ninst\u271d\u2077 : NoMinOrder \u03b1\ninst\u271d\u2076 : IsPredArchimedean \u03b1\ninst\u271d\u2075 : NoMinOrder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : NoMinOrder \u03b1\ninst\u271d\u00b9 : IsPredArchimedean \u03b1\nx\u271d : Sort u_2\nIsPredPrelimit : x\u271d\ninst\u271d : NoMaxOrder \u03b1\n\u22a2 \u00acsorry ()"}]}
{"declaration": "lemma _root_.IsGLB.isPredPrelimit_of_not_mem {s : Set \u03b1} (hs : IsGLB s a) (ha : a \u2209 s) :\n    IsPredPrelimit a := by\n  simpa using (IsGLB.dual hs).isSuccPrelimit_of_not_mem ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Limit.lean", "context": {"open": ["Function Set OrderDual"], "variables": ["{\u03b1 : Type*} {a b : \u03b1}", "[LT \u03b1]", "[Preorder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1] [NoMaxOrder \u03b1]", "[PartialOrder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1]", "[LinearOrder \u03b1]", "[SuccOrder \u03b1]", "[LT \u03b1]", "[Preorder \u03b1]", "[PredOrder \u03b1]", "[NoMinOrder \u03b1]", "[IsPredArchimedean \u03b1] [NoMinOrder \u03b1]", "[PartialOrder \u03b1]", "[PredOrder \u03b1]", "[NoMinOrder \u03b1]", "[IsPredArchimedean \u03b1]", "[LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\ninst\u271d\u00b2\u00b2 : LT \u03b1\ninst\u271d\u00b2\u00b9 : Preorder \u03b1\ninst\u271d\u00b2\u2070 : SuccOrder \u03b1\ninst\u271d\u00b9\u2079 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2078 : IsSuccArchimedean \u03b1\ninst\u271d\u00b9\u2077 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2076 : PartialOrder \u03b1\ninst\u271d\u00b9\u2075 : SuccOrder \u03b1\ninst\u271d\u00b9\u2074 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b3 : IsSuccArchimedean \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : SuccOrder \u03b1\ninst\u271d\u00b9\u2070 : LT \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : PredOrder \u03b1\ninst\u271d\u2077 : NoMinOrder \u03b1\ninst\u271d\u2076 : IsPredArchimedean \u03b1\ninst\u271d\u2075 : NoMinOrder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : NoMinOrder \u03b1\ninst\u271d\u00b9 : IsPredArchimedean \u03b1\ninst\u271d : LinearOrder \u03b1\nx\u271d : Sort u_2\nIsPredPrelimit : x\u271d\ns : Set \u03b1\nhs : IsGLB s a\nha : a \u2209 s\n\u22a2 sorry"}, {"line": "simpa using (IsGLB.dual hs).isSuccPrelimit_of_not_mem ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.IsGLB.isPredLimit_of_not_mem {s : Set \u03b1} (hs : IsGLB s a) (hs' : s.Nonempty)\n    (ha : a \u2209 s) : IsPredLimit a := by\n  simpa using (IsGLB.dual hs).isSuccLimit_of_not_mem hs' ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Limit.lean", "context": {"open": ["Function Set OrderDual"], "variables": ["{\u03b1 : Type*} {a b : \u03b1}", "[LT \u03b1]", "[Preorder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1] [NoMaxOrder \u03b1]", "[PartialOrder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1]", "[LinearOrder \u03b1]", "[SuccOrder \u03b1]", "[LT \u03b1]", "[Preorder \u03b1]", "[PredOrder \u03b1]", "[NoMinOrder \u03b1]", "[IsPredArchimedean \u03b1] [NoMinOrder \u03b1]", "[PartialOrder \u03b1]", "[PredOrder \u03b1]", "[NoMinOrder \u03b1]", "[IsPredArchimedean \u03b1]", "[LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\ninst\u271d\u00b2\u00b2 : LT \u03b1\ninst\u271d\u00b2\u00b9 : Preorder \u03b1\ninst\u271d\u00b2\u2070 : SuccOrder \u03b1\ninst\u271d\u00b9\u2079 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2078 : IsSuccArchimedean \u03b1\ninst\u271d\u00b9\u2077 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2076 : PartialOrder \u03b1\ninst\u271d\u00b9\u2075 : SuccOrder \u03b1\ninst\u271d\u00b9\u2074 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b3 : IsSuccArchimedean \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : SuccOrder \u03b1\ninst\u271d\u00b9\u2070 : LT \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : PredOrder \u03b1\ninst\u271d\u2077 : NoMinOrder \u03b1\ninst\u271d\u2076 : IsPredArchimedean \u03b1\ninst\u271d\u2075 : NoMinOrder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : NoMinOrder \u03b1\ninst\u271d\u00b9 : IsPredArchimedean \u03b1\ninst\u271d : LinearOrder \u03b1\nx\u271d : Sort u_2\nIsPredLimit : x\u271d\ns : Set \u03b1\nhs : IsGLB s a\nhs' : s.Nonempty\nha : a \u2209 s\n\u22a2 sorry"}, {"line": "simpa using (IsGLB.dual hs).isSuccLimit_of_not_mem hs' ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isGLB_Ioi_iff_isPredPrelimit : IsGLB (Ioi a) a \u2194 IsPredPrelimit a := by\n  simpa using isLUB_Iio_iff_isSuccPrelimit (a := toDual a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SuccPred/Limit.lean", "context": {"open": ["Function Set OrderDual"], "variables": ["{\u03b1 : Type*} {a b : \u03b1}", "[LT \u03b1]", "[Preorder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1] [NoMaxOrder \u03b1]", "[PartialOrder \u03b1]", "[SuccOrder \u03b1]", "[NoMaxOrder \u03b1]", "[IsSuccArchimedean \u03b1]", "[LinearOrder \u03b1]", "[SuccOrder \u03b1]", "[LT \u03b1]", "[Preorder \u03b1]", "[PredOrder \u03b1]", "[NoMinOrder \u03b1]", "[IsPredArchimedean \u03b1] [NoMinOrder \u03b1]", "[PartialOrder \u03b1]", "[PredOrder \u03b1]", "[NoMinOrder \u03b1]", "[IsPredArchimedean \u03b1]", "[LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\ninst\u271d\u00b2\u00b2 : LT \u03b1\ninst\u271d\u00b2\u00b9 : Preorder \u03b1\ninst\u271d\u00b2\u2070 : SuccOrder \u03b1\ninst\u271d\u00b9\u2079 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2078 : IsSuccArchimedean \u03b1\ninst\u271d\u00b9\u2077 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u2076 : PartialOrder \u03b1\ninst\u271d\u00b9\u2075 : SuccOrder \u03b1\ninst\u271d\u00b9\u2074 : NoMaxOrder \u03b1\ninst\u271d\u00b9\u00b3 : IsSuccArchimedean \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : SuccOrder \u03b1\ninst\u271d\u00b9\u2070 : LT \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : PredOrder \u03b1\ninst\u271d\u2077 : NoMinOrder \u03b1\ninst\u271d\u2076 : IsPredArchimedean \u03b1\ninst\u271d\u2075 : NoMinOrder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : NoMinOrder \u03b1\ninst\u271d\u00b9 : IsPredArchimedean \u03b1\ninst\u271d : LinearOrder \u03b1\nx\u271d : Sort u_2\nIsPredPrelimit : x\u271d\n\u22a2 IsGLB (Ioi a) a \u2194 sorry"}, {"line": "simpa using isLUB_Iio_iff_isSuccPrelimit (a := toDual a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_lowerClosure (s : Set \u03b1) : \u2191(lowerClosure s) = \u22c3 a \u2208 s, Iic a := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Closure.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1] [Preorder \u03b2] {s t : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\ns : Set \u03b1\n\u22a2 \u2191(lowerClosure s) = \u22c3 a \u2208 s, Iic a"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\ns : Set \u03b1\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u2191(lowerClosure s) \u2194 x\u271d \u2208 \u22c3 a \u2208 s, Iic a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem upperClosure_sUnion (S : Set (Set \u03b1)) : upperClosure (\u22c3\u2080 S) = \u2a05 s \u2208 S, upperClosure s := by\n  simp_rw [sUnion_eq_biUnion, upperClosure_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Closure.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1] [Preorder \u03b2] {s t : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nS : Set (Set \u03b1)\n\u22a2 upperClosure (\u22c3\u2080 S) = \u2a05 s \u2208 S, upperClosure s"}, {"line": "simp_rw [sUnion_eq_biUnion, upperClosure_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lowerClosure_sUnion (S : Set (Set \u03b1)) : lowerClosure (\u22c3\u2080 S) = \u2a06 s \u2208 S, lowerClosure s := by\n  simp_rw [sUnion_eq_biUnion, lowerClosure_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Closure.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1] [Preorder \u03b2] {s t : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nS : Set (Set \u03b1)\n\u22a2 lowerClosure (\u22c3\u2080 S) = \u2a06 s \u2208 S, lowerClosure s"}, {"line": "simp_rw [sUnion_eq_biUnion, lowerClosure_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ordConnected_iff_upperClosure_inter_lowerClosure :\n    s.OrdConnected \u2194 \u2191(upperClosure s) \u2229 \u2191(lowerClosure s) = s := by\n  refine \u27e8Set.OrdConnected.upperClosure_inter_lowerClosure, fun h => ?_\u27e9\n  rw [\u2190 h]\n  exact (UpperSet.upper _).ordConnected.inter (LowerSet.lower _).ordConnected\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Closure.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1] [Preorder \u03b2] {s t : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\ns : Set \u03b1\n\u22a2 s.OrdConnected \u2194 \u2191(upperClosure s) \u2229 \u2191(lowerClosure s) = s"}, {"line": "refine \u27e8Set.OrdConnected.upperClosure_inter_lowerClosure, fun h => ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\ns : Set \u03b1\nh : \u2191(upperClosure s) \u2229 \u2191(lowerClosure s) = s\n\u22a2 s.OrdConnected"}, {"line": "rw [\u2190 h]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\ns : Set \u03b1\nh : \u2191(upperClosure s) \u2229 \u2191(lowerClosure s) = s\n\u22a2 (\u2191(upperClosure s) \u2229 \u2191(lowerClosure s)).OrdConnected"}, {"line": "exact (UpperSet.upper _).ordConnected.inter (LowerSet.lower _).ordConnected", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bddAbove_lowerClosure : BddAbove (lowerClosure s : Set \u03b1) \u2194 BddAbove s := by\n  simp_rw [BddAbove, upperBounds_lowerClosure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Closure.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1] [Preorder \u03b2] {s t : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\ns : Set \u03b1\n\u22a2 BddAbove \u2191(lowerClosure s) \u2194 BddAbove s"}, {"line": "simp_rw [BddAbove, upperBounds_lowerClosure]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bddBelow_upperClosure : BddBelow (upperClosure s : Set \u03b1) \u2194 BddBelow s := by\n  simp_rw [BddBelow, lowerBounds_upperClosure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Closure.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1] [Preorder \u03b2] {s t : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\ns : Set \u03b1\n\u22a2 BddBelow \u2191(upperClosure s) \u2194 BddBelow s"}, {"line": "simp_rw [BddBelow, lowerBounds_upperClosure]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sdiff_sup_lowerClosure (hts : t \u2286 s) (hst : \u2200 b \u2208 s, \u2200 c \u2208 t, c \u2264 b \u2192 b \u2208 t) :\n    s.sdiff t \u2294 lowerClosure t = s := by\n  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha \u21a6 ?_\n  obtain hat | hat := em (a \u2208 t)\n  \u00b7 exact subset_union_right (subset_lowerClosure hat)\n  \u00b7 refine subset_union_left \u27e8ha, ?_\u27e9\n    rintro \u27e8b, hb, hba\u27e9\n    exact hat <| hst _ ha _ hb hba\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Closure.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1] [Preorder \u03b2] {s t : Set \u03b1} {x : \u03b1}", "[PartialOrder \u03b1] {s : Set \u03b1} {x : \u03b1}", "[Preorder \u03b1] {s : LowerSet \u03b1} {t : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b1\ns : LowerSet \u03b1\nt : Set \u03b1\nhts : t \u2286 \u2191s\nhst : \u2200 b \u2208 s, \u2200 c \u2208 t, c \u2264 b \u2192 b \u2208 t\n\u22a2 s.sdiff t \u2294 lowerClosure t = s"}, {"line": "refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha \u21a6 ?_", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b1\ns : LowerSet \u03b1\nt : Set \u03b1\nhts : t \u2286 \u2191s\nhst : \u2200 b \u2208 s, \u2200 c \u2208 t, c \u2264 b \u2192 b \u2208 t\na : \u03b1\nha : a \u2208 \u2191s\n\u22a2 a \u2208 \u2191(s.sdiff t \u2294 lowerClosure t)"}, {"line": "obtain hat | hat := em (a \u2208 t)", "tactic_state": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b1\ns : LowerSet \u03b1\nt : Set \u03b1\nhts : t \u2286 \u2191s\nhst : \u2200 b \u2208 s, \u2200 c \u2208 t, c \u2264 b \u2192 b \u2208 t\na : \u03b1\nha : a \u2208 \u2191s\nhat : a \u2208 t\n\u22a2 a \u2208 \u2191(s.sdiff t \u2294 lowerClosure t)\n---\ncase inr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b1\ns : LowerSet \u03b1\nt : Set \u03b1\nhts : t \u2286 \u2191s\nhst : \u2200 b \u2208 s, \u2200 c \u2208 t, c \u2264 b \u2192 b \u2208 t\na : \u03b1\nha : a \u2208 \u2191s\nhat : a \u2209 t\n\u22a2 a \u2208 \u2191(s.sdiff t \u2294 lowerClosure t)"}, {"line": "\u00b7 exact subset_union_right (subset_lowerClosure hat)", "tactic_state": "case inr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b1\ns : LowerSet \u03b1\nt : Set \u03b1\nhts : t \u2286 \u2191s\nhst : \u2200 b \u2208 s, \u2200 c \u2208 t, c \u2264 b \u2192 b \u2208 t\na : \u03b1\nha : a \u2208 \u2191s\nhat : a \u2209 t\n\u22a2 a \u2208 \u2191(s.sdiff t \u2294 lowerClosure t)"}, {"line": "\u00b7 refine subset_union_left \u27e8ha, ?_\u27e9\n    rintro \u27e8b, hb, hba\u27e9\n    exact hat <| hst _ ha _ hb hba", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sdiff_inf_upperClosure (hts : t \u2286 s) (hst : \u2200 b \u2208 s, \u2200 c \u2208 t, b \u2264 c \u2192 b \u2208 t) :\n    s.sdiff t \u2293 upperClosure t = s := by\n  refine ge_antisymm (le_inf le_sdiff_left <| le_upperClosure.2 hts) fun a ha \u21a6 ?_\n  obtain hat | hat := em (a \u2208 t)\n  \u00b7 exact subset_union_right (subset_upperClosure hat)\n  \u00b7 refine subset_union_left \u27e8ha, ?_\u27e9\n    rintro \u27e8b, hb, hab\u27e9\n    exact hat <| hst _ ha _ hb hab\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Closure.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1] [Preorder \u03b2] {s t : Set \u03b1} {x : \u03b1}", "[PartialOrder \u03b1] {s : Set \u03b1} {x : \u03b1}", "[Preorder \u03b1] {s : LowerSet \u03b1} {t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] {s : UpperSet \u03b1} {t : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\ns : UpperSet \u03b1\nt : Set \u03b1\nhts : t \u2286 \u2191s\nhst : \u2200 b \u2208 s, \u2200 c \u2208 t, b \u2264 c \u2192 b \u2208 t\n\u22a2 s.sdiff t \u2293 upperClosure t = s"}, {"line": "refine ge_antisymm (le_inf le_sdiff_left <| le_upperClosure.2 hts) fun a ha \u21a6 ?_", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\ns : UpperSet \u03b1\nt : Set \u03b1\nhts : t \u2286 \u2191s\nhst : \u2200 b \u2208 s, \u2200 c \u2208 t, b \u2264 c \u2192 b \u2208 t\na : \u03b1\nha : a \u2208 (\u21d1toDual \u2218 SetLike.coe) s\n\u22a2 a \u2208 (\u21d1toDual \u2218 SetLike.coe) (s.sdiff t \u2293 upperClosure t)"}, {"line": "obtain hat | hat := em (a \u2208 t)", "tactic_state": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\ns : UpperSet \u03b1\nt : Set \u03b1\nhts : t \u2286 \u2191s\nhst : \u2200 b \u2208 s, \u2200 c \u2208 t, b \u2264 c \u2192 b \u2208 t\na : \u03b1\nha : a \u2208 (\u21d1toDual \u2218 SetLike.coe) s\nhat : a \u2208 t\n\u22a2 a \u2208 (\u21d1toDual \u2218 SetLike.coe) (s.sdiff t \u2293 upperClosure t)\n---\ncase inr\n\u03b1 : Type u_1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\ns : UpperSet \u03b1\nt : Set \u03b1\nhts : t \u2286 \u2191s\nhst : \u2200 b \u2208 s, \u2200 c \u2208 t, b \u2264 c \u2192 b \u2208 t\na : \u03b1\nha : a \u2208 (\u21d1toDual \u2218 SetLike.coe) s\nhat : a \u2209 t\n\u22a2 a \u2208 (\u21d1toDual \u2218 SetLike.coe) (s.sdiff t \u2293 upperClosure t)"}, {"line": "\u00b7 exact subset_union_right (subset_upperClosure hat)", "tactic_state": "case inr\n\u03b1 : Type u_1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\ns : UpperSet \u03b1\nt : Set \u03b1\nhts : t \u2286 \u2191s\nhst : \u2200 b \u2208 s, \u2200 c \u2208 t, b \u2264 c \u2192 b \u2208 t\na : \u03b1\nha : a \u2208 (\u21d1toDual \u2218 SetLike.coe) s\nhat : a \u2209 t\n\u22a2 a \u2208 (\u21d1toDual \u2218 SetLike.coe) (s.sdiff t \u2293 upperClosure t)"}, {"line": "\u00b7 refine subset_union_left \u27e8ha, ?_\u27e9\n    rintro \u27e8b, hb, hab\u27e9\n    exact hat <| hst _ ha _ hb hab", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Finite.upperClosure [LocallyFiniteOrderTop \u03b1] (hs : s.Finite) :\n    (upperClosure s : Set \u03b1).Finite := by\n  rw [coe_upperClosure]\n  exact hs.biUnion fun _ _ => finite_Ici _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/LocallyFinite.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [Preorder \u03b1] {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ns : Set \u03b1\ninst\u271d : LocallyFiniteOrderTop \u03b1\nhs : s.Finite\n\u22a2 (\u2191(upperClosure s)).Finite"}, {"line": "rw [coe_upperClosure]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ns : Set \u03b1\ninst\u271d : LocallyFiniteOrderTop \u03b1\nhs : s.Finite\n\u22a2 (\u22c3 a \u2208 s, Set.Ici a).Finite"}, {"line": "exact hs.biUnion fun _ _ => finite_Ici _", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Finite.lowerClosure [LocallyFiniteOrderBot \u03b1] (hs : s.Finite) :\n    (lowerClosure s : Set \u03b1).Finite := by\n  rw [coe_lowerClosure]\n  exact hs.biUnion fun _ _ => finite_Iic _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/LocallyFinite.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [Preorder \u03b1] {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ns : Set \u03b1\ninst\u271d : LocallyFiniteOrderBot \u03b1\nhs : s.Finite\n\u22a2 (\u2191(lowerClosure s)).Finite"}, {"line": "rw [coe_lowerClosure]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ns : Set \u03b1\ninst\u271d : LocallyFiniteOrderBot \u03b1\nhs : s.Finite\n\u22a2 (\u22c3 a \u2208 s, Set.Iic a).Finite"}, {"line": "exact hs.biUnion fun _ _ => finite_Iic _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_Ici (f : \u03b1 \u2243o \u03b2) (a : \u03b1) : map f (Ici a) = Ici (f a) := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Principal.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[Preorder \u03b1] [Preorder \u03b2] {s : UpperSet \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d : Sort u_5\nmap : x\u271d\nf : \u03b1 \u2243o \u03b2\na : \u03b1\n\u22a2 sorry = Ici (f a)"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d\u00b9 : Sort u_5\nmap : x\u271d\u00b9\nf : \u03b1 \u2243o \u03b2\na : \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 sorry \u2194 x\u271d \u2208 Ici (f a)"}, {"line": "simp", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d\u00b9 : Sort u_5\nmap : x\u271d\u00b9\nf : \u03b1 \u2243o \u03b2\na : \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 sorry () \u2194 f a \u2264 x\u271d"}]}
{"declaration": "theorem map_Ioi (f : \u03b1 \u2243o \u03b2) (a : \u03b1) : map f (Ioi a) = Ioi (f a) := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Principal.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[Preorder \u03b1] [Preorder \u03b2] {s : UpperSet \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d : Sort u_5\nmap : x\u271d\nf : \u03b1 \u2243o \u03b2\na : \u03b1\n\u22a2 sorry = Ioi (f a)"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d\u00b9 : Sort u_5\nmap : x\u271d\u00b9\nf : \u03b1 \u2243o \u03b2\na : \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 sorry \u2194 x\u271d \u2208 Ioi (f a)"}, {"line": "simp", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d\u00b9 : Sort u_5\nmap : x\u271d\u00b9\nf : \u03b1 \u2243o \u03b2\na : \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 sorry () \u2194 f a < x\u271d"}]}
{"declaration": "theorem Ici_iSup\u2082 (f : \u2200 i, \u03ba i \u2192 \u03b1) : Ici (\u2a06 (i) (j), f i j) = \u2a06 (i) (j), Ici (f i j) := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Principal.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[Preorder \u03b1] [Preorder \u03b2] {s : UpperSet \u03b1} {a b : \u03b1}", "[PartialOrder \u03b1] {a b : \u03b1}", "[CompleteLattice \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_3\n\u03ba : \u03b9 \u2192 Sort u_4\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 \u03b1\n\u22a2 Ici (\u2a06 i, \u2a06 j, f i j) = \u2a06 i, \u2a06 j, Ici (f i j)"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_3\n\u03ba : \u03b9 \u2192 Sort u_4\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 \u03b1\n\u22a2 Ici (\u2a06 i, \u2a06 j, f i j) = \u22c3 i, \u22c3 j, Ici (f i j)"}]}
{"declaration": "theorem map_Iic (f : \u03b1 \u2243o \u03b2) (a : \u03b1) : map f (Iic a) = Iic (f a) := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Principal.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[Preorder \u03b1] [Preorder \u03b2] {s : UpperSet \u03b1} {a b : \u03b1}", "[PartialOrder \u03b1] {a b : \u03b1}", "[CompleteLattice \u03b1]", "[Preorder \u03b1] [Preorder \u03b2] {s : LowerSet \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d : Sort u_5\nmap : x\u271d\nf : \u03b1 \u2243o \u03b2\na : \u03b1\n\u22a2 sorry = Iic (f a)"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d\u00b9 : Sort u_5\nmap : x\u271d\u00b9\nf : \u03b1 \u2243o \u03b2\na : \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 sorry \u2194 x\u271d \u2208 Iic (f a)"}, {"line": "simp", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d\u00b9 : Sort u_5\nmap : x\u271d\u00b9\nf : \u03b1 \u2243o \u03b2\na : \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 sorry () \u2194 x\u271d \u2264 f a"}]}
{"declaration": "theorem map_Iio (f : \u03b1 \u2243o \u03b2) (a : \u03b1) : map f (Iio a) = Iio (f a) := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Principal.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[Preorder \u03b1] [Preorder \u03b2] {s : UpperSet \u03b1} {a b : \u03b1}", "[PartialOrder \u03b1] {a b : \u03b1}", "[CompleteLattice \u03b1]", "[Preorder \u03b1] [Preorder \u03b2] {s : LowerSet \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d : Sort u_5\nmap : x\u271d\nf : \u03b1 \u2243o \u03b2\na : \u03b1\n\u22a2 sorry = Iio (f a)"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d\u00b9 : Sort u_5\nmap : x\u271d\u00b9\nf : \u03b1 \u2243o \u03b2\na : \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 sorry \u2194 x\u271d \u2208 Iio (f a)"}, {"line": "simp", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d\u00b9 : Sort u_5\nmap : x\u271d\u00b9\nf : \u03b1 \u2243o \u03b2\na : \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 sorry () \u2194 x\u271d < f a"}]}
{"declaration": "theorem prod_eq_top : s \u00d7\u02e2 t = \u22a4 \u2194 s = \u22a4 \u2228 t = \u22a4 := by\n  simp_rw [SetLike.ext'_iff]\n  exact prod_eq_empty_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Prod.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2]", "{s : Set \u03b1} {t : Set \u03b2}", "(s s\u2081 s\u2082 : UpperSet \u03b1) (t t\u2081 t\u2082 : UpperSet \u03b2) {x : \u03b1 \u00d7 \u03b2}", "{s s\u2081 s\u2082 t t\u2081 t\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : UpperSet \u03b1\nt : UpperSet \u03b2\n\u22a2 s \u00d7\u02e2 t = \u22a4 \u2194 s = \u22a4 \u2228 t = \u22a4"}, {"line": "simp_rw [SetLike.ext'_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : UpperSet \u03b1\nt : UpperSet \u03b2\n\u22a2 \u2191(s \u00d7\u02e2 t) = \u2191\u22a4 \u2194 \u2191s = \u2191\u22a4 \u2228 \u2191t = \u2191\u22a4"}, {"line": "exact prod_eq_empty_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_eq_bot : s \u00d7\u02e2 t = \u22a5 \u2194 s = \u22a5 \u2228 t = \u22a5 := by\n  simp_rw [SetLike.ext'_iff]\n  exact prod_eq_empty_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Prod.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2]", "{s : Set \u03b1} {t : Set \u03b2}", "(s s\u2081 s\u2082 : UpperSet \u03b1) (t t\u2081 t\u2082 : UpperSet \u03b2) {x : \u03b1 \u00d7 \u03b2}", "{s s\u2081 s\u2082 t t\u2081 t\u2082}", "(s s\u2081 s\u2082 : LowerSet \u03b1) (t t\u2081 t\u2082 : LowerSet \u03b2) {x : \u03b1 \u00d7 \u03b2}", "{s s\u2081 s\u2082 t t\u2081 t\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : LowerSet \u03b1\nt : LowerSet \u03b2\n\u22a2 s \u00d7\u02e2 t = \u22a5 \u2194 s = \u22a5 \u2228 t = \u22a5"}, {"line": "simp_rw [SetLike.ext'_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : LowerSet \u03b1\nt : LowerSet \u03b2\n\u22a2 \u2191(s \u00d7\u02e2 t) = \u2191\u22a5 \u2194 \u2191s = \u2191\u22a5 \u2228 \u2191t = \u2191\u22a5"}, {"line": "exact prod_eq_empty_iff", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsUpperSet.isLowerSet_preimage_coe (hs : IsUpperSet s) :\n    IsLowerSet ((\u2191) \u207b\u00b9' t : Set s) \u2194 \u2200 b \u2208 s, \u2200 c \u2208 t, b \u2264 c \u2192 b \u2208 t := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Basic.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1] {s t : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LE \u03b1\ns t : Set \u03b1\nhs : IsUpperSet s\n\u22a2 IsLowerSet (Subtype.val \u207b\u00b9' t) \u2194 \u2200 b \u2208 s, \u2200 c \u2208 t, b \u2264 c \u2192 b \u2208 t"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsLowerSet.isUpperSet_preimage_coe (hs : IsLowerSet s) :\n    IsUpperSet ((\u2191) \u207b\u00b9' t : Set s) \u2194 \u2200 b \u2208 s, \u2200 c \u2208 t, c \u2264 b \u2192 b \u2208 t := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Basic.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1] {s t : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LE \u03b1\ns t : Set \u03b1\nhs : IsLowerSet s\n\u22a2 IsUpperSet (Subtype.val \u207b\u00b9' t) \u2194 \u2200 b \u2208 s, \u2200 c \u2208 t, c \u2264 b \u2192 b \u2208 t"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isUpperSet_iff_Ici_subset : IsUpperSet s \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 Ici a \u2286 s := by\n  simp [IsUpperSet, subset_def, @forall_swap (_ \u2208 s)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Basic.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1] {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {s : Set \u03b1} {p : \u03b1 \u2192 Prop} (a : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\ns : Set \u03b1\n\u22a2 IsUpperSet s \u2194 \u2200 \u2983a : \u03b1\u2984, a \u2208 s \u2192 Ici a \u2286 s"}, {"line": "simp [IsUpperSet, subset_def, @forall_swap (_ \u2208 s)]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\ns : Set \u03b1\n\u22a2 (\u2200 \u2983a b : \u03b1\u2984, a \u2264 b \u2192 a \u2208 s \u2192 b \u2208 s) \u2194 \u2200 \u2983a : \u03b1\u2984 (y : \u03b1), a \u2264 y \u2192 a \u2208 s \u2192 y \u2208 s"}]}
{"declaration": "theorem isLowerSet_iff_Iic_subset : IsLowerSet s \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 Iic a \u2286 s := by\n  simp [IsLowerSet, subset_def, @forall_swap (_ \u2208 s)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Basic.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1] {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {s : Set \u03b1} {p : \u03b1 \u2192 Prop} (a : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\ns : Set \u03b1\n\u22a2 IsLowerSet s \u2194 \u2200 \u2983a : \u03b1\u2984, a \u2208 s \u2192 Iic a \u2286 s"}, {"line": "simp [IsLowerSet, subset_def, @forall_swap (_ \u2208 s)]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\ns : Set \u03b1\n\u22a2 (\u2200 \u2983a b : \u03b1\u2984, b \u2264 a \u2192 a \u2208 s \u2192 b \u2208 s) \u2194 \u2200 \u2983a : \u03b1\u2984, \u2200 y \u2264 a, a \u2208 s \u2192 y \u2208 s"}]}
{"declaration": "theorem isUpperSet_iff_Ioi_subset : IsUpperSet s \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 Ioi a \u2286 s := by\n  simp [isUpperSet_iff_forall_lt, subset_def, @forall_swap (_ \u2208 s)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Basic.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1] {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {s : Set \u03b1} {p : \u03b1 \u2192 Prop} (a : \u03b1)", "[OrderTop \u03b1]", "[OrderBot \u03b1]", "[NoMaxOrder \u03b1]", "[NoMinOrder \u03b1]", "[PartialOrder \u03b1] {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : LE \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : OrderTop \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : PartialOrder \u03b1\ns : Set \u03b1\n\u22a2 IsUpperSet s \u2194 \u2200 \u2983a : \u03b1\u2984, a \u2208 s \u2192 Ioi a \u2286 s"}, {"line": "simp [isUpperSet_iff_forall_lt, subset_def, @forall_swap (_ \u2208 s)]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : LE \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : OrderTop \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : PartialOrder \u03b1\ns : Set \u03b1\n\u22a2 IsUpperSet s \u2194 \u2200 \u2983a : \u03b1\u2984 (y : \u03b1), a < y \u2192 a \u2208 s \u2192 y \u2208 s"}]}
{"declaration": "theorem isLowerSet_iff_Iio_subset : IsLowerSet s \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 Iio a \u2286 s := by\n  simp [isLowerSet_iff_forall_lt, subset_def, @forall_swap (_ \u2208 s)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/Basic.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1] {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {s : Set \u03b1} {p : \u03b1 \u2192 Prop} (a : \u03b1)", "[OrderTop \u03b1]", "[OrderBot \u03b1]", "[NoMaxOrder \u03b1]", "[NoMinOrder \u03b1]", "[PartialOrder \u03b1] {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : LE \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : OrderTop \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : PartialOrder \u03b1\ns : Set \u03b1\n\u22a2 IsLowerSet s \u2194 \u2200 \u2983a : \u03b1\u2984, a \u2208 s \u2192 Iio a \u2286 s"}, {"line": "simp [isLowerSet_iff_forall_lt, subset_def, @forall_swap (_ \u2208 s)]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : LE \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : OrderTop \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : PartialOrder \u03b1\ns : Set \u03b1\n\u22a2 IsLowerSet s \u2194 \u2200 \u2983a : \u03b1\u2984, \u2200 y < a, a \u2208 s \u2192 y \u2208 s"}]}
{"declaration": "theorem coe_iSup (f : \u03b9 \u2192 UpperSet \u03b1) : (\u2191(\u2a06 i, f i) : Set \u03b1) = \u22c2 i, f i := by simp [iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/CompleteLattice.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1]", "{S : Set (UpperSet \u03b1)} {s t : UpperSet \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d : LE \u03b1\nf : \u03b9 \u2192 UpperSet \u03b1\n\u22a2 \u2191(\u2a06 i, f i) = \u22c2 i, \u2191(f i)"}, {"line": "simp [iSup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_iInf (f : \u03b9 \u2192 UpperSet \u03b1) : (\u2191(\u2a05 i, f i) : Set \u03b1) = \u22c3 i, f i := by simp [iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/CompleteLattice.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1]", "{S : Set (UpperSet \u03b1)} {s t : UpperSet \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d : LE \u03b1\nf : \u03b9 \u2192 UpperSet \u03b1\n\u22a2 \u2191(\u2a05 i, f i) = \u22c3 i, \u2191(f i)"}, {"line": "simp [iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_iSup\u2082 (f : \u2200 i, \u03ba i \u2192 UpperSet \u03b1) :\n    (\u2191(\u2a06 (i) (j), f i j) : Set \u03b1) = \u22c2 (i) (j), f i j := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/CompleteLattice.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1]", "{S : Set (UpperSet \u03b1)} {s t : UpperSet \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 UpperSet \u03b1\n\u22a2 \u2191(\u2a06 i, \u2a06 j, f i j) = \u22c2 i, \u22c2 j, \u2191(f i j)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_iInf\u2082 (f : \u2200 i, \u03ba i \u2192 UpperSet \u03b1) :\n    (\u2191(\u2a05 (i) (j), f i j) : Set \u03b1) = \u22c3 (i) (j), f i j := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/CompleteLattice.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1]", "{S : Set (UpperSet \u03b1)} {s t : UpperSet \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 UpperSet \u03b1\n\u22a2 \u2191(\u2a05 i, \u2a05 j, f i j) = \u22c3 i, \u22c3 j, \u2191(f i j)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_iSup\u2082_iff {f : \u2200 i, \u03ba i \u2192 UpperSet \u03b1} : (a \u2208 \u2a06 (i) (j), f i j) \u2194 \u2200 i j, a \u2208 f i j := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/CompleteLattice.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1]", "{S : Set (UpperSet \u03b1)} {s t : UpperSet \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\na : \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 UpperSet \u03b1\n\u22a2 a \u2208 \u2a06 i, \u2a06 j, f i j \u2194 \u2200 (i : \u03b9) (j : \u03ba i), a \u2208 f i j"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_iInf\u2082_iff {f : \u2200 i, \u03ba i \u2192 UpperSet \u03b1} : (a \u2208 \u2a05 (i) (j), f i j) \u2194 \u2203 i j, a \u2208 f i j := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/CompleteLattice.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1]", "{S : Set (UpperSet \u03b1)} {s t : UpperSet \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\na : \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 UpperSet \u03b1\n\u22a2 a \u2208 \u2a05 i, \u2a05 j, f i j \u2194 \u2203 i j, a \u2208 f i j"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem codisjoint_coe : Codisjoint (s : Set \u03b1) t \u2194 Disjoint s t := by\n  simp [disjoint_iff, codisjoint_iff, SetLike.ext'_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/CompleteLattice.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1]", "{S : Set (UpperSet \u03b1)} {s t : UpperSet \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LE \u03b1\ns t : UpperSet \u03b1\n\u22a2 Codisjoint \u2191s \u2191t \u2194 Disjoint s t"}, {"line": "simp [disjoint_iff, codisjoint_iff, SetLike.ext'_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_iSup\u2082 (f : \u2200 i, \u03ba i \u2192 LowerSet \u03b1) :\n    (\u2191(\u2a06 (i) (j), f i j) : Set \u03b1) = \u22c3 (i) (j), f i j := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/CompleteLattice.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1]", "{S : Set (UpperSet \u03b1)} {s t : UpperSet \u03b1} {a : \u03b1}", "{S : Set (LowerSet \u03b1)} {s t : LowerSet \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 LowerSet \u03b1\n\u22a2 \u2191(\u2a06 i, \u2a06 j, f i j) = \u22c3 i, \u22c3 j, \u2191(f i j)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_iInf\u2082 (f : \u2200 i, \u03ba i \u2192 LowerSet \u03b1) :\n    (\u2191(\u2a05 (i) (j), f i j) : Set \u03b1) = \u22c2 (i) (j), f i j := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/CompleteLattice.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1]", "{S : Set (UpperSet \u03b1)} {s t : UpperSet \u03b1} {a : \u03b1}", "{S : Set (LowerSet \u03b1)} {s t : LowerSet \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 LowerSet \u03b1\n\u22a2 \u2191(\u2a05 i, \u2a05 j, f i j) = \u22c2 i, \u22c2 j, \u2191(f i j)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_iSup\u2082_iff {f : \u2200 i, \u03ba i \u2192 LowerSet \u03b1} : (a \u2208 \u2a06 (i) (j), f i j) \u2194 \u2203 i j, a \u2208 f i j := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/CompleteLattice.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1]", "{S : Set (UpperSet \u03b1)} {s t : UpperSet \u03b1} {a : \u03b1}", "{S : Set (LowerSet \u03b1)} {s t : LowerSet \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\na : \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 LowerSet \u03b1\n\u22a2 a \u2208 \u2a06 i, \u2a06 j, f i j \u2194 \u2203 i j, a \u2208 f i j"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_iInf\u2082_iff {f : \u2200 i, \u03ba i \u2192 LowerSet \u03b1} : (a \u2208 \u2a05 (i) (j), f i j) \u2194 \u2200 i j, a \u2208 f i j := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/CompleteLattice.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1]", "{S : Set (UpperSet \u03b1)} {s t : UpperSet \u03b1} {a : \u03b1}", "{S : Set (LowerSet \u03b1)} {s t : LowerSet \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\na : \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 LowerSet \u03b1\n\u22a2 a \u2208 \u2a05 i, \u2a05 j, f i j \u2194 \u2200 (i : \u03b9) (j : \u03ba i), a \u2208 f i j"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_coe : Disjoint (s : Set \u03b1) t \u2194 Disjoint s t := by\n  simp [disjoint_iff, SetLike.ext'_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/CompleteLattice.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1]", "{S : Set (UpperSet \u03b1)} {s t : UpperSet \u03b1} {a : \u03b1}", "{S : Set (LowerSet \u03b1)} {s t : LowerSet \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LE \u03b1\ns t : LowerSet \u03b1\n\u22a2 Disjoint \u2191s \u2191t \u2194 Disjoint s t"}, {"line": "simp [disjoint_iff, SetLike.ext'_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_iSup\u2082 (f : \u2200 i, \u03ba i \u2192 UpperSet \u03b1) :\n    (\u2a06 (i) (j), f i j).compl = \u2a06 (i) (j), (f i j).compl := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/CompleteLattice.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1]", "{S : Set (UpperSet \u03b1)} {s t : UpperSet \u03b1} {a : \u03b1}", "{S : Set (LowerSet \u03b1)} {s t : LowerSet \u03b1} {a : \u03b1}", "{s t : UpperSet \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 UpperSet \u03b1\n\u22a2 (\u2a06 i, \u2a06 j, f i j).compl = \u2a06 i, \u2a06 j, (f i j).compl"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_iInf\u2082 (f : \u2200 i, \u03ba i \u2192 UpperSet \u03b1) :\n    (\u2a05 (i) (j), f i j).compl = \u2a05 (i) (j), (f i j).compl := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/CompleteLattice.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1]", "{S : Set (UpperSet \u03b1)} {s t : UpperSet \u03b1} {a : \u03b1}", "{S : Set (LowerSet \u03b1)} {s t : LowerSet \u03b1} {a : \u03b1}", "{s t : UpperSet \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 UpperSet \u03b1\n\u22a2 (\u2a05 i, \u2a05 j, f i j).compl = \u2a05 i, \u2a05 j, (f i j).compl"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_iInf\u2082 (f : \u2200 i, \u03ba i \u2192 LowerSet \u03b1) :\n    (\u2a05 (i) (j), f i j).compl = \u2a05 (i) (j), (f i j).compl := by simp_rw [LowerSet.compl_iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/UpperLower/CompleteLattice.lean", "context": {"open": ["OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1]", "{S : Set (UpperSet \u03b1)} {s t : UpperSet \u03b1} {a : \u03b1}", "{S : Set (LowerSet \u03b1)} {s t : LowerSet \u03b1} {a : \u03b1}", "{s t : UpperSet \u03b1} {a : \u03b1}", "{s t : LowerSet \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 LowerSet \u03b1\n\u22a2 (\u2a05 i, \u2a05 j, f i j).compl = \u2a05 i, \u2a05 j, (f i j).compl"}, {"line": "simp_rw [LowerSet.compl_iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iIndepFun.indep_comap_natural_of_lt (hf : \u2200 i, StronglyMeasurable (f i))\n    (hfi : iIndepFun f \u03bc) (hij : i < j) :\n    Indep (MeasurableSpace.comap (f j) m\u03b2) (Filtration.natural f hf i) \u03bc := by\n  suffices Indep (\u2a06 k \u2208 ({j} : Set \u03b9), MeasurableSpace.comap (f k) m\u03b2)\n      (\u2a06 k \u2208 {k | k \u2264 i}, MeasurableSpace.comap (f k) m\u03b2) \u03bc by rwa [iSup_singleton] at this\n  exact indep_iSup_of_disjoint (fun k => (hf k).measurable.comap_le) hfi (by simpa)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/BorelCantelli.lean", "context": {"open": ["scoped ENNReal Topology", "MeasureTheory"], "variables": ["{\u03a9 : Type*} {m0 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}", "{\u03b9 \u03b2 : Type*} [LinearOrder \u03b9] [m\u03b2 : MeasurableSpace \u03b2] [NormedAddCommGroup \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_4\nf : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\niIndepFun : x\u271d\u00b9\n\u03b1\u271d : Type u_6\ni j : \u03b1\u271d\nx\u271d : Sort u_7\nIndep : x\u271d\nhf : \u2200 (i_1 : ?m.7505), StronglyMeasurable ?m.3693\nhfi : sorry\nhij : i < j\n\u22a2 sorry"}, {"line": "suffices Indep (\u2a06 k \u2208 ({j} : Set \u03b9), MeasurableSpace.comap (f k) m\u03b2)\n      (\u2a06 k \u2208 {k | k \u2264 i}, MeasurableSpace.comap (f k) m\u03b2) \u03bc by rwa [iSup_singleton] at this", "tactic_state": "x\u271d\u00b2 : Sort u_4\nf : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\niIndepFun : x\u271d\u00b9\n\u03b1\u271d : Type u_6\ni j : \u03b1\u271d\nx\u271d : Sort u_7\nIndep : x\u271d\nhf : \u2200 (i_1 : ?m.7505), StronglyMeasurable ?m.3693\nhfi : sorry\nhij : i < j\n\u22a2 sorry"}, {"line": "exact indep_iSup_of_disjoint (fun k => (hf k).measurable.comap_le) hfi (by simpa)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformOn_empty_meas : (uniformOn \u2205 : Measure \u03a9) = 0 := by simp [uniformOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/UniformOn.lean", "context": {"open": ["ProbabilityTheory", "MeasureTheory MeasurableSpace"], "variables": ["{\u03a9 : Type*} [MeasurableSpace \u03a9] {s : Set \u03a9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\n\u22a2 uniformOn \u2205 = 0"}, {"line": "simp [uniformOn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformOn_empty {s : Set \u03a9} : uniformOn s \u2205 = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/UniformOn.lean", "context": {"open": ["ProbabilityTheory", "MeasureTheory MeasurableSpace"], "variables": ["{\u03a9 : Type*} [MeasurableSpace \u03a9] {s : Set \u03a9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\ns : Set \u03a9\n\u22a2 (uniformOn s) \u2205 = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finite_of_uniformOn_ne_zero {s t : Set \u03a9} (h : uniformOn s t \u2260 0) : s.Finite := by\n  by_contra hs'\n  simp [uniformOn, cond, Measure.count_apply_infinite hs'] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/UniformOn.lean", "context": {"open": ["ProbabilityTheory", "MeasureTheory MeasurableSpace"], "variables": ["{\u03a9 : Type*} [MeasurableSpace \u03a9] {s : Set \u03a9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\ns t : Set \u03a9\nh : (uniformOn s) t \u2260 0\n\u22a2 s.Finite"}, {"line": "by_contra hs'", "tactic_state": "\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\ns t : Set \u03a9\nh : (uniformOn s) t \u2260 0\nhs' : \u00acs.Finite\n\u22a2 False"}, {"line": "simp [uniformOn, cond, Measure.count_apply_infinite hs'] at h", "tactic_state": "\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\ns t : Set \u03a9\nh : \u00acMeasure.count[t | s] = 0\nhs' : \u00acs.Finite\n\u22a2 False"}]}
{"declaration": "theorem uniformOn_univ [Fintype \u03a9] {s : Set \u03a9} :\n    uniformOn Set.univ s = Measure.count s / Fintype.card \u03a9 := by\n  simp [uniformOn, cond_apply, \u2190 ENNReal.div_eq_inv_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/UniformOn.lean", "context": {"open": ["ProbabilityTheory", "MeasureTheory MeasurableSpace"], "variables": ["{\u03a9 : Type*} [MeasurableSpace \u03a9] {s : Set \u03a9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03a9\ninst\u271d : Fintype \u03a9\ns : Set \u03a9\n\u22a2 (uniformOn Set.univ) s = Measure.count s / \u2191(Fintype.card \u03a9)"}, {"line": "simp [uniformOn, cond_apply, \u2190 ENNReal.div_eq_inv_mul]", "tactic_state": "\u03a9 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03a9\ninst\u271d : Fintype \u03a9\ns : Set \u03a9\n\u22a2 Measure.count s / \u2191(ENat.card \u03a9) = Measure.count s / \u2191(Fintype.card \u03a9)"}]}
{"declaration": "theorem uniformOn_isProbabilityMeasure {s : Set \u03a9} (hs : s.Finite) (hs' : s.Nonempty) :\n    IsProbabilityMeasure (uniformOn s) := by\n  apply cond_isProbabilityMeasure_of_finite\n  \u00b7 rwa [Measure.count_ne_zero_iff]\n  \u00b7 exact (Measure.count_apply_lt_top.2 hs).ne\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/UniformOn.lean", "context": {"open": ["ProbabilityTheory", "MeasureTheory MeasurableSpace"], "variables": ["{\u03a9 : Type*} [MeasurableSpace \u03a9] {s : Set \u03a9}", "[MeasurableSingletonClass \u03a9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03a9\ninst\u271d : MeasurableSingletonClass \u03a9\ns : Set \u03a9\nhs : s.Finite\nhs' : s.Nonempty\n\u22a2 IsProbabilityMeasure (uniformOn s)"}, {"line": "apply cond_isProbabilityMeasure_of_finite", "tactic_state": "case hcs\n\u03a9 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03a9\ninst\u271d : MeasurableSingletonClass \u03a9\ns : Set \u03a9\nhs : s.Finite\nhs' : s.Nonempty\n\u22a2 Measure.count s \u2260 0\n---\ncase hs\n\u03a9 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03a9\ninst\u271d : MeasurableSingletonClass \u03a9\ns : Set \u03a9\nhs : s.Finite\nhs' : s.Nonempty\n\u22a2 Measure.count s \u2260 \u22a4"}, {"line": "\u00b7 rwa [Measure.count_ne_zero_iff]", "tactic_state": "case hs\n\u03a9 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03a9\ninst\u271d : MeasurableSingletonClass \u03a9\ns : Set \u03a9\nhs : s.Finite\nhs' : s.Nonempty\n\u22a2 Measure.count s \u2260 \u22a4"}, {"line": "\u00b7 exact (Measure.count_apply_lt_top.2 hs).ne", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformOn_singleton (\u03c9 : \u03a9) (t : Set \u03a9) [Decidable (\u03c9 \u2208 t)] :\n    uniformOn {\u03c9} t = if \u03c9 \u2208 t then 1 else 0 := by\n  rw [uniformOn]\n  rw [cond_apply (measurableSet_singleton \u03c9)]\n  rw [Measure.count_singleton]\n  rw [inv_one]\n  rw [one_mul]\n  split_ifs\n  \u00b7 rw [(by simpa : ({\u03c9} : Set \u03a9) \u2229 t = {\u03c9}), Measure.count_singleton]\n  \u00b7 simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/UniformOn.lean", "context": {"open": ["ProbabilityTheory", "MeasureTheory MeasurableSpace"], "variables": ["{\u03a9 : Type*} [MeasurableSpace \u03a9] {s : Set \u03a9}", "[MeasurableSingletonClass \u03a9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 (uniformOn {\u03c9}) t = if \u03c9 \u2208 t then 1 else 0"}, {"line": "rw [uniformOn]", "tactic_state": "\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 Measure.count[t | {\u03c9}] = if \u03c9 \u2208 t then 1 else 0"}, {"line": "rw [cond_apply (measurableSet_singleton \u03c9)]", "tactic_state": "\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 (Measure.count {\u03c9})\u207b\u00b9 * Measure.count ({\u03c9} \u2229 t) = if \u03c9 \u2208 t then 1 else 0\n---\n\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 MeasurableSingletonClass \u03a9"}, {"line": "rw [Measure.count_singleton]", "tactic_state": "\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 1\u207b\u00b9 * Measure.count ({\u03c9} \u2229 t) = if \u03c9 \u2208 t then 1 else 0\n---\n\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 MeasurableSingletonClass \u03a9\n---\n\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 MeasurableSingletonClass \u03a9"}, {"line": "rw [inv_one]", "tactic_state": "\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 1 * Measure.count ({\u03c9} \u2229 t) = if \u03c9 \u2208 t then 1 else 0\n---\n\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 MeasurableSingletonClass \u03a9\n---\n\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 MeasurableSingletonClass \u03a9"}, {"line": "rw [one_mul]", "tactic_state": "\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 Measure.count ({\u03c9} \u2229 t) = if \u03c9 \u2208 t then 1 else 0\n---\n\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 MeasurableSingletonClass \u03a9\n---\n\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 MeasurableSingletonClass \u03a9"}, {"line": "split_ifs", "tactic_state": "case pos\n\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\nh\u271d : \u03c9 \u2208 t\n\u22a2 Measure.count ({\u03c9} \u2229 t) = 1\n---\ncase neg\n\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\nh\u271d : \u03c9 \u2209 t\n\u22a2 Measure.count ({\u03c9} \u2229 t) = 0\n---\n\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 MeasurableSingletonClass \u03a9\n---\n\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 MeasurableSingletonClass \u03a9"}, {"line": "\u00b7 rw [(by simpa : ({\u03c9} : Set \u03a9) \u2229 t = {\u03c9}), Measure.count_singleton]", "tactic_state": "case neg\n\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\nh\u271d : \u03c9 \u2209 t\n\u22a2 Measure.count ({\u03c9} \u2229 t) = 0\n---\n\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 MeasurableSingletonClass \u03a9\n---\n\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 MeasurableSingletonClass \u03a9"}, {"line": "\u00b7 simpa", "tactic_state": "\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 MeasurableSingletonClass \u03a9\n---\n\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : MeasurableSingletonClass \u03a9\n\u03c9 : \u03a9\nt : Set \u03a9\ninst\u271d : Decidable (\u03c9 \u2208 t)\n\u22a2 MeasurableSingletonClass \u03a9"}]}
{"declaration": "theorem uniformOn_eq_zero_iff (hs : s.Finite) : uniformOn s t = 0 \u2194 s \u2229 t = \u2205 := by\n  simp [uniformOn, cond_apply hs.measurableSet, Measure.count_apply_eq_top, Set.not_infinite.2 hs,\n    Measure.count_apply_finite _ (hs.inter_of_left _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/UniformOn.lean", "context": {"open": ["ProbabilityTheory", "MeasureTheory MeasurableSpace"], "variables": ["{\u03a9 : Type*} [MeasurableSpace \u03a9] {s : Set \u03a9}", "[MeasurableSingletonClass \u03a9]", "{s t u : Set \u03a9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03a9\ninst\u271d : MeasurableSingletonClass \u03a9\ns t : Set \u03a9\nhs : s.Finite\n\u22a2 (uniformOn s) t = 0 \u2194 s \u2229 t = \u2205"}, {"line": "simp [uniformOn, cond_apply hs.measurableSet, Measure.count_apply_eq_top, Set.not_infinite.2 hs,\n    Measure.count_apply_finite _ (hs.inter_of_left _)]", "tactic_state": "\u03a9 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03a9\ninst\u271d : MeasurableSingletonClass \u03a9\ns t : Set \u03a9\nhs : s.Finite\n\u22a2 Measure.count[t | s] = 0 \u2194 s \u2229 t = \u2205"}]}
{"declaration": "theorem uniformOn_inter' (hs : s.Finite) :\n    uniformOn s (t \u2229 u) = uniformOn (s \u2229 u) t * uniformOn s u := by\n  rw [\u2190 Set.inter_comm]\n  exact uniformOn_inter hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/UniformOn.lean", "context": {"open": ["ProbabilityTheory", "MeasureTheory MeasurableSpace"], "variables": ["{\u03a9 : Type*} [MeasurableSpace \u03a9] {s : Set \u03a9}", "[MeasurableSingletonClass \u03a9]", "{s t u : Set \u03a9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03a9\ninst\u271d : MeasurableSingletonClass \u03a9\ns t u : Set \u03a9\nhs : s.Finite\n\u22a2 (uniformOn s) (t \u2229 u) = (uniformOn (s \u2229 u)) t * (uniformOn s) u"}, {"line": "rw [\u2190 Set.inter_comm]", "tactic_state": "\u03a9 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03a9\ninst\u271d : MeasurableSingletonClass \u03a9\ns t u : Set \u03a9\nhs : s.Finite\n\u22a2 (uniformOn s) (u \u2229 t) = (uniformOn (s \u2229 u)) t * (uniformOn s) u"}, {"line": "exact uniformOn_inter hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrable_snd [NormedAddCommGroup \u03b3] [BorelSpace \u03b3] (h : IdentDistrib f g \u03bc \u03bd)\n    (hf : Integrable f \u03bc) : Integrable g \u03bd := by\n  rw [\u2190 memLp_one_iff_integrable] at hf \u22a2\n  exact h.memLp_snd hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/IdentDistrib.lean", "context": {"open": ["MeasureTheory Filter Finset", "scoped Topology MeasureTheory ENNReal NNReal", "TopologicalSpace"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] [MeasurableSpace \u03b3]", "{\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : MeasurableSpace \u03b3\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b3\nx\u271d : Sort u_5\nIdentDistrib : x\u271d\ninst\u271d\u00b9 : NormedAddCommGroup \u03b3\ninst\u271d : BorelSpace \u03b3\nh : sorry\nhf : Integrable f \u03bc\n\u22a2 Integrable g \u03bd"}, {"line": "rw [\u2190 memLp_one_iff_integrable] at hf \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : MeasurableSpace \u03b3\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b3\nx\u271d : Sort u_5\nIdentDistrib : x\u271d\ninst\u271d\u00b9 : NormedAddCommGroup \u03b3\ninst\u271d : BorelSpace \u03b3\nh : sorry\nhf : MemLp f 1 \u03bc\n\u22a2 MemLp g 1 \u03bd"}, {"line": "exact h.memLp_snd hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MemLp.uniformIntegrable_of_identDistrib {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1 \u2192 E} {j : \u03b9} {p : \u211d\u22650\u221e}\n    (hp : 1 \u2264 p) (hp' : p \u2260 \u221e) (h\u2112p : MemLp (f j) p \u03bc) (hf : \u2200 i, IdentDistrib (f i) (f j) \u03bc \u03bc) :\n    UniformIntegrable f p \u03bc := by\n  have hfmeas : \u2200 i, AEStronglyMeasurable (f i) \u03bc := fun i =>\n    (hf i).aestronglyMeasurable_iff.2 h\u2112p.1\n  set g : \u03b9 \u2192 \u03b1 \u2192 E := fun i => (hfmeas i).choose\n  have hgmeas : \u2200 i, StronglyMeasurable (g i) := fun i => (Exists.choose_spec <| hfmeas i).1\n  have hgeq : \u2200 i, g i =\u1d50[\u03bc] f i := fun i => (Exists.choose_spec <| hfmeas i).2.symm\n  have hg\u2112p : MemLp (g j) p \u03bc := h\u2112p.ae_eq (hgeq j).symm\n  exact UniformIntegrable.ae_eq\n    (MemLp.uniformIntegrable_of_identDistrib_aux hp hp' hg\u2112p hgmeas fun i =>\n      (IdentDistrib.of_ae_eq (hgmeas i).aemeasurable (hgeq i)).trans\n        ((hf i).trans <| IdentDistrib.of_ae_eq (hfmeas j).aemeasurable (hgeq j).symm)) hgeq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/IdentDistrib.lean", "context": {"open": ["MeasureTheory Filter Finset", "scoped Topology MeasureTheory ENNReal NNReal", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] [MeasurableSpace \u03b3]", "{\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3}", "{E : Type*} [MeasurableSpace E] [NormedAddCommGroup E] [BorelSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nE : Type u_5\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : BorelSpace E\nx\u271d : Sort u_7\nIdentDistrib : x\u271d\n\u03b9 : Type u_6\nf : \u03b9 \u2192 \u03b1 \u2192 E\nj : \u03b9\np : ENNReal\nhp : 1 \u2264 p\nhp' : p \u2260 \u22a4\nh\u2112p : MemLp (f j) p \u03bc\nhf : ?m.2529 hp hp' h\u2112p \u2192 sorry\n\u22a2 UniformIntegrable f p \u03bc"}, {"line": "have hfmeas : \u2200 i, AEStronglyMeasurable (f i) \u03bc := fun i =>\n    (hf i).aestronglyMeasurable_iff.2 h\u2112p.1", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nE : Type u_5\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : BorelSpace E\nx\u271d : Sort u_7\nIdentDistrib : x\u271d\n\u03b9 : Type u_6\nf : \u03b9 \u2192 \u03b1 \u2192 E\nj : \u03b9\np : ENNReal\nhp : 1 \u2264 p\nhp' : p \u2260 \u22a4\nh\u2112p : MemLp (f j) p \u03bc\nhf : ?m.2529 hp hp' h\u2112p \u2192 sorry\nhfmeas : \u03b9 \u2192 sorry\n\u22a2 UniformIntegrable f p \u03bc"}, {"line": "set g : \u03b9 \u2192 \u03b1 \u2192 E := fun i => (hfmeas i).choose", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nE : Type u_5\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : BorelSpace E\nx\u271d : Sort u_7\nIdentDistrib : x\u271d\n\u03b9 : Type u_6\nf : \u03b9 \u2192 \u03b1 \u2192 E\nj : \u03b9\np : ENNReal\nhp : 1 \u2264 p\nhp' : p \u2260 \u22a4\nh\u2112p : MemLp (f j) p \u03bc\nhf : ?m.2529 hp hp' h\u2112p \u2192 sorry\nhfmeas : \u03b9 \u2192 sorry\ng : \u03b9 \u2192 \u03b1 \u2192 E := fun i => sorry\n\u22a2 UniformIntegrable f p \u03bc"}, {"line": "have hgmeas : \u2200 i, StronglyMeasurable (g i) := fun i => (Exists.choose_spec <| hfmeas i).1", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nE : Type u_5\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : BorelSpace E\nx\u271d : Sort u_7\nIdentDistrib : x\u271d\n\u03b9 : Type u_6\nf : \u03b9 \u2192 \u03b1 \u2192 E\nj : \u03b9\np : ENNReal\nhp : 1 \u2264 p\nhp' : p \u2260 \u22a4\nh\u2112p : MemLp (f j) p \u03bc\nhf : ?m.2529 hp hp' h\u2112p \u2192 sorry\nhfmeas : \u03b9 \u2192 sorry\ng : \u03b9 \u2192 \u03b1 \u2192 E := fun i => sorry\nhgmeas : \u03b9 \u2192 sorry\n\u22a2 UniformIntegrable f p \u03bc"}, {"line": "have hgeq : \u2200 i, g i =\u1d50[\u03bc] f i := fun i => (Exists.choose_spec <| hfmeas i).2.symm", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nE : Type u_5\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : BorelSpace E\nx\u271d : Sort u_7\nIdentDistrib : x\u271d\n\u03b9 : Type u_6\nf : \u03b9 \u2192 \u03b1 \u2192 E\nj : \u03b9\np : ENNReal\nhp : 1 \u2264 p\nhp' : p \u2260 \u22a4\nh\u2112p : MemLp (f j) p \u03bc\nhf : ?m.2529 hp hp' h\u2112p \u2192 sorry\nhfmeas : \u03b9 \u2192 sorry\ng : \u03b9 \u2192 \u03b1 \u2192 E := fun i => sorry\nhgmeas : \u03b9 \u2192 sorry\nhgeq : \u2200 (i : \u03b9), g i =\u1da0[ae \u03bc] f i\n\u22a2 UniformIntegrable f p \u03bc"}, {"line": "have hg\u2112p : MemLp (g j) p \u03bc := h\u2112p.ae_eq (hgeq j).symm", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nE : Type u_5\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : BorelSpace E\nx\u271d : Sort u_7\nIdentDistrib : x\u271d\n\u03b9 : Type u_6\nf : \u03b9 \u2192 \u03b1 \u2192 E\nj : \u03b9\np : ENNReal\nhp : 1 \u2264 p\nhp' : p \u2260 \u22a4\nh\u2112p : MemLp (f j) p \u03bc\nhf : ?m.2529 hp hp' h\u2112p \u2192 sorry\nhfmeas : \u03b9 \u2192 sorry\ng : \u03b9 \u2192 \u03b1 \u2192 E := fun i => sorry\nhgmeas : \u03b9 \u2192 sorry\nhgeq : \u2200 (i : \u03b9), g i =\u1da0[ae \u03bc] f i\nhg\u2112p : sorry\n\u22a2 UniformIntegrable f p \u03bc"}, {"line": "exact UniformIntegrable.ae_eq\n    (MemLp.uniformIntegrable_of_identDistrib_aux hp hp' hg\u2112p hgmeas fun i =>\n      (IdentDistrib.of_ae_eq (hgmeas i).aemeasurable (hgeq i)).trans\n        ((hf i).trans <| IdentDistrib.of_ae_eq (hfmeas j).aemeasurable (hgeq j).symm)) hgeq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_truncation_eq_intervalIntegral (hf : AEStronglyMeasurable f \u03bc) {A : \u211d}\n    (hA : 0 \u2264 A) : \u222b x, truncation f A x \u2202\u03bc = \u222b y in -A..A, y \u2202Measure.map f \u03bc := by\n  simpa using moment_truncation_eq_intervalIntegral hf hA one_ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/StrongLaw.lean", "context": {"open": ["MeasureTheory Filter Finset Asymptotics", "Set (indicator)", "scoped Topology MeasureTheory ProbabilityTheory ENNReal NNReal", "scoped Function -- required for scoped `on` notation"], "variables": ["{\u03b1 : Type*}", "{m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nx\u271d : Sort u_2\ntruncation : x\u271d\nhf : AEStronglyMeasurable f \u03bc\nA : \u211d\nhA : 0 \u2264 A\n\u22a2 \u222b (x : \u03b1), sorry \u2202\u03bc = \u222b (y : \u211d) in -A..A, y \u2202Measure.map f \u03bc"}, {"line": "simpa using moment_truncation_eq_intervalIntegral hf hA one_ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_truncation_eq_intervalIntegral_of_nonneg (hf : AEStronglyMeasurable f \u03bc) {A : \u211d}\n    (h'f : 0 \u2264 f) : \u222b x, truncation f A x \u2202\u03bc = \u222b y in (0)..A, y \u2202Measure.map f \u03bc := by\n  simpa using moment_truncation_eq_intervalIntegral_of_nonneg hf one_ne_zero h'f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/StrongLaw.lean", "context": {"open": ["MeasureTheory Filter Finset Asymptotics", "Set (indicator)", "scoped Topology MeasureTheory ProbabilityTheory ENNReal NNReal", "scoped Function -- required for scoped `on` notation"], "variables": ["{\u03b1 : Type*}", "{m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nx\u271d : Sort u_2\ntruncation : x\u271d\nhf : AEStronglyMeasurable f \u03bc\nA : \u211d\nh'f : 0 \u2264 f\n\u22a2 \u222b (x : \u03b1), sorry \u2202\u03bc = \u222b (y : \u211d) in 0 ..A, y \u2202Measure.map f \u03bc"}, {"line": "simpa using moment_truncation_eq_intervalIntegral_of_nonneg hf one_ne_zero h'f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_truncation_le_integral_of_nonneg (hf : Integrable f \u03bc) (h'f : 0 \u2264 f) {A : \u211d} :\n    \u222b x, truncation f A x \u2202\u03bc \u2264 \u222b x, f x \u2202\u03bc := by\n  apply integral_mono_of_nonneg\n    (Eventually.of_forall fun x => ?_) hf (Eventually.of_forall fun x => ?_)\n  \u00b7 exact truncation_nonneg _ (h'f x)\n  \u00b7 calc\n      truncation f A x \u2264 |truncation f A x| := le_abs_self _\n      _ \u2264 |f x| := abs_truncation_le_abs_self _ _ _\n      _ = f x := abs_of_nonneg (h'f x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/StrongLaw.lean", "context": {"open": ["MeasureTheory Filter Finset Asymptotics", "Set (indicator)", "scoped Topology MeasureTheory ProbabilityTheory ENNReal NNReal", "scoped Function -- required for scoped `on` notation"], "variables": ["{\u03b1 : Type*}", "{m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nx\u271d : Sort u_2\ntruncation : x\u271d\nhf : Integrable f \u03bc\nh'f : 0 \u2264 f\nA : \u211d\n\u22a2 \u222b (x : \u03b1), sorry \u2202\u03bc \u2264 \u222b (x : \u03b1), f x \u2202\u03bc"}, {"line": "apply integral_mono_of_nonneg\n    (Eventually.of_forall fun x => ?_) hf (Eventually.of_forall fun x => ?_)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nx\u271d : Sort u_2\ntruncation : x\u271d\nhf : Integrable f \u03bc\nh'f : 0 \u2264 f\nA : \u211d\nx : \u03b1\n\u22a2 0 x \u2264 sorry\n---\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nx\u271d : Sort u_2\ntruncation : x\u271d\nhf : Integrable f \u03bc\nh'f : 0 \u2264 f\nA : \u211d\nx : \u03b1\n\u22a2 sorry \u2264 f x"}, {"line": "\u00b7 exact truncation_nonneg _ (h'f x)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nx\u271d : Sort u_2\ntruncation : x\u271d\nhf : Integrable f \u03bc\nh'f : 0 \u2264 f\nA : \u211d\nx : \u03b1\n\u22a2 sorry \u2264 f x"}, {"line": "\u00b7 calc\n      truncation f A x \u2264 |truncation f A x| := le_abs_self _\n      _ \u2264 |f x| := abs_truncation_le_abs_self _ _ _\n      _ = f x := abs_of_nonneg (h'f x)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma evariance_eq_top_iff [IsFiniteMeasure \u03bc] (hX : AEStronglyMeasurable X \u03bc) :\n    evariance X \u03bc = \u221e \u2194 \u00ac MemLp X 2 \u03bc := by simp [\u2190 evariance_lt_top_iff_memLp hX]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Variance.lean", "context": {"open": ["MeasureTheory Filter Finset", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal"], "variables": ["{\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {\u03bc : Measure \u03a9}", "(X \u03bc) in", "(X \u03bc) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nevariance : x\u271d\ninst\u271d : IsFiniteMeasure \u03bc\nhX : AEStronglyMeasurable X \u03bc\n\u22a2 sorry = \u22a4 \u2194 \u00acMemLp X 2 \u03bc"}, {"line": "simp [\u2190 evariance_lt_top_iff_memLp hX]", "tactic_state": "\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nevariance : x\u271d\ninst\u271d : IsFiniteMeasure \u03bc\nhX : AEStronglyMeasurable X \u03bc\n\u22a2 sorry () = \u22a4 \u2194 \u00acMemLp X 2 \u03bc"}]}
{"declaration": "theorem evariance_eq_lintegral_ofReal :\n    evariance X \u03bc = \u222b\u207b \u03c9, ENNReal.ofReal ((X \u03c9 - \u03bc[X]) ^ 2) \u2202\u03bc := by\n  simp [evariance, \u2190 enorm_pow, Real.enorm_of_nonneg (sq_nonneg _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Variance.lean", "context": {"open": ["MeasureTheory Filter Finset", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal"], "variables": ["{\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {\u03bc : Measure \u03a9}", "(X \u03bc) in", "(X \u03bc) in", "(X \u03bc) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nevariance : x\u271d\n\u22a2 sorry = \u222b\u207b (\u03c9 : \u03a9), ENNReal.ofReal ((X \u03c9 - \u222b (x : \u03a9), X x \u2202\u03bc) ^ 2) \u2202\u03bc"}, {"line": "simp [evariance, \u2190 enorm_pow, Real.enorm_of_nonneg (sq_nonneg _)]", "tactic_state": "\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nevariance : x\u271d\n\u22a2 sorry () = \u222b\u207b (\u03c9 : \u03a9), ENNReal.ofReal ((X \u03c9 - \u222b (x : \u03a9), X x \u2202\u03bc) ^ 2) \u2202\u03bc"}]}
{"declaration": "lemma variance_of_integral_eq_zero (hX : AEMeasurable X \u03bc) (hXint : \u03bc[X] = 0) :\n    variance X \u03bc = \u222b \u03c9, X \u03c9 ^ 2 \u2202\u03bc := by\n  simp [variance_eq_integral hX, hXint]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Variance.lean", "context": {"open": ["MeasureTheory Filter Finset", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal"], "variables": ["{\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {\u03bc : Measure \u03a9}", "(X \u03bc) in", "(X \u03bc) in", "(X \u03bc) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nvariance : x\u271d\nhX : AEMeasurable X \u03bc\nhXint : \u222b (x : \u03a9), X x \u2202\u03bc = 0\n\u22a2 sorry = \u222b (\u03c9 : \u03a9), X \u03c9 ^ 2 \u2202\u03bc"}, {"line": "simp [variance_eq_integral hX, hXint]", "tactic_state": "\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nvariance : x\u271d\nhX : AEMeasurable X \u03bc\nhXint : \u222b (x : \u03a9), X x \u2202\u03bc = 0\n\u22a2 sorry () = \u222b (\u03c9 : \u03a9), X \u03c9 ^ 2 \u2202\u03bc"}]}
{"declaration": "theorem evariance_zero : evariance 0 \u03bc = 0 := by simp [evariance]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Variance.lean", "context": {"open": ["MeasureTheory Filter Finset", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal"], "variables": ["{\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {\u03bc : Measure \u03a9}", "(X \u03bc) in", "(X \u03bc) in", "(X \u03bc) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nevariance : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [evariance]", "tactic_state": "x\u271d : Sort u_2\nevariance : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem evariance_eq_zero_iff (hX : AEMeasurable X \u03bc) :\n    evariance X \u03bc = 0 \u2194 X =\u1d50[\u03bc] fun _ => \u03bc[X] := by\n  simp [evariance, lintegral_eq_zero_iff' ((hX.sub_const _).enorm.pow_const _), EventuallyEq,\n    sub_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Variance.lean", "context": {"open": ["MeasureTheory Filter Finset", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal"], "variables": ["{\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {\u03bc : Measure \u03a9}", "(X \u03bc) in", "(X \u03bc) in", "(X \u03bc) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nevariance : x\u271d\nhX : AEMeasurable X \u03bc\n\u22a2 sorry = 0 \u2194 X =\u1da0[ae \u03bc] fun x => \u222b (x : \u03a9), X x \u2202\u03bc"}, {"line": "simp [evariance, lintegral_eq_zero_iff' ((hX.sub_const _).enorm.pow_const _), EventuallyEq,\n    sub_eq_zero]", "tactic_state": "\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nevariance : x\u271d\nhX : AEMeasurable X \u03bc\n\u22a2 sorry () = 0 \u2194 \u2200\u1d50 (x : \u03a9) \u2202\u03bc, X x = \u222b (x : \u03a9), X x \u2202\u03bc"}]}
{"declaration": "lemma variance_le_sub_mul_sub [IsProbabilityMeasure \u03bc] {a b : \u211d} {X : \u03a9 \u2192 \u211d}\n    (h : \u2200\u1d50 \u03c9 \u2202\u03bc, X \u03c9 \u2208 Set.Icc a b) (hX : AEMeasurable X \u03bc) :\n    variance X \u03bc \u2264 (b - \u03bc[X]) * (\u03bc[X] - a) := by\n  have ha : \u2200\u1d50 \u03c9 \u2202\u03bc, a \u2264 X \u03c9 := h.mono fun \u03c9 h => h.1\n  have hb : \u2200\u1d50 \u03c9 \u2202\u03bc, X \u03c9 \u2264 b := h.mono fun \u03c9 h => h.2\n  have hX_int\u2082 : Integrable (fun \u03c9 \u21a6 -X \u03c9 ^ 2) \u03bc :=\n    (memLp_of_bounded h hX.aestronglyMeasurable 2).integrable_sq.neg\n  have hX_int\u2081 : Integrable (fun \u03c9 \u21a6 (a + b) * X \u03c9) \u03bc :=\n    ((integrable_const (max |a| |b|)).mono' hX.aestronglyMeasurable\n      (by filter_upwards [ha, hb] with \u03c9 using abs_le_max_abs_abs)).const_mul (a + b)\n  have h0 : 0 \u2264 - \u03bc[X ^ 2] + (a + b) * \u03bc[X] - a * b :=\n    calc\n      _ \u2264 \u222b \u03c9, (b - X \u03c9) * (X \u03c9 - a) \u2202\u03bc := by\n        apply integral_nonneg_of_ae\n        filter_upwards [ha, hb] with \u03c9 ha' hb'\n        exact mul_nonneg (by linarith : 0 \u2264 b - X \u03c9) (by linarith : 0 \u2264 X \u03c9 - a)\n      _ = \u222b \u03c9, - X \u03c9 ^ 2 + (a + b) * X \u03c9 - a * b \u2202\u03bc :=\n        integral_congr_ae <| ae_of_all \u03bc fun \u03c9 \u21a6 by ring\n      _ = \u222b \u03c9, - X \u03c9 ^ 2 + (a + b) * X \u03c9 \u2202\u03bc - \u222b _, a * b \u2202\u03bc :=\n        integral_sub (by fun_prop) (integrable_const (a * b))\n      _ = \u222b \u03c9, - X \u03c9 ^ 2 + (a + b) * X \u03c9 \u2202\u03bc - a * b := by simp\n      _ = - \u03bc[X ^ 2] + (a + b) * \u03bc[X] - a * b := by\n        simp [\u2190 integral_neg, \u2190 integral_const_mul, integral_add hX_int\u2082 hX_int\u2081]\n  calc\n    _ \u2264 (a + b) * \u03bc[X] - a * b - \u03bc[X] ^ 2 := by\n      rw [variance_def' (memLp_of_bounded h hX.aestronglyMeasurable 2)]\n      linarith\n    _ = (b - \u03bc[X]) * (\u03bc[X] - a) := by ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Variance.lean", "context": {"open": ["MeasureTheory Filter Finset", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal"], "variables": ["{\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {\u03bc : Measure \u03a9}", "(X \u03bc) in", "(X \u03bc) in", "(X \u03bc) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nvariance : x\u271d\ninst\u271d : IsProbabilityMeasure \u03bc\na b : \u211d\nX : \u03a9 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2208 Set.Icc a b\nhX : AEMeasurable X \u03bc\n\u22a2 sorry \u2264 (b - \u222b (x : \u03a9), X x \u2202\u03bc) * (\u222b (x : \u03a9), X x \u2202\u03bc - a)"}, {"line": "have ha : \u2200\u1d50 \u03c9 \u2202\u03bc, a \u2264 X \u03c9 := h.mono fun \u03c9 h => h.1", "tactic_state": "\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nvariance : x\u271d\ninst\u271d : IsProbabilityMeasure \u03bc\na b : \u211d\nX : \u03a9 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2208 Set.Icc a b\nhX : AEMeasurable X \u03bc\nha : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, a \u2264 X \u03c9\n\u22a2 sorry \u2264 (b - \u222b (x : \u03a9), X x \u2202\u03bc) * (\u222b (x : \u03a9), X x \u2202\u03bc - a)"}, {"line": "have hb : \u2200\u1d50 \u03c9 \u2202\u03bc, X \u03c9 \u2264 b := h.mono fun \u03c9 h => h.2", "tactic_state": "\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nvariance : x\u271d\ninst\u271d : IsProbabilityMeasure \u03bc\na b : \u211d\nX : \u03a9 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2208 Set.Icc a b\nhX : AEMeasurable X \u03bc\nha : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, a \u2264 X \u03c9\nhb : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2264 b\n\u22a2 sorry \u2264 (b - \u222b (x : \u03a9), X x \u2202\u03bc) * (\u222b (x : \u03a9), X x \u2202\u03bc - a)"}, {"line": "have hX_int\u2082 : Integrable (fun \u03c9 \u21a6 -X \u03c9 ^ 2) \u03bc :=\n    (memLp_of_bounded h hX.aestronglyMeasurable 2).integrable_sq.neg", "tactic_state": "\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nvariance : x\u271d\ninst\u271d : IsProbabilityMeasure \u03bc\na b : \u211d\nX : \u03a9 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2208 Set.Icc a b\nhX : AEMeasurable X \u03bc\nha : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, a \u2264 X \u03c9\nhb : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2264 b\nhX_int\u2082 : Integrable (fun \u03c9 => -X \u03c9 ^ 2) \u03bc\n\u22a2 sorry \u2264 (b - \u222b (x : \u03a9), X x \u2202\u03bc) * (\u222b (x : \u03a9), X x \u2202\u03bc - a)"}, {"line": "have hX_int\u2081 : Integrable (fun \u03c9 \u21a6 (a + b) * X \u03c9) \u03bc :=\n    ((integrable_const (max |a| |b|)).mono' hX.aestronglyMeasurable\n      (by filter_upwards [ha, hb] with \u03c9 using abs_le_max_abs_abs)).const_mul (a + b)", "tactic_state": "case refine_2\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nvariance : x\u271d\ninst\u271d : IsProbabilityMeasure \u03bc\na b : \u211d\nX : \u03a9 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2208 Set.Icc a b\nhX : AEMeasurable X \u03bc\nha : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, a \u2264 X \u03c9\nhb : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2264 b\nhX_int\u2082 : Integrable (fun \u03c9 => -X \u03c9 ^ 2) \u03bc\nhX_int\u2081 : Integrable (fun \u03c9 => (a + b) * X \u03c9) \u03bc\n\u22a2 sorry \u2264 (b - \u222b (x : \u03a9), X x \u2202\u03bc) * (\u222b (x : \u03a9), X x \u2202\u03bc - a)\n---\ncase refine_1\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nvariance : x\u271d\ninst\u271d : IsProbabilityMeasure \u03bc\na b : \u211d\nX : \u03a9 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2208 Set.Icc a b\nhX : AEMeasurable X \u03bc\nha : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, a \u2264 X \u03c9\nhb : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2264 b\nhX_int\u2082 : Integrable (fun \u03c9 => -X \u03c9 ^ 2) \u03bc\n\u22a2 IsFiniteMeasure \u03bc"}, {"line": "have h0 : 0 \u2264 - \u03bc[X ^ 2] + (a + b) * \u03bc[X] - a * b :=\n    calc\n      _ \u2264 \u222b \u03c9, (b - X \u03c9) * (X \u03c9 - a) \u2202\u03bc := by\n        apply integral_nonneg_of_ae\n        filter_upwards [ha, hb] with \u03c9 ha' hb'\n        exact mul_nonneg (by linarith : 0 \u2264 b - X \u03c9) (by linarith : 0 \u2264 X \u03c9 - a)\n      _ = \u222b \u03c9, - X \u03c9 ^ 2 + (a + b) * X \u03c9 - a * b \u2202\u03bc :=\n        integral_congr_ae <| ae_of_all \u03bc fun \u03c9 \u21a6 by ring\n      _ = \u222b \u03c9, - X \u03c9 ^ 2 + (a + b) * X \u03c9 \u2202\u03bc - \u222b _, a * b \u2202\u03bc :=\n        integral_sub (by fun_prop) (integrable_const (a * b))\n      _ = \u222b \u03c9, - X \u03c9 ^ 2 + (a + b) * X \u03c9 \u2202\u03bc - a * b := by simp\n      _ = - \u03bc[X ^ 2] + (a + b) * \u03bc[X] - a * b := by\n        simp [\u2190 integral_neg, \u2190 integral_const_mul, integral_add hX_int\u2082 hX_int\u2081]", "tactic_state": "case refine_2\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nvariance : x\u271d\ninst\u271d : IsProbabilityMeasure \u03bc\na b : \u211d\nX : \u03a9 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2208 Set.Icc a b\nhX : AEMeasurable X \u03bc\nha : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, a \u2264 X \u03c9\nhb : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2264 b\nhX_int\u2082 : Integrable (fun \u03c9 => -X \u03c9 ^ 2) \u03bc\nhX_int\u2081 : Integrable (fun \u03c9 => (a + b) * X \u03c9) \u03bc\nh0 : 0 \u2264 -sorry + (a + b) * sorry - a * b\n\u22a2 sorry \u2264 (b - \u222b (x : \u03a9), X x \u2202\u03bc) * (\u222b (x : \u03a9), X x \u2202\u03bc - a)\n---\ncase refine_1\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nvariance : x\u271d\ninst\u271d : IsProbabilityMeasure \u03bc\na b : \u211d\nX : \u03a9 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2208 Set.Icc a b\nhX : AEMeasurable X \u03bc\nha : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, a \u2264 X \u03c9\nhb : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2264 b\nhX_int\u2082 : Integrable (fun \u03c9 => -X \u03c9 ^ 2) \u03bc\n\u22a2 IsFiniteMeasure \u03bc"}, {"line": "calc\n    _ \u2264 (a + b) * \u03bc[X] - a * b - \u03bc[X] ^ 2 := by\n      rw [variance_def' (memLp_of_bounded h hX.aestronglyMeasurable 2)]\n      linarith\n    _ = (b - \u03bc[X]) * (\u03bc[X] - a) := by ring", "tactic_state": "case refine_2.calc.step\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nvariance : x\u271d\ninst\u271d : IsProbabilityMeasure \u03bc\na b : \u211d\nX : \u03a9 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2208 Set.Icc a b\nhX : AEMeasurable X \u03bc\nha : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, a \u2264 X \u03c9\nhb : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2264 b\nhX_int\u2082 : Integrable (fun \u03c9 => -X \u03c9 ^ 2) \u03bc\nhX_int\u2081 : Integrable (fun \u03c9 => (a + b) * X \u03c9) \u03bc\nh0 : 0 \u2264 -sorry + (a + b) * sorry - a * b\n\u22a2 (b - sorry) * (sorry - a) \u2264 (b - \u222b (x : \u03a9), X x \u2202\u03bc) * (\u222b (x : \u03a9), X x \u2202\u03bc - a)\n---\ncase refine_1\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nx\u271d : Sort u_2\nvariance : x\u271d\ninst\u271d : IsProbabilityMeasure \u03bc\na b : \u211d\nX : \u03a9 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2208 Set.Icc a b\nhX : AEMeasurable X \u03bc\nha : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, a \u2264 X \u03c9\nhb : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2264 b\nhX_int\u2082 : Integrable (fun \u03c9 => -X \u03c9 ^ 2) \u03bc\n\u22a2 IsFiniteMeasure \u03bc"}]}
{"declaration": "lemma hasDerivAt_neg_exp_mul_exp {r x : \u211d} :\n    HasDerivAt (fun a \u21a6 -exp (-(r * a))) (r * exp (-(r * x))) x := by\n  convert (((hasDerivAt_id x).const_mul (-r)).exp.const_mul (-1)) using 1\n  \u00b7 simp only [one_mul, id_eq, neg_mul]\n  simp only [id_eq]\n  simp only [neg_mul]\n  simp only [mul_one]\n  simp only [mul_neg]\n  simp only [one_mul]\n  simp only [neg_neg]\n  simp only [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Distributions/Exponential.lean", "context": {"open": ["scoped ENNReal NNReal", "MeasureTheory Real Set Filter Topology", "Measure", "MeasureTheory", "Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "r x : \u211d\n\u22a2 HasDerivAt (fun a => -exp (-(r * a))) (r * exp (-(r * x))) x"}, {"line": "convert (((hasDerivAt_id x).const_mul (-r)).exp.const_mul (-1)) using 1", "tactic_state": "case h.e'_8\nr x : \u211d\n\u22a2 (fun a => -exp (-(r * a))) = fun y => -1 * exp (-r * id y)\n---\ncase h.e'_9\nr x : \u211d\n\u22a2 r * exp (-(r * x)) = -1 * (exp (-r * id x) * (-r * 1))"}, {"line": "\u00b7 simp only [one_mul, id_eq, neg_mul]", "tactic_state": "case h.e'_9\nr x : \u211d\n\u22a2 r * exp (-(r * x)) = -1 * (exp (-r * id x) * (-r * 1))"}, {"line": "simp only [id_eq]", "tactic_state": "case h.e'_9\nr x : \u211d\n\u22a2 r * exp (-(r * x)) = -1 * (exp (-r * x) * (-r * 1))"}, {"line": "simp only [neg_mul]", "tactic_state": "case h.e'_9\nr x : \u211d\n\u22a2 r * exp (-(r * x)) = -(1 * (exp (-(r * x)) * -(r * 1)))"}, {"line": "simp only [mul_one]", "tactic_state": "case h.e'_9\nr x : \u211d\n\u22a2 r * exp (-(r * x)) = -(1 * (exp (-(r * x)) * -r))"}, {"line": "simp only [mul_neg]", "tactic_state": "case h.e'_9\nr x : \u211d\n\u22a2 r * exp (-(r * x)) = - -(1 * (exp (-(r * x)) * r))"}, {"line": "simp only [one_mul]", "tactic_state": "case h.e'_9\nr x : \u211d\n\u22a2 r * exp (-(r * x)) = - -(exp (-(r * x)) * r)"}, {"line": "simp only [neg_neg]", "tactic_state": "case h.e'_9\nr x : \u211d\n\u22a2 r * exp (-(r * x)) = exp (-(r * x)) * r"}, {"line": "simp only [mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exp_neg_integrableOn_Ioc {b x : \u211d} (hb : 0 < b) :\n    IntegrableOn (fun x \u21a6 rexp (-(b * x))) (Ioc 0 x) := by\n  simp only [neg_mul_eq_neg_mul]\n  exact (exp_neg_integrableOn_Ioi _ hb).mono_set Ioc_subset_Ioi_self\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Distributions/Exponential.lean", "context": {"open": ["scoped ENNReal NNReal", "MeasureTheory Real Set Filter Topology", "Measure", "MeasureTheory", "Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b x : \u211d\nhb : 0 < b\n\u22a2 IntegrableOn (fun x => exp (-(b * x))) (Ioc 0 x) volume"}, {"line": "simp only [neg_mul_eq_neg_mul]", "tactic_state": "b x : \u211d\nhb : 0 < b\n\u22a2 IntegrableOn (fun x => exp (-b * x)) (Ioc 0 x) volume"}, {"line": "exact (exp_neg_integrableOn_Ioi _ hb).mono_set Ioc_subset_Ioi_self", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lintegral_Iic_eq_lintegral_Iio_add_Icc {y z : \u211d} (f : \u211d \u2192 \u211d\u22650\u221e) (hzy : z \u2264 y) :\n    \u222b\u207b x in Iic y, f x = (\u222b\u207b x in Iio z, f x) + \u222b\u207b x in Icc z y, f x := by\n  rw [\u2190 Iio_union_Icc_eq_Iic hzy]\n  rw [lintegral_union measurableSet_Icc]\n  simp_rw [Set.disjoint_iff_forall_ne, mem_Iio, mem_Icc]\n  intros\n  linarith\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Distributions/Gamma.lean", "context": {"open": ["scoped ENNReal NNReal", "MeasureTheory Real Set Filter Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y z : \u211d\nf : \u211d \u2192 ENNReal\nhzy : z \u2264 y\n\u22a2 \u222b\u207b (x : \u211d) in Iic y, f x = (\u222b\u207b (x : \u211d) in Iio z, f x) + \u222b\u207b (x : \u211d) in Icc z y, f x"}, {"line": "rw [\u2190 Iio_union_Icc_eq_Iic hzy]", "tactic_state": "y z : \u211d\nf : \u211d \u2192 ENNReal\nhzy : z \u2264 y\n\u22a2 \u222b\u207b (x : \u211d) in Iio z \u222a Icc z y, f x = (\u222b\u207b (x : \u211d) in Iio z, f x) + \u222b\u207b (x : \u211d) in Icc z y, f x"}, {"line": "rw [lintegral_union measurableSet_Icc]", "tactic_state": "y z : \u211d\nf : \u211d \u2192 ENNReal\nhzy : z \u2264 y\n\u22a2 Disjoint (Iio z) (Icc z y)"}, {"line": "simp_rw [Set.disjoint_iff_forall_ne, mem_Iio, mem_Icc]", "tactic_state": "y z : \u211d\nf : \u211d \u2192 ENNReal\nhzy : z \u2264 y\n\u22a2 \u2200 \u2983a : \u211d\u2984, a < z \u2192 \u2200 \u2983b : \u211d\u2984, z \u2264 b \u2227 b \u2264 y \u2192 a \u2260 b"}, {"line": "intros", "tactic_state": "y z : \u211d\nf : \u211d \u2192 ENNReal\nhzy : z \u2264 y\na\u271d\u00b2 : \u211d\na\u271d\u00b9 : a\u271d\u00b2 < z\nb\u271d : \u211d\na\u271d : z \u2264 b\u271d \u2227 b\u271d \u2264 y\n\u22a2 a\u271d\u00b2 \u2260 b\u271d"}, {"line": "linarith", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isProbabilityMeasureGamma {a r : \u211d} (ha : 0 < a) (hr : 0 < r) :\n    IsProbabilityMeasure (gammaMeasure a r) where\n  measure_univ := by simp [gammaMeasure, lintegral_gammaPDF_eq_one ha hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Distributions/Gamma.lean", "context": {"open": ["scoped ENNReal NNReal", "MeasureTheory Real Set Filter Topology", "Measure", "MeasureTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ngammaMeasure : x\u271d\na r : \u211d\nha : 0 < a\nhr : 0 < r\n\u22a2 sorry univ = 1"}, {"line": "simp [gammaMeasure, lintegral_gammaPDF_eq_one ha hr]", "tactic_state": "x\u271d : Sort u_1\ngammaMeasure : x\u271d\na r : \u211d\nha : 0 < a\nhr : 0 < r\n\u22a2 (sorry ()) univ = 1"}]}
{"declaration": "lemma gaussianPDF_lt_top {\u03bc : \u211d} {v : \u211d\u22650} {x : \u211d} : gaussianPDF \u03bc v x < \u221e := by simp [gaussianPDF]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Distributions/Gaussian.lean", "context": {"open": ["scoped ENNReal NNReal Real Complex", "MeasureTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ngaussianPDF : x\u271d\n\u03bc : \u211d\nv : NNReal\nx : \u211d\n\u22a2 sorry < \u22a4"}, {"line": "simp [gaussianPDF]", "tactic_state": "x\u271d : Sort u_1\ngaussianPDF : x\u271d\n\u03bc : \u211d\nv : NNReal\nx : \u211d\n\u22a2 sorry () < \u22a4"}]}
{"declaration": "lemma gaussianPDF_ne_top {\u03bc : \u211d} {v : \u211d\u22650} {x : \u211d} : gaussianPDF \u03bc v x \u2260 \u221e := by simp [gaussianPDF]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Distributions/Gaussian.lean", "context": {"open": ["scoped ENNReal NNReal Real Complex", "MeasureTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ngaussianPDF : x\u271d\n\u03bc : \u211d\nv : NNReal\nx : \u211d\n\u22a2 sorry \u2260 \u22a4"}, {"line": "simp [gaussianPDF]", "tactic_state": "x\u271d : Sort u_1\ngaussianPDF : x\u271d\n\u03bc : \u211d\nv : NNReal\nx : \u211d\n\u22a2 \u00acsorry () = \u22a4"}]}
{"declaration": "lemma integral_gaussianReal_eq_integral_smul {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    {\u03bc : \u211d} {v : \u211d\u22650} {f : \u211d \u2192 E} (hv : v \u2260 0) :\n    \u222b x, f x \u2202(gaussianReal \u03bc v) = \u222b x, gaussianPDFReal \u03bc v x \u2022 f x := by\n  simp [gaussianReal, hv,\n    integral_withDensity_eq_integral_toReal_smul (measurable_gaussianPDF _ _)\n      (ae_of_all _ fun _ \u21a6 gaussianPDF_lt_top)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Distributions/Gaussian.lean", "context": {"open": ["scoped ENNReal NNReal Real Complex", "MeasureTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\ngaussianReal : x\u271d\u00b9\nx\u271d : Sort u_3\ngaussianPDFReal : x\u271d\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03bc : \u211d\nv : NNReal\nf : \u211d \u2192 E\nhv : v \u2260 0\n\u22a2 \u222b (x : \u211d), f x \u2202sorry = \u222b (x : \u211d), ?m.642 \u2022 f x"}, {"line": "simp [gaussianReal, hv,\n    integral_withDensity_eq_integral_toReal_smul (measurable_gaussianPDF _ _)\n      (ae_of_all _ fun _ \u21a6 gaussianPDF_lt_top)]", "tactic_state": "x\u271d\u00b9 : Sort u_2\ngaussianReal : x\u271d\u00b9\nx\u271d : Sort u_3\ngaussianPDFReal : x\u271d\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03bc : \u211d\nv : NNReal\nf : \u211d \u2192 E\nhv : v \u2260 0\n\u22a2 \u222b (x : \u211d), f x \u2202sorry () = \u222b (x : \u211d), ?m.642 \u2022 f x"}]}
{"declaration": "lemma gaussianReal_const_add {X : \u03a9 \u2192 \u211d} (hX : Measure.map X \u2119 = gaussianReal \u03bc v) (y : \u211d) :\n    Measure.map (fun \u03c9 \u21a6 y + X \u03c9) \u2119 = gaussianReal (\u03bc + y) v := by\n  simp_rw [add_comm y]\n  exact gaussianReal_add_const hX y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Distributions/Gaussian.lean", "context": {"open": ["scoped ENNReal NNReal Real Complex", "MeasureTheory"], "variables": ["{\u03bc : \u211d} {v : \u211d\u22650}", "{\u03a9 : Type} [MeasureSpace \u03a9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type\ninst\u271d : MeasureSpace \u03a9\n\u2119 : Measure \u03a9\nx\u271d : Sort u_1\ngaussianReal : x\u271d\nX : \u03a9 \u2192 \u211d\nhX : Measure.map X \u2119 = sorry\ny : \u211d\n\u22a2 Measure.map (fun \u03c9 => y + X \u03c9) \u2119 = sorry"}, {"line": "simp_rw [add_comm y]", "tactic_state": "\u03a9 : Type\ninst\u271d : MeasureSpace \u03a9\n\u2119 : Measure \u03a9\nx\u271d : Sort u_1\ngaussianReal : x\u271d\nX : \u03a9 \u2192 \u211d\nhX : Measure.map X \u2119 = sorry\ny : \u211d\n\u22a2 Measure.map (fun \u03c9 => X \u03c9 + y) \u2119 = sorry"}, {"line": "exact gaussianReal_add_const hX y", "tactic_state": "No Goals!"}]}
{"declaration": "lemma gaussianReal_mul_const {X : \u03a9 \u2192 \u211d} (hX : Measure.map X \u2119 = gaussianReal \u03bc v) (c : \u211d) :\n    Measure.map (fun \u03c9 \u21a6 X \u03c9 * c) \u2119 = gaussianReal (c * \u03bc) (\u27e8c^2, sq_nonneg _\u27e9 * v) := by\n  simp_rw [mul_comm _ c]\n  exact gaussianReal_const_mul hX c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Distributions/Gaussian.lean", "context": {"open": ["scoped ENNReal NNReal Real Complex", "MeasureTheory"], "variables": ["{\u03bc : \u211d} {v : \u211d\u22650}", "{\u03a9 : Type} [MeasureSpace \u03a9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type\ninst\u271d : MeasureSpace \u03a9\n\u2119 : Measure \u03a9\nx\u271d : Sort u_1\ngaussianReal : x\u271d\nX : \u03a9 \u2192 \u211d\nhX : Measure.map X \u2119 = sorry\nc : \u211d\n\u22a2 Measure.map (fun \u03c9 => X \u03c9 * c) \u2119 = sorry"}, {"line": "simp_rw [mul_comm _ c]", "tactic_state": "\u03a9 : Type\ninst\u271d : MeasureSpace \u03a9\n\u2119 : Measure \u03a9\nx\u271d : Sort u_1\ngaussianReal : x\u271d\nX : \u03a9 \u2192 \u211d\nhX : Measure.map X \u2119 = sorry\nc : \u211d\n\u22a2 Measure.map (fun \u03c9 => c * X \u03c9) \u2119 = sorry"}, {"line": "exact gaussianReal_const_mul hX c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformOfFinset_apply_of_mem (ha : a \u2208 s) : uniformOfFinset s hs a = (s.card : \u211d\u22650\u221e)\u207b\u00b9 := by\n  simp [ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Distributions/Uniform.lean", "context": {"open": ["scoped Finset MeasureTheory NNReal ENNReal", "TopologicalSpace MeasureTheory.Measure PMF", "scoped Classical in", "scoped NNReal ENNReal", "scoped Classical in"], "variables": ["{E : Type*} [MeasurableSpace E] {\u03bc : Measure E}", "{\u03a9 : Type*}", "{_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}", "{X : \u03a9 \u2192 \u211d} {s : Set \u211d}", "{X : \u03a9 \u2192 E}", "{\u03b1 : Type*}", "{s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.2692\nE : Sort ?u.2734\n\u03a9 : Type u_1\nx\u271d : MeasurableSpace \u03a9\n\u2119 : sorry\nX\u271d : \u03a9 \u2192 \u211d\ns\u271d\u00b9 : Set \u211d\nX : \u03a9 \u2192 E\n\u03b1\u271d : Type u_2\ns\u271d : Finset \u03b1\u271d\nhs\u271d : s\u271d.Nonempty\na\u271d : \u03b1\u271d\n\u03b1 : Type u_2\ns : Finset \u03b1\nhs : s.Nonempty\na : \u03b1\nha : a \u2208 s\n\u22a2 (uniformOfFinset s hs) a = (\u2191s.card)\u207b\u00b9"}, {"line": "simp [ha]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformOfFinset_apply_of_not_mem (ha : a \u2209 s) : uniformOfFinset s hs a = 0 := by simp [ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Distributions/Uniform.lean", "context": {"open": ["scoped Finset MeasureTheory NNReal ENNReal", "TopologicalSpace MeasureTheory.Measure PMF", "scoped Classical in", "scoped NNReal ENNReal", "scoped Classical in"], "variables": ["{E : Type*} [MeasurableSpace E] {\u03bc : Measure E}", "{\u03a9 : Type*}", "{_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}", "{X : \u03a9 \u2192 \u211d} {s : Set \u211d}", "{X : \u03a9 \u2192 E}", "{\u03b1 : Type*}", "{s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.2692\nE : Sort ?u.2734\n\u03a9 : Type u_1\nx\u271d : MeasurableSpace \u03a9\n\u2119 : sorry\nX\u271d : \u03a9 \u2192 \u211d\ns\u271d\u00b9 : Set \u211d\nX : \u03a9 \u2192 E\n\u03b1\u271d : Type u_2\ns\u271d : Finset \u03b1\u271d\nhs\u271d : s\u271d.Nonempty\na\u271d : \u03b1\u271d\n\u03b1 : Type u_2\ns : Finset \u03b1\nhs : s.Nonempty\na : \u03b1\nha : a \u2209 s\n\u22a2 (uniformOfFinset s hs) a = 0"}, {"line": "simp [ha]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_support_uniformOfFinset_iff (a : \u03b1) : a \u2208 (uniformOfFinset s hs).support \u2194 a \u2208 s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Distributions/Uniform.lean", "context": {"open": ["scoped Finset MeasureTheory NNReal ENNReal", "TopologicalSpace MeasureTheory.Measure PMF", "scoped Classical in", "scoped NNReal ENNReal", "scoped Classical in"], "variables": ["{E : Type*} [MeasurableSpace E] {\u03bc : Measure E}", "{\u03a9 : Type*}", "{_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}", "{X : \u03a9 \u2192 \u211d} {s : Set \u211d}", "{X : \u03a9 \u2192 E}", "{\u03b1 : Type*}", "{s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.2692\nE : Sort ?u.2734\n\u03a9 : Type u_1\nx\u271d : MeasurableSpace \u03a9\n\u2119 : sorry\nX\u271d : \u03a9 \u2192 \u211d\ns\u271d\u00b9 : Set \u211d\nX : \u03a9 \u2192 E\n\u03b1\u271d : Type u_2\ns\u271d : Finset \u03b1\u271d\nhs\u271d : s\u271d.Nonempty\na\u271d : \u03b1\u271d\n\u03b1 : Type u_2\ns : Finset \u03b1\nhs : s.Nonempty\na : \u03b1\n\u22a2 a \u2208 (uniformOfFinset s hs).support \u2194 a \u2208 s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformOfFintype_apply (a : \u03b1) : uniformOfFintype \u03b1 a = (Fintype.card \u03b1 : \u211d\u22650\u221e)\u207b\u00b9 := by\n  simp [uniformOfFintype, Finset.mem_univ, if_true, uniformOfFinset_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Distributions/Uniform.lean", "context": {"open": ["scoped Finset MeasureTheory NNReal ENNReal", "TopologicalSpace MeasureTheory.Measure PMF", "scoped Classical in", "scoped NNReal ENNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{E : Type*} [MeasurableSpace E] {\u03bc : Measure E}", "{\u03a9 : Type*}", "{_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}", "{X : \u03a9 \u2192 \u211d} {s : Set \u211d}", "{X : \u03a9 \u2192 E}", "{\u03b1 : Type*}", "{s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}", "(t : Set \u03b1)", "[Fintype \u03b1] [Nonempty \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.3675\nE : Sort ?u.3717\n\u03a9 : Type u_1\nx\u271d : MeasurableSpace \u03a9\n\u2119 : sorry\nX\u271d : \u03a9 \u2192 \u211d\ns\u271d : Set \u211d\nX : \u03a9 \u2192 E\n\u03b1\u271d : Type u_2\ns : Finset \u03b1\u271d\nhs : s.Nonempty\na\u271d : \u03b1\u271d\nt : Set \u03b1\u271d\ninst\u271d\u00b3 : Fintype \u03b1\u271d\ninst\u271d\u00b2 : Nonempty \u03b1\u271d\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Nonempty \u03b1\na : \u03b1\n\u22a2 (uniformOfFintype \u03b1) a = (\u2191(Fintype.card \u03b1))\u207b\u00b9"}, {"line": "simp [uniformOfFintype, Finset.mem_univ, if_true, uniformOfFinset_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_support_uniformOfFintype (a : \u03b1) : a \u2208 (uniformOfFintype \u03b1).support := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Distributions/Uniform.lean", "context": {"open": ["scoped Finset MeasureTheory NNReal ENNReal", "TopologicalSpace MeasureTheory.Measure PMF", "scoped Classical in", "scoped NNReal ENNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{E : Type*} [MeasurableSpace E] {\u03bc : Measure E}", "{\u03a9 : Type*}", "{_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}", "{X : \u03a9 \u2192 \u211d} {s : Set \u211d}", "{X : \u03a9 \u2192 E}", "{\u03b1 : Type*}", "{s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}", "(t : Set \u03b1)", "[Fintype \u03b1] [Nonempty \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.3675\nE : Sort ?u.3717\n\u03a9 : Type u_1\nx\u271d : MeasurableSpace \u03a9\n\u2119 : sorry\nX\u271d : \u03a9 \u2192 \u211d\ns\u271d : Set \u211d\nX : \u03a9 \u2192 E\n\u03b1\u271d : Type u_2\ns : Finset \u03b1\u271d\nhs : s.Nonempty\na\u271d : \u03b1\u271d\nt : Set \u03b1\u271d\ninst\u271d\u00b3 : Fintype \u03b1\u271d\ninst\u271d\u00b2 : Nonempty \u03b1\u271d\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Nonempty \u03b1\na : \u03b1\n\u22a2 a \u2208 (uniformOfFintype \u03b1).support"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_support_ofMultiset_iff (a : \u03b1) : a \u2208 (ofMultiset s hs).support \u2194 a \u2208 s.toFinset := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Distributions/Uniform.lean", "context": {"open": ["scoped Finset MeasureTheory NNReal ENNReal", "TopologicalSpace MeasureTheory.Measure PMF", "scoped Classical in", "scoped NNReal ENNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{E : Type*} [MeasurableSpace E] {\u03bc : Measure E}", "{\u03a9 : Type*}", "{_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}", "{X : \u03a9 \u2192 \u211d} {s : Set \u211d}", "{X : \u03a9 \u2192 E}", "{\u03b1 : Type*}", "{s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}", "(t : Set \u03b1)", "[Fintype \u03b1] [Nonempty \u03b1]", "(s : Set \u03b1)", "{s : Multiset \u03b1} (hs : s \u2260 0)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.4705\nE : Sort ?u.4747\n\u03a9 : Type u_1\nx\u271d : MeasurableSpace \u03a9\n\u2119 : sorry\nX\u271d : \u03a9 \u2192 \u211d\ns\u271d\u00b3 : Set \u211d\nX : \u03a9 \u2192 E\n\u03b1\u271d : Type u_2\ns\u271d\u00b2 : Finset \u03b1\u271d\nhs\u271d\u00b9 : s\u271d\u00b2.Nonempty\na\u271d : \u03b1\u271d\nt : Set \u03b1\u271d\ninst\u271d\u00b3 : Fintype \u03b1\u271d\ninst\u271d\u00b2 : Nonempty \u03b1\u271d\ns\u271d\u00b9 : Set \u03b1\u271d\ns\u271d : Multiset \u03b1\u271d\nhs\u271d : s\u271d \u2260 0\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Nonempty \u03b1\ns : Multiset \u03b1\nhs : s \u2260 0\na : \u03b1\n\u22a2 a \u2208 (ofMultiset s hs).support \u2194 a \u2208 sorry"}, {"line": "simp", "tactic_state": "Measure : ?m.4705\nE : Sort ?u.4747\n\u03a9 : Type u_1\nx\u271d : MeasurableSpace \u03a9\n\u2119 : sorry\nX\u271d : \u03a9 \u2192 \u211d\ns\u271d\u00b3 : Set \u211d\nX : \u03a9 \u2192 E\n\u03b1\u271d : Type u_2\ns\u271d\u00b2 : Finset \u03b1\u271d\nhs\u271d\u00b9 : s\u271d\u00b2.Nonempty\na\u271d : \u03b1\u271d\nt : Set \u03b1\u271d\ninst\u271d\u00b3 : Fintype \u03b1\u271d\ninst\u271d\u00b2 : Nonempty \u03b1\u271d\ns\u271d\u00b9 : Set \u03b1\u271d\ns\u271d : Multiset \u03b1\u271d\nhs\u271d : s\u271d \u2260 0\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Nonempty \u03b1\ns : Multiset \u03b1\nhs : s \u2260 0\na : \u03b1\n\u22a2 a \u2208 s \u2194 a \u2208 sorry ()"}]}
{"declaration": "theorem ofMultiset_apply_of_not_mem {a : \u03b1} (ha : a \u2209 s) : ofMultiset s hs a = 0 := by\n  simpa only [ofMultiset_apply,ENNReal.div_eq_zero_iff,Nat.cast_eq_zero,Multiset.count_eq_zero,ENNReal.natCast_ne_top,or_false] using ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Distributions/Uniform.lean", "context": {"open": ["scoped Finset MeasureTheory NNReal ENNReal", "TopologicalSpace MeasureTheory.Measure PMF", "scoped Classical in", "scoped NNReal ENNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{E : Type*} [MeasurableSpace E] {\u03bc : Measure E}", "{\u03a9 : Type*}", "{_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}", "{X : \u03a9 \u2192 \u211d} {s : Set \u211d}", "{X : \u03a9 \u2192 E}", "{\u03b1 : Type*}", "{s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}", "(t : Set \u03b1)", "[Fintype \u03b1] [Nonempty \u03b1]", "(s : Set \u03b1)", "{s : Multiset \u03b1} (hs : s \u2260 0)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.4705\nE : Sort ?u.4747\n\u03a9 : Type u_1\nx\u271d : MeasurableSpace \u03a9\n\u2119 : sorry\nX\u271d : \u03a9 \u2192 \u211d\ns\u271d\u00b3 : Set \u211d\nX : \u03a9 \u2192 E\n\u03b1\u271d : Type u_2\ns\u271d\u00b2 : Finset \u03b1\u271d\nhs\u271d\u00b9 : s\u271d\u00b2.Nonempty\na\u271d : \u03b1\u271d\nt : Set \u03b1\u271d\ninst\u271d\u00b3 : Fintype \u03b1\u271d\ninst\u271d\u00b2 : Nonempty \u03b1\u271d\ns\u271d\u00b9 : Set \u03b1\u271d\ns\u271d : Multiset \u03b1\u271d\nhs\u271d : s\u271d \u2260 0\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Nonempty \u03b1\ns : Multiset \u03b1\nhs : s \u2260 0\na : \u03b1\nha : a \u2209 s\n\u22a2 (ofMultiset s hs) a = 0"}, {"line": "simpa only [ofMultiset_apply,ENNReal.div_eq_zero_iff,Nat.cast_eq_zero,Multiset.count_eq_zero,ENNReal.natCast_ne_top,or_false] using ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measure_eq_zero_or_one_or_top_of_indepSet_self {t : Set \u03a9}\n    (h_indep : IndepSet t t \u03bc) : \u03bc t = 0 \u2228 \u03bc t = 1 \u2228 \u03bc t = \u221e := by\n  simpa only [ae_dirac_eq,Filter.eventually_pure]\n    using Kernel.measure_eq_zero_or_one_or_top_of_indepSet_self h_indep\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Independence/ZeroOne.lean", "context": {"open": ["MeasureTheory MeasurableSpace", "scoped MeasureTheory ENNReal"], "variables": ["{\u03b1 \u03a9 \u03b9 : Type*} {_m\u03b1 : MeasurableSpace \u03b1} {s : \u03b9 \u2192 MeasurableSpace \u03a9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_2\nx\u271d\u00b9 : Sort u_4\nIndepSet : x\u271d\u00b9\nx\u271d : Sort u_5\n\u03bc : x\u271d\nt : Set \u03a9\nh_indep : sorry\n\u22a2 sorry = 0 \u2228 sorry = 1 \u2228 sorry = \u22a4"}, {"line": "simpa only [ae_dirac_eq,Filter.eventually_pure]\n    using Kernel.measure_eq_zero_or_one_or_top_of_indepSet_self h_indep", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measure_eq_zero_or_one_of_indepSet_self [IsFiniteMeasure \u03bc] {t : Set \u03a9}\n    (h_indep : IndepSet t t \u03bc) : \u03bc t = 0 \u2228 \u03bc t = 1 := by\n  simpa only [ae_dirac_eq,Filter.eventually_pure]\n    using Kernel.measure_eq_zero_or_one_of_indepSet_self h_indep\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Independence/ZeroOne.lean", "context": {"open": ["MeasureTheory MeasurableSpace", "scoped MeasureTheory ENNReal"], "variables": ["{\u03b1 \u03a9 \u03b9 : Type*} {_m\u03b1 : MeasurableSpace \u03b1} {s : \u03b9 \u2192 MeasurableSpace \u03a9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nx\u271d : Sort u_4\nIndepSet : x\u271d\ninst\u271d : IsFiniteMeasure \u03bc\nt : Set \u03a9\nh_indep : sorry\n\u22a2 \u03bc t = 0 \u2228 \u03bc t = 1"}, {"line": "simpa only [ae_dirac_eq,Filter.eventually_pure]\n    using Kernel.measure_eq_zero_or_one_of_indepSet_self h_indep", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Kernel.indep_iSup_limsup (h_le : \u2200 n, s n \u2264 m0) (h_indep : iIndep s \u03ba \u03bc\u03b1)\n    (hf : \u2200 t, p t \u2192 t\u1d9c \u2208 f)\n    (hns : Directed (\u00b7 \u2264 \u00b7) ns) (hnsp : \u2200 a, p (ns a)) (hns_univ : \u2200 n, \u2203 a, n \u2208 ns a) :\n    Indep (\u2a06 n, s n) (limsup s f) \u03ba \u03bc\u03b1 := by\n  suffices (\u2a06 a, \u2a06 n \u2208 ns a, s n) = \u2a06 n, s n by\n    rw [\u2190 this]\n    exact indep_iSup_directed_limsup h_le h_indep hf hns hnsp\n  rw [iSup_comm]\n  refine iSup_congr fun n => ?_\n  have h : \u2a06 (i : \u03b2) (_ : n \u2208 ns i), s n = \u2a06 _ : \u2203 i, n \u2208 ns i, s n := by rw [iSup_exists]\n  haveI : Nonempty (\u2203 i : \u03b2, n \u2208 ns i) := \u27e8hns_univ n\u27e9\n  rw [h]\n  rw [iSup_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Independence/ZeroOne.lean", "context": {"open": ["MeasureTheory MeasurableSpace", "scoped MeasureTheory ENNReal", "Filter"], "variables": ["{\u03b1 \u03a9 \u03b9 : Type*} {_m\u03b1 : MeasurableSpace \u03b1} {s : \u03b9 \u2192 MeasurableSpace \u03a9}", "{\u03b2 : Type*} {p : Set \u03b9 \u2192 Prop} {f : Filter \u03b9} {ns : \u03b2 \u2192 Set \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_2\n\u03b9 : Type u_3\ns : \u03b9 \u2192 MeasurableSpace \u03a9\n\u03b2 : Type u_4\np : Set \u03b9 \u2192 Prop\nf : Filter \u03b9\nns : \u03b2 \u2192 Set \u03b9\nm0 : MeasurableSpace \u03a9\nx\u271d\u00b9 : Sort u_5\niIndep : x\u271d\u00b9\nx\u271d : Sort u_6\nIndep : x\u271d\nh_le : \u2200 (n : \u03b9), s n \u2264 m0\nh_indep : sorry\nhf : \u2200 (t : Set \u03b9), p t \u2192 t\u1d9c \u2208 f\nhns : Directed (fun x1 x2 => x1 \u2264 x2) ns\nhnsp : \u2200 (a : \u03b2), p (ns a)\nhns_univ : \u2200 (n : \u03b9), \u2203 a, n \u2208 ns a\n\u22a2 sorry"}, {"line": "suffices (\u2a06 a, \u2a06 n \u2208 ns a, s n) = \u2a06 n, s n by\n    rw [\u2190 this]\n    exact indep_iSup_directed_limsup h_le h_indep hf hns hnsp", "tactic_state": "\u03a9 : Type u_2\n\u03b9 : Type u_3\ns : \u03b9 \u2192 MeasurableSpace \u03a9\n\u03b2 : Type u_4\np : Set \u03b9 \u2192 Prop\nf : Filter \u03b9\nns : \u03b2 \u2192 Set \u03b9\nm0 : MeasurableSpace \u03a9\nx\u271d\u00b9 : Sort u_5\niIndep : x\u271d\u00b9\nx\u271d : Sort u_6\nIndep : x\u271d\nh_le : \u2200 (n : \u03b9), s n \u2264 m0\nh_indep : sorry\nhf : \u2200 (t : Set \u03b9), p t \u2192 t\u1d9c \u2208 f\nhns : Directed (fun x1 x2 => x1 \u2264 x2) ns\nhnsp : \u2200 (a : \u03b2), p (ns a)\nhns_univ : \u2200 (n : \u03b9), \u2203 a, n \u2208 ns a\n\u22a2 \u2a06 a, \u2a06 n \u2208 ns a, s n = \u2a06 n, s n"}, {"line": "rw [iSup_comm]", "tactic_state": "\u03a9 : Type u_2\n\u03b9 : Type u_3\ns : \u03b9 \u2192 MeasurableSpace \u03a9\n\u03b2 : Type u_4\np : Set \u03b9 \u2192 Prop\nf : Filter \u03b9\nns : \u03b2 \u2192 Set \u03b9\nm0 : MeasurableSpace \u03a9\nx\u271d\u00b9 : Sort u_5\niIndep : x\u271d\u00b9\nx\u271d : Sort u_6\nIndep : x\u271d\nh_le : \u2200 (n : \u03b9), s n \u2264 m0\nh_indep : sorry\nhf : \u2200 (t : Set \u03b9), p t \u2192 t\u1d9c \u2208 f\nhns : Directed (fun x1 x2 => x1 \u2264 x2) ns\nhnsp : \u2200 (a : \u03b2), p (ns a)\nhns_univ : \u2200 (n : \u03b9), \u2203 a, n \u2208 ns a\n\u22a2 \u2a06 j, \u2a06 i, \u2a06 (_ : j \u2208 ns i), s j = \u2a06 n, s n"}, {"line": "refine iSup_congr fun n => ?_", "tactic_state": "\u03a9 : Type u_2\n\u03b9 : Type u_3\ns : \u03b9 \u2192 MeasurableSpace \u03a9\n\u03b2 : Type u_4\np : Set \u03b9 \u2192 Prop\nf : Filter \u03b9\nns : \u03b2 \u2192 Set \u03b9\nm0 : MeasurableSpace \u03a9\nx\u271d\u00b9 : Sort u_5\niIndep : x\u271d\u00b9\nx\u271d : Sort u_6\nIndep : x\u271d\nh_le : \u2200 (n : \u03b9), s n \u2264 m0\nh_indep : sorry\nhf : \u2200 (t : Set \u03b9), p t \u2192 t\u1d9c \u2208 f\nhns : Directed (fun x1 x2 => x1 \u2264 x2) ns\nhnsp : \u2200 (a : \u03b2), p (ns a)\nhns_univ : \u2200 (n : \u03b9), \u2203 a, n \u2208 ns a\nn : \u03b9\n\u22a2 \u2a06 i, \u2a06 (_ : n \u2208 ns i), s n = s n"}, {"line": "have h : \u2a06 (i : \u03b2) (_ : n \u2208 ns i), s n = \u2a06 _ : \u2203 i, n \u2208 ns i, s n := by rw [iSup_exists]", "tactic_state": "\u03a9 : Type u_2\n\u03b9 : Type u_3\ns : \u03b9 \u2192 MeasurableSpace \u03a9\n\u03b2 : Type u_4\np : Set \u03b9 \u2192 Prop\nf : Filter \u03b9\nns : \u03b2 \u2192 Set \u03b9\nm0 : MeasurableSpace \u03a9\nx\u271d\u00b9 : Sort u_5\niIndep : x\u271d\u00b9\nx\u271d : Sort u_6\nIndep : x\u271d\nh_le : \u2200 (n : \u03b9), s n \u2264 m0\nh_indep : sorry\nhf : \u2200 (t : Set \u03b9), p t \u2192 t\u1d9c \u2208 f\nhns : Directed (fun x1 x2 => x1 \u2264 x2) ns\nhnsp : \u2200 (a : \u03b2), p (ns a)\nhns_univ : \u2200 (n : \u03b9), \u2203 a, n \u2208 ns a\nn : \u03b9\nh : \u2a06 i, \u2a06 (_ : n \u2208 ns i), s n = \u2a06 (_ : \u2203 i, n \u2208 ns i), s n\n\u22a2 \u2a06 i, \u2a06 (_ : n \u2208 ns i), s n = s n"}, {"line": "haveI : Nonempty (\u2203 i : \u03b2, n \u2208 ns i) := \u27e8hns_univ n\u27e9", "tactic_state": "\u03a9 : Type u_2\n\u03b9 : Type u_3\ns : \u03b9 \u2192 MeasurableSpace \u03a9\n\u03b2 : Type u_4\np : Set \u03b9 \u2192 Prop\nf : Filter \u03b9\nns : \u03b2 \u2192 Set \u03b9\nm0 : MeasurableSpace \u03a9\nx\u271d\u00b9 : Sort u_5\niIndep : x\u271d\u00b9\nx\u271d : Sort u_6\nIndep : x\u271d\nh_le : \u2200 (n : \u03b9), s n \u2264 m0\nh_indep : sorry\nhf : \u2200 (t : Set \u03b9), p t \u2192 t\u1d9c \u2208 f\nhns : Directed (fun x1 x2 => x1 \u2264 x2) ns\nhnsp : \u2200 (a : \u03b2), p (ns a)\nhns_univ : \u2200 (n : \u03b9), \u2203 a, n \u2208 ns a\nn : \u03b9\nh : \u2a06 i, \u2a06 (_ : n \u2208 ns i), s n = \u2a06 (_ : \u2203 i, n \u2208 ns i), s n\nthis : Nonempty (\u2203 i, n \u2208 ns i)\n\u22a2 \u2a06 i, \u2a06 (_ : n \u2208 ns i), s n = s n"}, {"line": "rw [h]", "tactic_state": "\u03a9 : Type u_2\n\u03b9 : Type u_3\ns : \u03b9 \u2192 MeasurableSpace \u03a9\n\u03b2 : Type u_4\np : Set \u03b9 \u2192 Prop\nf : Filter \u03b9\nns : \u03b2 \u2192 Set \u03b9\nm0 : MeasurableSpace \u03a9\nx\u271d\u00b9 : Sort u_5\niIndep : x\u271d\u00b9\nx\u271d : Sort u_6\nIndep : x\u271d\nh_le : \u2200 (n : \u03b9), s n \u2264 m0\nh_indep : sorry\nhf : \u2200 (t : Set \u03b9), p t \u2192 t\u1d9c \u2208 f\nhns : Directed (fun x1 x2 => x1 \u2264 x2) ns\nhnsp : \u2200 (a : \u03b2), p (ns a)\nhns_univ : \u2200 (n : \u03b9), \u2203 a, n \u2208 ns a\nn : \u03b9\nh : \u2a06 i, \u2a06 (_ : n \u2208 ns i), s n = \u2a06 (_ : \u2203 i, n \u2208 ns i), s n\nthis : Nonempty (\u2203 i, n \u2208 ns i)\n\u22a2 \u2a06 (_ : \u2203 i, n \u2208 ns i), s n = s n"}, {"line": "rw [iSup_const]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measure_zero_or_one_of_measurableSet_limsup_atTop\n    (h_le : \u2200 n, s n \u2264 m0)\n    (h_indep : iIndep s \u03bc) {t : Set \u03a9} (ht_tail : MeasurableSet[limsup s atTop] t) :\n    \u03bc t = 0 \u2228 \u03bc t = 1 := by\n  simpa only [ae_dirac_eq,Filter.eventually_pure]\n    using Kernel.measure_zero_or_one_of_measurableSet_limsup_atTop h_le h_indep ht_tail\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Independence/ZeroOne.lean", "context": {"open": ["MeasureTheory MeasurableSpace", "scoped MeasureTheory ENNReal", "Filter"], "variables": ["{\u03b1 \u03a9 \u03b9 : Type*} {_m\u03b1 : MeasurableSpace \u03b1} {s : \u03b9 \u2192 MeasurableSpace \u03a9}", "{\u03b2 : Type*} {p : Set \u03b9 \u2192 Prop} {f : Filter \u03b9} {ns : \u03b2 \u2192 Set \u03b9}", "[SemilatticeSup \u03b9] [NoMaxOrder \u03b9] [Nonempty \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_2\n\u03b9 : Type u_3\ns : \u03b9 \u2192 MeasurableSpace \u03a9\ninst\u271d\u00b2 : SemilatticeSup \u03b9\ninst\u271d\u00b9 : NoMaxOrder \u03b9\ninst\u271d : Nonempty \u03b9\nm0 : MeasurableSpace \u03a9\nx\u271d\u00b9 : Sort u_5\niIndep : x\u271d\u00b9\nx\u271d : Sort u_6\n\u03bc : x\u271d\nh_le : \u2200 (n : \u03b9), s n \u2264 m0\nh_indep : sorry\nt : Set \u03a9\nht_tail : MeasurableSet t\n\u22a2 sorry = 0 \u2228 sorry = 1"}, {"line": "simpa only [ae_dirac_eq,Filter.eventually_pure]\n    using Kernel.measure_zero_or_one_of_measurableSet_limsup_atTop h_le h_indep ht_tail", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measure_zero_or_one_of_measurableSet_limsup_atBot\n    (h_le : \u2200 n, s n \u2264 m0) (h_indep : iIndep s \u03bc) {t : Set \u03a9}\n    (ht_tail : MeasurableSet[limsup s atBot] t) :\n    \u03bc t = 0 \u2228 \u03bc t = 1 := by\n  simpa only [ae_dirac_eq,Filter.eventually_pure]\n    using Kernel.measure_zero_or_one_of_measurableSet_limsup_atBot h_le h_indep ht_tail\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Independence/ZeroOne.lean", "context": {"open": ["MeasureTheory MeasurableSpace", "scoped MeasureTheory ENNReal", "Filter"], "variables": ["{\u03b1 \u03a9 \u03b9 : Type*} {_m\u03b1 : MeasurableSpace \u03b1} {s : \u03b9 \u2192 MeasurableSpace \u03a9}", "{\u03b2 : Type*} {p : Set \u03b9 \u2192 Prop} {f : Filter \u03b9} {ns : \u03b2 \u2192 Set \u03b9}", "[SemilatticeSup \u03b9] [NoMaxOrder \u03b9] [Nonempty \u03b9]", "[SemilatticeInf \u03b9] [NoMinOrder \u03b9] [Nonempty \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_2\n\u03b9 : Type u_3\ns : \u03b9 \u2192 MeasurableSpace \u03a9\ninst\u271d\u2075 : SemilatticeSup \u03b9\ninst\u271d\u2074 : NoMaxOrder \u03b9\ninst\u271d\u00b3 : Nonempty \u03b9\ninst\u271d\u00b2 : SemilatticeInf \u03b9\ninst\u271d\u00b9 : NoMinOrder \u03b9\ninst\u271d : Nonempty \u03b9\nm0 : MeasurableSpace \u03a9\nx\u271d\u00b9 : Sort u_5\niIndep : x\u271d\u00b9\nx\u271d : Sort u_6\n\u03bc : x\u271d\nh_le : \u2200 (n : \u03b9), s n \u2264 m0\nh_indep : sorry\nt : Set \u03a9\nht_tail : MeasurableSet t\n\u22a2 sorry = 0 \u2228 sorry = 1"}, {"line": "simpa only [ae_dirac_eq,Filter.eventually_pure]\n    using Kernel.measure_zero_or_one_of_measurableSet_limsup_atBot h_le h_indep ht_tail", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IndepSet.measure_inter_eq_mul {\u03bc : Measure \u03a9} (h : IndepSet s t \u03bc) :\n    \u03bc (s \u2229 t) = \u03bc s * \u03bc t := by\n  simpa using Kernel.IndepSet.measure_inter_eq_mul _ _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Independence/Basic.lean", "context": {"open": ["MeasureTheory MeasurableSpace Set", "scoped MeasureTheory ENNReal"], "variables": ["{\u03a9 \u03b9 \u03b2 \u03b3 : Type*} {\u03ba : \u03b9 \u2192 Type*}", "{\u03c0 : \u03b9 \u2192 Set (Set \u03a9)} {m : \u03b9 \u2192 MeasurableSpace \u03a9} {_ : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}", "{m\u2081 m\u2082 m\u2083 : MeasurableSpace \u03a9} (m' : MeasurableSpace \u03a9)", "{m : \u03b9 \u2192 MeasurableSpace \u03a9} {_m\u03a9 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}", "{m : \u03b9 \u2192 MeasurableSpace \u03a9} {_m\u03a9 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}", "{m : \u03b9 \u2192 MeasurableSpace \u03a9} {m1 m2 _m\u03a9 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}", "{m\u2081 m\u2082 _m\u03a9 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9} {s t : Set \u03a9} (S T : Set (Set \u03a9))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\n_m\u03a9 : MeasurableSpace \u03a9\ns t : Set \u03a9\nx\u271d : Sort u_6\nIndepSet : x\u271d\n\u03bc : Measure \u03a9\nh : sorry\n\u22a2 \u03bc (s \u2229 t) = \u03bc s * \u03bc t"}, {"line": "simpa using Kernel.IndepSet.measure_inter_eq_mul _ _ h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iIndepSet.meas_biInter {f : \u03b9 \u2192 Set \u03a9} (h : iIndepSet f \u03bc) (s : Finset \u03b9) :\n    \u03bc (\u22c2 i \u2208 s, f i) = \u220f i \u2208 s, \u03bc (f i) := by\n  simpa using Kernel.iIndepSet.meas_biInter h s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Independence/Basic.lean", "context": {"open": ["MeasureTheory MeasurableSpace Set", "scoped MeasureTheory ENNReal"], "variables": ["{\u03a9 \u03b9 \u03b2 \u03b3 : Type*} {\u03ba : \u03b9 \u2192 Type*}", "{\u03c0 : \u03b9 \u2192 Set (Set \u03a9)} {m : \u03b9 \u2192 MeasurableSpace \u03a9} {_ : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}", "{m\u2081 m\u2082 m\u2083 : MeasurableSpace \u03a9} (m' : MeasurableSpace \u03a9)", "{m : \u03b9 \u2192 MeasurableSpace \u03a9} {_m\u03a9 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}", "{m : \u03b9 \u2192 MeasurableSpace \u03a9} {_m\u03a9 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}", "{m : \u03b9 \u2192 MeasurableSpace \u03a9} {m1 m2 _m\u03a9 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}", "{m\u2081 m\u2082 _m\u03a9 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9} {s t : Set \u03a9} (S T : Set (Set \u03a9))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\n\u03b9 : Type u_2\n_m\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nx\u271d : Sort u_6\niIndepSet : x\u271d\nf : \u03b9 \u2192 Set \u03a9\nh : sorry\ns : Finset \u03b9\n\u22a2 \u03bc (\u22c2 i \u2208 s, f i) = \u220f i \u2208 s, \u03bc (f i)"}, {"line": "simpa using Kernel.iIndepSet.meas_biInter h s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IndepFun.congr {m\u03b2 : MeasurableSpace \u03b2} {m\u03b2' : MeasurableSpace \u03b2'}\n    {f' : \u03a9 \u2192 \u03b2} {g' : \u03a9 \u2192 \u03b2'} (hfg : IndepFun f g \u03bc)\n    (hf : f =\u1d50[\u03bc] f') (hg : g =\u1d50[\u03bc] g') : IndepFun f' g' \u03bc := by\n  refine Kernel.IndepFun.congr' hfg ?_ ?_ <;> simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Independence/Basic.lean", "context": {"open": ["MeasureTheory MeasurableSpace Set", "scoped MeasureTheory ENNReal"], "variables": ["{\u03a9 \u03b9 \u03b2 \u03b3 : Type*} {\u03ba : \u03b9 \u2192 Type*}", "{\u03c0 : \u03b9 \u2192 Set (Set \u03a9)} {m : \u03b9 \u2192 MeasurableSpace \u03a9} {_ : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}", "{m\u2081 m\u2082 m\u2083 : MeasurableSpace \u03a9} (m' : MeasurableSpace \u03a9)", "{m : \u03b9 \u2192 MeasurableSpace \u03a9} {_m\u03a9 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}", "{m : \u03b9 \u2192 MeasurableSpace \u03a9} {_m\u03a9 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}", "{m : \u03b9 \u2192 MeasurableSpace \u03a9} {m1 m2 _m\u03a9 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}", "{m\u2081 m\u2082 _m\u03a9 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9} {s t : Set \u03a9} (S T : Set (Set \u03a9))", "{\u03b2 \u03b2' \u03b3 \u03b3' : Type*} {_m\u03a9 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9} {f : \u03a9 \u2192 \u03b2} {g : \u03a9 \u2192 \u03b2'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\n\u03b2 : Type u_6\n\u03b2' : Type u_7\n_m\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nf : \u03a9 \u2192 \u03b2\ng : \u03a9 \u2192 \u03b2'\nx\u271d : Sort u_10\nIndepFun : x\u271d\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b2' : MeasurableSpace \u03b2'\nf' : \u03a9 \u2192 \u03b2\ng' : \u03a9 \u2192 \u03b2'\nhfg : sorry\nhf : f =\u1da0[ae \u03bc] f'\nhg : g =\u1da0[ae \u03bc] g'\n\u22a2 sorry"}, {"line": "refine Kernel.IndepFun.congr' hfg ?_ ?_ <;> simpa", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iIndepFun.indepFun_mul_left (hf_indep : iIndepFun f \u03ba \u03bc)\n    (hf_meas : \u2200 i, Measurable (f i)) (i j k : \u03b9) (hik : i \u2260 k) (hjk : j \u2260 k) :\n    IndepFun (f i * f j) (f k) \u03ba \u03bc := by\n  have : IndepFun (fun \u03c9 => (f i \u03c9, f j \u03c9)) (f k) \u03ba \u03bc :=\n    hf_indep.indepFun_prodMk hf_meas i j k hik hjk\n  simpa using this.comp (measurable_fst.mul measurable_snd) measurable_id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Independence/Kernel.lean", "context": {"open": ["Set MeasureTheory MeasurableSpace", "scoped MeasureTheory ENNReal", "Finset in"], "variables": ["{\u03b1 \u03a9 \u03b9 : Type*}", "{_m\u03b1 : MeasurableSpace \u03b1}", "{\u03b2 : \u03b9 \u2192 Type*} {m\u03b2 : \u2200 i, MeasurableSpace (\u03b2 i)}", "{_m\u03b1 : MeasurableSpace \u03b1}", "{_m\u03b1 : MeasurableSpace \u03b1}", "{_m\u03b1 : MeasurableSpace \u03b1}", "{_m\u03b1 : MeasurableSpace \u03b1}", "{_m\u03a9 : MeasurableSpace \u03a9} {\u03ba : Kernel \u03b1 \u03a9} {\u03bc : Measure \u03b1}", "{_m\u03b1 : MeasurableSpace \u03b1}", "{s t : Set \u03a9} (S T : Set (Set \u03a9))", "{\u03b2 \u03b2' \u03b3 \u03b3' : Type*} {_m\u03b1 : MeasurableSpace \u03b1} {_m\u03a9 : MeasurableSpace \u03a9}", "{\u03b2 : \u03b9 \u2192 Type*} {m : \u2200 i, MeasurableSpace (\u03b2 i)} {f : \u2200 i, \u03a9 \u2192 \u03b2 i}", "{\u03b2 : Type*} {m : MeasurableSpace \u03b2} [Mul \u03b2] [MeasurableMul\u2082 \u03b2] {f : \u03b9 \u2192 \u03a9 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.3706\n\u03b9\u271d : Sort u_12\n\u03a9\u271d : Type u_11\nKernel : ?m.3703\n_m\u03b1\u271d\u2075 : MeasurableSpace \u03b1\n\u03b2\u271d\u00b3 : \u03b9\u271d \u2192 Type u_1\nm\u03b2 : (i : \u03b9\u271d) \u2192 MeasurableSpace (\u03b2\u271d\u00b3 i)\n_m\u03b1\u271d\u2074 _m\u03b1\u271d\u00b3 _m\u03b1\u271d\u00b2 _m\u03b1\u271d\u00b9 : MeasurableSpace \u03b1\n_m\u03a9\u271d\u00b9 : MeasurableSpace \u03a9\u271d\n\u03ba : sorry\n\u03bc : Measure \u03b1\n_m\u03b1\u271d : MeasurableSpace \u03b1\ns t : Set \u03a9\u271d\nS T : Set (Set \u03a9\u271d)\n\u03b2\u271d\u00b2 : Type u_2\n\u03b2' : Type u_3\n\u03b3 : Type u_4\n\u03b3' : Type u_5\n_m\u03b1 : MeasurableSpace \u03b1\n_m\u03a9\u271d : MeasurableSpace \u03a9\u271d\n\u03b2\u271d\u00b9 : \u03b9\u271d \u2192 Type u_6\nm\u271d\u00b9 : (i : \u03b9\u271d) \u2192 MeasurableSpace (\u03b2\u271d\u00b9 i)\nf\u271d\u00b9 : (i : \u03b9\u271d) \u2192 \u03a9\u271d \u2192 \u03b2\u271d\u00b9 i\n\u03b2\u271d : Type u_7\nm\u271d : MeasurableSpace \u03b2\u271d\ninst\u271d\u00b3 : Mul \u03b2\u271d\ninst\u271d\u00b2 : MeasurableMul\u2082 \u03b2\u271d\nf\u271d : \u03b9\u271d \u2192 \u03a9\u271d \u2192 \u03b2\u271d\n\u03b9 : Sort u_12\n\u03a9 : Type u_11\n_m\u03a9 : MeasurableSpace \u03a9\n\u03b2 : Type u_7\nm : MeasurableSpace \u03b2\ninst\u271d\u00b9 : Mul \u03b2\ninst\u271d : MeasurableMul\u2082 \u03b2\nf : \u03b9 \u2192 \u03a9 \u2192 \u03b2\nx\u271d\u00b9 : Sort u_8\niIndepFun : x\u271d\u00b9\nx\u271d : Sort u_9\nIndepFun : x\u271d\nhf_indep : sorry\nhf_meas : \u2200 (i : \u03b9), Measurable (f i)\ni j k : \u03b9\nhik : i \u2260 k\nhjk : j \u2260 k\n\u22a2 sorry"}, {"line": "have : IndepFun (fun \u03c9 => (f i \u03c9, f j \u03c9)) (f k) \u03ba \u03bc :=\n    hf_indep.indepFun_prodMk hf_meas i j k hik hjk", "tactic_state": "\u03b1 : Type ?u.3706\n\u03b9\u271d : Sort u_12\n\u03a9\u271d : Type u_11\nKernel : ?m.3703\n_m\u03b1\u271d\u2075 : MeasurableSpace \u03b1\n\u03b2\u271d\u00b3 : \u03b9\u271d \u2192 Type u_1\nm\u03b2 : (i : \u03b9\u271d) \u2192 MeasurableSpace (\u03b2\u271d\u00b3 i)\n_m\u03b1\u271d\u2074 _m\u03b1\u271d\u00b3 _m\u03b1\u271d\u00b2 _m\u03b1\u271d\u00b9 : MeasurableSpace \u03b1\n_m\u03a9\u271d\u00b9 : MeasurableSpace \u03a9\u271d\n\u03ba : sorry\n\u03bc : Measure \u03b1\n_m\u03b1\u271d : MeasurableSpace \u03b1\ns t : Set \u03a9\u271d\nS T : Set (Set \u03a9\u271d)\n\u03b2\u271d\u00b2 : Type u_2\n\u03b2' : Type u_3\n\u03b3 : Type u_4\n\u03b3' : Type u_5\n_m\u03b1 : MeasurableSpace \u03b1\n_m\u03a9\u271d : MeasurableSpace \u03a9\u271d\n\u03b2\u271d\u00b9 : \u03b9\u271d \u2192 Type u_6\nm\u271d\u00b9 : (i : \u03b9\u271d) \u2192 MeasurableSpace (\u03b2\u271d\u00b9 i)\nf\u271d\u00b9 : (i : \u03b9\u271d) \u2192 \u03a9\u271d \u2192 \u03b2\u271d\u00b9 i\n\u03b2\u271d : Type u_7\nm\u271d : MeasurableSpace \u03b2\u271d\ninst\u271d\u00b3 : Mul \u03b2\u271d\ninst\u271d\u00b2 : MeasurableMul\u2082 \u03b2\u271d\nf\u271d : \u03b9\u271d \u2192 \u03a9\u271d \u2192 \u03b2\u271d\n\u03b9 : Sort u_12\n\u03a9 : Type u_11\n_m\u03a9 : MeasurableSpace \u03a9\n\u03b2 : Type u_7\nm : MeasurableSpace \u03b2\ninst\u271d\u00b9 : Mul \u03b2\ninst\u271d : MeasurableMul\u2082 \u03b2\nf : \u03b9 \u2192 \u03a9 \u2192 \u03b2\nx\u271d\u00b9 : Sort u_8\niIndepFun : x\u271d\u00b9\nx\u271d : Sort u_9\nIndepFun : x\u271d\nhf_indep : sorry\nhf_meas : \u2200 (i : \u03b9), Measurable (f i)\ni j k : \u03b9\nhik : i \u2260 k\nhjk : j \u2260 k\nthis : sorry\n\u22a2 sorry"}, {"line": "simpa using this.comp (measurable_fst.mul measurable_snd) measurable_id", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Measurable.lintegral_kernel_prod_right' {f : \u03b1 \u00d7 \u03b2 \u2192 \u211d\u22650\u221e} (hf : Measurable f) :\n    Measurable fun a => \u222b\u207b b, f (a, b) \u2202\u03ba a := by fun_prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/MeasurableLIntegral.lean", "context": {"open": ["MeasureTheory ProbabilityTheory Function Set Filter", "scoped MeasureTheory ENNReal Topology", "ProbabilityTheory.Kernel"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {m\u03b3 : MeasurableSpace \u03b3}", "[IsSFiniteKernel \u03ba] [IsSFiniteKernel \u03b7]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03ba\u271d : Kernel ?m.202 ?m.203\n\u03b7 : Kernel ?m.218 ?m.219\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\nm\u03b1\u271d : MeasurableSpace \u03b1\u271d\nm\u03b2\u271d : MeasurableSpace \u03b2\u271d\nm\u03b3 : MeasurableSpace \u03b3\ninst\u271d\u00b2 : IsSFiniteKernel \u03ba\u271d\ninst\u271d\u00b9 : IsSFiniteKernel \u03b7\nx\u271d\u00b3 : Type u_4\nx\u271d\u00b2 : Type u_5\nx\u271d\u00b9 : MeasurableSpace x\u271d\u00b3\nx\u271d : MeasurableSpace x\u271d\u00b2\n\u03ba : Kernel x\u271d\u00b3 x\u271d\u00b2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\ninst\u271d : IsSFiniteKernel \u03ba\nf : \u03b1 \u00d7 \u03b2 \u2192 ENNReal\nhf : Measurable f\n\u22a2 Measurable fun a => \u222b\u207b (b : x\u271d\u00b2), f (sorry, sorry) \u2202\u03ba a"}, {"line": "fun_prop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Measurable.lintegral_kernel_prod_left' {f : \u03b2 \u00d7 \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) :\n    Measurable fun y => \u222b\u207b x, f (x, y) \u2202\u03ba y := by fun_prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/MeasurableLIntegral.lean", "context": {"open": ["MeasureTheory ProbabilityTheory Function Set Filter", "scoped MeasureTheory ENNReal Topology", "ProbabilityTheory.Kernel"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {m\u03b3 : MeasurableSpace \u03b3}", "[IsSFiniteKernel \u03ba] [IsSFiniteKernel \u03b7]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03ba\u271d : Kernel ?m.202 ?m.203\n\u03b7 : Kernel ?m.218 ?m.219\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\nm\u03b1\u271d : MeasurableSpace \u03b1\u271d\nm\u03b2\u271d : MeasurableSpace \u03b2\u271d\nm\u03b3 : MeasurableSpace \u03b3\ninst\u271d\u00b2 : IsSFiniteKernel \u03ba\u271d\ninst\u271d\u00b9 : IsSFiniteKernel \u03b7\nx\u271d\u00b3 : Type u_4\nx\u271d\u00b2 : Type u_5\nx\u271d\u00b9 : MeasurableSpace x\u271d\u00b3\nx\u271d : MeasurableSpace x\u271d\u00b2\n\u03ba : Kernel x\u271d\u00b3 x\u271d\u00b2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\ninst\u271d : IsSFiniteKernel \u03ba\nf : \u03b2 \u00d7 \u03b1 \u2192 ENNReal\nhf : Measurable f\n\u22a2 Measurable fun y => \u222b\u207b (x : x\u271d\u00b2), f (sorry, sorry) \u2202\u03ba y"}, {"line": "fun_prop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Measurable.lintegral_kernel_prod_left {f : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : Measurable (uncurry f)) : Measurable fun y => \u222b\u207b x, f x y \u2202\u03ba y := by fun_prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/MeasurableLIntegral.lean", "context": {"open": ["MeasureTheory ProbabilityTheory Function Set Filter", "scoped MeasureTheory ENNReal Topology", "ProbabilityTheory.Kernel"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {m\u03b3 : MeasurableSpace \u03b3}", "[IsSFiniteKernel \u03ba] [IsSFiniteKernel \u03b7]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03ba\u271d : Kernel ?m.202 ?m.203\n\u03b7 : Kernel ?m.218 ?m.219\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\nm\u03b1\u271d : MeasurableSpace \u03b1\u271d\nm\u03b2\u271d : MeasurableSpace \u03b2\u271d\nm\u03b3 : MeasurableSpace \u03b3\ninst\u271d\u00b2 : IsSFiniteKernel \u03ba\u271d\ninst\u271d\u00b9 : IsSFiniteKernel \u03b7\nx\u271d\u00b3 : Type u_4\nx\u271d\u00b2 : Type u_5\nx\u271d\u00b9 : MeasurableSpace x\u271d\u00b3\nx\u271d : MeasurableSpace x\u271d\u00b2\n\u03ba : Kernel x\u271d\u00b3 x\u271d\u00b2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\ninst\u271d : IsSFiniteKernel \u03ba\nf : \u03b2 \u2192 \u03b1 \u2192 ENNReal\nhf : Measurable (uncurry f)\n\u22a2 Measurable fun y => \u222b\u207b (x : x\u271d\u00b2), f sorry sorry \u2202\u03ba y"}, {"line": "fun_prop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Measurable.lintegral_kernel {\u03ba : Kernel \u03b1 \u03b2} {f : \u03b2 \u2192 \u211d\u22650\u221e} (hf : Measurable f) :\n    Measurable fun a => \u222b\u207b b, f b \u2202\u03ba a := by fun_prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/MeasurableLIntegral.lean", "context": {"open": ["MeasureTheory ProbabilityTheory Function Set Filter", "scoped MeasureTheory ENNReal Topology", "ProbabilityTheory.Kernel"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {m\u03b3 : MeasurableSpace \u03b3}", "[IsSFiniteKernel \u03ba] [IsSFiniteKernel \u03b7]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03ba\u271d : Kernel ?m.202 ?m.203\n\u03b7 : Kernel ?m.218 ?m.219\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\nm\u03b1\u271d : MeasurableSpace \u03b1\u271d\nm\u03b2\u271d : MeasurableSpace \u03b2\u271d\nm\u03b3 : MeasurableSpace \u03b3\ninst\u271d\u00b9 : IsSFiniteKernel \u03ba\u271d\ninst\u271d : IsSFiniteKernel \u03b7\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1 \u03b2\nf : \u03b2 \u2192 ENNReal\nhf : Measurable f\n\u22a2 Measurable fun a => \u222b\u207b (b : \u03b2), f b \u2202\u03ba a"}, {"line": "fun_prop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isProper_iff_restrict_eq_indicator_smul (h\ud835\udcd1\ud835\udce7 : \ud835\udcd1 \u2264 \ud835\udce7) :\n    IsProper \u03c0 \u2194 \u2200 \u2983B : Set X\u2984 (hB : MeasurableSet[\ud835\udcd1] B) (x : X),\n      \u03c0.restrict (h\ud835\udcd1\ud835\udce7 _ hB) x = B.indicator (fun _ \u21a6 (1 : \u211d\u22650\u221e)) x \u2022 \u03c0 x := by\n  refine \u27e8fun \u27e8h\u27e9 \u21a6 ?_, fun h \u21a6 \u27e8?_\u27e9\u27e9 <;> simpa only [inf_eq_left.2 h\ud835\udcd1\ud835\udce7] using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Proper.lean", "context": {"open": ["MeasureTheory ENNReal NNReal Set", "scoped ProbabilityTheory"], "variables": ["{X : Type*} {\ud835\udcd1 \ud835\udce7 : MeasurableSpace X} {\u03c0 : Kernel[\ud835\udcd1, \ud835\udce7] X X} {A B : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\ud835\udcd1 \ud835\udce7 : MeasurableSpace X\n\u03c0 : ProbabilityTheory.Kernel X X\nx\u271d : Sort u_2\nIsProper : x\u271d\nh\ud835\udcd1\ud835\udce7 : \ud835\udcd1 \u2264 \ud835\udce7\n\u22a2 sorry \u2194 \u2200 \u2983B : Set X\u2984 (hB : MeasurableSet B) (x : X), (\u03c0.restrict \u22ef) x = B.indicator (fun x => 1) x \u2022 \u03c0 x"}, {"line": "refine \u27e8fun \u27e8h\u27e9 \u21a6 ?_, fun h \u21a6 \u27e8?_\u27e9\u27e9 <;> simpa only [inf_eq_left.2 h\ud835\udcd1\ud835\udce7] using h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma copy_apply (a : \u03b1) : copy \u03b1 a = Measure.dirac (a, a) := by simp [copy, deterministic_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Basic.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal"], "variables": ["{\u03b1 \u03b2 \u03b9 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {\u03ba : Kernel \u03b1 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Kernel : ?m.460\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nm\u03b1\u271d : MeasurableSpace \u03b1\u271d\nm\u03b2 : MeasurableSpace \u03b2\n\u03ba : sorry\n\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\nx\u271d : Sort u_4\ncopy : x\u271d\na : \u03b1\n\u22a2 sorry = Measure.dirac (a, a)"}, {"line": "simp [copy, deterministic_apply]", "tactic_state": "Kernel : ?m.460\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nm\u03b1\u271d : MeasurableSpace \u03b1\u271d\nm\u03b2 : MeasurableSpace \u03b2\n\u03ba : sorry\n\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\nx\u271d : Sort u_4\ncopy : x\u271d\na : \u03b1\n\u22a2 sorry () = Measure.dirac (a, a)"}]}
{"declaration": "lemma not_mem_mutuallySingularSetSlice (\u03ba \u03b7 : Kernel \u03b1 \u03b3) (a : \u03b1) (x : \u03b3) :\n    x \u2209 mutuallySingularSetSlice \u03ba \u03b7 a \u2194 rnDerivAux \u03ba (\u03ba + \u03b7) a x < 1 := by\n  simp [mutuallySingularSetSlice]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/RadonNikodym.lean", "context": {"open": ["MeasureTheory Set Filter ENNReal", "scoped NNReal MeasureTheory Topology ProbabilityTheory", "Classical in"], "variables": ["{\u03b1 \u03b3 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b3 : MeasurableSpace \u03b3} {\u03ba \u03b7 : Kernel \u03b1 \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_1\nKernel : x\u271d\u00b2\n\u03b1 : Sort u_2\n\u03b3 : Type u_3\nx\u271d\u00b9 : Sort u_4\nmutuallySingularSetSlice : x\u271d\u00b9\nx\u271d : Sort u_5\nrnDerivAux : x\u271d\n\u03ba : sorry\n\u03b7 : sorry\na : \u03b1\nx : \u03b3\n\u22a2 x \u2209 sorry \u2194 sorry < 1"}, {"line": "simp [mutuallySingularSetSlice]", "tactic_state": "x\u271d\u00b2 : Sort u_1\nKernel : x\u271d\u00b2\n\u03b1 : Sort u_2\n\u03b3 : Type u_3\nx\u271d\u00b9 : Sort u_4\nmutuallySingularSetSlice : x\u271d\u00b9\nx\u271d : Sort u_5\nrnDerivAux : x\u271d\n\u03ba : sorry\n\u03b7 : sorry\na : \u03b1\nx : \u03b3\n\u22a2 x \u2209 sorry () \u2194 sorry () = 0"}]}
{"declaration": "theorem map_of_not_measurable (\u03ba : Kernel \u03b1 \u03b2) {f : \u03b2 \u2192 \u03b3} (hf : \u00ac(Measurable f)) :\n    map \u03ba f = 0 := by\n  simp [map, hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Composition/MapComap.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {m\u03b3 : MeasurableSpace \u03b3}", "{\u03b3 \u03b4 : Type*} {m\u03b3 : MeasurableSpace \u03b3} {m\u03b4 : MeasurableSpace \u03b4} {f : \u03b2 \u2192 \u03b3} {g : \u03b3 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_6\n\u03b3 : Type u_1\nx\u271d\u00b9 : Sort u_3\nKernel : x\u271d\u00b9\nx\u271d : Sort u_4\nmap : x\u271d\n\u03ba : sorry\nf : \u03b2 \u2192 \u03b3\nhf : \u00acsorry\n\u22a2 sorry = 0"}, {"line": "simp [map, hf]", "tactic_state": "\u03b2 : Type u_6\n\u03b3 : Type u_1\nx\u271d\u00b9 : Sort u_3\nKernel : x\u271d\u00b9\nx\u271d : Sort u_4\nmap : x\u271d\n\u03ba : sorry\nf : \u03b2 \u2192 \u03b3\nhf : \u00acsorry\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma isSFiniteKernel_prodMkLeft_unit {\u03ba : Kernel \u03b1 \u03b2} :\n    IsSFiniteKernel (prodMkLeft Unit \u03ba) \u2194 IsSFiniteKernel \u03ba := by\n  refine \u27e8fun _ \u21a6 ?_, fun _ \u21a6 inferInstance\u27e9\n  change IsSFiniteKernel ((prodMkLeft Unit \u03ba).comap (fun a \u21a6 ((), a)) (by fun_prop))\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Composition/MapComap.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {m\u03b3 : MeasurableSpace \u03b3}", "{\u03b3 \u03b4 : Type*} {m\u03b3 : MeasurableSpace \u03b3} {m\u03b4 : MeasurableSpace \u03b4} {f : \u03b2 \u2192 \u03b3} {g : \u03b3 \u2192 \u03b1}", "{\u03b4 : Type*} {m\u03b4 : MeasurableSpace \u03b4}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_4\nKernel : x\u271d\u00b9\nx\u271d : Sort u_5\nIsSFiniteKernel : x\u271d\n\u03ba : sorry\n\u22a2 sorry \u2194 sorry"}, {"line": "refine \u27e8fun _ \u21a6 ?_, fun _ \u21a6 inferInstance\u27e9", "tactic_state": "x\u271d\u00b2 : Sort u_4\nKernel : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\nIsSFiniteKernel : x\u271d\u00b9\n\u03ba : sorry\nx\u271d : sorry\n\u22a2 sorry"}, {"line": "change IsSFiniteKernel ((prodMkLeft Unit \u03ba).comap (fun a \u21a6 ((), a)) (by fun_prop))", "tactic_state": "x\u271d\u00b2 : Sort u_4\nKernel : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\nIsSFiniteKernel : x\u271d\u00b9\n\u03ba : sorry\nx\u271d : sorry\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isSFiniteKernel_prodMkRight_unit {\u03ba : Kernel \u03b1 \u03b2} :\n    IsSFiniteKernel (prodMkRight Unit \u03ba) \u2194 IsSFiniteKernel \u03ba := by\n  refine \u27e8fun _ \u21a6 ?_, fun _ \u21a6 inferInstance\u27e9\n  change IsSFiniteKernel ((prodMkRight Unit \u03ba).comap (fun a \u21a6 (a, ())) (by fun_prop))\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Composition/MapComap.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {m\u03b3 : MeasurableSpace \u03b3}", "{\u03b3 \u03b4 : Type*} {m\u03b3 : MeasurableSpace \u03b3} {m\u03b4 : MeasurableSpace \u03b4} {f : \u03b2 \u2192 \u03b3} {g : \u03b3 \u2192 \u03b1}", "{\u03b4 : Type*} {m\u03b4 : MeasurableSpace \u03b4}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_4\nKernel : x\u271d\u00b9\nx\u271d : Sort u_5\nIsSFiniteKernel : x\u271d\n\u03ba : sorry\n\u22a2 sorry \u2194 sorry"}, {"line": "refine \u27e8fun _ \u21a6 ?_, fun _ \u21a6 inferInstance\u27e9", "tactic_state": "x\u271d\u00b2 : Sort u_4\nKernel : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\nIsSFiniteKernel : x\u271d\u00b9\n\u03ba : sorry\nx\u271d : sorry\n\u22a2 sorry"}, {"line": "change IsSFiniteKernel ((prodMkRight Unit \u03ba).comap (fun a \u21a6 (a, ())) (by fun_prop))", "tactic_state": "x\u271d\u00b2 : Sort u_4\nKernel : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\nIsSFiniteKernel : x\u271d\u00b9\n\u03ba : sorry\nx\u271d : sorry\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "lemma swapLeft_zero : swapLeft (0 : Kernel (\u03b1 \u00d7 \u03b2) \u03b3) = 0 := by simp [swapLeft]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Composition/MapComap.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {m\u03b3 : MeasurableSpace \u03b3}", "{\u03b3 \u03b4 : Type*} {m\u03b3 : MeasurableSpace \u03b3} {m\u03b4 : MeasurableSpace \u03b4} {f : \u03b2 \u2192 \u03b3} {g : \u03b3 \u2192 \u03b1}", "{\u03b4 : Type*} {m\u03b4 : MeasurableSpace \u03b4}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nswapLeft : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [swapLeft]", "tactic_state": "x\u271d : Sort u_4\nswapLeft : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma swapRight_eq (\u03ba : Kernel \u03b1 (\u03b2 \u00d7 \u03b3)) : swapRight \u03ba = map \u03ba Prod.swap := by\n  simp [swapRight]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Composition/MapComap.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {m\u03b3 : MeasurableSpace \u03b3}", "{\u03b3 \u03b4 : Type*} {m\u03b3 : MeasurableSpace \u03b3} {m\u03b4 : MeasurableSpace \u03b4} {f : \u03b2 \u2192 \u03b3} {g : \u03b3 \u2192 \u03b1}", "{\u03b4 : Type*} {m\u03b4 : MeasurableSpace \u03b4}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_4\nKernel : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\nswapRight : x\u271d\u00b9\nx\u271d : Sort u_6\nmap : x\u271d\n\u03ba : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [swapRight]", "tactic_state": "x\u271d\u00b2 : Sort u_4\nKernel : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\nswapRight : x\u271d\u00b9\nx\u271d : Sort u_6\nmap : x\u271d\n\u03ba : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma swapRight_zero : swapRight (0 : Kernel \u03b1 (\u03b2 \u00d7 \u03b3)) = 0 := by simp [swapRight]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Composition/MapComap.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {m\u03b3 : MeasurableSpace \u03b3}", "{\u03b3 \u03b4 : Type*} {m\u03b3 : MeasurableSpace \u03b3} {m\u03b4 : MeasurableSpace \u03b4} {f : \u03b2 \u2192 \u03b3} {g : \u03b3 \u2192 \u03b1}", "{\u03b4 : Type*} {m\u03b4 : MeasurableSpace \u03b4}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nswapRight : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [swapRight]", "tactic_state": "x\u271d : Sort u_4\nswapRight : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem fst_eq (\u03ba : Kernel \u03b1 (\u03b2 \u00d7 \u03b3)) : fst \u03ba = map \u03ba Prod.fst := by simp [fst]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Composition/MapComap.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {m\u03b3 : MeasurableSpace \u03b3}", "{\u03b3 \u03b4 : Type*} {m\u03b3 : MeasurableSpace \u03b3} {m\u03b4 : MeasurableSpace \u03b4} {f : \u03b2 \u2192 \u03b3} {g : \u03b3 \u2192 \u03b1}", "{\u03b4 : Type*} {m\u03b4 : MeasurableSpace \u03b4}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_4\nKernel : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\nfst : x\u271d\u00b9\nx\u271d : Sort u_6\nmap : x\u271d\n\u03ba : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [fst]", "tactic_state": "x\u271d\u00b2 : Sort u_4\nKernel : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\nfst : x\u271d\u00b9\nx\u271d : Sort u_6\nmap : x\u271d\n\u03ba : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma fst_zero : fst (0 : Kernel \u03b1 (\u03b2 \u00d7 \u03b3)) = 0 := by simp [fst]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Composition/MapComap.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {m\u03b3 : MeasurableSpace \u03b3}", "{\u03b3 \u03b4 : Type*} {m\u03b3 : MeasurableSpace \u03b3} {m\u03b4 : MeasurableSpace \u03b4} {f : \u03b2 \u2192 \u03b3} {g : \u03b3 \u2192 \u03b1}", "{\u03b4 : Type*} {m\u03b4 : MeasurableSpace \u03b4}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nfst : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [fst]", "tactic_state": "x\u271d : Sort u_4\nfst : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem snd_eq (\u03ba : Kernel \u03b1 (\u03b2 \u00d7 \u03b3)) : snd \u03ba = map \u03ba Prod.snd := by simp [snd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Composition/MapComap.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {m\u03b3 : MeasurableSpace \u03b3}", "{\u03b3 \u03b4 : Type*} {m\u03b3 : MeasurableSpace \u03b3} {m\u03b4 : MeasurableSpace \u03b4} {f : \u03b2 \u2192 \u03b3} {g : \u03b3 \u2192 \u03b1}", "{\u03b4 : Type*} {m\u03b4 : MeasurableSpace \u03b4}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_4\nKernel : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\nsnd : x\u271d\u00b9\nx\u271d : Sort u_6\nmap : x\u271d\n\u03ba : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [snd]", "tactic_state": "x\u271d\u00b2 : Sort u_4\nKernel : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\nsnd : x\u271d\u00b9\nx\u271d : Sort u_6\nmap : x\u271d\n\u03ba : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma snd_zero : snd (0 : Kernel \u03b1 (\u03b2 \u00d7 \u03b3)) = 0 := by simp [snd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Composition/MapComap.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {m\u03b3 : MeasurableSpace \u03b3}", "{\u03b3 \u03b4 : Type*} {m\u03b3 : MeasurableSpace \u03b3} {m\u03b4 : MeasurableSpace \u03b4} {f : \u03b2 \u2192 \u03b3} {g : \u03b3 \u2192 \u03b1}", "{\u03b4 : Type*} {m\u03b4 : MeasurableSpace \u03b4}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nsnd : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [snd]", "tactic_state": "x\u271d : Sort u_4\nsnd : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem integrable_kernel_prodMk_left (a : \u03b1) {s : Set (\u03b2 \u00d7 \u03b3)} (hs : MeasurableSet s)\n    (h2s : (\u03ba \u2297\u2096 \u03b7) a s \u2260 \u221e) : Integrable (fun b => (\u03b7 (a, b)).real (Prod.mk b \u207b\u00b9' s)) (\u03ba a) := by\n  constructor\n  \u00b7 exact (measurable_kernel_prodMk_left' hs a).ennreal_toReal.aestronglyMeasurable\n  \u00b7 exact hasFiniteIntegral_prodMk_left a h2s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Composition/IntegralCompProd.lean", "context": {"open": ["Set Function Real ENNReal MeasureTheory Filter ProbabilityTheory ProbabilityTheory.Kernel", "scoped Topology ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 E : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2}", "{\u03ba : Kernel \u03b1 \u03b2} [IsSFiniteKernel \u03ba] {\u03b7 : Kernel (\u03b1 \u00d7 \u03b2) \u03b3} [IsSFiniteKernel \u03b7]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : MeasurableSpace \u03b3\n\u03b7 : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\na : \u03b1\ns : Set (\u03b2 \u00d7 \u03b3)\nhs : sorry\nh2s : ((\u03ba.compProd \u03b7) a) s \u2260 \u22a4\n\u22a2 Integrable (fun b => (\u03b7 (a, b)).real (Prod.mk b \u207b\u00b9' s)) (\u03ba a)"}, {"line": "constructor", "tactic_state": "case left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : MeasurableSpace \u03b3\n\u03b7 : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\na : \u03b1\ns : Set (\u03b2 \u00d7 \u03b3)\nhs : sorry\nh2s : ((\u03ba.compProd \u03b7) a) s \u2260 \u22a4\n\u22a2 AEStronglyMeasurable (fun b => (\u03b7 (a, b)).real (Prod.mk b \u207b\u00b9' s)) (\u03ba a)\n---\ncase right\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : MeasurableSpace \u03b3\n\u03b7 : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\na : \u03b1\ns : Set (\u03b2 \u00d7 \u03b3)\nhs : sorry\nh2s : ((\u03ba.compProd \u03b7) a) s \u2260 \u22a4\n\u22a2 HasFiniteIntegral (fun b => (\u03b7 (a, b)).real (Prod.mk b \u207b\u00b9' s)) (\u03ba a)"}, {"line": "\u00b7 exact (measurable_kernel_prodMk_left' hs a).ennreal_toReal.aestronglyMeasurable", "tactic_state": "case right\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : MeasurableSpace \u03b3\n\u03b7 : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\na : \u03b1\ns : Set (\u03b2 \u00d7 \u03b3)\nhs : sorry\nh2s : ((\u03ba.compProd \u03b7) a) s \u2260 \u22a4\n\u22a2 HasFiniteIntegral (fun b => (\u03b7 (a, b)).real (Prod.mk b \u207b\u00b9' s)) (\u03ba a)"}, {"line": "\u00b7 exact hasFiniteIntegral_prodMk_left a h2s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.MeasureTheory.AEStronglyMeasurable.compProd_mk_left {\u03b4 : Type*} [TopologicalSpace \u03b4]\n    {f : \u03b2 \u00d7 \u03b3 \u2192 \u03b4} (hf : AEStronglyMeasurable f ((\u03ba \u2297\u2096 \u03b7) a)) :\n    \u2200\u1d50 x \u2202\u03ba a, AEStronglyMeasurable (fun y => f (x, y)) (\u03b7 (a, x)) := by\n  filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with x hx using\n    \u27e8fun y => hf.mk f (x, y), hf.stronglyMeasurable_mk.comp_measurable measurable_prodMk_left, hx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Composition/IntegralCompProd.lean", "context": {"open": ["Set Function Real ENNReal MeasureTheory Filter ProbabilityTheory ProbabilityTheory.Kernel", "scoped Topology ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 E : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2}", "{\u03ba : Kernel \u03b1 \u03b2} [IsSFiniteKernel \u03ba] {\u03b7 : Kernel (\u03b1 \u00d7 \u03b2) \u03b3} [IsSFiniteKernel \u03b7]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b1\u271d : Type u_6\ninst\u271d\u00b3 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1\u271d \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\n\u03b7 : Kernel (\u03b1\u271d \u00d7 \u03b2) \u03b3\na : \u03b1\u271d\n\u03b4 : Type u_5\ninst\u271d : TopologicalSpace \u03b4\nf : \u03b2 \u00d7 \u03b3 \u2192 \u03b4\nhf : sorry\n\u22a2 \u2200\u1d50 (x : \u03b2) \u2202\u03ba a, sorry"}, {"line": "filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with x hx using\n    \u27e8fun y => hf.mk f (x, y), hf.stronglyMeasurable_mk.comp_measurable measurable_prodMk_left, hx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isRatStieltjesPoint_unit_prod_iff (f : \u03b1 \u2192 \u211a \u2192 \u211d) (a : \u03b1) :\n    IsRatStieltjesPoint (fun p : Unit \u00d7 \u03b1 \u21a6 f p.2) ((), a)\n      \u2194 IsRatStieltjesPoint f a := by\n  constructor <;>\n    exact fun h \u21a6 \u27e8h.mono, h.tendsto_atTop_one, h.tendsto_atBot_zero, h.iInf_rat_gt_eq\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Disintegration/MeasurableStieltjes.lean", "context": {"open": ["MeasureTheory Set Filter TopologicalSpace", "scoped NNReal ENNReal MeasureTheory Topology"], "variables": ["{\u03b1 : Type*}", "{f : \u03b1 \u2192 \u211a \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\nIsRatStieltjesPoint : x\u271d\nf : \u03b1 \u2192 \u211a \u2192 \u211d\na : \u03b1\n\u22a2 sorry \u2194 sorry"}, {"line": "constructor <;>\n    exact fun h \u21a6 \u27e8h.mono, h.tendsto_atTop_one, h.tendsto_atBot_zero, h.iInf_rat_gt_eq\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma measurableSet_isRatStieltjesPoint [MeasurableSpace \u03b1] (hf : Measurable f) :\n    MeasurableSet {a | IsRatStieltjesPoint f a} := by\n  have h1 : MeasurableSet {a | Monotone (f a)} := by\n    change MeasurableSet {a | \u2200 q r (_ : q \u2264 r), f a q \u2264 f a r}\n    simp_rw [Set.setOf_forall]\n    refine MeasurableSet.iInter (fun q \u21a6 ?_)\n    refine MeasurableSet.iInter (fun r \u21a6 ?_)\n    refine MeasurableSet.iInter (fun _ \u21a6 ?_)\n    exact measurableSet_le hf.eval hf.eval\n  have h2 : MeasurableSet {a | Tendsto (f a) atTop (\ud835\udcdd 1)} :=\n    measurableSet_tendsto _ (fun q \u21a6 hf.eval)\n  have h3 : MeasurableSet {a | Tendsto (f a) atBot (\ud835\udcdd 0)} :=\n    measurableSet_tendsto _ (fun q \u21a6 hf.eval)\n  have h4 : MeasurableSet {a | \u2200 t : \u211a, \u2a05 r : Ioi t, f a r = f a t} := by\n    rw [Set.setOf_forall]\n    refine MeasurableSet.iInter (fun q \u21a6 ?_)\n    exact measurableSet_eq_fun (.iInf fun _ \u21a6 hf.eval) hf.eval\n  suffices {a | IsRatStieltjesPoint f a}\n      = ({a | Monotone (f a)} \u2229 {a | Tendsto (f a) atTop (\ud835\udcdd 1)} \u2229 {a | Tendsto (f a) atBot (\ud835\udcdd 0)}\n        \u2229 {a | \u2200 t : \u211a, \u2a05 r : Ioi t, f a r = f a t}) by\n    rw [this]\n    exact (((h1.inter h2).inter h3).inter h4)\n  ext a\n  simp only [mem_setOf_eq]\n  simp only [mem_inter_iff]\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 exact \u27e8\u27e8\u27e8h.mono, h.tendsto_atTop_one\u27e9, h.tendsto_atBot_zero\u27e9, h.iInf_rat_gt_eq\u27e9\n  \u00b7 exact \u27e8h.1.1.1, h.1.1.2, h.1.2, h.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Disintegration/MeasurableStieltjes.lean", "context": {"open": ["MeasureTheory Set Filter TopologicalSpace", "scoped NNReal ENNReal MeasureTheory Topology"], "variables": ["{\u03b1 : Type*}", "{f : \u03b1 \u2192 \u211a \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211a \u2192 \u211d\nx\u271d : Sort u_2\nIsRatStieltjesPoint : x\u271d\ninst\u271d : MeasurableSpace \u03b1\nhf : Measurable f\n\u22a2 MeasurableSet {a | sorry}"}, {"line": "have h1 : MeasurableSet {a | Monotone (f a)} := sorry", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211a \u2192 \u211d\nx\u271d : Sort u_2\nIsRatStieltjesPoint : x\u271d\ninst\u271d : MeasurableSpace \u03b1\nhf : Measurable f\nh1 : sorry\n\u22a2 MeasurableSet {a | sorry}"}, {"line": "have h2 : MeasurableSet {a | Tendsto (f a) atTop (\ud835\udcdd 1)} :=\n    measurableSet_tendsto _ (fun q \u21a6 hf.eval)", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211a \u2192 \u211d\nx\u271d : Sort u_2\nIsRatStieltjesPoint : x\u271d\ninst\u271d : MeasurableSpace \u03b1\nhf : Measurable f\nh1 : sorry\nh2 : sorry\n\u22a2 MeasurableSet {a | sorry}"}, {"line": "have h3 : MeasurableSet {a | Tendsto (f a) atBot (\ud835\udcdd 0)} :=\n    measurableSet_tendsto _ (fun q \u21a6 hf.eval)", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211a \u2192 \u211d\nx\u271d : Sort u_2\nIsRatStieltjesPoint : x\u271d\ninst\u271d : MeasurableSpace \u03b1\nhf : Measurable f\nh1 : sorry\nh2 : sorry\nh3 : sorry\n\u22a2 MeasurableSet {a | sorry}"}, {"line": "have h4 : MeasurableSet {a | \u2200 t : \u211a, \u2a05 r : Ioi t, f a r = f a t} := by\n    rw [Set.setOf_forall]\n    refine MeasurableSet.iInter (fun q \u21a6 ?_)\n    exact measurableSet_eq_fun (.iInf fun _ \u21a6 hf.eval) hf.eval", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211a \u2192 \u211d\nx\u271d : Sort u_2\nIsRatStieltjesPoint : x\u271d\ninst\u271d : MeasurableSpace \u03b1\nhf : Measurable f\nh1 : sorry\nh2 : sorry\nh3 : sorry\nh4 : sorry\n\u22a2 MeasurableSet {a | sorry}"}, {"line": "suffices {a | IsRatStieltjesPoint f a}\n      = ({a | Monotone (f a)} \u2229 {a | Tendsto (f a) atTop (\ud835\udcdd 1)} \u2229 {a | Tendsto (f a) atBot (\ud835\udcdd 0)}\n        \u2229 {a | \u2200 t : \u211a, \u2a05 r : Ioi t, f a r = f a t}) by\n    rw [this]\n    exact (((h1.inter h2).inter h3).inter h4)", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211a \u2192 \u211d\nx\u271d : Sort u_2\nIsRatStieltjesPoint : x\u271d\ninst\u271d : MeasurableSpace \u03b1\nhf : Measurable f\nh1 : sorry\nh2 : sorry\nh3 : sorry\nh4 : sorry\n\u22a2 {a | sorry} =\n    {a | Monotone (f a)} \u2229 {a | Tendsto (f a) atTop sorry} \u2229 {a | Tendsto (f a) atBot sorry} \u2229\n      {a | \u2200 (t : \u211a), \u2a05 r, f a \u2191r = f a t}"}, {"line": "ext a", "tactic_state": "case h\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211a \u2192 \u211d\nx\u271d : Sort u_2\nIsRatStieltjesPoint : x\u271d\ninst\u271d : MeasurableSpace \u03b1\nhf : Measurable f\nh1 : sorry\nh2 : sorry\nh3 : sorry\nh4 : sorry\na : \u03b1\n\u22a2 a \u2208 {a | sorry} \u2194\n    a \u2208\n      {a | Monotone (f a)} \u2229 {a | Tendsto (f a) atTop sorry} \u2229 {a | Tendsto (f a) atBot sorry} \u2229\n        {a | \u2200 (t : \u211a), \u2a05 r, f a \u2191r = f a t}"}, {"line": "simp only [mem_setOf_eq]", "tactic_state": "case h\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211a \u2192 \u211d\nx\u271d : Sort u_2\nIsRatStieltjesPoint : x\u271d\ninst\u271d : MeasurableSpace \u03b1\nhf : Measurable f\nh1 : sorry\nh2 : sorry\nh3 : sorry\nh4 : sorry\na : \u03b1\n\u22a2 sorry \u2194\n    a \u2208\n      {a | Monotone (f a)} \u2229 {a | Tendsto (f a) atTop sorry} \u2229 {a | Tendsto (f a) atBot sorry} \u2229\n        {a | \u2200 (t : \u211a), \u2a05 r, f a \u2191r = f a t}"}, {"line": "simp only [mem_inter_iff]", "tactic_state": "case h\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211a \u2192 \u211d\nx\u271d : Sort u_2\nIsRatStieltjesPoint : x\u271d\ninst\u271d : MeasurableSpace \u03b1\nhf : Measurable f\nh1 : sorry\nh2 : sorry\nh3 : sorry\nh4 : sorry\na : \u03b1\n\u22a2 sorry \u2194\n    ((a \u2208 {a | Monotone (f a)} \u2227 a \u2208 {a | Tendsto (f a) atTop sorry}) \u2227 a \u2208 {a | Tendsto (f a) atBot sorry}) \u2227\n      a \u2208 {a | \u2200 (t : \u211a), \u2a05 r, f a \u2191r = f a t}"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9", "tactic_state": "case h.refine_1\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211a \u2192 \u211d\nx\u271d : Sort u_2\nIsRatStieltjesPoint : x\u271d\ninst\u271d : MeasurableSpace \u03b1\nhf : Measurable f\nh1 : sorry\nh2 : sorry\nh3 : sorry\nh4 : sorry\na : \u03b1\nh : sorry\n\u22a2 ((a \u2208 {a | Monotone (f a)} \u2227 a \u2208 {a | Tendsto (f a) atTop sorry}) \u2227 a \u2208 {a | Tendsto (f a) atBot sorry}) \u2227\n    a \u2208 {a | \u2200 (t : \u211a), \u2a05 r, f a \u2191r = f a t}\n---\ncase h.refine_2\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211a \u2192 \u211d\nx\u271d : Sort u_2\nIsRatStieltjesPoint : x\u271d\ninst\u271d : MeasurableSpace \u03b1\nhf : Measurable f\nh1 : sorry\nh2 : sorry\nh3 : sorry\nh4 : sorry\na : \u03b1\nh :\n  ((a \u2208 {a | Monotone (f a)} \u2227 a \u2208 {a | Tendsto (f a) atTop sorry}) \u2227 a \u2208 {a | Tendsto (f a) atBot sorry}) \u2227\n    a \u2208 {a | \u2200 (t : \u211a), \u2a05 r, f a \u2191r = f a t}\n\u22a2 sorry"}, {"line": "\u00b7 exact \u27e8\u27e8\u27e8h.mono, h.tendsto_atTop_one\u27e9, h.tendsto_atBot_zero\u27e9, h.iInf_rat_gt_eq\u27e9", "tactic_state": "case h.refine_2\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211a \u2192 \u211d\nx\u271d : Sort u_2\nIsRatStieltjesPoint : x\u271d\ninst\u271d : MeasurableSpace \u03b1\nhf : Measurable f\nh1 : sorry\nh2 : sorry\nh3 : sorry\nh4 : sorry\na : \u03b1\nh :\n  ((a \u2208 {a | Monotone (f a)} \u2227 a \u2208 {a | Tendsto (f a) atTop sorry}) \u2227 a \u2208 {a | Tendsto (f a) atBot sorry}) \u2227\n    a \u2208 {a | \u2200 (t : \u211a), \u2a05 r, f a \u2191r = f a t}\n\u22a2 sorry"}, {"line": "\u00b7 exact \u27e8h.1.1.1, h.1.1.2, h.1.2, h.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCondKernel.apply_of_ne_zero [MeasurableSingletonClass \u03b1] {x : \u03b1}\n    (hx : \u03c1.fst {x} \u2260 0) (s : Set \u03a9) : \u03c1Cond x s = (\u03c1.fst {x})\u207b\u00b9 * \u03c1 ({x} \u00d7\u02e2 s) := by\n  have : \u03c1Cond x s = ((\u03c1.fst {x})\u207b\u00b9 \u2022 \u03c1).comap (fun (y : \u03a9) \u21a6 (x, y)) s := by\n    congr 2 with s hs\n    simp [IsCondKernel.apply_of_ne_zero_of_measurableSet _ _ hx hs,\n      (measurableEmbedding_prodMk_left x).comap_apply, Set.singleton_prod]\n  simp [this, (measurableEmbedding_prodMk_left x).comap_apply, hx, Set.singleton_prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Disintegration/Basic.lean", "context": {"open": ["MeasureTheory Set Filter MeasurableSpace ProbabilityTheory", "scoped ENNReal MeasureTheory Topology"], "variables": ["{\u03b1 \u03b2 \u03a9 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {m\u03a9 : MeasurableSpace \u03a9}", "(\u03c1 : Measure (\u03b1 \u00d7 \u03a9)) (\u03c1Cond : Kernel \u03b1 \u03a9)", "[\u03c1.IsCondKernel \u03c1Cond]", "[IsFiniteMeasure \u03c1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03a9 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03a9 : MeasurableSpace \u03a9\n\u03c1 : Measure (\u03b1 \u00d7 \u03a9)\n\u03c1Cond : Kernel \u03b1 \u03a9\ninst\u271d\u00b2 : \u03c1.IsCondKernel \u03c1Cond\ninst\u271d\u00b9 : IsFiniteMeasure \u03c1\ninst\u271d : MeasurableSingletonClass \u03b1\nx : \u03b1\nhx : \u03c1.fst {x} \u2260 0\ns : Set \u03a9\n\u22a2 (\u03c1Cond x) s = (\u03c1.fst {x})\u207b\u00b9 * \u03c1 ({x} \u00d7\u02e2 s)"}, {"line": "have : \u03c1Cond x s = ((\u03c1.fst {x})\u207b\u00b9 \u2022 \u03c1).comap (fun (y : \u03a9) \u21a6 (x, y)) s := by\n    congr 2 with s hs\n    simp [IsCondKernel.apply_of_ne_zero_of_measurableSet _ _ hx hs,\n      (measurableEmbedding_prodMk_left x).comap_apply, Set.singleton_prod]", "tactic_state": "\u03b1 : Type u_1\n\u03a9 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03a9 : MeasurableSpace \u03a9\n\u03c1 : Measure (\u03b1 \u00d7 \u03a9)\n\u03c1Cond : Kernel \u03b1 \u03a9\ninst\u271d\u00b2 : \u03c1.IsCondKernel \u03c1Cond\ninst\u271d\u00b9 : IsFiniteMeasure \u03c1\ninst\u271d : MeasurableSingletonClass \u03b1\nx : \u03b1\nhx : \u03c1.fst {x} \u2260 0\ns : Set \u03a9\nthis : (\u03c1Cond x) s = sorry\n\u22a2 (\u03c1Cond x) s = (\u03c1.fst {x})\u207b\u00b9 * \u03c1 ({x} \u00d7\u02e2 s)"}, {"line": "simp [this, (measurableEmbedding_prodMk_left x).comap_apply, hx, Set.singleton_prod]", "tactic_state": "\u03b1 : Type u_1\n\u03a9 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03a9 : MeasurableSpace \u03a9\n\u03c1 : Measure (\u03b1 \u00d7 \u03a9)\n\u03c1Cond : Kernel \u03b1 \u03a9\ninst\u271d\u00b2 : \u03c1.IsCondKernel \u03c1Cond\ninst\u271d\u00b9 : IsFiniteMeasure \u03c1\ninst\u271d : MeasurableSingletonClass \u03b1\nx : \u03b1\nhx : \u03c1.fst {x} \u2260 0\ns : Set \u03a9\nthis : (\u03c1Cond x) s = sorry\n\u22a2 sorry () = (\u03c1.fst {x})\u207b\u00b9 * \u03c1 (Prod.mk x '' s)"}]}
{"declaration": "lemma densityProcess_empty (\u03ba : Kernel \u03b1 (\u03b3 \u00d7 \u03b2)) (\u03bd : Kernel \u03b1 \u03b3) (n : \u2115) (a : \u03b1) (x : \u03b3) :\n    densityProcess \u03ba \u03bd n a x \u2205 = 0 := by\n  simp [densityProcess]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/Disintegration/Density.lean", "context": {"open": ["MeasureTheory Set Filter MeasurableSpace", "scoped NNReal ENNReal MeasureTheory Topology ProbabilityTheory", "scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {m\u03b3 : MeasurableSpace \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nKernel : x\u271d\u00b9\n\u03b1 : Sort u_2\n\u03b3 : Sort u_3\nx\u271d : Sort u_4\ndensityProcess : x\u271d\n\u03ba : sorry\n\u03bd : sorry\nn : \u2115\na : \u03b1\nx : \u03b3\n\u22a2 sorry = 0"}, {"line": "simp [densityProcess]", "tactic_state": "x\u271d\u00b9 : Sort u_1\nKernel : x\u271d\u00b9\n\u03b1 : Sort u_2\n\u03b3 : Sort u_3\nx\u271d : Sort u_4\ndensityProcess : x\u271d\n\u03ba : sorry\n\u03bd : sorry\nn : \u2115\na : \u03b1\nx : \u03b3\n\u22a2 sorry () = 0"}]}
{"declaration": "private lemma measure_cast {a b : \u2115} (h : a = b) (\u03bc : (n : \u2115) \u2192 Measure (\u03a0 i : Iic n, X i)) :\n    (\u03bc a).map (cast (Iic_pi_eq h)) = \u03bc b := by\n  cases h\n  exact Measure.map_id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/IonescuTulcea/Traj.lean", "context": {"open": ["Filter Finset Function MeasurableEquiv MeasurableSpace MeasureTheory Preorder ProbabilityTheory", "scoped ENNReal Topology"], "variables": ["{X : \u2115 \u2192 Type*}", "[\u2200 n, MeasurableSpace (X n)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\nx\u271d : Sort u_2\nIic_pi_eq : x\u271d\na b : \u2115\nh : a = b\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\n\u22a2 Measure.map (cast \u22ef) (\u03bc a) = \u03bc b"}, {"line": "cases h", "tactic_state": "case refl\nX : \u2115 \u2192 Type u_1\ninst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\nx\u271d : Sort u_2\nIic_pi_eq : x\u271d\na : \u2115\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\n\u22a2 Measure.map (cast \u22ef) (\u03bc a) = \u03bc a"}, {"line": "exact Measure.map_id", "tactic_state": "No Goals!"}]}
{"declaration": "lemma frestrictLe_iterateInduction {a : \u2115} (x : \u03a0 i : Iic a, X i)\n    (ind : (n : \u2115) \u2192 (\u03a0 i : Iic n, X i) \u2192 X (n + 1)) :\n    frestrictLe a (iterateInduction x ind) = x := by\n  ext i\n  simp only [frestrictLe_apply]\n  obtain \u27e8(zero | j), hj\u27e9 := i <;> rw [iterateInduction]\n  rw [dif_pos (mem_Iic.1 hj)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/IonescuTulcea/Traj.lean", "context": {"open": ["Filter Finset Function MeasurableEquiv MeasurableSpace MeasureTheory Preorder ProbabilityTheory", "scoped ENNReal Topology"], "variables": ["{X : \u2115 \u2192 Type*}", "[\u2200 n, MeasurableSpace (X n)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\na : \u2115\nx : (i : { x // x \u2208 Iic a }) \u2192 X \u2191i\nind : (n : \u2115) \u2192 ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) \u2192 X (n + 1)\n\u22a2 frestrictLe a (iterateInduction x ind) = x"}, {"line": "ext i", "tactic_state": "case h\nX : \u2115 \u2192 Type u_1\ninst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\na : \u2115\nx : (i : { x // x \u2208 Iic a }) \u2192 X \u2191i\nind : (n : \u2115) \u2192 ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) \u2192 X (n + 1)\ni : { x // x \u2208 Iic a }\n\u22a2 frestrictLe a (iterateInduction x ind) i = x i"}, {"line": "simp only [frestrictLe_apply]", "tactic_state": "case h\nX : \u2115 \u2192 Type u_1\ninst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\na : \u2115\nx : (i : { x // x \u2208 Iic a }) \u2192 X \u2191i\nind : (n : \u2115) \u2192 ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) \u2192 X (n + 1)\ni : { x // x \u2208 Iic a }\n\u22a2 iterateInduction x ind \u2191i = x i"}, {"line": "obtain \u27e8(zero | j), hj\u27e9 := i <;> rw [iterateInduction]", "tactic_state": "case h.mk.succ\nX : \u2115 \u2192 Type u_1\ninst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\na : \u2115\nx : (i : { x // x \u2208 Iic a }) \u2192 X \u2191i\nind : (n : \u2115) \u2192 ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) \u2192 X (n + 1)\nj : \u2115\nhj : j + 1 \u2208 Iic a\n\u22a2 (if h : j + 1 \u2264 a then x \u27e8j + 1, \u22ef\u27e9 else ind j fun i => iterateInduction x ind \u2191i) = x \u27e8j + 1, hj\u27e9"}, {"line": "rw [dif_pos (mem_Iic.1 hj)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isProjectiveLimit_nat_iff' {\u03bc : (I : Finset \u2115) \u2192 Measure (\u03a0 i : I, X i)}\n    (h\u03bc : IsProjectiveMeasureFamily \u03bc) (\u03bd : Measure (\u03a0 n, X n)) (a : \u2115) :\n    IsProjectiveLimit \u03bd \u03bc \u2194 \u2200 \u2983n\u2984, a \u2264 n \u2192 \u03bd.map (frestrictLe n) = \u03bc (Iic n) := by\n  refine \u27e8fun h n _ \u21a6 h (Iic n), fun h I \u21a6 ?_\u27e9\n  have := (I.subset_Iic_sup_id.trans (Iic_subset_Iic.2 (le_max_left (I.sup id) a)))\n  rw [\u2190 restrict\u2082_comp_restrict this]\n  rw [\u2190 Measure.map_map]\n  rw [\u2190 frestrictLe]\n  rw [h (le_max_right _ _)]\n  rw [\u2190 h\u03bc]\n  all_goals fun_prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/IonescuTulcea/Traj.lean", "context": {"open": ["Filter Finset Function MeasurableEquiv MeasurableSpace MeasureTheory Preorder ProbabilityTheory", "scoped ENNReal Topology"], "variables": ["{X : \u2115 \u2192 Type*}", "[\u2200 n, MeasurableSpace (X n)]", "[\u2200 n, MeasurableSpace (X n)]", "{\u03bc : (n : \u2115) \u2192 Measure (\u03a0 i : Iic n, X i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (I : Finset \u2115) \u2192 Measure ((i : { x // x \u2208 I }) \u2192 X \u2191i)\nh\u03bc : IsProjectiveMeasureFamily \u03bc\n\u03bd : Measure ((n : \u2115) \u2192 X n)\na : \u2115\n\u22a2 IsProjectiveLimit \u03bd \u03bc \u2194 \u2200 \u2983n : \u2115\u2984, a \u2264 n \u2192 Measure.map (frestrictLe n) \u03bd = \u03bc (Iic n)"}, {"line": "refine \u27e8fun h n _ \u21a6 h (Iic n), fun h I \u21a6 ?_\u27e9", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (I : Finset \u2115) \u2192 Measure ((i : { x // x \u2208 I }) \u2192 X \u2191i)\nh\u03bc : IsProjectiveMeasureFamily \u03bc\n\u03bd : Measure ((n : \u2115) \u2192 X n)\na : \u2115\nh : \u2200 \u2983n : \u2115\u2984, a \u2264 n \u2192 Measure.map (frestrictLe n) \u03bd = \u03bc (Iic n)\nI : Finset \u2115\n\u22a2 Measure.map I.restrict \u03bd = \u03bc I"}, {"line": "have := (I.subset_Iic_sup_id.trans (Iic_subset_Iic.2 (le_max_left (I.sup id) a)))", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (I : Finset \u2115) \u2192 Measure ((i : { x // x \u2208 I }) \u2192 X \u2191i)\nh\u03bc : IsProjectiveMeasureFamily \u03bc\n\u03bd : Measure ((n : \u2115) \u2192 X n)\na : \u2115\nh : \u2200 \u2983n : \u2115\u2984, a \u2264 n \u2192 Measure.map (frestrictLe n) \u03bd = \u03bc (Iic n)\nI : Finset \u2115\nthis : I \u2286 Iic (max (I.sup id) a)\n\u22a2 Measure.map I.restrict \u03bd = \u03bc I"}, {"line": "rw [\u2190 restrict\u2082_comp_restrict this]", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (I : Finset \u2115) \u2192 Measure ((i : { x // x \u2208 I }) \u2192 X \u2191i)\nh\u03bc : IsProjectiveMeasureFamily \u03bc\n\u03bd : Measure ((n : \u2115) \u2192 X n)\na : \u2115\nh : \u2200 \u2983n : \u2115\u2984, a \u2264 n \u2192 Measure.map (frestrictLe n) \u03bd = \u03bc (Iic n)\nI : Finset \u2115\nthis : I \u2286 Iic (max (I.sup id) a)\n\u22a2 Measure.map (restrict\u2082 this \u2218 (Iic (max (I.sup id) a)).restrict) \u03bd = \u03bc I"}, {"line": "rw [\u2190 Measure.map_map]", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (I : Finset \u2115) \u2192 Measure ((i : { x // x \u2208 I }) \u2192 X \u2191i)\nh\u03bc : IsProjectiveMeasureFamily \u03bc\n\u03bd : Measure ((n : \u2115) \u2192 X n)\na : \u2115\nh : \u2200 \u2983n : \u2115\u2984, a \u2264 n \u2192 Measure.map (frestrictLe n) \u03bd = \u03bc (Iic n)\nI : Finset \u2115\nthis : I \u2286 Iic (max (I.sup id) a)\n\u22a2 Measure.map (restrict\u2082 this) (Measure.map (Iic (max (I.sup id) a)).restrict \u03bd) = \u03bc I\n---\ncase hg\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (I : Finset \u2115) \u2192 Measure ((i : { x // x \u2208 I }) \u2192 X \u2191i)\nh\u03bc : IsProjectiveMeasureFamily \u03bc\n\u03bd : Measure ((n : \u2115) \u2192 X n)\na : \u2115\nh : \u2200 \u2983n : \u2115\u2984, a \u2264 n \u2192 Measure.map (frestrictLe n) \u03bd = \u03bc (Iic n)\nI : Finset \u2115\nthis : I \u2286 Iic (max (I.sup id) a)\n\u22a2 Measurable (restrict\u2082 this)\n---\ncase hf\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (I : Finset \u2115) \u2192 Measure ((i : { x // x \u2208 I }) \u2192 X \u2191i)\nh\u03bc : IsProjectiveMeasureFamily \u03bc\n\u03bd : Measure ((n : \u2115) \u2192 X n)\na : \u2115\nh : \u2200 \u2983n : \u2115\u2984, a \u2264 n \u2192 Measure.map (frestrictLe n) \u03bd = \u03bc (Iic n)\nI : Finset \u2115\nthis : I \u2286 Iic (max (I.sup id) a)\n\u22a2 Measurable (Iic (max (I.sup id) a)).restrict\n---\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (I : Finset \u2115) \u2192 Measure ((i : { x // x \u2208 I }) \u2192 X \u2191i)\nh\u03bc : IsProjectiveMeasureFamily \u03bc\n\u03bd : Measure ((n : \u2115) \u2192 X n)\na : \u2115\nh : \u2200 \u2983n : \u2115\u2984, a \u2264 n \u2192 Measure.map (frestrictLe n) \u03bd = \u03bc (Iic n)\nI : Finset \u2115\nthis : I \u2286 Iic (max (I.sup id) a)\n\u22a2 MeasurableSpace ((i : { x // x \u2208 Iic (max (I.sup id) a) }) \u2192 X \u2191i)"}, {"line": "rw [\u2190 frestrictLe]", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (I : Finset \u2115) \u2192 Measure ((i : { x // x \u2208 I }) \u2192 X \u2191i)\nh\u03bc : IsProjectiveMeasureFamily \u03bc\n\u03bd : Measure ((n : \u2115) \u2192 X n)\na : \u2115\nh : \u2200 \u2983n : \u2115\u2984, a \u2264 n \u2192 Measure.map (frestrictLe n) \u03bd = \u03bc (Iic n)\nI : Finset \u2115\nthis : I \u2286 Iic (max (I.sup id) a)\n\u22a2 Measure.map (restrict\u2082 this) (Measure.map (frestrictLe (max (I.sup id) a)) \u03bd) = \u03bc I\n---\ncase hg\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (I : Finset \u2115) \u2192 Measure ((i : { x // x \u2208 I }) \u2192 X \u2191i)\nh\u03bc : IsProjectiveMeasureFamily \u03bc\n\u03bd : Measure ((n : \u2115) \u2192 X n)\na : \u2115\nh : \u2200 \u2983n : \u2115\u2984, a \u2264 n \u2192 Measure.map (frestrictLe n) \u03bd = \u03bc (Iic n)\nI : Finset \u2115\nthis : I \u2286 Iic (max (I.sup id) a)\n\u22a2 Measurable (restrict\u2082 this)\n---\ncase hf\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (I : Finset \u2115) \u2192 Measure ((i : { x // x \u2208 I }) \u2192 X \u2191i)\nh\u03bc : IsProjectiveMeasureFamily \u03bc\n\u03bd : Measure ((n : \u2115) \u2192 X n)\na : \u2115\nh : \u2200 \u2983n : \u2115\u2984, a \u2264 n \u2192 Measure.map (frestrictLe n) \u03bd = \u03bc (Iic n)\nI : Finset \u2115\nthis : I \u2286 Iic (max (I.sup id) a)\n\u22a2 Measurable (Iic (max (I.sup id) a)).restrict\n---\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (I : Finset \u2115) \u2192 Measure ((i : { x // x \u2208 I }) \u2192 X \u2191i)\nh\u03bc : IsProjectiveMeasureFamily \u03bc\n\u03bd : Measure ((n : \u2115) \u2192 X n)\na : \u2115\nh : \u2200 \u2983n : \u2115\u2984, a \u2264 n \u2192 Measure.map (frestrictLe n) \u03bd = \u03bc (Iic n)\nI : Finset \u2115\nthis : I \u2286 Iic (max (I.sup id) a)\n\u22a2 MeasurableSpace ((i : { x // x \u2208 Iic (max (I.sup id) a) }) \u2192 X \u2191i)"}, {"line": "rw [h (le_max_right _ _)]", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (I : Finset \u2115) \u2192 Measure ((i : { x // x \u2208 I }) \u2192 X \u2191i)\nh\u03bc : IsProjectiveMeasureFamily \u03bc\n\u03bd : Measure ((n : \u2115) \u2192 X n)\na : \u2115\nh : \u2200 \u2983n : \u2115\u2984, a \u2264 n \u2192 Measure.map (frestrictLe n) \u03bd = \u03bc (Iic n)\nI : Finset \u2115\nthis : I \u2286 Iic (max (I.sup id) a)\n\u22a2 Measure.map (restrict\u2082 this) (\u03bc (Iic (max (I.sup id) a))) = \u03bc I\n---\ncase hg\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (I : Finset \u2115) \u2192 Measure ((i : { x // x \u2208 I }) \u2192 X \u2191i)\nh\u03bc : IsProjectiveMeasureFamily \u03bc\n\u03bd : Measure ((n : \u2115) \u2192 X n)\na : \u2115\nh : \u2200 \u2983n : \u2115\u2984, a \u2264 n \u2192 Measure.map (frestrictLe n) \u03bd = \u03bc (Iic n)\nI : Finset \u2115\nthis : I \u2286 Iic (max (I.sup id) a)\n\u22a2 Measurable (restrict\u2082 this)\n---\ncase hf\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (I : Finset \u2115) \u2192 Measure ((i : { x // x \u2208 I }) \u2192 X \u2191i)\nh\u03bc : IsProjectiveMeasureFamily \u03bc\n\u03bd : Measure ((n : \u2115) \u2192 X n)\na : \u2115\nh : \u2200 \u2983n : \u2115\u2984, a \u2264 n \u2192 Measure.map (frestrictLe n) \u03bd = \u03bc (Iic n)\nI : Finset \u2115\nthis : I \u2286 Iic (max (I.sup id) a)\n\u22a2 Measurable (Iic (max (I.sup id) a)).restrict"}, {"line": "rw [\u2190 h\u03bc]", "tactic_state": "case hg\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (I : Finset \u2115) \u2192 Measure ((i : { x // x \u2208 I }) \u2192 X \u2191i)\nh\u03bc : IsProjectiveMeasureFamily \u03bc\n\u03bd : Measure ((n : \u2115) \u2192 X n)\na : \u2115\nh : \u2200 \u2983n : \u2115\u2984, a \u2264 n \u2192 Measure.map (frestrictLe n) \u03bd = \u03bc (Iic n)\nI : Finset \u2115\nthis : I \u2286 Iic (max (I.sup id) a)\n\u22a2 Measurable (restrict\u2082 this)\n---\ncase hf\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (I : Finset \u2115) \u2192 Measure ((i : { x // x \u2208 I }) \u2192 X \u2191i)\nh\u03bc : IsProjectiveMeasureFamily \u03bc\n\u03bd : Measure ((n : \u2115) \u2192 X n)\na : \u2115\nh : \u2200 \u2983n : \u2115\u2984, a \u2264 n \u2192 Measure.map (frestrictLe n) \u03bd = \u03bc (Iic n)\nI : Finset \u2115\nthis : I \u2286 Iic (max (I.sup id) a)\n\u22a2 Measurable (Iic (max (I.sup id) a)).restrict"}, {"line": "all_goals fun_prop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isProjectiveMeasureFamily_inducedFamily\n    (h : \u2200 a b : \u2115, \u2200 hab : a \u2264 b, (\u03bc b).map (frestrictLe\u2082 hab) = \u03bc a) :\n    IsProjectiveMeasureFamily (inducedFamily \u03bc) := by\n  intro I J hJI\n  have sls : J.sup id \u2264 I.sup id := sup_mono hJI\n  simp only [inducedFamily]\n  rw [Measure.map_map]\n  rw [restrict\u2082_comp_restrict\u2082]\n  rw [\u2190 restrict\u2082_comp_restrict\u2082 J.subset_Iic_sup_id (Iic_subset_Iic.2 sls)]\n  rw [\u2190 Measure.map_map]\n  rw [\u2190 frestrictLe\u2082]\n  rw [h (J.sup id) (I.sup id) sls]\n  all_goals fun_prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/IonescuTulcea/Traj.lean", "context": {"open": ["Filter Finset Function MeasurableEquiv MeasurableSpace MeasureTheory Preorder ProbabilityTheory", "scoped ENNReal Topology"], "variables": ["{X : \u2115 \u2192 Type*}", "[\u2200 n, MeasurableSpace (X n)]", "[\u2200 n, MeasurableSpace (X n)]", "{\u03bc : (n : \u2115) \u2192 Measure (\u03a0 i : Iic n, X i)}", "(\u03bc : (n : \u2115) \u2192 Measure (\u03a0 i : Iic n, X i))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\n\u22a2 IsProjectiveMeasureFamily (inducedFamily \u03bc)"}, {"line": "intro I J hJI", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\n\u22a2 inducedFamily \u03bc J = Measure.map (restrict\u2082 hJI) (inducedFamily \u03bc I)"}, {"line": "have sls : J.sup id \u2264 I.sup id := sup_mono hJI", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 inducedFamily \u03bc J = Measure.map (restrict\u2082 hJI) (inducedFamily \u03bc I)"}, {"line": "simp only [inducedFamily]", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measure.map (restrict\u2082 \u22ef) (\u03bc (J.sup id)) = Measure.map (restrict\u2082 hJI) (Measure.map (restrict\u2082 \u22ef) (\u03bc (I.sup id)))"}, {"line": "rw [Measure.map_map]", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measure.map (restrict\u2082 \u22ef) (\u03bc (J.sup id)) = Measure.map (restrict\u2082 hJI \u2218 restrict\u2082 \u22ef) (\u03bc (I.sup id))\n---\ncase hg\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 hJI)\n---\ncase hf\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 \u22ef)"}, {"line": "rw [restrict\u2082_comp_restrict\u2082]", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measure.map (restrict\u2082 \u22ef) (\u03bc (J.sup id)) = Measure.map (restrict\u2082 \u22ef) (\u03bc (I.sup id))\n---\ncase hg\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 hJI)\n---\ncase hf\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 \u22ef)"}, {"line": "rw [\u2190 restrict\u2082_comp_restrict\u2082 J.subset_Iic_sup_id (Iic_subset_Iic.2 sls)]", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measure.map (restrict\u2082 \u22ef) (\u03bc (J.sup id)) = Measure.map (restrict\u2082 \u22ef \u2218 restrict\u2082 \u22ef) (\u03bc (I.sup id))\n---\ncase hg\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 hJI)\n---\ncase hf\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 \u22ef)"}, {"line": "rw [\u2190 Measure.map_map]", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measure.map (restrict\u2082 \u22ef) (\u03bc (J.sup id)) = Measure.map (restrict\u2082 \u22ef) (Measure.map (restrict\u2082 \u22ef) (\u03bc (I.sup id)))\n---\ncase hg\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 \u22ef)\n---\ncase hf\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 \u22ef)\n---\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 MeasurableSpace ((i : { x // x \u2208 Iic (J.sup id) }) \u2192 X \u2191i)\n---\ncase hg\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 hJI)\n---\ncase hf\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 \u22ef)"}, {"line": "rw [\u2190 frestrictLe\u2082]", "tactic_state": "X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measure.map (restrict\u2082 \u22ef) (\u03bc (J.sup id)) =\n    Measure.map (restrict\u2082 \u22ef) (Measure.map (frestrictLe\u2082 ?m.3747) (\u03bc (I.sup id)))\n---\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 J.sup id \u2264 I.sup id\n---\ncase hg\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 \u22ef)\n---\ncase hf\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 \u22ef)\n---\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 MeasurableSpace ((i : { x // x \u2208 Iic (J.sup id) }) \u2192 X \u2191i)\n---\ncase hg\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 hJI)\n---\ncase hf\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 \u22ef)"}, {"line": "rw [h (J.sup id) (I.sup id) sls]", "tactic_state": "case hg\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 \u22ef)\n---\ncase hf\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 \u22ef)\n---\ncase hg\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 hJI)\n---\ncase hf\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 inst\u271d : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\nh : \u2200 (a b : \u2115) (hab : a \u2264 b), Measure.map (frestrictLe\u2082 hab) (\u03bc b) = \u03bc a\nI J : Finset \u2115\nhJI : J \u2286 I\nsls : J.sup id \u2264 I.sup id\n\u22a2 Measurable (restrict\u2082 \u22ef)"}, {"line": "all_goals fun_prop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma frestrictLe\u2082_comp_IicProdIoc {a b : \u03b9} (hab : a \u2264 b) :\n    (frestrictLe\u2082 hab) \u2218 (IicProdIoc (X := X) a b) = Prod.fst := by\n  ext x i\n  simp [IicProdIoc, mem_Iic.1 i.2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/IonescuTulcea/Maps.lean", "context": {"open": ["Finset Preorder"], "variables": ["{\u03b9 : Type*} [LinearOrder \u03b9] [LocallyFiniteOrder \u03b9] [DecidableLE \u03b9] {X : \u03b9 \u2192 Type*}", "[LocallyFiniteOrderBot \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b9\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b9\ninst\u271d\u00b9 : DecidableLE \u03b9\nX : \u03b9 \u2192 Type u_2\ninst\u271d : LocallyFiniteOrderBot \u03b9\na b : \u03b9\nhab : a \u2264 b\n\u22a2 frestrictLe\u2082 hab \u2218 IicProdIoc a b = Prod.fst"}, {"line": "ext x i", "tactic_state": "case h.h\n\u03b9 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b9\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b9\ninst\u271d\u00b9 : DecidableLE \u03b9\nX : \u03b9 \u2192 Type u_2\ninst\u271d : LocallyFiniteOrderBot \u03b9\na b : \u03b9\nhab : a \u2264 b\nx : ((i : { x // x \u2208 Iic a }) \u2192 X \u2191i) \u00d7 ((i : { x // x \u2208 Ioc a b }) \u2192 X \u2191i)\ni : { x // x \u2208 Iic a }\n\u22a2 (frestrictLe\u2082 hab \u2218 IicProdIoc a b) x i = x.1 i"}, {"line": "simp [IicProdIoc, mem_Iic.1 i.2]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma restrict\u2082_comp_IicProdIoc (a b : \u03b9) :\n    (restrict\u2082 Ioc_subset_Iic_self) \u2218 (IicProdIoc (X := X) a b) = Prod.snd := by\n  ext x i\n  simp [IicProdIoc, not_le.2 (mem_Ioc.1 i.2).1]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/IonescuTulcea/Maps.lean", "context": {"open": ["Finset Preorder"], "variables": ["{\u03b9 : Type*} [LinearOrder \u03b9] [LocallyFiniteOrder \u03b9] [DecidableLE \u03b9] {X : \u03b9 \u2192 Type*}", "[LocallyFiniteOrderBot \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b9\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b9\ninst\u271d\u00b9 : DecidableLE \u03b9\nX : \u03b9 \u2192 Type u_2\ninst\u271d : LocallyFiniteOrderBot \u03b9\na b : \u03b9\n\u22a2 restrict\u2082 \u22ef \u2218 IicProdIoc a b = Prod.snd"}, {"line": "ext x i", "tactic_state": "case h.h\n\u03b9 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b9\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b9\ninst\u271d\u00b9 : DecidableLE \u03b9\nX : \u03b9 \u2192 Type u_2\ninst\u271d : LocallyFiniteOrderBot \u03b9\na b : \u03b9\nx : ((i : { x // x \u2208 Iic a }) \u2192 X \u2191i) \u00d7 ((i : { x // x \u2208 Ioc a b }) \u2192 X \u2191i)\ni : { x // x \u2208 Ioc a b }\n\u22a2 (restrict\u2082 \u22ef \u2218 IicProdIoc a b) x i = x.2 i"}, {"line": "simp [IicProdIoc, not_le.2 (mem_Ioc.1 i.2).1]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IicProdIoc_self (a : \u03b9) : IicProdIoc (X := X) a a = Prod.fst := by\n  ext x i\n  simp [IicProdIoc, mem_Iic.1 i.2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/IonescuTulcea/Maps.lean", "context": {"open": ["Finset Preorder"], "variables": ["{\u03b9 : Type*} [LinearOrder \u03b9] [LocallyFiniteOrder \u03b9] [DecidableLE \u03b9] {X : \u03b9 \u2192 Type*}", "[LocallyFiniteOrderBot \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b9\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b9\ninst\u271d\u00b9 : DecidableLE \u03b9\nX : \u03b9 \u2192 Type u_2\ninst\u271d : LocallyFiniteOrderBot \u03b9\na : \u03b9\n\u22a2 IicProdIoc a a = Prod.fst"}, {"line": "ext x i", "tactic_state": "case h.h\n\u03b9 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b9\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b9\ninst\u271d\u00b9 : DecidableLE \u03b9\nX : \u03b9 \u2192 Type u_2\ninst\u271d : LocallyFiniteOrderBot \u03b9\na : \u03b9\nx : ((i : { x // x \u2208 Iic a }) \u2192 X \u2191i) \u00d7 ((i : { x // x \u2208 Ioc a a }) \u2192 X \u2191i)\ni : { x // x \u2208 Iic a }\n\u22a2 IicProdIoc a a x i = x.1 i"}, {"line": "simp [IicProdIoc, mem_Iic.1 i.2]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IicProdIoc_le {a b : \u03b9} (hba : b \u2264 a) :\n    IicProdIoc (X := X) a b = (frestrictLe\u2082 hba) \u2218 Prod.fst := by\n  ext x i\n  simp [IicProdIoc, (mem_Iic.1 i.2).trans hba]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/IonescuTulcea/Maps.lean", "context": {"open": ["Finset Preorder"], "variables": ["{\u03b9 : Type*} [LinearOrder \u03b9] [LocallyFiniteOrder \u03b9] [DecidableLE \u03b9] {X : \u03b9 \u2192 Type*}", "[LocallyFiniteOrderBot \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b9\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b9\ninst\u271d\u00b9 : DecidableLE \u03b9\nX : \u03b9 \u2192 Type u_2\ninst\u271d : LocallyFiniteOrderBot \u03b9\na b : \u03b9\nhba : b \u2264 a\n\u22a2 IicProdIoc a b = frestrictLe\u2082 hba \u2218 Prod.fst"}, {"line": "ext x i", "tactic_state": "case h.h\n\u03b9 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b9\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b9\ninst\u271d\u00b9 : DecidableLE \u03b9\nX : \u03b9 \u2192 Type u_2\ninst\u271d : LocallyFiniteOrderBot \u03b9\na b : \u03b9\nhba : b \u2264 a\nx : ((i : { x // x \u2208 Iic a }) \u2192 X \u2191i) \u00d7 ((i : { x // x \u2208 Ioc a b }) \u2192 X \u2191i)\ni : { x // x \u2208 Iic b }\n\u22a2 IicProdIoc a b x i = (frestrictLe\u2082 hba \u2218 Prod.fst) x i"}, {"line": "simp [IicProdIoc, (mem_Iic.1 i.2).trans hba]", "tactic_state": "case h.h\n\u03b9 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b9\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b9\ninst\u271d\u00b9 : DecidableLE \u03b9\nX : \u03b9 \u2192 Type u_2\ninst\u271d : LocallyFiniteOrderBot \u03b9\na b : \u03b9\nhba : b \u2264 a\nx : ((i : { x // x \u2208 Iic a }) \u2192 X \u2191i) \u00d7 ((i : { x // x \u2208 Ioc a b }) \u2192 X \u2191i)\ni : { x // x \u2208 Iic b }\n\u22a2 (if h : \u2191i \u2264 a then x.1 \u27e8\u2191i, \u22ef\u27e9 else x.2 \u27e8\u2191i, \u22ef\u27e9) = x.1 \u27e8\u2191i, \u22ef\u27e9"}]}
{"declaration": "lemma IicProdIoc_comp_restrict\u2082 {a b : \u03b9} :\n    (restrict\u2082 Ioc_subset_Iic_self) \u2218 (IicProdIoc (X := X) a b) = Prod.snd := by\n  ext x i\n  simp [IicProdIoc, not_le.2 (mem_Ioc.1 i.2).1]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/IonescuTulcea/Maps.lean", "context": {"open": ["Finset Preorder"], "variables": ["{\u03b9 : Type*} [LinearOrder \u03b9] [LocallyFiniteOrder \u03b9] [DecidableLE \u03b9] {X : \u03b9 \u2192 Type*}", "[LocallyFiniteOrderBot \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b9\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b9\ninst\u271d\u00b9 : DecidableLE \u03b9\nX : \u03b9 \u2192 Type u_2\ninst\u271d : LocallyFiniteOrderBot \u03b9\na b : \u03b9\n\u22a2 restrict\u2082 \u22ef \u2218 IicProdIoc a b = Prod.snd"}, {"line": "ext x i", "tactic_state": "case h.h\n\u03b9 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b9\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b9\ninst\u271d\u00b9 : DecidableLE \u03b9\nX : \u03b9 \u2192 Type u_2\ninst\u271d : LocallyFiniteOrderBot \u03b9\na b : \u03b9\nx : ((i : { x // x \u2208 Iic a }) \u2192 X \u2191i) \u00d7 ((i : { x // x \u2208 Ioc a b }) \u2192 X \u2191i)\ni : { x // x \u2208 Ioc a b }\n\u22a2 (restrict\u2082 \u22ef \u2218 IicProdIoc a b) x i = x.2 i"}, {"line": "simp [IicProdIoc, not_le.2 (mem_Ioc.1 i.2).1]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lmarginalPartialTraj_const_right [\u2200 n, IsMarkovKernel (\u03ba n)] {d : \u2115} {f : (\u03a0 n, X n) \u2192 \u211d\u22650\u221e}\n    (mf : Measurable f) (hf : DependsOn f (Iic a)) (hac : a \u2264 c) (had : a \u2264 d) :\n    lmarginalPartialTraj \u03ba b c f = lmarginalPartialTraj \u03ba b d f := by\n  wlog hcd : c \u2264 d generalizing c d\n  \u00b7 rw [this had hac (le_of_not_le hcd)]\n  obtain hbc | hcb := le_total b c\n  \u00b7 rw [\u2190 lmarginalPartialTraj_self hbc hcd mf, hf.lmarginalPartialTraj_of_le d mf hac]\n  \u00b7 rw [hf.lmarginalPartialTraj_of_le c mf (hac.trans hcb),\n      hf.lmarginalPartialTraj_of_le d mf (hac.trans hcb)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Kernel/IonescuTulcea/PartialTraj.lean", "context": {"open": ["Finset Function MeasureTheory Preorder ProbabilityTheory", "scoped ENNReal", "MeasurableEquiv", "ProbabilityTheory Kernel"], "variables": ["{X : \u2115 \u2192 Type*} {mX : \u2200 n, MeasurableSpace (X n)} {a b c : \u2115}", "(\u03ba) in", "[\u2200 n, IsMarkovKernel (\u03ba n)]", "(\u03ba)", "{\u03ba}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na b c : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsMarkovKernel (\u03ba n)\nd : \u2115\nf : ((n : \u2115) \u2192 X n) \u2192 ENNReal\nmf : Measurable f\nhf : DependsOn f \u2191(Iic a)\nhac : a \u2264 c\nhad : a \u2264 d\n\u22a2 lmarginalPartialTraj \u03ba b c f = lmarginalPartialTraj \u03ba b d f"}, {"line": "wlog hcd : c \u2264 d generalizing c d", "tactic_state": "case inr\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na b c : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsMarkovKernel (\u03ba n)\nd : \u2115\nf : ((n : \u2115) \u2192 X n) \u2192 ENNReal\nmf : Measurable f\nhf : DependsOn f \u2191(Iic a)\nhac : a \u2264 c\nhad : a \u2264 d\nthis : \u2200 {c d : \u2115}, a \u2264 c \u2192 a \u2264 d \u2192 c \u2264 d \u2192 lmarginalPartialTraj \u03ba b c f = lmarginalPartialTraj \u03ba b d f\nhcd : \u00acc \u2264 d\n\u22a2 lmarginalPartialTraj \u03ba b c f = lmarginalPartialTraj \u03ba b d f\n---\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na b c\u271d : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsMarkovKernel (\u03ba n)\nf : ((n : \u2115) \u2192 X n) \u2192 ENNReal\nmf : Measurable f\nhf : DependsOn f \u2191(Iic a)\nc d : \u2115\nhac : a \u2264 c\nhad : a \u2264 d\nhcd : c \u2264 d\n\u22a2 lmarginalPartialTraj \u03ba b c f = lmarginalPartialTraj \u03ba b d f"}, {"line": "\u00b7 rw [this had hac (le_of_not_le hcd)]", "tactic_state": "X : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na b c\u271d : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsMarkovKernel (\u03ba n)\nf : ((n : \u2115) \u2192 X n) \u2192 ENNReal\nmf : Measurable f\nhf : DependsOn f \u2191(Iic a)\nc d : \u2115\nhac : a \u2264 c\nhad : a \u2264 d\nhcd : c \u2264 d\n\u22a2 lmarginalPartialTraj \u03ba b c f = lmarginalPartialTraj \u03ba b d f"}, {"line": "obtain hbc | hcb := le_total b c", "tactic_state": "case inl\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na b c\u271d : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsMarkovKernel (\u03ba n)\nf : ((n : \u2115) \u2192 X n) \u2192 ENNReal\nmf : Measurable f\nhf : DependsOn f \u2191(Iic a)\nc d : \u2115\nhac : a \u2264 c\nhad : a \u2264 d\nhcd : c \u2264 d\nhbc : b \u2264 c\n\u22a2 lmarginalPartialTraj \u03ba b c f = lmarginalPartialTraj \u03ba b d f\n---\ncase inr\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na b c\u271d : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsMarkovKernel (\u03ba n)\nf : ((n : \u2115) \u2192 X n) \u2192 ENNReal\nmf : Measurable f\nhf : DependsOn f \u2191(Iic a)\nc d : \u2115\nhac : a \u2264 c\nhad : a \u2264 d\nhcd : c \u2264 d\nhcb : c \u2264 b\n\u22a2 lmarginalPartialTraj \u03ba b c f = lmarginalPartialTraj \u03ba b d f"}, {"line": "\u00b7 rw [\u2190 lmarginalPartialTraj_self hbc hcd mf, hf.lmarginalPartialTraj_of_le d mf hac]", "tactic_state": "case inr\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na b c\u271d : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsMarkovKernel (\u03ba n)\nf : ((n : \u2115) \u2192 X n) \u2192 ENNReal\nmf : Measurable f\nhf : DependsOn f \u2191(Iic a)\nc d : \u2115\nhac : a \u2264 c\nhad : a \u2264 d\nhcd : c \u2264 d\nhcb : c \u2264 b\n\u22a2 lmarginalPartialTraj \u03ba b c f = lmarginalPartialTraj \u03ba b d f"}, {"line": "\u00b7 rw [hf.lmarginalPartialTraj_of_le c mf (hac.trans hcb),\n      hf.lmarginalPartialTraj_of_le d mf (hac.trans hcb)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem upperCrossingTime_le : upperCrossingTime a b f N n \u03c9 \u2264 N := by\n  cases n\n  \u00b7 simp only [upperCrossingTime_zero, Pi.bot_apply, bot_le]\n  \u00b7 simp only [upperCrossingTime_succ, hitting_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Martingale/Upcrossing.lean", "context": {"open": ["TopologicalSpace Filter", "scoped NNReal ENNReal MeasureTheory ProbabilityTheory Topology"], "variables": ["{\u03a9 \u03b9 : Type*} {m0 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}", "[Preorder \u03b9] [OrderBot \u03b9] [InfSet \u03b9]", "{a b : \u211d} {f : \u03b9 \u2192 \u03a9 \u2192 \u211d} {N : \u03b9} {n : \u2115} {\u03c9 : \u03a9}", "[ConditionallyCompleteLinearOrderBot \u03b9]", "{a b : \u211d} {f : \u03b9 \u2192 \u03a9 \u2192 \u211d} {N : \u03b9} {n m : \u2115} {\u03c9 : \u03a9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.2360\n\u03a9 : Type u_1\n\u03b9\u271d : Type u_2\nm0 : MeasurableSpace \u03a9\n\u03bc : sorry\ninst\u271d\u2077 : Preorder \u03b9\u271d\ninst\u271d\u2076 : OrderBot \u03b9\u271d\ninst\u271d\u2075 : InfSet \u03b9\u271d\na\u271d b\u271d : \u211d\nf\u271d : \u03b9\u271d \u2192 \u03a9 \u2192 \u211d\nN\u271d\u00b9 : \u03b9\u271d\nn\u271d : \u2115\n\u03c9\u271d : \u03a9\ninst\u271d\u2074 : ConditionallyCompleteLinearOrderBot \u03b9\u271d\na b : \u211d\nf : \u03b9\u271d \u2192 \u03a9 \u2192 \u211d\nN\u271d : \u03b9\u271d\nn m : \u2115\n\u03c9 : \u03a9\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : OrderBot \u03b9\ninst\u271d\u00b9 : InfSet \u03b9\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b9\nN : \u03b9\nx\u271d : Sort u_3\nupperCrossingTime : x\u271d\n\u22a2 sorry \u2264 N"}, {"line": "cases n", "tactic_state": "case zero\nMeasure : ?m.2360\n\u03a9 : Type u_1\n\u03b9\u271d : Type u_2\nm0 : MeasurableSpace \u03a9\n\u03bc : sorry\ninst\u271d\u2077 : Preorder \u03b9\u271d\ninst\u271d\u2076 : OrderBot \u03b9\u271d\ninst\u271d\u2075 : InfSet \u03b9\u271d\na\u271d b\u271d : \u211d\nf\u271d : \u03b9\u271d \u2192 \u03a9 \u2192 \u211d\nN\u271d\u00b9 : \u03b9\u271d\nn : \u2115\n\u03c9\u271d : \u03a9\ninst\u271d\u2074 : ConditionallyCompleteLinearOrderBot \u03b9\u271d\na b : \u211d\nf : \u03b9\u271d \u2192 \u03a9 \u2192 \u211d\nN\u271d : \u03b9\u271d\nm : \u2115\n\u03c9 : \u03a9\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : OrderBot \u03b9\ninst\u271d\u00b9 : InfSet \u03b9\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b9\nN : \u03b9\nx\u271d : Sort u_3\nupperCrossingTime : x\u271d\n\u22a2 sorry \u2264 N\n---\ncase succ\nMeasure : ?m.2360\n\u03a9 : Type u_1\n\u03b9\u271d : Type u_2\nm0 : MeasurableSpace \u03a9\n\u03bc : sorry\ninst\u271d\u2077 : Preorder \u03b9\u271d\ninst\u271d\u2076 : OrderBot \u03b9\u271d\ninst\u271d\u2075 : InfSet \u03b9\u271d\na\u271d b\u271d : \u211d\nf\u271d : \u03b9\u271d \u2192 \u03a9 \u2192 \u211d\nN\u271d\u00b9 : \u03b9\u271d\nn : \u2115\n\u03c9\u271d : \u03a9\ninst\u271d\u2074 : ConditionallyCompleteLinearOrderBot \u03b9\u271d\na b : \u211d\nf : \u03b9\u271d \u2192 \u03a9 \u2192 \u211d\nN\u271d : \u03b9\u271d\nm : \u2115\n\u03c9 : \u03a9\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : OrderBot \u03b9\ninst\u271d\u00b9 : InfSet \u03b9\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b9\nN : \u03b9\nx\u271d : Sort u_3\nupperCrossingTime : x\u271d\nn\u271d : \u2115\n\u22a2 sorry \u2264 N"}, {"line": "\u00b7 simp only [upperCrossingTime_zero, Pi.bot_apply, bot_le]", "tactic_state": "case succ\nMeasure : ?m.2360\n\u03a9 : Type u_1\n\u03b9\u271d : Type u_2\nm0 : MeasurableSpace \u03a9\n\u03bc : sorry\ninst\u271d\u2077 : Preorder \u03b9\u271d\ninst\u271d\u2076 : OrderBot \u03b9\u271d\ninst\u271d\u2075 : InfSet \u03b9\u271d\na\u271d b\u271d : \u211d\nf\u271d : \u03b9\u271d \u2192 \u03a9 \u2192 \u211d\nN\u271d\u00b9 : \u03b9\u271d\nn : \u2115\n\u03c9\u271d : \u03a9\ninst\u271d\u2074 : ConditionallyCompleteLinearOrderBot \u03b9\u271d\na b : \u211d\nf : \u03b9\u271d \u2192 \u03a9 \u2192 \u211d\nN\u271d : \u03b9\u271d\nm : \u2115\n\u03c9 : \u03a9\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : OrderBot \u03b9\ninst\u271d\u00b9 : InfSet \u03b9\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b9\nN : \u03b9\nx\u271d : Sort u_3\nupperCrossingTime : x\u271d\nn\u271d : \u2115\n\u22a2 sorry \u2264 N"}, {"line": "\u00b7 simp only [upperCrossingTime_succ, hitting_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem upcrossingsBefore_zero : upcrossingsBefore a b f 0 \u03c9 = 0 := by simp [upcrossingsBefore]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Martingale/Upcrossing.lean", "context": {"open": ["TopologicalSpace Filter", "scoped NNReal ENNReal MeasureTheory ProbabilityTheory Topology"], "variables": ["{\u03a9 \u03b9 : Type*} {m0 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}", "[Preorder \u03b9] [OrderBot \u03b9] [InfSet \u03b9]", "{a b : \u211d} {f : \u03b9 \u2192 \u03a9 \u2192 \u211d} {N : \u03b9} {n : \u2115} {\u03c9 : \u03a9}", "[ConditionallyCompleteLinearOrderBot \u03b9]", "{a b : \u211d} {f : \u03b9 \u2192 \u03a9 \u2192 \u211d} {N : \u03b9} {n m : \u2115} {\u03c9 : \u03a9}", "{a b : \u211d} {f : \u2115 \u2192 \u03a9 \u2192 \u211d} {N : \u2115} {n m : \u2115} {\u03c9 : \u03a9}", "{\u2131 : Filtration \u2115 m0}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.3835\nFiltration : ?m.3926\n\u03a9 : Type u_1\n\u03b9 : Type u_2\nm0 : MeasurableSpace \u03a9\n\u03bc : sorry\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : OrderBot \u03b9\ninst\u271d\u00b9 : InfSet \u03b9\na\u271d\u00b9 b\u271d\u00b9 : \u211d\nf\u271d\u00b9 : \u03b9 \u2192 \u03a9 \u2192 \u211d\nN\u271d\u00b9 : \u03b9\nn\u271d\u00b9 : \u2115\n\u03c9\u271d\u00b9 : \u03a9\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b9\na\u271d b\u271d : \u211d\nf\u271d : \u03b9 \u2192 \u03a9 \u2192 \u211d\nN\u271d : \u03b9\nn\u271d m\u271d : \u2115\n\u03c9\u271d : \u03a9\na b : \u211d\nf : \u2115 \u2192 \u03a9 \u2192 \u211d\nN n m : \u2115\n\u03c9 : \u03a9\n\u2131 : sorry\nx\u271d : Sort u_3\nupcrossingsBefore : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [upcrossingsBefore]", "tactic_state": "Measure : ?m.3835\nFiltration : ?m.3926\n\u03a9 : Type u_1\n\u03b9 : Type u_2\nm0 : MeasurableSpace \u03a9\n\u03bc : sorry\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : OrderBot \u03b9\ninst\u271d\u00b9 : InfSet \u03b9\na\u271d\u00b9 b\u271d\u00b9 : \u211d\nf\u271d\u00b9 : \u03b9 \u2192 \u03a9 \u2192 \u211d\nN\u271d\u00b9 : \u03b9\nn\u271d\u00b9 : \u2115\n\u03c9\u271d\u00b9 : \u03a9\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b9\na\u271d b\u271d : \u211d\nf\u271d : \u03b9 \u2192 \u03a9 \u2192 \u211d\nN\u271d : \u03b9\nn\u271d m\u271d : \u2115\n\u03c9\u271d : \u03a9\na b : \u211d\nf : \u2115 \u2192 \u03a9 \u2192 \u211d\nN n m : \u2115\n\u03c9 : \u03a9\n\u2131 : sorry\nx\u271d : Sort u_3\nupcrossingsBefore : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem upcrossingsBefore_le (f : \u2115 \u2192 \u03a9 \u2192 \u211d) (\u03c9 : \u03a9) (hab : a < b) :\n    upcrossingsBefore a b f N \u03c9 \u2264 N := by\n  by_cases hN : N = 0\n  \u00b7 subst hN\n    rw [upcrossingsBefore_zero]\n  \u00b7 refine csSup_le \u27e80, zero_lt_iff.2 hN\u27e9 fun n (hn : _ < N) => ?_\n    by_contra hnN\n    exact hn.ne (upperCrossingTime_eq_of_bound_le hab (not_le.1 hnN).le)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Martingale/Upcrossing.lean", "context": {"open": ["TopologicalSpace Filter", "scoped NNReal ENNReal MeasureTheory ProbabilityTheory Topology"], "variables": ["{\u03a9 \u03b9 : Type*} {m0 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}", "[Preorder \u03b9] [OrderBot \u03b9] [InfSet \u03b9]", "{a b : \u211d} {f : \u03b9 \u2192 \u03a9 \u2192 \u211d} {N : \u03b9} {n : \u2115} {\u03c9 : \u03a9}", "[ConditionallyCompleteLinearOrderBot \u03b9]", "{a b : \u211d} {f : \u03b9 \u2192 \u03a9 \u2192 \u211d} {N : \u03b9} {n m : \u2115} {\u03c9 : \u03a9}", "{a b : \u211d} {f : \u2115 \u2192 \u03a9 \u2192 \u211d} {N : \u2115} {n m : \u2115} {\u03c9 : \u03a9}", "{\u2131 : Filtration \u2115 m0}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.3835\nFiltration : ?m.3926\n\u03a9\u271d : Type u_1\n\u03b9 : Type u_2\nm0 : MeasurableSpace \u03a9\u271d\n\u03bc : sorry\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : OrderBot \u03b9\ninst\u271d\u00b9 : InfSet \u03b9\na\u271d\u00b2 b\u271d\u00b2 : \u211d\nf\u271d\u00b2 : \u03b9 \u2192 \u03a9\u271d \u2192 \u211d\nN\u271d\u00b2 : \u03b9\nn\u271d\u00b9 : \u2115\n\u03c9\u271d\u00b2 : \u03a9\u271d\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b9\na\u271d\u00b9 b\u271d\u00b9 : \u211d\nf\u271d\u00b9 : \u03b9 \u2192 \u03a9\u271d \u2192 \u211d\nN\u271d\u00b9 : \u03b9\nn\u271d m\u271d : \u2115\n\u03c9\u271d\u00b9 : \u03a9\u271d\na\u271d b\u271d : \u211d\nf\u271d : \u2115 \u2192 \u03a9\u271d \u2192 \u211d\nN\u271d n m : \u2115\n\u03c9\u271d : \u03a9\u271d\n\u2131 : sorry\n\u03a9 : Type u_1\na b : \u211d\nN : \u2115\nx\u271d : Sort u_3\nupcrossingsBefore : x\u271d\nf : \u2115 \u2192 \u03a9 \u2192 \u211d\n\u03c9 : \u03a9\nhab : a < b\n\u22a2 sorry \u2264 N"}, {"line": "by_cases hN : N = 0", "tactic_state": "case pos\nMeasure : ?m.3835\nFiltration : ?m.3926\n\u03a9\u271d : Type u_1\n\u03b9 : Type u_2\nm0 : MeasurableSpace \u03a9\u271d\n\u03bc : sorry\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : OrderBot \u03b9\ninst\u271d\u00b9 : InfSet \u03b9\na\u271d\u00b2 b\u271d\u00b2 : \u211d\nf\u271d\u00b2 : \u03b9 \u2192 \u03a9\u271d \u2192 \u211d\nN\u271d\u00b2 : \u03b9\nn\u271d\u00b9 : \u2115\n\u03c9\u271d\u00b2 : \u03a9\u271d\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b9\na\u271d\u00b9 b\u271d\u00b9 : \u211d\nf\u271d\u00b9 : \u03b9 \u2192 \u03a9\u271d \u2192 \u211d\nN\u271d\u00b9 : \u03b9\nn\u271d m\u271d : \u2115\n\u03c9\u271d\u00b9 : \u03a9\u271d\na\u271d b\u271d : \u211d\nf\u271d : \u2115 \u2192 \u03a9\u271d \u2192 \u211d\nN\u271d n m : \u2115\n\u03c9\u271d : \u03a9\u271d\n\u2131 : sorry\n\u03a9 : Type u_1\na b : \u211d\nN : \u2115\nx\u271d : Sort u_3\nupcrossingsBefore : x\u271d\nf : \u2115 \u2192 \u03a9 \u2192 \u211d\n\u03c9 : \u03a9\nhab : a < b\nhN : N = 0\n\u22a2 sorry \u2264 N\n---\ncase neg\nMeasure : ?m.3835\nFiltration : ?m.3926\n\u03a9\u271d : Type u_1\n\u03b9 : Type u_2\nm0 : MeasurableSpace \u03a9\u271d\n\u03bc : sorry\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : OrderBot \u03b9\ninst\u271d\u00b9 : InfSet \u03b9\na\u271d\u00b2 b\u271d\u00b2 : \u211d\nf\u271d\u00b2 : \u03b9 \u2192 \u03a9\u271d \u2192 \u211d\nN\u271d\u00b2 : \u03b9\nn\u271d\u00b9 : \u2115\n\u03c9\u271d\u00b2 : \u03a9\u271d\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b9\na\u271d\u00b9 b\u271d\u00b9 : \u211d\nf\u271d\u00b9 : \u03b9 \u2192 \u03a9\u271d \u2192 \u211d\nN\u271d\u00b9 : \u03b9\nn\u271d m\u271d : \u2115\n\u03c9\u271d\u00b9 : \u03a9\u271d\na\u271d b\u271d : \u211d\nf\u271d : \u2115 \u2192 \u03a9\u271d \u2192 \u211d\nN\u271d n m : \u2115\n\u03c9\u271d : \u03a9\u271d\n\u2131 : sorry\n\u03a9 : Type u_1\na b : \u211d\nN : \u2115\nx\u271d : Sort u_3\nupcrossingsBefore : x\u271d\nf : \u2115 \u2192 \u03a9 \u2192 \u211d\n\u03c9 : \u03a9\nhab : a < b\nhN : \u00acN = 0\n\u22a2 sorry \u2264 N"}, {"line": "\u00b7 subst hN\n    rw [upcrossingsBefore_zero]", "tactic_state": "case neg\nMeasure : ?m.3835\nFiltration : ?m.3926\n\u03a9\u271d : Type u_1\n\u03b9 : Type u_2\nm0 : MeasurableSpace \u03a9\u271d\n\u03bc : sorry\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : OrderBot \u03b9\ninst\u271d\u00b9 : InfSet \u03b9\na\u271d\u00b2 b\u271d\u00b2 : \u211d\nf\u271d\u00b2 : \u03b9 \u2192 \u03a9\u271d \u2192 \u211d\nN\u271d\u00b2 : \u03b9\nn\u271d\u00b9 : \u2115\n\u03c9\u271d\u00b2 : \u03a9\u271d\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b9\na\u271d\u00b9 b\u271d\u00b9 : \u211d\nf\u271d\u00b9 : \u03b9 \u2192 \u03a9\u271d \u2192 \u211d\nN\u271d\u00b9 : \u03b9\nn\u271d m\u271d : \u2115\n\u03c9\u271d\u00b9 : \u03a9\u271d\na\u271d b\u271d : \u211d\nf\u271d : \u2115 \u2192 \u03a9\u271d \u2192 \u211d\nN\u271d n m : \u2115\n\u03c9\u271d : \u03a9\u271d\n\u2131 : sorry\n\u03a9 : Type u_1\na b : \u211d\nN : \u2115\nx\u271d : Sort u_3\nupcrossingsBefore : x\u271d\nf : \u2115 \u2192 \u03a9 \u2192 \u211d\n\u03c9 : \u03a9\nhab : a < b\nhN : \u00acN = 0\n\u22a2 sorry \u2264 N"}, {"line": "\u00b7 refine csSup_le \u27e80, zero_lt_iff.2 hN\u27e9 fun n (hn : _ < N) => ?_\n    by_contra hnN\n    exact hn.ne (upperCrossingTime_eq_of_bound_le hab (not_le.1 hnN).le)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem upperCrossingTime_eq_upperCrossingTime_of_lt {M : \u2115} (hNM : N \u2264 M)\n    (h : upperCrossingTime a b f N n \u03c9 < N) :\n    upperCrossingTime a b f M n \u03c9 = upperCrossingTime a b f N n \u03c9 := by\n  cases n\n  \u00b7 simp\n  \u00b7 exact (crossing_eq_crossing_of_upperCrossingTime_lt hNM h).1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Martingale/Upcrossing.lean", "context": {"open": ["TopologicalSpace Filter", "scoped NNReal ENNReal MeasureTheory ProbabilityTheory Topology"], "variables": ["{\u03a9 \u03b9 : Type*} {m0 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}", "[Preorder \u03b9] [OrderBot \u03b9] [InfSet \u03b9]", "{a b : \u211d} {f : \u03b9 \u2192 \u03a9 \u2192 \u211d} {N : \u03b9} {n : \u2115} {\u03c9 : \u03a9}", "[ConditionallyCompleteLinearOrderBot \u03b9]", "{a b : \u211d} {f : \u03b9 \u2192 \u03a9 \u2192 \u211d} {N : \u03b9} {n m : \u2115} {\u03c9 : \u03a9}", "{a b : \u211d} {f : \u2115 \u2192 \u03a9 \u2192 \u211d} {N : \u2115} {n m : \u2115} {\u03c9 : \u03a9}", "{\u2131 : Filtration \u2115 m0}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.3835\nFiltration : ?m.3926\n\u03a9 : Type u_1\n\u03b9 : Type u_2\nm0 : MeasurableSpace \u03a9\n\u03bc : sorry\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : OrderBot \u03b9\ninst\u271d\u00b9 : InfSet \u03b9\na\u271d\u00b9 b\u271d\u00b9 : \u211d\nf\u271d\u00b9 : \u03b9 \u2192 \u03a9 \u2192 \u211d\nN\u271d\u00b2 : \u03b9\nn\u271d\u00b9 : \u2115\n\u03c9\u271d\u00b9 : \u03a9\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b9\na\u271d b\u271d : \u211d\nf\u271d : \u03b9 \u2192 \u03a9 \u2192 \u211d\nN\u271d\u00b9 : \u03b9\nn\u271d m\u271d : \u2115\n\u03c9\u271d : \u03a9\na b : \u211d\nf : \u2115 \u2192 \u03a9 \u2192 \u211d\nN\u271d n m : \u2115\n\u03c9 : \u03a9\n\u2131 : sorry\nN : \u2115\nx\u271d : Sort u_3\nupperCrossingTime : x\u271d\nM : \u2115\nhNM : N \u2264 M\nh : sorry < N\n\u22a2 sorry = sorry"}, {"line": "cases n", "tactic_state": "case zero\nMeasure : ?m.3835\nFiltration : ?m.3926\n\u03a9 : Type u_1\n\u03b9 : Type u_2\nm0 : MeasurableSpace \u03a9\n\u03bc : sorry\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : OrderBot \u03b9\ninst\u271d\u00b9 : InfSet \u03b9\na\u271d\u00b9 b\u271d\u00b9 : \u211d\nf\u271d\u00b9 : \u03b9 \u2192 \u03a9 \u2192 \u211d\nN\u271d\u00b2 : \u03b9\nn\u271d : \u2115\n\u03c9\u271d\u00b9 : \u03a9\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b9\na\u271d b\u271d : \u211d\nf\u271d : \u03b9 \u2192 \u03a9 \u2192 \u211d\nN\u271d\u00b9 : \u03b9\nn m\u271d : \u2115\n\u03c9\u271d : \u03a9\na b : \u211d\nf : \u2115 \u2192 \u03a9 \u2192 \u211d\nN\u271d m : \u2115\n\u03c9 : \u03a9\n\u2131 : sorry\nN : \u2115\nx\u271d : Sort u_3\nupperCrossingTime : x\u271d\nM : \u2115\nhNM : N \u2264 M\nh : sorry < N\n\u22a2 sorry = sorry\n---\ncase succ\nMeasure : ?m.3835\nFiltration : ?m.3926\n\u03a9 : Type u_1\n\u03b9 : Type u_2\nm0 : MeasurableSpace \u03a9\n\u03bc : sorry\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : OrderBot \u03b9\ninst\u271d\u00b9 : InfSet \u03b9\na\u271d\u00b9 b\u271d\u00b9 : \u211d\nf\u271d\u00b9 : \u03b9 \u2192 \u03a9 \u2192 \u211d\nN\u271d\u00b2 : \u03b9\nn\u271d\u00b9 : \u2115\n\u03c9\u271d\u00b9 : \u03a9\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b9\na\u271d b\u271d : \u211d\nf\u271d : \u03b9 \u2192 \u03a9 \u2192 \u211d\nN\u271d\u00b9 : \u03b9\nn m\u271d : \u2115\n\u03c9\u271d : \u03a9\na b : \u211d\nf : \u2115 \u2192 \u03a9 \u2192 \u211d\nN\u271d m : \u2115\n\u03c9 : \u03a9\n\u2131 : sorry\nN : \u2115\nx\u271d : Sort u_3\nupperCrossingTime : x\u271d\nM : \u2115\nhNM : N \u2264 M\nh : sorry < N\nn\u271d : \u2115\n\u22a2 sorry = sorry"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nMeasure : ?m.3835\nFiltration : ?m.3926\n\u03a9 : Type u_1\n\u03b9 : Type u_2\nm0 : MeasurableSpace \u03a9\n\u03bc : sorry\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : OrderBot \u03b9\ninst\u271d\u00b9 : InfSet \u03b9\na\u271d\u00b9 b\u271d\u00b9 : \u211d\nf\u271d\u00b9 : \u03b9 \u2192 \u03a9 \u2192 \u211d\nN\u271d\u00b2 : \u03b9\nn\u271d\u00b9 : \u2115\n\u03c9\u271d\u00b9 : \u03a9\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b9\na\u271d b\u271d : \u211d\nf\u271d : \u03b9 \u2192 \u03a9 \u2192 \u211d\nN\u271d\u00b9 : \u03b9\nn m\u271d : \u2115\n\u03c9\u271d : \u03a9\na b : \u211d\nf : \u2115 \u2192 \u03a9 \u2192 \u211d\nN\u271d m : \u2115\n\u03c9 : \u03a9\n\u2131 : sorry\nN : \u2115\nx\u271d : Sort u_3\nupperCrossingTime : x\u271d\nM : \u2115\nhNM : N \u2264 M\nh : sorry < N\nn\u271d : \u2115\n\u22a2 sorry = sorry"}, {"line": "\u00b7 exact (crossing_eq_crossing_of_upperCrossingTime_lt hNM h).1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iteratedDeriv_mgf_zero (h : 0 \u2208 interior (integrableExpSet X \u03bc)) (n : \u2115) :\n    iteratedDeriv n (mgf X \u03bc) 0 = \u03bc[X ^ n] := by\n  simp [iteratedDeriv_mgf h n]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/MGFAnalytic.lean", "context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal Topology Nat"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {\u03bc : Measure \u03a9} {t u v : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nx\u271d\u00b9 : Sort u_3\nintegrableExpSet : x\u271d\u00b9\nx\u271d : Sort u_4\nmgf : x\u271d\nh : 0 \u2208 interior sorry\nn : \u2115\n\u22a2 iteratedDeriv n sorry 0 = \u222b (x : \u03a9), (X ^ n) x \u2202\u03bc"}, {"line": "simp [iteratedDeriv_mgf h n]", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nx\u271d\u00b9 : Sort u_3\nintegrableExpSet : x\u271d\u00b9\nx\u271d : Sort u_4\nmgf : x\u271d\nh : 0 \u2208 interior sorry\nn : \u2115\n\u22a2 iteratedDeriv n (sorry ()) 0 = \u222b (x : \u03a9), X x ^ n \u2202\u03bc"}]}
{"declaration": "lemma deriv_mgf_zero (h : 0 \u2208 interior (integrableExpSet X \u03bc)) : deriv (mgf X \u03bc) 0 = \u03bc[X] := by\n  simp [deriv_mgf h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/MGFAnalytic.lean", "context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal Topology Nat"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {\u03bc : Measure \u03a9} {t u v : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nx\u271d\u00b9 : Sort u_3\nintegrableExpSet : x\u271d\u00b9\nx\u271d : Sort u_4\nmgf : x\u271d\nh : 0 \u2208 interior sorry\n\u22a2 deriv sorry 0 = \u222b (x : \u03a9), X x \u2202\u03bc"}, {"line": "simp [deriv_mgf h]", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nx\u271d\u00b9 : Sort u_3\nintegrableExpSet : x\u271d\u00b9\nx\u271d : Sort u_4\nmgf : x\u271d\nh : 0 \u2208 interior sorry\n\u22a2 deriv (sorry ()) 0 = \u222b (x : \u03a9), X x \u2202\u03bc"}]}
{"declaration": "lemma deriv_cgf_zero (h : 0 \u2208 interior (integrableExpSet X \u03bc)) :\n    deriv (cgf X \u03bc) 0 = \u03bc[X] / \u03bc.real Set.univ := by simp [deriv_cgf h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/MGFAnalytic.lean", "context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal Topology Nat"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {\u03bc : Measure \u03a9} {t u v : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nx\u271d\u00b9 : Sort u_3\nintegrableExpSet : x\u271d\u00b9\nx\u271d : Sort u_4\ncgf : x\u271d\nh : 0 \u2208 interior sorry\n\u22a2 deriv sorry 0 = (\u222b (x : \u03a9), X x \u2202\u03bc) / \u03bc.real Set.univ"}, {"line": "simp [deriv_cgf h]", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nx\u271d\u00b9 : Sort u_3\nintegrableExpSet : x\u271d\u00b9\nx\u271d : Sort u_4\ncgf : x\u271d\nh : 0 \u2208 interior sorry\n\u22a2 deriv (sorry ()) 0 = (\u222b (x : \u03a9), X x \u2202\u03bc) / \u03bc.real Set.univ"}]}
{"declaration": "lemma tilted_mul_apply_cgf' {s : Set \u03a9} (hs : MeasurableSet s)\n    (ht : Integrable (fun \u03c9 \u21a6 exp (t * X \u03c9)) \u03bc) :\n    \u03bc.tilted (t * X \u00b7) s = \u222b\u207b a in s, ENNReal.ofReal (exp (t * X a - cgf X \u03bc t)) \u2202\u03bc := by\n  rcases eq_zero_or_neZero \u03bc with rfl | h\u03bc\n  \u00b7 simp\n  \u00b7 simp_rw [tilted_mul_apply_mgf' hs, exp_sub, exp_cgf ht]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/Tilted.lean", "context": {"open": ["MeasureTheory Real Set Finset", "scoped NNReal ENNReal ProbabilityTheory"], "variables": ["{\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9} {\u03bc \u03bd : Measure \u03a9} {X : \u03a9 \u2192 \u211d} {t u : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nX : \u03a9 \u2192 \u211d\nt : \u211d\nx\u271d : Sort u_2\ncgf : x\u271d\ns : Set \u03a9\nhs : MeasurableSet s\nht : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\n\u22a2 (\u03bc.tilted fun x => t * X x) s = \u222b\u207b (a : \u03a9) in s, ENNReal.ofReal (exp (t * X a - sorry)) \u2202\u03bc"}, {"line": "rcases eq_zero_or_neZero \u03bc with rfl | h\u03bc", "tactic_state": "case inl\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\nt : \u211d\nx\u271d : Sort u_2\ncgf : x\u271d\ns : Set \u03a9\nhs : MeasurableSet s\nht : Integrable (fun \u03c9 => exp (t * X \u03c9)) 0\n\u22a2 (Measure.tilted 0 fun x => t * X x) s = \u222b\u207b (a : \u03a9) in s, ENNReal.ofReal (exp (t * X a - sorry)) \u22020\n---\ncase inr\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nX : \u03a9 \u2192 \u211d\nt : \u211d\nx\u271d : Sort u_2\ncgf : x\u271d\ns : Set \u03a9\nhs : MeasurableSet s\nht : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\nh\u03bc : NeZero \u03bc\n\u22a2 (\u03bc.tilted fun x => t * X x) s = \u222b\u207b (a : \u03a9) in s, ENNReal.ofReal (exp (t * X a - sorry)) \u2202\u03bc"}, {"line": "\u00b7 simp", "tactic_state": "case inr\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nX : \u03a9 \u2192 \u211d\nt : \u211d\nx\u271d : Sort u_2\ncgf : x\u271d\ns : Set \u03a9\nhs : MeasurableSet s\nht : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\nh\u03bc : NeZero \u03bc\n\u22a2 (\u03bc.tilted fun x => t * X x) s = \u222b\u207b (a : \u03a9) in s, ENNReal.ofReal (exp (t * X a - sorry)) \u2202\u03bc"}, {"line": "\u00b7 simp_rw [tilted_mul_apply_mgf' hs, exp_sub, exp_cgf ht]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tilted_mul_apply_cgf [SFinite \u03bc] (s : Set \u03a9) (ht : Integrable (fun \u03c9 \u21a6 exp (t * X \u03c9)) \u03bc) :\n    \u03bc.tilted (t * X \u00b7) s = \u222b\u207b a in s, ENNReal.ofReal (exp (t * X a - cgf X \u03bc t)) \u2202\u03bc := by\n  rcases eq_zero_or_neZero \u03bc with rfl | h\u03bc\n  \u00b7 simp\n  \u00b7 simp_rw [tilted_mul_apply_mgf s, exp_sub, exp_cgf ht]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/Tilted.lean", "context": {"open": ["MeasureTheory Real Set Finset", "scoped NNReal ENNReal ProbabilityTheory"], "variables": ["{\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9} {\u03bc \u03bd : Measure \u03a9} {X : \u03a9 \u2192 \u211d} {t u : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nX : \u03a9 \u2192 \u211d\nt : \u211d\nx\u271d : Sort u_2\ncgf : x\u271d\ninst\u271d : SFinite \u03bc\ns : Set \u03a9\nht : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\n\u22a2 (\u03bc.tilted fun x => t * X x) s = \u222b\u207b (a : \u03a9) in s, ENNReal.ofReal (exp (t * X a - sorry)) \u2202\u03bc"}, {"line": "rcases eq_zero_or_neZero \u03bc with rfl | h\u03bc", "tactic_state": "case inl\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\nt : \u211d\nx\u271d : Sort u_2\ncgf : x\u271d\ns : Set \u03a9\ninst\u271d : SFinite 0\nht : Integrable (fun \u03c9 => exp (t * X \u03c9)) 0\n\u22a2 (Measure.tilted 0 fun x => t * X x) s = \u222b\u207b (a : \u03a9) in s, ENNReal.ofReal (exp (t * X a - sorry)) \u22020\n---\ncase inr\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nX : \u03a9 \u2192 \u211d\nt : \u211d\nx\u271d : Sort u_2\ncgf : x\u271d\ninst\u271d : SFinite \u03bc\ns : Set \u03a9\nht : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\nh\u03bc : NeZero \u03bc\n\u22a2 (\u03bc.tilted fun x => t * X x) s = \u222b\u207b (a : \u03a9) in s, ENNReal.ofReal (exp (t * X a - sorry)) \u2202\u03bc"}, {"line": "\u00b7 simp", "tactic_state": "case inr\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nX : \u03a9 \u2192 \u211d\nt : \u211d\nx\u271d : Sort u_2\ncgf : x\u271d\ninst\u271d : SFinite \u03bc\ns : Set \u03a9\nht : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\nh\u03bc : NeZero \u03bc\n\u22a2 (\u03bc.tilted fun x => t * X x) s = \u222b\u207b (a : \u03a9) in s, ENNReal.ofReal (exp (t * X a - sorry)) \u2202\u03bc"}, {"line": "\u00b7 simp_rw [tilted_mul_apply_mgf s, exp_sub, exp_cgf ht]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma setIntegral_tilted_mul_eq_cgf' (g : \u03a9 \u2192 E) {s : Set \u03a9}\n    (hs : MeasurableSet s) (ht : Integrable (fun \u03c9 \u21a6 exp (t * X \u03c9)) \u03bc) :\n    \u222b x in s, g x \u2202(\u03bc.tilted (t * X \u00b7)) = \u222b x in s, exp (t * X x - cgf X \u03bc t) \u2022 (g x) \u2202\u03bc := by\n  rcases eq_zero_or_neZero \u03bc with rfl | h\u03bc\n  \u00b7 simp\n  \u00b7 simp_rw [setIntegral_tilted_mul_eq_mgf' _ hs, exp_sub, exp_cgf ht]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/Tilted.lean", "context": {"open": ["MeasureTheory Real Set Finset", "scoped NNReal ENNReal ProbabilityTheory"], "variables": ["{\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9} {\u03bc \u03bd : Measure \u03a9} {X : \u03a9 \u2192 \u211d} {t u : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nX : \u03a9 \u2192 \u211d\nt : \u211d\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx\u271d : Sort u_3\ncgf : x\u271d\ng : \u03a9 \u2192 E\ns : Set \u03a9\nhs : MeasurableSet s\nht : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\n\u22a2 (\u222b (x : \u03a9) in s, g x \u2202\u03bc.tilted fun x => t * X x) = \u222b (x : \u03a9) in s, exp (t * X x - sorry) \u2022 g x \u2202\u03bc"}, {"line": "rcases eq_zero_or_neZero \u03bc with rfl | h\u03bc", "tactic_state": "case inl\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\nt : \u211d\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx\u271d : Sort u_3\ncgf : x\u271d\ng : \u03a9 \u2192 E\ns : Set \u03a9\nhs : MeasurableSet s\nht : Integrable (fun \u03c9 => exp (t * X \u03c9)) 0\n\u22a2 (\u222b (x : \u03a9) in s, g x \u2202Measure.tilted 0 fun x => t * X x) = \u222b (x : \u03a9) in s, exp (t * X x - sorry) \u2022 g x \u22020\n---\ncase inr\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nX : \u03a9 \u2192 \u211d\nt : \u211d\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx\u271d : Sort u_3\ncgf : x\u271d\ng : \u03a9 \u2192 E\ns : Set \u03a9\nhs : MeasurableSet s\nht : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\nh\u03bc : NeZero \u03bc\n\u22a2 (\u222b (x : \u03a9) in s, g x \u2202\u03bc.tilted fun x => t * X x) = \u222b (x : \u03a9) in s, exp (t * X x - sorry) \u2022 g x \u2202\u03bc"}, {"line": "\u00b7 simp", "tactic_state": "case inr\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nX : \u03a9 \u2192 \u211d\nt : \u211d\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx\u271d : Sort u_3\ncgf : x\u271d\ng : \u03a9 \u2192 E\ns : Set \u03a9\nhs : MeasurableSet s\nht : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\nh\u03bc : NeZero \u03bc\n\u22a2 (\u222b (x : \u03a9) in s, g x \u2202\u03bc.tilted fun x => t * X x) = \u222b (x : \u03a9) in s, exp (t * X x - sorry) \u2022 g x \u2202\u03bc"}, {"line": "\u00b7 simp_rw [setIntegral_tilted_mul_eq_mgf' _ hs, exp_sub, exp_cgf ht]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma setIntegral_tilted_mul_eq_cgf [SFinite \u03bc] (g : \u03a9 \u2192 E) (s : Set \u03a9)\n    (ht : Integrable (fun \u03c9 \u21a6 exp (t * X \u03c9)) \u03bc) :\n    \u222b x in s, g x \u2202(\u03bc.tilted (t * X \u00b7)) = \u222b x in s, exp (t * X x - cgf X \u03bc t) \u2022 (g x) \u2202\u03bc := by\n  rcases eq_zero_or_neZero \u03bc with rfl | h\u03bc\n  \u00b7 simp\n  \u00b7 simp_rw [setIntegral_tilted_mul_eq_mgf, exp_sub, exp_cgf ht]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/Tilted.lean", "context": {"open": ["MeasureTheory Real Set Finset", "scoped NNReal ENNReal ProbabilityTheory"], "variables": ["{\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9} {\u03bc \u03bd : Measure \u03a9} {X : \u03a9 \u2192 \u211d} {t u : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nX : \u03a9 \u2192 \u211d\nt : \u211d\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\nx\u271d : Sort u_3\ncgf : x\u271d\ninst\u271d : SFinite \u03bc\ng : \u03a9 \u2192 E\ns : Set \u03a9\nht : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\n\u22a2 (\u222b (x : \u03a9) in s, g x \u2202\u03bc.tilted fun x => t * X x) = \u222b (x : \u03a9) in s, exp (t * X x - sorry) \u2022 g x \u2202\u03bc"}, {"line": "rcases eq_zero_or_neZero \u03bc with rfl | h\u03bc", "tactic_state": "case inl\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\nt : \u211d\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\nx\u271d : Sort u_3\ncgf : x\u271d\ng : \u03a9 \u2192 E\ns : Set \u03a9\ninst\u271d : SFinite 0\nht : Integrable (fun \u03c9 => exp (t * X \u03c9)) 0\n\u22a2 (\u222b (x : \u03a9) in s, g x \u2202Measure.tilted 0 fun x => t * X x) = \u222b (x : \u03a9) in s, exp (t * X x - sorry) \u2022 g x \u22020\n---\ncase inr\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nX : \u03a9 \u2192 \u211d\nt : \u211d\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\nx\u271d : Sort u_3\ncgf : x\u271d\ninst\u271d : SFinite \u03bc\ng : \u03a9 \u2192 E\ns : Set \u03a9\nht : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\nh\u03bc : NeZero \u03bc\n\u22a2 (\u222b (x : \u03a9) in s, g x \u2202\u03bc.tilted fun x => t * X x) = \u222b (x : \u03a9) in s, exp (t * X x - sorry) \u2022 g x \u2202\u03bc"}, {"line": "\u00b7 simp", "tactic_state": "case inr\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nX : \u03a9 \u2192 \u211d\nt : \u211d\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\nx\u271d : Sort u_3\ncgf : x\u271d\ninst\u271d : SFinite \u03bc\ng : \u03a9 \u2192 E\ns : Set \u03a9\nht : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\nh\u03bc : NeZero \u03bc\n\u22a2 (\u222b (x : \u03a9) in s, g x \u2202\u03bc.tilted fun x => t * X x) = \u222b (x : \u03a9) in s, exp (t * X x - sorry) \u2022 g x \u2202\u03bc"}, {"line": "\u00b7 simp_rw [setIntegral_tilted_mul_eq_mgf, exp_sub, exp_cgf ht]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma moment_zero_measure : moment X p (0 : Measure \u03a9) = 0 := by simp [moment]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/Basic.lean", "context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {p : \u2115} {\u03bc : Measure \u03a9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nmoment : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [moment]", "tactic_state": "x\u271d : Sort u_3\nmoment : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma centralMoment_zero_measure : centralMoment X p (0 : Measure \u03a9) = 0 := by\n  simp [centralMoment]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/Basic.lean", "context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {p : \u2115} {\u03bc : Measure \u03a9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\ncentralMoment : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [centralMoment]", "tactic_state": "x\u271d : Sort u_3\ncentralMoment : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem mgf_const (c : \u211d) [IsProbabilityMeasure \u03bc] : mgf (fun _ => c) \u03bc t = exp (t * c) := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/Basic.lean", "context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {p : \u2115} {\u03bc : Measure \u03a9}", "{t : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nt : \u211d\nx\u271d : Sort u_3\nmgf : x\u271d\nc : \u211d\ninst\u271d : IsProbabilityMeasure \u03bc\n\u22a2 sorry = exp (t * c)"}, {"line": "simp", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nt : \u211d\nx\u271d : Sort u_3\nmgf : x\u271d\nc : \u211d\ninst\u271d : IsProbabilityMeasure \u03bc\n\u22a2 sorry () = exp (t * c)"}]}
{"declaration": "theorem mgf_zero [IsProbabilityMeasure \u03bc] : mgf X \u03bc 0 = 1 := by\n  simp [mgf_zero']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/Basic.lean", "context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {p : \u2115} {\u03bc : Measure \u03a9}", "{t : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nx\u271d : Sort u_3\nmgf : x\u271d\ninst\u271d : IsProbabilityMeasure \u03bc\n\u22a2 sorry = 1"}, {"line": "simp [mgf_zero']", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nx\u271d : Sort u_3\nmgf : x\u271d\ninst\u271d : IsProbabilityMeasure \u03bc\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem cgf_zero [IsZeroOrProbabilityMeasure \u03bc] : cgf X \u03bc 0 = 0 := by\n  rcases eq_zero_or_isProbabilityMeasure \u03bc with rfl | h <;> simp [cgf_zero']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/Basic.lean", "context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {p : \u2115} {\u03bc : Measure \u03a9}", "{t : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nx\u271d : Sort u_3\ncgf : x\u271d\ninst\u271d : IsZeroOrProbabilityMeasure \u03bc\n\u22a2 sorry = 0"}, {"line": "rcases eq_zero_or_isProbabilityMeasure \u03bc with rfl | h <;> simp [cgf_zero']", "tactic_state": "case succ\n\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nx\u271d : Sort u_3\ncgf : x\u271d\ninst\u271d : IsZeroOrProbabilityMeasure \u03bc\nh : \u2115\n\u22a2 False"}]}
{"declaration": "lemma mgf_pos_iff [h\u03bc : NeZero \u03bc] :\n    0 < mgf X \u03bc t \u2194 Integrable (fun \u03c9 \u21a6 exp (t * X \u03c9)) \u03bc := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 mgf_pos' h\u03bc.out h\u27e9\n  contrapose! h with h\n  simp [mgf_undef h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/Basic.lean", "context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {p : \u2115} {\u03bc : Measure \u03a9}", "{t : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nt : \u211d\nx\u271d : Sort u_3\nmgf : x\u271d\nh\u03bc : NeZero \u03bc\n\u22a2 0 < sorry \u2194 Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 mgf_pos' h\u03bc.out h\u27e9", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nt : \u211d\nx\u271d : Sort u_3\nmgf : x\u271d\nh\u03bc : NeZero \u03bc\nh : 0 < sorry\n\u22a2 Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc"}, {"line": "contrapose! h with h", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nt : \u211d\nx\u271d : Sort u_3\nmgf : x\u271d\nh\u03bc : NeZero \u03bc\nh : \u00acIntegrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\n\u22a2 sorry \u2264 0"}, {"line": "simp [mgf_undef h]", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nt : \u211d\nx\u271d : Sort u_3\nmgf : x\u271d\nh\u03bc : NeZero \u03bc\nh : \u00acIntegrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem IndepFun.exp_mul {X Y : \u03a9 \u2192 \u211d} (h_indep : IndepFun X Y \u03bc) (s t : \u211d) :\n    IndepFun (fun \u03c9 => exp (s * X \u03c9)) (fun \u03c9 => exp (t * Y \u03c9)) \u03bc := by\n  have h_meas : \u2200 t, Measurable fun x => exp (t * x) := fun t => (measurable_id'.const_mul t).exp\n  change IndepFun ((fun x => exp (s * x)) \u2218 X) ((fun x => exp (t * x)) \u2218 Y) \u03bc\n  exact IndepFun.comp h_indep (h_meas s) (h_meas t)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/Basic.lean", "context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {p : \u2115} {\u03bc : Measure \u03a9}", "{t : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nx\u271d : Sort u_3\nIndepFun : x\u271d\nX Y : \u03a9 \u2192 \u211d\nh_indep : sorry\ns t : \u211d\n\u22a2 sorry"}, {"line": "have h_meas : \u2200 t, Measurable fun x => exp (t * x) := fun t => (measurable_id'.const_mul t).exp", "tactic_state": "\u03a9 : Type u_1\nx\u271d : Sort u_3\nIndepFun : x\u271d\nX Y : \u03a9 \u2192 \u211d\nh_indep : sorry\ns t : \u211d\nh_meas : \u2200 (t : \u211d), Measurable fun x => exp (t * x)\n\u22a2 sorry"}, {"line": "change IndepFun ((fun x => exp (s * x)) \u2218 X) ((fun x => exp (t * x)) \u2218 Y) \u03bc", "tactic_state": "\u03a9 : Type u_1\nx\u271d : Sort u_3\nIndepFun : x\u271d\nX Y : \u03a9 \u2192 \u211d\nh_indep : sorry\ns t : \u211d\nh_meas : \u2200 (t : \u211d), Measurable fun x => exp (t * x)\n\u22a2 sorry"}, {"line": "exact IndepFun.comp h_indep (h_meas s) (h_meas t)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aestronglyMeasurable_exp_mul_add {X Y : \u03a9 \u2192 \u211d}\n    (h_int_X : AEStronglyMeasurable (fun \u03c9 => exp (t * X \u03c9)) \u03bc)\n    (h_int_Y : AEStronglyMeasurable (fun \u03c9 => exp (t * Y \u03c9)) \u03bc) :\n    AEStronglyMeasurable (fun \u03c9 => exp (t * (X + Y) \u03c9)) \u03bc := by\n  simp_rw [Pi.add_apply, mul_add, exp_add]\n  exact AEStronglyMeasurable.mul h_int_X h_int_Y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/Basic.lean", "context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {p : \u2115} {\u03bc : Measure \u03a9}", "{t : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nt : \u211d\nX Y : \u03a9 \u2192 \u211d\nh_int_X : AEStronglyMeasurable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\nh_int_Y : AEStronglyMeasurable (fun \u03c9 => exp (t * Y \u03c9)) \u03bc\n\u22a2 AEStronglyMeasurable (fun \u03c9 => exp (t * (X + Y) \u03c9)) \u03bc"}, {"line": "simp_rw [Pi.add_apply, mul_add, exp_add]", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nt : \u211d\nX Y : \u03a9 \u2192 \u211d\nh_int_X : AEStronglyMeasurable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\nh_int_Y : AEStronglyMeasurable (fun \u03c9 => exp (t * Y \u03c9)) \u03bc\n\u22a2 AEStronglyMeasurable (fun \u03c9 => exp (t * X \u03c9) * exp (t * Y \u03c9)) \u03bc"}, {"line": "exact AEStronglyMeasurable.mul h_int_X h_int_Y", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IndepFun.integrable_exp_mul_add {X Y : \u03a9 \u2192 \u211d} (h_indep : IndepFun X Y \u03bc)\n    (h_int_X : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc)\n    (h_int_Y : Integrable (fun \u03c9 => exp (t * Y \u03c9)) \u03bc) :\n    Integrable (fun \u03c9 => exp (t * (X + Y) \u03c9)) \u03bc := by\n  simp_rw [Pi.add_apply, mul_add, exp_add]\n  exact (h_indep.exp_mul t t).integrable_mul h_int_X h_int_Y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/Basic.lean", "context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {p : \u2115} {\u03bc : Measure \u03a9}", "{t : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nt : \u211d\nx\u271d : Sort u_3\nIndepFun : x\u271d\nX Y : \u03a9 \u2192 \u211d\nh_indep : sorry\nh_int_X : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\nh_int_Y : Integrable (fun \u03c9 => exp (t * Y \u03c9)) \u03bc\n\u22a2 Integrable (fun \u03c9 => exp (t * (X + Y) \u03c9)) \u03bc"}, {"line": "simp_rw [Pi.add_apply, mul_add, exp_add]", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nt : \u211d\nx\u271d : Sort u_3\nIndepFun : x\u271d\nX Y : \u03a9 \u2192 \u211d\nh_indep : sorry\nh_int_X : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc\nh_int_Y : Integrable (fun \u03c9 => exp (t * Y \u03c9)) \u03bc\n\u22a2 Integrable (fun \u03c9 => exp (t * X \u03c9) * exp (t * Y \u03c9)) \u03bc"}, {"line": "exact (h_indep.exp_mul t t).integrable_mul h_int_X h_int_Y", "tactic_state": "No Goals!"}]}
{"declaration": "lemma re_complexMGF_ofReal (x : \u211d) : (complexMGF X \u03bc x).re = mgf X \u03bc x := by\n  simp [complexMGF_ofReal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/ComplexMGF.lean", "context": {"open": ["MeasureTheory Filter Finset Real Complex", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal Topology"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {\u03bc : Measure \u03a9} {t u v : \u211d} {z \u03b5 : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_3\ncomplexMGF : x\u271d\u00b9\nx\u271d : Sort u_4\nmgf : x\u271d\nx : \u211d\n\u22a2 sorry = sorry"}, {"line": "simp [complexMGF_ofReal]", "tactic_state": "x\u271d\u00b9 : Sort u_3\ncomplexMGF : x\u271d\u00b9\nx\u271d : Sort u_4\nmgf : x\u271d\nx : \u211d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma aemeasurable_of_integrable_exp_mul (huv : u \u2260 v)\n    (hu_int : Integrable (fun \u03c9 \u21a6 exp (u * X \u03c9)) \u03bc)\n    (hv_int : Integrable (fun \u03c9 \u21a6 exp (v * X \u03c9)) \u03bc) :\n    AEMeasurable X \u03bc := by\n  by_cases hu : u = 0\n  \u00b7 have hv : v \u2260 0 := ne_of_ne_of_eq huv.symm hu\n    exact aemeasurable_of_aemeasurable_exp_mul hv hv_int.aemeasurable\n  \u00b7 exact aemeasurable_of_aemeasurable_exp_mul hu hu_int.aemeasurable\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/IntegrableExpMul.lean", "context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal Topology"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {\u03bc : Measure \u03a9} {t u v : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nu v : \u211d\nhuv : u \u2260 v\nhu_int : Integrable (fun \u03c9 => exp (u * X \u03c9)) \u03bc\nhv_int : Integrable (fun \u03c9 => exp (v * X \u03c9)) \u03bc\n\u22a2 AEMeasurable X \u03bc"}, {"line": "by_cases hu : u = 0", "tactic_state": "case pos\n\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nu v : \u211d\nhuv : u \u2260 v\nhu_int : Integrable (fun \u03c9 => exp (u * X \u03c9)) \u03bc\nhv_int : Integrable (fun \u03c9 => exp (v * X \u03c9)) \u03bc\nhu : u = 0\n\u22a2 AEMeasurable X \u03bc\n---\ncase neg\n\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nu v : \u211d\nhuv : u \u2260 v\nhu_int : Integrable (fun \u03c9 => exp (u * X \u03c9)) \u03bc\nhv_int : Integrable (fun \u03c9 => exp (v * X \u03c9)) \u03bc\nhu : \u00acu = 0\n\u22a2 AEMeasurable X \u03bc"}, {"line": "\u00b7 have hv : v \u2260 0 := ne_of_ne_of_eq huv.symm hu\n    exact aemeasurable_of_aemeasurable_exp_mul hv hv_int.aemeasurable", "tactic_state": "case neg\n\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nu v : \u211d\nhuv : u \u2260 v\nhu_int : Integrable (fun \u03c9 => exp (u * X \u03c9)) \u03bc\nhv_int : Integrable (fun \u03c9 => exp (v * X \u03c9)) \u03bc\nhu : \u00acu = 0\n\u22a2 AEMeasurable X \u03bc"}, {"line": "\u00b7 exact aemeasurable_of_aemeasurable_exp_mul hu hu_int.aemeasurable", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_half_inf_sub_mem_Ioo {l u v : \u211d} (hv : v \u2208 Set.Ioo l u) :\n    v + ((v - l) \u2293 (u - v)) / 2 \u2208 Set.Ioo l u := by\n  have h_pos : 0 < (v - l) \u2293 (u - v) := by simp [hv.1, hv.2]\n  constructor\n  \u00b7 calc l < v := hv.1\n    _ \u2264 v + ((v - l) \u2293 (u - v)) / 2 := le_add_of_nonneg_right (by positivity)\n  \u00b7 calc v + ((v - l) \u2293 (u - v)) / 2\n    _ < v + ((v - l) \u2293 (u - v)) := by gcongr; exact half_lt_self (by positivity)\n    _ \u2264 v + (u - v) := by gcongr; exact inf_le_right\n    _ = u := by abel\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/IntegrableExpMul.lean", "context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal Topology"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {\u03bc : Measure \u03a9} {t u v : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l u v : \u211d\nhv : v \u2208 Set.Ioo l u\n\u22a2 v + min (v - l) (u - v) / 2 \u2208 Set.Ioo l u"}, {"line": "have h_pos : 0 < (v - l) \u2293 (u - v) := sorry", "tactic_state": "l u v : \u211d\nhv : v \u2208 Set.Ioo l u\nh_pos : 0 < min (v - l) (u - v)\n\u22a2 v + min (v - l) (u - v) / 2 \u2208 Set.Ioo l u"}, {"line": "constructor", "tactic_state": "case left\nl u v : \u211d\nhv : v \u2208 Set.Ioo l u\nh_pos : 0 < min (v - l) (u - v)\n\u22a2 l < v + min (v - l) (u - v) / 2\n---\ncase right\nl u v : \u211d\nhv : v \u2208 Set.Ioo l u\nh_pos : 0 < min (v - l) (u - v)\n\u22a2 v + min (v - l) (u - v) / 2 < u"}, {"line": "\u00b7 calc l < v := hv.1\n    _ \u2264 v + ((v - l) \u2293 (u - v)) / 2 := le_add_of_nonneg_right (by positivity)", "tactic_state": "case right\nl u v : \u211d\nhv : v \u2208 Set.Ioo l u\nh_pos : 0 < min (v - l) (u - v)\n\u22a2 v + min (v - l) (u - v) / 2 < u"}, {"line": "\u00b7 calc v + ((v - l) \u2293 (u - v)) / 2\n    _ < v + ((v - l) \u2293 (u - v)) := by gcongr; exact half_lt_self (by positivity)\n    _ \u2264 v + (u - v) := by gcongr; exact inf_le_right\n    _ = u := by abel", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub_half_inf_sub_mem_Ioo {l u v : \u211d} (hv : v \u2208 Set.Ioo l u) :\n    v - ((v - l) \u2293 (u - v)) / 2 \u2208 Set.Ioo l u := by\n  have h_pos : 0 < (v - l) \u2293 (u - v) := by simp [hv.1, hv.2]\n  constructor\n  \u00b7 calc l = v - (v - l) := by abel\n    _ \u2264 v - ((v - l) \u2293 (u - v)) := by gcongr; exact inf_le_left\n    _ < v - ((v - l) \u2293 (u - v)) / 2 := by gcongr; exact half_lt_self (by positivity)\n  \u00b7 calc v - ((v - l) \u2293 (u - v)) / 2\n    _ \u2264 v := by\n      rw [sub_le_iff_le_add]\n      exact le_add_of_nonneg_right (by positivity)\n    _ < u := hv.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/IntegrableExpMul.lean", "context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal Topology"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {\u03bc : Measure \u03a9} {t u v : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l u v : \u211d\nhv : v \u2208 Set.Ioo l u\n\u22a2 v - min (v - l) (u - v) / 2 \u2208 Set.Ioo l u"}, {"line": "have h_pos : 0 < (v - l) \u2293 (u - v) := sorry", "tactic_state": "l u v : \u211d\nhv : v \u2208 Set.Ioo l u\nh_pos : 0 < min (v - l) (u - v)\n\u22a2 v - min (v - l) (u - v) / 2 \u2208 Set.Ioo l u"}, {"line": "constructor", "tactic_state": "case left\nl u v : \u211d\nhv : v \u2208 Set.Ioo l u\nh_pos : 0 < min (v - l) (u - v)\n\u22a2 l < v - min (v - l) (u - v) / 2\n---\ncase right\nl u v : \u211d\nhv : v \u2208 Set.Ioo l u\nh_pos : 0 < min (v - l) (u - v)\n\u22a2 v - min (v - l) (u - v) / 2 < u"}, {"line": "\u00b7 calc l = v - (v - l) := by abel\n    _ \u2264 v - ((v - l) \u2293 (u - v)) := by gcongr; exact inf_le_left\n    _ < v - ((v - l) \u2293 (u - v)) / 2 := by gcongr; exact half_lt_self (by positivity)", "tactic_state": "case right\nl u v : \u211d\nhv : v \u2208 Set.Ioo l u\nh_pos : 0 < min (v - l) (u - v)\n\u22a2 v - min (v - l) (u - v) / 2 < u"}, {"line": "\u00b7 calc v - ((v - l) \u2293 (u - v)) / 2\n    _ \u2264 v := by\n      rw [sub_le_iff_le_add]\n      exact le_add_of_nonneg_right (by positivity)\n    _ < u := hv.2", "tactic_state": "No Goals!"}]}
{"declaration": "lemma integrable_cexp_mul_of_re_mem_integrableExpSet (hX : AEMeasurable X \u03bc)\n    (hz : z.re \u2208 integrableExpSet X \u03bc) :\n    Integrable (fun \u03c9 \u21a6 cexp (z * X \u03c9)) \u03bc := by\n  rw [\u2190 integrable_norm_iff]\n  \u00b7 simpa [Complex.norm_exp] using hz\n  \u00b7 exact AEMeasurable.aestronglyMeasurable (by fun_prop)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/IntegrableExpMul.lean", "context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal Topology", "Complex"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {\u03bc : Measure \u03a9} {t u v : \u211d}", "{z : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nz : \u2102\nx\u271d : Sort u_3\nintegrableExpSet : x\u271d\nhX : AEMeasurable X \u03bc\nhz : z.re \u2208 sorry\n\u22a2 Integrable (fun \u03c9 => Complex.exp (z * \u2191(X \u03c9))) \u03bc"}, {"line": "rw [\u2190 integrable_norm_iff]", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nz : \u2102\nx\u271d : Sort u_3\nintegrableExpSet : x\u271d\nhX : AEMeasurable X \u03bc\nhz : z.re \u2208 sorry\n\u22a2 Integrable (fun a => \u2016Complex.exp (z * \u2191(X a))\u2016) \u03bc\n---\n\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nz : \u2102\nx\u271d : Sort u_3\nintegrableExpSet : x\u271d\nhX : AEMeasurable X \u03bc\nhz : z.re \u2208 sorry\n\u22a2 AEStronglyMeasurable (fun \u03c9 => Complex.exp (z * \u2191(X \u03c9))) \u03bc"}, {"line": "\u00b7 simpa [Complex.norm_exp] using hz", "tactic_state": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nz : \u2102\nx\u271d : Sort u_3\nintegrableExpSet : x\u271d\nhX : AEMeasurable X \u03bc\nhz : z.re \u2208 sorry\n\u22a2 AEStronglyMeasurable (fun \u03c9 => Complex.exp (z * \u2191(X \u03c9))) \u03bc"}, {"line": "\u00b7 exact AEMeasurable.aestronglyMeasurable (by fun_prop)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma fun_zero [IsZeroOrProbabilityMeasure \u03bc] : HasSubgaussianMGF (fun _ \u21a6 0) 0 \u03bc := by\n  simp [HasSubgaussianMGF_iff_kernel]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Moments/SubGaussian.lean", "context": {"open": ["MeasureTheory Real", "scoped ENNReal NNReal Topology"], "variables": ["{\u03a9 \u03a9' : Type*} {m\u03a9 : MeasurableSpace \u03a9} {m\u03a9' : MeasurableSpace \u03a9'}", "{\u03a9'' : Type*} {m\u03a9'' : MeasurableSpace \u03a9''} {Y : \u03a9'' \u2192 \u211d} {cY : \u211d\u22650}", "[SFinite \u03bd]", "{\u03a9 : Type*} {m m\u03a9 : MeasurableSpace \u03a9} {hm : m \u2264 m\u03a9} [StandardBorelSpace \u03a9]", "(m) (hm) in", "{\u03a9 : Type*} {m m\u03a9 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9} {X : \u03a9 \u2192 \u211d} {c : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03bd : Measure ?m.497\n\u03a9\u271d : Type u_1\n\u03a9' : Type u_2\nm\u03a9\u271d : MeasurableSpace \u03a9\u271d\nm\u03a9' : MeasurableSpace \u03a9'\n\u03a9'' : Type u_3\nm\u03a9'' : MeasurableSpace \u03a9''\nY : \u03a9'' \u2192 \u211d\ncY : NNReal\ninst\u271d\u00b3 : SFinite \u03bd\n\u03a9 : Type u_4\nm m\u03a9 : MeasurableSpace \u03a9\nhm : m \u2264 m\u03a9\ninst\u271d\u00b2 : StandardBorelSpace \u03a9\n\u03b1\u271d : Type u_5\ninst\u271d\u00b9 : MeasurableSpace \u03b1\u271d\n\u03bc : Measure \u03b1\u271d\nx\u271d : Sort u_6\nHasSubgaussianMGF : x\u271d\ninst\u271d : IsZeroOrProbabilityMeasure \u03bc\n\u22a2 sorry"}, {"line": "simp [HasSubgaussianMGF_iff_kernel]", "tactic_state": "\u03bd : Measure ?m.497\n\u03a9\u271d : Type u_1\n\u03a9' : Type u_2\nm\u03a9\u271d : MeasurableSpace \u03a9\u271d\nm\u03a9' : MeasurableSpace \u03a9'\n\u03a9'' : Type u_3\nm\u03a9'' : MeasurableSpace \u03a9''\nY : \u03a9'' \u2192 \u211d\ncY : NNReal\ninst\u271d\u00b3 : SFinite \u03bd\n\u03a9 : Type u_4\nm m\u03a9 : MeasurableSpace \u03a9\nhm : m \u2264 m\u03a9\ninst\u271d\u00b2 : StandardBorelSpace \u03a9\n\u03b1\u271d : Type u_5\ninst\u271d\u00b9 : MeasurableSpace \u03b1\u271d\n\u03bc : Measure \u03b1\u271d\nx\u271d : Sort u_6\nHasSubgaussianMGF : x\u271d\ninst\u271d : IsZeroOrProbabilityMeasure \u03bc\n\u22a2 sorry ()"}]}
{"declaration": "theorem integral_eq_sum [Fintype \u03b1] (p : PMF \u03b1) (f : \u03b1 \u2192 E) :\n    \u222b a, f a \u2202(p.toMeasure) = \u2211 a, (p a).toReal \u2022 f a := by\n  rw [integral_fintype _ .of_finite]\n  congr with x\n  rw [measureReal_def]\n  congr 2\n  exact PMF.toMeasure_apply_singleton p x (MeasurableSet.singleton _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/ProbabilityMassFunction/Integrals.lean", "context": {"open": ["MeasureTheory ENNReal TopologicalSpace"], "variables": ["{\u03b1 : Type*} [MeasurableSpace \u03b1] [MeasurableSingletonClass \u03b1]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 \u222b (a : \u03b1), f a \u2202p.toMeasure = \u2211 a, (p a).toReal \u2022 f a"}, {"line": "rw [integral_fintype _ .of_finite]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 \u2211 x, p.toMeasure.real {x} \u2022 f x = \u2211 a, (p a).toReal \u2022 f a\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 CompleteSpace E\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 MeasurableSingletonClass \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 Fintype \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 Finite \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 MeasurableSingletonClass \u03b1"}, {"line": "congr with x", "tactic_state": "case e_f.h\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\nx : \u03b1\n\u22a2 p.toMeasure.real {x} \u2022 f x = (p x).toReal \u2022 f x\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 CompleteSpace E\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 MeasurableSingletonClass \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 Finite \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 MeasurableSingletonClass \u03b1"}, {"line": "rw [measureReal_def]", "tactic_state": "case e_f.h\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\nx : \u03b1\n\u22a2 (p.toMeasure {x}).toReal \u2022 f x = (p x).toReal \u2022 f x\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 CompleteSpace E\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 MeasurableSingletonClass \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 Finite \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 MeasurableSingletonClass \u03b1"}, {"line": "congr 2", "tactic_state": "case e_f.h.e_a.e_a\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\nx : \u03b1\n\u22a2 p.toMeasure {x} = p x\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 CompleteSpace E\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 MeasurableSingletonClass \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 Finite \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 MeasurableSingletonClass \u03b1"}, {"line": "exact PMF.toMeasure_apply_singleton p x (MeasurableSet.singleton _)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 CompleteSpace E\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 MeasurableSingletonClass \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 Finite \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : Fintype \u03b1\np : PMF \u03b1\nf : \u03b1 \u2192 E\n\u22a2 MeasurableSingletonClass \u03b1"}]}
{"declaration": "theorem bernoulli_expectation {p : \u211d\u22650\u221e} (h : p \u2264 1) :\n    \u222b b, cond b 1 0 \u2202((bernoulli p h).toMeasure) = p.toReal := by simp [integral_eq_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/ProbabilityMassFunction/Integrals.lean", "context": {"open": ["MeasureTheory ENNReal TopologicalSpace"], "variables": ["{\u03b1 : Type*} [MeasurableSpace \u03b1] [MeasurableSingletonClass \u03b1]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ENNReal\nh : p \u2264 1\n\u22a2 \u222b (b : Bool), bif b then 1 else 0 \u2202sorry = p.toReal"}, {"line": "simp [integral_eq_sum]", "tactic_state": "p : ENNReal\nh : p \u2264 1\n\u22a2 \u222b (b : Bool), bif b then 1 else 0 \u2202sorry () = p.toReal"}]}
{"declaration": "theorem mem_support_pure_iff : a' \u2208 (pure a).support \u2194 a' = a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/ProbabilityMassFunction/Monad.lean", "context": {"open": ["NNReal ENNReal", "MeasureTheory", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(a a' : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na a' : \u03b1\n\u22a2 a' \u2208 sorry \u2194 a' = a"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\na a' : \u03b1\n\u22a2 a' \u2208 sorry () \u2194 a' = a"}]}
{"declaration": "theorem toOuterMeasure_caratheodory : p.toOuterMeasure.caratheodory = \u22a4 := by\n  refine eq_top_iff.2 <| le_trans (le_sInf fun x hx => ?_) (le_sum_caratheodory _)\n  have \u27e8y, hy\u27e9 := hx\n  exact\n    ((le_of_eq (dirac_caratheodory y).symm).trans (le_smul_caratheodory _ _)).trans (le_of_eq hy)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/ProbabilityMassFunction/Basic.lean", "context": {"open": ["NNReal ENNReal MeasureTheory", "MeasureTheory MeasureTheory.OuterMeasure"], "variables": ["{\u03b1 : Type*}", "(p : PMF \u03b1) (s : Set \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : PMF \u03b1\n\u22a2 p.toOuterMeasure.caratheodory = \u22a4"}, {"line": "refine eq_top_iff.2 <| le_trans (le_sInf fun x hx => ?_) (le_sum_caratheodory _)", "tactic_state": "\u03b1 : Type u_1\np : PMF \u03b1\nx : MeasurableSpace \u03b1\nhx : x \u2208 Set.range fun i => (p i \u2022 dirac i).caratheodory\n\u22a2 \u22a4 \u2264 x"}, {"line": "have \u27e8y, hy\u27e9 := hx", "tactic_state": "\u03b1 : Type u_1\np : PMF \u03b1\nx : MeasurableSpace \u03b1\nhx : x \u2208 Set.range fun i => (p i \u2022 dirac i).caratheodory\ny : \u03b1\nhy : (fun i => (p i \u2022 dirac i).caratheodory) y = x\n\u22a2 \u22a4 \u2264 x"}, {"line": "exact\n    ((le_of_eq (dirac_caratheodory y).symm).trans (le_smul_caratheodory _ _)).trans (le_of_eq hy)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toOuterMeasure_apply_singleton (a : \u03b1) : p.toOuterMeasure {a} = p a := by\n  refine (p.toOuterMeasure_apply {a}).trans ((tsum_eq_single a fun b hb => ?_).trans ?_)\n  \u00b7 classical exact ite_eq_right_iff.2 fun hb' => False.elim <| hb hb'\n  \u00b7 classical exact ite_eq_left_iff.2 fun ha' => False.elim <| ha' rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/ProbabilityMassFunction/Basic.lean", "context": {"open": ["NNReal ENNReal MeasureTheory", "MeasureTheory MeasureTheory.OuterMeasure"], "variables": ["{\u03b1 : Type*}", "(p : PMF \u03b1) (s : Set \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : PMF \u03b1\na : \u03b1\n\u22a2 p.toOuterMeasure {a} = p a"}, {"line": "refine (p.toOuterMeasure_apply {a}).trans ((tsum_eq_single a fun b hb => ?_).trans ?_)", "tactic_state": "case refine_1\n\u03b1 : Type u_1\np : PMF \u03b1\na b : \u03b1\nhb : b \u2260 a\n\u22a2 {a}.indicator (\u21d1p) b = 0\n---\ncase refine_2\n\u03b1 : Type u_1\np : PMF \u03b1\na : \u03b1\n\u22a2 {a}.indicator (\u21d1p) a = p a"}, {"line": "\u00b7 classical exact ite_eq_right_iff.2 fun hb' => False.elim <| hb hb'", "tactic_state": "case refine_2\n\u03b1 : Type u_1\np : PMF \u03b1\na : \u03b1\n\u22a2 {a}.indicator (\u21d1p) a = p a"}, {"line": "\u00b7 classical exact ite_eq_left_iff.2 fun ha' => False.elim <| ha' rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toMeasure_mono {s t : Set \u03b1} (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h : s \u2229 p.support \u2286 t) : p.toMeasure s \u2264 p.toMeasure t := by\n  simpa only [p.toMeasure_apply_eq_toOuterMeasure_apply,hs,ht] using toOuterMeasure_mono p h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/ProbabilityMassFunction/Basic.lean", "context": {"open": ["NNReal ENNReal MeasureTheory", "MeasureTheory MeasureTheory.OuterMeasure", "MeasureTheory"], "variables": ["{\u03b1 : Type*}", "(p : PMF \u03b1) (s : Set \u03b1)", "[MeasurableSpace \u03b1] (p : PMF \u03b1) (s : Set \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\np : PMF \u03b1\ns t : Set \u03b1\nhs : MeasurableSet s\nht : MeasurableSet t\nh : s \u2229 p.support \u2286 t\n\u22a2 p.toMeasure s \u2264 p.toMeasure t"}, {"line": "simpa only [p.toMeasure_apply_eq_toOuterMeasure_apply,hs,ht] using toOuterMeasure_mono p h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toMeasure_apply_eq_of_inter_support_eq {s t : Set \u03b1} (hs : MeasurableSet s)\n    (ht : MeasurableSet t) (h : s \u2229 p.support = t \u2229 p.support) : p.toMeasure s = p.toMeasure t := by\n  simpa only [p.toMeasure_apply_eq_toOuterMeasure_apply,hs,ht] using\n    toOuterMeasure_apply_eq_of_inter_support_eq p h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/ProbabilityMassFunction/Basic.lean", "context": {"open": ["NNReal ENNReal MeasureTheory", "MeasureTheory MeasureTheory.OuterMeasure", "MeasureTheory"], "variables": ["{\u03b1 : Type*}", "(p : PMF \u03b1) (s : Set \u03b1)", "[MeasurableSpace \u03b1] (p : PMF \u03b1) (s : Set \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\np : PMF \u03b1\ns t : Set \u03b1\nhs : MeasurableSet s\nht : MeasurableSet t\nh : s \u2229 p.support = t \u2229 p.support\n\u22a2 p.toMeasure s = p.toMeasure t"}, {"line": "simpa only [p.toMeasure_apply_eq_toOuterMeasure_apply,hs,ht] using\n    toOuterMeasure_apply_eq_of_inter_support_eq p h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toPMF_eq_iff_toMeasure_eq (\u03bc : Measure \u03b1) [IsProbabilityMeasure \u03bc] :\n    \u03bc.toPMF = p \u2194 \u03bc = p.toMeasure := by rw [\u2190 toMeasure_inj, Measure.toPMF_toMeasure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/ProbabilityMassFunction/Basic.lean", "context": {"open": ["NNReal ENNReal MeasureTheory", "MeasureTheory MeasureTheory.OuterMeasure", "MeasureTheory", "PMF", "MeasureTheory"], "variables": ["{\u03b1 : Type*}", "(p : PMF \u03b1) (s : Set \u03b1)", "[MeasurableSpace \u03b1] (p : PMF \u03b1) (s : Set \u03b1)", "[MeasurableSingletonClass \u03b1]", "[Countable \u03b1] [MeasurableSpace \u03b1] [MeasurableSingletonClass \u03b1] (\u03bc : Measure \u03b1)", "[Countable \u03b1] [MeasurableSpace \u03b1] [MeasurableSingletonClass \u03b1] (p : PMF \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2078 : MeasurableSpace \u03b1\ninst\u271d\u2077 : MeasurableSingletonClass \u03b1\ninst\u271d\u2076 : Countable \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\ninst\u271d\u00b3 : Countable \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\np : PMF \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsProbabilityMeasure \u03bc\n\u22a2 \u03bc.toPMF = p \u2194 \u03bc = p.toMeasure"}, {"line": "rw [\u2190 toMeasure_inj, Measure.toPMF_toMeasure]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2078 : MeasurableSpace \u03b1\ninst\u271d\u2077 : MeasurableSingletonClass \u03b1\ninst\u271d\u2076 : Countable \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSingletonClass \u03b1\ninst\u271d\u00b3 : Countable \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\np : PMF \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsProbabilityMeasure \u03bc\n\u22a2 MeasurableSingletonClass \u03b1"}]}
{"declaration": "theorem binomial_apply_zero (p : \u211d\u22650\u221e) (h : p \u2264 1) (n : \u2115) :\n    binomial p h n 0 = (1-p)^n := by\n  simp [binomial_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/ProbabilityMassFunction/Binomial.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbinomial : x\u271d\np : ENNReal\nh : p \u2264 1\nn : \u2115\n\u22a2 sorry = (1 - p) ^ n"}, {"line": "simp [binomial_apply]", "tactic_state": "x\u271d : Sort u_1\nbinomial : x\u271d\np : ENNReal\nh : p \u2264 1\nn : \u2115\n\u22a2 sorry () = (1 - p) ^ n"}]}
{"declaration": "theorem binomial_apply_last (p : \u211d\u22650\u221e) (h : p \u2264 1) (n : \u2115) :\n    binomial p h n (.last n) = p^n := by\n  simp [binomial_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/ProbabilityMassFunction/Binomial.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbinomial : x\u271d\np : ENNReal\nh : p \u2264 1\nn : \u2115\n\u22a2 sorry = p ^ n"}, {"line": "simp [binomial_apply]", "tactic_state": "x\u271d : Sort u_1\nbinomial : x\u271d\np : ENNReal\nh : p \u2264 1\nn : \u2115\n\u22a2 sorry () = p ^ n"}]}
{"declaration": "theorem binomial_apply_self (p : \u211d\u22650\u221e) (h : p \u2264 1) (n : \u2115) :\n    binomial p h n n = p^n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/ProbabilityMassFunction/Binomial.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbinomial : x\u271d\np : ENNReal\nh : p \u2264 1\nn : \u2115\n\u22a2 sorry = p ^ n"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nbinomial : x\u271d\np : ENNReal\nh : p \u2264 1\nn : \u2115\n\u22a2 sorry () = p ^ n"}]}
{"declaration": "theorem map_comp (g : \u03b2 \u2192 \u03b3) : (p.map f).map g = p.map (g \u2218 f) := by simp [map, Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/ProbabilityMassFunction/Constructions.lean", "context": {"open": ["NNReal ENNReal Finset MeasureTheory", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(f : \u03b1 \u2192 \u03b2) (p : PMF \u03b1) (b : \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\np : PMF \u03b1\n\u03b3 : Type u_1\ng : \u03b2 \u2192 \u03b3\n\u22a2 PMF.map g (PMF.map f p) = PMF.map (g \u2218 f) p"}, {"line": "simp [map, Function.comp_def]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\np : PMF \u03b1\n\u03b3 : Type u_1\ng : \u03b2 \u2192 \u03b3\n\u22a2 PMF.map g (PMF.map f p) = PMF.map (fun x => g (f x)) p"}]}
{"declaration": "theorem hitting_of_le {m : \u03b9} (hmn : m \u2264 n) : hitting u s n m \u03c9 = m := by\n  obtain rfl | h := le_iff_eq_or_lt.1 hmn\n  \u00b7 classical\n    rw [hitting]\n    rw [ite_eq_right_iff]\n    rw [forall_exists_index]\n    conv => intro; rw [Set.mem_Icc, Set.Icc_self, and_imp, and_imp]\n    intro i hi\u2081 hi\u2082 hi\n    rw [Set.inter_eq_left.2]\n    rw [csInf_singleton]\n    exact Set.singleton_subset_iff.2 (le_antisymm hi\u2082 hi\u2081 \u25b8 hi)\n  \u00b7 exact hitting_of_lt h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Process/HittingTime.lean", "context": {"open": ["Filter Order TopologicalSpace", "scoped MeasureTheory NNReal ENNReal Topology", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03a9 \u03b2 \u03b9 : Type*} {m : MeasurableSpace \u03a9}", "[ConditionallyCompleteLinearOrder \u03b9] {u : \u03b9 \u2192 \u03a9 \u2192 \u03b2} {s : Set \u03b2} {n i : \u03b9} {\u03c9 : \u03a9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrder \u03b9\nn : \u03b9\nx\u271d : Sort u_1\nhitting : x\u271d\nm : \u03b9\nhmn : m \u2264 n\n\u22a2 sorry = m"}, {"line": "obtain rfl | h := le_iff_eq_or_lt.1 hmn", "tactic_state": "case inl\n\u03b9 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrder \u03b9\nx\u271d : Sort u_1\nhitting : x\u271d\nm : \u03b9\nhmn : m \u2264 m\n\u22a2 sorry = m\n---\ncase inr\n\u03b9 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrder \u03b9\nn : \u03b9\nx\u271d : Sort u_1\nhitting : x\u271d\nm : \u03b9\nhmn : m \u2264 n\nh : m < n\n\u22a2 sorry = m"}, {"line": "\u00b7 classical\n    rw [hitting]\n    rw [ite_eq_right_iff]\n    rw [forall_exists_index]\n    conv => intro; rw [Set.mem_Icc, Set.Icc_self, and_imp, and_imp]\n    intro i hi\u2081 hi\u2082 hi\n    rw [Set.inter_eq_left.2]\n    rw [csInf_singleton]\n    exact Set.singleton_subset_iff.2 (le_antisymm hi\u2082 hi\u2081 \u25b8 hi)", "tactic_state": "case inr\n\u03b9 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrder \u03b9\nn : \u03b9\nx\u271d : Sort u_1\nhitting : x\u271d\nm : \u03b9\nhmn : m \u2264 n\nh : m < n\n\u22a2 sorry = m"}, {"line": "\u00b7 exact hitting_of_lt h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsStoppingTime.measurableSet_eq (h\u03c4 : IsStoppingTime f \u03c4) (i : \u03b9) :\n    MeasurableSet[f i] {\u03c9 | \u03c4 \u03c9 = i} := by\n  have : {\u03c9 | \u03c4 \u03c9 = i} = {\u03c9 | \u03c4 \u03c9 \u2264 i} \u2229 {\u03c9 | \u03c4 \u03c9 \u2265 i} := by\n    ext1 \u03c9; simp only [Set.mem_setOf_eq, Set.mem_inter_iff, le_antisymm_iff]\n  rw [this]\n  exact (h\u03c4.measurableSet_le i).inter (h\u03c4.measurableSet_ge i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Process/Stopping.lean", "context": {"open": ["Filter Order TopologicalSpace", "scoped MeasureTheory NNReal ENNReal Topology"], "variables": ["{\u03a9 \u03b2 \u03b9 : Type*} {m : MeasurableSpace \u03a9}", "[Preorder \u03b9] {f : Filtration \u03b9 m} {\u03c4 : \u03a9 \u2192 \u03b9}", "[PartialOrder \u03b9] {\u03c4 : \u03a9 \u2192 \u03b9} {f : Filtration \u03b9 m}", "[LinearOrder \u03b9] {f : Filtration \u03b9 m} {\u03c4 : \u03a9 \u2192 \u03b9}", "[TopologicalSpace \u03b9] [OrderTopology \u03b9] [FirstCountableTopology \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Filtration : ?m.3207\n\u03a9\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b9\u271d : Type u_3\nm : MeasurableSpace \u03a9\u271d\ninst\u271d\u00b9\u00b9 : Preorder \u03b9\u271d\nf\u271d\u00b9 : sorry\n\u03c4\u271d\u00b2 : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u00b9\u2070 : PartialOrder \u03b9\u271d\n\u03c4\u271d\u00b9 : \u03a9\u271d \u2192 \u03b9\u271d\nf\u271d : sorry\ninst\u271d\u2079 : LinearOrder \u03b9\u271d\nf : sorry\n\u03c4\u271d : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u2078 : TopologicalSpace \u03b9\u271d\ninst\u271d\u2077 : OrderTopology \u03b9\u271d\ninst\u271d\u2076 : FirstCountableTopology \u03b9\u271d\n\u03a9 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2075 : Preorder \u03b9\ninst\u271d\u2074 : PartialOrder \u03b9\ninst\u271d\u00b3 : LinearOrder \u03b9\n\u03c4 : \u03a9 \u2192 \u03b9\ninst\u271d\u00b2 : TopologicalSpace \u03b9\ninst\u271d\u00b9 : OrderTopology \u03b9\ninst\u271d : FirstCountableTopology \u03b9\nx\u271d : Sort u_4\nIsStoppingTime : x\u271d\nh\u03c4 : sorry\ni : \u03b9\n\u22a2 MeasurableSet {\u03c9 | \u03c4 \u03c9 = i}"}, {"line": "have : {\u03c9 | \u03c4 \u03c9 = i} = {\u03c9 | \u03c4 \u03c9 \u2264 i} \u2229 {\u03c9 | \u03c4 \u03c9 \u2265 i} := by\n    ext1 \u03c9; simp only [Set.mem_setOf_eq, Set.mem_inter_iff, le_antisymm_iff]", "tactic_state": "Filtration : ?m.3207\n\u03a9\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b9\u271d : Type u_3\nm : MeasurableSpace \u03a9\u271d\ninst\u271d\u00b9\u00b9 : Preorder \u03b9\u271d\nf\u271d\u00b9 : sorry\n\u03c4\u271d\u00b2 : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u00b9\u2070 : PartialOrder \u03b9\u271d\n\u03c4\u271d\u00b9 : \u03a9\u271d \u2192 \u03b9\u271d\nf\u271d : sorry\ninst\u271d\u2079 : LinearOrder \u03b9\u271d\nf : sorry\n\u03c4\u271d : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u2078 : TopologicalSpace \u03b9\u271d\ninst\u271d\u2077 : OrderTopology \u03b9\u271d\ninst\u271d\u2076 : FirstCountableTopology \u03b9\u271d\n\u03a9 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2075 : Preorder \u03b9\ninst\u271d\u2074 : PartialOrder \u03b9\ninst\u271d\u00b3 : LinearOrder \u03b9\n\u03c4 : \u03a9 \u2192 \u03b9\ninst\u271d\u00b2 : TopologicalSpace \u03b9\ninst\u271d\u00b9 : OrderTopology \u03b9\ninst\u271d : FirstCountableTopology \u03b9\nx\u271d : Sort u_4\nIsStoppingTime : x\u271d\nh\u03c4 : sorry\ni : \u03b9\nthis : {\u03c9 | \u03c4 \u03c9 = i} = {\u03c9 | sorry} \u2229 {\u03c9 | sorry}\n\u22a2 MeasurableSet {\u03c9 | \u03c4 \u03c9 = i}"}, {"line": "rw [this]", "tactic_state": "Filtration : ?m.3207\n\u03a9\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b9\u271d : Type u_3\nm : MeasurableSpace \u03a9\u271d\ninst\u271d\u00b9\u00b9 : Preorder \u03b9\u271d\nf\u271d\u00b9 : sorry\n\u03c4\u271d\u00b2 : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u00b9\u2070 : PartialOrder \u03b9\u271d\n\u03c4\u271d\u00b9 : \u03a9\u271d \u2192 \u03b9\u271d\nf\u271d : sorry\ninst\u271d\u2079 : LinearOrder \u03b9\u271d\nf : sorry\n\u03c4\u271d : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u2078 : TopologicalSpace \u03b9\u271d\ninst\u271d\u2077 : OrderTopology \u03b9\u271d\ninst\u271d\u2076 : FirstCountableTopology \u03b9\u271d\n\u03a9 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2075 : Preorder \u03b9\ninst\u271d\u2074 : PartialOrder \u03b9\ninst\u271d\u00b3 : LinearOrder \u03b9\n\u03c4 : \u03a9 \u2192 \u03b9\ninst\u271d\u00b2 : TopologicalSpace \u03b9\ninst\u271d\u00b9 : OrderTopology \u03b9\ninst\u271d : FirstCountableTopology \u03b9\nx\u271d : Sort u_4\nIsStoppingTime : x\u271d\nh\u03c4 : sorry\ni : \u03b9\nthis : {\u03c9 | \u03c4 \u03c9 = i} = {\u03c9 | sorry} \u2229 {\u03c9 | sorry}\n\u22a2 MeasurableSet ({\u03c9 | sorry} \u2229 {\u03c9 | sorry})"}, {"line": "exact (h\u03c4.measurableSet_le i).inter (h\u03c4.measurableSet_ge i)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem stoppedProcess_eq_of_le {u : \u03b9 \u2192 \u03a9 \u2192 \u03b2} {\u03c4 : \u03a9 \u2192 \u03b9} {i : \u03b9} {\u03c9 : \u03a9} (h : i \u2264 \u03c4 \u03c9) :\n    stoppedProcess u \u03c4 i \u03c9 = u i \u03c9 := by simp [stoppedProcess, min_eq_left h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Process/Stopping.lean", "context": {"open": ["Filter Order TopologicalSpace", "scoped MeasureTheory NNReal ENNReal Topology"], "variables": ["{\u03a9 \u03b2 \u03b9 : Type*} {m : MeasurableSpace \u03a9}", "[Preorder \u03b9] {f : Filtration \u03b9 m} {\u03c4 : \u03a9 \u2192 \u03b9}", "[PartialOrder \u03b9] {\u03c4 : \u03a9 \u2192 \u03b9} {f : Filtration \u03b9 m}", "[LinearOrder \u03b9] {f : Filtration \u03b9 m} {\u03c4 : \u03a9 \u2192 \u03b9}", "[TopologicalSpace \u03b9] [OrderTopology \u03b9] [FirstCountableTopology \u03b9]", "[Preorder \u03b9] {f : Filtration \u03b9 m} {\u03c4 \u03c0 : \u03a9 \u2192 \u03b9}", "[LinearOrder \u03b9] {f : Filtration \u03b9 m} {\u03c4 \u03c0 : \u03a9 \u2192 \u03b9}", "[LinearOrder \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Filtration : ?m.8557\n\u03a9\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b9\u271d : Type u_3\nm : MeasurableSpace \u03a9\u271d\ninst\u271d\u00b9\u2077 : Preorder \u03b9\u271d\nf\u271d\u00b3 : sorry\n\u03c4\u271d\u2074 : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u00b9\u2076 : PartialOrder \u03b9\u271d\n\u03c4\u271d\u00b3 : \u03a9\u271d \u2192 \u03b9\u271d\nf\u271d\u00b2 : sorry\ninst\u271d\u00b9\u2075 : LinearOrder \u03b9\u271d\nf\u271d\u00b9 : sorry\n\u03c4\u271d\u00b2 : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b9\u271d\ninst\u271d\u00b9\u00b3 : OrderTopology \u03b9\u271d\ninst\u271d\u00b9\u00b2 : FirstCountableTopology \u03b9\u271d\ninst\u271d\u00b9\u00b9 : Preorder \u03b9\u271d\nf\u271d : sorry\n\u03c4\u271d\u00b9 \u03c0\u271d : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u00b9\u2070 : LinearOrder \u03b9\u271d\nf : sorry\n\u03c4\u271d \u03c0 : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u2079 : LinearOrder \u03b9\u271d\n\u03a9 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u2078 : Preorder \u03b9\ninst\u271d\u2077 : PartialOrder \u03b9\ninst\u271d\u2076 : LinearOrder \u03b9\ninst\u271d\u2075 : TopologicalSpace \u03b9\ninst\u271d\u2074 : OrderTopology \u03b9\ninst\u271d\u00b3 : FirstCountableTopology \u03b9\ninst\u271d\u00b2 : Preorder \u03b9\ninst\u271d\u00b9 inst\u271d : LinearOrder \u03b9\nx\u271d : Sort u_4\nstoppedProcess : x\u271d\nu : \u03b9 \u2192 \u03a9 \u2192 \u03b2\n\u03c4 : \u03a9 \u2192 \u03b9\ni : \u03b9\n\u03c9 : \u03a9\nh : i \u2264 \u03c4 \u03c9\n\u22a2 sorry = u i \u03c9"}, {"line": "simp [stoppedProcess, min_eq_left h]", "tactic_state": "Filtration : ?m.8557\n\u03a9\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b9\u271d : Type u_3\nm : MeasurableSpace \u03a9\u271d\ninst\u271d\u00b9\u2077 : Preorder \u03b9\u271d\nf\u271d\u00b3 : sorry\n\u03c4\u271d\u2074 : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u00b9\u2076 : PartialOrder \u03b9\u271d\n\u03c4\u271d\u00b3 : \u03a9\u271d \u2192 \u03b9\u271d\nf\u271d\u00b2 : sorry\ninst\u271d\u00b9\u2075 : LinearOrder \u03b9\u271d\nf\u271d\u00b9 : sorry\n\u03c4\u271d\u00b2 : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b9\u271d\ninst\u271d\u00b9\u00b3 : OrderTopology \u03b9\u271d\ninst\u271d\u00b9\u00b2 : FirstCountableTopology \u03b9\u271d\ninst\u271d\u00b9\u00b9 : Preorder \u03b9\u271d\nf\u271d : sorry\n\u03c4\u271d\u00b9 \u03c0\u271d : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u00b9\u2070 : LinearOrder \u03b9\u271d\nf : sorry\n\u03c4\u271d \u03c0 : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u2079 : LinearOrder \u03b9\u271d\n\u03a9 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u2078 : Preorder \u03b9\ninst\u271d\u2077 : PartialOrder \u03b9\ninst\u271d\u2076 : LinearOrder \u03b9\ninst\u271d\u2075 : TopologicalSpace \u03b9\ninst\u271d\u2074 : OrderTopology \u03b9\ninst\u271d\u00b3 : FirstCountableTopology \u03b9\ninst\u271d\u00b2 : Preorder \u03b9\ninst\u271d\u00b9 inst\u271d : LinearOrder \u03b9\nx\u271d : Sort u_4\nstoppedProcess : x\u271d\nu : \u03b9 \u2192 \u03a9 \u2192 \u03b2\n\u03c4 : \u03a9 \u2192 \u03b9\ni : \u03b9\n\u03c9 : \u03a9\nh : i \u2264 \u03c4 \u03c9\n\u22a2 sorry () = u i \u03c9"}]}
{"declaration": "theorem stoppedProcess_eq_of_ge {u : \u03b9 \u2192 \u03a9 \u2192 \u03b2} {\u03c4 : \u03a9 \u2192 \u03b9} {i : \u03b9} {\u03c9 : \u03a9} (h : \u03c4 \u03c9 \u2264 i) :\n    stoppedProcess u \u03c4 i \u03c9 = u (\u03c4 \u03c9) \u03c9 := by simp [stoppedProcess, min_eq_right h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Probability/Process/Stopping.lean", "context": {"open": ["Filter Order TopologicalSpace", "scoped MeasureTheory NNReal ENNReal Topology"], "variables": ["{\u03a9 \u03b2 \u03b9 : Type*} {m : MeasurableSpace \u03a9}", "[Preorder \u03b9] {f : Filtration \u03b9 m} {\u03c4 : \u03a9 \u2192 \u03b9}", "[PartialOrder \u03b9] {\u03c4 : \u03a9 \u2192 \u03b9} {f : Filtration \u03b9 m}", "[LinearOrder \u03b9] {f : Filtration \u03b9 m} {\u03c4 : \u03a9 \u2192 \u03b9}", "[TopologicalSpace \u03b9] [OrderTopology \u03b9] [FirstCountableTopology \u03b9]", "[Preorder \u03b9] {f : Filtration \u03b9 m} {\u03c4 \u03c0 : \u03a9 \u2192 \u03b9}", "[LinearOrder \u03b9] {f : Filtration \u03b9 m} {\u03c4 \u03c0 : \u03a9 \u2192 \u03b9}", "[LinearOrder \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Filtration : ?m.8557\n\u03a9\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b9\u271d : Type u_3\nm : MeasurableSpace \u03a9\u271d\ninst\u271d\u00b9\u2077 : Preorder \u03b9\u271d\nf\u271d\u00b3 : sorry\n\u03c4\u271d\u2074 : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u00b9\u2076 : PartialOrder \u03b9\u271d\n\u03c4\u271d\u00b3 : \u03a9\u271d \u2192 \u03b9\u271d\nf\u271d\u00b2 : sorry\ninst\u271d\u00b9\u2075 : LinearOrder \u03b9\u271d\nf\u271d\u00b9 : sorry\n\u03c4\u271d\u00b2 : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b9\u271d\ninst\u271d\u00b9\u00b3 : OrderTopology \u03b9\u271d\ninst\u271d\u00b9\u00b2 : FirstCountableTopology \u03b9\u271d\ninst\u271d\u00b9\u00b9 : Preorder \u03b9\u271d\nf\u271d : sorry\n\u03c4\u271d\u00b9 \u03c0\u271d : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u00b9\u2070 : LinearOrder \u03b9\u271d\nf : sorry\n\u03c4\u271d \u03c0 : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u2079 : LinearOrder \u03b9\u271d\n\u03a9 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u2078 : Preorder \u03b9\ninst\u271d\u2077 : PartialOrder \u03b9\ninst\u271d\u2076 : LinearOrder \u03b9\ninst\u271d\u2075 : TopologicalSpace \u03b9\ninst\u271d\u2074 : OrderTopology \u03b9\ninst\u271d\u00b3 : FirstCountableTopology \u03b9\ninst\u271d\u00b2 : Preorder \u03b9\ninst\u271d\u00b9 inst\u271d : LinearOrder \u03b9\nx\u271d : Sort u_4\nstoppedProcess : x\u271d\nu : \u03b9 \u2192 \u03a9 \u2192 \u03b2\n\u03c4 : \u03a9 \u2192 \u03b9\ni : \u03b9\n\u03c9 : \u03a9\nh : \u03c4 \u03c9 \u2264 i\n\u22a2 sorry = u (\u03c4 \u03c9) \u03c9"}, {"line": "simp [stoppedProcess, min_eq_right h]", "tactic_state": "Filtration : ?m.8557\n\u03a9\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b9\u271d : Type u_3\nm : MeasurableSpace \u03a9\u271d\ninst\u271d\u00b9\u2077 : Preorder \u03b9\u271d\nf\u271d\u00b3 : sorry\n\u03c4\u271d\u2074 : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u00b9\u2076 : PartialOrder \u03b9\u271d\n\u03c4\u271d\u00b3 : \u03a9\u271d \u2192 \u03b9\u271d\nf\u271d\u00b2 : sorry\ninst\u271d\u00b9\u2075 : LinearOrder \u03b9\u271d\nf\u271d\u00b9 : sorry\n\u03c4\u271d\u00b2 : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b9\u271d\ninst\u271d\u00b9\u00b3 : OrderTopology \u03b9\u271d\ninst\u271d\u00b9\u00b2 : FirstCountableTopology \u03b9\u271d\ninst\u271d\u00b9\u00b9 : Preorder \u03b9\u271d\nf\u271d : sorry\n\u03c4\u271d\u00b9 \u03c0\u271d : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u00b9\u2070 : LinearOrder \u03b9\u271d\nf : sorry\n\u03c4\u271d \u03c0 : \u03a9\u271d \u2192 \u03b9\u271d\ninst\u271d\u2079 : LinearOrder \u03b9\u271d\n\u03a9 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u2078 : Preorder \u03b9\ninst\u271d\u2077 : PartialOrder \u03b9\ninst\u271d\u2076 : LinearOrder \u03b9\ninst\u271d\u2075 : TopologicalSpace \u03b9\ninst\u271d\u2074 : OrderTopology \u03b9\ninst\u271d\u00b3 : FirstCountableTopology \u03b9\ninst\u271d\u00b2 : Preorder \u03b9\ninst\u271d\u00b9 inst\u271d : LinearOrder \u03b9\nx\u271d : Sort u_4\nstoppedProcess : x\u271d\nu : \u03b9 \u2192 \u03a9 \u2192 \u03b2\n\u03c4 : \u03a9 \u2192 \u03b9\ni : \u03b9\n\u03c9 : \u03a9\nh : \u03c4 \u03c9 \u2264 i\n\u22a2 sorry () = u (\u03c4 \u03c9) \u03c9"}]}
{"declaration": "theorem asAlgebraHom_single_one (g : G) : asAlgebraHom \u03c1 (MonoidAlgebra.single g 1) = \u03c1 g := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/Basic.lean", "context": {"open": ["MonoidAlgebra (lift of)", "LinearMap"], "variables": ["(k G V : Type*) [CommSemiring k] [Monoid G] [AddCommMonoid V] [Module k V]", "(k G V : Type*) [CommSemiring k] [Monoid G] [AddCommMonoid V] [Module k V]", "{G V}", "{k}", "{k G V : Type*} [CommSemiring k] [Monoid G] [AddCommMonoid V] [Module k V]", "(\u03c1 : Representation k G V)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_7\nG : Type u_8\nV : Type u_9\ninst\u271d\u00b3 : CommSemiring k\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : AddCommMonoid V\ninst\u271d : Module k V\n\u03c1 : Representation k G V\nx\u271d : Sort u_10\nasAlgebraHom : x\u271d\ng : G\n\u22a2 sorry = \u03c1 g"}, {"line": "simp", "tactic_state": "k : Type u_7\nG : Type u_8\nV : Type u_9\ninst\u271d\u00b3 : CommSemiring k\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : AddCommMonoid V\ninst\u271d : Module k V\n\u03c1 : Representation k G V\nx\u271d : Sort u_10\nasAlgebraHom : x\u271d\ng : G\n\u22a2 sorry () = \u03c1 g"}]}
{"declaration": "theorem asModuleEquiv_symm_map_smul (r : k) (x : V) :\n    \u03c1.asModuleEquiv.symm (r \u2022 x) = algebraMap k (MonoidAlgebra k G) r \u2022 \u03c1.asModuleEquiv.symm x := by\n  rw [LinearEquiv.symm_apply_eq]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/Basic.lean", "context": {"open": ["MonoidAlgebra (lift of)", "LinearMap"], "variables": ["(k G V : Type*) [CommSemiring k] [Monoid G] [AddCommMonoid V] [Module k V]", "(k G V : Type*) [CommSemiring k] [Monoid G] [AddCommMonoid V] [Module k V]", "{G V}", "{k}", "{k G V : Type*} [CommSemiring k] [Monoid G] [AddCommMonoid V] [Module k V]", "(\u03c1 : Representation k G V)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_7\nG : Type u_8\nV : Type u_9\ninst\u271d\u00b3 : CommSemiring k\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : AddCommMonoid V\ninst\u271d : Module k V\n\u03c1 : Representation k G V\nr : k\nx : V\n\u22a2 \u03c1.asModuleEquiv.symm (r \u2022 x) = (algebraMap k (MonoidAlgebra k G)) r \u2022 \u03c1.asModuleEquiv.symm x"}, {"line": "rw [LinearEquiv.symm_apply_eq]", "tactic_state": "k : Type u_7\nG : Type u_8\nV : Type u_9\ninst\u271d\u00b3 : CommSemiring k\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : AddCommMonoid V\ninst\u271d : Module k V\n\u03c1 : Representation k G V\nr : k\nx : V\n\u22a2 r \u2022 x = \u03c1.asModuleEquiv ((algebraMap k (MonoidAlgebra k G)) r \u2022 \u03c1.asModuleEquiv.symm x)"}, {"line": "simp", "tactic_state": "k : Type u_7\nG : Type u_8\nV : Type u_9\ninst\u271d\u00b3 : CommSemiring k\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : AddCommMonoid V\ninst\u271d : Module k V\n\u03c1 : Representation k G V\nr : k\nx : V\n\u22a2 r \u2022 x = \u03c1.asModuleEquiv (r \u2022 x)"}]}
{"declaration": "theorem asModuleEquiv_symm_map_rho (g : G) (x : V) :\n    \u03c1.asModuleEquiv.symm (\u03c1 g x) = MonoidAlgebra.of k G g \u2022 \u03c1.asModuleEquiv.symm x := by\n  rw [LinearEquiv.symm_apply_eq]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/Basic.lean", "context": {"open": ["MonoidAlgebra (lift of)", "LinearMap"], "variables": ["(k G V : Type*) [CommSemiring k] [Monoid G] [AddCommMonoid V] [Module k V]", "(k G V : Type*) [CommSemiring k] [Monoid G] [AddCommMonoid V] [Module k V]", "{G V}", "{k}", "{k G V : Type*} [CommSemiring k] [Monoid G] [AddCommMonoid V] [Module k V]", "(\u03c1 : Representation k G V)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_7\nG : Type u_8\nV : Type u_9\ninst\u271d\u00b3 : CommSemiring k\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : AddCommMonoid V\ninst\u271d : Module k V\n\u03c1 : Representation k G V\ng : G\nx : V\n\u22a2 \u03c1.asModuleEquiv.symm ((\u03c1 g) x) = (of k G) g \u2022 \u03c1.asModuleEquiv.symm x"}, {"line": "rw [LinearEquiv.symm_apply_eq]", "tactic_state": "k : Type u_7\nG : Type u_8\nV : Type u_9\ninst\u271d\u00b3 : CommSemiring k\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : AddCommMonoid V\ninst\u271d : Module k V\n\u03c1 : Representation k G V\ng : G\nx : V\n\u22a2 (\u03c1 g) x = \u03c1.asModuleEquiv ((of k G) g \u2022 \u03c1.asModuleEquiv.symm x)"}, {"line": "simp", "tactic_state": "k : Type u_7\nG : Type u_8\nV : Type u_9\ninst\u271d\u00b3 : CommSemiring k\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : AddCommMonoid V\ninst\u271d : Module k V\n\u03c1 : Representation k G V\ng : G\nx : V\n\u22a2 (\u03c1 g) x = \u03c1.asModuleEquiv (1 \u2022 (\u03c1 g) x)"}]}
{"declaration": "example : MonoidalCategory (FDRep R G) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/FDRep.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits"], "variables": ["{R k G : Type u} [CommRing R] [Field k] [Monoid G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R k G : Type u\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Field k\ninst\u271d : Monoid G\n\u22a2 MonoidalCategory (FDRep R G)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : MonoidalPreadditive (FDRep R G) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/FDRep.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits"], "variables": ["{R k G : Type u} [CommRing R] [Field k] [Monoid G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R k G : Type u\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Field k\ninst\u271d : Monoid G\n\u22a2 MonoidalPreadditive (FDRep R G)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : MonoidalLinear R (FDRep R G) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/FDRep.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits"], "variables": ["{R k G : Type u} [CommRing R] [Field k] [Monoid G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R k G : Type u\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Field k\ninst\u271d : Monoid G\n\u22a2 MonoidalLinear R (FDRep R G)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : RigidCategory (FDRep k G) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/FDRep.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "Module", "scoped Classical in"], "variables": ["{R k G : Type u} [CommRing R] [Field k] [Monoid G]", "{k G : Type u} [Field k] [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k G : Type u\ninst\u271d\u00b9 : Field k\ninst\u271d : Group G\n\u22a2 RigidCategory (FDRep k G)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_invariants (v : V) : v \u2208 invariants \u03c1 \u2194 \u2200 g : G, \u03c1 g v = v := by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/Invariants.lean", "context": {"open": ["MonoidAlgebra", "Representation", "GroupAlgebra"], "variables": ["(k G : Type*) [CommSemiring k] [Group G]", "[Fintype G] [Invertible (Fintype.card G : k)]", "{k G V : Type*} [CommSemiring k] [Group G] [AddCommMonoid V] [Module k V]", "(\u03c1 : Representation k G V)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_3\nG : Type u_4\nV : Type u_5\ninst\u271d\u00b3 : CommSemiring k\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : AddCommMonoid V\ninst\u271d : Module k V\n\u03c1 : Representation k G V\nv : V\n\u22a2 v \u2208 \u03c1.invariants \u2194 \u2200 (g : G), (\u03c1 g) v = v"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem averageMap_id (v : V) (hv : v \u2208 invariants \u03c1) : averageMap \u03c1 v = v := by\n  rw [mem_invariants] at hv\n  simp [average, map_sum, hv, Finset.card_univ, \u2190 Nat.cast_smul_eq_nsmul k _ v, smul_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/Invariants.lean", "context": {"open": ["MonoidAlgebra", "Representation", "GroupAlgebra"], "variables": ["(k G : Type*) [CommSemiring k] [Group G]", "[Fintype G] [Invertible (Fintype.card G : k)]", "{k G V : Type*} [CommSemiring k] [Group G] [AddCommMonoid V] [Module k V]", "(\u03c1 : Representation k G V)", "[Fintype G] [Invertible (Fintype.card G : k)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_3\nG : Type u_4\nV : Type u_5\ninst\u271d\u2075 : CommSemiring k\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : AddCommMonoid V\ninst\u271d\u00b2 : Module k V\n\u03c1 : Representation k G V\ninst\u271d\u00b9 : Fintype G\ninst\u271d : Invertible \u2191(Fintype.card G)\nv : V\nhv : v \u2208 \u03c1.invariants\n\u22a2 \u03c1.averageMap v = v"}, {"line": "rw [mem_invariants] at hv", "tactic_state": "k : Type u_3\nG : Type u_4\nV : Type u_5\ninst\u271d\u2075 : CommSemiring k\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : AddCommMonoid V\ninst\u271d\u00b2 : Module k V\n\u03c1 : Representation k G V\ninst\u271d\u00b9 : Fintype G\ninst\u271d : Invertible \u2191(Fintype.card G)\nv : V\nhv : \u2200 (g : G), (\u03c1 g) v = v\n\u22a2 \u03c1.averageMap v = v"}, {"line": "simp [average, map_sum, hv, Finset.card_univ, \u2190 Nat.cast_smul_eq_nsmul k _ v, smul_smul]", "tactic_state": "k : Type u_3\nG : Type u_4\nV : Type u_5\ninst\u271d\u2075 : CommSemiring k\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : AddCommMonoid V\ninst\u271d\u00b2 : Module k V\n\u03c1 : Representation k G V\ninst\u271d\u00b9 : Fintype G\ninst\u271d : Invertible \u2191(Fintype.card G)\nv : V\nhv : \u2200 (g : G), (\u03c1 g) v = v\n\u22a2 (\u03c1.asAlgebraHom (\u215f \u2191(Fintype.card G) \u2022 \u2211 x, single x 1)) v = v"}]}
{"declaration": "example : SymmetricCategory (Rep k G) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/Rep.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "MonoidalCategory in", "Functor.LaxMonoidal Functor.OplaxMonoidal Functor.Monoidal", "MonoidalCategory Action", "MonoidalCategory"], "variables": ["{k G : Type u} [CommRing k]", "[Monoid G]", "(k G)", "{k G}", "(k G)", "{k G}", "{X Y : Action (Type u) G} (f : X \u27f6 Y)", "(k G)", "(k G A : Type u) [CommRing k] [Monoid G] [AddCommGroup A]", "(M G : Type) [Monoid M] [CommGroup G] [MulDistribMulAction M G]", "{k G}", "[Group G] (A B C : Rep k G)", "{A B C}", "(A B C)", "{A B C}", "{k G : Type u} [CommRing k] [Monoid G] {V W : Type u} [AddCommGroup V] [AddCommGroup W]", "{k G : Type u} [CommRing k] [Monoid G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k\u271d\u00b2 G\u271d\u00b3 : Type u\ninst\u271d\u00b9\u2074 : CommRing k\u271d\u00b2\ninst\u271d\u00b9\u00b3 : Monoid G\u271d\u00b3\nX Y : Action (Type u) G\u271d\u00b3\nf : X \u27f6 Y\nk\u271d\u00b9 G\u271d\u00b2 A\u271d : Type u\ninst\u271d\u00b9\u00b2 : CommRing k\u271d\u00b9\ninst\u271d\u00b9\u00b9 : Monoid G\u271d\u00b2\ninst\u271d\u00b9\u2070 : AddCommGroup A\u271d\nM G\u271d\u00b9 : Type\ninst\u271d\u2079 : Monoid M\ninst\u271d\u2078 : CommGroup G\u271d\u00b9\ninst\u271d\u2077 : MulDistribMulAction M G\u271d\u00b9\ninst\u271d\u2076 : Group G\u271d\u00b9\nA : sorry\nB : sorry\nC : sorry\nk\u271d G\u271d : Type u\ninst\u271d\u2075 : CommRing k\u271d\ninst\u271d\u2074 : Monoid G\u271d\nV W : Type u\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : AddCommGroup W\nk G : Type u\ninst\u271d\u00b9 : CommRing k\ninst\u271d : Monoid G\n\u22a2 SymmetricCategory (Rep k G)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : MonoidalPreadditive (Rep k G) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/Rep.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "MonoidalCategory in", "Functor.LaxMonoidal Functor.OplaxMonoidal Functor.Monoidal", "MonoidalCategory Action", "MonoidalCategory"], "variables": ["{k G : Type u} [CommRing k]", "[Monoid G]", "(k G)", "{k G}", "(k G)", "{k G}", "{X Y : Action (Type u) G} (f : X \u27f6 Y)", "(k G)", "(k G A : Type u) [CommRing k] [Monoid G] [AddCommGroup A]", "(M G : Type) [Monoid M] [CommGroup G] [MulDistribMulAction M G]", "{k G}", "[Group G] (A B C : Rep k G)", "{A B C}", "(A B C)", "{A B C}", "{k G : Type u} [CommRing k] [Monoid G] {V W : Type u} [AddCommGroup V] [AddCommGroup W]", "{k G : Type u} [CommRing k] [Monoid G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k\u271d\u00b2 G\u271d\u00b3 : Type u\ninst\u271d\u00b9\u2074 : CommRing k\u271d\u00b2\ninst\u271d\u00b9\u00b3 : Monoid G\u271d\u00b3\nX Y : Action (Type u) G\u271d\u00b3\nf : X \u27f6 Y\nk\u271d\u00b9 G\u271d\u00b2 A\u271d : Type u\ninst\u271d\u00b9\u00b2 : CommRing k\u271d\u00b9\ninst\u271d\u00b9\u00b9 : Monoid G\u271d\u00b2\ninst\u271d\u00b9\u2070 : AddCommGroup A\u271d\nM G\u271d\u00b9 : Type\ninst\u271d\u2079 : Monoid M\ninst\u271d\u2078 : CommGroup G\u271d\u00b9\ninst\u271d\u2077 : MulDistribMulAction M G\u271d\u00b9\ninst\u271d\u2076 : Group G\u271d\u00b9\nA : sorry\nB : sorry\nC : sorry\nk\u271d G\u271d : Type u\ninst\u271d\u2075 : CommRing k\u271d\ninst\u271d\u2074 : Monoid G\u271d\nV W : Type u\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : AddCommGroup W\nk G : Type u\ninst\u271d\u00b9 : CommRing k\ninst\u271d : Monoid G\n\u22a2 MonoidalPreadditive (Rep k G)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : MonoidalLinear k (Rep k G) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/Rep.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "MonoidalCategory in", "Functor.LaxMonoidal Functor.OplaxMonoidal Functor.Monoidal", "MonoidalCategory Action", "MonoidalCategory"], "variables": ["{k G : Type u} [CommRing k]", "[Monoid G]", "(k G)", "{k G}", "(k G)", "{k G}", "{X Y : Action (Type u) G} (f : X \u27f6 Y)", "(k G)", "(k G A : Type u) [CommRing k] [Monoid G] [AddCommGroup A]", "(M G : Type) [Monoid M] [CommGroup G] [MulDistribMulAction M G]", "{k G}", "[Group G] (A B C : Rep k G)", "{A B C}", "(A B C)", "{A B C}", "{k G : Type u} [CommRing k] [Monoid G] {V W : Type u} [AddCommGroup V] [AddCommGroup W]", "{k G : Type u} [CommRing k] [Monoid G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k\u271d\u00b2 G\u271d\u00b3 : Type u\ninst\u271d\u00b9\u2074 : CommRing k\u271d\u00b2\ninst\u271d\u00b9\u00b3 : Monoid G\u271d\u00b3\nX Y : Action (Type u) G\u271d\u00b3\nf : X \u27f6 Y\nk\u271d\u00b9 G\u271d\u00b2 A\u271d : Type u\ninst\u271d\u00b9\u00b2 : CommRing k\u271d\u00b9\ninst\u271d\u00b9\u00b9 : Monoid G\u271d\u00b2\ninst\u271d\u00b9\u2070 : AddCommGroup A\u271d\nM G\u271d\u00b9 : Type\ninst\u271d\u2079 : Monoid M\ninst\u271d\u2078 : CommGroup G\u271d\u00b9\ninst\u271d\u2077 : MulDistribMulAction M G\u271d\u00b9\ninst\u271d\u2076 : Group G\u271d\u00b9\nA : sorry\nB : sorry\nC : sorry\nk\u271d G\u271d : Type u\ninst\u271d\u2075 : CommRing k\u271d\ninst\u271d\u2074 : Monoid G\u271d\nV W : Type u\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : AddCommGroup W\nk G : Type u\ninst\u271d\u00b9 : CommRing k\ninst\u271d : Monoid G\n\u22a2 MonoidalLinear k (Rep k G)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem unit_iso_comm (V : Rep k G) (g : G) (x : V) :\n    unitIsoAddEquiv ((V.\u03c1 g).toFun x) = ((ofModuleMonoidAlgebra.obj\n      (toModuleMonoidAlgebra.obj V)).\u03c1 g).toFun (unitIsoAddEquiv x) := by\n  simp [unitIsoAddEquiv, ofModuleMonoidAlgebra, toModuleMonoidAlgebra]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/Rep.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "MonoidalCategory in", "Functor.LaxMonoidal Functor.OplaxMonoidal Functor.Monoidal", "MonoidalCategory Action", "MonoidalCategory"], "variables": ["{k G : Type u} [CommRing k]", "[Monoid G]", "(k G)", "{k G}", "(k G)", "{k G}", "{X Y : Action (Type u) G} (f : X \u27f6 Y)", "(k G)", "(k G A : Type u) [CommRing k] [Monoid G] [AddCommGroup A]", "(M G : Type) [Monoid M] [CommGroup G] [MulDistribMulAction M G]", "{k G}", "[Group G] (A B C : Rep k G)", "{A B C}", "(A B C)", "{A B C}", "{k G : Type u} [CommRing k] [Monoid G] {V W : Type u} [AddCommGroup V] [AddCommGroup W]", "{k G : Type u} [CommRing k] [Monoid G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k G : Type u\ninst\u271d\u00b9 : CommRing k\ninst\u271d : Monoid G\nx\u271d : Sort u_1\nunitIsoAddEquiv : x\u271d\nV : Rep k G\ng : G\nx : \u2191V.V\n\u22a2 sorry = sorry"}, {"line": "simp [unitIsoAddEquiv, ofModuleMonoidAlgebra, toModuleMonoidAlgebra]", "tactic_state": "k G : Type u\ninst\u271d\u00b9 : CommRing k\ninst\u271d : Monoid G\nx\u271d : Sort u_1\nunitIsoAddEquiv : x\u271d\nV : Rep k G\ng : G\nx : \u2191V.V\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma asAlgebraHom_mem_of_forall_mem (p : Submodule k V) (hp : \u2200 g, \u2200 v \u2208 p, \u03c1 g v \u2208 p)\n    (v : V) (hv : v \u2208 p) (x : MonoidAlgebra k G) :\n    \u03c1.asAlgebraHom x v \u2208 p := by\n  apply x.induction_on <;> aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/Submodule.lean", "context": {"open": [], "variables": ["{k G V : Type*} [CommSemiring k] [Monoid G] [AddCommMonoid V] [Module k V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nG : Type u_2\nV : Type u_3\ninst\u271d\u00b3 : CommSemiring k\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : AddCommMonoid V\ninst\u271d : Module k V\nx\u271d : Sort u_4\n\u03c1 : x\u271d\np : Submodule k V\nhp : ?m.1543 p \u2192 \u2200 v \u2208 p, sorry \u2208 p\nv : V\nhv : v \u2208 p\nx : MonoidAlgebra k G\n\u22a2 sorry \u2208 p"}, {"line": "apply x.induction_on <;> aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cocyclesMap_id_comp {A B C : Rep k G} (\u03c6 : A \u27f6 B) (\u03c8 : B \u27f6 C) (n : \u2115) :\n    cocyclesMap (MonoidHom.id G) (\u03c6 \u226b \u03c8) n =\n      cocyclesMap (MonoidHom.id G) \u03c6 n \u226b cocyclesMap (MonoidHom.id G) \u03c8 n := by\n  simp [cocyclesMap, cochainsMap_id_comp, HomologicalComplex.cyclesMap_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/Functoriality.lean", "context": {"open": ["Rep CategoryTheory Representation"], "variables": ["{k G H : Type u} [CommRing k] [Group G] [Group H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k G : Type u\ninst\u271d\u00b9 : CommRing k\ninst\u271d : Group G\nx\u271d : Sort u_1\ncocyclesMap : x\u271d\nA B C : Rep k G\n\u03c6 : A \u27f6 B\n\u03c8 : B \u27f6 C\nn : \u2115\n\u22a2 sorry = CategoryStruct.comp sorry sorry"}, {"line": "simp [cocyclesMap, cochainsMap_id_comp, HomologicalComplex.cyclesMap_comp]", "tactic_state": "k G : Type u\ninst\u271d\u00b9 : CommRing k\ninst\u271d : Group G\nx\u271d : Sort u_1\ncocyclesMap : x\u271d\nA B C : Rep k G\n\u03c6 : A \u27f6 B\n\u03c8 : B \u27f6 C\nn : \u2115\n\u22a2 sorry () = CategoryStruct.comp (sorry ()) (sorry ())"}]}
{"declaration": "theorem map_comp_isoH0_hom :\n    map f \u03c6 0 \u226b (isoH0 B).hom = (isoH0 A).hom \u226b H0Map f \u03c6 := by\n  simp [\u2190 cancel_epi (groupCohomology\u03c0 _ _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/Functoriality.lean", "context": {"open": ["Rep CategoryTheory Representation", "ShortComplex"], "variables": ["{k G H : Type u} [CommRing k] [Group G] [Group H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_1\n\u03c6 : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nisoH0 : x\u271d\u00b9\nx\u271d : Sort u_3\nH0Map : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.comp sorry sorry"}, {"line": "simp [\u2190 cancel_epi (groupCohomology\u03c0 _ _)]", "tactic_state": "x\u271d\u00b2 : Sort u_1\n\u03c6 : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nisoH0 : x\u271d\u00b9\nx\u271d : Sort u_3\nH0Map : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.comp (sorry ()) (sorry ())"}]}
{"declaration": "lemma map_comp_isoH1_hom :\n    map f \u03c6 1 \u226b (isoH1 B).hom = (isoH1 A).hom \u226b H1Map f \u03c6 := by\n  simp [\u2190 cancel_epi (groupCohomology\u03c0 _ _), H1Map, Category.assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/Functoriality.lean", "context": {"open": ["Rep CategoryTheory Representation", "ShortComplex"], "variables": ["{k G H : Type u} [CommRing k] [Group G] [Group H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_1\n\u03c6 : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nisoH1 : x\u271d\u00b9\nx\u271d : Sort u_3\nH1Map : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.comp sorry sorry"}, {"line": "simp [\u2190 cancel_epi (groupCohomology\u03c0 _ _), H1Map, Category.assoc]", "tactic_state": "x\u271d\u00b2 : Sort u_1\n\u03c6 : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nisoH1 : x\u271d\u00b9\nx\u271d : Sort u_3\nH1Map : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.comp (sorry ()) (sorry ())"}]}
{"declaration": "lemma map_comp_isoH2_hom :\n    map f \u03c6 2 \u226b (isoH2 B).hom = (isoH2 A).hom \u226b H2Map f \u03c6 := by\n  simp [\u2190 cancel_epi (groupCohomology\u03c0 _ _), H2Map, Category.assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/Functoriality.lean", "context": {"open": ["Rep CategoryTheory Representation", "ShortComplex"], "variables": ["{k G H : Type u} [CommRing k] [Group G] [Group H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_1\n\u03c6 : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nisoH2 : x\u271d\u00b9\nx\u271d : Sort u_3\nH2Map : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.comp sorry sorry"}, {"line": "simp [\u2190 cancel_epi (groupCohomology\u03c0 _ _), H2Map, Category.assoc]", "tactic_state": "x\u271d\u00b2 : Sort u_1\n\u03c6 : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nisoH2 : x\u271d\u00b9\nx\u271d : Sort u_3\nH2Map : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.comp (sorry ()) (sorry ())"}]}
{"declaration": "theorem isMulOneCoboundary_of_isMulOneCocycle_of_aut_to_units\n    (f : (L \u2243\u2090[K] L) \u2192 L\u02e3) (hf : IsMulOneCocycle f) :\n    IsMulOneCoboundary f := by", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/Hilbert90.lean", "context": {"open": ["Hilbert90"], "variables": ["{K L : Type*} [Field K] [Field L] [Algebra K L] [FiniteDimensional K L]", "{K L : Type*} [Field K] [Field L] [Algebra K L] [FiniteDimensional K L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_3\nL : Type u_4\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : FiniteDimensional K L\nx\u271d\u00b9 : Sort u_5\nIsMulOneCocycle : x\u271d\u00b9\nx\u271d : Sort u_6\nIsMulOneCoboundary : x\u271d\nf : (L \u2243\u2090[K] L) \u2192 L\u02e3\nhf : sorry\n\u22a2 sorry"}]}
{"declaration": "theorem map_one_of_isOneCocycle {f : G \u2192 A} (hf : IsOneCocycle f) :\n    f 1 = 0 := by\n  simpa only [mul_one,one_smul,left_eq_add] using hf 1 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/LowDegree.lean", "context": {"open": ["CategoryTheory Limits Representation", "ShortComplex"], "variables": ["{k G : Type u} [CommRing k] [Group G] (A : Rep k G)", "{A}", "(A) in", "{A}", "(A) in", "(A) in", "(A) in", "(A) in", "{G A : Type*} [Mul G] [AddCommGroup A] [SMul G A]", "{G A : Type*} [Monoid G] [AddCommGroup A] [MulAction G A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : AddCommGroup A\ninst\u271d : MulAction G A\nx\u271d : Sort u_3\nIsOneCocycle : x\u271d\nf : G \u2192 A\nhf : sorry\n\u22a2 f 1 = 0"}, {"line": "simpa only [mul_one,one_smul,left_eq_add] using hf 1 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_one_fst_of_isTwoCocycle {f : G \u00d7 G \u2192 A} (hf : IsTwoCocycle f) (g : G) :\n    f (1, g) = f (1, 1) := by\n  simpa only [one_smul,one_mul,mul_one,add_right_inj] using (hf 1 1 g).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/LowDegree.lean", "context": {"open": ["CategoryTheory Limits Representation", "ShortComplex"], "variables": ["{k G : Type u} [CommRing k] [Group G] (A : Rep k G)", "{A}", "(A) in", "{A}", "(A) in", "(A) in", "(A) in", "(A) in", "{G A : Type*} [Mul G] [AddCommGroup A] [SMul G A]", "{G A : Type*} [Monoid G] [AddCommGroup A] [MulAction G A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : AddCommGroup A\ninst\u271d : MulAction G A\nx\u271d : Sort u_3\nIsTwoCocycle : x\u271d\nf : G \u00d7 G \u2192 A\nhf : sorry\ng : G\n\u22a2 f (1, g) = f (1, 1)"}, {"line": "simpa only [one_smul,one_mul,mul_one,add_right_inj] using (hf 1 1 g).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_one_snd_of_isTwoCocycle {f : G \u00d7 G \u2192 A} (hf : IsTwoCocycle f) (g : G) :\n    f (g, 1) = g \u2022 f (1, 1) := by\n  simpa only [mul_one,add_left_inj] using hf g 1 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/LowDegree.lean", "context": {"open": ["CategoryTheory Limits Representation", "ShortComplex"], "variables": ["{k G : Type u} [CommRing k] [Group G] (A : Rep k G)", "{A}", "(A) in", "{A}", "(A) in", "(A) in", "(A) in", "(A) in", "{G A : Type*} [Mul G] [AddCommGroup A] [SMul G A]", "{G A : Type*} [Monoid G] [AddCommGroup A] [MulAction G A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : AddCommGroup A\ninst\u271d : MulAction G A\nx\u271d : Sort u_3\nIsTwoCocycle : x\u271d\nf : G \u00d7 G \u2192 A\nhf : sorry\ng : G\n\u22a2 f (g, 1) = g \u2022 f (1, 1)"}, {"line": "simpa only [mul_one,add_left_inj] using hf g 1 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_one_of_isMulOneCocycle {f : G \u2192 M} (hf : IsMulOneCocycle f) :\n    f 1 = 1 := by\n  simpa only [mul_one,one_smul,left_eq_mul] using hf 1 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/LowDegree.lean", "context": {"open": ["CategoryTheory Limits Representation", "ShortComplex"], "variables": ["{k G : Type u} [CommRing k] [Group G] (A : Rep k G)", "{A}", "(A) in", "{A}", "(A) in", "(A) in", "(A) in", "(A) in", "{G A : Type*} [Mul G] [AddCommGroup A] [SMul G A]", "{G A : Type*} [Monoid G] [AddCommGroup A] [MulAction G A]", "{G A : Type*} [Group G] [AddCommGroup A] [MulAction G A]", "{G A : Type*} [Mul G] [AddCommGroup A] [SMul G A]", "{k G A : Type u} [CommRing k] [Group G] [AddCommGroup A] [Module k A]", "{G M : Type*} [Mul G] [CommGroup M] [SMul G M]", "{G M : Type*} [Monoid G] [CommGroup M] [MulAction G M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_9\nM : Type u_10\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : CommGroup M\ninst\u271d : MulAction G M\nx\u271d : Sort u_11\nIsMulOneCocycle : x\u271d\nf : G \u2192 M\nhf : sorry\n\u22a2 f 1 = 1"}, {"line": "simpa only [mul_one,one_smul,left_eq_mul] using hf 1 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_one_fst_of_isMulTwoCocycle {f : G \u00d7 G \u2192 M} (hf : IsMulTwoCocycle f) (g : G) :\n    f (1, g) = f (1, 1) := by\n  simpa only [one_smul,one_mul,mul_one,mul_right_inj] using (hf 1 1 g).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/LowDegree.lean", "context": {"open": ["CategoryTheory Limits Representation", "ShortComplex"], "variables": ["{k G : Type u} [CommRing k] [Group G] (A : Rep k G)", "{A}", "(A) in", "{A}", "(A) in", "(A) in", "(A) in", "(A) in", "{G A : Type*} [Mul G] [AddCommGroup A] [SMul G A]", "{G A : Type*} [Monoid G] [AddCommGroup A] [MulAction G A]", "{G A : Type*} [Group G] [AddCommGroup A] [MulAction G A]", "{G A : Type*} [Mul G] [AddCommGroup A] [SMul G A]", "{k G A : Type u} [CommRing k] [Group G] [AddCommGroup A] [Module k A]", "{G M : Type*} [Mul G] [CommGroup M] [SMul G M]", "{G M : Type*} [Monoid G] [CommGroup M] [MulAction G M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_9\nM : Type u_10\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : CommGroup M\ninst\u271d : MulAction G M\nx\u271d : Sort u_11\nIsMulTwoCocycle : x\u271d\nf : G \u00d7 G \u2192 M\nhf : sorry\ng : G\n\u22a2 f (1, g) = f (1, 1)"}, {"line": "simpa only [one_smul,one_mul,mul_one,mul_right_inj] using (hf 1 1 g).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_one_snd_of_isMulTwoCocycle {f : G \u00d7 G \u2192 M} (hf : IsMulTwoCocycle f) (g : G) :\n    f (g, 1) = g \u2022 f (1, 1) := by\n  simpa only [mul_one,mul_left_inj] using hf g 1 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/LowDegree.lean", "context": {"open": ["CategoryTheory Limits Representation", "ShortComplex"], "variables": ["{k G : Type u} [CommRing k] [Group G] (A : Rep k G)", "{A}", "(A) in", "{A}", "(A) in", "(A) in", "(A) in", "(A) in", "{G A : Type*} [Mul G] [AddCommGroup A] [SMul G A]", "{G A : Type*} [Monoid G] [AddCommGroup A] [MulAction G A]", "{G A : Type*} [Group G] [AddCommGroup A] [MulAction G A]", "{G A : Type*} [Mul G] [AddCommGroup A] [SMul G A]", "{k G A : Type u} [CommRing k] [Group G] [AddCommGroup A] [Module k A]", "{G M : Type*} [Mul G] [CommGroup M] [SMul G M]", "{G M : Type*} [Monoid G] [CommGroup M] [MulAction G M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_9\nM : Type u_10\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : CommGroup M\ninst\u271d : MulAction G M\nx\u271d : Sort u_11\nIsMulTwoCocycle : x\u271d\nf : G \u00d7 G \u2192 M\nhf : sorry\ng : G\n\u22a2 f (g, 1) = g \u2022 f (1, 1)"}, {"line": "simpa only [mul_one,mul_left_inj] using hf g 1 1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toCocycles_comp_isoOneCocycles_hom :\n    toCocycles A 0 1 \u226b (isoOneCocycles A).hom =\n      (zeroCochainsLequiv A).toModuleIso.hom \u226b\n        ModuleCat.ofHom (shortComplexH1 A).moduleCatToCycles := by\n  simp [isoOneCocycles]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/LowDegree.lean", "context": {"open": ["CategoryTheory Limits Representation", "ShortComplex", "ShortComplex"], "variables": ["{k G : Type u} [CommRing k] [Group G] (A : Rep k G)", "{A}", "(A) in", "{A}", "(A) in", "(A) in", "(A) in", "(A) in", "{G A : Type*} [Mul G] [AddCommGroup A] [SMul G A]", "{G A : Type*} [Monoid G] [AddCommGroup A] [MulAction G A]", "{G A : Type*} [Group G] [AddCommGroup A] [MulAction G A]", "{G A : Type*} [Mul G] [AddCommGroup A] [SMul G A]", "{k G A : Type u} [CommRing k] [Group G] [AddCommGroup A] [Module k A]", "{G M : Type*} [Mul G] [CommGroup M] [SMul G M]", "{G M : Type*} [Monoid G] [CommGroup M] [MulAction G M]", "{G M : Type*} [Group G] [CommGroup M] [MulAction G M]", "{G M : Type*} [Mul G] [CommGroup M] [SMul G M]", "{G M : Type} [Group G] [CommGroup M] [MulDistribMulAction G M]", "{A} in", "{A} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b3 : Sort u_15\ntoCocycles : x\u271d\u00b3\nx\u271d\u00b2 : Sort u_16\nisoOneCocycles : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_17\nzeroCochainsLequiv : x\u271d\u00b9\nx\u271d : Sort u_18\nshortComplexH1 : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.comp sorry (ModuleCat.ofHom sorry)"}, {"line": "simp [isoOneCocycles]", "tactic_state": "x\u271d\u00b3 : Sort u_15\ntoCocycles : x\u271d\u00b3\nx\u271d\u00b2 : Sort u_16\nisoOneCocycles : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_17\nzeroCochainsLequiv : x\u271d\u00b9\nx\u271d : Sort u_18\nshortComplexH1 : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.comp (sorry ()) (ModuleCat.ofHom (sorry ()))"}]}
{"declaration": "lemma toCocycles_comp_isoTwoCocycles_hom :\n    toCocycles A 1 2 \u226b (isoTwoCocycles A).hom =\n      (oneCochainsLequiv A).toModuleIso.hom \u226b\n        ModuleCat.ofHom (shortComplexH2 A).moduleCatToCycles := by\n  simp [isoTwoCocycles]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/LowDegree.lean", "context": {"open": ["CategoryTheory Limits Representation", "ShortComplex", "ShortComplex"], "variables": ["{k G : Type u} [CommRing k] [Group G] (A : Rep k G)", "{A}", "(A) in", "{A}", "(A) in", "(A) in", "(A) in", "(A) in", "{G A : Type*} [Mul G] [AddCommGroup A] [SMul G A]", "{G A : Type*} [Monoid G] [AddCommGroup A] [MulAction G A]", "{G A : Type*} [Group G] [AddCommGroup A] [MulAction G A]", "{G A : Type*} [Mul G] [AddCommGroup A] [SMul G A]", "{k G A : Type u} [CommRing k] [Group G] [AddCommGroup A] [Module k A]", "{G M : Type*} [Mul G] [CommGroup M] [SMul G M]", "{G M : Type*} [Monoid G] [CommGroup M] [MulAction G M]", "{G M : Type*} [Group G] [CommGroup M] [MulAction G M]", "{G M : Type*} [Mul G] [CommGroup M] [SMul G M]", "{G M : Type} [Group G] [CommGroup M] [MulDistribMulAction G M]", "{A} in", "{A} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b3 : Sort u_15\ntoCocycles : x\u271d\u00b3\nx\u271d\u00b2 : Sort u_16\nisoTwoCocycles : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_17\noneCochainsLequiv : x\u271d\u00b9\nx\u271d : Sort u_18\nshortComplexH2 : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.comp sorry (ModuleCat.ofHom sorry)"}, {"line": "simp [isoTwoCocycles]", "tactic_state": "x\u271d\u00b3 : Sort u_15\ntoCocycles : x\u271d\u00b3\nx\u271d\u00b2 : Sort u_16\nisoTwoCocycles : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_17\noneCochainsLequiv : x\u271d\u00b9\nx\u271d : Sort u_18\nshortComplexH2 : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.comp (sorry ()) (ModuleCat.ofHom (sorry ()))"}]}
{"declaration": "theorem diagonalHomEquiv_apply (f : Rep.diagonal k G (n + 1) \u27f6 A) (x : Fin n \u2192 G) :\n    diagonalHomEquiv n A f x = f.hom (Finsupp.single (Fin.partialProd x) 1) := by", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/Resolution.lean", "context": {"open": ["CategoryTheory Finsupp", "Finsupp hiding lift", "MonoidalCategory", "Fin (partialProd)", "Action", "Rep", "scoped TensorProduct", "Representation", "groupCohomology.resolution"], "variables": ["{k G : Type u} [CommRing k] {n : \u2115}", "(k G n) [Group G]", "{k G n}", "(n) [Group G] (A : Rep k G)", "{n A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k G : Type u\ninst\u271d\u00b2 : CommRing k\nn : \u2115\ninst\u271d\u00b9 inst\u271d : Group G\nA : Rep k G\nf : Rep.diagonal k G (n + 1) \u27f6 A\nx : Fin n \u2192 G\n\u22a2 (diagonalHomEquiv n A) f x = (ConcreteCategory.hom f.hom) fun\u2080 | partialProd x => 1"}]}
{"declaration": "theorem diagonalHomEquiv_symm_apply (f : (Fin n \u2192 G) \u2192 A) (x : Fin (n + 1) \u2192 G) :\n    ((diagonalHomEquiv n A).symm f).hom (Finsupp.single x 1) =\n      A.\u03c1 (x 0) (f fun i : Fin n => (x (Fin.castSucc i))\u207b\u00b9 * x i.succ) := by\n  unfold diagonalHomEquiv", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/Resolution.lean", "context": {"open": ["CategoryTheory Finsupp", "Finsupp hiding lift", "MonoidalCategory", "Fin (partialProd)", "Action", "Rep", "scoped TensorProduct", "Representation", "groupCohomology.resolution"], "variables": ["{k G : Type u} [CommRing k] {n : \u2115}", "(k G n) [Group G]", "{k G n}", "(n) [Group G] (A : Rep k G)", "{n A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k G : Type u\ninst\u271d\u00b2 : CommRing k\nn : \u2115\ninst\u271d\u00b9 inst\u271d : Group G\nA : Rep k G\nf : (Fin n \u2192 G) \u2192 \u2191A.V\nx : Fin (n + 1) \u2192 G\n\u22a2 ((ConcreteCategory.hom ((diagonalHomEquiv n A).symm f).hom) fun\u2080 | x => 1) =\n    (A.\u03c1 (x 0)) (f fun i => (x i.castSucc)\u207b\u00b9 * x i.succ)"}, {"line": "unfold diagonalHomEquiv", "tactic_state": "k G : Type u\ninst\u271d\u00b2 : CommRing k\nn : \u2115\ninst\u271d\u00b9 inst\u271d : Group G\nA : Rep k G\nf : (Fin n \u2192 G) \u2192 \u2191A.V\nx : Fin (n + 1) \u2192 G\n\u22a2 ((ConcreteCategory.hom\n        ((((Linear.homCongr k\n                        (groupCohomology.resolution.diagonalSucc k G n \u226a\u226b\n                          (Representation.ofMulAction k G G).repOfTprodIso 1)\n                        (Iso.refl A)).trans\n                    ((MonoidalClosed.linearHomEquivComm (of (Representation.ofMulAction k G G)) (of 1) A).trans\n                      ((ihom (of 1)).obj A).leftRegularHomEquiv)).trans\n                (llift (\u2191A.V) k k (Fin n \u2192 G)).symm).symm\n            f).hom)\n      fun\u2080 | x => 1) =\n    (A.\u03c1 (x 0)) (f fun i => (x i.castSucc)\u207b\u00b9 * x i.succ)"}]}
{"declaration": "theorem diagonalHomEquiv_symm_partialProd_succ (f : (Fin n \u2192 G) \u2192 A) (g : Fin (n + 1) \u2192 G)\n    (a : Fin (n + 1)) :\n    ((diagonalHomEquiv n A).symm f).hom (Finsupp.single (Fin.partialProd g \u2218 a.succ.succAbove) 1)\n      = f (Fin.contractNth a (\u00b7 * \u00b7) g) := by\n  simp only [diagonalHomEquiv_symm_apply]\n  simp only [Function.comp_apply]\n  simp only [Fin.succ_succAbove_zero]\n  simp only [Fin.partialProd_zero]\n  simp only [map_one]\n  simp only [Fin.succ_succAbove_succ]\n  simp only [Module.End.one_apply]\n  simp only [Fin.partialProd_succ]\n  congr\n  ext\n  rw [\u2190 Fin.partialProd_succ]\n  rw [Fin.inv_partialProd_mul_eq_contractNth]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/Resolution.lean", "context": {"open": ["CategoryTheory Finsupp", "Finsupp hiding lift", "MonoidalCategory", "Fin (partialProd)", "Action", "Rep", "scoped TensorProduct", "Representation", "groupCohomology.resolution"], "variables": ["{k G : Type u} [CommRing k] {n : \u2115}", "(k G n) [Group G]", "{k G n}", "(n) [Group G] (A : Rep k G)", "{n A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k G : Type u\ninst\u271d\u00b2 : CommRing k\nn : \u2115\ninst\u271d\u00b9 inst\u271d : Group G\nA : Rep k G\nf : (Fin n \u2192 G) \u2192 \u2191A.V\ng : Fin (n + 1) \u2192 G\na : Fin (n + 1)\n\u22a2 ((ConcreteCategory.hom ((diagonalHomEquiv n A).symm f).hom) fun\u2080 | partialProd g \u2218 a.succ.succAbove => 1) =\n    f (a.contractNth (fun x1 x2 => x1 * x2) g)"}, {"line": "simp only [diagonalHomEquiv_symm_apply]", "tactic_state": "k G : Type u\ninst\u271d\u00b2 : CommRing k\nn : \u2115\ninst\u271d\u00b9 inst\u271d : Group G\nA : Rep k G\nf : (Fin n \u2192 G) \u2192 \u2191A.V\ng : Fin (n + 1) \u2192 G\na : Fin (n + 1)\n\u22a2 (A.\u03c1 ((partialProd g \u2218 a.succ.succAbove) 0))\n      (f fun i => ((partialProd g \u2218 a.succ.succAbove) i.castSucc)\u207b\u00b9 * (partialProd g \u2218 a.succ.succAbove) i.succ) =\n    f (a.contractNth (fun x1 x2 => x1 * x2) g)"}, {"line": "simp only [Function.comp_apply]", "tactic_state": "k G : Type u\ninst\u271d\u00b2 : CommRing k\nn : \u2115\ninst\u271d\u00b9 inst\u271d : Group G\nA : Rep k G\nf : (Fin n \u2192 G) \u2192 \u2191A.V\ng : Fin (n + 1) \u2192 G\na : Fin (n + 1)\n\u22a2 (A.\u03c1 (partialProd g (a.succ.succAbove 0)))\n      (f fun i => (partialProd g (a.succ.succAbove i.castSucc))\u207b\u00b9 * partialProd g (a.succ.succAbove i.succ)) =\n    f (a.contractNth (fun x1 x2 => x1 * x2) g)"}, {"line": "simp only [Fin.succ_succAbove_zero]", "tactic_state": "k G : Type u\ninst\u271d\u00b2 : CommRing k\nn : \u2115\ninst\u271d\u00b9 inst\u271d : Group G\nA : Rep k G\nf : (Fin n \u2192 G) \u2192 \u2191A.V\ng : Fin (n + 1) \u2192 G\na : Fin (n + 1)\n\u22a2 (A.\u03c1 (partialProd g 0))\n      (f fun i => (partialProd g (a.succ.succAbove i.castSucc))\u207b\u00b9 * partialProd g (a.succ.succAbove i.succ)) =\n    f (a.contractNth (fun x1 x2 => x1 * x2) g)"}, {"line": "simp only [Fin.partialProd_zero]", "tactic_state": "k G : Type u\ninst\u271d\u00b2 : CommRing k\nn : \u2115\ninst\u271d\u00b9 inst\u271d : Group G\nA : Rep k G\nf : (Fin n \u2192 G) \u2192 \u2191A.V\ng : Fin (n + 1) \u2192 G\na : Fin (n + 1)\n\u22a2 (A.\u03c1 1) (f fun i => (partialProd g (a.succ.succAbove i.castSucc))\u207b\u00b9 * partialProd g (a.succ.succAbove i.succ)) =\n    f (a.contractNth (fun x1 x2 => x1 * x2) g)"}, {"line": "simp only [map_one]", "tactic_state": "k G : Type u\ninst\u271d\u00b2 : CommRing k\nn : \u2115\ninst\u271d\u00b9 inst\u271d : Group G\nA : Rep k G\nf : (Fin n \u2192 G) \u2192 \u2191A.V\ng : Fin (n + 1) \u2192 G\na : Fin (n + 1)\n\u22a2 1 (f fun i => (partialProd g (a.succ.succAbove i.castSucc))\u207b\u00b9 * partialProd g (a.succ.succAbove i.succ)) =\n    f (a.contractNth (fun x1 x2 => x1 * x2) g)"}, {"line": "simp only [Fin.succ_succAbove_succ]", "tactic_state": "k G : Type u\ninst\u271d\u00b2 : CommRing k\nn : \u2115\ninst\u271d\u00b9 inst\u271d : Group G\nA : Rep k G\nf : (Fin n \u2192 G) \u2192 \u2191A.V\ng : Fin (n + 1) \u2192 G\na : Fin (n + 1)\n\u22a2 1 (f fun i => (partialProd g (a.succ.succAbove i.castSucc))\u207b\u00b9 * partialProd g (a.succAbove i).succ) =\n    f (a.contractNth (fun x1 x2 => x1 * x2) g)"}, {"line": "simp only [Module.End.one_apply]", "tactic_state": "k G : Type u\ninst\u271d\u00b2 : CommRing k\nn : \u2115\ninst\u271d\u00b9 inst\u271d : Group G\nA : Rep k G\nf : (Fin n \u2192 G) \u2192 \u2191A.V\ng : Fin (n + 1) \u2192 G\na : Fin (n + 1)\n\u22a2 (f fun i => (partialProd g (a.succ.succAbove i.castSucc))\u207b\u00b9 * partialProd g (a.succAbove i).succ) =\n    f (a.contractNth (fun x1 x2 => x1 * x2) g)"}, {"line": "simp only [Fin.partialProd_succ]", "tactic_state": "k G : Type u\ninst\u271d\u00b2 : CommRing k\nn : \u2115\ninst\u271d\u00b9 inst\u271d : Group G\nA : Rep k G\nf : (Fin n \u2192 G) \u2192 \u2191A.V\ng : Fin (n + 1) \u2192 G\na : Fin (n + 1)\n\u22a2 (f fun i =>\n      (partialProd g (a.succ.succAbove i.castSucc))\u207b\u00b9 * (partialProd g (a.succAbove i).castSucc * g (a.succAbove i))) =\n    f (a.contractNth (fun x1 x2 => x1 * x2) g)"}, {"line": "congr", "tactic_state": "case e_a\nk G : Type u\ninst\u271d\u00b2 : CommRing k\nn : \u2115\ninst\u271d\u00b9 inst\u271d : Group G\nA : Rep k G\nf : (Fin n \u2192 G) \u2192 \u2191A.V\ng : Fin (n + 1) \u2192 G\na : Fin (n + 1)\n\u22a2 (fun i =>\n      (partialProd g (a.succ.succAbove i.castSucc))\u207b\u00b9 * (partialProd g (a.succAbove i).castSucc * g (a.succAbove i))) =\n    a.contractNth (fun x1 x2 => x1 * x2) g"}, {"line": "ext", "tactic_state": "case e_a.h\nk G : Type u\ninst\u271d\u00b2 : CommRing k\nn : \u2115\ninst\u271d\u00b9 inst\u271d : Group G\nA : Rep k G\nf : (Fin n \u2192 G) \u2192 \u2191A.V\ng : Fin (n + 1) \u2192 G\na : Fin (n + 1)\nx\u271d : Fin n\n\u22a2 (partialProd g (a.succ.succAbove x\u271d.castSucc))\u207b\u00b9 * (partialProd g (a.succAbove x\u271d).castSucc * g (a.succAbove x\u271d)) =\n    a.contractNth (fun x1 x2 => x1 * x2) g x\u271d"}, {"line": "rw [\u2190 Fin.partialProd_succ]", "tactic_state": "case e_a.h\nk G : Type u\ninst\u271d\u00b2 : CommRing k\nn : \u2115\ninst\u271d\u00b9 inst\u271d : Group G\nA : Rep k G\nf : (Fin n \u2192 G) \u2192 \u2191A.V\ng : Fin (n + 1) \u2192 G\na : Fin (n + 1)\nx\u271d : Fin n\n\u22a2 (partialProd g (a.succ.succAbove x\u271d.castSucc))\u207b\u00b9 * partialProd g (a.succAbove x\u271d).succ =\n    a.contractNth (fun x1 x2 => x1 * x2) g x\u271d"}, {"line": "rw [Fin.inv_partialProd_mul_eq_contractNth]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem d_of {G : Type u} {n : \u2115} (c : Fin (n + 1) \u2192 G) :\n    d k G n (Finsupp.single c 1) =\n      Finset.univ.sum fun p : Fin (n + 1) =>\n        Finsupp.single (c \u2218 p.succAbove) ((-1 : k) ^ (p : \u2115)) := by\n  simp [d]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/Resolution.lean", "context": {"open": ["CategoryTheory Finsupp", "Finsupp hiding lift", "MonoidalCategory", "Fin (partialProd)", "Action", "Rep", "scoped TensorProduct", "Representation", "groupCohomology.resolution", "CategoryTheory CategoryTheory.Limits", "AlgebraicTopology SimplicialObject.Augmented SimplicialObject CategoryTheory.Arrow", "classifyingSpaceUniversalCover AlgebraicTopology CategoryTheory CategoryTheory.Limits"], "variables": ["{k G : Type u} [CommRing k] {n : \u2115}", "(k G n) [Group G]", "{k G n}", "(n) [Group G] (A : Rep k G)", "{n A}", "(G)", "[Monoid G]", "(k)", "(k)", "[Monoid G]", "{k G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u\ninst\u271d : CommRing k\nG : Type u\nn : \u2115\nc : Fin (n + 1) \u2192 G\n\u22a2 ((d k G n) fun\u2080 | c => 1) = \u2211 p, fun\u2080 | c \u2218 p.succAbove => (-1) ^ \u2191p"}, {"line": "simp [d]", "tactic_state": "k : Type u\ninst\u271d : CommRing k\nG : Type u\nn : \u2115\nc : Fin (n + 1) \u2192 G\n\u22a2 (1 \u2022 \u2211 p, fun\u2080 | c \u2218 p.succAbove => (-1) ^ \u2191p) = \u2211 p, fun\u2080 | c \u2218 p.succAbove => (-1) ^ \u2191p"}]}
{"declaration": "theorem \u03b5ToSingle\u2080_comp_eq :\n    ((forget\u2082 _ (ModuleCat.{u} k)).mapHomologicalComplex _).map (\u03b5ToSingle\u2080 k G) \u226b\n        (HomologicalComplex.singleMapHomologicalComplex _ _ _).hom.app _ =\n      (forget\u2082ToModuleCatHomotopyEquiv k G).hom := by\n  dsimp\n  ext1\n  dsimp\n  simpa using (forget\u2082ToModuleCatHomotopyEquiv_f_0_eq k G).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RepresentationTheory/GroupCohomology/Resolution.lean", "context": {"open": ["CategoryTheory Finsupp", "Finsupp hiding lift", "MonoidalCategory", "Fin (partialProd)", "Action", "Rep", "scoped TensorProduct", "Representation", "groupCohomology.resolution", "CategoryTheory CategoryTheory.Limits", "AlgebraicTopology SimplicialObject.Augmented SimplicialObject CategoryTheory.Arrow", "classifyingSpaceUniversalCover AlgebraicTopology CategoryTheory CategoryTheory.Limits"], "variables": ["{k G : Type u} [CommRing k] {n : \u2115}", "(k G n) [Group G]", "{k G n}", "(n) [Group G] (A : Rep k G)", "{n A}", "(G)", "[Monoid G]", "(k)", "(k)", "[Monoid G]", "{k G}", "(k G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k G : Type u\ninst\u271d\u2074 : CommRing k\ninst\u271d\u00b3 inst\u271d\u00b2 : Group G\ninst\u271d\u00b9 inst\u271d : Monoid G\n\u22a2 CategoryStruct.comp\n      (((forget\u2082 (Rep k G) (ModuleCat k)).mapHomologicalComplex (ComplexShape.down \u2115)).map (\u03b5ToSingle\u2080 k G))\n      ((HomologicalComplex.singleMapHomologicalComplex (forget\u2082 (Rep k G) (ModuleCat k)) (ComplexShape.down \u2115)\n              0).hom.app\n        (Rep.trivial k G k)) =\n    (forget\u2082ToModuleCatHomotopyEquiv k G).hom"}, {"line": "dsimp", "tactic_state": "k G : Type u\ninst\u271d\u2074 : CommRing k\ninst\u271d\u00b3 inst\u271d\u00b2 : Group G\ninst\u271d\u00b9 inst\u271d : Monoid G\n\u22a2 CategoryStruct.comp\n      (((forget\u2082 (Rep k G) (ModuleCat k)).mapHomologicalComplex (ComplexShape.down \u2115)).map (\u03b5ToSingle\u2080 k G))\n      ((HomologicalComplex.singleMapHomologicalComplex (forget\u2082 (Rep k G) (ModuleCat k)) (ComplexShape.down \u2115)\n              0).hom.app\n        (Rep.trivial k G k)) =\n    (forget\u2082ToModuleCatHomotopyEquiv k G).hom"}, {"line": "ext1", "tactic_state": "case hfg\nk G : Type u\ninst\u271d\u2074 : CommRing k\ninst\u271d\u00b3 inst\u271d\u00b2 : Group G\ninst\u271d\u00b9 inst\u271d : Monoid G\n\u22a2 (CategoryStruct.comp\n          (((forget\u2082 (Rep k G) (ModuleCat k)).mapHomologicalComplex (ComplexShape.down \u2115)).map (\u03b5ToSingle\u2080 k G))\n          ((HomologicalComplex.singleMapHomologicalComplex (forget\u2082 (Rep k G) (ModuleCat k)) (ComplexShape.down \u2115)\n                  0).hom.app\n            (Rep.trivial k G k))).f\n      0 =\n    (forget\u2082ToModuleCatHomotopyEquiv k G).hom.f 0"}, {"line": "dsimp", "tactic_state": "case hfg\nk G : Type u\ninst\u271d\u2074 : CommRing k\ninst\u271d\u00b3 inst\u271d\u00b2 : Group G\ninst\u271d\u00b9 inst\u271d : Monoid G\n\u22a2 CategoryStruct.comp ((forget\u2082 (Rep k G) (ModuleCat k)).map ((\u03b5ToSingle\u2080 k G).f 0))\n      (((HomologicalComplex.singleMapHomologicalComplex (forget\u2082 (Rep k G) (ModuleCat k)) (ComplexShape.down \u2115)\n                  0).hom.app\n            (Rep.trivial k G k)).f\n        0) =\n    (forget\u2082ToModuleCatHomotopyEquiv k G).hom.f 0"}, {"line": "simpa using (forget\u2082ToModuleCatHomotopyEquiv_f_0_eq k G).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem adjoinRoot_eq_top : Algebra.adjoin R ({root f} : Set (AdjoinRoot f)) = \u22a4 := by\n  refine Algebra.eq_top_iff.2 fun x => ?_\n  induction x using AdjoinRoot.induction_on with\n    | ih p => exact (Algebra.adjoin_singleton_eq_range_aeval R (root f)).symm \u25b8 \u27e8p, aeval_eq p\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AdjoinRoot.lean", "context": {"open": ["Polynomial", "Polynomial Ideal"], "variables": ["{R : Type u} {S : Type v} {K : Type w}", "[CommRing R] (f : R[X])", "(S) in", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nf : Polynomial R\nx\u271d : Sort u_1\nroot : x\u271d\n\u22a2 Algebra.adjoin R {sorry} = \u22a4"}, {"line": "refine Algebra.eq_top_iff.2 fun x => ?_", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nf : Polynomial R\nx\u271d : Sort u_1\nroot : x\u271d\nx : AdjoinRoot f\n\u22a2 x \u2208 Algebra.adjoin R {sorry}"}, {"line": "induction x using AdjoinRoot.induction_on with\n    | ih p => exact (Algebra.adjoin_singleton_eq_range_aeval R (root f)).symm \u25b8 \u27e8p, aeval_eq p\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Minpoly.toAdjoin.apply_X :\n    Minpoly.toAdjoin R x (mk (minpoly R x) X) = \u27e8x, self_mem_adjoin_singleton R x\u27e9 := by\n  simp [toAdjoin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AdjoinRoot.lean", "context": {"open": ["Polynomial", "Polynomial Ideal", "Algebra Polynomial"], "variables": ["{R : Type u} {S : Type v} {K : Type w}", "[CommRing R] (f : R[X])", "(S) in", "{f}", "[CommRing S]", "{i : R \u2192+* S} {a : S} (h : f.eval\u2082 i a = 0)", "(f) [Algebra R S]", "(hfx : aeval a f = 0)", "{f}", "[Field K] {f : K[X]}", "(f)", "[CommRing R] {g : R[X]}", "[Field K] {f : K[X]}", "[CommRing R] [CommRing S] [Algebra R S] (x : S) (R)", "{R x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = sorry"}, {"line": "simp [toAdjoin]", "tactic_state": "\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem quotientEquivQuotientMinpolyMap_apply_mk (pb : PowerBasis R S) (I : Ideal R) (g : R[X]) :\n    pb.quotientEquivQuotientMinpolyMap I (Ideal.Quotient.mk (I.map (algebraMap R S))\n      (aeval pb.gen g)) = Ideal.Quotient.mk\n        (Ideal.span ({(minpoly R pb.gen).map (Ideal.Quotient.mk I)} : Set (Polynomial (R \u29f8 I))))\n          (g.map (Ideal.Quotient.mk I)) := by\n  rw [PowerBasis.quotientEquivQuotientMinpolyMap]\n  rw [AlgEquiv.trans_apply]\n  rw [AlgEquiv.ofRingEquiv_apply]\n  rw [quotientEquiv_mk]\n  rw [AlgEquiv.coe_ringEquiv']\n  rw [AdjoinRoot.equiv'_symm_apply]\n  rw [PowerBasis.lift_aeval]\n  rw [AdjoinRoot.aeval_eq]\n  rw [AdjoinRoot.quotEquivQuotMap_apply_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AdjoinRoot.lean", "context": {"open": ["Polynomial", "Polynomial Ideal", "Algebra Polynomial", "Ideal DoubleQuot Polynomial", "AdjoinRoot AlgEquiv"], "variables": ["{R : Type u} {S : Type v} {K : Type w}", "[CommRing R] (f : R[X])", "(S) in", "{f}", "[CommRing S]", "{i : R \u2192+* S} {a : S} (h : f.eval\u2082 i a = 0)", "(f) [Algebra R S]", "(hfx : aeval a f = 0)", "{f}", "[Field K] {f : K[X]}", "(f)", "[CommRing R] {g : R[X]}", "[Field K] {f : K[X]}", "[CommRing R] [CommRing S] [Algebra R S] (x : S) (R)", "{R x}", "(R x)", "[CommRing R] [CommRing S] [Algebra R S]", "(g : R[X]) (pb : PowerBasis R S)", "(L F : Type*) [Field F] [CommRing L] [IsDomain L] [Algebra F L]", "[CommRing R] (I : Ideal R) (f : R[X])", "[CommRing R] [CommRing S] [Algebra R S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\npb : PowerBasis R S\nI : Ideal R\ng : Polynomial R\n\u22a2 (pb.quotientEquivQuotientMinpolyMap I) ((Ideal.Quotient.mk (Ideal.map (algebraMap R S) I)) ((aeval pb.gen) g)) =\n    (Ideal.Quotient.mk (span {Polynomial.map (Ideal.Quotient.mk I) (minpoly R pb.gen)}))\n      (Polynomial.map (Ideal.Quotient.mk I) g)"}, {"line": "rw [PowerBasis.quotientEquivQuotientMinpolyMap]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\npb : PowerBasis R S\nI : Ideal R\ng : Polynomial R\n\u22a2 ((ofRingEquiv \u22ef).trans (quotEquivQuotMap (minpoly R pb.gen) I))\n      ((Ideal.Quotient.mk (Ideal.map (algebraMap R S) I)) ((aeval pb.gen) g)) =\n    (Ideal.Quotient.mk (span {Polynomial.map (Ideal.Quotient.mk I) (minpoly R pb.gen)}))\n      (Polynomial.map (Ideal.Quotient.mk I) g)"}, {"line": "rw [AlgEquiv.trans_apply]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\npb : PowerBasis R S\nI : Ideal R\ng : Polynomial R\n\u22a2 (quotEquivQuotMap (minpoly R pb.gen) I)\n      ((ofRingEquiv \u22ef) ((Ideal.Quotient.mk (Ideal.map (algebraMap R S) I)) ((aeval pb.gen) g))) =\n    (Ideal.Quotient.mk (span {Polynomial.map (Ideal.Quotient.mk I) (minpoly R pb.gen)}))\n      (Polynomial.map (Ideal.Quotient.mk I) g)"}, {"line": "rw [AlgEquiv.ofRingEquiv_apply]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\npb : PowerBasis R S\nI : Ideal R\ng : Polynomial R\n\u22a2 (quotEquivQuotMap (minpoly R pb.gen) I)\n      (((Ideal.map (algebraMap R S) I).quotientEquiv (Ideal.map (of (minpoly R pb.gen)) I)\n          (equiv' (minpoly R pb.gen) pb \u22ef \u22ef).symm.toRingEquiv \u22ef)\n        ((Ideal.Quotient.mk (Ideal.map (algebraMap R S) I)) ((aeval pb.gen) g))) =\n    (Ideal.Quotient.mk (span {Polynomial.map (Ideal.Quotient.mk I) (minpoly R pb.gen)}))\n      (Polynomial.map (Ideal.Quotient.mk I) g)"}, {"line": "rw [quotientEquiv_mk]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\npb : PowerBasis R S\nI : Ideal R\ng : Polynomial R\n\u22a2 (quotEquivQuotMap (minpoly R pb.gen) I)\n      ((Ideal.Quotient.mk (Ideal.map (of (minpoly R pb.gen)) I))\n        ((equiv' (minpoly R pb.gen) pb \u22ef \u22ef).symm.toRingEquiv ((aeval pb.gen) g))) =\n    (Ideal.Quotient.mk (span {Polynomial.map (Ideal.Quotient.mk I) (minpoly R pb.gen)}))\n      (Polynomial.map (Ideal.Quotient.mk I) g)"}, {"line": "rw [AlgEquiv.coe_ringEquiv']", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\npb : PowerBasis R S\nI : Ideal R\ng : Polynomial R\n\u22a2 (quotEquivQuotMap (minpoly R pb.gen) I)\n      ((Ideal.Quotient.mk (Ideal.map (of (minpoly R pb.gen)) I))\n        ((equiv' (minpoly R pb.gen) pb \u22ef \u22ef).symm ((aeval pb.gen) g))) =\n    (Ideal.Quotient.mk (span {Polynomial.map (Ideal.Quotient.mk I) (minpoly R pb.gen)}))\n      (Polynomial.map (Ideal.Quotient.mk I) g)"}, {"line": "rw [AdjoinRoot.equiv'_symm_apply]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\npb : PowerBasis R S\nI : Ideal R\ng : Polynomial R\n\u22a2 (quotEquivQuotMap (minpoly R pb.gen) I)\n      ((Ideal.Quotient.mk (Ideal.map (of (minpoly R pb.gen)) I))\n        ((pb.lift (root (minpoly R pb.gen)) \u22ef) ((aeval pb.gen) g))) =\n    (Ideal.Quotient.mk (span {Polynomial.map (Ideal.Quotient.mk I) (minpoly R pb.gen)}))\n      (Polynomial.map (Ideal.Quotient.mk I) g)"}, {"line": "rw [PowerBasis.lift_aeval]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\npb : PowerBasis R S\nI : Ideal R\ng : Polynomial R\n\u22a2 (quotEquivQuotMap (minpoly R pb.gen) I)\n      ((Ideal.Quotient.mk (Ideal.map (of (minpoly R pb.gen)) I)) ((aeval (root (minpoly R pb.gen))) g)) =\n    (Ideal.Quotient.mk (span {Polynomial.map (Ideal.Quotient.mk I) (minpoly R pb.gen)}))\n      (Polynomial.map (Ideal.Quotient.mk I) g)"}, {"line": "rw [AdjoinRoot.aeval_eq]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\npb : PowerBasis R S\nI : Ideal R\ng : Polynomial R\n\u22a2 (quotEquivQuotMap (minpoly R pb.gen) I)\n      ((Ideal.Quotient.mk (Ideal.map (of (minpoly R pb.gen)) I)) ((AdjoinRoot.mk (minpoly R pb.gen)) g)) =\n    (Ideal.Quotient.mk (span {Polynomial.map (Ideal.Quotient.mk I) (minpoly R pb.gen)}))\n      (Polynomial.map (Ideal.Quotient.mk I) g)"}, {"line": "rw [AdjoinRoot.quotEquivQuotMap_apply_mk]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasseDeriv_single_add (k : \u2115) (n : \u2124) (x : V) :\n    hasseDeriv R k (single (n + k) x) = single n ((Ring.choose (n + k) k) \u2022 x) := by\n  ext m\n  dsimp only [hasseDeriv_coeff]\n  by_cases h : m = n\n  \u00b7 simp [h]\n  \u00b7 simp [h, show m + k \u2260 n + k by omega]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LaurentSeries.lean", "context": {"open": ["scoped PowerSeries", "HahnSeries Polynomial"], "variables": ["{R : Type*}", "[Semiring R] {V : Type*} [AddCommGroup V] [Module R V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_2\ninst\u271d : AddCommGroup V\nk : \u2115\nn : \u2124\nx : V\n\u22a2 sorry = (single n) (Ring.choose (n + \u2191k) k \u2022 x)"}, {"line": "ext m", "tactic_state": "case coeff.h\nV : Type u_2\ninst\u271d : AddCommGroup V\nk : \u2115\nn : \u2124\nx : V\nm : \u2124\n\u22a2 sorry.coeff m = ((single n) (Ring.choose (n + \u2191k) k \u2022 x)).coeff m"}, {"line": "dsimp only [hasseDeriv_coeff]", "tactic_state": "case coeff.h\nV : Type u_2\ninst\u271d : AddCommGroup V\nk : \u2115\nn : \u2124\nx : V\nm : \u2124\n\u22a2 sorry.coeff m = ((single n) (Ring.choose (n + \u2191k) k \u2022 x)).coeff m"}, {"line": "by_cases h : m = n", "tactic_state": "case pos\nV : Type u_2\ninst\u271d : AddCommGroup V\nk : \u2115\nn : \u2124\nx : V\nm : \u2124\nh : m = n\n\u22a2 sorry.coeff m = ((single n) (Ring.choose (n + \u2191k) k \u2022 x)).coeff m\n---\ncase neg\nV : Type u_2\ninst\u271d : AddCommGroup V\nk : \u2115\nn : \u2124\nx : V\nm : \u2124\nh : \u00acm = n\n\u22a2 sorry.coeff m = ((single n) (Ring.choose (n + \u2191k) k \u2022 x)).coeff m"}, {"line": "\u00b7 simp [h]", "tactic_state": "case neg\nV : Type u_2\ninst\u271d : AddCommGroup V\nk : \u2115\nn : \u2124\nx : V\nm : \u2124\nh : \u00acm = n\n\u22a2 sorry.coeff m = ((single n) (Ring.choose (n + \u2191k) k \u2022 x)).coeff m"}, {"line": "\u00b7 simp [h, show m + k \u2260 n + k by omega]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : S\u27e6X\u27e7) :\n    ((r \u2022 x : S\u27e6X\u27e7) : S\u2e28X\u2e29) = r \u2022 (ofPowerSeries \u2124 S x) := by\n  ext\n  simp [coeff_coe, coeff_smul, smul_ite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LaurentSeries.lean", "context": {"open": ["scoped PowerSeries", "HahnSeries Polynomial", "LaurentSeries"], "variables": ["{R : Type*}", "[Semiring R] {V : Type*} [AddCommGroup V] [Module R V]", "[Semiring R]", "{R' : Type*} [Semiring R] [Ring R'] (f g : R\u27e6X\u27e7) (f' g' : R'\u27e6X\u27e7)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Semiring R\nS : Type u_4\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Module R S\nr : R\nx : PowerSeries S\n\u22a2 (ofPowerSeries \u2124 S) (r \u2022 x) = r \u2022 (ofPowerSeries \u2124 S) x"}, {"line": "ext", "tactic_state": "case coeff.h\nR : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Semiring R\nS : Type u_4\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Module R S\nr : R\nx : PowerSeries S\nx\u271d : \u2124\n\u22a2 ((ofPowerSeries \u2124 S) (r \u2022 x)).coeff x\u271d = (r \u2022 (ofPowerSeries \u2124 S) x).coeff x\u271d"}, {"line": "simp [coeff_coe, coeff_smul, smul_ite]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_ne_zero {f : Polynomial F} (hf : f \u2260 0) : (\u2191f : F\u27e6X\u27e7) \u2260 0 := by\n  simp only [ne_eq]\n  simp only [Polynomial.coe_eq_zero_iff]\n  simp only [hf]\n  simp only [not_false_eq_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LaurentSeries.lean", "context": {"open": ["scoped PowerSeries", "HahnSeries Polynomial", "LaurentSeries", "scoped LaurentSeries"], "variables": ["{R : Type*}", "[Semiring R] {V : Type*} [AddCommGroup V] [Module R V]", "[Semiring R]", "{R' : Type*} [Semiring R] [Ring R'] (f g : R\u27e6X\u27e7) (f' g' : R'\u27e6X\u27e7)", "{F : Type u} [Field F] (p q : F[X]) (f g : RatFunc F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\ninst\u271d : Field F\nf : Polynomial F\nhf : f \u2260 0\n\u22a2 \u2191f \u2260 0"}, {"line": "simp only [ne_eq]", "tactic_state": "F : Type u\ninst\u271d : Field F\nf : Polynomial F\nhf : f \u2260 0\n\u22a2 \u00ac\u2191f = 0"}, {"line": "simp only [Polynomial.coe_eq_zero_iff]", "tactic_state": "F : Type u\ninst\u271d : Field F\nf : Polynomial F\nhf : f \u2260 0\n\u22a2 \u00acf = 0"}, {"line": "simp only [hf]", "tactic_state": "F : Type u\ninst\u271d : Field F\nf : Polynomial F\nhf : f \u2260 0\n\u22a2 \u00acFalse"}, {"line": "simp only [not_false_eq_true]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem single_one_eq_pow {R : Type*} [Semiring R] (n : \u2115) :\n    single (n : \u2124) (1 : R) = single (1 : \u2124) 1 ^ n := by\n  induction' n with n h_ind\n  \u00b7 simp\n  \u00b7 rw [\u2190 Int.ofNat_add_one_out, pow_succ', \u2190 h_ind, HahnSeries.single_mul_single, one_mul,\n      add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LaurentSeries.lean", "context": {"open": ["scoped PowerSeries", "HahnSeries Polynomial", "LaurentSeries", "scoped LaurentSeries"], "variables": ["{R : Type*}", "[Semiring R] {V : Type*} [AddCommGroup V] [Module R V]", "[Semiring R]", "{R' : Type*} [Semiring R] [Ring R'] (f g : R\u27e6X\u27e7) (f' g' : R'\u27e6X\u27e7)", "{F : Type u} [Field F] (p q : F[X]) (f g : RatFunc F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 (single \u2191n) 1 = (single 1) 1 ^ n"}, {"line": "induction' n with n h_ind", "tactic_state": "case zero\nR : Type u_4\ninst\u271d : Semiring R\n\u22a2 (single \u21910) 1 = (single 1) 1 ^ 0\n---\ncase succ\nR : Type u_4\ninst\u271d : Semiring R\nn : \u2115\nh_ind : (single \u2191n) 1 = (single 1) 1 ^ n\n\u22a2 (single \u2191(n + 1)) 1 = (single 1) 1 ^ (n + 1)"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nR : Type u_4\ninst\u271d : Semiring R\nn : \u2115\nh_ind : (single \u2191n) 1 = (single 1) 1 ^ n\n\u22a2 (single \u2191(n + 1)) 1 = (single 1) 1 ^ (n + 1)"}, {"line": "\u00b7 rw [\u2190 Int.ofNat_add_one_out, pow_succ', \u2190 h_ind, HahnSeries.single_mul_single, one_mul,\n      add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem single_inv (d : \u2124) {\u03b1 : F} (h\u03b1 : \u03b1 \u2260 0) :\n    single (-d) (\u03b1\u207b\u00b9 : F) = (single (d : \u2124) (\u03b1 : F))\u207b\u00b9 := by\n  apply eq_inv_of_mul_eq_one_right\n  simp [h\u03b1]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LaurentSeries.lean", "context": {"open": ["scoped PowerSeries", "HahnSeries Polynomial", "LaurentSeries", "scoped LaurentSeries"], "variables": ["{R : Type*}", "[Semiring R] {V : Type*} [AddCommGroup V] [Module R V]", "[Semiring R]", "{R' : Type*} [Semiring R] [Ring R'] (f g : R\u27e6X\u27e7) (f' g' : R'\u27e6X\u27e7)", "{F : Type u} [Field F] (p q : F[X]) (f g : RatFunc F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\ninst\u271d : Field F\nd : \u2124\n\u03b1 : F\nh\u03b1 : \u03b1 \u2260 0\n\u22a2 (single (-d)) \u03b1\u207b\u00b9 = ((single d) \u03b1)\u207b\u00b9"}, {"line": "apply eq_inv_of_mul_eq_one_right", "tactic_state": "case h\nF : Type u\ninst\u271d : Field F\nd : \u2124\n\u03b1 : F\nh\u03b1 : \u03b1 \u2260 0\n\u22a2 (single d) \u03b1 * (single (-d)) \u03b1\u207b\u00b9 = 1"}, {"line": "simp [h\u03b1]", "tactic_state": "case h\nF : Type u\ninst\u271d : Field F\nd : \u2124\n\u03b1 : F\nh\u03b1 : \u03b1 \u2260 0\n\u22a2 (single 0) (\u03b1 * \u03b1\u207b\u00b9) = 1"}]}
{"declaration": "theorem valuation_X_pow (s : \u2115) :\n    Valued.v (((X : K\u27e6X\u27e7) : K\u2e28X\u2e29) ^ s) = Multiplicative.ofAdd (-(s : \u2124)) := by\n  rw [map_pow]\n  rw [\u2190 one_mul (s : \u2124)]\n  rw [\u2190 neg_mul (1 : \u2124) s]\n  rw [Int.ofAdd_mul]\n  rw [WithZero.coe_zpow]\n  rw [ofAdd_neg]\n  rw [WithZero.coe_inv]\n  rw [zpow_natCast]\n  rw [valuation_def]\n  rw [\u2190 LaurentSeries.coe_algebraMap]\n  rw [valuation_of_algebraMap]\n  rw [intValuation_toFun]\n  rw [intValuation_X]\n  rw [ofAdd_neg]\n  rw [WithZero.coe_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LaurentSeries.lean", "context": {"open": ["scoped PowerSeries", "HahnSeries Polynomial", "LaurentSeries", "scoped LaurentSeries", "scoped Multiplicative", "RatFunc IsDedekindDomain.HeightOneSpectrum", "IsDedekindDomain.HeightOneSpectrum PowerSeries", "scoped LaurentSeries", "IsDedekindDomain.HeightOneSpectrum PowerSeries RatFunc"], "variables": ["{R : Type*}", "[Semiring R] {V : Type*} [AddCommGroup V] [Module R V]", "[Semiring R]", "{R' : Type*} [Semiring R] [Ring R'] (f g : R\u27e6X\u27e7) (f' g' : R'\u27e6X\u27e7)", "{F : Type u} [Field F] (p q : F[X]) (f g : RatFunc F)", "(K : Type*) [Field K]", "{K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_4\ninst\u271d : Field K\ns : \u2115\n\u22a2 Valued.v ((ofPowerSeries \u2124 K) PowerSeries.X ^ s) = \u2191(Multiplicative.ofAdd (-\u2191s))"}, {"line": "rw [map_pow]", "tactic_state": "K : Type u_4\ninst\u271d : Field K\ns : \u2115\n\u22a2 Valued.v ((ofPowerSeries \u2124 K) PowerSeries.X) ^ s = \u2191(Multiplicative.ofAdd (-\u2191s))"}, {"line": "rw [\u2190 one_mul (s : \u2124)]", "tactic_state": "K : Type u_4\ninst\u271d : Field K\ns : \u2115\n\u22a2 Valued.v ((ofPowerSeries \u2124 K) PowerSeries.X) ^ s = \u2191(Multiplicative.ofAdd (-(1 * \u2191s)))"}, {"line": "rw [\u2190 neg_mul (1 : \u2124) s]", "tactic_state": "K : Type u_4\ninst\u271d : Field K\ns : \u2115\n\u22a2 Valued.v ((ofPowerSeries \u2124 K) PowerSeries.X) ^ s = \u2191(Multiplicative.ofAdd (-1 * \u2191s))"}, {"line": "rw [Int.ofAdd_mul]", "tactic_state": "K : Type u_4\ninst\u271d : Field K\ns : \u2115\n\u22a2 Valued.v ((ofPowerSeries \u2124 K) PowerSeries.X) ^ s = \u2191(Multiplicative.ofAdd (-1) ^ \u2191s)"}, {"line": "rw [WithZero.coe_zpow]", "tactic_state": "K : Type u_4\ninst\u271d : Field K\ns : \u2115\n\u22a2 Valued.v ((ofPowerSeries \u2124 K) PowerSeries.X) ^ s = \u2191(Multiplicative.ofAdd (-1)) ^ \u2191s"}, {"line": "rw [ofAdd_neg]", "tactic_state": "K : Type u_4\ninst\u271d : Field K\ns : \u2115\n\u22a2 Valued.v ((ofPowerSeries \u2124 K) PowerSeries.X) ^ s = \u2191(Multiplicative.ofAdd 1)\u207b\u00b9 ^ \u2191s"}, {"line": "rw [WithZero.coe_inv]", "tactic_state": "K : Type u_4\ninst\u271d : Field K\ns : \u2115\n\u22a2 Valued.v ((ofPowerSeries \u2124 K) PowerSeries.X) ^ s = (\u2191(Multiplicative.ofAdd 1))\u207b\u00b9 ^ \u2191s"}, {"line": "rw [zpow_natCast]", "tactic_state": "K : Type u_4\ninst\u271d : Field K\ns : \u2115\n\u22a2 Valued.v ((ofPowerSeries \u2124 K) PowerSeries.X) ^ s = (\u2191(Multiplicative.ofAdd 1))\u207b\u00b9 ^ s"}, {"line": "rw [valuation_def]", "tactic_state": "K : Type u_4\ninst\u271d : Field K\ns : \u2115\n\u22a2 (valuation (LaurentSeries K) (PowerSeries.idealX K)) ((ofPowerSeries \u2124 K) PowerSeries.X) ^ s =\n    (\u2191(Multiplicative.ofAdd 1))\u207b\u00b9 ^ s"}, {"line": "rw [\u2190 LaurentSeries.coe_algebraMap]", "tactic_state": "K : Type u_4\ninst\u271d : Field K\ns : \u2115\n\u22a2 (valuation (LaurentSeries K) (PowerSeries.idealX K)) ((algebraMap (PowerSeries K) (LaurentSeries K)) PowerSeries.X) ^\n      s =\n    (\u2191(Multiplicative.ofAdd 1))\u207b\u00b9 ^ s"}, {"line": "rw [valuation_of_algebraMap]", "tactic_state": "K : Type u_4\ninst\u271d : Field K\ns : \u2115\n\u22a2 (PowerSeries.idealX K).intValuation PowerSeries.X ^ s = (\u2191(Multiplicative.ofAdd 1))\u207b\u00b9 ^ s"}, {"line": "rw [intValuation_toFun]", "tactic_state": "K : Type u_4\ninst\u271d : Field K\ns : \u2115\n\u22a2 (PowerSeries.idealX K).intValuationDef PowerSeries.X ^ s = (\u2191(Multiplicative.ofAdd 1))\u207b\u00b9 ^ s"}, {"line": "rw [intValuation_X]", "tactic_state": "K : Type u_4\ninst\u271d : Field K\ns : \u2115\n\u22a2 \u2191(Multiplicative.ofAdd (-1)) ^ s = (\u2191(Multiplicative.ofAdd 1))\u207b\u00b9 ^ s"}, {"line": "rw [ofAdd_neg]", "tactic_state": "K : Type u_4\ninst\u271d : Field K\ns : \u2115\n\u22a2 \u2191(Multiplicative.ofAdd 1)\u207b\u00b9 ^ s = (\u2191(Multiplicative.ofAdd 1))\u207b\u00b9 ^ s"}, {"line": "rw [WithZero.coe_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_X_compare :\n    (ratfuncAdicComplRingEquiv K) ((RatFunc.X : RatFunc K) : RatFuncAdicCompl K) =\n      ((PowerSeries.X : K\u27e6X\u27e7) : K\u2e28X\u2e29) := by\n  rw [PowerSeries.coe_X]\n  rw [\u2190 RatFunc.coe_X]\n  rw [\u2190 LaurentSeries_coe]\n  rw [\u2190 compare_coe]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LaurentSeries.lean", "context": {"open": ["scoped PowerSeries", "HahnSeries Polynomial", "LaurentSeries", "scoped LaurentSeries", "scoped Multiplicative", "RatFunc IsDedekindDomain.HeightOneSpectrum", "IsDedekindDomain.HeightOneSpectrum PowerSeries", "scoped LaurentSeries", "IsDedekindDomain.HeightOneSpectrum PowerSeries RatFunc", "Filter Multiplicative", "scoped Topology", "scoped Multiplicative", "HahnSeries LaurentSeries PowerSeries IsDedekindDomain.HeightOneSpectrum WithZero", "RatFunc AbstractCompletion IsDedekindDomain.HeightOneSpectrum"], "variables": ["{R : Type*}", "[Semiring R] {V : Type*} [AddCommGroup V] [Module R V]", "[Semiring R]", "{R' : Type*} [Semiring R] [Ring R'] (f g : R\u27e6X\u27e7) (f' g' : R'\u27e6X\u27e7)", "{F : Type u} [Field F] (p q : F[X]) (f g : RatFunc F)", "(K : Type*) [Field K]", "{K}", "{K : Type*} [Field K]", "(K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_5\ninst\u271d : Field K\n\u22a2 (ratfuncAdicComplRingEquiv K) \u2191RatFunc.X = (ofPowerSeries \u2124 K) PowerSeries.X"}, {"line": "rw [PowerSeries.coe_X]", "tactic_state": "K : Type u_5\ninst\u271d : Field K\n\u22a2 (ratfuncAdicComplRingEquiv K) \u2191RatFunc.X = (single 1) 1"}, {"line": "rw [\u2190 RatFunc.coe_X]", "tactic_state": "K : Type u_5\ninst\u271d : Field K\n\u22a2 (ratfuncAdicComplRingEquiv K) \u2191RatFunc.X = \u2191RatFunc.X"}, {"line": "rw [\u2190 LaurentSeries_coe]", "tactic_state": "K : Type u_5\ninst\u271d : Field K\n\u22a2 (ratfuncAdicComplRingEquiv K) \u2191RatFunc.X = (LaurentSeriesPkg K).coe RatFunc.X"}, {"line": "rw [\u2190 compare_coe]", "tactic_state": "K : Type u_5\ninst\u271d : Field K\n\u22a2 (ratfuncAdicComplRingEquiv K) \u2191RatFunc.X =\n    AbstractCompletion.compare ?pkg (LaurentSeriesPkg K) (AbstractCompletion.coe ?pkg RatFunc.X)\n---\ncase pkg\nK : Type u_5\ninst\u271d : Field K\n\u22a2 AbstractCompletion (RatFunc K)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem algebraMap_apply (a : K) : algebraMap K K\u2e28X\u2e29 a = HahnSeries.C a := by\n  simp [RingHom.algebraMap_toAlgebra]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LaurentSeries.lean", "context": {"open": ["scoped PowerSeries", "HahnSeries Polynomial", "LaurentSeries", "scoped LaurentSeries", "scoped Multiplicative", "RatFunc IsDedekindDomain.HeightOneSpectrum", "IsDedekindDomain.HeightOneSpectrum PowerSeries", "scoped LaurentSeries", "IsDedekindDomain.HeightOneSpectrum PowerSeries RatFunc", "Filter Multiplicative", "scoped Topology", "scoped Multiplicative", "HahnSeries LaurentSeries PowerSeries IsDedekindDomain.HeightOneSpectrum WithZero", "RatFunc AbstractCompletion IsDedekindDomain.HeightOneSpectrum"], "variables": ["{R : Type*}", "[Semiring R] {V : Type*} [AddCommGroup V] [Module R V]", "[Semiring R]", "{R' : Type*} [Semiring R] [Ring R'] (f g : R\u27e6X\u27e7) (f' g' : R'\u27e6X\u27e7)", "{F : Type u} [Field F] (p q : F[X]) (f g : RatFunc F)", "(K : Type*) [Field K]", "{K}", "{K : Type*} [Field K]", "(K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_5\ninst\u271d : Field K\na : K\n\u22a2 (algebraMap K (LaurentSeries K)) a = HahnSeries.C a"}, {"line": "simp [RingHom.algebraMap_toAlgebra]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma LaurentSeriesRingEquiv_mem_valuationSubring (f : K\u27e6X\u27e7) :\n    LaurentSeriesRingEquiv K f \u2208 Valued.v.valuationSubring := by\n  simp only [Valuation.mem_valuationSubring_iff]\n  rw [LaurentSeriesRingEquiv_def]\n  rw [valuation_compare]\n  rw [val_le_one_iff_eq_coe]\n  use f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LaurentSeries.lean", "context": {"open": ["scoped PowerSeries", "HahnSeries Polynomial", "LaurentSeries", "scoped LaurentSeries", "scoped Multiplicative", "RatFunc IsDedekindDomain.HeightOneSpectrum", "IsDedekindDomain.HeightOneSpectrum PowerSeries", "scoped LaurentSeries", "IsDedekindDomain.HeightOneSpectrum PowerSeries RatFunc", "Filter Multiplicative", "scoped Topology", "scoped Multiplicative", "HahnSeries LaurentSeries PowerSeries IsDedekindDomain.HeightOneSpectrum WithZero", "RatFunc AbstractCompletion IsDedekindDomain.HeightOneSpectrum", "Filter WithZero", "scoped WithZeroTopology Topology Multiplicative"], "variables": ["{R : Type*}", "[Semiring R] {V : Type*} [AddCommGroup V] [Module R V]", "[Semiring R]", "{R' : Type*} [Semiring R] [Ring R'] (f g : R\u27e6X\u27e7) (f' g' : R'\u27e6X\u27e7)", "{F : Type u} [Field F] (p q : F[X]) (f g : RatFunc F)", "(K : Type*) [Field K]", "{K}", "{K : Type*} [Field K]", "(K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_5\ninst\u271d : Field K\nf : PowerSeries K\n\u22a2 (LaurentSeriesRingEquiv K) ((ofPowerSeries \u2124 K) f) \u2208 Valued.v.valuationSubring"}, {"line": "simp only [Valuation.mem_valuationSubring_iff]", "tactic_state": "K : Type u_5\ninst\u271d : Field K\nf : PowerSeries K\n\u22a2 Valued.v ((LaurentSeriesRingEquiv K) ((ofPowerSeries \u2124 K) f)) \u2264 1"}, {"line": "rw [LaurentSeriesRingEquiv_def]", "tactic_state": "K : Type u_5\ninst\u271d : Field K\nf : PowerSeries K\n\u22a2 Valued.v ((LaurentSeriesPkg K).compare ratfuncAdicComplPkg ((ofPowerSeries \u2124 K) f)) \u2264 1"}, {"line": "rw [valuation_compare]", "tactic_state": "K : Type u_5\ninst\u271d : Field K\nf : PowerSeries K\n\u22a2 Valued.v ((ofPowerSeries \u2124 K) f) \u2264 1"}, {"line": "rw [val_le_one_iff_eq_coe]", "tactic_state": "K : Type u_5\ninst\u271d : Field K\nf : PowerSeries K\n\u22a2 \u2203 F, (ofPowerSeries \u2124 K) F = (ofPowerSeries \u2124 K) f"}, {"line": "use f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iff_span_pair_isPrincipal :\n    IsBezout R \u2194 \u2200 x y : R, (Ideal.span {x, y} : Ideal R).IsPrincipal := by\n  classical\n    constructor\n    \u00b7 intro H x y; infer_instance\n    \u00b7 intro H\n      constructor\n      apply Submodule.fg_induction\n      \u00b7 exact fun _ => \u27e8\u27e8_, rfl\u27e9\u27e9\n      \u00b7 rintro _ _ \u27e8\u27e8x, rfl\u27e9\u27e9 \u27e8\u27e8y, rfl\u27e9\u27e9; rw [\u2190 Submodule.span_insert]; exact H _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Bezout.lean", "context": {"open": [], "variables": ["{R : Type u} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\n\u22a2 IsBezout R \u2194 \u2200 (x y : R), Submodule.IsPrincipal (Ideal.span {x, y})"}, {"line": "classical\n    constructor\n    \u00b7 intro H x y; infer_instance\n    \u00b7 intro H\n      constructor\n      apply Submodule.fg_induction\n      \u00b7 exact fun _ => \u27e8\u27e8_, rfl\u27e9\u27e9\n      \u00b7 rintro _ _ \u27e8\u27e8x, rfl\u27e9\u27e9 \u27e8\u27e8y, rfl\u27e9\u27e9; rw [\u2190 Submodule.span_insert]; exact H _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TFAE [IsBezout R] [IsDomain R] :\n    List.TFAE\n    [IsNoetherianRing R, IsPrincipalIdealRing R, UniqueFactorizationMonoid R, WfDvdMonoid R] := by\n  classical\n    tfae_have 1 \u2192 2\n    | _ => inferInstance\n    tfae_have 2 \u2192 3\n    | _ => inferInstance\n    tfae_have 3 \u2192 4\n    | _ => inferInstance\n    tfae_have 4 \u2192 1\n    | \u27e8h\u27e9 => by\n      rw [isNoetherianRing_iff]\n      rw [isNoetherian_iff_fg_wellFounded]\n      refine \u27e8RelEmbedding.wellFounded ?_ h\u27e9\n      have : \u2200 I : { J : Ideal R // J.FG }, \u2203 x : R, (I : Ideal R) = Ideal.span {x} :=\n        fun \u27e8I, hI\u27e9 => (IsBezout.isPrincipal_of_FG I hI).1\n      choose f hf using this\n      exact\n        { toFun := f\n          inj' := fun x y e => by ext1; rw [hf, hf, e]\n          map_rel_iff' := by\n            dsimp\n            intro a b\n            rw [\u2190 Ideal.span_singleton_lt_span_singleton]\n            rw [\u2190 hf]\n            rw [\u2190 hf]\n            rfl }\n    tfae_finish\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Bezout.lean", "context": {"open": [], "variables": ["{R : Type u} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsBezout R\ninst\u271d : IsDomain R\n\u22a2 [IsNoetherianRing R, IsPrincipalIdealRing R, UniqueFactorizationMonoid R, WfDvdMonoid R].TFAE"}, {"line": "classical\n    tfae_have 1 \u2192 2\n    | _ => inferInstance\n    tfae_have 2 \u2192 3\n    | _ => inferInstance\n    tfae_have 3 \u2192 4\n    | _ => inferInstance\n    tfae_have 4 \u2192 1\n    | \u27e8h\u27e9 => by\n      rw [isNoetherianRing_iff]\n      rw [isNoetherian_iff_fg_wellFounded]\n      refine \u27e8RelEmbedding.wellFounded ?_ h\u27e9\n      have : \u2200 I : { J : Ideal R // J.FG }, \u2203 x : R, (I : Ideal R) = Ideal.span {x} :=\n        fun \u27e8I, hI\u27e9 => (IsBezout.isPrincipal_of_FG I hI).1\n      choose f hf using this\n      exact\n        { toFun := f\n          inj' := fun x y e => by ext1; rw [hf, hf, e]\n          map_rel_iff' := by\n            dsimp\n            intro a b\n            rw [\u2190 Ideal.span_singleton_lt_span_singleton]\n            rw [\u2190 hf]\n            rw [\u2190 hf]\n            rfl }\n    tfae_finish", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pow_smul_le_pow_smul (i j k : \u2115) : I ^ (i + k) \u2022 F.N j \u2264 I ^ k \u2022 F.N (i + j) := by\n  rw [add_comm]\n  rw [pow_add]\n  rw [mul_smul]\n  exact smul_mono_right _ (F.pow_smul_le i j)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Filtration.lean", "context": {"open": ["Polynomial", "scoped Polynomial"], "variables": ["{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] (I : Ideal R)", "(F F' : I.Filtration M) {I}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nF : I.Filtration M\ni j k : \u2115\n\u22a2 I ^ (i + k) \u2022 F.N j \u2264 I ^ k \u2022 F.N (i + j)"}, {"line": "rw [add_comm]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nF : I.Filtration M\ni j k : \u2115\n\u22a2 I ^ (k + i) \u2022 F.N j \u2264 I ^ k \u2022 F.N (i + j)"}, {"line": "rw [pow_add]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nF : I.Filtration M\ni j k : \u2115\n\u22a2 (I ^ k * I ^ i) \u2022 F.N j \u2264 I ^ k \u2022 F.N (i + j)"}, {"line": "rw [mul_smul]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nF : I.Filtration M\ni j k : \u2115\n\u22a2 I ^ k \u2022 I ^ i \u2022 F.N j \u2264 I ^ k \u2022 F.N (i + j)"}, {"line": "exact smul_mono_right _ (F.pow_smul_le i j)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Ideal.stableFiltration_stable (I : Ideal R) (N : Submodule R M) :\n    (I.stableFiltration N).Stable := by\n  use 0\n  intro n _\n  dsimp\n  rw [add_comm]\n  rw [pow_add]\n  rw [mul_smul]\n  rw [pow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Filtration.lean", "context": {"open": ["Polynomial", "scoped Polynomial"], "variables": ["{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] (I : Ideal R)", "(F F' : I.Filtration M) {I}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nN : Submodule R M\n\u22a2 (I.stableFiltration N).Stable"}, {"line": "use 0", "tactic_state": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nN : Submodule R M\n\u22a2 \u2200 n \u2265 0, I \u2022 (I.stableFiltration N).N n = (I.stableFiltration N).N (n + 1)"}, {"line": "intro n _", "tactic_state": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nN : Submodule R M\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 I \u2022 (I.stableFiltration N).N n = (I.stableFiltration N).N (n + 1)"}, {"line": "dsimp", "tactic_state": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nN : Submodule R M\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 I \u2022 I ^ n \u2022 N = I ^ (n + 1) \u2022 N"}, {"line": "rw [add_comm]", "tactic_state": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nN : Submodule R M\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 I \u2022 I ^ n \u2022 N = I ^ (1 + n) \u2022 N"}, {"line": "rw [pow_add]", "tactic_state": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nN : Submodule R M\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 I \u2022 I ^ n \u2022 N = (I ^ 1 * I ^ n) \u2022 N"}, {"line": "rw [mul_smul]", "tactic_state": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nN : Submodule R M\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 I \u2022 I ^ n \u2022 N = I ^ 1 \u2022 I ^ n \u2022 N"}, {"line": "rw [pow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem stable_iff_exists_pow_smul_eq_of_ge :\n    F.Stable \u2194 \u2203 n\u2080, \u2200 n \u2265 n\u2080, F.N n = I ^ (n - n\u2080) \u2022 F.N n\u2080 := by\n  refine \u27e8Stable.exists_pow_smul_eq_of_ge, fun h => \u27e8h.choose, fun n hn => ?_\u27e9\u27e9\n  rw [h.choose_spec n hn]\n  rw [h.choose_spec (n + 1) (by omega)]\n  rw [smul_smul]\n  rw [\u2190 pow_succ']\n  rw [tsub_add_eq_add_tsub hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Filtration.lean", "context": {"open": ["Polynomial", "scoped Polynomial"], "variables": ["{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] (I : Ideal R)", "(F F' : I.Filtration M) {I}", "{F F'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nF : I.Filtration M\n\u22a2 F.Stable \u2194 \u2203 n\u2080, \u2200 n \u2265 n\u2080, F.N n = I ^ (n - n\u2080) \u2022 F.N n\u2080"}, {"line": "refine \u27e8Stable.exists_pow_smul_eq_of_ge, fun h => \u27e8h.choose, fun n hn => ?_\u27e9\u27e9", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nF : I.Filtration M\nh : \u2203 n\u2080, \u2200 n \u2265 n\u2080, F.N n = I ^ (n - n\u2080) \u2022 F.N n\u2080\nn : \u2115\nhn : n \u2265 h.choose\n\u22a2 I \u2022 F.N n = F.N (n + 1)"}, {"line": "rw [h.choose_spec n hn]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nF : I.Filtration M\nh : \u2203 n\u2080, \u2200 n \u2265 n\u2080, F.N n = I ^ (n - n\u2080) \u2022 F.N n\u2080\nn : \u2115\nhn : n \u2265 h.choose\n\u22a2 I \u2022 I ^ (n - h.choose) \u2022 F.N h.choose = F.N (n + 1)"}, {"line": "rw [h.choose_spec (n + 1) (by omega)]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nF : I.Filtration M\nh : \u2203 n\u2080, \u2200 n \u2265 n\u2080, F.N n = I ^ (n - n\u2080) \u2022 F.N n\u2080\nn : \u2115\nhn : n \u2265 h.choose\n\u22a2 I \u2022 I ^ (n - h.choose) \u2022 F.N h.choose = I ^ (n + 1 - h.choose) \u2022 F.N h.choose"}, {"line": "rw [smul_smul]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nF : I.Filtration M\nh : \u2203 n\u2080, \u2200 n \u2265 n\u2080, F.N n = I ^ (n - n\u2080) \u2022 F.N n\u2080\nn : \u2115\nhn : n \u2265 h.choose\n\u22a2 (I * I ^ (n - h.choose)) \u2022 F.N h.choose = I ^ (n + 1 - h.choose) \u2022 F.N h.choose"}, {"line": "rw [\u2190 pow_succ']", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nF : I.Filtration M\nh : \u2203 n\u2080, \u2200 n \u2265 n\u2080, F.N n = I ^ (n - n\u2080) \u2022 F.N n\u2080\nn : \u2115\nhn : n \u2265 h.choose\n\u22a2 I ^ (n - h.choose + 1) \u2022 F.N h.choose = I ^ (n + 1 - h.choose) \u2022 F.N h.choose"}, {"line": "rw [tsub_add_eq_add_tsub hn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_submodule : (F \u2293 F').submodule = F.submodule \u2293 F'.submodule := by\n  ext\n  exact forall_and\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Filtration.lean", "context": {"open": ["Polynomial", "scoped Polynomial", "PolynomialModule"], "variables": ["{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] (I : Ideal R)", "(F F' : I.Filtration M) {I}", "{F F'}", "(F F')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nF F' : I.Filtration M\n\u22a2 (F \u2293 F').submodule = F.submodule \u2293 F'.submodule"}, {"line": "ext", "tactic_state": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nF F' : I.Filtration M\nx\u271d : PolynomialModule R M\n\u22a2 x\u271d \u2208 (F \u2293 F').submodule \u2194 x\u271d \u2208 F.submodule \u2293 F'.submodule"}, {"line": "exact forall_and", "tactic_state": "No Goals!"}]}
{"declaration": "theorem kroneckerTMulAlgEquiv_symm_stdBasisMatrix_tmul\n    (ia : l) (ja : m) (ib : n) (jb : p) (a : M) (b : N) :\n    (kroneckerTMulLinearEquiv l m n p R M N).symm (stdBasisMatrix (ia, ib) (ja, jb) (a \u2297\u209c b)) =\n      stdBasisMatrix ia ja a \u2297\u209c stdBasisMatrix ib jb b := by\n  rw [LinearEquiv.symm_apply_eq]\n  rw [kroneckerTMulLinearEquiv_tmul]\n  rw [stdBasisMatrix_kroneckerTMul_stdBasisMatrix]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MatrixAlgebra.lean", "context": {"open": ["TensorProduct Algebra.TensorProduct Matrix", "Kronecker"], "variables": ["{l m n p : Type*} {R A B M N : Type*}", "[CommSemiring R] [AddCommMonoid M] [AddCommMonoid N] [Semiring A] [Semiring B]", "[Module R M] [Module R N] [Algebra R A] [Algebra R B]", "[Fintype l] [Fintype m] [Fintype n] [Fintype p]", "[DecidableEq l] [DecidableEq m] [DecidableEq n] [DecidableEq p]", "(l m n p R M N)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\np : Type u_4\nR : Type u_5\nM : Type u_8\nN : Type u_9\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid N\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R N\ninst\u271d\u2077 : Fintype l\ninst\u271d\u2076 : Fintype m\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : Fintype p\ninst\u271d\u00b3 : DecidableEq l\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : DecidableEq p\nia : l\nja : m\nib : n\njb : p\na : M\nb : N\n\u22a2 (kroneckerTMulLinearEquiv l m n p R M N).symm (stdBasisMatrix (ia, ib) (ja, jb) (a \u2297\u209c[R] b)) =\n    stdBasisMatrix ia ja a \u2297\u209c[R] stdBasisMatrix ib jb b"}, {"line": "rw [LinearEquiv.symm_apply_eq]", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\np : Type u_4\nR : Type u_5\nM : Type u_8\nN : Type u_9\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid N\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R N\ninst\u271d\u2077 : Fintype l\ninst\u271d\u2076 : Fintype m\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : Fintype p\ninst\u271d\u00b3 : DecidableEq l\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : DecidableEq p\nia : l\nja : m\nib : n\njb : p\na : M\nb : N\n\u22a2 stdBasisMatrix (ia, ib) (ja, jb) (a \u2297\u209c[R] b) =\n    (kroneckerTMulLinearEquiv l m n p R M N) (stdBasisMatrix ia ja a \u2297\u209c[R] stdBasisMatrix ib jb b)"}, {"line": "rw [kroneckerTMulLinearEquiv_tmul]", "tactic_state": "l : Type u_1\nm : Type u_2\nn : Type u_3\np : Type u_4\nR : Type u_5\nM : Type u_8\nN : Type u_9\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid N\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R N\ninst\u271d\u2077 : Fintype l\ninst\u271d\u2076 : Fintype m\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : Fintype p\ninst\u271d\u00b3 : DecidableEq l\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : DecidableEq p\nia : l\nja : m\nib : n\njb : p\na : M\nb : N\n\u22a2 stdBasisMatrix (ia, ib) (ja, jb) (a \u2297\u209c[R] b) =\n    kroneckerMap (fun x1 x2 => x1 \u2297\u209c[R] x2) (stdBasisMatrix ia ja a) (stdBasisMatrix ib jb b)"}, {"line": "rw [stdBasisMatrix_kroneckerTMul_stdBasisMatrix]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem kroneckerTMulLinearEquiv_one :\n    kroneckerTMulLinearEquiv m m n n R A B 1 = 1 := by simp [Algebra.TensorProduct.one_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MatrixAlgebra.lean", "context": {"open": ["TensorProduct Algebra.TensorProduct Matrix", "Kronecker"], "variables": ["{l m n p : Type*} {R A B M N : Type*}", "[CommSemiring R] [AddCommMonoid M] [AddCommMonoid N] [Semiring A] [Semiring B]", "[Module R M] [Module R N] [Algebra R A] [Algebra R B]", "[Fintype l] [Fintype m] [Fintype n] [Fintype p]", "[DecidableEq l] [DecidableEq m] [DecidableEq n] [DecidableEq p]", "(l m n p R M N)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_2\nn : Type u_3\nR : Type u_5\nA : Type u_6\nB : Type u_7\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : Semiring B\ninst\u271d\u2075 : Algebra R A\ninst\u271d\u2074 : Algebra R B\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq n\n\u22a2 (kroneckerTMulLinearEquiv m m n n R A B) 1 = 1"}, {"line": "simp [Algebra.TensorProduct.one_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem invFun_zero : invFun n R A 0 = 0 := by simp [invFun]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MatrixAlgebra.lean", "context": {"open": ["TensorProduct Algebra.TensorProduct Matrix", "Kronecker"], "variables": ["{l m n p : Type*} {R A B M N : Type*}", "[CommSemiring R] [AddCommMonoid M] [AddCommMonoid N] [Semiring A] [Semiring B]", "[Module R M] [Module R N] [Algebra R A] [Algebra R B]", "[Fintype l] [Fintype m] [Fintype n] [Fintype p]", "[DecidableEq l] [DecidableEq m] [DecidableEq n] [DecidableEq p]", "(l m n p R M N)", "[CommSemiring R]", "[Semiring A] [Semiring B] [Algebra R A] [Algebra R B]", "(n R A)", "[DecidableEq n] [Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_10\ninvFun : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [invFun]", "tactic_state": "x\u271d : Sort u_10\ninvFun : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem matrixEquivTensor_apply_stdBasisMatrix (i j : n) (x : A) :\n    matrixEquivTensor n R A (stdBasisMatrix i j x) = x \u2297\u209c stdBasisMatrix i j 1 := by\n  have t : \u2200 p : n \u00d7 n, i = p.1 \u2227 j = p.2 \u2194 p = (i, j) := by aesop\n  simp [ite_tmul, t, stdBasisMatrix]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MatrixAlgebra.lean", "context": {"open": ["TensorProduct Algebra.TensorProduct Matrix", "Kronecker", "MatrixEquivTensor"], "variables": ["{l m n p : Type*} {R A B M N : Type*}", "[CommSemiring R] [AddCommMonoid M] [AddCommMonoid N] [Semiring A] [Semiring B]", "[Module R M] [Module R N] [Algebra R A] [Algebra R B]", "[Fintype l] [Fintype m] [Fintype n] [Fintype p]", "[DecidableEq l] [DecidableEq m] [DecidableEq n] [DecidableEq p]", "(l m n p R M N)", "[CommSemiring R]", "[Semiring A] [Semiring B] [Algebra R A] [Algebra R B]", "(n R A)", "[DecidableEq n] [Fintype n]", "[Fintype n] [DecidableEq n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Type u_3\nR : Type u_5\nA : Type u_6\ninst\u271d\u00b9\u00b9 : CommSemiring R\ninst\u271d\u00b9\u2070 : Semiring A\ninst\u271d\u2079 : Algebra R A\ninst\u271d\u2078 : Fintype n\ninst\u271d\u2077 : DecidableEq n\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\ni j : n\nx : A\n\u22a2 (matrixEquivTensor n R A) (stdBasisMatrix i j x) = x \u2297\u209c[R] stdBasisMatrix i j 1"}, {"line": "have t : \u2200 p : n \u00d7 n, i = p.1 \u2227 j = p.2 \u2194 p = (i, j) := by aesop", "tactic_state": "n : Type u_3\nR : Type u_5\nA : Type u_6\ninst\u271d\u00b9\u00b9 : CommSemiring R\ninst\u271d\u00b9\u2070 : Semiring A\ninst\u271d\u2079 : Algebra R A\ninst\u271d\u2078 : Fintype n\ninst\u271d\u2077 : DecidableEq n\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\ni j : n\nx : A\nt : \u2200 (p : n \u00d7 n), i = p.1 \u2227 j = p.2 \u2194 p = (i, j)\n\u22a2 (matrixEquivTensor n R A) (stdBasisMatrix i j x) = x \u2297\u209c[R] stdBasisMatrix i j 1"}, {"line": "simp [ite_tmul, t, stdBasisMatrix]", "tactic_state": "n : Type u_3\nR : Type u_5\nA : Type u_6\ninst\u271d\u00b9\u00b9 : CommSemiring R\ninst\u271d\u00b9\u2070 : Semiring A\ninst\u271d\u2079 : Algebra R A\ninst\u271d\u2078 : Fintype n\ninst\u271d\u2077 : DecidableEq n\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\ni j : n\nx : A\nt : \u2200 (p : n \u00d7 n), i = p.1 \u2227 j = p.2 \u2194 p = (i, j)\n\u22a2 (\u2211 x_1, if i = x_1.1 \u2227 j = x_1.2 then x \u2297\u209c[R] of fun i' j' => if x_1.1 = i' \u2227 x_1.2 = j' then 1 else 0 else 0) =\n    x \u2297\u209c[R] of fun i' j' => if i = i' \u2227 j = j' then 1 else 0"}]}
{"declaration": "theorem Algebra.trace_complex_apply (z : \u2102) : Algebra.trace \u211d \u2102 z = 2 * z.re := by\n  rw [Algebra.trace_eq_matrix_trace Complex.basisOneI]\n  rw [Algebra.leftMulMatrix_complex]\n  rw [Matrix.trace_fin_two]\n  exact (two_mul _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Complex.lean", "context": {"open": ["Complex"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2102\n\u22a2 (trace \u211d \u2102) z = 2 * z.re"}, {"line": "rw [Algebra.trace_eq_matrix_trace Complex.basisOneI]", "tactic_state": "z : \u2102\n\u22a2 ((leftMulMatrix basisOneI) z).trace = 2 * z.re"}, {"line": "rw [Algebra.leftMulMatrix_complex]", "tactic_state": "z : \u2102\n\u22a2 !![z.re, -z.im; z.im, z.re].trace = 2 * z.re"}, {"line": "rw [Matrix.trace_fin_two]", "tactic_state": "z : \u2102\n\u22a2 !![z.re, -z.im; z.im, z.re] 0 0 + !![z.re, -z.im; z.im, z.re] 1 1 = 2 * z.re"}, {"line": "exact (two_mul _).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Algebra.norm_complex_apply (z : \u2102) : Algebra.norm \u211d z = Complex.normSq z := by\n  rw [Algebra.norm_eq_matrix_det Complex.basisOneI]\n  rw [Algebra.leftMulMatrix_complex]\n  rw [Matrix.det_fin_two]\n  rw [normSq_apply]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Complex.lean", "context": {"open": ["Complex"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2102\n\u22a2 (norm \u211d) z = normSq z"}, {"line": "rw [Algebra.norm_eq_matrix_det Complex.basisOneI]", "tactic_state": "z : \u2102\n\u22a2 ((leftMulMatrix basisOneI) z).det = normSq z"}, {"line": "rw [Algebra.leftMulMatrix_complex]", "tactic_state": "z : \u2102\n\u22a2 !![z.re, -z.im; z.im, z.re].det = normSq z"}, {"line": "rw [Matrix.det_fin_two]", "tactic_state": "z : \u2102\n\u22a2 !![z.re, -z.im; z.im, z.re] 0 0 * !![z.re, -z.im; z.im, z.re] 1 1 -\n      !![z.re, -z.im; z.im, z.re] 0 1 * !![z.re, -z.im; z.im, z.re] 1 0 =\n    normSq z"}, {"line": "rw [normSq_apply]", "tactic_state": "z : \u2102\n\u22a2 !![z.re, -z.im; z.im, z.re] 0 0 * !![z.re, -z.im; z.im, z.re] 1 1 -\n      !![z.re, -z.im; z.im, z.re] 0 1 * !![z.re, -z.im; z.im, z.re] 1 0 =\n    z.re * z.re + z.im * z.im"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma OrthogonalIdempotents.mul_eq [DecidableEq I] (he : OrthogonalIdempotents e) (i j) :\n    e i * e j = if i = j then e i else 0 := by\n  split\n  \u00b7 simp [*, (he.idem j).eq]\n  \u00b7 exact he.ortho \u2039_\u203a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Idempotents.lean", "context": {"open": [], "variables": ["{R S : Type*} [Semiring R] [Semiring S] (f : R \u2192+* S)", "{I : Type*} (e : I \u2192 R)", "{e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Semiring R\nI : Type u_3\ne : I \u2192 R\ninst\u271d : DecidableEq I\nhe : OrthogonalIdempotents e\ni j : I\n\u22a2 e i * e j = if i = j then e i else 0"}, {"line": "split", "tactic_state": "case isTrue\nR : Type u_1\ninst\u271d\u00b9 : Semiring R\nI : Type u_3\ne : I \u2192 R\ninst\u271d : DecidableEq I\nhe : OrthogonalIdempotents e\ni j : I\nh\u271d : i = j\n\u22a2 e i * e j = e i\n---\ncase isFalse\nR : Type u_1\ninst\u271d\u00b9 : Semiring R\nI : Type u_3\ne : I \u2192 R\ninst\u271d : DecidableEq I\nhe : OrthogonalIdempotents e\ni j : I\nh\u271d : \u00aci = j\n\u22a2 e i * e j = 0"}, {"line": "\u00b7 simp [*, (he.idem j).eq]", "tactic_state": "case isFalse\nR : Type u_1\ninst\u271d\u00b9 : Semiring R\nI : Type u_3\ne : I \u2192 R\ninst\u271d : DecidableEq I\nhe : OrthogonalIdempotents e\ni j : I\nh\u271d : \u00aci = j\n\u22a2 e i * e j = 0"}, {"line": "\u00b7 exact he.ortho \u2039_\u203a", "tactic_state": "No Goals!"}]}
{"declaration": "lemma CompleteOrthogonalIdempotents.pair_iff'\u209b {x y : R} :\n    CompleteOrthogonalIdempotents ![x, y] \u2194 x * y = 0 \u2227 y * x = 0 \u2227 x + y = 1 := by\n  simp [iff_ortho_complete, Pairwise, Fin.forall_fin_two, and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Idempotents.lean", "context": {"open": [], "variables": ["{R S : Type*} [Semiring R] [Semiring S] (f : R \u2192+* S)", "{I : Type*} (e : I \u2192 R)", "{e}", "[Fintype I]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nx y : R\n\u22a2 CompleteOrthogonalIdempotents ![x, y] \u2194 x * y = 0 \u2227 y * x = 0 \u2227 x + y = 1"}, {"line": "simp [iff_ortho_complete, Pairwise, Fin.forall_fin_two, and_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma CompleteOrthogonalIdempotents.unique_iff [Unique I] :\n    CompleteOrthogonalIdempotents e \u2194 e default = 1 := by\n  rw [completeOrthogonalIdempotents_iff]\n  rw [OrthogonalIdempotents.unique]\n  rw [Fintype.sum_unique]\n  rw [and_iff_right_iff_imp]\n  exact (\u00b7 \u25b8 IsIdempotentElem.one)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Idempotents.lean", "context": {"open": [], "variables": ["{R S : Type*} [Semiring R] [Semiring S] (f : R \u2192+* S)", "{I : Type*} (e : I \u2192 R)", "{e}", "[Fintype I]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Semiring R\nI : Type u_3\ne : I \u2192 R\ninst\u271d\u00b9 : Fintype I\ninst\u271d : Unique I\n\u22a2 CompleteOrthogonalIdempotents e \u2194 e default = 1"}, {"line": "rw [completeOrthogonalIdempotents_iff]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Semiring R\nI : Type u_3\ne : I \u2192 R\ninst\u271d\u00b9 : Fintype I\ninst\u271d : Unique I\n\u22a2 OrthogonalIdempotents e \u2227 \u2211 i, e i = 1 \u2194 e default = 1"}, {"line": "rw [OrthogonalIdempotents.unique]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Semiring R\nI : Type u_3\ne : I \u2192 R\ninst\u271d\u00b9 : Fintype I\ninst\u271d : Unique I\n\u22a2 IsIdempotentElem (e default) \u2227 \u2211 i, e i = 1 \u2194 e default = 1\n---\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nI : Type u_3\ne : I \u2192 R\ninst\u271d\u00b9 : Fintype I\ninst\u271d : Unique I\n\u22a2 Unique I"}, {"line": "rw [Fintype.sum_unique]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Semiring R\nI : Type u_3\ne : I \u2192 R\ninst\u271d\u00b9 : Fintype I\ninst\u271d : Unique I\n\u22a2 IsIdempotentElem (e default) \u2227 e default = 1 \u2194 e default = 1\n---\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nI : Type u_3\ne : I \u2192 R\ninst\u271d\u00b9 : Fintype I\ninst\u271d : Unique I\n\u22a2 Unique I\n---\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nI : Type u_3\ne : I \u2192 R\ninst\u271d\u00b9 : Fintype I\ninst\u271d : Unique I\n\u22a2 Unique I"}, {"line": "rw [and_iff_right_iff_imp]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Semiring R\nI : Type u_3\ne : I \u2192 R\ninst\u271d\u00b9 : Fintype I\ninst\u271d : Unique I\n\u22a2 e default = 1 \u2192 IsIdempotentElem (e default)\n---\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nI : Type u_3\ne : I \u2192 R\ninst\u271d\u00b9 : Fintype I\ninst\u271d : Unique I\n\u22a2 Unique I\n---\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nI : Type u_3\ne : I \u2192 R\ninst\u271d\u00b9 : Fintype I\ninst\u271d : Unique I\n\u22a2 Unique I"}, {"line": "exact (\u00b7 \u25b8 IsIdempotentElem.one)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Semiring R\nI : Type u_3\ne : I \u2192 R\ninst\u271d\u00b9 : Fintype I\ninst\u271d : Unique I\n\u22a2 Unique I\n---\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nI : Type u_3\ne : I \u2192 R\ninst\u271d\u00b9 : Fintype I\ninst\u271d : Unique I\n\u22a2 Unique I"}]}
{"declaration": "lemma CompleteOrthogonalIdempotents.map (he : CompleteOrthogonalIdempotents e) :\n    CompleteOrthogonalIdempotents (f \u2218 e) where\n  __ := he.toOrthogonalIdempotents.map f\n  complete := by simp only [Function.comp_apply, \u2190 map_sum, he.complete, map_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Idempotents.lean", "context": {"open": [], "variables": ["{R S : Type*} [Semiring R] [Semiring S] (f : R \u2192+* S)", "{I : Type*} (e : I \u2192 R)", "{e}", "[Fintype I]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\nI : Type u_3\ne : I \u2192 R\ninst\u271d : Fintype I\nhe : CompleteOrthogonalIdempotents e\n\u22a2 \u2211 i, (\u21d1f \u2218 e) i = 1"}, {"line": "simp only [Function.comp_apply, \u2190 map_sum, he.complete, map_one]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\nI : Type u_3\ne : I \u2192 R\ninst\u271d : Fintype I\nhe : CompleteOrthogonalIdempotents e\n\u22a2 f (\u2211 x, e x) = 1"}]}
{"declaration": "lemma CompleteOrthogonalIdempotents.map_injective_iff (hf : Function.Injective f) :\n    CompleteOrthogonalIdempotents (f \u2218 e) \u2194 CompleteOrthogonalIdempotents e := by\n  simp [completeOrthogonalIdempotents_iff, \u2190 hf.eq_iff, apply_ite,\n    OrthogonalIdempotents.map_injective_iff f hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Idempotents.lean", "context": {"open": [], "variables": ["{R S : Type*} [Semiring R] [Semiring S] (f : R \u2192+* S)", "{I : Type*} (e : I \u2192 R)", "{e}", "[Fintype I]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\nI : Type u_3\ne : I \u2192 R\ninst\u271d : Fintype I\nhf : Function.Injective \u21d1f\n\u22a2 CompleteOrthogonalIdempotents (\u21d1f \u2218 e) \u2194 CompleteOrthogonalIdempotents e"}, {"line": "simp [completeOrthogonalIdempotents_iff, \u2190 hf.eq_iff, apply_ite,\n    OrthogonalIdempotents.map_injective_iff f hf]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\nI : Type u_3\ne : I \u2192 R\ninst\u271d : Fintype I\nhf : Function.Injective \u21d1f\n\u22a2 OrthogonalIdempotents (\u21d1f \u2218 e) \u2227 \u2211 x, f (e x) = 1 \u2194 OrthogonalIdempotents e \u2227 \u2211 x, f (e x) = f 1"}]}
{"declaration": "lemma CompleteOrthogonalIdempotents.option (he : OrthogonalIdempotents e) :\n    CompleteOrthogonalIdempotents (Option.elim \u00b7 (1 - \u2211 i, e i) e) where\n  __ := he.option _ he.isIdempotentElem_sum.one_sub\n    (by simp [sub_mul, he.isIdempotentElem_sum.eq]) (by simp [mul_sub, he.isIdempotentElem_sum.eq])\n  complete := by\n    rw [Fintype.sum_option]\n    exact sub_add_cancel _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Idempotents.lean", "context": {"open": [], "variables": ["{R S : Type*} [Semiring R] [Semiring S] (f : R \u2192+* S)", "{I : Type*} (e : I \u2192 R)", "{e}", "[Fintype I]", "{R S : Type*} [Ring R] [Ring S] (f : R \u2192+* S)", "{I : Type*} {e : I \u2192 R}", "[Fintype I]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d\u00b9 : Ring R\nI : Type u_6\ne : I \u2192 R\ninst\u271d : Fintype I\nhe : OrthogonalIdempotents e\n\u22a2 \u2211 i, i.elim (1 - \u2211 i, e i) e = 1"}, {"line": "rw [Fintype.sum_option]", "tactic_state": "R : Type u_4\ninst\u271d\u00b9 : Ring R\nI : Type u_6\ne : I \u2192 R\ninst\u271d : Fintype I\nhe : OrthogonalIdempotents e\n\u22a2 none.elim (1 - \u2211 i, e i) e + \u2211 i, (some i).elim (1 - \u2211 i, e i) e = 1"}, {"line": "exact sub_add_cancel _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem emultiplicity_eq_top :\n    emultiplicity a b = \u22a4 \u2194 \u00acFiniteMultiplicity a b := by\n  simp [emultiplicity]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\n\u22a2 emultiplicity a b = \u22a4 \u2194 \u00acFiniteMultiplicity a b"}, {"line": "simp [emultiplicity]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem emultiplicity_lt_top {a b : \u03b1} : emultiplicity a b < \u22a4 \u2194 FiniteMultiplicity a b := by\n  simp [lt_top_iff_ne_top, emultiplicity_eq_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\n\u22a2 emultiplicity a b < \u22a4 \u2194 FiniteMultiplicity a b"}, {"line": "simp [lt_top_iff_ne_top, emultiplicity_eq_top]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finiteMultiplicity_iff_emultiplicity_ne_top :\n    FiniteMultiplicity a b \u2194 emultiplicity a b \u2260 \u22a4 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\n\u22a2 FiniteMultiplicity a b \u2194 emultiplicity a b \u2260 \u22a4"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finiteMultiplicity_of_emultiplicity_eq_natCast {n : \u2115} (h : emultiplicity a b = n) :\n    FiniteMultiplicity a b := by\n  by_contra! nh\n  rw [\u2190 emultiplicity_eq_top] at nh\n  rw [h] at nh\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nn : \u2115\nh : emultiplicity a b = \u2191n\n\u22a2 FiniteMultiplicity a b"}, {"line": "by_contra! nh", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nn : \u2115\nh : emultiplicity a b = \u2191n\nnh : \u00acFiniteMultiplicity a b\n\u22a2 False"}, {"line": "rw [\u2190 emultiplicity_eq_top] at nh", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nn : \u2115\nh : emultiplicity a b = \u2191n\nnh : emultiplicity a b = \u22a4\n\u22a2 False"}, {"line": "rw [h] at nh", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nn : \u2115\nh : emultiplicity a b = \u2191n\nnh : \u2191n = \u22a4\n\u22a2 False"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiplicity_eq_of_emultiplicity_eq_some {n : \u2115} (h : emultiplicity a b = n) :\n    multiplicity a b = n := by\n  simp [multiplicity, h]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nn : \u2115\nh : emultiplicity a b = \u2191n\n\u22a2 multiplicity a b = n"}, {"line": "simp [multiplicity, h]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nn : \u2115\nh : emultiplicity a b = \u2191n\n\u22a2 WithTop.untopD 1 \u2191n = n"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiplicity_eq_one_of_not_finiteMultiplicity (h : \u00acFiniteMultiplicity a b) :\n    multiplicity a b = 1 := by\n  simp [multiplicity, emultiplicity_eq_top.2 h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nh : \u00acFiniteMultiplicity a b\n\u22a2 multiplicity a b = 1"}, {"line": "simp [multiplicity, emultiplicity_eq_top.2 h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiplicity_le_emultiplicity :\n    multiplicity a b \u2264 emultiplicity a b := by\n  by_cases hf : FiniteMultiplicity a b\n  \u00b7 simp [hf.emultiplicity_eq_multiplicity]\n  \u00b7 simp [hf, emultiplicity_eq_top.2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\n\u22a2 \u2191(multiplicity a b) \u2264 emultiplicity a b"}, {"line": "by_cases hf : FiniteMultiplicity a b", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nhf : sorry\n\u22a2 \u2191(multiplicity a b) \u2264 emultiplicity a b\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nhf : \u00acsorry\n\u22a2 \u2191(multiplicity a b) \u2264 emultiplicity a b"}, {"line": "\u00b7 simp [hf.emultiplicity_eq_multiplicity]", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nhf : \u00acsorry\n\u22a2 \u2191(multiplicity a b) \u2264 emultiplicity a b"}, {"line": "\u00b7 simp [hf, emultiplicity_eq_top.2]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiplicity_eq_of_emultiplicity_eq {c d : \u03b2}\n    (h : emultiplicity a b = emultiplicity c d) : multiplicity a b = multiplicity c d := by\n  unfold multiplicity\n  rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na b : \u03b1\nc d : \u03b2\nh : emultiplicity a b = emultiplicity c d\n\u22a2 multiplicity a b = multiplicity c d"}, {"line": "unfold multiplicity", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na b : \u03b1\nc d : \u03b2\nh : emultiplicity a b = emultiplicity c d\n\u22a2 WithTop.untopD 1 (emultiplicity a b) = WithTop.untopD 1 (emultiplicity c d)"}, {"line": "rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiplicity_le_of_emultiplicity_le {n : \u2115} (h : emultiplicity a b \u2264 n) :\n    multiplicity a b \u2264 n := by\n  exact_mod_cast multiplicity_le_emultiplicity.trans h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nn : \u2115\nh : emultiplicity a b \u2264 \u2191n\n\u22a2 multiplicity a b \u2264 n"}, {"line": "exact_mod_cast multiplicity_le_emultiplicity.trans h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_emultiplicity_of_le_multiplicity {n : \u2115} (h : n \u2264 multiplicity a b) :\n    n \u2264 emultiplicity a b := by\n  exact_mod_cast (WithTop.coe_mono h).trans multiplicity_le_emultiplicity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nn : \u2115\nh : n \u2264 multiplicity a b\n\u22a2 \u2191n \u2264 emultiplicity a b"}, {"line": "exact_mod_cast (WithTop.coe_mono h).trans multiplicity_le_emultiplicity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiplicity_lt_of_emultiplicity_lt {n : \u2115} (h : emultiplicity a b < n) :\n    multiplicity a b < n := by\n  exact_mod_cast multiplicity_le_emultiplicity.trans_lt h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nn : \u2115\nh : emultiplicity a b < \u2191n\n\u22a2 multiplicity a b < n"}, {"line": "exact_mod_cast multiplicity_le_emultiplicity.trans_lt h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_emultiplicity_of_lt_multiplicity {n : \u2115} (h : n < multiplicity a b) :\n    n < emultiplicity a b := by\n  exact_mod_cast (WithTop.coe_strictMono h).trans_le multiplicity_le_emultiplicity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nn : \u2115\nh : n < multiplicity a b\n\u22a2 \u2191n < emultiplicity a b"}, {"line": "exact_mod_cast (WithTop.coe_strictMono h).trans_le multiplicity_le_emultiplicity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem emultiplicity_pos_iff :\n    0 < emultiplicity a b \u2194 0 < multiplicity a b := by\n  simp [pos_iff_ne_zero, pos_iff_ne_zero, emultiplicity_eq_zero_iff_multiplicity_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\n\u22a2 0 < emultiplicity a b \u2194 0 < multiplicity a b"}, {"line": "simp [pos_iff_ne_zero, pos_iff_ne_zero, emultiplicity_eq_zero_iff_multiplicity_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Int.natCast_emultiplicity (a b : \u2115) :\n    emultiplicity (a : \u2124) (b : \u2124) = emultiplicity a b := by\n  unfold emultiplicity FiniteMultiplicity\n  congr! <;> norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 emultiplicity \u2191a \u2191b = emultiplicity a b"}, {"line": "unfold emultiplicity FiniteMultiplicity", "tactic_state": "a b : \u2115\n\u22a2 (if h : \u2203 n, \u00ac\u2191a ^ (n + 1) \u2223 \u2191b then \u2191(Nat.find h) else \u22a4) = if h : \u2203 n, \u00aca ^ (n + 1) \u2223 b then \u2191(Nat.find h) else \u22a4"}, {"line": "congr! <;> norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiplicity_pos_of_dvd (hdiv : a \u2223 b) : 0 < multiplicity a b := by\n  refine Nat.pos_iff_ne_zero.2 fun h => ?_\n  simpa [hdiv] using FiniteMultiplicity.not_pow_dvd_of_multiplicity_lt\n    (by by_contra! nh; simp [nh] at h) (lt_one_iff.mpr h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nhdiv : a \u2223 b\n\u22a2 0 < multiplicity a b"}, {"line": "refine Nat.pos_iff_ne_zero.2 fun h => ?_", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nhdiv : a \u2223 b\nh : multiplicity a b = 0\n\u22a2 False"}, {"line": "simpa [hdiv] using FiniteMultiplicity.not_pow_dvd_of_multiplicity_lt\n    (by by_contra! nh; simp [nh] at h) (lt_one_iff.mpr h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem FiniteMultiplicity.pow_dvd_iff_le_multiplicity (hf : FiniteMultiplicity a b) {k : \u2115} :\n    a ^ k \u2223 b \u2194 k \u2264 multiplicity a b := by\n  exact_mod_cast hf.emultiplicity_eq_multiplicity \u25b8 pow_dvd_iff_le_emultiplicity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nhf : FiniteMultiplicity a b\nk : \u2115\n\u22a2 a ^ k \u2223 b \u2194 k \u2264 multiplicity a b"}, {"line": "exact_mod_cast hf.emultiplicity_eq_multiplicity \u25b8 pow_dvd_iff_le_emultiplicity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem emultiplicity_lt_iff_not_dvd {k : \u2115} :\n    emultiplicity a b < k \u2194 \u00aca ^ k \u2223 b := by rw [pow_dvd_iff_le_emultiplicity, not_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nk : \u2115\n\u22a2 emultiplicity a b < \u2191k \u2194 \u00aca ^ k \u2223 b"}, {"line": "rw [pow_dvd_iff_le_emultiplicity, not_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem FiniteMultiplicity.multiplicity_eq_iff (hf : FiniteMultiplicity a b) {n : \u2115} :\n    multiplicity a b = n \u2194 a ^ n \u2223 b \u2227 \u00aca ^ (n + 1) \u2223 b := by\n  simp [\u2190 emultiplicity_eq_coe, hf.emultiplicity_eq_multiplicity]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nhf : FiniteMultiplicity a b\nn : \u2115\n\u22a2 multiplicity a b = n \u2194 a ^ n \u2223 b \u2227 \u00aca ^ (n + 1) \u2223 b"}, {"line": "simp [\u2190 emultiplicity_eq_coe, hf.emultiplicity_eq_multiplicity]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nhf : FiniteMultiplicity a b\nn : \u2115\n\u22a2 multiplicity a b = n \u2194 emultiplicity a b = \u2191n"}]}
{"declaration": "theorem FiniteMultiplicity.not_of_one_left (b : \u03b1) : \u00ac FiniteMultiplicity 1 b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\nb : \u03b1\n\u22a2 \u00acFiniteMultiplicity 1 b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem emultiplicity_ne_zero :\n    emultiplicity a b \u2260 0 \u2194 a \u2223 b := by\n  simp [emultiplicity_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\n\u22a2 emultiplicity a b \u2260 0 \u2194 a \u2223 b"}, {"line": "simp [emultiplicity_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiplicity_ne_zero :\n    multiplicity a b \u2260 0 \u2194 a \u2223 b := by\n  simp [multiplicity_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\n\u22a2 multiplicity a b \u2260 0 \u2194 a \u2223 b"}, {"line": "simp [multiplicity_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem emultiplicity_le_emultiplicity_iff {c d : \u03b2} :\n    emultiplicity a b \u2264 emultiplicity c d \u2194 \u2200 n : \u2115, a ^ n \u2223 b \u2192 c ^ n \u2223 d := by classical\n  constructor\n  \u00b7 exact fun h n hab \u21a6 pow_dvd_of_le_emultiplicity (le_trans (le_emultiplicity_of_pow_dvd hab) h)\n  \u00b7 intro h\n    unfold emultiplicity\n    -- aesop? says\n    split\n    next h_1 =>\n      obtain \u27e8w, h_1\u27e9 := h_1\n      split\n      next h_2 =>\n        simp_all only [cast_le, le_find_iff, lt_find_iff, Decidable.not_not, le_refl,\n          not_true_eq_false, not_false_eq_true, implies_true]\n      next h_2 => simp_all only [not_exists, Decidable.not_not, le_top]\n    next h_1 =>\n      simp_all only [not_exists, Decidable.not_not, not_true_eq_false, top_le_iff,\n        dite_eq_right_iff, ENat.coe_ne_top, imp_false, not_false_eq_true, implies_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na b : \u03b1\nc d : \u03b2\n\u22a2 emultiplicity a b \u2264 emultiplicity c d \u2194 \u2200 (n : \u2115), a ^ n \u2223 b \u2192 c ^ n \u2223 d"}, {"line": "classical\n  constructor\n  \u00b7 exact fun h n hab \u21a6 pow_dvd_of_le_emultiplicity (le_trans (le_emultiplicity_of_pow_dvd hab) h)\n  \u00b7 intro h\n    unfold emultiplicity\n    split\n    next h_1 =>\n      obtain \u27e8w, h_1\u27e9 := h_1\n      split\n      next h_2 =>\n        simp_all only [cast_le, le_find_iff, lt_find_iff, Decidable.not_not, le_refl,\n          not_true_eq_false, not_false_eq_true, implies_true]\n      next h_2 => simp_all only [not_exists, Decidable.not_not, le_top]\n    next h_1 =>\n      simp_all only [not_exists, Decidable.not_not, not_true_eq_false, top_le_iff,\n        dite_eq_right_iff, ENat.coe_ne_top, imp_false, not_false_eq_true, implies_true]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem emultiplicity_map_eq {F : Type*} [EquivLike F \u03b1 \u03b2] [MulEquivClass F \u03b1 \u03b2]\n    (f : F) {a b : \u03b1} : emultiplicity (f a) (f b) = emultiplicity a b := by\n  simp [emultiplicity_eq_emultiplicity_iff, \u2190 map_pow, map_dvd_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\nF : Type u_1\ninst\u271d\u00b9 : EquivLike F \u03b1 \u03b2\ninst\u271d : MulEquivClass F \u03b1 \u03b2\nf : F\na b : \u03b1\n\u22a2 emultiplicity (f a) (f b) = emultiplicity a b"}, {"line": "simp [emultiplicity_eq_emultiplicity_iff, \u2190 map_pow, map_dvd_iff]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\nF : Type u_1\ninst\u271d\u00b9 : EquivLike F \u03b1 \u03b2\ninst\u271d : MulEquivClass F \u03b1 \u03b2\nf : F\na b : \u03b1\n\u22a2 \u2200 (n : \u2115), f a ^ n \u2223 f b \u2194 a ^ n \u2223 b"}]}
{"declaration": "theorem Nat.finiteMultiplicity_iff {a b : \u2115} : FiniteMultiplicity a b \u2194 a \u2260 1 \u2227 0 < b := by\n  rw [\u2190 not_iff_not]\n  rw [FiniteMultiplicity.not_iff_forall]\n  rw [not_and_or]\n  rw [not_ne_iff]\n  rw [not_lt]\n  rw [Nat.le_zero]\n  exact\n    \u27e8fun h =>\n      or_iff_not_imp_right.2 fun hb =>\n        have ha : a \u2260 0 := fun ha => hb <| zero_dvd_iff.mp <| by rw [ha] at h; exact h 1\n        Classical.by_contradiction fun ha1 : a \u2260 1 =>\n          have ha_gt_one : 1 < a :=\n            lt_of_not_ge fun _ =>\n              match a with\n              | 0 => ha rfl\n              | 1 => ha1 rfl\n              | b+2 => by omega\n          not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero hb) (h b)) (b.lt_pow_self ha_gt_one),\n      fun h => by cases h <;> simp [*]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 FiniteMultiplicity a b \u2194 a \u2260 1 \u2227 0 < b"}, {"line": "rw [\u2190 not_iff_not]", "tactic_state": "a b : \u2115\n\u22a2 \u00acFiniteMultiplicity a b \u2194 \u00ac(a \u2260 1 \u2227 0 < b)"}, {"line": "rw [FiniteMultiplicity.not_iff_forall]", "tactic_state": "a b : \u2115\n\u22a2 (\u2200 (n : \u2115), a ^ n \u2223 b) \u2194 \u00ac(a \u2260 1 \u2227 0 < b)"}, {"line": "rw [not_and_or]", "tactic_state": "a b : \u2115\n\u22a2 (\u2200 (n : \u2115), a ^ n \u2223 b) \u2194 \u00aca \u2260 1 \u2228 \u00ac0 < b"}, {"line": "rw [not_ne_iff]", "tactic_state": "a b : \u2115\n\u22a2 (\u2200 (n : \u2115), a ^ n \u2223 b) \u2194 a = 1 \u2228 \u00ac0 < b"}, {"line": "rw [not_lt]", "tactic_state": "a b : \u2115\n\u22a2 (\u2200 (n : \u2115), a ^ n \u2223 b) \u2194 a = 1 \u2228 b \u2264 0"}, {"line": "rw [Nat.le_zero]", "tactic_state": "a b : \u2115\n\u22a2 (\u2200 (n : \u2115), a ^ n \u2223 b) \u2194 a = 1 \u2228 b = 0"}, {"line": "exact\n    \u27e8fun h =>\n      or_iff_not_imp_right.2 fun hb =>\n        have ha : a \u2260 0 := fun ha => hb <| zero_dvd_iff.mp <| by rw [ha] at h; exact h 1\n        Classical.by_contradiction fun ha1 : a \u2260 1 =>\n          have ha_gt_one : 1 < a :=\n            lt_of_not_ge fun _ =>\n              match a with\n              | 0 => ha rfl\n              | 1 => ha1 rfl\n              | b+2 => by omega\n          not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero hb) (h b)) (b.lt_pow_self ha_gt_one),\n      fun h => by cases h <;> simp [*]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem emultiplicity_mk_eq_emultiplicity {a b : \u03b1} :\n    emultiplicity (Associates.mk a) (Associates.mk b) = emultiplicity a b := by\n  simp [emultiplicity_eq_emultiplicity_iff, \u2190 Associates.mk_pow, Associates.mk_dvd_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}", "[CommMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : CommMonoid \u03b1\na b : \u03b1\n\u22a2 sorry = emultiplicity a b"}, {"line": "simp [emultiplicity_eq_emultiplicity_iff, \u2190 Associates.mk_pow, Associates.mk_dvd_mk]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : CommMonoid \u03b1\na b : \u03b1\n\u22a2 sorry () = emultiplicity a b"}]}
{"declaration": "theorem FiniteMultiplicity.or_of_add {p a b : \u03b1} (hf : FiniteMultiplicity p (a + b)) :\n    FiniteMultiplicity p a \u2228 FiniteMultiplicity p b := by\n  by_contra! nh\n  obtain \u27e8c, hc\u27e9 := hf\n  simp_all [dvd_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}", "[CommMonoid \u03b1]", "[MonoidWithZero \u03b1]", "[Semiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : MonoidWithZero \u03b1\ninst\u271d : Semiring \u03b1\np a b : \u03b1\nhf : FiniteMultiplicity p (a + b)\n\u22a2 FiniteMultiplicity p a \u2228 FiniteMultiplicity p b"}, {"line": "by_contra! nh", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : MonoidWithZero \u03b1\ninst\u271d : Semiring \u03b1\np a b : \u03b1\nhf : FiniteMultiplicity p (a + b)\nnh : \u00acFiniteMultiplicity p a \u2227 \u00acFiniteMultiplicity p b\n\u22a2 False"}, {"line": "obtain \u27e8c, hc\u27e9 := hf", "tactic_state": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : MonoidWithZero \u03b1\ninst\u271d : Semiring \u03b1\np a b : \u03b1\nnh : \u00acFiniteMultiplicity p a \u2227 \u00acFiniteMultiplicity p b\nc : \u2115\nhc : \u00acp ^ (c + 1) \u2223 a + b\n\u22a2 False"}, {"line": "simp_all [dvd_add]", "tactic_state": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : MonoidWithZero \u03b1\ninst\u271d : Semiring \u03b1\np a b : \u03b1\nc : \u2115\nnh : (\u2200 (x : \u2115), p ^ (x + 1) \u2223 a) \u2227 \u2200 (x : \u2115), p ^ (x + 1) \u2223 b\nhc : \u00acp ^ (c + 1) \u2223 a + b\n\u22a2 False"}]}
{"declaration": "theorem Int.emultiplicity_natAbs (a : \u2115) (b : \u2124) :\n    emultiplicity a b.natAbs = emultiplicity (a : \u2124) b := by\n  rcases Int.natAbs_eq b with h | h <;> conv_rhs => rw [h]\n  \u00b7 rw [Int.natCast_emultiplicity]\n  \u00b7 rw [emultiplicity_neg, Int.natCast_emultiplicity]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}", "[CommMonoid \u03b1]", "[MonoidWithZero \u03b1]", "[Semiring \u03b1]", "[Ring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\nb : \u2124\n\u22a2 emultiplicity a b.natAbs = emultiplicity (\u2191a) b"}, {"line": "rcases Int.natAbs_eq b with h | h <;> conv_rhs => rw [h]", "tactic_state": "case inl\na : \u2115\nb : \u2124\nh : b = \u2191b.natAbs\n\u22a2 emultiplicity a b.natAbs = emultiplicity \u2191a \u2191b.natAbs\n---\ncase inr\na : \u2115\nb : \u2124\nh : b = -\u2191b.natAbs\n\u22a2 emultiplicity a b.natAbs = emultiplicity (\u2191a) (-\u2191b.natAbs)"}, {"line": "\u00b7 rw [Int.natCast_emultiplicity]", "tactic_state": "case inr\na : \u2115\nb : \u2124\nh : b = -\u2191b.natAbs\n\u22a2 emultiplicity a b.natAbs = emultiplicity (\u2191a) (-\u2191b.natAbs)"}, {"line": "\u00b7 rw [emultiplicity_neg, Int.natCast_emultiplicity]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finset.emultiplicity_prod {\u03b2 : Type*} {p : \u03b1} (hp : Prime p) (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) :\n    emultiplicity p (\u220f x \u2208 s, f x) = \u2211 x \u2208 s, emultiplicity p (f x) := by classical\n    induction' s using Finset.induction with a s has ih h\n    \u00b7 simp only [Finset.sum_empty, Finset.prod_empty]\n      exact emultiplicity_of_one_right hp.not_unit\n    \u00b7 simpa [has, \u2190 ih] using emultiplicity_mul hp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}", "[CommMonoid \u03b1]", "[MonoidWithZero \u03b1]", "[Semiring \u03b1]", "[Ring \u03b1]", "[CancelCommMonoidWithZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Monoid \u03b1\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : MonoidWithZero \u03b1\ninst\u271d\u00b2 : Semiring \u03b1\ninst\u271d\u00b9 : Ring \u03b1\ninst\u271d : CancelCommMonoidWithZero \u03b1\n\u03b2 : Type u_1\np : \u03b1\nhp : _root_.Prime p\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 emultiplicity p (\u220f x \u2208 s, f x) = \u2211 x \u2208 s, emultiplicity p (f x)"}, {"line": "classical\n    induction' s using Finset.induction with a s has ih h\n    \u00b7 simp only [Finset.sum_empty, Finset.prod_empty]\n      exact emultiplicity_of_one_right hp.not_unit\n    \u00b7 simpa [has, \u2190 ih] using emultiplicity_mul hp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem emultiplicity_pow {p a : \u03b1} (hp : Prime p) {k : \u2115} :\n    emultiplicity p (a ^ k) = k * emultiplicity p a := by\n  induction' k with k hk\n  \u00b7 simp [emultiplicity_of_one_right hp.not_unit]\n  \u00b7 simp [pow_succ, emultiplicity_mul hp, hk, add_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}", "[CommMonoid \u03b1]", "[MonoidWithZero \u03b1]", "[Semiring \u03b1]", "[Ring \u03b1]", "[CancelCommMonoidWithZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : Monoid \u03b1\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : MonoidWithZero \u03b1\ninst\u271d\u00b2 : Semiring \u03b1\ninst\u271d\u00b9 : Ring \u03b1\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a : \u03b1\nhp : _root_.Prime p\nk : \u2115\n\u22a2 emultiplicity p (a ^ k) = \u2191k * emultiplicity p a"}, {"line": "induction' k with k hk", "tactic_state": "case zero\n\u03b1 : Type u_1\ninst\u271d\u2075 : Monoid \u03b1\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : MonoidWithZero \u03b1\ninst\u271d\u00b2 : Semiring \u03b1\ninst\u271d\u00b9 : Ring \u03b1\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a : \u03b1\nhp : _root_.Prime p\n\u22a2 emultiplicity p (a ^ 0) = \u21910 * emultiplicity p a\n---\ncase succ\n\u03b1 : Type u_1\ninst\u271d\u2075 : Monoid \u03b1\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : MonoidWithZero \u03b1\ninst\u271d\u00b2 : Semiring \u03b1\ninst\u271d\u00b9 : Ring \u03b1\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a : \u03b1\nhp : _root_.Prime p\nk : \u2115\nhk : emultiplicity p (a ^ k) = \u2191k * emultiplicity p a\n\u22a2 emultiplicity p (a ^ (k + 1)) = \u2191(k + 1) * emultiplicity p a"}, {"line": "\u00b7 simp [emultiplicity_of_one_right hp.not_unit]", "tactic_state": "case succ\n\u03b1 : Type u_1\ninst\u271d\u2075 : Monoid \u03b1\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : MonoidWithZero \u03b1\ninst\u271d\u00b2 : Semiring \u03b1\ninst\u271d\u00b9 : Ring \u03b1\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a : \u03b1\nhp : _root_.Prime p\nk : \u2115\nhk : emultiplicity p (a ^ k) = \u2191k * emultiplicity p a\n\u22a2 emultiplicity p (a ^ (k + 1)) = \u2191(k + 1) * emultiplicity p a"}, {"line": "\u00b7 simp [pow_succ, emultiplicity_mul hp, hk, add_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem FiniteMultiplicity.multiplicity_pow {p a : \u03b1} (hp : Prime p)\n    (ha : FiniteMultiplicity p a) {k : \u2115} : multiplicity p (a ^ k) = k * multiplicity p a := by\n  exact_mod_cast (ha.pow hp).emultiplicity_eq_multiplicity \u25b8\n    ha.emultiplicity_eq_multiplicity \u25b8 emultiplicity_pow hp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}", "[CommMonoid \u03b1]", "[MonoidWithZero \u03b1]", "[Semiring \u03b1]", "[Ring \u03b1]", "[CancelCommMonoidWithZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : Monoid \u03b1\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : MonoidWithZero \u03b1\ninst\u271d\u00b2 : Semiring \u03b1\ninst\u271d\u00b9 : Ring \u03b1\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a : \u03b1\nhp : _root_.Prime p\nha : FiniteMultiplicity p a\nk : \u2115\n\u22a2 multiplicity p (a ^ k) = k * multiplicity p a"}, {"line": "exact_mod_cast (ha.pow hp).emultiplicity_eq_multiplicity \u25b8\n    ha.emultiplicity_eq_multiplicity \u25b8 emultiplicity_pow hp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiplicity_eq_zero_of_coprime {p a b : \u2115} (hp : p \u2260 1)\n    (hle : multiplicity p a \u2264 multiplicity p b) (hab : Nat.Coprime a b) : multiplicity p a = 0 := by\n  apply Nat.eq_zero_of_not_pos\n  intro nh\n  have da : p \u2223 a := by simpa [multiplicity_eq_zero] using nh.ne.symm\n  have db : p \u2223 b := by simpa [multiplicity_eq_zero] using (nh.trans_le hle).ne.symm\n  have := Nat.dvd_gcd da db\n  rw [Coprime.gcd_eq_one hab] at this\n  rw [Nat.dvd_one] at this\n  exact hp this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}", "[CommMonoid \u03b1]", "[MonoidWithZero \u03b1]", "[Semiring \u03b1]", "[Ring \u03b1]", "[CancelCommMonoidWithZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p a b : \u2115\nhp : p \u2260 1\nhle : multiplicity p a \u2264 multiplicity p b\nhab : a.Coprime b\n\u22a2 multiplicity p a = 0"}, {"line": "apply Nat.eq_zero_of_not_pos", "tactic_state": "case h\np a b : \u2115\nhp : p \u2260 1\nhle : multiplicity p a \u2264 multiplicity p b\nhab : a.Coprime b\n\u22a2 \u00ac0 < multiplicity p a"}, {"line": "intro nh", "tactic_state": "case h\np a b : \u2115\nhp : p \u2260 1\nhle : multiplicity p a \u2264 multiplicity p b\nhab : a.Coprime b\nnh : 0 < multiplicity p a\n\u22a2 False"}, {"line": "have da : p \u2223 a := sorry", "tactic_state": "case h\np a b : \u2115\nhp : p \u2260 1\nhle : multiplicity p a \u2264 multiplicity p b\nhab : a.Coprime b\nnh : 0 < multiplicity p a\nda : p \u2223 a\n\u22a2 False"}, {"line": "have db : p \u2223 b := sorry", "tactic_state": "case h\np a b : \u2115\nhp : p \u2260 1\nhle : multiplicity p a \u2264 multiplicity p b\nhab : a.Coprime b\nnh : 0 < multiplicity p a\nda : p \u2223 a\ndb : p \u2223 b\n\u22a2 False"}, {"line": "have := Nat.dvd_gcd da db", "tactic_state": "case h\np a b : \u2115\nhp : p \u2260 1\nhle : multiplicity p a \u2264 multiplicity p b\nhab : a.Coprime b\nnh : 0 < multiplicity p a\nda : p \u2223 a\ndb : p \u2223 b\nthis : p \u2223 a.gcd b\n\u22a2 False"}, {"line": "rw [Coprime.gcd_eq_one hab] at this", "tactic_state": "case h\np a b : \u2115\nhp : p \u2260 1\nhle : multiplicity p a \u2264 multiplicity p b\nhab : a.Coprime b\nnh : 0 < multiplicity p a\nda : p \u2223 a\ndb : p \u2223 b\nthis : p \u2223 1\n\u22a2 False"}, {"line": "rw [Nat.dvd_one] at this", "tactic_state": "case h\np a b : \u2115\nhp : p \u2260 1\nhle : multiplicity p a \u2264 multiplicity p b\nhab : a.Coprime b\nnh : 0 < multiplicity p a\nda : p \u2223 a\ndb : p \u2223 b\nthis : p = 1\n\u22a2 False"}, {"line": "exact hp this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Int.finiteMultiplicity_iff_finiteMultiplicity_natAbs {a b : \u2124} :\n    FiniteMultiplicity a b \u2194 FiniteMultiplicity a.natAbs b.natAbs := by\n  simp only [FiniteMultiplicity.def]\n  simp only [\u2190 Int.natAbs_dvd_natAbs]\n  simp only [Int.natAbs_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}", "[CommMonoid \u03b1]", "[MonoidWithZero \u03b1]", "[Semiring \u03b1]", "[Ring \u03b1]", "[CancelCommMonoidWithZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 FiniteMultiplicity a b \u2194 FiniteMultiplicity a.natAbs b.natAbs"}, {"line": "simp only [FiniteMultiplicity.def]", "tactic_state": "a b : \u2124\n\u22a2 (\u2203 n, \u00aca ^ (n + 1) \u2223 b) \u2194 \u2203 n, \u00aca.natAbs ^ (n + 1) \u2223 b.natAbs"}, {"line": "simp only [\u2190 Int.natAbs_dvd_natAbs]", "tactic_state": "a b : \u2124\n\u22a2 (\u2203 n, \u00ac(a ^ (n + 1)).natAbs \u2223 b.natAbs) \u2194 \u2203 n, \u00aca.natAbs ^ (n + 1) \u2223 b.natAbs"}, {"line": "simp only [Int.natAbs_pow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Int.finiteMultiplicity_iff {a b : \u2124} : FiniteMultiplicity a b \u2194 a.natAbs \u2260 1 \u2227 b \u2260 0 := by\n  rw [finiteMultiplicity_iff_finiteMultiplicity_natAbs]\n  rw [Nat.finiteMultiplicity_iff]\n  rw [pos_iff_ne_zero]\n  rw [Int.natAbs_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Multiplicity.lean", "context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}", "[CommMonoid \u03b1]", "[MonoidWithZero \u03b1]", "[Semiring \u03b1]", "[Ring \u03b1]", "[CancelCommMonoidWithZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 FiniteMultiplicity a b \u2194 a.natAbs \u2260 1 \u2227 b \u2260 0"}, {"line": "rw [finiteMultiplicity_iff_finiteMultiplicity_natAbs]", "tactic_state": "a b : \u2124\n\u22a2 FiniteMultiplicity a.natAbs b.natAbs \u2194 a.natAbs \u2260 1 \u2227 b \u2260 0"}, {"line": "rw [Nat.finiteMultiplicity_iff]", "tactic_state": "a b : \u2124\n\u22a2 a.natAbs \u2260 1 \u2227 0 < b.natAbs \u2194 a.natAbs \u2260 1 \u2227 b \u2260 0"}, {"line": "rw [pos_iff_ne_zero]", "tactic_state": "a b : \u2124\n\u22a2 a.natAbs \u2260 1 \u2227 b.natAbs \u2260 0 \u2194 a.natAbs \u2260 1 \u2227 b \u2260 0"}, {"line": "rw [Int.natAbs_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isNilpotent_iff_isNilpotent_fst {x : TrivSqZeroExt R M} :\n    IsNilpotent x \u2194 IsNilpotent x.fst := by\n  constructor <;> rintro \u27e8n, hn\u27e9\n  \u00b7 refine \u27e8n, ?_\u27e9\n    rw [\u2190 fst_pow]\n    rw [hn]\n    rw [fst_zero]\n  \u00b7 refine \u27e8n * 2, ?_\u27e9\n    rw [pow_mul]\n    ext\n    \u00b7 rw [fst_pow, fst_pow, hn, zero_pow two_ne_zero, fst_zero]\n    \u00b7 rw [pow_two, snd_mul, fst_pow, hn, MulOpposite.op_zero, zero_smul, zero_smul, zero_add,\n        snd_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/DualNumber.lean", "context": {"open": [], "variables": ["{R M : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M] [Module R\u1d50\u1d52\u1d56 M] [SMulCommClass R R\u1d50\u1d52\u1d56 M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R\u1d50\u1d52\u1d56 M\ninst\u271d : SMulCommClass R R\u1d50\u1d52\u1d56 M\nx : TrivSqZeroExt R M\n\u22a2 IsNilpotent x \u2194 IsNilpotent x.fst"}, {"line": "constructor <;> rintro \u27e8n, hn\u27e9", "tactic_state": "case mp.intro\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R\u1d50\u1d52\u1d56 M\ninst\u271d : SMulCommClass R R\u1d50\u1d52\u1d56 M\nx : TrivSqZeroExt R M\nn : \u2115\nhn : x ^ n = 0\n\u22a2 IsNilpotent x.fst\n---\ncase mpr.intro\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R\u1d50\u1d52\u1d56 M\ninst\u271d : SMulCommClass R R\u1d50\u1d52\u1d56 M\nx : TrivSqZeroExt R M\nn : \u2115\nhn : x.fst ^ n = 0\n\u22a2 IsNilpotent x"}, {"line": "\u00b7 refine \u27e8n, ?_\u27e9\n    rw [\u2190 fst_pow]\n    rw [hn]\n    rw [fst_zero]", "tactic_state": "case mpr.intro\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R\u1d50\u1d52\u1d56 M\ninst\u271d : SMulCommClass R R\u1d50\u1d52\u1d56 M\nx : TrivSqZeroExt R M\nn : \u2115\nhn : x.fst ^ n = 0\n\u22a2 IsNilpotent x"}, {"line": "\u00b7 refine \u27e8n * 2, ?_\u27e9\n    rw [pow_mul]\n    ext\n    \u00b7 rw [fst_pow, fst_pow, hn, zero_pow two_ne_zero, fst_zero]\n    \u00b7 rw [pow_two, snd_mul, fst_pow, hn, MulOpposite.op_zero, zero_smul, zero_smul, zero_add,\n        snd_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isNilpotent_inr (x : M) : IsNilpotent (.inr x : TrivSqZeroExt R M) := by\n  refine \u27e82, by simp [pow_two]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/DualNumber.lean", "context": {"open": [], "variables": ["{R M : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M] [Module R\u1d50\u1d52\u1d56 M] [SMulCommClass R R\u1d50\u1d52\u1d56 M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R\u1d50\u1d52\u1d56 M\ninst\u271d : SMulCommClass R R\u1d50\u1d52\u1d56 M\nx : M\n\u22a2 IsNilpotent (TrivSqZeroExt.inr x)"}, {"line": "refine \u27e82, by simp [pow_two]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma natCard_units_lt [Finite M\u2080] : Nat.card M\u2080\u02e3 < Nat.card M\u2080 := by\n  have : Fintype M\u2080 := Fintype.ofFinite M\u2080\n  simpa only [Fintype.card_eq_nat_card] using card_units_lt M\u2080\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Fintype.lean", "context": {"open": ["Finset ZMod", "scoped Classical in"], "variables": ["{R : Type*} [Ring R] [Fintype R] [DecidableEq R]", "(M\u2080 : Type*) [MonoidWithZero M\u2080] [Nontrivial M\u2080]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M\u2080 : Type u_1\ninst\u271d\u00b2 : MonoidWithZero M\u2080\ninst\u271d\u00b9 : Nontrivial M\u2080\ninst\u271d : Finite M\u2080\n\u22a2 Nat.card M\u2080\u02e3 < Nat.card M\u2080"}, {"line": "have : Fintype M\u2080 := Fintype.ofFinite M\u2080", "tactic_state": "M\u2080 : Type u_1\ninst\u271d\u00b2 : MonoidWithZero M\u2080\ninst\u271d\u00b9 : Nontrivial M\u2080\ninst\u271d : Finite M\u2080\nthis : Fintype M\u2080\n\u22a2 Nat.card M\u2080\u02e3 < Nat.card M\u2080"}, {"line": "simpa only [Fintype.card_eq_nat_card] using card_units_lt M\u2080", "tactic_state": "No Goals!"}]}
{"declaration": "lemma finitePresentation_algebraMap [Algebra A B] :\n    (algebraMap A B).FinitePresentation \u2194 Algebra.FinitePresentation A B := by\n  delta RingHom.FinitePresentation\n  congr!\n  exact Algebra.algebra_ext _ _ fun _ \u21a6 rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/FinitePresentation.lean", "context": {"open": ["Function (Surjective)", "Polynomial", "MvPolynomial"], "variables": ["(R : Type w\u2081) (A : Type w\u2082) (B : Type w\u2083)", "[CommRing R] [CommRing A] [Algebra R A] [CommRing B] [Algebra R B]", "{R A B}", "{R A B}", "(R)", "{R}", "(R A B)", "{R A B}", "{A B C : Type*} [CommRing A] [CommRing B] [CommRing C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : Algebra A B\n\u22a2 (algebraMap A B).FinitePresentation \u2194 Algebra.FinitePresentation A B"}, {"line": "delta RingHom.FinitePresentation", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : Algebra A B\n\u22a2 Algebra.FinitePresentation A B \u2194 Algebra.FinitePresentation A B"}, {"line": "congr!", "tactic_state": "case a.h.e'_5\nA : Type u_1\nB : Type u_2\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : Algebra A B\n\u22a2 (algebraMap A B).toAlgebra = inst\u271d"}, {"line": "exact Algebra.algebra_ext _ _ fun _ \u21a6 rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_surjective (f : A \u2192+* B) (hf : Surjective f) (hker : (RingHom.ker f).FG) :\n    f.FinitePresentation := by\n  rw [\u2190 f.comp_id]\n  exact (id A).comp_surjective hf hker\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/FinitePresentation.lean", "context": {"open": ["Function (Surjective)", "Polynomial", "MvPolynomial"], "variables": ["(R : Type w\u2081) (A : Type w\u2082) (B : Type w\u2083)", "[CommRing R] [CommRing A] [Algebra R A] [CommRing B] [Algebra R B]", "{R A B}", "{R A B}", "(R)", "{R}", "(R A B)", "{R A B}", "{A B C : Type*} [CommRing A] [CommRing B] [CommRing C]", "(A) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nhf : Surjective \u21d1f\nhker : (RingHom.ker f).FG\n\u22a2 f.FinitePresentation"}, {"line": "rw [\u2190 f.comp_id]", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nhf : Surjective \u21d1f\nhker : (RingHom.ker f).FG\n\u22a2 (f.comp (RingHom.id A)).FinitePresentation"}, {"line": "exact (id A).comp_surjective hf hker", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_surjective (f : A \u2192\u2090[R] B) (hf : Surjective f) (hker : (RingHom.ker f.toRingHom).FG) :\n    f.FinitePresentation := by\n  -- Porting note: added `convert`\n  convert RingHom.FinitePresentation.of_surjective f hf hker\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/FinitePresentation.lean", "context": {"open": ["Function (Surjective)", "Polynomial", "MvPolynomial", "Polynomial"], "variables": ["(R : Type w\u2081) (A : Type w\u2082) (B : Type w\u2083)", "[CommRing R] [CommRing A] [Algebra R A] [CommRing B] [Algebra R B]", "{R A B}", "{R A B}", "(R)", "{R}", "(R A B)", "{R A B}", "{A B C : Type*} [CommRing A] [CommRing B] [CommRing C]", "(A) in", "{R A B C : Type*} [CommRing R]", "[CommRing A] [CommRing B] [CommRing C]", "[Algebra R A] [Algebra R B] [Algebra R C]", "(R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type w\u2081\ninst\u271d\u2076 : CommRing R\nA : Type u_1\nB : Type u_2\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : CommRing B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nf : A \u2192\u2090[R] B\nhf : Surjective \u21d1f\nhker : (RingHom.ker f.toRingHom).FG\n\u22a2 f.FinitePresentation"}, {"line": "convert RingHom.FinitePresentation.of_surjective f hf hker", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_frobenius (f : Ring.Perfection R p) (n : \u2115) :\n    coeff R p (n + 1) (frobenius _ p f) = coeff R p n f := by apply coeff_pow_p f n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Perfection.lean", "context": {"open": ["scoped NNReal"], "variables": ["(R : Type u\u2081) [CommSemiring R] (p : \u2115) [hp : Fact p.Prime] [CharP R p]", "{R p}", "(R p)", "{R p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\u2081\ninst\u271d\u00b9 : CommSemiring R\np : \u2115\nhp : Fact (Nat.Prime p)\ninst\u271d : CharP R p\nx\u271d : Sort u_1\ncoeff : x\u271d\nf : Ring.Perfection R p\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "apply coeff_pow_p f n", "tactic_state": "\u22a2 {R : Type u\u2081} \u2192\n    [inst : CommSemiring R] \u2192\n      {p : \u2115} \u2192\n        [hp : Fact (Nat.Prime p)] \u2192 [inst_1 : CharP R p] \u2192 {coeff : ?m.2053} \u2192 Ring.Perfection R p \u2192 \u2115 \u2192 Sort u_2"}]}
{"declaration": "theorem isDomain : IsDomain (PreTilt O p) := by\n  have hp : Nat.Prime p := Fact.out\n  haveI : Nontrivial (PreTilt O p) := \u27e8(CharP.nontrivial_of_char_ne_one hp.ne_one).1\u27e9\n  haveI : NoZeroDivisors (PreTilt O p) :=\n    \u27e8fun hfg => by\n      simp_rw [\u2190 map_eq_zero hv] at hfg \u22a2; contrapose! hfg; rw [Valuation.map_mul]\n      exact mul_ne_zero hfg.1 hfg.2\u27e9\n  exact NoZeroDivisors.to_isDomain _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Perfection.lean", "context": {"open": ["scoped NNReal", "NNReal", "Perfection", "scoped Classical in", "scoped Classical in"], "variables": ["(R : Type u\u2081) [CommSemiring R] (p : \u2115) [hp : Fact p.Prime] [CharP R p]", "{R p}", "(R p)", "{R p}", "(R p)", "{R} {S : Type u\u2082} [CommSemiring S] [CharP S p]", "{p : \u2115} [Fact p.Prime]", "{R : Type u\u2081} [CommSemiring R] [CharP R p]", "{P : Type u\u2083} [CommSemiring P] [CharP P p] [PerfectRing P p]", "(p R P)", "{p R P}", "(p R P)", "{R p}", "{P} (p)", "{S : Type u\u2082} [CommSemiring S] [CharP S p]", "{Q : Type u\u2084} [CommSemiring Q] [CharP Q p] [PerfectRing Q p]", "(O : Type u\u2082) [CommRing O] (p : \u2115)", "(K : Type u\u2081) [Field K] (v : Valuation K \u211d\u22650)", "(O : Type u\u2082) [CommRing O] [Algebra O K] (hv : v.Integers O)", "(p : \u2115)", "{K v O p}", "[hp : Fact p.Prime]", "[Fact p.Prime] [Fact (\u00ac IsUnit (p : O))]", "{K v O p}", "(K v O p)", "{K v O p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "O : Type u\u2082\ninst\u271d\u00b2 : CommRing O\np : \u2115\nhp inst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Fact \u00acIsUnit \u2191p\n\u22a2 IsDomain (PreTilt O p)"}, {"line": "have hp : Nat.Prime p := Fact.out", "tactic_state": "O : Type u\u2082\ninst\u271d\u00b2 : CommRing O\np : \u2115\nhp\u271d inst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Fact \u00acIsUnit \u2191p\nhp : Nat.Prime p\n\u22a2 IsDomain (PreTilt O p)"}, {"line": "haveI : Nontrivial (PreTilt O p) := \u27e8(CharP.nontrivial_of_char_ne_one hp.ne_one).1\u27e9", "tactic_state": "case refine_3\nO : Type u\u2082\ninst\u271d\u00b2 : CommRing O\np : \u2115\nhp\u271d inst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Fact \u00acIsUnit \u2191p\nhp : Nat.Prime p\nthis : Nontrivial sorry\n\u22a2 IsDomain (PreTilt O p)\n---\ncase refine_1\nO : Type u\u2082\ninst\u271d\u00b2 : CommRing O\np : \u2115\nhp\u271d inst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Fact \u00acIsUnit \u2191p\nhp : Nat.Prime p\n\u22a2 NonAssocSemiring sorry\n---\ncase refine_2\nO : Type u\u2082\ninst\u271d\u00b2 : CommRing O\np : \u2115\nhp\u271d inst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Fact \u00acIsUnit \u2191p\nhp : Nat.Prime p\n\u22a2 CharP sorry p"}, {"line": "haveI : NoZeroDivisors (PreTilt O p) :=\n    \u27e8fun hfg => by\n      simp_rw [\u2190 map_eq_zero hv] at hfg \u22a2; contrapose! hfg; rw [Valuation.map_mul]\n      exact mul_ne_zero hfg.1 hfg.2\u27e9", "tactic_state": "case refine_3\nO : Type u\u2082\ninst\u271d\u00b2 : CommRing O\np : \u2115\nhp\u271d inst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Fact \u00acIsUnit \u2191p\nhp : Nat.Prime p\nthis\u271d : Nontrivial sorry\nthis : sorry\n\u22a2 IsDomain (PreTilt O p)\n---\ncase refine_1\nO : Type u\u2082\ninst\u271d\u00b2 : CommRing O\np : \u2115\nhp\u271d inst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Fact \u00acIsUnit \u2191p\nhp : Nat.Prime p\n\u22a2 NonAssocSemiring sorry\n---\ncase refine_2\nO : Type u\u2082\ninst\u271d\u00b2 : CommRing O\np : \u2115\nhp\u271d inst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Fact \u00acIsUnit \u2191p\nhp : Nat.Prime p\n\u22a2 CharP sorry p"}, {"line": "exact NoZeroDivisors.to_isDomain _", "tactic_state": "case refine_1\nO : Type u\u2082\ninst\u271d\u00b2 : CommRing O\np : \u2115\nhp\u271d inst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Fact \u00acIsUnit \u2191p\nhp : Nat.Prime p\n\u22a2 NonAssocSemiring sorry\n---\ncase refine_2\nO : Type u\u2082\ninst\u271d\u00b2 : CommRing O\np : \u2115\nhp\u271d inst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Fact \u00acIsUnit \u2191p\nhp : Nat.Prime p\n\u22a2 CharP sorry p"}]}
{"declaration": "theorem constantBaseRingEquiv_tprod (x : \u03b9 \u2192 R) :\n    constantBaseRingEquiv \u03b9 R (tprod R x) = \u220f i, x i := by\n  simp [constantBaseRingEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PiTensorProduct.lean", "context": {"open": ["TensorProduct Function", "Function"], "variables": ["{\u03b9 R' R : Type*} {A : \u03b9 \u2192 Type*}", "[CommSemiring R] [\u2200 i, AddCommMonoidWithOne (A i)] [\u2200 i, Module R (A i)]", "[CommSemiring R] [\u2200 i, NonUnitalNonAssocSemiring (A i)]", "[\u2200 i, Module R (A i)] [\u2200 i, SMulCommClass R (A i) (A i)] [\u2200 i, IsScalarTower R (A i) (A i)]", "[CommSemiring R] [\u2200 i, NonAssocSemiring (A i)]", "[\u2200 i, Module R (A i)] [\u2200 i, SMulCommClass R (A i) (A i)] [\u2200 i, IsScalarTower R (A i) (A i)]", "(R) in", "[CommSemiring R] [\u2200 i, NonUnitalSemiring (A i)]", "[\u2200 i, Module R (A i)] [\u2200 i, SMulCommClass R (A i) (A i)] [\u2200 i, IsScalarTower R (A i) (A i)]", "[CommSemiring R'] [CommSemiring R] [\u2200 i, Semiring (A i)]", "[Algebra R' R] [\u2200 i, Algebra R (A i)] [\u2200 i, Algebra R' (A i)]", "[\u2200 i, IsScalarTower R' R (A i)]", "[CommRing R] [\u2200 i, Ring (A i)] [\u2200 i, Algebra R (A i)]", "[CommSemiring R] [\u2200 i, CommSemiring (A i)] [\u2200 i, Algebra R (A i)]", "[Fintype \u03b9]", "(R \u03b9)", "{R \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_3\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Fintype \u03b9\nx\u271d : Sort u_5\nconstantBaseRingEquiv : x\u271d\nx : \u03b9 \u2192 R\n\u22a2 sorry = \u220f i, x i"}, {"line": "simp [constantBaseRingEquiv]", "tactic_state": "\u03b9 : Type u_1\nR : Type u_3\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Fintype \u03b9\nx\u271d : Sort u_5\nconstantBaseRingEquiv : x\u271d\nx : \u03b9 \u2192 R\n\u22a2 sorry () = \u220f i, x i"}]}
{"declaration": "theorem exists_gen_dvd_sub (pb : PowerBasis A B) (b : B) : \u2203 a, pb.gen \u2223 b - algebraMap A B a := by\n  simpa [\u2190 Ideal.mem_span_singleton, \u2190 mk_eq_zero, mk_sub, sub_eq_zero] using pb.exists_smodEq b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerBasis.lean", "context": {"open": ["Polynomial Finsupp", "Ideal Finset Submodule in", "Submodule.Quotient in"], "variables": ["{R S T : Type*} [CommRing R] [Ring S] [Algebra R S]", "{A B : Type*} [CommRing A] [CommRing B] [Algebra A B]", "{K : Type*} [Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : Algebra A B\npb : PowerBasis A B\nb : B\n\u22a2 \u2203 a, pb.gen \u2223 b - (algebraMap A B) a"}, {"line": "simpa [\u2190 Ideal.mem_span_singleton, \u2190 mk_eq_zero, mk_sub, sub_eq_zero] using pb.exists_smodEq b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem constr_pow_gen (pb : PowerBasis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0) :\n    pb.basis.constr A (fun i => y ^ (i : \u2115)) pb.gen = y := by\n  convert pb.constr_pow_aeval hy X <;> rw [aeval_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerBasis.lean", "context": {"open": ["Polynomial Finsupp", "Ideal Finset Submodule in", "Submodule.Quotient in"], "variables": ["{R S T : Type*} [CommRing R] [Ring S] [Algebra R S]", "{A B : Type*} [CommRing A] [CommRing B] [Algebra A B]", "{K : Type*} [Field K]", "[Algebra A S]", "[Algebra A S] {S' : Type*} [Ring S'] [Algebra A S']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_4\nS' : Type u_5\npb : sorry\ny : S'\nhy : sorry = 0\n\u22a2 sorry = y"}, {"line": "convert pb.constr_pow_aeval hy X <;> rw [aeval_X]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma localizationAway_dimension_zero : (localizationAway S r).dimension = 0 := by\n  simp [Presentation.dimension, localizationAway, Generators.localizationAway_vars]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Presentation.lean", "context": {"open": ["TensorProduct MvPolynomial", "IsLocalization.Away"], "variables": ["(R : Type u) (S : Type v) [CommRing R] [CommRing S] [Algebra R S]", "{R S}", "(P : Presentation.{t, w} R S)", "(R S) in", "(R) in", "(r : R) [IsLocalization.Away r S]", "(S) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Presentation : ?m.2265\nR : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nP : sorry\nx\u271d : Sort u_1\nlocalizationAway : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [Presentation.dimension, localizationAway, Generators.localizationAway_vars]", "tactic_state": "Presentation : ?m.2265\nR : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nP : sorry\nx\u271d : Sort u_1\nlocalizationAway : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma dimension_reindex (P : Presentation.{w, t} R S) {\u03b9 \u03ba : Type*} (e : \u03b9 \u2243 P.vars)\n    (f : \u03ba \u2243 P.rels) :\n    (P.reindex e f).dimension = P.dimension := by\n  simp [dimension, Generators.reindex_vars, reindex_rels, Nat.card_congr e, Nat.card_congr f]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Presentation.lean", "context": {"open": ["TensorProduct MvPolynomial", "IsLocalization.Away"], "variables": ["(R : Type u) (S : Type v) [CommRing R] [CommRing S] [Algebra R S]", "{R S}", "(P : Presentation.{t, w} R S)", "(R S) in", "(R) in", "(r : R) [IsLocalization.Away r S]", "(S) in", "(T) [CommRing T] [Algebra R T] (P : Presentation R S)", "{T} [CommRing T] [Algebra S T]", "(Q : Presentation S T) (P : Presentation R S)", "[Algebra R T] [IsScalarTower R S T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Presentation : ?m.5781\nR : Type u\nS : Type v\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : Algebra R S\nP\u271d\u00b9 : sorry\nT : Type ?u.5954\ninst\u271d\u00b3 : CommRing T\ninst\u271d\u00b2 : Algebra S T\nQ : sorry\nP\u271d : sorry\ninst\u271d\u00b9 : Algebra R T\ninst\u271d : IsScalarTower R S T\nP : sorry\n\u03b9 : Type u_1\n\u03ba : Type u_2\ne : \u03b9 \u2243 sorry\nf : \u03ba \u2243 sorry\n\u22a2 sorry = sorry"}, {"line": "simp [dimension, Generators.reindex_vars, reindex_rels, Nat.card_congr e, Nat.card_congr f]", "tactic_state": "Presentation : ?m.5781\nR : Type u\nS : Type v\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : Algebra R S\nP\u271d\u00b9 : sorry\nT : Type ?u.5954\ninst\u271d\u00b3 : CommRing T\ninst\u271d\u00b2 : Algebra S T\nQ : sorry\nP\u271d : sorry\ninst\u271d\u00b9 : Algebra R T\ninst\u271d : IsScalarTower R S T\nP : sorry\n\u03b9 : Type u_1\n\u03ba : Type u_2\ne : \u03b9 \u2243 sorry\nf : \u03ba \u2243 sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem divRadical_dvd_self (a : E) : divRadical a \u2223 a := by\n  exact Dvd.intro (radical a) (divRadical_mul_radical a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Radical.lean", "context": {"open": ["scoped Classical in", "UniqueFactorizationMonoid", "UniqueFactorizationDomain"], "variables": ["{M : Type*} [CancelCommMonoidWithZero M] [NormalizationMonoid M]", "{R : Type*} [CommRing R] [IsDomain R] [NormalizationMonoid R]", "{E : Type*} [EuclideanDomain E] [NormalizationMonoid E] [UniqueFactorizationMonoid E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : EuclideanDomain E\ninst\u271d\u00b9 : NormalizationMonoid E\ninst\u271d : UniqueFactorizationMonoid E\nx\u271d : Sort u_4\ndivRadical : x\u271d\na : E\n\u22a2 sorry \u2223 a"}, {"line": "exact Dvd.intro (radical a) (divRadical_mul_radical a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isAdjoinRoot_root_eq_root : (AdjoinRoot.isAdjoinRoot f).root = AdjoinRoot.root f := by\n  simp only [IsAdjoinRoot.root]\n  simp only [AdjoinRoot.root]\n  simp only [AdjoinRoot.isAdjoinRoot_map_eq_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IsAdjoinRoot.lean", "context": {"open": ["scoped Polynomial", "Polynomial"], "variables": ["{R : Type u} {S : Type v} [CommRing R] [Ring S] {f : R[X]} [Algebra R S]", "{T : Type*} [CommRing T] {i : R \u2192+* T} {x : T}", "(hx : f.eval\u2082 i x = 0)", "(i x)", "{i x}", "[Algebra R T] (hx' : aeval x f = 0)", "(x) in", "(f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nf : Polynomial R\n\u22a2 (AdjoinRoot.isAdjoinRoot f).root = AdjoinRoot.root f"}, {"line": "simp only [IsAdjoinRoot.root]", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nf : Polynomial R\n\u22a2 (AdjoinRoot.isAdjoinRoot f).map X = AdjoinRoot.root f"}, {"line": "simp only [AdjoinRoot.root]", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nf : Polynomial R\n\u22a2 (AdjoinRoot.isAdjoinRoot f).map X = (AdjoinRoot.mk f) X"}, {"line": "simp only [AdjoinRoot.isAdjoinRoot_map_eq_mk]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isAdjoinRootMonic_root_eq_root (hf : Monic f) :\n    (AdjoinRoot.isAdjoinRootMonic f hf).root = AdjoinRoot.root f := by\n  simp only [IsAdjoinRoot.root]\n  simp only [AdjoinRoot.root]\n  simp only [AdjoinRoot.isAdjoinRootMonic_map_eq_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IsAdjoinRoot.lean", "context": {"open": ["scoped Polynomial", "Polynomial"], "variables": ["{R : Type u} {S : Type v} [CommRing R] [Ring S] {f : R[X]} [Algebra R S]", "{T : Type*} [CommRing T] {i : R \u2192+* T} {x : T}", "(hx : f.eval\u2082 i x = 0)", "(i x)", "{i x}", "[Algebra R T] (hx' : aeval x f = 0)", "(x) in", "(f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nf : Polynomial R\nhf : f.Monic\n\u22a2 (AdjoinRoot.isAdjoinRootMonic f hf).root = AdjoinRoot.root f"}, {"line": "simp only [IsAdjoinRoot.root]", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nf : Polynomial R\nhf : f.Monic\n\u22a2 (AdjoinRoot.isAdjoinRootMonic f hf).map X = AdjoinRoot.root f"}, {"line": "simp only [AdjoinRoot.root]", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nf : Polynomial R\nhf : f.Monic\n\u22a2 (AdjoinRoot.isAdjoinRootMonic f hf).map X = (AdjoinRoot.mk f) X"}, {"line": "simp only [AdjoinRoot.isAdjoinRootMonic_map_eq_mk]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_modByMonicHom (h : IsAdjoinRootMonic S f) (x : S) : h.map (h.modByMonicHom x) = x := by\n  simp [modByMonicHom, map_modByMonic, map_repr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IsAdjoinRoot.lean", "context": {"open": ["scoped Polynomial", "Polynomial", "IsAdjoinRoot"], "variables": ["{R : Type u} {S : Type v} [CommRing R] [Ring S] {f : R[X]} [Algebra R S]", "{T : Type*} [CommRing T] {i : R \u2192+* T} {x : T}", "(hx : f.eval\u2082 i x = 0)", "(i x)", "{i x}", "[Algebra R T] (hx' : aeval x f = 0)", "(x) in", "(f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring S\nf : Polynomial R\ninst\u271d : Algebra R S\nh : IsAdjoinRootMonic S f\nx : S\n\u22a2 h.map (h.modByMonicHom x) = x"}, {"line": "simp [modByMonicHom, map_modByMonic, map_repr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem modByMonicHom_root (h : IsAdjoinRootMonic S f) (hdeg : 1 < natDegree f) :\n    h.modByMonicHom h.root = X := by simpa using modByMonicHom_root_pow h hdeg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IsAdjoinRoot.lean", "context": {"open": ["scoped Polynomial", "Polynomial", "IsAdjoinRoot"], "variables": ["{R : Type u} {S : Type v} [CommRing R] [Ring S] {f : R[X]} [Algebra R S]", "{T : Type*} [CommRing T] {i : R \u2192+* T} {x : T}", "(hx : f.eval\u2082 i x = 0)", "(i x)", "{i x}", "[Algebra R T] (hx' : aeval x f = 0)", "(x) in", "(f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring S\nf : Polynomial R\ninst\u271d : Algebra R S\nh : IsAdjoinRootMonic S f\nhdeg : 1 < f.natDegree\n\u22a2 h.modByMonicHom h.root = X"}, {"line": "simpa using modByMonicHom_root_pow h hdeg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_apply (h : IsAdjoinRootMonic S f) (z : S) (i : \u2115) :\n    h.coeff z i = if hi : i < natDegree f then h.basis.repr z \u27e8i, hi\u27e9 else 0 := by\n  split_ifs with hi\n  \u00b7 exact h.coeff_apply_lt z i hi\n  \u00b7 exact h.coeff_apply_le z i (le_of_not_lt hi)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IsAdjoinRoot.lean", "context": {"open": ["scoped Polynomial", "Polynomial", "IsAdjoinRoot"], "variables": ["{R : Type u} {S : Type v} [CommRing R] [Ring S] {f : R[X]} [Algebra R S]", "{T : Type*} [CommRing T] {i : R \u2192+* T} {x : T}", "(hx : f.eval\u2082 i x = 0)", "(i x)", "{i x}", "[Algebra R T] (hx' : aeval x f = 0)", "(x) in", "(f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring S\nf : Polynomial R\ninst\u271d : Algebra R S\nh : IsAdjoinRootMonic S f\nz : S\ni : \u2115\n\u22a2 h.coeff z i = if hi : i < f.natDegree then (h.basis.repr z) \u27e8i, hi\u27e9 else 0"}, {"line": "split_ifs with hi", "tactic_state": "case pos\nR : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring S\nf : Polynomial R\ninst\u271d : Algebra R S\nh : IsAdjoinRootMonic S f\nz : S\ni : \u2115\nhi : i < f.natDegree\n\u22a2 h.coeff z i = (h.basis.repr z) \u27e8i, hi\u27e9\n---\ncase neg\nR : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring S\nf : Polynomial R\ninst\u271d : Algebra R S\nh : IsAdjoinRootMonic S f\nz : S\ni : \u2115\nhi : \u00aci < f.natDegree\n\u22a2 h.coeff z i = 0"}, {"line": "\u00b7 exact h.coeff_apply_lt z i hi", "tactic_state": "case neg\nR : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring S\nf : Polynomial R\ninst\u271d : Algebra R S\nh : IsAdjoinRootMonic S f\nz : S\ni : \u2115\nhi : \u00aci < f.natDegree\n\u22a2 h.coeff z i = 0"}, {"line": "\u00b7 exact h.coeff_apply_le z i (le_of_not_lt hi)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aequiv_map (h : IsAdjoinRoot S f) (h' : IsAdjoinRoot T f) (z : R[X]) :\n    h.aequiv h' (h.map z) = h'.map z := by\n  rw [aequiv]\n  rw [AlgEquiv.coe_mk]\n  rw [Equiv.coe_fn_mk]\n  rw [liftHom_map]\n  rw [aeval_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IsAdjoinRoot.lean", "context": {"open": ["scoped Polynomial", "Polynomial", "IsAdjoinRoot"], "variables": ["{R : Type u} {S : Type v} [CommRing R] [Ring S] {f : R[X]} [Algebra R S]", "{T : Type*} [CommRing T] {i : R \u2192+* T} {x : T}", "(hx : f.eval\u2082 i x = 0)", "(i x)", "{i x}", "[Algebra R T] (hx' : aeval x f = 0)", "(x) in", "(f)", "{R : Type u} {S : Type v} [CommRing R] [CommRing S] [Algebra R S] {f : R[X]}", "{T : Type*} [CommRing T] [Algebra R T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nf : Polynomial R\nT : Type u_2\ninst\u271d\u00b9 : CommRing T\ninst\u271d : Algebra R T\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\nz : Polynomial R\n\u22a2 (h.aequiv h') (h.map z) = h'.map z"}, {"line": "rw [aequiv]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nf : Polynomial R\nT : Type u_2\ninst\u271d\u00b9 : CommRing T\ninst\u271d : Algebra R T\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\nz : Polynomial R\n\u22a2 { toFun := \u21d1(liftHom h'.root \u22ef h), invFun := \u21d1(liftHom h.root \u22ef h'), left_inv := \u22ef, right_inv := \u22ef, map_mul' := \u22ef,\n        map_add' := \u22ef, commutes' := \u22ef }\n      (h.map z) =\n    h'.map z"}, {"line": "rw [AlgEquiv.coe_mk]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nf : Polynomial R\nT : Type u_2\ninst\u271d\u00b9 : CommRing T\ninst\u271d : Algebra R T\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\nz : Polynomial R\n\u22a2 { toFun := \u21d1(liftHom h'.root \u22ef h), invFun := \u21d1(liftHom h.root \u22ef h'), left_inv := \u22ef, right_inv := \u22ef } (h.map z) =\n    h'.map z"}, {"line": "rw [Equiv.coe_fn_mk]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nf : Polynomial R\nT : Type u_2\ninst\u271d\u00b9 : CommRing T\ninst\u271d : Algebra R T\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\nz : Polynomial R\n\u22a2 (liftHom h'.root \u22ef h) (h.map z) = h'.map z"}, {"line": "rw [liftHom_map]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nf : Polynomial R\nT : Type u_2\ninst\u271d\u00b9 : CommRing T\ninst\u271d : Algebra R T\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\nz : Polynomial R\n\u22a2 (aeval h'.root) z = h'.map z"}, {"line": "rw [aeval_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aequiv_root (h : IsAdjoinRoot S f) (h' : IsAdjoinRoot T f) :\n    h.aequiv h' h.root = h'.root := by\n  rw [aequiv]\n  rw [AlgEquiv.coe_mk]\n  rw [Equiv.coe_fn_mk]\n  rw [liftHom_root]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IsAdjoinRoot.lean", "context": {"open": ["scoped Polynomial", "Polynomial", "IsAdjoinRoot"], "variables": ["{R : Type u} {S : Type v} [CommRing R] [Ring S] {f : R[X]} [Algebra R S]", "{T : Type*} [CommRing T] {i : R \u2192+* T} {x : T}", "(hx : f.eval\u2082 i x = 0)", "(i x)", "{i x}", "[Algebra R T] (hx' : aeval x f = 0)", "(x) in", "(f)", "{R : Type u} {S : Type v} [CommRing R] [CommRing S] [Algebra R S] {f : R[X]}", "{T : Type*} [CommRing T] [Algebra R T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nf : Polynomial R\nT : Type u_2\ninst\u271d\u00b9 : CommRing T\ninst\u271d : Algebra R T\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\n\u22a2 (h.aequiv h') h.root = h'.root"}, {"line": "rw [aequiv]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nf : Polynomial R\nT : Type u_2\ninst\u271d\u00b9 : CommRing T\ninst\u271d : Algebra R T\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\n\u22a2 { toFun := \u21d1(liftHom h'.root \u22ef h), invFun := \u21d1(liftHom h.root \u22ef h'), left_inv := \u22ef, right_inv := \u22ef, map_mul' := \u22ef,\n        map_add' := \u22ef, commutes' := \u22ef }\n      h.root =\n    h'.root"}, {"line": "rw [AlgEquiv.coe_mk]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nf : Polynomial R\nT : Type u_2\ninst\u271d\u00b9 : CommRing T\ninst\u271d : Algebra R T\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\n\u22a2 { toFun := \u21d1(liftHom h'.root \u22ef h), invFun := \u21d1(liftHom h.root \u22ef h'), left_inv := \u22ef, right_inv := \u22ef } h.root = h'.root"}, {"line": "rw [Equiv.coe_fn_mk]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nf : Polynomial R\nT : Type u_2\ninst\u271d\u00b9 : CommRing T\ninst\u271d : Algebra R T\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\n\u22a2 (liftHom h'.root \u22ef h) h.root = h'.root"}, {"line": "rw [liftHom_root]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsTensorProduct.lift_eq (h : IsTensorProduct f) (f' : M\u2081 \u2192\u2097[R] M\u2082 \u2192\u2097[R] M') (x\u2081 : M\u2081)\n    (x\u2082 : M\u2082) : h.lift f' (f x\u2081 x\u2082) = f' x\u2081 x\u2082 := by\n  delta IsTensorProduct.lift\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IsTensorProduct.lean", "context": {"open": ["TensorProduct"], "variables": ["{R : Type*} [CommSemiring R]", "{M\u2081 M\u2082 M M' : Type*}", "[AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M\u2081] [Module R M\u2082] [Module R M] [Module R M']", "(f : M\u2081 \u2192\u2097[R] M\u2082 \u2192\u2097[R] M)", "{N\u2081 N\u2082 N : Type*} [AddCommMonoid N\u2081] [AddCommMonoid N\u2082] [AddCommMonoid N]", "[Module R N\u2081] [Module R N\u2082] [Module R N]", "{g : N\u2081 \u2192\u2097[R] N\u2082 \u2192\u2097[R] N}", "(R M N) {f}", "{R M N}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2078 : CommSemiring R\nM\u2081 : Type u_2\nM\u2082 : Type u_3\nM : Type u_4\nM' : Type u_5\ninst\u271d\u2077 : AddCommMonoid M\u2081\ninst\u271d\u2076 : AddCommMonoid M\u2082\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : Module R M\u2081\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M'\nf : M\u2081 \u2192\u2097[R] M\u2082 \u2192\u2097[R] M\nh : IsTensorProduct f\nf' : M\u2081 \u2192\u2097[R] M\u2082 \u2192\u2097[R] M'\nx\u2081 : M\u2081\nx\u2082 : M\u2082\n\u22a2 (h.lift f') ((f x\u2081) x\u2082) = (f' x\u2081) x\u2082"}, {"line": "delta IsTensorProduct.lift", "tactic_state": "R : Type u_1\ninst\u271d\u2078 : CommSemiring R\nM\u2081 : Type u_2\nM\u2082 : Type u_3\nM : Type u_4\nM' : Type u_5\ninst\u271d\u2077 : AddCommMonoid M\u2081\ninst\u271d\u2076 : AddCommMonoid M\u2082\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : Module R M\u2081\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M'\nf : M\u2081 \u2192\u2097[R] M\u2082 \u2192\u2097[R] M\nh : IsTensorProduct f\nf' : M\u2081 \u2192\u2097[R] M\u2082 \u2192\u2097[R] M'\nx\u2081 : M\u2081\nx\u2082 : M\u2082\n\u22a2 (TensorProduct.lift f' \u2218\u2097 \u2191h.equiv.symm) ((f x\u2081) x\u2082) = (f' x\u2081) x\u2082"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsTensorProduct.map_eq (hf : IsTensorProduct f) (hg : IsTensorProduct g) (i\u2081 : M\u2081 \u2192\u2097[R] N\u2081)\n    (i\u2082 : M\u2082 \u2192\u2097[R] N\u2082) (x\u2081 : M\u2081) (x\u2082 : M\u2082) : hf.map hg i\u2081 i\u2082 (f x\u2081 x\u2082) = g (i\u2081 x\u2081) (i\u2082 x\u2082) := by\n  delta IsTensorProduct.map\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IsTensorProduct.lean", "context": {"open": ["TensorProduct"], "variables": ["{R : Type*} [CommSemiring R]", "{M\u2081 M\u2082 M M' : Type*}", "[AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M\u2081] [Module R M\u2082] [Module R M] [Module R M']", "(f : M\u2081 \u2192\u2097[R] M\u2082 \u2192\u2097[R] M)", "{N\u2081 N\u2082 N : Type*} [AddCommMonoid N\u2081] [AddCommMonoid N\u2082] [AddCommMonoid N]", "[Module R N\u2081] [Module R N\u2082] [Module R N]", "{g : N\u2081 \u2192\u2097[R] N\u2082 \u2192\u2097[R] N}", "(R M N) {f}", "{R M N}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9\u00b2 : CommSemiring R\nM\u2081 : Type u_2\nM\u2082 : Type u_3\nM : Type u_4\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2082\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : Module R M\u2081\ninst\u271d\u2077 : Module R M\u2082\ninst\u271d\u2076 : Module R M\nf : M\u2081 \u2192\u2097[R] M\u2082 \u2192\u2097[R] M\nN\u2081 : Type u_6\nN\u2082 : Type u_7\nN : Type u_8\ninst\u271d\u2075 : AddCommMonoid N\u2081\ninst\u271d\u2074 : AddCommMonoid N\u2082\ninst\u271d\u00b3 : AddCommMonoid N\ninst\u271d\u00b2 : Module R N\u2081\ninst\u271d\u00b9 : Module R N\u2082\ninst\u271d : Module R N\ng : N\u2081 \u2192\u2097[R] N\u2082 \u2192\u2097[R] N\nhf : IsTensorProduct f\nhg : IsTensorProduct g\ni\u2081 : M\u2081 \u2192\u2097[R] N\u2081\ni\u2082 : M\u2082 \u2192\u2097[R] N\u2082\nx\u2081 : M\u2081\nx\u2082 : M\u2082\n\u22a2 (hf.map hg i\u2081 i\u2082) ((f x\u2081) x\u2082) = (g (i\u2081 x\u2081)) (i\u2082 x\u2082)"}, {"line": "delta IsTensorProduct.map", "tactic_state": "R : Type u_1\ninst\u271d\u00b9\u00b2 : CommSemiring R\nM\u2081 : Type u_2\nM\u2082 : Type u_3\nM : Type u_4\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2082\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : Module R M\u2081\ninst\u271d\u2077 : Module R M\u2082\ninst\u271d\u2076 : Module R M\nf : M\u2081 \u2192\u2097[R] M\u2082 \u2192\u2097[R] M\nN\u2081 : Type u_6\nN\u2082 : Type u_7\nN : Type u_8\ninst\u271d\u2075 : AddCommMonoid N\u2081\ninst\u271d\u2074 : AddCommMonoid N\u2082\ninst\u271d\u00b3 : AddCommMonoid N\ninst\u271d\u00b2 : Module R N\u2081\ninst\u271d\u00b9 : Module R N\u2082\ninst\u271d : Module R N\ng : N\u2081 \u2192\u2097[R] N\u2082 \u2192\u2097[R] N\nhf : IsTensorProduct f\nhg : IsTensorProduct g\ni\u2081 : M\u2081 \u2192\u2097[R] N\u2081\ni\u2082 : M\u2082 \u2192\u2097[R] N\u2082\nx\u2081 : M\u2081\nx\u2082 : M\u2082\n\u22a2 (\u2191hg.equiv \u2218\u2097 TensorProduct.map i\u2081 i\u2082 \u2218\u2097 \u2191hf.equiv.symm) ((f x\u2081) x\u2082) = (g (i\u2081 x\u2081)) (i\u2082 x\u2082)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsTensorProduct.of_equiv (e : M\u2081 \u2297[R] M\u2082 \u2243\u2097[R] M) (he : \u2200 x y, e (x \u2297\u209c y) = f x y) :\n    IsTensorProduct f := by\n  have : TensorProduct.lift f = e := by\n    ext x y\n    simp [he]\n  simpa [IsTensorProduct, this] using e.bijective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IsTensorProduct.lean", "context": {"open": ["TensorProduct"], "variables": ["{R : Type*} [CommSemiring R]", "{M\u2081 M\u2082 M M' : Type*}", "[AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M\u2081] [Module R M\u2082] [Module R M] [Module R M']", "(f : M\u2081 \u2192\u2097[R] M\u2082 \u2192\u2097[R] M)", "{N\u2081 N\u2082 N : Type*} [AddCommMonoid N\u2081] [AddCommMonoid N\u2082] [AddCommMonoid N]", "[Module R N\u2081] [Module R N\u2082] [Module R N]", "{g : N\u2081 \u2192\u2097[R] N\u2082 \u2192\u2097[R] N}", "(R M N) {f}", "{R M N}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2076 : CommSemiring R\nM\u2081 : Type u_2\nM\u2082 : Type u_3\nM : Type u_4\ninst\u271d\u2075 : AddCommMonoid M\u2081\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\u2081\ninst\u271d\u00b9 : Module R M\u2082\ninst\u271d : Module R M\nf : M\u2081 \u2192\u2097[R] M\u2082 \u2192\u2097[R] M\ne : TensorProduct R M\u2081 M\u2082 \u2243\u2097[R] M\nhe : \u2200 (x : M\u2081) (y : M\u2082), e (x \u2297\u209c[R] y) = (f x) y\n\u22a2 IsTensorProduct f"}, {"line": "have : TensorProduct.lift f = e := by\n    ext x y\n    simp [he]", "tactic_state": "R : Type u_1\ninst\u271d\u2076 : CommSemiring R\nM\u2081 : Type u_2\nM\u2082 : Type u_3\nM : Type u_4\ninst\u271d\u2075 : AddCommMonoid M\u2081\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\u2081\ninst\u271d\u00b9 : Module R M\u2082\ninst\u271d : Module R M\nf : M\u2081 \u2192\u2097[R] M\u2082 \u2192\u2097[R] M\ne : TensorProduct R M\u2081 M\u2082 \u2243\u2097[R] M\nhe : \u2200 (x : M\u2081) (y : M\u2082), e (x \u2297\u209c[R] y) = (f x) y\nthis : sorry = e\n\u22a2 IsTensorProduct f"}, {"line": "simpa [IsTensorProduct, this] using e.bijective", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Algebra.pushoutDesc_left [Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]\n    [Algebra R A] (f : S \u2192\u2090[R] A) (g : R' \u2192\u2090[R] A) (H) (x : S) :\n    Algebra.pushoutDesc S' f g H (algebraMap S S' x) = f x := by\n  simp [Algebra.pushoutDesc_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IsTensorProduct.lean", "context": {"open": ["TensorProduct", "IsScalarTower (toAlgHom algebraMap_apply)"], "variables": ["{R : Type*} [CommSemiring R]", "{M\u2081 M\u2082 M M' : Type*}", "[AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M\u2081] [Module R M\u2082] [Module R M] [Module R M']", "(f : M\u2081 \u2192\u2097[R] M\u2082 \u2192\u2097[R] M)", "{N\u2081 N\u2082 N : Type*} [AddCommMonoid N\u2081] [AddCommMonoid N\u2082] [AddCommMonoid N]", "[Module R N\u2081] [Module R N\u2082] [Module R N]", "{g : N\u2081 \u2192\u2097[R] N\u2082 \u2192\u2097[R] N}", "(R M N) {f}", "{R M N}", "{R : Type*} {M : Type v\u2081} {N : Type v\u2082} (S : Type v\u2083)", "[AddCommMonoid M] [AddCommMonoid N] [CommSemiring R]", "[CommSemiring S] [Algebra R S] [Module R M] [Module R N] [Module S N] [IsScalarTower R S N]", "(f : M \u2192\u2097[R] N)", "{S f}", "(h : IsBaseChange S f)", "{P Q : Type*} [AddCommMonoid P] [Module R P]", "[AddCommMonoid Q] [Module S Q]", "[Module R Q] [IsScalarTower R S Q]", "(R M N S)", "{R M N S}", "(A : Type*) [CommSemiring A]", "[Algebra R A] [Algebra S A] [IsScalarTower R S A]", "[Module S M] [IsScalarTower R S M]", "[Module A N] [IsScalarTower S A N] [IsScalarTower R A N]", "(f) in", "{T O : Type*} [CommSemiring T] [Algebra R T] [Algebra S T] [IsScalarTower R S T]", "[AddCommMonoid O] [Module R O] [Module S O] [Module T O] [IsScalarTower S T O]", "[IsScalarTower R S O] [IsScalarTower R T O]", "{R' S' : Type*} [CommSemiring R'] [CommSemiring S']", "[Algebra R R'] [Algebra S S'] [Algebra R' S'] [Algebra R S']", "[IsScalarTower R R' S'] [IsScalarTower R S S']", "(R S R' S')", "{R S R' S'}", "(R S R' S')", "{R S R'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_9\nS : Type v\u2083\ninst\u271d\u00b9\u00b3 : CommSemiring R\ninst\u271d\u00b9\u00b2 : CommSemiring S\ninst\u271d\u00b9\u00b9 : Algebra R S\nR' : Type u_13\nS' : Type u_14\ninst\u271d\u00b9\u2070 : CommSemiring R'\ninst\u271d\u2079 : CommSemiring S'\ninst\u271d\u2078 : Algebra R R'\ninst\u271d\u2077 : Algebra S S'\ninst\u271d\u2076 : Algebra R' S'\ninst\u271d\u2075 : Algebra R S'\ninst\u271d\u2074 : IsScalarTower R R' S'\ninst\u271d\u00b3 : IsScalarTower R S S'\ninst\u271d\u00b2 : IsPushout R S R' S'\nA : Type u_15\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nf : S \u2192\u2090[R] A\ng : R' \u2192\u2090[R] A\nH : \u2200 (x : S) (y : R'), f x * g y = g y * f x\nx : S\n\u22a2 (pushoutDesc S' f g H) ((algebraMap S S') x) = f x"}, {"line": "simp [Algebra.pushoutDesc_apply]", "tactic_state": "R : Type u_9\nS : Type v\u2083\ninst\u271d\u00b9\u00b3 : CommSemiring R\ninst\u271d\u00b9\u00b2 : CommSemiring S\ninst\u271d\u00b9\u00b9 : Algebra R S\nR' : Type u_13\nS' : Type u_14\ninst\u271d\u00b9\u2070 : CommSemiring R'\ninst\u271d\u2079 : CommSemiring S'\ninst\u271d\u2078 : Algebra R R'\ninst\u271d\u2077 : Algebra S S'\ninst\u271d\u2076 : Algebra R' S'\ninst\u271d\u2075 : Algebra R S'\ninst\u271d\u2074 : IsScalarTower R R' S'\ninst\u271d\u00b3 : IsScalarTower R S S'\ninst\u271d\u00b2 : IsPushout R S R' S'\nA : Type u_15\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nf : S \u2192\u2090[R] A\ng : R' \u2192\u2090[R] A\nH : \u2200 (x : S) (y : R'), f x * g y = g y * f x\nx : S\n\u22a2 f x * g 1 = f x"}]}
{"declaration": "theorem Algebra.pushoutDesc_right [Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]\n    [Algebra R A] (f : S \u2192\u2090[R] A) (g : R' \u2192\u2090[R] A) (H) (x : R') :\n    Algebra.pushoutDesc S' f g H (algebraMap R' S' x) = g x := by\n  simp [Algebra.pushoutDesc_apply, Algebra.IsPushout.equiv_symm_algebraMap_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IsTensorProduct.lean", "context": {"open": ["TensorProduct", "IsScalarTower (toAlgHom algebraMap_apply)"], "variables": ["{R : Type*} [CommSemiring R]", "{M\u2081 M\u2082 M M' : Type*}", "[AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M\u2081] [Module R M\u2082] [Module R M] [Module R M']", "(f : M\u2081 \u2192\u2097[R] M\u2082 \u2192\u2097[R] M)", "{N\u2081 N\u2082 N : Type*} [AddCommMonoid N\u2081] [AddCommMonoid N\u2082] [AddCommMonoid N]", "[Module R N\u2081] [Module R N\u2082] [Module R N]", "{g : N\u2081 \u2192\u2097[R] N\u2082 \u2192\u2097[R] N}", "(R M N) {f}", "{R M N}", "{R : Type*} {M : Type v\u2081} {N : Type v\u2082} (S : Type v\u2083)", "[AddCommMonoid M] [AddCommMonoid N] [CommSemiring R]", "[CommSemiring S] [Algebra R S] [Module R M] [Module R N] [Module S N] [IsScalarTower R S N]", "(f : M \u2192\u2097[R] N)", "{S f}", "(h : IsBaseChange S f)", "{P Q : Type*} [AddCommMonoid P] [Module R P]", "[AddCommMonoid Q] [Module S Q]", "[Module R Q] [IsScalarTower R S Q]", "(R M N S)", "{R M N S}", "(A : Type*) [CommSemiring A]", "[Algebra R A] [Algebra S A] [IsScalarTower R S A]", "[Module S M] [IsScalarTower R S M]", "[Module A N] [IsScalarTower S A N] [IsScalarTower R A N]", "(f) in", "{T O : Type*} [CommSemiring T] [Algebra R T] [Algebra S T] [IsScalarTower R S T]", "[AddCommMonoid O] [Module R O] [Module S O] [Module T O] [IsScalarTower S T O]", "[IsScalarTower R S O] [IsScalarTower R T O]", "{R' S' : Type*} [CommSemiring R'] [CommSemiring S']", "[Algebra R R'] [Algebra S S'] [Algebra R' S'] [Algebra R S']", "[IsScalarTower R R' S'] [IsScalarTower R S S']", "(R S R' S')", "{R S R' S'}", "(R S R' S')", "{R S R'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_9\nS : Type v\u2083\ninst\u271d\u00b9\u00b3 : CommSemiring R\ninst\u271d\u00b9\u00b2 : CommSemiring S\ninst\u271d\u00b9\u00b9 : Algebra R S\nR' : Type u_13\nS' : Type u_14\ninst\u271d\u00b9\u2070 : CommSemiring R'\ninst\u271d\u2079 : CommSemiring S'\ninst\u271d\u2078 : Algebra R R'\ninst\u271d\u2077 : Algebra S S'\ninst\u271d\u2076 : Algebra R' S'\ninst\u271d\u2075 : Algebra R S'\ninst\u271d\u2074 : IsScalarTower R R' S'\ninst\u271d\u00b3 : IsScalarTower R S S'\ninst\u271d\u00b2 : IsPushout R S R' S'\nA : Type u_15\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nf : S \u2192\u2090[R] A\ng : R' \u2192\u2090[R] A\nH : \u2200 (x : S) (y : R'), f x * g y = g y * f x\nx : R'\n\u22a2 (pushoutDesc S' f g H) ((algebraMap R' S') x) = g x"}, {"line": "simp [Algebra.pushoutDesc_apply, Algebra.IsPushout.equiv_symm_algebraMap_right]", "tactic_state": "R : Type u_9\nS : Type v\u2083\ninst\u271d\u00b9\u00b3 : CommSemiring R\ninst\u271d\u00b9\u00b2 : CommSemiring S\ninst\u271d\u00b9\u00b9 : Algebra R S\nR' : Type u_13\nS' : Type u_14\ninst\u271d\u00b9\u2070 : CommSemiring R'\ninst\u271d\u2079 : CommSemiring S'\ninst\u271d\u2078 : Algebra R R'\ninst\u271d\u2077 : Algebra S S'\ninst\u271d\u2076 : Algebra R' S'\ninst\u271d\u2075 : Algebra R S'\ninst\u271d\u2074 : IsScalarTower R R' S'\ninst\u271d\u00b3 : IsScalarTower R S S'\ninst\u271d\u00b2 : IsPushout R S R' S'\nA : Type u_15\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nf : S \u2192\u2090[R] A\ng : R' \u2192\u2090[R] A\nH : \u2200 (x : S) (y : R'), f x * g y = g y * f x\nx : R'\n\u22a2 f 1 * g x = g x"}]}
{"declaration": "lemma Module.not_mem_support_iff' :\n    p \u2209 Module.support R M \u2194 \u2200 m : M, \u2203 r \u2209 p.asIdeal, r \u2022 m = 0 := by\n  simp only [not_mem_support_iff]\n  simp only [Ideal.primeCompl]\n  simp only [LocalizedModule.subsingleton_iff]\n  simp only [Submonoid.mem_mk]\n  simp only [Subsemigroup.mem_mk]\n  simp only [Set.mem_compl_iff]\n  simp only [SetLike.mem_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Support.lean", "context": {"open": [], "variables": ["{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] {p : PrimeSpectrum R}", "(R M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np : PrimeSpectrum R\n\u22a2 p \u2209 support R M \u2194 \u2200 (m : M), \u2203 r \u2209 p.asIdeal, r \u2022 m = 0"}, {"line": "simp only [not_mem_support_iff]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np : PrimeSpectrum R\n\u22a2 Subsingleton (LocalizedModule p.asIdeal.primeCompl M) \u2194 \u2200 (m : M), \u2203 r \u2209 p.asIdeal, r \u2022 m = 0"}, {"line": "simp only [Ideal.primeCompl]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np : PrimeSpectrum R\n\u22a2 Subsingleton (LocalizedModule { carrier := (\u2191p.asIdeal)\u1d9c, mul_mem' := \u22ef, one_mem' := \u22ef } M) \u2194\n    \u2200 (m : M), \u2203 r \u2209 p.asIdeal, r \u2022 m = 0"}, {"line": "simp only [LocalizedModule.subsingleton_iff]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np : PrimeSpectrum R\n\u22a2 (\u2200 (m : M), \u2203 r \u2208 { carrier := (\u2191p.asIdeal)\u1d9c, mul_mem' := \u22ef, one_mem' := \u22ef }, r \u2022 m = 0) \u2194\n    \u2200 (m : M), \u2203 r \u2209 p.asIdeal, r \u2022 m = 0"}, {"line": "simp only [Submonoid.mem_mk]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np : PrimeSpectrum R\n\u22a2 (\u2200 (m : M), \u2203 r \u2208 { carrier := (\u2191p.asIdeal)\u1d9c, mul_mem' := \u22ef }, r \u2022 m = 0) \u2194 \u2200 (m : M), \u2203 r \u2209 p.asIdeal, r \u2022 m = 0"}, {"line": "simp only [Subsemigroup.mem_mk]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np : PrimeSpectrum R\n\u22a2 (\u2200 (m : M), \u2203 r \u2208 (\u2191p.asIdeal)\u1d9c, r \u2022 m = 0) \u2194 \u2200 (m : M), \u2203 r \u2209 p.asIdeal, r \u2022 m = 0"}, {"line": "simp only [Set.mem_compl_iff]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np : PrimeSpectrum R\n\u22a2 (\u2200 (m : M), \u2203 r \u2209 \u2191p.asIdeal, r \u2022 m = 0) \u2194 \u2200 (m : M), \u2203 r \u2209 p.asIdeal, r \u2022 m = 0"}, {"line": "simp only [SetLike.mem_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Module.mem_support_iff' :\n    p \u2208 Module.support R M \u2194 \u2203 m : M, \u2200 r \u2209 p.asIdeal, r \u2022 m \u2260 0 := by\n  rw [\u2190 @not_not (_ \u2208 _)]\n  rw [not_mem_support_iff']\n  push_neg\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Support.lean", "context": {"open": [], "variables": ["{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] {p : PrimeSpectrum R}", "(R M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np : PrimeSpectrum R\n\u22a2 p \u2208 support R M \u2194 \u2203 m, \u2200 r \u2209 p.asIdeal, r \u2022 m \u2260 0"}, {"line": "rw [\u2190 @not_not (_ \u2208 _)]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np : PrimeSpectrum R\n\u22a2 \u00acp \u2209 support R M \u2194 \u2203 m, \u2200 r \u2209 p.asIdeal, r \u2022 m \u2260 0"}, {"line": "rw [not_mem_support_iff']", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np : PrimeSpectrum R\n\u22a2 (\u00ac\u2200 (m : M), \u2203 r \u2209 p.asIdeal, r \u2022 m = 0) \u2194 \u2203 m, \u2200 r \u2209 p.asIdeal, r \u2022 m \u2260 0"}, {"line": "push_neg", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np : PrimeSpectrum R\n\u22a2 (\u2203 m, \u2200 r \u2209 p.asIdeal, r \u2022 m \u2260 0) \u2194 \u2203 m, \u2200 r \u2209 p.asIdeal, r \u2022 m \u2260 0"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Module.mem_support_iff_exists_annihilator :\n    p \u2208 Module.support R M \u2194 \u2203 m : M, (R \u2219 m).annihilator \u2264 p.asIdeal := by\n  rw [Module.mem_support_iff']\n  simp_rw [not_imp_not, SetLike.le_def, Submodule.mem_annihilator_span_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Support.lean", "context": {"open": [], "variables": ["{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] {p : PrimeSpectrum R}", "(R M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np : PrimeSpectrum R\n\u22a2 p \u2208 support R M \u2194 \u2203 m, (Submodule.span R {m}).annihilator \u2264 p.asIdeal"}, {"line": "rw [Module.mem_support_iff']", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np : PrimeSpectrum R\n\u22a2 (\u2203 m, \u2200 r \u2209 p.asIdeal, r \u2022 m \u2260 0) \u2194 \u2203 m, (Submodule.span R {m}).annihilator \u2264 p.asIdeal"}, {"line": "simp_rw [not_imp_not, SetLike.le_def, Submodule.mem_annihilator_span_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Module.support_eq_empty_iff :\n    Module.support R M = \u2205 \u2194 Subsingleton M := by\n  rw [\u2190 Set.subset_empty_iff]\n  rw [\u2190 PrimeSpectrum.zeroLocus_singleton_one]\n  rw [\u2190 LocalizedModule.subsingleton_iff_support_subset]\n  rw [LocalizedModule.subsingleton_iff]\n  rw [subsingleton_iff_forall_eq 0]\n  simp only [Submonoid.powers_one]\n  simp only [Submonoid.mem_bot]\n  simp only [exists_eq_left]\n  simp only [one_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Support.lean", "context": {"open": [], "variables": ["{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] {p : PrimeSpectrum R}", "(R M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 support R M = \u2205 \u2194 Subsingleton M"}, {"line": "rw [\u2190 Set.subset_empty_iff]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 support R M \u2286 \u2205 \u2194 Subsingleton M"}, {"line": "rw [\u2190 PrimeSpectrum.zeroLocus_singleton_one]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 support R M \u2286 PrimeSpectrum.zeroLocus {1} \u2194 Subsingleton M"}, {"line": "rw [\u2190 LocalizedModule.subsingleton_iff_support_subset]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 Subsingleton (LocalizedModule (Submonoid.powers 1) M) \u2194 Subsingleton M"}, {"line": "rw [LocalizedModule.subsingleton_iff]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 (\u2200 (m : M), \u2203 r \u2208 Submonoid.powers 1, r \u2022 m = 0) \u2194 Subsingleton M"}, {"line": "rw [subsingleton_iff_forall_eq 0]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 (\u2200 (m : M), \u2203 r \u2208 Submonoid.powers 1, r \u2022 m = 0) \u2194 \u2200 (y : M), y = 0\n---\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 OfNat M 0"}, {"line": "simp only [Submonoid.powers_one]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 (\u2200 (m : M), \u2203 r \u2208 \u22a5, r \u2022 m = 0) \u2194 \u2200 (y : M), y = 0\n---\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 OfNat M 0"}, {"line": "simp only [Submonoid.mem_bot]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 (\u2200 (m : M), \u2203 r, r = 1 \u2227 r \u2022 m = 0) \u2194 \u2200 (y : M), y = 0\n---\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 OfNat M 0"}, {"line": "simp only [exists_eq_left]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 (\u2200 (m : M), 1 \u2022 m = 0) \u2194 \u2200 (y : M), y = 0\n---\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 OfNat M 0"}, {"line": "simp only [one_smul]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 (\u2200 (m : M), m = 0) \u2194 \u2200 (y : M), y = 0\n---\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 OfNat M 0"}]}
{"declaration": "lemma Module.support_of_algebra {A : Type*} [Ring A] [Algebra R A] :\n    Module.support R A = PrimeSpectrum.zeroLocus (RingHom.ker (algebraMap R A)) := by\n  ext p\n  simp only [mem_support_iff']\n  simp only [ne_eq]\n  simp only [PrimeSpectrum.mem_zeroLocus]\n  simp only [SetLike.coe_subset_coe]\n  refine \u27e8fun \u27e8m, hm\u27e9 x hx \u21a6 not_not.mp fun hx' \u21a6 ?_, fun H \u21a6 \u27e81, fun r hr e \u21a6 ?_\u27e9\u27e9\n  \u00b7 simpa [Algebra.smul_def, (show _ = _ from hx)] using hm _ hx'\n  \u00b7 exact hr (H ((Algebra.algebraMap_eq_smul_one _).trans e))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Support.lean", "context": {"open": [], "variables": ["{R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] {p : PrimeSpectrum R}", "(R M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nA : Type u_3\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\n\u22a2 support R A = PrimeSpectrum.zeroLocus \u2191(RingHom.ker (algebraMap R A))"}, {"line": "ext p", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nA : Type u_3\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\np : PrimeSpectrum R\n\u22a2 p \u2208 support R A \u2194 p \u2208 PrimeSpectrum.zeroLocus \u2191(RingHom.ker (algebraMap R A))"}, {"line": "simp only [mem_support_iff']", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nA : Type u_3\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\np : PrimeSpectrum R\n\u22a2 (\u2203 m, \u2200 r \u2209 p.asIdeal, r \u2022 m \u2260 0) \u2194 p \u2208 PrimeSpectrum.zeroLocus \u2191(RingHom.ker (algebraMap R A))"}, {"line": "simp only [ne_eq]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nA : Type u_3\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\np : PrimeSpectrum R\n\u22a2 (\u2203 m, \u2200 r \u2209 p.asIdeal, \u00acr \u2022 m = 0) \u2194 p \u2208 PrimeSpectrum.zeroLocus \u2191(RingHom.ker (algebraMap R A))"}, {"line": "simp only [PrimeSpectrum.mem_zeroLocus]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nA : Type u_3\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\np : PrimeSpectrum R\n\u22a2 (\u2203 m, \u2200 r \u2209 p.asIdeal, \u00acr \u2022 m = 0) \u2194 \u2191(RingHom.ker (algebraMap R A)) \u2286 \u2191p.asIdeal"}, {"line": "simp only [SetLike.coe_subset_coe]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nA : Type u_3\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\np : PrimeSpectrum R\n\u22a2 (\u2203 m, \u2200 r \u2209 p.asIdeal, \u00acr \u2022 m = 0) \u2194 RingHom.ker (algebraMap R A) \u2264 p.asIdeal"}, {"line": "refine \u27e8fun \u27e8m, hm\u27e9 x hx \u21a6 not_not.mp fun hx' \u21a6 ?_, fun H \u21a6 \u27e81, fun r hr e \u21a6 ?_\u27e9\u27e9", "tactic_state": "case h.refine_1\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nA : Type u_3\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\np : PrimeSpectrum R\nx\u271d : \u2203 m, \u2200 r \u2209 p.asIdeal, \u00acr \u2022 m = 0\nx : R\nhx : x \u2208 RingHom.ker (algebraMap R A)\nm : A\nhm : \u2200 r \u2209 p.asIdeal, \u00acr \u2022 m = 0\nhx' : x \u2209 p.asIdeal\n\u22a2 False\n---\ncase h.refine_2\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nA : Type u_3\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\np : PrimeSpectrum R\nH : RingHom.ker (algebraMap R A) \u2264 p.asIdeal\nr : R\nhr : r \u2209 p.asIdeal\ne : r \u2022 sorry = 0\n\u22a2 False"}, {"line": "\u00b7 simpa [Algebra.smul_def, (show _ = _ from hx)] using hm _ hx'", "tactic_state": "case h.refine_2\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nA : Type u_3\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\np : PrimeSpectrum R\nH : RingHom.ker (algebraMap R A) \u2264 p.asIdeal\nr : R\nhr : r \u2209 p.asIdeal\ne : r \u2022 sorry = 0\n\u22a2 False"}, {"line": "\u00b7 exact hr (H ((Algebra.algebraMap_eq_smul_one _).trans e))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsLasker.minimal [DecidableEq (Ideal R)] (h : IsLasker R) (I : Ideal R) :\n    \u2203 t : Finset (Ideal R), t.inf id = I \u2227 (\u2200 \u2983J\u2984, J \u2208 t \u2192 J.IsPrimary) \u2227\n      ((t : Set (Ideal R)).Pairwise ((\u00b7 \u2260 \u00b7) on radical)) \u2227\n      (\u2200 \u2983J\u2984, J \u2208 t \u2192 \u00ac (t.erase J).inf id \u2264 J) := by\n  obtain \u27e8s, hs, hs'\u27e9 := h I\n  exact exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition hs hs'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Lasker.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation"], "variables": ["(R : Type*) [CommSemiring R]", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\n\u03b2\u271d : Sort u_2\nradical : Ideal R \u2192 \u03b2\u271d\ninst\u271d : DecidableEq (Ideal R)\nh : IsLasker R\nI : Ideal R\n\u22a2 \u2203 t,\n    t.inf id = I \u2227\n      (\u2200 \u2983J : Ideal R\u2984, J \u2208 t \u2192 J.IsPrimary) \u2227\n        (\u2191t).Pairwise (Function.onFun (fun x1 x2 => x1 \u2260 x2) radical) \u2227 \u2200 \u2983J : Ideal R\u2984, J \u2208 t \u2192 \u00ac(t.erase J).inf id \u2264 J"}, {"line": "obtain \u27e8s, hs, hs'\u27e9 := h I", "tactic_state": "case intro.intro\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\n\u03b2\u271d : Sort u_2\nradical : Ideal R \u2192 \u03b2\u271d\ninst\u271d : DecidableEq (Ideal R)\nh : IsLasker R\nI : Ideal R\ns : Finset (Ideal R)\nhs : s.inf id = I\nhs' : \u2200 \u2983J : Ideal R\u2984, J \u2208 s \u2192 J.IsPrimary\n\u22a2 \u2203 t,\n    t.inf id = I \u2227\n      (\u2200 \u2983J : Ideal R\u2984, J \u2208 t \u2192 J.IsPrimary) \u2227\n        (\u2191t).Pairwise (Function.onFun (fun x1 x2 => x1 \u2260 x2) radical) \u2227 \u2200 \u2983J : Ideal R\u2984, J \u2208 t \u2192 \u00ac(t.erase J).inf id \u2264 J"}, {"line": "exact exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition hs hs'", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Module.length_eq_height : Module.length R M = Order.height (\u22a4 : Submodule R M) := by\n  apply WithBot.coe_injective\n  rw [Module.coe_length]\n  rw [Order.height_top_eq_krullDim]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Length.lean", "context": {"open": [], "variables": ["(R M : Type*) [Ring R] [AddCommGroup M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 length R M = Order.height \u22a4"}, {"line": "apply WithBot.coe_injective", "tactic_state": "case a\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 \u2191(length R M) = \u2191(Order.height \u22a4)"}, {"line": "rw [Module.coe_length]", "tactic_state": "case a\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 Order.krullDim (Submodule R M) = \u2191(Order.height \u22a4)"}, {"line": "rw [Order.height_top_eq_krullDim]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Module.length_eq_coheight : Module.length R M = Order.coheight (\u22a5 : Submodule R M) := by\n  apply WithBot.coe_injective\n  rw [Module.coe_length]\n  rw [Order.coheight_bot_eq_krullDim]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Length.lean", "context": {"open": [], "variables": ["(R M : Type*) [Ring R] [AddCommGroup M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 length R M = Order.coheight \u22a5"}, {"line": "apply WithBot.coe_injective", "tactic_state": "case a\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 \u2191(length R M) = \u2191(Order.coheight \u22a5)"}, {"line": "rw [Module.coe_length]", "tactic_state": "case a\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 Order.krullDim (Submodule R M) = \u2191(Order.coheight \u22a5)"}, {"line": "rw [Order.coheight_bot_eq_krullDim]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Module.length_eq_zero_iff : Module.length R M = 0 \u2194 Subsingleton M := by\n  rw [\u2190 WithBot.coe_inj]\n  rw [Module.coe_length]\n  rw [WithBot.coe_zero]\n  rw [Order.krullDim_eq_zero_iff_of_orderTop]\n  rw [Submodule.subsingleton_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Length.lean", "context": {"open": [], "variables": ["(R M : Type*) [Ring R] [AddCommGroup M] [Module R M]", "{R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 length R M = 0 \u2194 Subsingleton M"}, {"line": "rw [\u2190 WithBot.coe_inj]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 \u2191(length R M) = \u21910 \u2194 Subsingleton M"}, {"line": "rw [Module.coe_length]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 Order.krullDim (Submodule R M) = \u21910 \u2194 Subsingleton M"}, {"line": "rw [WithBot.coe_zero]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 Order.krullDim (Submodule R M) = 0 \u2194 Subsingleton M"}, {"line": "rw [Order.krullDim_eq_zero_iff_of_orderTop]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 Subsingleton (Submodule R M) \u2194 Subsingleton M"}, {"line": "rw [Submodule.subsingleton_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Module.length_pos_iff : 0 < Module.length R M \u2194 Nontrivial M := by\n  rw [pos_iff_ne_zero]\n  rw [ne_eq]\n  rw [Module.length_eq_zero_iff]\n  rw [not_subsingleton_iff_nontrivial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Length.lean", "context": {"open": [], "variables": ["(R M : Type*) [Ring R] [AddCommGroup M] [Module R M]", "{R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 0 < length R M \u2194 Nontrivial M"}, {"line": "rw [pos_iff_ne_zero]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 length R M \u2260 0 \u2194 Nontrivial M"}, {"line": "rw [ne_eq]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 \u00aclength R M = 0 \u2194 Nontrivial M"}, {"line": "rw [Module.length_eq_zero_iff]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 \u00acSubsingleton M \u2194 Nontrivial M"}, {"line": "rw [not_subsingleton_iff_nontrivial]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Module.length_ne_top_iff_finiteDimensionalOrder :\n    length R M \u2260 \u22a4 \u2194 FiniteDimensionalOrder (Submodule R M) := by\n  rw [Ne]\n  rw [length_eq_top_iff_infiniteDimensionalOrder]\n  rw [\u2190 not_finiteDimensionalOrder_iff]\n  rw [not_not]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Length.lean", "context": {"open": [], "variables": ["(R M : Type*) [Ring R] [AddCommGroup M] [Module R M]", "{R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 length R M \u2260 \u22a4 \u2194 FiniteDimensionalOrder (Submodule R M)"}, {"line": "rw [Ne]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 \u00aclength R M = \u22a4 \u2194 FiniteDimensionalOrder (Submodule R M)"}, {"line": "rw [length_eq_top_iff_infiniteDimensionalOrder]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 \u00acInfiniteDimensionalOrder (Submodule R M) \u2194 FiniteDimensionalOrder (Submodule R M)"}, {"line": "rw [\u2190 not_finiteDimensionalOrder_iff]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 \u00ac\u00acFiniteDimensionalOrder (Submodule R M) \u2194 FiniteDimensionalOrder (Submodule R M)"}, {"line": "rw [not_not]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Module.length_ne_top [IsArtinian R M] [IsNoetherian R M] : Module.length R M \u2260 \u22a4 := by\n  rw [length_ne_top_iff]\n  rw [isFiniteLength_iff_isNoetherian_isArtinian]\n  exact \u27e8\u2039_\u203a, \u2039_\u203a\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Length.lean", "context": {"open": [], "variables": ["(R M : Type*) [Ring R] [AddCommGroup M] [Module R M]", "{R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsArtinian R M\ninst\u271d : IsNoetherian R M\n\u22a2 length R M \u2260 \u22a4"}, {"line": "rw [length_ne_top_iff]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsArtinian R M\ninst\u271d : IsNoetherian R M\n\u22a2 IsFiniteLength R M"}, {"line": "rw [isFiniteLength_iff_isNoetherian_isArtinian]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsArtinian R M\ninst\u271d : IsNoetherian R M\n\u22a2 IsNoetherian R M \u2227 IsArtinian R M"}, {"line": "exact \u27e8\u2039_\u203a, \u2039_\u203a\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Module.length_submodule {N : Submodule R M} :\n    Module.length R N = Order.height N := by\n  apply WithBot.coe_injective\n  rw [Order.height_eq_krullDim_Iic]\n  rw [coe_length]\n  rw [Order.krullDim_eq_of_orderIso (Submodule.mapIic _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Length.lean", "context": {"open": [], "variables": ["(R M : Type*) [Ring R] [AddCommGroup M] [Module R M]", "{R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nN : Submodule R M\n\u22a2 length R \u21a5N = Order.height N"}, {"line": "apply WithBot.coe_injective", "tactic_state": "case a\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nN : Submodule R M\n\u22a2 \u2191(length R \u21a5N) = \u2191(Order.height N)"}, {"line": "rw [Order.height_eq_krullDim_Iic]", "tactic_state": "case a\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nN : Submodule R M\n\u22a2 \u2191(length R \u21a5N) = Order.krullDim \u2191(Set.Iic N)"}, {"line": "rw [coe_length]", "tactic_state": "case a\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nN : Submodule R M\n\u22a2 Order.krullDim (Submodule R \u21a5N) = Order.krullDim \u2191(Set.Iic N)"}, {"line": "rw [Order.krullDim_eq_of_orderIso (Submodule.mapIic _)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Submodule.length_lt [IsArtinian R M] [IsNoetherian R M] {N : Submodule R M} (h : N \u2260 \u22a4) :\n    Module.length R N < Module.length R M := by\n  simpa [\u2190 Module.length_top (M := M), Module.length_submodule] using height_strictMono h.lt_top\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Length.lean", "context": {"open": [], "variables": ["(R M : Type*) [Ring R] [AddCommGroup M] [Module R M]", "{R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsArtinian R M\ninst\u271d : IsNoetherian R M\nN : Submodule R M\nh : N \u2260 \u22a4\n\u22a2 Module.length R \u21a5N < Module.length R M"}, {"line": "simpa [\u2190 Module.length_top (M := M), Module.length_submodule] using height_strictMono h.lt_top", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Module.length_eq_one_iff :\n    Module.length R M = 1 \u2194 IsSimpleModule R M := by\n  rw [\u2190 WithBot.coe_inj]\n  rw [Module.coe_length]\n  rw [WithBot.coe_one]\n  rw [Order.krullDim_eq_one_iff_of_boundedOrder]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Length.lean", "context": {"open": [], "variables": ["(R M : Type*) [Ring R] [AddCommGroup M] [Module R M]", "{R M}", "{N P : Type*} [AddCommGroup N] [AddCommGroup P] [Module R N] [Module R P]", "(f : N \u2192\u2097[R] M) (g : M \u2192\u2097[R] P) (hf : Function.Injective f) (hg : Function.Surjective g)", "(H : Function.Exact f g)", "(R M N) in", "(R) in", "(R M) in", "(R M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 length R M = 1 \u2194 IsSimpleModule R M"}, {"line": "rw [\u2190 WithBot.coe_inj]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 \u2191(length R M) = \u21911 \u2194 IsSimpleModule R M"}, {"line": "rw [Module.coe_length]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 Order.krullDim (Submodule R M) = \u21911 \u2194 IsSimpleModule R M"}, {"line": "rw [WithBot.coe_one]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 Order.krullDim (Submodule R M) = 1 \u2194 IsSimpleModule R M"}, {"line": "rw [Order.krullDim_eq_one_iff_of_boundedOrder]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bot_left : (\u22a5 : Subalgebra R S).LinearDisjoint B := by\n  rw [Subalgebra.LinearDisjoint]\n  rw [Algebra.toSubmodule_bot]\n  exact Submodule.LinearDisjoint.one_left _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LinearDisjoint.lean", "context": {"open": ["scoped TensorProduct"], "variables": ["{R : Type u} {S : Type v}", "[CommSemiring R] [Semiring S] [Algebra R S]", "(A B : Subalgebra R S)", "{A B}", "(A B)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Algebra R S\nB : Subalgebra R S\n\u22a2 \u22a5.LinearDisjoint B"}, {"line": "rw [Subalgebra.LinearDisjoint]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Algebra R S\nB : Subalgebra R S\n\u22a2 (Subalgebra.toSubmodule \u22a5).LinearDisjoint (Subalgebra.toSubmodule B)"}, {"line": "rw [Algebra.toSubmodule_bot]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Algebra R S\nB : Subalgebra R S\n\u22a2 Submodule.LinearDisjoint 1 (Subalgebra.toSubmodule B)"}, {"line": "exact Submodule.LinearDisjoint.one_left _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bot_right : A.LinearDisjoint \u22a5 := by\n  rw [Subalgebra.LinearDisjoint]\n  rw [Algebra.toSubmodule_bot]\n  exact Submodule.LinearDisjoint.one_right _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LinearDisjoint.lean", "context": {"open": ["scoped TensorProduct"], "variables": ["{R : Type u} {S : Type v}", "[CommSemiring R] [Semiring S] [Algebra R S]", "(A B : Subalgebra R S)", "{A B}", "(A B)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Algebra R S\nA : Subalgebra R S\n\u22a2 A.LinearDisjoint \u22a5"}, {"line": "rw [Subalgebra.LinearDisjoint]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Algebra R S\nA : Subalgebra R S\n\u22a2 (Subalgebra.toSubmodule A).LinearDisjoint (Subalgebra.toSubmodule \u22a5)"}, {"line": "rw [Algebra.toSubmodule_bot]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Algebra R S\nA : Subalgebra R S\n\u22a2 (Subalgebra.toSubmodule A).LinearDisjoint 1"}, {"line": "exact Submodule.LinearDisjoint.one_right _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finrank_sup_of_free [Module.Free R A] [Module.Free R B] :\n    Module.finrank R \u21a5(A \u2294 B) = Module.finrank R A * Module.finrank R B := by\n  simpa only [map_mul] using congr(Cardinal.toNat $(H.rank_sup_of_free))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LinearDisjoint.lean", "context": {"open": ["scoped TensorProduct", "Cardinal Polynomial in"], "variables": ["{R : Type u} {S : Type v}", "[CommSemiring R] [Semiring S] [Algebra R S]", "(A B : Subalgebra R S)", "{A B}", "(A B)", "(R) in", "[CommSemiring R] [CommSemiring S] [Algebra R S]", "{A B : Subalgebra R S}", "(H : A.LinearDisjoint B)", "[CommRing R] [Ring S] [Algebra R S]", "(A B : Subalgebra R S)", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B}", "(H : A.LinearDisjoint B)", "[CommRing R] [CommRing S] [Algebra R S]", "(A B : Subalgebra R S)", "{A B} in", "{A B}", "(R) in", "(R) in", "(R) in", "(H : A.LinearDisjoint B)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : Semiring S\ninst\u271d\u2078 : Algebra R S\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : Ring S\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nA B : Subalgebra R S\ninst\u271d\u00b9 : Module.Free R \u21a5A\ninst\u271d : Module.Free R \u21a5B\n\u22a2 Module.finrank R \u21a5(A \u2294 B) = Module.finrank R \u21a5A * Module.finrank R \u21a5B"}, {"line": "simpa only [map_mul] using congr(Cardinal.toNat $(H.rank_sup_of_free))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_subset_support_matPolyEquiv (m : Matrix n n R[X]) (i j : n) :\n    support (m i j) \u2286 support (matPolyEquiv m) := by\n  intro k\n  contrapose\n  simp only [not_mem_support_iff]\n  intro hk\n  rw [\u2190 matPolyEquiv_coeff_apply]\n  rw [hk]\n  rw [zero_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MatrixPolynomialAlgebra.lean", "context": {"open": ["Polynomial TensorProduct", "Algebra.TensorProduct (algHomOfLinearMapTensorProduct includeLeft)", "Matrix", "Finset"], "variables": ["(R A : Type*)", "[CommSemiring R]", "[Semiring A] [Algebra R A]", "{R}", "{n : Type w} [DecidableEq n] [Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nm : Matrix n n (Polynomial R)\ni j : n\n\u22a2 (m i j).support \u2286 (matPolyEquiv m).support"}, {"line": "intro k", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nm : Matrix n n (Polynomial R)\ni j : n\nk : \u2115\n\u22a2 k \u2208 (m i j).support \u2192 k \u2208 (matPolyEquiv m).support"}, {"line": "contrapose", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nm : Matrix n n (Polynomial R)\ni j : n\nk : \u2115\n\u22a2 k \u2209 (matPolyEquiv m).support \u2192 k \u2209 (m i j).support"}, {"line": "simp only [not_mem_support_iff]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nm : Matrix n n (Polynomial R)\ni j : n\nk : \u2115\n\u22a2 (matPolyEquiv m).coeff k = 0 \u2192 (m i j).coeff k = 0"}, {"line": "intro hk", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nm : Matrix n n (Polynomial R)\ni j : n\nk : \u2115\nhk : (matPolyEquiv m).coeff k = 0\n\u22a2 (m i j).coeff k = 0"}, {"line": "rw [\u2190 matPolyEquiv_coeff_apply]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nm : Matrix n n (Polynomial R)\ni j : n\nk : \u2115\nhk : (matPolyEquiv m).coeff k = 0\n\u22a2 (matPolyEquiv m).coeff k i j = 0\n---\nR : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nm : Matrix n n (Polynomial R)\ni j : n\nk : \u2115\nhk : (matPolyEquiv m).coeff k = 0\n\u22a2 DecidableEq n\n---\nR : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nm : Matrix n n (Polynomial R)\ni j : n\nk : \u2115\nhk : (matPolyEquiv m).coeff k = 0\n\u22a2 Fintype n"}, {"line": "rw [hk]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nm : Matrix n n (Polynomial R)\ni j : n\nk : \u2115\nhk : (matPolyEquiv m).coeff k = 0\n\u22a2 0 i j = 0"}, {"line": "rw [zero_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma evalRingHom_mapMatrix_comp_polyToMatrix :\n    (evalRingHom 0).mapMatrix.comp f.polyToMatrix = f.comp (evalRingHom 0) := by\n  ext <;> simp [RingHom.polyToMatrix, \u2190 AlgEquiv.symm_toRingEquiv, diagonal, apply_ite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MatrixPolynomialAlgebra.lean", "context": {"open": ["Polynomial TensorProduct", "Algebra.TensorProduct (algHomOfLinearMapTensorProduct includeLeft)", "Matrix", "Finset"], "variables": ["(R A : Type*)", "[CommSemiring R]", "[Semiring A] [Algebra R A]", "{R}", "{n : Type w} [DecidableEq n] [Fintype n]", "{A}", "{S : Type*} [CommSemiring S] (f : S \u2192+* Matrix n n R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nn : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nS : Type u_3\ninst\u271d : CommSemiring S\nf : S \u2192+* Matrix n n R\n\u22a2 (evalRingHom 0).mapMatrix.comp f.polyToMatrix = f.comp (evalRingHom 0)"}, {"line": "ext <;> simp [RingHom.polyToMatrix, \u2190 AlgEquiv.symm_toRingEquiv, diagonal, apply_ite]", "tactic_state": "case a.a\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nn : Type w\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nS : Type u_3\ninst\u271d : CommSemiring S\nf : S \u2192+* Matrix n n R\nx\u271d : Polynomial S\ni\u271d j\u271d : n\n\u22a2 eval 0 (matPolyEquiv.symm (Polynomial.map f x\u271d) i\u271d j\u271d) = f (eval 0 x\u271d) i\u271d j\u271d"}]}
{"declaration": "private lemma lt_up (vlt : \u2200 i, v i < up) : \u2200 l \u2208 ofFn v, l < up := by\n  intro l h\n  rw [mem_ofFn] at h\n  obtain \u27e8y, rfl\u27e9 := h\n  exact vlt y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/NoetherNormalization.lean", "context": {"open": ["Polynomial MvPolynomial Ideal BigOperators Nat RingHom List"], "variables": ["{k : Type*} [Field k] {n : \u2115} (f : MvPolynomial (Fin (n + 1)) k)", "(v w : Fin (n + 1) \u2192\u2080 \u2115)", "{f v} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nv : Fin (n + 1) \u2192\u2080 \u2115\nup : \u2115\nvlt : \u2200 (i : Fin (n + 1)), v i < up\n\u22a2 \u2200 l \u2208 List.ofFn \u21d1v, l < up"}, {"line": "intro l h", "tactic_state": "n : \u2115\nv : Fin (n + 1) \u2192\u2080 \u2115\nup : \u2115\nvlt : \u2200 (i : Fin (n + 1)), v i < up\nl : \u2115\nh : l \u2208 List.ofFn \u21d1v\n\u22a2 l < up"}, {"line": "rw [mem_ofFn] at h", "tactic_state": "n : \u2115\nv : Fin (n + 1) \u2192\u2080 \u2115\nup : \u2115\nvlt : \u2200 (i : Fin (n + 1)), v i < up\nl : \u2115\nh : \u2203 i, v i = l\n\u22a2 l < up"}, {"line": "obtain \u27e8y, rfl\u27e9 := h", "tactic_state": "case intro\nn : \u2115\nv : Fin (n + 1) \u2192\u2080 \u2115\nup : \u2115\nvlt : \u2200 (i : Fin (n + 1)), v i < up\ny : Fin (n + 1)\n\u22a2 v y < up"}, {"line": "exact vlt y", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_eq_quo_add_rem_div (f : R[X]) {g : R[X]} (hg : g.Monic) :\n    \u2203 q r : R[X], r.degree < g.degree \u2227\n      (algebraMap R[X] K f) / (algebraMap R[X] K g) =\n        algebraMap R[X] K q + (algebraMap R[X] K r) / (algebraMap R[X] K g) := by\n  refine \u27e8f /\u2098 g, f %\u2098 g, ?_, ?_\u27e9\n  \u00b7 exact degree_modByMonic_lt _ hg\n  \u00b7 have hg' : algebraMap R[X] K g \u2260 0 :=\n      -- Porting note: the proof was `by exact_mod_cast Monic.ne_zero hg`\n      (map_ne_zero_iff _ (IsFractionRing.injective R[X] K)).mpr (Monic.ne_zero hg)\n    field_simp [hg']\n    -- Porting note: `norm_cast` was here, but does nothing.\n    rw [add_comm]\n    rw [mul_comm]\n    rw [\u2190 map_mul]\n    rw [\u2190 map_add]\n    rw [modByMonic_add_div f hg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IntegralDomain.lean", "context": {"open": ["Finset Polynomial Function Nat"], "variables": ["{M : Type*} [CancelMonoidWithZero M] [Finite M]", "{R : Type*} {G : Type*}", "[Ring R] [IsDomain R] [Fintype R]", "[CommRing R] [IsDomain R] [Group G]", "(S : Subgroup R\u02e3) [Finite S]", "(K : Type) [Field K] [Algebra R[X] K] [IsFractionRing R[X] K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : IsDomain R\ninst\u271d\u2075 : Fintype R\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\nK : Type\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra (Polynomial R) K\ninst\u271d : IsFractionRing (Polynomial R) K\nf g : Polynomial R\nhg : g.Monic\n\u22a2 \u2203 q r,\n    r.degree < g.degree \u2227\n      (algebraMap (Polynomial R) K) f / (algebraMap (Polynomial R) K) g =\n        (algebraMap (Polynomial R) K) q + (algebraMap (Polynomial R) K) r / (algebraMap (Polynomial R) K) g"}, {"line": "refine \u27e8f /\u2098 g, f %\u2098 g, ?_, ?_\u27e9", "tactic_state": "case refine_1\nR : Type u_2\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : IsDomain R\ninst\u271d\u2075 : Fintype R\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\nK : Type\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra (Polynomial R) K\ninst\u271d : IsFractionRing (Polynomial R) K\nf g : Polynomial R\nhg : g.Monic\n\u22a2 sorry.degree < g.degree\n---\ncase refine_2\nR : Type u_2\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : IsDomain R\ninst\u271d\u2075 : Fintype R\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\nK : Type\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra (Polynomial R) K\ninst\u271d : IsFractionRing (Polynomial R) K\nf g : Polynomial R\nhg : g.Monic\n\u22a2 (algebraMap (Polynomial R) K) f / (algebraMap (Polynomial R) K) g =\n    (algebraMap (Polynomial R) K) sorry + (algebraMap (Polynomial R) K) sorry / (algebraMap (Polynomial R) K) g"}, {"line": "\u00b7 exact degree_modByMonic_lt _ hg", "tactic_state": "case refine_2\nR : Type u_2\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : IsDomain R\ninst\u271d\u2075 : Fintype R\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\nK : Type\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra (Polynomial R) K\ninst\u271d : IsFractionRing (Polynomial R) K\nf g : Polynomial R\nhg : g.Monic\n\u22a2 (algebraMap (Polynomial R) K) f / (algebraMap (Polynomial R) K) g =\n    (algebraMap (Polynomial R) K) sorry + (algebraMap (Polynomial R) K) sorry / (algebraMap (Polynomial R) K) g"}, {"line": "\u00b7 have hg' : algebraMap R[X] K g \u2260 0 :=\n      (map_ne_zero_iff _ (IsFractionRing.injective R[X] K)).mpr (Monic.ne_zero hg)\n    field_simp [hg']\n    rw [add_comm]\n    rw [mul_comm]\n    rw [\u2190 map_mul]\n    rw [\u2190 map_add]\n    rw [modByMonic_add_div f hg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFunLinear_mul_tmul_mul_aux_1 (p : R[X]) (k : \u2115) (h : Decidable \u00acp.coeff k = 0) (a : A) :\n    ite (\u00accoeff p k = 0) (a * (algebraMap R A) (coeff p k)) 0 =\n    a * (algebraMap R A) (coeff p k) := by classical split_ifs <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PolynomialAlgebra.lean", "context": {"open": ["Polynomial TensorProduct", "Algebra.TensorProduct (algHomOfLinearMapTensorProduct includeLeft)"], "variables": ["(R A : Type*)", "[CommSemiring R]", "[Semiring A] [Algebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\np : Polynomial R\nk : \u2115\nh : Decidable \u00acp.coeff k = 0\na : A\n\u22a2 (if \u00acp.coeff k = 0 then a * (algebraMap R A) (p.coeff k) else 0) = a * (algebraMap R A) (p.coeff k)"}, {"line": "classical split_ifs <;> simp [*]", "tactic_state": "case pos\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\np : Polynomial R\nk : \u2115\nh : Decidable \u00acp.coeff k = 0\na : A\nh\u271d : p.coeff k = 0\n\u22a2 0 = a * 0"}]}
{"declaration": "theorem Prime.neg {p : \u03b1} (hp : Prime p) : Prime (-p) := by\n  obtain \u27e8h1, h2, h3\u27e9 := hp\n  exact \u27e8neg_ne_zero.mpr h1, by rwa [IsUnit.neg_iff], by simpa [neg_dvd] using h3\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Prime.lean", "context": {"open": ["Finset"], "variables": ["{R : Type*} [CancelCommMonoidWithZero R]", "{\u03b1 : Type*} [CommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : CommRing \u03b1\np : \u03b1\nhp : Prime p\n\u22a2 Prime (-p)"}, {"line": "obtain \u27e8h1, h2, h3\u27e9 := hp", "tactic_state": "case intro.intro\n\u03b1 : Type u_2\ninst\u271d : CommRing \u03b1\np : \u03b1\nh1 : p \u2260 0\nh2 : \u00acIsUnit p\nh3 : \u2200 (a b : \u03b1), p \u2223 a * b \u2192 p \u2223 a \u2228 p \u2223 b\n\u22a2 Prime (-p)"}, {"line": "exact \u27e8neg_ne_zero.mpr h1, by rwa [IsUnit.neg_iff], by simpa [neg_dvd] using h3\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonPrincipals_eq_empty_iff : nonPrincipals R = \u2205 \u2194 IsPrincipalIdealRing R := by\n  simp [Set.eq_empty_iff_forall_not_mem, isPrincipalIdealRing_iff, nonPrincipals_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PrincipalIdealDomain.lean", "context": {"open": ["Set Function", "Submodule", "Submodule.IsPrincipal Ideal", "EuclideanDomain", "IsPrincipalIdealRing", "scoped Classical in", "Submodule", "Ideal", "Set Ideal"], "variables": ["{R : Type u} {M : Type v}", "[Semiring R] [AddCommGroup M] [Module R M]", "(R)", "[AddCommMonoid M]", "[Semiring R] [Module R M]", "[CommRing R] [Module R M]", "[Ring R]", "(x y : R) [(Ideal.span {x, y}).IsPrincipal]", "[CommRing R] (x y z : R) [(Ideal.span {x, y}).IsPrincipal]", "{x y z} in", "{x y}", "(R)", "[EuclideanDomain R]", "[CommRing R] [IsDomain R] [IsPrincipalIdealRing R]", "{S N F : Type*} [Ring R] [AddCommGroup M] [AddCommGroup N] [Ring S]", "[Module R M] [Module R N] [FunLike F R S] [RingHomClass F R S]", "[CommRing R]", "[IsBezout R]", "[IsDomain R]", "[GCDMonoid R]", "[IsDomain R] [IsPrincipalIdealRing R]", "(R) [CommRing R]", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : EuclideanDomain R\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : IsDomain R\ninst\u271d\u2076 : IsPrincipalIdealRing R\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsBezout R\ninst\u271d\u00b2 inst\u271d\u00b9 : IsDomain R\ninst\u271d : IsPrincipalIdealRing R\n\u22a2 nonPrincipals R = \u2205 \u2194 IsPrincipalIdealRing R"}, {"line": "simp [Set.eq_empty_iff_forall_not_mem, isPrincipalIdealRing_iff, nonPrincipals_def]", "tactic_state": "R : Type u\ninst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : EuclideanDomain R\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : IsDomain R\ninst\u271d\u2076 : IsPrincipalIdealRing R\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsBezout R\ninst\u271d\u00b2 inst\u271d\u00b9 : IsDomain R\ninst\u271d : IsPrincipalIdealRing R\n\u22a2 (\u2200 (x : Ideal R), IsPrincipal x) \u2194 \u2200 (S : Ideal R), IsPrincipal S"}]}
{"declaration": "theorem mem_reesAlgebra_iff_support (f : R[X]) :\n    f \u2208 reesAlgebra I \u2194 \u2200 i \u2208 f.support, f.coeff i \u2208 I ^ i := by\n  apply forall_congr'\n  intro a\n  rw [mem_support_iff]\n  rw [Iff.comm]\n  rw [Classical.imp_iff_right_iff]\n  rw [Ne]\n  rw [\u2190 imp_iff_not_or]\n  exact fun e => e.symm \u25b8 (I ^ a).zero_mem\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/ReesAlgebra.lean", "context": {"open": ["Polynomial"], "variables": ["{R M : Type u} [CommRing R] [AddCommGroup M] [Module R M] (I : Ideal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nI : Ideal R\nf : Polynomial R\n\u22a2 f \u2208 reesAlgebra I \u2194 \u2200 i \u2208 f.support, f.coeff i \u2208 I ^ i"}, {"line": "apply forall_congr'", "tactic_state": "case h\nR : Type u\ninst\u271d : CommRing R\nI : Ideal R\nf : Polynomial R\n\u22a2 \u2200 (a : \u2115), f.coeff a \u2208 I ^ a \u2194 a \u2208 f.support \u2192 f.coeff a \u2208 I ^ a"}, {"line": "intro a", "tactic_state": "case h\nR : Type u\ninst\u271d : CommRing R\nI : Ideal R\nf : Polynomial R\na : \u2115\n\u22a2 f.coeff a \u2208 I ^ a \u2194 a \u2208 f.support \u2192 f.coeff a \u2208 I ^ a"}, {"line": "rw [mem_support_iff]", "tactic_state": "case h\nR : Type u\ninst\u271d : CommRing R\nI : Ideal R\nf : Polynomial R\na : \u2115\n\u22a2 f.coeff a \u2208 I ^ a \u2194 f.coeff a \u2260 0 \u2192 f.coeff a \u2208 I ^ a"}, {"line": "rw [Iff.comm]", "tactic_state": "case h\nR : Type u\ninst\u271d : CommRing R\nI : Ideal R\nf : Polynomial R\na : \u2115\n\u22a2 f.coeff a \u2260 0 \u2192 f.coeff a \u2208 I ^ a \u2194 f.coeff a \u2208 I ^ a"}, {"line": "rw [Classical.imp_iff_right_iff]", "tactic_state": "case h\nR : Type u\ninst\u271d : CommRing R\nI : Ideal R\nf : Polynomial R\na : \u2115\n\u22a2 f.coeff a \u2260 0 \u2228 f.coeff a \u2208 I ^ a"}, {"line": "rw [Ne]", "tactic_state": "case h\nR : Type u\ninst\u271d : CommRing R\nI : Ideal R\nf : Polynomial R\na : \u2115\n\u22a2 \u00acf.coeff a = 0 \u2228 f.coeff a \u2208 I ^ a"}, {"line": "rw [\u2190 imp_iff_not_or]", "tactic_state": "case h\nR : Type u\ninst\u271d : CommRing R\nI : Ideal R\nf : Polynomial R\na : \u2115\n\u22a2 f.coeff a = 0 \u2192 f.coeff a \u2208 I ^ a"}, {"line": "exact fun e => e.symm \u25b8 (I ^ a).zero_mem", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reesAlgebra.monomial_mem {I : Ideal R} {i : \u2115} {r : R} :\n    monomial i r \u2208 reesAlgebra I \u2194 r \u2208 I ^ i := by\n  simp +contextual [mem_reesAlgebra_iff_support, coeff_monomial, \u2190\n    imp_iff_not_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/ReesAlgebra.lean", "context": {"open": ["Polynomial"], "variables": ["{R M : Type u} [CommRing R] [AddCommGroup M] [Module R M] (I : Ideal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nI : Ideal R\ni : \u2115\nr : R\n\u22a2 (monomial i) r \u2208 reesAlgebra I \u2194 r \u2208 I ^ i"}, {"line": "simp +contextual [mem_reesAlgebra_iff_support, coeff_monomial, \u2190\n    imp_iff_not_or]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ZMod.ker_intCastRingHom (n : \u2115) :\n    RingHom.ker (Int.castRingHom (ZMod n)) = Ideal.span ({(n : \u2124)} : Set \u2124) := by\n  ext\n  rw [Ideal.mem_span_singleton]\n  rw [RingHom.mem_ker]\n  rw [Int.coe_castRingHom]\n  rw [ZMod.intCast_zmod_eq_zero_iff_dvd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/ZMod.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 RingHom.ker (Int.castRingHom (ZMod n)) = Ideal.span {\u2191n}"}, {"line": "ext", "tactic_state": "case h\nn : \u2115\nx\u271d : \u2124\n\u22a2 x\u271d \u2208 RingHom.ker (Int.castRingHom (ZMod n)) \u2194 x\u271d \u2208 Ideal.span {\u2191n}"}, {"line": "rw [Ideal.mem_span_singleton]", "tactic_state": "case h\nn : \u2115\nx\u271d : \u2124\n\u22a2 x\u271d \u2208 RingHom.ker (Int.castRingHom (ZMod n)) \u2194 \u2191n \u2223 x\u271d"}, {"line": "rw [RingHom.mem_ker]", "tactic_state": "case h\nn : \u2115\nx\u271d : \u2124\n\u22a2 (Int.castRingHom (ZMod n)) x\u271d = 0 \u2194 \u2191n \u2223 x\u271d"}, {"line": "rw [Int.coe_castRingHom]", "tactic_state": "case h\nn : \u2115\nx\u271d : \u2124\n\u22a2 (fun x => \u2191x) x\u271d = 0 \u2194 \u2191n \u2223 x\u271d"}, {"line": "rw [ZMod.intCast_zmod_eq_zero_iff_dvd]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isReduced_zmod {n : \u2115} : IsReduced (ZMod n) \u2194 Squarefree n \u2228 n = 0 := by\n  rw [\u2190 RingHom.ker_isRadical_iff_reduced_of_surjective       (ZMod.ringHom_surjective <| Int.castRingHom <| ZMod n)]\n  rw [ZMod.ker_intCastRingHom]\n  rw [\u2190 isRadical_iff_span_singleton]\n  rw [isRadical_iff_squarefree_or_zero]\n  rw [Int.squarefree_natCast]\n  rw [Nat.cast_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/ZMod.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 IsReduced (ZMod n) \u2194 Squarefree n \u2228 n = 0"}, {"line": "rw [\u2190 RingHom.ker_isRadical_iff_reduced_of_surjective       (ZMod.ringHom_surjective <| Int.castRingHom <| ZMod n)]", "tactic_state": "n : \u2115\n\u22a2 (RingHom.ker (Int.castRingHom (ZMod n))).IsRadical \u2194 Squarefree n \u2228 n = 0"}, {"line": "rw [ZMod.ker_intCastRingHom]", "tactic_state": "n : \u2115\n\u22a2 (Ideal.span {\u2191n}).IsRadical \u2194 Squarefree n \u2228 n = 0"}, {"line": "rw [\u2190 isRadical_iff_span_singleton]", "tactic_state": "n : \u2115\n\u22a2 IsRadical \u2191n \u2194 Squarefree n \u2228 n = 0"}, {"line": "rw [isRadical_iff_squarefree_or_zero]", "tactic_state": "n : \u2115\n\u22a2 Squarefree \u2191n \u2228 \u2191n = 0 \u2194 Squarefree n \u2228 n = 0"}, {"line": "rw [Int.squarefree_natCast]", "tactic_state": "n : \u2115\n\u22a2 Squarefree n \u2228 \u2191n = 0 \u2194 Squarefree n \u2228 n = 0"}, {"line": "rw [Nat.cast_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Basis.smulTower_repr (x ij) :\n    (b.smulTower c).repr x ij = b.repr (c.repr x ij.2) ij.1 := by\n  simp [smulTower]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraTower.lean", "context": {"open": ["Pointwise", "Finsupp"], "variables": ["(R S A B : Type*)", "[CommSemiring R] [CommSemiring S] [Semiring A] [Semiring B]", "[Algebra R S] [Algebra S A] [Algebra S B] [Algebra R A] [Algebra R B]", "[IsScalarTower R S A] [IsScalarTower R S B]", "[CommSemiring R] [CommSemiring A] [CommSemiring B]", "[Algebra R A] [Algebra A B] [Algebra R B] [IsScalarTower R A B]", "{R} {\u03b9 M : Type*} [CommSemiring R] [Semiring A] [AddCommMonoid M]", "[Algebra R A] [Module A M] [Module R M] [IsScalarTower R A M]", "(b : Basis \u03b9 R M) (h : Function.Bijective (algebraMap R A))", "{R S A}", "[Semiring R] [Semiring S] [AddCommMonoid A]", "[Module R S] [Module S A] [Module R A] [IsScalarTower R S A]", "(R)", "{R} {\u03b9 \u03b9' : Type*} (b : Basis \u03b9 R S) (c : Basis \u03b9' S A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\nA : Type u_3\ninst\u271d\u00b9\u2079 : CommSemiring R\ninst\u271d\u00b9\u2078 : CommSemiring S\ninst\u271d\u00b9\u2077 : Semiring A\ninst\u271d\u00b9\u2076 : Algebra R S\ninst\u271d\u00b9\u2075 : Algebra S A\ninst\u271d\u00b9\u2074 : Algebra R A\ninst\u271d\u00b9\u00b3 : IsScalarTower R S A\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : CommSemiring A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : CommSemiring R\ninst\u271d\u2078 : Semiring A\ninst\u271d\u2077 : Algebra R A\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Semiring S\ninst\u271d\u2074 : AddCommMonoid A\ninst\u271d\u00b3 : Module R S\ninst\u271d\u00b2 : Module S A\ninst\u271d\u00b9 : Module R A\ninst\u271d : IsScalarTower R S A\n\u03b9 : Type u_7\n\u03b9' : Type u_8\nb : Basis \u03b9 R S\nc : Basis \u03b9' S A\nx : A\nij : ?m.23505 S A _fvar.21121 _fvar.21235 b c x\n\u22a2 sorry = (b.repr ((c.repr x) sorry)) sorry"}, {"line": "simp [smulTower]", "tactic_state": "R : Type u_1\nS : Type u_2\nA : Type u_3\ninst\u271d\u00b9\u2079 : CommSemiring R\ninst\u271d\u00b9\u2078 : CommSemiring S\ninst\u271d\u00b9\u2077 : Semiring A\ninst\u271d\u00b9\u2076 : Algebra R S\ninst\u271d\u00b9\u2075 : Algebra S A\ninst\u271d\u00b9\u2074 : Algebra R A\ninst\u271d\u00b9\u00b3 : IsScalarTower R S A\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : CommSemiring A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : CommSemiring R\ninst\u271d\u2078 : Semiring A\ninst\u271d\u2077 : Algebra R A\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Semiring S\ninst\u271d\u2074 : AddCommMonoid A\ninst\u271d\u00b3 : Module R S\ninst\u271d\u00b2 : Module S A\ninst\u271d\u00b9 : Module R A\ninst\u271d : IsScalarTower R S A\n\u03b9 : Type u_7\n\u03b9' : Type u_8\nb : Basis \u03b9 R S\nc : Basis \u03b9' S A\nx : A\nij : ?m.23505 S A _fvar.21121 _fvar.21235 b c x\n\u22a2 sorry () = (b.repr ((c.repr x) (sorry ()))) (sorry ())"}]}
{"declaration": "theorem smeval_ascPochhammer_nat_cast {R} [NonAssocSemiring R] [Pow R \u2115] [NatPowAssoc R] (n k : \u2115) :\n    smeval (ascPochhammer \u2115 k) (n : R) = smeval (ascPochhammer \u2115 k) n := by\n  rw [smeval_at_natCast (ascPochhammer \u2115 k) n]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Binomial.lean", "context": {"open": ["Function Polynomial", "Polynomial", "Polynomial"], "variables": ["{R : Type*} [AddCommMonoid R] [Pow R \u2115] [BinomialRing R]", "{R : Type*} [NonAssocSemiring R] [Pow R \u2115] [NatPowAssoc R] [BinomialRing R]", "{R : Type*}", "[NonAssocRing R] [Pow R \u2115] [NatPowAssoc R]", "{R : Type*} [NonAssocRing R] [Pow R \u2115] [BinomialRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\ninst\u271d\u00b2 : NonAssocSemiring R\ninst\u271d\u00b9 : Pow R \u2115\ninst\u271d : NatPowAssoc R\nn k : \u2115\n\u22a2 (ascPochhammer \u2115 k).smeval \u2191n = \u2191((ascPochhammer \u2115 k).smeval n)"}, {"line": "rw [smeval_at_natCast (ascPochhammer \u2115 k) n]", "tactic_state": "R : Type u_5\ninst\u271d\u00b2 : NonAssocSemiring R\ninst\u271d\u00b9 : Pow R \u2115\ninst\u271d : NatPowAssoc R\nn k : \u2115\n\u22a2 NatPowAssoc R"}]}
{"declaration": "theorem choose_zero_ite (R) [NonAssocRing R] [Pow R \u2115] [NatPowAssoc R] [BinomialRing R]\n    (k : \u2115) : choose (0 : R) k = if k = 0 then 1 else 0 := by\n  split_ifs with hk\n  \u00b7 rw [hk, choose_zero_right]\n  \u00b7 rw [choose_zero_pos R <| Nat.pos_of_ne_zero hk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Binomial.lean", "context": {"open": ["Function Polynomial", "Polynomial", "Polynomial", "Polynomial"], "variables": ["{R : Type*} [AddCommMonoid R] [Pow R \u2115] [BinomialRing R]", "{R : Type*} [NonAssocSemiring R] [Pow R \u2115] [NatPowAssoc R] [BinomialRing R]", "{R : Type*}", "[NonAssocRing R] [Pow R \u2115] [NatPowAssoc R]", "{R : Type*} [NonAssocRing R] [Pow R \u2115] [BinomialRing R]", "{R : Type*}", "[NonAssocRing R] [Pow R \u2115] [BinomialRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_6\nchoose : x\u271d\nR : Type u_7\ninst\u271d\u00b3 : NonAssocRing R\ninst\u271d\u00b2 : Pow R \u2115\ninst\u271d\u00b9 : NatPowAssoc R\ninst\u271d : BinomialRing R\nk : \u2115\n\u22a2 sorry = if k = 0 then 1 else 0"}, {"line": "split_ifs with hk", "tactic_state": "case pos\nx\u271d : Sort u_6\nchoose : x\u271d\nR : Type u_7\ninst\u271d\u00b3 : NonAssocRing R\ninst\u271d\u00b2 : Pow R \u2115\ninst\u271d\u00b9 : NatPowAssoc R\ninst\u271d : BinomialRing R\nk : \u2115\nhk : k = 0\n\u22a2 sorry = 1\n---\ncase neg\nx\u271d : Sort u_6\nchoose : x\u271d\nR : Type u_7\ninst\u271d\u00b3 : NonAssocRing R\ninst\u271d\u00b2 : Pow R \u2115\ninst\u271d\u00b9 : NatPowAssoc R\ninst\u271d : BinomialRing R\nk : \u2115\nhk : \u00ack = 0\n\u22a2 sorry = 0"}, {"line": "\u00b7 rw [hk, choose_zero_right]", "tactic_state": "case neg\nx\u271d : Sort u_6\nchoose : x\u271d\nR : Type u_7\ninst\u271d\u00b3 : NonAssocRing R\ninst\u271d\u00b2 : Pow R \u2115\ninst\u271d\u00b9 : NatPowAssoc R\ninst\u271d : BinomialRing R\nk : \u2115\nhk : \u00ack = 0\n\u22a2 sorry = 0"}, {"line": "\u00b7 rw [choose_zero_pos R <| Nat.pos_of_ne_zero hk]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem first_of_chain_isUnit {q : Associates M} {n : \u2115} {c : Fin (n + 1) \u2192 Associates M}\n    (h\u2081 : StrictMono c) (h\u2082 : \u2200 {r}, r \u2264 q \u2194 \u2203 i, r = c i) : IsUnit (c 0) := by\n  obtain \u27e8i, hr\u27e9 := h\u2082.mp Associates.one_le\n  rw [Associates.isUnit_iff_eq_one]\n  rw [\u2190 Associates.le_one_iff]\n  rw [hr]\n  exact h\u2081.monotone (Fin.zero_le i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/ChainOfDivisors.lean", "context": {"open": ["UniqueFactorizationMonoid Irreducible Associates"], "variables": ["{M : Type*} [CancelCommMonoidWithZero M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d : CancelCommMonoidWithZero M\nq : Associates M\nn : \u2115\nc : Fin (n + 1) \u2192 Associates M\nh\u2081 : StrictMono c\nh\u2082 : \u2200 {r : Associates M}, r \u2264 q \u2194 \u2203 i, r = c i\n\u22a2 IsUnit (c 0)"}, {"line": "obtain \u27e8i, hr\u27e9 := h\u2082.mp Associates.one_le", "tactic_state": "case intro\nM : Type u_1\ninst\u271d : CancelCommMonoidWithZero M\nq : Associates M\nn : \u2115\nc : Fin (n + 1) \u2192 Associates M\nh\u2081 : StrictMono c\nh\u2082 : \u2200 {r : Associates M}, r \u2264 q \u2194 \u2203 i, r = c i\ni : Fin (n + 1)\nhr : 1 = c i\n\u22a2 IsUnit (c 0)"}, {"line": "rw [Associates.isUnit_iff_eq_one]", "tactic_state": "case intro\nM : Type u_1\ninst\u271d : CancelCommMonoidWithZero M\nq : Associates M\nn : \u2115\nc : Fin (n + 1) \u2192 Associates M\nh\u2081 : StrictMono c\nh\u2082 : \u2200 {r : Associates M}, r \u2264 q \u2194 \u2203 i, r = c i\ni : Fin (n + 1)\nhr : 1 = c i\n\u22a2 c 0 = 1"}, {"line": "rw [\u2190 Associates.le_one_iff]", "tactic_state": "case intro\nM : Type u_1\ninst\u271d : CancelCommMonoidWithZero M\nq : Associates M\nn : \u2115\nc : Fin (n + 1) \u2192 Associates M\nh\u2081 : StrictMono c\nh\u2082 : \u2200 {r : Associates M}, r \u2264 q \u2194 \u2203 i, r = c i\ni : Fin (n + 1)\nhr : 1 = c i\n\u22a2 c 0 \u2264 1"}, {"line": "rw [hr]", "tactic_state": "case intro\nM : Type u_1\ninst\u271d : CancelCommMonoidWithZero M\nq : Associates M\nn : \u2115\nc : Fin (n + 1) \u2192 Associates M\nh\u2081 : StrictMono c\nh\u2082 : \u2200 {r : Associates M}, r \u2264 q \u2194 \u2203 i, r = c i\ni : Fin (n + 1)\nhr : 1 = c i\n\u22a2 c 0 \u2264 c i"}, {"line": "exact h\u2081.monotone (Fin.zero_le i)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem element_of_chain_eq_pow_second_of_chain {q r : Associates M} {n : \u2115} (hn : n \u2260 0)\n    {c : Fin (n + 1) \u2192 Associates M} (h\u2081 : StrictMono c) (h\u2082 : \u2200 {r}, r \u2264 q \u2194 \u2203 i, r = c i)\n    (hr : r \u2223 q) (hq : q \u2260 0) : \u2203 i : Fin (n + 1), r = c 1 ^ (i : \u2115) := by\n  classical\n    let i := Multiset.card (normalizedFactors r)\n    have hi : normalizedFactors r = Multiset.replicate i (c 1) := by\n      apply Multiset.eq_replicate_of_mem\n      intro b hb\n      refine\n        eq_second_of_chain_of_prime_dvd hn h\u2081 (@fun r' => h\u2082) (prime_of_normalized_factor b hb) hr\n          (dvd_of_mem_normalizedFactors hb)\n    have H : r = c 1 ^ i := by\n      have := UniqueFactorizationMonoid.prod_normalizedFactors (ne_zero_of_dvd_ne_zero hq hr)\n      rw [associated_iff_eq] at this\n      rw [hi] at this\n      rw [Multiset.prod_replicate] at this\n      rw [this]\n    refine \u27e8\u27e8i, ?_\u27e9, H\u27e9\n    have : (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : \u2115)).card = i + 1 := by\n      conv_rhs => rw [\u2190 Finset.card_fin (i + 1)]\n      cases n\n      \u00b7 contradiction\n      rw [Finset.card_image_iff]\n      refine Set.injOn_of_injective (fun m m' h => Fin.ext ?_)\n      refine\n        pow_injective_of_not_isUnit (element_of_chain_not_isUnit_of_index_ne_zero (by simp) h\u2081) ?_ h\n      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h\u2081 (@h\u2082) hq)\n    suffices H' : \u2200 r \u2208 Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : \u2115), r \u2264 q by\n      simp only [\u2190 Nat.succ_le_iff]\n      simp only [Nat.succ_eq_add_one]\n      simp only [\u2190 this]\n      apply card_subset_divisors_le_length_of_chain (@h\u2082) H'\n    simp only [Finset.mem_image]\n    rintro r \u27e8a, _, rfl\u27e9\n    refine dvd_trans ?_ hr\n    use c 1 ^ (i - (a : \u2115))\n    rw [pow_mul_pow_sub (c 1)]\n    \u00b7 exact H\n    \u00b7 exact Nat.succ_le_succ_iff.mp a.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/ChainOfDivisors.lean", "context": {"open": ["UniqueFactorizationMonoid Irreducible Associates"], "variables": ["{M : Type*} [CancelCommMonoidWithZero M]", "[UniqueFactorizationMonoid M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero M\ninst\u271d : UniqueFactorizationMonoid M\nq r : Associates M\nn : \u2115\nhn : n \u2260 0\nc : Fin (n + 1) \u2192 Associates M\nh\u2081 : StrictMono c\nh\u2082 : \u2200 {r : Associates M}, r \u2264 q \u2194 \u2203 i, r = c i\nhr : r \u2223 q\nhq : q \u2260 0\n\u22a2 \u2203 i, r = c 1 ^ \u2191i"}, {"line": "classical\n    let i := Multiset.card (normalizedFactors r)\n    have hi : normalizedFactors r = Multiset.replicate i (c 1) := by\n      apply Multiset.eq_replicate_of_mem\n      intro b hb\n      refine\n        eq_second_of_chain_of_prime_dvd hn h\u2081 (@fun r' => h\u2082) (prime_of_normalized_factor b hb) hr\n          (dvd_of_mem_normalizedFactors hb)\n    have H : r = c 1 ^ i := by\n      have := UniqueFactorizationMonoid.prod_normalizedFactors (ne_zero_of_dvd_ne_zero hq hr)\n      rw [associated_iff_eq] at this\n      rw [hi] at this\n      rw [Multiset.prod_replicate] at this\n      rw [this]\n    refine \u27e8\u27e8i, ?_\u27e9, H\u27e9\n    have : (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : \u2115)).card = i + 1 := by\n      conv_rhs => rw [\u2190 Finset.card_fin (i + 1)]\n      cases n\n      \u00b7 contradiction\n      rw [Finset.card_image_iff]\n      refine Set.injOn_of_injective (fun m m' h => Fin.ext ?_)\n      refine\n        pow_injective_of_not_isUnit (element_of_chain_not_isUnit_of_index_ne_zero (by simp) h\u2081) ?_ h\n      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h\u2081 (@h\u2082) hq)\n    suffices H' : \u2200 r \u2208 Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : \u2115), r \u2264 q by\n      simp only [\u2190 Nat.succ_le_iff]\n      simp only [Nat.succ_eq_add_one]\n      simp only [\u2190 this]\n      apply card_subset_divisors_le_length_of_chain (@h\u2082) H'\n    simp only [Finset.mem_image]\n    rintro r \u27e8a, _, rfl\u27e9\n    refine dvd_trans ?_ hr\n    use c 1 ^ (i - (a : \u2115))\n    rw [pow_mul_pow_sub (c 1)]\n    \u00b7 exact H\n    \u00b7 exact Nat.succ_le_succ_iff.mp a.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ClassGroup.Quot_mk_eq_mk (I : (FractionalIdeal R\u2070 (FractionRing R))\u02e3) :\n    Quot.mk _ I = ClassGroup.mk I := by\n  rw [ClassGroup.mk_def]\n  rw [canonicalEquiv_self]\n  rw [RingEquiv.coe_monoidHom_refl]\n  rw [Units.map_id]\n  rw [MonoidHom.id_apply]\n  rw [QuotientGroup.mk'_apply]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/ClassGroup.lean", "context": {"open": ["scoped nonZeroDivisors", "IsLocalization IsFractionRing FractionalIdeal Units"], "variables": ["{R K : Type*} [CommRing R] [Field K] [Algebra R K] [IsFractionRing R K]", "(R K)", "{R K}", "(R)", "[IsDomain R]", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nI : (FractionalIdeal (nonZeroDivisors R) (FractionRing R))\u02e3\n\u22a2 Quot.mk (\u21d1(QuotientGroup.leftRel (toPrincipalIdeal R (FractionRing R)).range)) I = mk I"}, {"line": "rw [ClassGroup.mk_def]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nI : (FractionalIdeal (nonZeroDivisors R) (FractionRing R))\u02e3\n\u22a2 Quot.mk (\u21d1(QuotientGroup.leftRel (toPrincipalIdeal R (FractionRing R)).range)) I =\n    (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n      ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) (FractionRing R) (FractionRing R))) I)"}, {"line": "rw [canonicalEquiv_self]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nI : (FractionalIdeal (nonZeroDivisors R) (FractionRing R))\u02e3\n\u22a2 Quot.mk (\u21d1(QuotientGroup.leftRel (toPrincipalIdeal R (FractionRing R)).range)) I =\n    (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n      ((Units.map \u2191(RingEquiv.refl (FractionalIdeal (nonZeroDivisors R) (FractionRing R)))) I)"}, {"line": "rw [RingEquiv.coe_monoidHom_refl]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nI : (FractionalIdeal (nonZeroDivisors R) (FractionRing R))\u02e3\n\u22a2 Quot.mk (\u21d1(QuotientGroup.leftRel (toPrincipalIdeal R (FractionRing R)).range)) I =\n    (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n      ((Units.map (MonoidHom.id (FractionalIdeal (nonZeroDivisors R) (FractionRing R)))) I)"}, {"line": "rw [Units.map_id]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nI : (FractionalIdeal (nonZeroDivisors R) (FractionRing R))\u02e3\n\u22a2 Quot.mk (\u21d1(QuotientGroup.leftRel (toPrincipalIdeal R (FractionRing R)).range)) I =\n    (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n      ((MonoidHom.id (FractionalIdeal (nonZeroDivisors R) (FractionRing R))\u02e3) I)"}, {"line": "rw [MonoidHom.id_apply]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nI : (FractionalIdeal (nonZeroDivisors R) (FractionRing R))\u02e3\n\u22a2 Quot.mk (\u21d1(QuotientGroup.leftRel (toPrincipalIdeal R (FractionRing R)).range)) I =\n    (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range) I"}, {"line": "rw [QuotientGroup.mk'_apply]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nI : (FractionalIdeal (nonZeroDivisors R) (FractionRing R))\u02e3\n\u22a2 Quot.mk (\u21d1(QuotientGroup.leftRel (toPrincipalIdeal R (FractionRing R)).range)) I = \u2191I"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ClassGroup.mk_eq_mk {I J : (FractionalIdeal R\u2070 <| FractionRing R)\u02e3} :\n    ClassGroup.mk I = ClassGroup.mk J \u2194\n      \u2203 x : (FractionRing R)\u02e3, I * toPrincipalIdeal R (FractionRing R) x = J := by\n  rw [mk_def]\n  rw [mk_def]\n  rw [QuotientGroup.mk'_eq_mk']\n  simp [RingEquiv.coe_monoidHom_refl, MonoidHom.mem_range, -toPrincipalIdeal_eq_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/ClassGroup.lean", "context": {"open": ["scoped nonZeroDivisors", "IsLocalization IsFractionRing FractionalIdeal Units"], "variables": ["{R K : Type*} [CommRing R] [Field K] [Algebra R K] [IsFractionRing R K]", "(R K)", "{R K}", "(R)", "[IsDomain R]", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nI J : (FractionalIdeal (nonZeroDivisors R) (FractionRing R))\u02e3\n\u22a2 mk I = mk J \u2194 \u2203 x, I * (toPrincipalIdeal R (FractionRing R)) x = J"}, {"line": "rw [mk_def]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nI J : (FractionalIdeal (nonZeroDivisors R) (FractionRing R))\u02e3\n\u22a2 (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n        ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) (FractionRing R) (FractionRing R))) I) =\n      mk J \u2194\n    \u2203 x, I * (toPrincipalIdeal R (FractionRing R)) x = J"}, {"line": "rw [mk_def]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nI J : (FractionalIdeal (nonZeroDivisors R) (FractionRing R))\u02e3\n\u22a2 (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n        ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) (FractionRing R) (FractionRing R))) I) =\n      (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n        ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) (FractionRing R) (FractionRing R))) J) \u2194\n    \u2203 x, I * (toPrincipalIdeal R (FractionRing R)) x = J"}, {"line": "rw [QuotientGroup.mk'_eq_mk']", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nI J : (FractionalIdeal (nonZeroDivisors R) (FractionRing R))\u02e3\n\u22a2 (\u2203 z \u2208 (toPrincipalIdeal R (FractionRing R)).range,\n      (Units.map \u2191(canonicalEquiv (nonZeroDivisors R) (FractionRing R) (FractionRing R))) I * z =\n        (Units.map \u2191(canonicalEquiv (nonZeroDivisors R) (FractionRing R) (FractionRing R))) J) \u2194\n    \u2203 x, I * (toPrincipalIdeal R (FractionRing R)) x = J"}, {"line": "simp [RingEquiv.coe_monoidHom_refl, MonoidHom.mem_range, -toPrincipalIdeal_eq_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ClassGroup.equiv_mk (K' : Type*) [Field K'] [Algebra R K'] [IsFractionRing R K']\n    (I : (FractionalIdeal R\u2070 K)\u02e3) :\n    ClassGroup.equiv K' (ClassGroup.mk I) =\n      QuotientGroup.mk' _ (Units.mapEquiv (\u2191(FractionalIdeal.canonicalEquiv R\u2070 K K')) I) := by\n  -- `simp` can't apply `ClassGroup.mk_def` and `rw` can't unfold `ClassGroup`.\n  rw [ClassGroup.equiv]\n  rw [ClassGroup.mk_def]\n  simp only [ClassGroup]\n  simp only [QuotientGroup.congr_mk']\n  congr\n  rw [\u2190 Units.eq_iff]\n  rw [Units.coe_mapEquiv]\n  rw [Units.coe_mapEquiv]\n  rw [Units.coe_map]\n  exact FractionalIdeal.canonicalEquiv_canonicalEquiv _ _ _ _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/ClassGroup.lean", "context": {"open": ["scoped nonZeroDivisors", "IsLocalization IsFractionRing FractionalIdeal Units"], "variables": ["{R K : Type*} [CommRing R] [Field K] [Algebra R K] [IsFractionRing R K]", "(R K)", "{R K}", "(R)", "[IsDomain R]", "{R}", "(K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nK : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsFractionRing R K\ninst\u271d\u00b3 : IsDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : (FractionalIdeal (nonZeroDivisors R) K)\u02e3\n\u22a2 (equiv K') (mk I) =\n    (QuotientGroup.mk' (toPrincipalIdeal R K').range) ((Units.mapEquiv \u2191(canonicalEquiv (nonZeroDivisors R) K K')) I)"}, {"line": "rw [ClassGroup.equiv]", "tactic_state": "R : Type u_1\nK : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsFractionRing R K\ninst\u271d\u00b3 : IsDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : (FractionalIdeal (nonZeroDivisors R) K)\u02e3\n\u22a2 (QuotientGroup.congr (toPrincipalIdeal R (FractionRing R)).range (toPrincipalIdeal R K').range\n        (Units.mapEquiv (canonicalEquiv (nonZeroDivisors R) (FractionRing R) K').toMulEquiv) \u22ef)\n      (mk I) =\n    (QuotientGroup.mk' (toPrincipalIdeal R K').range) ((Units.mapEquiv \u2191(canonicalEquiv (nonZeroDivisors R) K K')) I)"}, {"line": "rw [ClassGroup.mk_def]", "tactic_state": "R : Type u_1\nK : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsFractionRing R K\ninst\u271d\u00b3 : IsDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : (FractionalIdeal (nonZeroDivisors R) K)\u02e3\n\u22a2 (QuotientGroup.congr (toPrincipalIdeal R (FractionRing R)).range (toPrincipalIdeal R K').range\n        (Units.mapEquiv (canonicalEquiv (nonZeroDivisors R) (FractionRing R) K').toMulEquiv) \u22ef)\n      ((QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n        ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K (FractionRing R))) I)) =\n    (QuotientGroup.mk' (toPrincipalIdeal R K').range) ((Units.mapEquiv \u2191(canonicalEquiv (nonZeroDivisors R) K K')) I)"}, {"line": "simp only [ClassGroup]", "tactic_state": "R : Type u_1\nK : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsFractionRing R K\ninst\u271d\u00b3 : IsDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : (FractionalIdeal (nonZeroDivisors R) K)\u02e3\n\u22a2 (QuotientGroup.congr (toPrincipalIdeal R (FractionRing R)).range (toPrincipalIdeal R K').range\n        (Units.mapEquiv (canonicalEquiv (nonZeroDivisors R) (FractionRing R) K').toMulEquiv) \u22ef)\n      ((QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n        ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K (FractionRing R))) I)) =\n    (QuotientGroup.mk' (toPrincipalIdeal R K').range) ((Units.mapEquiv \u2191(canonicalEquiv (nonZeroDivisors R) K K')) I)"}, {"line": "simp only [QuotientGroup.congr_mk']", "tactic_state": "R : Type u_1\nK : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsFractionRing R K\ninst\u271d\u00b3 : IsDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : (FractionalIdeal (nonZeroDivisors R) K)\u02e3\n\u22a2 (QuotientGroup.mk' (toPrincipalIdeal R K').range)\n      ((Units.mapEquiv (canonicalEquiv (nonZeroDivisors R) (FractionRing R) K').toMulEquiv)\n        ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K (FractionRing R))) I)) =\n    (QuotientGroup.mk' (toPrincipalIdeal R K').range) ((Units.mapEquiv \u2191(canonicalEquiv (nonZeroDivisors R) K K')) I)"}, {"line": "congr", "tactic_state": "case h.e_6.h\nR : Type u_1\nK : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsFractionRing R K\ninst\u271d\u00b3 : IsDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : (FractionalIdeal (nonZeroDivisors R) K)\u02e3\n\u22a2 (Units.mapEquiv (canonicalEquiv (nonZeroDivisors R) (FractionRing R) K').toMulEquiv)\n      ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K (FractionRing R))) I) =\n    (Units.mapEquiv \u2191(canonicalEquiv (nonZeroDivisors R) K K')) I"}, {"line": "rw [\u2190 Units.eq_iff]", "tactic_state": "case h.e_6.h\nR : Type u_1\nK : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsFractionRing R K\ninst\u271d\u00b3 : IsDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : (FractionalIdeal (nonZeroDivisors R) K)\u02e3\n\u22a2 \u2191((Units.mapEquiv (canonicalEquiv (nonZeroDivisors R) (FractionRing R) K').toMulEquiv)\n        ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K (FractionRing R))) I)) =\n    \u2191((Units.mapEquiv \u2191(canonicalEquiv (nonZeroDivisors R) K K')) I)"}, {"line": "rw [Units.coe_mapEquiv]", "tactic_state": "case h.e_6.h\nR : Type u_1\nK : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsFractionRing R K\ninst\u271d\u00b3 : IsDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : (FractionalIdeal (nonZeroDivisors R) K)\u02e3\n\u22a2 (canonicalEquiv (nonZeroDivisors R) (FractionRing R) K').toMulEquiv\n      \u2191((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K (FractionRing R))) I) =\n    \u2191((Units.mapEquiv \u2191(canonicalEquiv (nonZeroDivisors R) K K')) I)"}, {"line": "rw [Units.coe_mapEquiv]", "tactic_state": "case h.e_6.h\nR : Type u_1\nK : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsFractionRing R K\ninst\u271d\u00b3 : IsDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : (FractionalIdeal (nonZeroDivisors R) K)\u02e3\n\u22a2 (canonicalEquiv (nonZeroDivisors R) (FractionRing R) K').toMulEquiv\n      \u2191((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K (FractionRing R))) I) =\n    \u2191(canonicalEquiv (nonZeroDivisors R) K K') \u2191I"}, {"line": "rw [Units.coe_map]", "tactic_state": "case h.e_6.h\nR : Type u_1\nK : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsFractionRing R K\ninst\u271d\u00b3 : IsDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : (FractionalIdeal (nonZeroDivisors R) K)\u02e3\n\u22a2 (canonicalEquiv (nonZeroDivisors R) (FractionRing R) K').toMulEquiv\n      (\u2191(canonicalEquiv (nonZeroDivisors R) K (FractionRing R)) \u2191I) =\n    \u2191(canonicalEquiv (nonZeroDivisors R) K K') \u2191I"}, {"line": "exact FractionalIdeal.canonicalEquiv_canonicalEquiv _ _ _ _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ClassGroup.mk_canonicalEquiv (K' : Type*) [Field K'] [Algebra R K'] [IsFractionRing R K']\n    (I : (FractionalIdeal R\u2070 K)\u02e3) :\n    ClassGroup.mk (Units.map (\u2191(canonicalEquiv R\u2070 K K')) I : (FractionalIdeal R\u2070 K')\u02e3) =\n      ClassGroup.mk I := by\n  rw [ClassGroup.mk_def]\n  rw [ClassGroup.mk_def]\n  rw [\u2190 MonoidHom.comp_apply (Units.map _)]\n  rw [\u2190 Units.map_comp]\n  rw [\u2190 RingEquiv.coe_monoidHom_trans]\n  rw [FractionalIdeal.canonicalEquiv_trans_canonicalEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/ClassGroup.lean", "context": {"open": ["scoped nonZeroDivisors", "IsLocalization IsFractionRing FractionalIdeal Units"], "variables": ["{R K : Type*} [CommRing R] [Field K] [Algebra R K] [IsFractionRing R K]", "(R K)", "{R K}", "(R)", "[IsDomain R]", "{R}", "(K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nK : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsFractionRing R K\ninst\u271d\u00b3 : IsDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : (FractionalIdeal (nonZeroDivisors R) K)\u02e3\n\u22a2 mk ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K K')) I) = mk I"}, {"line": "rw [ClassGroup.mk_def]", "tactic_state": "R : Type u_1\nK : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsFractionRing R K\ninst\u271d\u00b3 : IsDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : (FractionalIdeal (nonZeroDivisors R) K)\u02e3\n\u22a2 (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n      ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K' (FractionRing R)))\n        ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K K')) I)) =\n    mk I"}, {"line": "rw [ClassGroup.mk_def]", "tactic_state": "R : Type u_1\nK : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsFractionRing R K\ninst\u271d\u00b3 : IsDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : (FractionalIdeal (nonZeroDivisors R) K)\u02e3\n\u22a2 (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n      ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K' (FractionRing R)))\n        ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K K')) I)) =\n    (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n      ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K (FractionRing R))) I)"}, {"line": "rw [\u2190 MonoidHom.comp_apply (Units.map _)]", "tactic_state": "R : Type u_1\nK : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsFractionRing R K\ninst\u271d\u00b3 : IsDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : (FractionalIdeal (nonZeroDivisors R) K)\u02e3\n\u22a2 (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n      (((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K' (FractionRing R))).comp\n          (Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K K')))\n        I) =\n    (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n      ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K (FractionRing R))) I)"}, {"line": "rw [\u2190 Units.map_comp]", "tactic_state": "R : Type u_1\nK : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsFractionRing R K\ninst\u271d\u00b3 : IsDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : (FractionalIdeal (nonZeroDivisors R) K)\u02e3\n\u22a2 (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n      ((Units.map\n          ((\u2191(canonicalEquiv (nonZeroDivisors R) K' (FractionRing R))).comp \u2191(canonicalEquiv (nonZeroDivisors R) K K')))\n        I) =\n    (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n      ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K (FractionRing R))) I)"}, {"line": "rw [\u2190 RingEquiv.coe_monoidHom_trans]", "tactic_state": "R : Type u_1\nK : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsFractionRing R K\ninst\u271d\u00b3 : IsDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : (FractionalIdeal (nonZeroDivisors R) K)\u02e3\n\u22a2 (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n      ((Units.map\n          \u2191((canonicalEquiv (nonZeroDivisors R) K K').trans (canonicalEquiv (nonZeroDivisors R) K' (FractionRing R))))\n        I) =\n    (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range)\n      ((Units.map \u2191(canonicalEquiv (nonZeroDivisors R) K (FractionRing R))) I)"}, {"line": "rw [FractionalIdeal.canonicalEquiv_trans_canonicalEquiv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem FractionalIdeal.canonicalEquiv_mk0 [IsDedekindDomain R] (K' : Type*) [Field K']\n    [Algebra R K'] [IsFractionRing R K'] (I : (Ideal R)\u2070) :\n    FractionalIdeal.canonicalEquiv R\u2070 K K' (FractionalIdeal.mk0 K I) =\n    FractionalIdeal.mk0 K' I := by\n  simp only [FractionalIdeal.coe_mk0]\n  simp only [FractionalIdeal.canonicalEquiv_coeIdeal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/ClassGroup.lean", "context": {"open": ["scoped nonZeroDivisors", "IsLocalization IsFractionRing FractionalIdeal Units"], "variables": ["{R K : Type*} [CommRing R] [Field K] [Algebra R K] [IsFractionRing R K]", "(R K)", "{R K}", "(R)", "[IsDomain R]", "{R}", "(K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nK : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field K\ninst\u271d\u2076 : Algebra R K\ninst\u271d\u2075 : IsFractionRing R K\ninst\u271d\u2074 : IsDomain R\ninst\u271d\u00b3 : IsDedekindDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : \u21a5(nonZeroDivisors (Ideal R))\n\u22a2 (canonicalEquiv (nonZeroDivisors R) K K') \u2191((mk0 K) I) = \u2191((mk0 K') I)"}, {"line": "simp only [FractionalIdeal.coe_mk0]", "tactic_state": "R : Type u_1\nK : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field K\ninst\u271d\u2076 : Algebra R K\ninst\u271d\u2075 : IsFractionRing R K\ninst\u271d\u2074 : IsDomain R\ninst\u271d\u00b3 : IsDedekindDomain R\nK' : Type u_3\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsFractionRing R K'\nI : \u21a5(nonZeroDivisors (Ideal R))\n\u22a2 (canonicalEquiv (nonZeroDivisors R) K K') \u2191\u2191I = \u2191\u2191I"}, {"line": "simp only [FractionalIdeal.canonicalEquiv_coeIdeal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ClassGroup.equiv_mk0 [IsDedekindDomain R] (I : (Ideal R)\u2070) :\n    ClassGroup.equiv K (ClassGroup.mk0 I) =\n      QuotientGroup.mk' (toPrincipalIdeal R K).range (FractionalIdeal.mk0 K I) := by\n  rw [ClassGroup.mk0]\n  rw [MonoidHom.comp_apply]\n  rw [ClassGroup.equiv_mk]\n  congr 1\n  simp [\u2190 Units.eq_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/ClassGroup.lean", "context": {"open": ["scoped nonZeroDivisors", "IsLocalization IsFractionRing FractionalIdeal Units"], "variables": ["{R K : Type*} [CommRing R] [Field K] [Algebra R K] [IsFractionRing R K]", "(R K)", "{R K}", "(R)", "[IsDomain R]", "{R}", "(K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nK : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDedekindDomain R\nI : \u21a5(nonZeroDivisors (Ideal R))\n\u22a2 (equiv K) (mk0 I) = (QuotientGroup.mk' (toPrincipalIdeal R K).range) ((FractionalIdeal.mk0 K) I)"}, {"line": "rw [ClassGroup.mk0]", "tactic_state": "R : Type u_1\nK : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDedekindDomain R\nI : \u21a5(nonZeroDivisors (Ideal R))\n\u22a2 (equiv K) ((mk.comp (FractionalIdeal.mk0 (FractionRing R))) I) =\n    (QuotientGroup.mk' (toPrincipalIdeal R K).range) ((FractionalIdeal.mk0 K) I)"}, {"line": "rw [MonoidHom.comp_apply]", "tactic_state": "R : Type u_1\nK : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDedekindDomain R\nI : \u21a5(nonZeroDivisors (Ideal R))\n\u22a2 (equiv K) (mk ((FractionalIdeal.mk0 (FractionRing R)) I)) =\n    (QuotientGroup.mk' (toPrincipalIdeal R K).range) ((FractionalIdeal.mk0 K) I)"}, {"line": "rw [ClassGroup.equiv_mk]", "tactic_state": "R : Type u_1\nK : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDedekindDomain R\nI : \u21a5(nonZeroDivisors (Ideal R))\n\u22a2 (QuotientGroup.mk' (toPrincipalIdeal R K).range)\n      ((Units.mapEquiv \u2191(canonicalEquiv (nonZeroDivisors R) (FractionRing R) K))\n        ((FractionalIdeal.mk0 (FractionRing R)) I)) =\n    (QuotientGroup.mk' (toPrincipalIdeal R K).range) ((FractionalIdeal.mk0 K) I)"}, {"line": "congr 1", "tactic_state": "case h.e_6.h\nR : Type u_1\nK : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDedekindDomain R\nI : \u21a5(nonZeroDivisors (Ideal R))\n\u22a2 (Units.mapEquiv \u2191(canonicalEquiv (nonZeroDivisors R) (FractionRing R) K)) ((FractionalIdeal.mk0 (FractionRing R)) I) =\n    (FractionalIdeal.mk0 K) I"}, {"line": "simp [\u2190 Units.eq_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ClassGroup.mk0_eq_mk0_inv_iff [IsDedekindDomain R] {I J : (Ideal R)\u2070} :\n    ClassGroup.mk0 I = (ClassGroup.mk0 J)\u207b\u00b9 \u2194\n      \u2203 x \u2260 (0 : R), I * J = Ideal.span {x} := by\n  rw [eq_inv_iff_mul_eq_one]\n  rw [\u2190 map_mul]\n  rw [ClassGroup.mk0_eq_one_iff]\n  rw [Submodule.isPrincipal_iff]\n  rw [Submonoid.coe_mul]\n  refine \u27e8fun \u27e8a, ha\u27e9 \u21a6 \u27e8a, ?_, ha\u27e9, fun \u27e8a, _, ha\u27e9 \u21a6 \u27e8a, ha\u27e9\u27e9\n  by_contra!\n  rw [this] at ha\n  rw [Submodule.span_zero_singleton] at ha\n  exact nonZeroDivisors.coe_ne_zero _ <| J.prop _ ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/ClassGroup.lean", "context": {"open": ["scoped nonZeroDivisors", "IsLocalization IsFractionRing FractionalIdeal Units"], "variables": ["{R K : Type*} [CommRing R] [Field K] [Algebra R K] [IsFractionRing R K]", "(R K)", "{R K}", "(R)", "[IsDomain R]", "{R}", "(K)", "{K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDedekindDomain R\nI J : \u21a5(nonZeroDivisors (Ideal R))\n\u22a2 mk0 I = (mk0 J)\u207b\u00b9 \u2194 \u2203 x, x \u2260 0 \u2227 \u2191I * \u2191J = Ideal.span {x}"}, {"line": "rw [eq_inv_iff_mul_eq_one]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDedekindDomain R\nI J : \u21a5(nonZeroDivisors (Ideal R))\n\u22a2 mk0 I * mk0 J = 1 \u2194 \u2203 x, x \u2260 0 \u2227 \u2191I * \u2191J = Ideal.span {x}"}, {"line": "rw [\u2190 map_mul]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDedekindDomain R\nI J : \u21a5(nonZeroDivisors (Ideal R))\n\u22a2 mk0 (I * J) = 1 \u2194 \u2203 x, x \u2260 0 \u2227 \u2191I * \u2191J = Ideal.span {x}"}, {"line": "rw [ClassGroup.mk0_eq_one_iff]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDedekindDomain R\nI J : \u21a5(nonZeroDivisors (Ideal R))\n\u22a2 Submodule.IsPrincipal \u2191(I * J) \u2194 \u2203 x, x \u2260 0 \u2227 \u2191I * \u2191J = Ideal.span {x}"}, {"line": "rw [Submodule.isPrincipal_iff]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDedekindDomain R\nI J : \u21a5(nonZeroDivisors (Ideal R))\n\u22a2 (\u2203 a, \u2191(I * J) = Submodule.span R {a}) \u2194 \u2203 x, x \u2260 0 \u2227 \u2191I * \u2191J = Ideal.span {x}"}, {"line": "rw [Submonoid.coe_mul]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDedekindDomain R\nI J : \u21a5(nonZeroDivisors (Ideal R))\n\u22a2 (\u2203 a, \u2191I * \u2191J = Submodule.span R {a}) \u2194 \u2203 x, x \u2260 0 \u2227 \u2191I * \u2191J = Ideal.span {x}"}, {"line": "refine \u27e8fun \u27e8a, ha\u27e9 \u21a6 \u27e8a, ?_, ha\u27e9, fun \u27e8a, _, ha\u27e9 \u21a6 \u27e8a, ha\u27e9\u27e9", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDedekindDomain R\nI J : \u21a5(nonZeroDivisors (Ideal R))\nx\u271d : \u2203 a, \u2191I * \u2191J = Submodule.span R {a}\na : R\nha : \u2191I * \u2191J = Submodule.span R {a}\n\u22a2 a \u2260 0"}, {"line": "by_contra!", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDedekindDomain R\nI J : \u21a5(nonZeroDivisors (Ideal R))\nx\u271d : \u2203 a, \u2191I * \u2191J = Submodule.span R {a}\na : R\nha : \u2191I * \u2191J = Submodule.span R {a}\nthis : a = 0\n\u22a2 False"}, {"line": "rw [this] at ha", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDedekindDomain R\nI J : \u21a5(nonZeroDivisors (Ideal R))\nx\u271d : \u2203 a, \u2191I * \u2191J = Submodule.span R {a}\na : R\nha : \u2191I * \u2191J = Submodule.span R {0}\nthis : a = 0\n\u22a2 False"}, {"line": "rw [Submodule.span_zero_singleton] at ha", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDedekindDomain R\nI J : \u21a5(nonZeroDivisors (Ideal R))\nx\u271d : \u2203 a, \u2191I * \u2191J = Submodule.span R {a}\na : R\nha : \u2191I * \u2191J = \u22a5\nthis : a = 0\n\u22a2 False"}, {"line": "exact nonZeroDivisors.coe_ne_zero _ <| J.prop _ ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma compLocalizationAwayAlgHom_X_inl : compLocalizationAwayAlgHom T g P (X (Sum.inl ())) =\n      IsLocalization.Away.invSelf ((Ideal.Quotient.mk (P.ker ^ 2)) (P.\u03c3 g)) := by\n  simp [compLocalizationAwayAlgHom]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/CotangentLocalizationAway.lean", "context": {"open": ["TensorProduct MvPolynomial"], "variables": ["{R S T : Type*} [CommRing R] [CommRing S] [Algebra R S]", "(g : S) [IsLocalization.Away g T] (P : Generators R S)", "(T) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\ncompLocalizationAwayAlgHom : x\u271d\n\u22a2 sorry = IsLocalization.Away.invSelf ((Ideal.Quotient.mk (sorry ^ 2)) sorry)"}, {"line": "simp [compLocalizationAwayAlgHom]", "tactic_state": "x\u271d : Sort u_4\ncompLocalizationAwayAlgHom : x\u271d\n\u22a2 sorry () = IsLocalization.Away.invSelf ((Ideal.Quotient.mk (sorry () ^ 2)) (sorry ()))"}]}
{"declaration": "lemma Cotangent.mk_eq_zero_iff {P : Extension R S} (x : P.ker) :\n    Cotangent.mk x = 0 \u2194 x.val \u2208 P.ker ^ 2 := by\n  simp [Cotangent.ext_iff, Ideal.toCotangent_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Extension.lean", "context": {"open": ["TensorProduct MvPolynomial"], "variables": ["(R : Type u) (S : Type v) [CommRing R] [CommRing S] [Algebra R S]", "{R S}", "(P : Extension.{w} R S)", "(R S) in", "(M : Submonoid S) {S' : Type*} [CommRing S'] [Algebra S S'] [IsLocalization M S']", "[Algebra R S'] [IsScalarTower R S S']", "{T} [CommRing T] [Algebra R T] [Algebra S T] [IsScalarTower R S T]", "{R' S'} [CommRing R'] [CommRing S'] [Algebra R' S'] (P' : Extension R' S')", "{R'' S''} [CommRing R''] [CommRing S''] [Algebra R'' S''] (P'' : Extension R'' S'')", "[Algebra R R'] [Algebra R' R''] [Algebra R R'']", "[Algebra S S'] [Algebra S' S''] [Algebra S S'']", "{P P'}", "(P P')", "{P P' P''}", "[IsScalarTower R R' R''] [IsScalarTower S S' S''] in", "{P}", "(x y : P.Cotangent) (w z : P.ker.Cotangent)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Extension : ?m.27790\nR : Type u\nS : Type v\ninst\u271d\u00b9\u2078 : CommRing R\ninst\u271d\u00b9\u2077 : CommRing S\ninst\u271d\u00b9\u2076 : Algebra R S\nP\u271d : sorry\nT : Type ?u.27963\ninst\u271d\u00b9\u2075 : CommRing T\ninst\u271d\u00b9\u2074 : Algebra R T\ninst\u271d\u00b9\u00b3 : Algebra S T\ninst\u271d\u00b9\u00b2 : IsScalarTower R S T\nR' : Type ?u.28439\nS' : Type ?u.28442\ninst\u271d\u00b9\u00b9 : CommRing R'\ninst\u271d\u00b9\u2070 : CommRing S'\ninst\u271d\u2079 : Algebra R' S'\nP' : sorry\nR'' : Type ?u.28650\nS'' : Type ?u.28653\ninst\u271d\u2078 : CommRing R''\ninst\u271d\u2077 : CommRing S''\ninst\u271d\u2076 : Algebra R'' S''\nP'' : sorry\ninst\u271d\u2075 : Algebra R R'\ninst\u271d\u2074 : Algebra R' R''\ninst\u271d\u00b3 : Algebra R R''\ninst\u271d\u00b2 : Algebra S S'\ninst\u271d\u00b9 : Algebra S' S''\ninst\u271d : Algebra S S''\nx\u271d : sorry\ny : sorry\nw : sorry\nz : sorry\nP : sorry\nx : sorry\n\u22a2 sorry = 0 \u2194 sorry \u2208 sorry ^ 2"}, {"line": "simp [Cotangent.ext_iff, Ideal.toCotangent_eq_zero]", "tactic_state": "Extension : ?m.27790\nR : Type u\nS : Type v\ninst\u271d\u00b9\u2078 : CommRing R\ninst\u271d\u00b9\u2077 : CommRing S\ninst\u271d\u00b9\u2076 : Algebra R S\nP\u271d : sorry\nT : Type ?u.27963\ninst\u271d\u00b9\u2075 : CommRing T\ninst\u271d\u00b9\u2074 : Algebra R T\ninst\u271d\u00b9\u00b3 : Algebra S T\ninst\u271d\u00b9\u00b2 : IsScalarTower R S T\nR' : Type ?u.28439\nS' : Type ?u.28442\ninst\u271d\u00b9\u00b9 : CommRing R'\ninst\u271d\u00b9\u2070 : CommRing S'\ninst\u271d\u2079 : Algebra R' S'\nP' : sorry\nR'' : Type ?u.28650\nS'' : Type ?u.28653\ninst\u271d\u2078 : CommRing R''\ninst\u271d\u2077 : CommRing S''\ninst\u271d\u2076 : Algebra R'' S''\nP'' : sorry\ninst\u271d\u2075 : Algebra R R'\ninst\u271d\u2074 : Algebra R' R''\ninst\u271d\u00b3 : Algebra R R''\ninst\u271d\u00b2 : Algebra S S'\ninst\u271d\u00b9 : Algebra S' S''\ninst\u271d : Algebra S S''\nx\u271d : sorry\ny : sorry\nw : sorry\nz : sorry\nP : sorry\nx : sorry\n\u22a2 sorry () = 0 \u2194 sorry () \u2208 sorry () ^ 2"}]}
{"declaration": "theorem of_surjective (f : A \u2192+* B) (hf : Surjective f) : f.FiniteType := by\n  rw [\u2190 f.comp_id]\n  exact (id A).comp_surjective hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/FiniteType.lean", "context": {"open": ["Function (Surjective)", "Polynomial", "Submodule Set"], "variables": ["(R : Type uR) (S : Type uS) (A : Type uA) (B : Type uB) (M : Type uM) (N : Type uN)", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]", "{R S M N}", "[CommSemiring R] [CommSemiring S] [Semiring A] [Semiring B]", "[Algebra R S] [Algebra R A] [Algebra R B]", "[AddCommMonoid M] [Module R M]", "[AddCommMonoid N] [Module R N]", "{R S A B}", "{A B C : Type*} [CommRing A] [CommRing B] [CommRing C]", "(A) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nhf : Surjective \u21d1f\n\u22a2 f.FiniteType"}, {"line": "rw [\u2190 f.comp_id]", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\nf : A \u2192+* B\nhf : Surjective \u21d1f\n\u22a2 (f.comp (RingHom.id A)).FiniteType"}, {"line": "exact (id A).comp_surjective hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finiteType_iff_group_fg {G : Type*} [AddGroup G] [CommRing R] [Nontrivial R] :\n    FiniteType R R[G] \u2194 AddGroup.FG G := by\n  simpa [AddGroup.fg_iff_addMonoid_fg] using finiteType_iff_fg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/FiniteType.lean", "context": {"open": ["Function (Surjective)", "Polynomial", "Submodule Set", "Algebra AddSubmonoid Submodule"], "variables": ["(R : Type uR) (S : Type uS) (A : Type uA) (B : Type uB) (M : Type uM) (N : Type uN)", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]", "{R S M N}", "[CommSemiring R] [CommSemiring S] [Semiring A] [Semiring B]", "[Algebra R S] [Algebra R A] [Algebra R B]", "[AddCommMonoid M] [Module R M]", "[AddCommMonoid N] [Module R N]", "{R S A B}", "{A B C : Type*} [CommRing A] [CommRing B] [CommRing C]", "(A) in", "{R A B C : Type*} [CommRing R]", "[CommRing A] [CommRing B] [CommRing C]", "[Algebra R A] [Algebra R B] [Algebra R C]", "(R A)", "{R A}", "{R : Type*} {M : Type*}", "[CommSemiring R] [AddMonoid M]", "[CommRing R] [AddMonoid M]", "[AddMonoid M]", "(R M)", "{R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : CommRing R\nG : Type u_6\ninst\u271d\u00b2 : AddGroup G\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Nontrivial R\n\u22a2 sorry \u2194 AddGroup.FG G"}, {"line": "simpa [AddGroup.fg_iff_addMonoid_fg] using finiteType_iff_fg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finiteType_iff_group_fg {G : Type*} [Group G] [CommRing R] [Nontrivial R] :\n    FiniteType R (MonoidAlgebra R G) \u2194 Group.FG G := by\n  simpa [Group.fg_iff_monoid_fg] using finiteType_iff_fg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/FiniteType.lean", "context": {"open": ["Function (Surjective)", "Polynomial", "Submodule Set", "Algebra AddSubmonoid Submodule", "Algebra Submonoid Submodule"], "variables": ["(R : Type uR) (S : Type uS) (A : Type uA) (B : Type uB) (M : Type uM) (N : Type uN)", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]", "{R S M N}", "[CommSemiring R] [CommSemiring S] [Semiring A] [Semiring B]", "[Algebra R S] [Algebra R A] [Algebra R B]", "[AddCommMonoid M] [Module R M]", "[AddCommMonoid N] [Module R N]", "{R S A B}", "{A B C : Type*} [CommRing A] [CommRing B] [CommRing C]", "(A) in", "{R A B C : Type*} [CommRing R]", "[CommRing A] [CommRing B] [CommRing C]", "[Algebra R A] [Algebra R B] [Algebra R C]", "(R A)", "{R A}", "{R : Type*} {M : Type*}", "[CommSemiring R] [AddMonoid M]", "[CommRing R] [AddMonoid M]", "[AddMonoid M]", "(R M)", "{R M}", "[CommSemiring R] [Monoid M]", "[CommRing R] [Monoid M]", "[Monoid M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : CommRing R\nG : Type u_6\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Nontrivial R\n\u22a2 FiniteType R (MonoidAlgebra R G) \u2194 Group.FG G"}, {"line": "simpa [Group.fg_iff_monoid_fg] using finiteType_iff_fg", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mk_apply (x) : Ideal.Quotient.mk Q (\u03c6 x) = x ^ Nat.card (R \u29f8 Q.under R) := by\n  rw [\u2190 map_pow]\n  rw [Ideal.Quotient.eq]\n  exact H x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Frobenius.lean", "context": {"open": [], "variables": ["{R S : Type*} [CommRing R] [CommRing S] [Algebra R S]", "{\u03c6 \u03c8 : S \u2192\u2090[R] S} {Q : Ideal S} (H : \u03c6.IsArithFrobAt Q)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\n\u03c6 : S \u2192\u2090[R] S\nQ : Ideal S\nx : S\n\u22a2 (Ideal.Quotient.mk Q) (\u03c6 x) = (Ideal.Quotient.mk Q) x ^ Nat.card (R \u29f8 Ideal.under R Q)"}, {"line": "rw [\u2190 map_pow]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\n\u03c6 : S \u2192\u2090[R] S\nQ : Ideal S\nx : S\n\u22a2 (Ideal.Quotient.mk Q) (\u03c6 x) = (Ideal.Quotient.mk Q) (x ^ Nat.card (R \u29f8 Ideal.under R Q))\n---\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\n\u03c6 : S \u2192\u2090[R] S\nQ : Ideal S\nx : S\n\u22a2 Monoid S\n---\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\n\u03c6 : S \u2192\u2090[R] S\nQ : Ideal S\nx : S\n\u22a2 MonoidHomClass (S \u2192+* S \u29f8 Q) S (S \u29f8 Q)"}, {"line": "rw [Ideal.Quotient.eq]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\n\u03c6 : S \u2192\u2090[R] S\nQ : Ideal S\nx : S\n\u22a2 \u03c6 x - x ^ Nat.card (R \u29f8 Ideal.under R Q) \u2208 Q\n---\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\n\u03c6 : S \u2192\u2090[R] S\nQ : Ideal S\nx : S\n\u22a2 Monoid S\n---\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\n\u03c6 : S \u2192\u2090[R] S\nQ : Ideal S\nx : S\n\u22a2 Monoid S\n---\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\n\u03c6 : S \u2192\u2090[R] S\nQ : Ideal S\nx : S\n\u22a2 MonoidHomClass (S \u2192+* S \u29f8 Q) S (S \u29f8 Q)"}, {"line": "exact H x", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\n\u03c6 : S \u2192\u2090[R] S\nQ : Ideal S\nx : S\n\u22a2 Monoid S\n---\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\n\u03c6 : S \u2192\u2090[R] S\nQ : Ideal S\nx : S\n\u22a2 Monoid S\n---\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\n\u03c6 : S \u2192\u2090[R] S\nQ : Ideal S\nx : S\n\u22a2 MonoidHomClass (S \u2192+* S \u29f8 Q) S (S \u29f8 Q)"}]}
{"declaration": "lemma finite_quotient : _root_.Finite (R \u29f8 Q.under R) := by\n  rw [\u2190 not_infinite_iff_finite]\n  intro h\n  obtain rfl : Q = \u22a4 := by simpa [Nat.card_eq_zero_of_infinite, \u2190 Ideal.eq_top_iff_one] using H 0\n  simp only [Ideal.comap_top] at h\n  exact not_finite (R \u29f8 (\u22a4 : Ideal R))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Frobenius.lean", "context": {"open": [], "variables": ["{R S : Type*} [CommRing R] [CommRing S] [Algebra R S]", "{\u03c6 \u03c8 : S \u2192\u2090[R] S} {Q : Ideal S} (H : \u03c6.IsArithFrobAt Q)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nQ : Ideal S\n\u22a2 Finite (R \u29f8 Ideal.under R Q)"}, {"line": "rw [\u2190 not_infinite_iff_finite]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nQ : Ideal S\n\u22a2 \u00acInfinite (R \u29f8 Ideal.under R Q)"}, {"line": "intro h", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nQ : Ideal S\nh : Infinite (R \u29f8 Ideal.under R Q)\n\u22a2 False"}, {"line": "obtain rfl : Q = \u22a4 := by simpa [Nat.card_eq_zero_of_infinite, \u2190 Ideal.eq_top_iff_one] using H 0", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nh : Infinite (R \u29f8 Ideal.under R \u22a4)\n\u22a2 False"}, {"line": "simp only [Ideal.comap_top] at h", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nh : Infinite (R \u29f8 \u22a4)\n\u22a2 False"}, {"line": "exact not_finite (R \u29f8 (\u22a4 : Ideal R))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_comap : Q \u2264 Q.comap \u03c6 := by\n  intro x hx\n  simp_all only [Ideal.mem_comap, \u2190 Ideal.Quotient.eq_zero_iff_mem (I := Q), H.mk_apply,\n    zero_pow_eq, ite_eq_right_iff, H.card_pos.ne', false_implies]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Frobenius.lean", "context": {"open": [], "variables": ["{R S : Type*} [CommRing R] [CommRing S] [Algebra R S]", "{\u03c6 \u03c8 : S \u2192\u2090[R] S} {Q : Ideal S} (H : \u03c6.IsArithFrobAt Q)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\n\u03c6 : S \u2192\u2090[R] S\nQ : Ideal S\n\u22a2 Q \u2264 Ideal.comap \u03c6 Q"}, {"line": "intro x hx", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\n\u03c6 : S \u2192\u2090[R] S\nQ : Ideal S\nx : S\nhx : x \u2208 Q\n\u22a2 x \u2208 Ideal.comap \u03c6 Q"}, {"line": "simp_all only [Ideal.mem_comap, \u2190 Ideal.Quotient.eq_zero_iff_mem (I := Q), H.mk_apply,\n    zero_pow_eq, ite_eq_right_iff, H.card_pos.ne', false_implies]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\n\u03c6 : S \u2192\u2090[R] S\nQ : Ideal S\nx : S\nhx : x \u2208 Q\n\u22a2 \u03c6 x \u2208 Q"}]}
{"declaration": "theorem eval\u2090_mk\u2090 (n : \u2115) (x : AdicCauchySequence I R) :\n    eval\u2090 I n (mk\u2090 I x) = Ideal.Quotient.mk (I ^ n) (x.val n) := by\n  simp [mk\u2090]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AdicCompletion/Algebra.lean", "context": {"open": ["Submodule"], "variables": ["{R S : Type*} [CommRing R] [CommRing S] (I : Ideal R)", "{M : Type*} [AddCommGroup M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nI : Ideal R\nx\u271d\u00b9 : Sort u_4\nAdicCauchySequence : x\u271d\u00b9\nx\u271d : Sort u_5\neval\u2090 : x\u271d\nn : \u2115\nx : sorry\n\u22a2 sorry = (Ideal.Quotient.mk (I ^ n)) sorry"}, {"line": "simp [mk\u2090]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nI : Ideal R\nx\u271d\u00b9 : Sort u_4\nAdicCauchySequence : x\u271d\u00b9\nx\u271d : Sort u_5\neval\u2090 : x\u271d\nn : \u2115\nx : sorry\n\u22a2 sorry () = (Ideal.Quotient.mk (I ^ n)) (sorry ())"}]}
{"declaration": "lemma val_sum_apply {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 AdicCompletion I M) (n : \u2115) :\n    (\u2211 i \u2208 s, f i).val n = \u2211 i \u2208 s, (f i).val n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AdicCompletion/Basic.lean", "context": {"open": ["Submodule"], "variables": ["{R S T : Type*} [CommRing R] (I : Ideal R)", "(M : Type*) [AddCommGroup M] [Module R M]", "{N : Type*} [AddCommGroup N] [Module R N]", "{I M}", "(I M)", "{M} in", "{I M}", "{I M}", "(I M)", "{M} [h : IsHausdorff I N]", "{I M}", "(I M)", "{I M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nI : Ideal R\nM : Type u_4\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u03b9 : Type u_6\ns : Finset \u03b9\nf : \u03b9 \u2192 AdicCompletion I M\nn : \u2115\n\u22a2 \u2191(\u2211 i \u2208 s, f i) n = \u2211 i \u2208 s, \u2191(f i) n"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Algebra.restrictScalars_adjoin_of_algEquiv\n    {F E L L' : Type*} [CommSemiring F] [CommSemiring L] [CommSemiring L'] [Semiring E]\n    [Algebra F L] [Algebra L E] [Algebra F L'] [Algebra L' E] [Algebra F E]\n    [IsScalarTower F L E] [IsScalarTower F L' E] (i : L \u2243\u2090[F] L')\n    (hi : algebraMap L E = (algebraMap L' E) \u2218 i) (S : Set E) :\n    (Algebra.adjoin L S).restrictScalars F = (Algebra.adjoin L' S).restrictScalars F := by\n  apply_fun Subalgebra.toSubsemiring using fun K K' h \u21a6 by rwa [SetLike.ext'_iff] at h \u22a2\n  change Subsemiring.closure _ = Subsemiring.closure _\n  rw [hi]\n  rw [Set.range_comp]\n  rw [EquivLike.range_eq_univ]\n  rw [Set.image_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Adjoin/Basic.lean", "context": {"open": ["Pointwise", "Submodule Subsemiring", "Algebra Subalgebra"], "variables": ["{R : Type uR} {S : Type uS} {A : Type uA} {B : Type uB}", "[CommSemiring R] [CommSemiring S] [Semiring A] [Semiring B]", "[Algebra R S] [Algebra R A] [Algebra S A] [Algebra R B] [IsScalarTower R S A]", "{s t : Set A}", "(R A)", "{A} (s)", "(A) in", "[CommSemiring R] [CommSemiring A]", "[Algebra R A] {s t : Set A}", "(R s t)", "{R}", "(F E : Type*) {K : Type*} [CommSemiring E] [Semiring K] [SMul F E] [Algebra E K]", "[CommSemiring F] [Algebra F K] [IsScalarTower F E K] (L : Subalgebra F K) {F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_4\nE : Type u_5\nL : Type u_6\nL' : Type u_7\ninst\u271d\u00b9\u2070 : CommSemiring F\ninst\u271d\u2079 : CommSemiring L\ninst\u271d\u2078 : CommSemiring L'\ninst\u271d\u2077 : Semiring E\ninst\u271d\u2076 : Algebra F L\ninst\u271d\u2075 : Algebra L E\ninst\u271d\u2074 : Algebra F L'\ninst\u271d\u00b3 : Algebra L' E\ninst\u271d\u00b2 : Algebra F E\ninst\u271d\u00b9 : IsScalarTower F L E\ninst\u271d : IsScalarTower F L' E\ni : L \u2243\u2090[F] L'\nhi : \u21d1(algebraMap L E) = \u21d1(algebraMap L' E) \u2218 \u21d1i\nS : Set E\n\u22a2 Subalgebra.restrictScalars F (adjoin L S) = Subalgebra.restrictScalars F (adjoin L' S)"}, {"line": "apply_fun Subalgebra.toSubsemiring using fun K K' h \u21a6 by rwa [SetLike.ext'_iff] at h \u22a2", "tactic_state": "F : Type u_4\nE : Type u_5\nL : Type u_6\nL' : Type u_7\ninst\u271d\u00b9\u2070 : CommSemiring F\ninst\u271d\u2079 : CommSemiring L\ninst\u271d\u2078 : CommSemiring L'\ninst\u271d\u2077 : Semiring E\ninst\u271d\u2076 : Algebra F L\ninst\u271d\u2075 : Algebra L E\ninst\u271d\u2074 : Algebra F L'\ninst\u271d\u00b3 : Algebra L' E\ninst\u271d\u00b2 : Algebra F E\ninst\u271d\u00b9 : IsScalarTower F L E\ninst\u271d : IsScalarTower F L' E\ni : L \u2243\u2090[F] L'\nhi : \u21d1(algebraMap L E) = \u21d1(algebraMap L' E) \u2218 \u21d1i\nS : Set E\n\u22a2 (Subalgebra.restrictScalars F (adjoin L S)).toSubsemiring = (Subalgebra.restrictScalars F (adjoin L' S)).toSubsemiring"}, {"line": "change Subsemiring.closure _ = Subsemiring.closure _", "tactic_state": "F : Type u_4\nE : Type u_5\nL : Type u_6\nL' : Type u_7\ninst\u271d\u00b9\u2070 : CommSemiring F\ninst\u271d\u2079 : CommSemiring L\ninst\u271d\u2078 : CommSemiring L'\ninst\u271d\u2077 : Semiring E\ninst\u271d\u2076 : Algebra F L\ninst\u271d\u2075 : Algebra L E\ninst\u271d\u2074 : Algebra F L'\ninst\u271d\u00b3 : Algebra L' E\ninst\u271d\u00b2 : Algebra F E\ninst\u271d\u00b9 : IsScalarTower F L E\ninst\u271d : IsScalarTower F L' E\ni : L \u2243\u2090[F] L'\nhi : \u21d1(algebraMap L E) = \u21d1(algebraMap L' E) \u2218 \u21d1i\nS : Set E\n\u22a2 Subsemiring.closure (Set.range \u21d1(algebraMap L E) \u222a S) = Subsemiring.closure (Set.range \u21d1(algebraMap L' E) \u222a S)"}, {"line": "rw [hi]", "tactic_state": "F : Type u_4\nE : Type u_5\nL : Type u_6\nL' : Type u_7\ninst\u271d\u00b9\u2070 : CommSemiring F\ninst\u271d\u2079 : CommSemiring L\ninst\u271d\u2078 : CommSemiring L'\ninst\u271d\u2077 : Semiring E\ninst\u271d\u2076 : Algebra F L\ninst\u271d\u2075 : Algebra L E\ninst\u271d\u2074 : Algebra F L'\ninst\u271d\u00b3 : Algebra L' E\ninst\u271d\u00b2 : Algebra F E\ninst\u271d\u00b9 : IsScalarTower F L E\ninst\u271d : IsScalarTower F L' E\ni : L \u2243\u2090[F] L'\nhi : \u21d1(algebraMap L E) = \u21d1(algebraMap L' E) \u2218 \u21d1i\nS : Set E\n\u22a2 Subsemiring.closure (Set.range (\u21d1(algebraMap L' E) \u2218 \u21d1i) \u222a S) = Subsemiring.closure (Set.range \u21d1(algebraMap L' E) \u222a S)"}, {"line": "rw [Set.range_comp]", "tactic_state": "F : Type u_4\nE : Type u_5\nL : Type u_6\nL' : Type u_7\ninst\u271d\u00b9\u2070 : CommSemiring F\ninst\u271d\u2079 : CommSemiring L\ninst\u271d\u2078 : CommSemiring L'\ninst\u271d\u2077 : Semiring E\ninst\u271d\u2076 : Algebra F L\ninst\u271d\u2075 : Algebra L E\ninst\u271d\u2074 : Algebra F L'\ninst\u271d\u00b3 : Algebra L' E\ninst\u271d\u00b2 : Algebra F E\ninst\u271d\u00b9 : IsScalarTower F L E\ninst\u271d : IsScalarTower F L' E\ni : L \u2243\u2090[F] L'\nhi : \u21d1(algebraMap L E) = \u21d1(algebraMap L' E) \u2218 \u21d1i\nS : Set E\n\u22a2 Subsemiring.closure (\u21d1(algebraMap L' E) '' Set.range \u21d1i \u222a S) = Subsemiring.closure (Set.range \u21d1(algebraMap L' E) \u222a S)"}, {"line": "rw [EquivLike.range_eq_univ]", "tactic_state": "F : Type u_4\nE : Type u_5\nL : Type u_6\nL' : Type u_7\ninst\u271d\u00b9\u2070 : CommSemiring F\ninst\u271d\u2079 : CommSemiring L\ninst\u271d\u2078 : CommSemiring L'\ninst\u271d\u2077 : Semiring E\ninst\u271d\u2076 : Algebra F L\ninst\u271d\u2075 : Algebra L E\ninst\u271d\u2074 : Algebra F L'\ninst\u271d\u00b3 : Algebra L' E\ninst\u271d\u00b2 : Algebra F E\ninst\u271d\u00b9 : IsScalarTower F L E\ninst\u271d : IsScalarTower F L' E\ni : L \u2243\u2090[F] L'\nhi : \u21d1(algebraMap L E) = \u21d1(algebraMap L' E) \u2218 \u21d1i\nS : Set E\n\u22a2 Subsemiring.closure (\u21d1(algebraMap L' E) '' Set.univ \u222a S) = Subsemiring.closure (Set.range \u21d1(algebraMap L' E) \u222a S)"}, {"line": "rw [Set.image_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Algebra.adjoin_singleton_eq_range_aeval (x : A) :\n    Algebra.adjoin R {x} = (Polynomial.aeval x).range := by\n  rw [\u2190 Algebra.map_top]\n  rw [\u2190 adjoin_X]\n  rw [AlgHom.map_adjoin]\n  rw [Set.image_singleton]\n  rw [aeval_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Adjoin/Polynomial.lean", "context": {"open": ["Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {A : Type z} {A' B : Type*} {a b : R} {n : \u2115}", "[CommSemiring R] [Semiring A] [CommSemiring A'] [Semiring B]", "[Algebra R A] [Algebra R B]", "{p q : R[X]} (x : A)", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type z\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nx : A\n\u22a2 Algebra.adjoin R {x} = (aeval x).range"}, {"line": "rw [\u2190 Algebra.map_top]", "tactic_state": "R : Type u\nA : Type z\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nx : A\n\u22a2 Algebra.adjoin R {x} = Subalgebra.map (aeval x) \u22a4"}, {"line": "rw [\u2190 adjoin_X]", "tactic_state": "R : Type u\nA : Type z\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nx : A\n\u22a2 Algebra.adjoin R {x} = Subalgebra.map (aeval x) (Algebra.adjoin R {X})"}, {"line": "rw [AlgHom.map_adjoin]", "tactic_state": "R : Type u\nA : Type z\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nx : A\n\u22a2 Algebra.adjoin R {x} = Algebra.adjoin R (\u21d1(aeval x) '' {X})"}, {"line": "rw [Set.image_singleton]", "tactic_state": "R : Type u\nA : Type z\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nx : A\n\u22a2 Algebra.adjoin R {x} = Algebra.adjoin R {(aeval x) X}"}, {"line": "rw [aeval_X]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aeval_mem_adjoin_singleton :\n    aeval x p \u2208 Algebra.adjoin R {x} := by\n  simpa only [Algebra.adjoin_singleton_eq_range_aeval] using Set.mem_range_self p\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Adjoin/Polynomial.lean", "context": {"open": ["Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {A : Type z} {A' B : Type*} {a b : R} {n : \u2115}", "[CommSemiring R] [Semiring A] [CommSemiring A'] [Semiring B]", "[Algebra R A] [Algebra R B]", "{p q : R[X]} (x : A)", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type z\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\np : Polynomial R\nx : A\n\u22a2 (aeval x) p \u2208 Algebra.adjoin R {x}"}, {"line": "simpa only [Algebra.adjoin_singleton_eq_range_aeval] using Set.mem_range_self p", "tactic_state": "No Goals!"}]}
{"declaration": "theorem minpoly_add_algebraMap_splits [Algebra K L] {x : L} (r : K)\n    (g : (minpoly K x).Splits (algebraMap K L)) :\n    (minpoly K (x + algebraMap K L r)).Splits (algebraMap K L) := by\n  simpa [minpoly.add_algebraMap] using g.comp_X_sub_C r\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Adjoin/Field.lean", "context": {"open": ["Polynomial", "AdjoinRoot in", "Finset"], "variables": ["(F : Type*) [Field F]", "{R K L M : Type*} [CommRing R] [Field K] [Field L] [CommRing M] [Algebra R K]", "[Algebra R L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_3\nL : Type u_4\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nx : L\nr : K\ng : Splits (algebraMap K L) (minpoly K x)\n\u22a2 Splits (algebraMap K L) (minpoly K (x + (algebraMap K L) r))"}, {"line": "simpa [minpoly.add_algebraMap] using g.comp_X_sub_C r", "tactic_state": "No Goals!"}]}
{"declaration": "theorem minpoly_sub_algebraMap_splits [Algebra K L] {x : L} (r : K)\n    (g : (minpoly K x).Splits (algebraMap K L)) :\n    (minpoly K (x - algebraMap K L r)).Splits (algebraMap K L) := by\n  simpa only [sub_eq_add_neg,map_neg] using minpoly_add_algebraMap_splits (-r) g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Adjoin/Field.lean", "context": {"open": ["Polynomial", "AdjoinRoot in", "Finset"], "variables": ["(F : Type*) [Field F]", "{R K L M : Type*} [CommRing R] [Field K] [Field L] [CommRing M] [Algebra R K]", "[Algebra R L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_3\nL : Type u_4\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nx : L\nr : K\ng : Splits (algebraMap K L) (minpoly K x)\n\u22a2 Splits (algebraMap K L) (minpoly K (x - (algebraMap K L) r))"}, {"line": "simpa only [sub_eq_add_neg,map_neg] using minpoly_add_algebraMap_splits (-r) g", "tactic_state": "No Goals!"}]}
{"declaration": "theorem minpoly_algebraMap_add_splits [Algebra K L] {x : L} (r : K)\n    (g : (minpoly K x).Splits (algebraMap K L)) :\n    (minpoly K (algebraMap K L r + x)).Splits (algebraMap K L) := by\n  simpa only [add_comm] using minpoly_add_algebraMap_splits r g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Adjoin/Field.lean", "context": {"open": ["Polynomial", "AdjoinRoot in", "Finset"], "variables": ["(F : Type*) [Field F]", "{R K L M : Type*} [CommRing R] [Field K] [Field L] [CommRing M] [Algebra R K]", "[Algebra R L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_3\nL : Type u_4\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nx : L\nr : K\ng : Splits (algebraMap K L) (minpoly K x)\n\u22a2 Splits (algebraMap K L) (minpoly K ((algebraMap K L) r + x))"}, {"line": "simpa only [add_comm] using minpoly_add_algebraMap_splits r g", "tactic_state": "No Goals!"}]}
{"declaration": "theorem minpoly_algebraMap_sub_splits [Algebra K L] {x : L} (r : K)\n    (g : (minpoly K x).Splits (algebraMap K L)) :\n    (minpoly K (algebraMap K L r - x)).Splits (algebraMap K L) := by\n  simpa only [neg_sub] using minpoly_neg_splits (minpoly_sub_algebraMap_splits r g)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Adjoin/Field.lean", "context": {"open": ["Polynomial", "AdjoinRoot in", "Finset"], "variables": ["(F : Type*) [Field F]", "{R K L M : Type*} [CommRing R] [Field K] [Field L] [CommRing M] [Algebra R K]", "[Algebra R L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_3\nL : Type u_4\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nx : L\nr : K\ng : Splits (algebraMap K L) (minpoly K x)\n\u22a2 Splits (algebraMap K L) (minpoly K ((algebraMap K L) r - x))"}, {"line": "simpa only [neg_sub] using minpoly_neg_splits (minpoly_sub_algebraMap_splits r g)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardinalMk_le_sigma_polynomial :\n    #L \u2264 #(\u03a3 p : R[X], { x : L // x \u2208 p.aroots L }) := by\n  simpa only [lift_id] using lift_cardinalMk_le_sigma_polynomial R L\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/Cardinality.lean", "context": {"open": ["scoped Cardinal Polynomial", "Cardinal"], "variables": ["(R : Type u) [CommRing R] (L : Type v) [CommRing L] [IsDomain L] [Algebra R L]", "[NoZeroSMulDivisors R L] [Algebra.IsAlgebraic R L]", "(L : Type u) [CommRing L] [IsDomain L] [Algebra R L]", "[NoZeroSMulDivisors R L] [Algebra.IsAlgebraic R L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2075 : CommRing R\nL : Type u\ninst\u271d\u2074 : CommRing L\ninst\u271d\u00b3 : IsDomain L\ninst\u271d\u00b2 : Algebra R L\ninst\u271d\u00b9 : NoZeroSMulDivisors R L\ninst\u271d : Algebra.IsAlgebraic R L\n\u22a2 mk L \u2264 mk ((p : Polynomial R) \u00d7 { x // x \u2208 p.aroots L })"}, {"line": "simpa only [lift_id] using lift_cardinalMk_le_sigma_polynomial R L", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardinalMk_le_max : #L \u2264 max #R \u2135\u2080 := by\n  simpa only [lift_id] using lift_cardinalMk_le_max R L\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/Cardinality.lean", "context": {"open": ["scoped Cardinal Polynomial", "Cardinal"], "variables": ["(R : Type u) [CommRing R] (L : Type v) [CommRing L] [IsDomain L] [Algebra R L]", "[NoZeroSMulDivisors R L] [Algebra.IsAlgebraic R L]", "(L : Type u) [CommRing L] [IsDomain L] [Algebra R L]", "[NoZeroSMulDivisors R L] [Algebra.IsAlgebraic R L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2075 : CommRing R\nL : Type u\ninst\u271d\u2074 : CommRing L\ninst\u271d\u00b3 : IsDomain L\ninst\u271d\u00b2 : Algebra R L\ninst\u271d\u00b9 : NoZeroSMulDivisors R L\ninst\u271d : Algebra.IsAlgebraic R L\n\u22a2 mk L \u2264 max (mk R) aleph0"}, {"line": "simpa only [lift_id] using lift_cardinalMk_le_max R L", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Algebra.transcendental_iff_not_isAlgebraic :\n    Algebra.Transcendental R A \u2194 \u00ac Algebra.IsAlgebraic R A := by\n  simp [isAlgebraic_def, transcendental_def, Transcendental]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/Defs.lean", "context": {"open": ["Polynomial"], "variables": ["(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]", "{R}", "(R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\n\u22a2 Algebra.Transcendental R A \u2194 \u00acAlgebra.IsAlgebraic R A"}, {"line": "simp [isAlgebraic_def, transcendental_def, Transcendental]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Algebra.isAlgebraic_iff : Algebra.IsAlgebraic R A \u2194 (\u22a4 : Subalgebra R A).IsAlgebraic := by\n  delta Subalgebra.IsAlgebraic\n  simp only [Algebra.isAlgebraic_def]\n  simp only [Algebra.mem_top]\n  simp only [forall_prop_of_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/Defs.lean", "context": {"open": ["Polynomial"], "variables": ["(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]", "{R}", "(R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\n\u22a2 Algebra.IsAlgebraic R A \u2194 \u22a4.IsAlgebraic"}, {"line": "delta Subalgebra.IsAlgebraic", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\n\u22a2 Algebra.IsAlgebraic R A \u2194 \u2200 x \u2208 \u22a4, IsAlgebraic R x"}, {"line": "simp only [Algebra.isAlgebraic_def]", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\n\u22a2 (\u2200 (x : A), IsAlgebraic R x) \u2194 \u2200 x \u2208 \u22a4, IsAlgebraic R x"}, {"line": "simp only [Algebra.mem_top]", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\n\u22a2 (\u2200 (x : A), IsAlgebraic R x) \u2194 \u2200 (x : A), True \u2192 IsAlgebraic R x"}, {"line": "simp only [forall_prop_of_true]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Algebra.isAlgebraic_iff_isIntegral :\n    Algebra.IsAlgebraic K A \u2194 Algebra.IsIntegral K A := by\n  rw [Algebra.isAlgebraic_def]\n  rw [Algebra.isIntegral_def]\n  rw [forall_congr' fun _ \u21a6 isAlgebraic_iff_isIntegral]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/Integral.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type u} {S : Type*} {A : Type v} [CommRing R]", "[CommRing S] [Ring A] [Algebra R A] [Algebra R S] [Algebra S A]", "[IsScalarTower R S A]", "{K : Type u} {A : Type v} [Field K] [Ring A] [Algebra K A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\nA : Type v\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra K A\n\u22a2 Algebra.IsAlgebraic K A \u2194 Algebra.IsIntegral K A"}, {"line": "rw [Algebra.isAlgebraic_def]", "tactic_state": "K : Type u\nA : Type v\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra K A\n\u22a2 (\u2200 (x : A), IsAlgebraic K x) \u2194 Algebra.IsIntegral K A"}, {"line": "rw [Algebra.isIntegral_def]", "tactic_state": "K : Type u\nA : Type v\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra K A\n\u22a2 (\u2200 (x : A), IsAlgebraic K x) \u2194 \u2200 (x : A), IsIntegral K x"}, {"line": "rw [forall_congr' fun _ \u21a6 isAlgebraic_iff_isIntegral]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transcendental_aeval_iff {r : A} {f : K[X]} :\n    Transcendental K (Polynomial.aeval r f) \u2194 Transcendental K r \u2227 Transcendental K f := by\n  refine \u27e8fun h \u21a6 \u27e8?_, h.of_aeval\u27e9, fun \u27e8h1, h2\u27e9 \u21a6 h1.aeval_of_transcendental h2\u27e9\n  rw [Transcendental] at h \u22a2\n  contrapose! h\n  rw [isAlgebraic_iff_isIntegral] at h \u22a2\n  exact .of_mem_of_fg _ h.fg_adjoin_singleton _ (aeval_mem_adjoin_singleton _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/Integral.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type u} {S : Type*} {A : Type v} [CommRing R]", "[CommRing S] [Ring A] [Algebra R A] [Algebra R S] [Algebra S A]", "[IsScalarTower R S A]", "{K : Type u} {A : Type v} [Field K] [Ring A] [Algebra K A]", "(K L R : Type*) {A : Type*}", "[CommRing R] [Nontrivial R] [Ring A] [Algebra R A]", "(A)", "{K L} [Field K] [Ring A] [Algebra K A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_2\nA : Type u_5\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra K A\nr : A\nf : Polynomial K\n\u22a2 Transcendental K ((aeval r) f) \u2194 Transcendental K r \u2227 Transcendental K f"}, {"line": "refine \u27e8fun h \u21a6 \u27e8?_, h.of_aeval\u27e9, fun \u27e8h1, h2\u27e9 \u21a6 h1.aeval_of_transcendental h2\u27e9", "tactic_state": "K : Type u_2\nA : Type u_5\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra K A\nr : A\nf : Polynomial K\nh : Transcendental K ((aeval r) f)\n\u22a2 Transcendental K r"}, {"line": "rw [Transcendental] at h \u22a2", "tactic_state": "K : Type u_2\nA : Type u_5\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra K A\nr : A\nf : Polynomial K\nh : \u00acIsAlgebraic K ((aeval r) f)\n\u22a2 \u00acIsAlgebraic K r"}, {"line": "contrapose! h", "tactic_state": "K : Type u_2\nA : Type u_5\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra K A\nr : A\nf : Polynomial K\nh : IsAlgebraic K r\n\u22a2 IsAlgebraic K ((aeval r) f)"}, {"line": "rw [isAlgebraic_iff_isIntegral] at h \u22a2", "tactic_state": "K : Type u_2\nA : Type u_5\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra K A\nr : A\nf : Polynomial K\nh : IsIntegral K r\n\u22a2 IsIntegral K ((aeval r) f)"}, {"line": "exact .of_mem_of_fg _ h.fg_adjoin_singleton _ (aeval_mem_adjoin_singleton _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.IsIntegral.trans_isAlgebraic [alg : Algebra.IsAlgebraic R S]\n    {a : A} (h : IsIntegral S a) : IsAlgebraic R a := by\n  cases subsingleton_or_nontrivial A\n  \u00b7 have := Algebra.IsAlgebraic.nontrivial R S\n    exact Subsingleton.elim a 0 \u25b8 isAlgebraic_zero\n  \u00b7 have := Module.nontrivial S A\n    exact h.isAlgebraic.restrictScalars _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/Integral.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type u} {S : Type*} {A : Type v} [CommRing R]", "[CommRing S] [Ring A] [Algebra R A] [Algebra R S] [Algebra S A]", "[IsScalarTower R S A]", "{K : Type u} {A : Type v} [Field K] [Ring A] [Algebra K A]", "(K L R : Type*) {A : Type*}", "[CommRing R] [Nontrivial R] [Ring A] [Algebra R A]", "(A)", "{K L} [Field K] [Ring A] [Algebra K A]", "[Field L] [Algebra K L]", "(K L) in", "{R S A : Type*} [CommRing R] [CommRing S] [Ring A]", "[Algebra R S] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "{z : A} {z' : S}", "(R) in", "(R) [NoZeroDivisors S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_1\ninst\u271d\u2079 : CommRing S\nR : Type u_4\nA : Type u_5\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Nontrivial R\ninst\u271d\u2076 : Ring A\ninst\u271d\u2075 : Algebra R A\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : IsScalarTower R S A\nalg : Algebra.IsAlgebraic R S\na : A\nh : IsIntegral S a\n\u22a2 IsAlgebraic R a"}, {"line": "cases subsingleton_or_nontrivial A", "tactic_state": "case inl\nS : Type u_1\ninst\u271d\u2079 : CommRing S\nR : Type u_4\nA : Type u_5\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Nontrivial R\ninst\u271d\u2076 : Ring A\ninst\u271d\u2075 : Algebra R A\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : IsScalarTower R S A\nalg : Algebra.IsAlgebraic R S\na : A\nh : IsIntegral S a\nh\u271d : Subsingleton A\n\u22a2 IsAlgebraic R a\n---\ncase inr\nS : Type u_1\ninst\u271d\u2079 : CommRing S\nR : Type u_4\nA : Type u_5\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Nontrivial R\ninst\u271d\u2076 : Ring A\ninst\u271d\u2075 : Algebra R A\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : IsScalarTower R S A\nalg : Algebra.IsAlgebraic R S\na : A\nh : IsIntegral S a\nh\u271d : Nontrivial A\n\u22a2 IsAlgebraic R a"}, {"line": "\u00b7 have := Algebra.IsAlgebraic.nontrivial R S\n    exact Subsingleton.elim a 0 \u25b8 isAlgebraic_zero", "tactic_state": "case inr\nS : Type u_1\ninst\u271d\u2079 : CommRing S\nR : Type u_4\nA : Type u_5\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Nontrivial R\ninst\u271d\u2076 : Ring A\ninst\u271d\u2075 : Algebra R A\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : IsScalarTower R S A\nalg : Algebra.IsAlgebraic R S\na : A\nh : IsIntegral S a\nh\u271d : Nontrivial A\n\u22a2 IsAlgebraic R a"}, {"line": "\u00b7 have := Module.nontrivial S A\n    exact h.isAlgebraic.restrictScalars _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Polynomial.transcendental_X : Transcendental R (X (R := R)) := by\n  simp [transcendental_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/Basic.lean", "context": {"open": ["Polynomial"], "variables": ["(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]", "{R}", "(R A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\n\u22a2 Transcendental R X"}, {"line": "simp [transcendental_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsAlgebraic.of_aeval {r : A} (f : R[X]) (hf : f.natDegree \u2260 0)\n    (hf' : f.leadingCoeff \u2208 nonZeroDivisors R) (H : IsAlgebraic R (aeval r f)) :\n    IsAlgebraic R r := by\n  obtain \u27e8p, h1, h2\u27e9 := H\n  have : (p.comp f).coeff (p.natDegree * f.natDegree) \u2260 0 := fun h \u21a6 h1 <| by\n    rwa [coeff_comp_degree_mul_degree hf,\n      mul_right_mem_nonZeroDivisors_eq_zero_iff (pow_mem hf' _),\n      leadingCoeff_eq_zero] at h\n  exact \u27e8p.comp f, fun h \u21a6 this (by simp [h]), by rwa [aeval_comp]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/Basic.lean", "context": {"open": ["Polynomial"], "variables": ["(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]", "{R}", "(R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nr : A\nf : Polynomial R\nhf : f.natDegree \u2260 0\nhf' : f.leadingCoeff \u2208 nonZeroDivisors R\nH : IsAlgebraic R ((aeval r) f)\n\u22a2 IsAlgebraic R r"}, {"line": "obtain \u27e8p, h1, h2\u27e9 := H", "tactic_state": "case intro.intro\nR : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nr : A\nf : Polynomial R\nhf : f.natDegree \u2260 0\nhf' : f.leadingCoeff \u2208 nonZeroDivisors R\np : Polynomial R\nh1 : p \u2260 0\nh2 : (aeval ((aeval r) f)) p = 0\n\u22a2 IsAlgebraic R r"}, {"line": "have : (p.comp f).coeff (p.natDegree * f.natDegree) \u2260 0 := fun h \u21a6 h1 <| by\n    rwa [coeff_comp_degree_mul_degree hf,\n      mul_right_mem_nonZeroDivisors_eq_zero_iff (pow_mem hf' _),\n      leadingCoeff_eq_zero] at h", "tactic_state": "case intro.intro\nR : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nr : A\nf : Polynomial R\nhf : f.natDegree \u2260 0\nhf' : f.leadingCoeff \u2208 nonZeroDivisors R\np : Polynomial R\nh1 : p \u2260 0\nh2 : (aeval ((aeval r) f)) p = 0\nthis : sorry \u2260 0\n\u22a2 IsAlgebraic R r"}, {"line": "exact \u27e8p.comp f, fun h \u21a6 this (by simp [h]), by rwa [aeval_comp]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Transcendental.aeval_of_transcendental {r : A} (H : Transcendental R r)\n    {f : R[X]} (hf : Transcendental R f) : Transcendental R (Polynomial.aeval r f) := by\n  rw [transcendental_iff] at H hf \u22a2\n  intro p hp\n  exact hf _ (H _ (by rwa [\u2190 aeval_comp, comp_eq_aeval] at hp))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/Basic.lean", "context": {"open": ["Polynomial"], "variables": ["(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]", "{R}", "(R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nr : A\nH : Transcendental R r\nf : Polynomial R\nhf : Transcendental R f\n\u22a2 Transcendental R ((Polynomial.aeval r) f)"}, {"line": "rw [transcendental_iff] at H hf \u22a2", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nr : A\nH : \u2200 (p : Polynomial R), (Polynomial.aeval r) p = 0 \u2192 p = 0\nf : Polynomial R\nhf : \u2200 (p : Polynomial R), (Polynomial.aeval f) p = 0 \u2192 p = 0\n\u22a2 \u2200 (p : Polynomial R), (Polynomial.aeval ((Polynomial.aeval r) f)) p = 0 \u2192 p = 0"}, {"line": "intro p hp", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nr : A\nH : \u2200 (p : Polynomial R), (Polynomial.aeval r) p = 0 \u2192 p = 0\nf : Polynomial R\nhf : \u2200 (p : Polynomial R), (Polynomial.aeval f) p = 0 \u2192 p = 0\np : Polynomial R\nhp : (Polynomial.aeval ((Polynomial.aeval r) f)) p = 0\n\u22a2 p = 0"}, {"line": "exact hf _ (H _ (by rwa [\u2190 aeval_comp, comp_eq_aeval] at hp))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Transcendental.of_aeval {r : A} {f : R[X]}\n    (H : Transcendental R (Polynomial.aeval r f)) : Transcendental R f := by\n  rw [transcendental_iff] at H \u22a2\n  intro p hp\n  exact H p (by rw [\u2190 aeval_comp, comp_eq_aeval, hp, map_zero])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/Basic.lean", "context": {"open": ["Polynomial"], "variables": ["(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]", "{R}", "(R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nr : A\nf : Polynomial R\nH : Transcendental R ((Polynomial.aeval r) f)\n\u22a2 Transcendental R f"}, {"line": "rw [transcendental_iff] at H \u22a2", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nr : A\nf : Polynomial R\nH : \u2200 (p : Polynomial R), (Polynomial.aeval ((Polynomial.aeval r) f)) p = 0 \u2192 p = 0\n\u22a2 \u2200 (p : Polynomial R), (Polynomial.aeval f) p = 0 \u2192 p = 0"}, {"line": "intro p hp", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nr : A\nf : Polynomial R\nH : \u2200 (p : Polynomial R), (Polynomial.aeval ((Polynomial.aeval r) f)) p = 0 \u2192 p = 0\np : Polynomial R\nhp : (Polynomial.aeval f) p = 0\n\u22a2 p = 0"}, {"line": "exact H p (by rw [\u2190 aeval_comp, comp_eq_aeval, hp, map_zero])", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsAlgebraic.of_aeval_of_transcendental {r : A} {f : R[X]}\n    (H : IsAlgebraic R (aeval r f)) (hf : Transcendental R f) : IsAlgebraic R r := by\n  contrapose H\n  exact Transcendental.aeval_of_transcendental H hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/Basic.lean", "context": {"open": ["Polynomial"], "variables": ["(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]", "{R}", "(R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nr : A\nf : Polynomial R\nH : IsAlgebraic R ((aeval r) f)\nhf : Transcendental R f\n\u22a2 IsAlgebraic R r"}, {"line": "contrapose H", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nr : A\nf : Polynomial R\nhf : Transcendental R f\nH : \u00acIsAlgebraic R r\n\u22a2 \u00acIsAlgebraic R ((aeval r) f)"}, {"line": "exact Transcendental.aeval_of_transcendental H hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Polynomial.transcendental (f : R[X]) (hf : f.natDegree \u2260 0)\n    (hf' : f.leadingCoeff \u2208 nonZeroDivisors R) :\n    Transcendental R f := by\n  simpa using (transcendental_X R).aeval f hf hf'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/Basic.lean", "context": {"open": ["Polynomial"], "variables": ["(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]", "{R}", "(R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nf : Polynomial R\nhf : f.natDegree \u2260 0\nhf' : f.leadingCoeff \u2208 nonZeroDivisors R\n\u22a2 Transcendental R f"}, {"line": "simpa using (transcendental_X R).aeval f hf hf'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transcendental_iff_ker_eq_bot {x : A} :\n    Transcendental R x \u2194 RingHom.ker (aeval (R := R) x) = \u22a5 := by\n  rw [transcendental_iff_injective]\n  rw [RingHom.injective_iff_ker_eq_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/Basic.lean", "context": {"open": ["Polynomial"], "variables": ["(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]", "{R}", "(R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nx : A\n\u22a2 Transcendental R x \u2194 RingHom.ker (aeval x) = \u22a5"}, {"line": "rw [transcendental_iff_injective]", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nx : A\n\u22a2 Function.Injective \u21d1(aeval x) \u2194 RingHom.ker (aeval x) = \u22a5"}, {"line": "rw [RingHom.injective_iff_ker_eq_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Algebra.injective_of_transcendental [h : Algebra.Transcendental R A] :\n    Function.Injective (algebraMap R A) := by\n  rw [transcendental_iff_not_isAlgebraic] at h\n  contrapose! h\n  exact isAlgebraic_of_not_injective h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/Basic.lean", "context": {"open": ["Polynomial"], "variables": ["(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]", "{R}", "(R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nh : Algebra.Transcendental R A\n\u22a2 Function.Injective \u21d1(algebraMap R A)"}, {"line": "rw [transcendental_iff_not_isAlgebraic] at h", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nh : \u00acAlgebra.IsAlgebraic R A\n\u22a2 Function.Injective \u21d1(algebraMap R A)"}, {"line": "contrapose! h", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nh : \u00acFunction.Injective \u21d1(algebraMap R A)\n\u22a2 Algebra.IsAlgebraic R A"}, {"line": "exact isAlgebraic_of_not_injective h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transcendental_polynomial_aeval_X_iff (i : \u03c3) {f : R[X]} :\n    Transcendental R (Polynomial.aeval (X i : MvPolynomial \u03c3 R) f) \u2194 Transcendental R f := by\n  refine \u27e8?_, transcendental_polynomial_aeval_X R i\u27e9\n  simp_rw [Transcendental, not_imp_not]\n  exact fun h \u21a6 h.algHom _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/MvPolynomial.lean", "context": {"open": ["Polynomial"], "variables": ["{\u03c3 : Type*} (R : Type*) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : CommRing R\ni : \u03c3\nf : Polynomial R\n\u22a2 Transcendental R ((aeval sorry) f) \u2194 Transcendental R f"}, {"line": "refine \u27e8?_, transcendental_polynomial_aeval_X R i\u27e9", "tactic_state": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : CommRing R\ni : \u03c3\nf : Polynomial R\n\u22a2 Transcendental R ((aeval sorry) f) \u2192 Transcendental R f"}, {"line": "simp_rw [Transcendental, not_imp_not]", "tactic_state": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : CommRing R\ni : \u03c3\nf : Polynomial R\n\u22a2 IsAlgebraic R f \u2192 IsAlgebraic R ((aeval sorry) f)"}, {"line": "exact fun h \u21a6 h.algHom _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transcendental_supported_X {i : \u03c3} {s : Set \u03c3} (h : i \u2209 s) :\n    Transcendental (supported R s) (X i : MvPolynomial \u03c3 R) := by\n  simpa using transcendental_supported_polynomial_aeval_X R h (Polynomial.transcendental_X R)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/MvPolynomial.lean", "context": {"open": ["Polynomial"], "variables": ["{\u03c3 : Type*} (R : Type*) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : CommRing R\nx\u271d : Sort u_3\nsupported : x\u271d\ni : \u03c3\ns : Set \u03c3\nh : i \u2209 s\n\u22a2 Transcendental sorry sorry"}, {"line": "simpa using transcendental_supported_polynomial_aeval_X R h (Polynomial.transcendental_X R)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transcendental_X (i : \u03c3) : Transcendental R (X i : MvPolynomial \u03c3 R) := by\n  simpa using transcendental_polynomial_aeval_X R i (Polynomial.transcendental_X R)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/MvPolynomial.lean", "context": {"open": ["Polynomial"], "variables": ["{\u03c3 : Type*} (R : Type*) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : CommRing R\ni : \u03c3\n\u22a2 Transcendental R sorry"}, {"line": "simpa using transcendental_polynomial_aeval_X R i (Polynomial.transcendental_X R)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transcendental_supported_X_iff [Nontrivial R] {i : \u03c3} {s : Set \u03c3} :\n    Transcendental (supported R s) (X i : MvPolynomial \u03c3 R) \u2194 i \u2209 s := by\n  simpa [Polynomial.transcendental_X] using\n    transcendental_supported_polynomial_aeval_X_iff R (i := i) (s := s) (f := Polynomial.X)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Algebraic/MvPolynomial.lean", "context": {"open": ["Polynomial"], "variables": ["{\u03c3 : Type*} (R : Type*) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_3\nsupported : x\u271d\ninst\u271d : Nontrivial R\ni : \u03c3\ns : Set \u03c3\n\u22a2 Transcendental sorry sorry \u2194 i \u2209 s"}, {"line": "simpa [Polynomial.transcendental_X] using\n    transcendental_supported_polynomial_aeval_X_iff R (i := i) (s := s) (f := Polynomial.X)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aevalEquivField_algebraMap_apply_coe (a : MvPolynomial \u03b9 F) :\n    hx.aevalEquivField (algebraMap _ _ a) = aeval x a := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Adjoin.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra"], "variables": ["{\u03b9 : Type*}", "{F E : Type*} {x : \u03b9 \u2192 E} [Field F] [Field E] [Algebra F E] (hx : AlgebraicIndependent F x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nF : Type u_2\nE : Type u_3\nx : \u03b9 \u2192 E\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nhx : AlgebraicIndependent F x\na : MvPolynomial \u03b9 F\n\u22a2 \u2191(hx.aevalEquivField ((algebraMap (MvPolynomial \u03b9 F) (FractionRing (MvPolynomial \u03b9 F))) a)) = (aeval x) a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem algebraicIndependent_iff_transcendental {x : A} :\n    AlgebraicIndependent R ![x] \u2194 Transcendental R x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Transcendental.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra"], "variables": ["{\u03b9 \u03b9' R : Type*} {S : Type u} {A : Type v} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing S] [CommRing A]", "[Algebra R S] [Algebra R A] [Algebra S A] [IsScalarTower R S A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nx : A\n\u22a2 AlgebraicIndependent R ![x] \u2194 Transcendental R x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isEmpty_of_isAlgebraic [Algebra.IsAlgebraic R A] : IsEmpty \u03b9 := by\n  rcases isEmpty_or_nonempty \u03b9 with h | \u27e8\u27e8i\u27e9\u27e9\n  \u00b7 exact h\n  exact False.elim (hx.transcendental i (Algebra.IsAlgebraic.isAlgebraic _))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Transcendental.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra"], "variables": ["{\u03b9 \u03b9' R : Type*} {S : Type u} {A : Type v} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing S] [CommRing A]", "[Algebra R S] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "(hx : AlgebraicIndependent R x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_3\nA : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra.IsAlgebraic R A\n\u22a2 IsEmpty \u03b9"}, {"line": "rcases isEmpty_or_nonempty \u03b9 with h | \u27e8\u27e8i\u27e9\u27e9", "tactic_state": "case inl\n\u03b9 : Type u_1\nR : Type u_3\nA : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra.IsAlgebraic R A\nh : IsEmpty \u03b9\n\u22a2 IsEmpty \u03b9\n---\ncase inr.intro\n\u03b9 : Type u_1\nR : Type u_3\nA : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra.IsAlgebraic R A\ni : \u03b9\n\u22a2 IsEmpty \u03b9"}, {"line": "\u00b7 exact h", "tactic_state": "case inr.intro\n\u03b9 : Type u_1\nR : Type u_3\nA : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra.IsAlgebraic R A\ni : \u03b9\n\u22a2 IsEmpty \u03b9"}, {"line": "exact False.elim (hx.transcendental i (Algebra.IsAlgebraic.isAlgebraic _))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem trdeg_ne_zero_iff : trdeg R A \u2260 0 \u2194 Algebra.Transcendental R A := by\n  rw [Algebra.transcendental_iff_not_isAlgebraic]\n  rw [Ne]\n  rw [trdeg_eq_zero_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Transcendental.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra"], "variables": ["{\u03b9 \u03b9' R : Type*} {S : Type u} {A : Type v} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing S] [CommRing A]", "[Algebra R S] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "(hx : AlgebraicIndependent R x)", "(R A) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\n\u22a2 trdeg R A \u2260 0 \u2194 Algebra.Transcendental R A"}, {"line": "rw [Algebra.transcendental_iff_not_isAlgebraic]", "tactic_state": "R : Type u_3\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\n\u22a2 trdeg R A \u2260 0 \u2194 \u00acAlgebra.IsAlgebraic R A"}, {"line": "rw [Ne]", "tactic_state": "R : Type u_3\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\n\u22a2 \u00actrdeg R A = 0 \u2194 \u00acAlgebra.IsAlgebraic R A"}, {"line": "rw [trdeg_eq_zero_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AlgebraicIndepOn.insert_iff {s : Set \u03b9} {i : \u03b9} (h : i \u2209 s) :\n    AlgebraicIndepOn R x (insert i s) \u2194\n      AlgebraicIndepOn R x s \u2227 Transcendental (adjoin R (x '' s)) (x i) := by\n  classical simp_rw [\u2190 algebraicIndependent_equiv (subtypeInsertEquivOption h).symm,\n    AlgebraicIndepOn]\n  convert option_iff (x := fun i : s \u21a6 x i) (a := x i) using 2\n  \u00b7 ext (_|_) <;> rfl\n  \u00b7 rw [Set.image_eq_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Transcendental.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent"], "variables": ["{\u03b9 \u03b9' R : Type*} {S : Type u} {A : Type v} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing S] [CommRing A]", "[Algebra R S] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "(hx : AlgebraicIndependent R x)", "(R A) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_3\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\ns : Set \u03b9\ni : \u03b9\nh : i \u2209 s\n\u22a2 AlgebraicIndepOn R x (insert i s) \u2194 AlgebraicIndepOn R x s \u2227 Transcendental (\u21a5(adjoin R (x '' s))) (x i)"}, {"line": "classical simp_rw [\u2190 algebraicIndependent_equiv (subtypeInsertEquivOption h).symm,\n    AlgebraicIndepOn]", "tactic_state": "\u03b9 : Type u_1\nR : Type u_3\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\ns : Set \u03b9\ni : \u03b9\nh : i \u2209 s\n\u22a2 AlgebraicIndependent R ((fun i_1 => x \u2191i_1) \u2218 \u21d1(subtypeInsertEquivOption h).symm) \u2194\n    (AlgebraicIndependent R fun i => x \u2191i) \u2227 Transcendental (\u21a5(adjoin R (x '' s))) (x i)"}, {"line": "convert option_iff (x := fun i : s \u21a6 x i) (a := x i) using 2", "tactic_state": "case h.e'_1.h.e'_4\n\u03b9 : Type u_1\nR : Type u_3\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\ns : Set \u03b9\ni : \u03b9\nh : i \u2209 s\n\u22a2 (fun i_1 => x \u2191i_1) \u2218 \u21d1(subtypeInsertEquivOption h).symm = fun o => o.elim (x i) fun i => x \u2191i\n---\ncase h.e'_2.h.e'_2.a\n\u03b9 : Type u_1\nR : Type u_3\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\ns : Set \u03b9\ni : \u03b9\nh : i \u2209 s\n\u22a2 Transcendental (\u21a5(adjoin R (x '' s))) (x i) \u2194 Transcendental (\u21a5(adjoin R (range fun i => x \u2191i))) (x i)"}, {"line": "\u00b7 ext (_|_) <;> rfl", "tactic_state": "case h.e'_2.h.e'_2.a\n\u03b9 : Type u_1\nR : Type u_3\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\ns : Set \u03b9\ni : \u03b9\nh : i \u2209 s\n\u22a2 Transcendental (\u21a5(adjoin R (x '' s))) (x i) \u2194 Transcendental (\u21a5(adjoin R (range fun i => x \u2191i))) (x i)"}, {"line": "\u00b7 rw [Set.image_eq_range]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iff_adjoin_image (s : Set \u03b9) :\n    AlgebraicIndependent R x \u2194 AlgebraicIndependent R (fun i : s \u21a6 x i) \u2227\n      AlgebraicIndepOn (adjoin R (x '' s)) x s\u1d9c := by\n  rw [show x '' s = range fun i : s \u21a6 x i by ext; simp]\n  convert \u2190 sumElim_iff\n  classical apply algebraicIndependent_equiv' ((Equiv.sumComm ..).trans (Equiv.Set.sumCompl ..))\n  ext (_|_) <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Transcendental.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent"], "variables": ["{\u03b9 \u03b9' R : Type*} {S : Type u} {A : Type v} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing S] [CommRing A]", "[Algebra R S] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "(hx : AlgebraicIndependent R x)", "(R A) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_3\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\ns : Set \u03b9\n\u22a2 AlgebraicIndependent R x \u2194 (AlgebraicIndependent R fun i => x \u2191i) \u2227 AlgebraicIndepOn (\u21a5(adjoin R (x '' s))) x s\u1d9c"}, {"line": "rw [show x '' s = range fun i : s \u21a6 x i by ext; simp]", "tactic_state": "\u03b9 : Type u_1\nR : Type u_3\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\ns : Set \u03b9\n\u22a2 AlgebraicIndependent R x \u2194\n    (AlgebraicIndependent R fun i => x \u2191i) \u2227 AlgebraicIndepOn (\u21a5(adjoin R (range fun i => x \u2191i))) x s\u1d9c"}, {"line": "convert \u2190 sumElim_iff", "tactic_state": "case h.e'_1.a\n\u03b9 : Type u_1\nR : Type u_3\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\ns : Set \u03b9\n\u22a2 AlgebraicIndependent R (Sum.elim (fun i => x \u2191i) fun i => x \u2191i) \u2194 AlgebraicIndependent R x"}, {"line": "classical apply algebraicIndependent_equiv' ((Equiv.sumComm ..).trans (Equiv.Set.sumCompl ..))", "tactic_state": "case h.e'_1.a\n\u03b9 : Type u_1\nR : Type u_3\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\ns : Set \u03b9\n\u22a2 x \u2218 \u21d1((Equiv.sumComm \u2191s\u1d9c \u2191s).trans (Equiv.Set.sumCompl s)) = Sum.elim (fun i => x \u2191i) fun i => x \u2191i"}, {"line": "ext (_|_) <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem extendScalars_of_isIntegral [Algebra.IsIntegral R S] : AlgebraicIndependent S x := by\n  nontriviality S\n  have := Module.nontrivial R S\n  exact hx.extendScalars S\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/AlgebraicClosure.lean", "context": {"open": ["Function Algebra"], "variables": ["{\u03b9 R S A : Type*} {x : \u03b9 \u2192 A} (S)", "[CommRing R] [CommRing S] [CommRing A]", "[Algebra R S] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "[NoZeroDivisors S] (hx : AlgebraicIndependent R x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nA : Type u_4\nx : \u03b9 \u2192 A\nS : Type u_5\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Algebra S A\ninst\u271d\u00b2 : IsScalarTower R S A\ninst\u271d\u00b9 : NoZeroDivisors S\ninst\u271d : Algebra.IsIntegral R S\n\u22a2 AlgebraicIndependent S x"}, {"line": "nontriviality S", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nA : Type u_4\nx : \u03b9 \u2192 A\nS : Type u_5\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Algebra S A\ninst\u271d\u00b2 : IsScalarTower R S A\ninst\u271d\u00b9 : NoZeroDivisors S\ninst\u271d : Algebra.IsIntegral R S\na\u271d : Nontrivial S\n\u22a2 AlgebraicIndependent S x"}, {"line": "have := Module.nontrivial R S", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nA : Type u_4\nx : \u03b9 \u2192 A\nS : Type u_5\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Algebra S A\ninst\u271d\u00b2 : IsScalarTower R S A\ninst\u271d\u00b9 : NoZeroDivisors S\ninst\u271d : Algebra.IsIntegral R S\na\u271d : Nontrivial S\nthis : Nontrivial R\n\u22a2 AlgebraicIndependent S x"}, {"line": "exact hx.extendScalars S", "tactic_state": "No Goals!"}]}
{"declaration": "theorem algebraicIndependent_empty_type_iff [IsEmpty \u03b9] :\n    AlgebraicIndependent R x \u2194 Injective (algebraMap R A) := by\n  rw [algebraicIndependent_iff_injective_aeval]\n  rw [MvPolynomial.aeval_injective_iff_of_isEmpty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Basic.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra"], "variables": ["{\u03b9 : Type u} {\u03b9' R : Type*} {A : Type v} {A' : Type v'} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "(R A) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : IsEmpty \u03b9\n\u22a2 AlgebraicIndependent R x \u2194 Injective \u21d1(algebraMap R A)"}, {"line": "rw [algebraicIndependent_iff_injective_aeval]", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : IsEmpty \u03b9\n\u22a2 Injective \u21d1(aeval x) \u2194 Injective \u21d1(algebraMap R A)"}, {"line": "rw [MvPolynomial.aeval_injective_iff_of_isEmpty]", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : IsEmpty \u03b9\n\u22a2 IsEmpty \u03b9"}]}
{"declaration": "theorem of_aeval {f : \u03b9 \u2192 MvPolynomial \u03b9 R}\n    (H : AlgebraicIndependent R fun i \u21a6 aeval x (f i)) :\n    AlgebraicIndependent R f := by\n  rw [algebraicIndependent_iff] at H \u22a2\n  intro p hp\n  exact H p (by rw [\u2190 aeval_comp_bind\u2081, AlgHom.comp_apply, bind\u2081, hp, map_zero])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Basic.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra"], "variables": ["{\u03b9 : Type u} {\u03b9' R : Type*} {A : Type v} {A' : Type v'} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "(R A) in", "(hx : AlgebraicIndependent R x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nf : \u03b9 \u2192 MvPolynomial \u03b9 R\nH : AlgebraicIndependent R fun i => (aeval x) (f i)\n\u22a2 AlgebraicIndependent R f"}, {"line": "rw [algebraicIndependent_iff] at H \u22a2", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nf : \u03b9 \u2192 MvPolynomial \u03b9 R\nH : \u2200 (p : MvPolynomial \u03b9 R), (aeval fun i => (aeval x) (f i)) p = 0 \u2192 p = 0\n\u22a2 \u2200 (p : MvPolynomial \u03b9 R), (aeval f) p = 0 \u2192 p = 0"}, {"line": "intro p hp", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nf : \u03b9 \u2192 MvPolynomial \u03b9 R\nH : \u2200 (p : MvPolynomial \u03b9 R), (aeval fun i => (aeval x) (f i)) p = 0 \u2192 p = 0\np : MvPolynomial \u03b9 R\nhp : (aeval f) p = 0\n\u22a2 p = 0"}, {"line": "exact H p (by rw [\u2190 aeval_comp_bind\u2081, AlgHom.comp_apply, bind\u2081, hp, map_zero])", "tactic_state": "No Goals!"}]}
{"declaration": "theorem trdeg_eq_zero_of_not_injective (h : \u00ac Injective (algebraMap R A)) : trdeg R A = 0 := by\n  have := isEmpty_algebraicIndependent h\n  rw [trdeg]\n  rw [ciSup_of_empty]\n  rw [bot_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Basic.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra"], "variables": ["{\u03b9 : Type u} {\u03b9' R : Type*} {A : Type v} {A' : Type v'} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "(R A) in", "(hx : AlgebraicIndependent R x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nh : \u00acInjective \u21d1(algebraMap R A)\n\u22a2 trdeg R A = 0"}, {"line": "have := isEmpty_algebraicIndependent h", "tactic_state": "R : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nh : \u00acInjective \u21d1(algebraMap R A)\nthis : IsEmpty { s // AlgebraicIndepOn R _root_.id s }\n\u22a2 trdeg R A = 0"}, {"line": "rw [trdeg]", "tactic_state": "R : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nh : \u00acInjective \u21d1(algebraMap R A)\nthis : IsEmpty { s // AlgebraicIndepOn R _root_.id s }\n\u22a2 \u2a06 \u03b9, Cardinal.mk \u2191\u2191\u03b9 = 0"}, {"line": "rw [ciSup_of_empty]", "tactic_state": "R : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nh : \u00acInjective \u21d1(algebraMap R A)\nthis : IsEmpty { s // AlgebraicIndepOn R _root_.id s }\n\u22a2 \u22a5 = 0"}, {"line": "rw [bot_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MvPolynomial.algebraicIndependent_X (\u03c3 R : Type*) [CommRing R] :\n    AlgebraicIndependent R (X (R := R) (\u03c3 := \u03c3)) := by\n  rw [AlgebraicIndependent]\n  rw [aeval_X_left]\n  exact injective_id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Basic.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra"], "variables": ["{\u03b9 : Type u} {\u03b9' R : Type*} {A : Type v} {A' : Type v'} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "(R A) in", "(hx : AlgebraicIndependent R x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_3\nR : Type u_4\ninst\u271d : CommRing R\n\u22a2 AlgebraicIndependent R X"}, {"line": "rw [AlgebraicIndependent]", "tactic_state": "\u03c3 : Type u_3\nR : Type u_4\ninst\u271d : CommRing R\n\u22a2 Injective \u21d1(aeval X)"}, {"line": "rw [aeval_X_left]", "tactic_state": "\u03c3 : Type u_3\nR : Type u_4\ninst\u271d : CommRing R\n\u22a2 Injective \u21d1(AlgHom.id R (MvPolynomial \u03c3 R))"}, {"line": "exact injective_id", "tactic_state": "No Goals!"}]}
{"declaration": "theorem algebraicIndependent_bounded_of_finset_algebraicIndependent_bounded {n : \u2115}\n    (H : \u2200 s : Finset A, (AlgebraicIndependent R fun i : s => (i : A)) \u2192 s.card \u2264 n) :\n    \u2200 s : Set A, AlgebraicIndependent R ((\u2191) : s \u2192 A) \u2192 Cardinal.mk s \u2264 n := by\n  intro s li\n  apply Cardinal.card_le_of\n  intro t\n  rw [\u2190 Finset.card_map (Embedding.subtype s)]\n  apply H\n  apply algebraicIndependent_finset_map_embedding_subtype _ li\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Basic.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent"], "variables": ["{\u03b9 : Type u} {\u03b9' R : Type*} {A : Type v} {A' : Type v'} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "(R A) in", "(hx : AlgebraicIndependent R x)", "{S B FRS FAB : Type*} [CommRing S] [CommRing B] [Algebra S B]", "[FunLike FRS R S] [RingHomClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "[EquivLike FRS R S] [RingEquivClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nn : \u2115\nH : \u2200 (s : Finset A), (AlgebraicIndependent R fun i => \u2191i) \u2192 s.card \u2264 n\n\u22a2 \u2200 (s : Set A), AlgebraicIndependent R Subtype.val \u2192 Cardinal.mk \u2191s \u2264 \u2191n"}, {"line": "intro s li", "tactic_state": "R : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nn : \u2115\nH : \u2200 (s : Finset A), (AlgebraicIndependent R fun i => \u2191i) \u2192 s.card \u2264 n\ns : Set A\nli : AlgebraicIndependent R Subtype.val\n\u22a2 Cardinal.mk \u2191s \u2264 \u2191n"}, {"line": "apply Cardinal.card_le_of", "tactic_state": "case H\nR : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nn : \u2115\nH : \u2200 (s : Finset A), (AlgebraicIndependent R fun i => \u2191i) \u2192 s.card \u2264 n\ns : Set A\nli : AlgebraicIndependent R Subtype.val\n\u22a2 \u2200 (s_1 : Finset \u2191s), s_1.card \u2264 n"}, {"line": "intro t", "tactic_state": "case H\nR : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nn : \u2115\nH : \u2200 (s : Finset A), (AlgebraicIndependent R fun i => \u2191i) \u2192 s.card \u2264 n\ns : Set A\nli : AlgebraicIndependent R Subtype.val\nt : Finset \u2191s\n\u22a2 t.card \u2264 n"}, {"line": "rw [\u2190 Finset.card_map (Embedding.subtype s)]", "tactic_state": "case H\nR : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nn : \u2115\nH : \u2200 (s : Finset A), (AlgebraicIndependent R fun i => \u2191i) \u2192 s.card \u2264 n\ns : Set A\nli : AlgebraicIndependent R Subtype.val\nt : Finset \u2191s\n\u22a2 (Finset.map (Embedding.subtype s) t).card \u2264 n"}, {"line": "apply H", "tactic_state": "case H.a\nR : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nn : \u2115\nH : \u2200 (s : Finset A), (AlgebraicIndependent R fun i => \u2191i) \u2192 s.card \u2264 n\ns : Set A\nli : AlgebraicIndependent R Subtype.val\nt : Finset \u2191s\n\u22a2 AlgebraicIndependent R fun i => \u2191i"}, {"line": "apply algebraicIndependent_finset_map_embedding_subtype _ li", "tactic_state": "No Goals!"}]}
{"declaration": "theorem algebraicIndependent_empty_iff :\n    AlgebraicIndependent R ((\u2191) : (\u2205 : Set A) \u2192 A) \u2194 Injective (algebraMap R A) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Basic.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent"], "variables": ["{\u03b9 : Type u} {\u03b9' R : Type*} {A : Type v} {A' : Type v'} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "(R A) in", "(hx : AlgebraicIndependent R x)", "{S B FRS FAB : Type*} [CommRing S] [CommRing B] [Algebra S B]", "[FunLike FRS R S] [RingHomClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "[EquivLike FRS R S] [RingEquivClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "(R A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\n\u22a2 AlgebraicIndependent R Subtype.val \u2194 Injective \u21d1(algebraMap R A)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsTranscendenceBasis.to_subtype_range (hx : IsTranscendenceBasis R x) :\n    IsTranscendenceBasis R ((\u2191) : range x \u2192 A) := by\n  cases subsingleton_or_nontrivial R\n  \u00b7 rw [isTranscendenceBasis_iff_of_subsingleton] at hx \u22a2; infer_instance\n  \u00b7 rwa [isTranscendenceBasis_subtype_range hx.1.injective]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Basic.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent"], "variables": ["{\u03b9 : Type u} {\u03b9' R : Type*} {A : Type v} {A' : Type v'} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "(R A) in", "(hx : AlgebraicIndependent R x)", "{S B FRS FAB : Type*} [CommRing S] [CommRing B] [Algebra S B]", "[FunLike FRS R S] [RingHomClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "[EquivLike FRS R S] [RingEquivClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "(R A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhx : IsTranscendenceBasis R x\n\u22a2 IsTranscendenceBasis R Subtype.val"}, {"line": "cases subsingleton_or_nontrivial R", "tactic_state": "case inl\n\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhx : IsTranscendenceBasis R x\nh\u271d : Subsingleton R\n\u22a2 IsTranscendenceBasis R Subtype.val\n---\ncase inr\n\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhx : IsTranscendenceBasis R x\nh\u271d : Nontrivial R\n\u22a2 IsTranscendenceBasis R Subtype.val"}, {"line": "\u00b7 rw [isTranscendenceBasis_iff_of_subsingleton] at hx \u22a2; infer_instance", "tactic_state": "case inr\n\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhx : IsTranscendenceBasis R x\nh\u271d : Nontrivial R\n\u22a2 IsTranscendenceBasis R Subtype.val"}, {"line": "\u00b7 rwa [isTranscendenceBasis_subtype_range hx.1.injective]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_trdeg_le_of_injective (f : A \u2192\u2090[R] A') (hf : Injective f) :\n    lift.{v'} (trdeg R A) \u2264 lift.{v} (trdeg R A') := by\n  nontriviality R\n  rw [trdeg]\n  rw [lift_iSup (bddAbove_range _)]\n  exact ciSup_le' fun i \u21a6 (i.2.map' hf).lift_cardinalMk_le_trdeg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Basic.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent", "Cardinal"], "variables": ["{\u03b9 : Type u} {\u03b9' R : Type*} {A : Type v} {A' : Type v'} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "(R A) in", "(hx : AlgebraicIndependent R x)", "{S B FRS FAB : Type*} [CommRing S] [CommRing B] [Algebra S B]", "[FunLike FRS R S] [RingHomClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "[EquivLike FRS R S] [RingEquivClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "(R A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nA : Type v\nA' : Type v'\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : CommRing A'\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nhf : Injective \u21d1f\n\u22a2 lift.{v', v} (trdeg R A) \u2264 lift.{v, v'} (trdeg R A')"}, {"line": "nontriviality R", "tactic_state": "R : Type u_2\nA : Type v\nA' : Type v'\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : CommRing A'\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nhf : Injective \u21d1f\na\u271d : Nontrivial R\n\u22a2 lift.{v', v} (trdeg R A) \u2264 lift.{v, v'} (trdeg R A')"}, {"line": "rw [trdeg]", "tactic_state": "R : Type u_2\nA : Type v\nA' : Type v'\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : CommRing A'\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nhf : Injective \u21d1f\na\u271d : Nontrivial R\n\u22a2 lift.{v', v} (\u2a06 \u03b9, Cardinal.mk \u2191\u2191\u03b9) \u2264 lift.{v, v'} (trdeg R A')"}, {"line": "rw [lift_iSup (bddAbove_range _)]", "tactic_state": "R : Type u_2\nA : Type v\nA' : Type v'\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : CommRing A'\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nhf : Injective \u21d1f\na\u271d : Nontrivial R\n\u22a2 \u2a06 i, lift.{v', v} (Cardinal.mk \u2191\u2191i) \u2264 lift.{v, v'} (trdeg R A')"}, {"line": "exact ciSup_le' fun i \u21a6 (i.2.map' hf).lift_cardinalMk_le_trdeg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AlgebraicIndependent.image_of_comp {\u03b9 \u03b9'} (s : Set \u03b9) (f : \u03b9 \u2192 \u03b9') (g : \u03b9' \u2192 A)\n    (hs : AlgebraicIndependent R fun x : s => g (f x)) :\n    AlgebraicIndependent R fun x : f '' s => g x := by\n  nontriviality R\n  have : InjOn f s := injOn_iff_injective.2 hs.injective.of_comp\n  exact (algebraicIndependent_equiv' (Equiv.Set.imageOfInjOn f s this) rfl).1 hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Basic.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent", "Cardinal"], "variables": ["{\u03b9 : Type u} {\u03b9' R : Type*} {A : Type v} {A' : Type v'} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "(R A) in", "(hx : AlgebraicIndependent R x)", "{S B FRS FAB : Type*} [CommRing S] [CommRing B] [Algebra S B]", "[FunLike FRS R S] [RingHomClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "[EquivLike FRS R S] [RingEquivClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "(R A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\n\u03b9 : Type u_7\n\u03b9' : Type u_8\ns : Set \u03b9\nf : \u03b9 \u2192 \u03b9'\ng : \u03b9' \u2192 A\nhs : AlgebraicIndependent R fun x => g (f \u2191x)\n\u22a2 AlgebraicIndependent R fun x => g \u2191x"}, {"line": "nontriviality R", "tactic_state": "R : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\n\u03b9 : Type u_7\n\u03b9' : Type u_8\ns : Set \u03b9\nf : \u03b9 \u2192 \u03b9'\ng : \u03b9' \u2192 A\nhs : AlgebraicIndependent R fun x => g (f \u2191x)\na\u271d : Nontrivial R\n\u22a2 AlgebraicIndependent R fun x => g \u2191x"}, {"line": "have : InjOn f s := injOn_iff_injective.2 hs.injective.of_comp", "tactic_state": "R : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\n\u03b9 : Type u_7\n\u03b9' : Type u_8\ns : Set \u03b9\nf : \u03b9 \u2192 \u03b9'\ng : \u03b9' \u2192 A\nhs : AlgebraicIndependent R fun x => g (f \u2191x)\na\u271d : Nontrivial R\nthis : InjOn f s\n\u22a2 AlgebraicIndependent R fun x => g \u2191x"}, {"line": "exact (algebraicIndependent_equiv' (Equiv.Set.imageOfInjOn f s this) rfl).1 hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AlgebraicIndependent.image {\u03b9} {s : Set \u03b9} {f : \u03b9 \u2192 A}\n    (hs : AlgebraicIndependent R fun x : s => f x) :\n    AlgebraicIndependent R fun x : f '' s => (x : A) := by\n  convert AlgebraicIndependent.image_of_comp s f id hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Basic.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent", "Cardinal"], "variables": ["{\u03b9 : Type u} {\u03b9' R : Type*} {A : Type v} {A' : Type v'} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "(R A) in", "(hx : AlgebraicIndependent R x)", "{S B FRS FAB : Type*} [CommRing S] [CommRing B] [Algebra S B]", "[FunLike FRS R S] [RingHomClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "[EquivLike FRS R S] [RingEquivClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "(R A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\n\u03b9 : Type u_7\ns : Set \u03b9\nf : \u03b9 \u2192 A\nhs : AlgebraicIndependent R fun x => f \u2191x\n\u22a2 AlgebraicIndependent R fun x => \u2191x"}, {"line": "convert AlgebraicIndependent.image_of_comp s f id hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem algebraicIndependent_sUnion_of_directed {s : Set (Set A)} (hsn : s.Nonempty)\n    (hs : DirectedOn (\u00b7 \u2286 \u00b7) s) (h : \u2200 a \u2208 s, AlgebraicIndependent R ((\u2191) : a \u2192 A)) :\n    AlgebraicIndependent R ((\u2191) : \u22c3\u2080 s \u2192 A) := by\n  letI : Nonempty s := Nonempty.to_subtype hsn\n  rw [sUnion_eq_iUnion]\n  exact algebraicIndependent_iUnion_of_directed hs.directed_val (by simpa using h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Basic.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent", "Cardinal"], "variables": ["{\u03b9 : Type u} {\u03b9' R : Type*} {A : Type v} {A' : Type v'} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "(R A) in", "(hx : AlgebraicIndependent R x)", "{S B FRS FAB : Type*} [CommRing S] [CommRing B] [Algebra S B]", "[FunLike FRS R S] [RingHomClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "[EquivLike FRS R S] [RingEquivClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "(R A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\ns : Set (Set A)\nhsn : s.Nonempty\nhs : DirectedOn (fun x1 x2 => x1 \u2286 x2) s\nh : \u2200 a \u2208 s, AlgebraicIndependent R Subtype.val\n\u22a2 AlgebraicIndependent R Subtype.val"}, {"line": "letI : Nonempty s := Nonempty.to_subtype hsn", "tactic_state": "R : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\ns : Set (Set A)\nhsn : s.Nonempty\nhs : DirectedOn (fun x1 x2 => x1 \u2286 x2) s\nh : \u2200 a \u2208 s, AlgebraicIndependent R Subtype.val\nthis : Nonempty \u2191s := Nonempty.to_subtype hsn\n\u22a2 AlgebraicIndependent R Subtype.val"}, {"line": "rw [sUnion_eq_iUnion]", "tactic_state": "R : Type u_2\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\ns : Set (Set A)\nhsn : s.Nonempty\nhs : DirectedOn (fun x1 x2 => x1 \u2286 x2) s\nh : \u2200 a \u2208 s, AlgebraicIndependent R Subtype.val\nthis : Nonempty \u2191s := Nonempty.to_subtype hsn\n\u22a2 AlgebraicIndependent R Subtype.val"}, {"line": "exact algebraicIndependent_iUnion_of_directed hs.directed_val (by simpa using h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_C'\n    (hx : AlgebraicIndependent R x) (r) :\n    Polynomial.C (hx.aevalEquiv (C r)) = Polynomial.C (algebraMap _ _ r) := by\n  congr\n  apply_fun Subtype.val using Subtype.val_injective\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Basic.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent", "Cardinal"], "variables": ["{\u03b9 : Type u} {\u03b9' R : Type*} {A : Type v} {A' : Type v'} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "(R A) in", "(hx : AlgebraicIndependent R x)", "{S B FRS FAB : Type*} [CommRing S] [CommRing B] [Algebra S B]", "[FunLike FRS R S] [RingHomClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "[EquivLike FRS R S] [RingEquivClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "(R A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhx : AlgebraicIndependent R x\nr : R\n\u22a2 Polynomial.C (hx.aevalEquiv (C r)) = Polynomial.C ((algebraMap R \u21a5(adjoin R (range x))) r)"}, {"line": "congr", "tactic_state": "case h.e_6.h\n\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhx : AlgebraicIndependent R x\nr : R\n\u22a2 hx.aevalEquiv (C r) = (algebraMap R \u21a5(adjoin R (range x))) r"}, {"line": "apply_fun Subtype.val using Subtype.val_injective", "tactic_state": "case h.e_6.h\n\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhx : AlgebraicIndependent R x\nr : R\n\u22a2 \u2191(hx.aevalEquiv (C r)) = \u2191((algebraMap R \u21a5(adjoin R (range x))) r)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_C\n    (hx : AlgebraicIndependent R x) (r) :\n    hx.mvPolynomialOptionEquivPolynomialAdjoin (C r) = Polynomial.C (algebraMap _ _ r) := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Basic.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent", "Cardinal"], "variables": ["{\u03b9 : Type u} {\u03b9' R : Type*} {A : Type v} {A' : Type v'} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "(R A) in", "(hx : AlgebraicIndependent R x)", "{S B FRS FAB : Type*} [CommRing S] [CommRing B] [Algebra S B]", "[FunLike FRS R S] [RingHomClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "[EquivLike FRS R S] [RingEquivClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "(R A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhx : AlgebraicIndependent R x\nr : R\n\u22a2 hx.mvPolynomialOptionEquivPolynomialAdjoin (C r) = Polynomial.C ((algebraMap R \u21a5(adjoin R (range x))) r)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_none\n    (hx : AlgebraicIndependent R x) :\n    hx.mvPolynomialOptionEquivPolynomialAdjoin (X none) = Polynomial.X := by\n  rw [AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply]\n  rw [aeval_X]\n  rw [Option.elim]\n  rw [Polynomial.map_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Basic.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent", "Cardinal"], "variables": ["{\u03b9 : Type u} {\u03b9' R : Type*} {A : Type v} {A' : Type v'} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "(R A) in", "(hx : AlgebraicIndependent R x)", "{S B FRS FAB : Type*} [CommRing S] [CommRing B] [Algebra S B]", "[FunLike FRS R S] [RingHomClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "[EquivLike FRS R S] [RingEquivClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "(R A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhx : AlgebraicIndependent R x\n\u22a2 hx.mvPolynomialOptionEquivPolynomialAdjoin (X none) = Polynomial.X"}, {"line": "rw [AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply]", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhx : AlgebraicIndependent R x\n\u22a2 Polynomial.map (\u2191hx.aevalEquiv) ((aeval fun o => o.elim Polynomial.X fun s => Polynomial.C (X s)) (X none)) =\n    Polynomial.X"}, {"line": "rw [aeval_X]", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhx : AlgebraicIndependent R x\n\u22a2 Polynomial.map (\u2191hx.aevalEquiv) (none.elim Polynomial.X fun s => Polynomial.C (X s)) = Polynomial.X"}, {"line": "rw [Option.elim]", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhx : AlgebraicIndependent R x\n\u22a2 Polynomial.map (\u2191hx.aevalEquiv) Polynomial.X = Polynomial.X"}, {"line": "rw [Polynomial.map_X]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_some\n    (hx : AlgebraicIndependent R x) (i) :\n    hx.mvPolynomialOptionEquivPolynomialAdjoin (X (some i)) =\n      Polynomial.C (hx.aevalEquiv (X i)) := by\n  rw [AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply]\n  rw [aeval_X]\n  rw [Option.elim]\n  rw [Polynomial.map_C]\n  rw [RingHom.coe_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Basic.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent", "Cardinal"], "variables": ["{\u03b9 : Type u} {\u03b9' R : Type*} {A : Type v} {A' : Type v'} {x : \u03b9 \u2192 A}", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "(R A) in", "(hx : AlgebraicIndependent R x)", "{S B FRS FAB : Type*} [CommRing S] [CommRing B] [Algebra S B]", "[FunLike FRS R S] [RingHomClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "[EquivLike FRS R S] [RingEquivClass FRS R S] [FunLike FAB A B] [RingHomClass FAB A B]", "(R A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhx : AlgebraicIndependent R x\ni : \u03b9\n\u22a2 hx.mvPolynomialOptionEquivPolynomialAdjoin (X (some i)) = Polynomial.C (hx.aevalEquiv (X i))"}, {"line": "rw [AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply]", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhx : AlgebraicIndependent R x\ni : \u03b9\n\u22a2 Polynomial.map (\u2191hx.aevalEquiv) ((aeval fun o => o.elim Polynomial.X fun s => Polynomial.C (X s)) (X (some i))) =\n    Polynomial.C (hx.aevalEquiv (X i))"}, {"line": "rw [aeval_X]", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhx : AlgebraicIndependent R x\ni : \u03b9\n\u22a2 Polynomial.map (\u2191hx.aevalEquiv) ((some i).elim Polynomial.X fun s => Polynomial.C (X s)) =\n    Polynomial.C (hx.aevalEquiv (X i))"}, {"line": "rw [Option.elim]", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhx : AlgebraicIndependent R x\ni : \u03b9\n\u22a2 Polynomial.map (\u2191hx.aevalEquiv) (Polynomial.C (X i)) = Polynomial.C (hx.aevalEquiv (X i))"}, {"line": "rw [Polynomial.map_C]", "tactic_state": "\u03b9 : Type u\nR : Type u_2\nA : Type v\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhx : AlgebraicIndependent R x\ni : \u03b9\n\u22a2 Polynomial.C (\u2191hx.aevalEquiv (X i)) = Polynomial.C (hx.aevalEquiv (X i))"}, {"line": "rw [RingHom.coe_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp (f : \u03b9' \u2192 \u03b9) (hf : Function.Injective f) : AlgebraicIndependent R (x \u2218 f) := by\n  intro p q\n  simpa [aeval_rename, (rename_injective f hf).eq_iff] using @hx (rename f p) (rename f q)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Defs.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra"], "variables": ["{\u03b9 \u03b9' : Type*} (R : Type*) {K A A' : Type*} (x : \u03b9 \u2192 A)", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "{R} {x}", "(hx : AlgebraicIndependent R x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nA : Type u_5\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nf : \u03b9' \u2192 \u03b9\nhf : Injective f\n\u22a2 AlgebraicIndependent R (x \u2218 f)"}, {"line": "intro p q", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nA : Type u_5\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nf : \u03b9' \u2192 \u03b9\nhf : Injective f\np q : MvPolynomial \u03b9' R\n\u22a2 (aeval (x \u2218 f)) p = (aeval (x \u2218 f)) q \u2192 p = q"}, {"line": "simpa [aeval_rename, (rename_injective f hf).eq_iff] using @hx (rename f p) (rename f q)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_range : AlgebraicIndependent R ((\u2191) : range x \u2192 A) := by\n  simpa using hx.comp _ (rangeSplitting_injective x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Defs.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra"], "variables": ["{\u03b9 \u03b9' : Type*} (R : Type*) {K A A' : Type*} (x : \u03b9 \u2192 A)", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "{R} {x}", "(hx : AlgebraicIndependent R x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_3\nA : Type u_5\nx : \u03b9 \u2192 A\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\n\u22a2 AlgebraicIndependent R Subtype.val"}, {"line": "simpa using hx.comp _ (rangeSplitting_injective x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mono {t s : Set A} (h : t \u2286 s)\n    (hx : AlgebraicIndependent R ((\u2191) : s \u2192 A)) : AlgebraicIndependent R ((\u2191) : t \u2192 A) := by\n  simpa [Function.comp] using hx.comp (inclusion h) (inclusion_injective h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Defs.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent"], "variables": ["{\u03b9 \u03b9' : Type*} (R : Type*) {K A A' : Type*} (x : \u03b9 \u2192 A)", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "{R} {x}", "(hx : AlgebraicIndependent R x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nA : Type u_5\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nt s : Set A\nh : t \u2286 s\nhx : AlgebraicIndependent R Subtype.val\n\u22a2 AlgebraicIndependent R Subtype.val"}, {"line": "simpa [Function.comp] using hx.comp (inclusion h) (inclusion_injective h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isTranscendenceBasis_equiv (e : \u03b9 \u2243 \u03b9') {f : \u03b9' \u2192 A} :\n    IsTranscendenceBasis R (f \u2218 e) \u2194 IsTranscendenceBasis R f := by\n  simp_rw [IsTranscendenceBasis, algebraicIndependent_equiv, EquivLike.range_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/Defs.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent"], "variables": ["{\u03b9 \u03b9' : Type*} (R : Type*) {K A A' : Type*} (x : \u03b9 \u2192 A)", "[CommRing R] [CommRing A] [CommRing A'] [Algebra R A] [Algebra R A']", "{R} {x}", "(hx : AlgebraicIndependent R x)", "(hx : AlgebraicIndependent R x)", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nA : Type u_5\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\ne : \u03b9 \u2243 \u03b9'\nf : \u03b9' \u2192 A\n\u22a2 IsTranscendenceBasis R (f \u2218 \u21d1e) \u2194 IsTranscendenceBasis R f"}, {"line": "simp_rw [IsTranscendenceBasis, algebraicIndependent_equiv, EquivLike.range_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_isTranscendenceBasis_superset {s : Set A}\n    (hs : AlgebraicIndepOn R id s) :\n    \u2203 t, s \u2286 t \u2227 IsTranscendenceBasis R ((\u2191) : t \u2192 A) := by\n  simpa [\u2190 isTranscendenceBasis_iff_maximal]\n    using exists_maximal_algebraicIndependent s _ (subset_univ _) hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/TranscendenceBasis.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type u'} (R : Type*) {S : Type v} {A : Type w}", "{x : \u03b9 \u2192 A} {y : \u03b9' \u2192 A}", "[CommRing R] [CommRing S] [CommRing A]", "[Algebra R S] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nA : Type w\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\ns : Set A\nhs : AlgebraicIndepOn R _root_.id s\n\u22a2 \u2203 t, s \u2286 t \u2227 IsTranscendenceBasis R Subtype.val"}, {"line": "simpa [\u2190 isTranscendenceBasis_iff_maximal]\n    using exists_maximal_algebraicIndependent s _ (subset_univ _) hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsTranscendenceBasis.isAlgebraic_field {F E : Type*} {x : \u03b9 \u2192 E}\n    [Field F] [Field E] [Algebra F E] (hx : IsTranscendenceBasis F x) :\n    Algebra.IsAlgebraic (IntermediateField.adjoin F (range x)) E := by\n  haveI := hx.isAlgebraic\n  set S := range x\n  letI : Algebra (adjoin F S) (IntermediateField.adjoin F S) :=\n    (Subalgebra.inclusion (IntermediateField.algebra_adjoin_le_adjoin F S)).toRingHom.toAlgebra\n  haveI : IsScalarTower (adjoin F S) (IntermediateField.adjoin F S) E :=\n    IsScalarTower.of_algebraMap_eq (congrFun rfl)\n  exact Algebra.IsAlgebraic.extendScalars (R := adjoin F S) (Subalgebra.inclusion_injective _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/TranscendenceBasis.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent", "Cardinal in"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type u'} (R : Type*) {S : Type v} {A : Type w}", "{x : \u03b9 \u2192 A} {y : \u03b9' \u2192 A}", "[CommRing R] [CommRing S] [CommRing A]", "[Algebra R S] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "{R} in", "(A)", "{A}", "{R}", "(\u03b9 R)", "{\u03b9 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "inst\u271d\u00b3 : CommRing sorry\n\u03b9 : Type u_3\nF : Type u_1\nE : Type u_2\nx : \u03b9 \u2192 E\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nhx : IsTranscendenceBasis F x\n\u22a2 Algebra.IsAlgebraic (\u21a5(IntermediateField.adjoin F (range x))) E"}, {"line": "haveI := hx.isAlgebraic", "tactic_state": "inst\u271d\u00b3 : CommRing sorry\n\u03b9 : Type u_3\nF : Type u_1\nE : Type u_2\nx : \u03b9 \u2192 E\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nhx : IsTranscendenceBasis F x\nthis : Algebra.IsAlgebraic (\u21a5(adjoin F (range x))) E\n\u22a2 Algebra.IsAlgebraic (\u21a5(IntermediateField.adjoin F (range x))) E"}, {"line": "set S := range x", "tactic_state": "inst\u271d\u00b3 : CommRing sorry\n\u03b9 : Type u_3\nF : Type u_1\nE : Type u_2\nx : \u03b9 \u2192 E\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nhx : IsTranscendenceBasis F x\nS : Set E := range x\nthis : Algebra.IsAlgebraic (\u21a5(adjoin F S)) E\n\u22a2 Algebra.IsAlgebraic (\u21a5(IntermediateField.adjoin F S)) E"}, {"line": "letI : Algebra (adjoin F S) (IntermediateField.adjoin F S) :=\n    (Subalgebra.inclusion (IntermediateField.algebra_adjoin_le_adjoin F S)).toRingHom.toAlgebra", "tactic_state": "inst\u271d\u00b3 : CommRing sorry\n\u03b9 : Type u_3\nF : Type u_1\nE : Type u_2\nx : \u03b9 \u2192 E\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nhx : IsTranscendenceBasis F x\nS : Set E := range x\nthis\u271d : Algebra.IsAlgebraic (\u21a5(adjoin F S)) E\nthis : sorry := sorry\n\u22a2 Algebra.IsAlgebraic (\u21a5(IntermediateField.adjoin F S)) E"}, {"line": "haveI : IsScalarTower (adjoin F S) (IntermediateField.adjoin F S) E :=\n    IsScalarTower.of_algebraMap_eq (congrFun rfl)", "tactic_state": "inst\u271d\u00b3 : CommRing sorry\n\u03b9 : Type u_3\nF : Type u_1\nE : Type u_2\nx : \u03b9 \u2192 E\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nhx : IsTranscendenceBasis F x\nS : Set E := range x\nthis\u271d\u00b9 : Algebra.IsAlgebraic (\u21a5(adjoin F S)) E\nthis\u271d : sorry := sorry\nthis : sorry\n\u22a2 Algebra.IsAlgebraic (\u21a5(IntermediateField.adjoin F S)) E"}, {"line": "exact Algebra.IsAlgebraic.extendScalars (R := adjoin F S) (Subalgebra.inclusion_injective _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Polynomial.trdeg_of_isDomain [IsDomain R] : trdeg R (Polynomial R) = 1 := by\n  simpa using (IsTranscendenceBasis.polynomial Unit R).lift_cardinalMk_eq_trdeg.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/AlgebraicIndependent/TranscendenceBasis.lean", "context": {"open": ["Function Set Subalgebra MvPolynomial Algebra", "AlgebraicIndependent", "Cardinal in", "Cardinal AlgebraicIndependent"], "variables": ["{\u03b9 : Type u} {\u03b9' : Type u'} (R : Type*) {S : Type v} {A : Type w}", "{x : \u03b9 \u2192 A} {y : \u03b9' \u2192 A}", "[CommRing R] [CommRing S] [CommRing A]", "[Algebra R S] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "{R} in", "(A)", "{A}", "{R}", "(\u03b9 R)", "{\u03b9 R}", "(R A) [FaithfulSMul R A]", "[NoZeroDivisors A]", "{R A}", "{R A}", "[Nontrivial R] [NoZeroDivisors A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : IsDomain R\n\u22a2 trdeg R (Polynomial R) = 1"}, {"line": "simpa using (IsTranscendenceBasis.polynomial Unit R).lift_cardinalMk_eq_trdeg.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem set_has_minimal_iff_artinian :\n    (\u2200 a : Set <| Submodule R M, a.Nonempty \u2192 \u2203 M' \u2208 a, \u2200 I \u2208 a, \u00acI < M') \u2194 IsArtinian R M := by\n  rw [isArtinian_iff]\n  rw [WellFounded.wellFounded_iff_has_min]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Artinian/Module.lean", "context": {"open": ["Set Filter Pointwise", "Submodule"], "variables": ["{R M P N : Type*}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid P] [AddCommMonoid N]", "[Module R M] [Module R P] [Module R N]", "(M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u22a2 (\u2200 (a : Set (Submodule R M)), a.Nonempty \u2192 \u2203 M' \u2208 a, \u2200 I \u2208 a, \u00acI < M') \u2194 IsArtinian R M"}, {"line": "rw [isArtinian_iff]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u22a2 (\u2200 (a : Set (Submodule R M)), a.Nonempty \u2192 \u2203 M' \u2208 a, \u2200 I \u2208 a, \u00acI < M') \u2194 WellFounded fun x1 x2 => x1 < x2"}, {"line": "rw [WellFounded.wellFounded_iff_has_min]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventuallyConst_of_isArtinian (f : \u2115 \u2192o (Submodule R M)\u1d52\u1d48) :\n    atTop.EventuallyConst f := by\n  simp_rw [eventuallyConst_atTop, eq_comm]\n  exact monotone_stabilizes f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Artinian/Module.lean", "context": {"open": ["Set Filter Pointwise", "Submodule"], "variables": ["{R M P N : Type*}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid P] [AddCommMonoid N]", "[Module R M] [Module R P] [Module R N]", "(M) in", "[IsArtinian R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nf : \u2115 \u2192o (Submodule R M)\u1d52\u1d48\n\u22a2 EventuallyConst (\u21d1f) atTop"}, {"line": "simp_rw [eventuallyConst_atTop, eq_comm]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nf : \u2115 \u2192o (Submodule R M)\u1d52\u1d48\n\u22a2 \u2203 i, \u2200 (j : \u2115), i \u2264 j \u2192 f i = f j"}, {"line": "exact monotone_stabilizes f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_isCompl_ker_pow_range_pow [IsNoetherian R M] (f : Module.End R M) :\n    \u2200\u1da0 n in atTop, IsCompl (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) := by\n  filter_upwards [f.eventually_disjoint_ker_pow_range_pow.and\n    f.eventually_codisjoint_ker_pow_range_pow] with n hn\n  simpa only [isCompl_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Artinian/Module.lean", "context": {"open": ["Set Filter Pointwise", "Submodule", "Function", "Submodule Function"], "variables": ["{R M P N : Type*}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid P] [AddCommMonoid N]", "[Module R M] [Module R P] [Module R N]", "(M) in", "[IsArtinian R M]", "[IsArtinian R M]", "{R M P N : Type*}", "[Ring R] [AddCommGroup M] [AddCommGroup P] [AddCommGroup N]", "[Module R M] [Module R P] [Module R N]", "{\u03b9 : Type*} [Finite \u03b9]", "(R M) in", "[IsArtinian R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\nM : Type u_6\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsNoetherian R M\nf : Module.End R M\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, IsCompl (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n))"}, {"line": "filter_upwards [f.eventually_disjoint_ker_pow_range_pow.and\n    f.eventually_codisjoint_ker_pow_range_pow] with n hn", "tactic_state": "case h\nR : Type u_5\nM : Type u_6\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsNoetherian R M\nf : Module.End R M\nn : \u2115\nhn : n \u2208 ?m.24603\n\u22a2 IsCompl (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n))"}, {"line": "simpa only [isCompl_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Function.Surjective.isArtinianRing {R} [Semiring R] {S} [Semiring S] {F}\n    [FunLike F R S] [RingHomClass F R S]\n    {f : F} (hf : Function.Surjective f) [H : IsArtinianRing R] : IsArtinianRing S := by\n  rw [isArtinianRing_iff] at H \u22a2\n  exact \u27e8(Ideal.orderEmbeddingOfSurjective f hf).wellFounded H.wf\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Artinian/Module.lean", "context": {"open": ["Set Filter Pointwise", "Submodule", "Function", "Submodule Function", "Submodule Function"], "variables": ["{R M P N : Type*}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid P] [AddCommMonoid N]", "[Module R M] [Module R P] [Module R N]", "(M) in", "[IsArtinian R M]", "[IsArtinian R M]", "{R M P N : Type*}", "[Ring R] [AddCommGroup M] [AddCommGroup P] [AddCommGroup N]", "[Module R M] [Module R P] [Module R N]", "{\u03b9 : Type*} [Finite \u03b9]", "(R M) in", "[IsArtinian R M]", "{R : Type*} (M : Type*) [CommSemiring R] [AddCommMonoid M] [Module R M] [IsArtinian R M]", "{M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_12\ninst\u271d\u00b3 : Semiring R\nS : Type u_13\ninst\u271d\u00b2 : Semiring S\nF : Type u_14\ninst\u271d\u00b9 : FunLike F R S\ninst\u271d : RingHomClass F R S\nf : F\nhf : Surjective \u21d1f\nH : IsArtinianRing R\n\u22a2 IsArtinianRing S"}, {"line": "rw [isArtinianRing_iff] at H \u22a2", "tactic_state": "R : Type u_12\ninst\u271d\u00b3 : Semiring R\nS : Type u_13\ninst\u271d\u00b2 : Semiring S\nF : Type u_14\ninst\u271d\u00b9 : FunLike F R S\ninst\u271d : RingHomClass F R S\nf : F\nhf : Surjective \u21d1f\nH : IsArtinian R R\n\u22a2 IsArtinian S S"}, {"line": "exact \u27e8(Ideal.orderEmbeddingOfSurjective f hf).wellFounded H.wf\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma setOf_isPrime_finite : {I : Ideal R | I.IsPrime}.Finite := by\n  simpa only [isPrime_iff_isMaximal] using setOf_isMaximal_finite R\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Artinian/Module.lean", "context": {"open": ["Set Filter Pointwise", "Submodule", "Function", "Submodule Function", "Submodule Function"], "variables": ["{R M P N : Type*}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid P] [AddCommMonoid N]", "[Module R M] [Module R P] [Module R N]", "(M) in", "[IsArtinian R M]", "[IsArtinian R M]", "{R M P N : Type*}", "[Ring R] [AddCommGroup M] [AddCommGroup P] [AddCommGroup N]", "[Module R M] [Module R P] [Module R N]", "{\u03b9 : Type*} [Finite \u03b9]", "(R M) in", "[IsArtinian R M]", "{R : Type*} (M : Type*) [CommSemiring R] [AddCommMonoid M] [Module R M] [IsArtinian R M]", "{M}", "(R : Type*) [CommSemiring R] [IsArtinianRing R]", "{R : Type*} [CommRing R] [IsArtinianRing R]", "(R) in", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_13\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsArtinianRing R\n\u22a2 {I | I.IsPrime}.Finite"}, {"line": "simpa only [isPrime_iff_isMaximal] using setOf_isMaximal_finite R", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toAlgHom_toLinearMap (f : A \u2192\u2090c[R] B) :\n    ((f : A \u2192\u2090[R] B) : A \u2192\u2097[R] B) = f := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Bialgebra/Hom.lean", "context": {"open": ["TensorProduct Bialgebra Coalgebra"], "variables": ["{R A B F : Type*}", "[CommSemiring R] [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]", "[CommSemiring R] [Semiring A] [Bialgebra R A] [Semiring B] [Bialgebra R B]", "{R A B C D : Type*} [CommSemiring R] [Semiring A] [Algebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : sorry\n\u22a2 f = f"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sum_counit_tmul_eq {a : A} (repr : Coalgebra.Repr R a) :\n    \u2211 i \u2208 repr.index, counit (R := R) (repr.left i) \u2297\u209c (repr.right i) = 1 \u2297\u209c[R] a := by\n  simpa [\u2190 repr.eq, map_sum] using congr($(rTensor_counit_comp_comul (R := R) (A := A)) a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coalgebra/Basic.lean", "context": {"open": ["scoped TensorProduct"], "variables": ["{R : Type u} {A : Type v}", "[CommSemiring R] [AddCommMonoid A] [Module R A] [Coalgebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid A\ninst\u271d\u00b9 : Module R A\ninst\u271d : Coalgebra R A\nx\u271d : Sort u_1\ncounit : x\u271d\na : A\nrepr : Coalgebra.Repr R a\n\u22a2 \u2211 i \u2208 repr.index, sorry \u2297\u209c[R] repr.right i = 1 \u2297\u209c[R] a"}, {"line": "simpa [\u2190 repr.eq, map_sum] using congr($(rTensor_counit_comp_comul (R := R) (A := A)) a)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sum_tmul_counit_eq {a : A} (repr : Coalgebra.Repr R a) :\n    \u2211 i \u2208 repr.index, (repr.left i) \u2297\u209c counit (R := R) (repr.right i) = a \u2297\u209c[R] 1 := by\n  simpa [\u2190 repr.eq, map_sum] using congr($(lTensor_counit_comp_comul (R := R) (A := A)) a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coalgebra/Basic.lean", "context": {"open": ["scoped TensorProduct"], "variables": ["{R : Type u} {A : Type v}", "[CommSemiring R] [AddCommMonoid A] [Module R A] [Coalgebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid A\ninst\u271d\u00b9 : Module R A\ninst\u271d : Coalgebra R A\nx\u271d : Sort u_1\ncounit : x\u271d\na : A\nrepr : Coalgebra.Repr R a\n\u22a2 \u2211 i \u2208 repr.index, repr.left i \u2297\u209c[R] sorry = a \u2297\u209c[R] 1"}, {"line": "simpa [\u2190 repr.eq, map_sum] using congr($(lTensor_counit_comp_comul (R := R) (A := A)) a)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sum_tmul_tmul_eq {a : A} (repr : Repr R a)\n    (a\u2081 : (i : repr.\u03b9) \u2192 Repr R (repr.left i)) (a\u2082 : (i : repr.\u03b9) \u2192 Repr R (repr.right i)) :\n    \u2211 i \u2208 repr.index, \u2211 j \u2208 (a\u2081 i).index,\n      (a\u2081 i).left j \u2297\u209c[R] (a\u2081 i).right j \u2297\u209c[R] repr.right i\n      = \u2211 i \u2208 repr.index, \u2211 j \u2208 (a\u2082 i).index,\n      repr.left i \u2297\u209c[R] (a\u2082 i).left j \u2297\u209c[R] (a\u2082 i).right j := by\n  simpa [(a\u2082 _).eq, \u2190 (a\u2081 _).eq, \u2190 TensorProduct.tmul_sum,\n    TensorProduct.sum_tmul, \u2190 repr.eq] using congr($(coassoc (R := R)) a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coalgebra/Basic.lean", "context": {"open": ["scoped TensorProduct"], "variables": ["{R : Type u} {A : Type v}", "[CommSemiring R] [AddCommMonoid A] [Module R A] [Coalgebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid A\ninst\u271d\u00b9 : Module R A\ninst\u271d : Coalgebra R A\na : A\nrepr : sorry\na\u2081 : sorry \u2192 sorry\na\u2082 : sorry \u2192 sorry\n\u22a2 \u2211 i \u2208 sorry, \u2211 j \u2208 sorry, sorry \u2297\u209c[R] sorry \u2297\u209c[R] sorry = \u2211 i \u2208 sorry, \u2211 j \u2208 sorry, sorry \u2297\u209c[R] sorry \u2297\u209c[R] sorry"}, {"line": "simpa [(a\u2082 _).eq, \u2190 (a\u2081 _).eq, \u2190 TensorProduct.tmul_sum,\n    TensorProduct.sum_tmul, \u2190 repr.eq] using congr($(coassoc (R := R)) a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comul_C_mul_T_self (a : R) (n : \u2124) :\n    Coalgebra.comul (C a * T n) = T n \u2297\u209c[R] (C a * T n) := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coalgebra/MonoidAlgebra.lean", "context": {"open": ["AddMonoidAlgebra"], "variables": ["{R : Type*} [CommSemiring R] {A : Type*} [Semiring A]", "(R A X) in", "{R : Type*} [CommSemiring R] {A : Type*} [Semiring A]", "(R A X) in", "(R A : Type*) [CommSemiring R] [Semiring A] [Module R A] [Coalgebra R A]", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\nx\u271d\u00b9 : Sort u_3\nC : x\u271d\u00b9\nx\u271d : Sort u_4\nT : x\u271d\na : R\nn : \u2124\n\u22a2 CoalgebraStruct.comul (sorry * sorry) = sorry \u2297\u209c[R] (sorry * sorry)"}, {"line": "simp", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\nx\u271d\u00b9 : Sort u_3\nC : x\u271d\u00b9\nx\u271d : Sort u_4\nT : x\u271d\na : R\nn : \u2124\n\u22a2 CoalgebraStruct.comul (sorry () * sorry ()) = sorry () \u2297\u209c[R] (sorry () * sorry ())"}]}
{"declaration": "theorem counit_C_mul_T (a : A) (n : \u2124) :\n    Coalgebra.counit (R := R) (C a * T n) = Coalgebra.counit (R := R) a := by\n  simp [\u2190 single_eq_C_mul_T]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coalgebra/MonoidAlgebra.lean", "context": {"open": ["AddMonoidAlgebra"], "variables": ["{R : Type*} [CommSemiring R] {A : Type*} [Semiring A]", "(R A X) in", "{R : Type*} [CommSemiring R] {A : Type*} [Semiring A]", "(R A X) in", "(R A : Type*) [CommSemiring R] [Semiring A] [Module R A] [Coalgebra R A]", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\nA : Type u_2\ninst\u271d : Semiring A\nx\u271d\u00b9 : Sort u_3\nC : x\u271d\u00b9\nx\u271d : Sort u_4\nT : x\u271d\na : A\nn : \u2124\n\u22a2 CoalgebraStruct.counit (sorry * sorry) = CoalgebraStruct.counit a"}, {"line": "simp [\u2190 single_eq_C_mul_T]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\nA : Type u_2\ninst\u271d : Semiring A\nx\u271d\u00b9 : Sort u_3\nC : x\u271d\u00b9\nx\u271d : Sort u_4\nT : x\u271d\na : A\nn : \u2124\n\u22a2 CoalgebraStruct.counit (sorry () * sorry ()) = CoalgebraStruct.counit a"}]}
{"declaration": "theorem nontrivial_iff : Nontrivial (RingCon R) \u2194 Nontrivial R := by\n  cases subsingleton_or_nontrivial R\n  on_goal 1 => simp_rw [\u2190 not_subsingleton_iff_nontrivial, not_iff_not]\n  all_goals exact iff_of_true inferInstance \u2039_\u203a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Congruence/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 R : Type*}", "[Add R] [MulOneClass R]", "[SMul \u03b1 R] [IsScalarTower \u03b1 R R]", "[SMul \u03b2 R] [IsScalarTower \u03b2 R R]", "(c : RingCon R)", "[Add R] [Mul R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : Add R\ninst\u271d\u00b2 : MulOneClass R\ninst\u271d\u00b9 : Add R\ninst\u271d : Mul R\n\u22a2 Nontrivial (RingCon R) \u2194 Nontrivial R"}, {"line": "cases subsingleton_or_nontrivial R", "tactic_state": "case inl\nR : Type u_3\ninst\u271d\u00b3 : Add R\ninst\u271d\u00b2 : MulOneClass R\ninst\u271d\u00b9 : Add R\ninst\u271d : Mul R\nh\u271d : Subsingleton R\n\u22a2 Nontrivial (RingCon R) \u2194 Nontrivial R\n---\ncase inr\nR : Type u_3\ninst\u271d\u00b3 : Add R\ninst\u271d\u00b2 : MulOneClass R\ninst\u271d\u00b9 : Add R\ninst\u271d : Mul R\nh\u271d : Nontrivial R\n\u22a2 Nontrivial (RingCon R) \u2194 Nontrivial R"}, {"line": "on_goal 1 => simp_rw [\u2190 not_subsingleton_iff_nontrivial, not_iff_not]", "tactic_state": "case inl\nR : Type u_3\ninst\u271d\u00b3 : Add R\ninst\u271d\u00b2 : MulOneClass R\ninst\u271d\u00b9 : Add R\ninst\u271d : Mul R\nh\u271d : Subsingleton R\n\u22a2 Subsingleton (RingCon R) \u2194 Subsingleton R\n---\ncase inr\nR : Type u_3\ninst\u271d\u00b3 : Add R\ninst\u271d\u00b2 : MulOneClass R\ninst\u271d\u00b9 : Add R\ninst\u271d : Mul R\nh\u271d : Nontrivial R\n\u22a2 Nontrivial (RingCon R) \u2194 Nontrivial R"}, {"line": "all_goals exact iff_of_true inferInstance \u2039_\u203a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subsingleton_iff : Subsingleton (RingCon R) \u2194 Subsingleton R := by\n  simp_rw [\u2190 not_nontrivial_iff_subsingleton, nontrivial_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Congruence/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 R : Type*}", "[Add R] [MulOneClass R]", "[SMul \u03b1 R] [IsScalarTower \u03b1 R R]", "[SMul \u03b2 R] [IsScalarTower \u03b2 R R]", "(c : RingCon R)", "[Add R] [Mul R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : Add R\ninst\u271d\u00b2 : MulOneClass R\ninst\u271d\u00b9 : Add R\ninst\u271d : Mul R\n\u22a2 Subsingleton (RingCon R) \u2194 Subsingleton R"}, {"line": "simp_rw [\u2190 not_nontrivial_iff_subsingleton, nontrivial_iff]", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : Add R\ninst\u271d\u00b2 : MulOneClass R\ninst\u271d\u00b9 : Add R\ninst\u271d : Mul R\n\u22a2 (\u00ac\u2203 x y, x \u2260 y) \u2194 \u00ac\u2203 x y, x \u2260 y"}]}
{"declaration": "theorem Nat.isCoprime_iff_coprime {m n : \u2115} : IsCoprime (m : \u2124) n \u2194 Nat.Coprime m n := by\n  rw [Int.isCoprime_iff_gcd_eq_one]\n  rw [Int.gcd_natCast_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coprime/Lemmas.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation"], "variables": ["{R : Type u} {I : Type v} [CommSemiring R] {x y z : R} {s : I \u2192 R} {t : Finset I}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 IsCoprime \u2191m \u2191n \u2194 m.Coprime n"}, {"line": "rw [Int.isCoprime_iff_gcd_eq_one]", "tactic_state": "m n : \u2115\n\u22a2 (\u2191m).gcd \u2191n = 1 \u2194 m.Coprime n"}, {"line": "rw [Int.gcd_natCast_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nat.Coprime.cast {R : Type*} [CommRing R] {a b : \u2115} (h : Nat.Coprime a b) :\n    IsCoprime (a : R) (b : R) := by\n  rw [\u2190 isCoprime_iff_coprime] at h\n  rw [\u2190 Int.cast_natCast a]\n  rw [\u2190 Int.cast_natCast b]\n  exact IsCoprime.intCast h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coprime/Lemmas.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation"], "variables": ["{R : Type u} {I : Type v} [CommSemiring R] {x y z : R} {s : I \u2192 R} {t : Finset I}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b : \u2115\nh : a.Coprime b\n\u22a2 IsCoprime \u2191a \u2191b"}, {"line": "rw [\u2190 isCoprime_iff_coprime] at h", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b : \u2115\nh : IsCoprime \u2191a \u2191b\n\u22a2 IsCoprime \u2191a \u2191b"}, {"line": "rw [\u2190 Int.cast_natCast a]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b : \u2115\nh : IsCoprime \u2191a \u2191b\n\u22a2 IsCoprime \u2191\u2191a \u2191b"}, {"line": "rw [\u2190 Int.cast_natCast b]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b : \u2115\nh : IsCoprime \u2191a \u2191b\n\u22a2 IsCoprime \u2191\u2191a \u2191\u2191b"}, {"line": "exact IsCoprime.intCast h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCoprime.prod_right : (\u2200 i \u2208 t, IsCoprime x (s i)) \u2192 IsCoprime x (\u220f i \u2208 t, s i) := by\n  simpa only [isCoprime_comm] using IsCoprime.prod_left (R := R)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coprime/Lemmas.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation"], "variables": ["{R : Type u} {I : Type v} [CommSemiring R] {x y z : R} {s : I \u2192 R} {t : Finset I}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nI : Type v\ninst\u271d : CommSemiring R\nx : R\ns : I \u2192 R\nt : Finset I\n\u22a2 (\u2200 i \u2208 t, IsCoprime x (s i)) \u2192 IsCoprime x (\u220f i \u2208 t, s i)"}, {"line": "simpa only [isCoprime_comm] using IsCoprime.prod_left (R := R)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCoprime.prod_right_iff : IsCoprime x (\u220f i \u2208 t, s i) \u2194 \u2200 i \u2208 t, IsCoprime x (s i) := by\n  simpa only [isCoprime_comm] using IsCoprime.prod_left_iff (R := R)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coprime/Lemmas.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation"], "variables": ["{R : Type u} {I : Type v} [CommSemiring R] {x y z : R} {s : I \u2192 R} {t : Finset I}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nI : Type v\ninst\u271d : CommSemiring R\nx : R\ns : I \u2192 R\nt : Finset I\n\u22a2 IsCoprime x (\u220f i \u2208 t, s i) \u2194 \u2200 i \u2208 t, IsCoprime x (s i)"}, {"line": "simpa only [isCoprime_comm] using IsCoprime.prod_left_iff (R := R)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsRelPrime.prod_right : (\u2200 i \u2208 t, IsRelPrime x (s i)) \u2192 IsRelPrime x (\u220f i \u2208 t, s i) := by\n  simpa only [isRelPrime_comm] using IsRelPrime.prod_left (\u03b1 := \u03b1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coprime/Lemmas.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation", "Finset"], "variables": ["{R : Type u} {I : Type v} [CommSemiring R] {x y z : R} {s : I \u2192 R} {t : Finset I}", "{m n : \u2115}", "{\u03b1 I} [CommMonoid \u03b1] [DecompositionMonoid \u03b1] {x y z : \u03b1} {s : I \u2192 \u03b1} {t : Finset I}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nI : Type v\ninst\u271d : CommSemiring R\nx : R\ns : I \u2192 R\nt : Finset I\n\u22a2 (\u2200 i \u2208 t, IsRelPrime x (s i)) \u2192 IsRelPrime x (\u220f i \u2208 t, s i)"}, {"line": "simpa only [isRelPrime_comm] using IsRelPrime.prod_left (\u03b1 := \u03b1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsRelPrime.prod_right_iff : IsRelPrime x (\u220f i \u2208 t, s i) \u2194 \u2200 i \u2208 t, IsRelPrime x (s i) := by\n  simpa only [isRelPrime_comm] using IsRelPrime.prod_left_iff (\u03b1 := \u03b1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coprime/Lemmas.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation", "Finset"], "variables": ["{R : Type u} {I : Type v} [CommSemiring R] {x y z : R} {s : I \u2192 R} {t : Finset I}", "{m n : \u2115}", "{\u03b1 I} [CommMonoid \u03b1] [DecompositionMonoid \u03b1] {x y z : \u03b1} {s : I \u2192 \u03b1} {t : Finset I}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nI : Type v\ninst\u271d : CommSemiring R\nx : R\ns : I \u2192 R\nt : Finset I\n\u22a2 IsRelPrime x (\u220f i \u2208 t, s i) \u2194 \u2200 i \u2208 t, IsRelPrime x (s i)"}, {"line": "simpa only [isRelPrime_comm] using IsRelPrime.prod_left_iff (\u03b1 := \u03b1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCoprime.ne_zero [Nontrivial R] {p : Fin 2 \u2192 R} (h : IsCoprime (p 0) (p 1)) : p \u2260 0 := by\n  rintro rfl\n  exact not_isCoprime_zero_zero h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coprime/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (x y z : R)", "{x y z}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Nontrivial R\np : Fin 2 \u2192 R\nh : IsCoprime (p 0) (p 1)\n\u22a2 p \u2260 0"}, {"line": "rintro rfl", "tactic_state": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Nontrivial R\nh : IsCoprime (0 0) (0 1)\n\u22a2 False"}, {"line": "exact not_isCoprime_zero_zero h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCoprime.ne_zero_or_ne_zero [Nontrivial R] (h : IsCoprime x y) : x \u2260 0 \u2228 y \u2260 0 := by\n  apply not_or_of_imp\n  rintro rfl rfl\n  exact not_isCoprime_zero_zero h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coprime/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (x y z : R)", "{x y z}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\nx y : R\ninst\u271d : Nontrivial R\nh : IsCoprime x y\n\u22a2 x \u2260 0 \u2228 y \u2260 0"}, {"line": "apply not_or_of_imp", "tactic_state": "case a\nR : Type u\ninst\u271d\u00b9 : CommSemiring R\nx y : R\ninst\u271d : Nontrivial R\nh : IsCoprime x y\n\u22a2 x = 0 \u2192 y \u2260 0"}, {"line": "rintro rfl rfl", "tactic_state": "case a\nR : Type u\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Nontrivial R\nh : IsCoprime 0 0\n\u22a2 False"}, {"line": "exact not_isCoprime_zero_zero h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCoprime.mul_right (H1 : IsCoprime x y) (H2 : IsCoprime x z) : IsCoprime x (y * z) := by\n  rw [isCoprime_comm] at H1 H2 \u22a2\n  exact H1.mul_left H2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coprime/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (x y z : R)", "{x y z}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nH1 : IsCoprime x y\nH2 : IsCoprime x z\n\u22a2 IsCoprime x (y * z)"}, {"line": "rw [isCoprime_comm] at H1 H2 \u22a2", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nH1 : IsCoprime y x\nH2 : IsCoprime z x\n\u22a2 IsCoprime (y * z) x"}, {"line": "exact H1.mul_left H2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCoprime.of_mul_right_left (H : IsCoprime x (y * z)) : IsCoprime x y := by\n  rw [isCoprime_comm] at H \u22a2\n  exact H.of_mul_left_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coprime/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (x y z : R)", "{x y z}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nH : IsCoprime x (y * z)\n\u22a2 IsCoprime x y"}, {"line": "rw [isCoprime_comm] at H \u22a2", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nH : IsCoprime (y * z) x\n\u22a2 IsCoprime y x"}, {"line": "exact H.of_mul_left_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCoprime.of_isCoprime_of_dvd_left (h : IsCoprime y z) (hdvd : x \u2223 y) : IsCoprime x z := by\n  obtain \u27e8d, rfl\u27e9 := hdvd\n  exact IsCoprime.of_mul_left_left h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coprime/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (x y z : R)", "{x y z}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime y z\nhdvd : x \u2223 y\n\u22a2 IsCoprime x z"}, {"line": "obtain \u27e8d, rfl\u27e9 := hdvd", "tactic_state": "case intro\nR : Type u\ninst\u271d : CommSemiring R\nx z d : R\nh : IsCoprime (x * d) z\n\u22a2 IsCoprime x z"}, {"line": "exact IsCoprime.of_mul_left_left h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCoprime.of_add_mul_left_right (h : IsCoprime x (y + x * z)) : IsCoprime x y := by\n  rw [isCoprime_comm] at h \u22a2\n  exact h.of_add_mul_left_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coprime/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (x y z : R)", "{x y z}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime x (y + x * z)\n\u22a2 IsCoprime x y"}, {"line": "rw [isCoprime_comm] at h \u22a2", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime (y + x * z) x\n\u22a2 IsCoprime y x"}, {"line": "exact h.of_add_mul_left_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_mul_left_right {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime x (y + x * z) := by\n  rw [isCoprime_comm]\n  exact h.symm.add_mul_left_left z\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coprime/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (x y z : R)", "{x y z}", "{R G : Type*} [CommSemiring R] [Group G] [MulAction G R] [SMulCommClass G R R]", "{R : Type*} [CommSemiring R] {x u v : R}", "{R : Type u} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n\u22a2 IsCoprime x (y + x * z)"}, {"line": "rw [isCoprime_comm]", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n\u22a2 IsCoprime (y + x * z) x"}, {"line": "exact h.symm.add_mul_left_left z", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_mul_right_right {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime x (y + z * x) := by\n  rw [isCoprime_comm]\n  exact h.symm.add_mul_right_left z\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coprime/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (x y z : R)", "{x y z}", "{R G : Type*} [CommSemiring R] [Group G] [MulAction G R] [SMulCommClass G R R]", "{R : Type*} [CommSemiring R] {x u v : R}", "{R : Type u} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n\u22a2 IsCoprime x (y + z * x)"}, {"line": "rw [isCoprime_comm]", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n\u22a2 IsCoprime (y + z * x) x"}, {"line": "exact h.symm.add_mul_right_left z", "tactic_state": "No Goals!"}]}
{"declaration": "lemma abs_right_iff (x y : R) : IsCoprime x |y| \u2194 IsCoprime x y := by\n  rw [isCoprime_comm]\n  rw [IsCoprime.abs_left_iff]\n  rw [isCoprime_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coprime/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (x y z : R)", "{x y z}", "{R G : Type*} [CommSemiring R] [Group G] [MulAction G R] [SMulCommClass G R R]", "{R : Type*} [CommSemiring R] {x u v : R}", "{R : Type u} [CommRing R]", "[LinearOrder R] [AddLeftMono R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : AddLeftMono R\nx y : R\n\u22a2 IsCoprime x |y| \u2194 IsCoprime x y"}, {"line": "rw [isCoprime_comm]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : AddLeftMono R\nx y : R\n\u22a2 IsCoprime |y| x \u2194 IsCoprime x y"}, {"line": "rw [IsCoprime.abs_left_iff]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : AddLeftMono R\nx y : R\n\u22a2 IsCoprime y x \u2194 IsCoprime x y\n---\nR : Type u\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : AddLeftMono R\nx y : R\n\u22a2 AddLeftMono R"}, {"line": "rw [isCoprime_comm]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : AddLeftMono R\nx y : R\n\u22a2 AddLeftMono R"}]}
{"declaration": "lemma PNat.isCoprime_iff {m n : \u2115+} : IsCoprime (m : \u2115) n \u2194 m = 1 \u2228 n = 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Coprime/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (x y z : R)", "{x y z}", "{R G : Type*} [CommSemiring R] [Group G] [MulAction G R] [SMulCommClass G R R]", "{R : Type*} [CommSemiring R] {x u v : R}", "{R : Type u} [CommRing R]", "[LinearOrder R] [AddLeftMono R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115+\n\u22a2 IsCoprime \u2191m \u2191n \u2194 m = 1 \u2228 n = 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsIntegralClosure.finite [IsIntegrallyClosed A] [IsNoetherianRing A] :\n    Module.Finite A C := by\n  haveI := IsIntegralClosure.isNoetherian A K L C\n  exact Module.IsNoetherian.finite A C\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/DedekindDomain/IntegralClosure.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "Algebra"], "variables": ["(A K : Type*) [CommRing A] [Field K]", "[Algebra A K] [IsFractionRing A K]", "(L : Type*) [Field L] (C : Type*) [CommRing C]", "[Algebra K L] [Algebra A L] [IsScalarTower A K L]", "[Algebra C L] [IsIntegralClosure C A L] [Algebra A C] [IsScalarTower A C L]", "[FiniteDimensional K L]", "{A K L}", "[IsDomain A]", "(A K)", "(L)", "[Algebra.IsSeparable K L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\ninst\u271d\u2075 : CommRing A\nC : Type u_4\ninst\u271d\u2074 : CommRing C\ninst\u271d\u00b3 : Algebra A C\ninst\u271d\u00b2 : IsDomain A\ninst\u271d\u00b9 : IsIntegrallyClosed A\ninst\u271d : IsNoetherianRing A\n\u22a2 Module.Finite A C"}, {"line": "haveI := IsIntegralClosure.isNoetherian A K L C", "tactic_state": "case refine_4\nA : Type u_1\ninst\u271d\u2075 : CommRing A\nC : Type u_4\ninst\u271d\u2074 : CommRing C\ninst\u271d\u00b3 : Algebra A C\ninst\u271d\u00b2 : IsDomain A\ninst\u271d\u00b9 : IsIntegrallyClosed A\ninst\u271d : IsNoetherianRing A\nthis : IsNoetherian A C\n\u22a2 Module.Finite A C\n---\ncase refine_1\nA : Type u_1\ninst\u271d\u2075 : CommRing A\nC : Type u_4\ninst\u271d\u2074 : CommRing C\ninst\u271d\u00b3 : Algebra A C\ninst\u271d\u00b2 : IsDomain A\ninst\u271d\u00b9 : IsIntegrallyClosed A\ninst\u271d : IsNoetherianRing A\n\u22a2 CommRing A\n---\ncase refine_2\nA : Type u_1\ninst\u271d\u2075 : CommRing A\nC : Type u_4\ninst\u271d\u2074 : CommRing C\ninst\u271d\u00b3 : Algebra A C\ninst\u271d\u00b2 : IsDomain A\ninst\u271d\u00b9 : IsIntegrallyClosed A\ninst\u271d : IsNoetherianRing A\n\u22a2 CommRing C\n---\ncase refine_3\nA : Type u_1\ninst\u271d\u2075 : CommRing A\nC : Type u_4\ninst\u271d\u2074 : CommRing C\ninst\u271d\u00b3 : Algebra A C\ninst\u271d\u00b2 : IsDomain A\ninst\u271d\u00b9 : IsIntegrallyClosed A\ninst\u271d : IsNoetherianRing A\n\u22a2 Algebra A C"}, {"line": "exact Module.IsNoetherian.finite A C", "tactic_state": "case refine_1\nA : Type u_1\ninst\u271d\u2075 : CommRing A\nC : Type u_4\ninst\u271d\u2074 : CommRing C\ninst\u271d\u00b3 : Algebra A C\ninst\u271d\u00b2 : IsDomain A\ninst\u271d\u00b9 : IsIntegrallyClosed A\ninst\u271d : IsNoetherianRing A\n\u22a2 CommRing A\n---\ncase refine_2\nA : Type u_1\ninst\u271d\u2075 : CommRing A\nC : Type u_4\ninst\u271d\u2074 : CommRing C\ninst\u271d\u00b3 : Algebra A C\ninst\u271d\u00b2 : IsDomain A\ninst\u271d\u00b9 : IsIntegrallyClosed A\ninst\u271d : IsNoetherianRing A\n\u22a2 CommRing C\n---\ncase refine_3\nA : Type u_1\ninst\u271d\u2075 : CommRing A\nC : Type u_4\ninst\u271d\u2074 : CommRing C\ninst\u271d\u00b3 : Algebra A C\ninst\u271d\u00b2 : IsDomain A\ninst\u271d\u00b9 : IsIntegrallyClosed A\ninst\u271d : IsNoetherianRing A\n\u22a2 Algebra A C"}]}
{"declaration": "theorem intValuation.le_max_iff_min_le {a b c : \u2115} :\n    Multiplicative.ofAdd (-c : \u2124) \u2264\n      max (Multiplicative.ofAdd (-a : \u2124)) (Multiplicative.ofAdd (-b : \u2124)) \u2194\n      min a b \u2264 c := by\n  rw [le_max_iff]\n  rw [ofAdd_le]\n  rw [ofAdd_le]\n  rw [neg_le_neg_iff]\n  rw [neg_le_neg_iff]\n  rw [Int.ofNat_le]\n  rw [Int.ofNat_le]\n  rw [\u2190     min_le_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/DedekindDomain/AdicValuation.lean", "context": {"open": ["scoped Multiplicative", "Multiplicative IsDedekindDomain", "scoped Classical in", "scoped Classical in"], "variables": ["{R : Type*} [CommRing R] [IsDedekindDomain R] {K S : Type*} [Field K] [CommSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\n\u22a2 ofAdd (-\u2191c) \u2264 max (ofAdd (-\u2191a)) (ofAdd (-\u2191b)) \u2194 min a b \u2264 c"}, {"line": "rw [le_max_iff]", "tactic_state": "a b c : \u2115\n\u22a2 ofAdd (-\u2191c) \u2264 ofAdd (-\u2191a) \u2228 ofAdd (-\u2191c) \u2264 ofAdd (-\u2191b) \u2194 min a b \u2264 c"}, {"line": "rw [ofAdd_le]", "tactic_state": "a b c : \u2115\n\u22a2 -\u2191c \u2264 -\u2191a \u2228 ofAdd (-\u2191c) \u2264 ofAdd (-\u2191b) \u2194 min a b \u2264 c"}, {"line": "rw [ofAdd_le]", "tactic_state": "a b c : \u2115\n\u22a2 -\u2191c \u2264 -\u2191a \u2228 -\u2191c \u2264 -\u2191b \u2194 min a b \u2264 c"}, {"line": "rw [neg_le_neg_iff]", "tactic_state": "a b c : \u2115\n\u22a2 \u2191a \u2264 \u2191c \u2228 -\u2191c \u2264 -\u2191b \u2194 min a b \u2264 c"}, {"line": "rw [neg_le_neg_iff]", "tactic_state": "a b c : \u2115\n\u22a2 \u2191a \u2264 \u2191c \u2228 \u2191b \u2264 \u2191c \u2194 min a b \u2264 c"}, {"line": "rw [Int.ofNat_le]", "tactic_state": "a b c : \u2115\n\u22a2 a \u2264 c \u2228 \u2191b \u2264 \u2191c \u2194 min a b \u2264 c"}, {"line": "rw [Int.ofNat_le]", "tactic_state": "a b c : \u2115\n\u22a2 a \u2264 c \u2228 b \u2264 c \u2194 min a b \u2264 c"}, {"line": "rw [\u2190     min_le_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem count_maximal (w : HeightOneSpectrum R) [Decidable (w = v)] :\n    count K v (w.asIdeal : FractionalIdeal R\u2070 K) = if w = v then 1 else 0 := by\n  split_ifs with h\n  \u00b7 rw [h, count_self]\n  \u00b7 exact count_maximal_coprime K v h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/DedekindDomain/Factorization.lean", "context": {"open": ["scoped nonZeroDivisors", "Set Function UniqueFactorizationMonoid IsDedekindDomain IsDedekindDomain.HeightOneSpectrum", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "Int IsLocalization", "scoped Classical in", "scoped Classical in", "Classical in", "Classical in", "Classical in", "Classical in"], "variables": ["{R : Type*} [CommRing R] {K : Type*} [Field K] [Algebra R K] [IsFractionRing R K]", "[IsDedekindDomain R] (v : HeightOneSpectrum R)", "(K)", "(K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nv : sorry\nx\u271d : Sort u_2\ncount : x\u271d\nw : sorry\ninst\u271d : Decidable (w = v)\n\u22a2 sorry = if w = v then 1 else 0"}, {"line": "split_ifs with h", "tactic_state": "case pos\nR : Type u_1\nv : sorry\nx\u271d : Sort u_2\ncount : x\u271d\nw : sorry\ninst\u271d : Decidable (w = v)\nh : w = v\n\u22a2 sorry = 1\n---\ncase neg\nR : Type u_1\nv : sorry\nx\u271d : Sort u_2\ncount : x\u271d\nw : sorry\ninst\u271d : Decidable (w = v)\nh : \u00acw = v\n\u22a2 sorry = 0"}, {"line": "\u00b7 rw [h, count_self]", "tactic_state": "case neg\nR : Type u_1\nv : sorry\nx\u271d : Sort u_2\ncount : x\u271d\nw : sorry\ninst\u271d : Decidable (w = v)\nh : \u00acw = v\n\u22a2 sorry = 0"}, {"line": "\u00b7 exact count_maximal_coprime K v h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem count_coe_nonneg (J : Ideal R) : 0 \u2264 count K v J := by\n  by_cases hJ : J = 0\n  \u00b7 simp only [hJ, Submodule.zero_eq_bot, coeIdeal_bot, count_zero, le_refl]\n  \u00b7 classical simp only [count_coe K v hJ, Nat.cast_nonneg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/DedekindDomain/Factorization.lean", "context": {"open": ["scoped nonZeroDivisors", "Set Function UniqueFactorizationMonoid IsDedekindDomain IsDedekindDomain.HeightOneSpectrum", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "Int IsLocalization", "scoped Classical in", "scoped Classical in", "Classical in", "Classical in", "Classical in", "Classical in", "scoped Classical in"], "variables": ["{R : Type*} [CommRing R] {K : Type*} [Field K] [Algebra R K] [IsFractionRing R K]", "[IsDedekindDomain R] (v : HeightOneSpectrum R)", "(K)", "(K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nx\u271d : Sort u_2\ncount : x\u271d\nJ : sorry\n\u22a2 0 \u2264 sorry"}, {"line": "by_cases hJ : J = 0", "tactic_state": "R : Type u_1\nx\u271d : Sort u_2\ncount : x\u271d\nJ : sorry\n\u22a2 OfNat sorry 0\n---\ncase pos\nR : Type u_1\nx\u271d : Sort u_2\ncount : x\u271d\nJ : sorry\nhJ : J = 0\n\u22a2 0 \u2264 sorry\n---\ncase neg\nR : Type u_1\nx\u271d : Sort u_2\ncount : x\u271d\nJ : sorry\nhJ : \u00acJ = 0\n\u22a2 0 \u2264 sorry"}, {"line": "\u00b7 simp only [hJ, Submodule.zero_eq_bot, coeIdeal_bot, count_zero, le_refl]", "tactic_state": "case pos\nR : Type u_1\nx\u271d : Sort u_2\ncount : x\u271d\nJ : sorry\nhJ : J = 0\n\u22a2 0 \u2264 sorry\n---\ncase neg\nR : Type u_1\nx\u271d : Sort u_2\ncount : x\u271d\nJ : sorry\nhJ : \u00acJ = 0\n\u22a2 0 \u2264 sorry"}, {"line": "\u00b7 classical simp only [count_coe K v hJ, Nat.cast_nonneg]", "tactic_state": "case neg\nR : Type u_1\nx\u271d : Sort u_2\ncount : x\u271d\nJ : sorry\nhJ : \u00acJ = 0\n\u22a2 0 \u2264 sorry"}]}
{"declaration": "theorem finite_factors (I : FractionalIdeal R\u2070 K) :\n    \u2200\u1da0 v : HeightOneSpectrum R in Filter.cofinite, count K v I = 0 := by\n  by_cases hI : I = 0\n  \u00b7 simp only [hI, count_zero, Filter.eventually_cofinite, not_true_eq_false, setOf_false,\n      finite_empty]\n  \u00b7 convert finite_factors' hI (choose_spec (choose_spec (exists_eq_spanSingleton_mul I))).2\n    rw [count_ne_zero K _ hI]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/DedekindDomain/Factorization.lean", "context": {"open": ["scoped nonZeroDivisors", "Set Function UniqueFactorizationMonoid IsDedekindDomain IsDedekindDomain.HeightOneSpectrum", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "Int IsLocalization", "scoped Classical in", "scoped Classical in", "Classical in", "Classical in", "Classical in", "Classical in", "scoped Classical in", "scoped Classical in", "Classical in"], "variables": ["{R : Type*} [CommRing R] {K : Type*} [Field K] [Algebra R K] [IsFractionRing R K]", "[IsDedekindDomain R] (v : HeightOneSpectrum R)", "(K)", "(K)", "{K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nx\u271d : Sort u_2\ncount : x\u271d\nI : sorry\n\u22a2 \u2200\u1da0 (v : sorry) in Filter.cofinite, sorry = 0"}, {"line": "by_cases hI : I = 0", "tactic_state": "R : Type u_1\nx\u271d : Sort u_2\ncount : x\u271d\nI : sorry\n\u22a2 OfNat sorry 0\n---\ncase pos\nR : Type u_1\nx\u271d : Sort u_2\ncount : x\u271d\nI : sorry\nhI : I = 0\n\u22a2 \u2200\u1da0 (v : sorry) in Filter.cofinite, sorry = 0\n---\ncase neg\nR : Type u_1\nx\u271d : Sort u_2\ncount : x\u271d\nI : sorry\nhI : \u00acI = 0\n\u22a2 \u2200\u1da0 (v : sorry) in Filter.cofinite, sorry = 0"}, {"line": "\u00b7 simp only [hI, count_zero, Filter.eventually_cofinite, not_true_eq_false, setOf_false,\n      finite_empty]", "tactic_state": "case pos\nR : Type u_1\nx\u271d : Sort u_2\ncount : x\u271d\nI : sorry\nhI : I = 0\n\u22a2 \u2200\u1da0 (v : sorry) in Filter.cofinite, sorry = 0\n---\ncase neg\nR : Type u_1\nx\u271d : Sort u_2\ncount : x\u271d\nI : sorry\nhI : \u00acI = 0\n\u22a2 \u2200\u1da0 (v : sorry) in Filter.cofinite, sorry = 0"}, {"line": "\u00b7 convert finite_factors' hI (choose_spec (choose_spec (exists_eq_spanSingleton_mul I))).2\n    rw [count_ne_zero K _ hI]", "tactic_state": "case neg\nR : Type u_1\nx\u271d : Sort u_2\ncount : x\u271d\nI : sorry\nhI : \u00acI = 0\n\u22a2 \u2200\u1da0 (v : sorry) in Filter.cofinite, sorry = 0"}]}
{"declaration": "theorem Ideal.prime_of_isPrime {P : Ideal A} (hP : P \u2260 \u22a5) (h : IsPrime P) : Prime P := by\n  refine \u27e8hP, mt Ideal.isUnit_iff.mp h.ne_top, fun I J hIJ => ?_\u27e9\n  simpa only [Ideal.dvd_iff_le] using h.mul_le.mp (Ideal.le_of_dvd hIJ)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/DedekindDomain/Ideal.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "Submodule Submodule.IsPrincipal", "FractionalIdeal", "Ring", "Ideal", "FractionalIdeal", "Ideal"], "variables": ["(R A K : Type*) [CommRing R] [CommRing A] [Field K]", "{R\u2081 : Type*} [CommRing R\u2081] [IsDomain R\u2081] [Algebra R\u2081 K] [IsFractionRing R\u2081 K]", "{I J : FractionalIdeal R\u2081\u2070 K}", "{K}", "(K)", "{K' : Type*} [Field K'] [Algebra R\u2081 K'] [IsFractionRing R\u2081 K']", "{K}", "[IsDomain A]", "{R A K}", "[Algebra A K] [IsFractionRing A K] (h : IsDedekindDomainInv A)", "[Algebra A K] [IsFractionRing A K]", "{A K}", "{R A}", "[IsDedekindDomain A] [Algebra A K] [IsFractionRing A K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : IsDomain A\ninst\u271d : IsDedekindDomain A\nP : Ideal A\nhP : P \u2260 \u22a5\nh : P.IsPrime\n\u22a2 Prime P"}, {"line": "refine \u27e8hP, mt Ideal.isUnit_iff.mp h.ne_top, fun I J hIJ => ?_\u27e9", "tactic_state": "A : Type u_2\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : IsDomain A\ninst\u271d : IsDedekindDomain A\nP : Ideal A\nhP : P \u2260 \u22a5\nh : P.IsPrime\nI J : Ideal A\nhIJ : P \u2223 I * J\n\u22a2 P \u2223 I \u2228 P \u2223 J"}, {"line": "simpa only [Ideal.dvd_iff_le] using h.mul_le.mp (Ideal.le_of_dvd hIJ)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isCoprime_iff_gcd {I J : Ideal A} : IsCoprime I J \u2194 gcd I J = 1 := by\n  rw [Ideal.isCoprime_iff_codisjoint]\n  rw [codisjoint_iff]\n  rw [one_eq_top]\n  rw [gcd_eq_sup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/DedekindDomain/Ideal.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "Submodule Submodule.IsPrincipal", "FractionalIdeal", "Ring", "Ideal", "FractionalIdeal", "Ideal", "Submodule.IsPrincipal in", "UniqueFactorizationMonoid in", "UniqueFactorizationMonoid", "FractionalIdeal"], "variables": ["(R A K : Type*) [CommRing R] [CommRing A] [Field K]", "{R\u2081 : Type*} [CommRing R\u2081] [IsDomain R\u2081] [Algebra R\u2081 K] [IsFractionRing R\u2081 K]", "{I J : FractionalIdeal R\u2081\u2070 K}", "{K}", "(K)", "{K' : Type*} [Field K'] [Algebra R\u2081 K'] [IsFractionRing R\u2081 K']", "{K}", "[IsDomain A]", "{R A K}", "[Algebra A K] [IsFractionRing A K] (h : IsDedekindDomainInv A)", "[Algebra A K] [IsFractionRing A K]", "{A K}", "{R A}", "[IsDedekindDomain A] [Algebra A K] [IsFractionRing A K]", "{K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : IsDomain A\ninst\u271d : IsDedekindDomain A\nI J : Ideal A\n\u22a2 IsCoprime I J \u2194 gcd I J = 1"}, {"line": "rw [Ideal.isCoprime_iff_codisjoint]", "tactic_state": "A : Type u_2\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : IsDomain A\ninst\u271d : IsDedekindDomain A\nI J : Ideal A\n\u22a2 Codisjoint I J \u2194 gcd I J = 1"}, {"line": "rw [codisjoint_iff]", "tactic_state": "A : Type u_2\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : IsDomain A\ninst\u271d : IsDedekindDomain A\nI J : Ideal A\n\u22a2 I \u2294 J = \u22a4 \u2194 gcd I J = 1"}, {"line": "rw [one_eq_top]", "tactic_state": "A : Type u_2\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : IsDomain A\ninst\u271d : IsDedekindDomain A\nI J : Ideal A\n\u22a2 I \u2294 J = \u22a4 \u2194 gcd I J = \u22a4"}, {"line": "rw [gcd_eq_sup]", "tactic_state": "No Goals!"}]}
