{"declaration": "lemma differentiableAt_LFunction (\u03a6 : ZMod N \u2192 \u2102) (s : \u2102) (hs : s \u2260 1 \u2228 \u2211 j, \u03a6 j = 0) :\n    DifferentiableAt \u2102 (LFunction \u03a6) s := by\n  refine .mul (by fun_prop) ?_\n  rcases ne_or_eq s 1 with hs' | rfl\n  \u00b7 exact .sum fun j _ \u21a6 (differentiableAt_hurwitzZeta _ hs').const_mul _\n  \u00b7 have := DifferentiableAt.sum (u := univ) fun j _ \u21a6\n      (differentiableAt_hurwitzZeta_sub_one_div (toAddCircle j)).const_mul (\u03a6 j)\n    simpa only [mul_sub,sum_sub_distrib,\u2190 sum_mul,hs.neg_resolve_left rfl,zero_mul,sub_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LSeries/ZMod.lean", "context": {"open": ["HurwitzZeta Complex ZMod Finset Topology Filter Set", "scoped Real"], "variables": ["{N : \u2115} [NeZero N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\nhs : s \u2260 1 \u2228 \u2211 j, \u03a6 j = 0\n\u22a2 DifferentiableAt \u2102 (LFunction \u03a6) s"}, {"line": "refine .mul (by fun_prop) ?_", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\nhs : s \u2260 1 \u2228 \u2211 j, \u03a6 j = 0\n\u22a2 DifferentiableAt \u2102 (fun y => \u2211 j, \u03a6 j * hurwitzZeta (toAddCircle j) y) s"}, {"line": "rcases ne_or_eq s 1 with hs' | rfl", "tactic_state": "case inl\nN : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\nhs : s \u2260 1 \u2228 \u2211 j, \u03a6 j = 0\nhs' : s \u2260 1\n\u22a2 DifferentiableAt \u2102 (fun y => \u2211 j, \u03a6 j * hurwitzZeta (toAddCircle j) y) s\n---\ncase inr\nN : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\nhs : 1 \u2260 1 \u2228 \u2211 j, \u03a6 j = 0\n\u22a2 DifferentiableAt \u2102 (fun y => \u2211 j, \u03a6 j * hurwitzZeta (toAddCircle j) y) 1"}, {"line": "\u00b7 exact .sum fun j _ \u21a6 (differentiableAt_hurwitzZeta _ hs').const_mul _", "tactic_state": "case inr\nN : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\nhs : 1 \u2260 1 \u2228 \u2211 j, \u03a6 j = 0\n\u22a2 DifferentiableAt \u2102 (fun y => \u2211 j, \u03a6 j * hurwitzZeta (toAddCircle j) y) 1"}, {"line": "\u00b7 have := DifferentiableAt.sum (u := univ) fun j _ \u21a6\n      (differentiableAt_hurwitzZeta_sub_one_div (toAddCircle j)).const_mul (\u03a6 j)\n    simpa only [mul_sub,sum_sub_distrib,\u2190 sum_mul,hs.neg_resolve_left rfl,zero_mul,sub_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma completedLFunction_const_mul (a : \u2102) (\u03a6 : ZMod N \u2192 \u2102) (s : \u2102) :\n    completedLFunction (fun j \u21a6 a * \u03a6 j) s = a * completedLFunction \u03a6 s := by\n  simp only [completedLFunction]\n  simp only [mul_add]\n  simp only [mul_sum]\n  congr with i <;> ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LSeries/ZMod.lean", "context": {"open": ["HurwitzZeta Complex ZMod Finset Topology Filter Set", "scoped Real"], "variables": ["{N : \u2115} [NeZero N]", "{\u03a6 : ZMod N \u2192 \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\na : \u2102\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 completedLFunction (fun j => a * \u03a6 j) s = a * completedLFunction \u03a6 s"}, {"line": "simp only [completedLFunction]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\na : \u2102\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) * \u2211 x, a * \u03a6 x * completedHurwitzZetaEven (toAddCircle x) s +\n      \u2191N ^ (-s) * \u2211 x, a * \u03a6 x * completedHurwitzZetaOdd (toAddCircle x) s =\n    a *\n      (\u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaEven (toAddCircle j) s +\n        \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s)"}, {"line": "simp only [mul_add]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\na : \u2102\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) * \u2211 x, a * \u03a6 x * completedHurwitzZetaEven (toAddCircle x) s +\n      \u2191N ^ (-s) * \u2211 x, a * \u03a6 x * completedHurwitzZetaOdd (toAddCircle x) s =\n    a * (\u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaEven (toAddCircle j) s) +\n      a * (\u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s)"}, {"line": "simp only [mul_sum]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\na : \u2102\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2211 i, \u2191N ^ (-s) * (a * \u03a6 i * completedHurwitzZetaEven (toAddCircle i) s) +\n      \u2211 i, \u2191N ^ (-s) * (a * \u03a6 i * completedHurwitzZetaOdd (toAddCircle i) s) =\n    \u2211 i, a * (\u2191N ^ (-s) * (\u03a6 i * completedHurwitzZetaEven (toAddCircle i) s)) +\n      \u2211 i, a * (\u2191N ^ (-s) * (\u03a6 i * completedHurwitzZetaOdd (toAddCircle i) s))"}, {"line": "congr with i <;> ring", "tactic_state": "No Goals!"}]}
{"declaration": "lemma completedLFunction_modOne_eq (\u03a6 : ZMod 1 \u2192 \u2102) (s : \u2102) :\n    completedLFunction \u03a6 s = \u03a6 1 * completedRiemannZeta s := by\n  rw [completedLFunction_def_even (show \u03a6.Even from fun _ \u21a6 congr_arg \u03a6 (Subsingleton.elim ..))]\n  rw [Nat.cast_one]\n  rw [one_cpow]\n  rw [one_mul]\n  rw [\u2190 singleton_eq_univ 0]\n  rw [sum_singleton]\n  rw [map_zero]\n  rw [completedHurwitzZetaEven_zero]\n  rw [Subsingleton.elim 0 1]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LSeries/ZMod.lean", "context": {"open": ["HurwitzZeta Complex ZMod Finset Topology Filter Set", "scoped Real"], "variables": ["{N : \u2115} [NeZero N]", "{\u03a6 : ZMod N \u2192 \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03a6 : ZMod 1 \u2192 \u2102\ns : \u2102\n\u22a2 completedLFunction \u03a6 s = \u03a6 1 * completedRiemannZeta s"}, {"line": "rw [completedLFunction_def_even (show \u03a6.Even from fun _ \u21a6 congr_arg \u03a6 (Subsingleton.elim ..))]", "tactic_state": "\u03a6 : ZMod 1 \u2192 \u2102\ns : \u2102\n\u22a2 \u21911 ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaEven (toAddCircle j) s = \u03a6 1 * completedRiemannZeta s"}, {"line": "rw [Nat.cast_one]", "tactic_state": "\u03a6 : ZMod 1 \u2192 \u2102\ns : \u2102\n\u22a2 1 ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaEven (toAddCircle j) s = \u03a6 1 * completedRiemannZeta s"}, {"line": "rw [one_cpow]", "tactic_state": "\u03a6 : ZMod 1 \u2192 \u2102\ns : \u2102\n\u22a2 1 * \u2211 j, \u03a6 j * completedHurwitzZetaEven (toAddCircle j) s = \u03a6 1 * completedRiemannZeta s"}, {"line": "rw [one_mul]", "tactic_state": "\u03a6 : ZMod 1 \u2192 \u2102\ns : \u2102\n\u22a2 \u2211 j, \u03a6 j * completedHurwitzZetaEven (toAddCircle j) s = \u03a6 1 * completedRiemannZeta s"}, {"line": "rw [\u2190 singleton_eq_univ 0]", "tactic_state": "\u03a6 : ZMod 1 \u2192 \u2102\ns : \u2102\n\u22a2 \u2211 j \u2208 {0}, \u03a6 j * completedHurwitzZetaEven (toAddCircle j) s = \u03a6 1 * completedRiemannZeta s"}, {"line": "rw [sum_singleton]", "tactic_state": "\u03a6 : ZMod 1 \u2192 \u2102\ns : \u2102\n\u22a2 \u03a6 0 * completedHurwitzZetaEven (toAddCircle 0) s = \u03a6 1 * completedRiemannZeta s"}, {"line": "rw [map_zero]", "tactic_state": "\u03a6 : ZMod 1 \u2192 \u2102\ns : \u2102\n\u22a2 \u03a6 0 * completedHurwitzZetaEven 0 s = \u03a6 1 * completedRiemannZeta s"}, {"line": "rw [completedHurwitzZetaEven_zero]", "tactic_state": "\u03a6 : ZMod 1 \u2192 \u2102\ns : \u2102\n\u22a2 \u03a6 0 * completedRiemannZeta s = \u03a6 1 * completedRiemannZeta s"}, {"line": "rw [Subsingleton.elim 0 1]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma completedLFunction_eq (\u03a6 : ZMod N \u2192 \u2102) (s : \u2102) :\n    completedLFunction \u03a6 s =\n      completedLFunction\u2080 \u03a6 s - N ^ (-s) * \u03a6 0 / s - N ^ (-s) * (\u2211 j, \u03a6 j) / (1 - s) := by\n  simp only [completedLFunction]\n  simp only [completedHurwitzZetaEven_eq]\n  simp only [toAddCircle_eq_zero]\n  simp only [div_eq_mul_inv]\n  simp only [ite_mul]\n  simp only [one_mul]\n  simp only [zero_mul]\n  simp only [mul_sub]\n  simp only [mul_ite]\n  simp only [mul_zero]\n  simp only [sum_sub_distrib]\n  simp only [Fintype.sum_ite_eq']\n  simp only [\u2190 sum_mul]\n  simp only [completedLFunction\u2080]\n  simp only [mul_assoc]\n  abel\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LSeries/ZMod.lean", "context": {"open": ["HurwitzZeta Complex ZMod Finset Topology Filter Set", "scoped Real"], "variables": ["{N : \u2115} [NeZero N]", "{\u03a6 : ZMod N \u2192 \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 completedLFunction \u03a6 s = completedLFunction\u2080 \u03a6 s - \u2191N ^ (-s) * \u03a6 0 / s - (\u2191N ^ (-s) * \u2211 j, \u03a6 j) / (1 - s)"}, {"line": "simp only [completedLFunction]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaEven (toAddCircle j) s +\n      \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s =\n    completedLFunction\u2080 \u03a6 s - \u2191N ^ (-s) * \u03a6 0 / s - (\u2191N ^ (-s) * \u2211 j, \u03a6 j) / (1 - s)"}, {"line": "simp only [completedHurwitzZetaEven_eq]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) *\n        \u2211 x,\n          \u03a6 x * (completedHurwitzZetaEven\u2080 (toAddCircle x) s - (if toAddCircle x = 0 then 1 else 0) / s - 1 / (1 - s)) +\n      \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s =\n    completedLFunction\u2080 \u03a6 s - \u2191N ^ (-s) * \u03a6 0 / s - (\u2191N ^ (-s) * \u2211 j, \u03a6 j) / (1 - s)"}, {"line": "simp only [toAddCircle_eq_zero]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) * \u2211 x, \u03a6 x * (completedHurwitzZetaEven\u2080 (toAddCircle x) s - (if x = 0 then 1 else 0) / s - 1 / (1 - s)) +\n      \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s =\n    completedLFunction\u2080 \u03a6 s - \u2191N ^ (-s) * \u03a6 0 / s - (\u2191N ^ (-s) * \u2211 j, \u03a6 j) / (1 - s)"}, {"line": "simp only [div_eq_mul_inv]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) *\n        \u2211 x, \u03a6 x * (completedHurwitzZetaEven\u2080 (toAddCircle x) s - (if x = 0 then 1 else 0) * s\u207b\u00b9 - 1 * (1 - s)\u207b\u00b9) +\n      \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s =\n    completedLFunction\u2080 \u03a6 s - \u2191N ^ (-s) * \u03a6 0 * s\u207b\u00b9 - (\u2191N ^ (-s) * \u2211 j, \u03a6 j) * (1 - s)\u207b\u00b9"}, {"line": "simp only [ite_mul]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) *\n        \u2211 x,\n          \u03a6 x * ((completedHurwitzZetaEven\u2080 (toAddCircle x) s - if x = 0 then 1 * s\u207b\u00b9 else 0 * s\u207b\u00b9) - 1 * (1 - s)\u207b\u00b9) +\n      \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s =\n    completedLFunction\u2080 \u03a6 s - \u2191N ^ (-s) * \u03a6 0 * s\u207b\u00b9 - (\u2191N ^ (-s) * \u2211 j, \u03a6 j) * (1 - s)\u207b\u00b9"}, {"line": "simp only [one_mul]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) * \u2211 x, \u03a6 x * ((completedHurwitzZetaEven\u2080 (toAddCircle x) s - if x = 0 then s\u207b\u00b9 else 0 * s\u207b\u00b9) - (1 - s)\u207b\u00b9) +\n      \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s =\n    completedLFunction\u2080 \u03a6 s - \u2191N ^ (-s) * \u03a6 0 * s\u207b\u00b9 - (\u2191N ^ (-s) * \u2211 j, \u03a6 j) * (1 - s)\u207b\u00b9"}, {"line": "simp only [zero_mul]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) * \u2211 x, \u03a6 x * ((completedHurwitzZetaEven\u2080 (toAddCircle x) s - if x = 0 then s\u207b\u00b9 else 0) - (1 - s)\u207b\u00b9) +\n      \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s =\n    completedLFunction\u2080 \u03a6 s - \u2191N ^ (-s) * \u03a6 0 * s\u207b\u00b9 - (\u2191N ^ (-s) * \u2211 j, \u03a6 j) * (1 - s)\u207b\u00b9"}, {"line": "simp only [mul_sub]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) *\n        \u2211 x, ((\u03a6 x * completedHurwitzZetaEven\u2080 (toAddCircle x) s - \u03a6 x * if x = 0 then s\u207b\u00b9 else 0) - \u03a6 x * (1 - s)\u207b\u00b9) +\n      \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s =\n    completedLFunction\u2080 \u03a6 s - \u2191N ^ (-s) * \u03a6 0 * s\u207b\u00b9 - (\u2191N ^ (-s) * \u2211 j, \u03a6 j) * (1 - s)\u207b\u00b9"}, {"line": "simp only [mul_ite]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) *\n        \u2211 x,\n          ((\u03a6 x * completedHurwitzZetaEven\u2080 (toAddCircle x) s - if x = 0 then \u03a6 x * s\u207b\u00b9 else \u03a6 x * 0) -\n            \u03a6 x * (1 - s)\u207b\u00b9) +\n      \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s =\n    completedLFunction\u2080 \u03a6 s - \u2191N ^ (-s) * \u03a6 0 * s\u207b\u00b9 - (\u2191N ^ (-s) * \u2211 j, \u03a6 j) * (1 - s)\u207b\u00b9"}, {"line": "simp only [mul_zero]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) *\n        \u2211 x, ((\u03a6 x * completedHurwitzZetaEven\u2080 (toAddCircle x) s - if x = 0 then \u03a6 x * s\u207b\u00b9 else 0) - \u03a6 x * (1 - s)\u207b\u00b9) +\n      \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s =\n    completedLFunction\u2080 \u03a6 s - \u2191N ^ (-s) * \u03a6 0 * s\u207b\u00b9 - (\u2191N ^ (-s) * \u2211 j, \u03a6 j) * (1 - s)\u207b\u00b9"}, {"line": "simp only [sum_sub_distrib]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) *\n        ((\u2211 x, \u03a6 x * completedHurwitzZetaEven\u2080 (toAddCircle x) s - \u2211 x, if x = 0 then \u03a6 x * s\u207b\u00b9 else 0) -\n          \u2211 x, \u03a6 x * (1 - s)\u207b\u00b9) +\n      \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s =\n    completedLFunction\u2080 \u03a6 s - \u2191N ^ (-s) * \u03a6 0 * s\u207b\u00b9 - (\u2191N ^ (-s) * \u2211 j, \u03a6 j) * (1 - s)\u207b\u00b9"}, {"line": "simp only [Fintype.sum_ite_eq']", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) * (\u2211 x, \u03a6 x * completedHurwitzZetaEven\u2080 (toAddCircle x) s - \u03a6 0 * s\u207b\u00b9 - \u2211 x, \u03a6 x * (1 - s)\u207b\u00b9) +\n      \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s =\n    completedLFunction\u2080 \u03a6 s - \u2191N ^ (-s) * \u03a6 0 * s\u207b\u00b9 - (\u2191N ^ (-s) * \u2211 j, \u03a6 j) * (1 - s)\u207b\u00b9"}, {"line": "simp only [\u2190 sum_mul]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) * (\u2211 x, \u03a6 x * completedHurwitzZetaEven\u2080 (toAddCircle x) s - \u03a6 0 * s\u207b\u00b9 - (\u2211 i, \u03a6 i) * (1 - s)\u207b\u00b9) +\n      \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s =\n    completedLFunction\u2080 \u03a6 s - \u2191N ^ (-s) * \u03a6 0 * s\u207b\u00b9 - (\u2191N ^ (-s) * \u2211 i, \u03a6 i) * (1 - s)\u207b\u00b9"}, {"line": "simp only [completedLFunction\u2080]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) * (\u2211 x, \u03a6 x * completedHurwitzZetaEven\u2080 (toAddCircle x) s - \u03a6 0 * s\u207b\u00b9 - (\u2211 i, \u03a6 i) * (1 - s)\u207b\u00b9) +\n      \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s =\n    \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaEven\u2080 (toAddCircle j) s +\n          \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s -\n        \u2191N ^ (-s) * \u03a6 0 * s\u207b\u00b9 -\n      (\u2191N ^ (-s) * \u2211 i, \u03a6 i) * (1 - s)\u207b\u00b9"}, {"line": "simp only [mul_assoc]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) * (\u2211 x, \u03a6 x * completedHurwitzZetaEven\u2080 (toAddCircle x) s - \u03a6 0 * s\u207b\u00b9 - (\u2211 i, \u03a6 i) * (1 - s)\u207b\u00b9) +\n      \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s =\n    \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaEven\u2080 (toAddCircle j) s +\n          \u2191N ^ (-s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s -\n        \u2191N ^ (-s) * (\u03a6 0 * s\u207b\u00b9) -\n      \u2191N ^ (-s) * ((\u2211 i, \u03a6 i) * (1 - s)\u207b\u00b9)"}, {"line": "abel", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-1 \u2022 s) *\n        (\u2211 x, \u03a6 x * completedHurwitzZetaEven\u2080 (toAddCircle x) s +\n          (-1 \u2022 (\u03a6 0 * s\u207b\u00b9) + -1 \u2022 ((\u2211 i, \u03a6 i) * (-1 \u2022 s + 1)\u207b\u00b9))) +\n      \u2191N ^ (-1 \u2022 s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s =\n    \u2191N ^ (-1 \u2022 s) * \u2211 j, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s +\n      (\u2191N ^ (-1 \u2022 s) * \u2211 j, \u03a6 j * completedHurwitzZetaEven\u2080 (toAddCircle j) s +\n        (-1 \u2022 (\u2191N ^ (-1 \u2022 s) * (\u03a6 0 * s\u207b\u00b9)) + -1 \u2022 (\u2191N ^ (-1 \u2022 s) * ((\u2211 i, \u03a6 i) * (-1 \u2022 s + 1)\u207b\u00b9))))"}]}
{"declaration": "theorem pow_div_two_eq_neg_one_or_one {a : ZMod p} (ha : a \u2260 0) :\n    a ^ (p / 2) = 1 \u2228 a ^ (p / 2) = -1 := by\n  rcases Prime.eq_two_or_odd (@Fact.out p.Prime _) with hp2 | hp_odd\n  \u00b7 subst p; revert a ha; intro a; fin_cases a\n    \u00b7 tauto\n    \u00b7 simp\n  rw [\u2190 mul_self_eq_one_iff]\n  rw [\u2190 pow_add]\n  rw [\u2190 two_mul]\n  rw [two_mul_odd_div_two hp_odd]\n  exact pow_card_sub_one_eq_one ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/Basic.lean", "context": {"open": ["Nat"], "variables": ["(p : \u2115) [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : a \u2260 0\n\u22a2 a ^ (p / 2) = 1 \u2228 a ^ (p / 2) = -1"}, {"line": "rcases Prime.eq_two_or_odd (@Fact.out p.Prime _) with hp2 | hp_odd", "tactic_state": "case inl\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : a \u2260 0\nhp2 : p = 2\n\u22a2 a ^ (p / 2) = 1 \u2228 a ^ (p / 2) = -1\n---\ncase inr\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : a \u2260 0\nhp_odd : p % 2 = 1\n\u22a2 a ^ (p / 2) = 1 \u2228 a ^ (p / 2) = -1"}, {"line": "\u00b7 subst p; revert a ha; intro a; fin_cases a\n    \u00b7 tauto\n    \u00b7 simp", "tactic_state": "case inr\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : a \u2260 0\nhp_odd : p % 2 = 1\n\u22a2 a ^ (p / 2) = 1 \u2228 a ^ (p / 2) = -1"}, {"line": "rw [\u2190 mul_self_eq_one_iff]", "tactic_state": "case inr\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : a \u2260 0\nhp_odd : p % 2 = 1\n\u22a2 a ^ (p / 2) * a ^ (p / 2) = 1\n---\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : a \u2260 0\nhp_odd : p % 2 = 1\n\u22a2 NoZeroDivisors (ZMod p)"}, {"line": "rw [\u2190 pow_add]", "tactic_state": "case inr\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : a \u2260 0\nhp_odd : p % 2 = 1\n\u22a2 a ^ (p / 2 + p / 2) = 1\n---\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : a \u2260 0\nhp_odd : p % 2 = 1\n\u22a2 NoZeroDivisors (ZMod p)"}, {"line": "rw [\u2190 two_mul]", "tactic_state": "case inr\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : a \u2260 0\nhp_odd : p % 2 = 1\n\u22a2 a ^ (2 * (p / 2)) = 1\n---\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : a \u2260 0\nhp_odd : p % 2 = 1\n\u22a2 NoZeroDivisors (ZMod p)"}, {"line": "rw [two_mul_odd_div_two hp_odd]", "tactic_state": "case inr\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : a \u2260 0\nhp_odd : p % 2 = 1\n\u22a2 a ^ (p - 1) = 1\n---\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : a \u2260 0\nhp_odd : p % 2 = 1\n\u22a2 NoZeroDivisors (ZMod p)"}, {"line": "exact pow_card_sub_one_eq_one ha", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : a \u2260 0\nhp_odd : p % 2 = 1\n\u22a2 NoZeroDivisors (ZMod p)"}]}
{"declaration": "theorem at_zero : legendreSym p 0 = 0 := by rw [legendreSym, Int.cast_zero, MulChar.map_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/Basic.lean", "context": {"open": ["Nat", "ZMod"], "variables": ["(p : \u2115) [Fact p.Prime]", "(p : \u2115) [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 legendreSym p 0 = 0"}, {"line": "rw [legendreSym, Int.cast_zero, MulChar.map_zero]", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 Nontrivial (ZMod p)"}]}
{"declaration": "theorem at_one : legendreSym p 1 = 1 := by rw [legendreSym, Int.cast_one, MulChar.map_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/Basic.lean", "context": {"open": ["Nat", "ZMod"], "variables": ["(p : \u2115) [Fact p.Prime]", "(p : \u2115) [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 legendreSym p 1 = 1"}, {"line": "rw [legendreSym, Int.cast_one, MulChar.map_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sq_one' {a : \u2124} (ha : (a : ZMod p) \u2260 0) : legendreSym p (a ^ 2) = 1 := by\n  dsimp only [legendreSym]\n  rw [Int.cast_pow]\n  exact quadraticChar_sq_one' ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/Basic.lean", "context": {"open": ["Nat", "ZMod"], "variables": ["(p : \u2115) [Fact p.Prime]", "(p : \u2115) [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2124\nha : \u2191a \u2260 0\n\u22a2 legendreSym p (a ^ 2) = 1"}, {"line": "dsimp only [legendreSym]", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2124\nha : \u2191a \u2260 0\n\u22a2 (quadraticChar (ZMod p)) \u2191(a ^ 2) = 1"}, {"line": "rw [Int.cast_pow]", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2124\nha : \u2191a \u2260 0\n\u22a2 (quadraticChar (ZMod p)) (\u2191a ^ 2) = 1"}, {"line": "exact quadraticChar_sq_one' ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_one_of_sq_sub_mul_sq_eq_zero' {p : \u2115} [Fact p.Prime] {a : \u2124} (ha : (a : ZMod p) \u2260 0)\n    {x y : ZMod p} (hx : x \u2260 0) (hxy : x ^ 2 - a * y ^ 2 = 0) : legendreSym p a = 1 := by\n  haveI hy : y \u2260 0 := by\n    rintro rfl\n    rw [zero_pow two_ne_zero] at hxy\n    rw [mul_zero] at hxy\n    rw [sub_zero] at hxy\n    rw [sq_eq_zero_iff] at hxy\n    exact hx hxy\n  exact eq_one_of_sq_sub_mul_sq_eq_zero ha hy hxy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/Basic.lean", "context": {"open": ["Nat", "ZMod"], "variables": ["(p : \u2115) [Fact p.Prime]", "(p : \u2115) [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2124\nha : \u2191a \u2260 0\nx y : ZMod p\nhx : x \u2260 0\nhxy : x ^ 2 - \u2191a * y ^ 2 = 0\n\u22a2 legendreSym p a = 1"}, {"line": "haveI hy : y \u2260 0 := by\n    rintro rfl\n    rw [zero_pow two_ne_zero] at hxy\n    rw [mul_zero] at hxy\n    rw [sub_zero] at hxy\n    rw [sq_eq_zero_iff] at hxy\n    exact hx hxy", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2124\nha : \u2191a \u2260 0\nx y : ZMod p\nhx : x \u2260 0\nhxy : x ^ 2 - \u2191a * y ^ 2 = 0\nhy : y \u2260 0\n\u22a2 legendreSym p a = 1"}, {"line": "exact eq_one_of_sq_sub_mul_sq_eq_zero ha hy hxy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prime_dvd_of_eq_neg_one {p : \u2115} [Fact p.Prime] {a : \u2124} (h : legendreSym p a = -1) {x y : \u2124}\n    (hxy : (p : \u2124) \u2223 x ^ 2 - a * y ^ 2) : \u2191p \u2223 x \u2227 \u2191p \u2223 y := by\n  simp_rw [\u2190 ZMod.intCast_zmod_eq_zero_iff_dvd] at hxy \u22a2\n  push_cast at hxy\n  exact eq_zero_mod_of_eq_neg_one h hxy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/Basic.lean", "context": {"open": ["Nat", "ZMod"], "variables": ["(p : \u2115) [Fact p.Prime]", "(p : \u2115) [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2124\nh : legendreSym p a = -1\nx y : \u2124\nhxy : \u2191p \u2223 x ^ 2 - a * y ^ 2\n\u22a2 \u2191p \u2223 x \u2227 \u2191p \u2223 y"}, {"line": "simp_rw [\u2190 ZMod.intCast_zmod_eq_zero_iff_dvd] at hxy \u22a2", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2124\nh : legendreSym p a = -1\nx y : \u2124\nhxy : \u2191(x ^ 2 - a * y ^ 2) = 0\n\u22a2 \u2191x = 0 \u2227 \u2191y = 0"}, {"line": "push_cast at hxy", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2124\nh : legendreSym p a = -1\nx y : \u2124\nhxy : \u2191x ^ 2 - \u2191a * \u2191y ^ 2 = 0\n\u22a2 \u2191x = 0 \u2227 \u2191y = 0"}, {"line": "exact eq_zero_mod_of_eq_neg_one h hxy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ico_map_valMinAbs_natAbs_eq_Ico_map_id (p : \u2115) [hp : Fact p.Prime] (a : ZMod p)\n    (hap : a \u2260 0) : ((Ico 1 (p / 2).succ).1.map fun (x : \u2115) => (a * x).valMinAbs.natAbs) =\n    (Ico 1 (p / 2).succ).1.map fun a => a := by\n  have he : \u2200 {x}, x \u2208 Ico 1 (p / 2).succ \u2192 x \u2260 0 \u2227 x \u2264 p / 2 := by\n    simp +contextual [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]\n  have hep : \u2200 {x}, x \u2208 Ico 1 (p / 2).succ \u2192 x < p := fun hx =>\n    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))\n  have hpe : \u2200 {x}, x \u2208 Ico 1 (p / 2).succ \u2192 \u00acp \u2223 x := fun hx hpx =>\n    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)\n  have hmem : \u2200 (x : \u2115) (_ : x \u2208 Ico 1 (p / 2).succ),\n      (a * x : ZMod p).valMinAbs.natAbs \u2208 Ico 1 (p / 2).succ := by\n    intro x hx\n    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, Nat.lt_succ_iff, succ_le_iff,\n      pos_iff_ne_zero, natAbs_valMinAbs_le _]\n  have hsurj : \u2200 (b : \u2115) (hb : b \u2208 Ico 1 (p / 2).succ),\n      \u2203 x, \u2203 _ : x \u2208 Ico 1 (p / 2).succ, (a * x : ZMod p).valMinAbs.natAbs = b := by\n    intro b hb\n    refine \u27e8(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr \u27e8?_, ?_\u27e9, ?_\u27e9\n    \u00b7 apply Nat.pos_of_ne_zero\n      simp only [div_eq_mul_inv]\n      simp only [hap]\n      simp only [CharP.cast_eq_zero_iff (ZMod p) p]\n      simp only [hpe hb]\n      simp only [not_false_iff]\n      simp only [valMinAbs_eq_zero]\n      simp only [inv_eq_zero]\n      simp only [Int.natAbs_eq_zero]\n      simp only [Ne]\n      simp only [_root_.mul_eq_zero]\n      simp only [or_self_iff]\n    \u00b7 apply lt_succ_of_le; apply natAbs_valMinAbs_le\n    \u00b7 rw [natCast_natAbs_valMinAbs]\n      split_ifs\n      \u00b7 rw [mul_div_cancel\u2080 _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),\n          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_natCast]\n      \u00b7 rw [mul_neg, mul_div_cancel\u2080 _ hap, natAbs_valMinAbs_neg, valMinAbs_def_pos,\n          val_cast_of_lt (hep hb), if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_natCast]\n  exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)\n    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem\n    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj (fun _ _ => rfl)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/GaussEisensteinLemmas.lean", "context": {"open": ["Finset Nat", "scoped Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\na : ZMod p\nhap : a \u2260 0\n\u22a2 Multiset.map (fun x => (a * \u2191x).valMinAbs.natAbs) (Ico 1 (p / 2).succ).val =\n    Multiset.map (fun a => a) (Ico 1 (p / 2).succ).val"}, {"line": "have he : \u2200 {x}, x \u2208 Ico 1 (p / 2).succ \u2192 x \u2260 0 \u2227 x \u2264 p / 2 := sorry", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\na : ZMod p\nhap : a \u2260 0\nhe : \u2200 {x : \u2115}, x \u2208 Ico 1 (p / 2).succ \u2192 x \u2260 0 \u2227 x \u2264 p / 2\n\u22a2 Multiset.map (fun x => (a * \u2191x).valMinAbs.natAbs) (Ico 1 (p / 2).succ).val =\n    Multiset.map (fun a => a) (Ico 1 (p / 2).succ).val"}, {"line": "have hep : \u2200 {x}, x \u2208 Ico 1 (p / 2).succ \u2192 x < p := fun hx =>\n    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\na : ZMod p\nhap : a \u2260 0\nhe : \u2200 {x : \u2115}, x \u2208 Ico 1 (p / 2).succ \u2192 x \u2260 0 \u2227 x \u2264 p / 2\nhep : \u2200 {x : \u2115}, x \u2208 Ico 1 (p / 2).succ \u2192 x < p\n\u22a2 Multiset.map (fun x => (a * \u2191x).valMinAbs.natAbs) (Ico 1 (p / 2).succ).val =\n    Multiset.map (fun a => a) (Ico 1 (p / 2).succ).val"}, {"line": "have hpe : \u2200 {x}, x \u2208 Ico 1 (p / 2).succ \u2192 \u00acp \u2223 x := fun hx hpx =>\n    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\na : ZMod p\nhap : a \u2260 0\nhe : \u2200 {x : \u2115}, x \u2208 Ico 1 (p / 2).succ \u2192 x \u2260 0 \u2227 x \u2264 p / 2\nhep : \u2200 {x : \u2115}, x \u2208 Ico 1 (p / 2).succ \u2192 x < p\nhpe : \u2200 {x : \u2115}, x \u2208 Ico 1 (p / 2).succ \u2192 \u00acp \u2223 x\n\u22a2 Multiset.map (fun x => (a * \u2191x).valMinAbs.natAbs) (Ico 1 (p / 2).succ).val =\n    Multiset.map (fun a => a) (Ico 1 (p / 2).succ).val"}, {"line": "have hmem : \u2200 (x : \u2115) (_ : x \u2208 Ico 1 (p / 2).succ),\n      (a * x : ZMod p).valMinAbs.natAbs \u2208 Ico 1 (p / 2).succ := sorry", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\na : ZMod p\nhap : a \u2260 0\nhe : \u2200 {x : \u2115}, x \u2208 Ico 1 (p / 2).succ \u2192 x \u2260 0 \u2227 x \u2264 p / 2\nhep : \u2200 {x : \u2115}, x \u2208 Ico 1 (p / 2).succ \u2192 x < p\nhpe : \u2200 {x : \u2115}, x \u2208 Ico 1 (p / 2).succ \u2192 \u00acp \u2223 x\nhmem : \u2200 x \u2208 Ico 1 (p / 2).succ, (a * \u2191x).valMinAbs.natAbs \u2208 Ico 1 (p / 2).succ\n\u22a2 Multiset.map (fun x => (a * \u2191x).valMinAbs.natAbs) (Ico 1 (p / 2).succ).val =\n    Multiset.map (fun a => a) (Ico 1 (p / 2).succ).val"}, {"line": "have hsurj : \u2200 (b : \u2115) (hb : b \u2208 Ico 1 (p / 2).succ),\n      \u2203 x, \u2203 _ : x \u2208 Ico 1 (p / 2).succ, (a * x : ZMod p).valMinAbs.natAbs = b := by\n    intro b hb\n    refine \u27e8(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr \u27e8?_, ?_\u27e9, ?_\u27e9\n    \u00b7 apply Nat.pos_of_ne_zero\n      simp only [div_eq_mul_inv]\n      simp only [hap]\n      simp only [CharP.cast_eq_zero_iff (ZMod p) p]\n      simp only [hpe hb]\n      simp only [not_false_iff]\n      simp only [valMinAbs_eq_zero]\n      simp only [inv_eq_zero]\n      simp only [Int.natAbs_eq_zero]\n      simp only [Ne]\n      simp only [_root_.mul_eq_zero]\n      simp only [or_self_iff]\n    \u00b7 apply lt_succ_of_le; apply natAbs_valMinAbs_le\n    \u00b7 rw [natCast_natAbs_valMinAbs]\n      split_ifs\n      \u00b7 rw [mul_div_cancel\u2080 _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),\n          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_natCast]\n      \u00b7 rw [mul_neg, mul_div_cancel\u2080 _ hap, natAbs_valMinAbs_neg, valMinAbs_def_pos,\n          val_cast_of_lt (hep hb), if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_natCast]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\na : ZMod p\nhap : a \u2260 0\nhe : \u2200 {x : \u2115}, x \u2208 Ico 1 (p / 2).succ \u2192 x \u2260 0 \u2227 x \u2264 p / 2\nhep : \u2200 {x : \u2115}, x \u2208 Ico 1 (p / 2).succ \u2192 x < p\nhpe : \u2200 {x : \u2115}, x \u2208 Ico 1 (p / 2).succ \u2192 \u00acp \u2223 x\nhmem : \u2200 x \u2208 Ico 1 (p / 2).succ, (a * \u2191x).valMinAbs.natAbs \u2208 Ico 1 (p / 2).succ\nhsurj : \u2200 b \u2208 Ico 1 (p / 2).succ, \u2203 x, \u2203 (_ : x \u2208 Ico 1 (p / 2).succ), (a * \u2191x).valMinAbs.natAbs = b\n\u22a2 Multiset.map (fun x => (a * \u2191x).valMinAbs.natAbs) (Ico 1 (p / 2).succ).val =\n    Multiset.map (fun a => a) (Ico 1 (p / 2).succ).val"}, {"line": "exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)\n    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem\n    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj (fun _ _ => rfl)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_sq_eq_prime_iff_of_mod_four_eq_one (hp1 : p % 4 = 1) (hq1 : q \u2260 2) :\n    IsSquare (q : ZMod p) \u2194 IsSquare (p : ZMod q) := by\n  rcases eq_or_ne p q with h | h\n  \u00b7 subst p; rfl\n  \u00b7 rw [\u2190 eq_one_iff' p (prime_ne_zero p q h), \u2190 eq_one_iff' q (prime_ne_zero q p h.symm),\n      quadratic_reciprocity_one_mod_four hp1 hq1]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/QuadraticReciprocity.lean", "context": {"open": ["Nat", "ZMod", "ZMod", "legendreSym"], "variables": ["{p : \u2115} [Fact p.Prime]", "{p q : \u2115} [Fact p.Prime] [Fact q.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Fact (Nat.Prime q)\nhp1 : p % 4 = 1\nhq1 : q \u2260 2\n\u22a2 IsSquare \u2191q \u2194 IsSquare \u2191p"}, {"line": "rcases eq_or_ne p q with h | h", "tactic_state": "case inl\np q : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Fact (Nat.Prime q)\nhp1 : p % 4 = 1\nhq1 : q \u2260 2\nh : p = q\n\u22a2 IsSquare \u2191q \u2194 IsSquare \u2191p\n---\ncase inr\np q : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Fact (Nat.Prime q)\nhp1 : p % 4 = 1\nhq1 : q \u2260 2\nh : p \u2260 q\n\u22a2 IsSquare \u2191q \u2194 IsSquare \u2191p"}, {"line": "\u00b7 subst p; rfl", "tactic_state": "case inr\np q : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Fact (Nat.Prime q)\nhp1 : p % 4 = 1\nhq1 : q \u2260 2\nh : p \u2260 q\n\u22a2 IsSquare \u2191q \u2194 IsSquare \u2191p"}, {"line": "\u00b7 rw [\u2190 eq_one_iff' p (prime_ne_zero p q h), \u2190 eq_one_iff' q (prime_ne_zero q p h.symm),\n      quadratic_reciprocity_one_mod_four hp1 hq1]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_eq_card_of_eq_one {\u03c8 : AddChar R R'} (h\u03c8 : \u03c8 = 1) :\n    \u2211 a, \u03c8 a = Fintype.card R := by simp [h\u03c8]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/AddCharacter.lean", "context": {"open": [], "variables": ["{R : Type u} [CommRing R] {R' : Type v} [CommMonoid R']", "{N : \u2115} [NeZero N] {R : Type*} [CommRing R] (e : AddChar (ZMod N) R)", "{C : Type v} [CommMonoid C]", "{R : Type*} [AddGroup R] [Fintype R] {R' : Type*} [CommRing R']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b2 : AddGroup R\ninst\u271d\u00b9 : Fintype R\nR' : Type u_3\ninst\u271d : CommRing R'\n\u03c8 : AddChar R R'\nh\u03c8 : \u03c8 = 1\n\u22a2 \u2211 a, \u03c8 a = \u2191(Fintype.card R)"}, {"line": "simp [h\u03c8]", "tactic_state": "R : Type u_2\ninst\u271d\u00b2 : AddGroup R\ninst\u271d\u00b9 : Fintype R\nR' : Type u_3\ninst\u271d : CommRing R'\n\u03c8 : AddChar R R'\nh\u03c8 : \u03c8 = 1\n\u22a2 Fintype.card R \u2022 1 = \u2191(Fintype.card R)"}]}
{"declaration": "theorem sum_mulShift {R : Type*} [CommRing R] [Fintype R] [DecidableEq R]\n    {R' : Type*} [CommRing R'] [IsDomain R'] {\u03c8 : AddChar R R'} (b : R)\n    (h\u03c8 : IsPrimitive \u03c8) : \u2211 x : R, \u03c8 (x * b) = if b = 0 then Fintype.card R else 0 := by\n  split_ifs with h\n  \u00b7 -- case `b = 0`\n    simp only [h]\n    simp only [mul_zero]\n    simp only [map_zero_eq_one]\n    simp only [Finset.sum_const]\n    simp only [Nat.smul_one_eq_cast]\n    rfl\n  \u00b7 -- case `b \u2260 0`\n    simp_rw [mul_comm]\n    exact mod_cast sum_eq_zero_of_ne_one (h\u03c8 h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/AddCharacter.lean", "context": {"open": [], "variables": ["{R : Type u} [CommRing R] {R' : Type v} [CommMonoid R']", "{N : \u2115} [NeZero N] {R : Type*} [CommRing R] (e : AddChar (ZMod N) R)", "{C : Type v} [CommMonoid C]", "{R : Type*} [AddGroup R] [Fintype R] {R' : Type*} [CommRing R']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_6\nIsPrimitive : x\u271d\nR : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Fintype R\ninst\u271d\u00b2 : DecidableEq R\nR' : Type u_5\ninst\u271d\u00b9 : CommRing R'\ninst\u271d : IsDomain R'\n\u03c8 : AddChar R R'\nb : R\nh\u03c8 : sorry\n\u22a2 \u2211 x, \u03c8 (x * b) = \u2191(if b = 0 then Fintype.card R else 0)"}, {"line": "split_ifs with h", "tactic_state": "case pos\nx\u271d : Sort u_6\nIsPrimitive : x\u271d\nR : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Fintype R\ninst\u271d\u00b2 : DecidableEq R\nR' : Type u_5\ninst\u271d\u00b9 : CommRing R'\ninst\u271d : IsDomain R'\n\u03c8 : AddChar R R'\nb : R\nh\u03c8 : sorry\nh : b = 0\n\u22a2 \u2211 x, \u03c8 (x * b) = \u2191(Fintype.card R)\n---\ncase neg\nx\u271d : Sort u_6\nIsPrimitive : x\u271d\nR : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Fintype R\ninst\u271d\u00b2 : DecidableEq R\nR' : Type u_5\ninst\u271d\u00b9 : CommRing R'\ninst\u271d : IsDomain R'\n\u03c8 : AddChar R R'\nb : R\nh\u03c8 : sorry\nh : \u00acb = 0\n\u22a2 \u2211 x, \u03c8 (x * b) = \u21910"}, {"line": "\u00b7 -- case `b = 0`\n    simp only [h]\n    simp only [mul_zero]\n    simp only [map_zero_eq_one]\n    simp only [Finset.sum_const]\n    simp only [Nat.smul_one_eq_cast]\n    rfl", "tactic_state": "case neg\nx\u271d : Sort u_6\nIsPrimitive : x\u271d\nR : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Fintype R\ninst\u271d\u00b2 : DecidableEq R\nR' : Type u_5\ninst\u271d\u00b9 : CommRing R'\ninst\u271d : IsDomain R'\n\u03c8 : AddChar R R'\nb : R\nh\u03c8 : sorry\nh : \u00acb = 0\n\u22a2 \u2211 x, \u03c8 (x * b) = \u21910"}, {"line": "\u00b7 -- case `b \u2260 0`\n    simp_rw [mul_comm]\n    exact mod_cast sum_eq_zero_of_ne_one (h\u03c8 h)", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma ringChar_ne : ringChar \u2102 \u2260 ringChar F := by\n  simpa only [ringChar.eq_zero] using (CharP.ringChar_ne_zero_of_finite F).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/AddCharacter.lean", "context": {"open": [], "variables": ["{R : Type u} [CommRing R] {R' : Type v} [CommMonoid R']", "{N : \u2115} [NeZero N] {R : Type*} [CommRing R] (e : AddChar (ZMod N) R)", "{C : Type v} [CommMonoid C]", "{R : Type*} [AddGroup R] [Fintype R] {R' : Type*} [CommRing R']", "{R : Type*} [CommRing R]", "(F : Type*) [Field F] [Finite F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_5\ninst\u271d\u00b9 : Field F\ninst\u271d : Finite F\n\u22a2 ringChar \u2102 \u2260 ringChar F"}, {"line": "simpa only [ringChar.eq_zero] using (CharP.ringChar_ne_zero_of_finite F).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_right' (a : \u2124) {b\u2081 b\u2082 : \u2115} (hb\u2081 : b\u2081 \u2260 0) (hb\u2082 : b\u2082 \u2260 0) :\n    J(a | b\u2081 * b\u2082) = J(a | b\u2081) * J(a | b\u2082) := by\n  rw [jacobiSym]\n  rw [((perm_primeFactorsList_mul hb\u2081 hb\u2082).pmap _).prod_eq]\n  rw [List.pmap_append]\n  rw [List.prod_append]\n  pick_goal 2\n  \u00b7 exact fun p hp =>\n      (List.mem_append.mp hp).elim prime_of_mem_primeFactorsList prime_of_mem_primeFactorsList\n  \u00b7 rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean", "context": {"open": ["Nat ZMod", "NumberTheorySymbols"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2124\nb\u2081 b\u2082 : \u2115\nhb\u2081 : b\u2081 \u2260 0\nhb\u2082 : b\u2082 \u2260 0\n\u22a2 jacobiSym a (b\u2081 * b\u2082) = jacobiSym a b\u2081 * jacobiSym a b\u2082"}, {"line": "rw [jacobiSym]", "tactic_state": "a : \u2124\nb\u2081 b\u2082 : \u2115\nhb\u2081 : b\u2081 \u2260 0\nhb\u2082 : b\u2082 \u2260 0\n\u22a2 (List.pmap (fun p pp => legendreSym p a) (b\u2081 * b\u2082).primeFactorsList \u22ef).prod = jacobiSym a b\u2081 * jacobiSym a b\u2082"}, {"line": "rw [((perm_primeFactorsList_mul hb\u2081 hb\u2082).pmap _).prod_eq]", "tactic_state": "a : \u2124\nb\u2081 b\u2082 : \u2115\nhb\u2081 : b\u2081 \u2260 0\nhb\u2082 : b\u2082 \u2260 0\n\u22a2 (List.pmap (fun p pp => legendreSym p a) (b\u2081.primeFactorsList ++ b\u2082.primeFactorsList) ?m.181).prod =\n    jacobiSym a b\u2081 * jacobiSym a b\u2082\n---\na : \u2124\nb\u2081 b\u2082 : \u2115\nhb\u2081 : b\u2081 \u2260 0\nhb\u2082 : b\u2082 \u2260 0\n\u22a2 \u2200 a \u2208 b\u2081.primeFactorsList ++ b\u2082.primeFactorsList, Nat.Prime a"}, {"line": "rw [List.pmap_append]", "tactic_state": "a : \u2124\nb\u2081 b\u2082 : \u2115\nhb\u2081 : b\u2081 \u2260 0\nhb\u2082 : b\u2082 \u2260 0\n\u22a2 (List.pmap (fun p pp => legendreSym p a) b\u2081.primeFactorsList \u22ef ++\n        List.pmap (fun p pp => legendreSym p a) b\u2082.primeFactorsList \u22ef).prod =\n    jacobiSym a b\u2081 * jacobiSym a b\u2082\n---\na : \u2124\nb\u2081 b\u2082 : \u2115\nhb\u2081 : b\u2081 \u2260 0\nhb\u2082 : b\u2082 \u2260 0\n\u22a2 \u2200 a \u2208 b\u2081.primeFactorsList ++ b\u2082.primeFactorsList, Nat.Prime a"}, {"line": "rw [List.prod_append]", "tactic_state": "a : \u2124\nb\u2081 b\u2082 : \u2115\nhb\u2081 : b\u2081 \u2260 0\nhb\u2082 : b\u2082 \u2260 0\n\u22a2 (List.pmap (fun p pp => legendreSym p a) b\u2081.primeFactorsList \u22ef).prod *\n      (List.pmap (fun p pp => legendreSym p a) b\u2082.primeFactorsList \u22ef).prod =\n    jacobiSym a b\u2081 * jacobiSym a b\u2082\n---\na : \u2124\nb\u2081 b\u2082 : \u2115\nhb\u2081 : b\u2081 \u2260 0\nhb\u2082 : b\u2082 \u2260 0\n\u22a2 \u2200 a \u2208 b\u2081.primeFactorsList ++ b\u2082.primeFactorsList, Nat.Prime a\n---\na : \u2124\nb\u2081 b\u2082 : \u2115\nhb\u2081 : b\u2081 \u2260 0\nhb\u2082 : b\u2082 \u2260 0\n\u22a2 \u2200 a \u2208 b\u2081.primeFactorsList ++ b\u2082.primeFactorsList, Nat.Prime a"}, {"line": "pick_goal 2", "tactic_state": "a : \u2124\nb\u2081 b\u2082 : \u2115\nhb\u2081 : b\u2081 \u2260 0\nhb\u2082 : b\u2082 \u2260 0\n\u22a2 \u2200 a \u2208 b\u2081.primeFactorsList ++ b\u2082.primeFactorsList, Nat.Prime a\n---\na : \u2124\nb\u2081 b\u2082 : \u2115\nhb\u2081 : b\u2081 \u2260 0\nhb\u2082 : b\u2082 \u2260 0\n\u22a2 (List.pmap (fun p pp => legendreSym p a) b\u2081.primeFactorsList \u22ef).prod *\n      (List.pmap (fun p pp => legendreSym p a) b\u2082.primeFactorsList \u22ef).prod =\n    jacobiSym a b\u2081 * jacobiSym a b\u2082\n---\na : \u2124\nb\u2081 b\u2082 : \u2115\nhb\u2081 : b\u2081 \u2260 0\nhb\u2082 : b\u2082 \u2260 0\n\u22a2 \u2200 a \u2208 b\u2081.primeFactorsList ++ b\u2082.primeFactorsList, Nat.Prime a"}, {"line": "\u00b7 exact fun p hp =>\n      (List.mem_append.mp hp).elim prime_of_mem_primeFactorsList prime_of_mem_primeFactorsList", "tactic_state": "a : \u2124\nb\u2081 b\u2082 : \u2115\nhb\u2081 : b\u2081 \u2260 0\nhb\u2082 : b\u2082 \u2260 0\n\u22a2 (List.pmap (fun p pp => legendreSym p a) b\u2081.primeFactorsList \u22ef).prod *\n      (List.pmap (fun p pp => legendreSym p a) b\u2082.primeFactorsList \u22ef).prod =\n    jacobiSym a b\u2081 * jacobiSym a b\u2082"}, {"line": "\u00b7 rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_left (a\u2081 a\u2082 : \u2124) (b : \u2115) : J(a\u2081 * a\u2082 | b) = J(a\u2081 | b) * J(a\u2082 | b) := by\n  simp_rw [jacobiSym, List.pmap_eq_map_attach, legendreSym.mul _ _ _]\n  exact List.prod_map_mul (\u03b1 := \u2124) (l := (primeFactorsList b).attach)\n    (f := fun x \u21a6 @legendreSym x {out := prime_of_mem_primeFactorsList x.2} a\u2081)\n    (g := fun x \u21a6 @legendreSym x {out := prime_of_mem_primeFactorsList x.2} a\u2082)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean", "context": {"open": ["Nat ZMod", "NumberTheorySymbols"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a\u2081 a\u2082 : \u2124\nb : \u2115\n\u22a2 jacobiSym (a\u2081 * a\u2082) b = jacobiSym a\u2081 b * jacobiSym a\u2082 b"}, {"line": "simp_rw [jacobiSym, List.pmap_eq_map_attach, legendreSym.mul _ _ _]", "tactic_state": "a\u2081 a\u2082 : \u2124\nb : \u2115\n\u22a2 (List.map (fun x => legendreSym (\u2191x) a\u2081 * legendreSym (\u2191x) a\u2082) b.primeFactorsList.attach).prod =\n    (List.map (fun x => legendreSym (\u2191x) a\u2081) b.primeFactorsList.attach).prod *\n      (List.map (fun x => legendreSym (\u2191x) a\u2082) b.primeFactorsList.attach).prod"}, {"line": "exact List.prod_map_mul (\u03b1 := \u2124) (l := (primeFactorsList b).attach)\n    (f := fun x \u21a6 @legendreSym x {out := prime_of_mem_primeFactorsList x.2} a\u2081)\n    (g := fun x \u21a6 @legendreSym x {out := prime_of_mem_primeFactorsList x.2} a\u2082)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_four_left {a : \u2124} {b : \u2115} (ha4 : a % 4 = 0) (hb2 : b % 2 = 1) :\n    J(a / 4 | b) = J(a | b) := by\n  obtain \u27e8a, rfl\u27e9 := Int.dvd_of_emod_eq_zero ha4\n  have : Int.gcd (2 : \u2115) b = 1 := by\n    rw [Int.gcd_natCast_natCast]\n    rw [\u2190 b.mod_add_div 2]\n    rw [hb2]\n    rw [Nat.gcd_add_mul_left_right]\n    rw [Nat.gcd_one_right]\n  rw [Int.mul_ediv_cancel_left _ (by decide)]\n  rw [jacobiSym.mul_left]\n  rw [(by decide : (4 : \u2124) = (2 : \u2115) ^ 2)]\n  rw [jacobiSym.sq_one' this]\n  rw [one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean", "context": {"open": ["Nat ZMod", "NumberTheorySymbols", "jacobiSym"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2124\nb : \u2115\nha4 : a % 4 = 0\nhb2 : b % 2 = 1\n\u22a2 jacobiSym (a / 4) b = jacobiSym a b"}, {"line": "obtain \u27e8a, rfl\u27e9 := Int.dvd_of_emod_eq_zero ha4", "tactic_state": "case intro\nb : \u2115\nhb2 : b % 2 = 1\na : \u2124\nha4 : 4 * a % 4 = 0\n\u22a2 jacobiSym (4 * a / 4) b = jacobiSym (4 * a) b"}, {"line": "have : Int.gcd (2 : \u2115) b = 1 := by\n    rw [Int.gcd_natCast_natCast]\n    rw [\u2190 b.mod_add_div 2]\n    rw [hb2]\n    rw [Nat.gcd_add_mul_left_right]\n    rw [Nat.gcd_one_right]", "tactic_state": "case intro\nb : \u2115\nhb2 : b % 2 = 1\na : \u2124\nha4 : 4 * a % 4 = 0\nthis : (\u21912).gcd \u2191b = 1\n\u22a2 jacobiSym (4 * a / 4) b = jacobiSym (4 * a) b"}, {"line": "rw [Int.mul_ediv_cancel_left _ (by decide)]", "tactic_state": "case intro\nb : \u2115\nhb2 : b % 2 = 1\na : \u2124\nha4 : 4 * a % 4 = 0\nthis : (\u21912).gcd \u2191b = 1\n\u22a2 jacobiSym a b = jacobiSym (4 * a) b"}, {"line": "rw [jacobiSym.mul_left]", "tactic_state": "case intro\nb : \u2115\nhb2 : b % 2 = 1\na : \u2124\nha4 : 4 * a % 4 = 0\nthis : (\u21912).gcd \u2191b = 1\n\u22a2 jacobiSym a b = jacobiSym 4 b * jacobiSym a b"}, {"line": "rw [(by decide : (4 : \u2124) = (2 : \u2115) ^ 2)]", "tactic_state": "case intro\nb : \u2115\nhb2 : b % 2 = 1\na : \u2124\nha4 : 4 * a % 4 = 0\nthis : (\u21912).gcd \u2191b = 1\n\u22a2 jacobiSym a b = jacobiSym (\u21912 ^ 2) b * jacobiSym a b"}, {"line": "rw [jacobiSym.sq_one' this]", "tactic_state": "case intro\nb : \u2115\nhb2 : b % 2 = 1\na : \u2124\nha4 : 4 * a % 4 = 0\nthis : (\u21912).gcd \u2191b = 1\n\u22a2 jacobiSym a b = 1 * jacobiSym a b"}, {"line": "rw [one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_one_pow {m n : \u2115} (hm : Odd m) (hn : Odd n) :\n    qrSign m n = (-1) ^ (m / 2 * (n / 2)) := by\n  rw [qrSign]\n  rw [pow_mul]\n  rw [\u2190 \u03c7\u2084_eq_neg_one_pow (odd_iff.mp hm)]\n  rcases odd_mod_four_iff.mp (odd_iff.mp hm) with h | h\n  \u00b7 rw [\u03c7\u2084_nat_one_mod_four h, jacobiSym.one_left, one_pow]\n  \u00b7 rw [\u03c7\u2084_nat_three_mod_four h, \u2190 \u03c7\u2084_eq_neg_one_pow (odd_iff.mp hn), jacobiSym.at_neg_one hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean", "context": {"open": ["Nat ZMod", "NumberTheorySymbols", "jacobiSym"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nhm : Odd m\nhn : Odd n\n\u22a2 qrSign m n = (-1) ^ (m / 2 * (n / 2))"}, {"line": "rw [qrSign]", "tactic_state": "m n : \u2115\nhm : Odd m\nhn : Odd n\n\u22a2 jacobiSym (\u03c7\u2084 \u2191m) n = (-1) ^ (m / 2 * (n / 2))"}, {"line": "rw [pow_mul]", "tactic_state": "m n : \u2115\nhm : Odd m\nhn : Odd n\n\u22a2 jacobiSym (\u03c7\u2084 \u2191m) n = ((-1) ^ (m / 2)) ^ (n / 2)"}, {"line": "rw [\u2190 \u03c7\u2084_eq_neg_one_pow (odd_iff.mp hm)]", "tactic_state": "m n : \u2115\nhm : Odd m\nhn : Odd n\n\u22a2 jacobiSym (\u03c7\u2084 \u2191m) n = \u03c7\u2084 \u2191m ^ (n / 2)"}, {"line": "rcases odd_mod_four_iff.mp (odd_iff.mp hm) with h | h", "tactic_state": "case inl\nm n : \u2115\nhm : Odd m\nhn : Odd n\nh : m % 4 = 1\n\u22a2 jacobiSym (\u03c7\u2084 \u2191m) n = \u03c7\u2084 \u2191m ^ (n / 2)\n---\ncase inr\nm n : \u2115\nhm : Odd m\nhn : Odd n\nh : m % 4 = 3\n\u22a2 jacobiSym (\u03c7\u2084 \u2191m) n = \u03c7\u2084 \u2191m ^ (n / 2)"}, {"line": "\u00b7 rw [\u03c7\u2084_nat_one_mod_four h, jacobiSym.one_left, one_pow]", "tactic_state": "case inr\nm n : \u2115\nhm : Odd m\nhn : Odd n\nh : m % 4 = 3\n\u22a2 jacobiSym (\u03c7\u2084 \u2191m) n = \u03c7\u2084 \u2191m ^ (n / 2)"}, {"line": "\u00b7 rw [\u03c7\u2084_nat_three_mod_four h, \u2190 \u03c7\u2084_eq_neg_one_pow (odd_iff.mp hn), jacobiSym.at_neg_one hn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_left (m\u2081 m\u2082 n : \u2115) : qrSign (m\u2081 * m\u2082) n = qrSign m\u2081 n * qrSign m\u2082 n := by\n  simp_rw [qrSign, Nat.cast_mul, map_mul, jacobiSym.mul_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean", "context": {"open": ["Nat ZMod", "NumberTheorySymbols", "jacobiSym"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m\u2081 m\u2082 n : \u2115\n\u22a2 qrSign (m\u2081 * m\u2082) n = qrSign m\u2081 n * qrSign m\u2082 n"}, {"line": "simp_rw [qrSign, Nat.cast_mul, map_mul, jacobiSym.mul_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem quadratic_reciprocity {a b : \u2115} (ha : Odd a) (hb : Odd b) :\n    J(a | b) = (-1) ^ (a / 2 * (b / 2)) * J(b | a) := by\n  rw [\u2190 qrSign.neg_one_pow ha hb]\n  rw [qrSign.symm ha hb]\n  rw [quadratic_reciprocity' ha hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean", "context": {"open": ["Nat ZMod", "NumberTheorySymbols", "jacobiSym"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nha : Odd a\nhb : Odd b\n\u22a2 jacobiSym (\u2191a) b = (-1) ^ (a / 2 * (b / 2)) * jacobiSym (\u2191b) a"}, {"line": "rw [\u2190 qrSign.neg_one_pow ha hb]", "tactic_state": "a b : \u2115\nha : Odd a\nhb : Odd b\n\u22a2 jacobiSym (\u2191a) b = qrSign a b * jacobiSym (\u2191b) a"}, {"line": "rw [qrSign.symm ha hb]", "tactic_state": "a b : \u2115\nha : Odd a\nhb : Odd b\n\u22a2 jacobiSym (\u2191a) b = qrSign b a * jacobiSym (\u2191b) a"}, {"line": "rw [quadratic_reciprocity' ha hb]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem quadratic_reciprocity_one_mod_four {a b : \u2115} (ha : a % 4 = 1) (hb : Odd b) :\n    J(a | b) = J(b | a) := by\n  rw [quadratic_reciprocity (odd_iff.mpr (odd_of_mod_four_eq_one ha)) hb]\n  rw [pow_mul]\n  rw [neg_one_pow_div_two_of_one_mod_four ha]\n  rw [one_pow]\n  rw [one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean", "context": {"open": ["Nat ZMod", "NumberTheorySymbols", "jacobiSym"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nha : a % 4 = 1\nhb : Odd b\n\u22a2 jacobiSym (\u2191a) b = jacobiSym (\u2191b) a"}, {"line": "rw [quadratic_reciprocity (odd_iff.mpr (odd_of_mod_four_eq_one ha)) hb]", "tactic_state": "a b : \u2115\nha : a % 4 = 1\nhb : Odd b\n\u22a2 (-1) ^ (a / 2 * (b / 2)) * jacobiSym (\u2191b) a = jacobiSym (\u2191b) a"}, {"line": "rw [pow_mul]", "tactic_state": "a b : \u2115\nha : a % 4 = 1\nhb : Odd b\n\u22a2 ((-1) ^ (a / 2)) ^ (b / 2) * jacobiSym (\u2191b) a = jacobiSym (\u2191b) a"}, {"line": "rw [neg_one_pow_div_two_of_one_mod_four ha]", "tactic_state": "a b : \u2115\nha : a % 4 = 1\nhb : Odd b\n\u22a2 1 ^ (b / 2) * jacobiSym (\u2191b) a = jacobiSym (\u2191b) a"}, {"line": "rw [one_pow]", "tactic_state": "a b : \u2115\nha : a % 4 = 1\nhb : Odd b\n\u22a2 1 * jacobiSym (\u2191b) a = jacobiSym (\u2191b) a"}, {"line": "rw [one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem quadratic_reciprocity_if {a b : \u2115} (ha2 : a % 2 = 1) (hb2 : b % 2 = 1) :\n    (if a % 4 = 3 \u2227 b % 4 = 3 then -J(b | a) else J(b | a)) = J(a | b) := by\n  rcases Nat.odd_mod_four_iff.mp ha2 with ha1 | ha3\n  \u00b7 simpa [ha1] using jacobiSym.quadratic_reciprocity_one_mod_four' (Nat.odd_iff.mpr hb2) ha1\n  rcases Nat.odd_mod_four_iff.mp hb2 with hb1 | hb3\n  \u00b7 simpa [hb1] using jacobiSym.quadratic_reciprocity_one_mod_four hb1 (Nat.odd_iff.mpr ha2)\n  simpa [ha3, hb3] using (jacobiSym.quadratic_reciprocity_three_mod_four ha3 hb3).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean", "context": {"open": ["Nat ZMod", "NumberTheorySymbols", "jacobiSym"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nha2 : a % 2 = 1\nhb2 : b % 2 = 1\n\u22a2 (if a % 4 = 3 \u2227 b % 4 = 3 then -jacobiSym (\u2191b) a else jacobiSym (\u2191b) a) = jacobiSym (\u2191a) b"}, {"line": "rcases Nat.odd_mod_four_iff.mp ha2 with ha1 | ha3", "tactic_state": "case inl\na b : \u2115\nha2 : a % 2 = 1\nhb2 : b % 2 = 1\nha1 : a % 4 = 1\n\u22a2 (if a % 4 = 3 \u2227 b % 4 = 3 then -jacobiSym (\u2191b) a else jacobiSym (\u2191b) a) = jacobiSym (\u2191a) b\n---\ncase inr\na b : \u2115\nha2 : a % 2 = 1\nhb2 : b % 2 = 1\nha3 : a % 4 = 3\n\u22a2 (if a % 4 = 3 \u2227 b % 4 = 3 then -jacobiSym (\u2191b) a else jacobiSym (\u2191b) a) = jacobiSym (\u2191a) b"}, {"line": "\u00b7 simpa [ha1] using jacobiSym.quadratic_reciprocity_one_mod_four' (Nat.odd_iff.mpr hb2) ha1", "tactic_state": "case inr\na b : \u2115\nha2 : a % 2 = 1\nhb2 : b % 2 = 1\nha3 : a % 4 = 3\n\u22a2 (if a % 4 = 3 \u2227 b % 4 = 3 then -jacobiSym (\u2191b) a else jacobiSym (\u2191b) a) = jacobiSym (\u2191a) b"}, {"line": "rcases Nat.odd_mod_four_iff.mp hb2 with hb1 | hb3", "tactic_state": "case inr.inl\na b : \u2115\nha2 : a % 2 = 1\nhb2 : b % 2 = 1\nha3 : a % 4 = 3\nhb1 : b % 4 = 1\n\u22a2 (if a % 4 = 3 \u2227 b % 4 = 3 then -jacobiSym (\u2191b) a else jacobiSym (\u2191b) a) = jacobiSym (\u2191a) b\n---\ncase inr.inr\na b : \u2115\nha2 : a % 2 = 1\nhb2 : b % 2 = 1\nha3 : a % 4 = 3\nhb3 : b % 4 = 3\n\u22a2 (if a % 4 = 3 \u2227 b % 4 = 3 then -jacobiSym (\u2191b) a else jacobiSym (\u2191b) a) = jacobiSym (\u2191a) b"}, {"line": "\u00b7 simpa [hb1] using jacobiSym.quadratic_reciprocity_one_mod_four hb1 (Nat.odd_iff.mpr ha2)", "tactic_state": "case inr.inr\na b : \u2115\nha2 : a % 2 = 1\nhb2 : b % 2 = 1\nha3 : a % 4 = 3\nhb3 : b % 4 = 3\n\u22a2 (if a % 4 = 3 \u2227 b % 4 = 3 then -jacobiSym (\u2191b) a else jacobiSym (\u2191b) a) = jacobiSym (\u2191a) b"}, {"line": "simpa [ha3, hb3] using (jacobiSym.quadratic_reciprocity_three_mod_four ha3 hb3).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mod_right (a : \u2124) {b : \u2115} (hb : Odd b) : J(a | b) = J(a | b % (4 * a.natAbs)) := by\n  rcases Int.natAbs_eq a with ha | ha <;> nth_rw 2 [ha] <;> nth_rw 1 [ha]\n  \u00b7 exact mod_right' a.natAbs hb\n  \u00b7 have hb' : Odd (b % (4 * a.natAbs)) := hb.mod_even (Even.mul_right (by decide) _)\n    rw [jacobiSym.neg _ hb]\n    rw [jacobiSym.neg _ hb']\n    rw [mod_right' _ hb]\n    rw [\u03c7\u2084_nat_mod_four]\n    rw [\u03c7\u2084_nat_mod_four (b % (4 * _))]\n    rw [mod_mod_of_dvd b (dvd_mul_right 4 _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean", "context": {"open": ["Nat ZMod", "NumberTheorySymbols", "jacobiSym"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2124\nb : \u2115\nhb : Odd b\n\u22a2 jacobiSym a b = jacobiSym a (b % (4 * a.natAbs))"}, {"line": "rcases Int.natAbs_eq a with ha | ha <;> nth_rw 2 [ha] <;> nth_rw 1 [ha]", "tactic_state": "case inl\na : \u2124\nb : \u2115\nhb : Odd b\nha : a = \u2191a.natAbs\n\u22a2 jacobiSym (\u2191a.natAbs) b = jacobiSym (\u2191a.natAbs) (b % (4 * a.natAbs))\n---\ncase inr\na : \u2124\nb : \u2115\nhb : Odd b\nha : a = -\u2191a.natAbs\n\u22a2 jacobiSym (-\u2191a.natAbs) b = jacobiSym (-\u2191a.natAbs) (b % (4 * a.natAbs))"}, {"line": "\u00b7 exact mod_right' a.natAbs hb", "tactic_state": "case inr\na : \u2124\nb : \u2115\nhb : Odd b\nha : a = -\u2191a.natAbs\n\u22a2 jacobiSym (-\u2191a.natAbs) b = jacobiSym (-\u2191a.natAbs) (b % (4 * a.natAbs))"}, {"line": "\u00b7 have hb' : Odd (b % (4 * a.natAbs)) := hb.mod_even (Even.mul_right (by decide) _)\n    rw [jacobiSym.neg _ hb]\n    rw [jacobiSym.neg _ hb']\n    rw [mod_right' _ hb]\n    rw [\u03c7\u2084_nat_mod_four]\n    rw [\u03c7\u2084_nat_mod_four (b % (4 * _))]\n    rw [mod_mod_of_dvd b (dvd_mul_right 4 _)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem quadraticCharFun_zero : quadraticCharFun F 0 = 0 := by\n  simp only [quadraticCharFun]\n  simp only [if_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "context": {"open": ["MulChar"], "variables": ["{F : Type*} [Field F] [Fintype F] [DecidableEq F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\n\u22a2 quadraticCharFun F 0 = 0"}, {"line": "simp only [quadraticCharFun]", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\n\u22a2 (if True then 0 else if IsSquare 0 then 1 else -1) = 0"}, {"line": "simp only [if_true]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem quadraticCharFun_eq_one_of_char_two (hF : ringChar F = 2) {a : F} (ha : a \u2260 0) :\n    quadraticCharFun F a = 1 := by\n  simp only [quadraticCharFun]\n  simp only [ha]\n  simp only [if_false]\n  simp only [ite_eq_left_iff]\n  exact fun h \u21a6 (h (FiniteField.isSquare_of_char_two hF a)).elim\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "context": {"open": ["MulChar"], "variables": ["{F : Type*} [Field F] [Fintype F] [DecidableEq F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\nhF : ringChar F = 2\na : F\nha : a \u2260 0\n\u22a2 quadraticCharFun F a = 1"}, {"line": "simp only [quadraticCharFun]", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\nhF : ringChar F = 2\na : F\nha : a \u2260 0\n\u22a2 (if a = 0 then 0 else if IsSquare a then 1 else -1) = 1"}, {"line": "simp only [ha]", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\nhF : ringChar F = 2\na : F\nha : a \u2260 0\n\u22a2 (if False then 0 else if IsSquare a then 1 else -1) = 1"}, {"line": "simp only [if_false]", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\nhF : ringChar F = 2\na : F\nha : a \u2260 0\n\u22a2 (if IsSquare a then 1 else -1) = 1"}, {"line": "simp only [ite_eq_left_iff]", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\nhF : ringChar F = 2\na : F\nha : a \u2260 0\n\u22a2 \u00acIsSquare a \u2192 -1 = 1"}, {"line": "exact fun h \u21a6 (h (FiniteField.isSquare_of_char_two hF a)).elim", "tactic_state": "No Goals!"}]}
{"declaration": "theorem quadraticChar_zero : quadraticChar F 0 = 0 := by\n  simp only [quadraticChar_apply]\n  simp only [quadraticCharFun_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "context": {"open": ["MulChar"], "variables": ["{F : Type*} [Field F] [Fintype F] [DecidableEq F]", "(F) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\n\u22a2 (quadraticChar F) 0 = 0"}, {"line": "simp only [quadraticChar_apply]", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\n\u22a2 quadraticCharFun F 0 = 0"}, {"line": "simp only [quadraticCharFun_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem quadraticChar_sq_one {a : F} (ha : a \u2260 0) : quadraticChar F a ^ 2 = 1 := by\n  rwa [pow_two, \u2190 map_mul, \u2190 pow_two, quadraticChar_sq_one']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "context": {"open": ["MulChar"], "variables": ["{F : Type*} [Field F] [Fintype F] [DecidableEq F]", "(F) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\na : F\nha : a \u2260 0\n\u22a2 (quadraticChar F) a ^ 2 = 1"}, {"line": "rwa [pow_two, \u2190 map_mul, \u2190 pow_two, quadraticChar_sq_one']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem quadraticChar_neg_one_iff_not_isSquare {a : F} : quadraticChar F a = -1 \u2194 \u00acIsSquare a := by\n  by_cases ha : a = 0\n  \u00b7 simp only [ha, MulChar.map_zero, zero_eq_neg, one_ne_zero, IsSquare.zero, not_true]\n  \u00b7 rw [quadraticChar_eq_neg_one_iff_not_one ha, quadraticChar_one_iff_isSquare ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "context": {"open": ["MulChar"], "variables": ["{F : Type*} [Field F] [Fintype F] [DecidableEq F]", "(F) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\na : F\n\u22a2 (quadraticChar F) a = -1 \u2194 \u00acIsSquare a"}, {"line": "by_cases ha : a = 0", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\na : F\n\u22a2 OfNat F 0\n---\ncase pos\nF : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\na : F\nha : a = 0\n\u22a2 (quadraticChar F) a = -1 \u2194 \u00acIsSquare a\n---\ncase neg\nF : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\na : F\nha : \u00aca = 0\n\u22a2 (quadraticChar F) a = -1 \u2194 \u00acIsSquare a"}, {"line": "\u00b7 simp only [ha, MulChar.map_zero, zero_eq_neg, one_ne_zero, IsSquare.zero, not_true]", "tactic_state": "case pos\nF : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\na : F\nha : a = 0\n\u22a2 (quadraticChar F) a = -1 \u2194 \u00acIsSquare a\n---\ncase neg\nF : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\na : F\nha : \u00aca = 0\n\u22a2 (quadraticChar F) a = -1 \u2194 \u00acIsSquare a"}, {"line": "\u00b7 rw [quadraticChar_eq_neg_one_iff_not_one ha, quadraticChar_one_iff_isSquare ha]", "tactic_state": "case neg\nF : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\na : F\nha : \u00aca = 0\n\u22a2 (quadraticChar F) a = -1 \u2194 \u00acIsSquare a"}]}
{"declaration": "theorem quadraticChar_isQuadratic : (quadraticChar F).IsQuadratic := by\n  intro a\n  by_cases ha : a = 0\n  \u00b7 left; rw [ha]; exact quadraticChar_zero\n  \u00b7 right; exact quadraticChar_dichotomy ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "context": {"open": ["MulChar"], "variables": ["{F : Type*} [Field F] [Fintype F] [DecidableEq F]", "(F) in", "(F) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\n\u22a2 (quadraticChar F).IsQuadratic"}, {"line": "intro a", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\na : F\n\u22a2 (quadraticChar F) a = 0 \u2228 (quadraticChar F) a = 1 \u2228 (quadraticChar F) a = -1"}, {"line": "by_cases ha : a = 0", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\na : F\n\u22a2 OfNat F 0\n---\ncase pos\nF : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\na : F\nha : a = 0\n\u22a2 (quadraticChar F) a = 0 \u2228 (quadraticChar F) a = 1 \u2228 (quadraticChar F) a = -1\n---\ncase neg\nF : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\na : F\nha : \u00aca = 0\n\u22a2 (quadraticChar F) a = 0 \u2228 (quadraticChar F) a = 1 \u2228 (quadraticChar F) a = -1"}, {"line": "\u00b7 left; rw [ha]; exact quadraticChar_zero", "tactic_state": "case pos\nF : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\na : F\nha : a = 0\n\u22a2 (quadraticChar F) a = 0 \u2228 (quadraticChar F) a = 1 \u2228 (quadraticChar F) a = -1\n---\ncase neg\nF : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\na : F\nha : \u00aca = 0\n\u22a2 (quadraticChar F) a = 0 \u2228 (quadraticChar F) a = 1 \u2228 (quadraticChar F) a = -1"}, {"line": "\u00b7 right; exact quadraticChar_dichotomy ha", "tactic_state": "case neg\nF : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\na : F\nha : \u00aca = 0\n\u22a2 (quadraticChar F) a = 0 \u2228 (quadraticChar F) a = 1 \u2228 (quadraticChar F) a = -1"}]}
{"declaration": "theorem T_zpow_width_invariant (N : \u2115) (k n : \u2124) (f : SlashInvariantForm (Gamma N) k) (z : \u210d) :\n    f (((ModularGroup.T ^ (N * n))) \u2022 z) = f z := by\n  rw [modular_T_zpow_smul z (N * n)]\n  simpa only [Int.cast_mul,Int.cast_natCast] using vAdd_width_periodic N k n f z\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/Identities.lean", "context": {"open": ["ModularForm UpperHalfPlane Matrix CongruenceSubgroup"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\nk n : \u2124\nf : SlashInvariantForm (Gamma N) k\nz : UpperHalfPlane\n\u22a2 f (ModularGroup.T ^ (\u2191N * n) \u2022 z) = f z"}, {"line": "rw [modular_T_zpow_smul z (N * n)]", "tactic_state": "N : \u2115\nk n : \u2124\nf : SlashInvariantForm (Gamma N) k\nz : UpperHalfPlane\n\u22a2 f (\u2191(\u2191N * n) +\u1d65 z) = f z"}, {"line": "simpa only [Int.cast_mul,Int.cast_natCast] using vAdd_width_periodic N k n f z", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_cuspFunction [NeZero n] [SlashInvariantFormClass F \u0393(n) k] (\u03c4 : \u210d) :\n    cuspFunction n f (\ud835\udd62 n \u03c4) = f \u03c4 := by\n  simpa only [comp_apply,ofComplex_apply]\n    using (periodic_comp_ofComplex n f).eq_cuspFunction (NeZero.ne _) \u03c4\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/QExpansion.lean", "context": {"open": ["ModularForm Complex Filter UpperHalfPlane Function", "scoped Real MatrixGroups CongruenceSubgroup"], "variables": ["{k : \u2124} {F : Type*} [FunLike F \u210d \u2102] {\u0393 : Subgroup SL(2, \u2124)} (n : \u2115) (f : F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2124\nF : Type u_1\ninst\u271d\u00b2 : FunLike F UpperHalfPlane \u2102\nn : \u2115\nf : F\nx\u271d : Sort u_2\ncuspFunction : x\u271d\ninst\u271d\u00b9 : NeZero n\ninst\u271d : SlashInvariantFormClass F (CongruenceSubgroup.Gamma n) k\n\u03c4 : UpperHalfPlane\n\u22a2 sorry = f \u03c4"}, {"line": "simpa only [comp_apply,ofComplex_apply]\n    using (periodic_comp_ofComplex n f).eq_cuspFunction (NeZero.ne _) \u03c4", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableAt_cuspFunction [NeZero n] [ModularFormClass F \u0393(n) k]\n    {q : \u2102} (hq : \u2016q\u2016 < 1) :\n    DifferentiableAt \u2102 (cuspFunction n f) q := by\n  have npos : 0 < (n : \u211d) := mod_cast (Nat.pos_iff_ne_zero.mpr (NeZero.ne _))\n  rcases eq_or_ne q 0 with rfl | hq'\n  \u00b7 exact (periodic_comp_ofComplex n f).differentiableAt_cuspFunction_zero npos\n      (eventually_of_mem (preimage_mem_comap (Ioi_mem_atTop 0))\n        (fun _ \u21a6 differentiableAt_comp_ofComplex f))\n      (bounded_at_infty_comp_ofComplex f)\n  \u00b7 exact Periodic.qParam_right_inv npos.ne' hq' \u25b8\n      (periodic_comp_ofComplex n f).differentiableAt_cuspFunction npos.ne'\n        <| differentiableAt_comp_ofComplex _ <| Periodic.im_invQParam_pos_of_norm_lt_one npos hq hq'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/QExpansion.lean", "context": {"open": ["ModularForm Complex Filter UpperHalfPlane Function", "scoped Real MatrixGroups CongruenceSubgroup", "SlashInvariantFormClass"], "variables": ["{k : \u2124} {F : Type*} [FunLike F \u210d \u2102] {\u0393 : Subgroup SL(2, \u2124)} (n : \u2115) (f : F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2124\nF : Type u_1\ninst\u271d\u00b2 : FunLike F UpperHalfPlane \u2102\nn : \u2115\nf : F\ninst\u271d\u00b9 : NeZero n\ninst\u271d : ModularFormClass F (CongruenceSubgroup.Gamma n) k\nq : \u2102\nhq : \u2016q\u2016 < 1\n\u22a2 DifferentiableAt \u2102 (cuspFunction n f) q"}, {"line": "have npos : 0 < (n : \u211d) := mod_cast (Nat.pos_iff_ne_zero.mpr (NeZero.ne _))", "tactic_state": "k : \u2124\nF : Type u_1\ninst\u271d\u00b2 : FunLike F UpperHalfPlane \u2102\nn : \u2115\nf : F\ninst\u271d\u00b9 : NeZero n\ninst\u271d : ModularFormClass F (CongruenceSubgroup.Gamma n) k\nq : \u2102\nhq : \u2016q\u2016 < 1\nnpos : 0 < \u2191n\n\u22a2 DifferentiableAt \u2102 (cuspFunction n f) q"}, {"line": "rcases eq_or_ne q 0 with rfl | hq'", "tactic_state": "case inl\nk : \u2124\nF : Type u_1\ninst\u271d\u00b2 : FunLike F UpperHalfPlane \u2102\nn : \u2115\nf : F\ninst\u271d\u00b9 : NeZero n\ninst\u271d : ModularFormClass F (CongruenceSubgroup.Gamma n) k\nnpos : 0 < \u2191n\nhq : \u20160\u2016 < 1\n\u22a2 DifferentiableAt \u2102 (cuspFunction n f) 0\n---\ncase inr\nk : \u2124\nF : Type u_1\ninst\u271d\u00b2 : FunLike F UpperHalfPlane \u2102\nn : \u2115\nf : F\ninst\u271d\u00b9 : NeZero n\ninst\u271d : ModularFormClass F (CongruenceSubgroup.Gamma n) k\nq : \u2102\nhq : \u2016q\u2016 < 1\nnpos : 0 < \u2191n\nhq' : q \u2260 0\n\u22a2 DifferentiableAt \u2102 (cuspFunction n f) q"}, {"line": "\u00b7 exact (periodic_comp_ofComplex n f).differentiableAt_cuspFunction_zero npos\n      (eventually_of_mem (preimage_mem_comap (Ioi_mem_atTop 0))\n        (fun _ \u21a6 differentiableAt_comp_ofComplex f))\n      (bounded_at_infty_comp_ofComplex f)", "tactic_state": "case inr\nk : \u2124\nF : Type u_1\ninst\u271d\u00b2 : FunLike F UpperHalfPlane \u2102\nn : \u2115\nf : F\ninst\u271d\u00b9 : NeZero n\ninst\u271d : ModularFormClass F (CongruenceSubgroup.Gamma n) k\nq : \u2102\nhq : \u2016q\u2016 < 1\nnpos : 0 < \u2191n\nhq' : q \u2260 0\n\u22a2 DifferentiableAt \u2102 (cuspFunction n f) q"}, {"line": "\u00b7 exact Periodic.qParam_right_inv npos.ne' hq' \u25b8\n      (periodic_comp_ofComplex n f).differentiableAt_cuspFunction npos.ne'\n        <| differentiableAt_comp_ofComplex _ <| Periodic.im_invQParam_pos_of_norm_lt_one npos hq hq'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_decay_atImInfty [NeZero n] [CuspFormClass F \u0393(n) k] :\n    f =O[atImInfty] fun \u03c4 \u21a6 Real.exp (-2 * \u03c0 * \u03c4.im / n) := by\n  simpa only [neg_mul,comp_def,ofComplex_apply,coe_im] using\n    ((periodic_comp_ofComplex n f).exp_decay_of_zero_at_inf\n      (mod_cast (Nat.pos_iff_ne_zero.mpr (NeZero.ne _)))\n      (eventually_of_mem (preimage_mem_comap (Ioi_mem_atTop 0))\n        fun _ \u21a6 differentiableAt_comp_ofComplex f)\n      (zero_at_infty_comp_ofComplex f)).comp_tendsto tendsto_coe_atImInfty\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/QExpansion.lean", "context": {"open": ["ModularForm Complex Filter UpperHalfPlane Function", "scoped Real MatrixGroups CongruenceSubgroup", "SlashInvariantFormClass", "ModularFormClass"], "variables": ["{k : \u2124} {F : Type*} [FunLike F \u210d \u2102] {\u0393 : Subgroup SL(2, \u2124)} (n : \u2115) (f : F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2124\nF : Type u_1\ninst\u271d\u00b2 : FunLike F UpperHalfPlane \u2102\nn : \u2115\nf : F\ninst\u271d\u00b9 : NeZero n\ninst\u271d : CuspFormClass F (CongruenceSubgroup.Gamma n) k\n\u22a2 \u21d1f =O[atImInfty] fun \u03c4 => Real.exp (-2 * Real.pi * \u03c4.im / \u2191n)"}, {"line": "simpa only [neg_mul,comp_def,ofComplex_apply,coe_im] using\n    ((periodic_comp_ofComplex n f).exp_decay_of_zero_at_inf\n      (mod_cast (Nat.pos_iff_ne_zero.mpr (NeZero.ne _)))\n      (eventually_of_mem (preimage_mem_comap (Ioi_mem_atTop 0))\n        fun _ \u21a6 differentiableAt_comp_ofComplex f)\n      (zero_at_infty_comp_ofComplex f)).comp_tendsto tendsto_coe_atImInfty", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gradedMonoid_eq_of_cast {\u0393 : Subgroup SL(2, \u2124)} {a b : GradedMonoid (ModularForm \u0393)}\n    (h : a.fst = b.fst) (h2 : mcast h a.snd = b.snd) : a = b := by\n  obtain \u27e8i, a\u27e9 := a\n  obtain \u27e8j, b\u27e9 := b\n  cases h\n  exact congr_arg _ h2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/Basic.lean", "context": {"open": ["Complex UpperHalfPlane", "scoped Topology Manifold MatrixGroups", "ModularForm", "scoped ModularForm", "SlashInvariantForm", "ModularForm"], "variables": ["(F : Type*) (\u0393 : Subgroup SL(2, \u2124)) (k : \u2124)", "{F \u0393 k}", "{\u0393 : Subgroup SL(2, \u2124)} {k : \u2124}", "{\u03b1 : Type*} [SMul \u03b1 \u2102] [IsScalarTower \u03b1 \u2102 \u2102]", "{F : Type*} {\u0393 : Subgroup SL(2, \u2124)} {k : \u2124}", "{\u03b1 : Type*} [SMul \u03b1 \u2102] [IsScalarTower \u03b1 \u2102 \u2102]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0393 : Subgroup (Matrix.SpecialLinearGroup (Fin 2) \u2124)\na b : GradedMonoid (ModularForm \u0393)\nh : a.fst = b.fst\nh2 : mcast h a.snd = b.snd\n\u22a2 a = b"}, {"line": "obtain \u27e8i, a\u27e9 := a", "tactic_state": "case mk\n\u0393 : Subgroup (Matrix.SpecialLinearGroup (Fin 2) \u2124)\nb : GradedMonoid (ModularForm \u0393)\ni : \u2124\na : ModularForm \u0393 i\nh : \u27e8i, a\u27e9.fst = b.fst\nh2 : mcast h \u27e8i, a\u27e9.snd = b.snd\n\u22a2 \u27e8i, a\u27e9 = b"}, {"line": "obtain \u27e8j, b\u27e9 := b", "tactic_state": "case mk.mk\n\u0393 : Subgroup (Matrix.SpecialLinearGroup (Fin 2) \u2124)\ni : \u2124\na : ModularForm \u0393 i\nj : \u2124\nb : ModularForm \u0393 j\nh : \u27e8i, a\u27e9.fst = \u27e8j, b\u27e9.fst\nh2 : mcast h \u27e8i, a\u27e9.snd = \u27e8j, b\u27e9.snd\n\u22a2 \u27e8i, a\u27e9 = \u27e8j, b\u27e9"}, {"line": "cases h", "tactic_state": "case mk.mk.refl\n\u0393 : Subgroup (Matrix.SpecialLinearGroup (Fin 2) \u2124)\ni : \u2124\na b : ModularForm \u0393 i\nh2 : mcast \u22ef \u27e8i, a\u27e9.snd = \u27e8i, b\u27e9.snd\n\u22a2 \u27e8i, a\u27e9 = \u27e8i, b\u27e9"}, {"line": "exact congr_arg _ h2", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem levelOne_nonpos_wt_const (hk : k \u2264 0) (f : F) :\n    \u21d1f = Function.const _ (cuspFunction 1 f 0) := by\n  ext z\n  have hQ : \ud835\udd62 1 z \u2208 (Metric.ball 0 1) := by\n    simpa only [Metric.mem_ball,dist_zero_right,neg_mul,mul_zero,div_one,Real.exp_zero]\n      using (norm_qParam_lt_iff zero_lt_one 0 z.1).mpr z.2\n  simpa only [\u2190 eq_cuspFunction 1 f z,Nat.cast_one,Function.const_apply] using\n    (cuspFunction_eqOn_const_of_nonpos_wt hk f) hQ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/LevelOne.lean", "context": {"open": ["UpperHalfPlane ModularGroup SlashInvariantForm ModularForm Complex"], "variables": ["{F : Type*} [FunLike F \u210d \u2102] {k : \u2124}", "[SlashInvariantFormClass F \u0393(1) k]", "(k) in", "[ModularFormClass F \u0393(1) k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d : FunLike F UpperHalfPlane \u2102\nk : \u2124\nx\u271d : Sort u_2\ncuspFunction : x\u271d\nhk : k \u2264 0\nf : F\n\u22a2 \u21d1f = Function.const UpperHalfPlane sorry"}, {"line": "ext z", "tactic_state": "case h\nF : Type u_1\ninst\u271d : FunLike F UpperHalfPlane \u2102\nk : \u2124\nx\u271d : Sort u_2\ncuspFunction : x\u271d\nhk : k \u2264 0\nf : F\nz : UpperHalfPlane\n\u22a2 f z = Function.const UpperHalfPlane sorry z"}, {"line": "have hQ : \ud835\udd62 1 z \u2208 (Metric.ball 0 1) := sorry", "tactic_state": "case h\nF : Type u_1\ninst\u271d : FunLike F UpperHalfPlane \u2102\nk : \u2124\nx\u271d : Sort u_2\ncuspFunction : x\u271d\nhk : k \u2264 0\nf : F\nz : UpperHalfPlane\nhQ : sorry \u2208 Metric.ball 0 1\n\u22a2 f z = Function.const UpperHalfPlane sorry z"}, {"line": "simpa only [\u2190 eq_cuspFunction 1 f z,Nat.cast_one,Function.const_apply] using\n    (cuspFunction_eqOn_const_of_nonpos_wt hk f) hQ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem is_invariant_one' (A : SL(2, \u2124)) : (1 : \u210d \u2192 \u2102) \u2223[(0 : \u2124)] (A : GL(2, \u211d)\u207a) = 1 := by\n  simpa using is_invariant_one A\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/SlashActions.lean", "context": {"open": ["Complex UpperHalfPlane ModularGroup", "scoped MatrixGroups", "scoped ModularForm"], "variables": ["{k : \u2124} (f : \u210d \u2192 \u2102)", "{\u03b1 : Type*} [SMul \u03b1 \u2102] [IsScalarTower \u03b1 \u2102 \u2102]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Matrix.SpecialLinearGroup (Fin 2) \u2124\n\u22a2 SlashAction.map \u2102 0 (\u2191A) 1 = 1"}, {"line": "simpa using is_invariant_one A", "tactic_state": "No Goals!"}]}
{"declaration": "lemma norm_eq_max_natAbs (x : Fin 2 \u2192 \u2124) : \u2016x\u2016 = max (x 0).natAbs (x 1).natAbs := by\n  rw [\u2190 coe_nnnorm]\n  rw [\u2190 NNReal.coe_natCast]\n  rw [NNReal.coe_inj]\n  rw [Nat.cast_max]\n  refine eq_of_forall_ge_iff fun c \u21a6 ?_\n  simp only [pi_nnnorm_le_iff]\n  simp only [Fin.forall_fin_two]\n  simp only [max_le_iff]\n  simp only [NNReal.natCast_natAbs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/EisensteinSeries/UniformConvergence.lean", "context": {"open": ["Complex UpperHalfPlane Set Finset CongruenceSubgroup Topology", "scoped UpperHalfPlane"], "variables": ["(z : \u210d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : Fin 2 \u2192 \u2124\n\u22a2 \u2016x\u2016 = \u2191(max (x 0).natAbs (x 1).natAbs)"}, {"line": "rw [\u2190 coe_nnnorm]", "tactic_state": "x : Fin 2 \u2192 \u2124\n\u22a2 \u2191\u2016x\u2016\u208a = \u2191(max (x 0).natAbs (x 1).natAbs)"}, {"line": "rw [\u2190 NNReal.coe_natCast]", "tactic_state": "x : Fin 2 \u2192 \u2124\n\u22a2 \u2191\u2016x\u2016\u208a = \u2191\u2191(max (x 0).natAbs (x 1).natAbs)"}, {"line": "rw [NNReal.coe_inj]", "tactic_state": "x : Fin 2 \u2192 \u2124\n\u22a2 \u2016x\u2016\u208a = \u2191(max (x 0).natAbs (x 1).natAbs)"}, {"line": "rw [Nat.cast_max]", "tactic_state": "x : Fin 2 \u2192 \u2124\n\u22a2 \u2016x\u2016\u208a = max \u2191(x 0).natAbs \u2191(x 1).natAbs"}, {"line": "refine eq_of_forall_ge_iff fun c \u21a6 ?_", "tactic_state": "x : Fin 2 \u2192 \u2124\nc : NNReal\n\u22a2 \u2016x\u2016\u208a \u2264 c \u2194 max \u2191(x 0).natAbs \u2191(x 1).natAbs \u2264 c"}, {"line": "simp only [pi_nnnorm_le_iff]", "tactic_state": "x : Fin 2 \u2192 \u2124\nc : NNReal\n\u22a2 (\u2200 (i : Fin 2), \u2016x i\u2016\u208a \u2264 c) \u2194 max \u2191(x 0).natAbs \u2191(x 1).natAbs \u2264 c"}, {"line": "simp only [Fin.forall_fin_two]", "tactic_state": "x : Fin 2 \u2192 \u2124\nc : NNReal\n\u22a2 \u2016x 0\u2016\u208a \u2264 c \u2227 \u2016x 1\u2016\u208a \u2264 c \u2194 max \u2191(x 0).natAbs \u2191(x 1).natAbs \u2264 c"}, {"line": "simp only [max_le_iff]", "tactic_state": "x : Fin 2 \u2192 \u2124\nc : NNReal\n\u22a2 \u2016x 0\u2016\u208a \u2264 c \u2227 \u2016x 1\u2016\u208a \u2264 c \u2194 \u2191(x 0).natAbs \u2264 c \u2227 \u2191(x 1).natAbs \u2264 c"}, {"line": "simp only [NNReal.natCast_natAbs]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isBigO_exp_neg_mul_of_le {c d : \u211d} (hcd : c \u2264 d) :\n    (fun t \u21a6 exp (-d * t)) =O[atTop] fun t \u21a6 exp (-c * t) := by\n  apply Eventually.isBigO\n  filter_upwards [eventually_gt_atTop 0] with t ht\n  rwa [norm_of_nonneg (exp_pos _).le, exp_le_exp, mul_le_mul_right ht, neg_le_neg_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/Bounds.lean", "context": {"open": ["Set Filter Topology Asymptotics Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c d : \u211d\nhcd : c \u2264 d\n\u22a2 (fun t => exp (-d * t)) =O[atTop] fun t => exp (-c * t)"}, {"line": "apply Eventually.isBigO", "tactic_state": "case hfg\nc d : \u211d\nhcd : c \u2264 d\n\u22a2 \u2200\u1da0 (x : \u211d) in atTop, \u2016exp (-d * x)\u2016 \u2264 exp (-c * x)"}, {"line": "filter_upwards [eventually_gt_atTop 0] with t ht", "tactic_state": "case h\nc d : \u211d\nhcd : c \u2264 d\nt : \u211d\nht : 0 < t\n\u22a2 \u2016exp (-d * t)\u2016 \u2264 exp (-c * t)"}, {"line": "rwa [norm_of_nonneg (exp_pos _).le, exp_le_exp, mul_le_mul_right ht, neg_le_neg_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma exp_lt_aux {t : \u211d} (ht : 0 < t) : rexp (-\u03c0 * t) < 1 := by\n  simpa only [exp_lt_one_iff,neg_mul,neg_lt_zero] using mul_pos pi_pos ht\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/Bounds.lean", "context": {"open": ["Set Filter Topology Asymptotics Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "t : \u211d\nht : 0 < t\n\u22a2 exp (-Real.pi * t) < 1"}, {"line": "simpa only [exp_lt_one_iff,neg_mul,neg_lt_zero] using mul_pos pi_pos ht", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma isBigO_one_aux :\n    IsBigO atTop (fun t : \u211d \u21a6 (1 - rexp (-\u03c0 * t))\u207b\u00b9) (fun _ \u21a6 (1 : \u211d)) := by\n  refine ((Tendsto.const_sub _ ?_).inv\u2080 (by norm_num)).isBigO_one \u211d (c := ((1 - 0)\u207b\u00b9 : \u211d))\n  simpa only [neg_mul,tendsto_exp_comp_nhds_zero,tendsto_neg_atBot_iff]\n    using tendsto_id.const_mul_atTop pi_pos\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/Bounds.lean", "context": {"open": ["Set Filter Topology Asymptotics Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun t => (1 - exp (-Real.pi * t))\u207b\u00b9) =O[atTop] fun x => 1"}, {"line": "refine ((Tendsto.const_sub _ ?_).inv\u2080 (by norm_num)).isBigO_one \u211d (c := ((1 - 0)\u207b\u00b9 : \u211d))", "tactic_state": "\u22a2 Tendsto (fun x => exp (-Real.pi * x)) atTop (nhds 0)"}, {"line": "simpa only [neg_mul,tendsto_exp_comp_nhds_zero,tendsto_neg_atBot_iff]\n    using tendsto_id.const_mul_atTop pi_pos", "tactic_state": "No Goals!"}]}
{"declaration": "theorem jacobiTheta_two_add (\u03c4 : \u2102) : jacobiTheta (2 + \u03c4) = jacobiTheta \u03c4 := by\n  simp_rw [jacobiTheta_eq_jacobiTheta\u2082, add_comm, jacobiTheta\u2082_add_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/OneVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped Real UpperHalfPlane"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c4 : \u2102\n\u22a2 jacobiTheta (2 + \u03c4) = jacobiTheta \u03c4"}, {"line": "simp_rw [jacobiTheta_eq_jacobiTheta\u2082, add_comm, jacobiTheta\u2082_add_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem jacobiTheta_T_sq_smul (\u03c4 : \u210d) : jacobiTheta (ModularGroup.T ^ 2 \u2022 \u03c4 :) = jacobiTheta \u03c4 := by\n  suffices (ModularGroup.T ^ 2 \u2022 \u03c4 :) = (2 : \u2102) + \u2191\u03c4 by simp_rw [this, jacobiTheta_two_add]\n  have : ModularGroup.T ^ (2 : \u2115) = ModularGroup.T ^ (2 : \u2124) := rfl\n  simp_rw [this, UpperHalfPlane.modular_T_zpow_smul, UpperHalfPlane.coe_vadd]\n  norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/OneVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped Real UpperHalfPlane"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c4 : UpperHalfPlane\n\u22a2 jacobiTheta \u2191(ModularGroup.T ^ 2 \u2022 \u03c4) = jacobiTheta \u2191\u03c4"}, {"line": "suffices (ModularGroup.T ^ 2 \u2022 \u03c4 :) = (2 : \u2102) + \u2191\u03c4 by simp_rw [this, jacobiTheta_two_add]", "tactic_state": "\u03c4 : UpperHalfPlane\n\u22a2 \u2191(ModularGroup.T ^ 2 \u2022 \u03c4) = 2 + \u2191\u03c4"}, {"line": "have : ModularGroup.T ^ (2 : \u2115) = ModularGroup.T ^ (2 : \u2124) := rfl", "tactic_state": "\u03c4 : UpperHalfPlane\nthis : ModularGroup.T ^ 2 = ModularGroup.T ^ 2\n\u22a2 \u2191(ModularGroup.T ^ 2 \u2022 \u03c4) = 2 + \u2191\u03c4"}, {"line": "simp_rw [this, UpperHalfPlane.modular_T_zpow_smul, UpperHalfPlane.coe_vadd]", "tactic_state": "\u03c4 : UpperHalfPlane\nthis : ModularGroup.T ^ 2 = ModularGroup.T ^ 2\n\u22a2 \u2191\u21912 + \u2191\u03c4 = 2 + \u2191\u03c4"}, {"line": "norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "theorem jacobiTheta_S_smul (\u03c4 : \u210d) :\n    jacobiTheta \u2191(ModularGroup.S \u2022 \u03c4) = (-I * \u03c4) ^ (1 / 2 : \u2102) * jacobiTheta \u03c4 := by\n  have h0 : (\u03c4 : \u2102) \u2260 0 := ne_of_apply_ne im (zero_im.symm \u25b8 ne_of_gt \u03c4.2)\n  have h1 : (-I * \u03c4) ^ (1 / 2 : \u2102) \u2260 0 := by\n    rw [Ne]\n    rw [cpow_eq_zero_iff]\n    rw [not_and_or]\n    exact Or.inl <| mul_ne_zero (neg_ne_zero.mpr I_ne_zero) h0\n  simp_rw [UpperHalfPlane.modular_S_smul, jacobiTheta_eq_jacobiTheta\u2082, \u2190 ofReal_zero]\n  norm_cast\n  simp_rw [jacobiTheta\u2082_functional_equation 0 \u03c4, zero_pow two_ne_zero, mul_zero, zero_div,\n    Complex.exp_zero, mul_one, \u2190 mul_assoc, mul_one_div, div_self h1, one_mul,\n    UpperHalfPlane.coe_mk, inv_neg, neg_div, one_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/OneVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped Real UpperHalfPlane"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c4 : UpperHalfPlane\n\u22a2 jacobiTheta \u2191(ModularGroup.S \u2022 \u03c4) = (-I * \u2191\u03c4) ^ (1 / 2) * jacobiTheta \u2191\u03c4"}, {"line": "have h0 : (\u03c4 : \u2102) \u2260 0 := ne_of_apply_ne im (zero_im.symm \u25b8 ne_of_gt \u03c4.2)", "tactic_state": "\u03c4 : UpperHalfPlane\nh0 : \u2191\u03c4 \u2260 0\n\u22a2 jacobiTheta \u2191(ModularGroup.S \u2022 \u03c4) = (-I * \u2191\u03c4) ^ (1 / 2) * jacobiTheta \u2191\u03c4"}, {"line": "have h1 : (-I * \u03c4) ^ (1 / 2 : \u2102) \u2260 0 := sorry", "tactic_state": "\u03c4 : UpperHalfPlane\nh0 : \u2191\u03c4 \u2260 0\nh1 : (-I * \u2191\u03c4) ^ (1 / 2) \u2260 0\n\u22a2 jacobiTheta \u2191(ModularGroup.S \u2022 \u03c4) = (-I * \u2191\u03c4) ^ (1 / 2) * jacobiTheta \u2191\u03c4"}, {"line": "simp_rw [UpperHalfPlane.modular_S_smul, jacobiTheta_eq_jacobiTheta\u2082, \u2190 ofReal_zero]", "tactic_state": "\u03c4 : UpperHalfPlane\nh0 : \u2191\u03c4 \u2260 0\nh1 : (-I * \u2191\u03c4) ^ (1 / 2) \u2260 0\n\u22a2 jacobiTheta\u2082 \u21910 \u2191(UpperHalfPlane.mk (-\u2191\u03c4)\u207b\u00b9 \u22ef) = (-I * \u2191\u03c4) ^ (1 / 2) * jacobiTheta\u2082 \u21910 \u2191\u03c4"}, {"line": "norm_cast", "tactic_state": "\u03c4 : UpperHalfPlane\nh0 : \u2191\u03c4 \u2260 0\nh1 : (-I * \u2191\u03c4) ^ (1 / 2) \u2260 0\n\u22a2 jacobiTheta\u2082 0 \u2191(UpperHalfPlane.mk (-\u2191\u03c4)\u207b\u00b9 \u22ef) = (-I * \u2191\u03c4) ^ (1 / 2) * jacobiTheta\u2082 0 \u2191\u03c4"}, {"line": "simp_rw [jacobiTheta\u2082_functional_equation 0 \u03c4, zero_pow two_ne_zero, mul_zero, zero_div,\n    Complex.exp_zero, mul_one, \u2190 mul_assoc, mul_one_div, div_self h1, one_mul,\n    UpperHalfPlane.coe_mk, inv_neg, neg_div, one_div]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasSum_nat_jacobiTheta {\u03c4 : \u2102} (h\u03c4 : 0 < im \u03c4) :\n    HasSum (fun n : \u2115 => cexp (\u03c0 * I * ((n : \u2102) + 1) ^ 2 * \u03c4)) ((jacobiTheta \u03c4 - 1) / 2) := by\n  have := hasSum_jacobiTheta\u2082_term 0 h\u03c4\n  simp_rw [jacobiTheta\u2082_term, mul_zero, zero_add, \u2190 jacobiTheta_eq_jacobiTheta\u2082] at this\n  have := this.nat_add_neg\n  rw [\u2190 hasSum_nat_add_iff' 1] at this\n  simp_rw [Finset.sum_range_one, Int.cast_neg, Int.cast_natCast, Nat.cast_zero, neg_zero,\n    Int.cast_zero, sq (0 : \u2102), mul_zero, zero_mul, neg_sq, \u2190 mul_two,\n    Complex.exp_zero, add_sub_assoc, (by norm_num : (1 : \u2102) - 1 * 2 = -1), \u2190 sub_eq_add_neg,\n    Nat.cast_add, Nat.cast_one] at this\n  convert this.div_const 2 using 1\n  simp_rw [mul_div_cancel_right\u2080 _ (two_ne_zero' \u2102)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/OneVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped Real UpperHalfPlane"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\n\u22a2 HasSum (fun n => Complex.exp (\u2191Real.pi * I * (\u2191n + 1) ^ 2 * \u03c4)) ((jacobiTheta \u03c4 - 1) / 2)"}, {"line": "have := hasSum_jacobiTheta\u2082_term 0 h\u03c4", "tactic_state": "\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nthis : HasSum (fun n => jacobiTheta\u2082_term n 0 \u03c4) (jacobiTheta\u2082 0 \u03c4)\n\u22a2 HasSum (fun n => Complex.exp (\u2191Real.pi * I * (\u2191n + 1) ^ 2 * \u03c4)) ((jacobiTheta \u03c4 - 1) / 2)"}, {"line": "simp_rw [jacobiTheta\u2082_term, mul_zero, zero_add, \u2190 jacobiTheta_eq_jacobiTheta\u2082] at this", "tactic_state": "\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nthis : HasSum (fun n => Complex.exp (\u2191Real.pi * I * \u2191n ^ 2 * \u03c4)) (jacobiTheta \u03c4)\n\u22a2 HasSum (fun n => Complex.exp (\u2191Real.pi * I * (\u2191n + 1) ^ 2 * \u03c4)) ((jacobiTheta \u03c4 - 1) / 2)"}, {"line": "have := this.nat_add_neg", "tactic_state": "\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nthis\u271d : HasSum (fun n => Complex.exp (\u2191Real.pi * I * \u2191n ^ 2 * \u03c4)) (jacobiTheta \u03c4)\nthis :\n  HasSum (fun n => Complex.exp (\u2191Real.pi * I * \u2191\u2191n ^ 2 * \u03c4) + Complex.exp (\u2191Real.pi * I * \u2191(-\u2191n) ^ 2 * \u03c4))\n    (jacobiTheta \u03c4 + Complex.exp (\u2191Real.pi * I * \u21910 ^ 2 * \u03c4))\n\u22a2 HasSum (fun n => Complex.exp (\u2191Real.pi * I * (\u2191n + 1) ^ 2 * \u03c4)) ((jacobiTheta \u03c4 - 1) / 2)"}, {"line": "rw [\u2190 hasSum_nat_add_iff' 1] at this", "tactic_state": "\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nthis\u271d : HasSum (fun n => Complex.exp (\u2191Real.pi * I * \u2191n ^ 2 * \u03c4)) (jacobiTheta \u03c4)\nthis :\n  HasSum (fun n => Complex.exp (\u2191Real.pi * I * \u2191\u2191(n + 1) ^ 2 * \u03c4) + Complex.exp (\u2191Real.pi * I * \u2191(-\u2191(n + 1)) ^ 2 * \u03c4))\n    (jacobiTheta \u03c4 + Complex.exp (\u2191Real.pi * I * \u21910 ^ 2 * \u03c4) -\n      \u2211 i \u2208 Finset.range 1, (Complex.exp (\u2191Real.pi * I * \u2191\u2191i ^ 2 * \u03c4) + Complex.exp (\u2191Real.pi * I * \u2191(-\u2191i) ^ 2 * \u03c4)))\n\u22a2 HasSum (fun n => Complex.exp (\u2191Real.pi * I * (\u2191n + 1) ^ 2 * \u03c4)) ((jacobiTheta \u03c4 - 1) / 2)"}, {"line": "simp_rw [Finset.sum_range_one, Int.cast_neg, Int.cast_natCast, Nat.cast_zero, neg_zero,\n    Int.cast_zero, sq (0 : \u2102), mul_zero, zero_mul, neg_sq, \u2190 mul_two,\n    Complex.exp_zero, add_sub_assoc, (by norm_num : (1 : \u2102) - 1 * 2 = -1), \u2190 sub_eq_add_neg,\n    Nat.cast_add, Nat.cast_one] at this", "tactic_state": "\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nthis\u271d : HasSum (fun n => Complex.exp (\u2191Real.pi * I * \u2191n ^ 2 * \u03c4)) (jacobiTheta \u03c4)\nthis : HasSum (fun n => Complex.exp (\u2191Real.pi * I * (\u2191n + 1) ^ 2 * \u03c4) * 2) (jacobiTheta \u03c4 - 1)\n\u22a2 HasSum (fun n => Complex.exp (\u2191Real.pi * I * (\u2191n + 1) ^ 2 * \u03c4)) ((jacobiTheta \u03c4 - 1) / 2)"}, {"line": "convert this.div_const 2 using 1", "tactic_state": "case h.e'_5\n\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nthis\u271d : HasSum (fun n => Complex.exp (\u2191Real.pi * I * \u2191n ^ 2 * \u03c4)) (jacobiTheta \u03c4)\nthis : HasSum (fun n => Complex.exp (\u2191Real.pi * I * (\u2191n + 1) ^ 2 * \u03c4) * 2) (jacobiTheta \u03c4 - 1)\n\u22a2 (fun n => Complex.exp (\u2191Real.pi * I * (\u2191n + 1) ^ 2 * \u03c4)) = fun i =>\n    Complex.exp (\u2191Real.pi * I * (\u2191i + 1) ^ 2 * \u03c4) * 2 / 2"}, {"line": "simp_rw [mul_div_cancel_right\u2080 _ (two_ne_zero' \u2102)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem jacobiTheta_eq_tsum_nat {\u03c4 : \u2102} (h\u03c4 : 0 < im \u03c4) :\n    jacobiTheta \u03c4 = \u21911 + \u21912 * \u2211' n : \u2115, cexp (\u03c0 * I * ((n : \u2102) + 1) ^ 2 * \u03c4) := by\n  rw [(hasSum_nat_jacobiTheta h\u03c4).tsum_eq]\n  rw [mul_div_cancel\u2080 _ (two_ne_zero' \u2102)]\n  rw [\u2190 add_sub_assoc]\n  rw [add_sub_cancel_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/OneVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped Real UpperHalfPlane"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\n\u22a2 jacobiTheta \u03c4 = 1 + 2 * \u2211' (n : \u2115), Complex.exp (\u2191Real.pi * I * (\u2191n + 1) ^ 2 * \u03c4)"}, {"line": "rw [(hasSum_nat_jacobiTheta h\u03c4).tsum_eq]", "tactic_state": "\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\n\u22a2 jacobiTheta \u03c4 = 1 + 2 * ((jacobiTheta \u03c4 - 1) / 2)"}, {"line": "rw [mul_div_cancel\u2080 _ (two_ne_zero' \u2102)]", "tactic_state": "\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\n\u22a2 jacobiTheta \u03c4 = 1 + (jacobiTheta \u03c4 - 1)"}, {"line": "rw [\u2190 add_sub_assoc]", "tactic_state": "\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\n\u22a2 jacobiTheta \u03c4 = 1 + jacobiTheta \u03c4 - 1"}, {"line": "rw [add_sub_cancel_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isBigO_at_im_infty_jacobiTheta_sub_one :\n    (fun \u03c4 => jacobiTheta \u03c4 - 1) =O[comap im atTop] fun \u03c4 => rexp (-\u03c0 * \u03c4.im) := by\n  simp_rw [IsBigO, IsBigOWith, Filter.eventually_comap, Filter.eventually_atTop]\n  refine \u27e82 / (1 - rexp (-(\u03c0 * 1))), 1, fun y hy \u03c4 h\u03c4 =>\n    (norm_jacobiTheta_sub_one_le (h\u03c4.symm \u25b8 zero_lt_one.trans_le hy : 0 < im \u03c4)).trans ?_\u27e9\n  rw [Real.norm_eq_abs]\n  rw [Real.abs_exp]\n  rw [h\u03c4]\n  rw [neg_mul]\n  gcongr\n  simp [pi_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/OneVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped Real UpperHalfPlane"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun \u03c4 => jacobiTheta \u03c4 - 1) =O[comap im atTop] fun \u03c4 => Real.exp (-Real.pi * \u03c4.im)"}, {"line": "simp_rw [IsBigO, IsBigOWith, Filter.eventually_comap, Filter.eventually_atTop]", "tactic_state": "\u22a2 \u2203 c a, \u2200 b \u2265 a, \u2200 (a : \u2102), a.im = b \u2192 \u2016jacobiTheta a - 1\u2016 \u2264 c * \u2016Real.exp (-Real.pi * a.im)\u2016"}, {"line": "refine \u27e82 / (1 - rexp (-(\u03c0 * 1))), 1, fun y hy \u03c4 h\u03c4 =>\n    (norm_jacobiTheta_sub_one_le (h\u03c4.symm \u25b8 zero_lt_one.trans_le hy : 0 < im \u03c4)).trans ?_\u27e9", "tactic_state": "y : \u211d\nhy : y \u2265 1\n\u03c4 : \u2102\nh\u03c4 : \u03c4.im = y\n\u22a2 2 / (1 - Real.exp (-Real.pi * \u03c4.im)) * Real.exp (-Real.pi * \u03c4.im) \u2264 2 / (1 - sorry) * \u2016Real.exp (-Real.pi * \u03c4.im)\u2016"}, {"line": "rw [Real.norm_eq_abs]", "tactic_state": "y : \u211d\nhy : y \u2265 1\n\u03c4 : \u2102\nh\u03c4 : \u03c4.im = y\n\u22a2 2 / (1 - Real.exp (-Real.pi * \u03c4.im)) * Real.exp (-Real.pi * \u03c4.im) \u2264 2 / (1 - sorry) * |Real.exp (-Real.pi * \u03c4.im)|"}, {"line": "rw [Real.abs_exp]", "tactic_state": "y : \u211d\nhy : y \u2265 1\n\u03c4 : \u2102\nh\u03c4 : \u03c4.im = y\n\u22a2 2 / (1 - Real.exp (-Real.pi * \u03c4.im)) * Real.exp (-Real.pi * \u03c4.im) \u2264 2 / (1 - sorry) * Real.exp (-Real.pi * \u03c4.im)"}, {"line": "rw [h\u03c4]", "tactic_state": "y : \u211d\nhy : y \u2265 1\n\u03c4 : \u2102\nh\u03c4 : \u03c4.im = y\n\u22a2 2 / (1 - Real.exp (-Real.pi * y)) * Real.exp (-Real.pi * y) \u2264 2 / (1 - sorry) * Real.exp (-Real.pi * y)"}, {"line": "rw [neg_mul]", "tactic_state": "y : \u211d\nhy : y \u2265 1\n\u03c4 : \u2102\nh\u03c4 : \u03c4.im = y\n\u22a2 2 / (1 - Real.exp (-(Real.pi * y))) * Real.exp (-(Real.pi * y)) \u2264 2 / (1 - sorry) * Real.exp (-(Real.pi * y))"}, {"line": "gcongr", "tactic_state": "case h.hc\ny : \u211d\nhy : y \u2265 1\n\u03c4 : \u2102\nh\u03c4 : \u03c4.im = y\n\u22a2 0 < 1 - sorry\n---\ncase h.h.h\ny : \u211d\nhy : y \u2265 1\n\u03c4 : \u2102\nh\u03c4 : \u03c4.im = y\n\u22a2 Real.exp (-(Real.pi * y)) \u2264 sorry"}, {"line": "simp [pi_pos]", "tactic_state": "case h.hc\ny : \u211d\nhy : y \u2265 1\n\u03c4 : \u2102\nh\u03c4 : \u03c4.im = y\n\u22a2 sorry () < 1\n---\ncase h.h.h\ny : \u211d\nhy : y \u2265 1\n\u03c4 : \u2102\nh\u03c4 : \u03c4.im = y\n\u22a2 Real.exp (-(Real.pi * y)) \u2264 sorry"}]}
{"declaration": "theorem differentiableAt_jacobiTheta {\u03c4 : \u2102} (h\u03c4 : 0 < im \u03c4) :\n    DifferentiableAt \u2102 jacobiTheta \u03c4 := by\n  simp_rw [funext jacobiTheta_eq_jacobiTheta\u2082]\n  exact differentiableAt_jacobiTheta\u2082_snd 0 h\u03c4\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/OneVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped Real UpperHalfPlane"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\n\u22a2 DifferentiableAt \u2102 jacobiTheta \u03c4"}, {"line": "simp_rw [funext jacobiTheta_eq_jacobiTheta\u2082]", "tactic_state": "\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\n\u22a2 DifferentiableAt \u2102 (jacobiTheta\u2082 0) \u03c4"}, {"line": "exact differentiableAt_jacobiTheta\u2082_snd 0 h\u03c4", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hasFDerivAt_jacobiTheta\u2082_term (n : \u2124) (z \u03c4 : \u2102) :\n    HasFDerivAt (fun p : \u2102 \u00d7 \u2102 \u21a6 jacobiTheta\u2082_term n p.1 p.2)\n    (jacobiTheta\u2082_term_fderiv n z \u03c4) (z, \u03c4) := by\n  let f : \u2102 \u00d7 \u2102 \u2192 \u2102 := fun p \u21a6 2 * \u03c0 * I * n * p.1 + \u03c0 * I * n ^ 2 * p.2\n  suffices HasFDerivAt f ((2 * \u03c0 * I * n) \u2022 (ContinuousLinearMap.fst \u2102 \u2102 \u2102)\n    + (\u03c0 * I * n ^ 2) \u2022 (ContinuousLinearMap.snd \u2102 \u2102 \u2102)) (z, \u03c4) from this.cexp\n  exact (hasFDerivAt_fst.const_mul _).add (hasFDerivAt_snd.const_mul _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\nz \u03c4 : \u2102\n\u22a2 HasFDerivAt (fun p => jacobiTheta\u2082_term n p.1 p.2) (jacobiTheta\u2082_term_fderiv n z \u03c4) (z, \u03c4)"}, {"line": "let f : \u2102 \u00d7 \u2102 \u2192 \u2102 := fun p \u21a6 2 * \u03c0 * I * n * p.1 + \u03c0 * I * n ^ 2 * p.2", "tactic_state": "n : \u2124\nz \u03c4 : \u2102\nf : \u2102 \u00d7 \u2102 \u2192 \u2102 := fun p => 2 * sorry * I * \u2191n * p.1 + sorry * I * \u2191n ^ 2 * p.2\n\u22a2 HasFDerivAt (fun p => jacobiTheta\u2082_term n p.1 p.2) (jacobiTheta\u2082_term_fderiv n z \u03c4) (z, \u03c4)"}, {"line": "suffices HasFDerivAt f ((2 * \u03c0 * I * n) \u2022 (ContinuousLinearMap.fst \u2102 \u2102 \u2102)\n    + (\u03c0 * I * n ^ 2) \u2022 (ContinuousLinearMap.snd \u2102 \u2102 \u2102)) (z, \u03c4) from this.cexp", "tactic_state": "n : \u2124\nz \u03c4 : \u2102\nf : \u2102 \u00d7 \u2102 \u2192 \u2102 := fun p => 2 * sorry * I * \u2191n * p.1 + sorry * I * \u2191n ^ 2 * p.2\n\u22a2 HasFDerivAt f\n    ((2 * sorry * I * \u2191n) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 + (sorry * I * \u2191n ^ 2) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) (z, \u03c4)"}, {"line": "exact (hasFDerivAt_fst.const_mul _).add (hasFDerivAt_snd.const_mul _)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma norm_jacobiTheta\u2082'_term_le {S T : \u211d} (hT : 0 < T) {z \u03c4 : \u2102}\n    (hz : |im z| \u2264 S) (h\u03c4 : T \u2264 im \u03c4) (n : \u2124) :\n    \u2016jacobiTheta\u2082'_term n z \u03c4\u2016 \u2264 2 * \u03c0 * |n| * rexp (-\u03c0 * (T * n ^ 2 - 2 * S * |n|)) := by\n  rw [jacobiTheta\u2082'_term]\n  rw [norm_mul]\n  refine mul_le_mul (le_of_eq ?_) (norm_jacobiTheta\u2082_term_le hT hz h\u03c4 n)\n    (norm_nonneg _) (by positivity)\n  simp only [norm_mul]\n  simp only [Complex.norm_two]\n  simp only [norm_I]\n  simp only [Complex.norm_of_nonneg pi_pos.le]\n  simp only [norm_intCast]\n  simp only [mul_one]\n  simp only [Int.cast_abs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "S T : \u211d\nhT : 0 < T\nz \u03c4 : \u2102\nhz : |z.im| \u2264 S\nh\u03c4 : T \u2264 \u03c4.im\nn : \u2124\n\u22a2 \u2016jacobiTheta\u2082'_term n z \u03c4\u2016 \u2264 2 * Real.pi * \u2191|n| * Real.exp (-Real.pi * (T * \u2191n ^ 2 - 2 * S * \u2191|n|))"}, {"line": "rw [jacobiTheta\u2082'_term]", "tactic_state": "S T : \u211d\nhT : 0 < T\nz \u03c4 : \u2102\nhz : |z.im| \u2264 S\nh\u03c4 : T \u2264 \u03c4.im\nn : \u2124\n\u22a2 \u20162 * \u2191Real.pi * I * \u2191n * jacobiTheta\u2082_term n z \u03c4\u2016 \u2264\n    2 * Real.pi * \u2191|n| * Real.exp (-Real.pi * (T * \u2191n ^ 2 - 2 * S * \u2191|n|))"}, {"line": "rw [norm_mul]", "tactic_state": "S T : \u211d\nhT : 0 < T\nz \u03c4 : \u2102\nhz : |z.im| \u2264 S\nh\u03c4 : T \u2264 \u03c4.im\nn : \u2124\n\u22a2 \u20162 * \u2191Real.pi * I * \u2191n\u2016 * \u2016jacobiTheta\u2082_term n z \u03c4\u2016 \u2264\n    2 * Real.pi * \u2191|n| * Real.exp (-Real.pi * (T * \u2191n ^ 2 - 2 * S * \u2191|n|))"}, {"line": "refine mul_le_mul (le_of_eq ?_) (norm_jacobiTheta\u2082_term_le hT hz h\u03c4 n)\n    (norm_nonneg _) (by positivity)", "tactic_state": "S T : \u211d\nhT : 0 < T\nz \u03c4 : \u2102\nhz : |z.im| \u2264 S\nh\u03c4 : T \u2264 \u03c4.im\nn : \u2124\n\u22a2 \u20162 * \u2191Real.pi * I * \u2191n\u2016 = 2 * Real.pi * \u2191|n|"}, {"line": "simp only [norm_mul]", "tactic_state": "S T : \u211d\nhT : 0 < T\nz \u03c4 : \u2102\nhz : |z.im| \u2264 S\nh\u03c4 : T \u2264 \u03c4.im\nn : \u2124\n\u22a2 \u20162\u2016 * \u2016\u2191Real.pi\u2016 * \u2016I\u2016 * \u2016\u2191n\u2016 = 2 * Real.pi * \u2191|n|"}, {"line": "simp only [Complex.norm_two]", "tactic_state": "S T : \u211d\nhT : 0 < T\nz \u03c4 : \u2102\nhz : |z.im| \u2264 S\nh\u03c4 : T \u2264 \u03c4.im\nn : \u2124\n\u22a2 2 * \u2016\u2191Real.pi\u2016 * \u2016I\u2016 * \u2016\u2191n\u2016 = 2 * Real.pi * \u2191|n|"}, {"line": "simp only [norm_I]", "tactic_state": "S T : \u211d\nhT : 0 < T\nz \u03c4 : \u2102\nhz : |z.im| \u2264 S\nh\u03c4 : T \u2264 \u03c4.im\nn : \u2124\n\u22a2 2 * \u2016\u2191Real.pi\u2016 * 1 * \u2016\u2191n\u2016 = 2 * Real.pi * \u2191|n|"}, {"line": "simp only [Complex.norm_of_nonneg pi_pos.le]", "tactic_state": "S T : \u211d\nhT : 0 < T\nz \u03c4 : \u2102\nhz : |z.im| \u2264 S\nh\u03c4 : T \u2264 \u03c4.im\nn : \u2124\n\u22a2 2 * Real.pi * 1 * \u2016\u2191n\u2016 = 2 * Real.pi * \u2191|n|"}, {"line": "simp only [norm_intCast]", "tactic_state": "S T : \u211d\nhT : 0 < T\nz \u03c4 : \u2102\nhz : |z.im| \u2264 S\nh\u03c4 : T \u2264 \u03c4.im\nn : \u2124\n\u22a2 2 * Real.pi * 1 * |\u2191n| = 2 * Real.pi * \u2191|n|"}, {"line": "simp only [mul_one]", "tactic_state": "S T : \u211d\nhT : 0 < T\nz \u03c4 : \u2102\nhz : |z.im| \u2264 S\nh\u03c4 : T \u2264 \u03c4.im\nn : \u2124\n\u22a2 2 * Real.pi * |\u2191n| = 2 * Real.pi * \u2191|n|"}, {"line": "simp only [Int.cast_abs]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma summable_pow_mul_jacobiTheta\u2082_term_bound (S : \u211d) {T : \u211d} (hT : 0 < T) (k : \u2115) :\n    Summable (fun n : \u2124 \u21a6 (|n| ^ k : \u211d) * Real.exp (-\u03c0 * (T * n ^ 2 - 2 * S * |n|))) := by\n  suffices Summable (fun n : \u2115 \u21a6 (n ^ k : \u211d) * Real.exp (-\u03c0 * (T * n ^ 2 - 2 * S * n))) by\n    apply Summable.of_nat_of_neg <;>\n    simpa only [Int.cast_neg,neg_sq,abs_neg,Int.cast_natCast,Nat.abs_cast]\n  apply summable_of_isBigO_nat (summable_pow_mul_exp_neg_nat_mul k zero_lt_one)\n  apply IsBigO.mul (isBigO_refl _ _)\n  refine Real.isBigO_exp_comp_exp_comp.mpr (Tendsto.isBoundedUnder_le_atBot ?_)\n  simp_rw [\u2190 tendsto_neg_atTop_iff, Pi.sub_apply]\n  conv =>\n    enter [1, n]\n    rw [show -(-\u03c0 * (T * n ^ 2 - 2 * S * n) - -1 * n) = n * (\u03c0 * T * n - (2 * \u03c0 * S + 1)) by ring]\n  refine tendsto_natCast_atTop_atTop.atTop_mul_atTop\u2080 (tendsto_atTop_add_const_right _ _ ?_)\n  exact tendsto_natCast_atTop_atTop.const_mul_atTop (mul_pos pi_pos hT)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "S T : \u211d\nhT : 0 < T\nk : \u2115\n\u22a2 Summable fun n => \u2191|n| ^ k * Real.exp (-Real.pi * (T * \u2191n ^ 2 - 2 * S * \u2191|n|))"}, {"line": "suffices Summable (fun n : \u2115 \u21a6 (n ^ k : \u211d) * Real.exp (-\u03c0 * (T * n ^ 2 - 2 * S * n))) by\n    apply Summable.of_nat_of_neg <;>\n    simpa only [Int.cast_neg,neg_sq,abs_neg,Int.cast_natCast,Nat.abs_cast]", "tactic_state": "S T : \u211d\nhT : 0 < T\nk : \u2115\n\u22a2 Summable fun n => \u2191n ^ k * Real.exp (-sorry * (T * \u2191n ^ 2 - 2 * S * \u2191n))"}, {"line": "apply summable_of_isBigO_nat (summable_pow_mul_exp_neg_nat_mul k zero_lt_one)", "tactic_state": "S T : \u211d\nhT : 0 < T\nk : \u2115\n\u22a2 (fun n => \u2191n ^ k * Real.exp (-sorry * (T * \u2191n ^ 2 - 2 * S * \u2191n))) =O[atTop] fun n => \u2191n ^ k * Real.exp (-1 * \u2191n)"}, {"line": "apply IsBigO.mul (isBigO_refl _ _)", "tactic_state": "S T : \u211d\nhT : 0 < T\nk : \u2115\n\u22a2 (fun x => Real.exp (-sorry * (T * \u2191x ^ 2 - 2 * S * \u2191x))) =O[atTop] fun x => Real.exp (-1 * \u2191x)"}, {"line": "refine Real.isBigO_exp_comp_exp_comp.mpr (Tendsto.isBoundedUnder_le_atBot ?_)", "tactic_state": "S T : \u211d\nhT : 0 < T\nk : \u2115\n\u22a2 Tendsto ((fun x => -sorry * (T * \u2191x ^ 2 - 2 * S * \u2191x)) - fun x => -1 * \u2191x) atTop atBot"}, {"line": "simp_rw [\u2190 tendsto_neg_atTop_iff, Pi.sub_apply]", "tactic_state": "S T : \u211d\nhT : 0 < T\nk : \u2115\n\u22a2 Tendsto (fun x => -(-sorry * (T * \u2191x ^ 2 - 2 * S * \u2191x) - -1 * \u2191x)) atTop atTop"}, {"line": "conv =>\n    enter [1, n]\n    rw [show -(-\u03c0 * (T * n ^ 2 - 2 * S * n) - -1 * n) = n * (\u03c0 * T * n - (2 * \u03c0 * S + 1)) by ring]", "tactic_state": "S T : \u211d\nhT : 0 < T\nk : \u2115\n\u22a2 Tendsto (fun n => \u2191n * (sorry * T * \u2191n - (2 * sorry * S + 1))) atTop atTop"}, {"line": "refine tendsto_natCast_atTop_atTop.atTop_mul_atTop\u2080 (tendsto_atTop_add_const_right _ _ ?_)", "tactic_state": "S T : \u211d\nhT : 0 < T\nk : \u2115\n\u22a2 Tendsto (fun n => sorry * T * \u2191n) atTop atTop"}, {"line": "exact tendsto_natCast_atTop_atTop.const_mul_atTop (mul_pos pi_pos hT)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma jacobiTheta\u2082_undef (z : \u2102) {\u03c4 : \u2102} (h\u03c4 : im \u03c4 \u2264 0) : jacobiTheta\u2082 z \u03c4 = 0 := by\n  apply tsum_eq_zero_of_not_summable\n  rw [summable_jacobiTheta\u2082_term_iff]\n  exact not_lt.mpr h\u03c4\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z \u03c4 : \u2102\nh\u03c4 : \u03c4.im \u2264 0\n\u22a2 jacobiTheta\u2082 z \u03c4 = 0"}, {"line": "apply tsum_eq_zero_of_not_summable", "tactic_state": "case h\nz \u03c4 : \u2102\nh\u03c4 : \u03c4.im \u2264 0\n\u22a2 \u00acSummable fun b => jacobiTheta\u2082_term b z \u03c4"}, {"line": "rw [summable_jacobiTheta\u2082_term_iff]", "tactic_state": "case h\nz \u03c4 : \u2102\nh\u03c4 : \u03c4.im \u2264 0\n\u22a2 \u00ac0 < \u03c4.im"}, {"line": "exact not_lt.mpr h\u03c4", "tactic_state": "No Goals!"}]}
{"declaration": "lemma jacobiTheta\u2082_fderiv_undef (z : \u2102) {\u03c4 : \u2102} (h\u03c4 : im \u03c4 \u2264 0) : jacobiTheta\u2082_fderiv z \u03c4 = 0 := by\n  apply tsum_eq_zero_of_not_summable\n  rw [summable_jacobiTheta\u2082_term_fderiv_iff]\n  exact not_lt.mpr h\u03c4\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z \u03c4 : \u2102\nh\u03c4 : \u03c4.im \u2264 0\n\u22a2 jacobiTheta\u2082_fderiv z \u03c4 = 0"}, {"line": "apply tsum_eq_zero_of_not_summable", "tactic_state": "case h\nz \u03c4 : \u2102\nh\u03c4 : \u03c4.im \u2264 0\n\u22a2 \u00acSummable fun b => jacobiTheta\u2082_term_fderiv b z \u03c4"}, {"line": "rw [summable_jacobiTheta\u2082_term_fderiv_iff]", "tactic_state": "case h\nz \u03c4 : \u2102\nh\u03c4 : \u03c4.im \u2264 0\n\u22a2 \u00ac0 < \u03c4.im"}, {"line": "exact not_lt.mpr h\u03c4", "tactic_state": "No Goals!"}]}
{"declaration": "lemma jacobiTheta\u2082'_undef (z : \u2102) {\u03c4 : \u2102} (h\u03c4 : im \u03c4 \u2264 0) : jacobiTheta\u2082' z \u03c4 = 0 := by\n  apply tsum_eq_zero_of_not_summable\n  rw [summable_jacobiTheta\u2082'_term_iff]\n  exact not_lt.mpr h\u03c4\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z \u03c4 : \u2102\nh\u03c4 : \u03c4.im \u2264 0\n\u22a2 jacobiTheta\u2082' z \u03c4 = 0"}, {"line": "apply tsum_eq_zero_of_not_summable", "tactic_state": "case h\nz \u03c4 : \u2102\nh\u03c4 : \u03c4.im \u2264 0\n\u22a2 \u00acSummable fun b => jacobiTheta\u2082'_term b z \u03c4"}, {"line": "rw [summable_jacobiTheta\u2082'_term_iff]", "tactic_state": "case h\nz \u03c4 : \u2102\nh\u03c4 : \u03c4.im \u2264 0\n\u22a2 \u00ac0 < \u03c4.im"}, {"line": "exact not_lt.mpr h\u03c4", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hasFDerivAt_jacobiTheta\u2082 (z : \u2102) {\u03c4 : \u2102} (h\u03c4 : 0 < im \u03c4) :\n    HasFDerivAt (fun p : \u2102 \u00d7 \u2102 \u21a6 jacobiTheta\u2082 p.1 p.2) (jacobiTheta\u2082_fderiv z \u03c4) (z, \u03c4) := by\n  obtain \u27e8T, hT, h\u03c4'\u27e9 := exists_between h\u03c4\n  obtain \u27e8S, hz\u27e9 := exists_gt |im z|\n  let V := {u | |im u| < S} \u00d7\u02e2 {v | T < im v}\n  have hVo : IsOpen V := by\n    refine ((_root_.continuous_abs.comp continuous_im).isOpen_preimage _ isOpen_Iio).prod ?_\n    exact continuous_im.isOpen_preimage _ isOpen_Ioi\n  have hVmem : (z, \u03c4) \u2208 V := \u27e8hz, h\u03c4'\u27e9\n  have hVp : IsPreconnected V := by\n    refine (Convex.isPreconnected ?_).prod (convex_halfSpace_im_gt T).isPreconnected\n    simpa only [abs_lt] using (convex_halfSpace_im_gt _).inter (convex_halfSpace_im_lt _)\n  let f : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 := fun n p \u21a6 jacobiTheta\u2082_term n p.1 p.2\n  let f' : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 \u00d7 \u2102 \u2192L[\u2102] \u2102 := fun n p \u21a6 jacobiTheta\u2082_term_fderiv n p.1 p.2\n  have hf (n : \u2124) : \u2200 p \u2208 V, HasFDerivAt (f n) (f' n p) p :=\n    fun p _ \u21a6 hasFDerivAt_jacobiTheta\u2082_term n p.1 p.2\n  let u : \u2124 \u2192 \u211d := fun n \u21a6 3 * \u03c0 * |n| ^ 2 * Real.exp (-\u03c0 * (T * n ^ 2 - 2 * S * |n|))\n  have hu : \u2200 (n : \u2124), \u2200 x \u2208 V, \u2016f' n x\u2016 \u2264 u n := by\n    refine fun n p hp \u21a6 (norm_jacobiTheta\u2082_term_fderiv_le n p.1 p.2).trans ?_\n    refine mul_le_mul_of_nonneg_left ?_ (by positivity)\n    exact norm_jacobiTheta\u2082_term_le hT (le_of_lt hp.1) (le_of_lt hp.2) n\n  have hu_sum : Summable u := by\n    simp_rw [u, mul_assoc (3 * \u03c0)]\n    exact (summable_pow_mul_jacobiTheta\u2082_term_bound S hT 2).mul_left _\n  have hf_sum : Summable fun n : \u2124 \u21a6 f n (z, \u03c4) := by\n    refine (summable_pow_mul_jacobiTheta\u2082_term_bound S hT 0).of_norm_bounded _ ?_\n    simpa only [pow_zero,one_mul] using norm_jacobiTheta\u2082_term_le hT hz.le h\u03c4'.le\n  simpa only [jacobiTheta\u2082,jacobiTheta\u2082_fderiv,f,f'] using\n    hasFDerivAt_tsum_of_isPreconnected hu_sum hVo hVp hf hu hVmem hf_sum hVmem\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\n\u22a2 HasFDerivAt (fun p => jacobiTheta\u2082 p.1 p.2) (jacobiTheta\u2082_fderiv z \u03c4) (z, \u03c4)"}, {"line": "obtain \u27e8T, hT, h\u03c4'\u27e9 := exists_between h\u03c4", "tactic_state": "case intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\n\u22a2 HasFDerivAt (fun p => jacobiTheta\u2082 p.1 p.2) (jacobiTheta\u2082_fderiv z \u03c4) (z, \u03c4)"}, {"line": "obtain \u27e8S, hz\u27e9 := exists_gt |im z|", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\n\u22a2 HasFDerivAt (fun p => jacobiTheta\u2082 p.1 p.2) (jacobiTheta\u2082_fderiv z \u03c4) (z, \u03c4)"}, {"line": "let V := {u | |im u| < S} \u00d7\u02e2 {v | T < im v}", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\n\u22a2 HasFDerivAt (fun p => jacobiTheta\u2082 p.1 p.2) (jacobiTheta\u2082_fderiv z \u03c4) (z, \u03c4)"}, {"line": "have hVo : IsOpen V := sorry", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\n\u22a2 HasFDerivAt (fun p => jacobiTheta\u2082 p.1 p.2) (jacobiTheta\u2082_fderiv z \u03c4) (z, \u03c4)"}, {"line": "have hVmem : (z, \u03c4) \u2208 V := \u27e8hz, h\u03c4'\u27e9", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\nhVmem : (z, \u03c4) \u2208 V\n\u22a2 HasFDerivAt (fun p => jacobiTheta\u2082 p.1 p.2) (jacobiTheta\u2082_fderiv z \u03c4) (z, \u03c4)"}, {"line": "have hVp : IsPreconnected V := sorry", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\nhVmem : (z, \u03c4) \u2208 V\nhVp : IsPreconnected V\n\u22a2 HasFDerivAt (fun p => jacobiTheta\u2082 p.1 p.2) (jacobiTheta\u2082_fderiv z \u03c4) (z, \u03c4)"}, {"line": "let f : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 := fun n p \u21a6 jacobiTheta\u2082_term n p.1 p.2", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\nhVmem : (z, \u03c4) \u2208 V\nhVp : IsPreconnected V\nf : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 := fun n p => jacobiTheta\u2082_term n p.1 p.2\n\u22a2 HasFDerivAt (fun p => jacobiTheta\u2082 p.1 p.2) (jacobiTheta\u2082_fderiv z \u03c4) (z, \u03c4)"}, {"line": "let f' : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 \u00d7 \u2102 \u2192L[\u2102] \u2102 := fun n p \u21a6 jacobiTheta\u2082_term_fderiv n p.1 p.2", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\nhVmem : (z, \u03c4) \u2208 V\nhVp : IsPreconnected V\nf : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 := fun n p => jacobiTheta\u2082_term n p.1 p.2\nf' : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 \u00d7 \u2102 \u2192L[\u2102] \u2102 := fun n p => jacobiTheta\u2082_term_fderiv n p.1 p.2\n\u22a2 HasFDerivAt (fun p => jacobiTheta\u2082 p.1 p.2) (jacobiTheta\u2082_fderiv z \u03c4) (z, \u03c4)"}, {"line": "have hf (n : \u2124) : \u2200 p \u2208 V, HasFDerivAt (f n) (f' n p) p :=\n    fun p _ \u21a6 hasFDerivAt_jacobiTheta\u2082_term n p.1 p.2", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\nhVmem : (z, \u03c4) \u2208 V\nhVp : IsPreconnected V\nf : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 := fun n p => jacobiTheta\u2082_term n p.1 p.2\nf' : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 \u00d7 \u2102 \u2192L[\u2102] \u2102 := fun n p => jacobiTheta\u2082_term_fderiv n p.1 p.2\nhf : \u2200 (n : \u2124), \u2200 p \u2208 V, HasFDerivAt (f n) (f' n p) p\n\u22a2 HasFDerivAt (fun p => jacobiTheta\u2082 p.1 p.2) (jacobiTheta\u2082_fderiv z \u03c4) (z, \u03c4)"}, {"line": "let u : \u2124 \u2192 \u211d := fun n \u21a6 3 * \u03c0 * |n| ^ 2 * Real.exp (-\u03c0 * (T * n ^ 2 - 2 * S * |n|))", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\nhVmem : (z, \u03c4) \u2208 V\nhVp : IsPreconnected V\nf : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 := fun n p => jacobiTheta\u2082_term n p.1 p.2\nf' : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 \u00d7 \u2102 \u2192L[\u2102] \u2102 := fun n p => jacobiTheta\u2082_term_fderiv n p.1 p.2\nhf : \u2200 (n : \u2124), \u2200 p \u2208 V, HasFDerivAt (f n) (f' n p) p\nu : \u2124 \u2192 \u211d := fun n => 3 * sorry * \u2191|n| ^ 2 * Real.exp (-sorry * (T * \u2191n ^ 2 - 2 * S * \u2191|n|))\n\u22a2 HasFDerivAt (fun p => jacobiTheta\u2082 p.1 p.2) (jacobiTheta\u2082_fderiv z \u03c4) (z, \u03c4)"}, {"line": "have hu : \u2200 (n : \u2124), \u2200 x \u2208 V, \u2016f' n x\u2016 \u2264 u n := sorry", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\nhVmem : (z, \u03c4) \u2208 V\nhVp : IsPreconnected V\nf : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 := fun n p => jacobiTheta\u2082_term n p.1 p.2\nf' : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 \u00d7 \u2102 \u2192L[\u2102] \u2102 := fun n p => jacobiTheta\u2082_term_fderiv n p.1 p.2\nhf : \u2200 (n : \u2124), \u2200 p \u2208 V, HasFDerivAt (f n) (f' n p) p\nu : \u2124 \u2192 \u211d := fun n => 3 * sorry * \u2191|n| ^ 2 * Real.exp (-sorry * (T * \u2191n ^ 2 - 2 * S * \u2191|n|))\nhu : \u2200 (n : \u2124), \u2200 x \u2208 V, \u2016f' n x\u2016 \u2264 u n\n\u22a2 HasFDerivAt (fun p => jacobiTheta\u2082 p.1 p.2) (jacobiTheta\u2082_fderiv z \u03c4) (z, \u03c4)"}, {"line": "have hu_sum : Summable u := sorry", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\nhVmem : (z, \u03c4) \u2208 V\nhVp : IsPreconnected V\nf : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 := fun n p => jacobiTheta\u2082_term n p.1 p.2\nf' : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 \u00d7 \u2102 \u2192L[\u2102] \u2102 := fun n p => jacobiTheta\u2082_term_fderiv n p.1 p.2\nhf : \u2200 (n : \u2124), \u2200 p \u2208 V, HasFDerivAt (f n) (f' n p) p\nu : \u2124 \u2192 \u211d := fun n => 3 * sorry * \u2191|n| ^ 2 * Real.exp (-sorry * (T * \u2191n ^ 2 - 2 * S * \u2191|n|))\nhu : \u2200 (n : \u2124), \u2200 x \u2208 V, \u2016f' n x\u2016 \u2264 u n\nhu_sum : Summable u\n\u22a2 HasFDerivAt (fun p => jacobiTheta\u2082 p.1 p.2) (jacobiTheta\u2082_fderiv z \u03c4) (z, \u03c4)"}, {"line": "have hf_sum : Summable fun n : \u2124 \u21a6 f n (z, \u03c4) := sorry", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\nhVmem : (z, \u03c4) \u2208 V\nhVp : IsPreconnected V\nf : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 := fun n p => jacobiTheta\u2082_term n p.1 p.2\nf' : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 \u00d7 \u2102 \u2192L[\u2102] \u2102 := fun n p => jacobiTheta\u2082_term_fderiv n p.1 p.2\nhf : \u2200 (n : \u2124), \u2200 p \u2208 V, HasFDerivAt (f n) (f' n p) p\nu : \u2124 \u2192 \u211d := fun n => 3 * sorry * \u2191|n| ^ 2 * Real.exp (-sorry * (T * \u2191n ^ 2 - 2 * S * \u2191|n|))\nhu : \u2200 (n : \u2124), \u2200 x \u2208 V, \u2016f' n x\u2016 \u2264 u n\nhu_sum : Summable u\nhf_sum : Summable fun n => f n (z, \u03c4)\n\u22a2 HasFDerivAt (fun p => jacobiTheta\u2082 p.1 p.2) (jacobiTheta\u2082_fderiv z \u03c4) (z, \u03c4)"}, {"line": "simpa only [jacobiTheta\u2082,jacobiTheta\u2082_fderiv,f,f'] using\n    hasFDerivAt_tsum_of_isPreconnected hu_sum hVo hVp hf hu hVmem hf_sum hVmem", "tactic_state": "No Goals!"}]}
{"declaration": "lemma continuousAt_jacobiTheta\u2082' (z : \u2102) {\u03c4 : \u2102} (h\u03c4 : 0 < im \u03c4) :\n    ContinuousAt (fun p : \u2102 \u00d7 \u2102 \u21a6 jacobiTheta\u2082' p.1 p.2) (z, \u03c4) := by\n  obtain \u27e8T, hT, h\u03c4'\u27e9 := exists_between h\u03c4\n  obtain \u27e8S, hz\u27e9 := exists_gt |im z|\n  let V := {u | |im u| < S} \u00d7\u02e2 {v | T < im v}\n  have hVo : IsOpen V := ((_root_.continuous_abs.comp continuous_im).isOpen_preimage _\n    isOpen_Iio).prod (continuous_im.isOpen_preimage _ isOpen_Ioi)\n  refine ContinuousOn.continuousAt ?_ (hVo.mem_nhds \u27e8hz, h\u03c4'\u27e9)\n  let u (n : \u2124) : \u211d := 2 * \u03c0 * |n| * rexp (-\u03c0 * (T * n ^ 2 - 2 * S * |n|))\n  have hu : Summable u  := by simpa only [u, mul_assoc, pow_one]\n      using (summable_pow_mul_jacobiTheta\u2082_term_bound S hT 1).mul_left (2 * \u03c0)\n  refine continuousOn_tsum (fun n \u21a6 ?_) hu (fun n \u27e8z', \u03c4'\u27e9 \u27e8hz', h\u03c4'\u27e9 \u21a6 ?_)\n  \u00b7 apply Continuous.continuousOn\n    unfold jacobiTheta\u2082'_term jacobiTheta\u2082_term\n    fun_prop\n  \u00b7 exact norm_jacobiTheta\u2082'_term_le hT (le_of_lt hz') (le_of_lt h\u03c4') n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\n\u22a2 ContinuousAt (fun p => jacobiTheta\u2082' p.1 p.2) (z, \u03c4)"}, {"line": "obtain \u27e8T, hT, h\u03c4'\u27e9 := exists_between h\u03c4", "tactic_state": "case intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\n\u22a2 ContinuousAt (fun p => jacobiTheta\u2082' p.1 p.2) (z, \u03c4)"}, {"line": "obtain \u27e8S, hz\u27e9 := exists_gt |im z|", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\n\u22a2 ContinuousAt (fun p => jacobiTheta\u2082' p.1 p.2) (z, \u03c4)"}, {"line": "let V := {u | |im u| < S} \u00d7\u02e2 {v | T < im v}", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\n\u22a2 ContinuousAt (fun p => jacobiTheta\u2082' p.1 p.2) (z, \u03c4)"}, {"line": "have hVo : IsOpen V := ((_root_.continuous_abs.comp continuous_im).isOpen_preimage _\n    isOpen_Iio).prod (continuous_im.isOpen_preimage _ isOpen_Ioi)", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\n\u22a2 ContinuousAt (fun p => jacobiTheta\u2082' p.1 p.2) (z, \u03c4)"}, {"line": "refine ContinuousOn.continuousAt ?_ (hVo.mem_nhds \u27e8hz, h\u03c4'\u27e9)", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\n\u22a2 ContinuousOn (fun p => jacobiTheta\u2082' p.1 p.2) V"}, {"line": "let u (n : \u2124) : \u211d := 2 * \u03c0 * |n| * rexp (-\u03c0 * (T * n ^ 2 - 2 * S * |n|))", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\nu : \u2124 \u2192 \u211d := fun n => 2 * sorry * \u2191|n| * sorry\n\u22a2 ContinuousOn (fun p => jacobiTheta\u2082' p.1 p.2) V"}, {"line": "have hu : Summable u := sorry", "tactic_state": "case intro.intro.intro\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\nu : \u2124 \u2192 \u211d := fun n => 2 * sorry * \u2191|n| * sorry\nhu : Summable u\n\u22a2 ContinuousOn (fun p => jacobiTheta\u2082' p.1 p.2) V"}, {"line": "refine continuousOn_tsum (fun n \u21a6 ?_) hu (fun n \u27e8z', \u03c4'\u27e9 \u27e8hz', h\u03c4'\u27e9 \u21a6 ?_)", "tactic_state": "case intro.intro.intro.refine_1\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\nu : \u2124 \u2192 \u211d := fun n => 2 * sorry * \u2191|n| * sorry\nhu : Summable u\nn : \u2124\n\u22a2 ContinuousOn (fun p => jacobiTheta\u2082'_term n p.1 p.2) V\n---\ncase intro.intro.intro.refine_2\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4'\u271d : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\nu : \u2124 \u2192 \u211d := fun n => 2 * sorry * \u2191|n| * sorry\nhu : Summable u\nn : \u2124\nx\u271d\u00b9 : \u2102 \u00d7 \u2102\nz' \u03c4' : \u2102\nx\u271d : (z', \u03c4') \u2208 V\nhz' : (z', \u03c4').1 \u2208 {u | |u.im| < S}\nh\u03c4' : (z', \u03c4').2 \u2208 {v | T < v.im}\n\u22a2 \u2016jacobiTheta\u2082'_term n (z', \u03c4').1 (z', \u03c4').2\u2016 \u2264 u n"}, {"line": "\u00b7 apply Continuous.continuousOn\n    unfold jacobiTheta\u2082'_term jacobiTheta\u2082_term\n    fun_prop", "tactic_state": "case intro.intro.intro.refine_2\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4'\u271d : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\nu : \u2124 \u2192 \u211d := fun n => 2 * sorry * \u2191|n| * sorry\nhu : Summable u\nn : \u2124\nx\u271d\u00b9 : \u2102 \u00d7 \u2102\nz' \u03c4' : \u2102\nx\u271d : (z', \u03c4') \u2208 V\nhz' : (z', \u03c4').1 \u2208 {u | |u.im| < S}\nh\u03c4' : (z', \u03c4').2 \u2208 {v | T < v.im}\n\u22a2 \u2016jacobiTheta\u2082'_term n (z', \u03c4').1 (z', \u03c4').2\u2016 \u2264 u n"}, {"line": "\u00b7 exact norm_jacobiTheta\u2082'_term_le hT (le_of_lt hz') (le_of_lt h\u03c4') n", "tactic_state": "No Goals!"}]}
{"declaration": "lemma jacobiTheta\u2082_add_left (z \u03c4 : \u2102) : jacobiTheta\u2082 (z + 1) \u03c4 = jacobiTheta\u2082 z \u03c4 := by\n  refine tsum_congr (fun n \u21a6 ?_)\n  simp_rw [jacobiTheta\u2082_term, mul_add, Complex.exp_add, mul_one, mul_comm _ (n : \u2102),\n    exp_int_mul_two_pi_mul_I, mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z \u03c4 : \u2102\n\u22a2 jacobiTheta\u2082 (z + 1) \u03c4 = jacobiTheta\u2082 z \u03c4"}, {"line": "refine tsum_congr (fun n \u21a6 ?_)", "tactic_state": "z \u03c4 : \u2102\nn : \u2124\n\u22a2 jacobiTheta\u2082_term n (z + 1) \u03c4 = jacobiTheta\u2082_term n z \u03c4"}, {"line": "simp_rw [jacobiTheta\u2082_term, mul_add, Complex.exp_add, mul_one, mul_comm _ (n : \u2102),\n    exp_int_mul_two_pi_mul_I, mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma jacobiTheta\u2082_add_left' (z \u03c4 : \u2102) :\n    jacobiTheta\u2082 (z + \u03c4) \u03c4 = cexp (-\u03c0 * I * (\u03c4 + 2 * z)) * jacobiTheta\u2082 z \u03c4 := by\n  conv_rhs => rw [jacobiTheta\u2082, \u2190 tsum_mul_left, \u2190 (Equiv.addRight 1).tsum_eq]\n  refine tsum_congr (fun n \u21a6 ?_)\n  simp_rw [jacobiTheta\u2082_term, \u2190 Complex.exp_add, Equiv.coe_addRight, Int.cast_add]\n  ring_nf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z \u03c4 : \u2102\n\u22a2 jacobiTheta\u2082 (z + \u03c4) \u03c4 = Complex.exp (-\u2191Real.pi * I * (\u03c4 + 2 * z)) * jacobiTheta\u2082 z \u03c4"}, {"line": "conv_rhs => rw [jacobiTheta\u2082, \u2190 tsum_mul_left, \u2190 (Equiv.addRight 1).tsum_eq]", "tactic_state": "z \u03c4 : \u2102\n\u22a2 jacobiTheta\u2082 (z + \u03c4) \u03c4 =\n    \u2211' (c : \u2124), Complex.exp (-\u2191Real.pi * I * (\u03c4 + 2 * z)) * jacobiTheta\u2082_term ((Equiv.addRight 1) c) z \u03c4"}, {"line": "refine tsum_congr (fun n \u21a6 ?_)", "tactic_state": "z \u03c4 : \u2102\nn : \u2124\n\u22a2 jacobiTheta\u2082_term n (z + \u03c4) \u03c4 =\n    Complex.exp (-\u2191Real.pi * I * (\u03c4 + 2 * z)) * jacobiTheta\u2082_term ((Equiv.addRight 1) n) z \u03c4"}, {"line": "simp_rw [jacobiTheta\u2082_term, \u2190 Complex.exp_add, Equiv.coe_addRight, Int.cast_add]", "tactic_state": "z \u03c4 : \u2102\nn : \u2124\n\u22a2 Complex.exp (2 * \u2191Real.pi * I * \u2191n * (z + \u03c4) + \u2191Real.pi * I * \u2191n ^ 2 * \u03c4) =\n    Complex.exp (-\u2191Real.pi * I * (\u03c4 + 2 * z) + (2 * \u2191Real.pi * I * (\u2191n + \u21911) * z + \u2191Real.pi * I * (\u2191n + \u21911) ^ 2 * \u03c4))"}, {"line": "ring_nf", "tactic_state": "No Goals!"}]}
{"declaration": "lemma jacobiTheta\u2082_neg_left (z \u03c4 : \u2102) : jacobiTheta\u2082 (-z) \u03c4 = jacobiTheta\u2082 z \u03c4 := by\n  conv_lhs => rw [jacobiTheta\u2082, \u2190 Equiv.tsum_eq (Equiv.neg \u2124)]\n  refine tsum_congr (fun n \u21a6 ?_)\n  simp_rw [jacobiTheta\u2082_term, Equiv.neg_apply, Int.cast_neg, neg_sq, mul_assoc, neg_mul_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z \u03c4 : \u2102\n\u22a2 jacobiTheta\u2082 (-z) \u03c4 = jacobiTheta\u2082 z \u03c4"}, {"line": "conv_lhs => rw [jacobiTheta\u2082, \u2190 Equiv.tsum_eq (Equiv.neg \u2124)]", "tactic_state": "z \u03c4 : \u2102\n\u22a2 \u2211' (c : \u2124), jacobiTheta\u2082_term ((Equiv.neg \u2124) c) (-z) \u03c4 = jacobiTheta\u2082 z \u03c4"}, {"line": "refine tsum_congr (fun n \u21a6 ?_)", "tactic_state": "z \u03c4 : \u2102\nn : \u2124\n\u22a2 jacobiTheta\u2082_term ((Equiv.neg \u2124) n) (-z) \u03c4 = jacobiTheta\u2082_term n z \u03c4"}, {"line": "simp_rw [jacobiTheta\u2082_term, Equiv.neg_apply, Int.cast_neg, neg_sq, mul_assoc, neg_mul_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma jacobiTheta\u2082'_add_left (z \u03c4 : \u2102) : jacobiTheta\u2082' (z + 1) \u03c4 = jacobiTheta\u2082' z \u03c4 := by\n  unfold jacobiTheta\u2082' jacobiTheta\u2082'_term jacobiTheta\u2082_term\n  refine tsum_congr (fun n \u21a6 ?_)\n  simp only [mul_add]\n  simp only [Complex.exp_add]\n  simp only [mul_one]\n  simp only [mul_comm _ (n : \u2102)]\n  simp only [exp_int_mul_two_pi_mul_I]\n  simp only [mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z \u03c4 : \u2102\n\u22a2 jacobiTheta\u2082' (z + 1) \u03c4 = jacobiTheta\u2082' z \u03c4"}, {"line": "unfold jacobiTheta\u2082' jacobiTheta\u2082'_term jacobiTheta\u2082_term", "tactic_state": "z \u03c4 : \u2102\n\u22a2 \u2211' (n : \u2124), 2 * \u2191Real.pi * I * \u2191n * Complex.exp (2 * \u2191Real.pi * I * \u2191n * (z + 1) + \u2191Real.pi * I * \u2191n ^ 2 * \u03c4) =\n    \u2211' (n : \u2124), 2 * \u2191Real.pi * I * \u2191n * Complex.exp (2 * \u2191Real.pi * I * \u2191n * z + \u2191Real.pi * I * \u2191n ^ 2 * \u03c4)"}, {"line": "refine tsum_congr (fun n \u21a6 ?_)", "tactic_state": "z \u03c4 : \u2102\nn : \u2124\n\u22a2 2 * \u2191Real.pi * I * \u2191n * Complex.exp (2 * \u2191Real.pi * I * \u2191n * (z + 1) + \u2191Real.pi * I * \u2191n ^ 2 * \u03c4) =\n    2 * \u2191Real.pi * I * \u2191n * Complex.exp (2 * \u2191Real.pi * I * \u2191n * z + \u2191Real.pi * I * \u2191n ^ 2 * \u03c4)"}, {"line": "simp only [mul_add]", "tactic_state": "z \u03c4 : \u2102\nn : \u2124\n\u22a2 2 * \u2191Real.pi * I * \u2191n *\n      Complex.exp (2 * \u2191Real.pi * I * \u2191n * z + 2 * \u2191Real.pi * I * \u2191n * 1 + \u2191Real.pi * I * \u2191n ^ 2 * \u03c4) =\n    2 * \u2191Real.pi * I * \u2191n * Complex.exp (2 * \u2191Real.pi * I * \u2191n * z + \u2191Real.pi * I * \u2191n ^ 2 * \u03c4)"}, {"line": "simp only [Complex.exp_add]", "tactic_state": "z \u03c4 : \u2102\nn : \u2124\n\u22a2 2 * \u2191Real.pi * I * \u2191n *\n      (Complex.exp (2 * \u2191Real.pi * I * \u2191n * z) * Complex.exp (2 * \u2191Real.pi * I * \u2191n * 1) *\n        Complex.exp (\u2191Real.pi * I * \u2191n ^ 2 * \u03c4)) =\n    2 * \u2191Real.pi * I * \u2191n * (Complex.exp (2 * \u2191Real.pi * I * \u2191n * z) * Complex.exp (\u2191Real.pi * I * \u2191n ^ 2 * \u03c4))"}, {"line": "simp only [mul_one]", "tactic_state": "z \u03c4 : \u2102\nn : \u2124\n\u22a2 2 * \u2191Real.pi * I * \u2191n *\n      (Complex.exp (2 * \u2191Real.pi * I * \u2191n * z) * Complex.exp (2 * \u2191Real.pi * I * \u2191n) *\n        Complex.exp (\u2191Real.pi * I * \u2191n ^ 2 * \u03c4)) =\n    2 * \u2191Real.pi * I * \u2191n * (Complex.exp (2 * \u2191Real.pi * I * \u2191n * z) * Complex.exp (\u2191Real.pi * I * \u2191n ^ 2 * \u03c4))"}, {"line": "simp only [mul_comm _ (n : \u2102)]", "tactic_state": "z \u03c4 : \u2102\nn : \u2124\n\u22a2 \u2191n * (2 * \u2191Real.pi * I) *\n      (Complex.exp (\u2191n * (2 * \u2191Real.pi * I) * z) * Complex.exp (\u2191n * (2 * \u2191Real.pi * I)) *\n        Complex.exp (\u2191Real.pi * I * \u2191n ^ 2 * \u03c4)) =\n    \u2191n * (2 * \u2191Real.pi * I) * (Complex.exp (\u2191n * (2 * \u2191Real.pi * I) * z) * Complex.exp (\u2191Real.pi * I * \u2191n ^ 2 * \u03c4))"}, {"line": "simp only [exp_int_mul_two_pi_mul_I]", "tactic_state": "z \u03c4 : \u2102\nn : \u2124\n\u22a2 \u2191n * (2 * \u2191Real.pi * I) * (Complex.exp (\u2191n * (2 * \u2191Real.pi * I) * z) * 1 * Complex.exp (\u2191Real.pi * I * \u2191n ^ 2 * \u03c4)) =\n    \u2191n * (2 * \u2191Real.pi * I) * (Complex.exp (\u2191n * (2 * \u2191Real.pi * I) * z) * Complex.exp (\u2191Real.pi * I * \u2191n ^ 2 * \u03c4))"}, {"line": "simp only [mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma jacobiTheta\u2082'_neg_left (z \u03c4 : \u2102) : jacobiTheta\u2082' (-z) \u03c4 = -jacobiTheta\u2082' z \u03c4 := by\n  rw [jacobiTheta\u2082']\n  rw [jacobiTheta\u2082']\n  rw [\u2190 tsum_neg]\n  rw [\u2190 (Equiv.neg \u2124).tsum_eq]\n  congr 1 with n\n  simp only [jacobiTheta\u2082'_term]\n  simp only [jacobiTheta\u2082_term]\n  rw [Equiv.neg_apply]\n  rw [\u2190 neg_mul]\n  push_cast\n  ring_nf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z \u03c4 : \u2102\n\u22a2 jacobiTheta\u2082' (-z) \u03c4 = -jacobiTheta\u2082' z \u03c4"}, {"line": "rw [jacobiTheta\u2082']", "tactic_state": "z \u03c4 : \u2102\n\u22a2 \u2211' (n : \u2124), jacobiTheta\u2082'_term n (-z) \u03c4 = -jacobiTheta\u2082' z \u03c4"}, {"line": "rw [jacobiTheta\u2082']", "tactic_state": "z \u03c4 : \u2102\n\u22a2 \u2211' (n : \u2124), jacobiTheta\u2082'_term n (-z) \u03c4 = -\u2211' (n : \u2124), jacobiTheta\u2082'_term n z \u03c4"}, {"line": "rw [\u2190 tsum_neg]", "tactic_state": "z \u03c4 : \u2102\n\u22a2 \u2211' (n : \u2124), jacobiTheta\u2082'_term n (-z) \u03c4 = \u2211' (b : \u2124), -jacobiTheta\u2082'_term b z \u03c4"}, {"line": "rw [\u2190 (Equiv.neg \u2124).tsum_eq]", "tactic_state": "z \u03c4 : \u2102\n\u22a2 \u2211' (c : \u2124), jacobiTheta\u2082'_term ((Equiv.neg \u2124) c) (-z) \u03c4 = \u2211' (b : \u2124), -jacobiTheta\u2082'_term b z \u03c4"}, {"line": "congr 1 with n", "tactic_state": "case e_f.h\nz \u03c4 : \u2102\nn : \u2124\n\u22a2 jacobiTheta\u2082'_term ((Equiv.neg \u2124) n) (-z) \u03c4 = -jacobiTheta\u2082'_term n z \u03c4"}, {"line": "simp only [jacobiTheta\u2082'_term]", "tactic_state": "case e_f.h\nz \u03c4 : \u2102\nn : \u2124\n\u22a2 2 * \u2191Real.pi * I * \u2191((Equiv.neg \u2124) n) * jacobiTheta\u2082_term ((Equiv.neg \u2124) n) (-z) \u03c4 =\n    -(2 * \u2191Real.pi * I * \u2191n * jacobiTheta\u2082_term n z \u03c4)"}, {"line": "simp only [jacobiTheta\u2082_term]", "tactic_state": "case e_f.h\nz \u03c4 : \u2102\nn : \u2124\n\u22a2 2 * \u2191Real.pi * I * \u2191((Equiv.neg \u2124) n) *\n      Complex.exp (2 * \u2191Real.pi * I * \u2191((Equiv.neg \u2124) n) * -z + \u2191Real.pi * I * \u2191((Equiv.neg \u2124) n) ^ 2 * \u03c4) =\n    -(2 * \u2191Real.pi * I * \u2191n * Complex.exp (2 * \u2191Real.pi * I * \u2191n * z + \u2191Real.pi * I * \u2191n ^ 2 * \u03c4))"}, {"line": "rw [Equiv.neg_apply]", "tactic_state": "case e_f.h\nz \u03c4 : \u2102\nn : \u2124\n\u22a2 2 * \u2191Real.pi * I * \u2191(-n) * Complex.exp (2 * \u2191Real.pi * I * \u2191(-n) * -z + \u2191Real.pi * I * \u2191(-n) ^ 2 * \u03c4) =\n    -(2 * \u2191Real.pi * I * \u2191n * Complex.exp (2 * \u2191Real.pi * I * \u2191n * z + \u2191Real.pi * I * \u2191n ^ 2 * \u03c4))"}, {"line": "rw [\u2190 neg_mul]", "tactic_state": "case e_f.h\nz \u03c4 : \u2102\nn : \u2124\n\u22a2 2 * \u2191Real.pi * I * \u2191(-n) * Complex.exp (2 * \u2191Real.pi * I * \u2191(-n) * -z + \u2191Real.pi * I * \u2191(-n) ^ 2 * \u03c4) =\n    -(2 * \u2191Real.pi * I * \u2191n) * Complex.exp (2 * \u2191Real.pi * I * \u2191n * z + \u2191Real.pi * I * \u2191n ^ 2 * \u03c4)"}, {"line": "push_cast", "tactic_state": "case e_f.h\nz \u03c4 : \u2102\nn : \u2124\n\u22a2 2 * \u2191Real.pi * I * -\u2191n * Complex.exp (2 * \u2191Real.pi * I * -\u2191n * -z + \u2191Real.pi * I * (-\u2191n) ^ 2 * \u03c4) =\n    -(2 * \u2191Real.pi * I * \u2191n) * Complex.exp (2 * \u2191Real.pi * I * \u2191n * z + \u2191Real.pi * I * \u2191n ^ 2 * \u03c4)"}, {"line": "ring_nf", "tactic_state": "No Goals!"}]}
{"declaration": "lemma jacobiTheta\u2082'_conj (z \u03c4 : \u2102) :\n    conj (jacobiTheta\u2082' z \u03c4) = jacobiTheta\u2082' (conj z) (-conj \u03c4) := by\n  rw [\u2190 neg_inj]\n  rw [\u2190 jacobiTheta\u2082'_neg_left]\n  rw [jacobiTheta\u2082']\n  rw [jacobiTheta\u2082']\n  rw [conj_tsum]\n  rw [\u2190 tsum_neg]\n  congr 1 with n\n  simp_rw [jacobiTheta\u2082'_term, jacobiTheta\u2082_term, map_mul, \u2190 Complex.exp_conj, map_add, map_mul,\n    \u2190 ofReal_intCast,\u2190 ofReal_ofNat, map_pow, conj_ofReal, conj_I]\n  ring_nf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean", "context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z \u03c4 : \u2102\n\u22a2 (starRingEnd \u2102) (jacobiTheta\u2082' z \u03c4) = jacobiTheta\u2082' ((starRingEnd \u2102) z) (-(starRingEnd \u2102) \u03c4)"}, {"line": "rw [\u2190 neg_inj]", "tactic_state": "z \u03c4 : \u2102\n\u22a2 -(starRingEnd \u2102) (jacobiTheta\u2082' z \u03c4) = -jacobiTheta\u2082' ((starRingEnd \u2102) z) (-(starRingEnd \u2102) \u03c4)"}, {"line": "rw [\u2190 jacobiTheta\u2082'_neg_left]", "tactic_state": "z \u03c4 : \u2102\n\u22a2 -(starRingEnd \u2102) (jacobiTheta\u2082' z \u03c4) = jacobiTheta\u2082' (-(starRingEnd \u2102) z) (-(starRingEnd \u2102) \u03c4)"}, {"line": "rw [jacobiTheta\u2082']", "tactic_state": "z \u03c4 : \u2102\n\u22a2 -(starRingEnd \u2102) (\u2211' (n : \u2124), jacobiTheta\u2082'_term n z \u03c4) = jacobiTheta\u2082' (-(starRingEnd \u2102) z) (-(starRingEnd \u2102) \u03c4)"}, {"line": "rw [jacobiTheta\u2082']", "tactic_state": "z \u03c4 : \u2102\n\u22a2 -(starRingEnd \u2102) (\u2211' (n : \u2124), jacobiTheta\u2082'_term n z \u03c4) =\n    \u2211' (n : \u2124), jacobiTheta\u2082'_term n (-(starRingEnd \u2102) z) (-(starRingEnd \u2102) \u03c4)"}, {"line": "rw [conj_tsum]", "tactic_state": "z \u03c4 : \u2102\n\u22a2 -\u2211' (a : \u2124), (starRingEnd \u2102) (jacobiTheta\u2082'_term a z \u03c4) =\n    \u2211' (n : \u2124), jacobiTheta\u2082'_term n (-(starRingEnd \u2102) z) (-(starRingEnd \u2102) \u03c4)"}, {"line": "rw [\u2190 tsum_neg]", "tactic_state": "z \u03c4 : \u2102\n\u22a2 \u2211' (b : \u2124), -(starRingEnd \u2102) (jacobiTheta\u2082'_term b z \u03c4) =\n    \u2211' (n : \u2124), jacobiTheta\u2082'_term n (-(starRingEnd \u2102) z) (-(starRingEnd \u2102) \u03c4)"}, {"line": "congr 1 with n", "tactic_state": "case e_f.h\nz \u03c4 : \u2102\nn : \u2124\n\u22a2 -(starRingEnd \u2102) (jacobiTheta\u2082'_term n z \u03c4) = jacobiTheta\u2082'_term n (-(starRingEnd \u2102) z) (-(starRingEnd \u2102) \u03c4)"}, {"line": "simp_rw [jacobiTheta\u2082'_term, jacobiTheta\u2082_term, map_mul, \u2190 Complex.exp_conj, map_add, map_mul,\n    \u2190 ofReal_intCast,\u2190 ofReal_ofNat, map_pow, conj_ofReal, conj_I]", "tactic_state": "case e_f.h\nz \u03c4 : \u2102\nn : \u2124\n\u22a2 -(\u21912 * \u2191Real.pi * -I * \u2191\u2191n *\n        Complex.exp (\u21912 * \u2191Real.pi * -I * \u2191\u2191n * (starRingEnd \u2102) z + \u2191Real.pi * -I * \u2191\u2191n ^ 2 * (starRingEnd \u2102) \u03c4)) =\n    \u21912 * \u2191Real.pi * I * \u2191\u2191n *\n      Complex.exp (\u21912 * \u2191Real.pi * I * \u2191\u2191n * -(starRingEnd \u2102) z + \u2191Real.pi * I * \u2191\u2191n ^ 2 * -(starRingEnd \u2102) \u03c4)"}, {"line": "ring_nf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ext' {\u03c7 \u03c7' : MulChar R R'} (h : \u2200 a, \u03c7 a = \u03c7' a) : \u03c7 = \u03c7' := by\n  cases \u03c7\n  cases \u03c7'\n  congr\n  exact MonoidHom.ext h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/MulChar/Basic.lean", "context": {"open": [], "variables": ["(R : Type*) [CommMonoid R]", "(R' : Type*) [CommMonoidWithZero R']", "{R : Type*} [CommMonoid R]", "{R' : Type*} [CommMonoidWithZero R']", "(R R') in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b9 : CommMonoid R\nR' : Type u_4\ninst\u271d : CommMonoidWithZero R'\n\u03c7 \u03c7' : MulChar R R'\nh : \u2200 (a : R), \u03c7 a = \u03c7' a\n\u22a2 \u03c7 = \u03c7'"}, {"line": "cases \u03c7", "tactic_state": "case mk\nR : Type u_3\ninst\u271d\u00b9 : CommMonoid R\nR' : Type u_4\ninst\u271d : CommMonoidWithZero R'\n\u03c7' : MulChar R R'\ntoMonoidHom\u271d : R \u2192* R'\nmap_nonunit'\u271d : \u2200 (a : R), \u00acIsUnit a \u2192 (\u2191toMonoidHom\u271d).toFun a = 0\nh : \u2200 (a : R), { toMonoidHom := toMonoidHom\u271d, map_nonunit' := map_nonunit'\u271d } a = \u03c7' a\n\u22a2 { toMonoidHom := toMonoidHom\u271d, map_nonunit' := map_nonunit'\u271d } = \u03c7'"}, {"line": "cases \u03c7'", "tactic_state": "case mk.mk\nR : Type u_3\ninst\u271d\u00b9 : CommMonoid R\nR' : Type u_4\ninst\u271d : CommMonoidWithZero R'\ntoMonoidHom\u271d\u00b9 : R \u2192* R'\nmap_nonunit'\u271d\u00b9 : \u2200 (a : R), \u00acIsUnit a \u2192 (\u2191toMonoidHom\u271d\u00b9).toFun a = 0\ntoMonoidHom\u271d : R \u2192* R'\nmap_nonunit'\u271d : \u2200 (a : R), \u00acIsUnit a \u2192 (\u2191toMonoidHom\u271d).toFun a = 0\nh :\n  \u2200 (a : R),\n    { toMonoidHom := toMonoidHom\u271d\u00b9, map_nonunit' := map_nonunit'\u271d\u00b9 } a =\n      { toMonoidHom := toMonoidHom\u271d, map_nonunit' := map_nonunit'\u271d } a\n\u22a2 { toMonoidHom := toMonoidHom\u271d\u00b9, map_nonunit' := map_nonunit'\u271d\u00b9 } =\n    { toMonoidHom := toMonoidHom\u271d, map_nonunit' := map_nonunit'\u271d }"}, {"line": "congr", "tactic_state": "case mk.mk.e_toMonoidHom\nR : Type u_3\ninst\u271d\u00b9 : CommMonoid R\nR' : Type u_4\ninst\u271d : CommMonoidWithZero R'\ntoMonoidHom\u271d\u00b9 : R \u2192* R'\nmap_nonunit'\u271d\u00b9 : \u2200 (a : R), \u00acIsUnit a \u2192 (\u2191toMonoidHom\u271d\u00b9).toFun a = 0\ntoMonoidHom\u271d : R \u2192* R'\nmap_nonunit'\u271d : \u2200 (a : R), \u00acIsUnit a \u2192 (\u2191toMonoidHom\u271d).toFun a = 0\nh :\n  \u2200 (a : R),\n    { toMonoidHom := toMonoidHom\u271d\u00b9, map_nonunit' := map_nonunit'\u271d\u00b9 } a =\n      { toMonoidHom := toMonoidHom\u271d, map_nonunit' := map_nonunit'\u271d } a\n\u22a2 toMonoidHom\u271d\u00b9 = toMonoidHom\u271d"}, {"line": "exact MonoidHom.ext h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_apply_coe (a : R\u02e3) : (1 : MulChar R R') a = 1 := by classical exact dif_pos a.isUnit\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/MulChar/Basic.lean", "context": {"open": [], "variables": ["(R : Type*) [CommMonoid R]", "(R' : Type*) [CommMonoidWithZero R']", "{R : Type*} [CommMonoid R]", "{R' : Type*} [CommMonoidWithZero R']", "(R R') in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b9 : CommMonoid R\nR' : Type u_4\ninst\u271d : CommMonoidWithZero R'\na : R\u02e3\n\u22a2 1 \u2191a = 1"}, {"line": "classical exact dif_pos a.isUnit", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsQuadratic.comp {\u03c7 : MulChar R R'} (h\u03c7 : \u03c7.IsQuadratic) (f : R' \u2192+* R'') :\n    (\u03c7.ringHomComp f).IsQuadratic := by\n  intro a\n  rcases h\u03c7 a with (ha | ha | ha) <;> simp [ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/MulChar/Basic.lean", "context": {"open": [], "variables": ["(R : Type*) [CommMonoid R]", "(R' : Type*) [CommMonoidWithZero R']", "{R : Type*} [CommMonoid R]", "{R' : Type*} [CommMonoidWithZero R']", "(R R') in", "{R : Type*} [CommMonoid R] {R' : Type*} [CommMonoidWithZero R']", "{R : Type*} [CommMonoid R] {R' : Type*} [CommRing R'] {R'' : Type*} [CommRing R'']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\ninst\u271d\u00b2 : CommMonoid R\nR' : Type u_6\ninst\u271d\u00b9 : CommRing R'\nR'' : Type u_7\ninst\u271d : CommRing R''\n\u03c7 : MulChar R R'\nh\u03c7 : \u03c7.IsQuadratic\nf : R' \u2192+* R''\n\u22a2 (\u03c7.ringHomComp f).IsQuadratic"}, {"line": "intro a", "tactic_state": "R : Type u_5\ninst\u271d\u00b2 : CommMonoid R\nR' : Type u_6\ninst\u271d\u00b9 : CommRing R'\nR'' : Type u_7\ninst\u271d : CommRing R''\n\u03c7 : MulChar R R'\nh\u03c7 : \u03c7.IsQuadratic\nf : R' \u2192+* R''\na : R\n\u22a2 (\u03c7.ringHomComp f) a = 0 \u2228 (\u03c7.ringHomComp f) a = 1 \u2228 (\u03c7.ringHomComp f) a = -1"}, {"line": "rcases h\u03c7 a with (ha | ha | ha) <;> simp [ha]", "tactic_state": "case inr.inl\nR : Type u_5\ninst\u271d\u00b2 : CommMonoid R\nR' : Type u_6\ninst\u271d\u00b9 : CommRing R'\nR'' : Type u_7\ninst\u271d : CommRing R''\n\u03c7 : MulChar R R'\nh\u03c7 : \u03c7.IsQuadratic\nf : R' \u2192+* R''\na : R\nha : \u03c7 a = 1\n\u22a2 f 1 = 0 \u2228 f 1 = 1 \u2228 f 1 = -1\n---\ncase inr.inr\nR : Type u_5\ninst\u271d\u00b2 : CommMonoid R\nR' : Type u_6\ninst\u271d\u00b9 : CommRing R'\nR'' : Type u_7\ninst\u271d : CommRing R''\n\u03c7 : MulChar R R'\nh\u03c7 : \u03c7.IsQuadratic\nf : R' \u2192+* R''\na : R\nha : \u03c7 a = -1\n\u22a2 f (-1) = 0 \u2228 f (-1) = 1 \u2228 f (-1) = -1"}]}
{"declaration": "theorem exists_apply_ne_one_of_hasEnoughRootsOfUnity [Nontrivial R] {a : M} (ha : a \u2260 1) :\n    \u2203 \u03c7 : MulChar M R, \u03c7 a \u2260 1 := by\n  by_cases hu : IsUnit a\n  \u00b7 refine (exists_apply_ne_one_iff_exists_monoidHom hu.unit).mpr ?_\n    refine CommGroup.exists_apply_ne_one_of_hasEnoughRootsOfUnity M\u02e3 R ?_\n    contrapose! ha\n    rw [\u2190 hu.unit_spec]\n    rw [ha]\n    rw [Units.val_eq_one]\n  \u00b7 exact \u27e81, by simpa only [map_nonunit _ hu] using zero_ne_one\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/MulChar/Duality.lean", "context": {"open": [], "variables": ["{M R : Type*} [CommMonoid M] [CommRing R]", "(M R)", "[Finite M] [HasEnoughRootsOfUnity R (Monoid.exponent M\u02e3)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nR : Type u_2\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : Finite M\ninst\u271d\u00b9 : HasEnoughRootsOfUnity R (Monoid.exponent M\u02e3)\ninst\u271d : Nontrivial R\na : M\nha : a \u2260 1\n\u22a2 \u2203 \u03c7, \u03c7 a \u2260 1"}, {"line": "by_cases hu : IsUnit a", "tactic_state": "case pos\nM : Type u_1\nR : Type u_2\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : Finite M\ninst\u271d\u00b9 : HasEnoughRootsOfUnity R (Monoid.exponent M\u02e3)\ninst\u271d : Nontrivial R\na : M\nha : a \u2260 1\nhu : sorry\n\u22a2 \u2203 \u03c7, \u03c7 a \u2260 1\n---\ncase neg\nM : Type u_1\nR : Type u_2\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : Finite M\ninst\u271d\u00b9 : HasEnoughRootsOfUnity R (Monoid.exponent M\u02e3)\ninst\u271d : Nontrivial R\na : M\nha : a \u2260 1\nhu : \u00acsorry\n\u22a2 \u2203 \u03c7, \u03c7 a \u2260 1"}, {"line": "\u00b7 refine (exists_apply_ne_one_iff_exists_monoidHom hu.unit).mpr ?_\n    refine CommGroup.exists_apply_ne_one_of_hasEnoughRootsOfUnity M\u02e3 R ?_\n    contrapose! ha\n    rw [\u2190 hu.unit_spec]\n    rw [ha]\n    rw [Units.val_eq_one]", "tactic_state": "case neg\nM : Type u_1\nR : Type u_2\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : Finite M\ninst\u271d\u00b9 : HasEnoughRootsOfUnity R (Monoid.exponent M\u02e3)\ninst\u271d : Nontrivial R\na : M\nha : a \u2260 1\nhu : \u00acsorry\n\u22a2 \u2203 \u03c7, \u03c7 a \u2260 1"}, {"line": "\u00b7 exact \u27e81, by simpa only [map_nonunit _ hu] using zero_ne_one\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mk_eq_mk (x y : K) (hx hy) : (\u27e8x, hx\u27e9 : \ud835\udcde K) = \u27e8y, hy\u27e9 \u2194 x = y := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/Basic.lean", "context": {"open": ["Function Module", "scoped nonZeroDivisors"], "variables": ["(K L : Type*) [Field K] [Field L]", "{K} {L} in", "{K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : Field K\nx\u271d : Sort u_3\n\ud835\udcde : x\u271d\nx y : K\nhx : ?m.494 K x y\nhy : ?m.495 K x y hx\n\u22a2 sorry = sorry \u2194 x = y"}, {"line": "simp", "tactic_state": "K : Type u_1\ninst\u271d : Field K\nx\u271d : Sort u_3\n\ud835\udcde : x\u271d\nx y : K\nhx : ?m.494 K x y\nhy : ?m.495 K x y hx\n\u22a2 x = y"}]}
{"declaration": "theorem coe_ringOfIntegersEquiv (z : \ud835\udcde \u211a) :\n    (Rat.ringOfIntegersEquiv z : \u211a) = algebraMap (\ud835\udcde \u211a) \u211a z := by\n  obtain \u27e8z, rfl\u27e9 := Rat.ringOfIntegersEquiv.symm.surjective z\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/Basic.lean", "context": {"open": ["Function Module", "scoped nonZeroDivisors", "NumberField"], "variables": ["(K L : Type*) [Field K] [Field L]", "{K} {L} in", "{K}", "{K}", "(K)", "[NumberField K]", "{K} {M : Type*}", "(K L : Type*) [Field K] [Field L] [Algebra K L]", "[NumberField K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : RingOfIntegers \u211a\n\u22a2 \u2191(Rat.ringOfIntegersEquiv z) = (algebraMap (RingOfIntegers \u211a) \u211a) z"}, {"line": "obtain \u27e8z, rfl\u27e9 := Rat.ringOfIntegersEquiv.symm.surjective z", "tactic_state": "case intro\nz : \u2124\n\u22a2 \u2191(Rat.ringOfIntegersEquiv (Rat.ringOfIntegersEquiv.symm z)) =\n    (algebraMap (RingOfIntegers \u211a) \u211a) (Rat.ringOfIntegersEquiv.symm z)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_eval_eq_rootSet_minpoly :\n    (range fun \u03c6 : K \u2192+* A => \u03c6 x) = (minpoly \u211a x).rootSet A := by\n  convert (NumberField.isAlgebraic K).range_eval_eq_rootSet_minpoly A x using 1\n  ext a\n  exact \u27e8fun \u27e8\u03c6, h\u03c6\u27e9 => \u27e8\u03c6.toRatAlgHom, h\u03c6\u27e9, fun \u27e8\u03c6, h\u03c6\u27e9 => \u27e8\u03c6.toRingHom, h\u03c6\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/Embeddings.lean", "context": {"open": ["scoped Finset", "Module", "Set Polynomial"], "variables": ["(K : Type*) [Field K] [NumberField K]", "(A : Type*) [Field A] [CharZero A]", "[IsAlgClosed A]", "(K A : Type*) [Field K] [NumberField K] [Field A] [Algebra \u211a A] [IsAlgClosed A] (x : K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_3\nA : Type u_4\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : NumberField K\ninst\u271d\u00b2 : Field A\ninst\u271d\u00b9 : Algebra \u211a A\ninst\u271d : IsAlgClosed A\nx : K\n\u22a2 (range fun \u03c6 => \u03c6 x) = (minpoly \u211a x).rootSet A"}, {"line": "convert (NumberField.isAlgebraic K).range_eval_eq_rootSet_minpoly A x using 1", "tactic_state": "case h.e'_2\nK : Type u_3\nA : Type u_4\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : NumberField K\ninst\u271d\u00b2 : Field A\ninst\u271d\u00b9 : Algebra \u211a A\ninst\u271d : IsAlgClosed A\nx : K\n\u22a2 (range fun \u03c6 => \u03c6 x) = range fun \u03c8 => \u03c8 x\n---\ncase convert_2\nK : Type u_3\nA : Type u_4\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : NumberField K\ninst\u271d\u00b2 : Field A\ninst\u271d\u00b9 : Algebra \u211a A\ninst\u271d : IsAlgClosed A\nx : K\n\u22a2 NumberField K\n---\ncase convert_5\nK : Type u_3\nA : Type u_4\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : NumberField K\ninst\u271d\u00b2 : Field A\ninst\u271d\u00b9 : Algebra \u211a A\ninst\u271d : IsAlgClosed A\nx : K\n\u22a2 IsAlgClosed A"}, {"line": "ext a", "tactic_state": "case h.e'_2.h\nK : Type u_3\nA : Type u_4\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : NumberField K\ninst\u271d\u00b2 : Field A\ninst\u271d\u00b9 : Algebra \u211a A\ninst\u271d : IsAlgClosed A\nx : K\na : A\n\u22a2 (a \u2208 range fun \u03c6 => \u03c6 x) \u2194 a \u2208 range fun \u03c8 => \u03c8 x\n---\ncase convert_2\nK : Type u_3\nA : Type u_4\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : NumberField K\ninst\u271d\u00b2 : Field A\ninst\u271d\u00b9 : Algebra \u211a A\ninst\u271d : IsAlgClosed A\nx : K\n\u22a2 NumberField K\n---\ncase convert_5\nK : Type u_3\nA : Type u_4\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : NumberField K\ninst\u271d\u00b2 : Field A\ninst\u271d\u00b9 : Algebra \u211a A\ninst\u271d : IsAlgClosed A\nx : K\n\u22a2 IsAlgClosed A"}, {"line": "exact \u27e8fun \u27e8\u03c6, h\u03c6\u27e9 => \u27e8\u03c6.toRatAlgHom, h\u03c6\u27e9, fun \u27e8\u03c6, h\u03c6\u27e9 => \u27e8\u03c6.toRingHom, h\u03c6\u27e9\u27e9", "tactic_state": "case convert_2\nK : Type u_3\nA : Type u_4\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : NumberField K\ninst\u271d\u00b2 : Field A\ninst\u271d\u00b9 : Algebra \u211a A\ninst\u271d : IsAlgClosed A\nx : K\n\u22a2 NumberField K\n---\ncase convert_5\nK : Type u_3\nA : Type u_4\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : NumberField K\ninst\u271d\u00b2 : Field A\ninst\u271d\u00b9 : Algebra \u211a A\ninst\u271d : IsAlgClosed A\nx : K\n\u22a2 IsAlgClosed A"}]}
{"declaration": "lemma even_nat_card_aut_of_not_isUnramified [IsGalois k K] (hw : \u00ac IsUnramified k w) :\n    Even (Nat.card <| K \u2243\u2090[k] K) := by\n  by_cases H : Finite (K \u2243\u2090[k] K)\n  \u00b7 cases nonempty_fintype (K \u2243\u2090[k] K)\n    rw [even_iff_two_dvd]\n    rw [\u2190 not_isUnramified_iff_card_stabilizer_eq_two.mp hw]\n    exact Subgroup.card_subgroup_dvd_card (Stab w)\n  \u00b7 convert Even.zero\n    by_contra e\n    exact H (Nat.finite_of_card_ne_zero e)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/Embeddings.lean", "context": {"open": ["scoped Finset", "Module", "Set Polynomial", "Module Polynomial Set", "Complex NumberField", "scoped ComplexConjugate", "NumberField", "NumberField", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped IntermediateField in", "Fintype Module", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(K : Type*) [Field K] [NumberField K]", "(A : Type*) [Field A] [CharZero A]", "[IsAlgClosed A]", "(K A : Type*) [Field K] [NumberField K] [Field A] [Algebra \u211a A] [IsAlgClosed A] (x : K)", "{K : Type*} [Field K] [NumberField K]", "{A : Type*} [NormedField A] [IsAlgClosed A] [NormedAlgebra \u211a A]", "(K A)", "{K : Type*} [Field K] {A : Type*} [NormedDivisionRing A] [Nontrivial A] (\u03c6 : K \u2192+* A)", "{K : Type*} [Field K] {k : Type*} [Field k]", "(K) in", "[Algebra k K] (\u03c6 : K \u2192+* \u2102) (\u03c3 : K \u2243\u2090[k] K)", "{\u03c6 \u03c3}", "{k : Type*} [Field k] (K : Type*) [Field K] {F : Type*} [Field F]", "{K}", "(K) in", "[NumberField K]", "(K)", "[NumberField K]", "{K}", "{K}", "[Algebra k K] (\u03c3 : K \u2243\u2090[k] K) (w : InfinitePlace K)", "(k K)", "{k K}", "{\u03c3 w}", "(k w)", "{k}", "{w}", "[Algebra k F]", "(K)", "[Algebra K F] [IsScalarTower k K F]", "{K}", "(k)", "{k}", "(k w)", "{k w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_10\ninst\u271d\u2074 : Field k\nK : Type u_11\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : NumberField K\ninst\u271d\u00b9 : Algebra k K\nx\u271d : Sort u_13\nIsUnramified : x\u271d\ninst\u271d : IsGalois k K\nhw : \u00acsorry\n\u22a2 Even (Nat.card (K \u2243\u2090[k] K))"}, {"line": "by_cases H : Finite (K \u2243\u2090[k] K)", "tactic_state": "case pos\nk : Type u_10\ninst\u271d\u2074 : Field k\nK : Type u_11\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : NumberField K\ninst\u271d\u00b9 : Algebra k K\nx\u271d : Sort u_13\nIsUnramified : x\u271d\ninst\u271d : IsGalois k K\nhw : \u00acsorry\nH : Finite sorry\n\u22a2 Even (Nat.card (K \u2243\u2090[k] K))\n---\ncase neg\nk : Type u_10\ninst\u271d\u2074 : Field k\nK : Type u_11\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : NumberField K\ninst\u271d\u00b9 : Algebra k K\nx\u271d : Sort u_13\nIsUnramified : x\u271d\ninst\u271d : IsGalois k K\nhw : \u00acsorry\nH : \u00acFinite sorry\n\u22a2 Even (Nat.card (K \u2243\u2090[k] K))"}, {"line": "\u00b7 cases nonempty_fintype (K \u2243\u2090[k] K)\n    rw [even_iff_two_dvd]\n    rw [\u2190 not_isUnramified_iff_card_stabilizer_eq_two.mp hw]\n    exact Subgroup.card_subgroup_dvd_card (Stab w)", "tactic_state": "case neg\nk : Type u_10\ninst\u271d\u2074 : Field k\nK : Type u_11\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : NumberField K\ninst\u271d\u00b9 : Algebra k K\nx\u271d : Sort u_13\nIsUnramified : x\u271d\ninst\u271d : IsGalois k K\nhw : \u00acsorry\nH : \u00acFinite sorry\n\u22a2 Even (Nat.card (K \u2243\u2090[k] K))"}, {"line": "\u00b7 convert Even.zero\n    by_contra e\n    exact H (Nat.finite_of_card_ne_zero e)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma even_finrank_of_not_isUnramified [IsGalois k K]\n    (hw : \u00ac IsUnramified k w) : Even (finrank k K) := by\n  by_cases FiniteDimensional k K\n  \u00b7 exact IsGalois.card_aut_eq_finrank k K \u25b8 even_card_aut_of_not_isUnramified hw\n  \u00b7 exact finrank_of_not_finite \u2039_\u203a \u25b8 Even.zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/Embeddings.lean", "context": {"open": ["scoped Finset", "Module", "Set Polynomial", "Module Polynomial Set", "Complex NumberField", "scoped ComplexConjugate", "NumberField", "NumberField", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped IntermediateField in", "Fintype Module", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(K : Type*) [Field K] [NumberField K]", "(A : Type*) [Field A] [CharZero A]", "[IsAlgClosed A]", "(K A : Type*) [Field K] [NumberField K] [Field A] [Algebra \u211a A] [IsAlgClosed A] (x : K)", "{K : Type*} [Field K] [NumberField K]", "{A : Type*} [NormedField A] [IsAlgClosed A] [NormedAlgebra \u211a A]", "(K A)", "{K : Type*} [Field K] {A : Type*} [NormedDivisionRing A] [Nontrivial A] (\u03c6 : K \u2192+* A)", "{K : Type*} [Field K] {k : Type*} [Field k]", "(K) in", "[Algebra k K] (\u03c6 : K \u2192+* \u2102) (\u03c3 : K \u2243\u2090[k] K)", "{\u03c6 \u03c3}", "{k : Type*} [Field k] (K : Type*) [Field K] {F : Type*} [Field F]", "{K}", "(K) in", "[NumberField K]", "(K)", "[NumberField K]", "{K}", "{K}", "[Algebra k K] (\u03c3 : K \u2243\u2090[k] K) (w : InfinitePlace K)", "(k K)", "{k K}", "{\u03c3 w}", "(k w)", "{k}", "{w}", "[Algebra k F]", "(K)", "[Algebra K F] [IsScalarTower k K F]", "{K}", "(k)", "{k}", "(k w)", "{k w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_10\ninst\u271d\u2074 : Field k\nK : Type u_11\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : NumberField K\ninst\u271d\u00b9 : Algebra k K\nx\u271d : Sort u_13\nIsUnramified : x\u271d\ninst\u271d : IsGalois k K\nhw : \u00acsorry\n\u22a2 Even (finrank k K)"}, {"line": "by_cases FiniteDimensional k K", "tactic_state": "case pos\nk : Type u_10\ninst\u271d\u2074 : Field k\nK : Type u_11\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : NumberField K\ninst\u271d\u00b9 : Algebra k K\nx\u271d : Sort u_13\nIsUnramified : x\u271d\ninst\u271d : IsGalois k K\nhw : \u00acsorry\nh\u271d : sorry\n\u22a2 Even (finrank k K)\n---\ncase neg\nk : Type u_10\ninst\u271d\u2074 : Field k\nK : Type u_11\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : NumberField K\ninst\u271d\u00b9 : Algebra k K\nx\u271d : Sort u_13\nIsUnramified : x\u271d\ninst\u271d : IsGalois k K\nhw : \u00acsorry\nh\u271d : \u00acsorry\n\u22a2 Even (finrank k K)"}, {"line": "\u00b7 exact IsGalois.card_aut_eq_finrank k K \u25b8 even_card_aut_of_not_isUnramified hw", "tactic_state": "case neg\nk : Type u_10\ninst\u271d\u2074 : Field k\nK : Type u_11\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : NumberField K\ninst\u271d\u00b9 : Algebra k K\nx\u271d : Sort u_13\nIsUnramified : x\u271d\ninst\u271d : IsGalois k K\nhw : \u00acsorry\nh\u271d : \u00acsorry\n\u22a2 Even (finrank k K)"}, {"line": "\u00b7 exact finrank_of_not_finite \u2039_\u203a \u25b8 Even.zero", "tactic_state": "No Goals!"}]}
{"declaration": "lemma infinitePlace_apply (v : InfinitePlace \u211a) (x : \u211a) : v x = |x| := by\n  rw [NumberField.InfinitePlace.coe_apply]\n  obtain \u27e8_, _, rfl\u27e9 := v\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/Embeddings.lean", "context": {"open": ["scoped Finset", "Module", "Set Polynomial", "Module Polynomial Set", "Complex NumberField", "scoped ComplexConjugate", "NumberField", "NumberField", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped IntermediateField in", "Fintype Module", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "Finset in", "scoped Classical in", "Finset in", "scoped Classical in", "scoped Classical in", "Module in", "NumberField"], "variables": ["(K : Type*) [Field K] [NumberField K]", "(A : Type*) [Field A] [CharZero A]", "[IsAlgClosed A]", "(K A : Type*) [Field K] [NumberField K] [Field A] [Algebra \u211a A] [IsAlgClosed A] (x : K)", "{K : Type*} [Field K] [NumberField K]", "{A : Type*} [NormedField A] [IsAlgClosed A] [NormedAlgebra \u211a A]", "(K A)", "{K : Type*} [Field K] {A : Type*} [NormedDivisionRing A] [Nontrivial A] (\u03c6 : K \u2192+* A)", "{K : Type*} [Field K] {k : Type*} [Field k]", "(K) in", "[Algebra k K] (\u03c6 : K \u2192+* \u2102) (\u03c3 : K \u2243\u2090[k] K)", "{\u03c6 \u03c3}", "{k : Type*} [Field k] (K : Type*) [Field K] {F : Type*} [Field F]", "{K}", "(K) in", "[NumberField K]", "(K)", "[NumberField K]", "{K}", "{K}", "[Algebra k K] (\u03c3 : K \u2243\u2090[k] K) (w : InfinitePlace K)", "(k K)", "{k K}", "{\u03c3 w}", "(k w)", "{k}", "{w}", "[Algebra k F]", "(K)", "[Algebra K F] [IsScalarTower k K F]", "{K}", "(k)", "{k}", "(k w)", "{k w}", "(K) in", "(k K)", "[NumberField K]", "(k K F)", "[Algebra k K] [Algebra k F] [Algebra K F] [IsScalarTower k K F]", "{K}", "{k} (K)", "{K}", "(k K)", "{K : Type*} [Field K] [NumberField K] {\u03b6 : K} {k : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "v : InfinitePlace \u211a\nx : \u211a\n\u22a2 v x = \u2191|x|"}, {"line": "rw [NumberField.InfinitePlace.coe_apply]", "tactic_state": "v : InfinitePlace \u211a\nx : \u211a\n\u22a2 \u2191v x = \u2191|x|"}, {"line": "obtain \u27e8_, _, rfl\u27e9 := v", "tactic_state": "case mk.intro\nx : \u211a\nw\u271d : \u211a \u2192+* \u2102\n\u22a2 \u2191\u27e8place w\u271d, \u22ef\u27e9 x = \u2191|x|"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nrComplexPlaces_eq_zero_iff :\n    nrComplexPlaces K = 0 \u2194 IsTotallyReal K := by\n  simp [Fintype.card_eq_zero_iff, isEmpty_subtype, isTotallyReal_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/Embeddings.lean", "context": {"open": ["scoped Finset", "Module", "Set Polynomial", "Module Polynomial Set", "Complex NumberField", "scoped ComplexConjugate", "NumberField", "NumberField", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped IntermediateField in", "Fintype Module", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "Finset in", "scoped Classical in", "Finset in", "scoped Classical in", "scoped Classical in", "Module in", "NumberField", "InfinitePlace Module"], "variables": ["(K : Type*) [Field K] [NumberField K]", "(A : Type*) [Field A] [CharZero A]", "[IsAlgClosed A]", "(K A : Type*) [Field K] [NumberField K] [Field A] [Algebra \u211a A] [IsAlgClosed A] (x : K)", "{K : Type*} [Field K] [NumberField K]", "{A : Type*} [NormedField A] [IsAlgClosed A] [NormedAlgebra \u211a A]", "(K A)", "{K : Type*} [Field K] {A : Type*} [NormedDivisionRing A] [Nontrivial A] (\u03c6 : K \u2192+* A)", "{K : Type*} [Field K] {k : Type*} [Field k]", "(K) in", "[Algebra k K] (\u03c6 : K \u2192+* \u2102) (\u03c3 : K \u2243\u2090[k] K)", "{\u03c6 \u03c3}", "{k : Type*} [Field k] (K : Type*) [Field K] {F : Type*} [Field F]", "{K}", "(K) in", "[NumberField K]", "(K)", "[NumberField K]", "{K}", "{K}", "[Algebra k K] (\u03c3 : K \u2243\u2090[k] K) (w : InfinitePlace K)", "(k K)", "{k K}", "{\u03c3 w}", "(k w)", "{k}", "{w}", "[Algebra k F]", "(K)", "[Algebra K F] [IsScalarTower k K F]", "{K}", "(k)", "{k}", "(k w)", "{k w}", "(K) in", "(k K)", "[NumberField K]", "(k K F)", "[Algebra k K] [Algebra k F] [Algebra K F] [IsScalarTower k K F]", "{K}", "{k} (K)", "{K}", "(k K)", "{K : Type*} [Field K] [NumberField K] {\u03b6 : K} {k : \u2115}", "{K : Type*} [Field K] [NumberField K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_15\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\n\u22a2 nrComplexPlaces K = 0 \u2194 IsTotallyReal K"}, {"line": "simp [Fintype.card_eq_zero_iff, isEmpty_subtype, isTotallyReal_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nrRealPlaces_eq_zero_iff :\n    nrRealPlaces K = 0 \u2194 IsTotallyComplex K := by\n  simp [Fintype.card_eq_zero_iff, isEmpty_subtype, isTotallyComplex_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/Embeddings.lean", "context": {"open": ["scoped Finset", "Module", "Set Polynomial", "Module Polynomial Set", "Complex NumberField", "scoped ComplexConjugate", "NumberField", "NumberField", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped IntermediateField in", "Fintype Module", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "Finset in", "scoped Classical in", "Finset in", "scoped Classical in", "scoped Classical in", "Module in", "NumberField", "InfinitePlace Module", "InfinitePlace"], "variables": ["(K : Type*) [Field K] [NumberField K]", "(A : Type*) [Field A] [CharZero A]", "[IsAlgClosed A]", "(K A : Type*) [Field K] [NumberField K] [Field A] [Algebra \u211a A] [IsAlgClosed A] (x : K)", "{K : Type*} [Field K] [NumberField K]", "{A : Type*} [NormedField A] [IsAlgClosed A] [NormedAlgebra \u211a A]", "(K A)", "{K : Type*} [Field K] {A : Type*} [NormedDivisionRing A] [Nontrivial A] (\u03c6 : K \u2192+* A)", "{K : Type*} [Field K] {k : Type*} [Field k]", "(K) in", "[Algebra k K] (\u03c6 : K \u2192+* \u2102) (\u03c3 : K \u2243\u2090[k] K)", "{\u03c6 \u03c3}", "{k : Type*} [Field k] (K : Type*) [Field K] {F : Type*} [Field F]", "{K}", "(K) in", "[NumberField K]", "(K)", "[NumberField K]", "{K}", "{K}", "[Algebra k K] (\u03c3 : K \u2243\u2090[k] K) (w : InfinitePlace K)", "(k K)", "{k K}", "{\u03c3 w}", "(k w)", "{k}", "{w}", "[Algebra k F]", "(K)", "[Algebra K F] [IsScalarTower k K F]", "{K}", "(k)", "{k}", "(k w)", "{k w}", "(K) in", "(k K)", "[NumberField K]", "(k K F)", "[Algebra k K] [Algebra k F] [Algebra K F] [IsScalarTower k K F]", "{K}", "{k} (K)", "{K}", "(k K)", "{K : Type*} [Field K] [NumberField K] {\u03b6 : K} {k : \u2115}", "{K : Type*} [Field K] [NumberField K]", "(K)", "{K : Type*} [Field K] [NumberField K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_16\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\n\u22a2 nrRealPlaces K = 0 \u2194 IsTotallyComplex K"}, {"line": "simp [Fintype.card_eq_zero_iff, isEmpty_subtype, isTotallyComplex_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem RingOfIntegers.HeightOneSpectrum.adicAbv_intCast_le_one (n : \u2124) : adicAbv v n \u2264 1 := by\n  simp [\u2190 AbsoluteValue.apply_natAbs_eq, adicAbv_natCast_le_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/FinitePlaces.lean", "context": {"open": ["Ideal IsDedekindDomain HeightOneSpectrum WithZeroMulInt", "scoped Multiplicative", "RingOfIntegers.HeightOneSpectrum"], "variables": ["{K : Type*} [Field K] [NumberField K] (v : HeightOneSpectrum (\ud835\udcde K))", "{K : Type*} [Field K] [NumberField K] (v : HeightOneSpectrum (\ud835\udcde K))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udcde : ?m.2765\nK\u271d : Type u_1\ninst\u271d\u00b3 : Field K\u271d\ninst\u271d\u00b2 : NumberField K\u271d\nv\u271d : HeightOneSpectrum sorry\nK : Type u_2\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv : HeightOneSpectrum sorry\nx\u271d : Sort u_3\nadicAbv : x\u271d\nn : \u2124\n\u22a2 sorry \u2264 1"}, {"line": "simp [\u2190 AbsoluteValue.apply_natAbs_eq, adicAbv_natCast_le_one]", "tactic_state": "\ud835\udcde : ?m.2765\nK\u271d : Type u_1\ninst\u271d\u00b3 : Field K\u271d\ninst\u271d\u00b2 : NumberField K\u271d\nv\u271d : HeightOneSpectrum sorry\nK : Type u_2\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv : HeightOneSpectrum sorry\nx\u271d : Sort u_3\nadicAbv : x\u271d\nn : \u2124\n\u22a2 sorry () \u2264 1"}]}
{"declaration": "lemma equivHeightOneSpectrum_symm_apply (v : HeightOneSpectrum (\ud835\udcde K)) (x : K) :\n    (equivHeightOneSpectrum.symm v) x = \u2016embedding v x\u2016 := by\n  have : v = (equivHeightOneSpectrum.symm v).maximalIdeal := by\n    show v = equivHeightOneSpectrum (equivHeightOneSpectrum.symm v)\n    exact (Equiv.apply_symm_apply _ v).symm\n  convert (norm_embedding_eq (equivHeightOneSpectrum.symm v) x).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/FinitePlaces.lean", "context": {"open": ["Ideal IsDedekindDomain HeightOneSpectrum WithZeroMulInt", "scoped Multiplicative", "RingOfIntegers.HeightOneSpectrum", "FinitePlace", "NumberField.FinitePlace NumberField.RingOfIntegers", "scoped NumberField"], "variables": ["{K : Type*} [Field K] [NumberField K] (v : HeightOneSpectrum (\ud835\udcde K))", "{K : Type*} [Field K] [NumberField K] (v : HeightOneSpectrum (\ud835\udcde K))", "{K : Type*} [Field K] [NumberField K]", "{K : Type*} [Field K] [NumberField K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv : HeightOneSpectrum (NumberField.RingOfIntegers K)\nx : K\n\u22a2 (equivHeightOneSpectrum.symm v) x = \u2016(embedding v) x\u2016"}, {"line": "have : v = (equivHeightOneSpectrum.symm v).maximalIdeal := by\n    show v = equivHeightOneSpectrum (equivHeightOneSpectrum.symm v)\n    exact (Equiv.apply_symm_apply _ v).symm", "tactic_state": "K : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv : HeightOneSpectrum (NumberField.RingOfIntegers K)\nx : K\nthis : v = sorry\n\u22a2 (equivHeightOneSpectrum.symm v) x = \u2016(embedding v) x\u2016"}, {"line": "convert (norm_embedding_eq (equivHeightOneSpectrum.symm v) x).symm", "tactic_state": "case h.e'_3.h.e'_1.h.e'_8\nK : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv : HeightOneSpectrum (NumberField.RingOfIntegers K)\nx : K\nthis : v = sorry\n\u22a2 v = (equivHeightOneSpectrum.symm v).maximalIdeal\n---\ncase h.e'_3.h.e'_2.e'_2.e'_4\nK : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv : HeightOneSpectrum (NumberField.RingOfIntegers K)\nx : K\nthis : v = sorry\ne_1\u271d : adicCompletion K v = adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal\n\u22a2 v = (equivHeightOneSpectrum.symm v).maximalIdeal\n---\ncase h.e'_3.h.e'_3.e'_1.h.e'_1.h.e'_5.h.e'_8\nK : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv : HeightOneSpectrum (NumberField.RingOfIntegers K)\nx : K\nthis : v = sorry\ne_1\u271d : adicCompletion K v = adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal\n\u22a2 v = (equivHeightOneSpectrum.symm v).maximalIdeal\n---\ncase h.e'_3.h.e'_3.e'_1.h.e'_4.e'_2.e'_2.e'_2.e'_2.e'_1.h.e'_5.h.e'_8\nK : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv : HeightOneSpectrum (NumberField.RingOfIntegers K)\nx : K\nthis : v = sorry\ne_1\u271d : adicCompletion K v = adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal\n\u22a2 v = (equivHeightOneSpectrum.symm v).maximalIdeal\n---\ncase h.e'_3.h.e'_3.e'_1.h.e'_4.e'_2.e'_2.e'_2.e'_2.e'_2.h.h.e'_5.h.e'_8\nK : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv : HeightOneSpectrum (NumberField.RingOfIntegers K)\nx : K\nthis : v = sorry\ne_1\u271d\u00b9 : adicCompletion K v = adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal\ne_1\u271d : WithVal (valuation K v) = WithVal (valuation K (equivHeightOneSpectrum.symm v).maximalIdeal)\n\u22a2 v = (equivHeightOneSpectrum.symm v).maximalIdeal\n---\ncase h.e'_3.h.e'_3.e'_1.h.e'_4.e'_2.e'_2.e'_2.e'_2.e'_3.h.h.e'_2.h.h.e'_5.h.e'_8\nK : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv : HeightOneSpectrum (NumberField.RingOfIntegers K)\nx : K\nthis : v = sorry\ne_1\u271d\u00b9 : adicCompletion K v = adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal\ne_1\u271d : WithVal (valuation K v) = WithVal (valuation K (equivHeightOneSpectrum.symm v).maximalIdeal)\n\u22a2 v = (equivHeightOneSpectrum.symm v).maximalIdeal\n---\ncase h.e'_3.h.e'_3.e'_1.h.e'_4.e'_2.e'_2.e'_2.e'_2.e'_3.h.h.e'_5.h.h.h.e'_5.h.e'_8\nK : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv : HeightOneSpectrum (NumberField.RingOfIntegers K)\nx : K\nthis : v = sorry\ne_1\u271d\u00b9 : adicCompletion K v = adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal\ne_1\u271d : WithVal (valuation K v) = WithVal (valuation K (equivHeightOneSpectrum.symm v).maximalIdeal)\nhe\u271d : WithVal.instRing (valuation K v) = WithVal.instRing (valuation K (equivHeightOneSpectrum.symm v).maximalIdeal)\n\u22a2 v = (equivHeightOneSpectrum.symm v).maximalIdeal\n---\ncase h.e'_3.h.e'_3.e'_2.h.e'_5.h.e'_8\nK : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv : HeightOneSpectrum (NumberField.RingOfIntegers K)\nx : K\nthis : v = sorry\ne_1\u271d : adicCompletion K v = adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal\n\u22a2 v = (equivHeightOneSpectrum.symm v).maximalIdeal\n---\ncase h.e'_3.h.e'_3.e'_4.h.e'_4.e'_2.e'_2.e'_2.e'_2.e'_2.h.h.e'_5.h.e'_8\nK : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv : HeightOneSpectrum (NumberField.RingOfIntegers K)\nx : K\nthis : v = sorry\ne_1\u271d\u00b2 : adicCompletion K v = adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal\ne_1\u271d\u00b9 :\n  (WithVal (valuation K v) \u2192+* adicCompletion K v) =\n    (WithVal (valuation K (equivHeightOneSpectrum.symm v).maximalIdeal) \u2192+*\n      adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal)\ne_2\u271d : WithVal (valuation K v) = WithVal (valuation K (equivHeightOneSpectrum.symm v).maximalIdeal)\nhe\u271d : (fun x => adicCompletion K v) = fun x => adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal\ne_1\u271d : WithVal (valuation K v) = WithVal (valuation K (equivHeightOneSpectrum.symm v).maximalIdeal)\n\u22a2 v = (equivHeightOneSpectrum.symm v).maximalIdeal\n---\ncase h.e'_3.h.e'_3.e'_4.h.e'_4.e'_2.e'_2.e'_2.e'_2.e'_3.h.h.e'_2.h.h.e'_5.h.e'_8\nK : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv : HeightOneSpectrum (NumberField.RingOfIntegers K)\nx : K\nthis : v = sorry\ne_1\u271d\u00b2 : adicCompletion K v = adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal\ne_1\u271d\u00b9 :\n  (WithVal (valuation K v) \u2192+* adicCompletion K v) =\n    (WithVal (valuation K (equivHeightOneSpectrum.symm v).maximalIdeal) \u2192+*\n      adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal)\ne_2\u271d : WithVal (valuation K v) = WithVal (valuation K (equivHeightOneSpectrum.symm v).maximalIdeal)\nhe\u271d : (fun x => adicCompletion K v) = fun x => adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal\ne_1\u271d : WithVal (valuation K v) = WithVal (valuation K (equivHeightOneSpectrum.symm v).maximalIdeal)\n\u22a2 v = (equivHeightOneSpectrum.symm v).maximalIdeal\n---\ncase h.e'_3.h.e'_3.e'_4.h.e'_4.e'_2.e'_2.e'_2.e'_2.e'_3.h.h.e'_5.h.h.h.e'_5.h.e'_8\nK : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv : HeightOneSpectrum (NumberField.RingOfIntegers K)\nx : K\nthis : v = sorry\ne_1\u271d\u00b2 : adicCompletion K v = adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal\ne_1\u271d\u00b9 :\n  (WithVal (valuation K v) \u2192+* adicCompletion K v) =\n    (WithVal (valuation K (equivHeightOneSpectrum.symm v).maximalIdeal) \u2192+*\n      adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal)\ne_2\u271d : WithVal (valuation K v) = WithVal (valuation K (equivHeightOneSpectrum.symm v).maximalIdeal)\nhe\u271d\u00b9 : (fun x => adicCompletion K v) = fun x => adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal\ne_1\u271d : WithVal (valuation K v) = WithVal (valuation K (equivHeightOneSpectrum.symm v).maximalIdeal)\nhe\u271d : WithVal.instRing (valuation K v) = WithVal.instRing (valuation K (equivHeightOneSpectrum.symm v).maximalIdeal)\n\u22a2 v = (equivHeightOneSpectrum.symm v).maximalIdeal\n---\ncase h.e'_3.h.e'_3.e'_5.e'_4\nK : Type u_4\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv : HeightOneSpectrum (NumberField.RingOfIntegers K)\nx : K\nthis : v = sorry\ne_1\u271d\u00b9 : adicCompletion K v = adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal\ne_1\u271d :\n  (WithVal (valuation K v) \u2192+* adicCompletion K v) =\n    (WithVal (valuation K (equivHeightOneSpectrum.symm v).maximalIdeal) \u2192+*\n      adicCompletion K (equivHeightOneSpectrum.symm v).maximalIdeal)\n\u22a2 v = (equivHeightOneSpectrum.symm v).maximalIdeal"}]}
{"declaration": "theorem latticeBasis_apply [NumberField K] (i : Free.ChooseBasisIndex \u2124 (\ud835\udcde K)) :\n    latticeBasis K i = (canonicalEmbedding K) (integralBasis K i) := by\n  simp [latticeBasis, integralBasis_apply, coe_basisOfPiSpaceOfLinearIndependent,\n    Function.comp_apply, Equiv.apply_symm_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/CanonicalEmbedding/Basic.lean", "context": {"open": ["scoped ComplexConjugate", "Module Fintype Module"], "variables": ["(K : Type*) [Field K]", "{K}", "(K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d\u00b9 : Field K\nx\u271d\u00b2 : Sort u_2\n\ud835\udcde : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_3\nlatticeBasis : x\u271d\u00b9\nx\u271d : Sort u_4\ncanonicalEmbedding : x\u271d\ninst\u271d : NumberField K\ni : Free.ChooseBasisIndex \u2124 sorry\n\u22a2 sorry = sorry"}, {"line": "simp [latticeBasis, integralBasis_apply, coe_basisOfPiSpaceOfLinearIndependent,\n    Function.comp_apply, Equiv.apply_symm_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_idealLattice {x : mixedSpace K} :\n    x \u2208 idealLattice K I \u2194 \u2203 y, y \u2208 (I : Set K) \u2227 mixedEmbedding K y = x := by\n  simp [idealLattice]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/CanonicalEmbedding/Basic.lean", "context": {"open": ["scoped ComplexConjugate", "Module Fintype Module", "NumberField.InfinitePlace Module Finset", "MeasureTheory.Measure MeasureTheory", "Classical in", "Classical in", "Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "Complex MeasureTheory MeasureTheory.Measure ZSpan Matrix ComplexConjugate", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "Module.Free", "scoped nonZeroDivisors", "Classical in", "Classical in"], "variables": ["(K : Type*) [Field K]", "{K}", "(K)", "[NumberField K]", "{K} in", "{K}", "[NumberField K]", "(K) in", "[NumberField K]", "{K}", "(K)", "{K}", "(K)", "[NumberField K]", "(I : (FractionalIdeal (\ud835\udcde K)\u2070 K)\u02e3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_3\nx\u271d\u00b2 : Sort u_1\nmixedSpace : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nidealLattice : x\u271d\u00b9\nI : Set K\nx\u271d : Sort u_4\nmixedEmbedding : x\u271d\nx : sorry\n\u22a2 x \u2208 sorry \u2194 \u2203 y \u2208 I, sorry = x"}, {"line": "simp [idealLattice]", "tactic_state": "K : Type u_3\nx\u271d\u00b2 : Sort u_1\nmixedSpace : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nidealLattice : x\u271d\u00b9\nI : Set K\nx\u271d : Sort u_4\nmixedEmbedding : x\u271d\nx : sorry\n\u22a2 x \u2208 sorry () \u2194 (\u2203 x, x \u2208 I) \u2227 sorry () = x"}]}
{"declaration": "theorem ne_zero_of_mem_integerSet (a : integerSet K) : (a : mixedSpace K) \u2260 0 := by\n  by_contra!\n  exact a.prop.1.2 (this.symm \u25b8 mixedEmbedding.norm.map_zero')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/CanonicalEmbedding/FundamentalCone.lean", "context": {"open": ["NumberField NumberField.InfinitePlace", "NumberField.Units NumberField.Units.dirichletUnitTheorem Module", "Classical in", "NumberField.Units NumberField.Units.dirichletUnitTheorem", "Classical in"], "variables": ["(K : Type*) [Field K]", "{K}", "[NumberField K]", "[NumberField K] {K}", "{x y : mixedSpace K}", "(x) in", "[NumberField K]", "{K} {x y : mixedSpace K} {c : \u211d}", "(K) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "mixedSpace : ?m.3763\nK : ?m.4584\nx : sorry\ny : sorry\nx\u271d : Sort u_1\nintegerSet : x\u271d\na : sorry\n\u22a2 a \u2260 sorry"}, {"line": "by_contra!", "tactic_state": "mixedSpace : ?m.3763\nK : ?m.4584\nx : sorry\ny : sorry\nx\u271d : Sort u_1\nintegerSet : x\u271d\na : sorry\nthis : a = sorry\n\u22a2 False"}, {"line": "exact a.prop.1.2 (this.symm \u25b8 mixedEmbedding.norm.map_zero')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem expMapBasis_source :\n    expMapBasis.source = (Set.univ : Set (realSpace K)) := by\n  simp [expMapBasis, expMap_source]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/CanonicalEmbedding/NormLeOne.lean", "context": {"open": ["Finset NumberField NumberField.InfinitePlace NumberField.mixedEmbedding NumberField.Units", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(K : Type*) [Field K]", "[NumberField K]", "{K}", "[NumberField K]", "{K} in", "{K}", "[NumberField K]", "(K)", "{K}", "[NumberField K]", "{K}", "(K) in", "(K)", "[NumberField K]", "{K}", "(K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = Set.univ"}, {"line": "simp [expMapBasis, expMap_source]", "tactic_state": "\u22a2 sorry () = Set.univ"}]}
{"declaration": "theorem hasFDerivAt_expMapBasis (x : realSpace K) :\n    HasFDerivAt expMapBasis (fderiv_expMapBasis K x) x := by\n  change HasFDerivAt (expMap \u2218 (completeBasis K).equivFunL.symm) (fderiv_expMapBasis K x) x\n  exact (hasFDerivAt_expMap _).comp x (completeBasis K).equivFunL.symm.hasFDerivAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/CanonicalEmbedding/NormLeOne.lean", "context": {"open": ["Finset NumberField NumberField.InfinitePlace NumberField.mixedEmbedding NumberField.Units", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(K : Type*) [Field K]", "[NumberField K]", "{K}", "[NumberField K]", "{K} in", "{K}", "[NumberField K]", "(K)", "{K}", "[NumberField K]", "{K}", "(K) in", "(K)", "[NumberField K]", "{K}", "(K)", "{K}", "(K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Type u_1\nexpMapBasis : sorry \u2192 x\u271d\u00b9\nx\u271d : Sort u_3\nfderiv_expMapBasis : x\u271d\nx : sorry\n\u22a2 sorry"}, {"line": "change HasFDerivAt (expMap \u2218 (completeBasis K).equivFunL.symm) (fderiv_expMapBasis K x) x", "tactic_state": "x\u271d\u00b9 : Type u_1\nexpMapBasis : sorry \u2192 x\u271d\u00b9\nx\u271d : Sort u_3\nfderiv_expMapBasis : x\u271d\nx : sorry\n\u22a2 sorry"}, {"line": "exact (hasFDerivAt_expMap _).comp x (completeBasis K).equivFunL.symm.hasFDerivAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_paramSet :\n    closure (paramSet K) = Set.univ.pi fun w \u21a6 if w = w\u2080 then Set.Iic 0 else Set.Icc 0 1 := by\n  simp [closure_pi_set, apply_ite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/CanonicalEmbedding/NormLeOne.lean", "context": {"open": ["Finset NumberField NumberField.InfinitePlace NumberField.mixedEmbedding NumberField.Units", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "Classical ContinuousLinearMap in", "ENNReal MeasureTheory", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(K : Type*) [Field K]", "[NumberField K]", "{K}", "[NumberField K]", "{K} in", "{K}", "[NumberField K]", "(K)", "{K}", "[NumberField K]", "{K}", "(K) in", "(K)", "[NumberField K]", "{K}", "(K)", "{K}", "(K)", "{K}", "[NumberField K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nparamSet : x\u271d\n\u03b9\u271d : Type u_2\nw\u2080 : \u03b9\u271d\n\u22a2 closure sorry = Set.univ.pi fun w => if w = w\u2080 then Set.Iic 0 else Set.Icc 0 1"}, {"line": "simp [closure_pi_set, apply_ite]", "tactic_state": "x\u271d : Sort u_1\nparamSet : x\u271d\n\u03b9\u271d : Type u_2\nw\u2080 : \u03b9\u271d\n\u22a2 closure (sorry ()) = Set.univ.pi fun w => if w = w\u2080 then Set.Iic 0 else Set.Icc 0 1"}]}
{"declaration": "theorem abs_discr_gt_two (h : 1 < finrank \u211a K) : 2 < |discr K| := by\n  rw [\u2190 Nat.succ_le_iff] at h\n  rify\n  calc\n    (2 : \u211d) < (4 / 9) * (3 * \u03c0 / 4) ^ 2 := by\n      nlinarith [Real.pi_gt_three]\n    _ \u2264 (4 / 9 : \u211d) * (3 * \u03c0 / 4) ^ finrank \u211a K := by\n      gcongr\n      linarith [Real.pi_gt_three]\n    _ \u2264 |(discr K : \u211d)| := mod_cast abs_discr_ge h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/Discriminant/Basic.lean", "context": {"open": ["Module NumberField NumberField.InfinitePlace Matrix", "scoped Real nonZeroDivisors", "MeasureTheory MeasureTheory.Measure ZSpan NumberField.mixedEmbedding", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(K : Type*) [Field K] [NumberField K]", "{K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 1 < sorry\n\u22a2 2 < |sorry|"}, {"line": "rw [\u2190 Nat.succ_le_iff] at h", "tactic_state": "h : Nat.succ 1 \u2264 sorry\n\u22a2 2 < |sorry|"}, {"line": "rify", "tactic_state": "h : Nat.succ 1 \u2264 sorry\n\u22a2 2 < |\u2191sorry|"}, {"line": "calc\n    (2 : \u211d) < (4 / 9) * (3 * \u03c0 / 4) ^ 2 := by\n      nlinarith [Real.pi_gt_three]\n    _ \u2264 (4 / 9 : \u211d) * (3 * \u03c0 / 4) ^ finrank \u211a K := by\n      gcongr\n      linarith [Real.pi_gt_three]\n    _ \u2264 |(discr K : \u211d)| := mod_cast abs_discr_ge h", "tactic_state": "case calc.step\nh : Nat.succ 1 \u2264 sorry\n\u22a2 |sorry| < |\u2191sorry|"}]}
{"declaration": "theorem NumberField.isUnit_iff_norm [NumberField K] {x : \ud835\udcde K} :\n    IsUnit x \u2194 |(RingOfIntegers.norm \u211a x : \u211a)| = 1 := by\n  convert (RingOfIntegers.isUnit_norm \u211a (F := K)).symm\n  rw [\u2190 abs_one]\n  rw [abs_eq_abs]\n  rw [\u2190 Rat.RingOfIntegers.isUnit_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/Units/Basic.lean", "context": {"open": ["scoped NumberField", "NumberField Units"], "variables": ["(K : Type*) [Field K]", "{K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nx : RingOfIntegers K\n\u22a2 IsUnit x \u2194 |\u2191((RingOfIntegers.norm \u211a) x)| = 1"}, {"line": "convert (RingOfIntegers.isUnit_norm \u211a (F := K)).symm", "tactic_state": "case h.e'_2.a\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nx : RingOfIntegers K\n\u22a2 |\u2191((RingOfIntegers.norm \u211a) x)| = 1 \u2194 IsUnit ((RingOfIntegers.norm \u211a) x)\n---\ncase convert_2\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nx : RingOfIntegers K\n\u22a2 Algebra \u211a K\n---\ncase convert_3\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nx : RingOfIntegers K\n\u22a2 Algebra.IsSeparable \u211a K\n---\ncase convert_4\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nx : RingOfIntegers K\n\u22a2 FiniteDimensional \u211a K"}, {"line": "rw [\u2190 abs_one]", "tactic_state": "case h.e'_2.a\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nx : RingOfIntegers K\n\u22a2 |\u2191((RingOfIntegers.norm \u211a) x)| = |1| \u2194 IsUnit ((RingOfIntegers.norm \u211a) x)\n---\ncase convert_2\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nx : RingOfIntegers K\n\u22a2 Algebra \u211a K\n---\ncase convert_3\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nx : RingOfIntegers K\n\u22a2 Algebra.IsSeparable \u211a K\n---\ncase convert_4\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nx : RingOfIntegers K\n\u22a2 FiniteDimensional \u211a K"}, {"line": "rw [abs_eq_abs]", "tactic_state": "case h.e'_2.a\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nx : RingOfIntegers K\n\u22a2 \u2191((RingOfIntegers.norm \u211a) x) = 1 \u2228 \u2191((RingOfIntegers.norm \u211a) x) = -1 \u2194 IsUnit ((RingOfIntegers.norm \u211a) x)\n---\ncase convert_2\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nx : RingOfIntegers K\n\u22a2 Algebra \u211a K\n---\ncase convert_3\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nx : RingOfIntegers K\n\u22a2 Algebra.IsSeparable \u211a K\n---\ncase convert_4\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nx : RingOfIntegers K\n\u22a2 FiniteDimensional \u211a K"}, {"line": "rw [\u2190 Rat.RingOfIntegers.isUnit_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_pow (x : (\ud835\udcde K)\u02e3) (n : \u2115) : ((x ^ n : (\ud835\udcde K)\u02e3) : K) = (x : K) ^ n := by\n  rw [\u2190 map_pow]\n  rw [\u2190 val_pow_eq_pow_val]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/NumberField/Units/Basic.lean", "context": {"open": ["scoped NumberField", "NumberField Units"], "variables": ["(K : Type*) [Field K]", "{K}", "{K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : Field K\nx : (RingOfIntegers K)\u02e3\nn : \u2115\n\u22a2 (algebraMap (RingOfIntegers K) K) \u2191(x ^ n) = (algebraMap (RingOfIntegers K) K) \u2191x ^ n"}, {"line": "rw [\u2190 map_pow]", "tactic_state": "K : Type u_1\ninst\u271d : Field K\nx : (RingOfIntegers K)\u02e3\nn : \u2115\n\u22a2 (algebraMap (RingOfIntegers K) K) \u2191(x ^ n) = (algebraMap (RingOfIntegers K) K) (\u2191x ^ n)\n---\nK : Type u_1\ninst\u271d : Field K\nx : (RingOfIntegers K)\u02e3\nn : \u2115\n\u22a2 MonoidHomClass (RingOfIntegers K \u2192+* K) (RingOfIntegers K) K"}, {"line": "rw [\u2190 val_pow_eq_pow_val]", "tactic_state": "K : Type u_1\ninst\u271d : Field K\nx : (RingOfIntegers K)\u02e3\nn : \u2115\n\u22a2 MonoidHomClass (RingOfIntegers K \u2192+* K) (RingOfIntegers K) K"}]}
{"declaration": "theorem mk_coe (k : \u2124_[p]) : (\u27e8k, k.2\u27e9 : \u2124_[p]) = k := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "context": {"open": ["Padic Metric IsLocalRing"], "variables": ["(p : \u2115) [hp : Fact p.Prime]", "{p} {x y : \u2124_[p]}", "(p)", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nk : \u2124_[p]\n\u22a2 \u27e8\u2191k, \u22ef\u27e9 = k"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intCast_eq (z1 z2 : \u2124) : (z1 : \u2124_[p]) = z2 \u2194 z1 = z2 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "context": {"open": ["Padic Metric IsLocalRing"], "variables": ["(p : \u2115) [hp : Fact p.Prime]", "{p} {x y : \u2124_[p]}", "(p)", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nz1 z2 : \u2124\n\u22a2 \u2191z1 = \u2191z2 \u2194 z1 = z2"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_p_pow (n : \u2115) : \u2016(p : \u2124_[p]) ^ n\u2016 = (p : \u211d) ^ (-n : \u2124) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "context": {"open": ["Padic Metric IsLocalRing"], "variables": ["(p : \u2115) [hp : Fact p.Prime]", "{p} {x y : \u2124_[p]}", "(p)", "{p}", "(p)", "{p} in", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 \u2016\u2191p ^ n\u2016 = \u2191p ^ (-\u2191n)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma norm_eq_zpow_neg_valuation {x : \u2124_[p]} (hx : x \u2260 0) : \u2016x\u2016 = p ^ (-x.valuation : \u2124) := by\n  simp [norm_def, Padic.norm_eq_zpow_neg_valuation <| coe_ne_zero.2 hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "context": {"open": ["Padic Metric IsLocalRing"], "variables": ["(p : \u2115) [hp : Fact p.Prime]", "{p} {x y : \u2124_[p]}", "(p)", "{p}", "(p)", "{p} in", "{p}", "(p)", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nx : \u2124_[p]\nhx : x \u2260 0\n\u22a2 \u2016x\u2016 = \u2191p ^ (-\u2191x.valuation)"}, {"line": "simp [norm_def, Padic.norm_eq_zpow_neg_valuation <| coe_ne_zero.2 hx]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nx : \u2124_[p]\nhx : x \u2260 0\n\u22a2 \u2016x\u2016 = (\u2191p ^ x.valuation)\u207b\u00b9"}]}
{"declaration": "theorem not_isUnit_iff {z : \u2124_[p]} : \u00acIsUnit z \u2194 \u2016z\u2016 < 1 := by\n  simpa using mem_nonunits\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "context": {"open": ["Padic Metric IsLocalRing"], "variables": ["(p : \u2115) [hp : Fact p.Prime]", "{p} {x y : \u2124_[p]}", "(p)", "{p}", "(p)", "{p} in", "{p}", "(p)", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nz : \u2124_[p]\n\u22a2 \u00acIsUnit z \u2194 \u2016z\u2016 < 1"}, {"line": "simpa using mem_nonunits", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem bound'_sq :\n    Tendsto (fun n : \u2115 => \u2016F.derivative.eval a\u2016 ^ 2 * T ^ 2 ^ n) atTop (\ud835\udcdd 0) := by\n  rw [\u2190 mul_zero \u2016F.derivative.eval a\u2016]\n  rw [sq]\n  simp only [mul_assoc]\n  apply Tendsto.mul\n  \u00b7 apply tendsto_const_nhds\n  \u00b7 apply bound'\n    assumption\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/Hensel.lean", "context": {"open": ["Topology", "Filter Metric", "Nat"], "variables": ["{p : \u2115} [Fact p.Prime] {ncs : CauSeq \u2124_[p] norm} {F : Polynomial \u2124_[p]}", "{p : \u2115} [Fact p.Prime] {ncs : CauSeq \u2124_[p] norm} {F : Polynomial \u2124_[p]}", "(p : \u2115) [Fact p.Prime] (F : Polynomial \u2124_[p]) (a : \u2124_[p])", "{p F a}", "(hnorm : \u2016F.eval a\u2016 < \u2016F.derivative.eval a\u2016 ^ 2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nF : Polynomial \u2124_[p]\na : \u2124_[p]\nT : \u211d\n\u22a2 Tendsto (fun n => \u2016Polynomial.eval a (Polynomial.derivative F)\u2016 ^ 2 * T ^ 2 ^ n) atTop (nhds 0)"}, {"line": "rw [\u2190 mul_zero \u2016F.derivative.eval a\u2016]", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nF : Polynomial \u2124_[p]\na : \u2124_[p]\nT : \u211d\n\u22a2 Tendsto (fun n => \u2016Polynomial.eval a (Polynomial.derivative F)\u2016 ^ 2 * T ^ 2 ^ n) atTop\n    (nhds (\u2016Polynomial.eval a (Polynomial.derivative F)\u2016 * 0))"}, {"line": "rw [sq]", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nF : Polynomial \u2124_[p]\na : \u2124_[p]\nT : \u211d\n\u22a2 Tendsto\n    (fun n => \u2016Polynomial.eval a (Polynomial.derivative F)\u2016 * \u2016Polynomial.eval a (Polynomial.derivative F)\u2016 * T ^ 2 ^ n)\n    atTop (nhds (\u2016Polynomial.eval a (Polynomial.derivative F)\u2016 * 0))"}, {"line": "simp only [mul_assoc]", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nF : Polynomial \u2124_[p]\na : \u2124_[p]\nT : \u211d\n\u22a2 Tendsto\n    (fun n =>\n      \u2016Polynomial.eval a (Polynomial.derivative F)\u2016 * (\u2016Polynomial.eval a (Polynomial.derivative F)\u2016 * T ^ 2 ^ n))\n    atTop (nhds (\u2016Polynomial.eval a (Polynomial.derivative F)\u2016 * 0))"}, {"line": "apply Tendsto.mul", "tactic_state": "case hf\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nF : Polynomial \u2124_[p]\na : \u2124_[p]\nT : \u211d\n\u22a2 Tendsto (fun x => \u2016Polynomial.eval a (Polynomial.derivative F)\u2016) atTop\n    (nhds \u2016Polynomial.eval a (Polynomial.derivative F)\u2016)\n---\ncase hg\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nF : Polynomial \u2124_[p]\na : \u2124_[p]\nT : \u211d\n\u22a2 Tendsto (fun x => \u2016Polynomial.eval a (Polynomial.derivative F)\u2016 * T ^ 2 ^ x) atTop (nhds 0)"}, {"line": "\u00b7 apply tendsto_const_nhds", "tactic_state": "case hg\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nF : Polynomial \u2124_[p]\na : \u2124_[p]\nT : \u211d\n\u22a2 Tendsto (fun x => \u2016Polynomial.eval a (Polynomial.derivative F)\u2016 * T ^ 2 ^ x) atTop (nhds 0)"}, {"line": "\u00b7 apply bound'\n    assumption", "tactic_state": "No Goals!"}]}
{"declaration": "lemma continuous_multichoose (k : \u2115) : Continuous (fun x : \u2124_[p] \u21a6 Ring.multichoose x k) := by\n  simp only [Ring.multichoose]\n  simp only [BinomialRing.multichoose]\n  simp only [continuous_induced_rng]\n  fun_prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/MahlerBasis.lean", "context": {"open": ["Finset IsUltrametricDist NNReal Filter", "scoped fwdDiff ZeroAtInfty Topology"], "variables": ["{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nk : \u2115\n\u22a2 Continuous fun x => Ring.multichoose x k"}, {"line": "simp only [Ring.multichoose]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nk : \u2115\n\u22a2 Continuous fun x => BinomialRing.multichoose x k"}, {"line": "simp only [BinomialRing.multichoose]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nk : \u2115\n\u22a2 Continuous fun x => \u27e8\u2191(Polynomial.eval x (ascPochhammer \u2124_[p] k)) / \u2191k.factorial, \u22ef\u27e9"}, {"line": "simp only [continuous_induced_rng]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nk : \u2115\n\u22a2 Continuous (Subtype.val \u2218 fun x => \u27e8\u2191(Polynomial.eval x (ascPochhammer \u2124_[p] k)) / \u2191k.factorial, \u22ef\u27e9)"}, {"line": "fun_prop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma continuous_choose (k : \u2115) : Continuous (fun x : \u2124_[p] \u21a6 Ring.choose x k) := by\n  simp only [Ring.choose]\n  fun_prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/MahlerBasis.lean", "context": {"open": ["Finset IsUltrametricDist NNReal Filter", "scoped fwdDiff ZeroAtInfty Topology"], "variables": ["{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nk : \u2115\n\u22a2 Continuous fun x => Ring.choose x k"}, {"line": "simp only [Ring.choose]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nk : \u2115\n\u22a2 Continuous fun x => Ring.multichoose (x - \u2191k + 1) k"}, {"line": "fun_prop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem padicNorm_of_prime_of_ne {q : \u2115} [p_prime : Fact p.Prime] [q_prime : Fact q.Prime]\n    (neq : p \u2260 q) : padicNorm p q = 1 := by\n  have p : padicValRat p q = 0 := mod_cast padicValNat_primes neq\n  rw [padicNorm]\n  rw [p]\n  simp [q_prime.1.ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNorm.lean", "context": {"open": ["padicValRat"], "variables": ["{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u2115\np_prime : Fact (Nat.Prime p)\nq_prime : Fact (Nat.Prime q)\nneq : p \u2260 q\n\u22a2 padicNorm p \u2191q = 1"}, {"line": "have p : padicValRat p q = 0 := mod_cast padicValNat_primes neq", "tactic_state": "p\u271d q : \u2115\np_prime : Fact (Nat.Prime p\u271d)\nq_prime : Fact (Nat.Prime q)\nneq : p\u271d \u2260 q\np : padicValRat p\u271d \u2191q = 0\n\u22a2 padicNorm p\u271d \u2191q = 1"}, {"line": "rw [padicNorm]", "tactic_state": "p\u271d q : \u2115\np_prime : Fact (Nat.Prime p\u271d)\nq_prime : Fact (Nat.Prime q)\nneq : p\u271d \u2260 q\np : padicValRat p\u271d \u2191q = 0\n\u22a2 (if \u2191q = 0 then 0 else \u2191p\u271d ^ (-padicValRat p\u271d \u2191q)) = 1"}, {"line": "rw [p]", "tactic_state": "p\u271d q : \u2115\np_prime : Fact (Nat.Prime p\u271d)\nq_prime : Fact (Nat.Prime q)\nneq : p\u271d \u2260 q\np : padicValRat p\u271d \u2191q = 0\n\u22a2 (if \u2191q = 0 then 0 else \u2191p\u271d ^ (-0)) = 1"}, {"line": "simp [q_prime.1.ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_lt {\u03b1 : Type*} {F : \u03b1 \u2192 \u211a} {t : \u211a} {s : Finset \u03b1} :\n    s.Nonempty \u2192 (\u2200 i \u2208 s, padicNorm p (F i) < t) \u2192 padicNorm p (\u2211 i \u2208 s, F i) < t := by\n  classical\n    refine s.induction_on (by rintro \u27e8-, \u27e8\u27e9\u27e9) ?_\n    rintro a S haS IH - ht\n    by_cases hs : S.Nonempty\n    \u00b7 rw [Finset.sum_insert haS]\n      exact\n        lt_of_le_of_lt padicNorm.nonarchimedean\n          (max_lt (ht a (Finset.mem_insert_self a S))\n            (IH hs fun b hb \u21a6 ht b (Finset.mem_insert_of_mem hb)))\n    \u00b7 simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNorm.lean", "context": {"open": ["padicValRat"], "variables": ["{p : \u2115}", "[hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u03b1 : Type u_1\nF : \u03b1 \u2192 \u211a\nt : \u211a\ns : Finset \u03b1\n\u22a2 s.Nonempty \u2192 (\u2200 i \u2208 s, padicNorm p (F i) < t) \u2192 padicNorm p (\u2211 i \u2208 s, F i) < t"}, {"line": "classical\n    refine s.induction_on (by rintro \u27e8-, \u27e8\u27e9\u27e9) ?_\n    rintro a S haS IH - ht\n    by_cases hs : S.Nonempty\n    \u00b7 rw [Finset.sum_insert haS]\n      exact\n        lt_of_le_of_lt padicNorm.nonarchimedean\n          (max_lt (ht a (Finset.mem_insert_self a S))\n            (IH hs fun b hb \u21a6 ht b (Finset.mem_insert_of_mem hb)))\n    \u00b7 simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_le {\u03b1 : Type*} {F : \u03b1 \u2192 \u211a} {t : \u211a} {s : Finset \u03b1} :\n    s.Nonempty \u2192 (\u2200 i \u2208 s, padicNorm p (F i) \u2264 t) \u2192 padicNorm p (\u2211 i \u2208 s, F i) \u2264 t := by\n  classical\n    refine s.induction_on (by rintro \u27e8-, \u27e8\u27e9\u27e9) ?_\n    rintro a S haS IH - ht\n    by_cases hs : S.Nonempty\n    \u00b7 rw [Finset.sum_insert haS]\n      exact\n        padicNorm.nonarchimedean.trans\n          (max_le (ht a (Finset.mem_insert_self a S))\n            (IH hs fun b hb \u21a6 ht b (Finset.mem_insert_of_mem hb)))\n    \u00b7 simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNorm.lean", "context": {"open": ["padicValRat"], "variables": ["{p : \u2115}", "[hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u03b1 : Type u_1\nF : \u03b1 \u2192 \u211a\nt : \u211a\ns : Finset \u03b1\n\u22a2 s.Nonempty \u2192 (\u2200 i \u2208 s, padicNorm p (F i) \u2264 t) \u2192 padicNorm p (\u2211 i \u2208 s, F i) \u2264 t"}, {"line": "classical\n    refine s.induction_on (by rintro \u27e8-, \u27e8\u27e9\u27e9) ?_\n    rintro a S haS IH - ht\n    by_cases hs : S.Nonempty\n    \u00b7 rw [Finset.sum_insert haS]\n      exact\n        padicNorm.nonarchimedean.trans\n          (max_le (ht a (Finset.mem_insert_self a S))\n            (IH hs fun b hb \u21a6 ht b (Finset.mem_insert_of_mem hb)))\n    \u00b7 simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_lt' {\u03b1 : Type*} {F : \u03b1 \u2192 \u211a} {t : \u211a} {s : Finset \u03b1}\n    (hF : \u2200 i \u2208 s, padicNorm p (F i) < t) (ht : 0 < t) : padicNorm p (\u2211 i \u2208 s, F i) < t := by\n  obtain rfl | hs := Finset.eq_empty_or_nonempty s\n  \u00b7 simp [ht]\n  \u00b7 exact sum_lt hs hF\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNorm.lean", "context": {"open": ["padicValRat"], "variables": ["{p : \u2115}", "[hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u03b1 : Type u_1\nF : \u03b1 \u2192 \u211a\nt : \u211a\ns : Finset \u03b1\nhF : \u2200 i \u2208 s, padicNorm p (F i) < t\nht : 0 < t\n\u22a2 padicNorm p (\u2211 i \u2208 s, F i) < t"}, {"line": "obtain rfl | hs := Finset.eq_empty_or_nonempty s", "tactic_state": "case inl\np : \u2115\nhp : Fact (Nat.Prime p)\n\u03b1 : Type u_1\nF : \u03b1 \u2192 \u211a\nt : \u211a\nht : 0 < t\nhF : \u2200 i \u2208 \u2205, padicNorm p (F i) < t\n\u22a2 padicNorm p (\u2211 i \u2208 \u2205, F i) < t\n---\ncase inr\np : \u2115\nhp : Fact (Nat.Prime p)\n\u03b1 : Type u_1\nF : \u03b1 \u2192 \u211a\nt : \u211a\ns : Finset \u03b1\nhF : \u2200 i \u2208 s, padicNorm p (F i) < t\nht : 0 < t\nhs : s.Nonempty\n\u22a2 padicNorm p (\u2211 i \u2208 s, F i) < t"}, {"line": "\u00b7 simp [ht]", "tactic_state": "case inr\np : \u2115\nhp : Fact (Nat.Prime p)\n\u03b1 : Type u_1\nF : \u03b1 \u2192 \u211a\nt : \u211a\ns : Finset \u03b1\nhF : \u2200 i \u2208 s, padicNorm p (F i) < t\nht : 0 < t\nhs : s.Nonempty\n\u22a2 padicNorm p (\u2211 i \u2208 s, F i) < t"}, {"line": "\u00b7 exact sum_lt hs hF", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_le' {\u03b1 : Type*} {F : \u03b1 \u2192 \u211a} {t : \u211a} {s : Finset \u03b1}\n    (hF : \u2200 i \u2208 s, padicNorm p (F i) \u2264 t) (ht : 0 \u2264 t) : padicNorm p (\u2211 i \u2208 s, F i) \u2264 t := by\n  obtain rfl | hs := Finset.eq_empty_or_nonempty s\n  \u00b7 simp [ht]\n  \u00b7 exact sum_le hs hF\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNorm.lean", "context": {"open": ["padicValRat"], "variables": ["{p : \u2115}", "[hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u03b1 : Type u_1\nF : \u03b1 \u2192 \u211a\nt : \u211a\ns : Finset \u03b1\nhF : \u2200 i \u2208 s, padicNorm p (F i) \u2264 t\nht : 0 \u2264 t\n\u22a2 padicNorm p (\u2211 i \u2208 s, F i) \u2264 t"}, {"line": "obtain rfl | hs := Finset.eq_empty_or_nonempty s", "tactic_state": "case inl\np : \u2115\nhp : Fact (Nat.Prime p)\n\u03b1 : Type u_1\nF : \u03b1 \u2192 \u211a\nt : \u211a\nht : 0 \u2264 t\nhF : \u2200 i \u2208 \u2205, padicNorm p (F i) \u2264 t\n\u22a2 padicNorm p (\u2211 i \u2208 \u2205, F i) \u2264 t\n---\ncase inr\np : \u2115\nhp : Fact (Nat.Prime p)\n\u03b1 : Type u_1\nF : \u03b1 \u2192 \u211a\nt : \u211a\ns : Finset \u03b1\nhF : \u2200 i \u2208 s, padicNorm p (F i) \u2264 t\nht : 0 \u2264 t\nhs : s.Nonempty\n\u22a2 padicNorm p (\u2211 i \u2208 s, F i) \u2264 t"}, {"line": "\u00b7 simp [ht]", "tactic_state": "case inr\np : \u2115\nhp : Fact (Nat.Prime p)\n\u03b1 : Type u_1\nF : \u03b1 \u2192 \u211a\nt : \u211a\ns : Finset \u03b1\nhF : \u2200 i \u2208 s, padicNorm p (F i) \u2264 t\nht : 0 \u2264 t\nhs : s.Nonempty\n\u22a2 padicNorm p (\u2211 i \u2208 s, F i) \u2264 t"}, {"line": "\u00b7 exact sum_le hs hF", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_const (q : \u211a) : norm (const (padicNorm p) q) = padicNorm p q := by\n  obtain rfl | hq := eq_or_ne q 0\n  \u00b7 simp [norm]\n  \u00b7 simp [norm, not_equiv_zero_const_of_nonzero hq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNumbers.lean", "context": {"open": ["Nat padicNorm CauSeq CauSeq.Completion Metric", "Classical in", "CauSeq", "CauSeq", "Classical in", "PadicSeq", "CauSeq"], "variables": ["{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nq : \u211a\n\u22a2 sorry = padicNorm p q"}, {"line": "obtain rfl | hq := eq_or_ne q 0", "tactic_state": "case inl\np : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 sorry = padicNorm p 0\n---\ncase inr\np : \u2115\nhp : Fact (Nat.Prime p)\nq : \u211a\nhq : q \u2260 0\n\u22a2 sorry = padicNorm p q"}, {"line": "\u00b7 simp [norm]", "tactic_state": "case inr\np : \u2115\nhp : Fact (Nat.Prime p)\nq : \u211a\nhq : q \u2260 0\n\u22a2 sorry = padicNorm p q"}, {"line": "\u00b7 simp [norm, not_equiv_zero_const_of_nonzero hq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_one : norm (1 : PadicSeq p) = 1 := by\n  have h1 : \u00ac(1 : PadicSeq p) \u2248 0 := one_not_equiv_zero _\n  simp [h1, norm, hp.1.one_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNumbers.lean", "context": {"open": ["Nat padicNorm CauSeq CauSeq.Completion Metric", "Classical in", "CauSeq", "CauSeq", "Classical in", "PadicSeq", "CauSeq"], "variables": ["{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = 1"}, {"line": "have h1 : \u00ac(1 : PadicSeq p) \u2248 0 := one_not_equiv_zero _", "tactic_state": "h1 : \u00acsorry\n\u22a2 sorry = 1"}, {"line": "simp [h1, norm, hp.1.one_lt]", "tactic_state": "h1 : \u00acsorry\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem add_eq_max_of_ne {q r : \u211a_[p]} (h : \u2016q\u2016 \u2260 \u2016r\u2016) : \u2016q + r\u2016 = max \u2016q\u2016 \u2016r\u2016 := by\n  dsimp [norm] at h \u22a2\n  have : padicNormE q \u2260 padicNormE r := mod_cast h\n  exact mod_cast add_eq_max_of_ne' this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNumbers.lean", "context": {"open": ["Nat padicNorm CauSeq CauSeq.Completion Metric", "Classical in", "CauSeq", "CauSeq", "Classical in", "PadicSeq", "CauSeq", "PadicSeq", "PadicSeq Padic"], "variables": ["{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "(p)", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime] (f : CauSeq _ (@padicNormE p _))", "(p : \u2115) [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nq r : \u211a_[p]\nh : \u2016q\u2016 \u2260 \u2016r\u2016\n\u22a2 \u2016q + r\u2016 = max \u2016q\u2016 \u2016r\u2016"}, {"line": "dsimp [norm] at h \u22a2", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nq r : \u211a_[p]\nh : \u00ac\u2016q\u2016 = \u2016r\u2016\n\u22a2 \u2016q + r\u2016 = max \u2016q\u2016 \u2016r\u2016"}, {"line": "have : padicNormE q \u2260 padicNormE r := mod_cast h", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nq r : \u211a_[p]\nh : \u00ac\u2016q\u2016 = \u2016r\u2016\nthis : sorry \u2260 sorry\n\u22a2 \u2016q + r\u2016 = max \u2016q\u2016 \u2016r\u2016"}, {"line": "exact mod_cast add_eq_max_of_ne' this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem padicNormE_lim_le {f : CauSeq \u211a_[p] norm} {a : \u211d} (ha : 0 < a) (hf : \u2200 i, \u2016f i\u2016 \u2264 a) :\n    \u2016f.lim\u2016 \u2264 a := by\n  obtain \u27e8N, hN\u27e9 := Setoid.symm (CauSeq.equiv_lim f) _ ha\n  calc\n    \u2016f.lim\u2016 = \u2016f.lim - f N + f N\u2016 := by simp\n    _ \u2264 max \u2016f.lim - f N\u2016 \u2016f N\u2016 := padicNormE.nonarchimedean _ _\n    _ \u2264 a := max_le (le_of_lt (hN _ le_rfl)) (hf _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNumbers.lean", "context": {"open": ["Nat padicNorm CauSeq CauSeq.Completion Metric", "Classical in", "CauSeq", "CauSeq", "Classical in", "PadicSeq", "CauSeq", "PadicSeq", "PadicSeq Padic"], "variables": ["{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "(p)", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime] (f : CauSeq _ (@padicNormE p _))", "(p : \u2115) [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nf : CauSeq \u211a_[p] Norm.norm\na : \u211d\nha : 0 < a\nhf : \u2200 (i : \u2115), \u2016\u2191f i\u2016 \u2264 a\n\u22a2 \u2016f.lim\u2016 \u2264 a"}, {"line": "obtain \u27e8N, hN\u27e9 := Setoid.symm (CauSeq.equiv_lim f) _ ha", "tactic_state": "case intro\np : \u2115\nhp : Fact (Nat.Prime p)\nf : CauSeq \u211a_[p] Norm.norm\na : \u211d\nha : 0 < a\nhf : \u2200 (i : \u2115), \u2016\u2191f i\u2016 \u2264 a\nN : \u2115\nhN : \u2200 j \u2265 N, \u2016\u2191(const Norm.norm f.lim - f) j\u2016 < a\n\u22a2 \u2016f.lim\u2016 \u2264 a"}, {"line": "calc\n    \u2016f.lim\u2016 = \u2016f.lim - f N + f N\u2016 := by simp\n    _ \u2264 max \u2016f.lim - f N\u2016 \u2016f N\u2016 := padicNormE.nonarchimedean _ _\n    _ \u2264 a := max_le (le_of_lt (hN _ le_rfl)) (hf _)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma valuation_intCast (n : \u2124) : valuation (n : \u211a_[p]) = padicValInt p n := by\n  rw [\u2190 Rat.cast_intCast]\n  rw [valuation_ratCast]\n  rw [padicValRat.of_int]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNumbers.lean", "context": {"open": ["Nat padicNorm CauSeq CauSeq.Completion Metric", "Classical in", "CauSeq", "CauSeq", "Classical in", "PadicSeq", "CauSeq", "PadicSeq", "PadicSeq Padic", "Filter Set"], "variables": ["{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "(p)", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime] (f : CauSeq _ (@padicNormE p _))", "(p : \u2115) [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2124\n\u22a2 (\u2191n).valuation = \u2191(padicValInt p n)"}, {"line": "rw [\u2190 Rat.cast_intCast]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2124\n\u22a2 (\u2191\u2191n).valuation = \u2191(padicValInt p n)"}, {"line": "rw [valuation_ratCast]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2124\n\u22a2 padicValRat p \u2191n = \u2191(padicValInt p n)"}, {"line": "rw [padicValRat.of_int]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma valuation_natCast (n : \u2115) : valuation (n : \u211a_[p]) = padicValNat p n := by\n  rw [\u2190 Rat.cast_natCast]\n  rw [valuation_ratCast]\n  rw [padicValRat.of_nat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNumbers.lean", "context": {"open": ["Nat padicNorm CauSeq CauSeq.Completion Metric", "Classical in", "CauSeq", "CauSeq", "Classical in", "PadicSeq", "CauSeq", "PadicSeq", "PadicSeq Padic", "Filter Set"], "variables": ["{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "(p)", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime] (f : CauSeq _ (@padicNormE p _))", "(p : \u2115) [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 (\u2191n).valuation = \u2191(padicValNat p n)"}, {"line": "rw [\u2190 Rat.cast_natCast]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 (\u2191\u2191n).valuation = \u2191(padicValNat p n)"}, {"line": "rw [valuation_ratCast]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 padicValRat p \u2191n = \u2191(padicValNat p n)"}, {"line": "rw [padicValRat.of_nat]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma valuation_one : valuation (1 : \u211a_[p]) = 0 := by\n  rw [\u2190 Nat.cast_one]\n  rw [valuation_natCast]\n  rw [padicValNat.one]\n  rw [cast_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNumbers.lean", "context": {"open": ["Nat padicNorm CauSeq CauSeq.Completion Metric", "Classical in", "CauSeq", "CauSeq", "Classical in", "PadicSeq", "CauSeq", "PadicSeq", "PadicSeq Padic", "Filter Set"], "variables": ["{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "(p)", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime] (f : CauSeq _ (@padicNormE p _))", "(p : \u2115) [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 Padic.valuation 1 = 0"}, {"line": "rw [\u2190 Nat.cast_one]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 (\u21911).valuation = 0"}, {"line": "rw [valuation_natCast]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 \u2191(padicValNat p 1) = 0"}, {"line": "rw [padicValNat.one]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 \u21910 = 0"}, {"line": "rw [cast_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma valuation_p : valuation (p : \u211a_[p]) = 1 := by\n  rw [valuation_natCast]\n  rw [padicValNat_self]\n  rw [cast_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNumbers.lean", "context": {"open": ["Nat padicNorm CauSeq CauSeq.Completion Metric", "Classical in", "CauSeq", "CauSeq", "Classical in", "PadicSeq", "CauSeq", "PadicSeq", "PadicSeq Padic", "Filter Set"], "variables": ["{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "(p)", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime] (f : CauSeq _ (@padicNormE p _))", "(p : \u2115) [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 (\u2191p).valuation = 1"}, {"line": "rw [valuation_natCast]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 \u2191(padicValNat p p) = 1"}, {"line": "rw [padicValNat_self]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 \u21911 = 1\n---\np : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 Fact (Nat.Prime p)"}, {"line": "rw [cast_one]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 Fact (Nat.Prime p)"}]}
{"declaration": "theorem AddValuation.map_zero : addValuationDef (0 : \u211a_[p]) = \u22a4 := by\n  rw [addValuationDef]\n  rw [if_pos rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNumbers.lean", "context": {"open": ["Nat padicNorm CauSeq CauSeq.Completion Metric", "Classical in", "CauSeq", "CauSeq", "Classical in", "PadicSeq", "CauSeq", "PadicSeq", "PadicSeq Padic", "Filter Set", "Classical in"], "variables": ["{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "(p)", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime] (f : CauSeq _ (@padicNormE p _))", "(p : \u2115) [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 addValuationDef 0 = \u22a4"}, {"line": "rw [addValuationDef]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 (if 0 = 0 then \u22a4 else \u2191(Padic.valuation 0)) = \u22a4"}, {"line": "rw [if_pos rfl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AddValuation.map_one : addValuationDef (1 : \u211a_[p]) = 0 := by\n  rw [addValuationDef]\n  rw [if_neg one_ne_zero]\n  rw [valuation_one]\n  rw [WithTop.coe_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNumbers.lean", "context": {"open": ["Nat padicNorm CauSeq CauSeq.Completion Metric", "Classical in", "CauSeq", "CauSeq", "Classical in", "PadicSeq", "CauSeq", "PadicSeq", "PadicSeq Padic", "Filter Set", "Classical in"], "variables": ["{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "(p)", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime] (f : CauSeq _ (@padicNormE p _))", "(p : \u2115) [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 addValuationDef 1 = 0"}, {"line": "rw [addValuationDef]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 (if 1 = 0 then \u22a4 else \u2191(Padic.valuation 1)) = 0"}, {"line": "rw [if_neg one_ne_zero]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 \u2191(Padic.valuation 1) = 0"}, {"line": "rw [valuation_one]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 \u21910 = 0"}, {"line": "rw [WithTop.coe_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AddValuation.map_mul (x y : \u211a_[p]) :\n    addValuationDef (x * y : \u211a_[p]) = addValuationDef x + addValuationDef y := by\n  simp only [addValuationDef]\n  by_cases hx : x = 0\n  \u00b7 rw [hx, if_pos rfl, zero_mul, if_pos rfl, WithTop.top_add]\n  \u00b7 by_cases hy : y = 0\n    \u00b7 rw [hy, if_pos rfl, mul_zero, if_pos rfl, WithTop.add_top]\n    \u00b7 rw [if_neg hx, if_neg hy, if_neg (mul_ne_zero hx hy), \u2190 WithTop.coe_add, WithTop.coe_eq_coe,\n        valuation_mul hx hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNumbers.lean", "context": {"open": ["Nat padicNorm CauSeq CauSeq.Completion Metric", "Classical in", "CauSeq", "CauSeq", "Classical in", "PadicSeq", "CauSeq", "PadicSeq", "PadicSeq Padic", "Filter Set", "Classical in"], "variables": ["{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "(p)", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime] (f : CauSeq _ (@padicNormE p _))", "(p : \u2115) [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nx y : \u211a_[p]\n\u22a2 (x * y).addValuationDef = x.addValuationDef + y.addValuationDef"}, {"line": "simp only [addValuationDef]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nx y : \u211a_[p]\n\u22a2 (if x * y = 0 then \u22a4 else \u2191(x * y).valuation) =\n    (if x = 0 then \u22a4 else \u2191x.valuation) + if y = 0 then \u22a4 else \u2191y.valuation"}, {"line": "by_cases hx : x = 0", "tactic_state": "case pos\np : \u2115\nhp : Fact (Nat.Prime p)\nx y : \u211a_[p]\nhx : x = 0\n\u22a2 (if x * y = 0 then \u22a4 else \u2191(x * y).valuation) =\n    (if x = 0 then \u22a4 else \u2191x.valuation) + if y = 0 then \u22a4 else \u2191y.valuation\n---\ncase neg\np : \u2115\nhp : Fact (Nat.Prime p)\nx y : \u211a_[p]\nhx : \u00acx = 0\n\u22a2 (if x * y = 0 then \u22a4 else \u2191(x * y).valuation) =\n    (if x = 0 then \u22a4 else \u2191x.valuation) + if y = 0 then \u22a4 else \u2191y.valuation"}, {"line": "\u00b7 rw [hx, if_pos rfl, zero_mul, if_pos rfl, WithTop.top_add]", "tactic_state": "case neg\np : \u2115\nhp : Fact (Nat.Prime p)\nx y : \u211a_[p]\nhx : \u00acx = 0\n\u22a2 (if x * y = 0 then \u22a4 else \u2191(x * y).valuation) =\n    (if x = 0 then \u22a4 else \u2191x.valuation) + if y = 0 then \u22a4 else \u2191y.valuation"}, {"line": "\u00b7 by_cases hy : y = 0\n    \u00b7 rw [hy, if_pos rfl, mul_zero, if_pos rfl, WithTop.add_top]\n    \u00b7 rw [if_neg hx, if_neg hy, if_neg (mul_ne_zero hx hy), \u2190 WithTop.coe_add, WithTop.coe_eq_coe,\n        valuation_mul hx hy]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem addValuation.apply {x : \u211a_[p]} (hx : x \u2260 0) :\n    Padic.addValuation x = (x.valuation : WithTop \u2124) := by\n  simp only [Padic.addValuation]\n  simp only [AddValuation.of_apply]\n  simp only [addValuationDef]\n  simp only [if_neg hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNumbers.lean", "context": {"open": ["Nat padicNorm CauSeq CauSeq.Completion Metric", "Classical in", "CauSeq", "CauSeq", "Classical in", "PadicSeq", "CauSeq", "PadicSeq", "PadicSeq Padic", "Filter Set", "Classical in"], "variables": ["{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "(p)", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime] (f : CauSeq _ (@padicNormE p _))", "(p : \u2115) [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nx : \u211a_[p]\nhx : x \u2260 0\n\u22a2 addValuation x = \u2191x.valuation"}, {"line": "simp only [Padic.addValuation]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nx : \u211a_[p]\nhx : x \u2260 0\n\u22a2 (AddValuation.of addValuationDef \u22ef \u22ef \u22ef \u22ef) x = \u2191x.valuation"}, {"line": "simp only [AddValuation.of_apply]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nx : \u211a_[p]\nhx : x \u2260 0\n\u22a2 x.addValuationDef = \u2191x.valuation"}, {"line": "simp only [addValuationDef]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nx : \u211a_[p]\nhx : x \u2260 0\n\u22a2 (if x = 0 then \u22a4 else \u2191x.valuation) = \u2191x.valuation"}, {"line": "simp only [if_neg hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_lt_pow_iff_norm_le_pow_sub_one (x : \u211a_[p]) (n : \u2124) :\n    \u2016x\u2016 < (p : \u211d) ^ n \u2194 \u2016x\u2016 \u2264 (p : \u211d) ^ (n - 1) := by\n  rw [norm_le_pow_iff_norm_lt_pow_add_one]\n  rw [sub_add_cancel]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicNumbers.lean", "context": {"open": ["Nat padicNorm CauSeq CauSeq.Completion Metric", "Classical in", "CauSeq", "CauSeq", "Classical in", "PadicSeq", "CauSeq", "PadicSeq", "PadicSeq Padic", "Filter Set", "Classical in"], "variables": ["{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [Fact p.Prime]", "(p)", "{p : \u2115} [Fact p.Prime]", "{p : \u2115} [Fact p.Prime] (f : CauSeq _ (@padicNormE p _))", "(p : \u2115) [Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]", "{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nx : \u211a_[p]\nn : \u2124\n\u22a2 \u2016x\u2016 < \u2191p ^ n \u2194 \u2016x\u2016 \u2264 \u2191p ^ (n - 1)"}, {"line": "rw [norm_le_pow_iff_norm_lt_pow_add_one]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nx : \u211a_[p]\nn : \u2124\n\u22a2 \u2016x\u2016 < \u2191p ^ n \u2194 \u2016x\u2016 < \u2191p ^ (n - 1 + 1)"}, {"line": "rw [sub_add_cancel]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem modPart_lt_p : modPart p r < p := by\n  convert Int.emod_lt_abs _ _\n  \u00b7 simp\n  \u00b7 exact mod_cast hp_prime.1.ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/RingHoms.lean", "context": {"open": ["Nat IsLocalRing Padic"], "variables": ["{p : \u2115} [hp_prime : Fact p.Prime]", "(p) (r : \u211a)", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp_prime : Fact (Nat.Prime p)\nx\u271d : Sort u_1\nmodPart : x\u271d\n\u22a2 sorry < p"}, {"line": "convert Int.emod_lt_abs _ _", "tactic_state": "case a\np : \u2115\nhp_prime : Fact (Nat.Prime p)\nx\u271d : Sort u_1\nmodPart : x\u271d\n\u22a2 sorry < p \u2194 ?convert_1 % ?convert_2 < |?convert_2|\n---\ncase convert_1\np : \u2115\nhp_prime : Fact (Nat.Prime p)\nx\u271d : Sort u_1\nmodPart : x\u271d\n\u22a2 \u2124\n---\ncase convert_2\np : \u2115\nhp_prime : Fact (Nat.Prime p)\nx\u271d : Sort u_1\nmodPart : x\u271d\n\u22a2 \u2124\n---\ncase convert_3\np : \u2115\nhp_prime : Fact (Nat.Prime p)\nx\u271d : Sort u_1\nmodPart : x\u271d\n\u22a2 ?convert_2 \u2260 0"}, {"line": "\u00b7 simp", "tactic_state": "case convert_1\np : \u2115\nhp_prime : Fact (Nat.Prime p)\nx\u271d : Sort u_1\nmodPart : x\u271d\n\u22a2 \u2124\n---\ncase convert_2\np : \u2115\nhp_prime : Fact (Nat.Prime p)\nx\u271d : Sort u_1\nmodPart : x\u271d\n\u22a2 \u2124\n---\ncase convert_3\np : \u2115\nhp_prime : Fact (Nat.Prime p)\nx\u271d : Sort u_1\nmodPart : x\u271d\n\u22a2 ?convert_2 \u2260 0"}, {"line": "\u00b7 exact mod_cast hp_prime.1.ne_zero", "tactic_state": "case convert_2\np : \u2115\nhp_prime : Fact (Nat.Prime p)\nx\u271d : Sort u_1\nmodPart : x\u271d\n\u22a2 \u2124\n---\ncase convert_3\np : \u2115\nhp_prime : Fact (Nat.Prime p)\nx\u271d : Sort u_1\nmodPart : x\u271d\n\u22a2 ?convert_2 \u2260 0"}]}
{"declaration": "theorem zmod_congr_of_sub_mem_span (n : \u2115) (x : \u2124_[p]) (a b : \u2115)\n    (ha : x - a \u2208 (Ideal.span {(p : \u2124_[p]) ^ n}))\n    (hb : x - b \u2208 (Ideal.span {(p : \u2124_[p]) ^ n})) : (a : ZMod (p ^ n)) = b := by\n  simpa using zmod_congr_of_sub_mem_span_aux n x a b ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/RingHoms.lean", "context": {"open": ["Nat IsLocalRing Padic"], "variables": ["{p : \u2115} [hp_prime : Fact p.Prime]", "(p) (r : \u211a)", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp_prime : Fact (Nat.Prime p)\nn : \u2115\nx : \u2124_[p]\na b : \u2115\nha : x - \u2191a \u2208 Ideal.span {\u2191p ^ n}\nhb : x - \u2191b \u2208 Ideal.span {\u2191p ^ n}\n\u22a2 \u2191a = \u2191b"}, {"line": "simpa using zmod_congr_of_sub_mem_span_aux n x a b ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem self (hp : 1 < p) : padicValNat p p = 1 := by\n  simp [padicValNat_def', zero_lt_one.trans hp, hp.ne']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset"], "variables": ["{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : 1 < p\n\u22a2 padicValNat p p = 1"}, {"line": "simp [padicValNat_def', zero_lt_one.trans hp, hp.ne']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem maxPowDiv_eq_emultiplicity {p n : \u2115} (hp : 1 < p) (hn : 0 < n) :\n    p.maxPowDiv n = emultiplicity p n := by\n  apply (emultiplicity_eq_of_dvd_of_not_dvd (pow_dvd p n) _).symm\n  intro h\n  apply Nat.not_lt.mpr <| le_of_dvd hp hn h\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n : \u2115\nhp : 1 < p\nhn : 0 < n\n\u22a2 \u2191(p.maxPowDiv n) = emultiplicity p n"}, {"line": "apply (emultiplicity_eq_of_dvd_of_not_dvd (pow_dvd p n) _).symm", "tactic_state": "p n : \u2115\nhp : 1 < p\nhn : 0 < n\n\u22a2 \u00acp ^ (p.maxPowDiv n + 1) \u2223 n"}, {"line": "intro h", "tactic_state": "p n : \u2115\nhp : 1 < p\nhn : 0 < n\nh : p ^ (p.maxPowDiv n + 1) \u2223 n\n\u22a2 False"}, {"line": "apply Nat.not_lt.mpr <| le_of_dvd hp hn h", "tactic_state": "p n : \u2115\nhp : 1 < p\nhn : 0 < n\nh : p ^ (p.maxPowDiv n + 1) \u2223 n\n\u22a2 p.maxPowDiv n < p.maxPowDiv n + 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem maxPowDiv_eq_multiplicity {p n : \u2115} (hp : 1 < p) (hn : 0 < n) (h : FiniteMultiplicity p n) :\n    p.maxPowDiv n = multiplicity p n := by\n  exact_mod_cast h.emultiplicity_eq_multiplicity \u25b8 maxPowDiv_eq_emultiplicity hp hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n : \u2115\nhp : 1 < p\nhn : 0 < n\nh : FiniteMultiplicity p n\n\u22a2 p.maxPowDiv n = multiplicity p n"}, {"line": "exact_mod_cast h.emultiplicity_eq_multiplicity \u25b8 maxPowDiv_eq_emultiplicity hp hn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_ne_one_ne_zero {z : \u2124} (hp : p \u2260 1) (hz : z \u2260 0) :\n    padicValInt p z = multiplicity (p : \u2124) z:= by\n  rw [padicValInt]\n  rw [padicValNat_def' hp (Int.natAbs_pos.mpr hz)]\n  apply Int.multiplicity_natAbs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nz : \u2124\nhp : p \u2260 1\nhz : z \u2260 0\n\u22a2 padicValInt p z = multiplicity (\u2191p) z"}, {"line": "rw [padicValInt]", "tactic_state": "p : \u2115\nz : \u2124\nhp : p \u2260 1\nhz : z \u2260 0\n\u22a2 padicValNat p z.natAbs = multiplicity (\u2191p) z"}, {"line": "rw [padicValNat_def' hp (Int.natAbs_pos.mpr hz)]", "tactic_state": "p : \u2115\nz : \u2124\nhp : p \u2260 1\nhz : z \u2260 0\n\u22a2 multiplicity p z.natAbs = multiplicity (\u2191p) z"}, {"line": "apply Int.multiplicity_natAbs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_nat {n : \u2115} : padicValInt p n = padicValNat p n := by simp [padicValInt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n : \u2115\n\u22a2 padicValInt p \u2191n = padicValNat p n"}, {"line": "simp [padicValInt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem self (hp : 1 < p) : padicValInt p p = 1 := by simp [padicValNat.self hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : 1 < p\n\u22a2 padicValInt p \u2191p = 1"}, {"line": "simp [padicValNat.self hp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_int {z : \u2124} : padicValRat p z = padicValInt p z := by simp [padicValRat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nz : \u2124\n\u22a2 padicValRat p \u2191z = \u2191(padicValInt p z)"}, {"line": "simp [padicValRat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiplicity_sub_multiplicity {q : \u211a} (hp : p \u2260 1) (hq : q \u2260 0) :\n    padicValRat p q = multiplicity (p : \u2124) q.num - multiplicity p q.den := by\n  rw [padicValRat]\n  rw [padicValInt.of_ne_one_ne_zero hp (Rat.num_ne_zero.2 hq)]\n  rw [padicValNat_def' hp q.pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nq : \u211a\nhp : p \u2260 1\nhq : q \u2260 0\n\u22a2 padicValRat p q = \u2191(multiplicity (\u2191p) q.num) - \u2191(multiplicity p q.den)"}, {"line": "rw [padicValRat]", "tactic_state": "p : \u2115\nq : \u211a\nhp : p \u2260 1\nhq : q \u2260 0\n\u22a2 \u2191(padicValInt p q.num) - \u2191(padicValNat p q.den) = \u2191(multiplicity (\u2191p) q.num) - \u2191(multiplicity p q.den)"}, {"line": "rw [padicValInt.of_ne_one_ne_zero hp (Rat.num_ne_zero.2 hq)]", "tactic_state": "p : \u2115\nq : \u211a\nhp : p \u2260 1\nhq : q \u2260 0\n\u22a2 \u2191(multiplicity (\u2191p) q.num) - \u2191(padicValNat p q.den) = \u2191(multiplicity (\u2191p) q.num) - \u2191(multiplicity p q.den)"}, {"line": "rw [padicValNat_def' hp q.pos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_nat {n : \u2115} : padicValRat p n = padicValNat p n := by simp [padicValRat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n : \u2115\n\u22a2 padicValRat p \u2191n = \u2191(padicValNat p n)"}, {"line": "simp [padicValRat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem self (hp : 1 < p) : padicValRat p p = 1 := by simp [hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : 1 < p\n\u22a2 padicValRat p \u2191p = 1"}, {"line": "simp [hp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_le_padicValRat_of_nat (n : \u2115) : 0 \u2264 padicValRat p n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n : \u2115\n\u22a2 0 \u2264 padicValRat p \u2191n"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem padicValRat_of_nat (n : \u2115) : \u2191(padicValNat p n) = padicValRat p n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n : \u2115\n\u22a2 \u2191(padicValNat p n) = padicValRat p \u2191n"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_le_padicValNat_of_dvd {n : \u2115} [hp : Fact p.Prime] (hn : 0 < n) (div : p \u2223 n) :\n    1 \u2264 padicValNat p n := by\n  rwa [\u2190 WithTop.coe_le_coe, ENat.some_eq_coe, padicValNat_eq_emultiplicity hn,\n    \u2190 pow_dvd_iff_le_emultiplicity, pow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n : \u2115\nhp : Fact (Nat.Prime p)\nhn : 0 < n\ndiv : p \u2223 n\n\u22a2 1 \u2264 padicValNat p n"}, {"line": "rwa [\u2190 WithTop.coe_le_coe, ENat.some_eq_coe, padicValNat_eq_emultiplicity hn,\n    \u2190 pow_dvd_iff_le_emultiplicity, pow_one]", "tactic_state": "p n : \u2115\nhp : Fact (Nat.Prime p)\nhn : 0 < n\ndiv : p \u2223 n\n\u22a2 Fact (Nat.Prime p)"}]}
{"declaration": "theorem finite_int_prime_iff {a : \u2124} : FiniteMultiplicity (p : \u2124) a \u2194 a \u2260 0 := by\n  simp [Int.finiteMultiplicity_iff, hp.1.ne_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\na : \u2124\n\u22a2 FiniteMultiplicity (\u2191p) a \u2194 a \u2260 0"}, {"line": "simp [Int.finiteMultiplicity_iff, hp.1.ne_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma self_pow_inv (r : \u2115) : padicValRat p ((p : \u211a) ^ r)\u207b\u00b9 = -r := by\n  rw [padicValRat.inv]\n  rw [neg_inj]\n  rw [padicValRat.pow (Nat.cast_ne_zero.mpr hp.elim.ne_zero)]\n  rw [padicValRat.self hp.elim.one_lt]\n  rw [mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nr : \u2115\n\u22a2 padicValRat p (\u2191p ^ r)\u207b\u00b9 = -\u2191r"}, {"line": "rw [padicValRat.inv]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nr : \u2115\n\u22a2 -padicValRat p (\u2191p ^ r) = -\u2191r\n---\np : \u2115\nhp : Fact (Nat.Prime p)\nr : \u2115\n\u22a2 Fact (Nat.Prime p)"}, {"line": "rw [neg_inj]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nr : \u2115\n\u22a2 padicValRat p (\u2191p ^ r) = \u2191r\n---\np : \u2115\nhp : Fact (Nat.Prime p)\nr : \u2115\n\u22a2 Fact (Nat.Prime p)"}, {"line": "rw [padicValRat.pow (Nat.cast_ne_zero.mpr hp.elim.ne_zero)]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nr : \u2115\n\u22a2 \u2191r * padicValRat p \u2191p = \u2191r\n---\np : \u2115\nhp : Fact (Nat.Prime p)\nr : \u2115\n\u22a2 Fact (Nat.Prime p)\n---\np : \u2115\nhp : Fact (Nat.Prime p)\nr : \u2115\n\u22a2 Fact (Nat.Prime p)"}, {"line": "rw [padicValRat.self hp.elim.one_lt]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nr : \u2115\n\u22a2 \u2191r * 1 = \u2191r\n---\np : \u2115\nhp : Fact (Nat.Prime p)\nr : \u2115\n\u22a2 Fact (Nat.Prime p)\n---\np : \u2115\nhp : Fact (Nat.Prime p)\nr : \u2115\n\u22a2 Fact (Nat.Prime p)"}, {"line": "rw [mul_one]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\nr : \u2115\n\u22a2 Fact (Nat.Prime p)\n---\np : \u2115\nhp : Fact (Nat.Prime p)\nr : \u2115\n\u22a2 Fact (Nat.Prime p)"}]}
{"declaration": "theorem dvd_of_one_le_padicValNat {n : \u2115} (hp : 1 \u2264 padicValNat p n) : p \u2223 n := by\n  by_contra h\n  rw [padicValNat.eq_zero_of_not_dvd h] at hp\n  exact lt_irrefl 0 (lt_of_lt_of_le zero_lt_one hp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115} [hp : Fact p.Prime]", "{p a b : \u2115} [hp : Fact p.Prime]", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n : \u2115\nhp : 1 \u2264 padicValNat p n\n\u22a2 p \u2223 n"}, {"line": "by_contra h", "tactic_state": "p n : \u2115\nhp : 1 \u2264 padicValNat p n\nh : \u00acp \u2223 n\n\u22a2 False"}, {"line": "rw [padicValNat.eq_zero_of_not_dvd h] at hp", "tactic_state": "p n : \u2115\nhp : 1 \u2264 0\nh : \u00acp \u2223 n\n\u22a2 False"}, {"line": "exact lt_irrefl 0 (lt_of_lt_of_le zero_lt_one hp)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem padicValNat_dvd_iff_le [hp : Fact p.Prime] {a n : \u2115} (ha : a \u2260 0) :\n    p ^ n \u2223 a \u2194 n \u2264 padicValNat p a := by\n  rw [pow_dvd_iff_le_emultiplicity]\n  rw [\u2190 padicValNat_eq_emultiplicity (Nat.pos_of_ne_zero ha)]\n  rw [Nat.cast_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115} [hp : Fact p.Prime]", "{p a b : \u2115} [hp : Fact p.Prime]", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\na n : \u2115\nha : a \u2260 0\n\u22a2 p ^ n \u2223 a \u2194 n \u2264 padicValNat p a"}, {"line": "rw [pow_dvd_iff_le_emultiplicity]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\na n : \u2115\nha : a \u2260 0\n\u22a2 \u2191n \u2264 emultiplicity p a \u2194 n \u2264 padicValNat p a"}, {"line": "rw [\u2190 padicValNat_eq_emultiplicity (Nat.pos_of_ne_zero ha)]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\na n : \u2115\nha : a \u2260 0\n\u22a2 \u2191n \u2264 \u2191(padicValNat p a) \u2194 n \u2264 padicValNat p a\n---\np : \u2115\nhp : Fact (Nat.Prime p)\na n : \u2115\nha : a \u2260 0\n\u22a2 Fact (Nat.Prime p)"}, {"line": "rw [Nat.cast_le]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\na n : \u2115\nha : a \u2260 0\n\u22a2 Fact (Nat.Prime p)"}]}
{"declaration": "theorem padicValNat_dvd_iff (n : \u2115) [hp : Fact p.Prime] (a : \u2115) :\n    p ^ n \u2223 a \u2194 a = 0 \u2228 n \u2264 padicValNat p a := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  \u00b7 exact iff_of_true (dvd_zero _) (Or.inl rfl)\n  \u00b7 rw [padicValNat_dvd_iff_le ha, or_iff_right ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115} [hp : Fact p.Prime]", "{p a b : \u2115} [hp : Fact p.Prime]", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n : \u2115\nhp : Fact (Nat.Prime p)\na : \u2115\n\u22a2 p ^ n \u2223 a \u2194 a = 0 \u2228 n \u2264 padicValNat p a"}, {"line": "rcases eq_or_ne a 0 with (rfl | ha)", "tactic_state": "case inl\np n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 p ^ n \u2223 0 \u2194 0 = 0 \u2228 n \u2264 padicValNat p 0\n---\ncase inr\np n : \u2115\nhp : Fact (Nat.Prime p)\na : \u2115\nha : a \u2260 0\n\u22a2 p ^ n \u2223 a \u2194 a = 0 \u2228 n \u2264 padicValNat p a"}, {"line": "\u00b7 exact iff_of_true (dvd_zero _) (Or.inl rfl)", "tactic_state": "case inr\np n : \u2115\nhp : Fact (Nat.Prime p)\na : \u2115\nha : a \u2260 0\n\u22a2 p ^ n \u2223 a \u2194 a = 0 \u2228 n \u2264 padicValNat p a"}, {"line": "\u00b7 rw [padicValNat_dvd_iff_le ha, or_iff_right ha]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pow_succ_padicValNat_not_dvd {n : \u2115} [hp : Fact p.Prime] (hn : n \u2260 0) :\n    \u00acp ^ (padicValNat p n + 1) \u2223 n := by\n  rw [padicValNat_dvd_iff_le hn]\n  rw [not_le]\n  exact Nat.lt_succ_self _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115} [hp : Fact p.Prime]", "{p a b : \u2115} [hp : Fact p.Prime]", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\n\u22a2 \u00acp ^ (padicValNat p n + 1) \u2223 n"}, {"line": "rw [padicValNat_dvd_iff_le hn]", "tactic_state": "p n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\n\u22a2 \u00acpadicValNat p n + 1 \u2264 padicValNat p n\n---\np n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\n\u22a2 Fact (Nat.Prime p)"}, {"line": "rw [not_le]", "tactic_state": "p n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\n\u22a2 padicValNat p n < padicValNat p n + 1\n---\np n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\n\u22a2 Fact (Nat.Prime p)"}, {"line": "exact Nat.lt_succ_self _", "tactic_state": "p n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\n\u22a2 Fact (Nat.Prime p)"}]}
{"declaration": "theorem padicValNat_mul_pow_right {q : \u2115} [hp : Fact p.Prime] [hq : Fact q.Prime]\n    (n m : \u2115) (neq : q \u2260 p) : padicValNat q (p^n * q^m) = m := by\n  rw [mul_comm (p^n) (q^m)]\n  exact padicValNat_mul_pow_left m n neq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115} [hp : Fact p.Prime]", "{p a b : \u2115} [hp : Fact p.Prime]", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u2115\nhp : Fact (Nat.Prime p)\nhq : Fact (Nat.Prime q)\nn m : \u2115\nneq : q \u2260 p\n\u22a2 padicValNat q (p ^ n * q ^ m) = m"}, {"line": "rw [mul_comm (p^n) (q^m)]", "tactic_state": "p q : \u2115\nhp : Fact (Nat.Prime p)\nhq : Fact (Nat.Prime q)\nn m : \u2115\nneq : q \u2260 p\n\u22a2 padicValNat q (q ^ m * p ^ n) = m"}, {"line": "exact padicValNat_mul_pow_left m n neq", "tactic_state": "No Goals!"}]}
{"declaration": "lemma padicValNat_le_nat_log (n : \u2115) : padicValNat p n \u2264 Nat.log p n := by\n  rcases n with _ | n\n  \u00b7 simp\n  rcases p with _ | _ | p\n  \u00b7 simp\n  \u00b7 simp\n  exact Nat.le_log_of_pow_le p.one_lt_succ_succ (le_of_dvd n.succ_pos pow_padicValNat_dvd)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115} [hp : Fact p.Prime]", "{p a b : \u2115} [hp : Fact p.Prime]", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n : \u2115\n\u22a2 padicValNat p n \u2264 log p n"}, {"line": "rcases n with _ | n", "tactic_state": "case zero\np : \u2115\n\u22a2 padicValNat p 0 \u2264 log p 0\n---\ncase succ\np n : \u2115\n\u22a2 padicValNat p (n + 1) \u2264 log p (n + 1)"}, {"line": "\u00b7 simp", "tactic_state": "case succ\np n : \u2115\n\u22a2 padicValNat p (n + 1) \u2264 log p (n + 1)"}, {"line": "rcases p with _ | _ | p", "tactic_state": "case succ.zero\nn : \u2115\n\u22a2 padicValNat 0 (n + 1) \u2264 log 0 (n + 1)\n---\ncase succ.succ.zero\nn : \u2115\n\u22a2 padicValNat (0 + 1) (n + 1) \u2264 log (0 + 1) (n + 1)\n---\ncase succ.succ.succ\nn p : \u2115\n\u22a2 padicValNat (p + 1 + 1) (n + 1) \u2264 log (p + 1 + 1) (n + 1)"}, {"line": "\u00b7 simp", "tactic_state": "case succ.succ.zero\nn : \u2115\n\u22a2 padicValNat (0 + 1) (n + 1) \u2264 log (0 + 1) (n + 1)\n---\ncase succ.succ.succ\nn p : \u2115\n\u22a2 padicValNat (p + 1 + 1) (n + 1) \u2264 log (p + 1 + 1) (n + 1)"}, {"line": "\u00b7 simp", "tactic_state": "case succ.succ.succ\nn p : \u2115\n\u22a2 padicValNat (p + 1 + 1) (n + 1) \u2264 log (p + 1 + 1) (n + 1)"}, {"line": "exact Nat.le_log_of_pow_le p.one_lt_succ_succ (le_of_dvd n.succ_pos pow_padicValNat_dvd)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Nat.max_log_padicValNat_succ_eq_log_succ (n : \u2115) :\n    max (log 2 n) (padicValNat 2 (n + 1)) = log 2 (n + 1) := by\n  apply le_antisymm (max_le (le_log_of_pow_le one_lt_two (pow_log_le_add_one 2 n))\n    (padicValNat_le_nat_log (n + 1)))\n  rw [le_max_iff]\n  rw [or_iff_not_imp_left]\n  rw [not_le]\n  intro h\n  replace h := le_antisymm (add_one_le_iff.mpr (lt_pow_of_log_lt one_lt_two h))\n    (pow_log_le_self 2 n.succ_ne_zero)\n  rw [h]\n  rw [padicValNat.prime_pow]\n  rw [\u2190 h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115} [hp : Fact p.Prime]", "{p a b : \u2115} [hp : Fact p.Prime]", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 max (log 2 n) (padicValNat 2 (n + 1)) = log 2 (n + 1)"}, {"line": "apply le_antisymm (max_le (le_log_of_pow_le one_lt_two (pow_log_le_add_one 2 n))\n    (padicValNat_le_nat_log (n + 1)))", "tactic_state": "n : \u2115\n\u22a2 log 2 (n + 1) \u2264 max (log 2 n) (padicValNat 2 (n + 1))"}, {"line": "rw [le_max_iff]", "tactic_state": "n : \u2115\n\u22a2 log 2 (n + 1) \u2264 log 2 n \u2228 log 2 (n + 1) \u2264 padicValNat 2 (n + 1)"}, {"line": "rw [or_iff_not_imp_left]", "tactic_state": "n : \u2115\n\u22a2 \u00aclog 2 (n + 1) \u2264 log 2 n \u2192 log 2 (n + 1) \u2264 padicValNat 2 (n + 1)"}, {"line": "rw [not_le]", "tactic_state": "n : \u2115\n\u22a2 log 2 n < log 2 (n + 1) \u2192 log 2 (n + 1) \u2264 padicValNat 2 (n + 1)"}, {"line": "intro h", "tactic_state": "n : \u2115\nh : log 2 n < log 2 (n + 1)\n\u22a2 log 2 (n + 1) \u2264 padicValNat 2 (n + 1)"}, {"line": "replace h := le_antisymm (add_one_le_iff.mpr (lt_pow_of_log_lt one_lt_two h))\n    (pow_log_le_self 2 n.succ_ne_zero)", "tactic_state": "n : \u2115\nh : n + 1 = 2 ^ log 2 (n + 1)\n\u22a2 log 2 (n + 1) \u2264 padicValNat 2 (n + 1)"}, {"line": "rw [h]", "tactic_state": "n : \u2115\nh : n + 1 = 2 ^ log 2 (n + 1)\n\u22a2 log 2 (2 ^ log 2 (n + 1)) \u2264 padicValNat 2 (2 ^ log 2 (n + 1))"}, {"line": "rw [padicValNat.prime_pow]", "tactic_state": "n : \u2115\nh : n + 1 = 2 ^ log 2 (n + 1)\n\u22a2 log 2 (2 ^ log 2 (n + 1)) \u2264 log 2 (n + 1)"}, {"line": "rw [\u2190 h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem padicValNat_factorial_mul (n : \u2115) [hp : Fact p.Prime] :\n    padicValNat p (p * n) ! = padicValNat p n ! + n := by\n  apply Nat.cast_injective (R := \u2115\u221e)\n  rw [padicValNat_eq_emultiplicity <| factorial_pos (p * n)]\n  rw [Nat.cast_add]\n  rw [padicValNat_eq_emultiplicity <| factorial_pos n]\n  exact Prime.emultiplicity_factorial_mul hp.out\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115} [hp : Fact p.Prime]", "{p a b : \u2115} [hp : Fact p.Prime]", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 padicValNat p (p * n).factorial = padicValNat p n.factorial + n"}, {"line": "apply Nat.cast_injective (R := \u2115\u221e)", "tactic_state": "case a\np n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 \u2191(padicValNat p (p * n).factorial) = \u2191(padicValNat p n.factorial + n)"}, {"line": "rw [padicValNat_eq_emultiplicity <| factorial_pos (p * n)]", "tactic_state": "case a\np n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 emultiplicity p (p * n).factorial = \u2191(padicValNat p n.factorial + n)\n---\np n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 Fact (Nat.Prime p)"}, {"line": "rw [Nat.cast_add]", "tactic_state": "case a\np n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 emultiplicity p (p * n).factorial = \u2191(padicValNat p n.factorial) + \u2191n\n---\np n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 Fact (Nat.Prime p)"}, {"line": "rw [padicValNat_eq_emultiplicity <| factorial_pos n]", "tactic_state": "case a\np n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 emultiplicity p (p * n).factorial = emultiplicity p n.factorial + \u2191n\n---\np n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 Fact (Nat.Prime p)\n---\np n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 Fact (Nat.Prime p)"}, {"line": "exact Prime.emultiplicity_factorial_mul hp.out", "tactic_state": "p n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 Fact (Nat.Prime p)\n---\np n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 Fact (Nat.Prime p)"}]}
{"declaration": "theorem padicValNat_factorial {n b : \u2115} [hp : Fact p.Prime] (hnb : log p n < b) :\n    padicValNat p (n !) = \u2211 i \u2208 Finset.Ico 1 b, n / p ^ i := by\n  exact_mod_cast ((padicValNat_eq_emultiplicity (p := p) <| factorial_pos _) \u25b8\n      Prime.emultiplicity_factorial hp.out hnb)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115} [hp : Fact p.Prime]", "{p a b : \u2115} [hp : Fact p.Prime]", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n b : \u2115\nhp : Fact (Nat.Prime p)\nhnb : log p n < b\n\u22a2 padicValNat p n.factorial = \u2211 i \u2208 Finset.Ico 1 b, n / p ^ i"}, {"line": "exact_mod_cast ((padicValNat_eq_emultiplicity (p := p) <| factorial_pos _) \u25b8\n      Prime.emultiplicity_factorial hp.out hnb)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem padicValNat_choose {n k b : \u2115} [hp : Fact p.Prime] (hkn : k \u2264 n) (hnb : log p n < b) :\n    padicValNat p (choose n k) = #{i \u2208 Finset.Ico 1 b | p ^ i \u2264 k % p ^ i + (n - k) % p ^ i} := by\n  exact_mod_cast (padicValNat_eq_emultiplicity (p := p) <| choose_pos hkn) \u25b8\n    Prime.emultiplicity_choose hp.out hkn hnb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115} [hp : Fact p.Prime]", "{p a b : \u2115} [hp : Fact p.Prime]", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n k b : \u2115\nhp : Fact (Nat.Prime p)\nhkn : k \u2264 n\nhnb : log p n < b\n\u22a2 padicValNat p (n.choose k) = {i \u2208 Finset.Ico 1 b | p ^ i \u2264 k % p ^ i + (n - k) % p ^ i}.card"}, {"line": "exact_mod_cast (padicValNat_eq_emultiplicity (p := p) <| choose_pos hkn) \u25b8\n    Prime.emultiplicity_choose hp.out hkn hnb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem padicValNat_choose' {n k b : \u2115} [hp : Fact p.Prime] (hnb : log p (n + k) < b) :\n    padicValNat p (choose (n + k) k) = #{i \u2208 Finset.Ico 1 b | p ^ i \u2264 k % p ^ i + n % p ^ i} := by\n  exact_mod_cast (padicValNat_eq_emultiplicity (p := p) <| choose_pos <|\n    Nat.le_add_left k n)\u25b8 Prime.emultiplicity_choose' hp.out hnb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115} [hp : Fact p.Prime]", "{p a b : \u2115} [hp : Fact p.Prime]", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n k b : \u2115\nhp : Fact (Nat.Prime p)\nhnb : log p (n + k) < b\n\u22a2 padicValNat p ((n + k).choose k) = {i \u2208 Finset.Ico 1 b | p ^ i \u2264 k % p ^ i + n % p ^ i}.card"}, {"line": "exact_mod_cast (padicValNat_eq_emultiplicity (p := p) <| choose_pos <|\n    Nat.le_add_left k n)\u25b8 Prime.emultiplicity_choose' hp.out hnb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_one_mul_padicValNat_choose_eq_sub_sum_digits {k n : \u2115} [hp : Fact p.Prime]\n    (h : k \u2264 n) : (p - 1) * padicValNat p (choose n k) =\n    (p.digits k).sum + (p.digits (n - k)).sum - (p.digits n).sum := by\n  convert @sub_one_mul_padicValNat_choose_eq_sub_sum_digits' _ _ _ \u2039_\u203a\n  all_goals omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115} [hp : Fact p.Prime]", "{p a b : \u2115} [hp : Fact p.Prime]", "{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p k n : \u2115\nhp : Fact (Nat.Prime p)\nh : k \u2264 n\n\u22a2 (p - 1) * padicValNat p (n.choose k) = (p.digits k).sum + (p.digits (n - k)).sum - (p.digits n).sum"}, {"line": "convert @sub_one_mul_padicValNat_choose_eq_sub_sum_digits' _ _ _ \u2039_\u203a", "tactic_state": "case h.e'_2.h.e'_6.h.e'_2.h.e'_1\np k n : \u2115\nhp : Fact (Nat.Prime p)\nh : k \u2264 n\n\u22a2 n = n - k + k\n---\ncase h.e'_3.h.e'_6.h.e'_4.h.e'_2\np k n : \u2115\nhp : Fact (Nat.Prime p)\nh : k \u2264 n\n\u22a2 n = n - k + k"}, {"line": "all_goals omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem padicValInt_dvd (a : \u2124) : (p : \u2124) ^ padicValInt p a \u2223 a := by\n  rw [padicValInt_dvd_iff]\n  exact Or.inr le_rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Basic.lean", "context": {"open": ["Nat Rat", "scoped Finset", "Nat.maxPowDiv"], "variables": ["{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115}", "{p : \u2115} [hp : Fact p.Prime]", "{p a b : \u2115} [hp : Fact p.Prime]", "{p : \u2115}", "{p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\na : \u2124\n\u22a2 \u2191p ^ padicValInt p a \u2223 a"}, {"line": "rw [padicValInt_dvd_iff]", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\na : \u2124\n\u22a2 a = 0 \u2228 padicValInt p a \u2264 padicValInt p a\n---\np : \u2115\nhp : Fact (Nat.Prime p)\na : \u2124\n\u22a2 Fact (Nat.Prime p)"}, {"line": "exact Or.inr le_rfl", "tactic_state": "p : \u2115\nhp : Fact (Nat.Prime p)\na : \u2124\n\u22a2 Fact (Nat.Prime p)"}]}
{"declaration": "theorem padicValNat_def' {n : \u2115} (hp : p \u2260 1) (hn : 0 < n) :\n    padicValNat p n = multiplicity p n := by\n  simp [padicValNat, hp, hn, multiplicity, emultiplicity, finiteMultiplicity_iff.2 \u27e8hp, hn\u27e9]\n  convert (WithTop.untopD_coe ..).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Defs.lean", "context": {"open": ["Nat"], "variables": ["{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n : \u2115\nhp : p \u2260 1\nhn : 0 < n\n\u22a2 padicValNat p n = multiplicity p n"}, {"line": "simp [padicValNat, hp, hn, multiplicity, emultiplicity, finiteMultiplicity_iff.2 \u27e8hp, hn\u27e9]", "tactic_state": "p n : \u2115\nhp : p \u2260 1\nhn : 0 < n\n\u22a2 Nat.find \u22ef = WithTop.untopD 1 \u2191(Nat.find \u22ef)"}, {"line": "convert (WithTop.untopD_coe ..).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_zero_iff {n : \u2115} : padicValNat p n = 0 \u2194 p = 1 \u2228 n = 0 \u2228 \u00acp \u2223 n := by\n  simp only [padicValNat]\n  simp only [ne_eq]\n  simp only [pos_iff_ne_zero]\n  simp only [dite_eq_right_iff]\n  simp only [find_eq_zero]\n  simp only [zero_add]\n  simp only [pow_one]\n  simp only [and_imp]\n  simp only [\u2190 or_iff_not_imp_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Padics/PadicVal/Defs.lean", "context": {"open": ["Nat", "List"], "variables": ["{p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n : \u2115\n\u22a2 padicValNat p n = 0 \u2194 p = 1 \u2228 n = 0 \u2228 \u00acp \u2223 n"}, {"line": "simp only [padicValNat]", "tactic_state": "p n : \u2115\n\u22a2 (if h : p \u2260 1 \u2227 0 < n then Nat.find \u22ef else 0) = 0 \u2194 p = 1 \u2228 n = 0 \u2228 \u00acp \u2223 n"}, {"line": "simp only [ne_eq]", "tactic_state": "p n : \u2115\n\u22a2 (if h : \u00acp = 1 \u2227 0 < n then Nat.find \u22ef else 0) = 0 \u2194 p = 1 \u2228 n = 0 \u2228 \u00acp \u2223 n"}, {"line": "simp only [pos_iff_ne_zero]", "tactic_state": "p n : \u2115\n\u22a2 (if h : \u00acp = 1 \u2227 n \u2260 0 then Nat.find \u22ef else 0) = 0 \u2194 p = 1 \u2228 n = 0 \u2228 \u00acp \u2223 n"}, {"line": "simp only [dite_eq_right_iff]", "tactic_state": "p n : \u2115\n\u22a2 (\u2200 (h : \u00acp = 1 \u2227 n \u2260 0), Nat.find \u22ef = 0) \u2194 p = 1 \u2228 n = 0 \u2228 \u00acp \u2223 n"}, {"line": "simp only [find_eq_zero]", "tactic_state": "p n : \u2115\n\u22a2 \u00acp = 1 \u2227 n \u2260 0 \u2192 \u00acp ^ (0 + 1) \u2223 n \u2194 p = 1 \u2228 n = 0 \u2228 \u00acp \u2223 n"}, {"line": "simp only [zero_add]", "tactic_state": "p n : \u2115\n\u22a2 \u00acp = 1 \u2227 n \u2260 0 \u2192 \u00acp ^ 1 \u2223 n \u2194 p = 1 \u2228 n = 0 \u2228 \u00acp \u2223 n"}, {"line": "simp only [pow_one]", "tactic_state": "p n : \u2115\n\u22a2 \u00acp = 1 \u2227 n \u2260 0 \u2192 \u00acp \u2223 n \u2194 p = 1 \u2228 n = 0 \u2228 \u00acp \u2223 n"}, {"line": "simp only [and_imp]", "tactic_state": "p n : \u2115\n\u22a2 \u00acp = 1 \u2192 n \u2260 0 \u2192 \u00acp \u2223 n \u2194 p = 1 \u2228 n = 0 \u2228 \u00acp \u2223 n"}, {"line": "simp only [\u2190 or_iff_not_imp_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ramificationIdx_eq_find [DecidablePred fun n \u21a6 \u2200 (k : \u2115), map f p \u2264 P ^ k \u2192 k \u2264 n]\n    (h : \u2203 n, \u2200 k, map f p \u2264 P ^ k \u2192 k \u2264 n) :\n    ramificationIdx f p P = Nat.find h := by\n  convert Nat.sSup_def h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/RamificationInertia/Basic.lean", "context": {"open": ["Module", "UniqueFactorizationMonoid"], "variables": ["{R : Type u} [CommRing R]", "{S : Type v} [CommRing S] (f : R \u2192+* S)", "(p : Ideal R) (P : Ideal S)", "{f p P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type v\ninst\u271d\u00b9 : CommRing S\nP : Ideal S\nx\u271d\u00b9 : Sort u_1\nmap : x\u271d\u00b9\nx\u271d : Sort u_2\nramificationIdx : x\u271d\ninst\u271d : DecidablePred fun n => \u2200 (k : \u2115), sorry \u2264 P ^ k \u2192 k \u2264 n\nh : \u2203 n, \u2200 (k : \u2115), sorry \u2264 P ^ k \u2192 k \u2264 n\n\u22a2 sorry = Nat.find h"}, {"line": "convert Nat.sSup_def h", "tactic_state": "case h.e'_2\nS : Type v\ninst\u271d\u00b9 : CommRing S\nP : Ideal S\nx\u271d\u00b9 : Sort u_1\nmap : x\u271d\u00b9\nx\u271d : Sort u_2\nramificationIdx : x\u271d\ninst\u271d : DecidablePred fun n => \u2200 (k : \u2115), sorry \u2264 P ^ k \u2192 k \u2264 n\nh : \u2203 n, \u2200 (k : \u2115), sorry \u2264 P ^ k \u2192 k \u2264 n\n\u22a2 sorry = sSup fun a => \u2200 \u2983x : S\u2984, x \u2208 sorry \u2192 x \u2208 P ^ a"}]}
{"declaration": "theorem le_pow_of_le_ramificationIdx {n : \u2115} (hn : n \u2264 ramificationIdx f p P) :\n    map f p \u2264 P ^ n := by\n  contrapose! hn\n  exact ramificationIdx_lt hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/RamificationInertia/Basic.lean", "context": {"open": ["Module", "UniqueFactorizationMonoid"], "variables": ["{R : Type u} [CommRing R]", "{S : Type v} [CommRing S] (f : R \u2192+* S)", "(p : Ideal R) (P : Ideal S)", "{f p P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type v\ninst\u271d : CommRing S\nP : Ideal S\nx\u271d\u00b9 : Sort u_1\nramificationIdx : x\u271d\u00b9\nx\u271d : Sort u_2\nmap : x\u271d\nn : \u2115\nhn : n \u2264 sorry\n\u22a2 sorry \u2264 P ^ n"}, {"line": "contrapose! hn", "tactic_state": "S : Type v\ninst\u271d : CommRing S\nP : Ideal S\nx\u271d\u00b9 : Sort u_1\nramificationIdx : x\u271d\u00b9\nx\u271d : Sort u_2\nmap : x\u271d\nn : \u2115\nhn : \u00acsorry \u2264 P ^ n\n\u22a2 sorry < n"}, {"line": "exact ramificationIdx_lt hn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivAt_cexp_mul_sumIDeriv (p : \u2102[X]) (s : \u2102) (x : \u211d) :\n    HasDerivAt (fun x : \u211d \u21a6 -(cexp (-(x \u2022 s)) * p.sumIDeriv.eval (x \u2022 s)))\n      (s * (cexp (-(x \u2022 s)) * p.eval (x \u2022 s))) x := by\n  have h\u2080 := (hasDerivAt_id' x).smul_const s\n  have h\u2081 := h\u2080.neg.cexp\n  have h\u2082 := ((sumIDeriv p).hasDerivAt (x \u2022 s)).comp x h\u2080\n  convert (h\u2081.mul h\u2082).neg using 1\n  nth_rw 1 [sumIDeriv_eq_self_add p]\n  simp only [one_smul]\n  simp only [eval_add]\n  simp only [Function.comp_apply]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Transcendental/Lindemann/AnalyticalPart.lean", "context": {"open": ["scoped Nat", "Complex Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Polynomial \u2102\ns : \u2102\nx : \u211d\n\u22a2 HasDerivAt (fun x => -(exp (-(x \u2022 s)) * eval (x \u2022 s) (sumIDeriv p))) (s * (exp (-(x \u2022 s)) * eval (x \u2022 s) p)) x"}, {"line": "have h\u2080 := (hasDerivAt_id' x).smul_const s", "tactic_state": "p : Polynomial \u2102\ns : \u2102\nx : \u211d\nh\u2080 : HasDerivAt (fun y => y \u2022 s) (1 \u2022 s) x\n\u22a2 HasDerivAt (fun x => -(exp (-(x \u2022 s)) * eval (x \u2022 s) (sumIDeriv p))) (s * (exp (-(x \u2022 s)) * eval (x \u2022 s) p)) x"}, {"line": "have h\u2081 := h\u2080.neg.cexp", "tactic_state": "p : Polynomial \u2102\ns : \u2102\nx : \u211d\nh\u2080 : HasDerivAt (fun y => y \u2022 s) (1 \u2022 s) x\nh\u2081 : HasDerivAt (fun x => exp (-(x \u2022 s))) (exp (-(x \u2022 s)) * -(1 \u2022 s)) x\n\u22a2 HasDerivAt (fun x => -(exp (-(x \u2022 s)) * eval (x \u2022 s) (sumIDeriv p))) (s * (exp (-(x \u2022 s)) * eval (x \u2022 s) p)) x"}, {"line": "have h\u2082 := ((sumIDeriv p).hasDerivAt (x \u2022 s)).comp x h\u2080", "tactic_state": "p : Polynomial \u2102\ns : \u2102\nx : \u211d\nh\u2080 : HasDerivAt (fun y => y \u2022 s) (1 \u2022 s) x\nh\u2081 : HasDerivAt (fun x => exp (-(x \u2022 s))) (exp (-(x \u2022 s)) * -(1 \u2022 s)) x\nh\u2082 : HasDerivAt ((fun x => eval x (sumIDeriv p)) \u2218 fun y => y \u2022 s) (eval (x \u2022 s) (derivative (sumIDeriv p)) * 1 \u2022 s) x\n\u22a2 HasDerivAt (fun x => -(exp (-(x \u2022 s)) * eval (x \u2022 s) (sumIDeriv p))) (s * (exp (-(x \u2022 s)) * eval (x \u2022 s) p)) x"}, {"line": "convert (h\u2081.mul h\u2082).neg using 1", "tactic_state": "case h.e'_9\np : Polynomial \u2102\ns : \u2102\nx : \u211d\nh\u2080 : HasDerivAt (fun y => y \u2022 s) (1 \u2022 s) x\nh\u2081 : HasDerivAt (fun x => exp (-(x \u2022 s))) (exp (-(x \u2022 s)) * -(1 \u2022 s)) x\nh\u2082 : HasDerivAt ((fun x => eval x (sumIDeriv p)) \u2218 fun y => y \u2022 s) (eval (x \u2022 s) (derivative (sumIDeriv p)) * 1 \u2022 s) x\n\u22a2 s * (exp (-(x \u2022 s)) * eval (x \u2022 s) p) =\n    -(exp (-(x \u2022 s)) * -(1 \u2022 s) * ((fun x => eval x (sumIDeriv p)) \u2218 fun y => y \u2022 s) x +\n        exp (-(x \u2022 s)) * (eval (x \u2022 s) (derivative (sumIDeriv p)) * 1 \u2022 s))"}, {"line": "nth_rw 1 [sumIDeriv_eq_self_add p]", "tactic_state": "case h.e'_9\np : Polynomial \u2102\ns : \u2102\nx : \u211d\nh\u2080 : HasDerivAt (fun y => y \u2022 s) (1 \u2022 s) x\nh\u2081 : HasDerivAt (fun x => exp (-(x \u2022 s))) (exp (-(x \u2022 s)) * -(1 \u2022 s)) x\nh\u2082 : HasDerivAt ((fun x => eval x (sumIDeriv p)) \u2218 fun y => y \u2022 s) (eval (x \u2022 s) (derivative (sumIDeriv p)) * 1 \u2022 s) x\n\u22a2 s * (exp (-(x \u2022 s)) * eval (x \u2022 s) p) =\n    -(exp (-(x \u2022 s)) * -(1 \u2022 s) * ((fun x => eval x (p + derivative (sumIDeriv p))) \u2218 fun y => y \u2022 s) x +\n        exp (-(x \u2022 s)) * (eval (x \u2022 s) (derivative (sumIDeriv p)) * 1 \u2022 s))"}, {"line": "simp only [one_smul]", "tactic_state": "case h.e'_9\np : Polynomial \u2102\ns : \u2102\nx : \u211d\nh\u2080 : HasDerivAt (fun y => y \u2022 s) (1 \u2022 s) x\nh\u2081 : HasDerivAt (fun x => exp (-(x \u2022 s))) (exp (-(x \u2022 s)) * -(1 \u2022 s)) x\nh\u2082 : HasDerivAt ((fun x => eval x (sumIDeriv p)) \u2218 fun y => y \u2022 s) (eval (x \u2022 s) (derivative (sumIDeriv p)) * 1 \u2022 s) x\n\u22a2 s * (exp (-(x \u2022 s)) * eval (x \u2022 s) p) =\n    -(exp (-(x \u2022 s)) * -s * ((fun x => eval x (p + derivative (sumIDeriv p))) \u2218 fun y => y \u2022 s) x +\n        exp (-(x \u2022 s)) * (eval (x \u2022 s) (derivative (sumIDeriv p)) * s))"}, {"line": "simp only [eval_add]", "tactic_state": "case h.e'_9\np : Polynomial \u2102\ns : \u2102\nx : \u211d\nh\u2080 : HasDerivAt (fun y => y \u2022 s) (1 \u2022 s) x\nh\u2081 : HasDerivAt (fun x => exp (-(x \u2022 s))) (exp (-(x \u2022 s)) * -(1 \u2022 s)) x\nh\u2082 : HasDerivAt ((fun x => eval x (sumIDeriv p)) \u2218 fun y => y \u2022 s) (eval (x \u2022 s) (derivative (sumIDeriv p)) * 1 \u2022 s) x\n\u22a2 s * (exp (-(x \u2022 s)) * eval (x \u2022 s) p) =\n    -(exp (-(x \u2022 s)) * -s * ((fun x => eval x p + eval x (derivative (sumIDeriv p))) \u2218 fun y => y \u2022 s) x +\n        exp (-(x \u2022 s)) * (eval (x \u2022 s) (derivative (sumIDeriv p)) * s))"}, {"line": "simp only [Function.comp_apply]", "tactic_state": "case h.e'_9\np : Polynomial \u2102\ns : \u2102\nx : \u211d\nh\u2080 : HasDerivAt (fun y => y \u2022 s) (1 \u2022 s) x\nh\u2081 : HasDerivAt (fun x => exp (-(x \u2022 s))) (exp (-(x \u2022 s)) * -(1 \u2022 s)) x\nh\u2082 : HasDerivAt ((fun x => eval x (sumIDeriv p)) \u2218 fun y => y \u2022 s) (eval (x \u2022 s) (derivative (sumIDeriv p)) * 1 \u2022 s) x\n\u22a2 s * (exp (-(x \u2022 s)) * eval (x \u2022 s) p) =\n    -(exp (-(x \u2022 s)) * -s * (eval (x \u2022 s) p + eval (x \u2022 s) (derivative (sumIDeriv p))) +\n        exp (-(x \u2022 s)) * (eval (x \u2022 s) (derivative (sumIDeriv p)) * s))"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_not_liouvilleWith : \u2200\u1d50 x, \u2200 p > (2 : \u211d), \u00acLiouvilleWith p x := by\n  simpa only [ae_iff,not_forall,Classical.not_not,setOf_exists] using\n    volume_iUnion_setOf_liouvilleWith\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Transcendental/Liouville/Measure.lean", "context": {"open": ["scoped Filter ENNReal Topology NNReal", "Filter Set Metric MeasureTheory Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200\u1d50 (x : \u211d), \u2200 p > 2, \u00acLiouvilleWith p x"}, {"line": "simpa only [ae_iff,not_forall,Classical.not_not,setOf_exists] using\n    volume_iUnion_setOf_liouvilleWith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem volume_setOf_liouville : volume { x : \u211d | Liouville x } = 0 := by\n  simpa only [ae_iff,Classical.not_not] using ae_not_liouville\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Transcendental/Liouville/Measure.lean", "context": {"open": ["scoped Filter ENNReal Topology NNReal", "Filter Set Metric MeasureTheory Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 volume {x | Liouville x} = 0"}, {"line": "simpa only [ae_iff,Classical.not_not] using ae_not_liouville", "tactic_state": "No Goals!"}]}
{"declaration": "theorem setOf_liouville_eq_iInter_iUnion :\n    { x | Liouville x } =\n      \u22c2 n : \u2115, \u22c3 (a : \u2124) (b : \u2124) (_ : 1 < b),\n      ball ((a : \u211d) / b) (1 / (b : \u211d) ^ n) \\ {(a : \u211d) / b} := by\n  ext x\n  simp only [mem_iInter]\n  simp only [mem_iUnion]\n  simp only [Liouville]\n  simp only [mem_setOf_eq]\n  simp only [exists_prop]\n  simp only [mem_diff]\n  simp only [mem_singleton_iff]\n  simp only [mem_ball]\n  simp only [Real.dist_eq]\n  simp only [and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Transcendental/Liouville/Residual.lean", "context": {"open": ["scoped Filter", "Filter Set Metric"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 {x | Liouville x} = \u22c2 n, \u22c3 a, \u22c3 b, \u22c3 (_ : 1 < b), ball (\u2191a / \u2191b) (1 / \u2191b ^ n) \\ {\u2191a / \u2191b}"}, {"line": "ext x", "tactic_state": "case h\nx : \u211d\n\u22a2 x \u2208 {x | Liouville x} \u2194 x \u2208 \u22c2 n, \u22c3 a, \u22c3 b, \u22c3 (_ : 1 < b), ball (\u2191a / \u2191b) (1 / \u2191b ^ n) \\ {\u2191a / \u2191b}"}, {"line": "simp only [mem_iInter]", "tactic_state": "case h\nx : \u211d\n\u22a2 x \u2208 {x | Liouville x} \u2194 \u2200 (i : \u2115), x \u2208 \u22c3 a, \u22c3 b, \u22c3 (_ : 1 < b), ball (\u2191a / \u2191b) (1 / \u2191b ^ i) \\ {\u2191a / \u2191b}"}, {"line": "simp only [mem_iUnion]", "tactic_state": "case h\nx : \u211d\n\u22a2 x \u2208 {x | Liouville x} \u2194 \u2200 (i : \u2115), \u2203 i_1 i_2, \u2203 (_ : 1 < i_2), x \u2208 ball (\u2191i_1 / \u2191i_2) (1 / \u2191i_2 ^ i) \\ {\u2191i_1 / \u2191i_2}"}, {"line": "simp only [Liouville]", "tactic_state": "case h\nx : \u211d\n\u22a2 x \u2208 {x | \u2200 (n : \u2115), \u2203 a b, 1 < b \u2227 x \u2260 \u2191a / \u2191b \u2227 |x - \u2191a / \u2191b| < 1 / \u2191b ^ n} \u2194\n    \u2200 (i : \u2115), \u2203 i_1 i_2, \u2203 (_ : 1 < i_2), x \u2208 ball (\u2191i_1 / \u2191i_2) (1 / \u2191i_2 ^ i) \\ {\u2191i_1 / \u2191i_2}"}, {"line": "simp only [mem_setOf_eq]", "tactic_state": "case h\nx : \u211d\n\u22a2 (\u2200 (n : \u2115), \u2203 a b, 1 < b \u2227 x \u2260 \u2191a / \u2191b \u2227 |x - \u2191a / \u2191b| < 1 / \u2191b ^ n) \u2194\n    \u2200 (i : \u2115), \u2203 i_1 i_2, \u2203 (_ : 1 < i_2), x \u2208 ball (\u2191i_1 / \u2191i_2) (1 / \u2191i_2 ^ i) \\ {\u2191i_1 / \u2191i_2}"}, {"line": "simp only [exists_prop]", "tactic_state": "case h\nx : \u211d\n\u22a2 (\u2200 (n : \u2115), \u2203 a b, 1 < b \u2227 x \u2260 \u2191a / \u2191b \u2227 |x - \u2191a / \u2191b| < 1 / \u2191b ^ n) \u2194\n    \u2200 (i : \u2115), \u2203 i_1 i_2, 1 < i_2 \u2227 x \u2208 ball (\u2191i_1 / \u2191i_2) (1 / \u2191i_2 ^ i) \\ {\u2191i_1 / \u2191i_2}"}, {"line": "simp only [mem_diff]", "tactic_state": "case h\nx : \u211d\n\u22a2 (\u2200 (n : \u2115), \u2203 a b, 1 < b \u2227 x \u2260 \u2191a / \u2191b \u2227 |x - \u2191a / \u2191b| < 1 / \u2191b ^ n) \u2194\n    \u2200 (i : \u2115), \u2203 i_1 i_2, 1 < i_2 \u2227 x \u2208 ball (\u2191i_1 / \u2191i_2) (1 / \u2191i_2 ^ i) \u2227 x \u2209 {\u2191i_1 / \u2191i_2}"}, {"line": "simp only [mem_singleton_iff]", "tactic_state": "case h\nx : \u211d\n\u22a2 (\u2200 (n : \u2115), \u2203 a b, 1 < b \u2227 x \u2260 \u2191a / \u2191b \u2227 |x - \u2191a / \u2191b| < 1 / \u2191b ^ n) \u2194\n    \u2200 (i : \u2115), \u2203 i_1 i_2, 1 < i_2 \u2227 x \u2208 ball (\u2191i_1 / \u2191i_2) (1 / \u2191i_2 ^ i) \u2227 \u00acx = \u2191i_1 / \u2191i_2"}, {"line": "simp only [mem_ball]", "tactic_state": "case h\nx : \u211d\n\u22a2 (\u2200 (n : \u2115), \u2203 a b, 1 < b \u2227 x \u2260 \u2191a / \u2191b \u2227 |x - \u2191a / \u2191b| < 1 / \u2191b ^ n) \u2194\n    \u2200 (i : \u2115), \u2203 i_1 i_2, 1 < i_2 \u2227 dist x (\u2191i_1 / \u2191i_2) < 1 / \u2191i_2 ^ i \u2227 \u00acx = \u2191i_1 / \u2191i_2"}, {"line": "simp only [Real.dist_eq]", "tactic_state": "case h\nx : \u211d\n\u22a2 (\u2200 (n : \u2115), \u2203 a b, 1 < b \u2227 x \u2260 \u2191a / \u2191b \u2227 |x - \u2191a / \u2191b| < 1 / \u2191b ^ n) \u2194\n    \u2200 (i : \u2115), \u2203 i_1 i_2, 1 < i_2 \u2227 |x - \u2191i_1 / \u2191i_2| < 1 / \u2191i_2 ^ i \u2227 \u00acx = \u2191i_1 / \u2191i_2"}, {"line": "simp only [and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsG\u03b4.setOf_liouville : IsG\u03b4 { x | Liouville x } := by\n  rw [setOf_liouville_eq_iInter_iUnion]\n  refine .iInter fun n => IsOpen.isG\u03b4 ?_\n  refine isOpen_iUnion fun a => isOpen_iUnion fun b => isOpen_iUnion fun _hb => ?_\n  exact isOpen_ball.inter isClosed_singleton.isOpen_compl\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Transcendental/Liouville/Residual.lean", "context": {"open": ["scoped Filter", "Filter Set Metric"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 IsG\u03b4 {x | Liouville x}"}, {"line": "rw [setOf_liouville_eq_iInter_iUnion]", "tactic_state": "\u22a2 IsG\u03b4 (\u22c2 n, \u22c3 a, \u22c3 b, \u22c3 (_ : 1 < b), ball (\u2191a / \u2191b) (1 / \u2191b ^ n) \\ {\u2191a / \u2191b})"}, {"line": "refine .iInter fun n => IsOpen.isG\u03b4 ?_", "tactic_state": "n : \u2115\n\u22a2 IsOpen (\u22c3 a, \u22c3 b, \u22c3 (_ : 1 < b), ball (\u2191a / \u2191b) (1 / \u2191b ^ n) \\ {\u2191a / \u2191b})"}, {"line": "refine isOpen_iUnion fun a => isOpen_iUnion fun b => isOpen_iUnion fun _hb => ?_", "tactic_state": "n : \u2115\na b : \u2124\n_hb : 1 < b\n\u22a2 IsOpen (ball (\u2191a / \u2191b) (1 / \u2191b ^ n) \\ {\u2191a / \u2191b})"}, {"line": "exact isOpen_ball.inter isClosed_singleton.isOpen_compl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_one_le_pow_mul_dist {Z N R : Type*} [PseudoMetricSpace R] {d : N \u2192 \u211d}\n    {j : Z \u2192 N \u2192 R} {f : R \u2192 R} {\u03b1 : R} {\u03b5 M : \u211d}\n    -- denominators are positive\n    (d0 : \u2200 a : N, 1 \u2264 d a)\n    (e0 : 0 < \u03b5)\n    -- function is Lipschitz at \u03b1\n    (B : \u2200 \u2983y : R\u2984, y \u2208 closedBall \u03b1 \u03b5 \u2192 dist (f \u03b1) (f y) \u2264 dist \u03b1 y * M)\n    -- clear denominators\n    (L : \u2200 \u2983z : Z\u2984, \u2200 \u2983a : N\u2984, j z a \u2208 closedBall \u03b1 \u03b5 \u2192 1 \u2264 d a * dist (f \u03b1) (f (j z a))) :\n    \u2203 A : \u211d, 0 < A \u2227 \u2200 z : Z, \u2200 a : N, 1 \u2264 d a * (dist \u03b1 (j z a) * A) := by\n  -- A useful inequality to keep at hand\n  have me0 : 0 < max (1 / \u03b5) M := lt_max_iff.mpr (Or.inl (one_div_pos.mpr e0))\n  -- The maximum between `1 / \u03b5` and `M` works\n  refine \u27e8max (1 / \u03b5) M, me0, fun z a => ?_\u27e9\n  -- First, let's deal with the easy case in which we are far away from `\u03b1`\n  by_cases dm1 : 1 \u2264 dist \u03b1 (j z a) * max (1 / \u03b5) M\n  \u00b7 exact one_le_mul_of_one_le_of_one_le (d0 a) dm1\n  \u00b7 -- `j z a = z / (a + 1)`: we prove that this ratio is close to `\u03b1`\n    have : j z a \u2208 closedBall \u03b1 \u03b5 := by\n      refine mem_closedBall'.mp (le_trans ?_ ((one_div_le me0 e0).mpr (le_max_left _ _)))\n      exact (le_div_iff\u2080 me0).mpr (not_le.mp dm1).le\n    -- use the \"separation from `1`\" (assumption `L`) for numerators,\n    refine (L this).trans ?_\n    -- remove a common factor and use the Lipschitz assumption `B`\n    refine mul_le_mul_of_nonneg_left ((B this).trans ?_) (zero_le_one.trans (d0 a))\n    exact mul_le_mul_of_nonneg_left (le_max_right _ M) dist_nonneg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Transcendental/Liouville/Basic.lean", "context": {"open": ["Polynomial Metric Set Real RingHom", "scoped Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Z : Type u_1\nN : Type u_2\nR : Type u_3\ninst\u271d : PseudoMetricSpace R\nd : N \u2192 \u211d\nj : Z \u2192 N \u2192 R\nf : R \u2192 R\n\u03b1 : R\n\u03b5 M : \u211d\nd0 : \u2200 (a : N), 1 \u2264 d a\ne0 : 0 < \u03b5\nB : \u2200 \u2983y : R\u2984, y \u2208 closedBall \u03b1 \u03b5 \u2192 dist (f \u03b1) (f y) \u2264 dist \u03b1 y * M\nL : \u2200 \u2983z : Z\u2984 \u2983a : N\u2984, j z a \u2208 closedBall \u03b1 \u03b5 \u2192 1 \u2264 d a * dist (f \u03b1) (f (j z a))\n\u22a2 \u2203 A, 0 < A \u2227 \u2200 (z : Z) (a : N), 1 \u2264 d a * (dist \u03b1 (j z a) * A)"}, {"line": "have me0 : 0 < max (1 / \u03b5) M := lt_max_iff.mpr (Or.inl (one_div_pos.mpr e0))", "tactic_state": "Z : Type u_1\nN : Type u_2\nR : Type u_3\ninst\u271d : PseudoMetricSpace R\nd : N \u2192 \u211d\nj : Z \u2192 N \u2192 R\nf : R \u2192 R\n\u03b1 : R\n\u03b5 M : \u211d\nd0 : \u2200 (a : N), 1 \u2264 d a\ne0 : 0 < \u03b5\nB : \u2200 \u2983y : R\u2984, y \u2208 closedBall \u03b1 \u03b5 \u2192 dist (f \u03b1) (f y) \u2264 dist \u03b1 y * M\nL : \u2200 \u2983z : Z\u2984 \u2983a : N\u2984, j z a \u2208 closedBall \u03b1 \u03b5 \u2192 1 \u2264 d a * dist (f \u03b1) (f (j z a))\nme0 : 0 < max (1 / \u03b5) M\n\u22a2 \u2203 A, 0 < A \u2227 \u2200 (z : Z) (a : N), 1 \u2264 d a * (dist \u03b1 (j z a) * A)"}, {"line": "refine \u27e8max (1 / \u03b5) M, me0, fun z a => ?_\u27e9", "tactic_state": "Z : Type u_1\nN : Type u_2\nR : Type u_3\ninst\u271d : PseudoMetricSpace R\nd : N \u2192 \u211d\nj : Z \u2192 N \u2192 R\nf : R \u2192 R\n\u03b1 : R\n\u03b5 M : \u211d\nd0 : \u2200 (a : N), 1 \u2264 d a\ne0 : 0 < \u03b5\nB : \u2200 \u2983y : R\u2984, y \u2208 closedBall \u03b1 \u03b5 \u2192 dist (f \u03b1) (f y) \u2264 dist \u03b1 y * M\nL : \u2200 \u2983z : Z\u2984 \u2983a : N\u2984, j z a \u2208 closedBall \u03b1 \u03b5 \u2192 1 \u2264 d a * dist (f \u03b1) (f (j z a))\nme0 : 0 < max (1 / \u03b5) M\nz : Z\na : N\n\u22a2 1 \u2264 d a * (dist \u03b1 (j z a) * max (1 / \u03b5) M)"}, {"line": "by_cases dm1 : 1 \u2264 dist \u03b1 (j z a) * max (1 / \u03b5) M", "tactic_state": "case pos\nZ : Type u_1\nN : Type u_2\nR : Type u_3\ninst\u271d : PseudoMetricSpace R\nd : N \u2192 \u211d\nj : Z \u2192 N \u2192 R\nf : R \u2192 R\n\u03b1 : R\n\u03b5 M : \u211d\nd0 : \u2200 (a : N), 1 \u2264 d a\ne0 : 0 < \u03b5\nB : \u2200 \u2983y : R\u2984, y \u2208 closedBall \u03b1 \u03b5 \u2192 dist (f \u03b1) (f y) \u2264 dist \u03b1 y * M\nL : \u2200 \u2983z : Z\u2984 \u2983a : N\u2984, j z a \u2208 closedBall \u03b1 \u03b5 \u2192 1 \u2264 d a * dist (f \u03b1) (f (j z a))\nme0 : 0 < max (1 / \u03b5) M\nz : Z\na : N\ndm1 : 1 \u2264 sorry * max (1 / \u03b5) M\n\u22a2 1 \u2264 d a * (dist \u03b1 (j z a) * max (1 / \u03b5) M)\n---\ncase neg\nZ : Type u_1\nN : Type u_2\nR : Type u_3\ninst\u271d : PseudoMetricSpace R\nd : N \u2192 \u211d\nj : Z \u2192 N \u2192 R\nf : R \u2192 R\n\u03b1 : R\n\u03b5 M : \u211d\nd0 : \u2200 (a : N), 1 \u2264 d a\ne0 : 0 < \u03b5\nB : \u2200 \u2983y : R\u2984, y \u2208 closedBall \u03b1 \u03b5 \u2192 dist (f \u03b1) (f y) \u2264 dist \u03b1 y * M\nL : \u2200 \u2983z : Z\u2984 \u2983a : N\u2984, j z a \u2208 closedBall \u03b1 \u03b5 \u2192 1 \u2264 d a * dist (f \u03b1) (f (j z a))\nme0 : 0 < max (1 / \u03b5) M\nz : Z\na : N\ndm1 : \u00ac1 \u2264 sorry * max (1 / \u03b5) M\n\u22a2 1 \u2264 d a * (dist \u03b1 (j z a) * max (1 / \u03b5) M)"}, {"line": "\u00b7 exact one_le_mul_of_one_le_of_one_le (d0 a) dm1", "tactic_state": "case neg\nZ : Type u_1\nN : Type u_2\nR : Type u_3\ninst\u271d : PseudoMetricSpace R\nd : N \u2192 \u211d\nj : Z \u2192 N \u2192 R\nf : R \u2192 R\n\u03b1 : R\n\u03b5 M : \u211d\nd0 : \u2200 (a : N), 1 \u2264 d a\ne0 : 0 < \u03b5\nB : \u2200 \u2983y : R\u2984, y \u2208 closedBall \u03b1 \u03b5 \u2192 dist (f \u03b1) (f y) \u2264 dist \u03b1 y * M\nL : \u2200 \u2983z : Z\u2984 \u2983a : N\u2984, j z a \u2208 closedBall \u03b1 \u03b5 \u2192 1 \u2264 d a * dist (f \u03b1) (f (j z a))\nme0 : 0 < max (1 / \u03b5) M\nz : Z\na : N\ndm1 : \u00ac1 \u2264 sorry * max (1 / \u03b5) M\n\u22a2 1 \u2264 d a * (dist \u03b1 (j z a) * max (1 / \u03b5) M)"}, {"line": "\u00b7 -- `j z a = z / (a + 1)`: we prove that this ratio is close to `\u03b1`\n    have : j z a \u2208 closedBall \u03b1 \u03b5 := by\n      refine mem_closedBall'.mp (le_trans ?_ ((one_div_le me0 e0).mpr (le_max_left _ _)))\n      exact (le_div_iff\u2080 me0).mpr (not_le.mp dm1).le\n    refine (L this).trans ?_\n    refine mul_le_mul_of_nonneg_left ((B this).trans ?_) (zero_le_one.trans (d0 a))\n    exact mul_le_mul_of_nonneg_left (le_max_right _ M) dist_nonneg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem remainder_summable {m : \u211d} (hm : 1 < m) (k : \u2115) :\n    Summable fun i : \u2115 => 1 / m ^ (i + (k + 1))! := by\n  convert (summable_nat_add_iff (k + 1)).2 (LiouvilleNumber.summable hm)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Transcendental/Liouville/LiouvilleNumber.lean", "context": {"open": ["scoped Nat", "Real Finset"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u211d\nhm : 1 < m\nk : \u2115\n\u22a2 Summable fun i => 1 / m ^ (i + (k + 1)).factorial"}, {"line": "convert (summable_nat_add_iff (k + 1)).2 (LiouvilleNumber.summable hm)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_pos (h : LiouvilleWith p x) :\n    \u2203 (C : \u211d) (_h\u2080 : 0 < C),\n      \u2203\u1da0 n : \u2115 in atTop, 1 \u2264 n \u2227 \u2203 m : \u2124, x \u2260 m / n \u2227 |x - m / n| < C / n ^ p := by\n  rcases h with \u27e8C, hC\u27e9\n  refine \u27e8max C 1, zero_lt_one.trans_le <| le_max_right _ _, ?_\u27e9\n  refine ((eventually_ge_atTop 1).and_frequently hC).mono ?_\n  rintro n \u27e8hle, m, hne, hlt\u27e9\n  refine \u27e8hle, m, hne, hlt.trans_le ?_\u27e9\n  gcongr\n  apply le_max_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Transcendental/Liouville/LiouvilleWith.lean", "context": {"open": ["Filter Metric Real Set", "scoped Filter Topology"], "variables": ["{p q x : \u211d} {r : \u211a} {m : \u2124} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p x : \u211d\nh : LiouvilleWith p x\n\u22a2 \u2203 C, \u2203 (_ : 0 < C), \u2203\u1da0 (n : \u2115) in atTop, 1 \u2264 n \u2227 \u2203 m, x \u2260 \u2191m / \u2191n \u2227 |x - \u2191m / \u2191n| < C / \u2191n ^ p"}, {"line": "rcases h with \u27e8C, hC\u27e9", "tactic_state": "case intro\np x C : \u211d\nhC : \u2203\u1da0 (n : \u2115) in atTop, \u2203 m, x \u2260 \u2191m / \u2191n \u2227 |x - \u2191m / \u2191n| < C / \u2191n ^ p\n\u22a2 \u2203 C, \u2203 (_ : 0 < C), \u2203\u1da0 (n : \u2115) in atTop, 1 \u2264 n \u2227 \u2203 m, x \u2260 \u2191m / \u2191n \u2227 |x - \u2191m / \u2191n| < C / \u2191n ^ p"}, {"line": "refine \u27e8max C 1, zero_lt_one.trans_le <| le_max_right _ _, ?_\u27e9", "tactic_state": "case intro\np x C : \u211d\nhC : \u2203\u1da0 (n : \u2115) in atTop, \u2203 m, x \u2260 \u2191m / \u2191n \u2227 |x - \u2191m / \u2191n| < C / \u2191n ^ p\n\u22a2 \u2203\u1da0 (n : \u2115) in atTop, 1 \u2264 n \u2227 \u2203 m, x \u2260 \u2191m / \u2191n \u2227 |x - \u2191m / \u2191n| < max C 1 / \u2191n ^ p"}, {"line": "refine ((eventually_ge_atTop 1).and_frequently hC).mono ?_", "tactic_state": "case intro\np x C : \u211d\nhC : \u2203\u1da0 (n : \u2115) in atTop, \u2203 m, x \u2260 \u2191m / \u2191n \u2227 |x - \u2191m / \u2191n| < C / \u2191n ^ p\n\u22a2 \u2200 (x_1 : \u2115),\n    (1 \u2264 x_1 \u2227 \u2203 m, x \u2260 \u2191m / \u2191x_1 \u2227 |x - \u2191m / \u2191x_1| < C / \u2191x_1 ^ p) \u2192\n      1 \u2264 x_1 \u2227 \u2203 m, x \u2260 \u2191m / \u2191x_1 \u2227 |x - \u2191m / \u2191x_1| < max C 1 / \u2191x_1 ^ p"}, {"line": "rintro n \u27e8hle, m, hne, hlt\u27e9", "tactic_state": "case intro.intro.intro.intro\np x C : \u211d\nhC : \u2203\u1da0 (n : \u2115) in atTop, \u2203 m, x \u2260 \u2191m / \u2191n \u2227 |x - \u2191m / \u2191n| < C / \u2191n ^ p\nn : \u2115\nhle : 1 \u2264 n\nm : \u2124\nhne : x \u2260 \u2191m / \u2191n\nhlt : |x - \u2191m / \u2191n| < C / \u2191n ^ p\n\u22a2 1 \u2264 n \u2227 \u2203 m, x \u2260 \u2191m / \u2191n \u2227 |x - \u2191m / \u2191n| < max C 1 / \u2191n ^ p"}, {"line": "refine \u27e8hle, m, hne, hlt.trans_le ?_\u27e9", "tactic_state": "case intro.intro.intro.intro\np x C : \u211d\nhC : \u2203\u1da0 (n : \u2115) in atTop, \u2203 m, x \u2260 \u2191m / \u2191n \u2227 |x - \u2191m / \u2191n| < C / \u2191n ^ p\nn : \u2115\nhle : 1 \u2264 n\nm : \u2124\nhne : x \u2260 \u2191m / \u2191n\nhlt : |x - \u2191m / \u2191n| < C / \u2191n ^ p\n\u22a2 C / \u2191n ^ p \u2264 max C 1 / \u2191n ^ p"}, {"line": "gcongr", "tactic_state": "case intro.intro.intro.intro.hab\np x C : \u211d\nhC : \u2203\u1da0 (n : \u2115) in atTop, \u2203 m, x \u2260 \u2191m / \u2191n \u2227 |x - \u2191m / \u2191n| < C / \u2191n ^ p\nn : \u2115\nhle : 1 \u2264 n\nm : \u2124\nhne : x \u2260 \u2191m / \u2191n\nhlt : |x - \u2191m / \u2191n| < C / \u2191n ^ p\n\u22a2 C \u2264 max C 1"}, {"line": "apply le_max_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rat_sub_iff : LiouvilleWith p (r - x) \u2194 LiouvilleWith p x := by simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Transcendental/Liouville/LiouvilleWith.lean", "context": {"open": ["Filter Metric Real Set", "scoped Filter Topology"], "variables": ["{p q x : \u211d} {r : \u211a} {m : \u2124} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p x : \u211d\nr : \u211a\n\u22a2 LiouvilleWith p (\u2191r - x) \u2194 LiouvilleWith p x"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem int_sub_iff : LiouvilleWith p (m - x) \u2194 LiouvilleWith p x := by simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Transcendental/Liouville/LiouvilleWith.lean", "context": {"open": ["Filter Metric Real Set", "scoped Filter Topology"], "variables": ["{p q x : \u211d} {r : \u211a} {m : \u2124} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p x : \u211d\nm : \u2124\n\u22a2 LiouvilleWith p (\u2191m - x) \u2194 LiouvilleWith p x"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nat_sub_iff : LiouvilleWith p (n - x) \u2194 LiouvilleWith p x := by simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Transcendental/Liouville/LiouvilleWith.lean", "context": {"open": ["Filter Metric Real Set", "scoped Filter Topology"], "variables": ["{p q x : \u211d} {r : \u211a} {m : \u2124} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p x : \u211d\nn : \u2115\n\u22a2 LiouvilleWith p (\u2191n - x) \u2194 LiouvilleWith p x"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem forall_liouvilleWith_iff {x : \u211d} : (\u2200 p, LiouvilleWith p x) \u2194 Liouville x := by\n  refine \u27e8fun H n => ?_, Liouville.liouvilleWith\u27e9\n  rcases ((eventually_gt_atTop 1).and_frequently\n    ((H (n + 1)).frequently_lt_rpow_neg (lt_add_one (n : \u211d)))).exists\n    with \u27e8b, hb, a, hne, hlt\u27e9\n  exact \u27e8a, b, mod_cast hb, hne, by simpa [rpow_neg] using hlt\u27e9", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Transcendental/Liouville/LiouvilleWith.lean", "context": {"open": ["Filter Metric Real Set", "scoped Filter Topology"], "variables": ["{p q x : \u211d} {r : \u211a} {m : \u2124} {n : \u2115}", "{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 (\u2200 (p : \u211d), LiouvilleWith p x) \u2194 Liouville x"}, {"line": "refine \u27e8fun H n => ?_, Liouville.liouvilleWith\u27e9", "tactic_state": "x : \u211d\nH : \u2200 (p : \u211d), LiouvilleWith p x\nn : \u2115\n\u22a2 \u2203 a b, 1 < b \u2227 x \u2260 \u2191a / \u2191b \u2227 |x - \u2191a / \u2191b| < 1 / \u2191b ^ n"}, {"line": "rcases ((eventually_gt_atTop 1).and_frequently\n    ((H (n + 1)).frequently_lt_rpow_neg (lt_add_one (n : \u211d)))).exists\n    with \u27e8b, hb, a, hne, hlt\u27e9", "tactic_state": "case intro.intro.intro.intro\nx : \u211d\nH : \u2200 (p : \u211d), LiouvilleWith p x\nn b : \u2115\nhb : 1 < b\na : \u2124\nhne : x \u2260 \u2191a / \u2191b\nhlt : |x - \u2191a / \u2191b| < \u2191b ^ (-\u2191n)\n\u22a2 \u2203 a b, 1 < b \u2227 x \u2260 \u2191a / \u2191b \u2227 |x - \u2191a / \u2191b| < 1 / \u2191b ^ n"}, {"line": "exact \u27e8a, b, mod_cast hb, hne, by simpa [rpow_neg] using hlt\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normSq_le_normSq_of_re_le_of_im_le {x y : \u2102} (hre : |x.re| \u2264 |y.re|)\n    (him : |x.im| \u2264 |y.im|) : Complex.normSq x \u2264 Complex.normSq y := by\n  rw [normSq_apply]\n  rw [normSq_apply]\n  rw [\u2190 _root_.abs_mul_self]\n  rw [_root_.abs_mul]\n  rw [\u2190       _root_.abs_mul_self y.re]\n  rw [_root_.abs_mul y.re]\n  rw [\u2190 _root_.abs_mul_self x.im]\n  rw [_root_.abs_mul x.im]\n  rw [\u2190 _root_.abs_mul_self y.im]\n  rw [_root_.abs_mul y.im]\n  exact\n      add_le_add (mul_self_le_mul_self (abs_nonneg _) hre) (mul_self_le_mul_self (abs_nonneg _) him)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean", "context": {"open": ["Zsqrtd Complex", "scoped ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\nhre : |x.re| \u2264 |y.re|\nhim : |x.im| \u2264 |y.im|\n\u22a2 normSq x \u2264 normSq y"}, {"line": "rw [normSq_apply]", "tactic_state": "x y : \u2102\nhre : |x.re| \u2264 |y.re|\nhim : |x.im| \u2264 |y.im|\n\u22a2 x.re * x.re + x.im * x.im \u2264 normSq y"}, {"line": "rw [normSq_apply]", "tactic_state": "x y : \u2102\nhre : |x.re| \u2264 |y.re|\nhim : |x.im| \u2264 |y.im|\n\u22a2 x.re * x.re + x.im * x.im \u2264 y.re * y.re + y.im * y.im"}, {"line": "rw [\u2190 _root_.abs_mul_self]", "tactic_state": "x y : \u2102\nhre : |x.re| \u2264 |y.re|\nhim : |x.im| \u2264 |y.im|\n\u22a2 |x.re * x.re| + x.im * x.im \u2264 y.re * y.re + y.im * y.im"}, {"line": "rw [_root_.abs_mul]", "tactic_state": "x y : \u2102\nhre : |x.re| \u2264 |y.re|\nhim : |x.im| \u2264 |y.im|\n\u22a2 |x.re| * |x.re| + x.im * x.im \u2264 y.re * y.re + y.im * y.im"}, {"line": "rw [\u2190       _root_.abs_mul_self y.re]", "tactic_state": "x y : \u2102\nhre : |x.re| \u2264 |y.re|\nhim : |x.im| \u2264 |y.im|\n\u22a2 |x.re| * |x.re| + x.im * x.im \u2264 |y.re * y.re| + y.im * y.im"}, {"line": "rw [_root_.abs_mul y.re]", "tactic_state": "x y : \u2102\nhre : |x.re| \u2264 |y.re|\nhim : |x.im| \u2264 |y.im|\n\u22a2 |x.re| * |x.re| + x.im * x.im \u2264 |y.re| * |y.re| + y.im * y.im"}, {"line": "rw [\u2190 _root_.abs_mul_self x.im]", "tactic_state": "x y : \u2102\nhre : |x.re| \u2264 |y.re|\nhim : |x.im| \u2264 |y.im|\n\u22a2 |x.re| * |x.re| + |x.im * x.im| \u2264 |y.re| * |y.re| + y.im * y.im"}, {"line": "rw [_root_.abs_mul x.im]", "tactic_state": "x y : \u2102\nhre : |x.re| \u2264 |y.re|\nhim : |x.im| \u2264 |y.im|\n\u22a2 |x.re| * |x.re| + |x.im| * |x.im| \u2264 |y.re| * |y.re| + y.im * y.im"}, {"line": "rw [\u2190 _root_.abs_mul_self y.im]", "tactic_state": "x y : \u2102\nhre : |x.re| \u2264 |y.re|\nhim : |x.im| \u2264 |y.im|\n\u22a2 |x.re| * |x.re| + |x.im| * |x.im| \u2264 |y.re| * |y.re| + |y.im * y.im|"}, {"line": "rw [_root_.abs_mul y.im]", "tactic_state": "x y : \u2102\nhre : |x.re| \u2264 |y.re|\nhim : |x.im| \u2264 |y.im|\n\u22a2 |x.re| * |x.re| + |x.im| * |x.im| \u2264 |y.re| * |y.re| + |y.im| * |y.im|"}, {"line": "exact\n      add_le_add (mul_self_le_mul_self (abs_nonneg _) hre) (mul_self_le_mul_self (abs_nonneg _) him)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intCast_re (n : \u2124) : (n : \u2124\u221ad).re = n := by cases n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": [], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d n : \u2124\n\u22a2 (\u2191n).re = n"}, {"line": "cases n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intCast_im (n : \u2124) : (n : \u2124\u221ad).im = 0 := by cases n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": [], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d n : \u2124\n\u22a2 (\u2191n).im = 0"}, {"line": "cases n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intCast_val (n : \u2124) : (n : \u2124\u221ad) = \u27e8n, 0\u27e9 := by ext <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": [], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d n : \u2124\n\u22a2 \u2191n = { re := n, im := 0 }"}, {"line": "ext <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofInt_eq_intCast (n : \u2124) : (ofInt n : \u2124\u221ad) = n := by ext <;> simp [ofInt_re, ofInt_im]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": [], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d : \u2124\nx\u271d : Sort u_1\nofInt : x\u271d\nn : \u2124\n\u22a2 sorry = \u2191n"}, {"line": "ext <;> simp [ofInt_re, ofInt_im]", "tactic_state": "case re\nd : \u2124\nx\u271d : Sort u_1\nofInt : x\u271d\nn : \u2124\n\u22a2 (sorry ()).re = n\n---\ncase im\nd : \u2124\nx\u271d : Sort u_1\nofInt : x\u271d\nn : \u2124\n\u22a2 (sorry ()).im = 0"}]}
{"declaration": "theorem nsmul_val (n : \u2115) (x y : \u2124) : (n : \u2124\u221ad) * \u27e8x, y\u27e9 = \u27e8n * x, n * y\u27e9 := by ext <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": [], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d : \u2124\nn : \u2115\nx y : \u2124\n\u22a2 \u2191n * { re := x, im := y } = { re := \u2191n * x, im := \u2191n * y }"}, {"line": "ext <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_val (n x y : \u2124) : (n : \u2124\u221ad) * \u27e8x, y\u27e9 = \u27e8n * x, n * y\u27e9 := by ext <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": [], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d n x y : \u2124\n\u22a2 \u2191n * { re := x, im := y } = { re := n * x, im := n * y }"}, {"line": "ext <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_re (a : \u2124) (b : \u2124\u221ad) : (\u2191a * b).re = a * b.re := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": [], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d a : \u2124\nb : \u2124\u221ad\n\u22a2 (\u2191a * b).re = a * b.re"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_im (a : \u2124) (b : \u2124\u221ad) : (\u2191a * b).im = a * b.im := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": [], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d a : \u2124\nb : \u2124\u221ad\n\u22a2 (\u2191a * b).im = a * b.im"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smuld_val (n x y : \u2124) : sqrtd * (n : \u2124\u221ad) * \u27e8x, y\u27e9 = \u27e8d * n * y, n * x\u27e9 := by ext <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": [], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d : \u2124\nsqrtd : \u2124\u221ad\nn x y : \u2124\n\u22a2 sqrtd * \u2191n * { re := x, im := y } = { re := d * n * y, im := n * x }"}, {"line": "ext <;> simp", "tactic_state": "case re\nd : \u2124\nsqrtd : \u2124\u221ad\nn x y : \u2124\n\u22a2 sqrtd.re * n * x + d * (sqrtd.im * n) * y = d * n * y\n---\ncase im\nd : \u2124\nsqrtd : \u2124\u221ad\nn x y : \u2124\n\u22a2 sqrtd.re * n * y + sqrtd.im * n * x = n * x"}]}
{"declaration": "theorem decompose {x y : \u2124} : (\u27e8x, y\u27e9 : \u2124\u221ad) = x + sqrtd (d := d) * y := by ext <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": [], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d : \u2124\nx\u271d : Sort u_1\nsqrtd : x\u271d\nx y : \u2124\n\u22a2 { re := x, im := y } = \u2191x + sorry * \u2191y"}, {"line": "ext <;> simp", "tactic_state": "case re\nd : \u2124\nx\u271d : Sort u_1\nsqrtd : x\u271d\nx y : \u2124\n\u22a2 (sorry ()).re = 0 \u2228 y = 0\n---\ncase im\nd : \u2124\nx\u271d : Sort u_1\nsqrtd : x\u271d\nx y : \u2124\n\u22a2 y = (sorry ()).im * y"}]}
{"declaration": "theorem mul_star {x y : \u2124} : (\u27e8x, y\u27e9 * star \u27e8x, y\u27e9 : \u2124\u221ad) = x * x - d * y * y := by\n  ext <;> simp [sub_eq_add_neg, mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": [], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d x y : \u2124\n\u22a2 { re := x, im := y } * star { re := x, im := y } = \u2191x * \u2191x - \u2191d * \u2191y * \u2191y"}, {"line": "ext <;> simp [sub_eq_add_neg, mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_coprime_of_gcd_pos {a : \u2124\u221ad} (hgcd : 0 < Int.gcd a.re a.im) :\n    \u2203 b : \u2124\u221ad, a = ((Int.gcd a.re a.im : \u2124) : \u2124\u221ad) * b \u2227 IsCoprime b.re b.im := by\n  obtain \u27e8re, im, H1, Hre, Him\u27e9 := Int.exists_gcd_one hgcd\n  rw [mul_comm] at Hre Him\n  refine \u27e8\u27e8re, im\u27e9, ?_, ?_\u27e9\n  \u00b7 rw [smul_val, \u2190 Hre, \u2190 Him]\n  \u00b7 rw [Int.isCoprime_iff_gcd_eq_one, H1]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": [], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d : \u2124\na : \u2124\u221ad\nhgcd : 0 < a.re.gcd a.im\n\u22a2 \u2203 b, a = \u2191\u2191(a.re.gcd a.im) * b \u2227 IsCoprime b.re b.im"}, {"line": "obtain \u27e8re, im, H1, Hre, Him\u27e9 := Int.exists_gcd_one hgcd", "tactic_state": "case intro.intro.intro.intro\nd : \u2124\na : \u2124\u221ad\nhgcd : 0 < a.re.gcd a.im\nre im : \u2124\nH1 : re.gcd im = 1\nHre : a.re = re * \u2191(a.re.gcd a.im)\nHim : a.im = im * \u2191(a.re.gcd a.im)\n\u22a2 \u2203 b, a = \u2191\u2191(a.re.gcd a.im) * b \u2227 IsCoprime b.re b.im"}, {"line": "rw [mul_comm] at Hre Him", "tactic_state": "case intro.intro.intro.intro\nd : \u2124\na : \u2124\u221ad\nhgcd : 0 < a.re.gcd a.im\nre im : \u2124\nH1 : re.gcd im = 1\nHre : a.re = \u2191(a.re.gcd a.im) * re\nHim : a.im = \u2191(a.re.gcd a.im) * im\n\u22a2 \u2203 b, a = \u2191\u2191(a.re.gcd a.im) * b \u2227 IsCoprime b.re b.im"}, {"line": "refine \u27e8\u27e8re, im\u27e9, ?_, ?_\u27e9", "tactic_state": "case intro.intro.intro.intro.refine_1\nd : \u2124\na : \u2124\u221ad\nhgcd : 0 < a.re.gcd a.im\nre im : \u2124\nH1 : re.gcd im = 1\nHre : a.re = \u2191(a.re.gcd a.im) * re\nHim : a.im = \u2191(a.re.gcd a.im) * im\n\u22a2 a = \u2191\u2191(a.re.gcd a.im) * { re := re, im := im }\n---\ncase intro.intro.intro.intro.refine_2\nd : \u2124\na : \u2124\u221ad\nhgcd : 0 < a.re.gcd a.im\nre im : \u2124\nH1 : re.gcd im = 1\nHre : a.re = \u2191(a.re.gcd a.im) * re\nHim : a.im = \u2191(a.re.gcd a.im) * im\n\u22a2 IsCoprime { re := re, im := im }.re { re := re, im := im }.im"}, {"line": "\u00b7 rw [smul_val, \u2190 Hre, \u2190 Him]", "tactic_state": "case intro.intro.intro.intro.refine_2\nd : \u2124\na : \u2124\u221ad\nhgcd : 0 < a.re.gcd a.im\nre im : \u2124\nH1 : re.gcd im = 1\nHre : a.re = \u2191(a.re.gcd a.im) * re\nHim : a.im = \u2191(a.re.gcd a.im) * im\n\u22a2 IsCoprime { re := re, im := im }.re { re := re, im := im }.im"}, {"line": "\u00b7 rw [Int.isCoprime_iff_gcd_eq_one, H1]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sqLe_mul {d x y z w : \u2115} :\n    (SqLe x 1 y d \u2192 SqLe z 1 w d \u2192 SqLe (x * w + y * z) d (x * z + d * y * w) 1) \u2227\n      (SqLe x 1 y d \u2192 SqLe w d z 1 \u2192 SqLe (x * z + d * y * w) 1 (x * w + y * z) d) \u2227\n        (SqLe y d x 1 \u2192 SqLe z 1 w d \u2192 SqLe (x * z + d * y * w) 1 (x * w + y * z) d) \u2227\n          (SqLe y d x 1 \u2192 SqLe w d z 1 \u2192 SqLe (x * w + y * z) d (x * z + d * y * w) 1) := by\n  refine \u27e8?_, ?_, ?_, ?_\u27e9 <;>\n    \u00b7 intro xy zw\n      have :=\n        Int.mul_nonneg (sub_nonneg_of_le (Int.ofNat_le_ofNat_of_le xy))\n          (sub_nonneg_of_le (Int.ofNat_le_ofNat_of_le zw))\n      refine Int.le_of_ofNat_le_ofNat (le_of_sub_nonneg ?_)\n      convert this using 1\n      simp only [one_mul]\n      simp only [Int.natCast_add]\n      simp only [Int.natCast_mul]\n      ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": [], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nSqLe : x\u271d\nd x y z w : \u2115\n\u22a2 (sorry \u2192 sorry \u2192 sorry) \u2227 (sorry \u2192 sorry \u2192 sorry) \u2227 (sorry \u2192 sorry \u2192 sorry) \u2227 (sorry \u2192 sorry \u2192 sorry)"}, {"line": "refine \u27e8?_, ?_, ?_, ?_\u27e9 <;>\n    \u00b7 intro xy zw\n      have :=\n        Int.mul_nonneg (sub_nonneg_of_le (Int.ofNat_le_ofNat_of_le xy))\n          (sub_nonneg_of_le (Int.ofNat_le_ofNat_of_le zw))\n      refine Int.le_of_ofNat_le_ofNat (le_of_sub_nonneg ?_)\n      convert this using 1\n      simp only [one_mul]\n      simp only [Int.natCast_add]\n      simp only [Int.natCast_mul]\n      ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonnegg_comm {c d : \u2115} {x y : \u2124} : Nonnegg c d x y = Nonnegg d c y x := by\n  cases x <;> cases y <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": ["Int in"], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nNonnegg : x\u271d\nc d : \u2115\nx y : \u2124\n\u22a2 sorry = sorry"}, {"line": "cases x <;> cases y <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_zero : norm (0 : \u2124\u221ad) = 0 := by simp [norm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": ["Int in", "Int in"], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d : \u2124\n\u22a2 sorry = 0"}, {"line": "simp [norm]", "tactic_state": "d : \u2124\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem norm_one : norm (1 : \u2124\u221ad) = 1 := by simp [norm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": ["Int in", "Int in"], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d : \u2124\n\u22a2 sorry = 1"}, {"line": "simp [norm]", "tactic_state": "d : \u2124\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem norm_intCast (n : \u2124) : norm (n : \u2124\u221ad) = n * n := by simp [norm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": ["Int in", "Int in"], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d n : \u2124\n\u22a2 sorry = n * n"}, {"line": "simp [norm]", "tactic_state": "d n : \u2124\n\u22a2 sorry () = n * n"}]}
{"declaration": "theorem norm_eq_mul_conj (n : \u2124\u221ad) : (norm n : \u2124\u221ad) = n * star n := by\n  ext <;> simp [norm, star, mul_comm, sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": ["Int in", "Int in"], "variables": ["{d : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d : \u2124\nn : \u2124\u221ad\n\u22a2 sorry = n * star n"}, {"line": "ext <;> simp [norm, star, mul_comm, sub_eq_add_neg]", "tactic_state": "case re\nd : \u2124\nn : \u2124\u221ad\n\u22a2 (sorry ()).re = n.re * n.re + -(n.im * (d * n.im))\n---\ncase im\nd : \u2124\nn : \u2124\u221ad\n\u22a2 (sorry ()).im = 0"}]}
{"declaration": "theorem divides_sq_eq_zero_z {x y : \u2124} (h : x * x = d * y * y) : x = 0 \u2227 y = 0 := by\n  rw [mul_assoc] at h\n  rw [\u2190 Int.natAbs_mul_self] at h\n  rw [\u2190 Int.natAbs_mul_self] at h\n  rw [\u2190 Int.natCast_mul] at h\n  rw [\u2190 mul_assoc] at h\n  exact\n    let \u27e8h1, h2\u27e9 := divides_sq_eq_zero (Int.ofNat.inj h)\n    \u27e8Int.natAbs_eq_zero.mp h1, Int.natAbs_eq_zero.mp h2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/NumberTheory/Zsqrtd/Basic.lean", "context": {"open": ["Int in", "Int in", "Int in", "Int in", "Int in", "Int in"], "variables": ["{d : \u2124}", "{d : \u2115}", "[dnsq : Nonsquare d]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d : \u2115\nx y : \u2124\nh : x * x = \u2191d * y * y\n\u22a2 x = 0 \u2227 y = 0"}, {"line": "rw [mul_assoc] at h", "tactic_state": "d : \u2115\nx y : \u2124\nh : x * x = \u2191d * (y * y)\n\u22a2 x = 0 \u2227 y = 0"}, {"line": "rw [\u2190 Int.natAbs_mul_self] at h", "tactic_state": "d : \u2115\nx y : \u2124\nh : \u2191(x.natAbs * x.natAbs) = \u2191d * (y * y)\n\u22a2 x = 0 \u2227 y = 0"}, {"line": "rw [\u2190 Int.natAbs_mul_self] at h", "tactic_state": "d : \u2115\nx y : \u2124\nh : \u2191(x.natAbs * x.natAbs) = \u2191d * \u2191(y.natAbs * y.natAbs)\n\u22a2 x = 0 \u2227 y = 0"}, {"line": "rw [\u2190 Int.natCast_mul] at h", "tactic_state": "d : \u2115\nx y : \u2124\nh : \u2191(x.natAbs * x.natAbs) = \u2191(d * (y.natAbs * y.natAbs))\n\u22a2 x = 0 \u2227 y = 0"}, {"line": "rw [\u2190 mul_assoc] at h", "tactic_state": "d : \u2115\nx y : \u2124\nh : \u2191(x.natAbs * x.natAbs) = \u2191(d * y.natAbs * y.natAbs)\n\u22a2 x = 0 \u2227 y = 0"}, {"line": "exact\n    let \u27e8h1, h2\u27e9 := divides_sq_eq_zero (Int.ofNat.inj h)\n    \u27e8Int.natAbs_eq_zero.mp h1, Int.natAbs_eq_zero.mp h2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_supIrred : \u00acSupIrred a \u2194 IsMin a \u2228 \u2203 b c, b \u2294 c = a \u2227 b < a \u2227 c < a := by\n  rw [SupIrred]\n  rw [not_and_or]\n  push_neg\n  rw [exists\u2082_congr]\n  simp +contextual [@eq_comm _ _ a]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Irreducible.lean", "context": {"open": ["Finset OrderDual"], "variables": ["{\u03b9 \u03b1 : Type*}", "[SemilatticeSup \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : SemilatticeSup \u03b1\na : \u03b1\n\u22a2 \u00acSupIrred a \u2194 IsMin a \u2228 \u2203 b c, b \u2294 c = a \u2227 b < a \u2227 c < a"}, {"line": "rw [SupIrred]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : SemilatticeSup \u03b1\na : \u03b1\n\u22a2 \u00ac(\u00acIsMin a \u2227 \u2200 \u2983b c : \u03b1\u2984, b \u2294 c = a \u2192 b = a \u2228 c = a) \u2194 IsMin a \u2228 \u2203 b c, b \u2294 c = a \u2227 b < a \u2227 c < a"}, {"line": "rw [not_and_or]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : SemilatticeSup \u03b1\na : \u03b1\n\u22a2 (\u00ac\u00acIsMin a \u2228 \u00ac\u2200 \u2983b c : \u03b1\u2984, b \u2294 c = a \u2192 b = a \u2228 c = a) \u2194 IsMin a \u2228 \u2203 b c, b \u2294 c = a \u2227 b < a \u2227 c < a"}, {"line": "push_neg", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : SemilatticeSup \u03b1\na : \u03b1\n\u22a2 (IsMin a \u2228 \u2203 b c, b \u2294 c = a \u2227 b \u2260 a \u2227 c \u2260 a) \u2194 IsMin a \u2228 \u2203 b c, b \u2294 c = a \u2227 b < a \u2227 c < a"}, {"line": "rw [exists\u2082_congr]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : SemilatticeSup \u03b1\na : \u03b1\n\u22a2 \u2200 (a_1 b : \u03b1), a_1 \u2294 b = a \u2227 a_1 \u2260 a \u2227 b \u2260 a \u2194 a_1 \u2294 b = a \u2227 a_1 < a \u2227 b < a"}, {"line": "simp +contextual [@eq_comm _ _ a]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_iInf (f : \u03b9 \u2192 BooleanSubalgebra \u03b1) : \u2a05 i, f i = \u22c2 i, (f i : Set \u03b1) := by simp [iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanSubalgebra.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 \u03b3 : Type*}", "(\u03b1) in", "[BooleanAlgebra \u03b1] [BooleanAlgebra \u03b2] [BooleanAlgebra \u03b3] {L M : BooleanSubalgebra \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 sorry\n\u22a2 sorry = \u22c2 i, sorry"}, {"line": "simp [iInf]", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 sorry\n\u22a2 sorry () = \u22c2 i, sorry ()"}]}
{"declaration": "lemma le_prod_iff {M : Sublattice \u03b2} {N : Sublattice (\u03b1 \u00d7 \u03b2)} :\n    N \u2264 L.prod M \u2194 N \u2264 comap LatticeHom.fst L \u2227 N \u2264 comap LatticeHom.snd M := by\n  simp [SetLike.le_def, forall_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Sublattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b9 : Sort*} (\u03b1 \u03b2 \u03b3 : Type*) [Lattice \u03b1] [Lattice \u03b2] [Lattice \u03b3]", "{\u03b1 \u03b2 \u03b3}", "{L M : Sublattice \u03b1} {f : LatticeHom \u03b1 \u03b2} {s t : Set \u03b1} {a b : \u03b1}", "{L M : Sublattice \u03b1} {f : LatticeHom \u03b1 \u03b2} {s t : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : Lattice \u03b2\nL : Sublattice \u03b1\nx\u271d : Sort u_5\ncomap : x\u271d\nM : Sublattice \u03b2\nN : Sublattice (\u03b1 \u00d7 \u03b2)\n\u22a2 N \u2264 L.prod M \u2194 N \u2264 sorry \u2227 N \u2264 sorry"}, {"line": "simp [SetLike.le_def, forall_and]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : Lattice \u03b2\nL : Sublattice \u03b1\nx\u271d : Sort u_5\ncomap : x\u271d\nM : Sublattice \u03b2\nN : Sublattice (\u03b1 \u00d7 \u03b2)\n\u22a2 ((\u2200 (a : \u03b1) (b : \u03b2), (a, b) \u2208 N \u2192 a \u2208 L) \u2227 \u2200 (a : \u03b1) (b : \u03b2), (a, b) \u2208 N \u2192 b \u2208 M) \u2194\n    \u2200 (a : \u03b1) (b : \u03b2), (a, b) \u2208 N \u2192 (a, b) \u2208 sorry ()"}]}
{"declaration": "theorem not_isMin_iff : \u00acIsMin a \u2194 \u2203 b, b < a := by\n  simp [lt_iff_le_not_le, IsMin, not_forall, exists_prop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Max.lean", "context": {"open": ["OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}", "[LE \u03b1] {a : \u03b1}", "[Preorder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 \u00acIsMin a \u2194 \u2203 b, b < a"}, {"line": "simp [lt_iff_le_not_le, IsMin, not_forall, exists_prop]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 (\u2203 x \u2264 a, \u00aca \u2264 x) \u2194 \u2203 b \u2264 a, \u00aca \u2264 b"}]}
{"declaration": "theorem not_isMax_iff : \u00acIsMax a \u2194 \u2203 b, a < b := by\n  simp [lt_iff_le_not_le, IsMax, not_forall, exists_prop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Max.lean", "context": {"open": ["OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}", "[LE \u03b1] {a : \u03b1}", "[Preorder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 \u00acIsMax a \u2194 \u2203 b, a < b"}, {"line": "simp [lt_iff_le_not_le, IsMax, not_forall, exists_prop]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 (\u2203 x, a \u2264 x \u2227 \u00acx \u2264 a) \u2194 \u2203 b, a \u2264 b \u2227 \u00acb \u2264 a"}]}
{"declaration": "lemma supClosed_range [FunLike F \u03b1 \u03b2] [SupHomClass F \u03b1 \u03b2] (f : F) : SupClosed (Set.range f) := by\n  simpa using supClosed_univ.image f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SupClosed.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {F \u03b1 \u03b2 : Type*}", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2]", "{\u03b9 : Sort*} {S : Set (Set \u03b1)} {f : \u03b9 \u2192 Set \u03b1} {s t : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b3 : SemilatticeSup \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : SupHomClass F \u03b1 \u03b2\nf : F\n\u22a2 SupClosed (range \u21d1f)"}, {"line": "simpa using supClosed_univ.image f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma SupClosed.insert_upperBounds {s : Set \u03b1} {a : \u03b1} (hs : SupClosed s) (ha : a \u2208 upperBounds s) :\n    SupClosed (insert a s) := by\n  rw [SupClosed]\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SupClosed.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {F \u03b1 \u03b2 : Type*}", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2]", "{\u03b9 : Sort*} {S : Set (Set \u03b1)} {f : \u03b9 \u2192 Set \u03b1} {s t : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : SemilatticeSup \u03b1\ns : Set \u03b1\na : \u03b1\nhs : SupClosed s\nha : a \u2208 upperBounds s\n\u22a2 SupClosed (insert a s)"}, {"line": "rw [SupClosed]", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : SemilatticeSup \u03b1\ns : Set \u03b1\na : \u03b1\nhs : SupClosed s\nha : a \u2208 upperBounds s\n\u22a2 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 insert a s \u2192 \u2200 \u2983b : \u03b1\u2984, b \u2208 insert a s \u2192 a_1 \u2294 b \u2208 insert a s"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma SupClosed.insert_lowerBounds {s : Set \u03b1} {a : \u03b1} (h : SupClosed s) (ha : a \u2208 lowerBounds s) :\n    SupClosed (insert a s) := by\n  rw [SupClosed]\n  have ha' : \u2200 b \u2208 s, a \u2264 b := fun _ a \u21a6 ha a\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SupClosed.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {F \u03b1 \u03b2 : Type*}", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2]", "{\u03b9 : Sort*} {S : Set (Set \u03b1)} {f : \u03b9 \u2192 Set \u03b1} {s t : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : SemilatticeSup \u03b1\ns : Set \u03b1\na : \u03b1\nh : SupClosed s\nha : a \u2208 lowerBounds s\n\u22a2 SupClosed (insert a s)"}, {"line": "rw [SupClosed]", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : SemilatticeSup \u03b1\ns : Set \u03b1\na : \u03b1\nh : SupClosed s\nha : a \u2208 lowerBounds s\n\u22a2 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 insert a s \u2192 \u2200 \u2983b : \u03b1\u2984, b \u2208 insert a s \u2192 a_1 \u2294 b \u2208 insert a s"}, {"line": "have ha' : \u2200 b \u2208 s, a \u2264 b := fun _ a \u21a6 ha a", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : SemilatticeSup \u03b1\ns : Set \u03b1\na : \u03b1\nh : SupClosed s\nha : a \u2208 lowerBounds s\nha' : (b : \u03b1) \u2192 b \u2208 s \u2192 sorry\n\u22a2 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 insert a s \u2192 \u2200 \u2983b : \u03b1\u2984, b \u2208 insert a s \u2192 a_1 \u2294 b \u2208 insert a s"}, {"line": "aesop", "tactic_state": "case inl.inr\n\u03b1 : Type u_3\ninst : SemilatticeSup \u03b1\ns : Set \u03b1\nh : SupClosed s\nha' : (b : \u03b1) \u2192 b \u2208 s \u2192 sorry\na_1 b : \u03b1\nh_3 : b \u2208 s\nha : a_1 \u2208 lowerBounds s\n\u22a2 b \u2264 a_1 \u2228 a_1 \u2294 b \u2208 s\n---\ncase inr.inl\n\u03b1 : Type u_3\ninst : SemilatticeSup \u03b1\ns : Set \u03b1\nh : SupClosed s\nha' : (b : \u03b1) \u2192 b \u2208 s \u2192 sorry\na_1 b : \u03b1\nh_2 : a_1 \u2208 s\nha : b \u2208 lowerBounds s\n\u22a2 a_1 \u2264 b \u2228 a_1 \u2294 b \u2208 s\n---\ncase inr.inr\n\u03b1 : Type u_3\ninst : SemilatticeSup \u03b1\ns : Set \u03b1\na : \u03b1\nh : SupClosed s\nha : a \u2208 lowerBounds s\nha' : (b : \u03b1) \u2192 b \u2208 s \u2192 sorry\na_1 b : \u03b1\nh_2 : a_1 \u2208 s\nh_3 : b \u2208 s\n\u22a2 a_1 \u2294 b = a \u2228 a_1 \u2294 b \u2208 s"}]}
{"declaration": "lemma infClosed_range [FunLike F \u03b1 \u03b2] [InfHomClass F \u03b1 \u03b2] (f : F) : InfClosed (Set.range f) := by\n  simpa using infClosed_univ.image f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SupClosed.lean", "context": {"open": ["Set", "Finset", "Set"], "variables": ["{\u03b9 : Sort*} {F \u03b1 \u03b2 : Type*}", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2]", "{\u03b9 : Sort*} {S : Set (Set \u03b1)} {f : \u03b9 \u2192 Set \u03b1} {s t : Set \u03b1} {a : \u03b1}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1} {s : Set \u03b1} {t : Finset \u03b9} {a : \u03b1}", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2]", "{\u03b9 : Sort*} {S : Set (Set \u03b1)} {f : \u03b9 \u2192 Set \u03b1} {s t : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u2075 : SemilatticeSup \u03b1\ninst\u271d\u2074 : SemilatticeSup \u03b2\ninst\u271d\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : InfHomClass F \u03b1 \u03b2\nf : F\n\u22a2 InfClosed (Set.range \u21d1f)"}, {"line": "simpa using infClosed_univ.image f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma InfClosed.insert_upperBounds {s : Set \u03b1} {a : \u03b1} (hs : InfClosed s) (ha : a \u2208 upperBounds s) :\n    InfClosed (insert a s) := by\n  rw [InfClosed]\n  have ha' : \u2200 b \u2208 s, b \u2264 a := fun _ a \u21a6 ha a\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SupClosed.lean", "context": {"open": ["Set", "Finset", "Set"], "variables": ["{\u03b9 : Sort*} {F \u03b1 \u03b2 : Type*}", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2]", "{\u03b9 : Sort*} {S : Set (Set \u03b1)} {f : \u03b9 \u2192 Set \u03b1} {s t : Set \u03b1} {a : \u03b1}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1} {s : Set \u03b1} {t : Finset \u03b9} {a : \u03b1}", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2]", "{\u03b9 : Sort*} {S : Set (Set \u03b1)} {f : \u03b9 \u2192 Set \u03b1} {s t : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : SemilatticeInf \u03b1\ns : Set \u03b1\na : \u03b1\nhs : InfClosed s\nha : a \u2208 upperBounds s\n\u22a2 InfClosed (insert a s)"}, {"line": "rw [InfClosed]", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : SemilatticeInf \u03b1\ns : Set \u03b1\na : \u03b1\nhs : InfClosed s\nha : a \u2208 upperBounds s\n\u22a2 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 insert a s \u2192 \u2200 \u2983b : \u03b1\u2984, b \u2208 insert a s \u2192 a_1 \u2293 b \u2208 insert a s"}, {"line": "have ha' : \u2200 b \u2208 s, b \u2264 a := fun _ a \u21a6 ha a", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : SemilatticeInf \u03b1\ns : Set \u03b1\na : \u03b1\nhs : InfClosed s\nha : a \u2208 upperBounds s\nha' : (b : \u03b1) \u2192 b \u2208 s \u2192 sorry\n\u22a2 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 insert a s \u2192 \u2200 \u2983b : \u03b1\u2984, b \u2208 insert a s \u2192 a_1 \u2293 b \u2208 insert a s"}, {"line": "aesop", "tactic_state": "case inl.inr\n\u03b1 : Type u_3\ninst : SemilatticeSup \u03b1\ninst_1 : SemilatticeInf \u03b1\ns : Set \u03b1\nhs : InfClosed s\nha' : (b : \u03b1) \u2192 b \u2208 s \u2192 sorry\na_1 b : \u03b1\nh_2 : b \u2208 s\nha : a_1 \u2208 upperBounds s\n\u22a2 a_1 \u2264 b \u2228 a_1 \u2293 b \u2208 s\n---\ncase inr.inl\n\u03b1 : Type u_3\ninst : SemilatticeSup \u03b1\ninst_1 : SemilatticeInf \u03b1\ns : Set \u03b1\nhs : InfClosed s\nha' : (b : \u03b1) \u2192 b \u2208 s \u2192 sorry\na_1 b : \u03b1\nh_1 : a_1 \u2208 s\nha : b \u2208 upperBounds s\n\u22a2 b \u2264 a_1 \u2228 a_1 \u2293 b \u2208 s\n---\ncase inr.inr\n\u03b1 : Type u_3\ninst : SemilatticeSup \u03b1\ninst_1 : SemilatticeInf \u03b1\ns : Set \u03b1\na : \u03b1\nhs : InfClosed s\nha : a \u2208 upperBounds s\nha' : (b : \u03b1) \u2192 b \u2208 s \u2192 sorry\na_1 b : \u03b1\nh_1 : a_1 \u2208 s\nh_2 : b \u2208 s\n\u22a2 a_1 \u2293 b = a \u2228 a_1 \u2293 b \u2208 s"}]}
{"declaration": "lemma InfClosed.insert_lowerBounds {s : Set \u03b1} {a : \u03b1} (h : InfClosed s) (ha : a \u2208 lowerBounds s) :\n    InfClosed (insert a s) := by\n  rw [InfClosed]\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SupClosed.lean", "context": {"open": ["Set", "Finset", "Set"], "variables": ["{\u03b9 : Sort*} {F \u03b1 \u03b2 : Type*}", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2]", "{\u03b9 : Sort*} {S : Set (Set \u03b1)} {f : \u03b9 \u2192 Set \u03b1} {s t : Set \u03b1} {a : \u03b1}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1} {s : Set \u03b1} {t : Finset \u03b9} {a : \u03b1}", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2]", "{\u03b9 : Sort*} {S : Set (Set \u03b1)} {f : \u03b9 \u2192 Set \u03b1} {s t : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : SemilatticeInf \u03b1\ns : Set \u03b1\na : \u03b1\nh : InfClosed s\nha : a \u2208 lowerBounds s\n\u22a2 InfClosed (insert a s)"}, {"line": "rw [InfClosed]", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : SemilatticeInf \u03b1\ns : Set \u03b1\na : \u03b1\nh : InfClosed s\nha : a \u2208 lowerBounds s\n\u22a2 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 insert a s \u2192 \u2200 \u2983b : \u03b1\u2984, b \u2208 insert a s \u2192 a_1 \u2293 b \u2208 insert a s"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma SupClosed.iSup_mem [Finite \u03b9] (hs : SupClosed s) (hbot : \u22a5 \u2208 s) (hf : \u2200 i, f i \u2208 s) :\n    \u2a06 i, f i \u2208 s := by\n  cases isEmpty_or_nonempty \u03b9\n  \u00b7 simpa [iSup_of_empty]\n  \u00b7 exact hs.iSup_mem_of_nonempty hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SupClosed.lean", "context": {"open": ["Set", "Finset", "Set", "Finset", "Finset OrderDual", "Set", "Finset", "Finset"], "variables": ["{\u03b9 : Sort*} {F \u03b1 \u03b2 : Type*}", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2]", "{\u03b9 : Sort*} {S : Set (Set \u03b1)} {f : \u03b9 \u2192 Set \u03b1} {s t : Set \u03b1} {a : \u03b1}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1} {s : Set \u03b1} {t : Finset \u03b9} {a : \u03b1}", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2]", "{\u03b9 : Sort*} {S : Set (Set \u03b1)} {f : \u03b9 \u2192 Set \u03b1} {s t : Set \u03b1} {a : \u03b1}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1} {s : Set \u03b1} {t : Finset \u03b9} {a : \u03b1}", "{\u03b9 : Sort*} [Lattice \u03b1] [Lattice \u03b2] {S : Set (Set \u03b1)} {f : \u03b9 \u2192 Set \u03b1} {s t : Set \u03b1} {a : \u03b1}", "[LinearOrder \u03b1]", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] {s t : Set \u03b1} {a b : \u03b1}", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2] {s t : Set \u03b1} {a b : \u03b1}", "[Lattice \u03b1] {s t : Set \u03b1}", "[DistribLattice \u03b1] [DistribLattice \u03b2] {s : Set \u03b1}", "[ConditionallyCompleteLattice \u03b1] {f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "[CompleteLattice \u03b1] {f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b9\u2070 : SemilatticeSup \u03b1\ninst\u271d\u2079 : SemilatticeInf \u03b1\n\u03b9 : Sort u_9\ninst\u271d\u2078 : Lattice \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : SemilatticeSup \u03b1\ninst\u271d\u2075 : SemilatticeInf \u03b1\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : DistribLattice \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\nf : \u03b9 \u2192 \u03b1\ns : Set \u03b1\ninst\u271d : Finite \u03b9\nhs : SupClosed s\nhbot : \u22a5 \u2208 s\nhf : \u2200 (i : \u03b9), f i \u2208 s\n\u22a2 \u2a06 i, f i \u2208 s"}, {"line": "cases isEmpty_or_nonempty \u03b9", "tactic_state": "case inl\n\u03b1 : Type u_3\ninst\u271d\u00b9\u2070 : SemilatticeSup \u03b1\ninst\u271d\u2079 : SemilatticeInf \u03b1\n\u03b9 : Sort u_9\ninst\u271d\u2078 : Lattice \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : SemilatticeSup \u03b1\ninst\u271d\u2075 : SemilatticeInf \u03b1\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : DistribLattice \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\nf : \u03b9 \u2192 \u03b1\ns : Set \u03b1\ninst\u271d : Finite \u03b9\nhs : SupClosed s\nhbot : \u22a5 \u2208 s\nhf : \u2200 (i : \u03b9), f i \u2208 s\nh\u271d : IsEmpty \u03b9\n\u22a2 \u2a06 i, f i \u2208 s\n---\ncase inr\n\u03b1 : Type u_3\ninst\u271d\u00b9\u2070 : SemilatticeSup \u03b1\ninst\u271d\u2079 : SemilatticeInf \u03b1\n\u03b9 : Sort u_9\ninst\u271d\u2078 : Lattice \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : SemilatticeSup \u03b1\ninst\u271d\u2075 : SemilatticeInf \u03b1\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : DistribLattice \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\nf : \u03b9 \u2192 \u03b1\ns : Set \u03b1\ninst\u271d : Finite \u03b9\nhs : SupClosed s\nhbot : \u22a5 \u2208 s\nhf : \u2200 (i : \u03b9), f i \u2208 s\nh\u271d : Nonempty \u03b9\n\u22a2 \u2a06 i, f i \u2208 s"}, {"line": "\u00b7 simpa [iSup_of_empty]", "tactic_state": "case inr\n\u03b1 : Type u_3\ninst\u271d\u00b9\u2070 : SemilatticeSup \u03b1\ninst\u271d\u2079 : SemilatticeInf \u03b1\n\u03b9 : Sort u_9\ninst\u271d\u2078 : Lattice \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : SemilatticeSup \u03b1\ninst\u271d\u2075 : SemilatticeInf \u03b1\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : DistribLattice \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\nf : \u03b9 \u2192 \u03b1\ns : Set \u03b1\ninst\u271d : Finite \u03b9\nhs : SupClosed s\nhbot : \u22a5 \u2208 s\nhf : \u2200 (i : \u03b9), f i \u2208 s\nh\u271d : Nonempty \u03b9\n\u22a2 \u2a06 i, f i \u2208 s"}, {"line": "\u00b7 exact hs.iSup_mem_of_nonempty hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_iff_forall_le (hf : IsNormal f) (ha : IsSuccLimit a) {b : \u03b2} :\n    f a \u2264 b \u2194 \u2200 a' < a, f a' \u2264 b := by\n  simpa [mem_upperBounds] using isLUB_le_iff (hf.isLUB_image_Iio_of_isSuccLimit ha)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/IsNormal.lean", "context": {"open": ["Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {a b : \u03b1} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "[LinearOrder \u03b1] [LinearOrder \u03b2] [LinearOrder \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nhf : IsNormal f\nha : IsSuccLimit a\nb : \u03b2\n\u22a2 f a \u2264 b \u2194 \u2200 a' < a, f a' \u2264 b"}, {"line": "simpa [mem_upperBounds] using isLUB_le_iff (hf.isLUB_image_Iio_of_isSuccLimit ha)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_iff_exists_lt (hf : IsNormal f) (ha : IsSuccLimit a) {b : \u03b2} :\n    b < f a \u2194 \u2203 a' < a, b < f a' := by\n  simpa [mem_upperBounds] using lt_isLUB_iff (hf.isLUB_image_Iio_of_isSuccLimit ha)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/IsNormal.lean", "context": {"open": ["Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {a b : \u03b1} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "[LinearOrder \u03b1] [LinearOrder \u03b2] [LinearOrder \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nhf : IsNormal f\nha : IsSuccLimit a\nb : \u03b2\n\u22a2 b < f a \u2194 \u2203 a' < a, b < f a'"}, {"line": "simpa [mem_upperBounds] using lt_isLUB_iff (hf.isLUB_image_Iio_of_isSuccLimit ha)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subset_sSup_of_within [Inhabited s] {t : Set s}\n    (h' : t.Nonempty) (h'' : BddAbove t) (h : sSup ((\u2191) '' t : Set \u03b1) \u2208 s) :\n    sSup ((\u2191) '' t : Set \u03b1) = (@sSup s _ t : \u03b1) := by simp [dif_pos, h, h', h'']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLatticeIntervals.lean", "context": {"open": ["Set", "Classical in", "Classical in"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} (s : Set \u03b1)", "[Preorder \u03b1] [SupSet \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SupSet \u03b1\ns : Type u_1\ninst\u271d : Inhabited s\nt : Set s\nh' : t.Nonempty\nh'' : sorry\nh : sorry\n\u22a2 sSup (sorry '' t) = sorry"}, {"line": "simp [dif_pos, h, h', h'']", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SupSet \u03b1\ns : Type u_1\ninst\u271d : Inhabited s\nt : Set s\nh' : t.Nonempty\nh'' : sorry\nh : sorry\n\u22a2 sSup ((fun a => sorry () a) '' t) = sorry ()"}]}
{"declaration": "theorem subset_sSup_emptyset [Inhabited s] :\n    sSup (\u2205 : Set s) = default := by\n  simp [sSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLatticeIntervals.lean", "context": {"open": ["Set", "Classical in", "Classical in"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} (s : Set \u03b1)", "[Preorder \u03b1] [SupSet \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Type u_1\ninst\u271d : Inhabited s\n\u22a2 sorry = default"}, {"line": "simp [sSup]", "tactic_state": "s : Type u_1\ninst\u271d : Inhabited s\n\u22a2 sorry () = default"}]}
{"declaration": "theorem subset_sSup_of_not_bddAbove [Inhabited s] {t : Set s} (ht : \u00acBddAbove t) :\n    sSup t = default := by\n  simp [sSup, ht]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLatticeIntervals.lean", "context": {"open": ["Set", "Classical in", "Classical in"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} (s : Set \u03b1)", "[Preorder \u03b1] [SupSet \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Type u_1\ninst\u271d : Inhabited s\nt : Set s\nht : \u00acsorry\n\u22a2 sorry = default"}, {"line": "simp [sSup, ht]", "tactic_state": "s : Type u_1\ninst\u271d : Inhabited s\nt : Set s\nht : \u00acsorry\n\u22a2 sorry () = default"}]}
{"declaration": "theorem subset_sInf_of_within [Inhabited s] {t : Set s}\n    (h' : t.Nonempty) (h'' : BddBelow t) (h : sInf ((\u2191) '' t : Set \u03b1) \u2208 s) :\n    sInf ((\u2191) '' t : Set \u03b1) = (@sInf s _ t : \u03b1) := by simp [dif_pos, h, h', h'']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLatticeIntervals.lean", "context": {"open": ["Set", "Classical in", "Classical in", "Classical in", "Classical in"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} (s : Set \u03b1)", "[Preorder \u03b1] [SupSet \u03b1]", "[Preorder \u03b1] [InfSet \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : SupSet \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ns : Type u_1\ninst\u271d : Inhabited s\nt : Set s\nh' : t.Nonempty\nh'' : sorry\nh : sorry\n\u22a2 sInf (sorry '' t) = sorry"}, {"line": "simp [dif_pos, h, h', h'']", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : SupSet \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ns : Type u_1\ninst\u271d : Inhabited s\nt : Set s\nh' : t.Nonempty\nh'' : sorry\nh : sorry\n\u22a2 sInf ((fun a => sorry () a) '' t) = sorry ()"}]}
{"declaration": "theorem subset_sInf_emptyset [Inhabited s] :\n    sInf (\u2205 : Set s) = default := by\n  simp [sInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLatticeIntervals.lean", "context": {"open": ["Set", "Classical in", "Classical in", "Classical in", "Classical in"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} (s : Set \u03b1)", "[Preorder \u03b1] [SupSet \u03b1]", "[Preorder \u03b1] [InfSet \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Type u_1\ninst\u271d : Inhabited s\n\u22a2 sorry = default"}, {"line": "simp [sInf]", "tactic_state": "s : Type u_1\ninst\u271d : Inhabited s\n\u22a2 sorry () = default"}]}
{"declaration": "theorem subset_sInf_of_not_bddBelow [Inhabited s] {t : Set s} (ht : \u00acBddBelow t) :\n    sInf t = default := by\n  simp [sInf, ht]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLatticeIntervals.lean", "context": {"open": ["Set", "Classical in", "Classical in", "Classical in", "Classical in"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} (s : Set \u03b1)", "[Preorder \u03b1] [SupSet \u03b1]", "[Preorder \u03b1] [InfSet \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Type u_1\ninst\u271d : Inhabited s\nt : Set s\nht : \u00acsorry\n\u22a2 sorry = default"}, {"line": "simp [sInf, ht]", "tactic_state": "s : Type u_1\ninst\u271d : Inhabited s\nt : Set s\nht : \u00acsorry\n\u22a2 sorry () = default"}]}
{"declaration": "theorem coe_biSup : (\u2191(\u2a06 i, \u2a06 (_ : p i), f i) : \u03b1) = \u2a06 i, \u2a06 (_ : p i), (f i : \u03b1) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLatticeIntervals.lean", "context": {"open": ["Set", "Classical in", "Classical in", "Classical in", "Classical in", "Classical in"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} (s : Set \u03b1)", "[Preorder \u03b1] [SupSet \u03b1]", "[Preorder \u03b1] [InfSet \u03b1]", "[ConditionallyCompleteLinearOrder \u03b1]", "[CompleteLattice \u03b1] {a : \u03b1}", "(S : Set <| Iic a) (f : \u03b9 \u2192 Iic a) (p : \u03b9 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : SupSet \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : InfSet \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d : CompleteLattice \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u2191(Iic a)\np : \u03b9 \u2192 Prop\n\u22a2 sorry = \u2a06 i, \u2a06 (_ : p i), \u2191(f i)"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : SupSet \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : InfSet \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d : CompleteLattice \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u2191(Iic a)\np : \u03b9 \u2192 Prop\n\u22a2 sorry () = \u2a06 i, \u2a06 (_ : p i), \u2191(f i)"}]}
{"declaration": "theorem coe_biInf : (\u2191(\u2a05 i, \u2a05 (_ : p i), f i) : \u03b1) = a \u2293 \u2a05 i, \u2a05 (_ : p i), (f i : \u03b1) := by\n  cases isEmpty_or_nonempty \u03b9\n  \u00b7 simp\n  \u00b7 simp_rw [coe_iInf, \u2190 inf_iInf, \u2190 inf_assoc, inf_idem]\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLatticeIntervals.lean", "context": {"open": ["Set", "Classical in", "Classical in", "Classical in", "Classical in", "Classical in"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} (s : Set \u03b1)", "[Preorder \u03b1] [SupSet \u03b1]", "[Preorder \u03b1] [InfSet \u03b1]", "[ConditionallyCompleteLinearOrder \u03b1]", "[CompleteLattice \u03b1] {a : \u03b1}", "(S : Set <| Iic a) (f : \u03b9 \u2192 Iic a) (p : \u03b9 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : SupSet \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : InfSet \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d : CompleteLattice \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u2191(Iic a)\np : \u03b9 \u2192 Prop\n\u22a2 sorry = min a (\u2a05 i, \u2a05 (_ : p i), \u2191(f i))"}, {"line": "cases isEmpty_or_nonempty \u03b9", "tactic_state": "case inl\n\u03b1 : Type u_1\n\u03b9 : Sort u_2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : SupSet \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : InfSet \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d : CompleteLattice \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u2191(Iic a)\np : \u03b9 \u2192 Prop\nh\u271d : IsEmpty \u03b9\n\u22a2 sorry = min a (\u2a05 i, \u2a05 (_ : p i), \u2191(f i))\n---\ncase inr\n\u03b1 : Type u_1\n\u03b9 : Sort u_2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : SupSet \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : InfSet \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d : CompleteLattice \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u2191(Iic a)\np : \u03b9 \u2192 Prop\nh\u271d : Nonempty \u03b9\n\u22a2 sorry = min a (\u2a05 i, \u2a05 (_ : p i), \u2191(f i))"}, {"line": "\u00b7 simp", "tactic_state": "case inr\n\u03b1 : Type u_1\n\u03b9 : Sort u_2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : SupSet \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : InfSet \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d : CompleteLattice \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u2191(Iic a)\np : \u03b9 \u2192 Prop\nh\u271d : Nonempty \u03b9\n\u22a2 sorry = min a (\u2a05 i, \u2a05 (_ : p i), \u2191(f i))"}, {"line": "\u00b7 simp_rw [coe_iInf, \u2190 inf_iInf, \u2190 inf_assoc, inf_idem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) \u2194 x i < a := by\n  refine \u27e8?_, fun h => toLex_strictMono <| lt_update_self_iff.2 h\u27e9\n  rintro \u27e8j, hj, h\u27e9\n  dsimp at h\n  obtain rfl : j = i := by\n    by_contra H\n    rw [update_of_ne H] at h\n    exact h.false\n  rwa [update_self] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/PiLex.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 : Type*} {\u03b2 : \u03b9 \u2192 Type*} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) (s : \u2200 {i}, \u03b2 i \u2192 \u03b2 i \u2192 Prop)", "[LinearOrder \u03b9] [WellFoundedLT \u03b9] [\u2200 i, PartialOrder (\u03b2 i)] {x : \u2200 i, \u03b2 i} {i : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b2 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : WellFoundedLT \u03b9\ninst\u271d : (i : \u03b9) \u2192 PartialOrder (\u03b2 i)\nx : (i : \u03b9) \u2192 \u03b2 i\ni : \u03b9\na : \u03b2 i\n\u22a2 toLex x < toLex (update x i a) \u2194 x i < a"}, {"line": "refine \u27e8?_, fun h => toLex_strictMono <| lt_update_self_iff.2 h\u27e9", "tactic_state": "\u03b9 : Type u_1\n\u03b2 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : WellFoundedLT \u03b9\ninst\u271d : (i : \u03b9) \u2192 PartialOrder (\u03b2 i)\nx : (i : \u03b9) \u2192 \u03b2 i\ni : \u03b9\na : \u03b2 i\n\u22a2 toLex x < toLex (update x i a) \u2192 x i < a"}, {"line": "rintro \u27e8j, hj, h\u27e9", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\n\u03b2 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : WellFoundedLT \u03b9\ninst\u271d : (i : \u03b9) \u2192 PartialOrder (\u03b2 i)\nx : (i : \u03b9) \u2192 \u03b2 i\ni : \u03b9\na : \u03b2 i\nj : \u03b9\nhj : \u2200 (j_1 : \u03b9), (fun x1 x2 => x1 < x2) j_1 j \u2192 toLex x j_1 = toLex (update x i a) j_1\nh : toLex x j < toLex (update x i a) j\n\u22a2 x i < a"}, {"line": "dsimp at h", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\n\u03b2 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : WellFoundedLT \u03b9\ninst\u271d : (i : \u03b9) \u2192 PartialOrder (\u03b2 i)\nx : (i : \u03b9) \u2192 \u03b2 i\ni : \u03b9\na : \u03b2 i\nj : \u03b9\nhj : \u2200 (j_1 : \u03b9), (fun x1 x2 => x1 < x2) j_1 j \u2192 toLex x j_1 = toLex (update x i a) j_1\nh : x j < update x i a j\n\u22a2 x i < a"}, {"line": "obtain rfl : j = i := by\n    by_contra H\n    rw [update_of_ne H] at h\n    exact h.false", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\n\u03b2 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : WellFoundedLT \u03b9\ninst\u271d : (i : \u03b9) \u2192 PartialOrder (\u03b2 i)\nx : (i : \u03b9) \u2192 \u03b2 i\nj : \u03b9\na : \u03b2 j\nhj : \u2200 (j_1 : \u03b9), (fun x1 x2 => x1 < x2) j_1 j \u2192 toLex x j_1 = toLex (update x j a) j_1\nh : x j < update x j a j\n\u22a2 x j < a"}, {"line": "rwa [update_self] at h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem maximal_true_subtype {x : Subtype P} : Maximal (fun _ \u21a6 True) x \u2194 Maximal P x := by\n  obtain \u27e8x, hx\u27e9 := x\n  simp [Maximal, hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Minimal.lean", "context": {"open": ["Set OrderDual"], "variables": ["{\u03b1 : Type*} {P Q : \u03b1 \u2192 Prop} {a x y : \u03b1}", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nP : \u03b1 \u2192 Prop\ninst\u271d : LE \u03b1\nx : Subtype P\n\u22a2 Maximal (fun x => True) x \u2194 Maximal P \u2191x"}, {"line": "obtain \u27e8x, hx\u27e9 := x", "tactic_state": "case mk\n\u03b1 : Type u_1\nP : \u03b1 \u2192 Prop\ninst\u271d : LE \u03b1\nx : \u03b1\nhx : P x\n\u22a2 Maximal (fun x => True) \u27e8x, hx\u27e9 \u2194 Maximal P \u2191\u27e8x, hx\u27e9"}, {"line": "simp [Maximal, hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem minimal_true_subtype {x : Subtype P} : Minimal (fun _ \u21a6 True) x \u2194 Minimal P x := by\n  obtain \u27e8x, hx\u27e9 := x\n  simp [Minimal, hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Minimal.lean", "context": {"open": ["Set OrderDual"], "variables": ["{\u03b1 : Type*} {P Q : \u03b1 \u2192 Prop} {a x y : \u03b1}", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nP : \u03b1 \u2192 Prop\ninst\u271d : LE \u03b1\nx : Subtype P\n\u22a2 Minimal (fun x => True) x \u2194 Minimal P \u2191x"}, {"line": "obtain \u27e8x, hx\u27e9 := x", "tactic_state": "case mk\n\u03b1 : Type u_1\nP : \u03b1 \u2192 Prop\ninst\u271d : LE \u03b1\nx : \u03b1\nhx : P x\n\u22a2 Minimal (fun x => True) \u27e8x, hx\u27e9 \u2194 Minimal P \u2191\u27e8x, hx\u27e9"}, {"line": "simp [Minimal, hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_minimal_iff (hx : P x) : \u00ac Minimal P x \u2194 \u2203 y, P y \u2227 y \u2264 x \u2227 \u00ac (x \u2264 y) := by\n  simp [Minimal, hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Minimal.lean", "context": {"open": ["Set OrderDual"], "variables": ["{\u03b1 : Type*} {P Q : \u03b1 \u2192 Prop} {a x y : \u03b1}", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nP : \u03b1 \u2192 Prop\nx : \u03b1\ninst\u271d : LE \u03b1\nhx : P x\n\u22a2 \u00acMinimal P x \u2194 \u2203 y, P y \u2227 y \u2264 x \u2227 \u00acx \u2264 y"}, {"line": "simp [Minimal, hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Minimal.or (h : Minimal (fun x \u21a6 P x \u2228 Q x) x) : Minimal P x \u2228 Minimal Q x := by\n  obtain \u27e8h | h, hmin\u27e9 := h\n  \u00b7 exact .inl \u27e8h, fun y hy hyx \u21a6 hmin (Or.inl hy) hyx\u27e9\n  exact .inr \u27e8h, fun y hy hyx \u21a6 hmin (Or.inr hy) hyx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Minimal.lean", "context": {"open": ["Set OrderDual"], "variables": ["{\u03b1 : Type*} {P Q : \u03b1 \u2192 Prop} {a x y : \u03b1}", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nP Q : \u03b1 \u2192 Prop\nx : \u03b1\ninst\u271d : LE \u03b1\nh : Minimal (fun x => P x \u2228 Q x) x\n\u22a2 Minimal P x \u2228 Minimal Q x"}, {"line": "obtain \u27e8h | h, hmin\u27e9 := h", "tactic_state": "case intro.inl\n\u03b1 : Type u_1\nP Q : \u03b1 \u2192 Prop\nx : \u03b1\ninst\u271d : LE \u03b1\nhmin : \u2200 \u2983y : \u03b1\u2984, (fun x => P x \u2228 Q x) y \u2192 y \u2264 x \u2192 x \u2264 y\nh : P x\n\u22a2 Minimal P x \u2228 Minimal Q x\n---\ncase intro.inr\n\u03b1 : Type u_1\nP Q : \u03b1 \u2192 Prop\nx : \u03b1\ninst\u271d : LE \u03b1\nhmin : \u2200 \u2983y : \u03b1\u2984, (fun x => P x \u2228 Q x) y \u2192 y \u2264 x \u2192 x \u2264 y\nh : Q x\n\u22a2 Minimal P x \u2228 Minimal Q x"}, {"line": "\u00b7 exact .inl \u27e8h, fun y hy hyx \u21a6 hmin (Or.inl hy) hyx\u27e9", "tactic_state": "case intro.inr\n\u03b1 : Type u_1\nP Q : \u03b1 \u2192 Prop\nx : \u03b1\ninst\u271d : LE \u03b1\nhmin : \u2200 \u2983y : \u03b1\u2984, (fun x => P x \u2228 Q x) y \u2192 y \u2264 x \u2192 x \u2264 y\nh : Q x\n\u22a2 Minimal P x \u2228 Minimal Q x"}, {"line": "exact .inr \u27e8h, fun y hy hyx \u21a6 hmin (Or.inr hy) hyx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem minimal_and_iff_right_of_imp (hPQ : \u2200 \u2983x\u2984, P x \u2192 Q x) :\n    Minimal (fun x \u21a6 P x \u2227 Q x) x \u2194 (Minimal P x) \u2227 Q x := by\n  simp_rw [and_iff_left_of_imp (fun x \u21a6 hPQ x), iff_self_and]\n  exact fun h \u21a6 hPQ h.prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Minimal.lean", "context": {"open": ["Set OrderDual"], "variables": ["{\u03b1 : Type*} {P Q : \u03b1 \u2192 Prop} {a x y : \u03b1}", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nP Q : \u03b1 \u2192 Prop\nx : \u03b1\ninst\u271d : LE \u03b1\nhPQ : \u2200 \u2983x : \u03b1\u2984, P x \u2192 Q x\n\u22a2 Minimal (fun x => P x \u2227 Q x) x \u2194 Minimal P x \u2227 Q x"}, {"line": "simp_rw [and_iff_left_of_imp (fun x \u21a6 hPQ x), iff_self_and]", "tactic_state": "\u03b1 : Type u_1\nP Q : \u03b1 \u2192 Prop\nx : \u03b1\ninst\u271d : LE \u03b1\nhPQ : \u2200 \u2983x : \u03b1\u2984, P x \u2192 Q x\n\u22a2 Minimal (fun x => P x) x \u2192 Q x"}, {"line": "exact fun h \u21a6 hPQ h.prop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem minimal_iff_forall_lt : Minimal P x \u2194 P x \u2227 \u2200 \u2983y\u2984, y < x \u2192 \u00ac P y := by\n  simp [Minimal, lt_iff_le_not_le, not_imp_not, imp.swap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Minimal.lean", "context": {"open": ["Set OrderDual"], "variables": ["{\u03b1 : Type*} {P Q : \u03b1 \u2192 Prop} {a x y : \u03b1}", "[LE \u03b1]", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nP : \u03b1 \u2192 Prop\nx : \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\n\u22a2 Minimal P x \u2194 P x \u2227 \u2200 \u2983y : \u03b1\u2984, y < x \u2192 \u00acP y"}, {"line": "simp [Minimal, lt_iff_le_not_le, not_imp_not, imp.swap]", "tactic_state": "\u03b1 : Type u_1\nP : \u03b1 \u2192 Prop\nx : \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\n\u22a2 P x \u2192 ((\u2200 \u2983y : \u03b1\u2984, P y \u2192 y \u2264 x \u2192 x \u2264 y) \u2194 \u2200 \u2983y : \u03b1\u2984, P y \u2192 y \u2264 x \u2192 x \u2264 y)"}]}
{"declaration": "theorem Set.exists_diff_singleton_of_not_minimal (hP : \u2200 \u2983s t\u2984, P t \u2192 t \u2286 s \u2192 P s) (hs : P s)\n    (h : \u00ac Minimal P s) : \u2203 x \u2208 s, P (s \\ {x}) := by\n  simpa [Set.minimal_iff_forall_diff_singleton hP, hs] using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Minimal.lean", "context": {"open": ["Set OrderDual"], "variables": ["{\u03b1 : Type*} {P Q : \u03b1 \u2192 Prop} {a x y : \u03b1}", "[LE \u03b1]", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "{P : Set \u03b1 \u2192 Prop} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PartialOrder \u03b1\nP : Set \u03b1 \u2192 Prop\ns : Set \u03b1\nhP : \u2200 \u2983s t : Set \u03b1\u2984, P t \u2192 t \u2286 s \u2192 P s\nhs : P s\nh : \u00acMinimal P s\n\u22a2 \u2203 x \u2208 s, P (s \\ {x})"}, {"line": "simpa [Set.minimal_iff_forall_diff_singleton hP, hs] using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Set.maximal_iff_forall_insert (hP : \u2200 \u2983s t\u2984, P t \u2192 s \u2286 t \u2192 P s) :\n    Maximal P s \u2194 P s \u2227 \u2200 x \u2209 s, \u00ac P (insert x s) := by\n  simp only [not_imp_not]\n  exact \u27e8fun h \u21a6 \u27e8h.1, fun x \u21a6 h.mem_of_prop_insert\u27e9,\n    fun h \u21a6 \u27e8h.1, fun t ht hst x hxt \u21a6 h.2 x (hP ht <| insert_subset hxt hst)\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Minimal.lean", "context": {"open": ["Set OrderDual"], "variables": ["{\u03b1 : Type*} {P Q : \u03b1 \u2192 Prop} {a x y : \u03b1}", "[LE \u03b1]", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "{P : Set \u03b1 \u2192 Prop} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PartialOrder \u03b1\nP : Set \u03b1 \u2192 Prop\ns : Set \u03b1\nhP : \u2200 \u2983s t : Set \u03b1\u2984, P t \u2192 s \u2286 t \u2192 P s\n\u22a2 Maximal P s \u2194 P s \u2227 \u2200 x \u2209 s, \u00acP (insert x s)"}, {"line": "simp only [not_imp_not]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PartialOrder \u03b1\nP : Set \u03b1 \u2192 Prop\ns : Set \u03b1\nhP : \u2200 \u2983s t : Set \u03b1\u2984, P t \u2192 s \u2286 t \u2192 P s\n\u22a2 Maximal P s \u2194 P s \u2227 \u2200 (x : \u03b1), P (insert x s) \u2192 x \u2208 s"}, {"line": "exact \u27e8fun h \u21a6 \u27e8h.1, fun x \u21a6 h.mem_of_prop_insert\u27e9,\n    fun h \u21a6 \u27e8h.1, fun t ht hst x hxt \u21a6 h.2 x (hP ht <| insert_subset hxt hst)\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Set.exists_insert_of_not_maximal (hP : \u2200 \u2983s t\u2984, P t \u2192 s \u2286 t \u2192 P s) (hs : P s)\n    (h : \u00ac Maximal P s) : \u2203 x \u2209 s, P (insert x s) := by\n  simpa [Set.maximal_iff_forall_insert hP, hs] using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Minimal.lean", "context": {"open": ["Set OrderDual"], "variables": ["{\u03b1 : Type*} {P Q : \u03b1 \u2192 Prop} {a x y : \u03b1}", "[LE \u03b1]", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "{P : Set \u03b1 \u2192 Prop} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PartialOrder \u03b1\nP : Set \u03b1 \u2192 Prop\ns : Set \u03b1\nhP : \u2200 \u2983s t : Set \u03b1\u2984, P t \u2192 s \u2286 t \u2192 P s\nhs : P s\nh : \u00acMaximal P s\n\u22a2 \u2203 x \u2209 s, P (insert x s)"}, {"line": "simpa [Set.maximal_iff_forall_insert hP, hs] using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Set.Subsingleton.maximal_mem_iff (h : s.Subsingleton) : Maximal (\u00b7 \u2208 s) x \u2194 x \u2208 s := by\n  obtain (rfl | \u27e8x, rfl\u27e9) := h.eq_empty_or_singleton <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Minimal.lean", "context": {"open": ["Set OrderDual"], "variables": ["{\u03b1 : Type*} {P Q : \u03b1 \u2192 Prop} {a x y : \u03b1}", "[LE \u03b1]", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "{P : Set \u03b1 \u2192 Prop} {s t : Set \u03b1}", "{s t : Set \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ns : Set \u03b1\ninst\u271d : Preorder \u03b1\nh : s.Subsingleton\n\u22a2 Maximal (fun x => x \u2208 s) x \u2194 x \u2208 s"}, {"line": "obtain (rfl | \u27e8x, rfl\u27e9) := h.eq_empty_or_singleton <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Set.Subsingleton.minimal_mem_iff (h : s.Subsingleton) : Minimal (\u00b7 \u2208 s) x \u2194 x \u2208 s := by\n  obtain (rfl | \u27e8x, rfl\u27e9) := h.eq_empty_or_singleton <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Minimal.lean", "context": {"open": ["Set OrderDual"], "variables": ["{\u03b1 : Type*} {P Q : \u03b1 \u2192 Prop} {a x y : \u03b1}", "[LE \u03b1]", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "{P : Set \u03b1 \u2192 Prop} {s t : Set \u03b1}", "{s t : Set \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ns : Set \u03b1\ninst\u271d : Preorder \u03b1\nh : s.Subsingleton\n\u22a2 Minimal (fun x => x \u2208 s) x \u2194 x \u2208 s"}, {"line": "obtain (rfl | \u27e8x, rfl\u27e9) := h.eq_empty_or_singleton <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsAntichain.eq_setOf_maximal (ht : IsAntichain (\u00b7 \u2264 \u00b7) t)\n    (h : \u2200 x, Maximal (\u00b7 \u2208 s) x \u2192 x \u2208 t) (hs : \u2200 a \u2208 t, \u2203 b, b \u2264 a \u2227 Maximal (\u00b7 \u2208 s) b) :\n    {x | Maximal (\u00b7 \u2208 s) x} = t := by\n  refine Set.ext fun x \u21a6 \u27e8h _, fun hx \u21a6 ?_\u27e9\n  obtain \u27e8y, hyx, hy\u27e9 := hs x hx\n  rwa [\u2190 ht.eq (h y hy) hx hyx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Minimal.lean", "context": {"open": ["Set OrderDual"], "variables": ["{\u03b1 : Type*} {P Q : \u03b1 \u2192 Prop} {a x y : \u03b1}", "[LE \u03b1]", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "{P : Set \u03b1 \u2192 Prop} {s t : Set \u03b1}", "{s t : Set \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ns t : Set \u03b1\ninst\u271d : Preorder \u03b1\nht : IsAntichain (fun x1 x2 => x1 \u2264 x2) t\nh : \u2200 (x : \u03b1), Maximal (fun x => x \u2208 s) x \u2192 x \u2208 t\nhs : \u2200 a \u2208 t, \u2203 b \u2264 a, Maximal (fun x => x \u2208 s) b\n\u22a2 {x | Maximal (fun x => x \u2208 s) x} = t"}, {"line": "refine Set.ext fun x \u21a6 \u27e8h _, fun hx \u21a6 ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ns t : Set \u03b1\ninst\u271d : Preorder \u03b1\nht : IsAntichain (fun x1 x2 => x1 \u2264 x2) t\nh : \u2200 (x : \u03b1), Maximal (fun x => x \u2208 s) x \u2192 x \u2208 t\nhs : \u2200 a \u2208 t, \u2203 b \u2264 a, Maximal (fun x => x \u2208 s) b\nx : \u03b1\nhx : x \u2208 t\n\u22a2 x \u2208 {x | Maximal (fun x => x \u2208 s) x}"}, {"line": "obtain \u27e8y, hyx, hy\u27e9 := hs x hx", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ns t : Set \u03b1\ninst\u271d : Preorder \u03b1\nht : IsAntichain (fun x1 x2 => x1 \u2264 x2) t\nh : \u2200 (x : \u03b1), Maximal (fun x => x \u2208 s) x \u2192 x \u2208 t\nhs : \u2200 a \u2208 t, \u2203 b \u2264 a, Maximal (fun x => x \u2208 s) b\nx : \u03b1\nhx : x \u2208 t\ny : \u03b1\nhyx : y \u2264 x\nhy : Maximal (fun x => x \u2208 s) y\n\u22a2 x \u2208 {x | Maximal (fun x => x \u2208 s) x}"}, {"line": "rwa [\u2190 ht.eq (h y hy) hx hyx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem directedOn_iff_directed {s} : @DirectedOn \u03b1 r s \u2194 Directed r (Subtype.val : s \u2192 \u03b1) := by\n  simp only [DirectedOn]\n  simp only [Directed]\n  simp only [Subtype.exists]\n  simp only [exists_and_left]\n  simp only [exists_prop]\n  simp only [Subtype.forall]\n  exact forall\u2082_congr fun x _ => by simp [And.comm, and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Directed.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} (r r' s : \u03b1 \u2192 \u03b1 \u2192 Prop)", "{r r'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\n\u22a2 DirectedOn r s \u2194 Directed r Subtype.val"}, {"line": "simp only [DirectedOn]", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\n\u22a2 (\u2200 x \u2208 s, \u2200 y \u2208 s, \u2203 z \u2208 s, r x z \u2227 r y z) \u2194 Directed r Subtype.val"}, {"line": "simp only [Directed]", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\n\u22a2 (\u2200 x \u2208 s, \u2200 y \u2208 s, \u2203 z \u2208 s, r x z \u2227 r y z) \u2194 \u2200 (x y : { x // x \u2208 s }), \u2203 z, r \u2191x \u2191z \u2227 r \u2191y \u2191z"}, {"line": "simp only [Subtype.exists]", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\n\u22a2 (\u2200 x \u2208 s, \u2200 y \u2208 s, \u2203 z \u2208 s, r x z \u2227 r y z) \u2194 \u2200 (x y : { x // x \u2208 s }), \u2203 a, \u2203 (_ : a \u2208 s), r (\u2191x) a \u2227 r (\u2191y) a"}, {"line": "simp only [exists_and_left]", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\n\u22a2 (\u2200 x \u2208 s, \u2200 y \u2208 s, \u2203 z \u2208 s, r x z \u2227 r y z) \u2194 \u2200 (x y : { x // x \u2208 s }), \u2203 a, r (\u2191x) a \u2227 \u2203 (_ : a \u2208 s), r (\u2191y) a"}, {"line": "simp only [exists_prop]", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\n\u22a2 (\u2200 x \u2208 s, \u2200 y \u2208 s, \u2203 z \u2208 s, r x z \u2227 r y z) \u2194 \u2200 (x y : { x // x \u2208 s }), \u2203 a, r (\u2191x) a \u2227 a \u2208 s \u2227 r (\u2191y) a"}, {"line": "simp only [Subtype.forall]", "tactic_state": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\n\u22a2 (\u2200 x \u2208 s, \u2200 y \u2208 s, \u2203 z \u2208 s, r x z \u2227 r y z) \u2194 \u2200 a \u2208 s, \u2200 a_1 \u2208 s, \u2203 a_2, r a a_2 \u2227 a_2 \u2208 s \u2227 r a_1 a_2"}, {"line": "exact forall\u2082_congr fun x _ => by simp [And.comm, and_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem directedOn_range {f : \u03b9 \u2192 \u03b1} : Directed r f \u2194 DirectedOn r (Set.range f) := by\n  simp_rw [Directed, DirectedOn, Set.forall_mem_range, Set.exists_range_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Directed.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} (r r' s : \u03b1 \u2192 \u03b1 \u2192 Prop)", "{r r'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b9 : Sort w\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : \u03b9 \u2192 \u03b1\n\u22a2 Directed r f \u2194 DirectedOn r (Set.range f)"}, {"line": "simp_rw [Directed, DirectedOn, Set.forall_mem_range, Set.exists_range_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem directedOn_image {s : Set \u03b2} {f : \u03b2 \u2192 \u03b1} :\n    DirectedOn r (f '' s) \u2194 DirectedOn (f \u207b\u00b9'o r) s := by\n  simp only [DirectedOn]\n  simp only [Set.mem_image]\n  simp only [exists_exists_and_eq_and]\n  simp only [forall_exists_index]\n  simp only [and_imp]\n  simp only [forall_apply_eq_imp_iff\u2082]\n  simp only [Order.Preimage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Directed.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} (r r' s : \u03b1 \u2192 \u03b1 \u2192 Prop)", "{r r'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 DirectedOn r (f '' s) \u2194 DirectedOn (f \u207b\u00b9'o r) s"}, {"line": "simp only [DirectedOn]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 (\u2200 x \u2208 f '' s, \u2200 y \u2208 f '' s, \u2203 z \u2208 f '' s, r x z \u2227 r y z) \u2194 \u2200 x \u2208 s, \u2200 y \u2208 s, \u2203 z \u2208 s, (f \u207b\u00b9'o r) x z \u2227 (f \u207b\u00b9'o r) y z"}, {"line": "simp only [Set.mem_image]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 (\u2200 (x : \u03b1), (\u2203 x_1 \u2208 s, f x_1 = x) \u2192 \u2200 (y : \u03b1), (\u2203 x \u2208 s, f x = y) \u2192 \u2203 z, (\u2203 x \u2208 s, f x = z) \u2227 r x z \u2227 r y z) \u2194\n    \u2200 x \u2208 s, \u2200 y \u2208 s, \u2203 z \u2208 s, (f \u207b\u00b9'o r) x z \u2227 (f \u207b\u00b9'o r) y z"}, {"line": "simp only [exists_exists_and_eq_and]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 (\u2200 (x : \u03b1), (\u2203 x_1 \u2208 s, f x_1 = x) \u2192 \u2200 (y : \u03b1), (\u2203 x \u2208 s, f x = y) \u2192 \u2203 a \u2208 s, r x (f a) \u2227 r y (f a)) \u2194\n    \u2200 x \u2208 s, \u2200 y \u2208 s, \u2203 z \u2208 s, (f \u207b\u00b9'o r) x z \u2227 (f \u207b\u00b9'o r) y z"}, {"line": "simp only [forall_exists_index]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 (\u2200 (x : \u03b1) (x_1 : \u03b2),\n      x_1 \u2208 s \u2227 f x_1 = x \u2192 \u2200 (y : \u03b1) (x_2 : \u03b2), x_2 \u2208 s \u2227 f x_2 = y \u2192 \u2203 a \u2208 s, r x (f a) \u2227 r y (f a)) \u2194\n    \u2200 x \u2208 s, \u2200 y \u2208 s, \u2203 z \u2208 s, (f \u207b\u00b9'o r) x z \u2227 (f \u207b\u00b9'o r) y z"}, {"line": "simp only [and_imp]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 (\u2200 (x : \u03b1), \u2200 x_1 \u2208 s, f x_1 = x \u2192 \u2200 (y : \u03b1), \u2200 x_2 \u2208 s, f x_2 = y \u2192 \u2203 a \u2208 s, r x (f a) \u2227 r y (f a)) \u2194\n    \u2200 x \u2208 s, \u2200 y \u2208 s, \u2203 z \u2208 s, (f \u207b\u00b9'o r) x z \u2227 (f \u207b\u00b9'o r) y z"}, {"line": "simp only [forall_apply_eq_imp_iff\u2082]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 (\u2200 a \u2208 s, \u2200 a_2 \u2208 s, \u2203 a_4 \u2208 s, r (f a) (f a_4) \u2227 r (f a_2) (f a_4)) \u2194\n    \u2200 x \u2208 s, \u2200 y \u2208 s, \u2203 z \u2208 s, (f \u207b\u00b9'o r) x z \u2227 (f \u207b\u00b9'o r) y z"}, {"line": "simp only [Order.Preimage]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Directed.extend_bot [Preorder \u03b1] [OrderBot \u03b1] {e : \u03b9 \u2192 \u03b2} {f : \u03b9 \u2192 \u03b1}\n    (hf : Directed (\u00b7 \u2264 \u00b7) f) (he : Function.Injective e) :\n    Directed (\u00b7 \u2264 \u00b7) (Function.extend e f \u22a5) := by\n  intro a b\n  rcases (em (\u2203 i, e i = a)).symm with (ha | \u27e8i, rfl\u27e9)\n  \u00b7 use b\n    simp [Function.extend_apply' _ _ _ ha]\n  rcases (em (\u2203 i, e i = b)).symm with (hb | \u27e8j, rfl\u27e9)\n  \u00b7 use e i\n    simp [Function.extend_apply' _ _ _ hb]\n  rcases hf i j with \u27e8k, hi, hj\u27e9\n  use e k\n  simp only [he.extend_apply]\n  simp only [*]\n  simp only [true_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Directed.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} (r r' s : \u03b1 \u2192 \u03b1 \u2192 Prop)", "{r r'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderBot \u03b1\ne : \u03b9 \u2192 \u03b2\nf : \u03b9 \u2192 \u03b1\nhf : Directed (fun x1 x2 => x1 \u2264 x2) f\nhe : Injective e\n\u22a2 Directed (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5)"}, {"line": "intro a b", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderBot \u03b1\ne : \u03b9 \u2192 \u03b2\nf : \u03b9 \u2192 \u03b1\nhf : Directed (fun x1 x2 => x1 \u2264 x2) f\nhe : Injective e\na b : \u03b2\n\u22a2 \u2203 z,\n    (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 a) (extend e f \u22a5 z) \u2227 (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 b) (extend e f \u22a5 z)"}, {"line": "rcases (em (\u2203 i, e i = a)).symm with (ha | \u27e8i, rfl\u27e9)", "tactic_state": "case inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderBot \u03b1\ne : \u03b9 \u2192 \u03b2\nf : \u03b9 \u2192 \u03b1\nhf : Directed (fun x1 x2 => x1 \u2264 x2) f\nhe : Injective e\na b : \u03b2\nha : \u00ac\u2203 i, e i = a\n\u22a2 \u2203 z,\n    (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 a) (extend e f \u22a5 z) \u2227 (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 b) (extend e f \u22a5 z)\n---\ncase inr.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderBot \u03b1\ne : \u03b9 \u2192 \u03b2\nf : \u03b9 \u2192 \u03b1\nhf : Directed (fun x1 x2 => x1 \u2264 x2) f\nhe : Injective e\nb : \u03b2\ni : \u03b9\n\u22a2 \u2203 z,\n    (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 (e i)) (extend e f \u22a5 z) \u2227\n      (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 b) (extend e f \u22a5 z)"}, {"line": "\u00b7 use b\n    simp [Function.extend_apply' _ _ _ ha]", "tactic_state": "case inr.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderBot \u03b1\ne : \u03b9 \u2192 \u03b2\nf : \u03b9 \u2192 \u03b1\nhf : Directed (fun x1 x2 => x1 \u2264 x2) f\nhe : Injective e\nb : \u03b2\ni : \u03b9\n\u22a2 \u2203 z,\n    (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 (e i)) (extend e f \u22a5 z) \u2227\n      (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 b) (extend e f \u22a5 z)"}, {"line": "rcases (em (\u2203 i, e i = b)).symm with (hb | \u27e8j, rfl\u27e9)", "tactic_state": "case inr.intro.inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderBot \u03b1\ne : \u03b9 \u2192 \u03b2\nf : \u03b9 \u2192 \u03b1\nhf : Directed (fun x1 x2 => x1 \u2264 x2) f\nhe : Injective e\nb : \u03b2\ni : \u03b9\nhb : \u00ac\u2203 i, e i = b\n\u22a2 \u2203 z,\n    (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 (e i)) (extend e f \u22a5 z) \u2227\n      (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 b) (extend e f \u22a5 z)\n---\ncase inr.intro.inr.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderBot \u03b1\ne : \u03b9 \u2192 \u03b2\nf : \u03b9 \u2192 \u03b1\nhf : Directed (fun x1 x2 => x1 \u2264 x2) f\nhe : Injective e\ni j : \u03b9\n\u22a2 \u2203 z,\n    (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 (e i)) (extend e f \u22a5 z) \u2227\n      (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 (e j)) (extend e f \u22a5 z)"}, {"line": "\u00b7 use e i\n    simp [Function.extend_apply' _ _ _ hb]", "tactic_state": "case inr.intro.inr.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderBot \u03b1\ne : \u03b9 \u2192 \u03b2\nf : \u03b9 \u2192 \u03b1\nhf : Directed (fun x1 x2 => x1 \u2264 x2) f\nhe : Injective e\ni j : \u03b9\n\u22a2 \u2203 z,\n    (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 (e i)) (extend e f \u22a5 z) \u2227\n      (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 (e j)) (extend e f \u22a5 z)"}, {"line": "rcases hf i j with \u27e8k, hi, hj\u27e9", "tactic_state": "case inr.intro.inr.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderBot \u03b1\ne : \u03b9 \u2192 \u03b2\nf : \u03b9 \u2192 \u03b1\nhf : Directed (fun x1 x2 => x1 \u2264 x2) f\nhe : Injective e\ni j k : \u03b9\nhi : f i \u2264 f k\nhj : f j \u2264 f k\n\u22a2 \u2203 z,\n    (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 (e i)) (extend e f \u22a5 z) \u2227\n      (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 (e j)) (extend e f \u22a5 z)"}, {"line": "use e k", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderBot \u03b1\ne : \u03b9 \u2192 \u03b2\nf : \u03b9 \u2192 \u03b1\nhf : Directed (fun x1 x2 => x1 \u2264 x2) f\nhe : Injective e\ni j k : \u03b9\nhi : f i \u2264 f k\nhj : f j \u2264 f k\n\u22a2 (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 (e i)) (extend e f \u22a5 (e k)) \u2227\n    (fun x1 x2 => x1 \u2264 x2) (extend e f \u22a5 (e j)) (extend e f \u22a5 (e k))"}, {"line": "simp only [he.extend_apply]", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderBot \u03b1\ne : \u03b9 \u2192 \u03b2\nf : \u03b9 \u2192 \u03b1\nhf : Directed (fun x1 x2 => x1 \u2264 x2) f\nhe : Injective e\ni j k : \u03b9\nhi : f i \u2264 f k\nhj : f j \u2264 f k\n\u22a2 f i \u2264 f k \u2227 f j \u2264 f k"}, {"line": "simp only [*]", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderBot \u03b1\ne : \u03b9 \u2192 \u03b2\nf : \u03b9 \u2192 \u03b1\nhf : Directed (fun x1 x2 => x1 \u2264 x2) f\nhe : Injective e\ni j k : \u03b9\nhi : f i \u2264 f k\nhj : f j \u2264 f k\n\u22a2 True \u2227 True"}, {"line": "simp only [true_and]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pi {d : (i : \u03b9) \u2192 Set (\u03b1 i)} (hd : \u2200 (i : \u03b9), DirectedOn (r i) (d i)) :\n    DirectedOn (fun x y => \u2200 i, r i (x i) (y i)) (Set.pi Set.univ d) := by\n  intro a ha b hb\n  choose f hfd haf hbf using fun i => hd i (a i) (ha i trivial) (b i) (hb i trivial)\n  exact \u27e8f, fun i _ => hfd i, haf, hbf\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Directed.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} (r r' s : \u03b1 \u2192 \u03b1 \u2192 Prop)", "{r r'}", "[Preorder \u03b1] {a : \u03b1}", "[PartialOrder \u03b2]", "[Nontrivial \u03b2]", "(\u03b2) in", "(\u03b2) in", "[Preorder \u03b1] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {r : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b1 i \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nr : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b1 i \u2192 Prop\nd : (i : \u03b9) \u2192 Set (\u03b1 i)\nhd : \u2200 (i : \u03b9), DirectedOn (r i) (d i)\n\u22a2 DirectedOn (fun x y => \u2200 (i : \u03b9), r i (x i) (y i)) (Set.univ.pi d)"}, {"line": "intro a ha b hb", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nr : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b1 i \u2192 Prop\nd : (i : \u03b9) \u2192 Set (\u03b1 i)\nhd : \u2200 (i : \u03b9), DirectedOn (r i) (d i)\na : (i : \u03b9) \u2192 \u03b1 i\nha : a \u2208 Set.univ.pi d\nb : (i : \u03b9) \u2192 \u03b1 i\nhb : b \u2208 Set.univ.pi d\n\u22a2 \u2203 z \u2208 Set.univ.pi d, (fun x y => \u2200 (i : \u03b9), r i (x i) (y i)) a z \u2227 (fun x y => \u2200 (i : \u03b9), r i (x i) (y i)) b z"}, {"line": "choose f hfd haf hbf using fun i => hd i (a i) (ha i trivial) (b i) (hb i trivial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nr : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b1 i \u2192 Prop\nd : (i : \u03b9) \u2192 Set (\u03b1 i)\nhd : \u2200 (i : \u03b9), DirectedOn (r i) (d i)\na : (i : \u03b9) \u2192 \u03b1 i\nha : a \u2208 Set.univ.pi d\nb : (i : \u03b9) \u2192 \u03b1 i\nhb : b \u2208 Set.univ.pi d\nf : (i : \u03b9) \u2192 \u03b1 i\nhfd : \u2200 (i : \u03b9), f i \u2208 d i\nhaf : \u2200 (i : \u03b9), r i (a i) (f i)\nhbf : \u2200 (i : \u03b9), r i (b i) (f i)\n\u22a2 \u2203 z \u2208 Set.univ.pi d, (fun x y => \u2200 (i : \u03b9), r i (x i) (y i)) a z \u2227 (fun x y => \u2200 (i : \u03b9), r i (x i) (y i)) b z"}, {"line": "exact \u27e8f, fun i _ => hfd i, haf, hbf\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_covBy_coe : (a : \u03b1) \u22d6 b \u2194 a \u22d6 b := by simp [covBy_iff_wcovBy_and_not_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Grade.lean", "context": {"open": ["Nat OrderDual"], "variables": ["{\ud835\udd46 \u2119 \u03b1 \u03b2 : Type*}", "[Preorder \ud835\udd46]", "[Preorder \u03b1]", "(\ud835\udd46)", "[GradeOrder \ud835\udd46 \u03b1] {a b : \u03b1}", "{\ud835\udd46}", "(\ud835\udd46)", "[GradeMinOrder \ud835\udd46 \u03b1] {a : \u03b1}", "{\ud835\udd46}", "(\ud835\udd46)", "[GradeMaxOrder \ud835\udd46 \u03b1] {a : \u03b1}", "{\ud835\udd46}", "[LinearOrder \u03b1] [GradeOrder \ud835\udd46 \u03b1] {a b : \u03b1}", "[PartialOrder \ud835\udd46] [Preorder \u03b1]", "[Preorder \ud835\udd46] [Preorder \u2119] [Preorder \u03b1] [Preorder \u03b2]", "[PartialOrder \u03b1] {s : Flag \u03b1} {a b : s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PartialOrder \u03b1\ns : Flag \u03b1\na b : \u21a5s\n\u22a2 \u2191a \u22d6 \u2191b \u2194 a \u22d6 b"}, {"line": "simp [covBy_iff_wcovBy_and_not_le]", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PartialOrder \u03b1\ns : Flag \u03b1\na b : \u21a5s\n\u22a2 \u2191a \u2a7f \u2191b \u2227 \u00acb \u2264 a \u2194 a \u22d6 b"}]}
{"declaration": "theorem le_iff_exists_sup : a \u2264 b \u2194 \u2203 c, b = a \u2294 c := by\n  constructor\n  \u00b7 intro h\n    exact \u27e8b, (sup_eq_right.mpr h).symm\u27e9\n  \u00b7 rintro \u27e8c, rfl : _ = _ \u2294 _\u27e9\n    exact le_sup_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Lattice.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[SemilatticeSup \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : SemilatticeSup \u03b1\na b : \u03b1\n\u22a2 a \u2264 b \u2194 \u2203 c, b = a \u2294 c"}, {"line": "constructor", "tactic_state": "case mp\n\u03b1 : Type u\ninst\u271d : SemilatticeSup \u03b1\na b : \u03b1\n\u22a2 a \u2264 b \u2192 \u2203 c, b = a \u2294 c\n---\ncase mpr\n\u03b1 : Type u\ninst\u271d : SemilatticeSup \u03b1\na b : \u03b1\n\u22a2 (\u2203 c, b = a \u2294 c) \u2192 a \u2264 b"}, {"line": "\u00b7 intro h\n    exact \u27e8b, (sup_eq_right.mpr h).symm\u27e9", "tactic_state": "case mpr\n\u03b1 : Type u\ninst\u271d : SemilatticeSup \u03b1\na b : \u03b1\n\u22a2 (\u2203 c, b = a \u2294 c) \u2192 a \u2264 b"}, {"line": "\u00b7 rintro \u27e8c, rfl : _ = _ \u2294 _\u27e9\n    exact le_sup_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_idem (a : \u03b1) : a \u2294 a = a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Lattice.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[SemilatticeSup \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : SemilatticeSup \u03b1\na : \u03b1\n\u22a2 a \u2294 a = a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_left_idem (a b : \u03b1) : a \u2294 (a \u2294 b) = a \u2294 b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Lattice.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[SemilatticeSup \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : SemilatticeSup \u03b1\na b : \u03b1\n\u22a2 a \u2294 (a \u2294 b) = a \u2294 b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_right_idem (a b : \u03b1) : a \u2294 b \u2294 b = a \u2294 b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Lattice.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[SemilatticeSup \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : SemilatticeSup \u03b1\na b : \u03b1\n\u22a2 a \u2294 b \u2294 b = a \u2294 b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_sup_distrib_left (a b c : \u03b1) : a \u2294 (b \u2294 c) = a \u2294 b \u2294 (a \u2294 c) := by\n  rw [sup_sup_sup_comm]\n  rw [sup_idem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Lattice.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[SemilatticeSup \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : SemilatticeSup \u03b1\na b c : \u03b1\n\u22a2 a \u2294 (b \u2294 c) = a \u2294 b \u2294 (a \u2294 c)"}, {"line": "rw [sup_sup_sup_comm]", "tactic_state": "\u03b1 : Type u\ninst\u271d : SemilatticeSup \u03b1\na b c : \u03b1\n\u22a2 a \u2294 (b \u2294 c) = a \u2294 a \u2294 (b \u2294 c)"}, {"line": "rw [sup_idem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_sup_distrib_right (a b c : \u03b1) : a \u2294 b \u2294 c = a \u2294 c \u2294 (b \u2294 c) := by\n  rw [sup_sup_sup_comm]\n  rw [sup_idem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Lattice.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[SemilatticeSup \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : SemilatticeSup \u03b1\na b c : \u03b1\n\u22a2 a \u2294 b \u2294 c = a \u2294 c \u2294 (b \u2294 c)"}, {"line": "rw [sup_sup_sup_comm]", "tactic_state": "\u03b1 : Type u\ninst\u271d : SemilatticeSup \u03b1\na b c : \u03b1\n\u22a2 a \u2294 b \u2294 c = a \u2294 b \u2294 (c \u2294 c)"}, {"line": "rw [sup_idem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_left_idem (a b : \u03b1) : a \u2293 (a \u2293 b) = a \u2293 b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Lattice.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[SemilatticeSup \u03b1] {a b c d : \u03b1}", "[SemilatticeInf \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : SemilatticeInf \u03b1\na b : \u03b1\n\u22a2 a \u2293 (a \u2293 b) = a \u2293 b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_right_idem (a b : \u03b1) : a \u2293 b \u2293 b = a \u2293 b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Lattice.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[SemilatticeSup \u03b1] {a b c d : \u03b1}", "[SemilatticeInf \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : SemilatticeInf \u03b1\na b : \u03b1\n\u22a2 a \u2293 b \u2293 b = a \u2293 b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_le_inf : a \u2294 b \u2264 a \u2293 b \u2194 a = b := by simp [le_antisymm_iff, and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Lattice.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[SemilatticeSup \u03b1] {a b c d : \u03b1}", "[SemilatticeInf \u03b1] {a b c d : \u03b1}", "[Lattice \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : Lattice \u03b1\na b : \u03b1\n\u22a2 a \u2294 b \u2264 a \u2293 b \u2194 a = b"}, {"line": "simp [le_antisymm_iff, and_comm]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : Lattice \u03b1\na b : \u03b1\n\u22a2 a \u2294 b \u2264 a \u2227 a \u2294 b \u2264 b \u2194 a = b"}]}
{"declaration": "theorem inf_sup_self : a \u2293 (a \u2294 b) = a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Lattice.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[SemilatticeSup \u03b1] {a b c d : \u03b1}", "[SemilatticeInf \u03b1] {a b c d : \u03b1}", "[Lattice \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : Lattice \u03b1\na b : \u03b1\n\u22a2 a \u2293 (a \u2294 b) = a"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : Lattice \u03b1\na b : \u03b1\n\u22a2 a \u2264 a \u2294 b"}]}
{"declaration": "theorem sup_inf_self : a \u2294 a \u2293 b = a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Lattice.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[SemilatticeSup \u03b1] {a b c d : \u03b1}", "[SemilatticeInf \u03b1] {a b c d : \u03b1}", "[Lattice \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : Lattice \u03b1\na b : \u03b1\n\u22a2 a \u2294 a \u2293 b = a"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : Lattice \u03b1\na b : \u03b1\n\u22a2 a \u2293 b \u2264 a"}]}
{"declaration": "theorem Lattice.ext {\u03b1} {A B : Lattice \u03b1} (H : \u2200 x y : \u03b1, (haveI := A; x \u2264 y) \u2194 x \u2264 y) :\n    A = B := by\n  cases A\n  cases B\n  cases SemilatticeSup.ext H\n  cases SemilatticeInf.ext H\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Lattice.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[SemilatticeSup \u03b1] {a b c d : \u03b1}", "[SemilatticeInf \u03b1] {a b c d : \u03b1}", "[Lattice \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nA B : Lattice \u03b1\nH : \u2200 (x y : \u03b1), x \u2264 y \u2194 x \u2264 y\n\u22a2 A = B"}, {"line": "cases A", "tactic_state": "case mk\n\u03b1 : Type u_1\nB : Lattice \u03b1\ntoSemilatticeSup\u271d : SemilatticeSup \u03b1\ninf\u271d : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninf_le_left\u271d : \u2200 (a b : \u03b1), inf\u271d a b \u2264 a\ninf_le_right\u271d : \u2200 (a b : \u03b1), inf\u271d a b \u2264 b\nle_inf\u271d : \u2200 (a b c : \u03b1), a \u2264 b \u2192 a \u2264 c \u2192 a \u2264 inf\u271d b c\nH : \u2200 (x y : \u03b1), x \u2264 y \u2194 x \u2264 y\n\u22a2 { toSemilatticeSup := toSemilatticeSup\u271d, inf := inf\u271d, inf_le_left := inf_le_left\u271d, inf_le_right := inf_le_right\u271d,\n      le_inf := le_inf\u271d } =\n    B"}, {"line": "cases B", "tactic_state": "case mk.mk\n\u03b1 : Type u_1\ntoSemilatticeSup\u271d\u00b9 : SemilatticeSup \u03b1\ninf\u271d\u00b9 : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninf_le_left\u271d\u00b9 : \u2200 (a b : \u03b1), inf\u271d\u00b9 a b \u2264 a\ninf_le_right\u271d\u00b9 : \u2200 (a b : \u03b1), inf\u271d\u00b9 a b \u2264 b\nle_inf\u271d\u00b9 : \u2200 (a b c : \u03b1), a \u2264 b \u2192 a \u2264 c \u2192 a \u2264 inf\u271d\u00b9 b c\ntoSemilatticeSup\u271d : SemilatticeSup \u03b1\ninf\u271d : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninf_le_left\u271d : \u2200 (a b : \u03b1), inf\u271d a b \u2264 a\ninf_le_right\u271d : \u2200 (a b : \u03b1), inf\u271d a b \u2264 b\nle_inf\u271d : \u2200 (a b c : \u03b1), a \u2264 b \u2192 a \u2264 c \u2192 a \u2264 inf\u271d b c\nH : \u2200 (x y : \u03b1), x \u2264 y \u2194 x \u2264 y\n\u22a2 { toSemilatticeSup := toSemilatticeSup\u271d\u00b9, inf := inf\u271d\u00b9, inf_le_left := inf_le_left\u271d\u00b9, inf_le_right := inf_le_right\u271d\u00b9,\n      le_inf := le_inf\u271d\u00b9 } =\n    { toSemilatticeSup := toSemilatticeSup\u271d, inf := inf\u271d, inf_le_left := inf_le_left\u271d, inf_le_right := inf_le_right\u271d,\n      le_inf := le_inf\u271d }"}, {"line": "cases SemilatticeSup.ext H", "tactic_state": "case mk.mk.refl\n\u03b1 : Type u_1\ntoSemilatticeSup\u271d : SemilatticeSup \u03b1\ninf\u271d\u00b9 : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninf_le_left\u271d\u00b9 : \u2200 (a b : \u03b1), inf\u271d\u00b9 a b \u2264 a\ninf_le_right\u271d\u00b9 : \u2200 (a b : \u03b1), inf\u271d\u00b9 a b \u2264 b\nle_inf\u271d\u00b9 : \u2200 (a b c : \u03b1), a \u2264 b \u2192 a \u2264 c \u2192 a \u2264 inf\u271d\u00b9 b c\ninf\u271d : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninf_le_left\u271d : \u2200 (a b : \u03b1), inf\u271d a b \u2264 a\ninf_le_right\u271d : \u2200 (a b : \u03b1), inf\u271d a b \u2264 b\nle_inf\u271d : \u2200 (a b c : \u03b1), a \u2264 b \u2192 a \u2264 c \u2192 a \u2264 inf\u271d b c\nH : \u2200 (x y : \u03b1), x \u2264 y \u2194 x \u2264 y\n\u22a2 { toSemilatticeSup := toSemilatticeSup\u271d, inf := inf\u271d\u00b9, inf_le_left := inf_le_left\u271d\u00b9, inf_le_right := inf_le_right\u271d\u00b9,\n      le_inf := le_inf\u271d\u00b9 } =\n    { toSemilatticeSup := toSemilatticeSup, inf := inf\u271d, inf_le_left := inf_le_left\u271d, inf_le_right := inf_le_right\u271d,\n      le_inf := le_inf\u271d }"}, {"line": "cases SemilatticeInf.ext H", "tactic_state": "case mk.mk.refl.refl\n\u03b1 : Type u_1\ntoSemilatticeSup\u271d : SemilatticeSup \u03b1\ninf\u271d : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninf_le_left\u271d\u00b9 : \u2200 (a b : \u03b1), inf\u271d a b \u2264 a\ninf_le_right\u271d\u00b9 : \u2200 (a b : \u03b1), inf\u271d a b \u2264 b\nle_inf\u271d\u00b9 : \u2200 (a b c : \u03b1), a \u2264 b \u2192 a \u2264 c \u2192 a \u2264 inf\u271d b c\ninf_le_left\u271d : \u2200 (a b : \u03b1), inf\u271d a b \u2264 a\ninf_le_right\u271d : \u2200 (a b : \u03b1), inf\u271d a b \u2264 b\nle_inf\u271d : \u2200 (a b c : \u03b1), a \u2264 b \u2192 a \u2264 c \u2192 a \u2264 inf\u271d b c\nH : \u2200 (x y : \u03b1), x \u2264 y \u2194 x \u2264 y\n\u22a2 { toSemilatticeSup := toSemilatticeSup\u271d, inf := inf\u271d, inf_le_left := inf_le_left\u271d\u00b9, inf_le_right := inf_le_right\u271d\u00b9,\n      le_inf := le_inf\u271d\u00b9 } =\n    { toSemilatticeSup := toSemilatticeSup, inf := inf\u271d, inf_le_left := inf_le_left\u271d, inf_le_right := inf_le_right\u271d,\n      le_inf := le_inf\u271d }"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_eq_maxDefault [SemilatticeSup \u03b1] [DecidableLE \u03b1] [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] :\n    (\u00b7 \u2294 \u00b7) = (maxDefault : \u03b1 \u2192 \u03b1 \u2192 \u03b1) := by\n  ext x y\n  unfold maxDefault\n  split_ifs with h'\n  exacts [sup_of_le_right h', sup_of_le_left <| (total_of (\u00b7 \u2264 \u00b7) x y).resolve_left h']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Lattice.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[SemilatticeSup \u03b1] {a b c d : \u03b1}", "[SemilatticeInf \u03b1] {a b c d : \u03b1}", "[Lattice \u03b1] {a b c : \u03b1}", "[DistribLattice \u03b1] {x y z : \u03b1}", "[LinearOrder \u03b1] {a b c d : \u03b1}", "(a b c d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2077 : SemilatticeSup \u03b1\ninst\u271d\u2076 : SemilatticeInf \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : DistribLattice \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\n\u22a2 (fun x1 x2 => x1 \u2294 x2) = maxDefault"}, {"line": "ext x y", "tactic_state": "case h.h\n\u03b1 : Type u\ninst\u271d\u2077 : SemilatticeSup \u03b1\ninst\u271d\u2076 : SemilatticeInf \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : DistribLattice \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\nx y : \u03b1\n\u22a2 x \u2294 y = maxDefault x y"}, {"line": "unfold maxDefault", "tactic_state": "case h.h\n\u03b1 : Type u\ninst\u271d\u2077 : SemilatticeSup \u03b1\ninst\u271d\u2076 : SemilatticeInf \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : DistribLattice \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\nx y : \u03b1\n\u22a2 x \u2294 y = if x \u2264 y then y else x"}, {"line": "split_ifs with h'", "tactic_state": "case pos\n\u03b1 : Type u\ninst\u271d\u2077 : SemilatticeSup \u03b1\ninst\u271d\u2076 : SemilatticeInf \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : DistribLattice \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\nx y : \u03b1\nh' : x \u2264 y\n\u22a2 x \u2294 y = y\n---\ncase neg\n\u03b1 : Type u\ninst\u271d\u2077 : SemilatticeSup \u03b1\ninst\u271d\u2076 : SemilatticeInf \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : DistribLattice \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\nx y : \u03b1\nh' : \u00acx \u2264 y\n\u22a2 x \u2294 y = x"}, {"line": "exacts [sup_of_le_right h', sup_of_le_left <| (total_of (\u00b7 \u2264 \u00b7) x y).resolve_left h']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_eq_minDefault [SemilatticeInf \u03b1] [DecidableLE \u03b1] [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] :\n    (\u00b7 \u2293 \u00b7) = (minDefault : \u03b1 \u2192 \u03b1 \u2192 \u03b1) := by\n  ext x y\n  unfold minDefault\n  split_ifs with h'\n  exacts [inf_of_le_left h', inf_of_le_right <| (total_of (\u00b7 \u2264 \u00b7) x y).resolve_left h']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Lattice.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[SemilatticeSup \u03b1] {a b c d : \u03b1}", "[SemilatticeInf \u03b1] {a b c d : \u03b1}", "[Lattice \u03b1] {a b c : \u03b1}", "[DistribLattice \u03b1] {x y z : \u03b1}", "[LinearOrder \u03b1] {a b c d : \u03b1}", "(a b c d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2077 : SemilatticeSup \u03b1\ninst\u271d\u2076 : SemilatticeInf \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : DistribLattice \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\n\u22a2 (fun x1 x2 => x1 \u2293 x2) = minDefault"}, {"line": "ext x y", "tactic_state": "case h.h\n\u03b1 : Type u\ninst\u271d\u2077 : SemilatticeSup \u03b1\ninst\u271d\u2076 : SemilatticeInf \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : DistribLattice \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\nx y : \u03b1\n\u22a2 x \u2293 y = minDefault x y"}, {"line": "unfold minDefault", "tactic_state": "case h.h\n\u03b1 : Type u\ninst\u271d\u2077 : SemilatticeSup \u03b1\ninst\u271d\u2076 : SemilatticeInf \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : DistribLattice \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\nx y : \u03b1\n\u22a2 x \u2293 y = if x \u2264 y then x else y"}, {"line": "split_ifs with h'", "tactic_state": "case pos\n\u03b1 : Type u\ninst\u271d\u2077 : SemilatticeSup \u03b1\ninst\u271d\u2076 : SemilatticeInf \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : DistribLattice \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\nx y : \u03b1\nh' : x \u2264 y\n\u22a2 x \u2293 y = x\n---\ncase neg\n\u03b1 : Type u\ninst\u271d\u2077 : SemilatticeSup \u03b1\ninst\u271d\u2076 : SemilatticeInf \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : DistribLattice \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\nx y : \u03b1\nh' : \u00acx \u2264 y\n\u22a2 x \u2293 y = y"}, {"line": "exacts [inf_of_le_left h', inf_of_le_right <| (total_of (\u00b7 \u2264 \u00b7) x y).resolve_left h']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_map_inf_le_left [SemilatticeInf \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (h : \u2200 x y, f (x \u2293 y) \u2264 f x) : Monotone f := by\n  intro x y hxy\n  rw [\u2190 inf_eq_right.2 hxy]\n  apply h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Lattice.lean", "context": {"open": ["OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[SemilatticeSup \u03b1] {a b c d : \u03b1}", "[SemilatticeInf \u03b1] {a b c d : \u03b1}", "[Lattice \u03b1] {a b c : \u03b1}", "[DistribLattice \u03b1] {x y z : \u03b1}", "[LinearOrder \u03b1] {a b c d : \u03b1}", "(a b c d)", "[LinearOrder \u03b1]", "{\u03b9 : Type*} {\u03b1' : \u03b9 \u2192 Type*}", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2077 : SemilatticeSup \u03b1\ninst\u271d\u2076 : SemilatticeInf \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : DistribLattice \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x y : \u03b1), f (x \u2293 y) \u2264 f x\n\u22a2 Monotone f"}, {"line": "intro x y hxy", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2077 : SemilatticeSup \u03b1\ninst\u271d\u2076 : SemilatticeInf \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : DistribLattice \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x y : \u03b1), f (x \u2293 y) \u2264 f x\nx y : \u03b1\nhxy : x \u2264 y\n\u22a2 f x \u2264 f y"}, {"line": "rw [\u2190 inf_eq_right.2 hxy]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2077 : SemilatticeSup \u03b1\ninst\u271d\u2076 : SemilatticeInf \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : DistribLattice \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x y : \u03b1), f (x \u2293 y) \u2264 f x\nx y : \u03b1\nhxy : x \u2264 y\n\u22a2 f (y \u2293 x) \u2264 f y"}, {"line": "apply h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem covBy_sup_of_inf_covBy_of_inf_covBy_right : a \u2293 b \u22d6 a \u2192 a \u2293 b \u22d6 b \u2192 b \u22d6 a \u2294 b := by\n  rw [inf_comm]\n  rw [sup_comm]\n  exact fun ha hb => covBy_sup_of_inf_covBy_of_inf_covBy_left hb ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ModularLattice.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Lattice \u03b1] [IsWeakUpperModularLattice \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsWeakUpperModularLattice \u03b1\na b : \u03b1\n\u22a2 a \u2293 b \u22d6 a \u2192 a \u2293 b \u22d6 b \u2192 b \u22d6 a \u2294 b"}, {"line": "rw [inf_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsWeakUpperModularLattice \u03b1\na b : \u03b1\n\u22a2 b \u2293 a \u22d6 a \u2192 b \u2293 a \u22d6 b \u2192 b \u22d6 a \u2294 b"}, {"line": "rw [sup_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsWeakUpperModularLattice \u03b1\na b : \u03b1\n\u22a2 b \u2293 a \u22d6 a \u2192 b \u2293 a \u22d6 b \u2192 b \u22d6 b \u2294 a"}, {"line": "exact fun ha hb => covBy_sup_of_inf_covBy_of_inf_covBy_left hb ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_covBy_of_covBy_sup_of_covBy_sup_right : a \u22d6 a \u2294 b \u2192 b \u22d6 a \u2294 b \u2192 a \u2293 b \u22d6 b := by\n  rw [sup_comm]\n  rw [inf_comm]\n  exact fun ha hb => inf_covBy_of_covBy_sup_of_covBy_sup_left hb ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ModularLattice.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Lattice \u03b1] [IsWeakUpperModularLattice \u03b1] {a b : \u03b1}", "[Lattice \u03b1] [IsWeakLowerModularLattice \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Lattice \u03b1\ninst\u271d\u00b2 : IsWeakUpperModularLattice \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsWeakLowerModularLattice \u03b1\na b : \u03b1\n\u22a2 a \u22d6 a \u2294 b \u2192 b \u22d6 a \u2294 b \u2192 a \u2293 b \u22d6 b"}, {"line": "rw [sup_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Lattice \u03b1\ninst\u271d\u00b2 : IsWeakUpperModularLattice \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsWeakLowerModularLattice \u03b1\na b : \u03b1\n\u22a2 a \u22d6 b \u2294 a \u2192 b \u22d6 b \u2294 a \u2192 a \u2293 b \u22d6 b"}, {"line": "rw [inf_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Lattice \u03b1\ninst\u271d\u00b2 : IsWeakUpperModularLattice \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsWeakLowerModularLattice \u03b1\na b : \u03b1\n\u22a2 a \u22d6 b \u2294 a \u2192 b \u22d6 b \u2294 a \u2192 b \u2293 a \u22d6 b"}, {"line": "exact fun ha hb => inf_covBy_of_covBy_sup_of_covBy_sup_left hb ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem covBy_sup_of_inf_covBy_right : a \u2293 b \u22d6 b \u2192 a \u22d6 a \u2294 b := by\n  rw [sup_comm]\n  rw [inf_comm]\n  exact covBy_sup_of_inf_covBy_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ModularLattice.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Lattice \u03b1] [IsWeakUpperModularLattice \u03b1] {a b : \u03b1}", "[Lattice \u03b1] [IsWeakLowerModularLattice \u03b1] {a b : \u03b1}", "[Lattice \u03b1] [IsUpperModularLattice \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : IsWeakUpperModularLattice \u03b1\ninst\u271d\u00b3 : Lattice \u03b1\ninst\u271d\u00b2 : IsWeakLowerModularLattice \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsUpperModularLattice \u03b1\na b : \u03b1\n\u22a2 a \u2293 b \u22d6 b \u2192 a \u22d6 a \u2294 b"}, {"line": "rw [sup_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : IsWeakUpperModularLattice \u03b1\ninst\u271d\u00b3 : Lattice \u03b1\ninst\u271d\u00b2 : IsWeakLowerModularLattice \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsUpperModularLattice \u03b1\na b : \u03b1\n\u22a2 a \u2293 b \u22d6 b \u2192 a \u22d6 b \u2294 a"}, {"line": "rw [inf_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : IsWeakUpperModularLattice \u03b1\ninst\u271d\u00b3 : Lattice \u03b1\ninst\u271d\u00b2 : IsWeakLowerModularLattice \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsUpperModularLattice \u03b1\na b : \u03b1\n\u22a2 b \u2293 a \u22d6 b \u2192 a \u22d6 b \u2294 a"}, {"line": "exact covBy_sup_of_inf_covBy_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_covBy_of_covBy_sup_right : b \u22d6 a \u2294 b \u2192 a \u2293 b \u22d6 a := by\n  rw [inf_comm]\n  rw [sup_comm]\n  exact inf_covBy_of_covBy_sup_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ModularLattice.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Lattice \u03b1] [IsWeakUpperModularLattice \u03b1] {a b : \u03b1}", "[Lattice \u03b1] [IsWeakLowerModularLattice \u03b1] {a b : \u03b1}", "[Lattice \u03b1] [IsUpperModularLattice \u03b1] {a b : \u03b1}", "[Lattice \u03b1] [IsLowerModularLattice \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : Lattice \u03b1\ninst\u271d\u2076 : IsWeakUpperModularLattice \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : IsWeakLowerModularLattice \u03b1\ninst\u271d\u00b3 : Lattice \u03b1\ninst\u271d\u00b2 : IsUpperModularLattice \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsLowerModularLattice \u03b1\na b : \u03b1\n\u22a2 b \u22d6 a \u2294 b \u2192 a \u2293 b \u22d6 a"}, {"line": "rw [inf_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : Lattice \u03b1\ninst\u271d\u2076 : IsWeakUpperModularLattice \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : IsWeakLowerModularLattice \u03b1\ninst\u271d\u00b3 : Lattice \u03b1\ninst\u271d\u00b2 : IsUpperModularLattice \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsLowerModularLattice \u03b1\na b : \u03b1\n\u22a2 b \u22d6 a \u2294 b \u2192 b \u2293 a \u22d6 a"}, {"line": "rw [sup_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : Lattice \u03b1\ninst\u271d\u2076 : IsWeakUpperModularLattice \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : IsWeakLowerModularLattice \u03b1\ninst\u271d\u00b3 : Lattice \u03b1\ninst\u271d\u00b2 : IsUpperModularLattice \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsLowerModularLattice \u03b1\na b : \u03b1\n\u22a2 b \u22d6 b \u2294 a \u2192 b \u2293 a \u22d6 a"}, {"line": "exact inf_covBy_of_covBy_sup_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem surjOn (f : r \u227ai s) : Set.SurjOn f Set.univ { b | s b f.top } := by\n  intro b h\n  simpa using mem_range_of_rel_top _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/InitialSeg.lean", "context": {"open": ["Function", "scoped InitialSeg"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : PrincipalSeg r s\n\u22a2 Set.SurjOn (\u21d1f.toRelEmbedding) Set.univ {b | s b f.top}"}, {"line": "intro b h", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : PrincipalSeg r s\nb : \u03b2\nh : b \u2208 {b | s b f.top}\n\u22a2 b \u2208 \u21d1f.toRelEmbedding '' Set.univ"}, {"line": "simpa using mem_range_of_rel_top _ h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLowerSet_range [LT \u03b1] (f : \u03b1 \u2264i \u03b2) : IsLowerSet (Set.range f) := by\n  rintro _ b h \u27e8a, rfl\u27e9\n  exact mem_range_of_le f h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/InitialSeg.lean", "context": {"open": ["Function", "scoped InitialSeg", "Classical in"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "[PartialOrder \u03b2] {a a' : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03b1 : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b2\ninst\u271d : LT \u03b1\nf : InitialSeg (fun x1 x2 => x1 < x2) fun x1 x2 => x1 < x2\n\u22a2 IsLowerSet (Set.range \u21d1f)"}, {"line": "rintro _ b h \u27e8a, rfl\u27e9", "tactic_state": "case intro\n\u03b2 : Type u_2\n\u03b1 : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b2\ninst\u271d : LT \u03b1\nf : InitialSeg (fun x1 x2 => x1 < x2) fun x1 x2 => x1 < x2\nb : \u03b2\na : \u03b1\nh : b \u2264 f a\n\u22a2 b \u2208 Set.range \u21d1f"}, {"line": "exact mem_range_of_le f h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma subset_of_eq_of_subset (hab : a = b) (hbc : b \u2286 c) : a \u2286 c := by rwa [hab]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelClasses.lean", "context": {"open": ["Function", "PSigma", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "(r) [IsWellFounded \u03b1 r]", "[LT \u03b1] [WellFoundedLT \u03b1]", "[LT \u03b1] [WellFoundedGT \u03b1]", "[HasSubset \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : LT \u03b1\ninst\u271d\u00b3 : WellFoundedLT \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : WellFoundedGT \u03b1\ninst\u271d : HasSubset \u03b1\na b c : \u03b1\nhab : a = b\nhbc : b \u2286 c\n\u22a2 a \u2286 c"}, {"line": "rwa [hab]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma subset_of_subset_of_eq (hab : a \u2286 b) (hbc : b = c) : a \u2286 c := by rwa [\u2190 hbc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelClasses.lean", "context": {"open": ["Function", "PSigma", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "(r) [IsWellFounded \u03b1 r]", "[LT \u03b1] [WellFoundedLT \u03b1]", "[LT \u03b1] [WellFoundedGT \u03b1]", "[HasSubset \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : LT \u03b1\ninst\u271d\u00b3 : WellFoundedLT \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : WellFoundedGT \u03b1\ninst\u271d : HasSubset \u03b1\na b c : \u03b1\nhab : a \u2286 b\nhbc : b = c\n\u22a2 a \u2286 c"}, {"line": "rwa [\u2190 hbc]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ssubset_of_eq_of_ssubset (hab : a = b) (hbc : b \u2282 c) : a \u2282 c := by rwa [hab]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelClasses.lean", "context": {"open": ["Function", "PSigma", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "(r) [IsWellFounded \u03b1 r]", "[LT \u03b1] [WellFoundedLT \u03b1]", "[LT \u03b1] [WellFoundedGT \u03b1]", "[HasSubset \u03b1] {a b c : \u03b1}", "[HasSSubset \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : LT \u03b1\ninst\u271d\u2074 : WellFoundedLT \u03b1\ninst\u271d\u00b3 : LT \u03b1\ninst\u271d\u00b2 : WellFoundedGT \u03b1\ninst\u271d\u00b9 : HasSubset \u03b1\ninst\u271d : HasSSubset \u03b1\na b c : \u03b1\nhab : a = b\nhbc : b \u2282 c\n\u22a2 a \u2282 c"}, {"line": "rwa [hab]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ssubset_of_ssubset_of_eq (hab : a \u2282 b) (hbc : b = c) : a \u2282 c := by rwa [\u2190 hbc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelClasses.lean", "context": {"open": ["Function", "PSigma", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "(r) [IsWellFounded \u03b1 r]", "[LT \u03b1] [WellFoundedLT \u03b1]", "[LT \u03b1] [WellFoundedGT \u03b1]", "[HasSubset \u03b1] {a b c : \u03b1}", "[HasSSubset \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : LT \u03b1\ninst\u271d\u2074 : WellFoundedLT \u03b1\ninst\u271d\u00b3 : LT \u03b1\ninst\u271d\u00b2 : WellFoundedGT \u03b1\ninst\u271d\u00b9 : HasSubset \u03b1\ninst\u271d : HasSSubset \u03b1\na b c : \u03b1\nhab : a \u2282 b\nhbc : b = c\n\u22a2 a \u2282 c"}, {"line": "rwa [\u2190 hbc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem seq_lt_seq_of_lt_of_le (hf : Monotone f) (n : \u2115) (h\u2080 : x 0 < y 0)\n    (hx : \u2200 k < n, x (k + 1) < f (x k)) (hy : \u2200 k < n, f (y k) \u2264 y (k + 1)) : x n < y n := by\n  cases n\n  exacts [h\u2080, hf.seq_pos_lt_seq_of_lt_of_le (Nat.zero_lt_succ _) h\u2080.le hx hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Iterate.lean", "context": {"open": ["Function", "Function (Commute)"], "variables": ["{\u03b1 : Type*} [Preorder \u03b1] {f : \u03b1 \u2192 \u03b1} {x y : \u2115 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nf : \u03b1 \u2192 \u03b1\nx y : \u2115 \u2192 \u03b1\nhf : Monotone f\nn : \u2115\nh\u2080 : x 0 < y 0\nhx : \u2200 k < n, x (k + 1) < f (x k)\nhy : \u2200 k < n, f (y k) \u2264 y (k + 1)\n\u22a2 x n < y n"}, {"line": "cases n", "tactic_state": "case zero\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nf : \u03b1 \u2192 \u03b1\nx y : \u2115 \u2192 \u03b1\nhf : Monotone f\nh\u2080 : x 0 < y 0\nhx : \u2200 k < 0, x (k + 1) < f (x k)\nhy : \u2200 k < 0, f (y k) \u2264 y (k + 1)\n\u22a2 x 0 < y 0\n---\ncase succ\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nf : \u03b1 \u2192 \u03b1\nx y : \u2115 \u2192 \u03b1\nhf : Monotone f\nh\u2080 : x 0 < y 0\nn\u271d : \u2115\nhx : \u2200 k < n\u271d + 1, x (k + 1) < f (x k)\nhy : \u2200 k < n\u271d + 1, f (y k) \u2264 y (k + 1)\n\u22a2 x (n\u271d + 1) < y (n\u271d + 1)"}, {"line": "exacts [h\u2080, hf.seq_pos_lt_seq_of_lt_of_le (Nat.zero_lt_succ _) h\u2080.le hx hy]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem id_le_iterate_of_id_le (h : id \u2264 f) (n : \u2115) : id \u2264 f^[n] := by\n  simpa only [iterate_id] using monotone_id.iterate_le_of_le h n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Iterate.lean", "context": {"open": ["Function", "Function (Commute)", "Function"], "variables": ["{\u03b1 : Type*} [Preorder \u03b1] {f : \u03b1 \u2192 \u03b1} {x y : \u2115 \u2192 \u03b1}", "{\u03b2 : Type*} {g : \u03b2 \u2192 \u03b2} {h : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type*} [Preorder \u03b1] {f : \u03b1 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : Preorder \u03b1\nf : \u03b1 \u2192 \u03b1\nh : id \u2264 f\nn : \u2115\n\u22a2 id \u2264 f^[n]"}, {"line": "simpa only [iterate_id] using monotone_id.iterate_le_of_le h n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iterate_pos_le_iff_map_le (h : Commute f g) (hf : Monotone f) (hg : StrictMono g) {x n}\n    (hn : 0 < n) : f^[n] x \u2264 g^[n] x \u2194 f x \u2264 g x := by\n  simpa only [not_lt] using not_congr (h.symm.iterate_pos_lt_iff_map_lt' hg hf hn)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Iterate.lean", "context": {"open": ["Function", "Function (Commute)", "Function"], "variables": ["{\u03b1 : Type*} [Preorder \u03b1] {f : \u03b1 \u2192 \u03b1} {x y : \u2115 \u2192 \u03b1}", "{\u03b2 : Type*} {g : \u03b2 \u2192 \u03b2} {h : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type*} [Preorder \u03b1] {f : \u03b1 \u2192 \u03b1}", "{\u03b1 : Type*} [Preorder \u03b1] {f g : \u03b1 \u2192 \u03b1}", "{\u03b1 : Type*} [LinearOrder \u03b1] {f g : \u03b1 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d : LinearOrder \u03b1\nf g : \u03b1 \u2192 \u03b1\nh : Function.Commute f g\nhf : Monotone f\nhg : StrictMono g\nx : \u03b1\nn : \u2115\nhn : 0 < n\n\u22a2 f^[n] x \u2264 g^[n] x \u2194 f x \u2264 g x"}, {"line": "simpa only [not_lt] using not_congr (h.symm.iterate_pos_lt_iff_map_lt' hg hf hn)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iterate_pos_le_iff_map_le' (h : Commute f g) (hf : StrictMono f) (hg : Monotone g) {x n}\n    (hn : 0 < n) : f^[n] x \u2264 g^[n] x \u2194 f x \u2264 g x := by\n  simpa only [not_lt] using not_congr (h.symm.iterate_pos_lt_iff_map_lt hg hf hn)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Iterate.lean", "context": {"open": ["Function", "Function (Commute)", "Function"], "variables": ["{\u03b1 : Type*} [Preorder \u03b1] {f : \u03b1 \u2192 \u03b1} {x y : \u2115 \u2192 \u03b1}", "{\u03b2 : Type*} {g : \u03b2 \u2192 \u03b2} {h : \u03b2 \u2192 \u03b1}", "{\u03b1 : Type*} [Preorder \u03b1] {f : \u03b1 \u2192 \u03b1}", "{\u03b1 : Type*} [Preorder \u03b1] {f g : \u03b1 \u2192 \u03b1}", "{\u03b1 : Type*} [LinearOrder \u03b1] {f g : \u03b1 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d : LinearOrder \u03b1\nf g : \u03b1 \u2192 \u03b1\nh : Function.Commute f g\nhf : StrictMono f\nhg : Monotone g\nx : \u03b1\nn : \u2115\nhn : 0 < n\n\u22a2 f^[n] x \u2264 g^[n] x \u2194 f x \u2264 g x"}, {"line": "simpa only [not_lt] using not_congr (h.symm.iterate_pos_lt_iff_map_lt hg hf hn)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rev_index_le_coheight (p : LTSeries \u03b1) (i : Fin (p.length + 1)) : i.rev \u2264 coheight (p i) := by\n  simpa using index_le_height (\u03b1 := \u03b1\u1d52\u1d48) p.reverse i.rev\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/KrullDimension.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nx\u271d : Sort u_3\ncoheight : x\u271d\np : LTSeries \u03b1\ni : Fin (p.length + 1)\n\u22a2 i.rev \u2264 sorry"}, {"line": "simpa using index_le_height (\u03b1 := \u03b1\u1d52\u1d48) p.reverse i.rev", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coheight_eq_index_of_length_eq_head_coheight {p : LTSeries \u03b1} (h : p.length = coheight p.head)\n    (i : Fin (p.length + 1)) : coheight (p i) = i.rev := by\n  simpa using height_eq_index_of_length_eq_height_last (\u03b1 := \u03b1\u1d52\u1d48) (p := p.reverse) (by simpa) i.rev\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/KrullDimension.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nx\u271d : Sort u_3\ncoheight : x\u271d\np : LTSeries \u03b1\nh : p.length = sorry\ni : Fin (p.length + 1)\n\u22a2 sorry = i.rev"}, {"line": "simpa using height_eq_index_of_length_eq_height_last (\u03b1 := \u03b1\u1d52\u1d48) (p := p.reverse) (by simpa) i.rev", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coheight_le_coheight_apply_of_strictMono (f : \u03b1 \u2192 \u03b2) (hf : StrictMono f) (x : \u03b1) :\n    coheight x \u2264 coheight (f x) := by\n  apply height_le_height_apply_of_strictMono (\u03b1 := \u03b1\u1d52\u1d48)\n  exact fun _ _ h \u21a6 hf h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/KrullDimension.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d : Sort u_3\ncoheight : x\u271d\nf : \u03b1 \u2192 \u03b2\nhf : StrictMono f\nx : \u03b1\n\u22a2 sorry \u2264 sorry"}, {"line": "apply height_le_height_apply_of_strictMono (\u03b1 := \u03b1\u1d52\u1d48)", "tactic_state": "\u22a2 {\u03b1 : Type u_1} \u2192\n    {\u03b2 : Type u_2} \u2192\n      [inst : Preorder \u03b1] \u2192 [inst_1 : Preorder \u03b2] \u2192 {coheight : ?m.2113} \u2192 (f : \u03b1 \u2192 \u03b2) \u2192 StrictMono f \u2192 \u03b1 \u2192 Type u_4\n---\n\u22a2 {\u03b1 : Type u_1} \u2192\n    {\u03b2 : Type u_2} \u2192\n      [inst : Preorder \u03b1] \u2192\n        [inst_1 : Preorder \u03b2] \u2192 {coheight : ?m.2113} \u2192 (f : \u03b1 \u2192 \u03b2) \u2192 (hf : StrictMono f) \u2192 (x : \u03b1) \u2192 LE (?m.2114 f hf x)"}, {"line": "exact fun _ _ h \u21a6 hf h", "tactic_state": "\u22a2 {\u03b1 : Type u_1} \u2192\n    {\u03b2 : Type u_2} \u2192\n      [inst : Preorder \u03b1] \u2192 [inst_1 : Preorder \u03b2] \u2192 {coheight : ?m.2113} \u2192 (f : \u03b1 \u2192 \u03b2) \u2192 StrictMono f \u2192 \u03b1 \u2192 LE sorry"}]}
{"declaration": "private lemma exists_eq_iSup_of_iSup_eq_coe {\u03b1 : Type*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u2115\u221e} {n : \u2115}\n    (h : (\u2a06 x, f x) = n) : \u2203 x, f x = n := by\n  obtain \u27e8x, hx\u27e9 := ENat.sSup_mem_of_nonempty_of_lt_top (h \u25b8 ENat.coe_lt_top _)\n  use x\n  simpa [hx] using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/KrullDimension.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : Nonempty \u03b1\nf : \u03b1 \u2192 \u2115\u221e\nn : \u2115\nh : \u2a06 x, f x = \u2191n\n\u22a2 \u2203 x, f x = \u2191n"}, {"line": "obtain \u27e8x, hx\u27e9 := ENat.sSup_mem_of_nonempty_of_lt_top (h \u25b8 ENat.coe_lt_top _)", "tactic_state": "case intro\n\u03b1 : Type u_3\ninst\u271d : Nonempty \u03b1\nf : \u03b1 \u2192 \u2115\u221e\nn : \u2115\nh : \u2a06 x, f x = \u2191n\nx : \u03b1\nhx : (fun x => f x) x = sSup (Set.range fun x => f x)\n\u22a2 \u2203 x, f x = \u2191n"}, {"line": "use x", "tactic_state": "case h\n\u03b1 : Type u_3\ninst\u271d : Nonempty \u03b1\nf : \u03b1 \u2192 \u2115\u221e\nn : \u2115\nh : \u2a06 x, f x = \u2191n\nx : \u03b1\nhx : (fun x => f x) x = sSup (Set.range fun x => f x)\n\u22a2 f x = \u2191n"}, {"line": "simpa [hx] using h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma krullDim_le_one_iff_forall_isMax {\u03b1 : Type*} [PartialOrder \u03b1] [OrderBot \u03b1] :\n    krullDim \u03b1 \u2264 1 \u2194 \u2200 x : \u03b1, x \u2260 \u22a5 \u2192 IsMax x := by\n  simp [krullDim_le_one_iff, \u2190 or_iff_not_imp_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/KrullDimension.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2]", "{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_6\nkrullDim : x\u271d\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderBot \u03b1\n\u22a2 sorry \u2264 1 \u2194 \u2200 (x : \u03b1), x \u2260 \u22a5 \u2192 IsMax x"}, {"line": "simp [krullDim_le_one_iff, \u2190 or_iff_not_imp_left]", "tactic_state": "x\u271d : Sort u_6\nkrullDim : x\u271d\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderBot \u03b1\n\u22a2 sorry () \u2264 1 \u2194 \u2200 (x : \u03b1), x = \u22a5 \u2228 IsMax x"}]}
{"declaration": "lemma krullDim_le_one_iff_forall_isMin {\u03b1 : Type*} [PartialOrder \u03b1] [OrderTop \u03b1] :\n    krullDim \u03b1 \u2264 1 \u2194 \u2200 x : \u03b1, x \u2260 \u22a4 \u2192 IsMin x := by\n  simp [krullDim_le_one_iff, \u2190 or_iff_not_imp_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/KrullDimension.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2]", "{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_6\nkrullDim : x\u271d\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderTop \u03b1\n\u22a2 sorry \u2264 1 \u2194 \u2200 (x : \u03b1), x \u2260 \u22a4 \u2192 IsMin x"}, {"line": "simp [krullDim_le_one_iff, \u2190 or_iff_not_imp_right]", "tactic_state": "x\u271d : Sort u_6\nkrullDim : x\u271d\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderTop \u03b1\n\u22a2 sorry () \u2264 1 \u2194 \u2200 (x : \u03b1), IsMin x \u2228 x = \u22a4"}]}
{"declaration": "lemma krullDim_pos_iff_of_orderBot [OrderBot \u03b1] :\n    0 < krullDim \u03b1 \u2194 Nontrivial \u03b1 := by\n  rw [\u2190 not_subsingleton_iff_nontrivial]\n  rw [\u2190 Order.krullDim_eq_zero_iff_of_orderBot]\n  rw [\u2190 ne_eq]\n  rw [\u2190 lt_or_lt_iff_ne]\n  rw [or_iff_right]\n  simp [Order.krullDim_nonneg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/KrullDimension.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2]", "{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2]", "{\u03b1 : Type*} [PartialOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 0 < sorry \u2194 Nontrivial \u03b1"}, {"line": "rw [\u2190 not_subsingleton_iff_nontrivial]", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 0 < sorry \u2194 \u00acSubsingleton \u03b1"}, {"line": "rw [\u2190 Order.krullDim_eq_zero_iff_of_orderBot]", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 0 < sorry \u2194 \u00acOrder.krullDim \u03b1 = 0\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 OrderBot \u03b1"}, {"line": "rw [\u2190 ne_eq]", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 0 < sorry \u2194 Order.krullDim \u03b1 \u2260 0\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 OrderBot \u03b1"}, {"line": "rw [\u2190 lt_or_lt_iff_ne]", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 0 < sorry \u2194 Order.krullDim \u03b1 < 0 \u2228 0 < Order.krullDim \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 OrderBot \u03b1"}, {"line": "rw [or_iff_right]", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 0 < sorry \u2194 0 < Order.krullDim \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 \u00acOrder.krullDim \u03b1 < 0\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 OrderBot \u03b1"}, {"line": "simp [Order.krullDim_nonneg]", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 0 < sorry () \u2194 0 < Order.krullDim \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 \u00acOrder.krullDim \u03b1 < 0\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderBot \u03b1\n\u22a2 OrderBot \u03b1"}]}
{"declaration": "lemma krullDim_pos_iff_of_orderTop [OrderTop \u03b1] :\n    0 < krullDim \u03b1 \u2194 Nontrivial \u03b1 := by\n  rw [\u2190 not_subsingleton_iff_nontrivial]\n  rw [\u2190 Order.krullDim_eq_zero_iff_of_orderTop]\n  rw [\u2190 ne_eq]\n  rw [\u2190 lt_or_lt_iff_ne]\n  rw [or_iff_right]\n  simp [Order.krullDim_nonneg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/KrullDimension.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2]", "{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2]", "{\u03b1 : Type*} [PartialOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 0 < sorry \u2194 Nontrivial \u03b1"}, {"line": "rw [\u2190 not_subsingleton_iff_nontrivial]", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 0 < sorry \u2194 \u00acSubsingleton \u03b1"}, {"line": "rw [\u2190 Order.krullDim_eq_zero_iff_of_orderTop]", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 0 < sorry \u2194 \u00acOrder.krullDim \u03b1 = 0\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 OrderTop \u03b1"}, {"line": "rw [\u2190 ne_eq]", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 0 < sorry \u2194 Order.krullDim \u03b1 \u2260 0\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 OrderTop \u03b1"}, {"line": "rw [\u2190 lt_or_lt_iff_ne]", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 0 < sorry \u2194 Order.krullDim \u03b1 < 0 \u2228 0 < Order.krullDim \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 OrderTop \u03b1"}, {"line": "rw [or_iff_right]", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 0 < sorry \u2194 0 < Order.krullDim \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 \u00acOrder.krullDim \u03b1 < 0\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 OrderTop \u03b1"}, {"line": "simp [Order.krullDim_nonneg]", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 0 < sorry () \u2194 0 < Order.krullDim \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 \u00acOrder.krullDim \u03b1 < 0\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_5\ninst\u271d\u00b9 : PartialOrder \u03b1\nx\u271d : Sort u_6\nkrullDim : x\u271d\ninst\u271d : OrderTop \u03b1\n\u22a2 OrderTop \u03b1"}]}
{"declaration": "theorem blimsup_true (f : Filter \u03b2) (u : \u03b2 \u2192 \u03b1) : (blimsup u f fun _ => True) = limsup u f := by\n  simp [blimsup_eq, limsup_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : Filter \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 (blimsup u f fun x => True) = limsup u f"}, {"line": "simp [blimsup_eq, limsup_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bliminf_true (f : Filter \u03b2) (u : \u03b2 \u2192 \u03b1) : (bliminf u f fun _ => True) = liminf u f := by\n  simp [bliminf_eq, liminf_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : Filter \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 (bliminf u f fun x => True) = liminf u f"}, {"line": "simp [bliminf_eq, liminf_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma blimsup_eq_limsup {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop} :\n    blimsup u f p = limsup u (f \u2293 \ud835\udcdf {x | p x}) := by\n  simp only [blimsup_eq]\n  simp only [limsup_eq]\n  simp only [eventually_inf_principal]\n  simp only [mem_setOf_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : Filter \u03b2\nu : \u03b2 \u2192 \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 blimsup u f p = limsup u (f \u2293 principal {x | p x})"}, {"line": "simp only [blimsup_eq]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : Filter \u03b2\nu : \u03b2 \u2192 \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 sInf {a | \u2200\u1da0 (x : \u03b2) in f, p x \u2192 u x \u2264 a} = limsup u (f \u2293 principal {x | p x})"}, {"line": "simp only [limsup_eq]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : Filter \u03b2\nu : \u03b2 \u2192 \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 sInf {a | \u2200\u1da0 (x : \u03b2) in f, p x \u2192 u x \u2264 a} = sInf {a | \u2200\u1da0 (n : \u03b2) in f \u2293 principal {x | p x}, u n \u2264 a}"}, {"line": "simp only [eventually_inf_principal]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : Filter \u03b2\nu : \u03b2 \u2192 \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 sInf {a | \u2200\u1da0 (x : \u03b2) in f, p x \u2192 u x \u2264 a} = sInf {a | \u2200\u1da0 (x : \u03b2) in f, x \u2208 {x | p x} \u2192 u x \u2264 a}"}, {"line": "simp only [mem_setOf_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem blimsup_eq_limsup_subtype {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop} :\n    blimsup u f p = limsup (u \u2218 ((\u2191) : { x | p x } \u2192 \u03b2)) (comap (\u2191) f) := by\n  rw [blimsup_eq_limsup]\n  rw [limsup]\n  rw [limsup]\n  rw [\u2190 map_map]\n  rw [map_comap_setCoe_val]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : Filter \u03b2\nu : \u03b2 \u2192 \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 blimsup u f p = limsup (u \u2218 Subtype.val) (comap Subtype.val f)"}, {"line": "rw [blimsup_eq_limsup]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : Filter \u03b2\nu : \u03b2 \u2192 \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 limsup u (f \u2293 principal {x | p x}) = limsup (u \u2218 Subtype.val) (comap Subtype.val f)"}, {"line": "rw [limsup]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : Filter \u03b2\nu : \u03b2 \u2192 \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 (map u (f \u2293 principal {x | p x})).limsSup = limsup (u \u2218 Subtype.val) (comap Subtype.val f)"}, {"line": "rw [limsup]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : Filter \u03b2\nu : \u03b2 \u2192 \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 (map u (f \u2293 principal {x | p x})).limsSup = (map (u \u2218 Subtype.val) (comap Subtype.val f)).limsSup"}, {"line": "rw [\u2190 map_map]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : Filter \u03b2\nu : \u03b2 \u2192 \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 (map u (f \u2293 principal {x | p x})).limsSup = (map u (map Subtype.val (comap Subtype.val f))).limsSup"}, {"line": "rw [map_comap_setCoe_val]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem limsup_congr {\u03b1 : Type*} [ConditionallyCompleteLattice \u03b2] {f : Filter \u03b1} {u v : \u03b1 \u2192 \u03b2}\n    (h : \u2200\u1da0 a in f, u a = v a) : limsup u f = limsup v f := by\n  rw [limsup_eq]\n  congr with b\n  exact eventually_congr (h.mono fun x hx => by simp [hx])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03b1 : Type u_6\ninst\u271d : ConditionallyCompleteLattice \u03b2\nf : Filter \u03b1\nu v : \u03b1 \u2192 \u03b2\nh : \u2200\u1da0 (a : \u03b1) in f, u a = v a\n\u22a2 limsup u f = limsup v f"}, {"line": "rw [limsup_eq]", "tactic_state": "\u03b2 : Type u_2\n\u03b1 : Type u_6\ninst\u271d : ConditionallyCompleteLattice \u03b2\nf : Filter \u03b1\nu v : \u03b1 \u2192 \u03b2\nh : \u2200\u1da0 (a : \u03b1) in f, u a = v a\n\u22a2 sInf {a | \u2200\u1da0 (n : \u03b1) in f, u n \u2264 a} = limsup v f"}, {"line": "congr with b", "tactic_state": "case e_a.h\n\u03b2 : Type u_2\n\u03b1 : Type u_6\ninst\u271d : ConditionallyCompleteLattice \u03b2\nf : Filter \u03b1\nu v : \u03b1 \u2192 \u03b2\nh : \u2200\u1da0 (a : \u03b1) in f, u a = v a\nb : \u03b2\n\u22a2 b \u2208 {a | \u2200\u1da0 (n : \u03b1) in f, u n \u2264 a} \u2194 b \u2208 {a | \u2200\u1da0 (n : \u03b2) in map v f, n \u2264 a}"}, {"line": "exact eventually_congr (h.mono fun x hx => by simp [hx])", "tactic_state": "No Goals!"}]}
{"declaration": "theorem blimsup_congr {f : Filter \u03b2} {u v : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop} (h : \u2200\u1da0 a in f, p a \u2192 u a = v a) :\n    blimsup u f p = blimsup v f p := by\n  simpa only [blimsup_eq_limsup] using limsup_congr <| eventually_inf_principal.2 h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : Filter \u03b2\nu v : \u03b2 \u2192 \u03b1\np : \u03b2 \u2192 Prop\nh : \u2200\u1da0 (a : \u03b2) in f, p a \u2192 u a = v a\n\u22a2 blimsup u f p = blimsup v f p"}, {"line": "simpa only [blimsup_eq_limsup] using limsup_congr <| eventually_inf_principal.2 h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.liminf_eq_sSup_iUnion_iInter {\u03b9 \u03b9' : Type*} {f : \u03b9 \u2192 \u03b1} {v : Filter \u03b9}\n    {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b9} (hv : v.HasBasis p s) :\n    liminf f v = sSup (\u22c3 (j : Subtype p), \u22c2 (i : s j), Iic (f i)) := by\n  simp_rw [liminf_eq, hv.eventually_iff]\n  congr\n  ext x\n  simp only [mem_setOf_eq]\n  simp only [iInter_coe_set]\n  simp only [mem_iUnion]\n  simp only [mem_iInter]\n  simp only [mem_Iic]\n  simp only [Subtype.exists]\n  simp only [exists_prop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\n\u03b9 : Type u_6\n\u03b9' : Type u_7\nf : \u03b9 \u2192 \u03b1\nv : Filter \u03b9\np : \u03b9' \u2192 Prop\ns : \u03b9' \u2192 Set \u03b9\nhv : v.HasBasis p s\n\u22a2 liminf f v = sSup (\u22c3 j, \u22c2 i, Iic (f \u2191i))"}, {"line": "simp_rw [liminf_eq, hv.eventually_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\n\u03b9 : Type u_6\n\u03b9' : Type u_7\nf : \u03b9 \u2192 \u03b1\nv : Filter \u03b9\np : \u03b9' \u2192 Prop\ns : \u03b9' \u2192 Set \u03b9\nhv : v.HasBasis p s\n\u22a2 sSup {a | \u2203 i, p i \u2227 \u2200 \u2983x : \u03b9\u2984, x \u2208 s i \u2192 a \u2264 f x} = sSup (\u22c3 j, \u22c2 i, Iic (f \u2191i))"}, {"line": "congr", "tactic_state": "case e_a\n\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\n\u03b9 : Type u_6\n\u03b9' : Type u_7\nf : \u03b9 \u2192 \u03b1\nv : Filter \u03b9\np : \u03b9' \u2192 Prop\ns : \u03b9' \u2192 Set \u03b9\nhv : v.HasBasis p s\n\u22a2 {a | \u2203 i, p i \u2227 \u2200 \u2983x : \u03b9\u2984, x \u2208 s i \u2192 a \u2264 f x} = \u22c3 j, \u22c2 i, Iic (f \u2191i)"}, {"line": "ext x", "tactic_state": "case e_a.h\n\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\n\u03b9 : Type u_6\n\u03b9' : Type u_7\nf : \u03b9 \u2192 \u03b1\nv : Filter \u03b9\np : \u03b9' \u2192 Prop\ns : \u03b9' \u2192 Set \u03b9\nhv : v.HasBasis p s\nx : \u03b1\n\u22a2 x \u2208 {a | \u2203 i, p i \u2227 \u2200 \u2983x : \u03b9\u2984, x \u2208 s i \u2192 a \u2264 f x} \u2194 x \u2208 \u22c3 j, \u22c2 i, Iic (f \u2191i)"}, {"line": "simp only [mem_setOf_eq]", "tactic_state": "case e_a.h\n\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\n\u03b9 : Type u_6\n\u03b9' : Type u_7\nf : \u03b9 \u2192 \u03b1\nv : Filter \u03b9\np : \u03b9' \u2192 Prop\ns : \u03b9' \u2192 Set \u03b9\nhv : v.HasBasis p s\nx : \u03b1\n\u22a2 (\u2203 i, p i \u2227 \u2200 \u2983x_1 : \u03b9\u2984, x_1 \u2208 s i \u2192 x \u2264 f x_1) \u2194 x \u2208 \u22c3 j, \u22c2 i, Iic (f \u2191i)"}, {"line": "simp only [iInter_coe_set]", "tactic_state": "case e_a.h\n\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\n\u03b9 : Type u_6\n\u03b9' : Type u_7\nf : \u03b9 \u2192 \u03b1\nv : Filter \u03b9\np : \u03b9' \u2192 Prop\ns : \u03b9' \u2192 Set \u03b9\nhv : v.HasBasis p s\nx : \u03b1\n\u22a2 (\u2203 i, p i \u2227 \u2200 \u2983x_1 : \u03b9\u2984, x_1 \u2208 s i \u2192 x \u2264 f x_1) \u2194 x \u2208 \u22c3 j, \u22c2 i \u2208 s \u2191j, Iic (f i)"}, {"line": "simp only [mem_iUnion]", "tactic_state": "case e_a.h\n\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\n\u03b9 : Type u_6\n\u03b9' : Type u_7\nf : \u03b9 \u2192 \u03b1\nv : Filter \u03b9\np : \u03b9' \u2192 Prop\ns : \u03b9' \u2192 Set \u03b9\nhv : v.HasBasis p s\nx : \u03b1\n\u22a2 (\u2203 i, p i \u2227 \u2200 \u2983x_1 : \u03b9\u2984, x_1 \u2208 s i \u2192 x \u2264 f x_1) \u2194 \u2203 i, x \u2208 \u22c2 i_1 \u2208 s \u2191i, Iic (f i_1)"}, {"line": "simp only [mem_iInter]", "tactic_state": "case e_a.h\n\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\n\u03b9 : Type u_6\n\u03b9' : Type u_7\nf : \u03b9 \u2192 \u03b1\nv : Filter \u03b9\np : \u03b9' \u2192 Prop\ns : \u03b9' \u2192 Set \u03b9\nhv : v.HasBasis p s\nx : \u03b1\n\u22a2 (\u2203 i, p i \u2227 \u2200 \u2983x_1 : \u03b9\u2984, x_1 \u2208 s i \u2192 x \u2264 f x_1) \u2194 \u2203 i, \u2200 i_1 \u2208 s \u2191i, x \u2208 Iic (f i_1)"}, {"line": "simp only [mem_Iic]", "tactic_state": "case e_a.h\n\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\n\u03b9 : Type u_6\n\u03b9' : Type u_7\nf : \u03b9 \u2192 \u03b1\nv : Filter \u03b9\np : \u03b9' \u2192 Prop\ns : \u03b9' \u2192 Set \u03b9\nhv : v.HasBasis p s\nx : \u03b1\n\u22a2 (\u2203 i, p i \u2227 \u2200 \u2983x_1 : \u03b9\u2984, x_1 \u2208 s i \u2192 x \u2264 f x_1) \u2194 \u2203 i, \u2200 i_1 \u2208 s \u2191i, x \u2264 f i_1"}, {"line": "simp only [Subtype.exists]", "tactic_state": "case e_a.h\n\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\n\u03b9 : Type u_6\n\u03b9' : Type u_7\nf : \u03b9 \u2192 \u03b1\nv : Filter \u03b9\np : \u03b9' \u2192 Prop\ns : \u03b9' \u2192 Set \u03b9\nhv : v.HasBasis p s\nx : \u03b1\n\u22a2 (\u2203 i, p i \u2227 \u2200 \u2983x_1 : \u03b9\u2984, x_1 \u2208 s i \u2192 x \u2264 f x_1) \u2194 \u2203 a, \u2203 (_ : p a), \u2200 i \u2208 s a, x \u2264 f i"}, {"line": "simp only [exists_prop]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.liminf_eq_sSup_univ_of_empty {f : \u03b9 \u2192 \u03b1} {v : Filter \u03b9}\n    {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b9} (hv : v.HasBasis p s) (i : \u03b9') (hi : p i) (h'i : s i = \u2205) :\n    liminf f v = sSup univ := by\n  simp [hv.eq_bot_iff.2 \u27e8i, hi, h'i\u27e9, liminf_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\n\u03b9' : Type u_5\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : \u03b9 \u2192 \u03b1\nv : Filter \u03b9\np : \u03b9' \u2192 Prop\ns : \u03b9' \u2192 Set \u03b9\nhv : v.HasBasis p s\ni : \u03b9'\nhi : p i\nh'i : s i = \u2205\n\u22a2 liminf f v = sSup univ"}, {"line": "simp [hv.eq_bot_iff.2 \u27e8i, hi, h'i\u27e9, liminf_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem liminf_nat_add (f : \u2115 \u2192 \u03b1) (k : \u2115) :\n    liminf (fun i => f (i + k)) atTop = liminf f atTop := by\n  rw [\u2190 Function.comp_def]\n  rw [liminf]\n  rw [liminf]\n  rw [\u2190 map_map]\n  rw [map_add_atTop_eq_nat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : \u2115 \u2192 \u03b1\nk : \u2115\n\u22a2 liminf (fun i => f (i + k)) atTop = liminf f atTop"}, {"line": "rw [\u2190 Function.comp_def]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : \u2115 \u2192 \u03b1\nk : \u2115\n\u22a2 liminf (f \u2218 fun i => i + k) atTop = liminf f atTop"}, {"line": "rw [liminf]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : \u2115 \u2192 \u03b1\nk : \u2115\n\u22a2 (map (f \u2218 fun i => i + k) atTop).limsInf = liminf f atTop"}, {"line": "rw [liminf]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : \u2115 \u2192 \u03b1\nk : \u2115\n\u22a2 (map (f \u2218 fun i => i + k) atTop).limsInf = (map f atTop).limsInf"}, {"line": "rw [\u2190 map_map]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : \u2115 \u2192 \u03b1\nk : \u2115\n\u22a2 (map f (map (fun i => i + k) atTop)).limsInf = (map f atTop).limsInf"}, {"line": "rw [map_add_atTop_eq_nat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem blimsup_false {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} : (blimsup u f fun _ => False) = \u22a5 := by\n  simp [blimsup_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}", "[CompleteLattice \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : ConditionallyCompleteLattice \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : Filter \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 (blimsup u f fun x => False) = \u22a5"}, {"line": "simp [blimsup_eq]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : ConditionallyCompleteLattice \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : Filter \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 sInf univ = \u22a5"}]}
{"declaration": "theorem bliminf_false {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} : (bliminf u f fun _ => False) = \u22a4 := by\n  simp [bliminf_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}", "[CompleteLattice \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : ConditionallyCompleteLattice \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : Filter \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 (bliminf u f fun x => False) = \u22a4"}, {"line": "simp [bliminf_eq]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : ConditionallyCompleteLattice \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : Filter \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 sSup univ = \u22a4"}]}
{"declaration": "lemma limsSup_principal_eq_sSup (s : Set \u03b1) : limsSup (\ud835\udcdf s) = sSup s := by\n  simpa only [limsSup,eventually_principal] using sInf_upperBounds_eq_csSup s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}", "[CompleteLattice \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : ConditionallyCompleteLattice \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\n\u22a2 (principal s).limsSup = sSup s"}, {"line": "simpa only [limsSup,eventually_principal] using sInf_upperBounds_eq_csSup s", "tactic_state": "No Goals!"}]}
{"declaration": "lemma limsInf_principal_eq_sInf (s : Set \u03b1) : limsInf (\ud835\udcdf s) = sInf s := by\n  simpa only [limsInf,eventually_principal] using sSup_lowerBounds_eq_sInf s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}", "[CompleteLattice \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : ConditionallyCompleteLattice \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\n\u22a2 (principal s).limsInf = sInf s"}, {"line": "simpa only [limsInf,eventually_principal] using sSup_lowerBounds_eq_sInf s", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_liminf_iff_eventually_mem : (a \u2208 liminf s \ud835\udcd5) \u2194 (\u2200\u1da0 i in \ud835\udcd5, a \u2208 s i) := by\n  simpa only [liminf_eq_iSup_iInf,iSup_eq_iUnion,iInf_eq_iInter,mem_iUnion,mem_iInter]\n    using \u27e8fun \u27e8S, hS, hS'\u27e9 \u21a6 mem_of_superset hS (by tauto), fun h \u21a6 \u27e8{i | a \u2208 s i}, h, by tauto\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}", "[CompleteLattice \u03b1]", "{f g : Filter \u03b2} {p q : \u03b2 \u2192 Prop} {u v : \u03b2 \u2192 \u03b1}", "[CompleteDistribLattice \u03b1] {f : Filter \u03b2} {p q : \u03b2 \u2192 Prop} {u : \u03b2 \u2192 \u03b1}", "[CompleteBooleanAlgebra \u03b1] (f : Filter \u03b2) (u : \u03b2 \u2192 \u03b1)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {\ud835\udcd5 : Filter \u03b9} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\ns : \u03b9 \u2192 Set \u03b1\n\ud835\udcd5 : Filter \u03b9\na : \u03b1\n\u22a2 a \u2208 liminf s \ud835\udcd5 \u2194 \u2200\u1da0 (i : \u03b9) in \ud835\udcd5, a \u2208 s i"}, {"line": "simpa only [liminf_eq_iSup_iInf,iSup_eq_iUnion,iInf_eq_iInter,mem_iUnion,mem_iInter]\n    using \u27e8fun \u27e8S, hS, hS'\u27e9 \u21a6 mem_of_superset hS (by tauto), fun h \u21a6 \u27e8{i | a \u2208 s i}, h, by tauto\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cofinite.limsup_set_eq : limsup s cofinite = { x | { n | x \u2208 s n }.Infinite } := by\n  simp only [\u2190 cofinite.blimsup_true s]\n  simp only [cofinite.blimsup_set_eq]\n  simp only [true_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}", "[CompleteLattice \u03b1]", "{f g : Filter \u03b2} {p q : \u03b2 \u2192 Prop} {u v : \u03b2 \u2192 \u03b1}", "[CompleteDistribLattice \u03b1] {f : Filter \u03b2} {p q : \u03b2 \u2192 Prop} {u : \u03b2 \u2192 \u03b1}", "[CompleteBooleanAlgebra \u03b1] (f : Filter \u03b2) (u : \u03b2 \u2192 \u03b1)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {\ud835\udcd5 : Filter \u03b9} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\ns : \u03b9 \u2192 Set \u03b1\n\u22a2 limsup s cofinite = {x | {n | x \u2208 s n}.Infinite}"}, {"line": "simp only [\u2190 cofinite.blimsup_true s]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\ns : \u03b9 \u2192 Set \u03b1\n\u22a2 (blimsup s cofinite fun x => True) = {x | {n | x \u2208 s n}.Infinite}"}, {"line": "simp only [cofinite.blimsup_set_eq]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\ns : \u03b9 \u2192 Set \u03b1\n\u22a2 {x | {n | True \u2227 x \u2208 s n}.Infinite} = {x | {n | x \u2208 s n}.Infinite}"}, {"line": "simp only [true_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cofinite.liminf_set_eq : liminf s cofinite = { x | { n | x \u2209 s n }.Finite } := by\n  simp only [\u2190 cofinite.bliminf_true s]\n  simp only [cofinite.bliminf_set_eq]\n  simp only [true_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}", "[CompleteLattice \u03b1]", "{f g : Filter \u03b2} {p q : \u03b2 \u2192 Prop} {u v : \u03b2 \u2192 \u03b1}", "[CompleteDistribLattice \u03b1] {f : Filter \u03b2} {p q : \u03b2 \u2192 Prop} {u : \u03b2 \u2192 \u03b1}", "[CompleteBooleanAlgebra \u03b1] (f : Filter \u03b2) (u : \u03b2 \u2192 \u03b1)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {\ud835\udcd5 : Filter \u03b9} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\ns : \u03b9 \u2192 Set \u03b1\n\u22a2 liminf s cofinite = {x | {n | x \u2209 s n}.Finite}"}, {"line": "simp only [\u2190 cofinite.bliminf_true s]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\ns : \u03b9 \u2192 Set \u03b1\n\u22a2 (bliminf s cofinite fun x => True) = {x | {n | x \u2209 s n}.Finite}"}, {"line": "simp only [cofinite.bliminf_set_eq]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\ns : \u03b9 \u2192 Set \u03b1\n\u22a2 {x | {n | True \u2227 x \u2209 s n}.Finite} = {x | {n | x \u2209 s n}.Finite}"}, {"line": "simp only [true_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_forall_mem_of_hasBasis_mem_blimsup {l : Filter \u03b2} {b : \u03b9 \u2192 Set \u03b2} {q : \u03b9 \u2192 Prop}\n    (hl : l.HasBasis q b) {u : \u03b2 \u2192 Set \u03b1} {p : \u03b2 \u2192 Prop} {x : \u03b1} (hx : x \u2208 blimsup u l p) :\n    \u2203 f : { i | q i } \u2192 \u03b2, \u2200 i, x \u2208 u (f i) \u2227 p (f i) \u2227 f i \u2208 b i := by\n  rw [blimsup_eq_iInf_biSup] at hx\n  simp only [iSup_eq_iUnion] at hx\n  simp only [iInf_eq_iInter] at hx\n  simp only [mem_iInter] at hx\n  simp only [mem_iUnion] at hx\n  simp only [exists_prop] at hx\n  choose g hg hg' using hx\n  refine \u27e8fun i : { i | q i } => g (b i) (hl.mem_of_mem i.2), fun i => \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact hg' (b i) (hl.mem_of_mem i.2)\n  \u00b7 exact hg (b i) (hl.mem_of_mem i.2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}", "[CompleteLattice \u03b1]", "{f g : Filter \u03b2} {p q : \u03b2 \u2192 Prop} {u v : \u03b2 \u2192 \u03b1}", "[CompleteDistribLattice \u03b1] {f : Filter \u03b2} {p q : \u03b2 \u2192 Prop} {u : \u03b2 \u2192 \u03b1}", "[CompleteBooleanAlgebra \u03b1] (f : Filter \u03b2) (u : \u03b2 \u2192 \u03b1)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {\ud835\udcd5 : Filter \u03b9} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\nl : Filter \u03b2\nb : \u03b9 \u2192 Set \u03b2\nq : \u03b9 \u2192 Prop\nhl : l.HasBasis q b\nu : \u03b2 \u2192 Set \u03b1\np : \u03b2 \u2192 Prop\nx : \u03b1\nhx : x \u2208 blimsup u l p\n\u22a2 \u2203 f, \u2200 (i : \u2191{i | q i}), x \u2208 u (f i) \u2227 p (f i) \u2227 f i \u2208 b \u2191i"}, {"line": "rw [blimsup_eq_iInf_biSup] at hx", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\nl : Filter \u03b2\nb : \u03b9 \u2192 Set \u03b2\nq : \u03b9 \u2192 Prop\nhl : l.HasBasis q b\nu : \u03b2 \u2192 Set \u03b1\np : \u03b2 \u2192 Prop\nx : \u03b1\nhx : x \u2208 \u2a05 s \u2208 l, \u2a06 b, \u2a06 (_ : p b \u2227 b \u2208 s), u b\n\u22a2 \u2203 f, \u2200 (i : \u2191{i | q i}), x \u2208 u (f i) \u2227 p (f i) \u2227 f i \u2208 b \u2191i"}, {"line": "simp only [iSup_eq_iUnion] at hx", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\nl : Filter \u03b2\nb : \u03b9 \u2192 Set \u03b2\nq : \u03b9 \u2192 Prop\nhl : l.HasBasis q b\nu : \u03b2 \u2192 Set \u03b1\np : \u03b2 \u2192 Prop\nx : \u03b1\nhx : x \u2208 \u2a05 s \u2208 l, \u22c3 b, \u22c3 (_ : p b \u2227 b \u2208 s), u b\n\u22a2 \u2203 f, \u2200 (i : \u2191{i | q i}), x \u2208 u (f i) \u2227 p (f i) \u2227 f i \u2208 b \u2191i"}, {"line": "simp only [iInf_eq_iInter] at hx", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\nl : Filter \u03b2\nb : \u03b9 \u2192 Set \u03b2\nq : \u03b9 \u2192 Prop\nhl : l.HasBasis q b\nu : \u03b2 \u2192 Set \u03b1\np : \u03b2 \u2192 Prop\nx : \u03b1\nhx : x \u2208 \u22c2 s \u2208 l, \u22c3 b, \u22c3 (_ : p b \u2227 b \u2208 s), u b\n\u22a2 \u2203 f, \u2200 (i : \u2191{i | q i}), x \u2208 u (f i) \u2227 p (f i) \u2227 f i \u2208 b \u2191i"}, {"line": "simp only [mem_iInter] at hx", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\nl : Filter \u03b2\nb : \u03b9 \u2192 Set \u03b2\nq : \u03b9 \u2192 Prop\nhl : l.HasBasis q b\nu : \u03b2 \u2192 Set \u03b1\np : \u03b2 \u2192 Prop\nx : \u03b1\nhx : \u2200 i \u2208 l, x \u2208 \u22c3 b, \u22c3 (_ : p b \u2227 b \u2208 i), u b\n\u22a2 \u2203 f, \u2200 (i : \u2191{i | q i}), x \u2208 u (f i) \u2227 p (f i) \u2227 f i \u2208 b \u2191i"}, {"line": "simp only [mem_iUnion] at hx", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\nl : Filter \u03b2\nb : \u03b9 \u2192 Set \u03b2\nq : \u03b9 \u2192 Prop\nhl : l.HasBasis q b\nu : \u03b2 \u2192 Set \u03b1\np : \u03b2 \u2192 Prop\nx : \u03b1\nhx : \u2200 i \u2208 l, \u2203 i_2, \u2203 (_ : p i_2 \u2227 i_2 \u2208 i), x \u2208 u i_2\n\u22a2 \u2203 f, \u2200 (i : \u2191{i | q i}), x \u2208 u (f i) \u2227 p (f i) \u2227 f i \u2208 b \u2191i"}, {"line": "simp only [exists_prop] at hx", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\nl : Filter \u03b2\nb : \u03b9 \u2192 Set \u03b2\nq : \u03b9 \u2192 Prop\nhl : l.HasBasis q b\nu : \u03b2 \u2192 Set \u03b1\np : \u03b2 \u2192 Prop\nx : \u03b1\nhx : \u2200 i \u2208 l, \u2203 i_2, (p i_2 \u2227 i_2 \u2208 i) \u2227 x \u2208 u i_2\n\u22a2 \u2203 f, \u2200 (i : \u2191{i | q i}), x \u2208 u (f i) \u2227 p (f i) \u2227 f i \u2208 b \u2191i"}, {"line": "choose g hg hg' using hx", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\nl : Filter \u03b2\nb : \u03b9 \u2192 Set \u03b2\nq : \u03b9 \u2192 Prop\nhl : l.HasBasis q b\nu : \u03b2 \u2192 Set \u03b1\np : \u03b2 \u2192 Prop\nx : \u03b1\ng : (i : Set \u03b2) \u2192 i \u2208 l \u2192 \u03b2\nhg : \u2200 (i : Set \u03b2) (i_1 : i \u2208 l), p (g i i_1) \u2227 g i i_1 \u2208 i\nhg' : \u2200 (i : Set \u03b2) (i_1 : i \u2208 l), x \u2208 u (g i i_1)\n\u22a2 \u2203 f, \u2200 (i : \u2191{i | q i}), x \u2208 u (f i) \u2227 p (f i) \u2227 f i \u2208 b \u2191i"}, {"line": "refine \u27e8fun i : { i | q i } => g (b i) (hl.mem_of_mem i.2), fun i => \u27e8?_, ?_\u27e9\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\nl : Filter \u03b2\nb : \u03b9 \u2192 Set \u03b2\nq : \u03b9 \u2192 Prop\nhl : l.HasBasis q b\nu : \u03b2 \u2192 Set \u03b1\np : \u03b2 \u2192 Prop\nx : \u03b1\ng : (i : Set \u03b2) \u2192 i \u2208 l \u2192 \u03b2\nhg : \u2200 (i : Set \u03b2) (i_1 : i \u2208 l), p (g i i_1) \u2227 g i i_1 \u2208 i\nhg' : \u2200 (i : Set \u03b2) (i_1 : i \u2208 l), x \u2208 u (g i i_1)\ni : \u2191{i | q i}\n\u22a2 x \u2208 u ((fun i => g (b \u2191i) \u22ef) i)\n---\ncase refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\nl : Filter \u03b2\nb : \u03b9 \u2192 Set \u03b2\nq : \u03b9 \u2192 Prop\nhl : l.HasBasis q b\nu : \u03b2 \u2192 Set \u03b1\np : \u03b2 \u2192 Prop\nx : \u03b1\ng : (i : Set \u03b2) \u2192 i \u2208 l \u2192 \u03b2\nhg : \u2200 (i : Set \u03b2) (i_1 : i \u2208 l), p (g i i_1) \u2227 g i i_1 \u2208 i\nhg' : \u2200 (i : Set \u03b2) (i_1 : i \u2208 l), x \u2208 u (g i i_1)\ni : \u2191{i | q i}\n\u22a2 p ((fun i => g (b \u2191i) \u22ef) i) \u2227 (fun i => g (b \u2191i) \u22ef) i \u2208 b \u2191i"}, {"line": "\u00b7 exact hg' (b i) (hl.mem_of_mem i.2)", "tactic_state": "case refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\nl : Filter \u03b2\nb : \u03b9 \u2192 Set \u03b2\nq : \u03b9 \u2192 Prop\nhl : l.HasBasis q b\nu : \u03b2 \u2192 Set \u03b1\np : \u03b2 \u2192 Prop\nx : \u03b1\ng : (i : Set \u03b2) \u2192 i \u2208 l \u2192 \u03b2\nhg : \u2200 (i : Set \u03b2) (i_1 : i \u2208 l), p (g i i_1) \u2227 g i i_1 \u2208 i\nhg' : \u2200 (i : Set \u03b2) (i_1 : i \u2208 l), x \u2208 u (g i i_1)\ni : \u2191{i | q i}\n\u22a2 p ((fun i => g (b \u2191i) \u22ef) i) \u2227 (fun i => g (b \u2191i) \u22ef) i \u2208 b \u2191i"}, {"line": "\u00b7 exact hg (b i) (hl.mem_of_mem i.2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_forall_mem_of_hasBasis_mem_blimsup' {l : Filter \u03b2} {b : \u03b9 \u2192 Set \u03b2}\n    (hl : l.HasBasis (fun _ => True) b) {u : \u03b2 \u2192 Set \u03b1} {p : \u03b2 \u2192 Prop} {x : \u03b1}\n    (hx : x \u2208 blimsup u l p) : \u2203 f : \u03b9 \u2192 \u03b2, \u2200 i, x \u2208 u (f i) \u2227 p (f i) \u2227 f i \u2208 b i := by\n  obtain \u27e8f, hf\u27e9 := exists_forall_mem_of_hasBasis_mem_blimsup hl hx\n  exact \u27e8fun i => f \u27e8i, trivial\u27e9, fun i => hf \u27e8i, trivial\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/LiminfLimsup.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*}", "[ConditionallyCompleteLattice \u03b1] {s : Set \u03b1} {u : \u03b2 \u2192 \u03b1}", "{f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop}", "[CompleteLattice \u03b1]", "{f g : Filter \u03b2} {p q : \u03b2 \u2192 Prop} {u v : \u03b2 \u2192 \u03b1}", "[CompleteDistribLattice \u03b1] {f : Filter \u03b2} {p q : \u03b2 \u2192 Prop} {u : \u03b2 \u2192 \u03b1}", "[CompleteBooleanAlgebra \u03b1] (f : Filter \u03b2) (u : \u03b2 \u2192 \u03b1)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {\ud835\udcd5 : Filter \u03b9} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\nl : Filter \u03b2\nb : \u03b9 \u2192 Set \u03b2\nhl : l.HasBasis (fun x => True) b\nu : \u03b2 \u2192 Set \u03b1\np : \u03b2 \u2192 Prop\nx : \u03b1\nhx : x \u2208 blimsup u l p\n\u22a2 \u2203 f, \u2200 (i : \u03b9), x \u2208 u (f i) \u2227 p (f i) \u2227 f i \u2208 b i"}, {"line": "obtain \u27e8f, hf\u27e9 := exists_forall_mem_of_hasBasis_mem_blimsup hl hx", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\nl : Filter \u03b2\nb : \u03b9 \u2192 Set \u03b2\nhl : l.HasBasis (fun x => True) b\nu : \u03b2 \u2192 Set \u03b1\np : \u03b2 \u2192 Prop\nx : \u03b1\nhx : x \u2208 blimsup u l p\nf : \u2191{i | True} \u2192 \u03b2\nhf : \u2200 (i : \u2191{i | True}), x \u2208 u (f i) \u2227 p (f i) \u2227 f i \u2208 b \u2191i\n\u22a2 \u2203 f, \u2200 (i : \u03b9), x \u2208 u (f i) \u2227 p (f i) \u2227 f i \u2208 b i"}, {"line": "exact \u27e8fun i => f \u27e8i, trivial\u27e9, fun i => hf \u27e8i, trivial\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isWF_univ_iff : IsWF (univ : Set \u03b1) \u2194 WellFoundedLT \u03b1 := by\n  simp [IsWF, wellFoundedOn_iff, isWellFounded_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WellFoundedSet.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation", "Relation", "List in"], "variables": ["{\u03b9 \u03b1 \u03b2 \u03b3 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "{r r' : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f : \u03b2 \u2192 \u03b1} {s t : Set \u03b1} {x y : \u03b1}", "[IsStrictOrder \u03b1 r] {s t : Set \u03b1}", "[LT \u03b1] {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : LT \u03b1\nx\u271d : Sort u_1\nIsWF : x\u271d\n\u22a2 sorry \u2194 WellFoundedLT \u03b1"}, {"line": "simp [IsWF, wellFoundedOn_iff, isWellFounded_iff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : LT \u03b1\nx\u271d : Sort u_1\nIsWF : x\u271d\n\u22a2 sorry () \u2194 WellFounded fun x1 x2 => x1 < x2"}]}
{"declaration": "lemma WellFoundedOn.mapsTo {\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (f : \u03b2 \u2192 \u03b1)\n    {s : Set \u03b1} {t : Set \u03b2} (h : MapsTo f t s) (hw : s.WellFoundedOn r) :\n    t.WellFoundedOn (r on f) := by\n  exact InvImage.wf (fun x : t \u21a6 \u27e8f x, h x.prop\u27e9) hw\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WellFoundedSet.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation", "Relation", "List in"], "variables": ["{\u03b9 \u03b1 \u03b2 \u03b3 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "{r r' : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f : \u03b2 \u2192 \u03b1} {s t : Set \u03b1} {x y : \u03b1}", "[IsStrictOrder \u03b1 r] {s t : Set \u03b1}", "[LT \u03b1] {s t : Set \u03b1}", "[Preorder \u03b1] {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] {s t : Set \u03b1} {a : \u03b1}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} {r' : \u03b2 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b1} {a : \u03b1}", "[IsRefl \u03b1 r]", "[IsPreorder \u03b1 r]", "[Preorder \u03b1] [Preorder \u03b2] {s t : Set \u03b1}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsStrictOrder \u03b1 r] {s : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nMapsTo : x\u271d\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b1\nt : Set \u03b2\nh : sorry\nhw : s.WellFoundedOn r\n\u22a2 t.WellFoundedOn (Function.onFun r f)"}, {"line": "exact InvImage.wf (fun x : t \u21a6 \u27e8f x, h x.prop\u27e9) hw", "tactic_state": "No Goals!"}]}
{"declaration": "theorem partiallyWellOrderedOn_bUnion (s : Finset \u03b9) {f : \u03b9 \u2192 Set \u03b1} :\n    (\u22c3 i \u2208 s, f i).PartiallyWellOrderedOn r \u2194 \u2200 i \u2208 s, (f i).PartiallyWellOrderedOn r := by\n  simpa only [Finset.sup_eq_iSup] using s.partiallyWellOrderedOn_sup\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WellFoundedSet.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation", "Relation", "List in"], "variables": ["{\u03b9 \u03b1 \u03b2 \u03b3 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "{r r' : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f : \u03b2 \u2192 \u03b1} {s t : Set \u03b1} {x y : \u03b1}", "[IsStrictOrder \u03b1 r] {s t : Set \u03b1}", "[LT \u03b1] {s t : Set \u03b1}", "[Preorder \u03b1] {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] {s t : Set \u03b1} {a : \u03b1}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} {r' : \u03b2 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b1} {a : \u03b1}", "[IsRefl \u03b1 r]", "[IsPreorder \u03b1 r]", "[Preorder \u03b1] [Preorder \u03b2] {s t : Set \u03b1}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsStrictOrder \u03b1 r] {s : Set \u03b1} {a : \u03b1}", "[LinearOrder \u03b1] {s : Set \u03b1}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : LT \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LinearOrder \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u03b9 : Type u_1\ns : Finset \u03b9\nf : \u03b9 \u2192 Set \u03b1\n\u22a2 (\u22c3 i \u2208 s, f i).PartiallyWellOrderedOn r \u2194 \u2200 i \u2208 s, (f i).PartiallyWellOrderedOn r"}, {"line": "simpa only [Finset.sup_eq_iSup] using s.partiallyWellOrderedOn_sup", "tactic_state": "No Goals!"}]}
{"declaration": "theorem min_eq_iff : min a b = c \u2194 a = c \u2227 a \u2264 b \u2228 b = c \u2227 b \u2264 a := by\n  constructor\n  \u00b7 intro h\n    refine Or.imp (fun h' => ?_) (fun h' => ?_) (le_total a b) <;> exact \u27e8by simpa [h'] using h, h'\u27e9\n  \u00b7 rintro (\u27e8rfl, h\u27e9 | \u27e8rfl, h\u27e9) <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/MinMax.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[LinearOrder \u03b1] [LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b c : \u03b1\n\u22a2 min a b = c \u2194 a = c \u2227 a \u2264 b \u2228 b = c \u2227 b \u2264 a"}, {"line": "constructor", "tactic_state": "case mp\n\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b c : \u03b1\n\u22a2 min a b = c \u2192 a = c \u2227 a \u2264 b \u2228 b = c \u2227 b \u2264 a\n---\ncase mpr\n\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b c : \u03b1\n\u22a2 a = c \u2227 a \u2264 b \u2228 b = c \u2227 b \u2264 a \u2192 min a b = c"}, {"line": "\u00b7 intro h\n    refine Or.imp (fun h' => ?_) (fun h' => ?_) (le_total a b) <;> exact \u27e8by simpa [h'] using h, h'\u27e9", "tactic_state": "case mpr\n\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b c : \u03b1\n\u22a2 a = c \u2227 a \u2264 b \u2228 b = c \u2227 b \u2264 a \u2192 min a b = c"}, {"line": "\u00b7 rintro (\u27e8rfl, h\u27e9 | \u27e8rfl, h\u27e9) <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem min_lt_min_left_iff : min a c < min b c \u2194 a < b \u2227 a < c := by\n  simp_rw [lt_min_iff, min_lt_iff, or_iff_left (lt_irrefl _)]\n  exact and_congr_left fun h => or_iff_left_of_imp h.trans\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/MinMax.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[LinearOrder \u03b1] [LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b c : \u03b1\n\u22a2 min a c < min b c \u2194 a < b \u2227 a < c"}, {"line": "simp_rw [lt_min_iff, min_lt_iff, or_iff_left (lt_irrefl _)]", "tactic_state": "\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b c : \u03b1\n\u22a2 (a < b \u2228 c < b) \u2227 a < c \u2194 a < b \u2227 a < c"}, {"line": "exact and_congr_left fun h => or_iff_left_of_imp h.trans", "tactic_state": "No Goals!"}]}
{"declaration": "theorem unbotD_eq_iff {d y : \u03b1} {x : WithBot \u03b1} : unbotD d x = y \u2194 x = y \u2228 x = \u22a5 \u2227 y = d := by\n  induction x <;> simp [@eq_comm _ d]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_5\nunbotD : x\u271d\nd y : \u03b1\nx : WithBot \u03b1\n\u22a2 sorry = y \u2194 x = \u2191y \u2228 x = \u22a5 \u2227 y = d"}, {"line": "induction x <;> simp [@eq_comm _ d]", "tactic_state": "case bot\n\u03b1 : Type u_1\nx\u271d : Sort u_5\nunbotD : x\u271d\nd y : \u03b1\n\u22a2 sorry () = y \u2194 y = d\n---\ncase coe\n\u03b1 : Type u_1\nx\u271d : Sort u_5\nunbotD : x\u271d\nd y a\u271d : \u03b1\n\u22a2 sorry () = y \u2194 a\u271d = y"}]}
{"declaration": "theorem unbotD_eq_self_iff {d : \u03b1} {x : WithBot \u03b1} : unbotD d x = d \u2194 x = d \u2228 x = \u22a5 := by\n  simp [unbotD_eq_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_5\nunbotD : x\u271d\nd : \u03b1\nx : WithBot \u03b1\n\u22a2 sorry = d \u2194 x = \u2191d \u2228 x = \u22a5"}, {"line": "simp [unbotD_eq_iff]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_5\nunbotD : x\u271d\nd : \u03b1\nx : WithBot \u03b1\n\u22a2 sorry () = d \u2194 x = \u2191d \u2228 x = \u22a5"}]}
{"declaration": "theorem some_eq_map_iff {f : \u03b1 \u2192 \u03b2} {y : \u03b2} {v : WithBot \u03b1} :\n    .some y = WithBot.map f v \u2194 \u2203 x, v = .some x \u2227 f x = y := by\n  cases v <;> simp [eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ny : \u03b2\nv : WithBot \u03b1\n\u22a2 \u2191y = WithBot.map f v \u2194 \u2203 x, v = \u2191x \u2227 f x = y"}, {"line": "cases v <;> simp [eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem unbot_eq_iff {a : WithBot \u03b1} {b : \u03b1} (h : a \u2260 \u22a5) :\n    a.unbot h = b \u2194 a = b := by\n  induction a\n  \u00b7 simpa using h rfl\n  \u00b7 simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : WithBot \u03b1\nb : \u03b1\nh : a \u2260 \u22a5\n\u22a2 a.unbot h = b \u2194 a = \u2191b"}, {"line": "induction a", "tactic_state": "case bot\n\u03b1 : Type u_1\nb : \u03b1\nh : \u22a5 \u2260 \u22a5\n\u22a2 \u22a5.unbot h = b \u2194 \u22a5 = \u2191b\n---\ncase coe\n\u03b1 : Type u_1\nb a\u271d : \u03b1\nh : \u2191a\u271d \u2260 \u22a5\n\u22a2 (\u2191a\u271d).unbot h = b \u2194 \u2191a\u271d = \u2191b"}, {"line": "\u00b7 simpa using h rfl", "tactic_state": "case coe\n\u03b1 : Type u_1\nb a\u271d : \u03b1\nh : \u2191a\u271d \u2260 \u22a5\n\u22a2 (\u2191a\u271d).unbot h = b \u2194 \u2191a\u271d = \u2191b"}, {"line": "\u00b7 simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_unbot_iff {a : \u03b1} {b : WithBot \u03b1} (h : b \u2260 \u22a5) :\n    a = b.unbot h \u2194 a = b := by\n  induction b\n  \u00b7 simpa using h rfl\n  \u00b7 simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\nb : WithBot \u03b1\nh : b \u2260 \u22a5\n\u22a2 a = b.unbot h \u2194 \u2191a = b"}, {"line": "induction b", "tactic_state": "case bot\n\u03b1 : Type u_1\na : \u03b1\nh : \u22a5 \u2260 \u22a5\n\u22a2 a = \u22a5.unbot h \u2194 \u2191a = \u22a5\n---\ncase coe\n\u03b1 : Type u_1\na a\u271d : \u03b1\nh : \u2191a\u271d \u2260 \u22a5\n\u22a2 a = (\u2191a\u271d).unbot h \u2194 \u2191a = \u2191a\u271d"}, {"line": "\u00b7 simpa using h rfl", "tactic_state": "case coe\n\u03b1 : Type u_1\na a\u271d : \u03b1\nh : \u2191a\u271d \u2260 \u22a5\n\u22a2 a = (\u2191a\u271d).unbot h \u2194 \u2191a = \u2191a\u271d"}, {"line": "\u00b7 simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_coe_le_bot (a : \u03b1) : \u00ac(a : WithBot \u03b1) \u2264 \u22a5 := by simp [le_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LE \u03b1\na : \u03b1\n\u22a2 \u00ac\u2191a \u2264 \u22a5"}, {"line": "simp [le_def]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma unbotD_le_iff (hx : x = \u22a5 \u2192 a \u2264 b) : x.unbotD a \u2264 b \u2194 x \u2264 b := by cases x <;> simp [hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : LE \u03b1\nx : WithBot \u03b1\nhx : x = \u22a5 \u2192 a \u2264 b\n\u22a2 WithBot.unbotD a x \u2264 b \u2194 x \u2264 \u2191b"}, {"line": "cases x <;> simp [hx]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lt_iff_exists_coe : x < y \u2194 \u2203 b : \u03b1, y = b \u2227 x < b := by cases y <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LT \u03b1\nx y : WithBot \u03b1\n\u22a2 x < y \u2194 \u2203 b, y = \u2191b \u2227 x < \u2191b"}, {"line": "cases y <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma unbotD_lt_iff (hx : x = \u22a5 \u2192 a < b) : x.unbotD a < b \u2194 x < b := by cases x <;> simp [hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LT \u03b1\nx : WithBot \u03b1\nhx : x = \u22a5 \u2192 a < b\n\u22a2 WithBot.unbotD a x < b \u2194 x < \u2191b"}, {"line": "cases x <;> simp [hx]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_le_iff (f : \u03b1 \u2192 \u03b2) (mono_iff : \u2200 {a b}, f a \u2264 f b \u2194 a \u2264 b) :\n    x.map f \u2264 y.map f \u2194 x \u2264 y := by cases x <;> cases y <;> simp [mono_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx y : WithBot \u03b1\nf : \u03b1 \u2192 \u03b2\nmono_iff : \u2200 {a b : \u03b1}, f a \u2264 f b \u2194 a \u2264 b\n\u22a2 WithBot.map f x \u2264 WithBot.map f y \u2194 x \u2264 y"}, {"line": "cases x <;> cases y <;> simp [mono_iff]", "tactic_state": "case coe.coe\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\nmono_iff : \u2200 {a b : \u03b1}, f a \u2264 f b \u2194 a \u2264 b\na\u271d\u00b9 a\u271d : \u03b1\n\u22a2 a\u271d\u00b9 \u2264 a\u271d \u2194 a\u271d\u00b9 \u2264 a\u271d"}]}
{"declaration": "theorem le_coe_unbotD (x : WithBot \u03b1) (b : \u03b1) : x \u2264 x.unbotD b := by cases x <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : LT \u03b1\ninst\u271d : Preorder \u03b1\nx : WithBot \u03b1\nb : \u03b1\n\u22a2 x \u2264 \u2191(WithBot.unbotD b x)"}, {"line": "cases x <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_coe_bot [OrderBot \u03b1] : x < (\u22a5 : \u03b1) \u2194 x = \u22a5 := by cases x <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\nx : WithBot \u03b1\ninst\u271d : OrderBot \u03b1\n\u22a2 x < \u2191\u22a5 \u2194 x = \u22a5"}, {"line": "cases x <;> simp", "tactic_state": "case coe\n\u03b1 : Type u_1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderBot \u03b1\na\u271d : \u03b1\n\u22a2 \u00aca\u271d < \u22a5"}]}
{"declaration": "lemma eq_bot_iff_forall_le [NoBotOrder \u03b1] : x = \u22a5 \u2194 \u2200 b : \u03b1, x \u2264 b := by\n  refine \u27e8by simp +contextual, fun h \u21a6 (x.eq_bot_iff_forall_ne).2 fun y => ?_\u27e9\n  rintro rfl\n  exact not_isBot y fun z => coe_le_coe.1 (h z)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\nx : WithBot \u03b1\ninst\u271d : NoBotOrder \u03b1\n\u22a2 x = \u22a5 \u2194 \u2200 (b : \u03b1), x \u2264 \u2191b"}, {"line": "refine \u27e8by simp +contextual, fun h \u21a6 (x.eq_bot_iff_forall_ne).2 fun y => ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\nx : WithBot \u03b1\ninst\u271d : NoBotOrder \u03b1\nh : \u2200 (b : \u03b1), x \u2264 \u2191b\ny : \u03b1\n\u22a2 \u2191y \u2260 x"}, {"line": "rintro rfl", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : NoBotOrder \u03b1\ny : \u03b1\nh : \u2200 (b : \u03b1), \u2191y \u2264 \u2191b\n\u22a2 False"}, {"line": "exact not_isBot y fun z => coe_le_coe.1 (h z)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma forall_le_coe_iff_le [NoBotOrder \u03b1] : (\u2200 a : \u03b1, y \u2264 a \u2192 x \u2264 a) \u2194 x \u2264 y := by\n  obtain _ | y := y\n  \u00b7 simp [WithBot.none_eq_bot, eq_bot_iff_forall_le]\n  \u00b7 exact \u27e8fun h \u21a6 h _ le_rfl, fun hmn a ham \u21a6 hmn.trans ham\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\nx y : WithBot \u03b1\ninst\u271d : NoBotOrder \u03b1\n\u22a2 (\u2200 (a : \u03b1), y \u2264 \u2191a \u2192 x \u2264 \u2191a) \u2194 x \u2264 y"}, {"line": "obtain _ | y := y", "tactic_state": "case none\n\u03b1 : Type u_1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\nx : WithBot \u03b1\ninst\u271d : NoBotOrder \u03b1\n\u22a2 (\u2200 (a : \u03b1), none \u2264 \u2191a \u2192 x \u2264 \u2191a) \u2194 x \u2264 none\n---\ncase some\n\u03b1 : Type u_1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\nx : WithBot \u03b1\ninst\u271d : NoBotOrder \u03b1\ny : \u03b1\n\u22a2 (\u2200 (a : \u03b1), some y \u2264 \u2191a \u2192 x \u2264 \u2191a) \u2194 x \u2264 some y"}, {"line": "\u00b7 simp [WithBot.none_eq_bot, eq_bot_iff_forall_le]", "tactic_state": "case some\n\u03b1 : Type u_1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\nx : WithBot \u03b1\ninst\u271d : NoBotOrder \u03b1\ny : \u03b1\n\u22a2 (\u2200 (a : \u03b1), some y \u2264 \u2191a \u2192 x \u2264 \u2191a) \u2194 x \u2264 some y"}, {"line": "\u00b7 exact \u27e8fun h \u21a6 h _ le_rfl, fun hmn a ham \u21a6 hmn.trans ham\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_of_forall_lt_iff_le : (\u2200 z : \u03b1, x < z \u2192 y \u2264 z) \u2194 y \u2264 x := by\n  cases x <;> cases y <;> simp [exists_lt, forall_gt_imp_ge_iff_le_of_dense]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : LE \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\nx y : WithBot \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\n\u22a2 (\u2200 (z : \u03b1), x < \u2191z \u2192 y \u2264 \u2191z) \u2194 y \u2264 x"}, {"line": "cases x <;> cases y <;> simp [exists_lt, forall_gt_imp_ge_iff_le_of_dense]", "tactic_state": "case bot.coe\n\u03b1 : Type u_1\ninst\u271d\u2077 : LE \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na\u271d : \u03b1\n\u22a2 \u2203 x, \u00aca\u271d \u2264 x\n---\ncase coe.coe\n\u03b1 : Type u_1\ninst\u271d\u2077 : LE \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na\u271d\u00b9 a\u271d : \u03b1\n\u22a2 (\u2200 (z : \u03b1), a\u271d\u00b9 < z \u2192 a\u271d \u2264 z) \u2194 a\u271d \u2264 a\u271d\u00b9"}]}
{"declaration": "lemma ge_of_forall_gt_iff_ge : (\u2200 z : \u03b1, z < x \u2192 z \u2264 y) \u2194 x \u2264 y := by\n  cases x <;> cases y <;> simp [exists_lt, forall_lt_imp_le_iff_le_of_dense]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : LE \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\nx y : WithBot \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\n\u22a2 (\u2200 (z : \u03b1), \u2191z < x \u2192 \u2191z \u2264 y) \u2194 x \u2264 y"}, {"line": "cases x <;> cases y <;> simp [exists_lt, forall_lt_imp_le_iff_le_of_dense]", "tactic_state": "case coe.bot\n\u03b1 : Type u_1\ninst\u271d\u2077 : LE \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na\u271d : \u03b1\n\u22a2 \u2203 x, x < a\u271d\n---\ncase coe.coe\n\u03b1 : Type u_1\ninst\u271d\u2077 : LE \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na\u271d\u00b9 a\u271d : \u03b1\n\u22a2 (\u2200 z < a\u271d\u00b9, z \u2264 a\u271d) \u2194 a\u271d\u00b9 \u2264 a\u271d"}]}
{"declaration": "lemma not_top_le_coe (a : \u03b1) : \u00ac \u22a4 \u2264 (a : WithTop \u03b1) := by simp [le_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2078 : LE \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : LE \u03b1\na : \u03b1\n\u22a2 \u00ac\u22a4 \u2264 \u2191a"}, {"line": "simp [le_def]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_untopD_iff (hy : y = \u22a4 \u2192 a \u2264 b) : a \u2264 y.untopD b \u2194 a \u2264 y := by cases y <;> simp [hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2078 : LE \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\na b : \u03b1\ninst\u271d : LE \u03b1\ny : WithTop \u03b1\nhy : y = \u22a4 \u2192 a \u2264 b\n\u22a2 a \u2264 WithTop.untopD b y \u2194 \u2191a \u2264 y"}, {"line": "cases y <;> simp [hy]", "tactic_state": "case coe\n\u03b1 : Type u_1\ninst\u271d\u2078 : LE \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\na b : \u03b1\ninst\u271d : LE \u03b1\na\u271d : \u03b1\nhy : \u2191a\u271d = \u22a4 \u2192 a \u2264 b\n\u22a2 a \u2264 a\u271d \u2194 a \u2264 a\u271d"}]}
{"declaration": "lemma lt_iff_exists_coe : x < y \u2194 \u2203 a : \u03b1, x = a \u2227 a < y := by cases x <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : LT \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : NoBotOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\ninst\u271d\u00b2 : NoMinOrder \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LT \u03b1\nx y : WithTop \u03b1\n\u22a2 x < y \u2194 \u2203 a, x = \u2191a \u2227 \u2191a < y"}, {"line": "cases x <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lt_untopD_iff (hy : y = \u22a4 \u2192 a < b) : a < y.untopD b \u2194 a < y := by cases y <;> simp [hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : LT \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : NoBotOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\ninst\u271d\u00b2 : NoMinOrder \u03b1\na b : \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LT \u03b1\ny : WithTop \u03b1\nhy : y = \u22a4 \u2192 a < b\n\u22a2 a < WithTop.untopD b y \u2194 \u2191a < y"}, {"line": "cases y <;> simp [hy]", "tactic_state": "case coe\n\u03b1 : Type u_1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : LT \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : NoBotOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\ninst\u271d\u00b2 : NoMinOrder \u03b1\na b : \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LT \u03b1\na\u271d : \u03b1\nhy : \u2191a\u271d = \u22a4 \u2192 a < b\n\u22a2 a < a\u271d \u2194 a < a\u271d"}]}
{"declaration": "theorem map_le_iff (f : \u03b1 \u2192 \u03b2) (mono_iff : \u2200 {a b}, f a \u2264 f b \u2194 a \u2264 b) :\n    x.map f \u2264 y.map f \u2194 x \u2264 y := by cases x <;> cases y <;> simp [mono_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b2 : LE \u03b1\ninst\u271d\u00b9\u00b9 : LT \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : PartialOrder \u03b1\ninst\u271d\u2077 : NoBotOrder \u03b1\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : DenselyOrdered \u03b1\ninst\u271d\u2074 : NoMinOrder \u03b1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx y : WithTop \u03b1\nf : \u03b1 \u2192 \u03b2\nmono_iff : \u2200 {a b : \u03b1}, f a \u2264 f b \u2194 a \u2264 b\n\u22a2 WithTop.map f x \u2264 WithTop.map f y \u2194 x \u2264 y"}, {"line": "cases x <;> cases y <;> simp [mono_iff]", "tactic_state": "case coe.coe\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b2 : LE \u03b1\ninst\u271d\u00b9\u00b9 : LT \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : PartialOrder \u03b1\ninst\u271d\u2077 : NoBotOrder \u03b1\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : DenselyOrdered \u03b1\ninst\u271d\u2074 : NoMinOrder \u03b1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\nmono_iff : \u2200 {a b : \u03b1}, f a \u2264 f b \u2194 a \u2264 b\na\u271d\u00b9 a\u271d : \u03b1\n\u22a2 a\u271d\u00b9 \u2264 a\u271d \u2194 a\u271d\u00b9 \u2264 a\u271d"}]}
{"declaration": "theorem coe_untopD_le (y : WithTop \u03b1) (a : \u03b1) : y.untopD a \u2264 y :=  by cases y <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2070 : LE \u03b1\ninst\u271d\u2079 : LT \u03b1\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : DenselyOrdered \u03b1\ninst\u271d\u00b3 : NoMinOrder \u03b1\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : LT \u03b1\ninst\u271d : Preorder \u03b1\ny : WithTop \u03b1\na : \u03b1\n\u22a2 \u2191(WithTop.untopD a y) \u2264 y"}, {"line": "cases y <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_top_lt [OrderTop \u03b1] : (\u22a4 : \u03b1) < x \u2194 x = \u22a4 := by cases x <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u00b9 : LE \u03b1\ninst\u271d\u00b9\u2070 : LT \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : PartialOrder \u03b1\ninst\u271d\u2077 : NoBotOrder \u03b1\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : DenselyOrdered \u03b1\ninst\u271d\u2074 : NoMinOrder \u03b1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\nx : WithTop \u03b1\ninst\u271d : OrderTop \u03b1\n\u22a2 \u2191\u22a4 < x \u2194 x = \u22a4"}, {"line": "cases x <;> simp", "tactic_state": "case coe\n\u03b1 : Type u_1\ninst\u271d\u00b9\u00b9 : LE \u03b1\ninst\u271d\u00b9\u2070 : LT \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : PartialOrder \u03b1\ninst\u271d\u2077 : NoBotOrder \u03b1\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : DenselyOrdered \u03b1\ninst\u271d\u2074 : NoMinOrder \u03b1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderTop \u03b1\na\u271d : \u03b1\n\u22a2 \u00ac\u22a4 < a\u271d"}]}
{"declaration": "lemma le_of_forall_lt_iff_le : (\u2200 b : \u03b1, x < b \u2192 y \u2264 b) \u2194 y \u2264 x := by\n  cases x <;> cases y <;> simp [exists_gt, forall_gt_imp_ge_iff_le_of_dense]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : LE \u03b1\ninst\u271d\u00b9\u2074 : LT \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b1\ninst\u271d\u00b9\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b9 : NoBotOrder \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : DenselyOrdered \u03b1\ninst\u271d\u2078 : NoMinOrder \u03b1\ninst\u271d\u2077 : LE \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : NoTopOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\nx y : WithTop \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u22a2 (\u2200 (b : \u03b1), x < \u2191b \u2192 y \u2264 \u2191b) \u2194 y \u2264 x"}, {"line": "cases x <;> cases y <;> simp [exists_gt, forall_gt_imp_ge_iff_le_of_dense]", "tactic_state": "case coe.top\n\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : LE \u03b1\ninst\u271d\u00b9\u2074 : LT \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b1\ninst\u271d\u00b9\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b9 : NoBotOrder \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : DenselyOrdered \u03b1\ninst\u271d\u2078 : NoMinOrder \u03b1\ninst\u271d\u2077 : LE \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : NoTopOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na\u271d : \u03b1\n\u22a2 \u2203 x, a\u271d < x\n---\ncase coe.coe\n\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : LE \u03b1\ninst\u271d\u00b9\u2074 : LT \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b1\ninst\u271d\u00b9\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b9 : NoBotOrder \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : DenselyOrdered \u03b1\ninst\u271d\u2078 : NoMinOrder \u03b1\ninst\u271d\u2077 : LE \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : NoTopOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na\u271d\u00b9 a\u271d : \u03b1\n\u22a2 (\u2200 (b : \u03b1), a\u271d\u00b9 < b \u2192 a\u271d \u2264 b) \u2194 a\u271d \u2264 a\u271d\u00b9"}]}
{"declaration": "lemma ge_of_forall_gt_iff_ge : (\u2200 a : \u03b1, a < x \u2192 a \u2264 y) \u2194 x \u2264 y := by\n  cases x <;> cases y <;> simp [exists_gt, forall_lt_imp_le_iff_le_of_dense]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : LE \u03b1\ninst\u271d\u00b9\u2074 : LT \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b1\ninst\u271d\u00b9\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b9 : NoBotOrder \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : DenselyOrdered \u03b1\ninst\u271d\u2078 : NoMinOrder \u03b1\ninst\u271d\u2077 : LE \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : NoTopOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\nx y : WithTop \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u22a2 (\u2200 (a : \u03b1), \u2191a < x \u2192 \u2191a \u2264 y) \u2194 x \u2264 y"}, {"line": "cases x <;> cases y <;> simp [exists_gt, forall_lt_imp_le_iff_le_of_dense]", "tactic_state": "case top.coe\n\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : LE \u03b1\ninst\u271d\u00b9\u2074 : LT \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b1\ninst\u271d\u00b9\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b9 : NoBotOrder \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : DenselyOrdered \u03b1\ninst\u271d\u2078 : NoMinOrder \u03b1\ninst\u271d\u2077 : LE \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : NoTopOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na\u271d : \u03b1\n\u22a2 \u2203 x, \u00acx \u2264 a\u271d\n---\ncase coe.coe\n\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : LE \u03b1\ninst\u271d\u00b9\u2074 : LT \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b1\ninst\u271d\u00b9\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b9 : NoBotOrder \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : DenselyOrdered \u03b1\ninst\u271d\u2078 : NoMinOrder \u03b1\ninst\u271d\u2077 : LE \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : NoTopOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na\u271d\u00b9 a\u271d : \u03b1\n\u22a2 (\u2200 a < a\u271d\u00b9, a \u2264 a\u271d) \u2194 a\u271d\u00b9 \u2264 a\u271d"}]}
{"declaration": "lemma WithBot.eq_top_iff_forall_ge [Preorder \u03b1] [Nonempty \u03b1] [NoTopOrder \u03b1]\n    {x : WithBot (WithTop \u03b1)} : x = \u22a4 \u2194 \u2200 a : \u03b1, a \u2264 x := by\n  refine \u27e8by aesop, fun H \u21a6 ?_\u27e9\n  induction x\n  \u00b7 simp at H\n  \u00b7 simpa [WithTop.eq_top_iff_forall_ge] using H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : LE \u03b1\ninst\u271d\u00b9\u2077 : LT \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : PartialOrder \u03b1\ninst\u271d\u00b9\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9\u00b9 : NoMinOrder \u03b1\ninst\u271d\u00b9\u2070 : LE \u03b1\ninst\u271d\u2079 : LT \u03b1\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : NoTopOrder \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : DenselyOrdered \u03b1\ninst\u271d\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : NoTopOrder \u03b1\nx : WithBot (WithTop \u03b1)\n\u22a2 x = \u22a4 \u2194 \u2200 (a : \u03b1), \u2191\u2191a \u2264 x"}, {"line": "refine \u27e8by aesop, fun H \u21a6 ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : LE \u03b1\ninst\u271d\u00b9\u2077 : LT \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : PartialOrder \u03b1\ninst\u271d\u00b9\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9\u00b9 : NoMinOrder \u03b1\ninst\u271d\u00b9\u2070 : LE \u03b1\ninst\u271d\u2079 : LT \u03b1\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : NoTopOrder \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : DenselyOrdered \u03b1\ninst\u271d\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : NoTopOrder \u03b1\nx : WithBot (WithTop \u03b1)\nH : \u2200 (a : \u03b1), \u2191\u2191a \u2264 x\n\u22a2 x = \u22a4"}, {"line": "induction x", "tactic_state": "case bot\n\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : LE \u03b1\ninst\u271d\u00b9\u2077 : LT \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : PartialOrder \u03b1\ninst\u271d\u00b9\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9\u00b9 : NoMinOrder \u03b1\ninst\u271d\u00b9\u2070 : LE \u03b1\ninst\u271d\u2079 : LT \u03b1\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : NoTopOrder \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : DenselyOrdered \u03b1\ninst\u271d\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : NoTopOrder \u03b1\nH : \u2200 (a : \u03b1), \u2191\u2191a \u2264 \u22a5\n\u22a2 \u22a5 = \u22a4\n---\ncase coe\n\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : LE \u03b1\ninst\u271d\u00b9\u2077 : LT \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : PartialOrder \u03b1\ninst\u271d\u00b9\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9\u00b9 : NoMinOrder \u03b1\ninst\u271d\u00b9\u2070 : LE \u03b1\ninst\u271d\u2079 : LT \u03b1\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : NoTopOrder \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : DenselyOrdered \u03b1\ninst\u271d\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : NoTopOrder \u03b1\na\u271d : WithTop \u03b1\nH : \u2200 (a : \u03b1), \u2191\u2191a \u2264 \u2191a\u271d\n\u22a2 \u2191a\u271d = \u22a4"}, {"line": "\u00b7 simp at H", "tactic_state": "case coe\n\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : LE \u03b1\ninst\u271d\u00b9\u2077 : LT \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : PartialOrder \u03b1\ninst\u271d\u00b9\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9\u00b9 : NoMinOrder \u03b1\ninst\u271d\u00b9\u2070 : LE \u03b1\ninst\u271d\u2079 : LT \u03b1\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : NoTopOrder \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : DenselyOrdered \u03b1\ninst\u271d\u00b3 : NoMaxOrder \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : NoTopOrder \u03b1\na\u271d : WithTop \u03b1\nH : \u2200 (a : \u03b1), \u2191\u2191a \u2264 \u2191a\u271d\n\u22a2 \u2191a\u271d = \u22a4"}, {"line": "\u00b7 simpa [WithTop.eq_top_iff_forall_ge] using H", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithBot.toDual_le_iff {x : WithBot \u03b1} {y : WithTop \u03b1\u1d52\u1d48} :\n    x.toDual \u2264 y \u2194 WithTop.ofDual y \u2264 x := by\n  cases x <;> cases y <;> simp [toDual_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : LE \u03b1\ninst\u271d\u00b9\u2075 : LT \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : DenselyOrdered \u03b1\ninst\u271d\u2079 : NoMinOrder \u03b1\ninst\u271d\u2078 : LE \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMaxOrder \u03b1\ninst\u271d : LE \u03b1\nx : WithBot \u03b1\ny : WithTop \u03b1\u1d52\u1d48\n\u22a2 WithBot.toDual x \u2264 y \u2194 WithTop.ofDual y \u2264 x"}, {"line": "cases x <;> cases y <;> simp [toDual_le]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithBot.le_toDual_iff {x : WithTop \u03b1\u1d52\u1d48} {y : WithBot \u03b1} :\n    x \u2264 WithBot.toDual y \u2194 y \u2264 WithTop.ofDual x := by cases x <;> cases y <;> simp [le_toDual]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : LE \u03b1\ninst\u271d\u00b9\u2075 : LT \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : DenselyOrdered \u03b1\ninst\u271d\u2079 : NoMinOrder \u03b1\ninst\u271d\u2078 : LE \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMaxOrder \u03b1\ninst\u271d : LE \u03b1\nx : WithTop \u03b1\u1d52\u1d48\ny : WithBot \u03b1\n\u22a2 x \u2264 WithBot.toDual y \u2194 y \u2264 WithTop.ofDual x"}, {"line": "cases x <;> cases y <;> simp [le_toDual]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithBot.toDual_le_toDual_iff {x y : WithBot \u03b1} : x.toDual \u2264 y.toDual \u2194 y \u2264 x := by\n  cases x <;> cases y <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : LE \u03b1\ninst\u271d\u00b9\u2075 : LT \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : DenselyOrdered \u03b1\ninst\u271d\u2079 : NoMinOrder \u03b1\ninst\u271d\u2078 : LE \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMaxOrder \u03b1\ninst\u271d : LE \u03b1\nx y : WithBot \u03b1\n\u22a2 WithBot.toDual x \u2264 WithBot.toDual y \u2194 y \u2264 x"}, {"line": "cases x <;> cases y <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithBot.ofDual_le_iff {x : WithBot \u03b1\u1d52\u1d48} {y : WithTop \u03b1} :\n    WithBot.ofDual x \u2264 y \u2194 y.toDual \u2264 x := by cases x <;> cases y <;> simp [toDual_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : LE \u03b1\ninst\u271d\u00b9\u2075 : LT \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : DenselyOrdered \u03b1\ninst\u271d\u2079 : NoMinOrder \u03b1\ninst\u271d\u2078 : LE \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMaxOrder \u03b1\ninst\u271d : LE \u03b1\nx : WithBot \u03b1\u1d52\u1d48\ny : WithTop \u03b1\n\u22a2 WithBot.ofDual x \u2264 y \u2194 WithTop.toDual y \u2264 x"}, {"line": "cases x <;> cases y <;> simp [toDual_le]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithBot.le_ofDual_iff {x : WithTop \u03b1} {y : WithBot \u03b1\u1d52\u1d48} :\n    x \u2264 WithBot.ofDual y \u2194 y \u2264 x.toDual := by cases x <;> cases y <;> simp [le_toDual]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : LE \u03b1\ninst\u271d\u00b9\u2075 : LT \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : DenselyOrdered \u03b1\ninst\u271d\u2079 : NoMinOrder \u03b1\ninst\u271d\u2078 : LE \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMaxOrder \u03b1\ninst\u271d : LE \u03b1\nx : WithTop \u03b1\ny : WithBot \u03b1\u1d52\u1d48\n\u22a2 x \u2264 WithBot.ofDual y \u2194 y \u2264 WithTop.toDual x"}, {"line": "cases x <;> cases y <;> simp [le_toDual]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithBot.ofDual_le_ofDual_iff {x y : WithBot \u03b1\u1d52\u1d48} :\n    WithBot.ofDual x \u2264 WithBot.ofDual y \u2194 y \u2264 x := by cases x <;> cases y <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : LE \u03b1\ninst\u271d\u00b9\u2075 : LT \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : DenselyOrdered \u03b1\ninst\u271d\u2079 : NoMinOrder \u03b1\ninst\u271d\u2078 : LE \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMaxOrder \u03b1\ninst\u271d : LE \u03b1\nx y : WithBot \u03b1\u1d52\u1d48\n\u22a2 WithBot.ofDual x \u2264 WithBot.ofDual y \u2194 y \u2264 x"}, {"line": "cases x <;> cases y <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithTop.toDual_le_iff {x : WithTop \u03b1} {y : WithBot \u03b1\u1d52\u1d48} :\n    x.toDual \u2264 y \u2194 WithBot.ofDual y \u2264 x := by cases x <;> cases y <;> simp [toDual_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : LE \u03b1\ninst\u271d\u00b9\u2075 : LT \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : DenselyOrdered \u03b1\ninst\u271d\u2079 : NoMinOrder \u03b1\ninst\u271d\u2078 : LE \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMaxOrder \u03b1\ninst\u271d : LE \u03b1\nx : WithTop \u03b1\ny : WithBot \u03b1\u1d52\u1d48\n\u22a2 WithTop.toDual x \u2264 y \u2194 WithBot.ofDual y \u2264 x"}, {"line": "cases x <;> cases y <;> simp [toDual_le]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithTop.le_toDual_iff {x : WithBot \u03b1\u1d52\u1d48} {y : WithTop \u03b1} :\n    x \u2264 WithTop.toDual y \u2194 y \u2264 WithBot.ofDual x := by cases x <;> cases y <;> simp [le_toDual]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : LE \u03b1\ninst\u271d\u00b9\u2075 : LT \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : DenselyOrdered \u03b1\ninst\u271d\u2079 : NoMinOrder \u03b1\ninst\u271d\u2078 : LE \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMaxOrder \u03b1\ninst\u271d : LE \u03b1\nx : WithBot \u03b1\u1d52\u1d48\ny : WithTop \u03b1\n\u22a2 x \u2264 WithTop.toDual y \u2194 y \u2264 WithBot.ofDual x"}, {"line": "cases x <;> cases y <;> simp [le_toDual]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithTop.toDual_le_toDual_iff {x y : WithTop \u03b1} : x.toDual \u2264 y.toDual \u2194 y \u2264 x := by\n  cases x <;> cases y <;> simp [le_toDual]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : LE \u03b1\ninst\u271d\u00b9\u2075 : LT \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : DenselyOrdered \u03b1\ninst\u271d\u2079 : NoMinOrder \u03b1\ninst\u271d\u2078 : LE \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMaxOrder \u03b1\ninst\u271d : LE \u03b1\nx y : WithTop \u03b1\n\u22a2 WithTop.toDual x \u2264 WithTop.toDual y \u2194 y \u2264 x"}, {"line": "cases x <;> cases y <;> simp [le_toDual]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithTop.ofDual_le_iff {x : WithTop \u03b1\u1d52\u1d48} {y : WithBot \u03b1} :\n    WithTop.ofDual x \u2264 y \u2194 y.toDual \u2264 x := by cases x <;> cases y <;> simp [toDual_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : LE \u03b1\ninst\u271d\u00b9\u2075 : LT \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : DenselyOrdered \u03b1\ninst\u271d\u2079 : NoMinOrder \u03b1\ninst\u271d\u2078 : LE \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMaxOrder \u03b1\ninst\u271d : LE \u03b1\nx : WithTop \u03b1\u1d52\u1d48\ny : WithBot \u03b1\n\u22a2 WithTop.ofDual x \u2264 y \u2194 WithBot.toDual y \u2264 x"}, {"line": "cases x <;> cases y <;> simp [toDual_le]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithTop.le_ofDual_iff {x : WithBot \u03b1} {y : WithTop \u03b1\u1d52\u1d48} :\n    x \u2264 WithTop.ofDual y \u2194 y \u2264 x.toDual := by cases x <;> cases y <;> simp [le_toDual]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : LE \u03b1\ninst\u271d\u00b9\u2075 : LT \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : DenselyOrdered \u03b1\ninst\u271d\u2079 : NoMinOrder \u03b1\ninst\u271d\u2078 : LE \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMaxOrder \u03b1\ninst\u271d : LE \u03b1\nx : WithBot \u03b1\ny : WithTop \u03b1\u1d52\u1d48\n\u22a2 x \u2264 WithTop.ofDual y \u2194 y \u2264 WithBot.toDual x"}, {"line": "cases x <;> cases y <;> simp [le_toDual]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithTop.ofDual_le_ofDual_iff {x y : WithTop \u03b1\u1d52\u1d48} :\n    WithTop.ofDual x \u2264 WithTop.ofDual y \u2194 y \u2264 x :=  by cases x <;> cases y <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : LE \u03b1\ninst\u271d\u00b9\u2075 : LT \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : DenselyOrdered \u03b1\ninst\u271d\u2079 : NoMinOrder \u03b1\ninst\u271d\u2078 : LE \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMaxOrder \u03b1\ninst\u271d : LE \u03b1\nx y : WithTop \u03b1\u1d52\u1d48\n\u22a2 WithTop.ofDual x \u2264 WithTop.ofDual y \u2194 y \u2264 x"}, {"line": "cases x <;> cases y <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithBot.toDual_lt_iff {x : WithBot \u03b1} {y : WithTop \u03b1\u1d52\u1d48} :\n    x.toDual < y \u2194 WithTop.ofDual y < x := by cases x <;> cases y <;> simp [toDual_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]", "[LT \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : LT \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : DenselyOrdered \u03b1\ninst\u271d\u00b9\u2070 : NoMinOrder \u03b1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : LT \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : NoTopOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LT \u03b1\nx : WithBot \u03b1\ny : WithTop \u03b1\u1d52\u1d48\n\u22a2 WithBot.toDual x < y \u2194 WithTop.ofDual y < x"}, {"line": "cases x <;> cases y <;> simp [toDual_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithBot.lt_toDual_iff {x : WithTop \u03b1\u1d52\u1d48} {y : WithBot \u03b1} :\n    x < y.toDual \u2194 y < WithTop.ofDual x := by cases x <;> cases y <;> simp [lt_toDual]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]", "[LT \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : LT \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : DenselyOrdered \u03b1\ninst\u271d\u00b9\u2070 : NoMinOrder \u03b1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : LT \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : NoTopOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LT \u03b1\nx : WithTop \u03b1\u1d52\u1d48\ny : WithBot \u03b1\n\u22a2 x < WithBot.toDual y \u2194 y < WithTop.ofDual x"}, {"line": "cases x <;> cases y <;> simp [lt_toDual]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithBot.toDual_lt_toDual_iff {x y : WithBot \u03b1} : x.toDual < y.toDual \u2194 y < x := by\n  cases x <;> cases y <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]", "[LT \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : LT \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : DenselyOrdered \u03b1\ninst\u271d\u00b9\u2070 : NoMinOrder \u03b1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : LT \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : NoTopOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LT \u03b1\nx y : WithBot \u03b1\n\u22a2 WithBot.toDual x < WithBot.toDual y \u2194 y < x"}, {"line": "cases x <;> cases y <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithBot.ofDual_lt_iff {x : WithBot \u03b1\u1d52\u1d48} {y : WithTop \u03b1} :\n    WithBot.ofDual x < y \u2194 y.toDual < x := by cases x <;> cases y <;> simp [toDual_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]", "[LT \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : LT \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : DenselyOrdered \u03b1\ninst\u271d\u00b9\u2070 : NoMinOrder \u03b1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : LT \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : NoTopOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LT \u03b1\nx : WithBot \u03b1\u1d52\u1d48\ny : WithTop \u03b1\n\u22a2 WithBot.ofDual x < y \u2194 WithTop.toDual y < x"}, {"line": "cases x <;> cases y <;> simp [toDual_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithBot.lt_ofDual_iff {x : WithTop \u03b1} {y : WithBot \u03b1\u1d52\u1d48} :\n    x < WithBot.ofDual y \u2194 y < x.toDual := by cases x <;> cases y <;> simp [lt_toDual]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]", "[LT \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : LT \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : DenselyOrdered \u03b1\ninst\u271d\u00b9\u2070 : NoMinOrder \u03b1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : LT \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : NoTopOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LT \u03b1\nx : WithTop \u03b1\ny : WithBot \u03b1\u1d52\u1d48\n\u22a2 x < WithBot.ofDual y \u2194 y < WithTop.toDual x"}, {"line": "cases x <;> cases y <;> simp [lt_toDual]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithBot.ofDual_lt_ofDual_iff {x y : WithBot \u03b1\u1d52\u1d48} :\n    WithBot.ofDual x < WithBot.ofDual y \u2194 y < x := by cases x <;> cases y <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]", "[LT \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : LT \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : DenselyOrdered \u03b1\ninst\u271d\u00b9\u2070 : NoMinOrder \u03b1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : LT \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : NoTopOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LT \u03b1\nx y : WithBot \u03b1\u1d52\u1d48\n\u22a2 WithBot.ofDual x < WithBot.ofDual y \u2194 y < x"}, {"line": "cases x <;> cases y <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithTop.toDual_lt_iff {x : WithTop \u03b1} {y : WithBot \u03b1\u1d52\u1d48} :\n    WithTop.toDual x < y \u2194 WithBot.ofDual y < x := by cases x <;> cases y <;> simp [toDual_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]", "[LT \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : LT \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : DenselyOrdered \u03b1\ninst\u271d\u00b9\u2070 : NoMinOrder \u03b1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : LT \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : NoTopOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LT \u03b1\nx : WithTop \u03b1\ny : WithBot \u03b1\u1d52\u1d48\n\u22a2 WithTop.toDual x < y \u2194 WithBot.ofDual y < x"}, {"line": "cases x <;> cases y <;> simp [toDual_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithTop.lt_toDual_iff {x : WithBot \u03b1\u1d52\u1d48} {y : WithTop \u03b1} :\n    x < WithTop.toDual y \u2194 y < WithBot.ofDual x := by cases x <;> cases y <;> simp [lt_toDual]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]", "[LT \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : LT \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : DenselyOrdered \u03b1\ninst\u271d\u00b9\u2070 : NoMinOrder \u03b1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : LT \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : NoTopOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LT \u03b1\nx : WithBot \u03b1\u1d52\u1d48\ny : WithTop \u03b1\n\u22a2 x < WithTop.toDual y \u2194 y < WithBot.ofDual x"}, {"line": "cases x <;> cases y <;> simp [lt_toDual]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithTop.toDual_lt_toDual_iff {x y : WithTop \u03b1} :\n    WithTop.toDual x < WithTop.toDual y \u2194 y < x := by cases x <;> cases y <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]", "[LT \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : LT \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : DenselyOrdered \u03b1\ninst\u271d\u00b9\u2070 : NoMinOrder \u03b1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : LT \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : NoTopOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LT \u03b1\nx y : WithTop \u03b1\n\u22a2 WithTop.toDual x < WithTop.toDual y \u2194 y < x"}, {"line": "cases x <;> cases y <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithTop.ofDual_lt_iff {x : WithTop \u03b1\u1d52\u1d48} {y : WithBot \u03b1} :\n    WithTop.ofDual x < y \u2194 WithBot.toDual y < x := by cases x <;> cases y <;> simp [toDual_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]", "[LT \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : LT \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : DenselyOrdered \u03b1\ninst\u271d\u00b9\u2070 : NoMinOrder \u03b1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : LT \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : NoTopOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LT \u03b1\nx : WithTop \u03b1\u1d52\u1d48\ny : WithBot \u03b1\n\u22a2 WithTop.ofDual x < y \u2194 WithBot.toDual y < x"}, {"line": "cases x <;> cases y <;> simp [toDual_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithTop.lt_ofDual_iff {x : WithBot \u03b1} {y : WithTop \u03b1\u1d52\u1d48} :\n    x < WithTop.ofDual y \u2194 y < WithBot.toDual x := by cases x <;> cases y <;> simp [lt_toDual]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]", "[LT \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : LT \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : DenselyOrdered \u03b1\ninst\u271d\u00b9\u2070 : NoMinOrder \u03b1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : LT \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : NoTopOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LT \u03b1\nx : WithBot \u03b1\ny : WithTop \u03b1\u1d52\u1d48\n\u22a2 x < WithTop.ofDual y \u2194 y < WithBot.toDual x"}, {"line": "cases x <;> cases y <;> simp [lt_toDual]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithTop.ofDual_lt_ofDual_iff {x y : WithTop \u03b1\u1d52\u1d48} :\n    WithTop.ofDual x < WithTop.ofDual y \u2194 y < x := by cases x <;> cases y <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WithBot.lean", "context": {"open": ["Function", "Function", "OrderDual", "OrderDual", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{a b : \u03b1}", "[LE \u03b1] {x y : WithBot \u03b1}", "[LT \u03b1] {x y : WithBot \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithBot \u03b1}", "[PartialOrder \u03b1] [NoBotOrder \u03b1] {x y : WithBot \u03b1}", "[LinearOrder \u03b1] {x y : WithBot \u03b1}", "[DenselyOrdered \u03b1] [NoMinOrder \u03b1]", "{a b : \u03b1}", "[LE \u03b1] {x y : WithTop \u03b1}", "[LT \u03b1] {x y : WithTop \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {x y : WithTop \u03b1}", "[PartialOrder \u03b1] [NoTopOrder \u03b1] {x y : WithTop \u03b1}", "[LinearOrder \u03b1] {x y : WithTop \u03b1}", "[DenselyOrdered \u03b1] [NoMaxOrder \u03b1]", "[LE \u03b1]", "[LT \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : LT \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : NoBotOrder \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : DenselyOrdered \u03b1\ninst\u271d\u00b9\u2070 : NoMinOrder \u03b1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : LT \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : NoTopOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\ninst\u271d\u00b2 : NoMaxOrder \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LT \u03b1\nx y : WithTop \u03b1\u1d52\u1d48\n\u22a2 WithTop.ofDual x < WithTop.ofDual y \u2194 y < x"}, {"line": "cases x <;> cases y <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma \u03c9ScottContinuous.const {x : \u03b2} : \u03c9ScottContinuous (Function.const \u03b1 x) := by\n  simp [\u03c9ScottContinuous, ScottContinuousOn, Set.range_nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/OmegaCompletePartialOrder.lean", "context": {"open": ["OmegaCompletePartialOrder", "Chain"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3]", "(c c' : Chain \u03b1)", "(f : \u03b1 \u2192o \u03b2)", "(g : \u03b2 \u2192o \u03b3)", "{f}", "[OmegaCompletePartialOrder \u03b1]", "[OmegaCompletePartialOrder \u03b2]", "[OmegaCompletePartialOrder \u03b3]", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : OmegaCompletePartialOrder \u03b2\nx : \u03b2\n\u22a2 \u03c9ScottContinuous (Function.const \u03b1 x)"}, {"line": "simp [\u03c9ScottContinuous, ScottContinuousOn, Set.range_nonempty]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma \u03c9ScottContinuous.map {\u03b2 \u03b3} {f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 Part \u03b2} (hg : \u03c9ScottContinuous g) :\n    \u03c9ScottContinuous fun x \u21a6 f <$> g x := by\n  simpa only [map_eq_bind_pure_comp] using \u03c9ScottContinuous.bind hg \u03c9ScottContinuous.const\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/OmegaCompletePartialOrder.lean", "context": {"open": ["OmegaCompletePartialOrder", "Chain", "OmegaCompletePartialOrder", "Classical in", "OmegaCompletePartialOrder OmegaCompletePartialOrder.Chain", "OmegaCompletePartialOrder", "OmegaCompletePartialOrder", "Chain in"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3]", "(c c' : Chain \u03b1)", "(f : \u03b1 \u2192o \u03b2)", "(g : \u03b2 \u2192o \u03b3)", "{f}", "[OmegaCompletePartialOrder \u03b1]", "[OmegaCompletePartialOrder \u03b2]", "[OmegaCompletePartialOrder \u03b3]", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{\u03b2 : \u03b1 \u2192 Type*}", "[\u2200 x, OmegaCompletePartialOrder <| \u03b2 x]", "[OmegaCompletePartialOrder \u03b3]", "{f : \u03b3 \u2192 \u2200 x, \u03b2 x}", "[OmegaCompletePartialOrder \u03b1]", "[OmegaCompletePartialOrder \u03b2]", "[OmegaCompletePartialOrder \u03b3]", "[OmegaCompletePartialOrder \u03b1] [CompleteLattice \u03b2] {f g : \u03b1 \u2192 \u03b2}", "[OmegaCompletePartialOrder \u03b1] [CompleteLinearOrder \u03b2] {f g : \u03b1 \u2192 \u03b2}", "[OmegaCompletePartialOrder \u03b1] [OmegaCompletePartialOrder \u03b2]", "[OmegaCompletePartialOrder \u03b3] [OmegaCompletePartialOrder \u03b4]", "(\u03b1 \u03b2) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "inst\u271d\u00b3 : OmegaCompletePartialOrder sorry\ninst\u271d\u00b2 : CompleteLattice sorry\ninst\u271d\u00b9 : CompleteLinearOrder sorry\ninst\u271d : OmegaCompletePartialOrder sorry\n\u03b1 : Type u_7\n\u03b2 \u03b3 : Type u_2\nf : \u03b2 \u2192 \u03b3\ng : \u03b1 \u2192 Part \u03b2\nhg : sorry\n\u22a2 sorry"}, {"line": "simpa only [map_eq_bind_pure_comp] using \u03c9ScottContinuous.bind hg \u03c9ScottContinuous.const", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_not_acc_lt_of_not_acc {a : \u03b1} {r} (h : \u00acAcc r a) : \u2203 b, \u00acAcc r b \u2227 r b a := by\n  contrapose! h\n  refine \u27e8_, fun b hr => ?_\u27e9\n  by_contra hb\n  exact h b hb hr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/OrderIsoNat.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsStrictOrder \u03b1 r]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u00acAcc r a\n\u22a2 \u2203 b, \u00acAcc r b \u2227 r b a"}, {"line": "contrapose! h", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (b : \u03b1), \u00acAcc r b \u2192 \u00acr b a\n\u22a2 Acc r a"}, {"line": "refine \u27e8_, fun b hr => ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (b : \u03b1), \u00acAcc r b \u2192 \u00acr b a\nb : \u03b1\nhr : r b a\n\u22a2 Acc r b"}, {"line": "by_contra hb", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (b : \u03b1), \u00acAcc r b \u2192 \u00acr b a\nb : \u03b1\nhr : r b a\nhb : \u00acAcc r b\n\u22a2 False"}, {"line": "exact h b hb hr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_subseq_of_forall_mem_union {s t : Set \u03b1} (e : \u2115 \u2192 \u03b1) (he : \u2200 n, e n \u2208 s \u222a t) :\n    \u2203 g : \u2115 \u21aao \u2115, (\u2200 n, e (g n) \u2208 s) \u2228 \u2200 n, e (g n) \u2208 t := by\n  classical\n    have : Infinite (e \u207b\u00b9' s) \u2228 Infinite (e \u207b\u00b9' t) := by\n      simp only [Set.infinite_coe_iff]\n      simp only [\u2190 Set.infinite_union]\n      simp only [\u2190 Set.preimage_union]\n      simp only [Set.eq_univ_of_forall fun n => Set.mem_preimage.2 (he n)]\n      simp only [Set.infinite_univ]\n    cases this\n    exacts [\u27e8Nat.orderEmbeddingOfSet (e \u207b\u00b9' s), Or.inl fun n => (Nat.Subtype.ofNat (e \u207b\u00b9' s) _).2\u27e9,\n      \u27e8Nat.orderEmbeddingOfSet (e \u207b\u00b9' t), Or.inr fun n => (Nat.Subtype.ofNat (e \u207b\u00b9' t) _).2\u27e9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/OrderIsoNat.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsStrictOrder \u03b1 r]", "(s : Set \u2115) [Infinite s]", "{s}", "(s)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\ne : \u2115 \u2192 \u03b1\nhe : \u2200 (n : \u2115), e n \u2208 s \u222a t\n\u22a2 \u2203 g, (\u2200 (n : \u2115), e (g n) \u2208 s) \u2228 \u2200 (n : \u2115), e (g n) \u2208 t"}, {"line": "classical\n    have : Infinite (e \u207b\u00b9' s) \u2228 Infinite (e \u207b\u00b9' t) := by\n      simp only [Set.infinite_coe_iff]\n      simp only [\u2190 Set.infinite_union]\n      simp only [\u2190 Set.preimage_union]\n      simp only [Set.eq_univ_of_forall fun n => Set.mem_preimage.2 (he n)]\n      simp only [Set.infinite_univ]\n    cases this\n    exacts [\u27e8Nat.orderEmbeddingOfSet (e \u207b\u00b9' s), Or.inl fun n => (Nat.Subtype.ofNat (e \u207b\u00b9' s) _).2\u27e9,\n      \u27e8Nat.orderEmbeddingOfSet (e \u207b\u00b9' t), Or.inr fun n => (Nat.Subtype.ofNat (e \u207b\u00b9' t) _).2\u27e9]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_increasing_or_nonincreasing_subseq' (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (f : \u2115 \u2192 \u03b1) :\n    \u2203 g : \u2115 \u21aao \u2115,\n      (\u2200 n : \u2115, r (f (g n)) (f (g (n + 1)))) \u2228 \u2200 m n : \u2115, m < n \u2192 \u00acr (f (g m)) (f (g n)) := by\n  classical\n    let bad : Set \u2115 := { m | \u2200 n, m < n \u2192 \u00acr (f m) (f n) }\n    by_cases hbad : Infinite bad\n    \u00b7 haveI := hbad\n      refine \u27e8Nat.orderEmbeddingOfSet bad, Or.intro_right _ fun m n mn => ?_\u27e9\n      have h := @Set.mem_range_self _ _ \u2191(Nat.orderEmbeddingOfSet bad) m\n      rw [Nat.orderEmbeddingOfSet_range bad] at h\n      exact h _ ((OrderEmbedding.lt_iff_lt _).2 mn)\n    \u00b7 rw [Set.infinite_coe_iff, Set.Infinite, not_not] at hbad\n      obtain \u27e8m, hm\u27e9 : \u2203 m, \u2200 n, m \u2264 n \u2192 \u00acn \u2208 bad := by\n        by_cases he : hbad.toFinset.Nonempty\n        \u00b7 refine\n            \u27e8(hbad.toFinset.max' he).succ, fun n hn nbad =>\n              Nat.not_succ_le_self _\n                (hn.trans (hbad.toFinset.le_max' n (hbad.mem_toFinset.2 nbad)))\u27e9\n        \u00b7 exact \u27e80, fun n _ nbad => he \u27e8n, hbad.mem_toFinset.2 nbad\u27e9\u27e9\n      have h : \u2200 n : \u2115, \u2203 n' : \u2115, n < n' \u2227 r (f (n + m)) (f (n' + m)) := by\n        intro n\n        have h := hm _ (Nat.le_add_left m n)\n        simp only [bad] at h\n        simp only [exists_prop] at h\n        simp only [not_not] at h\n        simp only [Set.mem_setOf_eq] at h\n        simp only [not_forall] at h\n        obtain \u27e8n', hn1, hn2\u27e9 := h\n        refine \u27e8n + n' - n - m, by omega, ?_\u27e9\n        convert hn2\n        omega\n      let g' : \u2115 \u2192 \u2115 := @Nat.rec (fun _ => \u2115) m fun n gn => Nat.find (h gn)\n      exact\n        \u27e8(RelEmbedding.natLT (fun n => g' n + m) fun n =>\n              Nat.add_lt_add_right (Nat.find_spec (h (g' n))).1 m).orderEmbeddingOfLTEmbedding,\n          Or.intro_left _ fun n => (Nat.find_spec (h (g' n))).2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/OrderIsoNat.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsStrictOrder \u03b1 r]", "(s : Set \u2115) [Infinite s]", "{s}", "(s)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : \u2115 \u2192 \u03b1\n\u22a2 \u2203 g, (\u2200 (n : \u2115), r (f (g n)) (f (g (n + 1)))) \u2228 \u2200 (m n : \u2115), m < n \u2192 \u00acr (f (g m)) (f (g n))"}, {"line": "classical\n    let bad : Set \u2115 := { m | \u2200 n, m < n \u2192 \u00acr (f m) (f n) }\n    by_cases hbad : Infinite bad\n    \u00b7 haveI := hbad\n      refine \u27e8Nat.orderEmbeddingOfSet bad, Or.intro_right _ fun m n mn => ?_\u27e9\n      have h := @Set.mem_range_self _ _ \u2191(Nat.orderEmbeddingOfSet bad) m\n      rw [Nat.orderEmbeddingOfSet_range bad] at h\n      exact h _ ((OrderEmbedding.lt_iff_lt _).2 mn)\n    \u00b7 rw [Set.infinite_coe_iff, Set.Infinite, not_not] at hbad\n      obtain \u27e8m, hm\u27e9 : \u2203 m, \u2200 n, m \u2264 n \u2192 \u00acn \u2208 bad := by\n        by_cases he : hbad.toFinset.Nonempty\n        \u00b7 refine\n            \u27e8(hbad.toFinset.max' he).succ, fun n hn nbad =>\n              Nat.not_succ_le_self _\n                (hn.trans (hbad.toFinset.le_max' n (hbad.mem_toFinset.2 nbad)))\u27e9\n        \u00b7 exact \u27e80, fun n _ nbad => he \u27e8n, hbad.mem_toFinset.2 nbad\u27e9\u27e9\n      have h : \u2200 n : \u2115, \u2203 n' : \u2115, n < n' \u2227 r (f (n + m)) (f (n' + m)) := by\n        intro n\n        have h := hm _ (Nat.le_add_left m n)\n        simp only [bad] at h\n        simp only [exists_prop] at h\n        simp only [not_not] at h\n        simp only [Set.mem_setOf_eq] at h\n        simp only [not_forall] at h\n        obtain \u27e8n', hn1, hn2\u27e9 := h\n        refine \u27e8n + n' - n - m, by omega, ?_\u27e9\n        convert hn2\n        omega\n      let g' : \u2115 \u2192 \u2115 := @Nat.rec (fun _ => \u2115) m fun n gn => Nat.find (h gn)\n      exact\n        \u27e8(RelEmbedding.natLT (fun n => g' n + m) fun n =>\n              Nat.add_lt_add_right (Nat.find_spec (h (g' n))).1 m).orderEmbeddingOfLTEmbedding,\n          Or.intro_left _ fun n => (Nat.find_spec (h (g' n))).2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem WellFounded.monotone_chain_condition' [Preorder \u03b1] :\n    WellFounded ((\u00b7 > \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u2194 \u2200 a : \u2115 \u2192o \u03b1, \u2203 n, \u2200 m, n \u2264 m \u2192 \u00aca n < a m := by\n  rw [\u2190 isWellFounded_iff]\n  exact wellFoundedGT_iff_monotone_chain_condition'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/OrderIsoNat.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsStrictOrder \u03b1 r]", "(s : Set \u2115) [Infinite s]", "{s}", "(s)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\n\u22a2 (WellFounded fun x1 x2 => x1 > x2) \u2194 \u2200 (a : \u2115 \u2192o \u03b1), \u2203 n, \u2200 (m : \u2115), n \u2264 m \u2192 \u00aca n < a m"}, {"line": "rw [\u2190 isWellFounded_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\n\u22a2 (IsWellFounded \u03b1 fun x1 x2 => x1 > x2) \u2194 \u2200 (a : \u2115 \u2192o \u03b1), \u2203 n, \u2200 (m : \u2115), n \u2264 m \u2192 \u00aca n < a m"}, {"line": "exact wellFoundedGT_iff_monotone_chain_condition'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem WellFounded.monotone_chain_condition [PartialOrder \u03b1] :\n    WellFounded ((\u00b7 > \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u2194 \u2200 a : \u2115 \u2192o \u03b1, \u2203 n, \u2200 m, n \u2264 m \u2192 a n = a m := by\n  rw [\u2190 isWellFounded_iff]\n  exact wellFoundedGT_iff_monotone_chain_condition\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/OrderIsoNat.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsStrictOrder \u03b1 r]", "(s : Set \u2115) [Infinite s]", "{s}", "(s)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PartialOrder \u03b1\n\u22a2 (WellFounded fun x1 x2 => x1 > x2) \u2194 \u2200 (a : \u2115 \u2192o \u03b1), \u2203 n, \u2200 (m : \u2115), n \u2264 m \u2192 a n = a m"}, {"line": "rw [\u2190 isWellFounded_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PartialOrder \u03b1\n\u22a2 (IsWellFounded \u03b1 fun x1 x2 => x1 > x2) \u2194 \u2200 (a : \u2115 \u2192o \u03b1), \u2203 n, \u2200 (m : \u2115), n \u2264 m \u2192 a n = a m"}, {"line": "exact wellFoundedGT_iff_monotone_chain_condition", "tactic_state": "No Goals!"}]}
{"declaration": "theorem WellFounded.iSup_eq_monotonicSequenceLimit [CompleteLattice \u03b1]\n    (h : WellFounded ((\u00b7 > \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)) (a : \u2115 \u2192o \u03b1) :\n    iSup a = monotonicSequenceLimit a := by\n  have : WellFoundedGT \u03b1 := \u27e8h\u27e9\n  exact WellFoundedGT.iSup_eq_monotonicSequenceLimit a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/OrderIsoNat.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsStrictOrder \u03b1 r]", "(s : Set \u2115) [Infinite s]", "{s}", "(s)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nh : WellFounded fun x1 x2 => x1 > x2\na : \u2115 \u2192o \u03b1\n\u22a2 iSup \u21d1a = monotonicSequenceLimit a"}, {"line": "have : WellFoundedGT \u03b1 := \u27e8h\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nh : WellFounded fun x1 x2 => x1 > x2\na : \u2115 \u2192o \u03b1\nthis : sorry\n\u22a2 iSup \u21d1a = monotonicSequenceLimit a"}, {"line": "exact WellFoundedGT.iSup_eq_monotonicSequenceLimit a", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Monotone.partMap (hg : Monotone g) : Monotone fun x \u21a6 (g x).map f := by\n  simpa only [\u2190 bind_some_eq_map] using hg.partBind monotone_const\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Part.lean", "context": {"open": ["Part"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} [Preorder \u03b1]", "{f : \u03b1 \u2192 Part \u03b2} {g : \u03b1 \u2192 \u03b2 \u2192 Part \u03b3}", "{f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 Part \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Preorder \u03b1\nf : \u03b2 \u2192 \u03b3\ng : \u03b1 \u2192 Part \u03b2\nhg : Monotone g\n\u22a2 Monotone fun x => map f (g x)"}, {"line": "simpa only [\u2190 bind_some_eq_map] using hg.partBind monotone_const", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Antitone.partMap (hg : Antitone g) : Antitone fun x \u21a6 (g x).map f := by\n  simpa only [\u2190 bind_some_eq_map] using hg.partBind antitone_const\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Part.lean", "context": {"open": ["Part"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} [Preorder \u03b1]", "{f : \u03b1 \u2192 Part \u03b2} {g : \u03b1 \u2192 \u03b2 \u2192 Part \u03b3}", "{f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 Part \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Preorder \u03b1\nf : \u03b2 \u2192 \u03b3\ng : \u03b1 \u2192 Part \u03b2\nhg : Antitone g\n\u22a2 Antitone fun x => map f (g x)"}, {"line": "simpa only [\u2190 bind_some_eq_map] using hg.partBind antitone_const", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Monotone.partSeq (hf : Monotone f) (hg : Monotone g) : Monotone fun x \u21a6 f x <*> g x := by\n  simpa only [seq_eq_bind_map] using hf.partBind <| Monotone.of_apply\u2082 fun _ \u21a6 hg.partMap\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Part.lean", "context": {"open": ["Part"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} [Preorder \u03b1]", "{f : \u03b1 \u2192 Part \u03b2} {g : \u03b1 \u2192 \u03b2 \u2192 Part \u03b3}", "{f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 Part \u03b2}", "{\u03b2 \u03b3 : Type _} {f : \u03b1 \u2192 Part (\u03b2 \u2192 \u03b3)} {g : \u03b1 \u2192 Part \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\n\u03b2 \u03b3 : Type u_4\nf : \u03b1 \u2192 Part (\u03b2 \u2192 \u03b3)\ng : \u03b1 \u2192 Part \u03b2\nhf : Monotone f\nhg : Monotone g\n\u22a2 Monotone fun x => f x <*> g x"}, {"line": "simpa only [seq_eq_bind_map] using hf.partBind <| Monotone.of_apply\u2082 fun _ \u21a6 hg.partMap", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Antitone.partSeq (hf : Antitone f) (hg : Antitone g) : Antitone fun x \u21a6 f x <*> g x := by\n  simpa only [seq_eq_bind_map] using hf.partBind <| Antitone.of_apply\u2082 fun _ \u21a6 hg.partMap\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Part.lean", "context": {"open": ["Part"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} [Preorder \u03b1]", "{f : \u03b1 \u2192 Part \u03b2} {g : \u03b1 \u2192 \u03b2 \u2192 Part \u03b3}", "{f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 Part \u03b2}", "{\u03b2 \u03b3 : Type _} {f : \u03b1 \u2192 Part (\u03b2 \u2192 \u03b3)} {g : \u03b1 \u2192 Part \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\n\u03b2 \u03b3 : Type u_4\nf : \u03b1 \u2192 Part (\u03b2 \u2192 \u03b3)\ng : \u03b1 \u2192 Part \u03b2\nhf : Antitone f\nhg : Antitone g\n\u22a2 Antitone fun x => f x <*> g x"}, {"line": "simpa only [seq_eq_bind_map] using hf.partBind <| Antitone.of_apply\u2082 fun _ \u21a6 hg.partMap", "tactic_state": "No Goals!"}]}
{"declaration": "lemma upperBounds_range_partialSups (f : \u03b9 \u2192 \u03b1) :\n    upperBounds (Set.range (partialSups f)) = upperBounds (Set.range f) := by\n  ext a\n  simp only [mem_upperBounds]\n  simp only [Set.forall_mem_range]\n  simp only [partialSups_le_iff]\n  exact \u27e8fun h _ \u21a6 h _ _ le_rfl, fun h _ _ _ \u21a6 h _\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/PartialSups.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 \u03b9 : Type*}", "[SemilatticeSup \u03b1]", "[Preorder \u03b9] [LocallyFiniteOrderBot \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : Preorder \u03b9\ninst\u271d : LocallyFiniteOrderBot \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 upperBounds (Set.range \u21d1(partialSups f)) = upperBounds (Set.range f)"}, {"line": "ext a", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : Preorder \u03b9\ninst\u271d : LocallyFiniteOrderBot \u03b9\nf : \u03b9 \u2192 \u03b1\na : \u03b1\n\u22a2 a \u2208 upperBounds (Set.range \u21d1(partialSups f)) \u2194 a \u2208 upperBounds (Set.range f)"}, {"line": "simp only [mem_upperBounds]", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : Preorder \u03b9\ninst\u271d : LocallyFiniteOrderBot \u03b9\nf : \u03b9 \u2192 \u03b1\na : \u03b1\n\u22a2 (\u2200 x \u2208 Set.range \u21d1(partialSups f), x \u2264 a) \u2194 \u2200 x \u2208 Set.range f, x \u2264 a"}, {"line": "simp only [Set.forall_mem_range]", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : Preorder \u03b9\ninst\u271d : LocallyFiniteOrderBot \u03b9\nf : \u03b9 \u2192 \u03b1\na : \u03b1\n\u22a2 (\u2200 (i : \u03b9), (partialSups f) i \u2264 a) \u2194 \u2200 (i : \u03b9), f i \u2264 a"}, {"line": "simp only [partialSups_le_iff]", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : Preorder \u03b9\ninst\u271d : LocallyFiniteOrderBot \u03b9\nf : \u03b9 \u2192 \u03b1\na : \u03b1\n\u22a2 (\u2200 (i j : \u03b9), j \u2264 i \u2192 f j \u2264 a) \u2194 \u2200 (i : \u03b9), f i \u2264 a"}, {"line": "exact \u27e8fun h _ \u21a6 h _ _ le_rfl, fun h _ _ _ \u21a6 h _\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma Pi.partialSups_apply {\u03c4 : Type*} {\u03c0 : \u03c4 \u2192 Type*} [\u2200 t, SemilatticeSup (\u03c0 t)]\n    (f : \u03b9 \u2192 (t : \u03c4) \u2192 \u03c0 t) (i : \u03b9) (t : \u03c4) :\n    partialSups f i t = partialSups (f \u00b7 t) i := by\n  simp only [partialSups_apply]\n  simp only [Finset.sup'_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/PartialSups.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 \u03b9 : Type*}", "[SemilatticeSup \u03b1]", "[Preorder \u03b9] [LocallyFiniteOrderBot \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\n\u03c4 : Type u_3\n\u03c0 : \u03c4 \u2192 Type u_4\ninst\u271d : (t : \u03c4) \u2192 SemilatticeSup (\u03c0 t)\nf : \u03b9 \u2192 (t : \u03c4) \u2192 \u03c0 t\ni : \u03b9\nt : \u03c4\n\u22a2 (partialSups f) i t = (partialSups fun x => f x t) i"}, {"line": "simp only [partialSups_apply]", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\n\u03c4 : Type u_3\n\u03c0 : \u03c4 \u2192 Type u_4\ninst\u271d : (t : \u03c4) \u2192 SemilatticeSup (\u03c0 t)\nf : \u03b9 \u2192 (t : \u03c4) \u2192 \u03c0 t\ni : \u03b9\nt : \u03c4\n\u22a2 (Iic i).sup' \u22ef f t = (Iic i).sup' \u22ef fun x => f x t"}, {"line": "simp only [Finset.sup'_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ciSup_partialSups_eq' [ConditionallyCompleteLinearOrder \u03b1] (f : \u03b9 \u2192 \u03b1) :\n    \u2a06 i, partialSups f i = \u2a06 i, f i := by\n  by_cases h : BddAbove (Set.range f)\n  \u00b7 exact ciSup_partialSups_eq h\n  \u00b7 rw [iSup, iSup, ConditionallyCompleteLinearOrder.csSup_of_not_bddAbove _ h,\n      ConditionallyCompleteLinearOrder.csSup_of_not_bddAbove _\n        (bddAbove_range_partialSups.not.mpr h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/PartialSups.lean", "context": {"open": ["Finset", "scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b1 \u03b9 : Type*}", "[SemilatticeSup \u03b1]", "[Preorder \u03b9] [LocallyFiniteOrderBot \u03b9]", "[Preorder \u03b9] [LocallyFiniteOrderBot \u03b9] [DistribLattice \u03b1] [OrderBot \u03b1]", "[Preorder \u03b9] [LocallyFiniteOrderBot \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u2079 : SemilatticeSup \u03b1\ninst\u271d\u2078 : Preorder \u03b9\ninst\u271d\u2077 : LocallyFiniteOrderBot \u03b9\ninst\u271d\u2076 : Preorder \u03b9\ninst\u271d\u2075 : LocallyFiniteOrderBot \u03b9\ninst\u271d\u2074 : DistribLattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : Preorder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\nf : \u03b9 \u2192 \u03b1\n\u22a2 \u2a06 i, (partialSups f) i = \u2a06 i, f i"}, {"line": "by_cases h : BddAbove (Set.range f)", "tactic_state": "case pos\n\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u2079 : SemilatticeSup \u03b1\ninst\u271d\u2078 : Preorder \u03b9\ninst\u271d\u2077 : LocallyFiniteOrderBot \u03b9\ninst\u271d\u2076 : Preorder \u03b9\ninst\u271d\u2075 : LocallyFiniteOrderBot \u03b9\ninst\u271d\u2074 : DistribLattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : Preorder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\nf : \u03b9 \u2192 \u03b1\nh : sorry\n\u22a2 \u2a06 i, (partialSups f) i = \u2a06 i, f i\n---\ncase neg\n\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u2079 : SemilatticeSup \u03b1\ninst\u271d\u2078 : Preorder \u03b9\ninst\u271d\u2077 : LocallyFiniteOrderBot \u03b9\ninst\u271d\u2076 : Preorder \u03b9\ninst\u271d\u2075 : LocallyFiniteOrderBot \u03b9\ninst\u271d\u2074 : DistribLattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : Preorder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\nf : \u03b9 \u2192 \u03b1\nh : \u00acsorry\n\u22a2 \u2a06 i, (partialSups f) i = \u2a06 i, f i"}, {"line": "\u00b7 exact ciSup_partialSups_eq h", "tactic_state": "case neg\n\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u2079 : SemilatticeSup \u03b1\ninst\u271d\u2078 : Preorder \u03b9\ninst\u271d\u2077 : LocallyFiniteOrderBot \u03b9\ninst\u271d\u2076 : Preorder \u03b9\ninst\u271d\u2075 : LocallyFiniteOrderBot \u03b9\ninst\u271d\u2074 : DistribLattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : Preorder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\nf : \u03b9 \u2192 \u03b1\nh : \u00acsorry\n\u22a2 \u2a06 i, (partialSups f) i = \u2a06 i, f i"}, {"line": "\u00b7 rw [iSup, iSup, ConditionallyCompleteLinearOrder.csSup_of_not_bddAbove _ h,\n      ConditionallyCompleteLinearOrder.csSup_of_not_bddAbove _\n        (bddAbove_range_partialSups.not.mpr h)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem partialSups_eq_biSup (f : \u03b9 \u2192 \u03b1) (i : \u03b9) :\n    partialSups f i = \u2a06 j \u2264 i, f j := by\n  simpa only [iSup_subtype] using partialSups_eq_ciSup_Iic f i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/PartialSups.lean", "context": {"open": ["Finset", "scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b1 \u03b9 : Type*}", "[SemilatticeSup \u03b1]", "[Preorder \u03b9] [LocallyFiniteOrderBot \u03b9]", "[Preorder \u03b9] [LocallyFiniteOrderBot \u03b9] [DistribLattice \u03b1] [OrderBot \u03b1]", "[Preorder \u03b9] [LocallyFiniteOrderBot \u03b9]", "[Preorder \u03b9] [LocallyFiniteOrderBot \u03b9] [CompleteLattice \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9\u00b9 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b9\ninst\u271d\u2079 : LocallyFiniteOrderBot \u03b9\ninst\u271d\u2078 : Preorder \u03b9\ninst\u271d\u2077 : LocallyFiniteOrderBot \u03b9\ninst\u271d\u2076 : DistribLattice \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : Preorder \u03b9\ninst\u271d\u00b3 : LocallyFiniteOrderBot \u03b9\ninst\u271d\u00b2 : Preorder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : CompleteLattice \u03b1\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\n\u22a2 (partialSups f) i = \u2a06 j, \u2a06 (_ : j \u2264 i), f j"}, {"line": "simpa only [iSup_subtype] using partialSups_eq_ciSup_Iic f i", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q \u2194 \u00ac(P \u2194 Q) := by\n  rw [_root_.isCompl_iff]\n  rw [Prop.disjoint_iff]\n  rw [Prop.codisjoint_iff]\n  rw [not_iff]\n  by_cases P <;> by_cases Q <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/PropInstances.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*} {\u03b1' : \u03b9 \u2192 Type*} [\u2200 i, PartialOrder (\u03b1' i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\n\u22a2 IsCompl P Q \u2194 \u00ac(P \u2194 Q)"}, {"line": "rw [_root_.isCompl_iff]", "tactic_state": "P Q : Prop\n\u22a2 Disjoint P Q \u2227 Codisjoint P Q \u2194 \u00ac(P \u2194 Q)"}, {"line": "rw [Prop.disjoint_iff]", "tactic_state": "P Q : Prop\n\u22a2 \u00ac(P \u2227 Q) \u2227 Codisjoint P Q \u2194 \u00ac(P \u2194 Q)"}, {"line": "rw [Prop.codisjoint_iff]", "tactic_state": "P Q : Prop\n\u22a2 \u00ac(P \u2227 Q) \u2227 (P \u2228 Q) \u2194 \u00ac(P \u2194 Q)"}, {"line": "rw [not_iff]", "tactic_state": "P Q : Prop\n\u22a2 \u00ac(P \u2227 Q) \u2227 (P \u2228 Q) \u2194 (\u00acP \u2194 Q)"}, {"line": "by_cases P <;> by_cases Q <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma updateFinset_frestrictLe (a : \u03b1) (x : \u03a0 a, \u03c0 a) : updateFinset x _ (frestrictLe a x) = x := by\n  simp [frestrictLe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Restriction.lean", "context": {"open": ["Set", "Finset", "Function"], "variables": ["{\u03b1 : Type*} [Preorder \u03b1] {\u03c0 : \u03b1 \u2192 Type*}", "[LocallyFiniteOrderBot \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Preorder \u03b1\n\u03c0 : \u03b1 \u2192 Type u_2\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_3\nfrestrictLe : x\u271d\na : \u03b1\nx : (a : \u03b1) \u2192 \u03c0 a\n\u22a2 updateFinset x (?m.592 a x) sorry = x"}, {"line": "simp [frestrictLe]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Preorder \u03b1\n\u03c0 : \u03b1 \u2192 Type u_2\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_3\nfrestrictLe : x\u271d\na : \u03b1\nx : (a : \u03b1) \u2192 \u03c0 a\n\u22a2 updateFinset x (?m.592 a x) (sorry ()) = x"}]}
{"declaration": "theorem supIndep_attach : (s.attach.SupIndep fun a => f a) \u2194 s.SupIndep f := by\n  simpa [Finset.attach_map_val] using (supIndep_map (s := s.attach) (g := .subtype _)).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SupIndep.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b9 \u03b9' : Type*}", "[Lattice \u03b1] [OrderBot \u03b1]", "{s t : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {i : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 (s.attach.SupIndep fun a => f \u2191a) \u2194 s.SupIndep f"}, {"line": "simpa [Finset.attach_map_val] using (supIndep_map (s := s.attach) (g := .subtype _)).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sSupIndep_iff {\u03b1 : Type*} [CompleteLattice \u03b1] (s : Set \u03b1) :\n    sSupIndep s \u2194 iSupIndep ((\u2191) : s \u2192 \u03b1) := by\n  simp_rw [iSupIndep, sSupIndep, SetCoe.forall, sSup_eq_iSup]\n  refine forall\u2082_congr fun a ha => ?_\n  simp [iSup_subtype, iSup_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SupIndep.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 \u03b2 \u03b9 \u03b9' : Type*}", "[Lattice \u03b1] [OrderBot \u03b1]", "{s t : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {i : \u03b9}", "[DistribLattice \u03b1] [OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1]", "{s : Set \u03b1} (hs : sSupIndep s)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\n\u22a2 sSupIndep s \u2194 iSupIndep Subtype.val"}, {"line": "simp_rw [iSupIndep, sSupIndep, SetCoe.forall, sSup_eq_iSup]", "tactic_state": "\u03b1 : Type u_5\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\n\u22a2 (\u2200 \u2983a : \u03b1\u2984, a \u2208 s \u2192 Disjoint a (\u2a06 a_2 \u2208 s \\ {a}, a_2)) \u2194\n    \u2200 (x : \u03b1) (h : x \u2208 s), Disjoint x (\u2a06 j, \u2a06 (_ : j \u2260 \u27e8x, h\u27e9), \u2191j)"}, {"line": "refine forall\u2082_congr fun a ha => ?_", "tactic_state": "\u03b1 : Type u_5\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\na : \u03b1\nha : a \u2208 s\n\u22a2 Disjoint a (\u2a06 a_1 \u2208 s \\ {a}, a_1) \u2194 Disjoint a (\u2a06 j, \u2a06 (_ : j \u2260 \u27e8a, ha\u27e9), \u2191j)"}, {"line": "simp [iSup_subtype, iSup_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSupIndep_def' : iSupIndep t \u2194 \u2200 i, Disjoint (t i) (sSup (t '' { j | j \u2260 i })) := by\n  simp_rw [sSup_image]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SupIndep.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 \u03b2 \u03b9 \u03b9' : Type*}", "[Lattice \u03b1] [OrderBot \u03b1]", "{s t : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {i : \u03b9}", "[DistribLattice \u03b1] [OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1]", "{s : Set \u03b1} (hs : sSupIndep s)", "{t : \u03b9 \u2192 \u03b1} (ht : iSupIndep t)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\nt : \u03b9 \u2192 \u03b1\n\u22a2 iSupIndep t \u2194 \u2200 (i : \u03b9), Disjoint (t i) (sSup (t '' {j | j \u2260 i}))"}, {"line": "simp_rw [sSup_image]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\nt : \u03b9 \u2192 \u03b1\n\u22a2 iSupIndep t \u2194 \u2200 (i : \u03b9), Disjoint (t i) (\u2a06 a \u2208 {j | j \u2260 i}, t a)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSupIndep_def'' :\n    iSupIndep t \u2194 \u2200 i, Disjoint (t i) (sSup { a | \u2203 j \u2260 i, t j = a }) := by\n  rw [iSupIndep_def']\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SupIndep.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 \u03b2 \u03b9 \u03b9' : Type*}", "[Lattice \u03b1] [OrderBot \u03b1]", "{s t : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {i : \u03b9}", "[DistribLattice \u03b1] [OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1]", "{s : Set \u03b1} (hs : sSupIndep s)", "{t : \u03b9 \u2192 \u03b1} (ht : iSupIndep t)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\nt : \u03b9 \u2192 \u03b1\n\u22a2 iSupIndep t \u2194 \u2200 (i : \u03b9), Disjoint (t i) (sSup {a | \u2203 j, j \u2260 i \u2227 t j = a})"}, {"line": "rw [iSupIndep_def']", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\nt : \u03b9 \u2192 \u03b1\n\u22a2 (\u2200 (i : \u03b9), Disjoint (t i) (sSup (t '' {j | j \u2260 i}))) \u2194 \u2200 (i : \u03b9), Disjoint (t i) (sSup {a | \u2203 j, j \u2260 i \u2227 t j = a})"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSupIndep.comp' {\u03b9 \u03b9' : Sort*} {t : \u03b9 \u2192 \u03b1} {f : \u03b9' \u2192 \u03b9} (ht : iSupIndep <| t \u2218 f)\n    (hf : Surjective f) : iSupIndep t := by\n  intro i\n  obtain \u27e8i', rfl\u27e9 := hf i\n  rw [\u2190 hf.iSup_comp]\n  exact (ht i').mono_right (biSup_mono fun j' hij => mt (congr_arg f) hij)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SupIndep.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 \u03b2 \u03b9 \u03b9' : Type*}", "[Lattice \u03b1] [OrderBot \u03b1]", "{s t : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {i : \u03b9}", "[DistribLattice \u03b1] [OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1]", "{s : Set \u03b1} (hs : sSupIndep s)", "{t : \u03b9 \u2192 \u03b1} (ht : iSupIndep t)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\nt : \u03b9 \u2192 \u03b1\nf : \u03b9' \u2192 \u03b9\nht : iSupIndep (t \u2218 f)\nhf : Surjective f\n\u22a2 iSupIndep t"}, {"line": "intro i", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\nt : \u03b9 \u2192 \u03b1\nf : \u03b9' \u2192 \u03b9\nht : iSupIndep (t \u2218 f)\nhf : Surjective f\ni : \u03b9\n\u22a2 Disjoint (t i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t j)"}, {"line": "obtain \u27e8i', rfl\u27e9 := hf i", "tactic_state": "case intro\n\u03b1 : Type u_1\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\nt : \u03b9 \u2192 \u03b1\nf : \u03b9' \u2192 \u03b9\nht : iSupIndep (t \u2218 f)\nhf : Surjective f\ni' : \u03b9'\n\u22a2 Disjoint (t (f i')) (\u2a06 j, \u2a06 (_ : j \u2260 f i'), t j)"}, {"line": "rw [\u2190 hf.iSup_comp]", "tactic_state": "case intro\n\u03b1 : Type u_1\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\nt : \u03b9 \u2192 \u03b1\nf : \u03b9' \u2192 \u03b9\nht : iSupIndep (t \u2218 f)\nhf : Surjective f\ni' : \u03b9'\n\u22a2 Disjoint (t (f i')) (\u2a06 x, \u2a06 (_ : f x \u2260 f i'), t (f x))"}, {"line": "exact (ht i').mono_right (biSup_mono fun j' hij => mt (congr_arg f) hij)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSupIndep.sSupIndep_range (ht : iSupIndep t) : sSupIndep <| range t := by\n  rw [sSupIndep_iff]\n  rw [\u2190 coe_comp_rangeFactorization t] at ht\n  exact ht.comp' surjective_onto_range\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SupIndep.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 \u03b2 \u03b9 \u03b9' : Type*}", "[Lattice \u03b1] [OrderBot \u03b1]", "{s t : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {i : \u03b9}", "[DistribLattice \u03b1] [OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1]", "{s : Set \u03b1} (hs : sSupIndep s)", "{t : \u03b9 \u2192 \u03b1} (ht : iSupIndep t)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\nt : \u03b9 \u2192 \u03b1\nht : iSupIndep t\n\u22a2 sSupIndep (range t)"}, {"line": "rw [sSupIndep_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\nt : \u03b9 \u2192 \u03b1\nht : iSupIndep t\n\u22a2 iSupIndep Subtype.val"}, {"line": "rw [\u2190 coe_comp_rangeFactorization t] at ht", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\nt : \u03b9 \u2192 \u03b1\nht : iSupIndep (Subtype.val \u2218 rangeFactorization t)\n\u22a2 iSupIndep Subtype.val"}, {"line": "exact ht.comp' surjective_onto_range", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSupIndep.injective (ht : iSupIndep t) (h_ne_bot : \u2200 i, t i \u2260 \u22a5) : Injective t := by\n  suffices univ = {i | t i \u2260 \u22a5} by rw [injective_iff_injOn_univ, this]; exact ht.injOn\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SupIndep.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 \u03b2 \u03b9 \u03b9' : Type*}", "[Lattice \u03b1] [OrderBot \u03b1]", "{s t : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {i : \u03b9}", "[DistribLattice \u03b1] [OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1]", "{s : Set \u03b1} (hs : sSupIndep s)", "{t : \u03b9 \u2192 \u03b1} (ht : iSupIndep t)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\nt : \u03b9 \u2192 \u03b1\nht : iSupIndep t\nh_ne_bot : \u2200 (i : \u03b9), t i \u2260 \u22a5\n\u22a2 Injective t"}, {"line": "suffices univ = {i | t i \u2260 \u22a5} by rw [injective_iff_injOn_univ, this]; exact ht.injOn", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\nt : \u03b9 \u2192 \u03b1\nht : iSupIndep t\nh_ne_bot : \u2200 (i : \u03b9), t i \u2260 \u22a5\n\u22a2 univ = {i | t i \u2260 sorry}"}, {"line": "aesop", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst : Lattice \u03b1\ninst_1 : OrderBot \u03b1\ninst_2 : DistribLattice \u03b1\ninst_3 : OrderBot \u03b1\ninst_4 : CompleteLattice \u03b1\nt : \u03b9 \u2192 \u03b1\nht : iSupIndep t\nh_ne_bot : \u2200 (i : \u03b9), \u00act i = \u22a5\n\u22a2 univ = {i | \u00act i = sorry ()}"}]}
{"declaration": "lemma iSupIndep.of_coe_Iic_comp {\u03b9 : Sort*} {a : \u03b1} {t : \u03b9 \u2192 Set.Iic a}\n    (ht : iSupIndep ((\u2191) \u2218 t : \u03b9 \u2192 \u03b1)) : iSupIndep t := by\n  intro i x\n  specialize ht i\n  simp_rw [Function.comp_apply, \u2190 Set.Iic.coe_iSup] at ht\n  exact @ht x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SupIndep.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 \u03b2 \u03b9 \u03b9' : Type*}", "[Lattice \u03b1] [OrderBot \u03b1]", "{s t : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {i : \u03b9}", "[DistribLattice \u03b1] [OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1]", "{s : Set \u03b1} (hs : sSupIndep s)", "{t : \u03b9 \u2192 \u03b1} (ht : iSupIndep t)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\n\u03b9 : Sort u_5\na : \u03b1\nt : \u03b9 \u2192 \u2191(Iic a)\nht : iSupIndep (Subtype.val \u2218 t)\n\u22a2 iSupIndep t"}, {"line": "intro i x", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\n\u03b9 : Sort u_5\na : \u03b1\nt : \u03b9 \u2192 \u2191(Iic a)\nht : iSupIndep (Subtype.val \u2218 t)\ni : \u03b9\nx : \u2191(Iic a)\n\u22a2 x \u2264 t i \u2192 x \u2264 \u2a06 j, \u2a06 (_ : j \u2260 i), t j \u2192 x \u2264 \u22a5"}, {"line": "specialize ht i", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\n\u03b9 : Sort u_5\na : \u03b1\nt : \u03b9 \u2192 \u2191(Iic a)\ni : \u03b9\nx : \u2191(Iic a)\nht : Disjoint ((Subtype.val \u2218 t) i) (\u2a06 j, \u2a06 (_ : j \u2260 i), (Subtype.val \u2218 t) j)\n\u22a2 x \u2264 t i \u2192 x \u2264 \u2a06 j, \u2a06 (_ : j \u2260 i), t j \u2192 x \u2264 \u22a5"}, {"line": "simp_rw [Function.comp_apply, \u2190 Set.Iic.coe_iSup] at ht", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : Lattice \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : DistribLattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\n\u03b9 : Sort u_5\na : \u03b1\nt : \u03b9 \u2192 \u2191(Iic a)\ni : \u03b9\nx : \u2191(Iic a)\nht : Disjoint \u2191(t i) \u2191(\u2a06 i_1, \u2a06 (_ : i_1 \u2260 i), t i_1)\n\u22a2 x \u2264 t i \u2192 x \u2264 \u2a06 j, \u2a06 (_ : j \u2260 i), t j \u2192 x \u2264 \u22a5"}, {"line": "exact @ht x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSupIndep_iff_supIndep_univ [Fintype \u03b9] {f : \u03b9 \u2192 \u03b1} :\n    iSupIndep f \u2194 Finset.univ.SupIndep f := by\n  classical\n    simp [Finset.supIndep_iff_disjoint_erase, iSupIndep, Finset.sup_eq_iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SupIndep.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 \u03b2 \u03b9 \u03b9' : Type*}", "[Lattice \u03b1] [OrderBot \u03b1]", "{s t : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {i : \u03b9}", "[DistribLattice \u03b1] [OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1]", "{s : Set \u03b1} (hs : sSupIndep s)", "{t : \u03b9 \u2192 \u03b1} (ht : iSupIndep t)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : OrderBot \u03b1\ninst\u271d\u00b3 : DistribLattice \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : Fintype \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 iSupIndep f \u2194 Finset.univ.SupIndep f"}, {"line": "classical\n    simp [Finset.supIndep_iff_disjoint_erase, iSupIndep, Finset.sup_eq_iSup]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : OrderBot \u03b1\ninst\u271d\u00b3 : DistribLattice \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : Fintype \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 (\u2200 (i : \u03b9), Disjoint (f i) (\u2a06 j, \u2a06 (_ : \u00acj = i), f j)) \u2194 \u2200 (i : \u03b9), Disjoint (f i) ((Finset.univ.erase i).sup f)"}]}
{"declaration": "theorem Bool.symmDiff_eq_xor : \u2200 p q : Bool, p \u2206 q = xor p q := by decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (p q : Bool), symmDiff p q = (p ^^ q)"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "theorem symmDiff_comm : a \u2206 b = b \u2206 a := by simp only [symmDiff, sup_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 symmDiff a b = symmDiff b a"}, {"line": "simp only [symmDiff, sup_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem symmDiff_self : a \u2206 a = \u22a5 := by rw [symmDiff, sup_idem, sdiff_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na : \u03b1\n\u22a2 symmDiff a a = \u22a5"}, {"line": "rw [symmDiff, sup_idem, sdiff_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem symmDiff_bot : a \u2206 \u22a5 = a := by rw [symmDiff, sdiff_bot, bot_sdiff, sup_bot_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na : \u03b1\n\u22a2 symmDiff a \u22a5 = a"}, {"line": "rw [symmDiff, sdiff_bot, bot_sdiff, sup_bot_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bot_symmDiff : \u22a5 \u2206 a = a := by rw [symmDiff_comm, symmDiff_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na : \u03b1\n\u22a2 symmDiff \u22a5 a = a"}, {"line": "rw [symmDiff_comm, symmDiff_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem symmDiff_of_le {a b : \u03b1} (h : a \u2264 b) : a \u2206 b = b \\ a := by\n  rw [symmDiff]\n  rw [sdiff_eq_bot_iff.2 h]\n  rw [bot_sup_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\nh : a \u2264 b\n\u22a2 symmDiff a b = b \\ a"}, {"line": "rw [symmDiff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\nh : a \u2264 b\n\u22a2 a \\ b \u2294 b \\ a = b \\ a"}, {"line": "rw [sdiff_eq_bot_iff.2 h]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\nh : a \u2264 b\n\u22a2 \u22a5 \u2294 b \\ a = b \\ a"}, {"line": "rw [bot_sup_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem symmDiff_of_ge {a b : \u03b1} (h : b \u2264 a) : a \u2206 b = a \\ b := by\n  rw [symmDiff]\n  rw [sdiff_eq_bot_iff.2 h]\n  rw [sup_bot_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\nh : b \u2264 a\n\u22a2 symmDiff a b = a \\ b"}, {"line": "rw [symmDiff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\nh : b \u2264 a\n\u22a2 a \\ b \u2294 b \\ a = a \\ b"}, {"line": "rw [sdiff_eq_bot_iff.2 h]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\nh : b \u2264 a\n\u22a2 a \\ b \u2294 \u22a5 = a \\ b"}, {"line": "rw [sup_bot_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem symmDiff_le_iff {a b c : \u03b1} : a \u2206 b \u2264 c \u2194 a \u2264 b \u2294 c \u2227 b \u2264 a \u2294 c := by\n  simp_rw [symmDiff, sup_le_iff, sdiff_le_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 symmDiff a b \u2264 c \u2194 a \u2264 b \u2294 c \u2227 b \u2264 a \u2294 c"}, {"line": "simp_rw [symmDiff, sup_le_iff, sdiff_le_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem symmDiff_eq_sup_sdiff_inf : a \u2206 b = (a \u2294 b) \\ (a \u2293 b) := by simp [sup_sdiff, symmDiff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 symmDiff a b = (a \u2294 b) \\ (a \u2293 b)"}, {"line": "simp [sup_sdiff, symmDiff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem symmDiff_sdiff : a \u2206 b \\ c = a \\ (b \u2294 c) \u2294 b \\ (a \u2294 c) := by\n  rw [symmDiff]\n  rw [sup_sdiff_distrib]\n  rw [sdiff_sdiff_left]\n  rw [sdiff_sdiff_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 symmDiff a b \\ c = a \\ (b \u2294 c) \u2294 b \\ (a \u2294 c)"}, {"line": "rw [symmDiff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 (a \\ b \u2294 b \\ a) \\ c = a \\ (b \u2294 c) \u2294 b \\ (a \u2294 c)"}, {"line": "rw [sup_sdiff_distrib]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 (a \\ b) \\ c \u2294 (b \\ a) \\ c = a \\ (b \u2294 c) \u2294 b \\ (a \u2294 c)"}, {"line": "rw [sdiff_sdiff_left]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \\ (b \u2294 c) \u2294 (b \\ a) \\ c = a \\ (b \u2294 c) \u2294 b \\ (a \u2294 c)"}, {"line": "rw [sdiff_sdiff_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem symmDiff_sdiff_inf : a \u2206 b \\ (a \u2293 b) = a \u2206 b := by\n  rw [symmDiff_sdiff]\n  simp [symmDiff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 symmDiff a b \\ (a \u2293 b) = symmDiff a b"}, {"line": "rw [symmDiff_sdiff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 a \\ (b \u2294 a \u2293 b) \u2294 b \\ (a \u2294 a \u2293 b) = symmDiff a b"}, {"line": "simp [symmDiff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem symmDiff_sdiff_eq_sup : a \u2206 (b \\ a) = a \u2294 b := by\n  rw [symmDiff]\n  rw [sdiff_idem]\n  exact\n    le_antisymm (sup_le_sup sdiff_le sdiff_le)\n      (sup_le le_sdiff_sup <| le_sdiff_sup.trans <| sup_le le_sup_right le_sdiff_sup)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 symmDiff a (b \\ a) = a \u2294 b"}, {"line": "rw [symmDiff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 a \\ (b \\ a) \u2294 (b \\ a) \\ a = a \u2294 b"}, {"line": "rw [sdiff_idem]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 a \\ (b \\ a) \u2294 b \\ a = a \u2294 b"}, {"line": "exact\n    le_antisymm (sup_le_sup sdiff_le sdiff_le)\n      (sup_le le_sdiff_sup <| le_sdiff_sup.trans <| sup_le le_sup_right le_sdiff_sup)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sdiff_symmDiff_eq_sup : (a \\ b) \u2206 b = a \u2294 b := by\n  rw [symmDiff_comm]\n  rw [symmDiff_sdiff_eq_sup]\n  rw [sup_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 symmDiff (a \\ b) b = a \u2294 b"}, {"line": "rw [symmDiff_comm]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 symmDiff b (a \\ b) = a \u2294 b"}, {"line": "rw [symmDiff_sdiff_eq_sup]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 b \u2294 a = a \u2294 b"}, {"line": "rw [sup_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_sup_symmDiff : a \u2293 b \u2294 a \u2206 b = a \u2294 b := by rw [sup_comm, symmDiff_sup_inf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 a \u2293 b \u2294 symmDiff a b = a \u2294 b"}, {"line": "rw [sup_comm, symmDiff_sup_inf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_symmDiff_symmDiff : (a \u2293 b) \u2206 (a \u2206 b) = a \u2294 b := by\n  rw [symmDiff_comm]\n  rw [symmDiff_symmDiff_inf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 symmDiff (a \u2293 b) (symmDiff a b) = a \u2294 b"}, {"line": "rw [symmDiff_comm]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 symmDiff (symmDiff a b) (a \u2293 b) = a \u2294 b"}, {"line": "rw [symmDiff_symmDiff_inf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_symmDiff_sup_right (a b : \u03b1) : a \u2264 (a \u2206 b) \u2294 b := by\n  convert symmDiff_triangle a b \u22a5 <;> rw [symmDiff_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 a \u2264 symmDiff a b \u2294 b"}, {"line": "convert symmDiff_triangle a b \u22a5 <;> rw [symmDiff_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bihimp_self : a \u21d4 a = \u22a4 := by rw [bihimp, inf_idem, himp_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)", "[GeneralizedHeytingAlgebra \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedCoheytingAlgebra \u03b1\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na : \u03b1\n\u22a2 bihimp a a = \u22a4"}, {"line": "rw [bihimp, inf_idem, himp_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bihimp_eq_inf_himp_inf : a \u21d4 b = a \u2294 b \u21e8 a \u2293 b := by simp [himp_inf_distrib, bihimp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)", "[GeneralizedHeytingAlgebra \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedCoheytingAlgebra \u03b1\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b : \u03b1\n\u22a2 bihimp a b = a \u2294 b \u21e8 a \u2293 b"}, {"line": "simp [himp_inf_distrib, bihimp]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedCoheytingAlgebra \u03b1\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b : \u03b1\n\u22a2 (b \u21e8 a) \u2293 (a \u21e8 b) = a \u2294 b \u21e8 a \u2293 b"}]}
{"declaration": "theorem symmDiff_top' : a \u2206 \u22a4 = \uffe2a := by simp [symmDiff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)", "[GeneralizedHeytingAlgebra \u03b1] (a b c : \u03b1)", "[CoheytingAlgebra \u03b1] (a : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : GeneralizedCoheytingAlgebra \u03b1\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : CoheytingAlgebra \u03b1\na : \u03b1\n\u22a2 symmDiff a \u22a4 = \uffe2a"}, {"line": "simp [symmDiff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : GeneralizedCoheytingAlgebra \u03b1\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : CoheytingAlgebra \u03b1\na : \u03b1\n\u22a2 a \\ \u22a4 \u2294 \u22a4 \\ a = \uffe2a"}]}
{"declaration": "theorem top_symmDiff' : \u22a4 \u2206 a = \uffe2a := by simp [symmDiff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)", "[GeneralizedHeytingAlgebra \u03b1] (a b c : \u03b1)", "[CoheytingAlgebra \u03b1] (a : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : GeneralizedCoheytingAlgebra \u03b1\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : CoheytingAlgebra \u03b1\na : \u03b1\n\u22a2 symmDiff \u22a4 a = \uffe2a"}, {"line": "simp [symmDiff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : GeneralizedCoheytingAlgebra \u03b1\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : CoheytingAlgebra \u03b1\na : \u03b1\n\u22a2 \u22a4 \\ a \u2294 a \\ \u22a4 = \uffe2a"}]}
{"declaration": "theorem bot_bihimp : \u22a5 \u21d4 a = a\u1d9c := by simp [bihimp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/SymmDiff.lean", "context": {"open": ["Function OrderDual", "scoped symmDiff"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedCoheytingAlgebra \u03b1] (a b c : \u03b1)", "[GeneralizedHeytingAlgebra \u03b1] (a b c : \u03b1)", "[CoheytingAlgebra \u03b1] (a : \u03b1)", "[HeytingAlgebra \u03b1] (a : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : GeneralizedCoheytingAlgebra \u03b1\ninst\u271d\u00b2 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d\u00b9 : CoheytingAlgebra \u03b1\ninst\u271d : HeytingAlgebra \u03b1\na : \u03b1\n\u22a2 bihimp \u22a5 a = a\u1d9c"}, {"line": "simp [bihimp]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : GeneralizedCoheytingAlgebra \u03b1\ninst\u271d\u00b2 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d\u00b9 : CoheytingAlgebra \u03b1\ninst\u271d : HeytingAlgebra \u03b1\na : \u03b1\n\u22a2 (a \u21e8 \u22a5) \u2293 (\u22a5 \u21e8 a) = a\u1d9c"}]}
{"declaration": "theorem toDual_inj {a b : \u03b1} : toDual a = toDual b \u2194 a = b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Synonym.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\ntoDual : x\u271d\na b : \u03b1\n\u22a2 sorry = sorry \u2194 a = b"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\ntoDual : x\u271d\na b : \u03b1\n\u22a2 a = b"}]}
{"declaration": "theorem toLex_inj {a b : \u03b1} : toLex a = toLex b \u2194 a = b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Synonym.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\n\u22a2 toLex a = toLex b \u2194 a = b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofLex_inj {a b : Lex \u03b1} : ofLex a = ofLex b \u2194 a = b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Synonym.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : Lex \u03b1\n\u22a2 ofLex a = ofLex b \u2194 a = b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem wellFounded_iff_has_min {r : \u03b1 \u2192 \u03b1 \u2192 Prop} :\n    WellFounded r \u2194 \u2200 s : Set \u03b1, s.Nonempty \u2192 \u2203 m \u2208 s, \u2200 x \u2208 s, \u00acr x m := by\n  refine \u27e8fun h => h.has_min, fun h => \u27e8fun x => ?_\u27e9\u27e9\n  by_contra hx\n  obtain \u27e8m, hm, hm'\u27e9 := h {x | \u00acAcc r x} \u27e8x, hx\u27e9\n  refine hm \u27e8_, fun y hy => ?_\u27e9\n  by_contra hy'\n  exact hm' y hy' hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WellFounded.lean", "context": {"open": ["scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{r r' : \u03b1 \u2192 \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 WellFounded r \u2194 \u2200 (s : Set \u03b1), s.Nonempty \u2192 \u2203 m \u2208 s, \u2200 x \u2208 s, \u00acr x m"}, {"line": "refine \u27e8fun h => h.has_min, fun h => \u27e8fun x => ?_\u27e9\u27e9", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (s : Set \u03b1), s.Nonempty \u2192 \u2203 m \u2208 s, \u2200 x \u2208 s, \u00acr x m\nx : \u03b1\n\u22a2 Acc r x"}, {"line": "by_contra hx", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (s : Set \u03b1), s.Nonempty \u2192 \u2203 m \u2208 s, \u2200 x \u2208 s, \u00acr x m\nx : \u03b1\nhx : \u00acAcc r x\n\u22a2 False"}, {"line": "obtain \u27e8m, hm, hm'\u27e9 := h {x | \u00acAcc r x} \u27e8x, hx\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (s : Set \u03b1), s.Nonempty \u2192 \u2203 m \u2208 s, \u2200 x \u2208 s, \u00acr x m\nx : \u03b1\nhx : \u00acAcc r x\nm : \u03b1\nhm : m \u2208 {x | \u00acAcc r x}\nhm' : \u2200 x \u2208 {x | \u00acAcc r x}, \u00acr x m\n\u22a2 False"}, {"line": "refine hm \u27e8_, fun y hy => ?_\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (s : Set \u03b1), s.Nonempty \u2192 \u2203 m \u2208 s, \u2200 x \u2208 s, \u00acr x m\nx : \u03b1\nhx : \u00acAcc r x\nm : \u03b1\nhm : m \u2208 {x | \u00acAcc r x}\nhm' : \u2200 x \u2208 {x | \u00acAcc r x}, \u00acr x m\ny : \u03b1\nhy : r y m\n\u22a2 Acc r y"}, {"line": "by_contra hy'", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (s : Set \u03b1), s.Nonempty \u2192 \u2203 m \u2208 s, \u2200 x \u2208 s, \u00acr x m\nx : \u03b1\nhx : \u00acAcc r x\nm : \u03b1\nhm : m \u2208 {x | \u00acAcc r x}\nhm' : \u2200 x \u2208 {x | \u00acAcc r x}, \u00acr x m\ny : \u03b1\nhy : r y m\nhy' : \u00acAcc r y\n\u22a2 False"}, {"line": "exact hm' y hy' hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_rel_apply_succ [h : IsWellFounded \u03b1 r] (f : \u2115 \u2192 \u03b1) : \u2203 n, \u00ac r (f (n + 1)) (f n) := by\n  by_contra! hf\n  exact (wellFounded_iff_no_descending_seq.1 h.wf).elim \u27e8f, hf\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WellFounded.lean", "context": {"open": ["scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{r r' : \u03b1 \u2192 \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : IsWellFounded \u03b1 r\nf : \u2115 \u2192 \u03b1\n\u22a2 \u2203 n, \u00acr (f (n + 1)) (f n)"}, {"line": "by_contra! hf", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : IsWellFounded \u03b1 r\nf : \u2115 \u2192 \u03b1\nhf : \u2200 (n : \u2115), r (f (n + 1)) (f n)\n\u22a2 False"}, {"line": "exact (wellFounded_iff_no_descending_seq.1 h.wf).elim \u27e8f, hf\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsAntichain.finite_of_wellQuasiOrdered {s : Set \u03b1} (hs : IsAntichain r s)\n    (hr : WellQuasiOrdered r) : s.Finite := by\n  refine Set.not_infinite.1 fun hi => ?_\n  obtain \u27e8m, n, hmn, h\u27e9 := hr fun n => hi.natEmbedding _ n\n  exact hmn.ne ((hi.natEmbedding _).injective <| Subtype.val_injective <|\n    hs.eq (hi.natEmbedding _ m).2 (hi.natEmbedding _ n).2 h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WellQuasiOrder.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\nhs : IsAntichain r s\nhr : WellQuasiOrdered r\n\u22a2 s.Finite"}, {"line": "refine Set.not_infinite.1 fun hi => ?_", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\nhs : IsAntichain r s\nhr : WellQuasiOrdered r\nhi : s.Infinite\n\u22a2 False"}, {"line": "obtain \u27e8m, n, hmn, h\u27e9 := hr fun n => hi.natEmbedding _ n", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\nhs : IsAntichain r s\nhr : WellQuasiOrdered r\nhi : s.Infinite\nm n : \u2115\nhmn : m < n\nh : r \u2191((Set.Infinite.natEmbedding s hi) m) \u2191((Set.Infinite.natEmbedding s hi) n)\n\u22a2 False"}, {"line": "exact hmn.ne ((hi.natEmbedding _).injective <| Subtype.val_injective <|\n    hs.eq (hi.natEmbedding _ m).2 (hi.natEmbedding _ n).2 h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.wellQuasiOrdered (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [Finite \u03b1] [IsRefl \u03b1 r] :\n    WellQuasiOrdered r := by\n  intro f\n  obtain \u27e8m, n, h, hf\u27e9 := Set.finite_univ.exists_lt_map_eq_of_forall_mem (f := f)\n    fun _ \u21a6 Set.mem_univ _\n  exact \u27e8m, n, h, hf \u25b8 refl _\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WellQuasiOrder.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : IsRefl \u03b1 r\n\u22a2 WellQuasiOrdered r"}, {"line": "intro f", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : IsRefl \u03b1 r\nf : \u2115 \u2192 \u03b1\n\u22a2 \u2203 m n, m < n \u2227 r (f m) (f n)"}, {"line": "obtain \u27e8m, n, h, hf\u27e9 := Set.finite_univ.exists_lt_map_eq_of_forall_mem (f := f)\n    fun _ \u21a6 Set.mem_univ _", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : IsRefl \u03b1 r\nf : \u2115 \u2192 \u03b1\nm n : \u2115\nh : m < n\nhf : f m = f n\n\u22a2 \u2203 m n, m < n \u2227 r (f m) (f n)"}, {"line": "exact \u27e8m, n, h, hf \u25b8 refl _\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem wellQuasiOrdered_iff_exists_monotone_subseq [IsPreorder \u03b1 r] :\n    WellQuasiOrdered r \u2194 \u2200 f : \u2115 \u2192 \u03b1, \u2203 g : \u2115 \u21aao \u2115, \u2200 m n : \u2115, m \u2264 n \u2192 r (f (g m)) (f (g n)) := by\n  constructor <;> intro h f\n  \u00b7 exact h.exists_monotone_subseq f\n  \u00b7 obtain \u27e8g, gmon\u27e9 := h f\n    exact \u27e8_, _, g.strictMono Nat.zero_lt_one, gmon _ _ (Nat.zero_le 1)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WellQuasiOrder.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsPreorder \u03b1 r\n\u22a2 WellQuasiOrdered r \u2194 \u2200 (f : \u2115 \u2192 \u03b1), \u2203 g, \u2200 (m n : \u2115), m \u2264 n \u2192 r (f (g m)) (f (g n))"}, {"line": "constructor <;> intro h f", "tactic_state": "case mp\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsPreorder \u03b1 r\nh : WellQuasiOrdered r\nf : \u2115 \u2192 \u03b1\n\u22a2 \u2203 g, \u2200 (m n : \u2115), m \u2264 n \u2192 r (f (g m)) (f (g n))\n---\ncase mpr\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsPreorder \u03b1 r\nh : \u2200 (f : \u2115 \u2192 \u03b1), \u2203 g, \u2200 (m n : \u2115), m \u2264 n \u2192 r (f (g m)) (f (g n))\nf : \u2115 \u2192 \u03b1\n\u22a2 \u2203 m n, m < n \u2227 r (f m) (f n)"}, {"line": "\u00b7 exact h.exists_monotone_subseq f", "tactic_state": "case mpr\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsPreorder \u03b1 r\nh : \u2200 (f : \u2115 \u2192 \u03b1), \u2203 g, \u2200 (m n : \u2115), m \u2264 n \u2192 r (f (g m)) (f (g n))\nf : \u2115 \u2192 \u03b1\n\u22a2 \u2203 m n, m < n \u2227 r (f m) (f n)"}, {"line": "\u00b7 obtain \u27e8g, gmon\u27e9 := h f\n    exact \u27e8_, _, g.strictMono Nat.zero_lt_one, gmon _ _ (Nat.zero_le 1)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem WellQuasiOrdered.wellFounded {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsPreorder \u03b1 r]\n    (h : WellQuasiOrdered r) : WellFounded fun a b \u21a6 r a b \u2227 \u00ac r b a := by\n  let _ : Preorder \u03b1 :=\n    { le := r\n      le_refl := refl_of r\n      le_trans := fun _ _ _ => trans_of r }\n  have : WellQuasiOrderedLE \u03b1 := \u27e8h\u27e9\n  exact wellFounded_lt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WellQuasiOrder.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsPreorder \u03b1 r\nh : WellQuasiOrdered r\n\u22a2 WellFounded fun a b => r a b \u2227 \u00acr b a"}, {"line": "let _ : Preorder \u03b1 :=\n    { le := r\n      le_refl := refl_of r\n      le_trans := fun _ _ _ => trans_of r }", "tactic_state": "\u03b1 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsPreorder \u03b1 r\nh : WellQuasiOrdered r\nx\u271d : Preorder \u03b1 := { le := r, le_refl := \u22ef, le_trans := \u22ef, lt_iff_le_not_le := \u22ef }\n\u22a2 WellFounded fun a b => r a b \u2227 \u00acr b a"}, {"line": "have : WellQuasiOrderedLE \u03b1 := \u27e8h\u27e9", "tactic_state": "\u03b1 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsPreorder \u03b1 r\nh : WellQuasiOrdered r\nx\u271d : Preorder \u03b1 := { le := r, le_refl := \u22ef, le_trans := \u22ef, lt_iff_le_not_le := \u22ef }\nthis : WellQuasiOrderedLE \u03b1\n\u22a2 WellFounded fun a b => r a b \u2227 \u00acr b a"}, {"line": "exact wellFounded_lt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem wellQuasiOrderedLE_iff_wellFoundedLT : WellQuasiOrderedLE \u03b1 \u2194 WellFoundedLT \u03b1 := by\n  rw [wellQuasiOrderedLE_iff]\n  rw [and_iff_left_iff_imp]\n  exact fun _ s hs \u21a6 hs.subsingleton.finite\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/WellQuasiOrder.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "[Preorder \u03b1]", "[LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LinearOrder \u03b1\n\u22a2 WellQuasiOrderedLE \u03b1 \u2194 WellFoundedLT \u03b1"}, {"line": "rw [wellQuasiOrderedLE_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LinearOrder \u03b1\n\u22a2 (WellFoundedLT \u03b1 \u2227 \u2200 (s : Set \u03b1), IsAntichain (fun x1 x2 => x1 \u2264 x2) s \u2192 s.Finite) \u2194 WellFoundedLT \u03b1"}, {"line": "rw [and_iff_left_iff_imp]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LinearOrder \u03b1\n\u22a2 WellFoundedLT \u03b1 \u2192 \u2200 (s : Set \u03b1), IsAntichain (fun x1 x2 => x1 \u2264 x2) s \u2192 s.Finite"}, {"line": "exact fun _ s hs \u21a6 hs.subsingleton.finite", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsChain.exists_maxChain (hc : IsChain r c) : \u2203 M, @IsMaxChain _ r M \u2227 c \u2286 M := by\n  have H := zorn_subset_nonempty { s | c \u2286 s \u2227 IsChain r s } ?_ c \u27e8Subset.rfl, hc\u27e9\n  \u00b7 obtain \u27e8M, hcM, hM\u27e9 := H\n    exact \u27e8M, \u27e8hM.prop.2, fun d hd hMd \u21a6 hM.eq_of_subset \u27e8hcM.trans hMd, hd\u27e9 hMd\u27e9, hcM\u27e9\n  rintro cs hcs\u2080 hcs\u2081 \u27e8s, hs\u27e9\n  refine\n    \u27e8\u22c3\u2080cs, \u27e8fun _ ha => Set.mem_sUnion_of_mem ((hcs\u2080 hs).left ha) hs, ?_\u27e9, fun _ =>\n      Set.subset_sUnion_of_mem\u27e9\n  rintro y \u27e8sy, hsy, hysy\u27e9 z \u27e8sz, hsz, hzsz\u27e9 hyz\n  obtain rfl | hsseq := eq_or_ne sy sz\n  \u00b7 exact (hcs\u2080 hsy).right hysy hzsz hyz\n  rcases hcs\u2081 hsy hsz hsseq with h | h\n  \u00b7 exact (hcs\u2080 hsz).right (h hysy) hzsz hyz\n  \u00b7 exact (hcs\u2080 hsy).right hysy (h hzsz) hyz\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Zorn.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {c : Set \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Set \u03b1\ninst\u271d : Preorder \u03b1\nhc : IsChain r c\n\u22a2 \u2203 M, IsMaxChain r M \u2227 c \u2286 M"}, {"line": "have H := zorn_subset_nonempty { s | c \u2286 s \u2227 IsChain r s } ?_ c \u27e8Subset.rfl, hc\u27e9", "tactic_state": "case refine_2\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Set \u03b1\ninst\u271d : Preorder \u03b1\nhc : IsChain r c\nH : \u2203 m, c \u2286 m \u2227 Maximal (fun x => x \u2208 {s | c \u2286 s \u2227 IsChain r s}) m\n\u22a2 \u2203 M, IsMaxChain r M \u2227 c \u2286 M\n---\ncase refine_1\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Set \u03b1\ninst\u271d : Preorder \u03b1\nhc : IsChain r c\n\u22a2 \u2200 c_1 \u2286 {s | c \u2286 s \u2227 IsChain r s},\n    IsChain (fun x1 x2 => x1 \u2286 x2) c_1 \u2192 c_1.Nonempty \u2192 \u2203 ub \u2208 {s | c \u2286 s \u2227 IsChain r s}, \u2200 s \u2208 c_1, s \u2286 ub"}, {"line": "\u00b7 obtain \u27e8M, hcM, hM\u27e9 := H\n    exact \u27e8M, \u27e8hM.prop.2, fun d hd hMd \u21a6 hM.eq_of_subset \u27e8hcM.trans hMd, hd\u27e9 hMd\u27e9, hcM\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Set \u03b1\ninst\u271d : Preorder \u03b1\nhc : IsChain r c\n\u22a2 \u2200 c_1 \u2286 {s | c \u2286 s \u2227 IsChain r s},\n    IsChain (fun x1 x2 => x1 \u2286 x2) c_1 \u2192 c_1.Nonempty \u2192 \u2203 ub \u2208 {s | c \u2286 s \u2227 IsChain r s}, \u2200 s \u2208 c_1, s \u2286 ub"}, {"line": "rintro cs hcs\u2080 hcs\u2081 \u27e8s, hs\u27e9", "tactic_state": "case refine_1.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Set \u03b1\ninst\u271d : Preorder \u03b1\nhc : IsChain r c\ncs : Set (Set \u03b1)\nhcs\u2080 : cs \u2286 {s | c \u2286 s \u2227 IsChain r s}\nhcs\u2081 : IsChain (fun x1 x2 => x1 \u2286 x2) cs\ns : Set \u03b1\nhs : s \u2208 cs\n\u22a2 \u2203 ub \u2208 {s | c \u2286 s \u2227 IsChain r s}, \u2200 s \u2208 cs, s \u2286 ub"}, {"line": "refine\n    \u27e8\u22c3\u2080cs, \u27e8fun _ ha => Set.mem_sUnion_of_mem ((hcs\u2080 hs).left ha) hs, ?_\u27e9, fun _ =>\n      Set.subset_sUnion_of_mem\u27e9", "tactic_state": "case refine_1.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Set \u03b1\ninst\u271d : Preorder \u03b1\nhc : IsChain r c\ncs : Set (Set \u03b1)\nhcs\u2080 : cs \u2286 {s | c \u2286 s \u2227 IsChain r s}\nhcs\u2081 : IsChain (fun x1 x2 => x1 \u2286 x2) cs\ns : Set \u03b1\nhs : s \u2208 cs\n\u22a2 IsChain r (\u22c3\u2080 cs)"}, {"line": "rintro y \u27e8sy, hsy, hysy\u27e9 z \u27e8sz, hsz, hzsz\u27e9 hyz", "tactic_state": "case refine_1.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Set \u03b1\ninst\u271d : Preorder \u03b1\nhc : IsChain r c\ncs : Set (Set \u03b1)\nhcs\u2080 : cs \u2286 {s | c \u2286 s \u2227 IsChain r s}\nhcs\u2081 : IsChain (fun x1 x2 => x1 \u2286 x2) cs\ns : Set \u03b1\nhs : s \u2208 cs\ny : \u03b1\nsy : Set \u03b1\nhsy : sy \u2208 cs\nhysy : y \u2208 sy\nz : \u03b1\nsz : Set \u03b1\nhsz : sz \u2208 cs\nhzsz : z \u2208 sz\nhyz : y \u2260 z\n\u22a2 r y z \u2228 r z y"}, {"line": "obtain rfl | hsseq := eq_or_ne sy sz", "tactic_state": "case refine_1.intro.intro.intro.intro.intro.inl\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Set \u03b1\ninst\u271d : Preorder \u03b1\nhc : IsChain r c\ncs : Set (Set \u03b1)\nhcs\u2080 : cs \u2286 {s | c \u2286 s \u2227 IsChain r s}\nhcs\u2081 : IsChain (fun x1 x2 => x1 \u2286 x2) cs\ns : Set \u03b1\nhs : s \u2208 cs\ny : \u03b1\nsy : Set \u03b1\nhsy : sy \u2208 cs\nhysy : y \u2208 sy\nz : \u03b1\nhyz : y \u2260 z\nhsz : sy \u2208 cs\nhzsz : z \u2208 sy\n\u22a2 r y z \u2228 r z y\n---\ncase refine_1.intro.intro.intro.intro.intro.inr\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Set \u03b1\ninst\u271d : Preorder \u03b1\nhc : IsChain r c\ncs : Set (Set \u03b1)\nhcs\u2080 : cs \u2286 {s | c \u2286 s \u2227 IsChain r s}\nhcs\u2081 : IsChain (fun x1 x2 => x1 \u2286 x2) cs\ns : Set \u03b1\nhs : s \u2208 cs\ny : \u03b1\nsy : Set \u03b1\nhsy : sy \u2208 cs\nhysy : y \u2208 sy\nz : \u03b1\nsz : Set \u03b1\nhsz : sz \u2208 cs\nhzsz : z \u2208 sz\nhyz : y \u2260 z\nhsseq : sy \u2260 sz\n\u22a2 r y z \u2228 r z y"}, {"line": "\u00b7 exact (hcs\u2080 hsy).right hysy hzsz hyz", "tactic_state": "case refine_1.intro.intro.intro.intro.intro.inr\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Set \u03b1\ninst\u271d : Preorder \u03b1\nhc : IsChain r c\ncs : Set (Set \u03b1)\nhcs\u2080 : cs \u2286 {s | c \u2286 s \u2227 IsChain r s}\nhcs\u2081 : IsChain (fun x1 x2 => x1 \u2286 x2) cs\ns : Set \u03b1\nhs : s \u2208 cs\ny : \u03b1\nsy : Set \u03b1\nhsy : sy \u2208 cs\nhysy : y \u2208 sy\nz : \u03b1\nsz : Set \u03b1\nhsz : sz \u2208 cs\nhzsz : z \u2208 sz\nhyz : y \u2260 z\nhsseq : sy \u2260 sz\n\u22a2 r y z \u2228 r z y"}, {"line": "rcases hcs\u2081 hsy hsz hsseq with h | h", "tactic_state": "case refine_1.intro.intro.intro.intro.intro.inr.inl\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Set \u03b1\ninst\u271d : Preorder \u03b1\nhc : IsChain r c\ncs : Set (Set \u03b1)\nhcs\u2080 : cs \u2286 {s | c \u2286 s \u2227 IsChain r s}\nhcs\u2081 : IsChain (fun x1 x2 => x1 \u2286 x2) cs\ns : Set \u03b1\nhs : s \u2208 cs\ny : \u03b1\nsy : Set \u03b1\nhsy : sy \u2208 cs\nhysy : y \u2208 sy\nz : \u03b1\nsz : Set \u03b1\nhsz : sz \u2208 cs\nhzsz : z \u2208 sz\nhyz : y \u2260 z\nhsseq : sy \u2260 sz\nh : sy \u2286 sz\n\u22a2 r y z \u2228 r z y\n---\ncase refine_1.intro.intro.intro.intro.intro.inr.inr\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Set \u03b1\ninst\u271d : Preorder \u03b1\nhc : IsChain r c\ncs : Set (Set \u03b1)\nhcs\u2080 : cs \u2286 {s | c \u2286 s \u2227 IsChain r s}\nhcs\u2081 : IsChain (fun x1 x2 => x1 \u2286 x2) cs\ns : Set \u03b1\nhs : s \u2208 cs\ny : \u03b1\nsy : Set \u03b1\nhsy : sy \u2208 cs\nhysy : y \u2208 sy\nz : \u03b1\nsz : Set \u03b1\nhsz : sz \u2208 cs\nhzsz : z \u2208 sz\nhyz : y \u2260 z\nhsseq : sy \u2260 sz\nh : sz \u2286 sy\n\u22a2 r y z \u2228 r z y"}, {"line": "\u00b7 exact (hcs\u2080 hsz).right (h hysy) hzsz hyz", "tactic_state": "case refine_1.intro.intro.intro.intro.intro.inr.inr\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Set \u03b1\ninst\u271d : Preorder \u03b1\nhc : IsChain r c\ncs : Set (Set \u03b1)\nhcs\u2080 : cs \u2286 {s | c \u2286 s \u2227 IsChain r s}\nhcs\u2081 : IsChain (fun x1 x2 => x1 \u2286 x2) cs\ns : Set \u03b1\nhs : s \u2208 cs\ny : \u03b1\nsy : Set \u03b1\nhsy : sy \u2208 cs\nhysy : y \u2208 sy\nz : \u03b1\nsz : Set \u03b1\nhsz : sz \u2208 cs\nhzsz : z \u2208 sz\nhyz : y \u2260 z\nhsseq : sy \u2260 sz\nh : sz \u2286 sy\n\u22a2 r y z \u2228 r z y"}, {"line": "\u00b7 exact (hcs\u2080 hsy).right hysy (h hzsz) hyz", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_mem_mem (hab : a \u2264 b) : \u2203 s : Flag \u03b1, a \u2208 s \u2227 b \u2208 s := by\n  simpa [Set.insert_subset_iff] using (IsChain.pair hab).exists_subset_flag\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Zorn.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {c : Set \u03b1}", "[Preorder \u03b1]", "[Preorder \u03b1] {c : Set \u03b1} {s : Flag \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\na b : \u03b1\nhab : a \u2264 b\n\u22a2 \u2203 s, a \u2208 s \u2227 b \u2208 s"}, {"line": "simpa [Set.insert_subset_iff] using (IsChain.pair hab).exists_subset_flag", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image (hs : IsAntichain r s) (f : \u03b1 \u2192 \u03b2) (h : \u2200 \u2983a b\u2984, r' (f a) (f b) \u2192 r a b) :\n    IsAntichain r' (f '' s) := by\n  rintro _ \u27e8b, hb, rfl\u27e9 _ \u27e8c, hc, rfl\u27e9 hbc hr\n  exact hs hb hc (ne_of_apply_ne _ hbc) (h hr)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Antichain.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 : Type*} {r r\u2081 r\u2082 : \u03b1 \u2192 \u03b1 \u2192 Prop} {r' : \u03b2 \u2192 \u03b2 \u2192 Prop} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nr' : \u03b2 \u2192 \u03b2 \u2192 Prop\ns : Set \u03b1\nhs : IsAntichain r s\nf : \u03b1 \u2192 \u03b2\nh : \u2200 \u2983a b : \u03b1\u2984, r' (f a) (f b) \u2192 r a b\n\u22a2 IsAntichain r' (f '' s)"}, {"line": "rintro _ \u27e8b, hb, rfl\u27e9 _ \u27e8c, hc, rfl\u27e9 hbc hr", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nr' : \u03b2 \u2192 \u03b2 \u2192 Prop\ns : Set \u03b1\nhs : IsAntichain r s\nf : \u03b1 \u2192 \u03b2\nh : \u2200 \u2983a b : \u03b1\u2984, r' (f a) (f b) \u2192 r a b\nb : \u03b1\nhb : b \u2208 s\nc : \u03b1\nhc : c \u2208 s\nhbc : f b \u2260 f c\nhr : r' (f b) (f c)\n\u22a2 False"}, {"line": "exact hs hb hc (ne_of_apply_ne _ hbc) (h hr)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_relEmbedding (hs : IsAntichain r s) (\u03c6 : r \u21aar r') : IsAntichain r' (\u03c6 '' s) := by\n  intro b hb b' hb' h\u2081 h\u2082\n  rw [Set.mem_image] at hb hb'\n  obtain \u27e8\u27e8a, has, rfl\u27e9, \u27e8a', has', rfl\u27e9\u27e9 := hb, hb'\n  exact hs has has' (fun haa' => h\u2081 (by rw [haa'])) (\u03c6.map_rel_iff.mp h\u2082)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Antichain.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 : Type*} {r r\u2081 r\u2082 : \u03b1 \u2192 \u03b1 \u2192 Prop} {r' : \u03b2 \u2192 \u03b2 \u2192 Prop} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nr' : \u03b2 \u2192 \u03b2 \u2192 Prop\ns : Set \u03b1\nhs : IsAntichain r s\n\u03c6 : r \u21aar r'\n\u22a2 IsAntichain r' (\u21d1\u03c6 '' s)"}, {"line": "intro b hb b' hb' h\u2081 h\u2082", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nr' : \u03b2 \u2192 \u03b2 \u2192 Prop\ns : Set \u03b1\nhs : IsAntichain r s\n\u03c6 : r \u21aar r'\nb : \u03b2\nhb : b \u2208 \u21d1\u03c6 '' s\nb' : \u03b2\nhb' : b' \u2208 \u21d1\u03c6 '' s\nh\u2081 : b \u2260 b'\nh\u2082 : r' b b'\n\u22a2 False"}, {"line": "rw [Set.mem_image] at hb hb'", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nr' : \u03b2 \u2192 \u03b2 \u2192 Prop\ns : Set \u03b1\nhs : IsAntichain r s\n\u03c6 : r \u21aar r'\nb : \u03b2\nhb : \u2203 x \u2208 s, \u03c6 x = b\nb' : \u03b2\nhb' : \u2203 x \u2208 s, \u03c6 x = b'\nh\u2081 : b \u2260 b'\nh\u2082 : r' b b'\n\u22a2 False"}, {"line": "obtain \u27e8\u27e8a, has, rfl\u27e9, \u27e8a', has', rfl\u27e9\u27e9 := hb, hb'", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nr' : \u03b2 \u2192 \u03b2 \u2192 Prop\ns : Set \u03b1\nhs : IsAntichain r s\n\u03c6 : r \u21aar r'\na : \u03b1\nhas : a \u2208 s\na' : \u03b1\nhas' : a' \u2208 s\nh\u2081 : \u03c6 a \u2260 \u03c6 a'\nh\u2082 : r' (\u03c6 a) (\u03c6 a')\n\u22a2 False"}, {"line": "exact hs has has' (fun haa' => h\u2081 (by rw [haa'])) (\u03c6.map_rel_iff.mp h\u2082)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image (hs : IsStrongAntichain r s) {f : \u03b1 \u2192 \u03b2} (hf : Surjective f)\n    (h : \u2200 a b, r' (f a) (f b) \u2192 r a b) : IsStrongAntichain r' (f '' s) := by\n  rintro _ \u27e8a, ha, rfl\u27e9 _ \u27e8b, hb, rfl\u27e9 hab c\n  obtain \u27e8c, rfl\u27e9 := hf c\n  exact (hs ha hb (ne_of_apply_ne _ hab) _).imp (mt <| h _ _) (mt <| h _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Antichain.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 : Type*} {r r\u2081 r\u2082 : \u03b1 \u2192 \u03b1 \u2192 Prop} {r' : \u03b2 \u2192 \u03b2 \u2192 Prop} {s t : Set \u03b1} {a b : \u03b1}", "[Preorder \u03b1]", "[PartialOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nr' : \u03b2 \u2192 \u03b2 \u2192 Prop\ns : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PartialOrder \u03b1\nhs : IsStrongAntichain r s\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\nh : \u2200 (a b : \u03b1), r' (f a) (f b) \u2192 r a b\n\u22a2 IsStrongAntichain r' (f '' s)"}, {"line": "rintro _ \u27e8a, ha, rfl\u27e9 _ \u27e8b, hb, rfl\u27e9 hab c", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nr' : \u03b2 \u2192 \u03b2 \u2192 Prop\ns : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PartialOrder \u03b1\nhs : IsStrongAntichain r s\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\nh : \u2200 (a b : \u03b1), r' (f a) (f b) \u2192 r a b\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : f a \u2260 f b\nc : \u03b2\n\u22a2 \u00acr' (f a) c \u2228 \u00acr' (f b) c"}, {"line": "obtain \u27e8c, rfl\u27e9 := hf c", "tactic_state": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nr' : \u03b2 \u2192 \u03b2 \u2192 Prop\ns : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PartialOrder \u03b1\nhs : IsStrongAntichain r s\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\nh : \u2200 (a b : \u03b1), r' (f a) (f b) \u2192 r a b\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : f a \u2260 f b\nc : \u03b1\n\u22a2 \u00acr' (f a) (f c) \u2228 \u00acr' (f b) (f c)"}, {"line": "exact (hs ha hb (ne_of_apply_ne _ hab) _).imp (mt <| h _ _) (mt <| h _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isAtom_iff [OrderBot A] {K : A} :\n    IsAtom K \u2194 K \u2260 \u22a5 \u2227 \u2200 H g, H \u2264 K \u2192 g \u2209 H \u2192 g \u2208 K \u2192 H = \u22a5 := by\n  simp_rw [IsAtom, lt_iff_le_not_le, SetLike.not_le_iff_exists,\n    and_comm (a := _ \u2264 _), and_imp, exists_imp, \u2190 and_imp, and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Atoms.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[Preorder \u03b1]", "[OrderTop \u03b1] {a x : \u03b1}", "[PartialOrder \u03b1] [OrderTop \u03b1] {a b x : \u03b1}", "{A B : Type*} [SetLike A B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_4\nB : Type u_5\ninst\u271d\u00b9 : SetLike A B\ninst\u271d : OrderBot A\nK : A\n\u22a2 IsAtom K \u2194 K \u2260 \u22a5 \u2227 \u2200 (H : A) (g : B), H \u2264 K \u2192 g \u2209 H \u2192 g \u2208 K \u2192 H = \u22a5"}, {"line": "simp_rw [IsAtom, lt_iff_le_not_le, SetLike.not_le_iff_exists,\n    and_comm (a := _ \u2264 _), and_imp, exists_imp, \u2190 and_imp, and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isCoatom_iff [OrderTop A] {K : A} :\n    IsCoatom K \u2194 K \u2260 \u22a4 \u2227 \u2200 H g, K \u2264 H \u2192 g \u2209 K \u2192 g \u2208 H \u2192 H = \u22a4 := by\n  simp_rw [IsCoatom, lt_iff_le_not_le, SetLike.not_le_iff_exists,\n    and_comm (a := _ \u2264 _), and_imp, exists_imp, \u2190 and_imp, and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Atoms.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[Preorder \u03b1]", "[OrderTop \u03b1] {a x : \u03b1}", "[PartialOrder \u03b1] [OrderTop \u03b1] {a b x : \u03b1}", "{A B : Type*} [SetLike A B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_4\nB : Type u_5\ninst\u271d\u00b9 : SetLike A B\ninst\u271d : OrderTop A\nK : A\n\u22a2 IsCoatom K \u2194 K \u2260 \u22a4 \u2227 \u2200 (H : A) (g : B), K \u2264 H \u2192 g \u2209 K \u2192 g \u2208 H \u2192 H = \u22a4"}, {"line": "simp_rw [IsCoatom, lt_iff_le_not_le, SetLike.not_le_iff_exists,\n    and_comm (a := _ \u2264 _), and_imp, exists_imp, \u2190 and_imp, and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem covBy_iff {K L : A} :\n    K \u22d6 L \u2194 K < L \u2227 \u2200 H g, K \u2264 H \u2192 H \u2264 L \u2192 g \u2209 K \u2192 g \u2208 H \u2192 H = L := by\n  refine and_congr_right fun _ \u21a6 forall_congr' fun H \u21a6 not_iff_not.mp ?_\n  push_neg\n  rw [lt_iff_le_not_le]\n  rw [lt_iff_le_and_ne]\n  rw [and_and_and_comm]\n  simp_rw [exists_and_left, and_assoc, and_congr_right_iff, \u2190 and_assoc, and_comm, exists_and_left,\n    SetLike.not_le_iff_exists, and_comm, implies_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Atoms.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[Preorder \u03b1]", "[OrderTop \u03b1] {a x : \u03b1}", "[PartialOrder \u03b1] [OrderTop \u03b1] {a b x : \u03b1}", "{A B : Type*} [SetLike A B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_4\nB : Type u_5\ninst\u271d : SetLike A B\nK L : A\n\u22a2 K \u22d6 L \u2194 K < L \u2227 \u2200 (H : A) (g : B), K \u2264 H \u2192 H \u2264 L \u2192 g \u2209 K \u2192 g \u2208 H \u2192 H = L"}, {"line": "refine and_congr_right fun _ \u21a6 forall_congr' fun H \u21a6 not_iff_not.mp ?_", "tactic_state": "A : Type u_4\nB : Type u_5\ninst\u271d : SetLike A B\nK L : A\nx\u271d : K < L\nH : A\n\u22a2 \u00ac(K < H \u2192 \u00acH < L) \u2194 \u00ac\u2200 (g : B), K \u2264 H \u2192 H \u2264 L \u2192 g \u2209 K \u2192 g \u2208 H \u2192 H = L"}, {"line": "push_neg", "tactic_state": "A : Type u_4\nB : Type u_5\ninst\u271d : SetLike A B\nK L : A\nx\u271d : K < L\nH : A\n\u22a2 K < H \u2227 H < L \u2194 \u2203 g, K \u2264 H \u2227 H \u2264 L \u2227 g \u2209 K \u2227 g \u2208 H \u2227 H \u2260 L"}, {"line": "rw [lt_iff_le_not_le]", "tactic_state": "A : Type u_4\nB : Type u_5\ninst\u271d : SetLike A B\nK L : A\nx\u271d : K < L\nH : A\n\u22a2 (K \u2264 H \u2227 \u00acH \u2264 K) \u2227 H < L \u2194 \u2203 g, K \u2264 H \u2227 H \u2264 L \u2227 g \u2209 K \u2227 g \u2208 H \u2227 H \u2260 L"}, {"line": "rw [lt_iff_le_and_ne]", "tactic_state": "A : Type u_4\nB : Type u_5\ninst\u271d : SetLike A B\nK L : A\nx\u271d : K < L\nH : A\n\u22a2 (K \u2264 H \u2227 \u00acH \u2264 K) \u2227 H \u2264 L \u2227 H \u2260 L \u2194 \u2203 g, K \u2264 H \u2227 H \u2264 L \u2227 g \u2209 K \u2227 g \u2208 H \u2227 H \u2260 L"}, {"line": "rw [and_and_and_comm]", "tactic_state": "A : Type u_4\nB : Type u_5\ninst\u271d : SetLike A B\nK L : A\nx\u271d : K < L\nH : A\n\u22a2 (K \u2264 H \u2227 H \u2264 L) \u2227 \u00acH \u2264 K \u2227 H \u2260 L \u2194 \u2203 g, K \u2264 H \u2227 H \u2264 L \u2227 g \u2209 K \u2227 g \u2208 H \u2227 H \u2260 L"}, {"line": "simp_rw [exists_and_left, and_assoc, and_congr_right_iff, \u2190 and_assoc, and_comm, exists_and_left,\n    SetLike.not_le_iff_exists, and_comm, implies_true]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem covBy_iff' {K L : A} :\n    K \u22d6 L \u2194 K < L \u2227 \u2200 H g, K \u2264 H \u2192 H \u2264 L \u2192 g \u2209 H \u2192 g \u2208 L \u2192 H = K := by\n  refine and_congr_right fun _ \u21a6 forall_congr' fun H \u21a6 not_iff_not.mp ?_\n  push_neg\n  rw [lt_iff_le_and_ne]\n  rw [lt_iff_le_not_le]\n  rw [and_and_and_comm]\n  simp_rw [exists_and_left, and_assoc, and_congr_right_iff, \u2190 and_assoc, and_comm, exists_and_left,\n    SetLike.not_le_iff_exists, ne_comm, implies_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Atoms.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[Preorder \u03b1]", "[OrderTop \u03b1] {a x : \u03b1}", "[PartialOrder \u03b1] [OrderTop \u03b1] {a b x : \u03b1}", "{A B : Type*} [SetLike A B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_4\nB : Type u_5\ninst\u271d : SetLike A B\nK L : A\n\u22a2 K \u22d6 L \u2194 K < L \u2227 \u2200 (H : A) (g : B), K \u2264 H \u2192 H \u2264 L \u2192 g \u2209 H \u2192 g \u2208 L \u2192 H = K"}, {"line": "refine and_congr_right fun _ \u21a6 forall_congr' fun H \u21a6 not_iff_not.mp ?_", "tactic_state": "A : Type u_4\nB : Type u_5\ninst\u271d : SetLike A B\nK L : A\nx\u271d : K < L\nH : A\n\u22a2 \u00ac(K < H \u2192 \u00acH < L) \u2194 \u00ac\u2200 (g : B), K \u2264 H \u2192 H \u2264 L \u2192 g \u2209 H \u2192 g \u2208 L \u2192 H = K"}, {"line": "push_neg", "tactic_state": "A : Type u_4\nB : Type u_5\ninst\u271d : SetLike A B\nK L : A\nx\u271d : K < L\nH : A\n\u22a2 K < H \u2227 H < L \u2194 \u2203 g, K \u2264 H \u2227 H \u2264 L \u2227 g \u2209 H \u2227 g \u2208 L \u2227 H \u2260 K"}, {"line": "rw [lt_iff_le_and_ne]", "tactic_state": "A : Type u_4\nB : Type u_5\ninst\u271d : SetLike A B\nK L : A\nx\u271d : K < L\nH : A\n\u22a2 (K \u2264 H \u2227 K \u2260 H) \u2227 H < L \u2194 \u2203 g, K \u2264 H \u2227 H \u2264 L \u2227 g \u2209 H \u2227 g \u2208 L \u2227 H \u2260 K"}, {"line": "rw [lt_iff_le_not_le]", "tactic_state": "A : Type u_4\nB : Type u_5\ninst\u271d : SetLike A B\nK L : A\nx\u271d : K < L\nH : A\n\u22a2 (K \u2264 H \u2227 K \u2260 H) \u2227 H \u2264 L \u2227 \u00acL \u2264 H \u2194 \u2203 g, K \u2264 H \u2227 H \u2264 L \u2227 g \u2209 H \u2227 g \u2208 L \u2227 H \u2260 K"}, {"line": "rw [and_and_and_comm]", "tactic_state": "A : Type u_4\nB : Type u_5\ninst\u271d : SetLike A B\nK L : A\nx\u271d : K < L\nH : A\n\u22a2 (K \u2264 H \u2227 H \u2264 L) \u2227 K \u2260 H \u2227 \u00acL \u2264 H \u2194 \u2203 g, K \u2264 H \u2227 H \u2264 L \u2227 g \u2209 H \u2227 g \u2208 L \u2227 H \u2260 K"}, {"line": "simp_rw [exists_and_left, and_assoc, and_congr_right_iff, \u2190 and_assoc, and_comm, exists_and_left,\n    SetLike.not_le_iff_exists, ne_comm, implies_true]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isStronglyAtomic_dual_iff_is_stronglyCoatomic :\n    IsStronglyAtomic \u03b1\u1d52\u1d48 \u2194 IsStronglyCoatomic \u03b1 := by\n  simpa [isStronglyAtomic_iff, OrderDual.exists, OrderDual.forall,\n    OrderDual.toDual_le_toDual, and_comm, isStronglyCoatomic_iff] using forall_comm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Atoms.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[Preorder \u03b1]", "[OrderTop \u03b1] {a x : \u03b1}", "[PartialOrder \u03b1] [OrderTop \u03b1] {a b x : \u03b1}", "{A B : Type*} [SetLike A B]", "[PartialOrder \u03b1] {a b : \u03b1}", "[PartialOrder \u03b1] (\u03b1)", "{\u03b1}", "[OrderBot \u03b1] [IsAtomic \u03b1]", "[OrderTop \u03b1] [IsCoatomic \u03b1]", "{\u03b1 : Type*} {a b : \u03b1} [Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\ninst\u271d : Preorder \u03b1\n\u22a2 IsStronglyAtomic \u03b1\u1d52\u1d48 \u2194 IsStronglyCoatomic \u03b1"}, {"line": "simpa [isStronglyAtomic_iff, OrderDual.exists, OrderDual.forall,\n    OrderDual.toDual_le_toDual, and_comm, isStronglyCoatomic_iff] using forall_comm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsStronglyAtomic.of_wellFounded_lt (h : WellFounded ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)) :\n    IsStronglyAtomic \u03b1 where\n  exists_covBy_le_of_lt a b hab := by\n    refine \u27e8WellFounded.min h (Set.Ioc a b) \u27e8b, hab,rfl.le\u27e9, ?_\u27e9\n    have hmem := (WellFounded.min_mem h (Set.Ioc a b) \u27e8b, hab,rfl.le\u27e9)\n    exact \u27e8\u27e8hmem.1,fun c hac hlt \u21a6 WellFounded.not_lt_min h\n      (Set.Ioc a b) \u27e8b, hab,rfl.le\u27e9 \u27e8hac, hlt.le.trans hmem.2\u27e9 hlt \u27e9, hmem.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Atoms.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[Preorder \u03b1]", "[OrderTop \u03b1] {a x : \u03b1}", "[PartialOrder \u03b1] [OrderTop \u03b1] {a b x : \u03b1}", "{A B : Type*} [SetLike A B]", "[PartialOrder \u03b1] {a b : \u03b1}", "[PartialOrder \u03b1] (\u03b1)", "{\u03b1}", "[OrderBot \u03b1] [IsAtomic \u03b1]", "[OrderTop \u03b1] [IsCoatomic \u03b1]", "{\u03b1 : Type*} {a b : \u03b1} [Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\ninst\u271d : Preorder \u03b1\nh : WellFounded fun x1 x2 => x1 < x2\na b : \u03b1\nhab : a < b\n\u22a2 \u2203 x, a \u22d6 x \u2227 x \u2264 b"}, {"line": "refine \u27e8WellFounded.min h (Set.Ioc a b) \u27e8b, hab,rfl.le\u27e9, ?_\u27e9", "tactic_state": "\u03b1 : Type u_6\ninst\u271d : Preorder \u03b1\nh : WellFounded fun x1 x2 => x1 < x2\na b : \u03b1\nhab : a < b\n\u22a2 a \u22d6 h.min sorry \u22ef \u2227 h.min sorry \u22ef \u2264 b"}, {"line": "have hmem := (WellFounded.min_mem h (Set.Ioc a b) \u27e8b, hab,rfl.le\u27e9)", "tactic_state": "\u03b1 : Type u_6\ninst\u271d : Preorder \u03b1\nh : WellFounded fun x1 x2 => x1 < x2\na b : \u03b1\nhab : a < b\nhmem : h.min sorry \u22ef \u2208 sorry\n\u22a2 a \u22d6 h.min sorry \u22ef \u2227 h.min sorry \u22ef \u2264 b"}, {"line": "exact \u27e8\u27e8hmem.1,fun c hac hlt \u21a6 WellFounded.not_lt_min h\n      (Set.Ioc a b) \u27e8b, hab,rfl.le\u27e9 \u27e8hac, hlt.le.trans hmem.2\u27e9 hlt \u27e9, hmem.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_iff_atom_le_iff {\u03b1} [BooleanAlgebra \u03b1] [IsAtomic \u03b1] {x y : \u03b1} :\n    x = y \u2194 \u2200 a, IsAtom a \u2192 (a \u2264 x \u2194 a \u2264 y) := by\n  refine \u27e8fun h => h \u25b8 by simp, fun h => ?_\u27e9\n  exact le_antisymm (le_iff_atom_le_imp.2 fun a ha hx => (h a ha).1 hx)\n    (le_iff_atom_le_imp.2 fun a ha hy => (h a ha).2 hy)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Atoms.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[Preorder \u03b1]", "[OrderTop \u03b1] {a x : \u03b1}", "[PartialOrder \u03b1] [OrderTop \u03b1] {a b x : \u03b1}", "{A B : Type*} [SetLike A B]", "[PartialOrder \u03b1] {a b : \u03b1}", "[PartialOrder \u03b1] (\u03b1)", "{\u03b1}", "[OrderBot \u03b1] [IsAtomic \u03b1]", "[OrderTop \u03b1] [IsCoatomic \u03b1]", "{\u03b1 : Type*} {a b : \u03b1} [Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\ninst\u271d\u00b9 : BooleanAlgebra \u03b1\ninst\u271d : IsAtomic \u03b1\nx y : \u03b1\n\u22a2 x = y \u2194 \u2200 (a : \u03b1), IsAtom a \u2192 (a \u2264 x \u2194 a \u2264 y)"}, {"line": "refine \u27e8fun h => h \u25b8 by simp, fun h => ?_\u27e9", "tactic_state": "\u03b1 : Type u_7\ninst\u271d\u00b9 : BooleanAlgebra \u03b1\ninst\u271d : IsAtomic \u03b1\nx y : \u03b1\nh : \u2200 (a : \u03b1), IsAtom a \u2192 (a \u2264 x \u2194 a \u2264 y)\n\u22a2 x = y"}, {"line": "exact le_antisymm (le_iff_atom_le_imp.2 fun a ha hx => (h a ha).1 hx)\n    (le_iff_atom_le_imp.2 fun a ha hy => (h a ha).2 hy)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLUB_atoms_top [OrderTop \u03b1] : IsLUB { a : \u03b1 | IsAtom a } \u22a4 := by\n  simpa using isLUB_atoms_le (\u22a4 : \u03b1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Atoms.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[Preorder \u03b1]", "[OrderTop \u03b1] {a x : \u03b1}", "[PartialOrder \u03b1] [OrderTop \u03b1] {a b x : \u03b1}", "{A B : Type*} [SetLike A B]", "[PartialOrder \u03b1] {a b : \u03b1}", "[PartialOrder \u03b1] (\u03b1)", "{\u03b1}", "[OrderBot \u03b1] [IsAtomic \u03b1]", "[OrderTop \u03b1] [IsCoatomic \u03b1]", "{\u03b1 : Type*} {a b : \u03b1} [Preorder \u03b1]", "(\u03b1) [PartialOrder \u03b1]", "{\u03b1}", "[OrderBot \u03b1] [IsAtomistic \u03b1]", "[OrderBot \u03b1] [IsAtomistic \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderTop \u03b1\n\u22a2 IsLUB {a | sorry} \u22a4"}, {"line": "simpa using isLUB_atoms_le (\u22a4 : \u03b1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isSimpleOrder_iff_isSimpleOrder_orderDual [LE \u03b1] [BoundedOrder \u03b1] :\n    IsSimpleOrder \u03b1 \u2194 IsSimpleOrder \u03b1\u1d52\u1d48 := by\n  constructor <;> intro i <;> haveI := i\n  \u00b7 exact\n      { exists_pair_ne := @exists_pair_ne \u03b1 _\n        eq_bot_or_eq_top := fun a => Or.symm (eq_bot_or_eq_top (OrderDual.ofDual a) : _ \u2228 _) }\n  \u00b7 exact\n      { exists_pair_ne := @exists_pair_ne \u03b1\u1d52\u1d48 _\n        eq_bot_or_eq_top := fun a => Or.symm (eq_bot_or_eq_top (OrderDual.toDual a)) }\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Atoms.lean", "context": {"open": [], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[Preorder \u03b1]", "[OrderTop \u03b1] {a x : \u03b1}", "[PartialOrder \u03b1] [OrderTop \u03b1] {a b x : \u03b1}", "{A B : Type*} [SetLike A B]", "[PartialOrder \u03b1] {a b : \u03b1}", "[PartialOrder \u03b1] (\u03b1)", "{\u03b1}", "[OrderBot \u03b1] [IsAtomic \u03b1]", "[OrderTop \u03b1] [IsCoatomic \u03b1]", "{\u03b1 : Type*} {a b : \u03b1} [Preorder \u03b1]", "(\u03b1) [PartialOrder \u03b1]", "{\u03b1}", "[OrderBot \u03b1] [IsAtomistic \u03b1]", "[OrderBot \u03b1] [IsAtomistic \u03b1]", "[OrderTop \u03b1]", "[IsCoatomistic \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderTop \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : BoundedOrder \u03b1\n\u22a2 IsSimpleOrder \u03b1 \u2194 IsSimpleOrder \u03b1\u1d52\u1d48"}, {"line": "constructor <;> intro i <;> haveI := i", "tactic_state": "case mp\n\u03b1 : Type u_6\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderTop \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : BoundedOrder \u03b1\ni this : IsSimpleOrder \u03b1\n\u22a2 IsSimpleOrder \u03b1\u1d52\u1d48\n---\ncase mpr\n\u03b1 : Type u_6\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderTop \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : BoundedOrder \u03b1\ni this : IsSimpleOrder \u03b1\u1d52\u1d48\n\u22a2 IsSimpleOrder \u03b1"}, {"line": "\u00b7 exact\n      { exists_pair_ne := @exists_pair_ne \u03b1 _\n        eq_bot_or_eq_top := fun a => Or.symm (eq_bot_or_eq_top (OrderDual.ofDual a) : _ \u2228 _) }", "tactic_state": "case mpr\n\u03b1 : Type u_6\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderTop \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : BoundedOrder \u03b1\ni this : IsSimpleOrder \u03b1\u1d52\u1d48\n\u22a2 IsSimpleOrder \u03b1"}, {"line": "\u00b7 exact\n      { exists_pair_ne := @exists_pair_ne \u03b1\u1d52\u1d48 _\n        eq_bot_or_eq_top := fun a => Or.symm (eq_bot_or_eq_top (OrderDual.toDual a)) }", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isAtom_of_map_bot_of_image [OrderBot \u03b1] [OrderBot \u03b2] (f : \u03b2 \u21aao \u03b1) (hbot : f \u22a5 = \u22a5) {b : \u03b2}\n    (hb : IsAtom (f b)) : IsAtom b := by\n  simp only [\u2190 bot_covBy_iff] at hb \u22a2\n  exact CovBy.of_image f (hbot.symm \u25b8 hb)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Atoms.lean", "context": {"open": ["Classical in", "Classical in"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[Preorder \u03b1]", "[OrderTop \u03b1] {a x : \u03b1}", "[PartialOrder \u03b1] [OrderTop \u03b1] {a b x : \u03b1}", "{A B : Type*} [SetLike A B]", "[PartialOrder \u03b1] {a b : \u03b1}", "[PartialOrder \u03b1] (\u03b1)", "{\u03b1}", "[OrderBot \u03b1] [IsAtomic \u03b1]", "[OrderTop \u03b1] [IsCoatomic \u03b1]", "{\u03b1 : Type*} {a b : \u03b1} [Preorder \u03b1]", "(\u03b1) [PartialOrder \u03b1]", "{\u03b1}", "[OrderBot \u03b1] [IsAtomistic \u03b1]", "[OrderBot \u03b1] [IsAtomistic \u03b1]", "[OrderTop \u03b1]", "[IsCoatomistic \u03b1]", "[PartialOrder \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1]", "[Preorder \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1] {a b : \u03b1} (h : a < b)", "[Lattice \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1]", "[DecidableEq \u03b1] [PartialOrder \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1]", "[Lattice \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1]", "[PartialOrder \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1]", "[PartialOrder \u03b1] [PartialOrder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_4\n\u03b1 : Type u_3\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b3 : OrderTop \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : BoundedOrder \u03b1\ninst\u271d\u00b2\u2070 : IsSimpleOrder \u03b1\ninst\u271d\u00b9\u2079 : Preorder \u03b1\ninst\u271d\u00b9\u2078 : BoundedOrder \u03b1\ninst\u271d\u00b9\u2077 : IsSimpleOrder \u03b1\ninst\u271d\u00b9\u2076 : Lattice \u03b1\ninst\u271d\u00b9\u2075 : BoundedOrder \u03b1\ninst\u271d\u00b9\u2074 : IsSimpleOrder \u03b1\ninst\u271d\u00b9\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b9\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b9 : BoundedOrder \u03b1\ninst\u271d\u00b9\u2070 : IsSimpleOrder \u03b1\ninst\u271d\u2079 : Lattice \u03b1\ninst\u271d\u2078 : BoundedOrder \u03b1\ninst\u271d\u2077 : IsSimpleOrder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : BoundedOrder \u03b1\ninst\u271d\u2074 : IsSimpleOrder \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b2\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : OrderBot \u03b2\nf : \u03b2 \u21aao \u03b1\nhbot : f \u22a5 = \u22a5\nb : \u03b2\nhb : IsAtom (f b)\n\u22a2 IsAtom b"}, {"line": "simp only [\u2190 bot_covBy_iff] at hb \u22a2", "tactic_state": "\u03b2 : Type u_4\n\u03b1 : Type u_3\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b3 : OrderTop \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : BoundedOrder \u03b1\ninst\u271d\u00b2\u2070 : IsSimpleOrder \u03b1\ninst\u271d\u00b9\u2079 : Preorder \u03b1\ninst\u271d\u00b9\u2078 : BoundedOrder \u03b1\ninst\u271d\u00b9\u2077 : IsSimpleOrder \u03b1\ninst\u271d\u00b9\u2076 : Lattice \u03b1\ninst\u271d\u00b9\u2075 : BoundedOrder \u03b1\ninst\u271d\u00b9\u2074 : IsSimpleOrder \u03b1\ninst\u271d\u00b9\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b9\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b9 : BoundedOrder \u03b1\ninst\u271d\u00b9\u2070 : IsSimpleOrder \u03b1\ninst\u271d\u2079 : Lattice \u03b1\ninst\u271d\u2078 : BoundedOrder \u03b1\ninst\u271d\u2077 : IsSimpleOrder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : BoundedOrder \u03b1\ninst\u271d\u2074 : IsSimpleOrder \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b2\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : OrderBot \u03b2\nf : \u03b2 \u21aao \u03b1\nhbot : f \u22a5 = \u22a5\nb : \u03b2\nhb : IsAtom (f b)\n\u22a2 \u22a5 \u22d6 b"}, {"line": "exact CovBy.of_image f (hbot.symm \u25b8 hb)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isAtom_iff {p : Prop} : IsAtom p \u2194 p := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Atoms.lean", "context": {"open": ["Classical in", "Classical in"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[Preorder \u03b1]", "[OrderTop \u03b1] {a x : \u03b1}", "[PartialOrder \u03b1] [OrderTop \u03b1] {a b x : \u03b1}", "{A B : Type*} [SetLike A B]", "[PartialOrder \u03b1] {a b : \u03b1}", "[PartialOrder \u03b1] (\u03b1)", "{\u03b1}", "[OrderBot \u03b1] [IsAtomic \u03b1]", "[OrderTop \u03b1] [IsCoatomic \u03b1]", "{\u03b1 : Type*} {a b : \u03b1} [Preorder \u03b1]", "(\u03b1) [PartialOrder \u03b1]", "{\u03b1}", "[OrderBot \u03b1] [IsAtomistic \u03b1]", "[OrderBot \u03b1] [IsAtomistic \u03b1]", "[OrderTop \u03b1]", "[IsCoatomistic \u03b1]", "[PartialOrder \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1]", "[Preorder \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1] {a b : \u03b1} (h : a < b)", "[Lattice \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1]", "[DecidableEq \u03b1] [PartialOrder \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1]", "[Lattice \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1]", "[PartialOrder \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1]", "[PartialOrder \u03b1] [PartialOrder \u03b2]", "[PartialOrder \u03b1] [PartialOrder \u03b2]", "[PartialOrder \u03b1] [PartialOrder \u03b2]", "[PartialOrder \u03b1] [PartialOrder \u03b2]", "[Lattice \u03b1]", "[Lattice \u03b1] [BoundedOrder \u03b1] [IsModularLattice \u03b1]", "{a b : \u03b1} (hc : IsCompl a b)", "[ComplementedLattice \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\n\u22a2 IsAtom p \u2194 p"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isAtom_iff_eq_single [DecidableEq \u03b9] [\u2200 i, PartialOrder (\u03c0 i)]\n    [\u2200 i, OrderBot (\u03c0 i)] {f : \u2200 i, \u03c0 i} :\n    IsAtom f \u2194 \u2203 i a, IsAtom a \u2227 f = Function.update \u22a5 i a := by\n  constructor\n  case mp =>\n    intro h\n    have \u27e8i, h, hbot\u27e9 := isAtom_iff.1 h\n    refine \u27e8_, _, h, funext fun j => if hij : j = i then hij \u25b8 by simp else ?_\u27e9\n    rw [Function.update_of_ne hij]\n    rw [hbot _ hij]\n    rw [bot_apply]\n  case mpr =>\n    rintro \u27e8i, a, h, rfl\u27e9\n    exact isAtom_single h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Atoms.lean", "context": {"open": ["Classical in", "Classical in"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}", "[Preorder \u03b1]", "[OrderTop \u03b1] {a x : \u03b1}", "[PartialOrder \u03b1] [OrderTop \u03b1] {a b x : \u03b1}", "{A B : Type*} [SetLike A B]", "[PartialOrder \u03b1] {a b : \u03b1}", "[PartialOrder \u03b1] (\u03b1)", "{\u03b1}", "[OrderBot \u03b1] [IsAtomic \u03b1]", "[OrderTop \u03b1] [IsCoatomic \u03b1]", "{\u03b1 : Type*} {a b : \u03b1} [Preorder \u03b1]", "(\u03b1) [PartialOrder \u03b1]", "{\u03b1}", "[OrderBot \u03b1] [IsAtomistic \u03b1]", "[OrderBot \u03b1] [IsAtomistic \u03b1]", "[OrderTop \u03b1]", "[IsCoatomistic \u03b1]", "[PartialOrder \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1]", "[Preorder \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1] {a b : \u03b1} (h : a < b)", "[Lattice \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1]", "[DecidableEq \u03b1] [PartialOrder \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1]", "[Lattice \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1]", "[PartialOrder \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1]", "[PartialOrder \u03b1] [PartialOrder \u03b2]", "[PartialOrder \u03b1] [PartialOrder \u03b2]", "[PartialOrder \u03b1] [PartialOrder \u03b2]", "[PartialOrder \u03b1] [PartialOrder \u03b2]", "[Lattice \u03b1]", "[Lattice \u03b1] [BoundedOrder \u03b1] [IsModularLattice \u03b1]", "{a b : \u03b1} (hc : IsCompl a b)", "[ComplementedLattice \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 PartialOrder (\u03c0 i)\ninst\u271d : (i : \u03b9) \u2192 OrderBot (\u03c0 i)\nf : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 IsAtom f \u2194 \u2203 i a, IsAtom a \u2227 f = Function.update \u22a5 i a"}, {"line": "constructor", "tactic_state": "case mp\n\u03b9 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 PartialOrder (\u03c0 i)\ninst\u271d : (i : \u03b9) \u2192 OrderBot (\u03c0 i)\nf : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 IsAtom f \u2192 \u2203 i a, IsAtom a \u2227 f = Function.update \u22a5 i a\n---\ncase mpr\n\u03b9 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 PartialOrder (\u03c0 i)\ninst\u271d : (i : \u03b9) \u2192 OrderBot (\u03c0 i)\nf : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 (\u2203 i a, IsAtom a \u2227 f = Function.update \u22a5 i a) \u2192 IsAtom f"}, {"line": "case mp =>\n    intro h\n    have \u27e8i, h, hbot\u27e9 := isAtom_iff.1 h\n    refine \u27e8_, _, h, funext fun j => if hij : j = i then hij \u25b8 by simp else ?_\u27e9\n    rw [Function.update_of_ne hij]\n    rw [hbot _ hij]\n    rw [bot_apply]", "tactic_state": "case mpr\n\u03b9 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 PartialOrder (\u03c0 i)\ninst\u271d : (i : \u03b9) \u2192 OrderBot (\u03c0 i)\nf : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 (\u2203 i a, IsAtom a \u2227 f = Function.update \u22a5 i a) \u2192 IsAtom f"}, {"line": "case mpr =>\n    rintro \u27e8i, a, h, rfl\u27e9\n    exact isAtom_single h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_lt_iff_not_le_or_ge : \u00aca < b \u2194 \u00aca \u2264 b \u2228 b \u2264 a := by\n  rw [lt_iff_le_not_le]\n  rw [Classical.not_and_iff_not_or_not]\n  rw [Classical.not_not]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 \u00aca < b \u2194 \u00aca \u2264 b \u2228 b \u2264 a"}, {"line": "rw [lt_iff_le_not_le]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 \u00ac(a \u2264 b \u2227 \u00acb \u2264 a) \u2194 \u00aca \u2264 b \u2228 b \u2264 a"}, {"line": "rw [Classical.not_and_iff_not_or_not]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 \u00aca \u2264 b \u2228 \u00ac\u00acb \u2264 a \u2194 \u00aca \u2264 b \u2228 b \u2264 a"}, {"line": "rw [Classical.not_not]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_lt_iff_le_imp_le : \u00ac a < b \u2194 (a \u2264 b \u2192 b \u2264 a) := by\n  simp [not_lt_iff_not_le_or_ge, or_iff_not_imp_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 \u00aca < b \u2194 a \u2264 b \u2192 b \u2264 a"}, {"line": "simp [not_lt_iff_not_le_or_ge, or_iff_not_imp_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Pi.lt_def [\u2200 i, Preorder (\u03c0 i)] {x y : \u2200 i, \u03c0 i} :\n    x < y \u2194 x \u2264 y \u2227 \u2203 i, x i < y i := by\n  simp +contextual [lt_iff_le_not_le, Pi.le_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] {a b : \u03b1}", "{P : Sort*} {x y : \u03b1}", "{p q r s : P}", "{p : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d : (i : \u03b9) \u2192 Preorder (\u03c0 i)\nx y : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 x < y \u2194 x \u2264 y \u2227 \u2203 i, x i < y i"}, {"line": "simp +contextual [lt_iff_le_not_le, Pi.le_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem update_le_update_iff :\n    Function.update x i a \u2264 Function.update y i b \u2194 a \u2264 b \u2227 \u2200 (j) (_ : j \u2260 i), x j \u2264 y j := by\n  simp +contextual [update_le_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] {a b : \u03b1}", "{P : Sort*} {x y : \u03b1}", "{p q r s : P}", "{p : \u03b1 \u2192 Prop}", "{\u03b1\u2081 \u03b1\u2082 : Type*} [LE \u03b2]", "[\u2200 i, Preorder (\u03c0 i)] {a b c : \u2200 i, \u03c0 i}", "[DecidableEq \u03b9] [\u2200 i, Preorder (\u03c0 i)] {x y : \u2200 i, \u03c0 i} {i : \u03b9} {a b : \u03c0 i}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Preorder (\u03c0 i)\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 Preorder (\u03c0 i)\nx y : (i : \u03b9) \u2192 \u03c0 i\ni : \u03b9\na b : \u03c0 i\n\u22a2 update x i a \u2264 update y i b \u2194 a \u2264 b \u2227 \u2200 (j : \u03b9), j \u2260 i \u2192 x j \u2264 y j"}, {"line": "simp +contextual [update_le_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem update_le_update_iff' : update x i a \u2264 update x i b \u2194 a \u2264 b := by\n  simp [update_le_update_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] {a b : \u03b1}", "{P : Sort*} {x y : \u03b1}", "{p q r s : P}", "{p : \u03b1 \u2192 Prop}", "{\u03b1\u2081 \u03b1\u2082 : Type*} [LE \u03b2]", "[\u2200 i, Preorder (\u03c0 i)] {a b c : \u2200 i, \u03c0 i}", "[DecidableEq \u03b9] [\u2200 i, Preorder (\u03c0 i)] {x y : \u2200 i, \u03c0 i} {i : \u03b9} {a b : \u03c0 i}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Preorder (\u03c0 i)\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 Preorder (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\ni : \u03b9\na b : \u03c0 i\n\u22a2 update x i a \u2264 update x i b \u2194 a \u2264 b"}, {"line": "simp [update_le_update_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_update_self_iff : x \u2264 update x i a \u2194 x i \u2264 a := by simp [le_update_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] {a b : \u03b1}", "{P : Sort*} {x y : \u03b1}", "{p q r s : P}", "{p : \u03b1 \u2192 Prop}", "{\u03b1\u2081 \u03b1\u2082 : Type*} [LE \u03b2]", "[\u2200 i, Preorder (\u03c0 i)] {a b c : \u2200 i, \u03c0 i}", "[DecidableEq \u03b9] [\u2200 i, Preorder (\u03c0 i)] {x y : \u2200 i, \u03c0 i} {i : \u03b9} {a b : \u03c0 i}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Preorder (\u03c0 i)\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 Preorder (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\ni : \u03b9\na : \u03c0 i\n\u22a2 x \u2264 update x i a \u2194 x i \u2264 a"}, {"line": "simp [le_update_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem update_le_self_iff : update x i a \u2264 x \u2194 a \u2264 x i := by simp [update_le_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] {a b : \u03b1}", "{P : Sort*} {x y : \u03b1}", "{p q r s : P}", "{p : \u03b1 \u2192 Prop}", "{\u03b1\u2081 \u03b1\u2082 : Type*} [LE \u03b2]", "[\u2200 i, Preorder (\u03c0 i)] {a b c : \u2200 i, \u03c0 i}", "[DecidableEq \u03b9] [\u2200 i, Preorder (\u03c0 i)] {x y : \u2200 i, \u03c0 i} {i : \u03b9} {a b : \u03c0 i}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Preorder (\u03c0 i)\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 Preorder (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\ni : \u03b9\na : \u03c0 i\n\u22a2 update x i a \u2264 x \u2194 a \u2264 x i"}, {"line": "simp [update_le_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_update_self_iff : x < update x i a \u2194 x i < a := by simp [lt_iff_le_not_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] {a b : \u03b1}", "{P : Sort*} {x y : \u03b1}", "{p q r s : P}", "{p : \u03b1 \u2192 Prop}", "{\u03b1\u2081 \u03b1\u2082 : Type*} [LE \u03b2]", "[\u2200 i, Preorder (\u03c0 i)] {a b c : \u2200 i, \u03c0 i}", "[DecidableEq \u03b9] [\u2200 i, Preorder (\u03c0 i)] {x y : \u2200 i, \u03c0 i} {i : \u03b9} {a b : \u03c0 i}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Preorder (\u03c0 i)\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 Preorder (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\ni : \u03b9\na : \u03c0 i\n\u22a2 x < update x i a \u2194 x i < a"}, {"line": "simp [lt_iff_le_not_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem update_lt_self_iff : update x i a < x \u2194 a < x i := by simp [lt_iff_le_not_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] {a b : \u03b1}", "{P : Sort*} {x y : \u03b1}", "{p q r s : P}", "{p : \u03b1 \u2192 Prop}", "{\u03b1\u2081 \u03b1\u2082 : Type*} [LE \u03b2]", "[\u2200 i, Preorder (\u03c0 i)] {a b c : \u2200 i, \u03c0 i}", "[DecidableEq \u03b9] [\u2200 i, Preorder (\u03c0 i)] {x y : \u2200 i, \u03c0 i} {i : \u03b9} {a b : \u03c0 i}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Preorder (\u03c0 i)\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 Preorder (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\ni : \u03b9\na : \u03c0 i\n\u22a2 update x i a < x \u2194 a < x i"}, {"line": "simp [lt_iff_le_not_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem const_le_const : const \u03b2 a \u2264 const \u03b2 b \u2194 a \u2264 b := by simp [Pi.le_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] {a b : \u03b1}", "{P : Sort*} {x y : \u03b1}", "{p q r s : P}", "{p : \u03b1 \u2192 Prop}", "{\u03b1\u2081 \u03b1\u2082 : Type*} [LE \u03b2]", "[\u2200 i, Preorder (\u03c0 i)] {a b c : \u2200 i, \u03c0 i}", "[DecidableEq \u03b9] [\u2200 i, Preorder (\u03c0 i)] {x y : \u2200 i, \u03c0 i} {i : \u03b9} {a b : \u03c0 i}", "[Preorder \u03b1] [Nonempty \u03b2] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : LE \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Nonempty \u03b2\na b : \u03b1\n\u22a2 const \u03b2 a \u2264 const \u03b2 b \u2194 a \u2264 b"}, {"line": "simp [Pi.le_def]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : LE \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Nonempty \u03b2\na b : \u03b1\n\u22a2 \u03b2 \u2192 a \u2264 b \u2194 a \u2264 b"}]}
{"declaration": "lemma mk_lt_mk_of_lt_of_le (h\u2081 : a\u2081 < a\u2082) (h\u2082 : b\u2081 \u2264 b\u2082) : (a\u2081, b\u2081) < (a\u2082, b\u2082) := by\n  simp [lt_iff, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] {a b : \u03b1}", "{P : Sort*} {x y : \u03b1}", "{p q r s : P}", "{p : \u03b1 \u2192 Prop}", "{\u03b1\u2081 \u03b1\u2082 : Type*} [LE \u03b2]", "[\u2200 i, Preorder (\u03c0 i)] {a b c : \u2200 i, \u03c0 i}", "[DecidableEq \u03b9] [\u2200 i, Preorder (\u03c0 i)] {x y : \u2200 i, \u03c0 i} {i : \u03b9} {a b : \u03c0 i}", "[Preorder \u03b1] [Nonempty \u03b2] {a b : \u03b1}", "[LE \u03b1] [LE \u03b2] {x y : \u03b1 \u00d7 \u03b2} {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2}", "[Preorder \u03b1] [Preorder \u03b2] {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2} {x y : \u03b1 \u00d7 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : PartialOrder \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : LE \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Nonempty \u03b2\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LE \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\na\u2081 a\u2082 : \u03b1\nb\u2081 b\u2082 : \u03b2\nh\u2081 : a\u2081 < a\u2082\nh\u2082 : b\u2081 \u2264 b\u2082\n\u22a2 (a\u2081, b\u2081) < (a\u2082, b\u2082)"}, {"line": "simp [lt_iff, *]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : PartialOrder \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : LE \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Nonempty \u03b2\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LE \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\na\u2081 a\u2082 : \u03b1\nb\u2081 b\u2082 : \u03b2\nh\u2081 : a\u2081 < a\u2082\nh\u2082 : b\u2081 \u2264 b\u2082\n\u22a2 b\u2081 \u2264 b\u2082 \u2228 a\u2081 \u2264 a\u2082 \u2227 b\u2081 < b\u2082"}]}
{"declaration": "lemma mk_lt_mk_of_le_of_lt (h\u2081 : a\u2081 \u2264 a\u2082) (h\u2082 : b\u2081 < b\u2082) : (a\u2081, b\u2081) < (a\u2082, b\u2082) := by\n  simp [lt_iff, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] {a b : \u03b1}", "{P : Sort*} {x y : \u03b1}", "{p q r s : P}", "{p : \u03b1 \u2192 Prop}", "{\u03b1\u2081 \u03b1\u2082 : Type*} [LE \u03b2]", "[\u2200 i, Preorder (\u03c0 i)] {a b c : \u2200 i, \u03c0 i}", "[DecidableEq \u03b9] [\u2200 i, Preorder (\u03c0 i)] {x y : \u2200 i, \u03c0 i} {i : \u03b9} {a b : \u03c0 i}", "[Preorder \u03b1] [Nonempty \u03b2] {a b : \u03b1}", "[LE \u03b1] [LE \u03b2] {x y : \u03b1 \u00d7 \u03b2} {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2}", "[Preorder \u03b1] [Preorder \u03b2] {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2} {x y : \u03b1 \u00d7 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : PartialOrder \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : LE \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Nonempty \u03b2\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LE \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\na\u2081 a\u2082 : \u03b1\nb\u2081 b\u2082 : \u03b2\nh\u2081 : a\u2081 \u2264 a\u2082\nh\u2082 : b\u2081 < b\u2082\n\u22a2 (a\u2081, b\u2081) < (a\u2082, b\u2082)"}, {"line": "simp [lt_iff, *]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : PartialOrder \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : LE \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Nonempty \u03b2\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LE \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\na\u2081 a\u2082 : \u03b1\nb\u2081 b\u2082 : \u03b2\nh\u2081 : a\u2081 \u2264 a\u2082\nh\u2082 : b\u2081 < b\u2082\n\u22a2 a\u2081 < a\u2082 \u2227 b\u2081 \u2264 b\u2082 \u2228 a\u2081 \u2264 a\u2082"}]}
{"declaration": "lemma supIrredLowerSet_surjective : Surjective (supIrredLowerSet (\u03b1 := \u03b1)) := by\n  aesop (add simp Surjective)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Birkhoff.lean", "context": {"open": ["Finset Function OrderDual UpperSet LowerSet"], "variables": ["{\u03b1 : Type*}", "[PartialOrder \u03b1]", "{s : UpperSet \u03b1}", "[Finite \u03b1]", "{s : LowerSet \u03b1}", "[Finite \u03b1]", "[Finite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nsupIrredLowerSet : x\u271d\n\u22a2 Surjective sorry"}, {"line": "aesop (add simp Surjective)", "tactic_state": "x : Sort u_2\nsupIrredLowerSet : x\nb : ?m.741\n\u22a2 \u2203 a, sorry () a = b"}]}
{"declaration": "lemma infIrredUpperSet_surjective : Surjective (infIrredUpperSet (\u03b1 := \u03b1)) := by\n  aesop (add simp Surjective)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Birkhoff.lean", "context": {"open": ["Finset Function OrderDual UpperSet LowerSet"], "variables": ["{\u03b1 : Type*}", "[PartialOrder \u03b1]", "{s : UpperSet \u03b1}", "[Finite \u03b1]", "{s : LowerSet \u03b1}", "[Finite \u03b1]", "[Finite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\ninfIrredUpperSet : x\u271d\n\u22a2 Surjective sorry"}, {"line": "aesop (add simp Surjective)", "tactic_state": "x : Sort u_2\ninfIrredUpperSet : x\nb : ?m.741\n\u22a2 \u2203 a, sorry () a = b"}]}
{"declaration": "theorem sup_sdiff_inf (x y : \u03b1) : x \\ y \u2294 x \u2293 y = x := by rw [sup_comm, sup_inf_sdiff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\nx y : \u03b1\n\u22a2 x \\ y \u2294 x \u2293 y = x"}, {"line": "rw [sup_comm, sup_inf_sdiff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_sdiff_inf (x y : \u03b1) : x \\ y \u2293 (x \u2293 y) = \u22a5 := by rw [inf_comm, inf_inf_sdiff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\nx y : \u03b1\n\u22a2 x \\ y \u2293 (x \u2293 y) = \u22a5"}, {"line": "rw [inf_comm, inf_inf_sdiff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_sdiff_self_left : y \\ x \u2293 x = \u22a5 := by rw [inf_comm, inf_sdiff_self_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\n\u22a2 y \\ x \u2293 x = \u22a5"}, {"line": "rw [inf_comm, inf_sdiff_self_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_sdiff_eq_bot_iff (hz : z \u2264 y) (hx : x \u2264 y) : z \u2293 y \\ x = \u22a5 \u2194 z \u2264 x := by\n  rw [\u2190 disjoint_iff]\n  exact disjoint_sdiff_iff_le hz hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx y z : \u03b1\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\nhz : z \u2264 y\nhx : x \u2264 y\n\u22a2 z \u2293 y \\ x = \u22a5 \u2194 z \u2264 x"}, {"line": "rw [\u2190 disjoint_iff]", "tactic_state": "\u03b1 : Type u\nx y z : \u03b1\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\nhz : z \u2264 y\nhx : x \u2264 y\n\u22a2 Disjoint z (y \\ x) \u2194 z \u2264 x"}, {"line": "exact disjoint_sdiff_iff_le hz hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sdiff_eq_self_iff_disjoint' : x \\ y = x \u2194 Disjoint x y := by\n  rw [sdiff_eq_self_iff_disjoint]\n  rw [disjoint_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\n\u22a2 x \\ y = x \u2194 Disjoint x y"}, {"line": "rw [sdiff_eq_self_iff_disjoint]", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\n\u22a2 Disjoint y x \u2194 Disjoint x y"}, {"line": "rw [disjoint_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sdiff_sdiff_eq_sdiff_sup (h : z \u2264 x) : x \\ (y \\ z) = x \\ y \u2294 z := by\n  rw [sdiff_sdiff_right']\n  rw [inf_eq_right.2 h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx y z : \u03b1\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\nh : z \u2264 x\n\u22a2 x \\ (y \\ z) = x \\ y \u2294 z"}, {"line": "rw [sdiff_sdiff_right']", "tactic_state": "\u03b1 : Type u\nx y z : \u03b1\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\nh : z \u2264 x\n\u22a2 x \\ y \u2294 x \u2293 z = x \\ y \u2294 z"}, {"line": "rw [inf_eq_right.2 h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inf_sdiff_left_comm (a b c : \u03b1) : a \u2293 (b \\ c) = b \u2293 (a \\ c) := by\n  simp_rw [\u2190 inf_sdiff_assoc, inf_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \u2293 b \\ c = b \u2293 a \\ c"}, {"line": "simp_rw [\u2190 inf_sdiff_assoc, inf_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_sdiff_distrib_left (a b c : \u03b1) : a \u2293 b \\ c = (a \u2293 b) \\ (a \u2293 c) := by\n  rw [sdiff_inf]\n  rw [sdiff_eq_bot_iff.2 inf_le_left]\n  rw [bot_sup_eq]\n  rw [inf_sdiff_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \u2293 b \\ c = (a \u2293 b) \\ (a \u2293 c)"}, {"line": "rw [sdiff_inf]", "tactic_state": "\u03b1 : Type u\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \u2293 b \\ c = (a \u2293 b) \\ a \u2294 (a \u2293 b) \\ c"}, {"line": "rw [sdiff_eq_bot_iff.2 inf_le_left]", "tactic_state": "\u03b1 : Type u\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \u2293 b \\ c = \u22a5 \u2294 (a \u2293 b) \\ c"}, {"line": "rw [bot_sup_eq]", "tactic_state": "\u03b1 : Type u\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \u2293 b \\ c = (a \u2293 b) \\ c"}, {"line": "rw [inf_sdiff_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_sdiff_comm : Disjoint (x \\ z) y \u2194 Disjoint x (y \\ z) := by\n  simp_rw [disjoint_iff, sdiff_inf_right_comm, inf_sdiff_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx y z : \u03b1\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\n\u22a2 Disjoint (x \\ z) y \u2194 Disjoint x (y \\ z)"}, {"line": "simp_rw [disjoint_iff, sdiff_inf_right_comm, inf_sdiff_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_sup_eq_top : x\u1d9c \u2294 x = \u22a4 := by rw [sup_comm, sup_compl_eq_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]", "[BooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 x\u1d9c \u2294 x = \u22a4"}, {"line": "rw [sup_comm, sup_compl_eq_top]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_eq_comm : x\u1d9c = y \u2194 y\u1d9c = x := by\n  rw [eq_comm]\n  rw [compl_eq_iff_isCompl]\n  rw [eq_compl_iff_isCompl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]", "[BooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 x\u1d9c = y \u2194 y\u1d9c = x"}, {"line": "rw [eq_comm]", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 y = x\u1d9c \u2194 y\u1d9c = x"}, {"line": "rw [compl_eq_iff_isCompl]", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 y = x\u1d9c \u2194 IsCompl y x"}, {"line": "rw [eq_compl_iff_isCompl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_compl_comm : x = y\u1d9c \u2194 y = x\u1d9c := by\n  rw [eq_comm]\n  rw [compl_eq_iff_isCompl]\n  rw [eq_compl_iff_isCompl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]", "[BooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 x = y\u1d9c \u2194 y = x\u1d9c"}, {"line": "rw [eq_comm]", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 y\u1d9c = x \u2194 y = x\u1d9c"}, {"line": "rw [compl_eq_iff_isCompl]", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 IsCompl y x \u2194 y = x\u1d9c"}, {"line": "rw [eq_compl_iff_isCompl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_le_of_compl_le (h : y\u1d9c \u2264 x) : x\u1d9c \u2264 y := by\n  simpa only [compl_compl] using compl_le_compl h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]", "[BooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\nh : y\u1d9c \u2264 x\n\u22a2 x\u1d9c \u2264 y"}, {"line": "simpa only [compl_compl] using compl_le_compl h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sdiff_compl : x \\ y\u1d9c = x \u2293 y := by rw [sdiff_eq, compl_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]", "[BooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 x \\ y\u1d9c = x \u2293 y"}, {"line": "rw [sdiff_eq, compl_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_sdiff : (x \\ y)\u1d9c = x \u21e8 y := by\n  rw [sdiff_eq]\n  rw [himp_eq]\n  rw [compl_inf]\n  rw [compl_compl]\n  rw [sup_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]", "[BooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 (x \\ y)\u1d9c = x \u21e8 y"}, {"line": "rw [sdiff_eq]", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 (x \u2293 y\u1d9c)\u1d9c = x \u21e8 y"}, {"line": "rw [himp_eq]", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 (x \u2293 y\u1d9c)\u1d9c = y \u2294 x\u1d9c"}, {"line": "rw [compl_inf]", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 x\u1d9c \u2294 y\u1d9c\u1d9c = y \u2294 x\u1d9c"}, {"line": "rw [compl_compl]", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 x\u1d9c \u2294 y = y \u2294 x\u1d9c"}, {"line": "rw [sup_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_sdiff_compl : x\u1d9c \\ y\u1d9c = y \\ x := by rw [sdiff_compl, sdiff_eq, inf_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]", "[BooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 x\u1d9c \\ y\u1d9c = y \\ x"}, {"line": "rw [sdiff_compl, sdiff_eq, inf_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_compl_left_iff : Disjoint x\u1d9c y \u2194 y \u2264 x := by\n  rw [\u2190 le_compl_iff_disjoint_left]\n  rw [compl_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]", "[BooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 Disjoint x\u1d9c y \u2194 y \u2264 x"}, {"line": "rw [\u2190 le_compl_iff_disjoint_left]", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 y \u2264 x\u1d9c\u1d9c \u2194 y \u2264 x"}, {"line": "rw [compl_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_compl_right_iff : Disjoint x y\u1d9c \u2194 x \u2264 y := by\n  rw [\u2190 le_compl_iff_disjoint_right]\n  rw [compl_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]", "[BooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 Disjoint x y\u1d9c \u2194 x \u2264 y"}, {"line": "rw [\u2190 le_compl_iff_disjoint_right]", "tactic_state": "\u03b1 : Type u\nx y : \u03b1\ninst\u271d\u00b9 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 x \u2264 y\u1d9c\u1d9c \u2194 x \u2264 y"}, {"line": "rw [compl_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Bool.sup_eq_bor : (\u00b7 \u2294 \u00b7) = or := by dsimp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]", "[BooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun x1 x2 => max x1 x2) = or"}, {"line": "dsimp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Bool.inf_eq_band : (\u00b7 \u2293 \u00b7) = and := by dsimp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/BooleanAlgebra.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {x y z : \u03b1}", "[GeneralizedBooleanAlgebra \u03b1]", "[BooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun x1 x2 => min x1 x2) = and"}, {"line": "dsimp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isCofinal_empty_iff : IsCofinal (\u2205 : Set \u03b1) \u2194 IsEmpty \u03b1 := by\n  refine \u27e8fun h \u21a6 \u27e8fun a \u21a6 ?_\u27e9, fun h \u21a6 .of_isEmpty _\u27e9\n  simpa using h a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Cofinal.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LE \u03b1\n\u22a2 IsCofinal \u2205 \u2194 IsEmpty \u03b1"}, {"line": "refine \u27e8fun h \u21a6 \u27e8fun a \u21a6 ?_\u27e9, fun h \u21a6 .of_isEmpty _\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LE \u03b1\nh : IsCofinal \u2205\na : \u03b1\n\u22a2 False"}, {"line": "simpa using h a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCofinal.mono {s t : Set \u03b1} (h : s \u2286 t) (hs : IsCofinal s) : IsCofinal t := by\n  intro a\n  obtain \u27e8b, hb, hb'\u27e9 := hs a\n  exact \u27e8b, h hb, hb'\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Cofinal.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[LE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LE \u03b1\ns t : Set \u03b1\nh : s \u2286 t\nhs : IsCofinal s\n\u22a2 IsCofinal t"}, {"line": "intro a", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LE \u03b1\ns t : Set \u03b1\nh : s \u2286 t\nhs : IsCofinal s\na : \u03b1\n\u22a2 \u2203 y \u2208 t, a \u2264 y"}, {"line": "obtain \u27e8b, hb, hb'\u27e9 := hs a", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : LE \u03b1\ns t : Set \u03b1\nh : s \u2286 t\nhs : IsCofinal s\na b : \u03b1\nhb : b \u2208 s\nhb' : a \u2264 b\n\u22a2 \u2203 y \u2208 t, a \u2264 y"}, {"line": "exact \u27e8b, h hb, hb'\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem GaloisConnection.map_cofinal [Preorder \u03b2] {f : \u03b2 \u2192 \u03b1} {g : \u03b1 \u2192 \u03b2}\n    (h : GaloisConnection f g) {s : Set \u03b1} (hs : IsCofinal s) : IsCofinal (g '' s) := by\n  intro a\n  obtain \u27e8b, hb, hb'\u27e9 := hs (f a)\n  exact \u27e8g b, Set.mem_image_of_mem _ hb, h.le_iff_le.1 hb'\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Cofinal.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[LE \u03b1]", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b2 \u2192 \u03b1\ng : \u03b1 \u2192 \u03b2\nh : GaloisConnection f g\ns : Set \u03b1\nhs : IsCofinal s\n\u22a2 IsCofinal (g '' s)"}, {"line": "intro a", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b2 \u2192 \u03b1\ng : \u03b1 \u2192 \u03b2\nh : GaloisConnection f g\ns : Set \u03b1\nhs : IsCofinal s\na : \u03b2\n\u22a2 \u2203 y \u2208 g '' s, a \u2264 y"}, {"line": "obtain \u27e8b, hb, hb'\u27e9 := hs (f a)", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b2 \u2192 \u03b1\ng : \u03b1 \u2192 \u03b2\nh : GaloisConnection f g\ns : Set \u03b1\nhs : IsCofinal s\na : \u03b2\nb : \u03b1\nhb : b \u2208 s\nhb' : f a \u2264 b\n\u22a2 \u2203 y \u2208 g '' s, a \u2264 y"}, {"line": "exact \u27e8g b, Set.mem_image_of_mem _ hb, h.le_iff_le.1 hb'\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_isCofinal_iff {s : Set \u03b1} : \u00ac IsCofinal s \u2194 \u2203 x, \u2200 y \u2208 s, y < x := by\n  simp [IsCofinal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Cofinal.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[LE \u03b1]", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : LinearOrder \u03b1\ns : Set \u03b1\n\u22a2 \u00acIsCofinal s \u2194 \u2203 x, \u2200 y \u2208 s, y < x"}, {"line": "simp [IsCofinal]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : LinearOrder \u03b1\ns : Set \u03b1\n\u22a2 (\u2203 x, \u2200 x_1 \u2208 s, \u00acx \u2264 x_1) \u2194 \u2203 x, \u2200 y \u2208 s, y < x"}]}
{"declaration": "theorem CompRel.of_compRel_of_antisymmRel\n    (h\u2081 : CompRel (\u00b7 \u2264 \u00b7) a b) (h\u2082 : AntisymmRel (\u00b7 \u2264 \u00b7) b c) : CompRel (\u00b7 \u2264 \u00b7) a c := by\n  obtain (h | h) := h\u2081\n  \u00b7 exact (h.trans h\u2082.le).compRel\n  \u00b7 exact (h\u2082.ge.trans h).compRel_symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Comparable.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {a b c d : \u03b1}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "[LE \u03b1]", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c : \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\nh\u2081 : CompRel (fun x1 x2 => x1 \u2264 x2) a b\nh\u2082 : AntisymmRel (fun x1 x2 => x1 \u2264 x2) b c\n\u22a2 CompRel (fun x1 x2 => x1 \u2264 x2) a c"}, {"line": "obtain (h | h) := h\u2081", "tactic_state": "case inl\n\u03b1 : Type u_1\na b c : \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\nh\u2082 : AntisymmRel (fun x1 x2 => x1 \u2264 x2) b c\nh : a \u2264 b\n\u22a2 CompRel (fun x1 x2 => x1 \u2264 x2) a c\n---\ncase inr\n\u03b1 : Type u_1\na b c : \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\nh\u2082 : AntisymmRel (fun x1 x2 => x1 \u2264 x2) b c\nh : b \u2264 a\n\u22a2 CompRel (fun x1 x2 => x1 \u2264 x2) a c"}, {"line": "\u00b7 exact (h.trans h\u2082.le).compRel", "tactic_state": "case inr\n\u03b1 : Type u_1\na b c : \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\nh\u2082 : AntisymmRel (fun x1 x2 => x1 \u2264 x2) b c\nh : b \u2264 a\n\u22a2 CompRel (fun x1 x2 => x1 \u2264 x2) a c"}, {"line": "\u00b7 exact (h\u2082.ge.trans h).compRel_symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem incompRel_compl_apply : IncompRel r\u1d9c a b \u2194 AntisymmRel r a b := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Comparable.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {a b c d : \u03b1}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "[LE \u03b1]", "[Preorder \u03b1]", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 IncompRel r\u1d9c a b \u2194 AntisymmRel r a b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_compRel_iff : \u00ac CompRel r a b \u2194 IncompRel r a b := by\n  simp [CompRel, IncompRel]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Comparable.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {a b c d : \u03b1}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "[LE \u03b1]", "[Preorder \u03b1]", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop)", "{r} in", "{r}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u00acCompRel r a b \u2194 IncompRel r a b"}, {"line": "simp [CompRel, IncompRel]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_incompRel_iff : \u00ac IncompRel r a b \u2194 CompRel r a b := by\n  rw [\u2190 not_compRel_iff]\n  rw [not_not]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Comparable.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {a b c d : \u03b1}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "[LE \u03b1]", "[Preorder \u03b1]", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop)", "{r} in", "{r}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u00acIncompRel r a b \u2194 CompRel r a b"}, {"line": "rw [\u2190 not_compRel_iff]", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : Preorder \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u00ac\u00acCompRel r a b \u2194 CompRel r a b"}, {"line": "rw [not_not]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsTotal.not_incompRel [IsTotal \u03b1 r] (a b : \u03b1) : \u00ac IncompRel r a b := by\n  rw [not_incompRel_iff]\n  exact IsTotal.compRel a b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Comparable.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {a b c d : \u03b1}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "[LE \u03b1]", "[Preorder \u03b1]", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop)", "{r} in", "{r}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsTotal \u03b1 r\na b : \u03b1\n\u22a2 \u00acIncompRel r a b"}, {"line": "rw [not_incompRel_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsTotal \u03b1 r\na b : \u03b1\n\u22a2 CompRel r a b"}, {"line": "exact IsTotal.compRel a b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_or_eq_or_gt_or_incompRel [PartialOrder \u03b1] (a b : \u03b1) :\n    a < b \u2228 a = b \u2228 b < a \u2228 IncompRel (\u00b7 \u2264 \u00b7) a b := by\n  simpa using lt_or_antisymmRel_or_gt_or_incompRel a b", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Comparable.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {a b c d : \u03b1}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "[LE \u03b1]", "[Preorder \u03b1]", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop)", "{r} in", "{r}", "[LE \u03b1]", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : LE \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\n\u22a2 a < b \u2228 a = b \u2228 b < a \u2228 IncompRel (fun x1 x2 => x1 \u2264 x2) a b"}, {"line": "simpa using lt_or_antisymmRel_or_gt_or_incompRel a b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cmpLE_swap {\u03b1} [LE \u03b1] [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] [DecidableLE \u03b1] (x y : \u03b1) :\n    (cmpLE x y).swap = cmpLE y x := by\n  by_cases xy : x \u2264 y <;> by_cases yx : y \u2264 x <;> simp [cmpLE, *, Ordering.swap]\n  cases not_or_intro xy yx (total_of _ _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Compare.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d : DecidableLE \u03b1\nx y : \u03b1\n\u22a2 (cmpLE x y).swap = cmpLE y x"}, {"line": "by_cases xy : x \u2264 y <;> by_cases yx : y \u2264 x <;> simp [cmpLE, *, Ordering.swap]", "tactic_state": "case pos\n\u03b1 : Type u_3\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d : DecidableLE \u03b1\nx y : \u03b1\nxy : sorry\nyx : sorry\n\u22a2 (match if x \u2264 y then if y \u2264 x then Ordering.eq else Ordering.lt else Ordering.gt with\n    | Ordering.lt => Ordering.gt\n    | Ordering.eq => Ordering.eq\n    | Ordering.gt => Ordering.lt) =\n    if y \u2264 x then if x \u2264 y then Ordering.eq else Ordering.lt else Ordering.gt\n---\ncase neg\n\u03b1 : Type u_3\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d : DecidableLE \u03b1\nx y : \u03b1\nxy : sorry\nyx : \u00acsorry\n\u22a2 (match if x \u2264 y then if y \u2264 x then Ordering.eq else Ordering.lt else Ordering.gt with\n    | Ordering.lt => Ordering.gt\n    | Ordering.eq => Ordering.eq\n    | Ordering.gt => Ordering.lt) =\n    if y \u2264 x then if x \u2264 y then Ordering.eq else Ordering.lt else Ordering.gt\n---\ncase pos\n\u03b1 : Type u_3\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d : DecidableLE \u03b1\nx y : \u03b1\nxy : \u00acsorry\nyx : sorry\n\u22a2 (match if x \u2264 y then if y \u2264 x then Ordering.eq else Ordering.lt else Ordering.gt with\n    | Ordering.lt => Ordering.gt\n    | Ordering.eq => Ordering.eq\n    | Ordering.gt => Ordering.lt) =\n    if y \u2264 x then if x \u2264 y then Ordering.eq else Ordering.lt else Ordering.gt\n---\ncase neg\n\u03b1 : Type u_3\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d : DecidableLE \u03b1\nx y : \u03b1\nxy : \u00acsorry\nyx : \u00acsorry\n\u22a2 (match if x \u2264 y then if y \u2264 x then Ordering.eq else Ordering.lt else Ordering.gt with\n    | Ordering.lt => Ordering.gt\n    | Ordering.eq => Ordering.eq\n    | Ordering.gt => Ordering.lt) =\n    if y \u2264 x then if x \u2264 y then Ordering.eq else Ordering.lt else Ordering.gt"}, {"line": "cases not_or_intro xy yx (total_of _ _ _)", "tactic_state": "case neg\n\u03b1 : Type u_3\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d : DecidableLE \u03b1\nx y : \u03b1\nxy : sorry\nyx : \u00acsorry\n\u22a2 (match if x \u2264 y then if y \u2264 x then Ordering.eq else Ordering.lt else Ordering.gt with\n    | Ordering.lt => Ordering.gt\n    | Ordering.eq => Ordering.eq\n    | Ordering.gt => Ordering.lt) =\n    if y \u2264 x then if x \u2264 y then Ordering.eq else Ordering.lt else Ordering.gt\n---\ncase pos\n\u03b1 : Type u_3\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d : DecidableLE \u03b1\nx y : \u03b1\nxy : \u00acsorry\nyx : sorry\n\u22a2 (match if x \u2264 y then if y \u2264 x then Ordering.eq else Ordering.lt else Ordering.gt with\n    | Ordering.lt => Ordering.gt\n    | Ordering.eq => Ordering.eq\n    | Ordering.gt => Ordering.lt) =\n    if y \u2264 x then if x \u2264 y then Ordering.eq else Ordering.lt else Ordering.gt\n---\ncase neg\n\u03b1 : Type u_3\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d : DecidableLE \u03b1\nx y : \u03b1\nxy : \u00acsorry\nyx : \u00acsorry\n\u22a2 (match if x \u2264 y then if y \u2264 x then Ordering.eq else Ordering.lt else Ordering.gt with\n    | Ordering.lt => Ordering.gt\n    | Ordering.eq => Ordering.eq\n    | Ordering.gt => Ordering.lt) =\n    if y \u2264 x then if x \u2264 y then Ordering.eq else Ordering.lt else Ordering.gt"}]}
{"declaration": "theorem cmpLE_eq_cmp {\u03b1} [Preorder \u03b1] [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] [DecidableLE \u03b1] [DecidableLT \u03b1]\n    (x y : \u03b1) : cmpLE x y = cmp x y := by\n  by_cases xy : x \u2264 y <;> by_cases yx : y \u2264 x <;> simp [cmpLE, lt_iff_le_not_le, *, cmp, cmpUsing]\n  cases not_or_intro xy yx (total_of _ _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Compare.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : DecidableLT \u03b1\nx y : \u03b1\n\u22a2 cmpLE x y = cmp x y"}, {"line": "by_cases xy : x \u2264 y <;> by_cases yx : y \u2264 x <;> simp [cmpLE, lt_iff_le_not_le, *, cmp, cmpUsing]", "tactic_state": "case pos\n\u03b1 : Type u_3\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : DecidableLT \u03b1\nx y : \u03b1\nxy : sorry\nyx : sorry\n\u22a2 (if x \u2264 y then if y \u2264 x then Ordering.eq else Ordering.lt else Ordering.gt) =\n    if x < y then Ordering.lt else if y < x then Ordering.gt else Ordering.eq\n---\ncase neg\n\u03b1 : Type u_3\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : DecidableLT \u03b1\nx y : \u03b1\nxy : sorry\nyx : \u00acsorry\n\u22a2 (if x \u2264 y then if y \u2264 x then Ordering.eq else Ordering.lt else Ordering.gt) =\n    if x < y then Ordering.lt else if y < x then Ordering.gt else Ordering.eq\n---\ncase pos\n\u03b1 : Type u_3\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : DecidableLT \u03b1\nx y : \u03b1\nxy : \u00acsorry\nyx : sorry\n\u22a2 (if x \u2264 y then if y \u2264 x then Ordering.eq else Ordering.lt else Ordering.gt) =\n    if x < y then Ordering.lt else if y < x then Ordering.gt else Ordering.eq\n---\ncase neg\n\u03b1 : Type u_3\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : DecidableLT \u03b1\nx y : \u03b1\nxy : \u00acsorry\nyx : \u00acsorry\n\u22a2 (if x \u2264 y then if y \u2264 x then Ordering.eq else Ordering.lt else Ordering.gt) =\n    if x < y then Ordering.lt else if y < x then Ordering.gt else Ordering.eq"}, {"line": "cases not_or_intro xy yx (total_of _ _ _)", "tactic_state": "case neg\n\u03b1 : Type u_3\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : DecidableLT \u03b1\nx y : \u03b1\nxy : sorry\nyx : \u00acsorry\n\u22a2 (if x \u2264 y then if y \u2264 x then Ordering.eq else Ordering.lt else Ordering.gt) =\n    if x < y then Ordering.lt else if y < x then Ordering.gt else Ordering.eq\n---\ncase pos\n\u03b1 : Type u_3\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : DecidableLT \u03b1\nx y : \u03b1\nxy : \u00acsorry\nyx : sorry\n\u22a2 (if x \u2264 y then if y \u2264 x then Ordering.eq else Ordering.lt else Ordering.gt) =\n    if x < y then Ordering.lt else if y < x then Ordering.gt else Ordering.eq\n---\ncase neg\n\u03b1 : Type u_3\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : IsTotal \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : DecidableLT \u03b1\nx y : \u03b1\nxy : \u00acsorry\nyx : \u00acsorry\n\u22a2 (if x \u2264 y then if y \u2264 x then Ordering.eq else Ordering.lt else Ordering.gt) =\n    if x < y then Ordering.lt else if y < x then Ordering.gt else Ordering.eq"}]}
{"declaration": "theorem compares_swap [LT \u03b1] {a b : \u03b1} {o : Ordering} : o.swap.Compares a b \u2194 o.Compares b a := by\n  cases o\n  \u00b7 exact Iff.rfl\n  \u00b7 exact eq_comm\n  \u00b7 exact Iff.rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Compare.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LT \u03b1\na b : \u03b1\no : Ordering\n\u22a2 o.swap.Compares a b \u2194 o.Compares b a"}, {"line": "cases o", "tactic_state": "case lt\n\u03b1 : Type u_1\ninst\u271d : LT \u03b1\na b : \u03b1\n\u22a2 Ordering.lt.swap.Compares a b \u2194 Ordering.lt.Compares b a\n---\ncase eq\n\u03b1 : Type u_1\ninst\u271d : LT \u03b1\na b : \u03b1\n\u22a2 Ordering.eq.swap.Compares a b \u2194 Ordering.eq.Compares b a\n---\ncase gt\n\u03b1 : Type u_1\ninst\u271d : LT \u03b1\na b : \u03b1\n\u22a2 Ordering.gt.swap.Compares a b \u2194 Ordering.gt.Compares b a"}, {"line": "\u00b7 exact Iff.rfl", "tactic_state": "case eq\n\u03b1 : Type u_1\ninst\u271d : LT \u03b1\na b : \u03b1\n\u22a2 Ordering.eq.swap.Compares a b \u2194 Ordering.eq.Compares b a\n---\ncase gt\n\u03b1 : Type u_1\ninst\u271d : LT \u03b1\na b : \u03b1\n\u22a2 Ordering.gt.swap.Compares a b \u2194 Ordering.gt.Compares b a"}, {"line": "\u00b7 exact eq_comm", "tactic_state": "case gt\n\u03b1 : Type u_1\ninst\u271d : LT \u03b1\na b : \u03b1\n\u22a2 Ordering.gt.swap.Compares a b \u2194 Ordering.gt.Compares b a"}, {"line": "\u00b7 exact Iff.rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toDual_compares_toDual [LT \u03b1] {a b : \u03b1} {o : Ordering} :\n    Compares o (toDual a) (toDual b) \u2194 Compares o b a := by\n  cases o\n  exacts [Iff.rfl, eq_comm, Iff.rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Compare.lean", "context": {"open": ["Ordering OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LT \u03b1\na b : \u03b1\no : Ordering\n\u22a2 o.Compares (toDual a) (toDual b) \u2194 o.Compares b a"}, {"line": "cases o", "tactic_state": "case lt\n\u03b1 : Type u_1\ninst\u271d : LT \u03b1\na b : \u03b1\n\u22a2 lt.Compares (toDual a) (toDual b) \u2194 lt.Compares b a\n---\ncase eq\n\u03b1 : Type u_1\ninst\u271d : LT \u03b1\na b : \u03b1\n\u22a2 eq.Compares (toDual a) (toDual b) \u2194 eq.Compares b a\n---\ncase gt\n\u03b1 : Type u_1\ninst\u271d : LT \u03b1\na b : \u03b1\n\u22a2 gt.Compares (toDual a) (toDual b) \u2194 gt.Compares b a"}, {"line": "exacts [Iff.rfl, eq_comm, Iff.rfl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofDual_compares_ofDual [LT \u03b1] {a b : \u03b1\u1d52\u1d48} {o : Ordering} :\n    Compares o (ofDual a) (ofDual b) \u2194 Compares o b a := by\n  cases o\n  exacts [Iff.rfl, eq_comm, Iff.rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Compare.lean", "context": {"open": ["Ordering OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LT \u03b1\na b : \u03b1\u1d52\u1d48\no : Ordering\n\u22a2 o.Compares (ofDual a) (ofDual b) \u2194 o.Compares b a"}, {"line": "cases o", "tactic_state": "case lt\n\u03b1 : Type u_1\ninst\u271d : LT \u03b1\na b : \u03b1\u1d52\u1d48\n\u22a2 lt.Compares (ofDual a) (ofDual b) \u2194 lt.Compares b a\n---\ncase eq\n\u03b1 : Type u_1\ninst\u271d : LT \u03b1\na b : \u03b1\u1d52\u1d48\n\u22a2 eq.Compares (ofDual a) (ofDual b) \u2194 eq.Compares b a\n---\ncase gt\n\u03b1 : Type u_1\ninst\u271d : LT \u03b1\na b : \u03b1\u1d52\u1d48\n\u22a2 gt.Compares (ofDual a) (ofDual b) \u2194 gt.Compares b a"}, {"line": "exacts [Iff.rfl, eq_comm, Iff.rfl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cmp_self_eq_eq : cmp x x = Ordering.eq := by rw [cmp_eq_eq_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Compare.lean", "context": {"open": ["Ordering OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}", "[LinearOrder \u03b1] (x y : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nx : \u03b1\n\u22a2 cmp x x = eq"}, {"line": "rw [cmp_eq_eq_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_iff_lt_of_cmp_eq_cmp (h : cmp x y = cmp x' y') : x < y \u2194 x' < y' := by\n  rw [\u2190 cmp_eq_lt_iff]\n  rw [\u2190 cmp_eq_lt_iff]\n  rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Compare.lean", "context": {"open": ["Ordering OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}", "[LinearOrder \u03b1] (x y : \u03b1)", "{x y} {\u03b2 : Type*} [LinearOrder \u03b2] {x' y' : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\nx y : \u03b1\n\u03b2 : Type u_3\ninst\u271d : LinearOrder \u03b2\nx' y' : \u03b2\nh : cmp x y = cmp x' y'\n\u22a2 x < y \u2194 x' < y'"}, {"line": "rw [\u2190 cmp_eq_lt_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\nx y : \u03b1\n\u03b2 : Type u_3\ninst\u271d : LinearOrder \u03b2\nx' y' : \u03b2\nh : cmp x y = cmp x' y'\n\u22a2 cmp x y = lt \u2194 x' < y'"}, {"line": "rw [\u2190 cmp_eq_lt_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\nx y : \u03b1\n\u03b2 : Type u_3\ninst\u271d : LinearOrder \u03b2\nx' y' : \u03b2\nh : cmp x y = cmp x' y'\n\u22a2 cmp x y = lt \u2194 cmp x' y' = lt"}, {"line": "rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sSup_inf_eq : sSup s \u2293 b = \u2a06 a \u2208 s, a \u2293 b := by\n  simpa only [inf_comm] using @inf_sSup_eq \u03b1 _ s b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteBooleanAlgebra.lean", "context": {"open": ["Function Set", "Order"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03ba : \u03b9 \u2192 Sort w'}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1)", "(minAx : MinimalAxioms \u03b1)", "[Frame \u03b1] {s t : Set \u03b1} {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03ba : \u03b9 \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b2 : Set \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b2 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns\u271d t : Set \u03b1\u271d\na b\u271d c d : \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : Frame \u03b1\ns : Set \u03b1\nb : \u03b1\n\u22a2 sSup s \u2293 b = \u2a06 a \u2208 s, a \u2293 b"}, {"line": "simpa only [inf_comm] using @inf_sSup_eq \u03b1 _ s b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_inf_eq (f : \u03b9 \u2192 \u03b1) (a : \u03b1) : (\u2a06 i, f i) \u2293 a = \u2a06 i, f i \u2293 a := by\n  rw [iSup]\n  rw [sSup_inf_eq]\n  rw [iSup_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteBooleanAlgebra.lean", "context": {"open": ["Function Set", "Order"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03ba : \u03b9 \u2192 Sort w'}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1)", "(minAx : MinimalAxioms \u03b1)", "[Frame \u03b1] {s t : Set \u03b1} {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03ba : \u03b9\u271d \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d\u00b2 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d : Set \u03b1\u271d\na\u271d\u00b9 b\u271d : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns t : Set \u03b1\u271d\na\u271d b c d : \u03b1\u271d\n\u03b1 : Type u\n\u03b9 : Sort w\ninst\u271d : Frame \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u03b1\n\u22a2 (\u2a06 i, f i) \u2293 a = \u2a06 i, f i \u2293 a"}, {"line": "rw [iSup]", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03ba : \u03b9\u271d \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d\u00b2 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d : Set \u03b1\u271d\na\u271d\u00b9 b\u271d : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns t : Set \u03b1\u271d\na\u271d b c d : \u03b1\u271d\n\u03b1 : Type u\n\u03b9 : Sort w\ninst\u271d : Frame \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u03b1\n\u22a2 sSup (range fun i => f i) \u2293 a = \u2a06 i, f i \u2293 a"}, {"line": "rw [sSup_inf_eq]", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03ba : \u03b9\u271d \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d\u00b2 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d : Set \u03b1\u271d\na\u271d\u00b9 b\u271d : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns t : Set \u03b1\u271d\na\u271d b c d : \u03b1\u271d\n\u03b1 : Type u\n\u03b9 : Sort w\ninst\u271d : Frame \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u03b1\n\u22a2 \u2a06 a_1 \u2208 range fun i => f i, a_1 \u2293 a = \u2a06 i, f i \u2293 a"}, {"line": "rw [iSup_range]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_iSup_eq (a : \u03b1) (f : \u03b9 \u2192 \u03b1) : (a \u2293 \u2a06 i, f i) = \u2a06 i, a \u2293 f i := by\n  simpa only [inf_comm] using iSup_inf_eq f a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteBooleanAlgebra.lean", "context": {"open": ["Function Set", "Order"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03ba : \u03b9 \u2192 Sort w'}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1)", "(minAx : MinimalAxioms \u03b1)", "[Frame \u03b1] {s t : Set \u03b1} {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03ba : \u03b9\u271d \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d\u00b2 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d : Set \u03b1\u271d\na\u271d\u00b9 b\u271d : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns t : Set \u03b1\u271d\na\u271d b c d : \u03b1\u271d\n\u03b1 : Type u\n\u03b9 : Sort w\ninst\u271d : Frame \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u03b1\n\u22a2 a \u2293 \u2a06 i, f i = \u2a06 i, a \u2293 f i"}, {"line": "simpa only [inf_comm] using iSup_inf_eq f a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup\u2082_inf_eq {f : \u2200 i, \u03ba i \u2192 \u03b1} (a : \u03b1) :\n    (\u2a06 (i) (j), f i j) \u2293 a = \u2a06 (i) (j), f i j \u2293 a := by\n  simp only [iSup_inf_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteBooleanAlgebra.lean", "context": {"open": ["Function Set", "Order"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03ba : \u03b9 \u2192 Sort w'}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1)", "(minAx : MinimalAxioms \u03b1)", "[Frame \u03b1] {s t : Set \u03b1} {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03ba\u271d : \u03b9\u271d \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d\u00b2 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d : Set \u03b1\u271d\na\u271d\u00b9 b\u271d : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns t : Set \u03b1\u271d\na\u271d b c d : \u03b1\u271d\n\u03b1 : Type u\n\u03b9 : Sort w\n\u03ba : \u03b9 \u2192 Sort w'\ninst\u271d : Frame \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 \u03b1\na : \u03b1\n\u22a2 (\u2a06 i, \u2a06 j, f i j) \u2293 a = \u2a06 i, \u2a06 j, f i j \u2293 a"}, {"line": "simp only [iSup_inf_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_iSup\u2082_eq {f : \u2200 i, \u03ba i \u2192 \u03b1} (a : \u03b1) :\n    (a \u2293 \u2a06 (i) (j), f i j) = \u2a06 (i) (j), a \u2293 f i j := by\n  simp only [inf_iSup_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteBooleanAlgebra.lean", "context": {"open": ["Function Set", "Order"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03ba : \u03b9 \u2192 Sort w'}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1)", "(minAx : MinimalAxioms \u03b1)", "[Frame \u03b1] {s t : Set \u03b1} {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03ba\u271d : \u03b9\u271d \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d\u00b2 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d : Set \u03b1\u271d\na\u271d\u00b9 b\u271d : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns t : Set \u03b1\u271d\na\u271d b c d : \u03b1\u271d\n\u03b1 : Type u\n\u03b9 : Sort w\n\u03ba : \u03b9 \u2192 Sort w'\ninst\u271d : Frame \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 \u03b1\na : \u03b1\n\u22a2 a \u2293 \u2a06 i, \u2a06 j, f i j = \u2a06 i, \u2a06 j, a \u2293 f i j"}, {"line": "simp only [inf_iSup_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_inf_iSup {\u03b9 \u03b9' : Type*} {f : \u03b9 \u2192 \u03b1} {g : \u03b9' \u2192 \u03b1} :\n    ((\u2a06 i, f i) \u2293 \u2a06 j, g j) = \u2a06 i : \u03b9 \u00d7 \u03b9', f i.1 \u2293 g i.2 := by\n  simp_rw [iSup_inf_eq, inf_iSup_eq, iSup_prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteBooleanAlgebra.lean", "context": {"open": ["Function Set", "Order"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03ba : \u03b9 \u2192 Sort w'}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1)", "(minAx : MinimalAxioms \u03b1)", "[Frame \u03b1] {s t : Set \u03b1} {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03ba : \u03b9\u271d \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d : Set \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns t : Set \u03b1\u271d\na b c d : \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : Frame \u03b1\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nf : \u03b9 \u2192 \u03b1\ng : \u03b9' \u2192 \u03b1\n\u22a2 (\u2a06 i, f i) \u2293 \u2a06 j, g j = \u2a06 i, f i.1 \u2293 g i.2"}, {"line": "simp_rw [iSup_inf_eq, inf_iSup_eq, iSup_prod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biSup_inf_biSup {\u03b9 \u03b9' : Type*} {f : \u03b9 \u2192 \u03b1} {g : \u03b9' \u2192 \u03b1} {s : Set \u03b9} {t : Set \u03b9'} :\n    ((\u2a06 i \u2208 s, f i) \u2293 \u2a06 j \u2208 t, g j) = \u2a06 p \u2208 s \u00d7\u02e2 t, f (p : \u03b9 \u00d7 \u03b9').1 \u2293 g p.2 := by\n  simp only [iSup_subtype']\n  simp only [iSup_inf_iSup]\n  exact (Equiv.surjective _).iSup_congr (Equiv.Set.prod s t).symm fun x => rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteBooleanAlgebra.lean", "context": {"open": ["Function Set", "Order"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03ba : \u03b9 \u2192 Sort w'}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1)", "(minAx : MinimalAxioms \u03b1)", "[Frame \u03b1] {s t : Set \u03b1} {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03ba : \u03b9\u271d \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b2 : Set \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns\u271d t\u271d : Set \u03b1\u271d\na b c d : \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : Frame \u03b1\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nf : \u03b9 \u2192 \u03b1\ng : \u03b9' \u2192 \u03b1\ns : Set \u03b9\nt : Set \u03b9'\n\u22a2 (\u2a06 i \u2208 s, f i) \u2293 \u2a06 j \u2208 t, g j = \u2a06 p \u2208 s \u00d7\u02e2 t, f p.1 \u2293 g p.2"}, {"line": "simp only [iSup_subtype']", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03ba : \u03b9\u271d \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b2 : Set \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns\u271d t\u271d : Set \u03b1\u271d\na b c d : \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : Frame \u03b1\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nf : \u03b9 \u2192 \u03b1\ng : \u03b9' \u2192 \u03b1\ns : Set \u03b9\nt : Set \u03b9'\n\u22a2 (\u2a06 x, f \u2191x) \u2293 \u2a06 x, g \u2191x = \u2a06 x, f (\u2191x).1 \u2293 g (\u2191x).2"}, {"line": "simp only [iSup_inf_iSup]", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03ba : \u03b9\u271d \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b2 : Set \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns\u271d t\u271d : Set \u03b1\u271d\na b c d : \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : Frame \u03b1\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nf : \u03b9 \u2192 \u03b1\ng : \u03b9' \u2192 \u03b1\ns : Set \u03b9\nt : Set \u03b9'\n\u22a2 \u2a06 i, f \u2191i.1 \u2293 g \u2191i.2 = \u2a06 x, f (\u2191x).1 \u2293 g (\u2191x).2"}, {"line": "exact (Equiv.surjective _).iSup_congr (Equiv.Set.prod s t).symm fun x => rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sSup_inf_sSup : sSup s \u2293 sSup t = \u2a06 p \u2208 s \u00d7\u02e2 t, (p : \u03b1 \u00d7 \u03b1).1 \u2293 p.2 := by\n  simp only [sSup_eq_iSup]\n  simp only [biSup_inf_biSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteBooleanAlgebra.lean", "context": {"open": ["Function Set", "Order"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03ba : \u03b9 \u2192 Sort w'}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1)", "(minAx : MinimalAxioms \u03b1)", "[Frame \u03b1] {s t : Set \u03b1} {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03ba : \u03b9 \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b2 : Set \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns\u271d t\u271d : Set \u03b1\u271d\na b c d : \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : Frame \u03b1\ns t : Set \u03b1\n\u22a2 sSup s \u2293 sSup t = \u2a06 p \u2208 s \u00d7\u02e2 t, p.1 \u2293 p.2"}, {"line": "simp only [sSup_eq_iSup]", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03ba : \u03b9 \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b2 : Set \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns\u271d t\u271d : Set \u03b1\u271d\na b c d : \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : Frame \u03b1\ns t : Set \u03b1\n\u22a2 (\u2a06 a \u2208 s, a) \u2293 \u2a06 a \u2208 t, a = \u2a06 p \u2208 s \u00d7\u02e2 t, p.1 \u2293 p.2"}, {"line": "simp only [biSup_inf_biSup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_iSup_iff {f : \u03b9 \u2192 \u03b1} : Disjoint a (\u2a06 i, f i) \u2194 \u2200 i, Disjoint a (f i) := by\n  simpa only [disjoint_comm] using @iSup_disjoint_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteBooleanAlgebra.lean", "context": {"open": ["Function Set", "Order"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03ba : \u03b9 \u2192 Sort w'}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1)", "(minAx : MinimalAxioms \u03b1)", "[Frame \u03b1] {s t : Set \u03b1} {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03ba : \u03b9\u271d \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d\u00b2 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d : Set \u03b1\u271d\na\u271d\u00b9 b\u271d : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns t : Set \u03b1\u271d\na\u271d b c d : \u03b1\u271d\n\u03b1 : Type u\n\u03b9 : Sort w\ninst\u271d : Frame \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u03b1\n\u22a2 Disjoint a (\u2a06 i, f i) \u2194 \u2200 (i : \u03b9), Disjoint a (f i)"}, {"line": "simpa only [disjoint_comm] using @iSup_disjoint_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup\u2082_disjoint_iff {f : \u2200 i, \u03ba i \u2192 \u03b1} :\n    Disjoint (\u2a06 (i) (j), f i j) a \u2194 \u2200 i j, Disjoint (f i j) a := by\n  simp_rw [iSup_disjoint_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteBooleanAlgebra.lean", "context": {"open": ["Function Set", "Order"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03ba : \u03b9 \u2192 Sort w'}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1)", "(minAx : MinimalAxioms \u03b1)", "[Frame \u03b1] {s t : Set \u03b1} {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03ba\u271d : \u03b9\u271d \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d\u00b2 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d : Set \u03b1\u271d\na\u271d\u00b9 b\u271d : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns t : Set \u03b1\u271d\na\u271d b c d : \u03b1\u271d\n\u03b1 : Type u\n\u03b9 : Sort w\n\u03ba : \u03b9 \u2192 Sort w'\ninst\u271d : Frame \u03b1\na : \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 \u03b1\n\u22a2 Disjoint (\u2a06 i, \u2a06 j, f i j) a \u2194 \u2200 (i : \u03b9) (j : \u03ba i), Disjoint (f i j) a"}, {"line": "simp_rw [iSup_disjoint_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_iSup\u2082_iff {f : \u2200 i, \u03ba i \u2192 \u03b1} :\n    Disjoint a (\u2a06 (i) (j), f i j) \u2194 \u2200 i j, Disjoint a (f i j) := by\n  simp_rw [disjoint_iSup_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteBooleanAlgebra.lean", "context": {"open": ["Function Set", "Order"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03ba : \u03b9 \u2192 Sort w'}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1)", "(minAx : MinimalAxioms \u03b1)", "[Frame \u03b1] {s t : Set \u03b1} {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03ba\u271d : \u03b9\u271d \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d\u00b2 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d : Set \u03b1\u271d\na\u271d\u00b9 b\u271d : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns t : Set \u03b1\u271d\na\u271d b c d : \u03b1\u271d\n\u03b1 : Type u\n\u03b9 : Sort w\n\u03ba : \u03b9 \u2192 Sort w'\ninst\u271d : Frame \u03b1\na : \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 \u03b1\n\u22a2 Disjoint a (\u2a06 i, \u2a06 j, f i j) \u2194 \u2200 (i : \u03b9) (j : \u03ba i), Disjoint a (f i j)"}, {"line": "simp_rw [disjoint_iSup_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_sSup_iff {s : Set \u03b1} : Disjoint a (sSup s) \u2194 \u2200 b \u2208 s, Disjoint a b := by\n  simpa only [disjoint_comm] using @sSup_disjoint_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteBooleanAlgebra.lean", "context": {"open": ["Function Set", "Order"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03ba : \u03b9 \u2192 Sort w'}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1)", "(minAx : MinimalAxioms \u03b1)", "[Frame \u03b1] {s t : Set \u03b1} {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03ba : \u03b9 \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b2 : Set \u03b1\u271d\na\u271d\u00b2 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d\u00b9 b\u271d : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns\u271d t : Set \u03b1\u271d\na\u271d b c d : \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : Frame \u03b1\na : \u03b1\ns : Set \u03b1\n\u22a2 Disjoint a (sSup s) \u2194 \u2200 b \u2208 s, Disjoint a b"}, {"line": "simpa only [disjoint_comm] using @sSup_disjoint_iff", "tactic_state": "No Goals!"}]}
{"declaration": "lemma himp_le_iff : a \u21e8 b \u2264 c \u2194 \u2200 d, d \u2293 a \u2264 b \u2192 d \u2264 c := by simp [himp_eq_sSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteBooleanAlgebra.lean", "context": {"open": ["Function Set", "Order"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03ba : \u03b9 \u2192 Sort w'}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1)", "(minAx : MinimalAxioms \u03b1)", "[Frame \u03b1] {s t : Set \u03b1} {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MinimalAxioms : ?m.4873\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03ba : \u03b9 \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u00b9 : Set \u03b1\u271d\na\u271d\u00b2 b\u271d\u00b2 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d : Set \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u00b9 : Frame \u03b1\u271d\ns t : Set \u03b1\u271d\na\u271d b\u271d c\u271d d : \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : Frame \u03b1\na b c : \u03b1\n\u22a2 a \u21e8 b \u2264 c \u2194 \u2200 (d : \u03b1), d \u2293 a \u2264 b \u2192 d \u2264 c"}, {"line": "simp [himp_eq_sSup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_sInf : (sInf s)\u1d9c = \u2a06 i \u2208 s, i\u1d9c := by simp only [sInf_eq_iInf, compl_iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteBooleanAlgebra.lean", "context": {"open": ["Function Set", "Order"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03ba : \u03b9 \u2192 Sort w'}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1)", "(minAx : MinimalAxioms \u03b1)", "[Frame \u03b1] {s t : Set \u03b1} {a b c d : \u03b1}", "[Coframe \u03b1] {s t : Set \u03b1} {a b c d : \u03b1}", "[CompleteDistribLattice \u03b1]", "[CompleteBooleanAlgebra \u03b1] {s : Set \u03b1} {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MinimalAxioms : ?m.10085\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03ba : \u03b9 \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u2074 : Set \u03b1\u271d\na\u271d\u00b2 b\u271d\u00b2 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d\u00b3 : Set \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u2077 : Frame \u03b1\u271d\ns\u271d\u00b2 t\u271d : Set \u03b1\u271d\na\u271d b\u271d c\u271d d\u271d : \u03b1\u271d\ninst\u271d\u2076 : Coframe \u03b1\u271d\ns\u271d\u00b9 t : Set \u03b1\u271d\na b c d : \u03b1\u271d\ninst\u271d\u2075 : CompleteDistribLattice \u03b1\u271d\ninst\u271d\u2074 : CompleteBooleanAlgebra \u03b1\u271d\ns\u271d : Set \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d\u00b3 : Frame \u03b1\ninst\u271d\u00b2 : Coframe \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\ns : Set \u03b1\n\u22a2 (sInf s)\u1d9c = \u2a06 i \u2208 s, i\u1d9c"}, {"line": "simp only [sInf_eq_iInf, compl_iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_sSup : (sSup s)\u1d9c = \u2a05 i \u2208 s, i\u1d9c := by simp only [sSup_eq_iSup, compl_iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteBooleanAlgebra.lean", "context": {"open": ["Function Set", "Order"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03ba : \u03b9 \u2192 Sort w'}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1) {s : Set \u03b1} {a b : \u03b1}", "(minAx : MinimalAxioms \u03b1)", "(minAx : MinimalAxioms \u03b1)", "[Frame \u03b1] {s t : Set \u03b1} {a b c d : \u03b1}", "[Coframe \u03b1] {s t : Set \u03b1} {a b c d : \u03b1}", "[CompleteDistribLattice \u03b1]", "[CompleteBooleanAlgebra \u03b1] {s : Set \u03b1} {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "MinimalAxioms : ?m.10085\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03ba : \u03b9 \u2192 Sort w'\nminAx\u271d\u00b2 : sorry\ns\u271d\u2074 : Set \u03b1\u271d\na\u271d\u00b2 b\u271d\u00b2 : \u03b1\u271d\nminAx\u271d\u00b9 : sorry\ns\u271d\u00b3 : Set \u03b1\u271d\na\u271d\u00b9 b\u271d\u00b9 : \u03b1\u271d\nminAx\u271d : sorry\nminAx : sorry\ninst\u271d\u2077 : Frame \u03b1\u271d\ns\u271d\u00b2 t\u271d : Set \u03b1\u271d\na\u271d b\u271d c\u271d d\u271d : \u03b1\u271d\ninst\u271d\u2076 : Coframe \u03b1\u271d\ns\u271d\u00b9 t : Set \u03b1\u271d\na b c d : \u03b1\u271d\ninst\u271d\u2075 : CompleteDistribLattice \u03b1\u271d\ninst\u271d\u2074 : CompleteBooleanAlgebra \u03b1\u271d\ns\u271d : Set \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d\u00b3 : Frame \u03b1\ninst\u271d\u00b2 : Coframe \u03b1\ninst\u271d\u00b9 : CompleteDistribLattice \u03b1\ninst\u271d : CompleteBooleanAlgebra \u03b1\ns : Set \u03b1\n\u22a2 (sSup s)\u1d9c = \u2a05 i \u2208 s, i\u1d9c"}, {"line": "simp only [sSup_eq_iSup, compl_iSup]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isComplemented_iff : ComplementedLattice L \u2194 \u2200 a \u2208 L, \u2203 b \u2208 L, IsCompl a b := by\n  refine \u27e8fun \u27e8h\u27e9 a ha \u21a6 ?_, fun h \u21a6 \u27e8fun \u27e8a, ha\u27e9 \u21a6 ?_\u27e9\u27e9\n  \u00b7 obtain \u27e8b, hb\u27e9 := h \u27e8a, ha\u27e9\n    exact \u27e8b, b.property, CompleteSublattice.isCompl_iff.mp hb\u27e9\n  \u00b7 obtain \u27e8b, hb, hb'\u27e9 := h a ha\n    exact \u27e8\u27e8b, hb\u27e9, CompleteSublattice.isCompl_iff.mpr hb'\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteSublattice.lean", "context": {"open": ["Function Set"], "variables": ["(\u03b1 \u03b2 : Type*) [CompleteLattice \u03b1] [CompleteLattice \u03b2] (f : CompleteLatticeHom \u03b1 \u03b2)", "{\u03b1 \u03b2}", "{L : CompleteSublattice \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nL : CompleteSublattice \u03b1\n\u22a2 ComplementedLattice \u21a5L \u2194 \u2200 a \u2208 L, \u2203 b \u2208 L, IsCompl a b"}, {"line": "refine \u27e8fun \u27e8h\u27e9 a ha \u21a6 ?_, fun h \u21a6 \u27e8fun \u27e8a, ha\u27e9 \u21a6 ?_\u27e9\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nL : CompleteSublattice \u03b1\nx\u271d : ComplementedLattice \u21a5L\na : \u03b1\nha : a \u2208 L\nh : \u2200 (a : \u21a5L), \u2203 b, IsCompl a b\n\u22a2 \u2203 b \u2208 L, IsCompl a b\n---\ncase refine_2\n\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nL : CompleteSublattice \u03b1\nh : \u2200 a \u2208 L, \u2203 b \u2208 L, IsCompl a b\nx\u271d : \u21a5L\na : \u03b1\nha : a \u2208 L\n\u22a2 \u2203 b, IsCompl \u27e8a, ha\u27e9 b"}, {"line": "\u00b7 obtain \u27e8b, hb\u27e9 := h \u27e8a, ha\u27e9\n    exact \u27e8b, b.property, CompleteSublattice.isCompl_iff.mp hb\u27e9", "tactic_state": "case refine_2\n\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nL : CompleteSublattice \u03b1\nh : \u2200 a \u2208 L, \u2203 b \u2208 L, IsCompl a b\nx\u271d : \u21a5L\na : \u03b1\nha : a \u2208 L\n\u22a2 \u2203 b, IsCompl \u27e8a, ha\u27e9 b"}, {"line": "\u00b7 obtain \u27e8b, hb, hb'\u27e9 := h a ha\n    exact \u27e8\u27e8b, hb\u27e9, CompleteSublattice.isCompl_iff.mpr hb'\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ext (h : c.fst = d.fst) : c = d := by\n  obtain \u27e8\u27e8s\u2081, t\u2081\u27e9, h\u2081, _\u27e9 := c\n  obtain \u27e8\u27e8s\u2082, t\u2082\u27e9, h\u2082, _\u27e9 := d\n  dsimp at h\u2081 h\u2082 h\n  substs h h\u2081 h\u2082\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Concept.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*} {\u03ba : \u03b9 \u2192 Sort*} (r : \u03b1 \u2192 \u03b2 \u2192 Prop) {s : Set \u03b1} {t : Set \u03b2}", "{r}", "(r)", "(\u03b1 \u03b2)", "{r \u03b1 \u03b2}", "{c d : Concept \u03b1 \u03b2 r}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\nc d : Concept \u03b1 \u03b2 r\nh : c.toProd.1 = d.toProd.1\n\u22a2 c = d"}, {"line": "obtain \u27e8\u27e8s\u2081, t\u2081\u27e9, h\u2081, _\u27e9 := c", "tactic_state": "case mk.mk\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\nd : Concept \u03b1 \u03b2 r\ns\u2081 : Set \u03b1\nt\u2081 : Set \u03b2\nh\u2081 : intentClosure r (s\u2081, t\u2081).1 = (s\u2081, t\u2081).2\nclosure_snd\u271d : extentClosure r (s\u2081, t\u2081).2 = (s\u2081, t\u2081).1\nh : { fst := s\u2081, snd := t\u2081, closure_fst := h\u2081, closure_snd := closure_snd\u271d }.toProd.1 = d.toProd.1\n\u22a2 { fst := s\u2081, snd := t\u2081, closure_fst := h\u2081, closure_snd := closure_snd\u271d } = d"}, {"line": "obtain \u27e8\u27e8s\u2082, t\u2082\u27e9, h\u2082, _\u27e9 := d", "tactic_state": "case mk.mk.mk.mk\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\ns\u2081 : Set \u03b1\nt\u2081 : Set \u03b2\nh\u2081 : intentClosure r (s\u2081, t\u2081).1 = (s\u2081, t\u2081).2\nclosure_snd\u271d\u00b9 : extentClosure r (s\u2081, t\u2081).2 = (s\u2081, t\u2081).1\ns\u2082 : Set \u03b1\nt\u2082 : Set \u03b2\nh\u2082 : intentClosure r (s\u2082, t\u2082).1 = (s\u2082, t\u2082).2\nclosure_snd\u271d : extentClosure r (s\u2082, t\u2082).2 = (s\u2082, t\u2082).1\nh :\n  { fst := s\u2081, snd := t\u2081, closure_fst := h\u2081, closure_snd := closure_snd\u271d\u00b9 }.toProd.1 =\n    { fst := s\u2082, snd := t\u2082, closure_fst := h\u2082, closure_snd := closure_snd\u271d }.toProd.1\n\u22a2 { fst := s\u2081, snd := t\u2081, closure_fst := h\u2081, closure_snd := closure_snd\u271d\u00b9 } =\n    { fst := s\u2082, snd := t\u2082, closure_fst := h\u2082, closure_snd := closure_snd\u271d }"}, {"line": "dsimp at h\u2081 h\u2082 h", "tactic_state": "case mk.mk.mk.mk\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\ns\u2081 : Set \u03b1\nt\u2081 : Set \u03b2\nh\u2081 : intentClosure r s\u2081 = t\u2081\nclosure_snd\u271d\u00b9 : extentClosure r (s\u2081, t\u2081).2 = (s\u2081, t\u2081).1\ns\u2082 : Set \u03b1\nt\u2082 : Set \u03b2\nh\u2082 : intentClosure r s\u2082 = t\u2082\nclosure_snd\u271d : extentClosure r (s\u2082, t\u2082).2 = (s\u2082, t\u2082).1\nh : s\u2081 = s\u2082\n\u22a2 { fst := s\u2081, snd := t\u2081, closure_fst := h\u2081, closure_snd := closure_snd\u271d\u00b9 } =\n    { fst := s\u2082, snd := t\u2082, closure_fst := h\u2082, closure_snd := closure_snd\u271d }"}, {"line": "substs h h\u2081 h\u2082", "tactic_state": "case mk.mk.mk.mk\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\ns\u2081 : Set \u03b1\nclosure_snd\u271d\u00b9 closure_snd\u271d : extentClosure r (s\u2081, intentClosure r s\u2081).2 = (s\u2081, intentClosure r s\u2081).1\n\u22a2 { fst := s\u2081, snd := intentClosure r s\u2081, closure_fst := \u22ef, closure_snd := closure_snd\u271d\u00b9 } =\n    { fst := s\u2081, snd := intentClosure r s\u2081, closure_fst := \u22ef, closure_snd := closure_snd\u271d }"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ext' (h : c.snd = d.snd) : c = d := by\n  obtain \u27e8\u27e8s\u2081, t\u2081\u27e9, _, h\u2081\u27e9 := c\n  obtain \u27e8\u27e8s\u2082, t\u2082\u27e9, _, h\u2082\u27e9 := d\n  dsimp at h\u2081 h\u2082 h\n  substs h h\u2081 h\u2082\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Concept.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*} {\u03ba : \u03b9 \u2192 Sort*} (r : \u03b1 \u2192 \u03b2 \u2192 Prop) {s : Set \u03b1} {t : Set \u03b2}", "{r}", "(r)", "(\u03b1 \u03b2)", "{r \u03b1 \u03b2}", "{c d : Concept \u03b1 \u03b2 r}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\nc d : Concept \u03b1 \u03b2 r\nh : c.toProd.2 = d.toProd.2\n\u22a2 c = d"}, {"line": "obtain \u27e8\u27e8s\u2081, t\u2081\u27e9, _, h\u2081\u27e9 := c", "tactic_state": "case mk.mk\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\nd : Concept \u03b1 \u03b2 r\ns\u2081 : Set \u03b1\nt\u2081 : Set \u03b2\nclosure_fst\u271d : intentClosure r (s\u2081, t\u2081).1 = (s\u2081, t\u2081).2\nh\u2081 : extentClosure r (s\u2081, t\u2081).2 = (s\u2081, t\u2081).1\nh : { fst := s\u2081, snd := t\u2081, closure_fst := closure_fst\u271d, closure_snd := h\u2081 }.toProd.2 = d.toProd.2\n\u22a2 { fst := s\u2081, snd := t\u2081, closure_fst := closure_fst\u271d, closure_snd := h\u2081 } = d"}, {"line": "obtain \u27e8\u27e8s\u2082, t\u2082\u27e9, _, h\u2082\u27e9 := d", "tactic_state": "case mk.mk.mk.mk\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\ns\u2081 : Set \u03b1\nt\u2081 : Set \u03b2\nclosure_fst\u271d\u00b9 : intentClosure r (s\u2081, t\u2081).1 = (s\u2081, t\u2081).2\nh\u2081 : extentClosure r (s\u2081, t\u2081).2 = (s\u2081, t\u2081).1\ns\u2082 : Set \u03b1\nt\u2082 : Set \u03b2\nclosure_fst\u271d : intentClosure r (s\u2082, t\u2082).1 = (s\u2082, t\u2082).2\nh\u2082 : extentClosure r (s\u2082, t\u2082).2 = (s\u2082, t\u2082).1\nh :\n  { fst := s\u2081, snd := t\u2081, closure_fst := closure_fst\u271d\u00b9, closure_snd := h\u2081 }.toProd.2 =\n    { fst := s\u2082, snd := t\u2082, closure_fst := closure_fst\u271d, closure_snd := h\u2082 }.toProd.2\n\u22a2 { fst := s\u2081, snd := t\u2081, closure_fst := closure_fst\u271d\u00b9, closure_snd := h\u2081 } =\n    { fst := s\u2082, snd := t\u2082, closure_fst := closure_fst\u271d, closure_snd := h\u2082 }"}, {"line": "dsimp at h\u2081 h\u2082 h", "tactic_state": "case mk.mk.mk.mk\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\ns\u2081 : Set \u03b1\nt\u2081 : Set \u03b2\nclosure_fst\u271d\u00b9 : intentClosure r (s\u2081, t\u2081).1 = (s\u2081, t\u2081).2\nh\u2081 : extentClosure r t\u2081 = s\u2081\ns\u2082 : Set \u03b1\nt\u2082 : Set \u03b2\nclosure_fst\u271d : intentClosure r (s\u2082, t\u2082).1 = (s\u2082, t\u2082).2\nh\u2082 : extentClosure r t\u2082 = s\u2082\nh : t\u2081 = t\u2082\n\u22a2 { fst := s\u2081, snd := t\u2081, closure_fst := closure_fst\u271d\u00b9, closure_snd := h\u2081 } =\n    { fst := s\u2082, snd := t\u2082, closure_fst := closure_fst\u271d, closure_snd := h\u2082 }"}, {"line": "substs h h\u2081 h\u2082", "tactic_state": "case mk.mk.mk.mk\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\nt\u2081 : Set \u03b2\nclosure_fst\u271d\u00b9 closure_fst\u271d : intentClosure r (extentClosure r t\u2081, t\u2081).1 = (extentClosure r t\u2081, t\u2081).2\n\u22a2 { fst := extentClosure r t\u2081, snd := t\u2081, closure_fst := closure_fst\u271d\u00b9, closure_snd := \u22ef } =\n    { fst := extentClosure r t\u2081, snd := t\u2081, closure_fst := closure_fst\u271d, closure_snd := \u22ef }"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_wcovBy_iff (h : a \u2264 b) : \u00aca \u2a7f b \u2194 \u2203 c, a < c \u2227 c < b := by\n  simp_rw [WCovBy, h, true_and, not_forall, exists_prop, not_not]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Cover.lean", "context": {"open": ["Set OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na b : \u03b1\nh : a \u2264 b\n\u22a2 \u00aca \u2a7f b \u2194 \u2203 c, a < c \u2227 c < b"}, {"line": "simp_rw [WCovBy, h, true_and, not_forall, exists_prop, not_not]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_covBy_iff (h : a < b) : \u00aca \u22d6 b \u2194 \u2203 c, a < c \u2227 c < b := by\n  simp_rw [CovBy, h, true_and, not_forall, exists_prop, not_not]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Cover.lean", "context": {"open": ["Set OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2] {a b c : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}", "[SemilatticeSup \u03b1] {a b c : \u03b1}", "[SemilatticeInf \u03b1] {a b c : \u03b1}", "[LT \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : LT \u03b1\na b : \u03b1\nh : a < b\n\u22a2 \u00aca \u22d6 b \u2194 \u2203 c, a < c \u2227 c < b"}, {"line": "simp_rw [CovBy, h, true_and, not_forall, exists_prop, not_not]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem wcovBy_iff_covBy_or_eq : a \u2a7f b \u2194 a \u22d6 b \u2228 a = b := by\n  rw [le_antisymm_iff]\n  rw [wcovBy_iff_covBy_or_le_and_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Cover.lean", "context": {"open": ["Set OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2] {a b c : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}", "[SemilatticeSup \u03b1] {a b c : \u03b1}", "[SemilatticeInf \u03b1] {a b c : \u03b1}", "[LT \u03b1] {a b : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {a b c : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : SemilatticeSup \u03b1\ninst\u271d\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\n\u22a2 a \u2a7f b \u2194 a \u22d6 b \u2228 a = b"}, {"line": "rw [le_antisymm_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : SemilatticeSup \u03b1\ninst\u271d\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\n\u22a2 a \u2a7f b \u2194 a \u22d6 b \u2228 a \u2264 b \u2227 b \u2264 a\n---\n\u03b1 : Type u_1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : SemilatticeSup \u03b1\ninst\u271d\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\n\u22a2 PartialOrder \u03b1"}, {"line": "rw [wcovBy_iff_covBy_or_le_and_le]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : SemilatticeSup \u03b1\ninst\u271d\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\n\u22a2 a \u22d6 b \u2228 a \u2264 b \u2227 b \u2264 a \u2194 a \u22d6 b \u2228 a \u2264 b \u2227 b \u2264 a\n---\n\u03b1 : Type u_1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : SemilatticeSup \u03b1\ninst\u271d\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b2 : LT \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\n\u22a2 PartialOrder \u03b1"}]}
{"declaration": "theorem covBy_iff_lt_iff_le_right {x y : \u03b1} : x \u22d6 y \u2194 \u2200 {z}, x < z \u2194 y \u2264 z := by\n  trans \u2200 {z}, \u00ac z \u2264 x \u2194 \u00ac z < y\n  \u00b7 simp_rw [covBy_iff_le_iff_lt_left, not_iff_not]\n  \u00b7 simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Cover.lean", "context": {"open": ["Set OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2] {a b c : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}", "[SemilatticeSup \u03b1] {a b c : \u03b1}", "[SemilatticeInf \u03b1] {a b c : \u03b1}", "[LT \u03b1] {a b : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {a b c : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}", "[LinearOrder \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : SemilatticeSup \u03b1\ninst\u271d\u2074 : SemilatticeInf \u03b1\ninst\u271d\u00b3 : LT \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : LinearOrder \u03b1\nx y : \u03b1\n\u22a2 x \u22d6 y \u2194 \u2200 {z : \u03b1}, x < z \u2194 y \u2264 z"}, {"line": "trans \u2200 {z}, \u00ac z \u2264 x \u2194 \u00ac z < y", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : SemilatticeSup \u03b1\ninst\u271d\u2074 : SemilatticeInf \u03b1\ninst\u271d\u00b3 : LT \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : LinearOrder \u03b1\nx y : \u03b1\n\u22a2 x \u22d6 y \u2194 \u2200 {z : \u03b1}, \u00acsorry \u2194 \u00acsorry\n---\n\u03b1 : Type u_1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : SemilatticeSup \u03b1\ninst\u271d\u2074 : SemilatticeInf \u03b1\ninst\u271d\u00b3 : LT \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : LinearOrder \u03b1\nx y : \u03b1\n\u22a2 (\u2200 {z : \u03b1}, \u00acsorry \u2194 \u00acsorry) \u2194 \u2200 {z : \u03b1}, x < z \u2194 y \u2264 z"}, {"line": "\u00b7 simp_rw [covBy_iff_le_iff_lt_left, not_iff_not]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : SemilatticeSup \u03b1\ninst\u271d\u2074 : SemilatticeInf \u03b1\ninst\u271d\u00b3 : LT \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : LinearOrder \u03b1\nx y : \u03b1\n\u22a2 (\u2200 {z : \u03b1}, \u00acsorry \u2194 \u00acsorry) \u2194 \u2200 {z : \u03b1}, x < z \u2194 y \u2264 z"}, {"line": "\u00b7 simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem wcovBy_iff : x \u2a7f y \u2194 x.1 \u2a7f y.1 \u2227 x.2 = y.2 \u2228 x.2 \u2a7f y.2 \u2227 x.1 = y.1 := by\n  cases x\n  cases y\n  exact mk_wcovBy_mk_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Cover.lean", "context": {"open": ["Set OrderDual", "Relation"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2] {a b c : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}", "[SemilatticeSup \u03b1] {a b c : \u03b1}", "[SemilatticeInf \u03b1] {a b c : \u03b1}", "[LT \u03b1] {a b : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {a b c : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}", "[LinearOrder \u03b1] {a b c : \u03b1}", "{s t : Set \u03b1} {a : \u03b1}", "[PartialOrder \u03b1] [PartialOrder \u03b2] {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2} {x y : \u03b1 \u00d7 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b2\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : SemilatticeSup \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nx y : \u03b1 \u00d7 \u03b2\n\u22a2 x \u2a7f y \u2194 x.1 \u2a7f y.1 \u2227 x.2 = y.2 \u2228 x.2 \u2a7f y.2 \u2227 x.1 = y.1"}, {"line": "cases x", "tactic_state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b2\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : SemilatticeSup \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PartialOrder \u03b2\ny : \u03b1 \u00d7 \u03b2\nfst\u271d : \u03b1\nsnd\u271d : \u03b2\n\u22a2 (fst\u271d, snd\u271d) \u2a7f y \u2194 (fst\u271d, snd\u271d).1 \u2a7f y.1 \u2227 (fst\u271d, snd\u271d).2 = y.2 \u2228 (fst\u271d, snd\u271d).2 \u2a7f y.2 \u2227 (fst\u271d, snd\u271d).1 = y.1"}, {"line": "cases y", "tactic_state": "case mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b2\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : SemilatticeSup \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nfst\u271d\u00b9 : \u03b1\nsnd\u271d\u00b9 : \u03b2\nfst\u271d : \u03b1\nsnd\u271d : \u03b2\n\u22a2 (fst\u271d\u00b9, snd\u271d\u00b9) \u2a7f (fst\u271d, snd\u271d) \u2194\n    (fst\u271d\u00b9, snd\u271d\u00b9).1 \u2a7f (fst\u271d, snd\u271d).1 \u2227 (fst\u271d\u00b9, snd\u271d\u00b9).2 = (fst\u271d, snd\u271d).2 \u2228\n      (fst\u271d\u00b9, snd\u271d\u00b9).2 \u2a7f (fst\u271d, snd\u271d).2 \u2227 (fst\u271d\u00b9, snd\u271d\u00b9).1 = (fst\u271d, snd\u271d).1"}, {"line": "exact mk_wcovBy_mk_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem covBy_iff : x \u22d6 y \u2194 x.1 \u22d6 y.1 \u2227 x.2 = y.2 \u2228 x.2 \u22d6 y.2 \u2227 x.1 = y.1 := by\n  cases x\n  cases y\n  exact mk_covBy_mk_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Cover.lean", "context": {"open": ["Set OrderDual", "Relation"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2] {a b c : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}", "[SemilatticeSup \u03b1] {a b c : \u03b1}", "[SemilatticeInf \u03b1] {a b c : \u03b1}", "[LT \u03b1] {a b : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {a b c : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}", "[LinearOrder \u03b1] {a b c : \u03b1}", "{s t : Set \u03b1} {a : \u03b1}", "[PartialOrder \u03b1] [PartialOrder \u03b2] {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2} {x y : \u03b1 \u00d7 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b2\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : SemilatticeSup \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nx y : \u03b1 \u00d7 \u03b2\n\u22a2 x \u22d6 y \u2194 x.1 \u22d6 y.1 \u2227 x.2 = y.2 \u2228 x.2 \u22d6 y.2 \u2227 x.1 = y.1"}, {"line": "cases x", "tactic_state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b2\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : SemilatticeSup \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PartialOrder \u03b2\ny : \u03b1 \u00d7 \u03b2\nfst\u271d : \u03b1\nsnd\u271d : \u03b2\n\u22a2 (fst\u271d, snd\u271d) \u22d6 y \u2194 (fst\u271d, snd\u271d).1 \u22d6 y.1 \u2227 (fst\u271d, snd\u271d).2 = y.2 \u2228 (fst\u271d, snd\u271d).2 \u22d6 y.2 \u2227 (fst\u271d, snd\u271d).1 = y.1"}, {"line": "cases y", "tactic_state": "case mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b2\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : SemilatticeSup \u03b1\ninst\u271d\u2077 : SemilatticeInf \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nfst\u271d\u00b9 : \u03b1\nsnd\u271d\u00b9 : \u03b2\nfst\u271d : \u03b1\nsnd\u271d : \u03b2\n\u22a2 (fst\u271d\u00b9, snd\u271d\u00b9) \u22d6 (fst\u271d, snd\u271d) \u2194\n    (fst\u271d\u00b9, snd\u271d\u00b9).1 \u22d6 (fst\u271d, snd\u271d).1 \u2227 (fst\u271d\u00b9, snd\u271d\u00b9).2 = (fst\u271d, snd\u271d).2 \u2228\n      (fst\u271d\u00b9, snd\u271d\u00b9).2 \u22d6 (fst\u271d, snd\u271d).2 \u2227 (fst\u271d\u00b9, snd\u271d\u00b9).1 = (fst\u271d, snd\u271d).1"}, {"line": "exact mk_covBy_mk_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem piEquivSucc_self {x} :\n    piEquivSucc equiv e hi \u27e8_, le_rfl\u27e9 x \u27e8i, lt_succ_of_not_isMax hi\u27e9 = (e x).2 := by\n  simp [piEquivSucc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/DirectedInverseSystem.lean", "context": {"open": ["Order Set", "DirectedSystem"], "variables": ["{\u03b9 : Type*} [Preorder \u03b9] {F\u2081 F\u2082 F X : \u03b9 \u2192 Type*}", "(F) in", "{T\u2081 : \u2200 \u2983i j : \u03b9\u2984, i \u2264 j \u2192 Sort*} (f\u2081 : \u2200 i j (h : i \u2264 j), T\u2081 h)", "[\u2200 \u2983i j\u2984 (h : i \u2264 j), FunLike (T\u2081 h) (F\u2081 i) (F\u2081 j)] [DirectedSystem F\u2081 (f\u2081 \u00b7 \u00b7 \u00b7)]", "{T\u2082 : \u2200 \u2983i j : \u03b9\u2984, i \u2264 j \u2192 Sort*} (f\u2082 : \u2200 i j (h : i \u2264 j), T\u2082 h)", "[\u2200 \u2983i j\u2984 (h : i \u2264 j), FunLike (T\u2082 h) (F\u2082 i) (F\u2082 j)] [DirectedSystem F\u2082 (f\u2082 \u00b7 \u00b7 \u00b7)]", "{T : \u2200 \u2983i j : \u03b9\u2984, i \u2264 j \u2192 Sort*} (f : \u2200 i j (h : i \u2264 j), T h)", "[\u2200 \u2983i j\u2984 (h : i \u2264 j), FunLike (T h) (F i) (F j)] [DirectedSystem F (f \u00b7 \u00b7 \u00b7)]", "[IsDirected \u03b9 (\u00b7 \u2264 \u00b7)]", "(F) in", "{f} in", "[Nonempty \u03b9] (ih : \u2200 i, F i)", "{C : Sort*} (ih : \u2200 i, F i \u2192 C) (compat : \u2200 i j h x, ih i x = ih j (f i j h x))", "(ih : \u2200 i, F\u2081 i \u2192 F\u2082 i) (compat : \u2200 i j h x, f\u2082 i j h (ih i x) = ih j (f\u2081 i j h x))", "{C : Sort*} (ih : \u2200 i, F\u2081 i \u2192 F\u2082 i \u2192 C)", "(ih : \u2200 i, F\u2081 i \u2192 F\u2082 i \u2192 F i)", "(f : \u2200 \u2983i j : \u03b9\u2984, i \u2264 j \u2192 F j \u2192 F i) \u2983i j : \u03b9\u2984 (h : i \u2264 j)", "{\u03b9 : Type*} [LinearOrder \u03b9] {X : \u03b9 \u2192 Type*} {i : \u03b9} (hi : IsSuccPrelimit i)", "{\u03b9 : Type*} {F X : \u03b9 \u2192 Type*} {i : \u03b9}", "[PartialOrder \u03b9] [DecidableEq \u03b9]", "[LinearOrder \u03b9] {f : \u2200 \u2983i j : \u03b9\u2984, i \u2264 j \u2192 F j \u2192 F i}", "[SuccOrder \u03b9]", "(equiv : \u2200 j : Iic i, F j \u2243 piLT X j) (e : F i\u207a \u2243 F i \u00d7 X i) (hi : \u00ac IsMax i)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T\u2081 : ?m.77894\nf\u2081 : ?m.78314\npiLT : ?m.81137\n\u03b9\u271d\u00b2 : Type u_1\ninst\u271d\u00b9\u2076 : Preorder \u03b9\u271d\u00b2\nF\u2081 : \u03b9\u271d\u00b2 \u2192 Type u_2\nF\u2082 : \u03b9\u271d\u00b2 \u2192 Type u_3\nF\u271d\u00b9 : \u03b9\u271d\u00b2 \u2192 Type u_4\nX\u271d\u00b2 : \u03b9\u271d\u00b2 \u2192 Type u_5\ninst\u271d\u00b9\u2075 : \u2983i j : \u03b9\u271d\u00b2\u2984 \u2192 i \u2264 j \u2192 FunLike sorry (F\u2081 i) (F\u2081 j)\ninst\u271d\u00b9\u2074 : DirectedSystem F\u2081 fun x1 x2 x3 => sorry\nT\u2082 : \u2983i j : \u03b9\u271d\u00b2\u2984 \u2192 i \u2264 j \u2192 Sort u_6\nf\u2082 : (i j : \u03b9\u271d\u00b2) \u2192 (h : i \u2264 j) \u2192 T\u2082 h\ninst\u271d\u00b9\u00b3 : \u2983i j : \u03b9\u271d\u00b2\u2984 \u2192 (h : i \u2264 j) \u2192 FunLike (T\u2082 h) (F\u2082 i) (F\u2082 j)\ninst\u271d\u00b9\u00b2 : DirectedSystem F\u2082 fun x1 x2 x3 => \u21d1(f\u2082 x1 x2 x3)\nT : \u2983i j : \u03b9\u271d\u00b2\u2984 \u2192 i \u2264 j \u2192 Sort u_7\nf\u271d\u00b9 : (i j : \u03b9\u271d\u00b2) \u2192 (h : i \u2264 j) \u2192 T h\ninst\u271d\u00b9\u00b9 : \u2983i j : \u03b9\u271d\u00b2\u2984 \u2192 (h : i \u2264 j) \u2192 FunLike (T h) (F\u271d\u00b9 i) (F\u271d\u00b9 j)\ninst\u271d\u00b9\u2070 : DirectedSystem F\u271d\u00b9 fun x1 x2 x3 => \u21d1(f\u271d\u00b9 x1 x2 x3)\ninst\u271d\u2079 : IsDirected \u03b9\u271d\u00b2 fun x1 x2 => x1 \u2264 x2\nC\u271d : Sort u_8\nih\u271d\u00b2 : (i : \u03b9\u271d\u00b2) \u2192 F\u271d\u00b9 i \u2192 C\u271d\ncompat\u271d : \u2200 (i j : \u03b9\u271d\u00b2) (h : i \u2264 j) (x : F\u271d\u00b9 i), ih\u271d\u00b2 i x = ih\u271d\u00b2 j ((f\u271d\u00b9 i j h) x)\nih\u271d\u00b9 : (i : \u03b9\u271d\u00b2) \u2192 F\u2081 i \u2192 F\u2082 i\ncompat : \u2200 (i j : \u03b9\u271d\u00b2) (h : i \u2264 j) (x : F\u2081 i), (f\u2082 i j h) (ih\u271d\u00b9 i x) = ih\u271d\u00b9 j sorry\nC : Sort u_9\nih\u271d : (i : \u03b9\u271d\u00b2) \u2192 F\u2081 i \u2192 F\u2082 i \u2192 C\nih : (i : \u03b9\u271d\u00b2) \u2192 F\u2081 i \u2192 F\u2082 i \u2192 F\u271d\u00b9 i\nf\u271d : \u2983i j : \u03b9\u271d\u00b2\u2984 \u2192 i \u2264 j \u2192 F\u271d\u00b9 j \u2192 F\u271d\u00b9 i\ni\u271d\u00b2 j : \u03b9\u271d\u00b2\nh : i\u271d\u00b2 \u2264 j\n\u03b9\u271d\u00b9 : Type u_10\ninst\u271d\u2078 : LinearOrder \u03b9\u271d\u00b9\nX\u271d\u00b9 : \u03b9\u271d\u00b9 \u2192 Type u_11\ni\u271d\u00b9 : \u03b9\u271d\u00b9\nhi\u271d : IsSuccPrelimit i\u271d\u00b9\n\u03b9\u271d : Type u_12\nF\u271d : \u03b9\u271d \u2192 Type u_13\nX\u271d : \u03b9\u271d \u2192 Type u_14\ni\u271d : \u03b9\u271d\ninst\u271d\u2077 : PartialOrder \u03b9\u271d\ninst\u271d\u2076 : DecidableEq \u03b9\u271d\ninst\u271d\u2075 : LinearOrder \u03b9\u271d\nf : \u2983i j : \u03b9\u271d\u2984 \u2192 i \u2264 j \u2192 F\u271d j \u2192 F\u271d i\ninst\u271d\u2074 : SuccOrder \u03b9\u271d\nequiv : (j : \u2191(Iic i\u271d)) \u2192 F\u271d \u2191j \u2243 sorry\ne\u271d : F\u271d sorry \u2243 F\u271d i\u271d \u00d7 X\u271d i\u271d\nhi : \u00acIsMax i\u271d\n\u03b9 : Type u_12\nF : \u03b9 \u2192 Type u_13\nX : \u03b9 \u2192 Type u_14\ni : \u03b9\ninst\u271d\u00b3 : PartialOrder \u03b9\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : LinearOrder \u03b9\ninst\u271d : SuccOrder \u03b9\ne : F sorry \u2243 F i \u00d7 X i\nx\u271d : Sort u_15\npiEquivSucc : x\u271d\nx : F sorry\n\u22a2 sorry = (e x).2"}, {"line": "simp [piEquivSucc]", "tactic_state": "T\u2081 : ?m.77894\nf\u2081 : ?m.78314\npiLT : ?m.81137\n\u03b9\u271d\u00b2 : Type u_1\ninst\u271d\u00b9\u2076 : Preorder \u03b9\u271d\u00b2\nF\u2081 : \u03b9\u271d\u00b2 \u2192 Type u_2\nF\u2082 : \u03b9\u271d\u00b2 \u2192 Type u_3\nF\u271d\u00b9 : \u03b9\u271d\u00b2 \u2192 Type u_4\nX\u271d\u00b2 : \u03b9\u271d\u00b2 \u2192 Type u_5\ninst\u271d\u00b9\u2075 : \u2983i j : \u03b9\u271d\u00b2\u2984 \u2192 i \u2264 j \u2192 FunLike sorry (F\u2081 i) (F\u2081 j)\ninst\u271d\u00b9\u2074 : DirectedSystem F\u2081 fun x1 x2 x3 => sorry\nT\u2082 : \u2983i j : \u03b9\u271d\u00b2\u2984 \u2192 i \u2264 j \u2192 Sort u_6\nf\u2082 : (i j : \u03b9\u271d\u00b2) \u2192 (h : i \u2264 j) \u2192 T\u2082 h\ninst\u271d\u00b9\u00b3 : \u2983i j : \u03b9\u271d\u00b2\u2984 \u2192 (h : i \u2264 j) \u2192 FunLike (T\u2082 h) (F\u2082 i) (F\u2082 j)\ninst\u271d\u00b9\u00b2 : DirectedSystem F\u2082 fun x1 x2 x3 => \u21d1(f\u2082 x1 x2 x3)\nT : \u2983i j : \u03b9\u271d\u00b2\u2984 \u2192 i \u2264 j \u2192 Sort u_7\nf\u271d\u00b9 : (i j : \u03b9\u271d\u00b2) \u2192 (h : i \u2264 j) \u2192 T h\ninst\u271d\u00b9\u00b9 : \u2983i j : \u03b9\u271d\u00b2\u2984 \u2192 (h : i \u2264 j) \u2192 FunLike (T h) (F\u271d\u00b9 i) (F\u271d\u00b9 j)\ninst\u271d\u00b9\u2070 : DirectedSystem F\u271d\u00b9 fun x1 x2 x3 => \u21d1(f\u271d\u00b9 x1 x2 x3)\ninst\u271d\u2079 : IsDirected \u03b9\u271d\u00b2 fun x1 x2 => x1 \u2264 x2\nC\u271d : Sort u_8\nih\u271d\u00b2 : (i : \u03b9\u271d\u00b2) \u2192 F\u271d\u00b9 i \u2192 C\u271d\ncompat\u271d : \u2200 (i j : \u03b9\u271d\u00b2) (h : i \u2264 j) (x : F\u271d\u00b9 i), ih\u271d\u00b2 i x = ih\u271d\u00b2 j ((f\u271d\u00b9 i j h) x)\nih\u271d\u00b9 : (i : \u03b9\u271d\u00b2) \u2192 F\u2081 i \u2192 F\u2082 i\ncompat : \u2200 (i j : \u03b9\u271d\u00b2) (h : i \u2264 j) (x : F\u2081 i), (f\u2082 i j h) (ih\u271d\u00b9 i x) = ih\u271d\u00b9 j sorry\nC : Sort u_9\nih\u271d : (i : \u03b9\u271d\u00b2) \u2192 F\u2081 i \u2192 F\u2082 i \u2192 C\nih : (i : \u03b9\u271d\u00b2) \u2192 F\u2081 i \u2192 F\u2082 i \u2192 F\u271d\u00b9 i\nf\u271d : \u2983i j : \u03b9\u271d\u00b2\u2984 \u2192 i \u2264 j \u2192 F\u271d\u00b9 j \u2192 F\u271d\u00b9 i\ni\u271d\u00b2 j : \u03b9\u271d\u00b2\nh : i\u271d\u00b2 \u2264 j\n\u03b9\u271d\u00b9 : Type u_10\ninst\u271d\u2078 : LinearOrder \u03b9\u271d\u00b9\nX\u271d\u00b9 : \u03b9\u271d\u00b9 \u2192 Type u_11\ni\u271d\u00b9 : \u03b9\u271d\u00b9\nhi\u271d : IsSuccPrelimit i\u271d\u00b9\n\u03b9\u271d : Type u_12\nF\u271d : \u03b9\u271d \u2192 Type u_13\nX\u271d : \u03b9\u271d \u2192 Type u_14\ni\u271d : \u03b9\u271d\ninst\u271d\u2077 : PartialOrder \u03b9\u271d\ninst\u271d\u2076 : DecidableEq \u03b9\u271d\ninst\u271d\u2075 : LinearOrder \u03b9\u271d\nf : \u2983i j : \u03b9\u271d\u2984 \u2192 i \u2264 j \u2192 F\u271d j \u2192 F\u271d i\ninst\u271d\u2074 : SuccOrder \u03b9\u271d\nequiv : (j : \u2191(Iic i\u271d)) \u2192 F\u271d \u2191j \u2243 sorry\ne\u271d : F\u271d sorry \u2243 F\u271d i\u271d \u00d7 X\u271d i\u271d\nhi : \u00acIsMax i\u271d\n\u03b9 : Type u_12\nF : \u03b9 \u2192 Type u_13\nX : \u03b9 \u2192 Type u_14\ni : \u03b9\ninst\u271d\u00b3 : PartialOrder \u03b9\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : LinearOrder \u03b9\ninst\u271d : SuccOrder \u03b9\ne : F sorry \u2243 F i \u00d7 X i\nx\u271d : Sort u_15\npiEquivSucc : x\u271d\nx : F sorry\n\u22a2 sorry () = (e x).2"}]}
{"declaration": "lemma Disjoint.eq_iff (hab : Disjoint a b) : a = b \u2194 a = \u22a5 \u2227 b = \u22a5 := by aesop", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Disjoint.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderBot \u03b1\na b : \u03b1\nhab : Disjoint a b\n\u22a2 a = b \u2194 a = \u22a5 \u2227 b = \u22a5"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Codisjoint.eq_iff (hab : Codisjoint a b) : a = b \u2194 a = \u22a4 \u2227 b = \u22a4 := by aesop", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Disjoint.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] [BoundedOrder \u03b1] {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderBot \u03b1] {a b c : \u03b1}", "(c)", "{c}", "[DistribLattice \u03b1] [OrderBot \u03b1] {a b c : \u03b1}", "[PartialOrder \u03b1] [OrderTop \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : OrderBot \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : BoundedOrder \u03b1\ninst\u271d\u2075 : SemilatticeInf \u03b1\ninst\u271d\u2074 : OrderBot \u03b1\ninst\u271d\u00b3 : DistribLattice \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderTop \u03b1\na b : \u03b1\nhab : Codisjoint a b\n\u22a2 a = b \u2194 a = \u22a4 \u2227 b = \u22a4"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_le_coe : (a : \u03b1) \u2264 b \u2194 a \u2264 b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Disjoint.lean", "context": {"open": ["Function", "OrderDual"], "variables": ["{\u03b1 : Type*}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] [BoundedOrder \u03b1] {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderBot \u03b1] {a b c : \u03b1}", "(c)", "{c}", "[DistribLattice \u03b1] [OrderBot \u03b1] {a b c : \u03b1}", "[PartialOrder \u03b1] [OrderTop \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] [BoundedOrder \u03b1] {a b : \u03b1}", "[SemilatticeSup \u03b1] [OrderTop \u03b1] {a b c : \u03b1}", "(c)", "{c}", "[DistribLattice \u03b1] [OrderTop \u03b1] {a b c : \u03b1}", "[DistribLattice \u03b1] [BoundedOrder \u03b1] {a b c : \u03b1}", "[PartialOrder \u03b1] [BoundedOrder \u03b1] {x y : \u03b1}", "[Lattice \u03b1] [BoundedOrder \u03b1] {x y : \u03b1}", "[DistribLattice \u03b1] [BoundedOrder \u03b1] {a b x y z : \u03b1}", "{\u03b2 : Type*} [PartialOrder \u03b1] [PartialOrder \u03b2]", "[Lattice \u03b1] [BoundedOrder \u03b1] {a b x : \u03b1}", "[Lattice \u03b1] [BoundedOrder \u03b1]", "[DistribLattice \u03b1] [BoundedOrder \u03b1] {a b : \u03b1}", "[Lattice \u03b1] [BoundedOrder \u03b1] [ComplementedLattice \u03b1]", "[Lattice \u03b1] [BoundedOrder \u03b1] {a b : Complementeds \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry \u2194 sorry"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_lt_coe : (a : \u03b1) < b \u2194 a < b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Disjoint.lean", "context": {"open": ["Function", "OrderDual"], "variables": ["{\u03b1 : Type*}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] [BoundedOrder \u03b1] {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderBot \u03b1] {a b c : \u03b1}", "(c)", "{c}", "[DistribLattice \u03b1] [OrderBot \u03b1] {a b c : \u03b1}", "[PartialOrder \u03b1] [OrderTop \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] [BoundedOrder \u03b1] {a b : \u03b1}", "[SemilatticeSup \u03b1] [OrderTop \u03b1] {a b c : \u03b1}", "(c)", "{c}", "[DistribLattice \u03b1] [OrderTop \u03b1] {a b c : \u03b1}", "[DistribLattice \u03b1] [BoundedOrder \u03b1] {a b c : \u03b1}", "[PartialOrder \u03b1] [BoundedOrder \u03b1] {x y : \u03b1}", "[Lattice \u03b1] [BoundedOrder \u03b1] {x y : \u03b1}", "[DistribLattice \u03b1] [BoundedOrder \u03b1] {a b x y z : \u03b1}", "{\u03b2 : Type*} [PartialOrder \u03b1] [PartialOrder \u03b2]", "[Lattice \u03b1] [BoundedOrder \u03b1] {a b x : \u03b1}", "[Lattice \u03b1] [BoundedOrder \u03b1]", "[DistribLattice \u03b1] [BoundedOrder \u03b1] {a b : \u03b1}", "[Lattice \u03b1] [BoundedOrder \u03b1] [ComplementedLattice \u03b1]", "[Lattice \u03b1] [BoundedOrder \u03b1] {a b : Complementeds \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry \u2194 sorry"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_bot : (\u27e8\u22a5, isComplemented_bot\u27e9 : Complementeds \u03b1) = \u22a5 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Disjoint.lean", "context": {"open": ["Function", "OrderDual"], "variables": ["{\u03b1 : Type*}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] [BoundedOrder \u03b1] {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderBot \u03b1] {a b c : \u03b1}", "(c)", "{c}", "[DistribLattice \u03b1] [OrderBot \u03b1] {a b c : \u03b1}", "[PartialOrder \u03b1] [OrderTop \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] [BoundedOrder \u03b1] {a b : \u03b1}", "[SemilatticeSup \u03b1] [OrderTop \u03b1] {a b c : \u03b1}", "(c)", "{c}", "[DistribLattice \u03b1] [OrderTop \u03b1] {a b c : \u03b1}", "[DistribLattice \u03b1] [BoundedOrder \u03b1] {a b c : \u03b1}", "[PartialOrder \u03b1] [BoundedOrder \u03b1] {x y : \u03b1}", "[Lattice \u03b1] [BoundedOrder \u03b1] {x y : \u03b1}", "[DistribLattice \u03b1] [BoundedOrder \u03b1] {a b x y z : \u03b1}", "{\u03b2 : Type*} [PartialOrder \u03b1] [PartialOrder \u03b2]", "[Lattice \u03b1] [BoundedOrder \u03b1] {a b x : \u03b1}", "[Lattice \u03b1] [BoundedOrder \u03b1]", "[DistribLattice \u03b1] [BoundedOrder \u03b1] {a b : \u03b1}", "[Lattice \u03b1] [BoundedOrder \u03b1] [ComplementedLattice \u03b1]", "[Lattice \u03b1] [BoundedOrder \u03b1] {a b : Complementeds \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = \u22a5"}, {"line": "simp", "tactic_state": "\u22a2 sorry () = \u22a5"}]}
{"declaration": "theorem mk_top : (\u27e8\u22a4, isComplemented_top\u27e9 : Complementeds \u03b1) = \u22a4 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Disjoint.lean", "context": {"open": ["Function", "OrderDual"], "variables": ["{\u03b1 : Type*}", "[PartialOrder \u03b1] [OrderBot \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] [BoundedOrder \u03b1] {a : \u03b1}", "[SemilatticeInf \u03b1] [OrderBot \u03b1] {a b c : \u03b1}", "(c)", "{c}", "[DistribLattice \u03b1] [OrderBot \u03b1] {a b c : \u03b1}", "[PartialOrder \u03b1] [OrderTop \u03b1] {a b c d : \u03b1}", "[PartialOrder \u03b1] [BoundedOrder \u03b1] {a b : \u03b1}", "[SemilatticeSup \u03b1] [OrderTop \u03b1] {a b c : \u03b1}", "(c)", "{c}", "[DistribLattice \u03b1] [OrderTop \u03b1] {a b c : \u03b1}", "[DistribLattice \u03b1] [BoundedOrder \u03b1] {a b c : \u03b1}", "[PartialOrder \u03b1] [BoundedOrder \u03b1] {x y : \u03b1}", "[Lattice \u03b1] [BoundedOrder \u03b1] {x y : \u03b1}", "[DistribLattice \u03b1] [BoundedOrder \u03b1] {a b x y z : \u03b1}", "{\u03b2 : Type*} [PartialOrder \u03b1] [PartialOrder \u03b2]", "[Lattice \u03b1] [BoundedOrder \u03b1] {a b x : \u03b1}", "[Lattice \u03b1] [BoundedOrder \u03b1]", "[DistribLattice \u03b1] [BoundedOrder \u03b1] {a b : \u03b1}", "[Lattice \u03b1] [BoundedOrder \u03b1] [ComplementedLattice \u03b1]", "[Lattice \u03b1] [BoundedOrder \u03b1] {a b : Complementeds \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = \u22a4"}, {"line": "simp", "tactic_state": "\u22a2 sorry () = \u22a4"}]}
{"declaration": "theorem preimage_find_eq_disjointed (s : \u2115 \u2192 Set \u03b1) (H : \u2200 x, \u2203 n, x \u2208 s n)\n    [\u2200 x n, Decidable (x \u2208 s n)] (n : \u2115) : (fun x => Nat.find (H x)) \u207b\u00b9' {n} = disjointed s n := by\n  ext x\n  simp [Nat.find_eq_iff, disjointed_eq_inter_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Disjointed.lean", "context": {"open": ["Finset Order", "scoped Function -- required for scoped `on` notation"], "variables": ["{\u03b1 \u03b9 : Type*}", "[GeneralizedBooleanAlgebra \u03b1]", "[Preorder \u03b9] [LocallyFiniteOrderBot \u03b9]", "[PartialOrder \u03b9] [LocallyFiniteOrderBot \u03b9]", "[LinearOrder \u03b9] [LocallyFiniteOrderBot \u03b9]", "[SuccOrder \u03b9]", "[CompleteBooleanAlgebra \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d\u00b9 : CompleteBooleanAlgebra \u03b1\ns : \u2115 \u2192 Set \u03b1\nH : \u2200 (x : \u03b1), \u2203 n, x \u2208 s n\ninst\u271d : (x : \u03b1) \u2192 (n : \u2115) \u2192 Decidable (x \u2208 s n)\nn : \u2115\n\u22a2 (fun x => Nat.find \u22ef) \u207b\u00b9' {n} = disjointed s n"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b2 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d\u00b9 : CompleteBooleanAlgebra \u03b1\ns : \u2115 \u2192 Set \u03b1\nH : \u2200 (x : \u03b1), \u2203 n, x \u2208 s n\ninst\u271d : (x : \u03b1) \u2192 (n : \u2115) \u2192 Decidable (x \u2208 s n)\nn : \u2115\nx : \u03b1\n\u22a2 x \u2208 (fun x => Nat.find \u22ef) \u207b\u00b9' {n} \u2194 x \u2208 disjointed s n"}, {"line": "simp [Nat.find_eq_iff, disjointed_eq_inter_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Acc.prod_gameAdd (ha : Acc r\u03b1 a) (hb : Acc r\u03b2 b) :\n    Acc (Prod.GameAdd r\u03b1 r\u03b2) (a, b) := by\n  induction' ha with a _ iha generalizing b\n  induction' hb with b hb ihb\n  refine Acc.intro _ fun h => ?_\n  rintro (\u27e8ra\u27e9 | \u27e8rb\u27e9)\n  exacts [iha _ ra (Acc.intro b hb), ihb _ rb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/GameAdd.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} {r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop} {r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop} {a : \u03b1} {b : \u03b2}", "(r\u03b1 r\u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop\na : \u03b1\nb : \u03b2\nha : Acc r\u03b1 a\nhb : Acc r\u03b2 b\n\u22a2 Acc (Prod.GameAdd r\u03b1 r\u03b2) (a, b)"}, {"line": "induction' ha with a _ iha generalizing b", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop\na\u271d a : \u03b1\nh\u271d : \u2200 (y : \u03b1), r\u03b1 y a \u2192 Acc r\u03b1 y\niha : \u2200 (y : \u03b1), r\u03b1 y a \u2192 \u2200 {b : \u03b2}, Acc r\u03b2 b \u2192 Acc (Prod.GameAdd r\u03b1 r\u03b2) (y, b)\nb : \u03b2\nhb : Acc r\u03b2 b\n\u22a2 Acc (Prod.GameAdd r\u03b1 r\u03b2) (a, b)"}, {"line": "induction' hb with b hb ihb", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop\na\u271d a : \u03b1\nh\u271d : \u2200 (y : \u03b1), r\u03b1 y a \u2192 Acc r\u03b1 y\niha : \u2200 (y : \u03b1), r\u03b1 y a \u2192 \u2200 {b : \u03b2}, Acc r\u03b2 b \u2192 Acc (Prod.GameAdd r\u03b1 r\u03b2) (y, b)\nb\u271d b : \u03b2\nhb : \u2200 (y : \u03b2), r\u03b2 y b \u2192 Acc r\u03b2 y\nihb : \u2200 (y : \u03b2), r\u03b2 y b \u2192 Acc (Prod.GameAdd r\u03b1 r\u03b2) (a, y)\n\u22a2 Acc (Prod.GameAdd r\u03b1 r\u03b2) (a, b)"}, {"line": "refine Acc.intro _ fun h => ?_", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop\na\u271d a : \u03b1\nh\u271d : \u2200 (y : \u03b1), r\u03b1 y a \u2192 Acc r\u03b1 y\niha : \u2200 (y : \u03b1), r\u03b1 y a \u2192 \u2200 {b : \u03b2}, Acc r\u03b2 b \u2192 Acc (Prod.GameAdd r\u03b1 r\u03b2) (y, b)\nb\u271d b : \u03b2\nhb : \u2200 (y : \u03b2), r\u03b2 y b \u2192 Acc r\u03b2 y\nihb : \u2200 (y : \u03b2), r\u03b2 y b \u2192 Acc (Prod.GameAdd r\u03b1 r\u03b2) (a, y)\nh : \u03b1 \u00d7 \u03b2\n\u22a2 Prod.GameAdd r\u03b1 r\u03b2 h (a, b) \u2192 Acc (Prod.GameAdd r\u03b1 r\u03b2) h"}, {"line": "rintro (\u27e8ra\u27e9 | \u27e8rb\u27e9)", "tactic_state": "case intro.intro.fst\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop\na\u271d a : \u03b1\nh\u271d : \u2200 (y : \u03b1), r\u03b1 y a \u2192 Acc r\u03b1 y\niha : \u2200 (y : \u03b1), r\u03b1 y a \u2192 \u2200 {b : \u03b2}, Acc r\u03b2 b \u2192 Acc (Prod.GameAdd r\u03b1 r\u03b2) (y, b)\nb\u271d b : \u03b2\nhb : \u2200 (y : \u03b2), r\u03b2 y b \u2192 Acc r\u03b2 y\nihb : \u2200 (y : \u03b2), r\u03b2 y b \u2192 Acc (Prod.GameAdd r\u03b1 r\u03b2) (a, y)\na\u2081\u271d : \u03b1\nra : r\u03b1 a\u2081\u271d a\n\u22a2 Acc (Prod.GameAdd r\u03b1 r\u03b2) (a\u2081\u271d, b)\n---\ncase intro.intro.snd\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop\na\u271d a : \u03b1\nh\u271d : \u2200 (y : \u03b1), r\u03b1 y a \u2192 Acc r\u03b1 y\niha : \u2200 (y : \u03b1), r\u03b1 y a \u2192 \u2200 {b : \u03b2}, Acc r\u03b2 b \u2192 Acc (Prod.GameAdd r\u03b1 r\u03b2) (y, b)\nb\u271d b : \u03b2\nhb : \u2200 (y : \u03b2), r\u03b2 y b \u2192 Acc r\u03b2 y\nihb : \u2200 (y : \u03b2), r\u03b2 y b \u2192 Acc (Prod.GameAdd r\u03b1 r\u03b2) (a, y)\nb\u2081\u271d : \u03b2\nrb : r\u03b2 b\u2081\u271d b\n\u22a2 Acc (Prod.GameAdd r\u03b1 r\u03b2) (a, b\u2081\u271d)"}, {"line": "exacts [iha _ ra (Acc.intro b hb), ihb _ rb]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singleton_mem_subchain_iff : [a] \u2208 s.subchain \u2194 a \u2208 s := by simp [cons_mem_subchain_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Height.lean", "context": {"open": ["List hiding le_antisymm", "OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}", "[LT \u03b1] [LT \u03b2] (s t : Set \u03b1)", "{s} {l : List \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LT \u03b1\ns : Set \u03b1\na : \u03b1\n\u22a2 [a] \u2208 s.subchain \u2194 a \u2208 s"}, {"line": "simp [cons_mem_subchain_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_chainHeight_TFAE (n : \u2115) :\n    TFAE [\u2191n \u2264 s.chainHeight, \u2203 l \u2208 s.subchain, length l = n, \u2203 l \u2208 s.subchain, n \u2264 length l] := by\n  tfae_have 1 \u2192 2 := s.exists_chain_of_le_chainHeight\n  tfae_have 2 \u2192 3 := fun \u27e8l, hls, he\u27e9 \u21a6 \u27e8l, hls, he.ge\u27e9\n  tfae_have 3 \u2192 1 := fun \u27e8l, hs, hn\u27e9 \u21a6 le_iSup\u2082_of_le l hs (WithTop.coe_le_coe.2 hn)\n  tfae_finish\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Height.lean", "context": {"open": ["List hiding le_antisymm", "OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}", "[LT \u03b1] [LT \u03b2] (s t : Set \u03b1)", "{s} {l : List \u03b1} {a : \u03b1}", "(s)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LT \u03b1\ns : Set \u03b1\nn : \u2115\n\u22a2 [\u2191n \u2264 s.chainHeight, \u2203 l \u2208 s.subchain, l.length = n, \u2203 l \u2208 s.subchain, n \u2264 l.length].TFAE"}, {"line": "tfae_have 1 \u2192 2 := s.exists_chain_of_le_chainHeight", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LT \u03b1\ns : Set \u03b1\nn : \u2115\ntfae_1_to_2 : \u2191n \u2264 s.chainHeight \u2192 \u2203 l \u2208 s.subchain, l.length = n\n\u22a2 [\u2191n \u2264 s.chainHeight, \u2203 l \u2208 s.subchain, l.length = n, \u2203 l \u2208 s.subchain, n \u2264 l.length].TFAE"}, {"line": "tfae_have 2 \u2192 3 := fun \u27e8l, hls, he\u27e9 \u21a6 \u27e8l, hls, he.ge\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LT \u03b1\ns : Set \u03b1\nn : \u2115\ntfae_1_to_2 : \u2191n \u2264 s.chainHeight \u2192 \u2203 l \u2208 s.subchain, l.length = n\ntfae_2_to_3 : (\u2203 l \u2208 s.subchain, l.length = n) \u2192 \u2203 l \u2208 s.subchain, n \u2264 l.length\n\u22a2 [\u2191n \u2264 s.chainHeight, \u2203 l \u2208 s.subchain, l.length = n, \u2203 l \u2208 s.subchain, n \u2264 l.length].TFAE"}, {"line": "tfae_have 3 \u2192 1 := fun \u27e8l, hs, hn\u27e9 \u21a6 le_iSup\u2082_of_le l hs (WithTop.coe_le_coe.2 hn)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LT \u03b1\ns : Set \u03b1\nn : \u2115\ntfae_1_to_2 : \u2191n \u2264 s.chainHeight \u2192 \u2203 l \u2208 s.subchain, l.length = n\ntfae_2_to_3 : (\u2203 l \u2208 s.subchain, l.length = n) \u2192 \u2203 l \u2208 s.subchain, n \u2264 l.length\ntfae_3_to_1 : (\u2203 l \u2208 s.subchain, n \u2264 l.length) \u2192 \u2191n \u2264 s.chainHeight\n\u22a2 [\u2191n \u2264 s.chainHeight, \u2203 l \u2208 s.subchain, l.length = n, \u2203 l \u2208 s.subchain, n \u2264 l.length].TFAE"}, {"line": "tfae_finish", "tactic_state": "No Goals!"}]}
{"declaration": "theorem chainHeight_le_chainHeight_TFAE (s : Set \u03b1) (t : Set \u03b2) :\n    TFAE [s.chainHeight \u2264 t.chainHeight, \u2200 l \u2208 s.subchain, \u2203 l' \u2208 t.subchain, length l = length l',\n      \u2200 l \u2208 s.subchain, \u2203 l' \u2208 t.subchain, length l \u2264 length l'] := by\n  tfae_have 1 \u2194 3 := by\n    convert \u2190 chainHeight_add_le_chainHeight_add s t 0 0 <;> apply add_zero\n  tfae_have 2 \u2194 3 := by\n    refine forall\u2082_congr fun l _ \u21a6 ?_\n    simp_rw [\u2190 (le_chainHeight_TFAE t l.length).out 1 2, eq_comm]\n  tfae_finish\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Height.lean", "context": {"open": ["List hiding le_antisymm", "OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}", "[LT \u03b1] [LT \u03b2] (s t : Set \u03b1)", "{s} {l : List \u03b1} {a : \u03b1}", "(s)", "{s t}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LT \u03b1\ninst\u271d : LT \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 [s.chainHeight \u2264 t.chainHeight, \u2200 l \u2208 s.subchain, \u2203 l' \u2208 t.subchain, l.length = l'.length,\n      \u2200 l \u2208 s.subchain, \u2203 l' \u2208 t.subchain, l.length \u2264 l'.length].TFAE"}, {"line": "tfae_have 1 \u2194 3 := by\n    convert \u2190 chainHeight_add_le_chainHeight_add s t 0 0 <;> apply add_zero", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LT \u03b1\ninst\u271d : LT \u03b2\ns : Set \u03b1\nt : Set \u03b2\ntfae_1_iff_3 : s.chainHeight \u2264 t.chainHeight \u2194 \u2200 l \u2208 s.subchain, \u2203 l' \u2208 t.subchain, l.length \u2264 l'.length\n\u22a2 [s.chainHeight \u2264 t.chainHeight, \u2200 l \u2208 s.subchain, \u2203 l' \u2208 t.subchain, l.length = l'.length,\n      \u2200 l \u2208 s.subchain, \u2203 l' \u2208 t.subchain, l.length \u2264 l'.length].TFAE"}, {"line": "tfae_have 2 \u2194 3 := by\n    refine forall\u2082_congr fun l _ \u21a6 ?_\n    simp_rw [\u2190 (le_chainHeight_TFAE t l.length).out 1 2, eq_comm]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LT \u03b1\ninst\u271d : LT \u03b2\ns : Set \u03b1\nt : Set \u03b2\ntfae_1_iff_3 : s.chainHeight \u2264 t.chainHeight \u2194 \u2200 l \u2208 s.subchain, \u2203 l' \u2208 t.subchain, l.length \u2264 l'.length\ntfae_2_iff_3 :\n  (\u2200 l \u2208 s.subchain, \u2203 l' \u2208 t.subchain, l.length = l'.length) \u2194\n    \u2200 l \u2208 s.subchain, \u2203 l' \u2208 t.subchain, l.length \u2264 l'.length\n\u22a2 [s.chainHeight \u2264 t.chainHeight, \u2200 l \u2208 s.subchain, \u2203 l' \u2208 t.subchain, l.length = l'.length,\n      \u2200 l \u2208 s.subchain, \u2203 l' \u2208 t.subchain, l.length \u2264 l'.length].TFAE"}, {"line": "tfae_finish", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isMaximal_of_eq_inf (x b : X) {a y : X} (ha : x \u2293 y = a) (hxy : x \u2260 y) (hxb : IsMaximal x b)\n    (hyb : IsMaximal y b) : IsMaximal a y := by\n  have hb : x \u2294 y = b := sup_eq_of_isMaximal hxb hyb hxy\n  substs a b\n  exact isMaximal_inf_right_of_isMaximal_sup hxb hyb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/JordanHolder.lean", "context": {"open": ["Set RelSeries"], "variables": ["{X : Type u} [Lattice X] [JordanHolderLattice X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\nx\u271d : Sort u_1\nIsMaximal : x\u271d\nx b a y : X\nha : x \u2293 y = a\nhxy : x \u2260 y\nhxb : sorry\nhyb : sorry\n\u22a2 sorry"}, {"line": "have hb : x \u2294 y = b := sup_eq_of_isMaximal hxb hyb hxy", "tactic_state": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\nx\u271d : Sort u_1\nIsMaximal : x\u271d\nx b a y : X\nha : x \u2293 y = a\nhxy : x \u2260 y\nhxb : sorry\nhyb : sorry\nhb : sorry = b\n\u22a2 sorry"}, {"line": "substs a b", "tactic_state": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\nx\u271d : Sort u_1\nIsMaximal : x\u271d\nx y : X\nhxy : x \u2260 y\nhxb : sorry\nhyb : sorry\n\u22a2 sorry"}, {"line": "exact isMaximal_inf_right_of_isMaximal_sup hxb hyb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem last_eraseLast_le (s : CompositionSeries X) : s.eraseLast.last \u2264 s.last := by\n  simp [eraseLast, last, s.strictMono.le_iff_le, Fin.le_iff_val_le_val]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/JordanHolder.lean", "context": {"open": ["Set RelSeries", "JordanHolderLattice"], "variables": ["{X : Type u} [Lattice X] [JordanHolderLattice X]", "{X : Type u} [Lattice X] [JordanHolderLattice X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns : CompositionSeries X\n\u22a2 (eraseLast s).last \u2264 last s"}, {"line": "simp [eraseLast, last, s.strictMono.le_iff_le, Fin.le_iff_val_le_val]", "tactic_state": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns : CompositionSeries X\n\u22a2 s.toFun \u27e8s.length - 1, \u22ef\u27e9 \u2264 s.toFun (Fin.last s.length)"}]}
{"declaration": "theorem mem_eraseLast_of_ne_of_mem {s : CompositionSeries X} {x : X}\n    (hx : x \u2260 s.last) (hxs : x \u2208 s) : x \u2208 s.eraseLast := by\n  rcases hxs with \u27e8i, rfl\u27e9\n  have hi : (i : \u2115) < (s.length - 1).succ := by\n    conv_rhs => rw [\u2190 Nat.succ_sub (length_pos_of_nontrivial \u27e8_, \u27e8i, rfl\u27e9, _, s.last_mem, hx\u27e9),\n      Nat.add_one_sub_one]\n    exact lt_of_le_of_ne (Nat.le_of_lt_succ i.2) (by simpa [last, s.inj, Fin.ext_iff] using hx)\n  refine \u27e8Fin.castSucc (n := s.length + 1) i, ?_\u27e9\n  simp [Fin.ext_iff, Nat.mod_eq_of_lt hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/JordanHolder.lean", "context": {"open": ["Set RelSeries", "JordanHolderLattice"], "variables": ["{X : Type u} [Lattice X] [JordanHolderLattice X]", "{X : Type u} [Lattice X] [JordanHolderLattice X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns : CompositionSeries X\nx : X\nhx : x \u2260 last s\nhxs : x \u2208 s\n\u22a2 x \u2208 eraseLast s"}, {"line": "rcases hxs with \u27e8i, rfl\u27e9", "tactic_state": "case intro\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns : CompositionSeries X\ni : Fin (s.length + 1)\nhx : s.toFun i \u2260 last s\n\u22a2 s.toFun i \u2208 eraseLast s"}, {"line": "have hi : (i : \u2115) < (s.length - 1).succ := sorry", "tactic_state": "case intro\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns : CompositionSeries X\ni : Fin (s.length + 1)\nhx : s.toFun i \u2260 last s\nhi : \u2191i < (s.length - 1).succ\n\u22a2 s.toFun i \u2208 eraseLast s"}, {"line": "refine \u27e8Fin.castSucc (n := s.length + 1) i, ?_\u27e9", "tactic_state": "case intro\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns : CompositionSeries X\ni : Fin (s.length + 1)\nhx : s.toFun i \u2260 last s\nhi : \u2191i < (s.length - 1).succ\n\u22a2 (eraseLast s).toFun \u2191\u2191i.castSucc = s.toFun i"}, {"line": "simp [Fin.ext_iff, Nat.mod_eq_of_lt hi]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_eq_zero_of_head_eq_head_of_last_eq_last_of_length_eq_zero\n    {s\u2081 s\u2082 : CompositionSeries X} (hb : s\u2081.head = s\u2082.head)\n    (ht : s\u2081.last = s\u2082.last) (hs\u2081 : s\u2081.length = 0) : s\u2082.length = 0 := by\n  have : Fin.last s\u2082.length = (0 : Fin s\u2082.length.succ) :=\n    s\u2082.injective (hb.symm.trans ((congr_arg s\u2081 (Fin.ext (by simp [hs\u2081]))).trans ht)).symm\n  simpa [Fin.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/JordanHolder.lean", "context": {"open": ["Set RelSeries", "JordanHolderLattice"], "variables": ["{X : Type u} [Lattice X] [JordanHolderLattice X]", "{X : Type u} [Lattice X] [JordanHolderLattice X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns\u2081 s\u2082 : CompositionSeries X\nhb : head s\u2081 = head s\u2082\nht : last s\u2081 = last s\u2082\nhs\u2081 : s\u2081.length = 0\n\u22a2 s\u2082.length = 0"}, {"line": "have : Fin.last s\u2082.length = (0 : Fin s\u2082.length.succ) :=\n    s\u2082.injective (hb.symm.trans ((congr_arg s\u2081 (Fin.ext (by simp [hs\u2081]))).trans ht)).symm", "tactic_state": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns\u2081 s\u2082 : CompositionSeries X\nhb : head s\u2081 = head s\u2082\nht : last s\u2081 = last s\u2082\nhs\u2081 : s\u2081.length = 0\nthis : Fin.last s\u2082.length = 0\n\u22a2 s\u2082.length = 0"}, {"line": "simpa [Fin.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_of_head_eq_head_of_last_eq_last_of_length_eq_zero {s\u2081 s\u2082 : CompositionSeries X}\n    (hb : s\u2081.head = s\u2082.head) (ht : s\u2081.last = s\u2082.last) (hs\u20810 : s\u2081.length = 0) : s\u2081 = s\u2082 := by\n  have : \u2200 x, x \u2208 s\u2081 \u2194 x = s\u2081.last := fun x =>\n    \u27e8fun hx =>  subsingleton_of_length_eq_zero hs\u20810 hx s\u2081.last_mem, fun hx => hx.symm \u25b8 s\u2081.last_mem\u27e9\n  have : \u2200 x, x \u2208 s\u2082 \u2194 x = s\u2082.last := fun x =>\n    \u27e8fun hx =>\n      subsingleton_of_length_eq_zero\n        (length_eq_zero_of_head_eq_head_of_last_eq_last_of_length_eq_zero hb ht\n          hs\u20810) hx s\u2082.last_mem,\n      fun hx => hx.symm \u25b8 s\u2082.last_mem\u27e9\n  ext\n  simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/JordanHolder.lean", "context": {"open": ["Set RelSeries", "JordanHolderLattice"], "variables": ["{X : Type u} [Lattice X] [JordanHolderLattice X]", "{X : Type u} [Lattice X] [JordanHolderLattice X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns\u2081 s\u2082 : CompositionSeries X\nhb : head s\u2081 = head s\u2082\nht : last s\u2081 = last s\u2082\nhs\u20810 : s\u2081.length = 0\n\u22a2 s\u2081 = s\u2082"}, {"line": "have : \u2200 x, x \u2208 s\u2081 \u2194 x = s\u2081.last := fun x =>\n    \u27e8fun hx =>  subsingleton_of_length_eq_zero hs\u20810 hx s\u2081.last_mem, fun hx => hx.symm \u25b8 s\u2081.last_mem\u27e9", "tactic_state": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns\u2081 s\u2082 : CompositionSeries X\nhb : head s\u2081 = head s\u2082\nht : last s\u2081 = last s\u2082\nhs\u20810 : s\u2081.length = 0\nthis : \u2200 (x : X), x \u2208 s\u2081 \u2194 x = last s\u2081\n\u22a2 s\u2081 = s\u2082"}, {"line": "have : \u2200 x, x \u2208 s\u2082 \u2194 x = s\u2082.last := fun x =>\n    \u27e8fun hx =>\n      subsingleton_of_length_eq_zero\n        (length_eq_zero_of_head_eq_head_of_last_eq_last_of_length_eq_zero hb ht\n          hs\u20810) hx s\u2082.last_mem,\n      fun hx => hx.symm \u25b8 s\u2082.last_mem\u27e9", "tactic_state": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns\u2081 s\u2082 : CompositionSeries X\nhb : head s\u2081 = head s\u2082\nht : last s\u2081 = last s\u2082\nhs\u20810 : s\u2081.length = 0\nthis\u271d : \u2200 (x : X), x \u2208 s\u2081 \u2194 x = last s\u2081\nthis : \u2200 (x : X), x \u2208 s\u2082 \u2194 x = last s\u2082\n\u22a2 s\u2081 = s\u2082"}, {"line": "ext", "tactic_state": "case length_eq\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns\u2081 s\u2082 : CompositionSeries X\nhb : head s\u2081 = head s\u2082\nht : last s\u2081 = last s\u2082\nhs\u20810 : s\u2081.length = 0\nthis\u271d : \u2200 (x : X), x \u2208 s\u2081 \u2194 x = last s\u2081\nthis : \u2200 (x : X), x \u2208 s\u2082 \u2194 x = last s\u2082\n\u22a2 s\u2081.length = s\u2082.length\n---\ncase toFun_eq.h\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns\u2081 s\u2082 : CompositionSeries X\nhb : head s\u2081 = head s\u2082\nht : last s\u2081 = last s\u2082\nhs\u20810 : s\u2081.length = 0\nthis\u271d : \u2200 (x : X), x \u2208 s\u2081 \u2194 x = last s\u2081\nthis : \u2200 (x : X), x \u2208 s\u2082 \u2194 x = last s\u2082\nx\u271d : Fin (s\u2081.length + 1)\n\u22a2 s\u2081.toFun x\u271d = (s\u2082.toFun \u2218 Fin.cast \u22ef) x\u271d"}, {"line": "simp [*]", "tactic_state": "case length_eq\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns\u2081 s\u2082 : CompositionSeries X\nhb : head s\u2081 = head s\u2082\nht : last s\u2081 = last s\u2082\nhs\u20810 : s\u2081.length = 0\nthis\u271d : \u2200 (x : X), x \u2208 s\u2081 \u2194 x = last s\u2081\nthis : \u2200 (x : X), x \u2208 s\u2082 \u2194 x = last s\u2082\n\u22a2 0 = s\u2082.length\n---\ncase toFun_eq.h\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns\u2081 s\u2082 : CompositionSeries X\nhb : head s\u2081 = head s\u2082\nht : last s\u2081 = last s\u2082\nhs\u20810 : s\u2081.length = 0\nthis\u271d : \u2200 (x : X), x \u2208 s\u2081 \u2194 x = last s\u2081\nthis : \u2200 (x : X), x \u2208 s\u2082 \u2194 x = last s\u2082\nx\u271d : Fin (s\u2081.length + 1)\n\u22a2 s\u2081.toFun x\u271d = (s\u2082.toFun \u2218 Fin.cast \u22ef) x\u271d"}]}
{"declaration": "lemma ext {x y : RelSeries r} (length_eq : x.length = y.length)\n    (toFun_eq : x.toFun = y.toFun \u2218 Fin.cast (by rw [length_eq])) : x = y := by\n  rcases x with \u27e8nx, fx\u27e9\n  dsimp only at length_eq toFun_eq\n  subst length_eq toFun_eq\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelSeries.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (r : Rel \u03b1 \u03b1)", "{\u03b2 : Type*} (s : Rel \u03b2 \u03b2)", "{r}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\nx y : RelSeries r\nlength_eq : x.length = y.length\ntoFun_eq : x.toFun = y.toFun \u2218 Fin.cast \u22ef\n\u22a2 x = y"}, {"line": "rcases x with \u27e8nx, fx\u27e9", "tactic_state": "case mk\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\ny : RelSeries r\nnx : \u2115\nfx : Fin (nx + 1) \u2192 \u03b1\nstep\u271d : \u2200 (i : Fin nx), r (fx i.castSucc) (fx i.succ)\nlength_eq : { length := nx, toFun := fx, step := step\u271d }.length = y.length\ntoFun_eq : { length := nx, toFun := fx, step := step\u271d }.toFun = y.toFun \u2218 Fin.cast \u22ef\n\u22a2 { length := nx, toFun := fx, step := step\u271d } = y"}, {"line": "dsimp only at length_eq toFun_eq", "tactic_state": "case mk\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\ny : RelSeries r\nnx : \u2115\nfx : Fin (nx + 1) \u2192 \u03b1\nstep\u271d : \u2200 (i : Fin nx), r (fx i.castSucc) (fx i.succ)\nlength_eq : nx = y.length\ntoFun_eq : fx = y.toFun \u2218 Fin.cast \u22ef\n\u22a2 { length := nx, toFun := fx, step := step\u271d } = y"}, {"line": "subst length_eq toFun_eq", "tactic_state": "case mk\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\ny : RelSeries r\nstep\u271d : \u2200 (i : Fin y.length), r ((y.toFun \u2218 Fin.cast \u22ef) i.castSucc) ((y.toFun \u2218 Fin.cast \u22ef) i.succ)\n\u22a2 { length := y.length, toFun := y.toFun \u2218 Fin.cast \u22ef, step := step\u271d } = y"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toList_chain' (x : RelSeries r) : x.toList.Chain' r := by\n  rw [List.chain'_iff_get]\n  intros i h\n  convert x.step \u27e8i, by simpa [toList] using h\u27e9 <;> apply List.get_ofFn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelSeries.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (r : Rel \u03b1 \u03b1)", "{\u03b2 : Type*} (s : Rel \u03b2 \u03b2)", "{r}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\nx : RelSeries r\n\u22a2 List.Chain' r x.toList"}, {"line": "rw [List.chain'_iff_get]", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\nx : RelSeries r\n\u22a2 \u2200 (i : \u2115) (h : i < x.toList.length - 1), r (x.toList.get \u27e8i, \u22ef\u27e9) (x.toList.get \u27e8i + 1, \u22ef\u27e9)"}, {"line": "intros i h", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\nx : RelSeries r\ni : \u2115\nh : i < x.toList.length - 1\n\u22a2 r (x.toList.get \u27e8i, \u22ef\u27e9) (x.toList.get \u27e8i + 1, \u22ef\u27e9)"}, {"line": "convert x.step \u27e8i, by simpa [toList] using h\u27e9 <;> apply List.get_ofFn", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nonempty_of_finiteDimensional [r.FiniteDimensional] : Nonempty \u03b1 := by\n  obtain \u27e8p, _\u27e9 := (Rel.finiteDimensional_iff r).mp \u2039_\u203a\n  exact \u27e8p 0\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelSeries.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (r : Rel \u03b1 \u03b1)", "{\u03b2 : Type*} (s : Rel \u03b2 \u03b2)", "{r}", "{r} {s : RelSeries r} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\ninst\u271d : r.FiniteDimensional\n\u22a2 Nonempty \u03b1"}, {"line": "obtain \u27e8p, _\u27e9 := (Rel.finiteDimensional_iff r).mp \u2039_\u203a", "tactic_state": "case intro\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\ninst\u271d : r.FiniteDimensional\np : RelSeries r\nh\u271d : \u2200 (y : RelSeries r), y.length \u2264 p.length\n\u22a2 Nonempty \u03b1"}, {"line": "exact \u27e8p 0\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma head_singleton {r : Rel \u03b1 \u03b1} (x : \u03b1) : (singleton r x).head = x := by simp [singleton, head]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelSeries.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (r : Rel \u03b1 \u03b1)", "{\u03b2 : Type*} (s : Rel \u03b2 \u03b2)", "{r}", "{r} {s : RelSeries r} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\nx : \u03b1\n\u22a2 sorry = x"}, {"line": "simp [singleton, head]", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\nx : \u03b1\n\u22a2 sorry () = x"}]}
{"declaration": "lemma last_singleton {r : Rel \u03b1 \u03b1} (x : \u03b1) : (singleton r x).last = x := by simp [singleton, last]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelSeries.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (r : Rel \u03b1 \u03b1)", "{\u03b2 : Type*} (s : Rel \u03b2 \u03b2)", "{r}", "{r} {s : RelSeries r} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\nx : \u03b1\n\u22a2 sorry = x"}, {"line": "simp [singleton, last]", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\nx : \u03b1\n\u22a2 sorry () = x"}]}
{"declaration": "lemma head_take (p : RelSeries r) (i : Fin (p.length + 1)) :\n    (p.take i).head = p.head := by simp [take, head]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelSeries.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (r : Rel \u03b1 \u03b1)", "{\u03b2 : Type*} (s : Rel \u03b2 \u03b2)", "{r}", "{r} {s : RelSeries r} {x : \u03b1}", "{r s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\np : RelSeries r\ni : Fin (p.length + 1)\n\u22a2 (p.take i).head = p.head"}, {"line": "simp [take, head]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma head_drop (p : RelSeries r) (i : Fin (p.length + 1)) : (p.drop i).head = p.toFun i := by\n  simp [drop, head]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelSeries.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (r : Rel \u03b1 \u03b1)", "{\u03b2 : Type*} (s : Rel \u03b2 \u03b2)", "{r}", "{r} {s : RelSeries r} {x : \u03b1}", "{r s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\np : RelSeries r\ni : Fin (p.length + 1)\n\u22a2 (p.drop i).head = p.toFun i"}, {"line": "simp [drop, head]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Rel.not_infiniteDimensional_iff [Nonempty \u03b1] :\n    \u00ac r.InfiniteDimensional \u2194 r.FiniteDimensional := by\n  rw [\u2190 not_finiteDimensional_iff]\n  rw [not_not]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelSeries.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (r : Rel \u03b1 \u03b1)", "{\u03b2 : Type*} (s : Rel \u03b2 \u03b2)", "{r}", "{r} {s : RelSeries r} {x : \u03b1}", "{r s}", "{r} in", "{r} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\ninst\u271d : Nonempty \u03b1\n\u22a2 \u00acr.InfiniteDimensional \u2194 r.FiniteDimensional"}, {"line": "rw [\u2190 not_finiteDimensional_iff]", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\ninst\u271d : Nonempty \u03b1\n\u22a2 \u00ac\u00acr.FiniteDimensional \u2194 r.FiniteDimensional\n---\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\ninst\u271d : Nonempty \u03b1\n\u22a2 Nonempty \u03b1"}, {"line": "rw [not_not]", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\ninst\u271d : Nonempty \u03b1\n\u22a2 Nonempty \u03b1"}]}
{"declaration": "lemma Rel.finiteDimensional_or_infiniteDimensional [Nonempty \u03b1] :\n    r.FiniteDimensional \u2228 r.InfiniteDimensional := by\n  rw [\u2190 not_finiteDimensional_iff]\n  exact em r.FiniteDimensional\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelSeries.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (r : Rel \u03b1 \u03b1)", "{\u03b2 : Type*} (s : Rel \u03b2 \u03b2)", "{r}", "{r} {s : RelSeries r} {x : \u03b1}", "{r s}", "{r} in", "{r} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\ninst\u271d : Nonempty \u03b1\n\u22a2 r.FiniteDimensional \u2228 r.InfiniteDimensional"}, {"line": "rw [\u2190 not_finiteDimensional_iff]", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\ninst\u271d : Nonempty \u03b1\n\u22a2 r.FiniteDimensional \u2228 \u00acr.FiniteDimensional\n---\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\ninst\u271d : Nonempty \u03b1\n\u22a2 Nonempty \u03b1"}, {"line": "exact em r.FiniteDimensional", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\ninst\u271d : Nonempty \u03b1\n\u22a2 Nonempty \u03b1"}]}
{"declaration": "lemma Rel.wellFounded_swap_of_finiteDimensional [Rel.FiniteDimensional r] :\n    WellFounded (Function.swap r) := by\n  rw [WellFounded.wellFounded_iff_no_descending_seq]\n  refine \u27e8fun \u27e8f, hf\u27e9 \u21a6 ?_\u27e9\n  let s := RelSeries.mk (r := r) ((RelSeries.longestOf r).length + 1) (f \u00b7) (hf \u00b7)\n  exact (RelSeries.longestOf r).length.lt_succ_self.not_le s.length_le_length_longestOf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelSeries.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (r : Rel \u03b1 \u03b1)", "{\u03b2 : Type*} (s : Rel \u03b2 \u03b2)", "{r}", "{r} {s : RelSeries r} {x : \u03b1}", "{r s}", "{r} in", "{r} in", "{r} in", "{r} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\ninst\u271d : r.FiniteDimensional\n\u22a2 WellFounded (Function.swap r)"}, {"line": "rw [WellFounded.wellFounded_iff_no_descending_seq]", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\ninst\u271d : r.FiniteDimensional\n\u22a2 IsEmpty { f // \u2200 (n : \u2115), Function.swap r (f (n + 1)) (f n) }"}, {"line": "refine \u27e8fun \u27e8f, hf\u27e9 \u21a6 ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\ninst\u271d : r.FiniteDimensional\nx\u271d : { f // \u2200 (n : \u2115), Function.swap r (f (n + 1)) (f n) }\nf : \u2115 \u2192 \u03b1\nhf : \u2200 (n : \u2115), Function.swap r (f (n + 1)) (f n)\n\u22a2 False"}, {"line": "let s := RelSeries.mk (r := r) ((RelSeries.longestOf r).length + 1) (f \u00b7) (hf \u00b7)", "tactic_state": "\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\ninst\u271d : r.FiniteDimensional\nx\u271d : { f // \u2200 (n : \u2115), Function.swap r (f (n + 1)) (f n) }\nf : \u2115 \u2192 \u03b1\nhf : \u2200 (n : \u2115), Function.swap r (f (n + 1)) (f n)\ns : RelSeries r := { length := sorry + 1, toFun := fun x => f \u2191x, step := \u22ef }\n\u22a2 False"}, {"line": "exact (RelSeries.longestOf r).length.lt_succ_self.not_le s.length_le_length_longestOf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_relSeries_covBy_and_head_eq_bot_and_last_eq_bot\n    {\u03b1} [PartialOrder \u03b1] [BoundedOrder \u03b1] [WellFoundedLT \u03b1] [WellFoundedGT \u03b1] (s : LTSeries \u03b1) :\n    \u2203 (t : RelSeries (\u03b1 := \u03b1) (\u00b7 \u22d6 \u00b7)) (i : Fin (s.length + 1) \u21aa Fin (t.length + 1)),\n      t \u2218 i = s \u2227 t.head = \u22a5 \u2227 t.last = \u22a4 := by\n  wlog h\u2081 : s.head = \u22a5\n  \u00b7 obtain \u27e8t, i, hi, ht\u27e9 := this (s.cons \u22a5 (bot_lt_iff_ne_bot.mpr h\u2081)) rfl\n    exact \u27e8t, \u27e8fun j \u21a6 i (j.succ.cast (by simp)), fun _ _ \u21a6 by simp\u27e9,\n      funext fun j \u21a6 (congr_fun hi _).trans (RelSeries.cons_cast_succ _ _ _ _), ht\u27e9\n  wlog h\u2082 : s.last = \u22a4\n  \u00b7 obtain \u27e8t, i, hi, ht\u27e9 := this (s.snoc \u22a4 (lt_top_iff_ne_top.mpr h\u2082)) (by simp [h\u2081]) (by simp)\n    exact \u27e8t, \u27e8fun j \u21a6 i (.cast (by simp) j.castSucc), fun _ _ \u21a6 by simp\u27e9,\n      funext fun j \u21a6 (congr_fun hi _).trans (RelSeries.snoc_cast_castSucc _ _ _ _), ht\u27e9\n  obtain \u27e8t, i, hit, hi\u2081, hi\u2082\u27e9 := s.exists_relSeries_covBy\n  refine \u27e8t, i, hit, ?_, ?_\u27e9\n  \u00b7 rw [\u2190 h\u2081, RelSeries.head, RelSeries.head, \u2190 hi\u2081, \u2190 hit, Function.comp]\n  \u00b7 rw [\u2190 h\u2082, RelSeries.last, RelSeries.last, \u2190 hi\u2082, \u2190 hit, Function.comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelSeries.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (r : Rel \u03b1 \u03b1)", "{\u03b2 : Type*} (s : Rel \u03b2 \u03b2)", "{r}", "{r} {s : RelSeries r} {x : \u03b1}", "{r s}", "{r} in", "{r} in", "{r} in", "{r} in", "(\u03b1) [Preorder \u03b1] [Preorder \u03b2]", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : BoundedOrder \u03b1\ninst\u271d\u00b9 : WellFoundedLT \u03b1\ninst\u271d : WellFoundedGT \u03b1\ns : LTSeries \u03b1\n\u22a2 \u2203 t i, t.toFun \u2218 \u21d1i = s.toFun \u2227 t.head = \u22a5 \u2227 t.last = \u22a4"}, {"line": "wlog h\u2081 : s.head = \u22a5", "tactic_state": "case inr\n\u03b1 : Type u_3\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : BoundedOrder \u03b1\ninst\u271d\u00b9 : WellFoundedLT \u03b1\ninst\u271d : WellFoundedGT \u03b1\ns : LTSeries \u03b1\nthis :\n  \u2200 {\u03b1 : Type u_3} [inst : PartialOrder \u03b1] [inst_1 : BoundedOrder \u03b1] [inst_2 : WellFoundedLT \u03b1]\n    [inst_3 : WellFoundedGT \u03b1] (s : LTSeries \u03b1),\n    RelSeries.head s = \u22a5 \u2192 \u2203 t i, t.toFun \u2218 \u21d1i = s.toFun \u2227 t.head = \u22a5 \u2227 t.last = \u22a4\nh\u2081 : \u00acRelSeries.head s = \u22a5\n\u22a2 \u2203 t i, t.toFun \u2218 \u21d1i = s.toFun \u2227 t.head = \u22a5 \u2227 t.last = \u22a4\n---\n\u03b1 : Type u_3\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : BoundedOrder \u03b1\ninst\u271d\u00b9 : WellFoundedLT \u03b1\ninst\u271d : WellFoundedGT \u03b1\ns : LTSeries \u03b1\nh\u2081 : RelSeries.head s = \u22a5\n\u22a2 \u2203 t i, t.toFun \u2218 \u21d1i = s.toFun \u2227 t.head = \u22a5 \u2227 t.last = \u22a4"}, {"line": "\u00b7 obtain \u27e8t, i, hi, ht\u27e9 := this (s.cons \u22a5 (bot_lt_iff_ne_bot.mpr h\u2081)) rfl\n    exact \u27e8t, \u27e8fun j \u21a6 i (j.succ.cast (by simp)), fun _ _ \u21a6 by simp\u27e9,\n      funext fun j \u21a6 (congr_fun hi _).trans (RelSeries.cons_cast_succ _ _ _ _), ht\u27e9", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : BoundedOrder \u03b1\ninst\u271d\u00b9 : WellFoundedLT \u03b1\ninst\u271d : WellFoundedGT \u03b1\ns : LTSeries \u03b1\nh\u2081 : RelSeries.head s = \u22a5\n\u22a2 \u2203 t i, t.toFun \u2218 \u21d1i = s.toFun \u2227 t.head = \u22a5 \u2227 t.last = \u22a4"}, {"line": "wlog h\u2082 : s.last = \u22a4", "tactic_state": "case inr\n\u03b1 : Type u_3\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : BoundedOrder \u03b1\ninst\u271d\u00b9 : WellFoundedLT \u03b1\ninst\u271d : WellFoundedGT \u03b1\ns : LTSeries \u03b1\nh\u2081 : RelSeries.head s = \u22a5\nthis :\n  \u2200 {\u03b1 : Type u_3} [inst : PartialOrder \u03b1] [inst_1 : BoundedOrder \u03b1] [inst_2 : WellFoundedLT \u03b1]\n    [inst_3 : WellFoundedGT \u03b1] (s : LTSeries \u03b1),\n    RelSeries.head s = \u22a5 \u2192 RelSeries.last s = \u22a4 \u2192 \u2203 t i, t.toFun \u2218 \u21d1i = s.toFun \u2227 t.head = \u22a5 \u2227 t.last = \u22a4\nh\u2082 : \u00acRelSeries.last s = \u22a4\n\u22a2 \u2203 t i, t.toFun \u2218 \u21d1i = s.toFun \u2227 t.head = \u22a5 \u2227 t.last = \u22a4\n---\n\u03b1 : Type u_3\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : BoundedOrder \u03b1\ninst\u271d\u00b9 : WellFoundedLT \u03b1\ninst\u271d : WellFoundedGT \u03b1\ns : LTSeries \u03b1\nh\u2081 : RelSeries.head s = \u22a5\nh\u2082 : RelSeries.last s = \u22a4\n\u22a2 \u2203 t i, t.toFun \u2218 \u21d1i = s.toFun \u2227 t.head = \u22a5 \u2227 t.last = \u22a4"}, {"line": "\u00b7 obtain \u27e8t, i, hi, ht\u27e9 := this (s.snoc \u22a4 (lt_top_iff_ne_top.mpr h\u2082)) (by simp [h\u2081]) (by simp)\n    exact \u27e8t, \u27e8fun j \u21a6 i (.cast (by simp) j.castSucc), fun _ _ \u21a6 by simp\u27e9,\n      funext fun j \u21a6 (congr_fun hi _).trans (RelSeries.snoc_cast_castSucc _ _ _ _), ht\u27e9", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : BoundedOrder \u03b1\ninst\u271d\u00b9 : WellFoundedLT \u03b1\ninst\u271d : WellFoundedGT \u03b1\ns : LTSeries \u03b1\nh\u2081 : RelSeries.head s = \u22a5\nh\u2082 : RelSeries.last s = \u22a4\n\u22a2 \u2203 t i, t.toFun \u2218 \u21d1i = s.toFun \u2227 t.head = \u22a5 \u2227 t.last = \u22a4"}, {"line": "obtain \u27e8t, i, hit, hi\u2081, hi\u2082\u27e9 := s.exists_relSeries_covBy", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_3\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : BoundedOrder \u03b1\ninst\u271d\u00b9 : WellFoundedLT \u03b1\ninst\u271d : WellFoundedGT \u03b1\ns : LTSeries \u03b1\nh\u2081 : RelSeries.head s = \u22a5\nh\u2082 : RelSeries.last s = \u22a4\nt : RelSeries fun x1 x2 => x1 \u22d6 x2\ni : Fin (s.length + 1) \u21aa Fin (t.length + 1)\nhit : t.toFun \u2218 \u21d1i = s.toFun\nhi\u2081 : i 0 = 0\nhi\u2082 : i (Fin.last s.length) = Fin.last t.length\n\u22a2 \u2203 t i, t.toFun \u2218 \u21d1i = s.toFun \u2227 t.head = \u22a5 \u2227 t.last = \u22a4"}, {"line": "refine \u27e8t, i, hit, ?_, ?_\u27e9", "tactic_state": "case intro.intro.intro.intro.refine_1\n\u03b1 : Type u_3\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : BoundedOrder \u03b1\ninst\u271d\u00b9 : WellFoundedLT \u03b1\ninst\u271d : WellFoundedGT \u03b1\ns : LTSeries \u03b1\nh\u2081 : RelSeries.head s = \u22a5\nh\u2082 : RelSeries.last s = \u22a4\nt : RelSeries fun x1 x2 => x1 \u22d6 x2\ni : Fin (s.length + 1) \u21aa Fin (t.length + 1)\nhit : t.toFun \u2218 \u21d1i = s.toFun\nhi\u2081 : i 0 = 0\nhi\u2082 : i (Fin.last s.length) = Fin.last t.length\n\u22a2 t.head = \u22a5\n---\ncase intro.intro.intro.intro.refine_2\n\u03b1 : Type u_3\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : BoundedOrder \u03b1\ninst\u271d\u00b9 : WellFoundedLT \u03b1\ninst\u271d : WellFoundedGT \u03b1\ns : LTSeries \u03b1\nh\u2081 : RelSeries.head s = \u22a5\nh\u2082 : RelSeries.last s = \u22a4\nt : RelSeries fun x1 x2 => x1 \u22d6 x2\ni : Fin (s.length + 1) \u21aa Fin (t.length + 1)\nhit : t.toFun \u2218 \u21d1i = s.toFun\nhi\u2081 : i 0 = 0\nhi\u2082 : i (Fin.last s.length) = Fin.last t.length\n\u22a2 t.last = \u22a4"}, {"line": "\u00b7 rw [\u2190 h\u2081, RelSeries.head, RelSeries.head, \u2190 hi\u2081, \u2190 hit, Function.comp]", "tactic_state": "case intro.intro.intro.intro.refine_2\n\u03b1 : Type u_3\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : BoundedOrder \u03b1\ninst\u271d\u00b9 : WellFoundedLT \u03b1\ninst\u271d : WellFoundedGT \u03b1\ns : LTSeries \u03b1\nh\u2081 : RelSeries.head s = \u22a5\nh\u2082 : RelSeries.last s = \u22a4\nt : RelSeries fun x1 x2 => x1 \u22d6 x2\ni : Fin (s.length + 1) \u21aa Fin (t.length + 1)\nhit : t.toFun \u2218 \u21d1i = s.toFun\nhi\u2081 : i 0 = 0\nhi\u2082 : i (Fin.last s.length) = Fin.last t.length\n\u22a2 t.last = \u22a4"}, {"line": "\u00b7 rw [\u2190 h\u2082, RelSeries.last, RelSeries.last, \u2190 hi\u2082, \u2190 hit, Function.comp]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma head_add_length_le_int (p : LTSeries \u2124) : p.head + p.length \u2264 p.last := by\n  simpa using LTSeries.apply_add_index_le_apply_add_index_int _ _ (Fin.last _) (Fin.zero_le _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/RelSeries.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (r : Rel \u03b1 \u03b1)", "{\u03b2 : Type*} (s : Rel \u03b2 \u03b2)", "{r}", "{r} {s : RelSeries r} {x : \u03b1}", "{r s}", "{r} in", "{r} in", "{r} in", "{r} in", "(\u03b1) [Preorder \u03b1] [Preorder \u03b2]", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : LTSeries \u2124\n\u22a2 RelSeries.head p + \u2191p.length \u2264 RelSeries.last p"}, {"line": "simpa using LTSeries.apply_add_index_le_apply_add_index_int _ _ (Fin.last _) (Fin.zero_le _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_bddAbove_iff' : \u00acBddAbove s \u2194 \u2200 x, \u2203 y \u2208 s, \u00acy \u2264 x := by\n  simp [BddAbove, upperBounds, Set.Nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Basic.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b3 : Type v}", "[Preorder \u03b1] {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\ns : Set \u03b1\n\u22a2 \u00acBddAbove s \u2194 \u2200 (x : \u03b1), \u2203 y \u2208 s, \u00acy \u2264 x"}, {"line": "simp [BddAbove, upperBounds, Set.Nonempty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_bddAbove_iff {\u03b1 : Type*} [LinearOrder \u03b1] {s : Set \u03b1} :\n    \u00acBddAbove s \u2194 \u2200 x, \u2203 y \u2208 s, x < y := by\n  simp only [not_bddAbove_iff']\n  simp only [not_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Basic.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b3 : Type v}", "[Preorder \u03b1] {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\ns : Set \u03b1\n\u22a2 \u00acBddAbove s \u2194 \u2200 (x : \u03b1), \u2203 y \u2208 s, x < y"}, {"line": "simp only [not_bddAbove_iff']", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\ns : Set \u03b1\n\u22a2 (\u2200 (x : \u03b1), \u2203 y \u2208 s, \u00acy \u2264 x) \u2194 \u2200 (x : \u03b1), \u2203 y \u2208 s, x < y"}, {"line": "simp only [not_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLUB_congr (h : upperBounds s = upperBounds t) : IsLUB s a \u2194 IsLUB t a := by\n  rw [IsLUB]\n  rw [IsLUB]\n  rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Basic.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b3 : Type v}", "[Preorder \u03b1] {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\ns t : Set \u03b1\na : \u03b1\nh : upperBounds s = upperBounds t\n\u22a2 IsLUB s a \u2194 IsLUB t a"}, {"line": "rw [IsLUB]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\ns t : Set \u03b1\na : \u03b1\nh : upperBounds s = upperBounds t\n\u22a2 IsLeast (upperBounds s) a \u2194 IsLUB t a"}, {"line": "rw [IsLUB]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\ns t : Set \u03b1\na : \u03b1\nh : upperBounds s = upperBounds t\n\u22a2 IsLeast (upperBounds s) a \u2194 IsLeast (upperBounds t) a"}, {"line": "rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isGLB_congr (h : lowerBounds s = lowerBounds t) : IsGLB s a \u2194 IsGLB t a := by\n  rw [IsGLB]\n  rw [IsGLB]\n  rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Basic.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b3 : Type v}", "[Preorder \u03b1] {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\ns t : Set \u03b1\na : \u03b1\nh : lowerBounds s = lowerBounds t\n\u22a2 IsGLB s a \u2194 IsGLB t a"}, {"line": "rw [IsGLB]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\ns t : Set \u03b1\na : \u03b1\nh : lowerBounds s = lowerBounds t\n\u22a2 IsGreatest (lowerBounds s) a \u2194 IsGLB t a"}, {"line": "rw [IsGLB]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\ns t : Set \u03b1\na : \u03b1\nh : lowerBounds s = lowerBounds t\n\u22a2 IsGreatest (lowerBounds s) a \u2194 IsGreatest (lowerBounds t) a"}, {"line": "rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLeast_union_iff {a : \u03b1} {s t : Set \u03b1} :\n    IsLeast (s \u222a t) a \u2194 IsLeast s a \u2227 a \u2208 lowerBounds t \u2228 a \u2208 lowerBounds s \u2227 IsLeast t a := by\n  simp [IsLeast, lowerBounds_union, or_and_right, and_comm (a := a \u2208 t), and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Basic.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b3 : Type v}", "[Preorder \u03b1] {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\na : \u03b1\ns t : Set \u03b1\n\u22a2 IsLeast (s \u222a t) a \u2194 IsLeast s a \u2227 a \u2208 lowerBounds t \u2228 a \u2208 lowerBounds s \u2227 IsLeast t a"}, {"line": "simp [IsLeast, lowerBounds_union, or_and_right, and_comm (a := a \u2208 t), and_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bddAbove_iff_exists_ge [SemilatticeSup \u03b3] {s : Set \u03b3} (x\u2080 : \u03b3) :\n    BddAbove s \u2194 \u2203 x, x\u2080 \u2264 x \u2227 \u2200 y \u2208 s, y \u2264 x := by\n  rw [bddAbove_def]\n  rw [exists_ge_and_iff_exists]\n  exact Monotone.ball fun x _ => monotone_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Basic.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b3 : Type v}", "[Preorder \u03b1] {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b3 : Type v\ninst\u271d : SemilatticeSup \u03b3\ns : Set \u03b3\nx\u2080 : \u03b3\n\u22a2 BddAbove s \u2194 \u2203 x, x\u2080 \u2264 x \u2227 \u2200 y \u2208 s, y \u2264 x"}, {"line": "rw [bddAbove_def]", "tactic_state": "\u03b3 : Type v\ninst\u271d : SemilatticeSup \u03b3\ns : Set \u03b3\nx\u2080 : \u03b3\n\u22a2 (\u2203 x, \u2200 y \u2208 s, y \u2264 x) \u2194 \u2203 x, x\u2080 \u2264 x \u2227 \u2200 y \u2208 s, y \u2264 x"}, {"line": "rw [exists_ge_and_iff_exists]", "tactic_state": "\u03b3 : Type v\ninst\u271d : SemilatticeSup \u03b3\ns : Set \u03b3\nx\u2080 : \u03b3\n\u22a2 Monotone fun x => \u2200 y \u2208 s, y \u2264 x"}, {"line": "exact Monotone.ball fun x _ => monotone_le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bddBelow_bddAbove_iff_subset_Icc : BddBelow s \u2227 BddAbove s \u2194 \u2203 a b, s \u2286 Icc a b := by\n  simp [Ici_inter_Iic.symm, subset_inter_iff, bddBelow_iff_subset_Ici,\n    bddAbove_iff_subset_Iic, exists_and_left, exists_and_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Basic.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b3 : Type v}", "[Preorder \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[LinearOrder \u03b3]", "[DenselyOrdered \u03b3]", "[SemilatticeSup \u03b3] [DenselyOrdered \u03b3]", "[SemilatticeInf \u03b3] [DenselyOrdered \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\ns : Set \u03b1\n\u22a2 BddBelow s \u2227 BddAbove s \u2194 \u2203 a b, s \u2286 Icc a b"}, {"line": "simp [Ici_inter_Iic.symm, subset_inter_iff, bddBelow_iff_subset_Ici,\n    bddAbove_iff_subset_Iic, exists_and_left, exists_and_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem OrderTop.upperBounds_univ [PartialOrder \u03b3] [OrderTop \u03b3] :\n    upperBounds (univ : Set \u03b3) = {\u22a4} := by rw [isGreatest_univ.upperBounds_eq, Ici_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Basic.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b3 : Type v}", "[Preorder \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[LinearOrder \u03b3]", "[DenselyOrdered \u03b3]", "[SemilatticeSup \u03b3] [DenselyOrdered \u03b3]", "[SemilatticeInf \u03b3] [DenselyOrdered \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b3 : Type v\ninst\u271d\u2077 : LinearOrder \u03b3\ninst\u271d\u2076 : DenselyOrdered \u03b3\ninst\u271d\u2075 : SemilatticeSup \u03b3\ninst\u271d\u2074 : DenselyOrdered \u03b3\ninst\u271d\u00b3 : SemilatticeInf \u03b3\ninst\u271d\u00b2 : DenselyOrdered \u03b3\ninst\u271d\u00b9 : PartialOrder \u03b3\ninst\u271d : OrderTop \u03b3\n\u22a2 upperBounds univ = {\u22a4}"}, {"line": "rw [isGreatest_univ.upperBounds_eq, Ici_top]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem upperBounds_empty : upperBounds (\u2205 : Set \u03b1) = univ := by\n  simp only [upperBounds]\n  simp only [eq_univ_iff_forall]\n  simp only [mem_setOf_eq]\n  simp only [forall_mem_empty]\n  simp only [forall_true_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Basic.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b3 : Type v}", "[Preorder \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[LinearOrder \u03b3]", "[DenselyOrdered \u03b3]", "[SemilatticeSup \u03b3] [DenselyOrdered \u03b3]", "[SemilatticeInf \u03b3] [DenselyOrdered \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\n\u22a2 upperBounds \u2205 = univ"}, {"line": "simp only [upperBounds]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\n\u22a2 {x | \u2200 \u2983a : \u03b1\u2984, a \u2208 \u2205 \u2192 a \u2264 x} = univ"}, {"line": "simp only [eq_univ_iff_forall]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\n\u22a2 \u2200 (x : \u03b1), x \u2208 {x | \u2200 \u2983a : \u03b1\u2984, a \u2208 \u2205 \u2192 a \u2264 x}"}, {"line": "simp only [mem_setOf_eq]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\n\u22a2 \u2200 (x : \u03b1) \u2983a : \u03b1\u2984, a \u2208 \u2205 \u2192 a \u2264 x"}, {"line": "simp only [forall_mem_empty]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\n\u22a2 \u03b1 \u2192 True"}, {"line": "simp only [forall_true_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsGLB.insert [SemilatticeInf \u03b3] (a) {b} {s : Set \u03b3} (hs : IsGLB s b) :\n    IsGLB (insert a s) (a \u2293 b) := by\n  rw [insert_eq]\n  exact isGLB_singleton.union hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Basic.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b3 : Type v}", "[Preorder \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[LinearOrder \u03b3]", "[DenselyOrdered \u03b3]", "[SemilatticeSup \u03b3] [DenselyOrdered \u03b3]", "[SemilatticeInf \u03b3] [DenselyOrdered \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b3 : Type v\ninst\u271d\u2076 : LinearOrder \u03b3\ninst\u271d\u2075 : DenselyOrdered \u03b3\ninst\u271d\u2074 : SemilatticeSup \u03b3\ninst\u271d\u00b3 : DenselyOrdered \u03b3\ninst\u271d\u00b2 : SemilatticeInf \u03b3\ninst\u271d\u00b9 : DenselyOrdered \u03b3\ninst\u271d : SemilatticeInf \u03b3\na b : \u03b3\ns : Set \u03b3\nhs : IsGLB s b\n\u22a2 IsGLB (insert a s) (a \u2293 b)"}, {"line": "rw [insert_eq]", "tactic_state": "\u03b3 : Type v\ninst\u271d\u2076 : LinearOrder \u03b3\ninst\u271d\u2075 : DenselyOrdered \u03b3\ninst\u271d\u2074 : SemilatticeSup \u03b3\ninst\u271d\u00b3 : DenselyOrdered \u03b3\ninst\u271d\u00b2 : SemilatticeInf \u03b3\ninst\u271d\u00b9 : DenselyOrdered \u03b3\ninst\u271d : SemilatticeInf \u03b3\na b : \u03b3\ns : Set \u03b3\nhs : IsGLB s b\n\u22a2 IsGLB ({a} \u222a s) (a \u2293 b)"}, {"line": "exact isGLB_singleton.union hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem upperBounds_insert (a : \u03b1) (s : Set \u03b1) :\n    upperBounds (insert a s) = Ici a \u2229 upperBounds s := by\n  rw [insert_eq]\n  rw [upperBounds_union]\n  rw [upperBounds_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Basic.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b3 : Type v}", "[Preorder \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[LinearOrder \u03b3]", "[DenselyOrdered \u03b3]", "[SemilatticeSup \u03b3] [DenselyOrdered \u03b3]", "[SemilatticeInf \u03b3] [DenselyOrdered \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\na : \u03b1\ns : Set \u03b1\n\u22a2 upperBounds (insert a s) = Ici a \u2229 upperBounds s"}, {"line": "rw [insert_eq]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\na : \u03b1\ns : Set \u03b1\n\u22a2 upperBounds ({a} \u222a s) = Ici a \u2229 upperBounds s"}, {"line": "rw [upperBounds_union]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\na : \u03b1\ns : Set \u03b1\n\u22a2 upperBounds {a} \u2229 upperBounds s = Ici a \u2229 upperBounds s"}, {"line": "rw [upperBounds_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lowerBounds_insert (a : \u03b1) (s : Set \u03b1) :\n    lowerBounds (insert a s) = Iic a \u2229 lowerBounds s := by\n  rw [insert_eq]\n  rw [lowerBounds_union]\n  rw [lowerBounds_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Basic.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b3 : Type v}", "[Preorder \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[LinearOrder \u03b3]", "[DenselyOrdered \u03b3]", "[SemilatticeSup \u03b3] [DenselyOrdered \u03b3]", "[SemilatticeInf \u03b3] [DenselyOrdered \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\na : \u03b1\ns : Set \u03b1\n\u22a2 lowerBounds (insert a s) = Iic a \u2229 lowerBounds s"}, {"line": "rw [insert_eq]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\na : \u03b1\ns : Set \u03b1\n\u22a2 lowerBounds ({a} \u222a s) = Iic a \u2229 lowerBounds s"}, {"line": "rw [lowerBounds_union]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Preorder \u03b1\na : \u03b1\ns : Set \u03b1\n\u22a2 lowerBounds {a} \u2229 lowerBounds s = Iic a \u2229 lowerBounds s"}, {"line": "rw [lowerBounds_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isGreatest_himp [GeneralizedHeytingAlgebra \u03b1] (a b : \u03b1) :\n    IsGreatest {w | w \u2293 a \u2264 b} (a \u21e8 b) := by\n  simp [IsGreatest, mem_upperBounds]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Basic.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b3 : Type v}", "[Preorder \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[LinearOrder \u03b3]", "[DenselyOrdered \u03b3]", "[SemilatticeSup \u03b3] [DenselyOrdered \u03b3]", "[SemilatticeInf \u03b3] [DenselyOrdered \u03b3]", "[Preorder \u03b1] {s : Set \u03b1} {a b : \u03b1}", "[PartialOrder \u03b1] {s : Set \u03b1} {a b : \u03b1}", "[LinearOrder \u03b1] {s : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b : \u03b1\n\u22a2 IsGreatest {w | w \u2293 a \u2264 b} (a \u21e8 b)"}, {"line": "simp [IsGreatest, mem_upperBounds]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b : \u03b1\n\u22a2 b \u2293 a \u2264 b \u2227 \u2200 (x : \u03b1), x \u2293 a \u2264 b \u2192 x \u2264 a \u21e8 b"}]}
{"declaration": "theorem isLeast_sdiff [GeneralizedCoheytingAlgebra \u03b1] (a b : \u03b1) :\n    IsLeast {w | a \u2264 b \u2294 w} (a \\ b) := by\n  simp [IsLeast, mem_lowerBounds]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Basic.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b3 : Type v}", "[Preorder \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[LinearOrder \u03b3]", "[DenselyOrdered \u03b3]", "[SemilatticeSup \u03b3] [DenselyOrdered \u03b3]", "[SemilatticeInf \u03b3] [DenselyOrdered \u03b3]", "[Preorder \u03b1] {s : Set \u03b1} {a b : \u03b1}", "[PartialOrder \u03b1] {s : Set \u03b1} {a b : \u03b1}", "[LinearOrder \u03b1] {s : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 IsLeast {w | a \u2264 b \u2294 w} (a \\ b)"}, {"line": "simp [IsLeast, mem_lowerBounds]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 a \u2264 b \u2294 a \u2227 \u2200 (x : \u03b1), a \u2264 b \u2294 x \u2192 a \\ b \u2264 x"}]}
{"declaration": "theorem isGreatest_compl [HeytingAlgebra \u03b1] (a : \u03b1) :\n    IsGreatest {w | Disjoint w a} (a\u1d9c) := by\n  simpa only [himp_bot,disjoint_iff_inf_le] using isGreatest_himp a \u22a5\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Basic.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b3 : Type v}", "[Preorder \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[LinearOrder \u03b3]", "[DenselyOrdered \u03b3]", "[SemilatticeSup \u03b3] [DenselyOrdered \u03b3]", "[SemilatticeInf \u03b3] [DenselyOrdered \u03b3]", "[Preorder \u03b1] {s : Set \u03b1} {a b : \u03b1}", "[PartialOrder \u03b1] {s : Set \u03b1} {a b : \u03b1}", "[LinearOrder \u03b1] {s : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : HeytingAlgebra \u03b1\na : \u03b1\n\u22a2 IsGreatest {w | sorry} a\u1d9c"}, {"line": "simpa only [himp_bot,disjoint_iff_inf_le] using isGreatest_himp a \u22a5", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLeast_hnot [CoheytingAlgebra \u03b1] (a : \u03b1) :\n    IsLeast {w | Codisjoint a w} (\uffe2a) := by\n  simpa only [CoheytingAlgebra.top_sdiff,codisjoint_iff_le_sup] using isLeast_sdiff \u22a4 a", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Basic.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b3 : Type v}", "[Preorder \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[LinearOrder \u03b3]", "[DenselyOrdered \u03b3]", "[SemilatticeSup \u03b3] [DenselyOrdered \u03b3]", "[SemilatticeInf \u03b3] [DenselyOrdered \u03b3]", "[Preorder \u03b1] {s : Set \u03b1} {a b : \u03b1}", "[PartialOrder \u03b1] {s : Set \u03b1} {a b : \u03b1}", "[LinearOrder \u03b1] {s : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : CoheytingAlgebra \u03b1\na : \u03b1\n\u22a2 IsLeast {w | sorry} (\uffe2a)"}, {"line": "simpa only [CoheytingAlgebra.top_sdiff,codisjoint_iff_le_sup] using isLeast_sdiff \u22a4 a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_upperBounds_subset_upperBounds_image (Hf : MonotoneOn f t) (Hst : s \u2286 t) :\n    f '' (upperBounds s \u2229 t) \u2286 upperBounds (f '' s) := by\n  rintro _ \u27e8a, ha, rfl\u27e9\n  exact Hf.mem_upperBounds_image Hst ha.1 ha.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\ns t : Set \u03b1\nHf : MonotoneOn f t\nHst : s \u2286 t\n\u22a2 f '' (upperBounds s \u2229 t) \u2286 upperBounds (f '' s)"}, {"line": "rintro _ \u27e8a, ha, rfl\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\ns t : Set \u03b1\nHf : MonotoneOn f t\nHst : s \u2286 t\na : \u03b1\nha : a \u2208 upperBounds s \u2229 t\n\u22a2 f a \u2208 upperBounds (f '' s)"}, {"line": "exact Hf.mem_upperBounds_image Hst ha.1 ha.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_upperBounds_subset_upperBounds_image :\n    f '' upperBounds s \u2286 upperBounds (f '' s) := by\n  rintro _ \u27e8a, ha, rfl\u27e9\n  exact Hf.mem_upperBounds_image ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 f '' upperBounds s \u2286 upperBounds (f '' s)"}, {"line": "rintro _ \u27e8a, ha, rfl\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na : \u03b1\nha : a \u2208 upperBounds s\n\u22a2 f a \u2208 upperBounds (f '' s)"}, {"line": "exact Hf.mem_upperBounds_image ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma StrictMono.mem_upperBounds_image (hf : StrictMono f) :\n    f a \u2208 upperBounds (f '' s) \u2194 a \u2208 upperBounds s := by simp [upperBounds, hf.le_iff_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nhf : StrictMono f\n\u22a2 f a \u2208 upperBounds (f '' s) \u2194 a \u2208 upperBounds s"}, {"line": "simp [upperBounds, hf.le_iff_le]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nhf : StrictMono f\n\u22a2 (\u2200 a_1 \u2208 s, f a_1 \u2264 f a) \u2194 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 s \u2192 a_1 \u2264 a"}]}
{"declaration": "lemma StrictMono.mem_lowerBounds_image (hf : StrictMono f) :\n    f a \u2208 lowerBounds (f '' s) \u2194 a \u2208 lowerBounds s :=  by simp [lowerBounds, hf.le_iff_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nhf : StrictMono f\n\u22a2 f a \u2208 lowerBounds (f '' s) \u2194 a \u2208 lowerBounds s"}, {"line": "simp [lowerBounds, hf.le_iff_le]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nhf : StrictMono f\n\u22a2 (\u2200 a_1 \u2208 s, f a \u2264 f a_1) \u2194 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 s \u2192 a \u2264 a_1"}]}
{"declaration": "lemma StrictMono.map_isLeast (hf : StrictMono f) : IsLeast (f '' s) (f a) \u2194 IsLeast s a := by\n  simp [IsLeast, hf.injective.eq_iff, hf.mem_lowerBounds_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nhf : StrictMono f\n\u22a2 IsLeast (f '' s) (f a) \u2194 IsLeast s a"}, {"line": "simp [IsLeast, hf.injective.eq_iff, hf.mem_lowerBounds_image]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nhf : StrictMono f\n\u22a2 (\u2203 x \u2208 s, f x = f a) \u2227 f a \u2208 lowerBounds (f '' s) \u2194 a \u2208 s \u2227 a \u2208 lowerBounds s"}]}
{"declaration": "lemma StrictMono.map_isGreatest (hf : StrictMono f) :\n    IsGreatest (f '' s) (f a) \u2194 IsGreatest s a := by\n  simp [IsGreatest, hf.injective.eq_iff, hf.mem_upperBounds_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nhf : StrictMono f\n\u22a2 IsGreatest (f '' s) (f a) \u2194 IsGreatest s a"}, {"line": "simp [IsGreatest, hf.injective.eq_iff, hf.mem_upperBounds_image]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nhf : StrictMono f\n\u22a2 (\u2203 x \u2208 s, f x = f a) \u2227 f a \u2208 upperBounds (f '' s) \u2194 a \u2208 s \u2227 a \u2208 upperBounds s"}]}
{"declaration": "lemma StrictAnti.mem_upperBounds_image (hf : StrictAnti f) :\n    f a \u2208 upperBounds (f '' s) \u2194 a \u2208 lowerBounds s := by\n  simp [upperBounds, lowerBounds, hf.le_iff_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b2\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nhf : StrictAnti f\n\u22a2 f a \u2208 upperBounds (f '' s) \u2194 a \u2208 lowerBounds s"}, {"line": "simp [upperBounds, lowerBounds, hf.le_iff_le]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b2\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nhf : StrictAnti f\n\u22a2 (\u2200 a_1 \u2208 s, f a_1 \u2264 f a) \u2194 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 s \u2192 a \u2264 a_1"}]}
{"declaration": "lemma StrictAnti.mem_lowerBounds_image (hf : StrictAnti f) :\n    f a \u2208 lowerBounds (f '' s) \u2194 a \u2208 upperBounds s := by\n  simp [upperBounds, lowerBounds, hf.le_iff_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b2\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nhf : StrictAnti f\n\u22a2 f a \u2208 lowerBounds (f '' s) \u2194 a \u2208 upperBounds s"}, {"line": "simp [upperBounds, lowerBounds, hf.le_iff_le]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b2\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nhf : StrictAnti f\n\u22a2 (\u2200 a_1 \u2208 s, f a \u2264 f a_1) \u2194 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 s \u2192 a_1 \u2264 a"}]}
{"declaration": "lemma StrictAnti.map_isLeast (hf : StrictAnti f) : IsLeast (f '' s) (f a) \u2194 IsGreatest s a := by\n  simp [IsLeast, IsGreatest, hf.injective.eq_iff, hf.mem_lowerBounds_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b2\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nhf : StrictAnti f\n\u22a2 IsLeast (f '' s) (f a) \u2194 IsGreatest s a"}, {"line": "simp [IsLeast, IsGreatest, hf.injective.eq_iff, hf.mem_lowerBounds_image]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b2\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nhf : StrictAnti f\n\u22a2 (\u2203 x \u2208 s, f x = f a) \u2227 f a \u2208 lowerBounds (f '' s) \u2194 a \u2208 s \u2227 a \u2208 upperBounds s"}]}
{"declaration": "protected theorem BddAbove.image2 :\n    BddAbove s \u2192 BddAbove t \u2192 BddAbove (image2 f s t) := by\n  rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9\n  exact \u27e8f a b, mem_upperBounds_image2 h\u2080 h\u2081 ha hb\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1}", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b2\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 BddAbove s \u2192 BddAbove t \u2192 BddAbove (image2 f s t)"}, {"line": "rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b2\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\na : \u03b1\nha : a \u2208 upperBounds s\nb : \u03b2\nhb : b \u2208 upperBounds t\n\u22a2 BddAbove (image2 f s t)"}, {"line": "exact \u27e8f a b, mem_upperBounds_image2 h\u2080 h\u2081 ha hb\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem BddBelow.image2 :\n    BddBelow s \u2192 BddBelow t \u2192 BddBelow (image2 f s t) := by\n  rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9\n  exact \u27e8f a b, mem_lowerBounds_image2 h\u2080 h\u2081 ha hb\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1}", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b2\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 BddBelow s \u2192 BddBelow t \u2192 BddBelow (image2 f s t)"}, {"line": "rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b2\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\na : \u03b1\nha : a \u2208 lowerBounds s\nb : \u03b2\nhb : b \u2208 lowerBounds t\n\u22a2 BddBelow (image2 f s t)"}, {"line": "exact \u27e8f a b, mem_lowerBounds_image2 h\u2080 h\u2081 ha hb\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem BddAbove.bddAbove_image2_of_bddBelow :\n    BddAbove s \u2192 BddBelow t \u2192 BddAbove (Set.image2 f s t) := by\n  rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9\n  exact \u27e8f a b, mem_upperBounds_image2_of_mem_upperBounds_of_mem_lowerBounds h\u2080 h\u2081 ha hb\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1}", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b2\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 BddAbove s \u2192 BddBelow t \u2192 BddAbove (image2 f s t)"}, {"line": "rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b2\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\na : \u03b1\nha : a \u2208 upperBounds s\nb : \u03b2\nhb : b \u2208 lowerBounds t\n\u22a2 BddAbove (image2 f s t)"}, {"line": "exact \u27e8f a b, mem_upperBounds_image2_of_mem_upperBounds_of_mem_lowerBounds h\u2080 h\u2081 ha hb\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem BddBelow.bddBelow_image2_of_bddAbove :\n    BddBelow s \u2192 BddAbove t \u2192 BddBelow (Set.image2 f s t) := by\n  rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9\n  exact \u27e8f a b, mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_upperBounds h\u2080 h\u2081 ha hb\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1}", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b2\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 BddBelow s \u2192 BddAbove t \u2192 BddBelow (image2 f s t)"}, {"line": "rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b2\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\na : \u03b1\nha : a \u2208 lowerBounds s\nb : \u03b2\nhb : b \u2208 upperBounds t\n\u22a2 BddBelow (image2 f s t)"}, {"line": "exact \u27e8f a b, mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_upperBounds h\u2080 h\u2081 ha hb\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem BddBelow.image2_bddAbove : BddBelow s \u2192 BddBelow t \u2192 BddAbove (Set.image2 f s t) := by\n  rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9\n  exact \u27e8f a b, mem_upperBounds_image2_of_mem_lowerBounds h\u2080 h\u2081 ha hb\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1}", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))", "(h\u2080 : \u2200 b, Antitone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b2\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 BddBelow s \u2192 BddBelow t \u2192 BddAbove (image2 f s t)"}, {"line": "rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b2\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\na : \u03b1\nha : a \u2208 lowerBounds s\nb : \u03b2\nhb : b \u2208 lowerBounds t\n\u22a2 BddAbove (image2 f s t)"}, {"line": "exact \u27e8f a b, mem_upperBounds_image2_of_mem_lowerBounds h\u2080 h\u2081 ha hb\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem BddAbove.image2_bddBelow : BddAbove s \u2192 BddAbove t \u2192 BddBelow (Set.image2 f s t) := by\n  rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9\n  exact \u27e8f a b, mem_lowerBounds_image2_of_mem_upperBounds h\u2080 h\u2081 ha hb\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1}", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))", "(h\u2080 : \u2200 b, Antitone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b2\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 BddAbove s \u2192 BddAbove t \u2192 BddBelow (image2 f s t)"}, {"line": "rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b2\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\na : \u03b1\nha : a \u2208 upperBounds s\nb : \u03b2\nhb : b \u2208 upperBounds t\n\u22a2 BddBelow (image2 f s t)"}, {"line": "exact \u27e8f a b, mem_lowerBounds_image2_of_mem_upperBounds h\u2080 h\u2081 ha hb\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem BddBelow.bddAbove_image2_of_bddAbove :\n    BddBelow s \u2192 BddAbove t \u2192 BddAbove (Set.image2 f s t) := by\n  rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9\n  exact \u27e8f a b, mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds h\u2080 h\u2081 ha hb\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1}", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))", "(h\u2080 : \u2200 b, Antitone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))", "(h\u2080 : \u2200 b, Antitone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b2\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 BddBelow s \u2192 BddAbove t \u2192 BddAbove (image2 f s t)"}, {"line": "rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b2\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\na : \u03b1\nha : a \u2208 lowerBounds s\nb : \u03b2\nhb : b \u2208 upperBounds t\n\u22a2 BddAbove (image2 f s t)"}, {"line": "exact \u27e8f a b, mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds h\u2080 h\u2081 ha hb\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem BddAbove.bddBelow_image2_of_bddAbove :\n    BddAbove s \u2192 BddBelow t \u2192 BddBelow (Set.image2 f s t) := by\n  rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9\n  exact \u27e8f a b, mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_lowerBounds h\u2080 h\u2081 ha hb\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1}", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))", "(h\u2080 : \u2200 b, Antitone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))", "(h\u2080 : \u2200 b, Antitone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b2\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 BddAbove s \u2192 BddBelow t \u2192 BddBelow (image2 f s t)"}, {"line": "rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : Preorder \u03b2\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Preorder \u03b2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b2\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\na : \u03b1\nha : a \u2208 upperBounds s\nb : \u03b2\nhb : b \u2208 lowerBounds t\n\u22a2 BddBelow (image2 f s t)"}, {"line": "exact \u27e8f a b, mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_lowerBounds h\u2080 h\u2081 ha hb\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma bddAbove_range_prod {F : \u03b9 \u2192 \u03b1 \u00d7 \u03b2} :\n    BddAbove (range F) \u2194 BddAbove (range <| Prod.fst \u2218 F) \u2227 BddAbove (range <| Prod.snd \u2218 F) := by\n  simp only [bddAbove_prod]\n  simp only [\u2190 range_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1}", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))", "(h\u2080 : \u2200 b, Antitone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))", "(h\u2080 : \u2200 b, Antitone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort x\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nF : \u03b9 \u2192 \u03b1 \u00d7 \u03b2\n\u22a2 BddAbove (range F) \u2194 BddAbove (range (Prod.fst \u2218 F)) \u2227 BddAbove (range (Prod.snd \u2218 F))"}, {"line": "simp only [bddAbove_prod]", "tactic_state": "\u03b9 : Sort x\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nF : \u03b9 \u2192 \u03b1 \u00d7 \u03b2\n\u22a2 BddAbove (Prod.fst '' range F) \u2227 BddAbove (Prod.snd '' range F) \u2194\n    BddAbove (range (Prod.fst \u2218 F)) \u2227 BddAbove (range (Prod.snd \u2218 F))"}, {"line": "simp only [\u2190 range_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLUB_prod {s : Set (\u03b1 \u00d7 \u03b2)} (p : \u03b1 \u00d7 \u03b2) :\n    IsLUB s p \u2194 IsLUB (Prod.fst '' s) p.1 \u2227 IsLUB (Prod.snd '' s) p.2 := by\n  refine\n    \u27e8fun H =>\n      \u27e8\u27e8monotone_fst.mem_upperBounds_image H.1, fun a ha => ?_\u27e9,\n        \u27e8monotone_snd.mem_upperBounds_image H.1, fun a ha => ?_\u27e9\u27e9,\n      fun H => \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 suffices h : (a, p.2) \u2208 upperBounds s from (H.2 h).1\n    exact fun q hq => \u27e8ha <| mem_image_of_mem _ hq, (H.1 hq).2\u27e9\n  \u00b7 suffices h : (p.1, a) \u2208 upperBounds s from (H.2 h).2\n    exact fun q hq => \u27e8(H.1 hq).1, ha <| mem_image_of_mem _ hq\u27e9\n  \u00b7 exact fun q hq => \u27e8H.1.1 <| mem_image_of_mem _ hq, H.2.1 <| mem_image_of_mem _ hq\u27e9\n  \u00b7 exact fun q hq =>\n      \u27e8H.1.2 <| monotone_fst.mem_upperBounds_image hq,\n        H.2.2 <| monotone_snd.mem_upperBounds_image hq\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1}", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))", "(h\u2080 : \u2200 b, Antitone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))", "(h\u2080 : \u2200 b, Antitone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\np : \u03b1 \u00d7 \u03b2\n\u22a2 IsLUB s p \u2194 IsLUB (Prod.fst '' s) p.1 \u2227 IsLUB (Prod.snd '' s) p.2"}, {"line": "refine\n    \u27e8fun H =>\n      \u27e8\u27e8monotone_fst.mem_upperBounds_image H.1, fun a ha => ?_\u27e9,\n        \u27e8monotone_snd.mem_upperBounds_image H.1, fun a ha => ?_\u27e9\u27e9,\n      fun H => \u27e8?_, ?_\u27e9\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\np : \u03b1 \u00d7 \u03b2\nH : IsLUB s p\na : \u03b1\nha : a \u2208 upperBounds (Prod.fst '' s)\n\u22a2 p.1 \u2264 a\n---\ncase refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\np : \u03b1 \u00d7 \u03b2\nH : IsLUB s p\na : \u03b2\nha : a \u2208 upperBounds (Prod.snd '' s)\n\u22a2 p.2 \u2264 a\n---\ncase refine_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\np : \u03b1 \u00d7 \u03b2\nH : IsLUB (Prod.fst '' s) p.1 \u2227 IsLUB (Prod.snd '' s) p.2\n\u22a2 p \u2208 upperBounds s\n---\ncase refine_4\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\np : \u03b1 \u00d7 \u03b2\nH : IsLUB (Prod.fst '' s) p.1 \u2227 IsLUB (Prod.snd '' s) p.2\n\u22a2 p \u2208 lowerBounds (upperBounds s)"}, {"line": "\u00b7 suffices h : (a, p.2) \u2208 upperBounds s from (H.2 h).1\n    exact fun q hq => \u27e8ha <| mem_image_of_mem _ hq, (H.1 hq).2\u27e9", "tactic_state": "case refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\np : \u03b1 \u00d7 \u03b2\nH : IsLUB s p\na : \u03b2\nha : a \u2208 upperBounds (Prod.snd '' s)\n\u22a2 p.2 \u2264 a\n---\ncase refine_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\np : \u03b1 \u00d7 \u03b2\nH : IsLUB (Prod.fst '' s) p.1 \u2227 IsLUB (Prod.snd '' s) p.2\n\u22a2 p \u2208 upperBounds s\n---\ncase refine_4\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\np : \u03b1 \u00d7 \u03b2\nH : IsLUB (Prod.fst '' s) p.1 \u2227 IsLUB (Prod.snd '' s) p.2\n\u22a2 p \u2208 lowerBounds (upperBounds s)"}, {"line": "\u00b7 suffices h : (p.1, a) \u2208 upperBounds s from (H.2 h).2\n    exact fun q hq => \u27e8(H.1 hq).1, ha <| mem_image_of_mem _ hq\u27e9", "tactic_state": "case refine_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\np : \u03b1 \u00d7 \u03b2\nH : IsLUB (Prod.fst '' s) p.1 \u2227 IsLUB (Prod.snd '' s) p.2\n\u22a2 p \u2208 upperBounds s\n---\ncase refine_4\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\np : \u03b1 \u00d7 \u03b2\nH : IsLUB (Prod.fst '' s) p.1 \u2227 IsLUB (Prod.snd '' s) p.2\n\u22a2 p \u2208 lowerBounds (upperBounds s)"}, {"line": "\u00b7 exact fun q hq => \u27e8H.1.1 <| mem_image_of_mem _ hq, H.2.1 <| mem_image_of_mem _ hq\u27e9", "tactic_state": "case refine_4\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\np : \u03b1 \u00d7 \u03b2\nH : IsLUB (Prod.fst '' s) p.1 \u2227 IsLUB (Prod.snd '' s) p.2\n\u22a2 p \u2208 lowerBounds (upperBounds s)"}, {"line": "\u00b7 exact fun q hq =>\n      \u27e8H.1.2 <| monotone_fst.mem_upperBounds_image hq,\n        H.2.2 <| monotone_snd.mem_upperBounds_image hq\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma bddAbove_range_pi {F : \u03b9 \u2192 \u2200 a, \u03c0 a} :\n    BddAbove (range F) \u2194 \u2200 a, BddAbove (range fun i \u21a6 F i a) := by\n  simp only [bddAbove_pi]\n  simp only [\u2190 range_comp]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1}", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))", "(h\u2080 : \u2200 b, Antitone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))", "(h\u2080 : \u2200 b, Antitone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]", "{\u03c0 : \u03b1 \u2192 Type*} [\u2200 a, Preorder (\u03c0 a)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort x\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\n\u03c0 : \u03b1 \u2192 Type u_3\ninst\u271d : (a : \u03b1) \u2192 Preorder (\u03c0 a)\nF : \u03b9 \u2192 (a : \u03b1) \u2192 \u03c0 a\n\u22a2 BddAbove (range F) \u2194 \u2200 (a : \u03b1), BddAbove (range fun i => F i a)"}, {"line": "simp only [bddAbove_pi]", "tactic_state": "\u03b9 : Sort x\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\n\u03c0 : \u03b1 \u2192 Type u_3\ninst\u271d : (a : \u03b1) \u2192 Preorder (\u03c0 a)\nF : \u03b9 \u2192 (a : \u03b1) \u2192 \u03c0 a\n\u22a2 (\u2200 (a : \u03b1), BddAbove (eval a '' range F)) \u2194 \u2200 (a : \u03b1), BddAbove (range fun i => F i a)"}, {"line": "simp only [\u2190 range_comp]", "tactic_state": "\u03b9 : Sort x\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\n\u03c0 : \u03b1 \u2192 Type u_3\ninst\u271d : (a : \u03b1) \u2192 Preorder (\u03c0 a)\nF : \u03b9 \u2192 (a : \u03b1) \u2192 \u03c0 a\n\u22a2 (\u2200 (a : \u03b1), BddAbove (range (eval a \u2218 F))) \u2194 \u2200 (a : \u03b1), BddAbove (range fun i => F i a)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLUB_pi {s : Set (\u2200 a, \u03c0 a)} {f : \u2200 a, \u03c0 a} :\n    IsLUB s f \u2194 \u2200 a, IsLUB (Function.eval a '' s) (f a) := by\n  classical\n    refine\n      \u27e8fun H a => \u27e8(Function.monotone_eval a).mem_upperBounds_image H.1, fun b hb => ?_\u27e9, fun H =>\n        \u27e8?_, ?_\u27e9\u27e9\n    \u00b7 suffices h : Function.update f a b \u2208 upperBounds s from Function.update_self a b f \u25b8 H.2 h a\n      exact fun g hg => le_update_iff.2 \u27e8hb <| mem_image_of_mem _ hg, fun i _ => H.1 hg i\u27e9\n    \u00b7 exact fun g hg a => (H a).1 (mem_image_of_mem _ hg)\n    \u00b7 exact fun g hg a => (H a).2 ((Function.monotone_eval a).mem_upperBounds_image hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1}", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))", "(h\u2080 : \u2200 b, Antitone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))", "(h\u2080 : \u2200 b, Antitone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]", "{\u03c0 : \u03b1 \u2192 Type*} [\u2200 a, Preorder (\u03c0 a)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\n\u03c0 : \u03b1 \u2192 Type u_3\ninst\u271d : (a : \u03b1) \u2192 Preorder (\u03c0 a)\ns : Set ((a : \u03b1) \u2192 \u03c0 a)\nf : (a : \u03b1) \u2192 \u03c0 a\n\u22a2 IsLUB s f \u2194 \u2200 (a : \u03b1), IsLUB (eval a '' s) (f a)"}, {"line": "classical\n    refine\n      \u27e8fun H a => \u27e8(Function.monotone_eval a).mem_upperBounds_image H.1, fun b hb => ?_\u27e9, fun H =>\n        \u27e8?_, ?_\u27e9\u27e9\n    \u00b7 suffices h : Function.update f a b \u2208 upperBounds s from Function.update_self a b f \u25b8 H.2 h a\n      exact fun g hg => le_update_iff.2 \u27e8hb <| mem_image_of_mem _ hg, fun i _ => H.1 hg i\u27e9\n    \u00b7 exact fun g hg a => (H a).1 (mem_image_of_mem _ hg)\n    \u00b7 exact fun g hg a => (H a).2 ((Function.monotone_eval a).mem_upperBounds_image hg)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma BddAbove.range_mono [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (g : \u03b1 \u2192 \u03b2) (h : \u2200 a, f a \u2264 g a)\n    (hbdd : BddAbove (range g)) : BddAbove (range f) := by\n  obtain \u27e8C, hC\u27e9 := hbdd\n  use C\n  rintro - \u27e8x, rfl\u27e9\n  exact (h x).trans (hC <| mem_range_self x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Image.lean", "context": {"open": ["Function Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {a : \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (Hf : Monotone f) {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1}", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))", "(h\u2080 : \u2200 b, Monotone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))", "(h\u2080 : \u2200 b, Antitone (swap f b)) (h\u2081 : \u2200 a, Antitone (f a))", "(h\u2080 : \u2200 b, Antitone (swap f b)) (h\u2081 : \u2200 a, Monotone (f a))", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]", "{\u03c0 : \u03b1 \u2192 Type*} [\u2200 a, Preorder (\u03c0 a)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b2\nf g : \u03b1 \u2192 \u03b2\nh : \u2200 (a : \u03b1), f a \u2264 g a\nhbdd : BddAbove (range g)\n\u22a2 BddAbove (range f)"}, {"line": "obtain \u27e8C, hC\u27e9 := hbdd", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b2\nf g : \u03b1 \u2192 \u03b2\nh : \u2200 (a : \u03b1), f a \u2264 g a\nC : \u03b2\nhC : C \u2208 upperBounds (range g)\n\u22a2 BddAbove (range f)"}, {"line": "use C", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b2\nf g : \u03b1 \u2192 \u03b2\nh : \u2200 (a : \u03b1), f a \u2264 g a\nC : \u03b2\nhC : C \u2208 upperBounds (range g)\n\u22a2 C \u2208 upperBounds (range f)"}, {"line": "rintro - \u27e8x, rfl\u27e9", "tactic_state": "case h.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b2\nf g : \u03b1 \u2192 \u03b2\nh : \u2200 (a : \u03b1), f a \u2264 g a\nC : \u03b2\nhC : C \u2208 upperBounds (range g)\nx : \u03b1\n\u22a2 f x \u2264 C"}, {"line": "exact (h x).trans (hC <| mem_range_self x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gc_upperBounds_lowerBounds : GaloisConnection\n    (OrderDual.toDual \u2218 upperBounds : Set \u03b1 \u2192 (Set \u03b1)\u1d52\u1d48)\n    (lowerBounds \u2218 OrderDual.ofDual : (Set \u03b1)\u1d52\u1d48 \u2192 Set \u03b1) := by\n  simpa [GaloisConnection, subset_def, mem_upperBounds, mem_lowerBounds]\n    using fun S T \u21a6 forall\u2082_swap\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Bounds/Lattice.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} [Preorder \u03b1] {\u03b9 : Sort*} {s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\n\u22a2 GaloisConnection (\u21d1OrderDual.toDual \u2218 upperBounds) (lowerBounds \u2218 \u21d1OrderDual.ofDual)"}, {"line": "simpa [GaloisConnection, subset_def, mem_upperBounds, mem_lowerBounds]\n    using fun S T \u21a6 forall\u2082_swap", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (X : BddDistLat) (x : X) :\n    (\ud835\udfd9 X : X \u27f6 X) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/BddDistLat.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : BddDistLat\nx : \u2191X.toDistLat\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id X)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {X Y Z : BddDistLat} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/BddDistLat.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : BddDistLat\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X.toDistLat\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {X Y : BddDistLat} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/BddDistLat.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : BddDistLat\ne : X \u2245 Y\nx : \u2191X.toDistLat\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {X Y : BddDistLat} (e : X \u2245 Y) (s : Y) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/BddDistLat.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : BddDistLat\ne : X \u2245 Y\ns : \u2191Y.toDistLat\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (X : BddOrd) (x : X) :\n    (\ud835\udfd9 X : X \u27f6 X) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/BddOrd.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : BddOrd\nx : \u2191X.toPartOrd\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id X)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {X Y Z : BddOrd} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/BddOrd.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : BddOrd\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X.toPartOrd\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {X Y : BddOrd} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/BddOrd.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : BddOrd\ne : X \u2245 Y\nx : \u2191X.toPartOrd\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {X Y : BddOrd} (e : X \u2245 Y) (s : Y) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/BddOrd.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : BddOrd\ne : X \u2245 Y\ns : \u2191Y.toPartOrd\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {X Y Z : BoolAlg} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/BoolAlg.lean", "context": {"open": ["OrderDual Opposite Set", "CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : BoolAlg\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {X Y : BoolAlg} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/BoolAlg.lean", "context": {"open": ["OrderDual Opposite Set", "CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : BoolAlg\ne : X \u2245 Y\nx : \u2191X\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {X Y : BoolAlg} (e : X \u2245 Y) (s : Y) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/BoolAlg.lean", "context": {"open": ["OrderDual Opposite Set", "CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : BoolAlg\ne : X \u2245 Y\ns : \u2191Y\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (X : DistLat) (x : X) :\n    (\ud835\udfd9 X : X \u27f6 X) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/DistLat.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : DistLat\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id X)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {X Y Z : DistLat} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/DistLat.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : DistLat\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {X Y : DistLat} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/DistLat.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : DistLat\ne : X \u2245 Y\nx : \u2191X\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {X Y : DistLat} (e : X \u2245 Y) (s : Y) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/DistLat.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : DistLat\ne : X \u2245 Y\ns : \u2191Y\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (X : FinBddDistLat) (x : X) :\n    (\ud835\udfd9 X : X \u27f6 X) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/FinBddDistLat.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : FinBddDistLat\nx : \u2191X.toDistLat\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id X)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {X Y Z : FinBddDistLat} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/FinBddDistLat.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : FinBddDistLat\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X.toDistLat\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {X Y : FinBddDistLat} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/FinBddDistLat.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : FinBddDistLat\ne : X \u2245 Y\nx : \u2191X.toDistLat\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {X Y : FinBddDistLat} (e : X \u2245 Y) (s : Y) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/FinBddDistLat.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : FinBddDistLat\ne : X \u2245 Y\ns : \u2191Y.toDistLat\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (X : FinPartOrd) (x : X) :\n    (\ud835\udfd9 X : X \u27f6 X) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/FinPartOrd.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : FinPartOrd\nx : \u2191X.toPartOrd\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id X)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {X Y Z : FinPartOrd} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/FinPartOrd.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : FinPartOrd\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X.toPartOrd\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (X : Frm) (x : X) :\n    (\ud835\udfd9 X : X \u27f6 X) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/Frm.lean", "context": {"open": ["CategoryTheory Order"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Frm\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id X)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {X Y Z : Frm} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/Frm.lean", "context": {"open": ["CategoryTheory Order"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Frm\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {X Y : Frm} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/Frm.lean", "context": {"open": ["CategoryTheory Order"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Frm\ne : X \u2245 Y\nx : \u2191X\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {X Y : Frm} (e : X \u2245 Y) (s : Y) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/Frm.lean", "context": {"open": ["CategoryTheory Order"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Frm\ne : X \u2245 Y\ns : \u2191Y\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (X : HeytAlg) (x : X) :\n    (\ud835\udfd9 X : X \u27f6 X) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/HeytAlg.lean", "context": {"open": ["CategoryTheory Opposite Order"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : HeytAlg\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id X)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {X Y Z : HeytAlg} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/HeytAlg.lean", "context": {"open": ["CategoryTheory Opposite Order"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : HeytAlg\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {X Y : HeytAlg} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/HeytAlg.lean", "context": {"open": ["CategoryTheory Opposite Order"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : HeytAlg\ne : X \u2245 Y\nx : \u2191X\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {X Y : HeytAlg} (e : X \u2245 Y) (s : Y) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/HeytAlg.lean", "context": {"open": ["CategoryTheory Opposite Order"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : HeytAlg\ne : X \u2245 Y\ns : \u2191Y\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {X Y Z : Lat} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/Lat.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Lat\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {X Y : Lat} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/Lat.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Lat\ne : X \u2245 Y\nx : \u2191X\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {X Y : Lat} (e : X \u2245 Y) (s : Y) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/Lat.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Lat\ne : X \u2245 Y\ns : \u2191Y\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (X : LinOrd) (x : X) :\n    (\ud835\udfd9 X : X \u27f6 X) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/LinOrd.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : LinOrd\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id X)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {X Y Z : LinOrd} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/LinOrd.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : LinOrd\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {X Y : LinOrd} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/LinOrd.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : LinOrd\ne : X \u2245 Y\nx : \u2191X\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {X Y : LinOrd} (e : X \u2245 Y) (s : Y) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/LinOrd.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : LinOrd\ne : X \u2245 Y\ns : \u2191Y\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (X : NonemptyFinLinOrd) (x : X) :\n    (\ud835\udfd9 X : X \u27f6 X) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/NonemptyFinLinOrd.lean", "context": {"open": ["CategoryTheory CategoryTheory.Limits"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : NonemptyFinLinOrd\nx : \u2191X.toLinOrd\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id X)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {X Y Z : NonemptyFinLinOrd} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/NonemptyFinLinOrd.lean", "context": {"open": ["CategoryTheory CategoryTheory.Limits"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : NonemptyFinLinOrd\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X.toLinOrd\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (X : Preord) (x : X) :\n    (\ud835\udfd9 X : X \u27f6 X) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/Preord.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Preord\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id X)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {X Y Z : Preord} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/Preord.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Preord\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {X Y : Preord} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/Preord.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Preord\ne : X \u2245 Y\nx : \u2191X\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {X Y : Preord} (e : X \u2245 Y) (s : Y) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/Preord.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Preord\ne : X \u2245 Y\ns : \u2191Y\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (X : Lat) (x : X) :\n    (\ud835\udfd9 X : X \u27f6 X) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/BddLat.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Lat\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id X)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {X Y Z : Lat} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/BddLat.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Lat\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (X : PartOrd) (x : X) :\n    (\ud835\udfd9 X : X \u27f6 X) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/PartOrd.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : PartOrd\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id X)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {X Y Z : PartOrd} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/PartOrd.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : PartOrd\nf : X \u27f6 Y\ng : Y \u27f6 Z\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {X Y : PartOrd} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Category/PartOrd.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : PartOrd\ne : X \u2245 Y\nx : \u2191X\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isCompactElement_iff_le_of_directed_sSup_le (k : \u03b1) :\n    IsCompactElement k \u2194\n      \u2200 s : Set \u03b1, s.Nonempty \u2192 DirectedOn (\u00b7 \u2264 \u00b7) s \u2192 k \u2264 sSup s \u2192 \u2203 x : \u03b1, x \u2208 s \u2227 k \u2264 x := by\n  classical\n    constructor\n    \u00b7 intro hk s hne hdir hsup\n      obtain \u27e8t, ht\u27e9 := hk s hsup\n      -- certainly every element of t is below something in s, since \u2191t \u2286 s.\n      have t_below_s : \u2200 x \u2208 t, \u2203 y \u2208 s, x \u2264 y := fun x hxt => \u27e8x, ht.left hxt, le_rfl\u27e9\n      obtain \u27e8x, \u27e8hxs, hsupx\u27e9\u27e9 := Finset.sup_le_of_le_directed s hne hdir t t_below_s\n      exact \u27e8x, \u27e8hxs, le_trans ht.right hsupx\u27e9\u27e9\n    \u00b7 intro hk s hsup\n      -- Consider the set of finite joins of elements of the (plain) set s.\n      let S : Set \u03b1 := { x | \u2203 t : Finset \u03b1, \u2191t \u2286 s \u2227 x = t.sup id }\n      -- S is directed, nonempty, and still has sup above k.\n      have dir_US : DirectedOn (\u00b7 \u2264 \u00b7) S := by\n        rintro x \u27e8c, hc\u27e9 y \u27e8d, hd\u27e9\n        use x \u2294 y\n        constructor\n        \u00b7 use c \u222a d\n          constructor\n          \u00b7 simp only [hc.left, hd.left, Set.union_subset_iff, Finset.coe_union, and_self_iff]\n          \u00b7 simp only [hc.right, hd.right, Finset.sup_union]\n        simp only [and_self_iff]\n        simp only [le_sup_left]\n        simp only [le_sup_right]\n      have sup_S : sSup s \u2264 sSup S := by\n        apply sSup_le_sSup\n        intro x hx\n        use {x}\n        simpa only [and_true,id,Finset.coe_singleton,eq_self_iff_true,Finset.sup_singleton,Set.singleton_subset_iff]\n      have Sne : S.Nonempty := by\n        suffices \u22a5 \u2208 S from Set.nonempty_of_mem this\n        use \u2205\n        simp only [Set.empty_subset]\n        simp only [Finset.coe_empty]\n        simp only [Finset.sup_empty]\n        simp only [eq_self_iff_true]\n        simp only [and_self_iff]\n      -- Now apply the defn of compact and finish.\n      obtain \u27e8j, \u27e8hjS, hjk\u27e9\u27e9 := hk S Sne dir_US (le_trans hsup sup_S)\n      obtain \u27e8t, \u27e8htS, htsup\u27e9\u27e9 := hjS\n      use t\n      exact \u27e8htS, by rwa [\u2190 htsup]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompactlyGenerated/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} [CompleteLattice \u03b1] {f : \u03b9 \u2192 \u03b1}", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : CompleteLattice \u03b1\nx\u271d : Sort u_3\nIsCompactElement : x\u271d\nk : \u03b1\n\u22a2 sorry \u2194 \u2200 (s : Set \u03b1), s.Nonempty \u2192 DirectedOn (fun x1 x2 => x1 \u2264 x2) s \u2192 k \u2264 sSup s \u2192 \u2203 x \u2208 s, k \u2264 x"}, {"line": "classical\n    constructor\n    \u00b7 intro hk s hne hdir hsup\n      obtain \u27e8t, ht\u27e9 := hk s hsup\n      have t_below_s : \u2200 x \u2208 t, \u2203 y \u2208 s, x \u2264 y := fun x hxt => \u27e8x, ht.left hxt, le_rfl\u27e9\n      obtain \u27e8x, \u27e8hxs, hsupx\u27e9\u27e9 := Finset.sup_le_of_le_directed s hne hdir t t_below_s\n      exact \u27e8x, \u27e8hxs, le_trans ht.right hsupx\u27e9\u27e9\n    \u00b7 intro hk s hsup\n      let S : Set \u03b1 := { x | \u2203 t : Finset \u03b1, \u2191t \u2286 s \u2227 x = t.sup id }\n      have dir_US : DirectedOn (\u00b7 \u2264 \u00b7) S := by\n        rintro x \u27e8c, hc\u27e9 y \u27e8d, hd\u27e9\n        use x \u2294 y\n        constructor\n        \u00b7 use c \u222a d\n          constructor\n          \u00b7 simp only [hc.left, hd.left, Set.union_subset_iff, Finset.coe_union, and_self_iff]\n          \u00b7 simp only [hc.right, hd.right, Finset.sup_union]\n        simp only [and_self_iff]\n        simp only [le_sup_left]\n        simp only [le_sup_right]\n      have sup_S : sSup s \u2264 sSup S := by\n        apply sSup_le_sSup\n        intro x hx\n        use {x}\n        simpa only [and_true,id,Finset.coe_singleton,eq_self_iff_true,Finset.sup_singleton,Set.singleton_subset_iff]\n      have Sne : S.Nonempty := by\n        suffices \u22a5 \u2208 S from Set.nonempty_of_mem this\n        use \u2205\n        simp only [Set.empty_subset]\n        simp only [Finset.coe_empty]\n        simp only [Finset.sup_empty]\n        simp only [eq_self_iff_true]\n        simp only [and_self_iff]\n      obtain \u27e8j, \u27e8hjS, hjk\u27e9\u27e9 := hk S Sne dir_US (le_trans hsup sup_S)\n      obtain \u27e8t, \u27e8htS, htsup\u27e9\u27e9 := hjS\n      use t\n      exact \u27e8htS, by rwa [\u2190 htsup]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem wellFoundedGT_characterisations : List.TFAE\n    [WellFoundedGT \u03b1, IsSupFiniteCompact \u03b1, IsSupClosedCompact \u03b1, \u2200 k : \u03b1, IsCompactElement k] := by\n  tfae_have 1 \u2192 2 := @WellFoundedGT.isSupFiniteCompact \u03b1 _\n  tfae_have 2 \u2192 3 := IsSupFiniteCompact.isSupClosedCompact \u03b1\n  tfae_have 3 \u2192 1 := IsSupClosedCompact.wellFoundedGT \u03b1\n  tfae_have 2 \u2194 4 := isSupFiniteCompact_iff_all_elements_compact \u03b1\n  tfae_finish\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompactlyGenerated/Basic.lean", "context": {"open": ["Set", "List in"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} [CompleteLattice \u03b1] {f : \u03b9 \u2192 \u03b1}", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\nx\u271d\u00b2 : Sort u_1\nIsSupFiniteCompact : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nIsSupClosedCompact : x\u271d\u00b9\nx\u271d : Sort u_3\nIsCompactElement : x\u271d\n\u22a2 [sorry, sorry, sorry, \u03b1 \u2192 sorry].TFAE"}, {"line": "tfae_have 1 \u2192 2 := @WellFoundedGT.isSupFiniteCompact \u03b1 _", "tactic_state": "\u03b1 : Type u_4\nx\u271d\u00b2 : Sort u_1\nIsSupFiniteCompact : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nIsSupClosedCompact : x\u271d\u00b9\nx\u271d : Sort u_3\nIsCompactElement : x\u271d\ntfae_1_to_2 : sorry \u2192 sorry\n\u22a2 [sorry, sorry, sorry, \u03b1 \u2192 sorry].TFAE"}, {"line": "tfae_have 2 \u2192 3 := IsSupFiniteCompact.isSupClosedCompact \u03b1", "tactic_state": "\u03b1 : Type u_4\nx\u271d\u00b2 : Sort u_1\nIsSupFiniteCompact : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nIsSupClosedCompact : x\u271d\u00b9\nx\u271d : Sort u_3\nIsCompactElement : x\u271d\ntfae_1_to_2 : sorry \u2192 sorry\ntfae_2_to_3 : sorry \u2192 sorry\n\u22a2 [sorry, sorry, sorry, \u03b1 \u2192 sorry].TFAE"}, {"line": "tfae_have 3 \u2192 1 := IsSupClosedCompact.wellFoundedGT \u03b1", "tactic_state": "\u03b1 : Type u_4\nx\u271d\u00b2 : Sort u_1\nIsSupFiniteCompact : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nIsSupClosedCompact : x\u271d\u00b9\nx\u271d : Sort u_3\nIsCompactElement : x\u271d\ntfae_1_to_2 : sorry \u2192 sorry\ntfae_2_to_3 : sorry \u2192 sorry\ntfae_3_to_1 : sorry \u2192 sorry\n\u22a2 [sorry, sorry, sorry, \u03b1 \u2192 sorry].TFAE"}, {"line": "tfae_have 2 \u2194 4 := isSupFiniteCompact_iff_all_elements_compact \u03b1", "tactic_state": "\u03b1 : Type u_4\nx\u271d\u00b2 : Sort u_1\nIsSupFiniteCompact : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nIsSupClosedCompact : x\u271d\u00b9\nx\u271d : Sort u_3\nIsCompactElement : x\u271d\ntfae_1_to_2 : sorry \u2192 sorry\ntfae_2_to_3 : sorry \u2192 sorry\ntfae_3_to_1 : sorry \u2192 sorry\ntfae_2_iff_4 : sorry \u2194 \u03b1 \u2192 sorry\n\u22a2 [sorry, sorry, sorry, \u03b1 \u2192 sorry].TFAE"}, {"line": "tfae_finish", "tactic_state": "No Goals!"}]}
{"declaration": "theorem complementedLattice_iff_isAtomistic : ComplementedLattice \u03b1 \u2194 IsAtomistic \u03b1 := by\n  constructor <;> intros\n  \u00b7 exact isAtomistic_of_complementedLattice\n  \u00b7 exact complementedLattice_of_isAtomistic\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompactlyGenerated/Basic.lean", "context": {"open": ["Set", "List in"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} [CompleteLattice \u03b1] {f : \u03b9 \u2192 \u03b1}", "(\u03b1)", "[IsCompactlyGenerated \u03b1] {a : \u03b1} {s : Set \u03b1}", "[IsModularLattice \u03b1] [IsCompactlyGenerated \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry \u2194 sorry"}, {"line": "constructor <;> intros", "tactic_state": "case mp\na\u271d : sorry\n\u22a2 sorry\n---\ncase mpr\na\u271d : sorry\n\u22a2 sorry"}, {"line": "\u00b7 exact isAtomistic_of_complementedLattice", "tactic_state": "case mpr\na\u271d : sorry\n\u22a2 sorry"}, {"line": "\u00b7 exact complementedLattice_of_isAtomistic", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sSup_eq_bot' {s : Set \u03b1} : sSup s = \u22a5 \u2194 s = \u2205 \u2228 s = {\u22a5} := by\n  rw [sSup_eq_bot]\n  rw [\u2190 subset_singleton_iff_eq]\n  rw [subset_singleton_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b9 : CompleteSemilatticeInf \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\n\u22a2 sSup s = \u22a5 \u2194 s = \u2205 \u2228 s = {\u22a5}"}, {"line": "rw [sSup_eq_bot]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b9 : CompleteSemilatticeInf \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\n\u22a2 (\u2200 a \u2208 s, a = \u22a5) \u2194 s = \u2205 \u2228 s = {\u22a5}"}, {"line": "rw [\u2190 subset_singleton_iff_eq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b9 : CompleteSemilatticeInf \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\n\u22a2 (\u2200 a \u2208 s, a = \u22a5) \u2194 s \u2286 {\u22a5}"}, {"line": "rw [subset_singleton_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_singleton_bot_of_sSup_eq_bot_of_nonempty {s : Set \u03b1} (h_sup : sSup s = \u22a5)\n    (hne : s.Nonempty) : s = {\u22a5} := by\n  rw [Set.eq_singleton_iff_nonempty_unique_mem]\n  rw [sSup_eq_bot] at h_sup\n  exact \u27e8hne, h_sup\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b9 : CompleteSemilatticeInf \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nh_sup : sSup s = \u22a5\nhne : s.Nonempty\n\u22a2 s = {\u22a5}"}, {"line": "rw [Set.eq_singleton_iff_nonempty_unique_mem]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b9 : CompleteSemilatticeInf \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nh_sup : sSup s = \u22a5\nhne : s.Nonempty\n\u22a2 s.Nonempty \u2227 \u2200 x \u2208 s, x = \u22a5"}, {"line": "rw [sSup_eq_bot] at h_sup", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b9 : CompleteSemilatticeInf \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nh_sup : \u2200 a \u2208 s, a = \u22a5\nhne : s.Nonempty\n\u22a2 s.Nonempty \u2227 \u2200 x \u2208 s, x = \u22a5"}, {"line": "exact \u27e8hne, h_sup\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sSup_eq_iSup' (s : Set \u03b1) : sSup s = \u2a06 a : s, (a : \u03b1) := by rw [iSup, Subtype.range_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b2 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : SupSet \u03b1\ns : Set \u03b1\n\u22a2 sSup s = \u2a06 a, \u2191a"}, {"line": "rw [iSup, Subtype.range_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Function.Surjective.iSup_comp {f : \u03b9 \u2192 \u03b9'} (hf : Surjective f) (g : \u03b9' \u2192 \u03b1) :\n    \u2a06 x, g (f x) = \u2a06 y, g y := by\n  simp only [iSup.eq_1]\n  congr\n  exact hf.range_comp g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\ninst\u271d\u00b3 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b2 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : SupSet \u03b1\nf : \u03b9 \u2192 \u03b9'\nhf : Surjective f\ng : \u03b9' \u2192 \u03b1\n\u22a2 \u2a06 x, g (f x) = \u2a06 y, g y"}, {"line": "simp only [iSup.eq_1]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\ninst\u271d\u00b3 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b2 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : SupSet \u03b1\nf : \u03b9 \u2192 \u03b9'\nhf : Surjective f\ng : \u03b9' \u2192 \u03b1\n\u22a2 sSup (range fun x => g (f x)) = sSup (range fun y => g y)"}, {"line": "congr", "tactic_state": "case e_a\n\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\ninst\u271d\u00b3 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b2 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : SupSet \u03b1\nf : \u03b9 \u2192 \u03b9'\nhf : Surjective f\ng : \u03b9' \u2192 \u03b1\n\u22a2 (range fun x => g (f x)) = range fun y => g y"}, {"line": "exact hf.range_comp g", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Function.Surjective.iSup_congr {g : \u03b9' \u2192 \u03b1} (h : \u03b9 \u2192 \u03b9') (h1 : Surjective h)\n    (h2 : \u2200 x, g (h x) = f x) : \u2a06 x, f x = \u2a06 y, g y := by\n  convert h1.iSup_comp g\n  exact (h2 _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\ninst\u271d\u00b3 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b2 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : SupSet \u03b1\nf : \u03b9 \u2192 \u03b1\ng : \u03b9' \u2192 \u03b1\nh : \u03b9 \u2192 \u03b9'\nh1 : Surjective h\nh2 : \u2200 (x : \u03b9), g (h x) = f x\n\u22a2 \u2a06 x, f x = \u2a06 y, g y"}, {"line": "convert h1.iSup_comp g", "tactic_state": "case h.e'_2.h.e'_4.h\n\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\ninst\u271d\u00b3 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b2 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : SupSet \u03b1\nf : \u03b9 \u2192 \u03b1\ng : \u03b9' \u2192 \u03b1\nh : \u03b9 \u2192 \u03b9'\nh1 : Surjective h\nh2 : \u2200 (x : \u03b9), g (h x) = f x\nx\u271d : \u03b9\n\u22a2 f x\u271d = g (h x\u271d)"}, {"line": "exact (h2 _).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_congr_Prop {p q : Prop} {f\u2081 : p \u2192 \u03b1} {f\u2082 : q \u2192 \u03b1} (pq : p \u2194 q)\n    (f : \u2200 x, f\u2081 (pq.mpr x) = f\u2082 x) : iSup f\u2081 = iSup f\u2082 := by\n  obtain rfl := propext pq\n  congr with x\n  apply f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b2 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : SupSet \u03b1\np q : Prop\nf\u2081 : p \u2192 \u03b1\nf\u2082 : q \u2192 \u03b1\npq : p \u2194 q\nf : \u2200 (x : q), f\u2081 \u22ef = f\u2082 x\n\u22a2 iSup f\u2081 = iSup f\u2082"}, {"line": "obtain rfl := propext pq", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b2 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : SupSet \u03b1\np : Prop\nf\u2081 f\u2082 : p \u2192 \u03b1\npq : p \u2194 p\nf : \u2200 (x : p), f\u2081 \u22ef = f\u2082 x\n\u22a2 iSup f\u2081 = iSup f\u2082"}, {"line": "congr with x", "tactic_state": "case e_s.h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b2 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : SupSet \u03b1\np : Prop\nf\u2081 f\u2082 : p \u2192 \u03b1\npq : p \u2194 p\nf : \u2200 (x : p), f\u2081 \u22ef = f\u2082 x\nx : p\n\u22a2 f\u2081 x = f\u2082 x"}, {"line": "apply f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_range' (g : \u03b2 \u2192 \u03b1) (f : \u03b9 \u2192 \u03b2) : \u2a06 b : range f, g b = \u2a06 i, g (f i) := by\n  rw [iSup]\n  rw [iSup]\n  rw [\u2190 image_eq_range]\n  rw [\u2190 range_comp']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\ninst\u271d\u00b3 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b2 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : SupSet \u03b1\ng : \u03b2 \u2192 \u03b1\nf : \u03b9 \u2192 \u03b2\n\u22a2 \u2a06 b, g \u2191b = \u2a06 i, g (f i)"}, {"line": "rw [iSup]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\ninst\u271d\u00b3 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b2 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : SupSet \u03b1\ng : \u03b2 \u2192 \u03b1\nf : \u03b9 \u2192 \u03b2\n\u22a2 sSup (range fun b => g \u2191b) = \u2a06 i, g (f i)"}, {"line": "rw [iSup]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\ninst\u271d\u00b3 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b2 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : SupSet \u03b1\ng : \u03b2 \u2192 \u03b1\nf : \u03b9 \u2192 \u03b2\n\u22a2 sSup (range fun b => g \u2191b) = sSup (range fun i => g (f i))"}, {"line": "rw [\u2190 image_eq_range]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\ninst\u271d\u00b3 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b2 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : SupSet \u03b1\ng : \u03b2 \u2192 \u03b1\nf : \u03b9 \u2192 \u03b2\n\u22a2 sSup (g '' range f) = sSup (range fun i => g (f i))"}, {"line": "rw [\u2190 range_comp']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sSup_image' {s : Set \u03b2} {f : \u03b2 \u2192 \u03b1} : sSup (f '' s) = \u2a06 a : s, f a := by\n  rw [iSup]\n  rw [image_eq_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b2 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : SupSet \u03b1\ns : Set \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 sSup (f '' s) = \u2a06 a, f \u2191a"}, {"line": "rw [iSup]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : CompleteSemilatticeSup \u03b1\ninst\u271d\u00b2 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : SupSet \u03b1\ns : Set \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 sSup (f '' s) = sSup (range fun a => f \u2191a)"}, {"line": "rw [image_eq_range]", "tactic_state": "No Goals!"}]}
