{"declaration": "theorem locallyCompactSpace_iff (h : X \u2243\u209c Y) :\n    LocallyCompactSpace X \u2194 LocallyCompactSpace Y := by\n  exact \u27e8fun _ => h.symm.isOpenEmbedding.locallyCompactSpace,\n    fun _ => h.isClosedEmbedding.locallyCompactSpace\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Homeomorph/Lemmas.lean", "context": {"open": ["Filter Function Set Topology"], "variables": ["{X Y W Z : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace W] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nh : X \u2243\u209c Y\n\u22a2 LocallyCompactSpace X \u2194 LocallyCompactSpace Y"}, {"line": "exact \u27e8fun _ => h.symm.isOpenEmbedding.locallyCompactSpace,\n    fun _ => h.isClosedEmbedding.locallyCompactSpace\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsHomeomorph.sigmaMap {\u03b9 \u03ba : Type*} {X : \u03b9 \u2192 Type*} {Y : \u03ba \u2192 Type*}\n    [\u2200 i, TopologicalSpace (X i)] [\u2200 i, TopologicalSpace (Y i)] {f : \u03b9 \u2192 \u03ba}\n    (hf : Bijective f) {g : (i : \u03b9) \u2192 X i \u2192 Y (f i)} (hg : \u2200 i, IsHomeomorph (g i)) :\n    IsHomeomorph (Sigma.map f g) := by\n  simp_rw [isHomeomorph_iff_isEmbedding_surjective,] at hg \u22a2\n  exact \u27e8(isEmbedding_sigmaMap hf.1).2 fun i \u21a6 (hg i).1, hf.2.sigma_map fun i \u21a6 (hg i).2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Homeomorph/Lemmas.lean", "context": {"open": ["Filter Function Set Topology"], "variables": ["{X Y W Z : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace W] [TopologicalSpace Z]", "{\u03b9 : Type*} {X : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (X i)]", "{\u03b9 : Type*}", "[DecidableEq \u03b9] (i : \u03b9)", "(Y)", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "(hf : IsHomeomorph f)", "(f) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "inst\u271d\u00b3 : TopologicalSpace sorry\ninst\u271d\u00b2 : TopologicalSpace sorry\n\u03b9 : Type u_8\n\u03ba : Type u_9\nX : \u03b9 \u2192 Type u_10\nY : \u03ba \u2192 Type u_11\ninst\u271d\u00b9 : (i : \u03b9) \u2192 TopologicalSpace (X i)\ninst\u271d : (i : \u03ba) \u2192 TopologicalSpace (Y i)\nf : \u03b9 \u2192 \u03ba\nhf : Bijective f\ng : (i : \u03b9) \u2192 X i \u2192 Y (f i)\nhg : \u2200 (i : \u03b9), IsHomeomorph (g i)\n\u22a2 IsHomeomorph (Sigma.map f g)"}, {"line": "simp_rw [isHomeomorph_iff_isEmbedding_surjective,] at hg \u22a2", "tactic_state": "inst\u271d\u00b3 : TopologicalSpace sorry\ninst\u271d\u00b2 : TopologicalSpace sorry\n\u03b9 : Type u_8\n\u03ba : Type u_9\nX : \u03b9 \u2192 Type u_10\nY : \u03ba \u2192 Type u_11\ninst\u271d\u00b9 : (i : \u03b9) \u2192 TopologicalSpace (X i)\ninst\u271d : (i : \u03ba) \u2192 TopologicalSpace (Y i)\nf : \u03b9 \u2192 \u03ba\nhf : Bijective f\ng : (i : \u03b9) \u2192 X i \u2192 Y (f i)\nhg : \u2200 (i : \u03b9), IsEmbedding (g i) \u2227 Surjective (g i)\n\u22a2 IsEmbedding (Sigma.map f g) \u2227 Surjective (Sigma.map f g)"}, {"line": "exact \u27e8(isEmbedding_sigmaMap hf.1).2 fun i \u21a6 (hg i).1, hf.2.sigma_map fun i \u21a6 (hg i).2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nullhomotopic.comp_right {f : C(X, Y)} (hf : f.Nullhomotopic) (g : C(Y, Z)) :\n    (g.comp f).Nullhomotopic := by\n  obtain \u27e8y, hy\u27e9 := hf\n  use g y\n  exact Homotopic.hcomp hy (Homotopic.refl g)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Homotopy/Contractible.lean", "context": {"open": [], "variables": ["{X Y Z : Type*} [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : C(X, Y)\nhf : f.Nullhomotopic\ng : C(Y, Z)\n\u22a2 (g.comp f).Nullhomotopic"}, {"line": "obtain \u27e8y, hy\u27e9 := hf", "tactic_state": "case intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : C(X, Y)\ng : C(Y, Z)\ny : Y\nhy : f.Homotopic (ContinuousMap.const X y)\n\u22a2 (g.comp f).Nullhomotopic"}, {"line": "use g y", "tactic_state": "case h\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : C(X, Y)\ng : C(Y, Z)\ny : Y\nhy : f.Homotopic (ContinuousMap.const X y)\n\u22a2 (g.comp f).Homotopic (ContinuousMap.const X (g y))"}, {"line": "exact Homotopic.hcomp hy (Homotopic.refl g)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nullhomotopic.comp_left {f : C(Y, Z)} (hf : f.Nullhomotopic) (g : C(X, Y)) :\n    (f.comp g).Nullhomotopic := by\n  obtain \u27e8y, hy\u27e9 := hf\n  use y\n  exact Homotopic.hcomp (Homotopic.refl g) hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Homotopy/Contractible.lean", "context": {"open": [], "variables": ["{X Y Z : Type*} [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : C(Y, Z)\nhf : f.Nullhomotopic\ng : C(X, Y)\n\u22a2 (f.comp g).Nullhomotopic"}, {"line": "obtain \u27e8y, hy\u27e9 := hf", "tactic_state": "case intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : C(Y, Z)\ng : C(X, Y)\ny : Z\nhy : f.Homotopic (ContinuousMap.const Y y)\n\u22a2 (f.comp g).Nullhomotopic"}, {"line": "use y", "tactic_state": "case h\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : C(Y, Z)\ng : C(X, Y)\ny : Z\nhy : f.Homotopic (ContinuousMap.const Y y)\n\u22a2 (f.comp g).Homotopic (ContinuousMap.const X y)"}, {"line": "exact Homotopic.hcomp (Homotopic.refl g) hy", "tactic_state": "No Goals!"}]}
{"declaration": "example {G G' : Type u} [TopologicalSpace G] [Group G] [IsTopologicalGroup G] [TopologicalSpace G']\n    [Group G'] [IsTopologicalGroup G'] : IsTopologicalGroup.hSpace (G \u00d7 G') = HSpace.prod G G' := by\n  simp only [HSpace.prod]\n  rfl\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Homotopy/HSpaces.lean", "context": {"open": ["scoped unitInterval", "Path ContinuousMap Set.Icc TopologicalSpace", "HSpaces"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G G' : Type u\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : IsTopologicalGroup G\ninst\u271d\u00b2 : TopologicalSpace G'\ninst\u271d\u00b9 : Group G'\ninst\u271d : IsTopologicalGroup G'\n\u22a2 IsTopologicalGroup.hSpace (G \u00d7 G') = HSpace.prod G G'"}, {"line": "simp only [HSpace.prod]", "tactic_state": "G G' : Type u\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : IsTopologicalGroup G\ninst\u271d\u00b2 : TopologicalSpace G'\ninst\u271d\u00b9 : Group G'\ninst\u271d : IsTopologicalGroup G'\n\u22a2 IsTopologicalGroup.hSpace (G \u00d7 G') =\n    { hmul := { toFun := fun p => (HSpace.hmul (p.1.1, p.2.1), HSpace.hmul (p.1.2, p.2.2)), continuous_toFun := \u22ef },\n      e := (HSpace.e, HSpace.e), hmul_e_e := \u22ef,\n      eHmul :=\n        { toFun := fun p => (HSpace.eHmul (p.1, p.2.1), HSpace.eHmul (p.1, p.2.2)), continuous_toFun := \u22ef,\n          map_zero_left := \u22ef, map_one_left := \u22ef, prop' := \u22ef },\n      hmulE :=\n        { toFun := fun p => (HSpace.hmulE (p.1, p.2.1), HSpace.hmulE (p.1, p.2.2)), continuous_toFun := \u22ef,\n          map_zero_left := \u22ef, map_one_left := \u22ef, prop' := \u22ef } }"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem delayReflLeft_zero (\u03b3 : Path x y) : delayReflLeft 0 \u03b3 = (Path.refl x).trans \u03b3 := by\n  simp only [delayReflLeft]\n  simp only [delayReflRight_zero]\n  simp only [trans_symm]\n  simp only [refl_symm]\n  simp only [Path.symm_symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Homotopy/HSpaces.lean", "context": {"open": ["scoped unitInterval", "Path ContinuousMap Set.Icc TopologicalSpace", "HSpaces", "unitInterval"], "variables": ["{X : Type u} [TopologicalSpace X] {x y : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx y : X\n\u03b3 : Path x y\n\u22a2 delayReflLeft 0 \u03b3 = (Path.refl x).trans \u03b3"}, {"line": "simp only [delayReflLeft]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx y : X\n\u03b3 : Path x y\n\u22a2 (delayReflRight 0 \u03b3.symm).symm = (Path.refl x).trans \u03b3"}, {"line": "simp only [delayReflRight_zero]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx y : X\n\u03b3 : Path x y\n\u22a2 (\u03b3.symm.trans (Path.refl x)).symm = (Path.refl x).trans \u03b3"}, {"line": "simp only [trans_symm]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx y : X\n\u03b3 : Path x y\n\u22a2 (Path.refl x).symm.trans \u03b3.symm.symm = (Path.refl x).trans \u03b3"}, {"line": "simp only [refl_symm]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx y : X\n\u03b3 : Path x y\n\u22a2 (Path.refl x).trans \u03b3.symm.symm = (Path.refl x).trans \u03b3"}, {"line": "simp only [Path.symm_symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem delayReflLeft_one (\u03b3 : Path x y) : delayReflLeft 1 \u03b3 = \u03b3 := by\n  simp only [delayReflLeft]\n  simp only [delayReflRight_one]\n  simp only [Path.symm_symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Homotopy/HSpaces.lean", "context": {"open": ["scoped unitInterval", "Path ContinuousMap Set.Icc TopologicalSpace", "HSpaces", "unitInterval"], "variables": ["{X : Type u} [TopologicalSpace X] {x y : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx y : X\n\u03b3 : Path x y\n\u22a2 delayReflLeft 1 \u03b3 = \u03b3"}, {"line": "simp only [delayReflLeft]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx y : X\n\u03b3 : Path x y\n\u22a2 (delayReflRight 1 \u03b3.symm).symm = \u03b3"}, {"line": "simp only [delayReflRight_one]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx y : X\n\u03b3 : Path x y\n\u22a2 \u03b3.symm.symm = \u03b3"}, {"line": "simp only [Path.symm_symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_mem_cantorSet : 0 \u2208 cantorSet := by simp [cantorSet, zero_mem_preCantorSet]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/CantorSet.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 \u2208 cantorSet"}, {"line": "simp [cantorSet, zero_mem_preCantorSet]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.subfield_eq_of_closed {K : Subfield \u2102} (hc : IsClosed (K : Set \u2102)) :\n    K = ofRealHom.fieldRange \u2228 K = \u22a4 := by\n  suffices range (ofReal : \u211d \u2192 \u2102) \u2286 K by\n    rw [range_subset_iff] at this\n    rw [\u2190 coe_algebraMap] at this\n    have :=\n      (Subalgebra.isSimpleOrder_of_finrank finrank_real_complex).eq_bot_or_eq_top\n        (Subfield.toIntermediateField K this).toSubalgebra\n    simp_rw [\u2190 SetLike.coe_set_eq, IntermediateField.coe_toSubalgebra] at this \u22a2\n    exact this\n  suffices range (ofReal : \u211d \u2192 \u2102) \u2286 closure (Set.range ((ofReal : \u211d \u2192 \u2102) \u2218 ((\u2191) : \u211a \u2192 \u211d))) by\n    refine subset_trans this ?_\n    rw [\u2190 IsClosed.closure_eq hc]\n    apply closure_mono\n    rintro _ \u27e8_, rfl\u27e9\n    simp only [Function.comp_apply]\n    simp only [ofReal_ratCast]\n    simp only [SetLike.mem_coe]\n    simp only [SubfieldClass.ratCast_mem]\n  nth_rw 1 [range_comp]\n  refine subset_trans ?_ (image_closure_subset_closure_image continuous_ofReal)\n  rw [DenseRange.closure_range Rat.isDenseEmbedding_coe_real.dense]\n  simp only [image_univ]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/Complex.lean", "context": {"open": ["Complex Set", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Subfield \u2102\nhc : IsClosed \u2191K\n\u22a2 K = ofRealHom.fieldRange \u2228 K = \u22a4"}, {"line": "suffices range (ofReal : \u211d \u2192 \u2102) \u2286 K by\n    rw [range_subset_iff] at this\n    rw [\u2190 coe_algebraMap] at this\n    have :=\n      (Subalgebra.isSimpleOrder_of_finrank finrank_real_complex).eq_bot_or_eq_top\n        (Subfield.toIntermediateField K this).toSubalgebra\n    simp_rw [\u2190 SetLike.coe_set_eq, IntermediateField.coe_toSubalgebra] at this \u22a2\n    exact this", "tactic_state": "K : Subfield \u2102\nhc : IsClosed \u2191K\n\u22a2 range ofReal \u2286 \u2191K"}, {"line": "suffices range (ofReal : \u211d \u2192 \u2102) \u2286 closure (Set.range ((ofReal : \u211d \u2192 \u2102) \u2218 ((\u2191) : \u211a \u2192 \u211d))) by\n    refine subset_trans this ?_\n    rw [\u2190 IsClosed.closure_eq hc]\n    apply closure_mono\n    rintro _ \u27e8_, rfl\u27e9\n    simp only [Function.comp_apply]\n    simp only [ofReal_ratCast]\n    simp only [SetLike.mem_coe]\n    simp only [SubfieldClass.ratCast_mem]", "tactic_state": "K : Subfield \u2102\nhc : IsClosed \u2191K\n\u22a2 range ofReal \u2286 closure (range (ofReal \u2218 Rat.cast))"}, {"line": "nth_rw 1 [range_comp]", "tactic_state": "K : Subfield \u2102\nhc : IsClosed \u2191K\n\u22a2 range ofReal \u2286 closure (ofReal '' range Rat.cast)"}, {"line": "refine subset_trans ?_ (image_closure_subset_closure_image continuous_ofReal)", "tactic_state": "K : Subfield \u2102\nhc : IsClosed \u2191K\n\u22a2 range ofReal \u2286 ofReal '' closure (range Rat.cast)"}, {"line": "rw [DenseRange.closure_range Rat.isDenseEmbedding_coe_real.dense]", "tactic_state": "K : Subfield \u2102\nhc : IsClosed \u2191K\n\u22a2 range ofReal \u2286 ofReal '' univ"}, {"line": "simp only [image_univ]", "tactic_state": "K : Subfield \u2102\nhc : IsClosed \u2191K\n\u22a2 range ofReal \u2286 range ofReal"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.uniformContinuous_ringHom_eq_id_or_conj (K : Subfield \u2102) {\u03c8 : K \u2192+* \u2102}\n    (hc : UniformContinuous \u03c8) : \u03c8.toFun = K.subtype \u2228 \u03c8.toFun = conj \u2218 K.subtype := by\n  letI : IsTopologicalDivisionRing \u2102 := IsTopologicalDivisionRing.mk\n  letI : IsTopologicalRing K.topologicalClosure :=\n    Subring.instIsTopologicalRing K.topologicalClosure.toSubring\n  set \u03b9 : K \u2192 K.topologicalClosure := \u21d1(Subfield.inclusion K.le_topologicalClosure)\n  have ui : IsUniformInducing \u03b9 :=\n    \u27e8by\n      rw [uniformity_subtype]\n      rw [uniformity_subtype]\n      rw [Filter.comap_comap]\n      congr \u27e9\n  let di := ui.isDenseInducing (?_ : DenseRange \u03b9)\n  \u00b7 -- ext\u03c8 : closure(K) \u2192+* \u2102 is the extension of \u03c8 : K \u2192+* \u2102\n    let ext\u03c8 := IsDenseInducing.extendRingHom ui di.dense hc\n    haveI h\u03c8 := (uniformContinuous_uniformly_extend ui di.dense hc).continuous\n    rcases Complex.subfield_eq_of_closed (Subfield.isClosed_topologicalClosure K) with h | h\n    \u00b7 left\n      let j := RingEquiv.subfieldCongr h\n      -- \u03c8\u2081 is the continuous ring hom `\u211d \u2192+* \u2102` constructed from `j : closure (K) \u2243+* \u211d`\n      -- and `ext\u03c8 : closure (K) \u2192+* \u2102`\n      let \u03c8\u2081 := RingHom.comp ext\u03c8 (RingHom.comp j.symm.toRingHom ofRealHom.rangeRestrict)\n      -- Porting note: was `by continuity!` and was used inline\n      have h\u03c8\u2081 : Continuous \u03c8\u2081 := by\n        simpa only [RingHom.coe_comp] using h\u03c8.comp ((continuous_algebraMap \u211d \u2102).subtype_mk _)\n      ext1 x\n      rsuffices \u27e8r, hr\u27e9 : \u2203 r : \u211d, ofRealHom.rangeRestrict r = j (\u03b9 x)\n      \u00b7 have :=\n          RingHom.congr_fun (ringHom_eq_ofReal_of_continuous h\u03c8\u2081) r\n        rw [RingHom.comp_apply] at this\n        rw [RingHom.comp_apply] at this\n        -- In `this`, the `DFunLike.coe` thinks it is applying a `(\u211d \u2192+* \u21a5ofRealHom.fieldRange)`,\n        -- while in `hr`, we have a `(\u211d \u2192+* \u21a5ofRealHom.range)`.\n        -- We could add a `@[simp]` lemma fixing this, but it breaks later steps of the proof.\n        erw [hr] at this\n        rw [RingEquiv.toRingHom_eq_coe] at this\n        convert this using 1\n        \u00b7 exact (IsDenseInducing.extend_eq di hc.continuous _).symm\n        \u00b7 rw [\u2190 ofRealHom.coe_rangeRestrict, hr]\n          rfl\n      obtain \u27e8r, hr\u27e9 := SetLike.coe_mem (j (\u03b9 x))\n      exact \u27e8r, Subtype.ext hr\u27e9\n    \u00b7 -- \u03c8\u2081 is the continuous ring hom `\u2102 \u2192+* \u2102` constructed from `closure (K) \u2243+* \u2102`\n      -- and `ext\u03c8 : closure (K) \u2192+* \u2102`\n      let \u03c8\u2081 :=\n        RingHom.comp ext\u03c8\n          (RingHom.comp (RingEquiv.subfieldCongr h).symm.toRingHom\n            (@Subfield.topEquiv \u2102 _).symm.toRingHom)\n      -- Porting note: was `by continuity!` and was used inline\n      have h\u03c8\u2081 : Continuous \u03c8\u2081 := by\n        simpa only [RingHom.coe_comp] using h\u03c8.comp (continuous_id.subtype_mk _)\n      rcases ringHom_eq_id_or_conj_of_continuous h\u03c8\u2081 with h | h\n      \u00b7 left\n        ext1 z\n        convert RingHom.congr_fun h z using 1\n        exact (IsDenseInducing.extend_eq di hc.continuous z).symm\n      \u00b7 right\n        ext1 z\n        convert RingHom.congr_fun h z using 1\n        exact (IsDenseInducing.extend_eq di hc.continuous z).symm\n  \u00b7 let j : { x // x \u2208 closure (id '' { x | (K : Set \u2102) x }) } \u2192 (K.topologicalClosure : Set \u2102) :=\n      fun x =>\n      \u27e8x, by\n        convert x.prop\n        simp only [id]\n        simp only [Set.image_id']\n        rfl \u27e9\n    convert DenseRange.comp (Function.Surjective.denseRange _)\n      (IsDenseEmbedding.id.subtype (K : Set \u2102)).dense (by continuity : Continuous j)\n    rintro \u27e8y, hy\u27e9\n    use\n      \u27e8y, by\n        convert hy\n        simp only [id]\n        simp only [Set.image_id']\n        rfl \u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/Complex.lean", "context": {"open": ["Complex Set", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Subfield \u2102\n\u03c8 : \u21a5K \u2192+* \u2102\nhc : UniformContinuous \u21d1\u03c8\n\u22a2 (\u2191\u2191\u03c8).toFun = \u21d1K.subtype \u2228 (\u2191\u2191\u03c8).toFun = \u21d1(starRingEnd \u2102) \u2218 \u21d1K.subtype"}, {"line": "letI : IsTopologicalDivisionRing \u2102 := IsTopologicalDivisionRing.mk", "tactic_state": "K : Subfield \u2102\n\u03c8 : \u21a5K \u2192+* \u2102\nhc : UniformContinuous \u21d1\u03c8\nthis : IsTopologicalDivisionRing \u2102 :=\n  { toIsTopologicalRing := IsTopologicalDivisionRing.toIsTopologicalRing,\n    toHasContinuousInv\u2080 := IsTopologicalDivisionRing.toHasContinuousInv\u2080 }\n\u22a2 (\u2191\u2191\u03c8).toFun = \u21d1K.subtype \u2228 (\u2191\u2191\u03c8).toFun = \u21d1(starRingEnd \u2102) \u2218 \u21d1K.subtype"}, {"line": "letI : IsTopologicalRing K.topologicalClosure :=\n    Subring.instIsTopologicalRing K.topologicalClosure.toSubring", "tactic_state": "K : Subfield \u2102\n\u03c8 : \u21a5K \u2192+* \u2102\nhc : UniformContinuous \u21d1\u03c8\nthis\u271d : IsTopologicalDivisionRing \u2102 :=\n  { toIsTopologicalRing := IsTopologicalDivisionRing.toIsTopologicalRing,\n    toHasContinuousInv\u2080 := IsTopologicalDivisionRing.toHasContinuousInv\u2080 }\nthis : IsTopologicalRing \u21a5K.topologicalClosure := Subring.instIsTopologicalRing K.topologicalClosure.toSubring\n\u22a2 (\u2191\u2191\u03c8).toFun = \u21d1K.subtype \u2228 (\u2191\u2191\u03c8).toFun = \u21d1(starRingEnd \u2102) \u2218 \u21d1K.subtype"}, {"line": "set \u03b9 : K \u2192 K.topologicalClosure := \u21d1(Subfield.inclusion K.le_topologicalClosure)", "tactic_state": "K : Subfield \u2102\n\u03c8 : \u21a5K \u2192+* \u2102\nhc : UniformContinuous \u21d1\u03c8\nthis\u271d : IsTopologicalDivisionRing \u2102 :=\n  { toIsTopologicalRing := IsTopologicalDivisionRing.toIsTopologicalRing,\n    toHasContinuousInv\u2080 := IsTopologicalDivisionRing.toHasContinuousInv\u2080 }\nthis : IsTopologicalRing \u21a5K.topologicalClosure := Subring.instIsTopologicalRing K.topologicalClosure.toSubring\n\u03b9 : \u21a5K \u2192 \u21a5K.topologicalClosure := \u21d1(Subfield.inclusion \u22ef)\n\u22a2 (\u2191\u2191\u03c8).toFun = \u21d1K.subtype \u2228 (\u2191\u2191\u03c8).toFun = \u21d1(starRingEnd \u2102) \u2218 \u21d1K.subtype"}, {"line": "have ui : IsUniformInducing \u03b9 :=\n    \u27e8by\n      rw [uniformity_subtype]\n      rw [uniformity_subtype]\n      rw [Filter.comap_comap]\n      congr \u27e9", "tactic_state": "K : Subfield \u2102\n\u03c8 : \u21a5K \u2192+* \u2102\nhc : UniformContinuous \u21d1\u03c8\nthis\u271d : IsTopologicalDivisionRing \u2102 :=\n  { toIsTopologicalRing := IsTopologicalDivisionRing.toIsTopologicalRing,\n    toHasContinuousInv\u2080 := IsTopologicalDivisionRing.toHasContinuousInv\u2080 }\nthis : IsTopologicalRing \u21a5K.topologicalClosure := Subring.instIsTopologicalRing K.topologicalClosure.toSubring\n\u03b9 : \u21a5K \u2192 \u21a5K.topologicalClosure := \u21d1(Subfield.inclusion \u22ef)\nui : IsUniformInducing \u03b9\n\u22a2 (\u2191\u2191\u03c8).toFun = \u21d1K.subtype \u2228 (\u2191\u2191\u03c8).toFun = \u21d1(starRingEnd \u2102) \u2218 \u21d1K.subtype"}, {"line": "let di := ui.isDenseInducing (?_ : DenseRange \u03b9)", "tactic_state": "case refine_2\nK : Subfield \u2102\n\u03c8 : \u21a5K \u2192+* \u2102\nhc : UniformContinuous \u21d1\u03c8\nthis\u271d : IsTopologicalDivisionRing \u2102 :=\n  { toIsTopologicalRing := IsTopologicalDivisionRing.toIsTopologicalRing,\n    toHasContinuousInv\u2080 := IsTopologicalDivisionRing.toHasContinuousInv\u2080 }\nthis : IsTopologicalRing \u21a5K.topologicalClosure := Subring.instIsTopologicalRing K.topologicalClosure.toSubring\n\u03b9 : \u21a5K \u2192 \u21a5K.topologicalClosure := \u21d1(Subfield.inclusion \u22ef)\nui : IsUniformInducing \u03b9\ndi : IsDenseInducing \u03b9 := IsUniformInducing.isDenseInducing ui ?refine_1\n\u22a2 (\u2191\u2191\u03c8).toFun = \u21d1K.subtype \u2228 (\u2191\u2191\u03c8).toFun = \u21d1(starRingEnd \u2102) \u2218 \u21d1K.subtype\n---\ncase refine_1\nK : Subfield \u2102\n\u03c8 : \u21a5K \u2192+* \u2102\nhc : UniformContinuous \u21d1\u03c8\nthis\u271d : IsTopologicalDivisionRing \u2102 :=\n  { toIsTopologicalRing := IsTopologicalDivisionRing.toIsTopologicalRing,\n    toHasContinuousInv\u2080 := IsTopologicalDivisionRing.toHasContinuousInv\u2080 }\nthis : IsTopologicalRing \u21a5K.topologicalClosure := Subring.instIsTopologicalRing K.topologicalClosure.toSubring\n\u03b9 : \u21a5K \u2192 \u21a5K.topologicalClosure := \u21d1(Subfield.inclusion \u22ef)\nui : IsUniformInducing \u03b9\n\u22a2 DenseRange \u03b9"}, {"line": "\u00b7 -- ext\u03c8 : closure(K) \u2192+* \u2102 is the extension of \u03c8 : K \u2192+* \u2102\n    let ext\u03c8 := IsDenseInducing.extendRingHom ui di.dense hc\n    haveI h\u03c8 := (uniformContinuous_uniformly_extend ui di.dense hc).continuous\n    rcases Complex.subfield_eq_of_closed (Subfield.isClosed_topologicalClosure K) with h | h\n    \u00b7 left\n      let j := RingEquiv.subfieldCongr h\n      let \u03c8\u2081 := RingHom.comp ext\u03c8 (RingHom.comp j.symm.toRingHom ofRealHom.rangeRestrict)\n      have h\u03c8\u2081 : Continuous \u03c8\u2081 := by\n        simpa only [RingHom.coe_comp] using h\u03c8.comp ((continuous_algebraMap \u211d \u2102).subtype_mk _)\n      ext1 x\n      rsuffices \u27e8r, hr\u27e9 : \u2203 r : \u211d, ofRealHom.rangeRestrict r = j (\u03b9 x)\n      \u00b7 have :=\n          RingHom.congr_fun (ringHom_eq_ofReal_of_continuous h\u03c8\u2081) r\n        rw [RingHom.comp_apply] at this\n        rw [RingHom.comp_apply] at this\n        erw [hr] at this\n        rw [RingEquiv.toRingHom_eq_coe] at this\n        convert this using 1\n        \u00b7 exact (IsDenseInducing.extend_eq di hc.continuous _).symm\n        \u00b7 rw [\u2190 ofRealHom.coe_rangeRestrict, hr]\n          rfl\n      obtain \u27e8r, hr\u27e9 := SetLike.coe_mem (j (\u03b9 x))\n      exact \u27e8r, Subtype.ext hr\u27e9\n    \u00b7 -- \u03c8\u2081 is the continuous ring hom `\u2102 \u2192+* \u2102` constructed from `closure (K) \u2243+* \u2102`\n      let \u03c8\u2081 :=\n        RingHom.comp ext\u03c8\n          (RingHom.comp (RingEquiv.subfieldCongr h).symm.toRingHom\n            (@Subfield.topEquiv \u2102 _).symm.toRingHom)\n      have h\u03c8\u2081 : Continuous \u03c8\u2081 := by\n        simpa only [RingHom.coe_comp] using h\u03c8.comp (continuous_id.subtype_mk _)\n      rcases ringHom_eq_id_or_conj_of_continuous h\u03c8\u2081 with h | h\n      \u00b7 left\n        ext1 z\n        convert RingHom.congr_fun h z using 1\n        exact (IsDenseInducing.extend_eq di hc.continuous z).symm\n      \u00b7 right\n        ext1 z\n        convert RingHom.congr_fun h z using 1\n        exact (IsDenseInducing.extend_eq di hc.continuous z).symm", "tactic_state": "case refine_1\nK : Subfield \u2102\n\u03c8 : \u21a5K \u2192+* \u2102\nhc : UniformContinuous \u21d1\u03c8\nthis\u271d : IsTopologicalDivisionRing \u2102 :=\n  { toIsTopologicalRing := IsTopologicalDivisionRing.toIsTopologicalRing,\n    toHasContinuousInv\u2080 := IsTopologicalDivisionRing.toHasContinuousInv\u2080 }\nthis : IsTopologicalRing \u21a5K.topologicalClosure := Subring.instIsTopologicalRing K.topologicalClosure.toSubring\n\u03b9 : \u21a5K \u2192 \u21a5K.topologicalClosure := \u21d1(Subfield.inclusion \u22ef)\nui : IsUniformInducing \u03b9\n\u22a2 DenseRange \u03b9"}, {"line": "\u00b7 let j : { x // x \u2208 closure (id '' { x | (K : Set \u2102) x }) } \u2192 (K.topologicalClosure : Set \u2102) :=\n      fun x =>\n      \u27e8x, by\n        convert x.prop\n        simp only [id]\n        simp only [Set.image_id']\n        rfl \u27e9\n    convert DenseRange.comp (Function.Surjective.denseRange _)\n      (IsDenseEmbedding.id.subtype (K : Set \u2102)).dense (by continuity : Continuous j)\n    rintro \u27e8y, hy\u27e9\n    use\n      \u27e8y, by\n        convert hy\n        simp only [id]\n        simp only [Set.image_id']\n        rfl \u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_natCast (n : \u2115) : \ud835\udcdd (n : \u2115\u221e) = pure (n : \u2115\u221e) := by\n  simp [\u2190 isOpenEmbedding_natCast.map_nhds_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENat.lean", "context": {"open": ["Filter Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 nhds \u2191n = pure \u2191n"}, {"line": "simp [\u2190 isOpenEmbedding_natCast.map_nhds_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_singleton {x : \u2115\u221e} (hx : x \u2260 \u22a4) : IsOpen {x} := by\n  rw [isOpen_singleton_iff_nhds_eq_pure]\n  rw [ENat.nhds_eq_pure hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENat.lean", "context": {"open": ["Filter Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\u221e\nhx : x \u2260 \u22a4\n\u22a2 IsOpen {x}"}, {"line": "rw [isOpen_singleton_iff_nhds_eq_pure]", "tactic_state": "x : \u2115\u221e\nhx : x \u2260 \u22a4\n\u22a2 nhds x = pure x"}, {"line": "rw [ENat.nhds_eq_pure hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_nhds_iff {x : \u2115\u221e} {s : Set \u2115\u221e} (hx : x \u2260 \u22a4) : s \u2208 \ud835\udcdd x \u2194 x \u2208 s := by\n  simp [hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENat.lean", "context": {"open": ["Filter Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\u221e\ns : Set \u2115\u221e\nhx : x \u2260 \u22a4\n\u22a2 s \u2208 nhds x \u2194 x \u2208 s"}, {"line": "simp [hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_nhds_top_iff_natCast_lt {\u03b1 : Type*} {l : Filter \u03b1} {f : \u03b1 \u2192 \u2115\u221e} :\n    Tendsto f l (\ud835\udcdd \u22a4) \u2194 \u2200 n : \u2115, \u2200\u1da0 a in l, n < f a := by\n  simp_rw [nhds_top_order, lt_top_iff_ne_top, tendsto_iInf, tendsto_principal]\n  exact Option.forall_ne_none\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENat.lean", "context": {"open": ["Filter Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\nf : \u03b1 \u2192 \u2115\u221e\n\u22a2 Tendsto f l (nhds \u22a4) \u2194 \u2200 (n : \u2115), \u2200\u1da0 (a : \u03b1) in l, \u2191n < f a"}, {"line": "simp_rw [nhds_top_order, lt_top_iff_ne_top, tendsto_iInf, tendsto_principal]", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\nf : \u03b1 \u2192 \u2115\u221e\n\u22a2 (\u2200 (i : \u2115\u221e), i \u2260 \u22a4 \u2192 \u2200\u1da0 (a : \u03b1) in l, f a \u2208 Ioi i) \u2194 \u2200 (n : \u2115), \u2200\u1da0 (a : \u03b1) in l, \u2191n < f a"}, {"line": "exact Option.forall_ne_none", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cofinite_eq : (cofinite : Filter \u2124) = atBot \u2294 atTop := by\n  rw [\u2190 cocompact_eq_cofinite]\n  rw [cocompact_eq_atBot_atTop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/Int.lean", "context": {"open": ["Filter Metric Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 cofinite = atBot \u2294 atTop"}, {"line": "rw [\u2190 cocompact_eq_cofinite]", "tactic_state": "\u22a2 cocompact \u2124 = atBot \u2294 atTop"}, {"line": "rw [cocompact_eq_atBot_atTop]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dense_irrational : Dense { x : \u211d | Irrational x } := by\n  refine Real.isTopologicalBasis_Ioo_rat.dense_iff.2 ?_\n  simp only [mem_iUnion]\n  simp only [mem_singleton_iff]\n  simp only [exists_prop]\n  simp only [forall_exists_index]\n  simp only [and_imp]\n  rintro _ a b hlt rfl _\n  rw [inter_comm]\n  exact exists_irrational_btwn (Rat.cast_lt.2 hlt)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/Irrational.lean", "context": {"open": ["Set Filter Metric", "Filter Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Dense {x | Irrational x}"}, {"line": "refine Real.isTopologicalBasis_Ioo_rat.dense_iff.2 ?_", "tactic_state": "\u22a2 \u2200 o \u2208 \u22c3 a, \u22c3 b, \u22c3 (_ : a < b), {Ioo \u2191a \u2191b}, o.Nonempty \u2192 (o \u2229 {x | Irrational x}).Nonempty"}, {"line": "simp only [mem_iUnion]", "tactic_state": "\u22a2 \u2200 (o : Set \u211d), (\u2203 i i_1, \u2203 (_ : i < i_1), o \u2208 {Ioo \u2191i \u2191i_1}) \u2192 o.Nonempty \u2192 (o \u2229 {x | Irrational x}).Nonempty"}, {"line": "simp only [mem_singleton_iff]", "tactic_state": "\u22a2 \u2200 (o : Set \u211d), (\u2203 i i_1, \u2203 (_ : i < i_1), o = Ioo \u2191i \u2191i_1) \u2192 o.Nonempty \u2192 (o \u2229 {x | Irrational x}).Nonempty"}, {"line": "simp only [exists_prop]", "tactic_state": "\u22a2 \u2200 (o : Set \u211d), (\u2203 i i_1, i < i_1 \u2227 o = Ioo \u2191i \u2191i_1) \u2192 o.Nonempty \u2192 (o \u2229 {x | Irrational x}).Nonempty"}, {"line": "simp only [forall_exists_index]", "tactic_state": "\u22a2 \u2200 (o : Set \u211d) (x x_1 : \u211a), x < x_1 \u2227 o = Ioo \u2191x \u2191x_1 \u2192 o.Nonempty \u2192 (o \u2229 {x | Irrational x}).Nonempty"}, {"line": "simp only [and_imp]", "tactic_state": "\u22a2 \u2200 (o : Set \u211d) (x x_1 : \u211a), x < x_1 \u2192 o = Ioo \u2191x \u2191x_1 \u2192 o.Nonempty \u2192 (o \u2229 {x | Irrational x}).Nonempty"}, {"line": "rintro _ a b hlt rfl _", "tactic_state": "a b : \u211a\nhlt : a < b\na\u271d : (Ioo \u2191a \u2191b).Nonempty\n\u22a2 (Ioo \u2191a \u2191b \u2229 {x | Irrational x}).Nonempty"}, {"line": "rw [inter_comm]", "tactic_state": "a b : \u211a\nhlt : a < b\na\u271d : (Ioo \u2191a \u2191b).Nonempty\n\u22a2 ({x | Irrational x} \u2229 Ioo \u2191a \u2191b).Nonempty"}, {"line": "exact exists_irrational_btwn (Rat.cast_lt.2 hlt)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_forall_le_dist_cast_div (hx : Irrational x) (n : \u2115) :\n    \u2200\u1da0 \u03b5 : \u211d in \ud835\udcdd 0, \u2200 m : \u2124, \u03b5 \u2264 dist x (m / n) := by\n  have A : IsClosed (range (fun m => (n : \u211d)\u207b\u00b9 * m : \u2124 \u2192 \u211d)) :=\n    ((isClosedMap_smul\u2080 (n\u207b\u00b9 : \u211d)).comp Int.isClosedEmbedding_coe_real.isClosedMap).isClosed_range\n  have B : x \u2209 range (fun m => (n : \u211d)\u207b\u00b9 * m : \u2124 \u2192 \u211d) := by\n    rintro \u27e8m, rfl\u27e9\n    simp at hx\n  rcases Metric.mem_nhds_iff.1 (A.isOpen_compl.mem_nhds B) with \u27e8\u03b5, \u03b50, h\u03b5\u27e9\n  refine (ge_mem_nhds \u03b50).mono fun \u03b4 h\u03b4 m => not_lt.1 fun hlt => ?_\n  rw [dist_comm] at hlt\n  refine h\u03b5 (ball_subset_ball h\u03b4 hlt) \u27e8m, ?_\u27e9\n  simp [div_eq_inv_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/Irrational.lean", "context": {"open": ["Set Filter Metric", "Filter Topology"], "variables": ["{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : Irrational x\nn : \u2115\n\u22a2 \u2200\u1da0 (\u03b5 : \u211d) in nhds 0, \u2200 (m : \u2124), \u03b5 \u2264 dist x (\u2191m / \u2191n)"}, {"line": "have A : IsClosed (range (fun m => (n : \u211d)\u207b\u00b9 * m : \u2124 \u2192 \u211d)) :=\n    ((isClosedMap_smul\u2080 (n\u207b\u00b9 : \u211d)).comp Int.isClosedEmbedding_coe_real.isClosedMap).isClosed_range", "tactic_state": "x : \u211d\nhx : Irrational x\nn : \u2115\nA : IsClosed (range fun m => (\u2191n)\u207b\u00b9 * \u2191m)\n\u22a2 \u2200\u1da0 (\u03b5 : \u211d) in nhds 0, \u2200 (m : \u2124), \u03b5 \u2264 dist x (\u2191m / \u2191n)"}, {"line": "have B : x \u2209 range (fun m => (n : \u211d)\u207b\u00b9 * m : \u2124 \u2192 \u211d) := by\n    rintro \u27e8m, rfl\u27e9\n    simp at hx", "tactic_state": "x : \u211d\nhx : Irrational x\nn : \u2115\nA : IsClosed (range fun m => (\u2191n)\u207b\u00b9 * \u2191m)\nB : x \u2209 range fun m => (\u2191n)\u207b\u00b9 * \u2191m\n\u22a2 \u2200\u1da0 (\u03b5 : \u211d) in nhds 0, \u2200 (m : \u2124), \u03b5 \u2264 dist x (\u2191m / \u2191n)"}, {"line": "rcases Metric.mem_nhds_iff.1 (A.isOpen_compl.mem_nhds B) with \u27e8\u03b5, \u03b50, h\u03b5\u27e9", "tactic_state": "case intro.intro\nx : \u211d\nhx : Irrational x\nn : \u2115\nA : IsClosed (range fun m => (\u2191n)\u207b\u00b9 * \u2191m)\nB : x \u2209 range fun m => (\u2191n)\u207b\u00b9 * \u2191m\n\u03b5 : \u211d\n\u03b50 : \u03b5 > 0\nh\u03b5 : ball x \u03b5 \u2286 (range fun m => (\u2191n)\u207b\u00b9 * \u2191m)\u1d9c\n\u22a2 \u2200\u1da0 (\u03b5 : \u211d) in nhds 0, \u2200 (m : \u2124), \u03b5 \u2264 dist x (\u2191m / \u2191n)"}, {"line": "refine (ge_mem_nhds \u03b50).mono fun \u03b4 h\u03b4 m => not_lt.1 fun hlt => ?_", "tactic_state": "case intro.intro\nx : \u211d\nhx : Irrational x\nn : \u2115\nA : IsClosed (range fun m => (\u2191n)\u207b\u00b9 * \u2191m)\nB : x \u2209 range fun m => (\u2191n)\u207b\u00b9 * \u2191m\n\u03b5 : \u211d\n\u03b50 : \u03b5 > 0\nh\u03b5 : ball x \u03b5 \u2286 (range fun m => (\u2191n)\u207b\u00b9 * \u2191m)\u1d9c\n\u03b4 : \u211d\nh\u03b4 : \u03b4 \u2264 \u03b5\nm : \u2124\nhlt : dist x (\u2191m / \u2191n) < \u03b4\n\u22a2 False"}, {"line": "rw [dist_comm] at hlt", "tactic_state": "case intro.intro\nx : \u211d\nhx : Irrational x\nn : \u2115\nA : IsClosed (range fun m => (\u2191n)\u207b\u00b9 * \u2191m)\nB : x \u2209 range fun m => (\u2191n)\u207b\u00b9 * \u2191m\n\u03b5 : \u211d\n\u03b50 : \u03b5 > 0\nh\u03b5 : ball x \u03b5 \u2286 (range fun m => (\u2191n)\u207b\u00b9 * \u2191m)\u1d9c\n\u03b4 : \u211d\nh\u03b4 : \u03b4 \u2264 \u03b5\nm : \u2124\nhlt : dist (\u2191m / \u2191n) x < \u03b4\n\u22a2 False"}, {"line": "refine h\u03b5 (ball_subset_ball h\u03b4 hlt) \u27e8m, ?_\u27e9", "tactic_state": "case intro.intro\nx : \u211d\nhx : Irrational x\nn : \u2115\nA : IsClosed (range fun m => (\u2191n)\u207b\u00b9 * \u2191m)\nB : x \u2209 range fun m => (\u2191n)\u207b\u00b9 * \u2191m\n\u03b5 : \u211d\n\u03b50 : \u03b5 > 0\nh\u03b5 : ball x \u03b5 \u2286 (range fun m => (\u2191n)\u207b\u00b9 * \u2191m)\u1d9c\n\u03b4 : \u211d\nh\u03b4 : \u03b4 \u2264 \u03b5\nm : \u2124\nhlt : dist (\u2191m / \u2191n) x < \u03b4\n\u22a2 (fun m => (\u2191n)\u207b\u00b9 * \u2191m) m = \u2191m / \u2191n"}, {"line": "simp [div_eq_inv_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_coe_Ico (a : AddCircle p) : \u2203 b, b \u2208 Ico 0 p \u2227 \u2191b = a := by\n  let b := QuotientAddGroup.equivIcoMod hp.out 0 a\n  exact \u27e8b.1, by simpa only [zero_add] using b.2,\n    (QuotientAddGroup.equivIcoMod hp.out 0).symm_apply_apply a\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/AddCircle.lean", "context": {"open": ["AddCommGroup Set Function AddSubgroup TopologicalSpace", "Topology"], "variables": ["{\ud835\udd5c B : Type*}", "[AddCommGroup \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsOrderedAddMonoid \ud835\udd5c] [Archimedean \ud835\udd5c]", "{x}", "[AddCommGroup \ud835\udd5c] (p : \ud835\udd5c)", "[LinearOrder \ud835\udd5c] [IsOrderedAddMonoid \ud835\udd5c]", "[hp : Fact (0 < p)] (a : \ud835\udd5c) [Archimedean \ud835\udd5c]", "{p a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2077 : AddCommGroup \ud835\udd5c\ninst\u271d\u2076 : LinearOrder \ud835\udd5c\ninst\u271d\u2075 : IsOrderedAddMonoid \ud835\udd5c\ninst\u271d\u2074 : Archimedean \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup \ud835\udd5c\np : \ud835\udd5c\ninst\u271d\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9 : IsOrderedAddMonoid \ud835\udd5c\nhp : Fact (0 < p)\ninst\u271d : Archimedean \ud835\udd5c\na : AddCircle p\n\u22a2 \u2203 b \u2208 Ico 0 p, \u2191b = a"}, {"line": "let b := QuotientAddGroup.equivIcoMod hp.out 0 a", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2077 : AddCommGroup \ud835\udd5c\ninst\u271d\u2076 : LinearOrder \ud835\udd5c\ninst\u271d\u2075 : IsOrderedAddMonoid \ud835\udd5c\ninst\u271d\u2074 : Archimedean \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup \ud835\udd5c\np : \ud835\udd5c\ninst\u271d\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9 : IsOrderedAddMonoid \ud835\udd5c\nhp : Fact (0 < p)\ninst\u271d : Archimedean \ud835\udd5c\na : AddCircle p\nb : \u2191(Ico sorry (sorry + p)) := sorry\n\u22a2 \u2203 b \u2208 Ico 0 p, \u2191b = a"}, {"line": "exact \u27e8b.1, by simpa only [zero_add] using b.2,\n    (QuotientAddGroup.equivIcoMod hp.out 0).symm_apply_apply a\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_image_Ico_eq : ((\u2191) : \ud835\udd5c \u2192 AddCircle p) '' Ico a (a + p) = univ := by\n  rw [image_eq_range]\n  exact (equivIco p a).symm.range_eq_univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/AddCircle.lean", "context": {"open": ["AddCommGroup Set Function AddSubgroup TopologicalSpace", "Topology"], "variables": ["{\ud835\udd5c B : Type*}", "[AddCommGroup \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsOrderedAddMonoid \ud835\udd5c] [Archimedean \ud835\udd5c]", "{x}", "[AddCommGroup \ud835\udd5c] (p : \ud835\udd5c)", "[LinearOrder \ud835\udd5c] [IsOrderedAddMonoid \ud835\udd5c]", "[hp : Fact (0 < p)] (a : \ud835\udd5c) [Archimedean \ud835\udd5c]", "{p a}", "(p a)", "[TopologicalSpace \ud835\udd5c]", "[OrderTopology \ud835\udd5c] {x : AddCircle p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2079 : AddCommGroup \ud835\udd5c\ninst\u271d\u2078 : LinearOrder \ud835\udd5c\ninst\u271d\u2077 : IsOrderedAddMonoid \ud835\udd5c\ninst\u271d\u2076 : Archimedean \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup \ud835\udd5c\np : \ud835\udd5c\ninst\u271d\u2074 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3 : IsOrderedAddMonoid \ud835\udd5c\nhp : Fact (0 < p)\na : \ud835\udd5c\ninst\u271d\u00b2 : Archimedean \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : OrderTopology \ud835\udd5c\n\u22a2 QuotientAddGroup.mk '' Ico a (a + p) = univ"}, {"line": "rw [image_eq_range]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2079 : AddCommGroup \ud835\udd5c\ninst\u271d\u2078 : LinearOrder \ud835\udd5c\ninst\u271d\u2077 : IsOrderedAddMonoid \ud835\udd5c\ninst\u271d\u2076 : Archimedean \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup \ud835\udd5c\np : \ud835\udd5c\ninst\u271d\u2074 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3 : IsOrderedAddMonoid \ud835\udd5c\nhp : Fact (0 < p)\na : \ud835\udd5c\ninst\u271d\u00b2 : Archimedean \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : OrderTopology \ud835\udd5c\n\u22a2 (range fun x => \u2191\u2191x) = univ"}, {"line": "exact (equivIco p a).symm.range_eq_univ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_image_Ioc_eq : ((\u2191) : \ud835\udd5c \u2192 AddCircle p) '' Ioc a (a + p) = univ := by\n  rw [image_eq_range]\n  exact (equivIoc p a).symm.range_eq_univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/AddCircle.lean", "context": {"open": ["AddCommGroup Set Function AddSubgroup TopologicalSpace", "Topology"], "variables": ["{\ud835\udd5c B : Type*}", "[AddCommGroup \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsOrderedAddMonoid \ud835\udd5c] [Archimedean \ud835\udd5c]", "{x}", "[AddCommGroup \ud835\udd5c] (p : \ud835\udd5c)", "[LinearOrder \ud835\udd5c] [IsOrderedAddMonoid \ud835\udd5c]", "[hp : Fact (0 < p)] (a : \ud835\udd5c) [Archimedean \ud835\udd5c]", "{p a}", "(p a)", "[TopologicalSpace \ud835\udd5c]", "[OrderTopology \ud835\udd5c] {x : AddCircle p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2079 : AddCommGroup \ud835\udd5c\ninst\u271d\u2078 : LinearOrder \ud835\udd5c\ninst\u271d\u2077 : IsOrderedAddMonoid \ud835\udd5c\ninst\u271d\u2076 : Archimedean \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup \ud835\udd5c\np : \ud835\udd5c\ninst\u271d\u2074 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3 : IsOrderedAddMonoid \ud835\udd5c\nhp : Fact (0 < p)\na : \ud835\udd5c\ninst\u271d\u00b2 : Archimedean \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : OrderTopology \ud835\udd5c\n\u22a2 QuotientAddGroup.mk '' Ioc a (a + p) = univ"}, {"line": "rw [image_eq_range]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2079 : AddCommGroup \ud835\udd5c\ninst\u271d\u2078 : LinearOrder \ud835\udd5c\ninst\u271d\u2077 : IsOrderedAddMonoid \ud835\udd5c\ninst\u271d\u2076 : Archimedean \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup \ud835\udd5c\np : \ud835\udd5c\ninst\u271d\u2074 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3 : IsOrderedAddMonoid \ud835\udd5c\nhp : Fact (0 < p)\na : \ud835\udd5c\ninst\u271d\u00b2 : Archimedean \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : OrderTopology \ud835\udd5c\n\u22a2 (range fun x => \u2191\u2191x) = univ"}, {"line": "exact (equivIoc p a).symm.range_eq_univ", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toAddCircle_intCast (j : \u2124) :\n    toAddCircle (j : ZMod N) = \u2191(j / N : \u211d) := by\n  simp [toAddCircle]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/AddCircle.lean", "context": {"open": ["AddCommGroup Set Function AddSubgroup TopologicalSpace", "Topology"], "variables": ["{\ud835\udd5c B : Type*}", "[AddCommGroup \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsOrderedAddMonoid \ud835\udd5c] [Archimedean \ud835\udd5c]", "{x}", "[AddCommGroup \ud835\udd5c] (p : \ud835\udd5c)", "[LinearOrder \ud835\udd5c] [IsOrderedAddMonoid \ud835\udd5c]", "[hp : Fact (0 < p)] (a : \ud835\udd5c) [Archimedean \ud835\udd5c]", "{p a}", "(p a)", "[TopologicalSpace \ud835\udd5c]", "[OrderTopology \ud835\udd5c] {x : AddCircle p}", "[Field \ud835\udd5c] (p q : \ud835\udd5c)", "[LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "[LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [hp : Fact (0 < p)]", "[FloorRing \ud835\udd5c]", "{p}", "(p) in", "(p)", "(p : \u211d)", "[AddCommGroup \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsOrderedAddMonoid \ud835\udd5c] (p a : \ud835\udd5c)", "[Archimedean \ud835\udd5c]", "{p a}", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{N : \u2115} [NeZero N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\nx\u271d : Sort u_3\ntoAddCircle : x\u271d\nj : \u2124\n\u22a2 sorry = \u2191j / \u2191N"}, {"line": "simp [toAddCircle]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\nx\u271d : Sort u_3\ntoAddCircle : x\u271d\nj : \u2124\n\u22a2 sorry () = \u2191j / \u2191N"}]}
{"declaration": "lemma toAddCircle_natCast (j : \u2115) :\n    toAddCircle (j : ZMod N) = \u2191(j / N : \u211d) := by\n  simpa using toAddCircle_intCast (N := N) j\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/AddCircle.lean", "context": {"open": ["AddCommGroup Set Function AddSubgroup TopologicalSpace", "Topology"], "variables": ["{\ud835\udd5c B : Type*}", "[AddCommGroup \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsOrderedAddMonoid \ud835\udd5c] [Archimedean \ud835\udd5c]", "{x}", "[AddCommGroup \ud835\udd5c] (p : \ud835\udd5c)", "[LinearOrder \ud835\udd5c] [IsOrderedAddMonoid \ud835\udd5c]", "[hp : Fact (0 < p)] (a : \ud835\udd5c) [Archimedean \ud835\udd5c]", "{p a}", "(p a)", "[TopologicalSpace \ud835\udd5c]", "[OrderTopology \ud835\udd5c] {x : AddCircle p}", "[Field \ud835\udd5c] (p q : \ud835\udd5c)", "[LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "[LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [hp : Fact (0 < p)]", "[FloorRing \ud835\udd5c]", "{p}", "(p) in", "(p)", "(p : \u211d)", "[AddCommGroup \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsOrderedAddMonoid \ud835\udd5c] (p a : \ud835\udd5c)", "[Archimedean \ud835\udd5c]", "{p a}", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{N : \u2115} [NeZero N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\nx\u271d : Sort u_3\ntoAddCircle : x\u271d\nj : \u2115\n\u22a2 sorry = \u2191j / \u2191N"}, {"line": "simpa using toAddCircle_intCast (N := N) j", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Matrix.transpose_tsum [T2Space R] {f : X \u2192 Matrix m n R} : (\u2211' x, f x)\u1d40 = \u2211' x, (f x)\u1d40 := by\n  by_cases hf : Summable f\n  \u00b7 exact hf.hasSum.matrix_transpose.tsum_eq.symm\n  \u00b7 have hft := summable_matrix_transpose.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf]\n    rw [tsum_eq_zero_of_not_summable hft]\n    rw [transpose_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/Matrix.lean", "context": {"open": ["Matrix"], "variables": ["{X \u03b1 l m n p S R : Type*} {m' n' : l \u2192 Type*}", "[TopologicalSpace X] [TopologicalSpace R]", "[AddCommMonoid R] [TopologicalSpace R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : TopologicalSpace R\ninst\u271d\u00b2 : AddCommMonoid R\ninst\u271d\u00b9 : TopologicalSpace R\ninst\u271d : T2Space R\nf : X \u2192 Matrix m n R\n\u22a2 (\u2211' (x : X), f x).transpose = \u2211' (x : X), (f x).transpose"}, {"line": "by_cases hf : Summable f", "tactic_state": "case pos\nX : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : TopologicalSpace R\ninst\u271d\u00b2 : AddCommMonoid R\ninst\u271d\u00b9 : TopologicalSpace R\ninst\u271d : T2Space R\nf : X \u2192 Matrix m n R\nhf : sorry\n\u22a2 (\u2211' (x : X), f x).transpose = \u2211' (x : X), (f x).transpose\n---\ncase neg\nX : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : TopologicalSpace R\ninst\u271d\u00b2 : AddCommMonoid R\ninst\u271d\u00b9 : TopologicalSpace R\ninst\u271d : T2Space R\nf : X \u2192 Matrix m n R\nhf : \u00acsorry\n\u22a2 (\u2211' (x : X), f x).transpose = \u2211' (x : X), (f x).transpose"}, {"line": "\u00b7 exact hf.hasSum.matrix_transpose.tsum_eq.symm", "tactic_state": "case neg\nX : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : TopologicalSpace R\ninst\u271d\u00b2 : AddCommMonoid R\ninst\u271d\u00b9 : TopologicalSpace R\ninst\u271d : T2Space R\nf : X \u2192 Matrix m n R\nhf : \u00acsorry\n\u22a2 (\u2211' (x : X), f x).transpose = \u2211' (x : X), (f x).transpose"}, {"line": "\u00b7 have hft := summable_matrix_transpose.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf]\n    rw [tsum_eq_zero_of_not_summable hft]\n    rw [transpose_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Matrix.conjTranspose_tsum [StarAddMonoid R] [ContinuousStar R] [T2Space R]\n    {f : X \u2192 Matrix m n R} : (\u2211' x, f x)\u1d34 = \u2211' x, (f x)\u1d34 := by\n  by_cases hf : Summable f\n  \u00b7 exact hf.hasSum.matrix_conjTranspose.tsum_eq.symm\n  \u00b7 have hft := summable_matrix_conjTranspose.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf]\n    rw [tsum_eq_zero_of_not_summable hft]\n    rw [conjTranspose_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/Matrix.lean", "context": {"open": ["Matrix"], "variables": ["{X \u03b1 l m n p S R : Type*} {m' n' : l \u2192 Type*}", "[TopologicalSpace X] [TopologicalSpace R]", "[AddCommMonoid R] [TopologicalSpace R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst\u271d\u2076 : TopologicalSpace X\ninst\u271d\u2075 : TopologicalSpace R\ninst\u271d\u2074 : AddCommMonoid R\ninst\u271d\u00b3 : TopologicalSpace R\ninst\u271d\u00b2 : StarAddMonoid R\ninst\u271d\u00b9 : ContinuousStar R\ninst\u271d : T2Space R\nf : X \u2192 Matrix m n R\n\u22a2 (\u2211' (x : X), f x).conjTranspose = \u2211' (x : X), (f x).conjTranspose"}, {"line": "by_cases hf : Summable f", "tactic_state": "case pos\nX : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst\u271d\u2076 : TopologicalSpace X\ninst\u271d\u2075 : TopologicalSpace R\ninst\u271d\u2074 : AddCommMonoid R\ninst\u271d\u00b3 : TopologicalSpace R\ninst\u271d\u00b2 : StarAddMonoid R\ninst\u271d\u00b9 : ContinuousStar R\ninst\u271d : T2Space R\nf : X \u2192 Matrix m n R\nhf : sorry\n\u22a2 (\u2211' (x : X), f x).conjTranspose = \u2211' (x : X), (f x).conjTranspose\n---\ncase neg\nX : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst\u271d\u2076 : TopologicalSpace X\ninst\u271d\u2075 : TopologicalSpace R\ninst\u271d\u2074 : AddCommMonoid R\ninst\u271d\u00b3 : TopologicalSpace R\ninst\u271d\u00b2 : StarAddMonoid R\ninst\u271d\u00b9 : ContinuousStar R\ninst\u271d : T2Space R\nf : X \u2192 Matrix m n R\nhf : \u00acsorry\n\u22a2 (\u2211' (x : X), f x).conjTranspose = \u2211' (x : X), (f x).conjTranspose"}, {"line": "\u00b7 exact hf.hasSum.matrix_conjTranspose.tsum_eq.symm", "tactic_state": "case neg\nX : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst\u271d\u2076 : TopologicalSpace X\ninst\u271d\u2075 : TopologicalSpace R\ninst\u271d\u2074 : AddCommMonoid R\ninst\u271d\u00b3 : TopologicalSpace R\ninst\u271d\u00b2 : StarAddMonoid R\ninst\u271d\u00b9 : ContinuousStar R\ninst\u271d : T2Space R\nf : X \u2192 Matrix m n R\nhf : \u00acsorry\n\u22a2 (\u2211' (x : X), f x).conjTranspose = \u2211' (x : X), (f x).conjTranspose"}, {"line": "\u00b7 have hft := summable_matrix_conjTranspose.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf]\n    rw [tsum_eq_zero_of_not_summable hft]\n    rw [conjTranspose_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Matrix.diagonal_tsum [DecidableEq n] [T2Space R] {f : X \u2192 n \u2192 R} :\n    diagonal (\u2211' x, f x) = \u2211' x, diagonal (f x) := by\n  by_cases hf : Summable f\n  \u00b7 exact hf.hasSum.matrix_diagonal.tsum_eq.symm\n  \u00b7 have hft := summable_matrix_diagonal.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf]\n    rw [tsum_eq_zero_of_not_summable hft]\n    exact diagonal_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/Matrix.lean", "context": {"open": ["Matrix"], "variables": ["{X \u03b1 l m n p S R : Type*} {m' n' : l \u2192 Type*}", "[TopologicalSpace X] [TopologicalSpace R]", "[AddCommMonoid R] [TopologicalSpace R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nn : Type u_5\nR : Type u_8\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : T2Space R\nf : X \u2192 n \u2192 R\n\u22a2 diagonal (\u2211' (x : X), f x) = \u2211' (x : X), diagonal (f x)"}, {"line": "by_cases hf : Summable f", "tactic_state": "case pos\nX : Type u_1\nn : Type u_5\nR : Type u_8\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : T2Space R\nf : X \u2192 n \u2192 R\nhf : sorry\n\u22a2 diagonal (\u2211' (x : X), f x) = \u2211' (x : X), diagonal (f x)\n---\ncase neg\nX : Type u_1\nn : Type u_5\nR : Type u_8\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : T2Space R\nf : X \u2192 n \u2192 R\nhf : \u00acsorry\n\u22a2 diagonal (\u2211' (x : X), f x) = \u2211' (x : X), diagonal (f x)"}, {"line": "\u00b7 exact hf.hasSum.matrix_diagonal.tsum_eq.symm", "tactic_state": "case neg\nX : Type u_1\nn : Type u_5\nR : Type u_8\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : T2Space R\nf : X \u2192 n \u2192 R\nhf : \u00acsorry\n\u22a2 diagonal (\u2211' (x : X), f x) = \u2211' (x : X), diagonal (f x)"}, {"line": "\u00b7 have hft := summable_matrix_diagonal.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf]\n    rw [tsum_eq_zero_of_not_summable hft]\n    exact diagonal_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Matrix.blockDiagonal_tsum [DecidableEq p] [T2Space R] {f : X \u2192 p \u2192 Matrix m n R} :\n    blockDiagonal (\u2211' x, f x) = \u2211' x, blockDiagonal (f x) := by\n  by_cases hf : Summable f\n  \u00b7 exact hf.hasSum.matrix_blockDiagonal.tsum_eq.symm\n  \u00b7 have hft := summable_matrix_blockDiagonal.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf]\n    rw [tsum_eq_zero_of_not_summable hft]\n    exact blockDiagonal_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/Matrix.lean", "context": {"open": ["Matrix"], "variables": ["{X \u03b1 l m n p S R : Type*} {m' n' : l \u2192 Type*}", "[TopologicalSpace X] [TopologicalSpace R]", "[AddCommMonoid R] [TopologicalSpace R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nm : Type u_4\nn : Type u_5\np : Type u_6\nR : Type u_8\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : DecidableEq p\ninst\u271d : T2Space R\nf : X \u2192 p \u2192 Matrix m n R\n\u22a2 blockDiagonal (\u2211' (x : X), f x) = \u2211' (x : X), blockDiagonal (f x)"}, {"line": "by_cases hf : Summable f", "tactic_state": "case pos\nX : Type u_1\nm : Type u_4\nn : Type u_5\np : Type u_6\nR : Type u_8\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : DecidableEq p\ninst\u271d : T2Space R\nf : X \u2192 p \u2192 Matrix m n R\nhf : sorry\n\u22a2 blockDiagonal (\u2211' (x : X), f x) = \u2211' (x : X), blockDiagonal (f x)\n---\ncase neg\nX : Type u_1\nm : Type u_4\nn : Type u_5\np : Type u_6\nR : Type u_8\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : DecidableEq p\ninst\u271d : T2Space R\nf : X \u2192 p \u2192 Matrix m n R\nhf : \u00acsorry\n\u22a2 blockDiagonal (\u2211' (x : X), f x) = \u2211' (x : X), blockDiagonal (f x)"}, {"line": "\u00b7 exact hf.hasSum.matrix_blockDiagonal.tsum_eq.symm", "tactic_state": "case neg\nX : Type u_1\nm : Type u_4\nn : Type u_5\np : Type u_6\nR : Type u_8\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : DecidableEq p\ninst\u271d : T2Space R\nf : X \u2192 p \u2192 Matrix m n R\nhf : \u00acsorry\n\u22a2 blockDiagonal (\u2211' (x : X), f x) = \u2211' (x : X), blockDiagonal (f x)"}, {"line": "\u00b7 have hft := summable_matrix_blockDiagonal.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf]\n    rw [tsum_eq_zero_of_not_summable hft]\n    exact blockDiagonal_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_coe_cofinite : Tendsto ((\u2191) : \u2124 \u2192 \u211d) cofinite (cocompact \u211d) := by\n  apply (castAddHom \u211d).tendsto_coe_cofinite_of_discrete cast_injective\n  rw [range_castAddHom]\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ZMultiples.lean", "context": {"open": ["Filter Int Metric Set TopologicalSpace Bornology", "scoped Topology Uniformity Interval", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Tendsto Int.cast Filter.cofinite (cocompact \u211d)"}, {"line": "apply (castAddHom \u211d).tendsto_coe_cofinite_of_discrete cast_injective", "tactic_state": "\u22a2 DiscreteTopology \u21a5(castAddHom \u211d).range"}, {"line": "rw [range_castAddHom]", "tactic_state": "\u22a2 DiscreteTopology \u21a5(AddSubgroup.zmultiples 1)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_zmultiplesHom_cofinite {a : \u211d} (ha : a \u2260 0) :\n    Tendsto (zmultiplesHom \u211d a) cofinite (cocompact \u211d) := by\n  apply (zmultiplesHom \u211d a).tendsto_coe_cofinite_of_discrete <| smul_left_injective \u2124 ha\n  rw [AddSubgroup.range_zmultiplesHom]\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ZMultiples.lean", "context": {"open": ["Filter Int Metric Set TopologicalSpace Bornology", "scoped Topology Uniformity Interval", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\nha : a \u2260 0\n\u22a2 Tendsto (\u21d1((zmultiplesHom \u211d) a)) Filter.cofinite (cocompact \u211d)"}, {"line": "apply (zmultiplesHom \u211d a).tendsto_coe_cofinite_of_discrete <| smul_left_injective \u2124 ha", "tactic_state": "a : \u211d\nha : a \u2260 0\n\u22a2 DiscreteTopology \u21a5((zmultiplesHom \u211d) a).range"}, {"line": "rw [AddSubgroup.range_zmultiplesHom]", "tactic_state": "a : \u211d\nha : a \u2260 0\n\u22a2 DiscreteTopology \u21a5(AddSubgroup.zmultiples a)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem denseRange_zsmul_coe_iff {a p : \u211d} :\n    DenseRange (\u00b7 \u2022 a : \u2124 \u2192 AddCircle p) \u2194 Irrational (a / p) := by\n  rw [\u2190 dense_addSubgroupClosure_pair_iff]\n  rw [DenseRange]\n  rw [\u2190 QuotientAddGroup.dense_preimage_mk]\n  rw [\u2190 QuotientAddGroup.coe_mk']\n  rw [\u2190 AddSubgroup.coe_zmultiples]\n  rw [\u2190 AddSubgroup.coe_comap]\n  rw [\u2190 AddMonoidHom.map_zmultiples]\n  rw [AddSubgroup.comap_map_eq]\n  rw [QuotientAddGroup.ker_mk']\n  rw [AddSubgroup.zmultiples_eq_closure]\n  rw [AddSubgroup.zmultiples_eq_closure]\n  rw [\u2190 AddSubgroup.closure_union]\n  rw [insert_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/AddCircle/DenseSubgroup.lean", "context": {"open": ["Set Filter", "scoped Pointwise Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a p : \u211d\n\u22a2 (DenseRange fun x => x \u2022 \u2191a) \u2194 Irrational (a / p)"}, {"line": "rw [\u2190 dense_addSubgroupClosure_pair_iff]", "tactic_state": "a p : \u211d\n\u22a2 (DenseRange fun x => x \u2022 \u2191a) \u2194 Dense \u2191(AddSubgroup.closure {a, p})"}, {"line": "rw [DenseRange]", "tactic_state": "a p : \u211d\n\u22a2 Dense (range fun x => x \u2022 \u2191a) \u2194 Dense \u2191(AddSubgroup.closure {a, p})"}, {"line": "rw [\u2190 QuotientAddGroup.dense_preimage_mk]", "tactic_state": "a p : \u211d\n\u22a2 Dense (QuotientAddGroup.mk \u207b\u00b9' range fun x => x \u2022 \u2191a) \u2194 Dense \u2191(AddSubgroup.closure {a, p})"}, {"line": "rw [\u2190 QuotientAddGroup.coe_mk']", "tactic_state": "a p : \u211d\n\u22a2 Dense\n      (\u21d1(QuotientAddGroup.mk' (AddSubgroup.zmultiples p)) \u207b\u00b9'\n        range fun x => x \u2022 (QuotientAddGroup.mk' (AddSubgroup.zmultiples p)) a) \u2194\n    Dense \u2191(AddSubgroup.closure {a, p})"}, {"line": "rw [\u2190 AddSubgroup.coe_zmultiples]", "tactic_state": "a p : \u211d\n\u22a2 Dense\n      (\u21d1(QuotientAddGroup.mk' (AddSubgroup.zmultiples p)) \u207b\u00b9'\n        \u2191(AddSubgroup.zmultiples ((QuotientAddGroup.mk' (AddSubgroup.zmultiples p)) a))) \u2194\n    Dense \u2191(AddSubgroup.closure {a, p})"}, {"line": "rw [\u2190 AddSubgroup.coe_comap]", "tactic_state": "a p : \u211d\n\u22a2 Dense\n      \u2191(AddSubgroup.comap (QuotientAddGroup.mk' (AddSubgroup.zmultiples p))\n          (AddSubgroup.zmultiples ((QuotientAddGroup.mk' (AddSubgroup.zmultiples p)) a))) \u2194\n    Dense \u2191(AddSubgroup.closure {a, p})"}, {"line": "rw [\u2190 AddMonoidHom.map_zmultiples]", "tactic_state": "a p : \u211d\n\u22a2 Dense\n      \u2191(AddSubgroup.comap (QuotientAddGroup.mk' (AddSubgroup.zmultiples p))\n          (AddSubgroup.map (QuotientAddGroup.mk' (AddSubgroup.zmultiples p)) (AddSubgroup.zmultiples a))) \u2194\n    Dense \u2191(AddSubgroup.closure {a, p})"}, {"line": "rw [AddSubgroup.comap_map_eq]", "tactic_state": "a p : \u211d\n\u22a2 Dense \u2191(AddSubgroup.zmultiples a \u2294 (QuotientAddGroup.mk' (AddSubgroup.zmultiples p)).ker) \u2194\n    Dense \u2191(AddSubgroup.closure {a, p})"}, {"line": "rw [QuotientAddGroup.ker_mk']", "tactic_state": "a p : \u211d\n\u22a2 Dense \u2191(AddSubgroup.zmultiples a \u2294 AddSubgroup.zmultiples p) \u2194 Dense \u2191(AddSubgroup.closure {a, p})"}, {"line": "rw [AddSubgroup.zmultiples_eq_closure]", "tactic_state": "a p : \u211d\n\u22a2 Dense \u2191(AddSubgroup.closure {a} \u2294 AddSubgroup.zmultiples p) \u2194 Dense \u2191(AddSubgroup.closure {a, p})"}, {"line": "rw [AddSubgroup.zmultiples_eq_closure]", "tactic_state": "a p : \u211d\n\u22a2 Dense \u2191(AddSubgroup.closure {a} \u2294 AddSubgroup.closure {p}) \u2194 Dense \u2191(AddSubgroup.closure {a, p})"}, {"line": "rw [\u2190 AddSubgroup.closure_union]", "tactic_state": "a p : \u211d\n\u22a2 Dense \u2191(AddSubgroup.closure ({a} \u222a {p})) \u2194 Dense \u2191(AddSubgroup.closure {a, p})"}, {"line": "rw [insert_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_Ico_zero : IsOpen (Ico 0 b) := by\n  rw [ENNReal.Ico_eq_Iio]\n  exact isOpen_Iio\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : ENNReal\n\u22a2 IsOpen (Ico 0 b)"}, {"line": "rw [ENNReal.Ico_eq_Iio]", "tactic_state": "b : ENNReal\n\u22a2 IsOpen (Iio b)"}, {"line": "exact isOpen_Iio", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventuallyEq_of_toReal_eventuallyEq {l : Filter \u03b1} {f g : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hfi : \u2200\u1da0 x in l, f x \u2260 \u221e) (hgi : \u2200\u1da0 x in l, g x \u2260 \u221e)\n    (hfg : (fun x => (f x).toReal) =\u1da0[l] fun x => (g x).toReal) : f =\u1da0[l] g := by\n  filter_upwards [hfi, hgi, hfg] with _ hfx hgx _\n  rwa [\u2190 ENNReal.toReal_eq_toReal hfx hgx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\nf g : \u03b1 \u2192 ENNReal\nhfi : \u2200\u1da0 (x : \u03b1) in l, f x \u2260 \u22a4\nhgi : \u2200\u1da0 (x : \u03b1) in l, g x \u2260 \u22a4\nhfg : (fun x => (f x).toReal) =\u1da0[l] fun x => (g x).toReal\n\u22a2 f =\u1da0[l] g"}, {"line": "filter_upwards [hfi, hgi, hfg] with _ hfx hgx _", "tactic_state": "case h\n\u03b1 : Type u_1\nl : Filter \u03b1\nf g : \u03b1 \u2192 ENNReal\nhfi : \u2200\u1da0 (x : \u03b1) in l, f x \u2260 \u22a4\nhgi : \u2200\u1da0 (x : \u03b1) in l, g x \u2260 \u22a4\nhfg : (fun x => (f x).toReal) =\u1da0[l] fun x => (g x).toReal\na\u271d\u00b9 : \u03b1\nhfx : f a\u271d\u00b9 \u2260 \u22a4\nhgx : g a\u271d\u00b9 \u2260 \u22a4\na\u271d : (f a\u271d\u00b9).toReal = (g a\u271d\u00b9).toReal\n\u22a2 f a\u271d\u00b9 = g a\u271d\u00b9"}, {"line": "rwa [\u2190 ENNReal.toReal_eq_toReal hfx hgx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasBasis_nhds_of_ne_top (xt : x \u2260 \u221e) :\n    (\ud835\udcdd x).HasBasis (0 < \u00b7) (fun \u03b5 => Icc (x - \u03b5) (x + \u03b5)) := by\n  simpa only [pos_iff_ne_zero] using hasBasis_nhds_of_ne_top' xt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ENNReal\nxt : x \u2260 \u22a4\n\u22a2 (nhds x).HasBasis (fun x => 0 < x) fun \u03b5 => Icc (x - \u03b5) (x + \u03b5)"}, {"line": "simpa only [pos_iff_ne_zero] using hasBasis_nhds_of_ne_top' xt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_atTop_zero_iff_le_of_antitone {\u03b2 : Type*} [Nonempty \u03b2] [SemilatticeSup \u03b2]\n    {f : \u03b2 \u2192 \u211d\u22650\u221e} (hf : Antitone f) :\n    Filter.Tendsto f Filter.atTop (\ud835\udcdd 0) \u2194 \u2200 \u03b5, 0 < \u03b5 \u2192 \u2203 n : \u03b2, f n \u2264 \u03b5 := by\n  rw [ENNReal.tendsto_atTop_zero]\n  refine \u27e8fun h \u21a6 fun \u03b5 h\u03b5 \u21a6 ?_, fun h \u21a6 fun \u03b5 h\u03b5 \u21a6 ?_\u27e9\n  \u00b7 obtain \u27e8n, hn\u27e9 := h \u03b5 h\u03b5\n    exact \u27e8n, hn n le_rfl\u27e9\n  \u00b7 obtain \u27e8n, hn\u27e9 := h \u03b5 h\u03b5\n    exact \u27e8n, fun m hm \u21a6 (hf hm).trans hn\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nf : \u03b2 \u2192 ENNReal\nhf : Antitone f\n\u22a2 Tendsto f atTop (nhds 0) \u2194 \u2200 (\u03b5 : ENNReal), 0 < \u03b5 \u2192 \u2203 n, f n \u2264 \u03b5"}, {"line": "rw [ENNReal.tendsto_atTop_zero]", "tactic_state": "\u03b2 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nf : \u03b2 \u2192 ENNReal\nhf : Antitone f\n\u22a2 (\u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, f n \u2264 \u03b5) \u2194 \u2200 (\u03b5 : ENNReal), 0 < \u03b5 \u2192 \u2203 n, f n \u2264 \u03b5\n---\n\u03b2 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nf : \u03b2 \u2192 ENNReal\nhf : Antitone f\n\u22a2 Nonempty \u03b2"}, {"line": "refine \u27e8fun h \u21a6 fun \u03b5 h\u03b5 \u21a6 ?_, fun h \u21a6 fun \u03b5 h\u03b5 \u21a6 ?_\u27e9", "tactic_state": "case refine_1\n\u03b2 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nf : \u03b2 \u2192 ENNReal\nhf : Antitone f\nh : \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, f n \u2264 \u03b5\n\u03b5 : ENNReal\nh\u03b5 : 0 < \u03b5\n\u22a2 \u2203 n, f n \u2264 \u03b5\n---\ncase refine_2\n\u03b2 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nf : \u03b2 \u2192 ENNReal\nhf : Antitone f\nh : \u2200 (\u03b5 : ENNReal), 0 < \u03b5 \u2192 \u2203 n, f n \u2264 \u03b5\n\u03b5 : ENNReal\nh\u03b5 : \u03b5 > 0\n\u22a2 \u2203 N, \u2200 n \u2265 N, f n \u2264 \u03b5\n---\n\u03b2 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nf : \u03b2 \u2192 ENNReal\nhf : Antitone f\n\u22a2 Nonempty \u03b2"}, {"line": "\u00b7 obtain \u27e8n, hn\u27e9 := h \u03b5 h\u03b5\n    exact \u27e8n, hn n le_rfl\u27e9", "tactic_state": "case refine_2\n\u03b2 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nf : \u03b2 \u2192 ENNReal\nhf : Antitone f\nh : \u2200 (\u03b5 : ENNReal), 0 < \u03b5 \u2192 \u2203 n, f n \u2264 \u03b5\n\u03b5 : ENNReal\nh\u03b5 : \u03b5 > 0\n\u22a2 \u2203 N, \u2200 n \u2265 N, f n \u2264 \u03b5\n---\n\u03b2 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nf : \u03b2 \u2192 ENNReal\nhf : Antitone f\n\u22a2 Nonempty \u03b2"}, {"line": "\u00b7 obtain \u27e8n, hn\u27e9 := h \u03b5 h\u03b5\n    exact \u27e8n, fun m hm \u21a6 (hf hm).trans hn\u27e9", "tactic_state": "\u03b2 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nf : \u03b2 \u2192 ENNReal\nhf : Antitone f\n\u22a2 Nonempty \u03b2"}]}
{"declaration": "protected theorem Tendsto.mul_const {f : Filter \u03b1} {m : \u03b1 \u2192 \u211d\u22650\u221e} {a b : \u211d\u22650\u221e}\n    (hm : Tendsto m f (\ud835\udcdd a)) (ha : a \u2260 0 \u2228 b \u2260 \u221e) : Tendsto (fun x => m x * b) f (\ud835\udcdd (a * b)) := by\n  simpa only [mul_comm] using ENNReal.Tendsto.const_mul hm ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\nm : \u03b1 \u2192 ENNReal\na b : ENNReal\nhm : Tendsto m f (nhds a)\nha : a \u2260 0 \u2228 b \u2260 \u22a4\n\u22a2 Tendsto (fun x => m x * b) f (nhds (a * b))"}, {"line": "simpa only [mul_comm] using ENNReal.Tendsto.const_mul hm ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousOn_sub :\n    ContinuousOn (fun p : \u211d\u22650\u221e \u00d7 \u211d\u22650\u221e => p.fst - p.snd) { p : \u211d\u22650\u221e \u00d7 \u211d\u22650\u221e | p \u2260 \u27e8\u221e, \u221e\u27e9 } := by\n  rw [ContinuousOn]\n  rintro \u27e8x, y\u27e9 hp\n  simp only [Ne] at hp\n  simp only [Set.mem_setOf_eq] at hp\n  simp only [Prod.mk_inj] at hp\n  exact tendsto_nhdsWithin_of_tendsto_nhds (tendsto_sub (not_and_or.mp hp))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 ContinuousOn (fun p => p.1 - p.2) {p | p \u2260 (\u22a4, \u22a4)}"}, {"line": "rw [ContinuousOn]", "tactic_state": "\u22a2 \u2200 x \u2208 {p | p \u2260 (\u22a4, \u22a4)}, ContinuousWithinAt (fun p => p.1 - p.2) {p | p \u2260 (\u22a4, \u22a4)} x"}, {"line": "rintro \u27e8x, y\u27e9 hp", "tactic_state": "case mk\nx y : ENNReal\nhp : (x, y) \u2208 {p | p \u2260 (\u22a4, \u22a4)}\n\u22a2 ContinuousWithinAt (fun p => p.1 - p.2) {p | p \u2260 (\u22a4, \u22a4)} (x, y)"}, {"line": "simp only [Ne] at hp", "tactic_state": "case mk\nx y : ENNReal\nhp : (x, y) \u2208 {p | \u00acp = (\u22a4, \u22a4)}\n\u22a2 ContinuousWithinAt (fun p => p.1 - p.2) {p | p \u2260 (\u22a4, \u22a4)} (x, y)"}, {"line": "simp only [Set.mem_setOf_eq] at hp", "tactic_state": "case mk\nx y : ENNReal\nhp : \u00ac(x, y) = (\u22a4, \u22a4)\n\u22a2 ContinuousWithinAt (fun p => p.1 - p.2) {p | p \u2260 (\u22a4, \u22a4)} (x, y)"}, {"line": "simp only [Prod.mk_inj] at hp", "tactic_state": "case mk\nx y : ENNReal\nhp : \u00ac(x = \u22a4 \u2227 y = \u22a4)\n\u22a2 ContinuousWithinAt (fun p => p.1 - p.2) {p | p \u2260 (\u22a4, \u22a4)} (x, y)"}, {"line": "exact tendsto_nhdsWithin_of_tendsto_nhds (tendsto_sub (not_and_or.mp hp))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_frequently_lt_of_liminf_ne_top {\u03b9 : Type*} {l : Filter \u03b9} {x : \u03b9 \u2192 \u211d}\n    (hx : liminf (fun n => (Real.nnabs (x n) : \u211d\u22650\u221e)) l \u2260 \u221e) : \u2203 R, \u2203\u1da0 n in l, x n < R := by\n  by_contra h\n  simp_rw [not_exists, not_frequently, not_lt] at h\n  refine hx (ENNReal.eq_top_of_forall_nnreal_le fun r => le_limsInf_of_le (by isBoundedDefault) ?_)\n  simp only [eventually_map]\n  simp only [ENNReal.coe_le_coe]\n  filter_upwards [h r] with i hi using hi.trans (le_abs_self (x i))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_4\nl : Filter \u03b9\nx : \u03b9 \u2192 \u211d\nhx : liminf (fun n => \u2191(Real.nnabs (x n))) l \u2260 \u22a4\n\u22a2 \u2203 R, \u2203\u1da0 (n : \u03b9) in l, x n < R"}, {"line": "by_contra h", "tactic_state": "\u03b9 : Type u_4\nl : Filter \u03b9\nx : \u03b9 \u2192 \u211d\nhx : liminf (fun n => \u2191(Real.nnabs (x n))) l \u2260 \u22a4\nh : \u00ac\u2203 R, \u2203\u1da0 (n : \u03b9) in l, x n < R\n\u22a2 False"}, {"line": "simp_rw [not_exists, not_frequently, not_lt] at h", "tactic_state": "\u03b9 : Type u_4\nl : Filter \u03b9\nx : \u03b9 \u2192 \u211d\nhx : liminf (fun n => \u2191(Real.nnabs (x n))) l \u2260 \u22a4\nh : \u2200 (x_1 : \u211d), \u2200\u1da0 (x_2 : \u03b9) in l, x_1 \u2264 x x_2\n\u22a2 False"}, {"line": "refine hx (ENNReal.eq_top_of_forall_nnreal_le fun r => le_limsInf_of_le (by isBoundedDefault) ?_)", "tactic_state": "\u03b9 : Type u_4\nl : Filter \u03b9\nx : \u03b9 \u2192 \u211d\nhx : liminf (fun n => \u2191(Real.nnabs (x n))) l \u2260 \u22a4\nh : \u2200 (x_1 : \u211d), \u2200\u1da0 (x_2 : \u03b9) in l, x_1 \u2264 x x_2\nr : NNReal\n\u22a2 \u2200\u1da0 (n : ENNReal) in map (fun n => \u2191(Real.nnabs (x n))) l, \u2191r \u2264 n"}, {"line": "simp only [eventually_map]", "tactic_state": "\u03b9 : Type u_4\nl : Filter \u03b9\nx : \u03b9 \u2192 \u211d\nhx : liminf (fun n => \u2191(Real.nnabs (x n))) l \u2260 \u22a4\nh : \u2200 (x_1 : \u211d), \u2200\u1da0 (x_2 : \u03b9) in l, x_1 \u2264 x x_2\nr : NNReal\n\u22a2 \u2200\u1da0 (a : \u03b9) in l, \u2191r \u2264 \u2191(Real.nnabs (x a))"}, {"line": "simp only [ENNReal.coe_le_coe]", "tactic_state": "\u03b9 : Type u_4\nl : Filter \u03b9\nx : \u03b9 \u2192 \u211d\nhx : liminf (fun n => \u2191(Real.nnabs (x n))) l \u2260 \u22a4\nh : \u2200 (x_1 : \u211d), \u2200\u1da0 (x_2 : \u03b9) in l, x_1 \u2264 x x_2\nr : NNReal\n\u22a2 \u2200\u1da0 (a : \u03b9) in l, r \u2264 Real.nnabs (x a)"}, {"line": "filter_upwards [h r] with i hi using hi.trans (le_abs_self (x i))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_frequently_lt_of_liminf_ne_top' {\u03b9 : Type*} {l : Filter \u03b9} {x : \u03b9 \u2192 \u211d}\n    (hx : liminf (fun n => (Real.nnabs (x n) : \u211d\u22650\u221e)) l \u2260 \u221e) : \u2203 R, \u2203\u1da0 n in l, R < x n := by\n  by_contra h\n  simp_rw [not_exists, not_frequently, not_lt] at h\n  refine hx (ENNReal.eq_top_of_forall_nnreal_le fun r => le_limsInf_of_le (by isBoundedDefault) ?_)\n  simp only [eventually_map]\n  simp only [ENNReal.coe_le_coe]\n  filter_upwards [h (-r)] with i hi using(le_neg.1 hi).trans (neg_le_abs _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_4\nl : Filter \u03b9\nx : \u03b9 \u2192 \u211d\nhx : liminf (fun n => \u2191(Real.nnabs (x n))) l \u2260 \u22a4\n\u22a2 \u2203 R, \u2203\u1da0 (n : \u03b9) in l, R < x n"}, {"line": "by_contra h", "tactic_state": "\u03b9 : Type u_4\nl : Filter \u03b9\nx : \u03b9 \u2192 \u211d\nhx : liminf (fun n => \u2191(Real.nnabs (x n))) l \u2260 \u22a4\nh : \u00ac\u2203 R, \u2203\u1da0 (n : \u03b9) in l, R < x n\n\u22a2 False"}, {"line": "simp_rw [not_exists, not_frequently, not_lt] at h", "tactic_state": "\u03b9 : Type u_4\nl : Filter \u03b9\nx : \u03b9 \u2192 \u211d\nhx : liminf (fun n => \u2191(Real.nnabs (x n))) l \u2260 \u22a4\nh : \u2200 (x_1 : \u211d), \u2200\u1da0 (x_2 : \u03b9) in l, x x_2 \u2264 x_1\n\u22a2 False"}, {"line": "refine hx (ENNReal.eq_top_of_forall_nnreal_le fun r => le_limsInf_of_le (by isBoundedDefault) ?_)", "tactic_state": "\u03b9 : Type u_4\nl : Filter \u03b9\nx : \u03b9 \u2192 \u211d\nhx : liminf (fun n => \u2191(Real.nnabs (x n))) l \u2260 \u22a4\nh : \u2200 (x_1 : \u211d), \u2200\u1da0 (x_2 : \u03b9) in l, x x_2 \u2264 x_1\nr : NNReal\n\u22a2 \u2200\u1da0 (n : ENNReal) in map (fun n => \u2191(Real.nnabs (x n))) l, \u2191r \u2264 n"}, {"line": "simp only [eventually_map]", "tactic_state": "\u03b9 : Type u_4\nl : Filter \u03b9\nx : \u03b9 \u2192 \u211d\nhx : liminf (fun n => \u2191(Real.nnabs (x n))) l \u2260 \u22a4\nh : \u2200 (x_1 : \u211d), \u2200\u1da0 (x_2 : \u03b9) in l, x x_2 \u2264 x_1\nr : NNReal\n\u22a2 \u2200\u1da0 (a : \u03b9) in l, \u2191r \u2264 \u2191(Real.nnabs (x a))"}, {"line": "simp only [ENNReal.coe_le_coe]", "tactic_state": "\u03b9 : Type u_4\nl : Filter \u03b9\nx : \u03b9 \u2192 \u211d\nhx : liminf (fun n => \u2191(Real.nnabs (x n))) l \u2260 \u22a4\nh : \u2200 (x_1 : \u211d), \u2200\u1da0 (x_2 : \u03b9) in l, x x_2 \u2264 x_1\nr : NNReal\n\u22a2 \u2200\u1da0 (a : \u03b9) in l, r \u2264 Real.nnabs (x a)"}, {"line": "filter_upwards [h (-r)] with i hi using(le_neg.1 hi).trans (neg_le_abs _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasSum_iff_tendsto_nat {f : \u2115 \u2192 \u211d\u22650\u221e} (r : \u211d\u22650\u221e) :\n    HasSum f r \u2194 Tendsto (fun n : \u2115 => \u2211 i \u2208 Finset.range n, f i) atTop (\ud835\udcdd r) := by\n  refine \u27e8HasSum.tendsto_sum_nat, fun h => ?_\u27e9\n  rw [\u2190 iSup_eq_of_tendsto _ h]\n  rw [\u2190 ENNReal.tsum_eq_iSup_nat]\n  \u00b7 exact ENNReal.summable.hasSum\n  \u00b7 exact fun s t hst => Finset.sum_le_sum_of_subset (Finset.range_subset.2 hst)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 ENNReal\nr : ENNReal\n\u22a2 HasSum f r \u2194 Tendsto (fun n => \u2211 i \u2208 Finset.range n, f i) atTop (nhds r)"}, {"line": "refine \u27e8HasSum.tendsto_sum_nat, fun h => ?_\u27e9", "tactic_state": "f : \u2115 \u2192 ENNReal\nr : ENNReal\nh : Tendsto (fun n => \u2211 i \u2208 Finset.range n, f i) atTop (nhds r)\n\u22a2 HasSum f r"}, {"line": "rw [\u2190 iSup_eq_of_tendsto _ h]", "tactic_state": "f : \u2115 \u2192 ENNReal\nr : ENNReal\nh : Tendsto (fun n => \u2211 i \u2208 Finset.range n, f i) atTop (nhds r)\n\u22a2 HasSum f (\u2a06 n, \u2211 i \u2208 Finset.range n, f i)\n---\nf : \u2115 \u2192 ENNReal\nr : ENNReal\nh : Tendsto (fun n => \u2211 i \u2208 Finset.range n, f i) atTop (nhds r)\n\u22a2 Monotone fun n => \u2211 i \u2208 Finset.range n, f i"}, {"line": "rw [\u2190 ENNReal.tsum_eq_iSup_nat]", "tactic_state": "f : \u2115 \u2192 ENNReal\nr : ENNReal\nh : Tendsto (fun n => \u2211 i \u2208 Finset.range n, f i) atTop (nhds r)\n\u22a2 HasSum f (\u2211' (i : \u2115), f i)\n---\nf : \u2115 \u2192 ENNReal\nr : ENNReal\nh : Tendsto (fun n => \u2211 i \u2208 Finset.range n, f i) atTop (nhds r)\n\u22a2 Monotone fun n => \u2211 i \u2208 Finset.range n, f i"}, {"line": "\u00b7 exact ENNReal.summable.hasSum", "tactic_state": "f : \u2115 \u2192 ENNReal\nr : ENNReal\nh : Tendsto (fun n => \u2211 i \u2208 Finset.range n, f i) atTop (nhds r)\n\u22a2 Monotone fun n => \u2211 i \u2208 Finset.range n, f i"}, {"line": "\u00b7 exact fun s t hst => Finset.sum_le_sum_of_subset (Finset.range_subset.2 hst)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_atTop_zero_of_tsum_ne_top {f : \u2115 \u2192 \u211d\u22650\u221e} (hf : \u2211' x, f x \u2260 \u221e) :\n    Tendsto f atTop (\ud835\udcdd 0) := by\n  rw [\u2190 Nat.cofinite_eq_atTop]\n  exact tendsto_cofinite_zero_of_tsum_ne_top hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 ENNReal\nhf : \u2211' (x : \u2115), f x \u2260 \u22a4\n\u22a2 Tendsto f atTop (nhds 0)"}, {"line": "rw [\u2190 Nat.cofinite_eq_atTop]", "tactic_state": "f : \u2115 \u2192 ENNReal\nhf : \u2211' (x : \u2115), f x \u2260 \u22a4\n\u22a2 Tendsto f cofinite (nhds 0)"}, {"line": "exact tendsto_cofinite_zero_of_tsum_ne_top hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tsum_iUnion_le {\u03b9 : Type*} [Fintype \u03b9] (f : \u03b1 \u2192 \u211d\u22650\u221e) (t : \u03b9 \u2192 Set \u03b1) :\n    \u2211' x : \u22c3 i, t i, f x \u2264 \u2211 i, \u2211' x : t i, f x := by\n  rw [\u2190 tsum_fintype]\n  exact tsum_iUnion_le_tsum f t\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d : Fintype \u03b9\nf : \u03b1 \u2192 ENNReal\nt : \u03b9 \u2192 Set \u03b1\n\u22a2 \u2211' (x : \u2191(\u22c3 i, t i)), f \u2191x \u2264 \u2211 i, \u2211' (x : \u2191(t i)), f \u2191x"}, {"line": "rw [\u2190 tsum_fintype]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d : Fintype \u03b9\nf : \u03b1 \u2192 ENNReal\nt : \u03b9 \u2192 Set \u03b1\n\u22a2 \u2211' (x : \u2191(\u22c3 i, t i)), f \u2191x \u2264 \u2211' (b : \u03b9) (x : \u2191(t b)), f \u2191x"}, {"line": "exact tsum_iUnion_le_tsum f t", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tsum_union_le (f : \u03b1 \u2192 \u211d\u22650\u221e) (s t : Set \u03b1) :\n    \u2211' x : \u2191(s \u222a t), f x \u2264 \u2211' x : s, f x + \u2211' x : t, f x :=\n  calc \u2211' x : \u2191(s \u222a t), f x = \u2211' x : \u22c3 b, cond b s t, f x := tsum_congr_set_coe _ union_eq_iUnion\n  _ \u2264 _ := by simpa using tsum_iUnion_le f (cond \u00b7 s t)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 ENNReal\ns t : Set \u03b1\n\u22a2 \u2211' (x : \u2191(\u22c3 b, bif b then s else t)), f \u2191x \u2264 \u2211' (x : \u2191s), f \u2191x + \u2211' (x : \u2191t), f \u2191x"}, {"line": "simpa using tsum_iUnion_le f (cond \u00b7 s t)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tsum_fiberwise (f : \u03b2 \u2192 \u211d\u22650\u221e) (g : \u03b2 \u2192 \u03b3) :\n    \u2211' x, \u2211' b : g \u207b\u00b9' {x}, f b = \u2211' i, f i := by\n  apply HasSum.tsum_eq\n  let equiv := Equiv.sigmaFiberEquiv g\n  apply (equiv.hasSum_iff.mpr ENNReal.summable.hasSum).sigma\n  exact fun _ \u21a6 ENNReal.summable.hasSum_iff.mpr rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_1\n\u03b3 : Type u_2\nf : \u03b2 \u2192 ENNReal\ng : \u03b2 \u2192 \u03b3\n\u22a2 \u2211' (x : \u03b3) (b : \u2191(g \u207b\u00b9' {x})), f \u2191b = \u2211' (i : \u03b2), f i"}, {"line": "apply HasSum.tsum_eq", "tactic_state": "case ha\n\u03b2 : Type u_1\n\u03b3 : Type u_2\nf : \u03b2 \u2192 ENNReal\ng : \u03b2 \u2192 \u03b3\n\u22a2 HasSum (fun b => \u2211' (b_1 : \u2191(g \u207b\u00b9' {b})), f \u2191b_1) (\u2211' (i : \u03b2), f i)"}, {"line": "let equiv := Equiv.sigmaFiberEquiv g", "tactic_state": "case ha\n\u03b2 : Type u_1\n\u03b3 : Type u_2\nf : \u03b2 \u2192 ENNReal\ng : \u03b2 \u2192 \u03b3\nequiv : (y : \u03b3) \u00d7 { x // g x = y } \u2243 \u03b2 := Equiv.sigmaFiberEquiv g\n\u22a2 HasSum (fun b => \u2211' (b_1 : \u2191(g \u207b\u00b9' {b})), f \u2191b_1) (\u2211' (i : \u03b2), f i)"}, {"line": "apply (equiv.hasSum_iff.mpr ENNReal.summable.hasSum).sigma", "tactic_state": "case ha\n\u03b2 : Type u_1\n\u03b3 : Type u_2\nf : \u03b2 \u2192 ENNReal\ng : \u03b2 \u2192 \u03b3\nequiv : (y : \u03b3) \u00d7 { x // g x = y } \u2243 \u03b2 := Equiv.sigmaFiberEquiv g\n\u22a2 \u2200 (b : \u03b3), HasSum (fun c => (f \u2218 \u21d1equiv) \u27e8b, c\u27e9) (\u2211' (b_1 : \u2191(g \u207b\u00b9' {b})), f \u2191b_1)"}, {"line": "exact fun _ \u21a6 ENNReal.summable.hasSum_iff.mpr rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tsum_coe_ne_top_iff_summable_coe {f : \u03b1 \u2192 \u211d\u22650} :\n    (\u2211' a, (f a : \u211d\u22650\u221e)) \u2260 \u221e \u2194 Summable fun a => (f a : \u211d) := by\n  rw [NNReal.summable_coe]\n  exact tsum_coe_ne_top_iff_summable\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 NNReal\n\u22a2 \u2211' (a : \u03b1), \u2191(f a) \u2260 \u22a4 \u2194 Summable fun a => \u2191(f a)"}, {"line": "rw [NNReal.summable_coe]", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 NNReal\n\u22a2 \u2211' (a : \u03b1), \u2191(f a) \u2260 \u22a4 \u2194 Summable f"}, {"line": "exact tsum_coe_ne_top_iff_summable", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Summable.countable_support_nnreal (f : \u03b1 \u2192 \u211d\u22650) (h : Summable f) :\n    f.support.Countable := by\n  rw [\u2190 NNReal.summable_coe] at h\n  simpa [support] using h.countable_support\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 NNReal\nh : Summable f\n\u22a2 (support f).Countable"}, {"line": "rw [\u2190 NNReal.summable_coe] at h", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 NNReal\nh : Summable fun a => \u2191(f a)\n\u22a2 (support f).Countable"}, {"line": "simpa [support] using h.countable_support", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasSum_iff_tendsto_nat {f : \u2115 \u2192 \u211d\u22650} {r : \u211d\u22650} :\n    HasSum f r \u2194 Tendsto (fun n : \u2115 => \u2211 i \u2208 Finset.range n, f i) atTop (\ud835\udcdd r) := by\n  rw [\u2190 ENNReal.hasSum_coe]\n  rw [ENNReal.hasSum_iff_tendsto_nat]\n  simp only [\u2190 ENNReal.coe_finset_sum]\n  exact ENNReal.tendsto_coe\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 NNReal\nr : NNReal\n\u22a2 HasSum f r \u2194 Tendsto (fun n => \u2211 i \u2208 Finset.range n, f i) atTop (nhds r)"}, {"line": "rw [\u2190 ENNReal.hasSum_coe]", "tactic_state": "f : \u2115 \u2192 NNReal\nr : NNReal\n\u22a2 HasSum (fun a => \u2191(f a)) \u2191r \u2194 Tendsto (fun n => \u2211 i \u2208 Finset.range n, f i) atTop (nhds r)"}, {"line": "rw [ENNReal.hasSum_iff_tendsto_nat]", "tactic_state": "f : \u2115 \u2192 NNReal\nr : NNReal\n\u22a2 Tendsto (fun n => \u2211 i \u2208 Finset.range n, \u2191(f i)) atTop (nhds \u2191r) \u2194\n    Tendsto (fun n => \u2211 i \u2208 Finset.range n, f i) atTop (nhds r)"}, {"line": "simp only [\u2190 ENNReal.coe_finset_sum]", "tactic_state": "f : \u2115 \u2192 NNReal\nr : NNReal\n\u22a2 Tendsto (fun n => \u2191(\u2211 a \u2208 Finset.range n, f a)) atTop (nhds \u2191r) \u2194\n    Tendsto (fun n => \u2211 a \u2208 Finset.range n, f a) atTop (nhds r)"}, {"line": "exact ENNReal.tendsto_coe", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ENNReal.ofReal_tsum_of_nonneg {f : \u03b1 \u2192 \u211d} (hf_nonneg : \u2200 n, 0 \u2264 f n) (hf : Summable f) :\n    ENNReal.ofReal (\u2211' n, f n) = \u2211' n, ENNReal.ofReal (f n) := by\n  simp_rw [ENNReal.ofReal, ENNReal.tsum_coe_eq (NNReal.hasSum_real_toNNReal_of_nonneg hf_nonneg hf)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in", "Finset", "Classical in"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf_nonneg : \u2200 (n : \u03b1), 0 \u2264 f n\nhf : Summable f\n\u22a2 ENNReal.ofReal (\u2211' (n : \u03b1), f n) = \u2211' (n : \u03b1), ENNReal.ofReal (f n)"}, {"line": "simp_rw [ENNReal.ofReal, ENNReal.tsum_coe_eq (NNReal.hasSum_real_toNNReal_of_nonneg hf_nonneg hf)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_of_le_add_edist {f : \u03b1 \u2192 \u211d\u22650\u221e} (C : \u211d\u22650\u221e) (hC : C \u2260 \u221e)\n    (h : \u2200 x y, f x \u2264 f y + C * edist x y) : Continuous f := by\n  refine continuous_iff_continuousAt.2 fun x => ENNReal.tendsto_nhds_of_Icc fun \u03b5 \u03b50 => ?_\n  rcases ENNReal.exists_nnreal_pos_mul_lt hC \u03b50.ne' with \u27e8\u03b4, \u03b40, h\u03b4\u27e9\n  rw [mul_comm] at h\u03b4\n  filter_upwards [EMetric.closedBall_mem_nhds x (ENNReal.coe_pos.2 \u03b40)] with y hy\n  refine \u27e8tsub_le_iff_right.2 <| (h x y).trans ?_, (h y x).trans ?_\u27e9 <;>\n    refine add_le_add_left (le_trans (mul_le_mul_left' ?_ _) h\u03b4.le) _\n  exacts [EMetric.mem_closedBall'.1 hy, EMetric.mem_closedBall.1 hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in", "Finset", "Classical in", "ENNReal Filter EMetric", "EMetric"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}", "[EMetricSpace \u03b2]", "[PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 ENNReal\nC : ENNReal\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\n\u22a2 Continuous f"}, {"line": "refine continuous_iff_continuousAt.2 fun x => ENNReal.tendsto_nhds_of_Icc fun \u03b5 \u03b50 => ?_", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 ENNReal\nC : ENNReal\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : ENNReal\n\u03b50 : \u03b5 > 0\n\u22a2 \u2200\u1da0 (x_1 : \u03b1) in nhds x, f x_1 \u2208 Icc (f x - \u03b5) (f x + \u03b5)"}, {"line": "rcases ENNReal.exists_nnreal_pos_mul_lt hC \u03b50.ne' with \u27e8\u03b4, \u03b40, h\u03b4\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 ENNReal\nC : ENNReal\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : ENNReal\n\u03b50 : \u03b5 > 0\n\u03b4 : NNReal\n\u03b40 : \u03b4 > 0\nh\u03b4 : \u2191\u03b4 * C < \u03b5\n\u22a2 \u2200\u1da0 (x_1 : \u03b1) in nhds x, f x_1 \u2208 Icc (f x - \u03b5) (f x + \u03b5)"}, {"line": "rw [mul_comm] at h\u03b4", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 ENNReal\nC : ENNReal\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : ENNReal\n\u03b50 : \u03b5 > 0\n\u03b4 : NNReal\n\u03b40 : \u03b4 > 0\nh\u03b4 : C * \u2191\u03b4 < \u03b5\n\u22a2 \u2200\u1da0 (x_1 : \u03b1) in nhds x, f x_1 \u2208 Icc (f x - \u03b5) (f x + \u03b5)"}, {"line": "filter_upwards [EMetric.closedBall_mem_nhds x (ENNReal.coe_pos.2 \u03b40)] with y hy", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 ENNReal\nC : ENNReal\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : ENNReal\n\u03b50 : \u03b5 > 0\n\u03b4 : NNReal\n\u03b40 : \u03b4 > 0\nh\u03b4 : C * \u2191\u03b4 < \u03b5\ny : \u03b1\nhy : y \u2208 EMetric.closedBall x \u2191\u03b4\n\u22a2 f y \u2208 Icc (f x - \u03b5) (f x + \u03b5)"}, {"line": "refine \u27e8tsub_le_iff_right.2 <| (h x y).trans ?_, (h y x).trans ?_\u27e9 <;>\n    refine add_le_add_left (le_trans (mul_le_mul_left' ?_ _) h\u03b4.le) _", "tactic_state": "case h.refine_1\n\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 ENNReal\nC : ENNReal\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : ENNReal\n\u03b50 : \u03b5 > 0\n\u03b4 : NNReal\n\u03b40 : \u03b4 > 0\nh\u03b4 : C * \u2191\u03b4 < \u03b5\ny : \u03b1\nhy : y \u2208 EMetric.closedBall x \u2191\u03b4\n\u22a2 edist x y \u2264 \u2191\u03b4\n---\ncase h.refine_2\n\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 ENNReal\nC : ENNReal\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : ENNReal\n\u03b50 : \u03b5 > 0\n\u03b4 : NNReal\n\u03b40 : \u03b4 > 0\nh\u03b4 : C * \u2191\u03b4 < \u03b5\ny : \u03b1\nhy : y \u2208 EMetric.closedBall x \u2191\u03b4\n\u22a2 edist y x \u2264 \u2191\u03b4"}, {"line": "exacts [EMetric.mem_closedBall'.1 hy, EMetric.mem_closedBall.1 hy]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cauchySeq_of_edist_le_of_summable {f : \u2115 \u2192 \u03b1} (d : \u2115 \u2192 \u211d\u22650)\n    (hf : \u2200 n, edist (f n) (f n.succ) \u2264 d n) (hd : Summable d) : CauchySeq f := by\n  refine EMetric.cauchySeq_iff_NNReal.2 fun \u03b5 \u03b5pos \u21a6 ?_\n  -- Actually we need partial sums of `d` to be a Cauchy sequence.\n  replace hd : CauchySeq fun n : \u2115 \u21a6 \u2211 x \u2208 Finset.range n, d x :=\n    let \u27e8_, H\u27e9 := hd\n    H.tendsto_sum_nat.cauchySeq\n  -- Now we take the same `N` as in one of the definitions of a Cauchy sequence.\n  refine (Metric.cauchySeq_iff'.1 hd \u03b5 (NNReal.coe_pos.2 \u03b5pos)).imp fun N hN n hn \u21a6 ?_\n  specialize hN n hn\n  -- We simplify the known inequality.\n  rw [dist_nndist] at hN\n  rw [NNReal.nndist_eq] at hN\n  rw [\u2190 Finset.sum_range_add_sum_Ico _ hn] at hN\n  rw [add_tsub_cancel_left] at hN\n  rw [NNReal.coe_lt_coe] at hN\n  rw [max_lt_iff] at hN\n  rw [edist_comm]\n  -- Then use `hf` to simplify the goal to the same form.\n  refine lt_of_le_of_lt (edist_le_Ico_sum_of_edist_le hn fun _ _ \u21a6 hf _) ?_\n  exact mod_cast hN.1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in", "Finset", "Classical in", "ENNReal Filter EMetric", "EMetric"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}", "[EMetricSpace \u03b2]", "[PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 NNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 \u2191(d n)\nhd : Summable d\n\u22a2 CauchySeq f"}, {"line": "refine EMetric.cauchySeq_iff_NNReal.2 fun \u03b5 \u03b5pos \u21a6 ?_", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 NNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 \u2191(d n)\nhd : Summable d\n\u03b5 : NNReal\n\u03b5pos : 0 < \u03b5\n\u22a2 \u2203 N, \u2200 (n : \u2115), N \u2264 n \u2192 edist (f n) (f N) < \u2191\u03b5"}, {"line": "replace hd : CauchySeq fun n : \u2115 \u21a6 \u2211 x \u2208 Finset.range n, d x :=\n    let \u27e8_, H\u27e9 := hd\n    H.tendsto_sum_nat.cauchySeq", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 NNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 \u2191(d n)\n\u03b5 : NNReal\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x \u2208 Finset.range n, d x\n\u22a2 \u2203 N, \u2200 (n : \u2115), N \u2264 n \u2192 edist (f n) (f N) < \u2191\u03b5"}, {"line": "refine (Metric.cauchySeq_iff'.1 hd \u03b5 (NNReal.coe_pos.2 \u03b5pos)).imp fun N hN n hn \u21a6 ?_", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 NNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 \u2191(d n)\n\u03b5 : NNReal\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x \u2208 Finset.range n, d x\nN : \u2115\nhN : \u2200 n \u2265 N, dist (\u2211 x \u2208 Finset.range n, d x) (\u2211 x \u2208 Finset.range N, d x) < \u2191\u03b5\nn : \u2115\nhn : N \u2264 n\n\u22a2 edist (f n) (f N) < \u2191\u03b5"}, {"line": "specialize hN n hn", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 NNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 \u2191(d n)\n\u03b5 : NNReal\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x \u2208 Finset.range n, d x\nN n : \u2115\nhn : N \u2264 n\nhN : dist (\u2211 x \u2208 Finset.range n, d x) (\u2211 x \u2208 Finset.range N, d x) < \u2191\u03b5\n\u22a2 edist (f n) (f N) < \u2191\u03b5"}, {"line": "rw [dist_nndist] at hN", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 NNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 \u2191(d n)\n\u03b5 : NNReal\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x \u2208 Finset.range n, d x\nN n : \u2115\nhn : N \u2264 n\nhN : \u2191(nndist (\u2211 x \u2208 Finset.range n, d x) (\u2211 x \u2208 Finset.range N, d x)) < \u2191\u03b5\n\u22a2 edist (f n) (f N) < \u2191\u03b5"}, {"line": "rw [NNReal.nndist_eq] at hN", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 NNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 \u2191(d n)\n\u03b5 : NNReal\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x \u2208 Finset.range n, d x\nN n : \u2115\nhn : N \u2264 n\nhN :\n  \u2191(max (\u2211 x \u2208 Finset.range n, d x - \u2211 x \u2208 Finset.range N, d x)\n        (\u2211 x \u2208 Finset.range N, d x - \u2211 x \u2208 Finset.range n, d x)) <\n    \u2191\u03b5\n\u22a2 edist (f n) (f N) < \u2191\u03b5"}, {"line": "rw [\u2190 Finset.sum_range_add_sum_Ico _ hn] at hN", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 NNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 \u2191(d n)\n\u03b5 : NNReal\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x \u2208 Finset.range n, d x\nN n : \u2115\nhn : N \u2264 n\nhN :\n  \u2191(max (\u2211 k \u2208 Finset.range N, d k + \u2211 k \u2208 Finset.Ico N n, d k - \u2211 x \u2208 Finset.range N, d x)\n        (\u2211 x \u2208 Finset.range N, d x - (\u2211 k \u2208 Finset.range N, d k + \u2211 k \u2208 Finset.Ico N n, d k))) <\n    \u2191\u03b5\n\u22a2 edist (f n) (f N) < \u2191\u03b5"}, {"line": "rw [add_tsub_cancel_left] at hN", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 NNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 \u2191(d n)\n\u03b5 : NNReal\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x \u2208 Finset.range n, d x\nN n : \u2115\nhn : N \u2264 n\nhN :\n  \u2191(max (\u2211 k \u2208 Finset.Ico N n, d k)\n        (\u2211 x \u2208 Finset.range N, d x - (\u2211 k \u2208 Finset.range N, d k + \u2211 k \u2208 Finset.Ico N n, d k))) <\n    \u2191\u03b5\n\u22a2 edist (f n) (f N) < \u2191\u03b5"}, {"line": "rw [NNReal.coe_lt_coe] at hN", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 NNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 \u2191(d n)\n\u03b5 : NNReal\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x \u2208 Finset.range n, d x\nN n : \u2115\nhn : N \u2264 n\nhN :\n  max (\u2211 k \u2208 Finset.Ico N n, d k)\n      (\u2211 x \u2208 Finset.range N, d x - (\u2211 k \u2208 Finset.range N, d k + \u2211 k \u2208 Finset.Ico N n, d k)) <\n    \u03b5\n\u22a2 edist (f n) (f N) < \u2191\u03b5"}, {"line": "rw [max_lt_iff] at hN", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 NNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 \u2191(d n)\n\u03b5 : NNReal\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x \u2208 Finset.range n, d x\nN n : \u2115\nhn : N \u2264 n\nhN :\n  \u2211 k \u2208 Finset.Ico N n, d k < \u03b5 \u2227\n    \u2211 x \u2208 Finset.range N, d x - (\u2211 k \u2208 Finset.range N, d k + \u2211 k \u2208 Finset.Ico N n, d k) < \u03b5\n\u22a2 edist (f n) (f N) < \u2191\u03b5"}, {"line": "rw [edist_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 NNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 \u2191(d n)\n\u03b5 : NNReal\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x \u2208 Finset.range n, d x\nN n : \u2115\nhn : N \u2264 n\nhN :\n  \u2211 k \u2208 Finset.Ico N n, d k < \u03b5 \u2227\n    \u2211 x \u2208 Finset.range N, d x - (\u2211 k \u2208 Finset.range N, d k + \u2211 k \u2208 Finset.Ico N n, d k) < \u03b5\n\u22a2 edist (f N) (f n) < \u2191\u03b5"}, {"line": "refine lt_of_le_of_lt (edist_le_Ico_sum_of_edist_le hn fun _ _ \u21a6 hf _) ?_", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 NNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 \u2191(d n)\n\u03b5 : NNReal\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x \u2208 Finset.range n, d x\nN n : \u2115\nhn : N \u2264 n\nhN :\n  \u2211 k \u2208 Finset.Ico N n, d k < \u03b5 \u2227\n    \u2211 x \u2208 Finset.range N, d x - (\u2211 k \u2208 Finset.range N, d k + \u2211 k \u2208 Finset.Ico N n, d k) < \u03b5\n\u22a2 \u2211 i \u2208 Finset.Ico N n, \u2191(d i) < \u2191\u03b5"}, {"line": "exact mod_cast hN.1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cauchySeq_of_edist_le_of_tsum_ne_top {f : \u2115 \u2192 \u03b1} (d : \u2115 \u2192 \u211d\u22650\u221e)\n    (hf : \u2200 n, edist (f n) (f n.succ) \u2264 d n) (hd : tsum d \u2260 \u221e) : CauchySeq f := by\n  lift d to \u2115 \u2192 NNReal using fun i => ENNReal.ne_top_of_tsum_ne_top hd i\n  rw [ENNReal.tsum_coe_ne_top_iff_summable] at hd\n  exact cauchySeq_of_edist_le_of_summable d hf hd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in", "Finset", "Classical in", "ENNReal Filter EMetric", "EMetric"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}", "[EMetricSpace \u03b2]", "[PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 ENNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 d n\nhd : tsum d \u2260 \u22a4\n\u22a2 CauchySeq f"}, {"line": "lift d to \u2115 \u2192 NNReal using fun i => ENNReal.ne_top_of_tsum_ne_top hd i", "tactic_state": "case intro\n\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 NNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 (fun i => \u2191(d i)) n\nhd : \u2211' (i : \u2115), \u2191(d i) \u2260 \u22a4\n\u22a2 CauchySeq f"}, {"line": "rw [ENNReal.tsum_coe_ne_top_iff_summable] at hd", "tactic_state": "case intro\n\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 NNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 (fun i => \u2191(d i)) n\nhd : Summable d\n\u22a2 CauchySeq f"}, {"line": "exact cauchySeq_of_edist_le_of_summable d hf hd", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Metric.diam_closure {\u03b1 : Type*} [PseudoMetricSpace \u03b1] (s : Set \u03b1) :\n    Metric.diam (closure s) = diam s := by simp only [Metric.diam, EMetric.diam_closure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in", "Finset", "Classical in", "ENNReal Filter EMetric", "EMetric"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}", "[EMetricSpace \u03b2]", "[PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\n\u22a2 diam (closure s) = diam s"}, {"line": "simp only [Metric.diam, EMetric.diam_closure]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_setOf_lipschitzWith {\u03b1 \u03b2} [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] (K : \u211d\u22650) :\n    IsClosed { f : \u03b1 \u2192 \u03b2 | LipschitzWith K f } := by\n  simp only [\u2190 lipschitzOnWith_univ]\n  simp only [isClosed_setOf_lipschitzOnWith]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in", "Finset", "Classical in", "ENNReal Filter EMetric", "EMetric"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}", "[EMetricSpace \u03b2]", "[PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nK : NNReal\n\u22a2 IsClosed {f | LipschitzWith K f}"}, {"line": "simp only [\u2190 lipschitzOnWith_univ]", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nK : NNReal\n\u22a2 IsClosed {f | LipschitzOnWith K f univ}"}, {"line": "simp only [isClosed_setOf_lipschitzOnWith]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem diam_eq {s : Set \u211d} (h : Bornology.IsBounded s) : Metric.diam s = sSup s - sInf s := by\n  rw [Metric.diam]\n  rw [Real.ediam_eq h]\n  rw [ENNReal.toReal_ofReal]\n  exact sub_nonneg.2 (Real.sInf_le_sSup s h.bddBelow h.bddAbove)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in", "Finset", "Classical in", "ENNReal Filter EMetric", "EMetric"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}", "[EMetricSpace \u03b2]", "[PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set \u211d\nh : Bornology.IsBounded s\n\u22a2 Metric.diam s = sSup s - sInf s"}, {"line": "rw [Metric.diam]", "tactic_state": "s : Set \u211d\nh : Bornology.IsBounded s\n\u22a2 (EMetric.diam s).toReal = sSup s - sInf s"}, {"line": "rw [Real.ediam_eq h]", "tactic_state": "s : Set \u211d\nh : Bornology.IsBounded s\n\u22a2 (ENNReal.ofReal (sSup s - sInf s)).toReal = sSup s - sInf s"}, {"line": "rw [ENNReal.toReal_ofReal]", "tactic_state": "s : Set \u211d\nh : Bornology.IsBounded s\n\u22a2 0 \u2264 sSup s - sInf s"}, {"line": "exact sub_nonneg.2 (Real.sInf_le_sSup s h.bddBelow h.bddAbove)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ediam_Ioo (a b : \u211d) : EMetric.diam (Ioo a b) = ENNReal.ofReal (b - a) := by\n  rcases le_or_lt b a with (h | h)\n  \u00b7 simp [h]\n  \u00b7 rw [Real.ediam_eq (isBounded_Ioo _ _), csSup_Ioo h, csInf_Ioo h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in", "Finset", "Classical in", "ENNReal Filter EMetric", "EMetric"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}", "[EMetricSpace \u03b2]", "[PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u22a2 EMetric.diam (Ioo a b) = ENNReal.ofReal (b - a)"}, {"line": "rcases le_or_lt b a with (h | h)", "tactic_state": "case inl\na b : \u211d\nh : b \u2264 a\n\u22a2 EMetric.diam (Ioo a b) = ENNReal.ofReal (b - a)\n---\ncase inr\na b : \u211d\nh : a < b\n\u22a2 EMetric.diam (Ioo a b) = ENNReal.ofReal (b - a)"}, {"line": "\u00b7 simp [h]", "tactic_state": "case inr\na b : \u211d\nh : a < b\n\u22a2 EMetric.diam (Ioo a b) = ENNReal.ofReal (b - a)"}, {"line": "\u00b7 rw [Real.ediam_eq (isBounded_Ioo _ _), csSup_Ioo h, csInf_Ioo h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ediam_Icc (a b : \u211d) : EMetric.diam (Icc a b) = ENNReal.ofReal (b - a) := by\n  rcases le_or_lt a b with (h | h)\n  \u00b7 rw [Real.ediam_eq (isBounded_Icc _ _), csSup_Icc h, csInf_Icc h]\n  \u00b7 simp [h, h.le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in", "Finset", "Classical in", "ENNReal Filter EMetric", "EMetric"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}", "[EMetricSpace \u03b2]", "[PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u22a2 EMetric.diam (Icc a b) = ENNReal.ofReal (b - a)"}, {"line": "rcases le_or_lt a b with (h | h)", "tactic_state": "case inl\na b : \u211d\nh : a \u2264 b\n\u22a2 EMetric.diam (Icc a b) = ENNReal.ofReal (b - a)\n---\ncase inr\na b : \u211d\nh : b < a\n\u22a2 EMetric.diam (Icc a b) = ENNReal.ofReal (b - a)"}, {"line": "\u00b7 rw [Real.ediam_eq (isBounded_Icc _ _), csSup_Icc h, csInf_Icc h]", "tactic_state": "case inr\na b : \u211d\nh : b < a\n\u22a2 EMetric.diam (Icc a b) = ENNReal.ofReal (b - a)"}, {"line": "\u00b7 simp [h, h.le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem diam_Icc {a b : \u211d} (h : a \u2264 b) : Metric.diam (Icc a b) = b - a := by\n  simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in", "Finset", "Classical in", "ENNReal Filter EMetric", "EMetric"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}", "[EMetricSpace \u03b2]", "[PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nh : a \u2264 b\n\u22a2 Metric.diam (Icc a b) = b - a"}, {"line": "simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem diam_Ico {a b : \u211d} (h : a \u2264 b) : Metric.diam (Ico a b) = b - a := by\n  simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in", "Finset", "Classical in", "ENNReal Filter EMetric", "EMetric"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}", "[EMetricSpace \u03b2]", "[PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nh : a \u2264 b\n\u22a2 Metric.diam (Ico a b) = b - a"}, {"line": "simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem diam_Ioc {a b : \u211d} (h : a \u2264 b) : Metric.diam (Ioc a b) = b - a := by\n  simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in", "Finset", "Classical in", "ENNReal Filter EMetric", "EMetric"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}", "[EMetricSpace \u03b2]", "[PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nh : a \u2264 b\n\u22a2 Metric.diam (Ioc a b) = b - a"}, {"line": "simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem diam_Ioo {a b : \u211d} (h : a \u2264 b) : Metric.diam (Ioo a b) = b - a := by\n  simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in", "Finset", "Classical in", "ENNReal Filter EMetric", "EMetric"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}", "[EMetricSpace \u03b2]", "[PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nh : a \u2264 b\n\u22a2 Metric.diam (Ioo a b) = b - a"}, {"line": "simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_le_tsum_of_edist_le_of_tendsto {f : \u2115 \u2192 \u03b1} (d : \u2115 \u2192 \u211d\u22650\u221e)\n    (hf : \u2200 n, edist (f n) (f n.succ) \u2264 d n) {a : \u03b1} (ha : Tendsto f atTop (\ud835\udcdd a)) (n : \u2115) :\n    edist (f n) a \u2264 \u2211' m, d (n + m) := by\n  refine le_of_tendsto (tendsto_const_nhds.edist ha) (mem_atTop_sets.2 \u27e8n, fun m hnm => ?_\u27e9)\n  change edist _ _ \u2264 _\n  refine le_trans (edist_le_Ico_sum_of_edist_le hnm fun _ _ => hf _) ?_\n  rw [Finset.sum_Ico_eq_sum_range]\n  exact ENNReal.summable.sum_le_tsum _ (fun _ _ => zero_le _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in", "Finset", "Classical in", "ENNReal Filter EMetric", "EMetric"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}", "[EMetricSpace \u03b2]", "[PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 ENNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 d n\na : \u03b1\nha : Tendsto f atTop (nhds a)\nn : \u2115\n\u22a2 edist (f n) a \u2264 \u2211' (m : \u2115), d (n + m)"}, {"line": "refine le_of_tendsto (tendsto_const_nhds.edist ha) (mem_atTop_sets.2 \u27e8n, fun m hnm => ?_\u27e9)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 ENNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 d n\na : \u03b1\nha : Tendsto f atTop (nhds a)\nn m : \u2115\nhnm : m \u2265 n\n\u22a2 m \u2208 {x | (fun c => edist (f n) (f c) \u2264 \u2211' (m : \u2115), d (n + m)) x}"}, {"line": "change edist _ _ \u2264 _", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 ENNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 d n\na : \u03b1\nha : Tendsto f atTop (nhds a)\nn m : \u2115\nhnm : m \u2265 n\n\u22a2 edist (f n) (f m) \u2264 \u2211' (m : \u2115), d (n + m)"}, {"line": "refine le_trans (edist_le_Ico_sum_of_edist_le hnm fun _ _ => hf _) ?_", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 ENNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 d n\na : \u03b1\nha : Tendsto f atTop (nhds a)\nn m : \u2115\nhnm : m \u2265 n\n\u22a2 \u2211 i \u2208 Finset.Ico n m, d i \u2264 \u2211' (m : \u2115), d (n + m)"}, {"line": "rw [Finset.sum_Ico_eq_sum_range]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 ENNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 d n\na : \u03b1\nha : Tendsto f atTop (nhds a)\nn m : \u2115\nhnm : m \u2265 n\n\u22a2 \u2211 k \u2208 Finset.range (m - n), d (n + k) \u2264 \u2211' (m : \u2115), d (n + m)"}, {"line": "exact ENNReal.summable.sum_le_tsum _ (fun _ _ => zero_le _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_le_tsum_of_edist_le_of_tendsto\u2080 {f : \u2115 \u2192 \u03b1} (d : \u2115 \u2192 \u211d\u22650\u221e)\n    (hf : \u2200 n, edist (f n) (f n.succ) \u2264 d n) {a : \u03b1} (ha : Tendsto f atTop (\ud835\udcdd a)) :\n    edist (f 0) a \u2264 \u2211' m, d m := by simpa using edist_le_tsum_of_edist_le_of_tendsto d hf ha 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/ENNReal/Lemmas.lean", "context": {"open": ["Filter Function Metric Set Topology", "scoped Finset ENNReal NNReal", "TopologicalSpace", "Classical in", "Finset", "Classical in", "ENNReal Filter EMetric", "EMetric"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{a b : \u211d\u22650\u221e} {r : \u211d\u22650} {x : \u211d\u22650\u221e} {\u03b5 : \u211d\u22650\u221e}", "{f g : \u03b1 \u2192 \u211d\u22650\u221e}", "[EMetricSpace \u03b2]", "[PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 ENNReal\nhf : \u2200 (n : \u2115), edist (f n) (f n.succ) \u2264 d n\na : \u03b1\nha : Tendsto f atTop (nhds a)\n\u22a2 edist (f 0) a \u2264 \u2211' (m : \u2115), d m"}, {"line": "simpa using edist_le_tsum_of_edist_le_of_tendsto d hf ha 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousAt_add {p : EReal \u00d7 EReal} (h : p.1 \u2260 \u22a4 \u2228 p.2 \u2260 \u22a5) (h' : p.1 \u2260 \u22a5 \u2228 p.2 \u2260 \u22a4) :\n    ContinuousAt (fun p : EReal \u00d7 EReal => p.1 + p.2) p := by\n  rcases p with \u27e8x, y\u27e9\n  induction x <;> induction y\n  \u00b7 exact continuousAt_add_bot_bot\n  \u00b7 exact continuousAt_add_bot_coe _\n  \u00b7 simp at h'\n  \u00b7 exact continuousAt_add_coe_bot _\n  \u00b7 exact continuousAt_add_coe_coe _ _\n  \u00b7 exact continuousAt_add_coe_top _\n  \u00b7 simp at h\n  \u00b7 exact continuousAt_add_top_coe _\n  \u00b7 exact continuousAt_add_top_top\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/EReal/Lemmas.lean", "context": {"open": ["Set Filter Metric TopologicalSpace Topology", "scoped ENNReal"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1]", "{\u03b1 : Type*} {u v : \u03b1 \u2192 EReal}", "{\u03b1 : Type*} {f : Filter \u03b1} {u v : \u03b1 \u2192 EReal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : EReal \u00d7 EReal\nh : p.1 \u2260 \u22a4 \u2228 p.2 \u2260 \u22a5\nh' : p.1 \u2260 \u22a5 \u2228 p.2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) p"}, {"line": "rcases p with \u27e8x, y\u27e9", "tactic_state": "case mk\nx y : EReal\nh : (x, y).1 \u2260 \u22a4 \u2228 (x, y).2 \u2260 \u22a5\nh' : (x, y).1 \u2260 \u22a5 \u2228 (x, y).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (x, y)"}, {"line": "induction x <;> induction y", "tactic_state": "case mk.bot.bot\nh : (\u22a5, \u22a5).1 \u2260 \u22a4 \u2228 (\u22a5, \u22a5).2 \u2260 \u22a5\nh' : (\u22a5, \u22a5).1 \u2260 \u22a5 \u2228 (\u22a5, \u22a5).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a5, \u22a5)\n---\ncase mk.bot.coe\na\u271d : \u211d\nh : (\u22a5, \u2191a\u271d).1 \u2260 \u22a4 \u2228 (\u22a5, \u2191a\u271d).2 \u2260 \u22a5\nh' : (\u22a5, \u2191a\u271d).1 \u2260 \u22a5 \u2228 (\u22a5, \u2191a\u271d).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a5, \u2191a\u271d)\n---\ncase mk.bot.top\nh : (\u22a5, \u22a4).1 \u2260 \u22a4 \u2228 (\u22a5, \u22a4).2 \u2260 \u22a5\nh' : (\u22a5, \u22a4).1 \u2260 \u22a5 \u2228 (\u22a5, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a5, \u22a4)\n---\ncase mk.coe.bot\na\u271d : \u211d\nh : (\u2191a\u271d, \u22a5).1 \u2260 \u22a4 \u2228 (\u2191a\u271d, \u22a5).2 \u2260 \u22a5\nh' : (\u2191a\u271d, \u22a5).1 \u2260 \u22a5 \u2228 (\u2191a\u271d, \u22a5).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u2191a\u271d, \u22a5)\n---\ncase mk.coe.coe\na\u271d\u00b9 a\u271d : \u211d\nh : (\u2191a\u271d\u00b9, \u2191a\u271d).1 \u2260 \u22a4 \u2228 (\u2191a\u271d\u00b9, \u2191a\u271d).2 \u2260 \u22a5\nh' : (\u2191a\u271d\u00b9, \u2191a\u271d).1 \u2260 \u22a5 \u2228 (\u2191a\u271d\u00b9, \u2191a\u271d).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u2191a\u271d\u00b9, \u2191a\u271d)\n---\ncase mk.coe.top\na\u271d : \u211d\nh : (\u2191a\u271d, \u22a4).1 \u2260 \u22a4 \u2228 (\u2191a\u271d, \u22a4).2 \u2260 \u22a5\nh' : (\u2191a\u271d, \u22a4).1 \u2260 \u22a5 \u2228 (\u2191a\u271d, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u2191a\u271d, \u22a4)\n---\ncase mk.top.bot\nh : (\u22a4, \u22a5).1 \u2260 \u22a4 \u2228 (\u22a4, \u22a5).2 \u2260 \u22a5\nh' : (\u22a4, \u22a5).1 \u2260 \u22a5 \u2228 (\u22a4, \u22a5).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u22a5)\n---\ncase mk.top.coe\na\u271d : \u211d\nh : (\u22a4, \u2191a\u271d).1 \u2260 \u22a4 \u2228 (\u22a4, \u2191a\u271d).2 \u2260 \u22a5\nh' : (\u22a4, \u2191a\u271d).1 \u2260 \u22a5 \u2228 (\u22a4, \u2191a\u271d).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u2191a\u271d)\n---\ncase mk.top.top\nh : (\u22a4, \u22a4).1 \u2260 \u22a4 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a5\nh' : (\u22a4, \u22a4).1 \u2260 \u22a5 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u22a4)"}, {"line": "\u00b7 exact continuousAt_add_bot_bot", "tactic_state": "case mk.bot.coe\na\u271d : \u211d\nh : (\u22a5, \u2191a\u271d).1 \u2260 \u22a4 \u2228 (\u22a5, \u2191a\u271d).2 \u2260 \u22a5\nh' : (\u22a5, \u2191a\u271d).1 \u2260 \u22a5 \u2228 (\u22a5, \u2191a\u271d).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a5, \u2191a\u271d)\n---\ncase mk.bot.top\nh : (\u22a5, \u22a4).1 \u2260 \u22a4 \u2228 (\u22a5, \u22a4).2 \u2260 \u22a5\nh' : (\u22a5, \u22a4).1 \u2260 \u22a5 \u2228 (\u22a5, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a5, \u22a4)\n---\ncase mk.coe.bot\na\u271d : \u211d\nh : (\u2191a\u271d, \u22a5).1 \u2260 \u22a4 \u2228 (\u2191a\u271d, \u22a5).2 \u2260 \u22a5\nh' : (\u2191a\u271d, \u22a5).1 \u2260 \u22a5 \u2228 (\u2191a\u271d, \u22a5).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u2191a\u271d, \u22a5)\n---\ncase mk.coe.coe\na\u271d\u00b9 a\u271d : \u211d\nh : (\u2191a\u271d\u00b9, \u2191a\u271d).1 \u2260 \u22a4 \u2228 (\u2191a\u271d\u00b9, \u2191a\u271d).2 \u2260 \u22a5\nh' : (\u2191a\u271d\u00b9, \u2191a\u271d).1 \u2260 \u22a5 \u2228 (\u2191a\u271d\u00b9, \u2191a\u271d).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u2191a\u271d\u00b9, \u2191a\u271d)\n---\ncase mk.coe.top\na\u271d : \u211d\nh : (\u2191a\u271d, \u22a4).1 \u2260 \u22a4 \u2228 (\u2191a\u271d, \u22a4).2 \u2260 \u22a5\nh' : (\u2191a\u271d, \u22a4).1 \u2260 \u22a5 \u2228 (\u2191a\u271d, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u2191a\u271d, \u22a4)\n---\ncase mk.top.bot\nh : (\u22a4, \u22a5).1 \u2260 \u22a4 \u2228 (\u22a4, \u22a5).2 \u2260 \u22a5\nh' : (\u22a4, \u22a5).1 \u2260 \u22a5 \u2228 (\u22a4, \u22a5).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u22a5)\n---\ncase mk.top.coe\na\u271d : \u211d\nh : (\u22a4, \u2191a\u271d).1 \u2260 \u22a4 \u2228 (\u22a4, \u2191a\u271d).2 \u2260 \u22a5\nh' : (\u22a4, \u2191a\u271d).1 \u2260 \u22a5 \u2228 (\u22a4, \u2191a\u271d).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u2191a\u271d)\n---\ncase mk.top.top\nh : (\u22a4, \u22a4).1 \u2260 \u22a4 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a5\nh' : (\u22a4, \u22a4).1 \u2260 \u22a5 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u22a4)"}, {"line": "\u00b7 exact continuousAt_add_bot_coe _", "tactic_state": "case mk.bot.top\nh : (\u22a5, \u22a4).1 \u2260 \u22a4 \u2228 (\u22a5, \u22a4).2 \u2260 \u22a5\nh' : (\u22a5, \u22a4).1 \u2260 \u22a5 \u2228 (\u22a5, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a5, \u22a4)\n---\ncase mk.coe.bot\na\u271d : \u211d\nh : (\u2191a\u271d, \u22a5).1 \u2260 \u22a4 \u2228 (\u2191a\u271d, \u22a5).2 \u2260 \u22a5\nh' : (\u2191a\u271d, \u22a5).1 \u2260 \u22a5 \u2228 (\u2191a\u271d, \u22a5).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u2191a\u271d, \u22a5)\n---\ncase mk.coe.coe\na\u271d\u00b9 a\u271d : \u211d\nh : (\u2191a\u271d\u00b9, \u2191a\u271d).1 \u2260 \u22a4 \u2228 (\u2191a\u271d\u00b9, \u2191a\u271d).2 \u2260 \u22a5\nh' : (\u2191a\u271d\u00b9, \u2191a\u271d).1 \u2260 \u22a5 \u2228 (\u2191a\u271d\u00b9, \u2191a\u271d).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u2191a\u271d\u00b9, \u2191a\u271d)\n---\ncase mk.coe.top\na\u271d : \u211d\nh : (\u2191a\u271d, \u22a4).1 \u2260 \u22a4 \u2228 (\u2191a\u271d, \u22a4).2 \u2260 \u22a5\nh' : (\u2191a\u271d, \u22a4).1 \u2260 \u22a5 \u2228 (\u2191a\u271d, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u2191a\u271d, \u22a4)\n---\ncase mk.top.bot\nh : (\u22a4, \u22a5).1 \u2260 \u22a4 \u2228 (\u22a4, \u22a5).2 \u2260 \u22a5\nh' : (\u22a4, \u22a5).1 \u2260 \u22a5 \u2228 (\u22a4, \u22a5).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u22a5)\n---\ncase mk.top.coe\na\u271d : \u211d\nh : (\u22a4, \u2191a\u271d).1 \u2260 \u22a4 \u2228 (\u22a4, \u2191a\u271d).2 \u2260 \u22a5\nh' : (\u22a4, \u2191a\u271d).1 \u2260 \u22a5 \u2228 (\u22a4, \u2191a\u271d).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u2191a\u271d)\n---\ncase mk.top.top\nh : (\u22a4, \u22a4).1 \u2260 \u22a4 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a5\nh' : (\u22a4, \u22a4).1 \u2260 \u22a5 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u22a4)"}, {"line": "\u00b7 simp at h'", "tactic_state": "case mk.coe.bot\na\u271d : \u211d\nh : (\u2191a\u271d, \u22a5).1 \u2260 \u22a4 \u2228 (\u2191a\u271d, \u22a5).2 \u2260 \u22a5\nh' : (\u2191a\u271d, \u22a5).1 \u2260 \u22a5 \u2228 (\u2191a\u271d, \u22a5).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u2191a\u271d, \u22a5)\n---\ncase mk.coe.coe\na\u271d\u00b9 a\u271d : \u211d\nh : (\u2191a\u271d\u00b9, \u2191a\u271d).1 \u2260 \u22a4 \u2228 (\u2191a\u271d\u00b9, \u2191a\u271d).2 \u2260 \u22a5\nh' : (\u2191a\u271d\u00b9, \u2191a\u271d).1 \u2260 \u22a5 \u2228 (\u2191a\u271d\u00b9, \u2191a\u271d).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u2191a\u271d\u00b9, \u2191a\u271d)\n---\ncase mk.coe.top\na\u271d : \u211d\nh : (\u2191a\u271d, \u22a4).1 \u2260 \u22a4 \u2228 (\u2191a\u271d, \u22a4).2 \u2260 \u22a5\nh' : (\u2191a\u271d, \u22a4).1 \u2260 \u22a5 \u2228 (\u2191a\u271d, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u2191a\u271d, \u22a4)\n---\ncase mk.top.bot\nh : (\u22a4, \u22a5).1 \u2260 \u22a4 \u2228 (\u22a4, \u22a5).2 \u2260 \u22a5\nh' : (\u22a4, \u22a5).1 \u2260 \u22a5 \u2228 (\u22a4, \u22a5).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u22a5)\n---\ncase mk.top.coe\na\u271d : \u211d\nh : (\u22a4, \u2191a\u271d).1 \u2260 \u22a4 \u2228 (\u22a4, \u2191a\u271d).2 \u2260 \u22a5\nh' : (\u22a4, \u2191a\u271d).1 \u2260 \u22a5 \u2228 (\u22a4, \u2191a\u271d).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u2191a\u271d)\n---\ncase mk.top.top\nh : (\u22a4, \u22a4).1 \u2260 \u22a4 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a5\nh' : (\u22a4, \u22a4).1 \u2260 \u22a5 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u22a4)"}, {"line": "\u00b7 exact continuousAt_add_coe_bot _", "tactic_state": "case mk.coe.coe\na\u271d\u00b9 a\u271d : \u211d\nh : (\u2191a\u271d\u00b9, \u2191a\u271d).1 \u2260 \u22a4 \u2228 (\u2191a\u271d\u00b9, \u2191a\u271d).2 \u2260 \u22a5\nh' : (\u2191a\u271d\u00b9, \u2191a\u271d).1 \u2260 \u22a5 \u2228 (\u2191a\u271d\u00b9, \u2191a\u271d).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u2191a\u271d\u00b9, \u2191a\u271d)\n---\ncase mk.coe.top\na\u271d : \u211d\nh : (\u2191a\u271d, \u22a4).1 \u2260 \u22a4 \u2228 (\u2191a\u271d, \u22a4).2 \u2260 \u22a5\nh' : (\u2191a\u271d, \u22a4).1 \u2260 \u22a5 \u2228 (\u2191a\u271d, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u2191a\u271d, \u22a4)\n---\ncase mk.top.bot\nh : (\u22a4, \u22a5).1 \u2260 \u22a4 \u2228 (\u22a4, \u22a5).2 \u2260 \u22a5\nh' : (\u22a4, \u22a5).1 \u2260 \u22a5 \u2228 (\u22a4, \u22a5).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u22a5)\n---\ncase mk.top.coe\na\u271d : \u211d\nh : (\u22a4, \u2191a\u271d).1 \u2260 \u22a4 \u2228 (\u22a4, \u2191a\u271d).2 \u2260 \u22a5\nh' : (\u22a4, \u2191a\u271d).1 \u2260 \u22a5 \u2228 (\u22a4, \u2191a\u271d).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u2191a\u271d)\n---\ncase mk.top.top\nh : (\u22a4, \u22a4).1 \u2260 \u22a4 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a5\nh' : (\u22a4, \u22a4).1 \u2260 \u22a5 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u22a4)"}, {"line": "\u00b7 exact continuousAt_add_coe_coe _ _", "tactic_state": "case mk.coe.top\na\u271d : \u211d\nh : (\u2191a\u271d, \u22a4).1 \u2260 \u22a4 \u2228 (\u2191a\u271d, \u22a4).2 \u2260 \u22a5\nh' : (\u2191a\u271d, \u22a4).1 \u2260 \u22a5 \u2228 (\u2191a\u271d, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u2191a\u271d, \u22a4)\n---\ncase mk.top.bot\nh : (\u22a4, \u22a5).1 \u2260 \u22a4 \u2228 (\u22a4, \u22a5).2 \u2260 \u22a5\nh' : (\u22a4, \u22a5).1 \u2260 \u22a5 \u2228 (\u22a4, \u22a5).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u22a5)\n---\ncase mk.top.coe\na\u271d : \u211d\nh : (\u22a4, \u2191a\u271d).1 \u2260 \u22a4 \u2228 (\u22a4, \u2191a\u271d).2 \u2260 \u22a5\nh' : (\u22a4, \u2191a\u271d).1 \u2260 \u22a5 \u2228 (\u22a4, \u2191a\u271d).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u2191a\u271d)\n---\ncase mk.top.top\nh : (\u22a4, \u22a4).1 \u2260 \u22a4 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a5\nh' : (\u22a4, \u22a4).1 \u2260 \u22a5 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u22a4)"}, {"line": "\u00b7 exact continuousAt_add_coe_top _", "tactic_state": "case mk.top.bot\nh : (\u22a4, \u22a5).1 \u2260 \u22a4 \u2228 (\u22a4, \u22a5).2 \u2260 \u22a5\nh' : (\u22a4, \u22a5).1 \u2260 \u22a5 \u2228 (\u22a4, \u22a5).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u22a5)\n---\ncase mk.top.coe\na\u271d : \u211d\nh : (\u22a4, \u2191a\u271d).1 \u2260 \u22a4 \u2228 (\u22a4, \u2191a\u271d).2 \u2260 \u22a5\nh' : (\u22a4, \u2191a\u271d).1 \u2260 \u22a5 \u2228 (\u22a4, \u2191a\u271d).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u2191a\u271d)\n---\ncase mk.top.top\nh : (\u22a4, \u22a4).1 \u2260 \u22a4 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a5\nh' : (\u22a4, \u22a4).1 \u2260 \u22a5 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u22a4)"}, {"line": "\u00b7 simp at h", "tactic_state": "case mk.top.coe\na\u271d : \u211d\nh : (\u22a4, \u2191a\u271d).1 \u2260 \u22a4 \u2228 (\u22a4, \u2191a\u271d).2 \u2260 \u22a5\nh' : (\u22a4, \u2191a\u271d).1 \u2260 \u22a5 \u2228 (\u22a4, \u2191a\u271d).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u2191a\u271d)\n---\ncase mk.top.top\nh : (\u22a4, \u22a4).1 \u2260 \u22a4 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a5\nh' : (\u22a4, \u22a4).1 \u2260 \u22a5 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u22a4)"}, {"line": "\u00b7 exact continuousAt_add_top_coe _", "tactic_state": "case mk.top.top\nh : (\u22a4, \u22a4).1 \u2260 \u22a4 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a5\nh' : (\u22a4, \u22a4).1 \u2260 \u22a5 \u2228 (\u22a4, \u22a4).2 \u2260 \u22a4\n\u22a2 ContinuousAt (fun p => p.1 + p.2) (\u22a4, \u22a4)"}, {"line": "\u00b7 exact continuousAt_add_top_top", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma continuousAt_mul_swap {a b : EReal}\n    (h : ContinuousAt (fun p : EReal \u00d7 EReal \u21a6 p.1 * p.2) (a, b)) :\n    ContinuousAt (fun p : EReal \u00d7 EReal \u21a6 p.1 * p.2) (b, a) := by\n  convert h.comp continuous_swap.continuousAt (x := (b, a))\n  simp [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/EReal/Lemmas.lean", "context": {"open": ["Set Filter Metric TopologicalSpace Topology", "scoped ENNReal"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1]", "{\u03b1 : Type*} {u v : \u03b1 \u2192 EReal}", "{\u03b1 : Type*} {f : Filter \u03b1} {u v : \u03b1 \u2192 EReal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : EReal\nh : ContinuousAt (fun p => p.1 * p.2) (a, b)\n\u22a2 ContinuousAt (fun p => p.1 * p.2) (b, a)"}, {"line": "convert h.comp continuous_swap.continuousAt (x := (b, a))", "tactic_state": "case h.e'_5.h\na b : EReal\nh : ContinuousAt (fun p => p.1 * p.2) (a, b)\nx\u271d : EReal \u00d7 EReal\n\u22a2 x\u271d.1 * x\u271d.2 = ((fun p => p.1 * p.2) \u2218 Prod.swap) x\u271d"}, {"line": "simp [mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma continuousAt_mul_symm1 {a b : EReal}\n    (h : ContinuousAt (fun p : EReal \u00d7 EReal \u21a6 p.1 * p.2) (a, b)) :\n    ContinuousAt (fun p : EReal \u00d7 EReal \u21a6 p.1 * p.2) (-a, b) := by\n  have : (fun p : EReal \u00d7 EReal \u21a6 p.1 * p.2) = (fun x : EReal \u21a6 -x)\n      \u2218 (fun p : EReal \u00d7 EReal \u21a6 p.1 * p.2) \u2218 (fun p : EReal \u00d7 EReal \u21a6 (-p.1, p.2)) := by\n    ext p\n    simp\n  rw [this]\n  apply ContinuousAt.comp (Continuous.continuousAt continuous_neg)\n    <| ContinuousAt.comp _ (ContinuousAt.prodMap (Continuous.continuousAt continuous_neg)\n      (Continuous.continuousAt continuous_id))\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/EReal/Lemmas.lean", "context": {"open": ["Set Filter Metric TopologicalSpace Topology", "scoped ENNReal"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1]", "{\u03b1 : Type*} {u v : \u03b1 \u2192 EReal}", "{\u03b1 : Type*} {f : Filter \u03b1} {u v : \u03b1 \u2192 EReal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : EReal\nh : ContinuousAt (fun p => p.1 * p.2) (a, b)\n\u22a2 ContinuousAt (fun p => p.1 * p.2) (-a, b)"}, {"line": "have : (fun p : EReal \u00d7 EReal \u21a6 p.1 * p.2) = (fun x : EReal \u21a6 -x)\n      \u2218 (fun p : EReal \u00d7 EReal \u21a6 p.1 * p.2) \u2218 (fun p : EReal \u00d7 EReal \u21a6 (-p.1, p.2)) := by\n    ext p\n    simp", "tactic_state": "a b : EReal\nh : ContinuousAt (fun p => p.1 * p.2) (a, b)\nthis : (fun p => p.1 * p.2) = (fun x => -x) \u2218 (fun p => p.1 * p.2) \u2218 fun p => (-p.1, p.2)\n\u22a2 ContinuousAt (fun p => p.1 * p.2) (-a, b)"}, {"line": "rw [this]", "tactic_state": "a b : EReal\nh : ContinuousAt (fun p => p.1 * p.2) (a, b)\nthis : (fun p => p.1 * p.2) = (fun x => -x) \u2218 (fun p => p.1 * p.2) \u2218 fun p => (-p.1, p.2)\n\u22a2 ContinuousAt ((fun x => -x) \u2218 (fun p => p.1 * p.2) \u2218 fun p => (-p.1, p.2)) (-a, b)"}, {"line": "apply ContinuousAt.comp (Continuous.continuousAt continuous_neg)\n    <| ContinuousAt.comp _ (ContinuousAt.prodMap (Continuous.continuousAt continuous_neg)\n      (Continuous.continuousAt continuous_id))", "tactic_state": "a b : EReal\nh : ContinuousAt (fun p => p.1 * p.2) (a, b)\nthis : (fun p => p.1 * p.2) = (fun x => -x) \u2218 (fun p => p.1 * p.2) \u2218 fun p => (-p.1, p.2)\n\u22a2 ContinuousAt (fun p => p.1 * p.2) (Prod.map (fun a => -a) id (-a, b))"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma continuousAt_mul_coe_coe (a b : \u211d) :\n    ContinuousAt (fun p : EReal \u00d7 EReal \u21a6 p.1 * p.2) (a, b) := by\n  simp [ContinuousAt, EReal.nhds_coe_coe, \u2190 EReal.coe_mul, Filter.tendsto_map'_iff,\n    Function.comp_def, EReal.tendsto_coe, tendsto_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/EReal/Lemmas.lean", "context": {"open": ["Set Filter Metric TopologicalSpace Topology", "scoped ENNReal"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1]", "{\u03b1 : Type*} {u v : \u03b1 \u2192 EReal}", "{\u03b1 : Type*} {f : Filter \u03b1} {u v : \u03b1 \u2192 EReal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u22a2 ContinuousAt (fun p => p.1 * p.2) (\u2191a, \u2191b)"}, {"line": "simp [ContinuousAt, EReal.nhds_coe_coe, \u2190 EReal.coe_mul, Filter.tendsto_map'_iff,\n    Function.comp_def, EReal.tendsto_coe, tendsto_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma continuousAt_mul_top_ne_zero {a : \u211d} (h : a \u2260 0) :\n    ContinuousAt (fun p : EReal \u00d7 EReal \u21a6 p.1 * p.2) (\u22a4, a) := by\n  rcases lt_or_gt_of_ne h with a_neg | a_pos\n  \u00b7 exact neg_neg a \u25b8 continuousAt_mul_symm2 (continuousAt_mul_top_pos (neg_pos.2 a_neg))\n  \u00b7 exact continuousAt_mul_top_pos a_pos\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/EReal/Lemmas.lean", "context": {"open": ["Set Filter Metric TopologicalSpace Topology", "scoped ENNReal"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1]", "{\u03b1 : Type*} {u v : \u03b1 \u2192 EReal}", "{\u03b1 : Type*} {f : Filter \u03b1} {u v : \u03b1 \u2192 EReal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\nh : a \u2260 0\n\u22a2 ContinuousAt (fun p => p.1 * p.2) (\u22a4, \u2191a)"}, {"line": "rcases lt_or_gt_of_ne h with a_neg | a_pos", "tactic_state": "case inl\na : \u211d\nh : a \u2260 0\na_neg : a < 0\n\u22a2 ContinuousAt (fun p => p.1 * p.2) (\u22a4, \u2191a)\n---\ncase inr\na : \u211d\nh : a \u2260 0\na_pos : a > 0\n\u22a2 ContinuousAt (fun p => p.1 * p.2) (\u22a4, \u2191a)"}, {"line": "\u00b7 exact neg_neg a \u25b8 continuousAt_mul_symm2 (continuousAt_mul_top_pos (neg_pos.2 a_neg))", "tactic_state": "case inr\na : \u211d\nh : a \u2260 0\na_pos : a > 0\n\u22a2 ContinuousAt (fun p => p.1 * p.2) (\u22a4, \u2191a)"}, {"line": "\u00b7 exact continuousAt_mul_top_pos a_pos", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lowerSemicontinuous_add : LowerSemicontinuous fun p : EReal \u00d7 EReal \u21a6 p.1 + p.2 := by\n  intro x y\n  by_cases hx\u2081 : x.1 = \u22a5\n  \u00b7 simp [hx\u2081]\n  by_cases hx\u2082 : x.2 = \u22a5\n  \u00b7 simp [hx\u2082]\n  \u00b7 exact continuousAt_add (.inr hx\u2082) (.inl hx\u2081) |>.lowerSemicontinuousAt _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/EReal/Lemmas.lean", "context": {"open": ["Set Filter Metric TopologicalSpace Topology", "scoped ENNReal"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1]", "{\u03b1 : Type*} {u v : \u03b1 \u2192 EReal}", "{\u03b1 : Type*} {f : Filter \u03b1} {u v : \u03b1 \u2192 EReal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 LowerSemicontinuous fun p => p.1 + p.2"}, {"line": "intro x y", "tactic_state": "x : EReal \u00d7 EReal\ny : EReal\n\u22a2 y < (fun p => p.1 + p.2) x \u2192 \u2200\u1da0 (x' : EReal \u00d7 EReal) in nhds x, y < (fun p => p.1 + p.2) x'"}, {"line": "by_cases hx\u2081 : x.1 = \u22a5", "tactic_state": "case pos\nx : EReal \u00d7 EReal\ny : EReal\nhx\u2081 : x.1 = \u22a5\n\u22a2 y < (fun p => p.1 + p.2) x \u2192 \u2200\u1da0 (x' : EReal \u00d7 EReal) in nhds x, y < (fun p => p.1 + p.2) x'\n---\ncase neg\nx : EReal \u00d7 EReal\ny : EReal\nhx\u2081 : \u00acx.1 = \u22a5\n\u22a2 y < (fun p => p.1 + p.2) x \u2192 \u2200\u1da0 (x' : EReal \u00d7 EReal) in nhds x, y < (fun p => p.1 + p.2) x'"}, {"line": "\u00b7 simp [hx\u2081]", "tactic_state": "case neg\nx : EReal \u00d7 EReal\ny : EReal\nhx\u2081 : \u00acx.1 = \u22a5\n\u22a2 y < (fun p => p.1 + p.2) x \u2192 \u2200\u1da0 (x' : EReal \u00d7 EReal) in nhds x, y < (fun p => p.1 + p.2) x'"}, {"line": "by_cases hx\u2082 : x.2 = \u22a5", "tactic_state": "case pos\nx : EReal \u00d7 EReal\ny : EReal\nhx\u2081 : \u00acx.1 = \u22a5\nhx\u2082 : x.2 = \u22a5\n\u22a2 y < (fun p => p.1 + p.2) x \u2192 \u2200\u1da0 (x' : EReal \u00d7 EReal) in nhds x, y < (fun p => p.1 + p.2) x'\n---\ncase neg\nx : EReal \u00d7 EReal\ny : EReal\nhx\u2081 : \u00acx.1 = \u22a5\nhx\u2082 : \u00acx.2 = \u22a5\n\u22a2 y < (fun p => p.1 + p.2) x \u2192 \u2200\u1da0 (x' : EReal \u00d7 EReal) in nhds x, y < (fun p => p.1 + p.2) x'"}, {"line": "\u00b7 simp [hx\u2082]", "tactic_state": "case neg\nx : EReal \u00d7 EReal\ny : EReal\nhx\u2081 : \u00acx.1 = \u22a5\nhx\u2082 : \u00acx.2 = \u22a5\n\u22a2 y < (fun p => p.1 + p.2) x \u2192 \u2200\u1da0 (x' : EReal \u00d7 EReal) in nhds x, y < (fun p => p.1 + p.2) x'"}, {"line": "\u00b7 exact continuousAt_add (.inr hx\u2082) (.inl hx\u2081) |>.lowerSemicontinuousAt _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Real.comap_toNNReal_atTop : comap Real.toNNReal atTop = atTop := by\n  refine le_antisymm ?_ tendsto_real_toNNReal_atTop.le_comap\n  refine (atTop_basis_Ioi' 0).ge_iff.2 fun a ha \u21a6 ?_\n  filter_upwards [preimage_mem_comap (Ioi_mem_atTop a.toNNReal)] with x hx\n  exact (Real.toNNReal_lt_toNNReal_iff_of_nonneg ha.le).1 hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/NNReal/Lemmas.lean", "context": {"open": ["Filter Metric Set TopologicalSpace Topology", "Filter Finset"], "variables": ["{\u03b9 : Sort*} {n : \u2115}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 comap Real.toNNReal atTop = atTop"}, {"line": "refine le_antisymm ?_ tendsto_real_toNNReal_atTop.le_comap", "tactic_state": "\u22a2 comap Real.toNNReal atTop \u2264 atTop"}, {"line": "refine (atTop_basis_Ioi' 0).ge_iff.2 fun a ha \u21a6 ?_", "tactic_state": "a : \u211d\nha : 0 < a\n\u22a2 Set.Ioi a \u2208 comap Real.toNNReal atTop"}, {"line": "filter_upwards [preimage_mem_comap (Ioi_mem_atTop a.toNNReal)] with x hx", "tactic_state": "case h\na : \u211d\nha : 0 < a\nx : \u211d\nhx : x \u2208 Real.toNNReal \u207b\u00b9' Set.Ioi a.toNNReal\n\u22a2 x \u2208 Set.Ioi a"}, {"line": "exact (Real.toNNReal_lt_toNNReal_iff_of_nonneg ha.le).1 hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Real.tendsto_toNNReal_atTop_iff {l : Filter \u03b1} {f : \u03b1 \u2192 \u211d} :\n    Tendsto (fun x \u21a6 (f x).toNNReal) l atTop \u2194 Tendsto f l atTop := by\n  rw [\u2190 Real.comap_toNNReal_atTop]\n  rw [tendsto_comap_iff]\n  rw [Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/NNReal/Lemmas.lean", "context": {"open": ["Filter Metric Set TopologicalSpace Topology", "Filter Finset"], "variables": ["{\u03b9 : Sort*} {n : \u2115}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nl : Filter \u03b1\nf : \u03b1 \u2192 \u211d\n\u22a2 Tendsto (fun x => (f x).toNNReal) l atTop \u2194 Tendsto f l atTop"}, {"line": "rw [\u2190 Real.comap_toNNReal_atTop]", "tactic_state": "\u03b1 : Type u_2\nl : Filter \u03b1\nf : \u03b1 \u2192 \u211d\n\u22a2 Tendsto (fun x => (f x).toNNReal) l atTop \u2194 Tendsto f l (comap Real.toNNReal atTop)"}, {"line": "rw [tendsto_comap_iff]", "tactic_state": "\u03b1 : Type u_2\nl : Filter \u03b1\nf : \u03b1 \u2192 \u211d\n\u22a2 Tendsto (fun x => (f x).toNNReal) l atTop \u2194 Tendsto (Real.toNNReal \u2218 f) l atTop"}, {"line": "rw [Function.comp_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Real.tendsto_of_bddAbove_monotone {f : \u2115 \u2192 \u211d} (h_bdd : BddAbove (Set.range f))\n    (h_mon : Monotone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isLUB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isLUB h_mon hB\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/NNReal/Lemmas.lean", "context": {"open": ["Filter Metric Set TopologicalSpace Topology", "Filter Finset"], "variables": ["{\u03b9 : Sort*} {n : \u2115}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u211d\nh_bdd : BddAbove (Set.range f)\nh_mon : Monotone f\n\u22a2 \u2203 r, Tendsto f atTop (nhds r)"}, {"line": "obtain \u27e8B, hB\u27e9 := Real.exists_isLUB (Set.range_nonempty f) h_bdd", "tactic_state": "case intro\nf : \u2115 \u2192 \u211d\nh_bdd : BddAbove (Set.range f)\nh_mon : Monotone f\nB : \u211d\nhB : IsLUB (Set.range f) B\n\u22a2 \u2203 r, Tendsto f atTop (nhds r)"}, {"line": "exact \u27e8B, tendsto_atTop_isLUB h_mon hB\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Real.tendsto_of_bddBelow_antitone {f : \u2115 \u2192 \u211d} (h_bdd : BddBelow (Set.range f))\n    (h_ant : Antitone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isGLB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isGLB h_ant hB\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/NNReal/Lemmas.lean", "context": {"open": ["Filter Metric Set TopologicalSpace Topology", "Filter Finset"], "variables": ["{\u03b9 : Sort*} {n : \u2115}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u211d\nh_bdd : BddBelow (Set.range f)\nh_ant : Antitone f\n\u22a2 \u2203 r, Tendsto f atTop (nhds r)"}, {"line": "obtain \u27e8B, hB\u27e9 := Real.exists_isGLB (Set.range_nonempty f) h_bdd", "tactic_state": "case intro\nf : \u2115 \u2192 \u211d\nh_bdd : BddBelow (Set.range f)\nh_ant : Antitone f\nB : \u211d\nhB : IsGLB (Set.range f) B\n\u22a2 \u2203 r, Tendsto f atTop (nhds r)"}, {"line": "exact \u27e8B, tendsto_atTop_isGLB h_ant hB\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Real.iSup_pow_of_ne_zero {f : \u03b9 \u2192 \u211d} (hf : \u2200 i, 0 \u2264 f i) (hn : n \u2260 0) :\n    (\u2a06 i, f i) ^ n = \u2a06 i, f i ^ n := by\n  cases isEmpty_or_nonempty \u03b9\n  \u00b7 simp [hn]\n  \u00b7 exact iSup_pow hf _", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/NNReal/Lemmas.lean", "context": {"open": ["Filter Metric Set TopologicalSpace Topology", "Filter Finset", "NNReal ENNReal in", "NNReal in"], "variables": ["{\u03b9 : Sort*} {n : \u2115}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_2\nn : \u2115\nf : \u03b9 \u2192 \u211d\nhf : \u2200 (i : \u03b9), 0 \u2264 f i\nhn : n \u2260 0\n\u22a2 (\u2a06 i, f i) ^ n = \u2a06 i, f i ^ n"}, {"line": "cases isEmpty_or_nonempty \u03b9", "tactic_state": "case inl\n\u03b9 : Sort u_2\nn : \u2115\nf : \u03b9 \u2192 \u211d\nhf : \u2200 (i : \u03b9), 0 \u2264 f i\nhn : n \u2260 0\nh\u271d : IsEmpty \u03b9\n\u22a2 (\u2a06 i, f i) ^ n = \u2a06 i, f i ^ n\n---\ncase inr\n\u03b9 : Sort u_2\nn : \u2115\nf : \u03b9 \u2192 \u211d\nhf : \u2200 (i : \u03b9), 0 \u2264 f i\nhn : n \u2260 0\nh\u271d : Nonempty \u03b9\n\u22a2 (\u2a06 i, f i) ^ n = \u2a06 i, f i ^ n"}, {"line": "\u00b7 simp [hn]", "tactic_state": "case inr\n\u03b9 : Sort u_2\nn : \u2115\nf : \u03b9 \u2192 \u211d\nhf : \u2200 (i : \u03b9), 0 \u2264 f i\nhn : n \u2260 0\nh\u271d : Nonempty \u03b9\n\u22a2 (\u2a06 i, f i) ^ n = \u2a06 i, f i ^ n"}, {"line": "\u00b7 exact iSup_pow hf _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.cobounded_eq : cobounded \u211d = atBot \u2294 atTop := by\n  simp only [\u2190 comap_dist_right_atTop (0 : \u211d)]\n  simp only [Real.dist_eq]\n  simp only [sub_zero]\n  simp only [comap_abs_atTop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/Real/Lemmas.lean", "context": {"open": ["Filter Int Metric Set TopologicalSpace Bornology", "scoped Topology Uniformity Interval"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 cobounded \u211d = atBot \u2294 atTop"}, {"line": "simp only [\u2190 comap_dist_right_atTop (0 : \u211d)]", "tactic_state": "\u22a2 comap (fun x => dist x 0) atTop = atBot \u2294 atTop"}, {"line": "simp only [Real.dist_eq]", "tactic_state": "\u22a2 comap (fun x => |x - 0|) atTop = atBot \u2294 atTop"}, {"line": "simp only [sub_zero]", "tactic_state": "\u22a2 comap (fun x => |x|) atTop = atBot \u2294 atTop"}, {"line": "simp only [comap_abs_atTop]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.mem_closure_iff {s : Set \u211d} {x : \u211d} :\n    x \u2208 closure s \u2194 \u2200 \u03b5 > 0, \u2203 y \u2208 s, |y - x| < \u03b5 := by\n  simp [mem_closure_iff_nhds_basis nhds_basis_ball, Real.dist_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/Real/Lemmas.lean", "context": {"open": ["Filter Int Metric Set TopologicalSpace Bornology", "scoped Topology Uniformity Interval"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set \u211d\nx : \u211d\n\u22a2 x \u2208 closure s \u2194 \u2200 \u03b5 > 0, \u2203 y \u2208 s, |y - x| < \u03b5"}, {"line": "simp [mem_closure_iff_nhds_basis nhds_basis_ball, Real.dist_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.subfield_eq_of_closed {K : Subfield \u211d} (hc : IsClosed (K : Set \u211d)) : K = \u22a4 := by\n  rw [SetLike.ext'_iff]\n  rw [Subfield.coe_top]\n  rw [\u2190 hc.closure_eq]\n  refine Rat.denseRange_cast.mono ?_ |>.closure_eq\n  rintro - \u27e8_, rfl\u27e9\n  exact SubfieldClass.ratCast_mem K _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Instances/Real/Lemmas.lean", "context": {"open": ["Filter Int Metric Set TopologicalSpace Bornology", "scoped Topology Uniformity Interval"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Subfield \u211d\nhc : IsClosed \u2191K\n\u22a2 K = \u22a4"}, {"line": "rw [SetLike.ext'_iff]", "tactic_state": "K : Subfield \u211d\nhc : IsClosed \u2191K\n\u22a2 \u2191K = \u2191\u22a4"}, {"line": "rw [Subfield.coe_top]", "tactic_state": "K : Subfield \u211d\nhc : IsClosed \u2191K\n\u22a2 \u2191K = univ"}, {"line": "rw [\u2190 hc.closure_eq]", "tactic_state": "K : Subfield \u211d\nhc : IsClosed \u2191K\n\u22a2 closure \u2191K = univ"}, {"line": "refine Rat.denseRange_cast.mono ?_ |>.closure_eq", "tactic_state": "K : Subfield \u211d\nhc : IsClosed \u2191K\n\u22a2 Set.range Rat.cast \u2286 \u2191K"}, {"line": "rintro - \u27e8_, rfl\u27e9", "tactic_state": "case intro\nK : Subfield \u211d\nhc : IsClosed \u2191K\nw\u271d : \u211a\n\u22a2 \u2191w\u271d \u2208 \u2191K"}, {"line": "exact SubfieldClass.ratCast_mem K _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_frontier_subset_frontier_preimage (hf : IsOpenMap f) {s : Set Y} :\n    f \u207b\u00b9' frontier s \u2286 frontier (f \u207b\u00b9' s) := by\n  simpa only [frontier_eq_closure_inter_closure,preimage_inter] using\n    inter_subset_inter hf.preimage_closure_subset_closure_preimage\n      hf.preimage_closure_subset_closure_preimage\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Maps/Basic.lean", "context": {"open": ["Set Filter Function", "TopologicalSpace Topology Filter"], "variables": ["{X : Type*} {Y : Type*} {Z : Type*} {\u03b9 : Type*} {f : X \u2192 Y} {g : Y \u2192 Z}", "[TopologicalSpace Y]", "[TopologicalSpace X]", "[TopologicalSpace Z]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\nf : X \u2192 Y\ninst\u271d\u2077 : TopologicalSpace Y\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nhf : IsOpenMap f\ns : Set Y\n\u22a2 f \u207b\u00b9' frontier s \u2286 frontier (f \u207b\u00b9' s)"}, {"line": "simpa only [frontier_eq_closure_inter_closure,preimage_inter] using\n    inter_subset_inter hf.preimage_closure_subset_closure_preimage\n      hf.preimage_closure_subset_closure_preimage", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosedMap_iff_clusterPt :\n    IsClosedMap f \u2194 \u2200 s y, MapClusterPt y (\ud835\udcdf s) f \u2192 \u2203 x, f x = y \u2227 ClusterPt x (\ud835\udcdf s) := by\n  simp [MapClusterPt, isClosedMap_iff_closure_image, subset_def, mem_closure_iff_clusterPt,\n    and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Maps/Basic.lean", "context": {"open": ["Set Filter Function", "TopologicalSpace Topology Filter", "Function"], "variables": ["{X : Type*} {Y : Type*} {Z : Type*} {\u03b9 : Type*} {f : X \u2192 Y} {g : Y \u2192 Z}", "[TopologicalSpace Y]", "[TopologicalSpace X]", "[TopologicalSpace Z]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\nf : X \u2192 Y\ninst\u271d\u2079 : TopologicalSpace Y\ninst\u271d\u2078 inst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : TopologicalSpace Y\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u22a2 IsClosedMap f \u2194 \u2200 (s : Set X) (y : Y), MapClusterPt y (principal s) f \u2192 \u2203 x, f x = y \u2227 ClusterPt x (principal s)"}, {"line": "simp [MapClusterPt, isClosedMap_iff_closure_image, subset_def, mem_closure_iff_clusterPt,\n    and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsOpenEmbedding.of_continuous_injective_isOpenMap\n    (h\u2081 : Continuous f) (h\u2082 : Injective f) (h\u2083 : IsOpenMap f) : IsOpenEmbedding f := by\n  simp only [isOpenEmbedding_iff_isEmbedding_isOpenMap]\n  simp only [isEmbedding_iff]\n  simp only [isInducing_iff_nhds]\n  simp only [*]\n  simp only [and_true]\n  exact fun x =>\n    le_antisymm (h\u2081.tendsto _).le_comap (@comap_map _ _ (\ud835\udcdd x) _ h\u2082 \u25b8 comap_mono (h\u2083.nhds_le _))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Maps/Basic.lean", "context": {"open": ["Set Filter Function", "TopologicalSpace Topology Filter", "Function"], "variables": ["{X : Type*} {Y : Type*} {Z : Type*} {\u03b9 : Type*} {f : X \u2192 Y} {g : Y \u2192 Z}", "[TopologicalSpace Y]", "[TopologicalSpace X]", "[TopologicalSpace Z]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "[TopologicalSpace X] [TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\nf : X \u2192 Y\ninst\u271d\u00b9\u00b9 : TopologicalSpace Y\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : TopologicalSpace X\ninst\u271d\u2078 : TopologicalSpace Y\ninst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : TopologicalSpace Y\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nh\u2081 : Continuous f\nh\u2082 : Injective f\nh\u2083 : IsOpenMap f\n\u22a2 IsOpenEmbedding f"}, {"line": "simp only [isOpenEmbedding_iff_isEmbedding_isOpenMap]", "tactic_state": "X : Type u_1\nY : Type u_2\nf : X \u2192 Y\ninst\u271d\u00b9\u00b9 : TopologicalSpace Y\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : TopologicalSpace X\ninst\u271d\u2078 : TopologicalSpace Y\ninst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : TopologicalSpace Y\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nh\u2081 : Continuous f\nh\u2082 : Injective f\nh\u2083 : IsOpenMap f\n\u22a2 IsEmbedding f \u2227 IsOpenMap f"}, {"line": "simp only [isEmbedding_iff]", "tactic_state": "X : Type u_1\nY : Type u_2\nf : X \u2192 Y\ninst\u271d\u00b9\u00b9 : TopologicalSpace Y\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : TopologicalSpace X\ninst\u271d\u2078 : TopologicalSpace Y\ninst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : TopologicalSpace Y\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nh\u2081 : Continuous f\nh\u2082 : Injective f\nh\u2083 : IsOpenMap f\n\u22a2 (IsInducing f \u2227 Injective f) \u2227 IsOpenMap f"}, {"line": "simp only [isInducing_iff_nhds]", "tactic_state": "X : Type u_1\nY : Type u_2\nf : X \u2192 Y\ninst\u271d\u00b9\u00b9 : TopologicalSpace Y\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : TopologicalSpace X\ninst\u271d\u2078 : TopologicalSpace Y\ninst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : TopologicalSpace Y\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nh\u2081 : Continuous f\nh\u2082 : Injective f\nh\u2083 : IsOpenMap f\n\u22a2 ((\u2200 (x : X), nhds x = comap f (nhds (f x))) \u2227 Injective f) \u2227 IsOpenMap f"}, {"line": "simp only [*]", "tactic_state": "X : Type u_1\nY : Type u_2\nf : X \u2192 Y\ninst\u271d\u00b9\u00b9 : TopologicalSpace Y\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : TopologicalSpace X\ninst\u271d\u2078 : TopologicalSpace Y\ninst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : TopologicalSpace Y\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nh\u2081 : Continuous f\nh\u2082 : Injective f\nh\u2083 : IsOpenMap f\n\u22a2 ((\u2200 (x : X), nhds x = comap f (nhds (f x))) \u2227 True) \u2227 True"}, {"line": "simp only [and_true]", "tactic_state": "X : Type u_1\nY : Type u_2\nf : X \u2192 Y\ninst\u271d\u00b9\u00b9 : TopologicalSpace Y\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : TopologicalSpace X\ninst\u271d\u2078 : TopologicalSpace Y\ninst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : TopologicalSpace Y\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nh\u2081 : Continuous f\nh\u2082 : Injective f\nh\u2083 : IsOpenMap f\n\u22a2 \u2200 (x : X), nhds x = comap f (nhds (f x))"}, {"line": "exact fun x =>\n    le_antisymm (h\u2081.tendsto _).le_comap (@comap_map _ _ (\ud835\udcdd x) _ h\u2082 \u25b8 comap_mono (h\u2083.nhds_le _))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem antilipschitzWith_iff_le_mul_nndist :\n    AntilipschitzWith K f \u2194 \u2200 x y, nndist x y \u2264 K * nndist (f x) (f y) := by\n  simp only [AntilipschitzWith]\n  simp only [edist_nndist]\n  norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Antilipschitz.lean", "context": {"open": ["Bornology Filter Set Topology", "scoped NNReal ENNReal Uniformity"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\n\u22a2 AntilipschitzWith K f \u2194 \u2200 (x y : \u03b1), nndist x y \u2264 K * nndist (f x) (f y)"}, {"line": "simp only [AntilipschitzWith]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (x y : \u03b1), edist x y \u2264 \u2191K * edist (f x) (f y)) \u2194 \u2200 (x y : \u03b1), nndist x y \u2264 K * nndist (f x) (f y)"}, {"line": "simp only [edist_nndist]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (x y : \u03b1), \u2191(nndist x y) \u2264 \u2191K * \u2191(nndist (f x) (f y))) \u2194 \u2200 (x y : \u03b1), nndist x y \u2264 K * nndist (f x) (f y)"}, {"line": "norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "theorem antilipschitzWith_iff_le_mul_dist :\n    AntilipschitzWith K f \u2194 \u2200 x y, dist x y \u2264 K * dist (f x) (f y) := by\n  simp only [antilipschitzWith_iff_le_mul_nndist]\n  simp only [dist_nndist]\n  norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Antilipschitz.lean", "context": {"open": ["Bornology Filter Set Topology", "scoped NNReal ENNReal Uniformity"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\n\u22a2 AntilipschitzWith K f \u2194 \u2200 (x y : \u03b1), dist x y \u2264 \u2191K * dist (f x) (f y)"}, {"line": "simp only [antilipschitzWith_iff_le_mul_nndist]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (x y : \u03b1), nndist x y \u2264 K * nndist (f x) (f y)) \u2194 \u2200 (x y : \u03b1), dist x y \u2264 \u2191K * dist (f x) (f y)"}, {"line": "simp only [dist_nndist]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (x y : \u03b1), nndist x y \u2264 K * nndist (f x) (f y)) \u2194 \u2200 (x y : \u03b1), \u2191(nndist x y) \u2264 \u2191K * \u2191(nndist (f x) (f y))"}, {"line": "norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_le_nndist (hf : AntilipschitzWith K f) (x y : \u03b1) :\n    K\u207b\u00b9 * nndist x y \u2264 nndist (f x) (f y) := by\n  simpa only [div_eq_inv_mul] using NNReal.div_le_of_le_mul' (hf.le_mul_nndist x y)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Antilipschitz.lean", "context": {"open": ["Bornology Filter Set Topology", "scoped NNReal ENNReal Uniformity"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\nhf : AntilipschitzWith K f\nx y : \u03b1\n\u22a2 K\u207b\u00b9 * nndist x y \u2264 nndist (f x) (f y)"}, {"line": "simpa only [div_eq_inv_mul] using NNReal.div_le_of_le_mul' (hf.le_mul_nndist x y)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_le_edist (hf : AntilipschitzWith K f) (x y : \u03b1) :\n    (K : \u211d\u22650\u221e)\u207b\u00b9 * edist x y \u2264 edist (f x) (f y) := by\n  rw [mul_comm]\n  rw [\u2190 div_eq_mul_inv]\n  exact ENNReal.div_le_of_le_mul' (hf x y)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Antilipschitz.lean", "context": {"open": ["Bornology Filter Set Topology", "scoped NNReal ENNReal Uniformity", "EMetric"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] [PseudoEMetricSpace \u03b3]", "{K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoMetricSpace \u03b2\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\nhf : AntilipschitzWith K f\nx y : \u03b1\n\u22a2 (\u2191K)\u207b\u00b9 * edist x y \u2264 edist (f x) (f y)"}, {"line": "rw [mul_comm]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoMetricSpace \u03b2\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\nhf : AntilipschitzWith K f\nx y : \u03b1\n\u22a2 edist x y * (\u2191K)\u207b\u00b9 \u2264 edist (f x) (f y)"}, {"line": "rw [\u2190 div_eq_mul_inv]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoMetricSpace \u03b2\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\nhf : AntilipschitzWith K f\nx y : \u03b1\n\u22a2 edist x y / \u2191K \u2264 edist (f x) (f y)"}, {"line": "exact ENNReal.div_le_of_le_mul' (hf x y)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem to_rightInverse (hf : AntilipschitzWith K f) {g : \u03b2 \u2192 \u03b1} (hg : Function.RightInverse g f) :\n    LipschitzWith K g := by\n  intro x y\n  have := hf (g x) (g y)\n  rwa [hg x, hg y] at this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Antilipschitz.lean", "context": {"open": ["Bornology Filter Set Topology", "scoped NNReal ENNReal Uniformity", "EMetric"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] [PseudoEMetricSpace \u03b3]", "{K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoMetricSpace \u03b2\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\nhf : AntilipschitzWith K f\ng : \u03b2 \u2192 \u03b1\nhg : Function.RightInverse g f\n\u22a2 LipschitzWith K g"}, {"line": "intro x y", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoMetricSpace \u03b2\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\nhf : AntilipschitzWith K f\ng : \u03b2 \u2192 \u03b1\nhg : Function.RightInverse g f\nx y : \u03b2\n\u22a2 edist (g x) (g y) \u2264 \u2191K * edist x y"}, {"line": "have := hf (g x) (g y)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoMetricSpace \u03b2\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\nhf : AntilipschitzWith K f\ng : \u03b2 \u2192 \u03b1\nhg : Function.RightInverse g f\nx y : \u03b2\nthis : edist (g x) (g y) \u2264 \u2191K * edist (f (g x)) (f (g y))\n\u22a2 edist (g x) (g y) \u2264 \u2191K * edist x y"}, {"line": "rwa [hg x, hg y] at this", "tactic_state": "No Goals!"}]}
{"declaration": "lemma congruent_iff_pairwise_edist_eq :\n    Congruent v\u2081 v\u2082 \u2194 Pairwise fun i\u2081 i\u2082 \u21a6 edist (v\u2081 i\u2081) (v\u2081 i\u2082) = edist (v\u2082 i\u2081) (v\u2082 i\u2082) := by\n  refine \u27e8fun h \u21a6 fun _ _ _ \u21a6 h _ _, fun h \u21a6 fun i\u2081 i\u2082 \u21a6 ?_\u27e9\n  by_cases hi : i\u2081 = i\u2082\n  \u00b7 simp [hi]\n  \u00b7 exact h hi\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Congruence.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b9' : Type*} {P\u2081 P\u2082 P\u2083 : Type*} {v\u2081 : \u03b9 \u2192 P\u2081} {v\u2082 : \u03b9 \u2192 P\u2082} {v\u2083 : \u03b9 \u2192 P\u2083}", "[PseudoEMetricSpace P\u2081] [PseudoEMetricSpace P\u2082] [PseudoEMetricSpace P\u2083]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nP\u2081 : Type u_3\nP\u2082 : Type u_4\nv\u2081 : \u03b9 \u2192 P\u2081\nv\u2082 : \u03b9 \u2192 P\u2082\ninst\u271d\u00b9 : PseudoEMetricSpace P\u2081\ninst\u271d : PseudoEMetricSpace P\u2082\n\u22a2 Congruent v\u2081 v\u2082 \u2194 Pairwise fun i\u2081 i\u2082 => edist (v\u2081 i\u2081) (v\u2081 i\u2082) = edist (v\u2082 i\u2081) (v\u2082 i\u2082)"}, {"line": "refine \u27e8fun h \u21a6 fun _ _ _ \u21a6 h _ _, fun h \u21a6 fun i\u2081 i\u2082 \u21a6 ?_\u27e9", "tactic_state": "\u03b9 : Type u_1\nP\u2081 : Type u_3\nP\u2082 : Type u_4\nv\u2081 : \u03b9 \u2192 P\u2081\nv\u2082 : \u03b9 \u2192 P\u2082\ninst\u271d\u00b9 : PseudoEMetricSpace P\u2081\ninst\u271d : PseudoEMetricSpace P\u2082\nh : Pairwise fun i\u2081 i\u2082 => edist (v\u2081 i\u2081) (v\u2081 i\u2082) = edist (v\u2082 i\u2081) (v\u2082 i\u2082)\ni\u2081 i\u2082 : \u03b9\n\u22a2 edist (v\u2081 i\u2081) (v\u2081 i\u2082) = edist (v\u2082 i\u2081) (v\u2082 i\u2082)"}, {"line": "by_cases hi : i\u2081 = i\u2082", "tactic_state": "case pos\n\u03b9 : Type u_1\nP\u2081 : Type u_3\nP\u2082 : Type u_4\nv\u2081 : \u03b9 \u2192 P\u2081\nv\u2082 : \u03b9 \u2192 P\u2082\ninst\u271d\u00b9 : PseudoEMetricSpace P\u2081\ninst\u271d : PseudoEMetricSpace P\u2082\nh : Pairwise fun i\u2081 i\u2082 => edist (v\u2081 i\u2081) (v\u2081 i\u2082) = edist (v\u2082 i\u2081) (v\u2082 i\u2082)\ni\u2081 i\u2082 : \u03b9\nhi : i\u2081 = i\u2082\n\u22a2 edist (v\u2081 i\u2081) (v\u2081 i\u2082) = edist (v\u2082 i\u2081) (v\u2082 i\u2082)\n---\ncase neg\n\u03b9 : Type u_1\nP\u2081 : Type u_3\nP\u2082 : Type u_4\nv\u2081 : \u03b9 \u2192 P\u2081\nv\u2082 : \u03b9 \u2192 P\u2082\ninst\u271d\u00b9 : PseudoEMetricSpace P\u2081\ninst\u271d : PseudoEMetricSpace P\u2082\nh : Pairwise fun i\u2081 i\u2082 => edist (v\u2081 i\u2081) (v\u2081 i\u2082) = edist (v\u2082 i\u2081) (v\u2082 i\u2082)\ni\u2081 i\u2082 : \u03b9\nhi : \u00aci\u2081 = i\u2082\n\u22a2 edist (v\u2081 i\u2081) (v\u2081 i\u2082) = edist (v\u2082 i\u2081) (v\u2082 i\u2082)"}, {"line": "\u00b7 simp [hi]", "tactic_state": "case neg\n\u03b9 : Type u_1\nP\u2081 : Type u_3\nP\u2082 : Type u_4\nv\u2081 : \u03b9 \u2192 P\u2081\nv\u2082 : \u03b9 \u2192 P\u2082\ninst\u271d\u00b9 : PseudoEMetricSpace P\u2081\ninst\u271d : PseudoEMetricSpace P\u2082\nh : Pairwise fun i\u2081 i\u2082 => edist (v\u2081 i\u2081) (v\u2081 i\u2082) = edist (v\u2082 i\u2081) (v\u2082 i\u2082)\ni\u2081 i\u2082 : \u03b9\nhi : \u00aci\u2081 = i\u2082\n\u22a2 edist (v\u2081 i\u2081) (v\u2081 i\u2082) = edist (v\u2082 i\u2081) (v\u2082 i\u2082)"}, {"line": "\u00b7 exact h hi", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_sub_K_pos' (hf : ContractingWith K f) : (0 : \u211d\u22650\u221e) < 1 - K := by simp [hf.1]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Contracting.lean", "context": {"open": ["NNReal Topology ENNReal Filter Function", "EMetric Set"], "variables": ["{\u03b1 : Type*}", "[EMetricSpace \u03b1] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : EMetricSpace \u03b1\nK : NNReal\nf : \u03b1 \u2192 \u03b1\nhf : ContractingWith K f\n\u22a2 0 < 1 - \u2191K"}, {"line": "simp [hf.1]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_sub_K_ne_top : (1 : \u211d\u22650\u221e) - K \u2260 \u221e := by\n  norm_cast\n  exact ENNReal.coe_ne_top\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Contracting.lean", "context": {"open": ["NNReal Topology ENNReal Filter Function", "EMetric Set"], "variables": ["{\u03b1 : Type*}", "[EMetricSpace \u03b1] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : NNReal\n\u22a2 1 - \u2191K \u2260 \u22a4"}, {"line": "norm_cast", "tactic_state": "K : NNReal\n\u22a2 \u00ac\u2191(1 - K) = \u22a4"}, {"line": "exact ENNReal.coe_ne_top", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_le_of_fixedPoint (hf : ContractingWith K f) {x y} (h : edist x y \u2260 \u221e)\n    (hy : IsFixedPt f y) : edist x y \u2264 edist x (f x) / (1 - K) := by\n  simpa only [hy.eq,edist_self,add_zero] using hf.edist_inequality h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Contracting.lean", "context": {"open": ["NNReal Topology ENNReal Filter Function", "EMetric Set"], "variables": ["{\u03b1 : Type*}", "[EMetricSpace \u03b1] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : EMetricSpace \u03b1\nK : NNReal\nf : \u03b1 \u2192 \u03b1\nhf : ContractingWith K f\nx y : \u03b1\nh : edist x y \u2260 \u22a4\nhy : IsFixedPt f y\n\u22a2 edist x y \u2264 edist x (f x) / (1 - \u2191K)"}, {"line": "simpa only [hy.eq,edist_self,add_zero] using hf.edist_inequality h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_or_edist_eq_top_of_fixedPoints (hf : ContractingWith K f) {x y} (hx : IsFixedPt f x)\n    (hy : IsFixedPt f y) : x = y \u2228 edist x y = \u221e := by\n  refine or_iff_not_imp_right.2 fun h \u21a6 edist_le_zero.1 ?_\n  simpa only [hx.eq,edist_self,add_zero,ENNReal.zero_div] using hf.edist_le_of_fixedPoint h hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Contracting.lean", "context": {"open": ["NNReal Topology ENNReal Filter Function", "EMetric Set"], "variables": ["{\u03b1 : Type*}", "[EMetricSpace \u03b1] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : EMetricSpace \u03b1\nK : NNReal\nf : \u03b1 \u2192 \u03b1\nhf : ContractingWith K f\nx y : \u03b1\nhx : IsFixedPt f x\nhy : IsFixedPt f y\n\u22a2 x = y \u2228 edist x y = \u22a4"}, {"line": "refine or_iff_not_imp_right.2 fun h \u21a6 edist_le_zero.1 ?_", "tactic_state": "case refine_1\n\u03b1 : Type u_1\ninst\u271d : EMetricSpace \u03b1\nK : NNReal\nf : \u03b1 \u2192 \u03b1\nhf : ContractingWith K f\nx y : \u03b1\nhx : IsFixedPt f x\nhy : IsFixedPt f y\nh : \u00acedist x y = \u22a4\n\u22a2 edist x y \u2264 0\n---\ncase refine_2\n\u03b1 : Type u_1\ninst\u271d : EMetricSpace \u03b1\nK : NNReal\nf : \u03b1 \u2192 \u03b1\nhf : ContractingWith K f\nx y : \u03b1\nhx : IsFixedPt f x\nhy : IsFixedPt f y\n\u22a2 \u00acedist x y = \u22a4 \u2192 EMetricSpace \u03b1"}, {"line": "simpa only [hx.eq,edist_self,add_zero,ENNReal.zero_div] using hf.edist_le_of_fixedPoint h hy", "tactic_state": "case refine_2\n\u03b1 : Type u_1\ninst\u271d : EMetricSpace \u03b1\nK : NNReal\nf : \u03b1 \u2192 \u03b1\nhf : ContractingWith K f\nx y : \u03b1\nhx : IsFixedPt f x\nhy : IsFixedPt f y\n\u22a2 \u00acedist x y = \u22a4 \u2192 EMetricSpace \u03b1"}]}
{"declaration": "theorem dist_le_of_fixedPoint (x) {y} (hy : IsFixedPt f y) : dist x y \u2264 dist x (f x) / (1 - K) := by\n  simpa only [hy.eq,dist_self,add_zero] using hf.dist_inequality x y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Contracting.lean", "context": {"open": ["NNReal Topology ENNReal Filter Function", "EMetric Set"], "variables": ["{\u03b1 : Type*}", "[EMetricSpace \u03b1] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b1}", "[CompleteSpace \u03b1]", "(f) in", "(f) in", "[MetricSpace \u03b1] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b1}", "(hf : ContractingWith K f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : EMetricSpace \u03b1\nK : NNReal\nf : \u03b1 \u2192 \u03b1\ninst\u271d : CompleteSpace \u03b1\nx y : \u03b1\nhy : IsFixedPt f y\n\u22a2 sorry \u2264 sorry / (1 - K)"}, {"line": "simpa only [hy.eq,dist_self,add_zero] using hf.dist_inequality x y", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_eq_dist {x y : \u03b3} : 0 = dist x y \u2194 x = y := by rw [eq_comm, dist_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Defs.lean", "context": {"open": ["Set Filter Bornology", "scoped NNReal Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{\u03b3 : Type w} [MetricSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b3 : Type w\ninst\u271d : MetricSpace \u03b3\nx y : \u03b3\n\u22a2 0 = dist x y \u2194 x = y"}, {"line": "rw [eq_comm, dist_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_ne_zero {x y : \u03b3} : dist x y \u2260 0 \u2194 x \u2260 y := by\n  simpa only [not_iff_not] using dist_eq_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Defs.lean", "context": {"open": ["Set Filter Bornology", "scoped NNReal Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{\u03b3 : Type w} [MetricSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b3 : Type w\ninst\u271d : MetricSpace \u03b3\nx y : \u03b3\n\u22a2 dist x y \u2260 0 \u2194 x \u2260 y"}, {"line": "simpa only [not_iff_not] using dist_eq_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_le_zero {x y : \u03b3} : dist x y \u2264 0 \u2194 x = y := by\n  simpa [le_antisymm_iff, dist_nonneg] using @dist_eq_zero _ _ x y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Defs.lean", "context": {"open": ["Set Filter Bornology", "scoped NNReal Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{\u03b3 : Type w} [MetricSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b3 : Type w\ninst\u271d : MetricSpace \u03b3\nx y : \u03b3\n\u22a2 dist x y \u2264 0 \u2194 x = y"}, {"line": "simpa [le_antisymm_iff, dist_nonneg] using @dist_eq_zero _ _ x y", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_pos {x y : \u03b3} : 0 < dist x y \u2194 x \u2260 y := by\n  simpa only [not_le] using not_congr dist_le_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Defs.lean", "context": {"open": ["Set Filter Bornology", "scoped NNReal Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{\u03b3 : Type w} [MetricSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b3 : Type w\ninst\u271d : MetricSpace \u03b3\nx y : \u03b3\n\u22a2 0 < dist x y \u2194 x \u2260 y"}, {"line": "simpa only [not_le] using not_congr dist_le_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MetricSpace.replaceBornology_eq {\u03b1} [m : MetricSpace \u03b1] [B : Bornology \u03b1]\n    (H : \u2200 s, @IsBounded _ B s \u2194 @IsBounded _ PseudoMetricSpace.toBornology s) :\n    MetricSpace.replaceBornology _ H = m := by\n  ext\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Defs.lean", "context": {"open": ["Set Filter Bornology", "scoped NNReal Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{\u03b3 : Type w} [MetricSpace \u03b3]", "{x : \u03b3} {s : Set \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nm : MetricSpace \u03b1\nB : Bornology \u03b1\nH : \u2200 (s : Set \u03b1), Bornology.IsBounded s \u2194 Bornology.IsBounded s\n\u22a2 m.replaceBornology H = m"}, {"line": "ext", "tactic_state": "case h.dist.h.h\n\u03b1 : Type u_3\nm : MetricSpace \u03b1\nB : Bornology \u03b1\nH : \u2200 (s : Set \u03b1), Bornology.IsBounded s \u2194 Bornology.IsBounded s\nx\u271d\u00b9 x\u271d : \u03b1\n\u22a2 dist x\u271d\u00b9 x\u271d = dist x\u271d\u00b9 x\u271d"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ratio_unique [DilationClass F \u03b1 \u03b2] {f : F} {x y : \u03b1} {r : \u211d\u22650} (h\u2080 : edist x y \u2260 0)\n    (htop : edist x y \u2260 \u22a4) (hr : edist (f x) (f y) = r * edist x y) : r = ratio f := by\n  simpa only [hr,ENNReal.mul_left_inj h\u2080 htop,ENNReal.coe_inj] using edist_eq f x y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Dilation.lean", "context": {"open": ["Bornology Function Set Topology", "scoped ENNReal NNReal", "Classical in"], "variables": ["(\u03b1 : Type*) (\u03b2 : Type*) [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {F : Type*}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "[FunLike F \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nF : Type u_4\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\nx\u271d : Sort u_5\nratio : x\u271d\ninst\u271d : DilationClass F \u03b1 \u03b2\nf : F\nx y : \u03b1\nr : NNReal\nh\u2080 : edist x y \u2260 0\nhtop : edist x y \u2260 \u22a4\nhr : edist (f x) (f y) = \u2191r * edist x y\n\u22a2 r = sorry"}, {"line": "simpa only [hr,ENNReal.mul_left_inj h\u2080 htop,ENNReal.coe_inj] using edist_eq f x y", "tactic_state": "No Goals!"}]}
{"declaration": "theorem diam_image (s : Set \u03b1) : Metric.diam ((f : \u03b1 \u2192 \u03b2) '' s) = ratio f * Metric.diam s := by\n  simp [Metric.diam, ediam_image, ENNReal.toReal_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Dilation.lean", "context": {"open": ["Bornology Function Set Topology", "scoped ENNReal NNReal", "Classical in"], "variables": ["(\u03b1 : Type*) (\u03b2 : Type*) [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {F : Type*}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "[FunLike F \u03b1 \u03b2]", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] [PseudoEMetricSpace \u03b3]", "[FunLike F \u03b1 \u03b2] [DilationClass F \u03b1 \u03b2]", "(f : F)", "[EMetricSpace \u03b1]", "[FunLike F \u03b1 \u03b2]", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] [FunLike F \u03b1 \u03b2] [DilationClass F \u03b1 \u03b2] (f : F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nF : Type u_4\ninst\u271d\u00b9\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u00b9 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u2070 : FunLike F \u03b1 \u03b2\ninst\u271d\u2079 : PseudoEMetricSpace \u03b1\ninst\u271d\u2078 : PseudoEMetricSpace \u03b2\ninst\u271d\u2077 : FunLike F \u03b1 \u03b2\ninst\u271d\u2076 : DilationClass F \u03b1 \u03b2\ninst\u271d\u2075 : EMetricSpace \u03b1\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoMetricSpace \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : DilationClass F \u03b1 \u03b2\nf : F\nx\u271d : Sort u_5\nratio : x\u271d\ns : Set \u03b1\n\u22a2 Metric.diam (\u21d1f '' s) = sorry * Metric.diam s"}, {"line": "simp [Metric.diam, ediam_image, ENNReal.toReal_mul]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nF : Type u_4\ninst\u271d\u00b9\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u00b9 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u2070 : FunLike F \u03b1 \u03b2\ninst\u271d\u2079 : PseudoEMetricSpace \u03b1\ninst\u271d\u2078 : PseudoEMetricSpace \u03b2\ninst\u271d\u2077 : FunLike F \u03b1 \u03b2\ninst\u271d\u2076 : DilationClass F \u03b1 \u03b2\ninst\u271d\u2075 : EMetricSpace \u03b1\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoMetricSpace \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : DilationClass F \u03b1 \u03b2\nf : F\nx\u271d : Sort u_5\nratio : x\u271d\ns : Set \u03b1\n\u22a2 (EMetric.diam (\u21d1f '' s)).toReal = sorry () * (EMetric.diam s).toReal"}]}
{"declaration": "theorem equicontinuousAt_of_continuity_modulus {\u03b9 : Type*} [TopologicalSpace \u03b2] {x\u2080 : \u03b2}\n    (b : \u03b2 \u2192 \u211d) (b_lim : Tendsto b (\ud835\udcdd x\u2080) (\ud835\udcdd 0)) (F : \u03b9 \u2192 \u03b2 \u2192 \u03b1)\n    (H : \u2200\u1da0 x in \ud835\udcdd x\u2080, \u2200 i, dist (F i x\u2080) (F i x) \u2264 b x) : EquicontinuousAt F x\u2080 := by\n  rw [Metric.equicontinuousAt_iff_right]\n  intro \u03b5 \u03b50\n  -- Porting note: Lean 3 didn't need `Filter.mem_map.mp` here\n  filter_upwards [Filter.mem_map.mp <| b_lim (Iio_mem_nhds \u03b50), H] using\n    fun x hx\u2081 hx\u2082 i => (hx\u2082 i).trans_lt hx\u2081\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Equicontinuity.lean", "context": {"open": ["Filter Topology Uniformity"], "variables": ["{\u03b1 \u03b2 \u03b9 : Type*} [PseudoMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\n\u03b9 : Type u_4\ninst\u271d : TopologicalSpace \u03b2\nx\u2080 : \u03b2\nb : \u03b2 \u2192 \u211d\nb_lim : Tendsto b (nhds x\u2080) (nhds 0)\nF : \u03b9 \u2192 \u03b2 \u2192 \u03b1\nH : \u2200\u1da0 (x : \u03b2) in nhds x\u2080, \u2200 (i : \u03b9), dist (F i x\u2080) (F i x) \u2264 b x\n\u22a2 EquicontinuousAt F x\u2080"}, {"line": "rw [Metric.equicontinuousAt_iff_right]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\n\u03b9 : Type u_4\ninst\u271d : TopologicalSpace \u03b2\nx\u2080 : \u03b2\nb : \u03b2 \u2192 \u211d\nb_lim : Tendsto b (nhds x\u2080) (nhds 0)\nF : \u03b9 \u2192 \u03b2 \u2192 \u03b1\nH : \u2200\u1da0 (x : \u03b2) in nhds x\u2080, \u2200 (i : \u03b9), dist (F i x\u2080) (F i x) \u2264 b x\n\u22a2 \u2200 \u03b5 > 0, \u2200\u1da0 (x : \u03b2) in nhds x\u2080, \u2200 (i : \u03b9), dist (F i x\u2080) (F i x) < \u03b5"}, {"line": "intro \u03b5 \u03b50", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\n\u03b9 : Type u_4\ninst\u271d : TopologicalSpace \u03b2\nx\u2080 : \u03b2\nb : \u03b2 \u2192 \u211d\nb_lim : Tendsto b (nhds x\u2080) (nhds 0)\nF : \u03b9 \u2192 \u03b2 \u2192 \u03b1\nH : \u2200\u1da0 (x : \u03b2) in nhds x\u2080, \u2200 (i : \u03b9), dist (F i x\u2080) (F i x) \u2264 b x\n\u03b5 : \u211d\n\u03b50 : \u03b5 > 0\n\u22a2 \u2200\u1da0 (x : \u03b2) in nhds x\u2080, \u2200 (i : \u03b9), dist (F i x\u2080) (F i x) < \u03b5"}, {"line": "filter_upwards [Filter.mem_map.mp <| b_lim (Iio_mem_nhds \u03b50), H] using\n    fun x hx\u2081 hx\u2082 i => (hx\u2082 i).trans_lt hx\u2081", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem candidates_nonneg (fA : f \u2208 candidates X Y) : 0 \u2264 f (x, y) := by\n  have : 0 \u2264 2 * f (x, y) :=\n    calc\n      0 = f (x, x) := (candidates_refl fA).symm\n      _ \u2264 f (x, y) + f (y, x) := candidates_triangle fA\n      _ = f (x, y) + f (x, y) := by rw [candidates_symm fA]\n      _ = 2 * f (x, y) := by ring\n  linarith\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/GromovHausdorffRealized.lean", "context": {"open": ["Topology NNReal Set Function TopologicalSpace Filter Metric Quotient BoundedContinuousFunction", "Sum (inl inr)"], "variables": ["(X : Type u) (Y : Type v) [MetricSpace X] [MetricSpace Y]", "{X : Type u} {Y : Type v} [MetricSpace X] [MetricSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncandidates : x\u271d\n\u03b1\u271d : Type u_2\nf : \u03b1\u271d\nfA : f \u2208 sorry\n\u22a2 0 \u2264 sorry"}, {"line": "have : 0 \u2264 2 * f (x, y) :=\n    calc\n      0 = f (x, x) := (candidates_refl fA).symm\n      _ \u2264 f (x, y) + f (y, x) := candidates_triangle fA\n      _ = f (x, y) + f (x, y) := by rw [candidates_symm fA]\n      _ = 2 * f (x, y) := by ring", "tactic_state": "x\u271d : Sort u_1\ncandidates : x\u271d\n\u03b1\u271d : Type u_2\nf : \u03b1\u271d\nfA : f \u2208 sorry\nthis : 0 \u2264 2 * sorry\n\u22a2 0 \u2264 sorry"}, {"line": "linarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem einfsep_iUnion_mem_option {\u03b9 : Type*} (o : Option \u03b9) (s : \u03b9 \u2192 Set \u03b1) :\n    (\u22c3 i \u2208 o, s i).einfsep = \u2a05 i \u2208 o, (s i).einfsep := by cases o <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Infsep.lean", "context": {"open": ["ENNReal", "Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "[EDist \u03b1] {x y : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : EDist \u03b1\n\u03b9 : Type u_3\no : Option \u03b9\ns : \u03b9 \u2192 Set \u03b1\n\u22a2 (\u22c3 i \u2208 o, s i).einfsep = \u2a05 i \u2208 o, (s i).einfsep"}, {"line": "cases o <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem einfsep_insert_le : (insert x s).einfsep \u2264 \u2a05 (y \u2208 s) (_ : x \u2260 y), edist x y := by\n  simp_rw [le_iInf_iff]\n  exact fun _ hy hxy => einfsep_le_edist_of_mem (mem_insert _ _) (mem_insert_of_mem _ hy) hxy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Infsep.lean", "context": {"open": ["ENNReal", "Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "[EDist \u03b1] {x y : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : EDist \u03b1\nx : \u03b1\ns : Set \u03b1\n\u22a2 (insert x s).einfsep \u2264 \u2a05 y \u2208 s, \u2a05 (_ : x \u2260 y), edist x y"}, {"line": "simp_rw [le_iInf_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : EDist \u03b1\nx : \u03b1\ns : Set \u03b1\n\u22a2 \u2200 i \u2208 s, x \u2260 i \u2192 (insert x s).einfsep \u2264 edist x i"}, {"line": "exact fun _ hy hxy => einfsep_le_edist_of_mem (mem_insert _ _) (mem_insert_of_mem _ hy) hxy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem infsep_zero : s.infsep = 0 \u2194 s.einfsep = 0 \u2228 s.einfsep = \u221e := by\n  rw [infsep]\n  rw [ENNReal.toReal_eq_zero_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Infsep.lean", "context": {"open": ["ENNReal", "Function", "ENNReal", "Set Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "[EDist \u03b1] {x y : \u03b1} {s t : Set \u03b1}", "[PseudoEMetricSpace \u03b1] {x y z : \u03b1} {s : Set \u03b1}", "[PseudoMetricSpace \u03b1] {s : Set \u03b1}", "[EMetricSpace \u03b1] {s : Set \u03b1}", "[EDist \u03b1] {x y : \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : EDist \u03b1\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : EMetricSpace \u03b1\ninst\u271d : EDist \u03b1\ns : Set \u03b1\n\u22a2 s.infsep = 0 \u2194 s.einfsep = 0 \u2228 s.einfsep = \u22a4"}, {"line": "rw [infsep]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : EDist \u03b1\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : EMetricSpace \u03b1\ninst\u271d : EDist \u03b1\ns : Set \u03b1\n\u22a2 s.einfsep.toReal = 0 \u2194 s.einfsep = 0 \u2228 s.einfsep = \u22a4"}, {"line": "rw [ENNReal.toReal_eq_zero_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem infsep_pos : 0 < s.infsep \u2194 0 < s.einfsep \u2227 s.einfsep < \u221e := by\n  simp_rw [infsep, ENNReal.toReal_pos_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Infsep.lean", "context": {"open": ["ENNReal", "Function", "ENNReal", "Set Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "[EDist \u03b1] {x y : \u03b1} {s t : Set \u03b1}", "[PseudoEMetricSpace \u03b1] {x y z : \u03b1} {s : Set \u03b1}", "[PseudoMetricSpace \u03b1] {s : Set \u03b1}", "[EMetricSpace \u03b1] {s : Set \u03b1}", "[EDist \u03b1] {x y : \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : EDist \u03b1\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : EMetricSpace \u03b1\ninst\u271d : EDist \u03b1\ns : Set \u03b1\n\u22a2 0 < s.infsep \u2194 0 < s.einfsep \u2227 s.einfsep < \u22a4"}, {"line": "simp_rw [infsep, ENNReal.toReal_pos_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nontrivial_of_infsep_pos (hs : 0 < s.infsep) : s.Nontrivial := by\n  contrapose hs\n  rw [not_nontrivial_iff] at hs\n  exact hs.infsep_zero \u25b8 lt_irrefl _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Infsep.lean", "context": {"open": ["ENNReal", "Function", "ENNReal", "Set Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "[EDist \u03b1] {x y : \u03b1} {s t : Set \u03b1}", "[PseudoEMetricSpace \u03b1] {x y z : \u03b1} {s : Set \u03b1}", "[PseudoMetricSpace \u03b1] {s : Set \u03b1}", "[EMetricSpace \u03b1] {s : Set \u03b1}", "[EDist \u03b1] {x y : \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : EDist \u03b1\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : EMetricSpace \u03b1\ninst\u271d : EDist \u03b1\ns : Set \u03b1\nhs : 0 < s.infsep\n\u22a2 s.Nontrivial"}, {"line": "contrapose hs", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : EDist \u03b1\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : EMetricSpace \u03b1\ninst\u271d : EDist \u03b1\ns : Set \u03b1\nhs : \u00acs.Nontrivial\n\u22a2 \u00ac0 < s.infsep"}, {"line": "rw [not_nontrivial_iff] at hs", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : EDist \u03b1\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : EMetricSpace \u03b1\ninst\u271d : EDist \u03b1\ns : Set \u03b1\nhs : s.Subsingleton\n\u22a2 \u00ac0 < s.infsep"}, {"line": "exact hs.infsep_zero \u25b8 lt_irrefl _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Finset.coe_infsep [DecidableEq \u03b1] (s : Finset \u03b1) : (s : Set \u03b1).infsep =\n    if hs : s.offDiag.Nonempty then s.offDiag.inf' hs (uncurry dist) else 0 := by\n  have H : (s : Set \u03b1).Nontrivial \u2194 s.offDiag.Nonempty := by\n    rw [\u2190 Set.offDiag_nonempty]\n    rw [\u2190 Finset.coe_offDiag]\n    rw [Finset.coe_nonempty]\n  split_ifs with hs\n  \u00b7 simp_rw [(H.mpr hs).infsep_of_fintype, \u2190 Finset.coe_offDiag, Finset.toFinset_coe]\n  \u00b7 exact (not_nontrivial_iff.mp (H.mp.mt hs)).infsep_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Infsep.lean", "context": {"open": ["ENNReal", "Function", "ENNReal", "Set Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "[EDist \u03b1] {x y : \u03b1} {s t : Set \u03b1}", "[PseudoEMetricSpace \u03b1] {x y z : \u03b1} {s : Set \u03b1}", "[PseudoMetricSpace \u03b1] {s : Set \u03b1}", "[EMetricSpace \u03b1] {s : Set \u03b1}", "[EDist \u03b1] {x y : \u03b1} {s : Set \u03b1}", "[PseudoEMetricSpace \u03b1] {x y : \u03b1}", "[PseudoMetricSpace \u03b1] {x y z : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : EDist \u03b1\ninst\u271d\u2076 : PseudoEMetricSpace \u03b1\ninst\u271d\u2075 : PseudoMetricSpace \u03b1\ninst\u271d\u2074 : EMetricSpace \u03b1\ninst\u271d\u00b3 : EDist \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 (\u2191s).infsep = if hs : s.offDiag.Nonempty then s.offDiag.inf' hs (uncurry dist) else 0"}, {"line": "have H : (s : Set \u03b1).Nontrivial \u2194 s.offDiag.Nonempty := sorry", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : EDist \u03b1\ninst\u271d\u2076 : PseudoEMetricSpace \u03b1\ninst\u271d\u2075 : PseudoMetricSpace \u03b1\ninst\u271d\u2074 : EMetricSpace \u03b1\ninst\u271d\u00b3 : EDist \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nH : (\u2191s).Nontrivial \u2194 sorry\n\u22a2 (\u2191s).infsep = if hs : s.offDiag.Nonempty then s.offDiag.inf' hs (uncurry dist) else 0"}, {"line": "split_ifs with hs", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d\u2077 : EDist \u03b1\ninst\u271d\u2076 : PseudoEMetricSpace \u03b1\ninst\u271d\u2075 : PseudoMetricSpace \u03b1\ninst\u271d\u2074 : EMetricSpace \u03b1\ninst\u271d\u00b3 : EDist \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nH : (\u2191s).Nontrivial \u2194 sorry\nhs : s.offDiag.Nonempty\n\u22a2 (\u2191s).infsep = s.offDiag.inf' hs (uncurry dist)\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d\u2077 : EDist \u03b1\ninst\u271d\u2076 : PseudoEMetricSpace \u03b1\ninst\u271d\u2075 : PseudoMetricSpace \u03b1\ninst\u271d\u2074 : EMetricSpace \u03b1\ninst\u271d\u00b3 : EDist \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nH : (\u2191s).Nontrivial \u2194 sorry\nhs : \u00acs.offDiag.Nonempty\n\u22a2 (\u2191s).infsep = 0"}, {"line": "\u00b7 simp_rw [(H.mpr hs).infsep_of_fintype, \u2190 Finset.coe_offDiag, Finset.toFinset_coe]", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d\u2077 : EDist \u03b1\ninst\u271d\u2076 : PseudoEMetricSpace \u03b1\ninst\u271d\u2075 : PseudoMetricSpace \u03b1\ninst\u271d\u2074 : EMetricSpace \u03b1\ninst\u271d\u00b3 : EDist \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nH : (\u2191s).Nontrivial \u2194 sorry\nhs : \u00acs.offDiag.Nonempty\n\u22a2 (\u2191s).infsep = 0"}, {"line": "\u00b7 exact (not_nontrivial_iff.mp (H.mp.mt hs)).infsep_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_div_left [PseudoEMetricSpace G] [IsIsometricSMul G G] [IsIsometricSMul G\u1d50\u1d52\u1d56 G]\n    (a b c : G) : edist (a / b) (a / c) = edist b c := by\n  rw [div_eq_mul_inv]\n  rw [div_eq_mul_inv]\n  rw [edist_mul_left]\n  rw [edist_inv_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/IsometricSMul.lean", "context": {"open": ["Set", "ENNReal Pointwise"], "variables": ["(M : Type u) (G : Type v) (X : Type w)", "{M G X}", "[PseudoEMetricSpace X] [Group G] [MulAction G X] [IsIsometricSMul G X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type v\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : PseudoEMetricSpace G\ninst\u271d\u00b9 : IsIsometricSMul G G\ninst\u271d : IsIsometricSMul G\u1d50\u1d52\u1d56 G\na b c : G\n\u22a2 edist (a / b) (a / c) = edist b c"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "G : Type v\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : PseudoEMetricSpace G\ninst\u271d\u00b9 : IsIsometricSMul G G\ninst\u271d : IsIsometricSMul G\u1d50\u1d52\u1d56 G\na b c : G\n\u22a2 edist (a * b\u207b\u00b9) (a / c) = edist b c"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "G : Type v\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : PseudoEMetricSpace G\ninst\u271d\u00b9 : IsIsometricSMul G G\ninst\u271d : IsIsometricSMul G\u1d50\u1d52\u1d56 G\na b c : G\n\u22a2 edist (a * b\u207b\u00b9) (a * c\u207b\u00b9) = edist b c"}, {"line": "rw [edist_mul_left]", "tactic_state": "G : Type v\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : PseudoEMetricSpace G\ninst\u271d\u00b9 : IsIsometricSMul G G\ninst\u271d : IsIsometricSMul G\u1d50\u1d52\u1d56 G\na b c : G\n\u22a2 edist b\u207b\u00b9 c\u207b\u00b9 = edist b c\n---\nG : Type v\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : PseudoEMetricSpace G\ninst\u271d\u00b9 : IsIsometricSMul G G\ninst\u271d : IsIsometricSMul G\u1d50\u1d52\u1d56 G\na b c : G\n\u22a2 IsIsometricSMul G G"}, {"line": "rw [edist_inv_inv]", "tactic_state": "G : Type v\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : PseudoEMetricSpace G\ninst\u271d\u00b9 : IsIsometricSMul G G\ninst\u271d : IsIsometricSMul G\u1d50\u1d52\u1d56 G\na b c : G\n\u22a2 IsIsometricSMul G G\n---\nG : Type v\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : PseudoEMetricSpace G\ninst\u271d\u00b9 : IsIsometricSMul G G\ninst\u271d : IsIsometricSMul G\u1d50\u1d52\u1d56 G\na b c : G\n\u22a2 IsIsometricSMul G\u1d50\u1d52\u1d56 G\n---\nG : Type v\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : PseudoEMetricSpace G\ninst\u271d\u00b9 : IsIsometricSMul G G\ninst\u271d : IsIsometricSMul G\u1d50\u1d52\u1d56 G\na b c : G\n\u22a2 IsIsometricSMul G G"}]}
{"declaration": "theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsIsometricSMul M\u1d50\u1d52\u1d56 M]\n    (a b c : M) : dist (a / c) (b / c) = dist a b := by simp only [div_eq_mul_inv, dist_mul_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/IsometricSMul.lean", "context": {"open": ["Set", "ENNReal Pointwise"], "variables": ["(M : Type u) (G : Type v) (X : Type w)", "{M G X}", "[PseudoEMetricSpace X] [Group G] [MulAction G X] [IsIsometricSMul G X]", "[PseudoEMetricSpace G]", "[IsIsometricSMul G G] [IsIsometricSMul G\u1d50\u1d52\u1d56 G]", "(G)", "[PseudoEMetricSpace G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b2 : DivInvMonoid M\ninst\u271d\u00b9 : PseudoMetricSpace M\ninst\u271d : IsIsometricSMul M\u1d50\u1d52\u1d56 M\na b c : M\n\u22a2 dist (a / c) (b / c) = dist a b"}, {"line": "simp only [div_eq_mul_inv, dist_mul_right]", "tactic_state": "M : Type u\ninst\u271d\u00b2 : DivInvMonoid M\ninst\u271d\u00b9 : PseudoMetricSpace M\ninst\u271d : IsIsometricSMul M\u1d50\u1d52\u1d56 M\na b c : M\n\u22a2 dist (a * c\u207b\u00b9) (b * c\u207b\u00b9) = dist a b"}]}
{"declaration": "theorem dist_div_left [Group G] [PseudoMetricSpace G] [IsIsometricSMul G G]\n    [IsIsometricSMul G\u1d50\u1d52\u1d56 G] (a b c : G) : dist (a / b) (a / c) = dist b c := by\n  simp [div_eq_mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/IsometricSMul.lean", "context": {"open": ["Set", "ENNReal Pointwise"], "variables": ["(M : Type u) (G : Type v) (X : Type w)", "{M G X}", "[PseudoEMetricSpace X] [Group G] [MulAction G X] [IsIsometricSMul G X]", "[PseudoEMetricSpace G]", "[IsIsometricSMul G G] [IsIsometricSMul G\u1d50\u1d52\u1d56 G]", "(G)", "[PseudoEMetricSpace G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type v\ninst\u271d\u2078 : Group G\ninst\u271d\u2077 : PseudoEMetricSpace G\ninst\u271d\u2076 : IsIsometricSMul G G\ninst\u271d\u2075 : IsIsometricSMul G\u1d50\u1d52\u1d56 G\ninst\u271d\u2074 : PseudoEMetricSpace G\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : PseudoMetricSpace G\ninst\u271d\u00b9 : IsIsometricSMul G G\ninst\u271d : IsIsometricSMul G\u1d50\u1d52\u1d56 G\na b c : G\n\u22a2 dist (a / b) (a / c) = dist b c"}, {"line": "simp [div_eq_mul_inv]", "tactic_state": "G : Type v\ninst\u271d\u2078 : Group G\ninst\u271d\u2077 : PseudoEMetricSpace G\ninst\u271d\u2076 : IsIsometricSMul G G\ninst\u271d\u2075 : IsIsometricSMul G\u1d50\u1d52\u1d56 G\ninst\u271d\u2074 : PseudoEMetricSpace G\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : PseudoMetricSpace G\ninst\u271d\u00b9 : IsIsometricSMul G G\ninst\u271d : IsIsometricSMul G\u1d50\u1d52\u1d56 G\na b c : G\n\u22a2 dist (a * b\u207b\u00b9) (a * c\u207b\u00b9) = dist b c"}]}
{"declaration": "theorem nndist_div_left [Group G] [PseudoMetricSpace G] [IsIsometricSMul G G]\n    [IsIsometricSMul G\u1d50\u1d52\u1d56 G] (a b c : G) : nndist (a / b) (a / c) = nndist b c := by\n  simp [div_eq_mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/IsometricSMul.lean", "context": {"open": ["Set", "ENNReal Pointwise"], "variables": ["(M : Type u) (G : Type v) (X : Type w)", "{M G X}", "[PseudoEMetricSpace X] [Group G] [MulAction G X] [IsIsometricSMul G X]", "[PseudoEMetricSpace G]", "[IsIsometricSMul G G] [IsIsometricSMul G\u1d50\u1d52\u1d56 G]", "(G)", "[PseudoEMetricSpace G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type v\ninst\u271d\u2078 : Group G\ninst\u271d\u2077 : PseudoEMetricSpace G\ninst\u271d\u2076 : IsIsometricSMul G G\ninst\u271d\u2075 : IsIsometricSMul G\u1d50\u1d52\u1d56 G\ninst\u271d\u2074 : PseudoEMetricSpace G\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : PseudoMetricSpace G\ninst\u271d\u00b9 : IsIsometricSMul G G\ninst\u271d : IsIsometricSMul G\u1d50\u1d52\u1d56 G\na b c : G\n\u22a2 nndist (a / b) (a / c) = nndist b c"}, {"line": "simp [div_eq_mul_inv]", "tactic_state": "G : Type v\ninst\u271d\u2078 : Group G\ninst\u271d\u2077 : PseudoEMetricSpace G\ninst\u271d\u2076 : IsIsometricSMul G G\ninst\u271d\u2075 : IsIsometricSMul G\u1d50\u1d52\u1d56 G\ninst\u271d\u2074 : PseudoEMetricSpace G\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : PseudoMetricSpace G\ninst\u271d\u00b9 : IsIsometricSMul G G\ninst\u271d : IsIsometricSMul G\u1d50\u1d52\u1d56 G\na b c : G\n\u22a2 nndist (a * b\u207b\u00b9) (a * c\u207b\u00b9) = nndist b c"}]}
{"declaration": "theorem lipschitzWith_iff_dist_le_mul [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {K : \u211d\u22650}\n    {f : \u03b1 \u2192 \u03b2} : LipschitzWith K f \u2194 \u2200 x y, dist (f x) (f y) \u2264 K * dist x y := by\n  simp only [LipschitzWith]\n  simp only [edist_nndist]\n  simp only [dist_nndist]\n  norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Lipschitz.lean", "context": {"open": ["Filter Function Set Topology NNReal ENNReal Bornology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Type x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\n\u22a2 LipschitzWith K f \u2194 \u2200 (x y : \u03b1), dist (f x) (f y) \u2264 \u2191K * dist x y"}, {"line": "simp only [LipschitzWith]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (x y : \u03b1), edist (f x) (f y) \u2264 \u2191K * edist x y) \u2194 \u2200 (x y : \u03b1), dist (f x) (f y) \u2264 \u2191K * dist x y"}, {"line": "simp only [edist_nndist]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (x y : \u03b1), \u2191(nndist (f x) (f y)) \u2264 \u2191K * \u2191(nndist x y)) \u2194 \u2200 (x y : \u03b1), dist (f x) (f y) \u2264 \u2191K * dist x y"}, {"line": "simp only [dist_nndist]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (x y : \u03b1), \u2191(nndist (f x) (f y)) \u2264 \u2191K * \u2191(nndist x y)) \u2194 \u2200 (x y : \u03b1), \u2191(nndist (f x) (f y)) \u2264 \u2191K * \u2191(nndist x y)"}, {"line": "norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lipschitzOnWith_iff_dist_le_mul [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {K : \u211d\u22650}\n    {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} :\n    LipschitzOnWith K f s \u2194 \u2200 x \u2208 s, \u2200 y \u2208 s, dist (f x) (f y) \u2264 K * dist x y := by\n  simp only [LipschitzOnWith]\n  simp only [edist_nndist]\n  simp only [dist_nndist]\n  norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Lipschitz.lean", "context": {"open": ["Filter Function Set Topology NNReal ENNReal Bornology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Type x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : NNReal\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 LipschitzOnWith K f s \u2194 \u2200 x \u2208 s, \u2200 y \u2208 s, dist (f x) (f y) \u2264 \u2191K * dist x y"}, {"line": "simp only [LipschitzOnWith]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : NNReal\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u2192 edist (f x) (f y) \u2264 \u2191K * edist x y) \u2194\n    \u2200 x \u2208 s, \u2200 y \u2208 s, dist (f x) (f y) \u2264 \u2191K * dist x y"}, {"line": "simp only [edist_nndist]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : NNReal\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u2192 \u2191(nndist (f x) (f y)) \u2264 \u2191K * \u2191(nndist x y)) \u2194\n    \u2200 x \u2208 s, \u2200 y \u2208 s, dist (f x) (f y) \u2264 \u2191K * dist x y"}, {"line": "simp only [dist_nndist]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : NNReal\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u2192 \u2191(nndist (f x) (f y)) \u2264 \u2191K * \u2191(nndist x y)) \u2194\n    \u2200 x \u2208 s, \u2200 y \u2208 s, \u2191(nndist (f x) (f y)) \u2264 \u2191K * \u2191(nndist x y)"}, {"line": "norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_iterate_succ_le_geometric {f : \u03b1 \u2192 \u03b1} (hf : LipschitzWith K f) (x n) :\n    dist (f^[n] x) (f^[n + 1] x) \u2264 dist x (f x) * (K : \u211d) ^ n := by\n  rw [iterate_succ]\n  rw [mul_comm]\n  simpa only [NNReal.coe_pow] using (hf.iterate n).dist_le_mul x (f x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Lipschitz.lean", "context": {"open": ["Filter Function Set Topology NNReal ENNReal Bornology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Type x}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] [PseudoMetricSpace \u03b3] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nK : NNReal\nf : \u03b1 \u2192 \u03b1\nhf : LipschitzWith K f\nx : \u03b1\nn : \u2115\n\u22a2 dist (f^[n] x) (f^[n + 1] x) \u2264 dist x (f x) * \u2191K ^ n"}, {"line": "rw [iterate_succ]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nK : NNReal\nf : \u03b1 \u2192 \u03b1\nhf : LipschitzWith K f\nx : \u03b1\nn : \u2115\n\u22a2 dist (f^[n] x) ((f^[n] \u2218 f) x) \u2264 dist x (f x) * \u2191K ^ n"}, {"line": "rw [mul_comm]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nK : NNReal\nf : \u03b1 \u2192 \u03b1\nhf : LipschitzWith K f\nx : \u03b1\nn : \u2115\n\u22a2 dist (f^[n] x) ((f^[n] \u2218 f) x) \u2264 \u2191K ^ n * dist x (f x)"}, {"line": "simpa only [NNReal.coe_pow] using (hf.iterate n).dist_le_mul x (f x)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.Real.lipschitzWith_toNNReal : LipschitzWith 1 Real.toNNReal := by\n  refine lipschitzWith_iff_dist_le_mul.mpr (fun x y \u21a6 ?_)\n  simpa only [NNReal.coe_one,dist_prod_same_right,one_mul,Real.dist_eq] using\n    lipschitzWith_iff_dist_le_mul.mp lipschitzWith_max (x, 0) (y, 0)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Lipschitz.lean", "context": {"open": ["Filter Function Set Topology NNReal ENNReal Bornology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Type x}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] [PseudoMetricSpace \u03b3] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 LipschitzWith 1 Real.toNNReal"}, {"line": "refine lipschitzWith_iff_dist_le_mul.mpr (fun x y \u21a6 ?_)", "tactic_state": "x y : \u211d\n\u22a2 dist x.toNNReal y.toNNReal \u2264 \u21911 * dist x y"}, {"line": "simpa only [NNReal.coe_one,dist_prod_same_right,one_mul,Real.dist_eq] using\n    lipschitzWith_iff_dist_le_mul.mp lipschitzWith_max (x, 0) (y, 0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem max_const (hf : LipschitzWith Kf f) (a : \u211d) : LipschitzWith Kf fun x => max (f x) a := by\n  simpa only [max_eq_left (zero_le Kf)] using hf.max (LipschitzWith.const a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Lipschitz.lean", "context": {"open": ["Filter Function Set Topology NNReal ENNReal Bornology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Type x}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] [PseudoMetricSpace \u03b3] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] {f g : \u03b1 \u2192 \u211d} {Kf Kg : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\nKf : NNReal\nhf : LipschitzWith Kf f\na : \u211d\n\u22a2 LipschitzWith Kf fun x => max (f x) a"}, {"line": "simpa only [max_eq_left (zero_le Kf)] using hf.max (LipschitzWith.const a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem const_max (hf : LipschitzWith Kf f) (a : \u211d) : LipschitzWith Kf fun x => max a (f x) := by\n  simpa only [max_comm] using hf.max_const a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Lipschitz.lean", "context": {"open": ["Filter Function Set Topology NNReal ENNReal Bornology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Type x}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] [PseudoMetricSpace \u03b3] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] {f g : \u03b1 \u2192 \u211d} {Kf Kg : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\nKf : NNReal\nhf : LipschitzWith Kf f\na : \u211d\n\u22a2 LipschitzWith Kf fun x => max a (f x)"}, {"line": "simpa only [max_comm] using hf.max_const a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem min_const (hf : LipschitzWith Kf f) (a : \u211d) : LipschitzWith Kf fun x => min (f x) a := by\n  simpa only [max_eq_left (zero_le Kf)] using hf.min (LipschitzWith.const a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Lipschitz.lean", "context": {"open": ["Filter Function Set Topology NNReal ENNReal Bornology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Type x}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] [PseudoMetricSpace \u03b3] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] {f g : \u03b1 \u2192 \u211d} {Kf Kg : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\nKf : NNReal\nhf : LipschitzWith Kf f\na : \u211d\n\u22a2 LipschitzWith Kf fun x => min (f x) a"}, {"line": "simpa only [max_eq_left (zero_le Kf)] using hf.min (LipschitzWith.const a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem const_min (hf : LipschitzWith Kf f) (a : \u211d) : LipschitzWith Kf fun x => min a (f x) := by\n  simpa only [min_comm] using hf.min_const a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Lipschitz.lean", "context": {"open": ["Filter Function Set Topology NNReal ENNReal Bornology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Type x}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] [PseudoMetricSpace \u03b3] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] {f g : \u03b1 \u2192 \u211d} {Kf Kg : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\nKf : NNReal\nhf : LipschitzWith Kf f\na : \u211d\n\u22a2 LipschitzWith Kf fun x => min a (f x)"}, {"line": "simpa only [min_comm] using hf.min_const a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem const_max (hf : LocallyLipschitz f) (a : \u211d) : LocallyLipschitz fun x => max a (f x) := by\n  simpa [max_comm] using (hf.max_const a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Lipschitz.lean", "context": {"open": ["Filter Function Set Topology NNReal ENNReal Bornology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Type x}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] [PseudoMetricSpace \u03b3] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] {f g : \u03b1 \u2192 \u211d} {Kf Kg : \u211d\u22650}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s : Set \u03b1} {t : Set \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] [PseudoMetricSpace \u03b3]", "{K : \u211d\u22650} {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] {f g : \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 : PseudoMetricSpace \u03b1\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\nhf : LocallyLipschitz f\na : \u211d\n\u22a2 LocallyLipschitz fun x => max a (f x)"}, {"line": "simpa [max_comm] using (hf.max_const a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem const_min (hf : LocallyLipschitz f) (a : \u211d) : LocallyLipschitz fun x => min a (f x) := by\n  simpa [min_comm] using (hf.min_const a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Lipschitz.lean", "context": {"open": ["Filter Function Set Topology NNReal ENNReal Bornology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Type x}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] [PseudoMetricSpace \u03b3] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] {f g : \u03b1 \u2192 \u211d} {Kf Kg : \u211d\u22650}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s : Set \u03b1} {t : Set \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] [PseudoMetricSpace \u03b3]", "{K : \u211d\u22650} {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] {f g : \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 : PseudoMetricSpace \u03b1\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\nhf : LocallyLipschitz f\na : \u211d\n\u22a2 LocallyLipschitz fun x => min a (f x)"}, {"line": "simpa [min_comm] using (hf.min_const a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lipschitz_with_lipschitz_const_mul :\n    \u2200 p q : \u03b2 \u00d7 \u03b2, dist (p.1 * p.2) (q.1 * q.2) \u2264 LipschitzMul.C \u03b2 * dist p q := by\n  rw [\u2190 lipschitzWith_iff_dist_le_mul]\n  exact lipschitzWith_lipschitz_const_mul_edist\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Algebra.lean", "context": {"open": ["NNReal"], "variables": ["(\u03b1 \u03b2 : Type*) [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2]", "[Monoid \u03b2]", "{\u03b2}", "[LipschitzMul \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace \u03b2\ninst\u271d\u00b9 : Monoid \u03b2\ninst\u271d : LipschitzMul \u03b2\n\u22a2 \u2200 (p q : \u03b2 \u00d7 \u03b2), dist (p.1 * p.2) (q.1 * q.2) \u2264 \u2191(LipschitzMul.C \u03b2) * dist p q"}, {"line": "rw [\u2190 lipschitzWith_iff_dist_le_mul]", "tactic_state": "\u03b2 : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace \u03b2\ninst\u271d\u00b9 : Monoid \u03b2\ninst\u271d : LipschitzMul \u03b2\n\u22a2 LipschitzWith (LipschitzMul.C \u03b2) fun p => p.1 * p.2"}, {"line": "exact lipschitzWith_lipschitz_const_mul_edist", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_dist_left_atTop (c : \u03b1) : comap (dist c) atTop = cobounded \u03b1 := by\n  simpa only [dist_comm _ c] using comap_dist_right_atTop c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Bounded.lean", "context": {"open": ["Set Filter Bornology", "scoped ENNReal Uniformity Topology Pointwise"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x : \u03b1} {s t : Set \u03b1} {r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nc : \u03b1\n\u22a2 comap (dist c) atTop = cobounded \u03b1"}, {"line": "simpa only [dist_comm _ c] using comap_dist_right_atTop c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_cocompact_of_closedBall_compl_subset [ProperSpace \u03b1] (c : \u03b1)\n    (h : \u2203 r, (closedBall c r)\u1d9c \u2286 s) : s \u2208 cocompact \u03b1 := by\n  rcases h with \u27e8r, h\u27e9\n  rw [Filter.mem_cocompact]\n  exact \u27e8closedBall c r, isCompact_closedBall c r, h\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Bounded.lean", "context": {"open": ["Set Filter Bornology", "scoped ENNReal Uniformity Topology Pointwise"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x : \u03b1} {s t : Set \u03b1} {r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx\u271d : Sort u_3\nclosedBall : x\u271d\ninst\u271d : ProperSpace \u03b1\nc : \u03b1\nh : \u2203 r, sorry\u1d9c \u2286 s\n\u22a2 s \u2208 cocompact \u03b1"}, {"line": "rcases h with \u27e8r, h\u27e9", "tactic_state": "case intro\n\u03b1 : Type u\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx\u271d : Sort u_3\nclosedBall : x\u271d\ninst\u271d : ProperSpace \u03b1\nc : \u03b1\nr : ?m.907 c\nh : sorry\u1d9c \u2286 s\n\u22a2 s \u2208 cocompact \u03b1"}, {"line": "rw [Filter.mem_cocompact]", "tactic_state": "case intro\n\u03b1 : Type u\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx\u271d : Sort u_3\nclosedBall : x\u271d\ninst\u271d : ProperSpace \u03b1\nc : \u03b1\nr : ?m.907 c\nh : sorry\u1d9c \u2286 s\n\u22a2 \u2203 t, IsCompact t \u2227 t\u1d9c \u2286 s"}, {"line": "exact \u27e8closedBall c r, isCompact_closedBall c r, h\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_isOpen_isBounded_image_of_isCompact_of_forall_continuousAt [TopologicalSpace \u03b2]\n    {k : Set \u03b2} {f : \u03b2 \u2192 \u03b1} (hk : IsCompact k) (hf : \u2200 x \u2208 k, ContinuousAt f x) :\n    \u2203 t, k \u2286 t \u2227 IsOpen t \u2227 IsBounded (f '' t) := by\n  simp_rw [\u2190 continuousWithinAt_univ] at hf\n  simpa only [inter_univ] using\n    exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt hk hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Bounded.lean", "context": {"open": ["Set Filter Bornology", "scoped ENNReal Uniformity Topology Pointwise"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x : \u03b1} {s t : Set \u03b1} {r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nk : Set \u03b2\nf : \u03b2 \u2192 \u03b1\nhk : IsCompact k\nhf : \u2200 x \u2208 k, ContinuousAt f x\n\u22a2 \u2203 t, k \u2286 t \u2227 IsOpen t \u2227 Bornology.IsBounded (f '' t)"}, {"line": "simp_rw [\u2190 continuousWithinAt_univ] at hf", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nk : Set \u03b2\nf : \u03b2 \u2192 \u03b1\nhk : IsCompact k\nhf : \u2200 x \u2208 k, ContinuousWithinAt f univ x\n\u22a2 \u2203 t, k \u2286 t \u2227 IsOpen t \u2227 Bornology.IsBounded (f '' t)"}, {"line": "simpa only [inter_univ] using\n    exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt hk hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem diam_triple :\n    Metric.diam ({x, y, z} : Set \u03b1) = max (max (dist x y) (dist x z)) (dist y z) := by\n  simp only [Metric.diam]\n  simp only [EMetric.diam_triple]\n  simp only [dist_edist]\n  rw [ENNReal.toReal_max] <;> apply_rules [ne_of_lt, edist_lt_top, max_lt]\n  rw [ENNReal.toReal_max] <;> apply_rules [ne_of_lt, edist_lt_top, max_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Bounded.lean", "context": {"open": ["Set Filter Bornology", "scoped ENNReal Uniformity Topology Pointwise"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x : \u03b1} {s t : Set \u03b1} {r : \u211d}", "[Preorder \u03b1] [CompactIccSpace \u03b1]", "{s : Set \u03b1} {x y z : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CompactIccSpace \u03b1\nx y z : \u03b1\n\u22a2 Metric.diam {x, y, z} = max (max (dist x y) (dist x z)) (dist y z)"}, {"line": "simp only [Metric.diam]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CompactIccSpace \u03b1\nx y z : \u03b1\n\u22a2 (EMetric.diam {x, y, z}).toReal = max (max (dist x y) (dist x z)) (dist y z)"}, {"line": "simp only [EMetric.diam_triple]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CompactIccSpace \u03b1\nx y z : \u03b1\n\u22a2 (max (max (edist x y) (edist x z)) (edist y z)).toReal = max (max (dist x y) (dist x z)) (dist y z)"}, {"line": "simp only [dist_edist]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CompactIccSpace \u03b1\nx y z : \u03b1\n\u22a2 (max (max (edist x y) (edist x z)) (edist y z)).toReal =\n    max (max (edist x y).toReal (edist x z).toReal) (edist y z).toReal"}, {"line": "rw [ENNReal.toReal_max] <;> apply_rules [ne_of_lt, edist_lt_top, max_lt]", "tactic_state": "case h.h\n\u03b1 : Type u\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CompactIccSpace \u03b1\nx y z : \u03b1\n\u22a2 (max (edist x y) (edist x z)).toReal = max (edist x y).toReal (edist x z).toReal"}, {"line": "rw [ENNReal.toReal_max] <;> apply_rules [ne_of_lt, edist_lt_top, max_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem diam_univ_of_noncompact [ProperSpace \u03b1] [NoncompactSpace \u03b1] : diam (univ : Set \u03b1) = 0 := by\n  simp [diam]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Bounded.lean", "context": {"open": ["Set Filter Bornology", "scoped ENNReal Uniformity Topology Pointwise"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x : \u03b1} {s t : Set \u03b1} {r : \u211d}", "[Preorder \u03b1] [CompactIccSpace \u03b1]", "{s : Set \u03b1} {x y z : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 : PseudoMetricSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : CompactIccSpace \u03b1\nx\u271d : Sort u_3\ndiam : x\u271d\ninst\u271d\u00b9 : ProperSpace \u03b1\ninst\u271d : NoncompactSpace \u03b1\n\u22a2 sorry = 0"}, {"line": "simp [diam]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 : PseudoMetricSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : CompactIccSpace \u03b1\nx\u271d : Sort u_3\ndiam : x\u271d\ninst\u271d\u00b9 : ProperSpace \u03b1\ninst\u271d : NoncompactSpace \u03b1\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem comap_dist_left_atTop_eq_cocompact [ProperSpace \u03b1] (x : \u03b1) :\n    comap (dist x) atTop = cocompact \u03b1 := by simp [cobounded_eq_cocompact]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Bounded.lean", "context": {"open": ["Set Filter Bornology", "scoped ENNReal Uniformity Topology Pointwise", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x : \u03b1} {s t : Set \u03b1} {r : \u211d}", "[Preorder \u03b1] [CompactIccSpace \u03b1]", "{s : Set \u03b1} {x y z : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : CompactIccSpace \u03b1\ninst\u271d : ProperSpace \u03b1\nx : \u03b1\n\u22a2 comap (dist x) atTop = cocompact \u03b1"}, {"line": "simp [cobounded_eq_cocompact]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : CompactIccSpace \u03b1\ninst\u271d : ProperSpace \u03b1\nx : \u03b1\n\u22a2 cobounded \u03b1 = cocompact \u03b1"}]}
{"declaration": "theorem Metric.finite_isBounded_inter_isClosed [ProperSpace \u03b1] {K s : Set \u03b1} [DiscreteTopology s]\n    (hK : IsBounded K) (hs : IsClosed s) : Set.Finite (K \u2229 s) := by\n  refine Set.Finite.subset (IsCompact.finite ?_ ?_) (Set.inter_subset_inter_left s subset_closure)\n  \u00b7 exact hK.isCompact_closure.inter_right hs\n  \u00b7 exact DiscreteTopology.of_subset inferInstance Set.inter_subset_right", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Bounded.lean", "context": {"open": ["Set Filter Bornology", "scoped ENNReal Uniformity Topology Pointwise", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x : \u03b1} {s t : Set \u03b1} {r : \u211d}", "[Preorder \u03b1] [CompactIccSpace \u03b1]", "{s : Set \u03b1} {x y z : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 : PseudoMetricSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : CompactIccSpace \u03b1\ninst\u271d\u00b9 : ProperSpace \u03b1\nK s : Set \u03b1\ninst\u271d : DiscreteTopology \u2191s\nhK : Bornology.IsBounded K\nhs : IsClosed s\n\u22a2 (K \u2229 s).Finite"}, {"line": "refine Set.Finite.subset (IsCompact.finite ?_ ?_) (Set.inter_subset_inter_left s subset_closure)", "tactic_state": "case refine_1\n\u03b1 : Type u\ninst\u271d\u2074 : PseudoMetricSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : CompactIccSpace \u03b1\ninst\u271d\u00b9 : ProperSpace \u03b1\nK s : Set \u03b1\ninst\u271d : DiscreteTopology \u2191s\nhK : Bornology.IsBounded K\nhs : IsClosed s\n\u22a2 TopologicalSpace \u03b1\n---\ncase refine_2\n\u03b1 : Type u\ninst\u271d\u2074 : PseudoMetricSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : CompactIccSpace \u03b1\ninst\u271d\u00b9 : ProperSpace \u03b1\nK s : Set \u03b1\ninst\u271d : DiscreteTopology \u2191s\nhK : Bornology.IsBounded K\nhs : IsClosed s\n\u22a2 IsCompact (closure K \u2229 s)\n---\ncase refine_3\n\u03b1 : Type u\ninst\u271d\u2074 : PseudoMetricSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : CompactIccSpace \u03b1\ninst\u271d\u00b9 : ProperSpace \u03b1\nK s : Set \u03b1\ninst\u271d : DiscreteTopology \u2191s\nhK : Bornology.IsBounded K\nhs : IsClosed s\n\u22a2 DiscreteTopology \u2191(closure K \u2229 s)\n---\ncase refine_4\n\u03b1 : Type u\ninst\u271d\u2074 : PseudoMetricSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : CompactIccSpace \u03b1\ninst\u271d\u00b9 : ProperSpace \u03b1\nK s : Set \u03b1\ninst\u271d : DiscreteTopology \u2191s\nhK : Bornology.IsBounded K\nhs : IsClosed s\n\u22a2 TopologicalSpace \u03b1"}, {"line": "\u00b7 exact hK.isCompact_closure.inter_right hs", "tactic_state": "case refine_2\n\u03b1 : Type u\ninst\u271d\u2074 : PseudoMetricSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : CompactIccSpace \u03b1\ninst\u271d\u00b9 : ProperSpace \u03b1\nK s : Set \u03b1\ninst\u271d : DiscreteTopology \u2191s\nhK : Bornology.IsBounded K\nhs : IsClosed s\n\u22a2 IsCompact (closure K \u2229 s)\n---\ncase refine_3\n\u03b1 : Type u\ninst\u271d\u2074 : PseudoMetricSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : CompactIccSpace \u03b1\ninst\u271d\u00b9 : ProperSpace \u03b1\nK s : Set \u03b1\ninst\u271d : DiscreteTopology \u2191s\nhK : Bornology.IsBounded K\nhs : IsClosed s\n\u22a2 DiscreteTopology \u2191(closure K \u2229 s)\n---\ncase refine_4\n\u03b1 : Type u\ninst\u271d\u2074 : PseudoMetricSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : CompactIccSpace \u03b1\ninst\u271d\u00b9 : ProperSpace \u03b1\nK s : Set \u03b1\ninst\u271d : DiscreteTopology \u2191s\nhK : Bornology.IsBounded K\nhs : IsClosed s\n\u22a2 TopologicalSpace \u03b1"}, {"line": "\u00b7 exact DiscreteTopology.of_subset inferInstance Set.inter_subset_right", "tactic_state": "case refine_3\n\u03b1 : Type u\ninst\u271d\u2074 : PseudoMetricSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : CompactIccSpace \u03b1\ninst\u271d\u00b9 : ProperSpace \u03b1\nK s : Set \u03b1\ninst\u271d : DiscreteTopology \u2191s\nhK : Bornology.IsBounded K\nhs : IsClosed s\n\u22a2 DiscreteTopology \u2191(closure K \u2229 s)\n---\ncase refine_4\n\u03b1 : Type u\ninst\u271d\u2074 : PseudoMetricSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : CompactIccSpace \u03b1\ninst\u271d\u00b9 : ProperSpace \u03b1\nK s : Set \u03b1\ninst\u271d : DiscreteTopology \u2191s\nhK : Bornology.IsBounded K\nhs : IsClosed s\n\u22a2 TopologicalSpace \u03b1"}]}
{"declaration": "theorem Sum.dist_eq_glueDist {p q : X \u2295 Y} (x : X) (y : Y) :\n    Sum.dist p q =\n      glueDist (fun _ : Unit => Nonempty.some \u27e8x\u27e9) (fun _ : Unit => Nonempty.some \u27e8y\u27e9) 1 p q := by\n  cases p <;> cases q <;> first |rfl|simp [Sum.dist, glueDist, dist_comm, add_comm,\n    add_left_comm, add_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Gluing.lean", "context": {"open": ["Function Set Uniformity Topology"], "variables": ["{X : Type u} {Y : Type v} {Z : Type w}", "[MetricSpace X] [MetricSpace Y] {\u03a6 : Z \u2192 X} {\u03a8 : Z \u2192 Y} {\u03b5 : \u211d}", "[Nonempty Z]", "{X : Type u} {Y : Type v} {Z : Type w}", "[MetricSpace X] [MetricSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : MetricSpace X\ninst\u271d : MetricSpace Y\nx\u271d : Sort u_1\nglueDist : x\u271d\np q : X \u2295 Y\nx : X\ny : Y\n\u22a2 sorry = sorry"}, {"line": "cases p <;> cases q <;> first |rfl|simp [Sum.dist, glueDist, dist_comm, add_comm,\n    add_left_comm, add_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem Sum.dist_comm (x y : X \u2295 Y) : Sum.dist x y = Sum.dist y x := by\n  cases x <;> cases y <;> simp [Sum.dist, _root_.dist_comm, add_comm, add_left_comm, add_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Gluing.lean", "context": {"open": ["Function Set Uniformity Topology"], "variables": ["{X : Type u} {Y : Type v} {Z : Type w}", "[MetricSpace X] [MetricSpace Y] {\u03a6 : Z \u2192 X} {\u03a8 : Z \u2192 Y} {\u03b5 : \u211d}", "[Nonempty Z]", "{X : Type u} {Y : Type v} {Z : Type w}", "[MetricSpace X] [MetricSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : MetricSpace X\ninst\u271d : MetricSpace Y\nx y : X \u2295 Y\n\u22a2 sorry = sorry"}, {"line": "cases x <;> cases y <;> simp [Sum.dist, _root_.dist_comm, add_comm, add_left_comm, add_assoc]", "tactic_state": "case inl.inl\nX : Type u\nY : Type v\ninst\u271d\u00b9 : MetricSpace X\ninst\u271d : MetricSpace Y\nval\u271d\u00b9 val\u271d : X\n\u22a2 sorry () = sorry ()\n---\ncase inl.inr\nX : Type u\nY : Type v\ninst\u271d\u00b9 : MetricSpace X\ninst\u271d : MetricSpace Y\nval\u271d\u00b9 : X\nval\u271d : Y\n\u22a2 sorry () = sorry ()\n---\ncase inr.inl\nX : Type u\nY : Type v\ninst\u271d\u00b9 : MetricSpace X\ninst\u271d : MetricSpace Y\nval\u271d\u00b9 : Y\nval\u271d : X\n\u22a2 sorry () = sorry ()\n---\ncase inr.inr\nX : Type u\nY : Type v\ninst\u271d\u00b9 : MetricSpace X\ninst\u271d : MetricSpace Y\nval\u271d\u00b9 val\u271d : Y\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem dist_same (i : \u03b9) (x y : E i) : dist (Sigma.mk i x) \u27e8i, y\u27e9 = dist x y := by\n  simp [Dist.dist, Sigma.dist]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Gluing.lean", "context": {"open": ["Function Set Uniformity Topology", "Classical in"], "variables": ["{X : Type u} {Y : Type v} {Z : Type w}", "[MetricSpace X] [MetricSpace Y] {\u03a6 : Z \u2192 X} {\u03a8 : Z \u2192 Y} {\u03b5 : \u211d}", "[Nonempty Z]", "{X : Type u} {Y : Type v} {Z : Type w}", "[MetricSpace X] [MetricSpace Y]", "{\u03b9 : Type*} {E : \u03b9 \u2192 Type*} [\u2200 i, MetricSpace (E i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nE : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 MetricSpace (E i)\ni : \u03b9\nx y : E i\n\u22a2 sorry = dist x y"}, {"line": "simp [Dist.dist, Sigma.dist]", "tactic_state": "\u03b9 : Type u_1\nE : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 MetricSpace (E i)\ni : \u03b9\nx y : E i\n\u22a2 sorry () = dist x y"}]}
{"declaration": "theorem dimH_bUnion {s : Set \u03b9} (hs : s.Countable) (t : \u03b9 \u2192 Set X) :\n    dimH (\u22c3 i \u2208 s, t i) = \u2a06 i \u2208 s, dimH (t i) := by\n  haveI := hs.toEncodable\n  rw [biUnion_eq_iUnion]\n  rw [dimH_iUnion]\n  rw [\u2190 iSup_subtype'']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDimension.lean", "context": {"open": ["scoped MeasureTheory ENNReal NNReal Topology", "MeasureTheory MeasureTheory.Measure Set TopologicalSpace Module Filter"], "variables": ["{\u03b9 X Y : Type*} [EMetricSpace X] [EMetricSpace Y]", "[MeasurableSpace X] [BorelSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nX : Type u_2\ninst\u271d\u00b2 : EMetricSpace X\ninst\u271d\u00b9 : MeasurableSpace X\ninst\u271d : BorelSpace X\ns : Set \u03b9\nhs : s.Countable\nt : \u03b9 \u2192 Set X\n\u22a2 dimH (\u22c3 i \u2208 s, t i) = \u2a06 i \u2208 s, dimH (t i)"}, {"line": "haveI := hs.toEncodable", "tactic_state": "\u03b9 : Type u_1\nX : Type u_2\ninst\u271d\u00b2 : EMetricSpace X\ninst\u271d\u00b9 : MeasurableSpace X\ninst\u271d : BorelSpace X\ns : Set \u03b9\nhs : s.Countable\nt : \u03b9 \u2192 Set X\nthis : Encodable \u2191s\n\u22a2 dimH (\u22c3 i \u2208 s, t i) = \u2a06 i \u2208 s, dimH (t i)"}, {"line": "rw [biUnion_eq_iUnion]", "tactic_state": "\u03b9 : Type u_1\nX : Type u_2\ninst\u271d\u00b2 : EMetricSpace X\ninst\u271d\u00b9 : MeasurableSpace X\ninst\u271d : BorelSpace X\ns : Set \u03b9\nhs : s.Countable\nt : \u03b9 \u2192 Set X\nthis : Encodable \u2191s\n\u22a2 dimH (\u22c3 x, t \u2191x) = \u2a06 i \u2208 s, dimH (t i)"}, {"line": "rw [dimH_iUnion]", "tactic_state": "\u03b9 : Type u_1\nX : Type u_2\ninst\u271d\u00b2 : EMetricSpace X\ninst\u271d\u00b9 : MeasurableSpace X\ninst\u271d : BorelSpace X\ns : Set \u03b9\nhs : s.Countable\nt : \u03b9 \u2192 Set X\nthis : Encodable \u2191s\n\u22a2 \u2a06 i, dimH (t \u2191i) = \u2a06 i \u2208 s, dimH (t i)"}, {"line": "rw [\u2190 iSup_subtype'']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dimH_sUnion {S : Set (Set X)} (hS : S.Countable) : dimH (\u22c3\u2080 S) = \u2a06 s \u2208 S, dimH s := by\n  rw [sUnion_eq_biUnion]\n  rw [dimH_bUnion hS]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDimension.lean", "context": {"open": ["scoped MeasureTheory ENNReal NNReal Topology", "MeasureTheory MeasureTheory.Measure Set TopologicalSpace Module Filter"], "variables": ["{\u03b9 X Y : Type*} [EMetricSpace X] [EMetricSpace Y]", "[MeasurableSpace X] [BorelSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d\u00b2 : EMetricSpace X\ninst\u271d\u00b9 : MeasurableSpace X\ninst\u271d : BorelSpace X\nS : Set (Set X)\nhS : S.Countable\n\u22a2 dimH (\u22c3\u2080 S) = \u2a06 s \u2208 S, dimH s"}, {"line": "rw [sUnion_eq_biUnion]", "tactic_state": "X : Type u_2\ninst\u271d\u00b2 : EMetricSpace X\ninst\u271d\u00b9 : MeasurableSpace X\ninst\u271d : BorelSpace X\nS : Set (Set X)\nhS : S.Countable\n\u22a2 dimH (\u22c3 i \u2208 S, i) = \u2a06 s \u2208 S, dimH s"}, {"line": "rw [dimH_bUnion hS]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dimH_union (s t : Set X) : dimH (s \u222a t) = max (dimH s) (dimH t) := by\n  rw [union_eq_iUnion]\n  rw [dimH_iUnion]\n  rw [iSup_bool_eq]\n  rw [cond]\n  rw [cond]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDimension.lean", "context": {"open": ["scoped MeasureTheory ENNReal NNReal Topology", "MeasureTheory MeasureTheory.Measure Set TopologicalSpace Module Filter"], "variables": ["{\u03b9 X Y : Type*} [EMetricSpace X] [EMetricSpace Y]", "[MeasurableSpace X] [BorelSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d\u00b2 : EMetricSpace X\ninst\u271d\u00b9 : MeasurableSpace X\ninst\u271d : BorelSpace X\ns t : Set X\n\u22a2 dimH (s \u222a t) = max (dimH s) (dimH t)"}, {"line": "rw [union_eq_iUnion]", "tactic_state": "X : Type u_2\ninst\u271d\u00b2 : EMetricSpace X\ninst\u271d\u00b9 : MeasurableSpace X\ninst\u271d : BorelSpace X\ns t : Set X\n\u22a2 dimH (\u22c3 b, bif b then s else t) = max (dimH s) (dimH t)"}, {"line": "rw [dimH_iUnion]", "tactic_state": "X : Type u_2\ninst\u271d\u00b2 : EMetricSpace X\ninst\u271d\u00b9 : MeasurableSpace X\ninst\u271d : BorelSpace X\ns t : Set X\n\u22a2 \u2a06 i, dimH (bif i then s else t) = max (dimH s) (dimH t)"}, {"line": "rw [iSup_bool_eq]", "tactic_state": "X : Type u_2\ninst\u271d\u00b2 : EMetricSpace X\ninst\u271d\u00b9 : MeasurableSpace X\ninst\u271d : BorelSpace X\ns t : Set X\n\u22a2 max (dimH (bif true then s else t)) (dimH (bif false then s else t)) = max (dimH s) (dimH t)"}, {"line": "rw [cond]", "tactic_state": "X : Type u_2\ninst\u271d\u00b2 : EMetricSpace X\ninst\u271d\u00b9 : MeasurableSpace X\ninst\u271d : BorelSpace X\ns t : Set X\n\u22a2 max (dimH s) (dimH (bif false then s else t)) = max (dimH s) (dimH t)"}, {"line": "rw [cond]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_limsup_dimH (s : Set X) : \u2a06 x, limsup dimH (\ud835\udcdd[s] x).smallSets = dimH s := by\n  refine le_antisymm (iSup_le fun x => ?_) ?_\n  \u00b7 refine limsup_le_of_le isCobounded_le_of_bot ?_\n    exact eventually_smallSets.2 \u27e8s, self_mem_nhdsWithin, fun t => dimH_mono\u27e9\n  \u00b7 rw [\u2190 bsupr_limsup_dimH]; exact iSup\u2082_le_iSup _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDimension.lean", "context": {"open": ["scoped MeasureTheory ENNReal NNReal Topology", "MeasureTheory MeasureTheory.Measure Set TopologicalSpace Module Filter"], "variables": ["{\u03b9 X Y : Type*} [EMetricSpace X] [EMetricSpace Y]", "[MeasurableSpace X] [BorelSpace X]", "[SecondCountableTopology X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d\u00b3 : EMetricSpace X\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : BorelSpace X\ninst\u271d : SecondCountableTopology X\ns : Set X\n\u22a2 \u2a06 x, limsup dimH (nhdsWithin x s).smallSets = dimH s"}, {"line": "refine le_antisymm (iSup_le fun x => ?_) ?_", "tactic_state": "case refine_1\nX : Type u_2\ninst\u271d\u00b3 : EMetricSpace X\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : BorelSpace X\ninst\u271d : SecondCountableTopology X\ns : Set X\nx : X\n\u22a2 limsup dimH (nhdsWithin x s).smallSets \u2264 dimH s\n---\ncase refine_2\nX : Type u_2\ninst\u271d\u00b3 : EMetricSpace X\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : BorelSpace X\ninst\u271d : SecondCountableTopology X\ns : Set X\n\u22a2 dimH s \u2264 \u2a06 x, limsup dimH (nhdsWithin x s).smallSets"}, {"line": "\u00b7 refine limsup_le_of_le isCobounded_le_of_bot ?_\n    exact eventually_smallSets.2 \u27e8s, self_mem_nhdsWithin, fun t => dimH_mono\u27e9", "tactic_state": "case refine_2\nX : Type u_2\ninst\u271d\u00b3 : EMetricSpace X\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : BorelSpace X\ninst\u271d : SecondCountableTopology X\ns : Set X\n\u22a2 dimH s \u2264 \u2a06 x, limsup dimH (nhdsWithin x s).smallSets"}, {"line": "\u00b7 rw [\u2190 bsupr_limsup_dimH]; exact iSup\u2082_le_iSup _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LipschitzOnWith.dimH_image_le (h : LipschitzOnWith K f s) : dimH (f '' s) \u2264 dimH s := by\n  simpa using h.holderOnWith.dimH_image_le zero_lt_one\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDimension.lean", "context": {"open": ["scoped MeasureTheory ENNReal NNReal Topology", "MeasureTheory MeasureTheory.Measure Set TopologicalSpace Module Filter"], "variables": ["{\u03b9 X Y : Type*} [EMetricSpace X] [EMetricSpace Y]", "[MeasurableSpace X] [BorelSpace X]", "[SecondCountableTopology X]", "{C K r : \u211d\u22650} {f : X \u2192 Y} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\nY : Type u_3\ninst\u271d\u2074 : EMetricSpace X\ninst\u271d\u00b3 : EMetricSpace Y\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : BorelSpace X\ninst\u271d : SecondCountableTopology X\nK : NNReal\nf : X \u2192 Y\ns : Set X\nh : LipschitzOnWith K f s\n\u22a2 dimH (f '' s) \u2264 dimH s"}, {"line": "simpa using h.holderOnWith.dimH_image_le zero_lt_one", "tactic_state": "No Goals!"}]}
{"declaration": "theorem infEdist_le_infEdist_add_edist : infEdist x s \u2264 infEdist y s + edist x y :=\n  calc\n    \u2a05 z \u2208 s, edist x z \u2264 \u2a05 z \u2208 s, edist y z + edist x y :=\n      iInf\u2082_mono fun _ _ => (edist_triangle _ _ _).trans_eq (add_comm _ _)\n    _ = (\u2a05 z \u2208 s, edist y z) + edist x y := by simp only [ENNReal.iInf_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\nx y : \u03b1\nx\u271d : Sort u_2\ninfEdist : x\u271d\n\u22a2 \u2a05 z \u2208 sorry, edist y z + edist x y = (\u2a05 z \u2208 sorry, edist y z) + edist x y"}, {"line": "simp only [ENNReal.iInf_add]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\nx y : \u03b1\nx\u271d : Sort u_2\ninfEdist : x\u271d\n\u22a2 \u2a05 z \u2208 sorry, edist y z + edist x y = \u2a05 i \u2208 sorry, edist y i + edist x y"}]}
{"declaration": "theorem infEdist_le_edist_add_infEdist : infEdist x s \u2264 edist x y + infEdist y s := by\n  rw [add_comm]\n  exact infEdist_le_infEdist_add_edist\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\nx y : \u03b1\nx\u271d : Sort u_2\ninfEdist : x\u271d\n\u22a2 sorry \u2264 edist x y + sorry"}, {"line": "rw [add_comm]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\nx y : \u03b1\nx\u271d : Sort u_2\ninfEdist : x\u271d\n\u22a2 sorry \u2264 sorry + edist x y"}, {"line": "exact infEdist_le_infEdist_add_edist", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_closedBall_of_lt_infEdist {r : \u211d\u22650\u221e} (h : r < infEdist x s) :\n    Disjoint (closedBall x r) s := by\n  rw [disjoint_left]\n  intro y hy h'y\n  apply lt_irrefl (infEdist x s)\n  calc\n    infEdist x s \u2264 edist x y := infEdist_le_edist_of_mem h'y\n    _ \u2264 r := by rwa [mem_closedBall, edist_comm] at hy\n    _ < infEdist x s := h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\nx\u271d\u00b9 : Sort u_2\ninfEdist : x\u271d\u00b9\nx\u271d : Sort u_3\nclosedBall : x\u271d\nr : ENNReal\nh : r < sorry\n\u22a2 Disjoint sorry s"}, {"line": "rw [disjoint_left]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\nx\u271d\u00b9 : Sort u_2\ninfEdist : x\u271d\u00b9\nx\u271d : Sort u_3\nclosedBall : x\u271d\nr : ENNReal\nh : r < sorry\n\u22a2 \u2200 \u2983a : \u03b1\u2984, a \u2208 sorry \u2192 a \u2209 s"}, {"line": "intro y hy h'y", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\nx\u271d\u00b9 : Sort u_2\ninfEdist : x\u271d\u00b9\nx\u271d : Sort u_3\nclosedBall : x\u271d\nr : ENNReal\nh : r < sorry\ny : \u03b1\nhy : y \u2208 sorry\nh'y : y \u2208 s\n\u22a2 False"}, {"line": "apply lt_irrefl (infEdist x s)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\nx\u271d\u00b9 : Sort u_2\ninfEdist : x\u271d\u00b9\nx\u271d : Sort u_3\nclosedBall : x\u271d\nr : ENNReal\nh : r < sorry\ny : \u03b1\nhy : y \u2208 sorry\nh'y : y \u2208 s\n\u22a2 sorry < sorry\n---\n\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\nx\u271d\u00b9 : Sort u_2\ninfEdist : x\u271d\u00b9\nx\u271d : Sort u_3\nclosedBall : x\u271d\nr : ENNReal\nh : r < sorry\ny : \u03b1\nhy : y \u2208 sorry\nh'y : y \u2208 s\n\u22a2 Type ?u.1757\n---\n\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\nx\u271d\u00b9 : Sort u_2\ninfEdist : x\u271d\u00b9\nx\u271d : Sort u_3\nclosedBall : x\u271d\nr : ENNReal\nh : r < sorry\ny : \u03b1\nhy : y \u2208 sorry\nh'y : y \u2208 s\n\u22a2 Preorder ?m.1758"}, {"line": "calc\n    infEdist x s \u2264 edist x y := infEdist_le_edist_of_mem h'y\n    _ \u2264 r := by rwa [mem_closedBall, edist_comm] at hy\n    _ < infEdist x s := h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.IsCompact.exists_infEdist_eq_edist (hs : IsCompact s) (hne : s.Nonempty) (x : \u03b1) :\n    \u2203 y \u2208 s, infEdist x s = edist x y := by\n  have A : Continuous fun y => edist x y := continuous_const.edist continuous_id\n  obtain \u27e8y, ys, hy\u27e9 := hs.exists_isMinOn hne A.continuousOn\n  exact \u27e8y, ys, le_antisymm (infEdist_le_edist_of_mem ys) (by rwa [le_infEdist])\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\nx\u271d : Sort u_2\ninfEdist : x\u271d\nhs : IsCompact s\nhne : s.Nonempty\nx : \u03b1\n\u22a2 \u2203 y \u2208 s, sorry = edist x y"}, {"line": "have A : Continuous fun y => edist x y := continuous_const.edist continuous_id", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\nx\u271d : Sort u_2\ninfEdist : x\u271d\nhs : IsCompact s\nhne : s.Nonempty\nx : \u03b1\nA : sorry\n\u22a2 \u2203 y \u2208 s, sorry = edist x y"}, {"line": "obtain \u27e8y, ys, hy\u27e9 := hs.exists_isMinOn hne A.continuousOn", "tactic_state": "case none\n\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\nx\u271d : Sort u_2\ninfEdist : x\u271d\nhs : IsCompact s\nhne : s.Nonempty\nx : \u03b1\nA : sorry\n\u22a2 \u2203 y \u2208 s, none = edist x y\n---\ncase some\n\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\nx\u271d : Sort u_2\ninfEdist : x\u271d\nhs : IsCompact s\nhne : s.Nonempty\nx : \u03b1\nA : sorry\nval\u271d : NNReal\n\u22a2 \u2203 y \u2208 s, some val\u271d = edist x y"}, {"line": "exact \u27e8y, ys, le_antisymm (infEdist_le_edist_of_mem ys) (by rwa [le_infEdist])\u27e9", "tactic_state": "case some\n\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\nx\u271d : Sort u_2\ninfEdist : x\u271d\nhs : IsCompact s\nhne : s.Nonempty\nx : \u03b1\nA : sorry\nval\u271d : NNReal\n\u22a2 \u2203 y \u2208 s, some val\u271d = edist x y"}]}
{"declaration": "theorem hausdorffEdist_closure\u2082 : hausdorffEdist s (closure t) = hausdorffEdist s t := by\n  simp [@hausdorffEdist_comm _ _ s _]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nhausdorffEdist : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [@hausdorffEdist_comm _ _ s _]", "tactic_state": "x\u271d : Sort u_2\nhausdorffEdist : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem hausdorffEdist_closure : hausdorffEdist (closure s) (closure t) = hausdorffEdist s t := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nhausdorffEdist : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_2\nhausdorffEdist : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem infDist_empty : infDist x \u2205 = 0 := by simp [infDist]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\ninfDist : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [infDist]", "tactic_state": "x\u271d : Sort u_2\ninfDist : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem infEdist_eq_top_iff : infEdist x s = \u221e \u2194 s = \u2205 := by\n  rcases s.eq_empty_or_nonempty with rfl | hs <;> simp [*, Nonempty.ne_empty, infEdist_ne_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx : \u03b1\n\u22a2 infEdist x s = \u22a4 \u2194 s = \u2205"}, {"line": "rcases s.eq_empty_or_nonempty with rfl | hs <;> simp [*, Nonempty.ne_empty, infEdist_ne_top]", "tactic_state": "case inr\n\u03b1 : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx : \u03b1\nhs : s.Nonempty\n\u22a2 \u00acinfEdist x s = \u22a4"}]}
{"declaration": "theorem infDist_zero_of_mem (h : x \u2208 s) : infDist x s = 0 := by\n  simp [infEdist_zero_of_mem h, infDist]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx : \u03b1\nx\u271d : Sort u_2\ninfDist : x\u271d\nh : x \u2208 s\n\u22a2 sorry = 0"}, {"line": "simp [infEdist_zero_of_mem h, infDist]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx : \u03b1\nx\u271d : Sort u_2\ninfDist : x\u271d\nh : x \u2208 s\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem infDist_singleton : infDist x {y} = dist x y := by simp [infDist, dist_edist]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\nx\u271d : Sort u_2\ninfDist : x\u271d\n\u22a2 sorry = dist x y"}, {"line": "simp [infDist, dist_edist]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\nx\u271d : Sort u_2\ninfDist : x\u271d\n\u22a2 sorry () = (edist x y).toReal"}]}
{"declaration": "theorem infDist_lt_iff {r : \u211d} (hs : s.Nonempty) : infDist x s < r \u2194 \u2203 y \u2208 s, dist x y < r := by\n  simp [\u2190 not_le, le_infDist hs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx : \u03b1\nx\u271d : Sort u_2\ninfDist : x\u271d\nr : \u211d\nhs : s.Nonempty\n\u22a2 sorry < r \u2194 \u2203 y \u2208 s, dist x y < r"}, {"line": "simp [\u2190 not_le, le_infDist hs]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx : \u03b1\nx\u271d : Sort u_2\ninfDist : x\u271d\nr : \u211d\nhs : s.Nonempty\n\u22a2 \u00acr \u2264 sorry () \u2194 \u2203 y \u2208 s, \u00acr \u2264 dist x y"}]}
{"declaration": "theorem infDist_closure : infDist x (closure s) = infDist x s := by\n  simp [infDist, infEdist_closure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "(s)", "{s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\ninfDist : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [infDist, infEdist_closure]", "tactic_state": "x\u271d : Sort u_2\ninfDist : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem mem_closure_iff_infDist_zero (h : s.Nonempty) : x \u2208 closure s \u2194 infDist x s = 0 := by\n  simp [mem_closure_iff_infEdist_zero, infDist, ENNReal.toReal_eq_zero_iff, infEdist_ne_top h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "(s)", "{s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx : \u03b1\nx\u271d : Sort u_2\ninfDist : x\u271d\nh : s.Nonempty\n\u22a2 x \u2208 closure s \u2194 sorry = 0"}, {"line": "simp [mem_closure_iff_infEdist_zero, infDist, ENNReal.toReal_eq_zero_iff, infEdist_ne_top h]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx : \u03b1\nx\u271d : Sort u_2\ninfDist : x\u271d\nh : s.Nonempty\n\u22a2 x \u2208 closure s \u2194 sorry () = 0"}]}
{"declaration": "theorem _root_.IsClosed.not_mem_iff_infDist_pos (h : IsClosed s) (hs : s.Nonempty) :\n    x \u2209 s \u2194 0 < infDist x s := by\n  simp [h.mem_iff_infDist_zero hs, infDist_nonneg.gt_iff_ne]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "(s)", "{s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx : \u03b1\nx\u271d : Sort u_2\ninfDist : x\u271d\nh : IsClosed s\nhs : s.Nonempty\n\u22a2 x \u2209 s \u2194 0 < sorry"}, {"line": "simp [h.mem_iff_infDist_zero hs, infDist_nonneg.gt_iff_ne]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx : \u03b1\nx\u271d : Sort u_2\ninfDist : x\u271d\nh : IsClosed s\nhs : s.Nonempty\n\u22a2 x \u2209 s \u2194 0 < sorry ()"}]}
{"declaration": "theorem exists_mem_closure_infDist_eq_dist [ProperSpace \u03b1] (hne : s.Nonempty) (x : \u03b1) :\n    \u2203 y \u2208 closure s, infDist x s = dist x y := by\n  simpa only [infDist_closure] using isClosed_closure.exists_infDist_eq_dist hne.closure x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "(s)", "{s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b3 inst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx\u271d : Sort u_2\ninfDist : x\u271d\ninst\u271d : ProperSpace \u03b1\nhne : s.Nonempty\nx : \u03b1\n\u22a2 \u2203 y \u2208 closure s, sorry = dist x y"}, {"line": "simpa only [infDist_closure] using isClosed_closure.exists_infDist_eq_dist hne.closure x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hausdorffDist_nonneg : 0 \u2264 hausdorffDist s t := by simp [hausdorffDist]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "(s)", "{s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nhausdorffDist : x\u271d\n\u22a2 0 \u2264 sorry"}, {"line": "simp [hausdorffDist]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hausdorffDist_self_zero : hausdorffDist s s = 0 := by simp [hausdorffDist]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "(s)", "{s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nhausdorffDist : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [hausdorffDist]", "tactic_state": "x\u271d : Sort u_2\nhausdorffDist : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem hausdorffDist_comm : hausdorffDist s t = hausdorffDist t s := by\n  simp [hausdorffDist, hausdorffEdist_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "(s)", "{s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nhausdorffDist : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [hausdorffDist, hausdorffEdist_comm]", "tactic_state": "x\u271d : Sort u_2\nhausdorffDist : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem hausdorffDist_empty : hausdorffDist s \u2205 = 0 := by\n  rcases s.eq_empty_or_nonempty with h | h\n  \u00b7 simp [h]\n  \u00b7 simp [hausdorffDist, hausdorffEdist_empty h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "(s)", "{s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nhausdorffDist : x\u271d\n\u22a2 sorry = 0"}, {"line": "rcases s.eq_empty_or_nonempty with h | h", "tactic_state": "case zero\nx\u271d : Sort u_2\nhausdorffDist : x\u271d\n\u22a2 0 = 0\n---\ncase succ\nx\u271d : Sort u_2\nhausdorffDist : x\u271d\nh : \u2115\n\u22a2 h + 1 = 0"}, {"line": "\u00b7 simp [h]", "tactic_state": "case succ\nx\u271d : Sort u_2\nhausdorffDist : x\u271d\nh : \u2115\n\u22a2 h + 1 = 0"}, {"line": "\u00b7 simp [hausdorffDist, hausdorffEdist_empty h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hausdorffDist_empty' : hausdorffDist \u2205 s = 0 := by simp [hausdorffDist_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "(s)", "{s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nhausdorffDist : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [hausdorffDist_comm]", "tactic_state": "x\u271d : Sort u_2\nhausdorffDist : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem hausdorffDist_self_closure : hausdorffDist s (closure s) = 0 := by simp [hausdorffDist]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "(s)", "{s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nhausdorffDist : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [hausdorffDist]", "tactic_state": "x\u271d : Sort u_2\nhausdorffDist : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem hausdorffDist_closure\u2081 : hausdorffDist (closure s) t = hausdorffDist s t := by\n  simp [hausdorffDist]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "(s)", "{s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nhausdorffDist : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [hausdorffDist]", "tactic_state": "x\u271d : Sort u_2\nhausdorffDist : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem hausdorffDist_closure\u2082 : hausdorffDist s (closure t) = hausdorffDist s t := by\n  simp [hausdorffDist]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "(s)", "{s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nhausdorffDist : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [hausdorffDist]", "tactic_state": "x\u271d : Sort u_2\nhausdorffDist : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem hausdorffDist_closure : hausdorffDist (closure s) (closure t) = hausdorffDist s t := by\n  simp [hausdorffDist]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "(s)", "{s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nhausdorffDist : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [hausdorffDist]", "tactic_state": "x\u271d : Sort u_2\nhausdorffDist : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem hausdorffDist_zero_iff_closure_eq_closure (fin : hausdorffEdist s t \u2260 \u22a4) :\n    hausdorffDist s t = 0 \u2194 closure s = closure t := by\n  simp [\u2190 hausdorffEdist_zero_iff_closure_eq_closure, hausdorffDist,\n    ENNReal.toReal_eq_zero_iff, fin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "(s)", "{s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\ns t : Set \u03b1\nx\u271d : Sort u_2\nhausdorffDist : x\u271d\nfin : hausdorffEdist s t \u2260 \u22a4\n\u22a2 sorry = 0 \u2194 closure s = closure t"}, {"line": "simp [\u2190 hausdorffEdist_zero_iff_closure_eq_closure, hausdorffDist,\n    ENNReal.toReal_eq_zero_iff, fin]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\ns t : Set \u03b1\nx\u271d : Sort u_2\nhausdorffDist : x\u271d\nfin : hausdorffEdist s t \u2260 \u22a4\n\u22a2 sorry () = 0 \u2194 closure s = closure t"}]}
{"declaration": "theorem _root_.IsClosed.hausdorffDist_zero_iff_eq (hs : IsClosed s) (ht : IsClosed t)\n    (fin : hausdorffEdist s t \u2260 \u22a4) : hausdorffDist s t = 0 \u2194 s = t := by\n  simp [\u2190 hausdorffEdist_zero_iff_eq_of_closed hs ht, hausdorffDist, ENNReal.toReal_eq_zero_iff,\n    fin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Pointwise Bornology", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x : \u03b1} {s t u : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}", "(s)", "{s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\ns t : Set \u03b1\nx\u271d : Sort u_2\nhausdorffDist : x\u271d\nhs : IsClosed s\nht : IsClosed t\nfin : hausdorffEdist s t \u2260 \u22a4\n\u22a2 sorry = 0 \u2194 s = t"}, {"line": "simp [\u2190 hausdorffEdist_zero_iff_eq_of_closed hs ht, hausdorffDist, ENNReal.toReal_eq_zero_iff,\n    fin]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\ns t : Set \u03b1\nx\u271d : Sort u_2\nhausdorffDist : x\u271d\nhs : IsClosed s\nht : IsClosed t\nfin : hausdorffEdist s t \u2260 \u22a4\n\u22a2 sorry () = 0 \u2194 s = t"}]}
{"declaration": "theorem holderOnWith_singleton (C r : \u211d\u22650) (f : X \u2192 Y) (x : X) : HolderOnWith C r f {x} := by\n  rintro a (rfl : a = x) b (rfl : b = a)\n  rw [edist_self]\n  exact zero_le _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Holder.lean", "context": {"open": ["Filter Set", "NNReal ENNReal Topology"], "variables": ["{X Y Z : Type*}", "[PseudoEMetricSpace X] [PseudoEMetricSpace Y] [PseudoEMetricSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nC r : NNReal\nf : X \u2192 Y\nx : X\n\u22a2 HolderOnWith C r f {x}"}, {"line": "rintro a (rfl : a = x) b (rfl : b = a)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nC r : NNReal\nf : X \u2192 Y\nb : X\n\u22a2 edist (f b) (f b) \u2264 \u2191C * edist b b ^ \u2191r"}, {"line": "rw [edist_self]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nC r : NNReal\nf : X \u2192 Y\nb : X\n\u22a2 0 \u2264 \u2191C * edist b b ^ \u2191r"}, {"line": "exact zero_le _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem holderOnWith_univ {C r : \u211d\u22650} {f : X \u2192 Y} : HolderOnWith C r f univ \u2194 HolderWith C r f := by\n  simp only [HolderOnWith]\n  simp only [HolderWith]\n  simp only [mem_univ]\n  simp only [true_imp_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Holder.lean", "context": {"open": ["Filter Set", "NNReal ENNReal Topology"], "variables": ["{X Y Z : Type*}", "[PseudoEMetricSpace X] [PseudoEMetricSpace Y] [PseudoEMetricSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nC r : NNReal\nf : X \u2192 Y\n\u22a2 HolderOnWith C r f univ \u2194 HolderWith C r f"}, {"line": "simp only [HolderOnWith]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nC r : NNReal\nf : X \u2192 Y\n\u22a2 (\u2200 x \u2208 univ, \u2200 y \u2208 univ, edist (f x) (f y) \u2264 \u2191C * edist x y ^ \u2191r) \u2194 HolderWith C r f"}, {"line": "simp only [HolderWith]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nC r : NNReal\nf : X \u2192 Y\n\u22a2 (\u2200 x \u2208 univ, \u2200 y \u2208 univ, edist (f x) (f y) \u2264 \u2191C * edist x y ^ \u2191r) \u2194\n    \u2200 (x y : X), edist (f x) (f y) \u2264 \u2191C * edist x y ^ \u2191r"}, {"line": "simp only [mem_univ]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nC r : NNReal\nf : X \u2192 Y\n\u22a2 (\u2200 (x : X), True \u2192 \u2200 (y : X), True \u2192 edist (f x) (f y) \u2264 \u2191C * edist x y ^ \u2191r) \u2194\n    \u2200 (x y : X), edist (f x) (f y) \u2264 \u2191C * edist x y ^ \u2191r"}, {"line": "simp only [true_imp_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem holderOnWith_one {C : \u211d\u22650} {f : X \u2192 Y} {s : Set X} :\n    HolderOnWith C 1 f s \u2194 LipschitzOnWith C f s := by\n  simp only [HolderOnWith]\n  simp only [LipschitzOnWith]\n  simp only [NNReal.coe_one]\n  simp only [ENNReal.rpow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Holder.lean", "context": {"open": ["Filter Set", "NNReal ENNReal Topology"], "variables": ["{X Y Z : Type*}", "[PseudoEMetricSpace X] [PseudoEMetricSpace Y] [PseudoEMetricSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nC : NNReal\nf : X \u2192 Y\ns : Set X\n\u22a2 HolderOnWith C 1 f s \u2194 LipschitzOnWith C f s"}, {"line": "simp only [HolderOnWith]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nC : NNReal\nf : X \u2192 Y\ns : Set X\n\u22a2 (\u2200 x \u2208 s, \u2200 y \u2208 s, edist (f x) (f y) \u2264 \u2191C * edist x y ^ \u21911) \u2194 LipschitzOnWith C f s"}, {"line": "simp only [LipschitzOnWith]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nC : NNReal\nf : X \u2192 Y\ns : Set X\n\u22a2 (\u2200 x \u2208 s, \u2200 y \u2208 s, edist (f x) (f y) \u2264 \u2191C * edist x y ^ \u21911) \u2194\n    \u2200 \u2983x : X\u2984, x \u2208 s \u2192 \u2200 \u2983y : X\u2984, y \u2208 s \u2192 edist (f x) (f y) \u2264 \u2191C * edist x y"}, {"line": "simp only [NNReal.coe_one]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nC : NNReal\nf : X \u2192 Y\ns : Set X\n\u22a2 (\u2200 x \u2208 s, \u2200 y \u2208 s, edist (f x) (f y) \u2264 \u2191C * edist x y ^ 1) \u2194\n    \u2200 \u2983x : X\u2984, x \u2208 s \u2192 \u2200 \u2983y : X\u2984, y \u2208 s \u2192 edist (f x) (f y) \u2264 \u2191C * edist x y"}, {"line": "simp only [ENNReal.rpow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem restrict_iff {s : Set X} : HolderWith C r (s.restrict f) \u2194 HolderOnWith C r f s := by\n  simp [HolderWith, HolderOnWith]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Holder.lean", "context": {"open": ["Filter Set", "NNReal ENNReal Topology"], "variables": ["{X Y Z : Type*}", "[PseudoEMetricSpace X] [PseudoEMetricSpace Y] [PseudoEMetricSpace Z]", "{C r : \u211d\u22650} {f : X \u2192 Y} {s t : Set X}", "{C r : \u211d\u22650} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nC r : NNReal\nf : X \u2192 Y\ns : Set X\n\u22a2 HolderWith C r (s.restrict f) \u2194 HolderOnWith C r f s"}, {"line": "simp [HolderWith, HolderOnWith]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eHolderNorm_ne_top : eHolderNorm r f \u2260 \u221e \u2194 MemHolder r f := by\n  rw [\u2190 eHolderNorm_lt_top]\n  rw [lt_top_iff_ne_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HolderNorm.lean", "context": {"open": ["Filter Set", "NNReal ENNReal Topology"], "variables": ["{X Y : Type*}", "[PseudoEMetricSpace X] [PseudoEMetricSpace Y] {r : \u211d\u22650} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nr : NNReal\nf : X \u2192 Y\n\u22a2 eHolderNorm r f \u2260 \u22a4 \u2194 MemHolder r f"}, {"line": "rw [\u2190 eHolderNorm_lt_top]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nr : NNReal\nf : X \u2192 Y\n\u22a2 eHolderNorm r f \u2260 \u22a4 \u2194 eHolderNorm r f < \u22a4"}, {"line": "rw [lt_top_iff_ne_top]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eHolderNorm_const (r : \u211d\u22650) (c : Y) : eHolderNorm r (Function.const X c) = 0 := by\n  rw [eHolderNorm]\n  rw [\u2190 ENNReal.bot_eq_zero]\n  rw [iInf\u2082_eq_bot]\n  exact fun C' hC' => \u27e80, .const, hC'\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HolderNorm.lean", "context": {"open": ["Filter Set", "NNReal ENNReal Topology"], "variables": ["{X Y : Type*}", "[PseudoEMetricSpace X] [PseudoEMetricSpace Y] {r : \u211d\u22650} {f : X \u2192 Y}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nr : NNReal\nc : Y\n\u22a2 eHolderNorm r (Function.const X c) = 0"}, {"line": "rw [eHolderNorm]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nr : NNReal\nc : Y\n\u22a2 \u2a05 C, \u2a05 (_ : HolderWith C r (Function.const X c)), \u2191C = 0"}, {"line": "rw [\u2190 ENNReal.bot_eq_zero]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nr : NNReal\nc : Y\n\u22a2 \u2a05 C, \u2a05 (_ : HolderWith C r (Function.const X c)), \u2191C = \u22a5"}, {"line": "rw [iInf\u2082_eq_bot]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nr : NNReal\nc : Y\n\u22a2 \u2200 b > \u22a5, \u2203 i, \u2203 (_ : HolderWith i r (Function.const X c)), \u2191i < b"}, {"line": "exact fun C' hC' => \u27e80, .const, hC'\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nnHolderNorm_const (r : \u211d\u22650) (c : Y) : nnHolderNorm r (Function.const X c) = 0 := by\n  refine le_antisymm (ENNReal.coe_le_coe.1 <|\n    le_trans coe_nnHolderNorm_le_eHolderNorm ?_) (zero_le _)\n  rw [eHolderNorm_const]\n  rw [ENNReal.coe_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HolderNorm.lean", "context": {"open": ["Filter Set", "NNReal ENNReal Topology"], "variables": ["{X Y : Type*}", "[PseudoEMetricSpace X] [PseudoEMetricSpace Y] {r : \u211d\u22650} {f : X \u2192 Y}", "(X) in", "(X) in", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nr : NNReal\nc : Y\n\u22a2 nnHolderNorm r (Function.const X c) = 0"}, {"line": "refine le_antisymm (ENNReal.coe_le_coe.1 <|\n    le_trans coe_nnHolderNorm_le_eHolderNorm ?_) (zero_le _)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nr : NNReal\nc : Y\n\u22a2 eHolderNorm r (Function.const X c) \u2264 \u21910"}, {"line": "rw [eHolderNorm_const]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nr : NNReal\nc : Y\n\u22a2 0 \u2264 \u21910"}, {"line": "rw [ENNReal.coe_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eHolderNorm_of_isEmpty [hX : IsEmpty X] :\n    eHolderNorm r f = 0 := by\n  rw [eHolderNorm]\n  rw [\u2190 ENNReal.bot_eq_zero]\n  rw [iInf\u2082_eq_bot]\n  exact fun \u03b5 h\u03b5 => \u27e80, .of_isEmpty, h\u03b5\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HolderNorm.lean", "context": {"open": ["Filter Set", "NNReal ENNReal Topology"], "variables": ["{X Y : Type*}", "[PseudoEMetricSpace X] [PseudoEMetricSpace Y] {r : \u211d\u22650} {f : X \u2192 Y}", "(X) in", "(X) in", "(X) in", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nr : NNReal\nf : X \u2192 Y\nhX : IsEmpty X\n\u22a2 eHolderNorm r f = 0"}, {"line": "rw [eHolderNorm]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nr : NNReal\nf : X \u2192 Y\nhX : IsEmpty X\n\u22a2 \u2a05 C, \u2a05 (_ : HolderWith C r f), \u2191C = 0"}, {"line": "rw [\u2190 ENNReal.bot_eq_zero]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nr : NNReal\nf : X \u2192 Y\nhX : IsEmpty X\n\u22a2 \u2a05 C, \u2a05 (_ : HolderWith C r f), \u2191C = \u22a5"}, {"line": "rw [iInf\u2082_eq_bot]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nr : NNReal\nf : X \u2192 Y\nhX : IsEmpty X\n\u22a2 \u2200 b > \u22a5, \u2203 i, \u2203 (_ : HolderWith i r f), \u2191i < b"}, {"line": "exact fun \u03b5 h\u03b5 => \u27e80, .of_isEmpty, h\u03b5\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eHolderNorm_nsmul [Module \u211d Y] [IsBoundedSMul \u211d Y] (n : \u2115) :\n    eHolderNorm r (n \u2022 f) = n \u2022 eHolderNorm r f := by\n  simp [\u2190 Nat.cast_smul_eq_nsmul (R := \u211d), eHolderNorm_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HolderNorm.lean", "context": {"open": ["Filter Set", "NNReal ENNReal Topology"], "variables": ["{X Y : Type*}", "[PseudoEMetricSpace X] [PseudoEMetricSpace Y] {r : \u211d\u22650} {f : X \u2192 Y}", "(X) in", "(X) in", "(X) in", "(X) in", "[MetricSpace X] [EMetricSpace Y]", "[MetricSpace X] [NormedAddCommGroup Y]", "{r : \u211d\u22650} {f g : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u2075 : PseudoEMetricSpace X\ninst\u271d\u2074 : PseudoEMetricSpace Y\ninst\u271d\u00b3 : MetricSpace X\ninst\u271d\u00b2 : NormedAddCommGroup Y\nr : NNReal\nf : X \u2192 Y\ninst\u271d\u00b9 : Module \u211d Y\ninst\u271d : IsBoundedSMul \u211d Y\nn : \u2115\n\u22a2 eHolderNorm r (n \u2022 f) = n \u2022 eHolderNorm r f"}, {"line": "simp [\u2190 Nat.cast_smul_eq_nsmul (R := \u211d), eHolderNorm_smul]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u2075 : PseudoEMetricSpace X\ninst\u271d\u2074 : PseudoEMetricSpace Y\ninst\u271d\u00b3 : MetricSpace X\ninst\u271d\u00b2 : NormedAddCommGroup Y\nr : NNReal\nf : X \u2192 Y\ninst\u271d\u00b9 : Module \u211d Y\ninst\u271d : IsBoundedSMul \u211d Y\nn : \u2115\n\u22a2 eHolderNorm r (n \u2022 f) = \u2191n * eHolderNorm r f"}]}
{"declaration": "lemma MemHolder.nnHolderNorm_nsmul [Module \u211d Y] [IsBoundedSMul \u211d Y] (n : \u2115) (hf : MemHolder r f) :\n    nnHolderNorm r (n \u2022 f) = n \u2022 nnHolderNorm r f := by\n  simp [\u2190 Nat.cast_smul_eq_nsmul (R := \u211d), hf.nnHolderNorm_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/HolderNorm.lean", "context": {"open": ["Filter Set", "NNReal ENNReal Topology"], "variables": ["{X Y : Type*}", "[PseudoEMetricSpace X] [PseudoEMetricSpace Y] {r : \u211d\u22650} {f : X \u2192 Y}", "(X) in", "(X) in", "(X) in", "(X) in", "[MetricSpace X] [EMetricSpace Y]", "[MetricSpace X] [NormedAddCommGroup Y]", "{r : \u211d\u22650} {f g : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u2075 : PseudoEMetricSpace X\ninst\u271d\u2074 : PseudoEMetricSpace Y\ninst\u271d\u00b3 : MetricSpace X\ninst\u271d\u00b2 : NormedAddCommGroup Y\nr : NNReal\nf : X \u2192 Y\ninst\u271d\u00b9 : Module \u211d Y\ninst\u271d : IsBoundedSMul \u211d Y\nn : \u2115\nhf : MemHolder r f\n\u22a2 nnHolderNorm r (n \u2022 f) = n \u2022 nnHolderNorm r f"}, {"line": "simp [\u2190 Nat.cast_smul_eq_nsmul (R := \u211d), hf.nnHolderNorm_smul]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u2075 : PseudoEMetricSpace X\ninst\u271d\u2074 : PseudoEMetricSpace Y\ninst\u271d\u00b3 : MetricSpace X\ninst\u271d\u00b2 : NormedAddCommGroup Y\nr : NNReal\nf : X \u2192 Y\ninst\u271d\u00b9 : Module \u211d Y\ninst\u271d : IsBoundedSMul \u211d Y\nn : \u2115\nhf : MemHolder r f\n\u22a2 nnHolderNorm r (n \u2022 f) = \u2191n * nnHolderNorm r f"}]}
{"declaration": "theorem isometry_iff_nndist_eq [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    Isometry f \u2194 \u2200 x y, nndist (f x) (f y) = nndist x y := by\n  simp only [Isometry]\n  simp only [edist_nndist]\n  simp only [ENNReal.coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Isometry.lean", "context": {"open": ["Topology", "Function Set", "scoped Topology ENNReal"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Isometry f \u2194 \u2200 (x y : \u03b1), nndist (f x) (f y) = nndist x y"}, {"line": "simp only [Isometry]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (x1 x2 : \u03b1), edist (f x1) (f x2) = edist x1 x2) \u2194 \u2200 (x y : \u03b1), nndist (f x) (f y) = nndist x y"}, {"line": "simp only [edist_nndist]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (x1 x2 : \u03b1), \u2191(nndist (f x1) (f x2)) = \u2191(nndist x1 x2)) \u2194 \u2200 (x y : \u03b1), nndist (f x) (f y) = nndist x y"}, {"line": "simp only [ENNReal.coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isometry_iff_dist_eq [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    Isometry f \u2194 \u2200 x y, dist (f x) (f y) = dist x y := by\n  simp only [isometry_iff_nndist_eq]\n  simp only [\u2190 coe_nndist]\n  simp only [NNReal.coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Isometry.lean", "context": {"open": ["Topology", "Function Set", "scoped Topology ENNReal"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Isometry f \u2194 \u2200 (x y : \u03b1), dist (f x) (f y) = dist x y"}, {"line": "simp only [isometry_iff_nndist_eq]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (x y : \u03b1), nndist (f x) (f y) = nndist x y) \u2194 \u2200 (x y : \u03b1), dist (f x) (f y) = dist x y"}, {"line": "simp only [\u2190 coe_nndist]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (x y : \u03b1), nndist (f x) (f y) = nndist x y) \u2194 \u2200 (x y : \u03b1), \u2191(nndist (f x) (f y)) = \u2191(nndist x y)"}, {"line": "simp only [NNReal.coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_emetric_closedBall (h : Isometry f) (x : \u03b1) (r : \u211d\u22650\u221e) :\n    f \u207b\u00b9' EMetric.closedBall (f x) r = EMetric.closedBall x r := by\n  ext y\n  simp [h.edist_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Isometry.lean", "context": {"open": ["Topology", "Function Set", "scoped Topology ENNReal"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] [PseudoEMetricSpace \u03b3]", "{f : \u03b1 \u2192 \u03b2} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Isometry f\nx : \u03b1\nr : ENNReal\n\u22a2 f \u207b\u00b9' EMetric.closedBall (f x) r = EMetric.closedBall x r"}, {"line": "ext y", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Isometry f\nx : \u03b1\nr : ENNReal\ny : \u03b1\n\u22a2 y \u2208 f \u207b\u00b9' EMetric.closedBall (f x) r \u2194 y \u2208 EMetric.closedBall x r"}, {"line": "simp [h.edist_eq]", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Isometry f\nx : \u03b1\nr : ENNReal\ny : \u03b1\n\u22a2 edist (f y) (f x) \u2264 r \u2194 edist y x \u2264 r"}]}
{"declaration": "theorem preimage_emetric_ball (h : Isometry f) (x : \u03b1) (r : \u211d\u22650\u221e) :\n    f \u207b\u00b9' EMetric.ball (f x) r = EMetric.ball x r := by\n  ext y\n  simp [h.edist_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Isometry.lean", "context": {"open": ["Topology", "Function Set", "scoped Topology ENNReal"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] [PseudoEMetricSpace \u03b3]", "{f : \u03b1 \u2192 \u03b2} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Isometry f\nx : \u03b1\nr : ENNReal\n\u22a2 f \u207b\u00b9' EMetric.ball (f x) r = EMetric.ball x r"}, {"line": "ext y", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Isometry f\nx : \u03b1\nr : ENNReal\ny : \u03b1\n\u22a2 y \u2208 f \u207b\u00b9' EMetric.ball (f x) r \u2194 y \u2208 EMetric.ball x r"}, {"line": "simp [h.edist_eq]", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Isometry f\nx : \u03b1\nr : ENNReal\ny : \u03b1\n\u22a2 edist (f y) (f x) < r \u2194 edist y x < r"}]}
{"declaration": "theorem ediam_range (hf : Isometry f) : EMetric.diam (range f) = EMetric.diam (univ : Set \u03b1) := by\n  rw [\u2190 image_univ]\n  exact hf.ediam_image univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Isometry.lean", "context": {"open": ["Topology", "Function Set", "scoped Topology ENNReal"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] [PseudoEMetricSpace \u03b3]", "{f : \u03b1 \u2192 \u03b2} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Isometry f\n\u22a2 EMetric.diam (range f) = EMetric.diam univ"}, {"line": "rw [\u2190 image_univ]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Isometry f\n\u22a2 EMetric.diam (f '' univ) = EMetric.diam univ"}, {"line": "exact hf.ediam_image univ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_setOf_dist (hf : Isometry f) (x : \u03b1) (p : \u211d \u2192 Prop) :\n    f \u207b\u00b9' { y | p (dist y (f x)) } = { y | p (dist y x) } := by\n  ext y\n  simp [hf.dist_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Isometry.lean", "context": {"open": ["Topology", "Function Set", "scoped Topology ENNReal"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] [PseudoEMetricSpace \u03b3]", "{f : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[EMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : PseudoEMetricSpace \u03b1\ninst\u271d\u2074 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b3 : EMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Isometry f\nx : \u03b1\np : \u211d \u2192 Prop\n\u22a2 f \u207b\u00b9' {y | p (dist y (f x))} = {y | p (dist y x)}"}, {"line": "ext y", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : PseudoEMetricSpace \u03b1\ninst\u271d\u2074 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b3 : EMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Isometry f\nx : \u03b1\np : \u211d \u2192 Prop\ny : \u03b1\n\u22a2 y \u2208 f \u207b\u00b9' {y | p (dist y (f x))} \u2194 y \u2208 {y | p (dist y x)}"}, {"line": "simp [hf.dist_eq]", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : PseudoEMetricSpace \u03b1\ninst\u271d\u2074 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b3 : EMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Isometry f\nx : \u03b1\np : \u211d \u2192 Prop\ny : \u03b1\n\u22a2 p (dist (f y) (f x)) \u2194 p (dist y x)"}]}
{"declaration": "theorem _root_.Fin.edist_append_eq_max_edist (m n : \u2115) {x x2 : Fin m \u2192 \u03b1} {y y2 : Fin n \u2192 \u03b1} :\n    edist (Fin.append x y) (Fin.append x2 y2) = max (edist x x2) (edist y y2) := by\n  simp [edist_pi_def, Finset.sup_univ_eq_iSup, \u2190 Equiv.iSup_comp (e := finSumFinEquiv),\n    Prod.edist_eq, iSup_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Isometry.lean", "context": {"open": ["Topology", "Function Set", "scoped Topology ENNReal"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] [PseudoEMetricSpace \u03b3]", "{f : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[EMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] [PseudoEMetricSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 : EMetricSpace \u03b1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b1\nm n : \u2115\nx x2 : Fin m \u2192 \u03b1\ny y2 : Fin n \u2192 \u03b1\n\u22a2 edist (Fin.append x y) (Fin.append x2 y2) = max (edist x x2) (edist y y2)"}, {"line": "simp [edist_pi_def, Finset.sup_univ_eq_iSup, \u2190 Equiv.iSup_comp (e := finSumFinEquiv),\n    Prod.edist_eq, iSup_sum]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Isometry.lipschitzWith_iff {\u03b1 \u03b2 \u03b3 : Type*} [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]\n    [PseudoEMetricSpace \u03b3] {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (K : \u211d\u22650) (h : Isometry g) :\n    LipschitzWith K (g \u2218 f) \u2194 LipschitzWith K f := by\n  simp [LipschitzWith, h.edist_eq]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Isometry.lean", "context": {"open": ["Topology", "Function Set", "scoped Topology ENNReal", "NNReal in"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] [PseudoEMetricSpace \u03b3]", "{f : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[EMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2}", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] [PseudoEMetricSpace \u03b3]", "(\u03b9 \u03b1)", "[PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] (h : \u03b1 \u2243\u1d62 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b2\ninst\u271d : PseudoEMetricSpace \u03b3\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nK : sorry\nh : Isometry g\n\u22a2 LipschitzWith sorry (g \u2218 f) \u2194 LipschitzWith sorry f"}, {"line": "simp [LipschitzWith, h.edist_eq]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b2\ninst\u271d : PseudoEMetricSpace \u03b3\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nK : sorry\nh : Isometry g\n\u22a2 (\u2200 (x y : \u03b1), edist (g (f x)) (g (f y)) \u2264 \u2191(sorry ()) * edist x y) \u2194\n    \u2200 (x y : \u03b1), edist (f x) (f y) \u2264 \u2191(sorry ()) * edist x y"}]}
{"declaration": "theorem exists_isometric_embedding (\u03b1 : Type u) [MetricSpace \u03b1] [SeparableSpace \u03b1] :\n    \u2203 f : \u03b1 \u2192 \u2113^\u221e(\u2115), Isometry f := by\n  rcases (univ : Set \u03b1).eq_empty_or_nonempty with h | h\n  \u00b7 use fun _ => 0; intro x; exact absurd h (Nonempty.ne_empty \u27e8x, mem_univ x\u27e9)\n  \u00b7 -- We construct a map x : \u2115 \u2192 \u03b1 with dense image\n    rcases h with \u27e8basepoint\u27e9\n    haveI : Inhabited \u03b1 := \u27e8basepoint\u27e9\n    have : \u2203 s : Set \u03b1, s.Countable \u2227 Dense s := exists_countable_dense \u03b1\n    rcases this with \u27e8S, \u27e8S_countable, S_dense\u27e9\u27e9\n    rcases Set.countable_iff_exists_subset_range.1 S_countable with \u27e8x, x_range\u27e9\n    -- Use embeddingOfSubset to construct the desired isometry\n    exact \u27e8embeddingOfSubset x, embeddingOfSubset_isometry x (S_dense.mono x_range)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Kuratowski.lean", "context": {"open": ["Set Metric TopologicalSpace NNReal ENNReal lp Function"], "variables": ["{\u03b1 : Type u}", "{n : \u2115} [MetricSpace \u03b1] (x : \u2115 \u2192 \u03b1) (a : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : MetricSpace \u03b1\ninst\u271d : SeparableSpace \u03b1\n\u22a2 \u2203 f, Isometry f"}, {"line": "rcases (univ : Set \u03b1).eq_empty_or_nonempty with h | h", "tactic_state": "case inl\n\u03b1 : Type u\ninst\u271d\u00b9 : MetricSpace \u03b1\ninst\u271d : SeparableSpace \u03b1\nh : univ = \u2205\n\u22a2 \u2203 f, Isometry f\n---\ncase inr\n\u03b1 : Type u\ninst\u271d\u00b9 : MetricSpace \u03b1\ninst\u271d : SeparableSpace \u03b1\nh : univ.Nonempty\n\u22a2 \u2203 f, Isometry f"}, {"line": "\u00b7 use fun _ => 0; intro x; exact absurd h (Nonempty.ne_empty \u27e8x, mem_univ x\u27e9)", "tactic_state": "case inr\n\u03b1 : Type u\ninst\u271d\u00b9 : MetricSpace \u03b1\ninst\u271d : SeparableSpace \u03b1\nh : univ.Nonempty\n\u22a2 \u2203 f, Isometry f"}, {"line": "\u00b7 -- We construct a map x : \u2115 \u2192 \u03b1 with dense image\n    rcases h with \u27e8basepoint\u27e9\n    haveI : Inhabited \u03b1 := \u27e8basepoint\u27e9\n    have : \u2203 s : Set \u03b1, s.Countable \u2227 Dense s := exists_countable_dense \u03b1\n    rcases this with \u27e8S, \u27e8S_countable, S_dense\u27e9\u27e9\n    rcases Set.countable_iff_exists_subset_range.1 S_countable with \u27e8x, x_range\u27e9\n    exact \u27e8embeddingOfSubset x, embeddingOfSubset_isometry x (S_dense.mono x_range)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finite_iUnion_right_iff {\u03b9 : Type*} {I : Set \u03b9} (hI : I.Finite) {s : Set X}\n    {t : \u03b9 \u2192 Set X} : AreSeparated s (\u22c3 i \u2208 I, t i) \u2194 \u2200 i \u2208 I, AreSeparated s (t i) := by\n  simpa only [@comm _ _ s] using finite_iUnion_left_iff hI\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/MetricSeparated.lean", "context": {"open": ["EMetric Set", "scoped ENNReal"], "variables": ["{X : Type*} [PseudoEMetricSpace X] {s t : Set X} {\u03b5 \u03b4 : \u211d\u22650\u221e} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : PseudoEMetricSpace X\nx\u271d : Sort u_3\nAreSeparated : x\u271d\n\u03b9 : Type u_2\nI : Set \u03b9\nhI : I.Finite\ns : Set X\nt : \u03b9 \u2192 Set X\n\u22a2 sorry \u2194 \u2200 i \u2208 I, sorry"}, {"line": "simpa only [@comm _ _ s] using finite_iUnion_left_iff hI", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cylinder_eq_pi (x : \u2200 n, E n) (n : \u2115) :\n    cylinder x n = Set.pi (Finset.range n : Set \u2115) fun i : \u2115 => {x i} := by\n  ext y\n  simp [cylinder]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/PiNat.lean", "context": {"open": ["Topology TopologicalSpace Set Metric Filter Function", "Classical in"], "variables": ["{E : \u2115 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nE : x\u271d\u00b9\nx\u271d : Sort u_2\ncylinder : x\u271d\nx : \u2115 \u2192 sorry\nn : \u2115\n\u22a2 sorry = (\u2191(Finset.range n)).pi fun i => sorry"}, {"line": "ext y", "tactic_state": "case h\nx\u271d\u00b9 : Sort u_1\nE : x\u271d\u00b9\nx\u271d : Sort u_2\ncylinder : x\u271d\nx : \u2115 \u2192 sorry\nn : \u2115\ny : (i : \u2115) \u2192 ?m.1143 x n i\n\u22a2 y \u2208 sorry \u2194 y \u2208 (\u2191(Finset.range n)).pi fun i => sorry"}, {"line": "simp [cylinder]", "tactic_state": "case h\nx\u271d\u00b9 : Sort u_1\nE : x\u271d\u00b9\nx\u271d : Sort u_2\ncylinder : x\u271d\nx : \u2115 \u2192 sorry\nn : \u2115\ny : (i : \u2115) \u2192 ?m.1143 x n i\n\u22a2 y \u2208 sorry () \u2194 \u2200 i < n, y i \u2208 sorry ()"}]}
{"declaration": "theorem cylinder_zero (x : \u2200 n, E n) : cylinder x 0 = univ := by simp [cylinder_eq_pi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/PiNat.lean", "context": {"open": ["Topology TopologicalSpace Set Metric Filter Function", "Classical in"], "variables": ["{E : \u2115 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nE : x\u271d\u00b9\nx\u271d : Sort u_2\ncylinder : x\u271d\nx : ?m.857 \u2192 sorry\n\u22a2 sorry = univ"}, {"line": "simp [cylinder_eq_pi]", "tactic_state": "x\u271d\u00b9 : Sort u_1\nE : x\u271d\u00b9\nx\u271d : Sort u_2\ncylinder : x\u271d\nx : ?m.857 \u2192 sorry\n\u22a2 sorry () = univ"}]}
{"declaration": "theorem res_length (x : \u2115 \u2192 \u03b1) (n : \u2115) : (res x n).length = n := by induction n <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/PiNat.lean", "context": {"open": ["Topology TopologicalSpace Set Metric Filter Function", "Classical in", "List"], "variables": ["{E : \u2115 \u2192 Type*}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nx\u271d : Sort u_3\nres : x\u271d\nx : \u2115 \u2192 \u03b1\nn : \u2115\n\u22a2 sorry = n"}, {"line": "induction n <;> simp [*]", "tactic_state": "case zero\n\u03b1 : Type u_2\nx\u271d : Sort u_3\nres : x\u271d\nx : \u2115 \u2192 \u03b1\n\u22a2 sorry () = 0\n---\ncase succ\n\u03b1 : Type u_2\nx\u271d : Sort u_3\nres : x\u271d\nx : \u2115 \u2192 \u03b1\nn\u271d : \u2115\na\u271d : sorry = n\u271d\n\u22a2 False"}]}
{"declaration": "theorem dist_summable (x y : \u2200 i, F i) :\n    Summable fun i : \u03b9 => min ((1 / 2) ^ encode i : \u211d) (dist (x i) (y i)) := by\n  refine .of_nonneg_of_le (fun i => ?_) (fun i => min_le_left _ _)\n    summable_geometric_two_encode\n  exact le_min (pow_nonneg (by norm_num) _) dist_nonneg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/PiNat.lean", "context": {"open": ["Topology TopologicalSpace Set Metric Filter Function", "Classical in", "List", "Classical in", "Classical in", "PiNat", "Encodable"], "variables": ["{E : \u2115 \u2192 Type*}", "{\u03b1 : Type*}", "(E)", "[\u2200 n, TopologicalSpace (E n)] [\u2200 n, DiscreteTopology (E n)]", "{E}", "{\u03b9 : Type*} [Encodable \u03b9] {F : \u03b9 \u2192 Type*} [\u2200 i, MetricSpace (F i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_3\ninst\u271d\u00b9 : Encodable \u03b9\nF : \u03b9 \u2192 Type u_4\ninst\u271d : (i : \u03b9) \u2192 MetricSpace (F i)\nx y : (i : \u03b9) \u2192 F i\n\u22a2 Summable fun i => min ((1 / 2) ^ encode i) (dist (x i) (y i))"}, {"line": "refine .of_nonneg_of_le (fun i => ?_) (fun i => min_le_left _ _)\n    summable_geometric_two_encode", "tactic_state": "\u03b9 : Type u_3\ninst\u271d\u00b9 : Encodable \u03b9\nF : \u03b9 \u2192 Type u_4\ninst\u271d : (i : \u03b9) \u2192 MetricSpace (F i)\nx y : (i : \u03b9) \u2192 F i\ni : \u03b9\n\u22a2 0 \u2264 min ((1 / 2) ^ encode i) (dist (x i) (y i))"}, {"line": "exact le_min (pow_nonneg (by norm_num) _) dist_nonneg", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem _root_.CompletePseudometrizable.iInf {\u03b9 : Type*} [Countable \u03b9]\n    {t : \u03b9 \u2192 TopologicalSpace \u03b1} (ht\u2080 : \u2203 t\u2080, @T2Space \u03b1 t\u2080 \u2227 \u2200 i, t i \u2264 t\u2080)\n    (ht : \u2200 i, \u2203 u : UniformSpace \u03b1, CompleteSpace \u03b1 \u2227 \ud835\udce4[u].IsCountablyGenerated \u2227\n      u.toTopologicalSpace = t i) :\n    \u2203 u : UniformSpace \u03b1, CompleteSpace \u03b1 \u2227\n      \ud835\udce4[u].IsCountablyGenerated \u2227 u.toTopologicalSpace = \u2a05 i, t i := by\n  choose u hcomp hcount hut using ht\n  obtain rfl : t = fun i \u21a6 (u i).toTopologicalSpace := (funext hut).symm\n  refine \u27e8\u2a05 i, u i, .iInf hcomp ht\u2080, ?_, UniformSpace.toTopologicalSpace_iInf\u27e9\n  rw [iInf_uniformity]\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Polish.lean", "context": {"open": ["Filter Function Metric TopologicalSpace Set Topology", "scoped Uniformity"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d : Countable \u03b9\nt : \u03b9 \u2192 TopologicalSpace \u03b1\nht\u2080 : \u2203 t\u2080, T2Space \u03b1 \u2227 \u2200 (i : \u03b9), t i \u2264 t\u2080\nht : \u2200 (i : \u03b9), \u2203 u, CompleteSpace \u03b1 \u2227 (uniformity \u03b1).IsCountablyGenerated \u2227 UniformSpace.toTopologicalSpace = t i\n\u22a2 \u2203 u, CompleteSpace \u03b1 \u2227 (uniformity \u03b1).IsCountablyGenerated \u2227 UniformSpace.toTopologicalSpace = \u2a05 i, t i"}, {"line": "choose u hcomp hcount hut using ht", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d : Countable \u03b9\nt : \u03b9 \u2192 TopologicalSpace \u03b1\nht\u2080 : \u2203 t\u2080, T2Space \u03b1 \u2227 \u2200 (i : \u03b9), t i \u2264 t\u2080\nu : \u03b9 \u2192 UniformSpace \u03b1\nhcomp : \u2200 (i : \u03b9), CompleteSpace \u03b1\nhcount : \u2200 (i : \u03b9), (uniformity \u03b1).IsCountablyGenerated\nhut : \u2200 (i : \u03b9), UniformSpace.toTopologicalSpace = t i\n\u22a2 \u2203 u, CompleteSpace \u03b1 \u2227 (uniformity \u03b1).IsCountablyGenerated \u2227 UniformSpace.toTopologicalSpace = \u2a05 i, t i"}, {"line": "obtain rfl : t = fun i \u21a6 (u i).toTopologicalSpace := (funext hut).symm", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d : Countable \u03b9\nu : \u03b9 \u2192 UniformSpace \u03b1\nhcomp : \u2200 (i : \u03b9), CompleteSpace \u03b1\nhcount : \u2200 (i : \u03b9), (uniformity \u03b1).IsCountablyGenerated\nht\u2080 : \u2203 t\u2080, T2Space \u03b1 \u2227 \u2200 (i : \u03b9), (fun i => UniformSpace.toTopologicalSpace) i \u2264 t\u2080\nhut : \u2200 (i : \u03b9), UniformSpace.toTopologicalSpace = (fun i => UniformSpace.toTopologicalSpace) i\n\u22a2 \u2203 u_1,\n    CompleteSpace \u03b1 \u2227\n      (uniformity \u03b1).IsCountablyGenerated \u2227\n        UniformSpace.toTopologicalSpace = \u2a05 i, (fun i => UniformSpace.toTopologicalSpace) i"}, {"line": "refine \u27e8\u2a05 i, u i, .iInf hcomp ht\u2080, ?_, UniformSpace.toTopologicalSpace_iInf\u27e9", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d : Countable \u03b9\nu : \u03b9 \u2192 UniformSpace \u03b1\nhcomp : \u2200 (i : \u03b9), CompleteSpace \u03b1\nhcount : \u2200 (i : \u03b9), (uniformity \u03b1).IsCountablyGenerated\nht\u2080 : \u2203 t\u2080, T2Space \u03b1 \u2227 \u2200 (i : \u03b9), (fun i => UniformSpace.toTopologicalSpace) i \u2264 t\u2080\nhut : \u2200 (i : \u03b9), UniformSpace.toTopologicalSpace = (fun i => UniformSpace.toTopologicalSpace) i\n\u22a2 (uniformity \u03b1).IsCountablyGenerated"}, {"line": "rw [iInf_uniformity]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d : Countable \u03b9\nu : \u03b9 \u2192 UniformSpace \u03b1\nhcomp : \u2200 (i : \u03b9), CompleteSpace \u03b1\nhcount : \u2200 (i : \u03b9), (uniformity \u03b1).IsCountablyGenerated\nht\u2080 : \u2203 t\u2080, T2Space \u03b1 \u2227 \u2200 (i : \u03b9), (fun i => UniformSpace.toTopologicalSpace) i \u2264 t\u2080\nhut : \u2200 (i : \u03b9), UniformSpace.toTopologicalSpace = (fun i => UniformSpace.toTopologicalSpace) i\n\u22a2 (\u2a05 i, uniformity \u03b1).IsCountablyGenerated"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.IsOpen.isClopenable [TopologicalSpace \u03b1] [PolishSpace \u03b1] {s : Set \u03b1}\n    (hs : IsOpen s) : IsClopenable s := by\n  simpa using hs.isClosed_compl.isClopenable.compl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Polish.lean", "context": {"open": ["Filter Function Metric TopologicalSpace Set Topology", "scoped Uniformity"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "[MetricSpace \u03b1] {s : Opens \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : MetricSpace \u03b1\nx\u271d : Sort u_3\nIsClopenable : x\u271d\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : PolishSpace \u03b1\ns : Set \u03b1\nhs : IsOpen s\n\u22a2 sorry"}, {"line": "simpa using hs.isClosed_compl.isClopenable.compl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma similar_iff_exists_pairwise_edist_eq :\n    Similar v\u2081 v\u2082 \u2194 (\u2203 r : \u211d\u22650, r \u2260 0 \u2227 Pairwise fun i\u2081 i\u2082 \u21a6 (edist (v\u2081 i\u2081) (v\u2081 i\u2082) =\n      r * edist (v\u2082 i\u2081) (v\u2082 i\u2082))) := by\n  rw [similar_iff_exists_edist_eq]\n  refine \u27e8?_, ?_\u27e9 <;> rintro \u27e8r, hr, h\u27e9 <;> refine \u27e8r, hr, fun i\u2081 i\u2082 \u21a6 ?_\u27e9\n  \u00b7 exact fun _ \u21a6 h i\u2081 i\u2082\n  \u00b7 by_cases hi : i\u2081 = i\u2082\n    \u00b7 simp [hi]\n    \u00b7 exact h hi\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Similarity.lean", "context": {"open": ["scoped NNReal"], "variables": ["{\u03b9 \u03b9' : Type*} {P\u2081 P\u2082 P\u2083 : Type*} {v\u2081 : \u03b9 \u2192 P\u2081} {v\u2082 : \u03b9 \u2192 P\u2082} {v\u2083 : \u03b9 \u2192 P\u2083}", "[PseudoEMetricSpace P\u2081] [PseudoEMetricSpace P\u2082] [PseudoEMetricSpace P\u2083]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nP\u2081 : Type u_3\nP\u2082 : Type u_4\nv\u2081 : \u03b9 \u2192 P\u2081\nv\u2082 : \u03b9 \u2192 P\u2082\ninst\u271d\u00b9 : PseudoEMetricSpace P\u2081\ninst\u271d : PseudoEMetricSpace P\u2082\n\u22a2 Similar v\u2081 v\u2082 \u2194 \u2203 r, r \u2260 0 \u2227 Pairwise fun i\u2081 i\u2082 => edist (v\u2081 i\u2081) (v\u2081 i\u2082) = \u2191r * edist (v\u2082 i\u2081) (v\u2082 i\u2082)"}, {"line": "rw [similar_iff_exists_edist_eq]", "tactic_state": "\u03b9 : Type u_1\nP\u2081 : Type u_3\nP\u2082 : Type u_4\nv\u2081 : \u03b9 \u2192 P\u2081\nv\u2082 : \u03b9 \u2192 P\u2082\ninst\u271d\u00b9 : PseudoEMetricSpace P\u2081\ninst\u271d : PseudoEMetricSpace P\u2082\n\u22a2 (\u2203 r, r \u2260 0 \u2227 \u2200 (i\u2081 i\u2082 : \u03b9), edist (v\u2081 i\u2081) (v\u2081 i\u2082) = \u2191r * edist (v\u2082 i\u2081) (v\u2082 i\u2082)) \u2194\n    \u2203 r, r \u2260 0 \u2227 Pairwise fun i\u2081 i\u2082 => edist (v\u2081 i\u2081) (v\u2081 i\u2082) = \u2191r * edist (v\u2082 i\u2081) (v\u2082 i\u2082)"}, {"line": "refine \u27e8?_, ?_\u27e9 <;> rintro \u27e8r, hr, h\u27e9 <;> refine \u27e8r, hr, fun i\u2081 i\u2082 \u21a6 ?_\u27e9", "tactic_state": "case refine_1.intro.intro\n\u03b9 : Type u_1\nP\u2081 : Type u_3\nP\u2082 : Type u_4\nv\u2081 : \u03b9 \u2192 P\u2081\nv\u2082 : \u03b9 \u2192 P\u2082\ninst\u271d\u00b9 : PseudoEMetricSpace P\u2081\ninst\u271d : PseudoEMetricSpace P\u2082\nr : NNReal\nhr : r \u2260 0\nh : \u2200 (i\u2081 i\u2082 : \u03b9), edist (v\u2081 i\u2081) (v\u2081 i\u2082) = \u2191r * edist (v\u2082 i\u2081) (v\u2082 i\u2082)\ni\u2081 i\u2082 : \u03b9\n\u22a2 i\u2081 \u2260 i\u2082 \u2192 (fun i\u2081 i\u2082 => edist (v\u2081 i\u2081) (v\u2081 i\u2082) = \u2191r * edist (v\u2082 i\u2081) (v\u2082 i\u2082)) i\u2081 i\u2082\n---\ncase refine_2.intro.intro\n\u03b9 : Type u_1\nP\u2081 : Type u_3\nP\u2082 : Type u_4\nv\u2081 : \u03b9 \u2192 P\u2081\nv\u2082 : \u03b9 \u2192 P\u2082\ninst\u271d\u00b9 : PseudoEMetricSpace P\u2081\ninst\u271d : PseudoEMetricSpace P\u2082\nr : NNReal\nhr : r \u2260 0\nh : Pairwise fun i\u2081 i\u2082 => edist (v\u2081 i\u2081) (v\u2081 i\u2082) = \u2191r * edist (v\u2082 i\u2081) (v\u2082 i\u2082)\ni\u2081 i\u2082 : \u03b9\n\u22a2 edist (v\u2081 i\u2081) (v\u2081 i\u2082) = \u2191r * edist (v\u2082 i\u2081) (v\u2082 i\u2082)"}, {"line": "\u00b7 exact fun _ \u21a6 h i\u2081 i\u2082", "tactic_state": "case refine_2.intro.intro\n\u03b9 : Type u_1\nP\u2081 : Type u_3\nP\u2082 : Type u_4\nv\u2081 : \u03b9 \u2192 P\u2081\nv\u2082 : \u03b9 \u2192 P\u2082\ninst\u271d\u00b9 : PseudoEMetricSpace P\u2081\ninst\u271d : PseudoEMetricSpace P\u2082\nr : NNReal\nhr : r \u2260 0\nh : Pairwise fun i\u2081 i\u2082 => edist (v\u2081 i\u2081) (v\u2081 i\u2082) = \u2191r * edist (v\u2082 i\u2081) (v\u2082 i\u2082)\ni\u2081 i\u2082 : \u03b9\n\u22a2 edist (v\u2081 i\u2081) (v\u2081 i\u2082) = \u2191r * edist (v\u2082 i\u2081) (v\u2082 i\u2082)"}, {"line": "\u00b7 by_cases hi : i\u2081 = i\u2082\n    \u00b7 simp [hi]\n    \u00b7 exact h hi", "tactic_state": "No Goals!"}]}
{"declaration": "theorem thickenedIndicatorAux_closure_eq (\u03b4 : \u211d) (E : Set \u03b1) :\n    thickenedIndicatorAux \u03b4 (closure E) = thickenedIndicatorAux \u03b4 E := by\n  simp +unfoldPartialApp only [thickenedIndicatorAux, infEdist_closure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/ThickenedIndicator.lean", "context": {"open": ["NNReal ENNReal Topology BoundedContinuousFunction Set Metric EMetric Filter"], "variables": ["{\u03b1 : Type*} [PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\n\u22a2 thickenedIndicatorAux \u03b4 (closure E) = thickenedIndicatorAux \u03b4 E"}, {"line": "simp +unfoldPartialApp only [thickenedIndicatorAux, infEdist_closure]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem thickenedIndicatorAux_one (\u03b4 : \u211d) (E : Set \u03b1) {x : \u03b1} (x_in_E : x \u2208 E) :\n    thickenedIndicatorAux \u03b4 E x = 1 := by\n  simp [thickenedIndicatorAux, infEdist_zero_of_mem x_in_E, tsub_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/ThickenedIndicator.lean", "context": {"open": ["NNReal ENNReal Topology BoundedContinuousFunction Set Metric EMetric Filter"], "variables": ["{\u03b1 : Type*} [PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\nx : \u03b1\nx_in_E : x \u2208 E\n\u22a2 thickenedIndicatorAux \u03b4 E x = 1"}, {"line": "simp [thickenedIndicatorAux, infEdist_zero_of_mem x_in_E, tsub_zero]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\nx : \u03b1\nx_in_E : x \u2208 E\n\u22a2 1 - infEdist x E / ENNReal.ofReal \u03b4 = 1"}]}
{"declaration": "theorem indicator_le_thickenedIndicatorAux (\u03b4 : \u211d) (E : Set \u03b1) :\n    (E.indicator fun _ => (1 : \u211d\u22650\u221e)) \u2264 thickenedIndicatorAux \u03b4 E := by\n  intro a\n  by_cases h : a \u2208 E\n  \u00b7 simp only [h, indicator_of_mem, thickenedIndicatorAux_one \u03b4 E h, le_refl]\n  \u00b7 simp only [h, indicator_of_not_mem, not_false_iff, zero_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/ThickenedIndicator.lean", "context": {"open": ["NNReal ENNReal Topology BoundedContinuousFunction Set Metric EMetric Filter"], "variables": ["{\u03b1 : Type*} [PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\n\u22a2 (E.indicator fun x => 1) \u2264 thickenedIndicatorAux \u03b4 E"}, {"line": "intro a", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\na : \u03b1\n\u22a2 E.indicator (fun x => 1) a \u2264 thickenedIndicatorAux \u03b4 E a"}, {"line": "by_cases h : a \u2208 E", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\na : \u03b1\nh : a \u2208 E\n\u22a2 E.indicator (fun x => 1) a \u2264 thickenedIndicatorAux \u03b4 E a\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\na : \u03b1\nh : a \u2209 E\n\u22a2 E.indicator (fun x => 1) a \u2264 thickenedIndicatorAux \u03b4 E a"}, {"line": "\u00b7 simp only [h, indicator_of_mem, thickenedIndicatorAux_one \u03b4 E h, le_refl]", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\na : \u03b1\nh : a \u2209 E\n\u22a2 E.indicator (fun x => 1) a \u2264 thickenedIndicatorAux \u03b4 E a"}, {"line": "\u00b7 simp only [h, indicator_of_not_mem, not_false_iff, zero_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem thickenedIndicator_le_one {\u03b4 : \u211d} (\u03b4_pos : 0 < \u03b4) (E : Set \u03b1) (x : \u03b1) :\n    thickenedIndicator \u03b4_pos E x \u2264 1 := by\n  rw [thickenedIndicator.coeFn_eq_comp]\n  simpa using (toNNReal_le_toNNReal thickenedIndicatorAux_lt_top.ne one_ne_top).mpr\n    (thickenedIndicatorAux_le_one \u03b4 E x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/ThickenedIndicator.lean", "context": {"open": ["NNReal ENNReal Topology BoundedContinuousFunction Set Metric EMetric Filter"], "variables": ["{\u03b1 : Type*} [PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\n\u03b4_pos : 0 < \u03b4\nE : Set \u03b1\nx : \u03b1\n\u22a2 (thickenedIndicator \u03b4_pos E) x \u2264 1"}, {"line": "rw [thickenedIndicator.coeFn_eq_comp]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\n\u03b4_pos : 0 < \u03b4\nE : Set \u03b1\nx : \u03b1\n\u22a2 (ENNReal.toNNReal \u2218 thickenedIndicatorAux \u03b4 E) x \u2264 1"}, {"line": "simpa using (toNNReal_le_toNNReal thickenedIndicatorAux_lt_top.ne one_ne_top).mpr\n    (thickenedIndicatorAux_le_one \u03b4 E x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem indicator_le_thickenedIndicator {\u03b4 : \u211d} (\u03b4_pos : 0 < \u03b4) (E : Set \u03b1) :\n    (E.indicator fun _ => (1 : \u211d\u22650)) \u2264 thickenedIndicator \u03b4_pos E := by\n  intro a\n  by_cases h : a \u2208 E\n  \u00b7 simp only [h, indicator_of_mem, thickenedIndicator_one \u03b4_pos E h, le_refl]\n  \u00b7 simp only [h, indicator_of_not_mem, not_false_iff, zero_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/ThickenedIndicator.lean", "context": {"open": ["NNReal ENNReal Topology BoundedContinuousFunction Set Metric EMetric Filter"], "variables": ["{\u03b1 : Type*} [PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\n\u03b4_pos : 0 < \u03b4\nE : Set \u03b1\n\u22a2 (E.indicator fun x => 1) \u2264 \u21d1(thickenedIndicator \u03b4_pos E)"}, {"line": "intro a", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\n\u03b4_pos : 0 < \u03b4\nE : Set \u03b1\na : \u03b1\n\u22a2 E.indicator (fun x => 1) a \u2264 (thickenedIndicator \u03b4_pos E) a"}, {"line": "by_cases h : a \u2208 E", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\n\u03b4_pos : 0 < \u03b4\nE : Set \u03b1\na : \u03b1\nh : a \u2208 E\n\u22a2 E.indicator (fun x => 1) a \u2264 (thickenedIndicator \u03b4_pos E) a\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\n\u03b4_pos : 0 < \u03b4\nE : Set \u03b1\na : \u03b1\nh : a \u2209 E\n\u22a2 E.indicator (fun x => 1) a \u2264 (thickenedIndicator \u03b4_pos E) a"}, {"line": "\u00b7 simp only [h, indicator_of_mem, thickenedIndicator_one \u03b4_pos E h, le_refl]", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\n\u03b4_pos : 0 < \u03b4\nE : Set \u03b1\na : \u03b1\nh : a \u2209 E\n\u22a2 E.indicator (fun x => 1) a \u2264 (thickenedIndicator \u03b4_pos E) a"}, {"line": "\u00b7 simp only [h, indicator_of_not_mem, not_false_iff, zero_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem thickenedIndicator_mono {\u03b4\u2081 \u03b4\u2082 : \u211d} (\u03b4\u2081_pos : 0 < \u03b4\u2081) (\u03b4\u2082_pos : 0 < \u03b4\u2082) (hle : \u03b4\u2081 \u2264 \u03b4\u2082)\n    (E : Set \u03b1) : \u21d1(thickenedIndicator \u03b4\u2081_pos E) \u2264 thickenedIndicator \u03b4\u2082_pos E := by\n  intro x\n  apply (toNNReal_le_toNNReal thickenedIndicatorAux_lt_top.ne thickenedIndicatorAux_lt_top.ne).mpr\n  apply thickenedIndicatorAux_mono hle\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/ThickenedIndicator.lean", "context": {"open": ["NNReal ENNReal Topology BoundedContinuousFunction Set Metric EMetric Filter"], "variables": ["{\u03b1 : Type*} [PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4\u2081 \u03b4\u2082 : \u211d\n\u03b4\u2081_pos : 0 < \u03b4\u2081\n\u03b4\u2082_pos : 0 < \u03b4\u2082\nhle : \u03b4\u2081 \u2264 \u03b4\u2082\nE : Set \u03b1\n\u22a2 \u21d1(thickenedIndicator \u03b4\u2081_pos E) \u2264 \u21d1(thickenedIndicator \u03b4\u2082_pos E)"}, {"line": "intro x", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4\u2081 \u03b4\u2082 : \u211d\n\u03b4\u2081_pos : 0 < \u03b4\u2081\n\u03b4\u2082_pos : 0 < \u03b4\u2082\nhle : \u03b4\u2081 \u2264 \u03b4\u2082\nE : Set \u03b1\nx : \u03b1\n\u22a2 (thickenedIndicator \u03b4\u2081_pos E) x \u2264 (thickenedIndicator \u03b4\u2082_pos E) x"}, {"line": "apply (toNNReal_le_toNNReal thickenedIndicatorAux_lt_top.ne thickenedIndicatorAux_lt_top.ne).mpr", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4\u2081 \u03b4\u2082 : \u211d\n\u03b4\u2081_pos : 0 < \u03b4\u2081\n\u03b4\u2082_pos : 0 < \u03b4\u2082\nhle : \u03b4\u2081 \u2264 \u03b4\u2082\nE : Set \u03b1\nx : \u03b1\n\u22a2 thickenedIndicatorAux \u03b4\u2081 E x \u2264 thickenedIndicatorAux \u03b4\u2082 E x"}, {"line": "apply thickenedIndicatorAux_mono hle", "tactic_state": "No Goals!"}]}
{"declaration": "lemma thickening_compl_thickening_self_subset_compl (\u03b4 : \u211d) (E : Set \u03b1) :\n    thickening \u03b4 (thickening \u03b4 E)\u1d9c \u2286 E\u1d9c := by\n  apply compl_subset_compl.mp\n  simpa only [compl_compl] using subset_compl_thickening_compl_thickening_self \u03b4 E\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Thickening.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Bornology", "EMetric", "scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u}", "[PseudoEMetricSpace \u03b1] {\u03b4 : \u211d} {s : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : PseudoEMetricSpace \u03b1\nx\u271d : Sort u_1\nthickening : x\u271d\n\u03b4 : \u211d\nE : Set \u03b1\n\u22a2 sorry \u2286 E\u1d9c"}, {"line": "apply compl_subset_compl.mp", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : PseudoEMetricSpace \u03b1\nx\u271d : Sort u_1\nthickening : x\u271d\n\u03b4 : \u211d\nE : Set \u03b1\n\u22a2 E\u1d9c\u1d9c \u2286 sorry\u1d9c"}, {"line": "simpa only [compl_compl] using subset_compl_thickening_compl_thickening_self \u03b4 E", "tactic_state": "No Goals!"}]}
{"declaration": "theorem thickening_singleton (\u03b4 : \u211d) (x : X) : thickening \u03b4 ({x} : Set X) = ball x \u03b4 := by\n  ext\n  simp [mem_thickening_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Thickening.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Bornology", "EMetric", "scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u}", "[PseudoEMetricSpace \u03b1] {\u03b4 : \u211d} {s : Set \u03b1} {x : \u03b1}", "{X : Type u} [PseudoMetricSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : PseudoMetricSpace X\nx\u271d : Sort u_1\nthickening : x\u271d\n\u03b4 : \u211d\nx : X\n\u22a2 sorry = ball x sorry"}, {"line": "ext", "tactic_state": "case h\nX : Type u\ninst\u271d : PseudoMetricSpace X\nx\u271d\u00b9 : Sort u_1\nthickening : x\u271d\u00b9\n\u03b4 : \u211d\nx x\u271d : X\n\u22a2 x\u271d \u2208 sorry \u2194 x\u271d \u2208 ball x sorry"}, {"line": "simp [mem_thickening_iff]", "tactic_state": "case h\nX : Type u\ninst\u271d : PseudoMetricSpace X\nx\u271d\u00b9 : Sort u_1\nthickening : x\u271d\u00b9\n\u03b4 : \u211d\nx x\u271d : X\n\u22a2 x\u271d \u2208 sorry () \u2194 edist x\u271d x < sorry ()"}]}
{"declaration": "theorem thickening_eq_biUnion_ball {\u03b4 : \u211d} {E : Set X} : thickening \u03b4 E = \u22c3 x \u2208 E, ball x \u03b4 := by\n  ext x\n  simp only [mem_iUnion\u2082]\n  simp only [exists_prop]\n  exact mem_thickening_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Thickening.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Bornology", "EMetric", "scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u}", "[PseudoEMetricSpace \u03b1] {\u03b4 : \u211d} {s : Set \u03b1} {x : \u03b1}", "{X : Type u} [PseudoMetricSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : PseudoMetricSpace X\nx\u271d : Sort u_1\nthickening : x\u271d\n\u03b4 : \u211d\nE : Set X\n\u22a2 sorry = \u22c3 x \u2208 E, ball x sorry"}, {"line": "ext x", "tactic_state": "case h\nX : Type u\ninst\u271d : PseudoMetricSpace X\nx\u271d : Sort u_1\nthickening : x\u271d\n\u03b4 : \u211d\nE : Set X\nx : X\n\u22a2 x \u2208 sorry \u2194 x \u2208 \u22c3 x \u2208 E, ball x sorry"}, {"line": "simp only [mem_iUnion\u2082]", "tactic_state": "case h\nX : Type u\ninst\u271d : PseudoMetricSpace X\nx\u271d : Sort u_1\nthickening : x\u271d\n\u03b4 : \u211d\nE : Set X\nx : X\n\u22a2 x \u2208 sorry \u2194 \u2203 i, \u2203 (_ : i \u2208 E), x \u2208 ball i sorry"}, {"line": "simp only [exists_prop]", "tactic_state": "case h\nX : Type u\ninst\u271d : PseudoMetricSpace X\nx\u271d : Sort u_1\nthickening : x\u271d\n\u03b4 : \u211d\nE : Set X\nx : X\n\u22a2 x \u2208 sorry \u2194 \u2203 i \u2208 E, x \u2208 ball i sorry"}, {"line": "exact mem_thickening_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cthickening_of_nonpos {\u03b4 : \u211d} (h\u03b4 : \u03b4 \u2264 0) (E : Set \u03b1) : cthickening \u03b4 E = closure E := by\n  ext x\n  simp [mem_closure_iff_infEdist_zero, cthickening, ENNReal.ofReal_eq_zero.2 h\u03b4]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Thickening.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Bornology", "EMetric", "scoped Function in -- required for scoped `on` notation", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u}", "[PseudoEMetricSpace \u03b1] {\u03b4 : \u211d} {s : Set \u03b1} {x : \u03b1}", "{X : Type u} [PseudoMetricSpace X]", "[PseudoEMetricSpace \u03b1] {\u03b4 \u03b5 : \u211d} {s t : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 inst\u271d : PseudoEMetricSpace \u03b1\nx\u271d : Sort u_2\ncthickening : x\u271d\n\u03b4 : \u211d\nh\u03b4 : \u03b4 \u2264 0\nE : Set \u03b1\n\u22a2 sorry = closure E"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u\ninst\u271d\u00b9 inst\u271d : PseudoEMetricSpace \u03b1\nx\u271d : Sort u_2\ncthickening : x\u271d\n\u03b4 : \u211d\nh\u03b4 : \u03b4 \u2264 0\nE : Set \u03b1\nx : \u03b1\n\u22a2 x \u2208 sorry \u2194 x \u2208 closure E"}, {"line": "simp [mem_closure_iff_infEdist_zero, cthickening, ENNReal.ofReal_eq_zero.2 h\u03b4]", "tactic_state": "case h\n\u03b1 : Type u\ninst\u271d\u00b9 inst\u271d : PseudoEMetricSpace \u03b1\nx\u271d : Sort u_2\ncthickening : x\u271d\n\u03b4 : \u211d\nh\u03b4 : \u03b4 \u2264 0\nE : Set \u03b1\nx : \u03b1\n\u22a2 x \u2208 sorry () \u2194 infEdist x E = 0"}]}
{"declaration": "theorem cthickening_singleton {\u03b1 : Type*} [PseudoMetricSpace \u03b1] (x : \u03b1) {\u03b4 : \u211d} (h\u03b4 : 0 \u2264 \u03b4) :\n    cthickening \u03b4 ({x} : Set \u03b1) = closedBall x \u03b4 := by\n  ext y\n  simp [cthickening, edist_dist, ENNReal.ofReal_le_ofReal_iff h\u03b4]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Thickening.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Bornology", "EMetric", "scoped Function in -- required for scoped `on` notation", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u}", "[PseudoEMetricSpace \u03b1] {\u03b4 : \u211d} {s : Set \u03b1} {x : \u03b1}", "{X : Type u} [PseudoMetricSpace X]", "[PseudoEMetricSpace \u03b1] {\u03b4 \u03b5 : \u211d} {s t : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\ncthickening : x\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b4 : \u211d\nh\u03b4 : 0 \u2264 \u03b4\n\u22a2 sorry = closedBall x sorry"}, {"line": "ext y", "tactic_state": "case h\nx\u271d : Sort u_3\ncthickening : x\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b4 : \u211d\nh\u03b4 : 0 \u2264 \u03b4\ny : \u03b1\n\u22a2 y \u2208 sorry \u2194 y \u2208 closedBall x sorry"}, {"line": "simp [cthickening, edist_dist, ENNReal.ofReal_le_ofReal_iff h\u03b4]", "tactic_state": "case h\nx\u271d : Sort u_3\ncthickening : x\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b4 : \u211d\nh\u03b4 : 0 \u2264 \u03b4\ny : \u03b1\n\u22a2 y \u2208 sorry () \u2194 ENNReal.ofReal (dist y x) \u2264 sorry ()"}]}
{"declaration": "theorem closedBall_subset_cthickening_singleton {\u03b1 : Type*} [PseudoMetricSpace \u03b1] (x : \u03b1) (\u03b4 : \u211d) :\n    closedBall x \u03b4 \u2286 cthickening \u03b4 ({x} : Set \u03b1) := by\n  rcases lt_or_le \u03b4 0 with (h\u03b4 | h\u03b4)\n  \u00b7 simp only [closedBall_eq_empty.mpr h\u03b4, empty_subset]\n  \u00b7 simp only [cthickening_singleton x h\u03b4, Subset.rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Thickening.lean", "context": {"open": ["NNReal ENNReal Topology Set Filter Bornology", "EMetric", "scoped Function in -- required for scoped `on` notation", "EMetric"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type u}", "[PseudoEMetricSpace \u03b1] {\u03b4 : \u211d} {s : Set \u03b1} {x : \u03b1}", "{X : Type u} [PseudoMetricSpace X]", "[PseudoEMetricSpace \u03b1] {\u03b4 \u03b5 : \u211d} {s t : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\ncthickening : x\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b4 : \u211d\n\u22a2 closedBall x sorry \u2286 sorry"}, {"line": "rcases lt_or_le \u03b4 0 with (h\u03b4 | h\u03b4)", "tactic_state": "case inl\nx\u271d : Sort u_3\ncthickening : x\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b4 : \u211d\nh\u03b4 : \u03b4 < 0\n\u22a2 closedBall x sorry \u2286 sorry\n---\ncase inr\nx\u271d : Sort u_3\ncthickening : x\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b4 : \u211d\nh\u03b4 : 0 \u2264 \u03b4\n\u22a2 closedBall x sorry \u2286 sorry"}, {"line": "\u00b7 simp only [closedBall_eq_empty.mpr h\u03b4, empty_subset]", "tactic_state": "case inr\nx\u271d : Sort u_3\ncthickening : x\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b4 : \u211d\nh\u03b4 : 0 \u2264 \u03b4\n\u22a2 closedBall x sorry \u2286 sorry"}, {"line": "\u00b7 simp only [cthickening_singleton x h\u03b4, Subset.rfl]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma NNReal.nndist_zero_eq_val' (z : \u211d\u22650) : nndist z 0 = z := by\n  rw [nndist_comm]\n  exact NNReal.nndist_zero_eq_val z\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Constructions.lean", "context": {"open": ["Bornology Filter Metric Set Topology", "scoped NNReal"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : NNReal\n\u22a2 nndist z 0 = z"}, {"line": "rw [nndist_comm]", "tactic_state": "z : NNReal\n\u22a2 nndist 0 z = z"}, {"line": "exact NNReal.nndist_zero_eq_val z", "tactic_state": "No Goals!"}]}
{"declaration": "lemma NNReal.le_add_nndist (a b : \u211d\u22650) : a \u2264 b + nndist a b := by\n  suffices (a : \u211d) \u2264 (b : \u211d) + dist a b by\n    rwa [\u2190 NNReal.coe_le_coe, NNReal.coe_add, coe_nndist]\n  rw [\u2190 sub_le_iff_le_add']\n  exact le_of_abs_le (dist_eq a b).ge\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Constructions.lean", "context": {"open": ["Bornology Filter Metric Set Topology", "scoped NNReal"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : NNReal\n\u22a2 a \u2264 b + nndist a b"}, {"line": "suffices (a : \u211d) \u2264 (b : \u211d) + dist a b by\n    rwa [\u2190 NNReal.coe_le_coe, NNReal.coe_add, coe_nndist]", "tactic_state": "a b : NNReal\n\u22a2 \u2191a \u2264 \u2191b + dist a b"}, {"line": "rw [\u2190 sub_le_iff_le_add']", "tactic_state": "a b : NNReal\n\u22a2 \u2191a - \u2191b \u2264 dist a b"}, {"line": "exact le_of_abs_le (dist_eq a b).ge", "tactic_state": "No Goals!"}]}
{"declaration": "lemma NNReal.ball_zero_eq_Ico (c : \u211d) :\n    Metric.ball (0 : \u211d\u22650) c = Set.Ico 0 c.toNNReal := by\n  by_cases c_pos : 0 < c\n  \u00b7 convert NNReal.ball_zero_eq_Ico' \u27e8c, c_pos.le\u27e9\n    simp [Real.toNNReal, c_pos.le]\n  simp [not_lt.mp c_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Constructions.lean", "context": {"open": ["Bornology Filter Metric Set Topology", "scoped NNReal"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u211d\n\u22a2 ball 0 c = Ico 0 c.toNNReal"}, {"line": "by_cases c_pos : 0 < c", "tactic_state": "case pos\nc : \u211d\nc_pos : 0 < c\n\u22a2 ball 0 c = Ico 0 c.toNNReal\n---\ncase neg\nc : \u211d\nc_pos : \u00ac0 < c\n\u22a2 ball 0 c = Ico 0 c.toNNReal"}, {"line": "\u00b7 convert NNReal.ball_zero_eq_Ico' \u27e8c, c_pos.le\u27e9\n    simp [Real.toNNReal, c_pos.le]", "tactic_state": "case neg\nc : \u211d\nc_pos : \u00ac0 < c\n\u22a2 ball 0 c = Ico 0 c.toNNReal"}, {"line": "simp [not_lt.mp c_pos]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma NNReal.closedBall_zero_eq_Icc {c : \u211d} (c_nn : 0 \u2264 c) :\n    Metric.closedBall (0 : \u211d\u22650) c = Set.Icc 0 c.toNNReal := by\n  convert NNReal.closedBall_zero_eq_Icc' \u27e8c, c_nn\u27e9\n  simp [Real.toNNReal, c_nn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Constructions.lean", "context": {"open": ["Bornology Filter Metric Set Topology", "scoped NNReal"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u211d\nc_nn : 0 \u2264 c\n\u22a2 closedBall 0 c = Icc 0 c.toNNReal"}, {"line": "convert NNReal.closedBall_zero_eq_Icc' \u27e8c, c_nn\u27e9", "tactic_state": "case h.e'_3.h.e'_4\nc : \u211d\nc_nn : 0 \u2264 c\n\u22a2 c.toNNReal = \u27e8c, c_nn\u27e9"}, {"line": "simp [Real.toNNReal, c_nn]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_prod_same_left {x : \u03b1} {y\u2081 y\u2082 : \u03b2} : dist (x, y\u2081) (x, y\u2082) = dist y\u2081 y\u2082 := by\n  simp [Prod.dist_eq, dist_nonneg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Constructions.lean", "context": {"open": ["Bornology Filter Metric Set Topology", "scoped NNReal"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1]", "[PseudoMetricSpace \u03b2]", "[PseudoMetricSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 inst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1\ny\u2081 y\u2082 : \u03b2\n\u22a2 dist (x, y\u2081) (x, y\u2082) = dist y\u2081 y\u2082"}, {"line": "simp [Prod.dist_eq, dist_nonneg]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_prod_same_right {x\u2081 x\u2082 : \u03b1} {y : \u03b2} : dist (x\u2081, y) (x\u2082, y) = dist x\u2081 x\u2082 := by\n  simp [Prod.dist_eq, dist_nonneg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Constructions.lean", "context": {"open": ["Bornology Filter Metric Set Topology", "scoped NNReal"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1]", "[PseudoMetricSpace \u03b2]", "[PseudoMetricSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 inst\u271d : PseudoMetricSpace \u03b2\nx\u2081 x\u2082 : \u03b1\ny : \u03b2\n\u22a2 dist (x\u2081, y) (x\u2082, y) = dist x\u2081 x\u2082"}, {"line": "simp [Prod.dist_eq, dist_nonneg]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_left_le_of_mem_uIcc {x y z : \u211d} (h : y \u2208 uIcc x z) : dist x y \u2264 dist x z := by\n  simpa only [dist_comm x] using abs_sub_left_of_mem_uIcc h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Real.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology"], "variables": ["{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nh : y \u2208 uIcc x z\n\u22a2 dist x y \u2264 dist x z"}, {"line": "simpa only [dist_comm x] using abs_sub_left_of_mem_uIcc h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_right_le_of_mem_uIcc {x y z : \u211d} (h : y \u2208 uIcc x z) : dist y z \u2264 dist x z := by\n  simpa only [dist_comm _ z] using abs_sub_right_of_mem_uIcc h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Real.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology"], "variables": ["{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nh : y \u2208 uIcc x z\n\u22a2 dist y z \u2264 dist x z"}, {"line": "simpa only [dist_comm _ z] using abs_sub_right_of_mem_uIcc h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_le_of_mem_Icc {x y x' y' : \u211d} (hx : x \u2208 Icc x' y') (hy : y \u2208 Icc x' y') :\n    dist x y \u2264 y' - x' := by\n  simpa only [Real.dist_eq,abs_of_nonpos (sub_nonpos.2 <| hx.1.trans hx.2),neg_sub] using\n    Real.dist_le_of_mem_uIcc (Icc_subset_uIcc hx) (Icc_subset_uIcc hy)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Real.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology"], "variables": ["{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y x' y' : \u211d\nhx : x \u2208 Icc x' y'\nhy : y \u2208 Icc x' y'\n\u22a2 dist x y \u2264 y' - x'"}, {"line": "simpa only [Real.dist_eq,abs_of_nonpos (sub_nonpos.2 <| hx.1.trans hx.2),neg_sub] using\n    Real.dist_le_of_mem_uIcc (Icc_subset_uIcc hx) (Icc_subset_uIcc hy)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_le_of_mem_Icc_01 {x y : \u211d} (hx : x \u2208 Icc (0 : \u211d) 1) (hy : y \u2208 Icc (0 : \u211d) 1) :\n    dist x y \u2264 1 := by simpa only [sub_zero] using Real.dist_le_of_mem_Icc hx hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Real.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology"], "variables": ["{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : x \u2208 Icc 0 1\nhy : y \u2208 Icc 0 1\n\u22a2 dist x y \u2264 1"}, {"line": "simpa only [sub_zero] using Real.dist_le_of_mem_Icc hx hy", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_le_of_mem_pi_Icc (hx : x \u2208 Icc x' y') (hy : y \u2208 Icc x' y') : dist x y \u2264 dist x' y' := by\n  refine (dist_pi_le_iff dist_nonneg).2 fun b =>\n    (Real.dist_le_of_mem_uIcc ?_ ?_).trans (dist_le_pi_dist x' y' b) <;> refine Icc_subset_uIcc ?_\n  exacts [\u27e8hx.1 _, hx.2 _\u27e9, \u27e8hy.1 _, hy.2 _\u27e9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Real.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology"], "variables": ["{\u03b9 : Type*}", "[Fintype \u03b9] {x y x' y' : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\nx y x' y' : \u03b9 \u2192 \u211d\nhx : x \u2208 Icc x' y'\nhy : y \u2208 Icc x' y'\n\u22a2 dist x y \u2264 dist x' y'"}, {"line": "refine (dist_pi_le_iff dist_nonneg).2 fun b =>\n    (Real.dist_le_of_mem_uIcc ?_ ?_).trans (dist_le_pi_dist x' y' b) <;> refine Icc_subset_uIcc ?_", "tactic_state": "case refine_1\n\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\nx y x' y' : \u03b9 \u2192 \u211d\nhx : x \u2208 Icc x' y'\nhy : y \u2208 Icc x' y'\nb : \u03b9\n\u22a2 x b \u2208 Icc (x' b) (y' b)\n---\ncase refine_2\n\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\nx y x' y' : \u03b9 \u2192 \u211d\nhx : x \u2208 Icc x' y'\nhy : y \u2208 Icc x' y'\nb : \u03b9\n\u22a2 y b \u2208 Icc (x' b) (y' b)"}, {"line": "exacts [\u27e8hx.1 _, hx.2 _\u27e9, \u27e8hy.1 _, hy.2 _\u27e9]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Metric.inseparable_iff {x y : \u03b1} : Inseparable x y \u2194 dist x y = 0 := by\n  rw [Metric.inseparable_iff_nndist]\n  rw [dist_nndist]\n  rw [NNReal.coe_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Basic.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\n\u22a2 Inseparable x y \u2194 dist x y = 0"}, {"line": "rw [Metric.inseparable_iff_nndist]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\n\u22a2 nndist x y = 0 \u2194 dist x y = 0"}, {"line": "rw [dist_nndist]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\n\u22a2 nndist x y = 0 \u2194 \u2191(nndist x y) = 0"}, {"line": "rw [NNReal.coe_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cauchySeq_iff_tendsto_dist_atTop_0 [Nonempty \u03b2] [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 Tendsto (fun n : \u03b2 \u00d7 \u03b2 => dist (u n.1) (u n.2)) atTop (\ud835\udcdd 0) := by\n  rw [cauchySeq_iff_tendsto]\n  rw [Metric.uniformity_eq_comap_nhds_zero]\n  rw [tendsto_comap_iff]\n  rw [Function.comp_def]\n  simp_rw [Prod.map_fst, Prod.map_snd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Basic.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 CauchySeq u \u2194 Tendsto (fun n => dist (u n.1) (u n.2)) atTop (nhds 0)"}, {"line": "rw [cauchySeq_iff_tendsto]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 Tendsto (Prod.map u u) atTop (uniformity \u03b1) \u2194 Tendsto (fun n => dist (u n.1) (u n.2)) atTop (nhds 0)\n---\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 Nonempty \u03b2"}, {"line": "rw [Metric.uniformity_eq_comap_nhds_zero]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 Tendsto (Prod.map u u) atTop (comap (fun p => dist p.1 p.2) (nhds 0)) \u2194\n    Tendsto (fun n => dist (u n.1) (u n.2)) atTop (nhds 0)\n---\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 Nonempty \u03b2"}, {"line": "rw [tendsto_comap_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 Tendsto ((fun p => dist p.1 p.2) \u2218 Prod.map u u) atTop (nhds 0) \u2194\n    Tendsto (fun n => dist (u n.1) (u n.2)) atTop (nhds 0)\n---\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 Nonempty \u03b2"}, {"line": "rw [Function.comp_def]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 Tendsto (fun x => dist (Prod.map u u x).1 (Prod.map u u x).2) atTop (nhds 0) \u2194\n    Tendsto (fun n => dist (u n.1) (u n.2)) atTop (nhds 0)\n---\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 Nonempty \u03b2"}, {"line": "simp_rw [Prod.map_fst, Prod.map_snd]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 Nonempty \u03b2"}]}
{"declaration": "theorem edist_nndist (x y : \u03b1) : edist x y = nndist x y := by\n  rw [edist_dist]\n  rw [dist_nndist]\n  rw [ENNReal.ofReal_coe_nnreal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\n\u22a2 edist x y = \u2191(nndist x y)"}, {"line": "rw [edist_dist]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\n\u22a2 ENNReal.ofReal (dist x y) = \u2191(nndist x y)"}, {"line": "rw [dist_nndist]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\n\u22a2 ENNReal.ofReal \u2191(nndist x y) = \u2191(nndist x y)"}, {"line": "rw [ENNReal.ofReal_coe_nnreal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_lt_coe {x y : \u03b1} {c : \u211d\u22650} : edist x y < c \u2194 nndist x y < c := by\n  rw [edist_nndist]\n  rw [ENNReal.coe_lt_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\nc : NNReal\n\u22a2 edist x y < \u2191c \u2194 nndist x y < c"}, {"line": "rw [edist_nndist]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\nc : NNReal\n\u22a2 \u2191(nndist x y) < \u2191c \u2194 nndist x y < c"}, {"line": "rw [ENNReal.coe_lt_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_le_coe {x y : \u03b1} {c : \u211d\u22650} : edist x y \u2264 c \u2194 nndist x y \u2264 c := by\n  rw [edist_nndist]\n  rw [ENNReal.coe_le_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\nc : NNReal\n\u22a2 edist x y \u2264 \u2191c \u2194 nndist x y \u2264 c"}, {"line": "rw [edist_nndist]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\nc : NNReal\n\u22a2 \u2191(nndist x y) \u2264 \u2191c \u2194 nndist x y \u2264 c"}, {"line": "rw [ENNReal.coe_le_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_lt_ofReal {x y : \u03b1} {r : \u211d} : edist x y < ENNReal.ofReal r \u2194 dist x y < r := by\n  rw [edist_dist]\n  rw [ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\nr : \u211d\n\u22a2 edist x y < ENNReal.ofReal r \u2194 dist x y < r"}, {"line": "rw [edist_dist]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\nr : \u211d\n\u22a2 ENNReal.ofReal (dist x y) < ENNReal.ofReal r \u2194 dist x y < r"}, {"line": "rw [ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_le_ofReal {x y : \u03b1} {r : \u211d} (hr : 0 \u2264 r) :\n    edist x y \u2264 ENNReal.ofReal r \u2194 dist x y \u2264 r := by\n  rw [edist_dist]\n  rw [ENNReal.ofReal_le_ofReal_iff hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 edist x y \u2264 ENNReal.ofReal r \u2194 dist x y \u2264 r"}, {"line": "rw [edist_dist]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 ENNReal.ofReal (dist x y) \u2264 ENNReal.ofReal r \u2194 dist x y \u2264 r"}, {"line": "rw [ENNReal.ofReal_le_ofReal_iff hr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nndist_dist (x y : \u03b1) : nndist x y = Real.toNNReal (dist x y) := by\n  rw [dist_nndist]\n  rw [Real.toNNReal_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\n\u22a2 nndist x y = (dist x y).toNNReal"}, {"line": "rw [dist_nndist]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\n\u22a2 nndist x y = (\u2191(nndist x y)).toNNReal"}, {"line": "rw [Real.toNNReal_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_edist (x y : \u03b1) : dist x y = (edist x y).toReal := by\n  rw [edist_dist]\n  rw [ENNReal.toReal_ofReal dist_nonneg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\n\u22a2 dist x y = (edist x y).toReal"}, {"line": "rw [edist_dist]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\n\u22a2 dist x y = (ENNReal.ofReal (dist x y)).toReal"}, {"line": "rw [ENNReal.toReal_ofReal dist_nonneg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ball_eq_ball' (\u03b5 : \u211d) (x : \u03b1) :\n    UniformSpace.ball x { p | dist p.1 p.2 < \u03b5 } = Metric.ball x \u03b5 := by\n  ext\n  simp [dist_comm, UniformSpace.ball]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\n\u03b5 : \u211d\nx : \u03b1\n\u22a2 UniformSpace.ball x {p | dist p.1 p.2 < \u03b5} = Metric.ball x \u03b5"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\n\u03b5 : \u211d\nx x\u271d : \u03b1\n\u22a2 x\u271d \u2208 UniformSpace.ball x {p | dist p.1 p.2 < \u03b5} \u2194 x\u271d \u2208 Metric.ball x \u03b5"}, {"line": "simp [dist_comm, UniformSpace.ball]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isBounded_iff {s : Set \u03b1} :\n    IsBounded s \u2194 \u2203 C : \u211d, \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 dist x y \u2264 C := by\n  rw [isBounded_def]\n  rw [\u2190 Filter.mem_sets]\n  rw [@PseudoMetricSpace.cobounded_sets \u03b1]\n  rw [mem_setOf_eq]\n  rw [compl_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\n\u22a2 Bornology.IsBounded s \u2194 \u2203 C, \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u2192 dist x y \u2264 C"}, {"line": "rw [isBounded_def]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\n\u22a2 s\u1d9c \u2208 cobounded \u03b1 \u2194 \u2203 C, \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u2192 dist x y \u2264 C"}, {"line": "rw [\u2190 Filter.mem_sets]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\n\u22a2 s\u1d9c \u2208 (cobounded \u03b1).sets \u2194 \u2203 C, \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u2192 dist x y \u2264 C"}, {"line": "rw [@PseudoMetricSpace.cobounded_sets \u03b1]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\n\u22a2 s\u1d9c \u2208 {s | \u2203 C, \u2200 x \u2208 s\u1d9c, \u2200 y \u2208 s\u1d9c, dist x y \u2264 C} \u2194 \u2203 C, \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u2192 dist x y \u2264 C"}, {"line": "rw [mem_setOf_eq]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\n\u22a2 (\u2203 C, \u2200 x \u2208 s\u1d9c\u1d9c, \u2200 y \u2208 s\u1d9c\u1d9c, dist x y \u2264 C) \u2194 \u2203 C, \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u2192 dist x y \u2264 C"}, {"line": "rw [compl_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_prod_nhds_iff {f : Filter \u03b9} {x\u2080 : \u03b1} {p : \u03b9 \u00d7 \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in f \u00d7\u02e2 \ud835\udcdd x\u2080, p x) \u2194 \u2203 pa : \u03b9 \u2192 Prop, (\u2200\u1da0 i in f, pa i) \u2227\n      \u2203 \u03b5 > 0, \u2200 \u2983i\u2984, pa i \u2192 \u2200 \u2983x\u2984, dist x x\u2080 < \u03b5 \u2192 p (i, x) := by\n  rw [eventually_swap_iff]\n  rw [Metric.eventually_nhds_prod_iff]\n  constructor <;>\n    \u00b7 rintro \u27e8a1, a2, a3, a4, a5\u27e9\n      exact \u27e8a3, a4, a1, a2, fun _ b1 b2 b3 => a5 b3 b1\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nf : Filter \u03b9\nx\u2080 : \u03b1\np : \u03b9 \u00d7 \u03b1 \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : \u03b9 \u00d7 \u03b1) in f \u00d7\u02e2 nhds x\u2080, p x) \u2194\n    \u2203 pa, (\u2200\u1da0 (i : \u03b9) in f, pa i) \u2227 \u2203 \u03b5 > 0, \u2200 \u2983i : \u03b9\u2984, pa i \u2192 \u2200 \u2983x : \u03b1\u2984, dist x x\u2080 < \u03b5 \u2192 p (i, x)"}, {"line": "rw [eventually_swap_iff]", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nf : Filter \u03b9\nx\u2080 : \u03b1\np : \u03b9 \u00d7 \u03b1 \u2192 Prop\n\u22a2 (\u2200\u1da0 (y : \u03b1 \u00d7 \u03b9) in nhds x\u2080 \u00d7\u02e2 f, p y.swap) \u2194\n    \u2203 pa, (\u2200\u1da0 (i : \u03b9) in f, pa i) \u2227 \u2203 \u03b5 > 0, \u2200 \u2983i : \u03b9\u2984, pa i \u2192 \u2200 \u2983x : \u03b1\u2984, dist x x\u2080 < \u03b5 \u2192 p (i, x)"}, {"line": "rw [Metric.eventually_nhds_prod_iff]", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nf : Filter \u03b9\nx\u2080 : \u03b1\np : \u03b9 \u00d7 \u03b1 \u2192 Prop\n\u22a2 (\u2203 \u03b5 > 0, \u2203 pa, (\u2200\u1da0 (i : \u03b9) in f, pa i) \u2227 \u2200 \u2983x : \u03b1\u2984, dist x x\u2080 < \u03b5 \u2192 \u2200 \u2983i : \u03b9\u2984, pa i \u2192 p (x, i).swap) \u2194\n    \u2203 pa, (\u2200\u1da0 (i : \u03b9) in f, pa i) \u2227 \u2203 \u03b5 > 0, \u2200 \u2983i : \u03b9\u2984, pa i \u2192 \u2200 \u2983x : \u03b1\u2984, dist x x\u2080 < \u03b5 \u2192 p (i, x)"}, {"line": "constructor <;>\n    \u00b7 rintro \u27e8a1, a2, a3, a4, a5\u27e9\n      exact \u27e8a3, a4, a1, a2, fun _ b1 b2 b3 => a5 b3 b1\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_iff : IsOpen s \u2194 \u2200 x \u2208 s, \u2203 \u03b5 > 0, ball x \u03b5 \u2286 s := by\n  simp only [isOpen_iff_mem_nhds]\n  simp only [mem_nhds_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx\u271d : Sort u_3\nball : x\u271d\n\u22a2 IsOpen s \u2194 \u2200 x \u2208 s, \u2203 \u03b5 > 0, sorry \u2286 s"}, {"line": "simp only [isOpen_iff_mem_nhds]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx\u271d : Sort u_3\nball : x\u271d\n\u22a2 (\u2200 x \u2208 s, s \u2208 nhds x) \u2194 \u2200 x \u2208 s, \u2203 \u03b5 > 0, sorry \u2286 s"}, {"line": "simp only [mem_nhds_iff]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx\u271d : Sort u_3\nball : x\u271d\n\u22a2 (\u2200 x \u2208 s, \u2203 t \u2286 s, IsOpen t \u2227 x \u2208 t) \u2194 \u2200 x \u2208 s, \u2203 \u03b5 > 0, sorry \u2286 s"}]}
{"declaration": "theorem continuousOn_iff [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    ContinuousOn f s \u2194 \u2200 b \u2208 s, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 a \u2208 s, dist a b < \u03b4 \u2192 dist (f a) (f b) < \u03b5 := by\n  simp [ContinuousOn, continuousWithinAt_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 ContinuousOn f s \u2194 \u2200 b \u2208 s, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 a \u2208 s, dist a b < \u03b4 \u2192 dist (f a) (f b) < \u03b5"}, {"line": "simp [ContinuousOn, continuousWithinAt_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 (\u2200 x \u2208 s, ContinuousWithinAt f s x) \u2194\n    \u2200 b \u2208 s, \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2203 \u03b4, 0 < \u03b4 \u2227 \u2200 a \u2208 s, dist a b < \u03b4 \u2192 dist (f a) (f b) < \u03b5"}]}
{"declaration": "theorem continuousAt_iff' [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {b : \u03b2} :\n    ContinuousAt f b \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 x in \ud835\udcdd b, dist (f x) (f b) < \u03b5 := by\n  rw [ContinuousAt]\n  rw [tendsto_nhds]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\n\u22a2 ContinuousAt f b \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 (x : \u03b2) in nhds b, dist (f x) (f b) < \u03b5"}, {"line": "rw [ContinuousAt]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\n\u22a2 Tendsto f (nhds b) (nhds (f b)) \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 (x : \u03b2) in nhds b, dist (f x) (f b) < \u03b5"}, {"line": "rw [tendsto_nhds]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\n\u22a2 (\u2200 (s : Set \u03b1), IsOpen s \u2192 f b \u2208 s \u2192 f \u207b\u00b9' s \u2208 nhds b) \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 (x : \u03b2) in nhds b, dist (f x) (f b) < \u03b5"}]}
{"declaration": "theorem continuousWithinAt_iff' [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {b : \u03b2} {s : Set \u03b2} :\n    ContinuousWithinAt f s b \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 x in \ud835\udcdd[s] b, dist (f x) (f b) < \u03b5 := by\n  rw [ContinuousWithinAt]\n  rw [tendsto_nhds]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\ns : Set \u03b2\n\u22a2 ContinuousWithinAt f s b \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 (x : \u03b2) in nhdsWithin b s, dist (f x) (f b) < \u03b5"}, {"line": "rw [ContinuousWithinAt]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\ns : Set \u03b2\n\u22a2 Tendsto f (nhdsWithin b s) (nhds (f b)) \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 (x : \u03b2) in nhdsWithin b s, dist (f x) (f b) < \u03b5"}, {"line": "rw [tendsto_nhds]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\ns : Set \u03b2\n\u22a2 (\u2200 (s_1 : Set \u03b1), IsOpen s_1 \u2192 f b \u2208 s_1 \u2192 f \u207b\u00b9' s_1 \u2208 nhdsWithin b s) \u2194\n    \u2200 \u03b5 > 0, \u2200\u1da0 (x : \u03b2) in nhdsWithin b s, dist (f x) (f b) < \u03b5"}]}
{"declaration": "theorem continuousOn_iff' [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} :\n    ContinuousOn f s \u2194 \u2200 b \u2208 s, \u2200 \u03b5 > 0, \u2200\u1da0 x in \ud835\udcdd[s] b, dist (f x) (f b) < \u03b5 := by\n  simp [ContinuousOn, continuousWithinAt_iff']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\n\u22a2 ContinuousOn f s \u2194 \u2200 b \u2208 s, \u2200 \u03b5 > 0, \u2200\u1da0 (x : \u03b2) in nhdsWithin b s, dist (f x) (f b) < \u03b5"}, {"line": "simp [ContinuousOn, continuousWithinAt_iff']", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\n\u22a2 (\u2200 x \u2208 s, ContinuousWithinAt f s x) \u2194 \u2200 b \u2208 s, \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2200\u1da0 (x : \u03b2) in nhdsWithin b s, dist (f x) (f b) < \u03b5"}]}
{"declaration": "theorem isOpen_singleton_iff {\u03b1 : Type*} [PseudoMetricSpace \u03b1] {x : \u03b1} :\n    IsOpen ({x} : Set \u03b1) \u2194 \u2203 \u03b5 > 0, \u2200 y, dist y x < \u03b5 \u2192 y = x := by\n  simp [isOpen_iff, subset_singleton_iff, mem_ball]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u22a2 IsOpen {x} \u2194 \u2203 \u03b5 > 0, \u2200 (y : \u03b1), dist y x < \u03b5 \u2192 y = x"}, {"line": "simp [isOpen_iff, subset_singleton_iff, mem_ball]", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u22a2 IsOpen {x} \u2194 \u2203 \u03b5, 0 < \u03b5 \u2227 \u2200 (y : \u03b1), dist y x < \u03b5 \u2192 y = x"}]}
{"declaration": "theorem Metric.uniformity_edist : \ud835\udce4 \u03b1 = \u2a05 \u03b5 > 0, \ud835\udcdf { p : \u03b1 \u00d7 \u03b1 | edist p.1 p.2 < \u03b5 } := by\n  simp only [PseudoMetricSpace.uniformity_dist]\n  simp only [dist_nndist]\n  simp only [edist_nndist]\n  simp only [Metric.uniformity_edist_aux]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\n\u22a2 uniformity \u03b1 = \u2a05 \u03b5, \u2a05 (_ : \u03b5 > 0), principal {p | edist p.1 p.2 < \u03b5}"}, {"line": "simp only [PseudoMetricSpace.uniformity_dist]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\n\u22a2 \u2a05 \u03b5, \u2a05 (_ : \u03b5 > 0), principal {p | dist p.1 p.2 < \u03b5} = \u2a05 \u03b5, \u2a05 (_ : \u03b5 > 0), principal {p | edist p.1 p.2 < \u03b5}"}, {"line": "simp only [dist_nndist]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\n\u22a2 \u2a05 \u03b5, \u2a05 (_ : \u03b5 > 0), principal {p | \u2191(nndist p.1 p.2) < \u03b5} = \u2a05 \u03b5, \u2a05 (_ : \u03b5 > 0), principal {p | edist p.1 p.2 < \u03b5}"}, {"line": "simp only [edist_nndist]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\n\u22a2 \u2a05 \u03b5, \u2a05 (_ : \u03b5 > 0), principal {p | \u2191(nndist p.1 p.2) < \u03b5} = \u2a05 \u03b5, \u2a05 (_ : \u03b5 > 0), principal {p | \u2191(nndist p.1 p.2) < \u03b5}"}, {"line": "simp only [Metric.uniformity_edist_aux]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Metric.emetric_ball {x : \u03b1} {\u03b5 : \u211d} : EMetric.ball x (ENNReal.ofReal \u03b5) = ball x \u03b5 := by\n  ext y\n  simp only [EMetric.mem_ball]\n  simp only [mem_ball]\n  simp only [edist_dist]\n  exact ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b5 : \u211d\n\u22a2 EMetric.ball x (ENNReal.ofReal \u03b5) = ball x \u03b5"}, {"line": "ext y", "tactic_state": "case h\n\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b5 : \u211d\ny : \u03b1\n\u22a2 y \u2208 EMetric.ball x (ENNReal.ofReal \u03b5) \u2194 y \u2208 ball x \u03b5"}, {"line": "simp only [EMetric.mem_ball]", "tactic_state": "case h\n\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b5 : \u211d\ny : \u03b1\n\u22a2 edist y x < ENNReal.ofReal \u03b5 \u2194 y \u2208 ball x \u03b5"}, {"line": "simp only [mem_ball]", "tactic_state": "case h\n\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b5 : \u211d\ny : \u03b1\n\u22a2 edist y x < ENNReal.ofReal \u03b5 \u2194 dist y x < \u03b5"}, {"line": "simp only [edist_dist]", "tactic_state": "case h\n\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b5 : \u211d\ny : \u03b1\n\u22a2 ENNReal.ofReal (dist y x) < ENNReal.ofReal \u03b5 \u2194 dist y x < \u03b5"}, {"line": "exact ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Metric.emetric_ball_nnreal {x : \u03b1} {\u03b5 : \u211d\u22650} : EMetric.ball x \u03b5 = ball x \u03b5 := by\n  rw [\u2190 Metric.emetric_ball]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b5 : NNReal\n\u22a2 EMetric.ball x \u2191\u03b5 = ball x \u2191\u03b5"}, {"line": "rw [\u2190 Metric.emetric_ball]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b5 : NNReal\n\u22a2 EMetric.ball x \u2191\u03b5 = EMetric.ball x (ENNReal.ofReal \u2191\u03b5)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Metric.emetric_closedBall_nnreal {x : \u03b1} {\u03b5 : \u211d\u22650} :\n    EMetric.closedBall x \u03b5 = closedBall x \u03b5 := by\n  rw [\u2190 Metric.emetric_closedBall \u03b5.coe_nonneg]\n  rw [ENNReal.ofReal_coe_nnreal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b5 : NNReal\n\u22a2 EMetric.closedBall x \u2191\u03b5 = closedBall x \u2191\u03b5"}, {"line": "rw [\u2190 Metric.emetric_closedBall \u03b5.coe_nonneg]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b5 : NNReal\n\u22a2 EMetric.closedBall x \u2191\u03b5 = EMetric.closedBall x (ENNReal.ofReal \u2191\u03b5)"}, {"line": "rw [ENNReal.ofReal_coe_nnreal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PseudoMetricSpace.replaceUniformity_eq {\u03b1} [U : UniformSpace \u03b1] (m : PseudoMetricSpace \u03b1)\n    (H : \ud835\udce4[U] = \ud835\udce4[PseudoEMetricSpace.toUniformSpace]) : m.replaceUniformity H = m := by\n  ext\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nU : UniformSpace \u03b1\nm : PseudoMetricSpace \u03b1\nH : uniformity \u03b1 = uniformity \u03b1\n\u22a2 m.replaceUniformity H = m"}, {"line": "ext", "tactic_state": "case h.dist.h.h\n\u03b1 : Type u_3\nU : UniformSpace \u03b1\nm : PseudoMetricSpace \u03b1\nH : uniformity \u03b1 = uniformity \u03b1\nx\u271d\u00b9 x\u271d : \u03b1\n\u22a2 dist x\u271d\u00b9 x\u271d = dist x\u271d\u00b9 x\u271d"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1} [U : UniformSpace \u03b1] (m : PseudoMetricSpace \u03b1)\n    (H : \ud835\udce4[U] = \ud835\udce4[PseudoEMetricSpace.toUniformSpace]) :\n    (PseudoMetricSpace.replaceUniformity m H).toBornology = m.toBornology := by\n  with_reducible_and_instances rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\u271d\nx y z : \u03b1\u271d\n\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\ns : Set \u03b1\u271d\n\u03b1 : Type u_3\nU : UniformSpace \u03b1\nm : PseudoMetricSpace \u03b1\nH : uniformity \u03b1 = uniformity \u03b1\n\u22a2 PseudoMetricSpace.toBornology = PseudoMetricSpace.toBornology"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PseudoMetricSpace.replaceTopology_eq {\u03b3} [U : TopologicalSpace \u03b3] (m : PseudoMetricSpace \u03b3)\n    (H : U = m.toUniformSpace.toTopologicalSpace) : m.replaceTopology H = m := by\n  ext\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b3 : Type u_3\nU : TopologicalSpace \u03b3\nm : PseudoMetricSpace \u03b3\nH : U = UniformSpace.toTopologicalSpace\n\u22a2 m.replaceTopology H = m"}, {"line": "ext", "tactic_state": "case h.dist.h.h\n\u03b3 : Type u_3\nU : TopologicalSpace \u03b3\nm : PseudoMetricSpace \u03b3\nH : U = UniformSpace.toTopologicalSpace\nx\u271d\u00b9 x\u271d : \u03b3\n\u22a2 dist x\u271d\u00b9 x\u271d = dist x\u271d\u00b9 x\u271d"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PseudoMetricSpace.replaceBornology_eq {\u03b1} [m : PseudoMetricSpace \u03b1] [B : Bornology \u03b1]\n    (H : \u2200 s, @IsBounded _ B s \u2194 @IsBounded _ PseudoMetricSpace.toBornology s) :\n    PseudoMetricSpace.replaceBornology _ H = m := by\n  ext\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nm : PseudoMetricSpace \u03b1\nB : Bornology \u03b1\nH : \u2200 (s : Set \u03b1), Bornology.IsBounded s \u2194 Bornology.IsBounded s\n\u22a2 m.replaceBornology H = m"}, {"line": "ext", "tactic_state": "case h.dist.h.h\n\u03b1 : Type u_3\nm : PseudoMetricSpace \u03b1\nB : Bornology \u03b1\nH : \u2200 (s : Set \u03b1), Bornology.IsBounded s \u2194 Bornology.IsBounded s\nx\u271d\u00b9 x\u271d : \u03b1\n\u22a2 dist x\u271d\u00b9 x\u271d = dist x\u271d\u00b9 x\u271d"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1} [B : Bornology \u03b1] (m : PseudoMetricSpace \u03b1)\n    (H : \u2200 s, @IsBounded _ B s \u2194 @IsBounded _ PseudoMetricSpace.toBornology s) :\n    (PseudoMetricSpace.replaceBornology m H).toUniformSpace = m.toUniformSpace := by\n  with_reducible_and_instances rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\u271d\nx y z : \u03b1\u271d\n\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\ns : Set \u03b1\u271d\n\u03b1 : Type u_3\nB : Bornology \u03b1\nm : PseudoMetricSpace \u03b1\nH : \u2200 (s : Set \u03b1), Bornology.IsBounded s \u2194 Bornology.IsBounded s\n\u22a2 PseudoMetricSpace.toUniformSpace = PseudoMetricSpace.toUniformSpace"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.dist_0_eq_abs (x : \u211d) : dist x 0 = |x| := by simp [Real.dist_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 dist x 0 = |x|"}, {"line": "simp [Real.dist_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.sub_le_dist (x y : \u211d) : x - y \u2264 dist x y := by\n  rw [Real.dist_eq]\n  rw [le_abs]\n  exact Or.inl (le_refl _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 x - y \u2264 dist x y"}, {"line": "rw [Real.dist_eq]", "tactic_state": "x y : \u211d\n\u22a2 x - y \u2264 |x - y|"}, {"line": "rw [le_abs]", "tactic_state": "x y : \u211d\n\u22a2 x - y \u2264 x - y \u2228 x - y \u2264 -(x - y)"}, {"line": "exact Or.inl (le_refl _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.closedBall_eq_Icc {x r : \u211d} : closedBall x r = Icc (x - r) (x + r) := by\n  ext y\n  rw [mem_closedBall]\n  rw [dist_comm]\n  rw [Real.dist_eq]\n  rw [abs_sub_le_iff]\n  rw [mem_Icc]\n  rw [\u2190 sub_le_iff_le_add']\n  rw [sub_le_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x r : \u211d\n\u22a2 closedBall x r = Icc (x - r) (x + r)"}, {"line": "ext y", "tactic_state": "case h\nx r y : \u211d\n\u22a2 y \u2208 closedBall x r \u2194 y \u2208 Icc (x - r) (x + r)"}, {"line": "rw [mem_closedBall]", "tactic_state": "case h\nx r y : \u211d\n\u22a2 dist y x \u2264 r \u2194 y \u2208 Icc (x - r) (x + r)"}, {"line": "rw [dist_comm]", "tactic_state": "case h\nx r y : \u211d\n\u22a2 dist x y \u2264 r \u2194 y \u2208 Icc (x - r) (x + r)"}, {"line": "rw [Real.dist_eq]", "tactic_state": "case h\nx r y : \u211d\n\u22a2 |x - y| \u2264 r \u2194 y \u2208 Icc (x - r) (x + r)"}, {"line": "rw [abs_sub_le_iff]", "tactic_state": "case h\nx r y : \u211d\n\u22a2 x - y \u2264 r \u2227 y - x \u2264 r \u2194 y \u2208 Icc (x - r) (x + r)"}, {"line": "rw [mem_Icc]", "tactic_state": "case h\nx r y : \u211d\n\u22a2 x - y \u2264 r \u2227 y - x \u2264 r \u2194 x - r \u2264 y \u2227 y \u2264 x + r"}, {"line": "rw [\u2190 sub_le_iff_le_add']", "tactic_state": "case h\nx r y : \u211d\n\u22a2 x - y \u2264 r \u2227 y - x \u2264 r \u2194 x - r \u2264 y \u2227 y - x \u2264 r"}, {"line": "rw [sub_le_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.Ioo_eq_ball (x y : \u211d) : Ioo x y = ball ((x + y) / 2) ((y - x) / 2) := by\n  rw [Real.ball_eq_Ioo]\n  rw [\u2190 sub_div]\n  rw [add_comm]\n  rw [\u2190 sub_add]\n  rw [add_sub_cancel_left]\n  rw [add_self_div_two]\n  rw [\u2190 add_div]\n  rw [add_assoc]\n  rw [add_sub_cancel]\n  rw [add_self_div_two]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 Ioo x y = ball ((x + y) / 2) ((y - x) / 2)"}, {"line": "rw [Real.ball_eq_Ioo]", "tactic_state": "x y : \u211d\n\u22a2 Ioo x y = Ioo ((x + y) / 2 - (y - x) / 2) ((x + y) / 2 + (y - x) / 2)"}, {"line": "rw [\u2190 sub_div]", "tactic_state": "x y : \u211d\n\u22a2 Ioo x y = Ioo ((x + y - (y - x)) / 2) ((x + y) / 2 + (y - x) / 2)"}, {"line": "rw [add_comm]", "tactic_state": "x y : \u211d\n\u22a2 Ioo x y = Ioo ((y + x - (y - x)) / 2) ((y + x) / 2 + (y - x) / 2)"}, {"line": "rw [\u2190 sub_add]", "tactic_state": "x y : \u211d\n\u22a2 Ioo x y = Ioo ((y + x - y + x) / 2) ((y + x) / 2 + (y - x) / 2)"}, {"line": "rw [add_sub_cancel_left]", "tactic_state": "x y : \u211d\n\u22a2 Ioo x y = Ioo ((x + x) / 2) ((y + x) / 2 + (y - x) / 2)"}, {"line": "rw [add_self_div_two]", "tactic_state": "x y : \u211d\n\u22a2 Ioo x y = Ioo x ((y + x) / 2 + (y - x) / 2)"}, {"line": "rw [\u2190 add_div]", "tactic_state": "x y : \u211d\n\u22a2 Ioo x y = Ioo x ((y + x + (y - x)) / 2)"}, {"line": "rw [add_assoc]", "tactic_state": "x y : \u211d\n\u22a2 Ioo x y = Ioo x ((y + (x + (y - x))) / 2)"}, {"line": "rw [add_sub_cancel]", "tactic_state": "x y : \u211d\n\u22a2 Ioo x y = Ioo x ((y + y) / 2)"}, {"line": "rw [add_self_div_two]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.Icc_eq_closedBall (x y : \u211d) : Icc x y = closedBall ((x + y) / 2) ((y - x) / 2) := by\n  rw [Real.closedBall_eq_Icc]\n  rw [\u2190 sub_div]\n  rw [add_comm]\n  rw [\u2190 sub_add]\n  rw [add_sub_cancel_left]\n  rw [add_self_div_two]\n  rw [\u2190 add_div]\n  rw [add_assoc]\n  rw [add_sub_cancel]\n  rw [add_self_div_two]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 Icc x y = closedBall ((x + y) / 2) ((y - x) / 2)"}, {"line": "rw [Real.closedBall_eq_Icc]", "tactic_state": "x y : \u211d\n\u22a2 Icc x y = Icc ((x + y) / 2 - (y - x) / 2) ((x + y) / 2 + (y - x) / 2)"}, {"line": "rw [\u2190 sub_div]", "tactic_state": "x y : \u211d\n\u22a2 Icc x y = Icc ((x + y - (y - x)) / 2) ((x + y) / 2 + (y - x) / 2)"}, {"line": "rw [add_comm]", "tactic_state": "x y : \u211d\n\u22a2 Icc x y = Icc ((y + x - (y - x)) / 2) ((y + x) / 2 + (y - x) / 2)"}, {"line": "rw [\u2190 sub_add]", "tactic_state": "x y : \u211d\n\u22a2 Icc x y = Icc ((y + x - y + x) / 2) ((y + x) / 2 + (y - x) / 2)"}, {"line": "rw [add_sub_cancel_left]", "tactic_state": "x y : \u211d\n\u22a2 Icc x y = Icc ((x + x) / 2) ((y + x) / 2 + (y - x) / 2)"}, {"line": "rw [add_self_div_two]", "tactic_state": "x y : \u211d\n\u22a2 Icc x y = Icc x ((y + x) / 2 + (y - x) / 2)"}, {"line": "rw [\u2190 add_div]", "tactic_state": "x y : \u211d\n\u22a2 Icc x y = Icc x ((y + x + (y - x)) / 2)"}, {"line": "rw [add_assoc]", "tactic_state": "x y : \u211d\n\u22a2 Icc x y = Icc x ((y + (x + (y - x))) / 2)"}, {"line": "rw [add_sub_cancel]", "tactic_state": "x y : \u211d\n\u22a2 Icc x y = Icc x ((y + y) / 2)"}, {"line": "rw [add_self_div_two]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Metric.uniformity_eq_comap_nhds_zero :\n    \ud835\udce4 \u03b1 = comap (fun p : \u03b1 \u00d7 \u03b1 => dist p.1 p.2) (\ud835\udcdd (0 : \u211d)) := by\n  ext s\n  simp only [mem_uniformity_dist]\n  simp only [(nhds_basis_ball.comap _).mem_iff]\n  simp [subset_def, Real.dist_0_eq_abs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\n\u22a2 uniformity \u03b1 = comap (fun p => dist p.1 p.2) (nhds 0)"}, {"line": "ext s", "tactic_state": "case h\n\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set (\u03b1 \u00d7 \u03b1)\n\u22a2 s \u2208 uniformity \u03b1 \u2194 s \u2208 comap (fun p => dist p.1 p.2) (nhds 0)"}, {"line": "simp only [mem_uniformity_dist]", "tactic_state": "case h\n\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set (\u03b1 \u00d7 \u03b1)\n\u22a2 (\u2203 \u03b5 > 0, \u2200 \u2983a b : \u03b1\u2984, dist a b < \u03b5 \u2192 (a, b) \u2208 s) \u2194 s \u2208 comap (fun p => dist p.1 p.2) (nhds 0)"}, {"line": "simp only [(nhds_basis_ball.comap _).mem_iff]", "tactic_state": "case h\n\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set (\u03b1 \u00d7 \u03b1)\n\u22a2 (\u2203 \u03b5 > 0, \u2200 \u2983a b : \u03b1\u2984, dist a b < \u03b5 \u2192 (a, b) \u2208 s) \u2194 \u2203 i, 0 < i \u2227 (fun p => dist p.1 p.2) \u207b\u00b9' ball 0 i \u2286 s"}, {"line": "simp [subset_def, Real.dist_0_eq_abs]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_uniformity_iff_dist_tendsto_zero {f : \u03b9 \u2192 \u03b1 \u00d7 \u03b1} {p : Filter \u03b9} :\n    Tendsto f p (\ud835\udce4 \u03b1) \u2194 Tendsto (fun x => dist (f x).1 (f x).2) p (\ud835\udcdd 0) := by\n  rw [Metric.uniformity_eq_comap_nhds_zero]\n  rw [tendsto_comap_iff]\n  rw [Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nf : \u03b9 \u2192 \u03b1 \u00d7 \u03b1\np : Filter \u03b9\n\u22a2 Tendsto f p (uniformity \u03b1) \u2194 Tendsto (fun x => dist (f x).1 (f x).2) p (nhds 0)"}, {"line": "rw [Metric.uniformity_eq_comap_nhds_zero]", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nf : \u03b9 \u2192 \u03b1 \u00d7 \u03b1\np : Filter \u03b9\n\u22a2 Tendsto f p (comap (fun p => dist p.1 p.2) (nhds 0)) \u2194 Tendsto (fun x => dist (f x).1 (f x).2) p (nhds 0)"}, {"line": "rw [tendsto_comap_iff]", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nf : \u03b9 \u2192 \u03b1 \u00d7 \u03b1\np : Filter \u03b9\n\u22a2 Tendsto ((fun p => dist p.1 p.2) \u2218 f) p (nhds 0) \u2194 Tendsto (fun x => dist (f x).1 (f x).2) p (nhds 0)"}, {"line": "rw [Function.comp_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_dist_dist_le_right (x y z : \u03b1) : dist (dist x y) (dist x z) \u2264 dist y z := by\n  simpa only [dist_comm x] using dist_dist_dist_le_left y z x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx y z : \u03b1\n\u22a2 dist (dist x y) (dist x z) \u2264 dist y z"}, {"line": "simpa only [dist_comm x] using dist_dist_dist_le_left y z x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_comap_dist (a : \u03b1) : ((\ud835\udcdd (0 : \u211d)).comap (dist \u00b7 a)) = \ud835\udcdd a := by\n  simp only [@nhds_eq_comap_uniformity \u03b1]\n  simp only [Metric.uniformity_eq_comap_nhds_zero]\n  simp only [comap_comap]\n  simp only [Function.comp_def]\n  simp only [dist_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\na : \u03b1\n\u22a2 comap (fun x => dist x a) (nhds 0) = nhds a"}, {"line": "simp only [@nhds_eq_comap_uniformity \u03b1]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\na : \u03b1\n\u22a2 comap (fun x => dist x a) (nhds 0) = comap (Prod.mk a) (uniformity \u03b1)"}, {"line": "simp only [Metric.uniformity_eq_comap_nhds_zero]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\na : \u03b1\n\u22a2 comap (fun x => dist x a) (nhds 0) = comap (Prod.mk a) (comap (fun p => dist p.1 p.2) (nhds 0))"}, {"line": "simp only [comap_comap]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\na : \u03b1\n\u22a2 comap (fun x => dist x a) (nhds 0) = comap ((fun p => dist p.1 p.2) \u2218 Prod.mk a) (nhds 0)"}, {"line": "simp only [Function.comp_def]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\na : \u03b1\n\u22a2 comap (fun x => dist x a) (nhds 0) = comap (fun x => dist a x) (nhds 0)"}, {"line": "simp only [dist_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_of_closed' {s : Set \u03b1} (hs : IsClosed s) {a : \u03b1} :\n    a \u2208 s \u2194 \u2200 \u03b5 > 0, \u2203 b \u2208 s, dist a b < \u03b5 := by\n  simpa only [hs.closure_eq] using @mem_closure_iff _ _ s a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Defs.lean", "context": {"open": ["Set Filter TopologicalSpace Bornology", "scoped ENNReal NNReal Uniformity Topology", "Lean Meta Qq Function", "Metric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}", "[PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nhs : IsClosed s\na : \u03b1\n\u22a2 a \u2208 s \u2194 \u2200 \u03b5 > 0, \u2203 b \u2208 s, dist a b < \u03b5"}, {"line": "simpa only [hs.closure_eq] using @mem_closure_iff _ _ s a", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Real.singleton_eq_inter_Icc (b : \u211d) : {b} = \u22c2 (r > 0), Icc (b - r) (b + r) := by\n  simp [Icc_eq_closedBall, biInter_basis_nhds Metric.nhds_basis_closedBall]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Lemmas.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology"], "variables": ["{\u03b9 \u03b1 : Type*} [PseudoMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u211d\n\u22a2 {b} = \u22c2 r, \u22c2 (_ : r > 0), Icc (b - r) (b + r)"}, {"line": "simp [Icc_eq_closedBall, biInter_basis_nhds Metric.nhds_basis_closedBall]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biInter_gt_closedBall (x : \u03b1) (r : \u211d) : \u22c2 r' > r, closedBall x r' = closedBall x r := by\n  ext\n  simp [forall_gt_imp_ge_iff_le_of_dense]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Lemmas.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology"], "variables": ["{\u03b9 \u03b1 : Type*} [PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\nr : \u211d\n\u22a2 \u22c2 r', \u22c2 (_ : r' > r), closedBall x r' = closedBall x r"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\nr : \u211d\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u22c2 r', \u22c2 (_ : r' > r), closedBall x r' \u2194 x\u271d \u2208 closedBall x r"}, {"line": "simp [forall_gt_imp_ge_iff_le_of_dense]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biInter_gt_ball (x : \u03b1) (r : \u211d) : \u22c2 r' > r, ball x r' = closedBall x r := by\n  ext\n  simp [forall_lt_iff_le']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Lemmas.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology"], "variables": ["{\u03b9 \u03b1 : Type*} [PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\nr : \u211d\n\u22a2 \u22c2 r', \u22c2 (_ : r' > r), ball x r' = closedBall x r"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\nr : \u211d\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u22c2 r', \u22c2 (_ : r' > r), ball x r' \u2194 x\u271d \u2208 closedBall x r"}, {"line": "simp [forall_lt_iff_le']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biUnion_lt_ball (x : \u03b1) (r : \u211d) : \u22c3 r' < r, ball x r' = ball x r := by\n  ext\n  rw [\u2190 not_iff_not]\n  simp [forall_lt_imp_le_iff_le_of_dense]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Lemmas.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology"], "variables": ["{\u03b9 \u03b1 : Type*} [PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\nr : \u211d\n\u22a2 \u22c3 r', \u22c3 (_ : r' < r), ball x r' = ball x r"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\nr : \u211d\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u22c3 r', \u22c3 (_ : r' < r), ball x r' \u2194 x\u271d \u2208 ball x r"}, {"line": "rw [\u2190 not_iff_not]", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\nr : \u211d\nx\u271d : \u03b1\n\u22a2 x\u271d \u2209 \u22c3 r', \u22c3 (_ : r' < r), ball x r' \u2194 x\u271d \u2209 ball x r"}, {"line": "simp [forall_lt_imp_le_iff_le_of_dense]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biUnion_lt_closedBall (x : \u03b1) (r : \u211d) : \u22c3 r' < r, closedBall x r' = ball x r := by\n  ext\n  rw [\u2190 not_iff_not]\n  simp [forall_lt_iff_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Lemmas.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology"], "variables": ["{\u03b9 \u03b1 : Type*} [PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\nr : \u211d\n\u22a2 \u22c3 r', \u22c3 (_ : r' < r), closedBall x r' = ball x r"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\nr : \u211d\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u22c3 r', \u22c3 (_ : r' < r), closedBall x r' \u2194 x\u271d \u2208 ball x r"}, {"line": "rw [\u2190 not_iff_not]", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\nr : \u211d\nx\u271d : \u03b1\n\u22a2 x\u271d \u2209 \u22c3 r', \u22c3 (_ : r' < r), closedBall x r' \u2194 x\u271d \u2209 ball x r"}, {"line": "simp [forall_lt_iff_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lebesgue_number_lemma_of_metric {s : Set \u03b1} {\u03b9 : Sort*} {c : \u03b9 \u2192 Set \u03b1} (hs : IsCompact s)\n    (hc\u2081 : \u2200 i, IsOpen (c i)) (hc\u2082 : s \u2286 \u22c3 i, c i) : \u2203 \u03b4 > 0, \u2200 x \u2208 s, \u2203 i, ball x \u03b4 \u2286 c i := by\n  simpa only [ball,UniformSpace.ball,preimage_setOf_eq,dist_comm]\n    using uniformity_basis_dist.lebesgue_number_lemma hs hc\u2081 hc\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Lemmas.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology"], "variables": ["{\u03b9 \u03b1 : Type*} [PseudoMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\n\u03b9 : Sort u_3\nc : \u03b9 \u2192 Set \u03b1\nhs : IsCompact s\nhc\u2081 : \u2200 (i : \u03b9), IsOpen (c i)\nhc\u2082 : s \u2286 \u22c3 i, c i\n\u22a2 \u2203 \u03b4 > 0, \u2200 x \u2208 s, \u2203 i, ball x \u03b4 \u2286 c i"}, {"line": "simpa only [ball,UniformSpace.ball,preimage_setOf_eq,dist_comm]\n    using uniformity_basis_dist.lebesgue_number_lemma hs hc\u2081 hc\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nndist_pi_le_iff {f g : \u2200 b, \u03c0 b} {r : \u211d\u22650} :\n    nndist f g \u2264 r \u2194 \u2200 b, nndist (f b) (g b) \u2264 r := by simp [nndist_pi_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Pi.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology", "Finset"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1]", "{\u03c0 : \u03b2 \u2192 Type*} [Fintype \u03b2] [\u2200 b, PseudoMetricSpace (\u03c0 b)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nf g : (b : \u03b2) \u2192 \u03c0 b\nr : NNReal\n\u22a2 nndist f g \u2264 r \u2194 \u2200 (b : \u03b2), nndist (f b) (g b) \u2264 r"}, {"line": "simp [nndist_pi_def]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nndist_pi_lt_iff {f g : \u2200 b, \u03c0 b} {r : \u211d\u22650} (hr : 0 < r) :\n    nndist f g < r \u2194 \u2200 b, nndist (f b) (g b) < r := by\n  rw [\u2190 bot_eq_zero'] at hr\n  simp [nndist_pi_def, Finset.sup_lt_iff hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Pi.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology", "Finset"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1]", "{\u03c0 : \u03b2 \u2192 Type*} [Fintype \u03b2] [\u2200 b, PseudoMetricSpace (\u03c0 b)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nf g : (b : \u03b2) \u2192 \u03c0 b\nr : NNReal\nhr : 0 < r\n\u22a2 nndist f g < r \u2194 \u2200 (b : \u03b2), nndist (f b) (g b) < r"}, {"line": "rw [\u2190 bot_eq_zero'] at hr", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nf g : (b : \u03b2) \u2192 \u03c0 b\nr : NNReal\nhr : \u22a5 < r\n\u22a2 nndist f g < r \u2194 \u2200 (b : \u03b2), nndist (f b) (g b) < r"}, {"line": "simp [nndist_pi_def, Finset.sup_lt_iff hr]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nndist_pi_eq_iff {f g : \u2200 b, \u03c0 b} {r : \u211d\u22650} (hr : 0 < r) :\n    nndist f g = r \u2194 (\u2203 i, nndist (f i) (g i) = r) \u2227 \u2200 b, nndist (f b) (g b) \u2264 r := by\n  rw [eq_iff_le_not_lt]\n  rw [nndist_pi_lt_iff hr]\n  rw [nndist_pi_le_iff]\n  rw [not_forall]\n  rw [and_comm]\n  simp_rw [not_lt, and_congr_left_iff, le_antisymm_iff]\n  intro h\n  refine exists_congr fun b => ?_\n  apply (and_iff_right <| h _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Pi.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology", "Finset"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1]", "{\u03c0 : \u03b2 \u2192 Type*} [Fintype \u03b2] [\u2200 b, PseudoMetricSpace (\u03c0 b)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nf g : (b : \u03b2) \u2192 \u03c0 b\nr : NNReal\nhr : 0 < r\n\u22a2 nndist f g = r \u2194 (\u2203 i, nndist (f i) (g i) = r) \u2227 \u2200 (b : \u03b2), nndist (f b) (g b) \u2264 r"}, {"line": "rw [eq_iff_le_not_lt]", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nf g : (b : \u03b2) \u2192 \u03c0 b\nr : NNReal\nhr : 0 < r\n\u22a2 nndist f g \u2264 r \u2227 \u00acnndist f g < r \u2194 (\u2203 i, nndist (f i) (g i) = r) \u2227 \u2200 (b : \u03b2), nndist (f b) (g b) \u2264 r"}, {"line": "rw [nndist_pi_lt_iff hr]", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nf g : (b : \u03b2) \u2192 \u03c0 b\nr : NNReal\nhr : 0 < r\n\u22a2 (nndist f g \u2264 r \u2227 \u00ac\u2200 (b : \u03b2), nndist (f b) (g b) < r) \u2194\n    (\u2203 i, nndist (f i) (g i) = r) \u2227 \u2200 (b : \u03b2), nndist (f b) (g b) \u2264 r"}, {"line": "rw [nndist_pi_le_iff]", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nf g : (b : \u03b2) \u2192 \u03c0 b\nr : NNReal\nhr : 0 < r\n\u22a2 ((\u2200 (b : \u03b2), nndist (f b) (g b) \u2264 r) \u2227 \u00ac\u2200 (b : \u03b2), nndist (f b) (g b) < r) \u2194\n    (\u2203 i, nndist (f i) (g i) = r) \u2227 \u2200 (b : \u03b2), nndist (f b) (g b) \u2264 r"}, {"line": "rw [not_forall]", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nf g : (b : \u03b2) \u2192 \u03c0 b\nr : NNReal\nhr : 0 < r\n\u22a2 ((\u2200 (b : \u03b2), nndist (f b) (g b) \u2264 r) \u2227 \u2203 x, \u00acnndist (f x) (g x) < r) \u2194\n    (\u2203 i, nndist (f i) (g i) = r) \u2227 \u2200 (b : \u03b2), nndist (f b) (g b) \u2264 r"}, {"line": "rw [and_comm]", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nf g : (b : \u03b2) \u2192 \u03c0 b\nr : NNReal\nhr : 0 < r\n\u22a2 ((\u2203 x, \u00acnndist (f x) (g x) < r) \u2227 \u2200 (b : \u03b2), nndist (f b) (g b) \u2264 r) \u2194\n    (\u2203 i, nndist (f i) (g i) = r) \u2227 \u2200 (b : \u03b2), nndist (f b) (g b) \u2264 r"}, {"line": "simp_rw [not_lt, and_congr_left_iff, le_antisymm_iff]", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nf g : (b : \u03b2) \u2192 \u03c0 b\nr : NNReal\nhr : 0 < r\n\u22a2 (\u2200 (b : \u03b2), nndist (f b) (g b) \u2264 r) \u2192\n    ((\u2203 x, r \u2264 nndist (f x) (g x)) \u2194 \u2203 i, nndist (f i) (g i) \u2264 r \u2227 r \u2264 nndist (f i) (g i))"}, {"line": "intro h", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nf g : (b : \u03b2) \u2192 \u03c0 b\nr : NNReal\nhr : 0 < r\nh : \u2200 (b : \u03b2), nndist (f b) (g b) \u2264 r\n\u22a2 (\u2203 x, r \u2264 nndist (f x) (g x)) \u2194 \u2203 i, nndist (f i) (g i) \u2264 r \u2227 r \u2264 nndist (f i) (g i)"}, {"line": "refine exists_congr fun b => ?_", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nf g : (b : \u03b2) \u2192 \u03c0 b\nr : NNReal\nhr : 0 < r\nh : \u2200 (b : \u03b2), nndist (f b) (g b) \u2264 r\nb : \u03b2\n\u22a2 r \u2264 nndist (f b) (g b) \u2194 nndist (f b) (g b) \u2264 r \u2227 r \u2264 nndist (f b) (g b)"}, {"line": "apply (and_iff_right <| h _).symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_pi_le_iff' [Nonempty \u03b2] {f g : \u2200 b, \u03c0 b} {r : \u211d} :\n    dist f g \u2264 r \u2194 \u2200 b, dist (f b) (g b) \u2264 r := by\n  by_cases hr : 0 \u2264 r\n  \u00b7 exact dist_pi_le_iff hr\n  \u00b7 exact iff_of_false (fun h => hr <| dist_nonneg.trans h) fun h =>\n      hr <| dist_nonneg.trans <| h <| Classical.arbitrary _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Pi.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology", "Finset"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1]", "{\u03c0 : \u03b2 \u2192 Type*} [Fintype \u03b2] [\u2200 b, PseudoMetricSpace (\u03c0 b)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b2 : Fintype \u03b2\ninst\u271d\u00b9 : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\ninst\u271d : Nonempty \u03b2\nf g : (b : \u03b2) \u2192 \u03c0 b\nr : \u211d\n\u22a2 dist f g \u2264 r \u2194 \u2200 (b : \u03b2), dist (f b) (g b) \u2264 r"}, {"line": "by_cases hr : 0 \u2264 r", "tactic_state": "case pos\n\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b2 : Fintype \u03b2\ninst\u271d\u00b9 : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\ninst\u271d : Nonempty \u03b2\nf g : (b : \u03b2) \u2192 \u03c0 b\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 dist f g \u2264 r \u2194 \u2200 (b : \u03b2), dist (f b) (g b) \u2264 r\n---\ncase neg\n\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b2 : Fintype \u03b2\ninst\u271d\u00b9 : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\ninst\u271d : Nonempty \u03b2\nf g : (b : \u03b2) \u2192 \u03c0 b\nr : \u211d\nhr : \u00ac0 \u2264 r\n\u22a2 dist f g \u2264 r \u2194 \u2200 (b : \u03b2), dist (f b) (g b) \u2264 r"}, {"line": "\u00b7 exact dist_pi_le_iff hr", "tactic_state": "case neg\n\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b2 : Fintype \u03b2\ninst\u271d\u00b9 : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\ninst\u271d : Nonempty \u03b2\nf g : (b : \u03b2) \u2192 \u03c0 b\nr : \u211d\nhr : \u00ac0 \u2264 r\n\u22a2 dist f g \u2264 r \u2194 \u2200 (b : \u03b2), dist (f b) (g b) \u2264 r"}, {"line": "\u00b7 exact iff_of_false (fun h => hr <| dist_nonneg.trans h) fun h =>\n      hr <| dist_nonneg.trans <| h <| Classical.arbitrary _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_pi_const [Nonempty \u03b2] (a b : \u03b1) : (dist (fun _ : \u03b2 => a) fun _ => b) = dist a b := by\n  simpa only [dist_edist] using congr_arg ENNReal.toReal (edist_pi_const a b)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Pi.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology", "Finset"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1]", "{\u03c0 : \u03b2 \u2192 Type*} [Fintype \u03b2] [\u2200 b, PseudoMetricSpace (\u03c0 b)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : Nonempty \u03b2\na b : \u03b1\n\u22a2 (dist (fun x => a) fun x => b) = dist a b"}, {"line": "simpa only [dist_edist] using congr_arg ENNReal.toReal (edist_pi_const a b)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nndist_le_pi_nndist (f g : \u2200 b, \u03c0 b) (b : \u03b2) : nndist (f b) (g b) \u2264 nndist f g := by\n  rw [\u2190 ENNReal.coe_le_coe]\n  rw [\u2190 edist_nndist]\n  rw [\u2190 edist_nndist]\n  exact edist_le_pi_edist f g b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Pi.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology", "Finset"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1]", "{\u03c0 : \u03b2 \u2192 Type*} [Fintype \u03b2] [\u2200 b, PseudoMetricSpace (\u03c0 b)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nf g : (b : \u03b2) \u2192 \u03c0 b\nb : \u03b2\n\u22a2 nndist (f b) (g b) \u2264 nndist f g"}, {"line": "rw [\u2190 ENNReal.coe_le_coe]", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nf g : (b : \u03b2) \u2192 \u03c0 b\nb : \u03b2\n\u22a2 \u2191(nndist (f b) (g b)) \u2264 \u2191(nndist f g)"}, {"line": "rw [\u2190 edist_nndist]", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nf g : (b : \u03b2) \u2192 \u03c0 b\nb : \u03b2\n\u22a2 edist (f b) (g b) \u2264 \u2191(nndist f g)"}, {"line": "rw [\u2190 edist_nndist]", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nf g : (b : \u03b2) \u2192 \u03c0 b\nb : \u03b2\n\u22a2 edist (f b) (g b) \u2264 edist f g"}, {"line": "exact edist_le_pi_edist f g b", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ball_pi (x : \u2200 b, \u03c0 b) {r : \u211d} (hr : 0 < r) :\n    ball x r = Set.pi univ fun b => ball (x b) r := by\n  ext p\n  simp [dist_pi_lt_iff hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Pi.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology", "Finset"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1]", "{\u03c0 : \u03b2 \u2192 Type*} [Fintype \u03b2] [\u2200 b, PseudoMetricSpace (\u03c0 b)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nx : (b : \u03b2) \u2192 \u03c0 b\nr : \u211d\nhr : 0 < r\n\u22a2 ball x r = Set.univ.pi fun b => ball (x b) r"}, {"line": "ext p", "tactic_state": "case h\n\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nx : (b : \u03b2) \u2192 \u03c0 b\nr : \u211d\nhr : 0 < r\np : (b : \u03b2) \u2192 \u03c0 b\n\u22a2 p \u2208 ball x r \u2194 p \u2208 Set.univ.pi fun b => ball (x b) r"}, {"line": "simp [dist_pi_lt_iff hr]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma closedBall_pi (x : \u2200 b, \u03c0 b) {r : \u211d} (hr : 0 \u2264 r) :\n    closedBall x r = Set.pi univ fun b => closedBall (x b) r := by\n  ext p\n  simp [dist_pi_le_iff hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Pi.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology", "Finset"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1]", "{\u03c0 : \u03b2 \u2192 Type*} [Fintype \u03b2] [\u2200 b, PseudoMetricSpace (\u03c0 b)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nx : (b : \u03b2) \u2192 \u03c0 b\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 closedBall x r = Set.univ.pi fun b => closedBall (x b) r"}, {"line": "ext p", "tactic_state": "case h\n\u03b2 : Type u_2\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nx : (b : \u03b2) \u2192 \u03c0 b\nr : \u211d\nhr : 0 \u2264 r\np : (b : \u03b2) \u2192 \u03c0 b\n\u22a2 p \u2208 closedBall x r \u2194 p \u2208 Set.univ.pi fun b => closedBall (x b) r"}, {"line": "simp [dist_pi_le_iff hr]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Fin.dist_insertNth_insertNth {n : \u2115} {\u03b1 : Fin (n + 1) \u2192 Type*}\n    [\u2200 i, PseudoMetricSpace (\u03b1 i)] (i : Fin (n + 1)) (x y : \u03b1 i) (f g : \u2200 j, \u03b1 (i.succAbove j)) :\n    dist (i.insertNth x f) (i.insertNth y g) = max (dist x y) (dist f g) := by\n  simp only [dist_nndist]\n  simp only [Fin.nndist_insertNth_insertNth]\n  simp only [NNReal.coe_max]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Pseudo/Pi.lean", "context": {"open": ["Bornology Filter Metric Set", "scoped NNReal Topology", "Finset"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1]", "{\u03c0 : \u03b2 \u2192 Type*} [Fintype \u03b2] [\u2200 b, PseudoMetricSpace (\u03c0 b)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_4\ninst\u271d : (i : Fin (n + 1)) \u2192 PseudoMetricSpace (\u03b1 i)\ni : Fin (n + 1)\nx y : \u03b1 i\nf g : (j : Fin n) \u2192 \u03b1 (i.succAbove j)\n\u22a2 dist (i.insertNth x f) (i.insertNth y g) = max (dist x y) (dist f g)"}, {"line": "simp only [dist_nndist]", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_4\ninst\u271d : (i : Fin (n + 1)) \u2192 PseudoMetricSpace (\u03b1 i)\ni : Fin (n + 1)\nx y : \u03b1 i\nf g : (j : Fin n) \u2192 \u03b1 (i.succAbove j)\n\u22a2 \u2191(nndist (i.insertNth x f) (i.insertNth y g)) = max \u2191(nndist x y) \u2191(nndist f g)"}, {"line": "simp only [Fin.nndist_insertNth_insertNth]", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_4\ninst\u271d : (i : Fin (n + 1)) \u2192 PseudoMetricSpace (\u03b1 i)\ni : Fin (n + 1)\nx y : \u03b1 i\nf g : (j : Fin n) \u2192 \u03b1 (i.succAbove j)\n\u22a2 \u2191(max (nndist x y) (nndist f g)) = max \u2191(nndist x y) \u2191(nndist f g)"}, {"line": "simp only [NNReal.coe_max]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isOpen_sphere {r : \u211d} (hr : r \u2260 0) : IsOpen (sphere x r) := by\n  rw [\u2190 closedBall_diff_ball]\n  rw [sdiff_eq]\n  exact (isOpen_closedBall x hr).inter (isClosed_ball x r).isOpen_compl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/MetricSpace/Ultra/Basic.lean", "context": {"open": ["Metric"], "variables": ["{X : Type*}", "[PseudoMetricSpace X] [IsUltrametricDist X] (x y z : X) (r s : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : PseudoMetricSpace X\ninst\u271d : IsUltrametricDist X\nx : X\nr : \u211d\nhr : r \u2260 0\n\u22a2 IsOpen (sphere x r)"}, {"line": "rw [\u2190 closedBall_diff_ball]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : PseudoMetricSpace X\ninst\u271d : IsUltrametricDist X\nx : X\nr : \u211d\nhr : r \u2260 0\n\u22a2 IsOpen (closedBall x r \\ ball x r)"}, {"line": "rw [sdiff_eq]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : PseudoMetricSpace X\ninst\u271d : IsUltrametricDist X\nx : X\nr : \u211d\nhr : r \u2260 0\n\u22a2 IsOpen (closedBall x r \u2293 (ball x r)\u1d9c)"}, {"line": "exact (isOpen_closedBall x hr).inter (isClosed_ball x r).isOpen_compl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UniformSpace.metrizableSpace [UniformSpace X] [IsCountablyGenerated (\ud835\udce4 X)] [T0Space X] :\n    TopologicalSpace.MetrizableSpace X := by\n  letI := UniformSpace.metricSpace X\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Metrizable/Uniformity.lean", "context": {"open": ["Set Function Metric List Filter", "NNReal Filter Uniformity"], "variables": ["{X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : UniformSpace X\ninst\u271d\u00b9 : (uniformity X).IsCountablyGenerated\ninst\u271d : T0Space X\n\u22a2 TopologicalSpace.MetrizableSpace X"}, {"line": "letI := UniformSpace.metricSpace X", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : UniformSpace X\ninst\u271d\u00b9 : (uniformity X).IsCountablyGenerated\ninst\u271d : T0Space X\nthis : MetricSpace X := sorry\n\u22a2 TopologicalSpace.MetrizableSpace X"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLocallyClosed_Ioc [LinearOrder X] [ClosedIicTopology X] :\n    IsLocallyClosed (Set.Ioc a b) := by\n  rw [\u2190 Set.Iic_inter_Ioi]\n  exact isLocallyClosed_Iic.inter isLocallyClosed_Ioi\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/IsLocallyClosed.lean", "context": {"open": [], "variables": ["{X : Type*} [TopologicalSpace X] {a b : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\na b : X\ninst\u271d\u00b9 : LinearOrder X\ninst\u271d : ClosedIicTopology X\n\u22a2 IsLocallyClosed (Set.Ioc a b)"}, {"line": "rw [\u2190 Set.Iic_inter_Ioi]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\na b : X\ninst\u271d\u00b9 : LinearOrder X\ninst\u271d : ClosedIicTopology X\n\u22a2 IsLocallyClosed (Set.Iic b \u2229 Set.Ioi a)"}, {"line": "exact isLocallyClosed_Iic.inter isLocallyClosed_Ioi", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLocallyClosed_Ico [LinearOrder X] [ClosedIciTopology X] :\n    IsLocallyClosed (Set.Ico a b) := by\n  rw [\u2190 Set.Iio_inter_Ici]\n  exact isLocallyClosed_Iio.inter isLocallyClosed_Ici", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/IsLocallyClosed.lean", "context": {"open": [], "variables": ["{X : Type*} [TopologicalSpace X] {a b : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\na b : X\ninst\u271d\u00b9 : LinearOrder X\ninst\u271d : ClosedIciTopology X\n\u22a2 IsLocallyClosed (Set.Ico a b)"}, {"line": "rw [\u2190 Set.Iio_inter_Ici]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\na b : X\ninst\u271d\u00b9 : LinearOrder X\ninst\u271d : ClosedIciTopology X\n\u22a2 IsLocallyClosed (Set.Iio b \u2229 Set.Ici a)"}, {"line": "exact isLocallyClosed_Iio.inter isLocallyClosed_Ici", "tactic_state": "No Goals!"}]}
{"declaration": "lemma finset_sup'_nhds_apply [SemilatticeSup L] [ContinuousSup L]\n    (hne : s.Nonempty) (hs : \u2200 i \u2208 s, Tendsto (f i) l (\ud835\udcdd (g i))) :\n    Tendsto (fun a \u21a6 s.sup' hne (f \u00b7 a)) l (\ud835\udcdd (s.sup' hne g)) := by\n  simpa only [\u2190 Finset.sup'_apply] using finset_sup'_nhds hne hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/Lattice.lean", "context": {"open": ["Filter", "Topology", "Finset"], "variables": ["{L X : Type*} [TopologicalSpace L] [TopologicalSpace X]", "{\u03b1 : Type*} {l : Filter \u03b1} {f g : \u03b1 \u2192 L} {x y : L}", "{\u03b9 \u03b1 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1 \u2192 L} {l : Filter \u03b1} {g : \u03b9 \u2192 L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : Type u_1\ninst\u271d\u00b2 : TopologicalSpace L\n\u03b9 : Type u_4\n\u03b1 : Type u_5\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 L\nl : Filter \u03b1\ng : \u03b9 \u2192 L\ninst\u271d\u00b9 : SemilatticeSup L\ninst\u271d : ContinuousSup L\nhne : s.Nonempty\nhs : \u2200 i \u2208 s, Tendsto (f i) l (nhds (g i))\n\u22a2 Tendsto (fun a => s.sup' hne fun x => f x a) l (nhds (s.sup' hne g))"}, {"line": "simpa only [\u2190 Finset.sup'_apply] using finset_sup'_nhds hne hs", "tactic_state": "No Goals!"}]}
{"declaration": "lemma finset_sup_nhds_apply [SemilatticeSup L] [OrderBot L] [ContinuousSup L]\n    (hs : \u2200 i \u2208 s, Tendsto (f i) l (\ud835\udcdd (g i))) :\n    Tendsto (fun a \u21a6 s.sup (f \u00b7 a)) l (\ud835\udcdd (s.sup g)) := by\n  simpa only [\u2190 Finset.sup_apply] using finset_sup_nhds hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/Lattice.lean", "context": {"open": ["Filter", "Topology", "Finset"], "variables": ["{L X : Type*} [TopologicalSpace L] [TopologicalSpace X]", "{\u03b1 : Type*} {l : Filter \u03b1} {f g : \u03b1 \u2192 L} {x y : L}", "{\u03b9 \u03b1 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1 \u2192 L} {l : Filter \u03b1} {g : \u03b9 \u2192 L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : Type u_1\ninst\u271d\u00b3 : TopologicalSpace L\n\u03b9 : Type u_4\n\u03b1 : Type u_5\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 L\nl : Filter \u03b1\ng : \u03b9 \u2192 L\ninst\u271d\u00b2 : SemilatticeSup L\ninst\u271d\u00b9 : OrderBot L\ninst\u271d : ContinuousSup L\nhs : \u2200 i \u2208 s, Tendsto (f i) l (nhds (g i))\n\u22a2 Tendsto (fun a => s.sup fun x => f x a) l (nhds (s.sup g))"}, {"line": "simpa only [\u2190 Finset.sup_apply] using finset_sup_nhds hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ioi_mem_nhdsSet_Ici_iff : Ioi a \u2208 \ud835\udcdd\u02e2 (Ici b) \u2194 a < b := by\n  rw [isOpen_Ioi.mem_nhdsSet]\n  rw [Ici_subset_Ioi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/NhdsSet.lean", "context": {"open": ["Set Filter OrderDual", "scoped Topology"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : OrderClosedTopology \u03b1\na b : \u03b1\n\u22a2 Ioi a \u2208 nhdsSet (Ici b) \u2194 a < b"}, {"line": "rw [isOpen_Ioi.mem_nhdsSet]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : OrderClosedTopology \u03b1\na b : \u03b1\n\u22a2 Ici b \u2286 Ioi a \u2194 a < b\n---\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : OrderClosedTopology \u03b1\na b : \u03b1\n\u22a2 ClosedIicTopology \u03b1"}, {"line": "rw [Ici_subset_Ioi]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : OrderClosedTopology \u03b1\na b : \u03b1\n\u22a2 ClosedIicTopology \u03b1"}]}
{"declaration": "protected lemma ContinuousAt.partialSups (hf : \u2200 k \u2264 n, ContinuousAt (f k) x) :\n    ContinuousAt (partialSups f n) x := by\n  simpa only [\u2190 Pi.partialSups_apply] using ContinuousAt.partialSups_apply hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/PartialSups.lean", "context": {"open": ["Filter", "scoped Topology"], "variables": ["{L : Type*} [SemilatticeSup L] [TopologicalSpace L] [ContinuousSup L]", "{\u03b1 : Type*} {l : Filter \u03b1} {f : \u2115 \u2192 \u03b1 \u2192 L} {g : \u2115 \u2192 L} {n : \u2115}", "{X : Type*} [TopologicalSpace X] {f : \u2115 \u2192 X \u2192 L} {n : \u2115} {s : Set X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : Type u_1\ninst\u271d\u00b3 : SemilatticeSup L\ninst\u271d\u00b2 : TopologicalSpace L\ninst\u271d\u00b9 : ContinuousSup L\nX : Type u_3\ninst\u271d : TopologicalSpace X\nf : \u2115 \u2192 X \u2192 L\nn : \u2115\nx : X\nhf : \u2200 k \u2264 n, ContinuousAt (f k) x\n\u22a2 ContinuousAt ((partialSups f) n) x"}, {"line": "simpa only [\u2190 Pi.partialSups_apply] using ContinuousAt.partialSups_apply hf", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma ContinuousWithinAt.partialSups (hf : \u2200 k \u2264 n, ContinuousWithinAt (f k) s x) :\n    ContinuousWithinAt (partialSups f n) s x := by\n  simpa only [\u2190 Pi.partialSups_apply] using ContinuousWithinAt.partialSups_apply hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/PartialSups.lean", "context": {"open": ["Filter", "scoped Topology"], "variables": ["{L : Type*} [SemilatticeSup L] [TopologicalSpace L] [ContinuousSup L]", "{\u03b1 : Type*} {l : Filter \u03b1} {f : \u2115 \u2192 \u03b1 \u2192 L} {g : \u2115 \u2192 L} {n : \u2115}", "{X : Type*} [TopologicalSpace X] {f : \u2115 \u2192 X \u2192 L} {n : \u2115} {s : Set X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : Type u_1\ninst\u271d\u00b3 : SemilatticeSup L\ninst\u271d\u00b2 : TopologicalSpace L\ninst\u271d\u00b9 : ContinuousSup L\nX : Type u_3\ninst\u271d : TopologicalSpace X\nf : \u2115 \u2192 X \u2192 L\nn : \u2115\ns : Set X\nx : X\nhf : \u2200 k \u2264 n, ContinuousWithinAt (f k) s x\n\u22a2 ContinuousWithinAt ((partialSups f) n) s x"}, {"line": "simpa only [\u2190 Pi.partialSups_apply] using ContinuousWithinAt.partialSups_apply hf", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dirSupInacc_iff_forall_sSup :\n    DirSupInacc s \u2194 \u2200 \u2983d\u2984, d.Nonempty \u2192 DirectedOn (\u00b7 \u2264 \u00b7) d \u2192 sSup d \u2208 s \u2192 (d \u2229 s).Nonempty := by\n  simp [DirSupInacc, isLUB_iff_sSup_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/ScottTopology.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] {s t : Set \u03b1}", "[CompleteLattice \u03b1] {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\n\u22a2 DirSupInacc s \u2194 \u2200 \u2983d : Set \u03b1\u2984, d.Nonempty \u2192 DirectedOn (fun x1 x2 => x1 \u2264 x2) d \u2192 sSup d \u2208 s \u2192 (d \u2229 s).Nonempty"}, {"line": "simp [DirSupInacc, isLUB_iff_sSup_eq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\n\u22a2 (\u2200 \u2983d : Set \u03b1\u2984, d.Nonempty \u2192 DirectedOn (fun x1 x2 => x1 \u2264 x2) d \u2192 \u2200 \u2983a : \u03b1\u2984, IsLUB d a \u2192 a \u2208 s \u2192 (d \u2229 s).Nonempty) \u2194\n    \u2200 \u2983d : Set \u03b1\u2984, d.Nonempty \u2192 DirectedOn (fun x1 x2 => x1 \u2264 x2) d \u2192 sSup d \u2208 s \u2192 (d \u2229 s).Nonempty"}]}
{"declaration": "lemma dirSupClosed_iff_forall_sSup :\n    DirSupClosed s \u2194 \u2200 \u2983d\u2984, d.Nonempty \u2192 DirectedOn (\u00b7 \u2264 \u00b7) d \u2192 d \u2286 s \u2192 sSup d \u2208 s := by\n  simp [DirSupClosed, isLUB_iff_sSup_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/ScottTopology.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] {s t : Set \u03b1}", "[CompleteLattice \u03b1] {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\n\u22a2 DirSupClosed s \u2194 \u2200 \u2983d : Set \u03b1\u2984, d.Nonempty \u2192 DirectedOn (fun x1 x2 => x1 \u2264 x2) d \u2192 d \u2286 s \u2192 sSup d \u2208 s"}, {"line": "simp [DirSupClosed, isLUB_iff_sSup_eq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\n\u22a2 (\u2200 \u2983d : Set \u03b1\u2984, d.Nonempty \u2192 DirectedOn (fun x1 x2 => x1 \u2264 x2) d \u2192 \u2200 \u2983a : \u03b1\u2984, IsLUB d a \u2192 d \u2286 s \u2192 a \u2208 s) \u2194\n    \u2200 \u2983d : Set \u03b1\u2984, d.Nonempty \u2192 DirectedOn (fun x1 x2 => x1 \u2264 x2) d \u2192 d \u2286 s \u2192 sSup d \u2208 s"}]}
{"declaration": "lemma closure_eq_lowerClosure {s : Set \u03b1} : closure s = lowerClosure s := by\n  rw [subset_antisymm_iff]\n  refine \u27e8?_, lowerClosure_min subset_closure (isClosed_iff_isLower.1 isClosed_closure)\u27e9\n  \u00b7 apply closure_minimal subset_lowerClosure _\n    rw [isClosed_iff_isLower]\n    exact LowerSet.lower (lowerClosure s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/UpperLowerSetTopology.lean", "context": {"open": ["Set TopologicalSpace"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[Preorder \u03b1] [Preorder \u03b2]", "[Preorder \u03b1]", "(\u03b1)", "[Preorder \u03b1] [TopologicalSpace \u03b1] [Topology.IsUpperSet \u03b1] {s : Set \u03b1}", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : Topology.IsUpperSet \u03b1\ns : Set \u03b1\n\u22a2 closure s = \u2191(lowerClosure s)"}, {"line": "rw [subset_antisymm_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : Topology.IsUpperSet \u03b1\ns : Set \u03b1\n\u22a2 closure s \u2286 \u2191(lowerClosure s) \u2227 \u2191(lowerClosure s) \u2286 closure s"}, {"line": "refine \u27e8?_, lowerClosure_min subset_closure (isClosed_iff_isLower.1 isClosed_closure)\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : Topology.IsUpperSet \u03b1\ns : Set \u03b1\n\u22a2 closure s \u2286 \u2191(lowerClosure s)"}, {"line": "\u00b7 apply closure_minimal subset_lowerClosure _\n    rw [isClosed_iff_isLower]\n    exact LowerSet.lower (lowerClosure s)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isUpperSet_orderDual [Preorder \u03b1] [TopologicalSpace \u03b1] :\n    Topology.IsUpperSet \u03b1\u1d52\u1d48 \u2194 Topology.IsLowerSet \u03b1 := by\n  constructor\n  \u00b7 apply OrderDual.instIsLowerSet\n  \u00b7 apply OrderDual.instIsUpperSet\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/UpperLowerSetTopology.lean", "context": {"open": ["Set TopologicalSpace", "Topology", "Topology", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[Preorder \u03b1] [Preorder \u03b2]", "[Preorder \u03b1]", "(\u03b1)", "[Preorder \u03b1] [TopologicalSpace \u03b1] [Topology.IsUpperSet \u03b1] {s : Set \u03b1}", "{\u03b1}", "[Preorder \u03b1] [Preorder \u03b2]", "(\u03b1)", "[Preorder \u03b1] [TopologicalSpace \u03b1] [Topology.IsLowerSet \u03b1] {s : Set \u03b1}", "{\u03b1}", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 inst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Topology.IsUpperSet \u03b1\ninst\u271d\u2076 inst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Topology.IsLowerSet \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 Topology.IsUpperSet \u03b1\u1d52\u1d48 \u2194 Topology.IsLowerSet \u03b1"}, {"line": "constructor", "tactic_state": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 inst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Topology.IsUpperSet \u03b1\ninst\u271d\u2076 inst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Topology.IsLowerSet \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 Topology.IsUpperSet \u03b1\u1d52\u1d48 \u2192 Topology.IsLowerSet \u03b1\n---\ncase mpr\n\u03b1 : Type u_1\ninst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 inst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Topology.IsUpperSet \u03b1\ninst\u271d\u2076 inst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Topology.IsLowerSet \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 Topology.IsLowerSet \u03b1 \u2192 Topology.IsUpperSet \u03b1\u1d52\u1d48"}, {"line": "\u00b7 apply OrderDual.instIsLowerSet", "tactic_state": "case mpr\n\u03b1 : Type u_1\ninst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 inst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Topology.IsUpperSet \u03b1\ninst\u271d\u2076 inst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Topology.IsLowerSet \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 Topology.IsLowerSet \u03b1 \u2192 Topology.IsUpperSet \u03b1\u1d52\u1d48"}, {"line": "\u00b7 apply OrderDual.instIsUpperSet", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsGE_eq_iInf_inf_principal [TopologicalSpace \u03b1] [Preorder \u03b1] [OrderTopology \u03b1] (a : \u03b1) :\n    \ud835\udcdd[\u2265] a = (\u2a05 (u) (_ : a < u), \ud835\udcdf (Iio u)) \u2293 \ud835\udcdf (Ici a) := by\n  rw [nhdsWithin]\n  rw [nhds_eq_order]\n  refine le_antisymm (inf_le_inf_right _ inf_le_right) (le_inf (le_inf ?_ inf_le_left) inf_le_right)\n  exact inf_le_right.trans (le_iInf\u2082 fun l hl => principal_mono.2 <| Ici_subset_Ioi.2 hl)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/Basic.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[TopologicalSpace \u03b1] [Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Ici a) = (\u2a05 u, \u2a05 (_ : a < u), principal (Iio u)) \u2293 principal (Ici a)"}, {"line": "rw [nhdsWithin]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\n\u22a2 nhds a \u2293 principal (Ici a) = (\u2a05 u, \u2a05 (_ : a < u), principal (Iio u)) \u2293 principal (Ici a)"}, {"line": "rw [nhds_eq_order]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\n\u22a2 ((\u2a05 b \u2208 Iio a, principal (Ioi b)) \u2293 \u2a05 b \u2208 Ioi a, principal (Iio b)) \u2293 principal (Ici a) =\n    (\u2a05 u, \u2a05 (_ : a < u), principal (Iio u)) \u2293 principal (Ici a)\n---\n\u03b1 : Type u\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\n\u22a2 Preorder \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\n\u22a2 OrderTopology \u03b1"}, {"line": "refine le_antisymm (inf_le_inf_right _ inf_le_right) (le_inf (le_inf ?_ inf_le_left) inf_le_right)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\n\u22a2 (\u2a05 u, \u2a05 (_ : a < u), principal (Iio u)) \u2293 principal (Ici a) \u2264 \u2a05 b \u2208 Iio a, principal (Ioi b)\n---\n\u03b1 : Type u\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\n\u22a2 OrderTopology \u03b1"}, {"line": "exact inf_le_right.trans (le_iInf\u2082 fun l hl => principal_mono.2 <| Ici_subset_Ioi.2 hl)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\n\u22a2 OrderTopology \u03b1"}]}
{"declaration": "theorem cocompact_le_atBot [OrderTop \u03b1] [CompactIccSpace \u03b1] :\n    cocompact \u03b1 \u2264 atBot := by\n  refine fun _ hs \u21a6 mem_cocompact.mpr <| (isEmpty_or_nonempty \u03b1).casesOn ?_ ?_ <;> intro\n  \u00b7 exact \u27e8\u2205, isCompact_empty, fun x _ \u21a6 (IsEmpty.false x).elim\u27e9\n  \u00b7 obtain \u27e8t, ht\u27e9 := mem_atBot_sets.mp hs\n    refine \u27e8Icc t \u22a4, isCompact_Icc, fun _ hx \u21a6 ?_\u27e9\n    exact (not_and_or.mp hx).casesOn (fun h \u21a6 ht _ (le_of_not_le h)) (fun h \u21a6 (h le_top).elim)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/Compact.lean", "context": {"open": ["Filter OrderDual TopologicalSpace Function Set", "scoped Filter Topology"], "variables": ["{\u03b1 : Type*}", "{\u03b1 : Type*} [Preorder \u03b1] [TopologicalSpace \u03b1] [CompactIccSpace \u03b1]", "{\u03b1 : Type*} [LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderTopology \u03b1] [DenselyOrdered \u03b1]", "{\u03b1 \u03b2 \u03b3 : Type*} [LinearOrder \u03b1] [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ninst\u271d : CompactIccSpace \u03b1\n\u22a2 cocompact \u03b1 \u2264 atBot"}, {"line": "refine fun _ hs \u21a6 mem_cocompact.mpr <| (isEmpty_or_nonempty \u03b1).casesOn ?_ ?_ <;> intro", "tactic_state": "case refine_1\n\u03b1 : Type u_4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ninst\u271d : CompactIccSpace \u03b1\nx\u271d : Set \u03b1\nhs : x\u271d \u2208 atBot\nh\u271d : IsEmpty \u03b1\n\u22a2 \u2203 t, IsCompact t \u2227 t\u1d9c \u2286 x\u271d\n---\ncase refine_2\n\u03b1 : Type u_4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ninst\u271d : CompactIccSpace \u03b1\nx\u271d : Set \u03b1\nhs : x\u271d \u2208 atBot\nh\u271d : Nonempty \u03b1\n\u22a2 \u2203 t, IsCompact t \u2227 t\u1d9c \u2286 x\u271d"}, {"line": "\u00b7 exact \u27e8\u2205, isCompact_empty, fun x _ \u21a6 (IsEmpty.false x).elim\u27e9", "tactic_state": "case refine_2\n\u03b1 : Type u_4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ninst\u271d : CompactIccSpace \u03b1\nx\u271d : Set \u03b1\nhs : x\u271d \u2208 atBot\nh\u271d : Nonempty \u03b1\n\u22a2 \u2203 t, IsCompact t \u2227 t\u1d9c \u2286 x\u271d"}, {"line": "\u00b7 obtain \u27e8t, ht\u27e9 := mem_atBot_sets.mp hs\n    refine \u27e8Icc t \u22a4, isCompact_Icc, fun _ hx \u21a6 ?_\u27e9\n    exact (not_and_or.mp hx).casesOn (fun h \u21a6 ht _ (le_of_not_le h)) (fun h \u21a6 (h le_top).elim)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCompact.exists_forall_le' [ClosedIicTopology \u03b1] [NoMaxOrder \u03b1] {f : \u03b2 \u2192 \u03b1}\n    {s : Set \u03b2} (hs : IsCompact s) (hf : ContinuousOn f s) {a : \u03b1} (hf' : \u2200 b \u2208 s, a < f b) :\n    \u2203 a', a < a' \u2227 \u2200 b \u2208 s, a' \u2264 f b := by\n  rcases s.eq_empty_or_nonempty with (rfl | hs')\n  \u00b7 obtain \u27e8a', ha'\u27e9 := exists_gt a\n    exact \u27e8a', ha', fun _ a \u21a6 a.elim\u27e9\n  \u00b7 obtain \u27e8x, hx, hx'\u27e9 := hs.exists_isMinOn hs' hf\n    exact \u27e8f x, hf' x hx, hx'\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/Compact.lean", "context": {"open": ["Filter OrderDual TopologicalSpace Function Set", "scoped Filter Topology"], "variables": ["{\u03b1 : Type*}", "{\u03b1 : Type*} [Preorder \u03b1] [TopologicalSpace \u03b1] [CompactIccSpace \u03b1]", "{\u03b1 : Type*} [LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderTopology \u03b1] [DenselyOrdered \u03b1]", "{\u03b1 \u03b2 \u03b3 : Type*} [LinearOrder \u03b1] [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : NoMaxOrder \u03b1\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\nhs : sorry\nhf : sorry\na : \u03b1\nhf' : \u2200 b \u2208 s, a < f b\n\u22a2 \u2203 a', a < a' \u2227 \u2200 b \u2208 s, a' \u2264 f b"}, {"line": "rcases s.eq_empty_or_nonempty with (rfl | hs')", "tactic_state": "case inl\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : NoMaxOrder \u03b1\nf : \u03b2 \u2192 \u03b1\nhs : sorry\nhf : sorry\na : \u03b1\nhf' : \u2200 b \u2208 \u2205, a < f b\n\u22a2 \u2203 a', a < a' \u2227 \u2200 b \u2208 \u2205, a' \u2264 f b\n---\ncase inr\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : NoMaxOrder \u03b1\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\nhs : sorry\nhf : sorry\na : \u03b1\nhf' : \u2200 b \u2208 s, a < f b\nhs' : s.Nonempty\n\u22a2 \u2203 a', a < a' \u2227 \u2200 b \u2208 s, a' \u2264 f b"}, {"line": "\u00b7 obtain \u27e8a', ha'\u27e9 := exists_gt a\n    exact \u27e8a', ha', fun _ a \u21a6 a.elim\u27e9", "tactic_state": "case inr\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : NoMaxOrder \u03b1\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\nhs : sorry\nhf : sorry\na : \u03b1\nhf' : \u2200 b \u2208 s, a < f b\nhs' : s.Nonempty\n\u22a2 \u2203 a', a < a' \u2227 \u2200 b \u2208 s, a' \u2264 f b"}, {"line": "\u00b7 obtain \u27e8x, hx, hx'\u27e9 := hs.exists_isMinOn hs' hf\n    exact \u27e8f x, hf' x hx, hx'\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCompact.bddBelow [ClosedIicTopology \u03b1] [Nonempty \u03b1] {s : Set \u03b1} (hs : IsCompact s) :\n    BddBelow s := by\n  rcases s.eq_empty_or_nonempty with rfl | hne\n  \u00b7 exact bddBelow_empty\n  \u00b7 obtain \u27e8a, -, has\u27e9 := hs.exists_isLeast hne\n    exact \u27e8a, has\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/Compact.lean", "context": {"open": ["Filter OrderDual TopologicalSpace Function Set", "scoped Filter Topology"], "variables": ["{\u03b1 : Type*}", "{\u03b1 : Type*} [Preorder \u03b1] [TopologicalSpace \u03b1] [CompactIccSpace \u03b1]", "{\u03b1 : Type*} [LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderTopology \u03b1] [DenselyOrdered \u03b1]", "{\u03b1 \u03b2 \u03b3 : Type*} [LinearOrder \u03b1] [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : Nonempty \u03b1\ns : Set \u03b1\nhs : IsCompact s\n\u22a2 BddBelow s"}, {"line": "rcases s.eq_empty_or_nonempty with rfl | hne", "tactic_state": "case inl\n\u03b1 : Type u_4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : Nonempty \u03b1\nhs : IsCompact \u2205\n\u22a2 BddBelow \u2205\n---\ncase inr\n\u03b1 : Type u_4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : Nonempty \u03b1\ns : Set \u03b1\nhs : IsCompact s\nhne : s.Nonempty\n\u22a2 BddBelow s"}, {"line": "\u00b7 exact bddBelow_empty", "tactic_state": "case inr\n\u03b1 : Type u_4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : Nonempty \u03b1\ns : Set \u03b1\nhs : IsCompact s\nhne : s.Nonempty\n\u22a2 BddBelow s"}, {"line": "\u00b7 obtain \u27e8a, -, has\u27e9 := hs.exists_isLeast hne\n    exact \u27e8a, has\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem interior_Icc [NoMinOrder \u03b1] [NoMaxOrder \u03b1] {a b : \u03b1} : interior (Icc a b) = Ioo a b := by\n  rw [\u2190 Ici_inter_Iic]\n  rw [interior_inter]\n  rw [interior_Ici]\n  rw [interior_Iic]\n  rw [Ioi_inter_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/DenselyOrdered.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 \u03b2 : Type*}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [DenselyOrdered \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 interior (Icc a b) = Ioo a b"}, {"line": "rw [\u2190 Ici_inter_Iic]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 interior (Ici a \u2229 Iic b) = Ioo a b"}, {"line": "rw [interior_inter]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 interior (Ici a) \u2229 interior (Iic b) = Ioo a b"}, {"line": "rw [interior_Ici]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 Ioi a \u2229 interior (Iic b) = Ioo a b\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 OrderTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 DenselyOrdered \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 NoMinOrder \u03b1"}, {"line": "rw [interior_Iic]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 Ioi a \u2229 Iio b = Ioo a b\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 OrderTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 DenselyOrdered \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 NoMaxOrder \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 OrderTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 DenselyOrdered \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 NoMinOrder \u03b1"}, {"line": "rw [Ioi_inter_Iio]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 OrderTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 DenselyOrdered \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 NoMaxOrder \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 OrderTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 DenselyOrdered \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 NoMinOrder \u03b1"}]}
{"declaration": "theorem Icc_mem_nhds_iff [NoMinOrder \u03b1] [NoMaxOrder \u03b1] {a b x : \u03b1} :\n    Icc a b \u2208 \ud835\udcdd x \u2194 x \u2208 Ioo a b := by\n  rw [\u2190 interior_Icc]\n  rw [mem_interior_iff_mem_nhds]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/DenselyOrdered.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 \u03b2 : Type*}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [DenselyOrdered \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 Icc a b \u2208 nhds x \u2194 x \u2208 Ioo a b"}, {"line": "rw [\u2190 interior_Icc]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 Icc a b \u2208 nhds x \u2194 x \u2208 interior (Icc a b)\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 TopologicalSpace \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 OrderTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 DenselyOrdered \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 NoMinOrder \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 NoMaxOrder \u03b1"}, {"line": "rw [mem_interior_iff_mem_nhds]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 OrderTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 DenselyOrdered \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 NoMinOrder \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\ninst\u271d\u00b2 : DenselyOrdered \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 NoMaxOrder \u03b1"}]}
{"declaration": "theorem interior_Ico [NoMinOrder \u03b1] {a b : \u03b1} : interior (Ico a b) = Ioo a b := by\n  rw [\u2190 Ici_inter_Iio]\n  rw [interior_inter]\n  rw [interior_Ici]\n  rw [interior_Iio]\n  rw [Ioi_inter_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/DenselyOrdered.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 \u03b2 : Type*}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [DenselyOrdered \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b : \u03b1\n\u22a2 interior (Ico a b) = Ioo a b"}, {"line": "rw [\u2190 Ici_inter_Iio]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b : \u03b1\n\u22a2 interior (Ici a \u2229 Iio b) = Ioo a b"}, {"line": "rw [interior_inter]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b : \u03b1\n\u22a2 interior (Ici a) \u2229 interior (Iio b) = Ioo a b"}, {"line": "rw [interior_Ici]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b : \u03b1\n\u22a2 Ioi a \u2229 interior (Iio b) = Ioo a b\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b : \u03b1\n\u22a2 OrderTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b : \u03b1\n\u22a2 DenselyOrdered \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b : \u03b1\n\u22a2 NoMinOrder \u03b1"}, {"line": "rw [interior_Iio]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b : \u03b1\n\u22a2 Ioi a \u2229 Iio b = Ioo a b\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b : \u03b1\n\u22a2 ClosedIciTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b : \u03b1\n\u22a2 OrderTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b : \u03b1\n\u22a2 DenselyOrdered \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b : \u03b1\n\u22a2 NoMinOrder \u03b1"}, {"line": "rw [Ioi_inter_Iio]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b : \u03b1\n\u22a2 ClosedIciTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b : \u03b1\n\u22a2 OrderTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b : \u03b1\n\u22a2 DenselyOrdered \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b : \u03b1\n\u22a2 NoMinOrder \u03b1"}]}
{"declaration": "theorem Ico_mem_nhds_iff [NoMinOrder \u03b1] {a b x : \u03b1} : Ico a b \u2208 \ud835\udcdd x \u2194 x \u2208 Ioo a b := by\n  rw [\u2190 interior_Ico]\n  rw [mem_interior_iff_mem_nhds]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/DenselyOrdered.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 \u03b2 : Type*}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [DenselyOrdered \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b x : \u03b1\n\u22a2 Ico a b \u2208 nhds x \u2194 x \u2208 Ioo a b"}, {"line": "rw [\u2190 interior_Ico]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b x : \u03b1\n\u22a2 Ico a b \u2208 nhds x \u2194 x \u2208 interior (Ico a b)\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b x : \u03b1\n\u22a2 TopologicalSpace \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b x : \u03b1\n\u22a2 OrderTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b x : \u03b1\n\u22a2 DenselyOrdered \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b x : \u03b1\n\u22a2 NoMinOrder \u03b1"}, {"line": "rw [mem_interior_iff_mem_nhds]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b x : \u03b1\n\u22a2 OrderTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b x : \u03b1\n\u22a2 DenselyOrdered \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMinOrder \u03b1\na b x : \u03b1\n\u22a2 NoMinOrder \u03b1"}]}
{"declaration": "theorem interior_Ioc [NoMaxOrder \u03b1] {a b : \u03b1} : interior (Ioc a b) = Ioo a b := by\n  rw [\u2190 Ioi_inter_Iic]\n  rw [interior_inter]\n  rw [interior_Ioi]\n  rw [interior_Iic]\n  rw [Ioi_inter_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/DenselyOrdered.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 \u03b2 : Type*}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [DenselyOrdered \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 interior (Ioc a b) = Ioo a b"}, {"line": "rw [\u2190 Ioi_inter_Iic]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 interior (Ioi a \u2229 Iic b) = Ioo a b"}, {"line": "rw [interior_inter]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 interior (Ioi a) \u2229 interior (Iic b) = Ioo a b"}, {"line": "rw [interior_Ioi]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 Ioi a \u2229 interior (Iic b) = Ioo a b\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 ClosedIicTopology \u03b1"}, {"line": "rw [interior_Iic]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 Ioi a \u2229 Iio b = Ioo a b\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 OrderTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 DenselyOrdered \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 NoMaxOrder \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 ClosedIicTopology \u03b1"}, {"line": "rw [Ioi_inter_Iio]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 OrderTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 DenselyOrdered \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 NoMaxOrder \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 ClosedIicTopology \u03b1"}]}
{"declaration": "theorem Ioc_mem_nhds_iff [NoMaxOrder \u03b1] {a b x : \u03b1} : Ioc a b \u2208 \ud835\udcdd x \u2194 x \u2208 Ioo a b := by\n  rw [\u2190 interior_Ioc]\n  rw [mem_interior_iff_mem_nhds]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/DenselyOrdered.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 \u03b2 : Type*}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [DenselyOrdered \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 Ioc a b \u2208 nhds x \u2194 x \u2208 Ioo a b"}, {"line": "rw [\u2190 interior_Ioc]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 Ioc a b \u2208 nhds x \u2194 x \u2208 interior (Ioc a b)\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 TopologicalSpace \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 OrderTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 DenselyOrdered \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 NoMaxOrder \u03b1"}, {"line": "rw [mem_interior_iff_mem_nhds]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 OrderTopology \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 DenselyOrdered \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b x : \u03b1\n\u22a2 NoMaxOrder \u03b1"}]}
{"declaration": "theorem Ioc_subset_closure_interior (a b : \u03b1) : Ioc a b \u2286 closure (interior (Ioc a b)) := by\n  rcases eq_or_ne a b with (rfl | h)\n  \u00b7 simp\n  \u00b7 calc\n      Ioc a b \u2286 Icc a b := Ioc_subset_Icc_self\n      _ = closure (Ioo a b) := (closure_Ioo h).symm\n      _ \u2286 closure (interior (Ioc a b)) :=\n        closure_mono (interior_maximal Ioo_subset_Ioc_self isOpen_Ioo)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/DenselyOrdered.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 \u03b2 : Type*}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [DenselyOrdered \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : DenselyOrdered \u03b1\na b : \u03b1\n\u22a2 Ioc a b \u2286 closure (interior (Ioc a b))"}, {"line": "rcases eq_or_ne a b with (rfl | h)", "tactic_state": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : DenselyOrdered \u03b1\na : \u03b1\n\u22a2 Ioc a a \u2286 closure (interior (Ioc a a))\n---\ncase inr\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : DenselyOrdered \u03b1\na b : \u03b1\nh : a \u2260 b\n\u22a2 Ioc a b \u2286 closure (interior (Ioc a b))"}, {"line": "\u00b7 simp", "tactic_state": "case inr\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : DenselyOrdered \u03b1\na b : \u03b1\nh : a \u2260 b\n\u22a2 Ioc a b \u2286 closure (interior (Ioc a b))"}, {"line": "\u00b7 calc\n      Ioc a b \u2286 Icc a b := Ioc_subset_Icc_self\n      _ = closure (Ioo a b) := (closure_Ioo h).symm\n      _ \u2286 closure (interior (Ioc a b)) :=\n        closure_mono (interior_maximal Ioo_subset_Ioc_self isOpen_Ioo)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ico_subset_closure_interior (a b : \u03b1) : Ico a b \u2286 closure (interior (Ico a b)) := by\n  simpa only [Ioc_toDual] using\n    Ioc_subset_closure_interior (OrderDual.toDual b) (OrderDual.toDual a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/DenselyOrdered.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 \u03b2 : Type*}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [DenselyOrdered \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : DenselyOrdered \u03b1\na b : \u03b1\n\u22a2 Ico a b \u2286 closure (interior (Ico a b))"}, {"line": "simpa only [Ioc_toDual] using\n    Ioc_subset_closure_interior (OrderDual.toDual b) (OrderDual.toDual a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPreconnected.Icc_subset {s : Set \u03b1} (hs : IsPreconnected s) {a b : \u03b1} (ha : a \u2208 s)\n    (hb : b \u2208 s) : Icc a b \u2286 s := by\n  simpa only [image_id] using hs.intermediate_value ha hb continuousOn_id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/IntermediateValue.lean", "context": {"open": ["Filter OrderDual TopologicalSpace Function Set", "scoped Topology Filter Interval"], "variables": ["{X : Type u} {\u03b1 : Type v} [TopologicalSpace X] [LinearOrder \u03b1] [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type v\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b1\nhs : IsPreconnected s\na b : \u03b1\nha : a \u2208 s\nhb : b \u2208 s\n\u22a2 Icc a b \u2286 s"}, {"line": "simpa only [image_id] using hs.intermediate_value ha hb continuousOn_id", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContinuousOn.strictMonoOn_of_injOn_Ioo {a b : \u03b1} {f : \u03b1 \u2192 \u03b4} (hab : a < b)\n    (hf_c : ContinuousOn f (Ioo a b)) (hf_i : InjOn f (Ioo a b)) :\n    StrictMonoOn f (Ioo a b) \u2228 StrictAntiOn f (Ioo a b) := by\n  haveI : Inhabited (Ioo a b) := Classical.inhabited_of_nonempty (nonempty_Ioo_subtype hab)\n  let g : Ioo a b \u2192 \u03b4 := Set.restrict (Ioo a b) f\n  have : StrictMono g \u2228 StrictAnti g :=\n    Continuous.strictMono_of_inj hf_c.restrict hf_i.injective\n  exact this.imp strictMono_restrict.mp strictAntiOn_iff_strictAnti.mpr", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/IntermediateValue.lean", "context": {"open": ["Filter OrderDual TopologicalSpace Function Set", "scoped Topology Filter Interval"], "variables": ["{X : Type u} {\u03b1 : Type v} [TopologicalSpace X] [LinearOrder \u03b1] [TopologicalSpace \u03b1]", "{\u03b1 : Type u} [ConditionallyCompleteLinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderTopology \u03b1]", "[DenselyOrdered \u03b1] {a b : \u03b1}", "{\u03b4 : Type*} [LinearOrder \u03b4] [TopologicalSpace \u03b4] [OrderClosedTopology \u03b4]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2076 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : OrderTopology \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\n\u03b4 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b4\ninst\u271d\u00b9 : TopologicalSpace \u03b4\ninst\u271d : OrderClosedTopology \u03b4\na b : \u03b1\nf : \u03b1 \u2192 \u03b4\nhab : a < b\nhf_c : ContinuousOn f (Ioo a b)\nhf_i : InjOn f (Ioo a b)\n\u22a2 StrictMonoOn f (Ioo a b) \u2228 StrictAntiOn f (Ioo a b)"}, {"line": "haveI : Inhabited (Ioo a b) := Classical.inhabited_of_nonempty (nonempty_Ioo_subtype hab)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2076 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : OrderTopology \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\n\u03b4 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b4\ninst\u271d\u00b9 : TopologicalSpace \u03b4\ninst\u271d : OrderClosedTopology \u03b4\na b : \u03b1\nf : \u03b1 \u2192 \u03b4\nhab : a < b\nhf_c : ContinuousOn f (Ioo a b)\nhf_i : InjOn f (Ioo a b)\nthis : Inhabited sorry\n\u22a2 StrictMonoOn f (Ioo a b) \u2228 StrictAntiOn f (Ioo a b)"}, {"line": "let g : Ioo a b \u2192 \u03b4 := Set.restrict (Ioo a b) f", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2076 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : OrderTopology \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\n\u03b4 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b4\ninst\u271d\u00b9 : TopologicalSpace \u03b4\ninst\u271d : OrderClosedTopology \u03b4\na b : \u03b1\nf : \u03b1 \u2192 \u03b4\nhab : a < b\nhf_c : ContinuousOn f (Ioo a b)\nhf_i : InjOn f (Ioo a b)\nthis : Inhabited sorry\ng : sorry \u2192 \u03b4 := sorry\n\u22a2 StrictMonoOn f (Ioo a b) \u2228 StrictAntiOn f (Ioo a b)"}, {"line": "have : StrictMono g \u2228 StrictAnti g :=\n    Continuous.strictMono_of_inj hf_c.restrict hf_i.injective", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2076 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : OrderTopology \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\n\u03b4 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b4\ninst\u271d\u00b9 : TopologicalSpace \u03b4\ninst\u271d : OrderClosedTopology \u03b4\na b : \u03b1\nf : \u03b1 \u2192 \u03b4\nhab : a < b\nhf_c : ContinuousOn f (Ioo a b)\nhf_i : InjOn f (Ioo a b)\nthis\u271d : Inhabited sorry\ng : sorry \u2192 \u03b4 := sorry\nthis : sorry \u2228 sorry\n\u22a2 StrictMonoOn f (Ioo a b) \u2228 StrictAntiOn f (Ioo a b)"}, {"line": "exact this.imp strictMono_restrict.mp strictAntiOn_iff_strictAnti.mpr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLUB_of_mem_closure {s : Set \u03b1} {a : \u03b1} (hsa : a \u2208 upperBounds s) (hsf : a \u2208 closure s) :\n    IsLUB s a := by\n  rw [mem_closure_iff_clusterPt] at hsf\n  rw [ClusterPt] at hsf\n  rw [inf_comm] at hsf\n  exact isLUB_of_mem_nhds hsa (mem_principal_self s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/IsLUB.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 \u03b3 : Type*}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\ns : Set \u03b1\na : \u03b1\nhsa : a \u2208 upperBounds s\nhsf : a \u2208 closure s\n\u22a2 IsLUB s a"}, {"line": "rw [mem_closure_iff_clusterPt] at hsf", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\ns : Set \u03b1\na : \u03b1\nhsa : a \u2208 upperBounds s\nhsf : ClusterPt a (principal s)\n\u22a2 IsLUB s a"}, {"line": "rw [ClusterPt] at hsf", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\ns : Set \u03b1\na : \u03b1\nhsa : a \u2208 upperBounds s\nhsf : (nhds a \u2293 principal s).NeBot\n\u22a2 IsLUB s a"}, {"line": "rw [inf_comm] at hsf", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\ns : Set \u03b1\na : \u03b1\nhsa : a \u2208 upperBounds s\nhsf : (principal s \u2293 nhds a).NeBot\n\u22a2 IsLUB s a"}, {"line": "exact isLUB_of_mem_nhds hsa (mem_principal_self s)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_seq_strictAnti_tendsto' [DenselyOrdered \u03b1] [FirstCountableTopology \u03b1] {x y : \u03b1}\n    (hy : x < y) : \u2203 u : \u2115 \u2192 \u03b1, StrictAnti u \u2227 (\u2200 n, u n \u2208 Ioo x y) \u2227 Tendsto u atTop (\ud835\udcdd x) := by\n  simpa using exists_seq_strictMono_tendsto' (\u03b1 := \u03b1\u1d52\u1d48) (OrderDual.toDual_lt_toDual.2 hy)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/IsLUB.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 \u03b3 : Type*}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : FirstCountableTopology \u03b1\nx y : \u03b1\nhy : x < y\n\u22a2 \u2203 u, StrictAnti u \u2227 (\u2200 (n : \u2115), u n \u2208 Ioo x y) \u2227 Tendsto u atTop (nhds x)"}, {"line": "simpa using exists_seq_strictMono_tendsto' (\u03b1 := \u03b1\u1d52\u1d48) (OrderDual.toDual_lt_toDual.2 hy)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Dense.exists_seq_strictAnti_tendsto_of_lt [DenselyOrdered \u03b1] [FirstCountableTopology \u03b1]\n    {s : Set \u03b1} (hs : Dense s) {x y : \u03b1} (hy : x < y) :\n    \u2203 u : \u2115 \u2192 \u03b1, StrictAnti u \u2227 (\u2200 n, u n \u2208 (Ioo x y \u2229 s)) \u2227 Tendsto u atTop (\ud835\udcdd x) := by\n  simpa using hs.exists_seq_strictMono_tendsto_of_lt (\u03b1 := \u03b1\u1d52\u1d48) (OrderDual.toDual_lt_toDual.2 hy)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/IsLUB.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 \u03b3 : Type*}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : FirstCountableTopology \u03b1\ns : Set \u03b1\nhs : Dense s\nx y : \u03b1\nhy : x < y\n\u22a2 \u2203 u, StrictAnti u \u2227 (\u2200 (n : \u2115), u n \u2208 Ioo x y \u2229 s) \u2227 Tendsto u atTop (nhds x)"}, {"line": "simpa using hs.exists_seq_strictMono_tendsto_of_lt (\u03b1 := \u03b1\u1d52\u1d48) (OrderDual.toDual_lt_toDual.2 hy)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DenseRange.exists_seq_strictAnti_tendsto_of_lt {\u03b2 : Type*} [LinearOrder \u03b2]\n    [DenselyOrdered \u03b1] [FirstCountableTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {x y : \u03b1} (hf : DenseRange f)\n    (hmono : Monotone f) (hlt : x < y) :\n    \u2203 u : \u2115 \u2192 \u03b2, StrictAnti u \u2227 (\u2200 n, f (u n) \u2208 Ioo x y) \u2227 Tendsto (f \u2218 u) atTop (\ud835\udcdd x) := by\n  simpa using hf.exists_seq_strictMono_tendsto_of_lt (\u03b1 := \u03b1\u1d52\u1d48) (\u03b2 := \u03b2\u1d52\u1d48) hmono.dual\n    (OrderDual.toDual_lt_toDual.2 hlt)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/IsLUB.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 \u03b3 : Type*}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\n\u03b2 : Type u_3\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : DenselyOrdered \u03b1\ninst\u271d : FirstCountableTopology \u03b1\nf : \u03b2 \u2192 \u03b1\nx y : \u03b1\nhf : DenseRange f\nhmono : Monotone f\nhlt : x < y\n\u22a2 \u2203 u, StrictAnti u \u2227 (\u2200 (n : \u2115), f (u n) \u2208 Ioo x y) \u2227 Tendsto (f \u2218 u) atTop (nhds x)"}, {"line": "simpa using hf.exists_seq_strictMono_tendsto_of_lt (\u03b1 := \u03b1\u1d52\u1d48) (\u03b2 := \u03b2\u1d52\u1d48) hmono.dual\n    (OrderDual.toDual_lt_toDual.2 hlt)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsLE_sup_nhdsGE (a : \u03b1) : \ud835\udcdd[\u2264] a \u2294 \ud835\udcdd[\u2265] a = \ud835\udcdd a := by\n  rw [\u2190 nhdsWithin_union]\n  rw [Iic_union_Ici]\n  rw [nhdsWithin_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/LeftRight.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] [Preorder \u03b1]", "{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [PartialOrder \u03b1] [TopologicalSpace \u03b2]", "{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1] [TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Iic a) \u2294 nhdsWithin a (Ici a) = nhds a"}, {"line": "rw [\u2190 nhdsWithin_union]", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Iic a \u222a Ici a) = nhds a"}, {"line": "rw [Iic_union_Ici]", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a univ = nhds a"}, {"line": "rw [nhdsWithin_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsLT_sup_nhdsGE (a : \u03b1) : \ud835\udcdd[<] a \u2294 \ud835\udcdd[\u2265] a = \ud835\udcdd a := by\n  rw [\u2190 nhdsWithin_union]\n  rw [Iio_union_Ici]\n  rw [nhdsWithin_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/LeftRight.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] [Preorder \u03b1]", "{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [PartialOrder \u03b1] [TopologicalSpace \u03b2]", "{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1] [TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ici a) = nhds a"}, {"line": "rw [\u2190 nhdsWithin_union]", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Iio a \u222a Ici a) = nhds a"}, {"line": "rw [Iio_union_Ici]", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a univ = nhds a"}, {"line": "rw [nhdsWithin_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsLE_sup_nhdsGT (a : \u03b1) : \ud835\udcdd[\u2264] a \u2294 \ud835\udcdd[>] a = \ud835\udcdd a := by\n  rw [\u2190 nhdsWithin_union]\n  rw [Iic_union_Ioi]\n  rw [nhdsWithin_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/LeftRight.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] [Preorder \u03b1]", "{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [PartialOrder \u03b1] [TopologicalSpace \u03b2]", "{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1] [TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Iic a) \u2294 nhdsWithin a (Ioi a) = nhds a"}, {"line": "rw [\u2190 nhdsWithin_union]", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Iic a \u222a Ioi a) = nhds a"}, {"line": "rw [Iic_union_Ioi]", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a univ = nhds a"}, {"line": "rw [nhdsWithin_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsLT_sup_nhdsGT (a : \u03b1) : \ud835\udcdd[<] a \u2294 \ud835\udcdd[>] a = \ud835\udcdd[\u2260] a := by\n  rw [\u2190 nhdsWithin_union]\n  rw [Iio_union_Ioi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/LeftRight.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] [Preorder \u03b1]", "{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [PartialOrder \u03b1] [TopologicalSpace \u03b2]", "{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1] [TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a) = nhdsWithin a {a}\u1d9c"}, {"line": "rw [\u2190 nhdsWithin_union]", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Iio a \u222a Ioi a) = nhdsWithin a {a}\u1d9c"}, {"line": "rw [Iio_union_Ioi]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousAt_iff_continuous_left_right {a : \u03b1} {f : \u03b1 \u2192 \u03b2} :\n    ContinuousAt f a \u2194 ContinuousWithinAt f (Iic a) a \u2227 ContinuousWithinAt f (Ici a) a := by\n  simp only [ContinuousWithinAt]\n  simp only [ContinuousAt]\n  simp only [\u2190 tendsto_sup]\n  simp only [nhdsLE_sup_nhdsGE]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/LeftRight.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] [Preorder \u03b1]", "{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [PartialOrder \u03b1] [TopologicalSpace \u03b2]", "{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1] [TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : TopologicalSpace \u03b2\na : \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 ContinuousAt f a \u2194 ContinuousWithinAt f (Iic a) a \u2227 ContinuousWithinAt f (Ici a) a"}, {"line": "simp only [ContinuousWithinAt]", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : TopologicalSpace \u03b2\na : \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 ContinuousAt f a \u2194 Tendsto f (nhdsWithin a (Iic a)) (nhds (f a)) \u2227 Tendsto f (nhdsWithin a (Ici a)) (nhds (f a))"}, {"line": "simp only [ContinuousAt]", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : TopologicalSpace \u03b2\na : \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 Tendsto f (nhds a) (nhds (f a)) \u2194\n    Tendsto f (nhdsWithin a (Iic a)) (nhds (f a)) \u2227 Tendsto f (nhdsWithin a (Ici a)) (nhds (f a))"}, {"line": "simp only [\u2190 tendsto_sup]", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : TopologicalSpace \u03b2\na : \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 Tendsto f (nhds a) (nhds (f a)) \u2194 Tendsto f (nhdsWithin a (Iic a) \u2294 nhdsWithin a (Ici a)) (nhds (f a))"}, {"line": "simp only [nhdsLE_sup_nhdsGE]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousAt_iff_continuous_left'_right' {a : \u03b1} {f : \u03b1 \u2192 \u03b2} :\n    ContinuousAt f a \u2194 ContinuousWithinAt f (Iio a) a \u2227 ContinuousWithinAt f (Ioi a) a := by\n  rw [continuousWithinAt_Ioi_iff_Ici]\n  rw [continuousWithinAt_Iio_iff_Iic]\n  rw [continuousAt_iff_continuous_left_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/LeftRight.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] [Preorder \u03b1]", "{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [PartialOrder \u03b1] [TopologicalSpace \u03b2]", "{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1] [TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : TopologicalSpace \u03b2\na : \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 ContinuousAt f a \u2194 ContinuousWithinAt f (Iio a) a \u2227 ContinuousWithinAt f (Ioi a) a"}, {"line": "rw [continuousWithinAt_Ioi_iff_Ici]", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : TopologicalSpace \u03b2\na : \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 ContinuousAt f a \u2194 ContinuousWithinAt f (Iio a) a \u2227 ContinuousWithinAt f (Ici a) a"}, {"line": "rw [continuousWithinAt_Iio_iff_Iic]", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : TopologicalSpace \u03b2\na : \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 ContinuousAt f a \u2194 ContinuousWithinAt f (Iic a) a \u2227 ContinuousWithinAt f (Ici a) a"}, {"line": "rw [continuousAt_iff_continuous_left_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leftLim_eq_of_eq_bot [h\u03b1 : TopologicalSpace \u03b1] [h'\u03b1 : OrderTopology \u03b1] (f : \u03b1 \u2192 \u03b2) {a : \u03b1}\n    (h : \ud835\udcdd[<] a = \u22a5) : leftLim f a = f a := by\n  rw [h'\u03b1.topology_eq_generate_intervals] at h\n  simp [leftLim, ite_eq_left_iff, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/LeftRightLim.lean", "context": {"open": ["Set Filter", "Topology", "Function"], "variables": ["{\u03b1 \u03b2 : Type*} [LinearOrder \u03b1] [TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : TopologicalSpace \u03b2\nh\u03b1 : TopologicalSpace \u03b1\nh'\u03b1 : OrderTopology \u03b1\nf : \u03b1 \u2192 \u03b2\na : \u03b1\nh : nhdsWithin a (Iio a) = \u22a5\n\u22a2 leftLim f a = f a"}, {"line": "rw [h'\u03b1.topology_eq_generate_intervals] at h", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : TopologicalSpace \u03b2\nh\u03b1 : TopologicalSpace \u03b1\nh'\u03b1 : OrderTopology \u03b1\nf : \u03b1 \u2192 \u03b2\na : \u03b1\nh : nhdsWithin a (Iio a) = \u22a5\n\u22a2 leftLim f a = f a"}, {"line": "simp [leftLim, ite_eq_left_iff, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TFAE_mem_nhdsLT {a b : \u03b1} (h : a < b) (s : Set \u03b1) :\n    TFAE [s \u2208 \ud835\udcdd[<] b,-- 0 : `s` is a neighborhood of `b` within `(-\u221e, b)`\n        s \u2208 \ud835\udcdd[Ico a b] b,-- 1 : `s` is a neighborhood of `b` within `[a, b)`\n        s \u2208 \ud835\udcdd[Ioo a b] b,-- 2 : `s` is a neighborhood of `b` within `(a, b)`\n        \u2203 l \u2208 Ico a b, Ioo l b \u2286 s,-- 3 : `s` includes `(l, b)` for some `l \u2208 [a, b)`\n        \u2203 l \u2208 Iio b, Ioo l b \u2286 s] := by-- 4 : `s` includes `(l, b)` for some `l < b`\n  simpa using TFAE_mem_nhdsGT h.dual (ofDual \u207b\u00b9' s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/LeftRightNhds.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Function", "OrderDual (toDual ofDual)", "List in", "List in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1]", "[OrderTopology \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\nx\u271d : Sort u_1\nTFAE : x\u271d\na b : \u03b1\nh : a < b\ns : Set \u03b1\n\u22a2 sorry"}, {"line": "simpa using TFAE_mem_nhdsGT h.dual (ofDual \u207b\u00b9' s)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TFAE_mem_nhdsLE {a b : \u03b1} (h : a < b) (s : Set \u03b1) :\n    TFAE [s \u2208 \ud835\udcdd[\u2264] b,-- 0 : `s` is a neighborhood of `b` within `(-\u221e, b]`\n      s \u2208 \ud835\udcdd[Icc a b] b,-- 1 : `s` is a neighborhood of `b` within `[a, b]`\n      s \u2208 \ud835\udcdd[Ioc a b] b,-- 2 : `s` is a neighborhood of `b` within `(a, b]`\n      \u2203 l \u2208 Ico a b, Ioc l b \u2286 s,-- 3 : `s` includes `(l, b]` for some `l \u2208 [a, b)`\n      \u2203 l \u2208 Iio b, Ioc l b \u2286 s] := by-- 4 : `s` includes `(l, b]` for some `l < b`\n  simpa using TFAE_mem_nhdsGE h.dual (ofDual \u207b\u00b9' s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/LeftRightNhds.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Function", "OrderDual (toDual ofDual)", "List in", "List in", "List in", "List in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1]", "[OrderTopology \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\nx\u271d : Sort u_1\nTFAE : x\u271d\na b : \u03b1\nh : a < b\ns : Set \u03b1\n\u22a2 sorry"}, {"line": "simpa using TFAE_mem_nhdsGE h.dual (ofDual \u207b\u00b9' s)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_nhdsLE_iff_exists_Icc_subset [NoMinOrder \u03b1] [DenselyOrdered \u03b1] {a : \u03b1}\n    {s : Set \u03b1} : s \u2208 \ud835\udcdd[\u2264] a \u2194 \u2203 l, l < a \u2227 Icc l a \u2286 s :=\n  calc s \u2208 \ud835\udcdd[\u2264] a \u2194 ofDual \u207b\u00b9' s \u2208 \ud835\udcdd[\u2265] (toDual a) := Iff.rfl\n  _ \u2194 \u2203 u : \u03b1, toDual a < toDual u \u2227 Icc (toDual a) (toDual u) \u2286 ofDual \u207b\u00b9' s :=\n    mem_nhdsGE_iff_exists_Icc_subset\n  _ \u2194 \u2203 l, l < a \u2227 Icc l a \u2286 s := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/LeftRightNhds.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Function", "OrderDual (toDual ofDual)", "List in", "List in", "List in", "List in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1]", "[OrderTopology \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : DenselyOrdered \u03b1\na : \u03b1\ns : Set \u03b1\n\u22a2 (\u2203 u, toDual a < toDual u \u2227 Icc (toDual a) (toDual u) \u2286 \u21d1ofDual \u207b\u00b9' s) \u2194 \u2203 l < a, Icc l a \u2286 s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearOrderedCommGroup.tendsto_nhds {x : Filter \u03b2} {a : \u03b1} :\n    Tendsto f x (\ud835\udcdd a) \u2194 \u2200 \u03b5 > (1 : \u03b1), \u2200\u1da0 b in x, |f b / a|\u2098 < \u03b5 := by\n  simp [nhds_eq_iInf_mabs_div, mabs_div_comm a]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/LeftRightNhds.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Function", "OrderDual (toDual ofDual)", "List in", "List in", "List in", "List in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1]", "[OrderTopology \u03b1]", "[TopologicalSpace \u03b1] [CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "{l : Filter \u03b2} {f g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : OrderTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\nf : \u03b2 \u2192 \u03b1\nx : Filter \u03b2\na : \u03b1\n\u22a2 Tendsto f x (nhds a) \u2194 \u2200 \u03b5 > 1, \u2200\u1da0 (b : \u03b2) in x, mabs (f b / a) < \u03b5"}, {"line": "simp [nhds_eq_iInf_mabs_div, mabs_div_comm a]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : OrderTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\nf : \u03b2 \u2192 \u03b1\nx : Filter \u03b2\na : \u03b1\n\u22a2 Tendsto f x (nhds a) \u2194 \u2200 (\u03b5 : \u03b1), 1 < \u03b5 \u2192 \u2200\u1da0 (b : \u03b2) in x, mabs (f b / a) < \u03b5"}]}
{"declaration": "lemma isLocalMaxOn_univ_iff : IsLocalMaxOn f univ a \u2194 IsLocalMax f a := by\n  simp only [IsLocalMaxOn]\n  simp only [IsLocalMax]\n  simp only [nhdsWithin_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/LocalExtr.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type x} [TopologicalSpace \u03b1]", "[Preorder \u03b2] [Preorder \u03b3] (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (a : \u03b1)", "{f s a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 IsLocalMaxOn f univ a \u2194 IsLocalMax f a"}, {"line": "simp only [IsLocalMaxOn]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 IsMaxFilter f (nhdsWithin a univ) a \u2194 IsLocalMax f a"}, {"line": "simp only [IsLocalMax]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 IsMaxFilter f (nhdsWithin a univ) a \u2194 IsMaxFilter f (nhds a) a"}, {"line": "simp only [nhdsWithin_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_upperClosure (h : s.Finite) : IsClosed (upperClosure s : Set \u03b1) := by\n  simp only [\u2190 UpperSet.iInf_Ici]\n  simp only [UpperSet.coe_iInf]\n  exact h.isClosed_biUnion fun _ _ => isClosed_Ici\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/LowerUpperTopology.lean", "context": {"open": ["Set TopologicalSpace Topology"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] {s : Set \u03b1}", "[Preorder \u03b1] {s : Set \u03b1}", "(\u03b1)", "[Preorder \u03b1] [TopologicalSpace \u03b1] [IsLower \u03b1] {s : Set \u03b1}", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : IsLower \u03b1\ns : Set \u03b1\nh : s.Finite\n\u22a2 IsClosed \u2191(upperClosure s)"}, {"line": "simp only [\u2190 UpperSet.iInf_Ici]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : IsLower \u03b1\ns : Set \u03b1\nh : s.Finite\n\u22a2 IsClosed \u2191(\u2a05 a \u2208 s, UpperSet.Ici a)"}, {"line": "simp only [UpperSet.coe_iInf]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : IsLower \u03b1\ns : Set \u03b1\nh : s.Finite\n\u22a2 IsClosed (\u22c3 i \u2208 s, \u2191(UpperSet.Ici i))"}, {"line": "exact h.isClosed_biUnion fun _ _ => isClosed_Ici", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_nhds_iff_not_le {\u03b2 : Type*} {f : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} {x : \u03b1} :\n    Filter.Tendsto f l (\ud835\udcdd x) \u2194 \u2200 y, \u00acy \u2264 x \u2192 \u2200\u1da0 z in l, \u00acy \u2264 f z := by\n  simp [topology_eq_lowerTopology, tendsto_nhds_generateFrom_iff, Filter.Eventually, Ici,\n    compl_setOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/LowerUpperTopology.lean", "context": {"open": ["Set TopologicalSpace Topology"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] {s : Set \u03b1}", "[Preorder \u03b1] {s : Set \u03b1}", "(\u03b1)", "[Preorder \u03b1] [TopologicalSpace \u03b1] [IsLower \u03b1] {s : Set \u03b1}", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : IsLower \u03b1\n\u03b2 : Type u_3\nf : \u03b2 \u2192 \u03b1\nl : Filter \u03b2\nx : \u03b1\n\u22a2 Filter.Tendsto f l (nhds x) \u2194 \u2200 (y : \u03b1), \u00acy \u2264 x \u2192 \u2200\u1da0 (z : \u03b2) in l, \u00acy \u2264 f z"}, {"line": "simp [topology_eq_lowerTopology, tendsto_nhds_generateFrom_iff, Filter.Eventually, Ici,\n    compl_setOf]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : IsLower \u03b1\n\u03b2 : Type u_3\nf : \u03b2 \u2192 \u03b1\nl : Filter \u03b2\nx : \u03b1\n\u22a2 Filter.Tendsto f l (nhds x) \u2194 \u2200 (y : \u03b1), \u00acy \u2264 x \u2192 {x | \u00acy \u2264 f x} \u2208 l"}]}
{"declaration": "lemma isUpper_orderDual [Preorder \u03b1] [TopologicalSpace \u03b1] : IsUpper \u03b1\u1d52\u1d48 \u2194 IsLower \u03b1 := by\n  constructor\n  \u00b7 apply OrderDual.instIsLower\n  \u00b7 apply OrderDual.instIsUpper\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/LowerUpperTopology.lean", "context": {"open": ["Set TopologicalSpace Topology"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] {s : Set \u03b1}", "[Preorder \u03b1] {s : Set \u03b1}", "(\u03b1)", "[Preorder \u03b1] [TopologicalSpace \u03b1] [IsLower \u03b1] {s : Set \u03b1}", "{\u03b1}", "[PartialOrder \u03b1] [TopologicalSpace \u03b1] [IsLower \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [IsLower \u03b1]", "[CompleteLinearOrder \u03b1] [t : TopologicalSpace \u03b1] [IsLower \u03b1]", "(\u03b1)", "[Preorder \u03b1] [TopologicalSpace \u03b1] [IsUpper \u03b1] {s : Set \u03b1}", "{\u03b1}", "[PartialOrder \u03b1] [TopologicalSpace \u03b1] [IsUpper \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [IsUpper \u03b1]", "[CompleteLinearOrder \u03b1] [t : TopologicalSpace \u03b1] [IsUpper \u03b1]", "[CompleteLattice \u03b1] [CompleteLattice \u03b2] [TopologicalSpace \u03b1] [IsLower \u03b1]", "[CompleteLattice \u03b1] [CompleteLattice \u03b2] [TopologicalSpace \u03b1] [IsUpper \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3\u00b9 inst\u271d\u00b3\u2070 inst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : IsLower \u03b1\ninst\u271d\u00b2\u2076 : PartialOrder \u03b1\ninst\u271d\u00b2\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2074 : IsLower \u03b1\ninst\u271d\u00b2\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b9 : IsLower \u03b1\ninst\u271d\u00b2\u2070 : CompleteLinearOrder \u03b1\nt\u271d : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2079 : IsLower \u03b1\ninst\u271d\u00b9\u2078 : Preorder \u03b1\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : IsUpper \u03b1\ninst\u271d\u00b9\u2075 : PartialOrder \u03b1\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b3 : IsUpper \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : IsUpper \u03b1\ninst\u271d\u2079 : CompleteLinearOrder \u03b1\nt : TopologicalSpace \u03b1\ninst\u271d\u2078 : IsUpper \u03b1\ninst\u271d\u2077 : CompleteLattice \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : IsLower \u03b1\ninst\u271d\u2074 : CompleteLattice \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : IsUpper \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 IsUpper \u03b1\u1d52\u1d48 \u2194 IsLower \u03b1"}, {"line": "constructor", "tactic_state": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b3\u00b9 inst\u271d\u00b3\u2070 inst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : IsLower \u03b1\ninst\u271d\u00b2\u2076 : PartialOrder \u03b1\ninst\u271d\u00b2\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2074 : IsLower \u03b1\ninst\u271d\u00b2\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b9 : IsLower \u03b1\ninst\u271d\u00b2\u2070 : CompleteLinearOrder \u03b1\nt\u271d : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2079 : IsLower \u03b1\ninst\u271d\u00b9\u2078 : Preorder \u03b1\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : IsUpper \u03b1\ninst\u271d\u00b9\u2075 : PartialOrder \u03b1\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b3 : IsUpper \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : IsUpper \u03b1\ninst\u271d\u2079 : CompleteLinearOrder \u03b1\nt : TopologicalSpace \u03b1\ninst\u271d\u2078 : IsUpper \u03b1\ninst\u271d\u2077 : CompleteLattice \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : IsLower \u03b1\ninst\u271d\u2074 : CompleteLattice \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : IsUpper \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 IsUpper \u03b1\u1d52\u1d48 \u2192 IsLower \u03b1\n---\ncase mpr\n\u03b1 : Type u_1\ninst\u271d\u00b3\u00b9 inst\u271d\u00b3\u2070 inst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : IsLower \u03b1\ninst\u271d\u00b2\u2076 : PartialOrder \u03b1\ninst\u271d\u00b2\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2074 : IsLower \u03b1\ninst\u271d\u00b2\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b9 : IsLower \u03b1\ninst\u271d\u00b2\u2070 : CompleteLinearOrder \u03b1\nt\u271d : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2079 : IsLower \u03b1\ninst\u271d\u00b9\u2078 : Preorder \u03b1\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : IsUpper \u03b1\ninst\u271d\u00b9\u2075 : PartialOrder \u03b1\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b3 : IsUpper \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : IsUpper \u03b1\ninst\u271d\u2079 : CompleteLinearOrder \u03b1\nt : TopologicalSpace \u03b1\ninst\u271d\u2078 : IsUpper \u03b1\ninst\u271d\u2077 : CompleteLattice \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : IsLower \u03b1\ninst\u271d\u2074 : CompleteLattice \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : IsUpper \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 IsLower \u03b1 \u2192 IsUpper \u03b1\u1d52\u1d48"}, {"line": "\u00b7 apply OrderDual.instIsLower", "tactic_state": "case mpr\n\u03b1 : Type u_1\ninst\u271d\u00b3\u00b9 inst\u271d\u00b3\u2070 inst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : IsLower \u03b1\ninst\u271d\u00b2\u2076 : PartialOrder \u03b1\ninst\u271d\u00b2\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2074 : IsLower \u03b1\ninst\u271d\u00b2\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b9 : IsLower \u03b1\ninst\u271d\u00b2\u2070 : CompleteLinearOrder \u03b1\nt\u271d : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2079 : IsLower \u03b1\ninst\u271d\u00b9\u2078 : Preorder \u03b1\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : IsUpper \u03b1\ninst\u271d\u00b9\u2075 : PartialOrder \u03b1\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b3 : IsUpper \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : IsUpper \u03b1\ninst\u271d\u2079 : CompleteLinearOrder \u03b1\nt : TopologicalSpace \u03b1\ninst\u271d\u2078 : IsUpper \u03b1\ninst\u271d\u2077 : CompleteLattice \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : IsLower \u03b1\ninst\u271d\u2074 : CompleteLattice \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : IsUpper \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 IsLower \u03b1 \u2192 IsUpper \u03b1\u1d52\u1d48"}, {"line": "\u00b7 apply OrderDual.instIsUpper", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_atTop_isLUB (h_mono : Monotone f) (ha : IsLUB (Set.range f) a) :\n    Tendsto f atTop (\ud835\udcdd a) := by\n  suffices Tendsto (rangeFactorization f) atTop atTop from\n    (SupConvergenceClass.tendsto_coe_atTop_isLUB _ _ ha).comp this\n  exact h_mono.rangeFactorization.tendsto_atTop_atTop fun b => b.2.imp fun a ha => ha.ge\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/MonotoneConvergence.lean", "context": {"open": ["Filter Set Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b9 : Type*} [Preorder \u03b9] [TopologicalSpace \u03b1]", "[Preorder \u03b1] [SupConvergenceClass \u03b1] {f : \u03b9 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SupConvergenceClass \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u03b1\nh_mono : Monotone f\nha : IsLUB (range f) a\n\u22a2 Tendsto f atTop (nhds a)"}, {"line": "suffices Tendsto (rangeFactorization f) atTop atTop from\n    (SupConvergenceClass.tendsto_coe_atTop_isLUB _ _ ha).comp this", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SupConvergenceClass \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u03b1\nh_mono : Monotone f\nha : IsLUB (range f) a\n\u22a2 Tendsto (rangeFactorization f) sorry sorry"}, {"line": "exact h_mono.rangeFactorization.tendsto_atTop_atTop fun b => b.2.imp fun a ha => ha.ge", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_atBot_isLUB (h_anti : Antitone f) (ha : IsLUB (Set.range f) a) :\n    Tendsto f atBot (\ud835\udcdd a) := by convert tendsto_atTop_isLUB h_anti.dual_left ha using 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/MonotoneConvergence.lean", "context": {"open": ["Filter Set Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b9 : Type*} [Preorder \u03b9] [TopologicalSpace \u03b1]", "[Preorder \u03b1] [SupConvergenceClass \u03b1] {f : \u03b9 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SupConvergenceClass \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u03b1\nh_anti : Antitone f\nha : IsLUB (range f) a\n\u22a2 Tendsto f atBot (nhds a)"}, {"line": "convert tendsto_atTop_isLUB h_anti.dual_left ha using 1", "tactic_state": "case convert_2\n\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Preorder \u03b9\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SupConvergenceClass \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u03b1\nh_anti : Antitone f\nha : IsLUB (range f) a\n\u22a2 SupConvergenceClass \u03b1"}]}
{"declaration": "theorem tendsto_atBot_isGLB (h_mono : Monotone f) (ha : IsGLB (Set.range f) a) :\n    Tendsto f atBot (\ud835\udcdd a) := by convert tendsto_atTop_isLUB h_mono.dual ha.dual using 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/MonotoneConvergence.lean", "context": {"open": ["Filter Set Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b9 : Type*} [Preorder \u03b9] [TopologicalSpace \u03b1]", "[Preorder \u03b1] [SupConvergenceClass \u03b1] {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[Preorder \u03b1] [InfConvergenceClass \u03b1] {f : \u03b9 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2075 : Preorder \u03b9\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : SupConvergenceClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : InfConvergenceClass \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u03b1\nh_mono : Monotone f\nha : IsGLB (range f) a\n\u22a2 Tendsto f atBot (nhds a)"}, {"line": "convert tendsto_atTop_isLUB h_mono.dual ha.dual using 1", "tactic_state": "case convert_2\n\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2075 : Preorder \u03b9\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : SupConvergenceClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : InfConvergenceClass \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u03b1\nh_mono : Monotone f\nha : IsGLB (range f) a\n\u22a2 SupConvergenceClass \u03b1\u1d52\u1d48"}]}
{"declaration": "theorem tendsto_atTop_isGLB (h_anti : Antitone f) (ha : IsGLB (Set.range f) a) :\n    Tendsto f atTop (\ud835\udcdd a) := by convert tendsto_atBot_isLUB h_anti.dual ha.dual using 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/MonotoneConvergence.lean", "context": {"open": ["Filter Set Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b9 : Type*} [Preorder \u03b9] [TopologicalSpace \u03b1]", "[Preorder \u03b1] [SupConvergenceClass \u03b1] {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[Preorder \u03b1] [InfConvergenceClass \u03b1] {f : \u03b9 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2075 : Preorder \u03b9\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : SupConvergenceClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : InfConvergenceClass \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u03b1\nh_anti : Antitone f\nha : IsGLB (range f) a\n\u22a2 Tendsto f atTop (nhds a)"}, {"line": "convert tendsto_atBot_isLUB h_anti.dual ha.dual using 1", "tactic_state": "case convert_2\n\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2075 : Preorder \u03b9\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : SupConvergenceClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : InfConvergenceClass \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u03b1\nh_anti : Antitone f\nha : IsGLB (range f) a\n\u22a2 SupConvergenceClass \u03b1\u1d52\u1d48"}]}
{"declaration": "theorem tendsto_atBot_ciSup (h_anti : Antitone f) (hbdd : BddAbove <| range f) :\n    Tendsto f atBot (\ud835\udcdd (\u2a06 i, f i)) := by convert tendsto_atTop_ciSup h_anti.dual hbdd.dual using 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/MonotoneConvergence.lean", "context": {"open": ["Filter Set Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b9 : Type*} [Preorder \u03b9] [TopologicalSpace \u03b1]", "[Preorder \u03b1] [SupConvergenceClass \u03b1] {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[Preorder \u03b1] [InfConvergenceClass \u03b1] {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[ConditionallyCompleteLattice \u03b1] [SupConvergenceClass \u03b1] {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2077 : Preorder \u03b9\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : SupConvergenceClass \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : InfConvergenceClass \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLattice \u03b1\ninst\u271d : SupConvergenceClass \u03b1\nf : \u03b9 \u2192 \u03b1\nh_anti : Antitone f\nhbdd : BddAbove (range f)\n\u22a2 Tendsto f atBot (nhds (\u2a06 i, f i))"}, {"line": "convert tendsto_atTop_ciSup h_anti.dual hbdd.dual using 1", "tactic_state": "case h.e'_4\n\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2077 : Preorder \u03b9\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : SupConvergenceClass \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : InfConvergenceClass \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLattice \u03b1\ninst\u271d : SupConvergenceClass \u03b1\nf : \u03b9 \u2192 \u03b1\nh_anti : Antitone f\nhbdd : BddAbove (range f)\n\u22a2 atBot = atTop\n---\ncase convert_3\n\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2077 : Preorder \u03b9\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : SupConvergenceClass \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : InfConvergenceClass \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLattice \u03b1\ninst\u271d : SupConvergenceClass \u03b1\nf : \u03b9 \u2192 \u03b1\nh_anti : Antitone f\nhbdd : BddAbove (range f)\n\u22a2 Preorder \u03b9\n---\ncase convert_6\n\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u2077 : Preorder \u03b9\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : SupConvergenceClass \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : InfConvergenceClass \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLattice \u03b1\ninst\u271d : SupConvergenceClass \u03b1\nf : \u03b9 \u2192 \u03b1\nh_anti : Antitone f\nhbdd : BddAbove (range f)\n\u22a2 SupConvergenceClass \u03b1"}]}
{"declaration": "theorem isLUB_of_tendsto_atTop [TopologicalSpace \u03b1] [Preorder \u03b1] [OrderClosedTopology \u03b1]\n    [Nonempty \u03b2] [SemilatticeSup \u03b2] {f : \u03b2 \u2192 \u03b1} {a : \u03b1} (hf : Monotone f)\n    (ha : Tendsto f atTop (\ud835\udcdd a)) : IsLUB (Set.range f) a := by\n  constructor\n  \u00b7 rintro _ \u27e8b, rfl\u27e9\n    exact hf.ge_of_tendsto ha b\n  \u00b7 exact fun _ hb => le_of_tendsto' ha fun x => hb (Set.mem_range_self x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/MonotoneConvergence.lean", "context": {"open": ["Filter Set Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b9 : Type*} [Preorder \u03b9] [TopologicalSpace \u03b1]", "[Preorder \u03b1] [SupConvergenceClass \u03b1] {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[Preorder \u03b1] [InfConvergenceClass \u03b1] {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[ConditionallyCompleteLattice \u03b1] [SupConvergenceClass \u03b1] {f : \u03b9 \u2192 \u03b1}", "[ConditionallyCompleteLattice \u03b1] [InfConvergenceClass \u03b1] {f : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] [SupConvergenceClass \u03b1] {f : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] [InfConvergenceClass \u03b1] {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : SupConvergenceClass \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : InfConvergenceClass \u03b1\ninst\u271d\u00b9\u00b2 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b9\u00b9 : SupConvergenceClass \u03b1\ninst\u271d\u00b9\u2070 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u2079 : InfConvergenceClass \u03b1\ninst\u271d\u2078 : CompleteLattice \u03b1\ninst\u271d\u2077 : SupConvergenceClass \u03b1\ninst\u271d\u2076 : CompleteLattice \u03b1\ninst\u271d\u2075 : InfConvergenceClass \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nf : \u03b2 \u2192 \u03b1\na : \u03b1\nhf : Monotone f\nha : Tendsto f atTop (nhds a)\n\u22a2 IsLUB (range f) a"}, {"line": "constructor", "tactic_state": "case left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : SupConvergenceClass \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : InfConvergenceClass \u03b1\ninst\u271d\u00b9\u00b2 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b9\u00b9 : SupConvergenceClass \u03b1\ninst\u271d\u00b9\u2070 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u2079 : InfConvergenceClass \u03b1\ninst\u271d\u2078 : CompleteLattice \u03b1\ninst\u271d\u2077 : SupConvergenceClass \u03b1\ninst\u271d\u2076 : CompleteLattice \u03b1\ninst\u271d\u2075 : InfConvergenceClass \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nf : \u03b2 \u2192 \u03b1\na : \u03b1\nhf : Monotone f\nha : Tendsto f atTop (nhds a)\n\u22a2 a \u2208 upperBounds (range f)\n---\ncase right\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : SupConvergenceClass \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : InfConvergenceClass \u03b1\ninst\u271d\u00b9\u00b2 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b9\u00b9 : SupConvergenceClass \u03b1\ninst\u271d\u00b9\u2070 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u2079 : InfConvergenceClass \u03b1\ninst\u271d\u2078 : CompleteLattice \u03b1\ninst\u271d\u2077 : SupConvergenceClass \u03b1\ninst\u271d\u2076 : CompleteLattice \u03b1\ninst\u271d\u2075 : InfConvergenceClass \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nf : \u03b2 \u2192 \u03b1\na : \u03b1\nhf : Monotone f\nha : Tendsto f atTop (nhds a)\n\u22a2 a \u2208 lowerBounds (upperBounds (range f))"}, {"line": "\u00b7 rintro _ \u27e8b, rfl\u27e9\n    exact hf.ge_of_tendsto ha b", "tactic_state": "case right\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : SupConvergenceClass \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : InfConvergenceClass \u03b1\ninst\u271d\u00b9\u00b2 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b9\u00b9 : SupConvergenceClass \u03b1\ninst\u271d\u00b9\u2070 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u2079 : InfConvergenceClass \u03b1\ninst\u271d\u2078 : CompleteLattice \u03b1\ninst\u271d\u2077 : SupConvergenceClass \u03b1\ninst\u271d\u2076 : CompleteLattice \u03b1\ninst\u271d\u2075 : InfConvergenceClass \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nf : \u03b2 \u2192 \u03b1\na : \u03b1\nhf : Monotone f\nha : Tendsto f atTop (nhds a)\n\u22a2 a \u2208 lowerBounds (upperBounds (range f))"}, {"line": "\u00b7 exact fun _ hb => le_of_tendsto' ha fun x => hb (Set.mem_range_self x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PredOrder.nhdsGT_eq_nhdsNE [PredOrder \u03b1] (a : \u03b1) : \ud835\udcdd[>] a = \ud835\udcdd[\u2260] a := by\n  rw [\u2190 nhdsLT_sup_nhdsGT]\n  rw [PredOrder.nhdsLT]\n  rw [bot_sup_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/OrderClosed.lean", "context": {"open": ["Set Filter", "OrderDual (toDual)", "scoped Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[TopologicalSpace \u03b1] [Preorder \u03b1] {s : Set \u03b1}", "[TopologicalSpace \u03b1] [Preorder \u03b1] [ClosedIicTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {a b : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [NoBotOrder \u03b1] [TopologicalSpace \u03b1] [ClosedIicTopology \u03b1] {a : \u03b1}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [ClosedIicTopology \u03b1] [TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Ioi a) = nhdsWithin a {a}\u1d9c"}, {"line": "rw [\u2190 nhdsLT_sup_nhdsGT]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Ioi a) = nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ioi a)\n---\n\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 LinearOrder \u03b1"}, {"line": "rw [PredOrder.nhdsLT]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Ioi a) = \u22a5 \u2294 nhdsWithin a (Ioi a)\n---\n\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 LinearOrder \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 ClosedIicTopology \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 PredOrder \u03b1"}, {"line": "rw [bot_sup_eq]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Ioi a) = nhdsWithin a (Ioi a)\n---\n\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 LinearOrder \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 ClosedIicTopology \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 PredOrder \u03b1"}]}
{"declaration": "theorem PredOrder.nhdsGE_eq_nhds [PredOrder \u03b1] (a : \u03b1) : \ud835\udcdd[\u2265] a = \ud835\udcdd a := by\n  rw [\u2190 nhdsLT_sup_nhdsGE]\n  rw [PredOrder.nhdsLT]\n  rw [bot_sup_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/OrderClosed.lean", "context": {"open": ["Set Filter", "OrderDual (toDual)", "scoped Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[TopologicalSpace \u03b1] [Preorder \u03b1] {s : Set \u03b1}", "[TopologicalSpace \u03b1] [Preorder \u03b1] [ClosedIicTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {a b : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [NoBotOrder \u03b1] [TopologicalSpace \u03b1] [ClosedIicTopology \u03b1] {a : \u03b1}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [ClosedIicTopology \u03b1] [TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Ici a) = nhds a"}, {"line": "rw [\u2190 nhdsLT_sup_nhdsGE]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Ici a) = nhdsWithin a (Iio a) \u2294 nhdsWithin a (Ici a)\n---\n\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 LinearOrder \u03b1"}, {"line": "rw [PredOrder.nhdsLT]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Ici a) = \u22a5 \u2294 nhdsWithin a (Ici a)\n---\n\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 LinearOrder \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 ClosedIicTopology \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 PredOrder \u03b1"}, {"line": "rw [bot_sup_eq]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Ici a) = nhdsWithin a (Ici a)\n---\n\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 LinearOrder \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 ClosedIicTopology \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\ninst\u271d\u2078 : ClosedIicTopology \u03b1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : NoBotOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : ClosedIicTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : ClosedIicTopology \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\n\u22a2 PredOrder \u03b1"}]}
{"declaration": "theorem DiscreteTopology.of_predOrder_succOrder [PredOrder \u03b1] [SuccOrder \u03b1] :\n    DiscreteTopology \u03b1 := by\n  refine discreteTopology_iff_nhds.mpr fun a \u21a6 ?_\n  rw [\u2190 nhdsWithin_univ]\n  rw [\u2190 Iic_union_Ioi]\n  rw [nhdsWithin_union]\n  rw [PredOrder.nhdsLE]\n  rw [SuccOrder.nhdsGT]\n  rw [sup_bot_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/OrderClosed.lean", "context": {"open": ["Set Filter", "OrderDual (toDual)", "scoped Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[TopologicalSpace \u03b1] [Preorder \u03b1] {s : Set \u03b1}", "[TopologicalSpace \u03b1] [Preorder \u03b1] [ClosedIicTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {a b : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [NoBotOrder \u03b1] [TopologicalSpace \u03b1] [ClosedIicTopology \u03b1] {a : \u03b1}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [ClosedIicTopology \u03b1] [TopologicalSpace \u03b2]", "[TopologicalSpace \u03b1] [Preorder \u03b1] [ClosedIciTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {a b : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [NoTopOrder \u03b1] [TopologicalSpace \u03b1] [ClosedIciTopology \u03b1] {a : \u03b1}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [ClosedIciTopology \u03b1] [TopologicalSpace \u03b2]", "[TopologicalSpace \u03b1] [Preorder \u03b1] [t : OrderClosedTopology \u03b1]", "[TopologicalSpace \u03b1] [PartialOrder \u03b1] [t : OrderClosedTopology \u03b1]", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderClosedTopology \u03b1]", "{a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\n\u22a2 DiscreteTopology \u03b1"}, {"line": "refine discreteTopology_iff_nhds.mpr fun a \u21a6 ?_", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 nhds a = pure a"}, {"line": "rw [\u2190 nhdsWithin_univ]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a univ = pure a"}, {"line": "rw [\u2190 Iic_union_Ioi]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Iic ?m.2914 \u222a Ioi ?m.2914) = pure a\n---\n\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 LinearOrder \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 \u03b1"}, {"line": "rw [nhdsWithin_union]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 nhdsWithin a (Iic ?m.2914) \u2294 nhdsWithin a (Ioi ?m.2914) = pure a\n---\n\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 LinearOrder \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 \u03b1"}, {"line": "rw [PredOrder.nhdsLE]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 pure a \u2294 nhdsWithin a (Ioi a) = pure a\n---\n\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 LinearOrder \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 ClosedIicTopology \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 PredOrder \u03b1"}, {"line": "rw [SuccOrder.nhdsGT]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 pure a \u2294 \u22a5 = pure a\n---\n\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 LinearOrder \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 ClosedIciTopology \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 SuccOrder \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 ClosedIicTopology \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 PredOrder \u03b1"}, {"line": "rw [sup_bot_eq]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 LinearOrder \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 ClosedIciTopology \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 SuccOrder \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 ClosedIicTopology \u03b1\n---\n\u03b1 : Type u\ninst\u271d\u00b3\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : NoBotOrder \u03b1\ninst\u271d\u00b2\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u00b2 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIicTopology \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : NoTopOrder \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9 : PredOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\n\u22a2 PredOrder \u03b1"}]}
{"declaration": "theorem frontier_lt_subset_eq (hf : Continuous f) (hg : Continuous g) :\n    frontier { b | f b < g b } \u2286 { b | f b = g b } := by\n  simpa only [\u2190 not_lt,\u2190 compl_setOf,frontier_compl,eq_comm] using frontier_le_subset_eq hg hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/OrderClosed.lean", "context": {"open": ["Set Filter", "OrderDual (toDual)", "scoped Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[TopologicalSpace \u03b1] [Preorder \u03b1] {s : Set \u03b1}", "[TopologicalSpace \u03b1] [Preorder \u03b1] [ClosedIicTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {a b : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [NoBotOrder \u03b1] [TopologicalSpace \u03b1] [ClosedIicTopology \u03b1] {a : \u03b1}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [ClosedIicTopology \u03b1] [TopologicalSpace \u03b2]", "[TopologicalSpace \u03b1] [Preorder \u03b1] [ClosedIciTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {a b : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [NoTopOrder \u03b1] [TopologicalSpace \u03b1] [ClosedIciTopology \u03b1] {a : \u03b1}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [ClosedIciTopology \u03b1] [TopologicalSpace \u03b2]", "[TopologicalSpace \u03b1] [Preorder \u03b1] [t : OrderClosedTopology \u03b1]", "[TopologicalSpace \u03b1] [PartialOrder \u03b1] [t : OrderClosedTopology \u03b1]", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderClosedTopology \u03b1]", "{a b : \u03b1}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderClosedTopology \u03b1] {f g : \u03b2 \u2192 \u03b1}", "[TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3\u00b3 : Preorder \u03b1\ninst\u271d\u00b3\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b3\u00b9 : Preorder \u03b1\ninst\u271d\u00b3\u2070 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : NoBotOrder \u03b1\ninst\u271d\u00b2\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2074 : LinearOrder \u03b1\ninst\u271d\u00b2\u00b3 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2078 : Preorder \u03b1\ninst\u271d\u00b9\u2077 : NoTopOrder \u03b1\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2075 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : OrderClosedTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderClosedTopology \u03b1\nf g : \u03b2 \u2192 \u03b1\ninst\u271d : TopologicalSpace \u03b2\nhf : Continuous f\nhg : Continuous g\n\u22a2 frontier {b | f b < g b} \u2286 {b | f b = g b}"}, {"line": "simpa only [\u2190 not_lt,\u2190 compl_setOf,frontier_compl,eq_comm] using frontier_le_subset_eq hg hf", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Continuous.min (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun b => min (f b) (g b) := by\n  simp only [min_def]\n  exact hf.if_le hg hf hg fun x => id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/OrderClosed.lean", "context": {"open": ["Set Filter", "OrderDual (toDual)", "scoped Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[TopologicalSpace \u03b1] [Preorder \u03b1] {s : Set \u03b1}", "[TopologicalSpace \u03b1] [Preorder \u03b1] [ClosedIicTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {a b : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [NoBotOrder \u03b1] [TopologicalSpace \u03b1] [ClosedIicTopology \u03b1] {a : \u03b1}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [ClosedIicTopology \u03b1] [TopologicalSpace \u03b2]", "[TopologicalSpace \u03b1] [Preorder \u03b1] [ClosedIciTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {a b : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [NoTopOrder \u03b1] [TopologicalSpace \u03b1] [ClosedIciTopology \u03b1] {a : \u03b1}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [ClosedIciTopology \u03b1] [TopologicalSpace \u03b2]", "[TopologicalSpace \u03b1] [Preorder \u03b1] [t : OrderClosedTopology \u03b1]", "[TopologicalSpace \u03b1] [PartialOrder \u03b1] [t : OrderClosedTopology \u03b1]", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderClosedTopology \u03b1]", "{a b : \u03b1}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderClosedTopology \u03b1] {f g : \u03b2 \u2192 \u03b1}", "[TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3\u00b3 : Preorder \u03b1\ninst\u271d\u00b3\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b3\u00b9 : Preorder \u03b1\ninst\u271d\u00b3\u2070 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : NoBotOrder \u03b1\ninst\u271d\u00b2\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2074 : LinearOrder \u03b1\ninst\u271d\u00b2\u00b3 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2078 : Preorder \u03b1\ninst\u271d\u00b9\u2077 : NoTopOrder \u03b1\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2075 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : OrderClosedTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderClosedTopology \u03b1\nf g : \u03b2 \u2192 \u03b1\ninst\u271d : TopologicalSpace \u03b2\nhf : Continuous f\nhg : Continuous g\n\u22a2 Continuous fun b => min (f b) (g b)"}, {"line": "simp only [min_def]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3\u00b3 : Preorder \u03b1\ninst\u271d\u00b3\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b3\u00b9 : Preorder \u03b1\ninst\u271d\u00b3\u2070 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : NoBotOrder \u03b1\ninst\u271d\u00b2\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2074 : LinearOrder \u03b1\ninst\u271d\u00b2\u00b3 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2078 : Preorder \u03b1\ninst\u271d\u00b9\u2077 : NoTopOrder \u03b1\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2075 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : OrderClosedTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderClosedTopology \u03b1\nf g : \u03b2 \u2192 \u03b1\ninst\u271d : TopologicalSpace \u03b2\nhf : Continuous f\nhg : Continuous g\n\u22a2 Continuous fun b => if f b \u2264 g b then f b else g b"}, {"line": "exact hf.if_le hg hf hg fun x => id", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Filter.Tendsto.max_right {l : Filter \u03b2} {a : \u03b1} (h : Tendsto f l (\ud835\udcdd a)) :\n    Tendsto (fun i => max a (f i)) l (\ud835\udcdd a) := by\n  simpa only [sup_idem] using (tendsto_const_nhds (x := a)).max h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/OrderClosed.lean", "context": {"open": ["Set Filter", "OrderDual (toDual)", "scoped Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[TopologicalSpace \u03b1] [Preorder \u03b1] {s : Set \u03b1}", "[TopologicalSpace \u03b1] [Preorder \u03b1] [ClosedIicTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {a b : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [NoBotOrder \u03b1] [TopologicalSpace \u03b1] [ClosedIicTopology \u03b1] {a : \u03b1}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [ClosedIicTopology \u03b1] [TopologicalSpace \u03b2]", "[TopologicalSpace \u03b1] [Preorder \u03b1] [ClosedIciTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {a b : \u03b1} {s : Set \u03b1}", "[Preorder \u03b1] [NoTopOrder \u03b1] [TopologicalSpace \u03b1] [ClosedIciTopology \u03b1] {a : \u03b1}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [ClosedIciTopology \u03b1] [TopologicalSpace \u03b2]", "[TopologicalSpace \u03b1] [Preorder \u03b1] [t : OrderClosedTopology \u03b1]", "[TopologicalSpace \u03b1] [PartialOrder \u03b1] [t : OrderClosedTopology \u03b1]", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderClosedTopology \u03b1]", "{a b : \u03b1}", "[TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderClosedTopology \u03b1] {f g : \u03b2 \u2192 \u03b1}", "[TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3\u00b3 : Preorder \u03b1\ninst\u271d\u00b3\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b3\u00b9 : Preorder \u03b1\ninst\u271d\u00b3\u2070 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : NoBotOrder \u03b1\ninst\u271d\u00b2\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2076 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2074 : LinearOrder \u03b1\ninst\u271d\u00b2\u00b3 : ClosedIicTopology \u03b1\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2078 : Preorder \u03b1\ninst\u271d\u00b9\u2077 : NoTopOrder \u03b1\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2075 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : ClosedIciTopology \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : Preorder \u03b1\nt\u271d : OrderClosedTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\nt : OrderClosedTopology \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : OrderClosedTopology \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderClosedTopology \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : TopologicalSpace \u03b2\nl : Filter \u03b2\na : \u03b1\nh : Tendsto f l (nhds a)\n\u22a2 Tendsto (fun i => max a (f i)) l (nhds a)"}, {"line": "simpa only [sup_idem] using (tendsto_const_nhds (x := a)).max h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_ordConnectedSection_ordSeparatingSet_mem_nhds (hd : Disjoint s (closure t))\n    (ha : a \u2208 s) : (ordConnectedSection <| ordSeparatingSet s t)\u1d9c \u2208 \ud835\udcdd a := by\n  rw [\u2190 nhdsLE_sup_nhdsGE]\n  rw [mem_sup]\n  exact \u27e8compl_ordConnectedSection_ordSeparatingSet_mem_nhdsLE hd ha,\n    compl_ordConnectedSection_ordSeparatingSet_mem_nhdsGE hd ha\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Order/T5.lean", "context": {"open": ["Filter Set Function OrderDual Topology Interval"], "variables": ["{X : Type*} [LinearOrder X] [TopologicalSpace X] [OrderTopology X] {a : X} {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : OrderTopology X\na : X\ns t : Set X\nhd : Disjoint s (closure t)\nha : a \u2208 s\n\u22a2 (s.ordSeparatingSet t).ordConnectedSection\u1d9c \u2208 nhds a"}, {"line": "rw [\u2190 nhdsLE_sup_nhdsGE]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : OrderTopology X\na : X\ns t : Set X\nhd : Disjoint s (closure t)\nha : a \u2208 s\n\u22a2 (s.ordSeparatingSet t).ordConnectedSection\u1d9c \u2208 nhdsWithin a (Iic a) \u2294 nhdsWithin a (Ici a)\n---\nX : Type u_1\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : OrderTopology X\na : X\ns t : Set X\nhd : Disjoint s (closure t)\nha : a \u2208 s\n\u22a2 LinearOrder X"}, {"line": "rw [mem_sup]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : OrderTopology X\na : X\ns t : Set X\nhd : Disjoint s (closure t)\nha : a \u2208 s\n\u22a2 (s.ordSeparatingSet t).ordConnectedSection\u1d9c \u2208 nhdsWithin a (Iic a) \u2227\n    (s.ordSeparatingSet t).ordConnectedSection\u1d9c \u2208 nhdsWithin a (Ici a)\n---\nX : Type u_1\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : OrderTopology X\na : X\ns t : Set X\nhd : Disjoint s (closure t)\nha : a \u2208 s\n\u22a2 LinearOrder X\n---\nX : Type u_1\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : OrderTopology X\na : X\ns t : Set X\nhd : Disjoint s (closure t)\nha : a \u2208 s\n\u22a2 LinearOrder X"}, {"line": "exact \u27e8compl_ordConnectedSection_ordSeparatingSet_mem_nhdsLE hd ha,\n    compl_ordConnectedSection_ordSeparatingSet_mem_nhdsGE hd ha\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasSeparatingCover.mono {s\u2081 s\u2082 t\u2081 t\u2082 : Set X} (sc_st : HasSeparatingCover s\u2082 t\u2082)\n    (s_sub : s\u2081 \u2286 s\u2082) (t_sub : t\u2081 \u2286 t\u2082) : HasSeparatingCover s\u2081 t\u2081 := by\n  obtain \u27e8u, u_cov, u_props\u27e9 := sc_st\n  exact\n    \u27e8u,\n     s_sub.trans u_cov,\n     fun n \u21a6\n       \u27e8(u_props n).1,\n        disjoint_of_subset (fun \u2983_\u2984 a \u21a6 a) t_sub (u_props n).2\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/SeparatedNhds.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns\u2081 s\u2082 t\u2081 t\u2082 : Set X\nsc_st : HasSeparatingCover s\u2082 t\u2082\ns_sub : s\u2081 \u2286 s\u2082\nt_sub : t\u2081 \u2286 t\u2082\n\u22a2 HasSeparatingCover s\u2081 t\u2081"}, {"line": "obtain \u27e8u, u_cov, u_props\u27e9 := sc_st", "tactic_state": "case intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns\u2081 s\u2082 t\u2081 t\u2082 : Set X\ns_sub : s\u2081 \u2286 s\u2082\nt_sub : t\u2081 \u2286 t\u2082\nu : \u2115 \u2192 Set X\nu_cov : s\u2082 \u2286 \u22c3 n, u n\nu_props : \u2200 (n : \u2115), IsOpen (u n) \u2227 Disjoint (closure (u n)) t\u2082\n\u22a2 HasSeparatingCover s\u2081 t\u2081"}, {"line": "exact\n    \u27e8u,\n     s_sub.trans u_cov,\n     fun n \u21a6\n       \u27e8(u_props n).1,\n        disjoint_of_subset (fun \u2983_\u2984 a \u21a6 a) t_sub (u_props n).2\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem union_left : SeparatedNhds s u \u2192 SeparatedNhds t u \u2192 SeparatedNhds (s \u222a t) u := by\n  simpa only [separatedNhds_iff_disjoint,nhdsSet_union,disjoint_sup_left] using And.intro\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/SeparatedNhds.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns t u : Set X\n\u22a2 SeparatedNhds s u \u2192 SeparatedNhds t u \u2192 SeparatedNhds (s \u222a t) u"}, {"line": "simpa only [separatedNhds_iff_disjoint,nhdsSet_union,disjoint_sup_left] using And.intro", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isOpen_left_of_isOpen_union (hst : SeparatedNhds s t) (hst' : IsOpen (s \u222a t)) : IsOpen s := by\n  obtain \u27e8u, v, hu, hv, hsu, htv, huv\u27e9 := hst\n  suffices s = (s \u222a t) \u2229 u from this \u25b8 hst'.inter hu\n  rw [union_inter_distrib_right]\n  rw [(huv.symm.mono_left htv).inter_eq]\n  rw [union_empty]\n  rw [inter_eq_left.2 hsu]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/SeparatedNhds.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst : SeparatedNhds s t\nhst' : IsOpen (s \u222a t)\n\u22a2 IsOpen s"}, {"line": "obtain \u27e8u, v, hu, hv, hsu, htv, huv\u27e9 := hst", "tactic_state": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst' : IsOpen (s \u222a t)\nu v : Set X\nhu : IsOpen u\nhv : IsOpen v\nhsu : s \u2286 u\nhtv : t \u2286 v\nhuv : Disjoint u v\n\u22a2 IsOpen s"}, {"line": "suffices s = (s \u222a t) \u2229 u from this \u25b8 hst'.inter hu", "tactic_state": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst' : IsOpen (s \u222a t)\nu v : Set X\nhu : IsOpen u\nhv : IsOpen v\nhsu : s \u2286 u\nhtv : t \u2286 v\nhuv : Disjoint u v\n\u22a2 s = (s \u222a t) \u2229 u"}, {"line": "rw [union_inter_distrib_right]", "tactic_state": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst' : IsOpen (s \u222a t)\nu v : Set X\nhu : IsOpen u\nhv : IsOpen v\nhsu : s \u2286 u\nhtv : t \u2286 v\nhuv : Disjoint u v\n\u22a2 s = s \u2229 u \u222a t \u2229 u"}, {"line": "rw [(huv.symm.mono_left htv).inter_eq]", "tactic_state": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst' : IsOpen (s \u222a t)\nu v : Set X\nhu : IsOpen u\nhv : IsOpen v\nhsu : s \u2286 u\nhtv : t \u2286 v\nhuv : Disjoint u v\n\u22a2 s = s \u2229 u \u222a \u2205"}, {"line": "rw [union_empty]", "tactic_state": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst' : IsOpen (s \u222a t)\nu v : Set X\nhu : IsOpen u\nhv : IsOpen v\nhsu : s \u2286 u\nhtv : t \u2286 v\nhuv : Disjoint u v\n\u22a2 s = s \u2229 u"}, {"line": "rw [inter_eq_left.2 hsu]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isClosed_left_of_isClosed_union (hst : SeparatedNhds s t) (hst' : IsClosed (s \u222a t)) :\n    IsClosed s := by\n  obtain \u27e8u, v, hu, hv, hsu, htv, huv\u27e9 := hst\n  rw [\u2190 isOpen_compl_iff] at hst' \u22a2\n  suffices s\u1d9c = (s \u222a t)\u1d9c \u222a v from this \u25b8 hst'.union hv\n  rw [\u2190 compl_inj_iff]\n  rw [Set.compl_union]\n  rw [compl_compl]\n  rw [compl_compl]\n  rw [union_inter_distrib_right]\n  rw [(disjoint_compl_right.mono_left htv).inter_eq]\n  rw [union_empty]\n  rw [left_eq_inter]\n  rw [subset_compl_comm]\n  exact (huv.mono_left hsu).subset_compl_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/SeparatedNhds.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst : SeparatedNhds s t\nhst' : IsClosed (s \u222a t)\n\u22a2 IsClosed s"}, {"line": "obtain \u27e8u, v, hu, hv, hsu, htv, huv\u27e9 := hst", "tactic_state": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst' : IsClosed (s \u222a t)\nu v : Set X\nhu : IsOpen u\nhv : IsOpen v\nhsu : s \u2286 u\nhtv : t \u2286 v\nhuv : Disjoint u v\n\u22a2 IsClosed s"}, {"line": "rw [\u2190 isOpen_compl_iff] at hst' \u22a2", "tactic_state": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst' : IsOpen (s \u222a t)\u1d9c\nu v : Set X\nhu : IsOpen u\nhv : IsOpen v\nhsu : s \u2286 u\nhtv : t \u2286 v\nhuv : Disjoint u v\n\u22a2 IsOpen s\u1d9c"}, {"line": "suffices s\u1d9c = (s \u222a t)\u1d9c \u222a v from this \u25b8 hst'.union hv", "tactic_state": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst' : IsOpen (s \u222a t)\u1d9c\nu v : Set X\nhu : IsOpen u\nhv : IsOpen v\nhsu : s \u2286 u\nhtv : t \u2286 v\nhuv : Disjoint u v\n\u22a2 s\u1d9c = (s \u222a t)\u1d9c \u222a v"}, {"line": "rw [\u2190 compl_inj_iff]", "tactic_state": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst' : IsOpen (s \u222a t)\u1d9c\nu v : Set X\nhu : IsOpen u\nhv : IsOpen v\nhsu : s \u2286 u\nhtv : t \u2286 v\nhuv : Disjoint u v\n\u22a2 s\u1d9c\u1d9c = ((s \u222a t)\u1d9c \u222a v)\u1d9c"}, {"line": "rw [Set.compl_union]", "tactic_state": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst' : IsOpen (s \u222a t)\u1d9c\nu v : Set X\nhu : IsOpen u\nhv : IsOpen v\nhsu : s \u2286 u\nhtv : t \u2286 v\nhuv : Disjoint u v\n\u22a2 s\u1d9c\u1d9c = (s \u222a t)\u1d9c\u1d9c \u2229 v\u1d9c"}, {"line": "rw [compl_compl]", "tactic_state": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst' : IsOpen (s \u222a t)\u1d9c\nu v : Set X\nhu : IsOpen u\nhv : IsOpen v\nhsu : s \u2286 u\nhtv : t \u2286 v\nhuv : Disjoint u v\n\u22a2 s = (s \u222a t)\u1d9c\u1d9c \u2229 v\u1d9c"}, {"line": "rw [compl_compl]", "tactic_state": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst' : IsOpen (s \u222a t)\u1d9c\nu v : Set X\nhu : IsOpen u\nhv : IsOpen v\nhsu : s \u2286 u\nhtv : t \u2286 v\nhuv : Disjoint u v\n\u22a2 s = (s \u222a t) \u2229 v\u1d9c"}, {"line": "rw [union_inter_distrib_right]", "tactic_state": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst' : IsOpen (s \u222a t)\u1d9c\nu v : Set X\nhu : IsOpen u\nhv : IsOpen v\nhsu : s \u2286 u\nhtv : t \u2286 v\nhuv : Disjoint u v\n\u22a2 s = s \u2229 v\u1d9c \u222a t \u2229 v\u1d9c"}, {"line": "rw [(disjoint_compl_right.mono_left htv).inter_eq]", "tactic_state": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst' : IsOpen (s \u222a t)\u1d9c\nu v : Set X\nhu : IsOpen u\nhv : IsOpen v\nhsu : s \u2286 u\nhtv : t \u2286 v\nhuv : Disjoint u v\n\u22a2 s = s \u2229 v\u1d9c \u222a \u2205"}, {"line": "rw [union_empty]", "tactic_state": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst' : IsOpen (s \u222a t)\u1d9c\nu v : Set X\nhu : IsOpen u\nhv : IsOpen v\nhsu : s \u2286 u\nhtv : t \u2286 v\nhuv : Disjoint u v\n\u22a2 s = s \u2229 v\u1d9c"}, {"line": "rw [left_eq_inter]", "tactic_state": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst' : IsOpen (s \u222a t)\u1d9c\nu v : Set X\nhu : IsOpen u\nhv : IsOpen v\nhsu : s \u2286 u\nhtv : t \u2286 v\nhuv : Disjoint u v\n\u22a2 s \u2286 v\u1d9c"}, {"line": "rw [subset_compl_comm]", "tactic_state": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhst' : IsOpen (s \u222a t)\u1d9c\nu v : Set X\nhu : IsOpen u\nhv : IsOpen v\nhsu : s \u2286 u\nhtv : t \u2286 v\nhuv : Disjoint u v\n\u22a2 v \u2286 s\u1d9c"}, {"line": "exact (huv.mono_left hsu).subset_compl_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem t0Space_iff_or_not_mem_closure (X : Type u) [TopologicalSpace X] :\n    T0Space X \u2194 Pairwise fun a b : X => a \u2209 closure ({b} : Set X) \u2228 b \u2209 closure ({a} : Set X) := by\n  simp only [t0Space_iff_not_inseparable]\n  simp only [inseparable_iff_mem_closure]\n  simp only [not_and_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Basic.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u22a2 T0Space X \u2194 Pairwise fun a b => a \u2209 closure {b} \u2228 b \u2209 closure {a}"}, {"line": "simp only [t0Space_iff_not_inseparable]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u22a2 (Pairwise fun x y => \u00acInseparable x y) \u2194 Pairwise fun a b => a \u2209 closure {b} \u2228 b \u2209 closure {a}"}, {"line": "simp only [inseparable_iff_mem_closure]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u22a2 (Pairwise fun x y => \u00ac(x \u2208 closure {y} \u2227 y \u2208 closure {x})) \u2194 Pairwise fun a b => a \u2209 closure {b} \u2228 b \u2209 closure {a}"}, {"line": "simp only [not_and_or]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ne.nhdsWithin_diff_singleton [T1Space X] {x y : X} (h : x \u2260 y) (s : Set X) :\n    \ud835\udcdd[s \\ {y}] x = \ud835\udcdd[s] x := by\n  rw [diff_eq]\n  rw [inter_comm]\n  rw [nhdsWithin_inter_of_mem]\n  exact mem_nhdsWithin_of_mem_nhds (isOpen_ne.mem_nhds h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Basic.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[R0Space X] {x y : X}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nx y : X\nh : x \u2260 y\ns : Set X\n\u22a2 nhdsWithin x (s \\ {y}) = nhdsWithin x s"}, {"line": "rw [diff_eq]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nx y : X\nh : x \u2260 y\ns : Set X\n\u22a2 nhdsWithin x (s \u2229 {y}\u1d9c) = nhdsWithin x s"}, {"line": "rw [inter_comm]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nx y : X\nh : x \u2260 y\ns : Set X\n\u22a2 nhdsWithin x ({y}\u1d9c \u2229 s) = nhdsWithin x s"}, {"line": "rw [nhdsWithin_inter_of_mem]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nx y : X\nh : x \u2260 y\ns : Set X\n\u22a2 {y}\u1d9c \u2208 nhdsWithin x s"}, {"line": "exact mem_nhdsWithin_of_mem_nhds (isOpen_ne.mem_nhds h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem t1Space_TFAE (X : Type u) [TopologicalSpace X] :\n    List.TFAE [T1Space X,\n      \u2200 x, IsClosed ({ x } : Set X),\n      \u2200 x, IsOpen ({ x }\u1d9c : Set X),\n      Continuous (@CofiniteTopology.of X),\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 \ud835\udcdd x,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 \ud835\udcdd x, y \u2209 s,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U : Set X, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (\ud835\udcdd x) (pure y),\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (pure x) (\ud835\udcdd y),\n      \u2200 \u2983x y : X\u2984, x \u2933 y \u2192 x = y] := by\n  tfae_have 1 \u2194 2 := \u27e8fun h => h.1, fun h => \u27e8h\u27e9\u27e9\n  tfae_have 2 \u2194 3 := by\n    simp only [isOpen_compl_iff]\n  tfae_have 5 \u2194 3 := by\n    refine forall_swap.trans ?_\n    simp only [isOpen_iff_mem_nhds]\n    simp only [mem_compl_iff]\n    simp only [mem_singleton_iff]\n  tfae_have 5 \u2194 6 := by\n    simp only [\u2190 subset_compl_singleton_iff]\n    simp only [exists_mem_subset_iff]\n  tfae_have 5 \u2194 7 := by\n    simp only [(nhds_basis_opens _).mem_iff]\n    simp only [subset_compl_singleton_iff]\n    simp only [exists_prop]\n    simp only [and_assoc]\n    simp only [and_left_comm]\n  tfae_have 5 \u2194 8 := by\n    simp only [\u2190 principal_singleton]\n    simp only [disjoint_principal_right]\n  tfae_have 8 \u2194 9 := forall_swap.trans (by simp only [disjoint_comm, ne_comm])\n  tfae_have 1 \u2192 4 := by\n    simp only [continuous_def]\n    simp only [CofiniteTopology.isOpen_iff']\n    rintro H s (rfl | hs)\n    exacts [isOpen_empty, compl_compl s \u25b8 (@Set.Finite.isClosed _ _ H _ hs).isOpen_compl]\n  tfae_have 4 \u2192 2 :=\n    fun h x => (CofiniteTopology.isClosed_iff.2 <| Or.inr (finite_singleton _)).preimage h\n  tfae_have 2 \u2194 10 := by\n    simp only [\u2190 closure_subset_iff_isClosed]\n    simp only [specializes_iff_mem_closure]\n    simp only [subset_def]\n    simp only [mem_singleton_iff]\n    simp only [eq_comm]\n  tfae_finish\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Basic.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[R0Space X] {x y : X}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u22a2 [T1Space X, \u2200 (x : X), IsClosed {x}, \u2200 (x : X), IsOpen {x}\u1d9c, Continuous \u21d1CofiniteTopology.of,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y),\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (pure x) (nhds y), \u2200 \u2983x y : X\u2984, x \u2933 y \u2192 x = y].TFAE"}, {"line": "tfae_have 1 \u2194 2 := \u27e8fun h => h.1, fun h => \u27e8h\u27e9\u27e9", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ntfae_1_iff_2 : T1Space X \u2194 \u2200 (x : X), IsClosed {x}\n\u22a2 [T1Space X, \u2200 (x : X), IsClosed {x}, \u2200 (x : X), IsOpen {x}\u1d9c, Continuous \u21d1CofiniteTopology.of,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y),\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (pure x) (nhds y), \u2200 \u2983x y : X\u2984, x \u2933 y \u2192 x = y].TFAE"}, {"line": "tfae_have 2 \u2194 3 := by\n    simp only [isOpen_compl_iff]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ntfae_1_iff_2 : T1Space X \u2194 \u2200 (x : X), IsClosed {x}\ntfae_2_iff_3 : (\u2200 (x : X), IsClosed {x}) \u2194 \u2200 (x : X), IsOpen {x}\u1d9c\n\u22a2 [T1Space X, \u2200 (x : X), IsClosed {x}, \u2200 (x : X), IsOpen {x}\u1d9c, Continuous \u21d1CofiniteTopology.of,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y),\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (pure x) (nhds y), \u2200 \u2983x y : X\u2984, x \u2933 y \u2192 x = y].TFAE"}, {"line": "tfae_have 5 \u2194 3 := by\n    refine forall_swap.trans ?_\n    simp only [isOpen_iff_mem_nhds]\n    simp only [mem_compl_iff]\n    simp only [mem_singleton_iff]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ntfae_1_iff_2 : T1Space X \u2194 \u2200 (x : X), IsClosed {x}\ntfae_2_iff_3 : (\u2200 (x : X), IsClosed {x}) \u2194 \u2200 (x : X), IsOpen {x}\u1d9c\ntfae_5_iff_3 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 (x : X), IsOpen {x}\u1d9c\n\u22a2 [T1Space X, \u2200 (x : X), IsClosed {x}, \u2200 (x : X), IsOpen {x}\u1d9c, Continuous \u21d1CofiniteTopology.of,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y),\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (pure x) (nhds y), \u2200 \u2983x y : X\u2984, x \u2933 y \u2192 x = y].TFAE"}, {"line": "tfae_have 5 \u2194 6 := by\n    simp only [\u2190 subset_compl_singleton_iff]\n    simp only [exists_mem_subset_iff]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ntfae_1_iff_2 : T1Space X \u2194 \u2200 (x : X), IsClosed {x}\ntfae_2_iff_3 : (\u2200 (x : X), IsClosed {x}) \u2194 \u2200 (x : X), IsOpen {x}\u1d9c\ntfae_5_iff_3 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 (x : X), IsOpen {x}\u1d9c\ntfae_5_iff_6 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s\n\u22a2 [T1Space X, \u2200 (x : X), IsClosed {x}, \u2200 (x : X), IsOpen {x}\u1d9c, Continuous \u21d1CofiniteTopology.of,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y),\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (pure x) (nhds y), \u2200 \u2983x y : X\u2984, x \u2933 y \u2192 x = y].TFAE"}, {"line": "tfae_have 5 \u2194 7 := by\n    simp only [(nhds_basis_opens _).mem_iff]\n    simp only [subset_compl_singleton_iff]\n    simp only [exists_prop]\n    simp only [and_assoc]\n    simp only [and_left_comm]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ntfae_1_iff_2 : T1Space X \u2194 \u2200 (x : X), IsClosed {x}\ntfae_2_iff_3 : (\u2200 (x : X), IsClosed {x}) \u2194 \u2200 (x : X), IsOpen {x}\u1d9c\ntfae_5_iff_3 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 (x : X), IsOpen {x}\u1d9c\ntfae_5_iff_6 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s\ntfae_5_iff_7 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U\n\u22a2 [T1Space X, \u2200 (x : X), IsClosed {x}, \u2200 (x : X), IsOpen {x}\u1d9c, Continuous \u21d1CofiniteTopology.of,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y),\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (pure x) (nhds y), \u2200 \u2983x y : X\u2984, x \u2933 y \u2192 x = y].TFAE"}, {"line": "tfae_have 5 \u2194 8 := by\n    simp only [\u2190 principal_singleton]\n    simp only [disjoint_principal_right]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ntfae_1_iff_2 : T1Space X \u2194 \u2200 (x : X), IsClosed {x}\ntfae_2_iff_3 : (\u2200 (x : X), IsClosed {x}) \u2194 \u2200 (x : X), IsOpen {x}\u1d9c\ntfae_5_iff_3 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 (x : X), IsOpen {x}\u1d9c\ntfae_5_iff_6 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s\ntfae_5_iff_7 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U\ntfae_5_iff_8 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y)\n\u22a2 [T1Space X, \u2200 (x : X), IsClosed {x}, \u2200 (x : X), IsOpen {x}\u1d9c, Continuous \u21d1CofiniteTopology.of,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y),\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (pure x) (nhds y), \u2200 \u2983x y : X\u2984, x \u2933 y \u2192 x = y].TFAE"}, {"line": "tfae_have 8 \u2194 9 := forall_swap.trans (by simp only [disjoint_comm, ne_comm])", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ntfae_1_iff_2 : T1Space X \u2194 \u2200 (x : X), IsClosed {x}\ntfae_2_iff_3 : (\u2200 (x : X), IsClosed {x}) \u2194 \u2200 (x : X), IsOpen {x}\u1d9c\ntfae_5_iff_3 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 (x : X), IsOpen {x}\u1d9c\ntfae_5_iff_6 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s\ntfae_5_iff_7 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U\ntfae_5_iff_8 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y)\ntfae_8_iff_9 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y)) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (pure x) (nhds y)\n\u22a2 [T1Space X, \u2200 (x : X), IsClosed {x}, \u2200 (x : X), IsOpen {x}\u1d9c, Continuous \u21d1CofiniteTopology.of,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y),\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (pure x) (nhds y), \u2200 \u2983x y : X\u2984, x \u2933 y \u2192 x = y].TFAE"}, {"line": "tfae_have 1 \u2192 4 := by\n    simp only [continuous_def]\n    simp only [CofiniteTopology.isOpen_iff']\n    rintro H s (rfl | hs)\n    exacts [isOpen_empty, compl_compl s \u25b8 (@Set.Finite.isClosed _ _ H _ hs).isOpen_compl]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ntfae_1_iff_2 : T1Space X \u2194 \u2200 (x : X), IsClosed {x}\ntfae_2_iff_3 : (\u2200 (x : X), IsClosed {x}) \u2194 \u2200 (x : X), IsOpen {x}\u1d9c\ntfae_5_iff_3 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 (x : X), IsOpen {x}\u1d9c\ntfae_5_iff_6 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s\ntfae_5_iff_7 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U\ntfae_5_iff_8 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y)\ntfae_8_iff_9 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y)) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (pure x) (nhds y)\ntfae_1_to_4 : T1Space X \u2192 Continuous \u21d1CofiniteTopology.of\n\u22a2 [T1Space X, \u2200 (x : X), IsClosed {x}, \u2200 (x : X), IsOpen {x}\u1d9c, Continuous \u21d1CofiniteTopology.of,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y),\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (pure x) (nhds y), \u2200 \u2983x y : X\u2984, x \u2933 y \u2192 x = y].TFAE"}, {"line": "tfae_have 4 \u2192 2 :=\n    fun h x => (CofiniteTopology.isClosed_iff.2 <| Or.inr (finite_singleton _)).preimage h", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ntfae_1_iff_2 : T1Space X \u2194 \u2200 (x : X), IsClosed {x}\ntfae_2_iff_3 : (\u2200 (x : X), IsClosed {x}) \u2194 \u2200 (x : X), IsOpen {x}\u1d9c\ntfae_5_iff_3 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 (x : X), IsOpen {x}\u1d9c\ntfae_5_iff_6 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s\ntfae_5_iff_7 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U\ntfae_5_iff_8 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y)\ntfae_8_iff_9 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y)) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (pure x) (nhds y)\ntfae_1_to_4 : T1Space X \u2192 Continuous \u21d1CofiniteTopology.of\ntfae_4_to_2 : Continuous \u21d1CofiniteTopology.of \u2192 \u2200 (x : X), IsClosed {x}\n\u22a2 [T1Space X, \u2200 (x : X), IsClosed {x}, \u2200 (x : X), IsOpen {x}\u1d9c, Continuous \u21d1CofiniteTopology.of,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y),\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (pure x) (nhds y), \u2200 \u2983x y : X\u2984, x \u2933 y \u2192 x = y].TFAE"}, {"line": "tfae_have 2 \u2194 10 := by\n    simp only [\u2190 closure_subset_iff_isClosed]\n    simp only [specializes_iff_mem_closure]\n    simp only [subset_def]\n    simp only [mem_singleton_iff]\n    simp only [eq_comm]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ntfae_1_iff_2 : T1Space X \u2194 \u2200 (x : X), IsClosed {x}\ntfae_2_iff_3 : (\u2200 (x : X), IsClosed {x}) \u2194 \u2200 (x : X), IsOpen {x}\u1d9c\ntfae_5_iff_3 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 (x : X), IsOpen {x}\u1d9c\ntfae_5_iff_6 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s\ntfae_5_iff_7 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U\ntfae_5_iff_8 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y)\ntfae_8_iff_9 : (\u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y)) \u2194 \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (pure x) (nhds y)\ntfae_1_to_4 : T1Space X \u2192 Continuous \u21d1CofiniteTopology.of\ntfae_4_to_2 : Continuous \u21d1CofiniteTopology.of \u2192 \u2200 (x : X), IsClosed {x}\ntfae_2_iff_10 : (\u2200 (x : X), IsClosed {x}) \u2194 \u2200 \u2983x y : X\u2984, x \u2933 y \u2192 x = y\n\u22a2 [T1Space X, \u2200 (x : X), IsClosed {x}, \u2200 (x : X), IsOpen {x}\u1d9c, Continuous \u21d1CofiniteTopology.of,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 nhds x, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 s \u2208 nhds x, y \u2209 s,\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U, \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (nhds x) (pure y),\n      \u2200 \u2983x y : X\u2984, x \u2260 y \u2192 Disjoint (pure x) (nhds y), \u2200 \u2983x y : X\u2984, x \u2933 y \u2192 x = y].TFAE"}, {"line": "tfae_finish", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Set.Subsingleton.isClosed [T1Space X] {s : Set X} (hs : s.Subsingleton) : IsClosed s := by\n  rcases hs.eq_empty_or_singleton with rfl | \u27e8x, rfl\u27e9\n  \u00b7 exact isClosed_empty\n  \u00b7 exact isClosed_singleton\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Basic.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[R0Space X] {x y : X}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\ns : Set X\nhs : s.Subsingleton\n\u22a2 IsClosed s"}, {"line": "rcases hs.eq_empty_or_singleton with rfl | \u27e8x, rfl\u27e9", "tactic_state": "case inl\nX : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nhs : \u2205.Subsingleton\n\u22a2 IsClosed \u2205\n---\ncase inr.intro\nX : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nx : X\nhs : {x}.Subsingleton\n\u22a2 IsClosed {x}"}, {"line": "\u00b7 exact isClosed_empty", "tactic_state": "case inr.intro\nX : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nx : X\nhs : {x}.Subsingleton\n\u22a2 IsClosed {x}"}, {"line": "\u00b7 exact isClosed_singleton", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsWithin_insert_of_ne [T1Space X] {x y : X} {s : Set X} (hxy : x \u2260 y) :\n    \ud835\udcdd[insert y s] x = \ud835\udcdd[s] x := by\n  refine le_antisymm (Filter.le_def.2 fun t ht => ?_) (nhdsWithin_mono x <| subset_insert y s)\n  obtain \u27e8o, ho, hxo, host\u27e9 := mem_nhdsWithin.mp ht\n  refine mem_nhdsWithin.mpr \u27e8o \\ {y}, ho.sdiff isClosed_singleton, \u27e8hxo, hxy\u27e9, ?_\u27e9\n  rw [inter_insert_of_not_mem <| not_mem_diff_of_mem (mem_singleton y)]\n  exact (inter_subset_inter diff_subset Subset.rfl).trans host\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Basic.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[R0Space X] {x y : X}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nx y : X\ns : Set X\nhxy : x \u2260 y\n\u22a2 nhdsWithin x (insert y s) = nhdsWithin x s"}, {"line": "refine le_antisymm (Filter.le_def.2 fun t ht => ?_) (nhdsWithin_mono x <| subset_insert y s)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nx y : X\ns : Set X\nhxy : x \u2260 y\nt : Set X\nht : t \u2208 nhdsWithin x s\n\u22a2 t \u2208 nhdsWithin x (insert y s)"}, {"line": "obtain \u27e8o, ho, hxo, host\u27e9 := mem_nhdsWithin.mp ht", "tactic_state": "case intro.intro.intro\nX : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nx y : X\ns : Set X\nhxy : x \u2260 y\nt : Set X\nht : t \u2208 nhdsWithin x s\no : Set X\nho : IsOpen o\nhxo : x \u2208 o\nhost : o \u2229 s \u2286 t\n\u22a2 t \u2208 nhdsWithin x (insert y s)"}, {"line": "refine mem_nhdsWithin.mpr \u27e8o \\ {y}, ho.sdiff isClosed_singleton, \u27e8hxo, hxy\u27e9, ?_\u27e9", "tactic_state": "case intro.intro.intro\nX : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nx y : X\ns : Set X\nhxy : x \u2260 y\nt : Set X\nht : t \u2208 nhdsWithin x s\no : Set X\nho : IsOpen o\nhxo : x \u2208 o\nhost : o \u2229 s \u2286 t\n\u22a2 o \\ {y} \u2229 insert y s \u2286 t"}, {"line": "rw [inter_insert_of_not_mem <| not_mem_diff_of_mem (mem_singleton y)]", "tactic_state": "case intro.intro.intro\nX : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nx y : X\ns : Set X\nhxy : x \u2260 y\nt : Set X\nht : t \u2208 nhdsWithin x s\no : Set X\nho : IsOpen o\nhxo : x \u2208 o\nhost : o \u2229 s \u2286 t\n\u22a2 o \\ {y} \u2229 s \u2286 t"}, {"line": "exact (inter_subset_inter diff_subset Subset.rfl).trans host", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ker_nhds [T1Space X] (x : X) : (\ud835\udcdd x).ker = {x} := by\n  simp [ker_nhds_eq_specializes]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Basic.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[R0Space X] {x y : X}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nx : X\n\u22a2 (nhds x).ker = {x}"}, {"line": "simp [ker_nhds_eq_specializes]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nx : X\n\u22a2 {y | y \u2933 x} = {x}"}]}
{"declaration": "theorem biInter_basis_nhds [T1Space X] {\u03b9 : Sort*} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set X} {x : X}\n    (h : (\ud835\udcdd x).HasBasis p s) : \u22c2 (i) (_ : p i), s i = {x} := by\n  rw [\u2190 h.ker]\n  rw [ker_nhds]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Basic.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[R0Space X] {x y : X}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set X\nx : X\nh : (nhds x).HasBasis p s\n\u22a2 \u22c2 i, \u22c2 (_ : p i), s i = {x}"}, {"line": "rw [\u2190 h.ker]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set X\nx : X\nh : (nhds x).HasBasis p s\n\u22a2 (nhds x).ker = {x}"}, {"line": "rw [ker_nhds]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set X\nx : X\nh : (nhds x).HasBasis p s\n\u22a2 T1Space X"}]}
{"declaration": "theorem compl_singleton_mem_nhdsSet_iff [T1Space X] {x : X} {s : Set X} : {x}\u1d9c \u2208 \ud835\udcdd\u02e2 s \u2194 x \u2209 s := by\n  rw [isOpen_compl_singleton.mem_nhdsSet]\n  rw [subset_compl_singleton_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Basic.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[R0Space X] {x y : X}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nx : X\ns : Set X\n\u22a2 {x}\u1d9c \u2208 nhdsSet s \u2194 x \u2209 s"}, {"line": "rw [isOpen_compl_singleton.mem_nhdsSet]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nx : X\ns : Set X\n\u22a2 s \u2286 {x}\u1d9c \u2194 x \u2209 s\n---\nX : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nx : X\ns : Set X\n\u22a2 T1Space X"}, {"line": "rw [subset_compl_singleton_iff]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\nx : X\ns : Set X\n\u22a2 T1Space X"}]}
{"declaration": "theorem nhdsSet_inj_iff [T1Space X] {s t : Set X} : \ud835\udcdd\u02e2 s = \ud835\udcdd\u02e2 t \u2194 s = t := by\n  simp_rw [le_antisymm_iff]\n  exact and_congr nhdsSet_le_iff nhdsSet_le_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Basic.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[R0Space X] {x y : X}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\ns t : Set X\n\u22a2 nhdsSet s = nhdsSet t \u2194 s = t"}, {"line": "simp_rw [le_antisymm_iff]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\ns t : Set X\n\u22a2 nhdsSet s \u2264 nhdsSet t \u2227 nhdsSet t \u2264 nhdsSet s \u2194 s \u2264 t \u2227 t \u2264 s"}, {"line": "exact and_congr nhdsSet_le_iff nhdsSet_le_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_le_nhdsSet_iff [T1Space X] {s : Set X} {x : X} : \ud835\udcdd x \u2264 \ud835\udcdd\u02e2 s \u2194 x \u2208 s := by\n  rw [\u2190 nhdsSet_singleton]\n  rw [nhdsSet_le_iff]\n  rw [singleton_subset_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Basic.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[R0Space X] {x y : X}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\ns : Set X\nx : X\n\u22a2 nhds x \u2264 nhdsSet s \u2194 x \u2208 s"}, {"line": "rw [\u2190 nhdsSet_singleton]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\ns : Set X\nx : X\n\u22a2 nhdsSet {x} \u2264 nhdsSet s \u2194 x \u2208 s"}, {"line": "rw [nhdsSet_le_iff]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\ns : Set X\nx : X\n\u22a2 {x} \u2286 s \u2194 x \u2208 s\n---\nX : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\ns : Set X\nx : X\n\u22a2 T1Space X"}, {"line": "rw [singleton_subset_iff]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ninst\u271d : T1Space X\ns : Set X\nx : X\n\u22a2 T1Space X"}]}
{"declaration": "theorem Dense.diff_finite [T1Space X] [\u2200 x : X, NeBot (\ud835\udcdd[\u2260] x)] {s : Set X} (hs : Dense s)\n    {t : Set X} (ht : t.Finite) : Dense (s \\ t) := by\n  convert hs.diff_finset ht.toFinset\n  exact (Finite.coe_toFinset _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Basic.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[R0Space X] {x y : X}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : R0Space X\ninst\u271d\u00b9 : T1Space X\ninst\u271d : \u2200 (x : X), (nhdsWithin x {x}\u1d9c).NeBot\ns : Set X\nhs : Dense s\nt : Set X\nht : t.Finite\n\u22a2 Dense (s \\ t)"}, {"line": "convert hs.diff_finset ht.toFinset", "tactic_state": "case h.e'_3.h.e'_4\nX : Type u_1\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : R0Space X\ninst\u271d\u00b9 : T1Space X\ninst\u271d : \u2200 (x : X), (nhdsWithin x {x}\u1d9c).NeBot\ns : Set X\nhs : Dense s\nt : Set X\nht : t.Finite\n\u22a2 t = \u2191ht.toFinset\n---\ncase convert_1\nX : Type u_1\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : R0Space X\ninst\u271d\u00b9 : T1Space X\ninst\u271d : \u2200 (x : X), (nhdsWithin x {x}\u1d9c).NeBot\ns : Set X\nhs : Dense s\nt : Set X\nht : t.Finite\n\u22a2 T1Space X\n---\ncase convert_2\nX : Type u_1\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : R0Space X\ninst\u271d\u00b9 : T1Space X\ninst\u271d : \u2200 (x : X), (nhdsWithin x {x}\u1d9c).NeBot\ns : Set X\nhs : Dense s\nt : Set X\nht : t.Finite\n\u22a2 \u2200 (x : X), (nhdsWithin x {x}\u1d9c).NeBot"}, {"line": "exact (Finite.coe_toFinset _).symm", "tactic_state": "case convert_1\nX : Type u_1\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : R0Space X\ninst\u271d\u00b9 : T1Space X\ninst\u271d : \u2200 (x : X), (nhdsWithin x {x}\u1d9c).NeBot\ns : Set X\nhs : Dense s\nt : Set X\nht : t.Finite\n\u22a2 T1Space X\n---\ncase convert_2\nX : Type u_1\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : R0Space X\ninst\u271d\u00b9 : T1Space X\ninst\u271d : \u2200 (x : X), (nhdsWithin x {x}\u1d9c).NeBot\ns : Set X\nhs : Dense s\nt : Set X\nht : t.Finite\n\u22a2 \u2200 (x : X), (nhdsWithin x {x}\u1d9c).NeBot"}]}
{"declaration": "theorem continuousWithinAt_diff_singleton [TopologicalSpace Y] [T1Space X]\n    {x y : X} {s : Set X} {f : X \u2192 Y} :\n    ContinuousWithinAt f (s \\ {y}) x \u2194 ContinuousWithinAt f s x := by\n  rw [\u2190 continuousWithinAt_insert]\n  rw [insert_diff_singleton]\n  rw [continuousWithinAt_insert]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Basic.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[R0Space X] {x y : X}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : R0Space X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : T1Space X\nx y : X\ns : Set X\nf : X \u2192 Y\n\u22a2 ContinuousWithinAt f (s \\ {y}) x \u2194 ContinuousWithinAt f s x"}, {"line": "rw [\u2190 continuousWithinAt_insert]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : R0Space X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : T1Space X\nx y : X\ns : Set X\nf : X \u2192 Y\n\u22a2 ContinuousWithinAt f (insert ?m.273 (s \\ {y})) x \u2194 ContinuousWithinAt f s x\n---\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : R0Space X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : T1Space X\nx y : X\ns : Set X\nf : X \u2192 Y\n\u22a2 T1Space X\n---\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : R0Space X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : T1Space X\nx y : X\ns : Set X\nf : X \u2192 Y\n\u22a2 X"}, {"line": "rw [insert_diff_singleton]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : R0Space X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : T1Space X\nx y : X\ns : Set X\nf : X \u2192 Y\n\u22a2 ContinuousWithinAt f (insert y s) x \u2194 ContinuousWithinAt f s x\n---\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : R0Space X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : T1Space X\nx y : X\ns : Set X\nf : X \u2192 Y\n\u22a2 T1Space X"}, {"line": "rw [continuousWithinAt_insert]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : R0Space X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : T1Space X\nx y : X\ns : Set X\nf : X \u2192 Y\n\u22a2 T1Space X\n---\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : R0Space X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : T1Space X\nx y : X\ns : Set X\nf : X \u2192 Y\n\u22a2 T1Space X"}]}
{"declaration": "theorem infinite_of_mem_nhds {X} [TopologicalSpace X] [T1Space X] (x : X) [hx : NeBot (\ud835\udcdd[\u2260] x)]\n    {s : Set X} (hs : s \u2208 \ud835\udcdd x) : Set.Infinite s := by\n  refine fun hsf => hx.1 ?_\n  rw [\u2190 isOpen_singleton_iff_punctured_nhds]\n  exact isOpen_singleton_of_finite_mem_nhds x hs hsf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Basic.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[R0Space X] {x y : X}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx : X\nhx : (nhdsWithin x {x}\u1d9c).NeBot\ns : Set X\nhs : s \u2208 nhds x\n\u22a2 s.Infinite"}, {"line": "refine fun hsf => hx.1 ?_", "tactic_state": "X : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx : X\nhx : (nhdsWithin x {x}\u1d9c).NeBot\ns : Set X\nhs : s \u2208 nhds x\nhsf : s.Finite\n\u22a2 nhdsWithin x {x}\u1d9c = \u22a5"}, {"line": "rw [\u2190 isOpen_singleton_iff_punctured_nhds]", "tactic_state": "X : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx : X\nhx : (nhdsWithin x {x}\u1d9c).NeBot\ns : Set X\nhs : s \u2208 nhds x\nhsf : s.Finite\n\u22a2 IsOpen {x}"}, {"line": "exact isOpen_singleton_of_finite_mem_nhds x hs hsf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_inter_eq_singleton_of_mem_discrete {s : Set X} [DiscreteTopology s] {x : X}\n    (hx : x \u2208 s) : \u2203 U \u2208 \ud835\udcdd x, U \u2229 s = {x} := by\n  simpa using (\ud835\udcdd x).basis_sets.exists_inter_eq_singleton_of_mem_discrete hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Basic.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[R0Space X] {x y : X}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : R0Space X\ns : Set X\ninst\u271d : DiscreteTopology \u2191s\nx : X\nhx : x \u2208 s\n\u22a2 \u2203 U \u2208 nhds x, U \u2229 s = {x}"}, {"line": "simpa using (\ud835\udcdd x).basis_sets.exists_inter_eq_singleton_of_mem_discrete hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_nhds_nhds_iff_not_inseparable : Disjoint (\ud835\udcdd x) (\ud835\udcdd y) \u2194 \u00acInseparable x y := by\n  rw [disjoint_nhds_nhds_iff_not_specializes]\n  rw [specializes_iff_inseparable]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Basic.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[R0Space X] {x y : X}", "(X) in", "[R1Space X] {x y : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : R0Space X\nx y : X\n\u22a2 Disjoint (nhds x) (nhds y) \u2194 \u00acInseparable x y"}, {"line": "rw [disjoint_nhds_nhds_iff_not_specializes]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : R0Space X\nx y : X\n\u22a2 \u00acx \u2933 y \u2194 \u00acInseparable x y\n---\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : R0Space X\nx y : X\n\u22a2 R1Space X"}, {"line": "rw [specializes_iff_inseparable]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : R0Space X\nx y : X\n\u22a2 R0Space X\n---\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : R0Space X\nx y : X\n\u22a2 R1Space X"}]}
{"declaration": "protected theorem R1Space.inf {X : Type*} {t\u2081 t\u2082 : TopologicalSpace X}\n    (h\u2081 : @R1Space X t\u2081) (h\u2082 : @R1Space X t\u2082) : @R1Space X (t\u2081 \u2293 t\u2082) := by\n  rw [inf_eq_iInf]\n  apply R1Space.iInf\n  simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Basic.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[R0Space X] {x y : X}", "(X) in", "[R1Space X] {x y : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_3\nt\u2081 t\u2082 : TopologicalSpace X\nh\u2081 : R1Space X\nh\u2082 : R1Space X\n\u22a2 R1Space X"}, {"line": "rw [inf_eq_iInf]", "tactic_state": "X : Type u_3\nt\u2081 t\u2082 : TopologicalSpace X\nh\u2081 : R1Space X\nh\u2082 : R1Space X\n\u22a2 R1Space X"}, {"line": "apply R1Space.iInf", "tactic_state": "case ht\nX : Type u_3\nt\u2081 t\u2082 : TopologicalSpace X\nh\u2081 : R1Space X\nh\u2082 : R1Space X\n\u22a2 \u2200 (i : Bool), R1Space X"}, {"line": "simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma separatesPoints_continuous_of_t35Space [T35Space X] :\n    SeparatesPoints (Continuous : Set (X \u2192 \u211d)) := by\n  intro x y x_ne_y\n  obtain \u27e8f, f_cont, f_zero, f_one\u27e9 :=\n    CompletelyRegularSpace.completely_regular x {y} isClosed_singleton x_ne_y\n  exact \u27e8fun x \u21a6 f x, continuous_subtype_val.comp f_cont, by aesop\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/CompletelyRegular.lean", "context": {"open": ["Set Topology Filter unitInterval"], "variables": ["{X : Type u} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T35Space X\n\u22a2 SeparatesPoints Continuous"}, {"line": "intro x y x_ne_y", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T35Space X\nx y : X\nx_ne_y : x \u2260 y\n\u22a2 \u2203 f \u2208 Continuous, f x \u2260 f y"}, {"line": "obtain \u27e8f, f_cont, f_zero, f_one\u27e9 :=\n    CompletelyRegularSpace.completely_regular x {y} isClosed_singleton x_ne_y", "tactic_state": "case intro.intro.intro\nX : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T35Space X\nx y : X\nx_ne_y : x \u2260 y\nf : X \u2192 \u2191unitInterval\nf_cont : Continuous f\nf_zero : f x = 0\nf_one : EqOn f 1 {y}\n\u22a2 \u2203 f \u2208 Continuous, f x \u2260 f y"}, {"line": "exact \u27e8fun x \u21a6 f x, continuous_subtype_val.comp f_cont, by aesop\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma separatesPoints_continuous_of_t35Space_Icc [T35Space X] :\n    SeparatesPoints (Continuous : Set (X \u2192 I)) := by\n  intro x y x_ne_y\n  obtain \u27e8f, f_cont, f_zero, f_one\u27e9 :=\n    CompletelyRegularSpace.completely_regular x {y} isClosed_singleton x_ne_y\n  exact \u27e8f, f_cont, by aesop\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/CompletelyRegular.lean", "context": {"open": ["Set Topology Filter unitInterval"], "variables": ["{X : Type u} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T35Space X\n\u22a2 SeparatesPoints Continuous"}, {"line": "intro x y x_ne_y", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T35Space X\nx y : X\nx_ne_y : x \u2260 y\n\u22a2 \u2203 f \u2208 Continuous, f x \u2260 f y"}, {"line": "obtain \u27e8f, f_cont, f_zero, f_one\u27e9 :=\n    CompletelyRegularSpace.completely_regular x {y} isClosed_singleton x_ne_y", "tactic_state": "case intro.intro.intro\nX : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T35Space X\nx y : X\nx_ne_y : x \u2260 y\nf : X \u2192 \u2191unitInterval\nf_cont : Continuous f\nf_zero : f x = 0\nf_one : EqOn f 1 {y}\n\u22a2 \u2203 f \u2208 Continuous, f x \u2260 f y"}, {"line": "exact \u27e8f, f_cont, by aesop\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Set.Countable.isG\u03b4_compl {s : Set X} [T1Space X] (hs : s.Countable) : IsG\u03b4 s\u1d9c := by\n  rw [\u2190 biUnion_of_singleton s]\n  rw [compl_iUnion\u2082]\n  exact .biInter hs fun x _ => .compl_singleton x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/GDelta.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ns : Set X\ninst\u271d : T1Space X\nhs : s.Countable\n\u22a2 IsG\u03b4 s\u1d9c"}, {"line": "rw [\u2190 biUnion_of_singleton s]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ns : Set X\ninst\u271d : T1Space X\nhs : s.Countable\n\u22a2 IsG\u03b4 (\u22c3 x \u2208 s, {x})\u1d9c"}, {"line": "rw [compl_iUnion\u2082]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ns : Set X\ninst\u271d : T1Space X\nhs : s.Countable\n\u22a2 IsG\u03b4 (\u22c2 i \u2208 s, {i}\u1d9c)"}, {"line": "exact .biInter hs fun x _ => .compl_singleton x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem SeparationQuotient.t2Space_iff : T2Space (SeparationQuotient X) \u2194 R1Space X := by\n  simp only [t2Space_iff_disjoint_nhds]\n  simp only [Pairwise]\n  simp only [surjective_mk.forall\u2082]\n  simp only [ne_eq]\n  simp only [mk_eq_mk]\n  simp only [r1Space_iff_inseparable_or_disjoint_nhds]\n  simp only [\u2190 disjoint_comap_iff surjective_mk]\n  simp only [comap_mk_nhds_mk]\n  simp only [\u2190 or_iff_not_imp_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Hausdorff.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 T2Space (SeparationQuotient X) \u2194 R1Space X"}, {"line": "simp only [t2Space_iff_disjoint_nhds]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 (Pairwise fun x y => Disjoint (nhds x) (nhds y)) \u2194 R1Space X"}, {"line": "simp only [Pairwise]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 (\u2200 \u2983i j : SeparationQuotient X\u2984, i \u2260 j \u2192 Disjoint (nhds i) (nhds j)) \u2194 R1Space X"}, {"line": "simp only [surjective_mk.forall\u2082]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 (\u2200 (x\u2081 x\u2082 : X), mk x\u2081 \u2260 mk x\u2082 \u2192 Disjoint (nhds (mk x\u2081)) (nhds (mk x\u2082))) \u2194 R1Space X"}, {"line": "simp only [ne_eq]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 (\u2200 (x\u2081 x\u2082 : X), \u00acmk x\u2081 = mk x\u2082 \u2192 Disjoint (nhds (mk x\u2081)) (nhds (mk x\u2082))) \u2194 R1Space X"}, {"line": "simp only [mk_eq_mk]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 (\u2200 (x\u2081 x\u2082 : X), \u00acInseparable x\u2081 x\u2082 \u2192 Disjoint (nhds (mk x\u2081)) (nhds (mk x\u2082))) \u2194 R1Space X"}, {"line": "simp only [r1Space_iff_inseparable_or_disjoint_nhds]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 (\u2200 (x\u2081 x\u2082 : X), \u00acInseparable x\u2081 x\u2082 \u2192 Disjoint (nhds (mk x\u2081)) (nhds (mk x\u2082))) \u2194\n    \u2200 (x y : X), Inseparable x y \u2228 Disjoint (nhds x) (nhds y)"}, {"line": "simp only [\u2190 disjoint_comap_iff surjective_mk]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 (\u2200 (x\u2081 x\u2082 : X), \u00acInseparable x\u2081 x\u2082 \u2192 Disjoint (comap mk (nhds (mk x\u2081))) (comap mk (nhds (mk x\u2082)))) \u2194\n    \u2200 (x y : X), Inseparable x y \u2228 Disjoint (nhds x) (nhds y)"}, {"line": "simp only [comap_mk_nhds_mk]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 (\u2200 (x\u2081 x\u2082 : X), \u00acInseparable x\u2081 x\u2082 \u2192 Disjoint (nhds x\u2081) (nhds x\u2082)) \u2194\n    \u2200 (x y : X), Inseparable x y \u2228 Disjoint (nhds x) (nhds y)"}, {"line": "simp only [\u2190 or_iff_not_imp_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem R1Space.t2Space_iff_t0Space [R1Space X] : T2Space X \u2194 T0Space X := by\n  constructor <;> intro <;> infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Hausdorff.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : R1Space X\n\u22a2 T2Space X \u2194 T0Space X"}, {"line": "constructor <;> intro <;> infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem t2_iff_nhds : T2Space X \u2194 \u2200 {x y : X}, NeBot (\ud835\udcdd x \u2293 \ud835\udcdd y) \u2192 x = y := by\n  simp only [t2Space_iff_disjoint_nhds]\n  simp only [disjoint_iff]\n  simp only [neBot_iff]\n  simp only [Ne]\n  simp only [not_imp_comm]\n  simp only [Pairwise]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Hausdorff.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 T2Space X \u2194 \u2200 {x y : X}, (nhds x \u2293 nhds y).NeBot \u2192 x = y"}, {"line": "simp only [t2Space_iff_disjoint_nhds]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 (Pairwise fun x y => Disjoint (nhds x) (nhds y)) \u2194 \u2200 {x y : X}, (nhds x \u2293 nhds y).NeBot \u2192 x = y"}, {"line": "simp only [disjoint_iff]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 (Pairwise fun x y => nhds x \u2293 nhds y = \u22a5) \u2194 \u2200 {x y : X}, (nhds x \u2293 nhds y).NeBot \u2192 x = y"}, {"line": "simp only [neBot_iff]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 (Pairwise fun x y => nhds x \u2293 nhds y = \u22a5) \u2194 \u2200 {x y : X}, nhds x \u2293 nhds y \u2260 \u22a5 \u2192 x = y"}, {"line": "simp only [Ne]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 (Pairwise fun x y => nhds x \u2293 nhds y = \u22a5) \u2194 \u2200 {x y : X}, \u00acnhds x \u2293 nhds y = \u22a5 \u2192 x = y"}, {"line": "simp only [not_imp_comm]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 (Pairwise fun x y => nhds x \u2293 nhds y = \u22a5) \u2194 \u2200 {x y : X}, \u00acx = y \u2192 nhds x \u2293 nhds y = \u22a5"}, {"line": "simp only [Pairwise]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem t2_separation_compact_nhds [LocallyCompactSpace X] [T2Space X] {x y : X} (h : x \u2260 y) :\n    \u2203 u v, u \u2208 \ud835\udcdd x \u2227 v \u2208 \ud835\udcdd y \u2227 IsCompact u \u2227 IsCompact v \u2227 Disjoint u v := by\n  simpa only [exists_prop,\u2190 exists_and_left,and_comm,and_assoc,and_left_comm] using\n    ((compact_basis_nhds x).disjoint_iff (compact_basis_nhds y)).1 (disjoint_nhds_nhds.2 h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Hausdorff.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : LocallyCompactSpace X\ninst\u271d : T2Space X\nx y : X\nh : x \u2260 y\n\u22a2 \u2203 u v, u \u2208 nhds x \u2227 v \u2208 nhds y \u2227 IsCompact u \u2227 IsCompact v \u2227 Disjoint u v"}, {"line": "simpa only [exists_prop,\u2190 exists_and_left,and_comm,and_assoc,and_left_comm] using\n    ((compact_basis_nhds x).disjoint_iff (compact_basis_nhds y)).1 (disjoint_nhds_nhds.2 h)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCompact.separation_of_not_mem {X : Type u_1} [TopologicalSpace X] [T2Space X] {x : X}\n    {t : Set X} (H1 : IsCompact t) (H2 : x \u2209 t) :\n    \u2203 (U : Set X), \u2203 (V : Set X), IsOpen U \u2227 IsOpen V \u2227 t \u2286 U \u2227 x \u2208 V \u2227 Disjoint U V := by\n  simpa [SeparatedNhds] using SeparatedNhds.of_isCompact_isCompact_isClosed H1 isCompact_singleton\n    isClosed_singleton <| disjoint_singleton_right.mpr H2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Hausdorff.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T2Space X\nx : X\nt : Set X\nH1 : IsCompact t\nH2 : x \u2209 t\n\u22a2 \u2203 U V, IsOpen U \u2227 IsOpen V \u2227 t \u2286 U \u2227 x \u2208 V \u2227 Disjoint U V"}, {"line": "simpa [SeparatedNhds] using SeparatedNhds.of_isCompact_isCompact_isClosed H1 isCompact_singleton\n    isClosed_singleton <| disjoint_singleton_right.mpr H2", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCompact.disjoint_nhdsSet_nhds {X : Type u_1} [TopologicalSpace X] [T2Space X] {x : X}\n    {t : Set X} (H1 : IsCompact t) (H2 : x \u2209 t) :\n    Disjoint (\ud835\udcdd\u02e2 t) (\ud835\udcdd x) := by\n  simpa using SeparatedNhds.disjoint_nhdsSet <| .of_isCompact_isCompact_isClosed H1\n    isCompact_singleton isClosed_singleton <| disjoint_singleton_right.mpr H2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Hausdorff.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T2Space X\nx : X\nt : Set X\nH1 : IsCompact t\nH2 : x \u2209 t\n\u22a2 Disjoint (nhdsSet t) (nhds x)"}, {"line": "simpa using SeparatedNhds.disjoint_nhdsSet <| .of_isCompact_isCompact_isClosed H1\n    isCompact_singleton isClosed_singleton <| disjoint_singleton_right.mpr H2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_iff_ultrafilter' [CompactSpace X] (U : Set X) :\n    IsOpen U \u2194 \u2200 F : Ultrafilter X, F.lim \u2208 U \u2192 U \u2208 F.1 := by\n  rw [isOpen_iff_ultrafilter]\n  refine \u27e8fun h F hF => h F.lim hF F F.le_nhds_lim, ?_\u27e9\n  intro cond x hx f h\n  rw [\u2190 Ultrafilter.lim_eq_iff_le_nhds.2 h] at hx\n  exact cond _ hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Hausdorff.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[T2Space X] {f : Filter X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\nU : Set X\n\u22a2 IsOpen U \u2194 \u2200 (F : Ultrafilter X), F.lim \u2208 U \u2192 U \u2208 \u2191F"}, {"line": "rw [isOpen_iff_ultrafilter]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\nU : Set X\n\u22a2 (\u2200 x \u2208 U, \u2200 (l : Ultrafilter X), \u2191l \u2264 nhds x \u2192 U \u2208 l) \u2194 \u2200 (F : Ultrafilter X), F.lim \u2208 U \u2192 U \u2208 \u2191F"}, {"line": "refine \u27e8fun h F hF => h F.lim hF F F.le_nhds_lim, ?_\u27e9", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\nU : Set X\n\u22a2 (\u2200 (F : Ultrafilter X), F.lim \u2208 U \u2192 U \u2208 \u2191F) \u2192 \u2200 x \u2208 U, \u2200 (l : Ultrafilter X), \u2191l \u2264 nhds x \u2192 U \u2208 l"}, {"line": "intro cond x hx f h", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\nU : Set X\ncond : \u2200 (F : Ultrafilter X), F.lim \u2208 U \u2192 U \u2208 \u2191F\nx : X\nhx : x \u2208 U\nf : Ultrafilter X\nh : \u2191f \u2264 nhds x\n\u22a2 U \u2208 f"}, {"line": "rw [\u2190 Ultrafilter.lim_eq_iff_le_nhds.2 h] at hx", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\nU : Set X\ncond : \u2200 (F : Ultrafilter X), F.lim \u2208 U \u2192 U \u2208 \u2191F\nx : X\nf : Ultrafilter X\nhx : f.lim \u2208 U\nh : \u2191f \u2264 nhds x\n\u22a2 U \u2208 f\n---\nX : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\nU : Set X\ncond : \u2200 (F : Ultrafilter X), F.lim \u2208 U \u2192 U \u2208 \u2191F\nx : X\nhx : x \u2208 U\nf : Ultrafilter X\nh : \u2191f \u2264 nhds x\n\u22a2 T2Space X\n---\nX : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\nU : Set X\ncond : \u2200 (F : Ultrafilter X), F.lim \u2208 U \u2192 U \u2208 \u2191F\nx : X\nhx : x \u2208 U\nf : Ultrafilter X\nh : \u2191f \u2264 nhds x\n\u22a2 CompactSpace X"}, {"line": "exact cond _ hx", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\nU : Set X\ncond : \u2200 (F : Ultrafilter X), F.lim \u2208 U \u2192 U \u2208 \u2191F\nx : X\nhx : x \u2208 U\nf : Ultrafilter X\nh : \u2191f \u2264 nhds x\n\u22a2 T2Space X\n---\nX : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : CompactSpace X\nU : Set X\ncond : \u2200 (F : Ultrafilter X), F.lim \u2208 U \u2192 U \u2208 \u2191F\nx : X\nhx : x \u2208 U\nf : Ultrafilter X\nh : \u2191f \u2264 nhds x\n\u22a2 CompactSpace X"}]}
{"declaration": "theorem Set.EqOn.of_subset_closure [T2Space Y] {s t : Set X} {f g : X \u2192 Y} (h : EqOn f g s)\n    (hf : ContinuousOn f t) (hg : ContinuousOn g t) (hst : s \u2286 t) (hts : t \u2286 closure s) :\n    EqOn f g t := by\n  intro x hx\n  have : (\ud835\udcdd[s] x).NeBot := mem_closure_iff_clusterPt.mp (hts hx)\n  exact\n    tendsto_nhds_unique_of_eventuallyEq ((hf x hx).mono_left <| nhdsWithin_mono _ hst)\n      ((hg x hx).mono_left <| nhdsWithin_mono _ hst) (h.eventuallyEq_of_mem self_mem_nhdsWithin)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Hausdorff.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[T2Space X] {f : Filter X}", "(X)", "{X}", "(X)", "{X}", "{Z : Type*} [TopologicalSpace Y] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : T2Space X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : T2Space Y\ns t : Set X\nf g : X \u2192 Y\nh : EqOn f g s\nhf : ContinuousOn f t\nhg : ContinuousOn g t\nhst : s \u2286 t\nhts : t \u2286 closure s\n\u22a2 EqOn f g t"}, {"line": "intro x hx", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : T2Space X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : T2Space Y\ns t : Set X\nf g : X \u2192 Y\nh : EqOn f g s\nhf : ContinuousOn f t\nhg : ContinuousOn g t\nhst : s \u2286 t\nhts : t \u2286 closure s\nx : X\nhx : x \u2208 t\n\u22a2 f x = g x"}, {"line": "have : (\ud835\udcdd[s] x).NeBot := mem_closure_iff_clusterPt.mp (hts hx)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : T2Space X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : T2Space Y\ns t : Set X\nf g : X \u2192 Y\nh : EqOn f g s\nhf : ContinuousOn f t\nhg : ContinuousOn g t\nhst : s \u2286 t\nhts : t \u2286 closure s\nx : X\nhx : x \u2208 t\nthis : sorry\n\u22a2 f x = g x"}, {"line": "exact\n    tendsto_nhds_unique_of_eventuallyEq ((hf x hx).mono_left <| nhdsWithin_mono _ hst)\n      ((hg x hx).mono_left <| nhdsWithin_mono _ hst) (h.eventuallyEq_of_mem self_mem_nhdsWithin)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem SeparatedNhds.of_isCompact_isCompact [T2Space X] {s t : Set X} (hs : IsCompact s)\n    (ht : IsCompact t) (hst : Disjoint s t) : SeparatedNhds s t := by\n  simp only [SeparatedNhds] at hst \u22a2\n  simp only [prod_subset_compl_diagonal_iff_disjoint.symm] at hst \u22a2\n  exact generalized_tube_lemma hs ht isClosed_diagonal.isOpen_compl hst\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Hausdorff.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[T2Space X] {f : Filter X}", "(X)", "{X}", "(X)", "{X}", "{Z : Type*} [TopologicalSpace Y] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 inst\u271d : T2Space X\ns t : Set X\nhs : IsCompact s\nht : IsCompact t\nhst : Disjoint s t\n\u22a2 SeparatedNhds s t"}, {"line": "simp only [SeparatedNhds] at hst \u22a2", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 inst\u271d : T2Space X\ns t : Set X\nhs : IsCompact s\nht : IsCompact t\nhst : Disjoint s t\n\u22a2 \u2203 U V, IsOpen U \u2227 IsOpen V \u2227 s \u2286 U \u2227 t \u2286 V \u2227 Disjoint U V"}, {"line": "simp only [prod_subset_compl_diagonal_iff_disjoint.symm] at hst \u22a2", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 inst\u271d : T2Space X\ns t : Set X\nhs : IsCompact s\nht : IsCompact t\nhst : s \u00d7\u02e2 t \u2286 (diagonal X)\u1d9c\n\u22a2 \u2203 U V, IsOpen U \u2227 IsOpen V \u2227 s \u2286 U \u2227 t \u2286 V \u2227 U \u00d7\u02e2 V \u2286 (diagonal X)\u1d9c"}, {"line": "exact generalized_tube_lemma hs ht isClosed_diagonal.isOpen_compl hst", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Pi.isCompact_iff {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]\n    [\u2200 i, T2Space (\u03c0 i)] {s : Set (\u03a0 i, \u03c0 i)} :\n    IsCompact s \u2194 IsClosed s \u2227 \u2200 i, IsCompact (eval i '' s) := by\n  constructor <;> intro H\n  \u00b7 exact \u27e8H.isClosed, fun i \u21a6 H.image <| continuous_apply i\u27e9\n  \u00b7 exact IsCompact.of_isClosed_subset (isCompact_univ_pi H.2) H.1 (subset_pi_eval_image univ s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Hausdorff.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[T2Space X] {f : Filter X}", "(X)", "{X}", "(X)", "{X}", "{Z : Type*} [TopologicalSpace Y] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\ninst\u271d\u00b9 : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\ninst\u271d : \u2200 (i : \u03b9), T2Space (\u03c0 i)\ns : Set ((i : \u03b9) \u2192 \u03c0 i)\n\u22a2 IsCompact s \u2194 IsClosed s \u2227 \u2200 (i : \u03b9), IsCompact (eval i '' s)"}, {"line": "constructor <;> intro H", "tactic_state": "case mp\n\u03b9 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\ninst\u271d\u00b9 : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\ninst\u271d : \u2200 (i : \u03b9), T2Space (\u03c0 i)\ns : Set ((i : \u03b9) \u2192 \u03c0 i)\nH : IsCompact s\n\u22a2 IsClosed s \u2227 \u2200 (i : \u03b9), IsCompact (eval i '' s)\n---\ncase mpr\n\u03b9 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\ninst\u271d\u00b9 : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\ninst\u271d : \u2200 (i : \u03b9), T2Space (\u03c0 i)\ns : Set ((i : \u03b9) \u2192 \u03c0 i)\nH : IsClosed s \u2227 \u2200 (i : \u03b9), IsCompact (eval i '' s)\n\u22a2 IsCompact s"}, {"line": "\u00b7 exact \u27e8H.isClosed, fun i \u21a6 H.image <| continuous_apply i\u27e9", "tactic_state": "case mpr\n\u03b9 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\ninst\u271d\u00b9 : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\ninst\u271d : \u2200 (i : \u03b9), T2Space (\u03c0 i)\ns : Set ((i : \u03b9) \u2192 \u03c0 i)\nH : IsClosed s \u2227 \u2200 (i : \u03b9), IsCompact (eval i '' s)\n\u22a2 IsCompact s"}, {"line": "\u00b7 exact IsCompact.of_isClosed_subset (isCompact_univ_pi H.2) H.1 (subset_pi_eval_image univ s)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isIrreducible_iff_singleton [T2Space X] {S : Set X} : IsIrreducible S \u2194 \u2203 x, S = {x} := by\n  rw [IsIrreducible]\n  rw [isPreirreducible_iff_subsingleton]\n  rw [exists_eq_singleton_iff_nonempty_subsingleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Hausdorff.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[T2Space X] {f : Filter X}", "(X)", "{X}", "(X)", "{X}", "{Z : Type*} [TopologicalSpace Y] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 inst\u271d : T2Space X\nS : Set X\n\u22a2 IsIrreducible S \u2194 \u2203 x, S = {x}"}, {"line": "rw [IsIrreducible]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 inst\u271d : T2Space X\nS : Set X\n\u22a2 S.Nonempty \u2227 IsPreirreducible S \u2194 \u2203 x, S = {x}"}, {"line": "rw [isPreirreducible_iff_subsingleton]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 inst\u271d : T2Space X\nS : Set X\n\u22a2 S.Nonempty \u2227 S.Subsingleton \u2194 \u2203 x, S = {x}\n---\nX : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 inst\u271d : T2Space X\nS : Set X\n\u22a2 T2Space X"}, {"line": "rw [exists_eq_singleton_iff_nonempty_subsingleton]", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 inst\u271d : T2Space X\nS : Set X\n\u22a2 T2Space X"}]}
{"declaration": "theorem TopologicalSpace.IsTopologicalBasis.nhds_basis_closure {B : Set (Set X)}\n    (hB : IsTopologicalBasis B) (x : X) :\n    (\ud835\udcdd x).HasBasis (fun s : Set X => x \u2208 s \u2227 s \u2208 B) closure := by\n  simpa only [and_comm] using hB.nhds_hasBasis.nhds_closure\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Regular.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[RegularSpace X] {x : X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : RegularSpace X\nB : Set (Set X)\nhB : IsTopologicalBasis B\nx : X\n\u22a2 (nhds x).HasBasis (fun s => x \u2208 s \u2227 s \u2208 B) closure"}, {"line": "simpa only [and_comm] using hB.nhds_hasBasis.nhds_closure", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TopologicalSpace.IsTopologicalBasis.exists_closure_subset {B : Set (Set X)}\n    (hB : IsTopologicalBasis B) {x : X} {s : Set X} (h : s \u2208 \ud835\udcdd x) :\n    \u2203 t \u2208 B, x \u2208 t \u2227 closure t \u2286 s := by\n  simpa only [exists_prop,and_assoc] using hB.nhds_hasBasis.nhds_closure.mem_iff.mp h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Regular.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[RegularSpace X] {x : X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : RegularSpace X\nB : Set (Set X)\nhB : IsTopologicalBasis B\nx : X\ns : Set X\nh : s \u2208 nhds x\n\u22a2 \u2203 t \u2208 B, x \u2208 t \u2227 closure t \u2286 s"}, {"line": "simpa only [exists_prop,and_assoc] using hB.nhds_hasBasis.nhds_closure.mem_iff.mp h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem RegularSpace.inf {X} {t\u2081 t\u2082 : TopologicalSpace X} (h\u2081 : @RegularSpace X t\u2081)\n    (h\u2082 : @RegularSpace X t\u2082) : @RegularSpace X (t\u2081 \u2293 t\u2082) := by\n  rw [inf_eq_iInf]\n  exact regularSpace_iInf (Bool.forall_bool.2 \u27e8h\u2082, h\u2081\u27e9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Regular.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[RegularSpace X] {x : X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_3\nt\u2081 t\u2082 : TopologicalSpace X\nh\u2081 : RegularSpace X\nh\u2082 : RegularSpace X\n\u22a2 RegularSpace X"}, {"line": "rw [inf_eq_iInf]", "tactic_state": "X : Type u_3\nt\u2081 t\u2082 : TopologicalSpace X\nh\u2081 : RegularSpace X\nh\u2082 : RegularSpace X\n\u22a2 RegularSpace X"}, {"line": "exact regularSpace_iInf (Bool.forall_bool.2 \u27e8h\u2082, h\u2081\u27e9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_open_nhds_disjoint_closure [T25Space X] {x y : X} (h : x \u2260 y) :\n    \u2203 u : Set X,\n      x \u2208 u \u2227 IsOpen u \u2227 \u2203 v : Set X, y \u2208 v \u2227 IsOpen v \u2227 Disjoint (closure u) (closure v) := by\n  simpa only [exists_prop,and_assoc] using\n    ((nhds_basis_opens x).lift'_closure.disjoint_iff (nhds_basis_opens y).lift'_closure).1\n      (disjoint_lift'_closure_nhds.2 h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Regular.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[RegularSpace X] {x : X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : RegularSpace X\ninst\u271d : T25Space X\nx y : X\nh : x \u2260 y\n\u22a2 \u2203 u, x \u2208 u \u2227 IsOpen u \u2227 \u2203 v, y \u2208 v \u2227 IsOpen v \u2227 Disjoint (closure u) (closure v)"}, {"line": "simpa only [exists_prop,and_assoc] using\n    ((nhds_basis_opens x).lift'_closure.disjoint_iff (nhds_basis_opens y).lift'_closure).1\n      (disjoint_lift'_closure_nhds.2 h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem RegularSpace.t3Space_iff_t0Space [RegularSpace X] : T3Space X \u2194 T0Space X := by\n  constructor <;> intro <;> infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Regular.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[RegularSpace X] {x : X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 inst\u271d : RegularSpace X\n\u22a2 T3Space X \u2194 T0Space X"}, {"line": "constructor <;> intro <;> infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Topology.IsClosedEmbedding.normalSpace [TopologicalSpace Y] [NormalSpace Y]\n    {f : X \u2192 Y} (hf : IsClosedEmbedding f) : NormalSpace X where\n  normal s t hs ht hst := by\n    have H : SeparatedNhds (f '' s) (f '' t) :=\n      NormalSpace.normal (f '' s) (f '' t) (hf.isClosedMap s hs) (hf.isClosedMap t ht)\n        (disjoint_image_of_injective hf.injective hst)\n    exact (H.preimage hf.continuous).mono (subset_preimage_image _ _) (subset_preimage_image _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Regular.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace", "SeparationQuotient"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[RegularSpace X] {x : X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : RegularSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : NormalSpace Y\nf : X \u2192 Y\nhf : IsClosedEmbedding f\ns t : Set X\nhs : IsClosed s\nht : IsClosed t\nhst : Disjoint s t\n\u22a2 SeparatedNhds s t"}, {"line": "have H : SeparatedNhds (f '' s) (f '' t) :=\n      NormalSpace.normal (f '' s) (f '' t) (hf.isClosedMap s hs) (hf.isClosedMap t ht)\n        (disjoint_image_of_injective hf.injective hst)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : RegularSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : NormalSpace Y\nf : X \u2192 Y\nhf : IsClosedEmbedding f\ns t : Set X\nhs : IsClosed s\nht : IsClosed t\nhst : Disjoint s t\nH : sorry\n\u22a2 SeparatedNhds s t"}, {"line": "exact (H.preimage hf.continuous).mono (subset_preimage_image _ _) (subset_preimage_image _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Topology.IsEmbedding.t5Space [TopologicalSpace Y] [T5Space Y] {e : X \u2192 Y}\n    (he : IsEmbedding e) : T5Space X where\n  __ := he.t1Space\n  completely_normal := by\n    have := he.completelyNormalSpace\n    exact completely_normal\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Separation/Regular.lean", "context": {"open": ["Function Set Filter Topology TopologicalSpace", "SeparationQuotient"], "variables": ["{X : Type*} {Y : Type*} [TopologicalSpace X]", "[RegularSpace X] {x : X} {s : Set X}", "(X)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : RegularSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : T5Space Y\ne : X \u2192 Y\nhe : IsEmbedding e\n\u22a2 \u2200 \u2983s t : Set X\u2984, Disjoint (closure s) t \u2192 Disjoint s (closure t) \u2192 Disjoint (nhdsSet s) (nhdsSet t)"}, {"line": "have := he.completelyNormalSpace", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : RegularSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : T5Space Y\ne : X \u2192 Y\nhe : IsEmbedding e\nthis : CompletelyNormalSpace X\n\u22a2 \u2200 \u2983s t : Set X\u2984, Disjoint (closure s) t \u2192 Disjoint s (closure t) \u2192 Disjoint (nhdsSet s) (nhdsSet t)"}, {"line": "exact completely_normal", "tactic_state": "No Goals!"}]}
{"declaration": "lemma of_sets {v : \u03b9 \u2192 Set X} (h_open : \u2200 i, IsOpen (v i)) (h_iUnion : \u22c3 i, v i = univ) :\n    IsOpenCover (fun i \u21a6 \u27e8v i, h_open i\u27e9) := by\n  simp [IsOpenCover, h_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sets/OpenCover.lean", "context": {"open": ["Set Topology"], "variables": ["{\u03b9 \u03ba X Y : Type*} [TopologicalSpace X] {u : \u03b9 \u2192 Opens X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Opens : ?m.466\n\u03b9\u271d : Type u_1\n\u03ba : Type u_2\nX\u271d : Type u_3\nY : Type u_4\ninst\u271d\u00b9 : TopologicalSpace X\u271d\nu : \u03b9\u271d \u2192 sorry\n\u03b9 : Type u_1\nX : Type u_3\ninst\u271d : TopologicalSpace X\nx\u271d : Sort u_5\nIsOpenCover : x\u271d\nv : \u03b9 \u2192 Set X\nh_open : \u2200 (i : \u03b9), IsOpen (v i)\nh_iUnion : \u22c3 i, v i = univ\n\u22a2 sorry"}, {"line": "simp [IsOpenCover, h_iUnion]", "tactic_state": "Opens : ?m.466\n\u03b9\u271d : Type u_1\n\u03ba : Type u_2\nX\u271d : Type u_3\nY : Type u_4\ninst\u271d\u00b9 : TopologicalSpace X\u271d\nu : \u03b9\u271d \u2192 sorry\n\u03b9 : Type u_1\nX : Type u_3\ninst\u271d : TopologicalSpace X\nx\u271d : Sort u_5\nIsOpenCover : x\u271d\nv : \u03b9 \u2192 Set X\nh_open : \u2200 (i : \u03b9), IsOpen (v i)\nh_iUnion : \u22c3 i, v i = univ\n\u22a2 sorry ()"}]}
{"declaration": "lemma comap (hv : IsOpenCover v) (f : C(X, Y)) : IsOpenCover fun k \u21a6 (v k).comap f :=\n  by simp [IsOpenCover, \u2190 preimage_iUnion, hv.iSup_set_eq_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sets/OpenCover.lean", "context": {"open": ["Set Topology"], "variables": ["{\u03b9 \u03ba X Y : Type*} [TopologicalSpace X] {u : \u03b9 \u2192 Opens X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Opens : ?m.466\n\u03b9 : Type u_1\n\u03ba : Type u_2\nX : Type u_3\nY : Type u_4\ninst\u271d : TopologicalSpace X\nu : \u03b9 \u2192 sorry\nx\u271d : Sort u_5\nIsOpenCover : x\u271d\nhv : sorry\nf : sorry\n\u22a2 sorry"}, {"line": "simp [IsOpenCover, \u2190 preimage_iUnion, hv.iSup_set_eq_univ]", "tactic_state": "Opens : ?m.466\n\u03b9 : Type u_1\n\u03ba : Type u_2\nX : Type u_3\nY : Type u_4\ninst\u271d : TopologicalSpace X\nu : \u03b9 \u2192 sorry\nx\u271d : Sort u_5\nIsOpenCover : x\u271d\nhv : sorry\nf : sorry\n\u22a2 sorry ()"}]}
{"declaration": "lemma iUnion_inter (hu : IsOpenCover u) (s : Set X) :\n    \u22c3 i, s \u2229 u i = s := by\n  simp [\u2190 inter_iUnion, hu.iSup_set_eq_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sets/OpenCover.lean", "context": {"open": ["Set Topology"], "variables": ["{\u03b9 \u03ba X Y : Type*} [TopologicalSpace X] {u : \u03b9 \u2192 Opens X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Opens : ?m.466\n\u03b9\u271d : Type u_1\n\u03ba : Type u_2\nX\u271d : Type u_3\nY : Type u_4\ninst\u271d\u00b9 : TopologicalSpace X\u271d\nu : \u03b9\u271d \u2192 sorry\n\u03b9 : Type u_1\nX : Type u_3\ninst\u271d : TopologicalSpace X\nx\u271d : Sort u_5\nIsOpenCover : x\u271d\nhu : sorry\ns : Set X\n\u22a2 \u22c3 i, s \u2229 sorry = s"}, {"line": "simp [\u2190 inter_iUnion, hu.iSup_set_eq_univ]", "tactic_state": "Opens : ?m.466\n\u03b9\u271d : Type u_1\n\u03ba : Type u_2\nX\u271d : Type u_3\nY : Type u_4\ninst\u271d\u00b9 : TopologicalSpace X\u271d\nu : \u03b9\u271d \u2192 sorry\n\u03b9 : Type u_1\nX : Type u_3\ninst\u271d : TopologicalSpace X\nx\u271d : Sort u_5\nIsOpenCover : x\u271d\nhu : sorry\ns : Set X\n\u22a2 s \u2286 \u22c3 i, sorry ()"}]}
{"declaration": "theorem mem_iInf {\u03b9} {x : \u03b1} {s : \u03b9 \u2192 Closeds \u03b1} : x \u2208 iInf s \u2194 \u2200 i, x \u2208 s i := by simp [iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sets/Closeds.lean", "context": {"open": ["Order OrderDual Set"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\nx\u271d : Sort u_4\nCloseds : x\u271d\n\u03b9 : Sort u_5\nx : \u03b1\ns : \u03b9 \u2192 sorry\n\u22a2 x \u2208 iInf s \u2194 \u2200 (i : \u03b9), x \u2208 s i"}, {"line": "simp [iInf]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\nx\u271d : Sort u_4\nCloseds : x\u271d\n\u03b9 : Sort u_5\nx : \u03b1\ns : \u03b9 \u2192 sorry\n\u22a2 x \u2208 sInf (range s) \u2194 \u2200 (i : \u03b9), x \u2208 s i"}]}
{"declaration": "theorem Closeds.isAtom_iff [T1Space \u03b1] {s : Closeds \u03b1} :\n    IsAtom s \u2194 \u2203 x, s = Closeds.singleton x := by\n  simp [\u2190 Closeds.isAtom_coe, Set.isAtom_iff, SetLike.ext_iff, Set.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sets/Closeds.lean", "context": {"open": ["Order OrderDual Set"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "(\u03b1)", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nx\u271d : Sort u_4\nCloseds : x\u271d\ninst\u271d : T1Space \u03b1\ns : sorry\n\u22a2 IsAtom s \u2194 \u2203 x, s = sorry"}, {"line": "simp [\u2190 Closeds.isAtom_coe, Set.isAtom_iff, SetLike.ext_iff, Set.ext_iff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nx\u271d : Sort u_4\nCloseds : x\u271d\ninst\u271d : T1Space \u03b1\ns : sorry\n\u22a2 IsAtom s \u2194 \u2203 x, s = sorry ()"}]}
{"declaration": "theorem pushforward_eq' {X Y : TopCat.{w}} {f g : X \u27f6 Y} (h : f = g) (\u2131 : X.Presheaf C) :\n    f _* \u2131 = g _* \u2131 := by rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sheaves/Presheaf.lean", "context": {"open": ["CategoryTheory TopologicalSpace Opposite", "AlgebraicGeometry", "CategoryTheory.Limits"], "variables": ["(C : Type u) [Category.{v} C]", "{C}", "{X : TopCat} {C : Type*} [Category C] {FC : C \u2192 C \u2192 Type*} {CC : C \u2192 Type*}", "[\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)] [ConcreteCategory C FC]", "(C)", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d : Category.{u_4, u_1} C\nX Y : TopCat\nf g : X \u27f6 Y\nh : f = g\n\u2131 : TopCat.Presheaf C X\n\u22a2 (TopCat.Presheaf.pushforward C f).obj \u2131 = (TopCat.Presheaf.pushforward C g).obj \u2131"}, {"line": "rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem skyscraperPresheaf_eq_pushforward\n    [hd : \u2200 U : Opens (TopCat.of PUnit.{u + 1}), Decidable (PUnit.unit \u2208 U)] :\n    skyscraperPresheaf p\u2080 A =\n      (ofHom (ContinuousMap.const (TopCat.of PUnit) p\u2080)) _*\n        skyscraperPresheaf (X := TopCat.of PUnit) PUnit.unit A := by\n  convert_to @skyscraperPresheaf X p\u2080 (fun U => hd <| (Opens.map <| ofHom <|\n      ContinuousMap.const _ p\u2080).obj U)\n    C _ _ A = _ <;> congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sheaves/Skyscraper.lean", "context": {"open": ["TopologicalSpace TopCat CategoryTheory CategoryTheory.Limits Opposite", "scoped AlgebraicGeometry"], "variables": ["{X : TopCat.{u}} (p\u2080 : X) [\u2200 U : Opens X, Decidable (p\u2080 \u2208 U)]", "{C : Type v} [Category.{w} C] [HasTerminal C] (A : C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : TopCat\np\u2080 : \u2191X\ninst\u271d\u00b2 : (U : Opens \u2191X) \u2192 Decidable (p\u2080 \u2208 U)\nC : Type v\ninst\u271d\u00b9 : Category.{w, v} C\ninst\u271d : HasTerminal C\nA : C\nhd : (U : Opens \u2191(of PUnit.{u + 1})) \u2192 Decidable (PUnit.unit \u2208 U)\n\u22a2 skyscraperPresheaf p\u2080 A =\n    (Presheaf.pushforward C (ofHom (ContinuousMap.const (\u2191(of PUnit.{u + 1})) p\u2080))).obj\n      (skyscraperPresheaf PUnit.unit A)"}, {"line": "convert_to @skyscraperPresheaf X p\u2080 (fun U => hd <| (Opens.map <| ofHom <|\n      ContinuousMap.const _ p\u2080).obj U)\n    C _ _ A = _ <;> congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem skyscraperPresheaf_isSheaf : (skyscraperPresheaf p\u2080 A).IsSheaf := by\n  classical exact\n    (Presheaf.isSheaf_iso_iff (eqToIso <| skyscraperPresheaf_eq_pushforward p\u2080 A)).mpr <|\n      (Sheaf.pushforward_sheaf_of_sheaf _\n        (Presheaf.isSheaf_on_punit_of_isTerminal _ (by\n          dsimp [skyscraperPresheaf]\n          rw [if_neg]\n          \u00b7 exact terminalIsTerminal\n          \u00b7 #adaptation_note /-- 2024-03-24\n            Previously the universe annotation was not needed here. -/\n            exact Set.not_mem_empty PUnit.unit.{u+1})))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sheaves/Skyscraper.lean", "context": {"open": ["TopologicalSpace TopCat CategoryTheory CategoryTheory.Limits Opposite", "scoped AlgebraicGeometry"], "variables": ["{X : TopCat.{u}} (p\u2080 : X) [\u2200 U : Opens X, Decidable (p\u2080 \u2208 U)]", "{C : Type v} [Category.{w} C] [HasTerminal C] (A : C)", "{C : Type v} [Category.{u} C] (A : C) [HasTerminal C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : TopCat\np\u2080 : \u2191X\ninst\u271d\u00b2 : (U : Opens \u2191X) \u2192 Decidable (p\u2080 \u2208 U)\nC : Type v\ninst\u271d\u00b9 : Category.{u, v} C\nA : C\ninst\u271d : HasTerminal C\n\u22a2 (skyscraperPresheaf p\u2080 A).IsSheaf"}, {"line": "classical exact\n    (Presheaf.isSheaf_iso_iff (eqToIso <| skyscraperPresheaf_eq_pushforward p\u2080 A)).mpr <|\n      (Sheaf.pushforward_sheaf_of_sheaf _\n        (Presheaf.isSheaf_on_punit_of_isTerminal _ (by\n          dsimp [skyscraperPresheaf]\n          rw [if_neg]\n          \u00b7 exact terminalIsTerminal\n          \u00b7 #adaptation_note /-- 2024-03-24\n            Previously the universe annotation was not needed here. -/\n            exact Set.not_mem_empty PUnit.unit.{u+1})))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem to_skyscraper_fromStalk {\ud835\udcd5 : Presheaf C X} {c : C} (f : \ud835\udcd5 \u27f6 skyscraperPresheaf p\u2080 c) :\n    toSkyscraperPresheaf p\u2080 (fromStalk _ f) = f := by\n  apply NatTrans.ext\n  ext U\n  dsimp\n  split_ifs with h\n  \u00b7 rw [\u2190 Category.assoc, germ_fromStalk, Category.assoc, eqToHom_trans, eqToHom_refl,\n      Category.comp_id]\n  \u00b7 exact ((if_neg h).symm.ndrec terminalIsTerminal).hom_ext ..\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sheaves/Skyscraper.lean", "context": {"open": ["TopologicalSpace TopCat CategoryTheory CategoryTheory.Limits Opposite", "scoped AlgebraicGeometry"], "variables": ["{X : TopCat.{u}} (p\u2080 : X) [\u2200 U : Opens X, Decidable (p\u2080 \u2208 U)]", "{C : Type v} [Category.{w} C] [HasTerminal C] (A : C)", "{C : Type v} [Category.{u} C] (A : C) [HasTerminal C]", "[HasColimits C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : TopCat\np\u2080 : \u2191X\ninst\u271d\u00b3 : (U : Opens \u2191X) \u2192 Decidable (p\u2080 \u2208 U)\nC : Type v\ninst\u271d\u00b2 : Category.{u, v} C\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasColimits C\nx\u271d : Sort u_1\ntoSkyscraperPresheaf : x\u271d\n\ud835\udcd5 : Presheaf C X\nc : C\nf : \ud835\udcd5 \u27f6 skyscraperPresheaf p\u2080 c\n\u22a2 sorry = f"}, {"line": "apply NatTrans.ext", "tactic_state": "case app\nX : TopCat\np\u2080 : \u2191X\ninst\u271d\u00b3 : (U : Opens \u2191X) \u2192 Decidable (p\u2080 \u2208 U)\nC : Type v\ninst\u271d\u00b2 : Category.{u, v} C\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasColimits C\nx\u271d : Sort u_1\ntoSkyscraperPresheaf : x\u271d\n\ud835\udcd5 : Presheaf C X\nc : C\nf : \ud835\udcd5 \u27f6 skyscraperPresheaf p\u2080 c\n\u22a2 sorry.app = f.app"}, {"line": "ext U", "tactic_state": "case app.h\nX : TopCat\np\u2080 : \u2191X\ninst\u271d\u00b3 : (U : Opens \u2191X) \u2192 Decidable (p\u2080 \u2208 U)\nC : Type v\ninst\u271d\u00b2 : Category.{u, v} C\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasColimits C\nx\u271d : Sort u_1\ntoSkyscraperPresheaf : x\u271d\n\ud835\udcd5 : Presheaf C X\nc : C\nf : \ud835\udcd5 \u27f6 skyscraperPresheaf p\u2080 c\nU : (Opens \u2191X)\u1d52\u1d56\n\u22a2 sorry.app U = f.app U"}, {"line": "dsimp", "tactic_state": "case app.h\nX : TopCat\np\u2080 : \u2191X\ninst\u271d\u00b3 : (U : Opens \u2191X) \u2192 Decidable (p\u2080 \u2208 U)\nC : Type v\ninst\u271d\u00b2 : Category.{u, v} C\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasColimits C\nx\u271d : Sort u_1\ntoSkyscraperPresheaf : x\u271d\n\ud835\udcd5 : Presheaf C X\nc : C\nf : \ud835\udcd5 \u27f6 skyscraperPresheaf p\u2080 c\nU : (Opens \u2191X)\u1d52\u1d56\n\u22a2 (sorry ()).app U = f.app U"}, {"line": "split_ifs with h", "tactic_state": "case pos\nX : TopCat\np\u2080 : \u2191X\ninst\u271d\u00b3 : (U : Opens \u2191X) \u2192 Decidable (p\u2080 \u2208 U)\nC : Type v\ninst\u271d\u00b2 : Category.{u, v} C\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasColimits C\nx\u271d : Sort u_1\ntoSkyscraperPresheaf : x\u271d\n\ud835\udcd5 : Presheaf C X\nc : C\nf : \ud835\udcd5 \u27f6 skyscraperPresheaf p\u2080 c\nU : (Opens \u2191X)\u1d52\u1d56\nh : p\u2080 \u2208 unop U\n\u22a2 (sorry ()).app U = f.app U\n---\ncase neg\nX : TopCat\np\u2080 : \u2191X\ninst\u271d\u00b3 : (U : Opens \u2191X) \u2192 Decidable (p\u2080 \u2208 U)\nC : Type v\ninst\u271d\u00b2 : Category.{u, v} C\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasColimits C\nx\u271d : Sort u_1\ntoSkyscraperPresheaf : x\u271d\n\ud835\udcd5 : Presheaf C X\nc : C\nf : \ud835\udcd5 \u27f6 skyscraperPresheaf p\u2080 c\nU : (Opens \u2191X)\u1d52\u1d56\nh : p\u2080 \u2209 unop U\n\u22a2 (sorry ()).app U = f.app U"}, {"line": "\u00b7 rw [\u2190 Category.assoc, germ_fromStalk, Category.assoc, eqToHom_trans, eqToHom_refl,\n      Category.comp_id]", "tactic_state": "case neg\nX : TopCat\np\u2080 : \u2191X\ninst\u271d\u00b3 : (U : Opens \u2191X) \u2192 Decidable (p\u2080 \u2208 U)\nC : Type v\ninst\u271d\u00b2 : Category.{u, v} C\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasColimits C\nx\u271d : Sort u_1\ntoSkyscraperPresheaf : x\u271d\n\ud835\udcd5 : Presheaf C X\nc : C\nf : \ud835\udcd5 \u27f6 skyscraperPresheaf p\u2080 c\nU : (Opens \u2191X)\u1d52\u1d56\nh : p\u2080 \u2209 unop U\n\u22a2 (sorry ()).app U = f.app U"}, {"line": "\u00b7 exact ((if_neg h).symm.ndrec terminalIsTerminal).hom_ext ..", "tactic_state": "No Goals!"}]}
{"declaration": "theorem stalkPushforward_germ (f : X \u27f6 Y) (F : X.Presheaf C) (U : Opens Y)\n    (x : X) (hx : f x \u2208 U) :\n      (f _* F).germ U (f x) hx \u226b F.stalkPushforward C f x = F.germ ((Opens.map f).obj U) x hx := by\n  simp [germ, stalkPushforward]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sheaves/Stalks.lean", "context": {"open": ["CategoryTheory", "TopCat", "CategoryTheory.Limits", "TopologicalSpace Topology", "Opposite", "scoped AlgebraicGeometry"], "variables": ["{C : Type u} [Category.{v} C]", "[HasColimits.{v} C]", "{X Y Z : TopCat.{v}}", "(C) in", "{FC : C \u2192 C \u2192 Type*} {CC : C \u2192 Type*} [\u2200 X Y, FunLike (FC X Y) (CC X) (CC Y)]", "(C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasColimits C\nX Y : TopCat\nf : X \u27f6 Y\nF : Presheaf C X\nU : Opens \u2191Y\nx : \u2191X\nhx : (ConcreteCategory.hom f) x \u2208 U\n\u22a2 CategoryStruct.comp (((Presheaf.pushforward C f).obj F).germ U ((ConcreteCategory.hom f) x) hx)\n      (Presheaf.stalkPushforward C f F x) =\n    F.germ ((Opens.map f).obj U) x hx"}, {"line": "simp [germ, stalkPushforward]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem covering_presieve_eq_self {Y : Opens X} (R : Presieve Y) :\n    presieveOfCoveringAux (coveringOfPresieve Y R) Y = R := by\n  funext Z\n  ext f\n  exact \u27e8fun \u27e8\u27e8_, f', h\u27e9, rfl\u27e9 => by rwa [Subsingleton.elim f f'], fun h => \u27e8\u27e8Z, f, h\u27e9, rfl\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sheaves/SheafCondition/Sites.lean", "context": {"open": ["CategoryTheory TopologicalSpace Topology"], "variables": ["{X : TopCat.{w}}", "(U : Opens X) (R : Presieve U)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : TopCat\nx\u271d : Sort u_1\npresieveOfCoveringAux : x\u271d\nY : Opens \u2191X\nR : Presieve Y\n\u22a2 sorry = R"}, {"line": "funext Z", "tactic_state": "case h\nX : TopCat\nx\u271d : Sort u_1\npresieveOfCoveringAux : x\u271d\nY : Opens \u2191X\nR : Presieve Y\nZ : Opens \u2191X\n\u22a2 sorry = R"}, {"line": "ext f", "tactic_state": "case h.h\nX : TopCat\nx\u271d : Sort u_1\npresieveOfCoveringAux : x\u271d\nY : Opens \u2191X\nR : Presieve Y\nZ : Opens \u2191X\nf : Z \u27f6 Y\n\u22a2 f \u2208 sorry \u2194 f \u2208 R"}, {"line": "exact \u27e8fun \u27e8\u27e8_, f', h\u27e9, rfl\u27e9 => by rwa [Subsingleton.elim f f'], fun h => \u27e8\u27e8Z, f, h\u27e9, rfl\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Topology.IsOpenEmbedding.compatiblePreserving (hf : IsOpenEmbedding f) :\n    CompatiblePreserving (Opens.grothendieckTopology Y) hf.isOpenMap.functor := by\n  haveI : Mono f := (TopCat.mono_iff_injective f).mpr hf.injective\n  apply compatiblePreservingOfDownwardsClosed\n  intro U V i\n  refine \u27e8(Opens.map f).obj V, eqToIso <| Opens.ext <| Set.image_preimage_eq_of_subset fun x h \u21a6 ?_\u27e9\n  obtain \u27e8_, _, rfl\u27e9 := i.le h\n  exact \u27e8_, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sheaves/SheafCondition/Sites.lean", "context": {"open": ["CategoryTheory TopologicalSpace Topology", "TopCat.Presheaf Opposite"], "variables": ["{X : TopCat.{w}}", "(U : Opens X) (R : Presieve U)", "{\u03b9 : Type v} (U : \u03b9 \u2192 Opens X)", "{X : TopCat} {\u03b9 : Type*}", "{C : Type u} [Category.{v} C]", "{X Y : TopCat.{w}} {f : X \u27f6 Y} {F : Y.Presheaf C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : TopCat\nf : X \u27f6 Y\nhf : IsOpenEmbedding \u21d1(ConcreteCategory.hom f)\n\u22a2 CompatiblePreserving (Opens.grothendieckTopology \u2191Y) \u22ef.functor"}, {"line": "haveI : Mono f := (TopCat.mono_iff_injective f).mpr hf.injective", "tactic_state": "X Y : TopCat\nf : X \u27f6 Y\nhf : IsOpenEmbedding \u21d1(ConcreteCategory.hom f)\nthis : Mono f\n\u22a2 CompatiblePreserving (Opens.grothendieckTopology \u2191Y) \u22ef.functor"}, {"line": "apply compatiblePreservingOfDownwardsClosed", "tactic_state": "case hF\nX Y : TopCat\nf : X \u27f6 Y\nhf : IsOpenEmbedding \u21d1(ConcreteCategory.hom f)\nthis : Mono f\n\u22a2 {c : Opens \u2191X} \u2192 {d : Opens \u2191Y} \u2192 (d \u27f6 \u22ef.functor.obj c) \u2192 (c' : Opens \u2191X) \u00d7 (\u22ef.functor.obj c' \u2245 d)"}, {"line": "intro U V i", "tactic_state": "case hF\nX Y : TopCat\nf : X \u27f6 Y\nhf : IsOpenEmbedding \u21d1(ConcreteCategory.hom f)\nthis : Mono f\nU : Opens \u2191X\nV : Opens \u2191Y\ni : V \u27f6 \u22ef.functor.obj U\n\u22a2 (c' : Opens \u2191X) \u00d7 (\u22ef.functor.obj c' \u2245 V)"}, {"line": "refine \u27e8(Opens.map f).obj V, eqToIso <| Opens.ext <| Set.image_preimage_eq_of_subset fun x h \u21a6 ?_\u27e9", "tactic_state": "case hF\nX Y : TopCat\nf : X \u27f6 Y\nhf : IsOpenEmbedding \u21d1(ConcreteCategory.hom f)\nthis : Mono f\nU : Opens \u2191X\nV : Opens \u2191Y\ni : V \u27f6 \u22ef.functor.obj U\nx : \u2191Y\nh : x \u2208 V.1\n\u22a2 x \u2208 Set.range \u21d1(ConcreteCategory.hom f)"}, {"line": "obtain \u27e8_, _, rfl\u27e9 := i.le h", "tactic_state": "case hF.intro.intro\nX Y : TopCat\nf : X \u27f6 Y\nhf : IsOpenEmbedding \u21d1(ConcreteCategory.hom f)\nthis : Mono f\nU : Opens \u2191X\nV : Opens \u2191Y\ni : V \u27f6 \u22ef.functor.obj U\nw\u271d : \u2191X\nleft\u271d : w\u271d \u2208 \u2191U\nh : (ConcreteCategory.hom f) w\u271d \u2208 V.1\n\u22a2 (ConcreteCategory.hom f) w\u271d \u2208 Set.range \u21d1(ConcreteCategory.hom f)"}, {"line": "exact \u27e8_, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Topology.IsOpenEmbedding.functor_isContinuous (h : IsOpenEmbedding f) :\n    h.isOpenMap.functor.IsContinuous (Opens.grothendieckTopology X)\n      (Opens.grothendieckTopology Y) := by\n  apply Functor.isContinuous_of_coverPreserving\n  \u00b7 exact h.compatiblePreserving\n  \u00b7 exact h.isOpenMap.coverPreserving\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sheaves/SheafCondition/Sites.lean", "context": {"open": ["CategoryTheory TopologicalSpace Topology", "TopCat.Presheaf Opposite"], "variables": ["{X : TopCat.{w}}", "(U : Opens X) (R : Presieve U)", "{\u03b9 : Type v} (U : \u03b9 \u2192 Opens X)", "{X : TopCat} {\u03b9 : Type*}", "{C : Type u} [Category.{v} C]", "{X Y : TopCat.{w}} {f : X \u27f6 Y} {F : Y.Presheaf C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : TopCat\nf : X \u27f6 Y\nh : IsOpenEmbedding \u21d1(ConcreteCategory.hom f)\n\u22a2 \u22ef.functor.IsContinuous (Opens.grothendieckTopology \u2191X) (Opens.grothendieckTopology \u2191Y)"}, {"line": "apply Functor.isContinuous_of_coverPreserving", "tactic_state": "case hF\u2081\nX Y : TopCat\nf : X \u27f6 Y\nh : IsOpenEmbedding \u21d1(ConcreteCategory.hom f)\n\u22a2 CompatiblePreserving (Opens.grothendieckTopology \u2191Y) \u22ef.functor\n---\ncase hF\u2082\nX Y : TopCat\nf : X \u27f6 Y\nh : IsOpenEmbedding \u21d1(ConcreteCategory.hom f)\n\u22a2 CoverPreserving (Opens.grothendieckTopology \u2191X) (Opens.grothendieckTopology \u2191Y) \u22ef.functor"}, {"line": "\u00b7 exact h.compatiblePreserving", "tactic_state": "case hF\u2082\nX Y : TopCat\nf : X \u27f6 Y\nh : IsOpenEmbedding \u21d1(ConcreteCategory.hom f)\n\u22a2 CoverPreserving (Opens.grothendieckTopology \u2191X) (Opens.grothendieckTopology \u2191Y) \u22ef.functor"}, {"line": "\u00b7 exact h.isOpenMap.coverPreserving", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TopCat.Presheaf.isSheaf_of_isOpenEmbedding (h : IsOpenEmbedding f) (hF : F.IsSheaf) :\n    IsSheaf (h.isOpenMap.functor.op \u22d9 F) := by\n  have := h.functor_isContinuous\n  exact Functor.op_comp_isSheaf _ _ _ \u27e8_, hF\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sheaves/SheafCondition/Sites.lean", "context": {"open": ["CategoryTheory TopologicalSpace Topology", "TopCat.Presheaf Opposite"], "variables": ["{X : TopCat.{w}}", "(U : Opens X) (R : Presieve U)", "{\u03b9 : Type v} (U : \u03b9 \u2192 Opens X)", "{X : TopCat} {\u03b9 : Type*}", "{C : Type u} [Category.{v} C]", "{X Y : TopCat.{w}} {f : X \u27f6 Y} {F : Y.Presheaf C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX Y : TopCat\nf : X \u27f6 Y\nF : Presheaf C Y\nh : IsOpenEmbedding \u21d1(ConcreteCategory.hom f)\nhF : F.IsSheaf\n\u22a2 IsSheaf (\u22ef.functor.op.comp F)"}, {"line": "have := h.functor_isContinuous", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nX Y : TopCat\nf : X \u27f6 Y\nF : Presheaf C Y\nh : IsOpenEmbedding \u21d1(ConcreteCategory.hom f)\nhF : F.IsSheaf\nthis : \u22ef.functor.IsContinuous (Opens.grothendieckTopology \u2191X) (Opens.grothendieckTopology \u2191Y)\n\u22a2 IsSheaf (\u22ef.functor.op.comp F)"}, {"line": "exact Functor.op_comp_isSheaf _ _ _ \u27e8_, hF\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ArzelaAscoli.isCompact_closure_of_isClosedEmbedding [TopologicalSpace \u03b9] [T2Space \u03b1]\n    {\ud835\udd16 : Set (Set X)} (\ud835\udd16_compact : \u2200 K \u2208 \ud835\udd16, IsCompact K)\n    (F_clemb : IsClosedEmbedding (UniformOnFun.ofFun \ud835\udd16 \u2218 F))\n    {s : Set \u03b9} (s_eqcont : \u2200 K \u2208 \ud835\udd16, EquicontinuousOn (F \u2218 ((\u2191) : s \u2192 \u03b9)) K)\n    (s_pointwiseCompact : \u2200 K \u2208 \ud835\udd16, \u2200 x \u2208 K, \u2203 Q, IsCompact Q \u2227 \u2200 i \u2208 s, F i x \u2208 Q) :\n    IsCompact (closure s) := by\n  -- We apply `ArzelaAscoli.compactSpace_of_isClosedEmbedding` to the map\n  -- `F \u2218 (\u2191) : closure s \u2192 (X \u2192 \u03b1)`, for which all the hypotheses are easily verified.\n  rw [isCompact_iff_compactSpace]\n  have : \u2200 K \u2208 \ud835\udd16, \u2200 x \u2208 K, Continuous (eval x \u2218 F) := fun K hK x hx \u21a6\n    UniformOnFun.uniformContinuous_eval_of_mem _ _ hx hK |>.continuous.comp F_clemb.continuous\n  have cls_eqcont : \u2200 K \u2208 \ud835\udd16, EquicontinuousOn (F \u2218 ((\u2191) : closure s \u2192 \u03b9)) K :=\n    fun K hK \u21a6 (s_eqcont K hK).closure' <| show Continuous (K.restrict \u2218 F) from\n      continuous_pi fun \u27e8x, hx\u27e9 \u21a6 this K hK x hx\n  have cls_pointwiseCompact : \u2200 K \u2208 \ud835\udd16, \u2200 x \u2208 K, \u2203 Q, IsCompact Q \u2227 \u2200 i \u2208 closure s, F i x \u2208 Q :=\n    fun K hK x hx \u21a6 (s_pointwiseCompact K hK x hx).imp fun Q hQ \u21a6 \u27e8hQ.1, closure_minimal hQ.2 <|\n      hQ.1.isClosed.preimage (this K hK x hx)\u27e9\n  exact ArzelaAscoli.compactSpace_of_isClosedEmbedding \ud835\udd16_compact\n    (F_clemb.comp isClosed_closure.isClosedEmbedding_subtypeVal) cls_eqcont\n    fun K hK x hx \u21a6 (cls_pointwiseCompact K hK x hx).imp fun Q hQ \u21a6 \u27e8hQ.1, by simpa using hQ.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Ascoli.lean", "context": {"open": ["Set Filter Uniformity Topology Function UniformConvergence"], "variables": ["{\u03b9 X \u03b1 : Type*} [TopologicalSpace X] [UniformSpace \u03b1] {F : \u03b9 \u2192 X \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nX : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : UniformSpace \u03b1\nF : \u03b9 \u2192 X \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b9\ninst\u271d : T2Space \u03b1\n\ud835\udd16 : Set (Set X)\n\ud835\udd16_compact : \u2200 K \u2208 \ud835\udd16, IsCompact K\nF_clemb : IsClosedEmbedding (\u21d1(UniformOnFun.ofFun \ud835\udd16) \u2218 F)\ns : Set \u03b9\ns_eqcont : \u2200 K \u2208 \ud835\udd16, EquicontinuousOn (F \u2218 Subtype.val) K\ns_pointwiseCompact : \u2200 K \u2208 \ud835\udd16, \u2200 x \u2208 K, \u2203 Q, IsCompact Q \u2227 \u2200 i \u2208 s, F i x \u2208 Q\n\u22a2 IsCompact (closure s)"}, {"line": "rw [isCompact_iff_compactSpace]", "tactic_state": "\u03b9 : Type u_1\nX : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : UniformSpace \u03b1\nF : \u03b9 \u2192 X \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b9\ninst\u271d : T2Space \u03b1\n\ud835\udd16 : Set (Set X)\n\ud835\udd16_compact : \u2200 K \u2208 \ud835\udd16, IsCompact K\nF_clemb : IsClosedEmbedding (\u21d1(UniformOnFun.ofFun \ud835\udd16) \u2218 F)\ns : Set \u03b9\ns_eqcont : \u2200 K \u2208 \ud835\udd16, EquicontinuousOn (F \u2218 Subtype.val) K\ns_pointwiseCompact : \u2200 K \u2208 \ud835\udd16, \u2200 x \u2208 K, \u2203 Q, IsCompact Q \u2227 \u2200 i \u2208 s, F i x \u2208 Q\n\u22a2 CompactSpace \u2191(closure s)"}, {"line": "have : \u2200 K \u2208 \ud835\udd16, \u2200 x \u2208 K, Continuous (eval x \u2218 F) := fun K hK x hx \u21a6\n    UniformOnFun.uniformContinuous_eval_of_mem _ _ hx hK |>.continuous.comp F_clemb.continuous", "tactic_state": "\u03b9 : Type u_1\nX : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : UniformSpace \u03b1\nF : \u03b9 \u2192 X \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b9\ninst\u271d : T2Space \u03b1\n\ud835\udd16 : Set (Set X)\n\ud835\udd16_compact : \u2200 K \u2208 \ud835\udd16, IsCompact K\nF_clemb : IsClosedEmbedding (\u21d1(UniformOnFun.ofFun \ud835\udd16) \u2218 F)\ns : Set \u03b9\ns_eqcont : \u2200 K \u2208 \ud835\udd16, EquicontinuousOn (F \u2218 Subtype.val) K\ns_pointwiseCompact : \u2200 K \u2208 \ud835\udd16, \u2200 x \u2208 K, \u2203 Q, IsCompact Q \u2227 \u2200 i \u2208 s, F i x \u2208 Q\nthis : \u2200 K \u2208 \ud835\udd16, \u2200 x \u2208 K, sorry\n\u22a2 CompactSpace \u2191(closure s)"}, {"line": "have cls_eqcont : \u2200 K \u2208 \ud835\udd16, EquicontinuousOn (F \u2218 ((\u2191) : closure s \u2192 \u03b9)) K :=\n    fun K hK \u21a6 (s_eqcont K hK).closure' <| show Continuous (K.restrict \u2218 F) from\n      continuous_pi fun \u27e8x, hx\u27e9 \u21a6 this K hK x hx", "tactic_state": "\u03b9 : Type u_1\nX : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : UniformSpace \u03b1\nF : \u03b9 \u2192 X \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b9\ninst\u271d : T2Space \u03b1\n\ud835\udd16 : Set (Set X)\n\ud835\udd16_compact : \u2200 K \u2208 \ud835\udd16, IsCompact K\nF_clemb : IsClosedEmbedding (\u21d1(UniformOnFun.ofFun \ud835\udd16) \u2218 F)\ns : Set \u03b9\ns_eqcont : \u2200 K \u2208 \ud835\udd16, EquicontinuousOn (F \u2218 Subtype.val) K\ns_pointwiseCompact : \u2200 K \u2208 \ud835\udd16, \u2200 x \u2208 K, \u2203 Q, IsCompact Q \u2227 \u2200 i \u2208 s, F i x \u2208 Q\nthis : \u2200 K \u2208 \ud835\udd16, \u2200 x \u2208 K, sorry\ncls_eqcont : \u2200 K \u2208 \ud835\udd16, sorry\n\u22a2 CompactSpace \u2191(closure s)"}, {"line": "have cls_pointwiseCompact : \u2200 K \u2208 \ud835\udd16, \u2200 x \u2208 K, \u2203 Q, IsCompact Q \u2227 \u2200 i \u2208 closure s, F i x \u2208 Q :=\n    fun K hK x hx \u21a6 (s_pointwiseCompact K hK x hx).imp fun Q hQ \u21a6 \u27e8hQ.1, closure_minimal hQ.2 <|\n      hQ.1.isClosed.preimage (this K hK x hx)\u27e9", "tactic_state": "\u03b9 : Type u_1\nX : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : UniformSpace \u03b1\nF : \u03b9 \u2192 X \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b9\ninst\u271d : T2Space \u03b1\n\ud835\udd16 : Set (Set X)\n\ud835\udd16_compact : \u2200 K \u2208 \ud835\udd16, IsCompact K\nF_clemb : IsClosedEmbedding (\u21d1(UniformOnFun.ofFun \ud835\udd16) \u2218 F)\ns : Set \u03b9\ns_eqcont : \u2200 K \u2208 \ud835\udd16, EquicontinuousOn (F \u2218 Subtype.val) K\ns_pointwiseCompact : \u2200 K \u2208 \ud835\udd16, \u2200 x \u2208 K, \u2203 Q, IsCompact Q \u2227 \u2200 i \u2208 s, F i x \u2208 Q\nthis : \u2200 K \u2208 \ud835\udd16, \u2200 x \u2208 K, sorry\ncls_eqcont : \u2200 K \u2208 \ud835\udd16, sorry\ncls_pointwiseCompact : \u2200 K \u2208 \ud835\udd16, \u2200 x \u2208 K, \u2203 Q, IsCompact Q \u2227 \u2200 i \u2208 sorry, F i x \u2208 Q\n\u22a2 CompactSpace \u2191(closure s)"}, {"line": "exact ArzelaAscoli.compactSpace_of_isClosedEmbedding \ud835\udd16_compact\n    (F_clemb.comp isClosed_closure.isClosedEmbedding_subtypeVal) cls_eqcont\n    fun K hK x hx \u21a6 (cls_pointwiseCompact K hK x hx).imp fun Q hQ \u21a6 \u27e8hQ.1, by simpa using hQ.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_eq_uniformity_prod {a b : \u03b1} :\n    \ud835\udcdd (a, b) =\n      (\ud835\udce4 \u03b1).lift' fun s : Set (\u03b1 \u00d7 \u03b1) => { y : \u03b1 | (y, a) \u2208 s } \u00d7\u02e2 { y : \u03b1 | (b, y) \u2208 s } := by\n  rw [nhds_prod_eq]\n  rw [nhds_nhds_eq_uniformity_uniformity_prod]\n  rw [lift_lift'_same_eq_lift']\n  \u00b7 exact fun s => monotone_const.set_prod monotone_preimage\n  \u00b7 refine fun t => Monotone.set_prod ?_ monotone_const\n    exact monotone_preimage (f := fun y => (y, a))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\na b : \u03b1\n\u22a2 nhds (a, b) = (uniformity \u03b1).lift' fun s => {y | (y, a) \u2208 s} \u00d7\u02e2 {y | (b, y) \u2208 s}"}, {"line": "rw [nhds_prod_eq]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\na b : \u03b1\n\u22a2 nhds a \u00d7\u02e2 nhds b = (uniformity \u03b1).lift' fun s => {y | (y, a) \u2208 s} \u00d7\u02e2 {y | (b, y) \u2208 s}"}, {"line": "rw [nhds_nhds_eq_uniformity_uniformity_prod]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\na b : \u03b1\n\u22a2 ((uniformity \u03b1).lift fun s => (uniformity \u03b1).lift' fun t => {y | (y, a) \u2208 s} \u00d7\u02e2 {y | (b, y) \u2208 t}) =\n    (uniformity \u03b1).lift' fun s => {y | (y, a) \u2208 s} \u00d7\u02e2 {y | (b, y) \u2208 s}"}, {"line": "rw [lift_lift'_same_eq_lift']", "tactic_state": "case hg\u2081\n\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\na b : \u03b1\n\u22a2 \u2200 (s : Set (\u03b1 \u00d7 \u03b1)), Monotone fun t => {y | (y, a) \u2208 s} \u00d7\u02e2 {y | (b, y) \u2208 t}\n---\ncase hg\u2082\n\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\na b : \u03b1\n\u22a2 \u2200 (t : Set (\u03b1 \u00d7 \u03b1)), Monotone fun s => {y | (y, a) \u2208 s} \u00d7\u02e2 {y | (b, y) \u2208 t}"}, {"line": "\u00b7 exact fun s => monotone_const.set_prod monotone_preimage", "tactic_state": "case hg\u2082\n\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\na b : \u03b1\n\u22a2 \u2200 (t : Set (\u03b1 \u00d7 \u03b1)), Monotone fun s => {y | (y, a) \u2208 s} \u00d7\u02e2 {y | (b, y) \u2208 t}"}, {"line": "\u00b7 refine fun t => Monotone.set_prod ?_ monotone_const\n    exact monotone_preimage (f := fun y => (y, a))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_eq_uniformity (s : Set <| \u03b1 \u00d7 \u03b1) :\n    closure s = \u22c2 V \u2208 { V | V \u2208 \ud835\udce4 \u03b1 \u2227 IsSymmetricRel V }, V \u25cb s \u25cb V := by\n  ext \u27e8x, y\u27e9\n  simp +contextual only\n    [mem_closure_iff_nhds_basis (UniformSpace.hasBasis_nhds_prod x y), mem_iInter, mem_setOf_eq,\n      and_imp, mem_comp_comp, exists_prop, \u2190 mem_inter_iff, inter_comm, Set.Nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\ns : Set (\u03b1 \u00d7 \u03b1)\n\u22a2 closure s = \u22c2 V \u2208 {V | V \u2208 uniformity \u03b1 \u2227 IsSymmetricRel V}, compRel (compRel V s) V"}, {"line": "ext \u27e8x, y\u27e9", "tactic_state": "case h.mk\n\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\ns : Set (\u03b1 \u00d7 \u03b1)\nx y : \u03b1\n\u22a2 (x, y) \u2208 closure s \u2194 (x, y) \u2208 \u22c2 V \u2208 {V | V \u2208 uniformity \u03b1 \u2227 IsSymmetricRel V}, compRel (compRel V s) V"}, {"line": "simp +contextual only\n    [mem_closure_iff_nhds_basis (UniformSpace.hasBasis_nhds_prod x y), mem_iInter, mem_setOf_eq,\n      and_imp, mem_comp_comp, exists_prop, \u2190 mem_inter_iff, inter_comm, Set.Nonempty]", "tactic_state": "case h.mk\n\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\ns : Set (\u03b1 \u00d7 \u03b1)\nx y : \u03b1\n\u22a2 (x, y) \u2208 closure s \u2194 \u2200 i \u2208 uniformity \u03b1, IsSymmetricRel i \u2192 \u2203 x_1, x_1 \u2208 s \u2229 ball x i \u00d7\u02e2 ball y i"}]}
{"declaration": "theorem closure_eq_inter_uniformity {t : Set (\u03b1 \u00d7 \u03b1)} : closure t = \u22c2 d \u2208 \ud835\udce4 \u03b1, d \u25cb (t \u25cb d) :=\n  calc\n    closure t = \u22c2 (V) (_ : V \u2208 \ud835\udce4 \u03b1 \u2227 IsSymmetricRel V), V \u25cb t \u25cb V := closure_eq_uniformity t\n    _ = \u22c2 V \u2208 \ud835\udce4 \u03b1, V \u25cb t \u25cb V :=\n      Eq.symm <|\n        UniformSpace.hasBasis_symmetric.biInter_mem fun _ _ hV =>\n          compRel_mono (compRel_mono hV Subset.rfl) hV\n    _ = \u22c2 V \u2208 \ud835\udce4 \u03b1, V \u25cb (t \u25cb V) := by simp only [compRel_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nt : Set (\u03b1 \u00d7 \u03b1)\n\u22a2 \u22c2 V \u2208 uniformity \u03b1, compRel (compRel V t) V = \u22c2 V \u2208 uniformity \u03b1, compRel V (compRel t V)"}, {"line": "simp only [compRel_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma DenseRange.iUnion_uniformity_ball {\u03b9 : Type*} {xs : \u03b9 \u2192 \u03b1}\n    (xs_dense : DenseRange xs) {U : Set (\u03b1 \u00d7 \u03b1)} (hU : U \u2208 uniformity \u03b1) :\n    \u22c3 i, UniformSpace.ball (xs i) U = univ := by\n  rw [\u2190 biUnion_range (f := xs) (g := fun x \u21a6 UniformSpace.ball x U)]\n  exact Dense.biUnion_uniformity_ball xs_dense hU\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\n\u03b9 : Type u_2\nxs : \u03b9 \u2192 \u03b1\nxs_dense : DenseRange xs\nU : Set (\u03b1 \u00d7 \u03b1)\nhU : U \u2208 uniformity \u03b1\n\u22a2 \u22c3 i, ball (xs i) U = univ"}, {"line": "rw [\u2190 biUnion_range (f := xs) (g := fun x \u21a6 UniformSpace.ball x U)]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\n\u03b9 : Type u_2\nxs : \u03b9 \u2192 \u03b1\nxs_dense : DenseRange xs\nU : Set (\u03b1 \u00d7 \u03b1)\nhU : U \u2208 uniformity \u03b1\n\u22a2 \u22c3 x \u2208 range xs, ball x U = univ"}, {"line": "exact Dense.biUnion_uniformity_ball xs_dense hU", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformity_hasBasis_open_symmetric :\n    HasBasis (\ud835\udce4 \u03b1) (fun V : Set (\u03b1 \u00d7 \u03b1) => V \u2208 \ud835\udce4 \u03b1 \u2227 IsOpen V \u2227 IsSymmetricRel V) id := by\n  simp only [\u2190 and_assoc]\n  refine uniformity_hasBasis_open.restrict fun s hs => \u27e8symmetrizeRel s, ?_\u27e9\n  exact\n    \u27e8\u27e8symmetrize_mem_uniformity hs.1, IsOpen.inter hs.2 (hs.2.preimage continuous_swap)\u27e9,\n      symmetric_symmetrizeRel s, symmetrizeRel_subset_self s\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\n\u22a2 (uniformity \u03b1).HasBasis (fun V => V \u2208 uniformity \u03b1 \u2227 IsOpen V \u2227 IsSymmetricRel V) id"}, {"line": "simp only [\u2190 and_assoc]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\n\u22a2 (uniformity \u03b1).HasBasis (fun V => (V \u2208 uniformity \u03b1 \u2227 IsOpen V) \u2227 IsSymmetricRel V) id"}, {"line": "refine uniformity_hasBasis_open.restrict fun s hs => \u27e8symmetrizeRel s, ?_\u27e9", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\ns : Set (\u03b1 \u00d7 \u03b1)\nhs : s \u2208 uniformity \u03b1 \u2227 IsOpen s\n\u22a2 (symmetrizeRel s \u2208 uniformity \u03b1 \u2227 IsOpen (symmetrizeRel s)) \u2227\n    IsSymmetricRel (symmetrizeRel s) \u2227 id (symmetrizeRel s) \u2286 id s"}, {"line": "exact\n    \u27e8\u27e8symmetrize_mem_uniformity hs.1, IsOpen.inter hs.2 (hs.2.preimage continuous_swap)\u27e9,\n      symmetric_symmetrizeRel s, symmetrizeRel_subset_self s\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ball_preimage {f : \u03b1 \u2192 \u03b2} {U : Set (\u03b2 \u00d7 \u03b2)} {x : \u03b1} :\n    UniformSpace.ball x (Prod.map f f \u207b\u00b9' U) = f \u207b\u00b9' UniformSpace.ball (f x) U := by\n  ext : 1\n  simp only [UniformSpace.ball]\n  simp only [mem_preimage]\n  simp only [Prod.map_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nU : Set (\u03b2 \u00d7 \u03b2)\nx : \u03b1\n\u22a2 ball x (Prod.map f f \u207b\u00b9' U) = f \u207b\u00b9' ball (f x) U"}, {"line": "ext : 1", "tactic_state": "case h\n\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nU : Set (\u03b2 \u00d7 \u03b2)\nx x\u271d : \u03b1\n\u22a2 x\u271d \u2208 ball x (Prod.map f f \u207b\u00b9' U) \u2194 x\u271d \u2208 f \u207b\u00b9' ball (f x) U"}, {"line": "simp only [UniformSpace.ball]", "tactic_state": "case h\n\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nU : Set (\u03b2 \u00d7 \u03b2)\nx x\u271d : \u03b1\n\u22a2 x\u271d \u2208 Prod.mk x \u207b\u00b9' (Prod.map f f \u207b\u00b9' U) \u2194 x\u271d \u2208 f \u207b\u00b9' (Prod.mk (f x) \u207b\u00b9' U)"}, {"line": "simp only [mem_preimage]", "tactic_state": "case h\n\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nU : Set (\u03b2 \u00d7 \u03b2)\nx x\u271d : \u03b1\n\u22a2 Prod.map f f (x, x\u271d) \u2208 U \u2194 (f x, f x\u271d) \u2208 U"}, {"line": "simp only [Prod.map_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformSpace_comap_id {\u03b1 : Type*} : UniformSpace.comap (id : \u03b1 \u2192 \u03b1) = id := by\n  ext : 2\n  rw [uniformity_comap]\n  rw [Prod.map_id]\n  rw [comap_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u22a2 UniformSpace.comap id = id"}, {"line": "ext : 2", "tactic_state": "case h.h\n\u03b1 : Type u_2\nx\u271d : UniformSpace \u03b1\n\u22a2 uniformity \u03b1 = uniformity \u03b1"}, {"line": "rw [uniformity_comap]", "tactic_state": "case h.h\n\u03b1 : Type u_2\nx\u271d : UniformSpace \u03b1\n\u22a2 Filter.comap (Prod.map id id) (uniformity \u03b1) = uniformity \u03b1"}, {"line": "rw [Prod.map_id]", "tactic_state": "case h.h\n\u03b1 : Type u_2\nx\u271d : UniformSpace \u03b1\n\u22a2 Filter.comap id (uniformity \u03b1) = uniformity \u03b1"}, {"line": "rw [comap_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UniformSpace.comap_comap {\u03b1 \u03b2 \u03b3} {u\u03b3 : UniformSpace \u03b3} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} :\n    UniformSpace.comap (g \u2218 f) u\u03b3 = UniformSpace.comap f (UniformSpace.comap g u\u03b3) := by\n  ext1\n  simp only [uniformity_comap]\n  simp only [Filter.comap_comap]\n  simp only [Prod.map_comp_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nu\u03b3 : UniformSpace \u03b3\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\n\u22a2 comap (g \u2218 f) u\u03b3 = comap f (comap g u\u03b3)"}, {"line": "ext1", "tactic_state": "case h\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nu\u03b3 : UniformSpace \u03b3\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\n\u22a2 uniformity \u03b1 = uniformity \u03b1"}, {"line": "simp only [uniformity_comap]", "tactic_state": "case h\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nu\u03b3 : UniformSpace \u03b3\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\n\u22a2 Filter.comap (Prod.map (g \u2218 f) (g \u2218 f)) (uniformity \u03b3) =\n    Filter.comap (Prod.map f f) (Filter.comap (Prod.map g g) (uniformity \u03b3))"}, {"line": "simp only [Filter.comap_comap]", "tactic_state": "case h\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nu\u03b3 : UniformSpace \u03b3\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\n\u22a2 Filter.comap (Prod.map (g \u2218 f) (g \u2218 f)) (uniformity \u03b3) = Filter.comap (Prod.map g g \u2218 Prod.map f f) (uniformity \u03b3)"}, {"line": "simp only [Prod.map_comp_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UniformSpace.comap_iInf {\u03b9 \u03b1 \u03b3} {u : \u03b9 \u2192 UniformSpace \u03b3} {f : \u03b1 \u2192 \u03b3} :\n    (\u2a05 i, u i).comap f = \u2a05 i, (u i).comap f := by\n  ext : 1\n  simp [uniformity_comap, iInf_uniformity]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_2\n\u03b1 : Type u_3\n\u03b3 : Type u_4\nu : \u03b9 \u2192 UniformSpace \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 comap f (\u2a05 i, u i) = \u2a05 i, comap f (u i)"}, {"line": "ext : 1", "tactic_state": "case h\n\u03b9 : Sort u_2\n\u03b1 : Type u_3\n\u03b3 : Type u_4\nu : \u03b9 \u2192 UniformSpace \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 uniformity \u03b1 = uniformity \u03b1"}, {"line": "simp [uniformity_comap, iInf_uniformity]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_iff_uniformContinuous_id {u v : UniformSpace \u03b1} :\n    u \u2264 v \u2194 @UniformContinuous _ _ u v id := by\n  rw [uniformContinuous_iff]\n  rw [uniformSpace_comap_id]\n  rw [id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d u v : UniformSpace \u03b1\n\u22a2 u \u2264 v \u2194 UniformContinuous id"}, {"line": "rw [uniformContinuous_iff]", "tactic_state": "\u03b1 : Type ua\ninst\u271d u v : UniformSpace \u03b1\n\u22a2 u \u2264 v \u2194 u \u2264 UniformSpace.comap id v"}, {"line": "rw [uniformSpace_comap_id]", "tactic_state": "\u03b1 : Type ua\ninst\u271d u v : UniformSpace \u03b1\n\u22a2 u \u2264 v \u2194 u \u2264 id v"}, {"line": "rw [id]", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma _root_.Filter.HasBasis.uniformSpace_eq_bot {\u03b9 p} {s : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)}\n    {u : UniformSpace \u03b1} (h : \ud835\udce4[u].HasBasis p s) :\n    u = \u22a5 \u2194 \u2203 i, p i \u2227 Pairwise fun x y : \u03b1 \u21a6 (x, y) \u2209 s i := by\n  simp [uniformSpace_eq_bot, h.mem_iff, subset_def, Pairwise, not_imp_not]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\n\u03b9 : Sort u_2\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)\nu : UniformSpace \u03b1\nh : (uniformity \u03b1).HasBasis p s\n\u22a2 u = \u22a5 \u2194 \u2203 i, p i \u2227 Pairwise fun x y => (x, y) \u2209 s i"}, {"line": "simp [uniformSpace_eq_bot, h.mem_iff, subset_def, Pairwise, not_imp_not]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toTopologicalSpace_sInf {s : Set (UniformSpace \u03b1)} :\n    (sInf s).toTopologicalSpace = \u2a05 i \u2208 s, @UniformSpace.toTopologicalSpace \u03b1 i := by\n  rw [sInf_eq_iInf]\n  simp only [\u2190 toTopologicalSpace_iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\ns : Set (UniformSpace \u03b1)\n\u22a2 toTopologicalSpace = \u2a05 i \u2208 s, toTopologicalSpace"}, {"line": "rw [sInf_eq_iInf]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\ns : Set (UniformSpace \u03b1)\n\u22a2 toTopologicalSpace = \u2a05 i \u2208 s, toTopologicalSpace"}, {"line": "simp only [\u2190 toTopologicalSpace_iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformContinuous_sInf_dom {f : \u03b1 \u2192 \u03b2} {u\u2081 : Set (UniformSpace \u03b1)} {u\u2082 : UniformSpace \u03b2}\n    {u : UniformSpace \u03b1} (h\u2081 : u \u2208 u\u2081) (hf : UniformContinuous[u, u\u2082] f) :\n    UniformContinuous[sInf u\u2081, u\u2082] f := by\n  delta UniformContinuous\n  rw [sInf_eq_iInf']\n  rw [iInf_uniformity]\n  exact tendsto_iInf' \u27e8u, h\u2081\u27e9 hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nu\u2081 : Set (UniformSpace \u03b1)\nu\u2082 : UniformSpace \u03b2\nu : UniformSpace \u03b1\nh\u2081 : u \u2208 u\u2081\nhf : UniformContinuous f\n\u22a2 UniformContinuous f"}, {"line": "delta UniformContinuous", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nu\u2081 : Set (UniformSpace \u03b1)\nu\u2082 : UniformSpace \u03b2\nu : UniformSpace \u03b1\nh\u2081 : u \u2208 u\u2081\nhf : UniformContinuous f\n\u22a2 Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (uniformity \u03b2)"}, {"line": "rw [sInf_eq_iInf']", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nu\u2081 : Set (UniformSpace \u03b1)\nu\u2082 : UniformSpace \u03b2\nu : UniformSpace \u03b1\nh\u2081 : u \u2208 u\u2081\nhf : UniformContinuous f\n\u22a2 Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (uniformity \u03b2)"}, {"line": "rw [iInf_uniformity]", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nu\u2081 : Set (UniformSpace \u03b1)\nu\u2082 : UniformSpace \u03b2\nu : UniformSpace \u03b1\nh\u2081 : u \u2208 u\u2081\nhf : UniformContinuous f\n\u22a2 Tendsto (fun x => (f x.1, f x.2)) (\u2a05 i, uniformity \u03b1) (uniformity \u03b2)"}, {"line": "exact tendsto_iInf' \u27e8u, h\u2081\u27e9 hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformContinuous_sInf_rng {f : \u03b1 \u2192 \u03b2} {u\u2081 : UniformSpace \u03b1} {u\u2082 : Set (UniformSpace \u03b2)} :\n    UniformContinuous[u\u2081, sInf u\u2082] f \u2194 \u2200 u \u2208 u\u2082, UniformContinuous[u\u2081, u] f := by\n  delta UniformContinuous\n  rw [sInf_eq_iInf']\n  rw [iInf_uniformity]\n  rw [tendsto_iInf]\n  rw [SetCoe.forall]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nu\u2081 : UniformSpace \u03b1\nu\u2082 : Set (UniformSpace \u03b2)\n\u22a2 UniformContinuous f \u2194 \u2200 u \u2208 u\u2082, UniformContinuous f"}, {"line": "delta UniformContinuous", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nu\u2081 : UniformSpace \u03b1\nu\u2082 : Set (UniformSpace \u03b2)\n\u22a2 Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (uniformity \u03b2) \u2194\n    \u2200 u \u2208 u\u2082, Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (uniformity \u03b2)"}, {"line": "rw [sInf_eq_iInf']", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nu\u2081 : UniformSpace \u03b1\nu\u2082 : Set (UniformSpace \u03b2)\n\u22a2 Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (uniformity \u03b2) \u2194\n    \u2200 u \u2208 u\u2082, Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (uniformity \u03b2)"}, {"line": "rw [iInf_uniformity]", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nu\u2081 : UniformSpace \u03b1\nu\u2082 : Set (UniformSpace \u03b2)\n\u22a2 Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (\u2a05 i, uniformity \u03b2) \u2194\n    \u2200 u \u2208 u\u2082, Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (uniformity \u03b2)"}, {"line": "rw [tendsto_iInf]", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nu\u2081 : UniformSpace \u03b1\nu\u2082 : Set (UniformSpace \u03b2)\n\u22a2 (\u2200 (i : \u2191u\u2082), Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (uniformity \u03b2)) \u2194\n    \u2200 u \u2208 u\u2082, Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (uniformity \u03b2)"}, {"line": "rw [SetCoe.forall]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformContinuous_iInf_dom {f : \u03b1 \u2192 \u03b2} {u\u2081 : \u03b9 \u2192 UniformSpace \u03b1} {u\u2082 : UniformSpace \u03b2}\n    {i : \u03b9} (hf : UniformContinuous[u\u2081 i, u\u2082] f) : UniformContinuous[iInf u\u2081, u\u2082] f := by\n  delta UniformContinuous\n  rw [iInf_uniformity]\n  exact tendsto_iInf' i hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nu\u2081 : \u03b9 \u2192 UniformSpace \u03b1\nu\u2082 : UniformSpace \u03b2\ni : \u03b9\nhf : UniformContinuous f\n\u22a2 UniformContinuous f"}, {"line": "delta UniformContinuous", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nu\u2081 : \u03b9 \u2192 UniformSpace \u03b1\nu\u2082 : UniformSpace \u03b2\ni : \u03b9\nhf : UniformContinuous f\n\u22a2 Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (uniformity \u03b2)"}, {"line": "rw [iInf_uniformity]", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nu\u2081 : \u03b9 \u2192 UniformSpace \u03b1\nu\u2082 : UniformSpace \u03b2\ni : \u03b9\nhf : UniformContinuous f\n\u22a2 Tendsto (fun x => (f x.1, f x.2)) (\u2a05 i, uniformity \u03b1) (uniformity \u03b2)"}, {"line": "exact tendsto_iInf' i hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformContinuous_iInf_rng {f : \u03b1 \u2192 \u03b2} {u\u2081 : UniformSpace \u03b1} {u\u2082 : \u03b9 \u2192 UniformSpace \u03b2} :\n    UniformContinuous[u\u2081, iInf u\u2082] f \u2194 \u2200 i, UniformContinuous[u\u2081, u\u2082 i] f := by\n  delta UniformContinuous\n  rw [iInf_uniformity]\n  rw [tendsto_iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nu\u2081 : UniformSpace \u03b1\nu\u2082 : \u03b9 \u2192 UniformSpace \u03b2\n\u22a2 UniformContinuous f \u2194 \u2200 (i : \u03b9), UniformContinuous f"}, {"line": "delta UniformContinuous", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nu\u2081 : UniformSpace \u03b1\nu\u2082 : \u03b9 \u2192 UniformSpace \u03b2\n\u22a2 Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (uniformity \u03b2) \u2194\n    \u2200 (i : \u03b9), Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (uniformity \u03b2)"}, {"line": "rw [iInf_uniformity]", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\nf : \u03b1 \u2192 \u03b2\nu\u2081 : UniformSpace \u03b1\nu\u2082 : \u03b9 \u2192 UniformSpace \u03b2\n\u22a2 Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (\u2a05 i, uniformity \u03b2) \u2194\n    \u2200 (i : \u03b9), Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (uniformity \u03b2)"}, {"line": "rw [tendsto_iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_uniformity_set_coe {s : Set \u03b1} [UniformSpace \u03b1] :\n    map (Prod.map (\u2191) (\u2191)) (\ud835\udce4 s) = \ud835\udce4 \u03b1 \u2293 \ud835\udcdf (s \u00d7\u02e2 s) := by\n  rw [uniformity_setCoe]\n  rw [map_comap]\n  rw [range_prodMap]\n  rw [Subtype.range_val]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity", "Additive Multiplicative"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d\u00b2 inst\u271d\u00b9 : UniformSpace \u03b1\ns : Set \u03b1\ninst\u271d : UniformSpace \u03b1\n\u22a2 map (Prod.map Subtype.val Subtype.val) (uniformity \u2191s) = uniformity \u03b1 \u2293 principal (s \u00d7\u02e2 s)"}, {"line": "rw [uniformity_setCoe]", "tactic_state": "\u03b1 : Type ua\ninst\u271d\u00b2 inst\u271d\u00b9 : UniformSpace \u03b1\ns : Set \u03b1\ninst\u271d : UniformSpace \u03b1\n\u22a2 map (Prod.map Subtype.val Subtype.val) (Filter.comap (Prod.map Subtype.val Subtype.val) (uniformity \u03b1)) =\n    uniformity \u03b1 \u2293 principal (s \u00d7\u02e2 s)"}, {"line": "rw [map_comap]", "tactic_state": "\u03b1 : Type ua\ninst\u271d\u00b2 inst\u271d\u00b9 : UniformSpace \u03b1\ns : Set \u03b1\ninst\u271d : UniformSpace \u03b1\n\u22a2 uniformity \u03b1 \u2293 principal (range (Prod.map Subtype.val Subtype.val)) = uniformity \u03b1 \u2293 principal (s \u00d7\u02e2 s)"}, {"line": "rw [range_prodMap]", "tactic_state": "\u03b1 : Type ua\ninst\u271d\u00b2 inst\u271d\u00b9 : UniformSpace \u03b1\ns : Set \u03b1\ninst\u271d : UniformSpace \u03b1\n\u22a2 uniformity \u03b1 \u2293 principal (range Subtype.val \u00d7\u02e2 range Subtype.val) = uniformity \u03b1 \u2293 principal (s \u00d7\u02e2 s)"}, {"line": "rw [Subtype.range_val]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UniformContinuousOn.continuousOn [UniformSpace \u03b1] [UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    (h : UniformContinuousOn f s) : ContinuousOn f s := by\n  rw [uniformContinuousOn_iff_restrict] at h\n  rw [continuousOn_iff_continuous_restrict]\n  exact h.continuous\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity", "Additive Multiplicative"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh : UniformContinuousOn f s\n\u22a2 ContinuousOn f s"}, {"line": "rw [uniformContinuousOn_iff_restrict] at h", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh : UniformContinuous (s.restrict f)\n\u22a2 ContinuousOn f s"}, {"line": "rw [continuousOn_iff_continuous_restrict]", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh : UniformContinuous (s.restrict f)\n\u22a2 Continuous (s.restrict f)"}, {"line": "exact h.continuous", "tactic_state": "No Goals!"}]}
{"declaration": "example [UniformSpace \u03b1] [UniformSpace \u03b2] :\n    (instTopologicalSpaceProd : TopologicalSpace (\u03b1 \u00d7 \u03b2)) = UniformSpace.toTopologicalSpace := by\n  with_reducible_and_instances rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity", "Additive Multiplicative", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b3 : Type uc\n\u03b4 : Type ud\n\u03b9 : Sort u_1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\n\u22a2 instTopologicalSpaceProd = toTopologicalSpace"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformity_prod_eq_comap_prod [UniformSpace \u03b1] [UniformSpace \u03b2] :\n    \ud835\udce4 (\u03b1 \u00d7 \u03b2) =\n      comap (fun p : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b1 \u00d7 \u03b2 => ((p.1.1, p.2.1), (p.1.2, p.2.2))) (\ud835\udce4 \u03b1 \u00d7\u02e2 \ud835\udce4 \u03b2) := by\n  simp_rw [uniformity_prod, prod_eq_inf, Filter.comap_inf, Filter.comap_comap, Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity", "Additive Multiplicative", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\n\u22a2 uniformity (\u03b1 \u00d7 \u03b2) = Filter.comap (fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) (uniformity \u03b1 \u00d7\u02e2 uniformity \u03b2)"}, {"line": "simp_rw [uniformity_prod, prod_eq_inf, Filter.comap_inf, Filter.comap_comap, Function.comp_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformity_prod_eq_prod [UniformSpace \u03b1] [UniformSpace \u03b2] :\n    \ud835\udce4 (\u03b1 \u00d7 \u03b2) = map (fun p : (\u03b1 \u00d7 \u03b1) \u00d7 \u03b2 \u00d7 \u03b2 => ((p.1.1, p.2.1), (p.1.2, p.2.2))) (\ud835\udce4 \u03b1 \u00d7\u02e2 \ud835\udce4 \u03b2) := by\n  rw [map_swap4_eq_comap]\n  rw [uniformity_prod_eq_comap_prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity", "Additive Multiplicative", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\n\u22a2 uniformity (\u03b1 \u00d7 \u03b2) = map (fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) (uniformity \u03b1 \u00d7\u02e2 uniformity \u03b2)"}, {"line": "rw [map_swap4_eq_comap]", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\n\u22a2 uniformity (\u03b1 \u00d7 \u03b2) = Filter.comap (fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) (uniformity \u03b1 \u00d7\u02e2 uniformity \u03b2)"}, {"line": "rw [uniformity_prod_eq_comap_prod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_uniformity_of_uniformContinuous_invariant [UniformSpace \u03b1] [UniformSpace \u03b2]\n    {s : Set (\u03b2 \u00d7 \u03b2)} {f : \u03b1 \u2192 \u03b1 \u2192 \u03b2} (hf : UniformContinuous fun p : \u03b1 \u00d7 \u03b1 => f p.1 p.2)\n    (hs : s \u2208 \ud835\udce4 \u03b2) : \u2203 u \u2208 \ud835\udce4 \u03b1, \u2200 a b c, (a, b) \u2208 u \u2192 (f a c, f b c) \u2208 s := by\n  rw [UniformContinuous] at hf\n  rw [uniformity_prod_eq_prod] at hf\n  rw [tendsto_map'_iff] at hf\n  rcases mem_prod_iff.1 (mem_map.1 <| hf hs) with \u27e8u, hu, v, hv, huvt\u27e9\n  exact \u27e8u, hu, fun a b c hab => @huvt ((_, _), (_, _)) \u27e8hab, refl_mem_uniformity hv\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity", "Additive Multiplicative", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\ns : Set (\u03b2 \u00d7 \u03b2)\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b2\nhf : UniformContinuous fun p => f p.1 p.2\nhs : s \u2208 uniformity \u03b2\n\u22a2 \u2203 u \u2208 uniformity \u03b1, \u2200 (a b c : \u03b1), (a, b) \u2208 u \u2192 (f a c, f b c) \u2208 s"}, {"line": "rw [UniformContinuous] at hf", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\ns : Set (\u03b2 \u00d7 \u03b2)\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b2\nhf : Tendsto (fun x => (f x.1.1 x.1.2, f x.2.1 x.2.2)) (uniformity (\u03b1 \u00d7 \u03b1)) (uniformity \u03b2)\nhs : s \u2208 uniformity \u03b2\n\u22a2 \u2203 u \u2208 uniformity \u03b1, \u2200 (a b c : \u03b1), (a, b) \u2208 u \u2192 (f a c, f b c) \u2208 s"}, {"line": "rw [uniformity_prod_eq_prod] at hf", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\ns : Set (\u03b2 \u00d7 \u03b2)\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b2\nhf :\n  Tendsto (fun x => (f x.1.1 x.1.2, f x.2.1 x.2.2))\n    (map (fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) (uniformity \u03b1 \u00d7\u02e2 uniformity \u03b1)) (uniformity \u03b2)\nhs : s \u2208 uniformity \u03b2\n\u22a2 \u2203 u \u2208 uniformity \u03b1, \u2200 (a b c : \u03b1), (a, b) \u2208 u \u2192 (f a c, f b c) \u2208 s"}, {"line": "rw [tendsto_map'_iff] at hf", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\ns : Set (\u03b2 \u00d7 \u03b2)\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b2\nhf :\n  Tendsto ((fun x => (f x.1.1 x.1.2, f x.2.1 x.2.2)) \u2218 fun p => ((p.1.1, p.2.1), p.1.2, p.2.2))\n    (uniformity \u03b1 \u00d7\u02e2 uniformity \u03b1) (uniformity \u03b2)\nhs : s \u2208 uniformity \u03b2\n\u22a2 \u2203 u \u2208 uniformity \u03b1, \u2200 (a b c : \u03b1), (a, b) \u2208 u \u2192 (f a c, f b c) \u2208 s"}, {"line": "rcases mem_prod_iff.1 (mem_map.1 <| hf hs) with \u27e8u, hu, v, hv, huvt\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\ns : Set (\u03b2 \u00d7 \u03b2)\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b2\nhf :\n  Tendsto ((fun x => (f x.1.1 x.1.2, f x.2.1 x.2.2)) \u2218 fun p => ((p.1.1, p.2.1), p.1.2, p.2.2))\n    (uniformity \u03b1 \u00d7\u02e2 uniformity \u03b1) (uniformity \u03b2)\nhs : s \u2208 uniformity \u03b2\nu : Set (\u03b1 \u00d7 \u03b1)\nhu : u \u2208 uniformity \u03b1\nv : Set (\u03b1 \u00d7 \u03b1)\nhv : v \u2208 uniformity \u03b1\nhuvt : u \u00d7\u02e2 v \u2286 ((fun x => (f x.1.1 x.1.2, f x.2.1 x.2.2)) \u2218 fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) \u207b\u00b9' s\n\u22a2 \u2203 u \u2208 uniformity \u03b1, \u2200 (a b c : \u03b1), (a, b) \u2208 u \u2192 (f a c, f b c) \u2208 s"}, {"line": "exact \u27e8u, hu, fun a b c hab => @huvt ((_, _), (_, _)) \u27e8hab, refl_mem_uniformity hv\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UniformContinuous.prodMk {f\u2081 : \u03b1 \u2192 \u03b2} {f\u2082 : \u03b1 \u2192 \u03b3} (h\u2081 : UniformContinuous f\u2081)\n    (h\u2082 : UniformContinuous f\u2082) : UniformContinuous fun a => (f\u2081 a, f\u2082 a) := by\n  rw [UniformContinuous]\n  rw [uniformity_prod]\n  exact tendsto_inf.2 \u27e8tendsto_comap_iff.2 h\u2081, tendsto_comap_iff.2 h\u2082\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity", "Additive Multiplicative", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)", "[UniformSpace \u03b1]", "[UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b3 : Type uc\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b2\ninst\u271d : UniformSpace \u03b3\nf\u2081 : \u03b1 \u2192 \u03b2\nf\u2082 : \u03b1 \u2192 \u03b3\nh\u2081 : UniformContinuous f\u2081\nh\u2082 : UniformContinuous f\u2082\n\u22a2 UniformContinuous fun a => (f\u2081 a, f\u2082 a)"}, {"line": "rw [UniformContinuous]", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b3 : Type uc\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b2\ninst\u271d : UniformSpace \u03b3\nf\u2081 : \u03b1 \u2192 \u03b2\nf\u2082 : \u03b1 \u2192 \u03b3\nh\u2081 : UniformContinuous f\u2081\nh\u2082 : UniformContinuous f\u2082\n\u22a2 Tendsto (fun x => ((f\u2081 x.1, f\u2082 x.1), f\u2081 x.2, f\u2082 x.2)) (uniformity \u03b1) (uniformity (\u03b2 \u00d7 \u03b3))"}, {"line": "rw [uniformity_prod]", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b3 : Type uc\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b2\ninst\u271d : UniformSpace \u03b3\nf\u2081 : \u03b1 \u2192 \u03b2\nf\u2082 : \u03b1 \u2192 \u03b3\nh\u2081 : UniformContinuous f\u2081\nh\u2082 : UniformContinuous f\u2082\n\u22a2 Tendsto (fun x => ((f\u2081 x.1, f\u2082 x.1), f\u2081 x.2, f\u2082 x.2)) (uniformity \u03b1)\n    (Filter.comap (fun p => (p.1.1, p.2.1)) (uniformity \u03b2) \u2293 Filter.comap (fun p => (p.1.2, p.2.2)) (uniformity \u03b3))"}, {"line": "exact tendsto_inf.2 \u27e8tendsto_comap_iff.2 h\u2081, tendsto_comap_iff.2 h\u2082\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformContinuous_inf_dom_left\u2082 {\u03b1 \u03b2 \u03b3} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {ua1 ua2 : UniformSpace \u03b1}\n    {ub1 ub2 : UniformSpace \u03b2} {uc1 : UniformSpace \u03b3}\n    (h : by haveI := ua1; haveI := ub1; exact UniformContinuous fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2) : by\n      haveI := ua1 \u2293 ua2; haveI := ub1 \u2293 ub2\n      exact UniformContinuous fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2 := by\n  -- proof essentially copied from `continuous_inf_dom_left\u2082`\n  have ha := @UniformContinuous.inf_dom_left _ _ id ua1 ua2 ua1 (@uniformContinuous_id _ (id _))\n  have hb := @UniformContinuous.inf_dom_left _ _ id ub1 ub2 ub1 (@uniformContinuous_id _ (id _))\n  have h_unif_cont_id :=\n    @UniformContinuous.prodMap _ _ _ _ (ua1 \u2293 ua2) (ub1 \u2293 ub2) ua1 ub1 _ _ ha hb\n  exact @UniformContinuous.comp _ _ _ (id _) (id _) _ _ _ h h_unif_cont_id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity", "Additive Multiplicative", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)", "[UniformSpace \u03b1]", "[UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nua1 ua2 : UniformSpace \u03b1\nub1 ub2 : UniformSpace \u03b2\nuc1 : UniformSpace \u03b3\nh : UniformContinuous fun p => f p.1 p.2\n\u22a2 UniformContinuous fun p => f p.1 p.2"}, {"line": "have ha := @UniformContinuous.inf_dom_left _ _ id ua1 ua2 ua1 (@uniformContinuous_id _ (id _))", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nua1 ua2 : UniformSpace \u03b1\nub1 ub2 : UniformSpace \u03b2\nuc1 : UniformSpace \u03b3\nh : UniformContinuous fun p => f p.1 p.2\nha : UniformContinuous id\n\u22a2 UniformContinuous fun p => f p.1 p.2"}, {"line": "have hb := @UniformContinuous.inf_dom_left _ _ id ub1 ub2 ub1 (@uniformContinuous_id _ (id _))", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nua1 ua2 : UniformSpace \u03b1\nub1 ub2 : UniformSpace \u03b2\nuc1 : UniformSpace \u03b3\nh : UniformContinuous fun p => f p.1 p.2\nha : UniformContinuous id\nhb : UniformContinuous id\n\u22a2 UniformContinuous fun p => f p.1 p.2"}, {"line": "have h_unif_cont_id :=\n    @UniformContinuous.prodMap _ _ _ _ (ua1 \u2293 ua2) (ub1 \u2293 ub2) ua1 ub1 _ _ ha hb", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nua1 ua2 : UniformSpace \u03b1\nub1 ub2 : UniformSpace \u03b2\nuc1 : UniformSpace \u03b3\nh : UniformContinuous fun p => f p.1 p.2\nha : UniformContinuous id\nhb : UniformContinuous id\nh_unif_cont_id : UniformContinuous (Prod.map id id)\n\u22a2 UniformContinuous fun p => f p.1 p.2"}, {"line": "exact @UniformContinuous.comp _ _ _ (id _) (id _) _ _ _ h h_unif_cont_id", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformContinuous_inf_dom_right\u2082 {\u03b1 \u03b2 \u03b3} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {ua1 ua2 : UniformSpace \u03b1}\n    {ub1 ub2 : UniformSpace \u03b2} {uc1 : UniformSpace \u03b3}\n    (h : by haveI := ua2; haveI := ub2; exact UniformContinuous fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2) : by\n      haveI := ua1 \u2293 ua2; haveI := ub1 \u2293 ub2\n      exact UniformContinuous fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2 := by\n  -- proof essentially copied from `continuous_inf_dom_right\u2082`\n  have ha := @UniformContinuous.inf_dom_right _ _ id ua1 ua2 ua2 (@uniformContinuous_id _ (id _))\n  have hb := @UniformContinuous.inf_dom_right _ _ id ub1 ub2 ub2 (@uniformContinuous_id _ (id _))\n  have h_unif_cont_id :=\n    @UniformContinuous.prodMap _ _ _ _ (ua1 \u2293 ua2) (ub1 \u2293 ub2) ua2 ub2 _ _ ha hb\n  exact @UniformContinuous.comp _ _ _ (id _) (id _) _ _ _ h h_unif_cont_id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity", "Additive Multiplicative", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)", "[UniformSpace \u03b1]", "[UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nua1 ua2 : UniformSpace \u03b1\nub1 ub2 : UniformSpace \u03b2\nuc1 : UniformSpace \u03b3\nh : UniformContinuous fun p => f p.1 p.2\n\u22a2 UniformContinuous fun p => f p.1 p.2"}, {"line": "have ha := @UniformContinuous.inf_dom_right _ _ id ua1 ua2 ua2 (@uniformContinuous_id _ (id _))", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nua1 ua2 : UniformSpace \u03b1\nub1 ub2 : UniformSpace \u03b2\nuc1 : UniformSpace \u03b3\nh : UniformContinuous fun p => f p.1 p.2\nha : UniformContinuous id\n\u22a2 UniformContinuous fun p => f p.1 p.2"}, {"line": "have hb := @UniformContinuous.inf_dom_right _ _ id ub1 ub2 ub2 (@uniformContinuous_id _ (id _))", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nua1 ua2 : UniformSpace \u03b1\nub1 ub2 : UniformSpace \u03b2\nuc1 : UniformSpace \u03b3\nh : UniformContinuous fun p => f p.1 p.2\nha : UniformContinuous id\nhb : UniformContinuous id\n\u22a2 UniformContinuous fun p => f p.1 p.2"}, {"line": "have h_unif_cont_id :=\n    @UniformContinuous.prodMap _ _ _ _ (ua1 \u2293 ua2) (ub1 \u2293 ub2) ua2 ub2 _ _ ha hb", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nua1 ua2 : UniformSpace \u03b1\nub1 ub2 : UniformSpace \u03b2\nuc1 : UniformSpace \u03b3\nh : UniformContinuous fun p => f p.1 p.2\nha : UniformContinuous id\nhb : UniformContinuous id\nh_unif_cont_id : UniformContinuous (Prod.map id id)\n\u22a2 UniformContinuous fun p => f p.1 p.2"}, {"line": "exact @UniformContinuous.comp _ _ _ (id _) (id _) _ _ _ h h_unif_cont_id", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformContinuous_sInf_dom\u2082 {\u03b1 \u03b2 \u03b3} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {uas : Set (UniformSpace \u03b1)}\n    {ubs : Set (UniformSpace \u03b2)} {ua : UniformSpace \u03b1} {ub : UniformSpace \u03b2} {uc : UniformSpace \u03b3}\n    (ha : ua \u2208 uas) (hb : ub \u2208 ubs) (hf : UniformContinuous fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2) : by\n      haveI := sInf uas; haveI := sInf ubs\n      exact @UniformContinuous _ _ _ uc fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2 := by\n  -- proof essentially copied from `continuous_sInf_dom`\n  let _ : UniformSpace (\u03b1 \u00d7 \u03b2) := instUniformSpaceProd\n  have ha := uniformContinuous_sInf_dom ha uniformContinuous_id\n  have hb := uniformContinuous_sInf_dom hb uniformContinuous_id\n  have h_unif_cont_id := @UniformContinuous.prodMap _ _ _ _ (sInf uas) (sInf ubs) ua ub _ _ ha hb\n  exact @UniformContinuous.comp _ _ _ (id _) (id _) _ _ _ hf h_unif_cont_id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity", "Additive Multiplicative", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)", "[UniformSpace \u03b1]", "[UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nuas : Set (UniformSpace \u03b1)\nubs : Set (UniformSpace \u03b2)\nua : UniformSpace \u03b1\nub : UniformSpace \u03b2\nuc : UniformSpace \u03b3\nha : ua \u2208 uas\nhb : ub \u2208 ubs\nhf : UniformContinuous fun p => f p.1 p.2\n\u22a2 UniformContinuous fun p => f p.1 p.2"}, {"line": "let _ : UniformSpace (\u03b1 \u00d7 \u03b2) := instUniformSpaceProd", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nuas : Set (UniformSpace \u03b1)\nubs : Set (UniformSpace \u03b2)\nua : UniformSpace \u03b1\nub : UniformSpace \u03b2\nuc : UniformSpace \u03b3\nha : ua \u2208 uas\nhb : ub \u2208 ubs\nhf : UniformContinuous fun p => f p.1 p.2\nx\u271d : UniformSpace (\u03b1 \u00d7 \u03b2) := sorry\n\u22a2 UniformContinuous fun p => f p.1 p.2"}, {"line": "have ha := uniformContinuous_sInf_dom ha uniformContinuous_id", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nuas : Set (UniformSpace \u03b1)\nubs : Set (UniformSpace \u03b2)\nua : UniformSpace \u03b1\nub : UniformSpace \u03b2\nuc : UniformSpace \u03b3\nha\u271d : ua \u2208 uas\nhb : ub \u2208 ubs\nhf : UniformContinuous fun p => f p.1 p.2\nx\u271d : UniformSpace (\u03b1 \u00d7 \u03b2) := sorry\nha : UniformContinuous id\n\u22a2 UniformContinuous fun p => f p.1 p.2"}, {"line": "have hb := uniformContinuous_sInf_dom hb uniformContinuous_id", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nuas : Set (UniformSpace \u03b1)\nubs : Set (UniformSpace \u03b2)\nua : UniformSpace \u03b1\nub : UniformSpace \u03b2\nuc : UniformSpace \u03b3\nha\u271d : ua \u2208 uas\nhb\u271d : ub \u2208 ubs\nhf : UniformContinuous fun p => f p.1 p.2\nx\u271d : UniformSpace (\u03b1 \u00d7 \u03b2) := sorry\nha : UniformContinuous id\nhb : UniformContinuous id\n\u22a2 UniformContinuous fun p => f p.1 p.2"}, {"line": "have h_unif_cont_id := @UniformContinuous.prodMap _ _ _ _ (sInf uas) (sInf ubs) ua ub _ _ ha hb", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nuas : Set (UniformSpace \u03b1)\nubs : Set (UniformSpace \u03b2)\nua : UniformSpace \u03b1\nub : UniformSpace \u03b2\nuc : UniformSpace \u03b3\nha\u271d : ua \u2208 uas\nhb\u271d : ub \u2208 ubs\nhf : UniformContinuous fun p => f p.1 p.2\nx\u271d : UniformSpace (\u03b1 \u00d7 \u03b2) := sorry\nha : UniformContinuous id\nhb : UniformContinuous id\nh_unif_cont_id : UniformContinuous (Prod.map id id)\n\u22a2 UniformContinuous fun p => f p.1 p.2"}, {"line": "exact @UniformContinuous.comp _ _ _ (id _) (id _) _ _ _ hf h_unif_cont_id", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformContinuous\u2082_curry (f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) :\n    UniformContinuous\u2082 (Function.curry f) \u2194 UniformContinuous f := by\n  rw [UniformContinuous\u2082]\n  rw [uncurry_curry]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity", "Additive Multiplicative", "UniformSpace", "UniformSpace Function"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)", "[UniformSpace \u03b1]", "[UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3]", "{\u03b4' : Type*} [UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3] [UniformSpace \u03b4]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b3 : Type uc\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : UniformSpace \u03b2\ninst\u271d\u00b3 : UniformSpace \u03b3\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b2\ninst\u271d : UniformSpace \u03b3\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b3\n\u22a2 UniformContinuous\u2082 (Function.curry f) \u2194 UniformContinuous f"}, {"line": "rw [UniformContinuous\u2082]", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b3 : Type uc\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : UniformSpace \u03b2\ninst\u271d\u00b3 : UniformSpace \u03b3\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b2\ninst\u271d : UniformSpace \u03b3\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b3\n\u22a2 UniformContinuous (uncurry (Function.curry f)) \u2194 UniformContinuous f"}, {"line": "rw [uncurry_curry]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousOn_iff'_right [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} :\n    ContinuousOn f s \u2194 \u2200 b \u2208 s, Tendsto (fun x => (f b, f x)) (\ud835\udcdd[s] b) (\ud835\udce4 \u03b1) := by\n  simp [ContinuousOn, continuousWithinAt_iff'_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity", "Additive Multiplicative", "UniformSpace", "UniformSpace Function", "Sum"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)", "[UniformSpace \u03b1]", "[UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3]", "{\u03b4' : Type*} [UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3] [UniformSpace \u03b4]", "[UniformSpace \u03b1] [UniformSpace \u03b2]", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : UniformSpace \u03b1\ninst\u271d\u2076 : UniformSpace \u03b2\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : UniformSpace \u03b2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\n\u22a2 ContinuousOn f s \u2194 \u2200 b \u2208 s, Tendsto (fun x => (f b, f x)) (nhdsWithin b s) (_root_.uniformity \u03b1)"}, {"line": "simp [ContinuousOn, continuousWithinAt_iff'_right]", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : UniformSpace \u03b1\ninst\u271d\u2076 : UniformSpace \u03b2\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : UniformSpace \u03b2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\n\u22a2 (\u2200 x \u2208 s, ContinuousWithinAt f s x) \u2194 \u2200 b \u2208 s, Tendsto (fun x => (f b, f x)) (nhdsWithin b s) (_root_.uniformity \u03b1)"}]}
{"declaration": "theorem continuousOn_iff'_left [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} :\n    ContinuousOn f s \u2194 \u2200 b \u2208 s, Tendsto (fun x => (f x, f b)) (\ud835\udcdd[s] b) (\ud835\udce4 \u03b1) := by\n  simp [ContinuousOn, continuousWithinAt_iff'_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity", "Additive Multiplicative", "UniformSpace", "UniformSpace Function", "Sum"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)", "[UniformSpace \u03b1]", "[UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3]", "{\u03b4' : Type*} [UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3] [UniformSpace \u03b4]", "[UniformSpace \u03b1] [UniformSpace \u03b2]", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : UniformSpace \u03b1\ninst\u271d\u2076 : UniformSpace \u03b2\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : UniformSpace \u03b2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\n\u22a2 ContinuousOn f s \u2194 \u2200 b \u2208 s, Tendsto (fun x => (f x, f b)) (nhdsWithin b s) (_root_.uniformity \u03b1)"}, {"line": "simp [ContinuousOn, continuousWithinAt_iff'_left]", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : UniformSpace \u03b1\ninst\u271d\u2076 : UniformSpace \u03b2\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : UniformSpace \u03b2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\n\u22a2 (\u2200 x \u2208 s, ContinuousWithinAt f s x) \u2194 \u2200 b \u2208 s, Tendsto (fun x => (f x, f b)) (nhdsWithin b s) (_root_.uniformity \u03b1)"}]}
{"declaration": "lemma exists_is_open_mem_uniformity_of_forall_mem_eq\n    [TopologicalSpace \u03b2] {r : Set (\u03b1 \u00d7 \u03b1)} {s : Set \u03b2}\n    {f g : \u03b2 \u2192 \u03b1} (hf : \u2200 x \u2208 s, ContinuousAt f x) (hg : \u2200 x \u2208 s, ContinuousAt g x)\n    (hfg : s.EqOn f g) (hr : r \u2208 \ud835\udce4 \u03b1) :\n    \u2203 t, IsOpen t \u2227 s \u2286 t \u2227 \u2200 x \u2208 t, (f x, g x) \u2208 r := by\n  have A : \u2200 x \u2208 s, \u2203 t, IsOpen t \u2227 x \u2208 t \u2227 \u2200 z \u2208 t, (f z, g z) \u2208 r := by\n    intro x hx\n    obtain \u27e8t, ht, htsymm, htr\u27e9 := comp_symm_mem_uniformity_sets hr\n    have A : {z | (f x, f z) \u2208 t} \u2208 \ud835\udcdd x := (hf x hx).preimage_mem_nhds (mem_nhds_left (f x) ht)\n    have B : {z | (g x, g z) \u2208 t} \u2208 \ud835\udcdd x := (hg x hx).preimage_mem_nhds (mem_nhds_left (g x) ht)\n    rcases _root_.mem_nhds_iff.1 (inter_mem A B) with \u27e8u, hu, u_open, xu\u27e9\n    refine \u27e8u, u_open, xu, fun y hy \u21a6 ?_\u27e9\n    have I1 : (f y, f x) \u2208 t := (htsymm.mk_mem_comm).2 (hu hy).1\n    have I2 : (g x, g y) \u2208 t := (hu hy).2\n    rw [hfg hx] at I1\n    exact htr (prodMk_mem_compRel I1 I2)\n  choose! t t_open xt ht using A\n  refine \u27e8\u22c3 x \u2208 s, t x, isOpen_biUnion t_open, fun x hx \u21a6 mem_biUnion hx (xt x hx), ?_\u27e9\n  rintro x hx\n  simp only [mem_iUnion] at hx\n  simp only [exists_prop] at hx\n  rcases hx with \u27e8y, ys, hy\u27e9\n  exact ht y ys x hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Basic.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity", "Additive Multiplicative", "UniformSpace", "UniformSpace Function", "Sum"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)", "[UniformSpace \u03b1]", "[UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3]", "{\u03b4' : Type*} [UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3] [UniformSpace \u03b4]", "[UniformSpace \u03b1] [UniformSpace \u03b2]", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : UniformSpace \u03b1\ninst\u271d\u2076 : UniformSpace \u03b2\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : UniformSpace \u03b2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nr : Set (\u03b1 \u00d7 \u03b1)\ns : Set \u03b2\nf g : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s, ContinuousAt f x\nhg : \u2200 x \u2208 s, ContinuousAt g x\nhfg : EqOn f g s\nhr : r \u2208 _root_.uniformity \u03b1\n\u22a2 \u2203 t, IsOpen t \u2227 s \u2286 t \u2227 \u2200 x \u2208 t, (f x, g x) \u2208 r"}, {"line": "have A : \u2200 x \u2208 s, \u2203 t, IsOpen t \u2227 x \u2208 t \u2227 \u2200 z \u2208 t, (f z, g z) \u2208 r := sorry", "tactic_state": "case refine_2\n\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : UniformSpace \u03b1\ninst\u271d\u2076 : UniformSpace \u03b2\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : UniformSpace \u03b2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nr : Set (\u03b1 \u00d7 \u03b1)\ns : Set \u03b2\nf g : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s, ContinuousAt f x\nhg : \u2200 x \u2208 s, ContinuousAt g x\nhfg : EqOn f g s\nhr : r \u2208 _root_.uniformity \u03b1\nA : \u2200 x \u2208 s, \u2203 t, IsOpen t \u2227 x \u2208 t \u2227 \u2200 z \u2208 t, (f z, g z) \u2208 r\n\u22a2 \u2203 t, IsOpen t \u2227 s \u2286 t \u2227 \u2200 x \u2208 t, (f x, g x) \u2208 r\n---\ncase refine_1\n\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : UniformSpace \u03b1\ninst\u271d\u2076 : UniformSpace \u03b2\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : UniformSpace \u03b2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nr : Set (\u03b1 \u00d7 \u03b1)\ns : Set \u03b2\nf g : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s, ContinuousAt f x\nhg : \u2200 x \u2208 s, ContinuousAt g x\nhfg : EqOn f g s\nhr : r \u2208 _root_.uniformity \u03b1\n\u22a2 \u03b2 \u2192 Set \u03b2 \u2192 TopologicalSpace \u03b2"}, {"line": "choose! t t_open xt ht using A", "tactic_state": "case refine_2\n\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : UniformSpace \u03b1\ninst\u271d\u2076 : UniformSpace \u03b2\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : UniformSpace \u03b2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nr : Set (\u03b1 \u00d7 \u03b1)\ns : Set \u03b2\nf g : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s, ContinuousAt f x\nhg : \u2200 x \u2208 s, ContinuousAt g x\nhfg : EqOn f g s\nhr : r \u2208 _root_.uniformity \u03b1\nt : \u03b2 \u2192 Set \u03b2\nt_open : \u2200 x \u2208 s, IsOpen (t x)\nxt : \u2200 x \u2208 s, x \u2208 t x\nht : \u2200 x \u2208 s, \u2200 z \u2208 t x, (f z, g z) \u2208 r\n\u22a2 \u2203 t, IsOpen t \u2227 s \u2286 t \u2227 \u2200 x \u2208 t, (f x, g x) \u2208 r\n---\ncase refine_1\n\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : UniformSpace \u03b1\ninst\u271d\u2076 : UniformSpace \u03b2\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : UniformSpace \u03b2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nr : Set (\u03b1 \u00d7 \u03b1)\ns : Set \u03b2\nf g : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s, ContinuousAt f x\nhg : \u2200 x \u2208 s, ContinuousAt g x\nhfg : EqOn f g s\nhr : r \u2208 _root_.uniformity \u03b1\n\u22a2 \u03b2 \u2192 Set \u03b2 \u2192 TopologicalSpace \u03b2"}, {"line": "refine \u27e8\u22c3 x \u2208 s, t x, isOpen_biUnion t_open, fun x hx \u21a6 mem_biUnion hx (xt x hx), ?_\u27e9", "tactic_state": "case refine_2\n\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : UniformSpace \u03b1\ninst\u271d\u2076 : UniformSpace \u03b2\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : UniformSpace \u03b2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nr : Set (\u03b1 \u00d7 \u03b1)\ns : Set \u03b2\nf g : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s, ContinuousAt f x\nhg : \u2200 x \u2208 s, ContinuousAt g x\nhfg : EqOn f g s\nhr : r \u2208 _root_.uniformity \u03b1\nt : \u03b2 \u2192 Set \u03b2\nt_open : \u2200 x \u2208 s, IsOpen (t x)\nxt : \u2200 x \u2208 s, x \u2208 t x\nht : \u2200 x \u2208 s, \u2200 z \u2208 t x, (f z, g z) \u2208 r\n\u22a2 \u2200 x \u2208 \u22c3 x \u2208 s, t x, (f x, g x) \u2208 r"}, {"line": "rintro x hx", "tactic_state": "case refine_2\n\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : UniformSpace \u03b1\ninst\u271d\u2076 : UniformSpace \u03b2\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : UniformSpace \u03b2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nr : Set (\u03b1 \u00d7 \u03b1)\ns : Set \u03b2\nf g : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s, ContinuousAt f x\nhg : \u2200 x \u2208 s, ContinuousAt g x\nhfg : EqOn f g s\nhr : r \u2208 _root_.uniformity \u03b1\nt : \u03b2 \u2192 Set \u03b2\nt_open : \u2200 x \u2208 s, IsOpen (t x)\nxt : \u2200 x \u2208 s, x \u2208 t x\nht : \u2200 x \u2208 s, \u2200 z \u2208 t x, (f z, g z) \u2208 r\nx : \u03b2\nhx : x \u2208 \u22c3 x \u2208 s, t x\n\u22a2 (f x, g x) \u2208 r"}, {"line": "simp only [mem_iUnion] at hx", "tactic_state": "case refine_2\n\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : UniformSpace \u03b1\ninst\u271d\u2076 : UniformSpace \u03b2\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : UniformSpace \u03b2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nr : Set (\u03b1 \u00d7 \u03b1)\ns : Set \u03b2\nf g : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s, ContinuousAt f x\nhg : \u2200 x \u2208 s, ContinuousAt g x\nhfg : EqOn f g s\nhr : r \u2208 _root_.uniformity \u03b1\nt : \u03b2 \u2192 Set \u03b2\nt_open : \u2200 x \u2208 s, IsOpen (t x)\nxt : \u2200 x \u2208 s, x \u2208 t x\nht : \u2200 x \u2208 s, \u2200 z \u2208 t x, (f z, g z) \u2208 r\nx : \u03b2\nhx : \u2203 i, \u2203 (_ : i \u2208 s), x \u2208 t i\n\u22a2 (f x, g x) \u2208 r"}, {"line": "simp only [exists_prop] at hx", "tactic_state": "case refine_2\n\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : UniformSpace \u03b1\ninst\u271d\u2076 : UniformSpace \u03b2\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : UniformSpace \u03b2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nr : Set (\u03b1 \u00d7 \u03b1)\ns : Set \u03b2\nf g : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s, ContinuousAt f x\nhg : \u2200 x \u2208 s, ContinuousAt g x\nhfg : EqOn f g s\nhr : r \u2208 _root_.uniformity \u03b1\nt : \u03b2 \u2192 Set \u03b2\nt_open : \u2200 x \u2208 s, IsOpen (t x)\nxt : \u2200 x \u2208 s, x \u2208 t x\nht : \u2200 x \u2208 s, \u2200 z \u2208 t x, (f z, g z) \u2208 r\nx : \u03b2\nhx : \u2203 i \u2208 s, x \u2208 t i\n\u22a2 (f x, g x) \u2208 r"}, {"line": "rcases hx with \u27e8y, ys, hy\u27e9", "tactic_state": "case refine_2.intro.intro\n\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : UniformSpace \u03b1\ninst\u271d\u2076 : UniformSpace \u03b2\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : UniformSpace \u03b2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nr : Set (\u03b1 \u00d7 \u03b1)\ns : Set \u03b2\nf g : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s, ContinuousAt f x\nhg : \u2200 x \u2208 s, ContinuousAt g x\nhfg : EqOn f g s\nhr : r \u2208 _root_.uniformity \u03b1\nt : \u03b2 \u2192 Set \u03b2\nt_open : \u2200 x \u2208 s, IsOpen (t x)\nxt : \u2200 x \u2208 s, x \u2208 t x\nht : \u2200 x \u2208 s, \u2200 z \u2208 t x, (f z, g z) \u2208 r\nx y : \u03b2\nys : y \u2208 s\nhy : x \u2208 t y\n\u22a2 (f x, g x) \u2208 r"}, {"line": "exact ht y ys x hy", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cauchy_iff_le {l : Filter \u03b1} [hl : l.NeBot] :\n    Cauchy l \u2194 l \u00d7\u02e2 l \u2264 \ud835\udce4 \u03b1 := by\n  simp only [Cauchy]\n  simp only [hl]\n  simp only [true_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nl : Filter \u03b1\nhl : l.NeBot\n\u22a2 Cauchy l \u2194 l \u00d7\u02e2 l \u2264 uniformity \u03b1"}, {"line": "simp only [Cauchy]", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nl : Filter \u03b1\nhl : l.NeBot\n\u22a2 l.NeBot \u2227 l \u00d7\u02e2 l \u2264 uniformity \u03b1 \u2194 l \u00d7\u02e2 l \u2264 uniformity \u03b1"}, {"line": "simp only [hl]", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nl : Filter \u03b1\nhl : l.NeBot\n\u22a2 True \u2227 l \u00d7\u02e2 l \u2264 uniformity \u03b1 \u2194 l \u00d7\u02e2 l \u2264 uniformity \u03b1"}, {"line": "simp only [true_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Cauchy.ultrafilter_of {l : Filter \u03b1} (h : Cauchy l) :\n    Cauchy (@Ultrafilter.of _ l h.1 : Filter \u03b1) := by\n  haveI := h.1\n  have := Ultrafilter.of_le l\n  exact \u27e8Ultrafilter.neBot _, (Filter.prod_mono this this).trans h.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nl : Filter \u03b1\nh : Cauchy l\n\u22a2 Cauchy \u2191(Ultrafilter.of l)"}, {"line": "haveI := h.1", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nl : Filter \u03b1\nh : Cauchy l\nthis : l.NeBot\n\u22a2 Cauchy \u2191(Ultrafilter.of l)"}, {"line": "have := Ultrafilter.of_le l", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nl : Filter \u03b1\nh : Cauchy l\nthis\u271d : l.NeBot\nthis : \u2191(Ultrafilter.of l) \u2264 l\n\u22a2 Cauchy \u2191(Ultrafilter.of l)"}, {"line": "exact \u27e8Ultrafilter.neBot _, (Filter.prod_mono this this).trans h.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cauchy_map_iff {l : Filter \u03b2} {f : \u03b2 \u2192 \u03b1} :\n    Cauchy (l.map f) \u2194 NeBot l \u2227 Tendsto (fun p : \u03b2 \u00d7 \u03b2 => (f p.1, f p.2)) (l \u00d7\u02e2 l) (\ud835\udce4 \u03b1) := by\n  rw [Cauchy]\n  rw [map_neBot_iff]\n  rw [prod_map_map_eq]\n  rw [Tendsto]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nl : Filter \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 Cauchy (map f l) \u2194 l.NeBot \u2227 Tendsto (fun p => (f p.1, f p.2)) (l \u00d7\u02e2 l) (uniformity \u03b1)"}, {"line": "rw [Cauchy]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nl : Filter \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 (map f l).NeBot \u2227 map f l \u00d7\u02e2 map f l \u2264 uniformity \u03b1 \u2194\n    l.NeBot \u2227 Tendsto (fun p => (f p.1, f p.2)) (l \u00d7\u02e2 l) (uniformity \u03b1)"}, {"line": "rw [map_neBot_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nl : Filter \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 l.NeBot \u2227 map f l \u00d7\u02e2 map f l \u2264 uniformity \u03b1 \u2194 l.NeBot \u2227 Tendsto (fun p => (f p.1, f p.2)) (l \u00d7\u02e2 l) (uniformity \u03b1)"}, {"line": "rw [prod_map_map_eq]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nl : Filter \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 l.NeBot \u2227 map (fun p => (f p.1, f p.2)) (l \u00d7\u02e2 l) \u2264 uniformity \u03b1 \u2194\n    l.NeBot \u2227 Tendsto (fun p => (f p.1, f p.2)) (l \u00d7\u02e2 l) (uniformity \u03b1)"}, {"line": "rw [Tendsto]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cauchy_inf_uniformSpace {u v : UniformSpace \u03b2} {F : Filter \u03b2} :\n    Cauchy (uniformSpace := u \u2293 v) F \u2194\n    Cauchy (uniformSpace := u) F \u2227 Cauchy (uniformSpace := v) F := by\n  unfold Cauchy\n  rw [inf_uniformity (u := u)]\n  rw [le_inf_iff]\n  rw [and_and_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type v\nu v : UniformSpace \u03b2\nF : Filter \u03b2\n\u22a2 Cauchy F \u2194 Cauchy F \u2227 Cauchy F"}, {"line": "unfold Cauchy", "tactic_state": "\u03b2 : Type v\nu v : UniformSpace \u03b2\nF : Filter \u03b2\n\u22a2 F.NeBot \u2227 F \u00d7\u02e2 F \u2264 uniformity \u03b2 \u2194 (F.NeBot \u2227 F \u00d7\u02e2 F \u2264 uniformity \u03b2) \u2227 F.NeBot \u2227 F \u00d7\u02e2 F \u2264 uniformity \u03b2"}, {"line": "rw [inf_uniformity (u := u)]", "tactic_state": "\u03b2 : Type v\nu v : UniformSpace \u03b2\nF : Filter \u03b2\n\u22a2 F.NeBot \u2227 F \u00d7\u02e2 F \u2264 uniformity \u03b2 \u2293 uniformity \u03b2 \u2194 (F.NeBot \u2227 F \u00d7\u02e2 F \u2264 uniformity \u03b2) \u2227 F.NeBot \u2227 F \u00d7\u02e2 F \u2264 uniformity \u03b2"}, {"line": "rw [le_inf_iff]", "tactic_state": "\u03b2 : Type v\nu v : UniformSpace \u03b2\nF : Filter \u03b2\n\u22a2 F.NeBot \u2227 F \u00d7\u02e2 F \u2264 uniformity \u03b2 \u2227 F \u00d7\u02e2 F \u2264 uniformity \u03b2 \u2194\n    (F.NeBot \u2227 F \u00d7\u02e2 F \u2264 uniformity \u03b2) \u2227 F.NeBot \u2227 F \u00d7\u02e2 F \u2264 uniformity \u03b2"}, {"line": "rw [and_and_left]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cauchy_comap_uniformSpace {u : UniformSpace \u03b2} {\u03b1} {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} :\n    Cauchy (uniformSpace := comap f u) l \u2194 Cauchy (map f l) := by\n  simp only [Cauchy]\n  simp only [map_neBot_iff]\n  simp only [prod_map_map_eq]\n  simp only [map_le_iff_le_comap]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type v\nu : UniformSpace \u03b2\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b2\nl : Filter \u03b1\n\u22a2 Cauchy l \u2194 Cauchy (map f l)"}, {"line": "simp only [Cauchy]", "tactic_state": "\u03b2 : Type v\nu : UniformSpace \u03b2\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b2\nl : Filter \u03b1\n\u22a2 l.NeBot \u2227 l \u00d7\u02e2 l \u2264 uniformity \u03b1 \u2194 (map f l).NeBot \u2227 map f l \u00d7\u02e2 map f l \u2264 uniformity \u03b2"}, {"line": "simp only [map_neBot_iff]", "tactic_state": "\u03b2 : Type v\nu : UniformSpace \u03b2\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b2\nl : Filter \u03b1\n\u22a2 l.NeBot \u2227 l \u00d7\u02e2 l \u2264 uniformity \u03b1 \u2194 l.NeBot \u2227 map f l \u00d7\u02e2 map f l \u2264 uniformity \u03b2"}, {"line": "simp only [prod_map_map_eq]", "tactic_state": "\u03b2 : Type v\nu : UniformSpace \u03b2\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b2\nl : Filter \u03b1\n\u22a2 l.NeBot \u2227 l \u00d7\u02e2 l \u2264 uniformity \u03b1 \u2194 l.NeBot \u2227 map (fun p => (f p.1, f p.2)) (l \u00d7\u02e2 l) \u2264 uniformity \u03b2"}, {"line": "simp only [map_le_iff_le_comap]", "tactic_state": "\u03b2 : Type v\nu : UniformSpace \u03b2\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b2\nl : Filter \u03b1\n\u22a2 l.NeBot \u2227 l \u00d7\u02e2 l \u2264 uniformity \u03b1 \u2194 l.NeBot \u2227 l \u00d7\u02e2 l \u2264 Filter.comap (fun p => (f p.1, f p.2)) (uniformity \u03b2)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cauchy_prod_iff [UniformSpace \u03b2] {F : Filter (\u03b1 \u00d7 \u03b2)} :\n    Cauchy F \u2194 Cauchy (map Prod.fst F) \u2227 Cauchy (map Prod.snd F) := by\n  simp_rw [instUniformSpaceProd, \u2190 cauchy_comap_uniformSpace, \u2190 cauchy_inf_uniformSpace]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : Filter (\u03b1 \u00d7 \u03b2)\n\u22a2 Cauchy F \u2194 Cauchy (map Prod.fst F) \u2227 Cauchy (map Prod.snd F)"}, {"line": "simp_rw [instUniformSpaceProd, \u2190 cauchy_comap_uniformSpace, \u2190 cauchy_inf_uniformSpace]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem CauchySeq.tendsto_uniformity [Preorder \u03b2] {u : \u03b2 \u2192 \u03b1} (h : CauchySeq u) :\n    Tendsto (Prod.map u u) atTop (\ud835\udce4 \u03b1) := by\n  simpa only [Tendsto,prod_map_map_eq',prod_atTop_atTop_eq] using h.right\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\ninst\u271d : Preorder \u03b2\nu : \u03b2 \u2192 \u03b1\nh : CauchySeq u\n\u22a2 Tendsto (Prod.map u u) atTop (uniformity \u03b1)"}, {"line": "simpa only [Tendsto,prod_map_map_eq',prod_atTop_atTop_eq] using h.right", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Function.Bijective.cauchySeq_comp_iff {f : \u2115 \u2192 \u2115} (hf : Bijective f) (u : \u2115 \u2192 \u03b1) :\n    CauchySeq (u \u2218 f) \u2194 CauchySeq u := by\n  refine \u27e8fun H => ?_, fun H => H.comp_injective hf.injective\u27e9\n  lift f to \u2115 \u2243 \u2115 using hf\n  simpa only [Function.comp_def,f.apply_symm_apply] using H.comp_injective f.symm.injective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nf : \u2115 \u2192 \u2115\nhf : Bijective f\nu : \u2115 \u2192 \u03b1\n\u22a2 CauchySeq (u \u2218 f) \u2194 CauchySeq u"}, {"line": "refine \u27e8fun H => ?_, fun H => H.comp_injective hf.injective\u27e9", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nf : \u2115 \u2192 \u2115\nhf : Bijective f\nu : \u2115 \u2192 \u03b1\nH : CauchySeq (u \u2218 f)\n\u22a2 CauchySeq u"}, {"line": "lift f to \u2115 \u2243 \u2115 using hf", "tactic_state": "case intro\n\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\nf : \u2115 \u2243 \u2115\nH : CauchySeq (u \u2218 \u21d1f)\n\u22a2 CauchySeq u"}, {"line": "simpa only [Function.comp_def,f.apply_symm_apply] using H.comp_injective f.symm.injective", "tactic_state": "No Goals!"}]}
{"declaration": "theorem CauchySeq.subseq_subseq_mem {V : \u2115 \u2192 Set (\u03b1 \u00d7 \u03b1)} (hV : \u2200 n, V n \u2208 \ud835\udce4 \u03b1) {u : \u2115 \u2192 \u03b1}\n    (hu : CauchySeq u) {f g : \u2115 \u2192 \u2115} (hf : Tendsto f atTop atTop) (hg : Tendsto g atTop atTop) :\n    \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 \u2200 n, ((u \u2218 f \u2218 \u03c6) n, (u \u2218 g \u2218 \u03c6) n) \u2208 V n := by\n  rw [cauchySeq_iff_tendsto] at hu\n  exact ((hu.comp <| hf.prod_atTop hg).comp tendsto_atTop_diagonal).subseq_mem hV\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nV : \u2115 \u2192 Set (\u03b1 \u00d7 \u03b1)\nhV : \u2200 (n : \u2115), V n \u2208 uniformity \u03b1\nu : \u2115 \u2192 \u03b1\nhu : CauchySeq u\nf g : \u2115 \u2192 \u2115\nhf : Tendsto f atTop atTop\nhg : Tendsto g atTop atTop\n\u22a2 \u2203 \u03c6, StrictMono \u03c6 \u2227 \u2200 (n : \u2115), ((u \u2218 f \u2218 \u03c6) n, (u \u2218 g \u2218 \u03c6) n) \u2208 V n"}, {"line": "rw [cauchySeq_iff_tendsto] at hu", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nV : \u2115 \u2192 Set (\u03b1 \u00d7 \u03b1)\nhV : \u2200 (n : \u2115), V n \u2208 uniformity \u03b1\nu : \u2115 \u2192 \u03b1\nhu : Tendsto (Prod.map u u) atTop (uniformity \u03b1)\nf g : \u2115 \u2192 \u2115\nhf : Tendsto f atTop atTop\nhg : Tendsto g atTop atTop\n\u22a2 \u2203 \u03c6, StrictMono \u03c6 \u2227 \u2200 (n : \u2115), ((u \u2218 f \u2218 \u03c6) n, (u \u2218 g \u2218 \u03c6) n) \u2208 V n"}, {"line": "exact ((hu.comp <| hf.prod_atTop hg).comp tendsto_atTop_diagonal).subseq_mem hV", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cauchySeq_iff {u : \u2115 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 V \u2208 \ud835\udce4 \u03b1, \u2203 N, \u2200 k \u2265 N, \u2200 l \u2265 N, (u k, u l) \u2208 V := by\n  simp only [cauchySeq_iff']\n  simp only [Filter.eventually_atTop_prod_self']\n  simp only [mem_preimage]\n  simp only [Prod.map_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\n\u22a2 CauchySeq u \u2194 \u2200 V \u2208 uniformity \u03b1, \u2203 N, \u2200 k \u2265 N, \u2200 l \u2265 N, (u k, u l) \u2208 V"}, {"line": "simp only [cauchySeq_iff']", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\n\u22a2 (\u2200 V \u2208 uniformity \u03b1, \u2200\u1da0 (k : \u2115 \u00d7 \u2115) in atTop, k \u2208 Prod.map u u \u207b\u00b9' V) \u2194\n    \u2200 V \u2208 uniformity \u03b1, \u2203 N, \u2200 k \u2265 N, \u2200 l \u2265 N, (u k, u l) \u2208 V"}, {"line": "simp only [Filter.eventually_atTop_prod_self']", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\n\u22a2 (\u2200 V \u2208 uniformity \u03b1, \u2203 a, \u2200 k \u2265 a, \u2200 l \u2265 a, (k, l) \u2208 Prod.map u u \u207b\u00b9' V) \u2194\n    \u2200 V \u2208 uniformity \u03b1, \u2203 N, \u2200 k \u2265 N, \u2200 l \u2265 N, (u k, u l) \u2208 V"}, {"line": "simp only [mem_preimage]", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\n\u22a2 (\u2200 V \u2208 uniformity \u03b1, \u2203 a, \u2200 k \u2265 a, \u2200 l \u2265 a, Prod.map u u (k, l) \u2208 V) \u2194\n    \u2200 V \u2208 uniformity \u03b1, \u2203 N, \u2200 k \u2265 N, \u2200 l \u2265 N, (u k, u l) \u2208 V"}, {"line": "simp only [Prod.map_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem CauchySeq.subseq_mem {V : \u2115 \u2192 Set (\u03b1 \u00d7 \u03b1)} (hV : \u2200 n, V n \u2208 \ud835\udce4 \u03b1) {u : \u2115 \u2192 \u03b1}\n    (hu : CauchySeq u) : \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 \u2200 n, (u <| \u03c6 (n + 1), u <| \u03c6 n) \u2208 V n := by\n  have : \u2200 n, \u2203 N, \u2200 k \u2265 N, \u2200 l \u2265 k, (u l, u k) \u2208 V n := fun n => by\n    rw [cauchySeq_iff] at hu\n    rcases hu _ (hV n) with \u27e8N, H\u27e9\n    exact \u27e8N, fun k hk l hl => H _ (le_trans hk hl) _ hk\u27e9\n  obtain \u27e8\u03c6 : \u2115 \u2192 \u2115, \u03c6_extr : StrictMono \u03c6, h\u03c6 : \u2200 n, \u2200 l \u2265 \u03c6 n, (u l, u <| \u03c6 n) \u2208 V n\u27e9 :=\n    extraction_forall_of_eventually' this\n  exact \u27e8\u03c6, \u03c6_extr, fun n => h\u03c6 _ _ (\u03c6_extr <| Nat.lt_add_one n).le\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nV : \u2115 \u2192 Set (\u03b1 \u00d7 \u03b1)\nhV : \u2200 (n : \u2115), V n \u2208 uniformity \u03b1\nu : \u2115 \u2192 \u03b1\nhu : CauchySeq u\n\u22a2 \u2203 \u03c6, StrictMono \u03c6 \u2227 \u2200 (n : \u2115), (u (\u03c6 (n + 1)), u (\u03c6 n)) \u2208 V n"}, {"line": "have : \u2200 n, \u2203 N, \u2200 k \u2265 N, \u2200 l \u2265 k, (u l, u k) \u2208 V n := fun n => by\n    rw [cauchySeq_iff] at hu\n    rcases hu _ (hV n) with \u27e8N, H\u27e9\n    exact \u27e8N, fun k hk l hl => H _ (le_trans hk hl) _ hk\u27e9", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nV : \u2115 \u2192 Set (\u03b1 \u00d7 \u03b1)\nhV : \u2200 (n : \u2115), V n \u2208 uniformity \u03b1\nu : \u2115 \u2192 \u03b1\nhu : CauchySeq u\nthis : \u2200 (n : \u2115), \u2203 N, \u2200 k \u2265 N, \u2200 l \u2265 k, (u l, u k) \u2208 V n\n\u22a2 \u2203 \u03c6, StrictMono \u03c6 \u2227 \u2200 (n : \u2115), (u (\u03c6 (n + 1)), u (\u03c6 n)) \u2208 V n"}, {"line": "obtain \u27e8\u03c6 : \u2115 \u2192 \u2115, \u03c6_extr : StrictMono \u03c6, h\u03c6 : \u2200 n, \u2200 l \u2265 \u03c6 n, (u l, u <| \u03c6 n) \u2208 V n\u27e9 :=\n    extraction_forall_of_eventually' this", "tactic_state": "case intro.intro\n\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nV : \u2115 \u2192 Set (\u03b1 \u00d7 \u03b1)\nhV : \u2200 (n : \u2115), V n \u2208 uniformity \u03b1\nu : \u2115 \u2192 \u03b1\nhu : CauchySeq u\nthis : \u2200 (n : \u2115), \u2203 N, \u2200 k \u2265 N, \u2200 l \u2265 k, (u l, u k) \u2208 V n\n\u03c6 : \u2115 \u2192 \u2115\n\u03c6_extr : StrictMono \u03c6\nh\u03c6 : \u2200 (n l : \u2115), l \u2265 \u03c6 n \u2192 (u l, u (\u03c6 n)) \u2208 V n\n\u22a2 \u2203 \u03c6, StrictMono \u03c6 \u2227 \u2200 (n : \u2115), (u (\u03c6 (n + 1)), u (\u03c6 n)) \u2208 V n"}, {"line": "exact \u27e8\u03c6, \u03c6_extr, fun n => h\u03c6 _ _ (\u03c6_extr <| Nat.lt_add_one n).le\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isComplete_iff_ultrafilter {s : Set \u03b1} :\n    IsComplete s \u2194 \u2200 l : Ultrafilter \u03b1, Cauchy (l : Filter \u03b1) \u2192 \u2191l \u2264 \ud835\udcdf s \u2192 \u2203 x \u2208 s, \u2191l \u2264 \ud835\udcdd x := by\n  refine \u27e8fun h l => h l, fun H => isComplete_iff_clusterPt.2 fun l hl hls => ?_\u27e9\n  haveI := hl.1\n  rcases H (Ultrafilter.of l) hl.ultrafilter_of ((Ultrafilter.of_le l).trans hls) with \u27e8x, hxs, hxl\u27e9\n  exact \u27e8x, hxs, (ClusterPt.of_le_nhds hxl).mono (Ultrafilter.of_le l)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns : Set \u03b1\n\u22a2 IsComplete s \u2194 \u2200 (l : Ultrafilter \u03b1), Cauchy \u2191l \u2192 \u2191l \u2264 principal s \u2192 \u2203 x \u2208 s, \u2191l \u2264 nhds x"}, {"line": "refine \u27e8fun h l => h l, fun H => isComplete_iff_clusterPt.2 fun l hl hls => ?_\u27e9", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns : Set \u03b1\nH : \u2200 (l : Ultrafilter \u03b1), Cauchy \u2191l \u2192 \u2191l \u2264 principal s \u2192 \u2203 x \u2208 s, \u2191l \u2264 nhds x\nl : Filter \u03b1\nhl : Cauchy l\nhls : l \u2264 principal s\n\u22a2 \u2203 x \u2208 s, ClusterPt x l"}, {"line": "haveI := hl.1", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns : Set \u03b1\nH : \u2200 (l : Ultrafilter \u03b1), Cauchy \u2191l \u2192 \u2191l \u2264 principal s \u2192 \u2203 x \u2208 s, \u2191l \u2264 nhds x\nl : Filter \u03b1\nhl : Cauchy l\nhls : l \u2264 principal s\nthis : l.NeBot\n\u22a2 \u2203 x \u2208 s, ClusterPt x l"}, {"line": "rcases H (Ultrafilter.of l) hl.ultrafilter_of ((Ultrafilter.of_le l).trans hls) with \u27e8x, hxs, hxl\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns : Set \u03b1\nH : \u2200 (l : Ultrafilter \u03b1), Cauchy \u2191l \u2192 \u2191l \u2264 principal s \u2192 \u2203 x \u2208 s, \u2191l \u2264 nhds x\nl : Filter \u03b1\nhl : Cauchy l\nhls : l \u2264 principal s\nthis : l.NeBot\nx : \u03b1\nhxs : x \u2208 s\nhxl : \u2191(Ultrafilter.of l) \u2264 nhds x\n\u22a2 \u2203 x \u2208 s, ClusterPt x l"}, {"line": "exact \u27e8x, hxs, (ClusterPt.of_le_nhds hxl).mono (Ultrafilter.of_le l)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsComplete.union {s t : Set \u03b1} (hs : IsComplete s) (ht : IsComplete t) :\n    IsComplete (s \u222a t) := by\n  simp only [isComplete_iff_ultrafilter'] at *\n  simp only [Ultrafilter.union_mem_iff] at *\n  simp only [or_imp] at *\n  exact fun l hl =>\n    \u27e8fun hsl => (hs l hl hsl).imp fun x hx => \u27e8Or.inl hx.1, hx.2\u27e9, fun htl =>\n      (ht l hl htl).imp fun x hx => \u27e8Or.inr hx.1, hx.2\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns t : Set \u03b1\nhs : IsComplete s\nht : IsComplete t\n\u22a2 IsComplete (s \u222a t)"}, {"line": "simp only [isComplete_iff_ultrafilter'] at *", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns t : Set \u03b1\nhs : \u2200 (l : Ultrafilter \u03b1), Cauchy \u2191l \u2192 s \u2208 l \u2192 \u2203 x \u2208 s, \u2191l \u2264 nhds x\nht : \u2200 (l : Ultrafilter \u03b1), Cauchy \u2191l \u2192 t \u2208 l \u2192 \u2203 x \u2208 t, \u2191l \u2264 nhds x\n\u22a2 \u2200 (l : Ultrafilter \u03b1), Cauchy \u2191l \u2192 s \u222a t \u2208 l \u2192 \u2203 x \u2208 s \u222a t, \u2191l \u2264 nhds x"}, {"line": "simp only [Ultrafilter.union_mem_iff] at *", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns t : Set \u03b1\nhs : \u2200 (l : Ultrafilter \u03b1), Cauchy \u2191l \u2192 s \u2208 l \u2192 \u2203 x \u2208 s, \u2191l \u2264 nhds x\nht : \u2200 (l : Ultrafilter \u03b1), Cauchy \u2191l \u2192 t \u2208 l \u2192 \u2203 x \u2208 t, \u2191l \u2264 nhds x\n\u22a2 \u2200 (l : Ultrafilter \u03b1), Cauchy \u2191l \u2192 s \u2208 l \u2228 t \u2208 l \u2192 \u2203 x \u2208 s \u222a t, \u2191l \u2264 nhds x"}, {"line": "simp only [or_imp] at *", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns t : Set \u03b1\nhs : \u2200 (l : Ultrafilter \u03b1), Cauchy \u2191l \u2192 s \u2208 l \u2192 \u2203 x \u2208 s, \u2191l \u2264 nhds x\nht : \u2200 (l : Ultrafilter \u03b1), Cauchy \u2191l \u2192 t \u2208 l \u2192 \u2203 x \u2208 t, \u2191l \u2264 nhds x\n\u22a2 \u2200 (l : Ultrafilter \u03b1), Cauchy \u2191l \u2192 (s \u2208 l \u2192 \u2203 x \u2208 s \u222a t, \u2191l \u2264 nhds x) \u2227 (t \u2208 l \u2192 \u2203 x \u2208 s \u222a t, \u2191l \u2264 nhds x)"}, {"line": "exact fun l hl =>\n    \u27e8fun hsl => (hs l hl hsl).imp fun x hx => \u27e8Or.inl hx.1, hx.2\u27e9, fun htl =>\n      (ht l hl htl).imp fun x hx => \u27e8Or.inr hx.1, hx.2\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isComplete_iUnion_separated {\u03b9 : Sort*} {s : \u03b9 \u2192 Set \u03b1} (hs : \u2200 i, IsComplete (s i))\n    {U : Set (\u03b1 \u00d7 \u03b1)} (hU : U \u2208 \ud835\udce4 \u03b1) (hd : \u2200 (i j : \u03b9), \u2200 x \u2208 s i, \u2200 y \u2208 s j, (x, y) \u2208 U \u2192 i = j) :\n    IsComplete (\u22c3 i, s i) := by\n  set S := \u22c3 i, s i\n  intro l hl hls\n  rw [le_principal_iff] at hls\n  obtain \u27e8hl_ne, hl'\u27e9 := cauchy_iff.1 hl\n  obtain \u27e8t, htS, htl, htU\u27e9 : \u2203 t, t \u2286 S \u2227 t \u2208 l \u2227 t \u00d7\u02e2 t \u2286 U := by\n    rcases hl' U hU with \u27e8t, htl, htU\u27e9\n    refine \u27e8t \u2229 S, inter_subset_right, inter_mem htl hls, Subset.trans ?_ htU\u27e9\n    gcongr <;> apply inter_subset_left\n  obtain \u27e8i, hi\u27e9 : \u2203 i, t \u2286 s i := by\n    rcases Filter.nonempty_of_mem htl with \u27e8x, hx\u27e9\n    rcases mem_iUnion.1 (htS hx) with \u27e8i, hi\u27e9\n    refine \u27e8i, fun y hy => ?_\u27e9\n    rcases mem_iUnion.1 (htS hy) with \u27e8j, hj\u27e9\n    rwa [hd i j x hi y hj (htU <| mk_mem_prod hx hy)]\n  rcases hs i l hl (le_principal_iff.2 <| mem_of_superset htl hi) with \u27e8x, hxs, hlx\u27e9\n  exact \u27e8x, mem_iUnion.2 \u27e8i, hxs\u27e9, hlx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\n\u03b9 : Sort u_1\ns : \u03b9 \u2192 Set \u03b1\nhs : \u2200 (i : \u03b9), IsComplete (s i)\nU : Set (\u03b1 \u00d7 \u03b1)\nhU : U \u2208 uniformity \u03b1\nhd : \u2200 (i j : \u03b9), \u2200 x \u2208 s i, \u2200 y \u2208 s j, (x, y) \u2208 U \u2192 i = j\n\u22a2 IsComplete (\u22c3 i, s i)"}, {"line": "set S := \u22c3 i, s i", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\n\u03b9 : Sort u_1\ns : \u03b9 \u2192 Set \u03b1\nhs : \u2200 (i : \u03b9), IsComplete (s i)\nU : Set (\u03b1 \u00d7 \u03b1)\nhU : U \u2208 uniformity \u03b1\nhd : \u2200 (i j : \u03b9), \u2200 x \u2208 s i, \u2200 y \u2208 s j, (x, y) \u2208 U \u2192 i = j\nS : Set \u03b1 := \u22c3 i, s i\n\u22a2 IsComplete S"}, {"line": "intro l hl hls", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\n\u03b9 : Sort u_1\ns : \u03b9 \u2192 Set \u03b1\nhs : \u2200 (i : \u03b9), IsComplete (s i)\nU : Set (\u03b1 \u00d7 \u03b1)\nhU : U \u2208 uniformity \u03b1\nhd : \u2200 (i j : \u03b9), \u2200 x \u2208 s i, \u2200 y \u2208 s j, (x, y) \u2208 U \u2192 i = j\nS : Set \u03b1 := \u22c3 i, s i\nl : Filter \u03b1\nhl : Cauchy l\nhls : l \u2264 principal S\n\u22a2 \u2203 x \u2208 S, l \u2264 nhds x"}, {"line": "rw [le_principal_iff] at hls", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\n\u03b9 : Sort u_1\ns : \u03b9 \u2192 Set \u03b1\nhs : \u2200 (i : \u03b9), IsComplete (s i)\nU : Set (\u03b1 \u00d7 \u03b1)\nhU : U \u2208 uniformity \u03b1\nhd : \u2200 (i j : \u03b9), \u2200 x \u2208 s i, \u2200 y \u2208 s j, (x, y) \u2208 U \u2192 i = j\nS : Set \u03b1 := \u22c3 i, s i\nl : Filter \u03b1\nhl : Cauchy l\nhls : S \u2208 l\n\u22a2 \u2203 x \u2208 S, l \u2264 nhds x"}, {"line": "obtain \u27e8hl_ne, hl'\u27e9 := cauchy_iff.1 hl", "tactic_state": "case intro\n\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\n\u03b9 : Sort u_1\ns : \u03b9 \u2192 Set \u03b1\nhs : \u2200 (i : \u03b9), IsComplete (s i)\nU : Set (\u03b1 \u00d7 \u03b1)\nhU : U \u2208 uniformity \u03b1\nhd : \u2200 (i j : \u03b9), \u2200 x \u2208 s i, \u2200 y \u2208 s j, (x, y) \u2208 U \u2192 i = j\nS : Set \u03b1 := \u22c3 i, s i\nl : Filter \u03b1\nhl : Cauchy l\nhls : S \u2208 l\nhl_ne : l.NeBot\nhl' : \u2200 s \u2208 uniformity \u03b1, \u2203 t \u2208 l, t \u00d7\u02e2 t \u2286 s\n\u22a2 \u2203 x \u2208 S, l \u2264 nhds x"}, {"line": "obtain \u27e8t, htS, htl, htU\u27e9 : \u2203 t, t \u2286 S \u2227 t \u2208 l \u2227 t \u00d7\u02e2 t \u2286 U := by\n    rcases hl' U hU with \u27e8t, htl, htU\u27e9\n    refine \u27e8t \u2229 S, inter_subset_right, inter_mem htl hls, Subset.trans ?_ htU\u27e9\n    gcongr <;> apply inter_subset_left", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\n\u03b9 : Sort u_1\ns : \u03b9 \u2192 Set \u03b1\nhs : \u2200 (i : \u03b9), IsComplete (s i)\nU : Set (\u03b1 \u00d7 \u03b1)\nhU : U \u2208 uniformity \u03b1\nhd : \u2200 (i j : \u03b9), \u2200 x \u2208 s i, \u2200 y \u2208 s j, (x, y) \u2208 U \u2192 i = j\nS : Set \u03b1 := \u22c3 i, s i\nl : Filter \u03b1\nhl : Cauchy l\nhls : S \u2208 l\nhl_ne : l.NeBot\nhl' : \u2200 s \u2208 uniformity \u03b1, \u2203 t \u2208 l, t \u00d7\u02e2 t \u2286 s\nt : Set \u03b1\nhtS : t \u2286 S\nhtl : t \u2208 l\nhtU : t \u00d7\u02e2 t \u2286 U\n\u22a2 \u2203 x \u2208 S, l \u2264 nhds x"}, {"line": "obtain \u27e8i, hi\u27e9 : \u2203 i, t \u2286 s i := by\n    rcases Filter.nonempty_of_mem htl with \u27e8x, hx\u27e9\n    rcases mem_iUnion.1 (htS hx) with \u27e8i, hi\u27e9\n    refine \u27e8i, fun y hy => ?_\u27e9\n    rcases mem_iUnion.1 (htS hy) with \u27e8j, hj\u27e9\n    rwa [hd i j x hi y hj (htU <| mk_mem_prod hx hy)]", "tactic_state": "case intro.intro.intro.intro.intro\n\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\n\u03b9 : Sort u_1\ns : \u03b9 \u2192 Set \u03b1\nhs : \u2200 (i : \u03b9), IsComplete (s i)\nU : Set (\u03b1 \u00d7 \u03b1)\nhU : U \u2208 uniformity \u03b1\nhd : \u2200 (i j : \u03b9), \u2200 x \u2208 s i, \u2200 y \u2208 s j, (x, y) \u2208 U \u2192 i = j\nS : Set \u03b1 := \u22c3 i, s i\nl : Filter \u03b1\nhl : Cauchy l\nhls : S \u2208 l\nhl_ne : l.NeBot\nhl' : \u2200 s \u2208 uniformity \u03b1, \u2203 t \u2208 l, t \u00d7\u02e2 t \u2286 s\nt : Set \u03b1\nhtS : t \u2286 S\nhtl : t \u2208 l\nhtU : t \u00d7\u02e2 t \u2286 U\ni : \u03b9\nhi : t \u2286 s i\n\u22a2 \u2203 x \u2208 S, l \u2264 nhds x"}, {"line": "rcases hs i l hl (le_principal_iff.2 <| mem_of_superset htl hi) with \u27e8x, hxs, hlx\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\n\u03b9 : Sort u_1\ns : \u03b9 \u2192 Set \u03b1\nhs : \u2200 (i : \u03b9), IsComplete (s i)\nU : Set (\u03b1 \u00d7 \u03b1)\nhU : U \u2208 uniformity \u03b1\nhd : \u2200 (i j : \u03b9), \u2200 x \u2208 s i, \u2200 y \u2208 s j, (x, y) \u2208 U \u2192 i = j\nS : Set \u03b1 := \u22c3 i, s i\nl : Filter \u03b1\nhl : Cauchy l\nhls : S \u2208 l\nhl_ne : l.NeBot\nhl' : \u2200 s \u2208 uniformity \u03b1, \u2203 t \u2208 l, t \u00d7\u02e2 t \u2286 s\nt : Set \u03b1\nhtS : t \u2286 S\nhtl : t \u2208 l\nhtU : t \u00d7\u02e2 t \u2286 U\ni : \u03b9\nhi : t \u2286 s i\nx : \u03b1\nhxs : x \u2208 s i\nhlx : l \u2264 nhds x\n\u22a2 \u2203 x \u2208 S, l \u2264 nhds x"}, {"line": "exact \u27e8x, mem_iUnion.2 \u27e8i, hxs\u27e9, hlx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem completeSpace_iff_ultrafilter :\n    CompleteSpace \u03b1 \u2194 \u2200 l : Ultrafilter \u03b1, Cauchy (l : Filter \u03b1) \u2192 \u2203 x : \u03b1, \u2191l \u2264 \ud835\udcdd x := by\n  simp [completeSpace_iff_isComplete_univ, isComplete_iff_ultrafilter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\n\u22a2 CompleteSpace \u03b1 \u2194 \u2200 (l : Ultrafilter \u03b1), Cauchy \u2191l \u2192 \u2203 x, \u2191l \u2264 nhds x"}, {"line": "simp [completeSpace_iff_isComplete_univ, isComplete_iff_ultrafilter]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma totallyBounded_biUnion {\u03b9 : Type*} {I : Set \u03b9} (hI : I.Finite) {s : \u03b9 \u2192 Set \u03b1} :\n    TotallyBounded (\u22c3 i \u2208 I, s i) \u2194 \u2200 i \u2208 I, TotallyBounded (s i) := by\n  have := hI.to_subtype\n  rw [biUnion_eq_iUnion]\n  rw [totallyBounded_iUnion]\n  rw [Subtype.forall]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\n\u03b9 : Type u_1\nI : Set \u03b9\nhI : I.Finite\ns : \u03b9 \u2192 Set \u03b1\n\u22a2 TotallyBounded (\u22c3 i \u2208 I, s i) \u2194 \u2200 i \u2208 I, TotallyBounded (s i)"}, {"line": "have := hI.to_subtype", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\n\u03b9 : Type u_1\nI : Set \u03b9\nhI : I.Finite\ns : \u03b9 \u2192 Set \u03b1\nthis : Finite \u2191I\n\u22a2 TotallyBounded (\u22c3 i \u2208 I, s i) \u2194 \u2200 i \u2208 I, TotallyBounded (s i)"}, {"line": "rw [biUnion_eq_iUnion]", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\n\u03b9 : Type u_1\nI : Set \u03b9\nhI : I.Finite\ns : \u03b9 \u2192 Set \u03b1\nthis : Finite \u2191I\n\u22a2 TotallyBounded (\u22c3 x, s \u2191x) \u2194 \u2200 i \u2208 I, TotallyBounded (s i)"}, {"line": "rw [totallyBounded_iUnion]", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\n\u03b9 : Type u_1\nI : Set \u03b9\nhI : I.Finite\ns : \u03b9 \u2192 Set \u03b1\nthis : Finite \u2191I\n\u22a2 (\u2200 (i : \u2191I), TotallyBounded (s \u2191i)) \u2194 \u2200 i \u2208 I, TotallyBounded (s i)"}, {"line": "rw [Subtype.forall]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma totallyBounded_sUnion {S : Set (Set \u03b1)} (hS : S.Finite) :\n    TotallyBounded (\u22c3\u2080 S) \u2194 \u2200 s \u2208 S, TotallyBounded s := by\n  rw [sUnion_eq_biUnion]\n  rw [totallyBounded_biUnion hS]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nS : Set (Set \u03b1)\nhS : S.Finite\n\u22a2 TotallyBounded (\u22c3\u2080 S) \u2194 \u2200 s \u2208 S, TotallyBounded s"}, {"line": "rw [sUnion_eq_biUnion]", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\nS : Set (Set \u03b1)\nhS : S.Finite\n\u22a2 TotallyBounded (\u22c3 i \u2208 S, i) \u2194 \u2200 s \u2208 S, TotallyBounded s"}, {"line": "rw [totallyBounded_biUnion hS]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma totallyBounded_union {s t : Set \u03b1} :\n    TotallyBounded (s \u222a t) \u2194 TotallyBounded s \u2227 TotallyBounded t := by\n  rw [union_eq_iUnion]\n  rw [totallyBounded_iUnion]\n  simp [and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns t : Set \u03b1\n\u22a2 TotallyBounded (s \u222a t) \u2194 TotallyBounded s \u2227 TotallyBounded t"}, {"line": "rw [union_eq_iUnion]", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns t : Set \u03b1\n\u22a2 TotallyBounded (\u22c3 b, bif b then s else t) \u2194 TotallyBounded s \u2227 TotallyBounded t"}, {"line": "rw [totallyBounded_iUnion]", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns t : Set \u03b1\n\u22a2 (\u2200 (i : Bool), TotallyBounded (bif i then s else t)) \u2194 TotallyBounded s \u2227 TotallyBounded t"}, {"line": "simp [and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma totallyBounded_insert (a : \u03b1) {s : Set \u03b1} :\n    TotallyBounded (insert a s) \u2194 TotallyBounded s := by\n  simp_rw [\u2190 singleton_union, totallyBounded_union, totallyBounded_singleton, true_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\na : \u03b1\ns : Set \u03b1\n\u22a2 TotallyBounded (insert a s) \u2194 TotallyBounded s"}, {"line": "simp_rw [\u2190 singleton_union, totallyBounded_union, totallyBounded_singleton, true_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem totallyBounded_iff_ultrafilter {s : Set \u03b1} :\n    TotallyBounded s \u2194 \u2200 f : Ultrafilter \u03b1, \u2191f \u2264 \ud835\udcdf s \u2192 Cauchy (f : Filter \u03b1) := by\n  refine \u27e8fun hs f => f.cauchy_of_totallyBounded hs, fun H => totallyBounded_iff_filter.2 ?_\u27e9\n  intro f hf hfs\n  exact \u27e8Ultrafilter.of f, Ultrafilter.of_le f, H _ ((Ultrafilter.of_le f).trans hfs)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns : Set \u03b1\n\u22a2 TotallyBounded s \u2194 \u2200 (f : Ultrafilter \u03b1), \u2191f \u2264 principal s \u2192 Cauchy \u2191f"}, {"line": "refine \u27e8fun hs f => f.cauchy_of_totallyBounded hs, fun H => totallyBounded_iff_filter.2 ?_\u27e9", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns : Set \u03b1\nH : \u2200 (f : Ultrafilter \u03b1), \u2191f \u2264 principal s \u2192 Cauchy \u2191f\n\u22a2 \u2200 (f : Filter \u03b1), f.NeBot \u2192 f \u2264 principal s \u2192 \u2203 c \u2264 f, Cauchy c"}, {"line": "intro f hf hfs", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns : Set \u03b1\nH : \u2200 (f : Ultrafilter \u03b1), \u2191f \u2264 principal s \u2192 Cauchy \u2191f\nf : Filter \u03b1\nhf : f.NeBot\nhfs : f \u2264 principal s\n\u22a2 \u2203 c \u2264 f, Cauchy c"}, {"line": "exact \u27e8Ultrafilter.of f, Ultrafilter.of_le f, H _ ((Ultrafilter.of_le f).trans hfs)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem CauchySeq.totallyBounded_range {s : \u2115 \u2192 \u03b1} (hs : CauchySeq s) :\n    TotallyBounded (range s) := by\n  intro a ha\n  obtain \u27e8n, hn\u27e9 := cauchySeq_iff.1 hs a ha\n  refine \u27e8s '' { k | k \u2264 n }, (finite_le_nat _).image _, ?_\u27e9\n  rw [range_subset_iff]\n  rw [biUnion_image]\n  intro m\n  rw [mem_iUnion\u2082]\n  rcases le_total m n with hm | hm\n  exacts [\u27e8m, hm, refl_mem_uniformity ha\u27e9, \u27e8n, le_refl n, hn m hm n le_rfl\u27e9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Cauchy.lean", "context": {"open": ["Filter Function TopologicalSpace Topology Set UniformSpace Uniformity"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} [uniformSpace : UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns : \u2115 \u2192 \u03b1\nhs : CauchySeq s\n\u22a2 TotallyBounded (range s)"}, {"line": "intro a ha", "tactic_state": "\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns : \u2115 \u2192 \u03b1\nhs : CauchySeq s\na : Set (\u03b1 \u00d7 \u03b1)\nha : a \u2208 uniformity \u03b1\n\u22a2 \u2203 t, t.Finite \u2227 range s \u2286 \u22c3 y \u2208 t, {x | (x, y) \u2208 a}"}, {"line": "obtain \u27e8n, hn\u27e9 := cauchySeq_iff.1 hs a ha", "tactic_state": "case intro\n\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns : \u2115 \u2192 \u03b1\nhs : CauchySeq s\na : Set (\u03b1 \u00d7 \u03b1)\nha : a \u2208 uniformity \u03b1\nn : \u2115\nhn : \u2200 k \u2265 n, \u2200 l \u2265 n, (s k, s l) \u2208 a\n\u22a2 \u2203 t, t.Finite \u2227 range s \u2286 \u22c3 y \u2208 t, {x | (x, y) \u2208 a}"}, {"line": "refine \u27e8s '' { k | k \u2264 n }, (finite_le_nat _).image _, ?_\u27e9", "tactic_state": "case intro\n\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns : \u2115 \u2192 \u03b1\nhs : CauchySeq s\na : Set (\u03b1 \u00d7 \u03b1)\nha : a \u2208 uniformity \u03b1\nn : \u2115\nhn : \u2200 k \u2265 n, \u2200 l \u2265 n, (s k, s l) \u2208 a\n\u22a2 range s \u2286 \u22c3 y \u2208 s '' {k | k \u2264 n}, {x | (x, y) \u2208 a}"}, {"line": "rw [range_subset_iff]", "tactic_state": "case intro\n\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns : \u2115 \u2192 \u03b1\nhs : CauchySeq s\na : Set (\u03b1 \u00d7 \u03b1)\nha : a \u2208 uniformity \u03b1\nn : \u2115\nhn : \u2200 k \u2265 n, \u2200 l \u2265 n, (s k, s l) \u2208 a\n\u22a2 \u2200 (y : \u2115), s y \u2208 \u22c3 y \u2208 s '' {k | k \u2264 n}, {x | (x, y) \u2208 a}"}, {"line": "rw [biUnion_image]", "tactic_state": "case intro\n\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns : \u2115 \u2192 \u03b1\nhs : CauchySeq s\na : Set (\u03b1 \u00d7 \u03b1)\nha : a \u2208 uniformity \u03b1\nn : \u2115\nhn : \u2200 k \u2265 n, \u2200 l \u2265 n, (s k, s l) \u2208 a\n\u22a2 \u2200 (y : \u2115), s y \u2208 \u22c3 y \u2208 {k | k \u2264 n}, {x | (x, s y) \u2208 a}"}, {"line": "intro m", "tactic_state": "case intro\n\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns : \u2115 \u2192 \u03b1\nhs : CauchySeq s\na : Set (\u03b1 \u00d7 \u03b1)\nha : a \u2208 uniformity \u03b1\nn : \u2115\nhn : \u2200 k \u2265 n, \u2200 l \u2265 n, (s k, s l) \u2208 a\nm : \u2115\n\u22a2 s m \u2208 \u22c3 y \u2208 {k | k \u2264 n}, {x | (x, s y) \u2208 a}"}, {"line": "rw [mem_iUnion\u2082]", "tactic_state": "case intro\n\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns : \u2115 \u2192 \u03b1\nhs : CauchySeq s\na : Set (\u03b1 \u00d7 \u03b1)\nha : a \u2208 uniformity \u03b1\nn : \u2115\nhn : \u2200 k \u2265 n, \u2200 l \u2265 n, (s k, s l) \u2208 a\nm : \u2115\n\u22a2 \u2203 i, \u2203 (_ : i \u2208 {k | k \u2264 n}), s m \u2208 {x | (x, s i) \u2208 a}"}, {"line": "rcases le_total m n with hm | hm", "tactic_state": "case intro.inl\n\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns : \u2115 \u2192 \u03b1\nhs : CauchySeq s\na : Set (\u03b1 \u00d7 \u03b1)\nha : a \u2208 uniformity \u03b1\nn : \u2115\nhn : \u2200 k \u2265 n, \u2200 l \u2265 n, (s k, s l) \u2208 a\nm : \u2115\nhm : m \u2264 n\n\u22a2 \u2203 i, \u2203 (_ : i \u2208 {k | k \u2264 n}), s m \u2208 {x | (x, s i) \u2208 a}\n---\ncase intro.inr\n\u03b1 : Type u\nuniformSpace : UniformSpace \u03b1\ns : \u2115 \u2192 \u03b1\nhs : CauchySeq s\na : Set (\u03b1 \u00d7 \u03b1)\nha : a \u2208 uniformity \u03b1\nn : \u2115\nhn : \u2200 k \u2265 n, \u2200 l \u2265 n, (s k, s l) \u2208 a\nm : \u2115\nhm : n \u2264 m\n\u22a2 \u2203 i, \u2203 (_ : i \u2208 {k | k \u2264 n}), s m \u2208 {x | (x, s i) \u2208 a}"}, {"line": "exacts [\u27e8m, hm, refl_mem_uniformity ha\u27e9, \u27e8n, le_refl n, hn m hm n le_rfl\u27e9]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Filter.HasBasis.lebesgue_number_lemma {\u03b9' \u03b9 : Sort*} {p : \u03b9' \u2192 Prop}\n    {V : \u03b9' \u2192 Set (\u03b1 \u00d7 \u03b1)} {U : \u03b9 \u2192 Set \u03b1} (hbasis : (\ud835\udce4 \u03b1).HasBasis p V) (hK : IsCompact K)\n    (hopen : \u2200 j, IsOpen (U j)) (hcover : K \u2286 \u22c3 j, U j) :\n    \u2203 i, p i \u2227 \u2200 x \u2208 K, \u2203 j, ball x (V i) \u2286 U j := by\n  refine (hbasis.exists_iff ?_).1 (lebesgue_number_lemma hK hopen hcover)\n  exact fun s t hst ht x hx \u21a6 (ht x hx).imp fun i hi \u21a6 Subset.trans (ball_mono hst _) hi\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Compact.lean", "context": {"open": ["Uniformity Set Filter UniformSpace", "scoped Topology"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1] {K : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nK : Set \u03b1\n\u03b9' : Sort u_2\n\u03b9 : Sort u_3\np : \u03b9' \u2192 Prop\nV : \u03b9' \u2192 Set (\u03b1 \u00d7 \u03b1)\nU : \u03b9 \u2192 Set \u03b1\nhbasis : (uniformity \u03b1).HasBasis p V\nhK : IsCompact K\nhopen : \u2200 (j : \u03b9), IsOpen (U j)\nhcover : K \u2286 \u22c3 j, U j\n\u22a2 \u2203 i, p i \u2227 \u2200 x \u2208 K, \u2203 j, ball x (V i) \u2286 U j"}, {"line": "refine (hbasis.exists_iff ?_).1 (lebesgue_number_lemma hK hopen hcover)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nK : Set \u03b1\n\u03b9' : Sort u_2\n\u03b9 : Sort u_3\np : \u03b9' \u2192 Prop\nV : \u03b9' \u2192 Set (\u03b1 \u00d7 \u03b1)\nU : \u03b9 \u2192 Set \u03b1\nhbasis : (uniformity \u03b1).HasBasis p V\nhK : IsCompact K\nhopen : \u2200 (j : \u03b9), IsOpen (U j)\nhcover : K \u2286 \u22c3 j, U j\n\u22a2 \u2200 \u2983s t : Set (\u03b1 \u00d7 \u03b1)\u2984, s \u2286 t \u2192 (\u2200 x \u2208 K, \u2203 i, ball x t \u2286 U i) \u2192 \u2200 x \u2208 K, \u2203 i, ball x s \u2286 U i"}, {"line": "exact fun s t hst ht x hx \u21a6 (ht x hx).imp fun i hi \u21a6 Subset.trans (ball_mono hst _) hi", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Filter.HasBasis.lebesgue_number_lemma_nhds' {\u03b9' : Sort*} {p : \u03b9' \u2192 Prop}\n    {V : \u03b9' \u2192 Set (\u03b1 \u00d7 \u03b1)} {U : (x : \u03b1) \u2192 x \u2208 K \u2192 Set \u03b1} (hbasis : (\ud835\udce4 \u03b1).HasBasis p V)\n    (hK : IsCompact K) (hU : \u2200 x hx, U x hx \u2208 \ud835\udcdd x) :\n    \u2203 i, p i \u2227 \u2200 x \u2208 K, \u2203 y : K, ball x (V i) \u2286 U y y.2 := by\n  refine (hbasis.exists_iff ?_).1 (lebesgue_number_lemma_nhds' hK hU)\n  exact fun s t hst ht x hx \u21a6 (ht x hx).imp fun y hy \u21a6 Subset.trans (ball_mono hst _) hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Compact.lean", "context": {"open": ["Uniformity Set Filter UniformSpace", "scoped Topology"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1] {K : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nK : Set \u03b1\n\u03b9' : Sort u_2\np : \u03b9' \u2192 Prop\nV : \u03b9' \u2192 Set (\u03b1 \u00d7 \u03b1)\nU : (x : \u03b1) \u2192 x \u2208 K \u2192 Set \u03b1\nhbasis : (uniformity \u03b1).HasBasis p V\nhK : IsCompact K\nhU : \u2200 (x : \u03b1) (hx : x \u2208 K), U x hx \u2208 nhds x\n\u22a2 \u2203 i, p i \u2227 \u2200 x \u2208 K, \u2203 y, ball x (V i) \u2286 U \u2191y \u22ef"}, {"line": "refine (hbasis.exists_iff ?_).1 (lebesgue_number_lemma_nhds' hK hU)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nK : Set \u03b1\n\u03b9' : Sort u_2\np : \u03b9' \u2192 Prop\nV : \u03b9' \u2192 Set (\u03b1 \u00d7 \u03b1)\nU : (x : \u03b1) \u2192 x \u2208 K \u2192 Set \u03b1\nhbasis : (uniformity \u03b1).HasBasis p V\nhK : IsCompact K\nhU : \u2200 (x : \u03b1) (hx : x \u2208 K), U x hx \u2208 nhds x\n\u22a2 \u2200 \u2983s t : Set (\u03b1 \u00d7 \u03b1)\u2984, s \u2286 t \u2192 (\u2200 x \u2208 K, \u2203 y, ball x t \u2286 U \u2191y \u22ef) \u2192 \u2200 x \u2208 K, \u2203 y, ball x s \u2286 U \u2191y \u22ef"}, {"line": "exact fun s t hst ht x hx \u21a6 (ht x hx).imp fun y hy \u21a6 Subset.trans (ball_mono hst _) hy", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Filter.HasBasis.lebesgue_number_lemma_nhds {\u03b9' : Sort*} {p : \u03b9' \u2192 Prop}\n    {V : \u03b9' \u2192 Set (\u03b1 \u00d7 \u03b1)} {U : \u03b1 \u2192 Set \u03b1} (hbasis : (\ud835\udce4 \u03b1).HasBasis p V) (hK : IsCompact K)\n    (hU : \u2200 x \u2208 K, U x \u2208 \ud835\udcdd x) : \u2203 i, p i \u2227 \u2200 x \u2208 K, \u2203 y, ball x (V i) \u2286 U y := by\n  refine (hbasis.exists_iff ?_).1 (lebesgue_number_lemma_nhds hK hU)\n  exact fun s t hst ht x hx \u21a6 (ht x hx).imp fun y hy \u21a6 Subset.trans (ball_mono hst _) hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Compact.lean", "context": {"open": ["Uniformity Set Filter UniformSpace", "scoped Topology"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1] {K : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nK : Set \u03b1\n\u03b9' : Sort u_2\np : \u03b9' \u2192 Prop\nV : \u03b9' \u2192 Set (\u03b1 \u00d7 \u03b1)\nU : \u03b1 \u2192 Set \u03b1\nhbasis : (uniformity \u03b1).HasBasis p V\nhK : IsCompact K\nhU : \u2200 x \u2208 K, U x \u2208 nhds x\n\u22a2 \u2203 i, p i \u2227 \u2200 x \u2208 K, \u2203 y, ball x (V i) \u2286 U y"}, {"line": "refine (hbasis.exists_iff ?_).1 (lebesgue_number_lemma_nhds hK hU)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nK : Set \u03b1\n\u03b9' : Sort u_2\np : \u03b9' \u2192 Prop\nV : \u03b9' \u2192 Set (\u03b1 \u00d7 \u03b1)\nU : \u03b1 \u2192 Set \u03b1\nhbasis : (uniformity \u03b1).HasBasis p V\nhK : IsCompact K\nhU : \u2200 x \u2208 K, U x \u2208 nhds x\n\u22a2 \u2200 \u2983s t : Set (\u03b1 \u00d7 \u03b1)\u2984, s \u2286 t \u2192 (\u2200 x \u2208 K, \u2203 y, ball x t \u2286 U y) \u2192 \u2200 x \u2208 K, \u2203 y, ball x s \u2286 U y"}, {"line": "exact fun s t hst ht x hx \u21a6 (ht x hx).imp fun y hy \u21a6 Subset.trans (ball_mono hst _) hy", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Filter.HasBasis.lebesgue_number_lemma_nhdsWithin' {\u03b9' : Sort*} {p : \u03b9' \u2192 Prop}\n    {V : \u03b9' \u2192 Set (\u03b1 \u00d7 \u03b1)} {U : (x : \u03b1) \u2192 x \u2208 K \u2192 Set \u03b1} (hbasis : (\ud835\udce4 \u03b1).HasBasis p V)\n    (hK : IsCompact K) (hU : \u2200 x hx, U x hx \u2208 \ud835\udcdd[K] x) :\n    \u2203 i, p i \u2227 \u2200 x \u2208 K, \u2203 y : K, ball x (V i) \u2229 K \u2286 U y y.2 := by\n  refine (hbasis.exists_iff ?_).1 (lebesgue_number_lemma_nhdsWithin' hK hU)\n  exact fun s t hst ht x hx \u21a6 (ht x hx).imp\n    fun y hy \u21a6 Subset.trans (Set.inter_subset_inter_left K (ball_mono hst _)) hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Compact.lean", "context": {"open": ["Uniformity Set Filter UniformSpace", "scoped Topology"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1] {K : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nK : Set \u03b1\n\u03b9' : Sort u_2\np : \u03b9' \u2192 Prop\nV : \u03b9' \u2192 Set (\u03b1 \u00d7 \u03b1)\nU : (x : \u03b1) \u2192 x \u2208 K \u2192 Set \u03b1\nhbasis : (uniformity \u03b1).HasBasis p V\nhK : IsCompact K\nhU : \u2200 (x : \u03b1) (hx : x \u2208 K), U x hx \u2208 nhdsWithin x K\n\u22a2 \u2203 i, p i \u2227 \u2200 x \u2208 K, \u2203 y, ball x (V i) \u2229 K \u2286 U \u2191y \u22ef"}, {"line": "refine (hbasis.exists_iff ?_).1 (lebesgue_number_lemma_nhdsWithin' hK hU)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nK : Set \u03b1\n\u03b9' : Sort u_2\np : \u03b9' \u2192 Prop\nV : \u03b9' \u2192 Set (\u03b1 \u00d7 \u03b1)\nU : (x : \u03b1) \u2192 x \u2208 K \u2192 Set \u03b1\nhbasis : (uniformity \u03b1).HasBasis p V\nhK : IsCompact K\nhU : \u2200 (x : \u03b1) (hx : x \u2208 K), U x hx \u2208 nhdsWithin x K\n\u22a2 \u2200 \u2983s t : Set (\u03b1 \u00d7 \u03b1)\u2984, s \u2286 t \u2192 (\u2200 x \u2208 K, \u2203 y, ball x t \u2229 K \u2286 U \u2191y \u22ef) \u2192 \u2200 x \u2208 K, \u2203 y, ball x s \u2229 K \u2286 U \u2191y \u22ef"}, {"line": "exact fun s t hst ht x hx \u21a6 (ht x hx).imp\n    fun y hy \u21a6 Subset.trans (Set.inter_subset_inter_left K (ball_mono hst _)) hy", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Filter.HasBasis.lebesgue_number_lemma_nhdsWithin {\u03b9' : Sort*} {p : \u03b9' \u2192 Prop}\n    {V : \u03b9' \u2192 Set (\u03b1 \u00d7 \u03b1)} {U : \u03b1 \u2192 Set \u03b1} (hbasis : (\ud835\udce4 \u03b1).HasBasis p V) (hK : IsCompact K)\n    (hU : \u2200 x \u2208 K, U x \u2208 \ud835\udcdd[K] x) : \u2203 i, p i \u2227 \u2200 x \u2208 K, \u2203 y, ball x (V i) \u2229 K \u2286 U y := by\n  refine (hbasis.exists_iff ?_).1 (lebesgue_number_lemma_nhdsWithin hK hU)\n  exact fun s t hst ht x hx \u21a6 (ht x hx).imp\n    fun y hy \u21a6 Subset.trans (Set.inter_subset_inter_left K (ball_mono hst _)) hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Compact.lean", "context": {"open": ["Uniformity Set Filter UniformSpace", "scoped Topology"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1] {K : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nK : Set \u03b1\n\u03b9' : Sort u_2\np : \u03b9' \u2192 Prop\nV : \u03b9' \u2192 Set (\u03b1 \u00d7 \u03b1)\nU : \u03b1 \u2192 Set \u03b1\nhbasis : (uniformity \u03b1).HasBasis p V\nhK : IsCompact K\nhU : \u2200 x \u2208 K, U x \u2208 nhdsWithin x K\n\u22a2 \u2203 i, p i \u2227 \u2200 x \u2208 K, \u2203 y, ball x (V i) \u2229 K \u2286 U y"}, {"line": "refine (hbasis.exists_iff ?_).1 (lebesgue_number_lemma_nhdsWithin hK hU)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nK : Set \u03b1\n\u03b9' : Sort u_2\np : \u03b9' \u2192 Prop\nV : \u03b9' \u2192 Set (\u03b1 \u00d7 \u03b1)\nU : \u03b1 \u2192 Set \u03b1\nhbasis : (uniformity \u03b1).HasBasis p V\nhK : IsCompact K\nhU : \u2200 x \u2208 K, U x \u2208 nhdsWithin x K\n\u22a2 \u2200 \u2983s t : Set (\u03b1 \u00d7 \u03b1)\u2984, s \u2286 t \u2192 (\u2200 x \u2208 K, \u2203 y, ball x t \u2229 K \u2286 U y) \u2192 \u2200 x \u2208 K, \u2203 y, ball x s \u2229 K \u2286 U y"}, {"line": "exact fun s t hst ht x hx \u21a6 (ht x hx).imp\n    fun y hy \u21a6 Subset.trans (Set.inter_subset_inter_left K (ball_mono hst _)) hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lebesgue_number_lemma_sUnion {S : Set (Set \u03b1)}\n    (hK : IsCompact K) (hopen : \u2200 s \u2208 S, IsOpen s) (hcover : K \u2286 \u22c3\u2080 S) :\n    \u2203 V \u2208 \ud835\udce4 \u03b1, \u2200 x \u2208 K, \u2203 s \u2208 S, ball x V \u2286 s := by\n  rw [sUnion_eq_iUnion] at hcover\n  simpa using lebesgue_number_lemma hK (by simpa) hcover\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Compact.lean", "context": {"open": ["Uniformity Set Filter UniformSpace", "scoped Topology"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1] {K : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nK : Set \u03b1\nS : Set (Set \u03b1)\nhK : IsCompact K\nhopen : \u2200 s \u2208 S, IsOpen s\nhcover : K \u2286 \u22c3\u2080 S\n\u22a2 \u2203 V \u2208 uniformity \u03b1, \u2200 x \u2208 K, \u2203 s \u2208 S, ball x V \u2286 s"}, {"line": "rw [sUnion_eq_iUnion] at hcover", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nK : Set \u03b1\nS : Set (Set \u03b1)\nhK : IsCompact K\nhopen : \u2200 s \u2208 S, IsOpen s\nhcover : K \u2286 \u22c3 i, \u2191i\n\u22a2 \u2203 V \u2208 uniformity \u03b1, \u2200 x \u2208 K, \u2203 s \u2208 S, ball x V \u2286 s"}, {"line": "simpa using lebesgue_number_lemma hK (by simpa) hcover", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Rat.uniformSpace_eq :\n    (AbsoluteValue.abs : AbsoluteValue \u211a \u211a).uniformSpace = PseudoMetricSpace.toUniformSpace := by\n  ext s\n  rw [(AbsoluteValue.hasBasis_uniformity _).mem_iff]\n  rw [Metric.uniformity_basis_dist_rat.mem_iff]\n  simp only [Rat.dist_eq]\n  simp only [AbsoluteValue.abs_apply]\n  simp only [\u2190 Rat.cast_sub]\n  simp only [\u2190 Rat.cast_abs]\n  simp only [Rat.cast_lt]\n  simp only [abs_sub_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/CompareReals.lean", "context": {"open": ["Set Function Filter CauSeq UniformSpace"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 AbsoluteValue.abs.uniformSpace = PseudoMetricSpace.toUniformSpace"}, {"line": "ext s", "tactic_state": "case h.h\ns : Set (\u211a \u00d7 \u211a)\n\u22a2 s \u2208 uniformity \u211a \u2194 s \u2208 uniformity \u211a"}, {"line": "rw [(AbsoluteValue.hasBasis_uniformity _).mem_iff]", "tactic_state": "case h.h\ns : Set (\u211a \u00d7 \u211a)\n\u22a2 (\u2203 i, 0 < i \u2227 {p | AbsoluteValue.abs (p.2 - p.1) < i} \u2286 s) \u2194 s \u2208 uniformity \u211a"}, {"line": "rw [Metric.uniformity_basis_dist_rat.mem_iff]", "tactic_state": "case h.h\ns : Set (\u211a \u00d7 \u211a)\n\u22a2 (\u2203 i, 0 < i \u2227 {p | AbsoluteValue.abs (p.2 - p.1) < i} \u2286 s) \u2194 \u2203 i, 0 < i \u2227 {p | dist p.1 p.2 < \u2191i} \u2286 s"}, {"line": "simp only [Rat.dist_eq]", "tactic_state": "case h.h\ns : Set (\u211a \u00d7 \u211a)\n\u22a2 (\u2203 i, 0 < i \u2227 {p | AbsoluteValue.abs (p.2 - p.1) < i} \u2286 s) \u2194 \u2203 i, 0 < i \u2227 {p | |\u2191p.1 - \u2191p.2| < \u2191i} \u2286 s"}, {"line": "simp only [AbsoluteValue.abs_apply]", "tactic_state": "case h.h\ns : Set (\u211a \u00d7 \u211a)\n\u22a2 (\u2203 i, 0 < i \u2227 {p | |p.2 - p.1| < i} \u2286 s) \u2194 \u2203 i, 0 < i \u2227 {p | |\u2191p.1 - \u2191p.2| < \u2191i} \u2286 s"}, {"line": "simp only [\u2190 Rat.cast_sub]", "tactic_state": "case h.h\ns : Set (\u211a \u00d7 \u211a)\n\u22a2 (\u2203 i, 0 < i \u2227 {p | |p.2 - p.1| < i} \u2286 s) \u2194 \u2203 i, 0 < i \u2227 {p | |\u2191(p.1 - p.2)| < \u2191i} \u2286 s"}, {"line": "simp only [\u2190 Rat.cast_abs]", "tactic_state": "case h.h\ns : Set (\u211a \u00d7 \u211a)\n\u22a2 (\u2203 i, 0 < i \u2227 {p | |p.2 - p.1| < i} \u2286 s) \u2194 \u2203 i, 0 < i \u2227 {p | \u2191|p.1 - p.2| < \u2191i} \u2286 s"}, {"line": "simp only [Rat.cast_lt]", "tactic_state": "case h.h\ns : Set (\u211a \u00d7 \u211a)\n\u22a2 (\u2203 i, 0 < i \u2227 {p | |p.2 - p.1| < i} \u2286 s) \u2194 \u2203 i, 0 < i \u2227 {p | |p.1 - p.2| < i} \u2286 s"}, {"line": "simp only [abs_sub_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.discreteUniformity_iff_idRel_mem_uniformity {X : Type*} [UniformSpace X] :\n    DiscreteUniformity X \u2194 idRel \u2208 uniformity X := by\n  rw [\u2190 uniformSpace_eq_bot]\n  rw [discreteUniformity_iff_eq_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/DiscreteUniformity.lean", "context": {"open": ["Filter UniformSpace"], "variables": ["(X : Type*) [u : UniformSpace X] [DiscreteUniformity X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d : UniformSpace X\n\u22a2 DiscreteUniformity X \u2194 idRel \u2208 uniformity X"}, {"line": "rw [\u2190 uniformSpace_eq_bot]", "tactic_state": "X : Type u_2\ninst\u271d : UniformSpace X\n\u22a2 DiscreteUniformity X \u2194 inst\u271d = \u22a5"}, {"line": "rw [discreteUniformity_iff_eq_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma equicontinuousAt_restrict_iff (F : \u03b9 \u2192 X \u2192 \u03b1) {S : Set X} (x\u2080 : S) :\n    EquicontinuousAt (S.restrict \u2218 F) x\u2080 \u2194 EquicontinuousWithinAt F S x\u2080 := by\n  simp [EquicontinuousWithinAt, EquicontinuousAt,\n    \u2190 eventually_nhds_subtype_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Equicontinuity.lean", "context": {"open": ["UniformSpace Filter Set Uniformity Topology UniformConvergence Function"], "variables": ["{\u03b9 \u03ba X X' Y \u03b1 \u03b1' \u03b2 \u03b2' \u03b3 : Type*} [tX : TopologicalSpace X] [tY : TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nX : Type u_3\n\u03b1 : Type u_6\ntX : TopologicalSpace X\nF : \u03b9 \u2192 X \u2192 \u03b1\nS : Set X\nx\u2080 : \u2191S\n\u22a2 EquicontinuousAt (S.restrict \u2218 F) x\u2080 \u2194 sorry"}, {"line": "simp [EquicontinuousWithinAt, EquicontinuousAt,\n    \u2190 eventually_nhds_subtype_iff]", "tactic_state": "\u03b9 : Type u_1\nX : Type u_3\n\u03b1 : Type u_6\ntX : TopologicalSpace X\nF : \u03b9 \u2192 X \u2192 \u03b1\nS : Set X\nx\u2080 : \u2191S\n\u22a2 (\u2200 U \u2208 uniformity \u03b1, \u2200\u1da0 (x : \u2191S) in nhds x\u2080, \u2200 (i : \u03b9), (F i \u2191x\u2080, F i \u2191x) \u2208 U) \u2194 sorry ()"}]}
{"declaration": "lemma equicontinuousOn_univ (F : \u03b9 \u2192 X \u2192 \u03b1) :\n    EquicontinuousOn F univ \u2194 Equicontinuous F := by\n  simp [EquicontinuousOn, Equicontinuous]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Equicontinuity.lean", "context": {"open": ["UniformSpace Filter Set Uniformity Topology UniformConvergence Function"], "variables": ["{\u03b9 \u03ba X X' Y \u03b1 \u03b1' \u03b2 \u03b2' \u03b3 : Type*} [tX : TopologicalSpace X] [tY : TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nX : Type u_3\n\u03b1 : Type u_6\ntX : TopologicalSpace X\nF : \u03b9 \u2192 X \u2192 \u03b1\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [EquicontinuousOn, Equicontinuous]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma equicontinuous_restrict_iff (F : \u03b9 \u2192 X \u2192 \u03b1) {S : Set X} :\n    Equicontinuous (S.restrict \u2218 F) \u2194 EquicontinuousOn F S := by\n  simp [Equicontinuous, EquicontinuousOn, equicontinuousAt_restrict_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Equicontinuity.lean", "context": {"open": ["UniformSpace Filter Set Uniformity Topology UniformConvergence Function"], "variables": ["{\u03b9 \u03ba X X' Y \u03b1 \u03b1' \u03b2 \u03b2' \u03b3 : Type*} [tX : TopologicalSpace X] [tY : TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nX : Type u_3\n\u03b1 : Type u_6\ntX : TopologicalSpace X\nF : \u03b9 \u2192 X \u2192 \u03b1\nS : Set X\n\u22a2 Equicontinuous (S.restrict \u2218 F) \u2194 sorry"}, {"line": "simp [Equicontinuous, EquicontinuousOn, equicontinuousAt_restrict_iff]", "tactic_state": "\u03b9 : Type u_1\nX : Type u_3\n\u03b1 : Type u_6\ntX : TopologicalSpace X\nF : \u03b9 \u2192 X \u2192 \u03b1\nS : Set X\n\u22a2 (\u2200 (x\u2080 : \u2191S), EquicontinuousAt (S.restrict \u2218 F) x\u2080) \u2194 sorry ()"}]}
{"declaration": "lemma uniformEquicontinuousOn_univ (F : \u03b9 \u2192 \u03b2 \u2192 \u03b1) :\n    UniformEquicontinuousOn F univ \u2194 UniformEquicontinuous F := by\n  simp [UniformEquicontinuousOn, UniformEquicontinuous]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Equicontinuity.lean", "context": {"open": ["UniformSpace Filter Set Uniformity Topology UniformConvergence Function"], "variables": ["{\u03b9 \u03ba X X' Y \u03b1 \u03b1' \u03b2 \u03b2' \u03b3 : Type*} [tX : TopologicalSpace X] [tY : TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_6\n\u03b2 : Type u_8\nF : \u03b9 \u2192 \u03b2 \u2192 \u03b1\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [UniformEquicontinuousOn, UniformEquicontinuous]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem equicontinuousAt_finite [Finite \u03b9] {F : \u03b9 \u2192 X \u2192 \u03b1} {x\u2080 : X} :\n    EquicontinuousAt F x\u2080 \u2194 \u2200 i, ContinuousAt (F i) x\u2080 := by\n  simp [EquicontinuousAt, ContinuousAt, (nhds_basis_uniformity' (\ud835\udce4 \u03b1).basis_sets).tendsto_right_iff,\n    UniformSpace.ball, @forall_swap _ \u03b9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Equicontinuity.lean", "context": {"open": ["UniformSpace Filter Set Uniformity Topology UniformConvergence Function"], "variables": ["{\u03b9 \u03ba X X' Y \u03b1 \u03b1' \u03b2 \u03b2' \u03b3 : Type*} [tX : TopologicalSpace X] [tY : TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nX : Type u_3\n\u03b1 : Type u_6\ntX : TopologicalSpace X\ninst\u271d : Finite \u03b9\nF : \u03b9 \u2192 X \u2192 \u03b1\nx\u2080 : X\n\u22a2 sorry \u2194 \u03b9 \u2192 sorry"}, {"line": "simp [EquicontinuousAt, ContinuousAt, (nhds_basis_uniformity' (\ud835\udce4 \u03b1).basis_sets).tendsto_right_iff,\n    UniformSpace.ball, @forall_swap _ \u03b9]", "tactic_state": "\u03b9 : Type u_1\nX : Type u_3\n\u03b1 : Type u_6\ntX : TopologicalSpace X\ninst\u271d : Finite \u03b9\nF : \u03b9 \u2192 X \u2192 \u03b1\nx\u2080 : X\n\u22a2 sorry () \u2194 \u03b9 \u2192 sorry ()"}]}
{"declaration": "theorem equicontinuousWithinAt_finite [Finite \u03b9] {F : \u03b9 \u2192 X \u2192 \u03b1} {S : Set X} {x\u2080 : X} :\n    EquicontinuousWithinAt F S x\u2080 \u2194 \u2200 i, ContinuousWithinAt (F i) S x\u2080 := by\n  simp [EquicontinuousWithinAt, ContinuousWithinAt,\n    (nhds_basis_uniformity' (\ud835\udce4 \u03b1).basis_sets).tendsto_right_iff, UniformSpace.ball,\n    @forall_swap _ \u03b9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Equicontinuity.lean", "context": {"open": ["UniformSpace Filter Set Uniformity Topology UniformConvergence Function"], "variables": ["{\u03b9 \u03ba X X' Y \u03b1 \u03b1' \u03b2 \u03b2' \u03b3 : Type*} [tX : TopologicalSpace X] [tY : TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nX : Type u_3\n\u03b1 : Type u_6\ntX : TopologicalSpace X\ninst\u271d : Finite \u03b9\nF : \u03b9 \u2192 X \u2192 \u03b1\nS : Set X\nx\u2080 : X\n\u22a2 sorry \u2194 \u03b9 \u2192 sorry"}, {"line": "simp [EquicontinuousWithinAt, ContinuousWithinAt,\n    (nhds_basis_uniformity' (\ud835\udce4 \u03b1).basis_sets).tendsto_right_iff, UniformSpace.ball,\n    @forall_swap _ \u03b9]", "tactic_state": "\u03b9 : Type u_1\nX : Type u_3\n\u03b1 : Type u_6\ntX : TopologicalSpace X\ninst\u271d : Finite \u03b9\nF : \u03b9 \u2192 X \u2192 \u03b1\nS : Set X\nx\u2080 : X\n\u22a2 sorry () \u2194 \u03b9 \u2192 sorry ()"}]}
{"declaration": "theorem equicontinuousWithinAt_iInf_rng {u : \u03ba \u2192 UniformSpace \u03b1'} {F : \u03b9 \u2192 X \u2192 \u03b1'}\n    {S : Set X} {x\u2080 : X} : EquicontinuousWithinAt (u\u03b1 :=  \u2a05 k, u k) F S x\u2080 \u2194\n      \u2200 k, EquicontinuousWithinAt (u\u03b1 :=  u k) F S x\u2080 := by\n  simp only [equicontinuousWithinAt_iff_continuousWithinAt (u\u03b1 := _)]\n  simp only [topologicalSpace]\n  unfold ContinuousWithinAt\n  rw [UniformFun.iInf_eq]\n  rw [toTopologicalSpace_iInf]\n  rw [nhds_iInf]\n  rw [tendsto_iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Equicontinuity.lean", "context": {"open": ["UniformSpace Filter Set Uniformity Topology UniformConvergence Function", "UniformFun"], "variables": ["{\u03b9 \u03ba X X' Y \u03b1 \u03b1' \u03b2 \u03b2' \u03b3 : Type*} [tX : TopologicalSpace X] [tY : TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nX : Type u_3\n\u03b1' : Type u_7\ntX : TopologicalSpace X\nu : \u03ba \u2192 UniformSpace \u03b1'\nF : \u03b9 \u2192 X \u2192 \u03b1'\nS : Set X\nx\u2080 : X\n\u22a2 EquicontinuousWithinAt F S x\u2080 \u2194 \u2200 (k : \u03ba), EquicontinuousWithinAt F S x\u2080"}, {"line": "simp only [equicontinuousWithinAt_iff_continuousWithinAt (u\u03b1 := _)]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nX : Type u_3\n\u03b1' : Type u_7\ntX : TopologicalSpace X\nu : \u03ba \u2192 UniformSpace \u03b1'\nF : \u03b9 \u2192 X \u2192 \u03b1'\nS : Set X\nx\u2080 : X\n\u22a2 ContinuousWithinAt (\u21d1UniformFun.ofFun \u2218 swap F) S x\u2080 \u2194 \u2200 (k : \u03ba), ContinuousWithinAt (\u21d1UniformFun.ofFun \u2218 swap F) S x\u2080"}, {"line": "simp only [topologicalSpace]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nX : Type u_3\n\u03b1' : Type u_7\ntX : TopologicalSpace X\nu : \u03ba \u2192 UniformSpace \u03b1'\nF : \u03b9 \u2192 X \u2192 \u03b1'\nS : Set X\nx\u2080 : X\n\u22a2 ContinuousWithinAt (\u21d1UniformFun.ofFun \u2218 swap F) S x\u2080 \u2194 \u2200 (k : \u03ba), ContinuousWithinAt (\u21d1UniformFun.ofFun \u2218 swap F) S x\u2080"}, {"line": "unfold ContinuousWithinAt", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nX : Type u_3\n\u03b1' : Type u_7\ntX : TopologicalSpace X\nu : \u03ba \u2192 UniformSpace \u03b1'\nF : \u03b9 \u2192 X \u2192 \u03b1'\nS : Set X\nx\u2080 : X\n\u22a2 Tendsto (\u21d1UniformFun.ofFun \u2218 swap F) (nhdsWithin x\u2080 S) (nhds ((\u21d1UniformFun.ofFun \u2218 swap F) x\u2080)) \u2194\n    \u2200 (k : \u03ba), Tendsto (\u21d1UniformFun.ofFun \u2218 swap F) (nhdsWithin x\u2080 S) (nhds ((\u21d1UniformFun.ofFun \u2218 swap F) x\u2080))"}, {"line": "rw [UniformFun.iInf_eq]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nX : Type u_3\n\u03b1' : Type u_7\ntX : TopologicalSpace X\nu : \u03ba \u2192 UniformSpace \u03b1'\nF : \u03b9 \u2192 X \u2192 \u03b1'\nS : Set X\nx\u2080 : X\n\u22a2 Tendsto (\u21d1UniformFun.ofFun \u2218 swap F) (nhdsWithin x\u2080 S) (nhds ((\u21d1UniformFun.ofFun \u2218 swap F) x\u2080)) \u2194\n    \u2200 (k : \u03ba), Tendsto (\u21d1UniformFun.ofFun \u2218 swap F) (nhdsWithin x\u2080 S) (nhds ((\u21d1UniformFun.ofFun \u2218 swap F) x\u2080))"}, {"line": "rw [toTopologicalSpace_iInf]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nX : Type u_3\n\u03b1' : Type u_7\ntX : TopologicalSpace X\nu : \u03ba \u2192 UniformSpace \u03b1'\nF : \u03b9 \u2192 X \u2192 \u03b1'\nS : Set X\nx\u2080 : X\n\u22a2 Tendsto (\u21d1UniformFun.ofFun \u2218 swap F) (nhdsWithin x\u2080 S) (nhds ((\u21d1UniformFun.ofFun \u2218 swap F) x\u2080)) \u2194\n    \u2200 (k : \u03ba), Tendsto (\u21d1UniformFun.ofFun \u2218 swap F) (nhdsWithin x\u2080 S) (nhds ((\u21d1UniformFun.ofFun \u2218 swap F) x\u2080))"}, {"line": "rw [nhds_iInf]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nX : Type u_3\n\u03b1' : Type u_7\ntX : TopologicalSpace X\nu : \u03ba \u2192 UniformSpace \u03b1'\nF : \u03b9 \u2192 X \u2192 \u03b1'\nS : Set X\nx\u2080 : X\n\u22a2 Tendsto (\u21d1UniformFun.ofFun \u2218 swap F) (nhdsWithin x\u2080 S) (\u2a05 i, nhds ((\u21d1UniformFun.ofFun \u2218 swap F) x\u2080)) \u2194\n    \u2200 (k : \u03ba), Tendsto (\u21d1UniformFun.ofFun \u2218 swap F) (nhdsWithin x\u2080 S) (nhds ((\u21d1UniformFun.ofFun \u2218 swap F) x\u2080))"}, {"line": "rw [tendsto_iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem equicontinuousAt_iInf_rng {u : \u03ba \u2192 UniformSpace \u03b1'} {F : \u03b9 \u2192 X \u2192 \u03b1'}\n    {x\u2080 : X} :\n    EquicontinuousAt (u\u03b1 := \u2a05 k, u k) F x\u2080 \u2194 \u2200 k, EquicontinuousAt (u\u03b1 := u k) F x\u2080 := by\n  simp only [\u2190 equicontinuousWithinAt_univ (u\u03b1 := _)]\n  simp only [equicontinuousWithinAt_iInf_rng]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Equicontinuity.lean", "context": {"open": ["UniformSpace Filter Set Uniformity Topology UniformConvergence Function", "UniformFun"], "variables": ["{\u03b9 \u03ba X X' Y \u03b1 \u03b1' \u03b2 \u03b2' \u03b3 : Type*} [tX : TopologicalSpace X] [tY : TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nX : Type u_3\n\u03b1' : Type u_7\ntX : TopologicalSpace X\nu : \u03ba \u2192 UniformSpace \u03b1'\nF : \u03b9 \u2192 X \u2192 \u03b1'\nx\u2080 : X\n\u22a2 EquicontinuousAt F x\u2080 \u2194 \u2200 (k : \u03ba), EquicontinuousAt F x\u2080"}, {"line": "simp only [\u2190 equicontinuousWithinAt_univ (u\u03b1 := _)]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nX : Type u_3\n\u03b1' : Type u_7\ntX : TopologicalSpace X\nu : \u03ba \u2192 UniformSpace \u03b1'\nF : \u03b9 \u2192 X \u2192 \u03b1'\nx\u2080 : X\n\u22a2 EquicontinuousWithinAt F univ x\u2080 \u2194 \u2200 (k : \u03ba), EquicontinuousWithinAt F univ x\u2080"}, {"line": "simp only [equicontinuousWithinAt_iInf_rng]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem equicontinuous_iInf_rng {u : \u03ba \u2192 UniformSpace \u03b1'} {F : \u03b9 \u2192 X \u2192 \u03b1'} :\n    Equicontinuous (u\u03b1 := \u2a05 k, u k) F \u2194 \u2200 k, Equicontinuous (u\u03b1 := u k) F := by\n  simp_rw [equicontinuous_iff_continuous (u\u03b1 := _), UniformFun.topologicalSpace]\n  rw [UniformFun.iInf_eq]\n  rw [toTopologicalSpace_iInf]\n  rw [continuous_iInf_rng]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Equicontinuity.lean", "context": {"open": ["UniformSpace Filter Set Uniformity Topology UniformConvergence Function", "UniformFun"], "variables": ["{\u03b9 \u03ba X X' Y \u03b1 \u03b1' \u03b2 \u03b2' \u03b3 : Type*} [tX : TopologicalSpace X] [tY : TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nX : Type u_3\n\u03b1' : Type u_7\ntX : TopologicalSpace X\nu : \u03ba \u2192 UniformSpace \u03b1'\nF : \u03b9 \u2192 X \u2192 \u03b1'\n\u22a2 Equicontinuous F \u2194 \u2200 (k : \u03ba), Equicontinuous F"}, {"line": "simp_rw [equicontinuous_iff_continuous (u\u03b1 := _), UniformFun.topologicalSpace]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nX : Type u_3\n\u03b1' : Type u_7\ntX : TopologicalSpace X\nu : \u03ba \u2192 UniformSpace \u03b1'\nF : \u03b9 \u2192 X \u2192 \u03b1'\n\u22a2 Continuous (\u21d1UniformFun.ofFun \u2218 swap F) \u2194 \u2200 (k : \u03ba), Continuous (\u21d1UniformFun.ofFun \u2218 swap F)"}, {"line": "rw [UniformFun.iInf_eq]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nX : Type u_3\n\u03b1' : Type u_7\ntX : TopologicalSpace X\nu : \u03ba \u2192 UniformSpace \u03b1'\nF : \u03b9 \u2192 X \u2192 \u03b1'\n\u22a2 Continuous (\u21d1UniformFun.ofFun \u2218 swap F) \u2194 \u2200 (k : \u03ba), Continuous (\u21d1UniformFun.ofFun \u2218 swap F)"}, {"line": "rw [toTopologicalSpace_iInf]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nX : Type u_3\n\u03b1' : Type u_7\ntX : TopologicalSpace X\nu : \u03ba \u2192 UniformSpace \u03b1'\nF : \u03b9 \u2192 X \u2192 \u03b1'\n\u22a2 Continuous (\u21d1UniformFun.ofFun \u2218 swap F) \u2194 \u2200 (k : \u03ba), Continuous (\u21d1UniformFun.ofFun \u2218 swap F)"}, {"line": "rw [continuous_iInf_rng]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem equicontinuousOn_iInf_rng {u : \u03ba \u2192 UniformSpace \u03b1'} {F : \u03b9 \u2192 X \u2192 \u03b1'}\n    {S : Set X} :\n    EquicontinuousOn (u\u03b1 := \u2a05 k, u k) F S \u2194 \u2200 k, EquicontinuousOn (u\u03b1 := u k) F S := by\n  simp_rw [EquicontinuousOn, equicontinuousWithinAt_iInf_rng, @forall_swap _ \u03ba]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Equicontinuity.lean", "context": {"open": ["UniformSpace Filter Set Uniformity Topology UniformConvergence Function", "UniformFun"], "variables": ["{\u03b9 \u03ba X X' Y \u03b1 \u03b1' \u03b2 \u03b2' \u03b3 : Type*} [tX : TopologicalSpace X] [tY : TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nX : Type u_3\n\u03b1' : Type u_7\ntX : TopologicalSpace X\nu : \u03ba \u2192 UniformSpace \u03b1'\nF : \u03b9 \u2192 X \u2192 \u03b1'\nS : Set X\n\u22a2 EquicontinuousOn F S \u2194 \u2200 (k : \u03ba), EquicontinuousOn F S"}, {"line": "simp_rw [EquicontinuousOn, equicontinuousWithinAt_iInf_rng, @forall_swap _ \u03ba]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCompact.uniformContinuousOn_of_continuous {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} (hs : IsCompact s)\n    (hf : ContinuousOn f s) : UniformContinuousOn f s := by\n  rw [uniformContinuousOn_iff_restrict]\n  rw [isCompact_iff_compactSpace] at hs\n  rw [continuousOn_iff_continuous_restrict] at hf\n  exact CompactSpace.uniformContinuous_of_continuous hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/HeineCantor.lean", "context": {"open": ["Uniformity Topology Filter UniformSpace Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} [UniformSpace \u03b1] [UniformSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : IsCompact s\nhf : ContinuousOn f s\n\u22a2 UniformContinuousOn f s"}, {"line": "rw [uniformContinuousOn_iff_restrict]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : IsCompact s\nhf : ContinuousOn f s\n\u22a2 UniformContinuous (s.restrict f)"}, {"line": "rw [isCompact_iff_compactSpace] at hs", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : CompactSpace \u2191s\nhf : ContinuousOn f s\n\u22a2 UniformContinuous (s.restrict f)"}, {"line": "rw [continuousOn_iff_continuous_restrict] at hf", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : CompactSpace \u2191s\nhf : Continuous (s.restrict f)\n\u22a2 UniformContinuous (s.restrict f)"}, {"line": "exact CompactSpace.uniformContinuous_of_continuous hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem CompactSpace.uniformEquicontinuous_of_equicontinuous {\u03b9 : Type*} {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1}\n    [CompactSpace \u03b2] (h : Equicontinuous F) : UniformEquicontinuous F := by\n  rw [equicontinuous_iff_continuous] at h\n  rw [uniformEquicontinuous_iff_uniformContinuous]\n  exact CompactSpace.uniformContinuous_of_continuous h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/HeineCantor.lean", "context": {"open": ["Uniformity Topology Filter UniformSpace Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} [UniformSpace \u03b1] [UniformSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b2\n\u03b9 : Type u_4\nF : \u03b9 \u2192 \u03b2 \u2192 \u03b1\ninst\u271d : CompactSpace \u03b2\nh : Equicontinuous F\n\u22a2 UniformEquicontinuous F"}, {"line": "rw [equicontinuous_iff_continuous] at h", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b2\n\u03b9 : Type u_4\nF : \u03b9 \u2192 \u03b2 \u2192 \u03b1\ninst\u271d : CompactSpace \u03b2\nh : Continuous (\u21d1UniformFun.ofFun \u2218 Function.swap F)\n\u22a2 UniformEquicontinuous F"}, {"line": "rw [uniformEquicontinuous_iff_uniformContinuous]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b2\n\u03b9 : Type u_4\nF : \u03b9 \u2192 \u03b2 \u2192 \u03b1\ninst\u271d : CompactSpace \u03b2\nh : Continuous (\u21d1UniformFun.ofFun \u2218 Function.swap F)\n\u22a2 UniformContinuous (\u21d1UniformFun.ofFun \u2218 Function.swap F)"}, {"line": "exact CompactSpace.uniformContinuous_of_continuous h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformity :\n    \ud835\udce4 (Matrix m n \ud835\udd5c) = \u2a05 (i : m) (j : n), (\ud835\udce4 \ud835\udd5c).comap fun a => (a.1 i j, a.2 i j) := by\n  erw [Pi.uniformity]\n  simp_rw [Pi.uniformity, Filter.comap_iInf, Filter.comap_comap]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Matrix.lean", "context": {"open": ["Uniformity Topology"], "variables": ["(m n \ud835\udd5c : Type*) [UniformSpace \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_1\nn : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d : UniformSpace \ud835\udd5c\n\u22a2 uniformity (Matrix m n \ud835\udd5c) = \u2a05 i, \u2a05 j, Filter.comap (fun a => (a.1 i j, a.2 i j)) (uniformity \ud835\udd5c)"}, {"line": "erw [Pi.uniformity]", "tactic_state": "m : Type u_1\nn : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d : UniformSpace \ud835\udd5c\n\u22a2 \u2a05 i, Filter.comap (fun a => (a.1 i, a.2 i)) (uniformity (n \u2192 \ud835\udd5c)) =\n    \u2a05 i, \u2a05 j, Filter.comap (fun a => (a.1 i j, a.2 i j)) (uniformity \ud835\udd5c)"}, {"line": "simp_rw [Pi.uniformity, Filter.comap_iInf, Filter.comap_comap]", "tactic_state": "m : Type u_1\nn : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d : UniformSpace \ud835\udd5c\n\u22a2 \u2a05 i, \u2a05 i_1, Filter.comap ((fun a => (a.1 i_1, a.2 i_1)) \u2218 fun a => (a.1 i, a.2 i)) (uniformity \ud835\udd5c) =\n    \u2a05 i, \u2a05 j, Filter.comap (fun a => (a.1 i j, a.2 i j)) (uniformity \ud835\udd5c)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformContinuous {\u03b2 : Type*} [UniformSpace \u03b2] {f : \u03b2 \u2192 Matrix m n \ud835\udd5c} :\n    UniformContinuous f \u2194 \u2200 i j, UniformContinuous fun x => f x i j := by\n  simp only [UniformContinuous]\n  simp only [Matrix.uniformity]\n  simp only [Filter.tendsto_iInf]\n  simp only [Filter.tendsto_comap_iff]\n  apply Iff.intro <;> intro a <;> apply a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Matrix.lean", "context": {"open": ["Uniformity Topology"], "variables": ["(m n \ud835\udd5c : Type*) [UniformSpace \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_1\nn : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : UniformSpace \ud835\udd5c\n\u03b2 : Type u_4\ninst\u271d : UniformSpace \u03b2\nf : \u03b2 \u2192 Matrix m n \ud835\udd5c\n\u22a2 UniformContinuous f \u2194 \u2200 (i : m) (j : n), UniformContinuous fun x => f x i j"}, {"line": "simp only [UniformContinuous]", "tactic_state": "m : Type u_1\nn : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : UniformSpace \ud835\udd5c\n\u03b2 : Type u_4\ninst\u271d : UniformSpace \u03b2\nf : \u03b2 \u2192 Matrix m n \ud835\udd5c\n\u22a2 Filter.Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b2) (uniformity (Matrix m n \ud835\udd5c)) \u2194\n    \u2200 (i : m) (j : n), Filter.Tendsto (fun x => (f x.1 i j, f x.2 i j)) (uniformity \u03b2) (uniformity \ud835\udd5c)"}, {"line": "simp only [Matrix.uniformity]", "tactic_state": "m : Type u_1\nn : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : UniformSpace \ud835\udd5c\n\u03b2 : Type u_4\ninst\u271d : UniformSpace \u03b2\nf : \u03b2 \u2192 Matrix m n \ud835\udd5c\n\u22a2 Filter.Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b2)\n      (\u2a05 i, \u2a05 j, Filter.comap (fun a => (a.1 i j, a.2 i j)) (uniformity \ud835\udd5c)) \u2194\n    \u2200 (i : m) (j : n), Filter.Tendsto (fun x => (f x.1 i j, f x.2 i j)) (uniformity \u03b2) (uniformity \ud835\udd5c)"}, {"line": "simp only [Filter.tendsto_iInf]", "tactic_state": "m : Type u_1\nn : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : UniformSpace \ud835\udd5c\n\u03b2 : Type u_4\ninst\u271d : UniformSpace \u03b2\nf : \u03b2 \u2192 Matrix m n \ud835\udd5c\n\u22a2 (\u2200 (i : m) (i_1 : n),\n      Filter.Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b2)\n        (Filter.comap (fun a => (a.1 i i_1, a.2 i i_1)) (uniformity \ud835\udd5c))) \u2194\n    \u2200 (i : m) (j : n), Filter.Tendsto (fun x => (f x.1 i j, f x.2 i j)) (uniformity \u03b2) (uniformity \ud835\udd5c)"}, {"line": "simp only [Filter.tendsto_comap_iff]", "tactic_state": "m : Type u_1\nn : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : UniformSpace \ud835\udd5c\n\u03b2 : Type u_4\ninst\u271d : UniformSpace \u03b2\nf : \u03b2 \u2192 Matrix m n \ud835\udd5c\n\u22a2 (\u2200 (i : m) (i_1 : n),\n      Filter.Tendsto ((fun a => (a.1 i i_1, a.2 i i_1)) \u2218 fun x => (f x.1, f x.2)) (uniformity \u03b2) (uniformity \ud835\udd5c)) \u2194\n    \u2200 (i : m) (j : n), Filter.Tendsto (fun x => (f x.1 i j, f x.2 i j)) (uniformity \u03b2) (uniformity \ud835\udd5c)"}, {"line": "apply Iff.intro <;> intro a <;> apply a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformContinuous_pi {\u03b2 : Type*} [UniformSpace \u03b2] {f : \u03b2 \u2192 \u2200 i, \u03b1 i} :\n    UniformContinuous f \u2194 \u2200 i, UniformContinuous fun x => f x i := by\n  simp only [UniformContinuous]\n  simp only [Pi.uniformity]\n  simp only [tendsto_iInf]\n  simp only [tendsto_comap_iff]\n  simp only [Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Pi.lean", "context": {"open": ["scoped Uniformity Topology", "Filter UniformSpace Function Set"], "variables": ["{\u03b9 \u03b9' \u03b2 : Type*} (\u03b1 : \u03b9 \u2192 Type u) [U : \u2200 i, UniformSpace (\u03b1 i)] [UniformSpace \u03b2]", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u\nU : (i : \u03b9) \u2192 UniformSpace (\u03b1 i)\n\u03b2 : Type u_4\ninst\u271d : UniformSpace \u03b2\nf : \u03b2 \u2192 (i : \u03b9) \u2192 \u03b1 i\n\u22a2 UniformContinuous f \u2194 \u2200 (i : \u03b9), UniformContinuous fun x => f x i"}, {"line": "simp only [UniformContinuous]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u\nU : (i : \u03b9) \u2192 UniformSpace (\u03b1 i)\n\u03b2 : Type u_4\ninst\u271d : UniformSpace \u03b2\nf : \u03b2 \u2192 (i : \u03b9) \u2192 \u03b1 i\n\u22a2 Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b2) (uniformity ((i : \u03b9) \u2192 \u03b1 i)) \u2194\n    \u2200 (i : \u03b9), Tendsto (fun x => (f x.1 i, f x.2 i)) (uniformity \u03b2) (uniformity (\u03b1 i))"}, {"line": "simp only [Pi.uniformity]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u\nU : (i : \u03b9) \u2192 UniformSpace (\u03b1 i)\n\u03b2 : Type u_4\ninst\u271d : UniformSpace \u03b2\nf : \u03b2 \u2192 (i : \u03b9) \u2192 \u03b1 i\n\u22a2 Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b2) (\u2a05 i, Filter.comap (fun a => (a.1 i, a.2 i)) (uniformity (\u03b1 i))) \u2194\n    \u2200 (i : \u03b9), Tendsto (fun x => (f x.1 i, f x.2 i)) (uniformity \u03b2) (uniformity (\u03b1 i))"}, {"line": "simp only [tendsto_iInf]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u\nU : (i : \u03b9) \u2192 UniformSpace (\u03b1 i)\n\u03b2 : Type u_4\ninst\u271d : UniformSpace \u03b2\nf : \u03b2 \u2192 (i : \u03b9) \u2192 \u03b1 i\n\u22a2 (\u2200 (i : \u03b9),\n      Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b2) (Filter.comap (fun a => (a.1 i, a.2 i)) (uniformity (\u03b1 i)))) \u2194\n    \u2200 (i : \u03b9), Tendsto (fun x => (f x.1 i, f x.2 i)) (uniformity \u03b2) (uniformity (\u03b1 i))"}, {"line": "simp only [tendsto_comap_iff]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u\nU : (i : \u03b9) \u2192 UniformSpace (\u03b1 i)\n\u03b2 : Type u_4\ninst\u271d : UniformSpace \u03b2\nf : \u03b2 \u2192 (i : \u03b9) \u2192 \u03b1 i\n\u22a2 (\u2200 (i : \u03b9), Tendsto ((fun a => (a.1 i, a.2 i)) \u2218 fun x => (f x.1, f x.2)) (uniformity \u03b2) (uniformity (\u03b1 i))) \u2194\n    \u2200 (i : \u03b9), Tendsto (fun x => (f x.1 i, f x.2 i)) (uniformity \u03b2) (uniformity (\u03b1 i))"}, {"line": "simp only [Function.comp_def]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Pi.uniformSpace_comap_precomp' (\u03c6 : \u03b9' \u2192 \u03b9) :\n    UniformSpace.comap (fun g i' \u21a6 g (\u03c6 i')) (Pi.uniformSpace (fun i' \u21a6 \u03b1 (\u03c6 i'))) =\n    \u2a05 i', UniformSpace.comap (eval (\u03c6 i')) (U (\u03c6 i')) := by\n  simp [Pi.uniformSpace_eq, UniformSpace.comap_iInf, \u2190 UniformSpace.comap_comap, comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Pi.lean", "context": {"open": ["scoped Uniformity Topology", "Filter UniformSpace Function Set"], "variables": ["{\u03b9 \u03b9' \u03b2 : Type*} (\u03b1 : \u03b9 \u2192 Type u) [U : \u2200 i, UniformSpace (\u03b1 i)] [UniformSpace \u03b2]", "{\u03b1}", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : \u03b9 \u2192 Type u\nU : (i : \u03b9) \u2192 UniformSpace (\u03b1 i)\n\u03c6 : \u03b9' \u2192 \u03b9\n\u22a2 UniformSpace.comap (fun g i' => g (\u03c6 i')) (uniformSpace fun i' => \u03b1 (\u03c6 i')) =\n    \u2a05 i', UniformSpace.comap (eval (\u03c6 i')) (U (\u03c6 i'))"}, {"line": "simp [Pi.uniformSpace_eq, UniformSpace.comap_iInf, \u2190 UniformSpace.comap_comap, comp_def]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Pi.uniformSpace_comap_restrict (S : Set \u03b9) :\n    UniformSpace.comap (S.restrict) (Pi.uniformSpace (fun i : S \u21a6 \u03b1 i)) =\n    \u2a05 i \u2208 S, UniformSpace.comap (eval i) (U i) := by\n  simp +unfoldPartialApp\n    [\u2190 iInf_subtype'', \u2190 uniformSpace_comap_precomp' _ ((\u2191) : S \u2192 \u03b9), Set.restrict]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Pi.lean", "context": {"open": ["scoped Uniformity Topology", "Filter UniformSpace Function Set"], "variables": ["{\u03b9 \u03b9' \u03b2 : Type*} (\u03b1 : \u03b9 \u2192 Type u) [U : \u2200 i, UniformSpace (\u03b1 i)] [UniformSpace \u03b2]", "{\u03b1}", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u\nU : (i : \u03b9) \u2192 UniformSpace (\u03b1 i)\nS : Set \u03b9\n\u22a2 UniformSpace.comap S.restrict (uniformSpace fun i => \u03b1 \u2191i) = \u2a05 i \u2208 S, UniformSpace.comap (eval i) (U i)"}, {"line": "simp +unfoldPartialApp\n    [\u2190 iInf_subtype'', \u2190 uniformSpace_comap_precomp' _ ((\u2191) : S \u2192 \u03b9), Set.restrict]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inseparable_iff_clusterPt_uniformity {x y : \u03b1} :\n    Inseparable x y \u2194 ClusterPt (x, y) (\ud835\udce4 \u03b1) := by\n  refine \u27e8fun h \u21a6 .of_nhds_le h.nhds_le_uniformity, fun h \u21a6 ?_\u27e9\n  simp_rw [uniformity_hasBasis_closed.inseparable_iff_uniformity, isClosed_iff_clusterPt]\n  exact fun U \u27e8hU, hUc\u27e9 \u21a6 hUc _ <| h.mono <| le_principal_iff.2 hU\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Separation.lean", "context": {"open": ["Filter Set Function Topology Uniformity UniformSpace"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : UniformSpace \u03b1\nx y : \u03b1\n\u22a2 Inseparable x y \u2194 ClusterPt (x, y) (uniformity \u03b1)"}, {"line": "refine \u27e8fun h \u21a6 .of_nhds_le h.nhds_le_uniformity, fun h \u21a6 ?_\u27e9", "tactic_state": "\u03b1 : Type u\ninst\u271d : UniformSpace \u03b1\nx y : \u03b1\nh : ClusterPt (x, y) (uniformity \u03b1)\n\u22a2 Inseparable x y"}, {"line": "simp_rw [uniformity_hasBasis_closed.inseparable_iff_uniformity, isClosed_iff_clusterPt]", "tactic_state": "\u03b1 : Type u\ninst\u271d : UniformSpace \u03b1\nx y : \u03b1\nh : ClusterPt (x, y) (uniformity \u03b1)\n\u22a2 \u2200 (i : Set (\u03b1 \u00d7 \u03b1)), (i \u2208 uniformity \u03b1 \u2227 \u2200 (a : \u03b1 \u00d7 \u03b1), ClusterPt a (principal i) \u2192 a \u2208 i) \u2192 (x, y) \u2208 id i"}, {"line": "exact fun U \u27e8hU, hUc\u27e9 \u21a6 hUc _ <| h.mono <| le_principal_iff.2 hU", "tactic_state": "No Goals!"}]}
{"declaration": "theorem t0Space_iff_uniformity' :\n    T0Space \u03b1 \u2194 Pairwise fun x y \u21a6 \u2203 r \u2208 \ud835\udce4 \u03b1, (x, y) \u2209 r := by\n  simp [t0Space_iff_not_inseparable, inseparable_iff_ker_uniformity]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Separation.lean", "context": {"open": ["Filter Set Function Topology Uniformity UniformSpace"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : UniformSpace \u03b1\n\u22a2 T0Space \u03b1 \u2194 Pairwise fun x y => \u2203 r \u2208 uniformity \u03b1, (x, y) \u2209 r"}, {"line": "simp [t0Space_iff_not_inseparable, inseparable_iff_ker_uniformity]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem t0Space_iff_ker_uniformity : T0Space \u03b1 \u2194 (\ud835\udce4 \u03b1).ker = diagonal \u03b1 := by\n  simp_rw [t0Space_iff_uniformity, subset_antisymm_iff, diagonal_subset_iff, subset_def,\n    Prod.forall, Filter.mem_ker, mem_diagonal_iff, iff_self_and]\n  exact fun _ x s hs \u21a6 refl_mem_uniformity hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Separation.lean", "context": {"open": ["Filter Set Function Topology Uniformity UniformSpace"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : UniformSpace \u03b1\n\u22a2 T0Space \u03b1 \u2194 (uniformity \u03b1).ker = diagonal \u03b1"}, {"line": "simp_rw [t0Space_iff_uniformity, subset_antisymm_iff, diagonal_subset_iff, subset_def,\n    Prod.forall, Filter.mem_ker, mem_diagonal_iff, iff_self_and]", "tactic_state": "\u03b1 : Type u\ninst\u271d : UniformSpace \u03b1\n\u22a2 (\u2200 (a b : \u03b1), (\u2200 s \u2208 uniformity \u03b1, (a, b) \u2208 s) \u2192 a = b) \u2192 \u2200 (x : \u03b1), \u2200 s \u2208 uniformity \u03b1, (x, x) \u2208 s"}, {"line": "exact fun _ x s hs \u21a6 refl_mem_uniformity hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.Tendsto.inseparable_iff_uniformity {\u03b2} {l : Filter \u03b2} [NeBot l] {f g : \u03b2 \u2192 \u03b1}\n    {a b : \u03b1} (ha : Tendsto f l (\ud835\udcdd a)) (hb : Tendsto g l (\ud835\udcdd b)) :\n    Inseparable a b \u2194 Tendsto (fun x \u21a6 (f x, g x)) l (\ud835\udce4 \u03b1) := by\n  refine \u27e8fun h \u21a6 (ha.prodMk_nhds hb).mono_right h.nhds_le_uniformity, fun h \u21a6 ?_\u27e9\n  rw [inseparable_iff_clusterPt_uniformity]\n  exact (ClusterPt.of_le_nhds (ha.prodMk_nhds hb)).mono h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Separation.lean", "context": {"open": ["Filter Set Function Topology Uniformity UniformSpace"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : UniformSpace \u03b1\n\u03b2 : Type u_1\nl : Filter \u03b2\ninst\u271d : l.NeBot\nf g : \u03b2 \u2192 \u03b1\na b : \u03b1\nha : Tendsto f l (nhds a)\nhb : Tendsto g l (nhds b)\n\u22a2 Inseparable a b \u2194 Tendsto (fun x => (f x, g x)) l (uniformity \u03b1)"}, {"line": "refine \u27e8fun h \u21a6 (ha.prodMk_nhds hb).mono_right h.nhds_le_uniformity, fun h \u21a6 ?_\u27e9", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : UniformSpace \u03b1\n\u03b2 : Type u_1\nl : Filter \u03b2\ninst\u271d : l.NeBot\nf g : \u03b2 \u2192 \u03b1\na b : \u03b1\nha : Tendsto f l (nhds a)\nhb : Tendsto g l (nhds b)\nh : Tendsto (fun x => (f x, g x)) l (uniformity \u03b1)\n\u22a2 Inseparable a b"}, {"line": "rw [inseparable_iff_clusterPt_uniformity]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : UniformSpace \u03b1\n\u03b2 : Type u_1\nl : Filter \u03b2\ninst\u271d : l.NeBot\nf g : \u03b2 \u2192 \u03b1\na b : \u03b1\nha : Tendsto f l (nhds a)\nhb : Tendsto g l (nhds b)\nh : Tendsto (fun x => (f x, g x)) l (uniformity \u03b1)\n\u22a2 ClusterPt (a, b) (uniformity \u03b1)"}, {"line": "exact (ClusterPt.of_le_nhds (ha.prodMk_nhds hb)).mono h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isUniformInducing_iff_uniformSpace {f : \u03b1 \u2192 \u03b2} :\n    IsUniformInducing f \u2194 \u2039UniformSpace \u03b2\u203a.comap f = \u2039UniformSpace \u03b1\u203a := by\n  rw [isUniformInducing_iff]\n  rw [UniformSpace.ext_iff]\n  rw [Filter.ext_iff]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformEmbedding.lean", "context": {"open": ["Filter Function Set Uniformity Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 IsUniformInducing f \u2194 UniformSpace.comap f inst\u271d = inst\u271d\u00b9"}, {"line": "rw [isUniformInducing_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap (fun x => (f x.1, f x.2)) (uniformity \u03b2) = uniformity \u03b1 \u2194 UniformSpace.comap f inst\u271d = inst\u271d\u00b9"}, {"line": "rw [UniformSpace.ext_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 comap (fun x => (f x.1, f x.2)) (uniformity \u03b2) = uniformity \u03b1 \u2194\n    \u2200 (s : Set (\u03b1 \u00d7 \u03b1)), s \u2208 uniformity \u03b1 \u2194 s \u2208 uniformity \u03b1"}, {"line": "rw [Filter.ext_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (s : Set (\u03b1 \u00d7 \u03b1)), s \u2208 comap (fun x => (f x.1, f x.2)) (uniformity \u03b2) \u2194 s \u2208 uniformity \u03b1) \u2194\n    \u2200 (s : Set (\u03b1 \u00d7 \u03b1)), s \u2208 uniformity \u03b1 \u2194 s \u2208 uniformity \u03b1"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma Filter.HasBasis.isUniformInducing_iff {\u03b9 \u03b9'} {p : \u03b9 \u2192 Prop} {p' : \u03b9' \u2192 Prop} {s s'}\n    (h : (\ud835\udce4 \u03b1).HasBasis p s) (h' : (\ud835\udce4 \u03b2).HasBasis p' s') {f : \u03b1 \u2192 \u03b2} :\n    IsUniformInducing f \u2194\n      (\u2200 i, p' i \u2192 \u2203 j, p j \u2227 \u2200 x y, (x, y) \u2208 s j \u2192 (f x, f y) \u2208 s' i) \u2227\n        (\u2200 j, p j \u2192 \u2203 i, p' i \u2227 \u2200 x y, (f x, f y) \u2208 s' i \u2192 (x, y) \u2208 s j) := by\n  simp [isUniformInducing_iff', h.uniformContinuous_iff h', (h'.comap _).le_basis_iff h, subset_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformEmbedding.lean", "context": {"open": ["Filter Function Set Uniformity Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\n\u03b9 : Sort u_1\n\u03b9' : Sort u_2\np : \u03b9 \u2192 Prop\np' : \u03b9' \u2192 Prop\ns : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)\ns' : \u03b9' \u2192 Set (\u03b2 \u00d7 \u03b2)\nh : (uniformity \u03b1).HasBasis p s\nh' : (uniformity \u03b2).HasBasis p' s'\nf : \u03b1 \u2192 \u03b2\n\u22a2 IsUniformInducing f \u2194\n    (\u2200 (i : \u03b9'), p' i \u2192 \u2203 j, p j \u2227 \u2200 (x y : \u03b1), (x, y) \u2208 s j \u2192 (f x, f y) \u2208 s' i) \u2227\n      \u2200 (j : \u03b9), p j \u2192 \u2203 i, p' i \u2227 \u2200 (x y : \u03b1), (f x, f y) \u2208 s' i \u2192 (x, y) \u2208 s j"}, {"line": "simp [isUniformInducing_iff', h.uniformContinuous_iff h', (h'.comap _).le_basis_iff h, subset_def]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\n\u03b9 : Sort u_1\n\u03b9' : Sort u_2\np : \u03b9 \u2192 Prop\np' : \u03b9' \u2192 Prop\ns : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)\ns' : \u03b9' \u2192 Set (\u03b2 \u00d7 \u03b2)\nh : (uniformity \u03b1).HasBasis p s\nh' : (uniformity \u03b2).HasBasis p' s'\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (i' : \u03b9), p i' \u2192 \u2203 i, p' i \u2227 \u2200 (a b : \u03b1), (f a, f b) \u2208 s' i \u2192 (a, b) \u2208 s i') \u2192\n    (UniformContinuous f \u2194 \u2200 (i : \u03b9'), p' i \u2192 \u2203 j, p j \u2227 \u2200 (x y : \u03b1), (x, y) \u2208 s j \u2192 (f x, f y) \u2208 s' i)"}]}
{"declaration": "theorem isUniformEmbedding_iff' {f : \u03b1 \u2192 \u03b2} :\n    IsUniformEmbedding f \u2194\n      Injective f \u2227 UniformContinuous f \u2227 comap (Prod.map f f) (\ud835\udce4 \u03b2) \u2264 \ud835\udce4 \u03b1 := by\n  rw [isUniformEmbedding_iff]\n  rw [and_comm]\n  rw [isUniformInducing_iff']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformEmbedding.lean", "context": {"open": ["Filter Function Set Uniformity Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 IsUniformEmbedding f \u2194 Injective f \u2227 UniformContinuous f \u2227 comap (Prod.map f f) (uniformity \u03b2) \u2264 uniformity \u03b1"}, {"line": "rw [isUniformEmbedding_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 IsUniformInducing f \u2227 Injective f \u2194\n    Injective f \u2227 UniformContinuous f \u2227 comap (Prod.map f f) (uniformity \u03b2) \u2264 uniformity \u03b1"}, {"line": "rw [and_comm]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Injective f \u2227 IsUniformInducing f \u2194\n    Injective f \u2227 UniformContinuous f \u2227 comap (Prod.map f f) (uniformity \u03b2) \u2264 uniformity \u03b1"}, {"line": "rw [isUniformInducing_iff']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem completeSpace_coe_iff_isComplete {s : Set \u03b1} : CompleteSpace s \u2194 IsComplete s := by\n  rw [completeSpace_iff_isComplete_range isUniformEmbedding_subtype_val.isUniformInducing]\n  rw [Subtype.range_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformEmbedding.lean", "context": {"open": ["Filter Function Set Uniformity Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : UniformSpace \u03b1\ns : Set \u03b1\n\u22a2 CompleteSpace \u2191s \u2194 IsComplete s"}, {"line": "rw [completeSpace_iff_isComplete_range isUniformEmbedding_subtype_val.isUniformInducing]", "tactic_state": "\u03b1 : Type u\ninst\u271d : UniformSpace \u03b1\ns : Set \u03b1\n\u22a2 IsComplete (range Subtype.val) \u2194 IsComplete s"}, {"line": "rw [Subtype.range_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_compactConvergence_entourage_iff (X : Set (C(\u03b1, \u03b2) \u00d7 C(\u03b1, \u03b2))) :\n    X \u2208 \ud835\udce4 C(\u03b1, \u03b2) \u2194\n      \u2203 (K : Set \u03b1) (V : Set (\u03b2 \u00d7 \u03b2)), IsCompact K \u2227 V \u2208 \ud835\udce4 \u03b2 \u2227\n        { fg : C(\u03b1, \u03b2) \u00d7 C(\u03b1, \u03b2) | \u2200 x \u2208 K, (fg.1 x, fg.2 x) \u2208 V } \u2286 X := by\n  simp [hasBasis_compactConvergenceUniformity.mem_iff, and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/CompactConvergence.lean", "context": {"open": ["Filter Set Topology UniformSpace", "scoped Uniformity UniformConvergence", "UniformSpace in"], "variables": ["{\u03b1 : Type u\u2081} {\u03b2 : Type u\u2082} [TopologicalSpace \u03b1] [UniformSpace \u03b2]", "(K : Set \u03b1) (V : Set (\u03b2 \u00d7 \u03b2)) (f : C(\u03b1, \u03b2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nX : Set (sorry \u00d7 sorry)\n\u22a2 X \u2208 sorry \u2194 \u2203 K V, sorry \u2227 V \u2208 sorry \u2227 {fg | \u2200 x \u2208 K, (sorry, sorry) \u2208 V} \u2286 X"}, {"line": "simp [hasBasis_compactConvergenceUniformity.mem_iff, and_assoc]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nX : Set (sorry \u00d7 sorry)\n\u22a2 X \u2208 sorry () \u2194 sorry () \u2227 \u2203 x, \u2203 x_1 \u2208 sorry (), {fg | \u2200 x_2 \u2208 x, (sorry (), sorry ()) \u2208 x_1} \u2286 X"}]}
{"declaration": "theorem idRel_subset {s : Set (\u03b1 \u00d7 \u03b1)} : idRel \u2286 s \u2194 \u2200 a, (a, a) \u2208 s := by\n  simp [subset_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ns : Set (\u03b1 \u00d7 \u03b1)\n\u22a2 idRel \u2286 s \u2194 \u2200 (a : \u03b1), (a, a) \u2208 s"}, {"line": "simp [subset_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_singleton_left_of_prod_subset_idRel {X : Type*} {S T : Set X} (hS : S.Nonempty)\n    (hT : T.Nonempty) (h_diag : S \u00d7\u02e2 T \u2286 idRel) : \u2203 x, S = {x} := by\n  rcases hS, hT with \u27e8\u27e8s, hs\u27e9, \u27e8t, ht\u27e9\u27e9\n  refine \u27e8s, eq_singleton_iff_nonempty_unique_mem.mpr \u27e8\u27e8s, hs\u27e9, fun x hx \u21a6 ?_\u27e9\u27e9\n  rw [prod_subset_iff] at h_diag\n  replace hs := h_diag s hs t ht\n  replace hx := h_diag x hx t ht\n  simp only [idRel] at hx hs\n  simp only [mem_setOf_eq] at hx hs\n  rwa [\u2190 hs] at hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\nS T : Set X\nhS : S.Nonempty\nhT : T.Nonempty\nh_diag : S \u00d7\u02e2 T \u2286 idRel\n\u22a2 \u2203 x, S = {x}"}, {"line": "rcases hS, hT with \u27e8\u27e8s, hs\u27e9, \u27e8t, ht\u27e9\u27e9", "tactic_state": "case intro.intro\nX : Type u_2\nS T : Set X\nh_diag : S \u00d7\u02e2 T \u2286 idRel\ns : X\nhs : s \u2208 S\nt : X\nht : t \u2208 T\n\u22a2 \u2203 x, S = {x}"}, {"line": "refine \u27e8s, eq_singleton_iff_nonempty_unique_mem.mpr \u27e8\u27e8s, hs\u27e9, fun x hx \u21a6 ?_\u27e9\u27e9", "tactic_state": "case intro.intro\nX : Type u_2\nS T : Set X\nh_diag : S \u00d7\u02e2 T \u2286 idRel\ns : X\nhs : s \u2208 S\nt : X\nht : t \u2208 T\nx : X\nhx : x \u2208 S\n\u22a2 x = s"}, {"line": "rw [prod_subset_iff] at h_diag", "tactic_state": "case intro.intro\nX : Type u_2\nS T : Set X\nh_diag : \u2200 x \u2208 S, \u2200 y \u2208 T, (x, y) \u2208 idRel\ns : X\nhs : s \u2208 S\nt : X\nht : t \u2208 T\nx : X\nhx : x \u2208 S\n\u22a2 x = s"}, {"line": "replace hs := h_diag s hs t ht", "tactic_state": "case intro.intro\nX : Type u_2\nS T : Set X\nh_diag : \u2200 x \u2208 S, \u2200 y \u2208 T, (x, y) \u2208 idRel\ns t : X\nht : t \u2208 T\nx : X\nhx : x \u2208 S\nhs : (s, t) \u2208 idRel\n\u22a2 x = s"}, {"line": "replace hx := h_diag x hx t ht", "tactic_state": "case intro.intro\nX : Type u_2\nS T : Set X\nh_diag : \u2200 x \u2208 S, \u2200 y \u2208 T, (x, y) \u2208 idRel\ns t : X\nht : t \u2208 T\nx : X\nhs : (s, t) \u2208 idRel\nhx : (x, t) \u2208 idRel\n\u22a2 x = s"}, {"line": "simp only [idRel] at hx hs", "tactic_state": "case intro.intro\nX : Type u_2\nS T : Set X\nh_diag : \u2200 x \u2208 S, \u2200 y \u2208 T, (x, y) \u2208 idRel\ns t : X\nht : t \u2208 T\nx : X\nhs : (s, t) \u2208 {p | p.1 = p.2}\nhx : (x, t) \u2208 {p | p.1 = p.2}\n\u22a2 x = s"}, {"line": "simp only [mem_setOf_eq] at hx hs", "tactic_state": "case intro.intro\nX : Type u_2\nS T : Set X\nh_diag : \u2200 x \u2208 S, \u2200 y \u2208 T, (x, y) \u2208 idRel\ns t : X\nht : t \u2208 T\nx : X\nhs : s = t\nhx : x = t\n\u22a2 x = s"}, {"line": "rwa [\u2190 hs] at hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_singleton_right_prod_subset_idRel {X : Type*} {S T : Set X} (hS : S.Nonempty)\n    (hT : T.Nonempty) (h_diag : S \u00d7\u02e2 T \u2286 idRel) : \u2203 x, T = {x} := by\n  rw [Set.prod_subset_iff] at h_diag\n  replace h_diag := fun x hx y hy => (h_diag y hy x hx).symm\n  exact eq_singleton_left_of_prod_subset_idRel hT hS (prod_subset_iff.mpr h_diag)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\nS T : Set X\nhS : S.Nonempty\nhT : T.Nonempty\nh_diag : S \u00d7\u02e2 T \u2286 idRel\n\u22a2 \u2203 x, T = {x}"}, {"line": "rw [Set.prod_subset_iff] at h_diag", "tactic_state": "X : Type u_2\nS T : Set X\nhS : S.Nonempty\nhT : T.Nonempty\nh_diag : \u2200 x \u2208 S, \u2200 y \u2208 T, (x, y) \u2208 idRel\n\u22a2 \u2203 x, T = {x}"}, {"line": "replace h_diag := fun x hx y hy => (h_diag y hy x hx).symm", "tactic_state": "X : Type u_2\nS T : Set X\nhS : S.Nonempty\nhT : T.Nonempty\nh_diag : \u2200 x \u2208 T, \u2200 y \u2208 S, (y, x).2 = (y, x).1\n\u22a2 \u2203 x, T = {x}"}, {"line": "exact eq_singleton_left_of_prod_subset_idRel hT hS (prod_subset_iff.mpr h_diag)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_singleton_prod_subset_idRel {X : Type*} {S T : Set X} (hS : S.Nonempty)\n    (hT : T.Nonempty) (h_diag : S \u00d7\u02e2 T \u2286 idRel) : \u2203 x, S = {x} \u2227 T = {x} := by\n  obtain \u27e8\u27e8x, hx\u27e9, \u27e8y, hy\u27e9\u27e9 := eq_singleton_left_of_prod_subset_idRel hS hT h_diag,\n    eq_singleton_right_prod_subset_idRel hS hT h_diag\n  refine \u27e8x, \u27e8hx, ?_\u27e9\u27e9\n  rw [hy]\n  rw [Set.singleton_eq_singleton_iff]\n  exact (Set.prod_subset_iff.mp h_diag x (by simp only [hx, Set.mem_singleton]) y\n    (by simp only [hy, Set.mem_singleton])).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\nS T : Set X\nhS : S.Nonempty\nhT : T.Nonempty\nh_diag : S \u00d7\u02e2 T \u2286 idRel\n\u22a2 \u2203 x, S = {x} \u2227 T = {x}"}, {"line": "obtain \u27e8\u27e8x, hx\u27e9, \u27e8y, hy\u27e9\u27e9 := eq_singleton_left_of_prod_subset_idRel hS hT h_diag,\n    eq_singleton_right_prod_subset_idRel hS hT h_diag", "tactic_state": "case intro.intro\nX : Type u_2\nS T : Set X\nhS : S.Nonempty\nhT : T.Nonempty\nh_diag : S \u00d7\u02e2 T \u2286 idRel\nx : X\nhx : S = {x}\ny : X\nhy : T = {y}\n\u22a2 \u2203 x, S = {x} \u2227 T = {x}"}, {"line": "refine \u27e8x, \u27e8hx, ?_\u27e9\u27e9", "tactic_state": "case intro.intro\nX : Type u_2\nS T : Set X\nhS : S.Nonempty\nhT : T.Nonempty\nh_diag : S \u00d7\u02e2 T \u2286 idRel\nx : X\nhx : S = {x}\ny : X\nhy : T = {y}\n\u22a2 T = {x}"}, {"line": "rw [hy]", "tactic_state": "case intro.intro\nX : Type u_2\nS T : Set X\nhS : S.Nonempty\nhT : T.Nonempty\nh_diag : S \u00d7\u02e2 T \u2286 idRel\nx : X\nhx : S = {x}\ny : X\nhy : T = {y}\n\u22a2 {y} = {x}"}, {"line": "rw [Set.singleton_eq_singleton_iff]", "tactic_state": "case intro.intro\nX : Type u_2\nS T : Set X\nhS : S.Nonempty\nhT : T.Nonempty\nh_diag : S \u00d7\u02e2 T \u2286 idRel\nx : X\nhx : S = {x}\ny : X\nhy : T = {y}\n\u22a2 y = x"}, {"line": "exact (Set.prod_subset_iff.mp h_diag x (by simp only [hx, Set.mem_singleton]) y\n    (by simp only [hy, Set.mem_singleton])).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem symmetric_symmetrizeRel (V : Set (\u03b1 \u00d7 \u03b1)) : IsSymmetricRel (symmetrizeRel V) := by\n  simp [IsSymmetricRel, symmetrizeRel, preimage_inter, inter_comm, \u2190 preimage_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\nV : Set (\u03b1 \u00d7 \u03b1)\n\u22a2 IsSymmetricRel (symmetrizeRel V)"}, {"line": "simp [IsSymmetricRel, symmetrizeRel, preimage_inter, inter_comm, \u2190 preimage_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsSymmetricRel.inter {U V : Set (\u03b1 \u00d7 \u03b1)} (hU : IsSymmetricRel U) (hV : IsSymmetricRel V) :\n    IsSymmetricRel (U \u2229 V) := by rw [IsSymmetricRel, preimage_inter, hU.eq, hV.eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\nU V : Set (\u03b1 \u00d7 \u03b1)\nhU : IsSymmetricRel U\nhV : IsSymmetricRel V\n\u22a2 IsSymmetricRel (U \u2229 V)"}, {"line": "rw [IsSymmetricRel, preimage_inter, hU.eq, hV.eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsSymmetricRel.iInter {U : (i : \u03b9) \u2192 Set (\u03b1 \u00d7 \u03b1)} (hU : \u2200 i, IsSymmetricRel (U i)) :\n    IsSymmetricRel (\u22c2 i, U i) := by\n  simp_rw [IsSymmetricRel, preimage_iInter, (hU _).eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b9 : Sort u_1\nU : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)\nhU : \u2200 (i : \u03b9), IsSymmetricRel (U i)\n\u22a2 IsSymmetricRel (\u22c2 i, U i)"}, {"line": "simp_rw [IsSymmetricRel, preimage_iInter, (hU _).eq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsSymmetricRel.sInter {s : Set (Set (\u03b1 \u00d7 \u03b1))} (h : \u2200 i \u2208 s, IsSymmetricRel i) :\n    IsSymmetricRel (\u22c2\u2080 s) := by\n  rw [sInter_eq_iInter]\n  exact IsSymmetricRel.iInter (by simpa)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ns : Set (Set (\u03b1 \u00d7 \u03b1))\nh : \u2200 i \u2208 s, IsSymmetricRel i\n\u22a2 IsSymmetricRel (\u22c2\u2080 s)"}, {"line": "rw [sInter_eq_iInter]", "tactic_state": "\u03b1 : Type ua\ns : Set (Set (\u03b1 \u00d7 \u03b1))\nh : \u2200 i \u2208 s, IsSymmetricRel i\n\u22a2 IsSymmetricRel (\u22c2 i, \u2191i)"}, {"line": "exact IsSymmetricRel.iInter (by simpa)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_uniformity {s : Set \u03b1} :\n    IsOpen s \u2194 \u2200 x \u2208 s, { p : \u03b1 \u00d7 \u03b1 | p.1 = x \u2192 p.2 \u2208 s } \u2208 \ud835\udce4 \u03b1 := by\n  simp only [isOpen_iff_mem_nhds]\n  simp only [nhds_eq_comap_uniformity]\n  simp only [mem_comap_prodMk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\ns : Set \u03b1\n\u22a2 IsOpen s \u2194 \u2200 x \u2208 s, {p | p.1 = x \u2192 p.2 \u2208 s} \u2208 uniformity \u03b1"}, {"line": "simp only [isOpen_iff_mem_nhds]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\ns : Set \u03b1\n\u22a2 (\u2200 x \u2208 s, s \u2208 nhds x) \u2194 \u2200 x \u2208 s, {p | p.1 = x \u2192 p.2 \u2208 s} \u2208 uniformity \u03b1"}, {"line": "simp only [nhds_eq_comap_uniformity]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\ns : Set \u03b1\n\u22a2 (\u2200 x \u2208 s, s \u2208 comap (Prod.mk x) (uniformity \u03b1)) \u2194 \u2200 x \u2208 s, {p | p.1 = x \u2192 p.2 \u2208 s} \u2208 uniformity \u03b1"}, {"line": "simp only [mem_comap_prodMk]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.Tendsto.uniformity_trans {l : Filter \u03b2} {f\u2081 f\u2082 f\u2083 : \u03b2 \u2192 \u03b1}\n    (h\u2081\u2082 : Tendsto (fun x => (f\u2081 x, f\u2082 x)) l (\ud835\udce4 \u03b1))\n    (h\u2082\u2083 : Tendsto (fun x => (f\u2082 x, f\u2083 x)) l (\ud835\udce4 \u03b1)) : Tendsto (fun x => (f\u2081 x, f\u2083 x)) l (\ud835\udce4 \u03b1) := by\n  refine le_trans (le_lift'.2 fun s hs => mem_map.2 ?_) comp_le_uniformity\n  filter_upwards [mem_map.1 (h\u2081\u2082 hs), mem_map.1 (h\u2082\u2083 hs)] with x hx\u2081\u2082 hx\u2082\u2083 using \u27e8_, hx\u2081\u2082, hx\u2082\u2083\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nl : Filter \u03b2\nf\u2081 f\u2082 f\u2083 : \u03b2 \u2192 \u03b1\nh\u2081\u2082 : Tendsto (fun x => (f\u2081 x, f\u2082 x)) l (uniformity \u03b1)\nh\u2082\u2083 : Tendsto (fun x => (f\u2082 x, f\u2083 x)) l (uniformity \u03b1)\n\u22a2 Tendsto (fun x => (f\u2081 x, f\u2083 x)) l (uniformity \u03b1)"}, {"line": "refine le_trans (le_lift'.2 fun s hs => mem_map.2 ?_) comp_le_uniformity", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nl : Filter \u03b2\nf\u2081 f\u2082 f\u2083 : \u03b2 \u2192 \u03b1\nh\u2081\u2082 : Tendsto (fun x => (f\u2081 x, f\u2082 x)) l (uniformity \u03b1)\nh\u2082\u2083 : Tendsto (fun x => (f\u2082 x, f\u2083 x)) l (uniformity \u03b1)\ns : Set (\u03b1 \u00d7 \u03b1)\nhs : s \u2208 uniformity \u03b1\n\u22a2 (fun x => (f\u2081 x, f\u2083 x)) \u207b\u00b9' compRel s s \u2208 l"}, {"line": "filter_upwards [mem_map.1 (h\u2081\u2082 hs), mem_map.1 (h\u2082\u2083 hs)] with x hx\u2081\u2082 hx\u2082\u2083 using \u27e8_, hx\u2081\u2082, hx\u2082\u2083\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_nhds_uniformity_iff_right {x : \u03b1} {s : Set \u03b1} :\n    s \u2208 \ud835\udcdd x \u2194 { p : \u03b1 \u00d7 \u03b1 | p.1 = x \u2192 p.2 \u2208 s } \u2208 \ud835\udce4 \u03b1 := by\n  simp only [nhds_eq_comap_uniformity]\n  simp only [mem_comap_prodMk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ns : Set \u03b1\n\u22a2 s \u2208 nhds x \u2194 {p | p.1 = x \u2192 p.2 \u2208 s} \u2208 uniformity \u03b1"}, {"line": "simp only [nhds_eq_comap_uniformity]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ns : Set \u03b1\n\u22a2 s \u2208 Filter.comap (Prod.mk x) (uniformity \u03b1) \u2194 {p | p.1 = x \u2192 p.2 \u2208 s} \u2208 uniformity \u03b1"}, {"line": "simp only [mem_comap_prodMk]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_nhds_uniformity_iff_left {x : \u03b1} {s : Set \u03b1} :\n    s \u2208 \ud835\udcdd x \u2194 { p : \u03b1 \u00d7 \u03b1 | p.2 = x \u2192 p.1 \u2208 s } \u2208 \ud835\udce4 \u03b1 := by\n  rw [uniformity_eq_symm]\n  rw [mem_nhds_uniformity_iff_right]\n  simp only [map_def]\n  simp only [mem_map]\n  simp only [preimage_setOf_eq]\n  simp only [Prod.snd_swap]\n  simp only [Prod.fst_swap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ns : Set \u03b1\n\u22a2 s \u2208 nhds x \u2194 {p | p.2 = x \u2192 p.1 \u2208 s} \u2208 uniformity \u03b1"}, {"line": "rw [uniformity_eq_symm]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ns : Set \u03b1\n\u22a2 s \u2208 nhds x \u2194 {p | p.2 = x \u2192 p.1 \u2208 s} \u2208 Prod.swap <$> uniformity \u03b1"}, {"line": "rw [mem_nhds_uniformity_iff_right]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ns : Set \u03b1\n\u22a2 {p | p.1 = x \u2192 p.2 \u2208 s} \u2208 uniformity \u03b1 \u2194 {p | p.2 = x \u2192 p.1 \u2208 s} \u2208 Prod.swap <$> uniformity \u03b1"}, {"line": "simp only [map_def]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ns : Set \u03b1\n\u22a2 {p | p.1 = x \u2192 p.2 \u2208 s} \u2208 uniformity \u03b1 \u2194 {p | p.2 = x \u2192 p.1 \u2208 s} \u2208 map Prod.swap (uniformity \u03b1)"}, {"line": "simp only [mem_map]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ns : Set \u03b1\n\u22a2 {p | p.1 = x \u2192 p.2 \u2208 s} \u2208 uniformity \u03b1 \u2194 Prod.swap \u207b\u00b9' {p | p.2 = x \u2192 p.1 \u2208 s} \u2208 uniformity \u03b1"}, {"line": "simp only [preimage_setOf_eq]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ns : Set \u03b1\n\u22a2 {p | p.1 = x \u2192 p.2 \u2208 s} \u2208 uniformity \u03b1 \u2194 {a | a.swap.2 = x \u2192 a.swap.1 \u2208 s} \u2208 uniformity \u03b1"}, {"line": "simp only [Prod.snd_swap]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ns : Set \u03b1\n\u22a2 {p | p.1 = x \u2192 p.2 \u2208 s} \u2208 uniformity \u03b1 \u2194 {a | a.1 = x \u2192 a.swap.1 \u2208 s} \u2208 uniformity \u03b1"}, {"line": "simp only [Prod.fst_swap]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsWithin_eq_comap_uniformity_of_mem {x : \u03b1} {T : Set \u03b1} (hx : x \u2208 T) (S : Set \u03b1) :\n    \ud835\udcdd[S] x = (\ud835\udce4 \u03b1 \u2293 \ud835\udcdf (T \u00d7\u02e2 S)).comap (Prod.mk x) := by\n  simp [nhdsWithin, nhds_eq_comap_uniformity, hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\nT : Set \u03b1\nhx : x \u2208 T\nS : Set \u03b1\n\u22a2 nhdsWithin x S = Filter.comap (Prod.mk x) (uniformity \u03b1 \u2293 principal (T \u00d7\u02e2 S))"}, {"line": "simp [nhdsWithin, nhds_eq_comap_uniformity, hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_iff_ball_subset {s : Set \u03b1} : IsOpen s \u2194 \u2200 x \u2208 s, \u2203 V \u2208 \ud835\udce4 \u03b1, ball x V \u2286 s := by\n  simp_rw [isOpen_iff_mem_nhds, nhds_eq_comap_uniformity, mem_comap, ball]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\ns : Set \u03b1\n\u22a2 IsOpen s \u2194 \u2200 x \u2208 s, \u2203 V \u2208 uniformity \u03b1, ball x V \u2286 s"}, {"line": "simp_rw [isOpen_iff_mem_nhds, nhds_eq_comap_uniformity, mem_comap, ball]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_basis_uniformity' {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)} (h : (\ud835\udce4 \u03b1).HasBasis p s)\n    {x : \u03b1} : (\ud835\udcdd x).HasBasis p fun i => ball x (s i) := by\n  rw [nhds_eq_comap_uniformity]\n  exact h.comap (Prod.mk x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)\nh : (uniformity \u03b1).HasBasis p s\nx : \u03b1\n\u22a2 (nhds x).HasBasis p fun i => ball x (s i)"}, {"line": "rw [nhds_eq_comap_uniformity]", "tactic_state": "\u03b1 : Type ua\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)\nh : (uniformity \u03b1).HasBasis p s\nx : \u03b1\n\u22a2 (Filter.comap (Prod.mk x) (uniformity \u03b1)).HasBasis p fun i => ball x (s i)"}, {"line": "exact h.comap (Prod.mk x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_basis_uniformity {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)} (h : (\ud835\udce4 \u03b1).HasBasis p s)\n    {x : \u03b1} : (\ud835\udcdd x).HasBasis p fun i => { y | (y, x) \u2208 s i } := by\n  replace h := h.comap Prod.swap\n  rw [comap_swap_uniformity] at h\n  exact nhds_basis_uniformity' h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)\nh : (uniformity \u03b1).HasBasis p s\nx : \u03b1\n\u22a2 (nhds x).HasBasis p fun i => {y | (y, x) \u2208 s i}"}, {"line": "replace h := h.comap Prod.swap", "tactic_state": "\u03b1 : Type ua\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)\nx : \u03b1\nh : (Filter.comap Prod.swap (uniformity \u03b1)).HasBasis p fun i => Prod.swap \u207b\u00b9' s i\n\u22a2 (nhds x).HasBasis p fun i => {y | (y, x) \u2208 s i}"}, {"line": "rw [comap_swap_uniformity] at h", "tactic_state": "\u03b1 : Type ua\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)\nx : \u03b1\nh : (uniformity \u03b1).HasBasis p fun i => Prod.swap \u207b\u00b9' s i\n\u22a2 (nhds x).HasBasis p fun i => {y | (y, x) \u2208 s i}"}, {"line": "exact nhds_basis_uniformity' h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UniformSpace.mem_nhds_iff {x : \u03b1} {s : Set \u03b1} : s \u2208 \ud835\udcdd x \u2194 \u2203 V \u2208 \ud835\udce4 \u03b1, ball x V \u2286 s := by\n  rw [nhds_eq_comap_uniformity]\n  rw [mem_comap]\n  simp_rw [ball]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ns : Set \u03b1\n\u22a2 s \u2208 nhds x \u2194 \u2203 V \u2208 uniformity \u03b1, ball x V \u2286 s"}, {"line": "rw [nhds_eq_comap_uniformity]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ns : Set \u03b1\n\u22a2 s \u2208 Filter.comap (Prod.mk x) (uniformity \u03b1) \u2194 \u2203 V \u2208 uniformity \u03b1, ball x V \u2286 s"}, {"line": "rw [mem_comap]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ns : Set \u03b1\n\u22a2 (\u2203 t \u2208 uniformity \u03b1, Prod.mk x \u207b\u00b9' t \u2286 s) \u2194 \u2203 V \u2208 uniformity \u03b1, ball x V \u2286 s"}, {"line": "simp_rw [ball]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UniformSpace.ball_mem_nhds (x : \u03b1) \u2983V : Set (\u03b1 \u00d7 \u03b1)\u2984 (V_in : V \u2208 \ud835\udce4 \u03b1) : ball x V \u2208 \ud835\udcdd x := by\n  rw [UniformSpace.mem_nhds_iff]\n  exact \u27e8V, V_in, Subset.rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\nV : Set (\u03b1 \u00d7 \u03b1)\nV_in : V \u2208 uniformity \u03b1\n\u22a2 ball x V \u2208 nhds x"}, {"line": "rw [UniformSpace.mem_nhds_iff]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\nV : Set (\u03b1 \u00d7 \u03b1)\nV_in : V \u2208 uniformity \u03b1\n\u22a2 \u2203 V_1 \u2208 uniformity \u03b1, ball x V_1 \u2286 ball x V"}, {"line": "exact \u27e8V, V_in, Subset.rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UniformSpace.mem_closure_iff_symm_ball {s : Set \u03b1} {x} :\n    x \u2208 closure s \u2194 \u2200 {V}, V \u2208 \ud835\udce4 \u03b1 \u2192 IsSymmetricRel V \u2192 (s \u2229 ball x V).Nonempty := by\n  simp [mem_closure_iff_nhds_basis (hasBasis_nhds x), Set.Nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\ns : Set \u03b1\nx : \u03b1\n\u22a2 x \u2208 closure s \u2194 \u2200 {V : Set (\u03b1 \u00d7 \u03b1)}, V \u2208 uniformity \u03b1 \u2192 IsSymmetricRel V \u2192 (s \u2229 ball x V).Nonempty"}, {"line": "simp [mem_closure_iff_nhds_basis (hasBasis_nhds x), Set.Nonempty]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\ns : Set \u03b1\nx : \u03b1\n\u22a2 x \u2208 closure s \u2194 \u2200 {V : Set (\u03b1 \u00d7 \u03b1)}, V \u2208 uniformity \u03b1 \u2192 IsSymmetricRel V \u2192 \u2203 x_1 \u2208 s, x_1 \u2208 ball x V"}]}
{"declaration": "theorem lift_nhds_right {x : \u03b1} {g : Set \u03b1 \u2192 Filter \u03b2} (hg : Monotone g) :\n    (\ud835\udcdd x).lift g = (\ud835\udce4 \u03b1).lift fun s : Set (\u03b1 \u00d7 \u03b1) => g { y | (y, x) \u2208 s } := by\n  rw [nhds_eq_comap_uniformity']\n  rw [comap_lift_eq2 hg]\n  simp_rw [Function.comp_def, preimage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhg : Monotone g\n\u22a2 (nhds x).lift g = (uniformity \u03b1).lift fun s => g {y | (y, x) \u2208 s}"}, {"line": "rw [nhds_eq_comap_uniformity']", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhg : Monotone g\n\u22a2 (Filter.comap (fun y => (y, x)) (uniformity \u03b1)).lift g = (uniformity \u03b1).lift fun s => g {y | (y, x) \u2208 s}"}, {"line": "rw [comap_lift_eq2 hg]", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhg : Monotone g\n\u22a2 (uniformity \u03b1).lift (g \u2218 preimage fun y => (y, x)) = (uniformity \u03b1).lift fun s => g {y | (y, x) \u2208 s}"}, {"line": "simp_rw [Function.comp_def, preimage]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_nhds_eq_uniformity_uniformity_prod {a b : \u03b1} :\n    \ud835\udcdd a \u00d7\u02e2 \ud835\udcdd b = (\ud835\udce4 \u03b1).lift fun s : Set (\u03b1 \u00d7 \u03b1) =>\n      (\ud835\udce4 \u03b1).lift' fun t => { y : \u03b1 | (y, a) \u2208 s } \u00d7\u02e2 { y : \u03b1 | (b, y) \u2208 t } := by\n  rw [nhds_eq_uniformity']\n  rw [nhds_eq_uniformity]\n  rw [prod_lift'_lift']\n  exacts [rfl, monotone_preimage, monotone_preimage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\na b : \u03b1\n\u22a2 nhds a \u00d7\u02e2 nhds b = (uniformity \u03b1).lift fun s => (uniformity \u03b1).lift' fun t => {y | (y, a) \u2208 s} \u00d7\u02e2 {y | (b, y) \u2208 t}"}, {"line": "rw [nhds_eq_uniformity']", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\na b : \u03b1\n\u22a2 ((uniformity \u03b1).lift' fun s => {y | (y, a) \u2208 s}) \u00d7\u02e2 nhds b =\n    (uniformity \u03b1).lift fun s => (uniformity \u03b1).lift' fun t => {y | (y, a) \u2208 s} \u00d7\u02e2 {y | (b, y) \u2208 t}"}, {"line": "rw [nhds_eq_uniformity]", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\na b : \u03b1\n\u22a2 ((uniformity \u03b1).lift' fun s => {y | (y, a) \u2208 s}) \u00d7\u02e2 (uniformity \u03b1).lift' (ball b) =\n    (uniformity \u03b1).lift fun s => (uniformity \u03b1).lift' fun t => {y | (y, a) \u2208 s} \u00d7\u02e2 {y | (b, y) \u2208 t}"}, {"line": "rw [prod_lift'_lift']", "tactic_state": "\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\na b : \u03b1\n\u22a2 ((uniformity \u03b1).lift fun s => (uniformity \u03b1).lift' fun t => {y | (y, a) \u2208 s} \u00d7\u02e2 ball b t) =\n    (uniformity \u03b1).lift fun s => (uniformity \u03b1).lift' fun t => {y | (y, a) \u2208 s} \u00d7\u02e2 {y | (b, y) \u2208 t}\n---\ncase hg\u2081\n\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\na b : \u03b1\n\u22a2 Monotone fun s => {y | (y, a) \u2208 s}\n---\ncase hg\u2082\n\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\na b : \u03b1\n\u22a2 Monotone (ball b)"}, {"line": "exacts [rfl, monotone_preimage, monotone_preimage]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.HasBasis.biInter_biUnion_ball {p : \u03b9 \u2192 Prop} {U : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)}\n    (h : HasBasis (\ud835\udce4 \u03b1) p U) (s : Set \u03b1) :\n    (\u22c2 (i) (_ : p i), \u22c3 x \u2208 s, ball x (U i)) = closure s := by\n  ext x\n  simp [mem_closure_iff_nhds_basis (nhds_basis_uniformity h), ball]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\np : \u03b9 \u2192 Prop\nU : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)\nh : (uniformity \u03b1).HasBasis p U\ns : Set \u03b1\n\u22a2 \u22c2 i, \u22c2 (_ : p i), \u22c3 x \u2208 s, ball x (U i) = closure s"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type ua\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\np : \u03b9 \u2192 Prop\nU : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)\nh : (uniformity \u03b1).HasBasis p U\ns : Set \u03b1\nx : \u03b1\n\u22a2 x \u2208 \u22c2 i, \u22c2 (_ : p i), \u22c3 x \u2208 s, ball x (U i) \u2194 x \u2208 closure s"}, {"line": "simp [mem_closure_iff_nhds_basis (nhds_basis_uniformity h), ball]", "tactic_state": "case h\n\u03b1 : Type ua\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\np : \u03b9 \u2192 Prop\nU : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)\nh : (uniformity \u03b1).HasBasis p U\ns : Set \u03b1\nx : \u03b1\n\u22a2 (\u2200 (i : \u03b9), p i \u2192 \u2203 i_2 \u2208 s, (i_2, x) \u2208 U i) \u2194 x \u2208 closure s"}]}
{"declaration": "theorem uniformContinuousOn_univ [UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    UniformContinuousOn f univ \u2194 UniformContinuous f := by\n  rw [UniformContinuousOn]\n  rw [UniformContinuous]\n  rw [univ_prod_univ]\n  rw [principal_univ]\n  rw [inf_top_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Defs.lean", "context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "UniformSpace"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 UniformContinuousOn f univ \u2194 UniformContinuous f"}, {"line": "rw [UniformContinuousOn]", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1 \u2293 principal (univ \u00d7\u02e2 univ)) (uniformity \u03b2) \u2194 UniformContinuous f"}, {"line": "rw [UniformContinuous]", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1 \u2293 principal (univ \u00d7\u02e2 univ)) (uniformity \u03b2) \u2194\n    Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (uniformity \u03b2)"}, {"line": "rw [univ_prod_univ]", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1 \u2293 principal univ) (uniformity \u03b2) \u2194\n    Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (uniformity \u03b2)"}, {"line": "rw [principal_univ]", "tactic_state": "\u03b1 : Type ua\n\u03b2 : Type ub\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1 \u2293 \u22a4) (uniformity \u03b2) \u2194\n    Tendsto (fun x => (f x.1, f x.2)) (uniformity \u03b1) (uniformity \u03b2)"}, {"line": "rw [inf_top_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_coe (h : \u03b1 \u2243\u1d64 \u03b2) : range h = univ := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Equiv.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*}", "[UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3] [UniformSpace \u03b4]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nh : \u03b1 \u2243\u1d64 \u03b2\n\u22a2 range \u21d1h = univ"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendstoLocallyUniformlyOn_univ :\n    TendstoLocallyUniformlyOn F f p univ \u2194 TendstoLocallyUniformly F f p := by\n  simp [TendstoLocallyUniformlyOn, TendstoLocallyUniformly, nhdsWithin_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/LocallyUniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [TopologicalSpace \u03b1] [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\n\u22a2 TendstoLocallyUniformlyOn F f p univ \u2194 TendstoLocallyUniformly F f p"}, {"line": "simp [TendstoLocallyUniformlyOn, TendstoLocallyUniformly, nhdsWithin_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendstoLocallyUniformly_iff_forall_tendsto :\n    TendstoLocallyUniformly F f p \u2194\n      \u2200 x, Tendsto (fun y : \u03b9 \u00d7 \u03b1 => (f y.2, F y.1 y.2)) (p \u00d7\u02e2 \ud835\udcdd x) (\ud835\udce4 \u03b2) := by\n  simp [\u2190 tendstoLocallyUniformlyOn_univ, isOpen_univ.tendstoLocallyUniformlyOn_iff_forall_tendsto]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/LocallyUniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [TopologicalSpace \u03b1] [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\n\u22a2 TendstoLocallyUniformly F f p \u2194 \u2200 (x : \u03b1), Tendsto (fun y => (f y.2, F y.1 y.2)) (p \u00d7\u02e2 nhds x) (uniformity \u03b2)"}, {"line": "simp [\u2190 tendstoLocallyUniformlyOn_univ, isOpen_univ.tendstoLocallyUniformlyOn_iff_forall_tendsto]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TendstoLocallyUniformlyOn.mono (h : TendstoLocallyUniformlyOn F f p s) (h' : s' \u2286 s) :\n    TendstoLocallyUniformlyOn F f p s' := by\n  intro u hu x hx\n  rcases h u hu x (h' hx) with \u27e8t, ht, H\u27e9\n  exact \u27e8t, nhdsWithin_mono x h' ht, H.mono fun n => id\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/LocallyUniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [TopologicalSpace \u03b1] [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\np : Filter \u03b9\nh : TendstoLocallyUniformlyOn F f p s\nh' : s' \u2286 s\n\u22a2 TendstoLocallyUniformlyOn F f p s'"}, {"line": "intro u hu x hx", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\np : Filter \u03b9\nh : TendstoLocallyUniformlyOn F f p s\nh' : s' \u2286 s\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\nx : \u03b1\nhx : x \u2208 s'\n\u22a2 \u2203 t \u2208 nhdsWithin x s', \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u"}, {"line": "rcases h u hu x (h' hx) with \u27e8t, ht, H\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\np : Filter \u03b9\nh : TendstoLocallyUniformlyOn F f p s\nh' : s' \u2286 s\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\nx : \u03b1\nhx : x \u2208 s'\nt : Set \u03b1\nht : t \u2208 nhdsWithin x s\nH : \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u\n\u22a2 \u2203 t \u2208 nhdsWithin x s', \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u"}, {"line": "exact \u27e8t, nhdsWithin_mono x h' ht, H.mono fun n => id\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendstoLocallyUniformlyOn_sUnion (S : Set (Set \u03b1)) (hS : \u2200 s \u2208 S, IsOpen s)\n    (h : \u2200 s \u2208 S, TendstoLocallyUniformlyOn F f p s) : TendstoLocallyUniformlyOn F f p (\u22c3\u2080 S) := by\n  rw [sUnion_eq_biUnion]\n  exact tendstoLocallyUniformlyOn_biUnion hS h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/LocallyUniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [TopologicalSpace \u03b1] [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nS : Set (Set \u03b1)\nhS : \u2200 s \u2208 S, IsOpen s\nh : \u2200 s \u2208 S, TendstoLocallyUniformlyOn F f p s\n\u22a2 TendstoLocallyUniformlyOn F f p (\u22c3\u2080 S)"}, {"line": "rw [sUnion_eq_biUnion]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nS : Set (Set \u03b1)\nhS : \u2200 s \u2208 S, IsOpen s\nh : \u2200 s \u2208 S, TendstoLocallyUniformlyOn F f p s\n\u22a2 TendstoLocallyUniformlyOn F f p (\u22c3 i \u2208 S, i)"}, {"line": "exact tendstoLocallyUniformlyOn_biUnion hS h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TendstoLocallyUniformlyOn.union (hs\u2081 : IsOpen s) (hs\u2082 : IsOpen s')\n    (h\u2081 : TendstoLocallyUniformlyOn F f p s) (h\u2082 : TendstoLocallyUniformlyOn F f p s') :\n    TendstoLocallyUniformlyOn F f p (s \u222a s') := by\n  rw [\u2190 sUnion_pair]\n  refine tendstoLocallyUniformlyOn_sUnion _ ?_ ?_ <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/LocallyUniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [TopologicalSpace \u03b1] [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\np : Filter \u03b9\nhs\u2081 : IsOpen s\nhs\u2082 : IsOpen s'\nh\u2081 : TendstoLocallyUniformlyOn F f p s\nh\u2082 : TendstoLocallyUniformlyOn F f p s'\n\u22a2 TendstoLocallyUniformlyOn F f p (s \u222a s')"}, {"line": "rw [\u2190 sUnion_pair]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\np : Filter \u03b9\nhs\u2081 : IsOpen s\nhs\u2082 : IsOpen s'\nh\u2081 : TendstoLocallyUniformlyOn F f p s\nh\u2082 : TendstoLocallyUniformlyOn F f p s'\n\u22a2 TendstoLocallyUniformlyOn F f p (\u22c3\u2080 {s, s'})"}, {"line": "refine tendstoLocallyUniformlyOn_sUnion _ ?_ ?_ <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact (hs : IsCompact s) :\n    TendstoLocallyUniformlyOn F f p s \u2194 TendstoUniformlyOn F f p s := by\n  haveI : CompactSpace s := isCompact_iff_compactSpace.mp hs\n  refine \u27e8fun h => ?_, TendstoUniformlyOn.tendstoLocallyUniformlyOn\u27e9\n  rwa [tendstoLocallyUniformlyOn_iff_tendstoLocallyUniformly_comp_coe,\n    tendstoLocallyUniformly_iff_tendstoUniformly_of_compactSpace, \u2190\n    tendstoUniformlyOn_iff_tendstoUniformly_comp_coe] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/LocallyUniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [TopologicalSpace \u03b1] [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\nhs : IsCompact s\n\u22a2 TendstoLocallyUniformlyOn F f p s \u2194 TendstoUniformlyOn F f p s"}, {"line": "haveI : CompactSpace s := isCompact_iff_compactSpace.mp hs", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\nhs : IsCompact s\nthis : sorry\n\u22a2 TendstoLocallyUniformlyOn F f p s \u2194 TendstoUniformlyOn F f p s"}, {"line": "refine \u27e8fun h => ?_, TendstoUniformlyOn.tendstoLocallyUniformlyOn\u27e9", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\nhs : IsCompact s\nthis : sorry\nh : TendstoLocallyUniformlyOn F f p s\n\u22a2 TendstoUniformlyOn F f p s"}, {"line": "rwa [tendstoLocallyUniformlyOn_iff_tendstoLocallyUniformly_comp_coe,\n    tendstoLocallyUniformly_iff_tendstoUniformly_of_compactSpace, \u2190\n    tendstoUniformlyOn_iff_tendstoUniformly_comp_coe] at h", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\nhs : IsCompact s\nthis : sorry\nh : TendstoLocallyUniformly (fun i x => F i \u2191x) (f \u2218 Subtype.val) p\n\u22a2 CompactSpace \u2191s"}]}
{"declaration": "theorem TendstoLocallyUniformly.comp [TopologicalSpace \u03b3] (h : TendstoLocallyUniformly F f p)\n    (g : \u03b3 \u2192 \u03b1) (cg : Continuous g) : TendstoLocallyUniformly (fun n => F n \u2218 g) (f \u2218 g) p := by\n  rw [\u2190 tendstoLocallyUniformlyOn_univ] at h \u22a2\n  rw [continuous_iff_continuousOn_univ] at cg\n  exact h.comp _ (mapsTo_univ _ _) cg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/LocallyUniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [TopologicalSpace \u03b1] [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\ninst\u271d : TopologicalSpace \u03b3\nh : TendstoLocallyUniformly F f p\ng : \u03b3 \u2192 \u03b1\ncg : Continuous g\n\u22a2 TendstoLocallyUniformly (fun n => F n \u2218 g) (f \u2218 g) p"}, {"line": "rw [\u2190 tendstoLocallyUniformlyOn_univ] at h \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\ninst\u271d : TopologicalSpace \u03b3\nh : TendstoLocallyUniformlyOn F f p univ\ng : \u03b3 \u2192 \u03b1\ncg : Continuous g\n\u22a2 TendstoLocallyUniformlyOn (fun n => F n \u2218 g) (f \u2218 g) p univ"}, {"line": "rw [continuous_iff_continuousOn_univ] at cg", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\ninst\u271d : TopologicalSpace \u03b3\nh : TendstoLocallyUniformlyOn F f p univ\ng : \u03b3 \u2192 \u03b1\ncg : ContinuousOn g univ\n\u22a2 TendstoLocallyUniformlyOn (fun n => F n \u2218 g) (f \u2218 g) p univ"}, {"line": "exact h.comp _ (mapsTo_univ _ _) cg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendstoLocallyUniformly_iff_filter :\n    TendstoLocallyUniformly F f p \u2194 \u2200 x, TendstoUniformlyOnFilter F f p (\ud835\udcdd x) := by\n  simpa [\u2190 tendstoLocallyUniformlyOn_univ, \u2190 nhdsWithin_univ] using\n    @tendstoLocallyUniformlyOn_iff_filter _ _ _ _ _ F f univ p\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/LocallyUniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [TopologicalSpace \u03b1] [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\n\u22a2 TendstoLocallyUniformly F f p \u2194 \u2200 (x : \u03b1), TendstoUniformlyOnFilter F f p (nhds x)"}, {"line": "simpa [\u2190 tendstoLocallyUniformlyOn_univ, \u2190 nhdsWithin_univ] using\n    @tendstoLocallyUniformlyOn_iff_filter _ _ _ _ _ F f univ p", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TendstoLocallyUniformlyOn.congr {G : \u03b9 \u2192 \u03b1 \u2192 \u03b2} (hf : TendstoLocallyUniformlyOn F f p s)\n    (hg : \u2200 n, s.EqOn (F n) (G n)) : TendstoLocallyUniformlyOn G f p s := by\n  rintro u hu x hx\n  obtain \u27e8t, ht, h\u27e9 := hf u hu x hx\n  refine \u27e8s \u2229 t, inter_mem self_mem_nhdsWithin ht, ?_\u27e9\n  filter_upwards [h] with i hi y hy using hg i hy.1 \u25b8 hi y hy.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/LocallyUniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [TopologicalSpace \u03b1] [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhf : TendstoLocallyUniformlyOn F f p s\nhg : \u2200 (n : \u03b9), EqOn (F n) (G n) s\n\u22a2 TendstoLocallyUniformlyOn G f p s"}, {"line": "rintro u hu x hx", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhf : TendstoLocallyUniformlyOn F f p s\nhg : \u2200 (n : \u03b9), EqOn (F n) (G n) s\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\nx : \u03b1\nhx : x \u2208 s\n\u22a2 \u2203 t \u2208 nhdsWithin x s, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, G n y) \u2208 u"}, {"line": "obtain \u27e8t, ht, h\u27e9 := hf u hu x hx", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhf : TendstoLocallyUniformlyOn F f p s\nhg : \u2200 (n : \u03b9), EqOn (F n) (G n) s\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\nx : \u03b1\nhx : x \u2208 s\nt : Set \u03b1\nht : t \u2208 nhdsWithin x s\nh : \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u\n\u22a2 \u2203 t \u2208 nhdsWithin x s, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, G n y) \u2208 u"}, {"line": "refine \u27e8s \u2229 t, inter_mem self_mem_nhdsWithin ht, ?_\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhf : TendstoLocallyUniformlyOn F f p s\nhg : \u2200 (n : \u03b9), EqOn (F n) (G n) s\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\nx : \u03b1\nhx : x \u2208 s\nt : Set \u03b1\nht : t \u2208 nhdsWithin x s\nh : \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u\n\u22a2 \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 s \u2229 t, (f y, G n y) \u2208 u"}, {"line": "filter_upwards [h] with i hi y hy using hg i hy.1 \u25b8 hi y hy.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TendstoLocallyUniformlyOn.congr_right {g : \u03b1 \u2192 \u03b2} (hf : TendstoLocallyUniformlyOn F f p s)\n    (hg : s.EqOn f g) : TendstoLocallyUniformlyOn F g p s := by\n  rintro u hu x hx\n  obtain \u27e8t, ht, h\u27e9 := hf u hu x hx\n  refine \u27e8s \u2229 t, inter_mem self_mem_nhdsWithin ht, ?_\u27e9\n  filter_upwards [h] with i hi y hy using hg hy.1 \u25b8 hi y hy.2", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/LocallyUniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [TopologicalSpace \u03b1] [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\ng : \u03b1 \u2192 \u03b2\nhf : TendstoLocallyUniformlyOn F f p s\nhg : EqOn f g s\n\u22a2 TendstoLocallyUniformlyOn F g p s"}, {"line": "rintro u hu x hx", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\ng : \u03b1 \u2192 \u03b2\nhf : TendstoLocallyUniformlyOn F f p s\nhg : EqOn f g s\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\nx : \u03b1\nhx : x \u2208 s\n\u22a2 \u2203 t \u2208 nhdsWithin x s, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (g y, F n y) \u2208 u"}, {"line": "obtain \u27e8t, ht, h\u27e9 := hf u hu x hx", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\ng : \u03b1 \u2192 \u03b2\nhf : TendstoLocallyUniformlyOn F f p s\nhg : EqOn f g s\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\nx : \u03b1\nhx : x \u2208 s\nt : Set \u03b1\nht : t \u2208 nhdsWithin x s\nh : \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u\n\u22a2 \u2203 t \u2208 nhdsWithin x s, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (g y, F n y) \u2208 u"}, {"line": "refine \u27e8s \u2229 t, inter_mem self_mem_nhdsWithin ht, ?_\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\ng : \u03b1 \u2192 \u03b2\nhf : TendstoLocallyUniformlyOn F f p s\nhg : EqOn f g s\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\nx : \u03b1\nhx : x \u2208 s\nt : Set \u03b1\nht : t \u2208 nhdsWithin x s\nh : \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u\n\u22a2 \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 s \u2229 t, (g y, F n y) \u2208 u"}, {"line": "filter_upwards [h] with i hi y hy using hg hy.1 \u25b8 hi y hy.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousAt_of_locally_uniform_approx_of_continuousAt\n    (L : \u2200 u \u2208 \ud835\udce4 \u03b2, \u2203 t \u2208 \ud835\udcdd x, \u2203 F, ContinuousAt F x \u2227 \u2200 y \u2208 t, (f y, F y) \u2208 u) :\n    ContinuousAt f x := by\n  rw [\u2190 continuousWithinAt_univ]\n  apply continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt (mem_univ _) _\n  simpa only [exists_prop,nhdsWithin_univ,continuousWithinAt_univ] using L\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformApproximation.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b9 : Type*} [TopologicalSpace \u03b1] [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\nL : \u2200 u \u2208 uniformity \u03b2, \u2203 t \u2208 nhds x, \u2203 F, ContinuousAt F x \u2227 \u2200 y \u2208 t, (f y, F y) \u2208 u\n\u22a2 ContinuousAt f x"}, {"line": "rw [\u2190 continuousWithinAt_univ]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\nL : \u2200 u \u2208 uniformity \u03b2, \u2203 t \u2208 nhds x, \u2203 F, ContinuousAt F x \u2227 \u2200 y \u2208 t, (f y, F y) \u2208 u\n\u22a2 ContinuousWithinAt f univ x"}, {"line": "apply continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt (mem_univ _) _", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\nL : \u2200 u \u2208 uniformity \u03b2, \u2203 t \u2208 nhds x, \u2203 F, ContinuousAt F x \u2227 \u2200 y \u2208 t, (f y, F y) \u2208 u\n\u22a2 \u2200 u \u2208 uniformity \u03b2, \u2203 t \u2208 nhdsWithin x univ, \u2203 F, ContinuousWithinAt F univ x \u2227 \u2200 y \u2208 t, (f y, F y) \u2208 u"}, {"line": "simpa only [exists_prop,nhdsWithin_univ,continuousWithinAt_univ] using L", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_comp_of_locally_uniform_limit (h : ContinuousAt f x) (hg : Tendsto g p (\ud835\udcdd x))\n    (hunif : \u2200 u \u2208 \ud835\udce4 \u03b2, \u2203 t \u2208 \ud835\udcdd x, \u2200\u1da0 n in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u) :\n    Tendsto (fun n => F n (g n)) p (\ud835\udcdd (f x)) := by\n  rw [\u2190 continuousWithinAt_univ] at h\n  rw [\u2190 nhdsWithin_univ] at hunif hg\n  exact tendsto_comp_of_locally_uniform_limit_within h hg hunif\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformApproximation.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b9 : Type*} [TopologicalSpace \u03b1] [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\np : Filter \u03b9\ng : \u03b9 \u2192 \u03b1\nh : ContinuousAt f x\nhg : Tendsto g p (nhds x)\nhunif : \u2200 u \u2208 uniformity \u03b2, \u2203 t \u2208 nhds x, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u\n\u22a2 Tendsto (fun n => F n (g n)) p (nhds (f x))"}, {"line": "rw [\u2190 continuousWithinAt_univ] at h", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\np : Filter \u03b9\ng : \u03b9 \u2192 \u03b1\nh : ContinuousWithinAt f univ x\nhg : Tendsto g p (nhds x)\nhunif : \u2200 u \u2208 uniformity \u03b2, \u2203 t \u2208 nhds x, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u\n\u22a2 Tendsto (fun n => F n (g n)) p (nhds (f x))"}, {"line": "rw [\u2190 nhdsWithin_univ] at hunif hg", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\np : Filter \u03b9\ng : \u03b9 \u2192 \u03b1\nh : ContinuousWithinAt f univ x\nhg : Tendsto g p (nhdsWithin x univ)\nhunif : \u2200 u \u2208 uniformity \u03b2, \u2203 t \u2208 nhdsWithin x univ, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u\n\u22a2 Tendsto (fun n => F n (g n)) p (nhds (f x))"}, {"line": "exact tendsto_comp_of_locally_uniform_limit_within h hg hunif", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendstoUniformlyOn_iff_tendstoUniformlyOnFilter :\n    TendstoUniformlyOn F f p s \u2194 TendstoUniformlyOnFilter F f p (\ud835\udcdf s) := by\n  simp only [TendstoUniformlyOn]\n  simp only [TendstoUniformlyOnFilter]\n  apply forall\u2082_congr\n  simp_rw [eventually_prod_principal_iff]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u22a2 TendstoUniformlyOn F f p s \u2194 TendstoUniformlyOnFilter F f p (principal s)"}, {"line": "simp only [TendstoUniformlyOn]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u22a2 (\u2200 u \u2208 uniformity \u03b2, \u2200\u1da0 (n : \u03b9) in p, \u2200 x \u2208 s, (f x, F n x) \u2208 u) \u2194 TendstoUniformlyOnFilter F f p (principal s)"}, {"line": "simp only [TendstoUniformlyOnFilter]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u22a2 (\u2200 u \u2208 uniformity \u03b2, \u2200\u1da0 (n : \u03b9) in p, \u2200 x \u2208 s, (f x, F n x) \u2208 u) \u2194\n    \u2200 u \u2208 uniformity \u03b2, \u2200\u1da0 (n : \u03b9 \u00d7 \u03b1) in p \u00d7\u02e2 principal s, (f n.2, F n.1 n.2) \u2208 u"}, {"line": "apply forall\u2082_congr", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u22a2 \u2200 a \u2208 uniformity \u03b2,\n    (\u2200\u1da0 (n : \u03b9) in p, \u2200 x \u2208 s, (f x, F n x) \u2208 a) \u2194 \u2200\u1da0 (n : \u03b9 \u00d7 \u03b1) in p \u00d7\u02e2 principal s, (f n.2, F n.1 n.2) \u2208 a"}, {"line": "simp_rw [eventually_prod_principal_iff]", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u22a2 \u2200 a \u2208 uniformity \u03b2, True"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendstoUniformlyOn_iff_tendsto :\n    TendstoUniformlyOn F f p s \u2194\n    Tendsto (fun q : \u03b9 \u00d7 \u03b1 => (f q.2, F q.1 q.2)) (p \u00d7\u02e2 \ud835\udcdf s) (\ud835\udce4 \u03b2) := by\n  simp [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter, tendstoUniformlyOnFilter_iff_tendsto]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u22a2 TendstoUniformlyOn F f p s \u2194 Tendsto (fun q => (f q.2, F q.1 q.2)) (p \u00d7\u02e2 principal s) (uniformity \u03b2)"}, {"line": "simp [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter, tendstoUniformlyOnFilter_iff_tendsto]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendstoUniformly_iff_tendstoUniformlyOnFilter :\n    TendstoUniformly F f p \u2194 TendstoUniformlyOnFilter F f p \u22a4 := by\n  rw [\u2190 tendstoUniformlyOn_univ]\n  rw [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter]\n  rw [principal_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\n\u22a2 TendstoUniformly F f p \u2194 TendstoUniformlyOnFilter F f p \u22a4"}, {"line": "rw [\u2190 tendstoUniformlyOn_univ]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\n\u22a2 TendstoUniformlyOn F f p univ \u2194 TendstoUniformlyOnFilter F f p \u22a4"}, {"line": "rw [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\n\u22a2 TendstoUniformlyOnFilter F f p (principal univ) \u2194 TendstoUniformlyOnFilter F f p \u22a4"}, {"line": "rw [principal_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TendstoUniformly.tendstoUniformlyOnFilter (h : TendstoUniformly F f p) :\n    TendstoUniformlyOnFilter F f p \u22a4 := by rwa [\u2190 tendstoUniformly_iff_tendstoUniformlyOnFilter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nh : TendstoUniformly F f p\n\u22a2 TendstoUniformlyOnFilter F f p \u22a4"}, {"line": "rwa [\u2190 tendstoUniformly_iff_tendstoUniformlyOnFilter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendstoUniformly_iff_tendsto :\n    TendstoUniformly F f p \u2194 Tendsto (fun q : \u03b9 \u00d7 \u03b1 => (f q.2, F q.1 q.2)) (p \u00d7\u02e2 \u22a4) (\ud835\udce4 \u03b2) := by\n  simp [tendstoUniformly_iff_tendstoUniformlyOnFilter, tendstoUniformlyOnFilter_iff_tendsto]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\n\u22a2 TendstoUniformly F f p \u2194 Tendsto (fun q => (f q.2, F q.1 q.2)) (p \u00d7\u02e2 \u22a4) (uniformity \u03b2)"}, {"line": "simp [tendstoUniformly_iff_tendstoUniformlyOnFilter, tendstoUniformlyOnFilter_iff_tendsto]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TendstoUniformlyOnFilter.tendsto_at (h : TendstoUniformlyOnFilter F f p p')\n    (hx : \ud835\udcdf {x} \u2264 p') : Tendsto (fun n => F n x) p <| \ud835\udcdd (f x) := by\n  refine Uniform.tendsto_nhds_right.mpr fun u hu => mem_map.mpr ?_\n  filter_upwards [(h u hu).curry]\n  intro i h\n  simpa using h.filter_mono hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\np : Filter \u03b9\np' : Filter \u03b1\nh : TendstoUniformlyOnFilter F f p p'\nhx : principal {x} \u2264 p'\n\u22a2 Tendsto (fun n => F n x) p (nhds (f x))"}, {"line": "refine Uniform.tendsto_nhds_right.mpr fun u hu => mem_map.mpr ?_", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\np : Filter \u03b9\np' : Filter \u03b1\nh : TendstoUniformlyOnFilter F f p p'\nhx : principal {x} \u2264 p'\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\n\u22a2 (fun x_1 => (f x, F x_1 x)) \u207b\u00b9' u \u2208 p"}, {"line": "filter_upwards [(h u hu).curry]", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\np : Filter \u03b9\np' : Filter \u03b1\nh : TendstoUniformlyOnFilter F f p p'\nhx : principal {x} \u2264 p'\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\n\u22a2 \u2200 (a : \u03b9), (\u2200\u1da0 (y : \u03b1) in p', (f y, F a y) \u2208 u) \u2192 a \u2208 (fun x_1 => (f x, F x_1 x)) \u207b\u00b9' u"}, {"line": "intro i h", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\np : Filter \u03b9\np' : Filter \u03b1\nh\u271d : TendstoUniformlyOnFilter F f p p'\nhx : principal {x} \u2264 p'\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\ni : \u03b9\nh : \u2200\u1da0 (y : \u03b1) in p', (f y, F i y) \u2208 u\n\u22a2 i \u2208 (fun x_1 => (f x, F x_1 x)) \u207b\u00b9' u"}, {"line": "simpa using h.filter_mono hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TendstoUniformlyOnFilter.congr {F' : \u03b9 \u2192 \u03b1 \u2192 \u03b2} (hf : TendstoUniformlyOnFilter F f p p')\n    (hff' : \u2200\u1da0 n : \u03b9 \u00d7 \u03b1 in p \u00d7\u02e2 p', F n.fst n.snd = F' n.fst n.snd) :\n    TendstoUniformlyOnFilter F' f p p' := by\n  refine fun u hu => ((hf u hu).and hff').mono fun n h => ?_\n  rw [\u2190 h.right]\n  exact h.left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\np' : Filter \u03b1\nF' : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhf : TendstoUniformlyOnFilter F f p p'\nhff' : \u2200\u1da0 (n : \u03b9 \u00d7 \u03b1) in p \u00d7\u02e2 p', F n.1 n.2 = F' n.1 n.2\n\u22a2 TendstoUniformlyOnFilter F' f p p'"}, {"line": "refine fun u hu => ((hf u hu).and hff').mono fun n h => ?_", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\np' : Filter \u03b1\nF' : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhf : TendstoUniformlyOnFilter F f p p'\nhff' : \u2200\u1da0 (n : \u03b9 \u00d7 \u03b1) in p \u00d7\u02e2 p', F n.1 n.2 = F' n.1 n.2\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\nn : \u03b9 \u00d7 \u03b1\nh : (f n.2, F n.1 n.2) \u2208 u \u2227 F n.1 n.2 = F' n.1 n.2\n\u22a2 (f n.2, F' n.1 n.2) \u2208 u"}, {"line": "rw [\u2190 h.right]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\np' : Filter \u03b1\nF' : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhf : TendstoUniformlyOnFilter F f p p'\nhff' : \u2200\u1da0 (n : \u03b9 \u00d7 \u03b1) in p \u00d7\u02e2 p', F n.1 n.2 = F' n.1 n.2\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\nn : \u03b9 \u00d7 \u03b1\nh : (f n.2, F n.1 n.2) \u2208 u \u2227 F n.1 n.2 = F' n.1 n.2\n\u22a2 (f n.2, F n.1 n.2) \u2208 u"}, {"line": "exact h.left", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tendstoUniformly_congr {F' : \u03b9 \u2192 \u03b1 \u2192 \u03b2} (hF : F =\u1da0[p] F') :\n    TendstoUniformly F f p \u2194 TendstoUniformly F' f p := by\n  simp_rw [\u2190 tendstoUniformlyOn_univ] at *\n  have HF := EventuallyEq.exists_mem hF\n  exact \u27e8fun h => h.congr (by aesop), fun h => h.congr (by simp_rw [eqOn_comm]; aesop)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nF' : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhF : F =\u1da0[p] F'\n\u22a2 TendstoUniformly F f p \u2194 TendstoUniformly F' f p"}, {"line": "simp_rw [\u2190 tendstoUniformlyOn_univ] at *", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nF' : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhF : F =\u1da0[p] F'\n\u22a2 TendstoUniformlyOn F f p univ \u2194 TendstoUniformlyOn F' f p univ"}, {"line": "have HF := EventuallyEq.exists_mem hF", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nF' : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhF : F =\u1da0[p] F'\nHF : \u2203 s \u2208 p, EqOn F F' s\n\u22a2 TendstoUniformlyOn F f p univ \u2194 TendstoUniformlyOn F' f p univ"}, {"line": "exact \u27e8fun h => h.congr (by aesop), fun h => h.congr (by simp_rw [eqOn_comm]; aesop)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TendstoUniformlyOnFilter.comp (h : TendstoUniformlyOnFilter F f p p') (g : \u03b3 \u2192 \u03b1) :\n    TendstoUniformlyOnFilter (fun n => F n \u2218 g) (f \u2218 g) p (p'.comap g) := by\n  rw [tendstoUniformlyOnFilter_iff_tendsto] at h \u22a2\n  exact h.comp (tendsto_id.prodMap tendsto_comap)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\np' : Filter \u03b1\nh : TendstoUniformlyOnFilter F f p p'\ng : \u03b3 \u2192 \u03b1\n\u22a2 TendstoUniformlyOnFilter (fun n => F n \u2218 g) (f \u2218 g) p (comap g p')"}, {"line": "rw [tendstoUniformlyOnFilter_iff_tendsto] at h \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\np' : Filter \u03b1\nh : Tendsto (fun q => (f q.2, F q.1 q.2)) (p \u00d7\u02e2 p') (uniformity \u03b2)\ng : \u03b3 \u2192 \u03b1\n\u22a2 Tendsto (fun q => ((f \u2218 g) q.2, (F q.1 \u2218 g) q.2)) (p \u00d7\u02e2 comap g p') (uniformity \u03b2)"}, {"line": "exact h.comp (tendsto_id.prodMap tendsto_comap)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TendstoUniformlyOn.comp (h : TendstoUniformlyOn F f p s) (g : \u03b3 \u2192 \u03b1) :\n    TendstoUniformlyOn (fun n => F n \u2218 g) (f \u2218 g) p (g \u207b\u00b9' s) := by\n  rw [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter] at h \u22a2\n  simpa [TendstoUniformlyOn, comap_principal] using TendstoUniformlyOnFilter.comp h g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\nh : TendstoUniformlyOn F f p s\ng : \u03b3 \u2192 \u03b1\n\u22a2 TendstoUniformlyOn (fun n => F n \u2218 g) (f \u2218 g) p (g \u207b\u00b9' s)"}, {"line": "rw [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter] at h \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\nh : TendstoUniformlyOnFilter F f p (principal s)\ng : \u03b3 \u2192 \u03b1\n\u22a2 TendstoUniformlyOnFilter (fun n => F n \u2218 g) (f \u2218 g) p (principal (g \u207b\u00b9' s))"}, {"line": "simpa [TendstoUniformlyOn, comap_principal] using TendstoUniformlyOnFilter.comp h g", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TendstoUniformly.comp (h : TendstoUniformly F f p) (g : \u03b3 \u2192 \u03b1) :\n    TendstoUniformly (fun n => F n \u2218 g) (f \u2218 g) p := by\n  rw [tendstoUniformly_iff_tendstoUniformlyOnFilter] at h \u22a2\n  simpa [principal_univ, comap_principal] using h.comp g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nh : TendstoUniformly F f p\ng : \u03b3 \u2192 \u03b1\n\u22a2 TendstoUniformly (fun n => F n \u2218 g) (f \u2218 g) p"}, {"line": "rw [tendstoUniformly_iff_tendstoUniformlyOnFilter] at h \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nh : TendstoUniformlyOnFilter F f p \u22a4\ng : \u03b3 \u2192 \u03b1\n\u22a2 TendstoUniformlyOnFilter (fun n => F n \u2218 g) (f \u2218 g) p \u22a4"}, {"line": "simpa [principal_univ, comap_principal] using h.comp g", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TendstoUniformlyOnFilter.prodMap {\u03b9' \u03b1' \u03b2' : Type*} [UniformSpace \u03b2'] {F' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'}\n    {f' : \u03b1' \u2192 \u03b2'} {q : Filter \u03b9'} {q' : Filter \u03b1'} (h : TendstoUniformlyOnFilter F f p p')\n    (h' : TendstoUniformlyOnFilter F' f' q q') :\n    TendstoUniformlyOnFilter (fun i : \u03b9 \u00d7 \u03b9' => Prod.map (F i.1) (F' i.2)) (Prod.map f f') (p \u00d7\u02e2 q)\n      (p' \u00d7\u02e2 q') := by\n  rw [tendstoUniformlyOnFilter_iff_tendsto] at h h' \u22a2\n  rw [uniformity_prod_eq_comap_prod]\n  rw [tendsto_comap_iff]\n  rw [\u2190 map_swap4_prod]\n  rw [tendsto_map'_iff]\n  simpa using h.prodMap h'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\np' : Filter \u03b1\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\nf' : \u03b1' \u2192 \u03b2'\nq : Filter \u03b9'\nq' : Filter \u03b1'\nh : TendstoUniformlyOnFilter F f p p'\nh' : TendstoUniformlyOnFilter F' f' q q'\n\u22a2 TendstoUniformlyOnFilter (fun i => Prod.map (F i.1) (F' i.2)) (Prod.map f f') (p \u00d7\u02e2 q) (p' \u00d7\u02e2 q')"}, {"line": "rw [tendstoUniformlyOnFilter_iff_tendsto] at h h' \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\np' : Filter \u03b1\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\nf' : \u03b1' \u2192 \u03b2'\nq : Filter \u03b9'\nq' : Filter \u03b1'\nh : Tendsto (fun q => (f q.2, F q.1 q.2)) (p \u00d7\u02e2 p') (uniformity \u03b2)\nh' : Tendsto (fun q => (f' q.2, F' q.1 q.2)) (q \u00d7\u02e2 q') (uniformity \u03b2')\n\u22a2 Tendsto (fun q => (Prod.map f f' q.2, Prod.map (F q.1.1) (F' q.1.2) q.2)) ((p \u00d7\u02e2 q) \u00d7\u02e2 p' \u00d7\u02e2 q') (uniformity (\u03b2 \u00d7 \u03b2'))"}, {"line": "rw [uniformity_prod_eq_comap_prod]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\np' : Filter \u03b1\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\nf' : \u03b1' \u2192 \u03b2'\nq : Filter \u03b9'\nq' : Filter \u03b1'\nh : Tendsto (fun q => (f q.2, F q.1 q.2)) (p \u00d7\u02e2 p') (uniformity \u03b2)\nh' : Tendsto (fun q => (f' q.2, F' q.1 q.2)) (q \u00d7\u02e2 q') (uniformity \u03b2')\n\u22a2 Tendsto (fun q => (Prod.map f f' q.2, Prod.map (F q.1.1) (F' q.1.2) q.2)) ((p \u00d7\u02e2 q) \u00d7\u02e2 p' \u00d7\u02e2 q')\n    (comap (fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) (uniformity \u03b2 \u00d7\u02e2 uniformity \u03b2'))"}, {"line": "rw [tendsto_comap_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\np' : Filter \u03b1\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\nf' : \u03b1' \u2192 \u03b2'\nq : Filter \u03b9'\nq' : Filter \u03b1'\nh : Tendsto (fun q => (f q.2, F q.1 q.2)) (p \u00d7\u02e2 p') (uniformity \u03b2)\nh' : Tendsto (fun q => (f' q.2, F' q.1 q.2)) (q \u00d7\u02e2 q') (uniformity \u03b2')\n\u22a2 Tendsto ((fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) \u2218 fun q => (Prod.map f f' q.2, Prod.map (F q.1.1) (F' q.1.2) q.2))\n    ((p \u00d7\u02e2 q) \u00d7\u02e2 p' \u00d7\u02e2 q') (uniformity \u03b2 \u00d7\u02e2 uniformity \u03b2')"}, {"line": "rw [\u2190 map_swap4_prod]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\np' : Filter \u03b1\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\nf' : \u03b1' \u2192 \u03b2'\nq : Filter \u03b9'\nq' : Filter \u03b1'\nh : Tendsto (fun q => (f q.2, F q.1 q.2)) (p \u00d7\u02e2 p') (uniformity \u03b2)\nh' : Tendsto (fun q => (f' q.2, F' q.1 q.2)) (q \u00d7\u02e2 q') (uniformity \u03b2')\n\u22a2 Tendsto ((fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) \u2218 fun q => (Prod.map f f' q.2, Prod.map (F q.1.1) (F' q.1.2) q.2))\n    (map (fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) ((p \u00d7\u02e2 p') \u00d7\u02e2 q \u00d7\u02e2 q')) (uniformity \u03b2 \u00d7\u02e2 uniformity \u03b2')"}, {"line": "rw [tendsto_map'_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\np' : Filter \u03b1\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\nf' : \u03b1' \u2192 \u03b2'\nq : Filter \u03b9'\nq' : Filter \u03b1'\nh : Tendsto (fun q => (f q.2, F q.1 q.2)) (p \u00d7\u02e2 p') (uniformity \u03b2)\nh' : Tendsto (fun q => (f' q.2, F' q.1 q.2)) (q \u00d7\u02e2 q') (uniformity \u03b2')\n\u22a2 Tendsto\n    (((fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) \u2218 fun q => (Prod.map f f' q.2, Prod.map (F q.1.1) (F' q.1.2) q.2)) \u2218\n      fun p => ((p.1.1, p.2.1), p.1.2, p.2.2))\n    ((p \u00d7\u02e2 p') \u00d7\u02e2 q \u00d7\u02e2 q') (uniformity \u03b2 \u00d7\u02e2 uniformity \u03b2')"}, {"line": "simpa using h.prodMap h'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TendstoUniformlyOn.prodMap {\u03b9' \u03b1' \u03b2' : Type*} [UniformSpace \u03b2'] {F' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'}\n    {f' : \u03b1' \u2192 \u03b2'} {p' : Filter \u03b9'} {s' : Set \u03b1'} (h : TendstoUniformlyOn F f p s)\n    (h' : TendstoUniformlyOn F' f' p' s') :\n    TendstoUniformlyOn (fun i : \u03b9 \u00d7 \u03b9' => Prod.map (F i.1) (F' i.2)) (Prod.map f f') (p \u00d7\u02e2 p')\n      (s \u00d7\u02e2 s') := by\n  rw [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter] at h h' \u22a2\n  simpa only [prod_principal_principal] using h.prodMap h'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\nf' : \u03b1' \u2192 \u03b2'\np' : Filter \u03b9'\ns' : Set \u03b1'\nh : TendstoUniformlyOn F f p s\nh' : TendstoUniformlyOn F' f' p' s'\n\u22a2 TendstoUniformlyOn (fun i => Prod.map (F i.1) (F' i.2)) (Prod.map f f') (p \u00d7\u02e2 p') (s \u00d7\u02e2 s')"}, {"line": "rw [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter] at h h' \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\nf' : \u03b1' \u2192 \u03b2'\np' : Filter \u03b9'\ns' : Set \u03b1'\nh : TendstoUniformlyOnFilter F f p (principal s)\nh' : TendstoUniformlyOnFilter F' f' p' (principal s')\n\u22a2 TendstoUniformlyOnFilter (fun i => Prod.map (F i.1) (F' i.2)) (Prod.map f f') (p \u00d7\u02e2 p') (principal (s \u00d7\u02e2 s'))"}, {"line": "simpa only [prod_principal_principal] using h.prodMap h'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TendstoUniformly.prodMap {\u03b9' \u03b1' \u03b2' : Type*} [UniformSpace \u03b2'] {F' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'}\n    {f' : \u03b1' \u2192 \u03b2'} {p' : Filter \u03b9'} (h : TendstoUniformly F f p) (h' : TendstoUniformly F' f' p') :\n    TendstoUniformly (fun i : \u03b9 \u00d7 \u03b9' => Prod.map (F i.1) (F' i.2)) (Prod.map f f') (p \u00d7\u02e2 p') := by\n  rw [\u2190 tendstoUniformlyOn_univ] at *\n  rw [\u2190 univ_prod_univ] at *\n  exact h.prodMap h'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\nf' : \u03b1' \u2192 \u03b2'\np' : Filter \u03b9'\nh : TendstoUniformly F f p\nh' : TendstoUniformly F' f' p'\n\u22a2 TendstoUniformly (fun i => Prod.map (F i.1) (F' i.2)) (Prod.map f f') (p \u00d7\u02e2 p')"}, {"line": "rw [\u2190 tendstoUniformlyOn_univ] at *", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\nf' : \u03b1' \u2192 \u03b2'\np' : Filter \u03b9'\nh : TendstoUniformlyOn F f p univ\nh' : TendstoUniformlyOn F' f' p' univ\n\u22a2 TendstoUniformlyOn (fun i => Prod.map (F i.1) (F' i.2)) (Prod.map f f') (p \u00d7\u02e2 p') univ"}, {"line": "rw [\u2190 univ_prod_univ] at *", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\np : Filter \u03b9\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\nf' : \u03b1' \u2192 \u03b2'\np' : Filter \u03b9'\nh : TendstoUniformlyOn F f p univ\nh' : TendstoUniformlyOn F' f' p' univ\n\u22a2 TendstoUniformlyOn (fun i => Prod.map (F i.1) (F' i.2)) (Prod.map f f') (p \u00d7\u02e2 p') (univ \u00d7\u02e2 univ)"}, {"line": "exact h.prodMap h'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_prod_filter_iff {c : \u03b2} :\n    Tendsto (\u21bfF) (p \u00d7\u02e2 p') (\ud835\udcdd c) \u2194 TendstoUniformlyOnFilter F (fun _ => c) p p' := by\n  simp_rw [nhds_eq_comap_uniformity, tendsto_comap_iff]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\np : Filter \u03b9\np' : Filter \u03b1\nc : \u03b2\n\u22a2 Tendsto (\u21bfF) (p \u00d7\u02e2 p') (nhds c) \u2194 TendstoUniformlyOnFilter F (fun x => c) p p'"}, {"line": "simp_rw [nhds_eq_comap_uniformity, tendsto_comap_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\np : Filter \u03b9\np' : Filter \u03b1\nc : \u03b2\n\u22a2 Tendsto (Prod.mk c \u2218 \u21bfF) (p \u00d7\u02e2 p') (uniformity \u03b2) \u2194 TendstoUniformlyOnFilter F (fun x => c) p p'"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_prod_principal_iff {c : \u03b2} :\n    Tendsto (\u21bfF) (p \u00d7\u02e2 \ud835\udcdf s) (\ud835\udcdd c) \u2194 TendstoUniformlyOn F (fun _ => c) p s := by\n  rw [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter]\n  exact tendsto_prod_filter_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\nc : \u03b2\n\u22a2 Tendsto (\u21bfF) (p \u00d7\u02e2 principal s) (nhds c) \u2194 TendstoUniformlyOn F (fun x => c) p s"}, {"line": "rw [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\nc : \u03b2\n\u22a2 Tendsto (\u21bfF) (p \u00d7\u02e2 principal s) (nhds c) \u2194 TendstoUniformlyOnFilter F (fun x => c) p (principal s)"}, {"line": "exact tendsto_prod_filter_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_prod_top_iff {c : \u03b2} :\n    Tendsto (\u21bfF) (p \u00d7\u02e2 \u22a4) (\ud835\udcdd c) \u2194 TendstoUniformly F (fun _ => c) p := by\n  rw [tendstoUniformly_iff_tendstoUniformlyOnFilter]\n  exact tendsto_prod_filter_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\np : Filter \u03b9\nc : \u03b2\n\u22a2 Tendsto (\u21bfF) (p \u00d7\u02e2 \u22a4) (nhds c) \u2194 TendstoUniformly F (fun x => c) p"}, {"line": "rw [tendstoUniformly_iff_tendstoUniformlyOnFilter]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\np : Filter \u03b9\nc : \u03b2\n\u22a2 Tendsto (\u21bfF) (p \u00d7\u02e2 \u22a4) (nhds c) \u2194 TendstoUniformlyOnFilter F (fun x => c) p \u22a4"}, {"line": "exact tendsto_prod_filter_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendstoUniformlyOn_singleton_iff_tendsto :\n    TendstoUniformlyOn F f p {x} \u2194 Tendsto (fun n : \u03b9 => F n x) p (\ud835\udcdd (f x)) := by\n  simp_rw [tendstoUniformlyOn_iff_tendsto, Uniform.tendsto_nhds_right, tendsto_def]\n  exact forall\u2082_congr fun u _ => by simp [mem_prod_principal, preimage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\np : Filter \u03b9\n\u22a2 TendstoUniformlyOn F f p {x} \u2194 Tendsto (fun n => F n x) p (nhds (f x))"}, {"line": "simp_rw [tendstoUniformlyOn_iff_tendsto, Uniform.tendsto_nhds_right, tendsto_def]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\np : Filter \u03b9\n\u22a2 (\u2200 s \u2208 uniformity \u03b2, (fun q => (f q.2, F q.1 q.2)) \u207b\u00b9' s \u2208 p \u00d7\u02e2 principal {x}) \u2194\n    \u2200 s \u2208 uniformity \u03b2, (fun x_1 => (f x, F x_1 x)) \u207b\u00b9' s \u2208 p"}, {"line": "exact forall\u2082_congr fun u _ => by simp [mem_prod_principal, preimage]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.Tendsto.tendstoUniformlyOnFilter_const {g : \u03b9 \u2192 \u03b2} {b : \u03b2} (hg : Tendsto g p (\ud835\udcdd b))\n    (p' : Filter \u03b1) :\n    TendstoUniformlyOnFilter (fun n : \u03b9 => fun _ : \u03b1 => g n) (fun _ : \u03b1 => b) p p' := by\n  simpa only [nhds_eq_comap_uniformity,tendsto_comap_iff] using hg.comp (tendsto_fst (g := p'))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\np : Filter \u03b9\ng : \u03b9 \u2192 \u03b2\nb : \u03b2\nhg : Tendsto g p (nhds b)\np' : Filter \u03b1\n\u22a2 TendstoUniformlyOnFilter (fun n x => g n) (fun x => b) p p'"}, {"line": "simpa only [nhds_eq_comap_uniformity,tendsto_comap_iff] using hg.comp (tendsto_fst (g := p'))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UniformContinuousOn.tendstoUniformly [UniformSpace \u03b1] [UniformSpace \u03b3] {U : Set \u03b1}\n    (hU : U \u2208 \ud835\udcdd x) {F : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (hF : UniformContinuousOn (\u21bfF) (U \u00d7\u02e2 (univ : Set \u03b2))) :\n    TendstoUniformly F (F x) (\ud835\udcdd x) := by\n  simpa only [tendstoUniformlyOn_univ,nhdsWithin_eq_nhds.2 hU]\n    using hF.tendstoUniformlyOn (mem_of_mem_nhds hU)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b2 : UniformSpace \u03b2\nx : \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b3\nU : Set \u03b1\nhU : U \u2208 nhds x\nF : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nhF : UniformContinuousOn (\u21bfF) (U \u00d7\u02e2 univ)\n\u22a2 TendstoUniformly F (F x) (nhds x)"}, {"line": "simpa only [tendstoUniformlyOn_univ,nhdsWithin_eq_nhds.2 hU]\n    using hF.tendstoUniformlyOn (mem_of_mem_nhds hU)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformCauchySeqOn_iff_uniformCauchySeqOnFilter :\n    UniformCauchySeqOn F p s \u2194 UniformCauchySeqOnFilter F p (\ud835\udcdf s) := by\n  simp only [UniformCauchySeqOn]\n  simp only [UniformCauchySeqOnFilter]\n  refine forall\u2082_congr fun u hu => ?_\n  rw [eventually_prod_principal_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u22a2 UniformCauchySeqOn F p s \u2194 UniformCauchySeqOnFilter F p (principal s)"}, {"line": "simp only [UniformCauchySeqOn]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u22a2 (\u2200 u \u2208 uniformity \u03b2, \u2200\u1da0 (m : \u03b9 \u00d7 \u03b9) in p \u00d7\u02e2 p, \u2200 x \u2208 s, (F m.1 x, F m.2 x) \u2208 u) \u2194\n    UniformCauchySeqOnFilter F p (principal s)"}, {"line": "simp only [UniformCauchySeqOnFilter]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u22a2 (\u2200 u \u2208 uniformity \u03b2, \u2200\u1da0 (m : \u03b9 \u00d7 \u03b9) in p \u00d7\u02e2 p, \u2200 x \u2208 s, (F m.1 x, F m.2 x) \u2208 u) \u2194\n    \u2200 u \u2208 uniformity \u03b2, \u2200\u1da0 (m : (\u03b9 \u00d7 \u03b9) \u00d7 \u03b1) in (p \u00d7\u02e2 p) \u00d7\u02e2 principal s, (F m.1.1 m.2, F m.1.2 m.2) \u2208 u"}, {"line": "refine forall\u2082_congr fun u hu => ?_", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\n\u22a2 (\u2200\u1da0 (m : \u03b9 \u00d7 \u03b9) in p \u00d7\u02e2 p, \u2200 x \u2208 s, (F m.1 x, F m.2 x) \u2208 u) \u2194\n    \u2200\u1da0 (m : (\u03b9 \u00d7 \u03b9) \u00d7 \u03b1) in (p \u00d7\u02e2 p) \u00d7\u02e2 principal s, (F m.1.1 m.2, F m.1.2 m.2) \u2208 u"}, {"line": "rw [eventually_prod_principal_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UniformCauchySeqOn.uniformCauchySeqOnFilter (hF : UniformCauchySeqOn F p s) :\n    UniformCauchySeqOnFilter F p (\ud835\udcdf s) := by rwa [\u2190 uniformCauchySeqOn_iff_uniformCauchySeqOnFilter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\nhF : UniformCauchySeqOn F p s\n\u22a2 UniformCauchySeqOnFilter F p (principal s)"}, {"line": "rwa [\u2190 uniformCauchySeqOn_iff_uniformCauchySeqOnFilter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UniformCauchySeqOnFilter.mono_left {p'' : Filter \u03b9} (hf : UniformCauchySeqOnFilter F p p')\n    (hp : p'' \u2264 p) : UniformCauchySeqOnFilter F p'' p' := by\n  intro u hu\n  have := (hf u hu).filter_mono (p'.prod_mono_left (Filter.prod_mono hp hp))\n  exact this.mono (by simp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\np : Filter \u03b9\np' : Filter \u03b1\np'' : Filter \u03b9\nhf : UniformCauchySeqOnFilter F p p'\nhp : p'' \u2264 p\n\u22a2 UniformCauchySeqOnFilter F p'' p'"}, {"line": "intro u hu", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\np : Filter \u03b9\np' : Filter \u03b1\np'' : Filter \u03b9\nhf : UniformCauchySeqOnFilter F p p'\nhp : p'' \u2264 p\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\n\u22a2 \u2200\u1da0 (m : (\u03b9 \u00d7 \u03b9) \u00d7 \u03b1) in (p'' \u00d7\u02e2 p'') \u00d7\u02e2 p', (F m.1.1 m.2, F m.1.2 m.2) \u2208 u"}, {"line": "have := (hf u hu).filter_mono (p'.prod_mono_left (Filter.prod_mono hp hp))", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\np : Filter \u03b9\np' : Filter \u03b1\np'' : Filter \u03b9\nhf : UniformCauchySeqOnFilter F p p'\nhp : p'' \u2264 p\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\nthis : \u2200\u1da0 (x : (\u03b9 \u00d7 \u03b9) \u00d7 \u03b1) in (p'' \u00d7\u02e2 p'') \u00d7\u02e2 p', (F x.1.1 x.2, F x.1.2 x.2) \u2208 u\n\u22a2 \u2200\u1da0 (m : (\u03b9 \u00d7 \u03b9) \u00d7 \u03b1) in (p'' \u00d7\u02e2 p'') \u00d7\u02e2 p', (F m.1.1 m.2, F m.1.2 m.2) \u2208 u"}, {"line": "exact this.mono (by simp)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UniformCauchySeqOn.mono (hf : UniformCauchySeqOn F p s) (hss' : s' \u2286 s) :\n    UniformCauchySeqOn F p s' := by\n  rw [uniformCauchySeqOn_iff_uniformCauchySeqOnFilter] at hf \u22a2\n  exact hf.mono_right (le_principal_iff.mpr <| mem_principal.mpr hss')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\np : Filter \u03b9\nhf : UniformCauchySeqOn F p s\nhss' : s' \u2286 s\n\u22a2 UniformCauchySeqOn F p s'"}, {"line": "rw [uniformCauchySeqOn_iff_uniformCauchySeqOnFilter] at hf \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\np : Filter \u03b9\nhf : UniformCauchySeqOnFilter F p (principal s)\nhss' : s' \u2286 s\n\u22a2 UniformCauchySeqOnFilter F p (principal s')"}, {"line": "exact hf.mono_right (le_principal_iff.mpr <| mem_principal.mpr hss')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UniformCauchySeqOn.comp {\u03b3 : Type*} (hf : UniformCauchySeqOn F p s) (g : \u03b3 \u2192 \u03b1) :\n    UniformCauchySeqOn (fun n => F n \u2218 g) p (g \u207b\u00b9' s) := by\n  rw [uniformCauchySeqOn_iff_uniformCauchySeqOnFilter] at hf \u22a2\n  simpa only [UniformCauchySeqOn,comap_principal] using hf.comp g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u03b3 : Type u_5\nhf : UniformCauchySeqOn F p s\ng : \u03b3 \u2192 \u03b1\n\u22a2 UniformCauchySeqOn (fun n => F n \u2218 g) p (g \u207b\u00b9' s)"}, {"line": "rw [uniformCauchySeqOn_iff_uniformCauchySeqOnFilter] at hf \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u03b3 : Type u_5\nhf : UniformCauchySeqOnFilter F p (principal s)\ng : \u03b3 \u2192 \u03b1\n\u22a2 UniformCauchySeqOnFilter (fun n => F n \u2218 g) p (principal (g \u207b\u00b9' s))"}, {"line": "simpa only [UniformCauchySeqOn,comap_principal] using hf.comp g", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UniformCauchySeqOn.prodMap {\u03b9' \u03b1' \u03b2' : Type*} [UniformSpace \u03b2'] {F' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'}\n    {p' : Filter \u03b9'} {s' : Set \u03b1'} (h : UniformCauchySeqOn F p s)\n    (h' : UniformCauchySeqOn F' p' s') :\n    UniformCauchySeqOn (fun i : \u03b9 \u00d7 \u03b9' => Prod.map (F i.1) (F' i.2)) (p \u00d7\u02e2 p') (s \u00d7\u02e2 s') := by\n  intro u hu\n  rw [uniformity_prod_eq_prod] at hu\n  rw [mem_map] at hu\n  rw [mem_prod_iff] at hu\n  obtain \u27e8v, hv, w, hw, hvw\u27e9 := hu\n  simp_rw [mem_prod, and_imp, Prod.forall, Prod.map_apply]\n  rw [\u2190 Set.image_subset_iff] at hvw\n  apply (tendsto_swap4_prod.eventually ((h v hv).prod_mk (h' w hw))).mono\n  intro x hx a b ha hb\n  exact hvw \u27e8_, mk_mem_prod (hx.1 a ha) (hx.2 b hb), rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\np' : Filter \u03b9'\ns' : Set \u03b1'\nh : UniformCauchySeqOn F p s\nh' : UniformCauchySeqOn F' p' s'\n\u22a2 UniformCauchySeqOn (fun i => Prod.map (F i.1) (F' i.2)) (p \u00d7\u02e2 p') (s \u00d7\u02e2 s')"}, {"line": "intro u hu", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\np' : Filter \u03b9'\ns' : Set \u03b1'\nh : UniformCauchySeqOn F p s\nh' : UniformCauchySeqOn F' p' s'\nu : Set ((\u03b2 \u00d7 \u03b2') \u00d7 \u03b2 \u00d7 \u03b2')\nhu : u \u2208 uniformity (\u03b2 \u00d7 \u03b2')\n\u22a2 \u2200\u1da0 (m : (\u03b9 \u00d7 \u03b9') \u00d7 \u03b9 \u00d7 \u03b9') in (p \u00d7\u02e2 p') \u00d7\u02e2 p \u00d7\u02e2 p',\n    \u2200 x \u2208 s \u00d7\u02e2 s', ((fun i => Prod.map (F i.1) (F' i.2)) m.1 x, (fun i => Prod.map (F i.1) (F' i.2)) m.2 x) \u2208 u"}, {"line": "rw [uniformity_prod_eq_prod] at hu", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\np' : Filter \u03b9'\ns' : Set \u03b1'\nh : UniformCauchySeqOn F p s\nh' : UniformCauchySeqOn F' p' s'\nu : Set ((\u03b2 \u00d7 \u03b2') \u00d7 \u03b2 \u00d7 \u03b2')\nhu : u \u2208 map (fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) (uniformity \u03b2 \u00d7\u02e2 uniformity \u03b2')\n\u22a2 \u2200\u1da0 (m : (\u03b9 \u00d7 \u03b9') \u00d7 \u03b9 \u00d7 \u03b9') in (p \u00d7\u02e2 p') \u00d7\u02e2 p \u00d7\u02e2 p',\n    \u2200 x \u2208 s \u00d7\u02e2 s', ((fun i => Prod.map (F i.1) (F' i.2)) m.1 x, (fun i => Prod.map (F i.1) (F' i.2)) m.2 x) \u2208 u"}, {"line": "rw [mem_map] at hu", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\np' : Filter \u03b9'\ns' : Set \u03b1'\nh : UniformCauchySeqOn F p s\nh' : UniformCauchySeqOn F' p' s'\nu : Set ((\u03b2 \u00d7 \u03b2') \u00d7 \u03b2 \u00d7 \u03b2')\nhu : (fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) \u207b\u00b9' u \u2208 uniformity \u03b2 \u00d7\u02e2 uniformity \u03b2'\n\u22a2 \u2200\u1da0 (m : (\u03b9 \u00d7 \u03b9') \u00d7 \u03b9 \u00d7 \u03b9') in (p \u00d7\u02e2 p') \u00d7\u02e2 p \u00d7\u02e2 p',\n    \u2200 x \u2208 s \u00d7\u02e2 s', ((fun i => Prod.map (F i.1) (F' i.2)) m.1 x, (fun i => Prod.map (F i.1) (F' i.2)) m.2 x) \u2208 u"}, {"line": "rw [mem_prod_iff] at hu", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\np' : Filter \u03b9'\ns' : Set \u03b1'\nh : UniformCauchySeqOn F p s\nh' : UniformCauchySeqOn F' p' s'\nu : Set ((\u03b2 \u00d7 \u03b2') \u00d7 \u03b2 \u00d7 \u03b2')\nhu : \u2203 t\u2081 \u2208 uniformity \u03b2, \u2203 t\u2082 \u2208 uniformity \u03b2', t\u2081 \u00d7\u02e2 t\u2082 \u2286 (fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) \u207b\u00b9' u\n\u22a2 \u2200\u1da0 (m : (\u03b9 \u00d7 \u03b9') \u00d7 \u03b9 \u00d7 \u03b9') in (p \u00d7\u02e2 p') \u00d7\u02e2 p \u00d7\u02e2 p',\n    \u2200 x \u2208 s \u00d7\u02e2 s', ((fun i => Prod.map (F i.1) (F' i.2)) m.1 x, (fun i => Prod.map (F i.1) (F' i.2)) m.2 x) \u2208 u"}, {"line": "obtain \u27e8v, hv, w, hw, hvw\u27e9 := hu", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\np' : Filter \u03b9'\ns' : Set \u03b1'\nh : UniformCauchySeqOn F p s\nh' : UniformCauchySeqOn F' p' s'\nu : Set ((\u03b2 \u00d7 \u03b2') \u00d7 \u03b2 \u00d7 \u03b2')\nv : Set (\u03b2 \u00d7 \u03b2)\nhv : v \u2208 uniformity \u03b2\nw : Set (\u03b2' \u00d7 \u03b2')\nhw : w \u2208 uniformity \u03b2'\nhvw : v \u00d7\u02e2 w \u2286 (fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) \u207b\u00b9' u\n\u22a2 \u2200\u1da0 (m : (\u03b9 \u00d7 \u03b9') \u00d7 \u03b9 \u00d7 \u03b9') in (p \u00d7\u02e2 p') \u00d7\u02e2 p \u00d7\u02e2 p',\n    \u2200 x \u2208 s \u00d7\u02e2 s', ((fun i => Prod.map (F i.1) (F' i.2)) m.1 x, (fun i => Prod.map (F i.1) (F' i.2)) m.2 x) \u2208 u"}, {"line": "simp_rw [mem_prod, and_imp, Prod.forall, Prod.map_apply]", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\np' : Filter \u03b9'\ns' : Set \u03b1'\nh : UniformCauchySeqOn F p s\nh' : UniformCauchySeqOn F' p' s'\nu : Set ((\u03b2 \u00d7 \u03b2') \u00d7 \u03b2 \u00d7 \u03b2')\nv : Set (\u03b2 \u00d7 \u03b2)\nhv : v \u2208 uniformity \u03b2\nw : Set (\u03b2' \u00d7 \u03b2')\nhw : w \u2208 uniformity \u03b2'\nhvw : v \u00d7\u02e2 w \u2286 (fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) \u207b\u00b9' u\n\u22a2 \u2200\u1da0 (m : (\u03b9 \u00d7 \u03b9') \u00d7 \u03b9 \u00d7 \u03b9') in (p \u00d7\u02e2 p') \u00d7\u02e2 p \u00d7\u02e2 p',\n    \u2200 (a : \u03b1) (b : \u03b1'), a \u2208 s \u2192 b \u2208 s' \u2192 ((F m.1.1 a, F' m.1.2 b), F m.2.1 a, F' m.2.2 b) \u2208 u"}, {"line": "rw [\u2190 Set.image_subset_iff] at hvw", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\np' : Filter \u03b9'\ns' : Set \u03b1'\nh : UniformCauchySeqOn F p s\nh' : UniformCauchySeqOn F' p' s'\nu : Set ((\u03b2 \u00d7 \u03b2') \u00d7 \u03b2 \u00d7 \u03b2')\nv : Set (\u03b2 \u00d7 \u03b2)\nhv : v \u2208 uniformity \u03b2\nw : Set (\u03b2' \u00d7 \u03b2')\nhw : w \u2208 uniformity \u03b2'\nhvw : (fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) '' v \u00d7\u02e2 w \u2286 u\n\u22a2 \u2200\u1da0 (m : (\u03b9 \u00d7 \u03b9') \u00d7 \u03b9 \u00d7 \u03b9') in (p \u00d7\u02e2 p') \u00d7\u02e2 p \u00d7\u02e2 p',\n    \u2200 (a : \u03b1) (b : \u03b1'), a \u2208 s \u2192 b \u2208 s' \u2192 ((F m.1.1 a, F' m.1.2 b), F m.2.1 a, F' m.2.2 b) \u2208 u"}, {"line": "apply (tendsto_swap4_prod.eventually ((h v hv).prod_mk (h' w hw))).mono", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\np' : Filter \u03b9'\ns' : Set \u03b1'\nh : UniformCauchySeqOn F p s\nh' : UniformCauchySeqOn F' p' s'\nu : Set ((\u03b2 \u00d7 \u03b2') \u00d7 \u03b2 \u00d7 \u03b2')\nv : Set (\u03b2 \u00d7 \u03b2)\nhv : v \u2208 uniformity \u03b2\nw : Set (\u03b2' \u00d7 \u03b2')\nhw : w \u2208 uniformity \u03b2'\nhvw : (fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) '' v \u00d7\u02e2 w \u2286 u\n\u22a2 \u2200 (x : (\u03b9 \u00d7 \u03b9') \u00d7 \u03b9 \u00d7 \u03b9'),\n    ((\u2200 x_1 \u2208 s, (F ((x.1.1, x.2.1), x.1.2, x.2.2).1.1 x_1, F ((x.1.1, x.2.1), x.1.2, x.2.2).1.2 x_1) \u2208 v) \u2227\n        \u2200 x_1 \u2208 s', (F' ((x.1.1, x.2.1), x.1.2, x.2.2).2.1 x_1, F' ((x.1.1, x.2.1), x.1.2, x.2.2).2.2 x_1) \u2208 w) \u2192\n      \u2200 (a : \u03b1) (b : \u03b1'), a \u2208 s \u2192 b \u2208 s' \u2192 ((F x.1.1 a, F' x.1.2 b), F x.2.1 a, F' x.2.2 b) \u2208 u"}, {"line": "intro x hx a b ha hb", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Filter \u03b9\n\u03b9' : Type u_5\n\u03b1' : Type u_6\n\u03b2' : Type u_7\ninst\u271d : UniformSpace \u03b2'\nF' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'\np' : Filter \u03b9'\ns' : Set \u03b1'\nh : UniformCauchySeqOn F p s\nh' : UniformCauchySeqOn F' p' s'\nu : Set ((\u03b2 \u00d7 \u03b2') \u00d7 \u03b2 \u00d7 \u03b2')\nv : Set (\u03b2 \u00d7 \u03b2)\nhv : v \u2208 uniformity \u03b2\nw : Set (\u03b2' \u00d7 \u03b2')\nhw : w \u2208 uniformity \u03b2'\nhvw : (fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) '' v \u00d7\u02e2 w \u2286 u\nx : (\u03b9 \u00d7 \u03b9') \u00d7 \u03b9 \u00d7 \u03b9'\nhx :\n  (\u2200 x_1 \u2208 s, (F ((x.1.1, x.2.1), x.1.2, x.2.2).1.1 x_1, F ((x.1.1, x.2.1), x.1.2, x.2.2).1.2 x_1) \u2208 v) \u2227\n    \u2200 x_1 \u2208 s', (F' ((x.1.1, x.2.1), x.1.2, x.2.2).2.1 x_1, F' ((x.1.1, x.2.1), x.1.2, x.2.2).2.2 x_1) \u2208 w\na : \u03b1\nb : \u03b1'\nha : a \u2208 s\nhb : b \u2208 s'\n\u22a2 ((F x.1.1 a, F' x.1.2 b), F x.2.1 a, F' x.2.2 b) \u2208 u"}, {"line": "exact hvw \u27e8_, mk_mem_prod (hx.1 a ha) (hx.2 b hb), rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UniformCauchySeqOn.cauchy_map [hp : NeBot p] (hf : UniformCauchySeqOn F p s) (hx : x \u2208 s) :\n    Cauchy (map (fun i => F i x) p) := by\n  simp only [cauchy_map_iff]\n  simp only [hp]\n  simp only [true_and]\n  intro u hu\n  rw [mem_map]\n  filter_upwards [hf u hu] with p hp using hp x hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\nx : \u03b1\np : Filter \u03b9\nhp : p.NeBot\nhf : UniformCauchySeqOn F p s\nhx : x \u2208 s\n\u22a2 Cauchy (map (fun i => F i x) p)"}, {"line": "simp only [cauchy_map_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\nx : \u03b1\np : Filter \u03b9\nhp : p.NeBot\nhf : UniformCauchySeqOn F p s\nhx : x \u2208 s\n\u22a2 p.NeBot \u2227 Tendsto (fun p => (F p.1 x, F p.2 x)) (p \u00d7\u02e2 p) (uniformity \u03b2)"}, {"line": "simp only [hp]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\nx : \u03b1\np : Filter \u03b9\nhp : p.NeBot\nhf : UniformCauchySeqOn F p s\nhx : x \u2208 s\n\u22a2 True \u2227 Tendsto (fun p => (F p.1 x, F p.2 x)) (p \u00d7\u02e2 p) (uniformity \u03b2)"}, {"line": "simp only [true_and]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\nx : \u03b1\np : Filter \u03b9\nhp : p.NeBot\nhf : UniformCauchySeqOn F p s\nhx : x \u2208 s\n\u22a2 Tendsto (fun p => (F p.1 x, F p.2 x)) (p \u00d7\u02e2 p) (uniformity \u03b2)"}, {"line": "intro u hu", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\nx : \u03b1\np : Filter \u03b9\nhp : p.NeBot\nhf : UniformCauchySeqOn F p s\nhx : x \u2208 s\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\n\u22a2 u \u2208 map (fun p => (F p.1 x, F p.2 x)) (p \u00d7\u02e2 p)"}, {"line": "rw [mem_map]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\nx : \u03b1\np : Filter \u03b9\nhp : p.NeBot\nhf : UniformCauchySeqOn F p s\nhx : x \u2208 s\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 uniformity \u03b2\n\u22a2 (fun p => (F p.1 x, F p.2 x)) \u207b\u00b9' u \u2208 p \u00d7\u02e2 p"}, {"line": "filter_upwards [hf u hu] with p hp using hp x hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendstoUniformlyOn_of_seq_tendstoUniformlyOn {l : Filter \u03b9} [l.IsCountablyGenerated]\n    (h : \u2200 u : \u2115 \u2192 \u03b9, Tendsto u atTop l \u2192 TendstoUniformlyOn (fun n => F (u n)) f atTop s) :\n    TendstoUniformlyOn F f l s := by\n  rw [tendstoUniformlyOn_iff_tendsto]\n  rw [tendsto_iff_seq_tendsto]\n  intro u hu\n  rw [tendsto_prod_iff'] at hu\n  specialize h (fun n => (u n).fst) hu.1\n  rw [tendstoUniformlyOn_iff_tendsto] at h\n  exact h.comp (tendsto_id.prodMk hu.2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nl : Filter \u03b9\ninst\u271d : l.IsCountablyGenerated\nh : \u2200 (u : \u2115 \u2192 \u03b9), Tendsto u atTop l \u2192 TendstoUniformlyOn (fun n => F (u n)) f atTop s\n\u22a2 TendstoUniformlyOn F f l s"}, {"line": "rw [tendstoUniformlyOn_iff_tendsto]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nl : Filter \u03b9\ninst\u271d : l.IsCountablyGenerated\nh : \u2200 (u : \u2115 \u2192 \u03b9), Tendsto u atTop l \u2192 TendstoUniformlyOn (fun n => F (u n)) f atTop s\n\u22a2 Tendsto (fun q => (f q.2, F q.1 q.2)) (l \u00d7\u02e2 principal s) (uniformity \u03b2)"}, {"line": "rw [tendsto_iff_seq_tendsto]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nl : Filter \u03b9\ninst\u271d : l.IsCountablyGenerated\nh : \u2200 (u : \u2115 \u2192 \u03b9), Tendsto u atTop l \u2192 TendstoUniformlyOn (fun n => F (u n)) f atTop s\n\u22a2 \u2200 (x : \u2115 \u2192 \u03b9 \u00d7 \u03b1),\n    Tendsto x atTop (l \u00d7\u02e2 principal s) \u2192 Tendsto ((fun q => (f q.2, F q.1 q.2)) \u2218 x) atTop (uniformity \u03b2)\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nl : Filter \u03b9\ninst\u271d : l.IsCountablyGenerated\nh : \u2200 (u : \u2115 \u2192 \u03b9), Tendsto u atTop l \u2192 TendstoUniformlyOn (fun n => F (u n)) f atTop s\n\u22a2 (l \u00d7\u02e2 principal s).IsCountablyGenerated"}, {"line": "intro u hu", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nl : Filter \u03b9\ninst\u271d : l.IsCountablyGenerated\nh : \u2200 (u : \u2115 \u2192 \u03b9), Tendsto u atTop l \u2192 TendstoUniformlyOn (fun n => F (u n)) f atTop s\nu : \u2115 \u2192 \u03b9 \u00d7 \u03b1\nhu : Tendsto u atTop (l \u00d7\u02e2 principal s)\n\u22a2 Tendsto ((fun q => (f q.2, F q.1 q.2)) \u2218 u) atTop (uniformity \u03b2)\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nl : Filter \u03b9\ninst\u271d : l.IsCountablyGenerated\nh : \u2200 (u : \u2115 \u2192 \u03b9), Tendsto u atTop l \u2192 TendstoUniformlyOn (fun n => F (u n)) f atTop s\n\u22a2 (l \u00d7\u02e2 principal s).IsCountablyGenerated"}, {"line": "rw [tendsto_prod_iff'] at hu", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nl : Filter \u03b9\ninst\u271d : l.IsCountablyGenerated\nh : \u2200 (u : \u2115 \u2192 \u03b9), Tendsto u atTop l \u2192 TendstoUniformlyOn (fun n => F (u n)) f atTop s\nu : \u2115 \u2192 \u03b9 \u00d7 \u03b1\nhu : Tendsto (fun n => (u n).1) atTop l \u2227 Tendsto (fun n => (u n).2) atTop (principal s)\n\u22a2 Tendsto ((fun q => (f q.2, F q.1 q.2)) \u2218 u) atTop (uniformity \u03b2)\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nl : Filter \u03b9\ninst\u271d : l.IsCountablyGenerated\nh : \u2200 (u : \u2115 \u2192 \u03b9), Tendsto u atTop l \u2192 TendstoUniformlyOn (fun n => F (u n)) f atTop s\n\u22a2 (l \u00d7\u02e2 principal s).IsCountablyGenerated"}, {"line": "specialize h (fun n => (u n).fst) hu.1", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nl : Filter \u03b9\ninst\u271d : l.IsCountablyGenerated\nu : \u2115 \u2192 \u03b9 \u00d7 \u03b1\nhu : Tendsto (fun n => (u n).1) atTop l \u2227 Tendsto (fun n => (u n).2) atTop (principal s)\nh : TendstoUniformlyOn (fun n => F (u n).1) f atTop s\n\u22a2 Tendsto ((fun q => (f q.2, F q.1 q.2)) \u2218 u) atTop (uniformity \u03b2)\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nl : Filter \u03b9\ninst\u271d : l.IsCountablyGenerated\nh : \u2200 (u : \u2115 \u2192 \u03b9), Tendsto u atTop l \u2192 TendstoUniformlyOn (fun n => F (u n)) f atTop s\n\u22a2 (l \u00d7\u02e2 principal s).IsCountablyGenerated"}, {"line": "rw [tendstoUniformlyOn_iff_tendsto] at h", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nl : Filter \u03b9\ninst\u271d : l.IsCountablyGenerated\nu : \u2115 \u2192 \u03b9 \u00d7 \u03b1\nhu : Tendsto (fun n => (u n).1) atTop l \u2227 Tendsto (fun n => (u n).2) atTop (principal s)\nh : Tendsto (fun q => (f q.2, F (u q.1).1 q.2)) (atTop \u00d7\u02e2 principal s) (uniformity \u03b2)\n\u22a2 Tendsto ((fun q => (f q.2, F q.1 q.2)) \u2218 u) atTop (uniformity \u03b2)\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nl : Filter \u03b9\ninst\u271d : l.IsCountablyGenerated\nh : \u2200 (u : \u2115 \u2192 \u03b9), Tendsto u atTop l \u2192 TendstoUniformlyOn (fun n => F (u n)) f atTop s\n\u22a2 (l \u00d7\u02e2 principal s).IsCountablyGenerated"}, {"line": "exact h.comp (tendsto_id.prodMk hu.2)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nl : Filter \u03b9\ninst\u271d : l.IsCountablyGenerated\nh : \u2200 (u : \u2115 \u2192 \u03b9), Tendsto u atTop l \u2192 TendstoUniformlyOn (fun n => F (u n)) f atTop s\n\u22a2 (l \u00d7\u02e2 principal s).IsCountablyGenerated"}]}
{"declaration": "theorem TendstoUniformlyOn.seq_tendstoUniformlyOn {l : Filter \u03b9} (h : TendstoUniformlyOn F f l s)\n    (u : \u2115 \u2192 \u03b9) (hu : Tendsto u atTop l) : TendstoUniformlyOn (fun n => F (u n)) f atTop s := by\n  rw [tendstoUniformlyOn_iff_tendsto] at h \u22a2\n  exact h.comp ((hu.comp tendsto_fst).prodMk tendsto_snd)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nl : Filter \u03b9\nh : TendstoUniformlyOn F f l s\nu : \u2115 \u2192 \u03b9\nhu : Tendsto u atTop l\n\u22a2 TendstoUniformlyOn (fun n => F (u n)) f atTop s"}, {"line": "rw [tendstoUniformlyOn_iff_tendsto] at h \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nl : Filter \u03b9\nh : Tendsto (fun q => (f q.2, F q.1 q.2)) (l \u00d7\u02e2 principal s) (uniformity \u03b2)\nu : \u2115 \u2192 \u03b9\nhu : Tendsto u atTop l\n\u22a2 Tendsto (fun q => (f q.2, F (u q.1) q.2)) (atTop \u00d7\u02e2 principal s) (uniformity \u03b2)"}, {"line": "exact h.comp ((hu.comp tendsto_fst).prodMk tendsto_snd)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendstoUniformly_iff_seq_tendstoUniformly {l : Filter \u03b9} [l.IsCountablyGenerated] :\n    TendstoUniformly F f l \u2194\n      \u2200 u : \u2115 \u2192 \u03b9, Tendsto u atTop l \u2192 TendstoUniformly (fun n => F (u n)) f atTop := by\n  simp_rw [\u2190 tendstoUniformlyOn_univ]\n  exact tendstoUniformlyOn_iff_seq_tendstoUniformlyOn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "context": {"open": ["Topology Uniformity Filter Set Uniform"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [UniformSpace \u03b2]", "{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : Set \u03b1} {x : \u03b1} {p : Filter \u03b9} {p' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nl : Filter \u03b9\ninst\u271d : l.IsCountablyGenerated\n\u22a2 TendstoUniformly F f l \u2194 \u2200 (u : \u2115 \u2192 \u03b9), Tendsto u atTop l \u2192 TendstoUniformly (fun n => F (u n)) f atTop"}, {"line": "simp_rw [\u2190 tendstoUniformlyOn_univ]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_4\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nl : Filter \u03b9\ninst\u271d : l.IsCountablyGenerated\n\u22a2 TendstoUniformlyOn F f l univ \u2194 \u2200 (u : \u2115 \u2192 \u03b9), Tendsto u atTop l \u2192 TendstoUniformlyOn (fun n => F (u n)) f atTop univ"}, {"line": "exact tendstoUniformlyOn_iff_seq_tendstoUniformlyOn", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isTransitiveRel_empty : IsTransitiveRel (X := X) \u2205 := by\n  simp [IsTransitiveRel]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Ultra/Basic.lean", "context": {"open": ["Set Filter Topology", "scoped Uniformity"], "variables": ["{X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u22a2 IsTransitiveRel \u2205"}, {"line": "simp [IsTransitiveRel]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isTransitiveRel_univ : IsTransitiveRel (X := X) Set.univ := by\n  simp [IsTransitiveRel]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Ultra/Basic.lean", "context": {"open": ["Set Filter Topology", "scoped Uniformity"], "variables": ["{X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u22a2 IsTransitiveRel univ"}, {"line": "simp [IsTransitiveRel]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isTransitiveRel_singleton (x y : X) : IsTransitiveRel {(x, y)} := by\n  simp +contextual [IsTransitiveRel]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Ultra/Basic.lean", "context": {"open": ["Set Filter Topology", "scoped Uniformity"], "variables": ["{X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nx y : X\n\u22a2 IsTransitiveRel {(x, y)}"}, {"line": "simp +contextual [IsTransitiveRel]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsTransitiveRel.iInter {\u03b9 : Type*} {U : (i : \u03b9) \u2192 Set (X \u00d7 X)}\n    (hU : \u2200 i, IsTransitiveRel (U i)) :\n    IsTransitiveRel (\u22c2 i, U i) := by\n  intro _ _ _ h h'\n  simp only [mem_iInter] at h h' \u22a2\n  intro i\n  exact hU i (h i) (h' i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Ultra/Basic.lean", "context": {"open": ["Set Filter Topology", "scoped Uniformity"], "variables": ["{X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u03b9 : Type u_2\nU : \u03b9 \u2192 Set (X \u00d7 X)\nhU : \u2200 (i : \u03b9), IsTransitiveRel (U i)\n\u22a2 IsTransitiveRel (\u22c2 i, U i)"}, {"line": "intro _ _ _ h h'", "tactic_state": "X : Type u_1\n\u03b9 : Type u_2\nU : \u03b9 \u2192 Set (X \u00d7 X)\nhU : \u2200 (i : \u03b9), IsTransitiveRel (U i)\nx\u271d y\u271d z\u271d : X\nh : (x\u271d, y\u271d) \u2208 \u22c2 i, U i\nh' : (y\u271d, z\u271d) \u2208 \u22c2 i, U i\n\u22a2 (x\u271d, z\u271d) \u2208 \u22c2 i, U i"}, {"line": "simp only [mem_iInter] at h h' \u22a2", "tactic_state": "X : Type u_1\n\u03b9 : Type u_2\nU : \u03b9 \u2192 Set (X \u00d7 X)\nhU : \u2200 (i : \u03b9), IsTransitiveRel (U i)\nx\u271d y\u271d z\u271d : X\nh : \u2200 (i : \u03b9), (x\u271d, y\u271d) \u2208 U i\nh' : \u2200 (i : \u03b9), (y\u271d, z\u271d) \u2208 U i\n\u22a2 \u2200 (i : \u03b9), (x\u271d, z\u271d) \u2208 U i"}, {"line": "intro i", "tactic_state": "X : Type u_1\n\u03b9 : Type u_2\nU : \u03b9 \u2192 Set (X \u00d7 X)\nhU : \u2200 (i : \u03b9), IsTransitiveRel (U i)\nx\u271d y\u271d z\u271d : X\nh : \u2200 (i : \u03b9), (x\u271d, y\u271d) \u2208 U i\nh' : \u2200 (i : \u03b9), (y\u271d, z\u271d) \u2208 U i\ni : \u03b9\n\u22a2 (x\u271d, z\u271d) \u2208 U i"}, {"line": "exact hU i (h i) (h' i)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsTransitiveRel.sInter {s : Set (Set (X \u00d7 X))} (h : \u2200 i \u2208 s, IsTransitiveRel i) :\n    IsTransitiveRel (\u22c2\u2080 s) := by\n  rw [sInter_eq_iInter]\n  exact IsTransitiveRel.iInter (by simpa)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Ultra/Basic.lean", "context": {"open": ["Set Filter Topology", "scoped Uniformity"], "variables": ["{X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ns : Set (Set (X \u00d7 X))\nh : \u2200 i \u2208 s, IsTransitiveRel i\n\u22a2 IsTransitiveRel (\u22c2\u2080 s)"}, {"line": "rw [sInter_eq_iInter]", "tactic_state": "X : Type u_1\ns : Set (Set (X \u00d7 X))\nh : \u2200 i \u2208 s, IsTransitiveRel i\n\u22a2 IsTransitiveRel (\u22c2 i, \u2191i)"}, {"line": "exact IsTransitiveRel.iInter (by simpa)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma UniformSpace.ball_eq_of_mem_of_isSymmetricRel_of_isTransitiveRel {V : Set (X \u00d7 X)}\n    (h_symm : IsSymmetricRel V) (h_trans : IsTransitiveRel V) {x y : X}\n    (hy : y \u2208 ball x V) :\n    ball x V = ball y V := by\n  refine le_antisymm (h_trans.ball_subset_of_mem ?_) (h_trans.ball_subset_of_mem hy)\n  rwa [\u2190 mem_ball_symmetry h_symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Ultra/Basic.lean", "context": {"open": ["Set Filter Topology", "scoped Uniformity", "UniformSpace in"], "variables": ["{X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nV : Set (X \u00d7 X)\nh_symm : IsSymmetricRel V\nh_trans : IsTransitiveRel V\nx y : X\nhy : y \u2208 ball x V\n\u22a2 ball x V = ball y V"}, {"line": "refine le_antisymm (h_trans.ball_subset_of_mem ?_) (h_trans.ball_subset_of_mem hy)", "tactic_state": "X : Type u_1\nV : Set (X \u00d7 X)\nh_symm : IsSymmetricRel V\nh_trans : IsTransitiveRel V\nx y : X\nhy : y \u2208 ball x V\n\u22a2 x \u2208 ball y V"}, {"line": "rwa [\u2190 mem_ball_symmetry h_symm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsUltraUniformity.comap {u : UniformSpace Y} (h : IsUltraUniformity Y) (f : X \u2192 Y) :\n    @IsUltraUniformity _ (u.comap f) := by\n  letI := u.comap f\n  refine .mk_of_hasBasis (h.hasBasis.comap (Prod.map f f)) ?_ ?_\n  \u00b7 exact fun _ \u27e8_, hU, _\u27e9 \u21a6 hU.preimage_prodMap f\n  \u00b7 exact fun _ \u27e8_, _, hU\u27e9 \u21a6 hU.preimage_prodMap f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Ultra/Constructions.lean", "context": {"open": [], "variables": ["{X Y : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\nu : UniformSpace Y\nh : IsUltraUniformity Y\nf : X \u2192 Y\n\u22a2 IsUltraUniformity X"}, {"line": "letI := u.comap f", "tactic_state": "X : Type u_1\nY : Type u_2\nu : UniformSpace Y\nh : IsUltraUniformity Y\nf : X \u2192 Y\nthis : UniformSpace X := UniformSpace.comap f u\n\u22a2 IsUltraUniformity X"}, {"line": "refine .mk_of_hasBasis (h.hasBasis.comap (Prod.map f f)) ?_ ?_", "tactic_state": "case refine_1\nX : Type u_1\nY : Type u_2\nu : UniformSpace Y\nh : IsUltraUniformity Y\nf : X \u2192 Y\nthis : UniformSpace X := UniformSpace.comap f u\n\u22a2 \u2200 (i : Set (Y \u00d7 Y)), i \u2208 uniformity Y \u2227 IsSymmetricRel i \u2227 IsTransitiveRel i \u2192 IsSymmetricRel (Prod.map f f \u207b\u00b9' id i)\n---\ncase refine_2\nX : Type u_1\nY : Type u_2\nu : UniformSpace Y\nh : IsUltraUniformity Y\nf : X \u2192 Y\nthis : UniformSpace X := UniformSpace.comap f u\n\u22a2 \u2200 (i : Set (Y \u00d7 Y)), i \u2208 uniformity Y \u2227 IsSymmetricRel i \u2227 IsTransitiveRel i \u2192 IsTransitiveRel (Prod.map f f \u207b\u00b9' id i)"}, {"line": "\u00b7 exact fun _ \u27e8_, hU, _\u27e9 \u21a6 hU.preimage_prodMap f", "tactic_state": "case refine_2\nX : Type u_1\nY : Type u_2\nu : UniformSpace Y\nh : IsUltraUniformity Y\nf : X \u2192 Y\nthis : UniformSpace X := UniformSpace.comap f u\n\u22a2 \u2200 (i : Set (Y \u00d7 Y)), i \u2208 uniformity Y \u2227 IsSymmetricRel i \u2227 IsTransitiveRel i \u2192 IsTransitiveRel (Prod.map f f \u207b\u00b9' id i)"}, {"line": "\u00b7 exact fun _ \u27e8_, _, hU\u27e9 \u21a6 hU.preimage_prodMap f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsUltraUniformity.inf {u u' : UniformSpace X} (h : @IsUltraUniformity _ u)\n    (h' : @IsUltraUniformity _ u') :\n    @IsUltraUniformity _ (u \u2293 u') := by\n  letI := u \u2293 u'\n  refine .mk_of_hasBasis (h.hasBasis.inf h'.hasBasis) ?_ ?_\n  \u00b7 exact fun _ \u27e8\u27e8_, hU, _\u27e9, _, hU', _\u27e9 \u21a6 hU.inter hU'\n  \u00b7 exact fun _ \u27e8\u27e8_, _, hU\u27e9, _, _, hU'\u27e9 \u21a6 hU.inter hU'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Ultra/Constructions.lean", "context": {"open": [], "variables": ["{X Y : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nu u' : UniformSpace X\nh : IsUltraUniformity X\nh' : IsUltraUniformity X\n\u22a2 IsUltraUniformity X"}, {"line": "letI := u \u2293 u'", "tactic_state": "X : Type u_1\nu u' : UniformSpace X\nh : IsUltraUniformity X\nh' : IsUltraUniformity X\nthis : UniformSpace X := u \u2293 u'\n\u22a2 IsUltraUniformity X"}, {"line": "refine .mk_of_hasBasis (h.hasBasis.inf h'.hasBasis) ?_ ?_", "tactic_state": "case refine_1\nX : Type u_1\nu u' : UniformSpace X\nh : IsUltraUniformity X\nh' : IsUltraUniformity X\nthis : UniformSpace X := u \u2293 u'\n\u22a2 \u2200 (i : Set (X \u00d7 X) \u00d7 Set (X \u00d7 X)),\n    (i.1 \u2208 uniformity X \u2227 IsSymmetricRel i.1 \u2227 IsTransitiveRel i.1) \u2227\n        i.2 \u2208 uniformity X \u2227 IsSymmetricRel i.2 \u2227 IsTransitiveRel i.2 \u2192\n      IsSymmetricRel (id i.1 \u2229 id i.2)\n---\ncase refine_2\nX : Type u_1\nu u' : UniformSpace X\nh : IsUltraUniformity X\nh' : IsUltraUniformity X\nthis : UniformSpace X := u \u2293 u'\n\u22a2 \u2200 (i : Set (X \u00d7 X) \u00d7 Set (X \u00d7 X)),\n    (i.1 \u2208 uniformity X \u2227 IsSymmetricRel i.1 \u2227 IsTransitiveRel i.1) \u2227\n        i.2 \u2208 uniformity X \u2227 IsSymmetricRel i.2 \u2227 IsTransitiveRel i.2 \u2192\n      IsTransitiveRel (id i.1 \u2229 id i.2)"}, {"line": "\u00b7 exact fun _ \u27e8\u27e8_, hU, _\u27e9, _, hU', _\u27e9 \u21a6 hU.inter hU'", "tactic_state": "case refine_2\nX : Type u_1\nu u' : UniformSpace X\nh : IsUltraUniformity X\nh' : IsUltraUniformity X\nthis : UniformSpace X := u \u2293 u'\n\u22a2 \u2200 (i : Set (X \u00d7 X) \u00d7 Set (X \u00d7 X)),\n    (i.1 \u2208 uniformity X \u2227 IsSymmetricRel i.1 \u2227 IsTransitiveRel i.1) \u2227\n        i.2 \u2208 uniformity X \u2227 IsSymmetricRel i.2 \u2227 IsTransitiveRel i.2 \u2192\n      IsTransitiveRel (id i.1 \u2229 id i.2)"}, {"line": "\u00b7 exact fun _ \u27e8\u27e8_, _, hU\u27e9, _, _, hU'\u27e9 \u21a6 hU.inter hU'", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsUltraUniformity.iInf {\u03b9 : Type*} {U : (i : \u03b9) \u2192 UniformSpace X}\n    (hU : \u2200 i, @IsUltraUniformity X (U i)) :\n    @IsUltraUniformity _ (\u2a05 i, U i : UniformSpace X) := by\n  letI : UniformSpace X := \u2a05 i, U i\n  refine .mk_of_hasBasis (iInf_uniformity \u25b8 (Filter.hasBasis_iInf (fun i \u21a6 (hU i).hasBasis))) ?_ ?_\n  \u00b7 exact fun _ \u27e8_, h\u27e9 \u21a6 IsSymmetricRel.iInter fun i \u21a6 (h i).right.left\n  \u00b7 exact fun _ \u27e8_, h\u27e9 \u21a6 IsTransitiveRel.iInter fun i \u21a6 (h i).right.right\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UniformSpace/Ultra/Constructions.lean", "context": {"open": [], "variables": ["{X Y : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u03b9 : Type u_3\nU : \u03b9 \u2192 UniformSpace X\nhU : \u2200 (i : \u03b9), IsUltraUniformity X\n\u22a2 IsUltraUniformity X"}, {"line": "letI : UniformSpace X := \u2a05 i, U i", "tactic_state": "X : Type u_1\n\u03b9 : Type u_3\nU : \u03b9 \u2192 UniformSpace X\nhU : \u2200 (i : \u03b9), IsUltraUniformity X\nthis : UniformSpace X := \u2a05 i, U i\n\u22a2 IsUltraUniformity X"}, {"line": "refine .mk_of_hasBasis (iInf_uniformity \u25b8 (Filter.hasBasis_iInf (fun i \u21a6 (hU i).hasBasis))) ?_ ?_", "tactic_state": "case refine_1\nX : Type u_1\n\u03b9 : Type u_3\nU : \u03b9 \u2192 UniformSpace X\nhU : \u2200 (i : \u03b9), IsUltraUniformity X\nthis : UniformSpace X := \u2a05 i, U i\n\u22a2 \u2200 (i : (I : Set \u03b9) \u00d7 (\u2191I \u2192 Set (X \u00d7 X))),\n    (i.fst.Finite \u2227\n        \u2200 (i_1 : \u2191i.fst), i.snd i_1 \u2208 uniformity X \u2227 IsSymmetricRel (i.snd i_1) \u2227 IsTransitiveRel (i.snd i_1)) \u2192\n      IsSymmetricRel (\u22c2 i_1, id (i.snd i_1))\n---\ncase refine_2\nX : Type u_1\n\u03b9 : Type u_3\nU : \u03b9 \u2192 UniformSpace X\nhU : \u2200 (i : \u03b9), IsUltraUniformity X\nthis : UniformSpace X := \u2a05 i, U i\n\u22a2 \u2200 (i : (I : Set \u03b9) \u00d7 (\u2191I \u2192 Set (X \u00d7 X))),\n    (i.fst.Finite \u2227\n        \u2200 (i_1 : \u2191i.fst), i.snd i_1 \u2208 uniformity X \u2227 IsSymmetricRel (i.snd i_1) \u2227 IsTransitiveRel (i.snd i_1)) \u2192\n      IsTransitiveRel (\u22c2 i_1, id (i.snd i_1))"}, {"line": "\u00b7 exact fun _ \u27e8_, h\u27e9 \u21a6 IsSymmetricRel.iInter fun i \u21a6 (h i).right.left", "tactic_state": "case refine_2\nX : Type u_1\n\u03b9 : Type u_3\nU : \u03b9 \u2192 UniformSpace X\nhU : \u2200 (i : \u03b9), IsUltraUniformity X\nthis : UniformSpace X := \u2a05 i, U i\n\u22a2 \u2200 (i : (I : Set \u03b9) \u00d7 (\u2191I \u2192 Set (X \u00d7 X))),\n    (i.fst.Finite \u2227\n        \u2200 (i_1 : \u2191i.fst), i.snd i_1 \u2208 uniformity X \u2227 IsSymmetricRel (i.snd i_1) \u2227 IsTransitiveRel (i.snd i_1)) \u2192\n      IsTransitiveRel (\u22c2 i_1, id (i.snd i_1))"}, {"line": "\u00b7 exact fun _ \u27e8_, h\u27e9 \u21a6 IsTransitiveRel.iInter fun i \u21a6 (h i).right.right", "tactic_state": "No Goals!"}]}
{"declaration": "example : 1 = 1 := by\n  sleep_heartbeats 1000\n  rfl", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Util/SleepHeartbeats.lean", "context": {"open": ["Lean Elab"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 = 1"}, {"line": "sleep_heartbeats 1000", "tactic_state": "\u22a2 1 = 1"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  aesop (add safe (by simp))", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/AesopUnusedTactic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "aesop (add safe (by simp))", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : \u03b2 := by\n  apply f at a\n  guard_hyp a :\u209b \u03b2\n  exact a\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 \u03b2"}, {"line": "apply f at a", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\na : \u03b2\n\u22a2 \u03b2"}, {"line": "guard_hyp a :\u209b \u03b2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\na : \u03b2\n\u22a2 \u03b2"}, {"line": "exact a", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1 : Type} (\u03b3 : \u03b1 \u2192 Type) (a : \u03b1) (f : \u03b1 \u2192 \u03b3 a) : \u03b3 a := by\n  apply f at a\n  rename_i a\u2082\n  guard_hyp a :\u209b \u03b3 a\u2082\n  exact a\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\n\u03b3 : \u03b1 \u2192 Type\na : \u03b1\nf : \u03b1 \u2192 \u03b3 a\n\u22a2 \u03b3 a"}, {"line": "apply f at a", "tactic_state": "\u03b1 : Type\n\u03b3 : \u03b1 \u2192 Type\na\u271d : \u03b1\nf : \u03b1 \u2192 \u03b3 a\u271d\na : \u03b3 a\u271d\n\u22a2 \u03b3 a\u271d"}, {"line": "rename_i a\u2082", "tactic_state": "\u03b1 : Type\n\u03b3 : \u03b1 \u2192 Type\na\u2082 : \u03b1\nf : \u03b1 \u2192 \u03b3 a\u2082\na : \u03b3 a\u2082\n\u22a2 \u03b3 a\u2082"}, {"line": "guard_hyp a :\u209b \u03b3 a\u2082", "tactic_state": "\u03b1 : Type\n\u03b3 : \u03b1 \u2192 Type\na\u2082 : \u03b1\nf : \u03b1 \u2192 \u03b3 a\u2082\na : \u03b3 a\u2082\n\u22a2 \u03b3 a\u2082"}, {"line": "exact a", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (a b : \u03b1) (h : a = b) : f a = f b := by\n  apply congr_arg f at h\n  guard_hyp h :\u209b f a = f b\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\na b : \u03b1\nh : a = b\n\u22a2 f a = f b"}, {"line": "apply congr_arg f at h", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\na b : \u03b1\nh : f a = f b\n\u22a2 f a = f b"}, {"line": "guard_hyp h :\u209b f a = f b", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\na b : \u03b1\nh : f a = f b\n\u22a2 f a = f b"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : \u2115) (h : a + 1 = b + 1) : a = b := by\n  apply Nat.succ.inj at h\n  guard_hyp h :\u209b a = b\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a + 1 = b + 1\n\u22a2 a = b"}, {"line": "apply Nat.succ.inj at h", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a = b"}, {"line": "guard_hyp h :\u209b a = b", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a = b"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example {G : Type*} [Group G] (a b c : G) (h : a * c = b * c) : a = b := by\n  apply mul_right_cancel at h\n  guard_hyp h :\u209b a = b\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\na b c : G\nh : a * c = b * c\n\u22a2 a = b"}, {"line": "apply mul_right_cancel at h", "tactic_state": "G : Type u_1\ninst\u271d : Group G\na b c : G\nh : a = b\n\u22a2 a = b\n---\ncase inst\nG : Type u_1\ninst\u271d : Group G\na b c : G\nh : a * c = b * c\n\u22a2 IsRightCancelMul G"}, {"line": "guard_hyp h :\u209b a = b", "tactic_state": "G : Type u_1\ninst\u271d : Group G\na b c : G\nh : a = b\n\u22a2 a = b\n---\ncase inst\nG : Type u_1\ninst\u271d : Group G\na b c : G\nh : a * c = b * c\n\u22a2 IsRightCancelMul G"}, {"line": "exact h", "tactic_state": "case inst\nG : Type u_1\ninst\u271d : Group G\na b c : G\nh : a * c = b * c\n\u22a2 IsRightCancelMul G"}]}
{"declaration": "example {G : Type*} [Monoid G] (a b c : G) (h : a * c = b * c)\n    (hh : \u2200 x y z : G, x * z = y * z \u2192 x = y): a = b := by\n  apply mul_right_cancel at h\n  guard_hyp h :\u209b a = b\n  \u00b7 exact h\n  \u00b7 guard_target = IsRightCancelMul G\n    constructor\n    intros a b c\n    apply hh\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\na b c : G\nh : a * c = b * c\nhh : \u2200 (x y z : G), x * z = y * z \u2192 x = y\n\u22a2 a = b"}, {"line": "apply mul_right_cancel at h", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\na b c : G\nhh : \u2200 (x y z : G), x * z = y * z \u2192 x = y\nh : a = b\n\u22a2 a = b\n---\ncase inst\nG : Type u_1\ninst\u271d : Monoid G\na b c : G\nh : a * c = b * c\nhh : \u2200 (x y z : G), x * z = y * z \u2192 x = y\n\u22a2 IsRightCancelMul G"}, {"line": "guard_hyp h :\u209b a = b", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\na b c : G\nhh : \u2200 (x y z : G), x * z = y * z \u2192 x = y\nh : a = b\n\u22a2 a = b\n---\ncase inst\nG : Type u_1\ninst\u271d : Monoid G\na b c : G\nh : a * c = b * c\nhh : \u2200 (x y z : G), x * z = y * z \u2192 x = y\n\u22a2 IsRightCancelMul G"}, {"line": "\u00b7 exact h", "tactic_state": "case inst\nG : Type u_1\ninst\u271d : Monoid G\na b c : G\nh : a * c = b * c\nhh : \u2200 (x y z : G), x * z = y * z \u2192 x = y\n\u22a2 IsRightCancelMul G"}, {"line": "\u00b7 guard_target = IsRightCancelMul G\n    constructor\n    intros a b c\n    apply hh", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4) (a : \u03b1) (b : \u03b2) (g : \u03b3) : \u03b4 := by\n  apply f at g\n  guard_hyp g :\u209b \u03b4\n  assumption'\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b3\n\u22a2 \u03b4"}, {"line": "apply f at g", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b4\n\u22a2 \u03b4\n---\ncase a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b3\n\u22a2 \u03b1\n---\ncase a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b3\n\u22a2 \u03b2"}, {"line": "guard_hyp g :\u209b \u03b4", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b4\n\u22a2 \u03b4\n---\ncase a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b3\n\u22a2 \u03b1\n---\ncase a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b3\n\u22a2 \u03b2"}, {"line": "assumption'", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1 \u03b3 : Type*} {\u03b2 : \u03b1 \u2192 Type*} {a : \u03b1}\n    (f : {a : \u03b1} \u2192 \u03b2 a \u2192 \u03b3) (b : \u03b2 a) : \u03b3 := by\n  apply f at b\n  guard_hyp b :\u209b \u03b3\n  exact b\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b3 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_3\na : \u03b1\nf : {a : \u03b1} \u2192 \u03b2 a \u2192 \u03b3\nb : \u03b2 a\n\u22a2 \u03b3"}, {"line": "apply f at b", "tactic_state": "\u03b1 : Type u_1\n\u03b3 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_3\na : \u03b1\nf : {a : \u03b1} \u2192 \u03b2 a \u2192 \u03b3\nb : \u03b3\n\u22a2 \u03b3"}, {"line": "guard_hyp b :\u209b \u03b3", "tactic_state": "\u03b1 : Type u_1\n\u03b3 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_3\na : \u03b1\nf : {a : \u03b1} \u2192 \u03b2 a \u2192 \u03b3\nb : \u03b3\n\u22a2 \u03b3"}, {"line": "exact b", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} (f : {_ : \u03b1} \u2192 \u03b2 \u2192 {_ : \u03b3} \u2192 \u03b4) (g : \u03b3) (a : \u03b1) (b : \u03b2) :\n    \u03b4 := by\n  apply f at g\n  guard_hyp g :\u209b \u03b4\n  assumption'\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 \u03b2 \u2192 {x : \u03b3} \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b4"}, {"line": "apply f at g", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 \u03b2 \u2192 {x : \u03b3} \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b4\n\u22a2 \u03b4\n---\ncase x\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 \u03b2 \u2192 {x : \u03b3} \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b1\n---\ncase a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 \u03b2 \u2192 {x : \u03b3} \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b2"}, {"line": "guard_hyp g :\u209b \u03b4", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 \u03b2 \u2192 {x : \u03b3} \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b4\n\u22a2 \u03b4\n---\ncase x\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 \u03b2 \u2192 {x : \u03b3} \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b1\n---\ncase a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 \u03b2 \u2192 {x : \u03b3} \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b2"}, {"line": "assumption'", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} (f : {_ : \u03b1} \u2192 {_ : \u03b2} \u2192 (g : \u03b3) \u2192 \u03b4) (g : \u03b3) (a : \u03b1) (b : \u03b2) :\n    \u03b4 := by\n  apply f at g\n  guard_hyp g :\u209b \u03b4\n  assumption'\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 {x : \u03b2} \u2192 \u03b3 \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b4"}, {"line": "apply f at g", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 {x : \u03b2} \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b4\n\u22a2 \u03b4\n---\ncase x\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 {x : \u03b2} \u2192 \u03b3 \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b1\n---\ncase x\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 {x : \u03b2} \u2192 \u03b3 \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b2"}, {"line": "guard_hyp g :\u209b \u03b4", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 {x : \u03b2} \u2192 \u03b3 \u2192 \u03b4\na : \u03b1\nb : \u03b2\ng : \u03b4\n\u22a2 \u03b4\n---\ncase x\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 {x : \u03b2} \u2192 \u03b3 \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b1\n---\ncase x\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : {x : \u03b1} \u2192 {x : \u03b2} \u2192 \u03b3 \u2192 \u03b4\ng : \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 \u03b2"}, {"line": "assumption'", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2) (g : \u03b3) (a : \u03b1) : \u03b2 \u00d7 \u03b3  := by\n  fail_if_success apply f at g\n  apply f at a\n  guard_hyp a :\u209b \u03b2\n  exact (a, g)\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\ng : \u03b3\na : \u03b1\n\u22a2 \u03b2 \u00d7 \u03b3"}, {"line": "fail_if_success apply f at g", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\ng : \u03b3\na : \u03b1\n\u22a2 \u03b2 \u00d7 \u03b3"}, {"line": "apply f at a", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\ng : \u03b3\na : \u03b2\n\u22a2 \u03b2 \u00d7 \u03b3"}, {"line": "guard_hyp a :\u209b \u03b2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\ng : \u03b3\na : \u03b2\n\u22a2 \u03b2 \u00d7 \u03b3"}, {"line": "exact (a, g)", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1 \u03b2 : Type*} (a : \u03b1) (b : \u03b2) : \u03b1 \u00d7 \u03b2 := by\n  fail_if_success apply a at b\n  exact (a, b)\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\nb : \u03b2\n\u22a2 \u03b1 \u00d7 \u03b2"}, {"line": "fail_if_success apply a at b", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\nb : \u03b2\n\u22a2 \u03b1 \u00d7 \u03b2"}, {"line": "exact (a, b)", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1 \u03b2 : Type*} (a : \u03b1) (b : \u03b2) : \u03b1 \u00d7 \u03b2 := by\n  fail_if_success apply a at b\n  exact (a, b)\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\nb : \u03b2\n\u22a2 \u03b1 \u00d7 \u03b2"}, {"line": "fail_if_success apply a at b", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\nb : \u03b2\n\u22a2 \u03b1 \u00d7 \u03b2"}, {"line": "exact (a, b)", "tactic_state": "No Goals!"}]}
{"declaration": "example {A B : Prop} (h : A \u2194 B) : A \u2192 B := by\n  intro hA\n  apply h.mp at hA\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A B : Prop\nh : A \u2194 B\n\u22a2 A \u2192 B"}, {"line": "intro hA", "tactic_state": "A B : Prop\nh : A \u2194 B\nhA : A\n\u22a2 B"}, {"line": "apply h.mp at hA", "tactic_state": "A B : Prop\nh : A \u2194 B\nhA : B\n\u22a2 B"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example (a : \u211d) (h3 : a + 1 = 0) : a = -1 := by\n  apply (congrArg (fun x => x - 1)) at h3\n  simp at h3\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\nh3 : a + 1 = 0\n\u22a2 a = -1"}, {"line": "apply (congrArg (fun x => x - 1)) at h3", "tactic_state": "a : \u211d\nh3\u271d : a + 1 = 0\nh3 : a + 1 - 1 = 0 - 1\n\u22a2 a = -1"}, {"line": "simp at h3", "tactic_state": "a : \u211d\nh3\u271d : a + 1 = 0\nh3 : a = -1\n\u22a2 a = -1"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : \u211d) (h : -a * b = 0) : a = 0 \u2228 b = 0 := by\n  apply (congrArg (fun x => x / 1)) at h\n  simp at h\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nh : -a * b = 0\n\u22a2 a = 0 \u2228 b = 0"}, {"line": "apply (congrArg (fun x => x / 1)) at h", "tactic_state": "a b : \u211d\nh\u271d : -a * b = 0\nh : -a * b / 1 = 0 / 1\n\u22a2 a = 0 \u2228 b = 0"}, {"line": "simp at h", "tactic_state": "a b : \u211d\nh\u271d : -a * b = 0\nh : a = 0 \u2228 b = 0\n\u22a2 a = 0 \u2228 b = 0"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : True) : True := by\n  have H (h : True) : h = h := rfl\n  apply H at h\n  simp at h\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : True\n\u22a2 True"}, {"line": "have H (h : True) : h = h := rfl", "tactic_state": "h : True\nH : \u2200 (h : True), h = h\n\u22a2 True"}, {"line": "apply H at h", "tactic_state": "h\u271d : True\nH : \u2200 (h : True), h = h\nh : h\u271d = h\u271d\n\u22a2 True"}, {"line": "simp at h", "tactic_state": "h\u271d : True\nH : \u2200 (h : True), h = h\nh : True\n\u22a2 True"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example (a : List Nat) (k : Nat) (hk : k < a.length) : True := by\n  have H (k : Nat) {xs ys : List Nat} (hk: k < xs.length)\n    (h : xs = ys) : xs[k] = ys[k]'(h \u25b8 hk) := h \u25b8 rfl\n  have h : a = a.map id := by simp\n  apply H k hk at h\n  simp at h\n  exact h", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ApplyAt.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : List \u2115\nk : \u2115\nhk : k < a.length\n\u22a2 True"}, {"line": "have H (k : Nat) {xs ys : List Nat} (hk: k < xs.length)\n    (h : xs = ys) : xs[k] = ys[k]'(h \u25b8 hk) := h \u25b8 rfl", "tactic_state": "a : List \u2115\nk : \u2115\nhk : k < a.length\nH : \u2200 (k : \u2115) {xs ys : List \u2115} (hk : k < xs.length) (h : xs = ys), xs[k] = ys[k]\n\u22a2 True"}, {"line": "have h : a = a.map id := by simp", "tactic_state": "a : List \u2115\nk : \u2115\nhk : k < a.length\nH : \u2200 (k : \u2115) {xs ys : List \u2115} (hk : k < xs.length) (h : xs = ys), xs[k] = ys[k]\nh : a = List.map id a\n\u22a2 True"}, {"line": "apply H k hk at h", "tactic_state": "a : List \u2115\nk : \u2115\nhk : k < a.length\nH : \u2200 (k : \u2115) {xs ys : List \u2115} (hk : k < xs.length) (h : xs = ys), xs[k] = ys[k]\nh\u271d : a = List.map id a\nh : a[k] = (List.map id a)[k]\n\u22a2 True"}, {"line": "simp at h", "tactic_state": "a : List \u2115\nk : \u2115\nhk : k < a.length\nH : \u2200 (k : \u2115) {xs ys : List \u2115} (hk : k < xs.length) (h : xs = ys), xs[k] = ys[k]\nh\u271d : a = List.map id a\nh : True\n\u22a2 True"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example : IsMultiplicative \u03bc := by arith_mult\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ArithMult.lean", "context": {"open": ["ArithmeticFunction"], "variables": ["{R : Type*} [Field R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Field R\n\u22a2 moebius.IsMultiplicative"}, {"line": "arith_mult", "tactic_state": "No Goals!"}]}
{"declaration": "example : IsMultiplicative (\u03b6 * \u03b6) := by arith_mult\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ArithMult.lean", "context": {"open": ["ArithmeticFunction"], "variables": ["{R : Type*} [Field R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Field R\n\u22a2 (zeta * zeta).IsMultiplicative"}, {"line": "arith_mult", "tactic_state": "No Goals!"}]}
{"declaration": "example {R : Type*} [Field R] (f : ArithmeticFunction R) (hf : IsMultiplicative f) :\n    IsMultiplicative ((\u03b6 : ArithmeticFunction R).pdiv f) := by arith_mult\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ArithMult.lean", "context": {"open": ["ArithmeticFunction"], "variables": ["{R : Type*} [Field R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u271d : Type u_1\ninst\u271d\u00b9 : Field R\u271d\nR : Type u_2\ninst\u271d : Field R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\n\u22a2 ((\u2191zeta).pdiv f).IsMultiplicative"}, {"line": "arith_mult", "tactic_state": "No Goals!"}]}
{"declaration": "example (f g : ArithmeticFunction R) (hf : IsMultiplicative f) :\n    IsMultiplicative (prodPrimeFactors g |>.pmul f) := by arith_mult\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ArithMult.lean", "context": {"open": ["ArithmeticFunction"], "variables": ["{R : Type*} [Field R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Field R\nf g : ArithmeticFunction R\nhf : f.IsMultiplicative\n\u22a2 ((prodPrimeFactors \u21d1g).pmul f).IsMultiplicative"}, {"line": "arith_mult", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2115) : IsMultiplicative <| (\u03c3 n * pow (n + 3)).ppow 2 := by arith_mult", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ArithMult.lean", "context": {"open": ["ArithmeticFunction"], "variables": ["{R : Type*} [Field R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Field R\nn : \u2115\n\u22a2 ((sigma n * pow (n + 3)).ppow 2).IsMultiplicative"}, {"line": "arith_mult", "tactic_state": "No Goals!"}]}
{"declaration": "example : natDegree (- C z * X ^ 5 + (monomial 2 5) ^ 2 - 0 + 1 + IntCast.intCast 1 +\n    NatCast.natCast 1 + (z : \u2124[X]) + (n : \u2124[X]) + f) \u2264 5 := by\n  compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 (-C z * X ^ 5 + (monomial 2) 5 ^ 2 - 0 + 1 + IntCast.intCast 1 + \u21911 + \u2191z + \u2191n + f).natDegree \u2264 5"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example : degree (- C z * X ^ 5 + (C 0 + monomial 2 5) ^ 2 - 0 + 1 + IntCast.intCast 1 +\n    NatCast.natCast 1 + (z : \u2124[X]) + (n : \u2124[X]) + f) \u2264 5 := by\n  set k := f with _h\u2080\n  compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 (-C z * X ^ 5 + (C 0 + (monomial 2) 5) ^ 2 - 0 + 1 + IntCast.intCast 1 + \u21911 + \u2191z + \u2191n + f).degree \u2264 5"}, {"line": "set k := f with _h\u2080", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nk : Polynomial \u2124 := f\nhn : k.natDegree \u2264 5\nhd : k.degree \u2264 5\n_h\u2080 : k = f\n\u22a2 (-C z * X ^ 5 + (C 0 + (monomial 2) 5) ^ 2 - 0 + 1 + IntCast.intCast 1 + \u21911 + \u2191z + \u2191n + k).degree \u2264 5"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example : natDegree (- C 1 * X ^ 5 + (C 0 + monomial 2 5) ^ 2 - 0 + 1 + IntCast.intCast 1 +\n    NatCast.natCast 1 + (z : \u2124[X]) + (n : \u2124[X])) = 5 := by\n  set k := f with _h\u2080\n  compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 (-C 1 * X ^ 5 + (C 0 + (monomial 2) 5) ^ 2 - 0 + 1 + IntCast.intCast 1 + \u21911 + \u2191z + \u2191n).natDegree = 5"}, {"line": "set k := f with _h\u2080", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nk : Polynomial \u2124 := f\nhn : k.natDegree \u2264 5\nhd : k.degree \u2264 5\n_h\u2080 : k = f\n\u22a2 (-C 1 * X ^ 5 + (C 0 + (monomial 2) 5) ^ 2 - 0 + 1 + IntCast.intCast 1 + \u21911 + \u2191z + \u2191n).natDegree = 5"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example : degree (- C 1 * X ^ 5 + (C 0 + monomial 2 5) ^ 2 - 0 + 1 + IntCast.intCast 1 +\n    NatCast.natCast 1 + (z : \u2124[X]) + (n : \u2124[X])) = 5 := by\n  set k := f with _h\u2080\n  compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 (-C 1 * X ^ 5 + (C 0 + (monomial 2) 5) ^ 2 - 0 + 1 + IntCast.intCast 1 + \u21911 + \u2191z + \u2191n).degree = 5"}, {"line": "set k := f with _h\u2080", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nk : Polynomial \u2124 := f\nhn : k.natDegree \u2264 5\nhd : k.degree \u2264 5\n_h\u2080 : k = f\n\u22a2 (-C 1 * X ^ 5 + (C 0 + (monomial 2) 5) ^ 2 - 0 + 1 + IntCast.intCast 1 + \u21911 + \u2191z + \u2191n).degree = 5"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example : degree\n    ((C 1 * X ^ 2 + C 2 * X + C 3) * (C 0 * X ^ 0 + C 2 * X ^ 1 + C 1 * X ^ 5) ^ 4) = 22 := by\n  compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 ((C 1 * X ^ 2 + C 2 * X + C 3) * (C 0 * X ^ 0 + C 2 * X ^ 1 + C 1 * X ^ 5) ^ 4).degree = 22"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example {N : WithBot \u2115} (nN : n \u2264 N) : degree (- C z * X ^ n) \u2264 N := by compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\nN : WithBot \u2115\nnN : \u2191n \u2264 N\n\u22a2 (-C z * X ^ n).degree \u2264 N"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example : natDegree (0 : \u2124[X]) \u2264 5 := by compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 natDegree 0 \u2264 5"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example : natDegree (1 : \u2124[X]) \u2264 5 := by compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 natDegree 1 \u2264 5"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example : natDegree (NatCast.natCast 4 : \u2124[X]) \u2264 5 := by compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 (\u21914).natDegree \u2264 5"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example : natDegree (Nat.cast n : \u2124[X]) \u2264 5 := by compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 (\u2191n).natDegree \u2264 5"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example : natDegree (IntCast.intCast 4 : \u2124[X]) \u2264 5 := by compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 (IntCast.intCast 4).natDegree \u2264 5"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example : natDegree (Int.cast z : \u2124[X]) \u2264 5 := by compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 (\u2191z).natDegree \u2264 5"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example : natDegree (X : \u2124[X]) \u2264 5 := by compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 X.natDegree \u2264 5"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example : natDegree (C n) \u2264 5 := by compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\n\u22a2 (C n).natDegree \u2264 5"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : n \u2264 5) : natDegree (monomial n (5 + n)) \u2264 5 := by compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\nh : n \u2264 5\n\u22a2 ((monomial n) (5 + n)).natDegree \u2264 5"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example {f : \u2115[X]} : natDegree f \u2264 natDegree f := by compute_degree\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf\u271d : Polynomial \u2124\nhn : f\u271d.natDegree \u2264 5\nhd : f\u271d.degree \u2264 5\nf : Polynomial \u2115\n\u22a2 f.natDegree \u2264 f.natDegree"}, {"line": "compute_degree", "tactic_state": "No Goals!"}]}
{"declaration": "example : natDegree (C n) \u2264 5 := by compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)", "[Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d : Ring R\n\u22a2 (C n).natDegree \u2264 5"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example {f : R[X]} : natDegree f \u2264 natDegree f := by compute_degree\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)", "[Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nn : \u2115\nz : \u2124\nf\u271d : Polynomial \u2124\nhn : f\u271d.natDegree \u2264 5\nhd : f\u271d.degree \u2264 5\ninst\u271d : Ring R\nf : Polynomial R\n\u22a2 f.natDegree \u2264 f.natDegree"}, {"line": "compute_degree", "tactic_state": "No Goals!"}]}
{"declaration": "example : Polynomial.natDegree (Polynomial.C 4) \u2264 1 \u2227 True := by\n  constructor\n  compute_degree!\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)", "[Ring R]", "{R : Type _} [Semiring R] {a b c d e : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u271d : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d\u00b9 : Ring R\u271d\nR : Type ?u.590\ninst\u271d : Semiring R\na b c d e : R\n\u22a2 (C 4).natDegree \u2264 1 \u2227 True"}, {"line": "constructor", "tactic_state": "case left\nR\u271d : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d\u00b9 : Ring R\u271d\nR : Type ?u.590\ninst\u271d : Semiring R\na b c d e : R\n\u22a2 (C 4).natDegree \u2264 1\n---\ncase right\nR\u271d : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d\u00b9 : Ring R\u271d\nR : Type ?u.590\ninst\u271d : Semiring R\na b c d e : R\n\u22a2 True"}, {"line": "compute_degree!", "tactic_state": "case right\nR\u271d : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d\u00b9 : Ring R\u271d\nR : Type ?u.590\ninst\u271d : Semiring R\na b c d e : R\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example : degree (X + (X * monomial 2 1 + X * X) ^ 2) \u2264 10 := by compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)", "[Ring R]", "{R : Type _} [Semiring R] {a b c d e : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u271d : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d\u00b9 : Ring R\u271d\nR : Type ?u.590\ninst\u271d : Semiring R\na b c d e : R\n\u22a2 (X + (X * (monomial 2) 1 + X * X) ^ 2).degree \u2264 10"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example : natDegree ((5 * X * C 3 : _root_.Rat[X]) ^ 4) \u2264 4 := by compute_degree\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)", "[Ring R]", "{R : Type _} [Semiring R] {a b c d e : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u271d : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d\u00b9 : Ring R\u271d\nR : Type ?u.590\ninst\u271d : Semiring R\na b c d e : R\n\u22a2 ((5 * X * C 3) ^ 4).natDegree \u2264 4"}, {"line": "compute_degree", "tactic_state": "No Goals!"}]}
{"declaration": "example : degree ((X : \u2124[X]) ^ 4) \u2264 4 := by compute_degree\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)", "[Ring R]", "{R : Type _} [Semiring R] {a b c d e : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u271d : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d\u00b9 : Ring R\u271d\nR : Type ?u.590\ninst\u271d : Semiring R\na b c d e : R\n\u22a2 (X ^ 4).degree \u2264 4"}, {"line": "compute_degree", "tactic_state": "No Goals!"}]}
{"declaration": "example : natDegree ((X : \u2124[X]) ^ 4) \u2264 40 := by compute_degree!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ComputeDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*}", "{n : \u2115} {z : \u2124} {f : \u2124[X]} (hn : natDegree f \u2264 5) (hd : degree f \u2264 5)", "[Ring R]", "{R : Type _} [Semiring R] {a b c d e : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u271d : Type u_1\nn : \u2115\nz : \u2124\nf : Polynomial \u2124\nhn : f.natDegree \u2264 5\nhd : f.degree \u2264 5\ninst\u271d\u00b9 : Ring R\u271d\nR : Type ?u.590\ninst\u271d : Semiring R\na b c d e : R\n\u22a2 (X ^ 4).natDegree \u2264 40"}, {"line": "compute_degree!", "tactic_state": "No Goals!"}]}
{"declaration": "example : comap exp (cobounded \u2102) = comap re atTop := by simp\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/TCSynth.lean", "context": {"open": ["Complex Filter Bornology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 comap exp (cobounded \u2102) = comap re atTop"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u211d) : \u2016cos x + sin x * I\u2016 = 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/TCSynth.lean", "context": {"open": ["Complex Filter Bornology", "Real in", "Complex in"], "variables": ["{A : Type} [NormedRing A] [NormedAlgebra \u2102 A] [StarRing A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 \u2016cos \u2191x + sin \u2191x * I\u2016 = 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "example : 1 = 1 := by\n  have := 0\n  calc?\n\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/CalcQuestionMark.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 = 1"}, {"line": "have := 0", "tactic_state": "this : \u2115\n\u22a2 1 = 1"}, {"line": "calc?", "tactic_state": "No Goals!"}]}
{"declaration": "example (a : Nat) : a \u2264 a := by\n  calc?\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/CalcQuestionMark.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 a \u2264 a"}, {"line": "calc?", "tactic_state": "No Goals!"}]}
{"declaration": "example (a : Nat) : a \u2264 a := by\n  all_goals\n    calc?\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/CalcQuestionMark.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 a \u2264 a"}, {"line": "all_goals\n    calc?", "tactic_state": "No Goals!"}]}
{"declaration": "example :\n    1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 +\n    1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 +\n    1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 +\n    1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 = 8 + 8 + 8 + 8 := by\n  calc?", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/CalcQuestionMark.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 +\n          1 +\n        1 +\n      1 =\n    8 + 8 + 8 + 8"}, {"line": "calc?", "tactic_state": "No Goals!"}]}
{"declaration": "example [AddCommGroup \u03b1] (a b : \u03b1) : a-2\u2022b = a -2\u2022b := by abel\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b : \u03b1\n\u22a2 a - 2 \u2022 b = a - 2 \u2022 b"}, {"line": "abel", "tactic_state": "No Goals!"}]}
{"declaration": "example [AddCommGroup \u03b1] : True := by\n  have : \u2200 (p q r s : \u03b1), s + p - q = s - r - (q - r - p) := by\n    intro p q r s\n    abel\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\n\u22a2 True"}, {"line": "have : \u2200 (p q r s : \u03b1), s + p - q = s - r - (q - r - p) := by\n    intro p q r s\n    abel", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nthis : \u03b1 \u2192 \u03b1 \u2192 \u03b1 \u2192 \u03b1 \u2192 sorry\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  have := 0\n  abel_nf\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\n\u22a2 True"}, {"line": "have := 0", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\nthis : \u2115\n\u22a2 True"}, {"line": "abel_nf", "tactic_state": "No Goals!"}]}
{"declaration": "example [AddCommGroup \u03b1] (x : \u03b1) (f : \u03b1 \u2192 \u03b1) : True := by\n  let y := x\n  have : x = y := by\n    fail_if_success abel_nf\n    abel_nf!\n  have : x - y = 0 := by\n    abel_nf\n    abel_nf!\n  have : f x = f y := by\n    fail_if_success abel_nf\n    abel_nf!\n  have : f x - f y = 0 := by\n    abel_nf\n    abel_nf!\n  trivial", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\n\u22a2 True"}, {"line": "let y := x", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\ny : \u03b1 := x\n\u22a2 True"}, {"line": "have : x = y := by\n    fail_if_success abel_nf\n    abel_nf!", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\ny : \u03b1 := x\nthis : x = y\n\u22a2 True"}, {"line": "have : x - y = 0 := by\n    abel_nf\n    abel_nf!", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\ny : \u03b1 := x\nthis\u271d : x = y\nthis : sorry\n\u22a2 True"}, {"line": "have : f x = f y := by\n    fail_if_success abel_nf\n    abel_nf!", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\ny : \u03b1 := x\nthis\u271d\u00b9 : x = y\nthis\u271d : sorry\nthis : f x = f y\n\u22a2 True"}, {"line": "have : f x - f y = 0 := by\n    abel_nf\n    abel_nf!", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : AddCommGroup \u03b1\nx : \u03b1\nf : \u03b1 \u2192 \u03b1\ny : \u03b1 := x\nthis\u271d\u00b2 : x = y\nthis\u271d\u00b9 : sorry\nthis\u271d : f x = f y\nthis : sorry\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "theorem withoutClean : 2 + 2 = 4 := by exact id rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Clean.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 2 + 2 = 4"}, {"line": "exact id rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  let x : id Nat := by dsimp; exact 1\n  guard_hyp x :\u209b id Nat := id (1 : Nat)\n  let x' : id Nat := clean% by dsimp; exact 1\n  guard_hyp x' :\u209b id Nat := (1 : Nat)\n\n  let y := show Nat from 1\n  guard_hyp y :\u209b Nat := let_fun this := 1; this\n  let y' := clean% show Nat from 1\n  guard_hyp y' :\u209b Nat := 1\n\n  -- Not a tautological let_fun:\n  let z := clean% let_fun x := 1; x + x\n  guard_hyp z :\u209b Nat := let_fun x := 1; x + x\n\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Clean.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "let x : id Nat := by dsimp; exact 1", "tactic_state": "x : id \u2115 := id 1\n\u22a2 True"}, {"line": "guard_hyp x :\u209b id Nat := id (1 : Nat)", "tactic_state": "x : id \u2115 := id 1\n\u22a2 True"}, {"line": "let x' : id Nat := clean% by dsimp; exact 1", "tactic_state": "x : id \u2115 := id 1\nx' : id \u2115 := 1\n\u22a2 True"}, {"line": "guard_hyp x' :\u209b id Nat := (1 : Nat)", "tactic_state": "x : id \u2115 := id 1\nx' : id \u2115 := 1\n\u22a2 True"}, {"line": "let y := show Nat from 1", "tactic_state": "x : id \u2115 := id 1\nx' : id \u2115 := 1\ny : \u2115 :=\n  let_fun this := 1;\n  this\n\u22a2 True"}, {"line": "guard_hyp y :\u209b Nat := let_fun this := 1; this", "tactic_state": "x : id \u2115 := id 1\nx' : id \u2115 := 1\ny : \u2115 :=\n  let_fun this := 1;\n  this\n\u22a2 True"}, {"line": "let y' := clean% show Nat from 1", "tactic_state": "x : id \u2115 := id 1\nx' : id \u2115 := 1\ny : \u2115 :=\n  let_fun this := 1;\n  this\ny' : \u2115 := 1\n\u22a2 True"}, {"line": "guard_hyp y' :\u209b Nat := 1", "tactic_state": "x : id \u2115 := id 1\nx' : id \u2115 := 1\ny : \u2115 :=\n  let_fun this := 1;\n  this\ny' : \u2115 := 1\n\u22a2 True"}, {"line": "let z := clean% let_fun x := 1; x + x", "tactic_state": "x : id \u2115 := id 1\nx' : id \u2115 := 1\ny : \u2115 :=\n  let_fun this := 1;\n  this\ny' : \u2115 := 1\nz : \u2115 :=\n  let_fun x := 1;\n  x + x\n\u22a2 True"}, {"line": "guard_hyp z :\u209b Nat := let_fun x := 1; x + x", "tactic_state": "x : id \u2115 := id 1\nx' : id \u2115 := 1\ny : \u2115 :=\n  let_fun this := 1;\n  this\ny' : \u2115 := 1\nz : \u2115 :=\n  let_fun x := 1;\n  x + x\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (_delete_this : Nat) (dont_delete_this : Int) : Nat := by\n  clear * - dont_delete_this\n  fail_if_success assumption\n  exact dont_delete_this.toNat\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ClearExcept.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_delete_this : \u2115\ndont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "clear * - dont_delete_this", "tactic_state": "dont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "fail_if_success assumption", "tactic_state": "dont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "exact dont_delete_this.toNat", "tactic_state": "No Goals!"}]}
{"declaration": "example [dont_delete_this : Inhabited Nat] (dont_delete_this2 : Prop) : Inhabited Nat := by\n  clear * - dont_delete_this2\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ClearExcept.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "dont_delete_this : Inhabited \u2115\ndont_delete_this2 : Prop\n\u22a2 Inhabited \u2115"}, {"line": "clear * - dont_delete_this2", "tactic_state": "dont_delete_this : Inhabited \u2115\ndont_delete_this2 : Prop\n\u22a2 Inhabited \u2115"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example (delete_this : Nat) (_delete_this2 : delete_this = delete_this) (dont_delete_this : Int) :\n    Nat := by\n  clear * - dont_delete_this\n  fail_if_success assumption\n  exact dont_delete_this.toNat\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ClearExcept.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "delete_this : \u2115\n_delete_this2 : delete_this = delete_this\ndont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "clear * - dont_delete_this", "tactic_state": "dont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "fail_if_success assumption", "tactic_state": "dont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "exact dont_delete_this.toNat", "tactic_state": "No Goals!"}]}
{"declaration": "example (dont_delete_this : Nat) (dont_delete_this2 : dont_delete_this = dont_delete_this) :\n    Nat := by\n  clear * - dont_delete_this2\n  exact dont_delete_this\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ClearExcept.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "dont_delete_this : \u2115\ndont_delete_this2 : dont_delete_this = dont_delete_this\n\u22a2 \u2115"}, {"line": "clear * - dont_delete_this2", "tactic_state": "dont_delete_this : \u2115\ndont_delete_this2 : dont_delete_this = dont_delete_this\n\u22a2 \u2115"}, {"line": "exact dont_delete_this", "tactic_state": "No Goals!"}]}
{"declaration": "example (_delete_this : Nat) (dont_delete_this : Int) (dont_delete_this2 : Int) : Nat := by\n  clear * - dont_delete_this dont_delete_this2\n  fail_if_success assumption\n  exact dont_delete_this.toNat + dont_delete_this2.toNat", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ClearExcept.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_delete_this : \u2115\ndont_delete_this dont_delete_this2 : \u2124\n\u22a2 \u2115"}, {"line": "clear * - dont_delete_this dont_delete_this2", "tactic_state": "dont_delete_this dont_delete_this2 : \u2124\n\u22a2 \u2115"}, {"line": "fail_if_success assumption", "tactic_state": "dont_delete_this dont_delete_this2 : \u2124\n\u22a2 \u2115"}, {"line": "exact dont_delete_this.toNat + dont_delete_this2.toNat", "tactic_state": "No Goals!"}]}
{"declaration": "example : let x := 22; 0 \u2264 x := by\n  intro x\n  clear_value x\n  fail_if_success clear_value x\n  exact Nat.zero_le _\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ClearValue.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 let x := 22;\n  0 \u2264 x"}, {"line": "intro x", "tactic_state": "x : \u2115 := 22\n\u22a2 0 \u2264 x"}, {"line": "clear_value x", "tactic_state": "x : \u2115\n\u22a2 0 \u2264 x"}, {"line": "fail_if_success clear_value x", "tactic_state": "x : \u2115\n\u22a2 0 \u2264 x"}, {"line": "exact Nat.zero_le _", "tactic_state": "No Goals!"}]}
{"declaration": "example : let x := 22; let y : Fin x := 0; y.1 < x := by\n  intro x y\n  fail_if_success clear_value x\n  clear_value y\n  clear_value x\n  fail_if_success clear_value x\n  fail_if_success clear_value y\n  exact y.2\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ClearValue.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 let x := 22;\n  let y := 0;\n  \u2191y < x"}, {"line": "intro x y", "tactic_state": "x : \u2115 := 22\ny : Fin x := 0\n\u22a2 \u2191y < x"}, {"line": "fail_if_success clear_value x", "tactic_state": "x : \u2115 := 22\ny : Fin x := 0\n\u22a2 \u2191y < x"}, {"line": "clear_value y", "tactic_state": "x : \u2115 := 22\ny : Fin x\n\u22a2 \u2191y < x"}, {"line": "clear_value x", "tactic_state": "x : \u2115\ny : Fin x\n\u22a2 \u2191y < x"}, {"line": "fail_if_success clear_value x", "tactic_state": "x : \u2115\ny : Fin x\n\u22a2 \u2191y < x"}, {"line": "fail_if_success clear_value y", "tactic_state": "x : \u2115\ny : Fin x\n\u22a2 \u2191y < x"}, {"line": "exact y.2", "tactic_state": "No Goals!"}]}
{"declaration": "example : let x := 22; let y : Fin x := 0; y.1 < x := by\n  intro x y\n  fail_if_success clear_value x -- 0 depends on `x = Nat.succ _`\n  clear_value y x\n  fail_if_success clear_value x\n  fail_if_success clear_value y\n  exact y.2\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ClearValue.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 let x := 22;\n  let y := 0;\n  \u2191y < x"}, {"line": "intro x y", "tactic_state": "x : \u2115 := 22\ny : Fin x := 0\n\u22a2 \u2191y < x"}, {"line": "fail_if_success clear_value x -- 0 depends on `x = Nat.succ _`", "tactic_state": "x : \u2115 := 22\ny : Fin x := 0\n\u22a2 \u2191y < x"}, {"line": "clear_value y x", "tactic_state": "x : \u2115\ny : Fin x\n\u22a2 \u2191y < x"}, {"line": "fail_if_success clear_value x", "tactic_state": "x : \u2115\ny : Fin x\n\u22a2 \u2191y < x"}, {"line": "fail_if_success clear_value y", "tactic_state": "x : \u2115\ny : Fin x\n\u22a2 \u2191y < x"}, {"line": "exact y.2", "tactic_state": "No Goals!"}]}
{"declaration": "example : let x := 22; let y : Fin x := 0; y.1 < x := by\n  intro x y\n  fail_if_success clear_value x\n  clear_value x y\n  fail_if_success clear_value x\n  fail_if_success clear_value y\n  exact y.2\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ClearValue.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 let x := 22;\n  let y := 0;\n  \u2191y < x"}, {"line": "intro x y", "tactic_state": "x : \u2115 := 22\ny : Fin x := 0\n\u22a2 \u2191y < x"}, {"line": "fail_if_success clear_value x", "tactic_state": "x : \u2115 := 22\ny : Fin x := 0\n\u22a2 \u2191y < x"}, {"line": "clear_value x y", "tactic_state": "x : \u2115\ny : Fin x\n\u22a2 \u2191y < x"}, {"line": "fail_if_success clear_value x", "tactic_state": "x : \u2115\ny : Fin x\n\u22a2 \u2191y < x"}, {"line": "fail_if_success clear_value y", "tactic_state": "x : \u2115\ny : Fin x\n\u22a2 \u2191y < x"}, {"line": "exact y.2", "tactic_state": "No Goals!"}]}
{"declaration": "example : let x := 22; let y : Nat := x; let z : Fin (y + 1) := 0; z.1 < y + 1 := by\n  intro x y z\n  clear_value x -- `0` depends on `x` but its OK\n  exact z.2\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ClearValue.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 let x := 22;\n  let y := x;\n  let z := 0;\n  \u2191z < y + 1"}, {"line": "intro x y z", "tactic_state": "x : \u2115 := 22\ny : \u2115 := x\nz : Fin (y + 1) := 0\n\u22a2 \u2191z < y + 1"}, {"line": "clear_value x -- `0` depends on `x` but its OK", "tactic_state": "x : \u2115\ny : \u2115 := x\nz : Fin (y + 1) := 0\n\u22a2 \u2191z < y + 1"}, {"line": "exact z.2", "tactic_state": "No Goals!"}]}
{"declaration": "example : let x := 22; let y : Nat := x; let z : Fin (y + 1) := 0; z.1 < y + 1 := by\n  intro x y z\n  clear_value y -- `0` depends on `y` but its OK\n  exact z.2", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ClearValue.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 let x := 22;\n  let y := x;\n  let z := 0;\n  \u2191z < y + 1"}, {"line": "intro x y z", "tactic_state": "x : \u2115 := 22\ny : \u2115 := x\nz : Fin (y + 1) := 0\n\u22a2 \u2191z < y + 1"}, {"line": "clear_value y -- `0` depends on `y` but its OK", "tactic_state": "x : \u2115 := 22\ny : \u2115\nz : Fin (y + 1) := 0\n\u22a2 \u2191z < y + 1"}, {"line": "exact z.2", "tactic_state": "No Goals!"}]}
{"declaration": "example (_delete_this : Nat) : Nat := by\n  clear_\n  fail_if_success assumption\n  exact 0\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Clear_.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_delete_this : \u2115\n\u22a2 \u2115"}, {"line": "clear_", "tactic_state": "\u22a2 \u2115"}, {"line": "fail_if_success assumption", "tactic_state": "\u22a2 \u2115"}, {"line": "exact 0", "tactic_state": "No Goals!"}]}
{"declaration": "example [_dont_delete_this : Inhabited Nat] : Inhabited Nat := by\n  clear_\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Clear_.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_dont_delete_this : Inhabited \u2115\n\u22a2 Inhabited \u2115"}, {"line": "clear_", "tactic_state": "_dont_delete_this : Inhabited \u2115\n\u22a2 Inhabited \u2115"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example (_delete_this : Nat) (dont_delete_this : Int) : Nat := by\n  clear_\n  fail_if_success assumption\n  exact dont_delete_this.toNat\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Clear_.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_delete_this : \u2115\ndont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "clear_", "tactic_state": "dont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "fail_if_success assumption", "tactic_state": "dont_delete_this : \u2124\n\u22a2 \u2115"}, {"line": "exact dont_delete_this.toNat", "tactic_state": "No Goals!"}]}
{"declaration": "example (_delete_this : Type) (_delete_this_dep : _delete_this)\n    (_delete_this_rw : _delete_this = Nat)\n    (_delete_this_dep_dep : _delete_this_dep = _delete_this_dep) : Nat := by\n  clear_\n  fail_if_success\n    rw [\u2190 _delete_this_rw]\n  exact 0\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Clear_.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_delete_this : Type\n_delete_this_dep : _delete_this\n_delete_this_rw : _delete_this = \u2115\n_delete_this_dep_dep : _delete_this_dep = _delete_this_dep\n\u22a2 \u2115"}, {"line": "clear_", "tactic_state": "\u22a2 \u2115"}, {"line": "fail_if_success\n    rw [\u2190 _delete_this_rw]", "tactic_state": "\u22a2 \u2115"}, {"line": "exact 0", "tactic_state": "No Goals!"}]}
{"declaration": "example (_dont_delete_this : Type) (dep : _dont_delete_this) : _dont_delete_this := by\n  clear_\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Clear_.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_dont_delete_this : Type\ndep : _dont_delete_this\n\u22a2 _dont_delete_this"}, {"line": "clear_", "tactic_state": "_dont_delete_this : Type\ndep : _dont_delete_this\n\u22a2 _dont_delete_this"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example (_dont_delete_this : Type) : _dont_delete_this = _dont_delete_this := by\n  clear_\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Clear_.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_dont_delete_this : Type\n\u22a2 _dont_delete_this = _dont_delete_this"}, {"line": "clear_", "tactic_state": "_dont_delete_this : Type\n\u22a2 _dont_delete_this = _dont_delete_this"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (_dont_delete_this : Type) (_delete_this : _dont_delete_this = _dont_delete_this) :\n  _dont_delete_this = _dont_delete_this := by\n  clear_\n  fail_if_success assumption\n  rfl", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Clear_.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_dont_delete_this : Type\n_delete_this : _dont_delete_this = _dont_delete_this\n\u22a2 _dont_delete_this = _dont_delete_this"}, {"line": "clear_", "tactic_state": "_dont_delete_this : Type\n\u22a2 _dont_delete_this = _dont_delete_this"}, {"line": "fail_if_success assumption", "tactic_state": "_dont_delete_this : Type\n\u22a2 _dont_delete_this = _dont_delete_this"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (i j k : \u2115) (h\u2080 : i \u2264 j) (h\u2081 : j \u2264 k) : i \u2264 k := by\n  extract_goal\n  exact h\u2080.trans h\u2081\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "i j k : \u2115\nh\u2080 : i \u2264 j\nh\u2081 : j \u2264 k\n\u22a2 i \u2264 k"}, {"line": "extract_goal", "tactic_state": "i j k : \u2115\nh\u2080 : i \u2264 j\nh\u2081 : j \u2264 k\n\u22a2 i \u2264 k"}, {"line": "exact h\u2080.trans h\u2081", "tactic_state": "No Goals!"}]}
{"declaration": "example (i j k : \u2115) (h\u2080 : i \u2264 j) (h\u2081 : j \u2264 k) : i \u2264 k := by\n  extract_goal h\u2081\n  exact h\u2080.trans h\u2081\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "i j k : \u2115\nh\u2080 : i \u2264 j\nh\u2081 : j \u2264 k\n\u22a2 i \u2264 k"}, {"line": "extract_goal h\u2081", "tactic_state": "i j k : \u2115\nh\u2080 : i \u2264 j\nh\u2081 : j \u2264 k\n\u22a2 i \u2264 k"}, {"line": "exact h\u2080.trans h\u2081", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2115) : n = n := by\n  cases n\n  rfl\n  extract_goal\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n = n"}, {"line": "cases n", "tactic_state": "case zero\n\u22a2 0 = 0\n---\ncase succ\nn\u271d : \u2115\n\u22a2 n\u271d + 1 = n\u271d + 1"}, {"line": "rfl", "tactic_state": "case succ\nn\u271d : \u2115\n\u22a2 n\u271d + 1 = n\u271d + 1"}, {"line": "extract_goal", "tactic_state": "case succ\nn\u271d : \u2115\n\u22a2 n\u271d + 1 = n\u271d + 1"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2115) : True := by\n  extract_goal using foo\n  sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "extract_goal using foo", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2115) : True := by\n  extract_goal n using foo\n  sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "extract_goal n using foo", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2115) : True := by\n  extract_goal *\n  sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "extract_goal *", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2115) (i : Fin n) : True := by\n  extract_goal n\n  sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 True"}, {"line": "extract_goal n", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 True"}, {"line": "sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2115) (i : Fin n) : True := by\n  extract_goal i\n  sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 True"}, {"line": "extract_goal i", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 True"}, {"line": "sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : 1 = 2) : False := by\n  extract_goal\n  sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 1 = 2\n\u22a2 False"}, {"line": "extract_goal", "tactic_state": "h : 1 = 2\n\u22a2 False"}, {"line": "sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example : False := by\n  have h : 1 = 2 := sorry\n  extract_goal\n  sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 False"}, {"line": "have h : 1 = 2 := sorry", "tactic_state": "h : 1 = 2\n\u22a2 False"}, {"line": "extract_goal", "tactic_state": "h : 1 = 2\n\u22a2 False"}, {"line": "sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example : 1 = 2 \u2192 False := by\n  intro h\n  extract_goal h\n  sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 = 2 \u2192 False"}, {"line": "intro h", "tactic_state": "h : 1 = 2\n\u22a2 False"}, {"line": "extract_goal h", "tactic_state": "h : 1 = 2\n\u22a2 False"}, {"line": "sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2200 n, n < n + 1 := by\n  intro m\n  extract_goal\n  sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (n : \u2115), n < n + 1"}, {"line": "intro m", "tactic_state": "m : \u2115\n\u22a2 m < m + 1"}, {"line": "extract_goal", "tactic_state": "m : \u2115\n\u22a2 m < m + 1"}, {"line": "sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2200 n, n < n + 1 := by\n  intro m\n  show _\n  have : m < _ := Nat.lt.step (Nat.lt.base m)\n  extract_goal\n  sorry", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractGoal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (n : \u2115), n < n + 1"}, {"line": "intro m", "tactic_state": "m : \u2115\n\u22a2 m < m + 1"}, {"line": "show _", "tactic_state": "m : \u2115\n\u22a2 m < m + 1"}, {"line": "have : m < _ := Nat.lt.step (Nat.lt.base m)", "tactic_state": "m : \u2115\nthis : m < m.succ.succ\n\u22a2 m < m + 1"}, {"line": "extract_goal", "tactic_state": "m : \u2115\nthis : m < m.succ.succ\n\u22a2 m < m + 1"}, {"line": "sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example : Continuous (fun x : \u211d => exp ((max x (-x)) + sin x)^2) := by\n  continuity\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Continuity.lean", "context": {"open": ["Real"], "variables": ["[TopologicalSpace W] [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "{I : Type _} {X' : I \u2192 Type _} [\u2200 i, TopologicalSpace (X' i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "W : Type ?u.156\nX : Type ?u.159\nY : Type ?u.162\nZ : Type ?u.165\ninst\u271d\u2074 : TopologicalSpace W\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\nI : Type ?u.168\nX' : I \u2192 Type ?u.173\ninst\u271d : (i : I) \u2192 TopologicalSpace (X' i)\n\u22a2 Continuous fun x => exp (max x (-x) + sin x) ^ 2"}, {"line": "continuity", "tactic_state": "No Goals!"}]}
{"declaration": "example : Continuous (fun x : \u211d => exp ((max x (-x)) + sin (cos x))^2) := by\n  continuity\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Continuity.lean", "context": {"open": ["Real"], "variables": ["[TopologicalSpace W] [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "{I : Type _} {X' : I \u2192 Type _} [\u2200 i, TopologicalSpace (X' i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "W : Type ?u.156\nX : Type ?u.159\nY : Type ?u.162\nZ : Type ?u.165\ninst\u271d\u2074 : TopologicalSpace W\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\nI : Type ?u.168\nX' : I \u2192 Type ?u.173\ninst\u271d : (i : I) \u2192 TopologicalSpace (X' i)\n\u22a2 Continuous fun x => exp (max x (-x) + sin (cos x)) ^ 2"}, {"line": "continuity", "tactic_state": "No Goals!"}]}
{"declaration": "example (f : C(X, Y)) (g : C(X, Z)) : Continuous (fun x => (f x, g x)) := by continuity\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Continuity.lean", "context": {"open": ["Real"], "variables": ["[TopologicalSpace W] [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "{I : Type _} {X' : I \u2192 Type _} [\u2200 i, TopologicalSpace (X' i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "W : Type ?u.156\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u2074 : TopologicalSpace W\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\nI : Type ?u.168\nX' : I \u2192 Type ?u.173\ninst\u271d : (i : I) \u2192 TopologicalSpace (X' i)\nf : C(X, Y)\ng : C(X, Z)\n\u22a2 Continuous fun x => (f x, g x)"}, {"line": "continuity", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1 \u03b2 : Type _} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {x\u2080 : \u03b1} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b2)\n  (hf : ContinuousAt (Function.uncurry f) (x\u2080, x\u2080)) :\n  ContinuousAt (fun x \u21a6 f x x) x\u2080 := by\n  fail_if_success { exact hf.comp (continuousAt_id.prod continuousAt_id) }\n  exact hf.comp_of_eq (continuousAt_id.prodMk continuousAt_id) rfl", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Continuity.lean", "context": {"open": ["Real"], "variables": ["[TopologicalSpace W] [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "{I : Type _} {X' : I \u2192 Type _} [\u2200 i, TopologicalSpace (X' i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "W : Type ?u.156\nX : Type ?u.159\nY : Type ?u.162\nZ : Type ?u.165\ninst\u271d\u2076 : TopologicalSpace W\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\nI : Type ?u.168\nX' : I \u2192 Type ?u.173\ninst\u271d\u00b2 : (i : I) \u2192 TopologicalSpace (X' i)\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nx\u2080 : \u03b1\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b2\nhf : ContinuousAt (Function.uncurry f) (x\u2080, x\u2080)\n\u22a2 ContinuousAt (fun x => f x x) x\u2080"}, {"line": "fail_if_success { exact hf.comp (continuousAt_id.prod continuousAt_id) }", "tactic_state": "W : Type ?u.156\nX : Type ?u.159\nY : Type ?u.162\nZ : Type ?u.165\ninst\u271d\u2076 : TopologicalSpace W\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\nI : Type ?u.168\nX' : I \u2192 Type ?u.173\ninst\u271d\u00b2 : (i : I) \u2192 TopologicalSpace (X' i)\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nx\u2080 : \u03b1\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b2\nhf : ContinuousAt (Function.uncurry f) (x\u2080, x\u2080)\n\u22a2 ContinuousAt (fun x => f x x) x\u2080"}, {"line": "exact hf.comp_of_eq (continuousAt_id.prodMk continuousAt_id) rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q : Prop) (h : \u00acq \u2192 \u00acp) : p \u2192 q := by\n  contrapose\n  guard_target = \u00acq \u2192 \u00acp\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Contrapose.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh : \u00acq \u2192 \u00acp\n\u22a2 p \u2192 q"}, {"line": "contrapose", "tactic_state": "p q : Prop\nh : \u00acq \u2192 \u00acp\n\u22a2 \u00acq \u2192 \u00acp"}, {"line": "guard_target = \u00acq \u2192 \u00acp", "tactic_state": "p q : Prop\nh : \u00acq \u2192 \u00acp\n\u22a2 \u00acq \u2192 \u00acp"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q : Prop) (h : p) (hpq : \u00acq \u2192 \u00acp) : q := by\n  contrapose h\n  guard_target = \u00acp\n  exact hpq h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Contrapose.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh : p\nhpq : \u00acq \u2192 \u00acp\n\u22a2 q"}, {"line": "contrapose h", "tactic_state": "p q : Prop\nhpq : \u00acq \u2192 \u00acp\nh : \u00acq\n\u22a2 \u00acp"}, {"line": "guard_target = \u00acp", "tactic_state": "p q : Prop\nhpq : \u00acq \u2192 \u00acp\nh : \u00acq\n\u22a2 \u00acp"}, {"line": "exact hpq h", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q : Prop) (h : p) (hpq : \u00acq \u2192 \u00acp) : q := by\n  contrapose h with h'\n  guard_target = \u00acp\n  exact hpq h'\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Contrapose.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh : p\nhpq : \u00acq \u2192 \u00acp\n\u22a2 q"}, {"line": "contrapose h with h'", "tactic_state": "p q : Prop\nhpq : \u00acq \u2192 \u00acp\nh' : \u00acq\n\u22a2 \u00acp"}, {"line": "guard_target = \u00acp", "tactic_state": "p q : Prop\nhpq : \u00acq \u2192 \u00acp\nh' : \u00acq\n\u22a2 \u00acp"}, {"line": "exact hpq h'", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q : Prop) (h : q \u2192 p) : \u00acp \u2192 \u00acq := by\n  contrapose!\n  guard_target = q \u2192 p\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Contrapose.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh : q \u2192 p\n\u22a2 \u00acp \u2192 \u00acq"}, {"line": "contrapose!", "tactic_state": "p q : Prop\nh : q \u2192 p\n\u22a2 q \u2192 p"}, {"line": "guard_target = q \u2192 p", "tactic_state": "p q : Prop\nh : q \u2192 p\n\u22a2 q \u2192 p"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q : Prop) (h : \u00acp) (hpq : q \u2192 p) : \u00acq := by\n  contrapose! h\n  guard_target = p\n  exact hpq h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Contrapose.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh : \u00acp\nhpq : q \u2192 p\n\u22a2 \u00acq"}, {"line": "contrapose! h", "tactic_state": "p q : Prop\nhpq : q \u2192 p\nh : q\n\u22a2 p"}, {"line": "guard_target = p", "tactic_state": "p q : Prop\nhpq : q \u2192 p\nh : q\n\u22a2 p"}, {"line": "exact hpq h", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q : Prop) (h : \u00acp) (hpq : q \u2192 p) : \u00acq := by\n  contrapose! h with h'\n  guard_target = p\n  exact hpq h'\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Contrapose.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh : \u00acp\nhpq : q \u2192 p\n\u22a2 \u00acq"}, {"line": "contrapose! h with h'", "tactic_state": "p q : Prop\nhpq : q \u2192 p\nh' : q\n\u22a2 p"}, {"line": "guard_target = p", "tactic_state": "p q : Prop\nhpq : q \u2192 p\nh' : q\n\u22a2 p"}, {"line": "exact hpq h'", "tactic_state": "No Goals!"}]}
{"declaration": "example (p : Prop) (h : p) : p := by\n  fail_if_success { contrapose }\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Contrapose.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\nh : p\n\u22a2 p"}, {"line": "fail_if_success { contrapose }", "tactic_state": "p : Prop\nh : p\n\u22a2 p"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q : Type) (h : p \u2192 q) : p \u2192 q := by\n  fail_if_success { contrapose }\n  exact h", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Contrapose.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Type\nh : p \u2192 q\n\u22a2 p \u2192 q"}, {"line": "fail_if_success { contrapose }", "tactic_state": "p q : Type\nh : p \u2192 q\n\u22a2 p \u2192 q"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  sleep_heartbeats 1000 -- on top of these heartbeats, a few more are used by the rest of the proof\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/CountHeartbeats.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "sleep_heartbeats 1000 -- on top of these heartbeats, a few more are used by the rest of the proof", "tactic_state": "\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example : id (1 = 1) := by\n  with_reducible whnf\n  guard_target =\u209b id (1 = 1)\n  whnf\n  guard_target =\u209b 1 = 1\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 id (1 = 1)"}, {"line": "with_reducible whnf", "tactic_state": "\u22a2 id (1 = 1)"}, {"line": "guard_target =\u209b id (1 = 1)", "tactic_state": "\u22a2 id (1 = 1)"}, {"line": "whnf", "tactic_state": "\u22a2 1 = 1"}, {"line": "guard_target =\u209b 1 = 1", "tactic_state": "\u22a2 1 = 1"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : (fun x => 1 + x) 1 = 2 := by\n  beta_reduce\n  guard_target =\u209b 1 + 1 = 2\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun x => 1 + x) 1 = 2"}, {"line": "beta_reduce", "tactic_state": "\u22a2 1 + 1 = 2"}, {"line": "guard_target =\u209b 1 + 1 = 2", "tactic_state": "\u22a2 1 + 1 = 2"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : (fun x => 1 + x) 2 = (fun y => 2 + y) 3 := by\n  conv =>\n    lhs\n    beta_reduce\n    guard_target =\u209b 1 + 2\n  guard_target =\u209b 1 + 2 = (fun y => 2 + y) 3\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun x => 1 + x) 2 = (fun y => 2 + y) 3"}, {"line": "conv =>\n    lhs\n    beta_reduce\n    guard_target =\u209b 1 + 2", "tactic_state": "\u22a2 1 + 2 = (fun y => 2 + y) 3"}, {"line": "guard_target =\u209b 1 + 2 = (fun y => 2 + y) 3", "tactic_state": "\u22a2 1 + 2 = (fun y => 2 + y) 3"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example : 1 + 2 * 3 = 7 := by\n  reduce\n  guard_target =\u209b nat_lit 7 = nat_lit 7\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 + 2 * 3 = 7"}, {"line": "reduce", "tactic_state": "\u22a2 7 = 7"}, {"line": "guard_target =\u209b nat_lit 7 = nat_lit 7", "tactic_state": "\u22a2 7 = 7"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : let x := 1; let y := 2 + x; 2 + 1 = 3 := by\n  intro x y\n  refold_let x\n  guard_target =\u209b 2 + x = 3\n  refold_let y\n  guard_target =\u209b y = 3\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 let x := 1;\n  let y := 2 + x;\n  2 + 1 = 3"}, {"line": "intro x y", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2 + x\n\u22a2 2 + 1 = 3"}, {"line": "refold_let x", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2 + x\n\u22a2 2 + x = 3"}, {"line": "guard_target =\u209b 2 + x = 3", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2 + x\n\u22a2 2 + x = 3"}, {"line": "refold_let y", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2 + x\n\u22a2 y = 3"}, {"line": "guard_target =\u209b y = 3", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2 + x\n\u22a2 y = 3"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : 5 = 5 := by\n  let x := 5\n  refold_let x\n  guard_target =\u209b x = x\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 5 = 5"}, {"line": "let x := 5", "tactic_state": "x : \u2115 := 5\n\u22a2 5 = 5"}, {"line": "refold_let x", "tactic_state": "x : \u2115 := 5\n\u22a2 x = x"}, {"line": "guard_target =\u209b x = x", "tactic_state": "x : \u2115 := 5\n\u22a2 x = x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : 2 + 1 = 3 := by\n  let a : Fin 1 := 0\n  let x := 1\n  let b : Fin 1 := 0\n  refold_let x at *\n  guard_hyp a :\u209b Fin 1 := 0\n  guard_hyp b :\u209b Fin x := 0\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 2 + 1 = 3"}, {"line": "let a : Fin 1 := 0", "tactic_state": "a : Fin 1 := 0\n\u22a2 2 + 1 = 3"}, {"line": "let x := 1", "tactic_state": "a : Fin 1 := 0\nx : \u2115 := 1\n\u22a2 2 + 1 = 3"}, {"line": "let b : Fin 1 := 0", "tactic_state": "a : Fin 1 := 0\nx : \u2115 := 1\nb : Fin 1 := 0\n\u22a2 2 + 1 = 3"}, {"line": "refold_let x at *", "tactic_state": "a : Fin 1 := 0\nx : \u2115 := 1\nb : Fin x := 0\n\u22a2 2 + x = 3"}, {"line": "guard_hyp a :\u209b Fin 1 := 0", "tactic_state": "a : Fin 1 := 0\nx : \u2115 := 1\nb : Fin x := 0\n\u22a2 2 + x = 3"}, {"line": "guard_hyp b :\u209b Fin x := 0", "tactic_state": "a : Fin 1 := 0\nx : \u2115 := 1\nb : Fin x := 0\n\u22a2 2 + x = 3"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : 1 + 2 = 2 + 1 := by\n  unfold_projs\n  guard_target =\u209b Nat.add (nat_lit 1) (nat_lit 2) = Nat.add (nat_lit 2) (nat_lit 1)\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 + 2 = 2 + 1"}, {"line": "unfold_projs", "tactic_state": "\u22a2 Nat.add 1 2 = Nat.add 2 1"}, {"line": "guard_target =\u209b Nat.add (nat_lit 1) (nat_lit 2) = Nat.add (nat_lit 2) (nat_lit 1)", "tactic_state": "\u22a2 Nat.add 1 2 = Nat.add 2 1"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (m n : Nat) : (m == n) = true := by\n  unfold_projs\n  guard_target =\u209b decide (m = n) = true\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 (m == n) = true"}, {"line": "unfold_projs", "tactic_state": "m n : \u2115\n\u22a2 decide (m = n) = true"}, {"line": "guard_target =\u209b decide (m = n) = true", "tactic_state": "m n : \u2115\n\u22a2 decide (m = n) = true"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1 : Type u} (f : \u03b1 \u2192 \u03b1) (a : \u03b1) :\n    (fun x => (fun x => f x) x) a = f a := by\n  eta_reduce\n  guard_target =\u209b f a = f a\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nf : \u03b1 \u2192 \u03b1\na : \u03b1\n\u22a2 (fun x => (fun x => f x) x) a = f a"}, {"line": "eta_reduce", "tactic_state": "\u03b1 : Type u\nf : \u03b1 \u2192 \u03b1\na : \u03b1\n\u22a2 f a = f a"}, {"line": "guard_target =\u209b f a = f a", "tactic_state": "\u03b1 : Type u\nf : \u03b1 \u2192 \u03b1\na : \u03b1\n\u22a2 f a = f a"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (f : Nat \u2192 Nat) : (fun a => f a) = (fun a => f (f a)) := by\n  eta_expand\n  guard_target =\u209b (fun a => f a) = (fun a => f (f a))\n  eta_reduce\n  guard_target =\u209b f = fun a => f (f a)\n  eta_expand\n  guard_target =\u209b (fun a => f a) = (fun a => f (f a))\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u2115\n\u22a2 (fun a => f a) = fun a => f (f a)"}, {"line": "eta_expand", "tactic_state": "f : \u2115 \u2192 \u2115\n\u22a2 (fun a => f a) = fun a => f (f a)"}, {"line": "guard_target =\u209b (fun a => f a) = (fun a => f (f a))", "tactic_state": "f : \u2115 \u2192 \u2115\n\u22a2 (fun a => f a) = fun a => f (f a)"}, {"line": "eta_reduce", "tactic_state": "f : \u2115 \u2192 \u2115\n\u22a2 f = fun a => f (f a)"}, {"line": "guard_target =\u209b f = fun a => f (f a)", "tactic_state": "f : \u2115 \u2192 \u2115\n\u22a2 f = fun a => f (f a)"}, {"line": "eta_expand", "tactic_state": "f : \u2115 \u2192 \u2115\n\u22a2 (fun a => f a) = fun a => f (f a)"}, {"line": "guard_target =\u209b (fun a => f a) = (fun a => f (f a))", "tactic_state": "f : \u2115 \u2192 \u2115\n\u22a2 (fun a => f a) = fun a => f (f a)"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example : (fun (a b : Nat) => a + b) = (\u00b7 + \u00b7) := by\n  eta_reduce\n  guard_target =\u209b (HAdd.hAdd : Nat \u2192 Nat \u2192 Nat) = HAdd.hAdd\n  eta_expand\n  guard_target =\u209b (fun (a b : Nat) => a + b) = fun a b => a + b\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun a b => a + b) = fun x1 x2 => x1 + x2"}, {"line": "eta_reduce", "tactic_state": "\u22a2 HAdd.hAdd = HAdd.hAdd"}, {"line": "guard_target =\u209b (HAdd.hAdd : Nat \u2192 Nat \u2192 Nat) = HAdd.hAdd", "tactic_state": "\u22a2 HAdd.hAdd = HAdd.hAdd"}, {"line": "eta_expand", "tactic_state": "\u22a2 (fun a a_1 => a + a_1) = fun a a_1 => a + a_1"}, {"line": "guard_target =\u209b (fun (a b : Nat) => a + b) = fun a b => a + b", "tactic_state": "\u22a2 (fun a a_1 => a + a_1) = fun a a_1 => a + a_1"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : (fun (a : Nat) => 1 + a) = (1 + \u00b7) := by\n  eta_reduce\n  guard_target =\u209b (HAdd.hAdd 1) = HAdd.hAdd 1\n  eta_expand\n  guard_target =\u209b (fun a \u21a6 1 + a) = fun a \u21a6 1 + a\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun a => 1 + a) = fun x => 1 + x"}, {"line": "eta_reduce", "tactic_state": "\u22a2 HAdd.hAdd 1 = HAdd.hAdd 1"}, {"line": "guard_target =\u209b (HAdd.hAdd 1) = HAdd.hAdd 1", "tactic_state": "\u22a2 HAdd.hAdd 1 = HAdd.hAdd 1"}, {"line": "eta_expand", "tactic_state": "\u22a2 (fun a => 1 + a) = fun a => 1 + a"}, {"line": "guard_target =\u209b (fun a \u21a6 1 + a) = fun a \u21a6 1 + a", "tactic_state": "\u22a2 (fun a => 1 + a) = fun a => 1 + a"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (f : Nat \u2192 Nat \u2192 Nat) : (fun x => f 1 x) 2 = 3 := by\n  eta_expand\n  guard_target =\u209b f 1 2 = 3\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u2115 \u2192 \u2115\n\u22a2 (fun x => f 1 x) 2 = 3"}, {"line": "eta_expand", "tactic_state": "f : \u2115 \u2192 \u2115 \u2192 \u2115\n\u22a2 f 1 2 = 3"}, {"line": "guard_target =\u209b f 1 2 = 3", "tactic_state": "f : \u2115 \u2192 \u2115 \u2192 \u2115\n\u22a2 f 1 2 = 3"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (p : Nat \u00d7 Nat) : (p.1, p.2) = (p.2, p.1) := by\n  eta_struct\n  guard_target =\u209b p = (p.2, p.1)\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u00d7 \u2115\n\u22a2 (p.1, p.2) = (p.2, p.1)"}, {"line": "eta_struct", "tactic_state": "p : \u2115 \u00d7 \u2115\n\u22a2 p = (p.2, p.1)"}, {"line": "guard_target =\u209b p = (p.2, p.1)", "tactic_state": "p : \u2115 \u00d7 \u2115\n\u22a2 p = (p.2, p.1)"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (p : Nat \u00d7 Nat) : ((p.1, p.2).1, (p.1, p.2).2) = ((p.1, p.2).2, (p.1, p.2).1) := by\n  eta_struct\n  guard_target =\u209b p = (p.2, p.1)\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u00d7 \u2115\n\u22a2 ((p.1, p.2).1, (p.1, p.2).2) = ((p.1, p.2).2, (p.1, p.2).1)"}, {"line": "eta_struct", "tactic_state": "p : \u2115 \u00d7 \u2115\n\u22a2 p = (p.2, p.1)"}, {"line": "guard_target =\u209b p = (p.2, p.1)", "tactic_state": "p : \u2115 \u00d7 \u2115\n\u22a2 p = (p.2, p.1)"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : Fin 5) : n = \u27e8n.1, n.2\u27e9 := by\n  eta_struct\n  guard_target =\u209b n = n\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DefEqTransformations.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Fin 5\n\u22a2 n = \u27e8\u2191n, \u22ef\u27e9"}, {"line": "eta_struct", "tactic_state": "n : Fin 5\n\u22a2 n = n"}, {"line": "guard_target =\u209b n = n", "tactic_state": "n : Fin 5\n\u22a2 n = n"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  refine' (by refine' .intro)\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "refine' (by refine' .intro)", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  refine' (by refine' .intro)\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "refine' (by refine' .intro)", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  refine' (by refine' .intro)\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "refine' (by refine' .intro)", "tactic_state": "No Goals!"}]}
{"declaration": "example (a : (True \u2228 True) \u2228 (True \u2228 True)): True := by\n  cases' a with b b <;> cases' b <;> trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : (True \u2228 True) \u2228 True \u2228 True\n\u22a2 True"}, {"line": "cases' a with b b <;> cases' b <;> trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (a : (True \u2228 True) \u2228 (True \u2228 True)): True := by\n  cases' a with b b <;> cases' b <;> trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : (True \u2228 True) \u2228 True \u2228 True\n\u22a2 True"}, {"line": "cases' a with b b <;> cases' b <;> trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example : False := by admit\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 False"}, {"line": "admit", "tactic_state": "No Goals!"}]}
{"declaration": "example : False := by admit\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 False"}, {"line": "admit", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u211d) : deriv (fun x => cos x + 2 * sin x) x = -sin x + 2 * cos x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Deriv.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 deriv (fun x => cos x + 2 * sin x) x = -sin x + 2 * cos x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u211d) :\n    deriv (fun x \u21a6 sin (sin (sin x)) + sin x) x =\n    cos (sin (sin x)) * (cos (sin x) * cos x) + cos x := by\n  simp (maxDischargeDepth := 3)\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Deriv.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 deriv (fun x => sin (sin (sin x)) + sin x) x = cos (sin (sin x)) * (cos (sin x) * cos x) + cos x"}, {"line": "simp (maxDischargeDepth := 3)", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u211d) :\n    deriv (fun x \u21a6 sin (sin (sin x)) ^ 10 + sin x) x =\n    10 * sin (sin (sin x)) ^ 9 * (cos (sin (sin x)) * (cos (sin x) * cos x)) + cos x := by\n  simp (maxDischargeDepth := 4)", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Deriv.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 deriv (fun x => sin (sin (sin x)) ^ 10 + sin x) x =\n    10 * sin (sin (sin x)) ^ 9 * (cos (sin (sin x)) * (cos (sin x) * cos x)) + cos x"}, {"line": "simp (maxDischargeDepth := 4)", "tactic_state": "No Goals!"}]}
{"declaration": "example (x y : Nat) : True := by\n  #check x + y\n  trivial\n\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Check.lean", "context": {"open": ["Lean PrettyPrinter Delaborator in @[delab mvar] def delabMVar : Delab := do"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\n\u22a2 True"}, {"line": "#check x + y", "tactic_state": "x y : \u2115\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : Nat) : True := by\n  #check x + _\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Check.lean", "context": {"open": ["Lean PrettyPrinter Delaborator in @[delab mvar] def delabMVar : Delab := do"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\n\u22a2 True"}, {"line": "#check x + _", "tactic_state": "x : \u2115\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : Nat) : True := by\n  let y : Nat := ?a\n  #check (by refine rfl : ?a = x)\n  trace_state\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Check.lean", "context": {"open": ["Lean PrettyPrinter Delaborator in @[delab mvar] def delabMVar : Delab := do"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\n\u22a2 True"}, {"line": "let y : Nat := ?a", "tactic_state": "x : \u2115\ny : \u2115 := ?a\n\u22a2 True\n---\ncase a\nx : \u2115\n\u22a2 \u2115"}, {"line": "#check (by refine rfl : ?a = x)", "tactic_state": "x : \u2115\ny : \u2115 := ?a\n\u22a2 True\n---\ncase a\nx : \u2115\n\u22a2 \u2115"}, {"line": "trace_state", "tactic_state": "x : \u2115\ny : \u2115 := ?a\n\u22a2 True\n---\ncase a\nx : \u2115\n\u22a2 \u2115"}]}
{"declaration": "example (x : Nat) : True := by\n  let y : Nat := ?a\n  have := (by refine rfl : ?a = x)\n  trace_state", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Check.lean", "context": {"open": ["Lean PrettyPrinter Delaborator in @[delab mvar] def delabMVar : Delab := do"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\n\u22a2 True"}, {"line": "let y : Nat := ?a", "tactic_state": "x : \u2115\ny : \u2115 := ?a\n\u22a2 True\n---\ncase a\nx : \u2115\n\u22a2 \u2115"}, {"line": "have := (by refine rfl : ?a = x)", "tactic_state": "x : \u2115\ny : \u2115 := x\nthis : x = x\n\u22a2 True"}, {"line": "trace_state", "tactic_state": "x : \u2115\ny : \u2115 := x\nthis : x = x\n\u22a2 True"}]}
{"declaration": "example (h : let x := 1; x = x) : True := by\n  extract_lets y at h\n  fail_if_success extract_lets a at h\n  extract_lets at h\n  guard_hyp y : Nat := 1\n  guard_hyp h :\u209b y = y\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h :\n  let x := 1;\n  x = x\n\u22a2 True"}, {"line": "extract_lets y at h", "tactic_state": "y : \u2115 := 1\nh : y = y\n\u22a2 True"}, {"line": "fail_if_success extract_lets a at h", "tactic_state": "y : \u2115 := 1\nh : y = y\n\u22a2 True"}, {"line": "extract_lets at h", "tactic_state": "y : \u2115 := 1\nh : y = y\n\u22a2 True"}, {"line": "guard_hyp y : Nat := 1", "tactic_state": "y : \u2115 := 1\nh : y = y\n\u22a2 True"}, {"line": "guard_hyp h :\u209b y = y", "tactic_state": "y : \u2115 := 1\nh : y = y\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  let h : (let x := 1; x = x) := rfl\n  extract_lets y at h\n  guard_hyp y : Nat := 1\n  guard_hyp h :\u209b y = y := rfl\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "let h : (let x := 1; x = x) := rfl", "tactic_state": "h : let x := 1;\nx = x :=\n  rfl\n\u22a2 True"}, {"line": "extract_lets y at h", "tactic_state": "y : \u2115 := 1\nh : y = y := rfl\n\u22a2 True"}, {"line": "guard_hyp y : Nat := 1", "tactic_state": "y : \u2115 := 1\nh : y = y := rfl\n\u22a2 True"}, {"line": "guard_hyp h :\u209b y = y := rfl", "tactic_state": "y : \u2115 := 1\nh : y = y := rfl\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : let x := 1; let y := 2; x + 1 = y) : True := by\n  extract_lets x y at h\n  guard_hyp x : Nat := 1\n  guard_hyp y : Nat := 2\n  guard_hyp h :\u209b x + 1 = y\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n\u22a2 True"}, {"line": "extract_lets x y at h", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2\nh : x + 1 = y\n\u22a2 True"}, {"line": "guard_hyp x : Nat := 1", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2\nh : x + 1 = y\n\u22a2 True"}, {"line": "guard_hyp y : Nat := 2", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2\nh : x + 1 = y\n\u22a2 True"}, {"line": "guard_hyp h :\u209b x + 1 = y", "tactic_state": "x : \u2115 := 1\ny : \u2115 := 2\nh : x + 1 = y\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : let x := 1; let y := 2; x + 1 = y) : True := by\n  extract_lets at h\n  rename_i a b\n  guard_hyp a : Nat := 1\n  guard_hyp b : Nat := 2\n  guard_hyp h :\u209b a + 1 = b\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n\u22a2 True"}, {"line": "extract_lets at h", "tactic_state": "x\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n\u22a2 True"}, {"line": "rename_i a b", "tactic_state": "a : \u2115 := 1\nb : \u2115 := 2\nh : a + 1 = b\n\u22a2 True"}, {"line": "guard_hyp a : Nat := 1", "tactic_state": "a : \u2115 := 1\nb : \u2115 := 2\nh : a + 1 = b\n\u22a2 True"}, {"line": "guard_hyp b : Nat := 2", "tactic_state": "a : \u2115 := 1\nb : \u2115 := 2\nh : a + 1 = b\n\u22a2 True"}, {"line": "guard_hyp h :\u209b a + 1 = b", "tactic_state": "a : \u2115 := 1\nb : \u2115 := 2\nh : a + 1 = b\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : let x := 1; let y := 2; x + 1 = y) : True := by\n  extract_lets x at h\n  guard_hyp x : Nat := 1\n  guard_hyp h :\u209b let y := 2; x + 1 = y\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n\u22a2 True"}, {"line": "extract_lets x at h", "tactic_state": "x : \u2115 := 1\nh :\n  let y := 2;\n  x + 1 = y\n\u22a2 True"}, {"line": "guard_hyp x : Nat := 1", "tactic_state": "x : \u2115 := 1\nh :\n  let y := 2;\n  x + 1 = y\n\u22a2 True"}, {"line": "guard_hyp h :\u209b let y := 2; x + 1 = y", "tactic_state": "x : \u2115 := 1\nh :\n  let y := 2;\n  x + 1 = y\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : let x := 1; let y := 2; x + 1 = y) : let _z := 3; \u2200 (_ : Nat), True := by\n  extract_lets at *\n  guard_hyp h : _ + 1 = _\n  fail_if_success extract_lets x at h\n  guard_target =\u209b \u2200 (_ : Nat), True\n  intro\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n\u22a2 let _z := 3;\n  \u2115 \u2192 True"}, {"line": "extract_lets at *", "tactic_state": "_z\u271d : \u2115 := 3\nx\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n\u22a2 \u2115 \u2192 True"}, {"line": "guard_hyp h : _ + 1 = _", "tactic_state": "_z\u271d : \u2115 := 3\nx\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n\u22a2 \u2115 \u2192 True"}, {"line": "fail_if_success extract_lets x at h", "tactic_state": "_z\u271d : \u2115 := 3\nx\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n\u22a2 \u2115 \u2192 True"}, {"line": "guard_target =\u209b \u2200 (_ : Nat), True", "tactic_state": "_z\u271d : \u2115 := 3\nx\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n\u22a2 \u2115 \u2192 True"}, {"line": "intro", "tactic_state": "_z\u271d : \u2115 := 3\nx\u271d\u00b9 : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d\u00b9 + 1 = y\u271d\nx\u271d : \u2115\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : let x := 1; let y := 2; x + 1 = y) :\n    let _z := 3\n    let _z\u2082 := 5\n    \u2200 (_ : Nat), True := by\n  extract_lets at h \u22a2\n  guard_hyp h : _ + 1 = _\n  fail_if_success extract_lets x at h\n  guard_target =\u209b \u2200 (_ : Nat), True\n  intro\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n\u22a2 let _z := 3;\n  let _z\u2082 := 5;\n  \u2115 \u2192 True"}, {"line": "extract_lets at h \u22a2", "tactic_state": "x\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\n\u22a2 \u2115 \u2192 True"}, {"line": "guard_hyp h : _ + 1 = _", "tactic_state": "x\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\n\u22a2 \u2115 \u2192 True"}, {"line": "fail_if_success extract_lets x at h", "tactic_state": "x\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\n\u22a2 \u2115 \u2192 True"}, {"line": "guard_target =\u209b \u2200 (_ : Nat), True", "tactic_state": "x\u271d : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d + 1 = y\u271d\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\n\u22a2 \u2115 \u2192 True"}, {"line": "intro", "tactic_state": "x\u271d\u00b9 : \u2115 := 1\ny\u271d : \u2115 := 2\nh : x\u271d\u00b9 + 1 = y\u271d\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\nx\u271d : \u2115\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : let x := 1; let y := 2; x + 1 = y) :\n    let _z := 3\n    let _z\u2082 := 5\n    \u2200 (_ : Nat), True := by\n  extract_lets\n  fail_if_success extract_lets x\n  guard_hyp h : let x := 1; let y := 2; x + 1 = y\n  guard_target =\u209b \u2200 (_ : Nat), True\n  intro\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n\u22a2 let _z := 3;\n  let _z\u2082 := 5;\n  \u2115 \u2192 True"}, {"line": "extract_lets", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\n\u22a2 \u2115 \u2192 True"}, {"line": "fail_if_success extract_lets x", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\n\u22a2 \u2115 \u2192 True"}, {"line": "guard_hyp h : let x := 1; let y := 2; x + 1 = y", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\n\u22a2 \u2115 \u2192 True"}, {"line": "guard_target =\u209b \u2200 (_ : Nat), True", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\n\u22a2 \u2115 \u2192 True"}, {"line": "intro", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n_z\u271d : \u2115 := 3\n_z\u2082\u271d : \u2115 := 5\nx\u271d : \u2115\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : let x := 1; let y := 2; x + 1 = y) : let _z := 3; \u2200 (_ : Nat), True := by\n  extract_lets u\n  guard_hyp u : Nat := 3\n  fail_if_success extract_lets x\n  guard_target =\u209b \u2200 (_ : Nat), True\n  guard_hyp h : let x := 1; let y := 2; x + 1 = y\n  intro\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExtractLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\n\u22a2 let _z := 3;\n  \u2115 \u2192 True"}, {"line": "extract_lets u", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\nu : \u2115 := 3\n\u22a2 \u2115 \u2192 True"}, {"line": "guard_hyp u : Nat := 3", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\nu : \u2115 := 3\n\u22a2 \u2115 \u2192 True"}, {"line": "fail_if_success extract_lets x", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\nu : \u2115 := 3\n\u22a2 \u2115 \u2192 True"}, {"line": "guard_target =\u209b \u2200 (_ : Nat), True", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\nu : \u2115 := 3\n\u22a2 \u2115 \u2192 True"}, {"line": "guard_hyp h : let x := 1; let y := 2; x + 1 = y", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\nu : \u2115 := 3\n\u22a2 \u2115 \u2192 True"}, {"line": "intro", "tactic_state": "h :\n  let x := 1;\n  let y := 2;\n  x + 1 = y\nu : \u2115 := 3\nx\u271d : \u2115\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 x : Nat, x = x := by\n  existsi 42\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExistsI.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}, {"line": "existsi 42", "tactic_state": "\u22a2 42 = 42"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 x : Nat, \u2203 y : Nat, x = y := by\n  existsi 42, 42\n  rfl", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/ExistsI.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x y, x = y"}, {"line": "existsi 42, 42", "tactic_state": "\u22a2 42 = 42"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : a /\u209a u\u2081 + b /\u209a u\u2081 = (a + b) /\u209a u\u2081 := by field_simp\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FieldSimp.lean", "context": {"open": [], "variables": ["{R : Type _} [CommRing R] (a b c d e f g : R) (u\u2081 u\u2082 : R\u02e3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\n\u22a2 a /\u209a u\u2081 + b /\u209a u\u2081 = (a + b) /\u209a u\u2081"}, {"line": "field_simp", "tactic_state": "No Goals!"}]}
{"declaration": "example : a /\u209a u\u2081 - b /\u209a u\u2081 = (a - b) /\u209a u\u2081 := by field_simp\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FieldSimp.lean", "context": {"open": [], "variables": ["{R : Type _} [CommRing R] (a b c d e f g : R) (u\u2081 u\u2082 : R\u02e3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\n\u22a2 a /\u209a u\u2081 - b /\u209a u\u2081 = (a - b) /\u209a u\u2081"}, {"line": "field_simp", "tactic_state": "No Goals!"}]}
{"declaration": "example : a /\u209a u\u2081 = b /\u209a u\u2082 \u2194 a * u\u2082 = b * u\u2081 := by field_simp\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FieldSimp.lean", "context": {"open": [], "variables": ["{R : Type _} [CommRing R] (a b c d e f g : R) (u\u2081 u\u2082 : R\u02e3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\n\u22a2 a /\u209a u\u2081 = b /\u209a u\u2082 \u2194 a * \u2191u\u2082 = b * \u2191u\u2081"}, {"line": "field_simp", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\n\u22a2 b /\u209a u\u2082 * \u2191u\u2081 = a \u2194 a * \u2191u\u2082 = b * \u2191u\u2081"}]}
{"declaration": "example : \u2191u\u2081\u207b\u00b9 = 1 /\u209a u\u2081 := by field_simp\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FieldSimp.lean", "context": {"open": [], "variables": ["{R : Type _} [CommRing R] (a b c d e f g : R) (u\u2081 u\u2082 : R\u02e3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\n\u22a2 \u2191u\u2081\u207b\u00b9 = 1 /\u209a u\u2081"}, {"line": "field_simp", "tactic_state": "No Goals!"}]}
{"declaration": "example : (f - (e + c * -(a /\u209a u\u2081) * b + d) - g) =\n    (f * u\u2081 - (e * u\u2081 + c * (-a) * b + d * u\u2081) - g * u\u2081) /\u209a u\u2081 := by field_simp\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FieldSimp.lean", "context": {"open": [], "variables": ["{R : Type _} [CommRing R] (a b c d e f g : R) (u\u2081 u\u2082 : R\u02e3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\n\u22a2 f - (e + c * -(a /\u209a u\u2081) * b + d) - g = (f * \u2191u\u2081 - (e * \u2191u\u2081 + c * -a * b + d * \u2191u\u2081) - g * \u2191u\u2081) /\u209a u\u2081"}, {"line": "field_simp", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\n\u22a2 (f - (e + c * -(a /\u209a u\u2081) * b + d) - g) * \u2191u\u2081 = f * \u2191u\u2081 - (e * \u2191u\u2081 + c * -a * b + d * \u2191u\u2081) - g * \u2191u\u2081"}]}
{"declaration": "example : a /\u209a (u\u2081 / u\u2082) = a * u\u2082 /\u209a u\u2081 := by field_simp\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FieldSimp.lean", "context": {"open": [], "variables": ["{R : Type _} [CommRing R] (a b c d e f g : R) (u\u2081 u\u2082 : R\u02e3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\n\u22a2 a /\u209a (u\u2081 / u\u2082) = a * \u2191u\u2082 /\u209a u\u2081"}, {"line": "field_simp", "tactic_state": "No Goals!"}]}
{"declaration": "example : a /\u209a u\u2081 /\u209a u\u2082 = a /\u209a (u\u2082 * u\u2081) := by field_simp\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FieldSimp.lean", "context": {"open": [], "variables": ["{R : Type _} [CommRing R] (a b c d e f g : R) (u\u2081 u\u2082 : R\u02e3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\n\u22a2 a /\u209a u\u2081 /\u209a u\u2082 = a /\u209a (u\u2082 * u\u2081)"}, {"line": "field_simp", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\n\u22a2 a /\u209a (u\u2082 * u\u2081) * (\u2191u\u2082 * \u2191u\u2081) = a"}]}
{"declaration": "example (x : \u211a) (h\u2080 : x \u2260 0) :\n    (4 / x)\u207b\u00b9 * ((3 * x^3) / x)^2 * ((1 / (2 * x))\u207b\u00b9)^3 = 18 * x^8 := by\n  field_simp\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FieldSimp.lean", "context": {"open": [], "variables": ["{R : Type _} [CommRing R] (a b c d e f g : R) (u\u2081 u\u2082 : R\u02e3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type ?u.203\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\nx : \u211a\nh\u2080 : x \u2260 0\n\u22a2 (4 / x)\u207b\u00b9 * (3 * x ^ 3 / x) ^ 2 * (1 / (2 * x))\u207b\u00b9 ^ 3 = 18 * x ^ 8"}, {"line": "field_simp", "tactic_state": "R : Type ?u.203\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\nx : \u211a\nh\u2080 : x \u2260 0\n\u22a2 x * (3 * x ^ 3) ^ 2 * (2 * x) ^ 3 = 18 * x ^ 8 * (4 * x ^ 2)"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u211a) (h\u2080 : x \u2260 0) :\n    (4 / x)\u207b\u00b9 * ((3 * x^3) / x)^2 * ((1 / (2 * x))\u207b\u00b9)^3 = 18 * x^8 := by\n  field_simp (discharger := simp; assumption)\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FieldSimp.lean", "context": {"open": [], "variables": ["{R : Type _} [CommRing R] (a b c d e f g : R) (u\u2081 u\u2082 : R\u02e3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type ?u.203\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\nx : \u211a\nh\u2080 : x \u2260 0\n\u22a2 (4 / x)\u207b\u00b9 * (3 * x ^ 3 / x) ^ 2 * (1 / (2 * x))\u207b\u00b9 ^ 3 = 18 * x ^ 8"}, {"line": "field_simp (discharger := simp; assumption)", "tactic_state": "R : Type ?u.203\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\nx : \u211a\nh\u2080 : x \u2260 0\n\u22a2 x * (3 * x ^ 3) ^ 2 * (2 * x) ^ 3 = 18 * x ^ 8 * (4 * x ^ 2)"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u211a) (h\u2080 : x \u2260 0) :\n    (4 / x)\u207b\u00b9 * ((3 * x^3) / x)^2 * ((1 / (2 * x))\u207b\u00b9)^3 = 18 * x^8 := by\n  fail_if_success field_simp (config := {maxSteps := 0})\n  field_simp (config := {})\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FieldSimp.lean", "context": {"open": [], "variables": ["{R : Type _} [CommRing R] (a b c d e f g : R) (u\u2081 u\u2082 : R\u02e3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type ?u.203\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\nx : \u211a\nh\u2080 : x \u2260 0\n\u22a2 (4 / x)\u207b\u00b9 * (3 * x ^ 3 / x) ^ 2 * (1 / (2 * x))\u207b\u00b9 ^ 3 = 18 * x ^ 8"}, {"line": "fail_if_success field_simp (config := {maxSteps := 0})", "tactic_state": "R : Type ?u.203\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\nx : \u211a\nh\u2080 : x \u2260 0\n\u22a2 (4 / x)\u207b\u00b9 * (3 * x ^ 3 / x) ^ 2 * (1 / (2 * x))\u207b\u00b9 ^ 3 = 18 * x ^ 8"}, {"line": "field_simp (config := {})", "tactic_state": "R : Type ?u.203\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\nx : \u211a\nh\u2080 : x \u2260 0\n\u22a2 x * (3 * x ^ 3) ^ 2 * (2 * x) ^ 3 = 18 * x ^ 8 * (4 * x ^ 2)"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "example {x y z w : \u211a} (h : x / y = z / w) (hy : y \u2260 0) (hw : w \u2260 0) : x * w = z * y := by\n  field_simp at h\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FieldSimp.lean", "context": {"open": [], "variables": ["{R : Type _} [CommRing R] (a b c d e f g : R) (u\u2081 u\u2082 : R\u02e3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type ?u.203\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\nx y z w : \u211a\nh : x / y = z / w\nhy : y \u2260 0\nhw : w \u2260 0\n\u22a2 x * w = z * y"}, {"line": "field_simp at h", "tactic_state": "R : Type ?u.203\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\nx y z w : \u211a\nhy : y \u2260 0\nhw : w \u2260 0\nh : x * w = z * y\n\u22a2 x * w = z * y"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example {aa : \u211a} (ha : (aa : \u211a) \u2260 0) (hb : 2 * aa = 3) : (1 : \u211a) / aa = 2/ 3 := by\n  simp (disch := field_simp_discharge) [-one_div, -one_divp, -mul_eq_zero, field_simps]\n  rw [hb]", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FieldSimp.lean", "context": {"open": [], "variables": ["{R : Type _} [CommRing R] (a b c d e f g : R) (u\u2081 u\u2082 : R\u02e3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type ?u.203\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\naa : \u211a\nha : aa \u2260 0\nhb : 2 * aa = 3\n\u22a2 1 / aa = 2 / 3"}, {"line": "simp (disch := field_simp_discharge) [-one_div, -one_divp, -mul_eq_zero, field_simps]", "tactic_state": "R : Type ?u.203\ninst\u271d : CommRing R\na b c d e f g : R\nu\u2081 u\u2082 : R\u02e3\naa : \u211a\nha : aa \u2260 0\nhb : 2 * aa = 3\n\u22a2 3 = 2 * aa"}, {"line": "rw [hb]", "tactic_state": "No Goals!"}]}
{"declaration": "example : (let x := 1; x) = 1 := by\n  lift_lets\n  guard_target =\u209b let x := 1; x = 1\n  intro _x\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (let x := 1;\n    x) =\n    1"}, {"line": "lift_lets", "tactic_state": "\u22a2 let x := 1;\n  x = 1"}, {"line": "guard_target =\u209b let x := 1; x = 1", "tactic_state": "\u22a2 let x := 1;\n  x = 1"}, {"line": "intro _x", "tactic_state": "_x : \u2115 := 1\n\u22a2 _x = 1"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : (let x := 1; x) = (let y := 1; y) := by\n  lift_lets\n  guard_target =\u209b let x := 1; x = x\n  intro _x\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (let x := 1;\n    x) =\n    let y := 1;\n    y"}, {"line": "lift_lets", "tactic_state": "\u22a2 let x := 1;\n  x = x"}, {"line": "guard_target =\u209b let x := 1; x = x", "tactic_state": "\u22a2 let x := 1;\n  x = x"}, {"line": "intro _x", "tactic_state": "_x : \u2115 := 1\n\u22a2 _x = _x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : (let x := 1; x) = (let y := 1; y) := by\n  lift_lets (config := {merge := false})\n  guard_target =\u209b let x := 1; let y := 1; x = y\n  intros _x _y\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (let x := 1;\n    x) =\n    let y := 1;\n    y"}, {"line": "lift_lets (config := {merge := false})", "tactic_state": "\u22a2 let x := 1;\n  let y := 1;\n  x = y"}, {"line": "guard_target =\u209b let x := 1; let y := 1; x = y", "tactic_state": "\u22a2 let x := 1;\n  let y := 1;\n  x = y"}, {"line": "intros _x _y", "tactic_state": "_x : \u2115 := 1\n_y : \u2115 := 1\n\u22a2 _x = _y"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : (let x := (let y := 1; y + 1); x + 1) = 3 := by\n  lift_lets\n  guard_target =\u209b let y := 1; let x := y + 1; x + 1 = 3\n  intros _y _x\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (let x :=\n      let y := 1;\n      y + 1;\n    x + 1) =\n    3"}, {"line": "lift_lets", "tactic_state": "\u22a2 let y := 1;\n  let x := y + 1;\n  x + 1 = 3"}, {"line": "guard_target =\u209b let y := 1; let x := y + 1; x + 1 = 3", "tactic_state": "\u22a2 let y := 1;\n  let x := y + 1;\n  x + 1 = 3"}, {"line": "intros _y _x", "tactic_state": "_y : \u2115 := 1\n_x : \u2115 := _y + 1\n\u22a2 _x + 1 = 3"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : (fun x => let a := x; let y := 1; a + y) 2 = 2 + 1 := by\n  lift_lets\n  guard_target =\u209b let y := 1; (fun x \u21a6 let a := x; a + y) 2 = 2 + 1\n  intro _y\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun x =>\n        let a := x;\n        let y := 1;\n        a + y)\n      2 =\n    2 + 1"}, {"line": "lift_lets", "tactic_state": "\u22a2 let y := 1;\n  (fun x =>\n        let a := x;\n        a + y)\n      2 =\n    2 + 1"}, {"line": "guard_target =\u209b let y := 1; (fun x \u21a6 let a := x; a + y) 2 = 2 + 1", "tactic_state": "\u22a2 let y := 1;\n  (fun x =>\n        let a := x;\n        a + y)\n      2 =\n    2 + 1"}, {"line": "intro _y", "tactic_state": "_y : \u2115 := 1\n\u22a2 (fun x =>\n        let a := x;\n        a + _y)\n      2 =\n    2 + 1"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : (fun (x : let ty := Nat; ty) => Fin x) (2 : Nat) := by\n  lift_lets\n  guard_target =\u209b let ty := Nat; (fun (x : ty) \u21a6 Fin x) (2 : Nat)\n  exact 0\n\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun x => Fin x) 2"}, {"line": "lift_lets", "tactic_state": "\u22a2 let ty := \u2115;\n  (fun x => Fin x) 2"}, {"line": "guard_target =\u209b let ty := Nat; (fun (x : ty) \u21a6 Fin x) (2 : Nat)", "tactic_state": "\u22a2 let ty := \u2115;\n  (fun x => Fin x) 2"}, {"line": "exact 0", "tactic_state": "No Goals!"}]}
{"declaration": "example : (id : Nat \u2192 Nat) = (fun (x : let ty := Nat; ty) => x) := by\n  lift_lets\n  guard_target =\u209b let ty := Nat; (id: Nat \u2192 Nat) = fun (x : ty) \u21a6 x\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 id = fun x => x"}, {"line": "lift_lets", "tactic_state": "\u22a2 let ty := \u2115;\n  id = fun x => x"}, {"line": "guard_target =\u209b let ty := Nat; (id: Nat \u2192 Nat) = fun (x : ty) \u21a6 x", "tactic_state": "\u22a2 let ty := \u2115;\n  id = fun x => x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : (x : let ty := Nat; ty) \u2192 let y := (1 : Nat); Fin (y + Nat.succ x) := by\n  lift_lets\n  guard_target =\u209b let ty := Nat; let y := 1; (x : ty) \u2192 Fin (y + Nat.succ x)\n  intro ty y x\n  rw [Nat.add_succ]\n  rw [Nat.succ_eq_add_one]\n  exact 0\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (x :\n      let ty := \u2115;\n      ty) \u2192\n    let y := 1;\n    Fin (y + Nat.succ x)"}, {"line": "lift_lets", "tactic_state": "\u22a2 let ty := \u2115;\n  let y := 1;\n  (x : ty) \u2192 Fin (y + Nat.succ x)"}, {"line": "guard_target =\u209b let ty := Nat; let y := 1; (x : ty) \u2192 Fin (y + Nat.succ x)", "tactic_state": "\u22a2 let ty := \u2115;\n  let y := 1;\n  (x : ty) \u2192 Fin (y + Nat.succ x)"}, {"line": "intro ty y x", "tactic_state": "ty : Type := \u2115\ny : \u2115 := 1\nx : ty\n\u22a2 Fin (y + Nat.succ x)"}, {"line": "rw [Nat.add_succ]", "tactic_state": "ty : Type := \u2115\ny : \u2115 := 1\nx : ty\n\u22a2 Fin (y + x).succ"}, {"line": "rw [Nat.succ_eq_add_one]", "tactic_state": "ty : Type := \u2115\ny : \u2115 := 1\nx : ty\n\u22a2 Fin (y + x + 1)"}, {"line": "exact 0", "tactic_state": "No Goals!"}]}
{"declaration": "example : (x : Nat) \u2192 (y : Nat) \u2192 let z := x + 1; let w := 3; Fin (z + w) := by\n  lift_lets\n  guard_target =\u209b let w := 3; (x : Nat) \u2192 let z := x + 1; Nat \u2192 Fin (z + w)\n  intro w x z _y\n  simp [w, z]\n  exact 0\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (x : \u2115) \u2192\n    \u2115 \u2192\n      let z := x + 1;\n      let w := 3;\n      Fin (z + w)"}, {"line": "lift_lets", "tactic_state": "\u22a2 let w := 3;\n  (x : \u2115) \u2192\n    let z := x + 1;\n    \u2115 \u2192 Fin (z + w)"}, {"line": "guard_target =\u209b let w := 3; (x : Nat) \u2192 let z := x + 1; Nat \u2192 Fin (z + w)", "tactic_state": "\u22a2 let w := 3;\n  (x : \u2115) \u2192\n    let z := x + 1;\n    \u2115 \u2192 Fin (z + w)"}, {"line": "intro w x z _y", "tactic_state": "w : \u2115 := 3\nx : \u2115\nz : \u2115 := x + 1\n_y : \u2115\n\u22a2 Fin (z + w)"}, {"line": "simp [w, z]", "tactic_state": "w : \u2115 := 3\nx : \u2115\nz : \u2115 := x + 1\n_y : \u2115\n\u22a2 Fin (x + 1 + 3)"}, {"line": "exact 0", "tactic_state": "No Goals!"}]}
{"declaration": "example : (x : Nat) \u2192 let z := x + 1; (y : Nat) \u2192 let w := 3; Fin (z + w) := by\n  lift_lets\n  guard_target =\u209b let w := 3; (x : Nat) \u2192 let z := x + 1; Nat \u2192 Fin (z + w)\n  intro w x z _y\n  simp [w, z]\n  exact 0\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (x : \u2115) \u2192\n    let z := x + 1;\n    \u2115 \u2192\n      let w := 3;\n      Fin (z + w)"}, {"line": "lift_lets", "tactic_state": "\u22a2 let w := 3;\n  (x : \u2115) \u2192\n    let z := x + 1;\n    \u2115 \u2192 Fin (z + w)"}, {"line": "guard_target =\u209b let w := 3; (x : Nat) \u2192 let z := x + 1; Nat \u2192 Fin (z + w)", "tactic_state": "\u22a2 let w := 3;\n  (x : \u2115) \u2192\n    let z := x + 1;\n    \u2115 \u2192 Fin (z + w)"}, {"line": "intro w x z _y", "tactic_state": "w : \u2115 := 3\nx : \u2115\nz : \u2115 := x + 1\n_y : \u2115\n\u22a2 Fin (z + w)"}, {"line": "simp [w, z]", "tactic_state": "w : \u2115 := 3\nx : \u2115\nz : \u2115 := x + 1\n_y : \u2115\n\u22a2 Fin (x + 1 + 3)"}, {"line": "exact 0", "tactic_state": "No Goals!"}]}
{"declaration": "example : (let x := 1; x) = (let x := 1; x) := by\n  lift_lets\n  guard_target =\u209b let x := 1; x = x\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (let x := 1;\n    x) =\n    let x := 1;\n    x"}, {"line": "lift_lets", "tactic_state": "\u22a2 let x := 1;\n  x = x"}, {"line": "guard_target =\u209b let x := 1; x = x", "tactic_state": "\u22a2 let x := 1;\n  x = x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : (let x := 2; x) = (let y := 1; y + 1) := by\n  lift_lets\n  guard_target =\u209b let x := 2; let y := 1; x = y + 1\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (let x := 2;\n    x) =\n    let y := 1;\n    y + 1"}, {"line": "lift_lets", "tactic_state": "\u22a2 let x := 2;\n  let y := 1;\n  x = y + 1"}, {"line": "guard_target =\u209b let x := 2; let y := 1; x = y + 1", "tactic_state": "\u22a2 let x := 2;\n  let y := 1;\n  x = y + 1"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : (let x := 1; x) = y) : True := by\n  lift_lets at h\n  guard_hyp h :\u209b let x := 1; x = y\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u2115\nh :\n  (let x := 1;\n    x) =\n    y\n\u22a2 True"}, {"line": "lift_lets at h", "tactic_state": "y : \u2115\nh :\n  let x := 1;\n  x = y\n\u22a2 True"}, {"line": "guard_hyp h :\u209b let x := 1; x = y", "tactic_state": "y : \u2115\nh :\n  let x := 1;\n  x = y\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : (let x := 1; x) = y) : True := by\n  revert h\n  lift_lets\n  intro x h\n  guard_hyp x : Nat := 1\n  guard_hyp h :\u209b x = y\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u2115\nh :\n  (let x := 1;\n    x) =\n    y\n\u22a2 True"}, {"line": "revert h", "tactic_state": "y : \u2115\n\u22a2 (let x := 1;\n      x) =\n      y \u2192\n    True"}, {"line": "lift_lets", "tactic_state": "y : \u2115\n\u22a2 let x := 1;\n  x = y \u2192 True"}, {"line": "intro x h", "tactic_state": "y : \u2115\nx : \u2115 := 1\nh : x = y\n\u22a2 True"}, {"line": "guard_hyp x : Nat := 1", "tactic_state": "y : \u2115\nx : \u2115 := 1\nh : x = y\n\u22a2 True"}, {"line": "guard_hyp h :\u209b x = y", "tactic_state": "y : \u2115\nx : \u2115 := 1\nh : x = y\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example : let x := 1; \u2200 n, let y := 1; x + n = y + n := by\n  lift_lets\n  guard_target =\u209b let x := 1; \u2200 n, x + n = x + n\n  intros x n\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 let x := 1;\n  \u2200 (n : \u2115),\n    let y := 1;\n    x + n = y + n"}, {"line": "lift_lets", "tactic_state": "\u22a2 let x := 1;\n  \u2200 (n : \u2115), x + n = x + n"}, {"line": "guard_target =\u209b let x := 1; \u2200 n, x + n = x + n", "tactic_state": "\u22a2 let x := 1;\n  \u2200 (n : \u2115), x + n = x + n"}, {"line": "intros x n", "tactic_state": "x : \u2115 := 1\nn : \u2115\n\u22a2 x + n = x + n"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (m : Nat) (h : \u2203 n, n + 1 = m) (x : Fin m) (y : Fin _) :\n    cast (let h' := h.choose_spec.symm; congrArg Fin h') x = y := by\n  lift_lets (config := {proofs := true})\n  intro h'\n  clear_value h'\n  guard_hyp h' : m = Exists.choose h + 1\n  exact test_sorry", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LiftLets.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\nh : \u2203 n, n + 1 = m\nx : Fin m\ny : Fin (h.choose + 1)\n\u22a2 cast \u22ef x = y"}, {"line": "lift_lets (config := {proofs := true})", "tactic_state": "m : \u2115\nh : \u2203 n, n + 1 = m\nx : Fin m\ny : Fin (h.choose + 1)\n\u22a2 let h' := \u22ef;\n  cast \u22ef x = y"}, {"line": "intro h'", "tactic_state": "m : \u2115\nh : \u2203 n, n + 1 = m\nx : Fin m\ny : Fin (h.choose + 1)\nh' : m = h.choose + 1 := Eq.symm (Exists.choose_spec h)\n\u22a2 cast \u22ef x = y"}, {"line": "clear_value h'", "tactic_state": "m : \u2115\nh : \u2203 n, n + 1 = m\nx : Fin m\ny : Fin (h.choose + 1)\nh' : m = h.choose + 1\n\u22a2 cast \u22ef x = y"}, {"line": "guard_hyp h' : m = Exists.choose h + 1", "tactic_state": "m : \u2115\nh : \u2203 n, n + 1 = m\nx : Fin m\ny : Fin (h.choose + 1)\nh' : m = h.choose + 1\n\u22a2 cast \u22ef x = y"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : 0 + 0 = 0) : True := by\n  simp at h\n  try exact h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 + 0 = 0\n\u22a2 True"}, {"line": "simp at h", "tactic_state": "h : True\n\u22a2 True"}, {"line": "try exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b : Nat} (h : a = b) : a + 0 = b := by\n  simp\n  subst h\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a + 0 = b"}, {"line": "simp", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a = b"}, {"line": "subst h", "tactic_state": "a : \u2115\n\u22a2 a = a"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b : Nat} (h : a = b) : a + 0 = b := by\n  simp\n  induction a <;> assumption\n\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a + 0 = b"}, {"line": "simp", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a = b"}, {"line": "induction a <;> assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : 0 = 0 \u2228 0 = 0) : True := by\n  cases h <;>\n    rename_i h <;>\n    simp at h\n  \u00b7 exact h\n  \u00b7 assumption --exact h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 = 0 \u2228 0 = 0\n\u22a2 True"}, {"line": "cases h <;>\n    rename_i h <;>\n    simp at h", "tactic_state": "case inl\nh : True\n\u22a2 True\n---\ncase inr\nh : True\n\u22a2 True"}, {"line": "\u00b7 exact h", "tactic_state": "case inr\nh : True\n\u22a2 True"}, {"line": "\u00b7 assumption --exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : 0 = 1 \u2228 0 = 1) : 0 = 1 \u2227 0 = 1 := by\n  cases h <;> simp\n  on_goal 2 => \u00b7 contradiction\n  \u00b7 contradiction\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 = 1 \u2228 0 = 1\n\u22a2 0 = 1 \u2227 0 = 1"}, {"line": "cases h <;> simp", "tactic_state": "case inl\nh\u271d : 0 = 1\n\u22a2 False\n---\ncase inr\nh\u271d : 0 = 1\n\u22a2 False"}, {"line": "on_goal 2 => \u00b7 contradiction", "tactic_state": "case inl\nh\u271d : 0 = 1\n\u22a2 False"}, {"line": "\u00b7 contradiction", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : 0 = 1 \u2228 0 = 1) : 0 = 1 \u2227 0 = 1 := by\n  cases h <;> simp\n  \u00b7 contradiction\n  \u00b7 contradiction\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 = 1 \u2228 0 = 1\n\u22a2 0 = 1 \u2227 0 = 1"}, {"line": "cases h <;> simp", "tactic_state": "case inl\nh\u271d : 0 = 1\n\u22a2 False\n---\ncase inr\nh\u271d : 0 = 1\n\u22a2 False"}, {"line": "\u00b7 contradiction", "tactic_state": "case inr\nh\u271d : 0 = 1\n\u22a2 False"}, {"line": "\u00b7 contradiction", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b : Nat} (h : \u2200 c, c + a + b = a + c) : (0 + 2 + 1 + a + b) = a + 3 := by\n  simp\n  specialize h 3\n  simp_all\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : \u2200 (c : \u2115), c + a + b = a + c\n\u22a2 0 + 2 + 1 + a + b = a + 3"}, {"line": "simp", "tactic_state": "a b : \u2115\nh : \u2200 (c : \u2115), c + a + b = a + c\n\u22a2 3 + a + b = a + 3"}, {"line": "specialize h 3", "tactic_state": "a b : \u2115\nh : 3 + a + b = a + 3\n\u22a2 3 + a + b = a + 3"}, {"line": "simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "example : (0 + 2 : Rat) + 1 = 3 := by\n  simp\n  norm_num\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 + 2 + 1 = 3"}, {"line": "simp", "tactic_state": "\u22a2 2 + 1 = 3"}, {"line": "norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "example {a : Rat} : a + (0 + 2 + 1 : Rat) = 3 + a := by\n  simp\n  norm_num\n  rw [add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211a\n\u22a2 a + (0 + 2 + 1) = 3 + a"}, {"line": "simp", "tactic_state": "a : \u211a\n\u22a2 a + (2 + 1) = 3 + a"}, {"line": "norm_num", "tactic_state": "a : \u211a\n\u22a2 a + 3 = 3 + a"}, {"line": "rw [add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b : Nat} (h : a = b) : a + b + 0 = b + a := by\n  simp\n  congr\n  exact h.symm\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a + b + 0 = b + a"}, {"line": "simp", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a + b = b + a"}, {"line": "congr", "tactic_state": "case e_a\na b : \u2115\nh : a = b\n\u22a2 b = a"}, {"line": "exact h.symm", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : False) : 0 \u2260 0 := by\n  try (simp; done)\n  exact h.elim\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : False\n\u22a2 0 \u2260 0"}, {"line": "try (simp; done)", "tactic_state": "h : False\n\u22a2 0 \u2260 0"}, {"line": "exact h.elim", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b : Nat} (h : a + b = a + (b + 1)) : a + b = b + a + 0 + 1 := by\n  simp\n  abel_nf\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a + b = a + (b + 1)\n\u22a2 a + b = b + a + 0 + 1"}, {"line": "simp", "tactic_state": "a b : \u2115\nh : a + b = a + (b + 1)\n\u22a2 a + b = b + a + 1"}, {"line": "abel_nf", "tactic_state": "a b : \u2115\nh : a + b = a + (b + 1)\n\u22a2 a + b = a + (b + 1)"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b : Nat} : a + b = b + a + 0 := by\n  simp\n  abel\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 a + b = b + a + 0"}, {"line": "simp", "tactic_state": "a b : \u2115\n\u22a2 a + b = b + a"}, {"line": "abel", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b : Nat} (h : a + b = 1 + a + b) : a + b = b + a + 0 + 1 := by\n  simp\n  ring_nf\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a + b = 1 + a + b\n\u22a2 a + b = b + a + 0 + 1"}, {"line": "simp", "tactic_state": "a b : \u2115\nh : a + b = 1 + a + b\n\u22a2 a + b = b + a + 1"}, {"line": "ring_nf", "tactic_state": "a b : \u2115\nh : a + b = 1 + a + b\n\u22a2 a + b = 1 + a + b"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b : Nat} : a + b = b + a + 0 := by\n  simp\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 a + b = b + a + 0"}, {"line": "simp", "tactic_state": "a b : \u2115\n\u22a2 a + b = b + a"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : 0 = 1 \u2228 0 = 1) : 0 = 1 \u2227 0 = 1 := by\n  cases h <;> simp\n  \u00b7 simp_all\n  \u00b7 contradiction\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 = 1 \u2228 0 = 1\n\u22a2 0 = 1 \u2227 0 = 1"}, {"line": "cases h <;> simp", "tactic_state": "case inl\nh\u271d : 0 = 1\n\u22a2 False\n---\ncase inr\nh\u271d : 0 = 1\n\u22a2 False"}, {"line": "\u00b7 simp_all", "tactic_state": "case inr\nh\u271d : 0 = 1\n\u22a2 False"}, {"line": "\u00b7 contradiction", "tactic_state": "No Goals!"}]}
{"declaration": "example {h : 0 = 0} {k : 1 = 1} : \u00ac \u00ac True := by\n  simp at h\n  rw [\u2190 Nat.add_zero 1] at k\n  -- flag below vvv do not flag above ^^^\n  rw [\u2190 Classical.not_not (a := True)] at h\n  --exact h -- <-- flagged\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 = 0\nk : 1 = 1\n\u22a2 \u00ac\u00acTrue"}, {"line": "simp at h", "tactic_state": "k : 1 = 1\nh : True\n\u22a2 \u00ac\u00acTrue"}, {"line": "rw [\u2190 Nat.add_zero 1] at k", "tactic_state": "k : 1 + 0 = 1 + 0\nh : True\n\u22a2 \u00ac\u00acTrue"}, {"line": "rw [\u2190 Classical.not_not (a := True)] at h", "tactic_state": "k : 1 + 0 = 1 + 0\nh : \u00ac\u00acTrue\n\u22a2 \u00ac\u00acTrue"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example {h : 0 = 0} {k : 1 = 1} : True := by\n  simp at h k\n  rw [\u2190 Classical.not_not (a := True)]\n  -- flag the two below vvv do not above ^^^\n  rw [\u2190 Classical.not_not (a := True)] at k\n  rw [\u2190 Classical.not_not (a := True)] at h\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 = 0\nk : 1 = 1\n\u22a2 True"}, {"line": "simp at h k", "tactic_state": "h k : True\n\u22a2 True"}, {"line": "rw [\u2190 Classical.not_not (a := True)]", "tactic_state": "h k : True\n\u22a2 \u00ac\u00acTrue"}, {"line": "rw [\u2190 Classical.not_not (a := True)] at k", "tactic_state": "h : True\nk : \u00ac\u00acTrue\n\u22a2 \u00ac\u00acTrue"}, {"line": "rw [\u2190 Classical.not_not (a := True)] at h", "tactic_state": "h k : \u00ac\u00acTrue\n\u22a2 \u00ac\u00acTrue"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example {h : 0 = 0} : True := by\n  simp at h\n  rw [\u2190 Classical.not_not (a := True)]\n  -- flag below vvv do not flag above ^^^\n  rw [\u2190 Classical.not_not (a := True)] at h\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : 0 = 0\n\u22a2 True"}, {"line": "simp at h", "tactic_state": "h : True\n\u22a2 True"}, {"line": "rw [\u2190 Classical.not_not (a := True)]", "tactic_state": "h : True\n\u22a2 \u00ac\u00acTrue"}, {"line": "rw [\u2190 Classical.not_not (a := True)] at h", "tactic_state": "h : \u00ac\u00acTrue\n\u22a2 \u00ac\u00acTrue"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example {h : False} : 0 = 1 := by\n  simp\n  rw [\u2190 Classical.not_not (a := False)] at h\n  -- flag below vvv do not flag above ^^^\n  rwa [\u2190 Classical.not_not (a := False)]\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/FlexibleLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : False\n\u22a2 0 = 1"}, {"line": "simp", "tactic_state": "h : False\n\u22a2 False"}, {"line": "rw [\u2190 Classical.not_not (a := False)] at h", "tactic_state": "h : \u00ac\u00acFalse\n\u22a2 False"}, {"line": "rwa [\u2190 Classical.not_not (a := False)]", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u2115) (h : x < 2) : Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) < 2 := by\n  generalize_proofs a\n  guard_hyp a :\u209b \u2203 x, x < 2\n  guard_target =\u209b Classical.choose a < 2\n  exact Classical.choose_spec a\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef < 2"}, {"line": "generalize_proofs a", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "guard_hyp a :\u209b \u2203 x, x < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "guard_target =\u209b Classical.choose a < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "exact Classical.choose_spec a", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u2115) (h : x < 2) :\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) := by\n  generalize_proofs a\n  guard_hyp a :\u209b \u2203 x, x < 2\n  guard_target =\u209b Classical.choose a = Classical.choose a\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "generalize_proofs a", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "guard_hyp a :\u209b \u2203 x, x < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "guard_target =\u209b Classical.choose a = Classical.choose a", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u2115) (h : x < 2) (h' : x < 1) :\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)\n      = Classical.choose (\u27e8x, (by clear h; omega)\u27e9 : \u2203 x, x < 2) := by\n  generalize_proofs a\n  guard_hyp a :\u209b \u2203 x, x < 2\n  guard_target =\u209b Classical.choose a = Classical.choose a\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\nh' : x < 1\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "generalize_proofs a", "tactic_state": "x : \u2115\nh : x < 2\nh' : x < 1\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "guard_hyp a :\u209b \u2203 x, x < 2", "tactic_state": "x : \u2115\nh : x < 2\nh' : x < 1\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "guard_target =\u209b Classical.choose a = Classical.choose a", "tactic_state": "x : \u2115\nh : x < 2\nh' : x < 1\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u2115) (h h' : x < 2) :\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h'\u27e9 : \u2203 x, x < 2) := by\n  change _ at h'\n  fail_if_success guard_target =\u209b\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)\n  generalize_proofs at h'\n  fail_if_success change _ at h'\n  guard_target =\u209b Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)\n  generalize_proofs a\n  guard_target =\u209b Classical.choose a = Classical.choose a\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh h' : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "change _ at h'", "tactic_state": "x : \u2115\nh h' : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "fail_if_success guard_target =\u209b\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)", "tactic_state": "x : \u2115\nh h' : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "generalize_proofs at h'", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "fail_if_success change _ at h'", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "guard_target =\u209b Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) = Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "generalize_proofs a", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "guard_target =\u209b Classical.choose a = Classical.choose a", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\n\u22a2 Classical.choose a = Classical.choose a"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u2115) (h : x < 2) :\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2)\n      = Classical.choose (\u27e8x, Nat.lt_succ_of_lt h\u27e9 : \u2203 x, x < 3) := by\n  generalize_proofs a a'\n  guard_hyp a :\u209b \u2203 x, x < 2\n  guard_hyp a' :\u209b \u2203 x, x < 3\n  guard_target =\u209b Classical.choose a = Classical.choose a'\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "generalize_proofs a a'", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\na' : \u2203 x, x < 3\n\u22a2 Classical.choose a = Classical.choose a'"}, {"line": "guard_hyp a :\u209b \u2203 x, x < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\na' : \u2203 x, x < 3\n\u22a2 Classical.choose a = Classical.choose a'"}, {"line": "guard_hyp a' :\u209b \u2203 x, x < 3", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\na' : \u2203 x, x < 3\n\u22a2 Classical.choose a = Classical.choose a'"}, {"line": "guard_target =\u209b Classical.choose a = Classical.choose a'", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\na' : \u2203 x, x < 3\n\u22a2 Classical.choose a = Classical.choose a'"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u2115) (h : x < 2) : Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) =\n  Classical.choose (\u27e8x, Nat.lt_succ_of_lt h\u27e9 : \u2203 x, x < 3) := by\n  generalize_proofs\n  guard_target = Classical.choose _ = Classical.choose _\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "generalize_proofs", "tactic_state": "x : \u2115\nh : x < 2\npf\u271d\u00b9 : \u2203 x, x < 2\npf\u271d : \u2203 x, x < 3\n\u22a2 Classical.choose pf\u271d\u00b9 = Classical.choose pf\u271d"}, {"line": "guard_target = Classical.choose _ = Classical.choose _", "tactic_state": "x : \u2115\nh : x < 2\npf\u271d\u00b9 : \u2203 x, x < 2\npf\u271d : \u2203 x, x < 3\n\u22a2 Classical.choose pf\u271d\u00b9 = Classical.choose pf\u271d"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u2115) (h : x < 2) : Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) =\n  Classical.choose (\u27e8x, Nat.lt_succ_of_lt h\u27e9 : \u2203 x, x < 3) := by\n  generalize_proofs _ a\n  guard_hyp a : \u2203 x, x < 3\n  guard_target = Classical.choose _ = Classical.choose a\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\n\u22a2 Classical.choose \u22ef = Classical.choose \u22ef"}, {"line": "generalize_proofs _ a", "tactic_state": "x : \u2115\nh : x < 2\npf\u271d : \u2203 x, x < 2\na : \u2203 x, x < 3\n\u22a2 Classical.choose pf\u271d = Classical.choose a"}, {"line": "guard_hyp a : \u2203 x, x < 3", "tactic_state": "x : \u2115\nh : x < 2\npf\u271d : \u2203 x, x < 2\na : \u2203 x, x < 3\n\u22a2 Classical.choose pf\u271d = Classical.choose a"}, {"line": "guard_target = Classical.choose _ = Classical.choose a", "tactic_state": "x : \u2115\nh : x < 2\npf\u271d : \u2203 x, x < 2\na : \u2203 x, x < 3\n\u22a2 Classical.choose pf\u271d = Classical.choose a"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (a : \u2203 x, x < 2) : Classical.choose a < 2 := by\n  generalize_proofs\n  guard_target =\u209b Classical.choose a < 2\n  exact Classical.choose_spec a\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "generalize_proofs", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "guard_target =\u209b Classical.choose a < 2", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "exact Classical.choose_spec a", "tactic_state": "No Goals!"}]}
{"declaration": "example (a : \u2203 x, x < 2) : Classical.choose a < 2 := by\n  generalize_proofs t\n  guard_target =\u209b Classical.choose a < 2\n  exact Classical.choose_spec a\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "generalize_proofs t", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "guard_target =\u209b Classical.choose a < 2", "tactic_state": "a : \u2203 x, x < 2\n\u22a2 Classical.choose a < 2"}, {"line": "exact Classical.choose_spec a", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u2115) (h : x < 2) (H : Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) < 2) :\n    Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < 2) < 2 := by\n  generalize_proofs a at H \u22a2\n  guard_hyp a :\u209b \u2203 x, x < 2\n  guard_hyp H :\u209b Classical.choose a < 2\n  guard_target =\u209b Classical.choose a < 2\n  exact H\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x < 2\nH : Classical.choose \u22ef < 2\n\u22a2 Classical.choose \u22ef < 2"}, {"line": "generalize_proofs a at H \u22a2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\nH : Classical.choose a < 2\n\u22a2 Classical.choose a < 2"}, {"line": "guard_hyp a :\u209b \u2203 x, x < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\nH : Classical.choose a < 2\n\u22a2 Classical.choose a < 2"}, {"line": "guard_hyp H :\u209b Classical.choose a < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\nH : Classical.choose a < 2\n\u22a2 Classical.choose a < 2"}, {"line": "guard_target =\u209b Classical.choose a < 2", "tactic_state": "x : \u2115\nh : x < 2\na : \u2203 x, x < 2\nH : Classical.choose a < 2\n\u22a2 Classical.choose a < 2"}, {"line": "exact H", "tactic_state": "No Goals!"}]}
{"declaration": "example (H : \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y) :\n    \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y := by\n  generalize_proofs (config := { abstract := false })\n  guard_target =\u209b \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y\n  generalize_proofs a at H \u22a2\n  guard_hyp a :\u209b \u2200 (y w : \u2115), w < y \u2192 \u2203 x, x < y\n  guard_hyp H :\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y\n  guard_target =\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y\n  exact H\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "generalize_proofs (config := { abstract := false })", "tactic_state": "H : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "guard_target =\u209b \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y", "tactic_state": "H : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "generalize_proofs a at H \u22a2", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "guard_hyp a :\u209b \u2200 (y w : \u2115), w < y \u2192 \u2203 x, x < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "guard_hyp H :\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "guard_target =\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "exact H", "tactic_state": "No Goals!"}]}
{"declaration": "example (H : \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y) :\n    \u2200 y, \u2203 (x : \u2115) (h : x < y), Classical.choose (\u27e8x, h\u27e9 : \u2203 x, x < y) < y := by\n  generalize_proofs a at *\n  guard_hyp a :\u209b \u2200 (y w : \u2115), w < y \u2192 \u2203 x, x < y\n  guard_hyp H :\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y\n  guard_target =\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y\n  exact H\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "generalize_proofs a at *", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "guard_hyp a :\u209b \u2200 (y w : \u2115), w < y \u2192 \u2203 x, x < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "guard_hyp H :\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "guard_target =\u209b \u2200 (y : \u2115), \u2203 x h, Classical.choose (a y x h) < y", "tactic_state": "a : \u2200 (y x : \u2115), x < y \u2192 \u2203 x, x < y\nH : \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y\n\u22a2 \u2200 (y : \u2115), \u2203 x, \u2203 (h : x < y), Classical.choose \u22ef < y"}, {"line": "exact H", "tactic_state": "No Goals!"}]}
{"declaration": "theorem good (x : Option Unit) : p (Option.get x test_sorry) \u2192 x.isSome = true := by\n  generalize_proofs h\n  exact fun _ => h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\np : x\u271d\nx : Option Unit\n\u22a2 sorry \u2192 x.isSome = true"}, {"line": "generalize_proofs h", "tactic_state": "x\u271d : Sort u_1\np : x\u271d\nx : Option Unit\n\u22a2 sorry \u2192 x.isSome = true"}, {"line": "exact fun _ => h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem was_bad (x : Option Unit) : p (Option.get x (t x)) \u2192 x.isSome = true := by\n  generalize_proofs h\n  exact fun _ => h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/GeneralizeProofs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\np : x\u271d\nx : Option Unit\n\u22a2 sorry \u2192 x.isSome = true"}, {"line": "generalize_proofs h", "tactic_state": "x\u271d : Sort u_1\np : x\u271d\nx : Option Unit\n\u22a2 sorry \u2192 x.isSome = true"}, {"line": "exact fun _ => h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma uses_norm_num : (0 + 1 : \u2115) = 1 := by norm_num\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MinImports.lean", "context": {"open": ["Lean.Elab.Command Mathlib.Command.MinImports in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 + 1 = 1"}, {"line": "norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b c : G) : c*(a*b)*(b\u207b\u00b9*a\u207b\u00b9)*c = c*c := by group\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\na b c : G\n\u22a2 c * (a * b) * (b\u207b\u00b9 * a\u207b\u00b9) * c = c * c"}, {"line": "group", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b c : G) : (b*c\u207b\u00b9)*c*(a*b)*(b\u207b\u00b9*a\u207b\u00b9)*c = b*c := by group\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\na b c : G\n\u22a2 b * c\u207b\u00b9 * c * (a * b) * (b\u207b\u00b9 * a\u207b\u00b9) * c = b * c"}, {"line": "group", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b c : G) : c\u207b\u00b9*(b*c\u207b\u00b9)*c*(a*b)*(b\u207b\u00b9*a\u207b\u00b9*b\u207b\u00b9)*c = 1 := by group\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\na b c : G\n\u22a2 c\u207b\u00b9 * (b * c\u207b\u00b9) * c * (a * b) * (b\u207b\u00b9 * a\u207b\u00b9 * b\u207b\u00b9) * c = 1"}, {"line": "group", "tactic_state": "No Goals!"}]}
{"declaration": "example (g h k : G) : g*\u2045\u2045g\u207b\u00b9,h\u2046,k\u2046*g\u207b\u00b9*k*\u2045\u2045k\u207b\u00b9,g\u2046,h\u2046*k\u207b\u00b9*h*\u2045\u2045h\u207b\u00b9,k\u2046,g\u2046*h\u207b\u00b9 = 1 := by group\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\ng h k : G\n\u22a2 g * \u2045\u2045g\u207b\u00b9, h\u2046, k\u2046 * g\u207b\u00b9 * k * \u2045\u2045k\u207b\u00b9, g\u2046, h\u2046 * k\u207b\u00b9 * h * \u2045\u2045h\u207b\u00b9, k\u2046, g\u2046 * h\u207b\u00b9 = 1"}, {"line": "group", "tactic_state": "G : Type\ninst\u271d : Group G\ng h k : G\n\u22a2 h * g * h ^ (-1) * k * (g ^ (-1) * h * g * h ^ (-1)) ^ (-1) * g ^ (-1) * h * (k ^ (-1) * g * k * g ^ (-1)) ^ (-1) *\n              k ^ (-1) *\n            g *\n          (h ^ (-1) * k * h * k ^ (-1)) ^ (-1) *\n        g ^ (-1) *\n      h ^ (-1) =\n    1"}]}
{"declaration": "example (a : G) : a^2*a = a^3 := by group\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\na : G\n\u22a2 a ^ 2 * a = a ^ 3"}, {"line": "group", "tactic_state": "No Goals!"}]}
{"declaration": "example (n m : \u2115) (a : G) : a^n*a^m = a^(n+m) := by group\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\nn m : \u2115\na : G\n\u22a2 a ^ n * a ^ m = a ^ (n + m)"}, {"line": "group", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b c : G) : c*(a*b^2)*((b*b)\u207b\u00b9*a\u207b\u00b9)*c = c*c := by group\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\na b c : G\n\u22a2 c * (a * b ^ 2) * ((b * b)\u207b\u00b9 * a\u207b\u00b9) * c = c * c"}, {"line": "group", "tactic_state": "G : Type\ninst\u271d : Group G\na b c : G\n\u22a2 c * a * b ^ 2 * (b * b) ^ (-1) * a ^ (-1) * c = c * c"}]}
{"declaration": "example (n : \u2115) (a : G) : a^n*(a\u207b\u00b9)^n = 1 := by group\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Group.lean", "context": {"open": [], "variables": ["{G : Type} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type\ninst\u271d : Group G\nn : \u2115\na : G\n\u22a2 a ^ n * a\u207b\u00b9 ^ n = 1"}, {"line": "group", "tactic_state": "No Goals!"}]}
{"declaration": "example : Nat := by\n  have : Nat\n  \u00b7 exact 5\n  exact this\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2115"}, {"line": "have : Nat", "tactic_state": "case this\n\u22a2 \u2115\n---\nthis : \u2115\n\u22a2 \u2115"}, {"line": "\u00b7 exact 5", "tactic_state": "this : \u2115\n\u22a2 \u2115"}, {"line": "exact this", "tactic_state": "No Goals!"}]}
{"declaration": "example {a : Nat} : a = a := by\n  have h : a = a\n  \u00b7 rfl\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 a = a"}, {"line": "have h : a = a", "tactic_state": "case h\na : \u2115\n\u22a2 a = a\n---\na : \u2115\nh : a = a\n\u22a2 a = a"}, {"line": "\u00b7 rfl", "tactic_state": "a : \u2115\nh : a = a\n\u22a2 a = a"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example {a : Nat} : a = a := by\n  have : a = a\n  \u00b7 rfl\n  exact this\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 a = a"}, {"line": "have : a = a", "tactic_state": "case this\na : \u2115\n\u22a2 a = a\n---\na : \u2115\nthis : a = a\n\u22a2 a = a"}, {"line": "\u00b7 rfl", "tactic_state": "a : \u2115\nthis : a = a\n\u22a2 a = a"}, {"line": "exact this", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9\n  exact .intro\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9", "tactic_state": "_zero : \u2115\nisLt\u271d : _zero < 1\n\u22a2 True"}, {"line": "exact .intro", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9\n  exact .intro\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9", "tactic_state": "_zero : \u2115\nisLt\u271d : _zero < 1\n\u22a2 True"}, {"line": "exact .intro", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex1 (a b c : Nat) (h : a = b) : a + c = b + c := by\n  congr!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : a = b\n\u22a2 a + c = b + c"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex2 (a b : Nat) (h : a = b) : \u2200 c, a + c = b + c := by\n  congr!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 \u2200 (c : \u2115), a + c = b + c"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex3 (a b : Nat) (h : a = b) : (fun c => a + c) = (fun c => b + c) := by\n  congr!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 (fun c => a + c) = fun c => b + c"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex4 (a b : Nat) : Fin (a + b) = Fin (b + a) := by\n  congr! 1\n  guard_target = a + b = b + a\n  apply Nat.add_comm\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 Fin (a + b) = Fin (b + a)"}, {"line": "congr! 1", "tactic_state": "case h.e'_1\na b : \u2115\n\u22a2 a + b = b + a"}, {"line": "guard_target = a + b = b + a", "tactic_state": "case h.e'_1\na b : \u2115\n\u22a2 a + b = b + a"}, {"line": "apply Nat.add_comm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex5 : ((a : Nat) \u2192 Fin (a + 1)) = ((a : Nat) \u2192 Fin (1 + a)) := by\n  congr! 2 with a\n  guard_target = a + 1 = 1 + a\n  apply Nat.add_comm\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 ((a : \u2115) \u2192 Fin (a + 1)) = ((a : \u2115) \u2192 Fin (1 + a))"}, {"line": "congr! 2 with a", "tactic_state": "case h.h.e'_1\na : \u2115\n\u22a2 a + 1 = 1 + a"}, {"line": "guard_target = a + 1 = 1 + a", "tactic_state": "case h.h.e'_1\na : \u2115\n\u22a2 a + 1 = 1 + a"}, {"line": "apply Nat.add_comm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex6 : ((a : Nat) \u00d7 Fin (a + 1)) = ((a : Nat) \u00d7 Fin (1 + a)) := by\n  congr! 3 with a\n  guard_target = a + 1 = 1 + a\n  apply Nat.add_comm\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 ((a : \u2115) \u00d7 Fin (a + 1)) = ((a : \u2115) \u00d7 Fin (1 + a))"}, {"line": "congr! 3 with a", "tactic_state": "case h.e'_2.h.h.e'_1\na : \u2115\n\u22a2 a + 1 = 1 + a"}, {"line": "guard_target = a + 1 = 1 + a", "tactic_state": "case h.e'_2.h.h.e'_1\na : \u2115\n\u22a2 a + 1 = 1 + a"}, {"line": "apply Nat.add_comm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex7 (p : Prop) (h1 h2 : p) : h1 = h2 := by\n  congr!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\nh1 h2 : p\n\u22a2 h1 = h2"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex8 (p q : Prop) (h1 : p) (h2 : q) : HEq h1 h2 := by\n  congr!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh1 : p\nh2 : q\n\u22a2 HEq h1 h2"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex9 (a b : Nat) (h : a = b) : a + 1 \u2264 b + 1 := by\n  congr!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a + 1 \u2264 b + 1"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex10 (x y : Unit) : x = y := by\n  congr!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : Unit\n\u22a2 x = y"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex11 (p q r : Nat \u2192 Prop) (h : q = r) : (\u2200 n, p n \u2192 q n) \u2194 (\u2200 n, p n \u2192 r n) := by\n  congr!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : \u2115 \u2192 Prop\nh : q = r\n\u22a2 (\u2200 (n : \u2115), p n \u2192 q n) \u2194 \u2200 (n : \u2115), p n \u2192 r n"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex12 (p q : Prop) (h : p \u2194 q) : p = q := by\n  congr!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh : p \u2194 q\n\u22a2 p = q"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex13 (x y : \u03b1) (h : x = y) (f : \u03b1 \u2192 Nat) : f x = f y := by\n  congr!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nx y : \u03b1\nh : x = y\nf : \u03b1 \u2192 \u2115\n\u22a2 f x = f y"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex14 {\u03b1 : Type} (f : Nat \u2192 Nat) (h : \u2200 x, f x = 0) (z : \u03b1) (hz : HEq z 0) :\n    HEq f (fun (_ : \u03b1) => z) := by\n  congr!\n  \u00b7 guard_target = Nat = \u03b1\n    exact type_eq_of_heq hz.symm\n  next n x _ =>\n    guard_target = HEq (f n) z\n    rw [h]\n    exact hz.symm\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nf : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = 0\nz : \u03b1\nhz : HEq z 0\n\u22a2 HEq f fun x => z"}, {"line": "congr!", "tactic_state": "case h\u03b1\n\u03b1 : Type\nf : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = 0\nz : \u03b1\nhz : HEq z 0\n\u22a2 \u2115 = \u03b1\n---\ncase h\n\u03b1 : Type\nf : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = 0\nz : \u03b1\nhz : HEq z 0\na\u271d\u00b9 : \u2115\na'\u271d : \u03b1\na\u271d : HEq a\u271d\u00b9 a'\u271d\n\u22a2 HEq (f a\u271d\u00b9) z"}, {"line": "\u00b7 guard_target = Nat = \u03b1\n    exact type_eq_of_heq hz.symm", "tactic_state": "case h\n\u03b1 : Type\nf : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = 0\nz : \u03b1\nhz : HEq z 0\na\u271d\u00b9 : \u2115\na'\u271d : \u03b1\na\u271d : HEq a\u271d\u00b9 a'\u271d\n\u22a2 HEq (f a\u271d\u00b9) z"}, {"line": "next n x _ =>\n    guard_target = HEq (f n) z\n    rw [h]\n    exact hz.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex15 (p q : Nat \u2192 Prop) :\n    (\u2200 \u03b5 > 0, p \u03b5) \u2194 \u2200 \u03b5 > 0, q \u03b5 := by\n  congr! 2 with \u03b5 h\u03b5\n  guard_hyp h\u03b5 : \u03b5 > 0\n  guard_target = p \u03b5 \u2194 q \u03b5\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u2115 \u2192 Prop\n\u22a2 (\u2200 \u03b5 > 0, p \u03b5) \u2194 \u2200 \u03b5 > 0, q \u03b5"}, {"line": "congr! 2 with \u03b5 h\u03b5", "tactic_state": "case a.h.h'.a\np q : \u2115 \u2192 Prop\n\u03b5 : \u2115\nh\u03b5 : \u03b5 > 0\n\u22a2 p \u03b5 \u2194 q \u03b5"}, {"line": "guard_hyp h\u03b5 : \u03b5 > 0", "tactic_state": "case a.h.h'.a\np q : \u2115 \u2192 Prop\n\u03b5 : \u2115\nh\u03b5 : \u03b5 > 0\n\u22a2 p \u03b5 \u2194 q \u03b5"}, {"line": "guard_target = p \u03b5 \u2194 q \u03b5", "tactic_state": "case a.h.h'.a\np q : \u2115 \u2192 Prop\n\u03b5 : \u2115\nh\u03b5 : \u03b5 > 0\n\u22a2 p \u03b5 \u2194 q \u03b5"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (s t : Set \u03b1) : (\u2115 \u00d7 Subtype s) = (\u2115 \u00d7 Subtype t) := by\n  congr! 1\n  guard_target = Subtype s = Subtype t\n  congr! 1\n  guard_target = s = t\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 (\u2115 \u00d7 Subtype s) = (\u2115 \u00d7 Subtype t)"}, {"line": "congr! 1", "tactic_state": "case h.e'_2\n\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 Subtype s = Subtype t"}, {"line": "guard_target = Subtype s = Subtype t", "tactic_state": "case h.e'_2\n\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 Subtype s = Subtype t"}, {"line": "congr! 1", "tactic_state": "case h.e'_2.h.e'_2\n\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 s = t"}, {"line": "guard_target = s = t", "tactic_state": "case h.e'_2.h.e'_2\n\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 s = t"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (s t : Set \u03b1) (f : Subtype s \u2192 \u03b1) (g : Subtype t \u2192 \u03b1) :\n    Set.image f Set.univ = Set.image g Set.univ := by\n  congr!\n  \u00b7 guard_target = s = t\n    exact test_sorry\n  \u00b7 guard_target = HEq f g\n    exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\nf : Subtype s \u2192 \u03b1\ng : Subtype t \u2192 \u03b1\n\u22a2 f '' Set.univ = g '' Set.univ"}, {"line": "congr!", "tactic_state": "case h.e'_1.h.e'_2\n\u03b1 : Type u_1\ns t : Set \u03b1\nf : Subtype s \u2192 \u03b1\ng : Subtype t \u2192 \u03b1\n\u22a2 s = t\n---\ncase h.e'_3\n\u03b1 : Type u_1\ns t : Set \u03b1\nf : Subtype s \u2192 \u03b1\ng : Subtype t \u2192 \u03b1\ne_1\u271d : Subtype s = Subtype t\n\u22a2 HEq f g"}, {"line": "\u00b7 guard_target = s = t\n    exact test_sorry", "tactic_state": "case h.e'_3\n\u03b1 : Type u_1\ns t : Set \u03b1\nf : Subtype s \u2192 \u03b1\ng : Subtype t \u2192 \u03b1\ne_1\u271d : Subtype s = Subtype t\n\u22a2 HEq f g"}, {"line": "\u00b7 guard_target = HEq f g\n    exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b9 \u03ba : Type u} (f : \u03b9 \u2192 \u03b1) (g : \u03ba \u2192 \u03b1) :\n    Set.image f Set.univ = Set.image g Set.univ := by\n  congr!\n  guard_target = Set.image f Set.univ = Set.image g Set.univ\n  congr! (config := {typeEqs := true})\n  \u00b7 guard_target = \u03b9 = \u03ba\n    exact test_sorry\n  \u00b7 guard_target = HEq f g\n    exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\n\u22a2 f '' Set.univ = g '' Set.univ"}, {"line": "congr!", "tactic_state": "\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\n\u22a2 f '' Set.univ = g '' Set.univ"}, {"line": "guard_target = Set.image f Set.univ = Set.image g Set.univ", "tactic_state": "\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\n\u22a2 f '' Set.univ = g '' Set.univ"}, {"line": "congr! (config := {typeEqs := true})", "tactic_state": "case h.e'_1\n\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\n\u22a2 \u03b9 = \u03ba\n---\ncase h.e'_3\n\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\ne_1\u271d : \u03b9 = \u03ba\n\u22a2 HEq f g"}, {"line": "\u00b7 guard_target = \u03b9 = \u03ba\n    exact test_sorry", "tactic_state": "case h.e'_3\n\u03b1 : Type u_1\n\u03b9 \u03ba : Type u\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\ne_1\u271d : \u03b9 = \u03ba\n\u22a2 HEq f g"}, {"line": "\u00b7 guard_target = HEq f g\n    exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (s : Set \u03b1) (t : Set \u03b2) : (\u2115 \u00d7 Subtype s) = (\u2115 \u00d7 Subtype t) := by\n  congr!\n  guard_target = Subtype s = Subtype t\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type u_1\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 (\u2115 \u00d7 Subtype s) = (\u2115 \u00d7 Subtype t)"}, {"line": "congr!", "tactic_state": "case h.e'_2\n\u03b1 \u03b2 : Type u_1\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 Subtype s = Subtype t"}, {"line": "guard_target = Subtype s = Subtype t", "tactic_state": "case h.e'_2\n\u03b1 \u03b2 : Type u_1\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 Subtype s = Subtype t"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (m n : Nat) (h : m = n) (x : Fin m) (y : Fin n) : HEq (x + x) (y + y) := by\n  congr!\n  guard_target = HEq x y\n  exact test_sorry\n  guard_target = HEq x y\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\n\u22a2 HEq (x + x) (y + y)"}, {"line": "congr!", "tactic_state": "case e'_5\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_1\u271d : Fin m = Fin n\n\u22a2 HEq x y\n---\ncase e'_6\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_2\u271d : Fin m = Fin n\n\u22a2 HEq x y"}, {"line": "guard_target = HEq x y", "tactic_state": "case e'_5\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_1\u271d : Fin m = Fin n\n\u22a2 HEq x y\n---\ncase e'_6\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_2\u271d : Fin m = Fin n\n\u22a2 HEq x y"}, {"line": "exact test_sorry", "tactic_state": "case e'_6\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_2\u271d : Fin m = Fin n\n\u22a2 HEq x y"}, {"line": "guard_target = HEq x y", "tactic_state": "case e'_6\nm n : \u2115\nh : m = n\nx : Fin m\ny : Fin n\ne_2\u271d : Fin m = Fin n\n\u22a2 HEq x y"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q r : Prop) : p \u2227 q \u2194 p \u2227 r := by\n  congr!\n  guard_target = q \u2194 r\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : Prop\n\u22a2 p \u2227 q \u2194 p \u2227 r"}, {"line": "congr!", "tactic_state": "case a.h.e'_2.a\np q r : Prop\n\u22a2 q \u2194 r"}, {"line": "guard_target = q \u2194 r", "tactic_state": "case a.h.e'_2.a\np q r : Prop\n\u22a2 q \u2194 r"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (prime : Nat \u2192 Prop) (n : Nat) :\n    prime (2 * n + 1) = prime (n + n + 1) := by\n  congr!\n  \u00b7 guard_target =\u209b (HMul.hMul : Nat \u2192 Nat \u2192 Nat) = HAdd.hAdd\n    exact test_sorry\n  \u00b7 guard_target = 2 = n\n    exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "prime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 prime (2 * n + 1) = prime (n + n + 1)"}, {"line": "congr!", "tactic_state": "case h.e'_1.h.e'_5.h.e\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 HMul.hMul = HAdd.hAdd\n---\ncase h.e'_1.h.e'_5.h.e'_1\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 = n"}, {"line": "\u00b7 guard_target =\u209b (HMul.hMul : Nat \u2192 Nat \u2192 Nat) = HAdd.hAdd\n    exact test_sorry", "tactic_state": "case h.e'_1.h.e'_5.h.e'_1\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 = n"}, {"line": "\u00b7 guard_target = 2 = n\n    exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (prime : Nat \u2192 Prop) (n : Nat) :\n    prime (2 * n + 1) = prime (n + n + 1) := by\n  congr! (config := {etaExpand := true})\n  \u00b7 guard_target =\u209b (fun (x y : Nat) => x * y) = (fun (x y : Nat) => x + y)\n    exact test_sorry\n  \u00b7 guard_target = 2 = n\n    exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "prime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 prime (2 * n + 1) = prime (n + n + 1)"}, {"line": "congr! (config := {etaExpand := true})", "tactic_state": "case h.e'_1.h.e'_5.h.e\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 (fun a a_1 => a * a_1) = fun a a_1 => a + a_1\n---\ncase h.e'_1.h.e'_5.h.e'_1\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 = n"}, {"line": "\u00b7 guard_target =\u209b (fun (x y : Nat) => x * y) = (fun (x y : Nat) => x + y)\n    exact test_sorry", "tactic_state": "case h.e'_1.h.e'_5.h.e'_1\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 = n"}, {"line": "\u00b7 guard_target = 2 = n\n    exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (prime : Nat \u2192 Prop) (n : Nat) :\n    prime (2 * n + 1) = prime (n + n + 1) := by\n  congr! 2\n  guard_target = 2 * n = n + n\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "prime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 prime (2 * n + 1) = prime (n + n + 1)"}, {"line": "congr! 2", "tactic_state": "case h.e'_1.h.e'_5\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 * n = n + n"}, {"line": "guard_target = 2 * n = n + n", "tactic_state": "case h.e'_1.h.e'_5\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 * n = n + n"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (prime : Nat \u2192 Prop) (n : Nat) :\n    prime (2 * n + 1) = prime (n + n + 1) := by\n  congr! (config := .unfoldSameFun)\n  guard_target = 2 * n = n + n\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "prime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 prime (2 * n + 1) = prime (n + n + 1)"}, {"line": "congr! (config := .unfoldSameFun)", "tactic_state": "case h.e'_1.h.e'_5\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 * n = n + n"}, {"line": "guard_target = 2 * n = n + n", "tactic_state": "case h.e'_1.h.e'_5\nprime : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 2 * n = n + n"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (s t : MySet \u03b1) (f g : \u03b1 \u2192 \u03b2) (h1 : s = t) (h2 : f = g) :\n    MySet.image f s = MySet.image g t := by\n  congr!\n\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nMySet : x\u271d\n\u03b1 : Sort u_2\n\u03b2 : Sort u_3\ns : sorry\nt : sorry\nf g : \u03b1 \u2192 \u03b2\nh1 : s = t\nh2 : f = g\n\u22a2 sorry = sorry"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "example (c : Prop \u2192 Prop \u2192 Prop \u2192 Prop) (x x' y z z' : Prop)\n    (h\u2080 : x \u2194 x') (h\u2081 : z \u2194 z') : c x y z \u2194 c x' y z' := by\n  congr!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Prop \u2192 Prop \u2192 Prop \u2192 Prop\nx x' y z z' : Prop\nh\u2080 : x \u2194 x'\nh\u2081 : z \u2194 z'\n\u22a2 c x y z \u2194 c x' y z'"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1 \u03b2 \u03b3 \u03b4} {F : \u2200 {\u03b1 \u03b2}, (\u03b1 \u2192 \u03b2) \u2192 \u03b3 \u2192 \u03b4} {f g : \u03b1 \u2192 \u03b2} {s : \u03b3} (h : \u2200 (x : \u03b1), f x = g x) :\n    F f s = F g s := by\n  congr!\n  funext\n  apply h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\n\u03b4 : Sort u_4\nF : {\u03b1 : Sort u_1} \u2192 {\u03b2 : Sort u_2} \u2192 (\u03b1 \u2192 \u03b2) \u2192 \u03b3 \u2192 \u03b4\nf g : \u03b1 \u2192 \u03b2\ns : \u03b3\nh : \u2200 (x : \u03b1), f x = g x\n\u22a2 F f s = F g s"}, {"line": "congr!", "tactic_state": "case h.e'_3\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\n\u03b4 : Sort u_4\nF : {\u03b1 : Sort u_1} \u2192 {\u03b2 : Sort u_2} \u2192 (\u03b1 \u2192 \u03b2) \u2192 \u03b3 \u2192 \u03b4\nf g : \u03b1 \u2192 \u03b2\ns : \u03b3\nh : \u2200 (x : \u03b1), f x = g x\n\u22a2 f = g"}, {"line": "funext", "tactic_state": "case h.e'_3.h\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\n\u03b4 : Sort u_4\nF : {\u03b1 : Sort u_1} \u2192 {\u03b2 : Sort u_2} \u2192 (\u03b1 \u2192 \u03b2) \u2192 \u03b3 \u2192 \u03b4\nf g : \u03b1 \u2192 \u03b2\ns : \u03b3\nh : \u2200 (x : \u03b1), f x = g x\nx\u271d : \u03b1\n\u22a2 f x\u271d = g x\u271d"}, {"line": "apply h", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1 \u03b2} {f : _ \u2192 \u03b2} {x y : {x : {x : \u03b1 // x = x} // x = x}} (h : x.1 = y.1) :\n    f x = f y := by\n  congr! 1\n  ext1\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : { x // x = x } \u2192 \u03b2\nx y : { x // x = x }\nh : \u2191x = \u2191y\n\u22a2 f x = f y"}, {"line": "congr! 1", "tactic_state": "case h.e'_1\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : { x // x = x } \u2192 \u03b2\nx y : { x // x = x }\nh : \u2191x = \u2191y\n\u22a2 x = y"}, {"line": "ext1", "tactic_state": "case h.e'_1.a\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : { x // x = x } \u2192 \u03b2\nx y : { x // x = x }\nh : \u2191x = \u2191y\n\u22a2 \u2191x = \u2191y"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1 \u03b2} {F : _ \u2192 \u03b2} {f g : {f : \u03b1 \u2192 \u03b2 // f = f}}\n    (h : \u2200 x : \u03b1, (f : \u03b1 \u2192 \u03b2) x = (g : \u03b1 \u2192 \u03b2) x) :\n    F f = F g := by\n  congr!\n  ext x\n  apply h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nF : { f // f = f } \u2192 \u03b2\nf g : { f // f = f }\nh : \u2200 (x : \u03b1), \u2191f x = \u2191g x\n\u22a2 F f = F g"}, {"line": "congr!", "tactic_state": "case h.e'_1\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nF : { f // f = f } \u2192 \u03b2\nf g : { f // f = f }\nh : \u2200 (x : \u03b1), \u2191f x = \u2191g x\n\u22a2 f = g"}, {"line": "ext x", "tactic_state": "case h.e'_1.a.h\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nF : { f // f = f } \u2192 \u03b2\nf g : { f // f = f }\nh : \u2200 (x : \u03b1), \u2191f x = \u2191g x\nx : \u03b1\n\u22a2 \u2191f x = \u2191g x"}, {"line": "apply h", "tactic_state": "No Goals!"}]}
{"declaration": "example {ls : List \u2115} :\n    ls.map (fun x => (ls.map (fun y => 1 + y)).sum + 1) =\n      ls.map (fun x => (ls.map (fun y => Nat.succ y)).sum + 1) := by\n  congr! 6 with - y\n  guard_target = 1 + y = y.succ\n  rw [Nat.add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "ls : List \u2115\n\u22a2 List.map (fun x => (List.map (fun y => 1 + y) ls).sum + 1) ls =\n    List.map (fun x => (List.map (fun y => y.succ) ls).sum + 1) ls"}, {"line": "congr! 6 with - y", "tactic_state": "case h.e'_3.h.h.e'_5.h.e'_4.h.e'_3.h\nls : List \u2115\ny : \u2115\n\u22a2 1 + y = y.succ"}, {"line": "guard_target = 1 + y = y.succ", "tactic_state": "case h.e'_3.h.h.e'_5.h.e'_4.h.e'_3.h\nls : List \u2115\ny : \u2115\n\u22a2 1 + y = y.succ"}, {"line": "rw [Nat.add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "example {ls : List \u2115} {f g : \u2115 \u2192 \u2115} {h : \u2200 x, f x = g x} :\n    ls.map (fun x => f x + 3) = ls.map (fun x => g x + 3) := by\n  congr! 3 with x -- it's a little too powerful and will get to `f = g`\n  exact h x\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "ls : List \u2115\nf g : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = g x\n\u22a2 List.map (fun x => f x + 3) ls = List.map (fun x => g x + 3) ls"}, {"line": "congr! 3 with x -- it's a little too powerful and will get to `f = g`", "tactic_state": "case h.e'_3.h.h.e'_5\nls : List \u2115\nf g : \u2115 \u2192 \u2115\nh : \u2200 (x : \u2115), f x = g x\nx : \u2115\n\u22a2 f x = g x"}, {"line": "exact h x", "tactic_state": "No Goals!"}]}
{"declaration": "example : () = () := by congr!", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 () = ()"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "example : 0 = 0 := by congr!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 = 0"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1} (a : \u03b1) : a = a := by congr!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\na : \u03b1\n\u22a2 a = a"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1} (a b : \u03b1) (h : false) : a = b := by\n  fail_if_success { congr! }\n  cases h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\na b : \u03b1\nh : false = true\n\u22a2 a = b"}, {"line": "fail_if_success { congr! }", "tactic_state": "\u03b1 : Sort u_1\na b : \u03b1\nh : false = true\n\u22a2 a = b"}, {"line": "cases h", "tactic_state": "No Goals!"}]}
{"declaration": "example (Fintype : Type \u2192 Type)\n    (\u03b1 \u03b2 : Type) (inst : Fintype \u03b1) (inst' : Fintype \u03b2) : HEq inst inst' := by\n  congr!\n  guard_target = HEq inst inst'\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Fintype : Type \u2192 Type\n\u03b1 \u03b2 : Type\ninst : Fintype \u03b1\ninst' : Fintype \u03b2\n\u22a2 HEq inst inst'"}, {"line": "congr!", "tactic_state": "Fintype : Type \u2192 Type\n\u03b1 \u03b2 : Type\ninst : Fintype \u03b1\ninst' : Fintype \u03b2\n\u22a2 HEq inst inst'"}, {"line": "guard_target = HEq inst inst'", "tactic_state": "Fintype : Type \u2192 Type\n\u03b1 \u03b2 : Type\ninst : Fintype \u03b1\ninst' : Fintype \u03b2\n\u22a2 HEq inst inst'"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example : n = m \u2192 3 + n = m + 3 := by\n  congr! 0 with rfl\n  guard_target = 3 + n = n + 3\n  apply add_comm\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\n\u22a2 n = m \u2192 3 + n = m + 3"}, {"line": "congr! 0 with rfl", "tactic_state": "n : \u2115\n\u22a2 3 + n = n + 3"}, {"line": "guard_target = 3 + n = n + 3", "tactic_state": "n : \u2115\n\u22a2 3 + n = n + 3"}, {"line": "apply add_comm", "tactic_state": "No Goals!"}]}
{"declaration": "example (x y x' y' : Nat) (hx : x = x') (hy : y = y') : x + y = x' + y' := by\n  congr! (config := { closePre := false, closePost := false })\n  exact hx\n  exact hy\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y x' y' : \u2115\nhx : x = x'\nhy : y = y'\n\u22a2 x + y = x' + y'"}, {"line": "congr! (config := { closePre := false, closePost := false })", "tactic_state": "case h.e'_5\nx y x' y' : \u2115\nhx : x = x'\nhy : y = y'\n\u22a2 x = x'\n---\ncase h.e'_6\nx y x' y' : \u2115\nhx : x = x'\nhy : y = y'\n\u22a2 y = y'"}, {"line": "exact hx", "tactic_state": "case h.e'_6\nx y x' y' : \u2115\nhx : x = x'\nhy : y = y'\n\u22a2 y = y'"}, {"line": "exact hy", "tactic_state": "No Goals!"}]}
{"declaration": "example (x y x' : Nat) (hx : id x = id x') : x + y = x' + y := by\n  congr!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y x' : \u2115\nhx : id x = id x'\n\u22a2 x + y = x' + y"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "example (x y x' : Nat) (hx : id x = id x') : x + y = x' + y := by\n  congr! (config := { closePost := false })\n  exact hx\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y x' : \u2115\nhx : id x = id x'\n\u22a2 x + y = x' + y"}, {"line": "congr! (config := { closePost := false })", "tactic_state": "case h.e'_5\nx y x' : \u2115\nhx : id x = id x'\n\u22a2 x = x'"}, {"line": "exact hx", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : z = y) : (x = y \u2228 x = z) \u2192 x = y := by\n  congr! with (rfl|rfl)\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Sort u_1\nz y x : \u03b1\u271d\nh : z = y\n\u22a2 x = y \u2228 x = z \u2192 x = y"}, {"line": "congr! with (rfl|rfl)", "tactic_state": "No Goals!"}]}
{"declaration": "example (inst1 : BEq \u03b1) [LawfulBEq \u03b1] (inst2 : BEq \u03b1) [LawfulBEq \u03b1] (xs : List \u03b1) (x : \u03b1) :\n    @List.erase _ inst1 xs x = @List.erase _ inst2 xs x := by\n  congr!\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst1 : BEq \u03b1\ninst\u271d\u00b9 : LawfulBEq \u03b1\ninst2 : BEq \u03b1\ninst\u271d : LawfulBEq \u03b1\nxs : List \u03b1\nx : \u03b1\n\u22a2 xs.erase x = xs.erase x"}, {"line": "congr!", "tactic_state": "case h.e'_2\n\u03b1 : Type u_1\ninst1 : BEq \u03b1\ninst\u271d\u00b9 : LawfulBEq \u03b1\ninst2 : BEq \u03b1\ninst\u271d : LawfulBEq \u03b1\nxs : List \u03b1\nx : \u03b1\n\u22a2 inst1 = inst2"}]}
{"declaration": "example\n    {\u03b1 : Type} (inst1 : BEq \u03b1) [LawfulBEq \u03b1] (inst2 : BEq \u03b1) [LawfulBEq \u03b1] (xs : List \u03b1) (x : \u03b1) :\n    @List.erase _ inst1 xs x = @List.erase _ inst2 xs x := by\n  congr! (config := { beqEq := false })\n\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\ninst1 : BEq \u03b1\ninst\u271d\u00b9 : LawfulBEq \u03b1\ninst2 : BEq \u03b1\ninst\u271d : LawfulBEq \u03b1\nxs : List \u03b1\nx : \u03b1\n\u22a2 xs.erase x = xs.erase x"}, {"line": "congr! (config := { beqEq := false })", "tactic_state": "case h.e'_2\n\u03b1 : Type\ninst1 : BEq \u03b1\ninst\u271d\u00b9 : LawfulBEq \u03b1\ninst2 : BEq \u03b1\ninst\u271d : LawfulBEq \u03b1\nxs : List \u03b1\nx : \u03b1\n\u22a2 inst1 = inst2"}]}
{"declaration": "theorem bug (H : F) (hp : H.A = 0) (hp' : H.B = 0) :\n  H H.A hp = H H.B hp' := by with_reducible congr!", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Sort u_1\nH : F\nhp : sorry = 0\nhp' : sorry = 0\n\u22a2 sorry = sorry"}, {"line": "with_reducible congr!", "tactic_state": "No Goals!"}]}
{"declaration": "example {f : Type u \u2192 Type v} [Applicative f] [LawfulApplicative f]\n    {\u03b1 \u03b2 : Type u} (g : \u03b1 \u2192 \u03b2) : Functor.map g \u2218 (pure : \u03b1 \u2192 f \u03b1) = pure \u2218 g := by\n  apply map_comp_pure\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/HigherOrder.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : Type u \u2192 Type v\ninst\u271d\u00b9 : Applicative f\ninst\u271d : LawfulApplicative f\n\u03b1 \u03b2 : Type u\ng : \u03b1 \u2192 \u03b2\n\u22a2 Functor.map g \u2218 pure = pure \u2218 g"}, {"line": "apply map_comp_pure", "tactic_state": "No Goals!"}]}
{"declaration": "example : 0 \u2264 2 + 2 := by\n  fail_if_success infer_param\n  decide\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/InferParam.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 \u2264 2 + 2"}, {"line": "fail_if_success infer_param", "tactic_state": "\u22a2 0 \u2264 2 + 2"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b : \u03b1} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] : a / 2 \u2264 b / 2 := by\n  fail_if_success with_reducible_and_instances apply mul_le_mul -- fails, as desired\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/InstanceTransparency.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\n\u22a2 a / 2 \u2264 b / 2"}, {"line": "fail_if_success with_reducible_and_instances apply mul_le_mul -- fails, as desired", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\n\u22a2 a / 2 \u2264 b / 2"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b : \u211a} : a / 2 \u2264 b / 2 := by\n  fail_if_success with_reducible_and_instances apply mul_le_mul -- fails, as desired\n  apply mul_le_mul\n  repeat exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/InstanceTransparency.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211a\n\u22a2 a / 2 \u2264 b / 2"}, {"line": "fail_if_success with_reducible_and_instances apply mul_le_mul -- fails, as desired", "tactic_state": "a b : \u211a\n\u22a2 a / 2 \u2264 b / 2"}, {"line": "apply mul_le_mul", "tactic_state": "case h\u2081\na b : \u211a\n\u22a2 a \u2264 b\n---\ncase h\u2082\na b : \u211a\n\u22a2 Rat.inv 2 \u2264 Rat.inv 2\n---\ncase c0\na b : \u211a\n\u22a2 0 \u2264 Rat.inv 2\n---\ncase b0\na b : \u211a\n\u22a2 0 \u2264 b"}, {"line": "repeat exact test_sorry", "tactic_state": "case h\u2081\na b : \u211a\n\u22a2 a \u2264 b\n---\ncase h\u2082\na b : \u211a\n\u22a2 Rat.inv 2 \u2264 Rat.inv 2\n---\ncase c0\na b : \u211a\n\u22a2 0 \u2264 Rat.inv 2\n---\ncase b0\na b : \u211a\n\u22a2 0 \u2264 b"}]}
{"declaration": "example {a b : \u211d} : a / 2 \u2264 b / 2 := by\n  fail_if_success with_reducible_and_instances apply mul_le_mul -- fails, as desired\n  apply mul_le_mul\n  repeat exact test_sorry", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/InstanceTransparency.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u22a2 a / 2 \u2264 b / 2"}, {"line": "fail_if_success with_reducible_and_instances apply mul_le_mul -- fails, as desired", "tactic_state": "a b : \u211d\n\u22a2 a / 2 \u2264 b / 2"}, {"line": "apply mul_le_mul", "tactic_state": "case h\u2081\na b : \u211d\n\u22a2 a \u2264 b\n---\ncase h\u2082\na b : \u211d\n\u22a2 2\u207b\u00b9 \u2264 2\u207b\u00b9\n---\ncase c0\na b : \u211d\n\u22a2 0 \u2264 2\u207b\u00b9\n---\ncase b0\na b : \u211d\n\u22a2 0 \u2264 b"}, {"line": "repeat exact test_sorry", "tactic_state": "case h\u2081\na b : \u211d\n\u22a2 a \u2264 b\n---\ncase h\u2082\na b : \u211d\n\u22a2 2\u207b\u00b9 \u2264 2\u207b\u00b9\n---\ncase c0\na b : \u211d\n\u22a2 0 \u2264 2\u207b\u00b9\n---\ncase b0\na b : \u211d\n\u22a2 0 \u2264 b"}]}
{"declaration": "example : limsup u f \u2264 limsup v f := by exact limsup_le_limsup h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/IsBoundedDefault.lean", "context": {"open": ["Filter"], "variables": ["{\u03b1 : Type*} {f : Filter \u03b1} {u v : \u03b1 \u2192 EReal} (h : u \u2264\u1da0[f] v)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\nu v : \u03b1 \u2192 EReal\nh : u \u2264\u1da0[f] v\n\u22a2 limsup u f \u2264 limsup v f"}, {"line": "exact limsup_le_limsup h", "tactic_state": "No Goals!"}]}
{"declaration": "example : limsup u f \u2264 limsup v f := by apply limsup_le_limsup h", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/IsBoundedDefault.lean", "context": {"open": ["Filter"], "variables": ["{\u03b1 : Type*} {f : Filter \u03b1} {u v : \u03b1 \u2192 EReal} (h : u \u2264\u1da0[f] v)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\nu v : \u03b1 \u2192 EReal\nh : u \u2264\u1da0[f] v\n\u22a2 limsup u f \u2264 limsup v f"}, {"line": "apply limsup_le_limsup h", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2115 \u2192 \u2115 := by exact \u03bb n \u21a6 3 * n + 1\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LintStyle.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2115 \u2192 \u2115"}, {"line": "exact \u03bb n \u21a6 3 * n + 1", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 \u2115 := by\n  have (n : \u2115) : True := trivial\n  have : (Set.univ : Set \u2115) = \u22c3 (i : \u2115), (Set.iUnion \u03bb j \u21a6 ({0, j} : Set \u2115)) := sorry\n  have : \u2203 m : \u2115, \u22c3 i : \u2115, (Set.univ : Set \u2115) = \u2205 := sorry\n  exact \u03bb _a \u21a6 fun _b \u21a6 \u03bb _c \u21a6 0\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LintStyle.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 \u2115"}, {"line": "have (n : \u2115) : True := trivial", "tactic_state": "this : \u2115 \u2192 True\n\u22a2 \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 \u2115"}, {"line": "have : (Set.univ : Set \u2115) = \u22c3 (i : \u2115), (Set.iUnion \u03bb j \u21a6 ({0, j} : Set \u2115)) := sorry", "tactic_state": "this\u271d : \u2115 \u2192 True\nthis : Set.univ = \u22c3 i, \u22c3 j, {0, j}\n\u22a2 \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 \u2115"}, {"line": "have : \u2203 m : \u2115, \u22c3 i : \u2115, (Set.univ : Set \u2115) = \u2205 := sorry", "tactic_state": "this\u271d\u00b9 : \u2115 \u2192 True\nthis\u271d : Set.univ = \u22c3 i, \u22c3 j, {0, j}\nthis : \u2203 m, \u22c3 i, Set.univ = \u2205\n\u22a2 \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 \u2115"}, {"line": "exact \u03bb _a \u21a6 fun _b \u21a6 \u03bb _c \u21a6 0", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  have : 0 = 0 \u2227 0 = 0 \u2227 1 + 3 = 4 := by\n    refine \u27e8by trivial, by\n      let _f := \u03bb n : \u2115 \u21a6 0;\n      have : \u2115 := by\n        \u00b7 -- comment\n          \u00b7 have := \u03bb k : \u2115 \u21a6 -5\n            \u00b7 exact 0\n      refine \u27e8by trivial, have := \u03bb k : \u2115 \u21a6 -5; by simp\u27e9\n      \u27e9\n  trivial\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/LintStyle.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "have : 0 = 0 \u2227 0 = 0 \u2227 1 + 3 = 4 := by\n    refine \u27e8by trivial, by\n      let _f := \u03bb n : \u2115 \u21a6 0;\n      have : \u2115 := by\n        \u00b7 -- comment\n          \u00b7 have := \u03bb k : \u2115 \u21a6 -5\n            \u00b7 exact 0\n      refine \u27e8by trivial, have := \u03bb k : \u2115 \u21a6 -5; by simp\u27e9\n      \u27e9", "tactic_state": "this : 0 = 0 \u2227 0 = 0 \u2227 1 + 3 = 4\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (e : PartialEquiv \u03b1 \u03b2) (e' : PartialEquiv \u03b2 \u03b3) :\n  (e.trans e').source = e.source \u2229 Set.preimage e (e.target \u2229 e'.source) := by\n  mfld_set_tac\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MfldSetTac.lean", "context": {"open": ["Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : PartialEquiv \u03b1 \u03b2\ne' : PartialEquiv \u03b2 \u03b3\n\u22a2 (e.trans e').source = e.source \u2229 \u2191e \u207b\u00b9' (e.target \u2229 e'.source)"}, {"line": "mfld_set_tac", "tactic_state": "No Goals!"}]}
{"declaration": "example (e : PartialEquiv \u03b1 \u03b2) : (e.trans e.symm).source = e.source := by mfld_set_tac\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MfldSetTac.lean", "context": {"open": ["Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ne : PartialEquiv \u03b1 \u03b2\n\u22a2 (e.trans e.symm).source = e.source"}, {"line": "mfld_set_tac", "tactic_state": "No Goals!"}]}
{"declaration": "example (s : Set \u03b1) (f : PartialHomeomorph \u03b1 \u03b2) :\n  f.symm.toPartialEquiv.source \u2229 (f.toPartialEquiv.target \u2229 Set.preimage f.symm s)\n  = f.symm.toPartialEquiv.source \u2229 Set.preimage f.symm s := by mfld_set_tac\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MfldSetTac.lean", "context": {"open": ["Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf : sorry\n\u22a2 sorry \u2229 (sorry \u2229 sorry \u207b\u00b9' s) = sorry \u2229 sorry \u207b\u00b9' s"}, {"line": "mfld_set_tac", "tactic_state": "No Goals!"}]}
{"declaration": "example\n  {I : ModelWithCorners \ud835\udd5c E H}\n  {I' : ModelWithCorners \ud835\udd5c E' H'}\n  {I'' : ModelWithCorners \ud835\udd5c E'' H''}\n  (e\u2081 : PartialHomeomorph M H)\n  (e\u2082 : PartialHomeomorph M' H')\n  (e\u2083 : PartialHomeomorph M'' H'')\n  {f : M \u2192 M'}\n  {g : M' \u2192 M''} :\n  (Set.preimage (f \u2218 ((e\u2081.toPartialEquiv.trans I.toPartialEquiv).symm))\n      (e\u2082.toPartialEquiv.trans I'.toPartialEquiv).source) \u2286\n    {y : E |\n    ((e\u2083.toPartialEquiv.trans I''.toPartialEquiv) \u2218\n          (g \u2218 f) \u2218 ((e\u2081.toPartialEquiv.trans I.toPartialEquiv).symm)) y\n    = (((e\u2083.toPartialEquiv.trans I''.toPartialEquiv : M'' \u2192 E'') \u2218\n             g \u2218 ((e\u2082.toPartialEquiv.trans I'.toPartialEquiv).symm)) \u2218\n          (e\u2082.toPartialEquiv.trans I'.toPartialEquiv : M' \u2192 E') \u2218\n            f \u2218 ((e\u2081.toPartialEquiv.trans I.toPartialEquiv).symm)) y} := by\n  mfld_set_tac\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MfldSetTac.lean", "context": {"open": ["Lean Meta Elab Tactic"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nH : Type u_3\nE' : Type u_4\nH' : Type u_5\nE'' : Type u_6\nH'' : Type u_7\nM : Type u_8\nM' : Type u_9\nM'' : Type u_10\nI : sorry\nI' : sorry\nI'' : sorry\ne\u2081 : sorry\ne\u2082 : sorry\ne\u2083 : sorry\nf : M \u2192 M'\ng : M' \u2192 M''\n\u22a2 f \u2218 sorry \u207b\u00b9' sorry \u2286 {y | (sorry \u2218 (g \u2218 f) \u2218 sorry) y = ((sorry \u2218 g \u2218 sorry) \u2218 sorry \u2218 f \u2218 sorry) y}"}, {"line": "mfld_set_tac", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nH : Type u_3\nE' : Type u_4\nH' : Type u_5\nE'' : Type u_6\nH'' : Type u_7\nM : Type u_8\nM' : Type u_9\nM'' : Type u_10\nI : sorry\nI' : sorry\nI'' : sorry\ne\u2081 : sorry\ne\u2082 : sorry\ne\u2083 : sorry\nf : M \u2192 M'\ng : M' \u2192 M''\nmy_y\u271d : E\nh_my_y\u271d : f (sorry my_y\u271d) \u2208 sorry\n\u22a2 sorry (g (f (sorry my_y\u271d))) = sorry (g (sorry (sorry (f (sorry my_y\u271d)))))"}]}
{"declaration": "example : bar.1 = 1 := by simp", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbar : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nbar : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "example {\u03b1} {b : Bool} {x} (h : (\u27e83, 5\u27e9 : MyProd _ _) = x) : (@test \u03b1).extra b = x := by\n  dsimp\n  rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nMyProd : x\u271d\u00b9\nx\u271d : Sort u_2\ntest : x\u271d\n\u03b1 : ?m.951\nb : Bool\nx : sorry\nh : sorry = x\n\u22a2 sorry = x"}, {"line": "dsimp", "tactic_state": "x\u271d\u00b9 : Sort u_1\nMyProd : x\u271d\u00b9\nx\u271d : Sort u_2\ntest : x\u271d\n\u03b1 : ?m.951\nb : Bool\nx : sorry\nh : sorry = x\n\u22a2 sorry () = x"}, {"line": "rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2115) : myNatEquiv.toFun (myNatEquiv.toFun <| myNatEquiv.invFun n) = n := by\n  { /-successIfFail { rfl },-/ simp only [myNatEquiv_toFun, myNatEquiv_invFun] }\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 sorry = n"}, {"line": "{ /-successIfFail { rfl },-/ simp only [myNatEquiv_toFun, myNatEquiv_invFun] }", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1 \u03b2} [Semigroup \u03b1] [Semigroup \u03b2] (x y : \u03b1 \u00d7 \u03b2) : (x * y).1 = x.1 * y.1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Semigroup \u03b1\ninst\u271d : Semigroup \u03b2\nx y : \u03b1 \u00d7 \u03b2\n\u22a2 (x * y).1 = x.1 * y.1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u2115) : x * - 0 \u2286 - x := by simp", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\n\u22a2 sorry \u2286 sorry"}, {"line": "simp", "tactic_state": "x : \u2115\n\u22a2 sorry () \u2286 sorry ()"}]}
{"declaration": "example (x : \u2115) : x * - 0 \u2286 - x := by simp", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\n\u22a2 sorry \u2286 sorry"}, {"line": "simp", "tactic_state": "x : \u2115\n\u22a2 sorry () \u2286 sorry ()"}]}
{"declaration": "example {M N} [One M] [One N] : (1 : M \u00d7 N) = \u27e81, 1\u27e9 := by simp", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2076 : Sort ?u.326\n\u03b2\u271d\u2076 : Sort ?u.329\n\u03b3\u271d\u2076 : Sort ?u.332\n\u03b1\u271d\u2075 : Sort ?u.335\n\u03b2\u271d\u2075 : Sort ?u.338\n\u03b3\u271d\u2075 : Sort ?u.341\n\u03b1\u271d\u2074 : Sort ?u.344\n\u03b2\u271d\u2074 : Sort ?u.347\n\u03b3\u271d\u2074 : Sort ?u.350\n\u03b1\u271d\u00b3 : Sort ?u.353\n\u03b2\u271d\u00b3 : Sort ?u.356\n\u03b3\u271d\u00b3 : Sort ?u.359\n\u03b1\u271d\u00b2 : Sort ?u.362\n\u03b2\u271d\u00b2 : Sort ?u.365\n\u03b3\u271d\u00b2 : Sort ?u.368\n\u03b1\u271d\u00b9 : Sort ?u.371\n\u03b2\u271d\u00b9 : Sort ?u.374\n\u03b3\u271d\u00b9 : Sort ?u.377\n\u03b1\u271d : Sort ?u.380\n\u03b2\u271d : Sort ?u.383\n\u03b3\u271d : Sort ?u.386\n\u03b1 : Sort ?u.389\n\u03b2 : Sort ?u.392\n\u03b3 : Sort ?u.395\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : One M\ninst\u271d : One N\n\u22a2 1 = (1, 1)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "example {M N} [Zero M] [Zero N] : (0 : M \u00d7 N) = \u27e80, 0\u27e9 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2076 : Sort ?u.326\n\u03b2\u271d\u2076 : Sort ?u.329\n\u03b3\u271d\u2076 : Sort ?u.332\n\u03b1\u271d\u2075 : Sort ?u.335\n\u03b2\u271d\u2075 : Sort ?u.338\n\u03b3\u271d\u2075 : Sort ?u.341\n\u03b1\u271d\u2074 : Sort ?u.344\n\u03b2\u271d\u2074 : Sort ?u.347\n\u03b3\u271d\u2074 : Sort ?u.350\n\u03b1\u271d\u00b3 : Sort ?u.353\n\u03b2\u271d\u00b3 : Sort ?u.356\n\u03b3\u271d\u00b3 : Sort ?u.359\n\u03b1\u271d\u00b2 : Sort ?u.362\n\u03b2\u271d\u00b2 : Sort ?u.365\n\u03b3\u271d\u00b2 : Sort ?u.368\n\u03b1\u271d\u00b9 : Sort ?u.371\n\u03b2\u271d\u00b9 : Sort ?u.374\n\u03b3\u271d\u00b9 : Sort ?u.377\n\u03b1\u271d : Sort ?u.380\n\u03b2\u271d : Sort ?u.383\n\u03b3\u271d : Sort ?u.386\n\u03b1 : Sort ?u.389\n\u03b2 : Sort ?u.392\n\u03b3 : Sort ?u.395\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : Zero M\ninst\u271d : Zero N\n\u22a2 0 = (0, 0)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1 : Type} (x : \u03b1) : (fffoo \u03b1).symm x = x := by dsimp\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Simps.lean", "context": {"open": ["Lean Meta Elab Term Command Simps"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}", "{\u03b1 \u03b2 \u03b3 : Sort _}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u2077 : Sort ?u.326\n\u03b2\u271d\u2076 : Sort ?u.329\n\u03b3\u271d\u2076 : Sort ?u.332\n\u03b1\u271d\u2076 : Sort ?u.335\n\u03b2\u271d\u2075 : Sort ?u.338\n\u03b3\u271d\u2075 : Sort ?u.341\n\u03b1\u271d\u2075 : Sort ?u.344\n\u03b2\u271d\u2074 : Sort ?u.347\n\u03b3\u271d\u2074 : Sort ?u.350\n\u03b1\u271d\u2074 : Sort ?u.353\n\u03b2\u271d\u00b3 : Sort ?u.356\n\u03b3\u271d\u00b3 : Sort ?u.359\n\u03b1\u271d\u00b3 : Sort ?u.362\n\u03b2\u271d\u00b2 : Sort ?u.365\n\u03b3\u271d\u00b2 : Sort ?u.368\n\u03b1\u271d\u00b2 : Sort ?u.371\n\u03b2\u271d\u00b9 : Sort ?u.374\n\u03b3\u271d\u00b9 : Sort ?u.377\n\u03b1\u271d\u00b9 : Sort ?u.380\n\u03b2\u271d : Sort ?u.383\n\u03b3\u271d : Sort ?u.386\n\u03b1\u271d : Sort ?u.389\n\u03b2 : Sort ?u.392\n\u03b3 : Sort ?u.395\nx\u271d : Sort u_1\nfffoo : x\u271d\n\u03b1 : Type\nx : \u03b1\n\u22a2 sorry = x"}, {"line": "dsimp", "tactic_state": "\u03b1\u271d\u2077 : Sort ?u.326\n\u03b2\u271d\u2076 : Sort ?u.329\n\u03b3\u271d\u2076 : Sort ?u.332\n\u03b1\u271d\u2076 : Sort ?u.335\n\u03b2\u271d\u2075 : Sort ?u.338\n\u03b3\u271d\u2075 : Sort ?u.341\n\u03b1\u271d\u2075 : Sort ?u.344\n\u03b2\u271d\u2074 : Sort ?u.347\n\u03b3\u271d\u2074 : Sort ?u.350\n\u03b1\u271d\u2074 : Sort ?u.353\n\u03b2\u271d\u00b3 : Sort ?u.356\n\u03b3\u271d\u00b3 : Sort ?u.359\n\u03b1\u271d\u00b3 : Sort ?u.362\n\u03b2\u271d\u00b2 : Sort ?u.365\n\u03b3\u271d\u00b2 : Sort ?u.368\n\u03b1\u271d\u00b2 : Sort ?u.371\n\u03b2\u271d\u00b9 : Sort ?u.374\n\u03b3\u271d\u00b9 : Sort ?u.377\n\u03b1\u271d\u00b9 : Sort ?u.380\n\u03b2\u271d : Sort ?u.383\n\u03b3\u271d : Sort ?u.386\n\u03b1\u271d : Sort ?u.389\n\u03b2 : Sort ?u.392\n\u03b3 : Sort ?u.395\nx\u271d : Sort u_1\nfffoo : x\u271d\n\u03b1 : Type\nx : \u03b1\n\u22a2 sorry () = x"}]}
{"declaration": "example {R S : MonCat} (i : R \u27f6 S) (r : R) (h : r = 1) : i r = 1 := by simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MonCat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R S : MonCat\ni : R \u27f6 S\nr : \u2191R\nh : r = 1\n\u22a2 (CategoryTheory.ConcreteCategory.hom i) r = 1"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "example {R S : CommMonCat} (i : R \u27f6 S) (r : R) (h : r = 1) : i r = 1 := by simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MonCat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R S : CommMonCat\ni : R \u27f6 S\nr : \u2191R\nh : r = 1\n\u22a2 (CategoryTheory.ConcreteCategory.hom i) r = 1"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "example (x y z k : \u2115)\n    (h : 3 \u2264 (4 : \u2115))\n    (h' : z \u2264 y) :\n    (k + 3 + x) - y \u2264 (k + 4 + x) - z := by\n  mono\n  -- norm_num\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Monotonicity.lean", "context": {"open": ["List Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z k : \u2115\nh : 3 \u2264 4\nh' : z \u2264 y\n\u22a2 k + 3 + x - y \u2264 k + 4 + x - z"}, {"line": "mono", "tactic_state": "No Goals!"}]}
{"declaration": "example (x y z k : \u2124)\n    (h : 3 \u2264 (4 : \u2124))\n    (h' : z \u2264 y) :\n    (k + 3 + x) - y \u2264 (k + 4 + x) - z := by\n  mono\n  -- norm_num\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Monotonicity.lean", "context": {"open": ["List Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z k : \u2124\nh : 3 \u2264 4\nh' : z \u2264 y\n\u22a2 k + 3 + x - y \u2264 k + 4 + x - z"}, {"line": "mono", "tactic_state": "No Goals!"}]}
{"declaration": "example (x y z a b : \u2115)\n    (h : a \u2264 (b : \u2115))\n    (h' : z \u2264 y) :\n    (1 + a + x) - y \u2264 (1 + b + x) - z := by\n  transitivity (1 + a + x - z)\n  \u00b7 mono\n  \u00b7 mono\n    -- mono\n    -- mono\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Monotonicity.lean", "context": {"open": ["List Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z a b : \u2115\nh : a \u2264 b\nh' : z \u2264 y\n\u22a2 1 + a + x - y \u2264 1 + b + x - z"}, {"line": "transitivity (1 + a + x - z)", "tactic_state": "x y z a b : \u2115\nh : a \u2264 b\nh' : z \u2264 y\n\u22a2 1 + a + x - y \u2264 1 + a + x - z\n---\nx y z a b : \u2115\nh : a \u2264 b\nh' : z \u2264 y\n\u22a2 1 + a + x - z \u2264 1 + b + x - z"}, {"line": "\u00b7 mono", "tactic_state": "x y z a b : \u2115\nh : a \u2264 b\nh' : z \u2264 y\n\u22a2 1 + a + x - z \u2264 1 + b + x - z"}, {"line": "\u00b7 mono", "tactic_state": "No Goals!"}]}
{"declaration": "example (x y z a b : \u2124)\n    (h : a \u2264 (b : \u2124))\n    (h' : z \u2264 y) :\n    (1 + a + x) - y \u2264 (1 + b + x) - z := by\n  apply @le_trans \u2124 _ _ (1 + a + x - z)\n  -- transitivity (1 + a + x - z)\n  \u00b7 mono\n  \u00b7 mono\n    -- mono\n    -- mono\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Monotonicity.lean", "context": {"open": ["List Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z a b : \u2124\nh : a \u2264 b\nh' : z \u2264 y\n\u22a2 1 + a + x - y \u2264 1 + b + x - z"}, {"line": "apply @le_trans \u2124 _ _ (1 + a + x - z)", "tactic_state": "case a\nx y z a b : \u2124\nh : a \u2264 b\nh' : z \u2264 y\n\u22a2 1 + a + x - y \u2264 1 + a + x - z\n---\ncase a\nx y z a b : \u2124\nh : a \u2264 b\nh' : z \u2264 y\n\u22a2 1 + a + x - z \u2264 1 + b + x - z"}, {"line": "\u00b7 mono", "tactic_state": "case a\nx y z a b : \u2124\nh : a \u2264 b\nh' : z \u2264 y\n\u22a2 1 + a + x - z \u2264 1 + b + x - z"}, {"line": "\u00b7 mono", "tactic_state": "No Goals!"}]}
{"declaration": "example {x y z : \u2115} : true := by\n  suffices _this : x + y \u2264 z + y by trivial\n  mono\n  guard_target = x \u2264 z\n  exact test_sorry\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/Monotonicity.lean", "context": {"open": ["List Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u2115\n\u22a2 true = true"}, {"line": "suffices _this : x + y \u2264 z + y by trivial", "tactic_state": "x y z : \u2115\n\u22a2 x + y \u2264 z + y"}, {"line": "mono", "tactic_state": "case h\u2081\nx y z : \u2115\n\u22a2 x \u2264 z"}, {"line": "guard_target = x \u2264 z", "tactic_state": "case h\u2081\nx y z : \u2115\n\u22a2 x \u2264 z"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : a + b + c = d) : b + (a + c) = d := by\n  move_add [\u2190 a]\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MoveAdd.lean", "context": {"open": [], "variables": ["{R : Type u}", "[AddCommSemigroup R] {a b c d e f g h : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : AddCommSemigroup R\na b c d e f g h\u271d : R\nh : a + b + c = d\n\u22a2 b + (a + c) = d"}, {"line": "move_add [\u2190 a]", "tactic_state": "R : Type u\ninst\u271d : AddCommSemigroup R\na b c d e f g h\u271d : R\nh : a + b + c = d\n\u22a2 a + b + c = d"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example : let k := c + (a + b); k = a + b + c := by\n  move_add [\u2190 a, c]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MoveAdd.lean", "context": {"open": [], "variables": ["{R : Type u}", "[AddCommSemigroup R] {a b c d e f g h : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : AddCommSemigroup R\na b c d e f g h : R\n\u22a2 let k := c + (a + b);\n  k = a + b + c"}, {"line": "move_add [\u2190 a, c]", "tactic_state": "R : Type u\ninst\u271d : AddCommSemigroup R\na b c d e f g h : R\n\u22a2 let k := a + b + c;\n  k = a + b + c"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : d + b + a = b + a \u2192 d + c + a = c + a) : a + d + b = b + a \u2192 d + c + a = a + c := by\n  move_add [a]\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MoveAdd.lean", "context": {"open": [], "variables": ["{R : Type u}", "[AddCommSemigroup R] {a b c d e f g h : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : AddCommSemigroup R\na b c d e f g h\u271d : R\nh : d + b + a = b + a \u2192 d + c + a = c + a\n\u22a2 a + d + b = b + a \u2192 d + c + a = a + c"}, {"line": "move_add [a]", "tactic_state": "R : Type u\ninst\u271d : AddCommSemigroup R\na b c d e f g h\u271d : R\nh : d + b + a = b + a \u2192 d + c + a = c + a\n\u22a2 d + b + a = b + a \u2192 d + c + a = c + a"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : a + c + b = a + d + b) : c + b + a = b + a + d := by\n  move_add [\u2190 a, b]  -- Goal before `exact h`: `a + c + b = a + d + b`\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MoveAdd.lean", "context": {"open": [], "variables": ["{R : Type u}", "[AddCommSemigroup R] {a b c d e f g h : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : AddCommSemigroup R\na b c d e f g h\u271d : R\nh : a + c + b = a + d + b\n\u22a2 c + b + a = b + a + d"}, {"line": "move_add [\u2190 a, b]  -- Goal before `exact h`: `a + c + b = a + d + b`", "tactic_state": "R : Type u\ninst\u271d : AddCommSemigroup R\na b c d e f g h\u271d : R\nh : a + c + b = a + d + b\n\u22a2 a + c + b = a + d + b"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example [Mul R] (h : a * c + c + b * c = a * d + d + b * d) :\n    c + b * c + a * c = a * d + d + b * d := by\n  -- the first input `_ * c` unifies with `b * c` and moves to the right\n  -- the second input `_ * c` unifies with `a * c` and moves to the left\n  move_add [_ * c, \u2190 _ * c] -- Goal before `exact h`: `a * c + c + b * c = a * d + d + b * d`\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MoveAdd.lean", "context": {"open": [], "variables": ["{R : Type u}", "[AddCommSemigroup R] {a b c d e f g h : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : AddCommSemigroup R\na b c d e f g h\u271d : R\ninst\u271d : Mul R\nh : a * c + c + b * c = a * d + d + b * d\n\u22a2 c + b * c + a * c = a * d + d + b * d"}, {"line": "move_add [_ * c, \u2190 _ * c] -- Goal before `exact h`: `a * c + c + b * c = a * d + d + b * d`", "tactic_state": "R : Type u\ninst\u271d\u00b9 : AddCommSemigroup R\na b c d e f g h\u271d : R\ninst\u271d : Mul R\nh : a * c + c + b * c = a * d + d + b * d\n\u22a2 a * c + c + b * c = a * d + d + b * d"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : \u2115) : a + max a b = max b a + a := by\n  move_oper Max.max [\u2190 a]\n  move_oper HAdd.hAdd [a]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MoveAdd.lean", "context": {"open": [], "variables": ["{R : Type u}", "[AddCommSemigroup R] {a b c d e f g h : R}", "[AddCommMonoidWithOne R] [Mul R] {f g h X r s t u : R} (C D E : R \u2192 R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : AddCommSemigroup R\na\u271d b\u271d c d e f\u271d g\u271d h\u271d : R\ninst\u271d\u00b9 : AddCommMonoidWithOne R\ninst\u271d : Mul R\nf g h X r s t u : R\nC D E : R \u2192 R\na b : \u2115\n\u22a2 a + max a b = max b a + a"}, {"line": "move_oper Max.max [\u2190 a]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : AddCommSemigroup R\na\u271d b\u271d c d e f\u271d g\u271d h\u271d : R\ninst\u271d\u00b9 : AddCommMonoidWithOne R\ninst\u271d : Mul R\nf g h X r s t u : R\nC D E : R \u2192 R\na b : \u2115\n\u22a2 a + max a b = max a b + a"}, {"line": "move_oper HAdd.hAdd [a]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : AddCommSemigroup R\na\u271d b\u271d c d e f\u271d g\u271d h\u271d : R\ninst\u271d\u00b9 : AddCommMonoidWithOne R\ninst\u271d : Mul R\nf g h X r s t u : R\nC D E : R \u2192 R\na b : \u2115\n\u22a2 max a b + a = max a b + a"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example {R : Type u} [CommSemigroup R] {a b : R} :\n    \u2200 x : R, \u2203 y : R, a * x * b * y = x * y * b * a := by\n  move_mul [a, b]\n  exact fun x \u21a6 \u27e8x, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MoveAdd.lean", "context": {"open": [], "variables": ["{R : Type u}", "[AddCommSemigroup R] {a b c d e f g h : R}", "[AddCommMonoidWithOne R] [Mul R] {f g h X r s t u : R} (C D E : R \u2192 R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u271d : Type u\ninst\u271d\u00b3 : AddCommSemigroup R\u271d\na\u271d b\u271d c d e f\u271d g\u271d h\u271d : R\u271d\ninst\u271d\u00b2 : AddCommMonoidWithOne R\u271d\ninst\u271d\u00b9 : Mul R\u271d\nf g h X r s t u : R\u271d\nC D E : R\u271d \u2192 R\u271d\nR : Type u\ninst\u271d : CommSemigroup R\na b : R\n\u22a2 \u2200 (x : R), \u2203 y, a * x * b * y = x * y * b * a"}, {"line": "move_mul [a, b]", "tactic_state": "R\u271d : Type u\ninst\u271d\u00b3 : AddCommSemigroup R\u271d\na\u271d b\u271d c d e f\u271d g\u271d h\u271d : R\u271d\ninst\u271d\u00b2 : AddCommMonoidWithOne R\u271d\ninst\u271d\u00b9 : Mul R\u271d\nf g h X r s t u : R\u271d\nC D E : R\u271d \u2192 R\u271d\nR : Type u\ninst\u271d : CommSemigroup R\na b : R\n\u22a2 \u2200 (x : R), \u2203 y, x * y * a * b = x * y * a * b"}, {"line": "exact fun x \u21a6 \u27e8x, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "example {R : Type u} [Add R] [CommSemigroup R] {a b c d e f g : R} :\n    a * (b * c * a) * ((d * e) * e) * f * g = (c * b * a) * (e * (e * d)) * g * f * a := by\n  move_mul [a, a, b, c, d, e, f]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MoveAdd.lean", "context": {"open": [], "variables": ["{R : Type u}", "[AddCommSemigroup R] {a b c d e f g h : R}", "[AddCommMonoidWithOne R] [Mul R] {f g h X r s t u : R} (C D E : R \u2192 R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u271d : Type u\ninst\u271d\u2074 : AddCommSemigroup R\u271d\na\u271d b\u271d c\u271d d\u271d e\u271d f\u271d\u00b9 g\u271d\u00b9 h\u271d : R\u271d\ninst\u271d\u00b3 : AddCommMonoidWithOne R\u271d\ninst\u271d\u00b2 : Mul R\u271d\nf\u271d g\u271d h X r s t u : R\u271d\nC D E : R\u271d \u2192 R\u271d\nR : Type u\ninst\u271d\u00b9 : Add R\ninst\u271d : CommSemigroup R\na b c d e f g : R\n\u22a2 a * (b * c * a) * (d * e * e) * f * g = c * b * a * (e * (e * d)) * g * f * a"}, {"line": "move_mul [a, a, b, c, d, e, f]", "tactic_state": "R\u271d : Type u\ninst\u271d\u2074 : AddCommSemigroup R\u271d\na\u271d b\u271d c\u271d d\u271d e\u271d f\u271d\u00b9 g\u271d\u00b9 h\u271d : R\u271d\ninst\u271d\u00b3 : AddCommMonoidWithOne R\u271d\ninst\u271d\u00b2 : Mul R\u271d\nf\u271d g\u271d h X r s t u : R\u271d\nC D E : R\u271d \u2192 R\u271d\nR : Type u\ninst\u271d\u00b9 : Add R\ninst\u271d : CommSemigroup R\na b c d e f g : R\n\u22a2 e * g * a * a * b * c * d * e * f = e * g * a * a * b * c * d * e * f"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b c : Prop) : a \u2227 b \u2227 c \u2194 b \u2227 c \u2227 a := by\n  move_oper And [a]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MoveAdd.lean", "context": {"open": [], "variables": ["{R : Type u}", "[AddCommSemigroup R] {a b c d e f g h : R}", "[AddCommMonoidWithOne R] [Mul R] {f g h X r s t u : R} (C D E : R \u2192 R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : AddCommSemigroup R\na\u271d b\u271d c\u271d d e f\u271d g\u271d h\u271d : R\ninst\u271d\u00b9 : AddCommMonoidWithOne R\ninst\u271d : Mul R\nf g h X r s t u : R\nC D E : R \u2192 R\na b c : Prop\n\u22a2 a \u2227 b \u2227 c \u2194 b \u2227 c \u2227 a"}, {"line": "move_oper And [a]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : AddCommSemigroup R\na\u271d b\u271d c\u271d d e f\u271d g\u271d h\u271d : R\ninst\u271d\u00b9 : AddCommMonoidWithOne R\ninst\u271d : Mul R\nf g h X r s t u : R\nC D E : R \u2192 R\na b c : Prop\n\u22a2 b \u2227 c \u2227 a \u2194 b \u2227 c \u2227 a"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b c : Prop) : a \u2228 b \u2228 c \u2194 b \u2228 c \u2228 a := by\n  move_oper Or [a]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MoveAdd.lean", "context": {"open": [], "variables": ["{R : Type u}", "[AddCommSemigroup R] {a b c d e f g h : R}", "[AddCommMonoidWithOne R] [Mul R] {f g h X r s t u : R} (C D E : R \u2192 R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : AddCommSemigroup R\na\u271d b\u271d c\u271d d e f\u271d g\u271d h\u271d : R\ninst\u271d\u00b9 : AddCommMonoidWithOne R\ninst\u271d : Mul R\nf g h X r s t u : R\nC D E : R \u2192 R\na b c : Prop\n\u22a2 a \u2228 b \u2228 c \u2194 b \u2228 c \u2228 a"}, {"line": "move_oper Or [a]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : AddCommSemigroup R\na\u271d b\u271d c\u271d d e f\u271d g\u271d h\u271d : R\ninst\u271d\u00b9 : AddCommMonoidWithOne R\ninst\u271d : Mul R\nf g h X r s t u : R\nC D E : R \u2192 R\na b c : Prop\n\u22a2 b \u2228 c \u2228 a \u2194 b \u2228 c \u2228 a"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example {R} [LinearOrder R] (a b c : R) : max (max a b) c = max (max b c) a := by\n  move_oper Max.max [a]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MoveAdd.lean", "context": {"open": [], "variables": ["{R : Type u}", "[AddCommSemigroup R] {a b c d e f g h : R}", "[AddCommMonoidWithOne R] [Mul R] {f g h X r s t u : R} (C D E : R \u2192 R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u271d : Type u\ninst\u271d\u00b3 : AddCommSemigroup R\u271d\na\u271d b\u271d c\u271d d e f\u271d g\u271d h\u271d : R\u271d\ninst\u271d\u00b2 : AddCommMonoidWithOne R\u271d\ninst\u271d\u00b9 : Mul R\u271d\nf g h X r s t u : R\u271d\nC D E : R\u271d \u2192 R\u271d\nR : Type u_1\ninst\u271d : LinearOrder R\na b c : R\n\u22a2 max (max a b) c = max (max b c) a"}, {"line": "move_oper Max.max [a]", "tactic_state": "R\u271d : Type u\ninst\u271d\u00b3 : AddCommSemigroup R\u271d\na\u271d b\u271d c\u271d d e f\u271d g\u271d h\u271d : R\u271d\ninst\u271d\u00b2 : AddCommMonoidWithOne R\u271d\ninst\u271d\u00b9 : Mul R\u271d\nf g h X r s t u : R\u271d\nC D E : R\u271d \u2192 R\u271d\nR : Type u_1\ninst\u271d : LinearOrder R\na b c : R\n\u22a2 max (max b c) a = max (max b c) a"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example {R} [LinearOrder R] (a b c : R) : min (min a b) c = min (min b c) a := by\n  move_oper Min.min [a]\n  rfl", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MoveAdd.lean", "context": {"open": [], "variables": ["{R : Type u}", "[AddCommSemigroup R] {a b c d e f g h : R}", "[AddCommMonoidWithOne R] [Mul R] {f g h X r s t u : R} (C D E : R \u2192 R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u271d : Type u\ninst\u271d\u00b3 : AddCommSemigroup R\u271d\na\u271d b\u271d c\u271d d e f\u271d g\u271d h\u271d : R\u271d\ninst\u271d\u00b2 : AddCommMonoidWithOne R\u271d\ninst\u271d\u00b9 : Mul R\u271d\nf g h X r s t u : R\u271d\nC D E : R\u271d \u2192 R\u271d\nR : Type u_1\ninst\u271d : LinearOrder R\na b c : R\n\u22a2 min (min a b) c = min (min b c) a"}, {"line": "move_oper Min.min [a]", "tactic_state": "R\u271d : Type u\ninst\u271d\u00b3 : AddCommSemigroup R\u271d\na\u271d b\u271d c\u271d d e f\u271d g\u271d h\u271d : R\u271d\ninst\u271d\u00b2 : AddCommMonoidWithOne R\u271d\ninst\u271d\u00b9 : Mul R\u271d\nf g h X r s t u : R\u271d\nC D E : R\u271d \u2192 R\u271d\nR : Type u_1\ninst\u271d : LinearOrder R\na b c : R\n\u22a2 min (min b c) a = min (min b c) a"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b c d e : Prop} (h : a \u2227 b \u2227 c \u2227 d \u2227 e) : a \u2227 c \u2227 e \u2227 b \u2227 d := by\n  move_oper And [a, b, c, d, e]\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MoveAdd.lean", "context": {"open": [], "variables": ["{R : Type u}", "[AddCommSemigroup R] {a b c d e f g h : R}", "[AddCommMonoidWithOne R] [Mul R] {f g h X r s t u : R} (C D E : R \u2192 R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : AddCommSemigroup R\na\u271d b\u271d c\u271d d\u271d e\u271d f\u271d g\u271d h\u271d\u00b9 : R\ninst\u271d\u00b9 : AddCommMonoidWithOne R\ninst\u271d : Mul R\nf g h\u271d X r s t u : R\nC D E : R \u2192 R\na b c d e : Prop\nh : a \u2227 b \u2227 c \u2227 d \u2227 e\n\u22a2 a \u2227 c \u2227 e \u2227 b \u2227 d"}, {"line": "move_oper And [a, b, c, d, e]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : AddCommSemigroup R\na\u271d b\u271d c\u271d d\u271d e\u271d f\u271d g\u271d h\u271d\u00b9 : R\ninst\u271d\u00b9 : AddCommMonoidWithOne R\ninst\u271d : Mul R\nf g h\u271d X r s t u : R\nC D E : R \u2192 R\na b c d e : Prop\nh : a \u2227 b \u2227 c \u2227 d \u2227 e\n\u22a2 a \u2227 b \u2227 c \u2227 d \u2227 e"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b c d e : Prop} (h : a \u2228 b \u2228 c \u2228 d \u2228 e) : a \u2228 c \u2228 e \u2228 b \u2228 d := by\n  move_oper Or [a, b, c, d, e]\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/MathlibTest/MoveAdd.lean", "context": {"open": [], "variables": ["{R : Type u}", "[AddCommSemigroup R] {a b c d e f g h : R}", "[AddCommMonoidWithOne R] [Mul R] {f g h X r s t u : R} (C D E : R \u2192 R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : AddCommSemigroup R\na\u271d b\u271d c\u271d d\u271d e\u271d f\u271d g\u271d h\u271d\u00b9 : R\ninst\u271d\u00b9 : AddCommMonoidWithOne R\ninst\u271d : Mul R\nf g h\u271d X r s t u : R\nC D E : R \u2192 R\na b c d e : Prop\nh : a \u2228 b \u2228 c \u2228 d \u2228 e\n\u22a2 a \u2228 c \u2228 e \u2228 b \u2228 d"}, {"line": "move_oper Or [a, b, c, d, e]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : AddCommSemigroup R\na\u271d b\u271d c\u271d d\u271d e\u271d f\u271d g\u271d h\u271d\u00b9 : R\ninst\u271d\u00b9 : AddCommMonoidWithOne R\ninst\u271d : Mul R\nf g h\u271d X r s t u : R\nC D E : R \u2192 R\na b c d e : Prop\nh : a \u2228 b \u2228 c \u2228 d \u2228 e\n\u22a2 a \u2228 b \u2228 c \u2228 d \u2228 e"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
