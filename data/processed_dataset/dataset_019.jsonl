{"declaration": "theorem iSup_eq_dif {p : Prop} [Decidable p] (a : p \u2192 \u03b1) :\n    \u2a06 h : p, a h = if h : p then a h else \u22a5 := by by_cases h : p <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[InfSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2075 : CompleteSemilatticeInf \u03b1\ninst\u271d\u2074 : CompleteLattice \u03b1\ninst\u271d\u00b3 : SupSet \u03b1\ninst\u271d\u00b2 : InfSet \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\np : Prop\ninst\u271d : Decidable p\na : p \u2192 \u03b1\n\u22a2 \u2a06 (h : p), a h = if h : p then a h else \u22a5"}, {"line": "by_cases h : p <;> simp [h]", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d\u2076 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2075 : CompleteSemilatticeInf \u03b1\ninst\u271d\u2074 : CompleteLattice \u03b1\ninst\u271d\u00b3 : SupSet \u03b1\ninst\u271d\u00b2 : InfSet \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\np : Prop\ninst\u271d : Decidable p\na : p \u2192 \u03b1\nh : p\n\u22a2 \u2a06 (x : True), a \u22ef = a \u22ef\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d\u2076 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2075 : CompleteSemilatticeInf \u03b1\ninst\u271d\u2074 : CompleteLattice \u03b1\ninst\u271d\u00b3 : SupSet \u03b1\ninst\u271d\u00b2 : InfSet \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\np : Prop\ninst\u271d : Decidable p\na : p \u2192 \u03b1\nh : \u00acp\n\u22a2 \u2a06 (x : False), a \u22ef = \u22a5"}]}
{"declaration": "lemma Equiv.biSup_comp {\u03b9 \u03b9' : Type*} {g : \u03b9' \u2192 \u03b1} (e : \u03b9 \u2243 \u03b9') (s : Set \u03b9') :\n    \u2a06 i \u2208 e.symm '' s, g (e i) = \u2a06 i \u2208 s, g i := by\n  simpa only [iSup_subtype'] using (image e.symm s).symm.iSup_comp (g := g \u2218 (\u2191))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[InfSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2074 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : SupSet \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ninst\u271d : CompleteLattice \u03b1\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ng : \u03b9' \u2192 \u03b1\ne : \u03b9 \u2243 \u03b9'\ns : Set \u03b9'\n\u22a2 \u2a06 i \u2208 \u21d1e.symm '' s, g (e i) = \u2a06 i \u2208 s, g i"}, {"line": "simpa only [iSup_subtype'] using (image e.symm s).symm.iSup_comp (g := g \u2218 (\u2191))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_biSup {p : \u03b9 \u2192 Prop} {f : \u2200 i, p i \u2192 \u03b1} {a : \u03b1} (h : \u2203 i, p i) :\n    (a \u2294 \u2a06 (i) (h : p i), f i h) = \u2a06 (i) (h : p i), a \u2294 f i h := by\n  simpa only [sup_comm] using @biSup_sup \u03b1 _ _ p _ _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[InfSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d\u2075 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2074 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : SupSet \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ninst\u271d : CompleteLattice \u03b1\np : \u03b9 \u2192 Prop\nf : (i : \u03b9) \u2192 p i \u2192 \u03b1\na : \u03b1\nh : \u2203 i, p i\n\u22a2 a \u2294 \u2a06 i, \u2a06 (h : p i), f i h = \u2a06 i, \u2a06 (h : p i), a \u2294 f i h"}, {"line": "simpa only [sup_comm] using @biSup_sup \u03b1 _ _ p _ _ h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_emptyset {f : \u03b2 \u2192 \u03b1} : \u2a06 x \u2208 (\u2205 : Set \u03b2), f x = \u22a5 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[InfSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2074 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : SupSet \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u2a06 x \u2208 \u2205, f x = \u22a5"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2074 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : SupSet \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u2a06 x, \u2a06 (_ : False), f x = \u22a5"}]}
{"declaration": "theorem iInf_emptyset {f : \u03b2 \u2192 \u03b1} : \u2a05 x \u2208 (\u2205 : Set \u03b2), f x = \u22a4 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[InfSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2074 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : SupSet \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u2a05 x \u2208 \u2205, f x = \u22a4"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2074 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : SupSet \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u2a05 x, \u2a05 (_ : False), f x = \u22a4"}]}
{"declaration": "theorem iSup_univ {f : \u03b2 \u2192 \u03b1} : \u2a06 x \u2208 (univ : Set \u03b2), f x = \u2a06 x, f x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[InfSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2074 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : SupSet \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u2a06 x \u2208 univ, f x = \u2a06 x, f x"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2074 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : SupSet \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u2a06 x, \u2a06 (_ : True), f x = \u2a06 x, f x"}]}
{"declaration": "theorem iInf_univ {f : \u03b2 \u2192 \u03b1} : \u2a05 x \u2208 (univ : Set \u03b2), f x = \u2a05 x, f x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[InfSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2074 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : SupSet \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u2a05 x \u2208 univ, f x = \u2a05 x, f x"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2074 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : SupSet \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u2a05 x, \u2a05 (_ : True), f x = \u2a05 x, f x"}]}
{"declaration": "theorem iSup_split (f : \u03b2 \u2192 \u03b1) (p : \u03b2 \u2192 Prop) :\n    \u2a06 i, f i = (\u2a06 (i) (_ : p i), f i) \u2294 \u2a06 (i) (_ : \u00acp i), f i := by\n  simpa [Classical.em] using @iSup_union _ _ _ f { i | p i } { i | \u00acp i }\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[InfSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2074 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : SupSet \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : \u03b2 \u2192 \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 \u2a06 i, f i = (\u2a06 i, \u2a06 (_ : p i), f i) \u2294 \u2a06 i, \u2a06 (_ : \u00acp i), f i"}, {"line": "simpa [Classical.em] using @iSup_union _ _ _ f { i | p i } { i | \u00acp i }", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_singleton {f : \u03b2 \u2192 \u03b1} {b : \u03b2} : \u2a06 x \u2208 (singleton b : Set \u03b2), f x = f b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[InfSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2074 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : SupSet \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\n\u22a2 \u2a06 x \u2208 {b}, f x = f b"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2074 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : SupSet \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\n\u22a2 \u2a06 x, \u2a06 (_ : x = b), f x = f b"}]}
{"declaration": "theorem iInf_singleton {f : \u03b2 \u2192 \u03b1} {b : \u03b2} : \u2a05 x \u2208 (singleton b : Set \u03b2), f x = f b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[InfSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2074 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : SupSet \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\n\u22a2 \u2a05 x \u2208 {b}, f x = f b"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2074 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : SupSet \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ninst\u271d : CompleteLattice \u03b1\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\n\u22a2 \u2a05 x, \u2a05 (_ : x = b), f x = f b"}]}
{"declaration": "theorem isGLB_biInf {s : Set \u03b2} {f : \u03b2 \u2192 \u03b1} : IsGLB (f '' s) (\u2a05 x \u2208 s, f x) := by\n  simpa only [range_comp,Subtype.range_coe,iInf_subtype'] using\n    @isGLB_iInf \u03b1 s _ (f \u2218 fun x => (x : \u03b2))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[InfSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{\u03b9 : Type*} [PartialOrder \u03b9] (f : \u03b9 \u2192 \u03b1) (i : \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2074 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : SupSet \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 IsGLB (f '' s) (\u2a05 x \u2208 s, f x)"}, {"line": "simpa only [range_comp,Subtype.range_coe,iInf_subtype'] using\n    @isGLB_iInf \u03b1 s _ (f \u2218 fun x => (x : \u03b2))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLUB_biSup {s : Set \u03b2} {f : \u03b2 \u2192 \u03b1} : IsLUB (f '' s) (\u2a06 x \u2208 s, f x) := by\n  simpa only [range_comp,Subtype.range_coe,iSup_subtype'] using\n    @isLUB_iSup \u03b1 s _ (f \u2218 fun x => (x : \u03b2))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[InfSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{\u03b9 : Type*} [PartialOrder \u03b9] (f : \u03b9 \u2192 \u03b1) (i : \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CompleteSemilatticeSup \u03b1\ninst\u271d\u2074 : CompleteSemilatticeInf \u03b1\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : SupSet \u03b1\ninst\u271d\u00b9 : InfSet \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 IsLUB (f '' s) (\u2a06 x \u2208 s, f x)"}, {"line": "simpa only [range_comp,Subtype.range_coe,iSup_subtype'] using\n    @isLUB_iSup \u03b1 s _ (f \u2218 fun x => (x : \u03b2))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem unary_relation_sSup_iff {\u03b1 : Type*} (s : Set (\u03b1 \u2192 Prop)) {a : \u03b1} :\n    sSup s a \u2194 \u2203 r : \u03b1 \u2192 Prop, r \u2208 s \u2227 r a := by\n  rw [sSup_apply]\n  simp [\u2190 eq_iff_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[InfSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{\u03b9 : Type*} [PartialOrder \u03b9] (f : \u03b9 \u2192 \u03b1) (i : \u03b9)", "[CompleteLinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_9\ns : Set (\u03b1 \u2192 Prop)\na : \u03b1\n\u22a2 sSup s a \u2194 \u2203 r \u2208 s, r a"}, {"line": "rw [sSup_apply]", "tactic_state": "\u03b1 : Type u_9\ns : Set (\u03b1 \u2192 Prop)\na : \u03b1\n\u22a2 \u2a06 f, \u2191f a \u2194 \u2203 r \u2208 s, r a"}, {"line": "simp [\u2190 eq_iff_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem unary_relation_sInf_iff {\u03b1 : Type*} (s : Set (\u03b1 \u2192 Prop)) {a : \u03b1} :\n    sInf s a \u2194 \u2200 r : \u03b1 \u2192 Prop, r \u2208 s \u2192 r a := by\n  rw [sInf_apply]\n  simp [\u2190 eq_iff_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[InfSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{\u03b9 : Type*} [PartialOrder \u03b9] (f : \u03b9 \u2192 \u03b1) (i : \u03b9)", "[CompleteLinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_9\ns : Set (\u03b1 \u2192 Prop)\na : \u03b1\n\u22a2 sInf s a \u2194 \u2200 r \u2208 s, r a"}, {"line": "rw [sInf_apply]", "tactic_state": "\u03b1 : Type u_9\ns : Set (\u03b1 \u2192 Prop)\na : \u03b1\n\u22a2 \u2a05 f, \u2191f a \u2194 \u2200 r \u2208 s, r a"}, {"line": "simp [\u2190 eq_iff_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem binary_relation_sSup_iff {\u03b1 \u03b2 : Type*} (s : Set (\u03b1 \u2192 \u03b2 \u2192 Prop)) {a : \u03b1} {b : \u03b2} :\n    sSup s a b \u2194 \u2203 r : \u03b1 \u2192 \u03b2 \u2192 Prop, r \u2208 s \u2227 r a b := by\n  rw [sSup_apply]\n  simp [\u2190 eq_iff_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[InfSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{\u03b9 : Type*} [PartialOrder \u03b9] (f : \u03b9 \u2192 \u03b1) (i : \u03b9)", "[CompleteLinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_9\n\u03b2 : Type u_10\ns : Set (\u03b1 \u2192 \u03b2 \u2192 Prop)\na : \u03b1\nb : \u03b2\n\u22a2 sSup s a b \u2194 \u2203 r \u2208 s, r a b"}, {"line": "rw [sSup_apply]", "tactic_state": "\u03b1 : Type u_9\n\u03b2 : Type u_10\ns : Set (\u03b1 \u2192 \u03b2 \u2192 Prop)\na : \u03b1\nb : \u03b2\n\u22a2 (\u2a06 f, \u2191f a) b \u2194 \u2203 r \u2208 s, r a b"}, {"line": "simp [\u2190 eq_iff_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem binary_relation_sInf_iff {\u03b1 \u03b2 : Type*} (s : Set (\u03b1 \u2192 \u03b2 \u2192 Prop)) {a : \u03b1} {b : \u03b2} :\n    sInf s a b \u2194 \u2200 r : \u03b1 \u2192 \u03b2 \u2192 Prop, r \u2208 s \u2192 r a b := by\n  rw [sInf_apply]\n  simp [\u2190 eq_iff_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {s t : Set \u03b1} {b : \u03b1}", "[SupSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[InfSet \u03b1] {f g : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{\u03b9 : Type*} [PartialOrder \u03b9] (f : \u03b9 \u2192 \u03b1) (i : \u03b9)", "[CompleteLinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_9\n\u03b2 : Type u_10\ns : Set (\u03b1 \u2192 \u03b2 \u2192 Prop)\na : \u03b1\nb : \u03b2\n\u22a2 sInf s a b \u2194 \u2200 r \u2208 s, r a b"}, {"line": "rw [sInf_apply]", "tactic_state": "\u03b1 : Type u_9\n\u03b2 : Type u_10\ns : Set (\u03b1 \u2192 \u03b2 \u2192 Prop)\na : \u03b1\nb : \u03b2\n\u22a2 (\u2a05 f, \u2191f a) b \u2194 \u2200 r \u2208 s, r a b"}, {"line": "simp [\u2190 eq_iff_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem maximal_iff_forall_insert (hP : \u2200 \u2983s t\u2984, P t \u2192 s \u2286 t \u2192 P s) :\n    Maximal P s \u2194 P s \u2227 \u2200 x \u2209 s, \u00ac P (insert x s) := by\n  simp only [Maximal]\n  simp only [and_congr_right_iff]\n  exact fun _ \u21a6 \u27e8fun h x hxs hx \u21a6 hxs <| h hx (subset_insert _ _) (mem_insert_self x s),\n    fun h t ht hst x hxt \u21a6 by_contra fun hxs \u21a6 h x hxs (hP ht (insert_subset hxt hst))\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Finset.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "{\u03b9' : Sort*} [CompleteLattice \u03b1]", "{\u03b9' : Sort*}", "[DecidableEq \u03b1] {P : Finset \u03b1 \u2192 Prop} {s : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : DecidableEq \u03b1\nP : Finset \u03b1 \u2192 Prop\ns : Finset \u03b1\nhP : \u2200 \u2983s t : Finset \u03b1\u2984, P t \u2192 s \u2286 t \u2192 P s\n\u22a2 Maximal P s \u2194 P s \u2227 \u2200 x \u2209 s, \u00acP (insert x s)"}, {"line": "simp only [Maximal]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : DecidableEq \u03b1\nP : Finset \u03b1 \u2192 Prop\ns : Finset \u03b1\nhP : \u2200 \u2983s t : Finset \u03b1\u2984, P t \u2192 s \u2286 t \u2192 P s\n\u22a2 (P s \u2227 \u2200 \u2983y : Finset \u03b1\u2984, P y \u2192 s \u2264 y \u2192 y \u2264 s) \u2194 P s \u2227 \u2200 x \u2209 s, \u00acP (insert x s)"}, {"line": "simp only [and_congr_right_iff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : DecidableEq \u03b1\nP : Finset \u03b1 \u2192 Prop\ns : Finset \u03b1\nhP : \u2200 \u2983s t : Finset \u03b1\u2984, P t \u2192 s \u2286 t \u2192 P s\n\u22a2 P s \u2192 ((\u2200 \u2983y : Finset \u03b1\u2984, P y \u2192 s \u2264 y \u2192 y \u2264 s) \u2194 \u2200 x \u2209 s, \u00acP (insert x s))"}, {"line": "exact fun _ \u21a6 \u27e8fun h x hxs hx \u21a6 hxs <| h hx (subset_insert _ _) (mem_insert_self x s),\n    fun h t ht hst x hxt \u21a6 by_contra fun hxs \u21a6 h x hxs (hP ht (insert_subset hxt hst))\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_singleton (a : \u03b1) (s : \u03b1 \u2192 \u03b2) : \u2a06 x \u2208 ({a} : Finset \u03b1), s x = s a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Finset.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "{\u03b9' : Sort*} [CompleteLattice \u03b1]", "{\u03b9' : Sort*}", "[DecidableEq \u03b1] {P : Finset \u03b1 \u2192 Prop} {s : Finset \u03b1}", "[CompleteLattice \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CompleteLattice \u03b2\na : \u03b1\ns : \u03b1 \u2192 \u03b2\n\u22a2 \u2a06 x \u2208 {a}, s x = s a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iInf_singleton (a : \u03b1) (s : \u03b1 \u2192 \u03b2) : \u2a05 x \u2208 ({a} : Finset \u03b1), s x = s a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Finset.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "{\u03b9' : Sort*} [CompleteLattice \u03b1]", "{\u03b9' : Sort*}", "[DecidableEq \u03b1] {P : Finset \u03b1 \u2192 Prop} {s : Finset \u03b1}", "[CompleteLattice \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CompleteLattice \u03b2\na : \u03b1\ns : \u03b1 \u2192 \u03b2\n\u22a2 \u2a05 x \u2208 {a}, s x = s a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_option_toFinset (o : Option \u03b1) (f : \u03b1 \u2192 \u03b2) : \u2a06 x \u2208 o.toFinset, f x = \u2a06 x \u2208 o, f x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Finset.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "{\u03b9' : Sort*} [CompleteLattice \u03b1]", "{\u03b9' : Sort*}", "[DecidableEq \u03b1] {P : Finset \u03b1 \u2192 Prop} {s : Finset \u03b1}", "[CompleteLattice \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CompleteLattice \u03b2\no : Option \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2a06 x \u2208 o.toFinset, f x = \u2a06 x \u2208 o, f x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_union {f : \u03b1 \u2192 \u03b2} {s t : Finset \u03b1} :\n    \u2a06 x \u2208 s \u222a t, f x = (\u2a06 x \u2208 s, f x) \u2294 \u2a06 x \u2208 t, f x := by simp [iSup_or, iSup_sup_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Finset.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "{\u03b9' : Sort*} [CompleteLattice \u03b1]", "{\u03b9' : Sort*}", "[DecidableEq \u03b1] {P : Finset \u03b1 \u2192 Prop} {s : Finset \u03b1}", "[CompleteLattice \u03b2]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ns t : Finset \u03b1\n\u22a2 \u2a06 x \u2208 s \u222a t, f x = (\u2a06 x \u2208 s, f x) \u2294 \u2a06 x \u2208 t, f x"}, {"line": "simp [iSup_or, iSup_sup_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_biUnion (s : Finset \u03b3) (t : \u03b3 \u2192 Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    \u2a06 y \u2208 s.biUnion t, f y = \u2a06 (x \u2208 s) (y \u2208 t x), f y := by simp [@iSup_comm _ \u03b1, iSup_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Finset.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "{\u03b9' : Sort*} [CompleteLattice \u03b1]", "{\u03b9' : Sort*}", "[DecidableEq \u03b1] {P : Finset \u03b1 \u2192 Prop} {s : Finset \u03b1}", "[CompleteLattice \u03b2]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b2\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b3\nt : \u03b3 \u2192 Finset \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2a06 y \u2208 s.biUnion t, f y = \u2a06 x \u2208 s, \u2a06 y \u2208 t x, f y"}, {"line": "simp [@iSup_comm _ \u03b1, iSup_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_bool_eq {f : Bool \u2192 \u03b1} : \u2a06 b : Bool, f b = f true \u2294 f false := by\n  rw [iSup]\n  rw [Bool.range_eq]\n  rw [sSup_pair]\n  rw [sup_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Lemmas.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nf : Bool \u2192 \u03b1\n\u22a2 \u2a06 b, f b = f true \u2294 f false"}, {"line": "rw [iSup]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nf : Bool \u2192 \u03b1\n\u22a2 sSup (range fun b => f b) = f true \u2294 f false"}, {"line": "rw [Bool.range_eq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nf : Bool \u2192 \u03b1\n\u22a2 sSup {f false, f true} = f true \u2294 f false"}, {"line": "rw [sSup_pair]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nf : Bool \u2192 \u03b1\n\u22a2 f false \u2294 f true = f true \u2294 f false"}, {"line": "rw [sup_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_eq_iSup (x y : \u03b1) : x \u2294 y = \u2a06 b : Bool, cond b x y := by\n  rw [iSup_bool_eq]\n  rw [Bool.cond_true]\n  rw [Bool.cond_false]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Lemmas.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nx y : \u03b1\n\u22a2 x \u2294 y = \u2a06 b, bif b then x else y"}, {"line": "rw [iSup_bool_eq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nx y : \u03b1\n\u22a2 x \u2294 y = (bif true then x else y) \u2294 bif false then x else y"}, {"line": "rw [Bool.cond_true]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nx y : \u03b1\n\u22a2 x \u2294 y = x \u2294 bif false then x else y"}, {"line": "rw [Bool.cond_false]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iInf_nat_gt_zero_eq (f : \u2115 \u2192 \u03b1) : \u2a05 i > 0, f i = \u2a05 i, f (i + 1) := by\n  rw [\u2190 iInf_range]\n  rw [Nat.range_succ]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Lemmas.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nf : \u2115 \u2192 \u03b1\n\u22a2 \u2a05 i, \u2a05 (_ : i > 0), f i = \u2a05 i, f (i + 1)"}, {"line": "rw [\u2190 iInf_range]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nf : \u2115 \u2192 \u03b1\n\u22a2 \u2a05 i, \u2a05 (_ : i > 0), f i = \u2a05 b \u2208 range fun i => i + 1, f b"}, {"line": "rw [Nat.range_succ]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nf : \u2115 \u2192 \u03b1\n\u22a2 \u2a05 i, \u2a05 (_ : i > 0), f i = \u2a05 b \u2208 {i | 0 < i}, f b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma disjoint_of_sSup_disjoint_of_le_of_le {a b : \u03b1} {c d : Set \u03b1} (hs : \u2200 e \u2208 c, e \u2264 a)\n    (ht : \u2200 e \u2208 d, e \u2264 b) (hd : Disjoint a b) (he : \u22a5 \u2209 c \u2228 \u22a5 \u2209 d) : Disjoint c d := by\n  rw [disjoint_iff_forall_ne]\n  intros x hx y hy\n  rw [Disjoint.ne_iff]\n  \u00b7 aesop\n  \u00b7 exact Disjoint.mono (hs x hx) (ht y hy) hd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Lemmas.lean", "context": {"open": ["Function OrderDual Set", "OrderDual"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteLattice \u03b1] {f g s : \u03b9 \u2192 \u03b1} {a b : \u03b1}", "[CompleteLattice \u03b1] {a : \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : CompleteLattice \u03b1\na b : \u03b1\nc d : Set \u03b1\nhs : \u2200 e \u2208 c, e \u2264 a\nht : \u2200 e \u2208 d, e \u2264 b\nhd : Disjoint a b\nhe : \u22a5 \u2209 c \u2228 \u22a5 \u2209 d\n\u22a2 Disjoint c d"}, {"line": "rw [disjoint_iff_forall_ne]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : CompleteLattice \u03b1\na b : \u03b1\nc d : Set \u03b1\nhs : \u2200 e \u2208 c, e \u2264 a\nht : \u2200 e \u2208 d, e \u2264 b\nhd : Disjoint a b\nhe : \u22a5 \u2209 c \u2228 \u22a5 \u2209 d\n\u22a2 \u2200 \u2983a : \u03b1\u2984, a \u2208 c \u2192 \u2200 \u2983b : \u03b1\u2984, b \u2208 d \u2192 a \u2260 b"}, {"line": "intros x hx y hy", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : CompleteLattice \u03b1\na b : \u03b1\nc d : Set \u03b1\nhs : \u2200 e \u2208 c, e \u2264 a\nht : \u2200 e \u2208 d, e \u2264 b\nhd : Disjoint a b\nhe : \u22a5 \u2209 c \u2228 \u22a5 \u2209 d\nx : \u03b1\nhx : x \u2208 c\ny : \u03b1\nhy : y \u2208 d\n\u22a2 x \u2260 y"}, {"line": "rw [Disjoint.ne_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : CompleteLattice \u03b1\na b : \u03b1\nc d : Set \u03b1\nhs : \u2200 e \u2208 c, e \u2264 a\nht : \u2200 e \u2208 d, e \u2264 b\nhd : Disjoint a b\nhe : \u22a5 \u2209 c \u2228 \u22a5 \u2209 d\nx : \u03b1\nhx : x \u2208 c\ny : \u03b1\nhy : y \u2208 d\n\u22a2 x \u2260 \u22a5 \u2228 y \u2260 \u22a5\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : CompleteLattice \u03b1\na b : \u03b1\nc d : Set \u03b1\nhs : \u2200 e \u2208 c, e \u2264 a\nht : \u2200 e \u2208 d, e \u2264 b\nhd : Disjoint a b\nhe : \u22a5 \u2209 c \u2228 \u22a5 \u2209 d\nx : \u03b1\nhx : x \u2208 c\ny : \u03b1\nhy : y \u2208 d\n\u22a2 Disjoint x y\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : CompleteLattice \u03b1\na b : \u03b1\nc d : Set \u03b1\nhs : \u2200 e \u2208 c, e \u2264 a\nht : \u2200 e \u2208 d, e \u2264 b\nhd : Disjoint a b\nhe : \u22a5 \u2209 c \u2228 \u22a5 \u2209 d\nx : \u03b1\nhx : x \u2208 c\ny : \u03b1\nhy : y \u2208 d\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : CompleteLattice \u03b1\na b : \u03b1\nc d : Set \u03b1\nhs : \u2200 e \u2208 c, e \u2264 a\nht : \u2200 e \u2208 d, e \u2264 b\nhd : Disjoint a b\nhe : \u22a5 \u2209 c \u2228 \u22a5 \u2209 d\nx : \u03b1\nhx : x \u2208 c\ny : \u03b1\nhy : y \u2208 d\n\u22a2 OrderBot \u03b1"}, {"line": "\u00b7 aesop", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : CompleteLattice \u03b1\na b : \u03b1\nc d : Set \u03b1\nhs : \u2200 e \u2208 c, e \u2264 a\nht : \u2200 e \u2208 d, e \u2264 b\nhd : Disjoint a b\nhe : \u22a5 \u2209 c \u2228 \u22a5 \u2209 d\nx : \u03b1\nhx : x \u2208 c\ny : \u03b1\nhy : y \u2208 d\n\u22a2 Disjoint x y\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : CompleteLattice \u03b1\na b : \u03b1\nc d : Set \u03b1\nhs : \u2200 e \u2208 c, e \u2264 a\nht : \u2200 e \u2208 d, e \u2264 b\nhd : Disjoint a b\nhe : \u22a5 \u2209 c \u2228 \u22a5 \u2209 d\nx : \u03b1\nhx : x \u2208 c\ny : \u03b1\nhy : y \u2208 d\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : CompleteLattice \u03b1\na b : \u03b1\nc d : Set \u03b1\nhs : \u2200 e \u2208 c, e \u2264 a\nht : \u2200 e \u2208 d, e \u2264 b\nhd : Disjoint a b\nhe : \u22a5 \u2209 c \u2228 \u22a5 \u2209 d\nx : \u03b1\nhx : x \u2208 c\ny : \u03b1\nhy : y \u2208 d\n\u22a2 OrderBot \u03b1"}, {"line": "\u00b7 exact Disjoint.mono (hs x hx) (ht y hy) hd", "tactic_state": "No Goals!"}]}
{"declaration": "lemma chainClosure_empty : ChainClosure r \u2205 := by\n  have : ChainClosure r (\u22c3\u2080\u2205) := ChainClosure.union fun a h => (not_mem_empty _ h).elim\n  simpa using this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Chain.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {c c\u2081 c\u2082 s t : Set \u03b1} {a b x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 ChainClosure r \u2205"}, {"line": "have : ChainClosure r (\u22c3\u2080\u2205) := ChainClosure.union fun a h => (not_mem_empty _ h).elim", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nthis : ChainClosure r (\u22c3\u2080 \u2205)\n\u22a2 ChainClosure r \u2205"}, {"line": "simpa using this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_iSup_iff {s : \u03b9 \u2192 \u03b1} : a \u2264 iSup s \u2194 \u2200 b, (\u2200 i, s i \u2264 b) \u2192 a \u2264 b := by\n  simp [iSup, le_sSup_iff, upperBounds]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Defs.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d : CompleteSemilatticeSup \u03b1\na : \u03b1\ns : \u03b9 \u2192 \u03b1\n\u22a2 a \u2264 iSup s \u2194 \u2200 (b : \u03b1), (\u2200 (i : \u03b9), s i \u2264 b) \u2192 a \u2264 b"}, {"line": "simp [iSup, le_sSup_iff, upperBounds]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iInf_le_iff {s : \u03b9 \u2192 \u03b1} : iInf s \u2264 a \u2194 \u2200 b, (\u2200 i, b \u2264 s i) \u2192 b \u2264 a := by\n  simp [iInf, sInf_le_iff, lowerBounds]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/Defs.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[CompleteSemilatticeSup \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[CompleteSemilatticeInf \u03b1] {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d\u00b9 : CompleteSemilatticeSup \u03b1\ninst\u271d : CompleteSemilatticeInf \u03b1\na : \u03b1\ns : \u03b9 \u2192 \u03b1\n\u22a2 iInf s \u2264 a \u2194 \u2200 (b : \u03b1), (\u2200 (i : \u03b9), b \u2264 s i) \u2192 b \u2264 a"}, {"line": "simp [iInf, sInf_le_iff, lowerBounds]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma setLike_mem_mk (U : Set X) (h : U \u2208 L) : x \u2208 (\u27e8U, h\u27e9 : L) \u2194 x \u2208 U := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/SetLike.lean", "context": {"open": [], "variables": ["{X : Type*} {L : Sublattice (Set X)}", "{S T : L} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nL : Sublattice (Set X)\nx : X\nU : Set X\nh : U \u2208 L\n\u22a2 sorry \u2194 x \u2208 U"}, {"line": "simp", "tactic_state": "X : Type u_1\nL : Sublattice (Set X)\nx : X\nU : Set X\nh : U \u2208 L\n\u22a2 sorry () \u2194 x \u2208 U"}]}
{"declaration": "lemma mem_mk (U : Set X) (h : U \u2208 L) : x \u2208 (\u27e8U, h\u27e9 : L) \u2194 x \u2208 U := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/CompleteLattice/SetLike.lean", "context": {"open": [], "variables": ["{X : Type*} {L : Sublattice (Set X)}", "{S T : L} {x : X}", "{X : Type*} {L : CompleteSublattice (Set X)}", "{S T : L} {\ud835\udcae : Set L} {I : Sort*} {f : I \u2192 L} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\nL : CompleteSublattice (Set X)\nx : X\nU : Set X\nh : U \u2208 L\n\u22a2 sorry \u2194 x \u2208 U"}, {"line": "simp", "tactic_state": "X : Type u_2\nL : CompleteSublattice (Set X)\nx : X\nU : Set X\nh : U \u2208 L\n\u22a2 sorry () \u2194 x \u2208 U"}]}
{"declaration": "theorem Set.Nonempty.csSup_mem (h : s.Nonempty) (hs : s.Finite) : sSup s \u2208 s := by\n  lift s to Finset \u03b1 using hs\n  exact Finset.Nonempty.csSup_mem h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ConditionallyCompleteLattice/Finset.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 \u03b2 \u03b3 : Type*}", "[ConditionallyCompleteLinearOrder \u03b1] {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\ns : Set \u03b1\nh : s.Nonempty\nhs : s.Finite\n\u22a2 sSup s \u2208 s"}, {"line": "lift s to Finset \u03b1 using hs", "tactic_state": "case intro\n\u03b1 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\ns : Finset \u03b1\nh : (\u2191s).Nonempty\n\u22a2 sSup \u2191s \u2208 \u2191s"}, {"line": "exact Finset.Nonempty.csSup_mem h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Set.Finite.ciSup_mem_image {s : Set \u03b9} (hs : s.Finite) (h : \u2203 x \u2208 s, sSup \u2205 \u2264 f x) :\n    \u2a06 i \u2208 s, f i \u2208 f '' s := by\n  lift s to Finset \u03b9 using hs\n  simp only [Finset.mem_coe] at h\n  simpa using Finset.ciSup_mem_image f h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ConditionallyCompleteLattice/Finset.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 \u03b2 \u03b3 : Type*}", "[ConditionallyCompleteLinearOrder \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "(f : \u03b9 \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\nf : \u03b9 \u2192 \u03b1\ns : Set \u03b9\nhs : s.Finite\nh : \u2203 x \u2208 s, sSup \u2205 \u2264 f x\n\u22a2 \u2a06 i \u2208 s, f i \u2208 f '' s"}, {"line": "lift s to Finset \u03b9 using hs", "tactic_state": "case intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\nf : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\nh : \u2203 x \u2208 \u2191s, sSup \u2205 \u2264 f x\n\u22a2 \u2a06 i \u2208 \u2191s, f i \u2208 f '' \u2191s"}, {"line": "simp only [Finset.mem_coe] at h", "tactic_state": "case intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\nf : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\nh : \u2203 x \u2208 s, sSup \u2205 \u2264 f x\n\u22a2 \u2a06 i \u2208 \u2191s, f i \u2208 f '' \u2191s"}, {"line": "simpa using Finset.ciSup_mem_image f h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Set.Finite.ciInf_mem_image {s : Set \u03b9} (hs : s.Finite) (h : \u2203 x \u2208 s, f x \u2264 sInf \u2205) :\n    \u2a05 i \u2208 s, f i \u2208 f '' s := by\n  lift s to Finset \u03b9 using hs\n  simp only [Finset.mem_coe] at h\n  simpa using Finset.ciInf_mem_image f h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ConditionallyCompleteLattice/Finset.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 \u03b2 \u03b3 : Type*}", "[ConditionallyCompleteLinearOrder \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "(f : \u03b9 \u2192 \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\nf : \u03b9 \u2192 \u03b1\ns : Set \u03b9\nhs : s.Finite\nh : \u2203 x \u2208 s, f x \u2264 sInf \u2205\n\u22a2 \u2a05 i \u2208 s, f i \u2208 f '' s"}, {"line": "lift s to Finset \u03b9 using hs", "tactic_state": "case intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\nf : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\nh : \u2203 x \u2208 \u2191s, f x \u2264 sInf \u2205\n\u22a2 \u2a05 i \u2208 \u2191s, f i \u2208 f '' \u2191s"}, {"line": "simp only [Finset.mem_coe] at h", "tactic_state": "case intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\nf : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\nh : \u2203 x \u2208 s, f x \u2264 sInf \u2205\n\u22a2 \u2a05 i \u2208 \u2191s, f i \u2208 f '' \u2191s"}, {"line": "simpa using Finset.ciInf_mem_image f h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inf'_univ_eq_ciInf (f : \u03b9 \u2192 \u03b1) : univ.inf' univ_nonempty f = \u2a05 i, f i := by\n  simp [inf'_eq_csInf_image, iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ConditionallyCompleteLattice/Finset.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 \u03b2 \u03b3 : Type*}", "[ConditionallyCompleteLinearOrder \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "(f : \u03b9 \u2192 \u03b1)", "[ConditionallyCompleteLattice \u03b1]", "[Fintype \u03b9] [Nonempty \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b3 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 sorry = \u2a05 i, f i"}, {"line": "simp [inf'_eq_csInf_image, iInf]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b3 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 sorry () = sInf (range fun i => f i)"}]}
{"declaration": "theorem isLUB_csSup' {s : Set \u03b1} (hs : BddAbove s) : IsLUB s (sSup s) := by\n  rcases eq_empty_or_nonempty s with (rfl | hne)\n  \u00b7 simp only [csSup_empty, isLUB_empty]\n  \u00b7 exact isLUB_csSup hne hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "Classical in", "Classical in", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1]", "[ConditionallyCompleteLattice \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[ConditionallyCompleteLinearOrder \u03b1] {f : \u03b9 \u2192 \u03b1} {s : Set \u03b1} {a b : \u03b1}", "[WellFoundedLT \u03b1]", "[ConditionallyCompleteLinearOrderBot \u03b1] {s : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : WellFoundedLT \u03b1\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b1\ns : Set \u03b1\nhs : BddAbove s\n\u22a2 IsLUB s (sSup s)"}, {"line": "rcases eq_empty_or_nonempty s with (rfl | hne)", "tactic_state": "case inl\n\u03b1 : Type u_1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : WellFoundedLT \u03b1\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b1\nhs : BddAbove \u2205\n\u22a2 IsLUB \u2205 (sSup \u2205)\n---\ncase inr\n\u03b1 : Type u_1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : WellFoundedLT \u03b1\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b1\ns : Set \u03b1\nhs : BddAbove s\nhne : s.Nonempty\n\u22a2 IsLUB s (sSup s)"}, {"line": "\u00b7 simp only [csSup_empty, isLUB_empty]", "tactic_state": "case inr\n\u03b1 : Type u_1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : WellFoundedLT \u03b1\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b1\ns : Set \u03b1\nhs : BddAbove s\nhne : s.Nonempty\n\u22a2 IsLUB s (sSup s)"}, {"line": "\u00b7 exact isLUB_csSup hne hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLUB_sSup (s : Set (WithTop \u03b1)) : IsLUB s (sSup s) := by\n  rcases s.eq_empty_or_nonempty with rfl | hs\n  \u00b7 simp [sSup]\n  \u00b7 exact isLUB_sSup' hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "Classical in", "Classical in", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1]", "[ConditionallyCompleteLattice \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[ConditionallyCompleteLinearOrder \u03b1] {f : \u03b9 \u2192 \u03b1} {s : Set \u03b1} {a b : \u03b1}", "[WellFoundedLT \u03b1]", "[ConditionallyCompleteLinearOrderBot \u03b1] {s : Set \u03b1} {a : \u03b1}", "[ConditionallyCompleteLinearOrderBot \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b3 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b2 : WellFoundedLT \u03b1\ninst\u271d\u00b9 inst\u271d : ConditionallyCompleteLinearOrderBot \u03b1\ns : Set (WithTop \u03b1)\n\u22a2 IsLUB s (sSup s)"}, {"line": "rcases s.eq_empty_or_nonempty with rfl | hs", "tactic_state": "case inl\n\u03b1 : Type u_1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b3 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b2 : WellFoundedLT \u03b1\ninst\u271d\u00b9 inst\u271d : ConditionallyCompleteLinearOrderBot \u03b1\n\u22a2 IsLUB \u2205 (sSup \u2205)\n---\ncase inr\n\u03b1 : Type u_1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b3 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b2 : WellFoundedLT \u03b1\ninst\u271d\u00b9 inst\u271d : ConditionallyCompleteLinearOrderBot \u03b1\ns : Set (WithTop \u03b1)\nhs : s.Nonempty\n\u22a2 IsLUB s (sSup s)"}, {"line": "\u00b7 simp [sSup]", "tactic_state": "case inr\n\u03b1 : Type u_1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b3 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b2 : WellFoundedLT \u03b1\ninst\u271d\u00b9 inst\u271d : ConditionallyCompleteLinearOrderBot \u03b1\ns : Set (WithTop \u03b1)\nhs : s.Nonempty\n\u22a2 IsLUB s (sSup s)"}, {"line": "\u00b7 exact isLUB_sSup' hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem csInf_image_le {s : Set \u03b1} {c : \u03b1} (hcs : c \u2208 s) (h_bdd : BddBelow s) :\n    sInf (f '' s) \u2264 f c := by\n  let f' : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48 := f\n  exact le_csSup_image (\u03b1 := \u03b1\u1d52\u1d48) (\u03b2 := \u03b2\u1d52\u1d48)\n    (show Monotone f' from fun x y hxy => h_mono hxy) hcs h_bdd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "Classical in", "Classical in", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1]", "[ConditionallyCompleteLattice \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[ConditionallyCompleteLinearOrder \u03b1] {f : \u03b9 \u2192 \u03b1} {s : Set \u03b1} {a b : \u03b1}", "[WellFoundedLT \u03b1]", "[ConditionallyCompleteLinearOrderBot \u03b1] {s : Set \u03b1} {a : \u03b1}", "[ConditionallyCompleteLinearOrderBot \u03b1]", "[Preorder \u03b1] [ConditionallyCompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2} (h_mono : Monotone f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u2075 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u2074 : WellFoundedLT \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : ConditionallyCompleteLinearOrderBot \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ConditionallyCompleteLattice \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nc : \u03b1\nhcs : c \u2208 s\nh_bdd : BddBelow s\n\u22a2 sInf (f '' s) \u2264 f c"}, {"line": "let f' : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48 := f", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u2075 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u2074 : WellFoundedLT \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : ConditionallyCompleteLinearOrderBot \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ConditionallyCompleteLattice \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nc : \u03b1\nhcs : c \u2208 s\nh_bdd : BddBelow s\nf' : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48 := f\n\u22a2 sInf (f '' s) \u2264 f c"}, {"line": "exact le_csSup_image (\u03b1 := \u03b1\u1d52\u1d48) (\u03b2 := \u03b2\u1d52\u1d48)\n    (show Monotone f' from fun x y hxy => h_mono hxy) hcs h_bdd", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_csInf_image {s : Set \u03b1} (hs : s.Nonempty) {B : \u03b1} (hB : B \u2208 lowerBounds s) :\n    f B \u2264 sInf (f '' s) := by\n  let f' : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48 := f\n  exact csSup_image_le (\u03b1 := \u03b1\u1d52\u1d48) (\u03b2 := \u03b2\u1d52\u1d48)\n    (show Monotone f' from fun x y hxy => h_mono hxy) hs hB\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "context": {"open": ["Function OrderDual Set", "Classical in", "Classical in", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1]", "[ConditionallyCompleteLattice \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[ConditionallyCompleteLinearOrder \u03b1] {f : \u03b9 \u2192 \u03b1} {s : Set \u03b1} {a b : \u03b1}", "[WellFoundedLT \u03b1]", "[ConditionallyCompleteLinearOrderBot \u03b1] {s : Set \u03b1} {a : \u03b1}", "[ConditionallyCompleteLinearOrderBot \u03b1]", "[Preorder \u03b1] [ConditionallyCompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2} (h_mono : Monotone f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u2075 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u2074 : WellFoundedLT \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : ConditionallyCompleteLinearOrderBot \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ConditionallyCompleteLattice \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s.Nonempty\nB : \u03b1\nhB : B \u2208 lowerBounds s\n\u22a2 f B \u2264 sInf (f '' s)"}, {"line": "let f' : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48 := f", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u2075 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u2074 : WellFoundedLT \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : ConditionallyCompleteLinearOrderBot \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ConditionallyCompleteLattice \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : s.Nonempty\nB : \u03b1\nhB : B \u2208 lowerBounds s\nf' : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48 := f\n\u22a2 f B \u2264 sInf (f '' s)"}, {"line": "exact csSup_image_le (\u03b1 := \u03b1\u1d52\u1d48) (\u03b2 := \u03b2\u1d52\u1d48)\n    (show Monotone f' from fun x y hxy => h_mono hxy) hs hB", "tactic_state": "No Goals!"}]}
{"declaration": "theorem WithTop.iInf_empty [IsEmpty \u03b9] [InfSet \u03b1] (f : \u03b9 \u2192 WithTop \u03b1) :\n    \u2a05 i, f i = \u22a4 := by rw [iInf, range_eq_empty, WithTop.sInf_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ConditionallyCompleteLattice/Indexed.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : IsEmpty \u03b9\ninst\u271d : InfSet \u03b1\nf : \u03b9 \u2192 WithTop \u03b1\n\u22a2 \u2a05 i, f i = \u22a4"}, {"line": "rw [iInf, range_eq_empty, WithTop.sInf_empty]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : IsEmpty \u03b9\ninst\u271d : InfSet \u03b1\nf : \u03b9 \u2192 WithTop \u03b1\n\u22a2 IsEmpty \u03b9"}]}
{"declaration": "theorem ciSup_mono {f g : \u03b9 \u2192 \u03b1} (B : BddAbove (range g)) (H : \u2200 x, f x \u2264 g x) :\n    iSup f \u2264 iSup g := by\n  cases isEmpty_or_nonempty \u03b9\n  \u00b7 rw [iSup_of_empty', iSup_of_empty']\n  \u00b7 exact ciSup_le fun x => le_ciSup_of_le B x (H x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ConditionallyCompleteLattice/Indexed.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1]", "[ConditionallyCompleteLattice \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\n\u22a2 iSup f \u2264 iSup g"}, {"line": "cases isEmpty_or_nonempty \u03b9", "tactic_state": "case inl\n\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u271d : IsEmpty \u03b9\n\u22a2 iSup f \u2264 iSup g\n---\ncase inr\n\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u271d : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g"}, {"line": "\u00b7 rw [iSup_of_empty', iSup_of_empty']", "tactic_state": "case inr\n\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf g : \u03b9 \u2192 \u03b1\nB : BddAbove (range g)\nH : \u2200 (x : \u03b9), f x \u2264 g x\nh\u271d : Nonempty \u03b9\n\u22a2 iSup f \u2264 iSup g"}, {"line": "\u00b7 exact ciSup_le fun x => le_ciSup_of_le B x (H x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ciSup_const [h\u03b9 : Nonempty \u03b9] {a : \u03b1} : \u2a06 _ : \u03b9, a = a := by\n  rw [iSup]\n  rw [range_const]\n  rw [csSup_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ConditionallyCompleteLattice/Indexed.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1]", "[ConditionallyCompleteLattice \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ConditionallyCompleteLattice \u03b1\nh\u03b9 : Nonempty \u03b9\na : \u03b1\n\u22a2 \u2a06 x, a = a"}, {"line": "rw [iSup]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ConditionallyCompleteLattice \u03b1\nh\u03b9 : Nonempty \u03b9\na : \u03b1\n\u22a2 sSup (range fun x => a) = a"}, {"line": "rw [range_const]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ConditionallyCompleteLattice \u03b1\nh\u03b9 : Nonempty \u03b9\na : \u03b1\n\u22a2 sSup {a} = a\n---\n\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ConditionallyCompleteLattice \u03b1\nh\u03b9 : Nonempty \u03b9\na : \u03b1\n\u22a2 Nonempty \u03b9"}, {"line": "rw [csSup_singleton]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ConditionallyCompleteLattice \u03b1\nh\u03b9 : Nonempty \u03b9\na : \u03b1\n\u22a2 Nonempty \u03b9"}]}
{"declaration": "lemma ciSup_neg {p : Prop} {f : p \u2192 \u03b1} (hp : \u00ac p) :\n    \u2a06 (h : p), f h = sSup (\u2205 : Set \u03b1) := by\n  rw [iSup]\n  congr\n  rwa [range_eq_empty_iff, isEmpty_Prop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ConditionallyCompleteLattice/Indexed.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1]", "[ConditionallyCompleteLattice \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ConditionallyCompleteLattice \u03b1\np : Prop\nf : p \u2192 \u03b1\nhp : \u00acp\n\u22a2 \u2a06 (h : p), f h = sSup \u2205"}, {"line": "rw [iSup]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ConditionallyCompleteLattice \u03b1\np : Prop\nf : p \u2192 \u03b1\nhp : \u00acp\n\u22a2 sSup (range fun h => f h) = sSup \u2205"}, {"line": "congr", "tactic_state": "case e_a\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ConditionallyCompleteLattice \u03b1\np : Prop\nf : p \u2192 \u03b1\nhp : \u00acp\n\u22a2 (range fun h => f h) = \u2205"}, {"line": "rwa [range_eq_empty_iff, isEmpty_Prop]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ciSup_eq_ite {p : Prop} [Decidable p] {f : p \u2192 \u03b1} :\n    (\u2a06 h : p, f h) = if h : p then f h else sSup (\u2205 : Set \u03b1) := by\n  by_cases H : p <;> simp [ciSup_neg, H]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ConditionallyCompleteLattice/Indexed.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1]", "[ConditionallyCompleteLattice \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLattice \u03b1\np : Prop\ninst\u271d : Decidable p\nf : p \u2192 \u03b1\n\u22a2 \u2a06 (h : p), f h = if h : p then f h else sSup \u2205"}, {"line": "by_cases H : p <;> simp [ciSup_neg, H]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_ciSup_iff' {s : \u03b9 \u2192 \u03b1} {a : \u03b1} (h : BddAbove (range s)) :\n    a \u2264 iSup s \u2194 \u2200 b, (\u2200 i, s i \u2264 b) \u2192 a \u2264 b := by simp [iSup, h, le_csSup_iff', upperBounds]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ConditionallyCompleteLattice/Indexed.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1]", "[ConditionallyCompleteLattice \u03b1] {a b : \u03b1}", "[ConditionallyCompleteLinearOrder \u03b1] {a b : \u03b1}", "[WellFoundedLT \u03b1]", "[ConditionallyCompleteLinearOrderBot \u03b1] {f : \u03b9 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : WellFoundedLT \u03b1\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b1\ns : \u03b9 \u2192 \u03b1\na : \u03b1\nh : BddAbove (range s)\n\u22a2 a \u2264 iSup s \u2194 \u2200 (b : \u03b1), (\u2200 (i : \u03b9), s i \u2264 b) \u2192 a \u2264 b"}, {"line": "simp [iSup, h, le_csSup_iff', upperBounds]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : WellFoundedLT \u03b1\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b1\ns : \u03b9 \u2192 \u03b1\na : \u03b1\nh : BddAbove (range s)\n\u22a2 a \u2264 sSup (range s) \u2194 \u2200 (b : \u03b1), (\u2200 (i : \u03b9), s i \u2264 b) \u2192 a \u2264 b"}]}
{"declaration": "lemma iInf_coe_eq_top : \u2a05 x, (f x : WithTop \u03b1) = \u22a4 \u2194 IsEmpty \u03b9 := by simp [isEmpty_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/ConditionallyCompleteLattice/Indexed.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "[Preorder \u03b1]", "[ConditionallyCompleteLattice \u03b1] {a b : \u03b1}", "[ConditionallyCompleteLinearOrder \u03b1] {a b : \u03b1}", "[WellFoundedLT \u03b1]", "[ConditionallyCompleteLinearOrderBot \u03b1] {f : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[ConditionallyCompleteLattice \u03b1] [ConditionallyCompleteLattice \u03b2] [Nonempty \u03b9] {l : \u03b1 \u2192 \u03b2}", "[ConditionallyCompleteLattice \u03b1] [ConditionallyCompleteLattice \u03b2] [Nonempty \u03b9]", "[ConditionallyCompleteLinearOrderBot \u03b1] [ConditionallyCompleteLinearOrderBot \u03b2]", "[ConditionallyCompleteLinearOrderBot \u03b1] {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u2078 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u2077 : WellFoundedLT \u03b1\ninst\u271d\u2076 : ConditionallyCompleteLinearOrderBot \u03b1\ninst\u271d\u2075 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u2074 : Nonempty \u03b9\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : Nonempty \u03b9\ninst\u271d\u00b9 inst\u271d : ConditionallyCompleteLinearOrderBot \u03b1\nf : \u03b9 \u2192 \u03b1\n\u22a2 \u2a05 x, \u2191(f x) = \u22a4 \u2194 IsEmpty \u03b9"}, {"line": "simp [isEmpty_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u2078 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u2077 : WellFoundedLT \u03b1\ninst\u271d\u2076 : ConditionallyCompleteLinearOrderBot \u03b1\ninst\u271d\u2075 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u2074 : Nonempty \u03b9\ninst\u271d\u00b3 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b2 : Nonempty \u03b9\ninst\u271d\u00b9 inst\u271d : ConditionallyCompleteLinearOrderBot \u03b1\nf : \u03b9 \u2192 \u03b1\n\u22a2 \u2a05 x, \u2191(f x) = \u22a4 \u2194 \u03b9 \u2192 False"}]}
{"declaration": "lemma lt_or_gt_of_ne (h : a \u2260 b) : a < b \u2228 a > b := by simpa [h] using lt_trichotomy a b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Defs/LinearOrder.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[LinearOrder \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh : a \u2260 b\n\u22a2 a < b \u2228 a > b"}, {"line": "simpa [h] using lt_trichotomy a b", "tactic_state": "No Goals!"}]}
{"declaration": "lemma compare_lt_iff_lt : compare a b = .lt \u2194 a < b := by\n  rw [LinearOrder.compare_eq_compareOfLessAndEq]\n  rw [compareOfLessAndEq]\n  split_ifs <;> simp only [*, lt_irrefl, reduceCtorEq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Defs/LinearOrder.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[LinearOrder \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 compare a b = Ordering.lt \u2194 a < b"}, {"line": "rw [LinearOrder.compare_eq_compareOfLessAndEq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 compareOfLessAndEq a b = Ordering.lt \u2194 a < b"}, {"line": "rw [compareOfLessAndEq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 (if a < b then Ordering.lt else if a = b then Ordering.eq else Ordering.gt) = Ordering.lt \u2194 a < b"}, {"line": "split_ifs <;> simp only [*, lt_irrefl, reduceCtorEq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma compare_gt_iff_gt : compare a b = .gt \u2194 a > b := by\n  rw [LinearOrder.compare_eq_compareOfLessAndEq]\n  rw [compareOfLessAndEq]\n  split_ifs <;> simp only [*, lt_irrefl, not_lt_of_gt, reduceCtorEq]\n  case _ h\u2081 h\u2082 =>\n    have h : b < a := lt_trichotomy a b |>.resolve_left h\u2081 |>.resolve_left h\u2082\n    rwa [true_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Defs/LinearOrder.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[LinearOrder \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 compare a b = Ordering.gt \u2194 a > b"}, {"line": "rw [LinearOrder.compare_eq_compareOfLessAndEq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 compareOfLessAndEq a b = Ordering.gt \u2194 a > b"}, {"line": "rw [compareOfLessAndEq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 (if a < b then Ordering.lt else if a = b then Ordering.eq else Ordering.gt) = Ordering.gt \u2194 a > b"}, {"line": "split_ifs <;> simp only [*, lt_irrefl, not_lt_of_gt, reduceCtorEq]", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh\u271d\u00b9 : \u00aca < b\nh\u271d : \u00aca = b\n\u22a2 True \u2194 a > b"}, {"line": "case _ h\u2081 h\u2082 =>\n    have h : b < a := lt_trichotomy a b |>.resolve_left h\u2081 |>.resolve_left h\u2082\n    rwa [true_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma compare_eq_iff_eq : compare a b = .eq \u2194 a = b := by\n  rw [LinearOrder.compare_eq_compareOfLessAndEq]\n  rw [compareOfLessAndEq]\n  split_ifs <;> try simp only [reduceCtorEq]\n  case _ h   => rw [false_iff]; exact ne_iff_lt_or_gt.2 <| .inl h\n  case _ _ h => rwa [true_iff]\n  case _ _ h => rwa [false_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Defs/LinearOrder.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[LinearOrder \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 compare a b = Ordering.eq \u2194 a = b"}, {"line": "rw [LinearOrder.compare_eq_compareOfLessAndEq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 compareOfLessAndEq a b = Ordering.eq \u2194 a = b"}, {"line": "rw [compareOfLessAndEq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 (if a < b then Ordering.lt else if a = b then Ordering.eq else Ordering.gt) = Ordering.eq \u2194 a = b"}, {"line": "split_ifs <;> try simp only [reduceCtorEq]", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh\u271d : a < b\n\u22a2 False \u2194 a = b\n---\ncase pos\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh\u271d\u00b9 : \u00aca < b\nh\u271d : a = b\n\u22a2 True \u2194 a = b\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh\u271d\u00b9 : \u00aca < b\nh\u271d : \u00aca = b\n\u22a2 False \u2194 a = b"}, {"line": "case _ h   => rw [false_iff]; exact ne_iff_lt_or_gt.2 <| .inl h", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh\u271d\u00b9 : \u00aca < b\nh\u271d : a = b\n\u22a2 True \u2194 a = b\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh\u271d\u00b9 : \u00aca < b\nh\u271d : \u00aca = b\n\u22a2 False \u2194 a = b"}, {"line": "case _ _ h => rwa [true_iff]", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh\u271d\u00b9 : \u00aca < b\nh\u271d : \u00aca = b\n\u22a2 False \u2194 a = b"}, {"line": "case _ _ h => rwa [false_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma compare_iff (a b : \u03b1) {o : Ordering} : compare a b = o \u2194 o.Compares a b := by\n  cases o <;> simp only [Ordering.Compares]\n  \u00b7 exact compare_lt_iff_lt\n  \u00b7 exact compare_eq_iff_eq\n  \u00b7 exact compare_gt_iff_gt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Defs/LinearOrder.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[LinearOrder \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\no : Ordering\n\u22a2 compare a b = o \u2194 o.Compares a b"}, {"line": "cases o <;> simp only [Ordering.Compares]", "tactic_state": "case lt\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 compare a b = Ordering.lt \u2194 a < b\n---\ncase eq\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 compare a b = Ordering.eq \u2194 a = b\n---\ncase gt\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 compare a b = Ordering.gt \u2194 a > b"}, {"line": "\u00b7 exact compare_lt_iff_lt", "tactic_state": "case eq\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 compare a b = Ordering.eq \u2194 a = b\n---\ncase gt\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 compare a b = Ordering.gt \u2194 a > b"}, {"line": "\u00b7 exact compare_eq_iff_eq", "tactic_state": "case gt\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 compare a b = Ordering.gt \u2194 a > b"}, {"line": "\u00b7 exact compare_gt_iff_gt", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_of_eq (hab : a = b) : a \u2264 b := by rw [hab]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Defs/PartialOrder.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na b : \u03b1\nhab : a = b\n\u22a2 a \u2264 b"}, {"line": "rw [hab]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na b : \u03b1\nhab : a = b\n\u22a2 b \u2264 b"}]}
{"declaration": "theorem _root_.Filter.cardinalInterFilter_aleph0 (l : Filter \u03b1) : CardinalInterFilter l \u2135\u2080 where\n  cardinal_sInter_mem := by\n    simp_all only [aleph_zero, lt_aleph0_iff_subtype_finite, setOf_mem_eq, sInter_mem,\n      implies_true, forall_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/CardinalInter.lean", "context": {"open": ["Set Filter Cardinal"], "variables": ["{\u03b9 : Type u} {\u03b1 \u03b2 : Type u} {c : Cardinal.{u}}", "{l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl : Filter \u03b1\n\u22a2 \u2200 (S : Set (Set \u03b1)), Cardinal.mk \u2191S < aleph0 \u2192 (\u2200 s \u2208 S, s \u2208 l) \u2192 \u22c2\u2080 S \u2208 l"}, {"line": "simp_all only [aleph_zero, lt_aleph0_iff_subtype_finite, setOf_mem_eq, sInter_mem,\n      implies_true, forall_const]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardinal_iInter_mem {s : \u03b9 \u2192 Set \u03b1} (hic : #\u03b9 < c) :\n    (\u22c2 i, s i) \u2208 l \u2194 \u2200 i, s i \u2208 l := by\n  rw [\u2190 sInter_range _]\n  apply (cardinal_sInter_mem (lt_of_le_of_lt Cardinal.mk_range_le hic)).trans\n  exact forall_mem_range\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/CardinalInter.lean", "context": {"open": ["Set Filter Cardinal"], "variables": ["{\u03b9 : Type u} {\u03b1 \u03b2 : Type u} {c : Cardinal.{u}}", "{l : Filter \u03b1}", "[CardinalInterFilter l c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 \u03b1 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\ns : \u03b9 \u2192 Set \u03b1\nhic : Cardinal.mk \u03b9 < c\n\u22a2 \u22c2 i, s i \u2208 l \u2194 \u2200 (i : \u03b9), s i \u2208 l"}, {"line": "rw [\u2190 sInter_range _]", "tactic_state": "\u03b9 \u03b1 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\ns : \u03b9 \u2192 Set \u03b1\nhic : Cardinal.mk \u03b9 < c\n\u22a2 \u22c2\u2080 range s \u2208 l \u2194 \u2200 (i : \u03b9), s i \u2208 l"}, {"line": "apply (cardinal_sInter_mem (lt_of_le_of_lt Cardinal.mk_range_le hic)).trans", "tactic_state": "\u03b9 \u03b1 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\ns : \u03b9 \u2192 Set \u03b1\nhic : Cardinal.mk \u03b9 < c\n\u22a2 (\u2200 s_1 \u2208 range s, s_1 \u2208 l) \u2194 \u2200 (i : \u03b9), s i \u2208 l\n---\n\u03b9 \u03b1 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\ns : \u03b9 \u2192 Set \u03b1\nhic : Cardinal.mk \u03b9 < c\n\u22a2 CardinalInterFilter l c"}, {"line": "exact forall_mem_range", "tactic_state": "\u03b9 \u03b1 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\ns : \u03b9 \u2192 Set \u03b1\nhic : Cardinal.mk \u03b9 < c\n\u22a2 CardinalInterFilter l c"}]}
{"declaration": "theorem eventually_cardinal_forall {p : \u03b1 \u2192 \u03b9 \u2192 Prop} (hic : #\u03b9 < c) :\n    (\u2200\u1da0 x in l, \u2200 i, p x i) \u2194 \u2200 i, \u2200\u1da0 x in l, p x i := by\n  simp only [Filter.Eventually]\n  simp only [setOf_forall]\n  exact cardinal_iInter_mem hic\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/CardinalInter.lean", "context": {"open": ["Set Filter Cardinal"], "variables": ["{\u03b9 : Type u} {\u03b1 \u03b2 : Type u} {c : Cardinal.{u}}", "{l : Filter \u03b1}", "[CardinalInterFilter l c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 \u03b1 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\np : \u03b1 \u2192 \u03b9 \u2192 Prop\nhic : Cardinal.mk \u03b9 < c\n\u22a2 (\u2200\u1da0 (x : \u03b1) in l, \u2200 (i : \u03b9), p x i) \u2194 \u2200 (i : \u03b9), \u2200\u1da0 (x : \u03b1) in l, p x i"}, {"line": "simp only [Filter.Eventually]", "tactic_state": "\u03b9 \u03b1 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\np : \u03b1 \u2192 \u03b9 \u2192 Prop\nhic : Cardinal.mk \u03b9 < c\n\u22a2 {x | \u2200 (i : \u03b9), p x i} \u2208 l \u2194 \u2200 (i : \u03b9), {x | p x i} \u2208 l"}, {"line": "simp only [setOf_forall]", "tactic_state": "\u03b9 \u03b1 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\np : \u03b1 \u2192 \u03b9 \u2192 Prop\nhic : Cardinal.mk \u03b9 < c\n\u22a2 \u22c2 i, {x | p x i} \u2208 l \u2194 \u2200 (i : \u03b9), {x | p x i} \u2208 l"}, {"line": "exact cardinal_iInter_mem hic", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_cardinal_ball {S : Set \u03b9} (hS : #S < c)\n    {p : \u03b1 \u2192 \u2200 i \u2208 S, Prop} :\n    (\u2200\u1da0 x in l, \u2200 i hi, p x i hi) \u2194 \u2200 i hi, \u2200\u1da0 x in l, p x i hi := by\n  simp only [Filter.Eventually]\n  simp only [setOf_forall]\n  exact cardinal_bInter_mem hS\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/CardinalInter.lean", "context": {"open": ["Set Filter Cardinal"], "variables": ["{\u03b9 : Type u} {\u03b1 \u03b2 : Type u} {c : Cardinal.{u}}", "{l : Filter \u03b1}", "[CardinalInterFilter l c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 \u03b1 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\nS : Set \u03b9\nhS : Cardinal.mk \u2191S < c\np : \u03b1 \u2192 (i : \u03b9) \u2192 i \u2208 S \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : \u03b1) in l, \u2200 (i : \u03b9) (hi : i \u2208 S), p x i hi) \u2194 \u2200 (i : \u03b9) (hi : i \u2208 S), \u2200\u1da0 (x : \u03b1) in l, p x i hi"}, {"line": "simp only [Filter.Eventually]", "tactic_state": "\u03b9 \u03b1 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\nS : Set \u03b9\nhS : Cardinal.mk \u2191S < c\np : \u03b1 \u2192 (i : \u03b9) \u2192 i \u2208 S \u2192 Prop\n\u22a2 {x | \u2200 (i : \u03b9) (hi : i \u2208 S), p x i hi} \u2208 l \u2194 \u2200 (i : \u03b9) (hi : i \u2208 S), {x | p x i hi} \u2208 l"}, {"line": "simp only [setOf_forall]", "tactic_state": "\u03b9 \u03b1 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\nS : Set \u03b9\nhS : Cardinal.mk \u2191S < c\np : \u03b1 \u2192 (i : \u03b9) \u2192 i \u2208 S \u2192 Prop\n\u22a2 \u22c2 i, \u22c2 (i_1 : i \u2208 S), {x | p x i i_1} \u2208 l \u2194 \u2200 (i : \u03b9) (hi : i \u2208 S), {x | p x i hi} \u2208 l"}, {"line": "exact cardinal_bInter_mem hS", "tactic_state": "No Goals!"}]}
{"declaration": "theorem EventuallyLE.cardinal_bUnion {S : Set \u03b9} (hS : #S < c)\n    {s t : \u2200 i \u2208 S, Set \u03b1} (h : \u2200 i hi, s i hi \u2264\u1da0[l] t i hi) :\n    \u22c3 i \u2208 S, s i \u2039_\u203a \u2264\u1da0[l] \u22c3 i \u2208 S, t i \u2039_\u203a := by\n  simp only [biUnion_eq_iUnion]\n  exact EventuallyLE.cardinal_iUnion hS fun i => h i i.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/CardinalInter.lean", "context": {"open": ["Set Filter Cardinal"], "variables": ["{\u03b9 : Type u} {\u03b1 \u03b2 : Type u} {c : Cardinal.{u}}", "{l : Filter \u03b1}", "[CardinalInterFilter l c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 \u03b1 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\nS : Set \u03b9\nhS : Cardinal.mk \u2191S < c\ns t : (i : \u03b9) \u2192 i \u2208 S \u2192 Set \u03b1\nh : \u2200 (i : \u03b9) (hi : i \u2208 S), s i hi \u2264\u1da0[l] t i hi\n\u22a2 \u22c3 i, \u22c3 (h : i \u2208 S), s i h \u2264\u1da0[l] \u22c3 i, \u22c3 (h : i \u2208 S), t i h"}, {"line": "simp only [biUnion_eq_iUnion]", "tactic_state": "\u03b9 \u03b1 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\nS : Set \u03b9\nhS : Cardinal.mk \u2191S < c\ns t : (i : \u03b9) \u2192 i \u2208 S \u2192 Set \u03b1\nh : \u2200 (i : \u03b9) (hi : i \u2208 S), s i hi \u2264\u1da0[l] t i hi\n\u22a2 \u22c3 x, s \u2191x \u22ef \u2264\u1da0[l] \u22c3 x, t \u2191x \u22ef"}, {"line": "exact EventuallyLE.cardinal_iUnion hS fun i => h i i.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem EventuallyLE.cardinal_bInter {S : Set \u03b9} (hS : #S < c)\n    {s t : \u2200 i \u2208 S, Set \u03b1} (h : \u2200 i hi, s i hi \u2264\u1da0[l] t i hi) :\n    \u22c2 i \u2208 S, s i \u2039_\u203a \u2264\u1da0[l] \u22c2 i \u2208 S, t i \u2039_\u203a := by\n  simp only [biInter_eq_iInter]\n  exact EventuallyLE.cardinal_iInter hS fun i => h i i.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/CardinalInter.lean", "context": {"open": ["Set Filter Cardinal"], "variables": ["{\u03b9 : Type u} {\u03b1 \u03b2 : Type u} {c : Cardinal.{u}}", "{l : Filter \u03b1}", "[CardinalInterFilter l c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 \u03b1 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\nS : Set \u03b9\nhS : Cardinal.mk \u2191S < c\ns t : (i : \u03b9) \u2192 i \u2208 S \u2192 Set \u03b1\nh : \u2200 (i : \u03b9) (hi : i \u2208 S), s i hi \u2264\u1da0[l] t i hi\n\u22a2 \u22c2 i, \u22c2 (h : i \u2208 S), s i h \u2264\u1da0[l] \u22c2 i, \u22c2 (h : i \u2208 S), t i h"}, {"line": "simp only [biInter_eq_iInter]", "tactic_state": "\u03b9 \u03b1 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\nS : Set \u03b9\nhS : Cardinal.mk \u2191S < c\ns t : (i : \u03b9) \u2192 i \u2208 S \u2192 Set \u03b1\nh : \u2200 (i : \u03b9) (hi : i \u2208 S), s i hi \u2264\u1da0[l] t i hi\n\u22a2 \u22c2 x, s \u2191x \u22ef \u2264\u1da0[l] \u22c2 x, t \u2191x \u22ef"}, {"line": "exact EventuallyLE.cardinal_iInter hS fun i => h i i.2", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cardinalInter_ofCardinalGenerate (hc : 2 < c) :\n    CardinalInterFilter (cardinalGenerate g hc) c := by\n  delta cardinalGenerate\n  apply cardinalInter_ofCardinalInter _ _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/CardinalInter.lean", "context": {"open": ["Set Filter Cardinal"], "variables": ["{\u03b9 : Type u} {\u03b1 \u03b2 : Type u} {c : Cardinal.{u}}", "{l : Filter \u03b1}", "[CardinalInterFilter l c]", "(g : Set (Set \u03b1))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nc : Cardinal.{u}\ng : Set (Set \u03b1)\nhc : 2 < c\n\u22a2 CardinalInterFilter (cardinalGenerate g hc) c"}, {"line": "delta cardinalGenerate", "tactic_state": "\u03b1 : Type u\nc : Cardinal.{u}\ng : Set (Set \u03b1)\nhc : 2 < c\n\u22a2 CardinalInterFilter (ofCardinalInter (CardinalGenerateSets g) hc \u22ef \u22ef) c"}, {"line": "apply cardinalInter_ofCardinalInter _ _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_cardinaleGenerate_iff {s : Set \u03b1} {hreg : c.IsRegular} :\n    s \u2208 cardinalGenerate g (IsRegular.nat_lt hreg 2) \u2194\n    \u2203 S : Set (Set \u03b1), S \u2286 g \u2227 (#S < c) \u2227 \u22c2\u2080 S \u2286 s := by\n  constructor <;> intro h\n  \u00b7 induction h with\n    | @basic s hs =>\n      refine \u27e8{s}, singleton_subset_iff.mpr hs, ?_\u27e9\n      simpa [subset_refl] using IsRegular.nat_lt hreg 1\n    | univ =>\n      exact \u27e8\u2205, \u27e8empty_subset g, mk_eq_zero (\u2205 : Set <| Set \u03b1) \u25b8 IsRegular.nat_lt hreg 0, by simp\u27e9\u27e9\n    | superset _ _ ih => exact Exists.imp (by tauto) ih\n    | @sInter S Sct _ ih =>\n      choose T Tg Tct hT using ih\n      refine \u27e8\u22c3 (s) (H : s \u2208 S), T s H, by simpa,\n        (Cardinal.card_biUnion_lt_iff_forall_of_isRegular hreg Sct).2 Tct, ?_\u27e9\n      apply subset_sInter\n      apply fun s H => subset_trans (sInter_subset_sInter (subset_iUnion\u2082 s H)) (hT s H)\n  rcases h with \u27e8S, Sg, Sct, hS\u27e9\n  have : CardinalInterFilter (cardinalGenerate g (IsRegular.nat_lt hreg 2)) c :=\n    cardinalInter_ofCardinalGenerate _ _\n  exact mem_of_superset ((cardinal_sInter_mem Sct).mpr\n    (fun s H => CardinalGenerateSets.basic (Sg H))) hS\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/CardinalInter.lean", "context": {"open": ["Set Filter Cardinal"], "variables": ["{\u03b9 : Type u} {\u03b1 \u03b2 : Type u} {c : Cardinal.{u}}", "{l : Filter \u03b1}", "[CardinalInterFilter l c]", "(g : Set (Set \u03b1))", "{g}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nc : Cardinal.{u}\ng : Set (Set \u03b1)\ns : Set \u03b1\nhreg : c.IsRegular\n\u22a2 s \u2208 cardinalGenerate g \u22ef \u2194 \u2203 S \u2286 g, Cardinal.mk \u2191S < c \u2227 \u22c2\u2080 S \u2286 s"}, {"line": "constructor <;> intro h", "tactic_state": "case mp\n\u03b1 : Type u\nc : Cardinal.{u}\ng : Set (Set \u03b1)\ns : Set \u03b1\nhreg : c.IsRegular\nh : s \u2208 cardinalGenerate g \u22ef\n\u22a2 \u2203 S \u2286 g, Cardinal.mk \u2191S < c \u2227 \u22c2\u2080 S \u2286 s\n---\ncase mpr\n\u03b1 : Type u\nc : Cardinal.{u}\ng : Set (Set \u03b1)\ns : Set \u03b1\nhreg : c.IsRegular\nh : \u2203 S \u2286 g, Cardinal.mk \u2191S < c \u2227 \u22c2\u2080 S \u2286 s\n\u22a2 s \u2208 cardinalGenerate g \u22ef"}, {"line": "\u00b7 induction h with\n    | @basic s hs =>\n      refine \u27e8{s}, singleton_subset_iff.mpr hs, ?_\u27e9\n      simpa [subset_refl] using IsRegular.nat_lt hreg 1\n    | univ =>\n      exact \u27e8\u2205, \u27e8empty_subset g, mk_eq_zero (\u2205 : Set <| Set \u03b1) \u25b8 IsRegular.nat_lt hreg 0, by simp\u27e9\u27e9\n    | superset _ _ ih => exact Exists.imp (by tauto) ih\n    | @sInter S Sct _ ih =>\n      choose T Tg Tct hT using ih\n      refine \u27e8\u22c3 (s) (H : s \u2208 S), T s H, by simpa,\n        (Cardinal.card_biUnion_lt_iff_forall_of_isRegular hreg Sct).2 Tct, ?_\u27e9\n      apply subset_sInter\n      apply fun s H => subset_trans (sInter_subset_sInter (subset_iUnion\u2082 s H)) (hT s H)", "tactic_state": "case mpr\n\u03b1 : Type u\nc : Cardinal.{u}\ng : Set (Set \u03b1)\ns : Set \u03b1\nhreg : c.IsRegular\nh : \u2203 S \u2286 g, Cardinal.mk \u2191S < c \u2227 \u22c2\u2080 S \u2286 s\n\u22a2 s \u2208 cardinalGenerate g \u22ef"}, {"line": "rcases h with \u27e8S, Sg, Sct, hS\u27e9", "tactic_state": "case mpr.intro.intro.intro\n\u03b1 : Type u\nc : Cardinal.{u}\ng : Set (Set \u03b1)\ns : Set \u03b1\nhreg : c.IsRegular\nS : Set (Set \u03b1)\nSg : S \u2286 g\nSct : Cardinal.mk \u2191S < c\nhS : \u22c2\u2080 S \u2286 s\n\u22a2 s \u2208 cardinalGenerate g \u22ef"}, {"line": "have : CardinalInterFilter (cardinalGenerate g (IsRegular.nat_lt hreg 2)) c :=\n    cardinalInter_ofCardinalGenerate _ _", "tactic_state": "case mpr.intro.intro.intro\n\u03b1 : Type u\nc : Cardinal.{u}\ng : Set (Set \u03b1)\ns : Set \u03b1\nhreg : c.IsRegular\nS : Set (Set \u03b1)\nSg : S \u2286 g\nSct : Cardinal.mk \u2191S < c\nhS : \u22c2\u2080 S \u2286 s\nthis : CardinalInterFilter (cardinalGenerate g \u22ef) c\n\u22a2 s \u2208 cardinalGenerate g \u22ef"}, {"line": "exact mem_of_superset ((cardinal_sInter_mem Sct).mpr\n    (fun s H => CardinalGenerateSets.basic (Sg H))) hS", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardinalGenerate_isGreatest (hc : 2 < c) :\n    IsGreatest { f : Filter \u03b1 | CardinalInterFilter f c \u2227 g \u2286 f.sets } (cardinalGenerate g hc) := by\n  refine \u27e8\u27e8cardinalInter_ofCardinalGenerate _ _, fun s => CardinalGenerateSets.basic\u27e9, ?_\u27e9\n  rintro f \u27e8fct, hf\u27e9\n  rwa [le_cardinalGenerate_iff_of_cardinalInterFilter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/CardinalInter.lean", "context": {"open": ["Set Filter Cardinal"], "variables": ["{\u03b9 : Type u} {\u03b1 \u03b2 : Type u} {c : Cardinal.{u}}", "{l : Filter \u03b1}", "[CardinalInterFilter l c]", "(g : Set (Set \u03b1))", "{g}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nc : Cardinal.{u}\ng : Set (Set \u03b1)\nhc : 2 < c\n\u22a2 IsGreatest {f | CardinalInterFilter f c \u2227 g \u2286 f.sets} (cardinalGenerate g hc)"}, {"line": "refine \u27e8\u27e8cardinalInter_ofCardinalGenerate _ _, fun s => CardinalGenerateSets.basic\u27e9, ?_\u27e9", "tactic_state": "\u03b1 : Type u\nc : Cardinal.{u}\ng : Set (Set \u03b1)\nhc : 2 < c\n\u22a2 cardinalGenerate g hc \u2208 upperBounds {f | CardinalInterFilter f c \u2227 g \u2286 f.sets}"}, {"line": "rintro f \u27e8fct, hf\u27e9", "tactic_state": "case intro\n\u03b1 : Type u\nc : Cardinal.{u}\ng : Set (Set \u03b1)\nhc : 2 < c\nf : Filter \u03b1\nfct : CardinalInterFilter f c\nhf : g \u2286 f.sets\n\u22a2 f \u2264 cardinalGenerate g hc"}, {"line": "rwa [le_cardinalGenerate_iff_of_cardinalInterFilter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasCountableSeparatingOn.of_subtype {\u03b1 : Type*} {p : Set \u03b1 \u2192 Prop} {t : Set \u03b1}\n    {q : Set t \u2192 Prop} [h : HasCountableSeparatingOn t q univ]\n    (hpq : \u2200 U, q U \u2192 \u2203 V, p V \u2227 (\u2191) \u207b\u00b9' V = U) : HasCountableSeparatingOn \u03b1 p t := by\n  rcases h.1 with \u27e8S, hSc, hSq, hS\u27e9\n  choose! V hpV hV using fun s hs \u21a6 hpq s (hSq s hs)\n  refine \u27e8\u27e8V '' S, hSc.image _, forall_mem_image.2 hpV, fun x hx y hy h \u21a6 ?_\u27e9\u27e9\n  refine congr_arg Subtype.val (hS \u27e8x, hx\u27e9 trivial \u27e8y, hy\u27e9 trivial fun U hU \u21a6 ?_)\n  rw [\u2190 hV U hU]\n  exact h _ (mem_image_of_mem _ hU)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/CountableSeparatingOn.lean", "context": {"open": ["Function Set Filter"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : Set \u03b1 \u2192 Prop\nt : Set \u03b1\nq : Set \u2191t \u2192 Prop\nh : HasCountableSeparatingOn (\u2191t) q univ\nhpq : \u2200 (U : Set \u2191t), q U \u2192 \u2203 V, p V \u2227 Subtype.val \u207b\u00b9' V = U\n\u22a2 HasCountableSeparatingOn \u03b1 p t"}, {"line": "rcases h.1 with \u27e8S, hSc, hSq, hS\u27e9", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\np : Set \u03b1 \u2192 Prop\nt : Set \u03b1\nq : Set \u2191t \u2192 Prop\nh : HasCountableSeparatingOn (\u2191t) q univ\nhpq : \u2200 (U : Set \u2191t), q U \u2192 \u2203 V, p V \u2227 Subtype.val \u207b\u00b9' V = U\nS : Set (Set \u2191t)\nhSc : S.Countable\nhSq : \u2200 s \u2208 S, q s\nhS : \u2200 x \u2208 univ, \u2200 y \u2208 univ, (\u2200 s \u2208 S, x \u2208 s \u2194 y \u2208 s) \u2192 x = y\n\u22a2 HasCountableSeparatingOn \u03b1 p t"}, {"line": "choose! V hpV hV using fun s hs \u21a6 hpq s (hSq s hs)", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\np : Set \u03b1 \u2192 Prop\nt : Set \u03b1\nq : Set \u2191t \u2192 Prop\nh : HasCountableSeparatingOn (\u2191t) q univ\nhpq : \u2200 (U : Set \u2191t), q U \u2192 \u2203 V, p V \u2227 Subtype.val \u207b\u00b9' V = U\nS : Set (Set \u2191t)\nhSc : S.Countable\nhSq : \u2200 s \u2208 S, q s\nhS : \u2200 x \u2208 univ, \u2200 y \u2208 univ, (\u2200 s \u2208 S, x \u2208 s \u2194 y \u2208 s) \u2192 x = y\nV : Set \u2191t \u2192 Set \u03b1\nhpV : \u2200 s \u2208 S, p (V s)\nhV : \u2200 s \u2208 S, Subtype.val \u207b\u00b9' V s = s\n\u22a2 HasCountableSeparatingOn \u03b1 p t"}, {"line": "refine \u27e8\u27e8V '' S, hSc.image _, forall_mem_image.2 hpV, fun x hx y hy h \u21a6 ?_\u27e9\u27e9", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\np : Set \u03b1 \u2192 Prop\nt : Set \u03b1\nq : Set \u2191t \u2192 Prop\nh\u271d : HasCountableSeparatingOn (\u2191t) q univ\nhpq : \u2200 (U : Set \u2191t), q U \u2192 \u2203 V, p V \u2227 Subtype.val \u207b\u00b9' V = U\nS : Set (Set \u2191t)\nhSc : S.Countable\nhSq : \u2200 s \u2208 S, q s\nhS : \u2200 x \u2208 univ, \u2200 y \u2208 univ, (\u2200 s \u2208 S, x \u2208 s \u2194 y \u2208 s) \u2192 x = y\nV : Set \u2191t \u2192 Set \u03b1\nhpV : \u2200 s \u2208 S, p (V s)\nhV : \u2200 s \u2208 S, Subtype.val \u207b\u00b9' V s = s\nx : \u03b1\nhx : x \u2208 t\ny : \u03b1\nhy : y \u2208 t\nh : \u2200 s \u2208 V '' S, x \u2208 s \u2194 y \u2208 s\n\u22a2 x = y"}, {"line": "refine congr_arg Subtype.val (hS \u27e8x, hx\u27e9 trivial \u27e8y, hy\u27e9 trivial fun U hU \u21a6 ?_)", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\np : Set \u03b1 \u2192 Prop\nt : Set \u03b1\nq : Set \u2191t \u2192 Prop\nh\u271d : HasCountableSeparatingOn (\u2191t) q univ\nhpq : \u2200 (U : Set \u2191t), q U \u2192 \u2203 V, p V \u2227 Subtype.val \u207b\u00b9' V = U\nS : Set (Set \u2191t)\nhSc : S.Countable\nhSq : \u2200 s \u2208 S, q s\nhS : \u2200 x \u2208 univ, \u2200 y \u2208 univ, (\u2200 s \u2208 S, x \u2208 s \u2194 y \u2208 s) \u2192 x = y\nV : Set \u2191t \u2192 Set \u03b1\nhpV : \u2200 s \u2208 S, p (V s)\nhV : \u2200 s \u2208 S, Subtype.val \u207b\u00b9' V s = s\nx : \u03b1\nhx : x \u2208 t\ny : \u03b1\nhy : y \u2208 t\nh : \u2200 s \u2208 V '' S, x \u2208 s \u2194 y \u2208 s\nU : Set \u2191t\nhU : U \u2208 S\n\u22a2 \u27e8x, hx\u27e9 \u2208 U \u2194 \u27e8y, hy\u27e9 \u2208 U"}, {"line": "rw [\u2190 hV U hU]", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\np : Set \u03b1 \u2192 Prop\nt : Set \u03b1\nq : Set \u2191t \u2192 Prop\nh\u271d : HasCountableSeparatingOn (\u2191t) q univ\nhpq : \u2200 (U : Set \u2191t), q U \u2192 \u2203 V, p V \u2227 Subtype.val \u207b\u00b9' V = U\nS : Set (Set \u2191t)\nhSc : S.Countable\nhSq : \u2200 s \u2208 S, q s\nhS : \u2200 x \u2208 univ, \u2200 y \u2208 univ, (\u2200 s \u2208 S, x \u2208 s \u2194 y \u2208 s) \u2192 x = y\nV : Set \u2191t \u2192 Set \u03b1\nhpV : \u2200 s \u2208 S, p (V s)\nhV : \u2200 s \u2208 S, Subtype.val \u207b\u00b9' V s = s\nx : \u03b1\nhx : x \u2208 t\ny : \u03b1\nhy : y \u2208 t\nh : \u2200 s \u2208 V '' S, x \u2208 s \u2194 y \u2208 s\nU : Set \u2191t\nhU : U \u2208 S\n\u22a2 \u27e8x, hx\u27e9 \u2208 Subtype.val \u207b\u00b9' V U \u2194 \u27e8y, hy\u27e9 \u2208 Subtype.val \u207b\u00b9' V U"}, {"line": "exact h _ (mem_image_of_mem _ hU)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_eventually_mem_of_forall_separating_mem_iff (p : Set \u03b2 \u2192 Prop) {s : Set \u03b2}\n    [h' : HasCountableSeparatingOn \u03b2 p s] (hf : \u2200\u1da0 x in l, f x \u2208 s) (hg : \u2200\u1da0 x in l, g x \u2208 s)\n    (h : \u2200 U : Set \u03b2, p U \u2192 \u2200\u1da0 x in l, f x \u2208 U \u2194 g x \u2208 U) : f =\u1da0[l] g := by\n  rcases h'.1 with \u27e8S, hSc, hSp, hS\u27e9\n  have H : \u2200\u1da0 x in l, \u2200 s \u2208 S, f x \u2208 s \u2194 g x \u2208 s :=\n    (eventually_countable_ball hSc).2 fun s hs \u21a6 (h _ (hSp _ hs))\n  filter_upwards [H, hf, hg] with x hx hxf hxg using hS _ hxf _ hxg hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/CountableSeparatingOn.lean", "context": {"open": ["Function Set Filter"], "variables": ["{\u03b1 \u03b2 : Type*} {l : Filter \u03b1} [CountableInterFilter l] {f g : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\ninst\u271d : CountableInterFilter l\nf g : \u03b1 \u2192 \u03b2\np : Set \u03b2 \u2192 Prop\ns : Set \u03b2\nh' : HasCountableSeparatingOn \u03b2 p s\nhf : \u2200\u1da0 (x : \u03b1) in l, f x \u2208 s\nhg : \u2200\u1da0 (x : \u03b1) in l, g x \u2208 s\nh : \u2200 (U : Set \u03b2), p U \u2192 \u2200\u1da0 (x : \u03b1) in l, f x \u2208 U \u2194 g x \u2208 U\n\u22a2 f =\u1da0[l] g"}, {"line": "rcases h'.1 with \u27e8S, hSc, hSp, hS\u27e9", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\ninst\u271d : CountableInterFilter l\nf g : \u03b1 \u2192 \u03b2\np : Set \u03b2 \u2192 Prop\ns : Set \u03b2\nh' : HasCountableSeparatingOn \u03b2 p s\nhf : \u2200\u1da0 (x : \u03b1) in l, f x \u2208 s\nhg : \u2200\u1da0 (x : \u03b1) in l, g x \u2208 s\nh : \u2200 (U : Set \u03b2), p U \u2192 \u2200\u1da0 (x : \u03b1) in l, f x \u2208 U \u2194 g x \u2208 U\nS : Set (Set \u03b2)\nhSc : S.Countable\nhSp : \u2200 s \u2208 S, p s\nhS : \u2200 x \u2208 s, \u2200 y \u2208 s, (\u2200 s \u2208 S, x \u2208 s \u2194 y \u2208 s) \u2192 x = y\n\u22a2 f =\u1da0[l] g"}, {"line": "have H : \u2200\u1da0 x in l, \u2200 s \u2208 S, f x \u2208 s \u2194 g x \u2208 s :=\n    (eventually_countable_ball hSc).2 fun s hs \u21a6 (h _ (hSp _ hs))", "tactic_state": "case intro.intro.intro.refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\ninst\u271d : CountableInterFilter l\nf g : \u03b1 \u2192 \u03b2\np : Set \u03b2 \u2192 Prop\ns : Set \u03b2\nh' : HasCountableSeparatingOn \u03b2 p s\nhf : \u2200\u1da0 (x : \u03b1) in l, f x \u2208 s\nhg : \u2200\u1da0 (x : \u03b1) in l, g x \u2208 s\nh : \u2200 (U : Set \u03b2), p U \u2192 \u2200\u1da0 (x : \u03b1) in l, f x \u2208 U \u2194 g x \u2208 U\nS : Set (Set \u03b2)\nhSc : S.Countable\nhSp : \u2200 s \u2208 S, p s\nhS : \u2200 x \u2208 s, \u2200 y \u2208 s, (\u2200 s \u2208 S, x \u2208 s \u2194 y \u2208 s) \u2192 x = y\nH : \u2200\u1da0 (x : \u03b1) in l, \u2200 s \u2208 S, f x \u2208 s \u2194 g x \u2208 s\n\u22a2 f =\u1da0[l] g\n---\ncase intro.intro.intro.refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\ninst\u271d : CountableInterFilter l\nf g : \u03b1 \u2192 \u03b2\np : Set \u03b2 \u2192 Prop\ns : Set \u03b2\nh' : HasCountableSeparatingOn \u03b2 p s\nhf : \u2200\u1da0 (x : \u03b1) in l, f x \u2208 s\nhg : \u2200\u1da0 (x : \u03b1) in l, g x \u2208 s\nh : \u2200 (U : Set \u03b2), p U \u2192 \u2200\u1da0 (x : \u03b1) in l, f x \u2208 U \u2194 g x \u2208 U\nS : Set (Set \u03b2)\nhSc : S.Countable\nhSp : \u2200 s \u2208 S, p s\nhS : \u2200 x \u2208 s, \u2200 y \u2208 s, (\u2200 s \u2208 S, x \u2208 s \u2194 y \u2208 s) \u2192 x = y\n\u22a2 CountableInterFilter l"}, {"line": "filter_upwards [H, hf, hg] with x hx hxf hxg using hS _ hxf _ hxg hx", "tactic_state": "case intro.intro.intro.refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\ninst\u271d : CountableInterFilter l\nf g : \u03b1 \u2192 \u03b2\np : Set \u03b2 \u2192 Prop\ns : Set \u03b2\nh' : HasCountableSeparatingOn \u03b2 p s\nhf : \u2200\u1da0 (x : \u03b1) in l, f x \u2208 s\nhg : \u2200\u1da0 (x : \u03b1) in l, g x \u2208 s\nh : \u2200 (U : Set \u03b2), p U \u2192 \u2200\u1da0 (x : \u03b1) in l, f x \u2208 U \u2194 g x \u2208 U\nS : Set (Set \u03b2)\nhSc : S.Countable\nhSp : \u2200 s \u2208 S, p s\nhS : \u2200 x \u2208 s, \u2200 y \u2208 s, (\u2200 s \u2208 S, x \u2208 s \u2194 y \u2208 s) \u2192 x = y\n\u22a2 CountableInterFilter l"}]}
{"declaration": "theorem eventuallyConst_pred {p : \u03b1 \u2192 Prop} :\n    EventuallyConst p l \u2194 (\u2200\u1da0 x in l, p x) \u2228 (\u2200\u1da0 x in l, \u00acp x) := by\n  simp [eventuallyConst_pred', or_comm, EventuallyEq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/EventuallyConst.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {l : Filter \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\nx\u271d : Sort u_5\nEventuallyConst : x\u271d\np : \u03b1 \u2192 Prop\n\u22a2 sorry \u2194 (\u2200\u1da0 (x : \u03b1) in l, p x) \u2228 \u2200\u1da0 (x : \u03b1) in l, \u00acp x"}, {"line": "simp [eventuallyConst_pred', or_comm, EventuallyEq]", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\nx\u271d : Sort u_5\nEventuallyConst : x\u271d\np : \u03b1 \u2192 Prop\n\u22a2 sorry () \u2194 (\u2200\u1da0 (x : \u03b1) in l, p x) \u2228 \u2200\u1da0 (x : \u03b1) in l, \u00acp x"}]}
{"declaration": "lemma of_mulIndicator_const (h : EventuallyConst (s.mulIndicator fun _ \u21a6 c) l) (hc : c \u2260 1) :\n    EventuallyConst s l := by\n  simpa [Function.comp_def, hc, imp_false] using h.comp (\u00b7 = c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/EventuallyConst.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {l : Filter \u03b1} {f : \u03b1 \u2192 \u03b2}", "[One \u03b2] {s : Set \u03b1} {c : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\ninst\u271d : One \u03b2\nc : \u03b2\nx\u271d : Sort u_5\nEventuallyConst : x\u271d\nh : sorry\nhc : c \u2260 1\n\u22a2 sorry"}, {"line": "simpa [Function.comp_def, hc, imp_false] using h.comp (\u00b7 = c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mulIndicator_const (h : EventuallyConst s l) (c : \u03b2) :\n    EventuallyConst (s.mulIndicator fun _ \u21a6 c) l := by\n  classical exact h.comp (if \u00b7 then c else 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/EventuallyConst.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {l : Filter \u03b1} {f : \u03b1 \u2192 \u03b2}", "[One \u03b2] {s : Set \u03b1} {c : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\ninst\u271d : One \u03b2\nx\u271d : Sort u_5\nEventuallyConst : x\u271d\nh : sorry\nc : \u03b2\n\u22a2 sorry"}, {"line": "classical exact h.comp (if \u00b7 then c else 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mulIndicator_const_iff :\n    EventuallyConst (s.mulIndicator fun _ \u21a6 c) l \u2194 c = 1 \u2228 EventuallyConst s l := by\n  rcases eq_or_ne c 1 with rfl | hc <;> simp [mulIndicator_const_iff_of_ne, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/EventuallyConst.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {l : Filter \u03b1} {f : \u03b1 \u2192 \u03b2}", "[One \u03b2] {s : Set \u03b1} {c : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\ninst\u271d : One \u03b2\nc : \u03b2\nx\u271d : Sort u_5\nEventuallyConst : x\u271d\n\u22a2 sorry \u2194 c = 1 \u2228 sorry"}, {"line": "rcases eq_or_ne c 1 with rfl | hc <;> simp [mulIndicator_const_iff_of_ne, *]", "tactic_state": "case inl\n\u03b2 : Type u_2\ninst\u271d : One \u03b2\nx\u271d : Sort u_5\nEventuallyConst : x\u271d\n\u22a2 sorry () = 1 \u2192 sorry ()\n---\ncase inr\n\u03b2 : Type u_2\ninst\u271d : One \u03b2\nc : \u03b2\nx\u271d : Sort u_5\nEventuallyConst : x\u271d\nhc : c \u2260 sorry\n\u22a2 c = 1 \u2192 sorry ()"}]}
{"declaration": "theorem lift_top (g : Set \u03b1 \u2192 Filter \u03b2) : (\u22a4 : Filter \u03b1).lift g = g univ := by simp [Filter.lift]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Lift.lean", "context": {"open": ["Set Filter Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : Set \u03b1 \u2192 Filter \u03b2\n\u22a2 \u22a4.lift g = g univ"}, {"line": "simp [Filter.lift]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.lift {\u03b9} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {f : Filter \u03b1} (hf : f.HasBasis p s)\n    {\u03b2 : \u03b9 \u2192 Type*} {pg : \u2200 i, \u03b2 i \u2192 Prop} {sg : \u2200 i, \u03b2 i \u2192 Set \u03b3} {g : Set \u03b1 \u2192 Filter \u03b3}\n    (hg : \u2200 i, (g (s i)).HasBasis (pg i) (sg i)) (gm : Monotone g) :\n    (f.lift g).HasBasis (fun i : \u03a3i, \u03b2 i => p i.1 \u2227 pg i.1 i.2) fun i : \u03a3i, \u03b2 i => sg i.1 i.2 := by\n  refine \u27e8fun t => (hf.mem_lift_iff hg gm).trans ?_\u27e9\n  simp [Sigma.exists, and_assoc, exists_and_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Lift.lean", "context": {"open": ["Set Filter Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b3 : Type u_3\n\u03b9 : Type u_6\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nf : Filter \u03b1\nhf : f.HasBasis p s\n\u03b2 : \u03b9 \u2192 Type u_5\npg : (i : \u03b9) \u2192 \u03b2 i \u2192 Prop\nsg : (i : \u03b9) \u2192 \u03b2 i \u2192 Set \u03b3\ng : Set \u03b1 \u2192 Filter \u03b3\nhg : \u2200 (i : \u03b9), (g (s i)).HasBasis (pg i) (sg i)\ngm : Monotone g\n\u22a2 (f.lift g).HasBasis (fun i => p i.fst \u2227 pg i.fst i.snd) fun i => sg i.fst i.snd"}, {"line": "refine \u27e8fun t => (hf.mem_lift_iff hg gm).trans ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\n\u03b3 : Type u_3\n\u03b9 : Type u_6\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nf : Filter \u03b1\nhf : f.HasBasis p s\n\u03b2 : \u03b9 \u2192 Type u_5\npg : (i : \u03b9) \u2192 \u03b2 i \u2192 Prop\nsg : (i : \u03b9) \u2192 \u03b2 i \u2192 Set \u03b3\ng : Set \u03b1 \u2192 Filter \u03b3\nhg : \u2200 (i : \u03b9), (g (s i)).HasBasis (pg i) (sg i)\ngm : Monotone g\nt : Set \u03b3\n\u22a2 (\u2203 i, p i \u2227 \u2203 x, pg i x \u2227 sg i x \u2286 t) \u2194 \u2203 i, (p i.fst \u2227 pg i.fst i.snd) \u2227 sg i.fst i.snd \u2286 t"}, {"line": "simp [Sigma.exists, and_assoc, exists_and_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_lift {m : \u03b3 \u2192 \u03b2} {l : Filter \u03b3} :\n    Tendsto m l (f.lift g) \u2194 \u2200 s \u2208 f, Tendsto m l (g s) := by\n  simp only [Filter.lift]\n  simp only [tendsto_iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Lift.lean", "context": {"open": ["Set Filter Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nm : \u03b3 \u2192 \u03b2\nl : Filter \u03b3\n\u22a2 Tendsto m l (f.lift g) \u2194 \u2200 s \u2208 f, Tendsto m l (g s)"}, {"line": "simp only [Filter.lift]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nm : \u03b3 \u2192 \u03b2\nl : Filter \u03b3\n\u22a2 Tendsto m l (\u2a05 s \u2208 f, g s) \u2194 \u2200 s \u2208 f, Tendsto m l (g s)"}, {"line": "simp only [tendsto_iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_neBot_iff (hm : Monotone g) : (NeBot (f.lift g)) \u2194 \u2200 s \u2208 f, NeBot (g s) := by\n  simp only [neBot_iff]\n  simp only [Ne]\n  simp only [\u2190 empty_mem_iff_bot]\n  simp only [mem_lift_sets hm]\n  simp only [not_exists]\n  simp only [not_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Lift.lean", "context": {"open": ["Set Filter Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhm : Monotone g\n\u22a2 (f.lift g).NeBot \u2194 \u2200 s \u2208 f, (g s).NeBot"}, {"line": "simp only [neBot_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhm : Monotone g\n\u22a2 f.lift g \u2260 \u22a5 \u2194 \u2200 s \u2208 f, g s \u2260 \u22a5"}, {"line": "simp only [Ne]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhm : Monotone g\n\u22a2 \u00acf.lift g = \u22a5 \u2194 \u2200 s \u2208 f, \u00acg s = \u22a5"}, {"line": "simp only [\u2190 empty_mem_iff_bot]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhm : Monotone g\n\u22a2 \u2205 \u2209 f.lift g \u2194 \u2200 s \u2208 f, \u2205 \u2209 g s"}, {"line": "simp only [mem_lift_sets hm]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhm : Monotone g\n\u22a2 (\u00ac\u2203 t \u2208 f, \u2205 \u2208 g t) \u2194 \u2200 s \u2208 f, \u2205 \u2209 g s"}, {"line": "simp only [not_exists]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhm : Monotone g\n\u22a2 (\u2200 (x : Set \u03b1), \u00ac(x \u2208 f \u2227 \u2205 \u2208 g x)) \u2194 \u2200 s \u2208 f, \u2205 \u2209 g s"}, {"line": "simp only [not_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_inf {f : Filter \u03b1} {g h : Set \u03b1 \u2192 Filter \u03b2} :\n    (f.lift fun x => g x \u2293 h x) = f.lift g \u2293 f.lift h := by simp only [Filter.lift, iInf_inf_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Lift.lean", "context": {"open": ["Set Filter Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng h : Set \u03b1 \u2192 Filter \u03b2\n\u22a2 (f.lift fun x => g x \u2293 h x) = f.lift g \u2293 f.lift h"}, {"line": "simp only [Filter.lift, iInf_inf_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_iInf [Nonempty \u03b9] {f : \u03b9 \u2192 Filter \u03b1} {g : Set \u03b1 \u2192 Filter \u03b2}\n    (hg : \u2200 s t, g (s \u2229 t) = g s \u2293 g t) : (iInf f).lift g = \u2a05 i, (f i).lift g := by\n  refine lift_iInf_le.antisymm fun s => ?_\n  have H : \u2200 t \u2208 iInf f, \u2a05 i, (f i).lift g \u2264 g t := by\n    intro t ht\n    refine iInf_sets_induct ht ?_ fun hs ht => ?_\n    \u00b7 inhabit \u03b9\n      exact iInf\u2082_le_of_le default univ (iInf_le _ univ_mem)\n    \u00b7 rw [hg]\n      exact le_inf (iInf\u2082_le_of_le _ _ <| iInf_le _ hs) ht\n  simp only [mem_lift_sets (Monotone.of_map_inf hg)]\n  simp only [exists_imp]\n  simp only [and_imp]\n  exact fun t ht hs => H t ht hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Lift.lean", "context": {"open": ["Set Filter Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhg : \u2200 (s t : Set \u03b1), g (s \u2229 t) = g s \u2293 g t\n\u22a2 (iInf f).lift g = \u2a05 i, (f i).lift g"}, {"line": "refine lift_iInf_le.antisymm fun s => ?_", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhg : \u2200 (s t : Set \u03b1), g (s \u2229 t) = g s \u2293 g t\ns : Set \u03b2\n\u22a2 s \u2208 (iInf f).lift g \u2192 s \u2208 \u2a05 i, (f i).lift g"}, {"line": "have H : \u2200 t \u2208 iInf f, \u2a05 i, (f i).lift g \u2264 g t := sorry", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhg : \u2200 (s t : Set \u03b1), g (s \u2229 t) = g s \u2293 g t\ns : Set \u03b2\nH : \u2200 t \u2208 iInf f, \u2a05 i, (f i).lift g \u2264 g t\n\u22a2 s \u2208 (iInf f).lift g \u2192 s \u2208 \u2a05 i, (f i).lift g"}, {"line": "simp only [mem_lift_sets (Monotone.of_map_inf hg)]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhg : \u2200 (s t : Set \u03b1), g (s \u2229 t) = g s \u2293 g t\ns : Set \u03b2\nH : \u2200 t \u2208 iInf f, \u2a05 i, (f i).lift g \u2264 g t\n\u22a2 (\u2203 t \u2208 iInf f, s \u2208 g t) \u2192 s \u2208 \u2a05 i, (f i).lift g"}, {"line": "simp only [exists_imp]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhg : \u2200 (s t : Set \u03b1), g (s \u2229 t) = g s \u2293 g t\ns : Set \u03b2\nH : \u2200 t \u2208 iInf f, \u2a05 i, (f i).lift g \u2264 g t\n\u22a2 \u2200 (x : Set \u03b1), x \u2208 iInf f \u2227 s \u2208 g x \u2192 s \u2208 \u2a05 i, (f i).lift g"}, {"line": "simp only [and_imp]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhg : \u2200 (s t : Set \u03b1), g (s \u2229 t) = g s \u2293 g t\ns : Set \u03b2\nH : \u2200 t \u2208 iInf f, \u2a05 i, (f i).lift g \u2264 g t\n\u22a2 \u2200 x \u2208 iInf f, s \u2208 g x \u2192 s \u2208 \u2a05 i, (f i).lift g"}, {"line": "exact fun t ht hs => H t ht hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_iInf_of_map_univ {f : \u03b9 \u2192 Filter \u03b1} {g : Set \u03b1 \u2192 Filter \u03b2}\n    (hg : \u2200 s t, g (s \u2229 t) = g s \u2293 g t) (hg' : g univ = \u22a4) :\n    (iInf f).lift g = \u2a05 i, (f i).lift g := by\n  cases isEmpty_or_nonempty \u03b9\n  \u00b7 simp [iInf_of_empty, hg']\n  \u00b7 exact lift_iInf hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Lift.lean", "context": {"open": ["Set Filter Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\nf : \u03b9 \u2192 Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhg : \u2200 (s t : Set \u03b1), g (s \u2229 t) = g s \u2293 g t\nhg' : g univ = \u22a4\n\u22a2 (iInf f).lift g = \u2a05 i, (f i).lift g"}, {"line": "cases isEmpty_or_nonempty \u03b9", "tactic_state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\nf : \u03b9 \u2192 Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhg : \u2200 (s t : Set \u03b1), g (s \u2229 t) = g s \u2293 g t\nhg' : g univ = \u22a4\nh\u271d : IsEmpty \u03b9\n\u22a2 (iInf f).lift g = \u2a05 i, (f i).lift g\n---\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\nf : \u03b9 \u2192 Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhg : \u2200 (s t : Set \u03b1), g (s \u2229 t) = g s \u2293 g t\nhg' : g univ = \u22a4\nh\u271d : Nonempty \u03b9\n\u22a2 (iInf f).lift g = \u2a05 i, (f i).lift g"}, {"line": "\u00b7 simp [iInf_of_empty, hg']", "tactic_state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\nf : \u03b9 \u2192 Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhg : \u2200 (s t : Set \u03b1), g (s \u2229 t) = g s \u2293 g t\nhg' : g univ = \u22a4\nh\u271d : Nonempty \u03b9\n\u22a2 (iInf f).lift g = \u2a05 i, (f i).lift g"}, {"line": "\u00b7 exact lift_iInf hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_lift'_eq {m : \u03b2 \u2192 \u03b3} (hh : Monotone h) : map m (f.lift' h) = f.lift' (image m \u2218 h) :=\n  calc\n    map m (f.lift' h) = f.lift (map m \u2218 \ud835\udcdf \u2218 h) := map_lift_eq <| monotone_principal.comp hh\n    _ = f.lift' (image m \u2218 h) := by simp only [comp_def, Filter.lift', map_principal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Lift.lean", "context": {"open": ["Set Filter Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2}", "{f f\u2081 f\u2082 : Filter \u03b1} {h h\u2081 h\u2082 : Set \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Filter \u03b1\nh : Set \u03b1 \u2192 Set \u03b2\nm : \u03b2 \u2192 \u03b3\nhh : Monotone h\n\u22a2 f.lift (map m \u2218 principal \u2218 h) = f.lift' (image m \u2218 h)"}, {"line": "simp only [comp_def, Filter.lift', map_principal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_lift'_eq {m : \u03b3 \u2192 \u03b2} : comap m (f.lift' h) = f.lift' (preimage m \u2218 h) := by\n  simp only [Filter.lift']\n  simp only [comap_lift_eq]\n  simp only [comp_def]\n  simp only [comap_principal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Lift.lean", "context": {"open": ["Set Filter Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2}", "{f f\u2081 f\u2082 : Filter \u03b1} {h h\u2081 h\u2082 : Set \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Filter \u03b1\nh : Set \u03b1 \u2192 Set \u03b2\nm : \u03b3 \u2192 \u03b2\n\u22a2 comap m (f.lift' h) = f.lift' (preimage m \u2218 h)"}, {"line": "simp only [Filter.lift']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Filter \u03b1\nh : Set \u03b1 \u2192 Set \u03b2\nm : \u03b3 \u2192 \u03b2\n\u22a2 comap m (f.lift (principal \u2218 h)) = f.lift (principal \u2218 preimage m \u2218 h)"}, {"line": "simp only [comap_lift_eq]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Filter \u03b1\nh : Set \u03b1 \u2192 Set \u03b2\nm : \u03b3 \u2192 \u03b2\n\u22a2 f.lift (comap m \u2218 principal \u2218 h) = f.lift (principal \u2218 preimage m \u2218 h)"}, {"line": "simp only [comp_def]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Filter \u03b1\nh : Set \u03b1 \u2192 Set \u03b2\nm : \u03b3 \u2192 \u03b2\n\u22a2 (f.lift fun x => comap m (principal (h x))) = f.lift fun x => principal (m \u207b\u00b9' h x)"}, {"line": "simp only [comap_principal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift'_bot (hh : Monotone h) : (\u22a5 : Filter \u03b1).lift' h = \ud835\udcdf (h \u2205) := by\n  rw [\u2190 principal_empty]\n  rw [lift'_principal hh]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Lift.lean", "context": {"open": ["Set Filter Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2}", "{f f\u2081 f\u2082 : Filter \u03b1} {h h\u2081 h\u2082 : Set \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nh : Set \u03b1 \u2192 Set \u03b2\nhh : Monotone h\n\u22a2 \u22a5.lift' h = principal (h \u2205)"}, {"line": "rw [\u2190 principal_empty]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nh : Set \u03b1 \u2192 Set \u03b2\nhh : Monotone h\n\u22a2 (principal \u2205).lift' h = principal (h \u2205)"}, {"line": "rw [lift'_principal hh]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_lift'_assoc {g : Set \u03b1 \u2192 Set \u03b2} {h : Set \u03b2 \u2192 Filter \u03b3} (hg : Monotone g)\n    (hh : Monotone h) : (f.lift' g).lift h = f.lift fun s => h (g s) :=\n  calc\n    (f.lift' g).lift h = f.lift fun s => (\ud835\udcdf (g s)).lift h := lift_assoc (monotone_principal.comp hg)\n    _ = f.lift fun s => h (g s) := by simp only [lift_principal, hh, eq_self_iff_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Lift.lean", "context": {"open": ["Set Filter Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2}", "{f f\u2081 f\u2082 : Filter \u03b1} {h h\u2081 h\u2082 : Set \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Filter \u03b1\ng : Set \u03b1 \u2192 Set \u03b2\nh : Set \u03b2 \u2192 Filter \u03b3\nhg : Monotone g\nhh : Monotone h\n\u22a2 (f.lift fun s => (principal (g s)).lift h) = f.lift fun s => h (g s)"}, {"line": "simp only [lift_principal, hh, eq_self_iff_true]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift'_inf_principal_eq {h : Set \u03b1 \u2192 Set \u03b2} {s : Set \u03b2} :\n    f.lift' h \u2293 \ud835\udcdf s = f.lift' fun t => h t \u2229 s := by\n  simp only [Filter.lift']\n  simp only [Filter.lift]\n  simp only [(\u00b7 \u2218 \u00b7)]\n  simp only [\u2190 inf_principal]\n  simp only [iInf_subtype']\n  simp only [\u2190 iInf_inf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Lift.lean", "context": {"open": ["Set Filter Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2}", "{f f\u2081 f\u2082 : Filter \u03b1} {h h\u2081 h\u2082 : Set \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\nh : Set \u03b1 \u2192 Set \u03b2\ns : Set \u03b2\n\u22a2 f.lift' h \u2293 principal s = f.lift' fun t => h t \u2229 s"}, {"line": "simp only [Filter.lift']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\nh : Set \u03b1 \u2192 Set \u03b2\ns : Set \u03b2\n\u22a2 f.lift (principal \u2218 h) \u2293 principal s = f.lift (principal \u2218 fun t => h t \u2229 s)"}, {"line": "simp only [Filter.lift]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\nh : Set \u03b1 \u2192 Set \u03b2\ns : Set \u03b2\n\u22a2 (\u2a05 s \u2208 f, (principal \u2218 h) s) \u2293 principal s = \u2a05 s_1 \u2208 f, (principal \u2218 fun t => h t \u2229 s) s_1"}, {"line": "simp only [(\u00b7 \u2218 \u00b7)]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\nh : Set \u03b1 \u2192 Set \u03b2\ns : Set \u03b2\n\u22a2 (\u2a05 s \u2208 f, principal (h s)) \u2293 principal s = \u2a05 s_1 \u2208 f, principal (h s_1 \u2229 s)"}, {"line": "simp only [\u2190 inf_principal]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\nh : Set \u03b1 \u2192 Set \u03b2\ns : Set \u03b2\n\u22a2 (\u2a05 s \u2208 f, principal (h s)) \u2293 principal s = \u2a05 s_1 \u2208 f, principal (h s_1) \u2293 principal s"}, {"line": "simp only [iInf_subtype']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\nh : Set \u03b1 \u2192 Set \u03b2\ns : Set \u03b2\n\u22a2 (\u2a05 x, principal (h \u2191x)) \u2293 principal s = \u2a05 x, principal (h \u2191x) \u2293 principal s"}, {"line": "simp only [\u2190 iInf_inf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift'_neBot_iff (hh : Monotone h) : NeBot (f.lift' h) \u2194 \u2200 s \u2208 f, (h s).Nonempty :=\n  calc\n    NeBot (f.lift' h) \u2194 \u2200 s \u2208 f, NeBot (\ud835\udcdf (h s)) := lift_neBot_iff (monotone_principal.comp hh)\n    _ \u2194 \u2200 s \u2208 f, (h s).Nonempty := by simp only [principal_neBot_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Lift.lean", "context": {"open": ["Set Filter Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2}", "{f f\u2081 f\u2082 : Filter \u03b1} {h h\u2081 h\u2082 : Set \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\nh : Set \u03b1 \u2192 Set \u03b2\nhh : Monotone h\n\u22a2 (\u2200 s \u2208 f, (principal (h s)).NeBot) \u2194 \u2200 s \u2208 f, (h s).Nonempty"}, {"line": "simp only [principal_neBot_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift'_inf (f g : Filter \u03b1) {s : Set \u03b1 \u2192 Set \u03b2} (hs : \u2200 t\u2081 t\u2082, s (t\u2081 \u2229 t\u2082) = s t\u2081 \u2229 s t\u2082) :\n    (f \u2293 g).lift' s = f.lift' s \u2293 g.lift' s := by\n  rw [inf_eq_iInf]\n  rw [inf_eq_iInf]\n  rw [lift'_iInf hs]\n  refine iInf_congr ?_\n  rintro (_|_) <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Lift.lean", "context": {"open": ["Set Filter Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2}", "{f f\u2081 f\u2082 : Filter \u03b1} {h h\u2081 h\u2082 : Set \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : Filter \u03b1\ns : Set \u03b1 \u2192 Set \u03b2\nhs : \u2200 (t\u2081 t\u2082 : Set \u03b1), s (t\u2081 \u2229 t\u2082) = s t\u2081 \u2229 s t\u2082\n\u22a2 (f \u2293 g).lift' s = f.lift' s \u2293 g.lift' s"}, {"line": "rw [inf_eq_iInf]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : Filter \u03b1\ns : Set \u03b1 \u2192 Set \u03b2\nhs : \u2200 (t\u2081 t\u2082 : Set \u03b1), s (t\u2081 \u2229 t\u2082) = s t\u2081 \u2229 s t\u2082\n\u22a2 (\u2a05 b, bif b then f else g).lift' s = f.lift' s \u2293 g.lift' s"}, {"line": "rw [inf_eq_iInf]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : Filter \u03b1\ns : Set \u03b1 \u2192 Set \u03b2\nhs : \u2200 (t\u2081 t\u2082 : Set \u03b1), s (t\u2081 \u2229 t\u2082) = s t\u2081 \u2229 s t\u2082\n\u22a2 (\u2a05 b, bif b then f else g).lift' s = \u2a05 b, bif b then f.lift' s else g.lift' s"}, {"line": "rw [lift'_iInf hs]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : Filter \u03b1\ns : Set \u03b1 \u2192 Set \u03b2\nhs : \u2200 (t\u2081 t\u2082 : Set \u03b1), s (t\u2081 \u2229 t\u2082) = s t\u2081 \u2229 s t\u2082\n\u22a2 \u2a05 i, (bif i then f else g).lift' s = \u2a05 b, bif b then f.lift' s else g.lift' s"}, {"line": "refine iInf_congr ?_", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : Filter \u03b1\ns : Set \u03b1 \u2192 Set \u03b2\nhs : \u2200 (t\u2081 t\u2082 : Set \u03b1), s (t\u2081 \u2229 t\u2082) = s t\u2081 \u2229 s t\u2082\n\u22a2 \u2200 (i : Bool), (bif i then f else g).lift' s = bif i then f.lift' s else g.lift' s"}, {"line": "rintro (_|_) <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_def {f : Filter \u03b1} {g : Filter \u03b2} :\n    f \u00d7\u02e2 g = f.lift fun s => g.lift' fun t => s \u00d7\u02e2 t := by\n  simpa only [Filter.lift',Filter.lift,(f.basis_sets.prod g.basis_sets).eq_biInf,iInf_prod,iInf_and] using iInf_congr fun i => iInf_comm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Lift.lean", "context": {"open": ["Set Filter Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2}", "{f f\u2081 f\u2082 : Filter \u03b1} {h h\u2081 h\u2082 : Set \u03b1 \u2192 Set \u03b2}", "{f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 f \u00d7\u02e2 g = f.lift fun s => g.lift' fun t => s \u00d7\u02e2 t"}, {"line": "simpa only [Filter.lift',Filter.lift,(f.basis_sets.prod g.basis_sets).eq_biInf,iInf_prod,iInf_and] using iInf_congr fun i => iInf_comm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_lift'_lift' {f\u2081 : Filter \u03b1\u2081} {f\u2082 : Filter \u03b1\u2082} {g\u2081 : Set \u03b1\u2081 \u2192 Set \u03b2\u2081}\n    {g\u2082 : Set \u03b1\u2082 \u2192 Set \u03b2\u2082} (hg\u2081 : Monotone g\u2081) (hg\u2082 : Monotone g\u2082) :\n    f\u2081.lift' g\u2081 \u00d7\u02e2 f\u2082.lift' g\u2082 = f\u2081.lift fun s => f\u2082.lift' fun t => g\u2081 s \u00d7\u02e2 g\u2082 t :=\n  calc\n    f\u2081.lift' g\u2081 \u00d7\u02e2 f\u2082.lift' g\u2082 = f\u2081.lift fun s => f\u2082.lift fun t => \ud835\udcdf (g\u2081 s) \u00d7\u02e2 \ud835\udcdf (g\u2082 t) :=\n      prod_lift_lift (monotone_principal.comp hg\u2081) (monotone_principal.comp hg\u2082)\n    _ = f\u2081.lift fun s => f\u2082.lift fun t => \ud835\udcdf (g\u2081 s \u00d7\u02e2 g\u2082 t) := by\n      { simp only [prod_principal_principal] }\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Lift.lean", "context": {"open": ["Set Filter Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2}", "{f f\u2081 f\u2082 : Filter \u03b1} {h h\u2081 h\u2082 : Set \u03b1 \u2192 Set \u03b2}", "{f : Filter \u03b1}", "{\u03b1\u2081 : Type*} {\u03b1\u2082 : Type*} {\u03b2\u2081 : Type*} {\u03b2\u2082 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u2081 : Type u_5\n\u03b1\u2082 : Type u_6\n\u03b2\u2081 : Type u_7\n\u03b2\u2082 : Type u_8\nf\u2081 : Filter \u03b1\u2081\nf\u2082 : Filter \u03b1\u2082\ng\u2081 : Set \u03b1\u2081 \u2192 Set \u03b2\u2081\ng\u2082 : Set \u03b1\u2082 \u2192 Set \u03b2\u2082\nhg\u2081 : Monotone g\u2081\nhg\u2082 : Monotone g\u2082\n\u22a2 (f\u2081.lift fun s => f\u2082.lift fun t => principal (g\u2081 s) \u00d7\u02e2 principal (g\u2082 t)) =\n    f\u2081.lift fun s => f\u2082.lift fun t => principal (g\u2081 s \u00d7\u02e2 g\u2082 t)"}, {"line": "{ simp only [prod_principal_principal] }", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_traverse_iff (fs : List \u03b2) (t : Set (List \u03b1)) :\n    t \u2208 traverse f fs \u2194\n      \u2203 us : List (Set \u03b1), Forall\u2082 (fun b (s : Set \u03b1) => s \u2208 f b) fs us \u2227 sequence us \u2286 t := by\n  constructor\n  \u00b7 induction fs generalizing t with\n    | nil =>\n      simp only [sequence]\n      simp only [mem_pure]\n      simp only [imp_self]\n      simp only [forall\u2082_nil_left_iff]\n      simp only [exists_eq_left]\n      simp only [Set.pure_def]\n      simp only [singleton_subset_iff]\n      simp only [traverse_nil]\n    | cons b fs ih =>\n      intro ht\n      rcases mem_seq_iff.1 ht with \u27e8u, hu, v, hv, ht\u27e9\n      rcases mem_map_iff_exists_image.1 hu with \u27e8w, hw, hwu\u27e9\n      rcases ih v hv with \u27e8us, hus, hu\u27e9\n      exact \u27e8w::us, Forall\u2082.cons hw hus, (Set.seq_mono hwu hu).trans ht\u27e9\n  \u00b7 rintro \u27e8us, hus, hs\u27e9\n    exact mem_of_superset (mem_traverse _ _ hus) hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/ListTraverse.lean", "context": {"open": ["Set List"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type u} {f : \u03b2 \u2192 Filter \u03b1} {s : \u03b3 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type u\nf : \u03b2 \u2192 Filter \u03b1\nfs : List \u03b2\nt : Set (List \u03b1)\n\u22a2 t \u2208 traverse f fs \u2194 \u2203 us, Forall\u2082 (fun b s => s \u2208 f b) fs us \u2227 sequence us \u2286 t"}, {"line": "constructor", "tactic_state": "case mp\n\u03b1 \u03b2 : Type u\nf : \u03b2 \u2192 Filter \u03b1\nfs : List \u03b2\nt : Set (List \u03b1)\n\u22a2 t \u2208 traverse f fs \u2192 \u2203 us, Forall\u2082 (fun b s => s \u2208 f b) fs us \u2227 sequence us \u2286 t\n---\ncase mpr\n\u03b1 \u03b2 : Type u\nf : \u03b2 \u2192 Filter \u03b1\nfs : List \u03b2\nt : Set (List \u03b1)\n\u22a2 (\u2203 us, Forall\u2082 (fun b s => s \u2208 f b) fs us \u2227 sequence us \u2286 t) \u2192 t \u2208 traverse f fs"}, {"line": "\u00b7 induction fs generalizing t with\n    | nil =>\n      simp only [sequence]\n      simp only [mem_pure]\n      simp only [imp_self]\n      simp only [forall\u2082_nil_left_iff]\n      simp only [exists_eq_left]\n      simp only [Set.pure_def]\n      simp only [singleton_subset_iff]\n      simp only [traverse_nil]\n    | cons b fs ih =>\n      intro ht\n      rcases mem_seq_iff.1 ht with \u27e8u, hu, v, hv, ht\u27e9\n      rcases mem_map_iff_exists_image.1 hu with \u27e8w, hw, hwu\u27e9\n      rcases ih v hv with \u27e8us, hus, hu\u27e9\n      exact \u27e8w::us, Forall\u2082.cons hw hus, (Set.seq_mono hwu hu).trans ht\u27e9", "tactic_state": "case mpr\n\u03b1 \u03b2 : Type u\nf : \u03b2 \u2192 Filter \u03b1\nfs : List \u03b2\nt : Set (List \u03b1)\n\u22a2 (\u2203 us, Forall\u2082 (fun b s => s \u2208 f b) fs us \u2227 sequence us \u2286 t) \u2192 t \u2208 traverse f fs"}, {"line": "\u00b7 rintro \u27e8us, hus, hs\u27e9\n    exact mem_of_superset (mem_traverse _ _ hus) hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_prod_eq_map\u2082 (m : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (f : Filter \u03b1) (g : Filter \u03b2) :\n    Filter.map (fun p : \u03b1 \u00d7 \u03b2 => m p.1 p.2) (f \u00d7\u02e2 g) = map\u2082 m f g := by\n  rw [map\u2082]\n  rw [copy_eq]\n  rw [uncurry_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nm : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 map (fun p => m p.1 p.2) (f \u00d7\u02e2 g) = map\u2082 m f g"}, {"line": "rw [map\u2082]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nm : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 map (fun p => m p.1 p.2) (f \u00d7\u02e2 g) = (map (uncurry m) (f \u00d7\u02e2 g)).copy {s | \u2203 u \u2208 f, \u2203 v \u2208 g, image2 m u v \u2286 s} \u22ef"}, {"line": "rw [copy_eq]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nm : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 map (fun p => m p.1 p.2) (f \u00d7\u02e2 g) = map (uncurry m) (f \u00d7\u02e2 g)"}, {"line": "rw [uncurry_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map\u2082_mk_eq_prod (f : Filter \u03b1) (g : Filter \u03b2) : map\u2082 Prod.mk f g = f \u00d7\u02e2 g := by\n  simp only [\u2190 map_prod_eq_map\u2082]\n  simp only [map_id']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 map\u2082 Prod.mk f g = f \u00d7\u02e2 g"}, {"line": "simp only [\u2190 map_prod_eq_map\u2082]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 map (fun p => (p.1, p.2)) (f \u00d7\u02e2 g) = f \u00d7\u02e2 g"}, {"line": "simp only [map_id']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map\u2082_eq_bot_iff : map\u2082 m f g = \u22a5 \u2194 f = \u22a5 \u2228 g = \u22a5 := by simp [\u2190 map_prod_eq_map\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nm : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 map\u2082 m f g = \u22a5 \u2194 f = \u22a5 \u2228 g = \u22a5"}, {"line": "simp [\u2190 map_prod_eq_map\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map\u2082_neBot_iff : (map\u2082 m f g).NeBot \u2194 f.NeBot \u2227 g.NeBot := by simp [neBot_iff, not_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nm : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 (map\u2082 m f g).NeBot \u2194 f.NeBot \u2227 g.NeBot"}, {"line": "simp [neBot_iff, not_or]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map\u2082_sup_left : map\u2082 m (f\u2081 \u2294 f\u2082) g = map\u2082 m f\u2081 g \u2294 map\u2082 m f\u2082 g := by\n  simp_rw [\u2190 map_prod_eq_map\u2082, sup_prod, map_sup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nm : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf\u2081 f\u2082 : Filter \u03b1\ng : Filter \u03b2\n\u22a2 map\u2082 m (f\u2081 \u2294 f\u2082) g = map\u2082 m f\u2081 g \u2294 map\u2082 m f\u2082 g"}, {"line": "simp_rw [\u2190 map_prod_eq_map\u2082, sup_prod, map_sup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map\u2082_sup_right : map\u2082 m f (g\u2081 \u2294 g\u2082) = map\u2082 m f g\u2081 \u2294 map\u2082 m f g\u2082 := by\n  simp_rw [\u2190 map_prod_eq_map\u2082, prod_sup, map_sup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nm : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf : Filter \u03b1\ng\u2081 g\u2082 : Filter \u03b2\n\u22a2 map\u2082 m f (g\u2081 \u2294 g\u2082) = map\u2082 m f g\u2081 \u2294 map\u2082 m f g\u2082"}, {"line": "simp_rw [\u2190 map_prod_eq_map\u2082, prod_sup, map_sup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map\u2082_pure : map\u2082 m (pure a) (pure b) = pure (m a b) := by rw [map\u2082_pure_right, map_pure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nm : \u03b1 \u2192 \u03b2 \u2192 \u03b3\na : \u03b1\nb : \u03b2\n\u22a2 map\u2082 m (pure a) (pure b) = pure (m a b)"}, {"line": "rw [map\u2082_pure_right, map_pure]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map\u2082_swap (m : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (f : Filter \u03b1) (g : Filter \u03b2) :\n    map\u2082 m f g = map\u2082 (fun a b => m b a) g f := by\n  rw [\u2190 map_prod_eq_map\u2082]\n  rw [prod_comm]\n  rw [map_map]\n  rw [\u2190 map_prod_eq_map\u2082]\n  rw [Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nm : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 map\u2082 m f g = map\u2082 (fun a b => m b a) g f"}, {"line": "rw [\u2190 map_prod_eq_map\u2082]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nm : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 map (fun p => m p.1 p.2) (f \u00d7\u02e2 g) = map\u2082 (fun a b => m b a) g f"}, {"line": "rw [prod_comm]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nm : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 map (fun p => m p.1 p.2) (map (fun p => (p.2, p.1)) (g \u00d7\u02e2 f)) = map\u2082 (fun a b => m b a) g f"}, {"line": "rw [map_map]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nm : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 map ((fun p => m p.1 p.2) \u2218 fun p => (p.2, p.1)) (g \u00d7\u02e2 f) = map\u2082 (fun a b => m b a) g f"}, {"line": "rw [\u2190 map_prod_eq_map\u2082]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nm : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 map ((fun p => m p.1 p.2) \u2218 fun p => (p.2, p.1)) (g \u00d7\u02e2 f) = map (fun p => m p.2 p.1) (g \u00d7\u02e2 f)"}, {"line": "rw [Function.comp_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map\u2082_right [NeBot f] : map\u2082 (fun _ y => y) f g = g := by rw [map\u2082_swap, map\u2082_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\n\u03b1\u271d : Type u_11\ng : Filter \u03b1\u271d\ninst\u271d : f.NeBot\n\u22a2 map\u2082 (fun x y => y) f g = g"}, {"line": "rw [map\u2082_swap, map\u2082_left]", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\n\u03b1\u271d : Type u_11\ng : Filter \u03b1\u271d\ninst\u271d : f.NeBot\n\u22a2 f.NeBot"}]}
{"declaration": "theorem map\u2082_map_right (m : \u03b1 \u2192 \u03b3 \u2192 \u03b4) (n : \u03b2 \u2192 \u03b3) :\n    map\u2082 m f (g.map n) = map\u2082 (fun a b => m a (n b)) f g := by\n  rw [map\u2082_swap]\n  rw [map\u2082_map_left]\n  rw [map\u2082_swap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\nf : Filter \u03b1\ng : Filter \u03b2\nm : \u03b1 \u2192 \u03b3 \u2192 \u03b4\nn : \u03b2 \u2192 \u03b3\n\u22a2 map\u2082 m f (map n g) = map\u2082 (fun a b => m a (n b)) f g"}, {"line": "rw [map\u2082_swap]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\nf : Filter \u03b1\ng : Filter \u03b2\nm : \u03b1 \u2192 \u03b3 \u2192 \u03b4\nn : \u03b2 \u2192 \u03b3\n\u22a2 map\u2082 (fun a b => m b a) (map n g) f = map\u2082 (fun a b => m a (n b)) f g"}, {"line": "rw [map\u2082_map_left]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\nf : Filter \u03b1\ng : Filter \u03b2\nm : \u03b1 \u2192 \u03b3 \u2192 \u03b4\nn : \u03b2 \u2192 \u03b3\n\u22a2 map\u2082 (fun a b => m b (n a)) g f = map\u2082 (fun a b => m a (n b)) f g"}, {"line": "rw [map\u2082_swap]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map\u2082_assoc {m : \u03b4 \u2192 \u03b3 \u2192 \u03b5} {n : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {m' : \u03b1 \u2192 \u03b5' \u2192 \u03b5} {n' : \u03b2 \u2192 \u03b3 \u2192 \u03b5'}\n    {h : Filter \u03b3} (h_assoc : \u2200 a b c, m (n a b) c = m' a (n' b c)) :\n    map\u2082 m (map\u2082 n f g) h = map\u2082 m' f (map\u2082 n' g h) := by\n  rw [\u2190 map_prod_eq_map\u2082 n]\n  rw [\u2190 map_prod_eq_map\u2082 n']\n  rw [map\u2082_map_left]\n  rw [map\u2082_map_right]\n  rw [\u2190 map_prod_eq_map\u2082]\n  rw [\u2190 map_prod_eq_map\u2082]\n  rw [\u2190 prod_assoc]\n  rw [map_map]\n  simp only [h_assoc]\n  simp only [Function.comp_def]\n  simp only [Equiv.prodAssoc_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b5 : Type u_9\n\u03b5' : Type u_10\nf : Filter \u03b1\ng : Filter \u03b2\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b5' \u2192 \u03b5\nn' : \u03b2 \u2192 \u03b3 \u2192 \u03b5'\nh : Filter \u03b3\nh_assoc : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = m' a (n' b c)\n\u22a2 map\u2082 m (map\u2082 n f g) h = map\u2082 m' f (map\u2082 n' g h)"}, {"line": "rw [\u2190 map_prod_eq_map\u2082 n]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b5 : Type u_9\n\u03b5' : Type u_10\nf : Filter \u03b1\ng : Filter \u03b2\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b5' \u2192 \u03b5\nn' : \u03b2 \u2192 \u03b3 \u2192 \u03b5'\nh : Filter \u03b3\nh_assoc : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = m' a (n' b c)\n\u22a2 map\u2082 m (map (fun p => n p.1 p.2) (f \u00d7\u02e2 g)) h = map\u2082 m' f (map\u2082 n' g h)"}, {"line": "rw [\u2190 map_prod_eq_map\u2082 n']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b5 : Type u_9\n\u03b5' : Type u_10\nf : Filter \u03b1\ng : Filter \u03b2\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b5' \u2192 \u03b5\nn' : \u03b2 \u2192 \u03b3 \u2192 \u03b5'\nh : Filter \u03b3\nh_assoc : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = m' a (n' b c)\n\u22a2 map\u2082 m (map (fun p => n p.1 p.2) (f \u00d7\u02e2 g)) h = map\u2082 m' f (map (fun p => n' p.1 p.2) (g \u00d7\u02e2 h))"}, {"line": "rw [map\u2082_map_left]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b5 : Type u_9\n\u03b5' : Type u_10\nf : Filter \u03b1\ng : Filter \u03b2\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b5' \u2192 \u03b5\nn' : \u03b2 \u2192 \u03b3 \u2192 \u03b5'\nh : Filter \u03b3\nh_assoc : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = m' a (n' b c)\n\u22a2 map\u2082 (fun a b => m (n a.1 a.2) b) (f \u00d7\u02e2 g) h = map\u2082 m' f (map (fun p => n' p.1 p.2) (g \u00d7\u02e2 h))"}, {"line": "rw [map\u2082_map_right]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b5 : Type u_9\n\u03b5' : Type u_10\nf : Filter \u03b1\ng : Filter \u03b2\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b5' \u2192 \u03b5\nn' : \u03b2 \u2192 \u03b3 \u2192 \u03b5'\nh : Filter \u03b3\nh_assoc : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = m' a (n' b c)\n\u22a2 map\u2082 (fun a b => m (n a.1 a.2) b) (f \u00d7\u02e2 g) h = map\u2082 (fun a b => m' a (n' b.1 b.2)) f (g \u00d7\u02e2 h)"}, {"line": "rw [\u2190 map_prod_eq_map\u2082]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b5 : Type u_9\n\u03b5' : Type u_10\nf : Filter \u03b1\ng : Filter \u03b2\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b5' \u2192 \u03b5\nn' : \u03b2 \u2192 \u03b3 \u2192 \u03b5'\nh : Filter \u03b3\nh_assoc : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = m' a (n' b c)\n\u22a2 map (fun p => m (n p.1.1 p.1.2) p.2) ((f \u00d7\u02e2 g) \u00d7\u02e2 h) = map\u2082 (fun a b => m' a (n' b.1 b.2)) f (g \u00d7\u02e2 h)"}, {"line": "rw [\u2190 map_prod_eq_map\u2082]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b5 : Type u_9\n\u03b5' : Type u_10\nf : Filter \u03b1\ng : Filter \u03b2\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b5' \u2192 \u03b5\nn' : \u03b2 \u2192 \u03b3 \u2192 \u03b5'\nh : Filter \u03b3\nh_assoc : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = m' a (n' b c)\n\u22a2 map (fun p => m (n p.1.1 p.1.2) p.2) ((f \u00d7\u02e2 g) \u00d7\u02e2 h) = map (fun p => m' p.1 (n' p.2.1 p.2.2)) (f \u00d7\u02e2 g \u00d7\u02e2 h)"}, {"line": "rw [\u2190 prod_assoc]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b5 : Type u_9\n\u03b5' : Type u_10\nf : Filter \u03b1\ng : Filter \u03b2\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b5' \u2192 \u03b5\nn' : \u03b2 \u2192 \u03b3 \u2192 \u03b5'\nh : Filter \u03b3\nh_assoc : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = m' a (n' b c)\n\u22a2 map (fun p => m (n p.1.1 p.1.2) p.2) ((f \u00d7\u02e2 g) \u00d7\u02e2 h) =\n    map (fun p => m' p.1 (n' p.2.1 p.2.2)) (map (\u21d1(Equiv.prodAssoc \u03b1 \u03b2 \u03b3)) ((f \u00d7\u02e2 g) \u00d7\u02e2 h))"}, {"line": "rw [map_map]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b5 : Type u_9\n\u03b5' : Type u_10\nf : Filter \u03b1\ng : Filter \u03b2\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b5' \u2192 \u03b5\nn' : \u03b2 \u2192 \u03b3 \u2192 \u03b5'\nh : Filter \u03b3\nh_assoc : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = m' a (n' b c)\n\u22a2 map (fun p => m (n p.1.1 p.1.2) p.2) ((f \u00d7\u02e2 g) \u00d7\u02e2 h) =\n    map ((fun p => m' p.1 (n' p.2.1 p.2.2)) \u2218 \u21d1(Equiv.prodAssoc \u03b1 \u03b2 \u03b3)) ((f \u00d7\u02e2 g) \u00d7\u02e2 h)"}, {"line": "simp only [h_assoc]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b5 : Type u_9\n\u03b5' : Type u_10\nf : Filter \u03b1\ng : Filter \u03b2\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b5' \u2192 \u03b5\nn' : \u03b2 \u2192 \u03b3 \u2192 \u03b5'\nh : Filter \u03b3\nh_assoc : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = m' a (n' b c)\n\u22a2 map (fun p => m' p.1.1 (n' p.1.2 p.2)) ((f \u00d7\u02e2 g) \u00d7\u02e2 h) =\n    map ((fun p => m' p.1 (n' p.2.1 p.2.2)) \u2218 \u21d1(Equiv.prodAssoc \u03b1 \u03b2 \u03b3)) ((f \u00d7\u02e2 g) \u00d7\u02e2 h)"}, {"line": "simp only [Function.comp_def]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b5 : Type u_9\n\u03b5' : Type u_10\nf : Filter \u03b1\ng : Filter \u03b2\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b5' \u2192 \u03b5\nn' : \u03b2 \u2192 \u03b3 \u2192 \u03b5'\nh : Filter \u03b3\nh_assoc : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = m' a (n' b c)\n\u22a2 map (fun p => m' p.1.1 (n' p.1.2 p.2)) ((f \u00d7\u02e2 g) \u00d7\u02e2 h) =\n    map (fun x => m' ((Equiv.prodAssoc \u03b1 \u03b2 \u03b3) x).1 (n' ((Equiv.prodAssoc \u03b1 \u03b2 \u03b3) x).2.1 ((Equiv.prodAssoc \u03b1 \u03b2 \u03b3) x).2.2))\n      ((f \u00d7\u02e2 g) \u00d7\u02e2 h)"}, {"line": "simp only [Equiv.prodAssoc_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map\u2082_left_comm {m : \u03b1 \u2192 \u03b4 \u2192 \u03b5} {n : \u03b2 \u2192 \u03b3 \u2192 \u03b4} {m' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'} {n' : \u03b2 \u2192 \u03b4' \u2192 \u03b5}\n    (h_left_comm : \u2200 a b c, m a (n b c) = n' b (m' a c)) :\n    map\u2082 m f (map\u2082 n g h) = map\u2082 n' g (map\u2082 m' f h) := by\n  rw [map\u2082_swap m']\n  rw [map\u2082_swap m]\n  exact map\u2082_assoc fun _ _ _ => h_left_comm _ _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b1 \u2192 \u03b4 \u2192 \u03b5\nn : \u03b2 \u2192 \u03b3 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'\nn' : \u03b2 \u2192 \u03b4' \u2192 \u03b5\nh_left_comm : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m a (n b c) = n' b (m' a c)\n\u22a2 map\u2082 m f (map\u2082 n g h) = map\u2082 n' g (map\u2082 m' f h)"}, {"line": "rw [map\u2082_swap m']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b1 \u2192 \u03b4 \u2192 \u03b5\nn : \u03b2 \u2192 \u03b3 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'\nn' : \u03b2 \u2192 \u03b4' \u2192 \u03b5\nh_left_comm : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m a (n b c) = n' b (m' a c)\n\u22a2 map\u2082 m f (map\u2082 n g h) = map\u2082 n' g (map\u2082 (fun a b => m' b a) h f)"}, {"line": "rw [map\u2082_swap m]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b1 \u2192 \u03b4 \u2192 \u03b5\nn : \u03b2 \u2192 \u03b3 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'\nn' : \u03b2 \u2192 \u03b4' \u2192 \u03b5\nh_left_comm : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m a (n b c) = n' b (m' a c)\n\u22a2 map\u2082 (fun a b => m b a) (map\u2082 n g h) f = map\u2082 n' g (map\u2082 (fun a b => m' b a) h f)"}, {"line": "exact map\u2082_assoc fun _ _ _ => h_left_comm _ _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map\u2082_right_comm {m : \u03b4 \u2192 \u03b3 \u2192 \u03b5} {n : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {m' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'} {n' : \u03b4' \u2192 \u03b2 \u2192 \u03b5}\n    (h_right_comm : \u2200 a b c, m (n a b) c = n' (m' a c) b) :\n    map\u2082 m (map\u2082 n f g) h = map\u2082 n' (map\u2082 m' f h) g := by\n  rw [map\u2082_swap n]\n  rw [map\u2082_swap n']\n  exact map\u2082_assoc fun _ _ _ => h_right_comm _ _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'\nn' : \u03b4' \u2192 \u03b2 \u2192 \u03b5\nh_right_comm : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = n' (m' a c) b\n\u22a2 map\u2082 m (map\u2082 n f g) h = map\u2082 n' (map\u2082 m' f h) g"}, {"line": "rw [map\u2082_swap n]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'\nn' : \u03b4' \u2192 \u03b2 \u2192 \u03b5\nh_right_comm : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = n' (m' a c) b\n\u22a2 map\u2082 m (map\u2082 (fun a b => n b a) g f) h = map\u2082 n' (map\u2082 m' f h) g"}, {"line": "rw [map\u2082_swap n']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'\nn' : \u03b4' \u2192 \u03b2 \u2192 \u03b5\nh_right_comm : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = n' (m' a c) b\n\u22a2 map\u2082 m (map\u2082 (fun a b => n b a) g f) h = map\u2082 (fun a b => n' b a) g (map\u2082 m' f h)"}, {"line": "exact map\u2082_assoc fun _ _ _ => h_right_comm _ _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_map\u2082_distrib {n : \u03b3 \u2192 \u03b4} {m' : \u03b1' \u2192 \u03b2' \u2192 \u03b4} {n\u2081 : \u03b1 \u2192 \u03b1'} {n\u2082 : \u03b2 \u2192 \u03b2'}\n    (h_distrib : \u2200 a b, n (m a b) = m' (n\u2081 a) (n\u2082 b)) :\n    (map\u2082 m f g).map n = map\u2082 m' (f.map n\u2081) (g.map n\u2082) := by\n  simp_rw [map_map\u2082, map\u2082_map_left, map\u2082_map_right, h_distrib]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_7\nm : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf : Filter \u03b1\ng : Filter \u03b2\nn : \u03b3 \u2192 \u03b4\nm' : \u03b1' \u2192 \u03b2' \u2192 \u03b4\nn\u2081 : \u03b1 \u2192 \u03b1'\nn\u2082 : \u03b2 \u2192 \u03b2'\nh_distrib : \u2200 (a : \u03b1) (b : \u03b2), n (m a b) = m' (n\u2081 a) (n\u2082 b)\n\u22a2 map n (map\u2082 m f g) = map\u2082 m' (map n\u2081 f) (map n\u2082 g)"}, {"line": "simp_rw [map_map\u2082, map\u2082_map_left, map\u2082_map_right, h_distrib]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map\u2082_distrib_le_left {m : \u03b1 \u2192 \u03b4 \u2192 \u03b5} {n : \u03b2 \u2192 \u03b3 \u2192 \u03b4} {m\u2081 : \u03b1 \u2192 \u03b2 \u2192 \u03b2'} {m\u2082 : \u03b1 \u2192 \u03b3 \u2192 \u03b3'}\n    {n' : \u03b2' \u2192 \u03b3' \u2192 \u03b5} (h_distrib : \u2200 a b c, m a (n b c) = n' (m\u2081 a b) (m\u2082 a c)) :\n    map\u2082 m f (map\u2082 n g h) \u2264 map\u2082 n' (map\u2082 m\u2081 f g) (map\u2082 m\u2082 f h) := by\n  rintro s \u27e8t\u2081, \u27e8u\u2081, hu\u2081, v, hv, ht\u2081\u27e9, t\u2082, \u27e8u\u2082, hu\u2082, w, hw, ht\u2082\u27e9, hs\u27e9\n  refine \u27e8u\u2081 \u2229 u\u2082, inter_mem hu\u2081 hu\u2082, _, image2_mem_map\u2082 hv hw, ?_\u27e9\n  refine (image2_distrib_subset_left h_distrib).trans ((image2_subset ?_ ?_).trans hs)\n  \u00b7 exact (image2_subset_right inter_subset_left).trans ht\u2081\n  \u00b7 exact (image2_subset_right inter_subset_right).trans ht\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b1 \u2192 \u03b4 \u2192 \u03b5\nn : \u03b2 \u2192 \u03b3 \u2192 \u03b4\nm\u2081 : \u03b1 \u2192 \u03b2 \u2192 \u03b2'\nm\u2082 : \u03b1 \u2192 \u03b3 \u2192 \u03b3'\nn' : \u03b2' \u2192 \u03b3' \u2192 \u03b5\nh_distrib : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m a (n b c) = n' (m\u2081 a b) (m\u2082 a c)\n\u22a2 map\u2082 m f (map\u2082 n g h) \u2264 map\u2082 n' (map\u2082 m\u2081 f g) (map\u2082 m\u2082 f h)"}, {"line": "rintro s \u27e8t\u2081, \u27e8u\u2081, hu\u2081, v, hv, ht\u2081\u27e9, t\u2082, \u27e8u\u2082, hu\u2082, w, hw, ht\u2082\u27e9, hs\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b1 \u2192 \u03b4 \u2192 \u03b5\nn : \u03b2 \u2192 \u03b3 \u2192 \u03b4\nm\u2081 : \u03b1 \u2192 \u03b2 \u2192 \u03b2'\nm\u2082 : \u03b1 \u2192 \u03b3 \u2192 \u03b3'\nn' : \u03b2' \u2192 \u03b3' \u2192 \u03b5\nh_distrib : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m a (n b c) = n' (m\u2081 a b) (m\u2082 a c)\ns : Set \u03b5\nt\u2081 : Set \u03b2'\nu\u2081 : Set \u03b1\nhu\u2081 : u\u2081 \u2208 f\nv : Set \u03b2\nhv : v \u2208 g\nht\u2081 : image2 m\u2081 u\u2081 v \u2286 t\u2081\nt\u2082 : Set \u03b3'\nhs : image2 n' t\u2081 t\u2082 \u2286 s\nu\u2082 : Set \u03b1\nhu\u2082 : u\u2082 \u2208 f\nw : Set \u03b3\nhw : w \u2208 h\nht\u2082 : image2 m\u2082 u\u2082 w \u2286 t\u2082\n\u22a2 s \u2208 map\u2082 m f (map\u2082 n g h)"}, {"line": "refine \u27e8u\u2081 \u2229 u\u2082, inter_mem hu\u2081 hu\u2082, _, image2_mem_map\u2082 hv hw, ?_\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b1 \u2192 \u03b4 \u2192 \u03b5\nn : \u03b2 \u2192 \u03b3 \u2192 \u03b4\nm\u2081 : \u03b1 \u2192 \u03b2 \u2192 \u03b2'\nm\u2082 : \u03b1 \u2192 \u03b3 \u2192 \u03b3'\nn' : \u03b2' \u2192 \u03b3' \u2192 \u03b5\nh_distrib : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m a (n b c) = n' (m\u2081 a b) (m\u2082 a c)\ns : Set \u03b5\nt\u2081 : Set \u03b2'\nu\u2081 : Set \u03b1\nhu\u2081 : u\u2081 \u2208 f\nv : Set \u03b2\nhv : v \u2208 g\nht\u2081 : image2 m\u2081 u\u2081 v \u2286 t\u2081\nt\u2082 : Set \u03b3'\nhs : image2 n' t\u2081 t\u2082 \u2286 s\nu\u2082 : Set \u03b1\nhu\u2082 : u\u2082 \u2208 f\nw : Set \u03b3\nhw : w \u2208 h\nht\u2082 : image2 m\u2082 u\u2082 w \u2286 t\u2082\n\u22a2 image2 m (u\u2081 \u2229 u\u2082) (image2 n v w) \u2286 s"}, {"line": "refine (image2_distrib_subset_left h_distrib).trans ((image2_subset ?_ ?_).trans hs)", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b1 \u2192 \u03b4 \u2192 \u03b5\nn : \u03b2 \u2192 \u03b3 \u2192 \u03b4\nm\u2081 : \u03b1 \u2192 \u03b2 \u2192 \u03b2'\nm\u2082 : \u03b1 \u2192 \u03b3 \u2192 \u03b3'\nn' : \u03b2' \u2192 \u03b3' \u2192 \u03b5\nh_distrib : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m a (n b c) = n' (m\u2081 a b) (m\u2082 a c)\ns : Set \u03b5\nt\u2081 : Set \u03b2'\nu\u2081 : Set \u03b1\nhu\u2081 : u\u2081 \u2208 f\nv : Set \u03b2\nhv : v \u2208 g\nht\u2081 : image2 m\u2081 u\u2081 v \u2286 t\u2081\nt\u2082 : Set \u03b3'\nhs : image2 n' t\u2081 t\u2082 \u2286 s\nu\u2082 : Set \u03b1\nhu\u2082 : u\u2082 \u2208 f\nw : Set \u03b3\nhw : w \u2208 h\nht\u2082 : image2 m\u2082 u\u2082 w \u2286 t\u2082\n\u22a2 image2 m\u2081 (u\u2081 \u2229 u\u2082) v \u2286 t\u2081\n---\ncase intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b1 \u2192 \u03b4 \u2192 \u03b5\nn : \u03b2 \u2192 \u03b3 \u2192 \u03b4\nm\u2081 : \u03b1 \u2192 \u03b2 \u2192 \u03b2'\nm\u2082 : \u03b1 \u2192 \u03b3 \u2192 \u03b3'\nn' : \u03b2' \u2192 \u03b3' \u2192 \u03b5\nh_distrib : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m a (n b c) = n' (m\u2081 a b) (m\u2082 a c)\ns : Set \u03b5\nt\u2081 : Set \u03b2'\nu\u2081 : Set \u03b1\nhu\u2081 : u\u2081 \u2208 f\nv : Set \u03b2\nhv : v \u2208 g\nht\u2081 : image2 m\u2081 u\u2081 v \u2286 t\u2081\nt\u2082 : Set \u03b3'\nhs : image2 n' t\u2081 t\u2082 \u2286 s\nu\u2082 : Set \u03b1\nhu\u2082 : u\u2082 \u2208 f\nw : Set \u03b3\nhw : w \u2208 h\nht\u2082 : image2 m\u2082 u\u2082 w \u2286 t\u2082\n\u22a2 image2 m\u2082 (u\u2081 \u2229 u\u2082) w \u2286 t\u2082"}, {"line": "\u00b7 exact (image2_subset_right inter_subset_left).trans ht\u2081", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b1 \u2192 \u03b4 \u2192 \u03b5\nn : \u03b2 \u2192 \u03b3 \u2192 \u03b4\nm\u2081 : \u03b1 \u2192 \u03b2 \u2192 \u03b2'\nm\u2082 : \u03b1 \u2192 \u03b3 \u2192 \u03b3'\nn' : \u03b2' \u2192 \u03b3' \u2192 \u03b5\nh_distrib : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m a (n b c) = n' (m\u2081 a b) (m\u2082 a c)\ns : Set \u03b5\nt\u2081 : Set \u03b2'\nu\u2081 : Set \u03b1\nhu\u2081 : u\u2081 \u2208 f\nv : Set \u03b2\nhv : v \u2208 g\nht\u2081 : image2 m\u2081 u\u2081 v \u2286 t\u2081\nt\u2082 : Set \u03b3'\nhs : image2 n' t\u2081 t\u2082 \u2286 s\nu\u2082 : Set \u03b1\nhu\u2082 : u\u2082 \u2208 f\nw : Set \u03b3\nhw : w \u2208 h\nht\u2082 : image2 m\u2082 u\u2082 w \u2286 t\u2082\n\u22a2 image2 m\u2082 (u\u2081 \u2229 u\u2082) w \u2286 t\u2082"}, {"line": "\u00b7 exact (image2_subset_right inter_subset_right).trans ht\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map\u2082_distrib_le_right {m : \u03b4 \u2192 \u03b3 \u2192 \u03b5} {n : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {m\u2081 : \u03b1 \u2192 \u03b3 \u2192 \u03b1'} {m\u2082 : \u03b2 \u2192 \u03b3 \u2192 \u03b2'}\n    {n' : \u03b1' \u2192 \u03b2' \u2192 \u03b5} (h_distrib : \u2200 a b c, m (n a b) c = n' (m\u2081 a c) (m\u2082 b c)) :\n    map\u2082 m (map\u2082 n f g) h \u2264 map\u2082 n' (map\u2082 m\u2081 f h) (map\u2082 m\u2082 g h) := by\n  rintro s \u27e8t\u2081, \u27e8u, hu, w\u2081, hw\u2081, ht\u2081\u27e9, t\u2082, \u27e8v, hv, w\u2082, hw\u2082, ht\u2082\u27e9, hs\u27e9\n  refine \u27e8_, image2_mem_map\u2082 hu hv, w\u2081 \u2229 w\u2082, inter_mem hw\u2081 hw\u2082, ?_\u27e9\n  refine (image2_distrib_subset_right h_distrib).trans ((image2_subset ?_ ?_).trans hs)\n  \u00b7 exact (image2_subset_left inter_subset_left).trans ht\u2081\n  \u00b7 exact (image2_subset_left inter_subset_right).trans ht\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm\u2081 : \u03b1 \u2192 \u03b3 \u2192 \u03b1'\nm\u2082 : \u03b2 \u2192 \u03b3 \u2192 \u03b2'\nn' : \u03b1' \u2192 \u03b2' \u2192 \u03b5\nh_distrib : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = n' (m\u2081 a c) (m\u2082 b c)\n\u22a2 map\u2082 m (map\u2082 n f g) h \u2264 map\u2082 n' (map\u2082 m\u2081 f h) (map\u2082 m\u2082 g h)"}, {"line": "rintro s \u27e8t\u2081, \u27e8u, hu, w\u2081, hw\u2081, ht\u2081\u27e9, t\u2082, \u27e8v, hv, w\u2082, hw\u2082, ht\u2082\u27e9, hs\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm\u2081 : \u03b1 \u2192 \u03b3 \u2192 \u03b1'\nm\u2082 : \u03b2 \u2192 \u03b3 \u2192 \u03b2'\nn' : \u03b1' \u2192 \u03b2' \u2192 \u03b5\nh_distrib : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = n' (m\u2081 a c) (m\u2082 b c)\ns : Set \u03b5\nt\u2081 : Set \u03b1'\nu : Set \u03b1\nhu : u \u2208 f\nw\u2081 : Set \u03b3\nhw\u2081 : w\u2081 \u2208 h\nht\u2081 : image2 m\u2081 u w\u2081 \u2286 t\u2081\nt\u2082 : Set \u03b2'\nhs : image2 n' t\u2081 t\u2082 \u2286 s\nv : Set \u03b2\nhv : v \u2208 g\nw\u2082 : Set \u03b3\nhw\u2082 : w\u2082 \u2208 h\nht\u2082 : image2 m\u2082 v w\u2082 \u2286 t\u2082\n\u22a2 s \u2208 map\u2082 m (map\u2082 n f g) h"}, {"line": "refine \u27e8_, image2_mem_map\u2082 hu hv, w\u2081 \u2229 w\u2082, inter_mem hw\u2081 hw\u2082, ?_\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm\u2081 : \u03b1 \u2192 \u03b3 \u2192 \u03b1'\nm\u2082 : \u03b2 \u2192 \u03b3 \u2192 \u03b2'\nn' : \u03b1' \u2192 \u03b2' \u2192 \u03b5\nh_distrib : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = n' (m\u2081 a c) (m\u2082 b c)\ns : Set \u03b5\nt\u2081 : Set \u03b1'\nu : Set \u03b1\nhu : u \u2208 f\nw\u2081 : Set \u03b3\nhw\u2081 : w\u2081 \u2208 h\nht\u2081 : image2 m\u2081 u w\u2081 \u2286 t\u2081\nt\u2082 : Set \u03b2'\nhs : image2 n' t\u2081 t\u2082 \u2286 s\nv : Set \u03b2\nhv : v \u2208 g\nw\u2082 : Set \u03b3\nhw\u2082 : w\u2082 \u2208 h\nht\u2082 : image2 m\u2082 v w\u2082 \u2286 t\u2082\n\u22a2 image2 m (image2 n u v) (w\u2081 \u2229 w\u2082) \u2286 s"}, {"line": "refine (image2_distrib_subset_right h_distrib).trans ((image2_subset ?_ ?_).trans hs)", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.refine_1\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm\u2081 : \u03b1 \u2192 \u03b3 \u2192 \u03b1'\nm\u2082 : \u03b2 \u2192 \u03b3 \u2192 \u03b2'\nn' : \u03b1' \u2192 \u03b2' \u2192 \u03b5\nh_distrib : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = n' (m\u2081 a c) (m\u2082 b c)\ns : Set \u03b5\nt\u2081 : Set \u03b1'\nu : Set \u03b1\nhu : u \u2208 f\nw\u2081 : Set \u03b3\nhw\u2081 : w\u2081 \u2208 h\nht\u2081 : image2 m\u2081 u w\u2081 \u2286 t\u2081\nt\u2082 : Set \u03b2'\nhs : image2 n' t\u2081 t\u2082 \u2286 s\nv : Set \u03b2\nhv : v \u2208 g\nw\u2082 : Set \u03b3\nhw\u2082 : w\u2082 \u2208 h\nht\u2082 : image2 m\u2082 v w\u2082 \u2286 t\u2082\n\u22a2 image2 m\u2081 u (w\u2081 \u2229 w\u2082) \u2286 t\u2081\n---\ncase intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.refine_2\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm\u2081 : \u03b1 \u2192 \u03b3 \u2192 \u03b1'\nm\u2082 : \u03b2 \u2192 \u03b3 \u2192 \u03b2'\nn' : \u03b1' \u2192 \u03b2' \u2192 \u03b5\nh_distrib : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = n' (m\u2081 a c) (m\u2082 b c)\ns : Set \u03b5\nt\u2081 : Set \u03b1'\nu : Set \u03b1\nhu : u \u2208 f\nw\u2081 : Set \u03b3\nhw\u2081 : w\u2081 \u2208 h\nht\u2081 : image2 m\u2081 u w\u2081 \u2286 t\u2081\nt\u2082 : Set \u03b2'\nhs : image2 n' t\u2081 t\u2082 \u2286 s\nv : Set \u03b2\nhv : v \u2208 g\nw\u2082 : Set \u03b3\nhw\u2082 : w\u2082 \u2208 h\nht\u2082 : image2 m\u2082 v w\u2082 \u2286 t\u2082\n\u22a2 image2 m\u2082 v (w\u2081 \u2229 w\u2082) \u2286 t\u2082"}, {"line": "\u00b7 exact (image2_subset_left inter_subset_left).trans ht\u2081", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.refine_2\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_7\n\u03b5 : Type u_9\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm\u2081 : \u03b1 \u2192 \u03b3 \u2192 \u03b1'\nm\u2082 : \u03b2 \u2192 \u03b3 \u2192 \u03b2'\nn' : \u03b1' \u2192 \u03b2' \u2192 \u03b5\nh_distrib : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = n' (m\u2081 a c) (m\u2082 b c)\ns : Set \u03b5\nt\u2081 : Set \u03b1'\nu : Set \u03b1\nhu : u \u2208 f\nw\u2081 : Set \u03b3\nhw\u2081 : w\u2081 \u2208 h\nht\u2081 : image2 m\u2081 u w\u2081 \u2286 t\u2081\nt\u2082 : Set \u03b2'\nhs : image2 n' t\u2081 t\u2082 \u2286 s\nv : Set \u03b2\nhv : v \u2208 g\nw\u2082 : Set \u03b3\nhw\u2082 : w\u2082 \u2208 h\nht\u2082 : image2 m\u2082 v w\u2082 \u2286 t\u2082\n\u22a2 image2 m\u2082 v (w\u2081 \u2229 w\u2082) \u2286 t\u2082"}, {"line": "\u00b7 exact (image2_subset_left inter_subset_right).trans ht\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_map\u2082_antidistrib {n : \u03b3 \u2192 \u03b4} {m' : \u03b2' \u2192 \u03b1' \u2192 \u03b4} {n\u2081 : \u03b2 \u2192 \u03b2'} {n\u2082 : \u03b1 \u2192 \u03b1'}\n    (h_antidistrib : \u2200 a b, n (m a b) = m' (n\u2081 b) (n\u2082 a)) :\n    (map\u2082 m f g).map n = map\u2082 m' (g.map n\u2081) (f.map n\u2082) := by\n  rw [map\u2082_swap m]\n  exact map_map\u2082_distrib fun _ _ => h_antidistrib _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_7\nm : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf : Filter \u03b1\ng : Filter \u03b2\nn : \u03b3 \u2192 \u03b4\nm' : \u03b2' \u2192 \u03b1' \u2192 \u03b4\nn\u2081 : \u03b2 \u2192 \u03b2'\nn\u2082 : \u03b1 \u2192 \u03b1'\nh_antidistrib : \u2200 (a : \u03b1) (b : \u03b2), n (m a b) = m' (n\u2081 b) (n\u2082 a)\n\u22a2 map n (map\u2082 m f g) = map\u2082 m' (map n\u2081 g) (map n\u2082 f)"}, {"line": "rw [map\u2082_swap m]", "tactic_state": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_7\nm : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf : Filter \u03b1\ng : Filter \u03b2\nn : \u03b3 \u2192 \u03b4\nm' : \u03b2' \u2192 \u03b1' \u2192 \u03b4\nn\u2081 : \u03b2 \u2192 \u03b2'\nn\u2082 : \u03b1 \u2192 \u03b1'\nh_antidistrib : \u2200 (a : \u03b1) (b : \u03b2), n (m a b) = m' (n\u2081 b) (n\u2082 a)\n\u22a2 map n (map\u2082 (fun a b => m b a) g f) = map\u2082 m' (map n\u2081 g) (map n\u2082 f)"}, {"line": "exact map_map\u2082_distrib fun _ _ => h_antidistrib _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map\u2082_left_identity {f : \u03b1 \u2192 \u03b2 \u2192 \u03b2} {a : \u03b1} (h : \u2200 b, f a b = b) (l : Filter \u03b2) :\n    map\u2082 f (pure a) l = l := by rw [map\u2082_pure_left, show f a = id from funext h, map_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\na : \u03b1\nh : \u2200 (b : \u03b2), f a b = b\nl : Filter \u03b2\n\u22a2 map\u2082 f (pure a) l = l"}, {"line": "rw [map\u2082_pure_left, show f a = id from funext h, map_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map\u2082_right_identity {f : \u03b1 \u2192 \u03b2 \u2192 \u03b1} {b : \u03b2} (h : \u2200 a, f a b = a) (l : Filter \u03b1) :\n    map\u2082 f l (pure b) = l := by rw [map\u2082_pure_right, funext h, map_id']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/NAry.lean", "context": {"open": ["Function Set", "Filter"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' : Type*} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {f f\u2081 f\u2082 : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b1\nb : \u03b2\nh : \u2200 (a : \u03b1), f a b = a\nl : Filter \u03b1\n\u22a2 map\u2082 f l (pure b) = l"}, {"line": "rw [map\u2082_pure_right, funext h, map_id']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rtendsto_iff_le_rcomap (r : Rel \u03b1 \u03b2) (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) :\n    RTendsto r l\u2081 l\u2082 \u2194 l\u2081 \u2264 l\u2082.rcomap r := by\n  rw [rtendsto_def]\n  simp_rw [\u2190 l\u2082.mem_sets]\n  constructor\n  \u00b7 simpa [Filter.le_def, rcomap, Rel.mem_image] using fun h s t tl\u2082 => mem_of_superset (h t tl\u2082)\n  \u00b7 simpa [Filter.le_def, rcomap, Rel.mem_image] using fun h t tl\u2082 => h _ t tl\u2082 Set.Subset.rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Partial.lean", "context": {"open": ["Filter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : Rel \u03b1 \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\n\u22a2 RTendsto r l\u2081 l\u2082 \u2194 l\u2081 \u2264 rcomap r l\u2082"}, {"line": "rw [rtendsto_def]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : Rel \u03b1 \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\n\u22a2 (\u2200 s \u2208 l\u2082, r.core s \u2208 l\u2081) \u2194 l\u2081 \u2264 rcomap r l\u2082"}, {"line": "simp_rw [\u2190 l\u2082.mem_sets]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : Rel \u03b1 \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\n\u22a2 (\u2200 s \u2208 l\u2082.sets, r.core s \u2208 l\u2081) \u2194 l\u2081 \u2264 rcomap r l\u2082"}, {"line": "constructor", "tactic_state": "case mp\n\u03b1 : Type u\n\u03b2 : Type v\nr : Rel \u03b1 \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\n\u22a2 (\u2200 s \u2208 l\u2082.sets, r.core s \u2208 l\u2081) \u2192 l\u2081 \u2264 rcomap r l\u2082\n---\ncase mpr\n\u03b1 : Type u\n\u03b2 : Type v\nr : Rel \u03b1 \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\n\u22a2 l\u2081 \u2264 rcomap r l\u2082 \u2192 \u2200 s \u2208 l\u2082.sets, r.core s \u2208 l\u2081"}, {"line": "\u00b7 simpa [Filter.le_def, rcomap, Rel.mem_image] using fun h s t tl\u2082 => mem_of_superset (h t tl\u2082)", "tactic_state": "case mpr\n\u03b1 : Type u\n\u03b2 : Type v\nr : Rel \u03b1 \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\n\u22a2 l\u2081 \u2264 rcomap r l\u2082 \u2192 \u2200 s \u2208 l\u2082.sets, r.core s \u2208 l\u2081"}, {"line": "\u00b7 simpa [Filter.le_def, rcomap, Rel.mem_image] using fun h t tl\u2082 => h _ t tl\u2082 Set.Subset.rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_iff_rtendsto (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) (f : \u03b1 \u2192 \u03b2) :\n    Tendsto f l\u2081 l\u2082 \u2194 RTendsto (Function.graph f) l\u2081 l\u2082 := by\n  simp [tendsto_def, Function.graph, rtendsto_def, Rel.core, Set.preimage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Partial.lean", "context": {"open": ["Filter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Tendsto f l\u2081 l\u2082 \u2194 RTendsto (Function.graph f) l\u2081 l\u2082"}, {"line": "simp [tendsto_def, Function.graph, rtendsto_def, Rel.core, Set.preimage]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_iff_rtendsto' (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) (f : \u03b1 \u2192 \u03b2) :\n    Tendsto f l\u2081 l\u2082 \u2194 RTendsto' (Function.graph f) l\u2081 l\u2082 := by\n  simp [tendsto_def, Function.graph, rtendsto'_def, Rel.preimage_def, Set.preimage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Partial.lean", "context": {"open": ["Filter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Tendsto f l\u2081 l\u2082 \u2194 RTendsto' (Function.graph f) l\u2081 l\u2082"}, {"line": "simp [tendsto_def, Function.graph, rtendsto'_def, Rel.preimage_def, Set.preimage]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_iff_ptendsto (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) (s : Set \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    Tendsto f (l\u2081 \u2293 \ud835\udcdf s) l\u2082 \u2194 PTendsto (PFun.res f s) l\u2081 l\u2082 := by\n  simp only [Tendsto]\n  simp only [PTendsto]\n  simp only [pmap_res]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Partial.lean", "context": {"open": ["Filter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 Tendsto f (l\u2081 \u2293 principal s) l\u2082 \u2194 PTendsto (PFun.res f s) l\u2081 l\u2082"}, {"line": "simp only [Tendsto]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 map f (l\u2081 \u2293 principal s) \u2264 l\u2082 \u2194 PTendsto (PFun.res f s) l\u2081 l\u2082"}, {"line": "simp only [PTendsto]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 map f (l\u2081 \u2293 principal s) \u2264 l\u2082 \u2194 pmap (PFun.res f s) l\u2081 \u2264 l\u2082"}, {"line": "simp only [pmap_res]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_iff_ptendsto_univ (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) (f : \u03b1 \u2192 \u03b2) :\n    Tendsto f l\u2081 l\u2082 \u2194 PTendsto (PFun.res f Set.univ) l\u2081 l\u2082 := by\n  rw [\u2190 tendsto_iff_ptendsto]\n  simp [principal_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Partial.lean", "context": {"open": ["Filter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Tendsto f l\u2081 l\u2082 \u2194 PTendsto (PFun.res f Set.univ) l\u2081 l\u2082"}, {"line": "rw [\u2190 tendsto_iff_ptendsto]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Tendsto f l\u2081 l\u2082 \u2194 Tendsto f (l\u2081 \u2293 principal Set.univ) l\u2082"}, {"line": "simp [principal_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ptendsto_of_ptendsto' {f : \u03b1 \u2192. \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} :\n    PTendsto' f l\u2081 l\u2082 \u2192 PTendsto f l\u2081 l\u2082 := by\n  rw [ptendsto_def]\n  rw [ptendsto'_def]\n  exact fun h s sl\u2082 => mem_of_superset (h s sl\u2082) (PFun.preimage_subset_core _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Partial.lean", "context": {"open": ["Filter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192. \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\n\u22a2 PTendsto' f l\u2081 l\u2082 \u2192 PTendsto f l\u2081 l\u2082"}, {"line": "rw [ptendsto_def]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192. \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\n\u22a2 PTendsto' f l\u2081 l\u2082 \u2192 \u2200 s \u2208 l\u2082, f.core s \u2208 l\u2081"}, {"line": "rw [ptendsto'_def]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192. \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\n\u22a2 (\u2200 s \u2208 l\u2082, f.preimage s \u2208 l\u2081) \u2192 \u2200 s \u2208 l\u2082, f.core s \u2208 l\u2081"}, {"line": "exact fun h s sl\u2082 => mem_of_superset (h s sl\u2082) (PFun.preimage_subset_core _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ptendsto'_of_ptendsto {f : \u03b1 \u2192. \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} (h : f.Dom \u2208 l\u2081) :\n    PTendsto f l\u2081 l\u2082 \u2192 PTendsto' f l\u2081 l\u2082 := by\n  rw [ptendsto_def]\n  rw [ptendsto'_def]\n  intro h' s sl\u2082\n  rw [PFun.preimage_eq]\n  exact inter_mem (h' s sl\u2082) h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Partial.lean", "context": {"open": ["Filter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192. \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nh : f.Dom \u2208 l\u2081\n\u22a2 PTendsto f l\u2081 l\u2082 \u2192 PTendsto' f l\u2081 l\u2082"}, {"line": "rw [ptendsto_def]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192. \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nh : f.Dom \u2208 l\u2081\n\u22a2 (\u2200 s \u2208 l\u2082, f.core s \u2208 l\u2081) \u2192 PTendsto' f l\u2081 l\u2082"}, {"line": "rw [ptendsto'_def]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192. \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nh : f.Dom \u2208 l\u2081\n\u22a2 (\u2200 s \u2208 l\u2082, f.core s \u2208 l\u2081) \u2192 \u2200 s \u2208 l\u2082, f.preimage s \u2208 l\u2081"}, {"line": "intro h' s sl\u2082", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192. \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nh : f.Dom \u2208 l\u2081\nh' : \u2200 s \u2208 l\u2082, f.core s \u2208 l\u2081\ns : Set \u03b2\nsl\u2082 : s \u2208 l\u2082\n\u22a2 f.preimage s \u2208 l\u2081"}, {"line": "rw [PFun.preimage_eq]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192. \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nh : f.Dom \u2208 l\u2081\nh' : \u2200 s \u2208 l\u2082, f.core s \u2208 l\u2081\ns : Set \u03b2\nsl\u2082 : s \u2208 l\u2082\n\u22a2 f.core s \u2229 f.Dom \u2208 l\u2081"}, {"line": "exact inter_mem (h' s sl\u2082) h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_diagonal_mem_prod {l\u2081 l\u2082 : Filter \u03b1} : (diagonal \u03b1)\u1d9c \u2208 l\u2081 \u00d7\u02e2 l\u2082 \u2194 Disjoint l\u2081 l\u2082 := by\n  simp only [mem_prod_iff]\n  simp only [Filter.disjoint_iff]\n  simp only [prod_subset_compl_diagonal_iff_disjoint]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl\u2081 l\u2082 : Filter \u03b1\n\u22a2 (diagonal \u03b1)\u1d9c \u2208 l\u2081 \u00d7\u02e2 l\u2082 \u2194 Disjoint l\u2081 l\u2082"}, {"line": "simp only [mem_prod_iff]", "tactic_state": "\u03b1 : Type u_1\nl\u2081 l\u2082 : Filter \u03b1\n\u22a2 (\u2203 t\u2081 \u2208 l\u2081, \u2203 t\u2082 \u2208 l\u2082, t\u2081 \u00d7\u02e2 t\u2082 \u2286 (diagonal \u03b1)\u1d9c) \u2194 Disjoint l\u2081 l\u2082"}, {"line": "simp only [Filter.disjoint_iff]", "tactic_state": "\u03b1 : Type u_1\nl\u2081 l\u2082 : Filter \u03b1\n\u22a2 (\u2203 t\u2081 \u2208 l\u2081, \u2203 t\u2082 \u2208 l\u2082, t\u2081 \u00d7\u02e2 t\u2082 \u2286 (diagonal \u03b1)\u1d9c) \u2194 \u2203 s \u2208 l\u2081, \u2203 t \u2208 l\u2082, Disjoint s t"}, {"line": "simp only [prod_subset_compl_diagonal_iff_disjoint]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_prod_top {s : Set (\u03b1 \u00d7 \u03b2)} :\n    s \u2208 f \u00d7\u02e2 (\u22a4 : Filter \u03b2) \u2194 { a | \u2200 b, (a, b) \u2208 s } \u2208 f := by\n  rw [\u2190 principal_univ]\n  rw [mem_prod_principal]\n  simp only [mem_univ]\n  simp only [forall_true_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ns : Set (\u03b1 \u00d7 \u03b2)\n\u22a2 s \u2208 f \u00d7\u02e2 \u22a4 \u2194 {a | \u2200 (b : \u03b2), (a, b) \u2208 s} \u2208 f"}, {"line": "rw [\u2190 principal_univ]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ns : Set (\u03b1 \u00d7 \u03b2)\n\u22a2 s \u2208 f \u00d7\u02e2 principal univ \u2194 {a | \u2200 (b : \u03b2), (a, b) \u2208 s} \u2208 f"}, {"line": "rw [mem_prod_principal]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ns : Set (\u03b1 \u00d7 \u03b2)\n\u22a2 {a | \u2200 b \u2208 univ, (a, b) \u2208 s} \u2208 f \u2194 {a | \u2200 (b : \u03b2), (a, b) \u2208 s} \u2208 f"}, {"line": "simp only [mem_univ]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ns : Set (\u03b1 \u00d7 \u03b2)\n\u22a2 {a | \u2200 (b : \u03b2), True \u2192 (a, b) \u2208 s} \u2208 f \u2194 {a | \u2200 (b : \u03b2), (a, b) \u2208 s} \u2208 f"}, {"line": "simp only [forall_true_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_prod_principal_iff {p : \u03b1 \u00d7 \u03b2 \u2192 Prop} {s : Set \u03b2} :\n    (\u2200\u1da0 x : \u03b1 \u00d7 \u03b2 in f \u00d7\u02e2 \ud835\udcdf s, p x) \u2194 \u2200\u1da0 x : \u03b1 in f, \u2200 y : \u03b2, y \u2208 s \u2192 p (x, y) := by\n  rw [eventually_iff]\n  rw [eventually_iff]\n  rw [mem_prod_principal]\n  simp only [mem_setOf_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\np : \u03b1 \u00d7 \u03b2 \u2192 Prop\ns : Set \u03b2\n\u22a2 (\u2200\u1da0 (x : \u03b1 \u00d7 \u03b2) in f \u00d7\u02e2 principal s, p x) \u2194 \u2200\u1da0 (x : \u03b1) in f, \u2200 y \u2208 s, p (x, y)"}, {"line": "rw [eventually_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\np : \u03b1 \u00d7 \u03b2 \u2192 Prop\ns : Set \u03b2\n\u22a2 {x | p x} \u2208 f \u00d7\u02e2 principal s \u2194 \u2200\u1da0 (x : \u03b1) in f, \u2200 y \u2208 s, p (x, y)"}, {"line": "rw [eventually_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\np : \u03b1 \u00d7 \u03b2 \u2192 Prop\ns : Set \u03b2\n\u22a2 {x | p x} \u2208 f \u00d7\u02e2 principal s \u2194 {x | \u2200 y \u2208 s, p (x, y)} \u2208 f"}, {"line": "rw [mem_prod_principal]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\np : \u03b1 \u00d7 \u03b2 \u2192 Prop\ns : Set \u03b2\n\u22a2 {a | \u2200 b \u2208 s, (a, b) \u2208 {x | p x}} \u2208 f \u2194 {x | \u2200 y \u2208 s, p (x, y)} \u2208 f"}, {"line": "simp only [mem_setOf_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_prod (f : \u03b1 \u2192 \u03b2 \u00d7 \u03b3) (b : Filter \u03b2) (c : Filter \u03b3) :\n    comap f (b \u00d7\u02e2 c) = comap (Prod.fst \u2218 f) b \u2293 comap (Prod.snd \u2218 f) c := by\n  rw [prod_eq_inf]\n  rw [comap_inf]\n  rw [Filter.comap_comap]\n  rw [Filter.comap_comap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\nb : Filter \u03b2\nc : Filter \u03b3\n\u22a2 comap f (b \u00d7\u02e2 c) = comap (Prod.fst \u2218 f) b \u2293 comap (Prod.snd \u2218 f) c"}, {"line": "rw [prod_eq_inf]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\nb : Filter \u03b2\nc : Filter \u03b3\n\u22a2 comap f (comap Prod.fst b \u2293 comap Prod.snd c) = comap (Prod.fst \u2218 f) b \u2293 comap (Prod.snd \u2218 f) c"}, {"line": "rw [comap_inf]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\nb : Filter \u03b2\nc : Filter \u03b3\n\u22a2 comap f (comap Prod.fst b) \u2293 comap f (comap Prod.snd c) = comap (Prod.fst \u2218 f) b \u2293 comap (Prod.snd \u2218 f) c"}, {"line": "rw [Filter.comap_comap]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\nb : Filter \u03b2\nc : Filter \u03b3\n\u22a2 comap (Prod.fst \u2218 f) b \u2293 comap f (comap Prod.snd c) = comap (Prod.fst \u2218 f) b \u2293 comap (Prod.snd \u2218 f) c"}, {"line": "rw [Filter.comap_comap]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_prodMap_prod (f : \u03b1 \u2192 \u03b2) (g : \u03b3 \u2192 \u03b4) (lb : Filter \u03b2) (ld : Filter \u03b4) :\n    comap (Prod.map f g) (lb \u00d7\u02e2 ld) = comap f lb \u00d7\u02e2 comap g ld := by\n  simp [prod_eq_inf, comap_comap, Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b3 \u2192 \u03b4\nlb : Filter \u03b2\nld : Filter \u03b4\n\u22a2 comap (Prod.map f g) (lb \u00d7\u02e2 ld) = comap f lb \u00d7\u02e2 comap g ld"}, {"line": "simp [prod_eq_inf, comap_comap, Function.comp_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_top : f \u00d7\u02e2 (\u22a4 : Filter \u03b2) = f.comap Prod.fst := by\n  rw [prod_eq_inf]\n  rw [comap_top]\n  rw [inf_top_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\n\u22a2 f \u00d7\u02e2 \u22a4 = comap Prod.fst f"}, {"line": "rw [prod_eq_inf]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\n\u22a2 comap Prod.fst f \u2293 comap Prod.snd \u22a4 = comap Prod.fst f"}, {"line": "rw [comap_top]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\n\u22a2 comap Prod.fst f \u2293 \u22a4 = comap Prod.fst f"}, {"line": "rw [inf_top_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem top_prod : (\u22a4 : Filter \u03b1) \u00d7\u02e2 g = g.comap Prod.snd := by\n  rw [prod_eq_inf]\n  rw [comap_top]\n  rw [top_inf_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : Filter \u03b2\n\u22a2 \u22a4 \u00d7\u02e2 g = comap Prod.snd g"}, {"line": "rw [prod_eq_inf]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : Filter \u03b2\n\u22a2 comap Prod.fst \u22a4 \u2293 comap Prod.snd g = comap Prod.snd g"}, {"line": "rw [comap_top]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : Filter \u03b2\n\u22a2 \u22a4 \u2293 comap Prod.snd g = comap Prod.snd g"}, {"line": "rw [top_inf_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_prod (f\u2081 f\u2082 : Filter \u03b1) (g : Filter \u03b2) : (f\u2081 \u2294 f\u2082) \u00d7\u02e2 g = (f\u2081 \u00d7\u02e2 g) \u2294 (f\u2082 \u00d7\u02e2 g) := by\n  simp only [prod_eq_inf]\n  simp only [comap_sup]\n  simp only [inf_sup_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf\u2081 f\u2082 : Filter \u03b1\ng : Filter \u03b2\n\u22a2 (f\u2081 \u2294 f\u2082) \u00d7\u02e2 g = f\u2081 \u00d7\u02e2 g \u2294 f\u2082 \u00d7\u02e2 g"}, {"line": "simp only [prod_eq_inf]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf\u2081 f\u2082 : Filter \u03b1\ng : Filter \u03b2\n\u22a2 comap Prod.fst (f\u2081 \u2294 f\u2082) \u2293 comap Prod.snd g =\n    comap Prod.fst f\u2081 \u2293 comap Prod.snd g \u2294 comap Prod.fst f\u2082 \u2293 comap Prod.snd g"}, {"line": "simp only [comap_sup]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf\u2081 f\u2082 : Filter \u03b1\ng : Filter \u03b2\n\u22a2 (comap Prod.fst f\u2081 \u2294 comap Prod.fst f\u2082) \u2293 comap Prod.snd g =\n    comap Prod.fst f\u2081 \u2293 comap Prod.snd g \u2294 comap Prod.fst f\u2082 \u2293 comap Prod.snd g"}, {"line": "simp only [inf_sup_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_sup (f : Filter \u03b1) (g\u2081 g\u2082 : Filter \u03b2) : f \u00d7\u02e2 (g\u2081 \u2294 g\u2082) = (f \u00d7\u02e2 g\u2081) \u2294 (f \u00d7\u02e2 g\u2082) := by\n  simp only [prod_eq_inf]\n  simp only [comap_sup]\n  simp only [inf_sup_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng\u2081 g\u2082 : Filter \u03b2\n\u22a2 f \u00d7\u02e2 (g\u2081 \u2294 g\u2082) = f \u00d7\u02e2 g\u2081 \u2294 f \u00d7\u02e2 g\u2082"}, {"line": "simp only [prod_eq_inf]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng\u2081 g\u2082 : Filter \u03b2\n\u22a2 comap Prod.fst f \u2293 comap Prod.snd (g\u2081 \u2294 g\u2082) =\n    comap Prod.fst f \u2293 comap Prod.snd g\u2081 \u2294 comap Prod.fst f \u2293 comap Prod.snd g\u2082"}, {"line": "simp only [comap_sup]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng\u2081 g\u2082 : Filter \u03b2\n\u22a2 comap Prod.fst f \u2293 (comap Prod.snd g\u2081 \u2294 comap Prod.snd g\u2082) =\n    comap Prod.fst f \u2293 comap Prod.snd g\u2081 \u2294 comap Prod.fst f \u2293 comap Prod.snd g\u2082"}, {"line": "simp only [inf_sup_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_prod_iff {p : \u03b1 \u00d7 \u03b2 \u2192 Prop} :\n    (\u2200\u1da0 x in f \u00d7\u02e2 g, p x) \u2194\n      \u2203 pa : \u03b1 \u2192 Prop, (\u2200\u1da0 x in f, pa x) \u2227 \u2203 pb : \u03b2 \u2192 Prop, (\u2200\u1da0 y in g, pb y) \u2227\n        \u2200 {x}, pa x \u2192 \u2200 {y}, pb y \u2192 p (x, y) := by\n  simpa only [Set.prod_subset_iff] using @mem_prod_iff \u03b1 \u03b2 p f g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : \u03b1 \u00d7 \u03b2) in f \u00d7\u02e2 g, p x) \u2194\n    \u2203 pa, (\u2200\u1da0 (x : \u03b1) in f, pa x) \u2227 \u2203 pb, (\u2200\u1da0 (y : \u03b2) in g, pb y) \u2227 \u2200 {x : \u03b1}, pa x \u2192 \u2200 {y : \u03b2}, pb y \u2192 p (x, y)"}, {"line": "simpa only [Set.prod_subset_iff] using @mem_prod_iff \u03b1 \u03b2 p f g", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Eventually.curry {la : Filter \u03b1} {lb : Filter \u03b2} {p : \u03b1 \u00d7 \u03b2 \u2192 Prop}\n    (h : \u2200\u1da0 x in la \u00d7\u02e2 lb, p x) : \u2200\u1da0 x in la, \u2200\u1da0 y in lb, p (x, y) := by\n  rcases eventually_prod_iff.1 h with \u27e8pa, ha, pb, hb, h\u27e9\n  exact ha.mono fun a ha => hb.mono fun b hb => h ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nla : Filter \u03b1\nlb : Filter \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Prop\nh : \u2200\u1da0 (x : \u03b1 \u00d7 \u03b2) in la \u00d7\u02e2 lb, p x\n\u22a2 \u2200\u1da0 (x : \u03b1) in la, \u2200\u1da0 (y : \u03b2) in lb, p (x, y)"}, {"line": "rcases eventually_prod_iff.1 h with \u27e8pa, ha, pb, hb, h\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nla : Filter \u03b1\nlb : Filter \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Prop\nh\u271d : \u2200\u1da0 (x : \u03b1 \u00d7 \u03b2) in la \u00d7\u02e2 lb, p x\npa : \u03b1 \u2192 Prop\nha : \u2200\u1da0 (x : \u03b1) in la, pa x\npb : \u03b2 \u2192 Prop\nhb : \u2200\u1da0 (y : \u03b2) in lb, pb y\nh : \u2200 {x : \u03b1}, pa x \u2192 \u2200 {y : \u03b2}, pb y \u2192 p (x, y)\n\u22a2 \u2200\u1da0 (x : \u03b1) in la, \u2200\u1da0 (y : \u03b2) in lb, p (x, y)"}, {"line": "exact ha.mono fun a ha => hb.mono fun b hb => h ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Eventually.diag_of_prod {p : \u03b1 \u00d7 \u03b1 \u2192 Prop} (h : \u2200\u1da0 i in f \u00d7\u02e2 f, p i) :\n    \u2200\u1da0 i in f, p (i, i) := by\n  obtain \u27e8t, ht, s, hs, hst\u27e9 := eventually_prod_iff.1 h\n  apply (ht.and hs).mono fun x hx => hst hx.1 hx.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\np : \u03b1 \u00d7 \u03b1 \u2192 Prop\nh : \u2200\u1da0 (i : \u03b1 \u00d7 \u03b1) in f \u00d7\u02e2 f, p i\n\u22a2 \u2200\u1da0 (i : \u03b1) in f, p (i, i)"}, {"line": "obtain \u27e8t, ht, s, hs, hst\u27e9 := eventually_prod_iff.1 h", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\nf : Filter \u03b1\np : \u03b1 \u00d7 \u03b1 \u2192 Prop\nh : \u2200\u1da0 (i : \u03b1 \u00d7 \u03b1) in f \u00d7\u02e2 f, p i\nt : \u03b1 \u2192 Prop\nht : \u2200\u1da0 (x : \u03b1) in f, t x\ns : \u03b1 \u2192 Prop\nhs : \u2200\u1da0 (y : \u03b1) in f, s y\nhst : \u2200 {x : \u03b1}, t x \u2192 \u2200 {y : \u03b1}, s y \u2192 p (x, y)\n\u22a2 \u2200\u1da0 (i : \u03b1) in f, p (i, i)"}, {"line": "apply (ht.and hs).mono fun x hx => hst hx.1 hx.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Eventually.diag_of_prod_left {f : Filter \u03b1} {g : Filter \u03b3} {p : (\u03b1 \u00d7 \u03b1) \u00d7 \u03b3 \u2192 Prop} :\n    (\u2200\u1da0 x in (f \u00d7\u02e2 f) \u00d7\u02e2 g, p x) \u2192 \u2200\u1da0 x : \u03b1 \u00d7 \u03b3 in f \u00d7\u02e2 g, p ((x.1, x.1), x.2) := by\n  intro h\n  obtain \u27e8t, ht, s, hs, hst\u27e9 := eventually_prod_iff.1 h\n  exact (ht.diag_of_prod.prod_mk hs).mono fun x hx => by simp only [hst hx.1 hx.2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b3 : Type u_3\nf : Filter \u03b1\ng : Filter \u03b3\np : (\u03b1 \u00d7 \u03b1) \u00d7 \u03b3 \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : (\u03b1 \u00d7 \u03b1) \u00d7 \u03b3) in (f \u00d7\u02e2 f) \u00d7\u02e2 g, p x) \u2192 \u2200\u1da0 (x : \u03b1 \u00d7 \u03b3) in f \u00d7\u02e2 g, p ((x.1, x.1), x.2)"}, {"line": "intro h", "tactic_state": "\u03b1 : Type u_1\n\u03b3 : Type u_3\nf : Filter \u03b1\ng : Filter \u03b3\np : (\u03b1 \u00d7 \u03b1) \u00d7 \u03b3 \u2192 Prop\nh : \u2200\u1da0 (x : (\u03b1 \u00d7 \u03b1) \u00d7 \u03b3) in (f \u00d7\u02e2 f) \u00d7\u02e2 g, p x\n\u22a2 \u2200\u1da0 (x : \u03b1 \u00d7 \u03b3) in f \u00d7\u02e2 g, p ((x.1, x.1), x.2)"}, {"line": "obtain \u27e8t, ht, s, hs, hst\u27e9 := eventually_prod_iff.1 h", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b3 : Type u_3\nf : Filter \u03b1\ng : Filter \u03b3\np : (\u03b1 \u00d7 \u03b1) \u00d7 \u03b3 \u2192 Prop\nh : \u2200\u1da0 (x : (\u03b1 \u00d7 \u03b1) \u00d7 \u03b3) in (f \u00d7\u02e2 f) \u00d7\u02e2 g, p x\nt : \u03b1 \u00d7 \u03b1 \u2192 Prop\nht : \u2200\u1da0 (x : \u03b1 \u00d7 \u03b1) in f \u00d7\u02e2 f, t x\ns : \u03b3 \u2192 Prop\nhs : \u2200\u1da0 (y : \u03b3) in g, s y\nhst : \u2200 {x : \u03b1 \u00d7 \u03b1}, t x \u2192 \u2200 {y : \u03b3}, s y \u2192 p (x, y)\n\u22a2 \u2200\u1da0 (x : \u03b1 \u00d7 \u03b3) in f \u00d7\u02e2 g, p ((x.1, x.1), x.2)"}, {"line": "exact (ht.diag_of_prod.prod_mk hs).mono fun x hx => by simp only [hst hx.1 hx.2]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Eventually.diag_of_prod_right {f : Filter \u03b1} {g : Filter \u03b3} {p : \u03b1 \u00d7 \u03b3 \u00d7 \u03b3 \u2192 Prop} :\n    (\u2200\u1da0 x in f \u00d7\u02e2 (g \u00d7\u02e2 g), p x) \u2192 \u2200\u1da0 x : \u03b1 \u00d7 \u03b3 in f \u00d7\u02e2 g, p (x.1, x.2, x.2) := by\n  intro h\n  obtain \u27e8t, ht, s, hs, hst\u27e9 := eventually_prod_iff.1 h\n  exact (ht.prod_mk hs.diag_of_prod).mono fun x hx => by simp only [hst hx.1 hx.2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b3 : Type u_3\nf : Filter \u03b1\ng : Filter \u03b3\np : \u03b1 \u00d7 \u03b3 \u00d7 \u03b3 \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : \u03b1 \u00d7 \u03b3 \u00d7 \u03b3) in f \u00d7\u02e2 g \u00d7\u02e2 g, p x) \u2192 \u2200\u1da0 (x : \u03b1 \u00d7 \u03b3) in f \u00d7\u02e2 g, p (x.1, x.2, x.2)"}, {"line": "intro h", "tactic_state": "\u03b1 : Type u_1\n\u03b3 : Type u_3\nf : Filter \u03b1\ng : Filter \u03b3\np : \u03b1 \u00d7 \u03b3 \u00d7 \u03b3 \u2192 Prop\nh : \u2200\u1da0 (x : \u03b1 \u00d7 \u03b3 \u00d7 \u03b3) in f \u00d7\u02e2 g \u00d7\u02e2 g, p x\n\u22a2 \u2200\u1da0 (x : \u03b1 \u00d7 \u03b3) in f \u00d7\u02e2 g, p (x.1, x.2, x.2)"}, {"line": "obtain \u27e8t, ht, s, hs, hst\u27e9 := eventually_prod_iff.1 h", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b3 : Type u_3\nf : Filter \u03b1\ng : Filter \u03b3\np : \u03b1 \u00d7 \u03b3 \u00d7 \u03b3 \u2192 Prop\nh : \u2200\u1da0 (x : \u03b1 \u00d7 \u03b3 \u00d7 \u03b3) in f \u00d7\u02e2 g \u00d7\u02e2 g, p x\nt : \u03b1 \u2192 Prop\nht : \u2200\u1da0 (x : \u03b1) in f, t x\ns : \u03b3 \u00d7 \u03b3 \u2192 Prop\nhs : \u2200\u1da0 (y : \u03b3 \u00d7 \u03b3) in g \u00d7\u02e2 g, s y\nhst : \u2200 {x : \u03b1}, t x \u2192 \u2200 {y : \u03b3 \u00d7 \u03b3}, s y \u2192 p (x, y)\n\u22a2 \u2200\u1da0 (x : \u03b1 \u00d7 \u03b3) in f \u00d7\u02e2 g, p (x.1, x.2, x.2)"}, {"line": "exact (ht.prod_mk hs.diag_of_prod).mono fun x hx => by simp only [hst hx.1 hx.2]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_comap_comap_eq.{u, v, w, x} {\u03b1\u2081 : Type u} {\u03b1\u2082 : Type v} {\u03b2\u2081 : Type w} {\u03b2\u2082 : Type x}\n    {f\u2081 : Filter \u03b1\u2081} {f\u2082 : Filter \u03b1\u2082} {m\u2081 : \u03b2\u2081 \u2192 \u03b1\u2081} {m\u2082 : \u03b2\u2082 \u2192 \u03b1\u2082} :\n    comap m\u2081 f\u2081 \u00d7\u02e2 comap m\u2082 f\u2082 = comap (fun p : \u03b2\u2081 \u00d7 \u03b2\u2082 => (m\u2081 p.1, m\u2082 p.2)) (f\u2081 \u00d7\u02e2 f\u2082) := by\n  simp only [prod_eq_inf]\n  simp only [comap_comap]\n  simp only [comap_inf]\n  simp only [Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u2081 : Type u\n\u03b1\u2082 : Type v\n\u03b2\u2081 : Type w\n\u03b2\u2082 : Type x\nf\u2081 : Filter \u03b1\u2081\nf\u2082 : Filter \u03b1\u2082\nm\u2081 : \u03b2\u2081 \u2192 \u03b1\u2081\nm\u2082 : \u03b2\u2082 \u2192 \u03b1\u2082\n\u22a2 comap m\u2081 f\u2081 \u00d7\u02e2 comap m\u2082 f\u2082 = comap (fun p => (m\u2081 p.1, m\u2082 p.2)) (f\u2081 \u00d7\u02e2 f\u2082)"}, {"line": "simp only [prod_eq_inf]", "tactic_state": "\u03b1\u2081 : Type u\n\u03b1\u2082 : Type v\n\u03b2\u2081 : Type w\n\u03b2\u2082 : Type x\nf\u2081 : Filter \u03b1\u2081\nf\u2082 : Filter \u03b1\u2082\nm\u2081 : \u03b2\u2081 \u2192 \u03b1\u2081\nm\u2082 : \u03b2\u2082 \u2192 \u03b1\u2082\n\u22a2 comap Prod.fst (comap m\u2081 f\u2081) \u2293 comap Prod.snd (comap m\u2082 f\u2082) =\n    comap (fun p => (m\u2081 p.1, m\u2082 p.2)) (comap Prod.fst f\u2081 \u2293 comap Prod.snd f\u2082)"}, {"line": "simp only [comap_comap]", "tactic_state": "\u03b1\u2081 : Type u\n\u03b1\u2082 : Type v\n\u03b2\u2081 : Type w\n\u03b2\u2082 : Type x\nf\u2081 : Filter \u03b1\u2081\nf\u2082 : Filter \u03b1\u2082\nm\u2081 : \u03b2\u2081 \u2192 \u03b1\u2081\nm\u2082 : \u03b2\u2082 \u2192 \u03b1\u2082\n\u22a2 comap (m\u2081 \u2218 Prod.fst) f\u2081 \u2293 comap (m\u2082 \u2218 Prod.snd) f\u2082 =\n    comap (fun p => (m\u2081 p.1, m\u2082 p.2)) (comap Prod.fst f\u2081 \u2293 comap Prod.snd f\u2082)"}, {"line": "simp only [comap_inf]", "tactic_state": "\u03b1\u2081 : Type u\n\u03b1\u2082 : Type v\n\u03b2\u2081 : Type w\n\u03b2\u2082 : Type x\nf\u2081 : Filter \u03b1\u2081\nf\u2082 : Filter \u03b1\u2082\nm\u2081 : \u03b2\u2081 \u2192 \u03b1\u2081\nm\u2082 : \u03b2\u2082 \u2192 \u03b1\u2082\n\u22a2 comap (m\u2081 \u2218 Prod.fst) f\u2081 \u2293 comap (m\u2082 \u2218 Prod.snd) f\u2082 =\n    comap (fun p => (m\u2081 p.1, m\u2082 p.2)) (comap Prod.fst f\u2081) \u2293 comap (fun p => (m\u2081 p.1, m\u2082 p.2)) (comap Prod.snd f\u2082)"}, {"line": "simp only [Function.comp_def]", "tactic_state": "\u03b1\u2081 : Type u\n\u03b1\u2082 : Type v\n\u03b2\u2081 : Type w\n\u03b2\u2082 : Type x\nf\u2081 : Filter \u03b1\u2081\nf\u2082 : Filter \u03b1\u2082\nm\u2081 : \u03b2\u2081 \u2192 \u03b1\u2081\nm\u2082 : \u03b2\u2082 \u2192 \u03b1\u2082\n\u22a2 comap (fun x => m\u2081 x.1) f\u2081 \u2293 comap (fun x => m\u2082 x.2) f\u2082 =\n    comap (fun p => (m\u2081 p.1, m\u2082 p.2)) (comap Prod.fst f\u2081) \u2293 comap (fun p => (m\u2081 p.1, m\u2082 p.2)) (comap Prod.snd f\u2082)"}]}
{"declaration": "theorem prod_comm : f \u00d7\u02e2 g = map (fun p : \u03b2 \u00d7 \u03b1 => (p.2, p.1)) (g \u00d7\u02e2 f) := by\n  rw [prod_comm']\n  rw [\u2190 map_swap_eq_comap_swap]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 f \u00d7\u02e2 g = map (fun p => (p.2, p.1)) (g \u00d7\u02e2 f)"}, {"line": "rw [prod_comm']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 comap Prod.swap (g \u00d7\u02e2 f) = map (fun p => (p.2, p.1)) (g \u00d7\u02e2 f)"}, {"line": "rw [\u2190 map_swap_eq_comap_swap]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 Prod.swap <$> (g \u00d7\u02e2 f) = map (fun p => (p.2, p.1)) (g \u00d7\u02e2 f)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_prod_iff_left {s : Set (\u03b1 \u00d7 \u03b2)} :\n    s \u2208 f \u00d7\u02e2 g \u2194 \u2203 t \u2208 f, \u2200\u1da0 y in g, \u2200 x \u2208 t, (x, y) \u2208 s := by\n  simp only [mem_prod_iff]\n  simp only [prod_subset_iff]\n  refine exists_congr fun _ => Iff.rfl.and <| Iff.trans ?_ exists_mem_subset_iff\n  exact exists_congr fun _ => Iff.rfl.and forall\u2082_swap\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\n\u22a2 s \u2208 f \u00d7\u02e2 g \u2194 \u2203 t \u2208 f, \u2200\u1da0 (y : \u03b2) in g, \u2200 x \u2208 t, (x, y) \u2208 s"}, {"line": "simp only [mem_prod_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\n\u22a2 (\u2203 t\u2081 \u2208 f, \u2203 t\u2082 \u2208 g, t\u2081 \u00d7\u02e2 t\u2082 \u2286 s) \u2194 \u2203 t \u2208 f, \u2200\u1da0 (y : \u03b2) in g, \u2200 x \u2208 t, (x, y) \u2208 s"}, {"line": "simp only [prod_subset_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\n\u22a2 (\u2203 t\u2081 \u2208 f, \u2203 t\u2082 \u2208 g, \u2200 x \u2208 t\u2081, \u2200 y \u2208 t\u2082, (x, y) \u2208 s) \u2194 \u2203 t \u2208 f, \u2200\u1da0 (y : \u03b2) in g, \u2200 x \u2208 t, (x, y) \u2208 s"}, {"line": "refine exists_congr fun _ => Iff.rfl.and <| Iff.trans ?_ exists_mem_subset_iff", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\nx\u271d : Set \u03b1\n\u22a2 (\u2203 t\u2082 \u2208 g, \u2200 x \u2208 x\u271d, \u2200 y \u2208 t\u2082, (x, y) \u2208 s) \u2194 \u2203 t \u2208 g, t \u2286 {x | (fun y => \u2200 x \u2208 x\u271d, (x, y) \u2208 s) x}"}, {"line": "exact exists_congr fun _ => Iff.rfl.and forall\u2082_swap", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_assoc (f : Filter \u03b1) (g : Filter \u03b2) (h : Filter \u03b3) :\n    map (Equiv.prodAssoc \u03b1 \u03b2 \u03b3) ((f \u00d7\u02e2 g) \u00d7\u02e2 h) = f \u00d7\u02e2 (g \u00d7\u02e2 h) := by\n  simp_rw [\u2190 comap_equiv_symm, prod_eq_inf, comap_inf, comap_comap, inf_assoc,\n    Function.comp_def, Equiv.prodAssoc_symm_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\n\u22a2 map (\u21d1(Equiv.prodAssoc \u03b1 \u03b2 \u03b3)) ((f \u00d7\u02e2 g) \u00d7\u02e2 h) = f \u00d7\u02e2 g \u00d7\u02e2 h"}, {"line": "simp_rw [\u2190 comap_equiv_symm, prod_eq_inf, comap_inf, comap_comap, inf_assoc,\n    Function.comp_def, Equiv.prodAssoc_symm_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_assoc_symm (f : Filter \u03b1) (g : Filter \u03b2) (h : Filter \u03b3) :\n    map (Equiv.prodAssoc \u03b1 \u03b2 \u03b3).symm (f \u00d7\u02e2 (g \u00d7\u02e2 h)) = (f \u00d7\u02e2 g) \u00d7\u02e2 h := by\n  simp_rw [map_equiv_symm, prod_eq_inf, comap_inf, comap_comap, inf_assoc,\n    Function.comp_def, Equiv.prodAssoc_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Filter \u03b1\ng : Filter \u03b2\nh : Filter \u03b3\n\u22a2 map (\u21d1(Equiv.prodAssoc \u03b1 \u03b2 \u03b3).symm) (f \u00d7\u02e2 g \u00d7\u02e2 h) = (f \u00d7\u02e2 g) \u00d7\u02e2 h"}, {"line": "simp_rw [map_equiv_symm, prod_eq_inf, comap_inf, comap_comap, inf_assoc,\n    Function.comp_def, Equiv.prodAssoc_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_map_left (f : \u03b1 \u2192 \u03b2) (F : Filter \u03b1) (G : Filter \u03b3) :\n    map f F \u00d7\u02e2 G = map (Prod.map f id) (F \u00d7\u02e2 G) := by\n  rw [\u2190 prod_map_map_eq']\n  rw [map_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\nG : Filter \u03b3\n\u22a2 map f F \u00d7\u02e2 G = map (Prod.map f id) (F \u00d7\u02e2 G)"}, {"line": "rw [\u2190 prod_map_map_eq']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\nG : Filter \u03b3\n\u22a2 map f F \u00d7\u02e2 G = map f F \u00d7\u02e2 map id G"}, {"line": "rw [map_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_map_right (f : \u03b2 \u2192 \u03b3) (F : Filter \u03b1) (G : Filter \u03b2) :\n    F \u00d7\u02e2 map f G = map (Prod.map id f) (F \u00d7\u02e2 G) := by\n  rw [\u2190 prod_map_map_eq']\n  rw [map_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b2 \u2192 \u03b3\nF : Filter \u03b1\nG : Filter \u03b2\n\u22a2 F \u00d7\u02e2 map f G = map (Prod.map id f) (F \u00d7\u02e2 G)"}, {"line": "rw [\u2190 prod_map_map_eq']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b2 \u2192 \u03b3\nF : Filter \u03b1\nG : Filter \u03b2\n\u22a2 F \u00d7\u02e2 map f G = map id F \u00d7\u02e2 map f G"}, {"line": "rw [map_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Tendsto.prodMap {\u03b4 : Type*} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {a : Filter \u03b1} {b : Filter \u03b2}\n    {c : Filter \u03b3} {d : Filter \u03b4} (hf : Tendsto f a c) (hg : Tendsto g b d) :\n    Tendsto (Prod.map f g) (a \u00d7\u02e2 b) (c \u00d7\u02e2 d) := by\n  rw [Tendsto]\n  rw [Prod.map_def]\n  rw [\u2190 prod_map_map_eq]\n  exact Filter.prod_mono hf hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_6\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b4\na : Filter \u03b1\nb : Filter \u03b2\nc : Filter \u03b3\nd : Filter \u03b4\nhf : Tendsto f a c\nhg : Tendsto g b d\n\u22a2 Tendsto (Prod.map f g) (a \u00d7\u02e2 b) (c \u00d7\u02e2 d)"}, {"line": "rw [Tendsto]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_6\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b4\na : Filter \u03b1\nb : Filter \u03b2\nc : Filter \u03b3\nd : Filter \u03b4\nhf : Tendsto f a c\nhg : Tendsto g b d\n\u22a2 map (Prod.map f g) (a \u00d7\u02e2 b) \u2264 c \u00d7\u02e2 d"}, {"line": "rw [Prod.map_def]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_6\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b4\na : Filter \u03b1\nb : Filter \u03b2\nc : Filter \u03b3\nd : Filter \u03b4\nhf : Tendsto f a c\nhg : Tendsto g b d\n\u22a2 map (fun p => (f p.1, g p.2)) (a \u00d7\u02e2 b) \u2264 c \u00d7\u02e2 d"}, {"line": "rw [\u2190 prod_map_map_eq]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_6\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b4\na : Filter \u03b1\nb : Filter \u03b2\nc : Filter \u03b3\nd : Filter \u03b4\nhf : Tendsto f a c\nhg : Tendsto g b d\n\u22a2 map f a \u00d7\u02e2 map g b \u2264 c \u00d7\u02e2 d"}, {"line": "exact Filter.prod_mono hf hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_prod {f\u2081 f\u2082 : Filter \u03b1} : (f\u2081 \u2293 f\u2082) \u00d7\u02e2 g = (f\u2081 \u00d7\u02e2 g) \u2293 (f\u2082 \u00d7\u02e2 g) := by\n  rw [prod_inf_prod]\n  rw [inf_idem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : Filter \u03b2\nf\u2081 f\u2082 : Filter \u03b1\n\u22a2 (f\u2081 \u2293 f\u2082) \u00d7\u02e2 g = f\u2081 \u00d7\u02e2 g \u2293 f\u2082 \u00d7\u02e2 g"}, {"line": "rw [prod_inf_prod]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : Filter \u03b2\nf\u2081 f\u2082 : Filter \u03b1\n\u22a2 (f\u2081 \u2293 f\u2082) \u00d7\u02e2 g = (f\u2081 \u2293 f\u2082) \u00d7\u02e2 (g \u2293 g)"}, {"line": "rw [inf_idem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_inf {g\u2081 g\u2082 : Filter \u03b2} : f \u00d7\u02e2 (g\u2081 \u2293 g\u2082) = (f \u00d7\u02e2 g\u2081) \u2293 (f \u00d7\u02e2 g\u2082) := by\n  rw [prod_inf_prod]\n  rw [inf_idem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng\u2081 g\u2082 : Filter \u03b2\n\u22a2 f \u00d7\u02e2 (g\u2081 \u2293 g\u2082) = f \u00d7\u02e2 g\u2081 \u2293 f \u00d7\u02e2 g\u2082"}, {"line": "rw [prod_inf_prod]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng\u2081 g\u2082 : Filter \u03b2\n\u22a2 f \u00d7\u02e2 (g\u2081 \u2293 g\u2082) = (f \u2293 f) \u00d7\u02e2 (g\u2081 \u2293 g\u2082)"}, {"line": "rw [inf_idem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_pure_pure {a : \u03b1} {b : \u03b2} :\n    (pure a : Filter \u03b1) \u00d7\u02e2 (pure b : Filter \u03b2) = pure (a, b) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\nb : \u03b2\n\u22a2 pure a \u00d7\u02e2 pure b = pure (a, b)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_eq_bot : f \u00d7\u02e2 g = \u22a5 \u2194 f = \u22a5 \u2228 g = \u22a5 := by\n  simp_rw [\u2190 empty_mem_iff_bot, mem_prod_iff, subset_empty_iff, prod_eq_empty_iff, \u2190 exists_prop,\n    Subtype.exists', exists_or, exists_const, Subtype.exists, exists_prop, exists_eq_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 f \u00d7\u02e2 g = \u22a5 \u2194 f = \u22a5 \u2228 g = \u22a5"}, {"line": "simp_rw [\u2190 empty_mem_iff_bot, mem_prod_iff, subset_empty_iff, prod_eq_empty_iff, \u2190 exists_prop,\n    Subtype.exists', exists_or, exists_const, Subtype.exists, exists_prop, exists_eq_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_neBot : NeBot (f \u00d7\u02e2 g) \u2194 NeBot f \u2227 NeBot g := by\n  simp only [neBot_iff]\n  simp only [Ne]\n  simp only [prod_eq_bot]\n  simp only [not_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 (f \u00d7\u02e2 g).NeBot \u2194 f.NeBot \u2227 g.NeBot"}, {"line": "simp only [neBot_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 f \u00d7\u02e2 g \u2260 \u22a5 \u2194 f \u2260 \u22a5 \u2227 g \u2260 \u22a5"}, {"line": "simp only [Ne]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 \u00acf \u00d7\u02e2 g = \u22a5 \u2194 \u00acf = \u22a5 \u2227 \u00acg = \u22a5"}, {"line": "simp only [prod_eq_bot]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 \u00ac(f = \u22a5 \u2228 g = \u22a5) \u2194 \u00acf = \u22a5 \u2227 \u00acg = \u22a5"}, {"line": "simp only [not_or]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma disjoint_prod {f' : Filter \u03b1} {g' : Filter \u03b2} :\n    Disjoint (f \u00d7\u02e2 g) (f' \u00d7\u02e2 g') \u2194 Disjoint f f' \u2228 Disjoint g g' := by\n  simp only [disjoint_iff]\n  simp only [prod_inf_prod]\n  simp only [prod_eq_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\nf' : Filter \u03b1\ng' : Filter \u03b2\n\u22a2 Disjoint (f \u00d7\u02e2 g) (f' \u00d7\u02e2 g') \u2194 Disjoint f f' \u2228 Disjoint g g'"}, {"line": "simp only [disjoint_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\nf' : Filter \u03b1\ng' : Filter \u03b2\n\u22a2 f \u00d7\u02e2 g \u2293 f' \u00d7\u02e2 g' = \u22a5 \u2194 f \u2293 f' = \u22a5 \u2228 g \u2293 g' = \u22a5"}, {"line": "simp only [prod_inf_prod]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\nf' : Filter \u03b1\ng' : Filter \u03b2\n\u22a2 (f \u2293 f') \u00d7\u02e2 (g \u2293 g') = \u22a5 \u2194 f \u2293 f' = \u22a5 \u2228 g \u2293 g' = \u22a5"}, {"line": "simp only [prod_eq_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frequently_prod_and {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} :\n    (\u2203\u1da0 x in f \u00d7\u02e2 g, p x.1 \u2227 q x.2) \u2194 (\u2203\u1da0 a in f, p a) \u2227 \u2203\u1da0 b in g, q b := by\n  simp only [frequently_iff_neBot]\n  simp only [\u2190 prod_neBot]\n  simp only [\u2190 prod_inf_prod]\n  simp only [prod_principal_principal]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\n\u22a2 (\u2203\u1da0 (x : \u03b1 \u00d7 \u03b2) in f \u00d7\u02e2 g, p x.1 \u2227 q x.2) \u2194 (\u2203\u1da0 (a : \u03b1) in f, p a) \u2227 \u2203\u1da0 (b : \u03b2) in g, q b"}, {"line": "simp only [frequently_iff_neBot]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\n\u22a2 (f \u00d7\u02e2 g \u2293 principal {x | p x.1 \u2227 q x.2}).NeBot \u2194 (f \u2293 principal {a | p a}).NeBot \u2227 (g \u2293 principal {b | q b}).NeBot"}, {"line": "simp only [\u2190 prod_neBot]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\n\u22a2 (f \u00d7\u02e2 g \u2293 principal {x | p x.1 \u2227 q x.2}).NeBot \u2194 ((f \u2293 principal {a | p a}) \u00d7\u02e2 (g \u2293 principal {b | q b})).NeBot"}, {"line": "simp only [\u2190 prod_inf_prod]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\n\u22a2 (f \u00d7\u02e2 g \u2293 principal {x | p x.1 \u2227 q x.2}).NeBot \u2194 (f \u00d7\u02e2 g \u2293 principal {a | p a} \u00d7\u02e2 principal {b | q b}).NeBot"}, {"line": "simp only [prod_principal_principal]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\n\u22a2 (f \u00d7\u02e2 g \u2293 principal {x | p x.1 \u2227 q x.2}).NeBot \u2194 (f \u00d7\u02e2 g \u2293 principal ({a | p a} \u00d7\u02e2 {b | q b})).NeBot"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_prod_iff' {g' : Filter \u03b3} {s : \u03b1 \u2192 \u03b2 \u00d7 \u03b3} :\n    Tendsto s f (g \u00d7\u02e2 g') \u2194 Tendsto (fun n => (s n).1) f g \u2227 Tendsto (fun n => (s n).2) f g' := by\n  simp only [prod_eq_inf]\n  simp only [tendsto_inf]\n  simp only [tendsto_comap_iff]\n  simp only [Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Filter \u03b1\ng : Filter \u03b2\ng' : Filter \u03b3\ns : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\n\u22a2 Tendsto s f (g \u00d7\u02e2 g') \u2194 Tendsto (fun n => (s n).1) f g \u2227 Tendsto (fun n => (s n).2) f g'"}, {"line": "simp only [prod_eq_inf]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Filter \u03b1\ng : Filter \u03b2\ng' : Filter \u03b3\ns : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\n\u22a2 Tendsto s f (comap Prod.fst g \u2293 comap Prod.snd g') \u2194 Tendsto (fun n => (s n).1) f g \u2227 Tendsto (fun n => (s n).2) f g'"}, {"line": "simp only [tendsto_inf]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Filter \u03b1\ng : Filter \u03b2\ng' : Filter \u03b3\ns : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\n\u22a2 Tendsto s f (comap Prod.fst g) \u2227 Tendsto s f (comap Prod.snd g') \u2194\n    Tendsto (fun n => (s n).1) f g \u2227 Tendsto (fun n => (s n).2) f g'"}, {"line": "simp only [tendsto_comap_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Filter \u03b1\ng : Filter \u03b2\ng' : Filter \u03b3\ns : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\n\u22a2 Tendsto (Prod.fst \u2218 s) f g \u2227 Tendsto (Prod.snd \u2218 s) f g' \u2194\n    Tendsto (fun n => (s n).1) f g \u2227 Tendsto (fun n => (s n).2) f g'"}, {"line": "simp only [Function.comp_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coprod_eq_prod_top_sup_top_prod (f : Filter \u03b1) (g : Filter \u03b2) :\n    Filter.coprod f g = f \u00d7\u02e2 \u22a4 \u2294 \u22a4 \u00d7\u02e2 g := by\n  rw [prod_top]\n  rw [top_prod]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}", "{f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 f.coprod g = f \u00d7\u02e2 \u22a4 \u2294 \u22a4 \u00d7\u02e2 g"}, {"line": "rw [prod_top]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 f.coprod g = comap Prod.fst f \u2294 \u22a4 \u00d7\u02e2 g"}, {"line": "rw [top_prod]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 f.coprod g = comap Prod.fst f \u2294 comap Prod.snd g"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_coprod_iff {s : Set (\u03b1 \u00d7 \u03b2)} {f : Filter \u03b1} {g : Filter \u03b2} :\n    s \u2208 f.coprod g \u2194 (\u2203 t\u2081 \u2208 f, Prod.fst \u207b\u00b9' t\u2081 \u2286 s) \u2227 \u2203 t\u2082 \u2208 g, Prod.snd \u207b\u00b9' t\u2082 \u2286 s := by\n  simp [Filter.coprod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}", "{f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (\u03b1 \u00d7 \u03b2)\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 s \u2208 f.coprod g \u2194 (\u2203 t\u2081 \u2208 f, Prod.fst \u207b\u00b9' t\u2081 \u2286 s) \u2227 \u2203 t\u2082 \u2208 g, Prod.snd \u207b\u00b9' t\u2082 \u2286 s"}, {"line": "simp [Filter.coprod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bot_coprod (l : Filter \u03b2) : (\u22a5 : Filter \u03b1).coprod l = comap Prod.snd l := by\n  simp [Filter.coprod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}", "{f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b2\n\u22a2 \u22a5.coprod l = comap Prod.snd l"}, {"line": "simp [Filter.coprod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coprod_bot (l : Filter \u03b1) : l.coprod (\u22a5 : Filter \u03b2) = comap Prod.fst l := by\n  simp [Filter.coprod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}", "{f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\n\u22a2 l.coprod \u22a5 = comap Prod.fst l"}, {"line": "simp [Filter.coprod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bot_coprod_bot : (\u22a5 : Filter \u03b1).coprod (\u22a5 : Filter \u03b2) = \u22a5 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}", "{f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 \u22a5.coprod \u22a5 = \u22a5"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_mem_coprod {s : Set (\u03b1 \u00d7 \u03b2)} {la : Filter \u03b1} {lb : Filter \u03b2} :\n    s\u1d9c \u2208 la.coprod lb \u2194 (Prod.fst '' s)\u1d9c \u2208 la \u2227 (Prod.snd '' s)\u1d9c \u2208 lb := by\n  simp only [Filter.coprod]\n  simp only [mem_sup]\n  simp only [compl_mem_comap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}", "{f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (\u03b1 \u00d7 \u03b2)\nla : Filter \u03b1\nlb : Filter \u03b2\n\u22a2 s\u1d9c \u2208 la.coprod lb \u2194 (Prod.fst '' s)\u1d9c \u2208 la \u2227 (Prod.snd '' s)\u1d9c \u2208 lb"}, {"line": "simp only [Filter.coprod]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (\u03b1 \u00d7 \u03b2)\nla : Filter \u03b1\nlb : Filter \u03b2\n\u22a2 s\u1d9c \u2208 comap Prod.fst la \u2294 comap Prod.snd lb \u2194 (Prod.fst '' s)\u1d9c \u2208 la \u2227 (Prod.snd '' s)\u1d9c \u2208 lb"}, {"line": "simp only [mem_sup]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (\u03b1 \u00d7 \u03b2)\nla : Filter \u03b1\nlb : Filter \u03b2\n\u22a2 s\u1d9c \u2208 comap Prod.fst la \u2227 s\u1d9c \u2208 comap Prod.snd lb \u2194 (Prod.fst '' s)\u1d9c \u2208 la \u2227 (Prod.snd '' s)\u1d9c \u2208 lb"}, {"line": "simp only [compl_mem_comap]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coprod_neBot_iff : (f.coprod g).NeBot \u2194 f.NeBot \u2227 Nonempty \u03b2 \u2228 Nonempty \u03b1 \u2227 g.NeBot := by\n  simp [Filter.coprod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}", "{f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 (f.coprod g).NeBot \u2194 f.NeBot \u2227 Nonempty \u03b2 \u2228 Nonempty \u03b1 \u2227 g.NeBot"}, {"line": "simp [Filter.coprod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem principal_coprod_principal (s : Set \u03b1) (t : Set \u03b2) :\n    (\ud835\udcdf s).coprod (\ud835\udcdf t) = \ud835\udcdf (s\u1d9c \u00d7\u02e2 t\u1d9c)\u1d9c := by\n  rw [Filter.coprod]\n  rw [comap_principal]\n  rw [comap_principal]\n  rw [sup_principal]\n  rw [Set.prod_eq]\n  rw [compl_inter]\n  rw [preimage_compl]\n  rw [preimage_compl]\n  rw [compl_compl]\n  rw [compl_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}", "{f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 (principal s).coprod (principal t) = principal (s\u1d9c \u00d7\u02e2 t\u1d9c)\u1d9c"}, {"line": "rw [Filter.coprod]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 comap Prod.fst (principal s) \u2294 comap Prod.snd (principal t) = principal (s\u1d9c \u00d7\u02e2 t\u1d9c)\u1d9c"}, {"line": "rw [comap_principal]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 principal (Prod.fst \u207b\u00b9' s) \u2294 comap Prod.snd (principal t) = principal (s\u1d9c \u00d7\u02e2 t\u1d9c)\u1d9c"}, {"line": "rw [comap_principal]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 principal (Prod.fst \u207b\u00b9' s) \u2294 principal (Prod.snd \u207b\u00b9' t) = principal (s\u1d9c \u00d7\u02e2 t\u1d9c)\u1d9c"}, {"line": "rw [sup_principal]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 principal (Prod.fst \u207b\u00b9' s \u222a Prod.snd \u207b\u00b9' t) = principal (s\u1d9c \u00d7\u02e2 t\u1d9c)\u1d9c"}, {"line": "rw [Set.prod_eq]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 principal (Prod.fst \u207b\u00b9' s \u222a Prod.snd \u207b\u00b9' t) = principal (Prod.fst \u207b\u00b9' s\u1d9c \u2229 Prod.snd \u207b\u00b9' t\u1d9c)\u1d9c"}, {"line": "rw [compl_inter]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 principal (Prod.fst \u207b\u00b9' s \u222a Prod.snd \u207b\u00b9' t) = principal ((Prod.fst \u207b\u00b9' s\u1d9c)\u1d9c \u222a (Prod.snd \u207b\u00b9' t\u1d9c)\u1d9c)"}, {"line": "rw [preimage_compl]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 principal (Prod.fst \u207b\u00b9' s \u222a Prod.snd \u207b\u00b9' t) = principal ((Prod.fst \u207b\u00b9' s)\u1d9c\u1d9c \u222a (Prod.snd \u207b\u00b9' t\u1d9c)\u1d9c)"}, {"line": "rw [preimage_compl]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 principal (Prod.fst \u207b\u00b9' s \u222a Prod.snd \u207b\u00b9' t) = principal ((Prod.fst \u207b\u00b9' s)\u1d9c\u1d9c \u222a (Prod.snd \u207b\u00b9' t)\u1d9c\u1d9c)"}, {"line": "rw [compl_compl]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 principal (Prod.fst \u207b\u00b9' s \u222a Prod.snd \u207b\u00b9' t) = principal (Prod.fst \u207b\u00b9' s \u222a (Prod.snd \u207b\u00b9' t)\u1d9c\u1d9c)"}, {"line": "rw [compl_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_prodMap_coprod_le.{u, v, w, x} {\u03b1\u2081 : Type u} {\u03b1\u2082 : Type v} {\u03b2\u2081 : Type w} {\u03b2\u2082 : Type x}\n    {f\u2081 : Filter \u03b1\u2081} {f\u2082 : Filter \u03b1\u2082} {m\u2081 : \u03b1\u2081 \u2192 \u03b2\u2081} {m\u2082 : \u03b1\u2082 \u2192 \u03b2\u2082} :\n    map (Prod.map m\u2081 m\u2082) (f\u2081.coprod f\u2082) \u2264 (map m\u2081 f\u2081).coprod (map m\u2082 f\u2082) := by\n  intro s\n  simp only [mem_map]\n  simp only [mem_coprod_iff]\n  rintro \u27e8\u27e8u\u2081, hu\u2081, h\u2081\u27e9, u\u2082, hu\u2082, h\u2082\u27e9\n  refine \u27e8\u27e8m\u2081 \u207b\u00b9' u\u2081, hu\u2081, fun _ hx => h\u2081 ?_\u27e9, \u27e8m\u2082 \u207b\u00b9' u\u2082, hu\u2082, fun _ hx => h\u2082 ?_\u27e9\u27e9 <;> convert hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Prod.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*}", "{s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2}", "{f : Filter \u03b1} {g : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u2081 : Type u\n\u03b1\u2082 : Type v\n\u03b2\u2081 : Type w\n\u03b2\u2082 : Type x\nf\u2081 : Filter \u03b1\u2081\nf\u2082 : Filter \u03b1\u2082\nm\u2081 : \u03b1\u2081 \u2192 \u03b2\u2081\nm\u2082 : \u03b1\u2082 \u2192 \u03b2\u2082\n\u22a2 map (Prod.map m\u2081 m\u2082) (f\u2081.coprod f\u2082) \u2264 (map m\u2081 f\u2081).coprod (map m\u2082 f\u2082)"}, {"line": "intro s", "tactic_state": "\u03b1\u2081 : Type u\n\u03b1\u2082 : Type v\n\u03b2\u2081 : Type w\n\u03b2\u2082 : Type x\nf\u2081 : Filter \u03b1\u2081\nf\u2082 : Filter \u03b1\u2082\nm\u2081 : \u03b1\u2081 \u2192 \u03b2\u2081\nm\u2082 : \u03b1\u2082 \u2192 \u03b2\u2082\ns : Set (\u03b2\u2081 \u00d7 \u03b2\u2082)\n\u22a2 s \u2208 (map m\u2081 f\u2081).coprod (map m\u2082 f\u2082) \u2192 s \u2208 map (Prod.map m\u2081 m\u2082) (f\u2081.coprod f\u2082)"}, {"line": "simp only [mem_map]", "tactic_state": "\u03b1\u2081 : Type u\n\u03b1\u2082 : Type v\n\u03b2\u2081 : Type w\n\u03b2\u2082 : Type x\nf\u2081 : Filter \u03b1\u2081\nf\u2082 : Filter \u03b1\u2082\nm\u2081 : \u03b1\u2081 \u2192 \u03b2\u2081\nm\u2082 : \u03b1\u2082 \u2192 \u03b2\u2082\ns : Set (\u03b2\u2081 \u00d7 \u03b2\u2082)\n\u22a2 s \u2208 (map m\u2081 f\u2081).coprod (map m\u2082 f\u2082) \u2192 Prod.map m\u2081 m\u2082 \u207b\u00b9' s \u2208 f\u2081.coprod f\u2082"}, {"line": "simp only [mem_coprod_iff]", "tactic_state": "\u03b1\u2081 : Type u\n\u03b1\u2082 : Type v\n\u03b2\u2081 : Type w\n\u03b2\u2082 : Type x\nf\u2081 : Filter \u03b1\u2081\nf\u2082 : Filter \u03b1\u2082\nm\u2081 : \u03b1\u2081 \u2192 \u03b2\u2081\nm\u2082 : \u03b1\u2082 \u2192 \u03b2\u2082\ns : Set (\u03b2\u2081 \u00d7 \u03b2\u2082)\n\u22a2 ((\u2203 t\u2081 \u2208 map m\u2081 f\u2081, Prod.fst \u207b\u00b9' t\u2081 \u2286 s) \u2227 \u2203 t\u2082 \u2208 map m\u2082 f\u2082, Prod.snd \u207b\u00b9' t\u2082 \u2286 s) \u2192\n    (\u2203 t\u2081 \u2208 f\u2081, Prod.fst \u207b\u00b9' t\u2081 \u2286 Prod.map m\u2081 m\u2082 \u207b\u00b9' s) \u2227 \u2203 t\u2082 \u2208 f\u2082, Prod.snd \u207b\u00b9' t\u2082 \u2286 Prod.map m\u2081 m\u2082 \u207b\u00b9' s"}, {"line": "rintro \u27e8\u27e8u\u2081, hu\u2081, h\u2081\u27e9, u\u2082, hu\u2082, h\u2082\u27e9", "tactic_state": "case intro.intro.intro.intro.intro\n\u03b1\u2081 : Type u\n\u03b1\u2082 : Type v\n\u03b2\u2081 : Type w\n\u03b2\u2082 : Type x\nf\u2081 : Filter \u03b1\u2081\nf\u2082 : Filter \u03b1\u2082\nm\u2081 : \u03b1\u2081 \u2192 \u03b2\u2081\nm\u2082 : \u03b1\u2082 \u2192 \u03b2\u2082\ns : Set (\u03b2\u2081 \u00d7 \u03b2\u2082)\nu\u2081 : Set \u03b2\u2081\nhu\u2081 : u\u2081 \u2208 map m\u2081 f\u2081\nh\u2081 : Prod.fst \u207b\u00b9' u\u2081 \u2286 s\nu\u2082 : Set \u03b2\u2082\nhu\u2082 : u\u2082 \u2208 map m\u2082 f\u2082\nh\u2082 : Prod.snd \u207b\u00b9' u\u2082 \u2286 s\n\u22a2 (\u2203 t\u2081 \u2208 f\u2081, Prod.fst \u207b\u00b9' t\u2081 \u2286 Prod.map m\u2081 m\u2082 \u207b\u00b9' s) \u2227 \u2203 t\u2082 \u2208 f\u2082, Prod.snd \u207b\u00b9' t\u2082 \u2286 Prod.map m\u2081 m\u2082 \u207b\u00b9' s"}, {"line": "refine \u27e8\u27e8m\u2081 \u207b\u00b9' u\u2081, hu\u2081, fun _ hx => h\u2081 ?_\u27e9, \u27e8m\u2082 \u207b\u00b9' u\u2082, hu\u2082, fun _ hx => h\u2082 ?_\u27e9\u27e9 <;> convert hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem EventuallyLE.mul_le_mul [MulZeroClass \u03b2] [Preorder \u03b2] [PosMulMono \u03b2] [MulPosMono \u03b2]\n    {l : Filter \u03b1} {f\u2081 f\u2082 g\u2081 g\u2082 : \u03b1 \u2192 \u03b2} (hf : f\u2081 \u2264\u1da0[l] f\u2082) (hg : g\u2081 \u2264\u1da0[l] g\u2082) (hg\u2080 : 0 \u2264\u1da0[l] g\u2081)\n    (hf\u2080 : 0 \u2264\u1da0[l] f\u2082) : f\u2081 * g\u2081 \u2264\u1da0[l] f\u2082 * g\u2082 := by\n  filter_upwards [hf, hg, hg\u2080, hf\u2080] with x using _root_.mul_le_mul\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Ring.lean", "context": {"open": ["Function Filter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : MulZeroClass \u03b2\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : PosMulMono \u03b2\ninst\u271d : MulPosMono \u03b2\nl : Filter \u03b1\nf\u2081 f\u2082 g\u2081 g\u2082 : \u03b1 \u2192 \u03b2\nhf : f\u2081 \u2264\u1da0[l] f\u2082\nhg : g\u2081 \u2264\u1da0[l] g\u2082\nhg\u2080 : 0 \u2264\u1da0[l] g\u2081\nhf\u2080 : 0 \u2264\u1da0[l] f\u2082\n\u22a2 f\u2081 * g\u2081 \u2264\u1da0[l] f\u2082 * g\u2082"}, {"line": "filter_upwards [hf, hg, hg\u2080, hf\u2080] with x using _root_.mul_le_mul", "tactic_state": "No Goals!"}]}
{"declaration": "theorem EventuallyLE.mul_le_mul' [Mul \u03b2] [Preorder \u03b2] [MulLeftMono \u03b2]\n    [MulRightMono \u03b2] {l : Filter \u03b1} {f\u2081 f\u2082 g\u2081 g\u2082 : \u03b1 \u2192 \u03b2}\n    (hf : f\u2081 \u2264\u1da0[l] f\u2082) (hg : g\u2081 \u2264\u1da0[l] g\u2082) : f\u2081 * g\u2081 \u2264\u1da0[l] f\u2082 * g\u2082 := by\n  filter_upwards [hf, hg] with x hfx hgx using _root_.mul_le_mul' hfx hgx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Ring.lean", "context": {"open": ["Function Filter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : Mul \u03b2\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : MulLeftMono \u03b2\ninst\u271d : MulRightMono \u03b2\nl : Filter \u03b1\nf\u2081 f\u2082 g\u2081 g\u2082 : \u03b1 \u2192 \u03b2\nhf : f\u2081 \u2264\u1da0[l] f\u2082\nhg : g\u2081 \u2264\u1da0[l] g\u2082\n\u22a2 f\u2081 * g\u2081 \u2264\u1da0[l] f\u2082 * g\u2082"}, {"line": "filter_upwards [hf, hg] with x hfx hgx using _root_.mul_le_mul' hfx hgx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem EventuallyLE.mul_nonneg [Semiring \u03b2] [PartialOrder \u03b2] [IsOrderedRing \u03b2]\n    {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (hf : 0 \u2264\u1da0[l] f)\n    (hg : 0 \u2264\u1da0[l] g) : 0 \u2264\u1da0[l] f * g := by filter_upwards [hf, hg] with x using _root_.mul_nonneg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Ring.lean", "context": {"open": ["Function Filter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : Semiring \u03b2\ninst\u271d\u00b9 : PartialOrder \u03b2\ninst\u271d : IsOrderedRing \u03b2\nl : Filter \u03b1\nf g : \u03b1 \u2192 \u03b2\nhf : 0 \u2264\u1da0[l] f\nhg : 0 \u2264\u1da0[l] g\n\u22a2 0 \u2264\u1da0[l] f * g"}, {"line": "filter_upwards [hf, hg] with x using _root_.mul_nonneg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subsingleton_iff_bot_or_pure : l.Subsingleton \u2194 l = \u22a5 \u2228 \u2203 a, l = pure a := by\n  refine \u27e8fun hl \u21a6 ?_, ?_\u27e9\n  \u00b7 exact (eq_or_neBot l).imp_right (@Subsingleton.exists_eq_pure _ _ \u00b7 hl)\n  \u00b7 rintro (rfl | \u27e8a, rfl\u27e9) <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Subsingleton.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} {l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\n\u22a2 l.Subsingleton \u2194 l = \u22a5 \u2228 \u2203 a, l = pure a"}, {"line": "refine \u27e8fun hl \u21a6 ?_, ?_\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u_1\nl : Filter \u03b1\nhl : l.Subsingleton\n\u22a2 l = \u22a5 \u2228 \u2203 a, l = pure a\n---\ncase refine_2\n\u03b1 : Type u_1\nl : Filter \u03b1\n\u22a2 (l = \u22a5 \u2228 \u2203 a, l = pure a) \u2192 l.Subsingleton"}, {"line": "\u00b7 exact (eq_or_neBot l).imp_right (@Subsingleton.exists_eq_pure _ _ \u00b7 hl)", "tactic_state": "case refine_2\n\u03b1 : Type u_1\nl : Filter \u03b1\n\u22a2 (l = \u22a5 \u2228 \u2203 a, l = pure a) \u2192 l.Subsingleton"}, {"line": "\u00b7 rintro (rfl | \u27e8a, rfl\u27e9) <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ZeroAtFilter.smul [TopologicalSpace \u03b2] [Zero \u03b2]\n    [SMulZeroClass \ud835\udd5c \u03b2] [ContinuousConstSMul \ud835\udd5c \u03b2] {l : Filter \u03b1} {f : \u03b1 \u2192 \u03b2} (c : \ud835\udd5c)\n    (hf : ZeroAtFilter l f) : ZeroAtFilter l (c \u2022 f) := by simpa using hf.const_smul c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/ZeroAndBoundedAtFilter.lean", "context": {"open": ["Topology"], "variables": ["{\ud835\udd5c \u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nx\u271d : Sort u_4\nZeroAtFilter : x\u271d\ninst\u271d\u00b3 : TopologicalSpace \u03b2\ninst\u271d\u00b2 : Zero \u03b2\ninst\u271d\u00b9 : SMulZeroClass \ud835\udd5c \u03b2\ninst\u271d : ContinuousConstSMul \ud835\udd5c \u03b2\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\nc : \ud835\udd5c\nhf : sorry\n\u22a2 sorry"}, {"line": "simpa using hf.const_smul c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biInter_mem' {\u03b2 : Type v} {s : \u03b2 \u2192 Set \u03b1} {is : Set \u03b2} (hf : is.Subsingleton) :\n    (\u22c2 i \u2208 is, s i) \u2208 f \u2194 \u2200 i \u2208 is, s i \u2208 f := by\n  apply Subsingleton.induction_on hf <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Basic.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nf : Filter \u03b1\n\u03b2 : Type v\ns : \u03b2 \u2192 Set \u03b1\nis : Set \u03b2\nhf : is.Subsingleton\n\u22a2 \u22c2 i \u2208 is, s i \u2208 f \u2194 \u2200 i \u2208 is, s i \u2208 f"}, {"line": "apply Subsingleton.induction_on hf <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_neBot {f : \u03b9 \u2192 Filter \u03b1} : (\u2a06 i, f i).NeBot \u2194 \u2203 i, (f i).NeBot := by\n  simp [neBot_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Basic.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b9 : Sort x\nf : \u03b9 \u2192 Filter \u03b1\n\u22a2 (\u2a06 i, f i).NeBot \u2194 \u2203 i, (f i).NeBot"}, {"line": "simp [neBot_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_eq_bot_iff {f g : Filter \u03b1} : f \u2293 g = \u22a5 \u2194 \u2203 U \u2208 f, \u2203 V \u2208 g, U \u2229 V = \u2205 := by\n  simp only [\u2190 disjoint_iff]\n  simp only [Filter.disjoint_iff]\n  simp only [Set.disjoint_iff_inter_eq_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Basic.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nf g : Filter \u03b1\n\u22a2 f \u2293 g = \u22a5 \u2194 \u2203 U \u2208 f, \u2203 V \u2208 g, U \u2229 V = \u2205"}, {"line": "simp only [\u2190 disjoint_iff]", "tactic_state": "\u03b1 : Type u\nf g : Filter \u03b1\n\u22a2 Disjoint f g \u2194 \u2203 U \u2208 f, \u2203 V \u2208 g, U \u2229 V = \u2205"}, {"line": "simp only [Filter.disjoint_iff]", "tactic_state": "\u03b1 : Type u\nf g : Filter \u03b1\n\u22a2 (\u2203 s \u2208 f, \u2203 t \u2208 g, Disjoint s t) \u2194 \u2203 U \u2208 f, \u2203 V \u2208 g, U \u2229 V = \u2205"}, {"line": "simp only [Set.disjoint_iff_inter_eq_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_biInf_of_mem_iff_exists_mem {f : \u03b9 \u2192 Filter \u03b1} {p : \u03b9 \u2192 Prop} {l : Filter \u03b1}\n    (h : \u2200 {s}, s \u2208 l \u2194 \u2203 i, p i \u2227 s \u2208 f i) : l = \u2a05 (i) (_ : p i), f i := by\n  rw [iInf_subtype']\n  exact eq_iInf_of_mem_iff_exists_mem fun {_} => by simp only [Subtype.exists, h, exists_prop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Basic.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b9 : Sort x\nf : \u03b9 \u2192 Filter \u03b1\np : \u03b9 \u2192 Prop\nl : Filter \u03b1\nh : \u2200 {s : Set \u03b1}, s \u2208 l \u2194 \u2203 i, p i \u2227 s \u2208 f i\n\u22a2 l = \u2a05 i, \u2a05 (_ : p i), f i"}, {"line": "rw [iInf_subtype']", "tactic_state": "\u03b1 : Type u\n\u03b9 : Sort x\nf : \u03b9 \u2192 Filter \u03b1\np : \u03b9 \u2192 Prop\nl : Filter \u03b1\nh : \u2200 {s : Set \u03b1}, s \u2208 l \u2194 \u2203 i, p i \u2227 s \u2208 f i\n\u22a2 l = \u2a05 x, f \u2191x"}, {"line": "exact eq_iInf_of_mem_iff_exists_mem fun {_} => by simp only [Subtype.exists, h, exists_prop]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Frequently.and_eventually {p q : \u03b1 \u2192 Prop} {f : Filter \u03b1} (hp : \u2203\u1da0 x in f, p x)\n    (hq : \u2200\u1da0 x in f, q x) : \u2203\u1da0 x in f, p x \u2227 q x := by\n  refine mt (fun h => hq.mp <| h.mono ?_) hp\n  exact fun x hpq hq hp => hpq \u27e8hp, hq\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Basic.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\np q : \u03b1 \u2192 Prop\nf : Filter \u03b1\nhp : \u2203\u1da0 (x : \u03b1) in f, p x\nhq : \u2200\u1da0 (x : \u03b1) in f, q x\n\u22a2 \u2203\u1da0 (x : \u03b1) in f, p x \u2227 q x"}, {"line": "refine mt (fun h => hq.mp <| h.mono ?_) hp", "tactic_state": "\u03b1 : Type u\np q : \u03b1 \u2192 Prop\nf : Filter \u03b1\nhp : \u2203\u1da0 (x : \u03b1) in f, p x\nhq : \u2200\u1da0 (x : \u03b1) in f, q x\nh : \u2200\u1da0 (x : \u03b1) in f, \u00ac(fun x => p x \u2227 q x) x\n\u22a2 \u2200 (x : \u03b1), \u00ac(fun x => p x \u2227 q x) x \u2192 q x \u2192 \u00ac(fun x => p x) x"}, {"line": "exact fun x hpq hq hp => hpq \u27e8hp, hq\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Eventually.and_frequently {p q : \u03b1 \u2192 Prop} {f : Filter \u03b1} (hp : \u2200\u1da0 x in f, p x)\n    (hq : \u2203\u1da0 x in f, q x) : \u2203\u1da0 x in f, p x \u2227 q x := by\n  simpa only [and_comm] using hq.and_eventually hp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Basic.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\np q : \u03b1 \u2192 Prop\nf : Filter \u03b1\nhp : \u2200\u1da0 (x : \u03b1) in f, p x\nhq : \u2203\u1da0 (x : \u03b1) in f, q x\n\u22a2 \u2203\u1da0 (x : \u03b1) in f, p x \u2227 q x"}, {"line": "simpa only [and_comm] using hq.and_eventually hp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Frequently.exists {p : \u03b1 \u2192 Prop} {f : Filter \u03b1} (hp : \u2203\u1da0 x in f, p x) : \u2203 x, p x := by\n  by_contra H\n  replace H : \u2200\u1da0 x in f, \u00acp x := Eventually.of_forall (not_exists.1 H)\n  exact hp H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Basic.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\np : \u03b1 \u2192 Prop\nf : Filter \u03b1\nhp : \u2203\u1da0 (x : \u03b1) in f, p x\n\u22a2 \u2203 x, p x"}, {"line": "by_contra H", "tactic_state": "\u03b1 : Type u\np : \u03b1 \u2192 Prop\nf : Filter \u03b1\nhp : \u2203\u1da0 (x : \u03b1) in f, p x\nH : \u00ac\u2203 x, p x\n\u22a2 False"}, {"line": "replace H : \u2200\u1da0 x in f, \u00acp x := Eventually.of_forall (not_exists.1 H)", "tactic_state": "\u03b1 : Type u\np : \u03b1 \u2192 Prop\nf : Filter \u03b1\nhp : \u2203\u1da0 (x : \u03b1) in f, p x\nH : \u2200\u1da0 (x : \u03b1) in f, \u00acp x\n\u22a2 False"}, {"line": "exact hp H", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_frequently {p : \u03b1 \u2192 Prop} {f : Filter \u03b1} : (\u00ac\u2203\u1da0 x in f, p x) \u2194 \u2200\u1da0 x in f, \u00acp x := by\n  simp only [Filter.Frequently]\n  simp only [not_not]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Basic.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\np : \u03b1 \u2192 Prop\nf : Filter \u03b1\n\u22a2 (\u00ac\u2203\u1da0 (x : \u03b1) in f, p x) \u2194 \u2200\u1da0 (x : \u03b1) in f, \u00acp x"}, {"line": "simp only [Filter.Frequently]", "tactic_state": "\u03b1 : Type u\np : \u03b1 \u2192 Prop\nf : Filter \u03b1\n\u22a2 (\u00ac\u00ac\u2200\u1da0 (x : \u03b1) in f, \u00acp x) \u2194 \u2200\u1da0 (x : \u03b1) in f, \u00acp x"}, {"line": "simp only [not_not]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frequently_true_iff_neBot (f : Filter \u03b1) : (\u2203\u1da0 _ in f, True) \u2194 NeBot f := by\n  simp [frequently_iff_neBot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Basic.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_2\nNeBot : x\u271d\nf : Filter \u03b1\n\u22a2 (\u2203\u1da0 (x : \u03b1) in f, True) \u2194 sorry"}, {"line": "simp [frequently_iff_neBot]", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_2\nNeBot : x\u271d\nf : Filter \u03b1\n\u22a2 f.NeBot \u2194 sorry ()"}]}
{"declaration": "theorem frequently_false (f : Filter \u03b1) : \u00ac\u2203\u1da0 _ in f, False := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Basic.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nf : Filter \u03b1\n\u22a2 \u00ac\u2203\u1da0 (x : \u03b1) in f, False"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frequently_imp_distrib {f : Filter \u03b1} {p q : \u03b1 \u2192 Prop} :\n    (\u2203\u1da0 x in f, p x \u2192 q x) \u2194 (\u2200\u1da0 x in f, p x) \u2192 \u2203\u1da0 x in f, q x := by\n  simp [imp_iff_not_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Basic.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nf : Filter \u03b1\np q : \u03b1 \u2192 Prop\n\u22a2 (\u2203\u1da0 (x : \u03b1) in f, p x \u2192 q x) \u2194 (\u2200\u1da0 (x : \u03b1) in f, p x) \u2192 \u2203\u1da0 (x : \u03b1) in f, q x"}, {"line": "simp [imp_iff_not_or]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frequently_bot {p : \u03b1 \u2192 Prop} : \u00ac\u2203\u1da0 x in \u22a5, p x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Basic.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\np : \u03b1 \u2192 Prop\n\u22a2 \u00ac\u2203\u1da0 (x : \u03b1) in \u22a5, p x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frequently_top {p : \u03b1 \u2192 Prop} : (\u2203\u1da0 x in \u22a4, p x) \u2194 \u2203 x, p x := by simp [Filter.Frequently]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Basic.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\np : \u03b1 \u2192 Prop\n\u22a2 (\u2203\u1da0 (x : \u03b1) in \u22a4, p x) \u2194 \u2203 x, p x"}, {"line": "simp [Filter.Frequently]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Eventually.choice {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {l : Filter \u03b1} [l.NeBot] (h : \u2200\u1da0 x in l, \u2203 y, r x y) :\n    \u2203 f : \u03b1 \u2192 \u03b2, \u2200\u1da0 x in l, r x (f x) := by\n  haveI : Nonempty \u03b2 := let \u27e8_, hx\u27e9 := h.exists; hx.nonempty\n  choose! f hf using fun x (hx : \u2203 y, r x y) => hx\n  exact \u27e8f, h.mono hf\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Basic.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\nl : Filter \u03b1\ninst\u271d : l.NeBot\nh : \u2200\u1da0 (x : \u03b1) in l, \u2203 y, r x y\n\u22a2 \u2203 f, \u2200\u1da0 (x : \u03b1) in l, r x (f x)"}, {"line": "haveI : Nonempty \u03b2 := let \u27e8_, hx\u27e9 := h.exists; hx.nonempty", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\nl : Filter \u03b1\ninst\u271d : l.NeBot\nh : \u2200\u1da0 (x : \u03b1) in l, \u2203 y, r x y\nthis : Nonempty \u03b2\n\u22a2 \u2203 f, \u2200\u1da0 (x : \u03b1) in l, r x (f x)"}, {"line": "choose! f hf using fun x (hx : \u2203 y, r x y) => hx", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\nl : Filter \u03b1\ninst\u271d : l.NeBot\nh : \u2200\u1da0 (x : \u03b1) in l, \u2203 y, r x y\nthis : Nonempty \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 (x : \u03b1), (\u2203 y, r x y) \u2192 r x (f x)\n\u22a2 \u2203 f, \u2200\u1da0 (x : \u03b1) in l, r x (f x)"}, {"line": "exact \u27e8f, h.mono hf\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventuallyEq_univ {s : Set \u03b1} {l : Filter \u03b1} : s =\u1da0[l] univ \u2194 s \u2208 l := by\n  simp [eventuallyEq_set]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Basic.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}", "{l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nl : Filter \u03b1\n\u22a2 s =\u1da0[l] univ \u2194 s \u2208 l"}, {"line": "simp [eventuallyEq_set]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem EventuallyEq.sub_eq [AddGroup \u03b2] {f g : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} (h : f =\u1da0[l] g) :\n    f - g =\u1da0[l] 0 := by simpa using ((EventuallyEq.refl l f).sub h).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Basic.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}", "{l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : AddGroup \u03b2\nf g : \u03b1 \u2192 \u03b2\nl : Filter \u03b1\nh : f =\u1da0[l] g\n\u22a2 f - g =\u1da0[l] 0"}, {"line": "simpa using ((EventuallyEq.refl l f).sub h).symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma compl_mem_comk {p : Set \u03b1 \u2192 Prop} {he hmono hunion s} :\n    s\u1d9c \u2208 comk p he hmono hunion \u2194 p s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Basic.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}", "{l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[LE \u03b2] {l : Filter \u03b1}", "[Preorder \u03b2] {l : Filter \u03b1} {f g h : \u03b1 \u2192 \u03b2}", "{l : Filter \u03b1}", "{\u03b1 \u03b2 : Type*} {F : Filter \u03b1} {G : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\np : Set \u03b1 \u2192 Prop\nhe : p \u2205\nhmono : \u2200 (t : Set \u03b1), p t \u2192 \u2200 s \u2286 t, p s\nhunion : \u2200 (s : Set \u03b1), p s \u2192 \u2200 (t : Set \u03b1), p t \u2192 p (s \u222a t)\ns : Set \u03b1\n\u22a2 s\u1d9c \u2208 comk p he hmono hunion \u2194 p s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frequently_cocardinal {p : \u03b1 \u2192 Prop} :\n    (\u2203\u1da0 x in cocardinal \u03b1 hreg, p x) \u2194 c \u2264 # { x | p x } := by\n  simp only [Filter.Frequently]\n  simp only [eventually_cocardinal]\n  simp only [not_not]\n  simp only [coe_setOf]\n  simp only [not_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Cocardinal.lean", "context": {"open": ["Set Filter Cardinal"], "variables": ["{\u03b1 : Type u} {c : Cardinal.{u}} {hreg : c.IsRegular}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\np : \u03b1 \u2192 Prop\n\u22a2 (\u2203\u1da0 (x : \u03b1) in cocardinal \u03b1 hreg, p x) \u2194 c \u2264 Cardinal.mk \u2191{x | p x}"}, {"line": "simp only [Filter.Frequently]", "tactic_state": "\u03b1 : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\np : \u03b1 \u2192 Prop\n\u22a2 (\u00ac\u2200\u1da0 (x : \u03b1) in cocardinal \u03b1 hreg, \u00acp x) \u2194 c \u2264 Cardinal.mk \u2191{x | p x}"}, {"line": "simp only [eventually_cocardinal]", "tactic_state": "\u03b1 : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\np : \u03b1 \u2192 Prop\n\u22a2 \u00acCardinal.mk \u2191{x | \u00ac\u00acp x} < c \u2194 c \u2264 Cardinal.mk \u2191{x | p x}"}, {"line": "simp only [not_not]", "tactic_state": "\u03b1 : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\np : \u03b1 \u2192 Prop\n\u22a2 \u00acCardinal.mk \u2191{x | p x} < c \u2194 c \u2264 Cardinal.mk \u2191{x | p x}"}, {"line": "simp only [coe_setOf]", "tactic_state": "\u03b1 : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\np : \u03b1 \u2192 Prop\n\u22a2 \u00acCardinal.mk { x // p x } < c \u2194 c \u2264 Cardinal.mk { x // p x }"}, {"line": "simp only [not_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_cocardinal_ne (x : \u03b1) : \u2200\u1da0 a in cocardinal \u03b1 hreg, a \u2260 x := by\n  simpa [Set.finite_singleton x] using hreg.nat_lt 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Cocardinal.lean", "context": {"open": ["Set Filter Cardinal"], "variables": ["{\u03b1 : Type u} {c : Cardinal.{u}} {hreg : c.IsRegular}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\nx : \u03b1\n\u22a2 \u2200\u1da0 (a : \u03b1) in cocardinal \u03b1 hreg, a \u2260 x"}, {"line": "simpa [Set.finite_singleton x] using hreg.nat_lt 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_cocountable {s : Set \u03b1} :\n    s \u2208 cocountable \u2194 (s\u1d9c : Set \u03b1).Countable := by\n  rw [Cardinal.countable_iff_lt_aleph_one]\n  rw [mem_cocardinal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Cocardinal.lean", "context": {"open": ["Set Filter Cardinal"], "variables": ["{\u03b1 : Type u} {c : Cardinal.{u}} {hreg : c.IsRegular}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\n\u22a2 s \u2208 cocountable \u2194 s\u1d9c.Countable"}, {"line": "rw [Cardinal.countable_iff_lt_aleph_one]", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\n\u22a2 s \u2208 cocountable \u2194 Cardinal.mk \u2191s\u1d9c < aleph 1"}, {"line": "rw [mem_cocardinal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_cofinite_left : Disjoint cofinite l \u2194 \u2203 s \u2208 l, Set.Finite s := by\n  simp [l.basis_sets.disjoint_iff_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Cofinite.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nl cofinite : Filter \u03b1\n\u22a2 Disjoint cofinite l \u2194 \u2203 s \u2208 l, s.Finite"}, {"line": "simp [l.basis_sets.disjoint_iff_right]", "tactic_state": "\u03b1 : Type u_2\nl cofinite : Filter \u03b1\n\u22a2 (\u2203 i \u2208 l, i\u1d9c \u2208 cofinite) \u2194 \u2203 s \u2208 l, s.Finite"}]}
{"declaration": "lemma Set.Finite.cofinite_inf_principal_compl {s : Set \u03b1} (hs : s.Finite) :\n    cofinite \u2293 \ud835\udcdf s\u1d9c = cofinite := by\n  simpa using hs.compl_mem_cofinite\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Cofinite.lean", "context": {"open": ["Set Function", "Filter"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ns : Set \u03b1\nhs : s.Finite\n\u22a2 cofinite \u2293 principal s\u1d9c = cofinite"}, {"line": "simpa using hs.compl_mem_cofinite", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Set.Finite.cofinite_inf_principal_diff {s t : Set \u03b1} (ht : t.Finite) :\n    cofinite \u2293 \ud835\udcdf (s \\ t) = cofinite \u2293 \ud835\udcdf s := by\n  rw [diff_eq]\n  rw [\u2190 inf_principal]\n  rw [\u2190 inf_assoc]\n  rw [inf_right_comm]\n  rw [ht.cofinite_inf_principal_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Cofinite.lean", "context": {"open": ["Set Function", "Filter"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ns t : Set \u03b1\nht : t.Finite\n\u22a2 cofinite \u2293 principal (s \\ t) = cofinite \u2293 principal s"}, {"line": "rw [diff_eq]", "tactic_state": "\u03b1 : Type u_2\ns t : Set \u03b1\nht : t.Finite\n\u22a2 cofinite \u2293 principal (s \u2229 t\u1d9c) = cofinite \u2293 principal s"}, {"line": "rw [\u2190 inf_principal]", "tactic_state": "\u03b1 : Type u_2\ns t : Set \u03b1\nht : t.Finite\n\u22a2 cofinite \u2293 (principal s \u2293 principal t\u1d9c) = cofinite \u2293 principal s"}, {"line": "rw [\u2190 inf_assoc]", "tactic_state": "\u03b1 : Type u_2\ns t : Set \u03b1\nht : t.Finite\n\u22a2 cofinite \u2293 principal s \u2293 principal t\u1d9c = cofinite \u2293 principal s"}, {"line": "rw [inf_right_comm]", "tactic_state": "\u03b1 : Type u_2\ns t : Set \u03b1\nht : t.Finite\n\u22a2 cofinite \u2293 principal t\u1d9c \u2293 principal s = cofinite \u2293 principal s"}, {"line": "rw [ht.cofinite_inf_principal_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nat.cofinite_eq_atTop : @cofinite \u2115 = atTop := by\n  refine le_antisymm ?_ atTop_le_cofinite\n  refine atTop_basis.ge_iff.2 fun N _ => ?_\n  simpa only [mem_cofinite,compl_Ici] using finite_lt_nat N\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Cofinite.lean", "context": {"open": ["Set Function", "Filter"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 cofinite = atTop"}, {"line": "refine le_antisymm ?_ atTop_le_cofinite", "tactic_state": "\u22a2 cofinite \u2264 atTop"}, {"line": "refine atTop_basis.ge_iff.2 fun N _ => ?_", "tactic_state": "N : \u2115\nx\u271d : True\n\u22a2 Ici N \u2208 cofinite"}, {"line": "simpa only [mem_cofinite,compl_Ici] using finite_lt_nat N", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nat.frequently_atTop_iff_infinite {p : \u2115 \u2192 Prop} :\n    (\u2203\u1da0 n in atTop, p n) \u2194 Set.Infinite { n | p n } := by\n  rw [\u2190 Nat.cofinite_eq_atTop]\n  rw [frequently_cofinite_iff_infinite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Cofinite.lean", "context": {"open": ["Set Function", "Filter"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\n\u22a2 (\u2203\u1da0 (n : \u2115) in atTop, p n) \u2194 {n | p n}.Infinite"}, {"line": "rw [\u2190 Nat.cofinite_eq_atTop]", "tactic_state": "p : \u2115 \u2192 Prop\n\u22a2 (\u2203\u1da0 (n : \u2115) in cofinite, p n) \u2194 {n | p n}.Infinite"}, {"line": "rw [frequently_cofinite_iff_infinite]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.Tendsto.exists_within_forall_le {\u03b1 \u03b2 : Type*} [LinearOrder \u03b2] {s : Set \u03b1}\n    (hs : s.Nonempty) {f : \u03b1 \u2192 \u03b2} (hf : Filter.Tendsto f Filter.cofinite Filter.atTop) :\n    \u2203 a\u2080 \u2208 s, \u2200 a \u2208 s, f a\u2080 \u2264 f a := by\n  rcases em (\u2203 y \u2208 s, \u2203 x, f y < x) with (\u27e8y, hys, x, hx\u27e9 | not_all_top)\n  \u00b7 -- the set of points `{y | f y < x}` is nonempty and finite, so we take `min` over this set\n    have : { y | \u00acx \u2264 f y }.Finite := Filter.eventually_cofinite.mp (tendsto_atTop.1 hf x)\n    simp only [not_le] at this\n    obtain \u27e8a\u2080, \u27e8ha\u2080 : f a\u2080 < x, ha\u2080s\u27e9, others_bigger\u27e9 :=\n      exists_min_image _ f (this.inter_of_left s) \u27e8y, hx, hys\u27e9\n    refine \u27e8a\u2080, ha\u2080s, fun a has => (lt_or_le (f a) x).elim ?_ (le_trans ha\u2080.le)\u27e9\n    exact fun h => others_bigger a \u27e8h, has\u27e9\n  \u00b7 -- in this case, f is constant because all values are at top\n    push_neg at not_all_top\n    obtain \u27e8a\u2080, ha\u2080s\u27e9 := hs\n    exact \u27e8a\u2080, ha\u2080s, fun a ha => not_all_top a ha (f a\u2080)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Cofinite.lean", "context": {"open": ["Set Function", "Filter"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*} {l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d : LinearOrder \u03b2\ns : Set \u03b1\nhs : s.Nonempty\nf : \u03b1 \u2192 \u03b2\nhf : Tendsto f cofinite atTop\n\u22a2 \u2203 a\u2080 \u2208 s, \u2200 a \u2208 s, f a\u2080 \u2264 f a"}, {"line": "rcases em (\u2203 y \u2208 s, \u2203 x, f y < x) with (\u27e8y, hys, x, hx\u27e9 | not_all_top)", "tactic_state": "case inl.intro.intro.intro\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d : LinearOrder \u03b2\ns : Set \u03b1\nhs : s.Nonempty\nf : \u03b1 \u2192 \u03b2\nhf : Tendsto f cofinite atTop\ny : \u03b1\nhys : y \u2208 s\nx : \u03b2\nhx : sorry\n\u22a2 \u2203 a\u2080 \u2208 s, \u2200 a \u2208 s, f a\u2080 \u2264 f a\n---\ncase inr\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d : LinearOrder \u03b2\ns : Set \u03b1\nhs : s.Nonempty\nf : \u03b1 \u2192 \u03b2\nhf : Tendsto f cofinite atTop\nnot_all_top : \u00ac\u2203 y \u2208 s, \u2203 x, sorry\n\u22a2 \u2203 a\u2080 \u2208 s, \u2200 a \u2208 s, f a\u2080 \u2264 f a"}, {"line": "\u00b7 -- the set of points `{y | f y < x}` is nonempty and finite, so we take `min` over this set\n    have : { y | \u00acx \u2264 f y }.Finite := Filter.eventually_cofinite.mp (tendsto_atTop.1 hf x)\n    simp only [not_le] at this\n    obtain \u27e8a\u2080, \u27e8ha\u2080 : f a\u2080 < x, ha\u2080s\u27e9, others_bigger\u27e9 :=\n      exists_min_image _ f (this.inter_of_left s) \u27e8y, hx, hys\u27e9\n    refine \u27e8a\u2080, ha\u2080s, fun a has => (lt_or_le (f a) x).elim ?_ (le_trans ha\u2080.le)\u27e9\n    exact fun h => others_bigger a \u27e8h, has\u27e9", "tactic_state": "case inr\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d : LinearOrder \u03b2\ns : Set \u03b1\nhs : s.Nonempty\nf : \u03b1 \u2192 \u03b2\nhf : Tendsto f cofinite atTop\nnot_all_top : \u00ac\u2203 y \u2208 s, \u2203 x, sorry\n\u22a2 \u2203 a\u2080 \u2208 s, \u2200 a \u2208 s, f a\u2080 \u2264 f a"}, {"line": "\u00b7 -- in this case, f is constant because all values are at top\n    push_neg at not_all_top\n    obtain \u27e8a\u2080, ha\u2080s\u27e9 := hs\n    exact \u27e8a\u2080, ha\u2080s, fun a ha => not_all_top a ha (f a\u2080)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_countable_forall [Countable \u03b9] {p : \u03b1 \u2192 \u03b9 \u2192 Prop} :\n    (\u2200\u1da0 x in l, \u2200 i, p x i) \u2194 \u2200 i, \u2200\u1da0 x in l, p x i := by\n  simpa only [Filter.Eventually,setOf_forall] using\n    @countable_iInter_mem _ _ l _ _ fun i => { x | p x i }\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/CountableInter.lean", "context": {"open": ["Set Filter", "Filter"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "{l : Filter \u03b1} [CountableInterFilter l]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\nl : Filter \u03b1\ninst\u271d\u00b9 : CountableInterFilter l\ninst\u271d : Countable \u03b9\np : \u03b1 \u2192 \u03b9 \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : \u03b1) in l, \u2200 (i : \u03b9), p x i) \u2194 \u2200 (i : \u03b9), \u2200\u1da0 (x : \u03b1) in l, p x i"}, {"line": "simpa only [Filter.Eventually,setOf_forall] using\n    @countable_iInter_mem _ _ l _ _ fun i => { x | p x i }", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_countable_ball {\u03b9 : Type*} {S : Set \u03b9} (hS : S.Countable)\n    {p : \u03b1 \u2192 \u2200 i \u2208 S, Prop} :\n    (\u2200\u1da0 x in l, \u2200 i hi, p x i hi) \u2194 \u2200 i hi, \u2200\u1da0 x in l, p x i hi := by\n  simpa only [Filter.Eventually,setOf_forall] using\n    @countable_bInter_mem _ l _ _ _ hS fun i hi => { x | p x i hi }\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/CountableInter.lean", "context": {"open": ["Set Filter", "Filter"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "{l : Filter \u03b1} [CountableInterFilter l]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nl : Filter \u03b1\ninst\u271d : CountableInterFilter l\n\u03b9 : Type u_4\nS : Set \u03b9\nhS : S.Countable\np : \u03b1 \u2192 (i : \u03b9) \u2192 i \u2208 S \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : \u03b1) in l, \u2200 (i : \u03b9) (hi : i \u2208 S), p x i hi) \u2194 \u2200 (i : \u03b9) (hi : i \u2208 S), \u2200\u1da0 (x : \u03b1) in l, p x i hi"}, {"line": "simpa only [Filter.Eventually,setOf_forall] using\n    @countable_bInter_mem _ l _ _ _ hS fun i hi => { x | p x i hi }", "tactic_state": "No Goals!"}]}
{"declaration": "theorem EventuallyLE.countable_bUnion {\u03b9 : Type*} {S : Set \u03b9} (hS : S.Countable)\n    {s t : \u2200 i \u2208 S, Set \u03b1} (h : \u2200 i hi, s i hi \u2264\u1da0[l] t i hi) :\n    \u22c3 i \u2208 S, s i \u2039_\u203a \u2264\u1da0[l] \u22c3 i \u2208 S, t i \u2039_\u203a := by\n  simp only [biUnion_eq_iUnion]\n  haveI := hS.toEncodable\n  exact EventuallyLE.countable_iUnion fun i => h i i.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/CountableInter.lean", "context": {"open": ["Set Filter", "Filter"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "{l : Filter \u03b1} [CountableInterFilter l]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nl : Filter \u03b1\ninst\u271d : CountableInterFilter l\n\u03b9 : Type u_4\nS : Set \u03b9\nhS : S.Countable\ns t : (i : \u03b9) \u2192 i \u2208 S \u2192 Set \u03b1\nh : \u2200 (i : \u03b9) (hi : i \u2208 S), s i hi \u2264\u1da0[l] t i hi\n\u22a2 \u22c3 i, \u22c3 (h : i \u2208 S), s i h \u2264\u1da0[l] \u22c3 i, \u22c3 (h : i \u2208 S), t i h"}, {"line": "simp only [biUnion_eq_iUnion]", "tactic_state": "\u03b1 : Type u_2\nl : Filter \u03b1\ninst\u271d : CountableInterFilter l\n\u03b9 : Type u_4\nS : Set \u03b9\nhS : S.Countable\ns t : (i : \u03b9) \u2192 i \u2208 S \u2192 Set \u03b1\nh : \u2200 (i : \u03b9) (hi : i \u2208 S), s i hi \u2264\u1da0[l] t i hi\n\u22a2 \u22c3 x, s \u2191x \u22ef \u2264\u1da0[l] \u22c3 x, t \u2191x \u22ef"}, {"line": "haveI := hS.toEncodable", "tactic_state": "\u03b1 : Type u_2\nl : Filter \u03b1\ninst\u271d : CountableInterFilter l\n\u03b9 : Type u_4\nS : Set \u03b9\nhS : S.Countable\ns t : (i : \u03b9) \u2192 i \u2208 S \u2192 Set \u03b1\nh : \u2200 (i : \u03b9) (hi : i \u2208 S), s i hi \u2264\u1da0[l] t i hi\nthis : Encodable \u2191S\n\u22a2 \u22c3 x, s \u2191x \u22ef \u2264\u1da0[l] \u22c3 x, t \u2191x \u22ef"}, {"line": "exact EventuallyLE.countable_iUnion fun i => h i i.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem EventuallyLE.countable_bInter {\u03b9 : Type*} {S : Set \u03b9} (hS : S.Countable)\n    {s t : \u2200 i \u2208 S, Set \u03b1} (h : \u2200 i hi, s i hi \u2264\u1da0[l] t i hi) :\n    \u22c2 i \u2208 S, s i \u2039_\u203a \u2264\u1da0[l] \u22c2 i \u2208 S, t i \u2039_\u203a := by\n  simp only [biInter_eq_iInter]\n  haveI := hS.toEncodable\n  exact EventuallyLE.countable_iInter fun i => h i i.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/CountableInter.lean", "context": {"open": ["Set Filter", "Filter"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "{l : Filter \u03b1} [CountableInterFilter l]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nl : Filter \u03b1\ninst\u271d : CountableInterFilter l\n\u03b9 : Type u_4\nS : Set \u03b9\nhS : S.Countable\ns t : (i : \u03b9) \u2192 i \u2208 S \u2192 Set \u03b1\nh : \u2200 (i : \u03b9) (hi : i \u2208 S), s i hi \u2264\u1da0[l] t i hi\n\u22a2 \u22c2 i, \u22c2 (h : i \u2208 S), s i h \u2264\u1da0[l] \u22c2 i, \u22c2 (h : i \u2208 S), t i h"}, {"line": "simp only [biInter_eq_iInter]", "tactic_state": "\u03b1 : Type u_2\nl : Filter \u03b1\ninst\u271d : CountableInterFilter l\n\u03b9 : Type u_4\nS : Set \u03b9\nhS : S.Countable\ns t : (i : \u03b9) \u2192 i \u2208 S \u2192 Set \u03b1\nh : \u2200 (i : \u03b9) (hi : i \u2208 S), s i hi \u2264\u1da0[l] t i hi\n\u22a2 \u22c2 x, s \u2191x \u22ef \u2264\u1da0[l] \u22c2 x, t \u2191x \u22ef"}, {"line": "haveI := hS.toEncodable", "tactic_state": "\u03b1 : Type u_2\nl : Filter \u03b1\ninst\u271d : CountableInterFilter l\n\u03b9 : Type u_4\nS : Set \u03b9\nhS : S.Countable\ns t : (i : \u03b9) \u2192 i \u2208 S \u2192 Set \u03b1\nh : \u2200 (i : \u03b9) (hi : i \u2208 S), s i hi \u2264\u1da0[l] t i hi\nthis : Encodable \u2191S\n\u22a2 \u22c2 x, s \u2191x \u22ef \u2264\u1da0[l] \u22c2 x, t \u2191x \u22ef"}, {"line": "exact EventuallyLE.countable_iInter fun i => h i i.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_countableGenerate_iff {s : Set \u03b1} :\n    s \u2208 countableGenerate g \u2194 \u2203 S : Set (Set \u03b1), S \u2286 g \u2227 S.Countable \u2227 \u22c2\u2080 S \u2286 s := by\n  constructor <;> intro h\n  \u00b7 induction h with\n    | @basic s hs => exact \u27e8{s}, by simp [hs, subset_refl]\u27e9\n    | univ => exact \u27e8\u2205, by simp\u27e9\n    | superset _ _ ih => refine Exists.imp (fun S => ?_) ih; tauto\n    | @sInter S Sct _ ih =>\n      choose T Tg Tct hT using ih\n      refine \u27e8\u22c3 (s) (H : s \u2208 S), T s H, by simpa, Sct.biUnion Tct, ?_\u27e9\n      apply subset_sInter\n      intro s H\n      exact subset_trans (sInter_subset_sInter (subset_iUnion\u2082 s H)) (hT s H)\n  rcases h with \u27e8S, Sg, Sct, hS\u27e9\n  refine mem_of_superset ((countable_sInter_mem Sct).mpr ?_) hS\n  intro s H\n  exact CountableGenerateSets.basic (Sg H)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/CountableInter.lean", "context": {"open": ["Set Filter", "Filter"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "{l : Filter \u03b1} [CountableInterFilter l]", "(g : Set (Set \u03b1))", "{g}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ng : Set (Set \u03b1)\ns : Set \u03b1\n\u22a2 s \u2208 countableGenerate g \u2194 \u2203 S \u2286 g, S.Countable \u2227 \u22c2\u2080 S \u2286 s"}, {"line": "constructor <;> intro h", "tactic_state": "case mp\n\u03b1 : Type u_2\ng : Set (Set \u03b1)\ns : Set \u03b1\nh : s \u2208 countableGenerate g\n\u22a2 \u2203 S \u2286 g, S.Countable \u2227 \u22c2\u2080 S \u2286 s\n---\ncase mpr\n\u03b1 : Type u_2\ng : Set (Set \u03b1)\ns : Set \u03b1\nh : \u2203 S \u2286 g, S.Countable \u2227 \u22c2\u2080 S \u2286 s\n\u22a2 s \u2208 countableGenerate g"}, {"line": "\u00b7 induction h with\n    | @basic s hs => exact \u27e8{s}, by simp [hs, subset_refl]\u27e9\n    | univ => exact \u27e8\u2205, by simp\u27e9\n    | superset _ _ ih => refine Exists.imp (fun S => ?_) ih; tauto\n    | @sInter S Sct _ ih =>\n      choose T Tg Tct hT using ih\n      refine \u27e8\u22c3 (s) (H : s \u2208 S), T s H, by simpa, Sct.biUnion Tct, ?_\u27e9\n      apply subset_sInter\n      intro s H\n      exact subset_trans (sInter_subset_sInter (subset_iUnion\u2082 s H)) (hT s H)", "tactic_state": "case mpr\n\u03b1 : Type u_2\ng : Set (Set \u03b1)\ns : Set \u03b1\nh : \u2203 S \u2286 g, S.Countable \u2227 \u22c2\u2080 S \u2286 s\n\u22a2 s \u2208 countableGenerate g"}, {"line": "rcases h with \u27e8S, Sg, Sct, hS\u27e9", "tactic_state": "case mpr.intro.intro.intro\n\u03b1 : Type u_2\ng : Set (Set \u03b1)\ns : Set \u03b1\nS : Set (Set \u03b1)\nSg : S \u2286 g\nSct : S.Countable\nhS : \u22c2\u2080 S \u2286 s\n\u22a2 s \u2208 countableGenerate g"}, {"line": "refine mem_of_superset ((countable_sInter_mem Sct).mpr ?_) hS", "tactic_state": "case mpr.intro.intro.intro\n\u03b1 : Type u_2\ng : Set (Set \u03b1)\ns : Set \u03b1\nS : Set (Set \u03b1)\nSg : S \u2286 g\nSct : S.Countable\nhS : \u22c2\u2080 S \u2286 s\n\u22a2 \u2200 s \u2208 S, s \u2208 countableGenerate g"}, {"line": "intro s H", "tactic_state": "case mpr.intro.intro.intro\n\u03b1 : Type u_2\ng : Set (Set \u03b1)\ns\u271d : Set \u03b1\nS : Set (Set \u03b1)\nSg : S \u2286 g\nSct : S.Countable\nhS : \u22c2\u2080 S \u2286 s\u271d\ns : Set \u03b1\nH : s \u2208 S\n\u22a2 s \u2208 countableGenerate g"}, {"line": "exact CountableGenerateSets.basic (Sg H)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem countableGenerate_isGreatest :\n    IsGreatest { f : Filter \u03b1 | CountableInterFilter f \u2227 g \u2286 f.sets } (countableGenerate g) := by\n  refine \u27e8\u27e8inferInstance, fun s => CountableGenerateSets.basic\u27e9, ?_\u27e9\n  rintro f \u27e8fct, hf\u27e9\n  rwa [@le_countableGenerate_iff_of_countableInterFilter _ _ _ fct]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/CountableInter.lean", "context": {"open": ["Set Filter", "Filter"], "variables": ["{\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}", "{l : Filter \u03b1} [CountableInterFilter l]", "(g : Set (Set \u03b1))", "{g}", "(g)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ng : Set (Set \u03b1)\n\u22a2 IsGreatest {f | CountableInterFilter f \u2227 g \u2286 f.sets} (countableGenerate g)"}, {"line": "refine \u27e8\u27e8inferInstance, fun s => CountableGenerateSets.basic\u27e9, ?_\u27e9", "tactic_state": "\u03b1 : Type u_2\ng : Set (Set \u03b1)\n\u22a2 countableGenerate g \u2208 upperBounds {f | CountableInterFilter f \u2227 g \u2286 f.sets}"}, {"line": "rintro f \u27e8fct, hf\u27e9", "tactic_state": "case intro\n\u03b1 : Type u_2\ng : Set (Set \u03b1)\nf : Filter \u03b1\nfct : CountableInterFilter f\nhf : g \u2286 f.sets\n\u22a2 f \u2264 countableGenerate g"}, {"line": "rwa [@le_countableGenerate_iff_of_countableInterFilter _ _ _ fct]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frequently_curry_prod_iff :\n    (\u2203\u1da0 x in l.curry m, x \u2208 s \u00d7\u02e2 t) \u2194 (\u2203\u1da0 x in l, x \u2208 s) \u2227 \u2203\u1da0 y in m, y \u2208 t := by\n  simp [frequently_curry_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Curry.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {l : Filter \u03b1} {m : Filter \u03b2} {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\nm : Filter \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 (\u2203\u1da0 (x : \u03b1 \u00d7 \u03b2) in l.curry m, x \u2208 s \u00d7\u02e2 t) \u2194 (\u2203\u1da0 (x : \u03b1) in l, x \u2208 s) \u2227 \u2203\u1da0 (y : \u03b2) in m, y \u2208 t"}, {"line": "simp [frequently_curry_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\nm : Filter \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 (\u2203\u1da0 (x : \u03b1 \u00d7 \u03b2) in l.curry m, x.1 \u2208 s \u2227 x.2 \u2208 t) \u2194 (\u2203\u1da0 (x : \u03b1) in l, x \u2208 s) \u2227 \u2203\u1da0 (y : \u03b2) in m, y \u2208 t"}]}
{"declaration": "theorem Filter.EventuallyLE.isMaxFilter {\u03b1 \u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1}\n    {l : Filter \u03b1} (hle : g \u2264\u1da0[l] f) (hfga : f a = g a) (h : IsMaxFilter f l a) :\n    IsMaxFilter g l a := by\n  refine hle.mp (h.mono fun x hf hgf => ?_)\n  rw [\u2190 hfga]\n  exact le_trans hgf hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Extr.lean", "context": {"open": ["Set Filter Relator", "Filter", "OrderDual (toDual)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type x}", "[Preorder \u03b2] [Preorder \u03b3]", "(f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (l : Filter \u03b1) (a : \u03b1)", "{f s a l} {t : Set \u03b1} {l' : Filter \u03b1}", "[AddCommMonoid \u03b2] [PartialOrder \u03b2] [IsOrderedAddMonoid \u03b2]", "[AddCommGroup \u03b2] [PartialOrder \u03b2] [IsOrderedAddMonoid \u03b2]", "[SemilatticeSup \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1} {l : Filter \u03b1}", "[SemilatticeInf \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1} {l : Filter \u03b1}", "[LinearOrder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1} {l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Preorder \u03b2\nf g : \u03b1 \u2192 \u03b2\na : \u03b1\nl : Filter \u03b1\nhle : g \u2264\u1da0[l] f\nhfga : f a = g a\nh : IsMaxFilter f l a\n\u22a2 IsMaxFilter g l a"}, {"line": "refine hle.mp (h.mono fun x hf hgf => ?_)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Preorder \u03b2\nf g : \u03b1 \u2192 \u03b2\na : \u03b1\nl : Filter \u03b1\nhle : g \u2264\u1da0[l] f\nhfga : f a = g a\nh : IsMaxFilter f l a\nx : \u03b1\nhf : f x \u2264 f a\nhgf : g x \u2264 f x\n\u22a2 g x \u2264 g a"}, {"line": "rw [\u2190 hfga]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Preorder \u03b2\nf g : \u03b1 \u2192 \u03b2\na : \u03b1\nl : Filter \u03b1\nhle : g \u2264\u1da0[l] f\nhfga : f a = g a\nh : IsMaxFilter f l a\nx : \u03b1\nhf : f x \u2264 f a\nhgf : g x \u2264 f x\n\u22a2 g x \u2264 f a"}, {"line": "exact le_trans hgf hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_iInf_of_finite {\u03b9 : Sort*} [Finite \u03b9] {\u03b1 : Type*} {f : \u03b9 \u2192 Filter \u03b1} (s) :\n    (s \u2208 \u2a05 i, f i) \u2194 \u2203 t : \u03b9 \u2192 Set \u03b1, (\u2200 i, t i \u2208 f i) \u2227 s = \u22c2 i, t i := by\n  refine \u27e8exists_iInter_of_mem_iInf, ?_\u27e9\n  rintro \u27e8t, ht, rfl\u27e9\n  exact iInter_mem.2 fun i => mem_iInf_of_mem i (ht i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Finite.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_2\ninst\u271d : Finite \u03b9\n\u03b1 : Type u_3\nf : \u03b9 \u2192 Filter \u03b1\ns : Set \u03b1\n\u22a2 s \u2208 \u2a05 i, f i \u2194 \u2203 t, (\u2200 (i : \u03b9), t i \u2208 f i) \u2227 s = \u22c2 i, t i"}, {"line": "refine \u27e8exists_iInter_of_mem_iInf, ?_\u27e9", "tactic_state": "\u03b9 : Sort u_2\ninst\u271d : Finite \u03b9\n\u03b1 : Type u_3\nf : \u03b9 \u2192 Filter \u03b1\ns : Set \u03b1\n\u22a2 (\u2203 t, (\u2200 (i : \u03b9), t i \u2208 f i) \u2227 s = \u22c2 i, t i) \u2192 s \u2208 \u2a05 i, f i"}, {"line": "rintro \u27e8t, ht, rfl\u27e9", "tactic_state": "case intro.intro\n\u03b9 : Sort u_2\ninst\u271d : Finite \u03b9\n\u03b1 : Type u_3\nf : \u03b9 \u2192 Filter \u03b1\nt : \u03b9 \u2192 Set \u03b1\nht : \u2200 (i : \u03b9), t i \u2208 f i\n\u22a2 \u22c2 i, t i \u2208 \u2a05 i, f i"}, {"line": "exact iInter_mem.2 fun i => mem_iInf_of_mem i (ht i)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Pairwise.exists_mem_filter_of_disjoint {\u03b9 : Type*} [Finite \u03b9] {l : \u03b9 \u2192 Filter \u03b1}\n    (hd : Pairwise (Disjoint on l)) :\n    \u2203 s : \u03b9 \u2192 Set \u03b1, (\u2200 i, s i \u2208 l i) \u2227 Pairwise (Disjoint on s) := by\n  have : Pairwise fun i j => \u2203 (s : {s // s \u2208 l i}) (t : {t // t \u2208 l j}), Disjoint s.1 t.1 := by\n    simpa only [Pairwise,Function.onFun,Filter.disjoint_iff,exists_prop,Subtype.exists] using hd\n  choose! s t hst using this\n  refine \u27e8fun i => \u22c2 j, @s i j \u2229 @t j i, fun i => ?_, fun i j hij => ?_\u27e9\n  exacts [iInter_mem.2 fun j => inter_mem (@s i j).2 (@t j i).2,\n    (hst hij).mono ((iInter_subset _ j).trans inter_subset_left)\n      ((iInter_subset _ i).trans inter_subset_right)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Finite.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_2\ninst\u271d : Finite \u03b9\nl : \u03b9 \u2192 Filter \u03b1\nhd : Pairwise (onFun Disjoint l)\n\u22a2 \u2203 s, (\u2200 (i : \u03b9), s i \u2208 l i) \u2227 Pairwise (onFun Disjoint s)"}, {"line": "have : Pairwise fun i j => \u2203 (s : {s // s \u2208 l i}) (t : {t // t \u2208 l j}), Disjoint s.1 t.1 := by\n    simpa only [Pairwise,Function.onFun,Filter.disjoint_iff,exists_prop,Subtype.exists] using hd", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_2\ninst\u271d : Finite \u03b9\nl : \u03b9 \u2192 Filter \u03b1\nhd : Pairwise (onFun Disjoint l)\nthis : Pairwise fun i j => \u2203 s t, Disjoint \u2191s \u2191t\n\u22a2 \u2203 s, (\u2200 (i : \u03b9), s i \u2208 l i) \u2227 Pairwise (onFun Disjoint s)"}, {"line": "choose! s t hst using this", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_2\ninst\u271d : Finite \u03b9\nl : \u03b9 \u2192 Filter \u03b1\nhd : Pairwise (onFun Disjoint l)\ns : \u2983i : \u03b9\u2984 \u2192 \u2983j : \u03b9\u2984 \u2192 { s // s \u2208 l i }\nt : \u2983i : \u03b9\u2984 \u2192 \u2983j : \u03b9\u2984 \u2192 { t // t \u2208 l j }\nhst : \u2200 \u2983i j : \u03b9\u2984, i \u2260 j \u2192 Disjoint \u2191s \u2191t\n\u22a2 \u2203 s, (\u2200 (i : \u03b9), s i \u2208 l i) \u2227 Pairwise (onFun Disjoint s)"}, {"line": "refine \u27e8fun i => \u22c2 j, @s i j \u2229 @t j i, fun i => ?_, fun i j hij => ?_\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u\n\u03b9 : Type u_2\ninst\u271d : Finite \u03b9\nl : \u03b9 \u2192 Filter \u03b1\nhd : Pairwise (onFun Disjoint l)\ns : \u2983i : \u03b9\u2984 \u2192 \u2983j : \u03b9\u2984 \u2192 { s // s \u2208 l i }\nt : \u2983i : \u03b9\u2984 \u2192 \u2983j : \u03b9\u2984 \u2192 { t // t \u2208 l j }\nhst : \u2200 \u2983i j : \u03b9\u2984, i \u2260 j \u2192 Disjoint \u2191s \u2191t\ni : \u03b9\n\u22a2 (fun i => \u22c2 j, \u2191s \u2229 \u2191t) i \u2208 l i\n---\ncase refine_2\n\u03b1 : Type u\n\u03b9 : Type u_2\ninst\u271d : Finite \u03b9\nl : \u03b9 \u2192 Filter \u03b1\nhd : Pairwise (onFun Disjoint l)\ns : \u2983i : \u03b9\u2984 \u2192 \u2983j : \u03b9\u2984 \u2192 { s // s \u2208 l i }\nt : \u2983i : \u03b9\u2984 \u2192 \u2983j : \u03b9\u2984 \u2192 { t // t \u2208 l j }\nhst : \u2200 \u2983i j : \u03b9\u2984, i \u2260 j \u2192 Disjoint \u2191s \u2191t\ni j : \u03b9\nhij : i \u2260 j\n\u22a2 onFun Disjoint (fun i => \u22c2 j, \u2191s \u2229 \u2191t) i j"}, {"line": "exacts [iInter_mem.2 fun j => inter_mem (@s i j).2 (@t j i).2,\n    (hst hij).mono ((iInter_subset _ j).trans inter_subset_left)\n      ((iInter_subset _ i).trans inter_subset_right)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Set.PairwiseDisjoint.exists_mem_filter {\u03b9 : Type*} {l : \u03b9 \u2192 Filter \u03b1} {t : Set \u03b9}\n    (hd : t.PairwiseDisjoint l) (ht : t.Finite) :\n    \u2203 s : \u03b9 \u2192 Set \u03b1, (\u2200 i, s i \u2208 l i) \u2227 t.PairwiseDisjoint s := by\n  haveI := ht.to_subtype\n  rcases (hd.subtype _ _).exists_mem_filter_of_disjoint with \u27e8s, hsl, hsd\u27e9\n  lift s to (i : t) \u2192 {s // s \u2208 l i} using hsl\n  rcases @Subtype.exists_pi_extension \u03b9 (fun i => { s // s \u2208 l i }) _ _ s with \u27e8s, rfl\u27e9\n  exact \u27e8fun i => s i, fun i => (s i).2, hsd.set_of_subtype _ _\u27e9\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Finite.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_2\nl : \u03b9 \u2192 Filter \u03b1\nt : Set \u03b9\nhd : t.PairwiseDisjoint l\nht : t.Finite\n\u22a2 \u2203 s, (\u2200 (i : \u03b9), s i \u2208 l i) \u2227 t.PairwiseDisjoint s"}, {"line": "haveI := ht.to_subtype", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_2\nl : \u03b9 \u2192 Filter \u03b1\nt : Set \u03b9\nhd : t.PairwiseDisjoint l\nht : t.Finite\nthis : Finite \u2191t\n\u22a2 \u2203 s, (\u2200 (i : \u03b9), s i \u2208 l i) \u2227 t.PairwiseDisjoint s"}, {"line": "rcases (hd.subtype _ _).exists_mem_filter_of_disjoint with \u27e8s, hsl, hsd\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\n\u03b9 : Type u_2\nl : \u03b9 \u2192 Filter \u03b1\nt : Set \u03b9\nhd : t.PairwiseDisjoint l\nht : t.Finite\nthis : Finite \u2191t\ns : \u2191t \u2192 Set \u03b1\nhsl : \u2200 (i : \u2191t), s i \u2208 l \u2191i\nhsd : Pairwise (onFun Disjoint s)\n\u22a2 \u2203 s, (\u2200 (i : \u03b9), s i \u2208 l i) \u2227 t.PairwiseDisjoint s"}, {"line": "lift s to (i : t) \u2192 {s // s \u2208 l i} using hsl", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u\n\u03b9 : Type u_2\nl : \u03b9 \u2192 Filter \u03b1\nt : Set \u03b9\nhd : t.PairwiseDisjoint l\nht : t.Finite\nthis : Finite \u2191t\ns : (i : \u2191t) \u2192 { s // s \u2208 l \u2191i }\nhsd : Pairwise (onFun Disjoint fun i => \u2191(s i))\n\u22a2 \u2203 s, (\u2200 (i : \u03b9), s i \u2208 l i) \u2227 t.PairwiseDisjoint s"}, {"line": "rcases @Subtype.exists_pi_extension \u03b9 (fun i => { s // s \u2208 l i }) _ _ s with \u27e8s, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u\n\u03b9 : Type u_2\nl : \u03b9 \u2192 Filter \u03b1\nt : Set \u03b9\nhd : t.PairwiseDisjoint l\nht : t.Finite\nthis : Finite \u2191t\ns : (i : \u03b9) \u2192 { s // s \u2208 l i }\nhsd : Pairwise (onFun Disjoint fun i => \u2191((fun i => s \u2191i) i))\n\u22a2 \u2203 s, (\u2200 (i : \u03b9), s i \u2208 l i) \u2227 t.PairwiseDisjoint s"}, {"line": "exact \u27e8fun i => s i, fun i => (s i).2, hsd.set_of_subtype _ _\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_all {\u03b9 : Sort*} [Finite \u03b9] {l} {p : \u03b9 \u2192 \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in l, \u2200 i, p i x) \u2194 \u2200 i, \u2200\u1da0 x in l, p i x := by\n  simpa only [Filter.Eventually,setOf_forall] using iInter_mem\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Finite.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b9 : Sort u_2\ninst\u271d : Finite \u03b9\nl : Filter \u03b1\np : \u03b9 \u2192 \u03b1 \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : \u03b1) in l, \u2200 (i : \u03b9), p i x) \u2194 \u2200 (i : \u03b9), \u2200\u1da0 (x : \u03b1) in l, p i x"}, {"line": "simpa only [Filter.Eventually,setOf_forall] using iInter_mem", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_all_finite {\u03b9} {I : Set \u03b9} (hI : I.Finite) {l} {p : \u03b9 \u2192 \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in l, \u2200 i \u2208 I, p i x) \u2194 \u2200 i \u2208 I, \u2200\u1da0 x in l, p i x := by\n  simpa only [Filter.Eventually,setOf_forall] using biInter_mem hI\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Finite.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_2\nI : Set \u03b9\nhI : I.Finite\nl : Filter \u03b1\np : \u03b9 \u2192 \u03b1 \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : \u03b1) in l, \u2200 i \u2208 I, p i x) \u2194 \u2200 i \u2208 I, \u2200\u1da0 (x : \u03b1) in l, p i x"}, {"line": "simpa only [Filter.Eventually,setOf_forall] using biInter_mem hI", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.Set.Finite.eventuallyLE_iUnion {\u03b9 : Type*} {s : Set \u03b9} (hs : s.Finite)\n    {f g : \u03b9 \u2192 Set \u03b1} (hle : \u2200 i \u2208 s, f i \u2264\u1da0[l] g i) : (\u22c3 i \u2208 s, f i) \u2264\u1da0[l] (\u22c3 i \u2208 s, g i) := by\n  have := hs.to_subtype\n  rw [biUnion_eq_iUnion]\n  rw [biUnion_eq_iUnion]\n  exact .iUnion fun i \u21a6 hle i.1 i.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Finite.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}", "{l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2}", "{l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl : Filter \u03b1\n\u03b9 : Type u_2\ns : Set \u03b9\nhs : s.Finite\nf g : \u03b9 \u2192 Set \u03b1\nhle : \u2200 i \u2208 s, f i \u2264\u1da0[l] g i\n\u22a2 \u22c3 i \u2208 s, f i \u2264\u1da0[l] \u22c3 i \u2208 s, g i"}, {"line": "have := hs.to_subtype", "tactic_state": "\u03b1 : Type u\nl : Filter \u03b1\n\u03b9 : Type u_2\ns : Set \u03b9\nhs : s.Finite\nf g : \u03b9 \u2192 Set \u03b1\nhle : \u2200 i \u2208 s, f i \u2264\u1da0[l] g i\nthis : Finite \u2191s\n\u22a2 \u22c3 i \u2208 s, f i \u2264\u1da0[l] \u22c3 i \u2208 s, g i"}, {"line": "rw [biUnion_eq_iUnion]", "tactic_state": "\u03b1 : Type u\nl : Filter \u03b1\n\u03b9 : Type u_2\ns : Set \u03b9\nhs : s.Finite\nf g : \u03b9 \u2192 Set \u03b1\nhle : \u2200 i \u2208 s, f i \u2264\u1da0[l] g i\nthis : Finite \u2191s\n\u22a2 \u22c3 x, f \u2191x \u2264\u1da0[l] \u22c3 i \u2208 s, g i"}, {"line": "rw [biUnion_eq_iUnion]", "tactic_state": "\u03b1 : Type u\nl : Filter \u03b1\n\u03b9 : Type u_2\ns : Set \u03b9\nhs : s.Finite\nf g : \u03b9 \u2192 Set \u03b1\nhle : \u2200 i \u2208 s, f i \u2264\u1da0[l] g i\nthis : Finite \u2191s\n\u22a2 \u22c3 x, f \u2191x \u2264\u1da0[l] \u22c3 x, g \u2191x"}, {"line": "exact .iUnion fun i \u21a6 hle i.1 i.2", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.Set.Finite.eventuallyLE_iInter {\u03b9 : Type*} {s : Set \u03b9} (hs : s.Finite)\n    {f g : \u03b9 \u2192 Set \u03b1} (hle : \u2200 i \u2208 s, f i \u2264\u1da0[l] g i) : (\u22c2 i \u2208 s, f i) \u2264\u1da0[l] (\u22c2 i \u2208 s, g i) := by\n  have := hs.to_subtype\n  rw [biInter_eq_iInter]\n  rw [biInter_eq_iInter]\n  exact .iInter fun i \u21a6 hle i.1 i.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Finite.lean", "context": {"open": ["Function Set Order", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03b9 : Sort x}", "{f g : Filter \u03b1} {s t : Set \u03b1}", "{l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2}", "{l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl : Filter \u03b1\n\u03b9 : Type u_2\ns : Set \u03b9\nhs : s.Finite\nf g : \u03b9 \u2192 Set \u03b1\nhle : \u2200 i \u2208 s, f i \u2264\u1da0[l] g i\n\u22a2 \u22c2 i \u2208 s, f i \u2264\u1da0[l] \u22c2 i \u2208 s, g i"}, {"line": "have := hs.to_subtype", "tactic_state": "\u03b1 : Type u\nl : Filter \u03b1\n\u03b9 : Type u_2\ns : Set \u03b9\nhs : s.Finite\nf g : \u03b9 \u2192 Set \u03b1\nhle : \u2200 i \u2208 s, f i \u2264\u1da0[l] g i\nthis : Finite \u2191s\n\u22a2 \u22c2 i \u2208 s, f i \u2264\u1da0[l] \u22c2 i \u2208 s, g i"}, {"line": "rw [biInter_eq_iInter]", "tactic_state": "\u03b1 : Type u\nl : Filter \u03b1\n\u03b9 : Type u_2\ns : Set \u03b9\nhs : s.Finite\nf g : \u03b9 \u2192 Set \u03b1\nhle : \u2200 i \u2208 s, f i \u2264\u1da0[l] g i\nthis : Finite \u2191s\n\u22a2 \u22c2 x, f \u2191x \u2264\u1da0[l] \u22c2 i \u2208 s, g i"}, {"line": "rw [biInter_eq_iInter]", "tactic_state": "\u03b1 : Type u\nl : Filter \u03b1\n\u03b9 : Type u_2\ns : Set \u03b9\nhs : s.Finite\nf g : \u03b9 \u2192 Set \u03b1\nhle : \u2200 i \u2208 s, f i \u2264\u1da0[l] g i\nthis : Finite \u2191s\n\u22a2 \u22c2 x, f \u2191x \u2264\u1da0[l] \u22c2 x, g \u2191x"}, {"line": "exact .iInter fun i \u21a6 hle i.1 i.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Monotone.mulIndicator_eventuallyEq_iUnion {\u03b9} [Preorder \u03b9] [One \u03b2] (s : \u03b9 \u2192 Set \u03b1)\n    (hs : Monotone s) (f : \u03b1 \u2192 \u03b2) (a : \u03b1) :\n    (fun i => mulIndicator (s i) f a) =\u1da0[atTop] fun _ \u21a6 mulIndicator (\u22c3 i, s i) f a := by\n  classical exact hs.piecewise_eventually_eq_iUnion f 1 a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/IndicatorFunction.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 M E : Type*}", "[One M] {s t : Set \u03b1} {f g : \u03b1 \u2192 M} {a : \u03b1} {l : Filter \u03b1}", "[Monoid M] {s t : Set \u03b1} {f g : \u03b1 \u2192 M} {a : \u03b1} {l : Filter \u03b1}", "[One \u03b2] [Preorder \u03b2] {s t : Set \u03b1} {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} {l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : One \u03b2\ninst\u271d\u00b2 : Preorder \u03b2\n\u03b9 : Type u_5\ninst\u271d\u00b9 : Preorder \u03b9\ninst\u271d : One \u03b2\ns : \u03b9 \u2192 Set \u03b1\nhs : Monotone s\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 (fun i => (s i).mulIndicator f a) =\u1da0[atTop] fun x => (\u22c3 i, s i).mulIndicator f a"}, {"line": "classical exact hs.piecewise_eventually_eq_iUnion f 1 a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antitone.mulIndicator_eventuallyEq_iInter {\u03b9} [Preorder \u03b9] [One \u03b2] (s : \u03b9 \u2192 Set \u03b1)\n    (hs : Antitone s) (f : \u03b1 \u2192 \u03b2) (a : \u03b1) :\n    (fun i => mulIndicator (s i) f a) =\u1da0[atTop] fun _ \u21a6 mulIndicator (\u22c2 i, s i) f a := by\n  classical exact hs.piecewise_eventually_eq_iInter f 1 a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/IndicatorFunction.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 M E : Type*}", "[One M] {s t : Set \u03b1} {f g : \u03b1 \u2192 M} {a : \u03b1} {l : Filter \u03b1}", "[Monoid M] {s t : Set \u03b1} {f g : \u03b1 \u2192 M} {a : \u03b1} {l : Filter \u03b1}", "[One \u03b2] [Preorder \u03b2] {s t : Set \u03b1} {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} {l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : One \u03b2\ninst\u271d\u00b2 : Preorder \u03b2\n\u03b9 : Type u_5\ninst\u271d\u00b9 : Preorder \u03b9\ninst\u271d : One \u03b2\ns : \u03b9 \u2192 Set \u03b1\nhs : Antitone s\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 (fun i => (s i).mulIndicator f a) =\u1da0[atTop] fun x => (\u22c2 i, s i).mulIndicator f a"}, {"line": "classical exact hs.piecewise_eventually_eq_iInter f 1 a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.EventuallyEq.of_mulIndicator [One \u03b2] {l : Filter \u03b1} {f : \u03b1 \u2192 \u03b2}\n    (hf : \u2200\u1da0 x in l, f x \u2260 1) {s t : Set \u03b1} (h : s.mulIndicator f =\u1da0[l] t.mulIndicator f) :\n    s =\u1da0[l] t := by\n  have : \u2200 {s : Set \u03b1}, Function.mulSupport (s.mulIndicator f) =\u1da0[l] s := fun {s} \u21a6 by\n    rw [mulSupport_mulIndicator]\n    exact (hf.mono fun x hx \u21a6 and_iff_left hx).set_eq\n  exact this.symm.trans <| h.mulSupport.trans this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/IndicatorFunction.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 M E : Type*}", "[One M] {s t : Set \u03b1} {f g : \u03b1 \u2192 M} {a : \u03b1} {l : Filter \u03b1}", "[Monoid M] {s t : Set \u03b1} {f g : \u03b1 \u2192 M} {a : \u03b1} {l : Filter \u03b1}", "[One \u03b2] [Preorder \u03b2] {s t : Set \u03b1} {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} {l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : One \u03b2\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : One \u03b2\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : \u2200\u1da0 (x : \u03b1) in l, f x \u2260 1\ns t : Set \u03b1\nh : s.mulIndicator f =\u1da0[l] t.mulIndicator f\n\u22a2 s =\u1da0[l] t"}, {"line": "have : \u2200 {s : Set \u03b1}, Function.mulSupport (s.mulIndicator f) =\u1da0[l] s := fun {s} \u21a6 by\n    rw [mulSupport_mulIndicator]\n    exact (hf.mono fun x hx \u21a6 and_iff_left hx).set_eq", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : One \u03b2\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : One \u03b2\nl : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : \u2200\u1da0 (x : \u03b1) in l, f x \u2260 1\ns t : Set \u03b1\nh : s.mulIndicator f =\u1da0[l] t.mulIndicator f\nthis : \u2200 {s : Set \u03b1}, sorry =\u1da0[l] s\n\u22a2 s =\u1da0[l] t"}, {"line": "exact this.symm.trans <| h.mulSupport.trans this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isBounded_bot : IsBounded r \u22a5 \u2194 Nonempty \u03b1 := by simp [IsBounded, exists_true_iff_nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/IsBounded.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} {f g : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_5\nIsBounded : x\u271d\n\u22a2 sorry \u2194 Nonempty \u03b1"}, {"line": "simp [IsBounded, exists_true_iff_nonempty]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_5\nIsBounded : x\u271d\n\u22a2 sorry () \u2194 Nonempty \u03b1"}]}
{"declaration": "theorem isBounded_top : IsBounded r \u22a4 \u2194 \u2203 t, \u2200 x, r x t := by simp [IsBounded, eq_univ_iff_forall]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/IsBounded.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} {f g : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_5\nIsBounded : x\u271d\n\u22a2 sorry \u2194 \u2203 t, \u2200 (x : \u03b1), r x t"}, {"line": "simp [IsBounded, eq_univ_iff_forall]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_5\nIsBounded : x\u271d\n\u22a2 sorry () \u2194 \u2203 t, \u2200 (x : \u03b1), r x t"}]}
{"declaration": "theorem isBounded_principal (s : Set \u03b1) : IsBounded r (\ud835\udcdf s) \u2194 \u2203 t, \u2200 x \u2208 s, r x t := by\n  simp [IsBounded, subset_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/IsBounded.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} {f g : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_5\nIsBounded : x\u271d\ns : Set \u03b1\n\u22a2 sorry \u2194 \u2203 t, \u2200 x \u2208 s, r x t"}, {"line": "simp [IsBounded, subset_def]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_5\nIsBounded : x\u271d\ns : Set \u03b1\n\u22a2 sorry () \u2194 \u2203 t, \u2200 x \u2208 s, r x t"}]}
{"declaration": "theorem isCobounded_top : IsCobounded r \u22a4 \u2194 Nonempty \u03b1 := by\n  simp +contextual [IsCobounded, eq_univ_iff_forall,\n    exists_true_iff_nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/IsBounded.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} {f g : Filter \u03b1}", "[Preorder \u03b1] {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {s : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nx\u271d : Sort u_5\nIsCobounded : x\u271d\n\u22a2 sorry \u2194 Nonempty \u03b1"}, {"line": "simp +contextual [IsCobounded, eq_univ_iff_forall,\n    exists_true_iff_nonempty]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nx\u271d : Sort u_5\nIsCobounded : x\u271d\n\u22a2 sorry () \u2194 Nonempty \u03b1"}]}
{"declaration": "theorem isCobounded_principal (s : Set \u03b1) :\n    (\ud835\udcdf s).IsCobounded r \u2194 \u2203 b, \u2200 a, (\u2200 x \u2208 s, r x a) \u2192 r b a := by simp [IsCobounded, subset_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/IsBounded.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} {f g : Filter \u03b1}", "[Preorder \u03b1] {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {s : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : Preorder \u03b1\nx\u271d : Sort u_5\n\ud835\udcdf : x\u271d\ns : Set \u03b1\n\u22a2 sorry \u2194 \u2203 b, \u2200 (a : \u03b1), (\u2200 x \u2208 s, r x a) \u2192 r b a"}, {"line": "simp [IsCobounded, subset_def]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : Preorder \u03b1\nx\u271d : Sort u_5\n\ud835\udcdf : x\u271d\ns : Set \u03b1\n\u22a2 sorry () \u2194 \u2203 b, \u2200 (a : \u03b1), (\u2200 x \u2208 s, r x a) \u2192 r b a"}]}
{"declaration": "lemma isBoundedUnder_sum {\u03ba : Type*} [AddCommMonoid R] {r : R \u2192 R \u2192 Prop}\n    (hr : \u2200 (v\u2081 v\u2082 : \u03b1 \u2192 R), f.IsBoundedUnder r v\u2081 \u2192 f.IsBoundedUnder r v\u2082\n      \u2192 f.IsBoundedUnder r (v\u2081 + v\u2082)) (hr\u2080 : r 0 0)\n    {u : \u03ba \u2192 \u03b1 \u2192 R} (s : Finset \u03ba) (h : \u2200 k \u2208 s, f.IsBoundedUnder r (u k)) :\n    f.IsBoundedUnder r (\u2211 k \u2208 s, u k) := by\n  induction s using Finset.cons_induction\n  case empty =>\n    rw [Finset.sum_empty]\n    exact \u27e80, by simp_all only [eventually_map, Pi.zero_apply, eventually_true]\u27e9\n  case cons k\u2080 s k\u2080_notin_s ih =>\n    simp only [Finset.forall_mem_cons] at *\n    simpa only [Finset.sum_cons] using hr _ _ h.1 (ih h.2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/IsBounded.lean", "context": {"open": ["Set Function", "Filter Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} {f g : Filter \u03b1}", "[Preorder \u03b1] {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {s : Set \u03b2}", "{\u03b1 : Type*} {f : Filter \u03b1}", "{R : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\nf : Filter \u03b1\nR : Type u_6\n\u03ba : Type u_7\ninst\u271d : AddCommMonoid R\nr : R \u2192 R \u2192 Prop\nhr : \u2200 (v\u2081 v\u2082 : \u03b1 \u2192 R), IsBoundedUnder r f v\u2081 \u2192 IsBoundedUnder r f v\u2082 \u2192 IsBoundedUnder r f (v\u2081 + v\u2082)\nhr\u2080 : r 0 0\nu : \u03ba \u2192 \u03b1 \u2192 R\ns : Finset \u03ba\nh : \u2200 k \u2208 s, IsBoundedUnder r f (u k)\n\u22a2 IsBoundedUnder r f (\u2211 k \u2208 s, u k)"}, {"line": "induction s using Finset.cons_induction", "tactic_state": "case empty\n\u03b1 : Type u_5\nf : Filter \u03b1\nR : Type u_6\n\u03ba : Type u_7\ninst\u271d : AddCommMonoid R\nr : R \u2192 R \u2192 Prop\nhr : \u2200 (v\u2081 v\u2082 : \u03b1 \u2192 R), IsBoundedUnder r f v\u2081 \u2192 IsBoundedUnder r f v\u2082 \u2192 IsBoundedUnder r f (v\u2081 + v\u2082)\nhr\u2080 : r 0 0\nu : \u03ba \u2192 \u03b1 \u2192 R\nh : \u2200 k \u2208 \u2205, IsBoundedUnder r f (u k)\n\u22a2 IsBoundedUnder r f (\u2211 k \u2208 \u2205, u k)\n---\ncase cons\n\u03b1 : Type u_5\nf : Filter \u03b1\nR : Type u_6\n\u03ba : Type u_7\ninst\u271d : AddCommMonoid R\nr : R \u2192 R \u2192 Prop\nhr : \u2200 (v\u2081 v\u2082 : \u03b1 \u2192 R), IsBoundedUnder r f v\u2081 \u2192 IsBoundedUnder r f v\u2082 \u2192 IsBoundedUnder r f (v\u2081 + v\u2082)\nhr\u2080 : r 0 0\nu : \u03ba \u2192 \u03b1 \u2192 R\na\u271d\u00b9 : \u03ba\ns\u271d : Finset \u03ba\nh\u271d : a\u271d\u00b9 \u2209 s\u271d\na\u271d : (\u2200 k \u2208 s\u271d, IsBoundedUnder r f (u k)) \u2192 IsBoundedUnder r f (\u2211 k \u2208 s\u271d, u k)\nh : \u2200 k \u2208 Finset.cons a\u271d\u00b9 s\u271d h\u271d, IsBoundedUnder r f (u k)\n\u22a2 IsBoundedUnder r f (\u2211 k \u2208 Finset.cons a\u271d\u00b9 s\u271d h\u271d, u k)"}, {"line": "case empty =>\n    rw [Finset.sum_empty]\n    exact \u27e80, by simp_all only [eventually_map, Pi.zero_apply, eventually_true]\u27e9", "tactic_state": "case cons\n\u03b1 : Type u_5\nf : Filter \u03b1\nR : Type u_6\n\u03ba : Type u_7\ninst\u271d : AddCommMonoid R\nr : R \u2192 R \u2192 Prop\nhr : \u2200 (v\u2081 v\u2082 : \u03b1 \u2192 R), IsBoundedUnder r f v\u2081 \u2192 IsBoundedUnder r f v\u2082 \u2192 IsBoundedUnder r f (v\u2081 + v\u2082)\nhr\u2080 : r 0 0\nu : \u03ba \u2192 \u03b1 \u2192 R\na\u271d\u00b9 : \u03ba\ns\u271d : Finset \u03ba\nh\u271d : a\u271d\u00b9 \u2209 s\u271d\na\u271d : (\u2200 k \u2208 s\u271d, IsBoundedUnder r f (u k)) \u2192 IsBoundedUnder r f (\u2211 k \u2208 s\u271d, u k)\nh : \u2200 k \u2208 Finset.cons a\u271d\u00b9 s\u271d h\u271d, IsBoundedUnder r f (u k)\n\u22a2 IsBoundedUnder r f (\u2211 k \u2208 Finset.cons a\u271d\u00b9 s\u271d h\u271d, u k)"}, {"line": "case cons k\u2080 s k\u2080_notin_s ih =>\n    simp only [Finset.forall_mem_cons] at *\n    simpa only [Finset.sum_cons] using hr _ _ h.1 (ih h.2)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isBoundedUnder_ge_add [Add R] [AddLeftMono R] [AddRightMono R]\n    {u v : \u03b1 \u2192 R} (u_bdd_ge : f.IsBoundedUnder (\u00b7 \u2265 \u00b7) u) (v_bdd_ge : f.IsBoundedUnder (\u00b7 \u2265 \u00b7) v) :\n    f.IsBoundedUnder (\u00b7 \u2265 \u00b7) (u + v) := by\n  obtain \u27e8U, hU\u27e9 := u_bdd_ge\n  obtain \u27e8V, hV\u27e9 := v_bdd_ge\n  use U + V\n  simp only [eventually_map] at hU hV \u22a2\n  simp only [Pi.add_apply] at hU hV \u22a2\n  filter_upwards [hU, hV] with a hu hv using add_le_add hu hv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/IsBounded.lean", "context": {"open": ["Set Function", "Filter Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} {f g : Filter \u03b1}", "[Preorder \u03b1] {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {s : Set \u03b2}", "{\u03b1 : Type*} {f : Filter \u03b1}", "{R : Type*}", "[Preorder R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\nf : Filter \u03b1\nR : Type u_6\ninst\u271d\u00b3 : Preorder R\ninst\u271d\u00b2 : Add R\ninst\u271d\u00b9 : AddLeftMono R\ninst\u271d : AddRightMono R\nu v : \u03b1 \u2192 R\nu_bdd_ge : IsBoundedUnder (fun x1 x2 => x1 \u2265 x2) f u\nv_bdd_ge : IsBoundedUnder (fun x1 x2 => x1 \u2265 x2) f v\n\u22a2 IsBoundedUnder (fun x1 x2 => x1 \u2265 x2) f (u + v)"}, {"line": "obtain \u27e8U, hU\u27e9 := u_bdd_ge", "tactic_state": "case intro\n\u03b1 : Type u_5\nf : Filter \u03b1\nR : Type u_6\ninst\u271d\u00b3 : Preorder R\ninst\u271d\u00b2 : Add R\ninst\u271d\u00b9 : AddLeftMono R\ninst\u271d : AddRightMono R\nu v : \u03b1 \u2192 R\nv_bdd_ge : IsBoundedUnder (fun x1 x2 => x1 \u2265 x2) f v\nU : R\nhU : \u2200\u1da0 (x : R) in map u f, (fun x1 x2 => x1 \u2265 x2) x U\n\u22a2 IsBoundedUnder (fun x1 x2 => x1 \u2265 x2) f (u + v)"}, {"line": "obtain \u27e8V, hV\u27e9 := v_bdd_ge", "tactic_state": "case intro.intro\n\u03b1 : Type u_5\nf : Filter \u03b1\nR : Type u_6\ninst\u271d\u00b3 : Preorder R\ninst\u271d\u00b2 : Add R\ninst\u271d\u00b9 : AddLeftMono R\ninst\u271d : AddRightMono R\nu v : \u03b1 \u2192 R\nU : R\nhU : \u2200\u1da0 (x : R) in map u f, (fun x1 x2 => x1 \u2265 x2) x U\nV : R\nhV : \u2200\u1da0 (x : R) in map v f, (fun x1 x2 => x1 \u2265 x2) x V\n\u22a2 IsBoundedUnder (fun x1 x2 => x1 \u2265 x2) f (u + v)"}, {"line": "use U + V", "tactic_state": "case h\n\u03b1 : Type u_5\nf : Filter \u03b1\nR : Type u_6\ninst\u271d\u00b3 : Preorder R\ninst\u271d\u00b2 : Add R\ninst\u271d\u00b9 : AddLeftMono R\ninst\u271d : AddRightMono R\nu v : \u03b1 \u2192 R\nU : R\nhU : \u2200\u1da0 (x : R) in map u f, (fun x1 x2 => x1 \u2265 x2) x U\nV : R\nhV : \u2200\u1da0 (x : R) in map v f, (fun x1 x2 => x1 \u2265 x2) x V\n\u22a2 \u2200\u1da0 (x : R) in map (u + v) f, (fun x1 x2 => x1 \u2265 x2) x sorry"}, {"line": "simp only [eventually_map] at hU hV \u22a2", "tactic_state": "case h\n\u03b1 : Type u_5\nf : Filter \u03b1\nR : Type u_6\ninst\u271d\u00b3 : Preorder R\ninst\u271d\u00b2 : Add R\ninst\u271d\u00b9 : AddLeftMono R\ninst\u271d : AddRightMono R\nu v : \u03b1 \u2192 R\nU V : R\nhU : \u2200\u1da0 (a : \u03b1) in f, u a \u2265 U\nhV : \u2200\u1da0 (a : \u03b1) in f, v a \u2265 V\n\u22a2 \u2200\u1da0 (a : \u03b1) in f, (u + v) a \u2265 sorry"}, {"line": "simp only [Pi.add_apply] at hU hV \u22a2", "tactic_state": "case h\n\u03b1 : Type u_5\nf : Filter \u03b1\nR : Type u_6\ninst\u271d\u00b3 : Preorder R\ninst\u271d\u00b2 : Add R\ninst\u271d\u00b9 : AddLeftMono R\ninst\u271d : AddRightMono R\nu v : \u03b1 \u2192 R\nU V : R\nhU : \u2200\u1da0 (a : \u03b1) in f, u a \u2265 U\nhV : \u2200\u1da0 (a : \u03b1) in f, v a \u2265 V\n\u22a2 \u2200\u1da0 (a : \u03b1) in f, u a + v a \u2265 sorry"}, {"line": "filter_upwards [hU, hV] with a hu hv using add_le_add hu hv", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isBoundedUnder_le_add [Add R] [AddLeftMono R] [AddRightMono R]\n    {u v : \u03b1 \u2192 R} (u_bdd_le : f.IsBoundedUnder (\u00b7 \u2264 \u00b7) u) (v_bdd_le : f.IsBoundedUnder (\u00b7 \u2264 \u00b7) v) :\n    f.IsBoundedUnder (\u00b7 \u2264 \u00b7) (u + v) := by\n  obtain \u27e8U, hU\u27e9 := u_bdd_le\n  obtain \u27e8V, hV\u27e9 := v_bdd_le\n  use U + V\n  simp only [eventually_map] at hU hV \u22a2\n  simp only [Pi.add_apply] at hU hV \u22a2\n  filter_upwards [hU, hV] with a hu hv using add_le_add hu hv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/IsBounded.lean", "context": {"open": ["Set Function", "Filter Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} {f g : Filter \u03b1}", "[Preorder \u03b1] {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {s : Set \u03b2}", "{\u03b1 : Type*} {f : Filter \u03b1}", "{R : Type*}", "[Preorder R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\nf : Filter \u03b1\nR : Type u_6\ninst\u271d\u00b3 : Preorder R\ninst\u271d\u00b2 : Add R\ninst\u271d\u00b9 : AddLeftMono R\ninst\u271d : AddRightMono R\nu v : \u03b1 \u2192 R\nu_bdd_le : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nv_bdd_le : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f v\n\u22a2 IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f (u + v)"}, {"line": "obtain \u27e8U, hU\u27e9 := u_bdd_le", "tactic_state": "case intro\n\u03b1 : Type u_5\nf : Filter \u03b1\nR : Type u_6\ninst\u271d\u00b3 : Preorder R\ninst\u271d\u00b2 : Add R\ninst\u271d\u00b9 : AddLeftMono R\ninst\u271d : AddRightMono R\nu v : \u03b1 \u2192 R\nv_bdd_le : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f v\nU : R\nhU : \u2200\u1da0 (x : R) in map u f, (fun x1 x2 => x1 \u2264 x2) x U\n\u22a2 IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f (u + v)"}, {"line": "obtain \u27e8V, hV\u27e9 := v_bdd_le", "tactic_state": "case intro.intro\n\u03b1 : Type u_5\nf : Filter \u03b1\nR : Type u_6\ninst\u271d\u00b3 : Preorder R\ninst\u271d\u00b2 : Add R\ninst\u271d\u00b9 : AddLeftMono R\ninst\u271d : AddRightMono R\nu v : \u03b1 \u2192 R\nU : R\nhU : \u2200\u1da0 (x : R) in map u f, (fun x1 x2 => x1 \u2264 x2) x U\nV : R\nhV : \u2200\u1da0 (x : R) in map v f, (fun x1 x2 => x1 \u2264 x2) x V\n\u22a2 IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f (u + v)"}, {"line": "use U + V", "tactic_state": "case h\n\u03b1 : Type u_5\nf : Filter \u03b1\nR : Type u_6\ninst\u271d\u00b3 : Preorder R\ninst\u271d\u00b2 : Add R\ninst\u271d\u00b9 : AddLeftMono R\ninst\u271d : AddRightMono R\nu v : \u03b1 \u2192 R\nU : R\nhU : \u2200\u1da0 (x : R) in map u f, (fun x1 x2 => x1 \u2264 x2) x U\nV : R\nhV : \u2200\u1da0 (x : R) in map v f, (fun x1 x2 => x1 \u2264 x2) x V\n\u22a2 \u2200\u1da0 (x : R) in map (u + v) f, (fun x1 x2 => x1 \u2264 x2) x sorry"}, {"line": "simp only [eventually_map] at hU hV \u22a2", "tactic_state": "case h\n\u03b1 : Type u_5\nf : Filter \u03b1\nR : Type u_6\ninst\u271d\u00b3 : Preorder R\ninst\u271d\u00b2 : Add R\ninst\u271d\u00b9 : AddLeftMono R\ninst\u271d : AddRightMono R\nu v : \u03b1 \u2192 R\nU V : R\nhU : \u2200\u1da0 (a : \u03b1) in f, u a \u2264 U\nhV : \u2200\u1da0 (a : \u03b1) in f, v a \u2264 V\n\u22a2 \u2200\u1da0 (a : \u03b1) in f, (u + v) a \u2264 sorry"}, {"line": "simp only [Pi.add_apply] at hU hV \u22a2", "tactic_state": "case h\n\u03b1 : Type u_5\nf : Filter \u03b1\nR : Type u_6\ninst\u271d\u00b3 : Preorder R\ninst\u271d\u00b2 : Add R\ninst\u271d\u00b9 : AddLeftMono R\ninst\u271d : AddRightMono R\nu v : \u03b1 \u2192 R\nU V : R\nhU : \u2200\u1da0 (a : \u03b1) in f, u a \u2264 U\nhV : \u2200\u1da0 (a : \u03b1) in f, v a \u2264 V\n\u22a2 \u2200\u1da0 (a : \u03b1) in f, u a + v a \u2264 sorry"}, {"line": "filter_upwards [hU, hV] with a hu hv using add_le_add hu hv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isCoboundedUnder_le_finset_sup' [LinearOrder \u03b2] {f : Filter \u03b1} {F : \u03b9 \u2192 \u03b1 \u2192 \u03b2}\n    {s : Finset \u03b9} (hs : s.Nonempty) (h : \u2203 i \u2208 s, f.IsCoboundedUnder (\u00b7 \u2264 \u00b7) (F i)) :\n    f.IsCoboundedUnder (\u00b7 \u2264 \u00b7) (fun a \u21a6 sup' s hs (fun i \u21a6 F i a)) := by\n  rcases h with \u27e8i, i_s, b, hb\u27e9\n  use b\n  refine fun c hc \u21a6 hb c ?_\n  rw [eventually_map] at hc \u22a2\n  refine hc.mono fun a h \u21a6 ?_\n  simp only [Finset.sup'_apply] at h \u22a2\n  simp only [sup'_le_iff] at h \u22a2\n  exact h i i_s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/IsBounded.lean", "context": {"open": ["Set Function", "Filter Set", "Filter", "Finset"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} {f g : Filter \u03b1}", "[Preorder \u03b1] {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {s : Set \u03b2}", "{\u03b1 : Type*} {f : Filter \u03b1}", "{R : Type*}", "[Preorder R]", "{\u03b1 : Type*} {R : Type*} [LinearOrder R] [Add R] {f : Filter \u03b1} [f.NeBot]", "[Preorder \u03b1] [Nonempty \u03b1] {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03b9 : Type u_4\n\u03b1 : Type u_7\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\nf : Filter \u03b1\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Finset \u03b9\nhs : s.Nonempty\nh : \u2203 i \u2208 s, IsCoboundedUnder (fun x1 x2 => x1 \u2264 x2) f (F i)\n\u22a2 IsCoboundedUnder (fun x1 x2 => x1 \u2264 x2) f fun a => s.sup' hs fun i => F i a"}, {"line": "rcases h with \u27e8i, i_s, b, hb\u27e9", "tactic_state": "case intro.intro.intro\n\u03b2 : Type u_2\n\u03b9 : Type u_4\n\u03b1 : Type u_7\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\nf : Filter \u03b1\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Finset \u03b9\nhs : s.Nonempty\ni : \u03b9\ni_s : i \u2208 s\nb : \u03b2\nhb : \u2200 (a : \u03b2), (\u2200\u1da0 (x : \u03b2) in Filter.map (F i) f, (fun x1 x2 => x1 \u2264 x2) x a) \u2192 (fun x1 x2 => x1 \u2264 x2) b a\n\u22a2 IsCoboundedUnder (fun x1 x2 => x1 \u2264 x2) f fun a => s.sup' hs fun i => F i a"}, {"line": "use b", "tactic_state": "case h\n\u03b2 : Type u_2\n\u03b9 : Type u_4\n\u03b1 : Type u_7\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\nf : Filter \u03b1\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Finset \u03b9\nhs : s.Nonempty\ni : \u03b9\ni_s : i \u2208 s\nb : \u03b2\nhb : \u2200 (a : \u03b2), (\u2200\u1da0 (x : \u03b2) in Filter.map (F i) f, (fun x1 x2 => x1 \u2264 x2) x a) \u2192 (fun x1 x2 => x1 \u2264 x2) b a\n\u22a2 \u2200 (a : \u03b2),\n    (\u2200\u1da0 (x : \u03b2) in Filter.map (fun a => s.sup' hs fun i => F i a) f, (fun x1 x2 => x1 \u2264 x2) x a) \u2192\n      (fun x1 x2 => x1 \u2264 x2) b a"}, {"line": "refine fun c hc \u21a6 hb c ?_", "tactic_state": "case h\n\u03b2 : Type u_2\n\u03b9 : Type u_4\n\u03b1 : Type u_7\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\nf : Filter \u03b1\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Finset \u03b9\nhs : s.Nonempty\ni : \u03b9\ni_s : i \u2208 s\nb : \u03b2\nhb : \u2200 (a : \u03b2), (\u2200\u1da0 (x : \u03b2) in Filter.map (F i) f, (fun x1 x2 => x1 \u2264 x2) x a) \u2192 (fun x1 x2 => x1 \u2264 x2) b a\nc : \u03b2\nhc : \u2200\u1da0 (x : \u03b2) in Filter.map (fun a => s.sup' hs fun i => F i a) f, (fun x1 x2 => x1 \u2264 x2) x c\n\u22a2 \u2200\u1da0 (x : \u03b2) in Filter.map (F i) f, (fun x1 x2 => x1 \u2264 x2) x c"}, {"line": "rw [eventually_map] at hc \u22a2", "tactic_state": "case h\n\u03b2 : Type u_2\n\u03b9 : Type u_4\n\u03b1 : Type u_7\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\nf : Filter \u03b1\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Finset \u03b9\nhs : s.Nonempty\ni : \u03b9\ni_s : i \u2208 s\nb : \u03b2\nhb : \u2200 (a : \u03b2), (\u2200\u1da0 (x : \u03b2) in Filter.map (F i) f, (fun x1 x2 => x1 \u2264 x2) x a) \u2192 (fun x1 x2 => x1 \u2264 x2) b a\nc : \u03b2\nhc : \u2200\u1da0 (a : \u03b1) in f, (fun x1 x2 => x1 \u2264 x2) (s.sup' hs fun i => F i a) c\n\u22a2 \u2200\u1da0 (a : \u03b1) in f, (fun x1 x2 => x1 \u2264 x2) (F i a) c"}, {"line": "refine hc.mono fun a h \u21a6 ?_", "tactic_state": "case h\n\u03b2 : Type u_2\n\u03b9 : Type u_4\n\u03b1 : Type u_7\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\nf : Filter \u03b1\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Finset \u03b9\nhs : s.Nonempty\ni : \u03b9\ni_s : i \u2208 s\nb : \u03b2\nhb : \u2200 (a : \u03b2), (\u2200\u1da0 (x : \u03b2) in Filter.map (F i) f, (fun x1 x2 => x1 \u2264 x2) x a) \u2192 (fun x1 x2 => x1 \u2264 x2) b a\nc : \u03b2\nhc : \u2200\u1da0 (a : \u03b1) in f, (fun x1 x2 => x1 \u2264 x2) (s.sup' hs fun i => F i a) c\na : \u03b1\nh : (fun x1 x2 => x1 \u2264 x2) (s.sup' hs fun i => F i a) c\n\u22a2 (fun x1 x2 => x1 \u2264 x2) (F i a) c"}, {"line": "simp only [Finset.sup'_apply] at h \u22a2", "tactic_state": "case h\n\u03b2 : Type u_2\n\u03b9 : Type u_4\n\u03b1 : Type u_7\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\nf : Filter \u03b1\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Finset \u03b9\nhs : s.Nonempty\ni : \u03b9\ni_s : i \u2208 s\nb : \u03b2\nhb : \u2200 (a : \u03b2), (\u2200\u1da0 (x : \u03b2) in Filter.map (F i) f, (fun x1 x2 => x1 \u2264 x2) x a) \u2192 (fun x1 x2 => x1 \u2264 x2) b a\nc : \u03b2\nhc : \u2200\u1da0 (a : \u03b1) in f, (fun x1 x2 => x1 \u2264 x2) (s.sup' hs fun i => F i a) c\na : \u03b1\nh : (s.sup' hs fun i => F i a) \u2264 c\n\u22a2 F i a \u2264 c"}, {"line": "simp only [sup'_le_iff] at h \u22a2", "tactic_state": "case h\n\u03b2 : Type u_2\n\u03b9 : Type u_4\n\u03b1 : Type u_7\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\nf : Filter \u03b1\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns : Finset \u03b9\nhs : s.Nonempty\ni : \u03b9\ni_s : i \u2208 s\nb : \u03b2\nhb : \u2200 (a : \u03b2), (\u2200\u1da0 (x : \u03b2) in Filter.map (F i) f, (fun x1 x2 => x1 \u2264 x2) x a) \u2192 (fun x1 x2 => x1 \u2264 x2) b a\nc : \u03b2\nhc : \u2200\u1da0 (a : \u03b1) in f, (fun x1 x2 => x1 \u2264 x2) (s.sup' hs fun i => F i a) c\na : \u03b1\nh : \u2200 b \u2208 s, F b a \u2264 c\n\u22a2 F i a \u2264 c"}, {"line": "exact h i i_s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Set.LeftInvOn.filter_map_Iic {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (hfg : LeftInvOn g f s) :\n    LeftInvOn (map g) (map f) (Iic <| \ud835\udcdf s) := fun F (hF : F \u2264 \ud835\udcdf s) \u21a6 by\n  have : (g \u2218 f) =\u1da0[\ud835\udcdf s] id := by simpa only [eventuallyEq_principal] using hfg\n  rw [map_map]\n  rw [map_congr (this.filter_mono hF)]\n  rw [map_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b1\nhfg : LeftInvOn g f s\nF : Filter \u03b1\nhF : F \u2264 principal s\n\u22a2 g \u2218 f =\u1da0[principal s] id"}, {"line": "simpa only [eventuallyEq_principal] using hfg\n  rw [map_map]\n  rw [map_congr (this.filter_mono hF)]\n  rw [map_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_kernMap_iff_compl {s : Set \u03b2} : s \u2208 kernMap m f \u2194 \u2203 t, t\u1d9c \u2208 f \u2227 m '' t = s\u1d9c := by\n  rw [mem_kernMap]\n  rw [compl_surjective.exists]\n  refine exists_congr (fun x \u21a6 and_congr_right fun _ \u21a6 ?_)\n  rw [kernImage_compl]\n  rw [compl_eq_comm]\n  rw [eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b1\ns : Set \u03b2\n\u22a2 s \u2208 kernMap m f \u2194 \u2203 t, t\u1d9c \u2208 f \u2227 m '' t = s\u1d9c"}, {"line": "rw [mem_kernMap]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b1\ns : Set \u03b2\n\u22a2 (\u2203 t \u2208 f, kernImage m t = s) \u2194 \u2203 t, t\u1d9c \u2208 f \u2227 m '' t = s\u1d9c"}, {"line": "rw [compl_surjective.exists]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b1\ns : Set \u03b2\n\u22a2 (\u2203 x, x\u1d9c \u2208 f \u2227 kernImage m x\u1d9c = s) \u2194 \u2203 t, t\u1d9c \u2208 f \u2227 m '' t = s\u1d9c"}, {"line": "refine exists_congr (fun x \u21a6 and_congr_right fun _ \u21a6 ?_)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b1\ns : Set \u03b2\nx : Set \u03b1\nx\u271d : x\u1d9c \u2208 f\n\u22a2 kernImage m x\u1d9c = s \u2194 m '' x = s\u1d9c"}, {"line": "rw [kernImage_compl]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b1\ns : Set \u03b2\nx : Set \u03b1\nx\u271d : x\u1d9c \u2208 f\n\u22a2 (m '' x)\u1d9c = s \u2194 m '' x = s\u1d9c"}, {"line": "rw [compl_eq_comm]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b1\ns : Set \u03b2\nx : Set \u03b1\nx\u271d : x\u1d9c \u2208 f\n\u22a2 s\u1d9c = m '' x \u2194 m '' x = s\u1d9c"}, {"line": "rw [eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_mem_kernMap {s : Set \u03b2} : s\u1d9c \u2208 kernMap m f \u2194 \u2203 t, t\u1d9c \u2208 f \u2227 m '' t = s := by\n  simp_rw [mem_kernMap_iff_compl, compl_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b1\ns : Set \u03b2\n\u22a2 s\u1d9c \u2208 kernMap m f \u2194 \u2203 t, t\u1d9c \u2208 f \u2227 m '' t = s"}, {"line": "simp_rw [mem_kernMap_iff_compl, compl_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_le_iff_le_kernMap : comap m g \u2264 f \u2194 g \u2264 kernMap m f := by\n  simp [Filter.le_def, mem_comap'', mem_kernMap, -mem_comap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b1\n\u22a2 comap m g \u2264 f \u2194 g \u2264 kernMap m f"}, {"line": "simp [Filter.le_def, mem_comap'', mem_kernMap, -mem_comap]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem kernMap_principal {s : Set \u03b1} : kernMap m (\ud835\udcdf s) = \ud835\udcdf (kernImage m s) := by\n  refine eq_of_forall_le_iff (fun g \u21a6 ?_)\n  rw [\u2190 comap_le_iff_le_kernMap]\n  rw [le_principal_iff]\n  rw [le_principal_iff]\n  rw [mem_comap'']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 kernMap m (principal s) = principal (kernImage m s)"}, {"line": "refine eq_of_forall_le_iff (fun g \u21a6 ?_)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : \u03b1 \u2192 \u03b2\ns : Set \u03b1\ng : Filter \u03b2\n\u22a2 g \u2264 kernMap m (principal s) \u2194 g \u2264 principal (kernImage m s)"}, {"line": "rw [\u2190 comap_le_iff_le_kernMap]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : \u03b1 \u2192 \u03b2\ns : Set \u03b1\ng : Filter \u03b2\n\u22a2 comap m g \u2264 principal s \u2194 g \u2264 principal (kernImage m s)"}, {"line": "rw [le_principal_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : \u03b1 \u2192 \u03b2\ns : Set \u03b1\ng : Filter \u03b2\n\u22a2 s \u2208 comap m g \u2194 g \u2264 principal (kernImage m s)"}, {"line": "rw [le_principal_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : \u03b1 \u2192 \u03b2\ns : Set \u03b1\ng : Filter \u03b2\n\u22a2 s \u2208 comap m g \u2194 kernImage m s \u2208 g"}, {"line": "rw [mem_comap'']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem principal_subtype {\u03b1 : Type*} (s : Set \u03b1) (t : Set s) :\n    \ud835\udcdf t = comap (\u2191) (\ud835\udcdf (((\u2191) : s \u2192 \u03b1) '' t)) := by\n  rw [comap_principal]\n  rw [preimage_image_eq _ Subtype.coe_injective]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\ns : Set \u03b1\nt : Set \u2191s\n\u22a2 principal t = comap Subtype.val (principal (Subtype.val '' t))"}, {"line": "rw [comap_principal]", "tactic_state": "\u03b1 : Type u_6\ns : Set \u03b1\nt : Set \u2191s\n\u22a2 principal t = principal (Subtype.val \u207b\u00b9' (Subtype.val '' t))"}, {"line": "rw [preimage_image_eq _ Subtype.coe_injective]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_pure {b : \u03b2} : comap m (pure b) = \ud835\udcdf (m \u207b\u00b9' {b}) := by\n  rw [\u2190 principal_singleton]\n  rw [comap_principal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : \u03b1 \u2192 \u03b2\nb : \u03b2\n\u22a2 comap m (pure b) = principal (m \u207b\u00b9' {b})"}, {"line": "rw [\u2190 principal_singleton]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : \u03b1 \u2192 \u03b2\nb : \u03b2\n\u22a2 comap m (principal {b}) = principal (m \u207b\u00b9' {b})"}, {"line": "rw [comap_principal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_top (f : \u03b1 \u2192 \u03b2) : map f \u22a4 = \ud835\udcdf (range f) := by\n  rw [\u2190 principal_univ]\n  rw [map_principal]\n  rw [image_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 map f \u22a4 = principal (range f)"}, {"line": "rw [\u2190 principal_univ]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 map f (principal univ) = principal (range f)"}, {"line": "rw [map_principal]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 principal (f '' univ) = principal (range f)"}, {"line": "rw [image_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_comap_top (f : \u03b1 \u2192 \u03b2) (l : Filter \u03b1) : l \u2264 comap f \u22a4 := by\n  rw [comap_top]\n  exact le_top\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nl : Filter \u03b1\n\u22a2 l \u2264 comap f \u22a4"}, {"line": "rw [comap_top]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nl : Filter \u03b1\n\u22a2 l \u2264 \u22a4"}, {"line": "exact le_top", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neBot_of_comap (h : (comap m g).NeBot) : g.NeBot := by\n  rw [neBot_iff] at *\n  contrapose! h\n  rw [h]\n  exact comap_bot\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nh : (comap m g).NeBot\n\u22a2 g.NeBot"}, {"line": "rw [neBot_iff] at *", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nh : comap m g \u2260 \u22a5\n\u22a2 g \u2260 \u22a5"}, {"line": "contrapose! h", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nh : g = \u22a5\n\u22a2 comap m g = \u22a5"}, {"line": "rw [h]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nh : g = \u22a5\n\u22a2 comap m \u22a5 = \u22a5"}, {"line": "exact comap_bot", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_inf_principal_range : comap m (g \u2293 \ud835\udcdf (range m)) = comap m g := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 comap m (g \u2293 principal (range m)) = comap m g"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_comap (h : Disjoint g\u2081 g\u2082) : Disjoint (comap m g\u2081) (comap m g\u2082) := by\n  simp only [disjoint_iff]\n  simp only [\u2190 comap_inf]\n  simp only [h.eq_bot]\n  simp only [comap_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nh : Disjoint g\u2081 g\u2082\n\u22a2 Disjoint (comap m g\u2081) (comap m g\u2082)"}, {"line": "simp only [disjoint_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nh : Disjoint g\u2081 g\u2082\n\u22a2 comap m g\u2081 \u2293 comap m g\u2082 = \u22a5"}, {"line": "simp only [\u2190 comap_inf]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nh : Disjoint g\u2081 g\u2082\n\u22a2 comap m (g\u2081 \u2293 g\u2082) = \u22a5"}, {"line": "simp only [h.eq_bot]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nh : Disjoint g\u2081 g\u2082\n\u22a2 comap m \u22a5 = \u22a5"}, {"line": "simp only [comap_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_sup : comap m (g\u2081 \u2294 g\u2082) = comap m g\u2081 \u2294 comap m g\u2082 := by\n  rw [sup_eq_iSup]\n  rw [comap_iSup]\n  rw [iSup_bool_eq]\n  rw [Bool.cond_true]\n  rw [Bool.cond_false]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 comap m (g\u2081 \u2294 g\u2082) = comap m g\u2081 \u2294 comap m g\u2082"}, {"line": "rw [sup_eq_iSup]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 comap m (\u2a06 b, bif b then g\u2081 else g\u2082) = comap m g\u2081 \u2294 comap m g\u2082"}, {"line": "rw [comap_iSup]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 \u2a06 i, comap m (bif i then g\u2081 else g\u2082) = comap m g\u2081 \u2294 comap m g\u2082"}, {"line": "rw [iSup_bool_eq]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 comap m (bif true then g\u2081 else g\u2082) \u2294 comap m (bif false then g\u2081 else g\u2082) = comap m g\u2081 \u2294 comap m g\u2082"}, {"line": "rw [Bool.cond_true]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 comap m g\u2081 \u2294 comap m (bif false then g\u2081 else g\u2082) = comap m g\u2081 \u2294 comap m g\u2082"}, {"line": "rw [Bool.cond_false]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_comap (f : Filter \u03b2) (m : \u03b1 \u2192 \u03b2) : (f.comap m).map m = f \u2293 \ud835\udcdf (range m) := by\n  refine le_antisymm (le_inf map_comap_le <| le_principal_iff.2 range_mem_map) ?_\n  rintro t' \u27e8t, ht, sub\u27e9\n  refine mem_inf_principal.2 (mem_of_superset ht ?_)\n  rintro _ hxt \u27e8x, rfl\u27e9\n  exact sub hxt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 map m (comap m f) = f \u2293 principal (range m)"}, {"line": "refine le_antisymm (le_inf map_comap_le <| le_principal_iff.2 range_mem_map) ?_", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 f \u2293 principal (range m) \u2264 map m (comap m f)"}, {"line": "rintro t' \u27e8t, ht, sub\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nt' t : Set \u03b2\nht : t \u2208 f\nsub : m \u207b\u00b9' t \u2286 m \u207b\u00b9' t'\n\u22a2 t' \u2208 f \u2293 principal (range m)"}, {"line": "refine mem_inf_principal.2 (mem_of_superset ht ?_)", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nt' t : Set \u03b2\nht : t \u2208 f\nsub : m \u207b\u00b9' t \u2286 m \u207b\u00b9' t'\n\u22a2 t \u2286 {x | x \u2208 range m \u2192 x \u2208 t'}"}, {"line": "rintro _ hxt \u27e8x, rfl\u27e9", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nt' t : Set \u03b2\nht : t \u2208 f\nsub : m \u207b\u00b9' t \u2286 m \u207b\u00b9' t'\nx : \u03b1\nhxt : m x \u2208 t\n\u22a2 m x \u2208 t'"}, {"line": "exact sub hxt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_comap_setCoe_val (f : Filter \u03b2) (s : Set \u03b2) :\n    (f.comap ((\u2191) : s \u2192 \u03b2)).map (\u2191) = f \u2293 \ud835\udcdf s := by\n  rw [map_comap]\n  rw [Subtype.range_val]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\nf : Filter \u03b2\ns : Set \u03b2\n\u22a2 map Subtype.val (comap Subtype.val f) = f \u2293 principal s"}, {"line": "rw [map_comap]", "tactic_state": "\u03b2 : Type u_2\nf : Filter \u03b2\ns : Set \u03b2\n\u22a2 f \u2293 principal (range Subtype.val) = f \u2293 principal s"}, {"line": "rw [Subtype.range_val]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_comap_of_mem {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} (hf : range m \u2208 f) : (f.comap m).map m = f := by\n  rw [map_comap]\n  rw [inf_eq_left.2 (le_principal_iff.2 hf)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nhf : range m \u2208 f\n\u22a2 map m (comap m f) = f"}, {"line": "rw [map_comap]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nhf : range m \u2208 f\n\u22a2 f \u2293 principal (range m) = f"}, {"line": "rw [inf_eq_left.2 (le_principal_iff.2 hf)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subtype_coe_map_comap (s : Set \u03b1) (f : Filter \u03b1) :\n    map ((\u2191) : s \u2192 \u03b1) (comap ((\u2191) : s \u2192 \u03b1) f) = f \u2293 \ud835\udcdf s := by rw [map_comap, Subtype.range_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nf : Filter \u03b1\n\u22a2 map Subtype.val (comap Subtype.val f) = f \u2293 principal s"}, {"line": "rw [map_comap, Subtype.range_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_mem_of_mem_comap {f : Filter \u03b1} {c : \u03b2 \u2192 \u03b1} (h : range c \u2208 f) {W : Set \u03b2}\n    (W_in : W \u2208 comap c f) : c '' W \u2208 f := by\n  rw [\u2190 map_comap_of_mem h]\n  exact image_mem_map W_in\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\nc : \u03b2 \u2192 \u03b1\nh : range c \u2208 f\nW : Set \u03b2\nW_in : W \u2208 comap c f\n\u22a2 c '' W \u2208 f"}, {"line": "rw [\u2190 map_comap_of_mem h]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\nc : \u03b2 \u2192 \u03b1\nh : range c \u2208 f\nW : Set \u03b2\nW_in : W \u2208 comap c f\n\u22a2 c '' W \u2208 map c (comap c f)"}, {"line": "exact image_mem_map W_in", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_comap_iff {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} (inj : Injective m) (large : Set.range m \u2208 f)\n    {S : Set \u03b1} : S \u2208 comap m f \u2194 m '' S \u2208 f := by\n  rw [\u2190 image_mem_map_iff inj]\n  rw [map_comap_of_mem large]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\ninj : Injective m\nlarge : range m \u2208 f\nS : Set \u03b1\n\u22a2 S \u2208 comap m f \u2194 m '' S \u2208 f"}, {"line": "rw [\u2190 image_mem_map_iff inj]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\ninj : Injective m\nlarge : range m \u2208 f\nS : Set \u03b1\n\u22a2 m '' S \u2208 map m (comap m f) \u2194 m '' S \u2208 f"}, {"line": "rw [map_comap_of_mem large]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_le_map_iff {f g : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} (hm : Injective m) :\n    map m f \u2264 map m g \u2194 f \u2264 g := by rw [map_le_iff_le_comap, comap_map hm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : Filter \u03b1\nm : \u03b1 \u2192 \u03b2\nhm : Injective m\n\u22a2 map m f \u2264 map m g \u2194 f \u2264 g"}, {"line": "rw [map_le_iff_le_comap, comap_map hm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_eq_map_iff_of_injOn {f g : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hsf : s \u2208 f) (hsg : s \u2208 g)\n    (hm : InjOn m s) : map m f = map m g \u2194 f = g := by\n  simp only [le_antisymm_iff]\n  simp only [map_le_map_iff_of_injOn hsf hsg hm]\n  simp only [map_le_map_iff_of_injOn hsg hsf hm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : Filter \u03b1\nm : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhsf : s \u2208 f\nhsg : s \u2208 g\nhm : InjOn m s\n\u22a2 map m f = map m g \u2194 f = g"}, {"line": "simp only [le_antisymm_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : Filter \u03b1\nm : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhsf : s \u2208 f\nhsg : s \u2208 g\nhm : InjOn m s\n\u22a2 map m f \u2264 map m g \u2227 map m g \u2264 map m f \u2194 f \u2264 g \u2227 g \u2264 f"}, {"line": "simp only [map_le_map_iff_of_injOn hsf hsg hm]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : Filter \u03b1\nm : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhsf : s \u2208 f\nhsg : s \u2208 g\nhm : InjOn m s\n\u22a2 f \u2264 g \u2227 map m g \u2264 map m f \u2194 f \u2264 g \u2227 g \u2264 f"}, {"line": "simp only [map_le_map_iff_of_injOn hsg hsf hm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_neBot_iff {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} : NeBot (comap m f) \u2194 \u2200 t \u2208 f, \u2203 a, m a \u2208 t := by\n  simp only [\u2190 forall_mem_nonempty_iff_neBot]\n  simp only [mem_comap]\n  simp only [forall_exists_index]\n  simp only [and_imp]\n  exact \u27e8fun h t t_in => h (m \u207b\u00b9' t) t t_in Subset.rfl, fun h s t ht hst => (h t ht).imp hst\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 (comap m f).NeBot \u2194 \u2200 t \u2208 f, \u2203 a, m a \u2208 t"}, {"line": "simp only [\u2190 forall_mem_nonempty_iff_neBot]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 s \u2208 comap m f, s.Nonempty) \u2194 \u2200 t \u2208 f, \u2203 a, m a \u2208 t"}, {"line": "simp only [mem_comap]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (s : Set \u03b1), (\u2203 t \u2208 f, m \u207b\u00b9' t \u2286 s) \u2192 s.Nonempty) \u2194 \u2200 t \u2208 f, \u2203 a, m a \u2208 t"}, {"line": "simp only [forall_exists_index]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (s : Set \u03b1) (x : Set \u03b2), x \u2208 f \u2227 m \u207b\u00b9' x \u2286 s \u2192 s.Nonempty) \u2194 \u2200 t \u2208 f, \u2203 a, m a \u2208 t"}, {"line": "simp only [and_imp]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (s : Set \u03b1), \u2200 x \u2208 f, m \u207b\u00b9' x \u2286 s \u2192 s.Nonempty) \u2194 \u2200 t \u2208 f, \u2203 a, m a \u2208 t"}, {"line": "exact \u27e8fun h t t_in => h (m \u207b\u00b9' t) t t_in Subset.rfl, fun h s t ht hst => (h t ht).imp hst\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_neBot_iff_frequently {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} :\n    NeBot (comap m f) \u2194 \u2203\u1da0 y in f, y \u2208 range m := by\n  simp only [comap_neBot_iff]\n  simp only [frequently_iff]\n  simp only [mem_range]\n  simp only [@and_comm (_ \u2208 _)]\n  simp only [exists_exists_eq_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 (comap m f).NeBot \u2194 \u2203\u1da0 (y : \u03b2) in f, y \u2208 range m"}, {"line": "simp only [comap_neBot_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 t \u2208 f, \u2203 a, m a \u2208 t) \u2194 \u2203\u1da0 (y : \u03b2) in f, y \u2208 range m"}, {"line": "simp only [frequently_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 t \u2208 f, \u2203 a, m a \u2208 t) \u2194 \u2200 {U : Set \u03b2}, U \u2208 f \u2192 \u2203 x \u2208 U, x \u2208 range m"}, {"line": "simp only [mem_range]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 t \u2208 f, \u2203 a, m a \u2208 t) \u2194 \u2200 {U : Set \u03b2}, U \u2208 f \u2192 \u2203 x \u2208 U, \u2203 y, m y = x"}, {"line": "simp only [@and_comm (_ \u2208 _)]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 t \u2208 f, \u2203 a, m a \u2208 t) \u2194 \u2200 {U : Set \u03b2}, U \u2208 f \u2192 \u2203 x, (\u2203 y, m y = x) \u2227 x \u2208 U"}, {"line": "simp only [exists_exists_eq_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_surjective_eq_bot {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} (hm : Surjective m) :\n    comap m f = \u22a5 \u2194 f = \u22a5 := by\n  rw [comap_eq_bot_iff_compl_range]\n  rw [hm.range_eq]\n  rw [compl_univ]\n  rw [empty_mem_iff_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nhm : Surjective m\n\u22a2 comap m f = \u22a5 \u2194 f = \u22a5"}, {"line": "rw [comap_eq_bot_iff_compl_range]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nhm : Surjective m\n\u22a2 (range m)\u1d9c \u2208 f \u2194 f = \u22a5"}, {"line": "rw [hm.range_eq]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nhm : Surjective m\n\u22a2 univ\u1d9c \u2208 f \u2194 f = \u22a5"}, {"line": "rw [compl_univ]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nhm : Surjective m\n\u22a2 \u2205 \u2208 f \u2194 f = \u22a5"}, {"line": "rw [empty_mem_iff_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_comap_iff (h : Surjective m) :\n    Disjoint (comap m g\u2081) (comap m g\u2082) \u2194 Disjoint g\u2081 g\u2082 := by\n  rw [disjoint_iff]\n  rw [disjoint_iff]\n  rw [\u2190 comap_inf]\n  rw [comap_surjective_eq_bot h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nh : Surjective m\n\u22a2 Disjoint (comap m g\u2081) (comap m g\u2082) \u2194 Disjoint g\u2081 g\u2082"}, {"line": "rw [disjoint_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nh : Surjective m\n\u22a2 comap m g\u2081 \u2293 comap m g\u2082 = \u22a5 \u2194 Disjoint g\u2081 g\u2082"}, {"line": "rw [disjoint_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nh : Surjective m\n\u22a2 comap m g\u2081 \u2293 comap m g\u2082 = \u22a5 \u2194 g\u2081 \u2293 g\u2082 = \u22a5"}, {"line": "rw [\u2190 comap_inf]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nh : Surjective m\n\u22a2 comap m (g\u2081 \u2293 g\u2082) = \u22a5 \u2194 g\u2081 \u2293 g\u2082 = \u22a5"}, {"line": "rw [comap_surjective_eq_bot h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_fst_neBot_iff {f : Filter \u03b1} :\n    (f.comap (Prod.fst : \u03b1 \u00d7 \u03b2 \u2192 \u03b1)).NeBot \u2194 f.NeBot \u2227 Nonempty \u03b2 := by\n  cases isEmpty_or_nonempty \u03b2\n  \u00b7 rw [filter_eq_bot_of_isEmpty (f.comap _), \u2190 not_iff_not]; simp [*]\n  \u00b7 simp [comap_neBot_iff_frequently, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\n\u22a2 (comap Prod.fst f).NeBot \u2194 f.NeBot \u2227 Nonempty \u03b2"}, {"line": "cases isEmpty_or_nonempty \u03b2", "tactic_state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\nh\u271d : IsEmpty \u03b2\n\u22a2 (comap Prod.fst f).NeBot \u2194 f.NeBot \u2227 Nonempty \u03b2\n---\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\nh\u271d : Nonempty \u03b2\n\u22a2 (comap Prod.fst f).NeBot \u2194 f.NeBot \u2227 Nonempty \u03b2"}, {"line": "\u00b7 rw [filter_eq_bot_of_isEmpty (f.comap _), \u2190 not_iff_not]; simp [*]", "tactic_state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\nh\u271d : Nonempty \u03b2\n\u22a2 (comap Prod.fst f).NeBot \u2194 f.NeBot \u2227 Nonempty \u03b2"}, {"line": "\u00b7 simp [comap_neBot_iff_frequently, *]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_snd_neBot_iff {f : Filter \u03b2} :\n    (f.comap (Prod.snd : \u03b1 \u00d7 \u03b2 \u2192 \u03b2)).NeBot \u2194 Nonempty \u03b1 \u2227 f.NeBot := by\n  rcases isEmpty_or_nonempty \u03b1 with h\u03b1 | h\u03b1\n  \u00b7 rw [filter_eq_bot_of_isEmpty (f.comap _), \u2190 not_iff_not]; simp\n  \u00b7 simp [comap_neBot_iff_frequently, h\u03b1]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\n\u22a2 (comap Prod.snd f).NeBot \u2194 Nonempty \u03b1 \u2227 f.NeBot"}, {"line": "rcases isEmpty_or_nonempty \u03b1 with h\u03b1 | h\u03b1", "tactic_state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nh\u03b1 : IsEmpty \u03b1\n\u22a2 (comap Prod.snd f).NeBot \u2194 Nonempty \u03b1 \u2227 f.NeBot\n---\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nh\u03b1 : Nonempty \u03b1\n\u22a2 (comap Prod.snd f).NeBot \u2194 Nonempty \u03b1 \u2227 f.NeBot"}, {"line": "\u00b7 rw [filter_eq_bot_of_isEmpty (f.comap _), \u2190 not_iff_not]; simp", "tactic_state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nh\u03b1 : Nonempty \u03b1\n\u22a2 (comap Prod.snd f).NeBot \u2194 Nonempty \u03b1 \u2227 f.NeBot"}, {"line": "\u00b7 simp [comap_neBot_iff_frequently, h\u03b1]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_eval_neBot_iff {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 j, Nonempty (\u03b1 j)] {i : \u03b9}\n    {f : Filter (\u03b1 i)} : (comap (eval i) f).NeBot \u2194 NeBot f := by simp [comap_eval_neBot_iff', *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_6\n\u03b1 : \u03b9 \u2192 Type u_7\ninst\u271d : \u2200 (j : \u03b9), Nonempty (\u03b1 j)\ni : \u03b9\nf : Filter (\u03b1 i)\n\u22a2 (comap (eval i) f).NeBot \u2194 f.NeBot"}, {"line": "simp [comap_eval_neBot_iff', *]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_neBot_iff (f : \u03b1 \u2192 \u03b2) {F : Filter \u03b1} : NeBot (map f F) \u2194 NeBot F := by\n  simp only [neBot_iff]\n  simp only [Ne]\n  simp only [map_eq_bot_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\n\u22a2 (map f F).NeBot \u2194 F.NeBot"}, {"line": "simp only [neBot_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\n\u22a2 map f F \u2260 \u22a5 \u2194 F \u2260 \u22a5"}, {"line": "simp only [Ne]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\n\u22a2 \u00acmap f F = \u22a5 \u2194 \u00acF = \u22a5"}, {"line": "simp only [map_eq_bot_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_biInf_eq {\u03b9 : Type w} {f : \u03b9 \u2192 Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {p : \u03b9 \u2192 Prop}\n    (h : DirectedOn (f \u207b\u00b9'o (\u00b7 \u2265 \u00b7)) { x | p x }) (ne : \u2203 i, p i) :\n    map m (\u2a05 (i) (_ : p i), f i) = \u2a05 (i) (_ : p i), map m (f i) := by\n  haveI := nonempty_subtype.2 ne\n  simp only [iInf_subtype']\n  exact map_iInf_eq h.directed_val\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type w\nf : \u03b9 \u2192 Filter \u03b1\nm : \u03b1 \u2192 \u03b2\np : \u03b9 \u2192 Prop\nh : DirectedOn (f \u207b\u00b9'o fun x1 x2 => x1 \u2265 x2) {x | p x}\nne : \u2203 i, p i\n\u22a2 map m (\u2a05 i, \u2a05 (_ : p i), f i) = \u2a05 i, \u2a05 (_ : p i), map m (f i)"}, {"line": "haveI := nonempty_subtype.2 ne", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type w\nf : \u03b9 \u2192 Filter \u03b1\nm : \u03b1 \u2192 \u03b2\np : \u03b9 \u2192 Prop\nh : DirectedOn (f \u207b\u00b9'o fun x1 x2 => x1 \u2265 x2) {x | p x}\nne : \u2203 i, p i\nthis : Nonempty (Subtype p)\n\u22a2 map m (\u2a05 i, \u2a05 (_ : p i), f i) = \u2a05 i, \u2a05 (_ : p i), map m (f i)"}, {"line": "simp only [iInf_subtype']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type w\nf : \u03b9 \u2192 Filter \u03b1\nm : \u03b1 \u2192 \u03b2\np : \u03b9 \u2192 Prop\nh : DirectedOn (f \u207b\u00b9'o fun x1 x2 => x1 \u2265 x2) {x | p x}\nne : \u2203 i, p i\nthis : Nonempty (Subtype p)\n\u22a2 map m (\u2a05 x, f \u2191x) = \u2a05 x, map m (f \u2191x)"}, {"line": "exact map_iInf_eq h.directed_val", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_inf {f g : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} (h : Injective m) :\n    map m (f \u2293 g) = map m f \u2293 map m g := by\n  refine map_inf_le.antisymm ?_\n  rintro t \u27e8s\u2081, hs\u2081, s\u2082, hs\u2082, ht : m \u207b\u00b9' t = s\u2081 \u2229 s\u2082\u27e9\n  refine mem_inf_of_inter (image_mem_map hs\u2081) (image_mem_map hs\u2082) ?_\n  rw [\u2190 image_inter h]\n  rw [image_subset_iff]\n  rw [ht]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : Filter \u03b1\nm : \u03b1 \u2192 \u03b2\nh : Injective m\n\u22a2 map m (f \u2293 g) = map m f \u2293 map m g"}, {"line": "refine map_inf_le.antisymm ?_", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : Filter \u03b1\nm : \u03b1 \u2192 \u03b2\nh : Injective m\n\u22a2 map m f \u2293 map m g \u2264 map m (f \u2293 g)"}, {"line": "rintro t \u27e8s\u2081, hs\u2081, s\u2082, hs\u2082, ht : m \u207b\u00b9' t = s\u2081 \u2229 s\u2082\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : Filter \u03b1\nm : \u03b1 \u2192 \u03b2\nh : Injective m\nt : Set \u03b2\ns\u2081 : Set \u03b1\nhs\u2081 : s\u2081 \u2208 f\ns\u2082 : Set \u03b1\nhs\u2082 : s\u2082 \u2208 g\nht : m \u207b\u00b9' t = s\u2081 \u2229 s\u2082\n\u22a2 t \u2208 map m f \u2293 map m g"}, {"line": "refine mem_inf_of_inter (image_mem_map hs\u2081) (image_mem_map hs\u2082) ?_", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : Filter \u03b1\nm : \u03b1 \u2192 \u03b2\nh : Injective m\nt : Set \u03b2\ns\u2081 : Set \u03b1\nhs\u2081 : s\u2081 \u2208 f\ns\u2082 : Set \u03b1\nhs\u2082 : s\u2082 \u2208 g\nht : m \u207b\u00b9' t = s\u2081 \u2229 s\u2082\n\u22a2 m '' s\u2081 \u2229 m '' s\u2082 \u2286 t"}, {"line": "rw [\u2190 image_inter h]", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : Filter \u03b1\nm : \u03b1 \u2192 \u03b2\nh : Injective m\nt : Set \u03b2\ns\u2081 : Set \u03b1\nhs\u2081 : s\u2081 \u2208 f\ns\u2082 : Set \u03b1\nhs\u2082 : s\u2082 \u2208 g\nht : m \u207b\u00b9' t = s\u2081 \u2229 s\u2082\n\u22a2 m '' (s\u2081 \u2229 s\u2082) \u2286 t"}, {"line": "rw [image_subset_iff]", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : Filter \u03b1\nm : \u03b1 \u2192 \u03b2\nh : Injective m\nt : Set \u03b2\ns\u2081 : Set \u03b1\nhs\u2081 : s\u2081 \u2208 f\ns\u2082 : Set \u03b1\nhs\u2082 : s\u2082 \u2208 g\nht : m \u207b\u00b9' t = s\u2081 \u2229 s\u2082\n\u22a2 s\u2081 \u2229 s\u2082 \u2286 m \u207b\u00b9' t"}, {"line": "rw [ht]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_map {m : \u03b1 \u2192 \u03b2} (hm : Injective m) {f\u2081 f\u2082 : Filter \u03b1} :\n    Disjoint (map m f\u2081) (map m f\u2082) \u2194 Disjoint f\u2081 f\u2082 := by\n  simp only [disjoint_iff]\n  simp only [\u2190 map_inf hm]\n  simp only [map_eq_bot_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : \u03b1 \u2192 \u03b2\nhm : Injective m\nf\u2081 f\u2082 : Filter \u03b1\n\u22a2 Disjoint (map m f\u2081) (map m f\u2082) \u2194 Disjoint f\u2081 f\u2082"}, {"line": "simp only [disjoint_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : \u03b1 \u2192 \u03b2\nhm : Injective m\nf\u2081 f\u2082 : Filter \u03b1\n\u22a2 map m f\u2081 \u2293 map m f\u2082 = \u22a5 \u2194 f\u2081 \u2293 f\u2082 = \u22a5"}, {"line": "simp only [\u2190 map_inf hm]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : \u03b1 \u2192 \u03b2\nhm : Injective m\nf\u2081 f\u2082 : Filter \u03b1\n\u22a2 map m (f\u2081 \u2293 f\u2082) = \u22a5 \u2194 f\u2081 \u2293 f\u2082 = \u22a5"}, {"line": "simp only [map_eq_bot_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_comap_iff_map {f : \u03b1 \u2192 \u03b2} {F : Filter \u03b1} {G : Filter \u03b2} :\n    Disjoint F (comap f G) \u2194 Disjoint (map f F) G := by\n  simp only [disjoint_iff]\n  simp only [\u2190 Filter.push_pull]\n  simp only [map_eq_bot_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\nG : Filter \u03b2\n\u22a2 Disjoint F (comap f G) \u2194 Disjoint (map f F) G"}, {"line": "simp only [disjoint_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\nG : Filter \u03b2\n\u22a2 F \u2293 comap f G = \u22a5 \u2194 map f F \u2293 G = \u22a5"}, {"line": "simp only [\u2190 Filter.push_pull]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\nG : Filter \u03b2\n\u22a2 F \u2293 comap f G = \u22a5 \u2194 map f (F \u2293 comap f G) = \u22a5"}, {"line": "simp only [map_eq_bot_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_comap_iff_map' {f : \u03b1 \u2192 \u03b2} {F : Filter \u03b1} {G : Filter \u03b2} :\n    Disjoint (comap f G) F \u2194 Disjoint G (map f F) := by\n  simp only [disjoint_iff]\n  simp only [\u2190 Filter.push_pull']\n  simp only [map_eq_bot_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\nG : Filter \u03b2\n\u22a2 Disjoint (comap f G) F \u2194 Disjoint G (map f F)"}, {"line": "simp only [disjoint_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\nG : Filter \u03b2\n\u22a2 comap f G \u2293 F = \u22a5 \u2194 G \u2293 map f F = \u22a5"}, {"line": "simp only [\u2190 Filter.push_pull']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\nG : Filter \u03b2\n\u22a2 comap f G \u2293 F = \u22a5 \u2194 map f (comap f G \u2293 F) = \u22a5"}, {"line": "simp only [map_eq_bot_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neBot_inf_comap_iff_map {f : \u03b1 \u2192 \u03b2} {F : Filter \u03b1} {G : Filter \u03b2} :\n    NeBot (F \u2293 comap f G) \u2194 NeBot (map f F \u2293 G) := by\n  rw [\u2190 map_neBot_iff]\n  rw [Filter.push_pull]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\nG : Filter \u03b2\n\u22a2 (F \u2293 comap f G).NeBot \u2194 (map f F \u2293 G).NeBot"}, {"line": "rw [\u2190 map_neBot_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\nG : Filter \u03b2\n\u22a2 (map ?f (F \u2293 comap f G)).NeBot \u2194 (map f F \u2293 G).NeBot\n---\ncase f\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\nG : Filter \u03b2\n\u22a2 \u03b1 \u2192 ?m.848\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\nG : Filter \u03b2\n\u22a2 Type ?u.845"}, {"line": "rw [Filter.push_pull]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neBot_inf_comap_iff_map' {f : \u03b1 \u2192 \u03b2} {F : Filter \u03b1} {G : Filter \u03b2} :\n    NeBot (comap f G \u2293 F) \u2194 NeBot (G \u2293 map f F) := by\n  rw [\u2190 map_neBot_iff]\n  rw [Filter.push_pull']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\nG : Filter \u03b2\n\u22a2 (comap f G \u2293 F).NeBot \u2194 (G \u2293 map f F).NeBot"}, {"line": "rw [\u2190 map_neBot_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\nG : Filter \u03b2\n\u22a2 (map ?f (comap f G \u2293 F)).NeBot \u2194 (G \u2293 map f F).NeBot\n---\ncase f\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\nG : Filter \u03b2\n\u22a2 \u03b1 \u2192 ?m.848\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nF : Filter \u03b1\nG : Filter \u03b2\n\u22a2 Type ?u.845"}, {"line": "rw [Filter.push_pull']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_inf_principal_neBot_of_image_mem {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} (hf : NeBot f) {s : Set \u03b1}\n    (hs : m '' s \u2208 f) : NeBot (comap m f \u2293 \ud835\udcdf s) := by\n  rw [neBot_inf_comap_iff_map']\n  rw [map_principal]\n  rw [\u2190 frequently_mem_iff_neBot]\n  exact Eventually.frequently hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nhf : f.NeBot\ns : Set \u03b1\nhs : m '' s \u2208 f\n\u22a2 (comap m f \u2293 principal s).NeBot"}, {"line": "rw [neBot_inf_comap_iff_map']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nhf : f.NeBot\ns : Set \u03b1\nhs : m '' s \u2208 f\n\u22a2 (f \u2293 map m (principal s)).NeBot"}, {"line": "rw [map_principal]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nhf : f.NeBot\ns : Set \u03b1\nhs : m '' s \u2208 f\n\u22a2 (f \u2293 principal (m '' s)).NeBot"}, {"line": "rw [\u2190 frequently_mem_iff_neBot]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nhf : f.NeBot\ns : Set \u03b1\nhs : m '' s \u2208 f\n\u22a2 \u2203\u1da0 (x : \u03b2) in f, x \u2208 m '' s"}, {"line": "exact Eventually.frequently hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem principal_eq_map_coe_top (s : Set \u03b1) : \ud835\udcdf s = map ((\u2191) : s \u2192 \u03b1) \u22a4 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 principal s = map Subtype.val \u22a4"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_generate_le_generate_preimage_preimage (U : Set (Set \u03b2)) (f : \u03b2 \u2192 \u03b1) :\n    map f (generate U) \u2264 generate ((f \u207b\u00b9' \u00b7) \u207b\u00b9' U) := by\n  rw [le_generate_iff]\n  exact fun u hu \u21a6 mem_generate_of_mem hu\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nU : Set (Set \u03b2)\nf : \u03b2 \u2192 \u03b1\n\u22a2 map f (generate U) \u2264 generate ((fun x => f \u207b\u00b9' x) \u207b\u00b9' U)"}, {"line": "rw [le_generate_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nU : Set (Set \u03b2)\nf : \u03b2 \u2192 \u03b1\n\u22a2 (fun x => f \u207b\u00b9' x) \u207b\u00b9' U \u2286 (map f (generate U)).sets"}, {"line": "exact fun u hu \u21a6 mem_generate_of_mem hu", "tactic_state": "No Goals!"}]}
{"declaration": "lemma generate_image_preimage_le_comap (U : Set (Set \u03b1)) (f : \u03b2 \u2192 \u03b1) :\n    generate ((f \u207b\u00b9' \u00b7) '' U) \u2264 comap f (generate U) := by\n  rw [\u2190 map_le_iff_le_comap]\n  rw [le_generate_iff]\n  exact fun u hu \u21a6 mem_generate_of_mem \u27e8u, hu, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nU : Set (Set \u03b1)\nf : \u03b2 \u2192 \u03b1\n\u22a2 generate ((fun x => f \u207b\u00b9' x) '' U) \u2264 comap f (generate U)"}, {"line": "rw [\u2190 map_le_iff_le_comap]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nU : Set (Set \u03b1)\nf : \u03b2 \u2192 \u03b1\n\u22a2 map f (generate ((fun x => f \u207b\u00b9' x) '' U)) \u2264 generate U"}, {"line": "rw [le_generate_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nU : Set (Set \u03b1)\nf : \u03b2 \u2192 \u03b1\n\u22a2 U \u2286 (map f (generate ((fun x => f \u207b\u00b9' x) '' U))).sets"}, {"line": "exact fun u hu \u21a6 mem_generate_of_mem \u27e8u, hu, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_pure_iff {f : Filter \u03b1} {a : \u03b1} : f \u2264 pure a \u2194 {a} \u2208 f := by\n  rw [\u2190 principal_singleton]\n  rw [le_principal_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\na : \u03b1\n\u22a2 f \u2264 pure a \u2194 {a} \u2208 f"}, {"line": "rw [\u2190 principal_singleton]", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\na : \u03b1\n\u22a2 f \u2264 principal {a} \u2194 {a} \u2208 f"}, {"line": "rw [le_principal_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bind_mono {f\u2081 f\u2082 : Filter \u03b1} {g\u2081 g\u2082 : \u03b1 \u2192 Filter \u03b2} (hf : f\u2081 \u2264 f\u2082) (hg : g\u2081 \u2264\u1da0[f\u2081] g\u2082) :\n    bind f\u2081 g\u2081 \u2264 bind f\u2082 g\u2082 := by\n  refine le_trans (fun s hs => ?_) (join_mono <| map_mono hf)\n  simp only [mem_join] at hs \u22a2\n  simp only [mem_bind'] at hs \u22a2\n  simp only [mem_map] at hs \u22a2\n  filter_upwards [hg, hs] with _ hx hs using hx hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf\u2081 f\u2082 : Filter \u03b1\ng\u2081 g\u2082 : \u03b1 \u2192 Filter \u03b2\nhf : f\u2081 \u2264 f\u2082\nhg : g\u2081 \u2264\u1da0[f\u2081] g\u2082\n\u22a2 f\u2081.bind g\u2081 \u2264 f\u2082.bind g\u2082"}, {"line": "refine le_trans (fun s hs => ?_) (join_mono <| map_mono hf)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf\u2081 f\u2082 : Filter \u03b1\ng\u2081 g\u2082 : \u03b1 \u2192 Filter \u03b2\nhf : f\u2081 \u2264 f\u2082\nhg : g\u2081 \u2264\u1da0[f\u2081] g\u2082\ns : Set \u03b2\nhs : s \u2208 (map g\u2082 f\u2081).join\n\u22a2 s \u2208 f\u2081.bind g\u2081"}, {"line": "simp only [mem_join] at hs \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf\u2081 f\u2082 : Filter \u03b1\ng\u2081 g\u2082 : \u03b1 \u2192 Filter \u03b2\nhf : f\u2081 \u2264 f\u2082\nhg : g\u2081 \u2264\u1da0[f\u2081] g\u2082\ns : Set \u03b2\nhs : {t | s \u2208 t} \u2208 map g\u2082 f\u2081\n\u22a2 s \u2208 f\u2081.bind g\u2081"}, {"line": "simp only [mem_bind'] at hs \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf\u2081 f\u2082 : Filter \u03b1\ng\u2081 g\u2082 : \u03b1 \u2192 Filter \u03b2\nhf : f\u2081 \u2264 f\u2082\nhg : g\u2081 \u2264\u1da0[f\u2081] g\u2082\ns : Set \u03b2\nhs : {t | s \u2208 t} \u2208 map g\u2082 f\u2081\n\u22a2 {a | s \u2208 g\u2081 a} \u2208 f\u2081"}, {"line": "simp only [mem_map] at hs \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf\u2081 f\u2082 : Filter \u03b1\ng\u2081 g\u2082 : \u03b1 \u2192 Filter \u03b2\nhf : f\u2081 \u2264 f\u2082\nhg : g\u2081 \u2264\u1da0[f\u2081] g\u2082\ns : Set \u03b2\nhs : g\u2082 \u207b\u00b9' {t | s \u2208 t} \u2208 f\u2081\n\u22a2 {a | s \u2208 g\u2081 a} \u2208 f\u2081"}, {"line": "filter_upwards [hg, hs] with _ hx hs using hx hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.map_surjOn_Iic_iff_surjOn {s : Set \u03b1} {t : Set \u03b2} {m : \u03b1 \u2192 \u03b2} :\n    SurjOn (map m) (Iic <| \ud835\udcdf s) (Iic <| \ud835\udcdf t) \u2194 SurjOn m s t := by\n  rw [map_surjOn_Iic_iff_le_map]\n  rw [map_principal]\n  rw [principal_mono]\n  rw [SurjOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}", "{\u03b1 \u03b2 : Type*} {F : Filter \u03b1} {G : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\n\u03b2 : Type u_7\ns : Set \u03b1\nt : Set \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 SurjOn (map m) (Iic (principal s)) (Iic (principal t)) \u2194 SurjOn m s t"}, {"line": "rw [map_surjOn_Iic_iff_le_map]", "tactic_state": "\u03b1 : Type u_6\n\u03b2 : Type u_7\ns : Set \u03b1\nt : Set \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 principal t \u2264 map m (principal s) \u2194 SurjOn m s t"}, {"line": "rw [map_principal]", "tactic_state": "\u03b1 : Type u_6\n\u03b2 : Type u_7\ns : Set \u03b1\nt : Set \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 principal t \u2264 principal (m '' s) \u2194 SurjOn m s t"}, {"line": "rw [principal_mono]", "tactic_state": "\u03b1 : Type u_6\n\u03b2 : Type u_7\ns : Set \u03b1\nt : Set \u03b2\nm : \u03b1 \u2192 \u03b2\n\u22a2 t \u2286 m '' s \u2194 SurjOn m s t"}, {"line": "rw [SurjOn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.filter_injOn_Iic_iff_injOn {s : Set \u03b1} {m : \u03b1 \u2192 \u03b2} :\n    InjOn (map m) (Iic <| \ud835\udcdf s) \u2194 InjOn m s := by\n  refine \u27e8fun hm x hx y hy hxy \u21a6 ?_, fun hm F hF G hG \u21a6 ?_\u27e9\n  \u00b7 rwa [\u2190 pure_injective.eq_iff, \u2190 map_pure, \u2190 map_pure, hm.eq_iff, pure_injective.eq_iff]\n      at hxy <;> rwa [mem_Iic, pure_le_principal]\n  \u00b7 simp [map_eq_map_iff_of_injOn (le_principal_iff.mp hF) (le_principal_iff.mp hG) hm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Map.lean", "context": {"open": ["Function Set Order", "scoped symmDiff", "Filter", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {F : Filter \u03b1} {G : Filter \u03b2}", "{f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} {p : \u03b1 \u2192 Prop} {s : Set \u03b1}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} {m' : \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}", "{\u03c6 : \u03b1 \u2192 \u03b2} {\u03b8 : \u03b1 \u2192 \u03b3} {\u03c8 : \u03b2 \u2192 \u03b4} {\u03c1 : \u03b3 \u2192 \u03b4}", "{m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1}", "{\u03b1 \u03b2 : Type*} {F : Filter \u03b1} {G : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\n\u03b2 : Type u_7\ns : Set \u03b1\nm : \u03b1 \u2192 \u03b2\n\u22a2 InjOn (map m) (Iic (principal s)) \u2194 InjOn m s"}, {"line": "refine \u27e8fun hm x hx y hy hxy \u21a6 ?_, fun hm F hF G hG \u21a6 ?_\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u_6\n\u03b2 : Type u_7\ns : Set \u03b1\nm : \u03b1 \u2192 \u03b2\nhm : InjOn (map m) (Iic (principal s))\nx : \u03b1\nhx : x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nhxy : m x = m y\n\u22a2 x = y\n---\ncase refine_2\n\u03b1 : Type u_6\n\u03b2 : Type u_7\ns : Set \u03b1\nm : \u03b1 \u2192 \u03b2\nhm : InjOn m s\nF : Filter \u03b1\nhF : F \u2208 Iic (principal s)\nG : Filter \u03b1\nhG : G \u2208 Iic (principal s)\n\u22a2 map m F = map m G \u2192 F = G"}, {"line": "\u00b7 rwa [\u2190 pure_injective.eq_iff, \u2190 map_pure, \u2190 map_pure, hm.eq_iff, pure_injective.eq_iff]\n      at hxy <;> rwa [mem_Iic, pure_le_principal]", "tactic_state": "case refine_2\n\u03b1 : Type u_6\n\u03b2 : Type u_7\ns : Set \u03b1\nm : \u03b1 \u2192 \u03b2\nhm : InjOn m s\nF : Filter \u03b1\nhF : F \u2208 Iic (principal s)\nG : Filter \u03b1\nhG : G \u2208 Iic (principal s)\n\u22a2 map m F = map m G \u2192 F = G"}, {"line": "\u00b7 simp [map_eq_map_iff_of_injOn (le_principal_iff.mp hF) (le_principal_iff.mp hG) hm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_mem_pi {I : Set \u03b9} (hI : I.Finite) (h : \u2200 i \u2208 I, s i \u2208 f i) : I.pi s \u2208 pi f := by\n  rw [pi_def]\n  rw [biInter_eq_iInter]\n  refine mem_iInf_of_iInter hI (fun i => ?_) Subset.rfl\n  exact preimage_mem_comap (h i i.2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pi.lean", "context": {"open": ["Set Function Filter"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {f f\u2081 f\u2082 : (i : \u03b9) \u2192 Filter (\u03b1 i)} {s : (i : \u03b9) \u2192 Set (\u03b1 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\ns : (i : \u03b9) \u2192 Set (\u03b1 i)\nI : Set \u03b9\nhI : I.Finite\nh : \u2200 i \u2208 I, s i \u2208 f i\n\u22a2 I.pi s \u2208 Filter.pi f"}, {"line": "rw [pi_def]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\ns : (i : \u03b9) \u2192 Set (\u03b1 i)\nI : Set \u03b9\nhI : I.Finite\nh : \u2200 i \u2208 I, s i \u2208 f i\n\u22a2 \u22c2 a \u2208 I, eval a \u207b\u00b9' s a \u2208 Filter.pi f"}, {"line": "rw [biInter_eq_iInter]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\ns : (i : \u03b9) \u2192 Set (\u03b1 i)\nI : Set \u03b9\nhI : I.Finite\nh : \u2200 i \u2208 I, s i \u2208 f i\n\u22a2 \u22c2 x, eval \u2191x \u207b\u00b9' s \u2191x \u2208 Filter.pi f"}, {"line": "refine mem_iInf_of_iInter hI (fun i => ?_) Subset.rfl", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\ns : (i : \u03b9) \u2192 Set (\u03b1 i)\nI : Set \u03b9\nhI : I.Finite\nh : \u2200 i \u2208 I, s i \u2208 f i\ni : \u2191I\n\u22a2 eval \u2191i \u207b\u00b9' s \u2191i \u2208 comap (eval \u2191i) (f \u2191i)"}, {"line": "exact preimage_mem_comap (h i i.2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasBasis_pi {\u03b9' : \u03b9 \u2192 Type*} {s : \u2200 i, \u03b9' i \u2192 Set (\u03b1 i)} {p : \u2200 i, \u03b9' i \u2192 Prop}\n    (h : \u2200 i, (f i).HasBasis (p i) (s i)) :\n    (pi f).HasBasis (fun If : Set \u03b9 \u00d7 \u2200 i, \u03b9' i => If.1.Finite \u2227 \u2200 i \u2208 If.1, p i (If.2 i))\n      fun If : Set \u03b9 \u00d7 \u2200 i, \u03b9' i => If.1.pi fun i => s i <| If.2 i := by\n  simpa [Set.pi_def] using hasBasis_iInf' fun i => (h i).comap (eval i : (\u2200 j, \u03b1 j) \u2192 \u03b1 i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pi.lean", "context": {"open": ["Set Function Filter"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {f f\u2081 f\u2082 : (i : \u03b9) \u2192 Filter (\u03b1 i)} {s : (i : \u03b9) \u2192 Set (\u03b1 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\n\u03b9' : \u03b9 \u2192 Type u_3\ns : (i : \u03b9) \u2192 \u03b9' i \u2192 Set (\u03b1 i)\np : (i : \u03b9) \u2192 \u03b9' i \u2192 Prop\nh : \u2200 (i : \u03b9), (f i).HasBasis (p i) (s i)\n\u22a2 (Filter.pi f).HasBasis (fun If => If.1.Finite \u2227 \u2200 i \u2208 If.1, p i (If.2 i)) fun If => If.1.pi fun i => s i (If.2 i)"}, {"line": "simpa [Set.pi_def] using hasBasis_iInf' fun i => (h i).comap (eval i : (\u2200 j, \u03b1 j) \u2192 \u03b1 i)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.pi_self {\u03b1 : Type*} {\u03ba : Type*} {f : Filter \u03b1} {p : \u03ba \u2192 Prop} {s : \u03ba \u2192 Set \u03b1}\n    (h : f.HasBasis p s) :\n    (pi fun _ \u21a6 f).HasBasis (fun Ik : Set \u03b9 \u00d7 \u03ba \u21a6 Ik.1.Finite \u2227 p Ik.2)\n      (fun Ik \u21a6 Ik.1.pi (fun _ \u21a6 s Ik.2)) := by\n  refine hasBasis_pi_same_index (fun _ \u21a6 h) (fun I k hI hk \u21a6 ?_)\n  rcases h.mem_iff.mp (biInter_mem hI |>.mpr fun i hi \u21a6 h.mem_of_mem (hk i hi))\n    with \u27e8k\u2080, hk\u2080, hk\u2080'\u27e9\n  exact \u27e8k\u2080, hk\u2080, fun i hi \u21a6 hk\u2080'.trans (biInter_subset_of_mem hi)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pi.lean", "context": {"open": ["Set Function Filter"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {f f\u2081 f\u2082 : (i : \u03b9) \u2192 Filter (\u03b1 i)} {s : (i : \u03b9) \u2192 Set (\u03b1 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\n\u03ba : Type u_4\nf : Filter \u03b1\np : \u03ba \u2192 Prop\ns : \u03ba \u2192 Set \u03b1\nh : f.HasBasis p s\n\u22a2 (Filter.pi fun x => f).HasBasis (fun Ik => Ik.1.Finite \u2227 p Ik.2) fun Ik => Ik.1.pi fun x => s Ik.2"}, {"line": "refine hasBasis_pi_same_index (fun _ \u21a6 h) (fun I k hI hk \u21a6 ?_)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\n\u03ba : Type u_4\nf : Filter \u03b1\np : \u03ba \u2192 Prop\ns : \u03ba \u2192 Set \u03b1\nh : f.HasBasis p s\nI : Set \u03b9\nk : \u03b9 \u2192 \u03ba\nhI : I.Finite\nhk : \u2200 i \u2208 I, p (k i)\n\u22a2 \u2203 k\u2080, p k\u2080 \u2227 \u2200 i \u2208 I, s k\u2080 \u2286 s (k i)"}, {"line": "rcases h.mem_iff.mp (biInter_mem hI |>.mpr fun i hi \u21a6 h.mem_of_mem (hk i hi))\n    with \u27e8k\u2080, hk\u2080, hk\u2080'\u27e9", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\n\u03b1 : Type u_3\n\u03ba : Type u_4\nf : Filter \u03b1\np : \u03ba \u2192 Prop\ns : \u03ba \u2192 Set \u03b1\nh : f.HasBasis p s\nI : Set \u03b9\nk : \u03b9 \u2192 \u03ba\nhI : I.Finite\nhk : \u2200 i \u2208 I, p (k i)\nk\u2080 : \u03ba\nhk\u2080 : p k\u2080\nhk\u2080' : s k\u2080 \u2286 \u22c2 i \u2208 I, s (k i)\n\u22a2 \u2203 k\u2080, p k\u2080 \u2227 \u2200 i \u2208 I, s k\u2080 \u2286 s (k i)"}, {"line": "exact \u27e8k\u2080, hk\u2080, fun i hi \u21a6 hk\u2080'.trans (biInter_subset_of_mem hi)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_principal [Finite \u03b9] (s : (i : \u03b9) \u2192 Set (\u03b1 i)) :\n    pi (fun i \u21a6 \ud835\udcdf (s i)) = \ud835\udcdf (univ.pi s) := by\n  simp [Filter.pi, Set.pi_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pi.lean", "context": {"open": ["Set Function Filter"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {f f\u2081 f\u2082 : (i : \u03b9) \u2192 Filter (\u03b1 i)} {s : (i : \u03b9) \u2192 Set (\u03b1 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d : Finite \u03b9\ns : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 (Filter.pi fun i => principal (s i)) = principal (univ.pi s)"}, {"line": "simp [Filter.pi, Set.pi_def]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d : Finite \u03b9\ns : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 \u2a05 i, principal (eval i \u207b\u00b9' s i) = principal (\u22c2 a, eval a \u207b\u00b9' s a)"}]}
{"declaration": "theorem mem_pi_pure {f : (i : \u03b9) \u2192 \u03b1 i} {s : Set ((i : \u03b9) \u2192 \u03b1 i)} :\n    s \u2208 pi (fun i \u21a6 pure (f i)) \u2194 \u2203 I : Set \u03b9, I.Finite \u2227 \u2200 g, (\u2200 i \u2208 I, g i = f i) \u2192 g \u2208 s := by\n  simp only [\u2190 principal_singleton]\n  simp only [mem_pi_principal]\n  simp [subset_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pi.lean", "context": {"open": ["Set Function Filter"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {f f\u2081 f\u2082 : (i : \u03b9) \u2192 Filter (\u03b1 i)} {s : (i : \u03b9) \u2192 Set (\u03b1 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 \u03b1 i\ns : Set ((i : \u03b9) \u2192 \u03b1 i)\n\u22a2 (s \u2208 Filter.pi fun i => pure (f i)) \u2194 \u2203 I, I.Finite \u2227 \u2200 (g : (i : \u03b9) \u2192 \u03b1 i), (\u2200 i \u2208 I, g i = f i) \u2192 g \u2208 s"}, {"line": "simp only [\u2190 principal_singleton]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 \u03b1 i\ns : Set ((i : \u03b9) \u2192 \u03b1 i)\n\u22a2 (s \u2208 Filter.pi fun i => principal {f i}) \u2194 \u2203 I, I.Finite \u2227 \u2200 (g : (i : \u03b9) \u2192 \u03b1 i), (\u2200 i \u2208 I, g i = f i) \u2192 g \u2208 s"}, {"line": "simp only [mem_pi_principal]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 \u03b1 i\ns : Set ((i : \u03b9) \u2192 \u03b1 i)\n\u22a2 (\u2203 I, I.Finite \u2227 (I.pi fun i => {f i}) \u2286 s) \u2194 \u2203 I, I.Finite \u2227 \u2200 (g : (i : \u03b9) \u2192 \u03b1 i), (\u2200 i \u2208 I, g i = f i) \u2192 g \u2208 s"}, {"line": "simp [subset_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_inf_principal_univ_pi_neBot :\n    NeBot (pi f \u2293 \ud835\udcdf (Set.pi univ s)) \u2194 \u2200 i, NeBot (f i \u2293 \ud835\udcdf (s i)) := by simp [neBot_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pi.lean", "context": {"open": ["Set Function Filter"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {f f\u2081 f\u2082 : (i : \u03b9) \u2192 Filter (\u03b1 i)} {s : (i : \u03b9) \u2192 Set (\u03b1 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\ns : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 (Filter.pi f \u2293 principal (univ.pi s)).NeBot \u2194 \u2200 (i : \u03b9), (f i \u2293 principal (s i)).NeBot"}, {"line": "simp [neBot_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_inf_principal_pi_neBot [\u2200 i, NeBot (f i)] {I : Set \u03b9} :\n    NeBot (pi f \u2293 \ud835\udcdf (I.pi s)) \u2194 \u2200 i \u2208 I, NeBot (f i \u2293 \ud835\udcdf (s i)) := by simp [neBot_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pi.lean", "context": {"open": ["Set Function Filter"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {f f\u2081 f\u2082 : (i : \u03b9) \u2192 Filter (\u03b1 i)} {s : (i : \u03b9) \u2192 Set (\u03b1 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\ns : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), (f i).NeBot\nI : Set \u03b9\n\u22a2 (Filter.pi f \u2293 principal (I.pi s)).NeBot \u2194 \u2200 i \u2208 I, (f i \u2293 principal (s i)).NeBot"}, {"line": "simp [neBot_iff]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\ns : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), (f i).NeBot\nI : Set \u03b9\n\u22a2 \u00acFilter.pi f \u2293 principal (I.pi s) = \u22a5 \u2194 \u2200 i \u2208 I, \u00acf i \u2293 principal (s i) = \u22a5"}]}
{"declaration": "theorem pi_eq_bot : pi f = \u22a5 \u2194 \u2203 i, f i = \u22a5 := by\n  simpa using @pi_inf_principal_univ_pi_eq_bot \u03b9 \u03b1 f fun _ => univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pi.lean", "context": {"open": ["Set Function Filter"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {f f\u2081 f\u2082 : (i : \u03b9) \u2192 Filter (\u03b1 i)} {s : (i : \u03b9) \u2192 Set (\u03b1 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\n\u22a2 Filter.pi f = \u22a5 \u2194 \u2203 i, f i = \u22a5"}, {"line": "simpa using @pi_inf_principal_univ_pi_eq_bot \u03b9 \u03b1 f fun _ => univ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_neBot : NeBot (pi f) \u2194 \u2200 i, NeBot (f i) := by simp [neBot_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pi.lean", "context": {"open": ["Set Function Filter"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {f f\u2081 f\u2082 : (i : \u03b9) \u2192 Filter (\u03b1 i)} {s : (i : \u03b9) \u2192 Set (\u03b1 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\n\u22a2 (Filter.pi f).NeBot \u2194 \u2200 (i : \u03b9), (f i).NeBot"}, {"line": "simp [neBot_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_coprod\u1d62_iff {s : Set (\u2200 i, \u03b1 i)} :\n    s \u2208 Filter.coprod\u1d62 f \u2194 \u2200 i : \u03b9, \u2203 t\u2081 \u2208 f i, eval i \u207b\u00b9' t\u2081 \u2286 s := by simp [Filter.coprod\u1d62]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pi.lean", "context": {"open": ["Set Function Filter"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {f f\u2081 f\u2082 : (i : \u03b9) \u2192 Filter (\u03b1 i)} {s : (i : \u03b9) \u2192 Set (\u03b1 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\ns : Set ((i : \u03b9) \u2192 \u03b1 i)\n\u22a2 s \u2208 Filter.coprod\u1d62 f \u2194 \u2200 (i : \u03b9), \u2203 t\u2081 \u2208 f i, eval i \u207b\u00b9' t\u2081 \u2286 s"}, {"line": "simp [Filter.coprod\u1d62]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_mem_coprod\u1d62 {s : Set (\u2200 i, \u03b1 i)} :\n    s\u1d9c \u2208 Filter.coprod\u1d62 f \u2194 \u2200 i, (eval i '' s)\u1d9c \u2208 f i := by\n  simp only [Filter.coprod\u1d62]\n  simp only [mem_iSup]\n  simp only [compl_mem_comap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pi.lean", "context": {"open": ["Set Function Filter"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {f f\u2081 f\u2082 : (i : \u03b9) \u2192 Filter (\u03b1 i)} {s : (i : \u03b9) \u2192 Set (\u03b1 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\ns : Set ((i : \u03b9) \u2192 \u03b1 i)\n\u22a2 s\u1d9c \u2208 Filter.coprod\u1d62 f \u2194 \u2200 (i : \u03b9), (eval i '' s)\u1d9c \u2208 f i"}, {"line": "simp only [Filter.coprod\u1d62]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\ns : Set ((i : \u03b9) \u2192 \u03b1 i)\n\u22a2 s\u1d9c \u2208 \u2a06 i, comap (eval i) (f i) \u2194 \u2200 (i : \u03b9), (eval i '' s)\u1d9c \u2208 f i"}, {"line": "simp only [mem_iSup]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\ns : Set ((i : \u03b9) \u2192 \u03b1 i)\n\u22a2 (\u2200 (i : \u03b9), s\u1d9c \u2208 comap (eval i) (f i)) \u2194 \u2200 (i : \u03b9), (eval i '' s)\u1d9c \u2208 f i"}, {"line": "simp only [compl_mem_comap]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coprod\u1d62_neBot_iff' :\n    NeBot (Filter.coprod\u1d62 f) \u2194 (\u2200 i, Nonempty (\u03b1 i)) \u2227 \u2203 d, NeBot (f d) := by\n  simp only [Filter.coprod\u1d62]\n  simp only [iSup_neBot]\n  simp only [\u2190 exists_and_left]\n  simp only [\u2190 comap_eval_neBot_iff']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pi.lean", "context": {"open": ["Set Function Filter"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {f f\u2081 f\u2082 : (i : \u03b9) \u2192 Filter (\u03b1 i)} {s : (i : \u03b9) \u2192 Set (\u03b1 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\n\u22a2 (Filter.coprod\u1d62 f).NeBot \u2194 (\u2200 (i : \u03b9), Nonempty (\u03b1 i)) \u2227 \u2203 d, (f d).NeBot"}, {"line": "simp only [Filter.coprod\u1d62]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\n\u22a2 (\u2a06 i, comap (eval i) (f i)).NeBot \u2194 (\u2200 (i : \u03b9), Nonempty (\u03b1 i)) \u2227 \u2203 d, (f d).NeBot"}, {"line": "simp only [iSup_neBot]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\n\u22a2 (\u2203 i, (comap (eval i) (f i)).NeBot) \u2194 (\u2200 (i : \u03b9), Nonempty (\u03b1 i)) \u2227 \u2203 d, (f d).NeBot"}, {"line": "simp only [\u2190 exists_and_left]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\n\u22a2 (\u2203 i, (comap (eval i) (f i)).NeBot) \u2194 \u2203 x, (\u2200 (i : \u03b9), Nonempty (\u03b1 i)) \u2227 (f x).NeBot"}, {"line": "simp only [\u2190 comap_eval_neBot_iff']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coprod\u1d62_neBot_iff [\u2200 i, Nonempty (\u03b1 i)] : NeBot (Filter.coprod\u1d62 f) \u2194 \u2203 d, NeBot (f d) := by\n  simp [coprod\u1d62_neBot_iff', *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pi.lean", "context": {"open": ["Set Function Filter"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {f f\u2081 f\u2082 : (i : \u03b9) \u2192 Filter (\u03b1 i)} {s : (i : \u03b9) \u2192 Set (\u03b1 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\n\u22a2 (Filter.coprod\u1d62 f).NeBot \u2194 \u2203 d, (f d).NeBot"}, {"line": "simp [coprod\u1d62_neBot_iff', *]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coprod\u1d62_eq_bot_iff' : Filter.coprod\u1d62 f = \u22a5 \u2194 (\u2203 i, IsEmpty (\u03b1 i)) \u2228 f = \u22a5 := by\n  simpa only [not_neBot,not_and_or,funext_iff,not_forall,not_exists,not_nonempty_iff]\n    using coprod\u1d62_neBot_iff'.not\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pi.lean", "context": {"open": ["Set Function Filter"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {f f\u2081 f\u2082 : (i : \u03b9) \u2192 Filter (\u03b1 i)} {s : (i : \u03b9) \u2192 Set (\u03b1 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\n\u22a2 Filter.coprod\u1d62 f = \u22a5 \u2194 (\u2203 i, IsEmpty (\u03b1 i)) \u2228 f = \u22a5"}, {"line": "simpa only [not_neBot,not_and_or,funext_iff,not_forall,not_exists,not_nonempty_iff]\n    using coprod\u1d62_neBot_iff'.not", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_pi_map_coprod\u1d62_le :\n    map (fun k : \u2200 i, \u03b1 i => fun i => m i (k i)) (Filter.coprod\u1d62 f) \u2264\n      Filter.coprod\u1d62 fun i => map (m i) (f i) := by\n  simp only [le_def]\n  simp only [mem_map]\n  simp only [mem_coprod\u1d62_iff]\n  intro s h i\n  obtain \u27e8t, H, hH\u27e9 := h i\n  exact \u27e8{ x : \u03b1 i | m i x \u2208 t }, H, fun x hx => hH hx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pi.lean", "context": {"open": ["Set Function Filter"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {f f\u2081 f\u2082 : (i : \u03b9) \u2192 Filter (\u03b1 i)} {s : (i : \u03b9) \u2192 Set (\u03b1 i)}", "{\u03b2 : \u03b9 \u2192 Type*} {m : \u2200 i, \u03b1 i \u2192 \u03b2 i}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\n\u03b2 : \u03b9 \u2192 Type u_3\nm : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\n\u22a2 map (fun k i => m i (k i)) (Filter.coprod\u1d62 f) \u2264 Filter.coprod\u1d62 fun i => map (m i) (f i)"}, {"line": "simp only [le_def]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\n\u03b2 : \u03b9 \u2192 Type u_3\nm : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\n\u22a2 \u2200 x \u2208 Filter.coprod\u1d62 fun i => map (m i) (f i), x \u2208 map (fun k i => m i (k i)) (Filter.coprod\u1d62 f)"}, {"line": "simp only [mem_map]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\n\u03b2 : \u03b9 \u2192 Type u_3\nm : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\n\u22a2 \u2200 x \u2208 Filter.coprod\u1d62 fun i => map (m i) (f i), (fun k i => m i (k i)) \u207b\u00b9' x \u2208 Filter.coprod\u1d62 f"}, {"line": "simp only [mem_coprod\u1d62_iff]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\n\u03b2 : \u03b9 \u2192 Type u_3\nm : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\n\u22a2 \u2200 (x : Set ((i : \u03b9) \u2192 \u03b2 i)),\n    (\u2200 (i : \u03b9), \u2203 t\u2081 \u2208 map (m i) (f i), eval i \u207b\u00b9' t\u2081 \u2286 x) \u2192\n      \u2200 (i : \u03b9), \u2203 t\u2081 \u2208 f i, eval i \u207b\u00b9' t\u2081 \u2286 (fun k i => m i (k i)) \u207b\u00b9' x"}, {"line": "intro s h i", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\n\u03b2 : \u03b9 \u2192 Type u_3\nm : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\ns : Set ((i : \u03b9) \u2192 \u03b2 i)\nh : \u2200 (i : \u03b9), \u2203 t\u2081 \u2208 map (m i) (f i), eval i \u207b\u00b9' t\u2081 \u2286 s\ni : \u03b9\n\u22a2 \u2203 t\u2081 \u2208 f i, eval i \u207b\u00b9' t\u2081 \u2286 (fun k i => m i (k i)) \u207b\u00b9' s"}, {"line": "obtain \u27e8t, H, hH\u27e9 := h i", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf : (i : \u03b9) \u2192 Filter (\u03b1 i)\n\u03b2 : \u03b9 \u2192 Type u_3\nm : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\ns : Set ((i : \u03b9) \u2192 \u03b2 i)\nh : \u2200 (i : \u03b9), \u2203 t\u2081 \u2208 map (m i) (f i), eval i \u207b\u00b9' t\u2081 \u2286 s\ni : \u03b9\nt : Set (\u03b2 i)\nH : t \u2208 map (m i) (f i)\nhH : eval i \u207b\u00b9' t \u2286 s\n\u22a2 \u2203 t\u2081 \u2208 f i, eval i \u207b\u00b9' t\u2081 \u2286 (fun k i => m i (k i)) \u207b\u00b9' s"}, {"line": "exact \u27e8{ x : \u03b1 i | m i x \u2208 t }, H, fun x hx => hH hx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pure_mul_pure : (pure a : Filter \u03b1) * pure b = pure (a * b) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pointwise.lean", "context": {"open": ["Function Set Filter Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*}", "[One \u03b1] {f : Filter \u03b1} {s : Set \u03b1}", "[One \u03b2]", "[Inv \u03b1] {f g : Filter \u03b1} {s : Set \u03b1} {a : \u03b1}", "[InvolutiveInv \u03b1] {f g : Filter \u03b1} {s : Set \u03b1}", "[Mul \u03b1] [Mul \u03b2] {f f\u2081 f\u2082 g g\u2081 g\u2082 h : Filter \u03b1} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : Inv \u03b1\ninst\u271d\u00b9 : InvolutiveInv \u03b1\ninst\u271d : Mul \u03b1\na b : \u03b1\n\u22a2 pure a * pure b = pure (a * b)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pure_div_pure : (pure a : Filter \u03b1) / pure b = pure (a / b) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pointwise.lean", "context": {"open": ["Function Set Filter Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*}", "[One \u03b1] {f : Filter \u03b1} {s : Set \u03b1}", "[One \u03b2]", "[Inv \u03b1] {f g : Filter \u03b1} {s : Set \u03b1} {a : \u03b1}", "[InvolutiveInv \u03b1] {f g : Filter \u03b1} {s : Set \u03b1}", "[Mul \u03b1] [Mul \u03b2] {f f\u2081 f\u2082 g g\u2081 g\u2082 h : Filter \u03b1} {s t : Set \u03b1} {a b : \u03b1}", "[Div \u03b1] {f f\u2081 f\u2082 g g\u2081 g\u2082 h : Filter \u03b1} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : One \u03b1\ninst\u271d\u00b3 : Inv \u03b1\ninst\u271d\u00b2 : InvolutiveInv \u03b1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : Div \u03b1\na b : \u03b1\n\u22a2 pure a / pure b = pure (a / b)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pure_vsub_pure : (pure a : Filter \u03b2) -\u1d65 pure b = (pure (a -\u1d65 b) : Filter \u03b1) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Pointwise.lean", "context": {"open": ["Function Set Filter Pointwise", "Pointwise", "Pointwise", "Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*}", "[One \u03b1] {f : Filter \u03b1} {s : Set \u03b1}", "[One \u03b2]", "[Inv \u03b1] {f g : Filter \u03b1} {s : Set \u03b1} {a : \u03b1}", "[InvolutiveInv \u03b1] {f g : Filter \u03b1} {s : Set \u03b1}", "[Mul \u03b1] [Mul \u03b2] {f f\u2081 f\u2082 g g\u2081 g\u2082 h : Filter \u03b1} {s t : Set \u03b1} {a b : \u03b1}", "[Div \u03b1] {f f\u2081 f\u2082 g g\u2081 g\u2082 h : Filter \u03b1} {s t : Set \u03b1} {a b : \u03b1}", "[MulOneClass \u03b1] [MulOneClass \u03b2]", "[FunLike F \u03b1 \u03b2]", "[Monoid \u03b1] {f g : Filter \u03b1} {s : Set \u03b1} {a : \u03b1} {m n : \u2115}", "[DivisionMonoid \u03b1] {f g : Filter \u03b1}", "[Distrib \u03b1] {f g h : Filter \u03b1}", "[MulZeroClass \u03b1] {f g : Filter \u03b1}", "[Group \u03b1] [DivisionMonoid \u03b2] [FunLike F \u03b1 \u03b2] [MonoidHomClass F \u03b1 \u03b2]", "[GroupWithZero \u03b1] {f g : Filter \u03b1}", "[SMul \u03b1 \u03b2] {f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 h : Filter \u03b2} {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1}", "[VSub \u03b1 \u03b2] {f f\u2081 f\u2082 g g\u2081 g\u2082 : Filter \u03b2} {h : Filter \u03b1} {s t : Set \u03b2} {a b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9\u2077 : One \u03b1\ninst\u271d\u00b9\u2076 : One \u03b2\ninst\u271d\u00b9\u2075 : Inv \u03b1\ninst\u271d\u00b9\u2074 : InvolutiveInv \u03b1\ninst\u271d\u00b9\u00b3 : Mul \u03b1\ninst\u271d\u00b9\u00b2 : Mul \u03b2\ninst\u271d\u00b9\u00b9 : Div \u03b1\ninst\u271d\u00b9\u2070 : MulOneClass \u03b1\ninst\u271d\u2079 : MulOneClass \u03b2\ninst\u271d\u2078 : Monoid \u03b1\ninst\u271d\u2077 : DivisionMonoid \u03b1\ninst\u271d\u2076 : Distrib \u03b1\ninst\u271d\u2075 : MulZeroClass \u03b1\ninst\u271d\u2074 : Group \u03b1\ninst\u271d\u00b3 : DivisionMonoid \u03b2\ninst\u271d\u00b2 : GroupWithZero \u03b1\ninst\u271d\u00b9 : SMul \u03b1 \u03b2\ninst\u271d : VSub \u03b1 \u03b2\na b : \u03b2\n\u22a2 pure a -\u1d65 pure b = pure (a -\u1d65 b)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smallSets_eq_generate {f : Filter \u03b1} : f.smallSets = generate (powerset '' f.sets) := by\n  simp_rw [generate_eq_biInf, smallSets, iInf_image, Filter.lift', Filter.lift, Function.comp_apply,\n    Filter.mem_sets]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/SmallSets.lean", "context": {"open": ["Filter", "Filter Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*}", "{l l' la : Filter \u03b1} {lb : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\n\u22a2 f.smallSets = generate (powerset '' f.sets)"}, {"line": "simp_rw [generate_eq_biInf, smallSets, iInf_image, Filter.lift', Filter.lift, Function.comp_apply,\n    Filter.mem_sets]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bind_smallSets_gc :\n    GaloisConnection (fun L : Filter (Set \u03b1) \u21a6 L.bind principal) smallSets := by\n  intro L l\n  simp_rw [smallSets_eq_generate, le_generate_iff, image_subset_iff]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/SmallSets.lean", "context": {"open": ["Filter", "Filter Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*}", "{l l' la : Filter \u03b1} {lb : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 GaloisConnection (fun L => L.bind principal) smallSets"}, {"line": "intro L l", "tactic_state": "\u03b1 : Type u_1\nL : Filter (Set \u03b1)\nl : Filter \u03b1\n\u22a2 (fun L => L.bind principal) L \u2264 l \u2194 L \u2264 l.smallSets"}, {"line": "simp_rw [smallSets_eq_generate, le_generate_iff, image_subset_iff]", "tactic_state": "\u03b1 : Type u_1\nL : Filter (Set \u03b1)\nl : Filter \u03b1\n\u22a2 L.bind principal \u2264 l \u2194 l.sets \u2286 powerset \u207b\u00b9' L.sets"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tendsto_image_smallSets {f : \u03b1 \u2192 \u03b2} :\n    Tendsto (f '' \u00b7) la.smallSets lb.smallSets \u2194 Tendsto f la lb := by\n  rw [tendsto_smallSets_iff]\n  refine forall\u2082_congr fun u hu \u21a6 ?_\n  rw [eventually_smallSets' fun s t hst ht \u21a6 (image_subset _ hst).trans ht]\n  simp only [image_subset_iff]\n  simp only [exists_mem_subset_iff]\n  simp only [mem_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/SmallSets.lean", "context": {"open": ["Filter", "Filter Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*}", "{l l' la : Filter \u03b1} {lb : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nla : Filter \u03b1\nlb : Filter \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Tendsto (fun x => f '' x) la.smallSets lb.smallSets \u2194 Tendsto f la lb"}, {"line": "rw [tendsto_smallSets_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nla : Filter \u03b1\nlb : Filter \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 t \u2208 lb, \u2200\u1da0 (x : Set \u03b1) in la.smallSets, f '' x \u2286 t) \u2194 Tendsto f la lb"}, {"line": "refine forall\u2082_congr fun u hu \u21a6 ?_", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nla : Filter \u03b1\nlb : Filter \u03b2\nf : \u03b1 \u2192 \u03b2\nu : Set \u03b2\nhu : u \u2208 lb\n\u22a2 (\u2200\u1da0 (x : Set \u03b1) in la.smallSets, f '' x \u2286 u) \u2194 u \u2208 map f la"}, {"line": "rw [eventually_smallSets' fun s t hst ht \u21a6 (image_subset _ hst).trans ht]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nla : Filter \u03b1\nlb : Filter \u03b2\nf : \u03b1 \u2192 \u03b2\nu : Set \u03b2\nhu : u \u2208 lb\n\u22a2 (\u2203 s \u2208 la, f '' s \u2286 u) \u2194 u \u2208 map f la"}, {"line": "simp only [image_subset_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nla : Filter \u03b1\nlb : Filter \u03b2\nf : \u03b1 \u2192 \u03b2\nu : Set \u03b2\nhu : u \u2208 lb\n\u22a2 (\u2203 s \u2208 la, s \u2286 f \u207b\u00b9' u) \u2194 u \u2208 map f la"}, {"line": "simp only [exists_mem_subset_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nla : Filter \u03b1\nlb : Filter \u03b2\nf : \u03b1 \u2192 \u03b2\nu : Set \u03b2\nhu : u \u2208 lb\n\u22a2 f \u207b\u00b9' u \u2208 la \u2194 u \u2208 map f la"}, {"line": "simp only [mem_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smallSets_bot : (\u22a5 : Filter \u03b1).smallSets = pure \u2205 := by\n  rw [smallSets]\n  rw [lift'_bot]\n  rw [powerset_empty]\n  rw [principal_singleton]\n  exact monotone_powerset\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/SmallSets.lean", "context": {"open": ["Filter", "Filter Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*}", "{l l' la : Filter \u03b1} {lb : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 \u22a5.smallSets = pure \u2205"}, {"line": "rw [smallSets]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 \u22a5.lift' powerset = pure \u2205"}, {"line": "rw [lift'_bot]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 principal (\ud835\udcab\u2205) = pure \u2205\n---\n\u03b1 : Type u_1\n\u22a2 Monotone powerset"}, {"line": "rw [powerset_empty]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 principal {\u2205} = pure \u2205\n---\n\u03b1 : Type u_1\n\u22a2 Monotone powerset"}, {"line": "rw [principal_singleton]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 Monotone powerset"}, {"line": "exact monotone_powerset", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smallSets_top : (\u22a4 : Filter \u03b1).smallSets = \u22a4 := by\n  rw [smallSets]\n  rw [lift'_top]\n  rw [powerset_univ]\n  rw [principal_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/SmallSets.lean", "context": {"open": ["Filter", "Filter Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*}", "{l l' la : Filter \u03b1} {lb : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 \u22a4.smallSets = \u22a4"}, {"line": "rw [smallSets]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 \u22a4.lift' powerset = \u22a4"}, {"line": "rw [lift'_top]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 principal (\ud835\udcab univ) = \u22a4"}, {"line": "rw [powerset_univ]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 principal univ = \u22a4"}, {"line": "rw [principal_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smallSets_comap_eq_comap_image (l : Filter \u03b2) (f : \u03b1 \u2192 \u03b2) :\n    (comap f l).smallSets = comap (image f) l.smallSets := by\n  refine (gc_map_comap _).u_comm_of_l_comm (gc_map_comap _) bind_smallSets_gc bind_smallSets_gc ?_\n  simp [Function.comp_def, map_bind, bind_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/SmallSets.lean", "context": {"open": ["Filter", "Filter Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*}", "{l l' la : Filter \u03b1} {lb : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 (comap f l).smallSets = comap (image f) l.smallSets"}, {"line": "refine (gc_map_comap _).u_comm_of_l_comm (gc_map_comap _) bind_smallSets_gc bind_smallSets_gc ?_", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (x : Filter (Set \u03b1)), map f (x.bind principal) = (map (image f) x).bind principal"}, {"line": "simp [Function.comp_def, map_bind, bind_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Tendsto.smallSets_mono {s t : \u03b1 \u2192 Set \u03b2} (ht : Tendsto t la lb.smallSets)\n    (hst : \u2200\u1da0 x in la, s x \u2286 t x) : Tendsto s la lb.smallSets := by\n  rw [tendsto_smallSets_iff] at ht \u22a2\n  exact fun u hu => (ht u hu).mp (hst.mono fun _ hst ht => hst.trans ht)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/SmallSets.lean", "context": {"open": ["Filter", "Filter Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*}", "{l l' la : Filter \u03b1} {lb : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nla : Filter \u03b1\nlb : Filter \u03b2\ns t : \u03b1 \u2192 Set \u03b2\nht : Tendsto t la lb.smallSets\nhst : \u2200\u1da0 (x : \u03b1) in la, s x \u2286 t x\n\u22a2 Tendsto s la lb.smallSets"}, {"line": "rw [tendsto_smallSets_iff] at ht \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nla : Filter \u03b1\nlb : Filter \u03b2\ns t : \u03b1 \u2192 Set \u03b2\nht : \u2200 t_1 \u2208 lb, \u2200\u1da0 (x : \u03b1) in la, t x \u2286 t_1\nhst : \u2200\u1da0 (x : \u03b1) in la, s x \u2286 t x\n\u22a2 \u2200 t \u2208 lb, \u2200\u1da0 (x : \u03b1) in la, s x \u2286 t"}, {"line": "exact fun u hu => (ht u hu).mp (hst.mono fun _ hst ht => hst.trans ht)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_smallSets_forall {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 s in l.smallSets, \u2200 x \u2208 s, p x) \u2194 \u2200\u1da0 x in l, p x := by\n  simpa only [inf_top_eq,eventually_top] using @eventually_smallSets_eventually \u03b1 l \u22a4 p\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/SmallSets.lean", "context": {"open": ["Filter", "Filter Set"], "variables": ["{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*}", "{l l' la : Filter \u03b1} {lb : Filter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 (\u2200\u1da0 (s : Set \u03b1) in l.smallSets, \u2200 x \u2208 s, p x) \u2194 \u2200\u1da0 (x : \u03b1) in l, p x"}, {"line": "simpa only [inf_top_eq,eventually_top] using @eventually_smallSets_eventually \u03b1 l \u22a4 p", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_tendsto_iff_exists_frequently_nmem {f : \u03b1 \u2192 \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} :\n    \u00acTendsto f l\u2081 l\u2082 \u2194 \u2203 s \u2208 l\u2082, \u2203\u1da0 x in l\u2081, f x \u2209 s := by\n  simp only [tendsto_iff_forall_eventually_mem]\n  simp only [not_forall]\n  simp only [exists_prop]\n  simp only [not_eventually]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Tendsto.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\n\u22a2 \u00acTendsto f l\u2081 l\u2082 \u2194 \u2203 s \u2208 l\u2082, \u2203\u1da0 (x : \u03b1) in l\u2081, f x \u2209 s"}, {"line": "simp only [tendsto_iff_forall_eventually_mem]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\n\u22a2 (\u00ac\u2200 s \u2208 l\u2082, \u2200\u1da0 (x : \u03b1) in l\u2081, f x \u2208 s) \u2194 \u2203 s \u2208 l\u2082, \u2203\u1da0 (x : \u03b1) in l\u2081, f x \u2209 s"}, {"line": "simp only [not_forall]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\n\u22a2 (\u2203 x, \u2203 (_ : x \u2208 l\u2082), \u00ac\u2200\u1da0 (x_2 : \u03b1) in l\u2081, f x_2 \u2208 x) \u2194 \u2203 s \u2208 l\u2082, \u2203\u1da0 (x : \u03b1) in l\u2081, f x \u2209 s"}, {"line": "simp only [exists_prop]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\n\u22a2 (\u2203 x \u2208 l\u2082, \u00ac\u2200\u1da0 (x_1 : \u03b1) in l\u2081, f x_1 \u2208 x) \u2194 \u2203 s \u2208 l\u2082, \u2203\u1da0 (x : \u03b1) in l\u2081, f x \u2209 s"}, {"line": "simp only [not_eventually]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_bot {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} : Tendsto f \u22a5 l := by simp [Tendsto]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Tendsto.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nl : Filter \u03b2\n\u22a2 Tendsto f \u22a5 l"}, {"line": "simp [Tendsto]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Tendsto.of_neBot_imp {f : \u03b1 \u2192 \u03b2} {la : Filter \u03b1} {lb : Filter \u03b2}\n    (h : NeBot la \u2192 Tendsto f la lb) : Tendsto f la lb := by\n  rcases eq_or_neBot la with rfl | hla\n  \u00b7 exact tendsto_bot\n  \u00b7 exact h hla\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Tendsto.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nla : Filter \u03b1\nlb : Filter \u03b2\nh : la.NeBot \u2192 Tendsto f la lb\n\u22a2 Tendsto f la lb"}, {"line": "rcases eq_or_neBot la with rfl | hla", "tactic_state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nlb : Filter \u03b2\nh : \u22a5.NeBot \u2192 Tendsto f \u22a5 lb\n\u22a2 Tendsto f \u22a5 lb\n---\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nla : Filter \u03b1\nlb : Filter \u03b2\nh : la.NeBot \u2192 Tendsto f la lb\nhla : la.NeBot\n\u22a2 Tendsto f la lb"}, {"line": "\u00b7 exact tendsto_bot", "tactic_state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nla : Filter \u03b1\nlb : Filter \u03b2\nh : la.NeBot \u2192 Tendsto f la lb\nhla : la.NeBot\n\u22a2 Tendsto f la lb"}, {"line": "\u00b7 exact h hla", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_map_of_right_inverse {mab : \u03b1 \u2192 \u03b2} {mba : \u03b2 \u2192 \u03b1} {f : Filter \u03b1} {g : Filter \u03b2}\n    (h\u2081 : mab \u2218 mba =\u1da0[g] id) (h\u2082 : Tendsto mba g f) : g \u2264 map mab f := by\n  rw [\u2190 @map_id _ g]\n  rw [\u2190 map_congr h\u2081]\n  rw [\u2190 map_map]\n  exact map_mono h\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Tendsto.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nmab : \u03b1 \u2192 \u03b2\nmba : \u03b2 \u2192 \u03b1\nf : Filter \u03b1\ng : Filter \u03b2\nh\u2081 : mab \u2218 mba =\u1da0[g] id\nh\u2082 : Tendsto mba g f\n\u22a2 g \u2264 map mab f"}, {"line": "rw [\u2190 @map_id _ g]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nmab : \u03b1 \u2192 \u03b2\nmba : \u03b2 \u2192 \u03b1\nf : Filter \u03b1\ng : Filter \u03b2\nh\u2081 : mab \u2218 mba =\u1da0[g] id\nh\u2082 : Tendsto mba g f\n\u22a2 map id g \u2264 map mab f"}, {"line": "rw [\u2190 map_congr h\u2081]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nmab : \u03b1 \u2192 \u03b2\nmba : \u03b2 \u2192 \u03b1\nf : Filter \u03b1\ng : Filter \u03b2\nh\u2081 : mab \u2218 mba =\u1da0[g] id\nh\u2082 : Tendsto mba g f\n\u22a2 map (mab \u2218 mba) g \u2264 map mab f"}, {"line": "rw [\u2190 map_map]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nmab : \u03b1 \u2192 \u03b2\nmba : \u03b2 \u2192 \u03b1\nf : Filter \u03b1\ng : Filter \u03b2\nh\u2081 : mab \u2218 mba =\u1da0[g] id\nh\u2082 : Tendsto mba g f\n\u22a2 map mab (map mba g) \u2264 map mab f"}, {"line": "exact map_mono h\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_congr' {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} (hl : f\u2081 =\u1da0[l\u2081] f\u2082) :\n    Tendsto f\u2081 l\u2081 l\u2082 \u2194 Tendsto f\u2082 l\u2081 l\u2082 := by rw [Tendsto, Tendsto, map_congr hl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Tendsto.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf\u2081 f\u2082 : \u03b1 \u2192 \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nhl : f\u2081 =\u1da0[l\u2081] f\u2082\n\u22a2 Tendsto f\u2081 l\u2081 l\u2082 \u2194 Tendsto f\u2082 l\u2081 l\u2082"}, {"line": "rw [Tendsto, Tendsto, map_congr hl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_map'_iff {f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b2} {x : Filter \u03b1} {y : Filter \u03b3} :\n    Tendsto f (map g x) y \u2194 Tendsto (f \u2218 g) x y := by\n  rw [Tendsto]\n  rw [Tendsto]\n  rw [map_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Tendsto.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b2 \u2192 \u03b3\ng : \u03b1 \u2192 \u03b2\nx : Filter \u03b1\ny : Filter \u03b3\n\u22a2 Tendsto f (map g x) y \u2194 Tendsto (f \u2218 g) x y"}, {"line": "rw [Tendsto]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b2 \u2192 \u03b3\ng : \u03b1 \u2192 \u03b2\nx : Filter \u03b1\ny : Filter \u03b3\n\u22a2 map f (map g x) \u2264 y \u2194 Tendsto (f \u2218 g) x y"}, {"line": "rw [Tendsto]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b2 \u2192 \u03b3\ng : \u03b1 \u2192 \u03b2\nx : Filter \u03b1\ny : Filter \u03b3\n\u22a2 map f (map g x) \u2264 y \u2194 map (f \u2218 g) x \u2264 y"}, {"line": "rw [map_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_comap'_iff {m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1} {g : Filter \u03b2} {i : \u03b3 \u2192 \u03b1} (h : range i \u2208 f) :\n    Tendsto (m \u2218 i) (comap i f) g \u2194 Tendsto m f g := by\n  rw [Tendsto]\n  rw [\u2190 map_compose]\n  simp only [(\u00b7 \u2218 \u00b7)]\n  simp only [map_comap_of_mem h]\n  simp only [Tendsto]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Tendsto.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b1\ng : Filter \u03b2\ni : \u03b3 \u2192 \u03b1\nh : range i \u2208 f\n\u22a2 Tendsto (m \u2218 i) (comap i f) g \u2194 Tendsto m f g"}, {"line": "rw [Tendsto]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b1\ng : Filter \u03b2\ni : \u03b3 \u2192 \u03b1\nh : range i \u2208 f\n\u22a2 map (m \u2218 i) (comap i f) \u2264 g \u2194 Tendsto m f g"}, {"line": "rw [\u2190 map_compose]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b1\ng : Filter \u03b2\ni : \u03b3 \u2192 \u03b1\nh : range i \u2208 f\n\u22a2 (map m \u2218 map i) (comap i f) \u2264 g \u2194 Tendsto m f g"}, {"line": "simp only [(\u00b7 \u2218 \u00b7)]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b1\ng : Filter \u03b2\ni : \u03b3 \u2192 \u03b1\nh : range i \u2208 f\n\u22a2 map m (map i (comap i f)) \u2264 g \u2194 Tendsto m f g"}, {"line": "simp only [map_comap_of_mem h]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b1\ng : Filter \u03b2\ni : \u03b3 \u2192 \u03b1\nh : range i \u2208 f\n\u22a2 map m f \u2264 g \u2194 Tendsto m f g"}, {"line": "simp only [Tendsto]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Tendsto.of_tendsto_comp {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : Filter \u03b1} {b : Filter \u03b2} {c : Filter \u03b3}\n    (hfg : Tendsto (g \u2218 f) a c) (hg : comap g c \u2264 b) : Tendsto f a b := by\n  rw [tendsto_iff_comap] at hfg \u22a2\n  calc\n    a \u2264 comap (g \u2218 f) c := hfg\n    _ \u2264 comap f b := by simpa [comap_comap] using comap_mono hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Tendsto.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\na : Filter \u03b1\nb : Filter \u03b2\nc : Filter \u03b3\nhfg : Tendsto (g \u2218 f) a c\nhg : comap g c \u2264 b\n\u22a2 Tendsto f a b"}, {"line": "rw [tendsto_iff_comap] at hfg \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\na : Filter \u03b1\nb : Filter \u03b2\nc : Filter \u03b3\nhfg : a \u2264 comap (g \u2218 f) c\nhg : comap g c \u2264 b\n\u22a2 a \u2264 comap f b"}, {"line": "calc\n    a \u2264 comap (g \u2218 f) c := hfg\n    _ \u2264 comap f b := by simpa [comap_comap] using comap_mono hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_eq_of_inverse {f : Filter \u03b1} {g : Filter \u03b2} {\u03c6 : \u03b1 \u2192 \u03b2} (\u03c8 : \u03b2 \u2192 \u03b1) (eq : \u03c8 \u2218 \u03c6 = id)\n    (h\u03c6 : Tendsto \u03c6 f g) (h\u03c8 : Tendsto \u03c8 g f) : comap \u03c6 g = f := by\n  refine ((comap_mono <| map_le_iff_le_comap.1 h\u03c8).trans ?_).antisymm (map_le_iff_le_comap.1 h\u03c6)\n  rw [comap_comap]\n  rw [eq]\n  rw [comap_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Tendsto.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u03c6 : \u03b1 \u2192 \u03b2\n\u03c8 : \u03b2 \u2192 \u03b1\neq : \u03c8 \u2218 \u03c6 = id\nh\u03c6 : Tendsto \u03c6 f g\nh\u03c8 : Tendsto \u03c8 g f\n\u22a2 comap \u03c6 g = f"}, {"line": "refine ((comap_mono <| map_le_iff_le_comap.1 h\u03c8).trans ?_).antisymm (map_le_iff_le_comap.1 h\u03c6)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u03c6 : \u03b1 \u2192 \u03b2\n\u03c8 : \u03b2 \u2192 \u03b1\neq : \u03c8 \u2218 \u03c6 = id\nh\u03c6 : Tendsto \u03c6 f g\nh\u03c8 : Tendsto \u03c8 g f\n\u22a2 comap \u03c6 (comap \u03c8 f) \u2264 f"}, {"line": "rw [comap_comap]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u03c6 : \u03b1 \u2192 \u03b2\n\u03c8 : \u03b2 \u2192 \u03b1\neq : \u03c8 \u2218 \u03c6 = id\nh\u03c6 : Tendsto \u03c6 f g\nh\u03c8 : Tendsto \u03c8 g f\n\u22a2 comap (\u03c8 \u2218 \u03c6) f \u2264 f"}, {"line": "rw [eq]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u03c6 : \u03b1 \u2192 \u03b2\n\u03c8 : \u03b2 \u2192 \u03b1\neq : \u03c8 \u2218 \u03c6 = id\nh\u03c6 : Tendsto \u03c6 f g\nh\u03c8 : Tendsto \u03c8 g f\n\u22a2 comap id f \u2264 f"}, {"line": "rw [comap_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_eq_of_inverse {f : Filter \u03b1} {g : Filter \u03b2} {\u03c6 : \u03b1 \u2192 \u03b2} (\u03c8 : \u03b2 \u2192 \u03b1) (eq : \u03c6 \u2218 \u03c8 = id)\n    (h\u03c6 : Tendsto \u03c6 f g) (h\u03c8 : Tendsto \u03c8 g f) : map \u03c6 f = g := by\n  refine le_antisymm h\u03c6 (le_trans ?_ (map_mono h\u03c8))\n  rw [map_map]\n  rw [eq]\n  rw [map_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Tendsto.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u03c6 : \u03b1 \u2192 \u03b2\n\u03c8 : \u03b2 \u2192 \u03b1\neq : \u03c6 \u2218 \u03c8 = id\nh\u03c6 : Tendsto \u03c6 f g\nh\u03c8 : Tendsto \u03c8 g f\n\u22a2 map \u03c6 f = g"}, {"line": "refine le_antisymm h\u03c6 (le_trans ?_ (map_mono h\u03c8))", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u03c6 : \u03b1 \u2192 \u03b2\n\u03c8 : \u03b2 \u2192 \u03b1\neq : \u03c6 \u2218 \u03c8 = id\nh\u03c6 : Tendsto \u03c6 f g\nh\u03c8 : Tendsto \u03c8 g f\n\u22a2 g \u2264 map \u03c6 (map \u03c8 g)"}, {"line": "rw [map_map]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u03c6 : \u03b1 \u2192 \u03b2\n\u03c8 : \u03b2 \u2192 \u03b1\neq : \u03c6 \u2218 \u03c8 = id\nh\u03c6 : Tendsto \u03c6 f g\nh\u03c8 : Tendsto \u03c8 g f\n\u22a2 g \u2264 map (\u03c6 \u2218 \u03c8) g"}, {"line": "rw [eq]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Filter \u03b1\ng : Filter \u03b2\n\u03c6 : \u03b1 \u2192 \u03b2\n\u03c8 : \u03b2 \u2192 \u03b1\neq : \u03c6 \u2218 \u03c8 = id\nh\u03c6 : Tendsto \u03c6 f g\nh\u03c8 : Tendsto \u03c8 g f\n\u22a2 g \u2264 map id g"}, {"line": "rw [map_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_inf {f : \u03b1 \u2192 \u03b2} {x : Filter \u03b1} {y\u2081 y\u2082 : Filter \u03b2} :\n    Tendsto f x (y\u2081 \u2293 y\u2082) \u2194 Tendsto f x y\u2081 \u2227 Tendsto f x y\u2082 := by\n  simp only [Tendsto]\n  simp only [le_inf_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Tendsto.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nx : Filter \u03b1\ny\u2081 y\u2082 : Filter \u03b2\n\u22a2 Tendsto f x (y\u2081 \u2293 y\u2082) \u2194 Tendsto f x y\u2081 \u2227 Tendsto f x y\u2082"}, {"line": "simp only [Tendsto]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nx : Filter \u03b1\ny\u2081 y\u2082 : Filter \u03b2\n\u22a2 map f x \u2264 y\u2081 \u2293 y\u2082 \u2194 map f x \u2264 y\u2081 \u2227 map f x \u2264 y\u2082"}, {"line": "simp only [le_inf_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_iInf {f : \u03b1 \u2192 \u03b2} {x : Filter \u03b1} {y : \u03b9 \u2192 Filter \u03b2} :\n    Tendsto f x (\u2a05 i, y i) \u2194 \u2200 i, Tendsto f x (y i) := by\n  simp only [Tendsto]\n  simp only [le_iInf_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Tendsto.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\nf : \u03b1 \u2192 \u03b2\nx : Filter \u03b1\ny : \u03b9 \u2192 Filter \u03b2\n\u22a2 Tendsto f x (\u2a05 i, y i) \u2194 \u2200 (i : \u03b9), Tendsto f x (y i)"}, {"line": "simp only [Tendsto]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\nf : \u03b1 \u2192 \u03b2\nx : Filter \u03b1\ny : \u03b9 \u2192 Filter \u03b2\n\u22a2 map f x \u2264 \u2a05 i, y i \u2194 \u2200 (i : \u03b9), map f x \u2264 y i"}, {"line": "simp only [le_iInf_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_sup {f : \u03b1 \u2192 \u03b2} {x\u2081 x\u2082 : Filter \u03b1} {y : Filter \u03b2} :\n    Tendsto f (x\u2081 \u2294 x\u2082) y \u2194 Tendsto f x\u2081 y \u2227 Tendsto f x\u2082 y := by\n  simp only [Tendsto]\n  simp only [map_sup]\n  simp only [sup_le_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Tendsto.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nx\u2081 x\u2082 : Filter \u03b1\ny : Filter \u03b2\n\u22a2 Tendsto f (x\u2081 \u2294 x\u2082) y \u2194 Tendsto f x\u2081 y \u2227 Tendsto f x\u2082 y"}, {"line": "simp only [Tendsto]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nx\u2081 x\u2082 : Filter \u03b1\ny : Filter \u03b2\n\u22a2 map f (x\u2081 \u2294 x\u2082) \u2264 y \u2194 map f x\u2081 \u2264 y \u2227 map f x\u2082 \u2264 y"}, {"line": "simp only [map_sup]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nx\u2081 x\u2082 : Filter \u03b1\ny : Filter \u03b2\n\u22a2 map f x\u2081 \u2294 map f x\u2082 \u2264 y \u2194 map f x\u2081 \u2264 y \u2227 map f x\u2082 \u2264 y"}, {"line": "simp only [sup_le_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_iSup {f : \u03b1 \u2192 \u03b2} {x : \u03b9 \u2192 Filter \u03b1} {y : Filter \u03b2} :\n    Tendsto f (\u2a06 i, x i) y \u2194 \u2200 i, Tendsto f (x i) y := by simp only [Tendsto, map_iSup, iSup_le_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Tendsto.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\nf : \u03b1 \u2192 \u03b2\nx : \u03b9 \u2192 Filter \u03b1\ny : Filter \u03b2\n\u22a2 Tendsto f (\u2a06 i, x i) y \u2194 \u2200 (i : \u03b9), Tendsto f (x i) y"}, {"line": "simp only [Tendsto, map_iSup, iSup_le_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_principal_principal {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} :\n    Tendsto f (\ud835\udcdf s) (\ud835\udcdf t) \u2194 \u2200 a \u2208 s, f a \u2208 t := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Tendsto.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 Tendsto f (principal s) (principal t) \u2194 \u2200 a \u2208 s, f a \u2208 t"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Tendsto.if {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} {f g : \u03b1 \u2192 \u03b2} {p : \u03b1 \u2192 Prop}\n    [\u2200 x, Decidable (p x)] (h\u2080 : Tendsto f (l\u2081 \u2293 \ud835\udcdf { x | p x }) l\u2082)\n    (h\u2081 : Tendsto g (l\u2081 \u2293 \ud835\udcdf { x | \u00acp x }) l\u2082) :\n    Tendsto (fun x => if p x then f x else g x) l\u2081 l\u2082 := by\n  simp only [tendsto_def] at *\n  simp only [mem_inf_principal] at *\n  intro s hs\n  filter_upwards [h\u2080 s hs, h\u2081 s hs] with x hp\u2080 hp\u2081\n  rw [mem_preimage]\n  split_ifs with h\n  exacts [hp\u2080 h, hp\u2081 h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Tendsto.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nf g : \u03b1 \u2192 \u03b2\np : \u03b1 \u2192 Prop\ninst\u271d : (x : \u03b1) \u2192 Decidable (p x)\nh\u2080 : Tendsto f (l\u2081 \u2293 principal {x | p x}) l\u2082\nh\u2081 : Tendsto g (l\u2081 \u2293 principal {x | \u00acp x}) l\u2082\n\u22a2 Tendsto (fun x => if p x then f x else g x) l\u2081 l\u2082"}, {"line": "simp only [tendsto_def] at *", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nf g : \u03b1 \u2192 \u03b2\np : \u03b1 \u2192 Prop\ninst\u271d : (x : \u03b1) \u2192 Decidable (p x)\nh\u2080 : \u2200 s \u2208 l\u2082, f \u207b\u00b9' s \u2208 l\u2081 \u2293 principal {x | p x}\nh\u2081 : \u2200 s \u2208 l\u2082, g \u207b\u00b9' s \u2208 l\u2081 \u2293 principal {x | \u00acp x}\n\u22a2 \u2200 s \u2208 l\u2082, (fun x => if p x then f x else g x) \u207b\u00b9' s \u2208 l\u2081"}, {"line": "simp only [mem_inf_principal] at *", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nf g : \u03b1 \u2192 \u03b2\np : \u03b1 \u2192 Prop\ninst\u271d : (x : \u03b1) \u2192 Decidable (p x)\nh\u2080 : \u2200 s \u2208 l\u2082, {x | x \u2208 {x | p x} \u2192 x \u2208 f \u207b\u00b9' s} \u2208 l\u2081\nh\u2081 : \u2200 s \u2208 l\u2082, {x | x \u2208 {x | \u00acp x} \u2192 x \u2208 g \u207b\u00b9' s} \u2208 l\u2081\n\u22a2 \u2200 s \u2208 l\u2082, (fun x => if p x then f x else g x) \u207b\u00b9' s \u2208 l\u2081"}, {"line": "intro s hs", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nf g : \u03b1 \u2192 \u03b2\np : \u03b1 \u2192 Prop\ninst\u271d : (x : \u03b1) \u2192 Decidable (p x)\nh\u2080 : \u2200 s \u2208 l\u2082, {x | x \u2208 {x | p x} \u2192 x \u2208 f \u207b\u00b9' s} \u2208 l\u2081\nh\u2081 : \u2200 s \u2208 l\u2082, {x | x \u2208 {x | \u00acp x} \u2192 x \u2208 g \u207b\u00b9' s} \u2208 l\u2081\ns : Set \u03b2\nhs : s \u2208 l\u2082\n\u22a2 (fun x => if p x then f x else g x) \u207b\u00b9' s \u2208 l\u2081"}, {"line": "filter_upwards [h\u2080 s hs, h\u2081 s hs] with x hp\u2080 hp\u2081", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nf g : \u03b1 \u2192 \u03b2\np : \u03b1 \u2192 Prop\ninst\u271d : (x : \u03b1) \u2192 Decidable (p x)\nh\u2080 : \u2200 s \u2208 l\u2082, {x | x \u2208 {x | p x} \u2192 x \u2208 f \u207b\u00b9' s} \u2208 l\u2081\nh\u2081 : \u2200 s \u2208 l\u2082, {x | x \u2208 {x | \u00acp x} \u2192 x \u2208 g \u207b\u00b9' s} \u2208 l\u2081\ns : Set \u03b2\nhs : s \u2208 l\u2082\nx : \u03b1\nhp\u2080 : p x \u2192 x \u2208 f \u207b\u00b9' s\nhp\u2081 : \u00acp x \u2192 x \u2208 g \u207b\u00b9' s\n\u22a2 x \u2208 (fun x => if p x then f x else g x) \u207b\u00b9' s"}, {"line": "rw [mem_preimage]", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nf g : \u03b1 \u2192 \u03b2\np : \u03b1 \u2192 Prop\ninst\u271d : (x : \u03b1) \u2192 Decidable (p x)\nh\u2080 : \u2200 s \u2208 l\u2082, {x | x \u2208 {x | p x} \u2192 x \u2208 f \u207b\u00b9' s} \u2208 l\u2081\nh\u2081 : \u2200 s \u2208 l\u2082, {x | x \u2208 {x | \u00acp x} \u2192 x \u2208 g \u207b\u00b9' s} \u2208 l\u2081\ns : Set \u03b2\nhs : s \u2208 l\u2082\nx : \u03b1\nhp\u2080 : p x \u2192 x \u2208 f \u207b\u00b9' s\nhp\u2081 : \u00acp x \u2192 x \u2208 g \u207b\u00b9' s\n\u22a2 (if p x then f x else g x) \u2208 s"}, {"line": "split_ifs with h", "tactic_state": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nf g : \u03b1 \u2192 \u03b2\np : \u03b1 \u2192 Prop\ninst\u271d : (x : \u03b1) \u2192 Decidable (p x)\nh\u2080 : \u2200 s \u2208 l\u2082, {x | x \u2208 {x | p x} \u2192 x \u2208 f \u207b\u00b9' s} \u2208 l\u2081\nh\u2081 : \u2200 s \u2208 l\u2082, {x | x \u2208 {x | \u00acp x} \u2192 x \u2208 g \u207b\u00b9' s} \u2208 l\u2081\ns : Set \u03b2\nhs : s \u2208 l\u2082\nx : \u03b1\nhp\u2080 : p x \u2192 x \u2208 f \u207b\u00b9' s\nhp\u2081 : \u00acp x \u2192 x \u2208 g \u207b\u00b9' s\nh : p x\n\u22a2 f x \u2208 s\n---\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\nf g : \u03b1 \u2192 \u03b2\np : \u03b1 \u2192 Prop\ninst\u271d : (x : \u03b1) \u2192 Decidable (p x)\nh\u2080 : \u2200 s \u2208 l\u2082, {x | x \u2208 {x | p x} \u2192 x \u2208 f \u207b\u00b9' s} \u2208 l\u2081\nh\u2081 : \u2200 s \u2208 l\u2082, {x | x \u2208 {x | \u00acp x} \u2192 x \u2208 g \u207b\u00b9' s} \u2208 l\u2081\ns : Set \u03b2\nhs : s \u2208 l\u2082\nx : \u03b1\nhp\u2080 : p x \u2192 x \u2208 f \u207b\u00b9' s\nhp\u2081 : \u00acp x \u2192 x \u2208 g \u207b\u00b9' s\nh : \u00acp x\n\u22a2 g x \u2208 s"}, {"line": "exacts [hp\u2080 h, hp\u2081 h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Tendsto.atTop_mul_const_of_neg' (hr : r < 0) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x * r) l atBot := by\n  simpa only [tendsto_neg_atTop_iff,mul_neg] using hf.atTop_mul_const' (neg_pos.mpr hr)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Archimedean.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 R : Type*}", "{l : Filter \u03b1} {f : \u03b1 \u2192 R} {r : R}", "[Semiring R] [LinearOrder R] [IsStrictOrderedRing R] [Archimedean R]", "[Ring R] [LinearOrder R] [IsStrictOrderedRing R] [Archimedean R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : Type u_2\nl : Filter \u03b1\nf : \u03b1 \u2192 R\nr : R\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : LinearOrder R\ninst\u271d\u2075 : IsStrictOrderedRing R\ninst\u271d\u2074 : Archimedean R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\ninst\u271d : Archimedean R\nhr : r < 0\nhf : Tendsto f l atTop\n\u22a2 Tendsto (fun x => f x * r) l atBot"}, {"line": "simpa only [tendsto_neg_atTop_iff,mul_neg] using hf.atTop_mul_const' (neg_pos.mpr hr)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Tendsto.atBot_mul_const_of_neg' (hr : r < 0) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => f x * r) l atTop := by\n  simpa only [mul_neg,tendsto_neg_atBot_iff] using hf.atBot_mul_const' (neg_pos.2 hr)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Archimedean.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 R : Type*}", "{l : Filter \u03b1} {f : \u03b1 \u2192 R} {r : R}", "[Semiring R] [LinearOrder R] [IsStrictOrderedRing R] [Archimedean R]", "[Ring R] [LinearOrder R] [IsStrictOrderedRing R] [Archimedean R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : Type u_2\nl : Filter \u03b1\nf : \u03b1 \u2192 R\nr : R\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : LinearOrder R\ninst\u271d\u2075 : IsStrictOrderedRing R\ninst\u271d\u2074 : Archimedean R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\ninst\u271d : Archimedean R\nhr : r < 0\nhf : Tendsto f l atBot\n\u22a2 Tendsto (fun x => f x * r) l atTop"}, {"line": "simpa only [mul_neg,tendsto_neg_atBot_iff] using hf.atBot_mul_const' (neg_pos.2 hr)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Tendsto.atTop_nsmul_neg_const {f : \u03b1 \u2192 \u2115} (hr : r < 0) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x \u2022 r) l atBot := by simpa using hf.atTop_nsmul_const (neg_pos.2 hr)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Archimedean.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 R : Type*}", "{l : Filter \u03b1} {f : \u03b1 \u2192 R} {r : R}", "[Semiring R] [LinearOrder R] [IsStrictOrderedRing R] [Archimedean R]", "[Ring R] [LinearOrder R] [IsStrictOrderedRing R] [Archimedean R]", "[AddCommMonoid R] [LinearOrder R] [IsOrderedCancelAddMonoid R] [Archimedean R]", "[AddCommGroup R] [LinearOrder R] [IsOrderedAddMonoid R] [Archimedean R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : Type u_2\nl : Filter \u03b1\nr : R\ninst\u271d\u00b9\u2075 : Semiring R\ninst\u271d\u00b9\u2074 : LinearOrder R\ninst\u271d\u00b9\u00b3 : IsStrictOrderedRing R\ninst\u271d\u00b9\u00b2 : Archimedean R\ninst\u271d\u00b9\u00b9 : Ring R\ninst\u271d\u00b9\u2070 : LinearOrder R\ninst\u271d\u2079 : IsStrictOrderedRing R\ninst\u271d\u2078 : Archimedean R\ninst\u271d\u2077 : AddCommMonoid R\ninst\u271d\u2076 : LinearOrder R\ninst\u271d\u2075 : IsOrderedCancelAddMonoid R\ninst\u271d\u2074 : Archimedean R\ninst\u271d\u00b3 : AddCommGroup R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsOrderedAddMonoid R\ninst\u271d : Archimedean R\nf : \u03b1 \u2192 \u2115\nhr : r < 0\nhf : Tendsto f l atTop\n\u22a2 Tendsto (fun x => f x \u2022 r) l atBot"}, {"line": "simpa using hf.atTop_nsmul_const (neg_pos.2 hr)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Tendsto.atTop_zsmul_neg_const {f : \u03b1 \u2192 \u2124} (hr : r < 0) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x \u2022 r) l atBot := by simpa using hf.atTop_zsmul_const (neg_pos.2 hr)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Archimedean.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 R : Type*}", "{l : Filter \u03b1} {f : \u03b1 \u2192 R} {r : R}", "[Semiring R] [LinearOrder R] [IsStrictOrderedRing R] [Archimedean R]", "[Ring R] [LinearOrder R] [IsStrictOrderedRing R] [Archimedean R]", "[AddCommMonoid R] [LinearOrder R] [IsOrderedCancelAddMonoid R] [Archimedean R]", "[AddCommGroup R] [LinearOrder R] [IsOrderedAddMonoid R] [Archimedean R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : Type u_2\nl : Filter \u03b1\nr : R\ninst\u271d\u00b9\u2075 : Semiring R\ninst\u271d\u00b9\u2074 : LinearOrder R\ninst\u271d\u00b9\u00b3 : IsStrictOrderedRing R\ninst\u271d\u00b9\u00b2 : Archimedean R\ninst\u271d\u00b9\u00b9 : Ring R\ninst\u271d\u00b9\u2070 : LinearOrder R\ninst\u271d\u2079 : IsStrictOrderedRing R\ninst\u271d\u2078 : Archimedean R\ninst\u271d\u2077 : AddCommMonoid R\ninst\u271d\u2076 : LinearOrder R\ninst\u271d\u2075 : IsOrderedCancelAddMonoid R\ninst\u271d\u2074 : Archimedean R\ninst\u271d\u00b3 : AddCommGroup R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsOrderedAddMonoid R\ninst\u271d : Archimedean R\nf : \u03b1 \u2192 \u2124\nhr : r < 0\nhf : Tendsto f l atTop\n\u22a2 Tendsto (fun x => f x \u2022 r) l atBot"}, {"line": "simpa using hf.atTop_zsmul_const (neg_pos.2 hr)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Tendsto.atBot_zsmul_neg_const {f : \u03b1 \u2192 \u2124} (hr : r < 0) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => f x \u2022 r) l atTop := by simpa using hf.atBot_zsmul_const (neg_pos.2 hr)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Archimedean.lean", "context": {"open": ["Filter Set Function"], "variables": ["{\u03b1 R : Type*}", "{l : Filter \u03b1} {f : \u03b1 \u2192 R} {r : R}", "[Semiring R] [LinearOrder R] [IsStrictOrderedRing R] [Archimedean R]", "[Ring R] [LinearOrder R] [IsStrictOrderedRing R] [Archimedean R]", "[AddCommMonoid R] [LinearOrder R] [IsOrderedCancelAddMonoid R] [Archimedean R]", "[AddCommGroup R] [LinearOrder R] [IsOrderedAddMonoid R] [Archimedean R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : Type u_2\nl : Filter \u03b1\nr : R\ninst\u271d\u00b9\u2075 : Semiring R\ninst\u271d\u00b9\u2074 : LinearOrder R\ninst\u271d\u00b9\u00b3 : IsStrictOrderedRing R\ninst\u271d\u00b9\u00b2 : Archimedean R\ninst\u271d\u00b9\u00b9 : Ring R\ninst\u271d\u00b9\u2070 : LinearOrder R\ninst\u271d\u2079 : IsStrictOrderedRing R\ninst\u271d\u2078 : Archimedean R\ninst\u271d\u2077 : AddCommMonoid R\ninst\u271d\u2076 : LinearOrder R\ninst\u271d\u2075 : IsOrderedCancelAddMonoid R\ninst\u271d\u2074 : Archimedean R\ninst\u271d\u00b3 : AddCommGroup R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsOrderedAddMonoid R\ninst\u271d : Archimedean R\nf : \u03b1 \u2192 \u2124\nhr : r < 0\nhf : Tendsto f l atBot\n\u22a2 Tendsto (fun x => f x \u2022 r) l atTop"}, {"line": "simpa using hf.atBot_zsmul_const (neg_pos.2 hr)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.map_atTop_finset_prod_le_of_prod_eq {f : \u03b1 \u2192 M} {g : \u03b2 \u2192 M}\n    (h_eq : \u2200 u : Finset \u03b2,\n      \u2203 v : Finset \u03b1, \u2200 v', v \u2286 v' \u2192 \u2203 u', u \u2286 u' \u2227 \u220f x \u2208 u', g x = \u220f b \u2208 v', f b) :\n    (atTop.map fun s : Finset \u03b1 => \u220f b \u2208 s, f b) \u2264\n      atTop.map fun s : Finset \u03b2 => \u220f x \u2208 s, g x := by\n  classical\n    refine ((atTop_basis.map _).le_basis_iff (atTop_basis.map _)).2 fun b _ => ?_\n    let \u27e8v, hv\u27e9 := h_eq b\n    refine \u27e8v, trivial, ?_\u27e9\n    simpa [Finset.image_subset_iff] using hv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/BigOperators.lean", "context": {"open": ["Filter Finset"], "variables": ["{\u03b1 \u03b2 M : Type*} [CommMonoid M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nM : Type u_3\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ng : \u03b2 \u2192 M\nh_eq : \u2200 (u : Finset \u03b2), \u2203 v, \u2200 (v' : Finset \u03b1), v \u2286 v' \u2192 \u2203 u', u \u2286 u' \u2227 \u220f x \u2208 u', g x = \u220f b \u2208 v', f b\n\u22a2 map (fun s => \u220f b \u2208 s, f b) atTop \u2264 map (fun s => \u220f x \u2208 s, g x) atTop"}, {"line": "classical\n    refine ((atTop_basis.map _).le_basis_iff (atTop_basis.map _)).2 fun b _ => ?_\n    let \u27e8v, hv\u27e9 := h_eq b\n    refine \u27e8v, trivial, ?_\u27e9\n    simpa [Finset.image_subset_iff] using hv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frequently_high_scores [LinearOrder \u03b2] [NoMaxOrder \u03b2] {u : \u2115 \u2192 \u03b2}\n    (hu : Tendsto u atTop atTop) : \u2203\u1da0 n in atTop, \u2200 k < n, u k < u n := by\n  simpa [frequently_atTop] using high_scores hu\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Finite.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b9' \u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_4\nx\u271d : Sort u_6\nTendsto : x\u271d\natTop : Filter \u2115\ninst\u271d\u00b9 : LinearOrder \u03b2\ninst\u271d : NoMaxOrder \u03b2\nu : \u2115 \u2192 \u03b2\nhu : sorry\n\u22a2 \u2203\u1da0 (n : \u2115) in atTop, \u2200 k < n, u k < u n"}, {"line": "simpa [frequently_atTop] using high_scores hu", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasAntitoneBasis.subbasis_with_rel {f : Filter \u03b1} {s : \u2115 \u2192 Set \u03b1}\n    (hs : f.HasAntitoneBasis s) {r : \u2115 \u2192 \u2115 \u2192 Prop} (hr : \u2200 m, \u2200\u1da0 n in atTop, r m n) :\n    \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 (\u2200 \u2983m n\u2984, m < n \u2192 r (\u03c6 m) (\u03c6 n)) \u2227 f.HasAntitoneBasis (s \u2218 \u03c6) := by\n  rsuffices \u27e8\u03c6, h\u03c6, hr\u03c6\u27e9 : \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 \u2200 m n, m < n \u2192 r (\u03c6 m) (\u03c6 n)\n  \u00b7 exact \u27e8\u03c6, h\u03c6, hr\u03c6, hs.comp_strictMono h\u03c6\u27e9\n  have : \u2200 t : Set \u2115, t.Finite \u2192 \u2200\u1da0 n in atTop, \u2200 m \u2208 t, m < n \u2227 r m n := fun t ht =>\n    (eventually_all_finite ht).2 fun m _ => (eventually_gt_atTop m).and (hr _)\n  rcases seq_of_forall_finite_exists fun t ht => (this t ht).exists with \u27e8\u03c6, h\u03c6\u27e9\n  simp only [forall_mem_image] at h\u03c6\n  simp only [forall_and] at h\u03c6\n  simp only [mem_Iio] at h\u03c6\n  exact \u27e8\u03c6, forall_swap.2 h\u03c6.1, forall_swap.2 h\u03c6.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Finite.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b9' \u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\natTop : Filter \u2115\nf : Filter \u03b1\ns : \u2115 \u2192 Set \u03b1\nhs : f.HasAntitoneBasis s\nr : \u2115 \u2192 \u2115 \u2192 Prop\nhr : \u2200 (m : \u2115), \u2200\u1da0 (n : \u2115) in atTop, r m n\n\u22a2 \u2203 \u03c6, StrictMono \u03c6 \u2227 (\u2200 \u2983m n : \u2115\u2984, m < n \u2192 r (\u03c6 m) (\u03c6 n)) \u2227 f.HasAntitoneBasis (s \u2218 \u03c6)"}, {"line": "rsuffices \u27e8\u03c6, h\u03c6, hr\u03c6\u27e9 : \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 \u2200 m n, m < n \u2192 r (\u03c6 m) (\u03c6 n)", "tactic_state": "case intro.intro\n\u03b1 : Type u_3\natTop : Filter \u2115\nf : Filter \u03b1\ns : \u2115 \u2192 Set \u03b1\nhs : f.HasAntitoneBasis s\nr : \u2115 \u2192 \u2115 \u2192 Prop\nhr : \u2200 (m : \u2115), \u2200\u1da0 (n : \u2115) in atTop, r m n\n\u03c6 : \u2115 \u2192 \u2115\nh\u03c6 : StrictMono \u03c6\nhr\u03c6 : \u2200 (m n : \u2115), m < n \u2192 r (\u03c6 m) (\u03c6 n)\n\u22a2 \u2203 \u03c6, StrictMono \u03c6 \u2227 (\u2200 \u2983m n : \u2115\u2984, m < n \u2192 r (\u03c6 m) (\u03c6 n)) \u2227 f.HasAntitoneBasis (s \u2218 \u03c6)\n---\n\u03b1 : Type u_3\natTop : Filter \u2115\nf : Filter \u03b1\ns : \u2115 \u2192 Set \u03b1\nhs : f.HasAntitoneBasis s\nr : \u2115 \u2192 \u2115 \u2192 Prop\nhr : \u2200 (m : \u2115), \u2200\u1da0 (n : \u2115) in atTop, r m n\n\u22a2 \u2203 \u03c6, StrictMono \u03c6 \u2227 \u2200 (m n : \u2115), m < n \u2192 r (\u03c6 m) (\u03c6 n)"}, {"line": "\u00b7 exact \u27e8\u03c6, h\u03c6, hr\u03c6, hs.comp_strictMono h\u03c6\u27e9", "tactic_state": "\u03b1 : Type u_3\natTop : Filter \u2115\nf : Filter \u03b1\ns : \u2115 \u2192 Set \u03b1\nhs : f.HasAntitoneBasis s\nr : \u2115 \u2192 \u2115 \u2192 Prop\nhr : \u2200 (m : \u2115), \u2200\u1da0 (n : \u2115) in atTop, r m n\n\u22a2 \u2203 \u03c6, StrictMono \u03c6 \u2227 \u2200 (m n : \u2115), m < n \u2192 r (\u03c6 m) (\u03c6 n)"}, {"line": "have : \u2200 t : Set \u2115, t.Finite \u2192 \u2200\u1da0 n in atTop, \u2200 m \u2208 t, m < n \u2227 r m n := fun t ht =>\n    (eventually_all_finite ht).2 fun m _ => (eventually_gt_atTop m).and (hr _)", "tactic_state": "\u03b1 : Type u_3\natTop : Filter \u2115\nf : Filter \u03b1\ns : \u2115 \u2192 Set \u03b1\nhs : f.HasAntitoneBasis s\nr : \u2115 \u2192 \u2115 \u2192 Prop\nhr : \u2200 (m : \u2115), \u2200\u1da0 (n : \u2115) in atTop, r m n\nthis : \u2200 (t : Set \u2115), t.Finite \u2192 \u2200\u1da0 (n : \u2115) in atTop, \u2200 m \u2208 t, m < n \u2227 r m n\n\u22a2 \u2203 \u03c6, StrictMono \u03c6 \u2227 \u2200 (m n : \u2115), m < n \u2192 r (\u03c6 m) (\u03c6 n)"}, {"line": "rcases seq_of_forall_finite_exists fun t ht => (this t ht).exists with \u27e8\u03c6, h\u03c6\u27e9", "tactic_state": "case intro\n\u03b1 : Type u_3\natTop : Filter \u2115\nf : Filter \u03b1\ns : \u2115 \u2192 Set \u03b1\nhs : f.HasAntitoneBasis s\nr : \u2115 \u2192 \u2115 \u2192 Prop\nhr : \u2200 (m : \u2115), \u2200\u1da0 (n : \u2115) in atTop, r m n\nthis : \u2200 (t : Set \u2115), t.Finite \u2192 \u2200\u1da0 (n : \u2115) in atTop, \u2200 m \u2208 t, m < n \u2227 r m n\n\u03c6 : \u2115 \u2192 \u2115\nh\u03c6 : \u2200 (n m : \u2115), m \u2208 \u03c6 '' Iio n \u2192 m < \u03c6 n \u2227 r m (\u03c6 n)\n\u22a2 \u2203 \u03c6, StrictMono \u03c6 \u2227 \u2200 (m n : \u2115), m < n \u2192 r (\u03c6 m) (\u03c6 n)"}, {"line": "simp only [forall_mem_image] at h\u03c6", "tactic_state": "case intro\n\u03b1 : Type u_3\natTop : Filter \u2115\nf : Filter \u03b1\ns : \u2115 \u2192 Set \u03b1\nhs : f.HasAntitoneBasis s\nr : \u2115 \u2192 \u2115 \u2192 Prop\nhr : \u2200 (m : \u2115), \u2200\u1da0 (n : \u2115) in atTop, r m n\nthis : \u2200 (t : Set \u2115), t.Finite \u2192 \u2200\u1da0 (n : \u2115) in atTop, \u2200 m \u2208 t, m < n \u2227 r m n\n\u03c6 : \u2115 \u2192 \u2115\nh\u03c6 : \u2200 (n : \u2115) \u2983x : \u2115\u2984, x \u2208 Iio n \u2192 \u03c6 x < \u03c6 n \u2227 r (\u03c6 x) (\u03c6 n)\n\u22a2 \u2203 \u03c6, StrictMono \u03c6 \u2227 \u2200 (m n : \u2115), m < n \u2192 r (\u03c6 m) (\u03c6 n)"}, {"line": "simp only [forall_and] at h\u03c6", "tactic_state": "case intro\n\u03b1 : Type u_3\natTop : Filter \u2115\nf : Filter \u03b1\ns : \u2115 \u2192 Set \u03b1\nhs : f.HasAntitoneBasis s\nr : \u2115 \u2192 \u2115 \u2192 Prop\nhr : \u2200 (m : \u2115), \u2200\u1da0 (n : \u2115) in atTop, r m n\nthis : \u2200 (t : Set \u2115), t.Finite \u2192 \u2200\u1da0 (n : \u2115) in atTop, \u2200 m \u2208 t, m < n \u2227 r m n\n\u03c6 : \u2115 \u2192 \u2115\nh\u03c6 : (\u2200 (x x_1 : \u2115), x_1 \u2208 Iio x \u2192 \u03c6 x_1 < \u03c6 x) \u2227 \u2200 (x x_1 : \u2115), x_1 \u2208 Iio x \u2192 r (\u03c6 x_1) (\u03c6 x)\n\u22a2 \u2203 \u03c6, StrictMono \u03c6 \u2227 \u2200 (m n : \u2115), m < n \u2192 r (\u03c6 m) (\u03c6 n)"}, {"line": "simp only [mem_Iio] at h\u03c6", "tactic_state": "case intro\n\u03b1 : Type u_3\natTop : Filter \u2115\nf : Filter \u03b1\ns : \u2115 \u2192 Set \u03b1\nhs : f.HasAntitoneBasis s\nr : \u2115 \u2192 \u2115 \u2192 Prop\nhr : \u2200 (m : \u2115), \u2200\u1da0 (n : \u2115) in atTop, r m n\nthis : \u2200 (t : Set \u2115), t.Finite \u2192 \u2200\u1da0 (n : \u2115) in atTop, \u2200 m \u2208 t, m < n \u2227 r m n\n\u03c6 : \u2115 \u2192 \u2115\nh\u03c6 : (\u2200 (x x_1 : \u2115), x_1 < x \u2192 \u03c6 x_1 < \u03c6 x) \u2227 \u2200 (x x_1 : \u2115), x_1 < x \u2192 r (\u03c6 x_1) (\u03c6 x)\n\u22a2 \u2203 \u03c6, StrictMono \u03c6 \u2227 \u2200 (m n : \u2115), m < n \u2192 r (\u03c6 m) (\u03c6 n)"}, {"line": "exact \u27e8\u03c6, forall_swap.2 h\u03c6.1, forall_swap.2 h\u03c6.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frequently_mod_eq {d n : \u2115} (h : d < n) : \u2203\u1da0 m in atTop, m % n = d := by\n  simpa only [Nat.ModEq,mod_eq_of_lt h] using frequently_modEq h.ne_bot d\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/ModEq.lean", "context": {"open": ["Filter"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "d n : \u2115\nh : d < n\n\u22a2 \u2203\u1da0 (m : \u2115) in atTop, m % n = d"}, {"line": "simpa only [Nat.ModEq,mod_eq_of_lt h] using frequently_modEq h.ne_bot d", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frequently_even : \u2203\u1da0 m : \u2115 in atTop, Even m := by\n  simpa only [even_iff] using frequently_mod_eq zero_lt_two\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/ModEq.lean", "context": {"open": ["Filter"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203\u1da0 (m : \u2115) in atTop, Even m"}, {"line": "simpa only [even_iff] using frequently_mod_eq zero_lt_two", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frequently_odd : \u2203\u1da0 m : \u2115 in atTop, Odd m := by\n  simpa only [odd_iff] using frequently_mod_eq one_lt_two\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/ModEq.lean", "context": {"open": ["Filter"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203\u1da0 (m : \u2115) in atTop, Odd m"}, {"line": "simpa only [odd_iff] using frequently_mod_eq one_lt_two", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Tendsto.atBot_mul_atTop\u2080 (hf : Tendsto f l atBot) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x * g x) l atBot := by\n  have : Tendsto (fun x => -f x * g x) l atTop :=\n    (tendsto_neg_atBot_atTop.comp hf).atTop_mul_atTop\u2080 hg\n  simpa only [Function.comp_def,neg_mul_eq_neg_mul,neg_neg] using\n    tendsto_neg_atTop_atBot.comp this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Ring.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Semiring \u03b1] [PartialOrder \u03b1] [IsOrderedRing \u03b1] {l : Filter \u03b2} {f g : \u03b2 \u2192 \u03b1}", "[Ring \u03b1] [PartialOrder \u03b1] [IsOrderedRing \u03b1] {l : Filter \u03b2} {f g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nTendsto : x\u271d\nhf : sorry\nhg : sorry\n\u22a2 sorry"}, {"line": "have : Tendsto (fun x => -f x * g x) l atTop :=\n    (tendsto_neg_atBot_atTop.comp hf).atTop_mul_atTop\u2080 hg", "tactic_state": "x\u271d : Sort u_3\nTendsto : x\u271d\nhf : sorry\nhg : sorry\nthis : sorry\n\u22a2 sorry"}, {"line": "simpa only [Function.comp_def,neg_mul_eq_neg_mul,neg_neg] using\n    tendsto_neg_atTop_atBot.comp this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Tendsto.atBot_mul_atBot\u2080 (hf : Tendsto f l atBot) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x * g x) l atTop := by\n  have : Tendsto (fun x => -f x * -g x) l atTop :=\n    (tendsto_neg_atBot_atTop.comp hf).atTop_mul_atTop\u2080 (tendsto_neg_atBot_atTop.comp hg)\n  simpa only [neg_mul_neg] using this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Ring.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Semiring \u03b1] [PartialOrder \u03b1] [IsOrderedRing \u03b1] {l : Filter \u03b2} {f g : \u03b2 \u2192 \u03b1}", "[Ring \u03b1] [PartialOrder \u03b1] [IsOrderedRing \u03b1] {l : Filter \u03b2} {f g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nTendsto : x\u271d\nhf : sorry\nhg : sorry\n\u22a2 sorry"}, {"line": "have : Tendsto (fun x => -f x * -g x) l atTop :=\n    (tendsto_neg_atBot_atTop.comp hf).atTop_mul_atTop\u2080 (tendsto_neg_atBot_atTop.comp hg)", "tactic_state": "x\u271d : Sort u_3\nTendsto : x\u271d\nhf : sorry\nhg : sorry\nthis : sorry\n\u22a2 sorry"}, {"line": "simpa only [neg_mul_neg] using this", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_le_of_tendsto_atTop (h : Tendsto u atTop atTop) (a : \u03b1) (b : \u03b2) :\n    \u2203 a' \u2265 a, b \u2264 u a' := by\n  have : Nonempty \u03b1 := \u27e8a\u27e9\n  have : \u2200\u1da0 x in atTop, a \u2264 x \u2227 b \u2264 u x :=\n    (eventually_ge_atTop a).and (h.eventually <| eventually_ge_atTop b)\n  exact this.exists\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b9' \u03b1 \u03b2 \u03b3 : Type*}", "[Preorder \u03b1] [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] {p : \u03b1 \u2192 Prop}", "[Nonempty \u03b1]", "[Preorder \u03b1] [IsDirected \u03b1 (\u00b7 \u2265 \u00b7)] {p : \u03b1 \u2192 Prop}", "[Nonempty \u03b1]", "[Preorder \u03b1] [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] {F : Filter \u03b2} {u : \u03b1 \u2192 \u03b2}", "[Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : IsDirected \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d\u2076 : Nonempty \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : IsDirected \u03b1 fun x1 x2 => x1 \u2265 x2\ninst\u271d\u00b3 : Nonempty \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : IsDirected \u03b1 fun x1 x2 => x1 \u2264 x2\nu : \u03b1 \u2192 \u03b2\ninst\u271d : Preorder \u03b2\nx\u271d : Sort u_6\nTendsto : x\u271d\nh : sorry\na : \u03b1\nb : \u03b2\n\u22a2 \u2203 a' \u2265 a, b \u2264 u a'"}, {"line": "have : Nonempty \u03b1 := \u27e8a\u27e9", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : IsDirected \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d\u2076 : Nonempty \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : IsDirected \u03b1 fun x1 x2 => x1 \u2265 x2\ninst\u271d\u00b3 : Nonempty \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : IsDirected \u03b1 fun x1 x2 => x1 \u2264 x2\nu : \u03b1 \u2192 \u03b2\ninst\u271d : Preorder \u03b2\nx\u271d : Sort u_6\nTendsto : x\u271d\nh : sorry\na : \u03b1\nb : \u03b2\nthis : Nonempty \u03b1\n\u22a2 \u2203 a' \u2265 a, b \u2264 u a'"}, {"line": "have : \u2200\u1da0 x in atTop, a \u2264 x \u2227 b \u2264 u x :=\n    (eventually_ge_atTop a).and (h.eventually <| eventually_ge_atTop b)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : IsDirected \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d\u2076 : Nonempty \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : IsDirected \u03b1 fun x1 x2 => x1 \u2265 x2\ninst\u271d\u00b3 : Nonempty \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : IsDirected \u03b1 fun x1 x2 => x1 \u2264 x2\nu : \u03b1 \u2192 \u03b2\ninst\u271d : Preorder \u03b2\nx\u271d : Sort u_6\nTendsto : x\u271d\nh : sorry\na : \u03b1\nb : \u03b2\nthis\u271d : Nonempty \u03b1\nthis : \u2200\u1da0 (x : \u03b1) in sorry, sorry \u2227 sorry\n\u22a2 \u2203 a' \u2265 a, b \u2264 u a'"}, {"line": "exact this.exists", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_iff_seq_eventually {\u03b9 : Type*} {l : Filter \u03b9} {p : \u03b9 \u2192 Prop}\n    [l.IsCountablyGenerated] :\n    (\u2200\u1da0 n in l, p n) \u2194 \u2200 x : \u2115 \u2192 \u03b9, Tendsto x atTop l \u2192 \u2200\u1da0 n : \u2115 in atTop, p (x n) := by\n  simpa using tendsto_iff_seq_tendsto (f := id) (l := \ud835\udcdf {x | p x})\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/CountablyGenerated.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nTendsto : x\u271d\natTop : Filter \u2115\n\u03b9 : Type u_3\nl : Filter \u03b9\np : \u03b9 \u2192 Prop\ninst\u271d : l.IsCountablyGenerated\n\u22a2 (\u2200\u1da0 (n : \u03b9) in l, p n) \u2194 \u2200 (x : \u2115 \u2192 \u03b9), sorry \u2192 \u2200\u1da0 (n : \u2115) in atTop, p (x n)"}, {"line": "simpa using tendsto_iff_seq_tendsto (f := id) (l := \ud835\udcdf {x | p x})", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Frequently.forall_exists_of_atTop [Preorder \u03b1] {p : \u03b1 \u2192 Prop}\n    (h : \u2203\u1da0 x in atTop, p x) (a : \u03b1) : \u2203 b \u2265 a, p b := by\n  rw [Filter.Frequently] at h\n  contrapose! h\n  exact (eventually_ge_atTop a).mono h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Defs.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03b9' \u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\natTop : Filter \u03b1\ninst\u271d : Preorder \u03b1\np : \u03b1 \u2192 Prop\nh : \u2203\u1da0 (x : \u03b1) in atTop, p x\na : \u03b1\n\u22a2 \u2203 b \u2265 a, p b"}, {"line": "rw [Filter.Frequently] at h", "tactic_state": "\u03b1 : Type u_3\natTop : Filter \u03b1\ninst\u271d : Preorder \u03b1\np : \u03b1 \u2192 Prop\nh : \u00ac\u2200\u1da0 (x : \u03b1) in atTop, \u00acp x\na : \u03b1\n\u22a2 \u2203 b \u2265 a, p b"}, {"line": "contrapose! h", "tactic_state": "\u03b1 : Type u_3\natTop : Filter \u03b1\ninst\u271d : Preorder \u03b1\np : \u03b1 \u2192 Prop\na : \u03b1\nh : \u2200 b \u2265 a, \u00acp b\n\u22a2 \u2200\u1da0 (x : \u03b1) in atTop, \u00acp x"}, {"line": "exact (eventually_ge_atTop a).mono h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Monotone.piecewise_eventually_eq_iUnion {\u03b2 : \u03b1 \u2192 Type*} [Preorder \u03b9] {s : \u03b9 \u2192 Set \u03b1}\n    [\u2200 i, DecidablePred (\u00b7 \u2208 s i)] [DecidablePred (\u00b7 \u2208 \u22c3 i, s i)]\n    (hs : Monotone s) (f g : (a : \u03b1) \u2192 \u03b2 a) (a : \u03b1) :\n    \u2200\u1da0 i in atTop, (s i).piecewise f g a = (\u22c3 i, s i).piecewise f g a := by\n  rcases em (\u2203 i, a \u2208 s i) with \u27e8i, hi\u27e9 | ha\n  \u00b7 refine (eventually_ge_atTop i).mono fun j hij \u21a6 ?_\n    simp only [Set.piecewise_eq_of_mem]\n    simp only [hs hij hi]\n    simp only [subset_iUnion _ _ hi]\n  \u00b7 filter_upwards with i\n    simp only [Set.piecewise_eq_of_not_mem]\n    simp only [not_exists.1 ha i]\n    simp only [mt mem_iUnion.1 ha]\n    simp only [not_false_eq_true]\n    simp only [exists_false]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Defs.lean", "context": {"open": ["Set", "Filter"], "variables": ["{\u03b9 \u03b9' \u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\n\u03b2 : \u03b1 \u2192 Type u_6\ninst\u271d\u00b2 : Preorder \u03b9\ns : \u03b9 \u2192 Set \u03b1\ninst\u271d\u00b9 : (i : \u03b9) \u2192 DecidablePred fun x => x \u2208 s i\ninst\u271d : DecidablePred fun x => x \u2208 \u22c3 i, s i\nhs : Monotone s\nf g : (a : \u03b1) \u2192 \u03b2 a\na : \u03b1\n\u22a2 \u2200\u1da0 (i : \u03b9) in atTop, (s i).piecewise f g a = (\u22c3 i, s i).piecewise f g a"}, {"line": "rcases em (\u2203 i, a \u2208 s i) with \u27e8i, hi\u27e9 | ha", "tactic_state": "case inl.intro\n\u03b9 : Type u_1\n\u03b1 : Type u_3\n\u03b2 : \u03b1 \u2192 Type u_6\ninst\u271d\u00b2 : Preorder \u03b9\ns : \u03b9 \u2192 Set \u03b1\ninst\u271d\u00b9 : (i : \u03b9) \u2192 DecidablePred fun x => x \u2208 s i\ninst\u271d : DecidablePred fun x => x \u2208 \u22c3 i, s i\nhs : Monotone s\nf g : (a : \u03b1) \u2192 \u03b2 a\na : \u03b1\ni : \u03b9\nhi : a \u2208 s i\n\u22a2 \u2200\u1da0 (i : \u03b9) in atTop, (s i).piecewise f g a = (\u22c3 i, s i).piecewise f g a\n---\ncase inr\n\u03b9 : Type u_1\n\u03b1 : Type u_3\n\u03b2 : \u03b1 \u2192 Type u_6\ninst\u271d\u00b2 : Preorder \u03b9\ns : \u03b9 \u2192 Set \u03b1\ninst\u271d\u00b9 : (i : \u03b9) \u2192 DecidablePred fun x => x \u2208 s i\ninst\u271d : DecidablePred fun x => x \u2208 \u22c3 i, s i\nhs : Monotone s\nf g : (a : \u03b1) \u2192 \u03b2 a\na : \u03b1\nha : \u00ac\u2203 i, a \u2208 s i\n\u22a2 \u2200\u1da0 (i : \u03b9) in atTop, (s i).piecewise f g a = (\u22c3 i, s i).piecewise f g a"}, {"line": "\u00b7 refine (eventually_ge_atTop i).mono fun j hij \u21a6 ?_\n    simp only [Set.piecewise_eq_of_mem]\n    simp only [hs hij hi]\n    simp only [subset_iUnion _ _ hi]", "tactic_state": "case inr\n\u03b9 : Type u_1\n\u03b1 : Type u_3\n\u03b2 : \u03b1 \u2192 Type u_6\ninst\u271d\u00b2 : Preorder \u03b9\ns : \u03b9 \u2192 Set \u03b1\ninst\u271d\u00b9 : (i : \u03b9) \u2192 DecidablePred fun x => x \u2208 s i\ninst\u271d : DecidablePred fun x => x \u2208 \u22c3 i, s i\nhs : Monotone s\nf g : (a : \u03b1) \u2192 \u03b2 a\na : \u03b1\nha : \u00ac\u2203 i, a \u2208 s i\n\u22a2 \u2200\u1da0 (i : \u03b9) in atTop, (s i).piecewise f g a = (\u22c3 i, s i).piecewise f g a"}, {"line": "\u00b7 filter_upwards with i\n    simp only [Set.piecewise_eq_of_not_mem]\n    simp only [not_exists.1 ha i]\n    simp only [mt mem_iUnion.1 ha]\n    simp only [not_false_eq_true]\n    simp only [exists_false]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_mul_const_atTop_of_pos (hr : 0 < r) :\n    Tendsto (fun x => f x * r) l atTop \u2194 Tendsto f l atTop := by\n  simpa only [mul_comm] using tendsto_const_mul_atTop_of_pos hr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Field.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115\nx\u271d : Sort u_3\nTendsto : x\u271d\nhr : 0 < r\n\u22a2 sorry \u2194 sorry"}, {"line": "simpa only [mul_comm] using tendsto_const_mul_atTop_of_pos hr", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tendsto_div_const_atTop_of_pos (hr : 0 < r) :\n    Tendsto (fun x \u21a6 f x / r) l atTop \u2194 Tendsto f l atTop := by\n  simpa only [div_eq_mul_inv] using tendsto_mul_const_atTop_of_pos (inv_pos.2 hr)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Field.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115\nx\u271d : Sort u_3\nTendsto : x\u271d\nhr : 0 < r\n\u22a2 sorry \u2194 sorry"}, {"line": "simpa only [div_eq_mul_inv] using tendsto_mul_const_atTop_of_pos (inv_pos.2 hr)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Tendsto.atTop_div_const (hr : 0 < r) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x / r) l atTop := by\n  simpa only [div_eq_mul_inv] using hf.atTop_mul_const (inv_pos.2 hr)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Field.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115\nx\u271d : Sort u_3\nTendsto : x\u271d\nhr : 0 < r\nhf : sorry\n\u22a2 sorry"}, {"line": "simpa only [div_eq_mul_inv] using hf.atTop_mul_const (inv_pos.2 hr)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_const_mul_atBot_of_pos (hr : 0 < r) :\n    Tendsto (fun x => r * f x) l atBot \u2194 Tendsto f l atBot := by\n  simpa only [\u2190 mul_neg,\u2190 tendsto_neg_atTop_iff] using tendsto_const_mul_atTop_of_pos hr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Field.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115\nx\u271d : Sort u_3\nTendsto : x\u271d\nhr : 0 < r\n\u22a2 sorry \u2194 sorry"}, {"line": "simpa only [\u2190 mul_neg,\u2190 tendsto_neg_atTop_iff] using tendsto_const_mul_atTop_of_pos hr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_mul_const_atBot_of_pos (hr : 0 < r) :\n    Tendsto (fun x => f x * r) l atBot \u2194 Tendsto f l atBot := by\n  simpa only [mul_comm] using tendsto_const_mul_atBot_of_pos hr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Field.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115\nx\u271d : Sort u_3\nTendsto : x\u271d\nhr : 0 < r\n\u22a2 sorry \u2194 sorry"}, {"line": "simpa only [mul_comm] using tendsto_const_mul_atBot_of_pos hr", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tendsto_div_const_atBot_of_pos (hr : 0 < r) :\n    Tendsto (fun x \u21a6 f x / r) l atBot \u2194 Tendsto f l atBot := by\n  simp [div_eq_mul_inv, tendsto_mul_const_atBot_of_pos, hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Field.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115\nx\u271d : Sort u_3\nTendsto : x\u271d\nhr : 0 < r\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [div_eq_mul_inv, tendsto_mul_const_atBot_of_pos, hr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_const_mul_atTop_of_neg (hr : r < 0) :\n    Tendsto (fun x => r * f x) l atTop \u2194 Tendsto f l atBot := by\n  simpa only [neg_mul,tendsto_neg_atBot_iff] using tendsto_const_mul_atBot_of_pos (neg_pos.2 hr)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Field.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115\nx\u271d : Sort u_3\nTendsto : x\u271d\nhr : r < 0\n\u22a2 sorry \u2194 sorry"}, {"line": "simpa only [neg_mul,tendsto_neg_atBot_iff] using tendsto_const_mul_atBot_of_pos (neg_pos.2 hr)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_mul_const_atTop_of_neg (hr : r < 0) :\n    Tendsto (fun x => f x * r) l atTop \u2194 Tendsto f l atBot := by\n  simpa only [mul_comm] using tendsto_const_mul_atTop_of_neg hr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Field.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115\nx\u271d : Sort u_3\nTendsto : x\u271d\nhr : r < 0\n\u22a2 sorry \u2194 sorry"}, {"line": "simpa only [mul_comm] using tendsto_const_mul_atTop_of_neg hr", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tendsto_div_const_atTop_of_neg (hr : r < 0) :\n    Tendsto (fun x \u21a6 f x / r) l atTop \u2194 Tendsto f l atBot := by\n  simp [div_eq_mul_inv, tendsto_mul_const_atTop_of_neg, hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Field.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115\nx\u271d : Sort u_3\nTendsto : x\u271d\nhr : r < 0\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [div_eq_mul_inv, tendsto_mul_const_atTop_of_neg, hr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_const_mul_atBot_of_neg (hr : r < 0) :\n    Tendsto (fun x => r * f x) l atBot \u2194 Tendsto f l atTop := by\n  simpa only [neg_mul,tendsto_neg_atTop_iff] using tendsto_const_mul_atTop_of_pos (neg_pos.2 hr)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Field.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115\nx\u271d : Sort u_3\nTendsto : x\u271d\nhr : r < 0\n\u22a2 sorry \u2194 sorry"}, {"line": "simpa only [neg_mul,tendsto_neg_atTop_iff] using tendsto_const_mul_atTop_of_pos (neg_pos.2 hr)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_mul_const_atBot_of_neg (hr : r < 0) :\n    Tendsto (fun x => f x * r) l atBot \u2194 Tendsto f l atTop := by\n  simpa only [mul_comm] using tendsto_const_mul_atBot_of_neg hr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Field.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115\nx\u271d : Sort u_3\nTendsto : x\u271d\nhr : r < 0\n\u22a2 sorry \u2194 sorry"}, {"line": "simpa only [mul_comm] using tendsto_const_mul_atBot_of_neg hr", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tendsto_div_const_atBot_of_neg (hr : r < 0) :\n    Tendsto (fun x \u21a6 f x / r) l atBot \u2194 Tendsto f l atTop := by\n  simp [div_eq_mul_inv, tendsto_mul_const_atBot_of_neg, hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/AtTopBot/Field.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u2115\nx\u271d : Sort u_3\nTendsto : x\u271d\nhr : r < 0\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [div_eq_mul_inv, tendsto_mul_const_atBot_of_neg, hr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem filter_eq_generate (h : IsBasis p s) : h.filter = generate { U | \u2203 i, p i \u2227 s i = U } := by\n  rw [IsBasis.filter]\n  rw [\u2190 h.filterBasis.generate]\n  rw [IsBasis.filterBasis]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : IsBasis p s\n\u22a2 h.filter = generate {U | \u2203 i, p i \u2227 s i = U}"}, {"line": "rw [IsBasis.filter]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : IsBasis p s\n\u22a2 h.filterBasis.filter = generate {U | \u2203 i, p i \u2227 s i = U}"}, {"line": "rw [\u2190 h.filterBasis.generate]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : IsBasis p s\n\u22a2 generate h.filterBasis.sets = generate {U | \u2203 i, p i \u2227 s i = U}"}, {"line": "rw [IsBasis.filterBasis]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.eq_of_same_basis (hl : l.HasBasis p s) (hl' : l'.HasBasis p s) : l = l' := by\n  ext t\n  rw [hl.mem_iff]\n  rw [hl'.mem_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nhl : l.HasBasis p s\nhl' : l'.HasBasis p s\n\u22a2 l = l'"}, {"line": "ext t", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nhl : l.HasBasis p s\nhl' : l'.HasBasis p s\nt : Set \u03b1\n\u22a2 t \u2208 l \u2194 t \u2208 l'"}, {"line": "rw [hl.mem_iff]", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nhl : l.HasBasis p s\nhl' : l'.HasBasis p s\nt : Set \u03b1\n\u22a2 (\u2203 i, p i \u2227 s i \u2286 t) \u2194 t \u2208 l'"}, {"line": "rw [hl'.mem_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.isBasis (h : l.HasBasis p s) : IsBasis p s where\n  nonempty := h.ex_mem\n  inter hi hj := by\n    simpa only [h.mem_iff] using inter_mem (h.mem_of_mem hi) (h.mem_of_mem hj)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\ni\u271d j\u271d : \u03b9\nhi : p i\u271d\nhj : p j\u271d\n\u22a2 \u2203 k, p k \u2227 s k \u2286 s i\u271d \u2229 s j\u271d"}, {"line": "simpa only [h.mem_iff] using inter_mem (h.mem_of_mem hi) (h.mem_of_mem hj)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.filter_eq (h : l.HasBasis p s) : h.isBasis.filter = l := by\n  ext U\n  simp [h.mem_iff, IsBasis.mem_filter_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\n\u22a2 \u22ef.filter = l"}, {"line": "ext U", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\nU : Set \u03b1\n\u22a2 U \u2208 \u22ef.filter \u2194 U \u2208 l"}, {"line": "simp [h.mem_iff, IsBasis.mem_filter_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.to_hasBasis' (hl : l.HasBasis p s) (h : \u2200 i, p i \u2192 \u2203 i', p' i' \u2227 s' i' \u2286 s i)\n    (h' : \u2200 i', p' i' \u2192 s' i' \u2208 l) : l.HasBasis p' s' := by\n  refine \u27e8fun t => \u27e8fun ht => ?_, fun \u27e8i', hi', ht\u27e9 => mem_of_superset (h' i' hi') ht\u27e9\u27e9\n  rcases hl.mem_iff.1 ht with \u27e8i, hi, ht\u27e9\n  rcases h i hi with \u27e8i', hi', hs's\u27e9\n  exact \u27e8i', hi', hs's.trans ht\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\nhl : l.HasBasis p s\nh : \u2200 (i : \u03b9), p i \u2192 \u2203 i', p' i' \u2227 s' i' \u2286 s i\nh' : \u2200 (i' : \u03b9'), p' i' \u2192 s' i' \u2208 l\n\u22a2 l.HasBasis p' s'"}, {"line": "refine \u27e8fun t => \u27e8fun ht => ?_, fun \u27e8i', hi', ht\u27e9 => mem_of_superset (h' i' hi') ht\u27e9\u27e9", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\nhl : l.HasBasis p s\nh : \u2200 (i : \u03b9), p i \u2192 \u2203 i', p' i' \u2227 s' i' \u2286 s i\nh' : \u2200 (i' : \u03b9'), p' i' \u2192 s' i' \u2208 l\nt : Set \u03b1\nht : t \u2208 l\n\u22a2 \u2203 i, p' i \u2227 s' i \u2286 t"}, {"line": "rcases hl.mem_iff.1 ht with \u27e8i, hi, ht\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\nhl : l.HasBasis p s\nh : \u2200 (i : \u03b9), p i \u2192 \u2203 i', p' i' \u2227 s' i' \u2286 s i\nh' : \u2200 (i' : \u03b9'), p' i' \u2192 s' i' \u2208 l\nt : Set \u03b1\nht\u271d : t \u2208 l\ni : \u03b9\nhi : p i\nht : s i \u2286 t\n\u22a2 \u2203 i, p' i \u2227 s' i \u2286 t"}, {"line": "rcases h i hi with \u27e8i', hi', hs's\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\nhl : l.HasBasis p s\nh : \u2200 (i : \u03b9), p i \u2192 \u2203 i', p' i' \u2227 s' i' \u2286 s i\nh' : \u2200 (i' : \u03b9'), p' i' \u2192 s' i' \u2208 l\nt : Set \u03b1\nht\u271d : t \u2208 l\ni : \u03b9\nhi : p i\nht : s i \u2286 t\ni' : \u03b9'\nhi' : p' i'\nhs's : s' i' \u2286 s i\n\u22a2 \u2203 i, p' i \u2227 s' i \u2286 t"}, {"line": "exact \u27e8i', hi', hs's.trans ht\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.eventually_iff (hl : l.HasBasis p s) {q : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in l, q x) \u2194 \u2203 i, p i \u2227 \u2200 \u2983x\u2984, x \u2208 s i \u2192 q x := by simpa using hl.mem_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nhl : l.HasBasis p s\nq : \u03b1 \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : \u03b1) in l, q x) \u2194 \u2203 i, p i \u2227 \u2200 \u2983x : \u03b1\u2984, x \u2208 s i \u2192 q x"}, {"line": "simpa using hl.mem_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasBasis_self {l : Filter \u03b1} {P : Set \u03b1 \u2192 Prop} :\n    HasBasis l (fun s => s \u2208 l \u2227 P s) id \u2194 \u2200 t \u2208 l, \u2203 r \u2208 l, P r \u2227 r \u2286 t := by\n  simp only [hasBasis_iff]\n  simp only [id]\n  simp only [and_assoc]\n  exact forall_congr' fun s =>\n    \u27e8fun h => h.1, fun h => \u27e8h, fun \u27e8t, hl, _, hts\u27e9 => mem_of_superset hl hts\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\nP : Set \u03b1 \u2192 Prop\n\u22a2 l.HasBasis (fun s => s \u2208 l \u2227 P s) id \u2194 \u2200 t \u2208 l, \u2203 r \u2208 l, P r \u2227 r \u2286 t"}, {"line": "simp only [hasBasis_iff]", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\nP : Set \u03b1 \u2192 Prop\n\u22a2 (\u2200 (t : Set \u03b1), t \u2208 l \u2194 \u2203 i, (i \u2208 l \u2227 P i) \u2227 id i \u2286 t) \u2194 \u2200 t \u2208 l, \u2203 r \u2208 l, P r \u2227 r \u2286 t"}, {"line": "simp only [id]", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\nP : Set \u03b1 \u2192 Prop\n\u22a2 (\u2200 (t : Set \u03b1), t \u2208 l \u2194 \u2203 i, (i \u2208 l \u2227 P i) \u2227 i \u2286 t) \u2194 \u2200 t \u2208 l, \u2203 r \u2208 l, P r \u2227 r \u2286 t"}, {"line": "simp only [and_assoc]", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\nP : Set \u03b1 \u2192 Prop\n\u22a2 (\u2200 (t : Set \u03b1), t \u2208 l \u2194 \u2203 i \u2208 l, P i \u2227 i \u2286 t) \u2194 \u2200 t \u2208 l, \u2203 r \u2208 l, P r \u2227 r \u2286 t"}, {"line": "exact forall_congr' fun s =>\n    \u27e8fun h => h.1, fun h => \u27e8h, fun \u27e8t, hl, _, hts\u27e9 => mem_of_superset hl hts\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.restrict (h : l.HasBasis p s) {q : \u03b9 \u2192 Prop}\n    (hq : \u2200 i, p i \u2192 \u2203 j, p j \u2227 q j \u2227 s j \u2286 s i) : l.HasBasis (fun i => p i \u2227 q i) s := by\n  refine \u27e8fun t => \u27e8fun ht => ?_, fun \u27e8i, hpi, hti\u27e9 => h.mem_iff.2 \u27e8i, hpi.1, hti\u27e9\u27e9\u27e9\n  rcases h.mem_iff.1 ht with \u27e8i, hpi, hti\u27e9\n  rcases hq i hpi with \u27e8j, hpj, hqj, hji\u27e9\n  exact \u27e8j, \u27e8hpj, hqj\u27e9, hji.trans hti\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\nq : \u03b9 \u2192 Prop\nhq : \u2200 (i : \u03b9), p i \u2192 \u2203 j, p j \u2227 q j \u2227 s j \u2286 s i\n\u22a2 l.HasBasis (fun i => p i \u2227 q i) s"}, {"line": "refine \u27e8fun t => \u27e8fun ht => ?_, fun \u27e8i, hpi, hti\u27e9 => h.mem_iff.2 \u27e8i, hpi.1, hti\u27e9\u27e9\u27e9", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\nq : \u03b9 \u2192 Prop\nhq : \u2200 (i : \u03b9), p i \u2192 \u2203 j, p j \u2227 q j \u2227 s j \u2286 s i\nt : Set \u03b1\nht : t \u2208 l\n\u22a2 \u2203 i, (p i \u2227 q i) \u2227 s i \u2286 t"}, {"line": "rcases h.mem_iff.1 ht with \u27e8i, hpi, hti\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\nq : \u03b9 \u2192 Prop\nhq : \u2200 (i : \u03b9), p i \u2192 \u2203 j, p j \u2227 q j \u2227 s j \u2286 s i\nt : Set \u03b1\nht : t \u2208 l\ni : \u03b9\nhpi : p i\nhti : s i \u2286 t\n\u22a2 \u2203 i, (p i \u2227 q i) \u2227 s i \u2286 t"}, {"line": "rcases hq i hpi with \u27e8j, hpj, hqj, hji\u27e9", "tactic_state": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\nq : \u03b9 \u2192 Prop\nhq : \u2200 (i : \u03b9), p i \u2192 \u2203 j, p j \u2227 q j \u2227 s j \u2286 s i\nt : Set \u03b1\nht : t \u2208 l\ni : \u03b9\nhpi : p i\nhti : s i \u2286 t\nj : \u03b9\nhpj : p j\nhqj : q j\nhji : s j \u2286 s i\n\u22a2 \u2203 i, (p i \u2227 q i) \u2227 s i \u2286 t"}, {"line": "exact \u27e8j, \u27e8hpj, hqj\u27e9, hji.trans hti\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.hasBasis_self_subset {p : Set \u03b1 \u2192 Prop} (h : l.HasBasis (fun s => s \u2208 l \u2227 p s) id)\n    {V : Set \u03b1} (hV : V \u2208 l) : l.HasBasis (fun s => s \u2208 l \u2227 p s \u2227 s \u2286 V) id := by\n  simpa only [and_assoc] using h.restrict_subset hV\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\np : Set \u03b1 \u2192 Prop\nh : l.HasBasis (fun s => s \u2208 l \u2227 p s) id\nV : Set \u03b1\nhV : V \u2208 l\n\u22a2 l.HasBasis (fun s => s \u2208 l \u2227 p s \u2227 s \u2286 V) id"}, {"line": "simpa only [and_assoc] using h.restrict_subset hV", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.le_iff (hl : l.HasBasis p s) : l \u2264 l' \u2194 \u2200 t \u2208 l', \u2203 i, p i \u2227 s i \u2286 t := by\n  simp only [le_def]\n  simp only [hl.mem_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nhl : l.HasBasis p s\n\u22a2 l \u2264 l' \u2194 \u2200 t \u2208 l', \u2203 i, p i \u2227 s i \u2286 t"}, {"line": "simp only [le_def]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nhl : l.HasBasis p s\n\u22a2 (\u2200 x \u2208 l', x \u2208 l) \u2194 \u2200 t \u2208 l', \u2203 i, p i \u2227 s i \u2286 t"}, {"line": "simp only [hl.mem_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.le_basis_iff (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    l \u2264 l' \u2194 \u2200 i', p' i' \u2192 \u2203 i, p i \u2227 s i \u2286 s' i' := by\n  simp only [hl'.ge_iff]\n  simp only [hl.mem_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\n\u22a2 l \u2264 l' \u2194 \u2200 (i' : \u03b9'), p' i' \u2192 \u2203 i, p i \u2227 s i \u2286 s' i'"}, {"line": "simp only [hl'.ge_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\n\u22a2 (\u2200 (i' : \u03b9'), p' i' \u2192 s' i' \u2208 l) \u2194 \u2200 (i' : \u03b9'), p' i' \u2192 \u2203 i, p i \u2227 s i \u2286 s' i'"}, {"line": "simp only [hl.mem_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasBasis_pure (x : \u03b1) :\n    (pure x : Filter \u03b1).HasBasis (fun _ : Unit => True) fun _ => {x} := by\n  simp only [\u2190 principal_singleton]\n  simp only [hasBasis_principal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\n\u22a2 (pure x).HasBasis (fun x => True) fun x_1 => {x}"}, {"line": "simp only [\u2190 principal_singleton]", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\n\u22a2 (principal {x}).HasBasis (fun x => True) fun x_1 => {x}"}, {"line": "simp only [hasBasis_principal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.sup_pure (hl : l.HasBasis p s) (x : \u03b1) :\n    (l \u2294 pure x).HasBasis p fun i => s i \u222a {x} := by\n  simp only [\u2190 principal_singleton]\n  simp only [hl.sup_principal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nhl : l.HasBasis p s\nx : \u03b1\n\u22a2 (l \u2294 pure x).HasBasis p fun i => s i \u222a {x}"}, {"line": "simp only [\u2190 principal_singleton]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nhl : l.HasBasis p s\nx : \u03b1\n\u22a2 (l \u2294 principal {x}).HasBasis p fun i => s i \u222a {x}"}, {"line": "simp only [hl.sup_principal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.principal_inf (hl : l.HasBasis p s) (s' : Set \u03b1) :\n    (\ud835\udcdf s' \u2293 l).HasBasis p fun i => s' \u2229 s i := by\n  simpa only [inf_comm,inter_comm] using hl.inf_principal s'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nhl : l.HasBasis p s\ns' : Set \u03b1\n\u22a2 (principal s' \u2293 l).HasBasis p fun i => s' \u2229 s i"}, {"line": "simpa only [inf_comm,inter_comm] using hl.inf_principal s'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_iff_inf_principal_compl {f : Filter \u03b1} {s : Set \u03b1} : s \u2208 f \u2194 f \u2293 \ud835\udcdf s\u1d9c = \u22a5 := by\n  refine not_iff_not.1 ((inf_principal_neBot_iff.trans ?_).symm.trans neBot_iff)\n  exact\n    \u27e8fun h hs => by simpa [Set.not_nonempty_empty] using h s hs, fun hs t ht =>\n      inter_compl_nonempty_iff.2 fun hts => hs <| mem_of_superset ht hts\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\ns : Set \u03b1\n\u22a2 s \u2208 f \u2194 f \u2293 principal s\u1d9c = \u22a5"}, {"line": "refine not_iff_not.1 ((inf_principal_neBot_iff.trans ?_).symm.trans neBot_iff)", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\ns : Set \u03b1\n\u22a2 (\u2200 U \u2208 f, (U \u2229 s\u1d9c).Nonempty) \u2194 s \u2209 f"}, {"line": "exact\n    \u27e8fun h hs => by simpa [Set.not_nonempty_empty] using h s hs, fun hs t ht =>\n      inter_compl_nonempty_iff.2 fun hts => hs <| mem_of_superset ht hts\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_principal_right {f : Filter \u03b1} {s : Set \u03b1} : Disjoint f (\ud835\udcdf s) \u2194 s\u1d9c \u2208 f := by\n  rw [mem_iff_inf_principal_compl]\n  rw [compl_compl]\n  rw [disjoint_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\ns : Set \u03b1\n\u22a2 Disjoint f (principal s) \u2194 s\u1d9c \u2208 f"}, {"line": "rw [mem_iff_inf_principal_compl]", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\ns : Set \u03b1\n\u22a2 Disjoint f (principal s) \u2194 f \u2293 principal s\u1d9c\u1d9c = \u22a5"}, {"line": "rw [compl_compl]", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\ns : Set \u03b1\n\u22a2 Disjoint f (principal s) \u2194 f \u2293 principal s = \u22a5"}, {"line": "rw [disjoint_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_principal_left {f : Filter \u03b1} {s : Set \u03b1} : Disjoint (\ud835\udcdf s) f \u2194 s\u1d9c \u2208 f := by\n  rw [disjoint_comm]\n  rw [disjoint_principal_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\ns : Set \u03b1\n\u22a2 Disjoint (principal s) f \u2194 s\u1d9c \u2208 f"}, {"line": "rw [disjoint_comm]", "tactic_state": "\u03b1 : Type u_1\nf : Filter \u03b1\ns : Set \u03b1\n\u22a2 Disjoint f (principal s) \u2194 s\u1d9c \u2208 f"}, {"line": "rw [disjoint_principal_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_principal_principal {s t : Set \u03b1} : Disjoint (\ud835\udcdf s) (\ud835\udcdf t) \u2194 Disjoint s t := by\n  rw [\u2190 subset_compl_iff_disjoint_left]\n  rw [disjoint_principal_left]\n  rw [mem_principal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 Disjoint (principal s) (principal t) \u2194 Disjoint s t"}, {"line": "rw [\u2190 subset_compl_iff_disjoint_left]", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 Disjoint (principal s) (principal t) \u2194 t \u2286 s\u1d9c"}, {"line": "rw [disjoint_principal_left]", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 s\u1d9c \u2208 principal t \u2194 t \u2286 s\u1d9c"}, {"line": "rw [mem_principal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_pure_pure {x y : \u03b1} : Disjoint (pure x : Filter \u03b1) (pure y) \u2194 x \u2260 y := by\n  simp only [\u2190 principal_singleton]\n  simp only [disjoint_principal_principal]\n  simp only [disjoint_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx y : \u03b1\n\u22a2 Disjoint (pure x) (pure y) \u2194 x \u2260 y"}, {"line": "simp only [\u2190 principal_singleton]", "tactic_state": "\u03b1 : Type u_1\nx y : \u03b1\n\u22a2 Disjoint (principal {x}) (principal {y}) \u2194 x \u2260 y"}, {"line": "simp only [disjoint_principal_principal]", "tactic_state": "\u03b1 : Type u_1\nx y : \u03b1\n\u22a2 Disjoint {x} {y} \u2194 x \u2260 y"}, {"line": "simp only [disjoint_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.disjoint_iff_left (h : l.HasBasis p s) :\n    Disjoint l l' \u2194 \u2203 i, p i \u2227 (s i)\u1d9c \u2208 l' := by\n  simp only [h.disjoint_iff l'.basis_sets]\n  simp only [id]\n  simp only [\u2190 disjoint_principal_left]\n  simp only [(hasBasis_principal _).disjoint_iff l'.basis_sets]\n  simp only [true_and]\n  simp only [Unique.exists_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\n\u22a2 Disjoint l l' \u2194 \u2203 i, p i \u2227 (s i)\u1d9c \u2208 l'"}, {"line": "simp only [h.disjoint_iff l'.basis_sets]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\n\u22a2 (\u2203 i, p i \u2227 \u2203 i' \u2208 l', Disjoint (s i) (id i')) \u2194 \u2203 i, p i \u2227 (s i)\u1d9c \u2208 l'"}, {"line": "simp only [id]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\n\u22a2 (\u2203 i, p i \u2227 \u2203 i' \u2208 l', Disjoint (s i) i') \u2194 \u2203 i, p i \u2227 (s i)\u1d9c \u2208 l'"}, {"line": "simp only [\u2190 disjoint_principal_left]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\n\u22a2 (\u2203 i, p i \u2227 \u2203 i' \u2208 l', Disjoint (s i) i') \u2194 \u2203 i, p i \u2227 Disjoint (principal (s i)) l'"}, {"line": "simp only [(hasBasis_principal _).disjoint_iff l'.basis_sets]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\n\u22a2 (\u2203 i, p i \u2227 \u2203 i' \u2208 l', Disjoint (s i) i') \u2194 \u2203 i, p i \u2227 \u2203 i_1, True \u2227 \u2203 i' \u2208 l', Disjoint (s i) (id i')"}, {"line": "simp only [true_and]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\n\u22a2 (\u2203 i, p i \u2227 \u2203 i' \u2208 l', Disjoint (s i) i') \u2194 \u2203 i, p i \u2227 \u2203 i_1, \u2203 i' \u2208 l', Disjoint (s i) (id i')"}, {"line": "simp only [Unique.exists_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\n\u22a2 (\u2203 i, p i \u2227 \u2203 i' \u2208 l', Disjoint (s i) i') \u2194 \u2203 i, p i \u2227 \u2203 i' \u2208 l', Disjoint (s i) (id i')"}]}
{"declaration": "theorem inf_neBot_iff_frequently_right {f g : Filter \u03b1} :\n    NeBot (f \u2293 g) \u2194 \u2200 {p : \u03b1 \u2192 Prop}, (\u2200\u1da0 x in g, p x) \u2192 \u2203\u1da0 x in f, p x := by\n  rw [inf_comm]\n  exact inf_neBot_iff_frequently_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf g : Filter \u03b1\n\u22a2 (f \u2293 g).NeBot \u2194 \u2200 {p : \u03b1 \u2192 Prop}, (\u2200\u1da0 (x : \u03b1) in g, p x) \u2192 \u2203\u1da0 (x : \u03b1) in f, p x"}, {"line": "rw [inf_comm]", "tactic_state": "\u03b1 : Type u_1\nf g : Filter \u03b1\n\u22a2 (g \u2293 f).NeBot \u2194 \u2200 {p : \u03b1 \u2192 Prop}, (\u2200\u1da0 (x : \u03b1) in g, p x) \u2192 \u2203\u1da0 (x : \u03b1) in f, p x"}, {"line": "exact inf_neBot_iff_frequently_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.eq_iInf (h : l.HasBasis (fun _ => True) s) : l = \u2a05 i, \ud835\udcdf (s i) := by\n  simpa only [iInf_true] using h.eq_biInf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl : Filter \u03b1\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis (fun x => True) s\n\u22a2 l = \u2a05 i, principal (s i)"}, {"line": "simpa only [iInf_true] using h.eq_biInf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.forall_mem_mem (h : HasBasis l p s) {x : \u03b1} :\n    (\u2200 t \u2208 l, x \u2208 t) \u2194 \u2200 i, p i \u2192 x \u2208 s i := by\n  simp only [h.mem_iff]\n  simp only [exists_imp]\n  simp only [and_imp]\n  exact \u27e8fun h i hi => h (s i) i hi Subset.rfl, fun h t i hi ht => ht (h i hi)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\nx : \u03b1\n\u22a2 (\u2200 t \u2208 l, x \u2208 t) \u2194 \u2200 (i : \u03b9), p i \u2192 x \u2208 s i"}, {"line": "simp only [h.mem_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\nx : \u03b1\n\u22a2 (\u2200 (t : Set \u03b1), (\u2203 i, p i \u2227 s i \u2286 t) \u2192 x \u2208 t) \u2194 \u2200 (i : \u03b9), p i \u2192 x \u2208 s i"}, {"line": "simp only [exists_imp]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\nx : \u03b1\n\u22a2 (\u2200 (t : Set \u03b1) (x_1 : \u03b9), p x_1 \u2227 s x_1 \u2286 t \u2192 x \u2208 t) \u2194 \u2200 (i : \u03b9), p i \u2192 x \u2208 s i"}, {"line": "simp only [and_imp]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_4\nl : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nh : l.HasBasis p s\nx : \u03b1\n\u22a2 (\u2200 (t : Set \u03b1) (x_1 : \u03b9), p x_1 \u2192 s x_1 \u2286 t \u2192 x \u2208 t) \u2194 \u2200 (i : \u03b9), p i \u2192 x \u2208 s i"}, {"line": "exact \u27e8fun h i hi => h (s i) i hi Subset.rfl, fun h t i hi ht => ht (h i hi)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.tendsto_left_iff (hla : la.HasBasis pa sa) :\n    Tendsto f la lb \u2194 \u2200 t \u2208 lb, \u2203 i, pa i \u2227 MapsTo f (sa i) t := by\n  simp only [Tendsto]\n  simp only [(hla.map f).le_iff]\n  simp only [image_subset_iff]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}", "{\u03b9'' : Type*} [Preorder \u03b9''] (l) (s'' : \u03b9'' \u2192 Set \u03b1)", "{la : Filter \u03b1} {pa : \u03b9 \u2192 Prop} {sa : \u03b9 \u2192 Set \u03b1} {lb : Filter \u03b2} {pb : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\nla : Filter \u03b1\npa : \u03b9 \u2192 Prop\nsa : \u03b9 \u2192 Set \u03b1\nlb : Filter \u03b2\nf : \u03b1 \u2192 \u03b2\nhla : la.HasBasis pa sa\n\u22a2 Tendsto f la lb \u2194 \u2200 t \u2208 lb, \u2203 i, pa i \u2227 MapsTo f (sa i) t"}, {"line": "simp only [Tendsto]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\nla : Filter \u03b1\npa : \u03b9 \u2192 Prop\nsa : \u03b9 \u2192 Set \u03b1\nlb : Filter \u03b2\nf : \u03b1 \u2192 \u03b2\nhla : la.HasBasis pa sa\n\u22a2 map f la \u2264 lb \u2194 \u2200 t \u2208 lb, \u2203 i, pa i \u2227 MapsTo f (sa i) t"}, {"line": "simp only [(hla.map f).le_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\nla : Filter \u03b1\npa : \u03b9 \u2192 Prop\nsa : \u03b9 \u2192 Set \u03b1\nlb : Filter \u03b2\nf : \u03b1 \u2192 \u03b2\nhla : la.HasBasis pa sa\n\u22a2 (\u2200 t \u2208 lb, \u2203 i, pa i \u2227 f '' sa i \u2286 t) \u2194 \u2200 t \u2208 lb, \u2203 i, pa i \u2227 MapsTo f (sa i) t"}, {"line": "simp only [image_subset_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\nla : Filter \u03b1\npa : \u03b9 \u2192 Prop\nsa : \u03b9 \u2192 Set \u03b1\nlb : Filter \u03b2\nf : \u03b1 \u2192 \u03b2\nhla : la.HasBasis pa sa\n\u22a2 (\u2200 t \u2208 lb, \u2203 i, pa i \u2227 sa i \u2286 f \u207b\u00b9' t) \u2194 \u2200 t \u2208 lb, \u2203 i, pa i \u2227 MapsTo f (sa i) t"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.tendsto_right_iff (hlb : lb.HasBasis pb sb) :\n    Tendsto f la lb \u2194 \u2200 i, pb i \u2192 \u2200\u1da0 x in la, f x \u2208 sb i := by\n  simp only [Tendsto]\n  simp only [hlb.ge_iff]\n  simp only [mem_map']\n  simp only [Filter.Eventually]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}", "{\u03b9'' : Type*} [Preorder \u03b9''] (l) (s'' : \u03b9'' \u2192 Set \u03b1)", "{la : Filter \u03b1} {pa : \u03b9 \u2192 Prop} {sa : \u03b9 \u2192 Set \u03b1} {lb : Filter \u03b2} {pb : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9' : Sort u_5\nla : Filter \u03b1\nlb : Filter \u03b2\npb : \u03b9' \u2192 Prop\nsb : \u03b9' \u2192 Set \u03b2\nf : \u03b1 \u2192 \u03b2\nhlb : lb.HasBasis pb sb\n\u22a2 Tendsto f la lb \u2194 \u2200 (i : \u03b9'), pb i \u2192 \u2200\u1da0 (x : \u03b1) in la, f x \u2208 sb i"}, {"line": "simp only [Tendsto]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9' : Sort u_5\nla : Filter \u03b1\nlb : Filter \u03b2\npb : \u03b9' \u2192 Prop\nsb : \u03b9' \u2192 Set \u03b2\nf : \u03b1 \u2192 \u03b2\nhlb : lb.HasBasis pb sb\n\u22a2 map f la \u2264 lb \u2194 \u2200 (i : \u03b9'), pb i \u2192 \u2200\u1da0 (x : \u03b1) in la, f x \u2208 sb i"}, {"line": "simp only [hlb.ge_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9' : Sort u_5\nla : Filter \u03b1\nlb : Filter \u03b2\npb : \u03b9' \u2192 Prop\nsb : \u03b9' \u2192 Set \u03b2\nf : \u03b1 \u2192 \u03b2\nhlb : lb.HasBasis pb sb\n\u22a2 (\u2200 (i' : \u03b9'), pb i' \u2192 sb i' \u2208 map f la) \u2194 \u2200 (i : \u03b9'), pb i \u2192 \u2200\u1da0 (x : \u03b1) in la, f x \u2208 sb i"}, {"line": "simp only [mem_map']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9' : Sort u_5\nla : Filter \u03b1\nlb : Filter \u03b2\npb : \u03b9' \u2192 Prop\nsb : \u03b9' \u2192 Set \u03b2\nf : \u03b1 \u2192 \u03b2\nhlb : lb.HasBasis pb sb\n\u22a2 (\u2200 (i' : \u03b9'), pb i' \u2192 {x | f x \u2208 sb i'} \u2208 la) \u2194 \u2200 (i : \u03b9'), pb i \u2192 \u2200\u1da0 (x : \u03b1) in la, f x \u2208 sb i"}, {"line": "simp only [Filter.Eventually]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasBasis.tendsto_iff (hla : la.HasBasis pa sa) (hlb : lb.HasBasis pb sb) :\n    Tendsto f la lb \u2194 \u2200 ib, pb ib \u2192 \u2203 ia, pa ia \u2227 \u2200 x \u2208 sa ia, f x \u2208 sb ib := by\n  simp [hlb.tendsto_right_iff, hla.eventually_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}", "{\u03b9'' : Type*} [Preorder \u03b9''] (l) (s'' : \u03b9'' \u2192 Set \u03b1)", "{la : Filter \u03b1} {pa : \u03b9 \u2192 Prop} {sa : \u03b9 \u2192 Set \u03b1} {lb : Filter \u03b2} {pb : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nla : Filter \u03b1\npa : \u03b9 \u2192 Prop\nsa : \u03b9 \u2192 Set \u03b1\nlb : Filter \u03b2\npb : \u03b9' \u2192 Prop\nsb : \u03b9' \u2192 Set \u03b2\nf : \u03b1 \u2192 \u03b2\nhla : la.HasBasis pa sa\nhlb : lb.HasBasis pb sb\n\u22a2 Tendsto f la lb \u2194 \u2200 (ib : \u03b9'), pb ib \u2192 \u2203 ia, pa ia \u2227 \u2200 x \u2208 sa ia, f x \u2208 sb ib"}, {"line": "simp [hlb.tendsto_right_iff, hla.eventually_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem HasBasis.principal_prod (sa : Set \u03b1) (h : lb.HasBasis pb sb) :\n    (\ud835\udcdf sa \u00d7\u02e2 lb).HasBasis pb (sa \u00d7\u02e2 sb \u00b7) := by\n  simpa only [prod_eq_inf,comap_principal,prod_eq] using (h.comap Prod.snd).principal_inf _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}", "{\u03b9'' : Type*} [Preorder \u03b9''] (l) (s'' : \u03b9'' \u2192 Set \u03b1)", "{la : Filter \u03b1} {pa : \u03b9 \u2192 Prop} {sa : \u03b9 \u2192 Set \u03b1} {lb : Filter \u03b2} {pb : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9' : Sort u_5\nlb : Filter \u03b2\npb : \u03b9' \u2192 Prop\nsb : \u03b9' \u2192 Set \u03b2\nsa : Set \u03b1\nh : lb.HasBasis pb sb\n\u22a2 (principal sa \u00d7\u02e2 lb).HasBasis pb fun x => sa \u00d7\u02e2 sb x"}, {"line": "simpa only [prod_eq_inf,comap_principal,prod_eq] using (h.comap Prod.snd).principal_inf _", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem HasBasis.prod_principal (h : la.HasBasis pa sa) (sb : Set \u03b2) :\n    (la \u00d7\u02e2 \ud835\udcdf sb).HasBasis pa (sa \u00b7 \u00d7\u02e2 sb) := by\n  simpa only [prod_eq_inf,comap_principal,prod_eq] using (h.comap Prod.fst).inf_principal _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}", "{\u03b9'' : Type*} [Preorder \u03b9''] (l) (s'' : \u03b9'' \u2192 Set \u03b1)", "{la : Filter \u03b1} {pa : \u03b9 \u2192 Prop} {sa : \u03b9 \u2192 Set \u03b1} {lb : Filter \u03b2} {pb : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\nla : Filter \u03b1\npa : \u03b9 \u2192 Prop\nsa : \u03b9 \u2192 Set \u03b1\nh : la.HasBasis pa sa\nsb : Set \u03b2\n\u22a2 (la \u00d7\u02e2 principal sb).HasBasis pa fun x => sa x \u00d7\u02e2 sb"}, {"line": "simpa only [prod_eq_inf,comap_principal,prod_eq] using (h.comap Prod.fst).inf_principal _", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem HasBasis.top_prod (h : lb.HasBasis pb sb) :\n    (\u22a4 \u00d7\u02e2 lb : Filter (\u03b1 \u00d7 \u03b2)).HasBasis pb (univ \u00d7\u02e2 sb \u00b7) := by\n  simpa only [principal_univ] using h.principal_prod univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}", "{\u03b9'' : Type*} [Preorder \u03b9''] (l) (s'' : \u03b9'' \u2192 Set \u03b1)", "{la : Filter \u03b1} {pa : \u03b9 \u2192 Prop} {sa : \u03b9 \u2192 Set \u03b1} {lb : Filter \u03b2} {pb : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9' : Sort u_5\nlb : Filter \u03b2\npb : \u03b9' \u2192 Prop\nsb : \u03b9' \u2192 Set \u03b2\nh : lb.HasBasis pb sb\n\u22a2 (\u22a4 \u00d7\u02e2 lb).HasBasis pb fun x => univ \u00d7\u02e2 sb x"}, {"line": "simpa only [principal_univ] using h.principal_prod univ", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem HasBasis.prod_top (h : la.HasBasis pa sa) :\n    (la \u00d7\u02e2 \u22a4 : Filter (\u03b1 \u00d7 \u03b2)).HasBasis pa (sa \u00b7 \u00d7\u02e2 univ) := by\n  simpa only [principal_univ] using h.prod_principal univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}", "{\u03b9'' : Type*} [Preorder \u03b9''] (l) (s'' : \u03b9'' \u2192 Set \u03b1)", "{la : Filter \u03b1} {pa : \u03b9 \u2192 Prop} {sa : \u03b9 \u2192 Set \u03b1} {lb : Filter \u03b2} {pb : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\nla : Filter \u03b1\npa : \u03b9 \u2192 Prop\nsa : \u03b9 \u2192 Set \u03b1\nh : la.HasBasis pa sa\n\u22a2 (la \u00d7\u02e2 \u22a4).HasBasis pa fun x => sa x \u00d7\u02e2 univ"}, {"line": "simpa only [principal_univ] using h.prod_principal univ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_sigma_mk_comap {\u03c0 : \u03b1 \u2192 Type*} {\u03c0' : \u03b2 \u2192 Type*} {f : \u03b1 \u2192 \u03b2}\n    (hf : Function.Injective f) (g : \u2200 a, \u03c0 a \u2192 \u03c0' (f a)) (a : \u03b1) (l : Filter (\u03c0' (f a))) :\n    map (Sigma.mk a) (comap (g a) l) = comap (Sigma.map f g) (map (Sigma.mk (f a)) l) := by\n  refine (((basis_sets _).comap _).map _).eq_of_same_basis ?_\n  convert ((basis_sets l).map (Sigma.mk (f a))).comap (Sigma.map f g)\n  apply image_sigmaMk_preimage_sigmaMap hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s)", "{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}", "{\u03b9'' : Type*} [Preorder \u03b9''] (l) (s'' : \u03b9'' \u2192 Set \u03b1)", "{la : Filter \u03b1} {pa : \u03b9 \u2192 Prop} {sa : \u03b9 \u2192 Set \u03b1} {lb : Filter \u03b2} {pb : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03c0 : \u03b1 \u2192 Type u_7\n\u03c0' : \u03b2 \u2192 Type u_8\nf : \u03b1 \u2192 \u03b2\nhf : Function.Injective f\ng : (a : \u03b1) \u2192 \u03c0 a \u2192 \u03c0' (f a)\na : \u03b1\nl : Filter (\u03c0' (f a))\n\u22a2 map (Sigma.mk a) (comap (g a) l) = comap (Sigma.map f g) (map (Sigma.mk (f a)) l)"}, {"line": "refine (((basis_sets _).comap _).map _).eq_of_same_basis ?_", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03c0 : \u03b1 \u2192 Type u_7\n\u03c0' : \u03b2 \u2192 Type u_8\nf : \u03b1 \u2192 \u03b2\nhf : Function.Injective f\ng : (a : \u03b1) \u2192 \u03c0 a \u2192 \u03c0' (f a)\na : \u03b1\nl : Filter (\u03c0' (f a))\n\u22a2 (comap (Sigma.map f g) (map (Sigma.mk (f a)) l)).HasBasis (fun s => s \u2208 l) fun i => Sigma.mk a '' (g a \u207b\u00b9' id i)"}, {"line": "convert ((basis_sets l).map (Sigma.mk (f a))).comap (Sigma.map f g)", "tactic_state": "case h.e'_5.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03c0 : \u03b1 \u2192 Type u_7\n\u03c0' : \u03b2 \u2192 Type u_8\nf : \u03b1 \u2192 \u03b2\nhf : Function.Injective f\ng : (a : \u03b1) \u2192 \u03c0 a \u2192 \u03c0' (f a)\na : \u03b1\nl : Filter (\u03c0' (f a))\nx\u271d : Set (\u03c0' (f a))\n\u22a2 Sigma.mk a '' (g a \u207b\u00b9' id x\u271d) = Sigma.map f g \u207b\u00b9' (Sigma.mk (f a) '' id x\u271d)"}, {"line": "apply image_sigmaMk_preimage_sigmaMap hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofSets_filter_eq_generate (s : Set (Set \u03b1)) :\n    (FilterBasis.ofSets s).filter = generate s := by\n  rw [\u2190 (FilterBasis.ofSets s).generate]\n  rw [FilterBasis.ofSets_sets]\n  rw [\u2190 generate_eq_generate_inter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Finite.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set (Set \u03b1)\n\u22a2 (FilterBasis.ofSets s).filter = generate s"}, {"line": "rw [\u2190 (FilterBasis.ofSets s).generate]", "tactic_state": "\u03b1 : Type u_1\ns : Set (Set \u03b1)\n\u22a2 generate (FilterBasis.ofSets s).sets = generate s"}, {"line": "rw [FilterBasis.ofSets_sets]", "tactic_state": "\u03b1 : Type u_1\ns : Set (Set \u03b1)\n\u22a2 generate (sInter '' {t | t.Finite \u2227 t \u2286 s}) = generate s"}, {"line": "rw [\u2190 generate_eq_generate_inter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Set.PairwiseDisjoint.exists_mem_filter_basis {I : Type*} {l : I \u2192 Filter \u03b1}\n    {\u03b9 : I \u2192 Sort*} {p : \u2200 i, \u03b9 i \u2192 Prop} {s : \u2200 i, \u03b9 i \u2192 Set \u03b1} {S : Set I}\n    (hd : S.PairwiseDisjoint l) (hS : S.Finite) (h : \u2200 i, (l i).HasBasis (p i) (s i)) :\n    \u2203 ind : \u2200 i, \u03b9 i, (\u2200 i, p i (ind i)) \u2227 S.PairwiseDisjoint fun i => s i (ind i) := by\n  rcases hd.exists_mem_filter hS with \u27e8t, htl, hd\u27e9\n  choose ind hp ht using fun i => (h i).mem_iff.1 (htl i)\n  exact \u27e8ind, hp, hd.mono ht\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Bases/Finite.lean", "context": {"open": ["Set Filter", "scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 \u03b9' : Sort*}", "{l l' : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} {i : \u03b9} {p' : \u03b9' \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nI : Type u_1\nl : I \u2192 Filter \u03b1\n\u03b9 : I \u2192 Sort u_2\np : (i : I) \u2192 \u03b9 i \u2192 Prop\ns : (i : I) \u2192 \u03b9 i \u2192 Set \u03b1\nS : Set I\nhd : S.PairwiseDisjoint l\nhS : S.Finite\nh : \u2200 (i : I), (l i).HasBasis (p i) (s i)\n\u22a2 \u2203 ind, (\u2200 (i : I), p i (ind i)) \u2227 S.PairwiseDisjoint fun i => s i (ind i)"}, {"line": "rcases hd.exists_mem_filter hS with \u27e8t, htl, hd\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_3\nI : Type u_1\nl : I \u2192 Filter \u03b1\n\u03b9 : I \u2192 Sort u_2\np : (i : I) \u2192 \u03b9 i \u2192 Prop\ns : (i : I) \u2192 \u03b9 i \u2192 Set \u03b1\nS : Set I\nhd\u271d : S.PairwiseDisjoint l\nhS : S.Finite\nh : \u2200 (i : I), (l i).HasBasis (p i) (s i)\nt : I \u2192 Set \u03b1\nhtl : \u2200 (i : I), t i \u2208 l i\nhd : S.PairwiseDisjoint t\n\u22a2 \u2203 ind, (\u2200 (i : I), p i (ind i)) \u2227 S.PairwiseDisjoint fun i => s i (ind i)"}, {"line": "choose ind hp ht using fun i => (h i).mem_iff.1 (htl i)", "tactic_state": "case intro.intro\n\u03b1 : Type u_3\nI : Type u_1\nl : I \u2192 Filter \u03b1\n\u03b9 : I \u2192 Sort u_2\np : (i : I) \u2192 \u03b9 i \u2192 Prop\ns : (i : I) \u2192 \u03b9 i \u2192 Set \u03b1\nS : Set I\nhd\u271d : S.PairwiseDisjoint l\nhS : S.Finite\nh : \u2200 (i : I), (l i).HasBasis (p i) (s i)\nt : I \u2192 Set \u03b1\nhtl : \u2200 (i : I), t i \u2208 l i\nhd : S.PairwiseDisjoint t\nind : (i : I) \u2192 \u03b9 i\nhp : \u2200 (i : I), p i (ind i)\nht : \u2200 (i : I), s i (ind i) \u2286 t i\n\u22a2 \u2203 ind, (\u2200 (i : I), p i (ind i)) \u2227 S.PairwiseDisjoint fun i => s i (ind i)"}, {"line": "exact \u27e8ind, hp, hd.mono ht\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isConstant_coe_const {l : Filter \u03b1} {b : \u03b2} : (fun _ : \u03b1 \u21a6 b : Germ l \u03b2).IsConstant := by\n  use b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Germ/Basic.lean", "context": {"open": ["scoped Relator"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {l : Filter \u03b1} {f g h : \u03b1 \u2192 \u03b2}", "{\u03b5 : \u03b1 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_6\nGerm : x\u271d\nl : Filter \u03b1\nb : \u03b2\n\u22a2 sorry"}, {"line": "use b", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eventually_exists_mem_iff {is : Set \u03b2} {P : \u03b2 \u2192 \u03b1 \u2192 Prop} (his : is.Finite) :\n    (\u2200\u1da0 i in f, \u2203 a \u2208 is, P a i) \u2194 \u2203 a \u2208 is, \u2200\u1da0 i in f, P a i := by\n  simp only [Filter.Eventually]\n  simp only [Ultrafilter.mem_coe]\n  convert f.finite_biUnion_mem_iff his (s := P) with i\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Ultrafilter/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "{f : Ultrafilter \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : Ultrafilter \u03b1\nis : Set \u03b2\nP : \u03b2 \u2192 \u03b1 \u2192 Prop\nhis : is.Finite\n\u22a2 (\u2200\u1da0 (i : \u03b1) in \u2191f, \u2203 a \u2208 is, P a i) \u2194 \u2203 a \u2208 is, \u2200\u1da0 (i : \u03b1) in \u2191f, P a i"}, {"line": "simp only [Filter.Eventually]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : Ultrafilter \u03b1\nis : Set \u03b2\nP : \u03b2 \u2192 \u03b1 \u2192 Prop\nhis : is.Finite\n\u22a2 {x | \u2203 a \u2208 is, P a x} \u2208 \u2191f \u2194 \u2203 a \u2208 is, {x | P a x} \u2208 \u2191f"}, {"line": "simp only [Ultrafilter.mem_coe]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : Ultrafilter \u03b1\nis : Set \u03b2\nP : \u03b2 \u2192 \u03b1 \u2192 Prop\nhis : is.Finite\n\u22a2 {x | \u2203 a \u2208 is, P a x} \u2208 f \u2194 \u2203 a \u2208 is, {x | P a x} \u2208 f"}, {"line": "convert f.finite_biUnion_mem_iff his (s := P) with i", "tactic_state": "case h.e'_1.h.e'_5\n\u03b1 : Type u\n\u03b2 : Type v\nf : Ultrafilter \u03b1\nis : Set \u03b2\nP : \u03b2 \u2192 \u03b1 \u2192 Prop\nhis : is.Finite\n\u22a2 {x | \u2203 a \u2208 is, P a x} = \u22c3 i \u2208 is, P i"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eventually_exists_iff [Finite \u03b2] {P : \u03b2 \u2192 \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 i in f, \u2203 a, P a i) \u2194 \u2203 a, \u2200\u1da0 i in f, P a i := by\n  simpa using eventually_exists_mem_iff (f := f) (P := P) Set.finite_univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Ultrafilter/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "{f : Ultrafilter \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : Ultrafilter \u03b1\ninst\u271d : Finite \u03b2\nP : \u03b2 \u2192 \u03b1 \u2192 Prop\n\u22a2 (\u2200\u1da0 (i : \u03b1) in \u2191f, \u2203 a, P a i) \u2194 \u2203 a, \u2200\u1da0 (i : \u03b1) in \u2191f, P a i"}, {"line": "simpa using eventually_exists_mem_iff (f := f) (P := P) Set.finite_univ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_pure_of_finite_mem (h : s.Finite) (h' : s \u2208 f) : \u2203 x \u2208 s, f = pure x := by\n  rw [\u2190 biUnion_of_singleton s] at h'\n  rcases (Ultrafilter.finite_biUnion_mem_iff h).mp h' with \u27e8a, has, haf\u27e9\n  exact \u27e8a, has, eq_of_le (Filter.le_pure_iff.2 haf)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Ultrafilter/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "{f : Ultrafilter \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nf : Ultrafilter \u03b1\ns : Set \u03b1\nh : s.Finite\nh' : s \u2208 f\n\u22a2 \u2203 x \u2208 s, f = pure x"}, {"line": "rw [\u2190 biUnion_of_singleton s] at h'", "tactic_state": "\u03b1 : Type u\nf : Ultrafilter \u03b1\ns : Set \u03b1\nh : s.Finite\nh' : \u22c3 x \u2208 s, {x} \u2208 f\n\u22a2 \u2203 x \u2208 s, f = pure x"}, {"line": "rcases (Ultrafilter.finite_biUnion_mem_iff h).mp h' with \u27e8a, has, haf\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\nf : Ultrafilter \u03b1\ns : Set \u03b1\nh : s.Finite\nh' : \u22c3 x \u2208 s, {x} \u2208 f\na : \u03b1\nhas : a \u2208 s\nhaf : {a} \u2208 f\n\u22a2 \u2203 x \u2208 s, f = pure x"}, {"line": "exact \u27e8a, has, eq_of_le (Filter.le_pure_iff.2 haf)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_iff_ultrafilter (f : \u03b1 \u2192 \u03b2) (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) :\n    Tendsto f l\u2081 l\u2082 \u2194 \u2200 g : Ultrafilter \u03b1, \u2191g \u2264 l\u2081 \u2192 Tendsto f g l\u2082 := by\n  simpa only [tendsto_iff_comap] using le_iff_ultrafilter\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Ultrafilter/Basic.lean", "context": {"open": ["Set Filter", "Ultrafilter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "{f : Ultrafilter \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nl\u2081 : Filter \u03b1\nl\u2082 : Filter \u03b2\n\u22a2 Tendsto f l\u2081 l\u2082 \u2194 \u2200 (g : Ultrafilter \u03b1), \u2191g \u2264 l\u2081 \u2192 Tendsto f (\u2191g) l\u2082"}, {"line": "simpa only [tendsto_iff_comap] using le_iff_ultrafilter", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem NeBot.eq_pure_iff (hf : f.NeBot) {x : \u03b1} :\n    f = pure x \u2194 {x} \u2208 f := by\n  rw [\u2190 hf.le_pure_iff]\n  rw [le_pure_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Ultrafilter/Defs.lean", "context": {"open": ["Set Filter Function", "Ultrafilter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type*}", "{f g : Ultrafilter \u03b1} {s t : Set \u03b1} {p q : \u03b1 \u2192 Prop}", "{f : Filter \u03b1} {s : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nf : Filter \u03b1\nhf : f.NeBot\nx : \u03b1\n\u22a2 f = pure x \u2194 {x} \u2208 f"}, {"line": "rw [\u2190 hf.le_pure_iff]", "tactic_state": "\u03b1 : Type u\nf : Filter \u03b1\nhf : f.NeBot\nx : \u03b1\n\u22a2 f \u2264 pure x \u2194 {x} \u2208 f"}, {"line": "rw [le_pure_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_iff_ultrafilter : s \u2208 f \u2194 \u2200 g : Ultrafilter \u03b1, \u2191g \u2264 f \u2192 s \u2208 g := by\n  refine \u27e8fun hf g hg => hg hf, fun H => by_contra fun hf => ?_\u27e9\n  set g : Filter (s\u1d9c : Set \u03b1) := comap (\u2191) f\n  haveI : NeBot g := comap_neBot_iff_compl_range.2 (by simpa [compl_setOf] )\n  simpa using H ((of g).map (\u2191)) (map_le_iff_le_comap.mpr (of_le g))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Ultrafilter/Defs.lean", "context": {"open": ["Set Filter Function", "Ultrafilter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type*}", "{f g : Ultrafilter \u03b1} {s t : Set \u03b1} {p q : \u03b1 \u2192 Prop}", "{f : Filter \u03b1} {s : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nf : Filter \u03b1\ns : Set \u03b1\n\u22a2 s \u2208 f \u2194 \u2200 (g : Ultrafilter \u03b1), \u2191g \u2264 f \u2192 s \u2208 g"}, {"line": "refine \u27e8fun hf g hg => hg hf, fun H => by_contra fun hf => ?_\u27e9", "tactic_state": "\u03b1 : Type u\nf : Filter \u03b1\ns : Set \u03b1\nH : \u2200 (g : Ultrafilter \u03b1), \u2191g \u2264 f \u2192 s \u2208 g\nhf : s \u2209 f\n\u22a2 False"}, {"line": "set g : Filter (s\u1d9c : Set \u03b1) := comap (\u2191) f", "tactic_state": "\u03b1 : Type u\nf : Filter \u03b1\ns : Set \u03b1\nH : \u2200 (g : Ultrafilter \u03b1), \u2191g \u2264 f \u2192 s \u2208 g\nhf : s \u2209 f\ng : Filter \u2191s\u1d9c := Filter.comap Subtype.val f\n\u22a2 False"}, {"line": "haveI : NeBot g := comap_neBot_iff_compl_range.2 (by simpa [compl_setOf] )", "tactic_state": "\u03b1 : Type u\nf : Filter \u03b1\ns : Set \u03b1\nH : \u2200 (g : Ultrafilter \u03b1), \u2191g \u2264 f \u2192 s \u2208 g\nhf : s \u2209 f\ng : Filter \u2191s\u1d9c := Filter.comap Subtype.val f\nthis : g.NeBot\n\u22a2 False"}, {"line": "simpa using H ((of g).map (\u2191)) (map_le_iff_le_comap.mpr (of_le g))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem forall_neBot_le_iff {g : Filter \u03b1} {p : Filter \u03b1 \u2192 Prop} (hp : Monotone p) :\n    (\u2200 f : Filter \u03b1, NeBot f \u2192 f \u2264 g \u2192 p f) \u2194 \u2200 f : Ultrafilter \u03b1, \u2191f \u2264 g \u2192 p f := by\n  refine \u27e8fun H f hf => H f f.neBot hf, ?_\u27e9\n  intro H f hf hfg\n  exact hp (of_le f) (H _ ((of_le f).trans hfg))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Ultrafilter/Defs.lean", "context": {"open": ["Set Filter Function", "Ultrafilter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type*}", "{f g : Ultrafilter \u03b1} {s t : Set \u03b1} {p q : \u03b1 \u2192 Prop}", "{f : Filter \u03b1} {s : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ng : Filter \u03b1\np : Filter \u03b1 \u2192 Prop\nhp : Monotone p\n\u22a2 (\u2200 (f : Filter \u03b1), f.NeBot \u2192 f \u2264 g \u2192 p f) \u2194 \u2200 (f : Ultrafilter \u03b1), \u2191f \u2264 g \u2192 p \u2191f"}, {"line": "refine \u27e8fun H f hf => H f f.neBot hf, ?_\u27e9", "tactic_state": "\u03b1 : Type u\ng : Filter \u03b1\np : Filter \u03b1 \u2192 Prop\nhp : Monotone p\n\u22a2 (\u2200 (f : Ultrafilter \u03b1), \u2191f \u2264 g \u2192 p \u2191f) \u2192 \u2200 (f : Filter \u03b1), f.NeBot \u2192 f \u2264 g \u2192 p f"}, {"line": "intro H f hf hfg", "tactic_state": "\u03b1 : Type u\ng : Filter \u03b1\np : Filter \u03b1 \u2192 Prop\nhp : Monotone p\nH : \u2200 (f : Ultrafilter \u03b1), \u2191f \u2264 g \u2192 p \u2191f\nf : Filter \u03b1\nhf : f.NeBot\nhfg : f \u2264 g\n\u22a2 p f"}, {"line": "exact hp (of_le f) (H _ ((of_le f).trans hfg))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofComapInfPrincipal_mem (h : m '' s \u2208 g) : s \u2208 ofComapInfPrincipal h := by\n  let f := Filter.comap m g \u2293 \ud835\udcdf s\n  haveI : f.NeBot := comap_inf_principal_neBot_of_image_mem h\n  have : s \u2208 f := mem_inf_of_right (mem_principal_self s)\n  exact le_def.mp (of_le _) s this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Filter/Ultrafilter/Defs.lean", "context": {"open": ["Set Filter Function", "Ultrafilter", "Filter"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type*}", "{f g : Ultrafilter \u03b1} {s t : Set \u03b1} {p q : \u03b1 \u2192 Prop}", "{f : Filter \u03b1} {s : Set \u03b1} {a : \u03b1}", "{m : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {g : Ultrafilter \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nm : \u03b1 \u2192 \u03b2\ns : Set \u03b1\ng : Ultrafilter \u03b2\nh : m '' s \u2208 g\n\u22a2 s \u2208 ofComapInfPrincipal h"}, {"line": "let f := Filter.comap m g \u2293 \ud835\udcdf s", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nm : \u03b1 \u2192 \u03b2\ns : Set \u03b1\ng : Ultrafilter \u03b2\nh : m '' s \u2208 g\nf : Filter \u03b1 := Filter.comap m \u2191g \u2293 sorry\n\u22a2 s \u2208 ofComapInfPrincipal h"}, {"line": "haveI : f.NeBot := comap_inf_principal_neBot_of_image_mem h", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nm : \u03b1 \u2192 \u03b2\ns : Set \u03b1\ng : Ultrafilter \u03b2\nh : m '' s \u2208 g\nf : Filter \u03b1 := Filter.comap m \u2191g \u2293 sorry\nthis : f.NeBot\n\u22a2 s \u2208 ofComapInfPrincipal h"}, {"line": "have : s \u2208 f := mem_inf_of_right (mem_principal_self s)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nm : \u03b1 \u2192 \u03b2\ns : Set \u03b1\ng : Ultrafilter \u03b2\nh : m '' s \u2208 g\nf : Filter \u03b1 := Filter.comap m \u2191g \u2293 sorry\nthis\u271d : f.NeBot\nthis : s \u2208 f\n\u22a2 s \u2208 ofComapInfPrincipal h"}, {"line": "exact le_def.mp (of_le _) s this", "tactic_state": "No Goals!"}]}
{"declaration": "lemma predAbove_le_predAbove {p q : Fin n} (hpq : p \u2264 q) {i j : Fin (n + 1)} (hij : i \u2264 j) :\n    p.predAbove i \u2264 q.predAbove j := by\n  trans p.predAbove j <;> gcongr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Fin/Basic.lean", "context": {"open": ["Function Nat Set"], "variables": ["{m n : \u2115}", "{\u03b1 : Type*} [Preorder \u03b1] {f : \u03b1 \u2192 Fin (n + 1)}", "{\u03b1 : Type*} [Preorder \u03b1] {f : Fin (n + 1) \u2192 \u03b1}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np q : Fin n\nhpq : p \u2264 q\ni j : Fin (n + 1)\nhij : i \u2264 j\n\u22a2 p.predAbove i \u2264 q.predAbove j"}, {"line": "trans p.predAbove j <;> gcongr", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pi_lex_lt_cons_cons {x\u2080 y\u2080 : \u03b1 0} {x y : \u2200 i : Fin n, \u03b1 i.succ}\n    (s : \u2200 {i : Fin n.succ}, \u03b1 i \u2192 \u03b1 i \u2192 Prop) :\n    Pi.Lex (\u00b7 < \u00b7) (@s) (Fin.cons x\u2080 x) (Fin.cons y\u2080 y) \u2194\n      s x\u2080 y\u2080 \u2228 x\u2080 = y\u2080 \u2227 Pi.Lex (\u00b7 < \u00b7) (@fun i : Fin n \u21a6 @s i.succ) x y := by\n  simp_rw [Pi.Lex, Fin.exists_fin_succ, Fin.cons_succ, Fin.cons_zero, Fin.forall_iff_succ]\n  simp [and_assoc, exists_and_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Fin/Tuple.lean", "context": {"open": ["Function Set"], "variables": ["{m n : \u2115} {\u03b1 : Fin (n + 1) \u2192 Type*} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_1\nx\u2080 y\u2080 : \u03b1 0\nx y : (i : Fin n) \u2192 \u03b1 i.succ\ns : {i : Fin n.succ} \u2192 \u03b1 i \u2192 \u03b1 i \u2192 Prop\n\u22a2 Pi.Lex (fun x1 x2 => x1 < x2) s (Fin.cons x\u2080 x) (Fin.cons y\u2080 y) \u2194\n    s x\u2080 y\u2080 \u2228 x\u2080 = y\u2080 \u2227 Pi.Lex (fun x1 x2 => x1 < x2) (fun i => s) x y"}, {"line": "simp_rw [Pi.Lex, Fin.exists_fin_succ, Fin.cons_succ, Fin.cons_zero, Fin.forall_iff_succ]", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_1\nx\u2080 y\u2080 : \u03b1 0\nx y : (i : Fin n) \u2192 \u03b1 i.succ\ns : {i : Fin n.succ} \u2192 \u03b1 i \u2192 \u03b1 i \u2192 Prop\n\u22a2 (((0 < 0 \u2192 Fin.cons x\u2080 x 0 = Fin.cons y\u2080 y 0) \u2227\n          \u2200 (i : Fin n), i.succ < 0 \u2192 Fin.cons x\u2080 x i.succ = Fin.cons y\u2080 y i.succ) \u2227\n        s x\u2080 y\u2080 \u2228\n      \u2203 i,\n        ((0 < i.succ \u2192 Fin.cons x\u2080 x 0 = Fin.cons y\u2080 y 0) \u2227\n            \u2200 (i_1 : Fin n), i_1.succ < i.succ \u2192 Fin.cons x\u2080 x i_1.succ = Fin.cons y\u2080 y i_1.succ) \u2227\n          s (x i) (y i)) \u2194\n    s x\u2080 y\u2080 \u2228 x\u2080 = y\u2080 \u2227 \u2203 i, (\u2200 j < i, x j = y j) \u2227 s (x i) (y i)"}, {"line": "simp [and_assoc, exists_and_left]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma monotone_vecCons : Monotone (vecCons a f) \u2194 a \u2264 f 0 \u2227 Monotone f := by\n  simpa only [monotone_iff_forall_lt] using @liftFun_vecCons \u03b1 n (\u00b7 \u2264 \u00b7) _ f a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Fin/Tuple.lean", "context": {"open": ["Function Set", "Set Fin Matrix Function", "scoped Relator in"], "variables": ["{m n : \u2115} {\u03b1 : Fin (n + 1) \u2192 Type*} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ)", "[\u2200 i, Preorder (\u03b1 i)]", "{\u03b1 : Type*}", "[Preorder \u03b1] {n : \u2115} {f : Fin (n + 1) \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : ?m.1562\ninst\u271d\u00b2 : ?m.2068 \u2192 Preorder sorry\n\u03b1\u271d : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\u271d\nn\u271d : \u2115\nf\u271d : Fin (n\u271d + 1) \u2192 \u03b1\u271d\na\u271d : \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nn : \u2115\nf : Fin (n + 1) \u2192 \u03b1\na : \u03b1\n\u22a2 Monotone (vecCons a f) \u2194 a \u2264 f 0 \u2227 Monotone f"}, {"line": "simpa only [monotone_iff_forall_lt] using @liftFun_vecCons \u03b1 n (\u00b7 \u2264 \u00b7) _ f a", "tactic_state": "No Goals!"}]}
{"declaration": "lemma finSuccAboveOrderIso_symm_apply_last (x : { x : Fin (n + 1) // x \u2260 Fin.last n }) :\n    (finSuccAboveOrderIso (Fin.last n)).symm x = Fin.castLT x.1 (Fin.val_lt_last x.2) := by\n  rw [\u2190 Option.some_inj]\n  simp [finSuccAboveOrderIso, finSuccAboveEquiv, OrderIso.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Fin/Tuple.lean", "context": {"open": ["Function Set", "Set Fin Matrix Function", "scoped Relator in"], "variables": ["{m n : \u2115} {\u03b1 : Fin (n + 1) \u2192 Type*} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ)", "[\u2200 i, Preorder (\u03b1 i)]", "{\u03b1 : Type*}", "[Preorder \u03b1] {n : \u2115} {f : Fin (n + 1) \u2192 \u03b1} {a : \u03b1}", "{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : ?m.2087\ninst\u271d\u00b9 : ?m.2595 \u2192 Preorder sorry\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nn\u271d\u00b9 : \u2115\nf : Fin (n\u271d\u00b9 + 1) \u2192 \u03b1\na : \u03b1\nn\u271d n : \u2115\nx : { x // x \u2260 last n }\n\u22a2 (finSuccAboveOrderIso (last n)).symm x = (\u2191x).castLT \u22ef"}, {"line": "rw [\u2190 Option.some_inj]", "tactic_state": "\u03b1\u271d : ?m.2087\ninst\u271d\u00b9 : ?m.2595 \u2192 Preorder sorry\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nn\u271d\u00b9 : \u2115\nf : Fin (n\u271d\u00b9 + 1) \u2192 \u03b1\na : \u03b1\nn\u271d n : \u2115\nx : { x // x \u2260 last n }\n\u22a2 some ((finSuccAboveOrderIso (last n)).symm x) = some ((\u2191x).castLT \u22ef)"}, {"line": "simp [finSuccAboveOrderIso, finSuccAboveEquiv, OrderIso.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma finSuccAboveOrderIso_symm_apply_ne_last {p : Fin (n + 1)} (h : p \u2260 Fin.last n)\n    (x : { x : Fin (n + 1) // x \u2260 p }) :\n    (finSuccAboveEquiv p).symm x = (p.castLT (Fin.val_lt_last h)).predAbove x := by\n  rw [\u2190 Option.some_inj]\n  simpa [finSuccAboveEquiv, OrderIso.symm] using finSuccEquiv'_ne_last_apply h x.property\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Fin/Tuple.lean", "context": {"open": ["Function Set", "Set Fin Matrix Function", "scoped Relator in"], "variables": ["{m n : \u2115} {\u03b1 : Fin (n + 1) \u2192 Type*} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ)", "[\u2200 i, Preorder (\u03b1 i)]", "{\u03b1 : Type*}", "[Preorder \u03b1] {n : \u2115} {f : Fin (n + 1) \u2192 \u03b1} {a : \u03b1}", "{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : ?m.2087\ninst\u271d\u00b9 : ?m.2595 \u2192 Preorder sorry\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nn\u271d\u00b9 : \u2115\nf : Fin (n\u271d\u00b9 + 1) \u2192 \u03b1\na : \u03b1\nn\u271d n : \u2115\np : Fin (n + 1)\nh : p \u2260 last n\nx : { x // x \u2260 p }\n\u22a2 (finSuccAboveEquiv p).symm x = (p.castLT \u22ef).predAbove \u2191x"}, {"line": "rw [\u2190 Option.some_inj]", "tactic_state": "\u03b1\u271d : ?m.2087\ninst\u271d\u00b9 : ?m.2595 \u2192 Preorder sorry\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nn\u271d\u00b9 : \u2115\nf : Fin (n\u271d\u00b9 + 1) \u2192 \u03b1\na : \u03b1\nn\u271d n : \u2115\np : Fin (n + 1)\nh : p \u2260 last n\nx : { x // x \u2260 p }\n\u22a2 some ((finSuccAboveEquiv p).symm x) = some ((p.castLT \u22ef).predAbove \u2191x)"}, {"line": "simpa [finSuccAboveEquiv, OrderIso.symm] using finSuccEquiv'_ne_last_apply h x.property", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : Prop) : (a \u2227 b \u2228 \u00ac(a \u2227 b)) \u2227 ((a \u2228 b) \u2228 \u00ac(a \u2228 b)) \u2192 a \u2228 \u00aca := by\n  rintro \u27e8\u27e8ha, _\u27e9 | hnab, (ha | hb) | hnab\u27e9 <;> try exact Or.inl ha\n  \u00b7 exact Or.inr fun ha => hnab \u27e8ha, hb\u27e9\n  \u00b7 exact Or.inr fun ha => hnab <| Or.inl ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Boundary.lean", "context": {"open": ["Heyting"], "variables": ["{\u03b1 : Type*}", "[CoheytingAlgebra \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CoheytingAlgebra \u03b1\na\u271d b\u271d : \u03b1\na b : Prop\n\u22a2 (a \u2227 b \u2228 \u00ac(a \u2227 b)) \u2227 ((a \u2228 b) \u2228 \u00ac(a \u2228 b)) \u2192 a \u2228 \u00aca"}, {"line": "rintro \u27e8\u27e8ha, _\u27e9 | hnab, (ha | hb) | hnab\u27e9 <;> try exact Or.inl ha", "tactic_state": "case intro.inr.inl.inr\n\u03b1 : Type u_1\ninst\u271d : CoheytingAlgebra \u03b1\na\u271d b\u271d : \u03b1\na b : Prop\nhnab : \u00ac(a \u2227 b)\nhb : b\n\u22a2 a \u2228 \u00aca\n---\ncase intro.inr.inr\n\u03b1 : Type u_1\ninst\u271d : CoheytingAlgebra \u03b1\na\u271d b\u271d : \u03b1\na b : Prop\nhnab\u271d : \u00ac(a \u2227 b)\nhnab : \u00ac(a \u2228 b)\n\u22a2 a \u2228 \u00aca"}, {"line": "\u00b7 exact Or.inr fun ha => hnab \u27e8ha, hb\u27e9", "tactic_state": "case intro.inr.inr\n\u03b1 : Type u_1\ninst\u271d : CoheytingAlgebra \u03b1\na\u271d b\u271d : \u03b1\na b : Prop\nhnab\u271d : \u00ac(a \u2227 b)\nhnab : \u00ac(a \u2228 b)\n\u22a2 a \u2228 \u00aca"}, {"line": "\u00b7 exact Or.inr fun ha => hnab <| Or.inl ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_himp_iff' : a \u2264 b \u21e8 c \u2194 b \u2293 a \u2264 c := by rw [le_himp_iff, inf_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \u2264 b \u21e8 c \u2194 b \u2293 a \u2264 c"}, {"line": "rw [le_himp_iff, inf_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_himp_comm : a \u2264 b \u21e8 c \u2194 b \u2264 a \u21e8 c := by rw [le_himp_iff, le_himp_iff']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \u2264 b \u21e8 c \u2194 b \u2264 a \u21e8 c"}, {"line": "rw [le_himp_iff, le_himp_iff']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_himp_iff_left : a \u2264 a \u21e8 b \u2194 a \u2264 b := by rw [le_himp_iff, inf_idem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b : \u03b1\n\u22a2 a \u2264 a \u21e8 b \u2194 a \u2264 b"}, {"line": "rw [le_himp_iff, inf_idem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_himp_le : a \u2293 (a \u21e8 b) \u2264 b := by rw [inf_comm, \u2190 le_himp_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b : \u03b1\n\u22a2 a \u2293 (a \u21e8 b) \u2264 b"}, {"line": "rw [inf_comm, \u2190 le_himp_iff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b : \u03b1\n\u22a2 a \u21e8 b \u2264 a \u21e8 b"}]}
{"declaration": "theorem himp_inf_self (a b : \u03b1) : (a \u21e8 b) \u2293 a = b \u2293 a := by rw [inf_comm, inf_himp, inf_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b : \u03b1\n\u22a2 (a \u21e8 b) \u2293 a = b \u2293 a"}, {"line": "rw [inf_comm, inf_himp, inf_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem himp_le_himp_himp_himp : b \u21e8 c \u2264 (a \u21e8 b) \u21e8 a \u21e8 c := by\n  rw [le_himp_iff]\n  rw [le_himp_iff]\n  rw [inf_assoc]\n  rw [himp_inf_self]\n  rw [\u2190 inf_assoc]\n  rw [himp_inf_self]\n  rw [inf_assoc]\n  exact inf_le_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 b \u21e8 c \u2264 (a \u21e8 b) \u21e8 a \u21e8 c"}, {"line": "rw [le_himp_iff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 (b \u21e8 c) \u2293 (a \u21e8 b) \u2264 a \u21e8 c"}, {"line": "rw [le_himp_iff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 (b \u21e8 c) \u2293 (a \u21e8 b) \u2293 a \u2264 c"}, {"line": "rw [inf_assoc]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 (b \u21e8 c) \u2293 ((a \u21e8 b) \u2293 a) \u2264 c"}, {"line": "rw [himp_inf_self]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 (b \u21e8 c) \u2293 (b \u2293 a) \u2264 c"}, {"line": "rw [\u2190 inf_assoc]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 (b \u21e8 c) \u2293 b \u2293 a \u2264 c"}, {"line": "rw [himp_inf_self]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 c \u2293 b \u2293 a \u2264 c"}, {"line": "rw [inf_assoc]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 c \u2293 (b \u2293 a) \u2264 c"}, {"line": "exact inf_le_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem himp_inf_himp_inf_le : (b \u21e8 c) \u2293 (a \u21e8 b) \u2293 a \u2264 c := by\n  simpa using @himp_le_himp_himp_himp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 (b \u21e8 c) \u2293 (a \u21e8 b) \u2293 a \u2264 c"}, {"line": "simpa using @himp_le_himp_himp_himp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem himp_left_comm (a b c : \u03b1) : a \u21e8 b \u21e8 c = b \u21e8 a \u21e8 c := by simp_rw [himp_himp, inf_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \u21e8 b \u21e8 c = b \u21e8 a \u21e8 c"}, {"line": "simp_rw [himp_himp, inf_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem himp_idem : b \u21e8 b \u21e8 a = b \u21e8 a := by rw [himp_himp, inf_idem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b : \u03b1\n\u22a2 b \u21e8 b \u21e8 a = b \u21e8 a"}, {"line": "rw [himp_himp, inf_idem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem himp_triangle (a b c : \u03b1) : (a \u21e8 b) \u2293 (b \u21e8 c) \u2264 a \u21e8 c := by\n  rw [le_himp_iff]\n  rw [inf_right_comm]\n  rw [\u2190 le_himp_iff]\n  exact himp_inf_le.trans le_himp_himp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 (a \u21e8 b) \u2293 (b \u21e8 c) \u2264 a \u21e8 c"}, {"line": "rw [le_himp_iff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 (a \u21e8 b) \u2293 (b \u21e8 c) \u2293 a \u2264 c"}, {"line": "rw [inf_right_comm]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 (a \u21e8 b) \u2293 a \u2293 (b \u21e8 c) \u2264 c"}, {"line": "rw [\u2190 le_himp_iff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 (a \u21e8 b) \u2293 a \u2264 (b \u21e8 c) \u21e8 c"}, {"line": "exact himp_inf_le.trans le_himp_himp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sdiff_le_comm : a \\ b \u2264 c \u2194 a \\ c \u2264 b := by rw [sdiff_le_iff, sdiff_le_iff']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}", "[GeneralizedCoheytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \\ b \u2264 c \u2194 a \\ c \u2264 b"}, {"line": "rw [sdiff_le_iff, sdiff_le_iff']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sdiff_le_iff_left : a \\ b \u2264 b \u2194 a \u2264 b := by rw [sdiff_le_iff, sup_idem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}", "[GeneralizedCoheytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 a \\ b \u2264 b \u2194 a \u2264 b"}, {"line": "rw [sdiff_le_iff, sup_idem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_sdiff_sup : a \u2264 a \\ b \u2294 b := by rw [sup_comm, \u2190 sdiff_le_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}", "[GeneralizedCoheytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 a \u2264 a \\ b \u2294 b"}, {"line": "rw [sup_comm, \u2190 sdiff_le_iff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 a \\ b \u2264 a \\ b"}]}
{"declaration": "theorem sdiff_sup_self (a b : \u03b1) : b \\ a \u2294 a = b \u2294 a := by rw [sup_comm, sup_sdiff_self, sup_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}", "[GeneralizedCoheytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 b \\ a \u2294 a = b \u2294 a"}, {"line": "rw [sup_comm, sup_sdiff_self, sup_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sdiff_eq_bot_iff : a \\ b = \u22a5 \u2194 a \u2264 b := by rw [\u2190 le_bot_iff, sdiff_le_iff, sup_bot_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}", "[GeneralizedCoheytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 a \\ b = \u22a5 \u2194 a \u2264 b"}, {"line": "rw [\u2190 le_bot_iff, sdiff_le_iff, sup_bot_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sdiff_sdiff_sdiff_le_sdiff : (a \\ b) \\ (a \\ c) \u2264 c \\ b := by\n  rw [sdiff_le_iff]\n  rw [sdiff_le_iff]\n  rw [sup_left_comm]\n  rw [sup_sdiff_self]\n  rw [sup_left_comm]\n  rw [sdiff_sup_self]\n  rw [sup_left_comm]\n  exact le_sup_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}", "[GeneralizedCoheytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 (a \\ b) \\ (a \\ c) \u2264 c \\ b"}, {"line": "rw [sdiff_le_iff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \\ b \u2264 a \\ c \u2294 c \\ b"}, {"line": "rw [sdiff_le_iff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \u2264 b \u2294 (a \\ c \u2294 c \\ b)"}, {"line": "rw [sup_left_comm]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \u2264 a \\ c \u2294 (b \u2294 c \\ b)"}, {"line": "rw [sup_sdiff_self]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \u2264 a \\ c \u2294 (b \u2294 c)"}, {"line": "rw [sup_left_comm]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \u2264 b \u2294 (a \\ c \u2294 c)"}, {"line": "rw [sdiff_sup_self]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \u2264 b \u2294 (a \u2294 c)"}, {"line": "rw [sup_left_comm]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \u2264 a \u2294 (b \u2294 c)"}, {"line": "exact le_sup_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_sup_sdiff_sup_sdiff : a \u2264 b \u2294 (a \\ c \u2294 c \\ b) := by\n  simpa using @sdiff_sdiff_sdiff_le_sdiff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}", "[GeneralizedCoheytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \u2264 b \u2294 (a \\ c \u2294 c \\ b)"}, {"line": "simpa using @sdiff_sdiff_sdiff_le_sdiff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sdiff_right_comm (a b c : \u03b1) : (a \\ b) \\ c = (a \\ c) \\ b := by\n  simp_rw [sdiff_sdiff, sup_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}", "[GeneralizedCoheytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 (a \\ b) \\ c = (a \\ c) \\ b"}, {"line": "simp_rw [sdiff_sdiff, sup_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sdiff_idem : (a \\ b) \\ b = a \\ b := by rw [sdiff_sdiff_left, sup_idem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}", "[GeneralizedCoheytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 (a \\ b) \\ b = a \\ b"}, {"line": "rw [sdiff_sdiff_left, sup_idem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sdiff_sdiff_self : (a \\ b) \\ a = \u22a5 := by rw [sdiff_sdiff_comm, sdiff_self, bot_sdiff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}", "[GeneralizedCoheytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 (a \\ b) \\ a = \u22a5"}, {"line": "rw [sdiff_sdiff_comm, sdiff_self, bot_sdiff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_sdiff_right_self : (a \u2294 b) \\ b = a \\ b := by rw [sup_sdiff, sdiff_self, sup_bot_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}", "[GeneralizedCoheytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 (a \u2294 b) \\ b = a \\ b"}, {"line": "rw [sup_sdiff, sdiff_self, sup_bot_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_sdiff_left_self : (a \u2294 b) \\ a = b \\ a := by rw [sup_comm, sup_sdiff_right_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}", "[GeneralizedCoheytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 (a \u2294 b) \\ a = b \\ a"}, {"line": "rw [sup_comm, sup_sdiff_right_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sdiff_inf_self_left (a b : \u03b1) : a \\ (a \u2293 b) = a \\ b := by\n  rw [sdiff_inf]\n  rw [sdiff_self]\n  rw [bot_sup_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}", "[GeneralizedCoheytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 a \\ (a \u2293 b) = a \\ b"}, {"line": "rw [sdiff_inf]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 a \\ a \u2294 a \\ b = a \\ b"}, {"line": "rw [sdiff_self]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 \u22a5 \u2294 a \\ b = a \\ b"}, {"line": "rw [bot_sup_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sdiff_inf_self_right (a b : \u03b1) : b \\ (a \u2293 b) = b \\ a := by\n  rw [sdiff_inf]\n  rw [sdiff_self]\n  rw [sup_bot_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}", "[GeneralizedCoheytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 b \\ (a \u2293 b) = b \\ a"}, {"line": "rw [sdiff_inf]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 b \\ a \u2294 b \\ b = b \\ a"}, {"line": "rw [sdiff_self]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 b \\ a \u2294 \u22a5 = b \\ a"}, {"line": "rw [sup_bot_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sdiff_triangle (a b c : \u03b1) : a \\ c \u2264 a \\ b \u2294 b \\ c := by\n  rw [sdiff_le_iff]\n  rw [sup_left_comm]\n  rw [\u2190 sdiff_le_iff]\n  exact sdiff_sdiff_le.trans le_sup_sdiff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}", "[GeneralizedCoheytingAlgebra \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \\ c \u2264 a \\ b \u2294 b \\ c"}, {"line": "rw [sdiff_le_iff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \u2264 c \u2294 (a \\ b \u2294 b \\ c)"}, {"line": "rw [sup_left_comm]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \u2264 a \\ b \u2294 (c \u2294 b \\ c)"}, {"line": "rw [\u2190 sdiff_le_iff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c : \u03b1\n\u22a2 a \\ (a \\ b) \u2264 c \u2294 b \\ c"}, {"line": "exact sdiff_sdiff_le.trans le_sup_sdiff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_bot : (\u22a5 : \u03b1)\u1d9c = \u22a4 := by rw [\u2190 himp_bot, himp_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}", "[GeneralizedCoheytingAlgebra \u03b1] {a b c d : \u03b1}", "[HeytingAlgebra \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d\u00b9 : GeneralizedCoheytingAlgebra \u03b1\ninst\u271d : HeytingAlgebra \u03b1\n\u22a2 \u22a5\u1d9c = \u22a4"}, {"line": "rw [\u2190 himp_bot, himp_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hnot_top : \uffe2(\u22a4 : \u03b1) = \u22a5 := by rw [\u2190 top_sdiff', sdiff_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2)", "{\u03c0 : \u03b9 \u2192 Type*}", "[GeneralizedHeytingAlgebra \u03b1] {a b c d : \u03b1}", "[GeneralizedCoheytingAlgebra \u03b1] {a b c d : \u03b1}", "[HeytingAlgebra \u03b1] {a b : \u03b1}", "[CoheytingAlgebra \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d\u00b2 : GeneralizedCoheytingAlgebra \u03b1\ninst\u271d\u00b9 : HeytingAlgebra \u03b1\ninst\u271d : CoheytingAlgebra \u03b1\n\u22a2 \uffe2\u22a4 = \u22a5"}, {"line": "rw [\u2190 top_sdiff', sdiff_self]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : GeneralizedHeytingAlgebra \u03b1\ninst\u271d\u00b2 : GeneralizedCoheytingAlgebra \u03b1\ninst\u271d\u00b9 : HeytingAlgebra \u03b1\ninst\u271d : CoheytingAlgebra \u03b1\n\u22a2 \u22a5 = \u22a5"}]}
{"declaration": "theorem map_compl (a : \u03b1) : f a\u1d9c = (f a)\u1d9c := by rw [\u2190 himp_bot, \u2190 himp_bot, map_himp, map_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Hom.lean", "context": {"open": ["Function", "scoped symmDiff"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[FunLike F \u03b1 \u03b2]", "[EquivLike F \u03b1 \u03b2]", "[FunLike F \u03b1 \u03b2]", "[HeytingAlgebra \u03b1] [HeytingAlgebra \u03b2] [HeytingHomClass F \u03b1 \u03b2] (f : F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2075 : FunLike F \u03b1 \u03b2\ninst\u271d\u2074 : EquivLike F \u03b1 \u03b2\ninst\u271d\u00b3 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b2 : HeytingAlgebra \u03b1\ninst\u271d\u00b9 : HeytingAlgebra \u03b2\ninst\u271d : HeytingHomClass F \u03b1 \u03b2\nf : F\na : \u03b1\n\u22a2 f a\u1d9c = (f a)\u1d9c"}, {"line": "rw [\u2190 himp_bot, \u2190 himp_bot, map_himp, map_bot]", "tactic_state": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2075 : FunLike F \u03b1 \u03b2\ninst\u271d\u2074 : EquivLike F \u03b1 \u03b2\ninst\u271d\u00b3 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b2 : HeytingAlgebra \u03b1\ninst\u271d\u00b9 : HeytingAlgebra \u03b2\ninst\u271d : HeytingHomClass F \u03b1 \u03b2\nf : F\na : \u03b1\n\u22a2 BotHomClass F \u03b1 \u03b2\n---\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2075 : FunLike F \u03b1 \u03b2\ninst\u271d\u2074 : EquivLike F \u03b1 \u03b2\ninst\u271d\u00b3 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b2 : HeytingAlgebra \u03b1\ninst\u271d\u00b9 : HeytingAlgebra \u03b2\ninst\u271d : HeytingHomClass F \u03b1 \u03b2\nf : F\na : \u03b1\n\u22a2 HeytingHomClass F \u03b1 \u03b2"}]}
{"declaration": "theorem map_hnot (a : \u03b1) : f (\uffe2a) = \uffe2f a := by rw [\u2190 top_sdiff', \u2190 top_sdiff', map_sdiff, map_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Heyting/Hom.lean", "context": {"open": ["Function", "scoped symmDiff", "scoped symmDiff"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[FunLike F \u03b1 \u03b2]", "[EquivLike F \u03b1 \u03b2]", "[FunLike F \u03b1 \u03b2]", "[HeytingAlgebra \u03b1] [HeytingAlgebra \u03b2] [HeytingHomClass F \u03b1 \u03b2] (f : F)", "[CoheytingAlgebra \u03b1] [CoheytingAlgebra \u03b2] [CoheytingHomClass F \u03b1 \u03b2] (f : F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2078 : FunLike F \u03b1 \u03b2\ninst\u271d\u2077 : EquivLike F \u03b1 \u03b2\ninst\u271d\u2076 : FunLike F \u03b1 \u03b2\ninst\u271d\u2075 : HeytingAlgebra \u03b1\ninst\u271d\u2074 : HeytingAlgebra \u03b2\ninst\u271d\u00b3 : HeytingHomClass F \u03b1 \u03b2\ninst\u271d\u00b2 : CoheytingAlgebra \u03b1\ninst\u271d\u00b9 : CoheytingAlgebra \u03b2\ninst\u271d : CoheytingHomClass F \u03b1 \u03b2\nf : F\na : \u03b1\n\u22a2 f (\uffe2a) = \uffe2f a"}, {"line": "rw [\u2190 top_sdiff', \u2190 top_sdiff', map_sdiff, map_top]", "tactic_state": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2078 : FunLike F \u03b1 \u03b2\ninst\u271d\u2077 : EquivLike F \u03b1 \u03b2\ninst\u271d\u2076 : FunLike F \u03b1 \u03b2\ninst\u271d\u2075 : HeytingAlgebra \u03b1\ninst\u271d\u2074 : HeytingAlgebra \u03b2\ninst\u271d\u00b3 : HeytingHomClass F \u03b1 \u03b2\ninst\u271d\u00b2 : CoheytingAlgebra \u03b1\ninst\u271d\u00b9 : CoheytingAlgebra \u03b2\ninst\u271d : CoheytingHomClass F \u03b1 \u03b2\nf : F\na : \u03b1\n\u22a2 TopHomClass F \u03b1 \u03b2\n---\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2078 : FunLike F \u03b1 \u03b2\ninst\u271d\u2077 : EquivLike F \u03b1 \u03b2\ninst\u271d\u2076 : FunLike F \u03b1 \u03b2\ninst\u271d\u2075 : HeytingAlgebra \u03b1\ninst\u271d\u2074 : HeytingAlgebra \u03b2\ninst\u271d\u00b3 : HeytingHomClass F \u03b1 \u03b2\ninst\u271d\u00b2 : CoheytingAlgebra \u03b1\ninst\u271d\u00b9 : CoheytingAlgebra \u03b2\ninst\u271d : CoheytingHomClass F \u03b1 \u03b2\nf : F\na : \u03b1\n\u22a2 CoheytingHomClass F \u03b1 \u03b2"}]}
{"declaration": "theorem map_inv_le_iff (f : F) {a : \u03b1} {b : \u03b2} : EquivLike.inv f b \u2264 a \u2194 b \u2264 f a := by\n  convert (map_le_map_iff f).symm\n  exact (EquivLike.right_inv f _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Hom/Basic.lean", "context": {"open": ["OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[Preorder \u03b1] [Preorder \u03b2] [FunLike F \u03b1 \u03b2] [OrderHomClass F \u03b1 \u03b2]", "[LE \u03b1] [LE \u03b2] [EquivLike F \u03b1 \u03b2] [OrderIsoClass F \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : FunLike F \u03b1 \u03b2\ninst\u271d\u2074 : OrderHomClass F \u03b1 \u03b2\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LE \u03b2\ninst\u271d\u00b9 : EquivLike F \u03b1 \u03b2\ninst\u271d : OrderIsoClass F \u03b1 \u03b2\nf : F\na : \u03b1\nb : \u03b2\n\u22a2 EquivLike.inv f b \u2264 a \u2194 b \u2264 f a"}, {"line": "convert (map_le_map_iff f).symm", "tactic_state": "case h.e'_2.h.e'_3\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : FunLike F \u03b1 \u03b2\ninst\u271d\u2074 : OrderHomClass F \u03b1 \u03b2\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LE \u03b2\ninst\u271d\u00b9 : EquivLike F \u03b1 \u03b2\ninst\u271d : OrderIsoClass F \u03b1 \u03b2\nf : F\na : \u03b1\nb : \u03b2\n\u22a2 b = f (EquivLike.inv f b)\n---\ncase h.e'_2.h.e'_4.h.e'_4\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : FunLike F \u03b1 \u03b2\ninst\u271d\u2074 : OrderHomClass F \u03b1 \u03b2\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LE \u03b2\ninst\u271d\u00b9 : EquivLike F \u03b1 \u03b2\ninst\u271d : OrderIsoClass F \u03b1 \u03b2\nf : F\na : \u03b1\nb : \u03b2\n\u22a2 inst\u271d\u2075 = EquivLike.toFunLike\n---\ncase convert_5\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : FunLike F \u03b1 \u03b2\ninst\u271d\u2074 : OrderHomClass F \u03b1 \u03b2\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LE \u03b2\ninst\u271d\u00b9 : EquivLike F \u03b1 \u03b2\ninst\u271d : OrderIsoClass F \u03b1 \u03b2\nf : F\na : \u03b1\nb : \u03b2\n\u22a2 EquivLike F \u03b1 \u03b2\n---\ncase convert_6\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : FunLike F \u03b1 \u03b2\ninst\u271d\u2074 : OrderHomClass F \u03b1 \u03b2\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LE \u03b2\ninst\u271d\u00b9 : EquivLike F \u03b1 \u03b2\ninst\u271d : OrderIsoClass F \u03b1 \u03b2\nf : F\na : \u03b1\nb : \u03b2\n\u22a2 OrderIsoClass F \u03b1 \u03b2"}, {"line": "exact (EquivLike.right_inv f _).symm", "tactic_state": "case h.e'_2.h.e'_4.h.e'_4\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : FunLike F \u03b1 \u03b2\ninst\u271d\u2074 : OrderHomClass F \u03b1 \u03b2\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LE \u03b2\ninst\u271d\u00b9 : EquivLike F \u03b1 \u03b2\ninst\u271d : OrderIsoClass F \u03b1 \u03b2\nf : F\na : \u03b1\nb : \u03b2\n\u22a2 inst\u271d\u2075 = EquivLike.toFunLike\n---\ncase convert_5\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : FunLike F \u03b1 \u03b2\ninst\u271d\u2074 : OrderHomClass F \u03b1 \u03b2\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LE \u03b2\ninst\u271d\u00b9 : EquivLike F \u03b1 \u03b2\ninst\u271d : OrderIsoClass F \u03b1 \u03b2\nf : F\na : \u03b1\nb : \u03b2\n\u22a2 EquivLike F \u03b1 \u03b2\n---\ncase convert_6\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : FunLike F \u03b1 \u03b2\ninst\u271d\u2074 : OrderHomClass F \u03b1 \u03b2\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LE \u03b2\ninst\u271d\u00b9 : EquivLike F \u03b1 \u03b2\ninst\u271d : OrderIsoClass F \u03b1 \u03b2\nf : F\na : \u03b1\nb : \u03b2\n\u22a2 OrderIsoClass F \u03b1 \u03b2"}]}
{"declaration": "theorem ofRelIsoLT_toRelIsoLT {\u03b1 \u03b2} [PartialOrder \u03b1] [PartialOrder \u03b2] (e : \u03b1 \u2243o \u03b2) :\n    ofRelIsoLT (toRelIsoLT e) = e := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Hom/Basic.lean", "context": {"open": ["OrderDual", "Set"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[Preorder \u03b1] [Preorder \u03b2] [FunLike F \u03b1 \u03b2] [OrderHomClass F \u03b1 \u03b2]", "[LE \u03b1] [LE \u03b2] [EquivLike F \u03b1 \u03b2] [OrderIsoClass F \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2] [EquivLike F \u03b1 \u03b2] [OrderIsoClass F \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] [Preorder \u03b4]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, Preorder (\u03c0 i)]", "[Preorder \u03b1] [Preorder \u03b2] (f : \u03b1 \u21aao \u03b2)", "[PartialOrder \u03b1] [PartialOrder \u03b2] (f : OrderEmbedding \u03b1 \u03b2)", "[PartialOrder \u03b1] [Preorder \u03b2]", "(f : ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u2192r ((\u00b7 < \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop))", "[LE \u03b1] [LE \u03b2] [LE \u03b3]", "(\u03b1)", "{\u03b1}", "[LE \u03b1] [LE \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_8\nofRelIsoLT : x\u271d\n\u03b1 : Type u_9\n\u03b2 : Type u_10\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PartialOrder \u03b2\ne : \u03b1 \u2243o \u03b2\n\u22a2 sorry = e"}, {"line": "ext", "tactic_state": "case h\nx\u271d\u00b9 : Sort u_8\nofRelIsoLT : x\u271d\u00b9\n\u03b1 : Type u_9\n\u03b2 : Type u_10\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PartialOrder \u03b2\ne : \u03b1 \u2243o \u03b2\nx\u271d : \u03b1\n\u22a2 sorry x\u271d = e x\u271d"}, {"line": "simp", "tactic_state": "case h\nx\u271d\u00b9 : Sort u_8\nofRelIsoLT : x\u271d\u00b9\n\u03b1 : Type u_9\n\u03b2 : Type u_10\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PartialOrder \u03b2\ne : \u03b1 \u2243o \u03b2\nx\u271d : \u03b1\n\u22a2 (sorry ()) x\u271d = e x\u271d"}]}
{"declaration": "theorem toRelIsoLT_ofRelIsoLT {\u03b1 \u03b2} [PartialOrder \u03b1] [PartialOrder \u03b2]\n    (e : ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u2243r ((\u00b7 < \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop)) : toRelIsoLT (ofRelIsoLT e) = e := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Hom/Basic.lean", "context": {"open": ["OrderDual", "Set"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[Preorder \u03b1] [Preorder \u03b2] [FunLike F \u03b1 \u03b2] [OrderHomClass F \u03b1 \u03b2]", "[LE \u03b1] [LE \u03b2] [EquivLike F \u03b1 \u03b2] [OrderIsoClass F \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2] [EquivLike F \u03b1 \u03b2] [OrderIsoClass F \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] [Preorder \u03b4]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, Preorder (\u03c0 i)]", "[Preorder \u03b1] [Preorder \u03b2] (f : \u03b1 \u21aao \u03b2)", "[PartialOrder \u03b1] [PartialOrder \u03b2] (f : OrderEmbedding \u03b1 \u03b2)", "[PartialOrder \u03b1] [Preorder \u03b2]", "(f : ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u2192r ((\u00b7 < \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop))", "[LE \u03b1] [LE \u03b2] [LE \u03b3]", "(\u03b1)", "{\u03b1}", "[LE \u03b1] [LE \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_8\ntoRelIsoLT : x\u271d\n\u03b1 : Type u_9\n\u03b2 : Type u_10\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PartialOrder \u03b2\ne : (fun x1 x2 => x1 < x2) \u2243r fun x1 x2 => x1 < x2\n\u22a2 sorry = e"}, {"line": "ext", "tactic_state": "case h\nx\u271d\u00b9 : Sort u_8\ntoRelIsoLT : x\u271d\u00b9\n\u03b1 : Type u_9\n\u03b2 : Type u_10\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PartialOrder \u03b2\ne : (fun x1 x2 => x1 < x2) \u2243r fun x1 x2 => x1 < x2\nx\u271d : \u03b1\n\u22a2 sorry x\u271d = e x\u271d"}, {"line": "simp", "tactic_state": "case h\nx\u271d\u00b9 : Sort u_8\ntoRelIsoLT : x\u271d\u00b9\n\u03b1 : Type u_9\n\u03b2 : Type u_10\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PartialOrder \u03b2\ne : (fun x1 x2 => x1 < x2) \u2243r fun x1 x2 => x1 < x2\nx\u271d : \u03b1\n\u22a2 (sorry ()) x\u271d = e x\u271d"}]}
{"declaration": "theorem dual_map (f : \u03b1 \u2192o \u03b2) (s : Interval \u03b1) : dual (s.map f) = s.dual.map f.dual := by\n  cases s\n  \u00b7 rfl\n  \u00b7 exact WithBot.map_comm rfl _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Basic.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[LE \u03b1] {s t : NonemptyInterval \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {s : NonemptyInterval \u03b1} {x : \u03b1 \u00d7 \u03b1} {a : \u03b1}", "[BoundedOrder \u03b1]", "[PartialOrder \u03b1] [PartialOrder \u03b2] {s t : NonemptyInterval \u03b1} {a b : \u03b1}", "[Lattice \u03b1]", "[LE \u03b1]", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : BoundedOrder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b2\ninst\u271d\u00b3 : Lattice \u03b1\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d : Sort u_6\ndual : x\u271d\nf : \u03b1 \u2192o \u03b2\ns : Interval \u03b1\n\u22a2 sorry = Interval.map (OrderHom.dual f) sorry"}, {"line": "cases s", "tactic_state": "case bot\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : BoundedOrder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b2\ninst\u271d\u00b3 : Lattice \u03b1\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d : Sort u_6\ndual : x\u271d\nf : \u03b1 \u2192o \u03b2\n\u22a2 sorry = Interval.map (OrderHom.dual f) sorry\n---\ncase coe\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : BoundedOrder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b2\ninst\u271d\u00b3 : Lattice \u03b1\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d : Sort u_6\ndual : x\u271d\nf : \u03b1 \u2192o \u03b2\na\u271d : NonemptyInterval \u03b1\n\u22a2 sorry = Interval.map (OrderHom.dual f) sorry"}, {"line": "\u00b7 rfl", "tactic_state": "case coe\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : BoundedOrder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b2\ninst\u271d\u00b3 : Lattice \u03b1\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d : Sort u_6\ndual : x\u271d\nf : \u03b1 \u2192o \u03b2\na\u271d : NonemptyInterval \u03b1\n\u22a2 sorry = Interval.map (OrderHom.dual f) sorry"}, {"line": "\u00b7 exact WithBot.map_comm rfl _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nonempty_Ioi : (Ioi a).Nonempty \u2194 \u00ac IsMax a := by simp [Finset.Nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Basic.lean", "context": {"open": ["Function OrderDual", "FinsetInterval"], "variables": ["{\u03b9 \u03b1 : Type*} {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[Preorder \u03b1]", "[LocallyFiniteOrder \u03b1]", "(a)", "{a}", "(a b) [Fintype \u03b1]", "[LocallyFiniteOrderTop \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\na : \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : LocallyFiniteOrderTop \u03b1\nx\u271d : Sort u_3\nIoi : x\u271d\n\u22a2 sorry \u2194 \u00acIsMax a"}, {"line": "simp [Finset.Nonempty]", "tactic_state": "\u03b1 : Type u_2\na : \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : LocallyFiniteOrderTop \u03b1\nx\u271d : Sort u_3\nIoi : x\u271d\n\u22a2 sorry () \u2194 \u2203 b, a < b"}]}
{"declaration": "lemma nonempty_Iio : (Iio a).Nonempty \u2194 \u00ac IsMin a := by simp [Finset.Nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Basic.lean", "context": {"open": ["Function OrderDual", "FinsetInterval"], "variables": ["{\u03b9 \u03b1 : Type*} {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[Preorder \u03b1]", "[LocallyFiniteOrder \u03b1]", "(a)", "{a}", "(a b) [Fintype \u03b1]", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderBot \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\na : \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : LocallyFiniteOrderBot \u03b1\nx\u271d : Sort u_3\nIio : x\u271d\n\u22a2 sorry \u2194 \u00acIsMin a"}, {"line": "simp [Finset.Nonempty]", "tactic_state": "\u03b1 : Type u_2\na : \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : LocallyFiniteOrderBot \u03b1\nx\u271d : Sort u_3\nIio : x\u271d\n\u22a2 sorry () \u2194 \u2203 b, b < a"}]}
{"declaration": "lemma Icc_map_sectL : (Icc a b).map (.sectL _ c) = Icc (a, c) (b, c) := by\n  aesop (add safe forward [le_antisymm])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Basic.lean", "context": {"open": ["Function OrderDual", "FinsetInterval"], "variables": ["{\u03b9 \u03b1 : Type*} {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[Preorder \u03b1]", "[LocallyFiniteOrder \u03b1]", "(a)", "{a}", "(a b) [Fintype \u03b1]", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrderBot \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderBot \u03b1]", "[PartialOrder \u03b1] [LocallyFiniteOrder \u03b1] {a b c : \u03b1}", "[DecidableEq \u03b1]", "{\u03b2 : Type*}", "[Preorder \u03b1] [PartialOrder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nIcc : x\u271d\n\u22a2 sorry = sorry"}, {"line": "aesop (add safe forward [le_antisymm])", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\na\u271d\u00b2 a\u2081 a\u2082 b\u271d b\u2081 b\u2082 c\u271d x : \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2078 : Fintype \u03b1\ninst\u271d\u00b9\u2077 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrderTop \u03b1\na\u271d\u00b9 : \u03b1\ninst\u271d\u00b9\u00b2 : Fintype \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrderBot \u03b1\na\u271d : \u03b1\ninst\u271d\u00b9\u2070 : Fintype \u03b1\ninst\u271d\u2079 : LocallyFiniteOrder \u03b1\ninst\u271d\u2078 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u2077 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : LocallyFiniteOrder \u03b1\na b c : \u03b1\ninst\u271d\u2074 : DecidableEq \u03b1\n\u03b2 : Type u_3\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b2\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b2\nIcc : ?m.1604\n\u22a2 Sort u_5"}]}
{"declaration": "lemma Ioc_map_sectL : (Ioc a b).map (.sectL _ c) = Ioc (a, c) (b, c) := by\n  aesop (add safe forward [le_antisymm, le_of_lt])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Basic.lean", "context": {"open": ["Function OrderDual", "FinsetInterval"], "variables": ["{\u03b9 \u03b1 : Type*} {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[Preorder \u03b1]", "[LocallyFiniteOrder \u03b1]", "(a)", "{a}", "(a b) [Fintype \u03b1]", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrderBot \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderBot \u03b1]", "[PartialOrder \u03b1] [LocallyFiniteOrder \u03b1] {a b c : \u03b1}", "[DecidableEq \u03b1]", "{\u03b2 : Type*}", "[Preorder \u03b1] [PartialOrder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nIoc : x\u271d\n\u22a2 sorry = sorry"}, {"line": "aesop (add safe forward [le_antisymm, le_of_lt])", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\na\u271d\u00b2 a\u2081 a\u2082 b\u271d b\u2081 b\u2082 c\u271d x : \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2078 : Fintype \u03b1\ninst\u271d\u00b9\u2077 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrderTop \u03b1\na\u271d\u00b9 : \u03b1\ninst\u271d\u00b9\u00b2 : Fintype \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrderBot \u03b1\na\u271d : \u03b1\ninst\u271d\u00b9\u2070 : Fintype \u03b1\ninst\u271d\u2079 : LocallyFiniteOrder \u03b1\ninst\u271d\u2078 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u2077 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : LocallyFiniteOrder \u03b1\na b c : \u03b1\ninst\u271d\u2074 : DecidableEq \u03b1\n\u03b2 : Type u_3\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b2\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b2\nIoc : ?m.1604\n\u22a2 Sort u_5"}]}
{"declaration": "lemma Ico_map_sectL : (Ico a b).map (.sectL _ c) = Ico (a, c) (b, c) := by\n  aesop (add safe forward [le_antisymm, le_of_lt])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Basic.lean", "context": {"open": ["Function OrderDual", "FinsetInterval"], "variables": ["{\u03b9 \u03b1 : Type*} {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[Preorder \u03b1]", "[LocallyFiniteOrder \u03b1]", "(a)", "{a}", "(a b) [Fintype \u03b1]", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrderBot \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderBot \u03b1]", "[PartialOrder \u03b1] [LocallyFiniteOrder \u03b1] {a b c : \u03b1}", "[DecidableEq \u03b1]", "{\u03b2 : Type*}", "[Preorder \u03b1] [PartialOrder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nIco : x\u271d\n\u22a2 sorry = sorry"}, {"line": "aesop (add safe forward [le_antisymm, le_of_lt])", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\na\u271d\u00b2 a\u2081 a\u2082 b\u271d b\u2081 b\u2082 c\u271d x : \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2078 : Fintype \u03b1\ninst\u271d\u00b9\u2077 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrderTop \u03b1\na\u271d\u00b9 : \u03b1\ninst\u271d\u00b9\u00b2 : Fintype \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrderBot \u03b1\na\u271d : \u03b1\ninst\u271d\u00b9\u2070 : Fintype \u03b1\ninst\u271d\u2079 : LocallyFiniteOrder \u03b1\ninst\u271d\u2078 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u2077 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : LocallyFiniteOrder \u03b1\na b c : \u03b1\ninst\u271d\u2074 : DecidableEq \u03b1\n\u03b2 : Type u_3\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b2\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b2\nIco : ?m.1604\n\u22a2 Sort u_5"}]}
{"declaration": "lemma Ioo_map_sectL : (Ioo a b).map (.sectL _ c) = Ioo (a, c) (b, c) := by\n  aesop (add safe forward [le_antisymm, le_of_lt])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Basic.lean", "context": {"open": ["Function OrderDual", "FinsetInterval"], "variables": ["{\u03b9 \u03b1 : Type*} {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[Preorder \u03b1]", "[LocallyFiniteOrder \u03b1]", "(a)", "{a}", "(a b) [Fintype \u03b1]", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrderBot \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderBot \u03b1]", "[PartialOrder \u03b1] [LocallyFiniteOrder \u03b1] {a b c : \u03b1}", "[DecidableEq \u03b1]", "{\u03b2 : Type*}", "[Preorder \u03b1] [PartialOrder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nIoo : x\u271d\n\u22a2 sorry = sorry"}, {"line": "aesop (add safe forward [le_antisymm, le_of_lt])", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\na\u271d\u00b2 a\u2081 a\u2082 b\u271d b\u2081 b\u2082 c\u271d x : \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2078 : Fintype \u03b1\ninst\u271d\u00b9\u2077 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrderTop \u03b1\na\u271d\u00b9 : \u03b1\ninst\u271d\u00b9\u00b2 : Fintype \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrderBot \u03b1\na\u271d : \u03b1\ninst\u271d\u00b9\u2070 : Fintype \u03b1\ninst\u271d\u2079 : LocallyFiniteOrder \u03b1\ninst\u271d\u2078 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u2077 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : LocallyFiniteOrder \u03b1\na b c : \u03b1\ninst\u271d\u2074 : DecidableEq \u03b1\n\u03b2 : Type u_3\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b2\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b2\nIoo : ?m.1604\n\u22a2 Sort u_5"}]}
{"declaration": "lemma Icc_map_sectR : (Icc a b).map (.sectR c _) = Icc (c, a) (c, b) := by\n  aesop (add safe forward [le_antisymm])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Basic.lean", "context": {"open": ["Function OrderDual", "FinsetInterval"], "variables": ["{\u03b9 \u03b1 : Type*} {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[Preorder \u03b1]", "[LocallyFiniteOrder \u03b1]", "(a)", "{a}", "(a b) [Fintype \u03b1]", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrderBot \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderBot \u03b1]", "[PartialOrder \u03b1] [LocallyFiniteOrder \u03b1] {a b c : \u03b1}", "[DecidableEq \u03b1]", "{\u03b2 : Type*}", "[Preorder \u03b1] [PartialOrder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]", "[PartialOrder \u03b1] [Preorder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nIcc : x\u271d\n\u22a2 sorry = sorry"}, {"line": "aesop (add safe forward [le_antisymm])", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\na\u271d\u00b2 a\u2081 a\u2082 b\u271d b\u2081 b\u2082 c\u271d x : \u03b1\ninst\u271d\u00b2\u2074 : Preorder \u03b1\ninst\u271d\u00b2\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u00b2 : Fintype \u03b1\ninst\u271d\u00b2\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2079 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2077 : LocallyFiniteOrderTop \u03b1\na\u271d\u00b9 : \u03b1\ninst\u271d\u00b9\u2076 : Fintype \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrderBot \u03b1\na\u271d : \u03b1\ninst\u271d\u00b9\u2074 : Fintype \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : LocallyFiniteOrder \u03b1\na b c : \u03b1\ninst\u271d\u2078 : DecidableEq \u03b1\n\u03b2 : Type u_3\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b2\ninst\u271d\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b2\nIcc : ?m.1807\n\u22a2 Sort u_5"}]}
{"declaration": "lemma Ioc_map_sectR : (Ioc a b).map (.sectR c _) = Ioc (c, a) (c, b) := by\n  aesop (add safe forward [le_antisymm, le_of_lt])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Basic.lean", "context": {"open": ["Function OrderDual", "FinsetInterval"], "variables": ["{\u03b9 \u03b1 : Type*} {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[Preorder \u03b1]", "[LocallyFiniteOrder \u03b1]", "(a)", "{a}", "(a b) [Fintype \u03b1]", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrderBot \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderBot \u03b1]", "[PartialOrder \u03b1] [LocallyFiniteOrder \u03b1] {a b c : \u03b1}", "[DecidableEq \u03b1]", "{\u03b2 : Type*}", "[Preorder \u03b1] [PartialOrder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]", "[PartialOrder \u03b1] [Preorder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nIoc : x\u271d\n\u22a2 sorry = sorry"}, {"line": "aesop (add safe forward [le_antisymm, le_of_lt])", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\na\u271d\u00b2 a\u2081 a\u2082 b\u271d b\u2081 b\u2082 c\u271d x : \u03b1\ninst\u271d\u00b2\u2074 : Preorder \u03b1\ninst\u271d\u00b2\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u00b2 : Fintype \u03b1\ninst\u271d\u00b2\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2079 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2077 : LocallyFiniteOrderTop \u03b1\na\u271d\u00b9 : \u03b1\ninst\u271d\u00b9\u2076 : Fintype \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrderBot \u03b1\na\u271d : \u03b1\ninst\u271d\u00b9\u2074 : Fintype \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : LocallyFiniteOrder \u03b1\na b c : \u03b1\ninst\u271d\u2078 : DecidableEq \u03b1\n\u03b2 : Type u_3\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b2\ninst\u271d\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b2\nIoc : ?m.1807\n\u22a2 Sort u_5"}]}
{"declaration": "lemma Ico_map_sectR : (Ico a b).map (.sectR c _) = Ico (c, a) (c, b) := by\n  aesop (add safe forward [le_antisymm, le_of_lt])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Basic.lean", "context": {"open": ["Function OrderDual", "FinsetInterval"], "variables": ["{\u03b9 \u03b1 : Type*} {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[Preorder \u03b1]", "[LocallyFiniteOrder \u03b1]", "(a)", "{a}", "(a b) [Fintype \u03b1]", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrderBot \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderBot \u03b1]", "[PartialOrder \u03b1] [LocallyFiniteOrder \u03b1] {a b c : \u03b1}", "[DecidableEq \u03b1]", "{\u03b2 : Type*}", "[Preorder \u03b1] [PartialOrder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]", "[PartialOrder \u03b1] [Preorder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nIco : x\u271d\n\u22a2 sorry = sorry"}, {"line": "aesop (add safe forward [le_antisymm, le_of_lt])", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\na\u271d\u00b2 a\u2081 a\u2082 b\u271d b\u2081 b\u2082 c\u271d x : \u03b1\ninst\u271d\u00b2\u2074 : Preorder \u03b1\ninst\u271d\u00b2\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u00b2 : Fintype \u03b1\ninst\u271d\u00b2\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2079 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2077 : LocallyFiniteOrderTop \u03b1\na\u271d\u00b9 : \u03b1\ninst\u271d\u00b9\u2076 : Fintype \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrderBot \u03b1\na\u271d : \u03b1\ninst\u271d\u00b9\u2074 : Fintype \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : LocallyFiniteOrder \u03b1\na b c : \u03b1\ninst\u271d\u2078 : DecidableEq \u03b1\n\u03b2 : Type u_3\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b2\ninst\u271d\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b2\nIco : ?m.1807\n\u22a2 Sort u_5"}]}
{"declaration": "lemma Ioo_map_sectR : (Ioo a b).map (.sectR c _) = Ioo (c, a) (c, b) := by\n  aesop (add safe forward [le_antisymm, le_of_lt])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Basic.lean", "context": {"open": ["Function OrderDual", "FinsetInterval"], "variables": ["{\u03b9 \u03b1 : Type*} {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[Preorder \u03b1]", "[LocallyFiniteOrder \u03b1]", "(a)", "{a}", "(a b) [Fintype \u03b1]", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrderBot \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderBot \u03b1]", "[PartialOrder \u03b1] [LocallyFiniteOrder \u03b1] {a b c : \u03b1}", "[DecidableEq \u03b1]", "{\u03b2 : Type*}", "[Preorder \u03b1] [PartialOrder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]", "[PartialOrder \u03b1] [Preorder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nIoo : x\u271d\n\u22a2 sorry = sorry"}, {"line": "aesop (add safe forward [le_antisymm, le_of_lt])", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\na\u271d\u00b2 a\u2081 a\u2082 b\u271d b\u2081 b\u2082 c\u271d x : \u03b1\ninst\u271d\u00b2\u2074 : Preorder \u03b1\ninst\u271d\u00b2\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u00b2 : Fintype \u03b1\ninst\u271d\u00b2\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2079 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2077 : LocallyFiniteOrderTop \u03b1\na\u271d\u00b9 : \u03b1\ninst\u271d\u00b9\u2076 : Fintype \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrderBot \u03b1\na\u271d : \u03b1\ninst\u271d\u00b9\u2074 : Fintype \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : LocallyFiniteOrder \u03b1\na b c : \u03b1\ninst\u271d\u2078 : DecidableEq \u03b1\n\u03b2 : Type u_3\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b2\ninst\u271d\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b2\nIoo : ?m.1807\n\u22a2 Sort u_5"}]}
{"declaration": "theorem Ioi_disjUnion_Iio (a : \u03b1) :\n    (Ioi a).disjUnion (Iio a) (disjoint_Ioi_Iio a) = ({a} : Finset \u03b1)\u1d9c := by\n  ext\n  simp [eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Basic.lean", "context": {"open": ["Function OrderDual", "FinsetInterval"], "variables": ["{\u03b9 \u03b1 : Type*} {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[Preorder \u03b1]", "[LocallyFiniteOrder \u03b1]", "(a)", "{a}", "(a b) [Fintype \u03b1]", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrderBot \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderBot \u03b1]", "[PartialOrder \u03b1] [LocallyFiniteOrder \u03b1] {a b c : \u03b1}", "[DecidableEq \u03b1]", "{\u03b2 : Type*}", "[Preorder \u03b1] [PartialOrder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]", "[PartialOrder \u03b1] [Preorder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]", "[PartialOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[SemilatticeSup \u03b1] [LocallyFiniteOrderBot \u03b1]", "[SemilatticeInf \u03b1] [LocallyFiniteOrderTop \u03b1]", "[LinearOrder \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[LocallyFiniteOrderBot \u03b1] {s : Set \u03b1}", "[LocallyFiniteOrderTop \u03b1] {s : Set \u03b1}", "[Fintype \u03b1] [LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderBot \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3\u2075 : Preorder \u03b1\ninst\u271d\u00b3\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u00b3 : Fintype \u03b1\ninst\u271d\u00b3\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b3\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u2070 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b2\u2079 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2078 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u2077 : Fintype \u03b1\ninst\u271d\u00b2\u2076 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b2\u2075 : Fintype \u03b1\ninst\u271d\u00b2\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u00b3 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u00b2 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b2\u00b9 : PartialOrder \u03b1\ninst\u271d\u00b2\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2079 : DecidableEq \u03b1\ninst\u271d\u00b9\u2078 : Preorder \u03b1\ninst\u271d\u00b9\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2076 : PartialOrder \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u00b2 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u00b9 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u2070 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u2079 : SemilatticeInf \u03b1\ninst\u271d\u2078 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b3 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d : LocallyFiniteOrderBot \u03b1\nx\u271d : Sort u_4\nIoi : x\u271d\na : \u03b1\n\u22a2 sorry = {a}\u1d9c"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b3\u2075 : Preorder \u03b1\ninst\u271d\u00b3\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u00b3 : Fintype \u03b1\ninst\u271d\u00b3\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b3\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u2070 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b2\u2079 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2078 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u2077 : Fintype \u03b1\ninst\u271d\u00b2\u2076 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b2\u2075 : Fintype \u03b1\ninst\u271d\u00b2\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u00b3 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u00b2 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b2\u00b9 : PartialOrder \u03b1\ninst\u271d\u00b2\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2079 : DecidableEq \u03b1\ninst\u271d\u00b9\u2078 : Preorder \u03b1\ninst\u271d\u00b9\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2076 : PartialOrder \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u00b2 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u00b9 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u2070 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u2079 : SemilatticeInf \u03b1\ninst\u271d\u2078 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b3 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d : LocallyFiniteOrderBot \u03b1\nx\u271d : Sort u_4\nIoi : x\u271d\na a\u271d : \u03b1\n\u22a2 a\u271d \u2208 sorry \u2194 a\u271d \u2208 {a}\u1d9c"}, {"line": "simp [eq_comm]", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b3\u2075 : Preorder \u03b1\ninst\u271d\u00b3\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u00b3 : Fintype \u03b1\ninst\u271d\u00b3\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b3\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u2070 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b2\u2079 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2078 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u2077 : Fintype \u03b1\ninst\u271d\u00b2\u2076 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b2\u2075 : Fintype \u03b1\ninst\u271d\u00b2\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u00b3 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u00b2 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b2\u00b9 : PartialOrder \u03b1\ninst\u271d\u00b2\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2079 : DecidableEq \u03b1\ninst\u271d\u00b9\u2078 : Preorder \u03b1\ninst\u271d\u00b9\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2076 : PartialOrder \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u00b2 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u00b9 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u2070 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u2079 : SemilatticeInf \u03b1\ninst\u271d\u2078 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b3 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d : LocallyFiniteOrderBot \u03b1\nx\u271d : Sort u_4\nIoi : x\u271d\na a\u271d : \u03b1\n\u22a2 a\u271d \u2208 sorry () \u2194 \u00aca = a\u271d"}]}
{"declaration": "theorem mem_uIcc' : a \u2208 [[b, c]] \u2194 b \u2264 a \u2227 a \u2264 c \u2228 c \u2264 a \u2227 a \u2264 b := by simp [uIcc_eq_union]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Basic.lean", "context": {"open": ["Function OrderDual", "FinsetInterval"], "variables": ["{\u03b9 \u03b1 : Type*} {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[Preorder \u03b1]", "[LocallyFiniteOrder \u03b1]", "(a)", "{a}", "(a b) [Fintype \u03b1]", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrderBot \u03b1] {a : \u03b1}", "[Fintype \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderBot \u03b1]", "[PartialOrder \u03b1] [LocallyFiniteOrder \u03b1] {a b c : \u03b1}", "[DecidableEq \u03b1]", "{\u03b2 : Type*}", "[Preorder \u03b1] [PartialOrder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]", "[PartialOrder \u03b1] [Preorder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]", "[PartialOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[SemilatticeSup \u03b1] [LocallyFiniteOrderBot \u03b1]", "[SemilatticeInf \u03b1] [LocallyFiniteOrderTop \u03b1]", "[LinearOrder \u03b1]", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[LocallyFiniteOrderBot \u03b1] {s : Set \u03b1}", "[LocallyFiniteOrderTop \u03b1] {s : Set \u03b1}", "[Fintype \u03b1] [LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderBot \u03b1]", "[Lattice \u03b1] [LocallyFiniteOrder \u03b1] {a a\u2081 a\u2082 b b\u2081 b\u2082 x : \u03b1}", "[DistribLattice \u03b1] [LocallyFiniteOrder \u03b1] {a b c : \u03b1}", "[LinearOrder \u03b1] [LocallyFiniteOrder \u03b1] {a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074\u00b9 : Preorder \u03b1\ninst\u271d\u2074\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u2079 : Fintype \u03b1\ninst\u271d\u00b3\u2078 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b3\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u2076 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b3\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u2074 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b3\u00b3 : Fintype \u03b1\ninst\u271d\u00b3\u00b2 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b3\u00b9 : Fintype \u03b1\ninst\u271d\u00b3\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2079 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u2078 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b2\u2077 : PartialOrder \u03b1\ninst\u271d\u00b2\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2075 : DecidableEq \u03b1\ninst\u271d\u00b2\u2074 : Preorder \u03b1\ninst\u271d\u00b2\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2070 : PartialOrder \u03b1\ninst\u271d\u00b9\u2079 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u2078 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2077 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u2076 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2075 : SemilatticeInf \u03b1\ninst\u271d\u00b9\u2074 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u2079 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u2078 : Fintype \u03b1\ninst\u271d\u2077 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u2076 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : DistribLattice \u03b1\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na b c : \u03b1\n\u22a2 a \u2208 sorry \u2194 b \u2264 a \u2227 a \u2264 c \u2228 c \u2264 a \u2227 a \u2264 b"}, {"line": "simp [uIcc_eq_union]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074\u00b9 : Preorder \u03b1\ninst\u271d\u2074\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u2079 : Fintype \u03b1\ninst\u271d\u00b3\u2078 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b3\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u2076 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b3\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u2074 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b3\u00b3 : Fintype \u03b1\ninst\u271d\u00b3\u00b2 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b3\u00b9 : Fintype \u03b1\ninst\u271d\u00b3\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2079 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u2078 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b2\u2077 : PartialOrder \u03b1\ninst\u271d\u00b2\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2075 : DecidableEq \u03b1\ninst\u271d\u00b2\u2074 : Preorder \u03b1\ninst\u271d\u00b2\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2070 : PartialOrder \u03b1\ninst\u271d\u00b9\u2079 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u2078 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2077 : SemilatticeSup \u03b1\ninst\u271d\u00b9\u2076 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2075 : SemilatticeInf \u03b1\ninst\u271d\u00b9\u2074 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u2079 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u2078 : Fintype \u03b1\ninst\u271d\u2077 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u2076 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u2075 : Lattice \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : DistribLattice \u03b1\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na b c : \u03b1\n\u22a2 a \u2208 sorry () \u2194 b \u2264 a \u2227 a \u2264 c \u2228 c \u2264 a \u2227 a \u2264 b"}]}
{"declaration": "private lemma Icc_neg_mono : Monotone fun n : \u2115 \u21a6 Icc (-n : \u03b1) n := by\n  refine fun m n hmn \u21a6 by apply Icc_subset_Icc <;> simpa using Nat.mono_cast hmn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Box.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [Ring \u03b1] [PartialOrder \u03b1] [IsOrderedRing \u03b1] [LocallyFiniteOrder \u03b1] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nIcc : x\u271d\n\u22a2 Monotone fun n => ?m.748"}, {"line": "refine fun m n hmn \u21a6 by apply Icc_subset_Icc <;> simpa using Nat.mono_cast hmn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_subtype_embedding_Ici (hp : \u2200 \u2983a x\u2984, a \u2264 x \u2192 p a \u2192 p x) :\n    (Ici a).map (Embedding.subtype p) = (Ici a : Finset \u03b1) := by\n  rw [subtype_Ici_eq]\n  exact Finset.subtype_map_of_mem fun x hx => hp (mem_Ici.1 hx) a.prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Defs.lean", "context": {"open": ["Finset Function", "Lean Elab Term Meta Batteries.ExtendedBinder", "Finset", "OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LocallyFiniteOrder \u03b1] {a b x : \u03b1}", "[LocallyFiniteOrderTop \u03b1] {a x : \u03b1}", "[LocallyFiniteOrderBot \u03b1] {a x : \u03b1}", "[LocallyFiniteOrder \u03b1] [OrderTop \u03b1] {a x : \u03b1}", "[OrderBot \u03b1] [LocallyFiniteOrder \u03b1] {b x : \u03b1}", "[Lattice \u03b1] [LocallyFiniteOrder \u03b1] {a b x : \u03b1}", "[Preorder \u03b1] [LocallyFiniteOrder \u03b1] (a b : \u03b1)", "[Preorder \u03b1] [LocallyFiniteOrderTop \u03b1] (a : \u03b1)", "[Preorder \u03b1] [LocallyFiniteOrderBot \u03b1] (b : \u03b1)", "[Lattice \u03b1] [LocallyFiniteOrder \u03b1] (a b : \u03b1)", "[Preorder \u03b1] [Preorder \u03b2]", "[LocallyFiniteOrder \u03b1] (a b : \u03b1)", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "[LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderTop \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "[LocallyFiniteOrderBot \u03b1] [LocallyFiniteOrderBot \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "[Lattice \u03b1] [Lattice \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "(\u03b1) [PartialOrder \u03b1] [OrderTop \u03b1] [LocallyFiniteOrder \u03b1]", "(a b : \u03b1)", "(\u03b1) [PartialOrder \u03b1] [OrderBot \u03b1] [LocallyFiniteOrder \u03b1]", "(a b : \u03b1)", "[Preorder \u03b1] [Preorder \u03b2]", "[Preorder \u03b1] (p : \u03b1 \u2192 Prop) [DecidablePred p]", "[LocallyFiniteOrder \u03b1] (a b : Subtype p)", "[LocallyFiniteOrderTop \u03b1] (a : Subtype p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3\u2074 : Preorder \u03b1\ninst\u271d\u00b3\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b3\u00b9 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b3\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2079 : OrderTop \u03b1\ninst\u271d\u00b2\u2078 : OrderBot \u03b1\ninst\u271d\u00b2\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2076 : Lattice \u03b1\ninst\u271d\u00b2\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2074 : Preorder \u03b1\ninst\u271d\u00b2\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u00b2 : Preorder \u03b1\ninst\u271d\u00b2\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2078 : Lattice \u03b1\ninst\u271d\u00b9\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2074 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u00b2 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u2070 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u2079 : Lattice \u03b1\ninst\u271d\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : OrderTop \u03b1\ninst\u271d\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : Preorder \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : LocallyFiniteOrderTop \u03b1\na : Subtype p\nhp : \u2200 \u2983a x : \u03b1\u2984, a \u2264 x \u2192 p a \u2192 p x\n\u22a2 map (Embedding.subtype p) (Ici a) = Ici \u2191a"}, {"line": "rw [subtype_Ici_eq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3\u2074 : Preorder \u03b1\ninst\u271d\u00b3\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b3\u00b9 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b3\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2079 : OrderTop \u03b1\ninst\u271d\u00b2\u2078 : OrderBot \u03b1\ninst\u271d\u00b2\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2076 : Lattice \u03b1\ninst\u271d\u00b2\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2074 : Preorder \u03b1\ninst\u271d\u00b2\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u00b2 : Preorder \u03b1\ninst\u271d\u00b2\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2078 : Lattice \u03b1\ninst\u271d\u00b9\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2074 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u00b2 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u2070 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u2079 : Lattice \u03b1\ninst\u271d\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : OrderTop \u03b1\ninst\u271d\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : Preorder \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : LocallyFiniteOrderTop \u03b1\na : Subtype p\nhp : \u2200 \u2983a x : \u03b1\u2984, a \u2264 x \u2192 p a \u2192 p x\n\u22a2 map (Embedding.subtype p) (Finset.subtype p (Ici \u2191a)) = Ici \u2191a"}, {"line": "exact Finset.subtype_map_of_mem fun x hx => hp (mem_Ici.1 hx) a.prop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_subtype_embedding_Ioi (hp : \u2200 \u2983a x\u2984, a \u2264 x \u2192 p a \u2192 p x) :\n    (Ioi a).map (Embedding.subtype p) = (Ioi a : Finset \u03b1) := by\n  rw [subtype_Ioi_eq]\n  exact Finset.subtype_map_of_mem fun x hx => hp (mem_Ioi.1 hx).le a.prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Defs.lean", "context": {"open": ["Finset Function", "Lean Elab Term Meta Batteries.ExtendedBinder", "Finset", "OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LocallyFiniteOrder \u03b1] {a b x : \u03b1}", "[LocallyFiniteOrderTop \u03b1] {a x : \u03b1}", "[LocallyFiniteOrderBot \u03b1] {a x : \u03b1}", "[LocallyFiniteOrder \u03b1] [OrderTop \u03b1] {a x : \u03b1}", "[OrderBot \u03b1] [LocallyFiniteOrder \u03b1] {b x : \u03b1}", "[Lattice \u03b1] [LocallyFiniteOrder \u03b1] {a b x : \u03b1}", "[Preorder \u03b1] [LocallyFiniteOrder \u03b1] (a b : \u03b1)", "[Preorder \u03b1] [LocallyFiniteOrderTop \u03b1] (a : \u03b1)", "[Preorder \u03b1] [LocallyFiniteOrderBot \u03b1] (b : \u03b1)", "[Lattice \u03b1] [LocallyFiniteOrder \u03b1] (a b : \u03b1)", "[Preorder \u03b1] [Preorder \u03b2]", "[LocallyFiniteOrder \u03b1] (a b : \u03b1)", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "[LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderTop \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "[LocallyFiniteOrderBot \u03b1] [LocallyFiniteOrderBot \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "[Lattice \u03b1] [Lattice \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "(\u03b1) [PartialOrder \u03b1] [OrderTop \u03b1] [LocallyFiniteOrder \u03b1]", "(a b : \u03b1)", "(\u03b1) [PartialOrder \u03b1] [OrderBot \u03b1] [LocallyFiniteOrder \u03b1]", "(a b : \u03b1)", "[Preorder \u03b1] [Preorder \u03b2]", "[Preorder \u03b1] (p : \u03b1 \u2192 Prop) [DecidablePred p]", "[LocallyFiniteOrder \u03b1] (a b : Subtype p)", "[LocallyFiniteOrderTop \u03b1] (a : Subtype p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3\u2074 : Preorder \u03b1\ninst\u271d\u00b3\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b3\u00b9 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b3\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2079 : OrderTop \u03b1\ninst\u271d\u00b2\u2078 : OrderBot \u03b1\ninst\u271d\u00b2\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2076 : Lattice \u03b1\ninst\u271d\u00b2\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2074 : Preorder \u03b1\ninst\u271d\u00b2\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u00b2 : Preorder \u03b1\ninst\u271d\u00b2\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2078 : Lattice \u03b1\ninst\u271d\u00b9\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2074 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u00b2 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u2070 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u2079 : Lattice \u03b1\ninst\u271d\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : OrderTop \u03b1\ninst\u271d\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : Preorder \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : LocallyFiniteOrderTop \u03b1\na : Subtype p\nhp : \u2200 \u2983a x : \u03b1\u2984, a \u2264 x \u2192 p a \u2192 p x\n\u22a2 map (Embedding.subtype p) (Ioi a) = Ioi \u2191a"}, {"line": "rw [subtype_Ioi_eq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3\u2074 : Preorder \u03b1\ninst\u271d\u00b3\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b3\u00b9 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b3\u2070 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2079 : OrderTop \u03b1\ninst\u271d\u00b2\u2078 : OrderBot \u03b1\ninst\u271d\u00b2\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2076 : Lattice \u03b1\ninst\u271d\u00b2\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2074 : Preorder \u03b1\ninst\u271d\u00b2\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u00b2 : Preorder \u03b1\ninst\u271d\u00b2\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2078 : Lattice \u03b1\ninst\u271d\u00b9\u2077 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2074 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u00b2 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u2070 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u2079 : Lattice \u03b1\ninst\u271d\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : OrderTop \u03b1\ninst\u271d\u2075 : LocallyFiniteOrder \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : Preorder \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : LocallyFiniteOrderTop \u03b1\na : Subtype p\nhp : \u2200 \u2983a x : \u03b1\u2984, a \u2264 x \u2192 p a \u2192 p x\n\u22a2 map (Embedding.subtype p) (Finset.subtype p (Ioi \u2191a)) = Ioi \u2191a"}, {"line": "exact Finset.subtype_map_of_mem fun x hx => hp (mem_Ioi.1 hx).le a.prop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_subtype_embedding_Iic (hp : \u2200 \u2983a x\u2984, x \u2264 a \u2192 p a \u2192 p x) :\n    (Iic a).map (Embedding.subtype p) = (Iic a : Finset \u03b1) := by\n  rw [subtype_Iic_eq]\n  exact Finset.subtype_map_of_mem fun x hx => hp (mem_Iic.1 hx) a.prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Defs.lean", "context": {"open": ["Finset Function", "Lean Elab Term Meta Batteries.ExtendedBinder", "Finset", "OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LocallyFiniteOrder \u03b1] {a b x : \u03b1}", "[LocallyFiniteOrderTop \u03b1] {a x : \u03b1}", "[LocallyFiniteOrderBot \u03b1] {a x : \u03b1}", "[LocallyFiniteOrder \u03b1] [OrderTop \u03b1] {a x : \u03b1}", "[OrderBot \u03b1] [LocallyFiniteOrder \u03b1] {b x : \u03b1}", "[Lattice \u03b1] [LocallyFiniteOrder \u03b1] {a b x : \u03b1}", "[Preorder \u03b1] [LocallyFiniteOrder \u03b1] (a b : \u03b1)", "[Preorder \u03b1] [LocallyFiniteOrderTop \u03b1] (a : \u03b1)", "[Preorder \u03b1] [LocallyFiniteOrderBot \u03b1] (b : \u03b1)", "[Lattice \u03b1] [LocallyFiniteOrder \u03b1] (a b : \u03b1)", "[Preorder \u03b1] [Preorder \u03b2]", "[LocallyFiniteOrder \u03b1] (a b : \u03b1)", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "[LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderTop \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "[LocallyFiniteOrderBot \u03b1] [LocallyFiniteOrderBot \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "[Lattice \u03b1] [Lattice \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "(\u03b1) [PartialOrder \u03b1] [OrderTop \u03b1] [LocallyFiniteOrder \u03b1]", "(a b : \u03b1)", "(\u03b1) [PartialOrder \u03b1] [OrderBot \u03b1] [LocallyFiniteOrder \u03b1]", "(a b : \u03b1)", "[Preorder \u03b1] [Preorder \u03b2]", "[Preorder \u03b1] (p : \u03b1 \u2192 Prop) [DecidablePred p]", "[LocallyFiniteOrder \u03b1] (a b : Subtype p)", "[LocallyFiniteOrderTop \u03b1] (a : Subtype p)", "[LocallyFiniteOrderBot \u03b1] (a : Subtype p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3\u2075 : Preorder \u03b1\ninst\u271d\u00b3\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u00b3 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b3\u00b2 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b3\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u2070 : OrderTop \u03b1\ninst\u271d\u00b2\u2079 : OrderBot \u03b1\ninst\u271d\u00b2\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2077 : Lattice \u03b1\ninst\u271d\u00b2\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u00b9 : Preorder \u03b1\ninst\u271d\u00b2\u2070 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2079 : Lattice \u03b1\ninst\u271d\u00b9\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u2074 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2070 : Lattice \u03b1\ninst\u271d\u2079 : LocallyFiniteOrder \u03b1\ninst\u271d\u2078 : PartialOrder \u03b1\ninst\u271d\u2077 : OrderTop \u03b1\ninst\u271d\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : Preorder \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d : LocallyFiniteOrderBot \u03b1\na : Subtype p\nhp : \u2200 \u2983a x : \u03b1\u2984, x \u2264 a \u2192 p a \u2192 p x\n\u22a2 map (Embedding.subtype p) (Iic a) = Iic \u2191a"}, {"line": "rw [subtype_Iic_eq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3\u2075 : Preorder \u03b1\ninst\u271d\u00b3\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u00b3 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b3\u00b2 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b3\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u2070 : OrderTop \u03b1\ninst\u271d\u00b2\u2079 : OrderBot \u03b1\ninst\u271d\u00b2\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2077 : Lattice \u03b1\ninst\u271d\u00b2\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u00b9 : Preorder \u03b1\ninst\u271d\u00b2\u2070 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2079 : Lattice \u03b1\ninst\u271d\u00b9\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u2074 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2070 : Lattice \u03b1\ninst\u271d\u2079 : LocallyFiniteOrder \u03b1\ninst\u271d\u2078 : PartialOrder \u03b1\ninst\u271d\u2077 : OrderTop \u03b1\ninst\u271d\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : Preorder \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d : LocallyFiniteOrderBot \u03b1\na : Subtype p\nhp : \u2200 \u2983a x : \u03b1\u2984, x \u2264 a \u2192 p a \u2192 p x\n\u22a2 map (Embedding.subtype p) (Finset.subtype p (Iic \u2191a)) = Iic \u2191a"}, {"line": "exact Finset.subtype_map_of_mem fun x hx => hp (mem_Iic.1 hx) a.prop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_subtype_embedding_Iio (hp : \u2200 \u2983a x\u2984, x \u2264 a \u2192 p a \u2192 p x) :\n    (Iio a).map (Embedding.subtype p) = (Iio a : Finset \u03b1) := by\n  rw [subtype_Iio_eq]\n  exact Finset.subtype_map_of_mem fun x hx => hp (mem_Iio.1 hx).le a.prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Defs.lean", "context": {"open": ["Finset Function", "Lean Elab Term Meta Batteries.ExtendedBinder", "Finset", "OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LocallyFiniteOrder \u03b1] {a b x : \u03b1}", "[LocallyFiniteOrderTop \u03b1] {a x : \u03b1}", "[LocallyFiniteOrderBot \u03b1] {a x : \u03b1}", "[LocallyFiniteOrder \u03b1] [OrderTop \u03b1] {a x : \u03b1}", "[OrderBot \u03b1] [LocallyFiniteOrder \u03b1] {b x : \u03b1}", "[Lattice \u03b1] [LocallyFiniteOrder \u03b1] {a b x : \u03b1}", "[Preorder \u03b1] [LocallyFiniteOrder \u03b1] (a b : \u03b1)", "[Preorder \u03b1] [LocallyFiniteOrderTop \u03b1] (a : \u03b1)", "[Preorder \u03b1] [LocallyFiniteOrderBot \u03b1] (b : \u03b1)", "[Lattice \u03b1] [LocallyFiniteOrder \u03b1] (a b : \u03b1)", "[Preorder \u03b1] [Preorder \u03b2]", "[LocallyFiniteOrder \u03b1] (a b : \u03b1)", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "[LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderTop \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "[LocallyFiniteOrderBot \u03b1] [LocallyFiniteOrderBot \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "[Lattice \u03b1] [Lattice \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "(\u03b1) [PartialOrder \u03b1] [OrderTop \u03b1] [LocallyFiniteOrder \u03b1]", "(a b : \u03b1)", "(\u03b1) [PartialOrder \u03b1] [OrderBot \u03b1] [LocallyFiniteOrder \u03b1]", "(a b : \u03b1)", "[Preorder \u03b1] [Preorder \u03b2]", "[Preorder \u03b1] (p : \u03b1 \u2192 Prop) [DecidablePred p]", "[LocallyFiniteOrder \u03b1] (a b : Subtype p)", "[LocallyFiniteOrderTop \u03b1] (a : Subtype p)", "[LocallyFiniteOrderBot \u03b1] (a : Subtype p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3\u2075 : Preorder \u03b1\ninst\u271d\u00b3\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u00b3 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b3\u00b2 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b3\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u2070 : OrderTop \u03b1\ninst\u271d\u00b2\u2079 : OrderBot \u03b1\ninst\u271d\u00b2\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2077 : Lattice \u03b1\ninst\u271d\u00b2\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u00b9 : Preorder \u03b1\ninst\u271d\u00b2\u2070 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2079 : Lattice \u03b1\ninst\u271d\u00b9\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u2074 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2070 : Lattice \u03b1\ninst\u271d\u2079 : LocallyFiniteOrder \u03b1\ninst\u271d\u2078 : PartialOrder \u03b1\ninst\u271d\u2077 : OrderTop \u03b1\ninst\u271d\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : Preorder \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d : LocallyFiniteOrderBot \u03b1\na : Subtype p\nhp : \u2200 \u2983a x : \u03b1\u2984, x \u2264 a \u2192 p a \u2192 p x\n\u22a2 map (Embedding.subtype p) (Iio a) = Iio \u2191a"}, {"line": "rw [subtype_Iio_eq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3\u2075 : Preorder \u03b1\ninst\u271d\u00b3\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u00b3 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b3\u00b2 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b3\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3\u2070 : OrderTop \u03b1\ninst\u271d\u00b2\u2079 : OrderBot \u03b1\ninst\u271d\u00b2\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2077 : Lattice \u03b1\ninst\u271d\u00b2\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b2\u00b9 : Preorder \u03b1\ninst\u271d\u00b2\u2070 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2079 : Lattice \u03b1\ninst\u271d\u00b9\u2078 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u2075 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u2074 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u00b3 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9\u00b2 : LocallyFiniteOrderTop \u03b1\ninst\u271d\u00b9\u00b9 : LocallyFiniteOrderBot \u03b1\ninst\u271d\u00b9\u2070 : Lattice \u03b1\ninst\u271d\u2079 : LocallyFiniteOrder \u03b1\ninst\u271d\u2078 : PartialOrder \u03b1\ninst\u271d\u2077 : OrderTop \u03b1\ninst\u271d\u2076 : LocallyFiniteOrder \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : Preorder \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrderTop \u03b1\ninst\u271d : LocallyFiniteOrderBot \u03b1\na : Subtype p\nhp : \u2200 \u2983a x : \u03b1\u2984, x \u2264 a \u2192 p a \u2192 p x\n\u22a2 map (Embedding.subtype p) (Finset.subtype p (Iio \u2191a)) = Iio \u2191a"}, {"line": "exact Finset.subtype_map_of_mem fun x hx => hp (mem_Iio.1 hx).le a.prop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Set.finite_iff_bddBelow_bddAbove [Nonempty \u03b1] [Lattice \u03b1] [LocallyFiniteOrder \u03b1] :\n    s.Finite \u2194 BddBelow s \u2227 BddAbove s := by\n  obtain (rfl | hs) := s.eq_empty_or_nonempty\n  \u00b7 simp only [Set.finite_empty, bddBelow_empty, bddAbove_empty, and_self]\n  exact \u27e8fun h \u21a6 \u27e8\u27e8h.toFinset.inf' ((Finite.toFinset_nonempty h).mpr hs) id,\n    fun x hx \u21a6 Finset.inf'_le id ((Finite.mem_toFinset h).mpr hx)\u27e9,\n    \u27e8h.toFinset.sup' ((Finite.toFinset_nonempty h).mpr hs) id, fun x hx \u21a6 Finset.le_sup' id\n    ((Finite.mem_toFinset h).mpr hx)\u27e9\u27e9,\n    fun \u27e8h\u2080, h\u2081\u27e9 \u21a6 BddBelow.finite_of_bddAbove h\u2080 h\u2081\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Defs.lean", "context": {"open": ["Finset Function", "Lean Elab Term Meta Batteries.ExtendedBinder", "Finset", "OrderDual"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1]", "[LocallyFiniteOrder \u03b1] {a b x : \u03b1}", "[LocallyFiniteOrderTop \u03b1] {a x : \u03b1}", "[LocallyFiniteOrderBot \u03b1] {a x : \u03b1}", "[LocallyFiniteOrder \u03b1] [OrderTop \u03b1] {a x : \u03b1}", "[OrderBot \u03b1] [LocallyFiniteOrder \u03b1] {b x : \u03b1}", "[Lattice \u03b1] [LocallyFiniteOrder \u03b1] {a b x : \u03b1}", "[Preorder \u03b1] [LocallyFiniteOrder \u03b1] (a b : \u03b1)", "[Preorder \u03b1] [LocallyFiniteOrderTop \u03b1] (a : \u03b1)", "[Preorder \u03b1] [LocallyFiniteOrderBot \u03b1] (b : \u03b1)", "[Lattice \u03b1] [LocallyFiniteOrder \u03b1] (a b : \u03b1)", "[Preorder \u03b1] [Preorder \u03b2]", "[LocallyFiniteOrder \u03b1] (a b : \u03b1)", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "[LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderTop \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "[LocallyFiniteOrderBot \u03b1] [LocallyFiniteOrderBot \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "[Lattice \u03b1] [Lattice \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2] [DecidableLE (\u03b1 \u00d7 \u03b2)]", "(\u03b1) [PartialOrder \u03b1] [OrderTop \u03b1] [LocallyFiniteOrder \u03b1]", "(a b : \u03b1)", "(\u03b1) [PartialOrder \u03b1] [OrderBot \u03b1] [LocallyFiniteOrder \u03b1]", "(a b : \u03b1)", "[Preorder \u03b1] [Preorder \u03b2]", "[Preorder \u03b1] (p : \u03b1 \u2192 Prop) [DecidablePred p]", "[LocallyFiniteOrder \u03b1] (a b : Subtype p)", "[LocallyFiniteOrderTop \u03b1] (a : Subtype p)", "[LocallyFiniteOrderBot \u03b1] (a : Subtype p)", "{\u03b1 : Type*} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ns : Set \u03b1\ninst\u271d\u00b2 : Nonempty \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\n\u22a2 s.Finite \u2194 BddBelow s \u2227 BddAbove s"}, {"line": "obtain (rfl | hs) := s.eq_empty_or_nonempty", "tactic_state": "case inl\n\u03b1 : Type u_3\ninst\u271d\u00b2 : Nonempty \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\n\u22a2 \u2205.Finite \u2194 BddBelow \u2205 \u2227 BddAbove \u2205\n---\ncase inr\n\u03b1 : Type u_3\ns : Set \u03b1\ninst\u271d\u00b2 : Nonempty \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\nhs : s.Nonempty\n\u22a2 s.Finite \u2194 BddBelow s \u2227 BddAbove s"}, {"line": "\u00b7 simp only [Set.finite_empty, bddBelow_empty, bddAbove_empty, and_self]", "tactic_state": "case inr\n\u03b1 : Type u_3\ns : Set \u03b1\ninst\u271d\u00b2 : Nonempty \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\nhs : s.Nonempty\n\u22a2 s.Finite \u2194 BddBelow s \u2227 BddAbove s"}, {"line": "exact \u27e8fun h \u21a6 \u27e8\u27e8h.toFinset.inf' ((Finite.toFinset_nonempty h).mpr hs) id,\n    fun x hx \u21a6 Finset.inf'_le id ((Finite.mem_toFinset h).mpr hx)\u27e9,\n    \u27e8h.toFinset.sup' ((Finite.toFinset_nonempty h).mpr hs) id, fun x hx \u21a6 Finset.le_sup' id\n    ((Finite.mem_toFinset h).mpr hx)\u27e9\u27e9,\n    fun \u27e8h\u2080, h\u2081\u27e9 \u21a6 BddBelow.finite_of_bddAbove h\u2080 h\u2081\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finsetImage_val_Ici : (Ici a).image val = Ico (a : \u2115) n := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "\u22a2 sorry ()"}]}
{"declaration": "theorem finsetImage_val_Ioi : (Ioi a).image val = Ioo (a : \u2115) n := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "\u22a2 sorry ()"}]}
{"declaration": "theorem finsetImage_val_Iic : (Iic a).image val = Iic (a : \u2115) := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "\u22a2 sorry ()"}]}
{"declaration": "theorem finsetImage_val_Iio : (Iio b).image val = Iio (b : \u2115) := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "\u22a2 sorry ()"}]}
{"declaration": "theorem finsetImage_castLE_Icc (h : n \u2264 m) :\n    (Icc a b).image (castLE h) = Icc (castLE h a) (castLE h b) := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d : Sort u_1\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 image sorry (Icc a b) = Icc sorry sorry"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d : Sort u_1\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 sorry () '' Set.Icc a b = Set.Icc (sorry ()) (sorry ())"}]}
{"declaration": "theorem finsetImage_castLE_Ico (h : n \u2264 m) :\n    (Ico a b).image (castLE h) = Ico (castLE h a) (castLE h b) := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d : Sort u_1\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 image sorry (Ico a b) = Ico sorry sorry"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d : Sort u_1\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 Set.Ico a b = \u2205"}]}
{"declaration": "theorem finsetImage_castLE_Ioc (h : n \u2264 m) :\n    (Ioc a b).image (castLE h) = Ioc (castLE h a) (castLE h b) := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d : Sort u_1\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 image sorry (Ioc a b) = Ioc sorry sorry"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d : Sort u_1\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 Set.Ioc a b = \u2205"}]}
{"declaration": "theorem finsetImage_castLE_Ioo (h : n \u2264 m) :\n    (Ioo a b).image (castLE h) = Ioo (castLE h a) (castLE h b) := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d : Sort u_1\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 image sorry (Ioo a b) = Ioo sorry sorry"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d : Sort u_1\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 Set.Ioo a b = \u2205"}]}
{"declaration": "theorem finsetImage_castLE_uIcc (h : n \u2264 m) :\n    (uIcc a b).image (castLE h) = uIcc (castLE h a) (castLE h b) := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d : Sort u_1\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 image sorry (uIcc a b) = uIcc sorry sorry"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d : Sort u_1\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 sorry () '' Set.uIcc a b = {sorry ()}"}]}
{"declaration": "theorem map_castLEEmb_Icc (h : n \u2264 m) :\n    (Icc a b).map (castLEEmb h) = Icc (castLE h a) (castLE h b) := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d\u00b9 : Sort u_1\ncastLEEmb : x\u271d\u00b9\nx\u271d : Sort u_2\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 map sorry (Icc a b) = Icc sorry sorry"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d\u00b9 : Sort u_1\ncastLEEmb : x\u271d\u00b9\nx\u271d : Sort u_2\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 \u21d1(sorry ()) '' Set.Icc a b = Set.Icc (sorry ()) (sorry ())"}]}
{"declaration": "theorem map_castLEEmb_Ico (h : n \u2264 m) :\n    (Ico a b).map (castLEEmb h) = Ico (castLE h a) (castLE h b) := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d\u00b9 : Sort u_1\ncastLEEmb : x\u271d\u00b9\nx\u271d : Sort u_2\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 map sorry (Ico a b) = Ico sorry sorry"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d\u00b9 : Sort u_1\ncastLEEmb : x\u271d\u00b9\nx\u271d : Sort u_2\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 Set.Ico a b = \u2205"}]}
{"declaration": "theorem map_castLEEmb_Ioc (h : n \u2264 m) :\n    (Ioc a b).map (castLEEmb h) = Ioc (castLE h a) (castLE h b) := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d\u00b9 : Sort u_1\ncastLEEmb : x\u271d\u00b9\nx\u271d : Sort u_2\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 map sorry (Ioc a b) = Ioc sorry sorry"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d\u00b9 : Sort u_1\ncastLEEmb : x\u271d\u00b9\nx\u271d : Sort u_2\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 Set.Ioc a b = \u2205"}]}
{"declaration": "theorem map_castLEEmb_Ioo (h : n \u2264 m) :\n    (Ioo a b).map (castLEEmb h) = Ioo (castLE h a) (castLE h b) := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d\u00b9 : Sort u_1\ncastLEEmb : x\u271d\u00b9\nx\u271d : Sort u_2\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 map sorry (Ioo a b) = Ioo sorry sorry"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d\u00b9 : Sort u_1\ncastLEEmb : x\u271d\u00b9\nx\u271d : Sort u_2\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 Set.Ioo a b = \u2205"}]}
{"declaration": "theorem map_castLEEmb_uIcc (h : n \u2264 m) :\n    (uIcc a b).map (castLEEmb h) = uIcc (castLE h a) (castLE h b) := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d\u00b9 : Sort u_1\ncastLEEmb : x\u271d\u00b9\nx\u271d : Sort u_2\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 map sorry (uIcc a b) = uIcc sorry sorry"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n m : \u2115\na b : Fin n\nx\u271d\u00b9 : Sort u_1\ncastLEEmb : x\u271d\u00b9\nx\u271d : Sort u_2\ncastLE : x\u271d\nh : n \u2264 m\n\u22a2 \u21d1(sorry ()) '' Set.uIcc a b = {sorry ()}"}]}
{"declaration": "theorem finsetImage_cast_Icc (h : n = m) (i j : Fin n) :\n    (Icc i j).image (.cast h) = Icc (i.cast h) (j.cast h) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\ni j : Fin n\n\u22a2 image (Fin.cast h) (Icc i j) = Icc (Fin.cast h i) (Fin.cast h j)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finsetImage_cast_Ico (h : n = m) (i j : Fin n) :\n    (Ico i j).image (.cast h) = Ico (i.cast h) (j.cast h) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\ni j : Fin n\n\u22a2 image (Fin.cast h) (Ico i j) = Ico (Fin.cast h i) (Fin.cast h j)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finsetImage_cast_Ioc (h : n = m) (i j : Fin n) :\n    (Ioc i j).image (.cast h) = Ioc (i.cast h) (j.cast h) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\ni j : Fin n\n\u22a2 image (Fin.cast h) (Ioc i j) = Ioc (Fin.cast h i) (Fin.cast h j)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finsetImage_cast_Ioo (h : n = m) (i j : Fin n) :\n    (Ioo i j).image (.cast h) = Ioo (i.cast h) (j.cast h) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\ni j : Fin n\n\u22a2 image (Fin.cast h) (Ioo i j) = Ioo (Fin.cast h i) (Fin.cast h j)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finsetImage_cast_uIcc (h : n = m) (i j : Fin n) :\n    (uIcc i j).image (.cast h) = uIcc (i.cast h) (j.cast h) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\ni j : Fin n\n\u22a2 image (Fin.cast h) (uIcc i j) = uIcc (Fin.cast h i) (Fin.cast h j)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finsetImage_cast_Ici (h : n = m) (i : Fin n) :\n    (Ici i).image (.cast h) = Ici (i.cast h) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\ni : Fin n\n\u22a2 image (Fin.cast h) (Ici i) = Ici (Fin.cast h i)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finsetImage_cast_Ioi (h : n = m) (i : Fin n) :\n    (Ioi i).image (.cast h) = Ioi (i.cast h) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\ni : Fin n\n\u22a2 image (Fin.cast h) (Ioi i) = Ioi (Fin.cast h i)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finsetImage_cast_Iic (h : n = m) (i : Fin n) :\n    (Iic i).image (.cast h) = Iic (i.cast h) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\ni : Fin n\n\u22a2 image (Fin.cast h) (Iic i) = Iic (Fin.cast h i)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finsetImage_cast_Iio (h : n = m) (i : Fin n) :\n    (Iio i).image (.cast h) = Iio (i.cast h) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\ni : Fin n\n\u22a2 image (Fin.cast h) (Iio i) = Iio (Fin.cast h i)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_finCongr_Icc (h : n = m) (i j : Fin n) :\n    (Icc i j).map (finCongr h).toEmbedding = Icc (i.cast h) (j.cast h) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\ni j : Fin n\n\u22a2 map (finCongr h).toEmbedding (Icc i j) = Icc (Fin.cast h i) (Fin.cast h j)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_finCongr_Ico (h : n = m) (i j : Fin n) :\n    (Ico i j).map (finCongr h).toEmbedding = Ico (i.cast h) (j.cast h) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\ni j : Fin n\n\u22a2 map (finCongr h).toEmbedding (Ico i j) = Ico (Fin.cast h i) (Fin.cast h j)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_finCongr_Ioc (h : n = m) (i j : Fin n) :\n    (Ioc i j).map (finCongr h).toEmbedding = Ioc (i.cast h) (j.cast h) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\ni j : Fin n\n\u22a2 map (finCongr h).toEmbedding (Ioc i j) = Ioc (Fin.cast h i) (Fin.cast h j)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_finCongr_Ioo (h : n = m) (i j : Fin n) :\n    (Ioo i j).map (finCongr h).toEmbedding = Ioo (i.cast h) (j.cast h) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\ni j : Fin n\n\u22a2 map (finCongr h).toEmbedding (Ioo i j) = Ioo (Fin.cast h i) (Fin.cast h j)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_finCongr_Ici (h : n = m) (i : Fin n) :\n    (Ici i).map (finCongr h).toEmbedding = Ici (i.cast h) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\ni : Fin n\n\u22a2 map (finCongr h).toEmbedding (Ici i) = Ici (Fin.cast h i)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_finCongr_Ioi (h : n = m) (i : Fin n) :\n    (Ioi i).map (finCongr h).toEmbedding = Ioi (i.cast h) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\ni : Fin n\n\u22a2 map (finCongr h).toEmbedding (Ioi i) = Ioi (Fin.cast h i)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_finCongr_Iic (h : n = m) (i : Fin n) :\n    (Iic i).map (finCongr h).toEmbedding = Iic (i.cast h) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\ni : Fin n\n\u22a2 map (finCongr h).toEmbedding (Iic i) = Iic (Fin.cast h i)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_finCongr_Iio (h : n = m) (i : Fin n) :\n    (Iio i).map (finCongr h).toEmbedding = Iio (i.cast h) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\ni : Fin n\n\u22a2 map (finCongr h).toEmbedding (Iio i) = Iio (Fin.cast h i)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finsetImage_addNat_Icc (m) (i j : Fin n) :\n    (Icc i j).image (addNat \u00b7 m) = Icc (i.addNat m) (j.addNat m) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 image (fun x => sorry) (Icc i j) = Icc (i.addNat m) (j.addNat m)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 (fun x => sorry ()) '' Set.Icc i j = Set.Icc (i.addNat m) (j.addNat m)"}]}
{"declaration": "theorem finsetImage_addNat_Ico (m) (i j : Fin n) :\n    (Ico i j).image (addNat \u00b7 m) = Ico (i.addNat m) (j.addNat m) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 image (fun x => sorry) (Ico i j) = Ico (i.addNat m) (j.addNat m)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 (fun x => sorry ()) '' Set.Ico i j = Set.Ico (i.addNat m) (j.addNat m)"}]}
{"declaration": "theorem finsetImage_addNat_Ioc (m) (i j : Fin n) :\n    (Ioc i j).image (addNat \u00b7 m) = Ioc (i.addNat m) (j.addNat m) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 image (fun x => sorry) (Ioc i j) = Ioc (i.addNat m) (j.addNat m)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 (fun x => sorry ()) '' Set.Ioc i j = Set.Ioc (i.addNat m) (j.addNat m)"}]}
{"declaration": "theorem finsetImage_addNat_Ioo (m) (i j : Fin n) :\n    (Ioo i j).image (addNat \u00b7 m) = Ioo (i.addNat m) (j.addNat m) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 image (fun x => sorry) (Ioo i j) = Ioo (i.addNat m) (j.addNat m)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 (fun x => sorry ()) '' Set.Ioo i j = Set.Ioo (i.addNat m) (j.addNat m)"}]}
{"declaration": "theorem finsetImage_addNat_uIcc (m) (i j : Fin n) :\n    (uIcc i j).image (addNat \u00b7 m) = uIcc (i.addNat m) (j.addNat m) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 image (fun x => sorry) (uIcc i j) = uIcc (i.addNat m) (j.addNat m)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 {sorry ()} = Set.uIcc (i.addNat m) (j.addNat m)"}]}
{"declaration": "theorem finsetImage_addNat_Ici (m) (i : Fin n) : (Ici i).image (addNat \u00b7 m) = Ici (i.addNat m) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni : Fin n\n\u22a2 image (fun x => sorry) (Ici i) = Ici (i.addNat m)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni : Fin n\n\u22a2 {sorry ()} = Set.Ici (i.addNat m)"}]}
{"declaration": "theorem finsetImage_addNat_Ioi (m) (i : Fin n) : (Ioi i).image (addNat \u00b7 m) = Ioi (i.addNat m) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni : Fin n\n\u22a2 image (fun x => sorry) (Ioi i) = Ioi (i.addNat m)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni : Fin n\n\u22a2 (fun x => sorry ()) '' Set.Ioi i = Set.Ioi (i.addNat m)"}]}
{"declaration": "theorem map_addNatEmb_Icc (m) (i j : Fin n) :\n    (Icc i j).map (addNatEmb m) = Icc (i.addNat m) (j.addNat m) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNatEmb : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 map sorry (Icc i j) = Icc (i.addNat m) (j.addNat m)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNatEmb : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.Icc i j = Set.Icc (i.addNat m) (j.addNat m)"}]}
{"declaration": "theorem map_addNatEmb_Ico (m) (i j : Fin n) :\n    (Ico i j).map (addNatEmb m) = Ico (i.addNat m) (j.addNat m) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNatEmb : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 map sorry (Ico i j) = Ico (i.addNat m) (j.addNat m)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNatEmb : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.Ico i j = Set.Ico (i.addNat m) (j.addNat m)"}]}
{"declaration": "theorem map_addNatEmb_Ioc (m) (i j : Fin n) :\n    (Ioc i j).map (addNatEmb m) = Ioc (i.addNat m) (j.addNat m) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNatEmb : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 map sorry (Ioc i j) = Ioc (i.addNat m) (j.addNat m)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNatEmb : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.Ioc i j = Set.Ioc (i.addNat m) (j.addNat m)"}]}
{"declaration": "theorem map_addNatEmb_Ioo (m) (i j : Fin n) :\n    (Ioo i j).map (addNatEmb m) = Ioo (i.addNat m) (j.addNat m) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNatEmb : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 map sorry (Ioo i j) = Ioo (i.addNat m) (j.addNat m)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNatEmb : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.Ioo i j = Set.Ioo (i.addNat m) (j.addNat m)"}]}
{"declaration": "theorem map_addNatEmb_uIcc (m) (i j : Fin n) :\n    (uIcc i j).map (addNatEmb m) = uIcc (i.addNat m) (j.addNat m) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNatEmb : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 map sorry (uIcc i j) = uIcc (i.addNat m) (j.addNat m)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNatEmb : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.uIcc i j = Set.uIcc (i.addNat m) (j.addNat m)"}]}
{"declaration": "theorem map_addNatEmb_Ici (m) (i : Fin n) : (Ici i).map (addNatEmb m) = Ici (i.addNat m) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNatEmb : x\u271d\nm : \u2115\ni : Fin n\n\u22a2 map sorry (Ici i) = Ici (i.addNat m)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNatEmb : x\u271d\nm : \u2115\ni : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.Ici i = Set.Ici (i.addNat m)"}]}
{"declaration": "theorem map_addNatEmb_Ioi (m) (i : Fin n) : (Ioi i).map (addNatEmb m) = Ioi (i.addNat m) := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNatEmb : x\u271d\nm : \u2115\ni : Fin n\n\u22a2 map sorry (Ioi i) = Ioi (i.addNat m)"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNatEmb : x\u271d\nm : \u2115\ni : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.Ioi i = Set.Ioi (i.addNat m)"}]}
{"declaration": "theorem finsetImage_succ_Iic (i : Fin n) : (Iic i).image succ = Ioc 0 i.succ := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nsucc : Fin n \u2192 Fin (n + 1)\ni : Fin n\n\u22a2 image succ (Iic i) = Ioc 0 i.succ"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nsucc : Fin n \u2192 Fin (n + 1)\ni : Fin n\n\u22a2 succ '' Set.Iic i = Set.Ioc 0 i.succ"}]}
{"declaration": "theorem finsetImage_succ_Iio (i : Fin n) : (Iio i).image succ = Ioo 0 i.succ := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nsucc : Fin n \u2192 Fin (n + 1)\ni : Fin n\n\u22a2 image succ (Iio i) = Ioo 0 i.succ"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nsucc : Fin n \u2192 Fin (n + 1)\ni : Fin n\n\u22a2 succ '' Set.Iio i = Set.Ioo 0 i.succ"}]}
{"declaration": "theorem map_succEmb_Iic (i : Fin n) : (Iic i).map (succEmb n) = Ioc 0 i.succ := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nsuccEmb : x\u271d\ni : Fin n\n\u22a2 map sorry (Iic i) = Ioc 0 i.succ"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nsuccEmb : x\u271d\ni : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.Iic i = Set.Ioc 0 i.succ"}]}
{"declaration": "theorem map_succEmb_Iio (i : Fin n) : (Iio i).map (succEmb n) = Ioo 0 i.succ := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nsuccEmb : x\u271d\ni : Fin n\n\u22a2 map sorry (Iio i) = Ioo 0 i.succ"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nsuccEmb : x\u271d\ni : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.Iio i = Set.Ioo 0 i.succ"}]}
{"declaration": "theorem finsetImage_rev_Icc (i j : Fin n) : (Icc i j).image rev = Icc j.rev i.rev := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni j : Fin n\n\u22a2 image rev (Icc i j) = Icc j.rev i.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni j : Fin n\n\u22a2 rev '' Set.Icc i j = Set.Icc j.rev i.rev"}]}
{"declaration": "theorem finsetImage_rev_Ico (i j : Fin n) : (Ico i j).image rev = Ioc j.rev i.rev := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni j : Fin n\n\u22a2 image rev (Ico i j) = Ioc j.rev i.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni j : Fin n\n\u22a2 rev '' Set.Ico i j = Set.Ioc j.rev i.rev"}]}
{"declaration": "theorem finsetImage_rev_Ioc (i j : Fin n) : (Ioc i j).image rev = Ico j.rev i.rev := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni j : Fin n\n\u22a2 image rev (Ioc i j) = Ico j.rev i.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni j : Fin n\n\u22a2 rev '' Set.Ioc i j = Set.Ico j.rev i.rev"}]}
{"declaration": "theorem finsetImage_rev_Ioo (i j : Fin n) : (Ioo i j).image rev = Ioo j.rev i.rev := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni j : Fin n\n\u22a2 image rev (Ioo i j) = Ioo j.rev i.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni j : Fin n\n\u22a2 rev '' Set.Ioo i j = Set.Ioo j.rev i.rev"}]}
{"declaration": "theorem finsetImage_rev_uIcc (i j : Fin n) : (uIcc i j).image rev = uIcc i.rev j.rev := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni j : Fin n\n\u22a2 image rev (uIcc i j) = uIcc i.rev j.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni j : Fin n\n\u22a2 rev '' Set.uIcc i j = Set.uIcc i.rev j.rev"}]}
{"declaration": "theorem finsetImage_rev_Ici (i : Fin n) : (Ici i).image rev = Iic i.rev := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni : Fin n\n\u22a2 image rev (Ici i) = Iic i.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni : Fin n\n\u22a2 rev '' Set.Ici i = Set.Iic i.rev"}]}
{"declaration": "theorem finsetImage_rev_Ioi (i : Fin n) : (Ioi i).image rev = Iio i.rev := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni : Fin n\n\u22a2 image rev (Ioi i) = Iio i.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni : Fin n\n\u22a2 rev '' Set.Ioi i = Set.Iio i.rev"}]}
{"declaration": "theorem finsetImage_rev_Iic (i : Fin n) : (Iic i).image rev = Ici i.rev := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni : Fin n\n\u22a2 image rev (Iic i) = Ici i.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni : Fin n\n\u22a2 rev '' Set.Iic i = Set.Ici i.rev"}]}
{"declaration": "theorem finsetImage_rev_Iio (i : Fin n) : (Iio i).image rev = Ioi i.rev := by simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni : Fin n\n\u22a2 image rev (Iio i) = Ioi i.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni : Fin n\n\u22a2 rev '' Set.Iio i = Set.Ioi i.rev"}]}
{"declaration": "theorem map_revPerm_Icc (i j : Fin n) : (Icc i j).map revPerm.toEmbedding = Icc j.rev i.rev := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 map sorry (Icc i j) = Icc j.rev i.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.Icc i j = Set.Icc j.rev i.rev"}]}
{"declaration": "theorem map_revPerm_Ico (i j : Fin n) : (Ico i j).map revPerm.toEmbedding = Ioc j.rev i.rev := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 map sorry (Ico i j) = Ioc j.rev i.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.Ico i j = Set.Ioc j.rev i.rev"}]}
{"declaration": "theorem map_revPerm_Ioc (i j : Fin n) : (Ioc i j).map revPerm.toEmbedding = Ico j.rev i.rev := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 map sorry (Ioc i j) = Ico j.rev i.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.Ioc i j = Set.Ico j.rev i.rev"}]}
{"declaration": "theorem map_revPerm_Ioo (i j : Fin n) : (Ioo i j).map revPerm.toEmbedding = Ioo j.rev i.rev := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 map sorry (Ioo i j) = Ioo j.rev i.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.Ioo i j = Set.Ioo j.rev i.rev"}]}
{"declaration": "theorem map_revPerm_uIcc (i j : Fin n) : (uIcc i j).map revPerm.toEmbedding = uIcc i.rev j.rev := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 map sorry (uIcc i j) = uIcc i.rev j.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.uIcc i j = Set.uIcc i.rev j.rev"}]}
{"declaration": "theorem map_revPerm_Ici (i : Fin n) : (Ici i).map revPerm.toEmbedding = Iic i.rev := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 map sorry (Ici i) = Iic i.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.Ici i = Set.Iic i.rev"}]}
{"declaration": "theorem map_revPerm_Ioi (i : Fin n) : (Ioi i).map revPerm.toEmbedding = Iio i.rev := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 map sorry (Ioi i) = Iio i.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.Ioi i = Set.Iio i.rev"}]}
{"declaration": "theorem map_revPerm_Iic (i : Fin n) : (Iic i).map revPerm.toEmbedding = Ici i.rev := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 map sorry (Iic i) = Ici i.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.Iic i = Set.Ici i.rev"}]}
{"declaration": "theorem map_revPerm_Iio (i : Fin n) : (Iio i).map revPerm.toEmbedding = Ioi i.rev := by\n  simp [\u2190 coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 map sorry (Iio i) = Ioi i.rev"}, {"line": "simp [\u2190 coe_inj]", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 \u21d1(sorry ()) '' Set.Iio i = Set.Ioi i.rev"}]}
{"declaration": "theorem card_fintypeIcc : Fintype.card (Set.Icc a b) = b + 1 - a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : Fin n\n\u22a2 Fintype.card \u2191(Set.Icc a b) = \u2191b + 1 - \u2191a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintypeIco : Fintype.card (Set.Ico a b) = b - a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : Fin n\n\u22a2 Fintype.card \u2191(Set.Ico a b) = \u2191b - \u2191a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintypeIoc : Fintype.card (Set.Ioc a b) = b - a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : Fin n\n\u22a2 Fintype.card \u2191(Set.Ioc a b) = \u2191b - \u2191a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintypeIoo : Fintype.card (Set.Ioo a b) = b - a - 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : Fin n\n\u22a2 Fintype.card \u2191(Set.Ioo a b) = \u2191b - \u2191a - 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintypeIci : Fintype.card (Set.Ici a) = n - a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na : Fin n\n\u22a2 Fintype.card \u2191(Set.Ici a) = n - \u2191a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintypeIoi : Fintype.card (Set.Ioi a) = n - 1 - a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na : Fin n\n\u22a2 Fintype.card \u2191(Set.Ioi a) = n - 1 - \u2191a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintypeIic : Fintype.card (Set.Iic b) = b + 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nb : Fin n\n\u22a2 Fintype.card \u2191(Set.Iic b) = \u2191b + 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintypeIio : Fintype.card (Set.Iio b) = b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Fin.lean", "context": {"open": ["Finset Function"], "variables": ["(n : \u2115)", "{n}", "{m : \u2115} (a b : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nb : Fin n\n\u22a2 Fintype.card \u2191(Set.Iio b) = \u2191b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Iio_eq_range : Iio = range := by\n  ext b x\n  rw [mem_Iio]\n  rw [mem_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Iio = range"}, {"line": "ext b x", "tactic_state": "case h.h\nb x : \u2115\n\u22a2 x \u2208 Iio b \u2194 x \u2208 range b"}, {"line": "rw [mem_Iio]", "tactic_state": "case h.h\nb x : \u2115\n\u22a2 x < b \u2194 x \u2208 range b"}, {"line": "rw [mem_range]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ico_zero_eq_range : Ico 0 = range := by rw [\u2190 Nat.bot_eq_zero, \u2190 Iio_eq_Ico, Iio_eq_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Ico 0 = range"}, {"line": "rw [\u2190 Nat.bot_eq_zero, \u2190 Iio_eq_Ico, Iio_eq_range]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma range_eq_Icc_zero_sub_one (n : \u2115) (hn : n \u2260 0) : range n = Icc 0 (n - 1) := by\n  ext b\n  simp_all only [mem_Icc, zero_le, true_and, mem_range]\n  exact lt_iff_le_pred (zero_lt_of_ne_zero hn)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : n \u2260 0\n\u22a2 range n = Icc 0 (n - 1)"}, {"line": "ext b", "tactic_state": "case h\nn : \u2115\nhn : n \u2260 0\nb : \u2115\n\u22a2 b \u2208 range n \u2194 b \u2208 Icc 0 (n - 1)"}, {"line": "simp_all only [mem_Icc, zero_le, true_and, mem_range]", "tactic_state": "case h\nn : \u2115\nhn : n \u2260 0\nb : \u2115\n\u22a2 b < n \u2194 b \u2264 n - 1"}, {"line": "exact lt_iff_le_pred (zero_lt_of_ne_zero hn)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_succ_eq_Icc_zero (n : \u2115) : range (n + 1) = Icc 0 n := by\n  rw [range_eq_Icc_zero_sub_one _ (Nat.add_one_ne_zero _)]\n  rw [Nat.add_sub_cancel_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 range (n + 1) = Icc 0 n"}, {"line": "rw [range_eq_Icc_zero_sub_one _ (Nat.add_one_ne_zero _)]", "tactic_state": "n : \u2115\n\u22a2 Icc 0 (n + 1 - 1) = Icc 0 n"}, {"line": "rw [Nat.add_sub_cancel_right]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_Iic : #(Iic b) = b + 1 := by rw [Iic_eq_Icc, card_Icc, Nat.bot_eq_zero, Nat.sub_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u2115\n\u22a2 (Iic b).card = b + 1"}, {"line": "rw [Iic_eq_Icc, card_Icc, Nat.bot_eq_zero, Nat.sub_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_Iio : #(Iio b) = b := by rw [Iio_eq_Ico, card_Ico, Nat.bot_eq_zero, Nat.sub_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u2115\n\u22a2 (Iio b).card = b"}, {"line": "rw [Iio_eq_Ico, card_Ico, Nat.bot_eq_zero, Nat.sub_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintypeIcc : Fintype.card (Set.Icc a b) = b + 1 - a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 Fintype.card \u2191(Set.Icc a b) = b + 1 - a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintypeIco : Fintype.card (Set.Ico a b) = b - a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 Fintype.card \u2191(Set.Ico a b) = b - a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintypeIoc : Fintype.card (Set.Ioc a b) = b - a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 Fintype.card \u2191(Set.Ioc a b) = b - a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintypeIoo : Fintype.card (Set.Ioo a b) = b - a - 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 Fintype.card \u2191(Set.Ioo a b) = b - a - 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintypeIic : Fintype.card (Set.Iic b) = b + 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u2115\n\u22a2 Fintype.card \u2191(Set.Iic b) = b + 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintypeIio : Fintype.card (Set.Iio b) = b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u2115\n\u22a2 Fintype.card \u2191(Set.Iio b) = b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Icc_succ_left : Icc a.succ b = Ioc a b := by\n  ext x\n  rw [mem_Icc]\n  rw [mem_Ioc]\n  rw [succ_le_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 Icc a.succ b = Ioc a b"}, {"line": "ext x", "tactic_state": "case h\na b x : \u2115\n\u22a2 x \u2208 Icc a.succ b \u2194 x \u2208 Ioc a b"}, {"line": "rw [mem_Icc]", "tactic_state": "case h\na b x : \u2115\n\u22a2 a.succ \u2264 x \u2227 x \u2264 b \u2194 x \u2208 Ioc a b"}, {"line": "rw [mem_Ioc]", "tactic_state": "case h\na b x : \u2115\n\u22a2 a.succ \u2264 x \u2227 x \u2264 b \u2194 a < x \u2227 x \u2264 b"}, {"line": "rw [succ_le_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ico_succ_right : Ico a b.succ = Icc a b := by\n  ext x\n  rw [mem_Ico]\n  rw [mem_Icc]\n  rw [Nat.lt_succ_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 Ico a b.succ = Icc a b"}, {"line": "ext x", "tactic_state": "case h\na b x : \u2115\n\u22a2 x \u2208 Ico a b.succ \u2194 x \u2208 Icc a b"}, {"line": "rw [mem_Ico]", "tactic_state": "case h\na b x : \u2115\n\u22a2 a \u2264 x \u2227 x < b.succ \u2194 x \u2208 Icc a b"}, {"line": "rw [mem_Icc]", "tactic_state": "case h\na b x : \u2115\n\u22a2 a \u2264 x \u2227 x < b.succ \u2194 a \u2264 x \u2227 x \u2264 b"}, {"line": "rw [Nat.lt_succ_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ico_succ_left : Ico a.succ b = Ioo a b := by\n  ext x\n  rw [mem_Ico]\n  rw [mem_Ioo]\n  rw [succ_le_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 Ico a.succ b = Ioo a b"}, {"line": "ext x", "tactic_state": "case h\na b x : \u2115\n\u22a2 x \u2208 Ico a.succ b \u2194 x \u2208 Ioo a b"}, {"line": "rw [mem_Ico]", "tactic_state": "case h\na b x : \u2115\n\u22a2 a.succ \u2264 x \u2227 x < b \u2194 x \u2208 Ioo a b"}, {"line": "rw [mem_Ioo]", "tactic_state": "case h\na b x : \u2115\n\u22a2 a.succ \u2264 x \u2227 x < b \u2194 a < x \u2227 x < b"}, {"line": "rw [succ_le_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Icc_pred_right {b : \u2115} (h : 0 < b) : Icc a (b - 1) = Ico a b := by\n  ext x\n  rw [mem_Icc]\n  rw [mem_Ico]\n  rw [lt_iff_le_pred h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : 0 < b\n\u22a2 Icc a (b - 1) = Ico a b"}, {"line": "ext x", "tactic_state": "case h\na b : \u2115\nh : 0 < b\nx : \u2115\n\u22a2 x \u2208 Icc a (b - 1) \u2194 x \u2208 Ico a b"}, {"line": "rw [mem_Icc]", "tactic_state": "case h\na b : \u2115\nh : 0 < b\nx : \u2115\n\u22a2 a \u2264 x \u2227 x \u2264 b - 1 \u2194 x \u2208 Ico a b"}, {"line": "rw [mem_Ico]", "tactic_state": "case h\na b : \u2115\nh : 0 < b\nx : \u2115\n\u22a2 a \u2264 x \u2227 x \u2264 b - 1 \u2194 a \u2264 x \u2227 x < b"}, {"line": "rw [lt_iff_le_pred h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ico_succ_succ : Ico a.succ b.succ = Ioc a b := by\n  ext x\n  rw [mem_Ico]\n  rw [mem_Ioc]\n  rw [succ_le_iff]\n  rw [Nat.lt_succ_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 Ico a.succ b.succ = Ioc a b"}, {"line": "ext x", "tactic_state": "case h\na b x : \u2115\n\u22a2 x \u2208 Ico a.succ b.succ \u2194 x \u2208 Ioc a b"}, {"line": "rw [mem_Ico]", "tactic_state": "case h\na b x : \u2115\n\u22a2 a.succ \u2264 x \u2227 x < b.succ \u2194 x \u2208 Ioc a b"}, {"line": "rw [mem_Ioc]", "tactic_state": "case h\na b x : \u2115\n\u22a2 a.succ \u2264 x \u2227 x < b.succ \u2194 a < x \u2227 x \u2264 b"}, {"line": "rw [succ_le_iff]", "tactic_state": "case h\na b x : \u2115\n\u22a2 a < x \u2227 x < b.succ \u2194 a < x \u2227 x \u2264 b"}, {"line": "rw [Nat.lt_succ_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ico_succ_singleton : Ico a (a + 1) = {a} := by rw [Ico_succ_right, Icc_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 Ico a (a + 1) = {a}"}, {"line": "rw [Ico_succ_right, Icc_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ico_pred_singleton {a : \u2115} (h : 0 < a) : Ico (a - 1) a = {a - 1} := by\n  rw [\u2190 Icc_pred_right _ h]\n  rw [Icc_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\nh : 0 < a\n\u22a2 Ico (a - 1) a = {a - 1}"}, {"line": "rw [\u2190 Icc_pred_right _ h]", "tactic_state": "a : \u2115\nh : 0 < a\n\u22a2 Icc (a - 1) (a - 1) = {a - 1}"}, {"line": "rw [Icc_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ioc_succ_singleton : Ioc b (b + 1) = {b + 1} := by rw [\u2190 Nat.Icc_succ_left, Icc_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u2115\n\u22a2 Ioc b (b + 1) = {b + 1}"}, {"line": "rw [\u2190 Nat.Icc_succ_left, Icc_self]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_Ioc_succ : a \u2208 Ioc b (b + 1) \u2194 a = b + 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)", "{a b c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 a \u2208 Ioc b (b + 1) \u2194 a = b + 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ico_succ_right_eq_insert_Ico (h : a \u2264 b) : Ico a (b + 1) = insert b (Ico a b) := by\n  rw [Ico_succ_right]\n  rw [\u2190 Ico_insert_right h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)", "{a b c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a \u2264 b\n\u22a2 Ico a (b + 1) = insert b (Ico a b)"}, {"line": "rw [Ico_succ_right]", "tactic_state": "a b : \u2115\nh : a \u2264 b\n\u22a2 Icc a b = insert b (Ico a b)"}, {"line": "rw [\u2190 Ico_insert_right h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ico_insert_succ_left (h : a < b) : insert a (Ico a.succ b) = Ico a b := by\n  rw [Ico_succ_left]\n  rw [\u2190 Ioo_insert_left h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)", "{a b c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a < b\n\u22a2 insert a (Ico a.succ b) = Ico a b"}, {"line": "rw [Ico_succ_left]", "tactic_state": "a b : \u2115\nh : a < b\n\u22a2 insert a (Ioo a b) = Ico a b"}, {"line": "rw [\u2190 Ioo_insert_left h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Icc_insert_succ_left (h : a \u2264 b) : insert a (Icc (a + 1) b) = Icc a b := by\n  ext x\n  simp only [mem_insert]\n  simp only [mem_Icc]\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)", "{a b c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a \u2264 b\n\u22a2 insert a (Icc (a + 1) b) = Icc a b"}, {"line": "ext x", "tactic_state": "case h\na b : \u2115\nh : a \u2264 b\nx : \u2115\n\u22a2 x \u2208 insert a (Icc (a + 1) b) \u2194 x \u2208 Icc a b"}, {"line": "simp only [mem_insert]", "tactic_state": "case h\na b : \u2115\nh : a \u2264 b\nx : \u2115\n\u22a2 x = a \u2228 x \u2208 Icc (a + 1) b \u2194 x \u2208 Icc a b"}, {"line": "simp only [mem_Icc]", "tactic_state": "case h\na b : \u2115\nh : a \u2264 b\nx : \u2115\n\u22a2 x = a \u2228 a + 1 \u2264 x \u2227 x \u2264 b \u2194 a \u2264 x \u2227 x \u2264 b"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Icc_insert_succ_right (h : a \u2264 b + 1) : insert (b + 1) (Icc a b) = Icc a (b + 1) := by\n  ext x\n  simp only [mem_insert]\n  simp only [mem_Icc]\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)", "{a b c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a \u2264 b + 1\n\u22a2 insert (b + 1) (Icc a b) = Icc a (b + 1)"}, {"line": "ext x", "tactic_state": "case h\na b : \u2115\nh : a \u2264 b + 1\nx : \u2115\n\u22a2 x \u2208 insert (b + 1) (Icc a b) \u2194 x \u2208 Icc a (b + 1)"}, {"line": "simp only [mem_insert]", "tactic_state": "case h\na b : \u2115\nh : a \u2264 b + 1\nx : \u2115\n\u22a2 x = b + 1 \u2228 x \u2208 Icc a b \u2194 x \u2208 Icc a (b + 1)"}, {"line": "simp only [mem_Icc]", "tactic_state": "case h\na b : \u2115\nh : a \u2264 b + 1\nx : \u2115\n\u22a2 x = b + 1 \u2228 a \u2264 x \u2227 x \u2264 b \u2194 a \u2264 x \u2227 x \u2264 b + 1"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_sub_const_Ico (h : c \u2264 a) :\n    ((Ico a b).image fun x => x - c) = Ico (a - c) (b - c) := by\n  ext x\n  simp_rw [mem_image, mem_Ico]\n  refine \u27e8?_, fun h \u21a6 \u27e8x + c, by omega\u27e9\u27e9\n  rintro \u27e8x, hx, rfl\u27e9\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)", "{a b c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : c \u2264 a\n\u22a2 image (fun x => x - c) (Ico a b) = Ico (a - c) (b - c)"}, {"line": "ext x", "tactic_state": "case h\na b c : \u2115\nh : c \u2264 a\nx : \u2115\n\u22a2 x \u2208 image (fun x => x - c) (Ico a b) \u2194 x \u2208 Ico (a - c) (b - c)"}, {"line": "simp_rw [mem_image, mem_Ico]", "tactic_state": "case h\na b c : \u2115\nh : c \u2264 a\nx : \u2115\n\u22a2 (\u2203 a_1, (a \u2264 a_1 \u2227 a_1 < b) \u2227 a_1 - c = x) \u2194 a - c \u2264 x \u2227 x < b - c"}, {"line": "refine \u27e8?_, fun h \u21a6 \u27e8x + c, by omega\u27e9\u27e9", "tactic_state": "case h\na b c : \u2115\nh : c \u2264 a\nx : \u2115\n\u22a2 (\u2203 a_1, (a \u2264 a_1 \u2227 a_1 < b) \u2227 a_1 - c = x) \u2192 a - c \u2264 x \u2227 x < b - c"}, {"line": "rintro \u27e8x, hx, rfl\u27e9", "tactic_state": "case h.intro.intro\na b c : \u2115\nh : c \u2264 a\nx : \u2115\nhx : a \u2264 x \u2227 x < b\n\u22a2 a - c \u2264 x - c \u2227 x - c < b - c"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ico_image_const_sub_eq_Ico (hac : a \u2264 c) :\n    ((Ico a b).image fun x => c - x) = Ico (c + 1 - b) (c + 1 - a) := by\n  ext x\n  simp_rw [mem_image, mem_Ico]\n  refine \u27e8?_, fun h \u21a6 \u27e8c - x, by omega\u27e9\u27e9\n  rintro \u27e8x, hx, rfl\u27e9\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)", "{a b c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nhac : a \u2264 c\n\u22a2 image (fun x => c - x) (Ico a b) = Ico (c + 1 - b) (c + 1 - a)"}, {"line": "ext x", "tactic_state": "case h\na b c : \u2115\nhac : a \u2264 c\nx : \u2115\n\u22a2 x \u2208 image (fun x => c - x) (Ico a b) \u2194 x \u2208 Ico (c + 1 - b) (c + 1 - a)"}, {"line": "simp_rw [mem_image, mem_Ico]", "tactic_state": "case h\na b c : \u2115\nhac : a \u2264 c\nx : \u2115\n\u22a2 (\u2203 a_1, (a \u2264 a_1 \u2227 a_1 < b) \u2227 c - a_1 = x) \u2194 c + 1 - b \u2264 x \u2227 x < c + 1 - a"}, {"line": "refine \u27e8?_, fun h \u21a6 \u27e8c - x, by omega\u27e9\u27e9", "tactic_state": "case h\na b c : \u2115\nhac : a \u2264 c\nx : \u2115\n\u22a2 (\u2203 a_1, (a \u2264 a_1 \u2227 a_1 < b) \u2227 c - a_1 = x) \u2192 c + 1 - b \u2264 x \u2227 x < c + 1 - a"}, {"line": "rintro \u27e8x, hx, rfl\u27e9", "tactic_state": "case h.intro.intro\na b c : \u2115\nhac : a \u2264 c\nx : \u2115\nhx : a \u2264 x \u2227 x < b\n\u22a2 c + 1 - b \u2264 c - x \u2227 c - x < c + 1 - a"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ico_succ_left_eq_erase_Ico : Ico a.succ b = erase (Ico a b) a := by\n  ext x\n  rw [Ico_succ_left]\n  rw [mem_erase]\n  rw [mem_Ico]\n  rw [mem_Ioo]\n  rw [\u2190 and_assoc]\n  rw [ne_comm]\n  rw [and_comm (a := a \u2260 x)]\n  rw [lt_iff_le_and_ne]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat"], "variables": ["(a b c : \u2115)", "{a b c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 Ico a.succ b = (Ico a b).erase a"}, {"line": "ext x", "tactic_state": "case h\na b x : \u2115\n\u22a2 x \u2208 Ico a.succ b \u2194 x \u2208 (Ico a b).erase a"}, {"line": "rw [Ico_succ_left]", "tactic_state": "case h\na b x : \u2115\n\u22a2 x \u2208 Ioo a b \u2194 x \u2208 (Ico a b).erase a"}, {"line": "rw [mem_erase]", "tactic_state": "case h\na b x : \u2115\n\u22a2 x \u2208 Ioo a b \u2194 x \u2260 a \u2227 x \u2208 Ico a b"}, {"line": "rw [mem_Ico]", "tactic_state": "case h\na b x : \u2115\n\u22a2 x \u2208 Ioo a b \u2194 x \u2260 a \u2227 a \u2264 x \u2227 x < b"}, {"line": "rw [mem_Ioo]", "tactic_state": "case h\na b x : \u2115\n\u22a2 a < x \u2227 x < b \u2194 x \u2260 a \u2227 a \u2264 x \u2227 x < b"}, {"line": "rw [\u2190 and_assoc]", "tactic_state": "case h\na b x : \u2115\n\u22a2 a < x \u2227 x < b \u2194 (x \u2260 a \u2227 a \u2264 x) \u2227 x < b"}, {"line": "rw [ne_comm]", "tactic_state": "case h\na b x : \u2115\n\u22a2 a < x \u2227 x < b \u2194 (a \u2260 x \u2227 a \u2264 x) \u2227 x < b"}, {"line": "rw [and_comm (a := a \u2260 x)]", "tactic_state": "case h\na b x : \u2115\n\u22a2 a < x \u2227 x < b \u2194 (a \u2264 x \u2227 a \u2260 x) \u2227 x < b"}, {"line": "rw [lt_iff_le_and_ne]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiset_Ico_map_mod (n a : \u2115) :\n    (Multiset.Ico n (n + a)).map (\u00b7 % a) = Multiset.range a := by\n  convert congr_arg Finset.val (image_Ico_mod n a)\n  refine ((nodup_map_iff_inj_on (Finset.Ico _ _).nodup).2 <| ?_).dedup.symm\n  exact mod_injOn_Ico _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat", "Multiset"], "variables": ["(a b c : \u2115)", "{a b c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n a : \u2115\n\u22a2 Multiset.map (fun x => x % a) (Multiset.Ico n (n + a)) = Multiset.range a"}, {"line": "convert congr_arg Finset.val (image_Ico_mod n a)", "tactic_state": "case h.e'_2\nn a : \u2115\n\u22a2 Multiset.map (fun x => x % a) (Multiset.Ico n (n + a)) = (image (fun x => x % a) (Finset.Ico n (n + a))).val"}, {"line": "refine ((nodup_map_iff_inj_on (Finset.Ico _ _).nodup).2 <| ?_).dedup.symm", "tactic_state": "case h.e'_2\nn a : \u2115\n\u22a2 \u2200 x \u2208 (Finset.Ico n (n + a)).val, \u2200 y \u2208 (Finset.Ico n (n + a)).val, x % a = y % a \u2192 x = y"}, {"line": "exact mod_injOn_Ico _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nat.cauchy_induction' (seed : \u2115) (h : \u2200 n, P (n + 1) \u2192 P n) (hs : P seed)\n    (hi : \u2200 x, seed \u2264 x \u2192 P x \u2192 \u2203 y, x < y \u2227 P y) (n : \u2115) : P n := by\n  apply Nat.decreasing_induction_of_infinite h fun hf => _\n  intro hf\n  obtain \u27e8m, hP, hm\u27e9 := hf.exists_maximal_wrt id _ \u27e8seed, hs\u27e9\n  obtain \u27e8y, hl, hy\u27e9 := hi m (le_of_not_lt fun hl => hl.ne <| hm seed hs hl.le) hP\n  exact hl.ne (hm y hy hl.le)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat", "Multiset"], "variables": ["(a b c : \u2115)", "{a b c}", "{P : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : \u2115 \u2192 Prop\nseed : \u2115\nh : \u2200 (n : \u2115), P (n + 1) \u2192 P n\nhs : P seed\nhi : \u2200 (x : \u2115), seed \u2264 x \u2192 P x \u2192 \u2203 y, x < y \u2227 P y\nn : \u2115\n\u22a2 P n"}, {"line": "apply Nat.decreasing_induction_of_infinite h fun hf => _", "tactic_state": "P : \u2115 \u2192 Prop\nseed : \u2115\nh : \u2200 (n : \u2115), P (n + 1) \u2192 P n\nhs : P seed\nhi : \u2200 (x : \u2115), seed \u2264 x \u2192 P x \u2192 \u2203 y, x < y \u2227 P y\nn : \u2115\n\u22a2 {x | P x}.Finite \u2192 False"}, {"line": "intro hf", "tactic_state": "P : \u2115 \u2192 Prop\nseed : \u2115\nh : \u2200 (n : \u2115), P (n + 1) \u2192 P n\nhs : P seed\nhi : \u2200 (x : \u2115), seed \u2264 x \u2192 P x \u2192 \u2203 y, x < y \u2227 P y\nn : \u2115\nhf : {x | P x}.Finite\n\u22a2 False"}, {"line": "obtain \u27e8m, hP, hm\u27e9 := hf.exists_maximal_wrt id _ \u27e8seed, hs\u27e9", "tactic_state": "case intro.intro\nP : \u2115 \u2192 Prop\nseed : \u2115\nh : \u2200 (n : \u2115), P (n + 1) \u2192 P n\nhs : P seed\nhi : \u2200 (x : \u2115), seed \u2264 x \u2192 P x \u2192 \u2203 y, x < y \u2227 P y\nn : \u2115\nhf : {x | P x}.Finite\nm : \u2115\nhP : m \u2208 {x | P x}\nhm : \u2200 a' \u2208 {x | P x}, id m \u2264 id a' \u2192 id m = id a'\n\u22a2 False"}, {"line": "obtain \u27e8y, hl, hy\u27e9 := hi m (le_of_not_lt fun hl => hl.ne <| hm seed hs hl.le) hP", "tactic_state": "case intro.intro.intro.intro\nP : \u2115 \u2192 Prop\nseed : \u2115\nh : \u2200 (n : \u2115), P (n + 1) \u2192 P n\nhs : P seed\nhi : \u2200 (x : \u2115), seed \u2264 x \u2192 P x \u2192 \u2203 y, x < y \u2227 P y\nn : \u2115\nhf : {x | P x}.Finite\nm : \u2115\nhP : m \u2208 {x | P x}\nhm : \u2200 a' \u2208 {x | P x}, id m \u2264 id a' \u2192 id m = id a'\ny : \u2115\nhl : m < y\nhy : P y\n\u22a2 False"}, {"line": "exact hl.ne (hm y hy hl.le)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nat.cauchy_induction_mul (h : \u2200 (n : \u2115), P (n + 1) \u2192 P n) (k seed : \u2115) (hk : 1 < k)\n    (hs : P seed.succ) (hm : \u2200 x, seed < x \u2192 P x \u2192 P (k * x)) (n : \u2115) : P n := by\n  apply Nat.cauchy_induction h _ hs (k * \u00b7) fun x hl hP => \u27e8_, hm x hl hP\u27e9\n  intro _ hl _\n  convert (Nat.mul_lt_mul_right <| seed.succ_pos.trans_le hl).2 hk\n  rw [one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Finset/Nat.lean", "context": {"open": ["Finset Nat", "Multiset"], "variables": ["(a b c : \u2115)", "{a b c}", "{P : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : \u2115 \u2192 Prop\nh : \u2200 (n : \u2115), P (n + 1) \u2192 P n\nk seed : \u2115\nhk : 1 < k\nhs : P seed.succ\nhm : \u2200 (x : \u2115), seed < x \u2192 P x \u2192 P (k * x)\nn : \u2115\n\u22a2 P n"}, {"line": "apply Nat.cauchy_induction h _ hs (k * \u00b7) fun x hl hP => \u27e8_, hm x hl hP\u27e9", "tactic_state": "P : \u2115 \u2192 Prop\nh : \u2200 (n : \u2115), P (n + 1) \u2192 P n\nk seed : \u2115\nhk : 1 < k\nhs : P seed.succ\nhm : \u2200 (x : \u2115), seed < x \u2192 P x \u2192 P (k * x)\nn : \u2115\n\u22a2 \u2200 (x : \u2115), seed.succ \u2264 x \u2192 P x \u2192 x < (fun x => k * x) x"}, {"line": "intro _ hl _", "tactic_state": "P : \u2115 \u2192 Prop\nh : \u2200 (n : \u2115), P (n + 1) \u2192 P n\nk seed : \u2115\nhk : 1 < k\nhs : P seed.succ\nhm : \u2200 (x : \u2115), seed < x \u2192 P x \u2192 P (k * x)\nn x\u271d : \u2115\nhl : seed.succ \u2264 x\u271d\nhP\u271d : P x\u271d\n\u22a2 x\u271d < (fun x => k * x) x\u271d"}, {"line": "convert (Nat.mul_lt_mul_right <| seed.succ_pos.trans_le hl).2 hk", "tactic_state": "case h.e'_3\nP : \u2115 \u2192 Prop\nh : \u2200 (n : \u2115), P (n + 1) \u2192 P n\nk seed : \u2115\nhk : 1 < k\nhs : P seed.succ\nhm : \u2200 (x : \u2115), seed < x \u2192 P x \u2192 P (k * x)\nn x\u271d : \u2115\nhl : seed.succ \u2264 x\u271d\nhP\u271d : P x\u271d\n\u22a2 x\u271d = 1 * x\u271d"}, {"line": "rw [one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_natAdd (m n : \u2115) : range (natAdd m : Fin n \u2192 Fin (m + n)) = {i | m \u2264 i.1} := by\n  ext i\n  constructor\n  \u00b7 rintro \u27e8i, rfl\u27e9\n    apply le_coe_natAdd\n  \u00b7 refine fun (hi : m \u2264 i) \u21a6 \u27e8\u27e8i - m, by omega\u27e9, ?_\u27e9\n    ext\n    simp [hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Fin.lean", "context": {"open": ["Function Set"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nnatAdd : x\u271d\nm n : \u2115\n\u22a2 range sorry = {i | m \u2264 \u2191i}"}, {"line": "ext i", "tactic_state": "case h\nx\u271d : Sort u_1\nnatAdd : x\u271d\nm n : \u2115\ni : Fin (m + n)\n\u22a2 i \u2208 range sorry \u2194 i \u2208 {i | m \u2264 \u2191i}"}, {"line": "constructor", "tactic_state": "case h.mp\nx\u271d : Sort u_1\nnatAdd : x\u271d\nm n : \u2115\ni : Fin (m + n)\n\u22a2 i \u2208 range sorry \u2192 i \u2208 {i | m \u2264 \u2191i}\n---\ncase h.mpr\nx\u271d : Sort u_1\nnatAdd : x\u271d\nm n : \u2115\ni : Fin (m + n)\n\u22a2 i \u2208 {i | m \u2264 \u2191i} \u2192 i \u2208 range sorry"}, {"line": "\u00b7 rintro \u27e8i, rfl\u27e9\n    apply le_coe_natAdd", "tactic_state": "case h.mpr\nx\u271d : Sort u_1\nnatAdd : x\u271d\nm n : \u2115\ni : Fin (m + n)\n\u22a2 i \u2208 {i | m \u2264 \u2191i} \u2192 i \u2208 range sorry"}, {"line": "\u00b7 refine fun (hi : m \u2264 i) \u21a6 \u27e8\u27e8i - m, by omega\u27e9, ?_\u27e9\n    ext\n    simp [hi]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_natAdd_eq_Ioi (m n : \u2115) [NeZero m] :\n    range (natAdd m : Fin n \u2192 Fin (m + n)) = Ioi (castAdd n \u22a4) := by\n  ext \u27e8_, _\u27e9\n  simp [range_natAdd, lt_def, \u2190 Nat.succ_le_iff, Nat.one_le_iff_ne_zero.mpr (NeZero.ne m)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Fin.lean", "context": {"open": ["Function Set"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nnatAdd : x\u271d\u00b9\nx\u271d : Sort u_2\ncastAdd : x\u271d\nm n : \u2115\ninst\u271d : NeZero m\n\u22a2 range sorry = Ioi sorry"}, {"line": "ext \u27e8_, _\u27e9", "tactic_state": "case h.mk\nx\u271d\u00b9 : Sort u_1\nnatAdd : x\u271d\u00b9\nx\u271d : Sort u_2\ncastAdd : x\u271d\nm n : \u2115\ninst\u271d : NeZero m\nval\u271d : \u2115\nisLt\u271d : val\u271d < m + n\n\u22a2 \u27e8val\u271d, isLt\u271d\u27e9 \u2208 range sorry \u2194 \u27e8val\u271d, isLt\u271d\u27e9 \u2208 Ioi sorry"}, {"line": "simp [range_natAdd, lt_def, \u2190 Nat.succ_le_iff, Nat.one_le_iff_ne_zero.mpr (NeZero.ne m)]", "tactic_state": "case h.mk\nx\u271d\u00b9 : Sort u_1\nnatAdd : x\u271d\u00b9\nx\u271d : Sort u_2\ncastAdd : x\u271d\nm n : \u2115\ninst\u271d : NeZero m\nval\u271d : \u2115\nisLt\u271d : val\u271d < m + n\n\u22a2 (\u2203 y, sorry () y = \u27e8val\u271d, isLt\u271d\u27e9) \u2194 sorry () < \u27e8val\u271d, isLt\u271d\u27e9"}]}
{"declaration": "theorem preimage_natAdd_uIcc_natAdd (m) (i j : Fin n) :\n    natAdd m \u207b\u00b9' uIcc (natAdd m i) (natAdd m j) = uIcc i j := by\n  simp [uIcc, \u2190 (strictMono_natAdd m).monotone.map_max, \u2190 (strictMono_natAdd m).monotone.map_min]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Fin.lean", "context": {"open": ["Function Set"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nnatAdd : x\u271d\nm : ?m.2364\ni j : Fin n\n\u22a2 sorry \u207b\u00b9' uIcc sorry sorry = uIcc i j"}, {"line": "simp [uIcc, \u2190 (strictMono_natAdd m).monotone.map_max, \u2190 (strictMono_natAdd m).monotone.map_min]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nnatAdd : x\u271d\nm : ?m.2364\ni j : Fin n\n\u22a2 sorry () \u207b\u00b9' Icc (sorry () \u2293 sorry ()) (sorry () \u2294 sorry ()) = Icc (min i j) (max i j)"}]}
{"declaration": "theorem preimage_natAdd_uIoc_natAdd (m) (i j : Fin n) :\n    natAdd m \u207b\u00b9' uIoc (natAdd m i) (natAdd m j) = uIoc i j := by\n  simp [uIoc, \u2190 (strictMono_natAdd m).monotone.map_max, \u2190 (strictMono_natAdd m).monotone.map_min]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Fin.lean", "context": {"open": ["Function Set"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nnatAdd : x\u271d\nm : ?m.2180\ni j : Fin n\n\u22a2 sorry \u207b\u00b9' uIoc sorry sorry = uIoc i j"}, {"line": "simp [uIoc, \u2190 (strictMono_natAdd m).monotone.map_max, \u2190 (strictMono_natAdd m).monotone.map_min]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nnatAdd : x\u271d\nm : ?m.2180\ni j : Fin n\n\u22a2 sorry () \u207b\u00b9' Ioc (sorry () \u2293 sorry ()) (sorry () \u2294 sorry ()) = Ioc (min i j) (max i j)"}]}
{"declaration": "theorem preimage_natAdd_uIoo_natAdd (m) (i j : Fin n) :\n    natAdd m \u207b\u00b9' uIoo (natAdd m i) (natAdd m j) = uIoo i j := by\n  simp [uIoo, \u2190 (strictMono_natAdd m).monotone.map_max, \u2190 (strictMono_natAdd m).monotone.map_min]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Fin.lean", "context": {"open": ["Function Set"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nnatAdd : x\u271d\nm : ?m.2180\ni j : Fin n\n\u22a2 sorry \u207b\u00b9' uIoo sorry sorry = uIoo i j"}, {"line": "simp [uIoo, \u2190 (strictMono_natAdd m).monotone.map_max, \u2190 (strictMono_natAdd m).monotone.map_min]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nnatAdd : x\u271d\nm : ?m.2180\ni j : Fin n\n\u22a2 sorry () \u207b\u00b9' Ioo (sorry () \u2293 sorry ()) (sorry () \u2294 sorry ()) = Ioo (min i j) (max i j)"}]}
{"declaration": "theorem image_natAdd_uIcc (m) (i j : Fin n) :\n    natAdd m '' uIcc i j = uIcc (natAdd m i) (natAdd m j) := by\n  simp [uIcc, \u2190 (strictMono_natAdd m).monotone.map_max, \u2190 (strictMono_natAdd m).monotone.map_min]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Fin.lean", "context": {"open": ["Function Set"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nnatAdd : x\u271d\nm : ?m.2207\ni j : Fin n\n\u22a2 sorry '' uIcc i j = uIcc sorry sorry"}, {"line": "simp [uIcc, \u2190 (strictMono_natAdd m).monotone.map_max, \u2190 (strictMono_natAdd m).monotone.map_min]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nnatAdd : x\u271d\nm : ?m.2207\ni j : Fin n\n\u22a2 sorry () '' Icc (min i j) (max i j) = Icc (sorry () \u2293 sorry ()) (sorry () \u2294 sorry ())"}]}
{"declaration": "theorem image_natAdd_uIoc (m) (i j : Fin n) :\n    natAdd m '' uIoc i j = uIoc (natAdd m i) (natAdd m j) := by\n  simp [uIoc, \u2190 (strictMono_natAdd m).monotone.map_max, \u2190 (strictMono_natAdd m).monotone.map_min]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Fin.lean", "context": {"open": ["Function Set"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nnatAdd : x\u271d\nm : ?m.2051\ni j : Fin n\n\u22a2 sorry '' uIoc i j = uIoc sorry sorry"}, {"line": "simp [uIoc, \u2190 (strictMono_natAdd m).monotone.map_max, \u2190 (strictMono_natAdd m).monotone.map_min]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nnatAdd : x\u271d\nm : ?m.2051\ni j : Fin n\n\u22a2 sorry () '' Ioc (min i j) (max i j) = Ioc (sorry () \u2293 sorry ()) (sorry () \u2294 sorry ())"}]}
{"declaration": "theorem image_natAdd_uIoo (m) (i j : Fin n) :\n    natAdd m '' uIoo i j = uIoo (natAdd m i) (natAdd m j) := by\n  simp [uIoo, \u2190 (strictMono_natAdd m).monotone.map_max, \u2190 (strictMono_natAdd m).monotone.map_min]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Fin.lean", "context": {"open": ["Function Set"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nnatAdd : x\u271d\nm : ?m.2051\ni j : Fin n\n\u22a2 sorry '' uIoo i j = uIoo sorry sorry"}, {"line": "simp [uIoo, \u2190 (strictMono_natAdd m).monotone.map_max, \u2190 (strictMono_natAdd m).monotone.map_min]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nnatAdd : x\u271d\nm : ?m.2051\ni j : Fin n\n\u22a2 sorry () '' Ioo (min i j) (max i j) = Ioo (sorry () \u2293 sorry ()) (sorry () \u2294 sorry ())"}]}
{"declaration": "theorem preimage_addNat_uIcc_addNat (m) (i j : Fin n) :\n    (addNat \u00b7 m) \u207b\u00b9' uIcc (i.addNat m) (j.addNat m) = uIcc i j := by\n  simp [uIcc, \u2190 (strictMono_addNat m).monotone.map_max, \u2190 (strictMono_addNat m).monotone.map_min]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Fin.lean", "context": {"open": ["Function Set"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 (fun x => sorry) \u207b\u00b9' uIcc (i.addNat m) (j.addNat m) = uIcc i j"}, {"line": "simp [uIcc, \u2190 (strictMono_addNat m).monotone.map_max, \u2190 (strictMono_addNat m).monotone.map_min]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 (fun x => sorry ()) \u207b\u00b9' Icc (min (i.addNat m) (j.addNat m)) (max (i.addNat m) (j.addNat m)) = Icc (min i j) (max i j)"}]}
{"declaration": "theorem preimage_addNat_uIoc_addNat (m) (i j : Fin n) :\n    (addNat \u00b7 m) \u207b\u00b9' uIoc (i.addNat m) (j.addNat m) = uIoc i j := by\n  simp [uIoc, \u2190 (strictMono_addNat m).monotone.map_max, \u2190 (strictMono_addNat m).monotone.map_min]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Fin.lean", "context": {"open": ["Function Set"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 (fun x => sorry) \u207b\u00b9' uIoc (i.addNat m) (j.addNat m) = uIoc i j"}, {"line": "simp [uIoc, \u2190 (strictMono_addNat m).monotone.map_max, \u2190 (strictMono_addNat m).monotone.map_min]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 (fun x => sorry ()) \u207b\u00b9' Ioc (min (i.addNat m) (j.addNat m)) (max (i.addNat m) (j.addNat m)) = Ioc (min i j) (max i j)"}]}
{"declaration": "theorem preimage_addNat_uIoo_addNat (m) (i j : Fin n) :\n    (addNat \u00b7 m) \u207b\u00b9' uIoo (i.addNat m) (j.addNat m) = uIoo i j := by\n  simp [uIoo, \u2190 (strictMono_addNat m).monotone.map_max, \u2190 (strictMono_addNat m).monotone.map_min]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Fin.lean", "context": {"open": ["Function Set"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 (fun x => sorry) \u207b\u00b9' uIoo (i.addNat m) (j.addNat m) = uIoo i j"}, {"line": "simp [uIoo, \u2190 (strictMono_addNat m).monotone.map_max, \u2190 (strictMono_addNat m).monotone.map_min]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 (fun x => sorry ()) \u207b\u00b9' Ioo (min (i.addNat m) (j.addNat m)) (max (i.addNat m) (j.addNat m)) = Ioo (min i j) (max i j)"}]}
{"declaration": "theorem image_addNat_uIcc (m) (i j : Fin n) :\n    (addNat \u00b7 m) '' uIcc i j = uIcc (i.addNat m) (j.addNat m) := by\n  simp [uIcc, \u2190 (strictMono_addNat m).monotone.map_max, \u2190 (strictMono_addNat m).monotone.map_min]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Fin.lean", "context": {"open": ["Function Set"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 (fun x => sorry) '' uIcc i j = uIcc (i.addNat m) (j.addNat m)"}, {"line": "simp [uIcc, \u2190 (strictMono_addNat m).monotone.map_max, \u2190 (strictMono_addNat m).monotone.map_min]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 {sorry ()} = Icc (min (i.addNat m) (j.addNat m)) (max (i.addNat m) (j.addNat m))"}]}
{"declaration": "theorem image_addNat_uIoc (m) (i j : Fin n) :\n    (addNat \u00b7 m) '' uIoc i j = uIoc (i.addNat m) (j.addNat m) := by\n  simp [uIoc, \u2190 (strictMono_addNat m).monotone.map_max, \u2190 (strictMono_addNat m).monotone.map_min]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Fin.lean", "context": {"open": ["Function Set"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 (fun x => sorry) '' uIoc i j = uIoc (i.addNat m) (j.addNat m)"}, {"line": "simp [uIoc, \u2190 (strictMono_addNat m).monotone.map_max, \u2190 (strictMono_addNat m).monotone.map_min]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 (fun a => sorry ()) '' Ioc (min i j) (max i j) = Ioc (min (i.addNat m) (j.addNat m)) (max (i.addNat m) (j.addNat m))"}]}
{"declaration": "theorem image_addNat_uIoo (m) (i j : Fin n) :\n    (addNat \u00b7 m) '' uIoo i j = uIoo (i.addNat m) (j.addNat m) := by\n  simp [uIoo, \u2190 (strictMono_addNat m).monotone.map_max, \u2190 (strictMono_addNat m).monotone.map_min]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Fin.lean", "context": {"open": ["Function Set"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 (fun x => sorry) '' uIoo i j = uIoo (i.addNat m) (j.addNat m)"}, {"line": "simp [uIoo, \u2190 (strictMono_addNat m).monotone.map_max, \u2190 (strictMono_addNat m).monotone.map_min]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\naddNat : x\u271d\nm : \u2115\ni j : Fin n\n\u22a2 (fun a => sorry ()) '' Ioo (min i j) (max i j) = Ioo (min (i.addNat m) (j.addNat m)) (max (i.addNat m) (j.addNat m))"}]}
{"declaration": "theorem preimage_rev_uIcc (i j : Fin n) : rev \u207b\u00b9' uIcc i j = uIcc i.rev j.rev := by\n  simp [uIcc, \u2190 rev_anti.map_min, \u2190 rev_anti.map_max]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Fin.lean", "context": {"open": ["Function Set"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni j : Fin n\n\u22a2 rev \u207b\u00b9' uIcc i j = uIcc i.rev j.rev"}, {"line": "simp [uIcc, \u2190 rev_anti.map_min, \u2190 rev_anti.map_max]", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni j : Fin n\n\u22a2 rev \u207b\u00b9' Icc (min i j) (max i j) = Icc (min i.rev j.rev) (max i.rev j.rev)"}]}
{"declaration": "theorem preimage_rev_uIoo (i j : Fin n) : rev \u207b\u00b9' uIoo i j = uIoo i.rev j.rev := by\n  simp [uIoo, \u2190 rev_anti.map_min, \u2190 rev_anti.map_max]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Fin.lean", "context": {"open": ["Function Set"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni j : Fin n\n\u22a2 rev \u207b\u00b9' uIoo i j = uIoo i.rev j.rev"}, {"line": "simp [uIoo, \u2190 rev_anti.map_min, \u2190 rev_anti.map_max]", "tactic_state": "n : \u2115\nrev : Fin n \u2192 Fin n\ni j : Fin n\n\u22a2 rev \u207b\u00b9' Ioo (min i j) (max i j) = Ioo (min i.rev j.rev) (max i.rev j.rev)"}]}
{"declaration": "theorem preimage_Ici (e : \u03b1 \u2243o \u03b2) (b : \u03b2) : e \u207b\u00b9' Ici b = Ici (e.symm b) := by\n  ext x\n  simp [\u2190 e.le_iff_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/OrderIso.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\nb : \u03b2\n\u22a2 \u21d1e \u207b\u00b9' Ici b = Ici (e.symm b)"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\nb : \u03b2\nx : \u03b1\n\u22a2 x \u2208 \u21d1e \u207b\u00b9' Ici b \u2194 x \u2208 Ici (e.symm b)"}, {"line": "simp [\u2190 e.le_iff_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_Iio (e : \u03b1 \u2243o \u03b2) (b : \u03b2) : e \u207b\u00b9' Iio b = Iio (e.symm b) := by\n  ext x\n  simp [\u2190 e.lt_iff_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/OrderIso.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\nb : \u03b2\n\u22a2 \u21d1e \u207b\u00b9' Iio b = Iio (e.symm b)"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\nb : \u03b2\nx : \u03b1\n\u22a2 x \u2208 \u21d1e \u207b\u00b9' Iio b \u2194 x \u2208 Iio (e.symm b)"}, {"line": "simp [\u2190 e.lt_iff_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_Icc (e : \u03b1 \u2243o \u03b2) (a b : \u03b2) : e \u207b\u00b9' Icc a b = Icc (e.symm a) (e.symm b) := by\n  simp [\u2190 Ici_inter_Iic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/OrderIso.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\na b : \u03b2\n\u22a2 \u21d1e \u207b\u00b9' Icc a b = Icc (e.symm a) (e.symm b)"}, {"line": "simp [\u2190 Ici_inter_Iic]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_Ico (e : \u03b1 \u2243o \u03b2) (a b : \u03b2) : e \u207b\u00b9' Ico a b = Ico (e.symm a) (e.symm b) := by\n  simp [\u2190 Ici_inter_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/OrderIso.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\na b : \u03b2\n\u22a2 \u21d1e \u207b\u00b9' Ico a b = Ico (e.symm a) (e.symm b)"}, {"line": "simp [\u2190 Ici_inter_Iio]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_Ioc (e : \u03b1 \u2243o \u03b2) (a b : \u03b2) : e \u207b\u00b9' Ioc a b = Ioc (e.symm a) (e.symm b) := by\n  simp [\u2190 Ioi_inter_Iic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/OrderIso.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\na b : \u03b2\n\u22a2 \u21d1e \u207b\u00b9' Ioc a b = Ioc (e.symm a) (e.symm b)"}, {"line": "simp [\u2190 Ioi_inter_Iic]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_Ioo (e : \u03b1 \u2243o \u03b2) (a b : \u03b2) : e \u207b\u00b9' Ioo a b = Ioo (e.symm a) (e.symm b) := by\n  simp [\u2190 Ioi_inter_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/OrderIso.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\na b : \u03b2\n\u22a2 \u21d1e \u207b\u00b9' Ioo a b = Ioo (e.symm a) (e.symm b)"}, {"line": "simp [\u2190 Ioi_inter_Iio]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Iic.succ_eq_of_not_isMax\n    [SuccOrder J] {j : J} {i : Set.Iic j} (hi : \u00ac IsMax i) :\n    Order.succ i = \u27e8Order.succ i.1, by\n      rw [\u2190 coe_succ_of_not_isMax hi]\n      apply Subtype.coe_prop\u27e9 := by\n  ext\n  simp only [coe_succ_of_not_isMax hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/SuccOrder.lean", "context": {"open": [], "variables": ["{J : Type*} [PartialOrder J]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Type u_1\ninst\u271d\u00b9 : PartialOrder J\ninst\u271d : SuccOrder J\nj : J\ni : \u2191(Set.Iic j)\nhi : \u00acIsMax i\n\u22a2 Order.succ i = \u27e8Order.succ \u2191i, \u22ef\u27e9"}, {"line": "ext", "tactic_state": "case a\nJ : Type u_1\ninst\u271d\u00b9 : PartialOrder J\ninst\u271d : SuccOrder J\nj : J\ni : \u2191(Set.Iic j)\nhi : \u00acIsMax i\n\u22a2 \u2191(Order.succ i) = \u2191\u27e8Order.succ \u2191i, \u22ef\u27e9"}, {"line": "simp only [coe_succ_of_not_isMax hi]", "tactic_state": "case a\nJ : Type u_1\ninst\u271d\u00b9 : PartialOrder J\ninst\u271d : SuccOrder J\nj : J\ni : \u2191(Set.Iic j)\nhi : \u00acIsMax i\n\u22a2 \u2191(Order.succ i) = Order.succ \u2191i"}]}
{"declaration": "lemma Ici.pred_eq_of_not_isMin\n    [PredOrder J] {j : J} {i : Set.Ici j} (hi : \u00ac IsMin i) :\n    Order.pred i = \u27e8Order.pred i.1, by\n      rw [\u2190 coe_pred_of_not_isMin hi]\n      apply Subtype.coe_prop\u27e9 := by\n  ext\n  simp only [coe_pred_of_not_isMin hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/SuccOrder.lean", "context": {"open": [], "variables": ["{J : Type*} [PartialOrder J]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Type u_1\ninst\u271d\u00b9 : PartialOrder J\ninst\u271d : PredOrder J\nj : J\ni : \u2191(Set.Ici j)\nhi : \u00acIsMin i\n\u22a2 Order.pred i = \u27e8Order.pred \u2191i, \u22ef\u27e9"}, {"line": "ext", "tactic_state": "case a\nJ : Type u_1\ninst\u271d\u00b9 : PartialOrder J\ninst\u271d : PredOrder J\nj : J\ni : \u2191(Set.Ici j)\nhi : \u00acIsMin i\n\u22a2 \u2191(Order.pred i) = \u2191\u27e8Order.pred \u2191i, \u22ef\u27e9"}, {"line": "simp only [coe_pred_of_not_isMin hi]", "tactic_state": "case a\nJ : Type u_1\ninst\u271d\u00b9 : PartialOrder J\ninst\u271d : PredOrder J\nj : J\ni : \u2191(Set.Ici j)\nhi : \u00acIsMin i\n\u22a2 \u2191(Order.pred i) = Order.pred \u2191i"}]}
{"declaration": "theorem preimage_coe_Icc : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' Icc a b = Icc a b := by simp [\u2190 Ici_inter_Iic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/WithBotTop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' sorry = Icc a b"}, {"line": "simp [\u2190 Ici_inter_Iic]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' sorry () = Ici a \u2229 Iic b"}]}
{"declaration": "theorem preimage_coe_Ico : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' Ico a b = Ico a b := by simp [\u2190 Ici_inter_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/WithBotTop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' sorry = Ico a b"}, {"line": "simp [\u2190 Ici_inter_Iio]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' sorry () = Ici a \u2229 Iio b"}]}
{"declaration": "theorem preimage_coe_Ioc : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' Ioc a b = Ioc a b := by simp [\u2190 Ioi_inter_Iic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/WithBotTop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' sorry = Ioc a b"}, {"line": "simp [\u2190 Ioi_inter_Iic]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' sorry () = Ioi a \u2229 Iic b"}]}
{"declaration": "theorem preimage_coe_Ioo : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' Ioo a b = Ioo a b := by simp [\u2190 Ioi_inter_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/WithBotTop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' sorry = Ioo a b"}, {"line": "simp [\u2190 Ioi_inter_Iio]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' sorry () = Ioi a \u2229 Iio b"}]}
{"declaration": "theorem preimage_coe_Ico_top : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' Ico a \u22a4 = Ici a := by\n  simp [\u2190 Ici_inter_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/WithBotTop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 some \u207b\u00b9' sorry = Ici a"}, {"line": "simp [\u2190 Ici_inter_Iio]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 some \u207b\u00b9' sorry () = Ici a"}]}
{"declaration": "theorem preimage_coe_Ioo_top : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' Ioo a \u22a4 = Ioi a := by\n  simp [\u2190 Ioi_inter_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/WithBotTop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 some \u207b\u00b9' sorry = Ioi a"}, {"line": "simp [\u2190 Ioi_inter_Iio]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 some \u207b\u00b9' sorry () = Ioi a"}]}
{"declaration": "theorem preimage_coe_Icc : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Icc a b = Icc a b := by simp [\u2190 Ici_inter_Iic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/WithBotTop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a b : \u03b1}", "[Preorder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' sorry = Icc a b"}, {"line": "simp [\u2190 Ici_inter_Iic]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' sorry () = Ici a \u2229 Iic b"}]}
{"declaration": "theorem preimage_coe_Ico : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Ico a b = Ico a b := by simp [\u2190 Ici_inter_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/WithBotTop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a b : \u03b1}", "[Preorder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' sorry = Ico a b"}, {"line": "simp [\u2190 Ici_inter_Iio]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' sorry () = Ici a \u2229 Iio b"}]}
{"declaration": "theorem preimage_coe_Ioc : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Ioc a b = Ioc a b := by simp [\u2190 Ioi_inter_Iic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/WithBotTop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a b : \u03b1}", "[Preorder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' sorry = Ioc a b"}, {"line": "simp [\u2190 Ioi_inter_Iic]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' sorry () = Ioi a \u2229 Iic b"}]}
{"declaration": "theorem preimage_coe_Ioo : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Ioo a b = Ioo a b := by simp [\u2190 Ioi_inter_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/WithBotTop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a b : \u03b1}", "[Preorder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' sorry = Ioo a b"}, {"line": "simp [\u2190 Ioi_inter_Iio]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' sorry () = Ioi a \u2229 Iio b"}]}
{"declaration": "theorem preimage_coe_Ioc_bot : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Ioc \u22a5 a = Iic a := by\n  simp [\u2190 Ioi_inter_Iic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/WithBotTop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a b : \u03b1}", "[Preorder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 some \u207b\u00b9' sorry = Iic a"}, {"line": "simp [\u2190 Ioi_inter_Iic]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 some \u207b\u00b9' sorry () = Iic a"}]}
{"declaration": "theorem preimage_coe_Ioo_bot : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Ioo \u22a5 a = Iio a := by\n  simp [\u2190 Ioi_inter_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/WithBotTop.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a b : \u03b1}", "[Preorder \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 some \u207b\u00b9' sorry = Iio a"}, {"line": "simp [\u2190 Ioi_inter_Iio]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 some \u207b\u00b9' sorry () = Iio a"}]}
{"declaration": "theorem mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset {s : Set \u03b1} (ho : Ioo a b \u2286 s) (hc : s \u2286 Icc a b) :\n    s \u2208 ({Icc a b, Ico a b, Ioc a b, Ioo a b} : Set (Set \u03b1)) := by\n  classical\n    by_cases ha : a \u2208 s <;> by_cases hb : b \u2208 s\n    \u00b7 refine Or.inl (Subset.antisymm hc ?_)\n      rwa [\u2190 Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha, \u2190 Icc_diff_right,\n        diff_singleton_subset_iff, insert_eq_of_mem hb] at ho\n    \u00b7 refine Or.inr <| Or.inl <| Subset.antisymm ?_ ?_\n      \u00b7 rw [\u2190 Icc_diff_right]\n        exact subset_diff_singleton hc hb\n      \u00b7 rwa [\u2190 Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha] at ho\n    \u00b7 refine Or.inr <| Or.inr <| Or.inl <| Subset.antisymm ?_ ?_\n      \u00b7 rw [\u2190 Icc_diff_left]\n        exact subset_diff_singleton hc ha\n      \u00b7 rwa [\u2190 Ioc_diff_right, diff_singleton_subset_iff, insert_eq_of_mem hb] at ho\n    \u00b7 refine Or.inr <| Or.inr <| Or.inr <| Subset.antisymm ?_ ho\n      rw [\u2190 Ico_diff_left]\n      rw [\u2190 Icc_diff_right]\n      apply_rules [subset_diff_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Basic.lean", "context": {"open": ["Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PartialOrder \u03b1\nx\u271d\u00b3 : Sort u_2\nIoo : x\u271d\u00b3\nx\u271d\u00b2 : Sort u_3\nIcc : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_4\nIco : x\u271d\u00b9\nx\u271d : Sort u_5\nIoc : x\u271d\ns : Set \u03b1\nho : sorry \u2286 s\nhc : s \u2286 sorry\n\u22a2 s \u2208 {sorry, sorry, sorry, sorry}"}, {"line": "classical\n    by_cases ha : a \u2208 s <;> by_cases hb : b \u2208 s\n    \u00b7 refine Or.inl (Subset.antisymm hc ?_)\n      rwa [\u2190 Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha, \u2190 Icc_diff_right,\n        diff_singleton_subset_iff, insert_eq_of_mem hb] at ho\n    \u00b7 refine Or.inr <| Or.inl <| Subset.antisymm ?_ ?_\n      \u00b7 rw [\u2190 Icc_diff_right]\n        exact subset_diff_singleton hc hb\n      \u00b7 rwa [\u2190 Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha] at ho\n    \u00b7 refine Or.inr <| Or.inr <| Or.inl <| Subset.antisymm ?_ ?_\n      \u00b7 rw [\u2190 Icc_diff_left]\n        exact subset_diff_singleton hc ha\n      \u00b7 rwa [\u2190 Ioc_diff_right, diff_singleton_subset_iff, insert_eq_of_mem hb] at ho\n    \u00b7 refine Or.inr <| Or.inr <| Or.inr <| Subset.antisymm ?_ ho\n      rw [\u2190 Ico_diff_left]\n      rw [\u2190 Icc_diff_right]\n      apply_rules [subset_diff_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Icc_top : Icc a \u22a4 = Ici a := by simp [\u2190 Ici_inter_Iic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Basic.lean", "context": {"open": ["Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}", "[Preorder \u03b1] [OrderTop \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nIcc : x\u271d\u00b9\nx\u271d : Sort u_3\nIci : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [\u2190 Ici_inter_Iic]", "tactic_state": "x\u271d\u00b9 : Sort u_2\nIcc : x\u271d\u00b9\nx\u271d : Sort u_3\nIci : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem Ioc_top : Ioc a \u22a4 = Ioi a := by simp [\u2190 Ioi_inter_Iic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Basic.lean", "context": {"open": ["Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}", "[Preorder \u03b1] [OrderTop \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nIoc : x\u271d\u00b9\nx\u271d : Sort u_3\nIoi : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [\u2190 Ioi_inter_Iic]", "tactic_state": "x\u271d\u00b9 : Sort u_2\nIoc : x\u271d\u00b9\nx\u271d : Sort u_3\nIoi : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem Icc_bot : Icc \u22a5 a = Iic a := by simp [\u2190 Ici_inter_Iic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Basic.lean", "context": {"open": ["Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}", "[Preorder \u03b1] [OrderTop \u03b1] {a : \u03b1}", "[Preorder \u03b1] [OrderBot \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nIcc : x\u271d\u00b9\nx\u271d : Sort u_3\nIic : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [\u2190 Ici_inter_Iic]", "tactic_state": "x\u271d\u00b9 : Sort u_2\nIcc : x\u271d\u00b9\nx\u271d : Sort u_3\nIic : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem Ico_bot : Ico \u22a5 a = Iio a := by simp [\u2190 Ici_inter_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Basic.lean", "context": {"open": ["Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}", "[Preorder \u03b1] [OrderTop \u03b1] {a : \u03b1}", "[Preorder \u03b1] [OrderBot \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nIco : x\u271d\u00b9\nx\u271d : Sort u_3\nIio : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [\u2190 Ici_inter_Iio]", "tactic_state": "x\u271d\u00b9 : Sort u_2\nIco : x\u271d\u00b9\nx\u271d : Sort u_3\nIio : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem Icc_bot_top [Preorder \u03b1] [BoundedOrder \u03b1] : Icc (\u22a5 : \u03b1) \u22a4 = univ := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Basic.lean", "context": {"open": ["Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}", "[Preorder \u03b1] [OrderTop \u03b1] {a : \u03b1}", "[Preorder \u03b1] [OrderBot \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : OrderTop \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\nx\u271d : Sort u_2\nIcc : x\u271d\n\u03b1\u271d : Sort u_3\nuniv : \u03b1\u271d\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : BoundedOrder \u03b1\n\u22a2 sorry = univ"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : OrderTop \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\nx\u271d : Sort u_2\nIcc : x\u271d\n\u03b1\u271d : Sort u_3\nuniv : \u03b1\u271d\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : BoundedOrder \u03b1\n\u22a2 sorry () = univ"}]}
{"declaration": "theorem Icc_prod_Icc (a\u2081 a\u2082 : \u03b1) (b\u2081 b\u2082 : \u03b2) : Icc a\u2081 a\u2082 \u00d7\u02e2 Icc b\u2081 b\u2082 = Icc (a\u2081, b\u2081) (a\u2082, b\u2082) := by\n  ext \u27e8x, y\u27e9\n  simp [and_assoc, and_comm, and_left_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Basic.lean", "context": {"open": ["Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}", "[Preorder \u03b1] [OrderTop \u03b1] {a : \u03b1}", "[Preorder \u03b1] [OrderBot \u03b1] {a : \u03b1}", "[SemilatticeInf \u03b1]", "[SemilatticeSup \u03b1]", "[Lattice \u03b1] {a b c a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1}", "{\u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : OrderTop \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : SemilatticeInf \u03b1\ninst\u271d\u00b3 : SemilatticeSup \u03b1\ninst\u271d\u00b2 : Lattice \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d : Sort u_3\nIcc : x\u271d\na\u2081 a\u2082 : \u03b1\nb\u2081 b\u2082 : \u03b2\n\u22a2 sorry \u00d7\u02e2 sorry = sorry"}, {"line": "ext \u27e8x, y\u27e9", "tactic_state": "case h.mk\n\u03b1 : Type u_1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : OrderTop \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : SemilatticeInf \u03b1\ninst\u271d\u00b3 : SemilatticeSup \u03b1\ninst\u271d\u00b2 : Lattice \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d : Sort u_3\nIcc : x\u271d\na\u2081 a\u2082 : \u03b1\nb\u2081 b\u2082 : \u03b2\nx : ?m.2834\ny : ?m.2912\n\u22a2 (x, y) \u2208 sorry \u00d7\u02e2 sorry \u2194 (x, y) \u2208 sorry"}, {"line": "simp [and_assoc, and_comm, and_left_comm]", "tactic_state": "case h.mk\n\u03b1 : Type u_1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : OrderTop \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 : SemilatticeInf \u03b1\ninst\u271d\u00b3 : SemilatticeSup \u03b1\ninst\u271d\u00b2 : Lattice \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u271d : Sort u_3\nIcc : x\u271d\na\u2081 a\u2082 : \u03b1\nb\u2081 b\u2082 : \u03b2\nx : ?m.2834\ny : ?m.2912\n\u22a2 x \u2208 sorry () \u2227 y \u2208 sorry () \u2194 (x, y) \u2208 sorry ()"}]}
{"declaration": "lemma Iio_False : Iio False = \u2205 := by aesop", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Basic.lean", "context": {"open": ["Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}", "[Preorder \u03b1] [OrderTop \u03b1] {a : \u03b1}", "[Preorder \u03b1] [OrderBot \u03b1] {a : \u03b1}", "[SemilatticeInf \u03b1]", "[SemilatticeSup \u03b1]", "[Lattice \u03b1] {a b c a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1}", "{\u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]", "(\u03b1) [Preorder \u03b1] [DenselyOrdered \u03b1] {x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nIio : x\u271d\n\u22a2 sorry = \u2205"}, {"line": "aesop", "tactic_state": "x : Sort u_3\nIio : x\n\u22a2 sorry () = \u2205"}]}
{"declaration": "lemma Ioi_True : Ioi True = \u2205 := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Basic.lean", "context": {"open": ["Function", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] {a a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1}", "[PartialOrder \u03b1] {a b c : \u03b1}", "[Preorder \u03b1] [OrderTop \u03b1] {a : \u03b1}", "[Preorder \u03b1] [OrderBot \u03b1] {a : \u03b1}", "[SemilatticeInf \u03b1]", "[SemilatticeSup \u03b1]", "[Lattice \u03b1] {a b c a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1}", "{\u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]", "(\u03b1) [Preorder \u03b1] [DenselyOrdered \u03b1] {x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nIoi : x\u271d\n\u22a2 sorry = \u2205"}, {"line": "aesop", "tactic_state": "x : Sort u_3\nIoi : x\n\u22a2 sorry () = \u2205"}]}
{"declaration": "theorem Ici_disjoint_Iic : Disjoint (Ici a) (Iic b) \u2194 \u00aca \u2264 b := by\n  rw [Set.disjoint_iff_inter_eq_empty]\n  rw [Ici_inter_Iic]\n  rw [Icc_eq_empty_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Disjoint.lean", "context": {"open": ["Set", "OrderDual (toDual)"], "variables": ["{\u03b9 : Sort u} {\u03b1 : Type v} {\u03b2 : Type w}", "[Preorder \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 Disjoint (Ici a) (Iic b) \u2194 \u00aca \u2264 b"}, {"line": "rw [Set.disjoint_iff_inter_eq_empty]", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 Ici a \u2229 Iic b = \u2205 \u2194 \u00aca \u2264 b"}, {"line": "rw [Ici_inter_Iic]", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 Icc a b = \u2205 \u2194 \u00aca \u2264 b"}, {"line": "rw [Icc_eq_empty_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_Icc_right (a : \u03b1) : \u22c3 b, Icc a b = Ici a := by\n  simp only [\u2190 Ici_inter_Iic]\n  simp only [\u2190 inter_iUnion]\n  simp only [iUnion_Iic]\n  simp only [inter_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Disjoint.lean", "context": {"open": ["Set", "OrderDual (toDual)"], "variables": ["{\u03b9 : Sort u} {\u03b1 : Type v} {\u03b2 : Type w}", "[Preorder \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 \u22c3 b, Icc a b = Ici a"}, {"line": "simp only [\u2190 Ici_inter_Iic]", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 \u22c3 b, Ici a \u2229 Iic b = Ici a"}, {"line": "simp only [\u2190 inter_iUnion]", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 Ici a \u2229 \u22c3 i, Iic i = Ici a"}, {"line": "simp only [iUnion_Iic]", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 Ici a \u2229 univ = Ici a"}, {"line": "simp only [inter_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_Ioc_right (a : \u03b1) : \u22c3 b, Ioc a b = Ioi a := by\n  simp only [\u2190 Ioi_inter_Iic]\n  simp only [\u2190 inter_iUnion]\n  simp only [iUnion_Iic]\n  simp only [inter_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Disjoint.lean", "context": {"open": ["Set", "OrderDual (toDual)"], "variables": ["{\u03b9 : Sort u} {\u03b1 : Type v} {\u03b2 : Type w}", "[Preorder \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 \u22c3 b, Ioc a b = Ioi a"}, {"line": "simp only [\u2190 Ioi_inter_Iic]", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 \u22c3 b, Ioi a \u2229 Iic b = Ioi a"}, {"line": "simp only [\u2190 inter_iUnion]", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 Ioi a \u2229 \u22c3 i, Iic i = Ioi a"}, {"line": "simp only [iUnion_Iic]", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\na : \u03b1\n\u22a2 Ioi a \u2229 univ = Ioi a"}, {"line": "simp only [inter_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_Icc_left (b : \u03b1) : \u22c3 a, Icc a b = Iic b := by\n  simp only [\u2190 Ici_inter_Iic]\n  simp only [\u2190 iUnion_inter]\n  simp only [iUnion_Ici]\n  simp only [univ_inter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Disjoint.lean", "context": {"open": ["Set", "OrderDual (toDual)"], "variables": ["{\u03b9 : Sort u} {\u03b1 : Type v} {\u03b2 : Type w}", "[Preorder \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\nb : \u03b1\n\u22a2 \u22c3 a, Icc a b = Iic b"}, {"line": "simp only [\u2190 Ici_inter_Iic]", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\nb : \u03b1\n\u22a2 \u22c3 a, Ici a \u2229 Iic b = Iic b"}, {"line": "simp only [\u2190 iUnion_inter]", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\nb : \u03b1\n\u22a2 (\u22c3 i, Ici i) \u2229 Iic b = Iic b"}, {"line": "simp only [iUnion_Ici]", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\nb : \u03b1\n\u22a2 univ \u2229 Iic b = Iic b"}, {"line": "simp only [univ_inter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_Ico_left (b : \u03b1) : \u22c3 a, Ico a b = Iio b := by\n  simp only [\u2190 Ici_inter_Iio]\n  simp only [\u2190 iUnion_inter]\n  simp only [iUnion_Ici]\n  simp only [univ_inter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Disjoint.lean", "context": {"open": ["Set", "OrderDual (toDual)"], "variables": ["{\u03b9 : Sort u} {\u03b1 : Type v} {\u03b2 : Type w}", "[Preorder \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\nb : \u03b1\n\u22a2 \u22c3 a, Ico a b = Iio b"}, {"line": "simp only [\u2190 Ici_inter_Iio]", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\nb : \u03b1\n\u22a2 \u22c3 a, Ici a \u2229 Iio b = Iio b"}, {"line": "simp only [\u2190 iUnion_inter]", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\nb : \u03b1\n\u22a2 (\u22c3 i, Ici i) \u2229 Iio b = Iio b"}, {"line": "simp only [iUnion_Ici]", "tactic_state": "\u03b1 : Type v\ninst\u271d : Preorder \u03b1\nb : \u03b1\n\u22a2 univ \u2229 Iio b = Iio b"}, {"line": "simp only [univ_inter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_Ico_eq_Iio_self_iff {f : \u03b9 \u2192 \u03b1} {a : \u03b1} :\n    \u22c3 i, Ico (f i) a = Iio a \u2194 \u2200 x < a, \u2203 i, f i \u2264 x := by\n  simp [\u2190 Ici_inter_Iio, \u2190 iUnion_inter, subset_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Disjoint.lean", "context": {"open": ["Set", "OrderDual (toDual)"], "variables": ["{\u03b9 : Sort u} {\u03b1 : Type v} {\u03b2 : Type w}", "[Preorder \u03b1] {a b c : \u03b1}", "[LinearOrder \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u\n\u03b1 : Type v\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LinearOrder \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u03b1\n\u22a2 \u22c3 i, Ico (f i) a = Iio a \u2194 \u2200 x < a, \u2203 i, f i \u2264 x"}, {"line": "simp [\u2190 Ici_inter_Iio, \u2190 iUnion_inter, subset_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_Ioc_eq_Ioi_self_iff {f : \u03b9 \u2192 \u03b1} {a : \u03b1} :\n    \u22c3 i, Ioc a (f i) = Ioi a \u2194 \u2200 x, a < x \u2192 \u2203 i, x \u2264 f i := by\n  simp [\u2190 Ioi_inter_Iic, \u2190 inter_iUnion, subset_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Disjoint.lean", "context": {"open": ["Set", "OrderDual (toDual)"], "variables": ["{\u03b9 : Sort u} {\u03b1 : Type v} {\u03b2 : Type w}", "[Preorder \u03b1] {a b c : \u03b1}", "[LinearOrder \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u\n\u03b1 : Type v\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LinearOrder \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u03b1\n\u22a2 \u22c3 i, Ioc a (f i) = Ioi a \u2194 \u2200 (x : \u03b1), a < x \u2192 \u2203 i, x \u2264 f i"}, {"line": "simp [\u2190 Ioi_inter_Iic, \u2190 inter_iUnion, subset_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biUnion_Ico_eq_Iio_self_iff {p : \u03b9 \u2192 Prop} {f : \u2200 i, p i \u2192 \u03b1} {a : \u03b1} :\n    \u22c3 (i) (hi : p i), Ico (f i hi) a = Iio a \u2194 \u2200 x < a, \u2203 i hi, f i hi \u2264 x := by\n  simp [\u2190 Ici_inter_Iio, \u2190 iUnion_inter, subset_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Disjoint.lean", "context": {"open": ["Set", "OrderDual (toDual)"], "variables": ["{\u03b9 : Sort u} {\u03b1 : Type v} {\u03b2 : Type w}", "[Preorder \u03b1] {a b c : \u03b1}", "[LinearOrder \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u\n\u03b1 : Type v\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LinearOrder \u03b1\np : \u03b9 \u2192 Prop\nf : (i : \u03b9) \u2192 p i \u2192 \u03b1\na : \u03b1\n\u22a2 \u22c3 i, \u22c3 (hi : p i), Ico (f i hi) a = Iio a \u2194 \u2200 x < a, \u2203 i, \u2203 (hi : p i), f i hi \u2264 x"}, {"line": "simp [\u2190 Ici_inter_Iio, \u2190 iUnion_inter, subset_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biUnion_Ioc_eq_Ioi_self_iff {p : \u03b9 \u2192 Prop} {f : \u2200 i, p i \u2192 \u03b1} {a : \u03b1} :\n    \u22c3 (i) (hi : p i), Ioc a (f i hi) = Ioi a \u2194 \u2200 x, a < x \u2192 \u2203 i hi, x \u2264 f i hi := by\n  simp [\u2190 Ioi_inter_Iic, \u2190 inter_iUnion, subset_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Disjoint.lean", "context": {"open": ["Set", "OrderDual (toDual)"], "variables": ["{\u03b9 : Sort u} {\u03b1 : Type v} {\u03b2 : Type w}", "[Preorder \u03b1] {a b c : \u03b1}", "[LinearOrder \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u\n\u03b1 : Type v\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LinearOrder \u03b1\np : \u03b9 \u2192 Prop\nf : (i : \u03b9) \u2192 p i \u2192 \u03b1\na : \u03b1\n\u22a2 \u22c3 i, \u22c3 (hi : p i), Ioc a (f i hi) = Ioi a \u2194 \u2200 (x : \u03b1), a < x \u2192 \u2203 i, \u2203 (hi : p i), x \u2264 f i hi"}, {"line": "simp [\u2190 Ioi_inter_Iic, \u2190 inter_iUnion, subset_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsGLB.biUnion_Ici_eq_Ici (a_glb : IsGLB s a) (a_mem : a \u2208 s) :\n    \u22c3 x \u2208 s, Ici x = Ici a := by\n  refine (iUnion\u2082_subset fun x hx => ?_).antisymm fun x hx => ?_\n  \u00b7 exact Ici_subset_Ici.mpr (mem_lowerBounds.mp a_glb.1 x hx)\n  \u00b7 exact mem_iUnion\u2082.mpr \u27e8a, a_mem, hx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Disjoint.lean", "context": {"open": ["Set", "OrderDual (toDual)"], "variables": ["{\u03b9 : Sort u} {\u03b1 : Type v} {\u03b2 : Type w}", "[Preorder \u03b1] {a b c : \u03b1}", "[LinearOrder \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1}", "[LinearOrder \u03b1] {s : Set \u03b1} {a : \u03b1} {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type v\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 inst\u271d : LinearOrder \u03b1\ns : Set \u03b1\na : \u03b1\na_glb : IsGLB s a\na_mem : a \u2208 s\n\u22a2 \u22c3 x \u2208 s, Ici x = Ici a"}, {"line": "refine (iUnion\u2082_subset fun x hx => ?_).antisymm fun x hx => ?_", "tactic_state": "case refine_1\n\u03b1 : Type v\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 inst\u271d : LinearOrder \u03b1\ns : Set \u03b1\na : \u03b1\na_glb : IsGLB s a\na_mem : a \u2208 s\nx : \u03b1\nhx : x \u2208 s\n\u22a2 Ici x \u2286 Ici a\n---\ncase refine_2\n\u03b1 : Type v\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 inst\u271d : LinearOrder \u03b1\ns : Set \u03b1\na : \u03b1\na_glb : IsGLB s a\na_mem : a \u2208 s\nx : \u03b1\nhx : x \u2208 Ici a\n\u22a2 x \u2208 \u22c3 i \u2208 s, Ici i"}, {"line": "\u00b7 exact Ici_subset_Ici.mpr (mem_lowerBounds.mp a_glb.1 x hx)", "tactic_state": "case refine_2\n\u03b1 : Type v\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 inst\u271d : LinearOrder \u03b1\ns : Set \u03b1\na : \u03b1\na_glb : IsGLB s a\na_mem : a \u2208 s\nx : \u03b1\nhx : x \u2208 Ici a\n\u22a2 x \u2208 \u22c3 i \u2208 s, Ici i"}, {"line": "\u00b7 exact mem_iUnion\u2082.mpr \u27e8a, a_mem, hx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_Iio_eq_univ_iff : \u22c3 i, Iio (f i) = univ \u2194 (\u00ac BddAbove (range f)) := by\n  simp [not_bddAbove_iff, Set.eq_univ_iff_forall]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Disjoint.lean", "context": {"open": ["Set", "OrderDual (toDual)"], "variables": ["{\u03b9 : Sort u} {\u03b1 : Type v} {\u03b2 : Type w}", "[Preorder \u03b1] {a b c : \u03b1}", "[LinearOrder \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1}", "[LinearOrder \u03b1] {s : Set \u03b1} {a : \u03b1} {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u\n\u03b1 : Type v\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 inst\u271d : LinearOrder \u03b1\nf : \u03b9 \u2192 \u03b1\n\u22a2 \u22c3 i, Iio (f i) = univ \u2194 \u00acBddAbove (range f)"}, {"line": "simp [not_bddAbove_iff, Set.eq_univ_iff_forall]", "tactic_state": "\u03b9 : Sort u\n\u03b1 : Type v\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 inst\u271d : LinearOrder \u03b1\nf : \u03b9 \u2192 \u03b1\n\u22a2 (\u2200 (x : \u03b1), \u2203 i, x < f i) \u2194 \u00acBddAbove (range f)"}]}
{"declaration": "theorem iInter_Iic_eq_empty_iff : \u22c2 i, Iic (f i) = \u2205 \u2194 \u00ac BddBelow (range f) := by\n  simp [not_bddBelow_iff, Set.eq_empty_iff_forall_not_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Disjoint.lean", "context": {"open": ["Set", "OrderDual (toDual)"], "variables": ["{\u03b9 : Sort u} {\u03b1 : Type v} {\u03b2 : Type w}", "[Preorder \u03b1] {a b c : \u03b1}", "[LinearOrder \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1}", "[LinearOrder \u03b1] {s : Set \u03b1} {a : \u03b1} {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u\n\u03b1 : Type v\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 inst\u271d : LinearOrder \u03b1\nf : \u03b9 \u2192 \u03b1\n\u22a2 \u22c2 i, Iic (f i) = \u2205 \u2194 \u00acBddBelow (range f)"}, {"line": "simp [not_bddBelow_iff, Set.eq_empty_iff_forall_not_mem]", "tactic_state": "\u03b9 : Sort u\n\u03b1 : Type v\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 inst\u271d : LinearOrder \u03b1\nf : \u03b9 \u2192 \u03b1\n\u22a2 (\u2200 (x : \u03b1), \u2203 x_1, \u00acx \u2264 f x_1) \u2194 \u00acBddBelow (range f)"}]}
{"declaration": "theorem dual_ordConnected_iff {s : Set \u03b1} : OrdConnected (ofDual \u207b\u00b9' s) \u2194 OrdConnected s := by\n  simp_rw [ordConnected_def, toDual.surjective.forall, Icc_toDual, Subtype.forall']\n  exact forall_swap\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/OrdConnected.lean", "context": {"open": ["scoped Interval", "Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2] {s : Set \u03b1}", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d : Preorder \u03b1\ns : Set \u03b1\n\u22a2 (\u21d1ofDual \u207b\u00b9' s).OrdConnected \u2194 s.OrdConnected"}, {"line": "simp_rw [ordConnected_def, toDual.surjective.forall, Icc_toDual, Subtype.forall']", "tactic_state": "\u03b1 : Type u_5\ninst\u271d : Preorder \u03b1\ns : Set \u03b1\n\u22a2 (\u2200 (x x_1 : { a // toDual a \u2208 \u21d1ofDual \u207b\u00b9' s }), \u21d1ofDual \u207b\u00b9' Icc \u2191x_1 \u2191x \u2286 \u21d1ofDual \u207b\u00b9' s) \u2194\n    \u2200 (x x_1 : { a // a \u2208 s }), Icc \u2191x \u2191x_1 \u2286 s"}, {"line": "exact forall_swap", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ordConnected_inter_Icc_iff (hx : x \u2208 s) (hy : y \u2208 s) :\n    OrdConnected (s \u2229 Icc x y) \u2194 Ioo x y \u2286 s := by\n  refine \u27e8fun h \u21a6 Ioo_subset_Icc_self.trans fun z hz \u21a6 ?_, ordConnected_inter_Icc_of_subset\u27e9\n  have hxy : x \u2264 y := hz.1.trans hz.2\n  exact h.out \u27e8hx, left_mem_Icc.2 hxy\u27e9 \u27e8hy, right_mem_Icc.2 hxy\u27e9 hz |>.1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/OrdConnected.lean", "context": {"open": ["scoped Interval", "Set", "OrderDual (toDual ofDual)"], "variables": ["{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2] {s : Set \u03b1}", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]", "{\u03b1 : Type*} [PartialOrder \u03b1] {s : Set \u03b1} {x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\ninst\u271d : PartialOrder \u03b1\ns : Set \u03b1\nx y : \u03b1\nhx : x \u2208 s\nhy : y \u2208 s\n\u22a2 (s \u2229 Icc x y).OrdConnected \u2194 Ioo x y \u2286 s"}, {"line": "refine \u27e8fun h \u21a6 Ioo_subset_Icc_self.trans fun z hz \u21a6 ?_, ordConnected_inter_Icc_of_subset\u27e9", "tactic_state": "\u03b1 : Type u_7\ninst\u271d : PartialOrder \u03b1\ns : Set \u03b1\nx y : \u03b1\nhx : x \u2208 s\nhy : y \u2208 s\nh : (s \u2229 Icc x y).OrdConnected\nz : \u03b1\nhz : z \u2208 Icc x y\n\u22a2 z \u2208 s"}, {"line": "have hxy : x \u2264 y := hz.1.trans hz.2", "tactic_state": "\u03b1 : Type u_7\ninst\u271d : PartialOrder \u03b1\ns : Set \u03b1\nx y : \u03b1\nhx : x \u2208 s\nhy : y \u2208 s\nh : (s \u2229 Icc x y).OrdConnected\nz : \u03b1\nhz : z \u2208 Icc x y\nhxy : sorry\n\u22a2 z \u2208 s"}, {"line": "exact h.out \u27e8hx, left_mem_Icc.2 hxy\u27e9 \u27e8hy, right_mem_Icc.2 hxy\u27e9 hz |>.1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ordConnectedComponent_univ : ordConnectedComponent univ x = univ := by\n  simp [ordConnectedComponent]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/OrdConnectedComponent.lean", "context": {"open": ["Interval Function OrderDual"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] {s t : Set \u03b1} {x y z : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nordConnectedComponent : x\u271d\n\u03b1\u271d : Sort u_3\nuniv : \u03b1\u271d\n\u22a2 sorry = univ"}, {"line": "simp [ordConnectedComponent]", "tactic_state": "x\u271d : Sort u_2\nordConnectedComponent : x\u271d\n\u03b1\u271d : Sort u_3\nuniv : \u03b1\u271d\n\u22a2 sorry () = univ"}]}
{"declaration": "lemma Set.Nonempty.eq_Icc_iff_nat {I : Set \u2115}\n    (h\u2080 : I.Nonempty) (h\u2082 : BddAbove I) :\n    I = Icc (sInf I) (sSup I) \u2194 \u2200\u1d49 (x \u2208 I) (y \u2208 I), Disjoint (Ioo x y) I \u2192 y \u2264 x + 1 := by\n  simp [\u2190 h\u2080.ordConnected_iff_of_bdd (OrderBot.bddBelow I) h\u2082, ordConnected_iff_disjoint_Ioo_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/OrdConnectedLinear.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : Set \u2115\nh\u2080 : I.Nonempty\nh\u2082 : BddAbove I\n\u22a2 I = Icc (sInf I) (sSup I) \u2194 \u2200 x \u2208 I, \u2200 y \u2208 I, Disjoint (Ioo x y) I \u2192 y \u2264 x + 1"}, {"line": "simp [\u2190 h\u2080.ordConnected_iff_of_bdd (OrderBot.bddBelow I) h\u2082, ordConnected_iff_disjoint_Ioo_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Set.Nonempty.eq_Icc_iff_int {I : Set \u2124}\n    (h\u2080 : I.Nonempty) (h\u2081 : BddBelow I) (h\u2082 : BddAbove I) :\n    I = Icc (sInf I) (sSup I) \u2194 \u2200\u1d49 (x \u2208 I) (y \u2208 I), Disjoint (Ioo x y) I \u2192 y \u2264 x + 1 := by\n  simp [\u2190 h\u2080.ordConnected_iff_of_bdd h\u2081 h\u2082, ordConnected_iff_disjoint_Ioo_empty, Int.succ]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/OrdConnectedLinear.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {I : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : Set \u2124\nh\u2080 : I.Nonempty\nh\u2081 : BddBelow I\nh\u2082 : BddAbove I\n\u22a2 I = Icc (sInf I) (sSup I) \u2194 \u2200 x \u2208 I, \u2200 y \u2208 I, Disjoint (Ioo x y) I \u2192 y \u2264 x + 1"}, {"line": "simp [\u2190 h\u2080.ordConnected_iff_of_bdd h\u2081 h\u2082, ordConnected_iff_disjoint_Ioo_empty, Int.succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_update_Icc_left (f : \u2200 i, \u03b1 i) (i : \u03b9) (a : \u03b1 i) :\n    update f i '' Icc a (f i) = Icc (update f i a) f := by simpa using image_update_Icc f i a (f i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Pi.lean", "context": {"open": ["Function", "Function (update)"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "[\u2200 i, Preorder (\u03b1 i)] (x y : \u2200 i, \u03b1 i)", "[DecidableEq \u03b9]", "[DecidableEq \u03b9] [\u2200 i, PartialOrder (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Preorder (\u03b1 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 PartialOrder (\u03b1 i)\nx\u271d : Sort u_3\nIcc : x\u271d\nf : (i : \u03b9) \u2192 \u03b1 i\ni : \u03b9\na : \u03b1 i\n\u22a2 update f i '' sorry = sorry"}, {"line": "simpa using image_update_Icc f i a (f i)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_update_Ico_left (f : \u2200 i, \u03b1 i) (i : \u03b9) (a : \u03b1 i) :\n    update f i '' Ico a (f i) = Ico (update f i a) f := by simpa using image_update_Ico f i a (f i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Pi.lean", "context": {"open": ["Function", "Function (update)"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "[\u2200 i, Preorder (\u03b1 i)] (x y : \u2200 i, \u03b1 i)", "[DecidableEq \u03b9]", "[DecidableEq \u03b9] [\u2200 i, PartialOrder (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Preorder (\u03b1 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 PartialOrder (\u03b1 i)\nx\u271d : Sort u_3\nIco : x\u271d\nf : (i : \u03b9) \u2192 \u03b1 i\ni : \u03b9\na : \u03b1 i\n\u22a2 update f i '' sorry = sorry"}, {"line": "simpa using image_update_Ico f i a (f i)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_update_Ioc_left (f : \u2200 i, \u03b1 i) (i : \u03b9) (a : \u03b1 i) :\n    update f i '' Ioc a (f i) = Ioc (update f i a) f := by simpa using image_update_Ioc f i a (f i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Pi.lean", "context": {"open": ["Function", "Function (update)"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "[\u2200 i, Preorder (\u03b1 i)] (x y : \u2200 i, \u03b1 i)", "[DecidableEq \u03b9]", "[DecidableEq \u03b9] [\u2200 i, PartialOrder (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Preorder (\u03b1 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 PartialOrder (\u03b1 i)\nx\u271d : Sort u_3\nIoc : x\u271d\nf : (i : \u03b9) \u2192 \u03b1 i\ni : \u03b9\na : \u03b1 i\n\u22a2 update f i '' sorry = sorry"}, {"line": "simpa using image_update_Ioc f i a (f i)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_update_Ioo_left (f : \u2200 i, \u03b1 i) (i : \u03b9) (a : \u03b1 i) :\n    update f i '' Ioo a (f i) = Ioo (update f i a) f := by simpa using image_update_Ioo f i a (f i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Pi.lean", "context": {"open": ["Function", "Function (update)"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "[\u2200 i, Preorder (\u03b1 i)] (x y : \u2200 i, \u03b1 i)", "[DecidableEq \u03b9]", "[DecidableEq \u03b9] [\u2200 i, PartialOrder (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Preorder (\u03b1 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 PartialOrder (\u03b1 i)\nx\u271d : Sort u_3\nIoo : x\u271d\nf : (i : \u03b9) \u2192 \u03b1 i\ni : \u03b9\na : \u03b1 i\n\u22a2 update f i '' sorry = sorry"}, {"line": "simpa using image_update_Ioo f i a (f i)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_update_Icc_right (f : \u2200 i, \u03b1 i) (i : \u03b9) (b : \u03b1 i) :\n    update f i '' Icc (f i) b = Icc f (update f i b) := by simpa using image_update_Icc f i (f i) b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Pi.lean", "context": {"open": ["Function", "Function (update)"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "[\u2200 i, Preorder (\u03b1 i)] (x y : \u2200 i, \u03b1 i)", "[DecidableEq \u03b9]", "[DecidableEq \u03b9] [\u2200 i, PartialOrder (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Preorder (\u03b1 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 PartialOrder (\u03b1 i)\nx\u271d : Sort u_3\nIcc : x\u271d\nf : (i : \u03b9) \u2192 \u03b1 i\ni : \u03b9\nb : \u03b1 i\n\u22a2 update f i '' sorry = sorry"}, {"line": "simpa using image_update_Icc f i (f i) b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_update_Ico_right (f : \u2200 i, \u03b1 i) (i : \u03b9) (b : \u03b1 i) :\n    update f i '' Ico (f i) b = Ico f (update f i b) := by simpa using image_update_Ico f i (f i) b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Pi.lean", "context": {"open": ["Function", "Function (update)"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "[\u2200 i, Preorder (\u03b1 i)] (x y : \u2200 i, \u03b1 i)", "[DecidableEq \u03b9]", "[DecidableEq \u03b9] [\u2200 i, PartialOrder (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Preorder (\u03b1 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 PartialOrder (\u03b1 i)\nx\u271d : Sort u_3\nIco : x\u271d\nf : (i : \u03b9) \u2192 \u03b1 i\ni : \u03b9\nb : \u03b1 i\n\u22a2 update f i '' sorry = sorry"}, {"line": "simpa using image_update_Ico f i (f i) b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_update_Ioc_right (f : \u2200 i, \u03b1 i) (i : \u03b9) (b : \u03b1 i) :\n    update f i '' Ioc (f i) b = Ioc f (update f i b) := by simpa using image_update_Ioc f i (f i) b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Pi.lean", "context": {"open": ["Function", "Function (update)"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "[\u2200 i, Preorder (\u03b1 i)] (x y : \u2200 i, \u03b1 i)", "[DecidableEq \u03b9]", "[DecidableEq \u03b9] [\u2200 i, PartialOrder (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Preorder (\u03b1 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 PartialOrder (\u03b1 i)\nx\u271d : Sort u_3\nIoc : x\u271d\nf : (i : \u03b9) \u2192 \u03b1 i\ni : \u03b9\nb : \u03b1 i\n\u22a2 update f i '' sorry = sorry"}, {"line": "simpa using image_update_Ioc f i (f i) b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_update_Ioo_right (f : \u2200 i, \u03b1 i) (i : \u03b9) (b : \u03b1 i) :\n    update f i '' Ioo (f i) b = Ioo f (update f i b) := by simpa using image_update_Ioo f i (f i) b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Pi.lean", "context": {"open": ["Function", "Function (update)"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "[\u2200 i, Preorder (\u03b1 i)] (x y : \u2200 i, \u03b1 i)", "[DecidableEq \u03b9]", "[DecidableEq \u03b9] [\u2200 i, PartialOrder (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Preorder (\u03b1 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 PartialOrder (\u03b1 i)\nx\u271d : Sort u_3\nIoo : x\u271d\nf : (i : \u03b9) \u2192 \u03b1 i\ni : \u03b9\nb : \u03b1 i\n\u22a2 update f i '' sorry = sorry"}, {"line": "simpa using image_update_Ioo f i (f i) b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_update_uIcc_right (f : \u2200 i, \u03b1 i) (i : \u03b9) (b : \u03b1 i) :\n    update f i '' uIcc (f i) b = uIcc f (update f i b) := by\n  simpa using image_update_uIcc f i (f i) b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/Pi.lean", "context": {"open": ["Function", "Function (update)"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "[\u2200 i, Preorder (\u03b1 i)] (x y : \u2200 i, \u03b1 i)", "[DecidableEq \u03b9]", "[DecidableEq \u03b9] [\u2200 i, PartialOrder (\u03b1 i)]", "[\u2200 i, One (\u03b1 i)]", "[\u2200 i, Lattice (\u03b1 i)]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u2076 : (i : \u03b9) \u2192 Preorder (\u03b1 i)\ninst\u271d\u2075 inst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : (i : \u03b9) \u2192 PartialOrder (\u03b1 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 One (\u03b1 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Lattice (\u03b1 i)\ninst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_3\nuIcc : x\u271d\nf : (i : \u03b9) \u2192 \u03b1 i\ni : \u03b9\nb : \u03b1 i\n\u22a2 update f i '' sorry = sorry"}, {"line": "simpa using image_update_uIcc f i (f i) b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem surjOn_Ioo_of_monotone_surjective (h_mono : Monotone f) (h_surj : Function.Surjective f)\n    (a b : \u03b1) : SurjOn f (Ioo a b) (Ioo (f a) (f b)) := by\n  intro p hp\n  rcases h_surj p with \u27e8x, rfl\u27e9\n  refine \u27e8x, mem_Ioo.2 ?_, rfl\u27e9\n  contrapose! hp\n  exact fun h => h.2.not_le (h_mono <| hp <| h_mono.reflect_lt h.1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/SurjOn.lean", "context": {"open": ["Set Function", "OrderDual (toDual)"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} [LinearOrder \u03b1] [PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nh_mono : Monotone f\nh_surj : Surjective f\na b : \u03b1\n\u22a2 SurjOn f (Ioo a b) (Ioo (f a) (f b))"}, {"line": "intro p hp", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nh_mono : Monotone f\nh_surj : Surjective f\na b : \u03b1\np : \u03b2\nhp : p \u2208 Ioo (f a) (f b)\n\u22a2 p \u2208 f '' Ioo a b"}, {"line": "rcases h_surj p with \u27e8x, rfl\u27e9", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nh_mono : Monotone f\nh_surj : Surjective f\na b x : \u03b1\nhp : f x \u2208 Ioo (f a) (f b)\n\u22a2 f x \u2208 f '' Ioo a b"}, {"line": "refine \u27e8x, mem_Ioo.2 ?_, rfl\u27e9", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nh_mono : Monotone f\nh_surj : Surjective f\na b x : \u03b1\nhp : f x \u2208 Ioo (f a) (f b)\n\u22a2 a < x \u2227 x < b"}, {"line": "contrapose! hp", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nh_mono : Monotone f\nh_surj : Surjective f\na b x : \u03b1\nhp : a < x \u2192 \u00acx < b\n\u22a2 f x \u2209 Ioo (f a) (f b)"}, {"line": "exact fun h => h.2.not_le (h_mono <| hp <| h_mono.reflect_lt h.1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem surjOn_Ioc_of_monotone_surjective (h_mono : Monotone f) (h_surj : Function.Surjective f)\n    (a b : \u03b1) : SurjOn f (Ioc a b) (Ioc (f a) (f b)) := by\n  simpa using surjOn_Ico_of_monotone_surjective h_mono.dual h_surj (toDual b) (toDual a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/SurjOn.lean", "context": {"open": ["Set Function", "OrderDual (toDual)"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} [LinearOrder \u03b1] [PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nh_mono : Monotone f\nh_surj : Surjective f\na b : \u03b1\n\u22a2 SurjOn f (Ioc a b) (Ioc (f a) (f b))"}, {"line": "simpa using surjOn_Ico_of_monotone_surjective h_mono.dual h_surj (toDual b) (toDual a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem surjOn_Ici_of_monotone_surjective (h_mono : Monotone f) (h_surj : Function.Surjective f)\n    (a : \u03b1) : SurjOn f (Ici a) (Ici (f a)) := by\n  rw [\u2190 Ioi_union_left]\n  rw [\u2190 Ioi_union_left]\n  exact\n    (surjOn_Ioi_of_monotone_surjective h_mono h_surj a).union_union\n      (@image_singleton _ _ f a \u25b8 surjOn_image _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/SurjOn.lean", "context": {"open": ["Set Function", "OrderDual (toDual)"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} [LinearOrder \u03b1] [PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nh_mono : Monotone f\nh_surj : Surjective f\na : \u03b1\n\u22a2 SurjOn f (Ici a) (Ici (f a))"}, {"line": "rw [\u2190 Ioi_union_left]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nh_mono : Monotone f\nh_surj : Surjective f\na : \u03b1\n\u22a2 SurjOn f (Ioi a \u222a {a}) (Ici (f a))"}, {"line": "rw [\u2190 Ioi_union_left]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nh_mono : Monotone f\nh_surj : Surjective f\na : \u03b1\n\u22a2 SurjOn f (Ioi a \u222a {a}) (Ioi (f a) \u222a {f a})"}, {"line": "exact\n    (surjOn_Ioi_of_monotone_surjective h_mono h_surj a).union_union\n      (@image_singleton _ _ f a \u25b8 surjOn_image _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma uIcc_self : [[a, a]] = {a} := by simp [uIcc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/UnorderedInterval.lean", "context": {"open": ["Function", "OrderDual (toDual ofDual)", "Interval"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Lattice \u03b1] [Lattice \u03b2] {a a\u2081 a\u2082 b b\u2081 b\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Lattice \u03b1\na : \u03b1\n\u22a2 Set.uIcc a a = {a}"}, {"line": "simp [uIcc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uIcc_prod_eq (a b : \u03b1 \u00d7 \u03b2) : [[a, b]] = [[a.1, b.1]] \u00d7\u02e2 [[a.2, b.2]] := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/UnorderedInterval.lean", "context": {"open": ["Function", "OrderDual (toDual ofDual)", "Interval"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Lattice \u03b1] [Lattice \u03b2] {a a\u2081 a\u2082 b b\u2081 b\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : Lattice \u03b2\na b : \u03b1 \u00d7 \u03b2\n\u22a2 Set.uIcc a b = Set.uIcc a.1 b.1 \u00d7\u02e2 Set.uIcc a.2 b.2"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_of_mem_uIcc_of_mem_uIcc' : b \u2208 [[a, c]] \u2192 c \u2208 [[a, b]] \u2192 b = c := by\n  simpa only [uIcc_comm a] using eq_of_mem_uIcc_of_mem_uIcc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/UnorderedInterval.lean", "context": {"open": ["Function", "OrderDual (toDual ofDual)", "Interval", "Interval"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Lattice \u03b1] [Lattice \u03b2] {a a\u2081 a\u2082 b b\u2081 b\u2082 x : \u03b1}", "[DistribLattice \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : DistribLattice \u03b1\na b c : \u03b1\n\u22a2 b \u2208 Set.uIcc a c \u2192 c \u2208 Set.uIcc a b \u2192 b = c"}, {"line": "simpa only [uIcc_comm a] using eq_of_mem_uIcc_of_mem_uIcc", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_of_mem_uIoc_of_mem_uIoc' : b \u2208 \u0399 a c \u2192 c \u2208 \u0399 a b \u2192 b = c := by\n  simpa only [uIoc_comm a] using eq_of_mem_uIoc_of_mem_uIoc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/UnorderedInterval.lean", "context": {"open": ["Function", "OrderDual (toDual ofDual)", "Interval", "Interval", "scoped Interval"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Lattice \u03b1] [Lattice \u03b2] {a a\u2081 a\u2082 b b\u2081 b\u2082 x : \u03b1}", "[DistribLattice \u03b1] {a b c : \u03b1}", "[LinearOrder \u03b1]", "[Lattice \u03b2] {f : \u03b1 \u2192 \u03b2} {a b : \u03b1}", "[LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : DistribLattice \u03b1\ninst\u271d : LinearOrder \u03b1\na b c : \u03b1\n\u22a2 b \u2208 Set.uIoc a c \u2192 c \u2208 Set.uIoc a b \u2192 b = c"}, {"line": "simpa only [uIoc_comm a] using eq_of_mem_uIoc_of_mem_uIoc", "tactic_state": "No Goals!"}]}
{"declaration": "lemma uIoc_injective_left (a : \u03b1) : Injective (\u0399 a) := by\n  simpa only [uIoc_comm] using uIoc_injective_right a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/UnorderedInterval.lean", "context": {"open": ["Function", "OrderDual (toDual ofDual)", "Interval", "Interval", "scoped Interval"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Lattice \u03b1] [Lattice \u03b2] {a a\u2081 a\u2082 b b\u2081 b\u2082 x : \u03b1}", "[DistribLattice \u03b1] {a b c : \u03b1}", "[LinearOrder \u03b1]", "[Lattice \u03b2] {f : \u03b1 \u2192 \u03b2} {a b : \u03b1}", "[LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : DistribLattice \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\n\u22a2 Injective (Set.uIoc a)"}, {"line": "simpa only [uIoc_comm] using uIoc_injective_right a", "tactic_state": "No Goals!"}]}
{"declaration": "lemma uIoo_self : uIoo a a = \u2205 := by simp [uIoo]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Interval/Set/UnorderedInterval.lean", "context": {"open": ["Function", "OrderDual (toDual ofDual)", "Interval", "Interval", "scoped Interval"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Lattice \u03b1] [Lattice \u03b2] {a a\u2081 a\u2082 b b\u2081 b\u2082 x : \u03b1}", "[DistribLattice \u03b1] {a b c : \u03b1}", "[LinearOrder \u03b1]", "[Lattice \u03b2] {f : \u03b1 \u2192 \u03b2} {a b : \u03b1}", "[LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nuIoo : x\u271d\n\u22a2 sorry = \u2205"}, {"line": "simp [uIoo]", "tactic_state": "x\u271d : Sort u_3\nuIoo : x\u271d\n\u22a2 sorry () = \u2205"}]}
{"declaration": "lemma monovary_iff_exists_monotone :\n    Monovary f g \u2194 \u2203 (_ : LinearOrder \u03b9), Monotone f \u2227 Monotone g := by\n  simp [\u2190 monovaryOn_univ, monovaryOn_iff_exists_monotoneOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/MonovaryOrder.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b9 \u03b9' \u03b1 \u03b2 \u03b3 : Type*}", "[LinearOrder \u03b1] [LinearOrder \u03b2] (f : \u03b9 \u2192 \u03b1) (g : \u03b9 \u2192 \u03b2) {s : Set \u03b9}", "{f g}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b9 \u2192 \u03b1\ng : \u03b9 \u2192 \u03b2\n\u22a2 Monovary f g \u2194 \u2203 x, Monotone f \u2227 Monotone g"}, {"line": "simp [\u2190 monovaryOn_univ, monovaryOn_iff_exists_monotoneOn]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma monovary_iff_exists_antitone :\n    Monovary f g \u2194 \u2203 (_ : LinearOrder \u03b9), Antitone f \u2227 Antitone g := by\n  simp [\u2190 monovaryOn_univ, monovaryOn_iff_exists_antitoneOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/MonovaryOrder.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b9 \u03b9' \u03b1 \u03b2 \u03b3 : Type*}", "[LinearOrder \u03b1] [LinearOrder \u03b2] (f : \u03b9 \u2192 \u03b1) (g : \u03b9 \u2192 \u03b2) {s : Set \u03b9}", "{f g}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b9 \u2192 \u03b1\ng : \u03b9 \u2192 \u03b2\n\u22a2 Monovary f g \u2194 \u2203 x, Antitone f \u2227 Antitone g"}, {"line": "simp [\u2190 monovaryOn_univ, monovaryOn_iff_exists_antitoneOn]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma antivary_iff_exists_monotone_antitone :\n    Antivary f g \u2194 \u2203 (_ : LinearOrder \u03b9), Monotone f \u2227 Antitone g := by\n  simp [\u2190 antivaryOn_univ, antivaryOn_iff_exists_monotoneOn_antitoneOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/MonovaryOrder.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b9 \u03b9' \u03b1 \u03b2 \u03b3 : Type*}", "[LinearOrder \u03b1] [LinearOrder \u03b2] (f : \u03b9 \u2192 \u03b1) (g : \u03b9 \u2192 \u03b2) {s : Set \u03b9}", "{f g}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b9 \u2192 \u03b1\ng : \u03b9 \u2192 \u03b2\n\u22a2 Antivary f g \u2194 \u2203 x, Monotone f \u2227 Antitone g"}, {"line": "simp [\u2190 antivaryOn_univ, antivaryOn_iff_exists_monotoneOn_antitoneOn]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma antivary_iff_exists_antitone_monotone :\n    Antivary f g \u2194 \u2203 (_ : LinearOrder \u03b9), Antitone f \u2227 Monotone g := by\n  simp [\u2190 antivaryOn_univ, antivaryOn_iff_exists_antitoneOn_monotoneOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/MonovaryOrder.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b9 \u03b9' \u03b1 \u03b2 \u03b3 : Type*}", "[LinearOrder \u03b1] [LinearOrder \u03b2] (f : \u03b9 \u2192 \u03b1) (g : \u03b9 \u2192 \u03b2) {s : Set \u03b9}", "{f g}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b9 \u2192 \u03b1\ng : \u03b9 \u2192 \u03b2\n\u22a2 Antivary f g \u2194 \u2203 x, Antitone f \u2227 Monotone g"}, {"line": "simp [\u2190 antivaryOn_univ, antivaryOn_iff_exists_antitoneOn_monotoneOn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem monotone_dual_iff : Monotone (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) \u2194 Monotone f := by\n  rw [monotone_toDual_comp_iff]\n  rw [antitone_comp_ofDual_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Monotone (\u21d1toDual \u2218 f \u2218 \u21d1ofDual) \u2194 Monotone f"}, {"line": "rw [monotone_toDual_comp_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Antitone (f \u2218 \u21d1ofDual) \u2194 Monotone f"}, {"line": "rw [antitone_comp_ofDual_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem antitone_dual_iff : Antitone (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) \u2194 Antitone f := by\n  rw [antitone_toDual_comp_iff]\n  rw [monotone_comp_ofDual_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Antitone (\u21d1toDual \u2218 f \u2218 \u21d1ofDual) \u2194 Antitone f"}, {"line": "rw [antitone_toDual_comp_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Monotone (f \u2218 \u21d1ofDual) \u2194 Antitone f"}, {"line": "rw [monotone_comp_ofDual_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem monotoneOn_dual_iff : MonotoneOn (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) s \u2194 MonotoneOn f s := by\n  rw [monotoneOn_toDual_comp_iff]\n  rw [antitoneOn_comp_ofDual_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 MonotoneOn (\u21d1toDual \u2218 f \u2218 \u21d1ofDual) s \u2194 MonotoneOn f s"}, {"line": "rw [monotoneOn_toDual_comp_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 AntitoneOn (f \u2218 \u21d1ofDual) s \u2194 MonotoneOn f s"}, {"line": "rw [antitoneOn_comp_ofDual_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem antitoneOn_dual_iff : AntitoneOn (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) s \u2194 AntitoneOn f s := by\n  rw [antitoneOn_toDual_comp_iff]\n  rw [monotoneOn_comp_ofDual_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 AntitoneOn (\u21d1toDual \u2218 f \u2218 \u21d1ofDual) s \u2194 AntitoneOn f s"}, {"line": "rw [antitoneOn_toDual_comp_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 MonotoneOn (f \u2218 \u21d1ofDual) s \u2194 AntitoneOn f s"}, {"line": "rw [monotoneOn_comp_ofDual_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem strictMono_dual_iff : StrictMono (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) \u2194 StrictMono f := by\n  rw [strictMono_toDual_comp_iff]\n  rw [strictAnti_comp_ofDual_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 StrictMono (\u21d1toDual \u2218 f \u2218 \u21d1ofDual) \u2194 StrictMono f"}, {"line": "rw [strictMono_toDual_comp_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 StrictAnti (f \u2218 \u21d1ofDual) \u2194 StrictMono f"}, {"line": "rw [strictAnti_comp_ofDual_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem strictAnti_dual_iff : StrictAnti (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) \u2194 StrictAnti f := by\n  rw [strictAnti_toDual_comp_iff]\n  rw [strictMono_comp_ofDual_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 StrictAnti (\u21d1toDual \u2218 f \u2218 \u21d1ofDual) \u2194 StrictAnti f"}, {"line": "rw [strictAnti_toDual_comp_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 StrictMono (f \u2218 \u21d1ofDual) \u2194 StrictAnti f"}, {"line": "rw [strictMono_comp_ofDual_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem strictMonoOn_dual_iff :\n    StrictMonoOn (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) s \u2194 StrictMonoOn f s := by\n  rw [strictMonoOn_toDual_comp_iff]\n  rw [strictAntiOn_comp_ofDual_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 StrictMonoOn (\u21d1toDual \u2218 f \u2218 \u21d1ofDual) s \u2194 StrictMonoOn f s"}, {"line": "rw [strictMonoOn_toDual_comp_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 StrictAntiOn (f \u2218 \u21d1ofDual) s \u2194 StrictMonoOn f s"}, {"line": "rw [strictAntiOn_comp_ofDual_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem strictAntiOn_dual_iff :\n    StrictAntiOn (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) s \u2194 StrictAntiOn f s := by\n  rw [strictAntiOn_toDual_comp_iff]\n  rw [strictMonoOn_comp_ofDual_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 StrictAntiOn (\u21d1toDual \u2218 f \u2218 \u21d1ofDual) s \u2194 StrictAntiOn f s"}, {"line": "rw [strictAntiOn_toDual_comp_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 StrictMonoOn (f \u2218 \u21d1ofDual) s \u2194 StrictAntiOn f s"}, {"line": "rw [strictMonoOn_comp_ofDual_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_self_mono : Monotone fun n : \u2115 \u21a6 n ^ n := by\n  refine monotone_nat_of_le_succ fun n \u21a6 ?_\n  rw [Nat.pow_succ]\n  exact (Nat.pow_le_pow_left n.le_succ _).trans (Nat.le_mul_of_pos_right _ n.succ_pos)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/Basic.lean", "context": {"open": ["Function OrderDual", "Ordering"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}", "[Preorder \u03b1] [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1}", "[LinearOrder \u03b1]", "[Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2}", "[LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x y : \u03b1}", "[Preorder \u03b1]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Monotone fun n => n ^ n"}, {"line": "refine monotone_nat_of_le_succ fun n \u21a6 ?_", "tactic_state": "n : \u2115\n\u22a2 n ^ n \u2264 (n + 1) ^ (n + 1)"}, {"line": "rw [Nat.pow_succ]", "tactic_state": "n : \u2115\n\u22a2 n ^ n \u2264 (n + 1) ^ n * (n + 1)"}, {"line": "exact (Nat.pow_le_pow_left n.le_succ _).trans (Nat.le_mul_of_pos_right _ n.succ_pos)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Monotone.ne_of_lt_of_lt_nat {f : \u2115 \u2192 \u03b1} (hf : Monotone f) (n : \u2115) {x : \u03b1} (h1 : f n < x)\n    (h2 : x < f (n + 1)) (a : \u2115) : f a \u2260 x := by\n  rintro rfl\n  exact (hf.reflect_lt h1).not_le (Nat.le_of_lt_succ <| hf.reflect_lt h2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/Basic.lean", "context": {"open": ["Function OrderDual", "Ordering"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}", "[Preorder \u03b1] [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1}", "[LinearOrder \u03b1]", "[Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2}", "[LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x y : \u03b1}", "[Preorder \u03b1]", "(\u03b1)", "(\u03b1)", "[Nonempty \u03b1] [NoMinOrder \u03b1] [NoMaxOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Nonempty \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nf : \u2115 \u2192 \u03b1\nhf : Monotone f\nn : \u2115\nx : \u03b1\nh1 : f n < x\nh2 : x < f (n + 1)\na : \u2115\n\u22a2 f a \u2260 x"}, {"line": "rintro rfl", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Nonempty \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nf : \u2115 \u2192 \u03b1\nhf : Monotone f\nn a : \u2115\nh1 : f n < f a\nh2 : f a < f (n + 1)\n\u22a2 False"}, {"line": "exact (hf.reflect_lt h1).not_le (Nat.le_of_lt_succ <| hf.reflect_lt h2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antitone.ne_of_lt_of_lt_nat {f : \u2115 \u2192 \u03b1} (hf : Antitone f) (n : \u2115) {x : \u03b1}\n    (h1 : f (n + 1) < x) (h2 : x < f n) (a : \u2115) : f a \u2260 x := by\n  rintro rfl\n  exact (hf.reflect_lt h2).not_le (Nat.le_of_lt_succ <| hf.reflect_lt h1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/Basic.lean", "context": {"open": ["Function OrderDual", "Ordering"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}", "[Preorder \u03b1] [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1}", "[LinearOrder \u03b1]", "[Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2}", "[LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x y : \u03b1}", "[Preorder \u03b1]", "(\u03b1)", "(\u03b1)", "[Nonempty \u03b1] [NoMinOrder \u03b1] [NoMaxOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Nonempty \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nf : \u2115 \u2192 \u03b1\nhf : Antitone f\nn : \u2115\nx : \u03b1\nh1 : f (n + 1) < x\nh2 : x < f n\na : \u2115\n\u22a2 f a \u2260 x"}, {"line": "rintro rfl", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Nonempty \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nf : \u2115 \u2192 \u03b1\nhf : Antitone f\nn a : \u2115\nh1 : f (n + 1) < f a\nh2 : f a < f n\n\u22a2 False"}, {"line": "exact (hf.reflect_lt h2).not_le (Nat.le_of_lt_succ <| hf.reflect_lt h1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Monotone.ne_of_lt_of_lt_int {f : \u2124 \u2192 \u03b1} (hf : Monotone f) (n : \u2124) {x : \u03b1} (h1 : f n < x)\n    (h2 : x < f (n + 1)) (a : \u2124) : f a \u2260 x := by\n  rintro rfl\n  exact (hf.reflect_lt h1).not_le (Int.le_of_lt_add_one <| hf.reflect_lt h2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/Basic.lean", "context": {"open": ["Function OrderDual", "Ordering"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}", "[Preorder \u03b1] [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1}", "[LinearOrder \u03b1]", "[Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2}", "[LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x y : \u03b1}", "[Preorder \u03b1]", "(\u03b1)", "(\u03b1)", "[Nonempty \u03b1] [NoMinOrder \u03b1] [NoMaxOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Nonempty \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nf : \u2124 \u2192 \u03b1\nhf : Monotone f\nn : \u2124\nx : \u03b1\nh1 : f n < x\nh2 : x < f (n + 1)\na : \u2124\n\u22a2 f a \u2260 x"}, {"line": "rintro rfl", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Nonempty \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nf : \u2124 \u2192 \u03b1\nhf : Monotone f\nn a : \u2124\nh1 : f n < f a\nh2 : f a < f (n + 1)\n\u22a2 False"}, {"line": "exact (hf.reflect_lt h1).not_le (Int.le_of_lt_add_one <| hf.reflect_lt h2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antitone.ne_of_lt_of_lt_int {f : \u2124 \u2192 \u03b1} (hf : Antitone f) (n : \u2124) {x : \u03b1}\n    (h1 : f (n + 1) < x) (h2 : x < f n) (a : \u2124) : f a \u2260 x := by\n  rintro rfl\n  exact (hf.reflect_lt h2).not_le (Int.le_of_lt_add_one <| hf.reflect_lt h1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/Basic.lean", "context": {"open": ["Function OrderDual", "Ordering"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}", "[Preorder \u03b1] [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1}", "[LinearOrder \u03b1]", "[Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2}", "[LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x y : \u03b1}", "[Preorder \u03b1]", "(\u03b1)", "(\u03b1)", "[Nonempty \u03b1] [NoMinOrder \u03b1] [NoMaxOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Nonempty \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nf : \u2124 \u2192 \u03b1\nhf : Antitone f\nn : \u2124\nx : \u03b1\nh1 : f (n + 1) < x\nh2 : x < f n\na : \u2124\n\u22a2 f a \u2260 x"}, {"line": "rintro rfl", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Nonempty \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nf : \u2124 \u2192 \u03b1\nhf : Antitone f\nn a : \u2124\nh1 : f (n + 1) < f a\nh2 : f a < f n\n\u22a2 False"}, {"line": "exact (hf.reflect_lt h2).not_le (Int.le_of_lt_add_one <| hf.reflect_lt h1)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Nat.stabilises_of_monotone {f : \u2115 \u2192 \u2115} {b n : \u2115} (hfmono : Monotone f) (hfb : \u2200 m, f m \u2264 b)\n    (hfstab : \u2200 m, f m = f (m + 1) \u2192 f (m + 1) = f (m + 2)) (hbn : b \u2264 n) : f n = f b := by\n  obtain \u27e8m, hmb, hm\u27e9 : \u2203 m \u2264 b, f m = f (m + 1) := by\n    contrapose! hfb\n    let rec strictMono : \u2200 m \u2264 b + 1, m \u2264 f m\n    | 0, _ => Nat.zero_le _\n    | m + 1, hmb => (strictMono _ <| m.le_succ.trans hmb).trans_lt <| (hfmono m.le_succ).lt_of_ne <|\n        hfb _ <| Nat.le_of_succ_le_succ hmb\n    exact \u27e8b + 1, strictMono _ le_rfl\u27e9\n  replace key : \u2200 k : \u2115, f (m + k) = f (m + k + 1) \u2227 f (m + k) = f m := fun k =>\n    Nat.rec \u27e8hm, rfl\u27e9 (fun k ih => \u27e8hfstab _ ih.1, ih.1.symm.trans ih.2\u27e9) k\n  replace key : \u2200 k \u2265 m, f k = f m := fun k hk =>\n    (congr_arg f (Nat.add_sub_of_le hk)).symm.trans (key (k - m)).2\n  exact (key n (hmb.trans hbn)).trans (key b hmb).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/Basic.lean", "context": {"open": ["Function OrderDual", "Ordering"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}", "[Preorder \u03b1] [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1}", "[LinearOrder \u03b1]", "[Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2}", "[LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x y : \u03b1}", "[Preorder \u03b1]", "(\u03b1)", "(\u03b1)", "[Nonempty \u03b1] [NoMinOrder \u03b1] [NoMaxOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u2115\nb n : \u2115\nhfmono : Monotone f\nhfb : \u2200 (m : \u2115), f m \u2264 b\nhfstab : \u2200 (m : \u2115), f m = f (m + 1) \u2192 f (m + 1) = f (m + 2)\nhbn : b \u2264 n\n\u22a2 f n = f b"}, {"line": "obtain \u27e8m, hmb, hm\u27e9 : \u2203 m \u2264 b, f m = f (m + 1) := by\n    contrapose! hfb\n    let rec strictMono : \u2200 m \u2264 b + 1, m \u2264 f m\n    | 0, _ => Nat.zero_le _\n    | m + 1, hmb => (strictMono _ <| m.le_succ.trans hmb).trans_lt <| (hfmono m.le_succ).lt_of_ne <|\n        hfb _ <| Nat.le_of_succ_le_succ hmb\n    exact \u27e8b + 1, strictMono _ le_rfl\u27e9", "tactic_state": "case intro.intro\nf : \u2115 \u2192 \u2115\nb n : \u2115\nhfmono : Monotone f\nhfb : \u2200 (m : \u2115), f m \u2264 b\nhfstab : \u2200 (m : \u2115), f m = f (m + 1) \u2192 f (m + 1) = f (m + 2)\nhbn : b \u2264 n\nm : \u2115\nhmb : m \u2264 b\nhm : f m = f (m + 1)\n\u22a2 f n = f b"}, {"line": "replace key : \u2200 k : \u2115, f (m + k) = f (m + k + 1) \u2227 f (m + k) = f m := fun k =>\n    Nat.rec \u27e8hm, rfl\u27e9 (fun k ih => \u27e8hfstab _ ih.1, ih.1.symm.trans ih.2\u27e9) k", "tactic_state": "case intro.intro\nf : \u2115 \u2192 \u2115\nb n : \u2115\nhfmono : Monotone f\nhfb : \u2200 (m : \u2115), f m \u2264 b\nhfstab : \u2200 (m : \u2115), f m = f (m + 1) \u2192 f (m + 1) = f (m + 2)\nhbn : b \u2264 n\nm : \u2115\nhmb : m \u2264 b\nhm : f m = f (m + 1)\nkey : \u2200 (k : \u2115), f (m + k) = f (m + k + 1) \u2227 f (m + k) = f m\n\u22a2 f n = f b"}, {"line": "replace key : \u2200 k \u2265 m, f k = f m := fun k hk =>\n    (congr_arg f (Nat.add_sub_of_le hk)).symm.trans (key (k - m)).2", "tactic_state": "case intro.intro\nf : \u2115 \u2192 \u2115\nb n : \u2115\nhfmono : Monotone f\nhfb : \u2200 (m : \u2115), f m \u2264 b\nhfstab : \u2200 (m : \u2115), f m = f (m + 1) \u2192 f (m + 1) = f (m + 2)\nhbn : b \u2264 n\nm : \u2115\nhmb : m \u2264 b\nhm : f m = f (m + 1)\nkey : \u2200 k \u2265 m, f k = f m\n\u22a2 f n = f b"}, {"line": "exact (key n (hmb.trans hbn)).trans (key b hmb).symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma monotone_iff_apply\u2082 : Monotone f \u2194 \u2200 i, Monotone (f \u00b7 i) := by\n  simp [Monotone, Pi.le_def, @forall_swap \u03b9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/Defs.lean", "context": {"open": ["Function OrderDual", "Ordering"], "variables": ["{\u03b9 : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b4 : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2]", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1]", "[Preorder \u03b3]", "[Preorder \u03b1]", "[Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a b : \u03b1}", "[PartialOrder \u03b2] {f : \u03b1 \u2192 \u03b2}", "[PartialOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2]", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[LinearOrder \u03b1]", "[Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] [Preorder \u03b4] {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4}", "[PartialOrder \u03b1] [PartialOrder \u03b2] [Preorder \u03b3] [Preorder \u03b4] {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4}", "[Preorder \u03b1] [DecidableEq \u03b9] [\u2200 i, Preorder (\u03c0 i)] {f : \u2200 i, \u03c0 i} {i : \u03b9}", "{\u03b2 : \u03b9 \u2192 Type*} [\u2200 i, Preorder (\u03b2 i)] [Preorder \u03b1] {f : \u03b1 \u2192 \u2200 i, \u03b2 i}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u\ninst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 inst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b9\n\u03b2 : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Preorder (\u03b2 i)\ninst\u271d : Preorder \u03b1\nf : \u03b1 \u2192 (i : \u03b9) \u2192 \u03b2 i\n\u22a2 Monotone f \u2194 \u2200 (i : \u03b9), Monotone fun x => f x i"}, {"line": "simp [Monotone, Pi.le_def, @forall_swap \u03b9]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma monovaryOn_iff_monovary : MonovaryOn f g s \u2194 Monovary (fun i : s \u21a6 f i) fun i \u21a6 g i := by\n  simp [Monovary, MonovaryOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/Monovary.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b9 \u03b9' \u03b1 \u03b2 \u03b3 : Type*}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b9 \u2192 \u03b1} {f' : \u03b1 \u2192 \u03b3} {g : \u03b9 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b9 \u2192 \u03b1\ng : \u03b9 \u2192 \u03b2\ns : Set \u03b9\n\u22a2 MonovaryOn f g s \u2194 Monovary (fun i => f \u2191i) fun i => g \u2191i"}, {"line": "simp [Monovary, MonovaryOn]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma antivaryOn_iff_antivary : AntivaryOn f g s \u2194 Antivary (fun i : s \u21a6 f i) fun i \u21a6 g i := by\n  simp [Antivary, AntivaryOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Monotone/Monovary.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b9 \u03b9' \u03b1 \u03b2 \u03b3 : Type*}", "[Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b9 \u2192 \u03b1} {f' : \u03b1 \u2192 \u03b3} {g : \u03b9 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b9 \u2192 \u03b1\ng : \u03b9 \u2192 \u03b2\ns : Set \u03b9\n\u22a2 AntivaryOn f g s \u2194 Antivary (fun i => f \u2191i) fun i => g \u2191i"}, {"line": "simp [Antivary, AntivaryOn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsEquipartition.filter_ne_average_add_one_eq_average (hP : P.IsEquipartition) :\n    {p \u2208 P.parts | \u00ac#p = #s / #P.parts + 1} = {p \u2208 P.parts | #p = #s / #P.parts} := by\n  ext p\n  simp only [mem_filter]\n  simp only [and_congr_right_iff]\n  exact fun hp \u21a6 (hP.card_part_eq_average_iff hp).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Partition/Equipartition.lean", "context": {"open": ["Finset Fintype"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] {s t : Finset \u03b1} (P : Finpartition s)", "{P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nP : Finpartition s\nhP : P.IsEquipartition\n\u22a2 {p \u2208 P.parts | \u00acp.card = s.card / P.parts.card + 1} = {p \u2208 P.parts | p.card = s.card / P.parts.card}"}, {"line": "ext p", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nP : Finpartition s\nhP : P.IsEquipartition\np : Finset \u03b1\n\u22a2 p \u2208 {p \u2208 P.parts | \u00acp.card = s.card / P.parts.card + 1} \u2194 p \u2208 {p \u2208 P.parts | p.card = s.card / P.parts.card}"}, {"line": "simp only [mem_filter]", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nP : Finpartition s\nhP : P.IsEquipartition\np : Finset \u03b1\n\u22a2 p \u2208 P.parts \u2227 \u00acp.card = s.card / P.parts.card + 1 \u2194 p \u2208 P.parts \u2227 p.card = s.card / P.parts.card"}, {"line": "simp only [and_congr_right_iff]", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nP : Finpartition s\nhP : P.IsEquipartition\np : Finset \u03b1\n\u22a2 p \u2208 P.parts \u2192 (\u00acp.card = s.card / P.parts.card + 1 \u2194 p.card = s.card / P.parts.card)"}, {"line": "exact fun hp \u21a6 (hP.card_part_eq_average_iff hp).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem parts_top_subset (a : \u03b1) [Decidable (a = \u22a5)] : (\u22a4 : Finpartition a).parts \u2286 {a} := by\n  intro b hb\n  have hb : b \u2208 Finpartition.parts (dite _ _ _) := hb\n  split_ifs at hb\n  \u00b7 simp only [copy_parts, empty_parts, not_mem_empty] at hb\n  \u00b7 exact hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Partition/Finpartition.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 : Type*}", "[Lattice \u03b1] [OrderBot \u03b1]", "(\u03b1)", "{\u03b1} {a : \u03b1}", "(P : Finpartition a)", "{P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\na : \u03b1\ninst\u271d : Decidable (a = \u22a5)\n\u22a2 \u22a4.parts \u2286 {a}"}, {"line": "intro b hb", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\na : \u03b1\ninst\u271d : Decidable (a = \u22a5)\nb : \u03b1\nhb : b \u2208 \u22a4.parts\n\u22a2 b \u2208 {a}"}, {"line": "have hb : b \u2208 Finpartition.parts (dite _ _ _) := hb", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\na : \u03b1\ninst\u271d : Decidable (a = \u22a5)\nb : \u03b1\nhb\u271d : b \u2208 \u22a4.parts\nhb : b \u2208 (if ha : a = \u22a5 then (Finpartition.empty \u03b1).copy \u22ef else Finpartition.indiscrete ha).parts\n\u22a2 b \u2208 {a}"}, {"line": "split_ifs at hb", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\na : \u03b1\ninst\u271d : Decidable (a = \u22a5)\nb : \u03b1\nhb\u271d : b \u2208 \u22a4.parts\nh\u271d : a = \u22a5\nhb : b \u2208 ((Finpartition.empty \u03b1).copy \u22ef).parts\n\u22a2 b \u2208 {a}\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\na : \u03b1\ninst\u271d : Decidable (a = \u22a5)\nb : \u03b1\nhb\u271d : b \u2208 \u22a4.parts\nh\u271d : \u00aca = \u22a5\nhb : b \u2208 (Finpartition.indiscrete h\u271d).parts\n\u22a2 b \u2208 {a}"}, {"line": "\u00b7 simp only [copy_parts, empty_parts, not_mem_empty] at hb", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\na : \u03b1\ninst\u271d : Decidable (a = \u22a5)\nb : \u03b1\nhb\u271d : b \u2208 \u22a4.parts\nh\u271d : \u00aca = \u22a5\nhb : b \u2208 (Finpartition.indiscrete h\u271d).parts\n\u22a2 b \u2208 {a}"}, {"line": "\u00b7 exact hb", "tactic_state": "No Goals!"}]}
{"declaration": "lemma part_mem : P.part a \u2208 P.parts \u2194 a \u2208 s := by\n  by_cases ha : a \u2208 s <;> simp [part, ha, choose_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Partition/Finpartition.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 : Type*}", "[Lattice \u03b1] [OrderBot \u03b1]", "(\u03b1)", "{\u03b1} {a : \u03b1}", "(P : Finpartition a)", "{P}", "[DistribLattice \u03b1] [OrderBot \u03b1]", "[DecidableEq \u03b1] {a b c : \u03b1}", "[DecidableEq \u03b1] {a b c : \u03b1}", "{P : Finpartition a} {Q : \u2200 i \u2208 P.parts, Finpartition i}", "[GeneralizedBooleanAlgebra \u03b1] [DecidableEq \u03b1] {a b c : \u03b1} (P : Finpartition a)", "[DecidableEq \u03b1] {s t u : Finset \u03b1} (P : Finpartition s) {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2078 : Lattice \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : DistribLattice \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nP : Finpartition s\na : \u03b1\n\u22a2 P.part a \u2208 P.parts \u2194 a \u2208 s"}, {"line": "by_cases ha : a \u2208 s <;> simp [part, ha, choose_mem]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma part_nonempty : (P.part a).Nonempty \u2194 a \u2208 s := by\n  simpa only [nonempty_iff_ne_empty] using P.part_eq_empty.not_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Partition/Finpartition.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 : Type*}", "[Lattice \u03b1] [OrderBot \u03b1]", "(\u03b1)", "{\u03b1} {a : \u03b1}", "(P : Finpartition a)", "{P}", "[DistribLattice \u03b1] [OrderBot \u03b1]", "[DecidableEq \u03b1] {a b c : \u03b1}", "[DecidableEq \u03b1] {a b c : \u03b1}", "{P : Finpartition a} {Q : \u2200 i \u2208 P.parts, Finpartition i}", "[GeneralizedBooleanAlgebra \u03b1] [DecidableEq \u03b1] {a b c : \u03b1} (P : Finpartition a)", "[DecidableEq \u03b1] {s t u : Finset \u03b1} (P : Finpartition s) {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2078 : Lattice \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : DistribLattice \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nP : Finpartition s\na : \u03b1\n\u22a2 (P.part a).Nonempty \u2194 a \u2208 s"}, {"line": "simpa only [nonempty_iff_ne_empty] using P.part_eq_empty.not_left", "tactic_state": "No Goals!"}]}
{"declaration": "lemma part_subset (a : \u03b1) : P.part a \u2286 s := by\n  by_cases ha : a \u2208 s\n  \u00b7 exact P.le <| P.part_mem.2 ha\n  \u00b7 simp [P.part_eq_empty.2 ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Partition/Finpartition.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 : Type*}", "[Lattice \u03b1] [OrderBot \u03b1]", "(\u03b1)", "{\u03b1} {a : \u03b1}", "(P : Finpartition a)", "{P}", "[DistribLattice \u03b1] [OrderBot \u03b1]", "[DecidableEq \u03b1] {a b c : \u03b1}", "[DecidableEq \u03b1] {a b c : \u03b1}", "{P : Finpartition a} {Q : \u2200 i \u2208 P.parts, Finpartition i}", "[GeneralizedBooleanAlgebra \u03b1] [DecidableEq \u03b1] {a b c : \u03b1} (P : Finpartition a)", "[DecidableEq \u03b1] {s t u : Finset \u03b1} (P : Finpartition s) {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2078 : Lattice \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : DistribLattice \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nP : Finpartition s\na : \u03b1\n\u22a2 P.part a \u2286 s"}, {"line": "by_cases ha : a \u2208 s", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d\u2078 : Lattice \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : DistribLattice \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nP : Finpartition s\na : \u03b1\nha : a \u2208 s\n\u22a2 P.part a \u2286 s\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d\u2078 : Lattice \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : DistribLattice \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nP : Finpartition s\na : \u03b1\nha : a \u2209 s\n\u22a2 P.part a \u2286 s"}, {"line": "\u00b7 exact P.le <| P.part_mem.2 ha", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d\u2078 : Lattice \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : DistribLattice \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nP : Finpartition s\na : \u03b1\nha : a \u2209 s\n\u22a2 P.part a \u2286 s"}, {"line": "\u00b7 simp [P.part_eq_empty.2 ha]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_part_self : a \u2208 P.part a \u2194 a \u2208 s := by\n  by_cases ha : a \u2208 s\n  \u00b7 simp [part, ha, choose_property (p := fun s => a \u2208 s) P.parts (P.existsUnique_mem ha)]\n  \u00b7 simp [P.part_eq_empty.2, ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Partition/Finpartition.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 : Type*}", "[Lattice \u03b1] [OrderBot \u03b1]", "(\u03b1)", "{\u03b1} {a : \u03b1}", "(P : Finpartition a)", "{P}", "[DistribLattice \u03b1] [OrderBot \u03b1]", "[DecidableEq \u03b1] {a b c : \u03b1}", "[DecidableEq \u03b1] {a b c : \u03b1}", "{P : Finpartition a} {Q : \u2200 i \u2208 P.parts, Finpartition i}", "[GeneralizedBooleanAlgebra \u03b1] [DecidableEq \u03b1] {a b c : \u03b1} (P : Finpartition a)", "[DecidableEq \u03b1] {s t u : Finset \u03b1} (P : Finpartition s) {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2078 : Lattice \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : DistribLattice \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nP : Finpartition s\na : \u03b1\n\u22a2 a \u2208 P.part a \u2194 a \u2208 s"}, {"line": "by_cases ha : a \u2208 s", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d\u2078 : Lattice \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : DistribLattice \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nP : Finpartition s\na : \u03b1\nha : a \u2208 s\n\u22a2 a \u2208 P.part a \u2194 a \u2208 s\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d\u2078 : Lattice \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : DistribLattice \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nP : Finpartition s\na : \u03b1\nha : a \u2209 s\n\u22a2 a \u2208 P.part a \u2194 a \u2208 s"}, {"line": "\u00b7 simp [part, ha, choose_property (p := fun s => a \u2208 s) P.parts (P.existsUnique_mem ha)]", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d\u2078 : Lattice \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : DistribLattice \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nP : Finpartition s\na : \u03b1\nha : a \u2209 s\n\u22a2 a \u2208 P.part a \u2194 a \u2208 s"}, {"line": "\u00b7 simp [P.part_eq_empty.2, ha]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_enumeration : \u2203 f : s \u2243 \u03a3 t : P.parts, Fin #t.1,\n    \u2200 a b : s, P.part a = P.part b \u2194 (f a).1 = (f b).1 := by\n  use P.equivSigmaParts.trans ((Equiv.refl _).sigmaCongr (fun t \u21a6 t.1.equivFin))\n  simp [equivSigmaParts, Equiv.sigmaCongr, Equiv.sigmaCongrLeft]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Partition/Finpartition.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 : Type*}", "[Lattice \u03b1] [OrderBot \u03b1]", "(\u03b1)", "{\u03b1} {a : \u03b1}", "(P : Finpartition a)", "{P}", "[DistribLattice \u03b1] [OrderBot \u03b1]", "[DecidableEq \u03b1] {a b c : \u03b1}", "[DecidableEq \u03b1] {a b c : \u03b1}", "{P : Finpartition a} {Q : \u2200 i \u2208 P.parts, Finpartition i}", "[GeneralizedBooleanAlgebra \u03b1] [DecidableEq \u03b1] {a b c : \u03b1} (P : Finpartition a)", "[DecidableEq \u03b1] {s t u : Finset \u03b1} (P : Finpartition s) {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2078 : Lattice \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : DistribLattice \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nP : Finpartition s\n\u22a2 \u2203 f, \u2200 (a b : { x // x \u2208 s }), P.part \u2191a = P.part \u2191b \u2194 (f a).fst = (f b).fst"}, {"line": "use P.equivSigmaParts.trans ((Equiv.refl _).sigmaCongr (fun t \u21a6 t.1.equivFin))", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u2078 : Lattice \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : DistribLattice \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nP : Finpartition s\n\u22a2 \u2200 (a b : { x // x \u2208 s }), P.part \u2191a = P.part \u2191b \u2194 (sorry a).fst = (sorry b).fst"}, {"line": "simp [equivSigmaParts, Equiv.sigmaCongr, Equiv.sigmaCongrLeft]", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u2078 : Lattice \u03b1\ninst\u271d\u2077 : OrderBot \u03b1\ninst\u271d\u2076 : DistribLattice \u03b1\ninst\u271d\u2075 : OrderBot \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nP : Finpartition s\n\u22a2 \u2200 (a : \u03b1) (b : a \u2208 s) (a_1 : \u03b1) (b_1 : a_1 \u2208 s),\n    P.part a = P.part a_1 \u2194 ((sorry ()) \u27e8a, b\u27e9).fst = ((sorry ()) \u27e8a_1, b_1\u27e9).fst"}]}
{"declaration": "theorem isChain_univ_iff : IsChain r (univ : Set \u03b1) \u2194 IsTrichotomous \u03b1 r := by\n  refine \u27e8fun h => \u27e8fun a b => ?_\u27e9, fun h => @isChain_of_trichotomous _ _ h univ\u27e9\n  rw [or_left_comm]\n  rw [or_iff_not_imp_left]\n  exact h trivial trivial\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Preorder/Chain.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop)", "{r} {c c\u2081 c\u2082 s t : Set \u03b1} {a b x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 IsChain r univ \u2194 IsTrichotomous \u03b1 r"}, {"line": "refine \u27e8fun h => \u27e8fun a b => ?_\u27e9, fun h => @isChain_of_trichotomous _ _ h univ\u27e9", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : IsChain r univ\na b : \u03b1\n\u22a2 r a b \u2228 a = b \u2228 r b a"}, {"line": "rw [or_left_comm]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : IsChain r univ\na b : \u03b1\n\u22a2 a = b \u2228 r a b \u2228 r b a"}, {"line": "rw [or_iff_not_imp_left]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : IsChain r univ\na b : \u03b1\n\u22a2 \u00aca = b \u2192 r a b \u2228 r b a"}, {"line": "exact h trivial trivial", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isChain_union {s t : Set \u03b1} :\n    IsChain r (s \u222a t) \u2194 IsChain r s \u2227 IsChain r t \u2227 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b \u2192 r a b \u2228 r b a := by\n  rw [IsChain]\n  rw [IsChain]\n  rw [IsChain]\n  rw [pairwise_union_of_symmetric fun _ _ \u21a6 Or.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Preorder/Chain.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop)", "{r} {c c\u2081 c\u2082 s t : Set \u03b1} {a b x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\n\u22a2 IsChain r (s \u222a t) \u2194 IsChain r s \u2227 IsChain r t \u2227 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b \u2192 r a b \u2228 r b a"}, {"line": "rw [IsChain]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\n\u22a2 ((s \u222a t).Pairwise fun x y => r x y \u2228 r y x) \u2194 IsChain r s \u2227 IsChain r t \u2227 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b \u2192 r a b \u2228 r b a"}, {"line": "rw [IsChain]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\n\u22a2 ((s \u222a t).Pairwise fun x y => r x y \u2228 r y x) \u2194\n    (s.Pairwise fun x y => r x y \u2228 r y x) \u2227 IsChain r t \u2227 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b \u2192 r a b \u2228 r b a"}, {"line": "rw [IsChain]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\n\u22a2 ((s \u222a t).Pairwise fun x y => r x y \u2228 r y x) \u2194\n    (s.Pairwise fun x y => r x y \u2228 r y x) \u2227\n      (t.Pairwise fun x y => r x y \u2228 r y x) \u2227 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b \u2192 r a b \u2228 r b a"}, {"line": "rw [pairwise_union_of_symmetric fun _ _ \u21a6 Or.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Monotone.isChain_range [LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) :\n    IsChain (\u00b7 \u2264 \u00b7) (range f) := by\n  rw [\u2190 image_univ]\n  exact hf.isChain_image (isChain_of_trichotomous _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Preorder/Chain.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop)", "{r} {c c\u2081 c\u2082 s t : Set \u03b1} {a b x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Monotone f\n\u22a2 IsChain (fun x1 x2 => x1 \u2264 x2) (range f)"}, {"line": "rw [\u2190 image_univ]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Monotone f\n\u22a2 IsChain (fun x1 x2 => x1 \u2264 x2) (f '' univ)"}, {"line": "exact hf.isChain_image (isChain_of_trichotomous _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsChain.exists3 (hchain : IsChain r s) [IsTrans \u03b1 r] {a b c} (mem1 : a \u2208 s) (mem2 : b \u2208 s)\n    (mem3 : c \u2208 s) : \u2203 (z : _) (_ : z \u2208 s), r a z \u2227 r b z \u2227 r c z := by\n  rcases directedOn_iff_directed.mpr (IsChain.directed hchain) a mem1 b mem2 with \u27e8z, mem4, H1, H2\u27e9\n  rcases directedOn_iff_directed.mpr (IsChain.directed hchain) z mem4 c mem3 with\n    \u27e8z', mem5, H3, H4\u27e9\n  exact \u27e8z', mem5, _root_.trans H1 H3, _root_.trans H2 H3, H4\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Order/Preorder/Chain.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop)", "{r} {c c\u2081 c\u2082 s t : Set \u03b1} {a b x y : \u03b1}", "[IsRefl \u03b1 r]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\ninst\u271d\u00b9 : IsRefl \u03b1 r\nhchain : IsChain r s\ninst\u271d : IsTrans \u03b1 r\na b c : \u03b1\nmem1 : a \u2208 s\nmem2 : b \u2208 s\nmem3 : c \u2208 s\n\u22a2 \u2203 z, \u2203 (_ : z \u2208 s), r a z \u2227 r b z \u2227 r c z"}, {"line": "rcases directedOn_iff_directed.mpr (IsChain.directed hchain) a mem1 b mem2 with \u27e8z, mem4, H1, H2\u27e9", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\ninst\u271d\u00b9 : IsRefl \u03b1 r\nhchain : IsChain r s\ninst\u271d : IsTrans \u03b1 r\na b c : \u03b1\nmem1 : a \u2208 s\nmem2 : b \u2208 s\nmem3 : c \u2208 s\nz : \u03b1\nmem4 : z \u2208 s\nH1 : r a z\nH2 : r b z\n\u22a2 \u2203 z, \u2203 (_ : z \u2208 s), r a z \u2227 r b z \u2227 r c z"}, {"line": "rcases directedOn_iff_directed.mpr (IsChain.directed hchain) z mem4 c mem3 with\n    \u27e8z', mem5, H3, H4\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\ninst\u271d\u00b9 : IsRefl \u03b1 r\nhchain : IsChain r s\ninst\u271d : IsTrans \u03b1 r\na b c : \u03b1\nmem1 : a \u2208 s\nmem2 : b \u2208 s\nmem3 : c \u2208 s\nz : \u03b1\nmem4 : z \u2208 s\nH1 : r a z\nH2 : r b z\nz' : \u03b1\nmem5 : z' \u2208 s\nH3 : r z z'\nH4 : r c z'\n\u22a2 \u2203 z, \u2203 (_ : z \u2208 s), r a z \u2227 r b z \u2227 r c z"}, {"line": "exact \u27e8z', mem5, _root_.trans H1 H3, _root_.trans H2 H3, H4\u27e9", "tactic_state": "No Goals!"}]}
