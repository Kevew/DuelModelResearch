{"declaration": "theorem Int.associated_iff {a b : \u2124} : Associated a b \u2194 a = b \u2228 a = -b := by\n  rw [Int.associated_iff_natAbs]\n  exact Int.natAbs_eq_natAbs_iff", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Nat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 Associated a b \u2194 a = b \u2228 a = -b"}, {"line": "rw [Int.associated_iff_natAbs]", "tactic_state": "a b : \u2124\n\u22a2 a.natAbs = b.natAbs \u2194 a = b \u2228 a = -b"}, {"line": "exact Int.natAbs_eq_natAbs_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mulLeftEmbedding_eq_mulRightEmbedding [CommMagma G] [IsCancelMul G] (g : G) :\n    mulLeftEmbedding g = mulRightEmbedding g := by\n  ext\n  exact mul_comm _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Embedding.lean", "context": {"open": [], "variables": ["{G : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : CommMagma G\ninst\u271d : IsCancelMul G\ng : G\n\u22a2 mulLeftEmbedding g = mulRightEmbedding g"}, {"line": "ext", "tactic_state": "case h\nG : Type u_1\ninst\u271d\u00b9 : CommMagma G\ninst\u271d : IsCancelMul G\ng x\u271d : G\n\u22a2 (mulLeftEmbedding g) x\u271d = (mulRightEmbedding g) x\u271d"}, {"line": "exact mul_comm _ _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Even.smul_even [SMul \u03b2 \u03b3] (hf : f.Even) (hg : g.Even) : (f \u2022 g).Even := by\n  intro a\n  simp only [Pi.smul_apply']\n  simp only [hf a]\n  simp only [hg a]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/EvenFunction.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [Neg \u03b1]", "{\u03b3 : Type*}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Neg \u03b1\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ninst\u271d : SMul \u03b2 \u03b3\nhf : Function.Even f\nhg : Function.Even g\n\u22a2 Function.Even (f \u2022 g)"}, {"line": "intro a", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Neg \u03b1\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ninst\u271d : SMul \u03b2 \u03b3\nhf : Function.Even f\nhg : Function.Even g\na : \u03b1\n\u22a2 (f \u2022 g) (-a) = (f \u2022 g) a"}, {"line": "simp only [Pi.smul_apply']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Neg \u03b1\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ninst\u271d : SMul \u03b2 \u03b3\nhf : Function.Even f\nhg : Function.Even g\na : \u03b1\n\u22a2 f (-a) \u2022 g (-a) = f a \u2022 g a"}, {"line": "simp only [hf a]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Neg \u03b1\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ninst\u271d : SMul \u03b2 \u03b3\nhf : Function.Even f\nhg : Function.Even g\na : \u03b1\n\u22a2 f a \u2022 g (-a) = f a \u2022 g a"}, {"line": "simp only [hg a]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Even.smul_odd [Monoid \u03b2] [AddGroup \u03b3] [DistribMulAction \u03b2 \u03b3] (hf : f.Even) (hg : g.Odd) :\n    (f \u2022 g).Odd := by\n  intro a\n  simp only [Pi.smul_apply']\n  simp only [hf a]\n  simp only [hg a]\n  simp only [smul_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/EvenFunction.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [Neg \u03b1]", "{\u03b3 : Type*}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Neg \u03b1\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : AddGroup \u03b3\ninst\u271d : DistribMulAction \u03b2 \u03b3\nhf : Function.Even f\nhg : Function.Odd g\n\u22a2 Function.Odd (f \u2022 g)"}, {"line": "intro a", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Neg \u03b1\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : AddGroup \u03b3\ninst\u271d : DistribMulAction \u03b2 \u03b3\nhf : Function.Even f\nhg : Function.Odd g\na : \u03b1\n\u22a2 (f \u2022 g) (-a) = -(f \u2022 g) a"}, {"line": "simp only [Pi.smul_apply']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Neg \u03b1\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : AddGroup \u03b3\ninst\u271d : DistribMulAction \u03b2 \u03b3\nhf : Function.Even f\nhg : Function.Odd g\na : \u03b1\n\u22a2 f (-a) \u2022 g (-a) = -(f a \u2022 g a)"}, {"line": "simp only [hf a]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Neg \u03b1\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : AddGroup \u03b3\ninst\u271d : DistribMulAction \u03b2 \u03b3\nhf : Function.Even f\nhg : Function.Odd g\na : \u03b1\n\u22a2 f a \u2022 g (-a) = -(f a \u2022 g a)"}, {"line": "simp only [hg a]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Neg \u03b1\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : AddGroup \u03b3\ninst\u271d : DistribMulAction \u03b2 \u03b3\nhf : Function.Even f\nhg : Function.Odd g\na : \u03b1\n\u22a2 f a \u2022 -g a = -(f a \u2022 g a)"}, {"line": "simp only [smul_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Odd.smul_even [Ring \u03b2] [AddCommGroup \u03b3] [Module \u03b2 \u03b3] (hf : f.Odd) (hg : g.Even) :\n    (f \u2022 g).Odd := by\n  intro a\n  simp only [Pi.smul_apply']\n  simp only [hf a]\n  simp only [hg a]\n  simp only [neg_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/EvenFunction.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [Neg \u03b1]", "{\u03b3 : Type*}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Neg \u03b1\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ninst\u271d\u00b2 : Ring \u03b2\ninst\u271d\u00b9 : AddCommGroup \u03b3\ninst\u271d : Module \u03b2 \u03b3\nhf : Function.Odd f\nhg : Function.Even g\n\u22a2 Function.Odd (f \u2022 g)"}, {"line": "intro a", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Neg \u03b1\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ninst\u271d\u00b2 : Ring \u03b2\ninst\u271d\u00b9 : AddCommGroup \u03b3\ninst\u271d : Module \u03b2 \u03b3\nhf : Function.Odd f\nhg : Function.Even g\na : \u03b1\n\u22a2 (f \u2022 g) (-a) = -(f \u2022 g) a"}, {"line": "simp only [Pi.smul_apply']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Neg \u03b1\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ninst\u271d\u00b2 : Ring \u03b2\ninst\u271d\u00b9 : AddCommGroup \u03b3\ninst\u271d : Module \u03b2 \u03b3\nhf : Function.Odd f\nhg : Function.Even g\na : \u03b1\n\u22a2 f (-a) \u2022 g (-a) = -(f a \u2022 g a)"}, {"line": "simp only [hf a]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Neg \u03b1\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ninst\u271d\u00b2 : Ring \u03b2\ninst\u271d\u00b9 : AddCommGroup \u03b3\ninst\u271d : Module \u03b2 \u03b3\nhf : Function.Odd f\nhg : Function.Even g\na : \u03b1\n\u22a2 -f a \u2022 g (-a) = -(f a \u2022 g a)"}, {"line": "simp only [hg a]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Neg \u03b1\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ninst\u271d\u00b2 : Ring \u03b2\ninst\u271d\u00b9 : AddCommGroup \u03b3\ninst\u271d : Module \u03b2 \u03b3\nhf : Function.Odd f\nhg : Function.Even g\na : \u03b1\n\u22a2 -f a \u2022 g a = -(f a \u2022 g a)"}, {"line": "simp only [neg_smul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Even.const_smul [SMul \u03b2 \u03b3] (hg : g.Even) (r : \u03b2) : (r \u2022 g).Even := by\n  intro a\n  simp only [Pi.smul_apply]\n  simp only [hg a]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/EvenFunction.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [Neg \u03b1]", "{\u03b3 : Type*}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Neg \u03b1\n\u03b3 : Type u_4\ng : \u03b1 \u2192 \u03b3\ninst\u271d : SMul \u03b2 \u03b3\nhg : Function.Even g\nr : \u03b2\n\u22a2 Function.Even (r \u2022 g)"}, {"line": "intro a", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Neg \u03b1\n\u03b3 : Type u_4\ng : \u03b1 \u2192 \u03b3\ninst\u271d : SMul \u03b2 \u03b3\nhg : Function.Even g\nr : \u03b2\na : \u03b1\n\u22a2 (r \u2022 g) (-a) = (r \u2022 g) a"}, {"line": "simp only [Pi.smul_apply]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Neg \u03b1\n\u03b3 : Type u_4\ng : \u03b1 \u2192 \u03b3\ninst\u271d : SMul \u03b2 \u03b3\nhg : Function.Even g\nr : \u03b2\na : \u03b1\n\u22a2 r \u2022 g (-a) = r \u2022 g a"}, {"line": "simp only [hg a]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Odd.const_smul [Monoid \u03b2] [AddGroup \u03b3] [DistribMulAction \u03b2 \u03b3] (hg : g.Odd) (r : \u03b2) :\n    (r \u2022 g).Odd := by\n  intro a\n  simp only [Pi.smul_apply]\n  simp only [hg a]\n  simp only [smul_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/EvenFunction.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [Neg \u03b1]", "{\u03b3 : Type*}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Neg \u03b1\n\u03b3 : Type u_4\ng : \u03b1 \u2192 \u03b3\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : AddGroup \u03b3\ninst\u271d : DistribMulAction \u03b2 \u03b3\nhg : Function.Odd g\nr : \u03b2\n\u22a2 Function.Odd (r \u2022 g)"}, {"line": "intro a", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Neg \u03b1\n\u03b3 : Type u_4\ng : \u03b1 \u2192 \u03b3\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : AddGroup \u03b3\ninst\u271d : DistribMulAction \u03b2 \u03b3\nhg : Function.Odd g\nr : \u03b2\na : \u03b1\n\u22a2 (r \u2022 g) (-a) = -(r \u2022 g) a"}, {"line": "simp only [Pi.smul_apply]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Neg \u03b1\n\u03b3 : Type u_4\ng : \u03b1 \u2192 \u03b3\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : AddGroup \u03b3\ninst\u271d : DistribMulAction \u03b2 \u03b3\nhg : Function.Odd g\nr : \u03b2\na : \u03b1\n\u22a2 r \u2022 g (-a) = -(r \u2022 g a)"}, {"line": "simp only [hg a]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Neg \u03b1\n\u03b3 : Type u_4\ng : \u03b1 \u2192 \u03b3\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : AddGroup \u03b3\ninst\u271d : DistribMulAction \u03b2 \u03b3\nhg : Function.Odd g\nr : \u03b2\na : \u03b1\n\u22a2 r \u2022 -g a = -(r \u2022 g a)"}, {"line": "simp only [smul_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Even.mul_even (hf : f.Even) (hg : g.Even) : (f * g).Even := by\n  intro a\n  simp only [Pi.mul_apply]\n  simp only [hf a]\n  simp only [hg a]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/EvenFunction.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [Neg \u03b1]", "{\u03b3 : Type*}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3}", "{R : Type*} [Mul R] {f g : \u03b1 \u2192 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Neg \u03b1\nR : Type u_5\ninst\u271d : Mul R\nf g : \u03b1 \u2192 R\nhf : Function.Even f\nhg : Function.Even g\n\u22a2 Function.Even (f * g)"}, {"line": "intro a", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Neg \u03b1\nR : Type u_5\ninst\u271d : Mul R\nf g : \u03b1 \u2192 R\nhf : Function.Even f\nhg : Function.Even g\na : \u03b1\n\u22a2 (f * g) (-a) = (f * g) a"}, {"line": "simp only [Pi.mul_apply]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Neg \u03b1\nR : Type u_5\ninst\u271d : Mul R\nf g : \u03b1 \u2192 R\nhf : Function.Even f\nhg : Function.Even g\na : \u03b1\n\u22a2 f (-a) * g (-a) = f a * g a"}, {"line": "simp only [hf a]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Neg \u03b1\nR : Type u_5\ninst\u271d : Mul R\nf g : \u03b1 \u2192 R\nhf : Function.Even f\nhg : Function.Even g\na : \u03b1\n\u22a2 f a * g (-a) = f a * g a"}, {"line": "simp only [hg a]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Even.mul_odd [HasDistribNeg R] (hf : f.Even) (hg : g.Odd) : (f * g).Odd := by\n  intro a\n  simp only [Pi.mul_apply]\n  simp only [hf a]\n  simp only [hg a]\n  simp only [mul_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/EvenFunction.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [Neg \u03b1]", "{\u03b3 : Type*}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3}", "{R : Type*} [Mul R] {f g : \u03b1 \u2192 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Neg \u03b1\nR : Type u_5\ninst\u271d\u00b9 : Mul R\nf g : \u03b1 \u2192 R\ninst\u271d : HasDistribNeg R\nhf : Function.Even f\nhg : Function.Odd g\n\u22a2 Function.Odd (f * g)"}, {"line": "intro a", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Neg \u03b1\nR : Type u_5\ninst\u271d\u00b9 : Mul R\nf g : \u03b1 \u2192 R\ninst\u271d : HasDistribNeg R\nhf : Function.Even f\nhg : Function.Odd g\na : \u03b1\n\u22a2 (f * g) (-a) = -(f * g) a"}, {"line": "simp only [Pi.mul_apply]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Neg \u03b1\nR : Type u_5\ninst\u271d\u00b9 : Mul R\nf g : \u03b1 \u2192 R\ninst\u271d : HasDistribNeg R\nhf : Function.Even f\nhg : Function.Odd g\na : \u03b1\n\u22a2 f (-a) * g (-a) = -(f a * g a)"}, {"line": "simp only [hf a]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Neg \u03b1\nR : Type u_5\ninst\u271d\u00b9 : Mul R\nf g : \u03b1 \u2192 R\ninst\u271d : HasDistribNeg R\nhf : Function.Even f\nhg : Function.Odd g\na : \u03b1\n\u22a2 f a * g (-a) = -(f a * g a)"}, {"line": "simp only [hg a]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Neg \u03b1\nR : Type u_5\ninst\u271d\u00b9 : Mul R\nf g : \u03b1 \u2192 R\ninst\u271d : HasDistribNeg R\nhf : Function.Even f\nhg : Function.Odd g\na : \u03b1\n\u22a2 f a * -g a = -(f a * g a)"}, {"line": "simp only [mul_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Odd.mul_even [HasDistribNeg R] (hf : f.Odd) (hg : g.Even) : (f * g).Odd := by\n  intro a\n  simp only [Pi.mul_apply]\n  simp only [hf a]\n  simp only [hg a]\n  simp only [neg_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/EvenFunction.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [Neg \u03b1]", "{\u03b3 : Type*}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3}", "{R : Type*} [Mul R] {f g : \u03b1 \u2192 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Neg \u03b1\nR : Type u_5\ninst\u271d\u00b9 : Mul R\nf g : \u03b1 \u2192 R\ninst\u271d : HasDistribNeg R\nhf : Function.Odd f\nhg : Function.Even g\n\u22a2 Function.Odd (f * g)"}, {"line": "intro a", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Neg \u03b1\nR : Type u_5\ninst\u271d\u00b9 : Mul R\nf g : \u03b1 \u2192 R\ninst\u271d : HasDistribNeg R\nhf : Function.Odd f\nhg : Function.Even g\na : \u03b1\n\u22a2 (f * g) (-a) = -(f * g) a"}, {"line": "simp only [Pi.mul_apply]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Neg \u03b1\nR : Type u_5\ninst\u271d\u00b9 : Mul R\nf g : \u03b1 \u2192 R\ninst\u271d : HasDistribNeg R\nhf : Function.Odd f\nhg : Function.Even g\na : \u03b1\n\u22a2 f (-a) * g (-a) = -(f a * g a)"}, {"line": "simp only [hf a]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Neg \u03b1\nR : Type u_5\ninst\u271d\u00b9 : Mul R\nf g : \u03b1 \u2192 R\ninst\u271d : HasDistribNeg R\nhf : Function.Odd f\nhg : Function.Even g\na : \u03b1\n\u22a2 -f a * g (-a) = -(f a * g a)"}, {"line": "simp only [hg a]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Neg \u03b1\nR : Type u_5\ninst\u271d\u00b9 : Mul R\nf g : \u03b1 \u2192 R\ninst\u271d : HasDistribNeg R\nhf : Function.Odd f\nhg : Function.Even g\na : \u03b1\n\u22a2 -f a * g a = -(f a * g a)"}, {"line": "simp only [neg_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Odd.mul_odd [HasDistribNeg R] (hf : f.Odd) (hg : g.Odd) : (f * g).Even := by\n  intro a\n  simp only [Pi.mul_apply]\n  simp only [hf a]\n  simp only [hg a]\n  simp only [mul_neg]\n  simp only [neg_mul]\n  simp only [neg_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/EvenFunction.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [Neg \u03b1]", "{\u03b3 : Type*}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3}", "{R : Type*} [Mul R] {f g : \u03b1 \u2192 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Neg \u03b1\nR : Type u_5\ninst\u271d\u00b9 : Mul R\nf g : \u03b1 \u2192 R\ninst\u271d : HasDistribNeg R\nhf : Function.Odd f\nhg : Function.Odd g\n\u22a2 Function.Even (f * g)"}, {"line": "intro a", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Neg \u03b1\nR : Type u_5\ninst\u271d\u00b9 : Mul R\nf g : \u03b1 \u2192 R\ninst\u271d : HasDistribNeg R\nhf : Function.Odd f\nhg : Function.Odd g\na : \u03b1\n\u22a2 (f * g) (-a) = (f * g) a"}, {"line": "simp only [Pi.mul_apply]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Neg \u03b1\nR : Type u_5\ninst\u271d\u00b9 : Mul R\nf g : \u03b1 \u2192 R\ninst\u271d : HasDistribNeg R\nhf : Function.Odd f\nhg : Function.Odd g\na : \u03b1\n\u22a2 f (-a) * g (-a) = f a * g a"}, {"line": "simp only [hf a]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Neg \u03b1\nR : Type u_5\ninst\u271d\u00b9 : Mul R\nf g : \u03b1 \u2192 R\ninst\u271d : HasDistribNeg R\nhf : Function.Odd f\nhg : Function.Odd g\na : \u03b1\n\u22a2 -f a * g (-a) = f a * g a"}, {"line": "simp only [hg a]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Neg \u03b1\nR : Type u_5\ninst\u271d\u00b9 : Mul R\nf g : \u03b1 \u2192 R\ninst\u271d : HasDistribNeg R\nhf : Function.Odd f\nhg : Function.Odd g\na : \u03b1\n\u22a2 -f a * -g a = f a * g a"}, {"line": "simp only [mul_neg]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Neg \u03b1\nR : Type u_5\ninst\u271d\u00b9 : Mul R\nf g : \u03b1 \u2192 R\ninst\u271d : HasDistribNeg R\nhf : Function.Odd f\nhg : Function.Odd g\na : \u03b1\n\u22a2 -(-f a * g a) = f a * g a"}, {"line": "simp only [neg_mul]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Neg \u03b1\nR : Type u_5\ninst\u271d\u00b9 : Mul R\nf g : \u03b1 \u2192 R\ninst\u271d : HasDistribNeg R\nhf : Function.Odd f\nhg : Function.Odd g\na : \u03b1\n\u22a2 - -(f a * g a) = f a * g a"}, {"line": "simp only [neg_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Odd.sum_eq_zero [Fintype \u03b1] [InvolutiveNeg \u03b1] {f : \u03b1 \u2192 \u03b2} (hf : f.Odd) : \u2211 a, f a = 0 := by\n  simpa only [neg_eq_self \u2115, Finset.sum_neg_distrib, funext hf, Equiv.neg_apply] using\n    Equiv.sum_comp (.neg \u03b1) f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/EvenFunction.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [Neg \u03b1]", "{\u03b3 : Type*}", "{\u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3}", "{R : Type*} [Mul R] {f g : \u03b1 \u2192 R}", "{\u03b1 \u03b2 : Type*} [AddCommGroup \u03b2] [NoZeroSMulDivisors \u2115 \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\n\u03b2 : Type u_7\ninst\u271d\u00b3 : AddCommGroup \u03b2\ninst\u271d\u00b2 : NoZeroSMulDivisors \u2115 \u03b2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : InvolutiveNeg \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Function.Odd f\n\u22a2 \u2211 a, f a = 0"}, {"line": "simpa only [neg_eq_self \u2115, Finset.sum_neg_distrib, funext hf, Equiv.neg_apply] using\n    Equiv.sum_comp (.neg \u03b1) f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma shift\u2097_apply (f : M \u2192 G) (y : M) : shift\u2097 M G h f y = f (y + h) := by simp [shift\u2097, fwdDiff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/ForwardDiff.lean", "context": {"open": ["Finset Nat Function", "fwdDiff"], "variables": ["{M G : Type*} [AddCommMonoid M] [AddCommGroup G] (h : M)", "(M G) in", "(M G) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : AddCommGroup G\nh : M\nx\u271d : Sort u_3\nshift\u2097 : x\u271d\nf : M \u2192 G\ny : M\n\u22a2 sorry = f (y + h)"}, {"line": "simp [shift\u2097, fwdDiff]", "tactic_state": "M : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : AddCommGroup G\nh : M\nx\u271d : Sort u_3\nshift\u2097 : x\u271d\nf : M \u2192 G\ny : M\n\u22a2 sorry () = f (y + h)"}]}
{"declaration": "lemma shift\u2097_pow_apply (f : M \u2192 G) (k : \u2115) (y : M) : (shift\u2097 M G h ^ k) f y = f (y + k \u2022 h) := by\n  induction' k with k IH generalizing f\n  \u00b7 simp\n  \u00b7 simp [pow_add, IH (shift\u2097 M G h f), shift\u2097_apply, add_assoc, add_nsmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/ForwardDiff.lean", "context": {"open": ["Finset Nat Function", "fwdDiff"], "variables": ["{M G : Type*} [AddCommMonoid M] [AddCommGroup G] (h : M)", "(M G) in", "(M G) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : AddCommGroup G\nh : M\nx\u271d : Sort u_3\nshift\u2097 : x\u271d\nf : M \u2192 G\nk : \u2115\ny : M\n\u22a2 sorry = f (y + k \u2022 h)"}, {"line": "induction' k with k IH generalizing f", "tactic_state": "case zero\nM : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : AddCommGroup G\nh : M\nx\u271d : Sort u_3\nshift\u2097 : x\u271d\ny : M\nf : M \u2192 G\n\u22a2 sorry = f (y + 0 \u2022 h)\n---\ncase succ\nM : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : AddCommGroup G\nh : M\nx\u271d : Sort u_3\nshift\u2097 : x\u271d\ny : M\nk : \u2115\nIH : \u2200 (f : M \u2192 G), sorry = f (y + k \u2022 h)\nf : M \u2192 G\n\u22a2 sorry = f (y + (k + 1) \u2022 h)"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nM : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : AddCommGroup G\nh : M\nx\u271d : Sort u_3\nshift\u2097 : x\u271d\ny : M\nk : \u2115\nIH : \u2200 (f : M \u2192 G), sorry = f (y + k \u2022 h)\nf : M \u2192 G\n\u22a2 sorry = f (y + (k + 1) \u2022 h)"}, {"line": "\u00b7 simp [pow_add, IH (shift\u2097 M G h f), shift\u2097_apply, add_assoc, add_nsmul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma fwdDiff_choose (j : \u2115) : \u0394_[1] (fun x \u21a6 x.choose (j + 1) : \u2115 \u2192 \u2124) = fun x \u21a6 x.choose j := by\n  ext n\n  simp only [fwdDiff]\n  simp only [choose_succ_succ' n j]\n  simp only [cast_add]\n  simp only [add_sub_cancel_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/ForwardDiff.lean", "context": {"open": ["Finset Nat Function", "fwdDiff", "fwdDiff_aux"], "variables": ["{M G : Type*} [AddCommMonoid M] [AddCommGroup G] (h : M)", "(M G) in", "(M G) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "j : \u2115\n\u22a2 (fwdDiff 1 fun x => \u2191(x.choose (j + 1))) = fun x => \u2191(x.choose j)"}, {"line": "ext n", "tactic_state": "case h\nj n : \u2115\n\u22a2 fwdDiff 1 (fun x => \u2191(x.choose (j + 1))) n = \u2191(n.choose j)"}, {"line": "simp only [fwdDiff]", "tactic_state": "case h\nj n : \u2115\n\u22a2 \u2191((n + 1).choose (j + 1)) - \u2191(n.choose (j + 1)) = \u2191(n.choose j)"}, {"line": "simp only [choose_succ_succ' n j]", "tactic_state": "case h\nj n : \u2115\n\u22a2 \u2191(n.choose j + n.choose (j + 1)) - \u2191(n.choose (j + 1)) = \u2191(n.choose j)"}, {"line": "simp only [cast_add]", "tactic_state": "case h\nj n : \u2115\n\u22a2 \u2191(n.choose j) + \u2191(n.choose (j + 1)) - \u2191(n.choose (j + 1)) = \u2191(n.choose j)"}, {"line": "simp only [add_sub_cancel_right]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mgraph_eq_mrange_prod (f : G \u2192* H) : f.mgraph = mrange ((id _).prod f) := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Graph.lean", "context": {"open": ["Function Set"], "variables": ["{G H I : Type*}", "[Monoid G] [Monoid H] [Monoid I]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\nH : Type u_2\ninst\u271d\u00b9 : Monoid G\ninst\u271d : Monoid H\nx\u271d : Sort u_4\nmrange : x\u271d\nf : G \u2192* H\n\u22a2 f.mgraph = sorry"}, {"line": "aesop", "tactic_state": "G : Type u_1\nH : Type u_2\ninst : Monoid G\ninst_1 : Monoid H\nx : Sort u_4\nmrange : x\nf : G \u2192* H\n\u22a2 f.mgraph = sorry ()"}]}
{"declaration": "theorem npow_mul' (x : M) (m n : \u2115) : x ^ (m * n) = (x ^ n) ^ m := by\n  rw [mul_comm]\n  exact npow_mul x n m\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/NatPowAssoc.lean", "context": {"open": [], "variables": ["{M : Type*}", "[MulOneClass M] [Pow M \u2115] [NatPowAssoc M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u00b2 : MulOneClass M\ninst\u271d\u00b9 : Pow M \u2115\ninst\u271d : NatPowAssoc M\nx : M\nm n : \u2115\n\u22a2 x ^ (m * n) = (x ^ n) ^ m"}, {"line": "rw [mul_comm]", "tactic_state": "M : Type u_1\ninst\u271d\u00b2 : MulOneClass M\ninst\u271d\u00b9 : Pow M \u2115\ninst\u271d : NatPowAssoc M\nx : M\nm n : \u2115\n\u22a2 x ^ (n * m) = (x ^ n) ^ m"}, {"line": "exact npow_mul x n m", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ppow_mul' (x : M) (m n : \u2115+) : x ^ (m * n) = (x ^ n) ^ m := by\n  rw [mul_comm]\n  exact ppow_mul x n m\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/PNatPowAssoc.lean", "context": {"open": [], "variables": ["{M : Type*}", "[Mul M] [Pow M \u2115+] [PNatPowAssoc M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u00b2 : Mul M\ninst\u271d\u00b9 : Pow M \u2115+\ninst\u271d : PNatPowAssoc M\nx : M\nm n : \u2115+\n\u22a2 x ^ (m * n) = (x ^ n) ^ m"}, {"line": "rw [mul_comm]", "tactic_state": "M : Type u_1\ninst\u271d\u00b2 : Mul M\ninst\u271d\u00b9 : Pow M \u2115+\ninst\u271d : PNatPowAssoc M\nx : M\nm n : \u2115+\n\u22a2 x ^ (n * m) = (x ^ n) ^ m"}, {"line": "exact ppow_mul x n m", "tactic_state": "No Goals!"}]}
{"declaration": "lemma translate_add' (a b : G) (f : G \u2192 \u03b1) : \u03c4 (a + b) f = \u03c4 b (\u03c4 a f) := by\n  rw [add_comm]\n  rw [translate_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Translate.lean", "context": {"open": ["Function Set", "scoped Pointwise", "scoped translate"], "variables": ["{\u03b9 \u03b1 \u03b2 M G H : Type*} [AddCommGroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nG : Type u_5\ninst\u271d : AddCommGroup G\na b : G\nf : G \u2192 \u03b1\n\u22a2 translate (a + b) f = translate b (translate a f)"}, {"line": "rw [add_comm]", "tactic_state": "\u03b1 : Type u_2\nG : Type u_5\ninst\u271d : AddCommGroup G\na b : G\nf : G \u2192 \u03b1\n\u22a2 translate (b + a) f = translate b (translate a f)"}, {"line": "rw [translate_add]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma translate_comm (a b : G) (f : G \u2192 \u03b1) : \u03c4 a (\u03c4 b f) = \u03c4 b (\u03c4 a f) := by\n  rw [\u2190 translate_add]\n  rw [translate_add']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Translate.lean", "context": {"open": ["Function Set", "scoped Pointwise", "scoped translate"], "variables": ["{\u03b9 \u03b1 \u03b2 M G H : Type*} [AddCommGroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nG : Type u_5\ninst\u271d : AddCommGroup G\na b : G\nf : G \u2192 \u03b1\n\u22a2 translate a (translate b f) = translate b (translate a f)"}, {"line": "rw [\u2190 translate_add]", "tactic_state": "\u03b1 : Type u_2\nG : Type u_5\ninst\u271d : AddCommGroup G\na b : G\nf : G \u2192 \u03b1\n\u22a2 translate (a + b) f = translate b (translate a f)"}, {"line": "rw [translate_add']", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_prod (s : Finset \u03b9) (\u03c8 : \u03b9 \u2192 AddChar A M) : \u220f i \u2208 s, \u03c8 i = \u220f i \u2208 s, \u21d1(\u03c8 i) := by\n  induction s using Finset.cons_induction <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/AddChar.lean", "context": {"open": ["Function Multiplicative", "Finset hiding card", "Fintype (card)"], "variables": ["(A : Type*) [AddMonoid A]", "(M : Type*) [Monoid M]", "{A B M N : Type*} [AddMonoid A] [AddMonoid B] [Monoid M] [Monoid N] {\u03c8 : AddChar A M}", "{\u03b9 A M : Type*} [AddMonoid A] [CommMonoid M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\nA : Type u_8\nM : Type u_9\ninst\u271d\u00b9 : AddMonoid A\ninst\u271d : CommMonoid M\ns : Finset \u03b9\n\u03c8 : \u03b9 \u2192 AddChar A M\n\u22a2 \u21d1(\u220f i \u2208 s, \u03c8 i) = \u220f i \u2208 s, \u21d1(\u03c8 i)"}, {"line": "induction s using Finset.cons_induction <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_sum (s : Finset \u03b9) (\u03c8 : \u03b9 \u2192 AddChar A M) : \u2211 i \u2208 s, \u03c8 i = \u220f i \u2208 s, \u21d1(\u03c8 i) := by\n  induction s using Finset.cons_induction <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/AddChar.lean", "context": {"open": ["Function Multiplicative", "Finset hiding card", "Fintype (card)"], "variables": ["(A : Type*) [AddMonoid A]", "(M : Type*) [Monoid M]", "{A B M N : Type*} [AddMonoid A] [AddMonoid B] [Monoid M] [Monoid N] {\u03c8 : AddChar A M}", "{\u03b9 A M : Type*} [AddMonoid A] [CommMonoid M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\nA : Type u_8\nM : Type u_9\ninst\u271d\u00b9 : AddMonoid A\ninst\u271d : CommMonoid M\ns : Finset \u03b9\n\u03c8 : \u03b9 \u2192 AddChar A M\n\u22a2 \u21d1(\u2211 i \u2208 s, \u03c8 i) = \u220f i \u2208 s, \u21d1(\u03c8 i)"}, {"line": "induction s using Finset.cons_induction <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_dite (p : Prop) [Decidable p] (a : \u03b1) (b : p \u2192 \u03b2) (c : \u00ac p \u2192 \u03b2) :\n    a ^ (if h : p then b h else c h) = if h : p then a ^ b h else a ^ c h := by split_ifs <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Pow \u03b1 \u03b2\np : Prop\ninst\u271d : Decidable p\na : \u03b1\nb : p \u2192 \u03b2\nc : \u00acp \u2192 \u03b2\n\u22a2 (a ^ if h : p then b h else c h) = if h : p then a ^ b h else a ^ c h"}, {"line": "split_ifs <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dite_pow (p : Prop) [Decidable p] (a : p \u2192 \u03b1) (b : \u00ac p \u2192 \u03b1) (c : \u03b2) :\n    (if h : p then a h else b h) ^ c = if h : p then a h ^ c else b h ^ c := by split_ifs <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Pow \u03b1 \u03b2\np : Prop\ninst\u271d : Decidable p\na : p \u2192 \u03b1\nb : \u00acp \u2192 \u03b1\nc : \u03b2\n\u22a2 (if h : p then a h else b h) ^ c = if h : p then a h ^ c else b h ^ c"}, {"line": "split_ifs <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_mul_left (x y : \u03b1) : (x * \u00b7) \u2218 (y * \u00b7) = (x * y * \u00b7) := by\n  ext z\n  simp [mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Semigroup \u03b1\nx y : \u03b1\n\u22a2 ((fun x_1 => x * x_1) \u2218 fun x => y * x) = fun x_1 => x * y * x_1"}, {"line": "ext z", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : Semigroup \u03b1\nx y z : \u03b1\n\u22a2 ((fun x_1 => x * x_1) \u2218 fun x => y * x) z = x * y * z"}, {"line": "simp [mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_mul_right (x y : \u03b1) : (\u00b7 * x) \u2218 (\u00b7 * y) = (\u00b7 * (y * x)) := by\n  ext z\n  simp [mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Semigroup \u03b1\nx y : \u03b1\n\u22a2 ((fun x_1 => x_1 * x) \u2218 fun x => x * y) = fun x_1 => x_1 * (y * x)"}, {"line": "ext z", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : Semigroup \u03b1\nx y z : \u03b1\n\u22a2 ((fun x_1 => x_1 * x) \u2218 fun x => x * y) z = z * (y * x)"}, {"line": "simp [mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ite_mul_one {P : Prop} [Decidable P] {a b : M} :\n    ite P (a * b) 1 = ite P a 1 * ite P b 1 := by\n  by_cases h : P <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_4\ninst\u271d\u00b9 : MulOneClass M\nP : Prop\ninst\u271d : Decidable P\na b : M\n\u22a2 (if P then a * b else 1) = (if P then a else 1) * if P then b else 1"}, {"line": "by_cases h : P <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ite_one_mul {P : Prop} [Decidable P] {a b : M} :\n    ite P 1 (a * b) = ite P 1 a * ite P 1 b := by\n  by_cases h : P <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_4\ninst\u271d\u00b9 : MulOneClass M\nP : Prop\ninst\u271d : Decidable P\na b : M\n\u22a2 (if P then 1 else a * b) = (if P then 1 else a) * if P then 1 else b"}, {"line": "by_cases h : P <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_one_iff_eq_one_of_mul_eq_one {a b : M} (h : a * b = 1) : a = 1 \u2194 b = 1 := by\n  constructor <;> (rintro rfl; simpa using h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_4\ninst\u271d : MulOneClass M\na b : M\nh : a * b = 1\n\u22a2 a = 1 \u2194 b = 1"}, {"line": "constructor <;> (rintro rfl; simpa using h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_mul_mul_comm (a b c d : G) : a * b * (c * d) = a * c * (b * d) := by\n  simp only [mul_left_comm]\n  simp only [mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d : CommSemigroup G\na b c d : G\n\u22a2 a * b * (c * d) = a * c * (b * d)"}, {"line": "simp only [mul_left_comm]", "tactic_state": "G : Type u_3\ninst\u271d : CommSemigroup G\na b c d : G\n\u22a2 c * (a * b * d) = b * (a * c * d)"}, {"line": "simp only [mul_assoc]", "tactic_state": "G : Type u_3\ninst\u271d : CommSemigroup G\na b c d : G\n\u22a2 c * (a * (b * d)) = b * (a * (c * d))"}]}
{"declaration": "lemma pow_boole (P : Prop) [Decidable P] (a : M) :\n    (a ^ if P then 1 else 0) = if P then a else 1 := by simp only [pow_ite, pow_one, pow_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_4\ninst\u271d\u00b2 : MulOneClass M\ninst\u271d\u00b9 : Monoid M\nP : Prop\ninst\u271d : Decidable P\na : M\n\u22a2 (a ^ if P then 1 else 0) = if P then a else 1"}, {"line": "simp only [pow_ite, pow_one, pow_zero]", "tactic_state": "M : Type u_4\ninst\u271d\u00b2 : MulOneClass M\ninst\u271d\u00b9 : Monoid M\nP : Prop\ninst\u271d : Decidable P\na : M\n\u22a2 (if P then a else 1) = if P then a else 1"}]}
{"declaration": "theorem mul_one_div (x y : G) : x * (1 / y) = x / y := by\n  rw [div_eq_mul_inv]\n  rw [one_mul]\n  rw [div_eq_mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u00b2 : CommSemigroup G\ninst\u271d\u00b9 : InvolutiveInv G\ninst\u271d : DivInvMonoid G\nx y : G\n\u22a2 x * (1 / y) = x / y"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "G : Type u_3\ninst\u271d\u00b2 : CommSemigroup G\ninst\u271d\u00b9 : InvolutiveInv G\ninst\u271d : DivInvMonoid G\nx y : G\n\u22a2 x * (1 * y\u207b\u00b9) = x / y"}, {"line": "rw [one_mul]", "tactic_state": "G : Type u_3\ninst\u271d\u00b2 : CommSemigroup G\ninst\u271d\u00b9 : InvolutiveInv G\ninst\u271d : DivInvMonoid G\nx y : G\n\u22a2 x * y\u207b\u00b9 = x / y"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_div (a b c : G) : a * (b / c) = a * b / c := by simp only [mul_assoc, div_eq_mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u00b2 : CommSemigroup G\ninst\u271d\u00b9 : InvolutiveInv G\ninst\u271d : DivInvMonoid G\na b c : G\n\u22a2 a * (b / c) = a * b / c"}, {"line": "simp only [mul_assoc, div_eq_mul_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_eq_mul_one_div (a b : G) : a / b = a * (1 / b) := by rw [div_eq_mul_inv, one_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u00b2 : CommSemigroup G\ninst\u271d\u00b9 : InvolutiveInv G\ninst\u271d : DivInvMonoid G\na b : G\n\u22a2 a / b = a * (1 / b)"}, {"line": "rw [div_eq_mul_inv, one_div]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_one (a : G) : a / 1 = a := by simp [div_eq_mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u00b3 : CommSemigroup G\ninst\u271d\u00b2 : InvolutiveInv G\ninst\u271d\u00b9 : DivInvMonoid G\ninst\u271d : DivInvOneMonoid G\na : G\n\u22a2 a / 1 = a"}, {"line": "simp [div_eq_mul_inv]", "tactic_state": "G : Type u_3\ninst\u271d\u00b3 : CommSemigroup G\ninst\u271d\u00b2 : InvolutiveInv G\ninst\u271d\u00b9 : DivInvMonoid G\ninst\u271d : DivInvOneMonoid G\na : G\n\u22a2 a * 1\u207b\u00b9 = a"}]}
{"declaration": "lemma eq_of_inv_mul_eq_one (h : a\u207b\u00b9 * b = 1) : a = b := by simpa using eq_inv_of_mul_eq_one_left h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na b : \u03b1\nh : a\u207b\u00b9 * b = 1\n\u22a2 a = b"}, {"line": "simpa using eq_inv_of_mul_eq_one_left h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_of_mul_inv_eq_one (h : a * b\u207b\u00b9 = 1) : a = b := by simpa using eq_inv_of_mul_eq_one_left h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na b : \u03b1\nh : a * b\u207b\u00b9 = 1\n\u22a2 a = b"}, {"line": "simpa using eq_inv_of_mul_eq_one_left h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_div_mul_one_div_rev : 1 / a * (1 / b) = 1 / (b * a) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na b : \u03b1\n\u22a2 1 / a * (1 / b) = 1 / (b * a)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_div_left : a\u207b\u00b9 / b = (b * a)\u207b\u00b9 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na b : \u03b1\n\u22a2 a\u207b\u00b9 / b = (b * a)\u207b\u00b9"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na b : \u03b1\n\u22a2 a\u207b\u00b9 / b = a\u207b\u00b9 * b\u207b\u00b9"}]}
{"declaration": "theorem inv_div : (a / b)\u207b\u00b9 = b / a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na b : \u03b1\n\u22a2 (a / b)\u207b\u00b9 = b / a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_div_div : 1 / (a / b) = b / a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na b : \u03b1\n\u22a2 1 / (a / b) = b / a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_div_one_div : 1 / (1 / a) = a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na : \u03b1\n\u22a2 1 / (1 / a) = a"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na : \u03b1\n\u22a2 1 * a = a"}]}
{"declaration": "lemma mul_zpow_neg_one (a b : \u03b1) : (a * b) ^ (-1 : \u2124) = b ^ (-1 : \u2124) * a ^ (-1 : \u2124) := by\n  simp only [zpow_neg]\n  simp only [zpow_one]\n  simp only [mul_inv_rev]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na b : \u03b1\n\u22a2 (a * b) ^ (-1) = b ^ (-1) * a ^ (-1)"}, {"line": "simp only [zpow_neg]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na b : \u03b1\n\u22a2 ((a * b) ^ 1)\u207b\u00b9 = (b ^ 1)\u207b\u00b9 * (a ^ 1)\u207b\u00b9"}, {"line": "simp only [zpow_one]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na b : \u03b1\n\u22a2 (a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9"}, {"line": "simp only [mul_inv_rev]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_zpow' (a : \u03b1) (n : \u2124) : a\u207b\u00b9 ^ n = a ^ (-n) := by rw [inv_zpow, zpow_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na : \u03b1\nn : \u2124\n\u22a2 a\u207b\u00b9 ^ n = a ^ (-n)"}, {"line": "rw [inv_zpow, zpow_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_div_pow (a : \u03b1) (n : \u2115) : (1 / a) ^ n = 1 / a ^ n := by simp only [one_div, inv_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na : \u03b1\nn : \u2115\n\u22a2 (1 / a) ^ n = 1 / a ^ n"}, {"line": "simp only [one_div, inv_pow]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_div_zpow (a : \u03b1) (n : \u2124) : (1 / a) ^ n = 1 / a ^ n := by simp only [one_div, inv_zpow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na : \u03b1\nn : \u2124\n\u22a2 (1 / a) ^ n = 1 / a ^ n"}, {"line": "simp only [one_div, inv_zpow]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zpow_mul' (a : \u03b1) (m n : \u2124) : a ^ (m * n) = (a ^ n) ^ m := by rw [Int.mul_comm, zpow_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na : \u03b1\nm n : \u2124\n\u22a2 a ^ (m * n) = (a ^ n) ^ m"}, {"line": "rw [Int.mul_comm, zpow_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zpow_comm (a : \u03b1) (m n : \u2124) : (a ^ m) ^ n = (a ^ n) ^ m := by rw [\u2190 zpow_mul, zpow_mul']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na : \u03b1\nm n : \u2124\n\u22a2 (a ^ m) ^ n = (a ^ n) ^ m"}, {"line": "rw [\u2190 zpow_mul, zpow_mul']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_inv_eq_mul : a / b\u207b\u00b9 = a * b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : CancelCommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na b : \u03b1\n\u22a2 a / b\u207b\u00b9 = a * b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_inv : (a * b)\u207b\u00b9 = a\u207b\u00b9 * b\u207b\u00b9 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Semigroup \u03b1\ninst\u271d\u00b2 : CancelCommMonoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : DivisionCommMonoid \u03b1\na b : \u03b1\n\u22a2 (a * b)\u207b\u00b9 = a\u207b\u00b9 * b\u207b\u00b9"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Semigroup \u03b1\ninst\u271d\u00b2 : CancelCommMonoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : DivisionCommMonoid \u03b1\na b : \u03b1\n\u22a2 b\u207b\u00b9 * a\u207b\u00b9 = a\u207b\u00b9 * b\u207b\u00b9"}]}
{"declaration": "theorem inv_div' : (a / b)\u207b\u00b9 = a\u207b\u00b9 / b\u207b\u00b9 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Semigroup \u03b1\ninst\u271d\u00b2 : CancelCommMonoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : DivisionCommMonoid \u03b1\na b : \u03b1\n\u22a2 (a / b)\u207b\u00b9 = a\u207b\u00b9 / b\u207b\u00b9"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Semigroup \u03b1\ninst\u271d\u00b2 : CancelCommMonoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : DivisionCommMonoid \u03b1\na b : \u03b1\n\u22a2 b / a = a\u207b\u00b9 * b"}]}
{"declaration": "theorem inv_mul' : (a * b)\u207b\u00b9 = a\u207b\u00b9 / b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Semigroup \u03b1\ninst\u271d\u00b2 : CancelCommMonoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : DivisionCommMonoid \u03b1\na b : \u03b1\n\u22a2 (a * b)\u207b\u00b9 = a\u207b\u00b9 / b"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Semigroup \u03b1\ninst\u271d\u00b2 : CancelCommMonoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : DivisionCommMonoid \u03b1\na b : \u03b1\n\u22a2 b\u207b\u00b9 * a\u207b\u00b9 = a\u207b\u00b9 / b"}]}
{"declaration": "theorem inv_div_inv : a\u207b\u00b9 / b\u207b\u00b9 = b / a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Semigroup \u03b1\ninst\u271d\u00b2 : CancelCommMonoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : DivisionCommMonoid \u03b1\na b : \u03b1\n\u22a2 a\u207b\u00b9 / b\u207b\u00b9 = b / a"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Semigroup \u03b1\ninst\u271d\u00b2 : CancelCommMonoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : DivisionCommMonoid \u03b1\na b : \u03b1\n\u22a2 a\u207b\u00b9 * b = b / a"}]}
{"declaration": "theorem inv_inv_div_inv : (a\u207b\u00b9 / b\u207b\u00b9)\u207b\u00b9 = a / b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Semigroup \u03b1\ninst\u271d\u00b2 : CancelCommMonoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : DivisionCommMonoid \u03b1\na b : \u03b1\n\u22a2 (a\u207b\u00b9 / b\u207b\u00b9)\u207b\u00b9 = a / b"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Semigroup \u03b1\ninst\u271d\u00b2 : CancelCommMonoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : DivisionCommMonoid \u03b1\na b : \u03b1\n\u22a2 b\u207b\u00b9 * a\u207b\u00b9\u207b\u00b9 = a / b"}]}
{"declaration": "theorem one_div_mul_one_div : 1 / a * (1 / b) = 1 / (a * b) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Semigroup \u03b1\ninst\u271d\u00b2 : CancelCommMonoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : DivisionCommMonoid \u03b1\na b : \u03b1\n\u22a2 1 / a * (1 / b) = 1 / (a * b)"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Semigroup \u03b1\ninst\u271d\u00b2 : CancelCommMonoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : DivisionCommMonoid \u03b1\na b : \u03b1\n\u22a2 a\u207b\u00b9 * b\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9"}]}
{"declaration": "theorem one_div_mul_eq_div : 1 / a * b = b / a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Semigroup \u03b1\ninst\u271d\u00b2 : CancelCommMonoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : DivisionCommMonoid \u03b1\na b : \u03b1\n\u22a2 1 / a * b = b / a"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Semigroup \u03b1\ninst\u271d\u00b2 : CancelCommMonoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : DivisionCommMonoid \u03b1\na b : \u03b1\n\u22a2 a\u207b\u00b9 * b = b / a"}]}
{"declaration": "theorem div_mul_eq_div_mul_one_div : a / (b * c) = a / b * (1 / c) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Semigroup \u03b1\ninst\u271d\u00b2 : CancelCommMonoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : DivisionCommMonoid \u03b1\na b c : \u03b1\n\u22a2 a / (b * c) = a / b * (1 / c)"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Semigroup \u03b1\ninst\u271d\u00b2 : CancelCommMonoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : DivisionCommMonoid \u03b1\na b c : \u03b1\n\u22a2 a / (b * c) = a / b * c\u207b\u00b9"}]}
{"declaration": "theorem eq_mul_inv_of_mul_eq (h : a * c = b) : a = b * c\u207b\u00b9 := by simp [h.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : a * c = b\n\u22a2 a = b * c\u207b\u00b9"}, {"line": "simp [h.symm]", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : a * c = b\n\u22a2 a = a * c * c\u207b\u00b9"}]}
{"declaration": "theorem eq_inv_mul_of_mul_eq (h : b * a = c) : a = b\u207b\u00b9 * c := by simp [h.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : b * a = c\n\u22a2 a = b\u207b\u00b9 * c"}, {"line": "simp [h.symm]", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : b * a = c\n\u22a2 a = b\u207b\u00b9 * (b * a)"}]}
{"declaration": "theorem inv_mul_eq_of_eq_mul (h : b = a * c) : a\u207b\u00b9 * b = c := by simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : b = a * c\n\u22a2 a\u207b\u00b9 * b = c"}, {"line": "simp [h]", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : b = a * c\n\u22a2 a\u207b\u00b9 * (a * c) = c"}]}
{"declaration": "theorem mul_inv_eq_of_eq_mul (h : a = c * b) : a * b\u207b\u00b9 = c := by simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : a = c * b\n\u22a2 a * b\u207b\u00b9 = c"}, {"line": "simp [h]", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : a = c * b\n\u22a2 c * b * b\u207b\u00b9 = c"}]}
{"declaration": "theorem eq_mul_of_mul_inv_eq (h : a * c\u207b\u00b9 = b) : a = b * c := by simp [h.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : a * c\u207b\u00b9 = b\n\u22a2 a = b * c"}, {"line": "simp [h.symm]", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : a * c\u207b\u00b9 = b\n\u22a2 a = a * c\u207b\u00b9 * c"}]}
{"declaration": "theorem eq_mul_of_inv_mul_eq (h : b\u207b\u00b9 * a = c) : a = b * c := by simp [h.symm, mul_inv_cancel_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : b\u207b\u00b9 * a = c\n\u22a2 a = b * c"}, {"line": "simp [h.symm, mul_inv_cancel_left]", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : b\u207b\u00b9 * a = c\n\u22a2 a = b * (b\u207b\u00b9 * a)"}]}
{"declaration": "theorem mul_eq_of_eq_mul_inv (h : a = c * b\u207b\u00b9) : a * b = c := by simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : a = c * b\u207b\u00b9\n\u22a2 a * b = c"}, {"line": "simp [h]", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : a = c * b\u207b\u00b9\n\u22a2 c * b\u207b\u00b9 * b = c"}]}
{"declaration": "theorem eq_div_of_mul_eq' (h : a * c = b) : a = b / c := by simp [\u2190 h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : a * c = b\n\u22a2 a = b / c"}, {"line": "simp [\u2190 h]", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : a * c = b\n\u22a2 a = a * c / c"}]}
{"declaration": "theorem div_eq_of_eq_mul'' (h : a = c * b) : a / b = c := by simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : a = c * b\n\u22a2 a / b = c"}, {"line": "simp [h]", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : a = c * b\n\u22a2 c * b / b = c"}]}
{"declaration": "theorem eq_mul_of_div_eq (h : a / c = b) : a = b * c := by simp [\u2190 h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : a / c = b\n\u22a2 a = b * c"}, {"line": "simp [\u2190 h]", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : a / c = b\n\u22a2 a = a / c * c"}]}
{"declaration": "theorem mul_eq_of_eq_div (h : a = c / b) : a * b = c := by simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : a = c / b\n\u22a2 a * b = c"}, {"line": "simp [h]", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\nh : a = c / b\n\u22a2 c / b * b = c"}]}
{"declaration": "theorem div_left_inj : b / a = c / a \u2194 b = c := by\n  rw [div_eq_mul_inv]\n  rw [div_eq_mul_inv]\n  exact mul_left_inj _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\n\u22a2 b / a = c / a \u2194 b = c"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\n\u22a2 b * a\u207b\u00b9 = c / a \u2194 b = c"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na b c : G\n\u22a2 b * a\u207b\u00b9 = c * a\u207b\u00b9 \u2194 b = c"}, {"line": "exact mul_left_inj _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_natAbs_eq_one : a ^ n.natAbs = 1 \u2194 a ^ n = 1 := by cases n <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na : G\nn : \u2124\n\u22a2 a ^ n.natAbs = 1 \u2194 a ^ n = 1"}, {"line": "cases n <;> simp", "tactic_state": "case negSucc\nG : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na : G\na\u271d : \u2115\n\u22a2 a ^ (a\u271d + 1) = 1 \u2194 (a ^ (a\u271d + 1))\u207b\u00b9 = 1"}]}
{"declaration": "lemma zpow_natCast_sub_natCast (a : G) (m n : \u2115) : a ^ (m - n : \u2124) = a ^ m / a ^ n := by\n  simpa [div_eq_mul_inv] using zpow_sub a m n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na : G\nm n : \u2115\n\u22a2 a ^ (\u2191m - \u2191n) = a ^ m / a ^ n"}, {"line": "simpa [div_eq_mul_inv] using zpow_sub a m n", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zpow_natCast_sub_one (a : G) (n : \u2115) : a ^ (n - 1 : \u2124) = a ^ n / a := by\n  simpa [div_eq_mul_inv] using zpow_sub a n 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na : G\nn : \u2115\n\u22a2 a ^ (\u2191n - 1) = a ^ n / a"}, {"line": "simpa [div_eq_mul_inv] using zpow_sub a n 1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zpow_one_sub_natCast (a : G) (n : \u2115) : a ^ (1 - n : \u2124) = a / a ^ n := by\n  simpa [div_eq_mul_inv] using zpow_sub a 1 n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2074 : CommSemigroup G\ninst\u271d\u00b3 : InvolutiveInv G\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvOneMonoid G\ninst\u271d : Group G\na : G\nn : \u2115\n\u22a2 a ^ (1 - \u2191n) = a / a ^ n"}, {"line": "simpa [div_eq_mul_inv] using zpow_sub a 1 n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_div_of_mul_eq'' (h : c * a = b) : a = b / c := by simp [h.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}", "[CommGroup G] {a b c d : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2075 : CommSemigroup G\ninst\u271d\u2074 : InvolutiveInv G\ninst\u271d\u00b3 : DivInvMonoid G\ninst\u271d\u00b2 : DivInvOneMonoid G\ninst\u271d\u00b9 : Group G\ninst\u271d : CommGroup G\na b c : G\nh : c * a = b\n\u22a2 a = b / c"}, {"line": "simp [h.symm]", "tactic_state": "G : Type u_3\ninst\u271d\u2075 : CommSemigroup G\ninst\u271d\u2074 : InvolutiveInv G\ninst\u271d\u00b3 : DivInvMonoid G\ninst\u271d\u00b2 : DivInvOneMonoid G\ninst\u271d\u00b9 : Group G\ninst\u271d : CommGroup G\na b c : G\nh : c * a = b\n\u22a2 a = c * a / c"}]}
{"declaration": "theorem eq_mul_of_div_eq' (h : a / b = c) : a = b * c := by simp [h.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 G M : Type*}", "[Pow \u03b1 \u03b2]", "[Semigroup \u03b1]", "[MulOneClass M]", "[CommSemigroup G]", "[Monoid M] {a b : M} {m n : \u2115}", "[CommMonoid M] {x y z : M}", "[Monoid M] [IsLeftCancelMul M] {a b : M}", "[RightCancelMonoid M] {a b : M}", "[CancelCommMonoid \u03b1] {a b c d : \u03b1}", "[InvolutiveInv G] {a b : G}", "(G)", "[DivInvMonoid G]", "[DivInvOneMonoid G]", "[DivisionMonoid \u03b1] {a b c d : \u03b1}", "(a b c)", "{a b c}", "(a b c)", "[DivisionCommMonoid \u03b1] (a b c d : \u03b1)", "[Group G] {a b c d : G} {n : \u2124}", "[CommGroup G] {a b c d : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2075 : CommSemigroup G\ninst\u271d\u2074 : InvolutiveInv G\ninst\u271d\u00b3 : DivInvMonoid G\ninst\u271d\u00b2 : DivInvOneMonoid G\ninst\u271d\u00b9 : Group G\ninst\u271d : CommGroup G\na b c : G\nh : a / b = c\n\u22a2 a = b * c"}, {"line": "simp [h.symm]", "tactic_state": "G : Type u_3\ninst\u271d\u2075 : CommSemigroup G\ninst\u271d\u2074 : InvolutiveInv G\ninst\u271d\u00b3 : DivInvMonoid G\ninst\u271d\u00b2 : DivInvOneMonoid G\ninst\u271d\u00b9 : Group G\ninst\u271d : CommGroup G\na b c : G\nh : a / b = c\n\u22a2 a = b * (a / b)"}]}
{"declaration": "lemma centralizer_union : centralizer (S \u222a T) = centralizer S \u2229 centralizer T := by\n  simp [centralizer, or_imp, forall_and, setOf_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Center.lean", "context": {"open": [], "variables": ["{M : Type*} {S T : Set M}", "{a c : M} [Mul M]", "[Mul M]", "(M) in", "(S) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\ncentralizer : x\u271d\n\u22a2 sorry = sorry \u2229 sorry"}, {"line": "simp [centralizer, or_imp, forall_and, setOf_and]", "tactic_state": "x\u271d : Sort u_2\ncentralizer : x\u271d\n\u22a2 sorry () = sorry () \u2229 sorry ()"}]}
{"declaration": "lemma subset_centralizer_centralizer : S \u2286 S.centralizer.centralizer := by\n  intro x hx\n  simp only [Set.mem_centralizer_iff]\n  exact fun y hy => (hy x hx).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Center.lean", "context": {"open": [], "variables": ["{M : Type*} {S T : Set M}", "{a c : M} [Mul M]", "[Mul M]", "(M) in", "(S) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nS : Set M\ninst\u271d\u00b9 inst\u271d : Mul M\n\u22a2 S \u2286 S.centralizer.centralizer"}, {"line": "intro x hx", "tactic_state": "M : Type u_1\nS : Set M\ninst\u271d\u00b9 inst\u271d : Mul M\nx : M\nhx : x \u2208 S\n\u22a2 x \u2208 S.centralizer.centralizer"}, {"line": "simp only [Set.mem_centralizer_iff]", "tactic_state": "M : Type u_1\nS : Set M\ninst\u271d\u00b9 inst\u271d : Mul M\nx : M\nhx : x \u2208 S\n\u22a2 \u2200 (m : M), (\u2200 m_1 \u2208 S, m_1 * m = m * m_1) \u2192 m * x = x * m"}, {"line": "exact fun y hy => (hy x hx).symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma centralizer_centralizer_centralizer (S : Set M) :\n    S.centralizer.centralizer.centralizer = S.centralizer := by\n  refine Set.Subset.antisymm ?_ Set.subset_centralizer_centralizer\n  intro x hx\n  rw [Set.mem_centralizer_iff]\n  intro y hy\n  rw [Set.mem_centralizer_iff] at hx\n  exact hx y <| Set.subset_centralizer_centralizer hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Center.lean", "context": {"open": [], "variables": ["{M : Type*} {S T : Set M}", "{a c : M} [Mul M]", "[Mul M]", "(M) in", "(S) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 inst\u271d : Mul M\nS : Set M\n\u22a2 S.centralizer.centralizer.centralizer = S.centralizer"}, {"line": "refine Set.Subset.antisymm ?_ Set.subset_centralizer_centralizer", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 inst\u271d : Mul M\nS : Set M\n\u22a2 S.centralizer.centralizer.centralizer \u2286 S.centralizer"}, {"line": "intro x hx", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 inst\u271d : Mul M\nS : Set M\nx : M\nhx : x \u2208 S.centralizer.centralizer.centralizer\n\u22a2 x \u2208 S.centralizer"}, {"line": "rw [Set.mem_centralizer_iff]", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 inst\u271d : Mul M\nS : Set M\nx : M\nhx : x \u2208 S.centralizer.centralizer.centralizer\n\u22a2 \u2200 m \u2208 S, m * x = x * m"}, {"line": "intro y hy", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 inst\u271d : Mul M\nS : Set M\nx : M\nhx : x \u2208 S.centralizer.centralizer.centralizer\ny : M\nhy : y \u2208 S\n\u22a2 y * x = x * y"}, {"line": "rw [Set.mem_centralizer_iff] at hx", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 inst\u271d : Mul M\nS : Set M\nx : M\nhx : \u2200 m \u2208 S.centralizer.centralizer, m * x = x * m\ny : M\nhy : y \u2208 S\n\u22a2 y * x = x * y"}, {"line": "exact hx y <| Set.subset_centralizer_centralizer hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_mem_center (ha : a \u2208 Set.center M) (hb : b \u2208 Set.center M) : a / b \u2208 Set.center M := by\n  rw [div_eq_mul_inv]\n  exact mul_mem_center ha (inv_mem_center hb)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Center.lean", "context": {"open": [], "variables": ["{M : Type*} {S T : Set M}", "{a c : M} [Mul M]", "[Mul M]", "(M) in", "(S) in", "[Semigroup M] {a b : M}", "(M) in", "[CommSemigroup M]", "(M)", "[MulOneClass M]", "[Monoid M]", "[DivisionMonoid M] {a b : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 : Mul M\ninst\u271d\u00b2 : MulOneClass M\ninst\u271d\u00b9 : Monoid M\ninst\u271d : DivisionMonoid M\na b : M\nha : a \u2208 Set.center M\nhb : b \u2208 Set.center M\n\u22a2 a / b \u2208 Set.center M"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "M : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 : Mul M\ninst\u271d\u00b2 : MulOneClass M\ninst\u271d\u00b9 : Monoid M\ninst\u271d : DivisionMonoid M\na b : M\nha : a \u2208 Set.center M\nhb : b \u2208 Set.center M\n\u22a2 a * b\u207b\u00b9 \u2208 Set.center M"}, {"line": "exact mul_mem_center ha (inv_mem_center hb)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isConj_one_right {a : \u03b1} : IsConj 1 a \u2194 a = 1 := by\n  refine \u27e8fun \u27e8c, h\u27e9 => ?_, fun h => by rw [h]\u27e9\n  rw [SemiconjBy] at h\n  rw [mul_one] at h\n  exact c.isUnit.mul_eq_right.mp h.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Conj.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[Monoid \u03b1] [Monoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Monoid \u03b1\na : \u03b1\n\u22a2 IsConj 1 a \u2194 a = 1"}, {"line": "refine \u27e8fun \u27e8c, h\u27e9 => ?_, fun h => by rw [h]\u27e9", "tactic_state": "\u03b1 : Type u\ninst\u271d : Monoid \u03b1\na : \u03b1\nx\u271d : IsConj 1 a\nc : \u03b1\u02e3\nh : SemiconjBy (\u2191c) 1 a\n\u22a2 a = 1"}, {"line": "rw [SemiconjBy] at h", "tactic_state": "\u03b1 : Type u\ninst\u271d : Monoid \u03b1\na : \u03b1\nx\u271d : IsConj 1 a\nc : \u03b1\u02e3\nh : \u2191c * 1 = a * \u2191c\n\u22a2 a = 1"}, {"line": "rw [mul_one] at h", "tactic_state": "\u03b1 : Type u\ninst\u271d : Monoid \u03b1\na : \u03b1\nx\u271d : IsConj 1 a\nc : \u03b1\u02e3\nh : \u2191c = a * \u2191c\n\u22a2 a = 1"}, {"line": "exact c.isUnit.mul_eq_right.mp h.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem conj_pow {i : \u2115} {a b : \u03b1} : (a * b * a\u207b\u00b9) ^ i = a * b ^ i * a\u207b\u00b9 := by\n  induction' i with i hi\n  \u00b7 simp\n  \u00b7 simp [pow_succ, hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Conj.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[Monoid \u03b1] [Monoid \u03b2]", "[Group \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Group \u03b1\ni : \u2115\na b : \u03b1\n\u22a2 (a * b * a\u207b\u00b9) ^ i = a * b ^ i * a\u207b\u00b9"}, {"line": "induction' i with i hi", "tactic_state": "case zero\n\u03b1 : Type u\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Group \u03b1\na b : \u03b1\n\u22a2 (a * b * a\u207b\u00b9) ^ 0 = a * b ^ 0 * a\u207b\u00b9\n---\ncase succ\n\u03b1 : Type u\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Group \u03b1\na b : \u03b1\ni : \u2115\nhi : (a * b * a\u207b\u00b9) ^ i = a * b ^ i * a\u207b\u00b9\n\u22a2 (a * b * a\u207b\u00b9) ^ (i + 1) = a * b ^ (i + 1) * a\u207b\u00b9"}, {"line": "\u00b7 simp", "tactic_state": "case succ\n\u03b1 : Type u\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Group \u03b1\na b : \u03b1\ni : \u2115\nhi : (a * b * a\u207b\u00b9) ^ i = a * b ^ i * a\u207b\u00b9\n\u22a2 (a * b * a\u207b\u00b9) ^ (i + 1) = a * b ^ (i + 1) * a\u207b\u00b9"}, {"line": "\u00b7 simp [pow_succ, hi]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MulOneClass.ext {M : Type u} : \u2200 \u2983m\u2081 m\u2082 : MulOneClass M\u2984, m\u2081.mul = m\u2082.mul \u2192 m\u2081 = m\u2082 := by\n  rintro @\u27e8\u27e8one\u2081\u27e9, \u27e8mul\u2081\u27e9, one_mul\u2081, mul_one\u2081\u27e9 @\u27e8\u27e8one\u2082\u27e9, \u27e8mul\u2082\u27e9, one_mul\u2082, mul_one\u2082\u27e9 \u27e8rfl\u27e9\n  -- FIXME (See https://github.com/leanprover/lean4/issues/1711)\n  -- congr\n  suffices one\u2081 = one\u2082 by cases this; rfl\n  exact (one_mul\u2082 one\u2081).symm.trans (mul_one\u2081 one\u2082)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Defs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[Mul G]", "[IsLeftCancelMul G] {a b c : G}", "[IsRightCancelMul G] {a b c : G}", "[Semigroup G]", "[CommMagma G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\n\u22a2 \u2200 \u2983m\u2081 m\u2082 : MulOneClass M\u2984, Mul.mul = Mul.mul \u2192 m\u2081 = m\u2082"}, {"line": "rintro @\u27e8\u27e8one\u2081\u27e9, \u27e8mul\u2081\u27e9, one_mul\u2081, mul_one\u2081\u27e9 @\u27e8\u27e8one\u2082\u27e9, \u27e8mul\u2082\u27e9, one_mul\u2082, mul_one\u2082\u27e9 \u27e8rfl\u27e9", "tactic_state": "case mk.mk.mk.mk.mk.mk.refl\nM : Type u\none\u2081 : M\nmul\u2081 : M \u2192 M \u2192 M\none_mul\u2081 : \u2200 (a : M), 1 * a = a\nmul_one\u2081 : \u2200 (a : M), a * 1 = a\none\u2082 : M\none_mul\u2082 : \u2200 (a : M), 1 * a = a\nmul_one\u2082 : \u2200 (a : M), a * 1 = a\n\u22a2 { one := one\u2081, mul := mul\u2081, one_mul := one_mul\u2081, mul_one := mul_one\u2081 } =\n    { one := one\u2082, mul := mul\u2081, one_mul := one_mul\u2082, mul_one := mul_one\u2082 }"}, {"line": "suffices one\u2081 = one\u2082 by cases this; rfl", "tactic_state": "case mk.mk.mk.mk.mk.mk.refl\nM : Type u\none\u2081 : M\nmul\u2081 : M \u2192 M \u2192 M\none_mul\u2081 : \u2200 (a : M), 1 * a = a\nmul_one\u2081 : \u2200 (a : M), a * 1 = a\none\u2082 : M\none_mul\u2082 : \u2200 (a : M), 1 * a = a\nmul_one\u2082 : \u2200 (a : M), a * 1 = a\n\u22a2 one\u2081 = one\u2082"}, {"line": "exact (one_mul\u2082 one\u2081).symm.trans (mul_one\u2081 one\u2082)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_mul_comm' (a : M) (n : \u2115) : a ^ n * a = a * a ^ n := by rw [\u2190 pow_succ, pow_succ']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Defs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[Mul G]", "[IsLeftCancelMul G] {a b c : G}", "[IsRightCancelMul G] {a b c : G}", "[Semigroup G]", "[CommMagma G]", "{M : Type u} [MulOneClass M]", "{M : Type u}", "[One M] [Semigroup M] (m n : \u2115) (hn : n \u2260 0) (a : M) (ha : 1 * a = a)", "{M : Type*} [Monoid M] {a b c : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : Monoid M\na : M\nn : \u2115\n\u22a2 a ^ n * a = a * a ^ n"}, {"line": "rw [\u2190 pow_succ, pow_succ']", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_three' (a : M) : a ^ 3 = a * a * a := by rw [pow_succ, pow_two]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Defs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[Mul G]", "[IsLeftCancelMul G] {a b c : G}", "[IsRightCancelMul G] {a b c : G}", "[Semigroup G]", "[CommMagma G]", "{M : Type u} [MulOneClass M]", "{M : Type u}", "[One M] [Semigroup M] (m n : \u2115) (hn : n \u2260 0) (a : M) (ha : 1 * a = a)", "{M : Type*} [Monoid M] {a b c : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : Monoid M\na : M\n\u22a2 a ^ 3 = a * a * a"}, {"line": "rw [pow_succ, pow_two]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_three (a : M) : a ^ 3 = a * (a * a) := by rw [pow_succ', pow_two]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Defs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[Mul G]", "[IsLeftCancelMul G] {a b c : G}", "[IsRightCancelMul G] {a b c : G}", "[Semigroup G]", "[CommMagma G]", "{M : Type u} [MulOneClass M]", "{M : Type u}", "[One M] [Semigroup M] (m n : \u2115) (hn : n \u2260 0) (a : M) (ha : 1 * a = a)", "{M : Type*} [Monoid M] {a b c : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : Monoid M\na : M\n\u22a2 a ^ 3 = a * (a * a)"}, {"line": "rw [pow_succ', pow_two]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_mul' (a : M) (m n : \u2115) : a ^ (m * n) = (a ^ n) ^ m := by rw [Nat.mul_comm, pow_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Defs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[Mul G]", "[IsLeftCancelMul G] {a b c : G}", "[IsRightCancelMul G] {a b c : G}", "[Semigroup G]", "[CommMagma G]", "{M : Type u} [MulOneClass M]", "{M : Type u}", "[One M] [Semigroup M] (m n : \u2115) (hn : n \u2260 0) (a : M) (ha : 1 * a = a)", "{M : Type*} [Monoid M] {a b c : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : Monoid M\na : M\nm n : \u2115\n\u22a2 a ^ (m * n) = (a ^ n) ^ m"}, {"line": "rw [Nat.mul_comm, pow_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_right_comm (a : M) (m n : \u2115) : (a ^ m) ^ n = (a ^ n) ^ m := by\n  rw [\u2190 pow_mul]\n  rw [Nat.mul_comm]\n  rw [pow_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Defs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[Mul G]", "[IsLeftCancelMul G] {a b c : G}", "[IsRightCancelMul G] {a b c : G}", "[Semigroup G]", "[CommMagma G]", "{M : Type u} [MulOneClass M]", "{M : Type u}", "[One M] [Semigroup M] (m n : \u2115) (hn : n \u2260 0) (a : M) (ha : 1 * a = a)", "{M : Type*} [Monoid M] {a b c : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : Monoid M\na : M\nm n : \u2115\n\u22a2 (a ^ m) ^ n = (a ^ n) ^ m"}, {"line": "rw [\u2190 pow_mul]", "tactic_state": "M : Type u_2\ninst\u271d : Monoid M\na : M\nm n : \u2115\n\u22a2 a ^ (m * n) = (a ^ n) ^ m"}, {"line": "rw [Nat.mul_comm]", "tactic_state": "M : Type u_2\ninst\u271d : Monoid M\na : M\nm n : \u2115\n\u22a2 a ^ (n * m) = (a ^ n) ^ m"}, {"line": "rw [pow_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zpow_negSucc (a : G) (n : \u2115) : a ^ (Int.negSucc n) = (a ^ (n + 1))\u207b\u00b9 := by\n  rw [\u2190 zpow_natCast]\n  exact DivInvMonoid.zpow_neg' n a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Defs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[Mul G]", "[IsLeftCancelMul G] {a b c : G}", "[IsRightCancelMul G] {a b c : G}", "[Semigroup G]", "[CommMagma G]", "{M : Type u} [MulOneClass M]", "{M : Type u}", "[One M] [Semigroup M] (m n : \u2115) (hn : n \u2260 0) (a : M) (ha : 1 * a = a)", "{M : Type*} [Monoid M] {a b c : M}", "[InvolutiveInv G]", "[DivInvMonoid G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u2076 : Mul G\ninst\u271d\u2075 : IsLeftCancelMul G\ninst\u271d\u2074 : IsRightCancelMul G\ninst\u271d\u00b3 : Semigroup G\ninst\u271d\u00b2 : CommMagma G\ninst\u271d\u00b9 : InvolutiveInv G\ninst\u271d : DivInvMonoid G\na : G\nn : \u2115\n\u22a2 a ^ Int.negSucc n = (a ^ (n + 1))\u207b\u00b9"}, {"line": "rw [\u2190 zpow_natCast]", "tactic_state": "G : Type u_1\ninst\u271d\u2076 : Mul G\ninst\u271d\u2075 : IsLeftCancelMul G\ninst\u271d\u2074 : IsRightCancelMul G\ninst\u271d\u00b3 : Semigroup G\ninst\u271d\u00b2 : CommMagma G\ninst\u271d\u00b9 : InvolutiveInv G\ninst\u271d : DivInvMonoid G\na : G\nn : \u2115\n\u22a2 a ^ Int.negSucc n = (a ^ \u2191(n + 1))\u207b\u00b9"}, {"line": "exact DivInvMonoid.zpow_neg' n a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem negSucc_zsmul {G} [SubNegMonoid G] (a : G) (n : \u2115) :\n    Int.negSucc n \u2022 a = -((n + 1) \u2022 a) := by\n  rw [\u2190 natCast_zsmul]\n  exact SubNegMonoid.zsmul_neg' n a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Defs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[Mul G]", "[IsLeftCancelMul G] {a b c : G}", "[IsRightCancelMul G] {a b c : G}", "[Semigroup G]", "[CommMagma G]", "{M : Type u} [MulOneClass M]", "{M : Type u}", "[One M] [Semigroup M] (m n : \u2115) (hn : n \u2260 0) (a : M) (ha : 1 * a = a)", "{M : Type*} [Monoid M] {a b c : M}", "[InvolutiveInv G]", "[DivInvMonoid G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d : SubNegMonoid G\na : G\nn : \u2115\n\u22a2 Int.negSucc n \u2022 a = -((n + 1) \u2022 a)"}, {"line": "rw [\u2190 natCast_zsmul]", "tactic_state": "G : Type u_3\ninst\u271d : SubNegMonoid G\na : G\nn : \u2115\n\u22a2 Int.negSucc n \u2022 a = -(\u2191(n + 1) \u2022 a)"}, {"line": "exact SubNegMonoid.zsmul_neg' n a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_eq_one_div (x : G) : x\u207b\u00b9 = 1 / x := by rw [div_eq_mul_inv, one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Defs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[Mul G]", "[IsLeftCancelMul G] {a b c : G}", "[IsRightCancelMul G] {a b c : G}", "[Semigroup G]", "[CommMagma G]", "{M : Type u} [MulOneClass M]", "{M : Type u}", "[One M] [Semigroup M] (m n : \u2115) (hn : n \u2260 0) (a : M) (ha : 1 * a = a)", "{M : Type*} [Monoid M] {a b c : M}", "[InvolutiveInv G]", "[DivInvMonoid G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u2076 : Mul G\ninst\u271d\u2075 : IsLeftCancelMul G\ninst\u271d\u2074 : IsRightCancelMul G\ninst\u271d\u00b3 : Semigroup G\ninst\u271d\u00b2 : CommMagma G\ninst\u271d\u00b9 : InvolutiveInv G\ninst\u271d : DivInvMonoid G\nx : G\n\u22a2 x\u207b\u00b9 = 1 / x"}, {"line": "rw [div_eq_mul_inv, one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zpow_one (a : G) : a ^ (1 : \u2124) = a := by rw [zpow_ofNat, pow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Defs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[Mul G]", "[IsLeftCancelMul G] {a b c : G}", "[IsRightCancelMul G] {a b c : G}", "[Semigroup G]", "[CommMagma G]", "{M : Type u} [MulOneClass M]", "{M : Type u}", "[One M] [Semigroup M] (m n : \u2115) (hn : n \u2260 0) (a : M) (ha : 1 * a = a)", "{M : Type*} [Monoid M] {a b c : M}", "[InvolutiveInv G]", "[DivInvMonoid G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u2076 : Mul G\ninst\u271d\u2075 : IsLeftCancelMul G\ninst\u271d\u2074 : IsRightCancelMul G\ninst\u271d\u00b3 : Semigroup G\ninst\u271d\u00b2 : CommMagma G\ninst\u271d\u00b9 : InvolutiveInv G\ninst\u271d : DivInvMonoid G\na : G\n\u22a2 a ^ 1 = a"}, {"line": "rw [zpow_ofNat, pow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem swap_mul_self_mul (i j : \u03b1) (\u03c3 : Perm \u03b1) : Equiv.swap i j * (Equiv.swap i j * \u03c3) = \u03c3 := by\n  simp [\u2190 mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/End.lean", "context": {"open": [], "variables": ["{A M G \u03b1 \u03b2 : Type*}", "(\u03b1) in", "(e : Perm \u03b1) {p : \u03b2 \u2192 Prop} [DecidablePred p] (f : \u03b1 \u2243 Subtype p)", "{p : \u03b1 \u2192 Prop} {f : Perm \u03b1}", "[DecidablePred p] {a : \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Perm : ?m.1891\nA : Type u_1\nM : Type u_2\nG : Type u_3\n\u03b1\u271d : Type u_4\n\u03b2 : Type u_5\np : \u03b1\u271d \u2192 Prop\nf : sorry\ninst\u271d\u00b2 : DecidablePred p\na : \u03b1\u271d\ninst\u271d\u00b9 : DecidableEq \u03b1\u271d\n\u03b1 : Type u_4\ninst\u271d : DecidableEq \u03b1\ni j : \u03b1\n\u03c3 : sorry\n\u22a2 sorry"}, {"line": "simp [\u2190 mul_assoc]", "tactic_state": "Perm : ?m.1891\nA : Type u_1\nM : Type u_2\nG : Type u_3\n\u03b1\u271d : Type u_4\n\u03b2 : Type u_5\np : \u03b1\u271d \u2192 Prop\nf : sorry\ninst\u271d\u00b2 : DecidablePred p\na : \u03b1\u271d\ninst\u271d\u00b9 : DecidableEq \u03b1\u271d\n\u03b1 : Type u_4\ninst\u271d : DecidableEq \u03b1\ni j : \u03b1\n\u03c3 : sorry\n\u22a2 sorry ()"}]}
{"declaration": "theorem neg_conj_apply [AddGroup G] (g h : G) : (-conj g).toMul h = -g + h + g := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/End.lean", "context": {"open": [], "variables": ["{A M G \u03b1 \u03b2 : Type*}", "(\u03b1) in", "(e : Perm \u03b1) {p : \u03b2 \u2192 Prop} [DecidablePred p] (f : \u03b1 \u2243 Subtype p)", "{p : \u03b1 \u2192 Prop} {f : Perm \u03b1}", "[DecidablePred p] {a : \u03b1}", "[DecidableEq \u03b1]", "[AddGroup \u03b1] (a b : \u03b1)", "[Group \u03b1] (a b : \u03b1)", "(M) [Mul M]", "(A) [Add A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Perm : ?m.3909\nA : Type u_1\nM : Type u_2\nG\u271d : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\np : \u03b1 \u2192 Prop\nf : sorry\ninst\u271d\u2076 : DecidablePred p\na\u271d\u00b9 : \u03b1\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : AddGroup \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d\u00b3 : Group \u03b1\na b : \u03b1\ninst\u271d\u00b2 : Mul M\ninst\u271d\u00b9 : Add A\nG : Type u_3\nx\u271d : Sort u_6\nconj : x\u271d\ninst\u271d : AddGroup G\ng h : G\n\u22a2 sorry = -g + h + g"}, {"line": "simp", "tactic_state": "Perm : ?m.3909\nA : Type u_1\nM : Type u_2\nG\u271d : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\np : \u03b1 \u2192 Prop\nf : sorry\ninst\u271d\u2076 : DecidablePred p\na\u271d\u00b9 : \u03b1\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : AddGroup \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d\u00b3 : Group \u03b1\na b : \u03b1\ninst\u271d\u00b2 : Mul M\ninst\u271d\u00b9 : Add A\nG : Type u_3\nx\u271d : Sort u_6\nconj : x\u271d\ninst\u271d : AddGroup G\ng h : G\n\u22a2 sorry () = -g + h + g"}]}
{"declaration": "lemma isSquare_iff_exists_sq (a : \u03b1) : IsSquare a \u2194 \u2203 r, a = r ^ 2 := by simp [IsSquare, pow_two]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Even.lean", "context": {"open": ["MulOpposite"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Mul \u03b1]", "[Add \u03b1]", "[MulOneClass \u03b1] [MulOneClass \u03b2] [FunLike F \u03b1 \u03b2] [MonoidHomClass F \u03b1 \u03b2]", "[Monoid \u03b1] {n : \u2115} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : Monoid \u03b1\na : \u03b1\n\u22a2 IsSquare a \u2194 \u2203 r, a = r ^ 2"}, {"line": "simp [IsSquare, pow_two]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : Monoid \u03b1\na : \u03b1\n\u22a2 (\u2203 r, a = r * r) \u2194 \u2203 r, a = r * r"}]}
{"declaration": "theorem Monoid.ext {M : Type u} \u2983m\u2081 m\u2082 : Monoid M\u2984\n    (h_mul : (letI := m\u2081; HMul.hMul : M \u2192 M \u2192 M) = (letI := m\u2082; HMul.hMul : M \u2192 M \u2192 M)) :\n    m\u2081 = m\u2082 := by\n  have : m\u2081.toMulOneClass = m\u2082.toMulOneClass := MulOneClass.ext h_mul\n  have h\u2081 : m\u2081.one = m\u2082.one := congr_arg (\u00b7.one) this\n  let f : @MonoidHom M M m\u2081.toMulOneClass m\u2082.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h\u2081)\n      (fun x y => congr_fun (congr_fun h_mul x) y)\n  have : m\u2081.npow = m\u2082.npow := by\n    ext n x\n    exact @MonoidHom.map_pow M M m\u2081 m\u2082 f x n\n  rcases m\u2081 with @\u27e8@\u27e8\u27e8_\u27e9\u27e9, \u27e8_\u27e9\u27e9\n  rcases m\u2082 with @\u27e8@\u27e8\u27e8_\u27e9\u27e9, \u27e8_\u27e9\u27e9\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Ext.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\nm\u2081 m\u2082 : Monoid M\nh_mul : HMul.hMul = HMul.hMul\n\u22a2 m\u2081 = m\u2082"}, {"line": "have : m\u2081.toMulOneClass = m\u2082.toMulOneClass := MulOneClass.ext h_mul", "tactic_state": "M : Type u\nm\u2081 m\u2082 : Monoid M\nh_mul : HMul.hMul = HMul.hMul\nthis : toMulOneClass = toMulOneClass\n\u22a2 m\u2081 = m\u2082"}, {"line": "have h\u2081 : m\u2081.one = m\u2082.one := congr_arg (\u00b7.one) this", "tactic_state": "M : Type u\nm\u2081 m\u2082 : Monoid M\nh_mul : HMul.hMul = HMul.hMul\nthis : toMulOneClass = toMulOneClass\nh\u2081 : One.one = One.one\n\u22a2 m\u2081 = m\u2082"}, {"line": "let f : @MonoidHom M M m\u2081.toMulOneClass m\u2082.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h\u2081)\n      (fun x y => congr_fun (congr_fun h_mul x) y)", "tactic_state": "M : Type u\nm\u2081 m\u2082 : Monoid M\nh_mul : HMul.hMul = HMul.hMul\nthis : toMulOneClass = toMulOneClass\nh\u2081 : One.one = One.one\nf : M \u2192* M := sorry\n\u22a2 m\u2081 = m\u2082"}, {"line": "have : m\u2081.npow = m\u2082.npow := by\n    ext n x\n    exact @MonoidHom.map_pow M M m\u2081 m\u2082 f x n", "tactic_state": "M : Type u\nm\u2081 m\u2082 : Monoid M\nh_mul : HMul.hMul = HMul.hMul\nthis\u271d : toMulOneClass = toMulOneClass\nh\u2081 : One.one = One.one\nf : M \u2192* M := sorry\nthis : Monoid.npow = Monoid.npow\n\u22a2 m\u2081 = m\u2082"}, {"line": "rcases m\u2081 with @\u27e8@\u27e8\u27e8_\u27e9\u27e9, \u27e8_\u27e9\u27e9", "tactic_state": "case mk.mk.mk.mk\nM : Type u\nm\u2082 : Monoid M\nnpow\u271d : \u2115 \u2192 M \u2192 M\nmul\u271d : M \u2192 M \u2192 M\nmul_assoc\u271d : \u2200 (a b c : M), a * b * c = a * (b * c)\nnpow_succ\u271d : \u2200 (n : \u2115) (x : M), npow\u271d (n + 1) x = npow\u271d n x * x\none\u271d : M\nnpow_zero\u271d : \u2200 (x : M), npow\u271d 0 x = 1\none_mul\u271d : \u2200 (a : M), 1 * a = a\nmul_one\u271d : \u2200 (a : M), a * 1 = a\nh_mul : HMul.hMul = HMul.hMul\nthis\u271d : toMulOneClass = toMulOneClass\nh\u2081 : One.one = One.one\nf : M \u2192* M := sorry\nthis : Monoid.npow = Monoid.npow\n\u22a2 { mul := mul\u271d, mul_assoc := mul_assoc\u271d, one := one\u271d, one_mul := one_mul\u271d, mul_one := mul_one\u271d, npow := npow\u271d,\n      npow_zero := npow_zero\u271d, npow_succ := npow_succ\u271d } =\n    m\u2082"}, {"line": "rcases m\u2082 with @\u27e8@\u27e8\u27e8_\u27e9\u27e9, \u27e8_\u27e9\u27e9", "tactic_state": "case mk.mk.mk.mk.mk.mk.mk.mk\nM : Type u\nnpow\u271d\u00b9 : \u2115 \u2192 M \u2192 M\nmul\u271d\u00b9 : M \u2192 M \u2192 M\nmul_assoc\u271d\u00b9 : \u2200 (a b c : M), a * b * c = a * (b * c)\nnpow_succ\u271d\u00b9 : \u2200 (n : \u2115) (x : M), npow\u271d\u00b9 (n + 1) x = npow\u271d\u00b9 n x * x\none\u271d\u00b9 : M\nnpow_zero\u271d\u00b9 : \u2200 (x : M), npow\u271d\u00b9 0 x = 1\none_mul\u271d\u00b9 : \u2200 (a : M), 1 * a = a\nmul_one\u271d\u00b9 : \u2200 (a : M), a * 1 = a\nnpow\u271d : \u2115 \u2192 M \u2192 M\nmul\u271d : M \u2192 M \u2192 M\nmul_assoc\u271d : \u2200 (a b c : M), a * b * c = a * (b * c)\nnpow_succ\u271d : \u2200 (n : \u2115) (x : M), npow\u271d (n + 1) x = npow\u271d n x * x\none\u271d : M\nnpow_zero\u271d : \u2200 (x : M), npow\u271d 0 x = 1\none_mul\u271d : \u2200 (a : M), 1 * a = a\nmul_one\u271d : \u2200 (a : M), a * 1 = a\nh_mul : HMul.hMul = HMul.hMul\nthis\u271d : toMulOneClass = toMulOneClass\nh\u2081 : One.one = One.one\nf : M \u2192* M := sorry\nthis : Monoid.npow = Monoid.npow\n\u22a2 { mul := mul\u271d\u00b9, mul_assoc := mul_assoc\u271d\u00b9, one := one\u271d\u00b9, one_mul := one_mul\u271d\u00b9, mul_one := mul_one\u271d\u00b9, npow := npow\u271d\u00b9,\n      npow_zero := npow_zero\u271d\u00b9, npow_succ := npow_succ\u271d\u00b9 } =\n    { mul := mul\u271d, mul_assoc := mul_assoc\u271d, one := one\u271d, one_mul := one_mul\u271d, mul_one := mul_one\u271d, npow := npow\u271d,\n      npow_zero := npow_zero\u271d, npow_succ := npow_succ\u271d }"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem CommMonoid.toMonoid_injective {M : Type u} :\n    Function.Injective (@CommMonoid.toMonoid M) := by\n  rintro \u27e8\u27e9 \u27e8\u27e9 h\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Ext.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\n\u22a2 Injective (@toMonoid M)"}, {"line": "rintro \u27e8\u27e9 \u27e8\u27e9 h", "tactic_state": "case mk.mk\nM : Type u\ntoMonoid\u271d\u00b9 : Monoid M\nmul_comm\u271d\u00b9 : \u2200 (a b : M), a * b = b * a\ntoMonoid\u271d : Monoid M\nmul_comm\u271d : \u2200 (a b : M), a * b = b * a\nh : toMonoid = toMonoid\n\u22a2 { toMonoid := toMonoid\u271d\u00b9, mul_comm := mul_comm\u271d\u00b9 } = { toMonoid := toMonoid\u271d, mul_comm := mul_comm\u271d }"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LeftCancelMonoid.toMonoid_injective {M : Type u} :\n    Function.Injective (@LeftCancelMonoid.toMonoid M) := by\n  rintro @\u27e8@\u27e8\u27e9\u27e9 @\u27e8@\u27e8\u27e9\u27e9 h\n  congr <;> injection h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Ext.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\n\u22a2 Injective (@toMonoid M)"}, {"line": "rintro @\u27e8@\u27e8\u27e9\u27e9 @\u27e8@\u27e8\u27e9\u27e9 h", "tactic_state": "case mk.mk.mk.mk\nM : Type u\ntoSemigroup\u271d\u00b9 : Semigroup M\ntoOne\u271d\u00b9 : One M\none_mul\u271d\u00b9 : \u2200 (a : M), 1 * a = a\nmul_one\u271d\u00b9 : \u2200 (a : M), a * 1 = a\nnpow\u271d\u00b9 : \u2115 \u2192 M \u2192 M\nnpow_zero\u271d\u00b9 : \u2200 (x : M), npow\u271d\u00b9 0 x = 1\nnpow_succ\u271d\u00b9 : \u2200 (n : \u2115) (x : M), npow\u271d\u00b9 (n + 1) x = npow\u271d\u00b9 n x * x\nmul_left_cancel\u271d\u00b9 : \u2200 (a b c : M), a * b = a * c \u2192 b = c\ntoSemigroup\u271d : Semigroup M\ntoOne\u271d : One M\none_mul\u271d : \u2200 (a : M), 1 * a = a\nmul_one\u271d : \u2200 (a : M), a * 1 = a\nnpow\u271d : \u2115 \u2192 M \u2192 M\nnpow_zero\u271d : \u2200 (x : M), npow\u271d 0 x = 1\nnpow_succ\u271d : \u2200 (n : \u2115) (x : M), npow\u271d (n + 1) x = npow\u271d n x * x\nmul_left_cancel\u271d : \u2200 (a b c : M), a * b = a * c \u2192 b = c\nh : toMonoid = toMonoid\n\u22a2 { toSemigroup := toSemigroup\u271d\u00b9, toOne := toOne\u271d\u00b9, one_mul := one_mul\u271d\u00b9, mul_one := mul_one\u271d\u00b9, npow := npow\u271d\u00b9,\n      npow_zero := npow_zero\u271d\u00b9, npow_succ := npow_succ\u271d\u00b9, mul_left_cancel := mul_left_cancel\u271d\u00b9 } =\n    { toSemigroup := toSemigroup\u271d, toOne := toOne\u271d, one_mul := one_mul\u271d, mul_one := mul_one\u271d, npow := npow\u271d,\n      npow_zero := npow_zero\u271d, npow_succ := npow_succ\u271d, mul_left_cancel := mul_left_cancel\u271d }"}, {"line": "congr <;> injection h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem RightCancelMonoid.toMonoid_injective {M : Type u} :\n    Function.Injective (@RightCancelMonoid.toMonoid M) := by\n  rintro @\u27e8@\u27e8\u27e9\u27e9 @\u27e8@\u27e8\u27e9\u27e9 h\n  congr <;> injection h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Ext.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\n\u22a2 Injective (@toMonoid M)"}, {"line": "rintro @\u27e8@\u27e8\u27e9\u27e9 @\u27e8@\u27e8\u27e9\u27e9 h", "tactic_state": "case mk.mk.mk.mk\nM : Type u\ntoSemigroup\u271d\u00b9 : Semigroup M\ntoOne\u271d\u00b9 : One M\none_mul\u271d\u00b9 : \u2200 (a : M), 1 * a = a\nmul_one\u271d\u00b9 : \u2200 (a : M), a * 1 = a\nnpow\u271d\u00b9 : \u2115 \u2192 M \u2192 M\nnpow_zero\u271d\u00b9 : \u2200 (x : M), npow\u271d\u00b9 0 x = 1\nnpow_succ\u271d\u00b9 : \u2200 (n : \u2115) (x : M), npow\u271d\u00b9 (n + 1) x = npow\u271d\u00b9 n x * x\nmul_right_cancel\u271d\u00b9 : \u2200 (a b c : M), a * b = c * b \u2192 a = c\ntoSemigroup\u271d : Semigroup M\ntoOne\u271d : One M\none_mul\u271d : \u2200 (a : M), 1 * a = a\nmul_one\u271d : \u2200 (a : M), a * 1 = a\nnpow\u271d : \u2115 \u2192 M \u2192 M\nnpow_zero\u271d : \u2200 (x : M), npow\u271d 0 x = 1\nnpow_succ\u271d : \u2200 (n : \u2115) (x : M), npow\u271d (n + 1) x = npow\u271d n x * x\nmul_right_cancel\u271d : \u2200 (a b c : M), a * b = c * b \u2192 a = c\nh : toMonoid = toMonoid\n\u22a2 { toSemigroup := toSemigroup\u271d\u00b9, toOne := toOne\u271d\u00b9, one_mul := one_mul\u271d\u00b9, mul_one := mul_one\u271d\u00b9, npow := npow\u271d\u00b9,\n      npow_zero := npow_zero\u271d\u00b9, npow_succ := npow_succ\u271d\u00b9, mul_right_cancel := mul_right_cancel\u271d\u00b9 } =\n    { toSemigroup := toSemigroup\u271d, toOne := toOne\u271d, one_mul := one_mul\u271d, mul_one := mul_one\u271d, npow := npow\u271d,\n      npow_zero := npow_zero\u271d, npow_succ := npow_succ\u271d, mul_right_cancel := mul_right_cancel\u271d }"}, {"line": "congr <;> injection h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem CancelMonoid.toLeftCancelMonoid_injective {M : Type u} :\n    Function.Injective (@CancelMonoid.toLeftCancelMonoid M) := by\n  rintro \u27e8\u27e9 \u27e8\u27e9 h\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Ext.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\n\u22a2 Injective (@toLeftCancelMonoid M)"}, {"line": "rintro \u27e8\u27e9 \u27e8\u27e9 h", "tactic_state": "case mk.mk\nM : Type u\ntoLeftCancelMonoid\u271d\u00b9 : LeftCancelMonoid M\nmul_right_cancel\u271d\u00b9 : \u2200 (a b c : M), a * b = c * b \u2192 a = c\ntoLeftCancelMonoid\u271d : LeftCancelMonoid M\nmul_right_cancel\u271d : \u2200 (a b c : M), a * b = c * b \u2192 a = c\nh : toLeftCancelMonoid = toLeftCancelMonoid\n\u22a2 { toLeftCancelMonoid := toLeftCancelMonoid\u271d\u00b9, mul_right_cancel := mul_right_cancel\u271d\u00b9 } =\n    { toLeftCancelMonoid := toLeftCancelMonoid\u271d, mul_right_cancel := mul_right_cancel\u271d }"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem CancelCommMonoid.toCommMonoid_injective {M : Type u} :\n    Function.Injective (@CancelCommMonoid.toCommMonoid M) := by\n  rintro @\u27e8@\u27e8@\u27e8\u27e9\u27e9\u27e9 @\u27e8@\u27e8@\u27e8\u27e9\u27e9\u27e9 h\n  congr <;> {\n    injection h with h'\n    injection h' }\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Ext.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\n\u22a2 Injective (@toCommMonoid M)"}, {"line": "rintro @\u27e8@\u27e8@\u27e8\u27e9\u27e9\u27e9 @\u27e8@\u27e8@\u27e8\u27e9\u27e9\u27e9 h", "tactic_state": "case mk.mk.mk.mk.mk.mk\nM : Type u\ntoSemigroup\u271d\u00b9 : Semigroup M\ntoOne\u271d\u00b9 : One M\none_mul\u271d\u00b9 : \u2200 (a : M), 1 * a = a\nmul_one\u271d\u00b9 : \u2200 (a : M), a * 1 = a\nnpow\u271d\u00b9 : \u2115 \u2192 M \u2192 M\nnpow_zero\u271d\u00b9 : \u2200 (x : M), npow\u271d\u00b9 0 x = 1\nnpow_succ\u271d\u00b9 : \u2200 (n : \u2115) (x : M), npow\u271d\u00b9 (n + 1) x = npow\u271d\u00b9 n x * x\nmul_comm\u271d\u00b9 : \u2200 (a b : M), a * b = b * a\nmul_left_cancel\u271d\u00b9 : \u2200 (a b c : M), a * b = a * c \u2192 b = c\ntoSemigroup\u271d : Semigroup M\ntoOne\u271d : One M\none_mul\u271d : \u2200 (a : M), 1 * a = a\nmul_one\u271d : \u2200 (a : M), a * 1 = a\nnpow\u271d : \u2115 \u2192 M \u2192 M\nnpow_zero\u271d : \u2200 (x : M), npow\u271d 0 x = 1\nnpow_succ\u271d : \u2200 (n : \u2115) (x : M), npow\u271d (n + 1) x = npow\u271d n x * x\nmul_comm\u271d : \u2200 (a b : M), a * b = b * a\nmul_left_cancel\u271d : \u2200 (a b c : M), a * b = a * c \u2192 b = c\nh : toCommMonoid = toCommMonoid\n\u22a2 { toSemigroup := toSemigroup\u271d\u00b9, toOne := toOne\u271d\u00b9, one_mul := one_mul\u271d\u00b9, mul_one := mul_one\u271d\u00b9, npow := npow\u271d\u00b9,\n      npow_zero := npow_zero\u271d\u00b9, npow_succ := npow_succ\u271d\u00b9, mul_comm := mul_comm\u271d\u00b9,\n      mul_left_cancel := mul_left_cancel\u271d\u00b9 } =\n    { toSemigroup := toSemigroup\u271d, toOne := toOne\u271d, one_mul := one_mul\u271d, mul_one := mul_one\u271d, npow := npow\u271d,\n      npow_zero := npow_zero\u271d, npow_succ := npow_succ\u271d, mul_comm := mul_comm\u271d, mul_left_cancel := mul_left_cancel\u271d }"}, {"line": "congr <;> {\n    injection h with h'\n    injection h' }", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DivInvMonoid.ext {M : Type*} \u2983m\u2081 m\u2082 : DivInvMonoid M\u2984\n    (h_mul : (letI := m\u2081; HMul.hMul : M \u2192 M \u2192 M) = (letI := m\u2082; HMul.hMul : M \u2192 M \u2192 M))\n    (h_inv : (letI := m\u2081; Inv.inv : M \u2192 M) = (letI := m\u2082; Inv.inv : M \u2192 M)) : m\u2081 = m\u2082 := by\n  have h_mon := Monoid.ext h_mul\n  have h\u2081 : m\u2081.one = m\u2082.one := congr_arg (\u00b7.one) h_mon\n  let f : @MonoidHom M M m\u2081.toMulOneClass m\u2082.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h\u2081)\n      (fun x y => congr_fun (congr_fun h_mul x) y)\n  have : m\u2081.npow = m\u2082.npow := congr_arg (\u00b7.npow) h_mon\n  have : m\u2081.zpow = m\u2082.zpow := by\n    ext m x\n    exact @MonoidHom.map_zpow' M M m\u2081 m\u2082 f (congr_fun h_inv) x m\n  have : m\u2081.div = m\u2082.div := by\n    ext a b\n    exact @map_div' _ _\n      (F := @MonoidHom _ _ (_) _) _ (id _) _ inferInstance f (congr_fun h_inv) a b\n  rcases m\u2081 with @\u27e8_, \u27e8_\u27e9, \u27e8_\u27e9\u27e9\n  rcases m\u2082 with @\u27e8_, \u27e8_\u27e9, \u27e8_\u27e9\u27e9\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Ext.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nm\u2081 m\u2082 : DivInvMonoid M\nh_mul : HMul.hMul = HMul.hMul\nh_inv : Inv.inv = Inv.inv\n\u22a2 m\u2081 = m\u2082"}, {"line": "have h_mon := Monoid.ext h_mul", "tactic_state": "M : Type u_1\nm\u2081 m\u2082 : DivInvMonoid M\nh_mul : HMul.hMul = HMul.hMul\nh_inv : Inv.inv = Inv.inv\nh_mon : toMonoid = toMonoid\n\u22a2 m\u2081 = m\u2082"}, {"line": "have h\u2081 : m\u2081.one = m\u2082.one := congr_arg (\u00b7.one) h_mon", "tactic_state": "M : Type u_1\nm\u2081 m\u2082 : DivInvMonoid M\nh_mul : HMul.hMul = HMul.hMul\nh_inv : Inv.inv = Inv.inv\nh_mon : toMonoid = toMonoid\nh\u2081 : One.one = One.one\n\u22a2 m\u2081 = m\u2082"}, {"line": "let f : @MonoidHom M M m\u2081.toMulOneClass m\u2082.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h\u2081)\n      (fun x y => congr_fun (congr_fun h_mul x) y)", "tactic_state": "M : Type u_1\nm\u2081 m\u2082 : DivInvMonoid M\nh_mul : HMul.hMul = HMul.hMul\nh_inv : Inv.inv = Inv.inv\nh_mon : toMonoid = toMonoid\nh\u2081 : One.one = One.one\nf : M \u2192* M := sorry\n\u22a2 m\u2081 = m\u2082"}, {"line": "have : m\u2081.npow = m\u2082.npow := congr_arg (\u00b7.npow) h_mon", "tactic_state": "M : Type u_1\nm\u2081 m\u2082 : DivInvMonoid M\nh_mul : HMul.hMul = HMul.hMul\nh_inv : Inv.inv = Inv.inv\nh_mon : toMonoid = toMonoid\nh\u2081 : One.one = One.one\nf : M \u2192* M := sorry\nthis : Monoid.npow = Monoid.npow\n\u22a2 m\u2081 = m\u2082"}, {"line": "have : m\u2081.zpow = m\u2082.zpow := by\n    ext m x\n    exact @MonoidHom.map_zpow' M M m\u2081 m\u2082 f (congr_fun h_inv) x m", "tactic_state": "M : Type u_1\nm\u2081 m\u2082 : DivInvMonoid M\nh_mul : HMul.hMul = HMul.hMul\nh_inv : Inv.inv = Inv.inv\nh_mon : toMonoid = toMonoid\nh\u2081 : One.one = One.one\nf : M \u2192* M := sorry\nthis\u271d : Monoid.npow = Monoid.npow\nthis : DivInvMonoid.zpow = DivInvMonoid.zpow\n\u22a2 m\u2081 = m\u2082"}, {"line": "have : m\u2081.div = m\u2082.div := by\n    ext a b\n    exact @map_div' _ _\n      (F := @MonoidHom _ _ (_) _) _ (id _) _ inferInstance f (congr_fun h_inv) a b", "tactic_state": "M : Type u_1\nm\u2081 m\u2082 : DivInvMonoid M\nh_mul : HMul.hMul = HMul.hMul\nh_inv : Inv.inv = Inv.inv\nh_mon : toMonoid = toMonoid\nh\u2081 : One.one = One.one\nf : M \u2192* M := sorry\nthis\u271d\u00b9 : Monoid.npow = Monoid.npow\nthis\u271d : DivInvMonoid.zpow = DivInvMonoid.zpow\nthis : Div.div = Div.div\n\u22a2 m\u2081 = m\u2082"}, {"line": "rcases m\u2081 with @\u27e8_, \u27e8_\u27e9, \u27e8_\u27e9\u27e9", "tactic_state": "case mk.mk.mk\nM : Type u_1\nm\u2082 : DivInvMonoid M\ntoMonoid\u271d : Monoid M\nzpow\u271d : \u2124 \u2192 M \u2192 M\nzpow_zero'\u271d : \u2200 (a : M), zpow\u271d 0 a = 1\nzpow_succ'\u271d : \u2200 (n : \u2115) (a : M), zpow\u271d (\u2191n.succ) a = zpow\u271d (\u2191n) a * a\ninv\u271d : M \u2192 M\nzpow_neg'\u271d : \u2200 (n : \u2115) (a : M), zpow\u271d (Int.negSucc n) a = (zpow\u271d (\u2191n.succ) a)\u207b\u00b9\ndiv\u271d : M \u2192 M \u2192 M\ndiv_eq_mul_inv\u271d : \u2200 (a b : M), a / b = a * b\u207b\u00b9\nh_mul : HMul.hMul = HMul.hMul\nh_inv : Inv.inv = Inv.inv\nh_mon : toMonoid = toMonoid\nh\u2081 : One.one = One.one\nf : M \u2192* M := sorry\nthis\u271d\u00b9 : Monoid.npow = Monoid.npow\nthis\u271d : DivInvMonoid.zpow = DivInvMonoid.zpow\nthis : Div.div = Div.div\n\u22a2 { toMonoid := toMonoid\u271d, inv := inv\u271d, div := div\u271d, div_eq_mul_inv := div_eq_mul_inv\u271d, zpow := zpow\u271d,\n      zpow_zero' := zpow_zero'\u271d, zpow_succ' := zpow_succ'\u271d, zpow_neg' := zpow_neg'\u271d } =\n    m\u2082"}, {"line": "rcases m\u2082 with @\u27e8_, \u27e8_\u27e9, \u27e8_\u27e9\u27e9", "tactic_state": "case mk.mk.mk.mk.mk.mk\nM : Type u_1\ntoMonoid\u271d\u00b9 : Monoid M\nzpow\u271d\u00b9 : \u2124 \u2192 M \u2192 M\nzpow_zero'\u271d\u00b9 : \u2200 (a : M), zpow\u271d\u00b9 0 a = 1\nzpow_succ'\u271d\u00b9 : \u2200 (n : \u2115) (a : M), zpow\u271d\u00b9 (\u2191n.succ) a = zpow\u271d\u00b9 (\u2191n) a * a\ninv\u271d\u00b9 : M \u2192 M\nzpow_neg'\u271d\u00b9 : \u2200 (n : \u2115) (a : M), zpow\u271d\u00b9 (Int.negSucc n) a = (zpow\u271d\u00b9 (\u2191n.succ) a)\u207b\u00b9\ndiv\u271d\u00b9 : M \u2192 M \u2192 M\ndiv_eq_mul_inv\u271d\u00b9 : \u2200 (a b : M), a / b = a * b\u207b\u00b9\ntoMonoid\u271d : Monoid M\nzpow\u271d : \u2124 \u2192 M \u2192 M\nzpow_zero'\u271d : \u2200 (a : M), zpow\u271d 0 a = 1\nzpow_succ'\u271d : \u2200 (n : \u2115) (a : M), zpow\u271d (\u2191n.succ) a = zpow\u271d (\u2191n) a * a\ninv\u271d : M \u2192 M\nzpow_neg'\u271d : \u2200 (n : \u2115) (a : M), zpow\u271d (Int.negSucc n) a = (zpow\u271d (\u2191n.succ) a)\u207b\u00b9\ndiv\u271d : M \u2192 M \u2192 M\ndiv_eq_mul_inv\u271d : \u2200 (a b : M), a / b = a * b\u207b\u00b9\nh_mul : HMul.hMul = HMul.hMul\nh_inv : Inv.inv = Inv.inv\nh_mon : toMonoid = toMonoid\nh\u2081 : One.one = One.one\nf : M \u2192* M := sorry\nthis\u271d\u00b9 : Monoid.npow = Monoid.npow\nthis\u271d : DivInvMonoid.zpow = DivInvMonoid.zpow\nthis : Div.div = Div.div\n\u22a2 { toMonoid := toMonoid\u271d\u00b9, inv := inv\u271d\u00b9, div := div\u271d\u00b9, div_eq_mul_inv := div_eq_mul_inv\u271d\u00b9, zpow := zpow\u271d\u00b9,\n      zpow_zero' := zpow_zero'\u271d\u00b9, zpow_succ' := zpow_succ'\u271d\u00b9, zpow_neg' := zpow_neg'\u271d\u00b9 } =\n    { toMonoid := toMonoid\u271d, inv := inv\u271d, div := div\u271d, div_eq_mul_inv := div_eq_mul_inv\u271d, zpow := zpow\u271d,\n      zpow_zero' := zpow_zero'\u271d, zpow_succ' := zpow_succ'\u271d, zpow_neg' := zpow_neg'\u271d }"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Group.ext {G : Type*} \u2983g\u2081 g\u2082 : Group G\u2984\n    (h_mul : (letI := g\u2081; HMul.hMul : G \u2192 G \u2192 G) = (letI := g\u2082; HMul.hMul : G \u2192 G \u2192 G)) :\n    g\u2081 = g\u2082 := by\n  have h\u2081 : g\u2081.one = g\u2082.one := congr_arg (\u00b7.one) (Monoid.ext h_mul)\n  let f : @MonoidHom G G g\u2081.toMulOneClass g\u2082.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h\u2081)\n      (fun x y => congr_fun (congr_fun h_mul x) y)\n  exact\n    Group.toDivInvMonoid_injective\n      (DivInvMonoid.ext h_mul\n        (funext <| @MonoidHom.map_inv G G g\u2081 g\u2082.toDivisionMonoid f))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Ext.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ng\u2081 g\u2082 : Group G\nh_mul : HMul.hMul = HMul.hMul\n\u22a2 g\u2081 = g\u2082"}, {"line": "have h\u2081 : g\u2081.one = g\u2082.one := congr_arg (\u00b7.one) (Monoid.ext h_mul)", "tactic_state": "G : Type u_1\ng\u2081 g\u2082 : Group G\nh_mul : HMul.hMul = HMul.hMul\nh\u2081 : One.one = One.one\n\u22a2 g\u2081 = g\u2082"}, {"line": "let f : @MonoidHom G G g\u2081.toMulOneClass g\u2082.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h\u2081)\n      (fun x y => congr_fun (congr_fun h_mul x) y)", "tactic_state": "G : Type u_1\ng\u2081 g\u2082 : Group G\nh_mul : HMul.hMul = HMul.hMul\nh\u2081 : One.one = One.one\nf : G \u2192* G := sorry\n\u22a2 g\u2081 = g\u2082"}, {"line": "exact\n    Group.toDivInvMonoid_injective\n      (DivInvMonoid.ext h_mul\n        (funext <| @MonoidHom.map_inv G G g\u2081 g\u2082.toDivisionMonoid f))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mulIndicator_eq_one_or_self (s : Set \u03b1) (f : \u03b1 \u2192 M) (a : \u03b1) :\n    mulIndicator s f a = 1 \u2228 mulIndicator s f a = f a := by\n  by_cases h : a \u2208 s\n  \u00b7 exact Or.inr (mulIndicator_of_mem h f)\n  \u00b7 exact Or.inl (mulIndicator_of_not_mem h f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Indicator.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 M N : Type*}", "[One M] [One N] {s t : Set \u03b1} {f g : \u03b1 \u2192 M} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_3\ninst\u271d : One M\nx\u271d : Sort u_5\nmulIndicator : x\u271d\ns : Set \u03b1\nf : \u03b1 \u2192 M\na : \u03b1\n\u22a2 sorry = 1 \u2228 sorry = f a"}, {"line": "by_cases h : a \u2208 s", "tactic_state": "case pos\n\u03b1 : Type u_1\nM : Type u_3\ninst\u271d : One M\nx\u271d : Sort u_5\nmulIndicator : x\u271d\ns : Set \u03b1\nf : \u03b1 \u2192 M\na : \u03b1\nh : a \u2208 s\n\u22a2 sorry = 1 \u2228 sorry = f a\n---\ncase neg\n\u03b1 : Type u_1\nM : Type u_3\ninst\u271d : One M\nx\u271d : Sort u_5\nmulIndicator : x\u271d\ns : Set \u03b1\nf : \u03b1 \u2192 M\na : \u03b1\nh : a \u2209 s\n\u22a2 sorry = 1 \u2228 sorry = f a"}, {"line": "\u00b7 exact Or.inr (mulIndicator_of_mem h f)", "tactic_state": "case neg\n\u03b1 : Type u_1\nM : Type u_3\ninst\u271d : One M\nx\u271d : Sort u_5\nmulIndicator : x\u271d\ns : Set \u03b1\nf : \u03b1 \u2192 M\na : \u03b1\nh : a \u2209 s\n\u22a2 sorry = 1 \u2228 sorry = f a"}, {"line": "\u00b7 exact Or.inl (mulIndicator_of_not_mem h f)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_mulIndicator (h : M \u2192 \u03b2) (f : \u03b1 \u2192 M) {s : Set \u03b1} {x : \u03b1} [DecidablePred (\u00b7 \u2208 s)] :\n    h (s.mulIndicator f x) = s.piecewise (h \u2218 f) (const \u03b1 (h 1)) x := by\n  letI := Classical.decPred (\u00b7 \u2208 s)\n  convert s.apply_piecewise f (const \u03b1 1) (fun _ => h) (x := x) using 2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Indicator.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 M N : Type*}", "[One M] [One N] {s t : Set \u03b1} {f g : \u03b1 \u2192 M} {a : \u03b1}", "(M)", "{M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : One M\nh : M \u2192 \u03b2\nf : \u03b1 \u2192 M\ns : Set \u03b1\nx : \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\n\u22a2 h (s.mulIndicator f x) = s.piecewise (h \u2218 f) (const \u03b1 (h 1)) x"}, {"line": "letI := Classical.decPred (\u00b7 \u2208 s)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : One M\nh : M \u2192 \u03b2\nf : \u03b1 \u2192 M\ns : Set \u03b1\nx : \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nthis : DecidablePred fun x => x \u2208 s := Classical.decPred fun x => x \u2208 s\n\u22a2 h (s.mulIndicator f x) = s.piecewise (h \u2218 f) (const \u03b1 (h 1)) x"}, {"line": "convert s.apply_piecewise f (const \u03b1 1) (fun _ => h) (x := x) using 2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mulIndicator_preimage_of_not_mem (s : Set \u03b1) (f : \u03b1 \u2192 M) {t : Set M} (ht : (1 : M) \u2209 t) :\n    mulIndicator s f \u207b\u00b9' t = f \u207b\u00b9' t \u2229 s := by\n  simp [mulIndicator_preimage, Pi.one_def, Set.preimage_const_of_not_mem ht]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Indicator.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 M N : Type*}", "[One M] [One N] {s t : Set \u03b1} {f g : \u03b1 \u2192 M} {a : \u03b1}", "(M)", "{M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_3\ninst\u271d : One M\nx\u271d : Sort u_5\nmulIndicator : x\u271d\ns : Set \u03b1\nf : \u03b1 \u2192 M\nt : Set M\nht : 1 \u2209 t\n\u22a2 sorry \u207b\u00b9' t = f \u207b\u00b9' t \u2229 s"}, {"line": "simp [mulIndicator_preimage, Pi.one_def, Set.preimage_const_of_not_mem ht]", "tactic_state": "\u03b1 : Type u_1\nM : Type u_3\ninst\u271d : One M\nx\u271d : Sort u_5\nmulIndicator : x\u271d\ns : Set \u03b1\nf : \u03b1 \u2192 M\nt : Set M\nht : 1 \u2209 t\n\u22a2 sorry () \u207b\u00b9' t = f \u207b\u00b9' t \u2229 s"}]}
{"declaration": "theorem mulIndicator_mul_compl_eq_piecewise [DecidablePred (\u00b7 \u2208 s)] (f g : \u03b1 \u2192 M) :\n    s.mulIndicator f * s\u1d9c.mulIndicator g = s.piecewise f g := by\n  ext x\n  by_cases h : x \u2208 s\n  \u00b7 rw [piecewise_eq_of_mem _ _ _ h, Pi.mul_apply, Set.mulIndicator_of_mem h,\n      Set.mulIndicator_of_not_mem (Set.not_mem_compl_iff.2 h), mul_one]\n  \u00b7 rw [piecewise_eq_of_not_mem _ _ _ h, Pi.mul_apply, Set.mulIndicator_of_not_mem h,\n      Set.mulIndicator_of_mem (Set.mem_compl h), one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Indicator.lean", "context": {"open": ["Function", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 M N : Type*}", "[One M] [One N] {s t : Set \u03b1} {f g : \u03b1 \u2192 M} {a : \u03b1}", "(M)", "{M}", "[MulOneClass M] {s t : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : MulOneClass M\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nf g : \u03b1 \u2192 M\n\u22a2 s.mulIndicator f * s\u1d9c.mulIndicator g = s.piecewise f g"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : MulOneClass M\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nf g : \u03b1 \u2192 M\nx : \u03b1\n\u22a2 (s.mulIndicator f * s\u1d9c.mulIndicator g) x = s.piecewise f g x"}, {"line": "by_cases h : x \u2208 s", "tactic_state": "case pos\n\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : MulOneClass M\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nf g : \u03b1 \u2192 M\nx : \u03b1\nh : x \u2208 s\n\u22a2 (s.mulIndicator f * s\u1d9c.mulIndicator g) x = s.piecewise f g x\n---\ncase neg\n\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : MulOneClass M\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nf g : \u03b1 \u2192 M\nx : \u03b1\nh : x \u2209 s\n\u22a2 (s.mulIndicator f * s\u1d9c.mulIndicator g) x = s.piecewise f g x"}, {"line": "\u00b7 rw [piecewise_eq_of_mem _ _ _ h, Pi.mul_apply, Set.mulIndicator_of_mem h,\n      Set.mulIndicator_of_not_mem (Set.not_mem_compl_iff.2 h), mul_one]", "tactic_state": "case neg\n\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : MulOneClass M\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nf g : \u03b1 \u2192 M\nx : \u03b1\nh : x \u2209 s\n\u22a2 (s.mulIndicator f * s\u1d9c.mulIndicator g) x = s.piecewise f g x"}, {"line": "\u00b7 rw [piecewise_eq_of_not_mem _ _ _ h, Pi.mul_apply, Set.mulIndicator_of_not_mem h,\n      Set.mulIndicator_of_mem (Set.mem_compl h), one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem op_div [DivInvMonoid \u03b1] (x y : \u03b1) : op (x / y) = (op y)\u207b\u00b9 * op x := by simp [div_eq_mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Opposite.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Monoid \u03b1]", "[DivInvMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : DivInvMonoid \u03b1\nx\u271d : Sort u_2\nop : x\u271d\ninst\u271d : DivInvMonoid \u03b1\nx y : \u03b1\n\u22a2 sorry = sorry\u207b\u00b9 * sorry"}, {"line": "simp [div_eq_mul_inv]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : DivInvMonoid \u03b1\nx\u271d : Sort u_2\nop : x\u271d\ninst\u271d : DivInvMonoid \u03b1\nx y : \u03b1\n\u22a2 sorry () = (sorry ())\u207b\u00b9 * sorry ()"}]}
{"declaration": "theorem mulSupport_curry (f : \u03b1 \u00d7 \u03b2 \u2192 M) :\n    (mulSupport f.curry) = (mulSupport f).image Prod.fst := by\n  simp [mulSupport, funext_iff, image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Support.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 A B M M' N P G : Type*}", "[One M] [One N] [One P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nM : Type u_5\ninst\u271d : One M\nx\u271d : Sort u_10\nmulSupport : x\u271d\nf : \u03b1 \u00d7 \u03b2 \u2192 M\n\u22a2 sorry = sorry"}, {"line": "simp [mulSupport, funext_iff, image]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nM : Type u_5\ninst\u271d : One M\nx\u271d : Sort u_10\nmulSupport : x\u271d\nf : \u03b1 \u00d7 \u03b2 \u2192 M\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem mulSupport_mulSingle_one : mulSupport (mulSingle a (1 : B)) = \u2205 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Support.lean", "context": {"open": ["Set", "Function", "Function"], "variables": ["{\u03b1 \u03b2 A B M M' N P G : Type*}", "[One M] [One N] [One P]", "[DivisionMonoid G] (f g : \u03b1 \u2192 G)", "{\u03b1 \u03b2 M : Type*} [One M] {f : \u03b1 \u2192 M}", "{A : Type*} {B : Type*} [DecidableEq A] [One B] {a : A} {b : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_15\nmulSingle : x\u271d\n\u22a2 mulSupport sorry = \u2205"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_15\nmulSingle : x\u271d\n\u22a2 mulSupport (sorry ()) = \u2205"}]}
{"declaration": "lemma smul_div_assoc [DivInvMonoid \u03b2] [SMul \u03b1 \u03b2] [IsScalarTower \u03b1 \u03b2 \u03b2] (r : \u03b1) (x y : \u03b2) :\n    r \u2022 x / y = r \u2022 (x / y) := by simp [div_eq_mul_inv, smul_mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Action/Defs.lean", "context": {"open": ["Function (Injective Surjective)"], "variables": ["{M N G H \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[SMul M \u03b1]", "(\u03b1)", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u00b2 : DivInvMonoid \u03b2\ninst\u271d\u00b9 : SMul \u03b1 \u03b2\ninst\u271d : IsScalarTower \u03b1 \u03b2 \u03b2\nr : \u03b1\nx y : \u03b2\n\u22a2 r \u2022 x / y = r \u2022 (x / y)"}, {"line": "simp [div_eq_mul_inv, smul_mul_assoc]", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u00b2 : DivInvMonoid \u03b2\ninst\u271d\u00b9 : SMul \u03b1 \u03b2\ninst\u271d : IsScalarTower \u03b1 \u03b2 \u03b2\nr : \u03b1\nx y : \u03b2\n\u22a2 r \u2022 x * y\u207b\u00b9 = r \u2022 (x * y\u207b\u00b9)"}]}
{"declaration": "lemma smul_smul_smul_comm [SMul \u03b1 \u03b2] [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b4] [SMul \u03b1 \u03b4] [SMul \u03b3 \u03b4]\n    [IsScalarTower \u03b1 \u03b2 \u03b4] [IsScalarTower \u03b1 \u03b3 \u03b4] [SMulCommClass \u03b2 \u03b3 \u03b4] (a : \u03b1) (b : \u03b2) (c : \u03b3)\n    (d : \u03b4) : (a \u2022 b) \u2022 c \u2022 d = (a \u2022 c) \u2022 b \u2022 d := by rw [smul_assoc, smul_assoc, smul_comm b]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Action/Defs.lean", "context": {"open": ["Function (Injective Surjective)"], "variables": ["{M N G H \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[SMul M \u03b1]", "(\u03b1)", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\n\u03b3 : Type u_7\n\u03b4 : Type u_8\ninst\u271d\u2077 : SMul \u03b1 \u03b2\ninst\u271d\u2076 : SMul \u03b1 \u03b3\ninst\u271d\u2075 : SMul \u03b2 \u03b4\ninst\u271d\u2074 : SMul \u03b1 \u03b4\ninst\u271d\u00b3 : SMul \u03b3 \u03b4\ninst\u271d\u00b2 : IsScalarTower \u03b1 \u03b2 \u03b4\ninst\u271d\u00b9 : IsScalarTower \u03b1 \u03b3 \u03b4\ninst\u271d : SMulCommClass \u03b2 \u03b3 \u03b4\na : \u03b1\nb : \u03b2\nc : \u03b3\nd : \u03b4\n\u22a2 (a \u2022 b) \u2022 c \u2022 d = (a \u2022 c) \u2022 b \u2022 d"}, {"line": "rw [smul_assoc, smul_assoc, smul_comm b]", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\n\u03b3 : Type u_7\n\u03b4 : Type u_8\ninst\u271d\u2077 : SMul \u03b1 \u03b2\ninst\u271d\u2076 : SMul \u03b1 \u03b3\ninst\u271d\u2075 : SMul \u03b2 \u03b4\ninst\u271d\u2074 : SMul \u03b1 \u03b4\ninst\u271d\u00b3 : SMul \u03b3 \u03b4\ninst\u271d\u00b2 : IsScalarTower \u03b1 \u03b2 \u03b4\ninst\u271d\u00b9 : IsScalarTower \u03b1 \u03b3 \u03b4\ninst\u271d : SMulCommClass \u03b2 \u03b3 \u03b4\na : \u03b1\nb : \u03b2\nc : \u03b3\nd : \u03b4\n\u22a2 SMulCommClass \u03b2 \u03b3 \u03b4\n---\n\u03b1 : Type u_5\n\u03b2 : Type u_6\n\u03b3 : Type u_7\n\u03b4 : Type u_8\ninst\u271d\u2077 : SMul \u03b1 \u03b2\ninst\u271d\u2076 : SMul \u03b1 \u03b3\ninst\u271d\u2075 : SMul \u03b2 \u03b4\ninst\u271d\u2074 : SMul \u03b1 \u03b4\ninst\u271d\u00b3 : SMul \u03b3 \u03b4\ninst\u271d\u00b2 : IsScalarTower \u03b1 \u03b2 \u03b4\ninst\u271d\u00b9 : IsScalarTower \u03b1 \u03b3 \u03b4\ninst\u271d : SMulCommClass \u03b2 \u03b3 \u03b4\na : \u03b1\nb : \u03b2\nc : \u03b3\nd : \u03b4\n\u22a2 SMul \u03b1 \u03b4\n---\n\u03b1 : Type u_5\n\u03b2 : Type u_6\n\u03b3 : Type u_7\n\u03b4 : Type u_8\ninst\u271d\u2077 : SMul \u03b1 \u03b2\ninst\u271d\u2076 : SMul \u03b1 \u03b3\ninst\u271d\u2075 : SMul \u03b2 \u03b4\ninst\u271d\u2074 : SMul \u03b1 \u03b4\ninst\u271d\u00b3 : SMul \u03b3 \u03b4\ninst\u271d\u00b2 : IsScalarTower \u03b1 \u03b2 \u03b4\ninst\u271d\u00b9 : IsScalarTower \u03b1 \u03b3 \u03b4\ninst\u271d : SMulCommClass \u03b2 \u03b3 \u03b4\na : \u03b1\nb : \u03b2\nc : \u03b3\nd : \u03b4\n\u22a2 IsScalarTower \u03b1 \u03b3 \u03b4\n---\n\u03b1 : Type u_5\n\u03b2 : Type u_6\n\u03b3 : Type u_7\n\u03b4 : Type u_8\ninst\u271d\u2077 : SMul \u03b1 \u03b2\ninst\u271d\u2076 : SMul \u03b1 \u03b3\ninst\u271d\u2075 : SMul \u03b2 \u03b4\ninst\u271d\u2074 : SMul \u03b1 \u03b4\ninst\u271d\u00b3 : SMul \u03b3 \u03b4\ninst\u271d\u00b2 : IsScalarTower \u03b1 \u03b2 \u03b4\ninst\u271d\u00b9 : IsScalarTower \u03b1 \u03b3 \u03b4\ninst\u271d : SMulCommClass \u03b2 \u03b3 \u03b4\na : \u03b1\nb : \u03b2\nc : \u03b3\nd : \u03b4\n\u22a2 IsScalarTower \u03b1 \u03b2 \u03b4"}]}
{"declaration": "lemma inv_smul_smul (g : G) (a : \u03b1) : g\u207b\u00b9 \u2022 g \u2022 a = a := by rw [smul_smul, inv_mul_cancel, one_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Action/Defs.lean", "context": {"open": ["Function (Injective Surjective)"], "variables": ["{M N G H \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[SMul M \u03b1]", "(\u03b1)", "{\u03b1}", "[SMul M \u03b1]", "[Monoid M] [MulAction M \u03b1] {a : M}", "(M)", "{M}", "(M)", "{M}", "[Monoid N] [MulAction M N] [IsScalarTower M N N] [SMulCommClass M N N]", "[Group G] [MulAction G \u03b1] {g : G} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\n\u03b1 : Type u_5\ninst\u271d\u00b9 : Group G\ninst\u271d : MulAction G \u03b1\ng : G\na : \u03b1\n\u22a2 g\u207b\u00b9 \u2022 g \u2022 a = a"}, {"line": "rw [smul_smul, inv_mul_cancel, one_smul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_inv_smul (g : G) (a : \u03b1) : g \u2022 g\u207b\u00b9 \u2022 a = a := by rw [smul_smul, mul_inv_cancel, one_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Action/Defs.lean", "context": {"open": ["Function (Injective Surjective)"], "variables": ["{M N G H \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[SMul M \u03b1]", "(\u03b1)", "{\u03b1}", "[SMul M \u03b1]", "[Monoid M] [MulAction M \u03b1] {a : M}", "(M)", "{M}", "(M)", "{M}", "[Monoid N] [MulAction M N] [IsScalarTower M N N] [SMulCommClass M N N]", "[Group G] [MulAction G \u03b1] {g : G} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\n\u03b1 : Type u_5\ninst\u271d\u00b9 : Group G\ninst\u271d : MulAction G \u03b1\ng : G\na : \u03b1\n\u22a2 g \u2022 g\u207b\u00b9 \u2022 a = a"}, {"line": "rw [smul_smul, mul_inv_cancel, one_smul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_zpow (g : G) (a : H) (n : \u2124) : (g \u2022 a) ^ n = g ^ n \u2022 a ^ n := by\n  cases n <;> simp [smul_pow, smul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Action/Defs.lean", "context": {"open": ["Function (Injective Surjective)"], "variables": ["{M N G H \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[SMul M \u03b1]", "(\u03b1)", "{\u03b1}", "[SMul M \u03b1]", "[Monoid M] [MulAction M \u03b1] {a : M}", "(M)", "{M}", "(M)", "{M}", "[Monoid N] [MulAction M N] [IsScalarTower M N N] [SMulCommClass M N N]", "[Group G] [MulAction G \u03b1] {g : G} {a b : \u03b1}", "[Mul H] [MulAction G H] [SMulCommClass G H H] [IsScalarTower G H H] {a b : H}", "[Group H] [MulAction G H] [SMulCommClass G H H] [IsScalarTower G H H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\nH : Type u_4\ninst\u271d\u2078 : Group G\ninst\u271d\u2077 : Mul H\ninst\u271d\u2076 : MulAction G H\ninst\u271d\u2075 : SMulCommClass G H H\ninst\u271d\u2074 : IsScalarTower G H H\ninst\u271d\u00b3 : Group H\ninst\u271d\u00b2 : MulAction G H\ninst\u271d\u00b9 : SMulCommClass G H H\ninst\u271d : IsScalarTower G H H\ng : G\na : H\nn : \u2124\n\u22a2 (g \u2022 a) ^ n = g ^ n \u2022 a ^ n"}, {"line": "cases n <;> simp [smul_pow, smul_inv]", "tactic_state": "case ofNat\nG : Type u_3\nH : Type u_4\ninst\u271d\u2078 : Group G\ninst\u271d\u2077 : Mul H\ninst\u271d\u2076 : MulAction G H\ninst\u271d\u2075 : SMulCommClass G H H\ninst\u271d\u2074 : IsScalarTower G H H\ninst\u271d\u00b3 : Group H\ninst\u271d\u00b2 : MulAction G H\ninst\u271d\u00b9 : SMulCommClass G H H\ninst\u271d : IsScalarTower G H H\ng : G\na : H\na\u271d : \u2115\n\u22a2 (g \u2022 a) ^ a\u271d = g ^ a\u271d \u2022 a ^ a\u271d\n---\ncase negSucc\nG : Type u_3\nH : Type u_4\ninst\u271d\u2078 : Group G\ninst\u271d\u2077 : Mul H\ninst\u271d\u2076 : MulAction G H\ninst\u271d\u2075 : SMulCommClass G H H\ninst\u271d\u2074 : IsScalarTower G H H\ninst\u271d\u00b3 : Group H\ninst\u271d\u00b2 : MulAction G H\ninst\u271d\u00b9 : SMulCommClass G H H\ninst\u271d : IsScalarTower G H H\ng : G\na : H\na\u271d : \u2115\n\u22a2 ((g \u2022 a) ^ (a\u271d + 1))\u207b\u00b9 = (g ^ (a\u271d + 1))\u207b\u00b9 \u2022 (a ^ (a\u271d + 1))\u207b\u00b9"}]}
{"declaration": "lemma smul_one_smul {M} (N) [Monoid N] [SMul M N] [MulAction N \u03b1] [SMul M \u03b1]\n    [IsScalarTower M N \u03b1] (x : M) (y : \u03b1) : (x \u2022 (1 : N)) \u2022 y = x \u2022 y := by\n  rw [smul_assoc]\n  rw [one_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Action/Defs.lean", "context": {"open": ["Function (Injective Surjective)"], "variables": ["{M N G H \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[SMul M \u03b1]", "(\u03b1)", "{\u03b1}", "[SMul M \u03b1]", "[Monoid M] [MulAction M \u03b1] {a : M}", "(M)", "{M}", "(M)", "{M}", "[Monoid N] [MulAction M N] [IsScalarTower M N N] [SMulCommClass M N N]", "[Group G] [MulAction G \u03b1] {g : G} {a b : \u03b1}", "[Mul H] [MulAction G H] [SMulCommClass G H H] [IsScalarTower G H H] {a b : H}", "[Group H] [MulAction G H] [SMulCommClass G H H] [IsScalarTower G H H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\nM : Type u_9\nN : Type u_10\ninst\u271d\u2074 : Monoid N\ninst\u271d\u00b3 : SMul M N\ninst\u271d\u00b2 : MulAction N \u03b1\ninst\u271d\u00b9 : SMul M \u03b1\ninst\u271d : IsScalarTower M N \u03b1\nx : M\ny : \u03b1\n\u22a2 (x \u2022 1) \u2022 y = x \u2022 y"}, {"line": "rw [smul_assoc]", "tactic_state": "\u03b1 : Type u_5\nM : Type u_9\nN : Type u_10\ninst\u271d\u2074 : Monoid N\ninst\u271d\u00b3 : SMul M N\ninst\u271d\u00b2 : MulAction N \u03b1\ninst\u271d\u00b9 : SMul M \u03b1\ninst\u271d : IsScalarTower M N \u03b1\nx : M\ny : \u03b1\n\u22a2 x \u2022 1 \u2022 y = x \u2022 y\n---\n\u03b1 : Type u_5\nM : Type u_9\nN : Type u_10\ninst\u271d\u2074 : Monoid N\ninst\u271d\u00b3 : SMul M N\ninst\u271d\u00b2 : MulAction N \u03b1\ninst\u271d\u00b9 : SMul M \u03b1\ninst\u271d : IsScalarTower M N \u03b1\nx : M\ny : \u03b1\n\u22a2 SMul M \u03b1\n---\n\u03b1 : Type u_5\nM : Type u_9\nN : Type u_10\ninst\u271d\u2074 : Monoid N\ninst\u271d\u00b3 : SMul M N\ninst\u271d\u00b2 : MulAction N \u03b1\ninst\u271d\u00b9 : SMul M \u03b1\ninst\u271d : IsScalarTower M N \u03b1\nx : M\ny : \u03b1\n\u22a2 IsScalarTower M N \u03b1"}, {"line": "rw [one_smul]", "tactic_state": "\u03b1 : Type u_5\nM : Type u_9\nN : Type u_10\ninst\u271d\u2074 : Monoid N\ninst\u271d\u00b3 : SMul M N\ninst\u271d\u00b2 : MulAction N \u03b1\ninst\u271d\u00b9 : SMul M \u03b1\ninst\u271d : IsScalarTower M N \u03b1\nx : M\ny : \u03b1\n\u22a2 IsScalarTower M N \u03b1"}]}
{"declaration": "lemma smul_one_mul {M N} [MulOneClass N] [SMul M N] [IsScalarTower M N N] (x : M) (y : N) :\n    x \u2022 (1 : N) * y = x \u2022 y := by rw [smul_mul_assoc, one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Action/Defs.lean", "context": {"open": ["Function (Injective Surjective)"], "variables": ["{M N G H \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[SMul M \u03b1]", "(\u03b1)", "{\u03b1}", "[SMul M \u03b1]", "[Monoid M] [MulAction M \u03b1] {a : M}", "(M)", "{M}", "(M)", "{M}", "[Monoid N] [MulAction M N] [IsScalarTower M N N] [SMulCommClass M N N]", "[Group G] [MulAction G \u03b1] {g : G} {a b : \u03b1}", "[Mul H] [MulAction G H] [SMulCommClass G H H] [IsScalarTower G H H] {a b : H}", "[Group H] [MulAction G H] [SMulCommClass G H H] [IsScalarTower G H H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_9\nN : Type u_10\ninst\u271d\u00b2 : MulOneClass N\ninst\u271d\u00b9 : SMul M N\ninst\u271d : IsScalarTower M N N\nx : M\ny : N\n\u22a2 x \u2022 1 * y = x \u2022 y"}, {"line": "rw [smul_mul_assoc, one_mul]", "tactic_state": "M : Type u_9\nN : Type u_10\ninst\u271d\u00b2 : MulOneClass N\ninst\u271d\u00b9 : SMul M N\ninst\u271d : IsScalarTower M N N\nx : M\ny : N\n\u22a2 IsScalarTower M N N"}]}
{"declaration": "lemma mul_smul_one {M N} [MulOneClass N] [SMul M N] [SMulCommClass M N N] (x : M) (y : N) :\n    y * x \u2022 (1 : N) = x \u2022 y := by rw [\u2190 smul_eq_mul, \u2190 smul_comm, smul_eq_mul, mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Action/Defs.lean", "context": {"open": ["Function (Injective Surjective)"], "variables": ["{M N G H \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[SMul M \u03b1]", "(\u03b1)", "{\u03b1}", "[SMul M \u03b1]", "[Monoid M] [MulAction M \u03b1] {a : M}", "(M)", "{M}", "(M)", "{M}", "[Monoid N] [MulAction M N] [IsScalarTower M N N] [SMulCommClass M N N]", "[Group G] [MulAction G \u03b1] {g : G} {a b : \u03b1}", "[Mul H] [MulAction G H] [SMulCommClass G H H] [IsScalarTower G H H] {a b : H}", "[Group H] [MulAction G H] [SMulCommClass G H H] [IsScalarTower G H H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_9\nN : Type u_10\ninst\u271d\u00b2 : MulOneClass N\ninst\u271d\u00b9 : SMul M N\ninst\u271d : SMulCommClass M N N\nx : M\ny : N\n\u22a2 y * x \u2022 1 = x \u2022 y"}, {"line": "rw [\u2190 smul_eq_mul, \u2190 smul_comm, smul_eq_mul, mul_one]", "tactic_state": "M : Type u_9\nN : Type u_10\ninst\u271d\u00b2 : MulOneClass N\ninst\u271d\u00b9 : SMul M N\ninst\u271d : SMulCommClass M N N\nx : M\ny : N\n\u22a2 SMulCommClass M N N"}]}
{"declaration": "lemma mem_smul_set_inv {s : Set \u03b1} : a \u2208 b \u2022 s\u207b\u00b9 \u2194 b \u2208 a \u2022 s := by\n  simp [mem_smul_set_iff_inv_smul_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Action/Pointwise/Set/Basic.lean", "context": {"open": ["Function MulOpposite", "scoped Pointwise", "scoped RightActions in", "scoped RightActions", "scoped RightActions in"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Mul \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "[Semigroup \u03b1]", "[Mul \u03b1] [IsLeftCancelMul \u03b1] {s t : Set \u03b1}", "[Group \u03b1] [MulAction \u03b1 \u03b2] {s t A B : Set \u03b2} {a b : \u03b1} {x : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u2074 : Mul \u03b1\ninst\u271d\u00b3 : Semigroup \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : IsLeftCancelMul \u03b1\ninst\u271d : Group \u03b1\na b : \u03b1\ns : Set \u03b1\n\u22a2 a \u2208 b \u2022 s\u207b\u00b9 \u2194 b \u2208 a \u2022 s"}, {"line": "simp [mem_smul_set_iff_inv_smul_mem]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma disjoint_smul_set_left : Disjoint (a \u2022 s) t \u2194 Disjoint s (a\u207b\u00b9 \u2022 t) := by\n  simpa using disjoint_smul_set (a := a) (t := a\u207b\u00b9 \u2022 t)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Action/Pointwise/Set/Basic.lean", "context": {"open": ["Function MulOpposite", "scoped Pointwise", "scoped RightActions in", "scoped RightActions", "scoped RightActions in", "scoped symmDiff in"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Mul \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "[Semigroup \u03b1]", "[Mul \u03b1] [IsLeftCancelMul \u03b1] {s t : Set \u03b1}", "[Group \u03b1] [MulAction \u03b1 \u03b2] {s t A B : Set \u03b2} {a b : \u03b1} {x : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_3\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 : Semigroup \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : IsLeftCancelMul \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : MulAction \u03b1 \u03b2\ns t : Set \u03b2\na : \u03b1\n\u22a2 Disjoint (a \u2022 s) t \u2194 Disjoint s (a\u207b\u00b9 \u2022 t)"}, {"line": "simpa using disjoint_smul_set (a := a) (t := a\u207b\u00b9 \u2022 t)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma disjoint_smul_set_right : Disjoint s (a \u2022 t) \u2194 Disjoint (a\u207b\u00b9 \u2022 s) t := by\n  simpa using disjoint_smul_set (a := a) (s := a\u207b\u00b9 \u2022 s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Action/Pointwise/Set/Basic.lean", "context": {"open": ["Function MulOpposite", "scoped Pointwise", "scoped RightActions in", "scoped RightActions", "scoped RightActions in", "scoped symmDiff in"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Mul \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "[Semigroup \u03b1]", "[Mul \u03b1] [IsLeftCancelMul \u03b1] {s t : Set \u03b1}", "[Group \u03b1] [MulAction \u03b1 \u03b2] {s t A B : Set \u03b2} {a b : \u03b1} {x : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_3\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 : Semigroup \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : IsLeftCancelMul \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : MulAction \u03b1 \u03b2\ns t : Set \u03b2\na : \u03b1\n\u22a2 Disjoint s (a \u2022 t) \u2194 Disjoint (a\u207b\u00b9 \u2022 s) t"}, {"line": "simpa using disjoint_smul_set (a := a) (s := a\u207b\u00b9 \u2022 s)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_graphOn (x : \u03b1 \u00d7 \u03b2) (s : Set \u03b1) (f : F) :\n    x \u2022 s.graphOn f = (x.1 \u2022 s).graphOn fun a \u21a6 x.2 / f x.1 * f a := by\n  ext \u27e8a, b\u27e9\n  simp [mem_smul_set_iff_inv_smul_mem, Prod.ext_iff, and_comm (a := _ = a), inv_mul_eq_iff_eq_mul,\n    mul_left_comm _ _\u207b\u00b9, eq_inv_mul_iff_mul_eq, \u2190 mul_div_right_comm, div_eq_iff_eq_mul, mul_comm b]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Action/Pointwise/Set/Basic.lean", "context": {"open": ["Function MulOpposite", "scoped Pointwise", "scoped RightActions in", "scoped RightActions", "scoped RightActions in", "scoped symmDiff in"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Mul \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "[Semigroup \u03b1]", "[Mul \u03b1] [IsLeftCancelMul \u03b1] {s t : Set \u03b1}", "[Group \u03b1] [MulAction \u03b1 \u03b2] {s t A B : Set \u03b2} {a b : \u03b1} {x : \u03b2}", "[Monoid \u03b1] [MulAction \u03b1 \u03b2] {s : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Group \u03b1] [CommGroup \u03b2] [FunLike F \u03b1 \u03b2] [MonoidHomClass F \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nF : Type u_5\ninst\u271d\u00b9\u00b9 : Mul \u03b1\ninst\u271d\u00b9\u2070 : Semigroup \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 : IsLeftCancelMul \u03b1\ninst\u271d\u2077 : Group \u03b1\ninst\u271d\u2076 : MulAction \u03b1 \u03b2\ninst\u271d\u2075 : Monoid \u03b1\ninst\u271d\u2074 : MulAction \u03b1 \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : CommGroup \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\nx : \u03b1 \u00d7 \u03b2\ns : Set \u03b1\nf : F\n\u22a2 x \u2022 Set.graphOn (\u21d1f) s = Set.graphOn (fun a => x.2 / f x.1 * f a) (x.1 \u2022 s)"}, {"line": "ext \u27e8a, b\u27e9", "tactic_state": "case h.mk\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nF : Type u_5\ninst\u271d\u00b9\u00b9 : Mul \u03b1\ninst\u271d\u00b9\u2070 : Semigroup \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 : IsLeftCancelMul \u03b1\ninst\u271d\u2077 : Group \u03b1\ninst\u271d\u2076 : MulAction \u03b1 \u03b2\ninst\u271d\u2075 : Monoid \u03b1\ninst\u271d\u2074 : MulAction \u03b1 \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : CommGroup \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\nx : \u03b1 \u00d7 \u03b2\ns : Set \u03b1\nf : F\na : \u03b1\nb : \u03b2\n\u22a2 (a, b) \u2208 x \u2022 Set.graphOn (\u21d1f) s \u2194 (a, b) \u2208 Set.graphOn (fun a => x.2 / f x.1 * f a) (x.1 \u2022 s)"}, {"line": "simp [mem_smul_set_iff_inv_smul_mem, Prod.ext_iff, and_comm (a := _ = a), inv_mul_eq_iff_eq_mul,\n    mul_left_comm _ _\u207b\u00b9, eq_inv_mul_iff_mul_eq, \u2190 mul_div_right_comm, div_eq_iff_eq_mul, mul_comm b]", "tactic_state": "case h.mk\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nF : Type u_5\ninst\u271d\u00b9\u00b9 : Mul \u03b1\ninst\u271d\u00b9\u2070 : Semigroup \u03b1\ninst\u271d\u2079 : Mul \u03b1\ninst\u271d\u2078 : IsLeftCancelMul \u03b1\ninst\u271d\u2077 : Group \u03b1\ninst\u271d\u2076 : MulAction \u03b1 \u03b2\ninst\u271d\u2075 : Monoid \u03b1\ninst\u271d\u2074 : MulAction \u03b1 \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : CommGroup \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\nx : \u03b1 \u00d7 \u03b2\ns : Set \u03b1\nf : F\na : \u03b1\nb : \u03b2\n\u22a2 (a, b) \u2208 x \u2022 Set.graphOn (\u21d1f) s \u2194 a \u2208 x.1 \u2022 s \u2227 x.2 / f x.1 * f a = b"}]}
{"declaration": "lemma lt_one_iff {n : \u2115} (x : Fin (n + 2)) : x < 1 \u2194 x = 0 := by\n  simp [lt_iff_val_lt_val]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Fin/Basic.lean", "context": {"open": ["Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx : Fin (n + 2)\n\u22a2 x < 1 \u2194 x = 0"}, {"line": "simp [lt_iff_val_lt_val]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lt_sub_one_iff {k : Fin (n + 2)} : k < k - 1 \u2194 k = 0 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Fin/Basic.lean", "context": {"open": ["Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nk : Fin (n + 2)\n\u22a2 k < k - 1 \u2194 k = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_mul_eq_one [MonoidHomClass F M N] (f : F) {a b : M} (h : a * b = 1) :\n    f a * f b = 1 := by\n  rw [\u2190 map_mul]\n  rw [h]\n  rw [map_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Hom/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 M N P : Type*}", "{G : Type*} {H : Type*}", "{F : Type*}", "[One M] [One N]", "[FunLike F M N]", "[Mul M] [Mul N]", "[FunLike F M N]", "[MulOneClass M] [MulOneClass N]", "[FunLike F M N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_4\nN : Type u_5\nF : Type u_9\ninst\u271d\u2079 : One M\ninst\u271d\u2078 : One N\ninst\u271d\u2077 : FunLike F M N\ninst\u271d\u2076 : Mul M\ninst\u271d\u2075 : Mul N\ninst\u271d\u2074 : FunLike F M N\ninst\u271d\u00b3 : MulOneClass M\ninst\u271d\u00b2 : MulOneClass N\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : MonoidHomClass F M N\nf : F\na b : M\nh : a * b = 1\n\u22a2 f a * f b = 1"}, {"line": "rw [\u2190 map_mul]", "tactic_state": "M : Type u_4\nN : Type u_5\nF : Type u_9\ninst\u271d\u2079 : One M\ninst\u271d\u2078 : One N\ninst\u271d\u2077 : FunLike F M N\ninst\u271d\u2076 : Mul M\ninst\u271d\u2075 : Mul N\ninst\u271d\u2074 : FunLike F M N\ninst\u271d\u00b3 : MulOneClass M\ninst\u271d\u00b2 : MulOneClass N\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : MonoidHomClass F M N\nf : F\na b : M\nh : a * b = 1\n\u22a2 f (a * b) = 1\n---\nM : Type u_4\nN : Type u_5\nF : Type u_9\ninst\u271d\u2079 : One M\ninst\u271d\u2078 : One N\ninst\u271d\u2077 : FunLike F M N\ninst\u271d\u2076 : Mul M\ninst\u271d\u2075 : Mul N\ninst\u271d\u2074 : FunLike F M N\ninst\u271d\u00b3 : MulOneClass M\ninst\u271d\u00b2 : MulOneClass N\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : MonoidHomClass F M N\nf : F\na b : M\nh : a * b = 1\n\u22a2 Mul M\n---\nM : Type u_4\nN : Type u_5\nF : Type u_9\ninst\u271d\u2079 : One M\ninst\u271d\u2078 : One N\ninst\u271d\u2077 : FunLike F M N\ninst\u271d\u2076 : Mul M\ninst\u271d\u2075 : Mul N\ninst\u271d\u2074 : FunLike F M N\ninst\u271d\u00b3 : MulOneClass M\ninst\u271d\u00b2 : MulOneClass N\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : MonoidHomClass F M N\nf : F\na b : M\nh : a * b = 1\n\u22a2 MulHomClass F M N"}, {"line": "rw [h]", "tactic_state": "M : Type u_4\nN : Type u_5\nF : Type u_9\ninst\u271d\u2079 : One M\ninst\u271d\u2078 : One N\ninst\u271d\u2077 : FunLike F M N\ninst\u271d\u2076 : Mul M\ninst\u271d\u2075 : Mul N\ninst\u271d\u2074 : FunLike F M N\ninst\u271d\u00b3 : MulOneClass M\ninst\u271d\u00b2 : MulOneClass N\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : MonoidHomClass F M N\nf : F\na b : M\nh : a * b = 1\n\u22a2 f 1 = 1\n---\nM : Type u_4\nN : Type u_5\nF : Type u_9\ninst\u271d\u2079 : One M\ninst\u271d\u2078 : One N\ninst\u271d\u2077 : FunLike F M N\ninst\u271d\u2076 : Mul M\ninst\u271d\u2075 : Mul N\ninst\u271d\u2074 : FunLike F M N\ninst\u271d\u00b3 : MulOneClass M\ninst\u271d\u00b2 : MulOneClass N\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : MonoidHomClass F M N\nf : F\na b : M\nh : a * b = 1\n\u22a2 MulHomClass F M N"}, {"line": "rw [map_one]", "tactic_state": "M : Type u_4\nN : Type u_5\nF : Type u_9\ninst\u271d\u2079 : One M\ninst\u271d\u2078 : One N\ninst\u271d\u2077 : FunLike F M N\ninst\u271d\u2076 : Mul M\ninst\u271d\u2075 : Mul N\ninst\u271d\u2074 : FunLike F M N\ninst\u271d\u00b3 : MulOneClass M\ninst\u271d\u00b2 : MulOneClass N\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : MonoidHomClass F M N\nf : F\na b : M\nh : a * b = 1\n\u22a2 OneHomClass F M N\n---\nM : Type u_4\nN : Type u_5\nF : Type u_9\ninst\u271d\u2079 : One M\ninst\u271d\u2078 : One N\ninst\u271d\u2077 : FunLike F M N\ninst\u271d\u2076 : Mul M\ninst\u271d\u2075 : Mul N\ninst\u271d\u2074 : FunLike F M N\ninst\u271d\u00b3 : MulOneClass M\ninst\u271d\u00b2 : MulOneClass N\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : MonoidHomClass F M N\nf : F\na b : M\nh : a * b = 1\n\u22a2 MulHomClass F M N"}]}
{"declaration": "theorem map_div' [DivInvMonoid G] [DivInvMonoid H] [MulHomClass F G H]\n    (f : F) (hf : \u2200 a, f a\u207b\u00b9 = (f a)\u207b\u00b9) (a b : G) : f (a / b) = f a / f b := by\n  rw [div_eq_mul_inv]\n  rw [div_eq_mul_inv]\n  rw [map_mul]\n  rw [hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Hom/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 M N P : Type*}", "{G : Type*} {H : Type*}", "{F : Type*}", "[One M] [One N]", "[FunLike F M N]", "[Mul M] [Mul N]", "[FunLike F M N]", "[MulOneClass M] [MulOneClass N]", "[FunLike F M N]", "[FunLike F G H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_7\nH : Type u_8\nF : Type u_9\ninst\u271d\u00b3 : FunLike F G H\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvMonoid H\ninst\u271d : MulHomClass F G H\nf : F\nhf : \u2200 (a : G), f a\u207b\u00b9 = (f a)\u207b\u00b9\na b : G\n\u22a2 f (a / b) = f a / f b"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "G : Type u_7\nH : Type u_8\nF : Type u_9\ninst\u271d\u00b3 : FunLike F G H\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvMonoid H\ninst\u271d : MulHomClass F G H\nf : F\nhf : \u2200 (a : G), f a\u207b\u00b9 = (f a)\u207b\u00b9\na b : G\n\u22a2 f (a * b\u207b\u00b9) = f a / f b"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "G : Type u_7\nH : Type u_8\nF : Type u_9\ninst\u271d\u00b3 : FunLike F G H\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvMonoid H\ninst\u271d : MulHomClass F G H\nf : F\nhf : \u2200 (a : G), f a\u207b\u00b9 = (f a)\u207b\u00b9\na b : G\n\u22a2 f (a * b\u207b\u00b9) = f a * (f b)\u207b\u00b9"}, {"line": "rw [map_mul]", "tactic_state": "G : Type u_7\nH : Type u_8\nF : Type u_9\ninst\u271d\u00b3 : FunLike F G H\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvMonoid H\ninst\u271d : MulHomClass F G H\nf : F\nhf : \u2200 (a : G), f a\u207b\u00b9 = (f a)\u207b\u00b9\na b : G\n\u22a2 f a * f b\u207b\u00b9 = f a * (f b)\u207b\u00b9\n---\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst\u271d\u00b3 : FunLike F G H\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvMonoid H\ninst\u271d : MulHomClass F G H\nf : F\nhf : \u2200 (a : G), f a\u207b\u00b9 = (f a)\u207b\u00b9\na b : G\n\u22a2 Mul H\n---\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst\u271d\u00b3 : FunLike F G H\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvMonoid H\ninst\u271d : MulHomClass F G H\nf : F\nhf : \u2200 (a : G), f a\u207b\u00b9 = (f a)\u207b\u00b9\na b : G\n\u22a2 MulHomClass F G H"}, {"line": "rw [hf]", "tactic_state": "G : Type u_7\nH : Type u_8\nF : Type u_9\ninst\u271d\u00b3 : FunLike F G H\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : DivInvMonoid H\ninst\u271d : MulHomClass F G H\nf : F\nhf : \u2200 (a : G), f a\u207b\u00b9 = (f a)\u207b\u00b9\na b : G\n\u22a2 MulHomClass F G H"}]}
{"declaration": "theorem map_mul_inv [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) (a b : G) :\n    f (a * b\u207b\u00b9) = f a * (f b)\u207b\u00b9 := by rw [map_mul, map_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Hom/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 M N P : Type*}", "{G : Type*} {H : Type*}", "{F : Type*}", "[One M] [One N]", "[FunLike F M N]", "[Mul M] [Mul N]", "[FunLike F M N]", "[MulOneClass M] [MulOneClass N]", "[FunLike F M N]", "[FunLike F G H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_7\nH : Type u_8\nF : Type u_9\ninst\u271d\u00b3 : FunLike F G H\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : DivisionMonoid H\ninst\u271d : MonoidHomClass F G H\nf : F\na b : G\n\u22a2 f (a * b\u207b\u00b9) = f a * (f b)\u207b\u00b9"}, {"line": "rw [map_mul, map_inv]", "tactic_state": "G : Type u_7\nH : Type u_8\nF : Type u_9\ninst\u271d\u00b3 : FunLike F G H\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : DivisionMonoid H\ninst\u271d : MonoidHomClass F G H\nf : F\na b : G\n\u22a2 MonoidHomClass F G H\n---\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst\u271d\u00b3 : FunLike F G H\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : DivisionMonoid H\ninst\u271d : MonoidHomClass F G H\nf : F\na b : G\n\u22a2 MulHomClass F G H"}]}
{"declaration": "lemma two_not_dvd_two_mul_add_one (n : \u2124) : \u00ac2 \u2223 2 * n + 1 := by simp [add_emod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Int/Even.lean", "context": {"open": ["Nat"], "variables": ["{m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 \u00ac2 \u2223 2 * n + 1"}, {"line": "simp [add_emod]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma even_sub : Even (m - n) \u2194 (Even m \u2194 Even n) := by simp [sub_eq_add_neg, parity_simps]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Int/Even.lean", "context": {"open": ["Nat"], "variables": ["{m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2124\n\u22a2 Even (m - n) \u2194 (Even m \u2194 Even n)"}, {"line": "simp [sub_eq_add_neg, parity_simps]", "tactic_state": "No Goals!"}]}
{"declaration": "example (m n : \u2124) (h : Even m) : \u00acEven (n + 3) \u2194 Even (m ^ 2 + m + n) := by\n  simp +decide [*, (by decide : \u00ac2 = 0), parity_simps]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Int/Even.lean", "context": {"open": ["Nat"], "variables": ["{m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m\u271d n\u271d m n : \u2124\nh : Even m\n\u22a2 \u00acEven (n + 3) \u2194 Even (m ^ 2 + m + n)"}, {"line": "simp +decide [*, (by decide : \u00ac2 = 0), parity_simps]", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u00acEven (25394535 : \u2124) := by decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Int/Even.lean", "context": {"open": ["Nat"], "variables": ["{m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2124\n\u22a2 \u00acEven 25394535"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isUnit_eq_one_or (hu : IsUnit u) : u = 1 \u2228 u = -1 := by\n  simpa only [natAbs_of_isUnit hu] using natAbs_eq u\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Int/Units.lean", "context": {"open": ["Nat"], "variables": ["{u v : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "u : \u2124\nhu : IsUnit u\n\u22a2 u = 1 \u2228 u = -1"}, {"line": "simpa only [natAbs_of_isUnit hu] using natAbs_eq u", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isUnit_iff : IsUnit u \u2194 u = 1 \u2228 u = -1 := by\n  refine \u27e8fun h \u21a6 isUnit_eq_one_or h, fun h \u21a6 ?_\u27e9\n  rcases h with (rfl | rfl)\n  \u00b7 exact isUnit_one\n  \u00b7 exact \u27e8\u27e8-1, -1, by decide, by decide\u27e9, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Int/Units.lean", "context": {"open": ["Nat"], "variables": ["{u v : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "u : \u2124\n\u22a2 IsUnit u \u2194 u = 1 \u2228 u = -1"}, {"line": "refine \u27e8fun h \u21a6 isUnit_eq_one_or h, fun h \u21a6 ?_\u27e9", "tactic_state": "u : \u2124\nh : u = 1 \u2228 u = -1\n\u22a2 IsUnit u"}, {"line": "rcases h with (rfl | rfl)", "tactic_state": "case inl\n\u22a2 IsUnit 1\n---\ncase inr\n\u22a2 IsUnit (-1)"}, {"line": "\u00b7 exact isUnit_one", "tactic_state": "case inr\n\u22a2 IsUnit (-1)"}, {"line": "\u00b7 exact \u27e8\u27e8-1, -1, by decide, by decide\u27e9, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_eq_one_iff_eq_one_or_neg_one : u * v = 1 \u2194 u = 1 \u2227 v = 1 \u2228 u = -1 \u2227 v = -1 := by\n  refine \u27e8eq_one_or_neg_one_of_mul_eq_one', fun h \u21a6 Or.elim h (fun H \u21a6 ?_) fun H \u21a6 ?_\u27e9 <;>\n    obtain \u27e8rfl, rfl\u27e9 := H <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Int/Units.lean", "context": {"open": ["Nat"], "variables": ["{u v : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "u v : \u2124\n\u22a2 u * v = 1 \u2194 u = 1 \u2227 v = 1 \u2228 u = -1 \u2227 v = -1"}, {"line": "refine \u27e8eq_one_or_neg_one_of_mul_eq_one', fun h \u21a6 Or.elim h (fun H \u21a6 ?_) fun H \u21a6 ?_\u27e9 <;>\n    obtain \u27e8rfl, rfl\u27e9 := H <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_eq_neg_one_iff_eq_one_or_neg_one : u * v = -1 \u2194 u = 1 \u2227 v = -1 \u2228 u = -1 \u2227 v = 1 := by\n  refine \u27e8eq_one_or_neg_one_of_mul_eq_neg_one', fun h \u21a6 Or.elim h (fun H \u21a6 ?_) fun H \u21a6 ?_\u27e9 <;>\n    obtain \u27e8rfl, rfl\u27e9 := H <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Int/Units.lean", "context": {"open": ["Nat"], "variables": ["{u v : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "u v : \u2124\n\u22a2 u * v = -1 \u2194 u = 1 \u2227 v = -1 \u2228 u = -1 \u2227 v = 1"}, {"line": "refine \u27e8eq_one_or_neg_one_of_mul_eq_neg_one', fun h \u21a6 Or.elim h (fun H \u21a6 ?_) fun H \u21a6 ?_\u27e9 <;>\n    obtain \u27e8rfl, rfl\u27e9 := H <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ofNat_isUnit {n : \u2115} : IsUnit (n : \u2124) \u2194 IsUnit n := by simp [isUnit_iff_natAbs_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Int/Units.lean", "context": {"open": ["Nat"], "variables": ["{u v : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 IsUnit \u2191n \u2194 IsUnit n"}, {"line": "simp [isUnit_iff_natAbs_eq]", "tactic_state": "n : \u2115\n\u22a2 IsUnit \u2191n \u2194 n = 1"}]}
{"declaration": "theorem invOf_mul_cancel_left' [Monoid \u03b1] (a b : \u03b1) {_ : Invertible a} : \u215f a * (a * b) = b := by\n  rw [\u2190 mul_assoc]\n  rw [invOf_mul_self]\n  rw [one_mul]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Invertible/Defs.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Monoid \u03b1\na b : \u03b1\nx\u271d : Invertible a\n\u22a2 \u215f a * (a * b) = b"}, {"line": "rw [\u2190 mul_assoc]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Monoid \u03b1\na b : \u03b1\nx\u271d : Invertible a\n\u22a2 \u215f a * a * b = b"}, {"line": "rw [invOf_mul_self]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Monoid \u03b1\na b : \u03b1\nx\u271d : Invertible a\n\u22a2 1 * b = b"}, {"line": "rw [one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_invOf_cancel_left' [Monoid \u03b1] (a b : \u03b1) {_ : Invertible a} : a * (\u215f a * b) = b := by\n  rw [\u2190 mul_assoc]\n  rw [mul_invOf_self]\n  rw [one_mul]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Invertible/Defs.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Monoid \u03b1\na b : \u03b1\nx\u271d : Invertible a\n\u22a2 a * (\u215f a * b) = b"}, {"line": "rw [\u2190 mul_assoc]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Monoid \u03b1\na b : \u03b1\nx\u271d : Invertible a\n\u22a2 a * \u215f a * b = b"}, {"line": "rw [mul_invOf_self]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Monoid \u03b1\na b : \u03b1\nx\u271d : Invertible a\n\u22a2 1 * b = b"}, {"line": "rw [one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_invOf_cancel_right' [Monoid \u03b1] (a b : \u03b1) {_ : Invertible b} : a * b * \u215f b = a := by\n  simp [mul_assoc]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Invertible/Defs.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Monoid \u03b1\na b : \u03b1\nx\u271d : Invertible b\n\u22a2 a * b * \u215f b = a"}, {"line": "simp [mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma MulEquiv.irreducible_iff : Irreducible (f x) \u2194 Irreducible x := by\n  simp [_root_.irreducible_iff, (EquivLike.surjective f).forall, \u2190 map_mul, -isUnit_map_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Irreducible/Lemmas.lean", "context": {"open": [], "variables": ["{F M N : Type*}", "[Monoid M] [Monoid N] {f : F} {x y : M}", "[EquivLike F M N] [MulEquivClass F M N] (f : F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\nM : Type u_2\nN : Type u_3\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : Monoid N\nx : M\ninst\u271d\u00b9 : EquivLike F M N\ninst\u271d : MulEquivClass F M N\nf : F\n\u22a2 Irreducible (f x) \u2194 Irreducible x"}, {"line": "simp [_root_.irreducible_iff, (EquivLike.surjective f).forall, \u2190 map_mul, -isUnit_map_iff]", "tactic_state": "F : Type u_1\nM : Type u_2\nN : Type u_3\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : Monoid N\nx : M\ninst\u271d\u00b9 : EquivLike F M N\ninst\u271d : MulEquivClass F M N\nf : F\n\u22a2 (\u00acIsUnit (f x) \u2227 \u2200 \u2983a b : N\u2984, f x = a * b \u2192 IsUnit a \u2228 IsUnit b) \u2194\n    \u00acIsUnit x \u2227 \u2200 \u2983a b : M\u2984, x = a * b \u2192 IsUnit a \u2228 IsUnit b"}]}
{"declaration": "lemma Irreducible.not_isSquare (ha : Irreducible x) : \u00acIsSquare x := by\n  rw [isSquare_iff_exists_sq]\n  rintro \u27e8y, rfl\u27e9\n  exact not_irreducible_pow (by decide) ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Irreducible/Lemmas.lean", "context": {"open": [], "variables": ["{F M N : Type*}", "[Monoid M] [Monoid N] {f : F} {x y : M}", "[EquivLike F M N] [MulEquivClass F M N] (f : F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : Monoid M\nx : M\nha : Irreducible x\n\u22a2 \u00acIsSquare x"}, {"line": "rw [isSquare_iff_exists_sq]", "tactic_state": "M : Type u_2\ninst\u271d : Monoid M\nx : M\nha : Irreducible x\n\u22a2 \u00ac\u2203 r, x = r ^ 2"}, {"line": "rintro \u27e8y, rfl\u27e9", "tactic_state": "case intro\nM : Type u_2\ninst\u271d : Monoid M\ny : M\nha : Irreducible (y ^ 2)\n\u22a2 False"}, {"line": "exact not_irreducible_pow (by decide) ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_irreducible_one : \u00acIrreducible (1 : M) := by simp [irreducible_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Irreducible/Defs.lean", "context": {"open": [], "variables": ["{M : Type*}", "[Monoid M] {p q x y : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d : Monoid M\n\u22a2 \u00acIrreducible 1"}, {"line": "simp [irreducible_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma succ_mod_two_eq_zero_iff : (m + 1) % 2 = 0 \u2194 m % 2 = 1 := by\n  simp [\u2190 Nat.even_iff, \u2190 Nat.not_even_iff, parity_simps]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Nat/Even.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\n\u22a2 (m + 1) % 2 = 0 \u2194 m % 2 = 1"}, {"line": "simp [\u2190 Nat.even_iff, \u2190 Nat.not_even_iff, parity_simps]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma succ_mod_two_eq_one_iff : (m + 1) % 2 = 1 \u2194 m % 2 = 0 := by\n  simp [\u2190 Nat.even_iff, \u2190 Nat.not_even_iff, parity_simps]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Nat/Even.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\n\u22a2 (m + 1) % 2 = 1 \u2194 m % 2 = 0"}, {"line": "simp [\u2190 Nat.even_iff, \u2190 Nat.not_even_iff, parity_simps]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma two_not_dvd_two_mul_add_one (n : \u2115) : \u00ac2 \u2223 2 * n + 1 := by simp [add_mod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Nat/Even.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u00ac2 \u2223 2 * n + 1"}, {"line": "simp [add_mod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_of_ne_zero_of_even (h0 : n \u2260 0) (hn : Even n) : 1 < n := by\n  refine Nat.one_lt_iff_ne_zero_and_ne_one.mpr (And.intro h0 ?_)\n  intro h\n  rw [h] at hn\n  exact Nat.not_even_one hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Nat/Even.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh0 : n \u2260 0\nhn : Even n\n\u22a2 1 < n"}, {"line": "refine Nat.one_lt_iff_ne_zero_and_ne_one.mpr (And.intro h0 ?_)", "tactic_state": "n : \u2115\nh0 : n \u2260 0\nhn : Even n\n\u22a2 n \u2260 1"}, {"line": "intro h", "tactic_state": "n : \u2115\nh0 : n \u2260 0\nhn : Even n\nh : n = 1\n\u22a2 False"}, {"line": "rw [h] at hn", "tactic_state": "n : \u2115\nh0 : n \u2260 0\nhn : Even 1\nh : n = 1\n\u22a2 False"}, {"line": "exact Nat.not_even_one hn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_one_lt_of_even (hn : Even n) (hm : Even m) (hnm : n < m) :\n    n + 1 < m := by\n  rcases hn with \u27e8n, rfl\u27e9\n  rcases hm with \u27e8m, rfl\u27e9\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Nat/Even.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nhn : Even n\nhm : Even m\nhnm : n < m\n\u22a2 n + 1 < m"}, {"line": "rcases hn with \u27e8n, rfl\u27e9", "tactic_state": "case intro\nm : \u2115\nhm : Even m\nn : \u2115\nhnm : n + n < m\n\u22a2 n + n + 1 < m"}, {"line": "rcases hm with \u27e8m, rfl\u27e9", "tactic_state": "case intro.intro\nn m : \u2115\nhnm : n + n < m + m\n\u22a2 n + n + 1 < m + m"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "example (m n : \u2115) (h : Even m) : \u00acEven (n + 3) \u2194 Even (m ^ 2 + m + n) := by simp [*, parity_simps]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Nat/Even.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m\u271d n\u271d m n : \u2115\nh : Even m\n\u22a2 \u00acEven (n + 3) \u2194 Even (m ^ 2 + m + n)"}, {"line": "simp [*, parity_simps]", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u00acEven 25394535 := by decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Nat/Even.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 \u00acEven 25394535"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "lemma AddMonoidHom.apply_nat (f : \u2115 \u2192+ M) (n : \u2115) : f n = n \u2022 f 1 := by\n  rw [\u2190 multiplesHom_symm_apply]\n  rw [\u2190 multiplesHom_apply]\n  rw [Equiv.apply_symm_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Nat/Hom.lean", "context": {"open": ["Additive Multiplicative"], "variables": ["{M M : Type*}", "{A B F : Type*} [FunLike F \u2115 A]", "[AddMonoid M]", "(M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : AddMonoid M\nf : \u2115 \u2192+ M\nn : \u2115\n\u22a2 f n = n \u2022 f 1"}, {"line": "rw [\u2190 multiplesHom_symm_apply]", "tactic_state": "M : Type u_2\ninst\u271d : AddMonoid M\nf : \u2115 \u2192+ M\nn : \u2115\n\u22a2 f n = n \u2022 (multiplesHom M).symm f"}, {"line": "rw [\u2190 multiplesHom_apply]", "tactic_state": "M : Type u_2\ninst\u271d : AddMonoid M\nf : \u2115 \u2192+ M\nn : \u2115\n\u22a2 f n = ((multiplesHom M) ((multiplesHom M).symm f)) n"}, {"line": "rw [Equiv.apply_symm_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mulSingle_comm [One \u03b2] (i : I) (x : \u03b2) (i' : I) :\n    (mulSingle i x : I \u2192 \u03b2) i' = (mulSingle i' x : I \u2192 \u03b2) i := by\n  simp [mulSingle_apply, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pi/Basic.lean", "context": {"open": ["Function"], "variables": ["{I : Type u}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{f : I \u2192 Type v\u2081} {g : I \u2192 Type v\u2082} {h : I \u2192 Type v\u2083}", "(x y : \u2200 i, f i) (i : I)", "[DecidableEq I]", "[\u2200 i, One (f i)] [\u2200 i, One (g i)] [\u2200 i, One (h i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : Type u\n\u03b2 : Type u_2\ninst\u271d\u00b9 : DecidableEq I\nx\u271d : Sort u_4\nmulSingle : x\u271d\ninst\u271d : One \u03b2\ni : I\nx : \u03b2\ni' : I\n\u22a2 sorry i' = sorry i"}, {"line": "simp [mulSingle_apply, eq_comm]", "tactic_state": "I : Type u\n\u03b2 : Type u_2\ninst\u271d\u00b9 : DecidableEq I\nx\u271d : Sort u_4\nmulSingle : x\u271d\ninst\u271d : One \u03b2\ni : I\nx : \u03b2\ni' : I\n\u22a2 sorry () i = sorry () i'"}]}
{"declaration": "theorem apply_mulSingle (f' : \u2200 i, f i \u2192 g i) (hf' : \u2200 i, f' i 1 = 1) (i : I) (x : f i) (j : I) :\n    f' j (mulSingle i x j) = mulSingle i (f' i x) j := by\n  simpa only [Pi.one_apply, hf', mulSingle] using Function.apply_update f' 1 i x j\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pi/Basic.lean", "context": {"open": ["Function"], "variables": ["{I : Type u}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{f : I \u2192 Type v\u2081} {g : I \u2192 Type v\u2082} {h : I \u2192 Type v\u2083}", "(x y : \u2200 i, f i) (i : I)", "[DecidableEq I]", "[\u2200 i, One (f i)] [\u2200 i, One (g i)] [\u2200 i, One (h i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : Type u\nf : I \u2192 Type v\u2081\ng : I \u2192 Type v\u2082\ninst\u271d\u00b2 : DecidableEq I\ninst\u271d\u00b9 : (i : I) \u2192 One (f i)\ninst\u271d : (i : I) \u2192 One (g i)\nx\u271d : Sort u_4\nmulSingle : x\u271d\nf' : (i : I) \u2192 f i \u2192 g i\nhf' : \u2200 (i : I), f' i 1 = 1\ni : I\nx : f i\nj : I\n\u22a2 f' j sorry = sorry"}, {"line": "simpa only [Pi.one_apply, hf', mulSingle] using Function.apply_update f' 1 i x j", "tactic_state": "No Goals!"}]}
{"declaration": "theorem apply_mulSingle\u2082 (f' : \u2200 i, f i \u2192 g i \u2192 h i) (hf' : \u2200 i, f' i 1 1 = 1) (i : I)\n    (x : f i) (y : g i) (j : I) :\n    f' j (mulSingle i x j) (mulSingle i y j) = mulSingle i (f' i x y) j := by\n  by_cases h : j = i\n  \u00b7 subst h\n    simp only [mulSingle_eq_same]\n  \u00b7 simp only [mulSingle_eq_of_ne h, hf']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pi/Basic.lean", "context": {"open": ["Function"], "variables": ["{I : Type u}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{f : I \u2192 Type v\u2081} {g : I \u2192 Type v\u2082} {h : I \u2192 Type v\u2083}", "(x y : \u2200 i, f i) (i : I)", "[DecidableEq I]", "[\u2200 i, One (f i)] [\u2200 i, One (g i)] [\u2200 i, One (h i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : Type u\nf : I \u2192 Type v\u2081\ng : I \u2192 Type v\u2082\nh : I \u2192 Type v\u2083\ninst\u271d\u00b3 : DecidableEq I\ninst\u271d\u00b2 : (i : I) \u2192 One (f i)\ninst\u271d\u00b9 : (i : I) \u2192 One (g i)\ninst\u271d : (i : I) \u2192 One (h i)\nx\u271d : Sort u_4\nmulSingle : x\u271d\nf' : (i : I) \u2192 f i \u2192 g i \u2192 h i\nhf' : \u2200 (i : I), f' i 1 1 = 1\ni : I\nx : f i\ny : g i\nj : I\n\u22a2 f' j sorry sorry = sorry"}, {"line": "by_cases h : j = i", "tactic_state": "case pos\nI : Type u\nf : I \u2192 Type v\u2081\ng : I \u2192 Type v\u2082\nh\u271d : I \u2192 Type v\u2083\ninst\u271d\u00b3 : DecidableEq I\ninst\u271d\u00b2 : (i : I) \u2192 One (f i)\ninst\u271d\u00b9 : (i : I) \u2192 One (g i)\ninst\u271d : (i : I) \u2192 One (h\u271d i)\nx\u271d : Sort u_4\nmulSingle : x\u271d\nf' : (i : I) \u2192 f i \u2192 g i \u2192 h\u271d i\nhf' : \u2200 (i : I), f' i 1 1 = 1\ni : I\nx : f i\ny : g i\nj : I\nh : j = i\n\u22a2 f' j sorry sorry = sorry\n---\ncase neg\nI : Type u\nf : I \u2192 Type v\u2081\ng : I \u2192 Type v\u2082\nh\u271d : I \u2192 Type v\u2083\ninst\u271d\u00b3 : DecidableEq I\ninst\u271d\u00b2 : (i : I) \u2192 One (f i)\ninst\u271d\u00b9 : (i : I) \u2192 One (g i)\ninst\u271d : (i : I) \u2192 One (h\u271d i)\nx\u271d : Sort u_4\nmulSingle : x\u271d\nf' : (i : I) \u2192 f i \u2192 g i \u2192 h\u271d i\nhf' : \u2200 (i : I), f' i 1 1 = 1\ni : I\nx : f i\ny : g i\nj : I\nh : \u00acj = i\n\u22a2 f' j sorry sorry = sorry"}, {"line": "\u00b7 subst h\n    simp only [mulSingle_eq_same]", "tactic_state": "case neg\nI : Type u\nf : I \u2192 Type v\u2081\ng : I \u2192 Type v\u2082\nh\u271d : I \u2192 Type v\u2083\ninst\u271d\u00b3 : DecidableEq I\ninst\u271d\u00b2 : (i : I) \u2192 One (f i)\ninst\u271d\u00b9 : (i : I) \u2192 One (g i)\ninst\u271d : (i : I) \u2192 One (h\u271d i)\nx\u271d : Sort u_4\nmulSingle : x\u271d\nf' : (i : I) \u2192 f i \u2192 g i \u2192 h\u271d i\nhf' : \u2200 (i : I), f' i 1 1 = 1\ni : I\nx : f i\ny : g i\nj : I\nh : \u00acj = i\n\u22a2 f' j sorry sorry = sorry"}, {"line": "\u00b7 simp only [mulSingle_eq_of_ne h, hf']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem elim_mul_mul [Mul \u03b3] : Sum.elim (a * a') (b * b') = Sum.elim a b * Sum.elim a' b' := by\n  ext x\n  cases x <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pi/Basic.lean", "context": {"open": ["Function"], "variables": ["{I : Type u}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{f : I \u2192 Type v\u2081} {g : I \u2192 Type v\u2082} {h : I \u2192 Type v\u2083}", "(x y : \u2200 i, f i) (i : I)", "[DecidableEq I]", "[\u2200 i, One (f i)] [\u2200 i, One (g i)] [\u2200 i, One (h i)]", "(f)", "(a a' : \u03b1 \u2192 \u03b3) (b b' : \u03b2 \u2192 \u03b3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na a' : \u03b1 \u2192 \u03b3\nb b' : \u03b2 \u2192 \u03b3\ninst\u271d : Mul \u03b3\n\u22a2 Sum.elim (a * a') (b * b') = Sum.elim a b * Sum.elim a' b'"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na a' : \u03b1 \u2192 \u03b3\nb b' : \u03b2 \u2192 \u03b3\ninst\u271d : Mul \u03b3\nx : \u03b1 \u2295 \u03b2\n\u22a2 Sum.elim (a * a') (b * b') x = (Sum.elim a b * Sum.elim a' b') x"}, {"line": "cases x <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem elim_div_div [Div \u03b3] : Sum.elim (a / a') (b / b') = Sum.elim a b / Sum.elim a' b' := by\n  ext x\n  cases x <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pi/Basic.lean", "context": {"open": ["Function"], "variables": ["{I : Type u}", "{\u03b1 \u03b2 \u03b3 : Type*}", "{f : I \u2192 Type v\u2081} {g : I \u2192 Type v\u2082} {h : I \u2192 Type v\u2083}", "(x y : \u2200 i, f i) (i : I)", "[DecidableEq I]", "[\u2200 i, One (f i)] [\u2200 i, One (g i)] [\u2200 i, One (h i)]", "(f)", "(a a' : \u03b1 \u2192 \u03b3) (b b' : \u03b2 \u2192 \u03b3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na a' : \u03b1 \u2192 \u03b3\nb b' : \u03b2 \u2192 \u03b3\ninst\u271d : Div \u03b3\n\u22a2 Sum.elim (a / a') (b / b') = Sum.elim a b / Sum.elim a' b'"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na a' : \u03b1 \u2192 \u03b3\nb b' : \u03b2 \u2192 \u03b3\ninst\u271d : Div \u03b3\nx : \u03b1 \u2295 \u03b2\n\u22a2 Sum.elim (a / a') (b / b') x = (Sum.elim a b / Sum.elim a' b') x"}, {"line": "cases x <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Pi.update_eq_div_mul_mulSingle [\u2200 i, Group <| f i] (g : \u2200 i : I, f i) (x : f i) :\n    Function.update g i x = g / mulSingle i (g i) * mulSingle i x := by\n  ext j\n  rcases eq_or_ne i j with (rfl | h)\n  \u00b7 simp\n  \u00b7 simp [Function.update_of_ne h.symm, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pi/Lemmas.lean", "context": {"open": ["Pi"], "variables": ["{\u03b9 \u03b1 : Type*}", "{I : Type u}", "{f : I \u2192 Type v}", "(i : I)", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]", "(f)", "[(i : I) \u2192 Mul (f i)]", "(f)", "[(i : I) \u2192 MulOneClass (f i)]", "[DecidableEq I]", "(f)", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : Type u\nf : I \u2192 Type v\ni : I\ninst\u271d\u00b3 : (i : I) \u2192 Mul (f i)\ninst\u271d\u00b2 : (i : I) \u2192 MulOneClass (f i)\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 Group (f i)\ng : (i : I) \u2192 f i\nx : f i\n\u22a2 Function.update g i x = g / mulSingle i (g i) * mulSingle i x"}, {"line": "ext j", "tactic_state": "case h\nI : Type u\nf : I \u2192 Type v\ni : I\ninst\u271d\u00b3 : (i : I) \u2192 Mul (f i)\ninst\u271d\u00b2 : (i : I) \u2192 MulOneClass (f i)\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 Group (f i)\ng : (i : I) \u2192 f i\nx : f i\nj : I\n\u22a2 Function.update g i x j = (g / mulSingle i (g i) * mulSingle i x) j"}, {"line": "rcases eq_or_ne i j with (rfl | h)", "tactic_state": "case h.inl\nI : Type u\nf : I \u2192 Type v\ni : I\ninst\u271d\u00b3 : (i : I) \u2192 Mul (f i)\ninst\u271d\u00b2 : (i : I) \u2192 MulOneClass (f i)\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 Group (f i)\ng : (i : I) \u2192 f i\nx : f i\n\u22a2 Function.update g i x i = (g / mulSingle i (g i) * mulSingle i x) i\n---\ncase h.inr\nI : Type u\nf : I \u2192 Type v\ni : I\ninst\u271d\u00b3 : (i : I) \u2192 Mul (f i)\ninst\u271d\u00b2 : (i : I) \u2192 MulOneClass (f i)\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 Group (f i)\ng : (i : I) \u2192 f i\nx : f i\nj : I\nh : i \u2260 j\n\u22a2 Function.update g i x j = (g / mulSingle i (g i) * mulSingle i x) j"}, {"line": "\u00b7 simp", "tactic_state": "case h.inr\nI : Type u\nf : I \u2192 Type v\ni : I\ninst\u271d\u00b3 : (i : I) \u2192 Mul (f i)\ninst\u271d\u00b2 : (i : I) \u2192 MulOneClass (f i)\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 Group (f i)\ng : (i : I) \u2192 f i\nx : f i\nj : I\nh : i \u2260 j\n\u22a2 Function.update g i x j = (g / mulSingle i (g i) * mulSingle i x) j"}, {"line": "\u00b7 simp [Function.update_of_ne h.symm, h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mulSingle_comp_equiv {m n : Type*} [DecidableEq n] [DecidableEq m] [One \u03b1] (\u03c3 : n \u2243 m)\n    (i : m) (x : \u03b1) : Pi.mulSingle i x \u2218 \u03c3 = Pi.mulSingle (\u03c3.symm i) x := by\n  ext x\n  aesop (add simp Pi.mulSingle_apply)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pi/Lemmas.lean", "context": {"open": ["Pi"], "variables": ["{\u03b9 \u03b1 : Type*}", "{I : Type u}", "{f : I \u2192 Type v}", "(i : I)", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]", "(f)", "[(i : I) \u2192 Mul (f i)]", "(f)", "[(i : I) \u2192 MulOneClass (f i)]", "[DecidableEq I]", "(f)", "{f}", "[\u2200 i, Mul <| f i]", "[One \u03b1] [Nonempty \u03b9] {a : \u03b1}", "{\u03b7 : Type v} (R : Type w) (s : \u03b9 \u2192 \u03b7)", "[DecidableEq I] [\u2200 i, Preorder (f i)] [\u2200 i, One (f i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : One \u03b1\nm : Type u_5\nn : Type u_6\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : One \u03b1\n\u03c3 : n \u2243 m\ni : m\nx : \u03b1\n\u22a2 mulSingle i x \u2218 \u21d1\u03c3 = mulSingle (\u03c3.symm i) x"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_3\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : One \u03b1\nm : Type u_5\nn : Type u_6\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : One \u03b1\n\u03c3 : n \u2243 m\ni : m\nx\u271d : \u03b1\nx : n\n\u22a2 (mulSingle i x\u271d \u2218 \u21d1\u03c3) x = mulSingle (\u03c3.symm i) x\u271d x"}, {"line": "aesop (add simp Pi.mulSingle_apply)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem curry_mulSingle [DecidableEq \u03b1] [\u2200 a, DecidableEq (\u03b2 a)] [\u2200 a b, One (\u03b3 a b)]\n    (i : \u03a3 a, \u03b2 a) (x : \u03b3 i.1 i.2) :\n    Sigma.curry (Pi.mulSingle i x) = Pi.mulSingle i.1 (Pi.mulSingle i.2 x) := by\n  simp only [Pi.mulSingle]\n  simp only [Sigma.curry_update]\n  simp only [Sigma.curry_one]\n  simp only [Pi.one_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pi/Lemmas.lean", "context": {"open": ["Pi"], "variables": ["{\u03b9 \u03b1 : Type*}", "{I : Type u}", "{f : I \u2192 Type v}", "(i : I)", "{\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2]", "(f)", "[(i : I) \u2192 Mul (f i)]", "(f)", "[(i : I) \u2192 MulOneClass (f i)]", "[DecidableEq I]", "(f)", "{f}", "[\u2200 i, Mul <| f i]", "[One \u03b1] [Nonempty \u03b9] {a : \u03b1}", "{\u03b7 : Type v} (R : Type w) (s : \u03b9 \u2192 \u03b7)", "[DecidableEq I] [\u2200 i, Preorder (f i)] [\u2200 i, One (f i)]", "{\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : \u03b1 \u2192 Type u_6\n\u03b3 : (a : \u03b1) \u2192 \u03b2 a \u2192 Type u_7\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : (a : \u03b1) \u2192 DecidableEq (\u03b2 a)\ninst\u271d : (a : \u03b1) \u2192 (b : \u03b2 a) \u2192 One (\u03b3 a b)\ni : (a : \u03b1) \u00d7 \u03b2 a\nx : \u03b3 i.fst i.snd\n\u22a2 Sigma.curry (mulSingle i x) = mulSingle i.fst (mulSingle i.snd x)"}, {"line": "simp only [Pi.mulSingle]", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : \u03b1 \u2192 Type u_6\n\u03b3 : (a : \u03b1) \u2192 \u03b2 a \u2192 Type u_7\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : (a : \u03b1) \u2192 DecidableEq (\u03b2 a)\ninst\u271d : (a : \u03b1) \u2192 (b : \u03b2 a) \u2192 One (\u03b3 a b)\ni : (a : \u03b1) \u00d7 \u03b2 a\nx : \u03b3 i.fst i.snd\n\u22a2 Sigma.curry (Function.update 1 i x) = Function.update 1 i.fst (Function.update 1 i.snd x)"}, {"line": "simp only [Sigma.curry_update]", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : \u03b1 \u2192 Type u_6\n\u03b3 : (a : \u03b1) \u2192 \u03b2 a \u2192 Type u_7\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : (a : \u03b1) \u2192 DecidableEq (\u03b2 a)\ninst\u271d : (a : \u03b1) \u2192 (b : \u03b2 a) \u2192 One (\u03b3 a b)\ni : (a : \u03b1) \u00d7 \u03b2 a\nx : \u03b3 i.fst i.snd\n\u22a2 Function.update (Sigma.curry 1) i.fst (Function.update (Sigma.curry 1 i.fst) i.snd x) =\n    Function.update 1 i.fst (Function.update 1 i.snd x)"}, {"line": "simp only [Sigma.curry_one]", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : \u03b1 \u2192 Type u_6\n\u03b3 : (a : \u03b1) \u2192 \u03b2 a \u2192 Type u_7\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : (a : \u03b1) \u2192 DecidableEq (\u03b2 a)\ninst\u271d : (a : \u03b1) \u2192 (b : \u03b2 a) \u2192 One (\u03b3 a b)\ni : (a : \u03b1) \u00d7 \u03b2 a\nx : \u03b3 i.fst i.snd\n\u22a2 Function.update 1 i.fst (Function.update (1 i.fst) i.snd x) = Function.update 1 i.fst (Function.update 1 i.snd x)"}, {"line": "simp only [Pi.one_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dens_inv [Fintype \u03b1] (s : Finset \u03b1) : s\u207b\u00b9.dens = s.dens := by simp [dens]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Finset/Density.lean", "context": {"open": ["scoped Pointwise"], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [InvolutiveInv \u03b1] {s : Finset \u03b1} {a : \u03b1} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : InvolutiveInv \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\n\u22a2 s\u207b\u00b9.dens = s.dens"}, {"line": "simp [dens]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dens_smul_finset [Fintype \u03b2] (a : \u03b1) (s : Finset \u03b2) : (a \u2022 s).dens = s.dens := by simp [dens]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Finset/Density.lean", "context": {"open": ["scoped Pointwise"], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] [InvolutiveInv \u03b1] {s : Finset \u03b1} {a : \u03b1} in", "[DecidableEq \u03b2] [Group \u03b1] [MulAction \u03b1 \u03b2] {s t : Finset \u03b2} {a : \u03b1} {b : \u03b2} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : InvolutiveInv \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b2\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : MulAction \u03b1 \u03b2\ninst\u271d : Fintype \u03b2\na : \u03b1\ns : Finset \u03b2\n\u22a2 (a \u2022 s).dens = s.dens"}, {"line": "simp [dens]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma subset_pow (hs : 1 \u2208 s) (hn : n \u2260 0) : s \u2286 s ^ n := by\n  simpa using pow_subset_pow_right hs <| Nat.one_le_iff_ne_zero.2 hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Finset/Basic.lean", "context": {"open": ["Function MulOpposite", "scoped Pointwise", "Pointwise", "scoped Pointwise", "Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[One \u03b1] {s : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [Inv \u03b1] {s t : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [InvolutiveInv \u03b1] {s : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [Mul \u03b1] [Mul \u03b2] [FunLike F \u03b1 \u03b2] [MulHomClass F \u03b1 \u03b2]", "[DecidableEq \u03b1] [Div \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[CommSemigroup \u03b1] {s t : Finset \u03b1}", "[MulOneClass \u03b1]", "[Monoid \u03b1] {s t : Finset \u03b1} {a : \u03b1} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u00b2 : One \u03b1\ninst\u271d\u00b9\u00b9 : DecidableEq \u03b1\ninst\u271d\u00b9\u2070 : Inv \u03b1\ninst\u271d\u2079 : DecidableEq \u03b1\ninst\u271d\u2078 : InvolutiveInv \u03b1\ninst\u271d\u2077 : DecidableEq \u03b1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : Div \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : CommSemigroup \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : Monoid \u03b1\ns : Finset \u03b1\nn : \u2115\nhs : 1 \u2208 s\nhn : n \u2260 0\n\u22a2 s \u2286 s ^ n"}, {"line": "simpa using pow_subset_pow_right hs <| Nat.one_le_iff_ne_zero.2 hn", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inter_pow_subset : (s \u2229 t) ^ n \u2286 s ^ n \u2229 t ^ n := by apply subset_inter <;> gcongr <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Finset/Basic.lean", "context": {"open": ["Function MulOpposite", "scoped Pointwise", "Pointwise", "scoped Pointwise", "Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[One \u03b1] {s : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [Inv \u03b1] {s t : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [InvolutiveInv \u03b1] {s : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [Mul \u03b1] [Mul \u03b2] [FunLike F \u03b1 \u03b2] [MulHomClass F \u03b1 \u03b2]", "[DecidableEq \u03b1] [Div \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[CommSemigroup \u03b1] {s t : Finset \u03b1}", "[MulOneClass \u03b1]", "[Monoid \u03b1] {s t : Finset \u03b1} {a : \u03b1} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u00b2 : One \u03b1\ninst\u271d\u00b9\u00b9 : DecidableEq \u03b1\ninst\u271d\u00b9\u2070 : Inv \u03b1\ninst\u271d\u2079 : DecidableEq \u03b1\ninst\u271d\u2078 : InvolutiveInv \u03b1\ninst\u271d\u2077 : DecidableEq \u03b1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : Div \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : CommSemigroup \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : Monoid \u03b1\ns t : Finset \u03b1\nn : \u2115\n\u22a2 (s \u2229 t) ^ n \u2286 s ^ n \u2229 t ^ n"}, {"line": "apply subset_inter <;> gcongr <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma empty_zpow (hn : n \u2260 0) : (\u2205 : Finset \u03b1) ^ n = \u2205 := by cases n <;> aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Finset/Basic.lean", "context": {"open": ["Function MulOpposite", "scoped Pointwise", "Pointwise", "scoped Pointwise", "Pointwise", "Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[One \u03b1] {s : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [Inv \u03b1] {s t : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [InvolutiveInv \u03b1] {s : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [Mul \u03b1] [Mul \u03b2] [FunLike F \u03b1 \u03b2] [MulHomClass F \u03b1 \u03b2]", "[DecidableEq \u03b1] [Div \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[CommSemigroup \u03b1] {s t : Finset \u03b1}", "[MulOneClass \u03b1]", "[Monoid \u03b1] {s t : Finset \u03b1} {a : \u03b1} {m n : \u2115}", "[CommMonoid \u03b1]", "[DivisionMonoid \u03b1] {s t : Finset \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2074 : One \u03b1\ninst\u271d\u00b9\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b9\u00b2 : Inv \u03b1\ninst\u271d\u00b9\u00b9 : DecidableEq \u03b1\ninst\u271d\u00b9\u2070 : InvolutiveInv \u03b1\ninst\u271d\u2079 : DecidableEq \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 : DecidableEq \u03b1\ninst\u271d\u2076 : Div \u03b1\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : CommSemigroup \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\nn : \u2124\nhn : n \u2260 0\n\u22a2 \u2205 ^ n = \u2205"}, {"line": "cases n <;> aesop", "tactic_state": "\u03b1 : Type u_2\ninst : One \u03b1\ninst_1 : DecidableEq \u03b1\ninst_2 : Inv \u03b1\ninst_3 : DecidableEq \u03b1\ninst_4 : InvolutiveInv \u03b1\ninst_5 : DecidableEq \u03b1\ninst_6 : Mul \u03b1\ninst_7 : DecidableEq \u03b1\ninst_8 : Div \u03b1\ninst_9 : DecidableEq \u03b1\ninst_10 : CommSemigroup \u03b1\ninst_11 : MulOneClass \u03b1\ninst_12 : Monoid \u03b1\ninst_13 : CommMonoid \u03b1\ninst_14 : DivisionMonoid \u03b1\na : \u2115\nhn : \u00aca = 0\n\u22a2 \u2205 ^ \u2191a = \u2205\n---\n\u03b1 : Type u_2\ninst : One \u03b1\ninst_1 : DecidableEq \u03b1\ninst_2 : Inv \u03b1\ninst_3 : DecidableEq \u03b1\ninst_4 : InvolutiveInv \u03b1\ninst_5 : DecidableEq \u03b1\ninst_6 : Mul \u03b1\ninst_7 : DecidableEq \u03b1\ninst_8 : Div \u03b1\ninst_9 : DecidableEq \u03b1\ninst_10 : CommSemigroup \u03b1\ninst_11 : MulOneClass \u03b1\ninst_12 : Monoid \u03b1\ninst_13 : CommMonoid \u03b1\ninst_14 : DivisionMonoid \u03b1\na : \u2115\n\u22a2 \u2205 ^ Int.negSucc a = \u2205"}]}
{"declaration": "lemma singleton_zpow (a : \u03b1) (n : \u2124) : ({a} : Finset \u03b1) ^ n = {a ^ n} := by cases n <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Finset/Basic.lean", "context": {"open": ["Function MulOpposite", "scoped Pointwise", "Pointwise", "scoped Pointwise", "Pointwise", "Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[One \u03b1] {s : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [Inv \u03b1] {s t : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [InvolutiveInv \u03b1] {s : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [Mul \u03b1] [Mul \u03b2] [FunLike F \u03b1 \u03b2] [MulHomClass F \u03b1 \u03b2]", "[DecidableEq \u03b1] [Div \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[CommSemigroup \u03b1] {s t : Finset \u03b1}", "[MulOneClass \u03b1]", "[Monoid \u03b1] {s t : Finset \u03b1} {a : \u03b1} {m n : \u2115}", "[CommMonoid \u03b1]", "[DivisionMonoid \u03b1] {s t : Finset \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u2074 : One \u03b1\ninst\u271d\u00b9\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b9\u00b2 : Inv \u03b1\ninst\u271d\u00b9\u00b9 : DecidableEq \u03b1\ninst\u271d\u00b9\u2070 : InvolutiveInv \u03b1\ninst\u271d\u2079 : DecidableEq \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 : DecidableEq \u03b1\ninst\u271d\u2076 : Div \u03b1\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : CommSemigroup \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na : \u03b1\nn : \u2124\n\u22a2 {a} ^ n = {a ^ n}"}, {"line": "cases n <;> simp", "tactic_state": "case ofNat\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2074 : One \u03b1\ninst\u271d\u00b9\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b9\u00b2 : Inv \u03b1\ninst\u271d\u00b9\u00b9 : DecidableEq \u03b1\ninst\u271d\u00b9\u2070 : InvolutiveInv \u03b1\ninst\u271d\u2079 : DecidableEq \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 : DecidableEq \u03b1\ninst\u271d\u2076 : Div \u03b1\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : CommSemigroup \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na : \u03b1\na\u271d : \u2115\n\u22a2 {a} ^ \u2191a\u271d = {a ^ a\u271d}\n---\ncase negSucc\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2074 : One \u03b1\ninst\u271d\u00b9\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b9\u00b2 : Inv \u03b1\ninst\u271d\u00b9\u00b9 : DecidableEq \u03b1\ninst\u271d\u00b9\u2070 : InvolutiveInv \u03b1\ninst\u271d\u2079 : DecidableEq \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 : DecidableEq \u03b1\ninst\u271d\u2076 : Div \u03b1\ninst\u271d\u2075 : DecidableEq \u03b1\ninst\u271d\u2074 : CommSemigroup \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na : \u03b1\na\u271d : \u2115\n\u22a2 {a} ^ Int.negSucc a\u271d = {(a ^ (a\u271d + 1))\u207b\u00b9}"}]}
{"declaration": "theorem isUnit_iff_singleton_aux {\u03b1} [Group \u03b1] {s : Finset \u03b1} :\n    (\u2203 a, s = {a} \u2227 IsUnit a) \u2194 \u2203 a, s = {a} := by\n  simp only [Group.isUnit]\n  simp only [and_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Finset/Basic.lean", "context": {"open": ["Function MulOpposite", "scoped Pointwise", "Pointwise", "scoped Pointwise", "Pointwise", "Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[One \u03b1] {s : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [Inv \u03b1] {s t : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [InvolutiveInv \u03b1] {s : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [Mul \u03b1] [Mul \u03b2] [FunLike F \u03b1 \u03b2] [MulHomClass F \u03b1 \u03b2]", "[DecidableEq \u03b1] [Div \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[CommSemigroup \u03b1] {s t : Finset \u03b1}", "[MulOneClass \u03b1]", "[Monoid \u03b1] {s t : Finset \u03b1} {a : \u03b1} {m n : \u2115}", "[CommMonoid \u03b1]", "[DivisionMonoid \u03b1] {s t : Finset \u03b1} {n : \u2124}", "[Group \u03b1] [DivisionMonoid \u03b2] [FunLike F \u03b1 \u03b2] [MonoidHomClass F \u03b1 \u03b2]", "(f : F) {s t : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d : Group \u03b1\ns : Finset \u03b1\n\u22a2 (\u2203 a, s = {a} \u2227 IsUnit a) \u2194 \u2203 a, s = {a}"}, {"line": "simp only [Group.isUnit]", "tactic_state": "\u03b1 : Type u_5\ninst\u271d : Group \u03b1\ns : Finset \u03b1\n\u22a2 (\u2203 a, s = {a} \u2227 True) \u2194 \u2203 a, s = {a}"}, {"line": "simp only [and_true]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_mul_left' :\n    image (fun b => a\u207b\u00b9 * b) t = preimage t (fun b => a * b) (mul_right_injective _).injOn := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Finset/Basic.lean", "context": {"open": ["Function MulOpposite", "scoped Pointwise", "Pointwise", "scoped Pointwise", "Pointwise", "Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[One \u03b1] {s : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [Inv \u03b1] {s t : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [InvolutiveInv \u03b1] {s : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [Mul \u03b1] [Mul \u03b2] [FunLike F \u03b1 \u03b2] [MulHomClass F \u03b1 \u03b2]", "[DecidableEq \u03b1] [Div \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[CommSemigroup \u03b1] {s t : Finset \u03b1}", "[MulOneClass \u03b1]", "[Monoid \u03b1] {s t : Finset \u03b1} {a : \u03b1} {m n : \u2115}", "[CommMonoid \u03b1]", "[DivisionMonoid \u03b1] {s t : Finset \u03b1} {n : \u2124}", "[Group \u03b1] [DivisionMonoid \u03b2] [FunLike F \u03b1 \u03b2] [MonoidHomClass F \u03b1 \u03b2]", "(f : F) {s t : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_5\nimage : x\u271d\u00b9\nx\u271d : Sort u_6\npreimage : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "x\u271d\u00b9 : Sort u_5\nimage : x\u271d\u00b9\nx\u271d : Sort u_6\npreimage : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem image_mul_right' :\n    image (\u00b7 * b\u207b\u00b9) t = preimage t (\u00b7 * b) (mul_left_injective _).injOn := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Finset/Basic.lean", "context": {"open": ["Function MulOpposite", "scoped Pointwise", "Pointwise", "scoped Pointwise", "Pointwise", "Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[One \u03b1] {s : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [Inv \u03b1] {s t : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [InvolutiveInv \u03b1] {s : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [Mul \u03b1] [Mul \u03b2] [FunLike F \u03b1 \u03b2] [MulHomClass F \u03b1 \u03b2]", "[DecidableEq \u03b1] [Div \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[CommSemigroup \u03b1] {s t : Finset \u03b1}", "[MulOneClass \u03b1]", "[Monoid \u03b1] {s t : Finset \u03b1} {a : \u03b1} {m n : \u2115}", "[CommMonoid \u03b1]", "[DivisionMonoid \u03b1] {s t : Finset \u03b1} {n : \u2124}", "[Group \u03b1] [DivisionMonoid \u03b2] [FunLike F \u03b1 \u03b2] [MonoidHomClass F \u03b1 \u03b2]", "(f : F) {s t : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_5\nimage : x\u271d\u00b9\nx\u271d : Sort u_6\npreimage : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "x\u271d\u00b9 : Sort u_5\nimage : x\u271d\u00b9\nx\u271d : Sort u_6\npreimage : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma Nontrivial.mul_right : s.Nontrivial \u2192 t.Nonempty \u2192 (s * t).Nontrivial := by\n  rintro \u27e8a, ha, b, hb, hab\u27e9 \u27e8c, hc\u27e9\n  exact \u27e8a * c, mul_mem_mul ha hc, b * c, mul_mem_mul hb hc, by simpa\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Finset/Basic.lean", "context": {"open": ["Function MulOpposite", "scoped Pointwise", "Pointwise", "scoped Pointwise", "Pointwise", "Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[One \u03b1] {s : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [Inv \u03b1] {s t : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [InvolutiveInv \u03b1] {s : Finset \u03b1} {a : \u03b1}", "[DecidableEq \u03b1] [Mul \u03b1] [Mul \u03b2] [FunLike F \u03b1 \u03b2] [MulHomClass F \u03b1 \u03b2]", "[DecidableEq \u03b1] [Div \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] [DecidableEq \u03b2]", "[CommSemigroup \u03b1] {s t : Finset \u03b1}", "[MulOneClass \u03b1]", "[Monoid \u03b1] {s t : Finset \u03b1} {a : \u03b1} {m n : \u2115}", "[CommMonoid \u03b1]", "[DivisionMonoid \u03b1] {s t : Finset \u03b1} {n : \u2124}", "[Group \u03b1] [DivisionMonoid \u03b2] [FunLike F \u03b1 \u03b2] [MonoidHomClass F \u03b1 \u03b2]", "(f : F) {s t : Finset \u03b1} {a b : \u03b1}", "[Group \u03b1] {a b : \u03b1}", "[DecidableEq \u03b1] [DecidableEq \u03b2] [Monoid \u03b1] [Monoid \u03b2] [FunLike F \u03b1 \u03b2]", "[Mul \u03b1] [IsLeftCancelMul \u03b1] [DecidableEq \u03b1] {s t : Finset \u03b1} {a : \u03b1}", "[Mul \u03b1] [IsRightCancelMul \u03b1] [DecidableEq \u03b1] {s t : Finset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2\u2074 : One \u03b1\ninst\u271d\u00b2\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2\u00b2 : Inv \u03b1\ninst\u271d\u00b2\u00b9 : DecidableEq \u03b1\ninst\u271d\u00b2\u2070 : InvolutiveInv \u03b1\ninst\u271d\u00b9\u2079 : DecidableEq \u03b1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : DecidableEq \u03b1\ninst\u271d\u00b9\u2076 : Div \u03b1\ninst\u271d\u00b9\u2075 : DecidableEq \u03b1\ninst\u271d\u00b9\u2074 : CommSemigroup \u03b1\ninst\u271d\u00b9\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b9\u00b2 : Monoid \u03b1\ninst\u271d\u00b9\u00b9 : CommMonoid \u03b1\ninst\u271d\u00b9\u2070 : DivisionMonoid \u03b1\ninst\u271d\u2079 inst\u271d\u2078 : Group \u03b1\ninst\u271d\u2077 : DecidableEq \u03b1\ninst\u271d\u2076 : Monoid \u03b1\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 : IsLeftCancelMul \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : IsRightCancelMul \u03b1\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\n\u22a2 s.Nontrivial \u2192 t.Nonempty \u2192 (s * t).Nontrivial"}, {"line": "rintro \u27e8a, ha, b, hb, hab\u27e9 \u27e8c, hc\u27e9", "tactic_state": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_2\ninst\u271d\u00b2\u2074 : One \u03b1\ninst\u271d\u00b2\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2\u00b2 : Inv \u03b1\ninst\u271d\u00b2\u00b9 : DecidableEq \u03b1\ninst\u271d\u00b2\u2070 : InvolutiveInv \u03b1\ninst\u271d\u00b9\u2079 : DecidableEq \u03b1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : DecidableEq \u03b1\ninst\u271d\u00b9\u2076 : Div \u03b1\ninst\u271d\u00b9\u2075 : DecidableEq \u03b1\ninst\u271d\u00b9\u2074 : CommSemigroup \u03b1\ninst\u271d\u00b9\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b9\u00b2 : Monoid \u03b1\ninst\u271d\u00b9\u00b9 : CommMonoid \u03b1\ninst\u271d\u00b9\u2070 : DivisionMonoid \u03b1\ninst\u271d\u2079 inst\u271d\u2078 : Group \u03b1\ninst\u271d\u2077 : DecidableEq \u03b1\ninst\u271d\u2076 : Monoid \u03b1\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 : IsLeftCancelMul \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : IsRightCancelMul \u03b1\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\na : \u03b1\nha : a \u2208 \u2191s\nb : \u03b1\nhb : b \u2208 \u2191s\nhab : a \u2260 b\nc : \u03b1\nhc : c \u2208 t\n\u22a2 (s * t).Nontrivial"}, {"line": "exact \u27e8a * c, mul_mem_mul ha hc, b * c, mul_mem_mul hb hc, by simpa\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma encard_inv (s : Set G) : s\u207b\u00b9.encard = s.encard := by\n  simp [ENat.card, \u2190 toENat_cardinalMk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Set/Card.lean", "context": {"open": ["scoped Cardinal Pointwise"], "variables": ["{G M \u03b1 : Type*}", "[Mul M] {s t : Set M}", "[IsCancelMul M]", "[InvolutiveInv G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : InvolutiveInv G\ns : Set G\n\u22a2 s\u207b\u00b9.encard = s.encard"}, {"line": "simp [ENat.card, \u2190 toENat_cardinalMk]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ncard_inv (s : Set G) : s\u207b\u00b9.ncard = s.ncard := by simp [ncard]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Set/Card.lean", "context": {"open": ["scoped Cardinal Pointwise"], "variables": ["{G M \u03b1 : Type*}", "[Mul M] {s t : Set M}", "[IsCancelMul M]", "[InvolutiveInv G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : InvolutiveInv G\ns : Set G\n\u22a2 s\u207b\u00b9.ncard = s.ncard"}, {"line": "simp [ncard]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma encard_smul_set (a : G) (s : Set \u03b1) : (a \u2022 s).encard = s.encard := by\n  simp [ENat.card, \u2190 toENat_cardinalMk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Set/Card.lean", "context": {"open": ["scoped Cardinal Pointwise"], "variables": ["{G M \u03b1 : Type*}", "[Mul M] {s t : Set M}", "[IsCancelMul M]", "[InvolutiveInv G]", "[DivInvMonoid M] {s t : Set M}", "[Group G] {s t : Set G}", "[MulAction G \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u00b2 : InvolutiveInv G\ninst\u271d\u00b9 : Group G\ninst\u271d : MulAction G \u03b1\na : G\ns : Set \u03b1\n\u22a2 (a \u2022 s).encard = s.encard"}, {"line": "simp [ENat.card, \u2190 toENat_cardinalMk]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ncard_smul_set (a : G) (s : Set \u03b1) : (a \u2022 s).ncard = s.ncard := by simp [ncard]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Set/Card.lean", "context": {"open": ["scoped Cardinal Pointwise"], "variables": ["{G M \u03b1 : Type*}", "[Mul M] {s t : Set M}", "[IsCancelMul M]", "[InvolutiveInv G]", "[DivInvMonoid M] {s t : Set M}", "[Group G] {s t : Set G}", "[MulAction G \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u00b2 : InvolutiveInv G\ninst\u271d\u00b9 : Group G\ninst\u271d : MulAction G \u03b1\na : G\ns : Set \u03b1\n\u22a2 (a \u2022 s).ncard = s.ncard"}, {"line": "simp [ncard]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma subset_pow (hs : 1 \u2208 s) (hn : n \u2260 0) : s \u2286 s ^ n := by\n  simpa using pow_subset_pow_right hs <| Nat.one_le_iff_ne_zero.2 hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Set/Basic.lean", "context": {"open": ["Function MulOpposite", "Pointwise", "Pointwise", "MulOpposite", "Pointwise", "MulOpposite"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[One \u03b1] {s : Set \u03b1} {a : \u03b1}", "{\u03b9 : Sort*} [Inv \u03b1] {s t : Set \u03b1} {a : \u03b1}", "[InvolutiveInv \u03b1] {s t : Set \u03b1} {a : \u03b1}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Mul \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Div \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "[CommSemigroup \u03b1] {s t : Set \u03b1}", "[MulOneClass \u03b1]", "[Monoid \u03b1] {s t : Set \u03b1} {a : \u03b1} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2077 : One \u03b1\ninst\u271d\u2076 : Inv \u03b1\ninst\u271d\u2075 : InvolutiveInv \u03b1\ninst\u271d\u2074 : Mul \u03b1\ninst\u271d\u00b3 : Div \u03b1\ninst\u271d\u00b2 : CommSemigroup \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : Monoid \u03b1\ns : Set \u03b1\nn : \u2115\nhs : 1 \u2208 s\nhn : n \u2260 0\n\u22a2 s \u2286 s ^ n"}, {"line": "simpa using pow_subset_pow_right hs <| Nat.one_le_iff_ne_zero.2 hn", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inter_pow_subset : (s \u2229 t) ^ n \u2286 s ^ n \u2229 t ^ n := by apply subset_inter <;> gcongr <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Set/Basic.lean", "context": {"open": ["Function MulOpposite", "Pointwise", "Pointwise", "MulOpposite", "Pointwise", "MulOpposite"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[One \u03b1] {s : Set \u03b1} {a : \u03b1}", "{\u03b9 : Sort*} [Inv \u03b1] {s t : Set \u03b1} {a : \u03b1}", "[InvolutiveInv \u03b1] {s t : Set \u03b1} {a : \u03b1}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Mul \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Div \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "[CommSemigroup \u03b1] {s t : Set \u03b1}", "[MulOneClass \u03b1]", "[Monoid \u03b1] {s t : Set \u03b1} {a : \u03b1} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2077 : One \u03b1\ninst\u271d\u2076 : Inv \u03b1\ninst\u271d\u2075 : InvolutiveInv \u03b1\ninst\u271d\u2074 : Mul \u03b1\ninst\u271d\u00b3 : Div \u03b1\ninst\u271d\u00b2 : CommSemigroup \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : Monoid \u03b1\ns t : Set \u03b1\nn : \u2115\n\u22a2 (s \u2229 t) ^ n \u2286 s ^ n \u2229 t ^ n"}, {"line": "apply subset_inter <;> gcongr <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Nontrivial.mul_left : t.Nontrivial \u2192 s.Nonempty \u2192 (s * t).Nontrivial := by\n  rintro \u27e8a, ha, b, hb, hab\u27e9 \u27e8c, hc\u27e9\n  exact \u27e8c * a, mul_mem_mul hc ha, c * b, mul_mem_mul hc hb, by simpa\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Set/Basic.lean", "context": {"open": ["Function MulOpposite", "Pointwise", "Pointwise", "MulOpposite", "Pointwise", "MulOpposite"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[One \u03b1] {s : Set \u03b1} {a : \u03b1}", "{\u03b9 : Sort*} [Inv \u03b1] {s t : Set \u03b1} {a : \u03b1}", "[InvolutiveInv \u03b1] {s t : Set \u03b1} {a : \u03b1}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Mul \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Div \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "[CommSemigroup \u03b1] {s t : Set \u03b1}", "[MulOneClass \u03b1]", "[Monoid \u03b1] {s t : Set \u03b1} {a : \u03b1} {m n : \u2115}", "[Mul \u03b1] [IsLeftCancelMul \u03b1] {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2079 : One \u03b1\ninst\u271d\u2078 : Inv \u03b1\ninst\u271d\u2077 : InvolutiveInv \u03b1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : Div \u03b1\ninst\u271d\u2074 : CommSemigroup \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : IsLeftCancelMul \u03b1\ns t : Set \u03b1\n\u22a2 t.Nontrivial \u2192 s.Nonempty \u2192 (s * t).Nontrivial"}, {"line": "rintro \u27e8a, ha, b, hb, hab\u27e9 \u27e8c, hc\u27e9", "tactic_state": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_2\ninst\u271d\u2079 : One \u03b1\ninst\u271d\u2078 : Inv \u03b1\ninst\u271d\u2077 : InvolutiveInv \u03b1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : Div \u03b1\ninst\u271d\u2074 : CommSemigroup \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : IsLeftCancelMul \u03b1\ns t : Set \u03b1\na : \u03b1\nha : a \u2208 t\nb : \u03b1\nhb : b \u2208 t\nhab : a \u2260 b\nc : \u03b1\nhc : c \u2208 s\n\u22a2 (s * t).Nontrivial"}, {"line": "exact \u27e8c * a, mul_mem_mul hc ha, c * b, mul_mem_mul hc hb, by simpa\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Nontrivial.mul_right : s.Nontrivial \u2192 t.Nonempty \u2192 (s * t).Nontrivial := by\n  rintro \u27e8a, ha, b, hb, hab\u27e9 \u27e8c, hc\u27e9\n  exact \u27e8a * c, mul_mem_mul ha hc, b * c, mul_mem_mul hb hc, by simpa\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Set/Basic.lean", "context": {"open": ["Function MulOpposite", "Pointwise", "Pointwise", "MulOpposite", "Pointwise", "MulOpposite"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[One \u03b1] {s : Set \u03b1} {a : \u03b1}", "{\u03b9 : Sort*} [Inv \u03b1] {s t : Set \u03b1} {a : \u03b1}", "[InvolutiveInv \u03b1] {s t : Set \u03b1} {a : \u03b1}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Mul \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Div \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "[CommSemigroup \u03b1] {s t : Set \u03b1}", "[MulOneClass \u03b1]", "[Monoid \u03b1] {s t : Set \u03b1} {a : \u03b1} {m n : \u2115}", "[Mul \u03b1] [IsLeftCancelMul \u03b1] {s t : Set \u03b1}", "[Mul \u03b1] [IsRightCancelMul \u03b1] {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u00b9 : One \u03b1\ninst\u271d\u00b9\u2070 : Inv \u03b1\ninst\u271d\u2079 : InvolutiveInv \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 : Div \u03b1\ninst\u271d\u2076 : CommSemigroup \u03b1\ninst\u271d\u2075 : MulOneClass \u03b1\ninst\u271d\u2074 : Monoid \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : IsLeftCancelMul \u03b1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : IsRightCancelMul \u03b1\ns t : Set \u03b1\n\u22a2 s.Nontrivial \u2192 t.Nonempty \u2192 (s * t).Nontrivial"}, {"line": "rintro \u27e8a, ha, b, hb, hab\u27e9 \u27e8c, hc\u27e9", "tactic_state": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_2\ninst\u271d\u00b9\u00b9 : One \u03b1\ninst\u271d\u00b9\u2070 : Inv \u03b1\ninst\u271d\u2079 : InvolutiveInv \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 : Div \u03b1\ninst\u271d\u2076 : CommSemigroup \u03b1\ninst\u271d\u2075 : MulOneClass \u03b1\ninst\u271d\u2074 : Monoid \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : IsLeftCancelMul \u03b1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : IsRightCancelMul \u03b1\ns t : Set \u03b1\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : a \u2260 b\nc : \u03b1\nhc : c \u2208 t\n\u22a2 (s * t).Nontrivial"}, {"line": "exact \u27e8a * c, mul_mem_mul ha hc, b * c, mul_mem_mul hb hc, by simpa\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma empty_zpow (hn : n \u2260 0) : (\u2205 : Set \u03b1) ^ n = \u2205 := by cases n <;> aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Set/Basic.lean", "context": {"open": ["Function MulOpposite", "Pointwise", "Pointwise", "MulOpposite", "Pointwise", "MulOpposite", "Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[One \u03b1] {s : Set \u03b1} {a : \u03b1}", "{\u03b9 : Sort*} [Inv \u03b1] {s t : Set \u03b1} {a : \u03b1}", "[InvolutiveInv \u03b1] {s t : Set \u03b1} {a : \u03b1}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Mul \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Div \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "[CommSemigroup \u03b1] {s t : Set \u03b1}", "[MulOneClass \u03b1]", "[Monoid \u03b1] {s t : Set \u03b1} {a : \u03b1} {m n : \u2115}", "[Mul \u03b1] [IsLeftCancelMul \u03b1] {s t : Set \u03b1}", "[Mul \u03b1] [IsRightCancelMul \u03b1] {s t : Set \u03b1}", "[CancelMonoid \u03b1] {s t : Set \u03b1} {a : \u03b1} {n : \u2115}", "[DivisionMonoid \u03b1] {s t : Set \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u00b3 : One \u03b1\ninst\u271d\u00b9\u00b2 : Inv \u03b1\ninst\u271d\u00b9\u00b9 : InvolutiveInv \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 : Div \u03b1\ninst\u271d\u2078 : CommSemigroup \u03b1\ninst\u271d\u2077 : MulOneClass \u03b1\ninst\u271d\u2076 : Monoid \u03b1\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 : IsLeftCancelMul \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : IsRightCancelMul \u03b1\ninst\u271d\u00b9 : CancelMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\nn : \u2124\nhn : n \u2260 0\n\u22a2 \u2205 ^ n = \u2205"}, {"line": "cases n <;> aesop", "tactic_state": "\u03b1 : Type u_2\ninst : One \u03b1\ninst_1 : Inv \u03b1\ninst_2 : InvolutiveInv \u03b1\ninst_3 : Mul \u03b1\ninst_4 : Div \u03b1\ninst_5 : CommSemigroup \u03b1\ninst_6 : MulOneClass \u03b1\ninst_7 : Monoid \u03b1\ninst_8 : Mul \u03b1\ninst_9 : IsLeftCancelMul \u03b1\ninst_10 : Mul \u03b1\ninst_11 : IsRightCancelMul \u03b1\ninst_12 : CancelMonoid \u03b1\ninst_13 : DivisionMonoid \u03b1\na : \u2115\nhn : \u00aca = 0\n\u22a2 \u2205 ^ \u2191a = \u2205\n---\n\u03b1 : Type u_2\ninst : One \u03b1\ninst_1 : Inv \u03b1\ninst_2 : InvolutiveInv \u03b1\ninst_3 : Mul \u03b1\ninst_4 : Div \u03b1\ninst_5 : CommSemigroup \u03b1\ninst_6 : MulOneClass \u03b1\ninst_7 : Monoid \u03b1\ninst_8 : Mul \u03b1\ninst_9 : IsLeftCancelMul \u03b1\ninst_10 : Mul \u03b1\ninst_11 : IsRightCancelMul \u03b1\ninst_12 : CancelMonoid \u03b1\ninst_13 : DivisionMonoid \u03b1\na : \u2115\n\u22a2 \u2205 ^ Int.negSucc a = \u2205"}]}
{"declaration": "lemma singleton_zpow (a : \u03b1) (n : \u2124) : ({a} : Set \u03b1) ^ n = {a ^ n} := by cases n <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Set/Basic.lean", "context": {"open": ["Function MulOpposite", "Pointwise", "Pointwise", "MulOpposite", "Pointwise", "MulOpposite", "Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[One \u03b1] {s : Set \u03b1} {a : \u03b1}", "{\u03b9 : Sort*} [Inv \u03b1] {s t : Set \u03b1} {a : \u03b1}", "[InvolutiveInv \u03b1] {s t : Set \u03b1} {a : \u03b1}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Mul \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Div \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "[CommSemigroup \u03b1] {s t : Set \u03b1}", "[MulOneClass \u03b1]", "[Monoid \u03b1] {s t : Set \u03b1} {a : \u03b1} {m n : \u2115}", "[Mul \u03b1] [IsLeftCancelMul \u03b1] {s t : Set \u03b1}", "[Mul \u03b1] [IsRightCancelMul \u03b1] {s t : Set \u03b1}", "[CancelMonoid \u03b1] {s t : Set \u03b1} {a : \u03b1} {n : \u2115}", "[DivisionMonoid \u03b1] {s t : Set \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9\u00b3 : One \u03b1\ninst\u271d\u00b9\u00b2 : Inv \u03b1\ninst\u271d\u00b9\u00b9 : InvolutiveInv \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 : Div \u03b1\ninst\u271d\u2078 : CommSemigroup \u03b1\ninst\u271d\u2077 : MulOneClass \u03b1\ninst\u271d\u2076 : Monoid \u03b1\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 : IsLeftCancelMul \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : IsRightCancelMul \u03b1\ninst\u271d\u00b9 : CancelMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na : \u03b1\nn : \u2124\n\u22a2 {a} ^ n = {a ^ n}"}, {"line": "cases n <;> simp", "tactic_state": "case ofNat\n\u03b1 : Type u_2\ninst\u271d\u00b9\u00b3 : One \u03b1\ninst\u271d\u00b9\u00b2 : Inv \u03b1\ninst\u271d\u00b9\u00b9 : InvolutiveInv \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 : Div \u03b1\ninst\u271d\u2078 : CommSemigroup \u03b1\ninst\u271d\u2077 : MulOneClass \u03b1\ninst\u271d\u2076 : Monoid \u03b1\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 : IsLeftCancelMul \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : IsRightCancelMul \u03b1\ninst\u271d\u00b9 : CancelMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na : \u03b1\na\u271d : \u2115\n\u22a2 {a} ^ \u2191a\u271d = {a ^ a\u271d}\n---\ncase negSucc\n\u03b1 : Type u_2\ninst\u271d\u00b9\u00b3 : One \u03b1\ninst\u271d\u00b9\u00b2 : Inv \u03b1\ninst\u271d\u00b9\u00b9 : InvolutiveInv \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 : Div \u03b1\ninst\u271d\u2078 : CommSemigroup \u03b1\ninst\u271d\u2077 : MulOneClass \u03b1\ninst\u271d\u2076 : Monoid \u03b1\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 : IsLeftCancelMul \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : IsRightCancelMul \u03b1\ninst\u271d\u00b9 : CancelMonoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\na : \u03b1\na\u271d : \u2115\n\u22a2 {a} ^ Int.negSucc a\u271d = {(a ^ (a\u271d + 1))\u207b\u00b9}"}]}
{"declaration": "theorem preimage_mul_preimage_subset {s t : Set \u03b2} : m \u207b\u00b9' s * m \u207b\u00b9' t \u2286 m \u207b\u00b9' (s * t) := by\n  rintro _ \u27e8_, _, _, _, rfl\u27e9\n  exact \u27e8_, \u2039_\u203a, _, \u2039_\u203a, (map_mul m ..).symm\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Set/Basic.lean", "context": {"open": ["Function MulOpposite", "Pointwise", "Pointwise", "MulOpposite", "Pointwise", "MulOpposite", "Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[One \u03b1] {s : Set \u03b1} {a : \u03b1}", "{\u03b9 : Sort*} [Inv \u03b1] {s t : Set \u03b1} {a : \u03b1}", "[InvolutiveInv \u03b1] {s t : Set \u03b1} {a : \u03b1}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Mul \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Div \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "[CommSemigroup \u03b1] {s t : Set \u03b1}", "[MulOneClass \u03b1]", "[Monoid \u03b1] {s t : Set \u03b1} {a : \u03b1} {m n : \u2115}", "[Mul \u03b1] [IsLeftCancelMul \u03b1] {s t : Set \u03b1}", "[Mul \u03b1] [IsRightCancelMul \u03b1] {s t : Set \u03b1}", "[CancelMonoid \u03b1] {s t : Set \u03b1} {a : \u03b1} {n : \u2115}", "[DivisionMonoid \u03b1] {s t : Set \u03b1} {n : \u2124}", "[Group \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[Mul \u03b1] [Mul \u03b2] [FunLike F \u03b1 \u03b2] [MulHomClass F \u03b1 \u03b2] (m : F) {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9\u2078 : One \u03b1\ninst\u271d\u00b9\u2077 : Inv \u03b1\ninst\u271d\u00b9\u2076 : InvolutiveInv \u03b1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 : Div \u03b1\ninst\u271d\u00b9\u00b3 : CommSemigroup \u03b1\ninst\u271d\u00b9\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b9\u00b9 : Monoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 : IsLeftCancelMul \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 : IsRightCancelMul \u03b1\ninst\u271d\u2076 : CancelMonoid \u03b1\ninst\u271d\u2075 : DivisionMonoid \u03b1\ninst\u271d\u2074 : Group \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MulHomClass F \u03b1 \u03b2\nm : F\ns t : Set \u03b2\n\u22a2 \u21d1m \u207b\u00b9' s * \u21d1m \u207b\u00b9' t \u2286 \u21d1m \u207b\u00b9' (s * t)"}, {"line": "rintro _ \u27e8_, _, _, _, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9\u2078 : One \u03b1\ninst\u271d\u00b9\u2077 : Inv \u03b1\ninst\u271d\u00b9\u2076 : InvolutiveInv \u03b1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 : Div \u03b1\ninst\u271d\u00b9\u00b3 : CommSemigroup \u03b1\ninst\u271d\u00b9\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b9\u00b9 : Monoid \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 : IsLeftCancelMul \u03b1\ninst\u271d\u2078 : Mul \u03b1\ninst\u271d\u2077 : IsRightCancelMul \u03b1\ninst\u271d\u2076 : CancelMonoid \u03b1\ninst\u271d\u2075 : DivisionMonoid \u03b1\ninst\u271d\u2074 : Group \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MulHomClass F \u03b1 \u03b2\nm : F\ns t : Set \u03b2\nw\u271d\u00b9 : \u03b1\nleft\u271d\u00b9 : w\u271d\u00b9 \u2208 \u21d1m \u207b\u00b9' s\nw\u271d : \u03b1\nleft\u271d : w\u271d \u2208 \u21d1m \u207b\u00b9' t\n\u22a2 (fun x1 x2 => x1 * x2) w\u271d\u00b9 w\u271d \u2208 \u21d1m \u207b\u00b9' (s * t)"}, {"line": "exact \u27e8_, \u2039_\u203a, _, \u2039_\u203a, (map_mul m ..).symm\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_div_preimage_subset {s t : Set \u03b2} : m \u207b\u00b9' s / m \u207b\u00b9' t \u2286 m \u207b\u00b9' (s / t) := by\n  rintro _ \u27e8_, _, _, _, rfl\u27e9\n  exact \u27e8_, \u2039_\u203a, _, \u2039_\u203a, (map_div m ..).symm\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Set/Basic.lean", "context": {"open": ["Function MulOpposite", "Pointwise", "Pointwise", "MulOpposite", "Pointwise", "MulOpposite", "Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[One \u03b1] {s : Set \u03b1} {a : \u03b1}", "{\u03b9 : Sort*} [Inv \u03b1] {s t : Set \u03b1} {a : \u03b1}", "[InvolutiveInv \u03b1] {s t : Set \u03b1} {a : \u03b1}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Mul \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "{\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} [Div \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1} {a b : \u03b1}", "[CommSemigroup \u03b1] {s t : Set \u03b1}", "[MulOneClass \u03b1]", "[Monoid \u03b1] {s t : Set \u03b1} {a : \u03b1} {m n : \u2115}", "[Mul \u03b1] [IsLeftCancelMul \u03b1] {s t : Set \u03b1}", "[Mul \u03b1] [IsRightCancelMul \u03b1] {s t : Set \u03b1}", "[CancelMonoid \u03b1] {s t : Set \u03b1} {a : \u03b1} {n : \u2115}", "[DivisionMonoid \u03b1] {s t : Set \u03b1} {n : \u2124}", "[Group \u03b1] {s t : Set \u03b1} {a b : \u03b1}", "[Mul \u03b1] [Mul \u03b2] [FunLike F \u03b1 \u03b2] [MulHomClass F \u03b1 \u03b2] (m : F) {s t : Set \u03b1}", "[Monoid \u03b1] [Monoid \u03b2] [FunLike F \u03b1 \u03b2]", "[Group \u03b1] [DivisionMonoid \u03b2] [FunLike F \u03b1 \u03b2] [MonoidHomClass F \u03b1 \u03b2] (m : F) {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2\u2075 : One \u03b1\ninst\u271d\u00b2\u2074 : Inv \u03b1\ninst\u271d\u00b2\u00b3 : InvolutiveInv \u03b1\ninst\u271d\u00b2\u00b2 : Mul \u03b1\ninst\u271d\u00b2\u00b9 : Div \u03b1\ninst\u271d\u00b2\u2070 : CommSemigroup \u03b1\ninst\u271d\u00b9\u2079 : MulOneClass \u03b1\ninst\u271d\u00b9\u2078 : Monoid \u03b1\ninst\u271d\u00b9\u2077 : Mul \u03b1\ninst\u271d\u00b9\u2076 : IsLeftCancelMul \u03b1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 : IsRightCancelMul \u03b1\ninst\u271d\u00b9\u00b3 : CancelMonoid \u03b1\ninst\u271d\u00b9\u00b2 : DivisionMonoid \u03b1\ninst\u271d\u00b9\u00b9 : Group \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 : Mul \u03b2\ninst\u271d\u2078 : FunLike F \u03b1 \u03b2\ninst\u271d\u2077 : MulHomClass F \u03b1 \u03b2\ninst\u271d\u2076 : Monoid \u03b1\ninst\u271d\u2075 : Monoid \u03b2\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : DivisionMonoid \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\nm : F\ns t : Set \u03b2\n\u22a2 \u21d1m \u207b\u00b9' s / \u21d1m \u207b\u00b9' t \u2286 \u21d1m \u207b\u00b9' (s / t)"}, {"line": "rintro _ \u27e8_, _, _, _, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2\u2075 : One \u03b1\ninst\u271d\u00b2\u2074 : Inv \u03b1\ninst\u271d\u00b2\u00b3 : InvolutiveInv \u03b1\ninst\u271d\u00b2\u00b2 : Mul \u03b1\ninst\u271d\u00b2\u00b9 : Div \u03b1\ninst\u271d\u00b2\u2070 : CommSemigroup \u03b1\ninst\u271d\u00b9\u2079 : MulOneClass \u03b1\ninst\u271d\u00b9\u2078 : Monoid \u03b1\ninst\u271d\u00b9\u2077 : Mul \u03b1\ninst\u271d\u00b9\u2076 : IsLeftCancelMul \u03b1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 : IsRightCancelMul \u03b1\ninst\u271d\u00b9\u00b3 : CancelMonoid \u03b1\ninst\u271d\u00b9\u00b2 : DivisionMonoid \u03b1\ninst\u271d\u00b9\u00b9 : Group \u03b1\ninst\u271d\u00b9\u2070 : Mul \u03b1\ninst\u271d\u2079 : Mul \u03b2\ninst\u271d\u2078 : FunLike F \u03b1 \u03b2\ninst\u271d\u2077 : MulHomClass F \u03b1 \u03b2\ninst\u271d\u2076 : Monoid \u03b1\ninst\u271d\u2075 : Monoid \u03b2\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : DivisionMonoid \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\nm : F\ns t : Set \u03b2\nw\u271d\u00b9 : \u03b1\nleft\u271d\u00b9 : w\u271d\u00b9 \u2208 \u21d1m \u207b\u00b9' s\nw\u271d : \u03b1\nleft\u271d : w\u271d \u2208 \u21d1m \u207b\u00b9' t\n\u22a2 (fun x1 x2 => x1 / x2) w\u271d\u00b9 w\u271d \u2208 \u21d1m \u207b\u00b9' (s / t)"}, {"line": "exact \u27e8_, \u2039_\u203a, _, \u2039_\u203a, (map_div m ..).symm\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_pow_iff_prod {n : \u2115} {s : Set \u03b1} {a : \u03b1} :\n    a \u2208 s ^ n \u2194 \u2203 f : Fin n \u2192 \u03b1, (\u2200 i, f i \u2208 s) \u2227 \u220f i, f i = a := by\n  simpa using mem_finset_prod (t := .univ) (f := fun _ : Fin n \u21a6 s) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Set/BigOperators.lean", "context": {"open": ["Pointwise Function"], "variables": ["{\u03b9 \u03b1 \u03b2 F : Type*} [FunLike F \u03b1 \u03b2]", "[Monoid \u03b1] [Monoid \u03b2] [MonoidHomClass F \u03b1 \u03b2]", "[CommMonoid \u03b1] [CommMonoid \u03b2] [MonoidHomClass F \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : CommMonoid \u03b1\nn : \u2115\ns : Set \u03b1\na : \u03b1\n\u22a2 a \u2208 s ^ n \u2194 \u2203 f, (\u2200 (i : Fin n), f i \u2208 s) \u2227 \u220f i, f i = a"}, {"line": "simpa using mem_finset_prod (t := .univ) (f := fun _ : Fin n \u21a6 s) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiset_prod_mem_multiset_prod (t : Multiset \u03b9) (f : \u03b9 \u2192 Set \u03b1) (g : \u03b9 \u2192 \u03b1)\n    (hg : \u2200 i \u2208 t, g i \u2208 f i) : (t.map g).prod \u2208 (t.map f).prod := by\n  induction t using Quotient.inductionOn\n  simp_rw [Multiset.quot_mk_to_coe, Multiset.map_coe, Multiset.prod_coe]\n  exact list_prod_mem_list_prod _ _ _ hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Set/BigOperators.lean", "context": {"open": ["Pointwise Function"], "variables": ["{\u03b9 \u03b1 \u03b2 F : Type*} [FunLike F \u03b1 \u03b2]", "[Monoid \u03b1] [Monoid \u03b2] [MonoidHomClass F \u03b1 \u03b2]", "[CommMonoid \u03b1] [CommMonoid \u03b2] [MonoidHomClass F \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : CommMonoid \u03b1\nt : Multiset \u03b9\nf : \u03b9 \u2192 Set \u03b1\ng : \u03b9 \u2192 \u03b1\nhg : \u2200 i \u2208 t, g i \u2208 f i\n\u22a2 (Multiset.map g t).prod \u2208 (Multiset.map f t).prod"}, {"line": "induction t using Quotient.inductionOn", "tactic_state": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : CommMonoid \u03b1\nf : \u03b9 \u2192 Set \u03b1\ng : \u03b9 \u2192 \u03b1\na\u271d : List \u03b9\nhg : \u2200 i \u2208 \u27e6a\u271d\u27e7, g i \u2208 f i\n\u22a2 (Multiset.map g \u27e6a\u271d\u27e7).prod \u2208 (Multiset.map f \u27e6a\u271d\u27e7).prod"}, {"line": "simp_rw [Multiset.quot_mk_to_coe, Multiset.map_coe, Multiset.prod_coe]", "tactic_state": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : CommMonoid \u03b1\nf : \u03b9 \u2192 Set \u03b1\ng : \u03b9 \u2192 \u03b1\na\u271d : List \u03b9\nhg : \u2200 i \u2208 \u27e6a\u271d\u27e7, g i \u2208 f i\n\u22a2 (List.map g a\u271d).prod \u2208 (List.map f a\u271d).prod"}, {"line": "exact list_prod_mem_list_prod _ _ _ hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiset_prod_subset_multiset_prod (t : Multiset \u03b9) (f\u2081 f\u2082 : \u03b9 \u2192 Set \u03b1)\n    (hf : \u2200 i \u2208 t, f\u2081 i \u2286 f\u2082 i) : (t.map f\u2081).prod \u2286 (t.map f\u2082).prod := by\n  induction t using Quotient.inductionOn\n  simp_rw [Multiset.quot_mk_to_coe, Multiset.map_coe, Multiset.prod_coe]\n  exact list_prod_subset_list_prod _ _ _ hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Set/BigOperators.lean", "context": {"open": ["Pointwise Function"], "variables": ["{\u03b9 \u03b1 \u03b2 F : Type*} [FunLike F \u03b1 \u03b2]", "[Monoid \u03b1] [Monoid \u03b2] [MonoidHomClass F \u03b1 \u03b2]", "[CommMonoid \u03b1] [CommMonoid \u03b2] [MonoidHomClass F \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : CommMonoid \u03b1\nt : Multiset \u03b9\nf\u2081 f\u2082 : \u03b9 \u2192 Set \u03b1\nhf : \u2200 i \u2208 t, f\u2081 i \u2286 f\u2082 i\n\u22a2 (Multiset.map f\u2081 t).prod \u2286 (Multiset.map f\u2082 t).prod"}, {"line": "induction t using Quotient.inductionOn", "tactic_state": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : CommMonoid \u03b1\nf\u2081 f\u2082 : \u03b9 \u2192 Set \u03b1\na\u271d : List \u03b9\nhf : \u2200 i \u2208 \u27e6a\u271d\u27e7, f\u2081 i \u2286 f\u2082 i\n\u22a2 (Multiset.map f\u2081 \u27e6a\u271d\u27e7).prod \u2286 (Multiset.map f\u2082 \u27e6a\u271d\u27e7).prod"}, {"line": "simp_rw [Multiset.quot_mk_to_coe, Multiset.map_coe, Multiset.prod_coe]", "tactic_state": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : CommMonoid \u03b1\nf\u2081 f\u2082 : \u03b9 \u2192 Set \u03b1\na\u271d : List \u03b9\nhf : \u2200 i \u2208 \u27e6a\u271d\u27e7, f\u2081 i \u2286 f\u2082 i\n\u22a2 (List.map f\u2081 a\u271d).prod \u2286 (List.map f\u2082 a\u271d).prod"}, {"line": "exact list_prod_subset_list_prod _ _ _ hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_fintype_prod_pi [Fintype \u03b9] (S : \u03b9 \u2192 Set \u03b1) :\n    (fun f : \u03b9 \u2192 \u03b1 => \u220f i, f i) '' univ.pi S = \u220f i, S i := by\n  simpa only [Finset.coe_univ] using image_finset_prod_pi Finset.univ S\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Pointwise/Set/BigOperators.lean", "context": {"open": ["Pointwise Function"], "variables": ["{\u03b9 \u03b1 \u03b2 F : Type*} [FunLike F \u03b1 \u03b2]", "[Monoid \u03b1] [Monoid \u03b2] [MonoidHomClass F \u03b1 \u03b2]", "[CommMonoid \u03b1] [CommMonoid \u03b2] [MonoidHomClass F \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : Fintype \u03b9\nS : \u03b9 \u2192 Set \u03b1\n\u22a2 (fun f => \u220f i, f i) '' sorry = \u220f i, S i"}, {"line": "simpa only [Finset.coe_univ] using image_finset_prod_pi Finset.univ S", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_right (a : M) : SemiconjBy a 1 1 := by rw [SemiconjBy, mul_one, one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Semiconj/Defs.lean", "context": {"open": [], "variables": ["{S M G : Type*}", "[Semigroup S] {a b x y z x' y' : S}", "[MulOneClass M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : MulOneClass M\na : M\n\u22a2 SemiconjBy a 1 1"}, {"line": "rw [SemiconjBy, mul_one, one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem conj_iff {a x y b : G} :\n    SemiconjBy (b * a * b\u207b\u00b9) (b * x * b\u207b\u00b9) (b * y * b\u207b\u00b9) \u2194 SemiconjBy a x y := by\n  unfold SemiconjBy\n  simp only [\u2190 mul_assoc]\n  simp only [inv_mul_cancel_right]\n  repeat rw [mul_assoc]\n  rw [mul_left_cancel_iff]\n  rw [\u2190 mul_assoc]\n  rw [\u2190 mul_assoc]\n  rw [mul_right_cancel_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Semiconj/Defs.lean", "context": {"open": [], "variables": ["{S M G : Type*}", "[Semigroup S] {a b x y z x' y' : S}", "[MulOneClass M]", "[Monoid M]", "[Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d : Group G\na x y b : G\n\u22a2 SemiconjBy (b * a * b\u207b\u00b9) (b * x * b\u207b\u00b9) (b * y * b\u207b\u00b9) \u2194 SemiconjBy a x y"}, {"line": "unfold SemiconjBy", "tactic_state": "G : Type u_3\ninst\u271d : Group G\na x y b : G\n\u22a2 b * a * b\u207b\u00b9 * (b * x * b\u207b\u00b9) = b * y * b\u207b\u00b9 * (b * a * b\u207b\u00b9) \u2194 a * x = y * a"}, {"line": "simp only [\u2190 mul_assoc]", "tactic_state": "G : Type u_3\ninst\u271d : Group G\na x y b : G\n\u22a2 b * a * b\u207b\u00b9 * b * x * b\u207b\u00b9 = b * y * b\u207b\u00b9 * b * a * b\u207b\u00b9 \u2194 a * x = y * a"}, {"line": "simp only [inv_mul_cancel_right]", "tactic_state": "G : Type u_3\ninst\u271d : Group G\na x y b : G\n\u22a2 b * a * x * b\u207b\u00b9 = b * y * a * b\u207b\u00b9 \u2194 a * x = y * a"}, {"line": "repeat rw [mul_assoc]", "tactic_state": "G : Type u_3\ninst\u271d : Group G\na x y b : G\n\u22a2 b * (a * (x * b\u207b\u00b9)) = b * (y * (a * b\u207b\u00b9)) \u2194 a * x = y * a"}, {"line": "rw [mul_left_cancel_iff]", "tactic_state": "G : Type u_3\ninst\u271d : Group G\na x y b : G\n\u22a2 a * (x * b\u207b\u00b9) = y * (a * b\u207b\u00b9) \u2194 a * x = y * a\n---\nG : Type u_3\ninst\u271d : Group G\na x y b : G\n\u22a2 IsLeftCancelMul G"}, {"line": "rw [\u2190 mul_assoc]", "tactic_state": "G : Type u_3\ninst\u271d : Group G\na x y b : G\n\u22a2 a * x * b\u207b\u00b9 = y * (a * b\u207b\u00b9) \u2194 a * x = y * a\n---\nG : Type u_3\ninst\u271d : Group G\na x y b : G\n\u22a2 IsLeftCancelMul G"}, {"line": "rw [\u2190 mul_assoc]", "tactic_state": "G : Type u_3\ninst\u271d : Group G\na x y b : G\n\u22a2 a * x * b\u207b\u00b9 = y * a * b\u207b\u00b9 \u2194 a * x = y * a\n---\nG : Type u_3\ninst\u271d : Group G\na x y b : G\n\u22a2 IsLeftCancelMul G"}, {"line": "rw [mul_right_cancel_iff]", "tactic_state": "G : Type u_3\ninst\u271d : Group G\na x y b : G\n\u22a2 IsRightCancelMul G\n---\nG : Type u_3\ninst\u271d : Group G\na x y b : G\n\u22a2 IsLeftCancelMul G"}]}
{"declaration": "theorem exists_inv_mem_iff_exists_mem {P : G \u2192 Prop} :\n    (\u2203 x : G, x \u2208 H \u2227 P x\u207b\u00b9) \u2194 \u2203 x \u2208 H, P x := by\n  constructor <;>\n    \u00b7 rintro \u27e8x, x_in, hx\u27e9\n      exact \u27e8x\u207b\u00b9, inv_mem x_in, by simp [hx]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Defs.lean", "context": {"open": ["Function", "scoped Int"], "variables": ["{G : Type*} [Group G] {A : Type*} [AddGroup A]", "{M S : Type*} [DivInvMonoid M] [SetLike S M] [hSM : SubgroupClass S M] {H K : S}", "[SetLike S G] [SubgroupClass S G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : Group G\nS : Type u_4\nH : S\ninst\u271d\u00b9 : SetLike S G\ninst\u271d : SubgroupClass S G\nP : G \u2192 Prop\n\u22a2 (\u2203 x \u2208 H, P x\u207b\u00b9) \u2194 \u2203 x \u2208 H, P x"}, {"line": "constructor <;>\n    \u00b7 rintro \u27e8x, x_in, hx\u27e9\n      exact \u27e8x\u207b\u00b9, inv_mem x_in, by simp [hx]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_subtype : (SubgroupClass.subtype H : H \u2192 G) = ((\u2191) : H \u2192 G) := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Defs.lean", "context": {"open": ["Function", "scoped Int"], "variables": ["{G : Type*} [Group G] {A : Type*} [AddGroup A]", "{M S : Type*} [DivInvMonoid M] [SetLike S M] [hSM : SubgroupClass S M] {H K : S}", "[SetLike S G] [SubgroupClass S G]", "(H)", "{H} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : Group G\nS : Type u_4\nH : S\ninst\u271d\u00b9 : SetLike S G\ninst\u271d : SubgroupClass S G\n\u22a2 \u21d1\u2191H = Subtype.val"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inclusion_inclusion {L : S} (hHK : H \u2264 K) (hKL : K \u2264 L) (x : H) :\n    inclusion hKL (inclusion hHK x) = inclusion (hHK.trans hKL) x := by\n  cases x\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Defs.lean", "context": {"open": ["Function", "scoped Int"], "variables": ["{G : Type*} [Group G] {A : Type*} [AddGroup A]", "{M S : Type*} [DivInvMonoid M] [SetLike S M] [hSM : SubgroupClass S M] {H K : S}", "[SetLike S G] [SubgroupClass S G]", "(H)", "{H} in", "{H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : Group G\nS : Type u_4\nH K : S\ninst\u271d\u00b9 : SetLike S G\ninst\u271d : SubgroupClass S G\nx\u271d : Sort u_5\ninclusion : x\u271d\nL : S\nhHK : H \u2264 K\nhKL : K \u2264 L\nx : \u21a5H\n\u22a2 sorry = sorry"}, {"line": "cases x", "tactic_state": "case mk\nG : Type u_1\ninst\u271d\u00b2 : Group G\nS : Type u_4\nH K : S\ninst\u271d\u00b9 : SetLike S G\ninst\u271d : SubgroupClass S G\nx\u271d : Sort u_5\ninclusion : x\u271d\nL : S\nhHK : H \u2264 K\nhKL : K \u2264 L\nval\u271d : G\nproperty\u271d : val\u271d \u2208 H\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_zpow (x : H) (n : \u2124) : ((x ^ n : H) : G) = (x : G) ^ n := by\n  dsimp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Defs.lean", "context": {"open": ["Function", "scoped Int"], "variables": ["{G : Type*} [Group G] {A : Type*} [AddGroup A]", "{M S : Type*} [DivInvMonoid M] [SetLike S M] [hSM : SubgroupClass S M] {H K : S}", "[SetLike S G] [SubgroupClass S G]", "(H)", "{H} in", "{H}", "(H K : Subgroup G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH : Subgroup G\nx : \u21a5H\nn : \u2124\n\u22a2 \u2191(x ^ n) = \u2191x ^ n"}, {"line": "dsimp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_comm_of_mem_isMulCommutative [IsMulCommutative H] {a b : G} (ha : a \u2208 H) (hb : b \u2208 H) :\n    a * b = b * a := by\n  simpa only [MulMemClass.mk_mul_mk, Subtype.mk.injEq] using mul_comm (\u27e8a, ha\u27e9 : H) (\u27e8b, hb\u27e9 : H)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Defs.lean", "context": {"open": ["Function", "scoped Int", "Set"], "variables": ["{G : Type*} [Group G] {A : Type*} [AddGroup A]", "{M S : Type*} [DivInvMonoid M] [SetLike S M] [hSM : SubgroupClass S M] {H K : S}", "[SetLike S G] [SubgroupClass S G]", "(H)", "{H} in", "{H}", "(H K : Subgroup G)", "{H : Subgroup G}", "(H : Subgroup G)", "{H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nH : Subgroup G\ninst\u271d : IsMulCommutative \u21a5H\na b : G\nha : a \u2208 H\nhb : b \u2208 H\n\u22a2 a * b = b * a"}, {"line": "simpa only [MulMemClass.mk_mul_mk, Subtype.mk.injEq] using mul_comm (\u27e8a, ha\u27e9 : H) (\u27e8b, hb\u27e9 : H)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_liftOfRightInverse (hf : Function.RightInverse f_inv f) (g : G\u2081 \u2192* G\u2083)\n    (hg : f.ker \u2264 g.ker) (h : G\u2082 \u2192* G\u2083) (hh : h.comp f = g) :\n    h = f.liftOfRightInverse f_inv hf \u27e8g, hg\u27e9 := by\n  simp_rw [\u2190 hh]\n  exact ((f.liftOfRightInverse f_inv hf).apply_symm_apply _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Basic.lean", "context": {"open": ["Function", "scoped Int", "Set", "scoped Relator in", "Group", "Subgroup", "MonoidHom"], "variables": ["{G G' G'' : Type*} [Group G] [Group G'] [Group G'']", "{A : Type*} [AddGroup A]", "{M S : Type*} [DivInvMonoid M] [SetLike S M] [hSM : SubgroupClass S M] {H K : S}", "[SetLike S G] [SubgroupClass S G]", "(H K : Subgroup G)", "{k : Set G}", "{N : Type*} [Group N] {P : Type*} [Group P]", "{\u03b7 : Type*} {f : \u03b7 \u2192 Type*}", "[\u2200 i, Group (f i)]", "{H K : Subgroup G}", "(H)", "(H : AddSubgroup A)", "{H K : Subgroup G}", "(H)", "{H}", "(H) in", "{N : Type*} [Group N]", "(G) in", "(H)", "{s : Set G}", "{s : Set G}", "{N : Type*} {P : Type*} [Group N] [Group P] (K : Subgroup G)", "{M : Type*} [MulOneClass M]", "{N : Type*} [Group N] (H : Subgroup G)", "{N : Type*} [Group N] (f : G \u2192* N)", "{G\u2081 G\u2082 G\u2083 : Type*} [Group G\u2081] [Group G\u2082] [Group G\u2083]", "(f : G\u2081 \u2192* G\u2082) (f_inv : G\u2082 \u2192 G\u2081)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2081 : Type u_16\nG\u2082 : Type u_17\nG\u2083 : Type u_18\ninst\u271d\u00b2 : Group G\u2081\ninst\u271d\u00b9 : Group G\u2082\ninst\u271d : Group G\u2083\nf : G\u2081 \u2192* G\u2082\nf_inv : G\u2082 \u2192 G\u2081\nhf : RightInverse f_inv \u21d1f\ng : G\u2081 \u2192* G\u2083\nhg : f.ker \u2264 g.ker\nh : G\u2082 \u2192* G\u2083\nhh : h.comp f = g\n\u22a2 h = (f.liftOfRightInverse f_inv hf) \u27e8g, hg\u27e9"}, {"line": "simp_rw [\u2190 hh]", "tactic_state": "G\u2081 : Type u_16\nG\u2082 : Type u_17\nG\u2083 : Type u_18\ninst\u271d\u00b2 : Group G\u2081\ninst\u271d\u00b9 : Group G\u2082\ninst\u271d : Group G\u2083\nf : G\u2081 \u2192* G\u2082\nf_inv : G\u2082 \u2192 G\u2081\nhf : RightInverse f_inv \u21d1f\ng : G\u2081 \u2192* G\u2083\nhg : f.ker \u2264 g.ker\nh : G\u2082 \u2192* G\u2083\nhh : h.comp f = g\n\u22a2 h = (f.liftOfRightInverse f_inv hf) \u27e8h.comp f, \u22ef\u27e9"}, {"line": "exact ((f.liftOfRightInverse f_inv hf).apply_symm_apply _).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_normalClosure (s : Set G) (f : G \u2192* N) (hf : Surjective f) :\n    (normalClosure s).map f = normalClosure (f '' s) := by\n  have : Normal (map f (normalClosure s)) := Normal.map inferInstance f hf\n  apply le_antisymm\n  \u00b7 simp [map_le_iff_le_comap, normalClosure_le_normal, coe_comap,\n      \u2190 Set.image_subset_iff, subset_normalClosure]\n  \u00b7 exact normalClosure_le_normal (Set.image_subset f subset_normalClosure)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Basic.lean", "context": {"open": ["Function", "scoped Int", "Set", "scoped Relator in", "Group", "Subgroup", "MonoidHom"], "variables": ["{G G' G'' : Type*} [Group G] [Group G'] [Group G'']", "{A : Type*} [AddGroup A]", "{M S : Type*} [DivInvMonoid M] [SetLike S M] [hSM : SubgroupClass S M] {H K : S}", "[SetLike S G] [SubgroupClass S G]", "(H K : Subgroup G)", "{k : Set G}", "{N : Type*} [Group N] {P : Type*} [Group P]", "{\u03b7 : Type*} {f : \u03b7 \u2192 Type*}", "[\u2200 i, Group (f i)]", "{H K : Subgroup G}", "(H)", "(H : AddSubgroup A)", "{H K : Subgroup G}", "(H)", "{H}", "(H) in", "{N : Type*} [Group N]", "(G) in", "(H)", "{s : Set G}", "{s : Set G}", "{N : Type*} {P : Type*} [Group N] [Group P] (K : Subgroup G)", "{M : Type*} [MulOneClass M]", "{N : Type*} [Group N] (H : Subgroup G)", "{N : Type*} [Group N] (f : G \u2192* N)", "{G\u2081 G\u2082 G\u2083 : Type*} [Group G\u2081] [Group G\u2082] [Group G\u2083]", "(f : G\u2081 \u2192* G\u2082) (f_inv : G\u2082 \u2192 G\u2081)", "{N : Type*} [Group N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_19\ninst\u271d : Group N\ns : Set G\nf : G \u2192* N\nhf : Surjective \u21d1f\n\u22a2 map f (normalClosure s) = normalClosure (\u21d1f '' s)"}, {"line": "have : Normal (map f (normalClosure s)) := Normal.map inferInstance f hf", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_19\ninst\u271d : Group N\ns : Set G\nf : G \u2192* N\nhf : Surjective \u21d1f\nthis : sorry\n\u22a2 map f (normalClosure s) = normalClosure (\u21d1f '' s)"}, {"line": "apply le_antisymm", "tactic_state": "case a\nG : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_19\ninst\u271d : Group N\ns : Set G\nf : G \u2192* N\nhf : Surjective \u21d1f\nthis : sorry\n\u22a2 map f (normalClosure s) \u2264 normalClosure (\u21d1f '' s)\n---\ncase a\nG : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_19\ninst\u271d : Group N\ns : Set G\nf : G \u2192* N\nhf : Surjective \u21d1f\nthis : sorry\n\u22a2 normalClosure (\u21d1f '' s) \u2264 map f (normalClosure s)"}, {"line": "\u00b7 simp [map_le_iff_le_comap, normalClosure_le_normal, coe_comap,\n      \u2190 Set.image_subset_iff, subset_normalClosure]", "tactic_state": "case a\nG : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_19\ninst\u271d : Group N\ns : Set G\nf : G \u2192* N\nhf : Surjective \u21d1f\nthis : sorry\n\u22a2 normalClosure (\u21d1f '' s) \u2264 map f (normalClosure s)"}, {"line": "\u00b7 exact normalClosure_le_normal (Set.image_subset f subset_normalClosure)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_normalClosure (s : Set N) (f : G \u2243* N) :\n    normalClosure (f \u207b\u00b9' s) = (normalClosure s).comap f := by\n  have := Set.preimage_equiv_eq_image_symm s f.toEquiv\n  simp_all [comap_equiv_eq_map_symm, map_normalClosure s (f.symm : N \u2192* G) f.symm.surjective]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Basic.lean", "context": {"open": ["Function", "scoped Int", "Set", "scoped Relator in", "Group", "Subgroup", "MonoidHom"], "variables": ["{G G' G'' : Type*} [Group G] [Group G'] [Group G'']", "{A : Type*} [AddGroup A]", "{M S : Type*} [DivInvMonoid M] [SetLike S M] [hSM : SubgroupClass S M] {H K : S}", "[SetLike S G] [SubgroupClass S G]", "(H K : Subgroup G)", "{k : Set G}", "{N : Type*} [Group N] {P : Type*} [Group P]", "{\u03b7 : Type*} {f : \u03b7 \u2192 Type*}", "[\u2200 i, Group (f i)]", "{H K : Subgroup G}", "(H)", "(H : AddSubgroup A)", "{H K : Subgroup G}", "(H)", "{H}", "(H) in", "{N : Type*} [Group N]", "(G) in", "(H)", "{s : Set G}", "{s : Set G}", "{N : Type*} {P : Type*} [Group N] [Group P] (K : Subgroup G)", "{M : Type*} [MulOneClass M]", "{N : Type*} [Group N] (H : Subgroup G)", "{N : Type*} [Group N] (f : G \u2192* N)", "{G\u2081 G\u2082 G\u2083 : Type*} [Group G\u2081] [Group G\u2082] [Group G\u2083]", "(f : G\u2081 \u2192* G\u2082) (f_inv : G\u2082 \u2192 G\u2081)", "{N : Type*} [Group N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_19\ninst\u271d : Group N\ns : Set N\nf : G \u2243* N\n\u22a2 normalClosure (\u21d1f \u207b\u00b9' s) = comap (\u2191f) (normalClosure s)"}, {"line": "have := Set.preimage_equiv_eq_image_symm s f.toEquiv", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_19\ninst\u271d : Group N\ns : Set N\nf : G \u2243* N\nthis : \u21d1sorry \u207b\u00b9' s = \u21d1sorry.symm '' s\n\u22a2 normalClosure (\u21d1f \u207b\u00b9' s) = comap (\u2191f) (normalClosure s)"}, {"line": "simp_all [comap_equiv_eq_map_symm, map_normalClosure s (f.symm : N \u2192* G) f.symm.surjective]", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_19\ninst\u271d : Group N\ns : Set N\nf : G \u2243* N\nthis : \u21d1(sorry ()) \u207b\u00b9' s = (fun a => (sorry ()).symm a) '' s\n\u22a2 normalClosure (\u21d1f \u207b\u00b9' s) = map (\u2191f.symm) (normalClosure s)"}]}
{"declaration": "theorem inf_subgroupOf_inf_normal_of_right (A B' B : Subgroup G)\n    [hN : (B'.subgroupOf B).Normal] : ((A \u2293 B').subgroupOf (A \u2293 B)).Normal := by\n  rw [normal_subgroupOf_iff_le_normalizer_inf] at hN \u22a2\n  rw [inf_inf_inf_comm]\n  rw [inf_idem]\n  exact le_trans (inf_le_inf A.le_normalizer hN) (inf_normalizer_le_normalizer_inf)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Basic.lean", "context": {"open": ["Function", "scoped Int", "Set", "scoped Relator in", "Group", "Subgroup", "MonoidHom"], "variables": ["{G G' G'' : Type*} [Group G] [Group G'] [Group G'']", "{A : Type*} [AddGroup A]", "{M S : Type*} [DivInvMonoid M] [SetLike S M] [hSM : SubgroupClass S M] {H K : S}", "[SetLike S G] [SubgroupClass S G]", "(H K : Subgroup G)", "{k : Set G}", "{N : Type*} [Group N] {P : Type*} [Group P]", "{\u03b7 : Type*} {f : \u03b7 \u2192 Type*}", "[\u2200 i, Group (f i)]", "{H K : Subgroup G}", "(H)", "(H : AddSubgroup A)", "{H K : Subgroup G}", "(H)", "{H}", "(H) in", "{N : Type*} [Group N]", "(G) in", "(H)", "{s : Set G}", "{s : Set G}", "{N : Type*} {P : Type*} [Group N] [Group P] (K : Subgroup G)", "{M : Type*} [MulOneClass M]", "{N : Type*} [Group N] (H : Subgroup G)", "{N : Type*} [Group N] (f : G \u2192* N)", "{G\u2081 G\u2082 G\u2083 : Type*} [Group G\u2081] [Group G\u2082] [Group G\u2083]", "(f : G\u2081 \u2192* G\u2082) (f_inv : G\u2082 \u2192 G\u2081)", "{N : Type*} [Group N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nA B' B : Subgroup G\nhN : (B'.subgroupOf B).Normal\n\u22a2 ((A \u2293 B').subgroupOf (A \u2293 B)).Normal"}, {"line": "rw [normal_subgroupOf_iff_le_normalizer_inf] at hN \u22a2", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nA B' B : Subgroup G\nhN : B \u2264 (B' \u2293 B).normalizer\n\u22a2 A \u2293 B \u2264 (A \u2293 B' \u2293 (A \u2293 B)).normalizer"}, {"line": "rw [inf_inf_inf_comm]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nA B' B : Subgroup G\nhN : B \u2264 (B' \u2293 B).normalizer\n\u22a2 A \u2293 B \u2264 (A \u2293 A \u2293 (B' \u2293 B)).normalizer"}, {"line": "rw [inf_idem]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nA B' B : Subgroup G\nhN : B \u2264 (B' \u2293 B).normalizer\n\u22a2 A \u2293 B \u2264 (A \u2293 (B' \u2293 B)).normalizer"}, {"line": "exact le_trans (inf_le_inf A.le_normalizer hN) (inf_normalizer_le_normalizer_inf)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_subgroupOf_inf_normal_of_left {A' A : Subgroup G} (B : Subgroup G)\n    [hN : (A'.subgroupOf A).Normal] : ((A' \u2293 B).subgroupOf (A \u2293 B)).Normal := by\n  rw [normal_subgroupOf_iff_le_normalizer_inf] at hN \u22a2\n  rw [inf_inf_inf_comm]\n  rw [inf_idem]\n  exact le_trans (inf_le_inf hN B.le_normalizer) (inf_normalizer_le_normalizer_inf)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Basic.lean", "context": {"open": ["Function", "scoped Int", "Set", "scoped Relator in", "Group", "Subgroup", "MonoidHom"], "variables": ["{G G' G'' : Type*} [Group G] [Group G'] [Group G'']", "{A : Type*} [AddGroup A]", "{M S : Type*} [DivInvMonoid M] [SetLike S M] [hSM : SubgroupClass S M] {H K : S}", "[SetLike S G] [SubgroupClass S G]", "(H K : Subgroup G)", "{k : Set G}", "{N : Type*} [Group N] {P : Type*} [Group P]", "{\u03b7 : Type*} {f : \u03b7 \u2192 Type*}", "[\u2200 i, Group (f i)]", "{H K : Subgroup G}", "(H)", "(H : AddSubgroup A)", "{H K : Subgroup G}", "(H)", "{H}", "(H) in", "{N : Type*} [Group N]", "(G) in", "(H)", "{s : Set G}", "{s : Set G}", "{N : Type*} {P : Type*} [Group N] [Group P] (K : Subgroup G)", "{M : Type*} [MulOneClass M]", "{N : Type*} [Group N] (H : Subgroup G)", "{N : Type*} [Group N] (f : G \u2192* N)", "{G\u2081 G\u2082 G\u2083 : Type*} [Group G\u2081] [Group G\u2082] [Group G\u2083]", "(f : G\u2081 \u2192* G\u2082) (f_inv : G\u2082 \u2192 G\u2081)", "{N : Type*} [Group N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nA' A B : Subgroup G\nhN : (A'.subgroupOf A).Normal\n\u22a2 ((A' \u2293 B).subgroupOf (A \u2293 B)).Normal"}, {"line": "rw [normal_subgroupOf_iff_le_normalizer_inf] at hN \u22a2", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nA' A B : Subgroup G\nhN : A \u2264 (A' \u2293 A).normalizer\n\u22a2 A \u2293 B \u2264 (A' \u2293 B \u2293 (A \u2293 B)).normalizer"}, {"line": "rw [inf_inf_inf_comm]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nA' A B : Subgroup G\nhN : A \u2264 (A' \u2293 A).normalizer\n\u22a2 A \u2293 B \u2264 (A' \u2293 A \u2293 (B \u2293 B)).normalizer"}, {"line": "rw [inf_idem]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nA' A B : Subgroup G\nhN : A \u2264 (A' \u2293 A).normalizer\n\u22a2 A \u2293 B \u2264 (A' \u2293 A \u2293 B).normalizer"}, {"line": "exact le_trans (inf_le_inf hN B.le_normalizer) (inf_normalizer_le_normalizer_inf)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normal_subgroupOf_of_le_normalizer {H N : Subgroup G}\n    (hLE : H \u2264 N.normalizer) : (N.subgroupOf H).Normal := by\n  rw [normal_subgroupOf_iff_le_normalizer_inf]\n  exact (le_inf hLE H.le_normalizer).trans inf_normalizer_le_normalizer_inf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Basic.lean", "context": {"open": ["Function", "scoped Int", "Set", "scoped Relator in", "Group", "Subgroup", "MonoidHom"], "variables": ["{G G' G'' : Type*} [Group G] [Group G'] [Group G'']", "{A : Type*} [AddGroup A]", "{M S : Type*} [DivInvMonoid M] [SetLike S M] [hSM : SubgroupClass S M] {H K : S}", "[SetLike S G] [SubgroupClass S G]", "(H K : Subgroup G)", "{k : Set G}", "{N : Type*} [Group N] {P : Type*} [Group P]", "{\u03b7 : Type*} {f : \u03b7 \u2192 Type*}", "[\u2200 i, Group (f i)]", "{H K : Subgroup G}", "(H)", "(H : AddSubgroup A)", "{H K : Subgroup G}", "(H)", "{H}", "(H) in", "{N : Type*} [Group N]", "(G) in", "(H)", "{s : Set G}", "{s : Set G}", "{N : Type*} {P : Type*} [Group N] [Group P] (K : Subgroup G)", "{M : Type*} [MulOneClass M]", "{N : Type*} [Group N] (H : Subgroup G)", "{N : Type*} [Group N] (f : G \u2192* N)", "{G\u2081 G\u2082 G\u2083 : Type*} [Group G\u2081] [Group G\u2082] [Group G\u2083]", "(f : G\u2081 \u2192* G\u2082) (f_inv : G\u2082 \u2192 G\u2081)", "{N : Type*} [Group N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH N : Subgroup G\nhLE : H \u2264 N.normalizer\n\u22a2 (N.subgroupOf H).Normal"}, {"line": "rw [normal_subgroupOf_iff_le_normalizer_inf]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH N : Subgroup G\nhLE : H \u2264 N.normalizer\n\u22a2 H \u2264 (N \u2293 H).normalizer"}, {"line": "exact (le_inf hLE H.le_normalizer).trans inf_normalizer_le_normalizer_inf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normal_subgroupOf_sup_of_le_normalizer {H N : Subgroup G}\n    (hLE : H \u2264 N.normalizer) : (N.subgroupOf (H \u2294 N)).Normal := by\n  rw [normal_subgroupOf_iff_le_normalizer le_sup_right]\n  exact sup_le hLE le_normalizer\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Basic.lean", "context": {"open": ["Function", "scoped Int", "Set", "scoped Relator in", "Group", "Subgroup", "MonoidHom"], "variables": ["{G G' G'' : Type*} [Group G] [Group G'] [Group G'']", "{A : Type*} [AddGroup A]", "{M S : Type*} [DivInvMonoid M] [SetLike S M] [hSM : SubgroupClass S M] {H K : S}", "[SetLike S G] [SubgroupClass S G]", "(H K : Subgroup G)", "{k : Set G}", "{N : Type*} [Group N] {P : Type*} [Group P]", "{\u03b7 : Type*} {f : \u03b7 \u2192 Type*}", "[\u2200 i, Group (f i)]", "{H K : Subgroup G}", "(H)", "(H : AddSubgroup A)", "{H K : Subgroup G}", "(H)", "{H}", "(H) in", "{N : Type*} [Group N]", "(G) in", "(H)", "{s : Set G}", "{s : Set G}", "{N : Type*} {P : Type*} [Group N] [Group P] (K : Subgroup G)", "{M : Type*} [MulOneClass M]", "{N : Type*} [Group N] (H : Subgroup G)", "{N : Type*} [Group N] (f : G \u2192* N)", "{G\u2081 G\u2082 G\u2083 : Type*} [Group G\u2081] [Group G\u2082] [Group G\u2083]", "(f : G\u2081 \u2192* G\u2082) (f_inv : G\u2082 \u2192 G\u2081)", "{N : Type*} [Group N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH N : Subgroup G\nhLE : H \u2264 N.normalizer\n\u22a2 (N.subgroupOf (H \u2294 N)).Normal"}, {"line": "rw [normal_subgroupOf_iff_le_normalizer le_sup_right]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH N : Subgroup G\nhLE : H \u2264 N.normalizer\n\u22a2 H \u2294 N \u2264 N.normalizer"}, {"line": "exact sup_le hLE le_normalizer", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_bot : Nat.card (\u22a5 : Subgroup G) = 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Finite.lean", "context": {"open": [], "variables": ["{G : Type*} [Group G]", "{A : Type*} [AddGroup A]", "(H K : Subgroup G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\n\u22a2 Nat.card \u21a5\u22a5 = 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_top_of_card_eq [Finite H] (h : Nat.card H = Nat.card G) : H = \u22a4 := by\n  have : Finite G := Nat.finite_of_card_ne_zero (h \u25b8 Nat.card_pos.ne')\n  exact eq_top_of_le_card _ (Nat.le_of_eq h.symm)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Finite.lean", "context": {"open": [], "variables": ["{G : Type*} [Group G]", "{A : Type*} [AddGroup A]", "(H K : Subgroup G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nH : Subgroup G\ninst\u271d : Finite \u21a5H\nh : Nat.card \u21a5H = Nat.card G\n\u22a2 H = \u22a4"}, {"line": "have : Finite G := Nat.finite_of_card_ne_zero (h \u25b8 Nat.card_pos.ne')", "tactic_state": "case refine_2\nG : Type u_1\ninst\u271d\u00b9 : Group G\nH : Subgroup G\ninst\u271d : Finite \u21a5H\nh : Nat.card \u21a5H = Nat.card G\nthis : Finite G\n\u22a2 H = \u22a4\n---\ncase refine_1\nG : Type u_1\ninst\u271d\u00b9 : Group G\nH : Subgroup G\ninst\u271d : Finite \u21a5H\nh : Nat.card \u21a5H = Nat.card G\n\u22a2 Finite \u21a5H"}, {"line": "exact eq_top_of_le_card _ (Nat.le_of_eq h.symm)", "tactic_state": "case refine_1\nG : Type u_1\ninst\u271d\u00b9 : Group G\nH : Subgroup G\ninst\u271d : Finite \u21a5H\nh : Nat.card \u21a5H = Nat.card G\n\u22a2 Finite \u21a5H"}]}
{"declaration": "lemma rangeRestrict_injective_iff {f : G \u2192* N} : Injective f.rangeRestrict \u2194 Injective f := by\n  convert Set.injective_codRestrict _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Ker.lean", "context": {"open": ["Function", "scoped Int", "Subgroup"], "variables": ["{G G' G'' : Type*} [Group G] [Group G'] [Group G'']", "{A : Type*} [AddGroup A]", "{N : Type*} {P : Type*} [Group N] [Group P] (K : Subgroup G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_5\ninst\u271d : Group N\nf : G \u2192* N\n\u22a2 Injective \u21d1f.rangeRestrict \u2194 Injective \u21d1f"}, {"line": "convert Set.injective_codRestrict _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_iff (f : G \u2192* M) {x y : G} : f x = f y \u2194 y\u207b\u00b9 * x \u2208 f.ker := by\n  constructor <;> intro h\n  \u00b7 rw [mem_ker, map_mul, h, \u2190 map_mul, inv_mul_cancel, map_one]\n  \u00b7 rw [\u2190 one_mul x, \u2190 mul_inv_cancel y, mul_assoc, map_mul, mem_ker.1 h, mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Ker.lean", "context": {"open": ["Function", "scoped Int", "Subgroup"], "variables": ["{G G' G'' : Type*} [Group G] [Group G'] [Group G'']", "{A : Type*} [AddGroup A]", "{N : Type*} {P : Type*} [Group N] [Group P] (K : Subgroup G)", "{M : Type*} [MulOneClass M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nM : Type u_7\ninst\u271d : MulOneClass M\nf : G \u2192* M\nx y : G\n\u22a2 f x = f y \u2194 y\u207b\u00b9 * x \u2208 f.ker"}, {"line": "constructor <;> intro h", "tactic_state": "case mp\nG : Type u_1\ninst\u271d\u00b9 : Group G\nM : Type u_7\ninst\u271d : MulOneClass M\nf : G \u2192* M\nx y : G\nh : f x = f y\n\u22a2 y\u207b\u00b9 * x \u2208 f.ker\n---\ncase mpr\nG : Type u_1\ninst\u271d\u00b9 : Group G\nM : Type u_7\ninst\u271d : MulOneClass M\nf : G \u2192* M\nx y : G\nh : y\u207b\u00b9 * x \u2208 f.ker\n\u22a2 f x = f y"}, {"line": "\u00b7 rw [mem_ker, map_mul, h, \u2190 map_mul, inv_mul_cancel, map_one]", "tactic_state": "case mpr\nG : Type u_1\ninst\u271d\u00b9 : Group G\nM : Type u_7\ninst\u271d : MulOneClass M\nf : G \u2192* M\nx y : G\nh : y\u207b\u00b9 * x \u2208 f.ker\n\u22a2 f x = f y"}, {"line": "\u00b7 rw [\u2190 one_mul x, \u2190 mul_inv_cancel y, mul_assoc, map_mul, mem_ker.1 h, mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_comap_eq_self {f : G \u2192* N} {H : Subgroup N} (h : H \u2264 f.range) :\n    map f (comap f H) = H := by\n  rwa [map_comap_eq, inf_eq_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Ker.lean", "context": {"open": ["Function", "scoped Int", "Subgroup", "MonoidHom"], "variables": ["{G G' G'' : Type*} [Group G] [Group G'] [Group G'']", "{A : Type*} [AddGroup A]", "{N : Type*} {P : Type*} [Group N] [Group P] (K : Subgroup G)", "{M : Type*} [MulOneClass M]", "{M : Type*} [Monoid M]", "{N : Type*} [Group N] (H : Subgroup G)", "(f : G \u2192* N)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_9\ninst\u271d : Group N\nf : G \u2192* N\nH : Subgroup N\nh : H \u2264 f.range\n\u22a2 map f (comap f H) = H"}, {"line": "rwa [map_comap_eq, inf_eq_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_map_eq_self {f : G \u2192* N} {H : Subgroup G} (h : f.ker \u2264 H) :\n    comap f (map f H) = H := by\n  rwa [comap_map_eq, sup_eq_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Ker.lean", "context": {"open": ["Function", "scoped Int", "Subgroup", "MonoidHom"], "variables": ["{G G' G'' : Type*} [Group G] [Group G'] [Group G'']", "{A : Type*} [AddGroup A]", "{N : Type*} {P : Type*} [Group N] [Group P] (K : Subgroup G)", "{M : Type*} [MulOneClass M]", "{M : Type*} [Monoid M]", "{N : Type*} [Group N] (H : Subgroup G)", "(f : G \u2192* N)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_9\ninst\u271d : Group N\nf : G \u2192* N\nH : Subgroup G\nh : f.ker \u2264 H\n\u22a2 comap f (map f H) = H"}, {"line": "rwa [comap_map_eq, sup_eq_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_le_map_iff {f : G \u2192* N} {H K : Subgroup G} : H.map f \u2264 K.map f \u2194 H \u2264 K \u2294 f.ker := by\n  rw [map_le_iff_le_comap]\n  rw [comap_map_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Ker.lean", "context": {"open": ["Function", "scoped Int", "Subgroup", "MonoidHom"], "variables": ["{G G' G'' : Type*} [Group G] [Group G'] [Group G'']", "{A : Type*} [AddGroup A]", "{N : Type*} {P : Type*} [Group N] [Group P] (K : Subgroup G)", "{M : Type*} [MulOneClass M]", "{M : Type*} [Monoid M]", "{N : Type*} [Group N] (H : Subgroup G)", "(f : G \u2192* N)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_9\ninst\u271d : Group N\nf : G \u2192* N\nH K : Subgroup G\n\u22a2 map f H \u2264 map f K \u2194 H \u2264 K \u2294 f.ker"}, {"line": "rw [map_le_iff_le_comap]", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_9\ninst\u271d : Group N\nf : G \u2192* N\nH K : Subgroup G\n\u22a2 H \u2264 comap f (map f K) \u2194 H \u2264 K \u2294 f.ker"}, {"line": "rw [comap_map_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_eq_map_iff {f : G \u2192* N} {H K : Subgroup G} :\n    H.map f = K.map f \u2194 H \u2294 f.ker = K \u2294 f.ker := by simp only [le_antisymm_iff, map_le_map_iff']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Ker.lean", "context": {"open": ["Function", "scoped Int", "Subgroup", "MonoidHom"], "variables": ["{G G' G'' : Type*} [Group G] [Group G'] [Group G'']", "{A : Type*} [AddGroup A]", "{N : Type*} {P : Type*} [Group N] [Group P] (K : Subgroup G)", "{M : Type*} [MulOneClass M]", "{M : Type*} [Monoid M]", "{N : Type*} [Group N] (H : Subgroup G)", "(f : G \u2192* N)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_9\ninst\u271d : Group N\nf : G \u2192* N\nH K : Subgroup G\n\u22a2 map f H = map f K \u2194 H \u2294 f.ker = K \u2294 f.ker"}, {"line": "simp only [le_antisymm_iff, map_le_map_iff']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem codisjoint_subgroupOf_sup (H K : Subgroup G) :\n    Codisjoint (H.subgroupOf (H \u2294 K)) (K.subgroupOf (H \u2294 K)) := by\n  rw [codisjoint_iff]\n  rw [sup_subgroupOf_eq]\n  rw [subgroupOf_self]\n  exacts [le_sup_left, le_sup_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Ker.lean", "context": {"open": ["Function", "scoped Int", "Subgroup", "MonoidHom"], "variables": ["{G G' G'' : Type*} [Group G] [Group G'] [Group G'']", "{A : Type*} [AddGroup A]", "{N : Type*} {P : Type*} [Group N] [Group P] (K : Subgroup G)", "{M : Type*} [MulOneClass M]", "{M : Type*} [Monoid M]", "{N : Type*} [Group N] (H : Subgroup G)", "(f : G \u2192* N)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH K : Subgroup G\n\u22a2 Codisjoint (H.subgroupOf (H \u2294 K)) (K.subgroupOf (H \u2294 K))"}, {"line": "rw [codisjoint_iff]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH K : Subgroup G\n\u22a2 H.subgroupOf (H \u2294 K) \u2294 K.subgroupOf (H \u2294 K) = \u22a4"}, {"line": "rw [sup_subgroupOf_eq]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH K : Subgroup G\n\u22a2 (H \u2294 K).subgroupOf (H \u2294 K) = \u22a4\n---\ncase hH\nG : Type u_1\ninst\u271d : Group G\nH K : Subgroup G\n\u22a2 H \u2264 H \u2294 K\n---\ncase hK\nG : Type u_1\ninst\u271d : Group G\nH K : Subgroup G\n\u22a2 K \u2264 H \u2294 K"}, {"line": "rw [subgroupOf_self]", "tactic_state": "case hH\nG : Type u_1\ninst\u271d : Group G\nH K : Subgroup G\n\u22a2 H \u2264 H \u2294 K\n---\ncase hK\nG : Type u_1\ninst\u271d : Group G\nH K : Subgroup G\n\u22a2 K \u2264 H \u2294 K"}, {"line": "exacts [le_sup_left, le_sup_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nontrivial_iff_exists_ne_one (H : Subgroup G) : Nontrivial H \u2194 \u2203 x \u2208 H, x \u2260 (1 : G) := by\n  rw [Subtype.nontrivial_iff_exists_ne (fun x => x \u2208 H) (1 : H)]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Lattice.lean", "context": {"open": ["Function", "scoped Int"], "variables": ["{G : Type*} [Group G]", "{A : Type*} [AddGroup A]", "(H K : Subgroup G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH : Subgroup G\n\u22a2 Nontrivial \u21a5H \u2194 \u2203 x \u2208 H, x \u2260 1"}, {"line": "rw [Subtype.nontrivial_iff_exists_ne (fun x => x \u2208 H) (1 : H)]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH : Subgroup G\n\u22a2 (\u2203 y, \u2203 (_ : y \u2208 H), y \u2260 \u21911) \u2194 \u2203 x \u2208 H, x \u2260 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_ne_one_of_nontrivial (H : Subgroup G) [Nontrivial H] :\n    \u2203 x \u2208 H, x \u2260 1 := by\n  rwa [\u2190 Subgroup.nontrivial_iff_exists_ne_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Lattice.lean", "context": {"open": ["Function", "scoped Int"], "variables": ["{G : Type*} [Group G]", "{A : Type*} [AddGroup A]", "(H K : Subgroup G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nH : Subgroup G\ninst\u271d : Nontrivial \u21a5H\n\u22a2 \u2203 x \u2208 H, x \u2260 1"}, {"line": "rwa [\u2190 Subgroup.nontrivial_iff_exists_ne_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_singleton_one : closure ({1} : Set G) = \u22a5 := by\n  simp [eq_bot_iff_forall, mem_closure_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Lattice.lean", "context": {"open": ["Function", "scoped Int", "Set"], "variables": ["{G : Type*} [Group G]", "{A : Type*} [AddGroup A]", "(H K : Subgroup G)", "{k : Set G}", "(G) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = \u22a5"}, {"line": "simp [eq_bot_iff_forall, mem_closure_singleton]", "tactic_state": "\u22a2 sorry () = \u22a5"}]}
{"declaration": "lemma mem_closure_singleton_self (x : G) : x \u2208 closure ({x} : Set G) := by\n  simpa [-subset_closure] using subset_closure (k := {x})\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Lattice.lean", "context": {"open": ["Function", "scoped Int", "Set"], "variables": ["{G : Type*} [Group G]", "{A : Type*} [AddGroup A]", "(H K : Subgroup G)", "{k : Set G}", "(G) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nx : G\n\u22a2 x \u2208 sorry"}, {"line": "simpa [-subset_closure] using subset_closure (k := {x})", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_symm_eq_iff_map_eq {H : Subgroup N} {e : G \u2243* N} :\n    H.map \u2191e.symm = K \u2194 K.map \u2191e = H := by\n  constructor <;> rintro rfl\n  \u00b7 rw [map_map, \u2190 MulEquiv.coe_monoidHom_trans, MulEquiv.symm_trans_self,\n      MulEquiv.coe_monoidHom_refl, map_id]\n  \u00b7 rw [map_map, \u2190 MulEquiv.coe_monoidHom_trans, MulEquiv.self_trans_symm,\n      MulEquiv.coe_monoidHom_refl, map_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Map.lean", "context": {"open": ["Function", "scoped Int", "Set"], "variables": ["{G G' G'' : Type*} [Group G] [Group G'] [Group G'']", "{A : Type*} [AddGroup A]", "(H K : Subgroup G) {k : Set G}", "{N : Type*} [Group N] {P : Type*} [Group P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nK : Subgroup G\nN : Type u_5\ninst\u271d : Group N\nH : Subgroup N\ne : G \u2243* N\n\u22a2 Subgroup.map (\u2191e.symm) H = K \u2194 Subgroup.map (\u2191e) K = H"}, {"line": "constructor <;> rintro rfl", "tactic_state": "case mp\nG : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_5\ninst\u271d : Group N\nH : Subgroup N\ne : G \u2243* N\n\u22a2 Subgroup.map (\u2191e) (Subgroup.map (\u2191e.symm) H) = H\n---\ncase mpr\nG : Type u_1\ninst\u271d\u00b9 : Group G\nK : Subgroup G\nN : Type u_5\ninst\u271d : Group N\ne : G \u2243* N\n\u22a2 Subgroup.map (\u2191e.symm) (Subgroup.map (\u2191e) K) = K"}, {"line": "\u00b7 rw [map_map, \u2190 MulEquiv.coe_monoidHom_trans, MulEquiv.symm_trans_self,\n      MulEquiv.coe_monoidHom_refl, map_id]", "tactic_state": "case mpr\nG : Type u_1\ninst\u271d\u00b9 : Group G\nK : Subgroup G\nN : Type u_5\ninst\u271d : Group N\ne : G \u2243* N\n\u22a2 Subgroup.map (\u2191e.symm) (Subgroup.map (\u2191e) K) = K"}, {"line": "\u00b7 rw [map_map, \u2190 MulEquiv.coe_monoidHom_trans, MulEquiv.self_trans_symm,\n      MulEquiv.coe_monoidHom_refl, map_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_iInf {\u03b9 : Sort*} [Nonempty \u03b9] (f : G \u2192* N) (hf : Function.Injective f)\n    (s : \u03b9 \u2192 Subgroup G) : (iInf s).map f = \u2a05 i, (s i).map f := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe \u2218 s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Map.lean", "context": {"open": ["Function", "scoped Int", "Set"], "variables": ["{G G' G'' : Type*} [Group G] [Group G'] [Group G'']", "{A : Type*} [AddGroup A]", "(H K : Subgroup G) {k : Set G}", "{N : Type*} [Group N] {P : Type*} [Group P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : Group G\nN : Type u_5\ninst\u271d\u00b9 : Group N\n\u03b9 : Sort u_7\ninst\u271d : Nonempty \u03b9\nf : G \u2192* N\nhf : Injective \u21d1f\ns : \u03b9 \u2192 Subgroup G\n\u22a2 Subgroup.map f (iInf s) = \u2a05 i, Subgroup.map f (s i)"}, {"line": "apply SetLike.coe_injective", "tactic_state": "case a\nG : Type u_1\ninst\u271d\u00b2 : Group G\nN : Type u_5\ninst\u271d\u00b9 : Group N\n\u03b9 : Sort u_7\ninst\u271d : Nonempty \u03b9\nf : G \u2192* N\nhf : Injective \u21d1f\ns : \u03b9 \u2192 Subgroup G\n\u22a2 \u2191(Subgroup.map f (iInf s)) = \u2191(\u2a05 i, Subgroup.map f (s i))"}, {"line": "simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe \u2218 s)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_top_of_surjective (f : G \u2192* N) (h : Function.Surjective f) : Subgroup.map f \u22a4 = \u22a4 := by\n  rw [eq_top_iff]\n  intro x _\n  obtain \u27e8y, hy\u27e9 := h x\n  exact \u27e8y, trivial, hy\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Map.lean", "context": {"open": ["Function", "scoped Int", "Set"], "variables": ["{G G' G'' : Type*} [Group G] [Group G'] [Group G'']", "{A : Type*} [AddGroup A]", "(H K : Subgroup G) {k : Set G}", "{N : Type*} [Group N] {P : Type*} [Group P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_5\ninst\u271d : Group N\nf : G \u2192* N\nh : Surjective \u21d1f\n\u22a2 Subgroup.map f \u22a4 = \u22a4"}, {"line": "rw [eq_top_iff]", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_5\ninst\u271d : Group N\nf : G \u2192* N\nh : Surjective \u21d1f\n\u22a2 \u22a4 \u2264 Subgroup.map f \u22a4"}, {"line": "intro x _", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_5\ninst\u271d : Group N\nf : G \u2192* N\nh : Surjective \u21d1f\nx : N\na\u271d : x \u2208 \u22a4\n\u22a2 x \u2208 Subgroup.map f \u22a4"}, {"line": "obtain \u27e8y, hy\u27e9 := h x", "tactic_state": "case intro\nG : Type u_1\ninst\u271d\u00b9 : Group G\nN : Type u_5\ninst\u271d : Group N\nf : G \u2192* N\nh : Surjective \u21d1f\nx : N\na\u271d : x \u2208 \u22a4\ny : G\nhy : f y = x\n\u22a2 x \u2208 Subgroup.map f \u22a4"}, {"line": "exact \u27e8y, trivial, hy\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_toSubmonoid (S : Set G) :\n    (closure S).toSubmonoid = Submonoid.closure (S \u222a S\u207b\u00b9) := by\n  refine le_antisymm (fun x hx => ?_) (Submonoid.closure_le.2 ?_)\n  \u00b7 refine\n      closure_induction\n        (fun x hx => Submonoid.closure_mono subset_union_left (Submonoid.subset_closure hx))\n        (Submonoid.one_mem _) (fun x y _ _ hx hy => Submonoid.mul_mem _ hx hy) (fun x _ hx => ?_) hx\n    rwa [\u2190 Submonoid.mem_closure_inv, Set.union_inv, inv_inv, Set.union_comm]\n  \u00b7 simp only [true_and, coe_toSubmonoid, union_subset_iff, subset_closure, inv_subset_closure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Pointwise.lean", "context": {"open": ["Set", "Pointwise", "Subgroup", "scoped RightActions in"], "variables": ["{\u03b1 G A S : Type*}", "[Group G] [AddGroup A] {s : Set G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nS : Set G\n\u22a2 (Subgroup.closure S).toSubmonoid = Submonoid.closure (S \u222a S\u207b\u00b9)"}, {"line": "refine le_antisymm (fun x hx => ?_) (Submonoid.closure_le.2 ?_)", "tactic_state": "case refine_1\nG : Type u_1\ninst\u271d : Group G\nS : Set G\nx : G\nhx : x \u2208 (Subgroup.closure S).toSubmonoid\n\u22a2 x \u2208 Submonoid.closure (S \u222a S\u207b\u00b9)\n---\ncase refine_2\nG : Type u_1\ninst\u271d : Group G\nS : Set G\n\u22a2 S \u222a S\u207b\u00b9 \u2286 \u2191(Subgroup.closure S).toSubmonoid"}, {"line": "\u00b7 refine\n      closure_induction\n        (fun x hx => Submonoid.closure_mono subset_union_left (Submonoid.subset_closure hx))\n        (Submonoid.one_mem _) (fun x y _ _ hx hy => Submonoid.mul_mem _ hx hy) (fun x _ hx => ?_) hx\n    rwa [\u2190 Submonoid.mem_closure_inv, Set.union_inv, inv_inv, Set.union_comm]", "tactic_state": "case refine_2\nG : Type u_1\ninst\u271d : Group G\nS : Set G\n\u22a2 S \u222a S\u207b\u00b9 \u2286 \u2191(Subgroup.closure S).toSubmonoid"}, {"line": "\u00b7 simp only [true_and, coe_toSubmonoid, union_subset_iff, subset_closure, inv_subset_closure]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem set_mul_normalizer_comm (S : Set G) (N : Subgroup G) (hLE : S \u2286 N.normalizer) :\n    S * N = N * S := by\n  rw [\u2190 iUnion_mul_left_image]\n  rw [\u2190 iUnion_mul_right_image]\n  simp only [image_mul_left]\n  simp only [image_mul_right]\n  simp only [Set.preimage]\n  congr! 5 with s hs x\n  exact (mem_normalizer_iff'.mp (inv_mem (hLE hs)) x).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Pointwise.lean", "context": {"open": ["Set", "Pointwise", "Subgroup", "scoped RightActions in"], "variables": ["{\u03b1 G A S : Type*}", "[Group G] [AddGroup A] {s : Set G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nS : Set G\nN : Subgroup G\nhLE : S \u2286 \u2191N.normalizer\n\u22a2 S * \u2191N = \u2191N * S"}, {"line": "rw [\u2190 iUnion_mul_left_image]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nS : Set G\nN : Subgroup G\nhLE : S \u2286 \u2191N.normalizer\n\u22a2 \u22c3 a \u2208 S, (fun x => a * x) '' \u2191N = \u2191N * S"}, {"line": "rw [\u2190 iUnion_mul_right_image]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nS : Set G\nN : Subgroup G\nhLE : S \u2286 \u2191N.normalizer\n\u22a2 \u22c3 a \u2208 S, (fun x => a * x) '' \u2191N = \u22c3 a \u2208 S, (fun x => x * a) '' \u2191N"}, {"line": "simp only [image_mul_left]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nS : Set G\nN : Subgroup G\nhLE : S \u2286 \u2191N.normalizer\n\u22a2 \u22c3 a \u2208 S, (fun x => a\u207b\u00b9 * x) \u207b\u00b9' \u2191N = \u22c3 a \u2208 S, (fun x => x * a) '' \u2191N"}, {"line": "simp only [image_mul_right]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nS : Set G\nN : Subgroup G\nhLE : S \u2286 \u2191N.normalizer\n\u22a2 \u22c3 a \u2208 S, (fun x => a\u207b\u00b9 * x) \u207b\u00b9' \u2191N = \u22c3 a \u2208 S, (fun x => x * a\u207b\u00b9) \u207b\u00b9' \u2191N"}, {"line": "simp only [Set.preimage]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nS : Set G\nN : Subgroup G\nhLE : S \u2286 \u2191N.normalizer\n\u22a2 \u22c3 a \u2208 S, {x | a\u207b\u00b9 * x \u2208 \u2191N} = \u22c3 a \u2208 S, {x | x * a\u207b\u00b9 \u2208 \u2191N}"}, {"line": "congr! 5 with s hs x", "tactic_state": "case h.e'_3.h.f.h.e'_2.h.a\nG : Type u_1\ninst\u271d : Group G\nS : Set G\nN : Subgroup G\nhLE : S \u2286 \u2191N.normalizer\ns : G\nhs : s \u2208 S\nx : G\n\u22a2 s\u207b\u00b9 * x \u2208 \u2191N \u2194 x * s\u207b\u00b9 \u2208 \u2191N"}, {"line": "exact (mem_normalizer_iff'.mp (inv_mem (hLE hs)) x).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_opposite_image_mul_preimage' (g : G) (h : G\u1d50\u1d52\u1d56) (s : Set G) :\n    (fun y => h \u2022 y) '' ((g * \u00b7) \u207b\u00b9' s) = (g * \u00b7) \u207b\u00b9' ((fun y => h \u2022 y) '' s) := by\n  simp [preimage_preimage, mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Pointwise.lean", "context": {"open": ["Set", "Pointwise", "Subgroup", "scoped RightActions in"], "variables": ["{\u03b1 G A S : Type*}", "[Group G] [AddGroup A] {s : Set G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\ng : G\nh : G\u1d50\u1d52\u1d56\ns : Set G\n\u22a2 (fun y => h \u2022 y) '' ((fun x => g * x) \u207b\u00b9' s) = (fun x => g * x) \u207b\u00b9' ((fun y => h \u2022 y) '' s)"}, {"line": "simp [preimage_preimage, mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem conj_smul_le_of_le {P H : Subgroup G} (hP : P \u2264 H) (h : H) :\n    MulAut.conj (h : G) \u2022 P \u2264 H := by\n  rintro - \u27e8g, hg, rfl\u27e9\n  exact H.mul_mem (H.mul_mem h.2 (hP hg)) (H.inv_mem h.2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Pointwise.lean", "context": {"open": ["Set", "Pointwise", "Subgroup", "scoped RightActions in"], "variables": ["{\u03b1 G A S : Type*}", "[Group G] [AddGroup A] {s : Set G}", "[Monoid \u03b1] [MulDistribMulAction \u03b1 G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nP H : Subgroup G\nhP : P \u2264 H\nh : \u21a5H\n\u22a2 MulAut.conj \u2191h \u2022 P \u2264 H"}, {"line": "rintro - \u27e8g, hg, rfl\u27e9", "tactic_state": "case intro.intro\nG : Type u_1\ninst\u271d : Group G\nP H : Subgroup G\nhP : P \u2264 H\nh : \u21a5H\ng : G\nhg : g \u2208 \u2191P\n\u22a2 ((MulDistribMulAction.toMonoidEnd (MulAut G) G) (MulAut.conj \u2191h)) g \u2208 H"}, {"line": "exact H.mul_mem (H.mul_mem h.2 (hP hg)) (H.inv_mem h.2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_inf (a : \u03b1) (S T : Subgroup G) : a \u2022 (S \u2293 T) = a \u2022 S \u2293 a \u2022 T := by\n  simp [SetLike.ext_iff, mem_pointwise_smul_iff_inv_smul_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Pointwise.lean", "context": {"open": ["Set", "Pointwise", "Subgroup", "scoped RightActions in"], "variables": ["{\u03b1 G A S : Type*}", "[Group G] [AddGroup A] {s : Set G}", "[Monoid \u03b1] [MulDistribMulAction \u03b1 G]", "[Group \u03b1] [MulDistribMulAction \u03b1 G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : MulDistribMulAction \u03b1 G\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : MulDistribMulAction \u03b1 G\na : \u03b1\nS T : Subgroup G\n\u22a2 a \u2022 (S \u2293 T) = a \u2022 S \u2293 a \u2022 T"}, {"line": "simp [SetLike.ext_iff, mem_pointwise_smul_iff_inv_smul_mem]", "tactic_state": "G : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : MulDistribMulAction \u03b1 G\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : MulDistribMulAction \u03b1 G\na : \u03b1\nS T : Subgroup G\n\u22a2 \u2200 (x : G), x \u2208 a \u2022 (S \u2293 T) \u2194 x \u2208 a \u2022 S \u2227 x \u2208 a \u2022 T"}]}
{"declaration": "theorem subgroup_mul_singleton {H : Subgroup G} {h : G} (hh : h \u2208 H) : (H : Set G) * {h} = H := by\n  simp [preimage, mul_mem_cancel_right (inv_mem hh)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Pointwise.lean", "context": {"open": ["Set", "Pointwise", "Subgroup", "scoped RightActions in"], "variables": ["{\u03b1 G A S : Type*}", "[Group G] [AddGroup A] {s : Set G}", "[Monoid \u03b1] [MulDistribMulAction \u03b1 G]", "[Group \u03b1] [MulDistribMulAction \u03b1 G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH : Subgroup G\nh : G\nhh : h \u2208 H\n\u22a2 \u2191H * {h} = \u2191H"}, {"line": "simp [preimage, mul_mem_cancel_right (inv_mem hh)]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH : Subgroup G\nh : G\nhh : h \u2208 H\n\u22a2 {x | x * h\u207b\u00b9 \u2208 H} = \u2191H"}]}
{"declaration": "theorem singleton_mul_subgroup {H : Subgroup G} {h : G} (hh : h \u2208 H) : {h} * (H : Set G) = H := by\n  simp [preimage, mul_mem_cancel_left (inv_mem hh)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/Pointwise.lean", "context": {"open": ["Set", "Pointwise", "Subgroup", "scoped RightActions in"], "variables": ["{\u03b1 G A S : Type*}", "[Group G] [AddGroup A] {s : Set G}", "[Monoid \u03b1] [MulDistribMulAction \u03b1 G]", "[Group \u03b1] [MulDistribMulAction \u03b1 G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH : Subgroup G\nh : G\nhh : h \u2208 H\n\u22a2 {h} * \u2191H = \u2191H"}, {"line": "simp [preimage, mul_mem_cancel_left (inv_mem hh)]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH : Subgroup G\nh : G\nhh : h \u2208 H\n\u22a2 {x | h\u207b\u00b9 * x \u2208 H} = \u2191H"}]}
{"declaration": "lemma Int.zmultiples_one : AddSubgroup.zmultiples (1 : \u2124) = \u22a4 := by\n  ext z\n  simpa only [AddSubgroup.mem_top, iff_true] using \u27e8z, zsmul_int_one z\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/ZPowers/Basic.lean", "context": {"open": [], "variables": ["{G : Type*} [Group G]", "{A : Type*} [AddGroup A]", "{N : Type*} [Group N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 AddSubgroup.zmultiples 1 = \u22a4"}, {"line": "ext z", "tactic_state": "case h\nz : \u2124\n\u22a2 z \u2208 AddSubgroup.zmultiples 1 \u2194 z \u2208 \u22a4"}, {"line": "simpa only [AddSubgroup.mem_top, iff_true] using \u27e8z, zsmul_int_one z\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofAdd_image_zmultiples_eq_zpowers_ofAdd {x : A} :\n    Multiplicative.ofAdd '' (AddSubgroup.zmultiples x : Set A) =\n      Subgroup.zpowers (Multiplicative.ofAdd x) := by\n  symm\n  rw [Equiv.eq_image_iff_symm_image_eq]\n  exact ofMul_image_zpowers_eq_zmultiples_ofMul\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/ZPowers/Basic.lean", "context": {"open": [], "variables": ["{G : Type*} [Group G]", "{A : Type*} [AddGroup A]", "{N : Type*} [Group N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\ninst\u271d : AddGroup A\nx : A\n\u22a2 \u21d1Multiplicative.ofAdd '' \u2191(AddSubgroup.zmultiples x) = \u2191(Subgroup.zpowers (Multiplicative.ofAdd x))"}, {"line": "symm", "tactic_state": "A : Type u_2\ninst\u271d : AddGroup A\nx : A\n\u22a2 \u2191(Subgroup.zpowers (Multiplicative.ofAdd x)) = \u21d1Multiplicative.ofAdd '' \u2191(AddSubgroup.zmultiples x)"}, {"line": "rw [Equiv.eq_image_iff_symm_image_eq]", "tactic_state": "A : Type u_2\ninst\u271d : AddGroup A\nx : A\n\u22a2 \u21d1Multiplicative.ofAdd.symm '' \u2191(Subgroup.zpowers (Multiplicative.ofAdd x)) = \u2191(AddSubgroup.zmultiples x)"}, {"line": "exact ofMul_image_zpowers_eq_zmultiples_ofMul", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Int.zmultiples_natAbs (a : \u2124) :\n    AddSubgroup.zmultiples (a.natAbs : \u2124) = AddSubgroup.zmultiples a := by\n  simp [le_antisymm_iff, Int.mem_zmultiples_iff, Int.dvd_natAbs, Int.natAbs_dvd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/ZPowers/Basic.lean", "context": {"open": [], "variables": ["{G : Type*} [Group G]", "{A : Type*} [AddGroup A]", "{N : Type*} [Group N]", "{s : Set G} {g : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2124\n\u22a2 AddSubgroup.zmultiples \u2191a.natAbs = AddSubgroup.zmultiples a"}, {"line": "simp [le_antisymm_iff, Int.mem_zmultiples_iff, Int.dvd_natAbs, Int.natAbs_dvd]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma AddSubgroup.closure_singleton_int_one_eq_top : closure ({1} : Set \u2124) = \u22a4 := by\n  ext\n  simp [mem_closure_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/ZPowers/Basic.lean", "context": {"open": [], "variables": ["{G : Type*} [Group G]", "{A : Type*} [AddGroup A]", "{N : Type*} [Group N]", "{s : Set G} {g : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 closure {1} = \u22a4"}, {"line": "ext", "tactic_state": "case h\nx\u271d : \u2124\n\u22a2 x\u271d \u2208 closure {1} \u2194 x\u271d \u2208 \u22a4"}, {"line": "simp [mem_closure_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma AddSubgroup.zmultiples_one_eq_top : zmultiples (1 : \u2124) = \u22a4 := by\n  rw [zmultiples_eq_closure]\n  rw [closure_singleton_int_one_eq_top]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subgroup/ZPowers/Basic.lean", "context": {"open": [], "variables": ["{G : Type*} [Group G]", "{A : Type*} [AddGroup A]", "{N : Type*} [Group N]", "{s : Set G} {g : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 zmultiples 1 = \u22a4"}, {"line": "rw [zmultiples_eq_closure]", "tactic_state": "\u22a2 closure {1} = \u22a4"}, {"line": "rw [closure_singleton_int_one_eq_top]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiset_prod_mem {M} [CommMonoid M] (S : Submonoid M) (m : Multiset M)\n    (hm : \u2200 a \u2208 m, a \u2208 S) : m.prod \u2208 S := by\n  lift m to Multiset S using hm\n  rw [\u2190 coe_multiset_prod]\n  exact m.prod.coe_prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/BigOperators.lean", "context": {"open": ["SubmonoidClass"], "variables": ["{M A B : Type*}", "[Monoid M] [SetLike B M] [SubmonoidClass B M] {x : M} {S : B}", "[Monoid M] {x : M} (s : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_4\ninst\u271d : CommMonoid M\nS : Submonoid M\nm : Multiset M\nhm : \u2200 a \u2208 m, a \u2208 S\n\u22a2 m.prod \u2208 S"}, {"line": "lift m to Multiset S using hm", "tactic_state": "case intro\nM : Type u_4\ninst\u271d : CommMonoid M\nS : Submonoid M\nm : Multiset \u21a5S\n\u22a2 (Multiset.map Subtype.val m).prod \u2208 S"}, {"line": "rw [\u2190 coe_multiset_prod]", "tactic_state": "case intro\nM : Type u_4\ninst\u271d : CommMonoid M\nS : Submonoid M\nm : Multiset \u21a5S\n\u22a2 \u2191m.prod \u2208 S"}, {"line": "exact m.prod.coe_prop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiset_noncommProd_mem (S : Submonoid M) (m : Multiset M) (comm) (h : \u2200 x \u2208 m, x \u2208 S) :\n    m.noncommProd comm \u2208 S := by\n  induction m using Quotient.inductionOn with | h l => ?_\n  simp only [Multiset.quot_mk_to_coe]\n  simp only [Multiset.noncommProd_coe]\n  exact Submonoid.list_prod_mem _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/BigOperators.lean", "context": {"open": ["SubmonoidClass"], "variables": ["{M A B : Type*}", "[Monoid M] [SetLike B M] [SubmonoidClass B M] {x : M} {S : B}", "[Monoid M] {x : M} (s : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 inst\u271d : Monoid M\nS : Submonoid M\nm : Multiset M\ncomm : {x | x \u2208 m}.Pairwise Commute\nh : \u2200 x \u2208 m, x \u2208 S\n\u22a2 m.noncommProd comm \u2208 S"}, {"line": "induction m using Quotient.inductionOn with | h l => ?_", "tactic_state": "case h\nM : Type u_1\ninst\u271d\u00b9 inst\u271d : Monoid M\nS : Submonoid M\nl : List M\ncomm : {x | x \u2208 \u27e6l\u27e7}.Pairwise Commute\nh : \u2200 x \u2208 \u27e6l\u27e7, x \u2208 S\n\u22a2 Multiset.noncommProd \u27e6l\u27e7 comm \u2208 S"}, {"line": "simp only [Multiset.quot_mk_to_coe]", "tactic_state": "case h\nM : Type u_1\ninst\u271d\u00b9 inst\u271d : Monoid M\nS : Submonoid M\nl : List M\ncomm : {x | x \u2208 \u27e6l\u27e7}.Pairwise Commute\nh : \u2200 x \u2208 \u27e6l\u27e7, x \u2208 S\n\u22a2 (\u2191l).noncommProd \u22ef \u2208 S"}, {"line": "simp only [Multiset.noncommProd_coe]", "tactic_state": "case h\nM : Type u_1\ninst\u271d\u00b9 inst\u271d : Monoid M\nS : Submonoid M\nl : List M\ncomm : {x | x \u2208 \u27e6l\u27e7}.Pairwise Commute\nh : \u2200 x \u2208 \u27e6l\u27e7, x \u2208 S\n\u22a2 l.prod \u2208 S"}, {"line": "exact Submonoid.list_prod_mem _ h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mk_eq_one {a : M} {ha} : (\u27e8a, ha\u27e9 : S) = 1 \u2194 a = 1 := by simp [\u2190 SetLike.coe_eq_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Defs.lean", "context": {"open": ["Submonoid"], "variables": ["{M : Type*} {N : Type*}", "[MulOneClass M] {s : Set M}", "{S : Submonoid M}", "(S)", "[MulOneClass N]", "{A M\u2081 : Type*} [SetLike A M\u2081] [One M\u2081] [hA : OneMemClass A M\u2081] (S' : A)", "{S'}", "(S')", "{A : Type*} [MulOneClass M] [SetLike A M] [hA : SubmonoidClass A M] (S' : A)", "{S'} in", "{M : Type*} [MulOneClass M] (S : Submonoid M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 : MulOneClass M\nS : Submonoid M\ninst\u271d : MulOneClass M\na : M\nha : a \u2208 S\n\u22a2 \u27e8a, ha\u27e9 = 1 \u2194 a = 1"}, {"line": "simp [\u2190 SetLike.coe_eq_coe]", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 : MulOneClass M\nS : Submonoid M\ninst\u271d : MulOneClass M\na : M\nha : a \u2208 S\n\u22a2 a = 1 \u2194 a = 1"}]}
{"declaration": "theorem mem_closure_range_iff :\n    x \u2208 closure (Set.range f) \u2194 \u2203 a : \u03b9 \u2192\u2080 \u2115, x = a.prod (f \u00b7 ^ \u00b7) := by\n  refine \u27e8exists_finsupp_of_mem_closure_range f x, ?_\u27e9\n  rintro \u27e8a, rfl\u27e9\n  exact prod_mem _ fun i hi \u21a6 pow_mem (subset_closure (Set.mem_range_self i)) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Finsupp.lean", "context": {"open": [], "variables": ["{M : Type*} [CommMonoid M] {\u03b9 : Type*} (f : \u03b9 \u2192 M) (x : M)", "{f x} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d : CommMonoid M\n\u03b9 : Type u_2\nf : \u03b9 \u2192 M\nx : M\n\u22a2 x \u2208 sorry \u2194 \u2203 a, x = a.prod fun x1 x2 => f x1 ^ x2"}, {"line": "refine \u27e8exists_finsupp_of_mem_closure_range f x, ?_\u27e9", "tactic_state": "M : Type u_1\ninst\u271d : CommMonoid M\n\u03b9 : Type u_2\nf : \u03b9 \u2192 M\nx : M\n\u22a2 (\u2203 a, x = a.prod fun x1 x2 => f x1 ^ x2) \u2192 x \u2208 sorry"}, {"line": "rintro \u27e8a, rfl\u27e9", "tactic_state": "case intro\nM : Type u_1\ninst\u271d : CommMonoid M\n\u03b9 : Type u_2\nf : \u03b9 \u2192 M\na : \u03b9 \u2192\u2080 \u2115\n\u22a2 (a.prod fun x1 x2 => f x1 ^ x2) \u2208 sorry"}, {"line": "exact prod_mem _ fun i hi \u21a6 pow_mem (subset_closure (Set.mem_range_self i)) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_sSup_of_directedOn {S : Set (Submonoid M)} (Sne : S.Nonempty)\n    (hS : DirectedOn (\u00b7 \u2264 \u00b7) S) {x : M} : x \u2208 sSup S \u2194 \u2203 s \u2208 S, x \u2208 s := by\n  haveI : Nonempty S := Sne.to_subtype\n  simp [sSup_eq_iSup', mem_iSup_of_directed hS.directed_val, SetCoe.exists, Subtype.coe_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Membership.lean", "context": {"open": ["Set"], "variables": ["{M A B : Type*}", "[Monoid M] [SetLike B M] [SubmonoidClass B M] {S : B}", "[MulOneClass M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 : Monoid M\ninst\u271d : MulOneClass M\nS : Set (Submonoid M)\nSne : S.Nonempty\nhS : DirectedOn (fun x1 x2 => x1 \u2264 x2) S\nx : M\n\u22a2 x \u2208 sSup S \u2194 \u2203 s \u2208 S, x \u2208 s"}, {"line": "haveI : Nonempty S := Sne.to_subtype", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 : Monoid M\ninst\u271d : MulOneClass M\nS : Set (Submonoid M)\nSne : S.Nonempty\nhS : DirectedOn (fun x1 x2 => x1 \u2264 x2) S\nx : M\nthis : Nonempty \u2191S\n\u22a2 x \u2208 sSup S \u2194 \u2203 s \u2208 S, x \u2208 s"}, {"line": "simp [sSup_eq_iSup', mem_iSup_of_directed hS.directed_val, SetCoe.exists, Subtype.coe_mk]", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 : Monoid M\ninst\u271d : MulOneClass M\nS : Set (Submonoid M)\nSne : S.Nonempty\nhS : DirectedOn (fun x1 x2 => x1 \u2264 x2) S\nx : M\nthis : Nonempty \u2191S\n\u22a2 x \u2208 \u2a06 a, \u2191a \u2194 \u2203 s \u2208 S, x \u2208 s"}]}
{"declaration": "theorem closure_singleton_one : closure ({1} : Set M) = \u22a5 := by\n  simp [eq_bot_iff_forall, mem_closure_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Membership.lean", "context": {"open": ["Set", "Submonoid", "MonoidHom"], "variables": ["{M A B : Type*}", "[Monoid M] [SetLike B M] [SubmonoidClass B M] {S : B}", "[MulOneClass M]", "{\u03b1 : Type*}", "[Monoid M] {a : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : MulOneClass M\ninst\u271d : Monoid M\n\u22a2 Submonoid.closure {1} = \u22a5"}, {"line": "simp [eq_bot_iff_forall, mem_closure_singleton]", "tactic_state": "M : Type u_1\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : MulOneClass M\ninst\u271d : Monoid M\n\u22a2 \u2200 x \u2208 Submonoid.closure {1}, x = 1"}]}
{"declaration": "lemma powers_le {n : M} {P : Submonoid M} : powers n \u2264 P \u2194 n \u2208 P := by simp [powers_eq_closure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Membership.lean", "context": {"open": ["Set", "Submonoid", "MonoidHom", "Fintype"], "variables": ["{M A B : Type*}", "[Monoid M] [SetLike B M] [SubmonoidClass B M] {S : B}", "[MulOneClass M]", "{\u03b1 : Type*}", "[Monoid M] {a : M}", "{S : Submonoid M} [Fintype S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : MulOneClass M\ninst\u271d : Monoid M\nn : M\nP : Submonoid M\n\u22a2 sorry \u2194 n \u2208 P"}, {"line": "simp [powers_eq_closure]", "tactic_state": "M : Type u_1\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : MulOneClass M\ninst\u271d : Monoid M\nn : M\nP : Submonoid M\n\u22a2 sorry () \u2194 n \u2208 P"}]}
{"declaration": "theorem mem_sup {s t : Submonoid N} {x : N} : x \u2208 s \u2294 t \u2194 \u2203 y \u2208 s, \u2203 z \u2208 t, y * z = x := by\n  simp only [sup_eq_range]\n  simp only [mem_mrange]\n  simp only [coprod_apply]\n  simp only [coe_subtype]\n  simp only [Prod.exists]\n  simp only [Subtype.exists]\n  simp only [exists_prop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Membership.lean", "context": {"open": ["Set", "Submonoid", "MonoidHom", "Fintype", "MonoidHom"], "variables": ["{M A B : Type*}", "[Monoid M] [SetLike B M] [SubmonoidClass B M] {S : B}", "[MulOneClass M]", "{\u03b1 : Type*}", "[Monoid M] {a : M}", "{S : Submonoid M} [Fintype S]", "{N : Type*} [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : Type u_5\ninst\u271d : CommMonoid N\ns t : Submonoid N\nx : N\n\u22a2 x \u2208 s \u2294 t \u2194 \u2203 y \u2208 s, \u2203 z \u2208 t, y * z = x"}, {"line": "simp only [sup_eq_range]", "tactic_state": "N : Type u_5\ninst\u271d : CommMonoid N\ns t : Submonoid N\nx : N\n\u22a2 x \u2208 mrange (s.subtype.coprod t.subtype) \u2194 \u2203 y \u2208 s, \u2203 z \u2208 t, y * z = x"}, {"line": "simp only [mem_mrange]", "tactic_state": "N : Type u_5\ninst\u271d : CommMonoid N\ns t : Submonoid N\nx : N\n\u22a2 (\u2203 x_1, (s.subtype.coprod t.subtype) x_1 = x) \u2194 \u2203 y \u2208 s, \u2203 z \u2208 t, y * z = x"}, {"line": "simp only [coprod_apply]", "tactic_state": "N : Type u_5\ninst\u271d : CommMonoid N\ns t : Submonoid N\nx : N\n\u22a2 (\u2203 x_1, s.subtype x_1.1 * t.subtype x_1.2 = x) \u2194 \u2203 y \u2208 s, \u2203 z \u2208 t, y * z = x"}, {"line": "simp only [coe_subtype]", "tactic_state": "N : Type u_5\ninst\u271d : CommMonoid N\ns t : Submonoid N\nx : N\n\u22a2 (\u2203 x_1, \u2191x_1.1 * \u2191x_1.2 = x) \u2194 \u2203 y \u2208 s, \u2203 z \u2208 t, y * z = x"}, {"line": "simp only [Prod.exists]", "tactic_state": "N : Type u_5\ninst\u271d : CommMonoid N\ns t : Submonoid N\nx : N\n\u22a2 (\u2203 a b, \u2191a * \u2191b = x) \u2194 \u2203 y \u2208 s, \u2203 z \u2208 t, y * z = x"}, {"line": "simp only [Subtype.exists]", "tactic_state": "N : Type u_5\ninst\u271d : CommMonoid N\ns t : Submonoid N\nx : N\n\u22a2 (\u2203 a, \u2203 (_ : a \u2208 s), \u2203 a_1, \u2203 (_ : a_1 \u2208 t), a * a_1 = x) \u2194 \u2203 y \u2208 s, \u2203 z \u2208 t, y * z = x"}, {"line": "simp only [exists_prop]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_singleton_zero : closure ({0} : Set A) = \u22a5 := by\n  simp [eq_bot_iff_forall, mem_closure_singleton, nsmul_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Membership.lean", "context": {"open": ["Set", "Submonoid", "MonoidHom", "Fintype", "MonoidHom", "Set"], "variables": ["{M A B : Type*}", "[Monoid M] [SetLike B M] [SubmonoidClass B M] {S : B}", "[MulOneClass M]", "{\u03b1 : Type*}", "[Monoid M] {a : M}", "{S : Submonoid M} [Fintype S]", "{N : Type*} [CommMonoid N]", "[AddMonoid A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = \u22a5"}, {"line": "simp [eq_bot_iff_forall, mem_closure_singleton, nsmul_zero]", "tactic_state": "\u22a2 sorry () = \u22a5"}]}
{"declaration": "theorem mem_closure_pair {A : Type*} [CommMonoid A] (a b c : A) :\n    c \u2208 Submonoid.closure ({a, b} : Set A) \u2194 \u2203 m n : \u2115, a ^ m * b ^ n = c := by\n  rw [\u2190 Set.singleton_union]\n  rw [Submonoid.closure_union]\n  rw [mem_sup]\n  simp_rw [mem_closure_singleton, exists_exists_eq_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Membership.lean", "context": {"open": ["Set", "Submonoid", "MonoidHom", "Fintype", "MonoidHom", "Set"], "variables": ["{M A B : Type*}", "[Monoid M] [SetLike B M] [SubmonoidClass B M] {S : B}", "[MulOneClass M]", "{\u03b1 : Type*}", "[Monoid M] {a : M}", "{S : Submonoid M} [Fintype S]", "{N : Type*} [CommMonoid N]", "[AddMonoid A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_6\ninst\u271d : CommMonoid A\na b c : A\n\u22a2 c \u2208 Submonoid.closure {a, b} \u2194 \u2203 m n, a ^ m * b ^ n = c"}, {"line": "rw [\u2190 Set.singleton_union]", "tactic_state": "A : Type u_6\ninst\u271d : CommMonoid A\na b c : A\n\u22a2 c \u2208 Submonoid.closure ({a} \u222a {b}) \u2194 \u2203 m n, a ^ m * b ^ n = c"}, {"line": "rw [Submonoid.closure_union]", "tactic_state": "A : Type u_6\ninst\u271d : CommMonoid A\na b c : A\n\u22a2 c \u2208 Submonoid.closure {a} \u2294 Submonoid.closure {b} \u2194 \u2203 m n, a ^ m * b ^ n = c"}, {"line": "rw [mem_sup]", "tactic_state": "A : Type u_6\ninst\u271d : CommMonoid A\na b c : A\n\u22a2 (\u2203 y \u2208 Submonoid.closure {a}, \u2203 z \u2208 Submonoid.closure {b}, y * z = c) \u2194 \u2203 m n, a ^ m * b ^ n = c"}, {"line": "simp_rw [mem_closure_singleton, exists_exists_eq_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofAdd_image_multiples_eq_powers_ofAdd [AddMonoid A] {x : A} :\n    Multiplicative.ofAdd '' (AddSubmonoid.multiples x : Set A) =\n      Submonoid.powers (Multiplicative.ofAdd x) := by\n  symm\n  rw [Equiv.eq_image_iff_symm_image_eq]\n  exact ofMul_image_powers_eq_multiples_ofMul\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Membership.lean", "context": {"open": ["Set", "Submonoid", "MonoidHom", "Fintype", "MonoidHom", "Set"], "variables": ["{M A B : Type*}", "[Monoid M] [SetLike B M] [SubmonoidClass B M] {S : B}", "[MulOneClass M]", "{\u03b1 : Type*}", "[Monoid M] {a : M}", "{S : Submonoid M} [Fintype S]", "{N : Type*} [CommMonoid N]", "[AddMonoid A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\ninst\u271d\u00b9 inst\u271d : AddMonoid A\nx : A\n\u22a2 \u21d1Multiplicative.ofAdd '' \u2191(AddSubmonoid.multiples x) = \u2191(powers (Multiplicative.ofAdd x))"}, {"line": "symm", "tactic_state": "A : Type u_2\ninst\u271d\u00b9 inst\u271d : AddMonoid A\nx : A\n\u22a2 \u2191(powers (Multiplicative.ofAdd x)) = \u21d1Multiplicative.ofAdd '' \u2191(AddSubmonoid.multiples x)"}, {"line": "rw [Equiv.eq_image_iff_symm_image_eq]", "tactic_state": "A : Type u_2\ninst\u271d\u00b9 inst\u271d : AddMonoid A\nx : A\n\u22a2 \u21d1Multiplicative.ofAdd.symm '' \u2191(powers (Multiplicative.ofAdd x)) = \u2191(AddSubmonoid.multiples x)"}, {"line": "exact ofMul_image_powers_eq_multiples_ofMul", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_eq_closure {\u03b9 : Sort*} (p : \u03b9 \u2192 Submonoid M) :\n    \u2a06 i, p i = Submonoid.closure (\u22c3 i, (p i : Set M)) := by\n  simp_rw [Submonoid.closure_iUnion, Submonoid.closure_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Basic.lean", "context": {"open": ["Set"], "variables": ["{M : Type*} {N : Type*}", "{A : Type*}", "[MulOneClass M] {s : Set M}", "[AddZeroClass A] {t : Set A}", "(S : Submonoid M)", "{S}", "(S)", "(M)", "{M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d : MulOneClass M\n\u03b9 : Sort u_4\np : \u03b9 \u2192 Submonoid M\n\u22a2 \u2a06 i, p i = Submonoid.closure (\u22c3 i, \u2191(p i))"}, {"line": "simp_rw [Submonoid.closure_iUnion, Submonoid.closure_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "example {S : Submonoid M'} : IsScalarTower S M' M' := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/MulAction.lean", "context": {"open": [], "variables": ["{M' : Type*} {\u03b1 \u03b2 : Type*}", "{S' : Type*} [SetLike S' M'] (s : S')", "[MulOneClass M']", "[Monoid M'] [SubmonoidClass S' M']", "[MulOneClass M']", "[SMul M' \u03b1] {S : Submonoid M'}", "[Monoid M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M' : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nS' : Type u_4\ninst\u271d\u2076 : SetLike S' M'\ns : S'\ninst\u271d\u2075 : MulOneClass M'\ninst\u271d\u2074 : Monoid M'\ninst\u271d\u00b3 : SubmonoidClass S' M'\ninst\u271d\u00b2 : MulOneClass M'\ninst\u271d\u00b9 : SMul M' \u03b1\nS\u271d : Submonoid M'\ninst\u271d : Monoid M'\nS : Submonoid M'\n\u22a2 IsScalarTower (\u21a5S) M' M'"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mrange_id : mrange (MonoidHom.id M) = \u22a4 := by\n  simp [mrange_eq_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Operations.lean", "context": {"open": ["Function", "Set", "MonoidHom", "Submonoid"], "variables": ["{M N P : Type*} [MulOneClass M] [MulOneClass N] [MulOneClass P] (S : Submonoid M)", "{A : Type*} [AddZeroClass A]", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]", "{\u03b9 : Type*} {f : F}", "(hf : Function.Injective f)", "{\u03b9 : Type*} {f : F}", "(hf : Function.Surjective f)", "{M : Type*} [MulOneClass M] (S : Submonoid M)", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_8\ninst\u271d : MulOneClass M\n\u22a2 mrange (MonoidHom.id M) = \u22a4"}, {"line": "simp [mrange_eq_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_mrange (g : N \u2192* P) (f : M \u2192* N) : (mrange f).map g = mrange (comp g f) := by\n  simpa only [mrange_eq_map] using (\u22a4 : Submonoid M).map_map g f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Operations.lean", "context": {"open": ["Function", "Set", "MonoidHom", "Submonoid"], "variables": ["{M N P : Type*} [MulOneClass M] [MulOneClass N] [MulOneClass P] (S : Submonoid M)", "{A : Type*} [AddZeroClass A]", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]", "{\u03b9 : Type*} {f : F}", "(hf : Function.Injective f)", "{\u03b9 : Type*} {f : F}", "(hf : Function.Surjective f)", "{M : Type*} [MulOneClass M] (S : Submonoid M)", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : MulOneClass N\ninst\u271d\u00b9 : MulOneClass P\nM : Type u_8\ninst\u271d : MulOneClass M\ng : N \u2192* P\nf : M \u2192* N\n\u22a2 map g (mrange f) = sorry"}, {"line": "simpa only [mrange_eq_map] using (\u22a4 : Submonoid M).map_map g f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem restrict_mrange (f : M \u2192* N) : mrange (f.restrict S) = S.map f := by\n  simp [SetLike.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Operations.lean", "context": {"open": ["Function", "Set", "MonoidHom", "Submonoid"], "variables": ["{M N P : Type*} [MulOneClass M] [MulOneClass N] [MulOneClass P] (S : Submonoid M)", "{A : Type*} [AddZeroClass A]", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]", "{\u03b9 : Type*} {f : F}", "(hf : Function.Injective f)", "{\u03b9 : Type*} {f : F}", "(hf : Function.Surjective f)", "{M : Type*} [MulOneClass M] (S : Submonoid M)", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : Type u_2\ninst\u271d\u00b9 : MulOneClass N\nM : Type u_8\ninst\u271d : MulOneClass M\nS : Submonoid M\nf : M \u2192* N\n\u22a2 mrange (f.restrict S) = map f S"}, {"line": "simp [SetLike.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mker_prod_map {M' : Type*} {N' : Type*} [MulOneClass M'] [MulOneClass N'] (f : M \u2192* N)\n    (g : M' \u2192* N') : mker (prodMap f g) = (mker f).prod (mker g) := by\n  rw [\u2190 comap_bot']\n  rw [\u2190 comap_bot']\n  rw [\u2190 comap_bot']\n  rw [\u2190 prod_map_comap_prod']\n  rw [bot_prod_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Operations.lean", "context": {"open": ["Function", "Set", "MonoidHom", "Submonoid"], "variables": ["{M N P : Type*} [MulOneClass M] [MulOneClass N] [MulOneClass P] (S : Submonoid M)", "{A : Type*} [AddZeroClass A]", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]", "{\u03b9 : Type*} {f : F}", "(hf : Function.Injective f)", "{\u03b9 : Type*} {f : F}", "(hf : Function.Surjective f)", "{M : Type*} [MulOneClass M] (S : Submonoid M)", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : Type u_2\ninst\u271d\u00b3 : MulOneClass N\nM : Type u_8\ninst\u271d\u00b2 : MulOneClass M\nM' : Type u_10\nN' : Type u_11\ninst\u271d\u00b9 : MulOneClass M'\ninst\u271d : MulOneClass N'\nf : M \u2192* N\ng : M' \u2192* N'\n\u22a2 mker (f.prodMap g) = (mker f).prod (mker g)"}, {"line": "rw [\u2190 comap_bot']", "tactic_state": "N : Type u_2\ninst\u271d\u00b3 : MulOneClass N\nM : Type u_8\ninst\u271d\u00b2 : MulOneClass M\nM' : Type u_10\nN' : Type u_11\ninst\u271d\u00b9 : MulOneClass M'\ninst\u271d : MulOneClass N'\nf : M \u2192* N\ng : M' \u2192* N'\n\u22a2 comap (f.prodMap g) \u22a5 = (mker f).prod (mker g)"}, {"line": "rw [\u2190 comap_bot']", "tactic_state": "N : Type u_2\ninst\u271d\u00b3 : MulOneClass N\nM : Type u_8\ninst\u271d\u00b2 : MulOneClass M\nM' : Type u_10\nN' : Type u_11\ninst\u271d\u00b9 : MulOneClass M'\ninst\u271d : MulOneClass N'\nf : M \u2192* N\ng : M' \u2192* N'\n\u22a2 comap (f.prodMap g) \u22a5 = (comap f \u22a5).prod (mker g)"}, {"line": "rw [\u2190 comap_bot']", "tactic_state": "N : Type u_2\ninst\u271d\u00b3 : MulOneClass N\nM : Type u_8\ninst\u271d\u00b2 : MulOneClass M\nM' : Type u_10\nN' : Type u_11\ninst\u271d\u00b9 : MulOneClass M'\ninst\u271d : MulOneClass N'\nf : M \u2192* N\ng : M' \u2192* N'\n\u22a2 comap (f.prodMap g) \u22a5 = (comap f \u22a5).prod (comap g \u22a5)"}, {"line": "rw [\u2190 prod_map_comap_prod']", "tactic_state": "N : Type u_2\ninst\u271d\u00b3 : MulOneClass N\nM : Type u_8\ninst\u271d\u00b2 : MulOneClass M\nM' : Type u_10\nN' : Type u_11\ninst\u271d\u00b9 : MulOneClass M'\ninst\u271d : MulOneClass N'\nf : M \u2192* N\ng : M' \u2192* N'\n\u22a2 comap (f.prodMap g) \u22a5 = comap (f.prodMap g) (\u22a5.prod \u22a5)"}, {"line": "rw [bot_prod_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem submonoidMap_surjective (f : M \u2192* N) (M' : Submonoid M) :\n    Function.Surjective (f.submonoidMap M') := by\n  rintro \u27e8_, x, hx, rfl\u27e9\n  exact \u27e8\u27e8x, hx\u27e9, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Operations.lean", "context": {"open": ["Function", "Set", "MonoidHom", "Submonoid"], "variables": ["{M N P : Type*} [MulOneClass M] [MulOneClass N] [MulOneClass P] (S : Submonoid M)", "{A : Type*} [AddZeroClass A]", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]", "{\u03b9 : Type*} {f : F}", "(hf : Function.Injective f)", "{\u03b9 : Type*} {f : F}", "(hf : Function.Surjective f)", "{M : Type*} [MulOneClass M] (S : Submonoid M)", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : Type u_2\ninst\u271d\u00b9 : MulOneClass N\nM : Type u_8\ninst\u271d : MulOneClass M\nf : M \u2192* N\nM' : Submonoid M\n\u22a2 Surjective \u21d1(f.submonoidMap M')"}, {"line": "rintro \u27e8_, x, hx, rfl\u27e9", "tactic_state": "case mk.intro.intro\nN : Type u_2\ninst\u271d\u00b9 : MulOneClass N\nM : Type u_8\ninst\u271d : MulOneClass M\nf : M \u2192* N\nM' : Submonoid M\nx : M\nhx : x \u2208 \u2191M'\n\u22a2 \u2203 a, (f.submonoidMap M') a = \u27e8f x, \u22ef\u27e9"}, {"line": "exact \u27e8\u27e8x, hx\u27e9, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_eq_bot_iff {s : Submonoid M} {t : Submonoid N} : s.prod t = \u22a5 \u2194 s = \u22a5 \u2227 t = \u22a5 := by\n  simp only [eq_bot_iff]\n  simp only [prod_le_iff]\n  simp only [(gc_map_comap _).le_iff_le]\n  simp only [comap_bot']\n  simp only [mker_inl]\n  simp only [mker_inr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Operations.lean", "context": {"open": ["Function", "Set", "MonoidHom", "Submonoid", "MonoidHom"], "variables": ["{M N P : Type*} [MulOneClass M] [MulOneClass N] [MulOneClass P] (S : Submonoid M)", "{A : Type*} [AddZeroClass A]", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]", "{\u03b9 : Type*} {f : F}", "(hf : Function.Injective f)", "{\u03b9 : Type*} {f : F}", "(hf : Function.Surjective f)", "{M : Type*} [MulOneClass M] (S : Submonoid M)", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : Type u_2\ninst\u271d\u00b9 : MulOneClass N\nM : Type u_8\ninst\u271d : MulOneClass M\ns : Submonoid M\nt : Submonoid N\n\u22a2 s.prod t = \u22a5 \u2194 s = \u22a5 \u2227 t = \u22a5"}, {"line": "simp only [eq_bot_iff]", "tactic_state": "N : Type u_2\ninst\u271d\u00b9 : MulOneClass N\nM : Type u_8\ninst\u271d : MulOneClass M\ns : Submonoid M\nt : Submonoid N\n\u22a2 s.prod t \u2264 \u22a5 \u2194 s \u2264 \u22a5 \u2227 t \u2264 \u22a5"}, {"line": "simp only [prod_le_iff]", "tactic_state": "N : Type u_2\ninst\u271d\u00b9 : MulOneClass N\nM : Type u_8\ninst\u271d : MulOneClass M\ns : Submonoid M\nt : Submonoid N\n\u22a2 map (inl M N) s \u2264 \u22a5 \u2227 map (inr M N) t \u2264 \u22a5 \u2194 s \u2264 \u22a5 \u2227 t \u2264 \u22a5"}, {"line": "simp only [(gc_map_comap _).le_iff_le]", "tactic_state": "N : Type u_2\ninst\u271d\u00b9 : MulOneClass N\nM : Type u_8\ninst\u271d : MulOneClass M\ns : Submonoid M\nt : Submonoid N\n\u22a2 s \u2264 comap (inl M N) \u22a5 \u2227 t \u2264 comap (inr M N) \u22a5 \u2194 s \u2264 \u22a5 \u2227 t \u2264 \u22a5"}, {"line": "simp only [comap_bot']", "tactic_state": "N : Type u_2\ninst\u271d\u00b9 : MulOneClass N\nM : Type u_8\ninst\u271d : MulOneClass M\ns : Submonoid M\nt : Submonoid N\n\u22a2 s \u2264 mker (inl M N) \u2227 t \u2264 mker (inr M N) \u2194 s \u2264 \u22a5 \u2227 t \u2264 \u22a5"}, {"line": "simp only [mker_inl]", "tactic_state": "N : Type u_2\ninst\u271d\u00b9 : MulOneClass N\nM : Type u_8\ninst\u271d : MulOneClass M\ns : Submonoid M\nt : Submonoid N\n\u22a2 s \u2264 \u22a5 \u2227 t \u2264 mker (inr M N) \u2194 s \u2264 \u22a5 \u2227 t \u2264 \u22a5"}, {"line": "simp only [mker_inr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mrange_inl_sup_mrange_inr : mrange (inl M N) \u2294 mrange (inr M N) = \u22a4 := by\n  simp only [mrange_inl]\n  simp only [mrange_inr]\n  simp only [prod_bot_sup_bot_prod]\n  simp only [top_prod_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Operations.lean", "context": {"open": ["Function", "Set", "MonoidHom", "Submonoid", "MonoidHom"], "variables": ["{M N P : Type*} [MulOneClass M] [MulOneClass N] [MulOneClass P] (S : Submonoid M)", "{A : Type*} [AddZeroClass A]", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]", "{\u03b9 : Type*} {f : F}", "(hf : Function.Injective f)", "{\u03b9 : Type*} {f : F}", "(hf : Function.Surjective f)", "{M : Type*} [MulOneClass M] (S : Submonoid M)", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : Type u_2\ninst\u271d\u00b9 : MulOneClass N\nM : Type u_8\ninst\u271d : MulOneClass M\n\u22a2 mrange (inl M N) \u2294 mrange (inr M N) = \u22a4"}, {"line": "simp only [mrange_inl]", "tactic_state": "N : Type u_2\ninst\u271d\u00b9 : MulOneClass N\nM : Type u_8\ninst\u271d : MulOneClass M\n\u22a2 \u22a4.prod \u22a5 \u2294 mrange (inr M N) = \u22a4"}, {"line": "simp only [mrange_inr]", "tactic_state": "N : Type u_2\ninst\u271d\u00b9 : MulOneClass N\nM : Type u_8\ninst\u271d : MulOneClass M\n\u22a2 \u22a4.prod \u22a5 \u2294 \u22a5.prod \u22a4 = \u22a4"}, {"line": "simp only [prod_bot_sup_bot_prod]", "tactic_state": "N : Type u_2\ninst\u271d\u00b9 : MulOneClass N\nM : Type u_8\ninst\u271d : MulOneClass M\n\u22a2 \u22a4.prod \u22a4 = \u22a4"}, {"line": "simp only [top_prod_top]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_bot_of_subsingleton [Subsingleton S] : S = \u22a5 := by\n  rw [eq_bot_iff_forall]\n  intro y hy\n  simpa using congr_arg ((\u2191) : S \u2192 M) <| Subsingleton.elim (\u27e8y, hy\u27e9 : S) 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Operations.lean", "context": {"open": ["Function", "Set", "MonoidHom", "Submonoid", "MonoidHom"], "variables": ["{M N P : Type*} [MulOneClass M] [MulOneClass N] [MulOneClass P] (S : Submonoid M)", "{A : Type*} [AddZeroClass A]", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]", "{\u03b9 : Type*} {f : F}", "(hf : Function.Injective f)", "{\u03b9 : Type*} {f : F}", "(hf : Function.Surjective f)", "{M : Type*} [MulOneClass M] (S : Submonoid M)", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_8\ninst\u271d\u00b9 : MulOneClass M\nS : Submonoid M\ninst\u271d : Subsingleton \u21a5S\n\u22a2 S = \u22a5"}, {"line": "rw [eq_bot_iff_forall]", "tactic_state": "M : Type u_8\ninst\u271d\u00b9 : MulOneClass M\nS : Submonoid M\ninst\u271d : Subsingleton \u21a5S\n\u22a2 \u2200 x \u2208 S, x = 1"}, {"line": "intro y hy", "tactic_state": "M : Type u_8\ninst\u271d\u00b9 : MulOneClass M\nS : Submonoid M\ninst\u271d : Subsingleton \u21a5S\ny : M\nhy : y \u2208 S\n\u22a2 y = 1"}, {"line": "simpa using congr_arg ((\u2191) : S \u2192 M) <| Subsingleton.elim (\u27e8y, hy\u27e9 : S) 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nontrivial_iff_exists_ne_one (S : Submonoid M) : Nontrivial S \u2194 \u2203 x \u2208 S, x \u2260 (1 : M) :=\n  calc\n    Nontrivial S \u2194 \u2203 x : S, x \u2260 1 := nontrivial_iff_exists_ne 1\n    _ \u2194 \u2203 (x : _) (hx : x \u2208 S), (\u27e8x, hx\u27e9 : S) \u2260 \u27e81, S.one_mem\u27e9 := Subtype.exists\n    _ \u2194 \u2203 x \u2208 S, x \u2260 (1 : M) := by simp [Ne]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Operations.lean", "context": {"open": ["Function", "Set", "MonoidHom", "Submonoid", "MonoidHom"], "variables": ["{M N P : Type*} [MulOneClass M] [MulOneClass N] [MulOneClass P] (S : Submonoid M)", "{A : Type*} [AddZeroClass A]", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]", "{\u03b9 : Type*} {f : F}", "(hf : Function.Injective f)", "{\u03b9 : Type*} {f : F}", "(hf : Function.Surjective f)", "{M : Type*} [MulOneClass M] (S : Submonoid M)", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_8\ninst\u271d : MulOneClass M\nS : Submonoid M\n\u22a2 (\u2203 x, \u2203 (hx : x \u2208 S), \u27e8x, hx\u27e9 \u2260 \u27e81, \u22ef\u27e9) \u2194 \u2203 x \u2208 S, x \u2260 1"}, {"line": "simp [Ne]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_comap_eq_self {f : F} {S : Submonoid N} (h : S \u2264 MonoidHom.mrange f) :\n    (S.comap f).map f = S := by\n  simpa only [inf_of_le_left h] using map_comap_eq f S\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Operations.lean", "context": {"open": ["Function", "Set", "MonoidHom", "Submonoid", "MonoidHom", "AddSubmonoid Set"], "variables": ["{M N P : Type*} [MulOneClass M] [MulOneClass N] [MulOneClass P] (S : Submonoid M)", "{A : Type*} [AddZeroClass A]", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]", "{\u03b9 : Type*} {f : F}", "(hf : Function.Injective f)", "{\u03b9 : Type*} {f : F}", "(hf : Function.Surjective f)", "{M : Type*} [MulOneClass M] (S : Submonoid M)", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]", "{S} {T : Submonoid M}", "{F : Type*} [FunLike F M N] [mc : MonoidHomClass F M N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : Type u_2\ninst\u271d\u00b2 : MulOneClass N\nM : Type u_8\ninst\u271d\u00b9 : MulOneClass M\nF : Type u_10\ninst\u271d : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nS : Submonoid N\nh : S \u2264 mrange f\n\u22a2 Submonoid.map f (Submonoid.comap f S) = S"}, {"line": "simpa only [inf_of_le_left h] using map_comap_eq f S", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_mul_coe [SetLike S M] [SubmonoidClass S M] (H : S) : H * H = (H : Set M) := by\n  aesop (add simp mem_mul)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Pointwise.lean", "context": {"open": ["Set Pointwise"], "variables": ["{\u03b1 G M R A S : Type*}", "[Monoid M] [AddMonoid A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\nS : Type u_6\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : SetLike S M\ninst\u271d : SubmonoidClass S M\nH : S\n\u22a2 \u2191H * \u2191H = \u2191H"}, {"line": "aesop (add simp mem_mul)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_mul_self_eq (s : Submonoid M) : (s : Set M) * s = s := by\n  ext x\n  refine \u27e8?_, fun h => \u27e8x, h, 1, s.one_mem, mul_one x\u27e9\u27e9\n  rintro \u27e8a, ha, b, hb, rfl\u27e9\n  exact s.mul_mem ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Pointwise.lean", "context": {"open": ["Set Pointwise"], "variables": ["{\u03b1 G M R A S : Type*}", "[Monoid M] [AddMonoid A]", "{s t u : Set M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\ninst\u271d : Monoid M\ns : Submonoid M\n\u22a2 \u2191s * \u2191s = \u2191s"}, {"line": "ext x", "tactic_state": "case h\nM : Type u_3\ninst\u271d : Monoid M\ns : Submonoid M\nx : M\n\u22a2 x \u2208 \u2191s * \u2191s \u2194 x \u2208 \u2191s"}, {"line": "refine \u27e8?_, fun h => \u27e8x, h, 1, s.one_mem, mul_one x\u27e9\u27e9", "tactic_state": "case h\nM : Type u_3\ninst\u271d : Monoid M\ns : Submonoid M\nx : M\n\u22a2 x \u2208 \u2191s * \u2191s \u2192 x \u2208 \u2191s"}, {"line": "rintro \u27e8a, ha, b, hb, rfl\u27e9", "tactic_state": "case h.intro.intro.intro.intro\nM : Type u_3\ninst\u271d : Monoid M\ns : Submonoid M\na : M\nha : a \u2208 \u2191s\nb : M\nhb : b \u2208 \u2191s\n\u22a2 (fun x1 x2 => x1 * x2) a b \u2208 \u2191s"}, {"line": "exact s.mul_mem ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem submonoid_closure (hpos : \u2200 x : \u03b1, x \u2208 s \u2192 1 \u2264 x) (h : s.IsPWO) :\n    IsPWO (Submonoid.closure s : Set \u03b1) := by\n  rw [Submonoid.closure_eq_image_prod]\n  refine (h.partiallyWellOrderedOn_sublistForall\u2082 (\u00b7 \u2264 \u00b7)).image_of_monotone_on ?_\n  exact fun l1 _ l2 hl2 h12 => h12.prod_le_prod' fun x hx => hpos x <| hl2 x hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Submonoid/Pointwise.lean", "context": {"open": ["Set Pointwise"], "variables": ["{\u03b1 G M R A S : Type*}", "[Monoid M] [AddMonoid A]", "{s t u : Set M}", "[Group G]", "[Monoid \u03b1] [MulDistribMulAction \u03b1 M]", "[Group \u03b1] [MulDistribMulAction \u03b1 M]", "[CommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedCancelMonoid \u03b1] {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : Monoid \u03b1\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedCancelMonoid \u03b1\ns : Set \u03b1\nhpos : \u2200 x \u2208 s, 1 \u2264 x\nh : s.IsPWO\n\u22a2 (\u2191(Submonoid.closure s)).IsPWO"}, {"line": "rw [Submonoid.closure_eq_image_prod]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : Monoid \u03b1\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedCancelMonoid \u03b1\ns : Set \u03b1\nhpos : \u2200 x \u2208 s, 1 \u2264 x\nh : s.IsPWO\n\u22a2 (List.prod '' {l | \u2200 x \u2208 l, x \u2208 s}).IsPWO"}, {"line": "refine (h.partiallyWellOrderedOn_sublistForall\u2082 (\u00b7 \u2264 \u00b7)).image_of_monotone_on ?_", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : Monoid \u03b1\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedCancelMonoid \u03b1\ns : Set \u03b1\nhpos : \u2200 x \u2208 s, 1 \u2264 x\nh : s.IsPWO\n\u22a2 \u2200 a\u2081 \u2208 {l | \u2200 x \u2208 l, x \u2208 s},\n    \u2200 a\u2082 \u2208 {l | \u2200 x \u2208 l, x \u2208 s}, List.SublistForall\u2082 (fun x1 x2 => x1 \u2264 x2) a\u2081 a\u2082 \u2192 a\u2081.prod \u2264 a\u2082.prod"}, {"line": "exact fun l1 _ l2 hl2 h12 => h12.prod_le_prod' fun x hx => hpos x <| hl2 x hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_sup_left {S T : Subsemigroup M} : \u2200 {x : M}, x \u2208 S \u2192 x \u2208 S \u2294 T := by\n  have : S \u2264 S \u2294 T := le_sup_left\n  tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subsemigroup/Membership.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {M : Type*}", "[Mul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : Mul M\nS T : Subsemigroup M\nx\u271d : M\n\u22a2 x\u271d \u2208 S \u2192 x\u271d \u2208 S \u2294 T"}, {"line": "have : S \u2264 S \u2294 T := le_sup_left", "tactic_state": "M : Type u_2\ninst\u271d : Mul M\nS T : Subsemigroup M\nx\u271d : M\nthis : S \u2264 S \u2294 T\n\u22a2 x\u271d \u2208 S \u2192 x\u271d \u2208 S \u2294 T"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_sup_right {S T : Subsemigroup M} : \u2200 {x : M}, x \u2208 T \u2192 x \u2208 S \u2294 T := by\n  have : T \u2264 S \u2294 T := le_sup_right\n  tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subsemigroup/Membership.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {M : Type*}", "[Mul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : Mul M\nS T : Subsemigroup M\nx\u271d : M\n\u22a2 x\u271d \u2208 T \u2192 x\u271d \u2208 S \u2294 T"}, {"line": "have : T \u2264 S \u2294 T := le_sup_right", "tactic_state": "M : Type u_2\ninst\u271d : Mul M\nS T : Subsemigroup M\nx\u271d : M\nthis : T \u2264 S \u2294 T\n\u22a2 x\u271d \u2208 T \u2192 x\u271d \u2208 S \u2294 T"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_sSup_of_mem {S : Set (Subsemigroup M)} {s : Subsemigroup M} (hs : s \u2208 S) :\n    \u2200 {x : M}, x \u2208 s \u2192 x \u2208 sSup S := by\n  have : s \u2264 sSup S := le_sSup hs\n  tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subsemigroup/Membership.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {M : Type*}", "[Mul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : Mul M\nS : Set (Subsemigroup M)\ns : Subsemigroup M\nhs : s \u2208 S\nx\u271d : M\n\u22a2 x\u271d \u2208 s \u2192 x\u271d \u2208 sSup S"}, {"line": "have : s \u2264 sSup S := le_sSup hs", "tactic_state": "M : Type u_2\ninst\u271d : Mul M\nS : Set (Subsemigroup M)\ns : Subsemigroup M\nhs : s \u2208 S\nx\u271d : M\nthis : s \u2264 sSup S\n\u22a2 x\u271d \u2208 s \u2192 x\u271d \u2208 sSup S"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_eq_closure {\u03b9 : Sort*} (p : \u03b9 \u2192 Subsemigroup M) :\n    \u2a06 i, p i = Subsemigroup.closure (\u22c3 i, (p i : Set M)) := by\n  simp_rw [Subsemigroup.closure_iUnion, Subsemigroup.closure_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subsemigroup/Basic.lean", "context": {"open": ["Set"], "variables": ["{M : Type*} {N : Type*}", "[Mul M] {s : Set M}", "(S : Subsemigroup M)", "{S}", "(S)", "(M)", "{M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d : Mul M\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Subsemigroup M\n\u22a2 \u2a06 i, p i = Subsemigroup.closure (\u22c3 i, \u2191(p i))"}, {"line": "simp_rw [Subsemigroup.closure_iUnion, Subsemigroup.closure_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_iInf {\u03b9 : Sort*} [Nonempty \u03b9] (f : M \u2192\u2099* N) (hf : Function.Injective f)\n    (s : \u03b9 \u2192 Subsemigroup M) : (iInf s).map f = \u2a05 i, (s i).map f := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe \u2218 s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subsemigroup/Operations.lean", "context": {"open": ["Set"], "variables": ["{M N P \u03c3 : Type*}", "[Mul M]", "{A : Type*} [Add A]", "[Mul M] [Mul N] [Mul P] (S : Subsemigroup M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nN : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 : Mul M\ninst\u271d\u00b9 : Mul N\n\u03b9 : Sort u_6\ninst\u271d : Nonempty \u03b9\nf : M \u2192\u2099* N\nhf : Function.Injective \u21d1f\ns : \u03b9 \u2192 Subsemigroup M\n\u22a2 Subsemigroup.map f (iInf s) = \u2a05 i, Subsemigroup.map f (s i)"}, {"line": "apply SetLike.coe_injective", "tactic_state": "case a\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 : Mul M\ninst\u271d\u00b9 : Mul N\n\u03b9 : Sort u_6\ninst\u271d : Nonempty \u03b9\nf : M \u2192\u2099* N\nhf : Function.Injective \u21d1f\ns : \u03b9 \u2192 Subsemigroup M\n\u22a2 \u2191(Subsemigroup.map f (iInf s)) = \u2191(\u2a05 i, Subsemigroup.map f (s i))"}, {"line": "simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe \u2218 s)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_srange (g : N \u2192\u2099* P) (f : M \u2192\u2099* N) : f.srange.map g = (g.comp f).srange := by\n  simpa only [srange_eq_map] using (\u22a4 : Subsemigroup M).map_map g f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subsemigroup/Operations.lean", "context": {"open": ["Set", "MulHom", "Subsemigroup"], "variables": ["{M N P \u03c3 : Type*}", "[Mul M]", "{A : Type*} [Add A]", "[Mul M] [Mul N] [Mul P] (S : Subsemigroup M)", "{\u03b9 : Type*} {f : M \u2192\u2099* N}", "(hf : Function.Injective f)", "{\u03b9 : Type*} {f : M \u2192\u2099* N} (hf : Function.Surjective f)", "[Mul M] [Mul N] [Mul P] (S : Subsemigroup M)", "[Mul M] [Mul N] [Mul P] (S : Subsemigroup M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nN : Type u_2\nP : Type u_3\ninst\u271d\u2079 inst\u271d\u2078 : Mul M\ninst\u271d\u2077 : Mul N\ninst\u271d\u2076 : Mul P\ninst\u271d\u2075 : Mul M\ninst\u271d\u2074 : Mul N\ninst\u271d\u00b3 : Mul P\ninst\u271d\u00b2 : Mul M\ninst\u271d\u00b9 : Mul N\ninst\u271d : Mul P\ng : N \u2192\u2099* P\nf : M \u2192\u2099* N\n\u22a2 map g f.srange = (g.comp f).srange"}, {"line": "simpa only [srange_eq_map] using (\u22a4 : Subsemigroup M).map_map g f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subsemigroupMap_surjective (f : M \u2192\u2099* N) (M' : Subsemigroup M) :\n    Function.Surjective (f.subsemigroupMap M') := by\n  rintro \u27e8_, x, hx, rfl\u27e9\n  exact \u27e8\u27e8x, hx\u27e9, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subsemigroup/Operations.lean", "context": {"open": ["Set", "MulHom", "Subsemigroup"], "variables": ["{M N P \u03c3 : Type*}", "[Mul M]", "{A : Type*} [Add A]", "[Mul M] [Mul N] [Mul P] (S : Subsemigroup M)", "{\u03b9 : Type*} {f : M \u2192\u2099* N}", "(hf : Function.Injective f)", "{\u03b9 : Type*} {f : M \u2192\u2099* N} (hf : Function.Surjective f)", "[Mul M] [Mul N] [Mul P] (S : Subsemigroup M)", "[Mul M] [Mul N] [Mul P] (S : Subsemigroup M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nN : Type u_2\ninst\u271d\u2076 inst\u271d\u2075 : Mul M\ninst\u271d\u2074 : Mul N\ninst\u271d\u00b3 : Mul M\ninst\u271d\u00b2 : Mul N\ninst\u271d\u00b9 : Mul M\ninst\u271d : Mul N\nf : M \u2192\u2099* N\nM' : Subsemigroup M\n\u22a2 Function.Surjective \u21d1(f.subsemigroupMap M')"}, {"line": "rintro \u27e8_, x, hx, rfl\u27e9", "tactic_state": "case mk.intro.intro\nM : Type u_1\nN : Type u_2\ninst\u271d\u2076 inst\u271d\u2075 : Mul M\ninst\u271d\u2074 : Mul N\ninst\u271d\u00b3 : Mul M\ninst\u271d\u00b2 : Mul N\ninst\u271d\u00b9 : Mul M\ninst\u271d : Mul N\nf : M \u2192\u2099* N\nM' : Subsemigroup M\nx : M\nhx : x \u2208 \u2191M'\n\u22a2 \u2203 a, (f.subsemigroupMap M') a = \u27e8f x, \u22ef\u27e9"}, {"line": "exact \u27e8\u27e8x, hx\u27e9, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_comap_eq_self {f : M \u2192\u2099* N} {S : Subsemigroup N} (h : S \u2264 f.srange) :\n    (S.comap f).map f = S := by\n  simpa only [inf_of_le_left h] using map_comap_eq f S\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Subsemigroup/Operations.lean", "context": {"open": ["Set", "MulHom", "Subsemigroup", "MulHom"], "variables": ["{M N P \u03c3 : Type*}", "[Mul M]", "{A : Type*} [Add A]", "[Mul M] [Mul N] [Mul P] (S : Subsemigroup M)", "{\u03b9 : Type*} {f : M \u2192\u2099* N}", "(hf : Function.Injective f)", "{\u03b9 : Type*} {f : M \u2192\u2099* N} (hf : Function.Surjective f)", "[Mul M] [Mul N] [Mul P] (S : Subsemigroup M)", "[Mul M] [Mul N] [Mul P] (S : Subsemigroup M)", "[Mul M] [Mul N] [Mul P] (S : Subsemigroup M)", "[Mul M] [Mul N] {S T : Subsemigroup M}", "[Mul M] [Mul N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nN : Type u_2\ninst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : Mul M\ninst\u271d\u00b9\u2070 : Mul N\ninst\u271d\u2079 : Mul M\ninst\u271d\u2078 : Mul N\ninst\u271d\u2077 : Mul M\ninst\u271d\u2076 : Mul N\ninst\u271d\u2075 : Mul M\ninst\u271d\u2074 : Mul N\ninst\u271d\u00b3 : Mul M\ninst\u271d\u00b2 : Mul N\ninst\u271d\u00b9 : Mul M\ninst\u271d : Mul N\nf : M \u2192\u2099* N\nS : Subsemigroup N\nh : S \u2264 f.srange\n\u22a2 map f (comap f S) = S"}, {"line": "simpa only [inf_of_le_left h] using map_comap_eq f S", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Pi.mulSingle_multiplicativeOfAdd_eq {\u03b9 : Type*} [DecidableEq \u03b9] {M : \u03b9 \u2192 Type*}\n    [(i : \u03b9) \u2192 AddMonoid (M i)] (i : \u03b9) (a : M i) (j : \u03b9) :\n    Pi.mulSingle (f := fun i \u21a6 Multiplicative (M i)) i (Multiplicative.ofAdd a) j =\n      Multiplicative.ofAdd ((Pi.single i a) j) := by\n  rcases eq_or_ne j i with rfl | h\n  \u00b7 simp only [mulSingle_eq_same, single_eq_same]\n  \u00b7 simp only [mulSingle, ne_eq, h, not_false_eq_true, Function.update_of_ne, one_apply, single,\n      zero_apply, ofAdd_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/TypeTags/Basic.lean", "context": {"open": ["Additive (ofMul toMul)", "Multiplicative (ofAdd toAdd)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b9\nM : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 AddMonoid (M i)\ni : \u03b9\na : M i\nj : \u03b9\n\u22a2 mulSingle i (ofAdd a) j = ofAdd (single i a j)"}, {"line": "rcases eq_or_ne j i with rfl | h", "tactic_state": "case inl\n\u03b9 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b9\nM : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 AddMonoid (M i)\nj : \u03b9\na : M j\n\u22a2 mulSingle j (ofAdd a) j = ofAdd (single j a j)\n---\ncase inr\n\u03b9 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b9\nM : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 AddMonoid (M i)\ni : \u03b9\na : M i\nj : \u03b9\nh : j \u2260 i\n\u22a2 mulSingle i (ofAdd a) j = ofAdd (single i a j)"}, {"line": "\u00b7 simp only [mulSingle_eq_same, single_eq_same]", "tactic_state": "case inr\n\u03b9 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b9\nM : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 AddMonoid (M i)\ni : \u03b9\na : M i\nj : \u03b9\nh : j \u2260 i\n\u22a2 mulSingle i (ofAdd a) j = ofAdd (single i a j)"}, {"line": "\u00b7 simp only [mulSingle, ne_eq, h, not_false_eq_true, Function.update_of_ne, one_apply, single,\n      zero_apply, ofAdd_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Pi.single_additiveOfMul_eq {\u03b9 : Type*} [DecidableEq \u03b9] {M : \u03b9 \u2192 Type*}\n    [(i : \u03b9) \u2192 Monoid (M i)] (i : \u03b9) (a : M i) (j : \u03b9) :\n    Pi.single (f := fun i \u21a6 Additive (M i)) i (Additive.ofMul a) j =\n      Additive.ofMul ((Pi.mulSingle i a) j) := by\n  rcases eq_or_ne j i with rfl | h\n  \u00b7 simp only [mulSingle_eq_same, single_eq_same]\n  \u00b7 simp only [single, ne_eq, h, not_false_eq_true, Function.update_of_ne, zero_apply, mulSingle,\n      one_apply, ofMul_one]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/TypeTags/Basic.lean", "context": {"open": ["Additive (ofMul toMul)", "Multiplicative (ofAdd toAdd)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b9\nM : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 Monoid (M i)\ni : \u03b9\na : M i\nj : \u03b9\n\u22a2 single i (ofMul a) j = ofMul (mulSingle i a j)"}, {"line": "rcases eq_or_ne j i with rfl | h", "tactic_state": "case inl\n\u03b9 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b9\nM : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 Monoid (M i)\nj : \u03b9\na : M j\n\u22a2 single j (ofMul a) j = ofMul (mulSingle j a j)\n---\ncase inr\n\u03b9 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b9\nM : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 Monoid (M i)\ni : \u03b9\na : M i\nj : \u03b9\nh : j \u2260 i\n\u22a2 single i (ofMul a) j = ofMul (mulSingle i a j)"}, {"line": "\u00b7 simp only [mulSingle_eq_same, single_eq_same]", "tactic_state": "case inr\n\u03b9 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b9\nM : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 Monoid (M i)\ni : \u03b9\na : M i\nj : \u03b9\nh : j \u2260 i\n\u22a2 single i (ofMul a) j = ofMul (mulSingle i a j)"}, {"line": "\u00b7 simp only [single, ne_eq, h, not_false_eq_true, Function.update_of_ne, zero_apply, mulSingle,\n      one_apply, ofMul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_subsingleton [Subsingleton G] : UniqueMul A B a0 b0 := by\n  simp [UniqueMul, eq_iff_true_of_subsingleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/UniqueProds/Basic.lean", "context": {"open": ["Finset"], "variables": ["{G H : Type*} [Mul G] [Mul H] {A B : Finset G} {a0 b0 : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Mul G\nA B : Finset G\na0 b0 : G\ninst\u271d : Subsingleton G\n\u22a2 UniqueMul A B a0 b0"}, {"line": "simp [UniqueMul, eq_iff_true_of_subsingleton]", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Mul G\nA B : Finset G\na0 b0 : G\ninst\u271d : Subsingleton G\n\u22a2 \u2200 \u2983a b : G\u2984, a \u2208 A \u2192 b \u2208 B \u2192 a * b = a0 * b0 \u2192 a = a0 \u2227 b = b0"}]}
{"declaration": "theorem eq_divp_iff_mul_eq {x : \u03b1} {u : \u03b1\u02e3} {y : \u03b1} : x = y /\u209a u \u2194 x * u = y := by\n  rw [eq_comm]\n  rw [divp_eq_iff_mul_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Units/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u}", "[Monoid \u03b1]", "(b c : \u03b1\u02e3) {u : \u03b1\u02e3}", "[Monoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 inst\u271d : Monoid \u03b1\nx : \u03b1\nu : \u03b1\u02e3\ny : \u03b1\n\u22a2 x = y /\u209a u \u2194 x * \u2191u = y"}, {"line": "rw [eq_comm]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 inst\u271d : Monoid \u03b1\nx : \u03b1\nu : \u03b1\u02e3\ny : \u03b1\n\u22a2 y /\u209a u = x \u2194 x * \u2191u = y"}, {"line": "rw [divp_eq_iff_mul_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_eq_one_divp' (u : \u03b1\u02e3) : ((1 / u : \u03b1\u02e3) : \u03b1) = 1 /\u209a u := by\n  rw [one_div]\n  rw [one_divp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Units/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u}", "[Monoid \u03b1]", "(b c : \u03b1\u02e3) {u : \u03b1\u02e3}", "[Monoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 inst\u271d : Monoid \u03b1\nu : \u03b1\u02e3\n\u22a2 \u2191(1 / u) = 1 /\u209a u"}, {"line": "rw [one_div]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 inst\u271d : Monoid \u03b1\nu : \u03b1\u02e3\n\u22a2 \u2191u\u207b\u00b9 = 1 /\u209a u"}, {"line": "rw [one_divp]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma val_div_eq_div_val : \u2200 u\u2081 u\u2082 : \u03b1\u02e3, \u2191(u\u2081 / u\u2082) = (u\u2081 / u\u2082 : \u03b1) := by simp [div_eq_mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Units/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u}", "[Monoid \u03b1]", "(a b : \u03b1\u02e3) {u : \u03b1\u02e3}", "[DivisionMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\n\u22a2 \u2200 (u\u2081 u\u2082 : \u03b1\u02e3), \u2191(u\u2081 / u\u2082) = \u2191u\u2081 / \u2191u\u2082"}, {"line": "simp [div_eq_mul_inv]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : DivisionMonoid \u03b1\n\u22a2 \u2200 (u\u2081 u\u2082 : \u03b1\u02e3), \u2191u\u2081 * \u2191u\u2082\u207b\u00b9 = \u2191u\u2081 * (\u2191u\u2082)\u207b\u00b9"}]}
{"declaration": "theorem divp_divp_eq_divp_mul (x : \u03b1) (u\u2081 u\u2082 : \u03b1\u02e3) : x /\u209a u\u2081 /\u209a u\u2082 = x /\u209a (u\u2082 * u\u2081) := by\n  simp only [divp]\n  simp only [mul_inv_rev]\n  simp only [Units.val_mul]\n  simp only [mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Units/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u}", "[Monoid \u03b1]", "(a b : \u03b1\u02e3) {u : \u03b1\u02e3}", "[DivisionMonoid \u03b1]", "[Monoid \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : Monoid \u03b1\nx : \u03b1\nu\u2081 u\u2082 : \u03b1\u02e3\n\u22a2 x /\u209a u\u2081 /\u209a u\u2082 = x /\u209a (u\u2082 * u\u2081)"}, {"line": "simp only [divp]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : Monoid \u03b1\nx : \u03b1\nu\u2081 u\u2082 : \u03b1\u02e3\n\u22a2 x * \u2191u\u2081\u207b\u00b9 * \u2191u\u2082\u207b\u00b9 = x * \u2191(u\u2082 * u\u2081)\u207b\u00b9"}, {"line": "simp only [mul_inv_rev]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : Monoid \u03b1\nx : \u03b1\nu\u2081 u\u2082 : \u03b1\u02e3\n\u22a2 x * \u2191u\u2081\u207b\u00b9 * \u2191u\u2082\u207b\u00b9 = x * \u2191(u\u2081\u207b\u00b9 * u\u2082\u207b\u00b9)"}, {"line": "simp only [Units.val_mul]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : Monoid \u03b1\nx : \u03b1\nu\u2081 u\u2082 : \u03b1\u02e3\n\u22a2 x * \u2191u\u2081\u207b\u00b9 * \u2191u\u2082\u207b\u00b9 = x * (\u2191u\u2081\u207b\u00b9 * \u2191u\u2082\u207b\u00b9)"}, {"line": "simp only [mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_div_eq_divp (u\u2081 u\u2082 : \u03b1\u02e3) : \u2191(u\u2081 / u\u2082) = \u2191u\u2081 /\u209a u\u2082 := by\n  rw [divp]\n  rw [division_def]\n  rw [Units.val_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Units/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u}", "[Monoid \u03b1]", "(a b : \u03b1\u02e3) {u : \u03b1\u02e3}", "[DivisionMonoid \u03b1]", "[Monoid \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : Monoid \u03b1\nu\u2081 u\u2082 : \u03b1\u02e3\n\u22a2 \u2191(u\u2081 / u\u2082) = \u2191u\u2081 /\u209a u\u2082"}, {"line": "rw [divp]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : Monoid \u03b1\nu\u2081 u\u2082 : \u03b1\u02e3\n\u22a2 \u2191(u\u2081 / u\u2082) = \u2191u\u2081 * \u2191u\u2082\u207b\u00b9"}, {"line": "rw [division_def]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b1\ninst\u271d : Monoid \u03b1\nu\u2081 u\u2082 : \u03b1\u02e3\n\u22a2 \u2191(u\u2081 * u\u2082\u207b\u00b9) = \u2191u\u2081 * \u2191u\u2082\u207b\u00b9"}, {"line": "rw [Units.val_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsUnit.exists_right_inv (h : IsUnit a) : \u2203 b, a * b = 1 := by\n  rcases h with \u27e8\u27e8a, b, hab, _\u27e9, rfl\u27e9\n  exact \u27e8b, hab\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Units/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u}", "[Monoid \u03b1]", "(a b : \u03b1\u02e3) {u : \u03b1\u02e3}", "[DivisionMonoid \u03b1]", "[Monoid \u03b1] {a : \u03b1}", "{M : Type*} {N : Type*}", "[Monoid M] {a b : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d : Monoid M\na : M\nh : IsUnit a\n\u22a2 \u2203 b, a * b = 1"}, {"line": "rcases h with \u27e8\u27e8a, b, hab, _\u27e9, rfl\u27e9", "tactic_state": "case intro.mk\nM : Type u_1\ninst\u271d : Monoid M\na b : M\nhab : a * b = 1\ninv_val\u271d : b * a = 1\n\u22a2 \u2203 b_1, \u2191{ val := a, inv := b, val_inv := hab, inv_val := inv_val\u271d } * b_1 = 1"}, {"line": "exact \u27e8b, hab\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsUnit.exists_left_inv {a : M} (h : IsUnit a) : \u2203 b, b * a = 1 := by\n  rcases h with \u27e8\u27e8a, b, _, hba\u27e9, rfl\u27e9\n  exact \u27e8b, hba\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Units/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u}", "[Monoid \u03b1]", "(a b : \u03b1\u02e3) {u : \u03b1\u02e3}", "[DivisionMonoid \u03b1]", "[Monoid \u03b1] {a : \u03b1}", "{M : Type*} {N : Type*}", "[Monoid M] {a b : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d : Monoid M\na : M\nh : IsUnit a\n\u22a2 \u2203 b, b * a = 1"}, {"line": "rcases h with \u27e8\u27e8a, b, _, hba\u27e9, rfl\u27e9", "tactic_state": "case intro.mk\nM : Type u_1\ninst\u271d : Monoid M\na b : M\nval_inv\u271d : a * b = 1\nhba : b * a = 1\n\u22a2 \u2203 b_1, b_1 * \u2191{ val := a, inv := b, val_inv := val_inv\u271d, inv_val := hba } = 1"}, {"line": "exact \u27e8b, hba\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toUnits_val_apply {G : Type*} [Group G] (x : G\u02e3) : toUnits (x : G) = x := by\n  simp_rw [MulEquiv.apply_eq_iff_symm_apply, toUnits_symm_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Units/Equiv.lean", "context": {"open": [], "variables": ["{F \u03b1 M N G : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_6\ninst\u271d : Group G\nx : G\u02e3\n\u22a2 toUnits \u2191x = x"}, {"line": "simp_rw [MulEquiv.apply_eq_iff_symm_apply, toUnits_symm_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_leftInverse [MonoidHomClass G N M] {f : F} {x : M} (g : G)\n    (hfg : Function.LeftInverse g f) (h : IsUnit (f x)) : IsUnit x := by\n  simpa only [hfg x] using h.map g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Group/Units/Hom.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {M : Type u} {N : Type v} {P : Type w} [Monoid M] [Monoid N] [Monoid P]", "(M)", "{M}", "[DivisionMonoid \u03b1]", "{F G M N : Type*} [FunLike F M N] [FunLike G N M]", "[Monoid M] [Monoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_2\nG : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u2074 : FunLike F M N\ninst\u271d\u00b3 : FunLike G N M\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : Monoid N\ninst\u271d : MonoidHomClass G N M\nf : F\nx : M\ng : G\nhfg : LeftInverse \u21d1g \u21d1f\nh : IsUnit (f x)\n\u22a2 IsUnit x"}, {"line": "simpa only [hfg x] using h.map g", "tactic_state": "No Goals!"}]}
{"declaration": "theorem associated_eq_eq : (Associated : M \u2192 M \u2192 Prop) = Eq := by\n  ext\n  rw [associated_iff_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Associated.lean", "context": {"open": [], "variables": ["{M : Type*}", "[Monoid M] [Subsingleton M\u02e3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 : Monoid M\ninst\u271d : Subsingleton M\u02e3\n\u22a2 Associated = Eq"}, {"line": "ext", "tactic_state": "case h.h.a\nM : Type u_1\ninst\u271d\u00b9 : Monoid M\ninst\u271d : Subsingleton M\u02e3\nx\u271d\u00b9 x\u271d : M\n\u22a2 Associated x\u271d\u00b9 x\u271d \u2194 x\u271d\u00b9 = x\u271d"}, {"line": "rw [associated_iff_eq]", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 : Monoid M\ninst\u271d : Subsingleton M\u02e3\nx\u271d\u00b9 x\u271d : M\n\u22a2 Subsingleton M\u02e3"}]}
{"declaration": "theorem eq_of_prime_pow_eq (hp\u2081 : Prime p\u2081) (hp\u2082 : Prime p\u2082) (hk\u2081 : 0 < k\u2081)\n    (h : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082) : p\u2081 = p\u2082 := by\n  rw [\u2190 associated_iff_eq] at h \u22a2\n  apply h.of_pow_associated_of_prime hp\u2081 hp\u2082 hk\u2081\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Associated.lean", "context": {"open": [], "variables": ["{M : Type*}", "[Monoid M] [Subsingleton M\u02e3]", "{R : Type*} [CancelCommMonoidWithZero R] [Subsingleton R\u02e3] {p\u2081 p\u2082 : R} {k\u2081 k\u2082 : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2081\nh : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\n\u22a2 p\u2081 = p\u2082"}, {"line": "rw [\u2190 associated_iff_eq] at h \u22a2", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2081\nh\u271d : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\nh : Associated (p\u2081 ^ k\u2081) (p\u2082 ^ k\u2082)\n\u22a2 Associated p\u2081 p\u2082\n---\nR : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2081\nh\u271d : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\nh : Associated (p\u2081 ^ k\u2081) (p\u2082 ^ k\u2082)\n\u22a2 Monoid R\n---\nR : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2081\nh\u271d : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\nh : Associated (p\u2081 ^ k\u2081) (p\u2082 ^ k\u2082)\n\u22a2 Subsingleton R\u02e3\n---\nR : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2081\nh : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\n\u22a2 Monoid R\n---\nR : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2081\nh : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\n\u22a2 Subsingleton R\u02e3"}, {"line": "apply h.of_pow_associated_of_prime hp\u2081 hp\u2082 hk\u2081", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2081\nh\u271d : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\nh : Associated (p\u2081 ^ k\u2081) (p\u2082 ^ k\u2082)\n\u22a2 Monoid R\n---\nR : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2081\nh\u271d : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\nh : Associated (p\u2081 ^ k\u2081) (p\u2082 ^ k\u2082)\n\u22a2 Monoid R\n---\nR : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2081\nh\u271d : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\nh : Associated (p\u2081 ^ k\u2081) (p\u2082 ^ k\u2082)\n\u22a2 Subsingleton R\u02e3\n---\nR : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2081\nh : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\n\u22a2 Subsingleton R\u02e3"}]}
{"declaration": "theorem eq_of_prime_pow_eq' (hp\u2081 : Prime p\u2081) (hp\u2082 : Prime p\u2082) (hk\u2081 : 0 < k\u2082)\n    (h : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082) : p\u2081 = p\u2082 := by\n  rw [\u2190 associated_iff_eq] at h \u22a2\n  apply h.of_pow_associated_of_prime' hp\u2081 hp\u2082 hk\u2081\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Associated.lean", "context": {"open": [], "variables": ["{M : Type*}", "[Monoid M] [Subsingleton M\u02e3]", "{R : Type*} [CancelCommMonoidWithZero R] [Subsingleton R\u02e3] {p\u2081 p\u2082 : R} {k\u2081 k\u2082 : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2082\nh : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\n\u22a2 p\u2081 = p\u2082"}, {"line": "rw [\u2190 associated_iff_eq] at h \u22a2", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2082\nh\u271d : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\nh : Associated (p\u2081 ^ k\u2081) (p\u2082 ^ k\u2082)\n\u22a2 Associated p\u2081 p\u2082\n---\nR : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2082\nh\u271d : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\nh : Associated (p\u2081 ^ k\u2081) (p\u2082 ^ k\u2082)\n\u22a2 Monoid R\n---\nR : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2082\nh\u271d : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\nh : Associated (p\u2081 ^ k\u2081) (p\u2082 ^ k\u2082)\n\u22a2 Subsingleton R\u02e3\n---\nR : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2082\nh : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\n\u22a2 Monoid R\n---\nR : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2082\nh : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\n\u22a2 Subsingleton R\u02e3"}, {"line": "apply h.of_pow_associated_of_prime' hp\u2081 hp\u2082 hk\u2081", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2082\nh\u271d : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\nh : Associated (p\u2081 ^ k\u2081) (p\u2082 ^ k\u2082)\n\u22a2 Monoid R\n---\nR : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2082\nh\u271d : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\nh : Associated (p\u2081 ^ k\u2081) (p\u2082 ^ k\u2082)\n\u22a2 Monoid R\n---\nR : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2082\nh\u271d : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\nh : Associated (p\u2081 ^ k\u2081) (p\u2082 ^ k\u2082)\n\u22a2 Subsingleton R\u02e3\n---\nR : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Subsingleton R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2082\nh : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\n\u22a2 Subsingleton R\u02e3"}]}
{"declaration": "theorem mk_pow (a : M) (n : \u2115) : Associates.mk (a ^ n) = Associates.mk a ^ n := by\n  induction n <;> simp [*, pow_succ, Associates.mk_mul_mk.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Associated.lean", "context": {"open": ["Associated"], "variables": ["{M : Type*}", "[Monoid M] [Subsingleton M\u02e3]", "{R : Type*} [CancelCommMonoidWithZero R] [Subsingleton R\u02e3] {p\u2081 p\u2082 : R} {k\u2081 k\u2082 : \u2115}", "[CommMonoid M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : Subsingleton M\u02e3\ninst\u271d : CommMonoid M\na : M\nn : \u2115\n\u22a2 sorry"}, {"line": "induction n <;> simp [*, pow_succ, Associates.mk_mul_mk.symm]", "tactic_state": "case zero\nM : Type u_1\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : Subsingleton M\u02e3\ninst\u271d : CommMonoid M\na : M\n\u22a2 sorry ()\n---\ncase succ\nM : Type u_1\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : Subsingleton M\u02e3\ninst\u271d : CommMonoid M\na : M\nn\u271d : \u2115\na\u271d : sorry\n\u22a2 sorry ()"}]}
{"declaration": "theorem coe_unit_eq_one (u : (Associates M)\u02e3) : (u : Associates M) = 1 := by\n  simp [eq_iff_true_of_subsingleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Associated.lean", "context": {"open": ["Associated"], "variables": ["{M : Type*}", "[Monoid M] [Subsingleton M\u02e3]", "{R : Type*} [CancelCommMonoidWithZero R] [Subsingleton R\u02e3] {p\u2081 p\u2082 : R} {k\u2081 k\u2082 : \u2115}", "[CommMonoid M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "u : sorry\n\u22a2 sorry = 1"}, {"line": "simp [eq_iff_true_of_subsingleton]", "tactic_state": "u : sorry\n\u22a2 sorry () = 1"}]}
{"declaration": "lemma zero_pow_eq (n : \u2115) : (0 : M\u2080) ^ n = if n = 0 then 1 else 0 := by\n  split_ifs with h\n  \u00b7 rw [h, pow_zero]\n  \u00b7 rw [zero_pow h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Basic.lean", "context": {"open": ["Function"], "variables": ["{M\u2080 G\u2080 : Type*}", "[MulZeroClass M\u2080] {a b : M\u2080}", "[Mul M\u2080] [Zero M\u2080] [NoZeroDivisors M\u2080] {a b : M\u2080}", "[MulZeroOneClass M\u2080]", "[MulZeroOneClass M\u2080] [Nontrivial M\u2080] {a b : M\u2080}", "[MonoidWithZero M\u2080] {a : M\u2080} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M\u2080 : Type u_1\ninst\u271d\u2077 : MulZeroClass M\u2080\ninst\u271d\u2076 : Mul M\u2080\ninst\u271d\u2075 : Zero M\u2080\ninst\u271d\u2074 : NoZeroDivisors M\u2080\ninst\u271d\u00b3 inst\u271d\u00b2 : MulZeroOneClass M\u2080\ninst\u271d\u00b9 : Nontrivial M\u2080\ninst\u271d : MonoidWithZero M\u2080\nn : \u2115\n\u22a2 0 ^ n = if n = 0 then 1 else 0"}, {"line": "split_ifs with h", "tactic_state": "case pos\nM\u2080 : Type u_1\ninst\u271d\u2077 : MulZeroClass M\u2080\ninst\u271d\u2076 : Mul M\u2080\ninst\u271d\u2075 : Zero M\u2080\ninst\u271d\u2074 : NoZeroDivisors M\u2080\ninst\u271d\u00b3 inst\u271d\u00b2 : MulZeroOneClass M\u2080\ninst\u271d\u00b9 : Nontrivial M\u2080\ninst\u271d : MonoidWithZero M\u2080\nn : \u2115\nh : n = 0\n\u22a2 0 ^ n = 1\n---\ncase neg\nM\u2080 : Type u_1\ninst\u271d\u2077 : MulZeroClass M\u2080\ninst\u271d\u2076 : Mul M\u2080\ninst\u271d\u2075 : Zero M\u2080\ninst\u271d\u2074 : NoZeroDivisors M\u2080\ninst\u271d\u00b3 inst\u271d\u00b2 : MulZeroOneClass M\u2080\ninst\u271d\u00b9 : Nontrivial M\u2080\ninst\u271d : MonoidWithZero M\u2080\nn : \u2115\nh : \u00acn = 0\n\u22a2 0 ^ n = 0"}, {"line": "\u00b7 rw [h, pow_zero]", "tactic_state": "case neg\nM\u2080 : Type u_1\ninst\u271d\u2077 : MulZeroClass M\u2080\ninst\u271d\u2076 : Mul M\u2080\ninst\u271d\u2075 : Zero M\u2080\ninst\u271d\u2074 : NoZeroDivisors M\u2080\ninst\u271d\u00b3 inst\u271d\u00b2 : MulZeroOneClass M\u2080\ninst\u271d\u00b9 : Nontrivial M\u2080\ninst\u271d : MonoidWithZero M\u2080\nn : \u2115\nh : \u00acn = 0\n\u22a2 0 ^ n = 0"}, {"line": "\u00b7 rw [zero_pow h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_mul_cancel_left\u2080 (h : a \u2260 0) (b : G\u2080) : a\u207b\u00b9 * (a * b) = b :=\n  calc\n    a\u207b\u00b9 * (a * b) = a\u207b\u00b9 * a * b := (mul_assoc _ _ _).symm\n    _ = b := by simp [h]\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Basic.lean", "context": {"open": ["Function"], "variables": ["{M\u2080 G\u2080 : Type*}", "[MulZeroClass M\u2080] {a b : M\u2080}", "[Mul M\u2080] [Zero M\u2080] [NoZeroDivisors M\u2080] {a b : M\u2080}", "[MulZeroOneClass M\u2080]", "[MulZeroOneClass M\u2080] [Nontrivial M\u2080] {a b : M\u2080}", "[MonoidWithZero M\u2080] {a : M\u2080} {n : \u2115}", "[NoZeroDivisors M\u2080]", "[CancelMonoidWithZero M\u2080] {a b c : M\u2080}", "[GroupWithZero G\u2080] {a b x : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : a \u2260 0\nb : G\u2080\n\u22a2 a\u207b\u00b9 * a * b = b"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_div (a : G\u2080) : 0 / a = 0 := by rw [div_eq_mul_inv, zero_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Basic.lean", "context": {"open": ["Function"], "variables": ["{M\u2080 G\u2080 : Type*}", "[MulZeroClass M\u2080] {a b : M\u2080}", "[Mul M\u2080] [Zero M\u2080] [NoZeroDivisors M\u2080] {a b : M\u2080}", "[MulZeroOneClass M\u2080]", "[MulZeroOneClass M\u2080] [Nontrivial M\u2080] {a b : M\u2080}", "[MonoidWithZero M\u2080] {a : M\u2080} {n : \u2115}", "[NoZeroDivisors M\u2080]", "[CancelMonoidWithZero M\u2080] {a b c : M\u2080}", "[GroupWithZero G\u2080] {a b x : G\u2080}", "[GroupWithZero G\u2080] {a : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\n\u22a2 0 / a = 0"}, {"line": "rw [div_eq_mul_inv, zero_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_zero (a : G\u2080) : a / 0 = 0 := by rw [div_eq_mul_inv, inv_zero, mul_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Basic.lean", "context": {"open": ["Function"], "variables": ["{M\u2080 G\u2080 : Type*}", "[MulZeroClass M\u2080] {a b : M\u2080}", "[Mul M\u2080] [Zero M\u2080] [NoZeroDivisors M\u2080] {a b : M\u2080}", "[MulZeroOneClass M\u2080]", "[MulZeroOneClass M\u2080] [Nontrivial M\u2080] {a b : M\u2080}", "[MonoidWithZero M\u2080] {a : M\u2080} {n : \u2115}", "[NoZeroDivisors M\u2080]", "[CancelMonoidWithZero M\u2080] {a b c : M\u2080}", "[GroupWithZero G\u2080] {a b x : G\u2080}", "[GroupWithZero G\u2080] {a : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\n\u22a2 a / 0 = 0"}, {"line": "rw [div_eq_mul_inv, inv_zero, mul_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_self_mul_inv (a : G\u2080) : a * a * a\u207b\u00b9 = a := by\n  by_cases h : a = 0\n  \u00b7 rw [h, inv_zero, mul_zero]\n  \u00b7 rw [mul_assoc, mul_inv_cancel\u2080 h, mul_one]\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Basic.lean", "context": {"open": ["Function"], "variables": ["{M\u2080 G\u2080 : Type*}", "[MulZeroClass M\u2080] {a b : M\u2080}", "[Mul M\u2080] [Zero M\u2080] [NoZeroDivisors M\u2080] {a b : M\u2080}", "[MulZeroOneClass M\u2080]", "[MulZeroOneClass M\u2080] [Nontrivial M\u2080] {a b : M\u2080}", "[MonoidWithZero M\u2080] {a : M\u2080} {n : \u2115}", "[NoZeroDivisors M\u2080]", "[CancelMonoidWithZero M\u2080] {a b c : M\u2080}", "[GroupWithZero G\u2080] {a b x : G\u2080}", "[GroupWithZero G\u2080] {a : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\n\u22a2 a * a * a\u207b\u00b9 = a"}, {"line": "by_cases h : a = 0", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\n\u22a2 OfNat G\u2080 0\n---\ncase pos\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : a = 0\n\u22a2 a * a * a\u207b\u00b9 = a\n---\ncase neg\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : \u00aca = 0\n\u22a2 a * a * a\u207b\u00b9 = a"}, {"line": "\u00b7 rw [h, inv_zero, mul_zero]", "tactic_state": "case pos\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : a = 0\n\u22a2 a * a * a\u207b\u00b9 = a\n---\ncase neg\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : \u00aca = 0\n\u22a2 a * a * a\u207b\u00b9 = a"}, {"line": "\u00b7 rw [mul_assoc, mul_inv_cancel\u2080 h, mul_one]", "tactic_state": "case neg\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : \u00aca = 0\n\u22a2 a * a * a\u207b\u00b9 = a"}]}
{"declaration": "theorem mul_inv_mul_cancel (a : G\u2080) : a * a\u207b\u00b9 * a = a := by\n  by_cases h : a = 0\n  \u00b7 rw [h, inv_zero, mul_zero]\n  \u00b7 rw [mul_inv_cancel\u2080 h, one_mul]\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Basic.lean", "context": {"open": ["Function"], "variables": ["{M\u2080 G\u2080 : Type*}", "[MulZeroClass M\u2080] {a b : M\u2080}", "[Mul M\u2080] [Zero M\u2080] [NoZeroDivisors M\u2080] {a b : M\u2080}", "[MulZeroOneClass M\u2080]", "[MulZeroOneClass M\u2080] [Nontrivial M\u2080] {a b : M\u2080}", "[MonoidWithZero M\u2080] {a : M\u2080} {n : \u2115}", "[NoZeroDivisors M\u2080]", "[CancelMonoidWithZero M\u2080] {a b c : M\u2080}", "[GroupWithZero G\u2080] {a b x : G\u2080}", "[GroupWithZero G\u2080] {a : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\n\u22a2 a * a\u207b\u00b9 * a = a"}, {"line": "by_cases h : a = 0", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\n\u22a2 OfNat G\u2080 0\n---\ncase pos\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : a = 0\n\u22a2 a * a\u207b\u00b9 * a = a\n---\ncase neg\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : \u00aca = 0\n\u22a2 a * a\u207b\u00b9 * a = a"}, {"line": "\u00b7 rw [h, inv_zero, mul_zero]", "tactic_state": "case pos\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : a = 0\n\u22a2 a * a\u207b\u00b9 * a = a\n---\ncase neg\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : \u00aca = 0\n\u22a2 a * a\u207b\u00b9 * a = a"}, {"line": "\u00b7 rw [mul_inv_cancel\u2080 h, one_mul]", "tactic_state": "case neg\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : \u00aca = 0\n\u22a2 a * a\u207b\u00b9 * a = a"}]}
{"declaration": "theorem inv_mul_mul_self (a : G\u2080) : a\u207b\u00b9 * a * a = a := by\n  by_cases h : a = 0\n  \u00b7 rw [h, inv_zero, mul_zero]\n  \u00b7 rw [inv_mul_cancel\u2080 h, one_mul]\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Basic.lean", "context": {"open": ["Function"], "variables": ["{M\u2080 G\u2080 : Type*}", "[MulZeroClass M\u2080] {a b : M\u2080}", "[Mul M\u2080] [Zero M\u2080] [NoZeroDivisors M\u2080] {a b : M\u2080}", "[MulZeroOneClass M\u2080]", "[MulZeroOneClass M\u2080] [Nontrivial M\u2080] {a b : M\u2080}", "[MonoidWithZero M\u2080] {a : M\u2080} {n : \u2115}", "[NoZeroDivisors M\u2080]", "[CancelMonoidWithZero M\u2080] {a b c : M\u2080}", "[GroupWithZero G\u2080] {a b x : G\u2080}", "[GroupWithZero G\u2080] {a : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\n\u22a2 a\u207b\u00b9 * a * a = a"}, {"line": "by_cases h : a = 0", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\n\u22a2 OfNat G\u2080 0\n---\ncase pos\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : a = 0\n\u22a2 a\u207b\u00b9 * a * a = a\n---\ncase neg\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : \u00aca = 0\n\u22a2 a\u207b\u00b9 * a * a = a"}, {"line": "\u00b7 rw [h, inv_zero, mul_zero]", "tactic_state": "case pos\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : a = 0\n\u22a2 a\u207b\u00b9 * a * a = a\n---\ncase neg\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : \u00aca = 0\n\u22a2 a\u207b\u00b9 * a * a = a"}, {"line": "\u00b7 rw [inv_mul_cancel\u2080 h, one_mul]", "tactic_state": "case neg\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : \u00aca = 0\n\u22a2 a\u207b\u00b9 * a * a = a"}]}
{"declaration": "theorem one_div_ne_zero {a : G\u2080} (h : a \u2260 0) : 1 / a \u2260 0 := by\n  simpa only [one_div] using inv_ne_zero h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Basic.lean", "context": {"open": ["Function"], "variables": ["{M\u2080 G\u2080 : Type*}", "[MulZeroClass M\u2080] {a b : M\u2080}", "[Mul M\u2080] [Zero M\u2080] [NoZeroDivisors M\u2080] {a b : M\u2080}", "[MulZeroOneClass M\u2080]", "[MulZeroOneClass M\u2080] [Nontrivial M\u2080] {a b : M\u2080}", "[MonoidWithZero M\u2080] {a : M\u2080} {n : \u2115}", "[NoZeroDivisors M\u2080]", "[CancelMonoidWithZero M\u2080] {a b c : M\u2080}", "[GroupWithZero G\u2080] {a b x : G\u2080}", "[GroupWithZero G\u2080] {a : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : a \u2260 0\n\u22a2 1 / a \u2260 0"}, {"line": "simpa only [one_div] using inv_ne_zero h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zero_zpow_eq (n : \u2124) : (0 : G\u2080) ^ n = if n = 0 then 1 else 0 := by\n  split_ifs with h\n  \u00b7 rw [h, zpow_zero]\n  \u00b7 rw [zero_zpow _ h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Basic.lean", "context": {"open": ["Function"], "variables": ["{M\u2080 G\u2080 : Type*}", "[MulZeroClass M\u2080] {a b : M\u2080}", "[Mul M\u2080] [Zero M\u2080] [NoZeroDivisors M\u2080] {a b : M\u2080}", "[MulZeroOneClass M\u2080]", "[MulZeroOneClass M\u2080] [Nontrivial M\u2080] {a b : M\u2080}", "[MonoidWithZero M\u2080] {a : M\u2080} {n : \u2115}", "[NoZeroDivisors M\u2080]", "[CancelMonoidWithZero M\u2080] {a b c : M\u2080}", "[GroupWithZero G\u2080] {a b x : G\u2080}", "[GroupWithZero G\u2080] {a : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\nn : \u2124\n\u22a2 0 ^ n = if n = 0 then 1 else 0"}, {"line": "split_ifs with h", "tactic_state": "case pos\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\nn : \u2124\nh : n = 0\n\u22a2 0 ^ n = 1\n---\ncase neg\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\nn : \u2124\nh : \u00acn = 0\n\u22a2 0 ^ n = 0"}, {"line": "\u00b7 rw [h, zpow_zero]", "tactic_state": "case neg\nG\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\nn : \u2124\nh : \u00acn = 0\n\u22a2 0 ^ n = 0"}, {"line": "\u00b7 rw [zero_zpow _ h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zero_zpow_eq_one\u2080 {n : \u2124} : (0 : G\u2080) ^ n = 1 \u2194 n = 0 := by\n  rw [zero_zpow_eq]\n  rw [one_ne_zero.ite_eq_left_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Basic.lean", "context": {"open": ["Function"], "variables": ["{M\u2080 G\u2080 : Type*}", "[MulZeroClass M\u2080] {a b : M\u2080}", "[Mul M\u2080] [Zero M\u2080] [NoZeroDivisors M\u2080] {a b : M\u2080}", "[MulZeroOneClass M\u2080]", "[MulZeroOneClass M\u2080] [Nontrivial M\u2080] {a b : M\u2080}", "[MonoidWithZero M\u2080] {a : M\u2080} {n : \u2115}", "[NoZeroDivisors M\u2080]", "[CancelMonoidWithZero M\u2080] {a b c : M\u2080}", "[GroupWithZero G\u2080] {a b x : G\u2080}", "[GroupWithZero G\u2080] {a : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\nn : \u2124\n\u22a2 0 ^ n = 1 \u2194 n = 0"}, {"line": "rw [zero_zpow_eq]", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\nn : \u2124\n\u22a2 (if n = 0 then 1 else 0) = 1 \u2194 n = 0"}, {"line": "rw [one_ne_zero.ite_eq_left_iff]", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\nn : \u2124\n\u22a2 NeZero 1"}]}
{"declaration": "theorem div_left (hac : Commute a c) (hbc : Commute b c) : Commute (a / b) c := by\n  rw [div_eq_mul_inv]\n  exact hac.mul_left hbc.inv_left\u2080\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Commute.lean", "context": {"open": [], "variables": ["{M\u2080 G\u2080 : Type*}", "[MonoidWithZero M\u2080]", "[GroupWithZero G\u2080] {a b c : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d : GroupWithZero G\u2080\na b c : G\u2080\nhac : Commute a c\nhbc : Commute b c\n\u22a2 Commute (a / b) c"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "G\u2080 : Type u_2\ninst\u271d : GroupWithZero G\u2080\na b c : G\u2080\nhac : Commute a c\nhbc : Commute b c\n\u22a2 Commute (a * b\u207b\u00b9) c"}, {"line": "exact hac.mul_left hbc.inv_left\u2080", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_inv_cancel_right\u2080 (h : b \u2260 0) (a : G\u2080) : a * b * b\u207b\u00b9 = a :=\n  calc\n    a * b * b\u207b\u00b9 = a * (b * b\u207b\u00b9) := mul_assoc _ _ _\n    _ = a := by simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Defs.lean", "context": {"open": [], "variables": ["{G\u2080 : Type u} {M\u2080 : Type*}", "[Mul M\u2080] [Zero M\u2080] [IsLeftCancelMulZero M\u2080] {a b c : M\u2080}", "[Mul M\u2080] [Zero M\u2080] [IsRightCancelMulZero M\u2080] {a b c : M\u2080}", "[MonoidWithZero M\u2080]", "[CancelMonoidWithZero M\u2080] {a b c : M\u2080}", "[CommSemigroup M\u2080] [Zero M\u2080]", "[MonoidWithZero M\u2080] [Div M\u2080] [MulDivCancelClass M\u2080]", "[CommMonoidWithZero M\u2080] [Div M\u2080] [MulDivCancelClass M\u2080]", "[GroupWithZero G\u2080] {a : G\u2080}", "[CancelMonoidWithZero M\u2080] {x : M\u2080}", "[GroupWithZero G\u2080] {a b : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\nb : G\u2080\nh : b \u2260 0\na : G\u2080\n\u22a2 a * (b * b\u207b\u00b9) = a"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_inv_cancel_left\u2080 (h : a \u2260 0) (b : G\u2080) : a * (a\u207b\u00b9 * b) = b :=\n  calc\n    a * (a\u207b\u00b9 * b) = a * a\u207b\u00b9 * b := (mul_assoc _ _ _).symm\n    _ = b := by simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Defs.lean", "context": {"open": [], "variables": ["{G\u2080 : Type u} {M\u2080 : Type*}", "[Mul M\u2080] [Zero M\u2080] [IsLeftCancelMulZero M\u2080] {a b c : M\u2080}", "[Mul M\u2080] [Zero M\u2080] [IsRightCancelMulZero M\u2080] {a b c : M\u2080}", "[MonoidWithZero M\u2080]", "[CancelMonoidWithZero M\u2080] {a b c : M\u2080}", "[CommSemigroup M\u2080] [Zero M\u2080]", "[MonoidWithZero M\u2080] [Div M\u2080] [MulDivCancelClass M\u2080]", "[CommMonoidWithZero M\u2080] [Div M\u2080] [MulDivCancelClass M\u2080]", "[GroupWithZero G\u2080] {a : G\u2080}", "[CancelMonoidWithZero M\u2080] {x : M\u2080}", "[GroupWithZero G\u2080] {a b : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : a \u2260 0\nb : G\u2080\n\u22a2 a * a\u207b\u00b9 * b = b"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_ne_zero_iff_left (ha : a \u2260 0) : a * b \u2260 0 \u2194 b \u2260 0 := by simp [ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Defs.lean", "context": {"open": [], "variables": ["{G\u2080 : Type u} {M\u2080 : Type*}", "[Mul M\u2080] [Zero M\u2080] [IsLeftCancelMulZero M\u2080] {a b c : M\u2080}", "[Mul M\u2080] [Zero M\u2080] [IsRightCancelMulZero M\u2080] {a b c : M\u2080}", "[MonoidWithZero M\u2080]", "[CancelMonoidWithZero M\u2080] {a b c : M\u2080}", "[CommSemigroup M\u2080] [Zero M\u2080]", "[MonoidWithZero M\u2080] [Div M\u2080] [MulDivCancelClass M\u2080]", "[CommMonoidWithZero M\u2080] [Div M\u2080] [MulDivCancelClass M\u2080]", "[GroupWithZero G\u2080] {a : G\u2080}", "[CancelMonoidWithZero M\u2080] {x : M\u2080}", "[GroupWithZero G\u2080] {a b : G\u2080}", "[MulZeroClass M\u2080]", "[NoZeroDivisors M\u2080] {a b : M\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M\u2080 : Type u_1\ninst\u271d\u00b9\u2078 : Mul M\u2080\ninst\u271d\u00b9\u2077 : Zero M\u2080\ninst\u271d\u00b9\u2076 : IsLeftCancelMulZero M\u2080\ninst\u271d\u00b9\u2075 : Mul M\u2080\ninst\u271d\u00b9\u2074 : Zero M\u2080\ninst\u271d\u00b9\u00b3 : IsRightCancelMulZero M\u2080\ninst\u271d\u00b9\u00b2 : MonoidWithZero M\u2080\ninst\u271d\u00b9\u00b9 : CancelMonoidWithZero M\u2080\ninst\u271d\u00b9\u2070 : CommSemigroup M\u2080\ninst\u271d\u2079 : Zero M\u2080\ninst\u271d\u2078 : MonoidWithZero M\u2080\ninst\u271d\u2077 : Div M\u2080\ninst\u271d\u2076 : MulDivCancelClass M\u2080\ninst\u271d\u2075 : CommMonoidWithZero M\u2080\ninst\u271d\u2074 : Div M\u2080\ninst\u271d\u00b3 : MulDivCancelClass M\u2080\ninst\u271d\u00b2 : CancelMonoidWithZero M\u2080\ninst\u271d\u00b9 : MulZeroClass M\u2080\ninst\u271d : NoZeroDivisors M\u2080\na b : M\u2080\nha : a \u2260 0\n\u22a2 a * b \u2260 0 \u2194 b \u2260 0"}, {"line": "simp [ha]", "tactic_state": "M\u2080 : Type u_1\ninst\u271d\u00b9\u2078 : Mul M\u2080\ninst\u271d\u00b9\u2077 : Zero M\u2080\ninst\u271d\u00b9\u2076 : IsLeftCancelMulZero M\u2080\ninst\u271d\u00b9\u2075 : Mul M\u2080\ninst\u271d\u00b9\u2074 : Zero M\u2080\ninst\u271d\u00b9\u00b3 : IsRightCancelMulZero M\u2080\ninst\u271d\u00b9\u00b2 : MonoidWithZero M\u2080\ninst\u271d\u00b9\u00b9 : CancelMonoidWithZero M\u2080\ninst\u271d\u00b9\u2070 : CommSemigroup M\u2080\ninst\u271d\u2079 : Zero M\u2080\ninst\u271d\u2078 : MonoidWithZero M\u2080\ninst\u271d\u2077 : Div M\u2080\ninst\u271d\u2076 : MulDivCancelClass M\u2080\ninst\u271d\u2075 : CommMonoidWithZero M\u2080\ninst\u271d\u2074 : Div M\u2080\ninst\u271d\u00b3 : MulDivCancelClass M\u2080\ninst\u271d\u00b2 : CancelMonoidWithZero M\u2080\ninst\u271d\u00b9 : MulZeroClass M\u2080\ninst\u271d : NoZeroDivisors M\u2080\na b : M\u2080\nha : a \u2260 0\n\u22a2 \u00aca * b = 0 \u2194 \u00acb = 0"}]}
{"declaration": "theorem mul_ne_zero_iff_right (hb : b \u2260 0) : a * b \u2260 0 \u2194 a \u2260 0 := by simp [hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Defs.lean", "context": {"open": [], "variables": ["{G\u2080 : Type u} {M\u2080 : Type*}", "[Mul M\u2080] [Zero M\u2080] [IsLeftCancelMulZero M\u2080] {a b c : M\u2080}", "[Mul M\u2080] [Zero M\u2080] [IsRightCancelMulZero M\u2080] {a b c : M\u2080}", "[MonoidWithZero M\u2080]", "[CancelMonoidWithZero M\u2080] {a b c : M\u2080}", "[CommSemigroup M\u2080] [Zero M\u2080]", "[MonoidWithZero M\u2080] [Div M\u2080] [MulDivCancelClass M\u2080]", "[CommMonoidWithZero M\u2080] [Div M\u2080] [MulDivCancelClass M\u2080]", "[GroupWithZero G\u2080] {a : G\u2080}", "[CancelMonoidWithZero M\u2080] {x : M\u2080}", "[GroupWithZero G\u2080] {a b : G\u2080}", "[MulZeroClass M\u2080]", "[NoZeroDivisors M\u2080] {a b : M\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M\u2080 : Type u_1\ninst\u271d\u00b9\u2078 : Mul M\u2080\ninst\u271d\u00b9\u2077 : Zero M\u2080\ninst\u271d\u00b9\u2076 : IsLeftCancelMulZero M\u2080\ninst\u271d\u00b9\u2075 : Mul M\u2080\ninst\u271d\u00b9\u2074 : Zero M\u2080\ninst\u271d\u00b9\u00b3 : IsRightCancelMulZero M\u2080\ninst\u271d\u00b9\u00b2 : MonoidWithZero M\u2080\ninst\u271d\u00b9\u00b9 : CancelMonoidWithZero M\u2080\ninst\u271d\u00b9\u2070 : CommSemigroup M\u2080\ninst\u271d\u2079 : Zero M\u2080\ninst\u271d\u2078 : MonoidWithZero M\u2080\ninst\u271d\u2077 : Div M\u2080\ninst\u271d\u2076 : MulDivCancelClass M\u2080\ninst\u271d\u2075 : CommMonoidWithZero M\u2080\ninst\u271d\u2074 : Div M\u2080\ninst\u271d\u00b3 : MulDivCancelClass M\u2080\ninst\u271d\u00b2 : CancelMonoidWithZero M\u2080\ninst\u271d\u00b9 : MulZeroClass M\u2080\ninst\u271d : NoZeroDivisors M\u2080\na b : M\u2080\nhb : b \u2260 0\n\u22a2 a * b \u2260 0 \u2194 a \u2260 0"}, {"line": "simp [hb]", "tactic_state": "M\u2080 : Type u_1\ninst\u271d\u00b9\u2078 : Mul M\u2080\ninst\u271d\u00b9\u2077 : Zero M\u2080\ninst\u271d\u00b9\u2076 : IsLeftCancelMulZero M\u2080\ninst\u271d\u00b9\u2075 : Mul M\u2080\ninst\u271d\u00b9\u2074 : Zero M\u2080\ninst\u271d\u00b9\u00b3 : IsRightCancelMulZero M\u2080\ninst\u271d\u00b9\u00b2 : MonoidWithZero M\u2080\ninst\u271d\u00b9\u00b9 : CancelMonoidWithZero M\u2080\ninst\u271d\u00b9\u2070 : CommSemigroup M\u2080\ninst\u271d\u2079 : Zero M\u2080\ninst\u271d\u2078 : MonoidWithZero M\u2080\ninst\u271d\u2077 : Div M\u2080\ninst\u271d\u2076 : MulDivCancelClass M\u2080\ninst\u271d\u2075 : CommMonoidWithZero M\u2080\ninst\u271d\u2074 : Div M\u2080\ninst\u271d\u00b3 : MulDivCancelClass M\u2080\ninst\u271d\u00b2 : CancelMonoidWithZero M\u2080\ninst\u271d\u00b9 : MulZeroClass M\u2080\ninst\u271d : NoZeroDivisors M\u2080\na b : M\u2080\nhb : b \u2260 0\n\u22a2 \u00aca * b = 0 \u2194 \u00aca = 0"}]}
{"declaration": "lemma indicator_mul (s : Set \u03b9) (f g : \u03b9 \u2192 M\u2080) :\n    indicator s (fun i \u21a6 f i * g i) = fun i \u21a6 indicator s f i * indicator s g i := by\n  funext\n  simp only [indicator]\n  split_ifs\n  \u00b7 rfl\n  rw [mul_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Indicator.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03ba G\u2080 M\u2080 R : Type*}", "[MulZeroClass M\u2080] {s t : Set \u03b9} {i : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ns : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\n\u22a2 (s.indicator fun i => f i * g i) = fun i => s.indicator f i * s.indicator g i"}, {"line": "funext", "tactic_state": "case h\n\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ns : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\nx\u271d : \u03b9\n\u22a2 s.indicator (fun i => f i * g i) x\u271d = s.indicator f x\u271d * s.indicator g x\u271d"}, {"line": "simp only [indicator]", "tactic_state": "case h\n\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ns : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\nx\u271d : \u03b9\n\u22a2 (if x\u271d \u2208 s then f x\u271d * g x\u271d else 0) = (if x\u271d \u2208 s then f x\u271d else 0) * if x\u271d \u2208 s then g x\u271d else 0"}, {"line": "split_ifs", "tactic_state": "case pos\n\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ns : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\nx\u271d : \u03b9\nh\u271d : x\u271d \u2208 s\n\u22a2 f x\u271d * g x\u271d = f x\u271d * g x\u271d\n---\ncase neg\n\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ns : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\nx\u271d : \u03b9\nh\u271d : x\u271d \u2209 s\n\u22a2 0 = 0 * 0"}, {"line": "\u00b7 rfl", "tactic_state": "case neg\n\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ns : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\nx\u271d : \u03b9\nh\u271d : x\u271d \u2209 s\n\u22a2 0 = 0 * 0"}, {"line": "rw [mul_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma indicator_mul_left (s : Set \u03b9) (f g : \u03b9 \u2192 M\u2080) :\n    indicator s (fun j \u21a6 f j * g j) i = indicator s f i * g i := by\n  simp only [indicator]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 rw [zero_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Indicator.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03ba G\u2080 M\u2080 R : Type*}", "[MulZeroClass M\u2080] {s t : Set \u03b9} {i : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ni : \u03b9\ns : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\n\u22a2 s.indicator (fun j => f j * g j) i = s.indicator f i * g i"}, {"line": "simp only [indicator]", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ni : \u03b9\ns : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\n\u22a2 (if i \u2208 s then f i * g i else 0) = (if i \u2208 s then f i else 0) * g i"}, {"line": "split_ifs", "tactic_state": "case pos\n\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ni : \u03b9\ns : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\nh\u271d : i \u2208 s\n\u22a2 f i * g i = f i * g i\n---\ncase neg\n\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ni : \u03b9\ns : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\nh\u271d : i \u2209 s\n\u22a2 0 = 0 * g i"}, {"line": "\u00b7 rfl", "tactic_state": "case neg\n\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ni : \u03b9\ns : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\nh\u271d : i \u2209 s\n\u22a2 0 = 0 * g i"}, {"line": "\u00b7 rw [zero_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma indicator_mul_right (s : Set \u03b9) (f g : \u03b9 \u2192 M\u2080) :\n    indicator s (fun j \u21a6 f j * g j) i = f i * indicator s g i := by\n  simp only [indicator]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 rw [mul_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Indicator.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03ba G\u2080 M\u2080 R : Type*}", "[MulZeroClass M\u2080] {s t : Set \u03b9} {i : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ni : \u03b9\ns : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\n\u22a2 s.indicator (fun j => f j * g j) i = f i * s.indicator g i"}, {"line": "simp only [indicator]", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ni : \u03b9\ns : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\n\u22a2 (if i \u2208 s then f i * g i else 0) = f i * if i \u2208 s then g i else 0"}, {"line": "split_ifs", "tactic_state": "case pos\n\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ni : \u03b9\ns : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\nh\u271d : i \u2208 s\n\u22a2 f i * g i = f i * g i\n---\ncase neg\n\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ni : \u03b9\ns : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\nh\u271d : i \u2209 s\n\u22a2 0 = f i * 0"}, {"line": "\u00b7 rfl", "tactic_state": "case neg\n\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ni : \u03b9\ns : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\nh\u271d : i \u2209 s\n\u22a2 0 = f i * 0"}, {"line": "\u00b7 rw [mul_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma indicator_mul_const (s : Set \u03b9) (f : \u03b9 \u2192 M\u2080) (a : M\u2080) (i : \u03b9) :\n    s.indicator (f \u00b7 * a) i = s.indicator f i * a := by rw [indicator_mul_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Indicator.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03ba G\u2080 M\u2080 R : Type*}", "[MulZeroClass M\u2080] {s t : Set \u03b9} {i : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ns : Set \u03b9\nf : \u03b9 \u2192 M\u2080\na : M\u2080\ni : \u03b9\n\u22a2 s.indicator (fun x => f x * a) i = s.indicator f i * a"}, {"line": "rw [indicator_mul_left]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma indicator_const_mul (s : Set \u03b9) (f : \u03b9 \u2192 M\u2080) (a : M\u2080) (i : \u03b9) :\n    s.indicator (a * f \u00b7) i = a * s.indicator f i := by rw [indicator_mul_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Indicator.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03ba G\u2080 M\u2080 R : Type*}", "[MulZeroClass M\u2080] {s t : Set \u03b9} {i : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ns : Set \u03b9\nf : \u03b9 \u2192 M\u2080\na : M\u2080\ni : \u03b9\n\u22a2 s.indicator (fun x => a * f x) i = a * s.indicator f i"}, {"line": "rw [indicator_mul_right]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inter_indicator_mul (f g : \u03b9 \u2192 M\u2080) (i : \u03b9) :\n    (s \u2229 t).indicator (fun j \u21a6 f j * g j) i = s.indicator f i * t.indicator g i := by\n  rw [\u2190 Set.indicator_indicator]\n  simp_rw [indicator]\n  split_ifs <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Indicator.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03ba G\u2080 M\u2080 R : Type*}", "[MulZeroClass M\u2080] {s t : Set \u03b9} {i : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ns t : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\ni : \u03b9\n\u22a2 (s \u2229 t).indicator (fun j => f j * g j) i = s.indicator f i * t.indicator g i"}, {"line": "rw [\u2190 Set.indicator_indicator]", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ns t : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\ni : \u03b9\n\u22a2 s.indicator (t.indicator fun j => f j * g j) i = s.indicator f i * t.indicator g i"}, {"line": "simp_rw [indicator]", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroClass M\u2080\ns t : Set \u03b9\nf g : \u03b9 \u2192 M\u2080\ni : \u03b9\n\u22a2 (if i \u2208 s then if i \u2208 t then f i * g i else 0 else 0) = (if i \u2208 s then f i else 0) * if i \u2208 t then g i else 0"}, {"line": "split_ifs <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma indicator_eq_zero_iff_not_mem : indicator s 1 i = (0 : M\u2080) \u2194 i \u2209 s := by\n  classical simp [indicator_apply, imp_false]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Indicator.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03ba G\u2080 M\u2080 R : Type*}", "[MulZeroClass M\u2080] {s t : Set \u03b9} {i : \u03b9}", "[MulZeroOneClass M\u2080] {s t : Set \u03b9} {i : \u03b9}", "(M\u2080) [Nontrivial M\u2080]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d\u00b2 : MulZeroClass M\u2080\ninst\u271d\u00b9 : MulZeroOneClass M\u2080\ns : Set \u03b9\ni : \u03b9\ninst\u271d : Nontrivial M\u2080\n\u22a2 s.indicator 1 i = 0 \u2194 i \u2209 s"}, {"line": "classical simp [indicator_apply, imp_false]", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d\u00b2 : MulZeroClass M\u2080\ninst\u271d\u00b9 : MulZeroOneClass M\u2080\ns : Set \u03b9\ni : \u03b9\ninst\u271d : Nontrivial M\u2080\n\u22a2 i \u2208 s \u2192 1 = 0 \u2194 i \u2209 s"}]}
{"declaration": "lemma indicator_eq_one_iff_mem : indicator s 1 i = (1 : M\u2080) \u2194 i \u2208 s := by\n  classical simp [indicator_apply, imp_false]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Indicator.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03ba G\u2080 M\u2080 R : Type*}", "[MulZeroClass M\u2080] {s t : Set \u03b9} {i : \u03b9}", "[MulZeroOneClass M\u2080] {s t : Set \u03b9} {i : \u03b9}", "(M\u2080) [Nontrivial M\u2080]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d\u00b2 : MulZeroClass M\u2080\ninst\u271d\u00b9 : MulZeroOneClass M\u2080\ns : Set \u03b9\ni : \u03b9\ninst\u271d : Nontrivial M\u2080\n\u22a2 s.indicator 1 i = 1 \u2194 i \u2208 s"}, {"line": "classical simp [indicator_apply, imp_false]", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d\u00b2 : MulZeroClass M\u2080\ninst\u271d\u00b9 : MulZeroOneClass M\u2080\ns : Set \u03b9\ni : \u03b9\ninst\u271d : Nontrivial M\u2080\n\u22a2 i \u2209 s \u2192 0 = 1 \u2194 i \u2208 s"}]}
{"declaration": "theorem ofAdd_zpow (a : \u2124) : (\u2191(ofAdd a) : \u2124\u2098\u2080) = ofAdd (1 : \u2124) ^ a := by\n  rw [\u2190 WithZero.coe_zpow]\n  rw [WithZero.coe_inj]\n  rw [\u2190 Int.ofAdd_mul]\n  rw [one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Int.lean", "context": {"open": ["Multiplicative"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2124\n\u22a2 \u2191(ofAdd a) = \u2191(ofAdd 1) ^ a"}, {"line": "rw [\u2190 WithZero.coe_zpow]", "tactic_state": "a : \u2124\n\u22a2 \u2191(ofAdd a) = \u2191(ofAdd 1 ^ a)"}, {"line": "rw [WithZero.coe_inj]", "tactic_state": "a : \u2124\n\u22a2 ofAdd a = ofAdd 1 ^ a"}, {"line": "rw [\u2190 Int.ofAdd_mul]", "tactic_state": "a : \u2124\n\u22a2 ofAdd a = ofAdd (1 * a)"}, {"line": "rw [one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nmem_nonZeroDivisorsLeft_iff :\n    x \u2209 nonZeroDivisorsLeft M\u2080 \u2194 {y | y * x = 0 \u2227 y \u2260 0}.Nonempty := by\n  simpa [mem_nonZeroDivisorsLeft_iff] using Set.nonempty_def.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/NonZeroDivisors.lean", "context": {"open": ["Function"], "variables": ["(M\u2080 : Type*) [MonoidWithZero M\u2080] {x : M\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M\u2080 : Type u_1\ninst\u271d : MonoidWithZero M\u2080\nx : M\u2080\n\u22a2 x \u2209 nonZeroDivisorsLeft M\u2080 \u2194 {y | y * x = 0 \u2227 y \u2260 0}.Nonempty"}, {"line": "simpa [mem_nonZeroDivisorsLeft_iff] using Set.nonempty_def.symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nmem_nonZeroDivisorsRight_iff :\n    x \u2209 nonZeroDivisorsRight M\u2080 \u2194 {y | x * y = 0 \u2227 y \u2260 0}.Nonempty := by\n  simpa [mem_nonZeroDivisorsRight_iff] using Set.nonempty_def.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/NonZeroDivisors.lean", "context": {"open": ["Function"], "variables": ["(M\u2080 : Type*) [MonoidWithZero M\u2080] {x : M\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M\u2080 : Type u_1\ninst\u271d : MonoidWithZero M\u2080\nx : M\u2080\n\u22a2 x \u2209 nonZeroDivisorsRight M\u2080 \u2194 {y | x * y = 0 \u2227 y \u2260 0}.Nonempty"}, {"line": "simpa [mem_nonZeroDivisorsRight_iff] using Set.nonempty_def.symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nmem_nonZeroDivisors_iff : r \u2209 M\u2080\u2070 \u2194 {s | s * r = 0 \u2227 s \u2260 0}.Nonempty := by\n  simpa [mem_nonZeroDivisors_iff] using Set.nonempty_def.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/NonZeroDivisors.lean", "context": {"open": ["Function", "nonZeroDivisors"], "variables": ["(M\u2080 : Type*) [MonoidWithZero M\u2080] {x : M\u2080}", "{F M\u2080 M\u2080' : Type*} [MonoidWithZero M\u2080] [MonoidWithZero M\u2080'] {r x y : M\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M\u2080 : Type u_3\ninst\u271d : MonoidWithZero M\u2080\nr : M\u2080\n\u22a2 r \u2209 nonZeroDivisors M\u2080 \u2194 {s | s * r = 0 \u2227 s \u2260 0}.Nonempty"}, {"line": "simpa [mem_nonZeroDivisors_iff] using Set.nonempty_def.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_le_nonZeroDivisors_of_injective [NoZeroDivisors M\u2080'] [MonoidWithZeroHomClass F M\u2080 M\u2080']\n    (f : F) (hf : Injective f) {S : Submonoid M\u2080} (hS : S \u2264 M\u2080\u2070) : S.map f \u2264 M\u2080'\u2070 := by\n  cases subsingleton_or_nontrivial M\u2080\n  \u00b7 simp [Subsingleton.elim S \u22a5]\n  \u00b7 refine le_nonZeroDivisors_of_noZeroDivisors ?_\n    rintro \u27e8x, hx, hx0\u27e9\n    exact zero_not_mem_nonZeroDivisors <| hS <| map_eq_zero_iff f hf |>.mp hx0 \u25b8 hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/NonZeroDivisors.lean", "context": {"open": ["Function", "nonZeroDivisors"], "variables": ["(M\u2080 : Type*) [MonoidWithZero M\u2080] {x : M\u2080}", "{F M\u2080 M\u2080' : Type*} [MonoidWithZero M\u2080] [MonoidWithZero M\u2080'] {r x y : M\u2080}", "[Nontrivial M\u2080]", "[NoZeroDivisors M\u2080]", "[FunLike F M\u2080 M\u2080']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_2\nM\u2080 : Type u_3\nM\u2080' : Type u_4\ninst\u271d\u2076 : MonoidWithZero M\u2080\ninst\u271d\u2075 : MonoidWithZero M\u2080'\ninst\u271d\u2074 : Nontrivial M\u2080\ninst\u271d\u00b3 : NoZeroDivisors M\u2080\ninst\u271d\u00b2 : FunLike F M\u2080 M\u2080'\ninst\u271d\u00b9 : NoZeroDivisors M\u2080'\ninst\u271d : MonoidWithZeroHomClass F M\u2080 M\u2080'\nf : F\nhf : Injective \u21d1f\nS : Submonoid M\u2080\nhS : S \u2264 nonZeroDivisors M\u2080\n\u22a2 Submonoid.map f S \u2264 nonZeroDivisors M\u2080'"}, {"line": "cases subsingleton_or_nontrivial M\u2080", "tactic_state": "case inl\nF : Type u_2\nM\u2080 : Type u_3\nM\u2080' : Type u_4\ninst\u271d\u2076 : MonoidWithZero M\u2080\ninst\u271d\u2075 : MonoidWithZero M\u2080'\ninst\u271d\u2074 : Nontrivial M\u2080\ninst\u271d\u00b3 : NoZeroDivisors M\u2080\ninst\u271d\u00b2 : FunLike F M\u2080 M\u2080'\ninst\u271d\u00b9 : NoZeroDivisors M\u2080'\ninst\u271d : MonoidWithZeroHomClass F M\u2080 M\u2080'\nf : F\nhf : Injective \u21d1f\nS : Submonoid M\u2080\nhS : S \u2264 nonZeroDivisors M\u2080\nh\u271d : Subsingleton M\u2080\n\u22a2 Submonoid.map f S \u2264 nonZeroDivisors M\u2080'\n---\ncase inr\nF : Type u_2\nM\u2080 : Type u_3\nM\u2080' : Type u_4\ninst\u271d\u2076 : MonoidWithZero M\u2080\ninst\u271d\u2075 : MonoidWithZero M\u2080'\ninst\u271d\u2074 : Nontrivial M\u2080\ninst\u271d\u00b3 : NoZeroDivisors M\u2080\ninst\u271d\u00b2 : FunLike F M\u2080 M\u2080'\ninst\u271d\u00b9 : NoZeroDivisors M\u2080'\ninst\u271d : MonoidWithZeroHomClass F M\u2080 M\u2080'\nf : F\nhf : Injective \u21d1f\nS : Submonoid M\u2080\nhS : S \u2264 nonZeroDivisors M\u2080\nh\u271d : Nontrivial M\u2080\n\u22a2 Submonoid.map f S \u2264 nonZeroDivisors M\u2080'"}, {"line": "\u00b7 simp [Subsingleton.elim S \u22a5]", "tactic_state": "case inr\nF : Type u_2\nM\u2080 : Type u_3\nM\u2080' : Type u_4\ninst\u271d\u2076 : MonoidWithZero M\u2080\ninst\u271d\u2075 : MonoidWithZero M\u2080'\ninst\u271d\u2074 : Nontrivial M\u2080\ninst\u271d\u00b3 : NoZeroDivisors M\u2080\ninst\u271d\u00b2 : FunLike F M\u2080 M\u2080'\ninst\u271d\u00b9 : NoZeroDivisors M\u2080'\ninst\u271d : MonoidWithZeroHomClass F M\u2080 M\u2080'\nf : F\nhf : Injective \u21d1f\nS : Submonoid M\u2080\nhS : S \u2264 nonZeroDivisors M\u2080\nh\u271d : Nontrivial M\u2080\n\u22a2 Submonoid.map f S \u2264 nonZeroDivisors M\u2080'"}, {"line": "\u00b7 refine le_nonZeroDivisors_of_noZeroDivisors ?_\n    rintro \u27e8x, hx, hx0\u27e9\n    exact zero_not_mem_nonZeroDivisors <| hS <| map_eq_zero_iff f hf |>.mp hx0 \u25b8 hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_right [MulZeroClass G\u2080] (a : G\u2080) : SemiconjBy a 0 0 := by\n  simp only [SemiconjBy]\n  simp only [mul_zero]\n  simp only [zero_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Semiconj.lean", "context": {"open": [], "variables": ["{G\u2080 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_1\ninst\u271d : MulZeroClass G\u2080\na : G\u2080\n\u22a2 SemiconjBy a 0 0"}, {"line": "simp only [SemiconjBy]", "tactic_state": "G\u2080 : Type u_1\ninst\u271d : MulZeroClass G\u2080\na : G\u2080\n\u22a2 a * 0 = 0 * a"}, {"line": "simp only [mul_zero]", "tactic_state": "G\u2080 : Type u_1\ninst\u271d : MulZeroClass G\u2080\na : G\u2080\n\u22a2 0 = 0 * a"}, {"line": "simp only [zero_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_left [MulZeroClass G\u2080] (x y : G\u2080) : SemiconjBy 0 x y := by\n  simp only [SemiconjBy]\n  simp only [mul_zero]\n  simp only [zero_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Semiconj.lean", "context": {"open": [], "variables": ["{G\u2080 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_1\ninst\u271d : MulZeroClass G\u2080\nx y : G\u2080\n\u22a2 SemiconjBy 0 x y"}, {"line": "simp only [SemiconjBy]", "tactic_state": "G\u2080 : Type u_1\ninst\u271d : MulZeroClass G\u2080\nx y : G\u2080\n\u22a2 0 * x = y * 0"}, {"line": "simp only [mul_zero]", "tactic_state": "G\u2080 : Type u_1\ninst\u271d : MulZeroClass G\u2080\nx y : G\u2080\n\u22a2 0 * x = 0"}, {"line": "simp only [zero_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_right (h : SemiconjBy a x y) (h' : SemiconjBy a x' y') :\n    SemiconjBy a (x / x') (y / y') := by\n  rw [div_eq_mul_inv]\n  rw [div_eq_mul_inv]\n  exact h.mul_right h'.inv_right\u2080\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Semiconj.lean", "context": {"open": [], "variables": ["{G\u2080 : Type*}", "[GroupWithZero G\u2080] {a x y x' y' : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_1\ninst\u271d : GroupWithZero G\u2080\na x y x' y' : G\u2080\nh : SemiconjBy a x y\nh' : SemiconjBy a x' y'\n\u22a2 SemiconjBy a (x / x') (y / y')"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "G\u2080 : Type u_1\ninst\u271d : GroupWithZero G\u2080\na x y x' y' : G\u2080\nh : SemiconjBy a x y\nh' : SemiconjBy a x' y'\n\u22a2 SemiconjBy a (x * x'\u207b\u00b9) (y / y')"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "G\u2080 : Type u_1\ninst\u271d : GroupWithZero G\u2080\na x y x' y' : G\u2080\nh : SemiconjBy a x y\nh' : SemiconjBy a x' y'\n\u22a2 SemiconjBy a (x * x'\u207b\u00b9) (y * y'\u207b\u00b9)"}, {"line": "exact h.mul_right h'.inv_right\u2080", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_zero_mk {\u03b1 : Type*} [Monoid M] [AddMonoid \u03b1] [DistribMulAction M \u03b1] (a : M) (c : \u03b2) :\n    a \u2022 ((0 : \u03b1), c) = (0, a \u2022 c) := by rw [Prod.smul_mk, smul_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Action/Prod.lean", "context": {"open": [], "variables": ["{M N \u03b1 \u03b2 : Type*}", "[SMul M \u03b1] [SMul M \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\n\u03b2 : Type u_4\ninst\u271d\u00b3 : SMul M \u03b2\n\u03b1 : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : AddMonoid \u03b1\ninst\u271d : DistribMulAction M \u03b1\na : M\nc : \u03b2\n\u22a2 a \u2022 (0, c) = (0, a \u2022 c)"}, {"line": "rw [Prod.smul_mk, smul_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_mk_zero {\u03b2 : Type*} [Monoid M] [AddMonoid \u03b2] [DistribMulAction M \u03b2] (a : M) (b : \u03b1) :\n    a \u2022 (b, (0 : \u03b2)) = (a \u2022 b, 0) := by rw [Prod.smul_mk, smul_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Action/Prod.lean", "context": {"open": [], "variables": ["{M N \u03b1 \u03b2 : Type*}", "[SMul M \u03b1] [SMul M \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u00b3 : SMul M \u03b1\n\u03b2 : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : AddMonoid \u03b2\ninst\u271d : DistribMulAction M \u03b2\na : M\nb : \u03b1\n\u22a2 a \u2022 (b, 0) = (a \u2022 b, 0)"}, {"line": "rw [Prod.smul_mk, smul_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_ite_zero (p : Prop) [Decidable p] (a : M) (b : A) :\n    (a \u2022 if p then b else 0) = if p then a \u2022 b else 0 := by split_ifs <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Action/Defs.lean", "context": {"open": ["Function"], "variables": ["{M M\u2080 M\u2080' G\u2080 G\u2080' N A A' B \u03b1 \u03b2 : Type*}", "[Zero A] [SMulZeroClass M A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nA : Type u_7\ninst\u271d\u00b2 : Zero A\ninst\u271d\u00b9 : SMulZeroClass M A\np : Prop\ninst\u271d : Decidable p\na : M\nb : A\n\u22a2 (a \u2022 if p then b else 0) = if p then a \u2022 b else 0"}, {"line": "split_ifs <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma boole_smul (a : A) : (if p then 1 else 0 : M\u2080) \u2022 a = if p then a else 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Action/Defs.lean", "context": {"open": ["Function"], "variables": ["{M M\u2080 M\u2080' G\u2080 G\u2080' N A A' B \u03b1 \u03b2 : Type*}", "[Zero A] [SMulZeroClass M A]", "(A)", "(M\u2080 A)", "{A} [Zero M\u2080] [Zero A] [SMulWithZero M\u2080 A]", "{M\u2080} {a : M\u2080} {b : A}", "[Zero M\u2080'] [Zero A'] [SMul M\u2080 A']", "(A)", "(M\u2080 A) [MonoidWithZero M\u2080] [MonoidWithZero M\u2080'] [Zero A]", "{M\u2080 A} [MulActionWithZero M\u2080 A] [Zero A'] [SMul M\u2080 A'] (p : Prop) [Decidable p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M\u2080 : Type u_2\nA : Type u_7\ninst\u271d\u00b3 : Zero A\ninst\u271d\u00b2 : Zero M\u2080\ninst\u271d\u00b9 : Zero A\ninst\u271d : SMulWithZero M\u2080 A\np : Prop\na : A\n\u22a2 sorry \u2022 a = sorry"}, {"line": "simp", "tactic_state": "M\u2080 : Type u_2\nA : Type u_7\ninst\u271d\u00b3 : Zero A\ninst\u271d\u00b2 : Zero M\u2080\ninst\u271d\u00b9 : Zero A\ninst\u271d : SMulWithZero M\u2080 A\np : Prop\na : A\n\u22a2 sorry () \u2022 a = sorry ()"}]}
{"declaration": "lemma smul_inv\u2080 (c : G\u2080) (x : G\u2080') : (c \u2022 x)\u207b\u00b9 = c\u207b\u00b9 \u2022 x\u207b\u00b9 := by\n  obtain rfl | hc := eq_or_ne c 0\n  \u00b7 simp only [inv_zero, zero_smul]\n  obtain rfl | hx := eq_or_ne x 0\n  \u00b7 simp only [inv_zero, smul_zero]\n  \u00b7 refine inv_eq_of_mul_eq_one_left ?_\n    rw [smul_mul_smul_comm]\n    rw [inv_mul_cancel\u2080 hc]\n    rw [inv_mul_cancel\u2080 hx]\n    rw [one_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Action/Defs.lean", "context": {"open": ["Function"], "variables": ["{M M\u2080 M\u2080' G\u2080 G\u2080' N A A' B \u03b1 \u03b2 : Type*}", "[Zero A] [SMulZeroClass M A]", "(A)", "(M\u2080 A)", "{A} [Zero M\u2080] [Zero A] [SMulWithZero M\u2080 A]", "{M\u2080} {a : M\u2080} {b : A}", "[Zero M\u2080'] [Zero A'] [SMul M\u2080 A']", "(A)", "(M\u2080 A) [MonoidWithZero M\u2080] [MonoidWithZero M\u2080'] [Zero A]", "{M\u2080 A} [MulActionWithZero M\u2080 A] [Zero A'] [SMul M\u2080 A'] (p : Prop) [Decidable p]", "(A)", "[GroupWithZero G\u2080] [GroupWithZero G\u2080'] [MulActionWithZero G\u2080 G\u2080']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_4\nG\u2080' : Type u_5\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : GroupWithZero G\u2080'\ninst\u271d : MulActionWithZero G\u2080 G\u2080'\nc : G\u2080\nx : G\u2080'\n\u22a2 (c \u2022 x)\u207b\u00b9 = c\u207b\u00b9 \u2022 x\u207b\u00b9"}, {"line": "obtain rfl | hc := eq_or_ne c 0", "tactic_state": "case inl\nG\u2080 : Type u_4\nG\u2080' : Type u_5\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : GroupWithZero G\u2080'\ninst\u271d : MulActionWithZero G\u2080 G\u2080'\nx : G\u2080'\n\u22a2 (sorry \u2022 x)\u207b\u00b9 = sorry\u207b\u00b9 \u2022 x\u207b\u00b9\n---\ncase inr\nG\u2080 : Type u_4\nG\u2080' : Type u_5\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : GroupWithZero G\u2080'\ninst\u271d : MulActionWithZero G\u2080 G\u2080'\nc : G\u2080\nx : G\u2080'\nhc : c \u2260 sorry\n\u22a2 (c \u2022 x)\u207b\u00b9 = c\u207b\u00b9 \u2022 x\u207b\u00b9"}, {"line": "\u00b7 simp only [inv_zero, zero_smul]", "tactic_state": "case inr\nG\u2080 : Type u_4\nG\u2080' : Type u_5\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : GroupWithZero G\u2080'\ninst\u271d : MulActionWithZero G\u2080 G\u2080'\nc : G\u2080\nx : G\u2080'\nhc : c \u2260 sorry\n\u22a2 (c \u2022 x)\u207b\u00b9 = c\u207b\u00b9 \u2022 x\u207b\u00b9"}, {"line": "obtain rfl | hx := eq_or_ne x 0", "tactic_state": "case inr.inl\nG\u2080 : Type u_4\nG\u2080' : Type u_5\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : GroupWithZero G\u2080'\ninst\u271d : MulActionWithZero G\u2080 G\u2080'\nc : G\u2080\nhc : c \u2260 sorry\n\u22a2 (c \u2022 sorry)\u207b\u00b9 = c\u207b\u00b9 \u2022 sorry\u207b\u00b9\n---\ncase inr.inr\nG\u2080 : Type u_4\nG\u2080' : Type u_5\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : GroupWithZero G\u2080'\ninst\u271d : MulActionWithZero G\u2080 G\u2080'\nc : G\u2080\nx : G\u2080'\nhc : c \u2260 sorry\nhx : x \u2260 sorry\n\u22a2 (c \u2022 x)\u207b\u00b9 = c\u207b\u00b9 \u2022 x\u207b\u00b9"}, {"line": "\u00b7 simp only [inv_zero, smul_zero]", "tactic_state": "case inr.inr\nG\u2080 : Type u_4\nG\u2080' : Type u_5\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : GroupWithZero G\u2080'\ninst\u271d : MulActionWithZero G\u2080 G\u2080'\nc : G\u2080\nx : G\u2080'\nhc : c \u2260 sorry\nhx : x \u2260 sorry\n\u22a2 (c \u2022 x)\u207b\u00b9 = c\u207b\u00b9 \u2022 x\u207b\u00b9"}, {"line": "\u00b7 refine inv_eq_of_mul_eq_one_left ?_\n    rw [smul_mul_smul_comm]\n    rw [inv_mul_cancel\u2080 hc]\n    rw [inv_mul_cancel\u2080 hx]\n    rw [one_smul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zero_mem_smul_set_iff (ha : a \u2260 0) : (0 : \u03b2) \u2208 a \u2022 t \u2194 (0 : \u03b2) \u2208 t := by\n  refine \u27e8?_, zero_mem_smul_set\u27e9\n  rintro \u27e8b, hb, h\u27e9\n  rwa [(eq_zero_or_eq_zero_of_smul_eq_zero h).resolve_left ha] at hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Action/Pointwise/Set.lean", "context": {"open": ["Function", "scoped Pointwise"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Zero \u03b2] [SMulZeroClass \u03b1 \u03b2] {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1}", "[Zero \u03b1] [NoZeroSMulDivisors \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Zero \u03b2\ninst\u271d\u00b2 : SMulZeroClass \u03b1 \u03b2\nt : Set \u03b2\na : \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : NoZeroSMulDivisors \u03b1 \u03b2\nha : a \u2260 0\n\u22a2 0 \u2208 a \u2022 t \u2194 0 \u2208 t"}, {"line": "refine \u27e8?_, zero_mem_smul_set\u27e9", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Zero \u03b2\ninst\u271d\u00b2 : SMulZeroClass \u03b1 \u03b2\nt : Set \u03b2\na : \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : NoZeroSMulDivisors \u03b1 \u03b2\nha : a \u2260 0\n\u22a2 0 \u2208 a \u2022 t \u2192 0 \u2208 t"}, {"line": "rintro \u27e8b, hb, h\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Zero \u03b2\ninst\u271d\u00b2 : SMulZeroClass \u03b1 \u03b2\nt : Set \u03b2\na : \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : NoZeroSMulDivisors \u03b1 \u03b2\nha : a \u2260 0\nb : \u03b2\nhb : b \u2208 t\nh : (fun x => a \u2022 x) b = 0\n\u22a2 0 \u2208 t"}, {"line": "rwa [(eq_zero_or_eq_zero_of_smul_eq_zero h).resolve_left ha] at hb", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Zero \u03b2\ninst\u271d\u00b2 : SMulZeroClass \u03b1 \u03b2\nt : Set \u03b2\na : \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : NoZeroSMulDivisors \u03b1 \u03b2\nha : a \u2260 0\nb : \u03b2\nhb : b \u2208 t\nh : (fun x => a \u2022 x) b = 0\n\u22a2 NoZeroSMulDivisors \u03b1 \u03b2"}]}
{"declaration": "theorem inverse_zero : inverse (0 : M\u2080) = 0 := by\n  nontriviality\n  exact inverse_non_unit _ not_isUnit_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "context": {"open": ["Classical in"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MonoidWithZero M\u2080]", "(M\u2080)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ninverse : x\u271d\n\u22a2 sorry = 0"}, {"line": "nontriviality", "tactic_state": "x\u271d : Sort u_1\ninverse : x\u271d\ninst\u271d : Nontrivial \u2115\n\u22a2 sorry = 0"}, {"line": "exact inverse_non_unit _ not_isUnit_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_iff_ne_zero {p : G\u2080 \u2192 Prop} : (\u2203 u : G\u2080\u02e3, p u) \u2194 \u2203 x \u2260 0, p x := by\n  simp [exists0]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "context": {"open": ["Classical in"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MonoidWithZero M\u2080]", "(M\u2080)", "{M\u2080}", "[GroupWithZero G\u2080]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_1\ninst\u271d : GroupWithZero G\u2080\np : G\u2080 \u2192 Prop\n\u22a2 (\u2203 u, p \u2191u) \u2194 \u2203 x, x \u2260 0 \u2227 p x"}, {"line": "simp [exists0]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.GroupWithZero.eq_zero_or_unit (a : G\u2080) : a = 0 \u2228 \u2203 u : G\u2080\u02e3, a = u := by\n  simpa using em _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "context": {"open": ["Classical in"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MonoidWithZero M\u2080]", "(M\u2080)", "{M\u2080}", "[GroupWithZero G\u2080]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_1\ninst\u271d : GroupWithZero G\u2080\na : G\u2080\n\u22a2 a = 0 \u2228 \u2203 u, a = \u2191u"}, {"line": "simpa using em _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_ne_zero (ha : a \u2260 0) (hb : b \u2260 0) : a / b \u2260 0 := by\n  rw [div_eq_mul_inv]\n  exact mul_ne_zero ha (inv_ne_zero hb)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "context": {"open": ["Classical in"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MonoidWithZero M\u2080]", "(M\u2080)", "{M\u2080}", "[GroupWithZero G\u2080]", "[GroupWithZero G\u2080] {a b c : G\u2080} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na b : G\u2080\nha : a \u2260 0\nhb : b \u2260 0\n\u22a2 a / b \u2260 0"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "G\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na b : G\u2080\nha : a \u2260 0\nhb : b \u2260 0\n\u22a2 a * b\u207b\u00b9 \u2260 0"}, {"line": "exact mul_ne_zero ha (inv_ne_zero hb)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_eq_zero_iff : a / b = 0 \u2194 a = 0 \u2228 b = 0 := by simp [div_eq_mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "context": {"open": ["Classical in"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MonoidWithZero M\u2080]", "(M\u2080)", "{M\u2080}", "[GroupWithZero G\u2080]", "[GroupWithZero G\u2080] {a b c : G\u2080} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na b : G\u2080\n\u22a2 a / b = 0 \u2194 a = 0 \u2228 b = 0"}, {"line": "simp [div_eq_mul_inv]", "tactic_state": "G\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na b : G\u2080\n\u22a2 a * b\u207b\u00b9 = 0 \u2194 a = 0 \u2228 b = 0"}]}
{"declaration": "lemma pow_sub\u2080 (a : G\u2080) (ha : a \u2260 0) (h : n \u2264 m) : a ^ (m - n) = a ^ m * (a ^ n)\u207b\u00b9 := by\n  have h1 : m - n + n = m := Nat.sub_add_cancel h\n  have h2 : a ^ (m - n) * a ^ n = a ^ m := by rw [\u2190 pow_add, h1]\n  simpa only [div_eq_mul_inv] using eq_div_of_mul_eq (pow_ne_zero _ ha) h2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "context": {"open": ["Classical in"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MonoidWithZero M\u2080]", "(M\u2080)", "{M\u2080}", "[GroupWithZero G\u2080]", "[GroupWithZero G\u2080] {a b c : G\u2080} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\nm n : \u2115\na : G\u2080\nha : a \u2260 0\nh : n \u2264 m\n\u22a2 a ^ (m - n) = a ^ m * (a ^ n)\u207b\u00b9"}, {"line": "have h1 : m - n + n = m := Nat.sub_add_cancel h", "tactic_state": "G\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\nm n : \u2115\na : G\u2080\nha : a \u2260 0\nh : n \u2264 m\nh1 : m - n + n = m\n\u22a2 a ^ (m - n) = a ^ m * (a ^ n)\u207b\u00b9"}, {"line": "have h2 : a ^ (m - n) * a ^ n = a ^ m := by rw [\u2190 pow_add, h1]", "tactic_state": "G\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\nm n : \u2115\na : G\u2080\nha : a \u2260 0\nh : n \u2264 m\nh1 : m - n + n = m\nh2 : sorry\n\u22a2 a ^ (m - n) = a ^ m * (a ^ n)\u207b\u00b9"}, {"line": "simpa only [div_eq_mul_inv] using eq_div_of_mul_eq (pow_ne_zero _ ha) h2", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_sub_of_lt (a : G\u2080) (h : n < m) : a ^ (m - n) = a ^ m * (a ^ n)\u207b\u00b9 := by\n  obtain rfl | ha := eq_or_ne a 0\n  \u00b7 rw [zero_pow (Nat.ne_of_gt <| Nat.sub_pos_of_lt h), zero_pow (by omega), zero_mul]\n  \u00b7 exact pow_sub\u2080 _ ha <| Nat.le_of_lt h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "context": {"open": ["Classical in"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MonoidWithZero M\u2080]", "(M\u2080)", "{M\u2080}", "[GroupWithZero G\u2080]", "[GroupWithZero G\u2080] {a b c : G\u2080} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\nm n : \u2115\na : G\u2080\nh : n < m\n\u22a2 a ^ (m - n) = a ^ m * (a ^ n)\u207b\u00b9"}, {"line": "obtain rfl | ha := eq_or_ne a 0", "tactic_state": "case inl\nG\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\nm n : \u2115\nh : n < m\n\u22a2 sorry ^ (m - n) = sorry ^ m * (sorry ^ n)\u207b\u00b9\n---\ncase inr\nG\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\nm n : \u2115\na : G\u2080\nh : n < m\nha : a \u2260 sorry\n\u22a2 a ^ (m - n) = a ^ m * (a ^ n)\u207b\u00b9"}, {"line": "\u00b7 rw [zero_pow (Nat.ne_of_gt <| Nat.sub_pos_of_lt h), zero_pow (by omega), zero_mul]", "tactic_state": "case inr\nG\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\nm n : \u2115\na : G\u2080\nh : n < m\nha : a \u2260 sorry\n\u22a2 a ^ (m - n) = a ^ m * (a ^ n)\u207b\u00b9"}, {"line": "\u00b7 exact pow_sub\u2080 _ ha <| Nat.le_of_lt h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zpow_natCast_sub_natCast\u2080 (ha : a \u2260 0) (m n : \u2115) : a ^ (m - n : \u2124) = a ^ m / a ^ n := by\n  simpa using zpow_sub\u2080 ha m n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "context": {"open": ["Classical in"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MonoidWithZero M\u2080]", "(M\u2080)", "{M\u2080}", "[GroupWithZero G\u2080]", "[GroupWithZero G\u2080] {a b c : G\u2080} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nha : a \u2260 0\nm n : \u2115\n\u22a2 a ^ (\u2191m - \u2191n) = a ^ m / a ^ n"}, {"line": "simpa using zpow_sub\u2080 ha m n", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zpow_natCast_sub_one\u2080 (ha : a \u2260 0) (n : \u2115) : a ^ (n - 1 : \u2124) = a ^ n / a := by\n  simpa using zpow_sub\u2080 ha n 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "context": {"open": ["Classical in"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MonoidWithZero M\u2080]", "(M\u2080)", "{M\u2080}", "[GroupWithZero G\u2080]", "[GroupWithZero G\u2080] {a b c : G\u2080} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nha : a \u2260 0\nn : \u2115\n\u22a2 a ^ (\u2191n - 1) = a ^ n / a"}, {"line": "simpa using zpow_sub\u2080 ha n 1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zpow_one_sub_natCast\u2080 (ha : a \u2260 0) (n : \u2115) : a ^ (1 - n : \u2124) = a / a ^ n := by\n  simpa using zpow_sub\u2080 ha 1 n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "context": {"open": ["Classical in"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MonoidWithZero M\u2080]", "(M\u2080)", "{M\u2080}", "[GroupWithZero G\u2080]", "[GroupWithZero G\u2080] {a b c : G\u2080} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nha : a \u2260 0\nn : \u2115\n\u22a2 a ^ (1 - \u2191n) = a / a ^ n"}, {"line": "simpa using zpow_sub\u2080 ha 1 n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ring.inverse_eq_inv (a : G\u2080) : Ring.inverse a = a\u207b\u00b9 := by\n  obtain rfl | ha := eq_or_ne a 0\n  \u00b7 simp\n  \u00b7 exact Ring.inverse_unit (Units.mk0 a ha)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "context": {"open": ["Classical in"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MonoidWithZero M\u2080]", "(M\u2080)", "{M\u2080}", "[GroupWithZero G\u2080]", "[GroupWithZero G\u2080] {a b c : G\u2080} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\n\u22a2 inverse a = a\u207b\u00b9"}, {"line": "obtain rfl | ha := eq_or_ne a 0", "tactic_state": "case inl\nG\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\n\u22a2 inverse sorry = sorry\u207b\u00b9\n---\ncase inr\nG\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nha : a \u2260 sorry\n\u22a2 inverse a = a\u207b\u00b9"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nG\u2080 : Type u_1\ninst\u271d\u00b9 inst\u271d : GroupWithZero G\u2080\na : G\u2080\nha : a \u2260 sorry\n\u22a2 inverse a = a\u207b\u00b9"}, {"line": "\u00b7 exact Ring.inverse_unit (Units.mk0 a ha)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem NatTrans.mapHomologicalComplex_id\n    (c : ComplexShape \u03b9) (F : W\u2081 \u2964 W\u2082) [F.PreservesZeroMorphisms] :\n    NatTrans.mapHomologicalComplex (\ud835\udfd9 F) c = \ud835\udfd9 (F.mapHomologicalComplex c) := by aesop_cat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Additive.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits HomologicalComplex"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [Preadditive V]", "{W : Type*} [Category W] [Preadditive W]", "{W\u2081 W\u2082 : Type*} [Category W\u2081] [Category W\u2082] [HasZeroMorphisms W\u2081] [HasZeroMorphisms W\u2082]", "{c : ComplexShape \u03b9} {C D : HomologicalComplex V c}", "(f : C \u27f6 D) (i : \u03b9)", "(W\u2081)", "{W\u2081}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nW\u2081 : Type u_3\nW\u2082 : Type u_4\ninst\u271d\u2074 : Category.{u_5, u_3} W\u2081\ninst\u271d\u00b3 : Category.{u_6, u_4} W\u2082\ninst\u271d\u00b2 : HasZeroMorphisms W\u2081\ninst\u271d\u00b9 : HasZeroMorphisms W\u2082\nc : ComplexShape \u03b9\nF : CategoryTheory.Functor W\u2081 W\u2082\ninst\u271d : F.PreservesZeroMorphisms\n\u22a2 NatTrans.mapHomologicalComplex (CategoryStruct.id F) c = CategoryStruct.id (F.mapHomologicalComplex c)"}, {"line": "aesop_cat", "tactic_state": "No Goals!"}]}
{"declaration": "theorem NatTrans.mapHomologicalComplex_comp (c : ComplexShape \u03b9) {F G H : W\u2081 \u2964 W\u2082}\n    [F.PreservesZeroMorphisms] [G.PreservesZeroMorphisms] [H.PreservesZeroMorphisms]\n    (\u03b1 : F \u27f6 G) (\u03b2 : G \u27f6 H) :\n    NatTrans.mapHomologicalComplex (\u03b1 \u226b \u03b2) c =\n      NatTrans.mapHomologicalComplex \u03b1 c \u226b NatTrans.mapHomologicalComplex \u03b2 c := by\n  aesop_cat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Additive.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits HomologicalComplex"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [Preadditive V]", "{W : Type*} [Category W] [Preadditive W]", "{W\u2081 W\u2082 : Type*} [Category W\u2081] [Category W\u2082] [HasZeroMorphisms W\u2081] [HasZeroMorphisms W\u2082]", "{c : ComplexShape \u03b9} {C D : HomologicalComplex V c}", "(f : C \u27f6 D) (i : \u03b9)", "(W\u2081)", "{W\u2081}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nW\u2081 : Type u_3\nW\u2082 : Type u_4\ninst\u271d\u2076 : Category.{u_5, u_3} W\u2081\ninst\u271d\u2075 : Category.{u_6, u_4} W\u2082\ninst\u271d\u2074 : HasZeroMorphisms W\u2081\ninst\u271d\u00b3 : HasZeroMorphisms W\u2082\nc : ComplexShape \u03b9\nF G H : CategoryTheory.Functor W\u2081 W\u2082\ninst\u271d\u00b2 : F.PreservesZeroMorphisms\ninst\u271d\u00b9 : G.PreservesZeroMorphisms\ninst\u271d : H.PreservesZeroMorphisms\n\u03b1 : F \u27f6 G\n\u03b2 : G \u27f6 H\n\u22a2 NatTrans.mapHomologicalComplex (CategoryStruct.comp \u03b1 \u03b2) c =\n    CategoryStruct.comp (NatTrans.mapHomologicalComplex \u03b1 c) (NatTrans.mapHomologicalComplex \u03b2 c)"}, {"line": "aesop_cat", "tactic_state": "No Goals!"}]}
{"declaration": "theorem NatTrans.mapHomologicalComplex_naturality {c : ComplexShape \u03b9} {F G : W\u2081 \u2964 W\u2082}\n    [F.PreservesZeroMorphisms] [G.PreservesZeroMorphisms]\n    (\u03b1 : F \u27f6 G) {C D : HomologicalComplex W\u2081 c} (f : C \u27f6 D) :\n    (F.mapHomologicalComplex c).map f \u226b (NatTrans.mapHomologicalComplex \u03b1 c).app D =\n      (NatTrans.mapHomologicalComplex \u03b1 c).app C \u226b (G.mapHomologicalComplex c).map f := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Additive.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits HomologicalComplex"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [Preadditive V]", "{W : Type*} [Category W] [Preadditive W]", "{W\u2081 W\u2082 : Type*} [Category W\u2081] [Category W\u2082] [HasZeroMorphisms W\u2081] [HasZeroMorphisms W\u2082]", "{c : ComplexShape \u03b9} {C D : HomologicalComplex V c}", "(f : C \u27f6 D) (i : \u03b9)", "(W\u2081)", "{W\u2081}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nW\u2081 : Type u_3\nW\u2082 : Type u_4\ninst\u271d\u2075 : Category.{u_5, u_3} W\u2081\ninst\u271d\u2074 : Category.{u_6, u_4} W\u2082\ninst\u271d\u00b3 : HasZeroMorphisms W\u2081\ninst\u271d\u00b2 : HasZeroMorphisms W\u2082\nc : ComplexShape \u03b9\nF G : CategoryTheory.Functor W\u2081 W\u2082\ninst\u271d\u00b9 : F.PreservesZeroMorphisms\ninst\u271d : G.PreservesZeroMorphisms\n\u03b1 : F \u27f6 G\nC D : HomologicalComplex W\u2081 c\nf : C \u27f6 D\n\u22a2 CategoryStruct.comp ((F.mapHomologicalComplex c).map f) ((NatTrans.mapHomologicalComplex \u03b1 c).app D) =\n    CategoryStruct.comp ((NatTrans.mapHomologicalComplex \u03b1 c).app C) ((G.mapHomologicalComplex c).map f)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singleMapHomologicalComplex_hom_app_ne {i j : \u03b9} (h : i \u2260 j) (X : W\u2081) :\n    ((singleMapHomologicalComplex F c j).hom.app X).f i = 0 := by\n  simp [singleMapHomologicalComplex, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Additive.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits HomologicalComplex"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [Preadditive V]", "{W : Type*} [Category W] [Preadditive W]", "{W\u2081 W\u2082 : Type*} [Category W\u2081] [Category W\u2082] [HasZeroMorphisms W\u2081] [HasZeroMorphisms W\u2082]", "{c : ComplexShape \u03b9} {C D : HomologicalComplex V c}", "(f : C \u27f6 D) (i : \u03b9)", "(W\u2081)", "{W\u2081}", "{\u03b1 : Type*} [AddRightCancelSemigroup \u03b1] [One \u03b1] [DecidableEq \u03b1]", "[HasZeroObject W\u2081] [HasZeroObject W\u2082]", "(F : W\u2081 \u2964 W\u2082) [F.PreservesZeroMorphisms]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nW\u2081 : Type u_3\ninst\u271d\u00b2 : Category.{u_6, u_3} W\u2081\ninst\u271d\u00b9 : HasZeroMorphisms W\u2081\ninst\u271d : HasZeroObject W\u2081\ni j : \u03b9\nh : i \u2260 j\nX : W\u2081\n\u22a2 sorry = 0"}, {"line": "simp [singleMapHomologicalComplex, h]", "tactic_state": "\u03b9 : Type u_1\nW\u2081 : Type u_3\ninst\u271d\u00b2 : Category.{u_6, u_3} W\u2081\ninst\u271d\u00b9 : HasZeroMorphisms W\u2081\ninst\u271d : HasZeroObject W\u2081\ni j : \u03b9\nh : i \u2260 j\nX : W\u2081\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem singleMapHomologicalComplex_inv_app_ne {i j : \u03b9} (h : i \u2260 j) (X : W\u2081) :\n    ((singleMapHomologicalComplex F c j).inv.app X).f i = 0 := by\n  simp [singleMapHomologicalComplex, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Additive.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits HomologicalComplex"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [Preadditive V]", "{W : Type*} [Category W] [Preadditive W]", "{W\u2081 W\u2082 : Type*} [Category W\u2081] [Category W\u2082] [HasZeroMorphisms W\u2081] [HasZeroMorphisms W\u2082]", "{c : ComplexShape \u03b9} {C D : HomologicalComplex V c}", "(f : C \u27f6 D) (i : \u03b9)", "(W\u2081)", "{W\u2081}", "{\u03b1 : Type*} [AddRightCancelSemigroup \u03b1] [One \u03b1] [DecidableEq \u03b1]", "[HasZeroObject W\u2081] [HasZeroObject W\u2082]", "(F : W\u2081 \u2964 W\u2082) [F.PreservesZeroMorphisms]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nW\u2081 : Type u_3\ninst\u271d\u00b2 : Category.{u_6, u_3} W\u2081\ninst\u271d\u00b9 : HasZeroMorphisms W\u2081\ninst\u271d : HasZeroObject W\u2081\ni j : \u03b9\nh : i \u2260 j\nX : W\u2081\n\u22a2 sorry = 0"}, {"line": "simp [singleMapHomologicalComplex, h]", "tactic_state": "\u03b9 : Type u_1\nW\u2081 : Type u_3\ninst\u271d\u00b2 : Category.{u_6, u_3} W\u2081\ninst\u271d\u00b9 : HasZeroMorphisms W\u2081\ninst\u271d : HasZeroObject W\u2081\ni j : \u03b9\nh : i \u2260 j\nX : W\u2081\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma \u03b9_D\u2082 :\n    \u03b9 F G\u2082\u2083 K\u2081 K\u2082 K\u2083 c\u2081\u2082 c\u2082\u2083 c\u2084 i\u2081 i\u2082 i\u2083 j h \u226b D\u2082 F G\u2082\u2083 K\u2081 K\u2082 K\u2083 c\u2081\u2082 c\u2082\u2083 c\u2084 j j' =\n      d\u2082 F G\u2082\u2083 K\u2081 K\u2082 K\u2083 c\u2081\u2082 c\u2082\u2083 c\u2084 i\u2081 i\u2082 i\u2083 j' := by\n  simp [D\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/BifunctorAssociator.lean", "context": {"open": ["CategoryTheory Category Limits"], "variables": ["{C\u2081 C\u2082 C\u2081\u2082 C\u2082\u2083 C\u2083 C\u2084 : Type*}", "(F\u2081\u2082 G) in", "(F G\u2082\u2083) in", "[DecidableEq \u03b9\u2081\u2082] [DecidableEq \u03b9\u2082\u2083]", "[DecidableEq \u03b9\u2081\u2082] [HasMapBifunctor (mapBifunctor K\u2081 K\u2082 F\u2081\u2082 c\u2081\u2082) K\u2083 G c\u2084]", "(F\u2081\u2082 G)", "{F\u2081\u2082 G K\u2081 K\u2082 K\u2083 c\u2081\u2082 c\u2084} in", "{K\u2081 K\u2082 K\u2083 c\u2081\u2082 c\u2084}", "[HasGoodTrifunctor\u2081\u2082Obj F\u2081\u2082 G K\u2081 K\u2082 K\u2083 c\u2081\u2082 c\u2084] {j : \u03b9\u2084} {A : C\u2084}", "(F\u2081\u2082 G)", "[HasGoodTrifunctor\u2081\u2082Obj F\u2081\u2082 G K\u2081 K\u2082 K\u2083 c\u2081\u2082 c\u2084]", "(j j' : \u03b9\u2084)", "(i\u2081 : \u03b9\u2081) (i\u2082 : \u03b9\u2082) (i\u2083 : \u03b9\u2083) (j j' : \u03b9\u2084)", "[DecidableEq \u03b9\u2082\u2083] [HasMapBifunctor K\u2081 (mapBifunctor K\u2082 K\u2083 G\u2082\u2083 c\u2082\u2083) F c\u2084]", "(F G\u2082\u2083)", "[HasGoodTrifunctor\u2082\u2083Obj F G\u2082\u2083 K\u2081 K\u2082 K\u2083 c\u2081\u2082 c\u2082\u2083 c\u2084]", "{F G\u2082\u2083 K\u2081 K\u2082 K\u2083 c\u2082\u2083 c\u2084} in", "{F G\u2082\u2083 K\u2081 K\u2082 K\u2083 c\u2082\u2083 c\u2084}", "{j : \u03b9\u2084} {A : C\u2084}", "(F G\u2082\u2083)", "(j j' : \u03b9\u2084)", "[HasGoodTrifunctor\u2082\u2083Obj F G\u2082\u2083 K\u2081 K\u2082 K\u2083 c\u2081\u2082 c\u2082\u2083 c\u2084]", "(i\u2081 : \u03b9\u2081) (i\u2082 : \u03b9\u2082) (i\u2083 : \u03b9\u2083) (j j' : \u03b9\u2084)", "[HasGoodTrifunctor\u2082\u2083Obj F G\u2082\u2083 K\u2081 K\u2082 K\u2083 c\u2081\u2082 c\u2082\u2083 c\u2084]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_7\n\u03b9 : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_8\nD\u2082 : x\u271d\u00b9\nx\u271d : Sort u_9\nd\u2082 : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = sorry"}, {"line": "simp [D\u2082]", "tactic_state": "x\u271d\u00b2 : Sort u_7\n\u03b9 : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_8\nD\u2082 : x\u271d\u00b9\nx\u271d : Sort u_9\nd\u2082 : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "lemma \u03b9MapBifunctor_hom\u2081 (i\u2081 i\u2081' : I\u2081) (i\u2082 : I\u2082) (j j' : J)\n    (h : ComplexShape.\u03c0 c\u2081 c\u2082 c (i\u2081', i\u2082) = j) (h' : c\u2081.prev i\u2081' = i\u2081) :\n    \u03b9MapBifunctor K\u2081 K\u2082 F c i\u2081' i\u2082 j h \u226b hom\u2081 h\u2081 f\u2082 F c j j' = ComplexShape.\u03b5\u2081 c\u2081 c\u2082 c (i\u2081, i\u2082) \u2022\n      (F.map (h\u2081.hom i\u2081' i\u2081)).app (K\u2082.X i\u2082) \u226b (F.obj (L\u2081.X i\u2081)).map (f\u2082.f i\u2082) \u226b\n        \u03b9MapBifunctorOrZero L\u2081 L\u2082 F c _ _ j' := by\n  subst h'\n  simp [hom\u2081]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/BifunctorHomotopy.lean", "context": {"open": ["CategoryTheory Category Limits"], "variables": ["{C\u2081 C\u2082 D I\u2081 I\u2082 J : Type*} [Category C\u2081] [Category C\u2082] [Category D]", "{K\u2081 L\u2081 : HomologicalComplex C\u2081 c\u2081} {f\u2081 f\u2081' : K\u2081 \u27f6 L\u2081} (h\u2081 : Homotopy f\u2081 f\u2081')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I\u2081 : Type u_4\nI\u2082 : Type u_5\nJ : Type u_6\nc\u2081 : ComplexShape I\u2081\nc\u2082 : ComplexShape I\u2082\n\u03b9\u271d : Type u_7\nc : ComplexShape \u03b9\u271d\nx\u271d\u00b2 : Sort u_8\n\u03b9MapBifunctor : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_9\nhom\u2081 : x\u271d\u00b9\nx\u271d : Sort u_10\n\u03b9MapBifunctorOrZero : x\u271d\ni\u2081 i\u2081' : I\u2081\ni\u2082 : I\u2082\nj j' : J\nh : sorry = j\nh' : c\u2081.prev i\u2081' = i\u2081\n\u22a2 CategoryStruct.comp sorry sorry = sorry \u2022 CategoryStruct.comp sorry (CategoryStruct.comp sorry sorry)"}, {"line": "subst h'", "tactic_state": "I\u2081 : Type u_4\nI\u2082 : Type u_5\nJ : Type u_6\nc\u2081 : ComplexShape I\u2081\nc\u2082 : ComplexShape I\u2082\n\u03b9\u271d : Type u_7\nc : ComplexShape \u03b9\u271d\nx\u271d\u00b2 : Sort u_8\n\u03b9MapBifunctor : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_9\nhom\u2081 : x\u271d\u00b9\nx\u271d : Sort u_10\n\u03b9MapBifunctorOrZero : x\u271d\ni\u2081' : I\u2081\ni\u2082 : I\u2082\nj j' : J\nh : sorry = j\n\u22a2 CategoryStruct.comp sorry sorry = sorry \u2022 CategoryStruct.comp sorry (CategoryStruct.comp sorry sorry)"}, {"line": "simp [hom\u2081]", "tactic_state": "I\u2081 : Type u_4\nI\u2082 : Type u_5\nJ : Type u_6\nc\u2081 : ComplexShape I\u2081\nc\u2082 : ComplexShape I\u2082\n\u03b9\u271d : Type u_7\nc : ComplexShape \u03b9\u271d\nx\u271d\u00b2 : Sort u_8\n\u03b9MapBifunctor : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_9\nhom\u2081 : x\u271d\u00b9\nx\u271d : Sort u_10\n\u03b9MapBifunctorOrZero : x\u271d\ni\u2081' : I\u2081\ni\u2082 : I\u2082\nj j' : J\nh : sorry = j\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) =\n    sorry () \u2022 CategoryStruct.comp (sorry ()) (CategoryStruct.comp (sorry ()) (sorry ()))"}]}
{"declaration": "lemma not_rel_of_eq {j' : \u03b9 } (h : j = j') : \u00ac c.Rel j j' := by\n  subst h\n  exact c.not_rel_self j\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HasNoLoop.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*}", "(c : ComplexShape \u03b9) [c.HasNoLoop] (j : \u03b9)", "{j} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nc : ComplexShape \u03b9\ninst\u271d : c.HasNoLoop\nj j' : \u03b9\nh : j = j'\n\u22a2 \u00acc.Rel j j'"}, {"line": "subst h", "tactic_state": "\u03b9 : Type u_1\nc : ComplexShape \u03b9\ninst\u271d : c.HasNoLoop\nj : \u03b9\n\u22a2 \u00acc.Rel j j"}, {"line": "exact c.not_rel_self j", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_distinct_prev_or :\n    (\u2203 (k : \u03b9), c.Rel j k \u2227 j \u2260 k) \u2228 \u2200 (k : \u03b9), \u00ac c.Rel j k := by\n  by_cases h : \u2203 (k : \u03b9), c.Rel j k\n  \u00b7 obtain \u27e8k, hk\u27e9 := h\n    exact Or.inl \u27e8k, hk, fun hjk \u21a6 c.not_rel_of_eq hjk hk\u27e9\n  \u00b7 exact Or.inr (by simpa using h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HasNoLoop.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*}", "(c : ComplexShape \u03b9) [c.HasNoLoop] (j : \u03b9)", "{j} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nc : ComplexShape \u03b9\ninst\u271d : c.HasNoLoop\nj : \u03b9\n\u22a2 (\u2203 k, c.Rel j k \u2227 j \u2260 k) \u2228 \u2200 (k : \u03b9), \u00acc.Rel j k"}, {"line": "by_cases h : \u2203 (k : \u03b9), c.Rel j k", "tactic_state": "case pos\n\u03b9 : Type u_1\nc : ComplexShape \u03b9\ninst\u271d : c.HasNoLoop\nj : \u03b9\nh : \u2203 k, c.Rel j k\n\u22a2 (\u2203 k, c.Rel j k \u2227 j \u2260 k) \u2228 \u2200 (k : \u03b9), \u00acc.Rel j k\n---\ncase neg\n\u03b9 : Type u_1\nc : ComplexShape \u03b9\ninst\u271d : c.HasNoLoop\nj : \u03b9\nh : \u00ac\u2203 k, c.Rel j k\n\u22a2 (\u2203 k, c.Rel j k \u2227 j \u2260 k) \u2228 \u2200 (k : \u03b9), \u00acc.Rel j k"}, {"line": "\u00b7 obtain \u27e8k, hk\u27e9 := h\n    exact Or.inl \u27e8k, hk, fun hjk \u21a6 c.not_rel_of_eq hjk hk\u27e9", "tactic_state": "case neg\n\u03b9 : Type u_1\nc : ComplexShape \u03b9\ninst\u271d : c.HasNoLoop\nj : \u03b9\nh : \u00ac\u2203 k, c.Rel j k\n\u22a2 (\u2203 k, c.Rel j k \u2227 j \u2260 k) \u2228 \u2200 (k : \u03b9), \u00acc.Rel j k"}, {"line": "\u00b7 exact Or.inr (by simpa using h)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_distinct_next_or :\n    (\u2203 (i : \u03b9), c.Rel i j \u2227 i \u2260 j) \u2228 \u2200 (i : \u03b9), \u00ac c.Rel i j := by\n  by_cases h : \u2203 (i : \u03b9), c.Rel i j\n  \u00b7 obtain \u27e8i, hi\u27e9 := h\n    exact Or.inl \u27e8i, hi, fun hij \u21a6 c.not_rel_of_eq hij hi\u27e9\n  \u00b7 exact Or.inr (by simpa using h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HasNoLoop.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*}", "(c : ComplexShape \u03b9) [c.HasNoLoop] (j : \u03b9)", "{j} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nc : ComplexShape \u03b9\ninst\u271d : c.HasNoLoop\nj : \u03b9\n\u22a2 (\u2203 i, c.Rel i j \u2227 i \u2260 j) \u2228 \u2200 (i : \u03b9), \u00acc.Rel i j"}, {"line": "by_cases h : \u2203 (i : \u03b9), c.Rel i j", "tactic_state": "case pos\n\u03b9 : Type u_1\nc : ComplexShape \u03b9\ninst\u271d : c.HasNoLoop\nj : \u03b9\nh : \u2203 i, c.Rel i j\n\u22a2 (\u2203 i, c.Rel i j \u2227 i \u2260 j) \u2228 \u2200 (i : \u03b9), \u00acc.Rel i j\n---\ncase neg\n\u03b9 : Type u_1\nc : ComplexShape \u03b9\ninst\u271d : c.HasNoLoop\nj : \u03b9\nh : \u00ac\u2203 i, c.Rel i j\n\u22a2 (\u2203 i, c.Rel i j \u2227 i \u2260 j) \u2228 \u2200 (i : \u03b9), \u00acc.Rel i j"}, {"line": "\u00b7 obtain \u27e8i, hi\u27e9 := h\n    exact Or.inl \u27e8i, hi, fun hij \u21a6 c.not_rel_of_eq hij hi\u27e9", "tactic_state": "case neg\n\u03b9 : Type u_1\nc : ComplexShape \u03b9\ninst\u271d : c.HasNoLoop\nj : \u03b9\nh : \u00ac\u2203 i, c.Rel i j\n\u22a2 (\u2203 i, c.Rel i j \u2227 i \u2260 j) \u2228 \u2200 (i : \u03b9), \u00acc.Rel i j"}, {"line": "\u00b7 exact Or.inr (by simpa using h)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma shape_f (K : HomologicalComplex\u2082 C c\u2081 c\u2082) (i\u2081 i\u2081' : I\u2081) (h : \u00ac c\u2081.Rel i\u2081 i\u2081') (i\u2082 : I\u2082) :\n    (K.d i\u2081 i\u2081').f i\u2082 = 0 := by\n  rw [K.shape _ _ h]\n  rw [zero_f]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalBicomplex.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex"], "variables": ["(C : Type*) [Category C] [HasZeroMorphisms C]", "{C c\u2081 c\u2082}", "(C c\u2081 c\u2082) in", "(c\u2081 c\u2082)", "(X : GradedObject (I\u2081 \u00d7 I\u2082) C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I\u2081 : Type u_2\nI\u2082 : Type u_3\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : HasZeroMorphisms C\nc\u2081 : ComplexShape I\u2081\nc\u2082 : ComplexShape I\u2082\nK : HomologicalComplex\u2082 C c\u2081 c\u2082\ni\u2081 i\u2081' : I\u2081\nh : \u00acc\u2081.Rel i\u2081 i\u2081'\ni\u2082 : I\u2082\n\u22a2 (K.d i\u2081 i\u2081').f i\u2082 = 0"}, {"line": "rw [K.shape _ _ h]", "tactic_state": "I\u2081 : Type u_2\nI\u2082 : Type u_3\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : HasZeroMorphisms C\nc\u2081 : ComplexShape I\u2081\nc\u2082 : ComplexShape I\u2082\nK : HomologicalComplex\u2082 C c\u2081 c\u2082\ni\u2081 i\u2081' : I\u2081\nh : \u00acc\u2081.Rel i\u2081 i\u2081'\ni\u2082 : I\u2082\n\u22a2 Hom.f 0 i\u2082 = 0"}, {"line": "rw [zero_f]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma d_f_comp_d_f (K : HomologicalComplex\u2082 C c\u2081 c\u2082)\n    (i\u2081 i\u2081' i\u2081'' : I\u2081) (i\u2082 : I\u2082) :\n    (K.d i\u2081 i\u2081').f i\u2082 \u226b (K.d i\u2081' i\u2081'').f i\u2082 = 0 := by\n  rw [\u2190 comp_f]\n  rw [d_comp_d]\n  rw [zero_f]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalBicomplex.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex"], "variables": ["(C : Type*) [Category C] [HasZeroMorphisms C]", "{C c\u2081 c\u2082}", "(C c\u2081 c\u2082) in", "(c\u2081 c\u2082)", "(X : GradedObject (I\u2081 \u00d7 I\u2082) C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I\u2081 : Type u_2\nI\u2082 : Type u_3\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : HasZeroMorphisms C\nc\u2081 : ComplexShape I\u2081\nc\u2082 : ComplexShape I\u2082\nK : HomologicalComplex\u2082 C c\u2081 c\u2082\ni\u2081 i\u2081' i\u2081'' : I\u2081\ni\u2082 : I\u2082\n\u22a2 CategoryStruct.comp ((K.d i\u2081 i\u2081').f i\u2082) ((K.d i\u2081' i\u2081'').f i\u2082) = 0"}, {"line": "rw [\u2190 comp_f]", "tactic_state": "I\u2081 : Type u_2\nI\u2082 : Type u_3\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : HasZeroMorphisms C\nc\u2081 : ComplexShape I\u2081\nc\u2082 : ComplexShape I\u2082\nK : HomologicalComplex\u2082 C c\u2081 c\u2082\ni\u2081 i\u2081' i\u2081'' : I\u2081\ni\u2082 : I\u2082\n\u22a2 (CategoryStruct.comp (K.d i\u2081 i\u2081') (K.d i\u2081' i\u2081'')).f i\u2082 = 0"}, {"line": "rw [d_comp_d]", "tactic_state": "I\u2081 : Type u_2\nI\u2082 : Type u_3\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : HasZeroMorphisms C\nc\u2081 : ComplexShape I\u2081\nc\u2082 : ComplexShape I\u2082\nK : HomologicalComplex\u2082 C c\u2081 c\u2082\ni\u2081 i\u2081' i\u2081'' : I\u2081\ni\u2082 : I\u2082\n\u22a2 Hom.f 0 i\u2082 = 0"}, {"line": "rw [zero_f]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma d_comm (K : HomologicalComplex\u2082 C c\u2081 c\u2082) (i\u2081 i\u2081' : I\u2081) (i\u2082 i\u2082' : I\u2082) :\n    (K.d i\u2081 i\u2081').f i\u2082 \u226b (K.X i\u2081').d i\u2082 i\u2082' = (K.X i\u2081).d i\u2082 i\u2082' \u226b (K.d i\u2081 i\u2081').f i\u2082' := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalBicomplex.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex"], "variables": ["(C : Type*) [Category C] [HasZeroMorphisms C]", "{C c\u2081 c\u2082}", "(C c\u2081 c\u2082) in", "(c\u2081 c\u2082)", "(X : GradedObject (I\u2081 \u00d7 I\u2082) C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I\u2081 : Type u_2\nI\u2082 : Type u_3\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\ninst\u271d : HasZeroMorphisms C\nc\u2081 : ComplexShape I\u2081\nc\u2082 : ComplexShape I\u2082\nK : HomologicalComplex\u2082 C c\u2081 c\u2082\ni\u2081 i\u2081' : I\u2081\ni\u2082 i\u2082' : I\u2082\n\u22a2 CategoryStruct.comp ((K.d i\u2081 i\u2081').f i\u2082) ((K.X i\u2081').d i\u2082 i\u2082') =\n    CategoryStruct.comp ((K.X i\u2081).d i\u2082 i\u2082') ((K.d i\u2081 i\u2081').f i\u2082')"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pOpcycles_opcyclesToCycles_iCycles :\n    K.pOpcycles i \u226b K.opcyclesToCycles i j \u226b K.iCycles j = K.d i j := by\n  simp [opcyclesToCycles]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologySequence.lean", "context": {"open": ["CategoryTheory Category Limits"], "variables": ["{C \u03b9 : Type*} [Category C] [HasZeroMorphisms C] {c : ComplexShape \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 CategoryStruct.comp sorry (CategoryStruct.comp sorry sorry) = sorry"}, {"line": "simp [opcyclesToCycles]", "tactic_state": "\u22a2 CategoryStruct.comp (sorry ()) (CategoryStruct.comp (sorry ()) (sorry ())) = sorry ()"}]}
{"declaration": "theorem imageToKernel_arrow (w : f \u226b g = 0) :\n    imageToKernel f g w \u226b (kernelSubobject g).arrow = (imageSubobject f).arrow := by\n  simp [imageToKernel]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/ImageToKernel.lean", "context": {"open": ["CategoryTheory CategoryTheory.Limits"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [HasZeroMorphisms V]", "{A B C : V} (f : A \u27f6 B) [HasImage f] (g : B \u27f6 C) [HasKernel g]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d\u00b3 : Category.{v, u} V\ninst\u271d\u00b2 : HasZeroMorphisms V\nA B C : V\nf : A \u27f6 B\ninst\u271d\u00b9 : HasImage f\ng : B \u27f6 C\ninst\u271d : HasKernel g\nw : CategoryStruct.comp f g = 0\n\u22a2 CategoryStruct.comp (imageToKernel f g w) (kernelSubobject g).arrow = (imageSubobject f).arrow"}, {"line": "simp [imageToKernel]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma imageToKernel_arrow_apply {FV : V \u2192 V \u2192 Type*} {CV : V \u2192 Type*}\n    [\u2200 X Y, FunLike (FV X Y) (CV X) (CV Y)] [ConcreteCategory V FV] (w : f \u226b g = 0)\n    (x : ToType (Subobject.underlying.obj (imageSubobject f))) :\n    (kernelSubobject g).arrow (imageToKernel f g w x) =\n      (imageSubobject f).arrow x := by\n  rw [\u2190 ConcreteCategory.comp_apply]\n  rw [imageToKernel_arrow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/ImageToKernel.lean", "context": {"open": ["CategoryTheory CategoryTheory.Limits"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [HasZeroMorphisms V]", "{A B C : V} (f : A \u27f6 B) [HasImage f] (g : B \u27f6 C) [HasKernel g]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d\u2075 : Category.{v, u} V\ninst\u271d\u2074 : HasZeroMorphisms V\nA B C : V\nf : A \u27f6 B\ninst\u271d\u00b3 : HasImage f\ng : B \u27f6 C\ninst\u271d\u00b2 : HasKernel g\nFV : V \u2192 V \u2192 Type u_2\nCV : V \u2192 Type u_3\ninst\u271d\u00b9 : (X Y : V) \u2192 FunLike (FV X Y) (CV X) (CV Y)\ninst\u271d : ConcreteCategory V FV\nw : CategoryStruct.comp f g = 0\nx : ToType (Subobject.underlying.obj (imageSubobject f))\n\u22a2 (ConcreteCategory.hom (kernelSubobject g).arrow) ((ConcreteCategory.hom (imageToKernel f g w)) x) =\n    (ConcreteCategory.hom (imageSubobject f).arrow) x"}, {"line": "rw [\u2190 ConcreteCategory.comp_apply]", "tactic_state": "V : Type u\ninst\u271d\u2075 : Category.{v, u} V\ninst\u271d\u2074 : HasZeroMorphisms V\nA B C : V\nf : A \u27f6 B\ninst\u271d\u00b3 : HasImage f\ng : B \u27f6 C\ninst\u271d\u00b2 : HasKernel g\nFV : V \u2192 V \u2192 Type u_2\nCV : V \u2192 Type u_3\ninst\u271d\u00b9 : (X Y : V) \u2192 FunLike (FV X Y) (CV X) (CV Y)\ninst\u271d : ConcreteCategory V FV\nw : CategoryStruct.comp f g = 0\nx : ToType (Subobject.underlying.obj (imageSubobject f))\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp (imageToKernel f g w) (kernelSubobject g).arrow)) x =\n    (ConcreteCategory.hom (imageSubobject f).arrow) x"}, {"line": "rw [imageToKernel_arrow]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isIso_Q_map_iff_mem_quasiIso {K L : HomologicalComplex C c} (f : K \u27f6 L) :\n    IsIso (Q.map f) \u2194 HomologicalComplex.quasiIso C c f := by\n  constructor\n  \u00b7 intro h\n    rw [HomologicalComplex.mem_quasiIso_iff]\n    rw [quasiIso_iff]\n    intro i\n    rw [quasiIsoAt_iff_isIso_homologyMap]\n    refine (NatIso.isIso_map_iff (homologyFunctorFactors C c i) f).1 ?_\n    dsimp\n    infer_instance\n  \u00b7 intro h\n    exact Localization.inverts Q (HomologicalComplex.quasiIso C c) _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Localization.lean", "context": {"open": ["CategoryTheory Limits"], "variables": ["(C : Type*) [Category C] {\u03b9 : Type*} (c : ComplexShape \u03b9) [HasZeroMorphisms C]", "[(HomologicalComplex.quasiIso C c).HasLocalization]", "{C c} in", "{C c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d\u00b9 : Category.{u_3, u_1} C\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\ninst\u271d : HasZeroMorphisms C\nK L : HomologicalComplex C c\nf : K \u27f6 L\n\u22a2 IsIso sorry \u2194 sorry"}, {"line": "constructor", "tactic_state": "case mp\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_3, u_1} C\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\ninst\u271d : HasZeroMorphisms C\nK L : HomologicalComplex C c\nf : K \u27f6 L\n\u22a2 IsIso sorry \u2192 sorry\n---\ncase mpr\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_3, u_1} C\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\ninst\u271d : HasZeroMorphisms C\nK L : HomologicalComplex C c\nf : K \u27f6 L\n\u22a2 sorry \u2192 IsIso sorry"}, {"line": "\u00b7 intro h\n    rw [HomologicalComplex.mem_quasiIso_iff]\n    rw [quasiIso_iff]\n    intro i\n    rw [quasiIsoAt_iff_isIso_homologyMap]\n    refine (NatIso.isIso_map_iff (homologyFunctorFactors C c i) f).1 ?_\n    dsimp\n    infer_instance", "tactic_state": "case mpr\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_3, u_1} C\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\ninst\u271d : HasZeroMorphisms C\nK L : HomologicalComplex C c\nf : K \u27f6 L\n\u22a2 sorry \u2192 IsIso sorry"}, {"line": "\u00b7 intro h\n    exact Localization.inverts Q (HomologicalComplex.quasiIso C c) _ h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mapHomologicalComplex_upToQuasiIso_Q_inverts_quasiIso :\n    (HomologicalComplex.quasiIso C c).IsInvertedBy\n      (F.mapHomologicalComplex c \u22d9 HomologicalComplexUpToQuasiIso.Q) := by\n  apply (F.mapHomologicalComplexUpToQuasiIsoLocalizerMorphism c).inverts\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Localization.lean", "context": {"open": ["CategoryTheory Limits"], "variables": ["(C : Type*) [Category C] {\u03b9 : Type*} (c : ComplexShape \u03b9) [HasZeroMorphisms C]", "[(HomologicalComplex.quasiIso C c).HasLocalization]", "{C c} in", "{C c}", "(C : Type*) [Category C] {\u03b9 : Type*} (c : ComplexShape \u03b9) [Preadditive C]", "{C c}", "(C c)", "{C c}", "[(HomologicalComplex.quasiIso C c).HasLocalization] [c.QFactorsThroughHomotopy C]", "(C c)", "[(HomotopyCategory.quotient C c).IsLocalization", "{\u03b9 : Type*} (c : ComplexShape \u03b9) (hc : \u2200 j, \u2203 i, c.Rel i j)", "(C : Type*) [Category C] {\u03b9 : Type*} [Preadditive C]", "[CategoryWithHomology C]", "(C : Type*) [Category C] {\u03b9 : Type*} [Preadditive C] [HasBinaryBiproducts C]", "[CategoryWithHomology C]", "{C D : Type*} [Category C] [Category D] (F : C \u2964 D)", "[Preadditive C] [Preadditive D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry"}, {"line": "apply (F.mapHomologicalComplexUpToQuasiIsoLocalizerMorphism c).inverts", "tactic_state": "No Goals!"}]}
{"declaration": "lemma unit_tensor_d\u2081 (i\u2081 i\u2082 j : I) :\n    mapBifunctor.d\u2081 (tensorUnit C c) K (curriedTensor C) c i\u2081 i\u2082 j = 0 := by\n  by_cases h\u2081 : c.Rel i\u2081 (c.next i\u2081)\n  \u00b7 by_cases h\u2082 : ComplexShape.\u03c0 c c c (c.next i\u2081, i\u2082) = j\n    \u00b7 rw [mapBifunctor.d\u2081_eq _ _ _ _ h\u2081 _ _ h\u2082, single_obj_d, Functor.map_zero,\n        zero_app, zero_comp, smul_zero]\n    \u00b7 rw [mapBifunctor.d\u2081_eq_zero' _ _ _ _ h\u2081 _ _ h\u2082]\n  \u00b7 rw [mapBifunctor.d\u2081_eq_zero _ _ _ _ _ _ _ h\u2081]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Monoidal.lean", "context": {"open": ["CategoryTheory Limits MonoidalCategory Category"], "variables": ["{C : Type*} [Category C] [MonoidalCategory C] [Preadditive C] [HasZeroObject C]", "[DecidableEq I]", "(C c) in", "(C c) in", "(K : HomologicalComplex C c) [DecidableEq I]", "[\u2200 X\u2082, PreservesColimit (Functor.empty.{0} C) ((curriedTensor C).flip.obj X\u2082)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : Sort u_2\ninst\u271d : DecidableEq I\ni\u2081 i\u2082 j : I\n\u22a2 sorry = 0"}, {"line": "by_cases h\u2081 : c.Rel i\u2081 (c.next i\u2081)", "tactic_state": "case pos\nI : Sort u_2\ninst\u271d : DecidableEq I\ni\u2081 i\u2082 j : I\nh\u2081 : sorry\n\u22a2 sorry = 0\n---\ncase neg\nI : Sort u_2\ninst\u271d : DecidableEq I\ni\u2081 i\u2082 j : I\nh\u2081 : \u00acsorry\n\u22a2 sorry = 0"}, {"line": "\u00b7 by_cases h\u2082 : ComplexShape.\u03c0 c c c (c.next i\u2081, i\u2082) = j\n    \u00b7 rw [mapBifunctor.d\u2081_eq _ _ _ _ h\u2081 _ _ h\u2082, single_obj_d, Functor.map_zero,\n        zero_app, zero_comp, smul_zero]\n    \u00b7 rw [mapBifunctor.d\u2081_eq_zero' _ _ _ _ h\u2081 _ _ h\u2082]", "tactic_state": "case neg\nI : Sort u_2\ninst\u271d : DecidableEq I\ni\u2081 i\u2082 j : I\nh\u2081 : \u00acsorry\n\u22a2 sorry = 0"}, {"line": "\u00b7 rw [mapBifunctor.d\u2081_eq_zero _ _ _ _ _ _ _ h\u2081]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tensor_unit_d\u2082 (i\u2081 i\u2082 j : I) :\n    mapBifunctor.d\u2082 K (tensorUnit C c) (curriedTensor C) c i\u2081 i\u2082 j = 0 := by\n  by_cases h\u2081 : c.Rel i\u2082 (c.next i\u2082)\n  \u00b7 by_cases h\u2082 : ComplexShape.\u03c0 c c c (i\u2081, c.next i\u2082) = j\n    \u00b7 rw [mapBifunctor.d\u2082_eq _ _ _ _ _ h\u2081 _ h\u2082, single_obj_d, Functor.map_zero,\n        zero_comp, smul_zero]\n    \u00b7 rw [mapBifunctor.d\u2082_eq_zero' _ _ _ _ _ h\u2081 _ h\u2082]\n  \u00b7 rw [mapBifunctor.d\u2082_eq_zero _ _ _ _ _ _ _ h\u2081]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Monoidal.lean", "context": {"open": ["CategoryTheory Limits MonoidalCategory Category"], "variables": ["{C : Type*} [Category C] [MonoidalCategory C] [Preadditive C] [HasZeroObject C]", "[DecidableEq I]", "(C c) in", "(C c) in", "(K : HomologicalComplex C c) [DecidableEq I]", "[\u2200 X\u2082, PreservesColimit (Functor.empty.{0} C) ((curriedTensor C).flip.obj X\u2082)]", "[\u2200 X\u2081, PreservesColimit (Functor.empty.{0} C) ((curriedTensor C).obj X\u2081)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : Sort u_2\ninst\u271d : DecidableEq I\ni\u2081 i\u2082 j : I\n\u22a2 sorry = 0"}, {"line": "by_cases h\u2081 : c.Rel i\u2082 (c.next i\u2082)", "tactic_state": "case pos\nI : Sort u_2\ninst\u271d : DecidableEq I\ni\u2081 i\u2082 j : I\nh\u2081 : sorry\n\u22a2 sorry = 0\n---\ncase neg\nI : Sort u_2\ninst\u271d : DecidableEq I\ni\u2081 i\u2082 j : I\nh\u2081 : \u00acsorry\n\u22a2 sorry = 0"}, {"line": "\u00b7 by_cases h\u2082 : ComplexShape.\u03c0 c c c (i\u2081, c.next i\u2082) = j\n    \u00b7 rw [mapBifunctor.d\u2082_eq _ _ _ _ _ h\u2081 _ h\u2082, single_obj_d, Functor.map_zero,\n        zero_comp, smul_zero]\n    \u00b7 rw [mapBifunctor.d\u2082_eq_zero' _ _ _ _ _ h\u2081 _ h\u2082]", "tactic_state": "case neg\nI : Sort u_2\ninst\u271d : DecidableEq I\ni\u2081 i\u2082 j : I\nh\u2081 : \u00acsorry\n\u22a2 sorry = 0"}, {"line": "\u00b7 rw [mapBifunctor.d\u2082_eq_zero _ _ _ _ _ _ _ h\u2081]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma opcyclesOpIso_hom_toCycles_op :\n    (K.opcyclesOpIso i).hom \u226b (K.toCycles j i).op = K.op.fromOpcycles i j := by\n  by_cases hij : c.Rel j i\n  \u00b7 obtain rfl := c.prev_eq' hij\n    exact (K.sc i).opcyclesOpIso_hom_toCycles_op\n  \u00b7 rw [K.toCycles_eq_zero hij, K.op.fromOpcycles_eq_zero hij, op_zero, comp_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Opposite.lean", "context": {"open": ["Opposite CategoryTheory CategoryTheory.Limits"], "variables": ["{V : Type*} [Category V] [Abelian V]", "{\u03b9 V : Type*} [Category V] {c : ComplexShape \u03b9}", "[HasZeroMorphisms V]", "(V c)", "{V c}", "(K : HomologicalComplex V c) (i : \u03b9) [K.HasHomology i]", "(j : \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\nV : Type u_3\ninst\u271d\u00b2 : Category.{u_4, u_3} V\nc : ComplexShape \u03b9\ninst\u271d\u00b9 : HasZeroMorphisms V\nK : HomologicalComplex V c\ni : \u03b9\ninst\u271d : K.HasHomology i\nj : \u03b9\n\u22a2 CategoryStruct.comp (K.opcyclesOpIso i).hom (K.toCycles j i).op = K.op.fromOpcycles i j"}, {"line": "by_cases hij : c.Rel j i", "tactic_state": "case pos\n\u03b9 : Type u_2\nV : Type u_3\ninst\u271d\u00b2 : Category.{u_4, u_3} V\nc : ComplexShape \u03b9\ninst\u271d\u00b9 : HasZeroMorphisms V\nK : HomologicalComplex V c\ni : \u03b9\ninst\u271d : K.HasHomology i\nj : \u03b9\nhij : c.Rel j i\n\u22a2 CategoryStruct.comp (K.opcyclesOpIso i).hom (K.toCycles j i).op = K.op.fromOpcycles i j\n---\ncase neg\n\u03b9 : Type u_2\nV : Type u_3\ninst\u271d\u00b2 : Category.{u_4, u_3} V\nc : ComplexShape \u03b9\ninst\u271d\u00b9 : HasZeroMorphisms V\nK : HomologicalComplex V c\ni : \u03b9\ninst\u271d : K.HasHomology i\nj : \u03b9\nhij : \u00acc.Rel j i\n\u22a2 CategoryStruct.comp (K.opcyclesOpIso i).hom (K.toCycles j i).op = K.op.fromOpcycles i j"}, {"line": "\u00b7 obtain rfl := c.prev_eq' hij\n    exact (K.sc i).opcyclesOpIso_hom_toCycles_op", "tactic_state": "case neg\n\u03b9 : Type u_2\nV : Type u_3\ninst\u271d\u00b2 : Category.{u_4, u_3} V\nc : ComplexShape \u03b9\ninst\u271d\u00b9 : HasZeroMorphisms V\nK : HomologicalComplex V c\ni : \u03b9\ninst\u271d : K.HasHomology i\nj : \u03b9\nhij : \u00acc.Rel j i\n\u22a2 CategoryStruct.comp (K.opcyclesOpIso i).hom (K.toCycles j i).op = K.op.fromOpcycles i j"}, {"line": "\u00b7 rw [K.toCycles_eq_zero hij, K.op.fromOpcycles_eq_zero hij, op_zero, comp_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma fromOpcycles_op_cyclesOpIso_inv :\n    (K.fromOpcycles i j).op \u226b (K.cyclesOpIso i).inv = K.op.toCycles j i := by\n  by_cases hij : c.Rel i j\n  \u00b7 obtain rfl := c.next_eq' hij\n    exact (K.sc i).fromOpcycles_op_cyclesOpIso_inv\n  \u00b7 rw [K.op.toCycles_eq_zero hij, K.fromOpcycles_eq_zero hij, op_zero, zero_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Opposite.lean", "context": {"open": ["Opposite CategoryTheory CategoryTheory.Limits"], "variables": ["{V : Type*} [Category V] [Abelian V]", "{\u03b9 V : Type*} [Category V] {c : ComplexShape \u03b9}", "[HasZeroMorphisms V]", "(V c)", "{V c}", "(K : HomologicalComplex V c) (i : \u03b9) [K.HasHomology i]", "(j : \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\nV : Type u_3\ninst\u271d\u00b2 : Category.{u_4, u_3} V\nc : ComplexShape \u03b9\ninst\u271d\u00b9 : HasZeroMorphisms V\nK : HomologicalComplex V c\ni : \u03b9\ninst\u271d : K.HasHomology i\nj : \u03b9\n\u22a2 CategoryStruct.comp (K.fromOpcycles i j).op (K.cyclesOpIso i).inv = K.op.toCycles j i"}, {"line": "by_cases hij : c.Rel i j", "tactic_state": "case pos\n\u03b9 : Type u_2\nV : Type u_3\ninst\u271d\u00b2 : Category.{u_4, u_3} V\nc : ComplexShape \u03b9\ninst\u271d\u00b9 : HasZeroMorphisms V\nK : HomologicalComplex V c\ni : \u03b9\ninst\u271d : K.HasHomology i\nj : \u03b9\nhij : c.Rel i j\n\u22a2 CategoryStruct.comp (K.fromOpcycles i j).op (K.cyclesOpIso i).inv = K.op.toCycles j i\n---\ncase neg\n\u03b9 : Type u_2\nV : Type u_3\ninst\u271d\u00b2 : Category.{u_4, u_3} V\nc : ComplexShape \u03b9\ninst\u271d\u00b9 : HasZeroMorphisms V\nK : HomologicalComplex V c\ni : \u03b9\ninst\u271d : K.HasHomology i\nj : \u03b9\nhij : \u00acc.Rel i j\n\u22a2 CategoryStruct.comp (K.fromOpcycles i j).op (K.cyclesOpIso i).inv = K.op.toCycles j i"}, {"line": "\u00b7 obtain rfl := c.next_eq' hij\n    exact (K.sc i).fromOpcycles_op_cyclesOpIso_inv", "tactic_state": "case neg\n\u03b9 : Type u_2\nV : Type u_3\ninst\u271d\u00b2 : Category.{u_4, u_3} V\nc : ComplexShape \u03b9\ninst\u271d\u00b9 : HasZeroMorphisms V\nK : HomologicalComplex V c\ni : \u03b9\ninst\u271d : K.HasHomology i\nj : \u03b9\nhij : \u00acc.Rel i j\n\u22a2 CategoryStruct.comp (K.fromOpcycles i j).op (K.cyclesOpIso i).inv = K.op.toCycles j i"}, {"line": "\u00b7 rw [K.op.toCycles_eq_zero hij, K.fromOpcycles_eq_zero hij, op_zero, zero_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_quasiIso_iff (f : K \u27f6 L) : quasiIso C c f \u2194 QuasiIso f := by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/QuasiIso.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex"], "variables": ["{\u03b9 : Type*} {C : Type u} [Category.{v} C] [HasZeroMorphisms C]", "{C\u2081 C\u2082 : Type*} [Category C\u2081] [Category C\u2082] [Preadditive C\u2081] [Preadditive C\u2082]", "(i : \u03b9) [K.HasHomology i] [L.HasHomology i]", "[\u2200 i, K.HasHomology i] [\u2200 i, L.HasHomology i]", "(C c)", "{C c} [CategoryWithHomology C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : HasZeroMorphisms C\nc : ComplexShape ?m.1012\ninst\u271d : CategoryWithHomology C\n\u03b9\u271d : Type u_4\nK L : HomologicalComplex C c\nf : K \u27f6 L\n\u22a2 quasiIso C c f \u2194 QuasiIso f"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_liftCycles_homology\u03c0_up_to_refinements {A : C} {i : \u03b9} (\u03b3 : A \u27f6 K.homology i)\n    (j : \u03b9) (hj : c.next i = j) :\n    \u2203 (A' : C) (\u03c0 : A' \u27f6 A) (_ : Epi \u03c0) (z : A' \u27f6 K.X i) (hz : z \u226b K.d i j = 0),\n      \u03c0 \u226b \u03b3 = K.liftCycles z j hj hz \u226b K.homology\u03c0 i := by\n  subst hj\n  exact (K.sc i).eq_liftCycles_homology\u03c0_up_to_refinements \u03b3\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Refinements.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C \u03b9 : Type*} [Category C] [Abelian C] {c : ComplexShape \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : Category.{u_3, u_1} C\ninst\u271d : Abelian C\nc : ComplexShape \u03b9\nA : C\ni : \u03b9\n\u03b3 : A \u27f6 sorry\nj : \u03b9\nhj : c.next i = j\n\u22a2 \u2203 A' \u03c0,\n    \u2203 (x : Epi \u03c0),\n      \u2203 z, \u2203 (hz : CategoryStruct.comp z sorry = 0), CategoryStruct.comp \u03c0 \u03b3 = CategoryStruct.comp sorry sorry"}, {"line": "subst hj", "tactic_state": "C : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : Category.{u_3, u_1} C\ninst\u271d : Abelian C\nc : ComplexShape \u03b9\nA : C\ni : \u03b9\n\u03b3 : A \u27f6 sorry\n\u22a2 \u2203 A' \u03c0,\n    \u2203 (x : Epi \u03c0),\n      \u2203 z, \u2203 (hz : CategoryStruct.comp z sorry = 0), CategoryStruct.comp \u03c0 \u03b3 = CategoryStruct.comp sorry sorry"}, {"line": "exact (K.sc i).eq_liftCycles_homology\u03c0_up_to_refinements \u03b3", "tactic_state": "No Goals!"}]}
{"declaration": "lemma singleObjCyclesSelfIso_inv_iCycles :\n    (singleObjCyclesSelfIso _ _ _).inv \u226b ((single C c j).obj A).iCycles j =\n      (singleObjXSelf c j A).inv := by\n  simp [singleObjCyclesSelfIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/SingleHomology.lean", "context": {"open": ["CategoryTheory Category Limits ZeroObject"], "variables": ["{C : Type u} [Category.{v} C] [HasZeroMorphisms C] [HasZeroObject C]", "(A : C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_1\nsingleObjCyclesSelfIso : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nsingle : x\u271d\u00b9\nx\u271d : Sort u_3\nsingleObjXSelf : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = sorry"}, {"line": "simp [singleObjCyclesSelfIso]", "tactic_state": "x\u271d\u00b2 : Sort u_1\nsingleObjCyclesSelfIso : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nsingle : x\u271d\u00b9\nx\u271d : Sort u_3\nsingleObjXSelf : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "lemma homology\u03c0_singleObjHomologySelfIso_hom :\n    ((single C c j).obj A).homology\u03c0 j \u226b (singleObjHomologySelfIso _ _ _).hom =\n      (singleObjCyclesSelfIso _ _ _).hom := by\n  simp [singleObjCyclesSelfIso, singleObjHomologySelfIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/SingleHomology.lean", "context": {"open": ["CategoryTheory Category Limits ZeroObject"], "variables": ["{C : Type u} [Category.{v} C] [HasZeroMorphisms C] [HasZeroObject C]", "(A : C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_1\nsingle : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nsingleObjHomologySelfIso : x\u271d\u00b9\nx\u271d : Sort u_3\nsingleObjCyclesSelfIso : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = sorry"}, {"line": "simp [singleObjCyclesSelfIso, singleObjHomologySelfIso]", "tactic_state": "x\u271d\u00b2 : Sort u_1\nsingle : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nsingleObjHomologySelfIso : x\u271d\u00b9\nx\u271d : Sort u_3\nsingleObjCyclesSelfIso : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "lemma singleObjCyclesSelfIso_hom_singleObjOpcyclesSelfIso_hom :\n    (singleObjCyclesSelfIso c j A).hom \u226b (singleObjOpcyclesSelfIso c j A).hom =\n      ((single C c j).obj A).iCycles j \u226b ((single C c j).obj A).pOpcycles j := by\n  simp [singleObjCyclesSelfIso, singleObjOpcyclesSelfIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/SingleHomology.lean", "context": {"open": ["CategoryTheory Category Limits ZeroObject"], "variables": ["{C : Type u} [Category.{v} C] [HasZeroMorphisms C] [HasZeroObject C]", "(A : C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_1\nsingleObjCyclesSelfIso : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nsingleObjOpcyclesSelfIso : x\u271d\u00b9\nx\u271d : Sort u_3\nsingle : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.comp sorry sorry"}, {"line": "simp [singleObjCyclesSelfIso, singleObjOpcyclesSelfIso]", "tactic_state": "x\u271d\u00b2 : Sort u_1\nsingleObjCyclesSelfIso : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nsingleObjOpcyclesSelfIso : x\u271d\u00b9\nx\u271d : Sort u_3\nsingle : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.comp (sorry ()) (sorry ())"}]}
{"declaration": "lemma singleObjCyclesSelfIso_inv_homology\u03c0  :\n    (singleObjCyclesSelfIso _ _ _).inv \u226b ((single C c j).obj A).homology\u03c0 j =\n      (singleObjHomologySelfIso _ _ _).inv := by\n  simp [singleObjCyclesSelfIso, singleObjHomologySelfIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/SingleHomology.lean", "context": {"open": ["CategoryTheory Category Limits ZeroObject"], "variables": ["{C : Type u} [Category.{v} C] [HasZeroMorphisms C] [HasZeroObject C]", "(A : C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_1\nsingleObjCyclesSelfIso : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nsingle : x\u271d\u00b9\nx\u271d : Sort u_3\nsingleObjHomologySelfIso : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = sorry"}, {"line": "simp [singleObjCyclesSelfIso, singleObjHomologySelfIso]", "tactic_state": "x\u271d\u00b2 : Sort u_1\nsingleObjCyclesSelfIso : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nsingle : x\u271d\u00b9\nx\u271d : Sort u_3\nsingleObjHomologySelfIso : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "lemma \u03b9Total_totalFlipIso_f_hom\n    (i\u2081 : I\u2081) (i\u2082 : I\u2082) (j : J) (h : ComplexShape.\u03c0 c\u2082 c\u2081 c (i\u2082, i\u2081) = j) :\n    K.flip.\u03b9Total c i\u2082 i\u2081 j h \u226b (K.totalFlipIso c).hom.f j =\n      ComplexShape.\u03c3 c\u2081 c\u2082 c i\u2081 i\u2082 \u2022 K.\u03b9Total c i\u2081 i\u2082 j\n        (by rw [\u2190 ComplexShape.\u03c0_symm c\u2081 c\u2082 c i\u2081 i\u2082, h]) := by\n  simp [totalFlipIso, totalFlipIsoX]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/TotalComplexSymmetry.lean", "context": {"open": ["CategoryTheory Category Limits"], "variables": ["{C I\u2081 I\u2082 J : Type*} [Category C] [Preadditive C]", "[K.HasTotal c] [DecidableEq J]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I\u2081 : Type u_2\nI\u2082 : Type u_3\nJ : Type u_4\nc\u2082 : ComplexShape I\u2082\nc\u2081 : ComplexShape I\u2081\n\u03b9\u271d : Type u_5\nc : ComplexShape \u03b9\u271d\ni\u2081 : I\u2081\ni\u2082 : I\u2082\nj : J\nh : sorry = j\n\u22a2 CategoryStruct.comp sorry sorry = sorry \u2022 sorry"}, {"line": "simp [totalFlipIso, totalFlipIsoX]", "tactic_state": "I\u2081 : Type u_2\nI\u2082 : Type u_3\nJ : Type u_4\nc\u2082 : ComplexShape I\u2082\nc\u2081 : ComplexShape I\u2081\n\u03b9\u271d : Type u_5\nc : ComplexShape \u03b9\u271d\ni\u2081 : I\u2081\ni\u2082 : I\u2082\nj : J\nh : sorry = j\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry () \u2022 sorry ()"}]}
{"declaration": "lemma \u03b9Total_totalFlipIso_f_inv\n    (i\u2081 : I\u2081) (i\u2082 : I\u2082) (j : J) (h : ComplexShape.\u03c0 c\u2081 c\u2082 c (i\u2081, i\u2082) = j) :\n    K.\u03b9Total c i\u2081 i\u2082 j h \u226b (K.totalFlipIso c).inv.f j =\n      ComplexShape.\u03c3 c\u2081 c\u2082 c i\u2081 i\u2082 \u2022 K.flip.\u03b9Total c i\u2082 i\u2081 j\n        (by rw [ComplexShape.\u03c0_symm c\u2081 c\u2082 c i\u2081 i\u2082, h]) := by\n  simp [totalFlipIso, totalFlipIsoX]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/TotalComplexSymmetry.lean", "context": {"open": ["CategoryTheory Category Limits"], "variables": ["{C I\u2081 I\u2082 J : Type*} [Category C] [Preadditive C]", "[K.HasTotal c] [DecidableEq J]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I\u2081 : Type u_2\nI\u2082 : Type u_3\nJ : Type u_4\nc\u2081 : ComplexShape I\u2081\nc\u2082 : ComplexShape I\u2082\n\u03b9\u271d : Type u_5\nc : ComplexShape \u03b9\u271d\ni\u2081 : I\u2081\ni\u2082 : I\u2082\nj : J\nh : sorry = j\n\u22a2 CategoryStruct.comp sorry sorry = sorry \u2022 sorry"}, {"line": "simp [totalFlipIso, totalFlipIsoX]", "tactic_state": "I\u2081 : Type u_2\nI\u2082 : Type u_3\nJ : Type u_4\nc\u2081 : ComplexShape I\u2081\nc\u2082 : ComplexShape I\u2082\n\u03b9\u271d : Type u_5\nc : ComplexShape \u03b9\u271d\ni\u2081 : I\u2081\ni\u2082 : I\u2082\nj : J\nh : sorry = j\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry () \u2022 sorry ()"}]}
{"declaration": "theorem d_comp_d (C : HomologicalComplex V c) (i j k : \u03b9) : C.d i j \u226b C.d j k = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 by_cases hjk : c.Rel j k\n    \u00b7 exact C.d_comp_d' i j k hij hjk\n    \u00b7 rw [C.shape j k hjk, comp_zero]\n  \u00b7 rw [C.shape i j hij, zero_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalComplex.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{\u03b9 : Type*}", "(V : Type u) [Category.{v} V] [HasZeroMorphisms V]", "{V} {c : ComplexShape \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\ni j k : \u03b9\n\u22a2 CategoryStruct.comp (C.d i j) (C.d j k) = 0"}, {"line": "by_cases hij : c.Rel i j", "tactic_state": "case pos\n\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\ni j k : \u03b9\nhij : c.Rel i j\n\u22a2 CategoryStruct.comp (C.d i j) (C.d j k) = 0\n---\ncase neg\n\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\ni j k : \u03b9\nhij : \u00acc.Rel i j\n\u22a2 CategoryStruct.comp (C.d i j) (C.d j k) = 0"}, {"line": "\u00b7 by_cases hjk : c.Rel j k\n    \u00b7 exact C.d_comp_d' i j k hij hjk\n    \u00b7 rw [C.shape j k hjk, comp_zero]", "tactic_state": "case neg\n\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\ni j k : \u03b9\nhij : \u00acc.Rel i j\n\u22a2 CategoryStruct.comp (C.d i j) (C.d j k) = 0"}, {"line": "\u00b7 rw [C.shape i j hij, zero_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem next_nat_zero : (ComplexShape.down \u2115).next 0 = 0 := by\n  classical\n    refine dif_neg ?_\n    push_neg\n    intro\n    apply Nat.noConfusion\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalComplex.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{\u03b9 : Type*}", "(V : Type u) [Category.{v} V] [HasZeroMorphisms V]", "{V} {c : ComplexShape \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (ComplexShape.down \u2115).next 0 = 0"}, {"line": "classical\n    refine dif_neg ?_\n    push_neg\n    intro\n    apply Nat.noConfusion", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prev_nat_zero : (ComplexShape.up \u2115).prev 0 = 0 := by\n  classical\n    refine dif_neg ?_\n    push_neg\n    intro\n    apply Nat.noConfusion\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalComplex.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{\u03b9 : Type*}", "(V : Type u) [Category.{v} V] [HasZeroMorphisms V]", "{V} {c : ComplexShape \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (ComplexShape.up \u2115).prev 0 = 0"}, {"line": "classical\n    refine dif_neg ?_\n    push_neg\n    intro\n    apply Nat.noConfusion", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Hom.comm {A B : HomologicalComplex V c} (f : A.Hom B) (i j : \u03b9) :\n    f.f i \u226b B.d i j = A.d i j \u226b f.f j := by\n  by_cases hij : c.Rel i j\n  \u00b7 exact f.comm' i j hij\n  \u00b7 rw [A.shape i j hij, B.shape i j hij, comp_zero, zero_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalComplex.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{\u03b9 : Type*}", "(V : Type u) [Category.{v} V] [HasZeroMorphisms V]", "{V} {c : ComplexShape \u03b9}", "{V}", "{c : ComplexShape \u03b9} (C : HomologicalComplex V c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nA B : HomologicalComplex V c\nf : A.Hom B\ni j : \u03b9\n\u22a2 CategoryStruct.comp (f.f i) (B.d i j) = CategoryStruct.comp (A.d i j) (f.f j)"}, {"line": "by_cases hij : c.Rel i j", "tactic_state": "case pos\n\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nA B : HomologicalComplex V c\nf : A.Hom B\ni j : \u03b9\nhij : c.Rel i j\n\u22a2 CategoryStruct.comp (f.f i) (B.d i j) = CategoryStruct.comp (A.d i j) (f.f j)\n---\ncase neg\n\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nA B : HomologicalComplex V c\nf : A.Hom B\ni j : \u03b9\nhij : \u00acc.Rel i j\n\u22a2 CategoryStruct.comp (f.f i) (B.d i j) = CategoryStruct.comp (A.d i j) (f.f j)"}, {"line": "\u00b7 exact f.comm' i j hij", "tactic_state": "case neg\n\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nA B : HomologicalComplex V c\nf : A.Hom B\ni j : \u03b9\nhij : \u00acc.Rel i j\n\u22a2 CategoryStruct.comp (f.f i) (B.d i j) = CategoryStruct.comp (A.d i j) (f.f j)"}, {"line": "\u00b7 rw [A.shape i j hij, B.shape i j hij, comp_zero, zero_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eqToHom_f {C\u2081 C\u2082 : HomologicalComplex V c} (h : C\u2081 = C\u2082) (n : \u03b9) :\n    HomologicalComplex.Hom.f (eqToHom h) n =\n      eqToHom (congr_fun (congr_arg HomologicalComplex.X h) n) := by\n  subst h\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalComplex.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits"], "variables": ["{\u03b9 : Type*}", "(V : Type u) [Category.{v} V] [HasZeroMorphisms V]", "{V} {c : ComplexShape \u03b9}", "{V}", "{c : ComplexShape \u03b9} (C : HomologicalComplex V c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC\u2081 C\u2082 : HomologicalComplex V c\nh : C\u2081 = C\u2082\nn : \u03b9\n\u22a2 (eqToHom h).f n = eqToHom \u22ef"}, {"line": "subst h", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC\u2081 : HomologicalComplex V c\nn : \u03b9\n\u22a2 (eqToHom \u22ef).f n = eqToHom \u22ef"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem d_comp_eqToHom {i j j' : \u03b9} (rij : c.Rel i j) (rij' : c.Rel i j') :\n    C.d i j' \u226b eqToHom (congr_arg C.X (c.next_eq rij' rij)) = C.d i j := by\n  obtain rfl := c.next_eq rij rij'\n  simp only [eqToHom_refl]\n  simp only [comp_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalComplex.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits", "ZeroObject"], "variables": ["{\u03b9 : Type*}", "(V : Type u) [Category.{v} V] [HasZeroMorphisms V]", "{V} {c : ComplexShape \u03b9}", "{V}", "{c : ComplexShape \u03b9} (C : HomologicalComplex V c)", "(V c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\ni j j' : \u03b9\nrij : c.Rel i j\nrij' : c.Rel i j'\n\u22a2 CategoryStruct.comp (C.d i j') (eqToHom \u22ef) = C.d i j"}, {"line": "obtain rfl := c.next_eq rij rij'", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\ni j : \u03b9\nrij rij' : c.Rel i j\n\u22a2 CategoryStruct.comp (C.d i j) (eqToHom \u22ef) = C.d i j"}, {"line": "simp only [eqToHom_refl]", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\ni j : \u03b9\nrij rij' : c.Rel i j\n\u22a2 CategoryStruct.comp (C.d i j) (CategoryStruct.id (C.X j)) = C.d i j"}, {"line": "simp only [comp_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eqToHom_comp_d {i i' j : \u03b9} (rij : c.Rel i j) (rij' : c.Rel i' j) :\n    eqToHom (congr_arg C.X (c.prev_eq rij rij')) \u226b C.d i' j = C.d i j := by\n  obtain rfl := c.prev_eq rij rij'\n  simp only [eqToHom_refl]\n  simp only [id_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalComplex.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits", "ZeroObject"], "variables": ["{\u03b9 : Type*}", "(V : Type u) [Category.{v} V] [HasZeroMorphisms V]", "{V} {c : ComplexShape \u03b9}", "{V}", "{c : ComplexShape \u03b9} (C : HomologicalComplex V c)", "(V c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\ni i' j : \u03b9\nrij : c.Rel i j\nrij' : c.Rel i' j\n\u22a2 CategoryStruct.comp (eqToHom \u22ef) (C.d i' j) = C.d i j"}, {"line": "obtain rfl := c.prev_eq rij rij'", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\ni j : \u03b9\nrij rij' : c.Rel i j\n\u22a2 CategoryStruct.comp (eqToHom \u22ef) (C.d i j) = C.d i j"}, {"line": "simp only [eqToHom_refl]", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\ni j : \u03b9\nrij rij' : c.Rel i j\n\u22a2 CategoryStruct.comp (CategoryStruct.id (C.X i)) (C.d i j) = C.d i j"}, {"line": "simp only [id_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dTo_eq {i j : \u03b9} (r : c.Rel i j) : C.dTo j = (C.xPrevIso r).hom \u226b C.d i j := by\n  obtain rfl := c.prev_eq' r\n  exact (Category.id_comp _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalComplex.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits", "ZeroObject"], "variables": ["{\u03b9 : Type*}", "(V : Type u) [Category.{v} V] [HasZeroMorphisms V]", "{V} {c : ComplexShape \u03b9}", "{V}", "{c : ComplexShape \u03b9} (C : HomologicalComplex V c)", "(V c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\ni j : \u03b9\nr : c.Rel i j\n\u22a2 C.dTo j = CategoryStruct.comp (C.xPrevIso r).hom (C.d i j)"}, {"line": "obtain rfl := c.prev_eq' r", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\nj : \u03b9\nr : c.Rel (c.prev j) j\n\u22a2 C.dTo j = CategoryStruct.comp (C.xPrevIso r).hom (C.d (c.prev j) j)"}, {"line": "exact (Category.id_comp _).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dFrom_eq {i j : \u03b9} (r : c.Rel i j) : C.dFrom i = C.d i j \u226b (C.xNextIso r).inv := by\n  obtain rfl := c.next_eq' r\n  exact (Category.comp_id _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalComplex.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits", "ZeroObject"], "variables": ["{\u03b9 : Type*}", "(V : Type u) [Category.{v} V] [HasZeroMorphisms V]", "{V} {c : ComplexShape \u03b9}", "{V}", "{c : ComplexShape \u03b9} (C : HomologicalComplex V c)", "(V c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\ni j : \u03b9\nr : c.Rel i j\n\u22a2 C.dFrom i = CategoryStruct.comp (C.d i j) (C.xNextIso r).inv"}, {"line": "obtain rfl := c.next_eq' r", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\ni : \u03b9\nr : c.Rel i (c.next i)\n\u22a2 C.dFrom i = CategoryStruct.comp (C.d i (c.next i)) (C.xNextIso r).inv"}, {"line": "exact (Category.comp_id _).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem xPrevIso_comp_dTo {i j : \u03b9} (r : c.Rel i j) : (C.xPrevIso r).inv \u226b C.dTo j = C.d i j := by\n  simp [C.dTo_eq r]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalComplex.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits", "ZeroObject"], "variables": ["{\u03b9 : Type*}", "(V : Type u) [Category.{v} V] [HasZeroMorphisms V]", "{V} {c : ComplexShape \u03b9}", "{V}", "{c : ComplexShape \u03b9} (C : HomologicalComplex V c)", "(V c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\ni j : \u03b9\nr : c.Rel i j\n\u22a2 CategoryStruct.comp (C.xPrevIso r).inv (C.dTo j) = C.d i j"}, {"line": "simp [C.dTo_eq r]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem xPrevIsoSelf_comp_dTo {j : \u03b9} (h : \u00acc.Rel (c.prev j) j) :\n    (C.xPrevIsoSelf h).inv \u226b C.dTo j = 0 := by simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalComplex.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits", "ZeroObject"], "variables": ["{\u03b9 : Type*}", "(V : Type u) [Category.{v} V] [HasZeroMorphisms V]", "{V} {c : ComplexShape \u03b9}", "{V}", "{c : ComplexShape \u03b9} (C : HomologicalComplex V c)", "(V c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\nj : \u03b9\nh : \u00acc.Rel (c.prev j) j\n\u22a2 CategoryStruct.comp (C.xPrevIsoSelf h).inv (C.dTo j) = 0"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dFrom_comp_xNextIso {i j : \u03b9} (r : c.Rel i j) :\n    C.dFrom i \u226b (C.xNextIso r).hom = C.d i j := by\n  simp [C.dFrom_eq r]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalComplex.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits", "ZeroObject"], "variables": ["{\u03b9 : Type*}", "(V : Type u) [Category.{v} V] [HasZeroMorphisms V]", "{V} {c : ComplexShape \u03b9}", "{V}", "{c : ComplexShape \u03b9} (C : HomologicalComplex V c)", "(V c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\ni j : \u03b9\nr : c.Rel i j\n\u22a2 CategoryStruct.comp (C.dFrom i) (C.xNextIso r).hom = C.d i j"}, {"line": "simp [C.dFrom_eq r]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dFrom_comp_xNextIsoSelf {i : \u03b9} (h : \u00acc.Rel i (c.next i)) :\n    C.dFrom i \u226b (C.xNextIsoSelf h).hom = 0 := by simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalComplex.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits", "ZeroObject"], "variables": ["{\u03b9 : Type*}", "(V : Type u) [Category.{v} V] [HasZeroMorphisms V]", "{V} {c : ComplexShape \u03b9}", "{V}", "{c : ComplexShape \u03b9} (C : HomologicalComplex V c)", "(V c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\ni : \u03b9\nh : \u00acc.Rel i (c.next i)\n\u22a2 CategoryStruct.comp (C.dFrom i) (C.xNextIsoSelf h).hom = 0"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mkHom_f_succ_succ (n : \u2115) :\n    (mkHom P Q zero one one_zero_comm succ).f (n + 2) =\n      (succ n\n          \u27e8(mkHom P Q zero one one_zero_comm succ).f n,\n            (mkHom P Q zero one one_zero_comm succ).f (n + 1),\n            (mkHom P Q zero one one_zero_comm succ).comm (n + 1) n\u27e9).1 := by\n  dsimp [mkHom, mkHomAux]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalComplex.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits", "ZeroObject"], "variables": ["{\u03b9 : Type*}", "(V : Type u) [Category.{v} V] [HasZeroMorphisms V]", "{V} {c : ComplexShape \u03b9}", "{V}", "{c : ComplexShape \u03b9} (C : HomologicalComplex V c)", "(V c)", "{C\u2081 C\u2082 C\u2083 : HomologicalComplex V c}", "{V} {\u03b1 : Type*} [AddRightCancelSemigroup \u03b1] [One \u03b1] [DecidableEq \u03b1]", "(X : \u03b1 \u2192 V) (d : \u2200 n, X (n + 1) \u27f6 X n) (sq : \u2200 n, d (n + 1) \u226b d n = 0)", "{V} {\u03b1 : Type*} [AddRightCancelSemigroup \u03b1] [One \u03b1] [DecidableEq \u03b1]", "(X : \u03b1 \u2192 V) (d_X : \u2200 n, X (n + 1) \u27f6 X n) (sq_X : \u2200 n, d_X (n + 1) \u226b d_X n = 0) (Y : \u03b1 \u2192 V)", "{V}", "(X\u2080 X\u2081 X\u2082 : V) (d\u2080 : X\u2081 \u27f6 X\u2080) (d\u2081 : X\u2082 \u27f6 X\u2081) (s : d\u2081 \u226b d\u2080 = 0)", "(succ' : \u2200 {X\u2080 X\u2081 : V} (f : X\u2081 \u27f6 X\u2080), \u03a3' (X\u2082 : V) (d : X\u2082 \u27f6 X\u2081), d \u226b f = 0)", "{V}", "(P Q : ChainComplex V \u2115) (zero : P.X 0 \u27f6 Q.X 0) (one : P.X 1 \u27f6 Q.X 1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_3\nmkHom : x\u271d\u00b9\nx\u271d : Sort u_4\nsucc : x\u271d\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "dsimp [mkHom, mkHomAux]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mkHom_f_succ_succ (n : \u2115) :\n    (mkHom P Q zero one one_zero_comm succ).f (n + 2) =\n      (succ n\n          \u27e8(mkHom P Q zero one one_zero_comm succ).f n,\n            (mkHom P Q zero one one_zero_comm succ).f (n + 1),\n            (mkHom P Q zero one one_zero_comm succ).comm n (n + 1)\u27e9).1 := by\n  dsimp [mkHom, mkHomAux]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomologicalComplex.lean", "context": {"open": ["CategoryTheory CategoryTheory.Category CategoryTheory.Limits", "ZeroObject"], "variables": ["{\u03b9 : Type*}", "(V : Type u) [Category.{v} V] [HasZeroMorphisms V]", "{V} {c : ComplexShape \u03b9}", "{V}", "{c : ComplexShape \u03b9} (C : HomologicalComplex V c)", "(V c)", "{C\u2081 C\u2082 C\u2083 : HomologicalComplex V c}", "{V} {\u03b1 : Type*} [AddRightCancelSemigroup \u03b1] [One \u03b1] [DecidableEq \u03b1]", "(X : \u03b1 \u2192 V) (d : \u2200 n, X (n + 1) \u27f6 X n) (sq : \u2200 n, d (n + 1) \u226b d n = 0)", "{V} {\u03b1 : Type*} [AddRightCancelSemigroup \u03b1] [One \u03b1] [DecidableEq \u03b1]", "(X : \u03b1 \u2192 V) (d_X : \u2200 n, X (n + 1) \u27f6 X n) (sq_X : \u2200 n, d_X (n + 1) \u226b d_X n = 0) (Y : \u03b1 \u2192 V)", "{V}", "(X\u2080 X\u2081 X\u2082 : V) (d\u2080 : X\u2081 \u27f6 X\u2080) (d\u2081 : X\u2082 \u27f6 X\u2081) (s : d\u2081 \u226b d\u2080 = 0)", "(succ' : \u2200 {X\u2080 X\u2081 : V} (f : X\u2081 \u27f6 X\u2080), \u03a3' (X\u2082 : V) (d : X\u2082 \u27f6 X\u2081), d \u226b f = 0)", "{V}", "(P Q : ChainComplex V \u2115) (zero : P.X 0 \u27f6 Q.X 0) (one : P.X 1 \u27f6 Q.X 1)", "{V} {\u03b1 : Type*} [AddRightCancelSemigroup \u03b1] [One \u03b1] [DecidableEq \u03b1]", "(X : \u03b1 \u2192 V) (d : \u2200 n, X n \u27f6 X (n + 1)) (sq : \u2200 n, d n \u226b d (n + 1) = 0)", "{V} {\u03b1 : Type*} [AddRightCancelSemigroup \u03b1] [One \u03b1] [DecidableEq \u03b1]", "(X : \u03b1 \u2192 V) (d_X : \u2200 n, X n \u27f6 X (n + 1)) (sq_X : \u2200 n, d_X n \u226b d_X (n + 1) = 0) (Y : \u03b1 \u2192 V)", "{V}", "(X\u2080 X\u2081 X\u2082 : V) (d\u2080 : X\u2080 \u27f6 X\u2081) (d\u2081 : X\u2081 \u27f6 X\u2082) (s : d\u2080 \u226b d\u2081 = 0)", "(succ' : \u2200 {X\u2080 X\u2081 : V} (f : X\u2080 \u27f6 X\u2081), \u03a3' (X\u2082 : V) (d : X\u2081 \u27f6 X\u2082), f \u226b d = 0)", "{V}", "(P Q : CochainComplex V \u2115) (zero : P.X 0 \u27f6 Q.X 0) (one : P.X 1 \u27f6 Q.X 1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_3\nmkHom : x\u271d\u00b9\nx\u271d : Sort u_4\nsucc : x\u271d\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "dsimp [mkHom, mkHomAux]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dNext_eq (f : \u2200 i j, C.X i \u27f6 D.X j) {i i' : \u03b9} (w : c.Rel i i') :\n    dNext i f = C.d i i' \u226b f i' i := by\n  obtain rfl := c.next_eq' w\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Homotopy.lean", "context": {"open": ["CategoryTheory Category Limits HomologicalComplex"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [Preadditive V]", "{c : ComplexShape \u03b9} {C D E : HomologicalComplex V c}", "(f g : C \u27f6 D) (h k : D \u27f6 E) (i : \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nc : ComplexShape \u03b9\nC D : HomologicalComplex V c\nf : (i j : \u03b9) \u2192 C.X i \u27f6 D.X j\ni i' : \u03b9\nw : c.Rel i i'\n\u22a2 (dNext i) f = CategoryStruct.comp (C.d i i') (f i' i)"}, {"line": "obtain rfl := c.next_eq' w", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nc : ComplexShape \u03b9\nC D : HomologicalComplex V c\nf : (i j : \u03b9) \u2192 C.X i \u27f6 D.X j\ni : \u03b9\nw : c.Rel i (c.next i)\n\u22a2 (dNext i) f = CategoryStruct.comp (C.d i (c.next i)) (f (c.next i) i)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dNext_eq_zero (f : \u2200 i j, C.X i \u27f6 D.X j) (i : \u03b9) (hi : \u00ac c.Rel i (c.next i)) :\n    dNext i f = 0 := by\n  dsimp [dNext]\n  rw [shape _ _ _ hi]\n  rw [zero_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Homotopy.lean", "context": {"open": ["CategoryTheory Category Limits HomologicalComplex"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [Preadditive V]", "{c : ComplexShape \u03b9} {C D E : HomologicalComplex V c}", "(f g : C \u27f6 D) (h k : D \u27f6 E) (i : \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nc : ComplexShape \u03b9\nC D : HomologicalComplex V c\nf : (i j : \u03b9) \u2192 C.X i \u27f6 D.X j\ni : \u03b9\nhi : \u00acc.Rel i (c.next i)\n\u22a2 (dNext i) f = 0"}, {"line": "dsimp [dNext]", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nc : ComplexShape \u03b9\nC D : HomologicalComplex V c\nf : (i j : \u03b9) \u2192 C.X i \u27f6 D.X j\ni : \u03b9\nhi : \u00acc.Rel i (c.next i)\n\u22a2 CategoryStruct.comp (C.d i (c.next i)) (f (c.next i) i) = 0"}, {"line": "rw [shape _ _ _ hi]", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nc : ComplexShape \u03b9\nC D : HomologicalComplex V c\nf : (i j : \u03b9) \u2192 C.X i \u27f6 D.X j\ni : \u03b9\nhi : \u00acc.Rel i (c.next i)\n\u22a2 CategoryStruct.comp 0 (f (c.next i) i) = 0"}, {"line": "rw [zero_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prevD_eq_zero (f : \u2200 i j, C.X i \u27f6 D.X j) (i : \u03b9) (hi : \u00ac c.Rel (c.prev i) i) :\n    prevD i f = 0 := by\n  dsimp [prevD]\n  rw [shape _ _ _ hi]\n  rw [comp_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Homotopy.lean", "context": {"open": ["CategoryTheory Category Limits HomologicalComplex"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [Preadditive V]", "{c : ComplexShape \u03b9} {C D E : HomologicalComplex V c}", "(f g : C \u27f6 D) (h k : D \u27f6 E) (i : \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nc : ComplexShape \u03b9\nC D : HomologicalComplex V c\nf : (i j : \u03b9) \u2192 C.X i \u27f6 D.X j\ni : \u03b9\nhi : \u00acc.Rel (c.prev i) i\n\u22a2 (prevD i) f = 0"}, {"line": "dsimp [prevD]", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nc : ComplexShape \u03b9\nC D : HomologicalComplex V c\nf : (i j : \u03b9) \u2192 C.X i \u27f6 D.X j\ni : \u03b9\nhi : \u00acc.Rel (c.prev i) i\n\u22a2 CategoryStruct.comp (f i (c.prev i)) (D.d (c.prev i) i) = 0"}, {"line": "rw [shape _ _ _ hi]", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nc : ComplexShape \u03b9\nC D : HomologicalComplex V c\nf : (i j : \u03b9) \u2192 C.X i \u27f6 D.X j\ni : \u03b9\nhi : \u00acc.Rel (c.prev i) i\n\u22a2 CategoryStruct.comp (f i (c.prev i)) 0 = 0"}, {"line": "rw [comp_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prevD_eq (f : \u2200 i j, C.X i \u27f6 D.X j) {j j' : \u03b9} (w : c.Rel j' j) :\n    prevD j f = f j j' \u226b D.d j' j := by\n  obtain rfl := c.prev_eq' w\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Homotopy.lean", "context": {"open": ["CategoryTheory Category Limits HomologicalComplex"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [Preadditive V]", "{c : ComplexShape \u03b9} {C D E : HomologicalComplex V c}", "(f g : C \u27f6 D) (h k : D \u27f6 E) (i : \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nc : ComplexShape \u03b9\nC D : HomologicalComplex V c\nf : (i j : \u03b9) \u2192 C.X i \u27f6 D.X j\nj j' : \u03b9\nw : c.Rel j' j\n\u22a2 (prevD j) f = CategoryStruct.comp (f j j') (D.d j' j)"}, {"line": "obtain rfl := c.prev_eq' w", "tactic_state": "\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nc : ComplexShape \u03b9\nC D : HomologicalComplex V c\nf : (i j : \u03b9) \u2192 C.X i \u27f6 D.X j\nj : \u03b9\nw : c.Rel (c.prev j) j\n\u22a2 (prevD j) f = CategoryStruct.comp (f j (c.prev j)) (D.d (c.prev j) j)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dNext_nat (C D : ChainComplex V \u2115) (i : \u2115) (f : \u2200 i j, C.X i \u27f6 D.X j) :\n    dNext i f = C.d i (i - 1) \u226b f (i - 1) i := by\n  dsimp [dNext]\n  cases i\n  \u00b7 simp only [shape, ChainComplex.next_nat_zero, ComplexShape.down_Rel, Nat.one_ne_zero,\n      not_false_iff, zero_comp, reduceCtorEq]\n  \u00b7 congr <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Homotopy.lean", "context": {"open": ["CategoryTheory Category Limits HomologicalComplex"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [Preadditive V]", "{c : ComplexShape \u03b9} {C D E : HomologicalComplex V c}", "(f g : C \u27f6 D) (h k : D \u27f6 E) (i : \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nC D : ChainComplex V \u2115\ni : \u2115\nf : (i j : \u2115) \u2192 C.X i \u27f6 D.X j\n\u22a2 (dNext i) f = CategoryStruct.comp (C.d i (i - 1)) (f (i - 1) i)"}, {"line": "dsimp [dNext]", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nC D : ChainComplex V \u2115\ni : \u2115\nf : (i j : \u2115) \u2192 C.X i \u27f6 D.X j\n\u22a2 CategoryStruct.comp (C.d i ((ComplexShape.down \u2115).next i)) (f ((ComplexShape.down \u2115).next i) i) =\n    CategoryStruct.comp (C.d i (i - 1)) (f (i - 1) i)"}, {"line": "cases i", "tactic_state": "case zero\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nC D : ChainComplex V \u2115\nf : (i j : \u2115) \u2192 C.X i \u27f6 D.X j\n\u22a2 CategoryStruct.comp (C.d 0 ((ComplexShape.down \u2115).next 0)) (f ((ComplexShape.down \u2115).next 0) 0) =\n    CategoryStruct.comp (C.d 0 (0 - 1)) (f (0 - 1) 0)\n---\ncase succ\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nC D : ChainComplex V \u2115\nf : (i j : \u2115) \u2192 C.X i \u27f6 D.X j\nn\u271d : \u2115\n\u22a2 CategoryStruct.comp (C.d (n\u271d + 1) ((ComplexShape.down \u2115).next (n\u271d + 1)))\n      (f ((ComplexShape.down \u2115).next (n\u271d + 1)) (n\u271d + 1)) =\n    CategoryStruct.comp (C.d (n\u271d + 1) (n\u271d + 1 - 1)) (f (n\u271d + 1 - 1) (n\u271d + 1))"}, {"line": "\u00b7 simp only [shape, ChainComplex.next_nat_zero, ComplexShape.down_Rel, Nat.one_ne_zero,\n      not_false_iff, zero_comp, reduceCtorEq]", "tactic_state": "case succ\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nC D : ChainComplex V \u2115\nf : (i j : \u2115) \u2192 C.X i \u27f6 D.X j\nn\u271d : \u2115\n\u22a2 CategoryStruct.comp (C.d (n\u271d + 1) ((ComplexShape.down \u2115).next (n\u271d + 1)))\n      (f ((ComplexShape.down \u2115).next (n\u271d + 1)) (n\u271d + 1)) =\n    CategoryStruct.comp (C.d (n\u271d + 1) (n\u271d + 1 - 1)) (f (n\u271d + 1 - 1) (n\u271d + 1))"}, {"line": "\u00b7 congr <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prevD_nat (C D : CochainComplex V \u2115) (i : \u2115) (f : \u2200 i j, C.X i \u27f6 D.X j) :\n    prevD i f = f i (i - 1) \u226b D.d (i - 1) i := by\n  dsimp [prevD]\n  cases i\n  \u00b7 simp only [shape, CochainComplex.prev_nat_zero, ComplexShape.up_Rel, Nat.one_ne_zero,\n      not_false_iff, comp_zero, reduceCtorEq]\n  \u00b7 congr <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Homotopy.lean", "context": {"open": ["CategoryTheory Category Limits HomologicalComplex"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [Preadditive V]", "{c : ComplexShape \u03b9} {C D E : HomologicalComplex V c}", "(f g : C \u27f6 D) (h k : D \u27f6 E) (i : \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nC D : CochainComplex V \u2115\ni : \u2115\nf : (i j : \u2115) \u2192 C.X i \u27f6 D.X j\n\u22a2 (prevD i) f = CategoryStruct.comp (f i (i - 1)) (D.d (i - 1) i)"}, {"line": "dsimp [prevD]", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nC D : CochainComplex V \u2115\ni : \u2115\nf : (i j : \u2115) \u2192 C.X i \u27f6 D.X j\n\u22a2 CategoryStruct.comp (f i ((ComplexShape.up \u2115).prev i)) (D.d ((ComplexShape.up \u2115).prev i) i) =\n    CategoryStruct.comp (f i (i - 1)) (D.d (i - 1) i)"}, {"line": "cases i", "tactic_state": "case zero\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nC D : CochainComplex V \u2115\nf : (i j : \u2115) \u2192 C.X i \u27f6 D.X j\n\u22a2 CategoryStruct.comp (f 0 ((ComplexShape.up \u2115).prev 0)) (D.d ((ComplexShape.up \u2115).prev 0) 0) =\n    CategoryStruct.comp (f 0 (0 - 1)) (D.d (0 - 1) 0)\n---\ncase succ\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nC D : CochainComplex V \u2115\nf : (i j : \u2115) \u2192 C.X i \u27f6 D.X j\nn\u271d : \u2115\n\u22a2 CategoryStruct.comp (f (n\u271d + 1) ((ComplexShape.up \u2115).prev (n\u271d + 1)))\n      (D.d ((ComplexShape.up \u2115).prev (n\u271d + 1)) (n\u271d + 1)) =\n    CategoryStruct.comp (f (n\u271d + 1) (n\u271d + 1 - 1)) (D.d (n\u271d + 1 - 1) (n\u271d + 1))"}, {"line": "\u00b7 simp only [shape, CochainComplex.prev_nat_zero, ComplexShape.up_Rel, Nat.one_ne_zero,\n      not_false_iff, comp_zero, reduceCtorEq]", "tactic_state": "case succ\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nC D : CochainComplex V \u2115\nf : (i j : \u2115) \u2192 C.X i \u27f6 D.X j\nn\u271d : \u2115\n\u22a2 CategoryStruct.comp (f (n\u271d + 1) ((ComplexShape.up \u2115).prev (n\u271d + 1)))\n      (D.d ((ComplexShape.up \u2115).prev (n\u271d + 1)) (n\u271d + 1)) =\n    CategoryStruct.comp (f (n\u271d + 1) (n\u271d + 1 - 1)) (D.d (n\u271d + 1 - 1) (n\u271d + 1))"}, {"line": "\u00b7 congr <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prevD_chainComplex (f : \u2200 i j, P.X i \u27f6 Q.X j) (j : \u2115) :\n    prevD j f = f j (j + 1) \u226b Q.d _ _ := by\n  dsimp [prevD]\n  have : (ComplexShape.down \u2115).prev j = j + 1 := ChainComplex.prev \u2115 j\n  congr 2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Homotopy.lean", "context": {"open": ["CategoryTheory Category Limits HomologicalComplex", "Classical in", "Classical in"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [Preadditive V]", "{c : ComplexShape \u03b9} {C D E : HomologicalComplex V c}", "(f g : C \u27f6 D) (h k : D \u27f6 E) (i : \u03b9)", "{f g}", "{P Q : ChainComplex V \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : ChainComplex V \u2115\nf : (i j : \u2115) \u2192 P.X i \u27f6 Q.X j\nj : \u2115\n\u22a2 (prevD j) f = CategoryStruct.comp (f j (j + 1)) (Q.d (j + 1) j)"}, {"line": "dsimp [prevD]", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : ChainComplex V \u2115\nf : (i j : \u2115) \u2192 P.X i \u27f6 Q.X j\nj : \u2115\n\u22a2 CategoryStruct.comp (f j ((ComplexShape.down \u2115).prev j)) (Q.d ((ComplexShape.down \u2115).prev j) j) =\n    CategoryStruct.comp (f j (j + 1)) (Q.d (j + 1) j)"}, {"line": "have : (ComplexShape.down \u2115).prev j = j + 1 := ChainComplex.prev \u2115 j", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : ChainComplex V \u2115\nf : (i j : \u2115) \u2192 P.X i \u27f6 Q.X j\nj : \u2115\nthis : (ComplexShape.down \u2115).prev j = j + 1\n\u22a2 CategoryStruct.comp (f j ((ComplexShape.down \u2115).prev j)) (Q.d ((ComplexShape.down \u2115).prev j) j) =\n    CategoryStruct.comp (f j (j + 1)) (Q.d (j + 1) j)"}, {"line": "congr 2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dNext_succ_chainComplex (f : \u2200 i j, P.X i \u27f6 Q.X j) (i : \u2115) :\n    dNext (i + 1) f = P.d _ _ \u226b f i (i + 1) := by\n  dsimp [dNext]\n  have : (ComplexShape.down \u2115).next (i + 1) = i := ChainComplex.next_nat_succ _\n  congr 2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Homotopy.lean", "context": {"open": ["CategoryTheory Category Limits HomologicalComplex", "Classical in", "Classical in"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [Preadditive V]", "{c : ComplexShape \u03b9} {C D E : HomologicalComplex V c}", "(f g : C \u27f6 D) (h k : D \u27f6 E) (i : \u03b9)", "{f g}", "{P Q : ChainComplex V \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : ChainComplex V \u2115\nf : (i j : \u2115) \u2192 P.X i \u27f6 Q.X j\ni : \u2115\n\u22a2 (dNext (i + 1)) f = CategoryStruct.comp (P.d (i + 1) i) (f i (i + 1))"}, {"line": "dsimp [dNext]", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : ChainComplex V \u2115\nf : (i j : \u2115) \u2192 P.X i \u27f6 Q.X j\ni : \u2115\n\u22a2 CategoryStruct.comp (P.d (i + 1) ((ComplexShape.down \u2115).next (i + 1)))\n      (f ((ComplexShape.down \u2115).next (i + 1)) (i + 1)) =\n    CategoryStruct.comp (P.d (i + 1) i) (f i (i + 1))"}, {"line": "have : (ComplexShape.down \u2115).next (i + 1) = i := ChainComplex.next_nat_succ _", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : ChainComplex V \u2115\nf : (i j : \u2115) \u2192 P.X i \u27f6 Q.X j\ni : \u2115\nthis : (ComplexShape.down \u2115).next (i + 1) = i\n\u22a2 CategoryStruct.comp (P.d (i + 1) ((ComplexShape.down \u2115).next (i + 1)))\n      (f ((ComplexShape.down \u2115).next (i + 1)) (i + 1)) =\n    CategoryStruct.comp (P.d (i + 1) i) (f i (i + 1))"}, {"line": "congr 2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mkInductiveAux\u2083 (i j : \u2115) (h : i + 1 = j) :\n    (mkInductiveAux\u2082 e zero comm_zero one comm_one succ i).2.1 \u226b (Q.xPrevIso h).hom =\n      (P.xNextIso h).inv \u226b (mkInductiveAux\u2082 e zero comm_zero one comm_one succ j).1 := by\n  subst j\n  rcases i with (_ | _ | i) <;> simp [mkInductiveAux\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Homotopy.lean", "context": {"open": ["CategoryTheory Category Limits HomologicalComplex", "Classical in", "Classical in"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [Preadditive V]", "{c : ComplexShape \u03b9} {C D E : HomologicalComplex V c}", "(f g : C \u27f6 D) (h k : D \u27f6 E) (i : \u03b9)", "{f g}", "{P Q : ChainComplex V \u2115}", "(e : P \u27f6 Q) (zero : P.X 0 \u27f6 Q.X 1) (comm_zero : e.f 0 = zero \u226b Q.d 1 0)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : ChainComplex V \u2115\nx\u271d : Sort u_1\nmkInductiveAux\u2082 : x\u271d\ni j : \u2115\nh : i + 1 = j\n\u22a2 CategoryStruct.comp sorry (xPrevIso Q h).hom = CategoryStruct.comp (xNextIso P h).inv sorry"}, {"line": "subst j", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : ChainComplex V \u2115\nx\u271d : Sort u_1\nmkInductiveAux\u2082 : x\u271d\ni : \u2115\n\u22a2 CategoryStruct.comp sorry (xPrevIso Q \u22ef).hom = CategoryStruct.comp (xNextIso P \u22ef).inv sorry"}, {"line": "rcases i with (_ | _ | i) <;> simp [mkInductiveAux\u2082]", "tactic_state": "case zero\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : ChainComplex V \u2115\nx\u271d : Sort u_1\nmkInductiveAux\u2082 : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (xPrevIso Q \u22ef).hom = CategoryStruct.comp (xNextIso P \u22ef).inv (sorry ())\n---\ncase succ.zero\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : ChainComplex V \u2115\nx\u271d : Sort u_1\nmkInductiveAux\u2082 : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (xPrevIso Q \u22ef).hom = CategoryStruct.comp (xNextIso P \u22ef).inv (sorry ())\n---\ncase succ.succ\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : ChainComplex V \u2115\nx\u271d : Sort u_1\nmkInductiveAux\u2082 : x\u271d\ni : \u2115\n\u22a2 CategoryStruct.comp (sorry ()) (xPrevIso Q \u22ef).hom = CategoryStruct.comp (xNextIso P \u22ef).inv (sorry ())"}]}
{"declaration": "theorem dNext_cochainComplex (f : \u2200 i j, P.X i \u27f6 Q.X j) (j : \u2115) :\n    dNext j f = P.d _ _ \u226b f (j + 1) j := by\n  dsimp [dNext]\n  have : (ComplexShape.up \u2115).next j = j + 1 := CochainComplex.next \u2115 j\n  congr 2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Homotopy.lean", "context": {"open": ["CategoryTheory Category Limits HomologicalComplex", "Classical in", "Classical in"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [Preadditive V]", "{c : ComplexShape \u03b9} {C D E : HomologicalComplex V c}", "(f g : C \u27f6 D) (h k : D \u27f6 E) (i : \u03b9)", "{f g}", "{P Q : ChainComplex V \u2115}", "(e : P \u27f6 Q) (zero : P.X 0 \u27f6 Q.X 1) (comm_zero : e.f 0 = zero \u226b Q.d 1 0)", "{P Q : CochainComplex V \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : CochainComplex V \u2115\nf : (i j : \u2115) \u2192 P.X i \u27f6 Q.X j\nj : \u2115\n\u22a2 (dNext j) f = CategoryStruct.comp (P.d j (j + 1)) (f (j + 1) j)"}, {"line": "dsimp [dNext]", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : CochainComplex V \u2115\nf : (i j : \u2115) \u2192 P.X i \u27f6 Q.X j\nj : \u2115\n\u22a2 CategoryStruct.comp (P.d j ((ComplexShape.up \u2115).next j)) (f ((ComplexShape.up \u2115).next j) j) =\n    CategoryStruct.comp (P.d j (j + 1)) (f (j + 1) j)"}, {"line": "have : (ComplexShape.up \u2115).next j = j + 1 := CochainComplex.next \u2115 j", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : CochainComplex V \u2115\nf : (i j : \u2115) \u2192 P.X i \u27f6 Q.X j\nj : \u2115\nthis : (ComplexShape.up \u2115).next j = j + 1\n\u22a2 CategoryStruct.comp (P.d j ((ComplexShape.up \u2115).next j)) (f ((ComplexShape.up \u2115).next j) j) =\n    CategoryStruct.comp (P.d j (j + 1)) (f (j + 1) j)"}, {"line": "congr 2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prevD_succ_cochainComplex (f : \u2200 i j, P.X i \u27f6 Q.X j) (i : \u2115) :\n    prevD (i + 1) f = f (i + 1) _ \u226b Q.d i (i + 1) := by\n  dsimp [prevD]\n  have : (ComplexShape.up \u2115).prev (i + 1) = i := CochainComplex.prev_nat_succ i\n  congr 2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Homotopy.lean", "context": {"open": ["CategoryTheory Category Limits HomologicalComplex", "Classical in", "Classical in"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [Preadditive V]", "{c : ComplexShape \u03b9} {C D E : HomologicalComplex V c}", "(f g : C \u27f6 D) (h k : D \u27f6 E) (i : \u03b9)", "{f g}", "{P Q : ChainComplex V \u2115}", "(e : P \u27f6 Q) (zero : P.X 0 \u27f6 Q.X 1) (comm_zero : e.f 0 = zero \u226b Q.d 1 0)", "{P Q : CochainComplex V \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : CochainComplex V \u2115\nf : (i j : \u2115) \u2192 P.X i \u27f6 Q.X j\ni : \u2115\n\u22a2 (prevD (i + 1)) f = CategoryStruct.comp (f (i + 1) i) (Q.d i (i + 1))"}, {"line": "dsimp [prevD]", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : CochainComplex V \u2115\nf : (i j : \u2115) \u2192 P.X i \u27f6 Q.X j\ni : \u2115\n\u22a2 CategoryStruct.comp (f (i + 1) ((ComplexShape.up \u2115).prev (i + 1))) (Q.d ((ComplexShape.up \u2115).prev (i + 1)) (i + 1)) =\n    CategoryStruct.comp (f (i + 1) i) (Q.d i (i + 1))"}, {"line": "have : (ComplexShape.up \u2115).prev (i + 1) = i := CochainComplex.prev_nat_succ i", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : CochainComplex V \u2115\nf : (i j : \u2115) \u2192 P.X i \u27f6 Q.X j\ni : \u2115\nthis : (ComplexShape.up \u2115).prev (i + 1) = i\n\u22a2 CategoryStruct.comp (f (i + 1) ((ComplexShape.up \u2115).prev (i + 1))) (Q.d ((ComplexShape.up \u2115).prev (i + 1)) (i + 1)) =\n    CategoryStruct.comp (f (i + 1) i) (Q.d i (i + 1))"}, {"line": "congr 2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mkCoinductiveAux\u2083 (i j : \u2115) (h : i + 1 = j) :\n    (P.xNextIso h).inv \u226b (mkCoinductiveAux\u2082 e zero comm_zero one comm_one succ i).2.1 =\n      (mkCoinductiveAux\u2082 e zero comm_zero one comm_one succ j).1 \u226b (Q.xPrevIso h).hom := by\n  subst j\n  rcases i with (_ | _ | i) <;> simp [mkCoinductiveAux\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Homotopy.lean", "context": {"open": ["CategoryTheory Category Limits HomologicalComplex", "Classical in", "Classical in"], "variables": ["{\u03b9 : Type*}", "{V : Type u} [Category.{v} V] [Preadditive V]", "{c : ComplexShape \u03b9} {C D E : HomologicalComplex V c}", "(f g : C \u27f6 D) (h k : D \u27f6 E) (i : \u03b9)", "{f g}", "{P Q : ChainComplex V \u2115}", "(e : P \u27f6 Q) (zero : P.X 0 \u27f6 Q.X 1) (comm_zero : e.f 0 = zero \u226b Q.d 1 0)", "{P Q : CochainComplex V \u2115}", "(e : P \u27f6 Q) (zero : P.X 1 \u27f6 Q.X 0) (comm_zero : e.f 0 = P.d 0 1 \u226b zero)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : CochainComplex V \u2115\nx\u271d : Sort u_1\nmkCoinductiveAux\u2082 : x\u271d\ni j : \u2115\nh : i + 1 = j\n\u22a2 CategoryStruct.comp (xNextIso P h).inv sorry = CategoryStruct.comp sorry (xPrevIso Q h).hom"}, {"line": "subst j", "tactic_state": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : CochainComplex V \u2115\nx\u271d : Sort u_1\nmkCoinductiveAux\u2082 : x\u271d\ni : \u2115\n\u22a2 CategoryStruct.comp (xNextIso P \u22ef).inv sorry = CategoryStruct.comp sorry (xPrevIso Q \u22ef).hom"}, {"line": "rcases i with (_ | _ | i) <;> simp [mkCoinductiveAux\u2082]", "tactic_state": "case zero\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : CochainComplex V \u2115\nx\u271d : Sort u_1\nmkCoinductiveAux\u2082 : x\u271d\n\u22a2 CategoryStruct.comp (xNextIso P \u22ef).inv (sorry ()) = CategoryStruct.comp (sorry ()) (xPrevIso Q \u22ef).hom\n---\ncase succ.zero\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : CochainComplex V \u2115\nx\u271d : Sort u_1\nmkCoinductiveAux\u2082 : x\u271d\n\u22a2 CategoryStruct.comp (xNextIso P \u22ef).inv (sorry ()) = CategoryStruct.comp (sorry ()) (xPrevIso Q \u22ef).hom\n---\ncase succ.succ\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : CochainComplex V \u2115\nx\u271d : Sort u_1\nmkCoinductiveAux\u2082 : x\u271d\ni : \u2115\n\u22a2 CategoryStruct.comp (xNextIso P \u22ef).inv (sorry ()) = CategoryStruct.comp (sorry ()) (xPrevIso Q \u22ef).hom"}]}
{"declaration": "lemma toSingle\u2080Equiv_symm_apply_f_zero {C : ChainComplex V \u2115} {X : V}\n    (f : C.X 0 \u27f6 X) (hf : C.d 1 0 \u226b f = 0) :\n    ((toSingle\u2080Equiv C X).symm \u27e8f, hf\u27e9).f 0 = f := by\n  simp [toSingle\u2080Equiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Single.lean", "context": {"open": ["CategoryTheory Category Limits ZeroObject"], "variables": ["(V : Type u) [Category.{v} V] [HasZeroMorphisms V] [HasZeroObject V]", "{\u03b9 : Type*} [DecidableEq \u03b9] (c : ComplexShape \u03b9)", "{V}", "(V)", "{V c}", "{V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d\u00b2 : Category.{v, u} V\ninst\u271d\u00b9 : HasZeroMorphisms V\ninst\u271d : HasZeroObject V\nx\u271d : Sort u_2\ntoSingle\u2080Equiv : x\u271d\nC : ChainComplex V \u2115\nX : V\nf : C.X 0 \u27f6 X\nhf : CategoryStruct.comp (C.d 1 0) f = 0\n\u22a2 sorry = f"}, {"line": "simp [toSingle\u2080Equiv]", "tactic_state": "V : Type u\ninst\u271d\u00b2 : Category.{v, u} V\ninst\u271d\u00b9 : HasZeroMorphisms V\ninst\u271d : HasZeroObject V\nx\u271d : Sort u_2\ntoSingle\u2080Equiv : x\u271d\nC : ChainComplex V \u2115\nX : V\nf : C.X 0 \u27f6 X\nhf : CategoryStruct.comp (C.d 1 0) f = 0\n\u22a2 sorry () = f"}]}
{"declaration": "lemma fromSingle\u2080Equiv_symm_apply_f_zero\n    {C : ChainComplex V \u2115} {X : V} (f : X \u27f6 C.X 0) :\n    ((fromSingle\u2080Equiv C X).symm f).f 0 = f := by\n  simp [fromSingle\u2080Equiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Single.lean", "context": {"open": ["CategoryTheory Category Limits ZeroObject"], "variables": ["(V : Type u) [Category.{v} V] [HasZeroMorphisms V] [HasZeroObject V]", "{\u03b9 : Type*} [DecidableEq \u03b9] (c : ComplexShape \u03b9)", "{V}", "(V)", "{V c}", "{V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d\u00b2 : Category.{v, u} V\ninst\u271d\u00b9 : HasZeroMorphisms V\ninst\u271d : HasZeroObject V\nx\u271d : Sort u_2\nfromSingle\u2080Equiv : x\u271d\nC : ChainComplex V \u2115\nX : V\nf : X \u27f6 C.X 0\n\u22a2 sorry = f"}, {"line": "simp [fromSingle\u2080Equiv]", "tactic_state": "V : Type u\ninst\u271d\u00b2 : Category.{v, u} V\ninst\u271d\u00b9 : HasZeroMorphisms V\ninst\u271d : HasZeroObject V\nx\u271d : Sort u_2\nfromSingle\u2080Equiv : x\u271d\nC : ChainComplex V \u2115\nX : V\nf : X \u27f6 C.X 0\n\u22a2 sorry () = f"}]}
{"declaration": "lemma fromSingle\u2080Equiv_symm_apply_f_zero {C : CochainComplex V \u2115} {X : V}\n    (f : X \u27f6 C.X 0) (hf : f \u226b C.d 0 1 = 0) :\n    ((fromSingle\u2080Equiv C X).symm \u27e8f, hf\u27e9).f 0 = f := by\n  simp [fromSingle\u2080Equiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Single.lean", "context": {"open": ["CategoryTheory Category Limits ZeroObject"], "variables": ["(V : Type u) [Category.{v} V] [HasZeroMorphisms V] [HasZeroObject V]", "{\u03b9 : Type*} [DecidableEq \u03b9] (c : ComplexShape \u03b9)", "{V}", "(V)", "{V c}", "{V}", "{V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d\u00b2 : Category.{v, u} V\ninst\u271d\u00b9 : HasZeroMorphisms V\ninst\u271d : HasZeroObject V\nx\u271d : Sort u_2\nfromSingle\u2080Equiv : x\u271d\nC : CochainComplex V \u2115\nX : V\nf : X \u27f6 C.X 0\nhf : CategoryStruct.comp f (C.d 0 1) = 0\n\u22a2 sorry = f"}, {"line": "simp [fromSingle\u2080Equiv]", "tactic_state": "V : Type u\ninst\u271d\u00b2 : Category.{v, u} V\ninst\u271d\u00b9 : HasZeroMorphisms V\ninst\u271d : HasZeroObject V\nx\u271d : Sort u_2\nfromSingle\u2080Equiv : x\u271d\nC : CochainComplex V \u2115\nX : V\nf : X \u27f6 C.X 0\nhf : CategoryStruct.comp f (C.d 0 1) = 0\n\u22a2 sorry () = f"}]}
{"declaration": "lemma toSingle\u2080Equiv_symm_apply_f_zero\n    {C : CochainComplex V \u2115} {X : V} (f : C.X 0 \u27f6 X) :\n    ((toSingle\u2080Equiv C X).symm f).f 0 = f := by\n  simp [toSingle\u2080Equiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Single.lean", "context": {"open": ["CategoryTheory Category Limits ZeroObject"], "variables": ["(V : Type u) [Category.{v} V] [HasZeroMorphisms V] [HasZeroObject V]", "{\u03b9 : Type*} [DecidableEq \u03b9] (c : ComplexShape \u03b9)", "{V}", "(V)", "{V c}", "{V}", "{V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u\ninst\u271d\u00b2 : Category.{v, u} V\ninst\u271d\u00b9 : HasZeroMorphisms V\ninst\u271d : HasZeroObject V\nx\u271d : Sort u_2\ntoSingle\u2080Equiv : x\u271d\nC : CochainComplex V \u2115\nX : V\nf : C.X 0 \u27f6 X\n\u22a2 sorry = f"}, {"line": "simp [toSingle\u2080Equiv]", "tactic_state": "V : Type u\ninst\u271d\u00b2 : Category.{v, u} V\ninst\u271d\u00b9 : HasZeroMorphisms V\ninst\u271d : HasZeroObject V\nx\u271d : Sort u_2\ntoSingle\u2080Equiv : x\u271d\nC : CochainComplex V \u2115\nX : V\nf : C.X 0 \u27f6 X\n\u22a2 sorry () = f"}]}
{"declaration": "lemma isIso_Qh_map_iff {X Y : HomotopyCategory C (ComplexShape.up \u2124)} (f : X \u27f6 Y) :\n    IsIso (Qh.map f) \u2194 HomotopyCategory.quasiIso C _ f := by\n  constructor\n  \u00b7 intro hf\n    rw [HomotopyCategory.mem_quasiIso_iff]\n    intro n\n    rw [\u2190 NatIso.isIso_map_iff (homologyFunctorFactorsh C n) f]\n    dsimp\n    infer_instance\n  \u00b7 exact Localization.inverts Qh (HomotopyCategory.quasiIso _ _) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/DerivedCategory/HomologySequence.lean", "context": {"open": ["CategoryTheory Pretriangulated"], "variables": ["(C : Type u) [Category.{v} C] [Abelian C] [HasDerivedCategory.{w} C]", "{C} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : Abelian C\ninst\u271d : HasDerivedCategory C\nX Y : HomotopyCategory C (ComplexShape.up \u2124)\nf : X \u27f6 Y\n\u22a2 IsIso sorry \u2194 HomotopyCategory.quasiIso C (ComplexShape.up \u2124) f"}, {"line": "constructor", "tactic_state": "case mp\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : Abelian C\ninst\u271d : HasDerivedCategory C\nX Y : HomotopyCategory C (ComplexShape.up \u2124)\nf : X \u27f6 Y\n\u22a2 IsIso sorry \u2192 HomotopyCategory.quasiIso C (ComplexShape.up \u2124) f\n---\ncase mpr\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : Abelian C\ninst\u271d : HasDerivedCategory C\nX Y : HomotopyCategory C (ComplexShape.up \u2124)\nf : X \u27f6 Y\n\u22a2 HomotopyCategory.quasiIso C (ComplexShape.up \u2124) f \u2192 IsIso sorry"}, {"line": "\u00b7 intro hf\n    rw [HomotopyCategory.mem_quasiIso_iff]\n    intro n\n    rw [\u2190 NatIso.isIso_map_iff (homologyFunctorFactorsh C n) f]\n    dsimp\n    infer_instance", "tactic_state": "case mpr\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : Abelian C\ninst\u271d : HasDerivedCategory C\nX Y : HomotopyCategory C (ComplexShape.up \u2124)\nf : X \u27f6 Y\n\u22a2 HomotopyCategory.quasiIso C (ComplexShape.up \u2124) f \u2192 IsIso sorry"}, {"line": "\u00b7 exact Localization.inverts Qh (HomotopyCategory.quasiIso _ _) _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ext_mk\u2080_f_comp_ext_mk\u2080_g : (Ext.mk\u2080 S.f).comp (Ext.mk\u2080 S.g) (zero_add 0) = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/DerivedCategory/Ext/ExtClass.lean", "context": {"open": ["Localization Limits ZeroObject DerivedCategory Pretriangulated", "Abelian"], "variables": ["{C : Type u} [Category.{v} C] [Abelian C] [HasExt.{w} C]", "(S : ShortComplex C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "ShortComplex : ?m.425\nS : sorry\n\u22a2 sorry = 0"}, {"line": "simp", "tactic_state": "ShortComplex : ?m.425\nS : sorry\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma HasExt.standard : HasExt.{max u v} C := by\n  letI := HasDerivedCategory.standard\n  exact hasExt_of_hasDerivedCategory _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/DerivedCategory/Ext/Basic.lean", "context": {"open": ["Localization Limits ZeroObject DerivedCategory Pretriangulated"], "variables": ["(C : Type u) [Category.{v} C] [Abelian C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nHasExt : x\u271d\n\u22a2 sorry"}, {"line": "letI := HasDerivedCategory.standard", "tactic_state": "x\u271d : Sort u_1\nHasExt : x\u271d\nthis : (C : Type ?u.27) \u2192\n  [inst : CategoryTheory.Category.{?u.28, ?u.27} C] \u2192 [inst_1 : CategoryTheory.Abelian C] \u2192 HasDerivedCategory C :=\n  HasDerivedCategory.standard\n\u22a2 sorry"}, {"line": "exact hasExt_of_hasDerivedCategory _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma extend_d_eq {i' j' : \u03b9'} {i j : \u03b9} (hi : e.f i = i') (hj : e.f j = j') :\n    (K.extend e).d i' j' = (K.extendXIso e hi).hom \u226b K.d i j \u226b\n      (K.extendXIso e hj).inv := by\n  apply extend.d_eq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Embedding/Extend.lean", "context": {"open": ["CategoryTheory Category Limits ZeroObject"], "variables": ["{\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}", "{C : Type*} [Category C] [HasZeroObject C]", "[HasZeroMorphisms C] (K L M : HomologicalComplex C c)", "{K L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nc : ComplexShape \u03b9\nC : Type u_3\ninst\u271d\u00b2 : Category.{u_4, u_3} C\ninst\u271d\u00b9 : HasZeroObject C\ninst\u271d : HasZeroMorphisms C\nK : HomologicalComplex C c\nc'\u271d : ComplexShape \u03b9'\ne : c.Embedding c'\u271d\ni' j' : \u03b9'\ni j : \u03b9\nhi : e.f i = i'\nhj : e.f j = j'\n\u22a2 (K.extend e).d i' j' =\n    CategoryStruct.comp (K.extendXIso e hi).hom (CategoryStruct.comp (K.d i j) (K.extendXIso e hj).inv)"}, {"line": "apply extend.d_eq", "tactic_state": "No Goals!"}]}
{"declaration": "lemma extendCyclesIso_hom_naturality :\n    cyclesMap (extendMap \u03c6 e) j' \u226b (L.extendCyclesIso e hj').hom =\n      (K.extendCyclesIso e hj').hom \u226b cyclesMap \u03c6 j := by\n  simp [\u2190 cancel_mono (L.iCycles j), extendMap_f \u03c6 e hj']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean", "context": {"open": ["CategoryTheory Limits Category", "leftHomologyData in", "rightHomologyData in"], "variables": ["{\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}", "(K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M) (e : c.Embedding c')", "{i j k : \u03b9} {i' j' k' : \u03b9'} (hj' : e.f j = j')", "(cone : KernelFork (K.d j k)) (hcone : IsLimit cone)", "(cocone : CokernelCofork (hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k))))", "(cocone : CokernelCofork (K.d i j)) (hcocone : IsColimit cocone)", "(cone : KernelFork (hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k))))", "{j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] [L.HasHomology j]", "{K L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncyclesMap : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.comp sorry sorry"}, {"line": "simp [\u2190 cancel_mono (L.iCycles j), extendMap_f \u03c6 e hj']", "tactic_state": "x\u271d : Sort u_1\ncyclesMap : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.comp (sorry ()) (sorry ())"}]}
{"declaration": "lemma extendHomologyIso_hom_naturality :\n    homologyMap (extendMap \u03c6 e) j' \u226b (L.extendHomologyIso e hj').hom =\n      (K.extendHomologyIso e hj').hom \u226b homologyMap \u03c6 j := by\n  simp [\u2190 cancel_epi ((K.extend e).homology\u03c0 _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean", "context": {"open": ["CategoryTheory Limits Category", "leftHomologyData in", "rightHomologyData in"], "variables": ["{\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}", "(K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M) (e : c.Embedding c')", "{i j k : \u03b9} {i' j' k' : \u03b9'} (hj' : e.f j = j')", "(cone : KernelFork (K.d j k)) (hcone : IsLimit cone)", "(cocone : CokernelCofork (hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k))))", "(cocone : CokernelCofork (K.d i j)) (hcocone : IsColimit cocone)", "(cone : KernelFork (hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k))))", "{j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] [L.HasHomology j]", "{K L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nhomologyMap : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.comp sorry sorry"}, {"line": "simp [\u2190 cancel_epi ((K.extend e).homology\u03c0 _)]", "tactic_state": "x\u271d : Sort u_1\nhomologyMap : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.comp (sorry ()) (sorry ())"}]}
{"declaration": "lemma isZero_stupidTrunc_iff :\n    IsZero (K.stupidTrunc e) \u2194 K.IsStrictlySupportedOutside e := by\n  constructor\n  \u00b7 exact fun h \u21a6 \u27e8fun i \u21a6\n      ((eval _ _ (e.f i)).map_isZero h).of_iso (K.stupidTruncXIso e rfl).symm\u27e9\n  \u00b7 intro h\n    rw [isZero_iff_isStrictlySupported_and_isStrictlySupportedOutside _ e]\n    constructor\n    \u00b7 infer_instance\n    \u00b7 exact \u27e8fun i \u21a6 (h.isZero i).of_iso (K.stupidTruncXIso e rfl)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Embedding/StupidTrunc.lean", "context": {"open": ["CategoryTheory Category Limits ZeroObject"], "variables": ["{\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}", "{C : Type*} [Category C] [HasZeroMorphisms C] [HasZeroObject C]", "(K L M : HomologicalComplex C c') (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9' : Type u_2\nc' : ComplexShape \u03b9'\nC : Type u_3\ninst\u271d\u00b2 : Category.{u_5, u_3} C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasZeroObject C\nK : HomologicalComplex C c'\n\u03b9\u271d : Type u_4\nc\u271d : ComplexShape \u03b9\u271d\ne : c\u271d.Embedding c'\n\u22a2 IsZero sorry \u2194 K.IsStrictlySupportedOutside e"}, {"line": "constructor", "tactic_state": "case mp\n\u03b9' : Type u_2\nc' : ComplexShape \u03b9'\nC : Type u_3\ninst\u271d\u00b2 : Category.{u_5, u_3} C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasZeroObject C\nK : HomologicalComplex C c'\n\u03b9\u271d : Type u_4\nc\u271d : ComplexShape \u03b9\u271d\ne : c\u271d.Embedding c'\n\u22a2 IsZero sorry \u2192 K.IsStrictlySupportedOutside e\n---\ncase mpr\n\u03b9' : Type u_2\nc' : ComplexShape \u03b9'\nC : Type u_3\ninst\u271d\u00b2 : Category.{u_5, u_3} C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasZeroObject C\nK : HomologicalComplex C c'\n\u03b9\u271d : Type u_4\nc\u271d : ComplexShape \u03b9\u271d\ne : c\u271d.Embedding c'\n\u22a2 K.IsStrictlySupportedOutside e \u2192 IsZero sorry"}, {"line": "\u00b7 exact fun h \u21a6 \u27e8fun i \u21a6\n      ((eval _ _ (e.f i)).map_isZero h).of_iso (K.stupidTruncXIso e rfl).symm\u27e9", "tactic_state": "case mpr\n\u03b9' : Type u_2\nc' : ComplexShape \u03b9'\nC : Type u_3\ninst\u271d\u00b2 : Category.{u_5, u_3} C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasZeroObject C\nK : HomologicalComplex C c'\n\u03b9\u271d : Type u_4\nc\u271d : ComplexShape \u03b9\u271d\ne : c\u271d.Embedding c'\n\u22a2 K.IsStrictlySupportedOutside e \u2192 IsZero sorry"}, {"line": "\u00b7 intro h\n    rw [isZero_iff_isStrictlySupported_and_isStrictlySupportedOutside _ e]\n    constructor\n    \u00b7 infer_instance\n    \u00b7 exact \u27e8fun i \u21a6 (h.isZero i).of_iso (K.stupidTruncXIso e rfl)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma stupidTruncMap_id : stupidTruncMap (\ud835\udfd9 K) e = \ud835\udfd9 _ := by\n  simp [stupidTruncMap, stupidTrunc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Embedding/StupidTrunc.lean", "context": {"open": ["CategoryTheory Category Limits ZeroObject"], "variables": ["{\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}", "{C : Type*} [Category C] [HasZeroMorphisms C] [HasZeroObject C]", "(K L M : HomologicalComplex C c') (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M)", "{K L M}", "(K) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nstupidTruncMap : x\u271d\n\u22a2 sorry = CategoryStruct.id ?m.2094"}, {"line": "simp [stupidTruncMap, stupidTrunc]", "tactic_state": "x\u271d : Sort u_4\nstupidTruncMap : x\u271d\n\u22a2 sorry () = CategoryStruct.id ?m.2094"}]}
{"declaration": "lemma stupidTruncMap_comp :\n    stupidTruncMap (\u03c6 \u226b \u03c6') e = stupidTruncMap \u03c6 e \u226b stupidTruncMap \u03c6' e := by\n  simp [stupidTruncMap, stupidTrunc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Embedding/StupidTrunc.lean", "context": {"open": ["CategoryTheory Category Limits ZeroObject"], "variables": ["{\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}", "{C : Type*} [Category C] [HasZeroMorphisms C] [HasZeroObject C]", "(K L M : HomologicalComplex C c') (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M)", "{K L M}", "(K) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nstupidTruncMap : x\u271d\n\u22a2 sorry = CategoryStruct.comp sorry sorry"}, {"line": "simp [stupidTruncMap, stupidTrunc]", "tactic_state": "x\u271d : Sort u_4\nstupidTruncMap : x\u271d\n\u22a2 sorry () = CategoryStruct.comp (sorry ()) (sorry ())"}]}
{"declaration": "lemma truncGEMap_id : truncGEMap (\ud835\udfd9 K) e = \ud835\udfd9 _ := by\n  simp [truncGEMap, truncGE]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Embedding/TruncGE.lean", "context": {"open": ["CategoryTheory Limits ZeroObject Category", "Classical in", "Classical in", "Classical in"], "variables": ["{\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}", "(K L M : HomologicalComplex C c') (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M)", "[HasZeroObject C]", "{K L M}", "(K) in", "[HasZeroObject C]", "(K) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntruncGEMap : x\u271d\n\u22a2 sorry = CategoryStruct.id ?m.3927"}, {"line": "simp [truncGEMap, truncGE]", "tactic_state": "x\u271d : Sort u_1\ntruncGEMap : x\u271d\n\u22a2 sorry () = CategoryStruct.id ?m.3927"}]}
{"declaration": "lemma truncGEMap_comp : truncGEMap (\u03c6 \u226b \u03c6') e = truncGEMap \u03c6 e \u226b truncGEMap \u03c6' e := by\n  simp [truncGEMap, truncGE]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Embedding/TruncGE.lean", "context": {"open": ["CategoryTheory Limits ZeroObject Category", "Classical in", "Classical in", "Classical in"], "variables": ["{\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}", "(K L M : HomologicalComplex C c') (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M)", "[HasZeroObject C]", "{K L M}", "(K) in", "[HasZeroObject C]", "(K) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntruncGEMap : x\u271d\n\u22a2 sorry = CategoryStruct.comp sorry sorry"}, {"line": "simp [truncGEMap, truncGE]", "tactic_state": "x\u271d : Sort u_1\ntruncGEMap : x\u271d\n\u22a2 sorry () = CategoryStruct.comp (sorry ()) (sorry ())"}]}
{"declaration": "lemma not_mem_range_embeddingUpIntLE_iff (n : \u2124) :\n    (\u2200 (i : \u2115), (embeddingUpIntLE p).f i \u2260 n) \u2194 p < n := by\n  constructor\n  \u00b7 intro h\n    by_contra!\n    exact h (p - n).natAbs (by simp; omega)\n  \u00b7 intros\n    dsimp\n    omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Embedding/Basic.lean", "context": {"open": ["Classical in"], "variables": ["{\u03b9 \u03b9' : Type*} (c : ComplexShape \u03b9) (c' : ComplexShape \u03b9')", "{c c'}", "(e : Embedding c c')", "(c c')", "(f : \u03b9 \u2192 \u03b9') (hf : Function.Injective f)", "(p : \u2124)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Embedding : ?m.1810\n\u03b9 : Sort ?u.1851\n\u03b9' : Sort ?u.1852\nc : ?m.2270\nc' : ?m.2271 c\ne : sorry\nf : \u03b9 \u2192 \u03b9'\nhf : Function.Injective f\np\u271d p : \u2124\nx\u271d : Sort u_1\nembeddingUpIntLE : x\u271d\nn : \u2124\n\u22a2 \u2115 \u2192 sorry \u2260 n \u2194 p < n"}, {"line": "constructor", "tactic_state": "case mp\nEmbedding : ?m.1810\n\u03b9 : Sort ?u.1851\n\u03b9' : Sort ?u.1852\nc : ?m.2270\nc' : ?m.2271 c\ne : sorry\nf : \u03b9 \u2192 \u03b9'\nhf : Function.Injective f\np\u271d p : \u2124\nx\u271d : Sort u_1\nembeddingUpIntLE : x\u271d\nn : \u2124\n\u22a2 (\u2115 \u2192 sorry \u2260 n) \u2192 p < n\n---\ncase mpr\nEmbedding : ?m.1810\n\u03b9 : Sort ?u.1851\n\u03b9' : Sort ?u.1852\nc : ?m.2270\nc' : ?m.2271 c\ne : sorry\nf : \u03b9 \u2192 \u03b9'\nhf : Function.Injective f\np\u271d p : \u2124\nx\u271d : Sort u_1\nembeddingUpIntLE : x\u271d\nn : \u2124\n\u22a2 p < n \u2192 \u2115 \u2192 sorry \u2260 n"}, {"line": "\u00b7 intro h\n    by_contra!\n    exact h (p - n).natAbs (by simp; omega)", "tactic_state": "case mpr\nEmbedding : ?m.1810\n\u03b9 : Sort ?u.1851\n\u03b9' : Sort ?u.1852\nc : ?m.2270\nc' : ?m.2271 c\ne : sorry\nf : \u03b9 \u2192 \u03b9'\nhf : Function.Injective f\np\u271d p : \u2124\nx\u271d : Sort u_1\nembeddingUpIntLE : x\u271d\nn : \u2124\n\u22a2 p < n \u2192 \u2115 \u2192 sorry \u2260 n"}, {"line": "\u00b7 intros\n    dsimp\n    omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_mem_range_embeddingUpIntGE_iff (n : \u2124) :\n    (\u2200 (i : \u2115), (embeddingUpIntGE p).f i \u2260 n) \u2194 n < p := by\n  constructor\n  \u00b7 intro h\n    by_contra!\n    exact h (n - p).natAbs (by simp; omega)\n  \u00b7 intros\n    dsimp\n    omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/Embedding/Basic.lean", "context": {"open": ["Classical in"], "variables": ["{\u03b9 \u03b9' : Type*} (c : ComplexShape \u03b9) (c' : ComplexShape \u03b9')", "{c c'}", "(e : Embedding c c')", "(c c')", "(f : \u03b9 \u2192 \u03b9') (hf : Function.Injective f)", "(p : \u2124)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Embedding : ?m.1810\n\u03b9 : Sort ?u.1851\n\u03b9' : Sort ?u.1852\nc : ?m.2270\nc' : ?m.2271 c\ne : sorry\nf : \u03b9 \u2192 \u03b9'\nhf : Function.Injective f\np\u271d p : \u2124\nx\u271d : Sort u_1\nembeddingUpIntGE : x\u271d\nn : \u2124\n\u22a2 \u2115 \u2192 sorry \u2260 n \u2194 n < p"}, {"line": "constructor", "tactic_state": "case mp\nEmbedding : ?m.1810\n\u03b9 : Sort ?u.1851\n\u03b9' : Sort ?u.1852\nc : ?m.2270\nc' : ?m.2271 c\ne : sorry\nf : \u03b9 \u2192 \u03b9'\nhf : Function.Injective f\np\u271d p : \u2124\nx\u271d : Sort u_1\nembeddingUpIntGE : x\u271d\nn : \u2124\n\u22a2 (\u2115 \u2192 sorry \u2260 n) \u2192 n < p\n---\ncase mpr\nEmbedding : ?m.1810\n\u03b9 : Sort ?u.1851\n\u03b9' : Sort ?u.1852\nc : ?m.2270\nc' : ?m.2271 c\ne : sorry\nf : \u03b9 \u2192 \u03b9'\nhf : Function.Injective f\np\u271d p : \u2124\nx\u271d : Sort u_1\nembeddingUpIntGE : x\u271d\nn : \u2124\n\u22a2 n < p \u2192 \u2115 \u2192 sorry \u2260 n"}, {"line": "\u00b7 intro h\n    by_contra!\n    exact h (n - p).natAbs (by simp; omega)", "tactic_state": "case mpr\nEmbedding : ?m.1810\n\u03b9 : Sort ?u.1851\n\u03b9' : Sort ?u.1852\nc : ?m.2270\nc' : ?m.2271 c\ne : sorry\nf : \u03b9 \u2192 \u03b9'\nhf : Function.Injective f\np\u271d p : \u2124\nx\u271d : Sort u_1\nembeddingUpIntGE : x\u271d\nn : \u2124\n\u22a2 n < p \u2192 \u2115 \u2192 sorry \u2260 n"}, {"line": "\u00b7 intros\n    dsimp\n    omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ofHoms_zero : ofHoms (fun p => (0 : F.X p \u27f6 G.X p)) = 0 := by aesop_cat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean", "context": {"open": ["CategoryTheory Category Limits Preadditive"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C] {R : Type*} [Ring R] [Linear R C]", "{F G K L : CochainComplex C \u2124} (n m : \u2124)", "(F G)", "{F G n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nofHoms : x\u271d\n\u22a2 sorry = 0"}, {"line": "aesop_cat", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ofHom_neg (\u03c6 : F \u27f6 G) :\n    Cochain.ofHom (-\u03c6) = -Cochain.ofHom \u03c6 := by aesop_cat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean", "context": {"open": ["CategoryTheory Category Limits Preadditive"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C] {R : Type*} [Ring R] [Linear R C]", "{F G K L : CochainComplex C \u2124} (n m : \u2124)", "(F G)", "{F G n}", "(F G)", "{F G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\n\u22a2 sorry = -sorry"}, {"line": "aesop_cat", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_zero : (\u2191(0 : Cocycle F G n) : Cochain F G n) = 0 := by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean", "context": {"open": ["CategoryTheory Category Limits Preadditive", "HomComplex"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C] {R : Type*} [Ring R] [Linear R C]", "{F G K L : CochainComplex C \u2124} (n m : \u2124)", "(F G)", "{F G n}", "(F G)", "{F G}", "(K)", "{F G}", "(F G) (R)", "{F G R}", "(F G)", "{F G}", "{n}", "(F G n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nCochain : x\u271d\u00b9\nx\u271d : Sort u_3\nCocycle : x\u271d\n\u22a2 0 = 0"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma homOf_ofHom_eq_self (\u03c6 : F \u27f6 G) : homOf (ofHom \u03c6) = \u03c6 := by aesop_cat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean", "context": {"open": ["CategoryTheory Category Limits Preadditive", "HomComplex"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C] {R : Type*} [Ring R] [Linear R C]", "{F G K L : CochainComplex C \u2124} (n m : \u2124)", "(F G)", "{F G n}", "(F G)", "{F G}", "(K)", "{F G}", "(F G) (R)", "{F G R}", "(F G)", "{F G}", "{n}", "(F G n)", "{F G n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nF G : CochainComplex C \u2124\nx\u271d : Sort u_2\nhomOf : x\u271d\n\u03c6 : F \u27f6 G\n\u22a2 sorry = \u03c6"}, {"line": "aesop_cat", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ofHom_homOf_eq_self (z : Cocycle F G 0) : ofHom (homOf z) = z := by aesop_cat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean", "context": {"open": ["CategoryTheory Category Limits Preadditive", "HomComplex"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C] {R : Type*} [Ring R] [Linear R C]", "{F G K L : CochainComplex C \u2124} (n m : \u2124)", "(F G)", "{F G n}", "(F G)", "{F G}", "(K)", "{F G}", "(F G) (R)", "{F G R}", "(F G)", "{F G}", "{n}", "(F G n)", "{F G n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nCocycle : x\u271d\u00b9\nx\u271d : Sort u_3\nofHom : x\u271d\nz : sorry\n\u22a2 sorry = z"}, {"line": "aesop_cat", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cochain_ofHom_homOf_eq_coe (z : Cocycle F G 0) :\n    Cochain.ofHom (homOf z) = (z : Cochain F G 0) := by\n  simpa only [Cocycle.ext_iff] using ofHom_homOf_eq_self z\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean", "context": {"open": ["CategoryTheory Category Limits Preadditive", "HomComplex"], "variables": ["{C : Type u} [Category.{v} C] [Preadditive C] {R : Type*} [Ring R] [Linear R C]", "{F G K L : CochainComplex C \u2124} (n m : \u2124)", "(F G)", "{F G n}", "(F G)", "{F G}", "(K)", "{F G}", "(F G) (R)", "{F G R}", "(F G)", "{F G}", "{n}", "(F G n)", "{F G n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nCocycle : x\u271d\u00b9\nx\u271d : Sort u_3\nCochain : x\u271d\nz : sorry\n\u22a2 sorry = z"}, {"line": "simpa only [Cocycle.ext_iff] using ofHom_homOf_eq_self z", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inl_v_fst_v (p q : \u2124) (hpq : q + 1 = p) :\n    (inl \u03c6).v p q (by rw [\u2190 hpq, add_neg_cancel_right]) \u226b\n      (fst \u03c6 : Cochain (mappingCone \u03c6) F 1).v q p hpq = \ud835\udfd9 _ := by\n  simp [inl, fst]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex", "HomComplex"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]", "{\u03b9 : Type*} [AddRightCancelSemigroup \u03b9] [One \u03b9]", "{F G : CochainComplex C \u2124} (\u03c6 : F \u27f6 G)", "[HasHomotopyCofiber \u03c6]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_4\ninl : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\nCochain : x\u271d\u00b9\nx\u271d : Sort u_6\nfst : x\u271d\np q : \u2124\nhpq : q + 1 = p\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.id (?m.4883 p q hpq)"}, {"line": "simp [inl, fst]", "tactic_state": "x\u271d\u00b2 : Sort u_4\ninl : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\nCochain : x\u271d\u00b9\nx\u271d : Sort u_6\nfst : x\u271d\np q : \u2124\nhpq : q + 1 = p\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.id (?m.4883 p q hpq)"}]}
{"declaration": "lemma inl_v_snd_v (p q : \u2124) (hpq : p + (-1) = q) :\n    (inl \u03c6).v p q hpq \u226b (snd \u03c6).v q q (add_zero q) = 0 := by\n  simp [inl, snd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex", "HomComplex"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]", "{\u03b9 : Type*} [AddRightCancelSemigroup \u03b9] [One \u03b9]", "{F G : CochainComplex C \u2124} (\u03c6 : F \u27f6 G)", "[HasHomotopyCofiber \u03c6]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_4\ninl : x\u271d\u00b9\nx\u271d : Sort u_5\nsnd : x\u271d\np q : \u2124\nhpq : p + -1 = q\n\u22a2 CategoryStruct.comp sorry sorry = 0"}, {"line": "simp [inl, snd]", "tactic_state": "x\u271d\u00b9 : Sort u_4\ninl : x\u271d\u00b9\nx\u271d : Sort u_5\nsnd : x\u271d\np q : \u2124\nhpq : p + -1 = q\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = 0"}]}
{"declaration": "lemma inr_f_fst_v (p q : \u2124) (hpq : p + 1 = q) :\n    (inr \u03c6).f p \u226b (fst \u03c6).1.v p q hpq = 0 := by\n  simp [inr, fst]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex", "HomComplex"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]", "{\u03b9 : Type*} [AddRightCancelSemigroup \u03b9] [One \u03b9]", "{F G : CochainComplex C \u2124} (\u03c6 : F \u27f6 G)", "[HasHomotopyCofiber \u03c6]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_4\ninr : x\u271d\u00b9\nx\u271d : Sort u_5\nfst : x\u271d\np q : \u2124\nhpq : p + 1 = q\n\u22a2 CategoryStruct.comp sorry sorry = 0"}, {"line": "simp [inr, fst]", "tactic_state": "x\u271d\u00b9 : Sort u_4\ninr : x\u271d\u00b9\nx\u271d : Sort u_5\nfst : x\u271d\np q : \u2124\nhpq : p + 1 = q\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = 0"}]}
{"declaration": "lemma id :\n    (fst \u03c6).1.comp (inl \u03c6) (add_neg_cancel 1) +\n      (snd \u03c6).comp (Cochain.ofHom (inr \u03c6)) (add_zero 0) = Cochain.ofHom (\ud835\udfd9 _) := by\n  simp [ext_cochain_from_iff \u03c6 (-1) 0 (neg_add_cancel 1)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex", "HomComplex"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]", "{\u03b9 : Type*} [AddRightCancelSemigroup \u03b9] [One \u03b9]", "{F G : CochainComplex C \u2124} (\u03c6 : F \u27f6 G)", "[HasHomotopyCofiber \u03c6]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_4\nfst : x\u271d\u00b9\nx\u271d : Sort u_5\nsnd : x\u271d\n\u22a2 sorry + sorry = sorry"}, {"line": "simp [ext_cochain_from_iff \u03c6 (-1) 0 (neg_add_cancel 1)]", "tactic_state": "x\u271d\u00b9 : Sort u_4\nfst : x\u271d\u00b9\nx\u271d : Sort u_5\nsnd : x\u271d\n\u22a2 sorry () + sorry () = sorry ()"}]}
{"declaration": "lemma inl_descCochain :\n    (inl \u03c6).comp (descCochain \u03c6 \u03b1 \u03b2 h) (by omega) = \u03b1 := by\n  simp [descCochain]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex", "HomComplex"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]", "{\u03b9 : Type*} [AddRightCancelSemigroup \u03b9] [One \u03b9]", "{F G : CochainComplex C \u2124} (\u03c6 : F \u27f6 G)", "[HasHomotopyCofiber \u03c6]", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain F K m) (\u03b2 : Cochain G K n) (h : m + 1 = n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Cochain : ?m.5214\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.5224, u_1} C\ninst\u271d\u2075 : Category.{?u.5228, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d : sorry\n\u03b2 : sorry\nh : m + 1 = n\n\u03b1 : sorry\nx\u271d : Sort u_4\ninl : x\u271d\n\u22a2 sorry = \u03b1"}, {"line": "simp [descCochain]", "tactic_state": "Cochain : ?m.5214\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.5224, u_1} C\ninst\u271d\u2075 : Category.{?u.5228, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d : sorry\n\u03b2 : sorry\nh : m + 1 = n\n\u03b1 : sorry\nx\u271d : Sort u_4\ninl : x\u271d\n\u22a2 sorry () = \u03b1"}]}
{"declaration": "lemma inr_descCochain :\n    (Cochain.ofHom (inr \u03c6)).comp (descCochain \u03c6 \u03b1 \u03b2 h) (zero_add n) = \u03b2 := by\n  simp [descCochain]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex", "HomComplex"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]", "{\u03b9 : Type*} [AddRightCancelSemigroup \u03b9] [One \u03b9]", "{F G : CochainComplex C \u2124} (\u03c6 : F \u27f6 G)", "[HasHomotopyCofiber \u03c6]", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain F K m) (\u03b2 : Cochain G K n) (h : m + 1 = n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Cochain : ?m.5214\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.5224, u_1} C\ninst\u271d\u2075 : Category.{?u.5228, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK : CochainComplex C \u2124\nn m : \u2124\n\u03b1 : sorry\n\u03b2\u271d : sorry\nh : m + 1 = n\n\u03b2 : sorry\n\u22a2 sorry = \u03b2"}, {"line": "simp [descCochain]", "tactic_state": "Cochain : ?m.5214\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.5224, u_1} C\ninst\u271d\u2075 : Category.{?u.5228, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK : CochainComplex C \u2124\nn m : \u2124\n\u03b1 : sorry\n\u03b2\u271d : sorry\nh : m + 1 = n\n\u03b2 : sorry\n\u22a2 sorry () = \u03b2"}]}
{"declaration": "lemma ofHom_desc :\n    Cochain.ofHom (desc \u03c6 \u03b1 \u03b2 eq) = descCochain \u03c6 \u03b1 (Cochain.ofHom \u03b2) (neg_add_cancel 1) := by\n  simp [desc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex", "HomComplex"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]", "{\u03b9 : Type*} [AddRightCancelSemigroup \u03b9] [One \u03b9]", "{F G : CochainComplex C \u2124} (\u03c6 : F \u27f6 G)", "[HasHomotopyCofiber \u03c6]", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain F K m) (\u03b2 : Cochain G K n) (h : m + 1 = n)", "{K : CochainComplex C \u2124}", "(\u03b1 : Cochain F K (-1)) (\u03b2 : G \u27f6 K) (eq : \u03b4 (-1) 0 \u03b1 = Cochain.ofHom (\u03c6 \u226b \u03b2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Cochain : ?m.11798\n\u03b4 : ?m.12977\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.12987, u_1} C\ninst\u271d\u2075 : Category.{?u.12991, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d : sorry\nh : m + 1 = n\nK : CochainComplex C \u2124\n\u03b1 : sorry\n\u03b2 : G \u27f6 K\neq : sorry = sorry\nx\u271d : Sort u_4\ndescCochain : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [desc]", "tactic_state": "Cochain : ?m.11798\n\u03b4 : ?m.12977\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.12987, u_1} C\ninst\u271d\u2075 : Category.{?u.12991, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d : sorry\nh : m + 1 = n\nK : CochainComplex C \u2124\n\u03b1 : sorry\n\u03b2 : G \u27f6 K\neq : sorry = sorry\nx\u271d : Sort u_4\ndescCochain : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma inl_v_desc_f (p q : \u2124) (h : p + (-1) = q) :\n    (inl \u03c6).v p q h \u226b (desc \u03c6 \u03b1 \u03b2 eq).f q = \u03b1.v p q h := by\n  simp [desc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex", "HomComplex"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]", "{\u03b9 : Type*} [AddRightCancelSemigroup \u03b9] [One \u03b9]", "{F G : CochainComplex C \u2124} (\u03c6 : F \u27f6 G)", "[HasHomotopyCofiber \u03c6]", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain F K m) (\u03b2 : Cochain G K n) (h : m + 1 = n)", "{K : CochainComplex C \u2124}", "(\u03b1 : Cochain F K (-1)) (\u03b2 : G \u27f6 K) (eq : \u03b4 (-1) 0 \u03b1 = Cochain.ofHom (\u03c6 \u226b \u03b2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Cochain : ?m.11798\n\u03b4 : ?m.12977\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.12987, u_1} C\ninst\u271d\u2075 : Category.{?u.12991, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d : sorry\nh\u271d : m + 1 = n\nK : CochainComplex C \u2124\n\u03b1 : sorry\n\u03b2 : G \u27f6 K\neq : sorry = sorry\nx\u271d\u00b9 : Sort u_4\ninl : x\u271d\u00b9\nx\u271d : Sort u_5\ndesc : x\u271d\np q : \u2124\nh : p + -1 = q\n\u22a2 CategoryStruct.comp sorry sorry = sorry"}, {"line": "simp [desc]", "tactic_state": "Cochain : ?m.11798\n\u03b4 : ?m.12977\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.12987, u_1} C\ninst\u271d\u2075 : Category.{?u.12991, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d : sorry\nh\u271d : m + 1 = n\nK : CochainComplex C \u2124\n\u03b1 : sorry\n\u03b2 : G \u27f6 K\neq : sorry = sorry\nx\u271d\u00b9 : Sort u_4\ninl : x\u271d\u00b9\nx\u271d : Sort u_5\ndesc : x\u271d\np q : \u2124\nh : p + -1 = q\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "lemma inl_desc :\n    (inl \u03c6).comp (Cochain.ofHom (desc \u03c6 \u03b1 \u03b2 eq)) (add_zero _) = \u03b1 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex", "HomComplex"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]", "{\u03b9 : Type*} [AddRightCancelSemigroup \u03b9] [One \u03b9]", "{F G : CochainComplex C \u2124} (\u03c6 : F \u27f6 G)", "[HasHomotopyCofiber \u03c6]", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain F K m) (\u03b2 : Cochain G K n) (h : m + 1 = n)", "{K : CochainComplex C \u2124}", "(\u03b1 : Cochain F K (-1)) (\u03b2 : G \u27f6 K) (eq : \u03b4 (-1) 0 \u03b1 = Cochain.ofHom (\u03c6 \u226b \u03b2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Cochain : ?m.11798\n\u03b4 : ?m.12977\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.12987, u_1} C\ninst\u271d\u2075 : Category.{?u.12991, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d : sorry\nh : m + 1 = n\nK : CochainComplex C \u2124\n\u03b1\u271d : sorry\n\u03b2 : G \u27f6 K\neq : sorry = sorry\n\u03b1 : sorry\nx\u271d : Sort u_4\ninl : x\u271d\n\u22a2 sorry = \u03b1"}, {"line": "simp", "tactic_state": "Cochain : ?m.11798\n\u03b4 : ?m.12977\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.12987, u_1} C\ninst\u271d\u2075 : Category.{?u.12991, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d : sorry\nh : m + 1 = n\nK : CochainComplex C \u2124\n\u03b1\u271d : sorry\n\u03b2 : G \u27f6 K\neq : sorry = sorry\n\u03b1 : sorry\nx\u271d : Sort u_4\ninl : x\u271d\n\u22a2 sorry () = \u03b1"}]}
{"declaration": "lemma liftCochain_fst :\n    (liftCochain \u03c6 \u03b1 \u03b2 h).comp (fst \u03c6).1 h = \u03b1 := by\n  simp [liftCochain]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex", "HomComplex"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]", "{\u03b9 : Type*} [AddRightCancelSemigroup \u03b9] [One \u03b9]", "{F G : CochainComplex C \u2124} (\u03c6 : F \u27f6 G)", "[HasHomotopyCofiber \u03c6]", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain F K m) (\u03b2 : Cochain G K n) (h : m + 1 = n)", "{K : CochainComplex C \u2124}", "(\u03b1 : Cochain F K (-1)) (\u03b2 : G \u27f6 K) (eq : \u03b4 (-1) 0 \u03b1 = Cochain.ofHom (\u03c6 \u226b \u03b2))", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain K F m) (\u03b2 : Cochain K G n) (h : n + 1 = m)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Cochain : ?m.22070\n\u03b4 : ?m.23249\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.23259, u_1} C\ninst\u271d\u2075 : Category.{?u.23263, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d\u00b9 : CochainComplex C \u2124\nn\u271d m\u271d : \u2124\n\u03b1\u271d\u00b2 : sorry\n\u03b2\u271d\u00b9 : sorry\nh\u271d : m\u271d + 1 = n\u271d\nK\u271d : CochainComplex C \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d : G \u27f6 K\u271d\neq : sorry = sorry\nK : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d : sorry\n\u03b2 : sorry\nh : n + 1 = m\n\u03b1 : sorry\nx\u271d : Sort u_4\nliftCochain : x\u271d\n\u22a2 sorry = \u03b1"}, {"line": "simp [liftCochain]", "tactic_state": "Cochain : ?m.22070\n\u03b4 : ?m.23249\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.23259, u_1} C\ninst\u271d\u2075 : Category.{?u.23263, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d\u00b9 : CochainComplex C \u2124\nn\u271d m\u271d : \u2124\n\u03b1\u271d\u00b2 : sorry\n\u03b2\u271d\u00b9 : sorry\nh\u271d : m\u271d + 1 = n\u271d\nK\u271d : CochainComplex C \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d : G \u27f6 K\u271d\neq : sorry = sorry\nK : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d : sorry\n\u03b2 : sorry\nh : n + 1 = m\n\u03b1 : sorry\nx\u271d : Sort u_4\nliftCochain : x\u271d\n\u22a2 sorry () = \u03b1"}]}
{"declaration": "lemma liftCochain_snd :\n    (liftCochain \u03c6 \u03b1 \u03b2 h).comp (snd \u03c6) (add_zero n) = \u03b2 := by\n  simp [liftCochain]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex", "HomComplex"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]", "{\u03b9 : Type*} [AddRightCancelSemigroup \u03b9] [One \u03b9]", "{F G : CochainComplex C \u2124} (\u03c6 : F \u27f6 G)", "[HasHomotopyCofiber \u03c6]", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain F K m) (\u03b2 : Cochain G K n) (h : m + 1 = n)", "{K : CochainComplex C \u2124}", "(\u03b1 : Cochain F K (-1)) (\u03b2 : G \u27f6 K) (eq : \u03b4 (-1) 0 \u03b1 = Cochain.ofHom (\u03c6 \u226b \u03b2))", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain K F m) (\u03b2 : Cochain K G n) (h : n + 1 = m)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Cochain : ?m.22070\n\u03b4 : ?m.23249\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.23259, u_1} C\ninst\u271d\u2075 : Category.{?u.23263, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d\u00b9 : CochainComplex C \u2124\nn\u271d m\u271d : \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d\u00b2 : sorry\nh\u271d : m\u271d + 1 = n\u271d\nK\u271d : CochainComplex C \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d\u00b9 : G \u27f6 K\u271d\neq : sorry = sorry\nK : CochainComplex C \u2124\nn m : \u2124\n\u03b1 : sorry\n\u03b2\u271d : sorry\nh : n + 1 = m\n\u03b2 : sorry\nx\u271d : Sort u_4\nliftCochain : x\u271d\n\u22a2 sorry = \u03b2"}, {"line": "simp [liftCochain]", "tactic_state": "Cochain : ?m.22070\n\u03b4 : ?m.23249\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.23259, u_1} C\ninst\u271d\u2075 : Category.{?u.23263, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d\u00b9 : CochainComplex C \u2124\nn\u271d m\u271d : \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d\u00b2 : sorry\nh\u271d : m\u271d + 1 = n\u271d\nK\u271d : CochainComplex C \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d\u00b9 : G \u27f6 K\u271d\neq : sorry = sorry\nK : CochainComplex C \u2124\nn m : \u2124\n\u03b1 : sorry\n\u03b2\u271d : sorry\nh : n + 1 = m\n\u03b2 : sorry\nx\u271d : Sort u_4\nliftCochain : x\u271d\n\u22a2 sorry () = \u03b2"}]}
{"declaration": "lemma lift_f_fst_v (p q : \u2124) (hpq : p + 1 = q) :\n    (lift \u03c6 \u03b1 \u03b2 eq).f p \u226b (fst \u03c6).1.v p q hpq = \u03b1.1.v p q hpq := by\n  simp [lift]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex", "HomComplex"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]", "{\u03b9 : Type*} [AddRightCancelSemigroup \u03b9] [One \u03b9]", "{F G : CochainComplex C \u2124} (\u03c6 : F \u27f6 G)", "[HasHomotopyCofiber \u03c6]", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain F K m) (\u03b2 : Cochain G K n) (h : m + 1 = n)", "{K : CochainComplex C \u2124}", "(\u03b1 : Cochain F K (-1)) (\u03b2 : G \u27f6 K) (eq : \u03b4 (-1) 0 \u03b1 = Cochain.ofHom (\u03c6 \u226b \u03b2))", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain K F m) (\u03b2 : Cochain K G n) (h : n + 1 = m)", "{K : CochainComplex C \u2124} (\u03b1 : Cocycle K F 1) (\u03b2 : Cochain K G 0)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Cochain : ?m.28528\n\u03b4 : ?m.29707\nCocycle : ?m.30985\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.30995, u_1} C\ninst\u271d\u2075 : Category.{?u.30999, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d\u00b2 : CochainComplex C \u2124\nn\u271d m\u271d : \u2124\n\u03b1\u271d\u00b2 : sorry\n\u03b2\u271d\u00b2 : sorry\nh\u271d : m\u271d + 1 = n\u271d\nK\u271d\u00b9 : CochainComplex C \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d\u00b9 : G \u27f6 K\u271d\u00b9\neq : sorry = sorry\nK\u271d : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d : sorry\nh : n + 1 = m\nK : CochainComplex C \u2124\n\u03b1 : sorry\n\u03b2 : sorry\nx\u271d\u00b9 : Sort u_4\nlift : x\u271d\u00b9\nx\u271d : Sort u_5\nfst : x\u271d\np q : \u2124\nhpq : p + 1 = q\n\u22a2 CategoryStruct.comp sorry sorry = sorry"}, {"line": "simp [lift]", "tactic_state": "Cochain : ?m.28528\n\u03b4 : ?m.29707\nCocycle : ?m.30985\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.30995, u_1} C\ninst\u271d\u2075 : Category.{?u.30999, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d\u00b2 : CochainComplex C \u2124\nn\u271d m\u271d : \u2124\n\u03b1\u271d\u00b2 : sorry\n\u03b2\u271d\u00b2 : sorry\nh\u271d : m\u271d + 1 = n\u271d\nK\u271d\u00b9 : CochainComplex C \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d\u00b9 : G \u27f6 K\u271d\u00b9\neq : sorry = sorry\nK\u271d : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d : sorry\nh : n + 1 = m\nK : CochainComplex C \u2124\n\u03b1 : sorry\n\u03b2 : sorry\nx\u271d\u00b9 : Sort u_4\nlift : x\u271d\u00b9\nx\u271d : Sort u_5\nfst : x\u271d\np q : \u2124\nhpq : p + 1 = q\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "lemma lift_fst :\n    (Cochain.ofHom (lift \u03c6 \u03b1 \u03b2 eq)).comp (fst \u03c6).1 (zero_add 1) = \u03b1.1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex", "HomComplex"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]", "{\u03b9 : Type*} [AddRightCancelSemigroup \u03b9] [One \u03b9]", "{F G : CochainComplex C \u2124} (\u03c6 : F \u27f6 G)", "[HasHomotopyCofiber \u03c6]", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain F K m) (\u03b2 : Cochain G K n) (h : m + 1 = n)", "{K : CochainComplex C \u2124}", "(\u03b1 : Cochain F K (-1)) (\u03b2 : G \u27f6 K) (eq : \u03b4 (-1) 0 \u03b1 = Cochain.ofHom (\u03c6 \u226b \u03b2))", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain K F m) (\u03b2 : Cochain K G n) (h : n + 1 = m)", "{K : CochainComplex C \u2124} (\u03b1 : Cocycle K F 1) (\u03b2 : Cochain K G 0)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Cochain : ?m.28528\n\u03b4 : ?m.29707\nCocycle : ?m.30985\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.30995, u_1} C\ninst\u271d\u2075 : Category.{?u.30999, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d\u00b2 : CochainComplex C \u2124\nn\u271d m\u271d : \u2124\n\u03b1\u271d\u00b2 : sorry\n\u03b2\u271d\u00b2 : sorry\nh\u271d : m\u271d + 1 = n\u271d\nK\u271d\u00b9 : CochainComplex C \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d\u00b9 : G \u27f6 K\u271d\u00b9\neq : sorry = sorry\nK\u271d : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d : sorry\nh : n + 1 = m\nK : CochainComplex C \u2124\n\u03b1 : sorry\n\u03b2 : sorry\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "Cochain : ?m.28528\n\u03b4 : ?m.29707\nCocycle : ?m.30985\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.30995, u_1} C\ninst\u271d\u2075 : Category.{?u.30999, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d\u00b2 : CochainComplex C \u2124\nn\u271d m\u271d : \u2124\n\u03b1\u271d\u00b2 : sorry\n\u03b2\u271d\u00b2 : sorry\nh\u271d : m\u271d + 1 = n\u271d\nK\u271d\u00b9 : CochainComplex C \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d\u00b9 : G \u27f6 K\u271d\u00b9\neq : sorry = sorry\nK\u271d : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d : sorry\nh : n + 1 = m\nK : CochainComplex C \u2124\n\u03b1 : sorry\n\u03b2 : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma lift_snd :\n    (Cochain.ofHom (lift \u03c6 \u03b1 \u03b2 eq)).comp (snd \u03c6) (zero_add 0) = \u03b2 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex", "HomComplex"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]", "{\u03b9 : Type*} [AddRightCancelSemigroup \u03b9] [One \u03b9]", "{F G : CochainComplex C \u2124} (\u03c6 : F \u27f6 G)", "[HasHomotopyCofiber \u03c6]", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain F K m) (\u03b2 : Cochain G K n) (h : m + 1 = n)", "{K : CochainComplex C \u2124}", "(\u03b1 : Cochain F K (-1)) (\u03b2 : G \u27f6 K) (eq : \u03b4 (-1) 0 \u03b1 = Cochain.ofHom (\u03c6 \u226b \u03b2))", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain K F m) (\u03b2 : Cochain K G n) (h : n + 1 = m)", "{K : CochainComplex C \u2124} (\u03b1 : Cocycle K F 1) (\u03b2 : Cochain K G 0)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Cochain : ?m.28528\n\u03b4 : ?m.29707\nCocycle : ?m.30985\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.30995, u_1} C\ninst\u271d\u2075 : Category.{?u.30999, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d\u00b2 : CochainComplex C \u2124\nn\u271d m\u271d : \u2124\n\u03b1\u271d\u00b2 : sorry\n\u03b2\u271d\u00b3 : sorry\nh\u271d : m\u271d + 1 = n\u271d\nK\u271d\u00b9 : CochainComplex C \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d\u00b2 : G \u27f6 K\u271d\u00b9\neq : sorry = sorry\nK\u271d : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d\u00b9 : sorry\nh : n + 1 = m\nK : CochainComplex C \u2124\n\u03b1 : sorry\n\u03b2\u271d \u03b2 : sorry\n\u22a2 sorry = \u03b2"}, {"line": "simp", "tactic_state": "Cochain : ?m.28528\n\u03b4 : ?m.29707\nCocycle : ?m.30985\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.30995, u_1} C\ninst\u271d\u2075 : Category.{?u.30999, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d\u00b2 : CochainComplex C \u2124\nn\u271d m\u271d : \u2124\n\u03b1\u271d\u00b2 : sorry\n\u03b2\u271d\u00b3 : sorry\nh\u271d : m\u271d + 1 = n\u271d\nK\u271d\u00b9 : CochainComplex C \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d\u00b2 : G \u27f6 K\u271d\u00b9\neq : sorry = sorry\nK\u271d : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d\u00b9 : sorry\nh : n + 1 = m\nK : CochainComplex C \u2124\n\u03b1 : sorry\n\u03b2\u271d \u03b2 : sorry\n\u22a2 sorry () = \u03b2"}]}
{"declaration": "lemma lift_f (p q : \u2124) (hpq : p + 1 = q) :\n    (lift \u03c6 \u03b1 \u03b2 eq).f p = \u03b1.1.v p q hpq \u226b\n      (inl \u03c6).v q p (by omega) + \u03b2.v p p (add_zero p) \u226b (inr \u03c6).f p := by\n  simp [ext_to_iff _ _ _ hpq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex", "HomComplex"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]", "{\u03b9 : Type*} [AddRightCancelSemigroup \u03b9] [One \u03b9]", "{F G : CochainComplex C \u2124} (\u03c6 : F \u27f6 G)", "[HasHomotopyCofiber \u03c6]", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain F K m) (\u03b2 : Cochain G K n) (h : m + 1 = n)", "{K : CochainComplex C \u2124}", "(\u03b1 : Cochain F K (-1)) (\u03b2 : G \u27f6 K) (eq : \u03b4 (-1) 0 \u03b1 = Cochain.ofHom (\u03c6 \u226b \u03b2))", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain K F m) (\u03b2 : Cochain K G n) (h : n + 1 = m)", "{K : CochainComplex C \u2124} (\u03b1 : Cocycle K F 1) (\u03b2 : Cochain K G 0)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Cochain : ?m.28528\n\u03b4 : ?m.29707\nCocycle : ?m.30985\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.30995, u_1} C\ninst\u271d\u2075 : Category.{?u.30999, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d\u00b2 : CochainComplex C \u2124\nn\u271d m\u271d : \u2124\n\u03b1\u271d\u00b2 : sorry\n\u03b2\u271d\u00b2 : sorry\nh\u271d : m\u271d + 1 = n\u271d\nK\u271d\u00b9 : CochainComplex C \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d\u00b9 : G \u27f6 K\u271d\u00b9\neq : sorry = sorry\nK\u271d : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d : sorry\nh : n + 1 = m\nK : CochainComplex C \u2124\n\u03b1 : sorry\n\u03b2 : sorry\nx\u271d\u00b2 : Sort u_4\nlift : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\ninl : x\u271d\u00b9\nx\u271d : Sort u_6\ninr : x\u271d\np q : \u2124\nhpq : p + 1 = q\n\u22a2 sorry = CategoryStruct.comp sorry sorry + CategoryStruct.comp sorry sorry"}, {"line": "simp [ext_to_iff _ _ _ hpq]", "tactic_state": "Cochain : ?m.28528\n\u03b4 : ?m.29707\nCocycle : ?m.30985\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.30995, u_1} C\ninst\u271d\u2075 : Category.{?u.30999, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d\u00b2 : CochainComplex C \u2124\nn\u271d m\u271d : \u2124\n\u03b1\u271d\u00b2 : sorry\n\u03b2\u271d\u00b2 : sorry\nh\u271d : m\u271d + 1 = n\u271d\nK\u271d\u00b9 : CochainComplex C \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d\u00b9 : G \u27f6 K\u271d\u00b9\neq : sorry = sorry\nK\u271d : CochainComplex C \u2124\nn m : \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d : sorry\nh : n + 1 = m\nK : CochainComplex C \u2124\n\u03b1 : sorry\n\u03b2 : sorry\nx\u271d\u00b2 : Sort u_4\nlift : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_5\ninl : x\u271d\u00b9\nx\u271d : Sort u_6\ninr : x\u271d\np q : \u2124\nhpq : p + 1 = q\n\u22a2 sorry () = CategoryStruct.comp (sorry ()) (sorry ()) + CategoryStruct.comp (sorry ()) (sorry ())"}]}
{"declaration": "lemma liftCochain_descCochain :\n    (liftCochain \u03c6 \u03b1 \u03b2 h).comp (descCochain \u03c6 \u03b1' \u03b2' h') hp =\n      \u03b1.comp \u03b1' (by omega) + \u03b2.comp \u03b2' (by omega) := by\n  simp [liftCochain, descCochain,\n    Cochain.comp_assoc \u03b1 (inl \u03c6) _ _ (show -1 + n' = m' by omega) (by linarith)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex", "HomComplex"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]", "{\u03b9 : Type*} [AddRightCancelSemigroup \u03b9] [One \u03b9]", "{F G : CochainComplex C \u2124} (\u03c6 : F \u27f6 G)", "[HasHomotopyCofiber \u03c6]", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain F K m) (\u03b2 : Cochain G K n) (h : m + 1 = n)", "{K : CochainComplex C \u2124}", "(\u03b1 : Cochain F K (-1)) (\u03b2 : G \u27f6 K) (eq : \u03b4 (-1) 0 \u03b1 = Cochain.ofHom (\u03c6 \u226b \u03b2))", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain K F m) (\u03b2 : Cochain K G n) (h : n + 1 = m)", "{K : CochainComplex C \u2124} (\u03b1 : Cocycle K F 1) (\u03b2 : Cochain K G 0)", "{K L : CochainComplex C \u2124} {n m : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Cochain : ?m.36656\n\u03b4 : ?m.37835\nCocycle : ?m.39113\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.39123, u_1} C\ninst\u271d\u2075 : Category.{?u.39127, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d\u00b3 : CochainComplex C \u2124\nn\u271d\u00b9 m\u271d\u00b9 : \u2124\n\u03b1\u271d\u00b2 : sorry\n\u03b2\u271d\u00b2 : sorry\nh\u271d : m\u271d\u00b9 + 1 = n\u271d\u00b9\nK\u271d\u00b2 : CochainComplex C \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d\u00b9 : G \u27f6 K\u271d\u00b2\neq : sorry = sorry\nK\u271d\u00b9 : CochainComplex C \u2124\nn\u271d m\u271d : \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d : sorry\nh : n\u271d + 1 = m\u271d\nK\u271d : CochainComplex C \u2124\n\u03b1 : sorry\n\u03b2 : sorry\nK L : CochainComplex C \u2124\nn m : \u2124\nx\u271d : Sort u_4\nliftCochain : x\u271d\n\u22a2 sorry = sorry + sorry"}, {"line": "simp [liftCochain, descCochain,\n    Cochain.comp_assoc \u03b1 (inl \u03c6) _ _ (show -1 + n' = m' by omega) (by linarith)]", "tactic_state": "Cochain : ?m.36656\n\u03b4 : ?m.37835\nCocycle : ?m.39113\nC : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{?u.39123, u_1} C\ninst\u271d\u2075 : Category.{?u.39127, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK\u271d\u00b3 : CochainComplex C \u2124\nn\u271d\u00b9 m\u271d\u00b9 : \u2124\n\u03b1\u271d\u00b2 : sorry\n\u03b2\u271d\u00b2 : sorry\nh\u271d : m\u271d\u00b9 + 1 = n\u271d\u00b9\nK\u271d\u00b2 : CochainComplex C \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d\u00b9 : G \u27f6 K\u271d\u00b2\neq : sorry = sorry\nK\u271d\u00b9 : CochainComplex C \u2124\nn\u271d m\u271d : \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d : sorry\nh : n\u271d + 1 = m\u271d\nK\u271d : CochainComplex C \u2124\n\u03b1 : sorry\n\u03b2 : sorry\nK L : CochainComplex C \u2124\nn m : \u2124\nx\u271d : Sort u_4\nliftCochain : x\u271d\n\u22a2 sorry () = sorry () + sorry ()"}]}
{"declaration": "lemma mapHomologicalComplexXIso_eq (n m : \u2124) (hnm : n + 1 = m) :\n    mapHomologicalComplexXIso \u03c6 H n = mapHomologicalComplexXIso' \u03c6 H n m hnm := by\n  subst hnm\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean", "context": {"open": ["CategoryTheory Limits", "HomologicalComplex", "HomComplex", "Preadditive Category"], "variables": ["{C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]", "{\u03b9 : Type*} [AddRightCancelSemigroup \u03b9] [One \u03b9]", "{F G : CochainComplex C \u2124} (\u03c6 : F \u27f6 G)", "[HasHomotopyCofiber \u03c6]", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain F K m) (\u03b2 : Cochain G K n) (h : m + 1 = n)", "{K : CochainComplex C \u2124}", "(\u03b1 : Cochain F K (-1)) (\u03b2 : G \u27f6 K) (eq : \u03b4 (-1) 0 \u03b1 = Cochain.ofHom (\u03c6 \u226b \u03b2))", "{K : CochainComplex C \u2124} {n m : \u2124}", "(\u03b1 : Cochain K F m) (\u03b2 : Cochain K G n) (h : n + 1 = m)", "{K : CochainComplex C \u2124} (\u03b1 : Cocycle K F 1) (\u03b2 : Cochain K G 0)", "{K L : CochainComplex C \u2124} {n m : \u2124}", "(H : C \u2964 D) [H.Additive]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Cochain : ?m.44808\n\u03b4 : ?m.45987\nCocycle : ?m.47265\nC : Type u_1\nD : Type u_2\ninst\u271d\u2077 : Category.{?u.47275, u_1} C\ninst\u271d\u2076 : Category.{?u.47279, u_2} D\ninst\u271d\u2075 : Preadditive C\ninst\u271d\u2074 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b3 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b2 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d\u00b9 : HasHomotopyCofiber \u03c6\nK\u271d\u00b3 : CochainComplex C \u2124\nn\u271d\u00b2 m\u271d\u00b2 : \u2124\n\u03b1\u271d\u00b2 : sorry\n\u03b2\u271d\u00b2 : sorry\nh\u271d : m\u271d\u00b2 + 1 = n\u271d\u00b2\nK\u271d\u00b2 : CochainComplex C \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d\u00b9 : G \u27f6 K\u271d\u00b2\neq : sorry = sorry\nK\u271d\u00b9 : CochainComplex C \u2124\nn\u271d\u00b9 m\u271d\u00b9 : \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d : sorry\nh : n\u271d\u00b9 + 1 = m\u271d\u00b9\nK\u271d : CochainComplex C \u2124\n\u03b1 : sorry\n\u03b2 : sorry\nK L : CochainComplex C \u2124\nn\u271d m\u271d : \u2124\nH : CategoryTheory.Functor C D\ninst\u271d : H.Additive\nx\u271d\u00b9 : Sort u_4\nmapHomologicalComplexXIso : x\u271d\u00b9\nx\u271d : Sort u_5\nmapHomologicalComplexXIso' : x\u271d\nn m : \u2124\nhnm : n + 1 = m\n\u22a2 sorry = sorry"}, {"line": "subst hnm", "tactic_state": "Cochain : ?m.44808\n\u03b4 : ?m.45987\nCocycle : ?m.47265\nC : Type u_1\nD : Type u_2\ninst\u271d\u2077 : Category.{?u.47275, u_1} C\ninst\u271d\u2076 : Category.{?u.47279, u_2} D\ninst\u271d\u2075 : Preadditive C\ninst\u271d\u2074 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b3 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b2 : One \u03b9\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d\u00b9 : HasHomotopyCofiber \u03c6\nK\u271d\u00b3 : CochainComplex C \u2124\nn\u271d\u00b2 m\u271d\u00b9 : \u2124\n\u03b1\u271d\u00b2 : sorry\n\u03b2\u271d\u00b2 : sorry\nh\u271d : m\u271d\u00b9 + 1 = n\u271d\u00b2\nK\u271d\u00b2 : CochainComplex C \u2124\n\u03b1\u271d\u00b9 : sorry\n\u03b2\u271d\u00b9 : G \u27f6 K\u271d\u00b2\neq : sorry = sorry\nK\u271d\u00b9 : CochainComplex C \u2124\nn\u271d\u00b9 m\u271d : \u2124\n\u03b1\u271d : sorry\n\u03b2\u271d : sorry\nh : n\u271d\u00b9 + 1 = m\u271d\nK\u271d : CochainComplex C \u2124\n\u03b1 : sorry\n\u03b2 : sorry\nK L : CochainComplex C \u2124\nn\u271d m : \u2124\nH : CategoryTheory.Functor C D\ninst\u271d : H.Additive\nx\u271d\u00b9 : Sort u_4\nmapHomologicalComplexXIso : x\u271d\u00b9\nx\u271d : Sort u_5\nmapHomologicalComplexXIso' : x\u271d\nn : \u2124\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inl_v_descShortComplex_f (i j : \u2124) (h : i + (-1) = j) :\n    (inl S.f).v i j h \u226b (descShortComplex S).f j = 0 := by\n  simp [descShortComplex]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/ShortExact.lean", "context": {"open": ["CategoryTheory Category ComplexShape HomotopyCategory Limits"], "variables": ["{C : Type*} [Category C] [Abelian C]", "(S : ShortComplex (CochainComplex C \u2124)) (hS : S.ShortExact)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\ninl : x\u271d\u00b9\nx\u271d : Sort u_3\ndescShortComplex : x\u271d\ni j : \u2124\nh : i + -1 = j\n\u22a2 CategoryStruct.comp sorry sorry = 0"}, {"line": "simp [descShortComplex]", "tactic_state": "x\u271d\u00b9 : Sort u_2\ninl : x\u271d\u00b9\nx\u271d : Sort u_3\ndescShortComplex : x\u271d\ni j : \u2124\nh : i + -1 = j\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = 0"}]}
{"declaration": "lemma homOfDegreewiseSplit_f (n : \u2124) :\n    (homOfDegreewiseSplit S \u03c3).f n =\n      (cocycleOfDegreewiseSplit S \u03c3).1.v n (n + 1) rfl := by\n  simp [homOfDegreewiseSplit, Cochain.rightShift_v _ _ _ _ _ _ _ _ rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/DegreewiseSplit.lean", "context": {"open": ["CategoryTheory Category Limits Pretriangulated Preadditive", "HomologicalComplex HomComplex"], "variables": ["{C : Type*} [Category C] [Preadditive C]", "(S : ShortComplex (CochainComplex C \u2124))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nhomOfDegreewiseSplit : x\u271d\u00b9\nx\u271d : Sort u_3\ncocycleOfDegreewiseSplit : x\u271d\nn : \u2124\n\u22a2 sorry = sorry"}, {"line": "simp [homOfDegreewiseSplit, Cochain.rightShift_v _ _ _ _ _ _ _ _ rfl]", "tactic_state": "x\u271d\u00b9 : Sort u_2\nhomOfDegreewiseSplit : x\u271d\u00b9\nx\u271d : Sort u_3\ncocycleOfDegreewiseSplit : x\u271d\nn : \u2124\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma triangleMapOfHomotopy_comm\u2082 :\n    inr \u03c6\u2081 \u226b mapOfHomotopy H = b \u226b inr \u03c6\u2082 := by\n  simp [mapOfHomotopy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/Pretriangulated.lean", "context": {"open": ["CategoryTheory Category Limits CochainComplex.HomComplex Pretriangulated"], "variables": ["{C D : Type*} [Category C] [Category D]", "(K) in", "{K\u2081 L\u2081 K\u2082 L\u2082 K\u2083 L\u2083 : CochainComplex C \u2124} {\u03c6\u2081 : K\u2081 \u27f6 L\u2081} {\u03c6\u2082 : K\u2082 \u27f6 L\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_3\ninr : x\u271d\u00b9\nx\u271d : Sort u_4\nmapOfHomotopy : x\u271d\nobj\u271d : Type u_5\nself\u271d : CategoryStruct.{u_6, u_5} obj\u271d\na\u271d\u00b9 a\u271d : obj\u271d\nb : a\u271d\u00b9 \u27f6 a\u271d\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.comp b sorry"}, {"line": "simp [mapOfHomotopy]", "tactic_state": "x\u271d\u00b9 : Sort u_3\ninr : x\u271d\u00b9\nx\u271d : Sort u_4\nmapOfHomotopy : x\u271d\nobj\u271d : Type u_5\nself\u271d : CategoryStruct.{u_6, u_5} obj\u271d\na\u271d\u00b9 a\u271d : obj\u271d\nb : a\u271d\u00b9 \u27f6 a\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.comp b (sorry ())"}]}
{"declaration": "lemma mappingConeCompHomotopyEquiv_hom_inv_id :\n    (mappingConeCompHomotopyEquiv f g).hom \u226b\n      (mappingConeCompHomotopyEquiv f g).inv = \ud835\udfd9 _ := by\n  simp [mappingConeCompHomotopyEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/Triangulated.lean", "context": {"open": ["CategoryTheory Category Limits Pretriangulated ComposableArrows", "HomComplex mappingCone"], "variables": ["{C : Type*} [Category C] [Preadditive C] [HasBinaryBiproducts C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nmappingConeCompHomotopyEquiv : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = CategoryStruct.id ?m.2284"}, {"line": "simp [mappingConeCompHomotopyEquiv]", "tactic_state": "x\u271d : Sort u_2\nmappingConeCompHomotopyEquiv : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = CategoryStruct.id ?m.2284"}]}
{"declaration": "lemma mappingConeCompHomotopyEquiv_comm\u2081 :\n    inr (map f (f \u226b g) (\ud835\udfd9 X\u2081) g (by rw [id_comp])) \u226b\n      (mappingConeCompHomotopyEquiv f g).inv = (mappingConeCompTriangle f g).mor\u2082 := by\n  simp [map, mappingConeCompHomotopyEquiv, MappingConeCompHomotopyEquiv.inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/HomotopyCategory/Triangulated.lean", "context": {"open": ["CategoryTheory Category Limits Pretriangulated ComposableArrows", "HomComplex mappingCone"], "variables": ["{C : Type*} [Category C] [Preadditive C] [HasBinaryBiproducts C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_2\ninr : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_3\nmappingConeCompHomotopyEquiv : x\u271d\u00b9\nx\u271d : Sort u_4\nmappingConeCompTriangle : x\u271d\n\u22a2 CategoryStruct.comp sorry sorry = sorry"}, {"line": "simp [map, mappingConeCompHomotopyEquiv, MappingConeCompHomotopyEquiv.inv]", "tactic_state": "x\u271d\u00b2 : Sort u_2\ninr : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_3\nmappingConeCompHomotopyEquiv : x\u271d\u00b9\nx\u271d : Sort u_4\nmappingConeCompTriangle : x\u271d\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "lemma Exact.mono_g_iff (hS : S.Exact) : Mono S.g \u2194 S.f = 0 := by\n  constructor\n  \u00b7 intro\n    rw [\u2190 cancel_mono S.g]\n    rw [zero]\n    rw [zero_comp]\n  \u00b7 exact hS.mono_g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/ShortComplex/Exact.lean", "context": {"open": ["Category Limits ZeroObject Preadditive"], "variables": ["{C D : Type*} [Category C] [Category D]", "", "{S}", "(S)", "{S}", "(S)", "{S}", "(S)", "{S}", "(S)", "{S}", "(S)", "{S}", "(S)", "{S}", "[Preadditive C] [Preadditive D] (S : ShortComplex C)", "{S}", "(S)", "{S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nMono : x\u271d\nhS : sorry\n\u22a2 sorry \u2194 sorry = 0"}, {"line": "constructor", "tactic_state": "case mp\nx\u271d : Sort u_1\nMono : x\u271d\nhS : sorry\n\u22a2 sorry \u2192 sorry = 0\n---\ncase mpr\nx\u271d : Sort u_1\nMono : x\u271d\nhS : sorry\n\u22a2 sorry = 0 \u2192 sorry"}, {"line": "\u00b7 intro\n    rw [\u2190 cancel_mono S.g]\n    rw [zero]\n    rw [zero_comp]", "tactic_state": "case mpr\nx\u271d : Sort u_1\nMono : x\u271d\nhS : sorry\n\u22a2 sorry = 0 \u2192 sorry"}, {"line": "\u00b7 exact hS.mono_g", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Exact.epi_f_iff (hS : S.Exact) : Epi S.f \u2194 S.g = 0 := by\n  constructor\n  \u00b7 intro\n    rw [\u2190 cancel_epi S.f]\n    rw [zero]\n    rw [comp_zero]\n  \u00b7 exact hS.epi_f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/ShortComplex/Exact.lean", "context": {"open": ["Category Limits ZeroObject Preadditive"], "variables": ["{C D : Type*} [Category C] [Category D]", "", "{S}", "(S)", "{S}", "(S)", "{S}", "(S)", "{S}", "(S)", "{S}", "(S)", "{S}", "(S)", "{S}", "[Preadditive C] [Preadditive D] (S : ShortComplex C)", "{S}", "(S)", "{S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nEpi : x\u271d\nhS : sorry\n\u22a2 sorry \u2194 sorry = 0"}, {"line": "constructor", "tactic_state": "case mp\nx\u271d : Sort u_1\nEpi : x\u271d\nhS : sorry\n\u22a2 sorry \u2192 sorry = 0\n---\ncase mpr\nx\u271d : Sort u_1\nEpi : x\u271d\nhS : sorry\n\u22a2 sorry = 0 \u2192 sorry"}, {"line": "\u00b7 intro\n    rw [\u2190 cancel_epi S.f]\n    rw [zero]\n    rw [comp_zero]", "tactic_state": "case mpr\nx\u271d : Sort u_1\nEpi : x\u271d\nhS : sorry\n\u22a2 sorry = 0 \u2192 sorry"}, {"line": "\u00b7 exact hS.epi_f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Exact.isZero_X\u2082_iff (hS : S.Exact) : IsZero S.X\u2082 \u2194 S.f = 0 \u2227 S.g = 0 := by\n  constructor\n  \u00b7 intro h\n    exact \u27e8h.eq_of_tgt _ _, h.eq_of_src _ _\u27e9\n  \u00b7 rintro \u27e8hf, hg\u27e9\n    exact hS.isZero_X\u2082 hf hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/ShortComplex/Exact.lean", "context": {"open": ["Category Limits ZeroObject Preadditive"], "variables": ["{C D : Type*} [Category C] [Category D]", "", "{S}", "(S)", "{S}", "(S)", "{S}", "(S)", "{S}", "(S)", "{S}", "(S)", "{S}", "(S)", "{S}", "[Preadditive C] [Preadditive D] (S : ShortComplex C)", "{S}", "(S)", "{S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nIsZero : x\u271d\nhS : sorry\n\u22a2 sorry \u2194 sorry = 0 \u2227 sorry = 0"}, {"line": "constructor", "tactic_state": "case mp\nx\u271d : Sort u_1\nIsZero : x\u271d\nhS : sorry\n\u22a2 sorry \u2192 sorry = 0 \u2227 sorry = 0\n---\ncase mpr\nx\u271d : Sort u_1\nIsZero : x\u271d\nhS : sorry\n\u22a2 sorry = 0 \u2227 sorry = 0 \u2192 sorry"}, {"line": "\u00b7 intro h\n    exact \u27e8h.eq_of_tgt _ _, h.eq_of_src _ _\u27e9", "tactic_state": "case mpr\nx\u271d : Sort u_1\nIsZero : x\u271d\nhS : sorry\n\u22a2 sorry = 0 \u2227 sorry = 0 \u2192 sorry"}, {"line": "\u00b7 rintro \u27e8hf, hg\u27e9\n    exact hS.isZero_X\u2082 hf hg", "tactic_state": "No Goals!"}]}
{"declaration": "lemma quasiIso_iff (\u03c6 : S\u2081 \u27f6 S\u2082) :\n    QuasiIso \u03c6 \u2194 IsIso (homologyMap \u03c6) := by\n  constructor\n  \u00b7 intro h\n    infer_instance\n  \u00b7 intro h\n    exact \u27e8h\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/ShortComplex/QuasiIso.lean", "context": {"open": ["Category Limits"], "variables": ["{C : Type _} [Category C] [HasZeroMorphisms C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9\u271d : Type u_1\nobj\u271d : Type u_2\ninst\u271d\u00b9 : CategoryTheory.Category.{u_3, u_2} obj\u271d\ninst\u271d : CategoryTheory.Limits.HasZeroMorphisms obj\u271d\nc\u271d : ComplexShape \u03b9\u271d\nS\u2081 S\u2082 : HomologicalComplex obj\u271d c\u271d\nx\u271d : Sort u_4\nIsIso : x\u271d\n\u03c6 : S\u2081 \u27f6 S\u2082\n\u22a2 QuasiIso \u03c6 \u2194 sorry"}, {"line": "constructor", "tactic_state": "case mp\n\u03b9\u271d : Type u_1\nobj\u271d : Type u_2\ninst\u271d\u00b9 : CategoryTheory.Category.{u_3, u_2} obj\u271d\ninst\u271d : CategoryTheory.Limits.HasZeroMorphisms obj\u271d\nc\u271d : ComplexShape \u03b9\u271d\nS\u2081 S\u2082 : HomologicalComplex obj\u271d c\u271d\nx\u271d : Sort u_4\nIsIso : x\u271d\n\u03c6 : S\u2081 \u27f6 S\u2082\n\u22a2 QuasiIso \u03c6 \u2192 sorry\n---\ncase mpr\n\u03b9\u271d : Type u_1\nobj\u271d : Type u_2\ninst\u271d\u00b9 : CategoryTheory.Category.{u_3, u_2} obj\u271d\ninst\u271d : CategoryTheory.Limits.HasZeroMorphisms obj\u271d\nc\u271d : ComplexShape \u03b9\u271d\nS\u2081 S\u2082 : HomologicalComplex obj\u271d c\u271d\nx\u271d : Sort u_4\nIsIso : x\u271d\n\u03c6 : S\u2081 \u27f6 S\u2082\n\u22a2 sorry \u2192 QuasiIso \u03c6"}, {"line": "\u00b7 intro h\n    infer_instance", "tactic_state": "case mpr\n\u03b9\u271d : Type u_1\nobj\u271d : Type u_2\ninst\u271d\u00b9 : CategoryTheory.Category.{u_3, u_2} obj\u271d\ninst\u271d : CategoryTheory.Limits.HasZeroMorphisms obj\u271d\nc\u271d : ComplexShape \u03b9\u271d\nS\u2081 S\u2082 : HomologicalComplex obj\u271d c\u271d\nx\u271d : Sort u_4\nIsIso : x\u271d\n\u03c6 : S\u2081 \u27f6 S\u2082\n\u22a2 sorry \u2192 QuasiIso \u03c6"}, {"line": "\u00b7 intro h\n    exact \u27e8h\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma quasiIso_iff_isIso_liftCycles (\u03c6 : S\u2081 \u27f6 S\u2082)\n    (hf\u2081 : S\u2081.f = 0) (hg\u2081 : S\u2081.g = 0) (hf\u2082 : S\u2082.f = 0) :\n    QuasiIso \u03c6 \u2194 IsIso (S\u2082.liftCycles \u03c6.\u03c4\u2082 (by rw [\u03c6.comm\u2082\u2083, hg\u2081, zero_comp])) := by\n  let H : LeftHomologyMapData \u03c6 (LeftHomologyData.ofZeros S\u2081 hf\u2081 hg\u2081)\n      (LeftHomologyData.ofIsLimitKernelFork S\u2082 hf\u2082 _ S\u2082.cyclesIsKernel) :=\n    { \u03c6K := S\u2082.liftCycles \u03c6.\u03c4\u2082 (by rw [\u03c6.comm\u2082\u2083, hg\u2081, zero_comp])\n      \u03c6H := S\u2082.liftCycles \u03c6.\u03c4\u2082 (by rw [\u03c6.comm\u2082\u2083, hg\u2081, zero_comp]) }\n  exact H.quasiIso_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/ShortComplex/QuasiIso.lean", "context": {"open": ["Category Limits"], "variables": ["{C : Type _} [Category C] [HasZeroMorphisms C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9\u271d : Type u_1\nobj\u271d : Type u_2\ninst\u271d\u00b9 : CategoryTheory.Category.{u_3, u_2} obj\u271d\ninst\u271d : CategoryTheory.Limits.HasZeroMorphisms obj\u271d\nc\u271d : ComplexShape \u03b9\u271d\nS\u2081 S\u2082 : HomologicalComplex obj\u271d c\u271d\nx\u271d : Sort u_4\nIsIso : x\u271d\n\u03c6 : S\u2081 \u27f6 S\u2082\nhf\u2081 : sorry = 0\nhg\u2081 : sorry = 0\nhf\u2082 : sorry = 0\n\u22a2 QuasiIso \u03c6 \u2194 sorry"}, {"line": "let H : LeftHomologyMapData \u03c6 (LeftHomologyData.ofZeros S\u2081 hf\u2081 hg\u2081)\n      (LeftHomologyData.ofIsLimitKernelFork S\u2082 hf\u2082 _ S\u2082.cyclesIsKernel) :=\n    { \u03c6K := S\u2082.liftCycles \u03c6.\u03c4\u2082 (by rw [\u03c6.comm\u2082\u2083, hg\u2081, zero_comp])\n      \u03c6H := S\u2082.liftCycles \u03c6.\u03c4\u2082 (by rw [\u03c6.comm\u2082\u2083, hg\u2081, zero_comp]) }", "tactic_state": "\u03b9\u271d : Type u_1\nobj\u271d : Type u_2\ninst\u271d\u00b9 : CategoryTheory.Category.{u_3, u_2} obj\u271d\ninst\u271d : CategoryTheory.Limits.HasZeroMorphisms obj\u271d\nc\u271d : ComplexShape \u03b9\u271d\nS\u2081 S\u2082 : HomologicalComplex obj\u271d c\u271d\nx\u271d : Sort u_4\nIsIso : x\u271d\n\u03c6 : S\u2081 \u27f6 S\u2082\nhf\u2081 : sorry = 0\nhg\u2081 : sorry = 0\nhf\u2082 : sorry = 0\nH : sorry := sorry\n\u22a2 QuasiIso \u03c6 \u2194 sorry"}, {"line": "exact H.quasiIso_iff", "tactic_state": "No Goals!"}]}
{"declaration": "lemma quasiIso_iff_isIso_descOpcycles (\u03c6 : S\u2081 \u27f6 S\u2082)\n    (hg\u2081 : S\u2081.g = 0) (hf\u2082 : S\u2082.f = 0) (hg\u2082 : S\u2082.g = 0) :\n    QuasiIso \u03c6 \u2194 IsIso (S\u2081.descOpcycles \u03c6.\u03c4\u2082 (by rw [\u2190 \u03c6.comm\u2081\u2082, hf\u2082, comp_zero])) := by\n  let H : RightHomologyMapData \u03c6\n      (RightHomologyData.ofIsColimitCokernelCofork S\u2081 hg\u2081 _ S\u2081.opcyclesIsCokernel)\n        (RightHomologyData.ofZeros S\u2082 hf\u2082 hg\u2082) :=\n    { \u03c6Q := S\u2081.descOpcycles \u03c6.\u03c4\u2082 (by rw [\u2190 \u03c6.comm\u2081\u2082, hf\u2082, comp_zero])\n      \u03c6H := S\u2081.descOpcycles \u03c6.\u03c4\u2082 (by rw [\u2190 \u03c6.comm\u2081\u2082, hf\u2082, comp_zero]) }\n  exact H.quasiIso_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/ShortComplex/QuasiIso.lean", "context": {"open": ["Category Limits"], "variables": ["{C : Type _} [Category C] [HasZeroMorphisms C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9\u271d : Type u_1\nobj\u271d : Type u_2\ninst\u271d\u00b9 : CategoryTheory.Category.{u_3, u_2} obj\u271d\ninst\u271d : CategoryTheory.Limits.HasZeroMorphisms obj\u271d\nc\u271d : ComplexShape \u03b9\u271d\nS\u2081 S\u2082 : HomologicalComplex obj\u271d c\u271d\nx\u271d : Sort u_4\nIsIso : x\u271d\n\u03c6 : S\u2081 \u27f6 S\u2082\nhg\u2081 : sorry = 0\nhf\u2082 : sorry = 0\nhg\u2082 : sorry = 0\n\u22a2 QuasiIso \u03c6 \u2194 sorry"}, {"line": "let H : RightHomologyMapData \u03c6\n      (RightHomologyData.ofIsColimitCokernelCofork S\u2081 hg\u2081 _ S\u2081.opcyclesIsCokernel)\n        (RightHomologyData.ofZeros S\u2082 hf\u2082 hg\u2082) :=\n    { \u03c6Q := S\u2081.descOpcycles \u03c6.\u03c4\u2082 (by rw [\u2190 \u03c6.comm\u2081\u2082, hf\u2082, comp_zero])\n      \u03c6H := S\u2081.descOpcycles \u03c6.\u03c4\u2082 (by rw [\u2190 \u03c6.comm\u2081\u2082, hf\u2082, comp_zero]) }", "tactic_state": "\u03b9\u271d : Type u_1\nobj\u271d : Type u_2\ninst\u271d\u00b9 : CategoryTheory.Category.{u_3, u_2} obj\u271d\ninst\u271d : CategoryTheory.Limits.HasZeroMorphisms obj\u271d\nc\u271d : ComplexShape \u03b9\u271d\nS\u2081 S\u2082 : HomologicalComplex obj\u271d c\u271d\nx\u271d : Sort u_4\nIsIso : x\u271d\n\u03c6 : S\u2081 \u27f6 S\u2082\nhg\u2081 : sorry = 0\nhf\u2082 : sorry = 0\nhg\u2082 : sorry = 0\nH : sorry := sorry\n\u22a2 QuasiIso \u03c6 \u2194 sorry"}, {"line": "exact H.quasiIso_iff", "tactic_state": "No Goals!"}]}
{"declaration": "lemma shortExact_iff_of_iso (e : S\u2081 \u2245 S\u2082) : S\u2081.ShortExact \u2194 S\u2082.ShortExact := by\n  constructor\n  \u00b7 exact shortExact_of_iso e\n  \u00b7 exact shortExact_of_iso e.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/ShortComplex/ShortExact.lean", "context": {"open": ["Category Limits ZeroObject"], "variables": ["{C D : Type*} [Category C] [Category D]", "[HasZeroMorphisms C] [HasZeroMorphisms D]", "{S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C\u271d : Type u_1\nS\u2081 S\u2082 : C\u271d\ne : S\u2081 \u2245 S\u2082\n\u22a2 sorry \u2194 sorry"}, {"line": "constructor", "tactic_state": "case mp\nC\u271d : Type u_1\nS\u2081 S\u2082 : C\u271d\ne : S\u2081 \u2245 S\u2082\n\u22a2 sorry \u2192 sorry\n---\ncase mpr\nC\u271d : Type u_1\nS\u2081 S\u2082 : C\u271d\ne : S\u2081 \u2245 S\u2082\n\u22a2 sorry \u2192 sorry"}, {"line": "\u00b7 exact shortExact_of_iso e", "tactic_state": "case mpr\nC\u271d : Type u_1\nS\u2081 S\u2082 : C\u271d\ne : S\u2081 \u2245 S\u2082\n\u22a2 sorry \u2192 sorry"}, {"line": "\u00b7 exact shortExact_of_iso e.symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iCycles_d : K.iCycles i \u226b K.d i j = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 obtain rfl := c.next_eq' hij\n    exact (K.sc i).iCycles_g\n  \u00b7 rw [K.shape _ _ hij, comp_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/ShortComplex/HomologicalComplex.lean", "context": {"open": ["CategoryTheory Category Limits"], "variables": ["(C : Type*) [Category C] [HasZeroMorphisms C] {\u03b9 : Type*} (c : ComplexShape \u03b9)", "{C c}", "(K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c8 : L \u27f6 M) (i j k : \u03b9)", "[K.HasHomology i]", "{i}", "(i)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : HasZeroMorphisms C\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\nK : HomologicalComplex C c\ni j : \u03b9\ninst\u271d : K.HasHomology i\n\u22a2 CategoryStruct.comp (K.iCycles i) (K.d i j) = 0"}, {"line": "by_cases hij : c.Rel i j", "tactic_state": "case pos\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : HasZeroMorphisms C\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\nK : HomologicalComplex C c\ni j : \u03b9\ninst\u271d : K.HasHomology i\nhij : c.Rel i j\n\u22a2 CategoryStruct.comp (K.iCycles i) (K.d i j) = 0\n---\ncase neg\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : HasZeroMorphisms C\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\nK : HomologicalComplex C c\ni j : \u03b9\ninst\u271d : K.HasHomology i\nhij : \u00acc.Rel i j\n\u22a2 CategoryStruct.comp (K.iCycles i) (K.d i j) = 0"}, {"line": "\u00b7 obtain rfl := c.next_eq' hij\n    exact (K.sc i).iCycles_g", "tactic_state": "case neg\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : HasZeroMorphisms C\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\nK : HomologicalComplex C c\ni j : \u03b9\ninst\u271d : K.HasHomology i\nhij : \u00acc.Rel i j\n\u22a2 CategoryStruct.comp (K.iCycles i) (K.d i j) = 0"}, {"line": "\u00b7 rw [K.shape _ _ hij, comp_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma d_pOpcycles [K.HasHomology j] : K.d i j \u226b K.pOpcycles j = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 obtain rfl := c.prev_eq' hij\n    exact (K.sc j).f_pOpcycles\n  \u00b7 rw [K.shape _ _ hij, zero_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/ShortComplex/HomologicalComplex.lean", "context": {"open": ["CategoryTheory Category Limits"], "variables": ["(C : Type*) [Category C] [HasZeroMorphisms C] {\u03b9 : Type*} (c : ComplexShape \u03b9)", "{C c}", "(K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c8 : L \u27f6 M) (i j k : \u03b9)", "[K.HasHomology i]", "{i}", "(i)", "[K.HasHomology i]", "{i j} in", "{i}", "[K.HasHomology i]", "(i)", "[K.HasHomology i]", "{i}", "(i)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d\u2076 : Category.{u_3, u_1} C\ninst\u271d\u2075 : HasZeroMorphisms C\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\nK : HomologicalComplex C c\ni j : \u03b9\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : K.HasHomology i\ninst\u271d : K.HasHomology j\n\u22a2 CategoryStruct.comp (K.d i j) (K.pOpcycles j) = 0"}, {"line": "by_cases hij : c.Rel i j", "tactic_state": "case pos\nC : Type u_1\ninst\u271d\u2076 : Category.{u_3, u_1} C\ninst\u271d\u2075 : HasZeroMorphisms C\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\nK : HomologicalComplex C c\ni j : \u03b9\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : K.HasHomology i\ninst\u271d : K.HasHomology j\nhij : c.Rel i j\n\u22a2 CategoryStruct.comp (K.d i j) (K.pOpcycles j) = 0\n---\ncase neg\nC : Type u_1\ninst\u271d\u2076 : Category.{u_3, u_1} C\ninst\u271d\u2075 : HasZeroMorphisms C\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\nK : HomologicalComplex C c\ni j : \u03b9\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : K.HasHomology i\ninst\u271d : K.HasHomology j\nhij : \u00acc.Rel i j\n\u22a2 CategoryStruct.comp (K.d i j) (K.pOpcycles j) = 0"}, {"line": "\u00b7 obtain rfl := c.prev_eq' hij\n    exact (K.sc j).f_pOpcycles", "tactic_state": "case neg\nC : Type u_1\ninst\u271d\u2076 : Category.{u_3, u_1} C\ninst\u271d\u2075 : HasZeroMorphisms C\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\nK : HomologicalComplex C c\ni j : \u03b9\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : K.HasHomology i\ninst\u271d : K.HasHomology j\nhij : \u00acc.Rel i j\n\u22a2 CategoryStruct.comp (K.d i j) (K.pOpcycles j) = 0"}, {"line": "\u00b7 rw [K.shape _ _ hij, zero_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exactAt_iff :\n    K.ExactAt i \u2194 (K.sc i).Exact := by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/ShortComplex/HomologicalComplex.lean", "context": {"open": ["CategoryTheory Category Limits"], "variables": ["(C : Type*) [Category C] [HasZeroMorphisms C] {\u03b9 : Type*} (c : ComplexShape \u03b9)", "{C c}", "(K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c8 : L \u27f6 M) (i j k : \u03b9)", "[K.HasHomology i]", "{i}", "(i)", "[K.HasHomology i]", "{i j} in", "{i}", "[K.HasHomology i]", "(i)", "[K.HasHomology i]", "{i}", "(i)", "{i j} in", "{i}", "(i)", "{K L M}", "[L.HasHomology i] [M.HasHomology i]", "(K)", "{K}", "(K L)", "{K L}", "{i}", "(C c i)", "(hj : c.next i = j) (h : K.d i j = 0) [K.HasHomology i]", "(hi : c.prev j = i) (h : K.d i j = 0) [K.HasHomology j]", "{K L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d\u2076 : Category.{u_3, u_1} C\ninst\u271d\u2075 : HasZeroMorphisms C\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\nK : HomologicalComplex C c\ni : \u03b9\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : K.HasHomology i\n\u22a2 K.ExactAt i \u2194 (K.sc i).Exact"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma acyclic_iff :\n    K.Acyclic \u2194 \u2200 i, K.ExactAt i := by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Homology/ShortComplex/HomologicalComplex.lean", "context": {"open": ["CategoryTheory Category Limits"], "variables": ["(C : Type*) [Category C] [HasZeroMorphisms C] {\u03b9 : Type*} (c : ComplexShape \u03b9)", "{C c}", "(K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c8 : L \u27f6 M) (i j k : \u03b9)", "[K.HasHomology i]", "{i}", "(i)", "[K.HasHomology i]", "{i j} in", "{i}", "[K.HasHomology i]", "(i)", "[K.HasHomology i]", "{i}", "(i)", "{i j} in", "{i}", "(i)", "{K L M}", "[L.HasHomology i] [M.HasHomology i]", "(K)", "{K}", "(K L)", "{K L}", "{i}", "(C c i)", "(hj : c.next i = j) (h : K.d i j = 0) [K.HasHomology i]", "(hi : c.prev j = i) (h : K.d i j = 0) [K.HasHomology j]", "{K L}", "{K i} in", "{K i} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u_1\ninst\u271d\u00b9 : Category.{u_3, u_1} C\ninst\u271d : HasZeroMorphisms C\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\nK : HomologicalComplex C c\n\u22a2 K.Acyclic \u2194 \u2200 (i : \u03b9), K.ExactAt i"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LieSubmodule.lie_abelian_iff_lie_self_eq_bot : IsLieAbelian I \u2194 \u2045I, I\u2046 = \u22a5 := by\n  simp only [_root_.eq_bot_iff]\n  simp only [lieIdeal_oper_eq_span]\n  simp only [LieSubmodule.lieSpan_le]\n  simp only [LieSubmodule.bot_coe]\n  simp only [Set.subset_singleton_iff]\n  simp only [Set.mem_setOf_eq]\n  simp only [exists_imp]\n  refine\n    \u27e8fun h z x y hz =>\n      hz.symm.trans\n        (((I : LieSubalgebra R L).coe_bracket x y).symm.trans\n          ((coe_zero_iff_zero _ _).mpr (by apply h.trivial))),\n      fun h => \u27e8fun x y => ((I : LieSubalgebra R L).coe_zero_iff_zero _).mp (h _ x y rfl)\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Abelian.lean", "context": {"open": ["LieSubmodule LieSubalgebra"], "variables": ["(R : Type u) (L : Type v) (M : Type w) (N : Type w\u2081)", "[CommRing R] [LieRing L] [LieAlgebra R L]", "[AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M]", "[AddCommGroup N] [Module R N] [LieRingModule L N] [LieModule R L N]", "{R L M N}", "{R L}", "{x : L} (hx : x \u2208 LieAlgebra.center R L) (y : L)", "{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M] (N N' : LieSubmodule R L M) (I J : LieIdeal R L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nI : LieIdeal R L\n\u22a2 IsLieAbelian \u21a5I \u2194 \u2045I, I\u2046 = \u22a5"}, {"line": "simp only [_root_.eq_bot_iff]", "tactic_state": "R : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nI : LieIdeal R L\n\u22a2 IsLieAbelian \u21a5I \u2194 \u2045I, I\u2046 \u2264 \u22a5"}, {"line": "simp only [lieIdeal_oper_eq_span]", "tactic_state": "R : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nI : LieIdeal R L\n\u22a2 IsLieAbelian \u21a5I \u2194 lieSpan R L {x | \u2203 x_1 n, \u2045\u2191x_1, \u2191n\u2046 = x} \u2264 \u22a5"}, {"line": "simp only [LieSubmodule.lieSpan_le]", "tactic_state": "R : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nI : LieIdeal R L\n\u22a2 IsLieAbelian \u21a5I \u2194 {x | \u2203 x_1 n, \u2045\u2191x_1, \u2191n\u2046 = x} \u2286 \u2191\u22a5"}, {"line": "simp only [LieSubmodule.bot_coe]", "tactic_state": "R : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nI : LieIdeal R L\n\u22a2 IsLieAbelian \u21a5I \u2194 {x | \u2203 x_1 n, \u2045\u2191x_1, \u2191n\u2046 = x} \u2286 {0}"}, {"line": "simp only [Set.subset_singleton_iff]", "tactic_state": "R : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nI : LieIdeal R L\n\u22a2 IsLieAbelian \u21a5I \u2194 \u2200 y \u2208 {x | \u2203 x_1 n, \u2045\u2191x_1, \u2191n\u2046 = x}, y = 0"}, {"line": "simp only [Set.mem_setOf_eq]", "tactic_state": "R : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nI : LieIdeal R L\n\u22a2 IsLieAbelian \u21a5I \u2194 \u2200 (y : L), (\u2203 x n, \u2045\u2191x, \u2191n\u2046 = y) \u2192 y = 0"}, {"line": "simp only [exists_imp]", "tactic_state": "R : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nI : LieIdeal R L\n\u22a2 IsLieAbelian \u21a5I \u2194 \u2200 (y : L) (x x_1 : \u21a5I), \u2045\u2191x, \u2191x_1\u2046 = y \u2192 y = 0"}, {"line": "refine\n    \u27e8fun h z x y hz =>\n      hz.symm.trans\n        (((I : LieSubalgebra R L).coe_bracket x y).symm.trans\n          ((coe_zero_iff_zero _ _).mpr (by apply h.trivial))),\n      fun h => \u27e8fun x y => ((I : LieSubalgebra R L).coe_zero_iff_zero _).mp (h _ x y rfl)\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LieAlgebra.isEngelian_of_subsingleton [Subsingleton L] : LieAlgebra.IsEngelian R L := by\n  intro M _i1 _i2 _i3 _i4 _h\n  use 1\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Engel.lean", "context": {"open": ["LieModule", "LieModule hiding IsNilpotent"], "variables": ["{R : Type u\u2081} {L : Type u\u2082} {L\u2082 : Type u\u2083} {M : Type u\u2084}", "[CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L\u2082] [LieAlgebra R L\u2082]", "[AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M]", "{I : LieIdeal R L} {x : L} (hxI : (R \u2219 x) \u2294 I = \u22a4)", "(R L)", "{R L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\u2081\nL : Type u\u2082\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : Subsingleton L\n\u22a2 IsEngelian R L"}, {"line": "intro M _i1 _i2 _i3 _i4 _h", "tactic_state": "R : Type u\u2081\nL : Type u\u2082\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : Subsingleton L\nM : Type u_1\n_i1 : AddCommGroup M\n_i2 : Module R M\n_i3 : LieRingModule L M\n_i4 : LieModule R L M\n_h : \u2200 (x : L), _root_.IsNilpotent ((toEnd R L M) x)\n\u22a2 LieModule.IsNilpotent L M"}, {"line": "use 1", "tactic_state": "case h\nR : Type u\u2081\nL : Type u\u2082\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : Subsingleton L\nM : Type u_1\n_i1 : AddCommGroup M\n_i2 : Module R M\n_i3 : LieRingModule L M\n_i4 : LieModule R L M\n_h : \u2200 (x : L), _root_.IsNilpotent ((toEnd R L M) x)\n\u22a2 LieModule.lowerCentralSeries \u2124 L M 1 = \u22a5"}, {"line": "simp", "tactic_state": "case h\nR : Type u\u2081\nL : Type u\u2082\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : Subsingleton L\nM : Type u_1\n_i1 : AddCommGroup M\n_i2 : Module R M\n_i3 : LieRingModule L M\n_i4 : LieModule R L M\n_h : \u2200 (x : L), _root_.IsNilpotent ((toEnd R L M) x)\n\u22a2 \u2045\u22a4, \u22a4\u2046 = \u22a5"}]}
{"declaration": "theorem Rel.neg {a b : lib R X} (h : Rel R X a b) : Rel R X (-a) (-b) := by\n  simpa only [neg_one_smul] using h.smul (-1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Free.lean", "context": {"open": [], "variables": ["(R : Type u) (X : Type v) [CommRing R]", "{R X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlib : x\u271d\na : sorry\nb : sorry\nh : sorry\n\u22a2 sorry"}, {"line": "simpa only [neg_one_smul] using h.smul (-1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Rel.subLeft (a : lib R X) {b c : lib R X} (h : Rel R X b c) : Rel R X (a - b) (a - c) := by\n  simpa only [sub_eq_add_neg] using h.neg.addLeft a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Free.lean", "context": {"open": [], "variables": ["(R : Type u) (X : Type v) [CommRing R]", "{R X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlib : x\u271d\na : sorry\nb : sorry\nc : sorry\nh : sorry\n\u22a2 sorry"}, {"line": "simpa only [sub_eq_add_neg] using h.neg.addLeft a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Rel.subRight {a b : lib R X} (c : lib R X) (h : Rel R X a b) : Rel R X (a - c) (b - c) := by\n  simpa only [sub_eq_add_neg] using h.add_right (-c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Free.lean", "context": {"open": [], "variables": ["(R : Type u) (X : Type v) [CommRing R]", "{R X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlib : x\u271d\na : sorry\nb : sorry\nc : sorry\nh : sorry\n\u22a2 sorry"}, {"line": "simpa only [sub_eq_add_neg] using h.add_right (-c)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma orthogonal_isCompl (I : LieIdeal K L) (hI : IsAtom I) :\n    IsCompl I (orthogonal \u03a6 h\u03a6_inv I) := by\n  rw [\u2190 LieSubmodule.isCompl_toSubmodule]\n  exact orthogonal_isCompl_toSubmodule \u03a6 h\u03a6_nondeg h\u03a6_inv h\u03a6_refl hL I hI\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/InvariantForm.lean", "context": {"open": ["Module Submodule in", "Module Submodule in"], "variables": ["{R L M : Type*}", "[CommRing R] [LieRing L]", "[AddCommGroup M] [Module R M] [LieRingModule L M]", "(\u03a6 : LinearMap.BilinForm R M) (h\u03a6_nondeg : \u03a6.Nondegenerate)", "(L) in", "(h\u03a6_inv : \u03a6.lieInvariant L)", "[LieAlgebra R L]", "{K L M : Type*}", "[Field K] [LieRing L] [LieAlgebra K L]", "[AddCommGroup M] [Module K M] [LieRingModule L M]", "[Module.Finite K L]", "(\u03a6 : LinearMap.BilinForm K L) (h\u03a6_nondeg : \u03a6.Nondegenerate)", "(h\u03a6_inv : \u03a6.lieInvariant L) (h\u03a6_refl : \u03a6.IsRefl)", "(hL : \u2200 I : LieIdeal K L, IsAtom I \u2192 \u00acIsLieAbelian I)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra K L\ninst\u271d : Module.Finite K L\nx\u271d : Sort u_4\northogonal : x\u271d\nI : LieIdeal K L\nhI : IsAtom I\n\u22a2 IsCompl I sorry"}, {"line": "rw [\u2190 LieSubmodule.isCompl_toSubmodule]", "tactic_state": "K : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra K L\ninst\u271d : Module.Finite K L\nx\u271d : Sort u_4\northogonal : x\u271d\nI : LieIdeal K L\nhI : IsAtom I\n\u22a2 IsCompl \u2191I \u2191sorry"}, {"line": "exact orthogonal_isCompl_toSubmodule \u03a6 h\u03a6_nondeg h\u03a6_inv h\u03a6_refl hL I hI", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_mk' : LieModuleHom.range (mk' N) = \u22a4 := by\n  simp [LieModuleHom.range_eq_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Quotient.lean", "context": {"open": [], "variables": ["{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(N N' : LieSubmodule R L M)", "{N}", "[LieAlgebra R L] [LieModule R L M] (I J : LieIdeal R L)", "(N)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nmk' : x\u271d\n\u22a2 sorry.range = \u22a4"}, {"line": "simp [LieModuleHom.range_eq_top]", "tactic_state": "x\u271d : Sort u_1\nmk' : x\u271d\n\u22a2 (sorry ()).range = \u22a4"}]}
{"declaration": "theorem skewAdjointLieSubalgebraEquiv_apply\n    (f : skewAdjointLieSubalgebra (B.compl\u2081\u2082 (Q\u2097 := N) (Q\u2097' := N) \u2191e \u2191e)) :\n    \u2191(skewAdjointLieSubalgebraEquiv B e f) = e.lieConj f := by\n  simp [skewAdjointLieSubalgebraEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/SkewAdjoint.lean", "context": {"open": ["LinearMap (BilinForm)"], "variables": ["{R : Type u} {M : Type v} [CommRing R] [AddCommGroup M] [Module R M]", "(B : BilinForm R M)", "{N : Type w} [AddCommGroup N] [Module R N] (e : N \u2243\u2097[R] M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\nB : BilinForm R M\nN : Type w\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\ne : N \u2243\u2097[R] M\nf : \u21a5(skewAdjointLieSubalgebra (LinearMap.compl\u2081\u2082 B \u2191e \u2191e))\n\u22a2 \u2191((skewAdjointLieSubalgebraEquiv B e) f) = e.lieConj \u2191f"}, {"line": "simp [skewAdjointLieSubalgebraEquiv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem skewAdjointLieSubalgebraEquiv_symm_apply (f : skewAdjointLieSubalgebra B) :\n    \u2191((skewAdjointLieSubalgebraEquiv B e).symm f) = e.symm.lieConj f := by\n  simp [skewAdjointLieSubalgebraEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/SkewAdjoint.lean", "context": {"open": ["LinearMap (BilinForm)"], "variables": ["{R : Type u} {M : Type v} [CommRing R] [AddCommGroup M] [Module R M]", "(B : BilinForm R M)", "{N : Type w} [AddCommGroup N] [Module R N] (e : N \u2243\u2097[R] M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\nB : BilinForm R M\nN : Type w\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\ne : N \u2243\u2097[R] M\nf : \u21a5(skewAdjointLieSubalgebra B)\n\u22a2 \u2191((skewAdjointLieSubalgebraEquiv B e).symm f) = e.symm.lieConj \u2191f"}, {"line": "simp [skewAdjointLieSubalgebraEquiv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem skewAdjointMatricesLieSubalgebraEquiv_apply (P : Matrix n n R) (h : Invertible P)\n    (A : skewAdjointMatricesLieSubalgebra J) :\n    \u2191(skewAdjointMatricesLieSubalgebraEquiv J P h A) = P\u207b\u00b9 * A * P := by\n  simp [skewAdjointMatricesLieSubalgebraEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/SkewAdjoint.lean", "context": {"open": ["LinearMap (BilinForm)", "scoped Matrix"], "variables": ["{R : Type u} {M : Type v} [CommRing R] [AddCommGroup M] [Module R M]", "(B : BilinForm R M)", "{N : Type w} [AddCommGroup N] [Module R N] (e : N \u2243\u2097[R] M)", "{R : Type u} {n : Type w} [CommRing R] [DecidableEq n] [Fintype n]", "(J : Matrix n n R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nn : Type w\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nJ P : Matrix n n R\nh : Invertible P\nA : \u21a5(skewAdjointMatricesLieSubalgebra J)\n\u22a2 \u2191((skewAdjointMatricesLieSubalgebraEquiv J P h) A) = P\u207b\u00b9 * \u2191A * P"}, {"line": "simp [skewAdjointMatricesLieSubalgebraEquiv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivedSeries_eq_top (n : \u2115) (h : derivedSeries R L 1 = \u22a4) :\n    derivedSeries R L n = \u22a4 := by\n  cases n\n  \u00b7 rfl\n  \u00b7 rwa [derivedSeries_succ_eq_top_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Solvable.lean", "context": {"open": ["TensorProduct in", "TensorProduct in", "LieAlgebra"], "variables": ["(R : Type u) (L : Type v) (M : Type w) {L' : Type w\u2081}", "[CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L']", "(I J : LieIdeal R L) {f : L' \u2192\u2097\u2045R\u2046 L}", "{R L}", "{R L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh : sorry = \u22a4\n\u22a2 sorry = \u22a4"}, {"line": "cases n", "tactic_state": "case zero\nh : sorry = \u22a4\n\u22a2 sorry = \u22a4\n---\ncase succ\nn\u271d : \u2115\nh : sorry = \u22a4\n\u22a2 sorry = \u22a4"}, {"line": "\u00b7 rfl", "tactic_state": "case succ\nn\u271d : \u2115\nh : sorry = \u22a4\n\u22a2 sorry = \u22a4"}, {"line": "\u00b7 rwa [derivedSeries_succ_eq_top_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isSolvable_iff : IsSolvable L \u2194 \u2203 k, derivedSeries R L k = \u22a5 := by\n  simp [isSolvable_iff_int, SetLike.ext'_iff, LieIdeal.coe_derivedSeries_eq_int]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Solvable.lean", "context": {"open": ["TensorProduct in", "TensorProduct in", "LieAlgebra"], "variables": ["(R : Type u) (L : Type v) (M : Type w) {L' : Type w\u2081}", "[CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L']", "(I J : LieIdeal R L) {f : L' \u2192\u2097\u2045R\u2046 L}", "{R L}", "{R L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry \u2194 \u2203 k, sorry = \u22a5"}, {"line": "simp [isSolvable_iff_int, SetLike.ext'_iff, LieIdeal.coe_derivedSeries_eq_int]", "tactic_state": "\u22a2 sorry () \u2194 \u2203 k, sorry () = \u22a5"}]}
{"declaration": "theorem solvable_iff_equiv_solvable (e : L' \u2243\u2097\u2045R\u2046 L) : IsSolvable L' \u2194 IsSolvable L := by\n  constructor <;> intro h\n  \u00b7 exact e.symm.injective.lieAlgebra_isSolvable\n  \u00b7 exact e.injective.lieAlgebra_isSolvable\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Solvable.lean", "context": {"open": ["TensorProduct in", "TensorProduct in", "LieAlgebra", "TensorProduct in", "TensorProduct in", "LieAlgebra"], "variables": ["(R : Type u) (L : Type v) (M : Type w) {L' : Type w\u2081}", "[CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L']", "(I J : LieIdeal R L) {f : L' \u2192\u2097\u2045R\u2046 L}", "{R L}", "{R L}", "{R L} in", "{A : Type*} [CommRing A] [Algebra R A] [Module.FaithfullyFlat R A] in", "{R L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nL' : Type w\u2081\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\ne : L' \u2243\u2097\u2045R\u2046 L\n\u22a2 sorry \u2194 sorry"}, {"line": "constructor <;> intro h", "tactic_state": "case mp\nR : Type u\nL : Type v\nL' : Type w\u2081\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\ne : L' \u2243\u2097\u2045R\u2046 L\nh : sorry\n\u22a2 sorry\n---\ncase mpr\nR : Type u\nL : Type v\nL' : Type w\u2081\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\ne : L' \u2243\u2097\u2045R\u2046 L\nh : sorry\n\u22a2 sorry"}, {"line": "\u00b7 exact e.symm.injective.lieAlgebra_isSolvable", "tactic_state": "case mpr\nR : Type u\nL : Type v\nL' : Type w\u2081\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\ne : L' \u2243\u2097\u2045R\u2046 L\nh : sorry\n\u22a2 sorry"}, {"line": "\u00b7 exact e.injective.lieAlgebra_isSolvable", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_\u03b9_apply' (x : L) :\n    lift R f ((UniversalEnvelopingAlgebra.mkAlgHom R L) (\u03b9\u209c x)) = f x := by\n  simpa using lift_\u03b9_apply R f x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/UniversalEnveloping.lean", "context": {"open": [], "variables": ["(R : Type u\u2081) (L : Type u\u2082)", "[CommRing R] [LieRing L] [LieAlgebra R L]", "{L}", "{A : Type u\u2083} [Ring A] [Algebra R A] (f : L \u2192\u2097\u2045R\u2046 A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\u2081\nL : Type u\u2082\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\nA : Type u\u2083\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nf : L \u2192\u2097\u2045R\u2046 A\nx\u271d : Sort u_1\nlift : x\u271d\nx : L\n\u22a2 sorry = f x"}, {"line": "simpa using lift_\u03b9_apply R f x", "tactic_state": "No Goals!"}]}
