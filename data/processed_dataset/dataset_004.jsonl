{"declaration": "lemma smul_neg_of_pos_of_neg [PosSMulStrictMono \u03b1 \u03b2] (ha : 0 < a) (hb : b < 0) : a \u2022 b < 0 := by\n  simpa only [smul_zero] using smul_lt_smul_of_pos_left hb ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/Defs.lean", "context": {"open": ["OrderDual"], "variables": ["(\u03b1 \u03b2 : Type*)", "[SMul \u03b1 \u03b2] [Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "{\u03b1 \u03b2} {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2}", "[Zero \u03b1] [Mul \u03b1] [Preorder \u03b1]", "[SMul \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2]", "[Preorder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[LinearOrder \u03b1] [Preorder \u03b2]", "[Zero \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3\u2070 : SMul \u03b1 \u03b2\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : Preorder \u03b2\ninst\u271d\u00b2\u2077 : Zero \u03b1\ninst\u271d\u00b2\u2076 : Zero \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d\u00b2\u2075 : Zero \u03b1\ninst\u271d\u00b2\u2074 : Mul \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : SMul \u03b1 \u03b2\ninst\u271d\u00b2\u00b9 : Preorder \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b2\ninst\u271d\u00b9\u2079 : Zero \u03b1\ninst\u271d\u00b9\u2078 : Zero \u03b2\ninst\u271d\u00b9\u2077 : Zero \u03b1\ninst\u271d\u00b9\u2076 : Zero \u03b2\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : LinearOrder \u03b2\ninst\u271d\u00b9\u00b3 : Zero \u03b1\ninst\u271d\u00b9\u00b2 : Zero \u03b2\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b2\ninst\u271d\u2079 : Zero \u03b2\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : LinearOrder \u03b2\ninst\u271d\u2076 : Zero \u03b2\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Zero \u03b2\ninst\u271d\u00b3 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : PosSMulStrictMono \u03b1 \u03b2\nha : 0 < a\nhb : b < 0\n\u22a2 a \u2022 b < 0"}, {"line": "simpa only [smul_zero] using smul_lt_smul_of_pos_left hb ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_pos_iff_of_pos_left [PosSMulStrictMono \u03b1 \u03b2] [PosSMulReflectLT \u03b1 \u03b2] (ha : 0 < a) :\n    0 < a \u2022 b \u2194 0 < b := by\n  simpa only [smul_zero] using smul_lt_smul_iff_of_pos_left ha (b\u2081 := 0) (b\u2082 := b)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/Defs.lean", "context": {"open": ["OrderDual"], "variables": ["(\u03b1 \u03b2 : Type*)", "[SMul \u03b1 \u03b2] [Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "{\u03b1 \u03b2} {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2}", "[Zero \u03b1] [Mul \u03b1] [Preorder \u03b1]", "[SMul \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2]", "[Preorder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[LinearOrder \u03b1] [Preorder \u03b2]", "[Zero \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3\u00b9 : SMul \u03b1 \u03b2\ninst\u271d\u00b3\u2070 : Preorder \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b2\ninst\u271d\u00b2\u2078 : Zero \u03b1\ninst\u271d\u00b2\u2077 : Zero \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d\u00b2\u2076 : Zero \u03b1\ninst\u271d\u00b2\u2075 : Mul \u03b1\ninst\u271d\u00b2\u2074 : Preorder \u03b1\ninst\u271d\u00b2\u00b3 : SMul \u03b1 \u03b2\ninst\u271d\u00b2\u00b2 : Preorder \u03b1\ninst\u271d\u00b2\u00b9 : Preorder \u03b2\ninst\u271d\u00b2\u2070 : Zero \u03b1\ninst\u271d\u00b9\u2079 : Zero \u03b2\ninst\u271d\u00b9\u2078 : Zero \u03b1\ninst\u271d\u00b9\u2077 : Zero \u03b2\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b2\ninst\u271d\u00b9\u2074 : Zero \u03b1\ninst\u271d\u00b9\u00b3 : Zero \u03b2\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Zero \u03b2\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : LinearOrder \u03b2\ninst\u271d\u2077 : Zero \u03b2\ninst\u271d\u2076 : Zero \u03b1\ninst\u271d\u2075 : Zero \u03b2\ninst\u271d\u2074 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : PosSMulStrictMono \u03b1 \u03b2\ninst\u271d : PosSMulReflectLT \u03b1 \u03b2\nha : 0 < a\n\u22a2 0 < a \u2022 b \u2194 0 < b"}, {"line": "simpa only [smul_zero] using smul_lt_smul_iff_of_pos_left ha (b\u2081 := 0) (b\u2082 := b)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_neg_iff_of_pos_left [PosSMulStrictMono \u03b1 \u03b2] [PosSMulReflectLT \u03b1 \u03b2] (ha : 0 < a) :\n    a \u2022 b < 0 \u2194 b < 0 := by\n  simpa only [smul_zero]  using smul_lt_smul_iff_of_pos_left ha (b\u2082 := (0 : \u03b2))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/Defs.lean", "context": {"open": ["OrderDual"], "variables": ["(\u03b1 \u03b2 : Type*)", "[SMul \u03b1 \u03b2] [Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "{\u03b1 \u03b2} {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2}", "[Zero \u03b1] [Mul \u03b1] [Preorder \u03b1]", "[SMul \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2]", "[Preorder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[LinearOrder \u03b1] [Preorder \u03b2]", "[Zero \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3\u00b9 : SMul \u03b1 \u03b2\ninst\u271d\u00b3\u2070 : Preorder \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b2\ninst\u271d\u00b2\u2078 : Zero \u03b1\ninst\u271d\u00b2\u2077 : Zero \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d\u00b2\u2076 : Zero \u03b1\ninst\u271d\u00b2\u2075 : Mul \u03b1\ninst\u271d\u00b2\u2074 : Preorder \u03b1\ninst\u271d\u00b2\u00b3 : SMul \u03b1 \u03b2\ninst\u271d\u00b2\u00b2 : Preorder \u03b1\ninst\u271d\u00b2\u00b9 : Preorder \u03b2\ninst\u271d\u00b2\u2070 : Zero \u03b1\ninst\u271d\u00b9\u2079 : Zero \u03b2\ninst\u271d\u00b9\u2078 : Zero \u03b1\ninst\u271d\u00b9\u2077 : Zero \u03b2\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b2\ninst\u271d\u00b9\u2074 : Zero \u03b1\ninst\u271d\u00b9\u00b3 : Zero \u03b2\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b9 : Preorder \u03b2\ninst\u271d\u00b9\u2070 : Zero \u03b2\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : LinearOrder \u03b2\ninst\u271d\u2077 : Zero \u03b2\ninst\u271d\u2076 : Zero \u03b1\ninst\u271d\u2075 : Zero \u03b2\ninst\u271d\u2074 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : PosSMulStrictMono \u03b1 \u03b2\ninst\u271d : PosSMulReflectLT \u03b1 \u03b2\nha : 0 < a\n\u22a2 a \u2022 b < 0 \u2194 b < 0"}, {"line": "simpa only [smul_zero]  using smul_lt_smul_iff_of_pos_left ha (b\u2082 := (0 : \u03b2))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_nonneg [PosSMulMono \u03b1 \u03b2] (ha : 0 \u2264 a) (hb : 0 \u2264 b\u2081) : 0 \u2264 a \u2022 b\u2081 := by\n  simpa only [smul_zero] using smul_le_smul_of_nonneg_left hb ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/Defs.lean", "context": {"open": ["OrderDual"], "variables": ["(\u03b1 \u03b2 : Type*)", "[SMul \u03b1 \u03b2] [Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "{\u03b1 \u03b2} {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2}", "[Zero \u03b1] [Mul \u03b1] [Preorder \u03b1]", "[SMul \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2]", "[Preorder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[LinearOrder \u03b1] [Preorder \u03b2]", "[Zero \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3\u2070 : SMul \u03b1 \u03b2\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : Preorder \u03b2\ninst\u271d\u00b2\u2077 : Zero \u03b1\ninst\u271d\u00b2\u2076 : Zero \u03b2\na : \u03b1\nb\u2081 : \u03b2\ninst\u271d\u00b2\u2075 : Zero \u03b1\ninst\u271d\u00b2\u2074 : Mul \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : SMul \u03b1 \u03b2\ninst\u271d\u00b2\u00b9 : Preorder \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b2\ninst\u271d\u00b9\u2079 : Zero \u03b1\ninst\u271d\u00b9\u2078 : Zero \u03b2\ninst\u271d\u00b9\u2077 : Zero \u03b1\ninst\u271d\u00b9\u2076 : Zero \u03b2\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : LinearOrder \u03b2\ninst\u271d\u00b9\u00b3 : Zero \u03b1\ninst\u271d\u00b9\u00b2 : Zero \u03b2\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b2\ninst\u271d\u2079 : Zero \u03b2\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : LinearOrder \u03b2\ninst\u271d\u2076 : Zero \u03b2\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Zero \u03b2\ninst\u271d\u00b3 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : PosSMulMono \u03b1 \u03b2\nha : 0 \u2264 a\nhb : 0 \u2264 b\u2081\n\u22a2 0 \u2264 a \u2022 b\u2081"}, {"line": "simpa only [smul_zero] using smul_le_smul_of_nonneg_left hb ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_nonpos_of_nonneg_of_nonpos [PosSMulMono \u03b1 \u03b2] (ha : 0 \u2264 a) (hb : b \u2264 0) : a \u2022 b \u2264 0 := by\n  simpa only [smul_zero] using smul_le_smul_of_nonneg_left hb ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/Defs.lean", "context": {"open": ["OrderDual"], "variables": ["(\u03b1 \u03b2 : Type*)", "[SMul \u03b1 \u03b2] [Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "{\u03b1 \u03b2} {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2}", "[Zero \u03b1] [Mul \u03b1] [Preorder \u03b1]", "[SMul \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2]", "[Preorder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[LinearOrder \u03b1] [Preorder \u03b2]", "[Zero \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3\u2070 : SMul \u03b1 \u03b2\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : Preorder \u03b2\ninst\u271d\u00b2\u2077 : Zero \u03b1\ninst\u271d\u00b2\u2076 : Zero \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d\u00b2\u2075 : Zero \u03b1\ninst\u271d\u00b2\u2074 : Mul \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : SMul \u03b1 \u03b2\ninst\u271d\u00b2\u00b9 : Preorder \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b2\ninst\u271d\u00b9\u2079 : Zero \u03b1\ninst\u271d\u00b9\u2078 : Zero \u03b2\ninst\u271d\u00b9\u2077 : Zero \u03b1\ninst\u271d\u00b9\u2076 : Zero \u03b2\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : LinearOrder \u03b2\ninst\u271d\u00b9\u00b3 : Zero \u03b1\ninst\u271d\u00b9\u00b2 : Zero \u03b2\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b2\ninst\u271d\u2079 : Zero \u03b2\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : LinearOrder \u03b2\ninst\u271d\u2076 : Zero \u03b2\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Zero \u03b2\ninst\u271d\u00b3 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : PosSMulMono \u03b1 \u03b2\nha : 0 \u2264 a\nhb : b \u2264 0\n\u22a2 a \u2022 b \u2264 0"}, {"line": "simpa only [smul_zero] using smul_le_smul_of_nonneg_left hb ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_pos' [SMulPosStrictMono \u03b1 \u03b2] (ha : 0 < a) (hb : 0 < b) : 0 < a \u2022 b := by\n  simpa only [zero_smul] using smul_lt_smul_of_pos_right ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/Defs.lean", "context": {"open": ["OrderDual"], "variables": ["(\u03b1 \u03b2 : Type*)", "[SMul \u03b1 \u03b2] [Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "{\u03b1 \u03b2} {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2}", "[Zero \u03b1] [Mul \u03b1] [Preorder \u03b1]", "[SMul \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2]", "[Preorder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[LinearOrder \u03b1] [Preorder \u03b2]", "[Zero \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulWithZero \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3\u2075 : SMul \u03b1 \u03b2\ninst\u271d\u00b3\u2074 : Preorder \u03b1\ninst\u271d\u00b3\u00b3 : Preorder \u03b2\ninst\u271d\u00b3\u00b2 : Zero \u03b1\ninst\u271d\u00b3\u00b9 : Zero \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d\u00b3\u2070 : Zero \u03b1\ninst\u271d\u00b2\u2079 : Mul \u03b1\ninst\u271d\u00b2\u2078 : Preorder \u03b1\ninst\u271d\u00b2\u2077 : SMul \u03b1 \u03b2\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b2\ninst\u271d\u00b2\u2074 : Zero \u03b1\ninst\u271d\u00b2\u00b3 : Zero \u03b2\ninst\u271d\u00b2\u00b2 : Zero \u03b1\ninst\u271d\u00b2\u00b9 : Zero \u03b2\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : LinearOrder \u03b2\ninst\u271d\u00b9\u2078 : Zero \u03b1\ninst\u271d\u00b9\u2077 : Zero \u03b2\ninst\u271d\u00b9\u2076 : LinearOrder \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b2\ninst\u271d\u00b9\u2074 : Zero \u03b2\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9\u00b9 : Zero \u03b2\ninst\u271d\u00b9\u2070 : Zero \u03b1\ninst\u271d\u2079 : Zero \u03b2\ninst\u271d\u2078 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Zero \u03b2\ninst\u271d\u00b3 : SMulWithZero \u03b1 \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : SMulPosStrictMono \u03b1 \u03b2\nha : 0 < a\nhb : 0 < b\n\u22a2 0 < a \u2022 b"}, {"line": "simpa only [zero_smul] using smul_lt_smul_of_pos_right ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_neg_of_neg_of_pos [SMulPosStrictMono \u03b1 \u03b2] (ha : a < 0) (hb : 0 < b) : a \u2022 b < 0 := by\n  simpa only [zero_smul] using smul_lt_smul_of_pos_right ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/Defs.lean", "context": {"open": ["OrderDual"], "variables": ["(\u03b1 \u03b2 : Type*)", "[SMul \u03b1 \u03b2] [Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "{\u03b1 \u03b2} {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2}", "[Zero \u03b1] [Mul \u03b1] [Preorder \u03b1]", "[SMul \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2]", "[Preorder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[LinearOrder \u03b1] [Preorder \u03b2]", "[Zero \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulWithZero \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3\u2075 : SMul \u03b1 \u03b2\ninst\u271d\u00b3\u2074 : Preorder \u03b1\ninst\u271d\u00b3\u00b3 : Preorder \u03b2\ninst\u271d\u00b3\u00b2 : Zero \u03b1\ninst\u271d\u00b3\u00b9 : Zero \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d\u00b3\u2070 : Zero \u03b1\ninst\u271d\u00b2\u2079 : Mul \u03b1\ninst\u271d\u00b2\u2078 : Preorder \u03b1\ninst\u271d\u00b2\u2077 : SMul \u03b1 \u03b2\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b2\ninst\u271d\u00b2\u2074 : Zero \u03b1\ninst\u271d\u00b2\u00b3 : Zero \u03b2\ninst\u271d\u00b2\u00b2 : Zero \u03b1\ninst\u271d\u00b2\u00b9 : Zero \u03b2\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : LinearOrder \u03b2\ninst\u271d\u00b9\u2078 : Zero \u03b1\ninst\u271d\u00b9\u2077 : Zero \u03b2\ninst\u271d\u00b9\u2076 : LinearOrder \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b2\ninst\u271d\u00b9\u2074 : Zero \u03b2\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9\u00b9 : Zero \u03b2\ninst\u271d\u00b9\u2070 : Zero \u03b1\ninst\u271d\u2079 : Zero \u03b2\ninst\u271d\u2078 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Zero \u03b2\ninst\u271d\u00b3 : SMulWithZero \u03b1 \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : SMulPosStrictMono \u03b1 \u03b2\nha : a < 0\nhb : 0 < b\n\u22a2 a \u2022 b < 0"}, {"line": "simpa only [zero_smul] using smul_lt_smul_of_pos_right ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_pos_iff_of_pos_right [SMulPosStrictMono \u03b1 \u03b2] [SMulPosReflectLT \u03b1 \u03b2] (hb : 0 < b) :\n    0 < a \u2022 b \u2194 0 < a := by\n  simpa only [zero_smul] using smul_lt_smul_iff_of_pos_right hb (a\u2081 := 0) (a\u2082 := a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/Defs.lean", "context": {"open": ["OrderDual"], "variables": ["(\u03b1 \u03b2 : Type*)", "[SMul \u03b1 \u03b2] [Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "{\u03b1 \u03b2} {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2}", "[Zero \u03b1] [Mul \u03b1] [Preorder \u03b1]", "[SMul \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2]", "[Preorder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[LinearOrder \u03b1] [Preorder \u03b2]", "[Zero \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulWithZero \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3\u2076 : SMul \u03b1 \u03b2\ninst\u271d\u00b3\u2075 : Preorder \u03b1\ninst\u271d\u00b3\u2074 : Preorder \u03b2\ninst\u271d\u00b3\u00b3 : Zero \u03b1\ninst\u271d\u00b3\u00b2 : Zero \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d\u00b3\u00b9 : Zero \u03b1\ninst\u271d\u00b3\u2070 : Mul \u03b1\ninst\u271d\u00b2\u2079 : Preorder \u03b1\ninst\u271d\u00b2\u2078 : SMul \u03b1 \u03b2\ninst\u271d\u00b2\u2077 : Preorder \u03b1\ninst\u271d\u00b2\u2076 : Preorder \u03b2\ninst\u271d\u00b2\u2075 : Zero \u03b1\ninst\u271d\u00b2\u2074 : Zero \u03b2\ninst\u271d\u00b2\u00b3 : Zero \u03b1\ninst\u271d\u00b2\u00b2 : Zero \u03b2\ninst\u271d\u00b2\u00b9 : Preorder \u03b1\ninst\u271d\u00b2\u2070 : LinearOrder \u03b2\ninst\u271d\u00b9\u2079 : Zero \u03b1\ninst\u271d\u00b9\u2078 : Zero \u03b2\ninst\u271d\u00b9\u2077 : LinearOrder \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b2\ninst\u271d\u00b9\u2075 : Zero \u03b2\ninst\u271d\u00b9\u2074 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b2\ninst\u271d\u00b9\u00b2 : Zero \u03b2\ninst\u271d\u00b9\u00b9 : Zero \u03b1\ninst\u271d\u00b9\u2070 : Zero \u03b2\ninst\u271d\u2079 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u2078 : Preorder \u03b1\ninst\u271d\u2077 : Preorder \u03b2\ninst\u271d\u2076 : Zero \u03b1\ninst\u271d\u2075 : Zero \u03b2\ninst\u271d\u2074 : SMulWithZero \u03b1 \u03b2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : SMulPosStrictMono \u03b1 \u03b2\ninst\u271d : SMulPosReflectLT \u03b1 \u03b2\nhb : 0 < b\n\u22a2 0 < a \u2022 b \u2194 0 < a"}, {"line": "simpa only [zero_smul] using smul_lt_smul_iff_of_pos_right hb (a\u2081 := 0) (a\u2082 := a)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_nonneg' [SMulPosMono \u03b1 \u03b2] (ha : 0 \u2264 a) (hb : 0 \u2264 b\u2081) : 0 \u2264 a \u2022 b\u2081 := by\n  simpa only [zero_smul] using smul_le_smul_of_nonneg_right ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/Defs.lean", "context": {"open": ["OrderDual"], "variables": ["(\u03b1 \u03b2 : Type*)", "[SMul \u03b1 \u03b2] [Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "{\u03b1 \u03b2} {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2}", "[Zero \u03b1] [Mul \u03b1] [Preorder \u03b1]", "[SMul \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2]", "[Preorder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[LinearOrder \u03b1] [Preorder \u03b2]", "[Zero \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulWithZero \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3\u2075 : SMul \u03b1 \u03b2\ninst\u271d\u00b3\u2074 : Preorder \u03b1\ninst\u271d\u00b3\u00b3 : Preorder \u03b2\ninst\u271d\u00b3\u00b2 : Zero \u03b1\ninst\u271d\u00b3\u00b9 : Zero \u03b2\na : \u03b1\nb\u2081 : \u03b2\ninst\u271d\u00b3\u2070 : Zero \u03b1\ninst\u271d\u00b2\u2079 : Mul \u03b1\ninst\u271d\u00b2\u2078 : Preorder \u03b1\ninst\u271d\u00b2\u2077 : SMul \u03b1 \u03b2\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b2\ninst\u271d\u00b2\u2074 : Zero \u03b1\ninst\u271d\u00b2\u00b3 : Zero \u03b2\ninst\u271d\u00b2\u00b2 : Zero \u03b1\ninst\u271d\u00b2\u00b9 : Zero \u03b2\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : LinearOrder \u03b2\ninst\u271d\u00b9\u2078 : Zero \u03b1\ninst\u271d\u00b9\u2077 : Zero \u03b2\ninst\u271d\u00b9\u2076 : LinearOrder \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b2\ninst\u271d\u00b9\u2074 : Zero \u03b2\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9\u00b9 : Zero \u03b2\ninst\u271d\u00b9\u2070 : Zero \u03b1\ninst\u271d\u2079 : Zero \u03b2\ninst\u271d\u2078 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Zero \u03b2\ninst\u271d\u00b3 : SMulWithZero \u03b1 \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : SMulPosMono \u03b1 \u03b2\nha : 0 \u2264 a\nhb : 0 \u2264 b\u2081\n\u22a2 0 \u2264 a \u2022 b\u2081"}, {"line": "simpa only [zero_smul] using smul_le_smul_of_nonneg_right ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_nonpos_of_nonpos_of_nonneg [SMulPosMono \u03b1 \u03b2] (ha : a \u2264 0) (hb : 0 \u2264 b) : a \u2022 b \u2264 0 := by\n  simpa only [zero_smul] using smul_le_smul_of_nonneg_right ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/Defs.lean", "context": {"open": ["OrderDual"], "variables": ["(\u03b1 \u03b2 : Type*)", "[SMul \u03b1 \u03b2] [Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "{\u03b1 \u03b2} {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2}", "[Zero \u03b1] [Mul \u03b1] [Preorder \u03b1]", "[SMul \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2]", "[Preorder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[LinearOrder \u03b1] [Preorder \u03b2]", "[Zero \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulWithZero \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3\u2075 : SMul \u03b1 \u03b2\ninst\u271d\u00b3\u2074 : Preorder \u03b1\ninst\u271d\u00b3\u00b3 : Preorder \u03b2\ninst\u271d\u00b3\u00b2 : Zero \u03b1\ninst\u271d\u00b3\u00b9 : Zero \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d\u00b3\u2070 : Zero \u03b1\ninst\u271d\u00b2\u2079 : Mul \u03b1\ninst\u271d\u00b2\u2078 : Preorder \u03b1\ninst\u271d\u00b2\u2077 : SMul \u03b1 \u03b2\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b2\ninst\u271d\u00b2\u2074 : Zero \u03b1\ninst\u271d\u00b2\u00b3 : Zero \u03b2\ninst\u271d\u00b2\u00b2 : Zero \u03b1\ninst\u271d\u00b2\u00b9 : Zero \u03b2\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : LinearOrder \u03b2\ninst\u271d\u00b9\u2078 : Zero \u03b1\ninst\u271d\u00b9\u2077 : Zero \u03b2\ninst\u271d\u00b9\u2076 : LinearOrder \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b2\ninst\u271d\u00b9\u2074 : Zero \u03b2\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9\u00b9 : Zero \u03b2\ninst\u271d\u00b9\u2070 : Zero \u03b1\ninst\u271d\u2079 : Zero \u03b2\ninst\u271d\u2078 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Zero \u03b2\ninst\u271d\u00b3 : SMulWithZero \u03b1 \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : SMulPosMono \u03b1 \u03b2\nha : a \u2264 0\nhb : 0 \u2264 b\n\u22a2 a \u2022 b \u2264 0"}, {"line": "simpa only [zero_smul] using smul_le_smul_of_nonneg_right ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_le_of_le_one_left [SMulPosMono \u03b1 \u03b2] (hb : 0 \u2264 b) (h : a \u2264 1) : a \u2022 b \u2264 b := by\n  simpa only [one_smul] using smul_le_smul_of_nonneg_right h hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/Defs.lean", "context": {"open": ["OrderDual"], "variables": ["(\u03b1 \u03b2 : Type*)", "[SMul \u03b1 \u03b2] [Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "{\u03b1 \u03b2} {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2}", "[Zero \u03b1] [Mul \u03b1] [Preorder \u03b1]", "[SMul \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2]", "[Preorder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[LinearOrder \u03b1] [Preorder \u03b2]", "[Zero \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulWithZero \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[PartialOrder \u03b1] [Preorder \u03b2]", "[Preorder \u03b1] [PartialOrder \u03b2]", "[PartialOrder \u03b1] [PartialOrder \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Monoid \u03b1] [Zero \u03b2] [MulAction \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074\u2078 : SMul \u03b1 \u03b2\ninst\u271d\u2074\u2077 : Preorder \u03b1\ninst\u271d\u2074\u2076 : Preorder \u03b2\ninst\u271d\u2074\u2075 : Zero \u03b1\ninst\u271d\u2074\u2074 : Zero \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d\u2074\u00b3 : Zero \u03b1\ninst\u271d\u2074\u00b2 : Mul \u03b1\ninst\u271d\u2074\u00b9 : Preorder \u03b1\ninst\u271d\u2074\u2070 : SMul \u03b1 \u03b2\ninst\u271d\u00b3\u2079 : Preorder \u03b1\ninst\u271d\u00b3\u2078 : Preorder \u03b2\ninst\u271d\u00b3\u2077 : Zero \u03b1\ninst\u271d\u00b3\u2076 : Zero \u03b2\ninst\u271d\u00b3\u2075 : Zero \u03b1\ninst\u271d\u00b3\u2074 : Zero \u03b2\ninst\u271d\u00b3\u00b3 : Preorder \u03b1\ninst\u271d\u00b3\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b3\u00b9 : Zero \u03b1\ninst\u271d\u00b3\u2070 : Zero \u03b2\ninst\u271d\u00b2\u2079 : LinearOrder \u03b1\ninst\u271d\u00b2\u2078 : Preorder \u03b2\ninst\u271d\u00b2\u2077 : Zero \u03b2\ninst\u271d\u00b2\u2076 : LinearOrder \u03b1\ninst\u271d\u00b2\u2075 : LinearOrder \u03b2\ninst\u271d\u00b2\u2074 : Zero \u03b2\ninst\u271d\u00b2\u00b3 : Zero \u03b1\ninst\u271d\u00b2\u00b2 : Zero \u03b2\ninst\u271d\u00b2\u00b9 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : Preorder \u03b2\ninst\u271d\u00b9\u2078 : Zero \u03b1\ninst\u271d\u00b9\u2077 : Zero \u03b2\ninst\u271d\u00b9\u2076 : SMulWithZero \u03b1 \u03b2\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b2\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b2\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b2\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : PartialOrder \u03b2\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : LinearOrder \u03b2\ninst\u271d\u2075 : Monoid \u03b1\ninst\u271d\u2074 : Zero \u03b2\ninst\u271d\u00b3 : MulAction \u03b1 \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : SMulPosMono \u03b1 \u03b2\nhb : 0 \u2264 b\nh : a \u2264 1\n\u22a2 a \u2022 b \u2264 b"}, {"line": "simpa only [one_smul] using smul_le_smul_of_nonneg_right h hb", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_smul_of_one_le_left [SMulPosMono \u03b1 \u03b2] (hb : 0 \u2264 b) (h : 1 \u2264 a) : b \u2264 a \u2022 b := by\n  simpa only [one_smul] using smul_le_smul_of_nonneg_right h hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/Defs.lean", "context": {"open": ["OrderDual"], "variables": ["(\u03b1 \u03b2 : Type*)", "[SMul \u03b1 \u03b2] [Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "{\u03b1 \u03b2} {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2}", "[Zero \u03b1] [Mul \u03b1] [Preorder \u03b1]", "[SMul \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2]", "[Preorder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[LinearOrder \u03b1] [Preorder \u03b2]", "[Zero \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulWithZero \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[PartialOrder \u03b1] [Preorder \u03b2]", "[Preorder \u03b1] [PartialOrder \u03b2]", "[PartialOrder \u03b1] [PartialOrder \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Monoid \u03b1] [Zero \u03b2] [MulAction \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074\u2078 : SMul \u03b1 \u03b2\ninst\u271d\u2074\u2077 : Preorder \u03b1\ninst\u271d\u2074\u2076 : Preorder \u03b2\ninst\u271d\u2074\u2075 : Zero \u03b1\ninst\u271d\u2074\u2074 : Zero \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d\u2074\u00b3 : Zero \u03b1\ninst\u271d\u2074\u00b2 : Mul \u03b1\ninst\u271d\u2074\u00b9 : Preorder \u03b1\ninst\u271d\u2074\u2070 : SMul \u03b1 \u03b2\ninst\u271d\u00b3\u2079 : Preorder \u03b1\ninst\u271d\u00b3\u2078 : Preorder \u03b2\ninst\u271d\u00b3\u2077 : Zero \u03b1\ninst\u271d\u00b3\u2076 : Zero \u03b2\ninst\u271d\u00b3\u2075 : Zero \u03b1\ninst\u271d\u00b3\u2074 : Zero \u03b2\ninst\u271d\u00b3\u00b3 : Preorder \u03b1\ninst\u271d\u00b3\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b3\u00b9 : Zero \u03b1\ninst\u271d\u00b3\u2070 : Zero \u03b2\ninst\u271d\u00b2\u2079 : LinearOrder \u03b1\ninst\u271d\u00b2\u2078 : Preorder \u03b2\ninst\u271d\u00b2\u2077 : Zero \u03b2\ninst\u271d\u00b2\u2076 : LinearOrder \u03b1\ninst\u271d\u00b2\u2075 : LinearOrder \u03b2\ninst\u271d\u00b2\u2074 : Zero \u03b2\ninst\u271d\u00b2\u00b3 : Zero \u03b1\ninst\u271d\u00b2\u00b2 : Zero \u03b2\ninst\u271d\u00b2\u00b9 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : Preorder \u03b2\ninst\u271d\u00b9\u2078 : Zero \u03b1\ninst\u271d\u00b9\u2077 : Zero \u03b2\ninst\u271d\u00b9\u2076 : SMulWithZero \u03b1 \u03b2\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b2\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b2\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b2\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : PartialOrder \u03b2\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : LinearOrder \u03b2\ninst\u271d\u2075 : Monoid \u03b1\ninst\u271d\u2074 : Zero \u03b2\ninst\u271d\u00b3 : MulAction \u03b1 \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : SMulPosMono \u03b1 \u03b2\nhb : 0 \u2264 b\nh : 1 \u2264 a\n\u22a2 b \u2264 a \u2022 b"}, {"line": "simpa only [one_smul] using smul_le_smul_of_nonneg_right h hb", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_lt_of_lt_one_left [SMulPosStrictMono \u03b1 \u03b2] (hb : 0 < b) (h : a < 1) : a \u2022 b < b := by\n  simpa only [one_smul] using smul_lt_smul_of_pos_right h hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/Defs.lean", "context": {"open": ["OrderDual"], "variables": ["(\u03b1 \u03b2 : Type*)", "[SMul \u03b1 \u03b2] [Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "{\u03b1 \u03b2} {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2}", "[Zero \u03b1] [Mul \u03b1] [Preorder \u03b1]", "[SMul \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2]", "[Preorder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[LinearOrder \u03b1] [Preorder \u03b2]", "[Zero \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulWithZero \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[PartialOrder \u03b1] [Preorder \u03b2]", "[Preorder \u03b1] [PartialOrder \u03b2]", "[PartialOrder \u03b1] [PartialOrder \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Monoid \u03b1] [Zero \u03b2] [MulAction \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074\u2078 : SMul \u03b1 \u03b2\ninst\u271d\u2074\u2077 : Preorder \u03b1\ninst\u271d\u2074\u2076 : Preorder \u03b2\ninst\u271d\u2074\u2075 : Zero \u03b1\ninst\u271d\u2074\u2074 : Zero \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d\u2074\u00b3 : Zero \u03b1\ninst\u271d\u2074\u00b2 : Mul \u03b1\ninst\u271d\u2074\u00b9 : Preorder \u03b1\ninst\u271d\u2074\u2070 : SMul \u03b1 \u03b2\ninst\u271d\u00b3\u2079 : Preorder \u03b1\ninst\u271d\u00b3\u2078 : Preorder \u03b2\ninst\u271d\u00b3\u2077 : Zero \u03b1\ninst\u271d\u00b3\u2076 : Zero \u03b2\ninst\u271d\u00b3\u2075 : Zero \u03b1\ninst\u271d\u00b3\u2074 : Zero \u03b2\ninst\u271d\u00b3\u00b3 : Preorder \u03b1\ninst\u271d\u00b3\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b3\u00b9 : Zero \u03b1\ninst\u271d\u00b3\u2070 : Zero \u03b2\ninst\u271d\u00b2\u2079 : LinearOrder \u03b1\ninst\u271d\u00b2\u2078 : Preorder \u03b2\ninst\u271d\u00b2\u2077 : Zero \u03b2\ninst\u271d\u00b2\u2076 : LinearOrder \u03b1\ninst\u271d\u00b2\u2075 : LinearOrder \u03b2\ninst\u271d\u00b2\u2074 : Zero \u03b2\ninst\u271d\u00b2\u00b3 : Zero \u03b1\ninst\u271d\u00b2\u00b2 : Zero \u03b2\ninst\u271d\u00b2\u00b9 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : Preorder \u03b2\ninst\u271d\u00b9\u2078 : Zero \u03b1\ninst\u271d\u00b9\u2077 : Zero \u03b2\ninst\u271d\u00b9\u2076 : SMulWithZero \u03b1 \u03b2\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b2\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b2\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b2\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : PartialOrder \u03b2\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : LinearOrder \u03b2\ninst\u271d\u2075 : Monoid \u03b1\ninst\u271d\u2074 : Zero \u03b2\ninst\u271d\u00b3 : MulAction \u03b1 \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : SMulPosStrictMono \u03b1 \u03b2\nhb : 0 < b\nh : a < 1\n\u22a2 a \u2022 b < b"}, {"line": "simpa only [one_smul] using smul_lt_smul_of_pos_right h hb", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lt_smul_of_one_lt_left [SMulPosStrictMono \u03b1 \u03b2] (hb : 0 < b) (h : 1 < a) : b < a \u2022 b := by\n  simpa only [one_smul] using smul_lt_smul_of_pos_right h hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/Defs.lean", "context": {"open": ["OrderDual"], "variables": ["(\u03b1 \u03b2 : Type*)", "[SMul \u03b1 \u03b2] [Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "{\u03b1 \u03b2} {a a\u2081 a\u2082 : \u03b1} {b b\u2081 b\u2082 : \u03b2}", "[Zero \u03b1] [Mul \u03b1] [Preorder \u03b1]", "[SMul \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2]", "[Preorder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b1]", "[Zero \u03b2]", "[LinearOrder \u03b1] [Preorder \u03b2]", "[Zero \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Zero \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[Zero \u03b1] [Zero \u03b2] [SMulWithZero \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]", "[PartialOrder \u03b1] [Preorder \u03b2]", "[Preorder \u03b1] [PartialOrder \u03b2]", "[PartialOrder \u03b1] [PartialOrder \u03b2]", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[Monoid \u03b1] [Zero \u03b2] [MulAction \u03b1 \u03b2]", "[Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074\u2078 : SMul \u03b1 \u03b2\ninst\u271d\u2074\u2077 : Preorder \u03b1\ninst\u271d\u2074\u2076 : Preorder \u03b2\ninst\u271d\u2074\u2075 : Zero \u03b1\ninst\u271d\u2074\u2074 : Zero \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d\u2074\u00b3 : Zero \u03b1\ninst\u271d\u2074\u00b2 : Mul \u03b1\ninst\u271d\u2074\u00b9 : Preorder \u03b1\ninst\u271d\u2074\u2070 : SMul \u03b1 \u03b2\ninst\u271d\u00b3\u2079 : Preorder \u03b1\ninst\u271d\u00b3\u2078 : Preorder \u03b2\ninst\u271d\u00b3\u2077 : Zero \u03b1\ninst\u271d\u00b3\u2076 : Zero \u03b2\ninst\u271d\u00b3\u2075 : Zero \u03b1\ninst\u271d\u00b3\u2074 : Zero \u03b2\ninst\u271d\u00b3\u00b3 : Preorder \u03b1\ninst\u271d\u00b3\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b3\u00b9 : Zero \u03b1\ninst\u271d\u00b3\u2070 : Zero \u03b2\ninst\u271d\u00b2\u2079 : LinearOrder \u03b1\ninst\u271d\u00b2\u2078 : Preorder \u03b2\ninst\u271d\u00b2\u2077 : Zero \u03b2\ninst\u271d\u00b2\u2076 : LinearOrder \u03b1\ninst\u271d\u00b2\u2075 : LinearOrder \u03b2\ninst\u271d\u00b2\u2074 : Zero \u03b2\ninst\u271d\u00b2\u00b3 : Zero \u03b1\ninst\u271d\u00b2\u00b2 : Zero \u03b2\ninst\u271d\u00b2\u00b9 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : Preorder \u03b2\ninst\u271d\u00b9\u2078 : Zero \u03b1\ninst\u271d\u00b9\u2077 : Zero \u03b2\ninst\u271d\u00b9\u2076 : SMulWithZero \u03b1 \u03b2\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b2\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b2\ninst\u271d\u00b9\u00b9 : Preorder \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b2\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : PartialOrder \u03b2\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : LinearOrder \u03b2\ninst\u271d\u2075 : Monoid \u03b1\ninst\u271d\u2074 : Zero \u03b2\ninst\u271d\u00b3 : MulAction \u03b1 \u03b2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : SMulPosStrictMono \u03b1 \u03b2\nhb : 0 < b\nh : 1 < a\n\u22a2 b < a \u2022 b"}, {"line": "simpa only [one_smul] using smul_lt_smul_of_pos_right h hb", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inf_eq_half_smul_add_sub_abs_sub' (x y : \u03b2) : x \u2293 y = (2\u207b\u00b9 : \u03b1) \u2022 (x + y - |y - x|) := by\n  letI := invertibleOfNonzero (two_ne_zero' \u03b1)\n  exact inf_eq_half_smul_add_sub_abs_sub \u03b1 x y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/OrderedSMul.lean", "context": {"open": [], "variables": ["{\u03b9 \ud835\udd5c R M N : Type*}", "[Semiring R] [PartialOrder R] [AddCommMonoid M] [PartialOrder M]", "[Semiring R] [LinearOrder R] [IsStrictOrderedRing R]", "[Semifield \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "(\u03b1 : Type*) {\u03b2 : Type*}", "[Semiring \u03b1] [Invertible (2 : \u03b1)] [Lattice \u03b2] [AddCommGroup \u03b2] [Module \u03b1 \u03b2]", "(\u03b1 : Type*) {\u03b2 : Type*}", "[DivisionSemiring \u03b1] [NeZero (2 : \u03b1)] [Lattice \u03b2] [AddCommGroup \u03b2] [Module \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\ninst\u271d\u2074 : DivisionSemiring \u03b1\ninst\u271d\u00b3 : NeZero 2\ninst\u271d\u00b2 : Lattice \u03b2\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : Module \u03b1 \u03b2\nx y : \u03b2\n\u22a2 x \u2293 y = 2\u207b\u00b9 \u2022 (x + y - |y - x|)"}, {"line": "letI := invertibleOfNonzero (two_ne_zero' \u03b1)", "tactic_state": "case refine_3\n\u03b1 : Type u_8\n\u03b2 : Type u_9\ninst\u271d\u2074 : DivisionSemiring \u03b1\ninst\u271d\u00b3 : NeZero 2\ninst\u271d\u00b2 : Lattice \u03b2\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : Module \u03b1 \u03b2\nx y : \u03b2\nthis : Invertible 2 := sorry\n\u22a2 x \u2293 y = 2\u207b\u00b9 \u2022 (x + y - |y - x|)\n---\ncase refine_1\n\u03b1 : Type u_8\n\u03b2 : Type u_9\ninst\u271d\u2074 : DivisionSemiring \u03b1\ninst\u271d\u00b3 : NeZero 2\ninst\u271d\u00b2 : Lattice \u03b2\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : Module \u03b1 \u03b2\nx y : \u03b2\n\u22a2 GroupWithZero \u03b1\n---\ncase refine_2\n\u03b1 : Type u_8\n\u03b2 : Type u_9\ninst\u271d\u2074 : DivisionSemiring \u03b1\ninst\u271d\u00b3 : NeZero 2\ninst\u271d\u00b2 : Lattice \u03b2\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : Module \u03b1 \u03b2\nx y : \u03b2\n\u22a2 OfNat \u03b1 2"}, {"line": "exact inf_eq_half_smul_add_sub_abs_sub \u03b1 x y", "tactic_state": "case refine_1\n\u03b1 : Type u_8\n\u03b2 : Type u_9\ninst\u271d\u2074 : DivisionSemiring \u03b1\ninst\u271d\u00b3 : NeZero 2\ninst\u271d\u00b2 : Lattice \u03b2\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : Module \u03b1 \u03b2\nx y : \u03b2\n\u22a2 GroupWithZero \u03b1\n---\ncase refine_2\n\u03b1 : Type u_8\n\u03b2 : Type u_9\ninst\u271d\u2074 : DivisionSemiring \u03b1\ninst\u271d\u00b3 : NeZero 2\ninst\u271d\u00b2 : Lattice \u03b2\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : Module \u03b1 \u03b2\nx y : \u03b2\n\u22a2 OfNat \u03b1 2"}]}
{"declaration": "lemma sup_eq_half_smul_add_add_abs_sub' (x y : \u03b2) : x \u2294 y = (2\u207b\u00b9 : \u03b1) \u2022 (x + y + |y - x|) := by\n  letI := invertibleOfNonzero (two_ne_zero' \u03b1)\n  exact sup_eq_half_smul_add_add_abs_sub \u03b1 x y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/OrderedSMul.lean", "context": {"open": [], "variables": ["{\u03b9 \ud835\udd5c R M N : Type*}", "[Semiring R] [PartialOrder R] [AddCommMonoid M] [PartialOrder M]", "[Semiring R] [LinearOrder R] [IsStrictOrderedRing R]", "[Semifield \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "(\u03b1 : Type*) {\u03b2 : Type*}", "[Semiring \u03b1] [Invertible (2 : \u03b1)] [Lattice \u03b2] [AddCommGroup \u03b2] [Module \u03b1 \u03b2]", "(\u03b1 : Type*) {\u03b2 : Type*}", "[DivisionSemiring \u03b1] [NeZero (2 : \u03b1)] [Lattice \u03b2] [AddCommGroup \u03b2] [Module \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_8\n\u03b2 : Type u_9\ninst\u271d\u2074 : DivisionSemiring \u03b1\ninst\u271d\u00b3 : NeZero 2\ninst\u271d\u00b2 : Lattice \u03b2\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : Module \u03b1 \u03b2\nx y : \u03b2\n\u22a2 x \u2294 y = 2\u207b\u00b9 \u2022 (x + y + |y - x|)"}, {"line": "letI := invertibleOfNonzero (two_ne_zero' \u03b1)", "tactic_state": "case refine_3\n\u03b1 : Type u_8\n\u03b2 : Type u_9\ninst\u271d\u2074 : DivisionSemiring \u03b1\ninst\u271d\u00b3 : NeZero 2\ninst\u271d\u00b2 : Lattice \u03b2\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : Module \u03b1 \u03b2\nx y : \u03b2\nthis : Invertible 2 := sorry\n\u22a2 x \u2294 y = 2\u207b\u00b9 \u2022 (x + y + |y - x|)\n---\ncase refine_1\n\u03b1 : Type u_8\n\u03b2 : Type u_9\ninst\u271d\u2074 : DivisionSemiring \u03b1\ninst\u271d\u00b3 : NeZero 2\ninst\u271d\u00b2 : Lattice \u03b2\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : Module \u03b1 \u03b2\nx y : \u03b2\n\u22a2 GroupWithZero \u03b1\n---\ncase refine_2\n\u03b1 : Type u_8\n\u03b2 : Type u_9\ninst\u271d\u2074 : DivisionSemiring \u03b1\ninst\u271d\u00b3 : NeZero 2\ninst\u271d\u00b2 : Lattice \u03b2\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : Module \u03b1 \u03b2\nx y : \u03b2\n\u22a2 OfNat \u03b1 2"}, {"line": "exact sup_eq_half_smul_add_add_abs_sub \u03b1 x y", "tactic_state": "case refine_1\n\u03b1 : Type u_8\n\u03b2 : Type u_9\ninst\u271d\u2074 : DivisionSemiring \u03b1\ninst\u271d\u00b3 : NeZero 2\ninst\u271d\u00b2 : Lattice \u03b2\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : Module \u03b1 \u03b2\nx y : \u03b2\n\u22a2 GroupWithZero \u03b1\n---\ncase refine_2\n\u03b1 : Type u_8\n\u03b2 : Type u_9\ninst\u271d\u2074 : DivisionSemiring \u03b1\ninst\u271d\u00b3 : NeZero 2\ninst\u271d\u00b2 : Lattice \u03b2\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : Module \u03b1 \u03b2\nx y : \u03b2\n\u22a2 OfNat \u03b1 2"}]}
{"declaration": "lemma zero_le_two [Preorder \u03b1] [ZeroLEOneClass \u03b1] [AddLeftMono \u03b1] :\n    (0 : \u03b1) \u2264 2 := by\n  rw [\u2190 one_add_one_eq_two]\n  exact add_nonneg zero_le_one zero_le_one\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Monoid/NatCast.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*}", "[AddMonoidWithOne \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : AddMonoidWithOne \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : ZeroLEOneClass \u03b1\ninst\u271d : AddLeftMono \u03b1\n\u22a2 0 \u2264 2"}, {"line": "rw [\u2190 one_add_one_eq_two]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : AddMonoidWithOne \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : ZeroLEOneClass \u03b1\ninst\u271d : AddLeftMono \u03b1\n\u22a2 0 \u2264 1 + 1"}, {"line": "exact add_nonneg zero_le_one zero_le_one", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zero_le_three [Preorder \u03b1] [ZeroLEOneClass \u03b1] [AddLeftMono \u03b1] :\n    (0 : \u03b1) \u2264 3 := by\n  rw [\u2190 two_add_one_eq_three]\n  exact add_nonneg zero_le_two zero_le_one\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Monoid/NatCast.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*}", "[AddMonoidWithOne \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : AddMonoidWithOne \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : ZeroLEOneClass \u03b1\ninst\u271d : AddLeftMono \u03b1\n\u22a2 0 \u2264 3"}, {"line": "rw [\u2190 two_add_one_eq_three]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : AddMonoidWithOne \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : ZeroLEOneClass \u03b1\ninst\u271d : AddLeftMono \u03b1\n\u22a2 0 \u2264 2 + 1"}, {"line": "exact add_nonneg zero_le_two zero_le_one", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zero_le_four [Preorder \u03b1] [ZeroLEOneClass \u03b1] [AddLeftMono \u03b1] :\n    (0 : \u03b1) \u2264 4 := by\n  rw [\u2190 three_add_one_eq_four]\n  exact add_nonneg zero_le_three zero_le_one\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Monoid/NatCast.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*}", "[AddMonoidWithOne \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : AddMonoidWithOne \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : ZeroLEOneClass \u03b1\ninst\u271d : AddLeftMono \u03b1\n\u22a2 0 \u2264 4"}, {"line": "rw [\u2190 three_add_one_eq_four]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : AddMonoidWithOne \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : ZeroLEOneClass \u03b1\ninst\u271d : AddLeftMono \u03b1\n\u22a2 0 \u2264 3 + 1"}, {"line": "exact add_nonneg zero_le_three zero_le_one", "tactic_state": "No Goals!"}]}
{"declaration": "theorem min_mul_distrib' (a b c : \u03b1) : min (a * b) c = min (min a c * min b c) c := by\n  simpa [min_comm _ c] using min_mul_distrib c a b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u}", "[Mul \u03b1]", "[LE \u03b1] [CanonicallyOrderedMul \u03b1] {a b c : \u03b1}", "[Preorder \u03b1] [CanonicallyOrderedMul \u03b1] {a b c : \u03b1}", "[CommMagma \u03b1]", "[LE \u03b1] [CanonicallyOrderedMul \u03b1] {a b : \u03b1}", "[Preorder \u03b1] [CanonicallyOrderedMul \u03b1] {a b c : \u03b1}", "[MulOneClass \u03b1]", "[LE \u03b1] [CanonicallyOrderedMul \u03b1] {a b : \u03b1}", "[Preorder \u03b1] [CanonicallyOrderedMul \u03b1] {a b : \u03b1}", "[PartialOrder \u03b1] [CanonicallyOrderedMul \u03b1] {a b c : \u03b1}", "[Semigroup \u03b1]", "[LE \u03b1] [CanonicallyOrderedMul \u03b1]", "[Monoid \u03b1]", "[PartialOrder \u03b1] [CanonicallyOrderedMul \u03b1] {a b c : \u03b1}", "[CommMonoid \u03b1]", "[PartialOrder \u03b1] [CanonicallyOrderedMul \u03b1] {a b c : \u03b1}", "[CommMonoid \u03b1] [LinearOrder \u03b1] [CanonicallyOrderedMul \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2\u2078 : Mul \u03b1\ninst\u271d\u00b2\u2077 : LE \u03b1\ninst\u271d\u00b2\u2076 : CanonicallyOrderedMul \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : CanonicallyOrderedMul \u03b1\ninst\u271d\u00b2\u00b3 : CommMagma \u03b1\ninst\u271d\u00b2\u00b2 : LE \u03b1\ninst\u271d\u00b2\u00b9 : CanonicallyOrderedMul \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : CanonicallyOrderedMul \u03b1\ninst\u271d\u00b9\u2078 : MulOneClass \u03b1\ninst\u271d\u00b9\u2077 : LE \u03b1\ninst\u271d\u00b9\u2076 : CanonicallyOrderedMul \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : CanonicallyOrderedMul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : CanonicallyOrderedMul \u03b1\ninst\u271d\u00b9\u00b9 : Semigroup \u03b1\ninst\u271d\u00b9\u2070 : LE \u03b1\ninst\u271d\u2079 : CanonicallyOrderedMul \u03b1\ninst\u271d\u2078 : Monoid \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : CanonicallyOrderedMul \u03b1\ninst\u271d\u2075 : CommMonoid \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : CanonicallyOrderedMul \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : CanonicallyOrderedMul \u03b1\na b c : \u03b1\n\u22a2 min (a * b) c = min (min a c * min b c) c"}, {"line": "simpa [min_comm _ c] using min_mul_distrib c a b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_lt_mul_iff_of_le_of_le [MulLeftMono \u03b1]\n    [MulRightMono \u03b1] [MulLeftStrictMono \u03b1]\n    [MulRightStrictMono \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1} (ha : a\u2081 \u2264 a\u2082)\n    (hb : b\u2081 \u2264 b\u2082) : a\u2081 * b\u2081 < a\u2082 * b\u2082 \u2194 a\u2081 < a\u2082 \u2228 b\u2081 < b\u2082 := by\n  refine \u27e8lt_or_lt_of_mul_lt_mul, fun h => ?_\u27e9\n  rcases h with ha' | hb'\n  \u00b7 exact mul_lt_mul_of_lt_of_le ha' hb\n  \u00b7 exact mul_lt_mul_of_le_of_lt ha hb'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Monoid/Unbundled/MinMax.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "[LinearOrder \u03b1] [CommSemigroup \u03b2]", "[CommSemigroup \u03b1]", "[LinearOrder \u03b1]", "[Mul \u03b1]", "[MulLeftMono \u03b1]", "[MulRightMono \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : CommSemigroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : MulLeftMono \u03b1\ninst\u271d\u2074 : MulRightMono \u03b1\ninst\u271d\u00b3 : MulLeftMono \u03b1\ninst\u271d\u00b2 : MulRightMono \u03b1\ninst\u271d\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d : MulRightStrictMono \u03b1\na\u2081 a\u2082 b\u2081 b\u2082 : \u03b1\nha : a\u2081 \u2264 a\u2082\nhb : b\u2081 \u2264 b\u2082\n\u22a2 a\u2081 * b\u2081 < a\u2082 * b\u2082 \u2194 a\u2081 < a\u2082 \u2228 b\u2081 < b\u2082"}, {"line": "refine \u27e8lt_or_lt_of_mul_lt_mul, fun h => ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : CommSemigroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : MulLeftMono \u03b1\ninst\u271d\u2074 : MulRightMono \u03b1\ninst\u271d\u00b3 : MulLeftMono \u03b1\ninst\u271d\u00b2 : MulRightMono \u03b1\ninst\u271d\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d : MulRightStrictMono \u03b1\na\u2081 a\u2082 b\u2081 b\u2082 : \u03b1\nha : a\u2081 \u2264 a\u2082\nhb : b\u2081 \u2264 b\u2082\nh : a\u2081 < a\u2082 \u2228 b\u2081 < b\u2082\n\u22a2 a\u2081 * b\u2081 < a\u2082 * b\u2082"}, {"line": "rcases h with ha' | hb'", "tactic_state": "case inl\n\u03b1 : Type u_1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : CommSemigroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : MulLeftMono \u03b1\ninst\u271d\u2074 : MulRightMono \u03b1\ninst\u271d\u00b3 : MulLeftMono \u03b1\ninst\u271d\u00b2 : MulRightMono \u03b1\ninst\u271d\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d : MulRightStrictMono \u03b1\na\u2081 a\u2082 b\u2081 b\u2082 : \u03b1\nha : a\u2081 \u2264 a\u2082\nhb : b\u2081 \u2264 b\u2082\nha' : a\u2081 < a\u2082\n\u22a2 a\u2081 * b\u2081 < a\u2082 * b\u2082\n---\ncase inr\n\u03b1 : Type u_1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : CommSemigroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : MulLeftMono \u03b1\ninst\u271d\u2074 : MulRightMono \u03b1\ninst\u271d\u00b3 : MulLeftMono \u03b1\ninst\u271d\u00b2 : MulRightMono \u03b1\ninst\u271d\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d : MulRightStrictMono \u03b1\na\u2081 a\u2082 b\u2081 b\u2082 : \u03b1\nha : a\u2081 \u2264 a\u2082\nhb : b\u2081 \u2264 b\u2082\nhb' : b\u2081 < b\u2082\n\u22a2 a\u2081 * b\u2081 < a\u2082 * b\u2082"}, {"line": "\u00b7 exact mul_lt_mul_of_lt_of_le ha' hb", "tactic_state": "case inr\n\u03b1 : Type u_1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : CommSemigroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : MulLeftMono \u03b1\ninst\u271d\u2074 : MulRightMono \u03b1\ninst\u271d\u00b3 : MulLeftMono \u03b1\ninst\u271d\u00b2 : MulRightMono \u03b1\ninst\u271d\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d : MulRightStrictMono \u03b1\na\u2081 a\u2082 b\u2081 b\u2082 : \u03b1\nha : a\u2081 \u2264 a\u2082\nhb : b\u2081 \u2264 b\u2082\nhb' : b\u2081 < b\u2082\n\u22a2 a\u2081 * b\u2081 < a\u2082 * b\u2082"}, {"line": "\u00b7 exact mul_lt_mul_of_le_of_lt ha hb'", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_right_inj_of_comparable [MulLeftStrictMono \u03b1] {a b c : \u03b1} (h : b \u2264 c \u2228 c \u2264 b) :\n    a * c = a * b \u2194 c = b := by\n  refine \u27e8fun h' => ?_, (\u00b7 \u25b8 rfl)\u27e9\n  contrapose h'\n  obtain h | h := h\n  \u00b7 exact mul_lt_mul_left' (h.lt_of_ne' h') a |>.ne'\n  \u00b7 exact mul_lt_mul_left' (h.lt_of_ne h') a |>.ne\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Mul \u03b1]", "[LE \u03b1]", "[LT \u03b1]", "[Preorder \u03b1]", "[PartialOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 : LE \u03b1\ninst\u271d\u00b3 : LT \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MulLeftStrictMono \u03b1\na b c : \u03b1\nh : b \u2264 c \u2228 c \u2264 b\n\u22a2 a * c = a * b \u2194 c = b"}, {"line": "refine \u27e8fun h' => ?_, (\u00b7 \u25b8 rfl)\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 : LE \u03b1\ninst\u271d\u00b3 : LT \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MulLeftStrictMono \u03b1\na b c : \u03b1\nh : b \u2264 c \u2228 c \u2264 b\nh' : a * c = a * b\n\u22a2 c = b"}, {"line": "contrapose h'", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 : LE \u03b1\ninst\u271d\u00b3 : LT \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MulLeftStrictMono \u03b1\na b c : \u03b1\nh : b \u2264 c \u2228 c \u2264 b\nh' : \u00acc = b\n\u22a2 \u00aca * c = a * b"}, {"line": "obtain h | h := h", "tactic_state": "case inl\n\u03b1 : Type u_1\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 : LE \u03b1\ninst\u271d\u00b3 : LT \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MulLeftStrictMono \u03b1\na b c : \u03b1\nh' : \u00acc = b\nh : b \u2264 c\n\u22a2 \u00aca * c = a * b\n---\ncase inr\n\u03b1 : Type u_1\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 : LE \u03b1\ninst\u271d\u00b3 : LT \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MulLeftStrictMono \u03b1\na b c : \u03b1\nh' : \u00acc = b\nh : c \u2264 b\n\u22a2 \u00aca * c = a * b"}, {"line": "\u00b7 exact mul_lt_mul_left' (h.lt_of_ne' h') a |>.ne'", "tactic_state": "case inr\n\u03b1 : Type u_1\ninst\u271d\u2075 : Mul \u03b1\ninst\u271d\u2074 : LE \u03b1\ninst\u271d\u00b3 : LT \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MulLeftStrictMono \u03b1\na b c : \u03b1\nh' : \u00acc = b\nh : c \u2264 b\n\u22a2 \u00aca * c = a * b"}, {"line": "\u00b7 exact mul_lt_mul_left' (h.lt_of_ne h') a |>.ne", "tactic_state": "No Goals!"}]}
{"declaration": "theorem contravariant_le_iff_contravariant_lt_and_eq [PartialOrder N] :\n    Contravariant M N \u03bc (\u00b7 \u2264 \u00b7) \u2194 Contravariant M N \u03bc (\u00b7 < \u00b7) \u2227 Contravariant M N \u03bc (\u00b7 = \u00b7) := by\n  refine \u27e8fun h \u21a6 \u27e8fun a b c bc \u21a6 ?_, fun a b c bc \u21a6 ?_\u27e9, fun h \u21a6 fun a b c bc \u21a6 ?_\u27e9\n  \u00b7 exact (h a bc.le).lt_of_ne (by rintro rfl; exact lt_irrefl _ bc)\n  \u00b7 exact (h a bc.le).antisymm (h a bc.ge)\n  \u00b7 exact bc.lt_or_eq.elim (fun bc \u21a6 (h.1 a bc).le) (fun bc \u21a6 (h.2 a bc).le)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Monoid/Unbundled/Defs.lean", "context": {"open": ["Function"], "variables": ["{M N : Type*} (\u03bc : M \u2192 N \u2192 N) (r : N \u2192 N \u2192 Prop)", "(M N)", "{M N \u03bc r}", "{M N \u03bc r} [CovariantClass M N \u03bc r]", "[IsTrans N r] (m : M) {a b c : N}", "{M N \u03bc r} {mu : N \u2192 N \u2192 N} [IsTrans N r] [i : CovariantClass N N mu r]", "{M N \u03bc r} [ContravariantClass M N \u03bc r]", "[IsTrans N r] (m : M) {a b c : N}", "{\u03b1 : Type*} {M N \u03bc} [Preorder \u03b1] [Preorder N]", "{f : N \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nN : Type u_2\n\u03bc : M \u2192 N \u2192 N\ninst\u271d : PartialOrder N\n\u22a2 (Contravariant M N \u03bc fun x1 x2 => x1 \u2264 x2) \u2194\n    (Contravariant M N \u03bc fun x1 x2 => x1 < x2) \u2227 Contravariant M N \u03bc fun x1 x2 => x1 = x2"}, {"line": "refine \u27e8fun h \u21a6 \u27e8fun a b c bc \u21a6 ?_, fun a b c bc \u21a6 ?_\u27e9, fun h \u21a6 fun a b c bc \u21a6 ?_\u27e9", "tactic_state": "case refine_1\nM : Type u_1\nN : Type u_2\n\u03bc : M \u2192 N \u2192 N\ninst\u271d : PartialOrder N\nh : Contravariant M N \u03bc fun x1 x2 => x1 \u2264 x2\na : M\nb c : N\nbc : (fun x1 x2 => x1 < x2) (\u03bc a b) (\u03bc a c)\n\u22a2 (fun x1 x2 => x1 < x2) b c\n---\ncase refine_2\nM : Type u_1\nN : Type u_2\n\u03bc : M \u2192 N \u2192 N\ninst\u271d : PartialOrder N\nh : Contravariant M N \u03bc fun x1 x2 => x1 \u2264 x2\na : M\nb c : N\nbc : (fun x1 x2 => x1 = x2) (\u03bc a b) (\u03bc a c)\n\u22a2 (fun x1 x2 => x1 = x2) b c\n---\ncase refine_3\nM : Type u_1\nN : Type u_2\n\u03bc : M \u2192 N \u2192 N\ninst\u271d : PartialOrder N\nh : (Contravariant M N \u03bc fun x1 x2 => x1 < x2) \u2227 Contravariant M N \u03bc fun x1 x2 => x1 = x2\na : M\nb c : N\nbc : (fun x1 x2 => x1 \u2264 x2) (\u03bc a b) (\u03bc a c)\n\u22a2 (fun x1 x2 => x1 \u2264 x2) b c"}, {"line": "\u00b7 exact (h a bc.le).lt_of_ne (by rintro rfl; exact lt_irrefl _ bc)", "tactic_state": "case refine_2\nM : Type u_1\nN : Type u_2\n\u03bc : M \u2192 N \u2192 N\ninst\u271d : PartialOrder N\nh : Contravariant M N \u03bc fun x1 x2 => x1 \u2264 x2\na : M\nb c : N\nbc : (fun x1 x2 => x1 = x2) (\u03bc a b) (\u03bc a c)\n\u22a2 (fun x1 x2 => x1 = x2) b c\n---\ncase refine_3\nM : Type u_1\nN : Type u_2\n\u03bc : M \u2192 N \u2192 N\ninst\u271d : PartialOrder N\nh : (Contravariant M N \u03bc fun x1 x2 => x1 < x2) \u2227 Contravariant M N \u03bc fun x1 x2 => x1 = x2\na : M\nb c : N\nbc : (fun x1 x2 => x1 \u2264 x2) (\u03bc a b) (\u03bc a c)\n\u22a2 (fun x1 x2 => x1 \u2264 x2) b c"}, {"line": "\u00b7 exact (h a bc.le).antisymm (h a bc.ge)", "tactic_state": "case refine_3\nM : Type u_1\nN : Type u_2\n\u03bc : M \u2192 N \u2192 N\ninst\u271d : PartialOrder N\nh : (Contravariant M N \u03bc fun x1 x2 => x1 < x2) \u2227 Contravariant M N \u03bc fun x1 x2 => x1 = x2\na : M\nb c : N\nbc : (fun x1 x2 => x1 \u2264 x2) (\u03bc a b) (\u03bc a c)\n\u22a2 (fun x1 x2 => x1 \u2264 x2) b c"}, {"line": "\u00b7 exact bc.lt_or_eq.elim (fun bc \u21a6 (h.1 a bc).le) (fun bc \u21a6 (h.2 a bc).le)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_self_pow (ha : 1 \u2264 a) (hn : n \u2260 0) : a \u2264 a ^ n := by\n  simpa using pow_le_pow_right' ha (Nat.one_le_iff_ne_zero.2 hn)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean", "context": {"open": ["Function"], "variables": ["{\u03b2 G M : Type*}", "[Monoid M]", "[Preorder M]", "[MulLeftMono M] {a : M}", "[MulLeftMono M] {a : M} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : Preorder M\ninst\u271d\u00b9 inst\u271d : MulLeftMono M\na : M\nn : \u2115\nha : 1 \u2264 a\nhn : n \u2260 0\n\u22a2 a \u2264 a ^ n"}, {"line": "simpa using pow_le_pow_right' ha (Nat.one_le_iff_ne_zero.2 hn)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Right.pow_lt_one_of_lt {n : \u2115} {x : M} (hn : 0 < n) (h : x < 1) : x ^ n < 1 := by\n  rcases Nat.exists_eq_succ_of_ne_zero hn.ne' with \u27e8k, rfl\u27e9\n  rw [pow_succ]\n  exact mul_lt_one_of_le_of_lt (pow_le_one_of_le h.le) h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean", "context": {"open": ["Function"], "variables": ["{\u03b2 G M : Type*}", "[Monoid M]", "[Preorder M]", "[MulLeftMono M] {a : M}", "[MulLeftMono M] {a : M} {n : \u2115}", "[MulLeftStrictMono M] {a : M} {n m : \u2115}", "[MulRightMono M] {x : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\ninst\u271d\u2075 : Monoid M\ninst\u271d\u2074 : Preorder M\ninst\u271d\u00b3 inst\u271d\u00b2 : MulLeftMono M\ninst\u271d\u00b9 : MulLeftStrictMono M\ninst\u271d : MulRightMono M\nn : \u2115\nx : M\nhn : 0 < n\nh : x < 1\n\u22a2 x ^ n < 1"}, {"line": "rcases Nat.exists_eq_succ_of_ne_zero hn.ne' with \u27e8k, rfl\u27e9", "tactic_state": "case intro\nM : Type u_3\ninst\u271d\u2075 : Monoid M\ninst\u271d\u2074 : Preorder M\ninst\u271d\u00b3 inst\u271d\u00b2 : MulLeftMono M\ninst\u271d\u00b9 : MulLeftStrictMono M\ninst\u271d : MulRightMono M\nx : M\nh : x < 1\nk : \u2115\nhn : 0 < k.succ\n\u22a2 x ^ k.succ < 1"}, {"line": "rw [pow_succ]", "tactic_state": "case intro\nM : Type u_3\ninst\u271d\u2075 : Monoid M\ninst\u271d\u2074 : Preorder M\ninst\u271d\u00b3 inst\u271d\u00b2 : MulLeftMono M\ninst\u271d\u00b9 : MulLeftStrictMono M\ninst\u271d : MulRightMono M\nx : M\nh : x < 1\nk : \u2115\nhn : 0 < k.succ\n\u22a2 x ^ k * x < 1"}, {"line": "exact mul_lt_one_of_le_of_lt (pow_le_one_of_le h.le) h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_le_zpow {x : G} (H : 1 \u2264 x) {n : \u2124} (hn : 0 \u2264 n) : 1 \u2264 x ^ n := by\n  lift n to \u2115 using hn\n  rw [zpow_natCast]\n  apply one_le_pow_of_one_le' H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean", "context": {"open": ["Function"], "variables": ["{\u03b2 G M : Type*}", "[Monoid M]", "[Preorder M]", "[MulLeftMono M] {a : M}", "[MulLeftMono M] {a : M} {n : \u2115}", "[MulLeftStrictMono M] {a : M} {n m : \u2115}", "[MulRightMono M] {x : M}", "[Preorder \u03b2] [MulLeftStrictMono M] [MulRightStrictMono M] {f : \u03b2 \u2192 M} {n : \u2115}", "[Preorder \u03b2] [MulLeftMono M] [MulRightMono M]", "[SemilatticeSup M] [MulLeftMono M] [MulRightMono M] {a b : M} {n : \u2115}", "[SemilatticeInf M] [MulLeftMono M] [MulRightMono M] {a b : M} {n : \u2115}", "[LinearOrder M]", "[MulLeftMono M]", "[MulLeftStrictMono M] {a : M} {m n : \u2115}", "[MulLeftMono M] [MulRightMono M]", "[MulLeftStrictMono M] [MulRightStrictMono M]", "[DivInvMonoid G] [Preorder G] [MulLeftMono G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : Preorder G\ninst\u271d : MulLeftMono G\nx : G\nH : 1 \u2264 x\nn : \u2124\nhn : 0 \u2264 n\n\u22a2 1 \u2264 x ^ n"}, {"line": "lift n to \u2115 using hn", "tactic_state": "case intro\nG : Type u_2\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : Preorder G\ninst\u271d : MulLeftMono G\nx : G\nH : 1 \u2264 x\nn : \u2115\n\u22a2 1 \u2264 x ^ \u2191n"}, {"line": "rw [zpow_natCast]", "tactic_state": "case intro\nG : Type u_2\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : Preorder G\ninst\u271d : MulLeftMono G\nx : G\nH : 1 \u2264 x\nn : \u2115\n\u22a2 1 \u2264 x ^ n"}, {"line": "apply one_le_pow_of_one_le' H", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_ne_top : x + y \u2260 \u22a4 \u2194 x \u2260 \u22a4 \u2227 y \u2260 \u22a4 := by cases x <;> cases y <;> simp [\u2190 coe_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Monoid/Unbundled/WithTop.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[One \u03b1] {a : \u03b1}", "[Add \u03b1] {w x y z : WithTop \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Add \u03b1\nx y : WithTop \u03b1\n\u22a2 x + y \u2260 \u22a4 \u2194 x \u2260 \u22a4 \u2227 y \u2260 \u22a4"}, {"line": "cases x <;> cases y <;> simp [\u2190 coe_add]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_coe_eq_top_iff : x + b = \u22a4 \u2194 x = \u22a4 := by simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Monoid/Unbundled/WithTop.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[One \u03b1] {a : \u03b1}", "[Add \u03b1] {w x y z : WithTop \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Add \u03b1\nx : WithTop \u03b1\nb : \u03b1\n\u22a2 x + \u2191b = \u22a4 \u2194 x = \u22a4"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_add_eq_top_iff : a + y = \u22a4 \u2194 y = \u22a4 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Monoid/Unbundled/WithTop.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[One \u03b1] {a : \u03b1}", "[Add \u03b1] {w x y z : WithTop \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Add \u03b1\ny : WithTop \u03b1\na : \u03b1\n\u22a2 \u2191a + y = \u22a4 \u2194 y = \u22a4"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_ne_bot : x + y \u2260 \u22a5 \u2194 x \u2260 \u22a5 \u2227 y \u2260 \u22a5 := by cases x <;> cases y <;> simp [\u2190 coe_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Monoid/Unbundled/WithTop.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[One \u03b1] {a : \u03b1}", "[Add \u03b1] {w x y z : WithTop \u03b1} {a b : \u03b1}", "[AddMonoid \u03b1]", "[AddMonoidWithOne \u03b1]", "[One \u03b1] {a : \u03b1}", "[Add \u03b1] {w x y z : WithBot \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2075 : One \u03b1\ninst\u271d\u2074 : Add \u03b1\ninst\u271d\u00b3 : AddMonoid \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Add \u03b1\nx y : WithBot \u03b1\n\u22a2 x + y \u2260 \u22a5 \u2194 x \u2260 \u22a5 \u2227 y \u2260 \u22a5"}, {"line": "cases x <;> cases y <;> simp [\u2190 coe_add]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_coe_eq_bot_iff : x + b = \u22a5 \u2194 x = \u22a5 := by simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Monoid/Unbundled/WithTop.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[One \u03b1] {a : \u03b1}", "[Add \u03b1] {w x y z : WithTop \u03b1} {a b : \u03b1}", "[AddMonoid \u03b1]", "[AddMonoidWithOne \u03b1]", "[One \u03b1] {a : \u03b1}", "[Add \u03b1] {w x y z : WithBot \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2075 : One \u03b1\ninst\u271d\u2074 : Add \u03b1\ninst\u271d\u00b3 : AddMonoid \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Add \u03b1\nx : WithBot \u03b1\nb : \u03b1\n\u22a2 x + \u2191b = \u22a5 \u2194 x = \u22a5"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_add_eq_bot_iff : a + y = \u22a5 \u2194 y = \u22a5 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Monoid/Unbundled/WithTop.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[One \u03b1] {a : \u03b1}", "[Add \u03b1] {w x y z : WithTop \u03b1} {a b : \u03b1}", "[AddMonoid \u03b1]", "[AddMonoidWithOne \u03b1]", "[One \u03b1] {a : \u03b1}", "[Add \u03b1] {w x y z : WithBot \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2075 : One \u03b1\ninst\u271d\u2074 : Add \u03b1\ninst\u271d\u00b3 : AddMonoid \u03b1\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Add \u03b1\ny : WithBot \u03b1\na : \u03b1\n\u22a2 \u2191a + y = \u22a5 \u2194 y = \u22a5"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNonneg_of_nonneg {a : \u03b1} (h : 0 \u2264 a) : toNonneg a = \u27e8a, h\u27e9 := by simp [toNonneg, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Nonneg/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Zero \u03b1] [One \u03b1] [LE \u03b1] [ZeroLEOneClass \u03b1]", "[MulZeroClass \u03b1] [Preorder \u03b1] [PosMulMono \u03b1]", "[AddMonoid \u03b1] [Preorder \u03b1] [AddLeftMono \u03b1]", "[AddCommMonoid \u03b1] [Preorder \u03b1] [AddLeftMono \u03b1]", "[AddMonoidWithOne \u03b1] [PartialOrder \u03b1] [AddLeftMono \u03b1] [ZeroLEOneClass \u03b1]", "[MonoidWithZero \u03b1] [Preorder \u03b1] [ZeroLEOneClass \u03b1] [PosMulMono \u03b1]", "[Semiring \u03b1] [PartialOrder \u03b1] [ZeroLEOneClass \u03b1]", "[CommSemiring \u03b1] [PartialOrder \u03b1] [ZeroLEOneClass \u03b1]", "[Zero \u03b1] [SemilatticeSup \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2078 : Zero \u03b1\ninst\u271d\u00b2\u2077 : One \u03b1\ninst\u271d\u00b2\u2076 : LE \u03b1\ninst\u271d\u00b2\u2075 : ZeroLEOneClass \u03b1\ninst\u271d\u00b2\u2074 : MulZeroClass \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : PosMulMono \u03b1\ninst\u271d\u00b2\u00b9 : AddMonoid \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : AddLeftMono \u03b1\ninst\u271d\u00b9\u2078 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : AddLeftMono \u03b1\ninst\u271d\u00b9\u2075 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : AddLeftMono \u03b1\ninst\u271d\u00b9\u00b2 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9\u00b9 : MonoidWithZero \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : ZeroLEOneClass \u03b1\ninst\u271d\u2078 : PosMulMono \u03b1\ninst\u271d\u2077 : Semiring \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : ZeroLEOneClass \u03b1\ninst\u271d\u2074 : CommSemiring \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : SemilatticeSup \u03b1\nx\u271d : Sort u_2\ntoNonneg : x\u271d\na : \u03b1\nh : 0 \u2264 a\n\u22a2 sorry = sorry"}, {"line": "simp [toNonneg, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNonneg_le {a : \u03b1} {b : { x : \u03b1 // 0 \u2264 x }} : toNonneg a \u2264 b \u2194 a \u2264 b := by\n  obtain \u27e8b, hb\u27e9 := b\n  simp [toNonneg, hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Nonneg/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Zero \u03b1] [One \u03b1] [LE \u03b1] [ZeroLEOneClass \u03b1]", "[MulZeroClass \u03b1] [Preorder \u03b1] [PosMulMono \u03b1]", "[AddMonoid \u03b1] [Preorder \u03b1] [AddLeftMono \u03b1]", "[AddCommMonoid \u03b1] [Preorder \u03b1] [AddLeftMono \u03b1]", "[AddMonoidWithOne \u03b1] [PartialOrder \u03b1] [AddLeftMono \u03b1] [ZeroLEOneClass \u03b1]", "[MonoidWithZero \u03b1] [Preorder \u03b1] [ZeroLEOneClass \u03b1] [PosMulMono \u03b1]", "[Semiring \u03b1] [PartialOrder \u03b1] [ZeroLEOneClass \u03b1]", "[CommSemiring \u03b1] [PartialOrder \u03b1] [ZeroLEOneClass \u03b1]", "[Zero \u03b1] [SemilatticeSup \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2078 : Zero \u03b1\ninst\u271d\u00b2\u2077 : One \u03b1\ninst\u271d\u00b2\u2076 : LE \u03b1\ninst\u271d\u00b2\u2075 : ZeroLEOneClass \u03b1\ninst\u271d\u00b2\u2074 : MulZeroClass \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : PosMulMono \u03b1\ninst\u271d\u00b2\u00b9 : AddMonoid \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : AddLeftMono \u03b1\ninst\u271d\u00b9\u2078 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : AddLeftMono \u03b1\ninst\u271d\u00b9\u2075 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : AddLeftMono \u03b1\ninst\u271d\u00b9\u00b2 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9\u00b9 : MonoidWithZero \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : ZeroLEOneClass \u03b1\ninst\u271d\u2078 : PosMulMono \u03b1\ninst\u271d\u2077 : Semiring \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : ZeroLEOneClass \u03b1\ninst\u271d\u2074 : CommSemiring \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : SemilatticeSup \u03b1\nx\u271d : Sort u_2\ntoNonneg : x\u271d\na : \u03b1\nb : { x // 0 \u2264 x }\n\u22a2 sorry \u2264 b \u2194 a \u2264 \u2191b"}, {"line": "obtain \u27e8b, hb\u27e9 := b", "tactic_state": "case mk\n\u03b1 : Type u_1\ninst\u271d\u00b2\u2078 : Zero \u03b1\ninst\u271d\u00b2\u2077 : One \u03b1\ninst\u271d\u00b2\u2076 : LE \u03b1\ninst\u271d\u00b2\u2075 : ZeroLEOneClass \u03b1\ninst\u271d\u00b2\u2074 : MulZeroClass \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : PosMulMono \u03b1\ninst\u271d\u00b2\u00b9 : AddMonoid \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : AddLeftMono \u03b1\ninst\u271d\u00b9\u2078 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : AddLeftMono \u03b1\ninst\u271d\u00b9\u2075 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : AddLeftMono \u03b1\ninst\u271d\u00b9\u00b2 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9\u00b9 : MonoidWithZero \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : ZeroLEOneClass \u03b1\ninst\u271d\u2078 : PosMulMono \u03b1\ninst\u271d\u2077 : Semiring \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : ZeroLEOneClass \u03b1\ninst\u271d\u2074 : CommSemiring \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : SemilatticeSup \u03b1\nx\u271d : Sort u_2\ntoNonneg : x\u271d\na b : \u03b1\nhb : 0 \u2264 b\n\u22a2 sorry \u2264 \u27e8b, hb\u27e9 \u2194 a \u2264 \u2191\u27e8b, hb\u27e9"}, {"line": "simp [toNonneg, hb]", "tactic_state": "case mk\n\u03b1 : Type u_1\ninst\u271d\u00b2\u2078 : Zero \u03b1\ninst\u271d\u00b2\u2077 : One \u03b1\ninst\u271d\u00b2\u2076 : LE \u03b1\ninst\u271d\u00b2\u2075 : ZeroLEOneClass \u03b1\ninst\u271d\u00b2\u2074 : MulZeroClass \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : PosMulMono \u03b1\ninst\u271d\u00b2\u00b9 : AddMonoid \u03b1\ninst\u271d\u00b2\u2070 : Preorder \u03b1\ninst\u271d\u00b9\u2079 : AddLeftMono \u03b1\ninst\u271d\u00b9\u2078 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : AddLeftMono \u03b1\ninst\u271d\u00b9\u2075 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : AddLeftMono \u03b1\ninst\u271d\u00b9\u00b2 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9\u00b9 : MonoidWithZero \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : ZeroLEOneClass \u03b1\ninst\u271d\u2078 : PosMulMono \u03b1\ninst\u271d\u2077 : Semiring \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : ZeroLEOneClass \u03b1\ninst\u271d\u2074 : CommSemiring \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : SemilatticeSup \u03b1\nx\u271d : Sort u_2\ntoNonneg : x\u271d\na b : \u03b1\nhb : 0 \u2264 b\n\u22a2 sorry () \u2264 \u27e8b, hb\u27e9 \u2194 a \u2264 b"}]}
{"declaration": "theorem toNonneg_lt {a : { x : \u03b1 // 0 \u2264 x }} {b : \u03b1} : a < toNonneg b \u2194 \u2191a < b := by\n  obtain \u27e8a, ha\u27e9 := a\n  simp [toNonneg, ha.not_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Nonneg/Basic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*}", "[Zero \u03b1] [One \u03b1] [LE \u03b1] [ZeroLEOneClass \u03b1]", "[MulZeroClass \u03b1] [Preorder \u03b1] [PosMulMono \u03b1]", "[AddMonoid \u03b1] [Preorder \u03b1] [AddLeftMono \u03b1]", "[AddCommMonoid \u03b1] [Preorder \u03b1] [AddLeftMono \u03b1]", "[AddMonoidWithOne \u03b1] [PartialOrder \u03b1] [AddLeftMono \u03b1] [ZeroLEOneClass \u03b1]", "[MonoidWithZero \u03b1] [Preorder \u03b1] [ZeroLEOneClass \u03b1] [PosMulMono \u03b1]", "[Semiring \u03b1] [PartialOrder \u03b1] [ZeroLEOneClass \u03b1]", "[CommSemiring \u03b1] [PartialOrder \u03b1] [ZeroLEOneClass \u03b1]", "[Zero \u03b1] [SemilatticeSup \u03b1]", "[Zero \u03b1] [LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3\u2070 : Zero \u03b1\ninst\u271d\u00b2\u2079 : One \u03b1\ninst\u271d\u00b2\u2078 : LE \u03b1\ninst\u271d\u00b2\u2077 : ZeroLEOneClass \u03b1\ninst\u271d\u00b2\u2076 : MulZeroClass \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : PosMulMono \u03b1\ninst\u271d\u00b2\u00b3 : AddMonoid \u03b1\ninst\u271d\u00b2\u00b2 : Preorder \u03b1\ninst\u271d\u00b2\u00b9 : AddLeftMono \u03b1\ninst\u271d\u00b2\u2070 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2079 : Preorder \u03b1\ninst\u271d\u00b9\u2078 : AddLeftMono \u03b1\ninst\u271d\u00b9\u2077 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9\u2076 : PartialOrder \u03b1\ninst\u271d\u00b9\u2075 : AddLeftMono \u03b1\ninst\u271d\u00b9\u2074 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9\u00b3 : MonoidWithZero \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9\u2070 : PosMulMono \u03b1\ninst\u271d\u2079 : Semiring \u03b1\ninst\u271d\u2078 : PartialOrder \u03b1\ninst\u271d\u2077 : ZeroLEOneClass \u03b1\ninst\u271d\u2076 : CommSemiring \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : ZeroLEOneClass \u03b1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : LinearOrder \u03b1\nx\u271d : Sort u_2\ntoNonneg : x\u271d\na : { x // 0 \u2264 x }\nb : \u03b1\n\u22a2 a < sorry \u2194 \u2191a < b"}, {"line": "obtain \u27e8a, ha\u27e9 := a", "tactic_state": "case mk\n\u03b1 : Type u_1\ninst\u271d\u00b3\u2070 : Zero \u03b1\ninst\u271d\u00b2\u2079 : One \u03b1\ninst\u271d\u00b2\u2078 : LE \u03b1\ninst\u271d\u00b2\u2077 : ZeroLEOneClass \u03b1\ninst\u271d\u00b2\u2076 : MulZeroClass \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : PosMulMono \u03b1\ninst\u271d\u00b2\u00b3 : AddMonoid \u03b1\ninst\u271d\u00b2\u00b2 : Preorder \u03b1\ninst\u271d\u00b2\u00b9 : AddLeftMono \u03b1\ninst\u271d\u00b2\u2070 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2079 : Preorder \u03b1\ninst\u271d\u00b9\u2078 : AddLeftMono \u03b1\ninst\u271d\u00b9\u2077 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9\u2076 : PartialOrder \u03b1\ninst\u271d\u00b9\u2075 : AddLeftMono \u03b1\ninst\u271d\u00b9\u2074 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9\u00b3 : MonoidWithZero \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9\u2070 : PosMulMono \u03b1\ninst\u271d\u2079 : Semiring \u03b1\ninst\u271d\u2078 : PartialOrder \u03b1\ninst\u271d\u2077 : ZeroLEOneClass \u03b1\ninst\u271d\u2076 : CommSemiring \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : ZeroLEOneClass \u03b1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : LinearOrder \u03b1\nx\u271d : Sort u_2\ntoNonneg : x\u271d\nb a : \u03b1\nha : 0 \u2264 a\n\u22a2 \u27e8a, ha\u27e9 < sorry \u2194 \u2191\u27e8a, ha\u27e9 < b"}, {"line": "simp [toNonneg, ha.not_lt]", "tactic_state": "case mk\n\u03b1 : Type u_1\ninst\u271d\u00b3\u2070 : Zero \u03b1\ninst\u271d\u00b2\u2079 : One \u03b1\ninst\u271d\u00b2\u2078 : LE \u03b1\ninst\u271d\u00b2\u2077 : ZeroLEOneClass \u03b1\ninst\u271d\u00b2\u2076 : MulZeroClass \u03b1\ninst\u271d\u00b2\u2075 : Preorder \u03b1\ninst\u271d\u00b2\u2074 : PosMulMono \u03b1\ninst\u271d\u00b2\u00b3 : AddMonoid \u03b1\ninst\u271d\u00b2\u00b2 : Preorder \u03b1\ninst\u271d\u00b2\u00b9 : AddLeftMono \u03b1\ninst\u271d\u00b2\u2070 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2079 : Preorder \u03b1\ninst\u271d\u00b9\u2078 : AddLeftMono \u03b1\ninst\u271d\u00b9\u2077 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9\u2076 : PartialOrder \u03b1\ninst\u271d\u00b9\u2075 : AddLeftMono \u03b1\ninst\u271d\u00b9\u2074 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9\u00b3 : MonoidWithZero \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9\u2070 : PosMulMono \u03b1\ninst\u271d\u2079 : Semiring \u03b1\ninst\u271d\u2078 : PartialOrder \u03b1\ninst\u271d\u2077 : ZeroLEOneClass \u03b1\ninst\u271d\u2076 : CommSemiring \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : ZeroLEOneClass \u03b1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : LinearOrder \u03b1\nx\u271d : Sort u_2\ntoNonneg : x\u271d\nb a : \u03b1\nha : 0 \u2264 a\n\u22a2 \u27e8a, ha\u27e9 < sorry () \u2194 a < b"}]}
{"declaration": "lemma abs_mul_self (a : \u03b1) : |a * a| = a * a := by rw [abs_mul, abs_mul_abs_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Abs.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {n : \u2115} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : Ring \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 |a * a| = a * a"}, {"line": "rw [abs_mul, abs_mul_abs_self]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : Ring \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 IsStrictOrderedRing \u03b1"}]}
{"declaration": "lemma abs_le_one_iff_mul_self_le_one : |a| \u2264 1 \u2194 a * a \u2264 1 := by\n  simpa only [abs_one, one_mul] using abs_le_iff_mul_self_le (a := a) (b := 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Abs.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {n : \u2115} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : Ring \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 |a| \u2264 1 \u2194 a * a \u2264 1"}, {"line": "simpa only [abs_one, one_mul] using abs_le_iff_mul_self_le (a := a) (b := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma abs_sq (x : \u03b1) : |x ^ 2| = x ^ 2 := by simpa only [sq] using abs_mul_self x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Abs.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {n : \u2115} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : Ring \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx : \u03b1\n\u22a2 |x ^ 2| = x ^ 2"}, {"line": "simpa only [sq] using abs_mul_self x", "tactic_state": "No Goals!"}]}
{"declaration": "lemma abs_unit_intCast (a : \u2124\u02e3) : |((a : \u2124) : \u03b1)| = 1 := by\n  cases Int.units_eq_one_or a <;> simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Abs.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {n : \u2115} {a b : \u03b1}", "[CommRing \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b : \u03b1) (n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : Ring \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : CommRing \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u2124\u02e3\n\u22a2 |\u2191\u2191a| = 1"}, {"line": "cases Int.units_eq_one_or a <;> simp_all", "tactic_state": "case inl\n\u03b1 : Type u_1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : Ring \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : CommRing \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u2124\u02e3\nh\u271d : a = 1\n\u22a2 |1| = 1\n---\ncase inr\n\u03b1 : Type u_1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : Ring \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : CommRing \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u2124\u02e3\nh\u271d : a = -1\n\u22a2 |1| = 1"}]}
{"declaration": "lemma pow_eq_pow_iff_cases : a ^ n = b ^ n \u2194 n = 0 \u2228 a = b \u2228 a = -b \u2227 Even n := by\n  rcases eq_or_ne n 0 with rfl | hn <;> simp [pow_eq_pow_iff_of_ne_zero, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Abs.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type*}", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {n : \u2115} {a b : \u03b1}", "[CommRing \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b : \u03b1) (n : \u2115)", "[Ring \u03b1] [LinearOrder \u03b1]", "{R : Type*} [Ring R] [LinearOrder R] [IsStrictOrderedRing R] {a b : R} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : IsStrictOrderedRing R\na b : R\nn : \u2115\n\u22a2 a ^ n = b ^ n \u2194 n = 0 \u2228 a = b \u2228 a = -b \u2227 Even n"}, {"line": "rcases eq_or_ne n 0 with rfl | hn <;> simp [pow_eq_pow_iff_of_ne_zero, *]", "tactic_state": "case inr\nR : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : IsStrictOrderedRing R\na b : R\nn : \u2115\nhn : n \u2260 0\n\u22a2 a ^ n = b ^ n \u2194 a = b \u2228 a = -b \u2227 Even n"}]}
{"declaration": "lemma pow_eq_neg_one_iff : a ^ n = -1 \u2194 a = -1 \u2227 Odd n := by\n  simpa using pow_eq_neg_pow_iff (R := R) one_ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Abs.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type*}", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {n : \u2115} {a b : \u03b1}", "[CommRing \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b : \u03b1) (n : \u2115)", "[Ring \u03b1] [LinearOrder \u03b1]", "{R : Type*} [Ring R] [LinearOrder R] [IsStrictOrderedRing R] {a b : R} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : IsStrictOrderedRing R\na : R\nn : \u2115\n\u22a2 a ^ n = -1 \u2194 a = -1 \u2227 Odd n"}, {"line": "simpa using pow_eq_neg_pow_iff (R := R) one_ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Odd.ne_two_of_dvd_nat {m n : \u2115} (hn : Odd n) (hm : m \u2223 n) : m \u2260 2 := by\n  rintro rfl\n  exact absurd (hn.of_dvd_nat hm) (by decide)", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Abs.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type*}", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {n : \u2115} {a b : \u03b1}", "[CommRing \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] (a b : \u03b1) (n : \u2115)", "[Ring \u03b1] [LinearOrder \u03b1]", "{R : Type*} [Ring R] [LinearOrder R] [IsStrictOrderedRing R] {a b : R} {n : \u2115}", "{m n a : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nhn : Odd n\nhm : m \u2223 n\n\u22a2 m \u2260 2"}, {"line": "rintro rfl", "tactic_state": "n : \u2115\nhn : Odd n\nhm : 2 \u2223 n\n\u22a2 False"}, {"line": "exact absurd (hn.of_dvd_nat hm) (by decide)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsSquare.nonneg [Semiring R] [LinearOrder R] [IsRightCancelAdd R]\n    [ZeroLEOneClass R] [ExistsAddOfLE R] [PosMulMono R] [AddLeftStrictMono R]\n    {x : R} (h : IsSquare x) : 0 \u2264 x := by\n  rcases h with \u27e8y, rfl\u27e9\n  exact mul_self_nonneg y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Basic.lean", "context": {"open": ["Function Int"], "variables": ["{\u03b1 M R : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : LinearOrder R\ninst\u271d\u2074 : IsRightCancelAdd R\ninst\u271d\u00b3 : ZeroLEOneClass R\ninst\u271d\u00b2 : ExistsAddOfLE R\ninst\u271d\u00b9 : PosMulMono R\ninst\u271d : AddLeftStrictMono R\nx : R\nh : IsSquare x\n\u22a2 0 \u2264 x"}, {"line": "rcases h with \u27e8y, rfl\u27e9", "tactic_state": "case intro\nR : Type u_3\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : LinearOrder R\ninst\u271d\u2074 : IsRightCancelAdd R\ninst\u271d\u00b3 : ZeroLEOneClass R\ninst\u271d\u00b2 : ExistsAddOfLE R\ninst\u271d\u00b9 : PosMulMono R\ninst\u271d : AddLeftStrictMono R\ny : R\n\u22a2 0 \u2264 y * y"}, {"line": "exact mul_self_nonneg y", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cast_abs : (\u2191|a| : R) = |(a : R)| := by simp [abs_eq_max_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Cast.lean", "context": {"open": ["Function Nat"], "variables": ["{R : Type*}", "[AddCommGroupWithOne R] [PartialOrder R] [AddLeftMono R]", "[ZeroLEOneClass R]", "[NeZero (1 : R)] {m n : \u2124}", "[Ring R] [LinearOrder R] [IsStrictOrderedRing R] {a b n : \u2124} {x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2077 : AddCommGroupWithOne R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : AddLeftMono R\ninst\u271d\u2074 : ZeroLEOneClass R\ninst\u271d\u00b3 : NeZero 1\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : IsStrictOrderedRing R\na : \u2124\n\u22a2 \u2191|a| = |\u2191a|"}, {"line": "simp [abs_eq_max_neg]", "tactic_state": "R : Type u_1\ninst\u271d\u2077 : AddCommGroupWithOne R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : AddLeftMono R\ninst\u271d\u2074 : ZeroLEOneClass R\ninst\u271d\u00b3 : NeZero 1\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : IsStrictOrderedRing R\na : \u2124\n\u22a2 \u2191(max a (-a)) = max (\u2191a) (-\u2191a)"}]}
{"declaration": "lemma cast_natAbs : (n.natAbs : R) = |n| := by\n  cases n\n  \u00b7 simp\n  \u00b7 rw [abs_eq_natAbs, natAbs_negSucc, cast_succ, cast_natCast, cast_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Cast.lean", "context": {"open": ["Function Nat"], "variables": ["{R : Type*}", "[AddCommGroupWithOne R] [PartialOrder R] [AddLeftMono R]", "[ZeroLEOneClass R]", "[NeZero (1 : R)] {m n : \u2124}", "[Ring R] [LinearOrder R] [IsStrictOrderedRing R] {a b n : \u2124} {x : R}", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2077 : AddCommGroupWithOne R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : AddLeftMono R\ninst\u271d\u2074 : ZeroLEOneClass R\ninst\u271d\u00b3 : NeZero 1\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : IsStrictOrderedRing R\nn : \u2124\n\u22a2 \u2191n.natAbs = \u2191|n|"}, {"line": "cases n", "tactic_state": "case ofNat\nR : Type u_1\ninst\u271d\u2077 : AddCommGroupWithOne R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : AddLeftMono R\ninst\u271d\u2074 : ZeroLEOneClass R\ninst\u271d\u00b3 : NeZero 1\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : IsStrictOrderedRing R\na\u271d : \u2115\n\u22a2 \u2191(Int.ofNat a\u271d).natAbs = \u2191|Int.ofNat a\u271d|\n---\ncase negSucc\nR : Type u_1\ninst\u271d\u2077 : AddCommGroupWithOne R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : AddLeftMono R\ninst\u271d\u2074 : ZeroLEOneClass R\ninst\u271d\u00b3 : NeZero 1\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : IsStrictOrderedRing R\na\u271d : \u2115\n\u22a2 \u2191(Int.negSucc a\u271d).natAbs = \u2191|Int.negSucc a\u271d|"}, {"line": "\u00b7 simp", "tactic_state": "case negSucc\nR : Type u_1\ninst\u271d\u2077 : AddCommGroupWithOne R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : AddLeftMono R\ninst\u271d\u2074 : ZeroLEOneClass R\ninst\u271d\u00b3 : NeZero 1\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : IsStrictOrderedRing R\na\u271d : \u2115\n\u22a2 \u2191(Int.negSucc a\u271d).natAbs = \u2191|Int.negSucc a\u271d|"}, {"line": "\u00b7 rw [abs_eq_natAbs, natAbs_negSucc, cast_succ, cast_natCast, cast_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nmul_le {F \u03b1 : Type*} [NonAssocSemiring \u03b1] [FunLike F \u03b1 R] [ZeroHomClass F \u03b1 R]\n    [NonnegHomClass F \u03b1 R] {f : F} (hna : IsNonarchimedean f) {n : \u2115} {a : \u03b1} :\n    f (n * a) \u2264 f a := by\n  rw [\u2190 nsmul_eq_mul]\n  exact nsmul_le hna\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/IsNonarchimedean.lean", "context": {"open": [], "variables": ["{R : Type*} [Semiring R] [LinearOrder R] {a b : R} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : LinearOrder R\nF : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b3 : NonAssocSemiring \u03b1\ninst\u271d\u00b2 : FunLike F \u03b1 R\ninst\u271d\u00b9 : ZeroHomClass F \u03b1 R\ninst\u271d : NonnegHomClass F \u03b1 R\nf : F\nhna : IsNonarchimedean \u21d1f\nn : \u2115\na : \u03b1\n\u22a2 f (\u2191n * a) \u2264 f a"}, {"line": "rw [\u2190 nsmul_eq_mul]", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : LinearOrder R\nF : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b3 : NonAssocSemiring \u03b1\ninst\u271d\u00b2 : FunLike F \u03b1 R\ninst\u271d\u00b9 : ZeroHomClass F \u03b1 R\ninst\u271d : NonnegHomClass F \u03b1 R\nf : F\nhna : IsNonarchimedean \u21d1f\nn : \u2115\na : \u03b1\n\u22a2 f (n \u2022 a) \u2264 f a"}, {"line": "exact nsmul_le hna", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finset_image_add {F \u03b1 \u03b2 : Type*} [AddCommMonoid \u03b1] [FunLike F \u03b1 R]\n    [ZeroHomClass F \u03b1 R] [NonnegHomClass F \u03b1 R] [Nonempty \u03b2] {f : F} (hna : IsNonarchimedean f)\n    (g : \u03b2 \u2192 \u03b1) (t : Finset \u03b2) :\n    \u2203 b : \u03b2, (t.Nonempty \u2192 b \u2208 t) \u2227 f (t.sum g) \u2264 f (g b) := by\n  have h1 : t.Nonempty \u2194 t.val \u2260 0 := by simp [Finset.nonempty_iff_ne_empty]\n  rw [h1]\n  exact multiset_image_add hna g t.val\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/IsNonarchimedean.lean", "context": {"open": [], "variables": ["{R : Type*} [Semiring R] [LinearOrder R] {a b : R} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : LinearOrder R\nF : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : FunLike F \u03b1 R\ninst\u271d\u00b2 : ZeroHomClass F \u03b1 R\ninst\u271d\u00b9 : NonnegHomClass F \u03b1 R\ninst\u271d : Nonempty \u03b2\nf : F\nhna : IsNonarchimedean \u21d1f\ng : \u03b2 \u2192 \u03b1\nt : Finset \u03b2\n\u22a2 \u2203 b, (t.Nonempty \u2192 b \u2208 t) \u2227 f (t.sum g) \u2264 f (g b)"}, {"line": "have h1 : t.Nonempty \u2194 t.val \u2260 0 := sorry", "tactic_state": "R : Type u_1\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : LinearOrder R\nF : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : FunLike F \u03b1 R\ninst\u271d\u00b2 : ZeroHomClass F \u03b1 R\ninst\u271d\u00b9 : NonnegHomClass F \u03b1 R\ninst\u271d : Nonempty \u03b2\nf : F\nhna : IsNonarchimedean \u21d1f\ng : \u03b2 \u2192 \u03b1\nt : Finset \u03b2\nh1 : t.Nonempty \u2194 t.val \u2260 0\n\u22a2 \u2203 b, (t.Nonempty \u2192 b \u2208 t) \u2227 f (t.sum g) \u2264 f (g b)"}, {"line": "rw [h1]", "tactic_state": "R : Type u_1\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : LinearOrder R\nF : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : FunLike F \u03b1 R\ninst\u271d\u00b2 : ZeroHomClass F \u03b1 R\ninst\u271d\u00b9 : NonnegHomClass F \u03b1 R\ninst\u271d : Nonempty \u03b2\nf : F\nhna : IsNonarchimedean \u21d1f\ng : \u03b2 \u2192 \u03b1\nt : Finset \u03b2\nh1 : t.Nonempty \u2194 t.val \u2260 0\n\u22a2 \u2203 b, (t.val \u2260 0 \u2192 b \u2208 t) \u2227 f (t.sum g) \u2264 f (g b)"}, {"line": "exact multiset_image_add hna g t.val", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_def (a b : WithTop \u03b1) :\n    a * b = if a = 0 \u2228 b = 0 then 0 else WithTop.map\u2082 (\u00b7 * \u00b7) a b := by\n  cases a <;> cases b <;> aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/WithTop.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1]", "[MulZeroClass \u03b1] {a b : WithTop \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : MulZeroClass \u03b1\na b : WithTop \u03b1\n\u22a2 a * b = if a = 0 \u2228 b = 0 then 0 else WithTop.map\u2082 (fun x1 x2 => x1 * x2) a b"}, {"line": "cases a <;> cases b <;> aesop", "tactic_state": "\u03b1 : Type u_1\ninst : DecidableEq \u03b1\ninst_1 : MulZeroClass \u03b1\n\u22a2 \u22a4 * 0 = 0\n---\n\u03b1 : Type u_1\ninst : DecidableEq \u03b1\ninst_1 : MulZeroClass \u03b1\n\u22a2 0 * \u22a4 = 0\n---\ncase inl\n\u03b1 : Type u_1\ninst : DecidableEq \u03b1\ninst_1 : MulZeroClass \u03b1\na_1 : \u03b1\n\u22a2 0 * \u2191a_1 = 0\n---\ncase inr\n\u03b1 : Type u_1\ninst : DecidableEq \u03b1\ninst_1 : MulZeroClass \u03b1\na : \u03b1\n\u22a2 \u2191a * 0 = 0"}]}
{"declaration": "theorem mul_ne_top {a b : WithTop \u03b1} (ha : a \u2260 \u22a4) (hb : b \u2260 \u22a4) : a * b \u2260 \u22a4 := by\n  simp [mul_eq_top_iff, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/WithTop.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1]", "[MulZeroClass \u03b1] {a b : WithTop \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : MulZeroClass \u03b1\na b : WithTop \u03b1\nha : a \u2260 \u22a4\nhb : b \u2260 \u22a4\n\u22a2 a * b \u2260 \u22a4"}, {"line": "simp [mul_eq_top_iff, *]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : MulZeroClass \u03b1\na b : WithTop \u03b1\nha : a \u2260 \u22a4\nhb : b \u2260 \u22a4\n\u22a2 \u00aca * b = \u22a4"}]}
{"declaration": "theorem mul_lt_top [LT \u03b1] {a b : WithTop \u03b1} (ha : a < \u22a4) (hb : b < \u22a4) : a * b < \u22a4 := by\n  rw [WithTop.lt_top_iff_ne_top] at *\n  exact mul_ne_top ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/WithTop.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1]", "[MulZeroClass \u03b1] {a b : WithTop \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : MulZeroClass \u03b1\ninst\u271d : LT \u03b1\na b : WithTop \u03b1\nha : a < \u22a4\nhb : b < \u22a4\n\u22a2 a * b < \u22a4"}, {"line": "rw [WithTop.lt_top_iff_ne_top] at *", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : MulZeroClass \u03b1\ninst\u271d : LT \u03b1\na b : WithTop \u03b1\nha : a \u2260 \u22a4\nhb : b \u2260 \u22a4\n\u22a2 a * b \u2260 \u22a4"}, {"line": "exact mul_ne_top ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_def (a b : WithBot \u03b1) :\n    a * b = if a = 0 \u2228 b = 0 then 0 else WithBot.map\u2082 (\u00b7 * \u00b7) a b := by\n  cases a <;> cases b <;> aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/WithTop.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1]", "[MulZeroClass \u03b1] {a b : WithTop \u03b1}", "[MonoidWithZero \u03b1] [NoZeroDivisors \u03b1] [Nontrivial \u03b1] {x : WithTop \u03b1} {n : \u2115}", "[CommSemiring \u03b1] [PartialOrder \u03b1] [CanonicallyOrderedAdd \u03b1] [PosMulStrictMono \u03b1]", "[NoZeroDivisors \u03b1] [Nontrivial \u03b1] {a b : WithTop \u03b1}", "[DecidableEq \u03b1]", "[MulZeroClass \u03b1] {a b : WithBot \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9\u00b9 : MulZeroClass \u03b1\ninst\u271d\u00b9\u2070 : MonoidWithZero \u03b1\ninst\u271d\u2079 : NoZeroDivisors \u03b1\ninst\u271d\u2078 : Nontrivial \u03b1\ninst\u271d\u2077 : CommSemiring \u03b1\ninst\u271d\u2076 : PartialOrder \u03b1\ninst\u271d\u2075 : CanonicallyOrderedAdd \u03b1\ninst\u271d\u2074 : PosMulStrictMono \u03b1\ninst\u271d\u00b3 : NoZeroDivisors \u03b1\ninst\u271d\u00b2 : Nontrivial \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : MulZeroClass \u03b1\na b : WithBot \u03b1\n\u22a2 a * b = if a = 0 \u2228 b = 0 then 0 else WithBot.map\u2082 (fun x1 x2 => x1 * x2) a b"}, {"line": "cases a <;> cases b <;> aesop", "tactic_state": "\u03b1 : Type u_1\ninst : DecidableEq \u03b1\ninst_1 : MulZeroClass \u03b1\ninst_2 : MonoidWithZero \u03b1\ninst_3 : NoZeroDivisors \u03b1\ninst_5 : CommSemiring \u03b1\ninst_6 : PartialOrder \u03b1\ninst_7 : CanonicallyOrderedAdd \u03b1\ninst_8 : PosMulStrictMono \u03b1\ninst_9 : NoZeroDivisors \u03b1\ninst_10 : Nontrivial \u03b1\ninst_11 : DecidableEq \u03b1\ninst_12 : MulZeroClass \u03b1\n\u22a2 \u22a5 * 0 = 0\n---\n\u03b1 : Type u_1\ninst : DecidableEq \u03b1\ninst_1 : MulZeroClass \u03b1\ninst_2 : MonoidWithZero \u03b1\ninst_3 : NoZeroDivisors \u03b1\ninst_5 : CommSemiring \u03b1\ninst_6 : PartialOrder \u03b1\ninst_7 : CanonicallyOrderedAdd \u03b1\ninst_8 : PosMulStrictMono \u03b1\ninst_9 : NoZeroDivisors \u03b1\ninst_10 : Nontrivial \u03b1\ninst_11 : DecidableEq \u03b1\ninst_12 : MulZeroClass \u03b1\n\u22a2 0 * \u22a5 = 0\n---\ncase inl\n\u03b1 : Type u_1\ninst : DecidableEq \u03b1\ninst_1 : MulZeroClass \u03b1\ninst_2 : MonoidWithZero \u03b1\ninst_3 : NoZeroDivisors \u03b1\ninst_5 : CommSemiring \u03b1\ninst_6 : PartialOrder \u03b1\ninst_7 : CanonicallyOrderedAdd \u03b1\ninst_8 : PosMulStrictMono \u03b1\ninst_9 : NoZeroDivisors \u03b1\ninst_10 : Nontrivial \u03b1\ninst_11 : DecidableEq \u03b1\ninst_12 : MulZeroClass \u03b1\na_1 : \u03b1\n\u22a2 0 * \u2191a_1 = 0\n---\ncase inr\n\u03b1 : Type u_1\ninst : DecidableEq \u03b1\ninst_1 : MulZeroClass \u03b1\ninst_2 : MonoidWithZero \u03b1\ninst_3 : NoZeroDivisors \u03b1\ninst_5 : CommSemiring \u03b1\ninst_6 : PartialOrder \u03b1\ninst_7 : CanonicallyOrderedAdd \u03b1\ninst_8 : PosMulStrictMono \u03b1\ninst_9 : NoZeroDivisors \u03b1\ninst_10 : Nontrivial \u03b1\ninst_11 : DecidableEq \u03b1\ninst_12 : MulZeroClass \u03b1\na : \u03b1\n\u22a2 \u2191a * 0 = 0\n---\n\u03b1 : Type u_1\ninst : DecidableEq \u03b1\ninst_1 : MulZeroClass \u03b1\ninst_2 : MonoidWithZero \u03b1\ninst_3 : NoZeroDivisors \u03b1\ninst_5 : CommSemiring \u03b1\ninst_6 : PartialOrder \u03b1\ninst_7 : CanonicallyOrderedAdd \u03b1\ninst_8 : PosMulStrictMono \u03b1\ninst_9 : NoZeroDivisors \u03b1\ninst_10 : Nontrivial \u03b1\ninst_11 : DecidableEq \u03b1\ninst_12 : MulZeroClass \u03b1\na a_1 : \u03b1\nleft : \u00aca = 0\nright : \u00aca_1 = 0\n\u22a2 \u2191a * \u2191a_1 = \u2191(a * a_1)"}]}
{"declaration": "theorem add_le_mul_two_add [ZeroLEOneClass R] [MulPosMono R] [AddLeftMono R]\n    (a2 : 2 \u2264 a) (b0 : 0 \u2264 b) : a + (2 + b) \u2264 a * (2 + b) :=\n  calc\n    a + (2 + b) \u2264 a + (a + a * b) :=\n      add_le_add_left (add_le_add a2 <| le_mul_of_one_le_left b0 <| one_le_two.trans a2) a\n    _ \u2264 a * (2 + b) := by rw [mul_add, mul_two, add_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{R : Type u} {\u03b1 : Type*}", "[Semiring R] [Preorder R] {a b c d : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Preorder R\na b : R\ninst\u271d\u00b2 : ZeroLEOneClass R\ninst\u271d\u00b9 : MulPosMono R\ninst\u271d : AddLeftMono R\na2 : 2 \u2264 a\nb0 : 0 \u2264 b\n\u22a2 a + (a + a * b) \u2264 a * (2 + b)"}, {"line": "rw [mul_add, mul_two, add_assoc]", "tactic_state": "R : Type u\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Preorder R\na b : R\ninst\u271d\u00b2 : ZeroLEOneClass R\ninst\u271d\u00b9 : MulPosMono R\ninst\u271d : AddLeftMono R\na2 : 2 \u2264 a\nb0 : 0 \u2264 b\n\u22a2 a + (a + a * b) \u2264 a + (a + a * b)"}]}
{"declaration": "theorem mul_nonneg_of_nonpos_of_nonpos [ExistsAddOfLE R] [MulPosMono R]\n    [AddRightMono R] [AddRightReflectLE R]\n    (ha : a \u2264 0) (hb : b \u2264 0) : 0 \u2264 a * b := by\n  simpa only [zero_mul] using mul_le_mul_of_nonpos_right ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{R : Type u} {\u03b1 : Type*}", "[Semiring R] [Preorder R] {a b c d : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Preorder R\na b : R\ninst\u271d\u00b3 : ExistsAddOfLE R\ninst\u271d\u00b2 : MulPosMono R\ninst\u271d\u00b9 : AddRightMono R\ninst\u271d : AddRightReflectLE R\nha : a \u2264 0\nhb : b \u2264 0\n\u22a2 0 \u2264 a * b"}, {"line": "simpa only [zero_mul] using mul_le_mul_of_nonpos_right ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_mul_of_le_one_left [ExistsAddOfLE R] [MulPosMono R]\n    [AddRightMono R] [AddRightReflectLE R]\n    (hb : b \u2264 0) (h : a \u2264 1) : b \u2264 a * b := by\n  simpa only [one_mul] using mul_le_mul_of_nonpos_right h hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{R : Type u} {\u03b1 : Type*}", "[Semiring R] [Preorder R] {a b c d : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Preorder R\na b : R\ninst\u271d\u00b3 : ExistsAddOfLE R\ninst\u271d\u00b2 : MulPosMono R\ninst\u271d\u00b9 : AddRightMono R\ninst\u271d : AddRightReflectLE R\nhb : b \u2264 0\nh : a \u2264 1\n\u22a2 b \u2264 a * b"}, {"line": "simpa only [one_mul] using mul_le_mul_of_nonpos_right h hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_le_of_one_le_left [ExistsAddOfLE R] [MulPosMono R]\n    [AddRightMono R] [AddRightReflectLE R]\n    (hb : b \u2264 0) (h : 1 \u2264 a) : a * b \u2264 b := by\n  simpa only [one_mul] using mul_le_mul_of_nonpos_right h hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{R : Type u} {\u03b1 : Type*}", "[Semiring R] [Preorder R] {a b c d : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Preorder R\na b : R\ninst\u271d\u00b3 : ExistsAddOfLE R\ninst\u271d\u00b2 : MulPosMono R\ninst\u271d\u00b9 : AddRightMono R\ninst\u271d : AddRightReflectLE R\nhb : b \u2264 0\nh : 1 \u2264 a\n\u22a2 a * b \u2264 b"}, {"line": "simpa only [one_mul] using mul_le_mul_of_nonpos_right h hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_mul_of_le_one_right [ExistsAddOfLE R] [PosMulMono R]\n    [AddRightMono R] [AddRightReflectLE R]\n    (ha : a \u2264 0) (h : b \u2264 1) : a \u2264 a * b := by\n  simpa only [mul_one] using mul_le_mul_of_nonpos_left h ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{R : Type u} {\u03b1 : Type*}", "[Semiring R] [Preorder R] {a b c d : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Preorder R\na b : R\ninst\u271d\u00b3 : ExistsAddOfLE R\ninst\u271d\u00b2 : PosMulMono R\ninst\u271d\u00b9 : AddRightMono R\ninst\u271d : AddRightReflectLE R\nha : a \u2264 0\nh : b \u2264 1\n\u22a2 a \u2264 a * b"}, {"line": "simpa only [mul_one] using mul_le_mul_of_nonpos_left h ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_le_of_one_le_right [ExistsAddOfLE R] [PosMulMono R]\n    [AddRightMono R] [AddRightReflectLE R]\n    (ha : a \u2264 0) (h : 1 \u2264 b) : a * b \u2264 a := by\n  simpa only [mul_one] using mul_le_mul_of_nonpos_left h ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{R : Type u} {\u03b1 : Type*}", "[Semiring R] [Preorder R] {a b c d : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Preorder R\na b : R\ninst\u271d\u00b3 : ExistsAddOfLE R\ninst\u271d\u00b2 : PosMulMono R\ninst\u271d\u00b9 : AddRightMono R\ninst\u271d : AddRightReflectLE R\nha : a \u2264 0\nh : 1 \u2264 b\n\u22a2 a * b \u2264 a"}, {"line": "simpa only [mul_one] using mul_le_mul_of_nonpos_left h ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_nonneg_iff_of_pos_left [PosMulStrictMono R]\n    (h : 0 < c) : 0 \u2264 c * b \u2194 0 \u2264 b := by\n  convert mul_le_mul_left h\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{R : Type u} {\u03b1 : Type*}", "[Semiring R] [Preorder R] {a b c d : R}", "[Preorder \u03b1] {f g : \u03b1 \u2192 R}", "[Semiring R] [PartialOrder R] {a b c d : R}", "[Preorder \u03b1] {f : \u03b1 \u2192 R}", "[AddLeftReflectLT R]", "[Semiring R] [LinearOrder R] {a b c : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Preorder R\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 : AddLeftReflectLT R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : LinearOrder R\nb c : R\ninst\u271d : PosMulStrictMono R\nh : 0 < c\n\u22a2 0 \u2264 c * b \u2194 0 \u2264 b"}, {"line": "convert mul_le_mul_left h", "tactic_state": "case h.e'_1.h.e'_3\nR : Type u\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Preorder R\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 : AddLeftReflectLT R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : LinearOrder R\nb c : R\ninst\u271d : PosMulStrictMono R\nh : 0 < c\n\u22a2 0 = c * 0\n---\ncase convert_4\nR : Type u\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Preorder R\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 : AddLeftReflectLT R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : LinearOrder R\nb c : R\ninst\u271d : PosMulStrictMono R\nh : 0 < c\n\u22a2 PosMulMono R\n---\ncase convert_5\nR : Type u\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Preorder R\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 : AddLeftReflectLT R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : LinearOrder R\nb c : R\ninst\u271d : PosMulStrictMono R\nh : 0 < c\n\u22a2 PosMulReflectLE R"}, {"line": "simp", "tactic_state": "case convert_4\nR : Type u\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Preorder R\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 : AddLeftReflectLT R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : LinearOrder R\nb c : R\ninst\u271d : PosMulStrictMono R\nh : 0 < c\n\u22a2 PosMulMono R\n---\ncase convert_5\nR : Type u\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Preorder R\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 : AddLeftReflectLT R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : LinearOrder R\nb c : R\ninst\u271d : PosMulStrictMono R\nh : 0 < c\n\u22a2 PosMulReflectLE R"}]}
{"declaration": "lemma sq_nonpos_iff [IsRightCancelAdd R] [ZeroLEOneClass R] [ExistsAddOfLE R]\n    [PosMulMono R] [AddLeftStrictMono R] [NoZeroDivisors R] (r : R) :\n    r ^ 2 \u2264 0 \u2194 r = 0 := by\n  trans r ^ 2 = 0\n  \u00b7 rw [le_antisymm_iff, and_iff_left (sq_nonneg r)]\n  \u00b7 exact sq_eq_zero_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{R : Type u} {\u03b1 : Type*}", "[Semiring R] [Preorder R] {a b c d : R}", "[Preorder \u03b1] {f g : \u03b1 \u2192 R}", "[Semiring R] [PartialOrder R] {a b c d : R}", "[Preorder \u03b1] {f : \u03b1 \u2192 R}", "[AddLeftReflectLT R]", "[Semiring R] [LinearOrder R] {a b c : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Preorder R\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : PartialOrder R\ninst\u271d\u2078 : AddLeftReflectLT R\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : LinearOrder R\ninst\u271d\u2075 : IsRightCancelAdd R\ninst\u271d\u2074 : ZeroLEOneClass R\ninst\u271d\u00b3 : ExistsAddOfLE R\ninst\u271d\u00b2 : PosMulMono R\ninst\u271d\u00b9 : AddLeftStrictMono R\ninst\u271d : NoZeroDivisors R\nr : R\n\u22a2 r ^ 2 \u2264 0 \u2194 r = 0"}, {"line": "trans r ^ 2 = 0", "tactic_state": "R : Type u\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Preorder R\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : PartialOrder R\ninst\u271d\u2078 : AddLeftReflectLT R\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : LinearOrder R\ninst\u271d\u2075 : IsRightCancelAdd R\ninst\u271d\u2074 : ZeroLEOneClass R\ninst\u271d\u00b3 : ExistsAddOfLE R\ninst\u271d\u00b2 : PosMulMono R\ninst\u271d\u00b9 : AddLeftStrictMono R\ninst\u271d : NoZeroDivisors R\nr : R\n\u22a2 r ^ 2 \u2264 0 \u2194 r ^ 2 = 0\n---\nR : Type u\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Preorder R\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : PartialOrder R\ninst\u271d\u2078 : AddLeftReflectLT R\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : LinearOrder R\ninst\u271d\u2075 : IsRightCancelAdd R\ninst\u271d\u2074 : ZeroLEOneClass R\ninst\u271d\u00b3 : ExistsAddOfLE R\ninst\u271d\u00b2 : PosMulMono R\ninst\u271d\u00b9 : AddLeftStrictMono R\ninst\u271d : NoZeroDivisors R\nr : R\n\u22a2 r ^ 2 = 0 \u2194 r = 0\n---\ncase _1\nR : Type u\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Preorder R\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : PartialOrder R\ninst\u271d\u2078 : AddLeftReflectLT R\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : LinearOrder R\ninst\u271d\u2075 : IsRightCancelAdd R\ninst\u271d\u2074 : ZeroLEOneClass R\ninst\u271d\u00b3 : ExistsAddOfLE R\ninst\u271d\u00b2 : PosMulMono R\ninst\u271d\u00b9 : AddLeftStrictMono R\ninst\u271d : NoZeroDivisors R\nr : R\n\u22a2 OfNat R 0\n---\ncase _2\nR : Type u\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Preorder R\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : PartialOrder R\ninst\u271d\u2078 : AddLeftReflectLT R\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : LinearOrder R\ninst\u271d\u2075 : IsRightCancelAdd R\ninst\u271d\u2074 : ZeroLEOneClass R\ninst\u271d\u00b3 : ExistsAddOfLE R\ninst\u271d\u00b2 : PosMulMono R\ninst\u271d\u00b9 : AddLeftStrictMono R\ninst\u271d : NoZeroDivisors R\nr : R\n\u22a2 HPow R \u2115 R"}, {"line": "\u00b7 rw [le_antisymm_iff, and_iff_left (sq_nonneg r)]", "tactic_state": "R : Type u\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Preorder R\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : PartialOrder R\ninst\u271d\u2078 : AddLeftReflectLT R\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : LinearOrder R\ninst\u271d\u2075 : IsRightCancelAdd R\ninst\u271d\u2074 : ZeroLEOneClass R\ninst\u271d\u00b3 : ExistsAddOfLE R\ninst\u271d\u00b2 : PosMulMono R\ninst\u271d\u00b9 : AddLeftStrictMono R\ninst\u271d : NoZeroDivisors R\nr : R\n\u22a2 r ^ 2 = 0 \u2194 r = 0\n---\ncase _1\nR : Type u\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Preorder R\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : PartialOrder R\ninst\u271d\u2078 : AddLeftReflectLT R\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : LinearOrder R\ninst\u271d\u2075 : IsRightCancelAdd R\ninst\u271d\u2074 : ZeroLEOneClass R\ninst\u271d\u00b3 : ExistsAddOfLE R\ninst\u271d\u00b2 : PosMulMono R\ninst\u271d\u00b9 : AddLeftStrictMono R\ninst\u271d : NoZeroDivisors R\nr : R\n\u22a2 OfNat R 0\n---\ncase _2\nR : Type u\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Preorder R\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : PartialOrder R\ninst\u271d\u2078 : AddLeftReflectLT R\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : LinearOrder R\ninst\u271d\u2075 : IsRightCancelAdd R\ninst\u271d\u2074 : ZeroLEOneClass R\ninst\u271d\u00b3 : ExistsAddOfLE R\ninst\u271d\u00b2 : PosMulMono R\ninst\u271d\u00b9 : AddLeftStrictMono R\ninst\u271d : NoZeroDivisors R\nr : R\n\u22a2 HPow R \u2115 R"}, {"line": "\u00b7 exact sq_eq_zero_iff", "tactic_state": "case _1\nR : Type u\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Preorder R\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : PartialOrder R\ninst\u271d\u2078 : AddLeftReflectLT R\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : LinearOrder R\ninst\u271d\u2075 : IsRightCancelAdd R\ninst\u271d\u2074 : ZeroLEOneClass R\ninst\u271d\u00b3 : ExistsAddOfLE R\ninst\u271d\u00b2 : PosMulMono R\ninst\u271d\u00b9 : AddLeftStrictMono R\ninst\u271d : NoZeroDivisors R\nr : R\n\u22a2 OfNat R 0\n---\ncase _2\nR : Type u\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Preorder R\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : PartialOrder R\ninst\u271d\u2078 : AddLeftReflectLT R\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : LinearOrder R\ninst\u271d\u2075 : IsRightCancelAdd R\ninst\u271d\u2074 : ZeroLEOneClass R\ninst\u271d\u00b3 : ExistsAddOfLE R\ninst\u271d\u00b2 : PosMulMono R\ninst\u271d\u00b9 : AddLeftStrictMono R\ninst\u271d : NoZeroDivisors R\nr : R\n\u22a2 HPow R \u2115 R"}]}
{"declaration": "lemma mul_self_nonneg [IsRightCancelAdd R]\n    [ZeroLEOneClass R] [ExistsAddOfLE R] [PosMulMono R] [AddLeftStrictMono R]\n    (a : R) : 0 \u2264 a * a := by simpa only [sq] using sq_nonneg a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{R : Type u} {\u03b1 : Type*}", "[Semiring R] [Preorder R] {a b c d : R}", "[Preorder \u03b1] {f g : \u03b1 \u2192 R}", "[Semiring R] [PartialOrder R] {a b c d : R}", "[Preorder \u03b1] {f : \u03b1 \u2192 R}", "[AddLeftReflectLT R]", "[Semiring R] [LinearOrder R] {a b c : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9\u00b9 : Semiring R\ninst\u271d\u00b9\u2070 : Preorder R\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddLeftReflectLT R\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : LinearOrder R\ninst\u271d\u2074 : IsRightCancelAdd R\ninst\u271d\u00b3 : ZeroLEOneClass R\ninst\u271d\u00b2 : ExistsAddOfLE R\ninst\u271d\u00b9 : PosMulMono R\ninst\u271d : AddLeftStrictMono R\na : R\n\u22a2 0 \u2264 a * a"}, {"line": "simpa only [sq] using sq_nonneg a", "tactic_state": "No Goals!"}]}
{"declaration": "lemma two_mul_le_add_sq [ExistsAddOfLE R] [MulPosStrictMono R]\n    [AddLeftReflectLE R] [AddLeftMono R]\n    (a b : R) : 2 * a * b \u2264 a ^ 2 + b ^ 2 := by\n  simpa [fn_min_add_fn_max (fun x \u21a6 x * x), sq, two_mul, add_mul]\n    using mul_add_mul_le_mul_add_mul (@min_le_max _ _ a b) (@min_le_max _ _ a b)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{R : Type u} {\u03b1 : Type*}", "[Semiring R] [Preorder R] {a b c d : R}", "[Preorder \u03b1] {f g : \u03b1 \u2192 R}", "[Semiring R] [PartialOrder R] {a b c d : R}", "[Preorder \u03b1] {f : \u03b1 \u2192 R}", "[AddLeftReflectLT R]", "[Semiring R] [LinearOrder R] {a b c : R}", "[CommSemiring R] [LinearOrder R] {a d : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Preorder R\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : PartialOrder R\ninst\u271d\u2078 : AddLeftReflectLT R\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : LinearOrder R\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : ExistsAddOfLE R\ninst\u271d\u00b2 : MulPosStrictMono R\ninst\u271d\u00b9 : AddLeftReflectLE R\ninst\u271d : AddLeftMono R\na b : R\n\u22a2 2 * a * b \u2264 a ^ 2 + b ^ 2"}, {"line": "simpa [fn_min_add_fn_max (fun x \u21a6 x * x), sq, two_mul, add_mul]\n    using mul_add_mul_le_mul_add_mul (@min_le_max _ _ a b) (@min_le_max _ _ a b)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_lt_div_iff_mul_lt_mul {a b c d : \u2124} (b_pos : 0 < b) (d_pos : 0 < d) :\n    (a : \u211a) / b < c / d \u2194 a * d < c * b := by\n  simp only [lt_iff_le_not_le]\n  apply and_congr\n  \u00b7 simp [div_def', Rat.divInt_le_divInt b_pos d_pos]\n  \u00b7 apply not_congr\n    simp [div_def', Rat.divInt_le_divInt d_pos b_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Unbundled/Rat.lean", "context": {"open": [], "variables": ["{a b p q : \u211a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2124\nb_pos : 0 < b\nd_pos : 0 < d\n\u22a2 \u2191a / \u2191b < \u2191c / \u2191d \u2194 a * d < c * b"}, {"line": "simp only [lt_iff_le_not_le]", "tactic_state": "a b c d : \u2124\nb_pos : 0 < b\nd_pos : 0 < d\n\u22a2 \u2191a / \u2191b \u2264 \u2191c / \u2191d \u2227 \u00ac\u2191c / \u2191d \u2264 \u2191a / \u2191b \u2194 a * d \u2264 c * b \u2227 \u00acc * b \u2264 a * d"}, {"line": "apply and_congr", "tactic_state": "case h\u2081\na b c d : \u2124\nb_pos : 0 < b\nd_pos : 0 < d\n\u22a2 \u2191a / \u2191b \u2264 \u2191c / \u2191d \u2194 a * d \u2264 c * b\n---\ncase h\u2082\na b c d : \u2124\nb_pos : 0 < b\nd_pos : 0 < d\n\u22a2 \u00ac\u2191c / \u2191d \u2264 \u2191a / \u2191b \u2194 \u00acc * b \u2264 a * d"}, {"line": "\u00b7 simp [div_def', Rat.divInt_le_divInt b_pos d_pos]", "tactic_state": "case h\u2082\na b c d : \u2124\nb_pos : 0 < b\nd_pos : 0 < d\n\u22a2 \u00ac\u2191c / \u2191d \u2264 \u2191a / \u2191b \u2194 \u00acc * b \u2264 a * d"}, {"line": "\u00b7 apply not_congr\n    simp [div_def', Rat.divInt_le_divInt d_pos b_pos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_one_iff_num_lt_denom {q : \u211a} : q < 1 \u2194 q.num < q.den := by simp [Rat.lt_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Ring/Unbundled/Rat.lean", "context": {"open": [], "variables": ["{a b p q : \u211a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : \u211a\n\u22a2 q < 1 \u2194 q.num < \u2191q.den"}, {"line": "simp [Rat.lt_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_star_self_nonneg (r : R) : 0 \u2264 r * star r := by\n  simpa only [star_star] using star_mul_self_nonneg (star r)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\nr : R\n\u22a2 0 \u2264 r * star r"}, {"line": "simpa only [star_star] using star_mul_self_nonneg (star r)", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsSelfAdjoint.mul_self_nonneg {a : R} (ha : IsSelfAdjoint a) : 0 \u2264 a * a := by\n  simpa [ha.star_eq] using star_mul_self_nonneg a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\na : R\nha : IsSelfAdjoint a\n\u22a2 0 \u2264 a * a"}, {"line": "simpa [ha.star_eq] using star_mul_self_nonneg a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem conjugate_nonneg' {a : R} (ha : 0 \u2264 a) (c : R) : 0 \u2264 c * a * star c := by\n  simpa only [star_star] using conjugate_nonneg ha (star c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\na : R\nha : 0 \u2264 a\nc : R\n\u22a2 0 \u2264 c * a * star c"}, {"line": "simpa only [star_star] using conjugate_nonneg ha (star c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem conjugate_le_conjugate' {a b : R} (hab : a \u2264 b) (c : R) :\n    c * a * star c \u2264 c * b * star c := by\n  simpa only [star_star] using conjugate_le_conjugate hab (star c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\na b : R\nhab : a \u2264 b\nc : R\n\u22a2 c * a * star c \u2264 c * b * star c"}, {"line": "simpa only [star_star] using conjugate_le_conjugate hab (star c)", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsSelfAdjoint.conjugate_le_conjugate {a b : R} (hab : a \u2264 b) {c : R}\n    (hc : IsSelfAdjoint c) : c * a * c \u2264 c * b * c := by\n  simpa only [hc.star_eq] using conjugate_le_conjugate hab c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\na b : R\nhab : a \u2264 b\nc : R\nhc : IsSelfAdjoint c\n\u22a2 c * a * c \u2264 c * b * c"}, {"line": "simpa only [hc.star_eq] using conjugate_le_conjugate hab c", "tactic_state": "No Goals!"}]}
{"declaration": "lemma star_lt_star_iff {x y : R} : star x < star y \u2194 x < y := by\n  by_cases h : x = y\n  \u00b7 simp [h]\n  \u00b7 simpa [le_iff_lt_or_eq, h] using star_le_star_iff (x := x) (y := y)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\nx y : R\n\u22a2 star x < star y \u2194 x < y"}, {"line": "by_cases h : x = y", "tactic_state": "case pos\nR : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\nx y : R\nh : x = y\n\u22a2 star x < star y \u2194 x < y\n---\ncase neg\nR : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\nx y : R\nh : \u00acx = y\n\u22a2 star x < star y \u2194 x < y"}, {"line": "\u00b7 simp [h]", "tactic_state": "case neg\nR : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\nx y : R\nh : \u00acx = y\n\u22a2 star x < star y \u2194 x < y"}, {"line": "\u00b7 simpa [le_iff_lt_or_eq, h] using star_le_star_iff (x := x) (y := y)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma star_le_iff {x y : R} : star x \u2264 y \u2194 x \u2264 star y := by rw [\u2190 star_le_star_iff, star_star]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\nx y : R\n\u22a2 star x \u2264 y \u2194 x \u2264 star y"}, {"line": "rw [\u2190 star_le_star_iff, star_star]", "tactic_state": "R : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\nx y : R\n\u22a2 StarOrderedRing R"}]}
{"declaration": "lemma star_lt_iff {x y : R} : star x < y \u2194 x < star y := by rw [\u2190 star_lt_star_iff, star_star]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\nx y : R\n\u22a2 star x < y \u2194 x < star y"}, {"line": "rw [\u2190 star_lt_star_iff, star_star]", "tactic_state": "R : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\nx y : R\n\u22a2 StarOrderedRing R"}]}
{"declaration": "lemma star_nonneg_iff {x : R} : 0 \u2264 star x \u2194 0 \u2264 x := by\n  simpa using star_le_star_iff (x := 0) (y := x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\nx : R\n\u22a2 0 \u2264 star x \u2194 0 \u2264 x"}, {"line": "simpa using star_le_star_iff (x := 0) (y := x)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma star_nonpos_iff {x : R} : star x \u2264 0 \u2194 x \u2264 0 := by\n  simpa using star_le_star_iff (x := x) (y := 0)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\nx : R\n\u22a2 star x \u2264 0 \u2194 x \u2264 0"}, {"line": "simpa using star_le_star_iff (x := x) (y := 0)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma star_pos_iff {x : R} : 0 < star x \u2194 0 < x := by\n  simpa using star_lt_star_iff (x := 0) (y := x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\nx : R\n\u22a2 0 < star x \u2194 0 < x"}, {"line": "simpa using star_lt_star_iff (x := 0) (y := x)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma star_neg_iff {x : R} : star x < 0 \u2194 x < 0 := by\n  simpa using star_lt_star_iff (x := x) (y := 0)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\nx : R\n\u22a2 star x < 0 \u2194 x < 0"}, {"line": "simpa using star_lt_star_iff (x := x) (y := 0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem conjugate_lt_conjugate' {a b : R} (hab : a < b) {c : R} (hc : IsRegular c) :\n    c * a * star c < c * b * star c := by\n  simpa only [star_star] using conjugate_lt_conjugate hab hc.star\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\na b : R\nhab : a < b\nc : R\nhc : IsRegular c\n\u22a2 c * a * star c < c * b * star c"}, {"line": "simpa only [star_star] using conjugate_lt_conjugate hab hc.star", "tactic_state": "No Goals!"}]}
{"declaration": "theorem conjugate_pos {a : R} (ha : 0 < a) {c : R} (hc : IsRegular c) : 0 < star c * a * c := by\n  simpa only [mul_zero, zero_mul] using conjugate_lt_conjugate ha hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\na : R\nha : 0 < a\nc : R\nhc : IsRegular c\n\u22a2 0 < star c * a * c"}, {"line": "simpa only [mul_zero, zero_mul] using conjugate_lt_conjugate ha hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_star_self_pos [Nontrivial R] {x : R} (hx : IsRegular x) : 0 < x * star x := by\n  simpa using star_mul_self_pos hx.star\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 : NonUnitalSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : StarRing R\ninst\u271d\u00b9 : StarOrderedRing R\ninst\u271d : Nontrivial R\nx : R\nhx : IsRegular x\n\u22a2 0 < x * star x"}, {"line": "simpa using star_mul_self_pos hx.star", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_le_star_iff {x : R} : 1 \u2264 star x \u2194 1 \u2264 x := by\n  simpa using star_le_star_iff (x := 1) (y := x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]", "[Semiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2077 : NonUnitalSemiring R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : StarRing R\ninst\u271d\u2074 : StarOrderedRing R\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\nx : R\n\u22a2 1 \u2264 star x \u2194 1 \u2264 x"}, {"line": "simpa using star_le_star_iff (x := 1) (y := x)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma star_le_one_iff {x : R} : star x \u2264 1 \u2194 x \u2264 1 := by\n  simpa using star_le_star_iff (x := x) (y := 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]", "[Semiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2077 : NonUnitalSemiring R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : StarRing R\ninst\u271d\u2074 : StarOrderedRing R\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\nx : R\n\u22a2 star x \u2264 1 \u2194 x \u2264 1"}, {"line": "simpa using star_le_star_iff (x := x) (y := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_lt_star_iff {x : R} : 1 < star x \u2194 1 < x := by\n  simpa using star_lt_star_iff (x := 1) (y := x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]", "[Semiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2077 : NonUnitalSemiring R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : StarRing R\ninst\u271d\u2074 : StarOrderedRing R\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\nx : R\n\u22a2 1 < star x \u2194 1 < x"}, {"line": "simpa using star_lt_star_iff (x := 1) (y := x)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma star_lt_one_iff {x : R} : star x < 1 \u2194 x < 1 := by\n  simpa using star_lt_star_iff (x := x) (y := 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]", "[Semiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2077 : NonUnitalSemiring R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : StarRing R\ninst\u271d\u2074 : StarOrderedRing R\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\nx : R\n\u22a2 star x < 1 \u2194 x < 1"}, {"line": "simpa using star_lt_star_iff (x := x) (y := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsSelfAdjoint.sq_nonneg {a : R} (ha : IsSelfAdjoint a) : 0 \u2264 a ^ 2 := by\n  simp [sq, ha.mul_self_nonneg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Star/Basic.lean", "context": {"open": ["Set", "scoped NNRat"], "variables": ["{R : Type u}", "[NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]", "[Semiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2077 : NonUnitalSemiring R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : StarRing R\ninst\u271d\u2074 : StarOrderedRing R\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\na : R\nha : IsSelfAdjoint a\n\u22a2 0 \u2264 a ^ 2"}, {"line": "simp [sq, ha.mul_self_nonneg]", "tactic_state": "R : Type u\ninst\u271d\u2077 : NonUnitalSemiring R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : StarRing R\ninst\u271d\u2074 : StarOrderedRing R\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : PartialOrder R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : StarOrderedRing R\na : R\nha : IsSelfAdjoint a\n\u22a2 0 \u2264 a * a"}]}
{"declaration": "theorem tsub_eq_zero_iff_le : a - b = 0 \u2194 a \u2264 b := by\n  rw [\u2190 nonpos_iff_eq_zero]\n  rw [tsub_le_iff_left]\n  rw [add_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Sub/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [CanonicallyOrderedAdd \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 a - b = 0 \u2194 a \u2264 b"}, {"line": "rw [\u2190 nonpos_iff_eq_zero]", "tactic_state": "a b : \u2115\n\u22a2 a - b \u2264 0 \u2194 a \u2264 b"}, {"line": "rw [tsub_le_iff_left]", "tactic_state": "a b : \u2115\n\u22a2 a \u2264 b + 0 \u2194 a \u2264 b"}, {"line": "rw [add_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tsub_pos_iff_not_le : 0 < a - b \u2194 \u00aca \u2264 b := by\n  rw [pos_iff_ne_zero]\n  rw [Ne]\n  rw [tsub_eq_zero_iff_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Sub/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [CanonicallyOrderedAdd \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 0 < a - b \u2194 \u00aca \u2264 b"}, {"line": "rw [pos_iff_ne_zero]", "tactic_state": "a b : \u2115\n\u22a2 a - b \u2260 0 \u2194 \u00aca \u2264 b"}, {"line": "rw [Ne]", "tactic_state": "a b : \u2115\n\u22a2 \u00aca - b = 0 \u2194 \u00aca \u2264 b"}, {"line": "rw [tsub_eq_zero_iff_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tsub_pos_iff_lt : 0 < a - b \u2194 b < a := by rw [tsub_pos_iff_not_le, not_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Sub/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [CanonicallyOrderedAdd \u03b1]", "[AddLeftReflectLE \u03b1]", "(\u03b1)", "[AddCommMonoid \u03b1] [LinearOrder \u03b1] [CanonicallyOrderedAdd \u03b1] [Sub \u03b1] [OrderedSub \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 0 < a - b \u2194 b < a"}, {"line": "rw [tsub_pos_iff_not_le, not_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tsub_le_iff_left : a - b \u2264 c \u2194 a \u2264 b + c := by rw [tsub_le_iff_right, add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Sub/Defs.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] [Add \u03b1] [Sub \u03b1] [OrderedSub \u03b1] {a b : \u03b1}", "[Preorder \u03b1]", "[AddCommSemigroup \u03b1] [Sub \u03b1] [OrderedSub \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Add \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 a - b \u2264 c \u2194 a \u2264 b + c"}, {"line": "rw [tsub_le_iff_right, add_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Add \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 a \u2264 b + c \u2194 a \u2264 b + c\n---\n\u03b1 : Type u_1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Add \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 AddCommMagma \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Add \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 OrderedSub \u03b1"}]}
{"declaration": "theorem tsub_le_iff_tsub_le : a - b \u2264 c \u2194 a - c \u2264 b := by rw [tsub_le_iff_left, tsub_le_iff_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Sub/Defs.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] [Add \u03b1] [Sub \u03b1] [OrderedSub \u03b1] {a b : \u03b1}", "[Preorder \u03b1]", "[AddCommSemigroup \u03b1] [Sub \u03b1] [OrderedSub \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Add \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 a - b \u2264 c \u2194 a - c \u2264 b"}, {"line": "rw [tsub_le_iff_left, tsub_le_iff_right]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Add \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 OrderedSub \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Add \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 AddCommSemigroup \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Add \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 OrderedSub \u03b1"}]}
{"declaration": "theorem tsub_right_comm : a - b - c = a - c - b := by\n  rw [\u2190 tsub_add_eq_tsub_tsub]\n  rw [tsub_add_eq_tsub_tsub_swap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Sub/Defs.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1] [Add \u03b1] [Sub \u03b1] [OrderedSub \u03b1] {a b : \u03b1}", "[Preorder \u03b1]", "[AddCommSemigroup \u03b1] [Sub \u03b1] [OrderedSub \u03b1] {a b c d : \u03b1}", "[AddLeftMono \u03b1]", "[AddLeftReflectLE \u03b1]", "[AddCommMonoid \u03b1] [Sub \u03b1] [OrderedSub \u03b1] {a b : \u03b1}", "[PartialOrder \u03b1] [AddCommSemigroup \u03b1] [Sub \u03b1] [OrderedSub \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : Add \u03b1\ninst\u271d\u00b9\u2074 : Sub \u03b1\ninst\u271d\u00b9\u00b3 : OrderedSub \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : AddCommSemigroup \u03b1\ninst\u271d\u00b9\u2070 : Sub \u03b1\ninst\u271d\u2079 : OrderedSub \u03b1\ninst\u271d\u2078 : AddLeftMono \u03b1\ninst\u271d\u2077 : AddLeftReflectLE \u03b1\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 a - b - c = a - c - b"}, {"line": "rw [\u2190 tsub_add_eq_tsub_tsub]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : Add \u03b1\ninst\u271d\u00b9\u2074 : Sub \u03b1\ninst\u271d\u00b9\u00b3 : OrderedSub \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : AddCommSemigroup \u03b1\ninst\u271d\u00b9\u2070 : Sub \u03b1\ninst\u271d\u2079 : OrderedSub \u03b1\ninst\u271d\u2078 : AddLeftMono \u03b1\ninst\u271d\u2077 : AddLeftReflectLE \u03b1\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 a - (b + c) = a - c - b\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : Add \u03b1\ninst\u271d\u00b9\u2074 : Sub \u03b1\ninst\u271d\u00b9\u00b3 : OrderedSub \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : AddCommSemigroup \u03b1\ninst\u271d\u00b9\u2070 : Sub \u03b1\ninst\u271d\u2079 : OrderedSub \u03b1\ninst\u271d\u2078 : AddLeftMono \u03b1\ninst\u271d\u2077 : AddLeftReflectLE \u03b1\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : Add \u03b1\ninst\u271d\u00b9\u2074 : Sub \u03b1\ninst\u271d\u00b9\u00b3 : OrderedSub \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : AddCommSemigroup \u03b1\ninst\u271d\u00b9\u2070 : Sub \u03b1\ninst\u271d\u2079 : OrderedSub \u03b1\ninst\u271d\u2078 : AddLeftMono \u03b1\ninst\u271d\u2077 : AddLeftReflectLE \u03b1\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 AddCommSemigroup \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : Add \u03b1\ninst\u271d\u00b9\u2074 : Sub \u03b1\ninst\u271d\u00b9\u00b3 : OrderedSub \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : AddCommSemigroup \u03b1\ninst\u271d\u00b9\u2070 : Sub \u03b1\ninst\u271d\u2079 : OrderedSub \u03b1\ninst\u271d\u2078 : AddLeftMono \u03b1\ninst\u271d\u2077 : AddLeftReflectLE \u03b1\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 OrderedSub \u03b1"}, {"line": "rw [tsub_add_eq_tsub_tsub_swap]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : Add \u03b1\ninst\u271d\u00b9\u2074 : Sub \u03b1\ninst\u271d\u00b9\u00b3 : OrderedSub \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : AddCommSemigroup \u03b1\ninst\u271d\u00b9\u2070 : Sub \u03b1\ninst\u271d\u2079 : OrderedSub \u03b1\ninst\u271d\u2078 : AddLeftMono \u03b1\ninst\u271d\u2077 : AddLeftReflectLE \u03b1\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : Add \u03b1\ninst\u271d\u00b9\u2074 : Sub \u03b1\ninst\u271d\u00b9\u00b3 : OrderedSub \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : AddCommSemigroup \u03b1\ninst\u271d\u00b9\u2070 : Sub \u03b1\ninst\u271d\u2079 : OrderedSub \u03b1\ninst\u271d\u2078 : AddLeftMono \u03b1\ninst\u271d\u2077 : AddLeftReflectLE \u03b1\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 AddCommSemigroup \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : Add \u03b1\ninst\u271d\u00b9\u2074 : Sub \u03b1\ninst\u271d\u00b9\u00b3 : OrderedSub \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : AddCommSemigroup \u03b1\ninst\u271d\u00b9\u2070 : Sub \u03b1\ninst\u271d\u2079 : OrderedSub \u03b1\ninst\u271d\u2078 : AddLeftMono \u03b1\ninst\u271d\u2077 : AddLeftReflectLE \u03b1\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 OrderedSub \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : Add \u03b1\ninst\u271d\u00b9\u2074 : Sub \u03b1\ninst\u271d\u00b9\u00b3 : OrderedSub \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : AddCommSemigroup \u03b1\ninst\u271d\u00b9\u2070 : Sub \u03b1\ninst\u271d\u2079 : OrderedSub \u03b1\ninst\u271d\u2078 : AddLeftMono \u03b1\ninst\u271d\u2077 : AddLeftReflectLE \u03b1\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 PartialOrder \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : Add \u03b1\ninst\u271d\u00b9\u2074 : Sub \u03b1\ninst\u271d\u00b9\u00b3 : OrderedSub \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : AddCommSemigroup \u03b1\ninst\u271d\u00b9\u2070 : Sub \u03b1\ninst\u271d\u2079 : OrderedSub \u03b1\ninst\u271d\u2078 : AddLeftMono \u03b1\ninst\u271d\u2077 : AddLeftReflectLE \u03b1\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : Sub \u03b1\ninst\u271d\u2074 : OrderedSub \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c : \u03b1\n\u22a2 OrderedSub \u03b1"}]}
{"declaration": "lemma sub_ne_top_iff {a b : WithTop \u03b1} : a - b \u2260 \u22a4 \u2194 a \u2260 \u22a4 \u2228 b = \u22a4 := by simp [or_iff_not_imp_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Sub/WithTop.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Sub \u03b1] [Bot \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : Bot \u03b1\na b : WithTop \u03b1\n\u22a2 a - b \u2260 \u22a4 \u2194 a \u2260 \u22a4 \u2228 b = \u22a4"}, {"line": "simp [or_iff_not_imp_left]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma succ_one : succ (1 : WithBot \u03b1) = 2 := by simpa [one_add_one_eq_two] using succ_natCast 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred/WithBot.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [Preorder \u03b1] [OrderBot \u03b1] [AddMonoidWithOne \u03b1] [SuccAddOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nsucc : x\u271d\n\u22a2 sorry = 2"}, {"line": "simpa [one_add_one_eq_two] using succ_natCast 1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_le_iff_pos {\u03b1 : Type*} [PartialOrder \u03b1] [AddMonoidWithOne \u03b1]\n    [ZeroLEOneClass \u03b1] [NeZero (1 : \u03b1)] [SuccAddOrder \u03b1] (a : WithBot \u03b1) : 1 \u2264 a \u2194 0 < a := by\n  cases a <;> simp [Order.one_le_iff_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred/WithBot.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [Preorder \u03b1] [OrderBot \u03b1] [AddMonoidWithOne \u03b1] [SuccAddOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : AddMonoidWithOne \u03b1\ninst\u271d\u00b2 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9 : NeZero 1\ninst\u271d : SuccAddOrder \u03b1\na : WithBot \u03b1\n\u22a2 1 \u2264 a \u2194 0 < a"}, {"line": "cases a <;> simp [Order.one_le_iff_pos]", "tactic_state": "case coe\n\u03b1 : Type u_2\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : AddMonoidWithOne \u03b1\ninst\u271d\u00b2 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9 : NeZero 1\ninst\u271d : SuccAddOrder \u03b1\na\u271d : \u03b1\n\u22a2 1 \u2264 a\u271d \u2194 0 < a\u271d"}]}
{"declaration": "lemma untop\u2080_eq_zero {a : WithTop \u03b1} :\n    a.untop\u2080 = 0 \u2194 a = 0 \u2228 a = \u22a4 := by simp [untop\u2080]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/WithTop/Untop0.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Zero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Zero \u03b1\na : WithTop \u03b1\n\u22a2 a.untop\u2080 = 0 \u2194 a = 0 \u2228 a = \u22a4"}, {"line": "simp [untop\u2080]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma untop\u2080_top : untop\u2080 \u22a4 = (0 : \u03b1) := by simp [untop\u2080]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/WithTop/Untop0.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Zero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Zero \u03b1\nx\u271d : Sort u_2\nuntop\u2080 : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [untop\u2080]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Zero \u03b1\nx\u271d : Sort u_2\nuntop\u2080 : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma untop\u2080_zero : untop\u2080 0 = (0 : \u03b1) := by simp [untop\u2080]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/WithTop/Untop0.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Zero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Zero \u03b1\nx\u271d : Sort u_2\nuntop\u2080 : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [untop\u2080]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Zero \u03b1\nx\u271d : Sort u_2\nuntop\u2080 : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma untopD_add [Add \u03b1] {a b : WithTop \u03b1} {c : \u03b1} (ha : a \u2260 \u22a4) (hb : b \u2260 \u22a4) :\n    (a + b).untopD c = a.untopD c + b.untopD c := by\n  lift a to \u03b1 using ha\n  lift b to \u03b1 using hb\n  simp [\u2190 coe_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/WithTop/Untop0.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Zero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : Add \u03b1\na b : WithTop \u03b1\nc : \u03b1\nha : a \u2260 \u22a4\nhb : b \u2260 \u22a4\n\u22a2 WithTop.untopD c (a + b) = WithTop.untopD c a + WithTop.untopD c b"}, {"line": "lift a to \u03b1 using ha", "tactic_state": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : Add \u03b1\nb : WithTop \u03b1\nc : \u03b1\nhb : b \u2260 \u22a4\na : \u03b1\n\u22a2 WithTop.untopD c (\u2191a + b) = WithTop.untopD c \u2191a + WithTop.untopD c b"}, {"line": "lift b to \u03b1 using hb", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : Add \u03b1\nc a b : \u03b1\n\u22a2 WithTop.untopD c (\u2191a + \u2191b) = WithTop.untopD c \u2191a + WithTop.untopD c \u2191b"}, {"line": "simp [\u2190 coe_add]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma stabilizer_finite (hs\u2080 : s.Nonempty) (hs : s.Finite) : (stabilizer G s : Set G).Finite := by\n  obtain \u27e8a, ha\u27e9 := hs\u2080\n  exact (hs.div <| finite_singleton _).subset <| stabilizer_subset_div_right ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Pointwise/Stabilizer.lean", "context": {"open": ["Function MulOpposite Set", "scoped Pointwise", "scoped RightActions in"], "variables": ["{G H \u03b1 : Type*}", "[Group G] [Group H] [MulAction G \u03b1] {a : G} {s t : Set \u03b1}", "{s : Set G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d : Group G\ns : Set G\nx\u271d : Sort u_1\nstabilizer : x\u271d\nhs\u2080 : s.Nonempty\nhs : s.Finite\n\u22a2 sorry.Finite"}, {"line": "obtain \u27e8a, ha\u27e9 := hs\u2080", "tactic_state": "case intro\nG : Type u_2\ninst\u271d : Group G\ns : Set G\nx\u271d : Sort u_1\nstabilizer : x\u271d\nhs : s.Finite\na : G\nha : a \u2208 s\n\u22a2 sorry.Finite"}, {"line": "exact (hs.div <| finite_singleton _).subset <| stabilizer_subset_div_right ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_set_stabilizer_subset (ha : a \u2208 s) : a \u2022 (stabilizer G s : Set G) \u2286 s := by\n  simpa using op_smul_set_stabilizer_subset ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Pointwise/Stabilizer.lean", "context": {"open": ["Function MulOpposite Set", "scoped Pointwise", "scoped RightActions in"], "variables": ["{G H \u03b1 : Type*}", "[Group G] [Group H] [MulAction G \u03b1] {a : G} {s t : Set \u03b1}", "{s : Set G}", "[CommGroup G] {s t : Set G} {a : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : CommGroup G\ns : Set G\na : G\nx\u271d : Sort u_1\nstabilizer : x\u271d\nha : a \u2208 s\n\u22a2 a \u2022 sorry \u2286 s"}, {"line": "simpa using op_smul_set_stabilizer_subset ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_list_sum_le (l : List S[X]) :\n    natDegree l.sum \u2264 (l.map natDegree).foldr max 0 := by\n  apply List.sum_le_foldr_max natDegree\n  \u00b7 simp\n  \u00b7 exact natDegree_add_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/BigOperators.lean", "context": {"open": ["Finset", "Multiset", "Polynomial"], "variables": ["{R : Type u} {\u03b9 : Type w}", "(s : Finset \u03b9)", "{S : Type*} [Semiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\nl : List (Polynomial S)\n\u22a2 l.sum.natDegree \u2264 List.foldr max 0 (List.map natDegree l)"}, {"line": "apply List.sum_le_foldr_max natDegree", "tactic_state": "case h0\nS : Type u_1\ninst\u271d : Semiring S\nl : List (Polynomial S)\n\u22a2 natDegree 0 \u2264 0\n---\ncase hadd\nS : Type u_1\ninst\u271d : Semiring S\nl : List (Polynomial S)\n\u22a2 \u2200 (x y : Polynomial S), (x + y).natDegree \u2264 max x.natDegree y.natDegree"}, {"line": "\u00b7 simp", "tactic_state": "case hadd\nS : Type u_1\ninst\u271d : Semiring S\nl : List (Polynomial S)\n\u22a2 \u2200 (x y : Polynomial S), (x + y).natDegree \u2264 max x.natDegree y.natDegree"}, {"line": "\u00b7 exact natDegree_add_le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_sum_le (f : \u03b9 \u2192 S[X]) :\n    natDegree (\u2211 i \u2208 s, f i) \u2264 s.fold max 0 (natDegree \u2218 f) := by\n  simpa using natDegree_multiset_sum_le (s.val.map f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/BigOperators.lean", "context": {"open": ["Finset", "Multiset", "Polynomial"], "variables": ["{R : Type u} {\u03b9 : Type w}", "(s : Finset \u03b9)", "{S : Type*} [Semiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type w\ns : Finset \u03b9\nS : Type u_1\ninst\u271d : Semiring S\nf : \u03b9 \u2192 Polynomial S\n\u22a2 (\u2211 i \u2208 s, f i).natDegree \u2264 Finset.fold max 0 (natDegree \u2218 f) s"}, {"line": "simpa using natDegree_multiset_sum_le (s.val.map f)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_list_prod_le (l : List S[X]) : natDegree l.prod \u2264 (l.map natDegree).sum := by\n  induction' l with hd tl IH\n  \u00b7 simp\n  \u00b7 simpa using natDegree_mul_le.trans (add_le_add_left IH _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/BigOperators.lean", "context": {"open": ["Finset", "Multiset", "Polynomial"], "variables": ["{R : Type u} {\u03b9 : Type w}", "(s : Finset \u03b9)", "{S : Type*} [Semiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\nl : List (Polynomial S)\n\u22a2 l.prod.natDegree \u2264 (List.map natDegree l).sum"}, {"line": "induction' l with hd tl IH", "tactic_state": "case nil\nS : Type u_1\ninst\u271d : Semiring S\n\u22a2 [].prod.natDegree \u2264 (List.map natDegree []).sum\n---\ncase cons\nS : Type u_1\ninst\u271d : Semiring S\nhd : Polynomial S\ntl : List (Polynomial S)\nIH : tl.prod.natDegree \u2264 (List.map natDegree tl).sum\n\u22a2 (hd :: tl).prod.natDegree \u2264 (List.map natDegree (hd :: tl)).sum"}, {"line": "\u00b7 simp", "tactic_state": "case cons\nS : Type u_1\ninst\u271d : Semiring S\nhd : Polynomial S\ntl : List (Polynomial S)\nIH : tl.prod.natDegree \u2264 (List.map natDegree tl).sum\n\u22a2 (hd :: tl).prod.natDegree \u2264 (List.map natDegree (hd :: tl)).sum"}, {"line": "\u00b7 simpa using natDegree_mul_le.trans (add_le_add_left IH _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem degree_list_prod_le (l : List S[X]) : degree l.prod \u2264 (l.map degree).sum := by\n  induction' l with hd tl IH\n  \u00b7 simp\n  \u00b7 simpa using (degree_mul_le _ _).trans (add_le_add_left IH _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/BigOperators.lean", "context": {"open": ["Finset", "Multiset", "Polynomial"], "variables": ["{R : Type u} {\u03b9 : Type w}", "(s : Finset \u03b9)", "{S : Type*} [Semiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\nl : List (Polynomial S)\n\u22a2 l.prod.degree \u2264 (List.map degree l).sum"}, {"line": "induction' l with hd tl IH", "tactic_state": "case nil\nS : Type u_1\ninst\u271d : Semiring S\n\u22a2 [].prod.degree \u2264 (List.map degree []).sum\n---\ncase cons\nS : Type u_1\ninst\u271d : Semiring S\nhd : Polynomial S\ntl : List (Polynomial S)\nIH : tl.prod.degree \u2264 (List.map degree tl).sum\n\u22a2 (hd :: tl).prod.degree \u2264 (List.map degree (hd :: tl)).sum"}, {"line": "\u00b7 simp", "tactic_state": "case cons\nS : Type u_1\ninst\u271d : Semiring S\nhd : Polynomial S\ntl : List (Polynomial S)\nIH : tl.prod.degree \u2264 (List.map degree tl).sum\n\u22a2 (hd :: tl).prod.degree \u2264 (List.map degree (hd :: tl)).sum"}, {"line": "\u00b7 simpa using (degree_mul_le _ _).trans (add_le_add_left IH _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_prod_le : (\u220f i \u2208 s, f i).natDegree \u2264 \u2211 i \u2208 s, (f i).natDegree := by\n  simpa using natDegree_multiset_prod_le (s.1.map f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/BigOperators.lean", "context": {"open": ["Finset", "Multiset", "Polynomial"], "variables": ["{R : Type u} {\u03b9 : Type w}", "(s : Finset \u03b9)", "{S : Type*} [Semiring S]", "[CommSemiring R] (f : \u03b9 \u2192 R[X]) (t : Multiset R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03b9 : Type w\ns : Finset \u03b9\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 Polynomial R\n\u22a2 (\u220f i \u2208 s, f i).natDegree \u2264 \u2211 i \u2208 s, (f i).natDegree"}, {"line": "simpa using natDegree_multiset_prod_le (s.1.map f)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem degree_prod_le : (\u220f i \u2208 s, f i).degree \u2264 \u2211 i \u2208 s, (f i).degree := by\n  simpa only [Multiset.map_map] using degree_multiset_prod_le (s.1.map f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/BigOperators.lean", "context": {"open": ["Finset", "Multiset", "Polynomial"], "variables": ["{R : Type u} {\u03b9 : Type w}", "(s : Finset \u03b9)", "{S : Type*} [Semiring S]", "[CommSemiring R] (f : \u03b9 \u2192 R[X]) (t : Multiset R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03b9 : Type w\ns : Finset \u03b9\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 Polynomial R\n\u22a2 (\u220f i \u2208 s, f i).degree \u2264 \u2211 i \u2208 s, (f i).degree"}, {"line": "simpa only [Multiset.map_map] using degree_multiset_prod_le (s.1.map f)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leadingCoeff_prod' (h : (\u220f i \u2208 s, (f i).leadingCoeff) \u2260 0) :\n    (\u220f i \u2208 s, f i).leadingCoeff = \u220f i \u2208 s, (f i).leadingCoeff := by\n  simpa using leadingCoeff_multiset_prod' (s.1.map f) (by simpa using h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/BigOperators.lean", "context": {"open": ["Finset", "Multiset", "Polynomial"], "variables": ["{R : Type u} {\u03b9 : Type w}", "(s : Finset \u03b9)", "{S : Type*} [Semiring S]", "[CommSemiring R] (f : \u03b9 \u2192 R[X]) (t : Multiset R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03b9 : Type w\ns : Finset \u03b9\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 Polynomial R\nh : \u220f i \u2208 s, (f i).leadingCoeff \u2260 0\n\u22a2 (\u220f i \u2208 s, f i).leadingCoeff = \u220f i \u2208 s, (f i).leadingCoeff"}, {"line": "simpa using leadingCoeff_multiset_prod' (s.1.map f) (by simpa using h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_prod' (h : (\u220f i \u2208 s, (f i).leadingCoeff) \u2260 0) :\n    (\u220f i \u2208 s, f i).natDegree = \u2211 i \u2208 s, (f i).natDegree := by\n  simpa using natDegree_multiset_prod' (s.1.map f) (by simpa using h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/BigOperators.lean", "context": {"open": ["Finset", "Multiset", "Polynomial"], "variables": ["{R : Type u} {\u03b9 : Type w}", "(s : Finset \u03b9)", "{S : Type*} [Semiring S]", "[CommSemiring R] (f : \u03b9 \u2192 R[X]) (t : Multiset R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03b9 : Type w\ns : Finset \u03b9\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 Polynomial R\nh : \u220f i \u2208 s, (f i).leadingCoeff \u2260 0\n\u22a2 (\u220f i \u2208 s, f i).natDegree = \u2211 i \u2208 s, (f i).natDegree"}, {"line": "simpa using natDegree_multiset_prod' (s.1.map f) (by simpa using h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_prod_of_monic (h : \u2200 i \u2208 s, (f i).Monic) :\n    (\u220f i \u2208 s, f i).natDegree = \u2211 i \u2208 s, (f i).natDegree := by\n  simpa using natDegree_multiset_prod_of_monic (s.1.map f) (by simpa using h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/BigOperators.lean", "context": {"open": ["Finset", "Multiset", "Polynomial"], "variables": ["{R : Type u} {\u03b9 : Type w}", "(s : Finset \u03b9)", "{S : Type*} [Semiring S]", "[CommSemiring R] (f : \u03b9 \u2192 R[X]) (t : Multiset R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03b9 : Type w\ns : Finset \u03b9\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 Polynomial R\nh : \u2200 i \u2208 s, (f i).Monic\n\u22a2 (\u220f i \u2208 s, f i).natDegree = \u2211 i \u2208 s, (f i).natDegree"}, {"line": "simpa using natDegree_multiset_prod_of_monic (s.1.map f) (by simpa using h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem degree_prod_of_monic [Nontrivial R] (h : \u2200 i \u2208 s, (f i).Monic) :\n    (\u220f i \u2208 s, f i).degree = \u2211 i \u2208 s, (f i).degree := by\n  simpa using degree_multiset_prod_of_monic (s.1.map f) (by simpa using h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/BigOperators.lean", "context": {"open": ["Finset", "Multiset", "Polynomial"], "variables": ["{R : Type u} {\u03b9 : Type w}", "(s : Finset \u03b9)", "{S : Type*} [Semiring S]", "[CommSemiring R] (f : \u03b9 \u2192 R[X]) (t : Multiset R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03b9 : Type w\ns : Finset \u03b9\ninst\u271d\u00b9 : CommSemiring R\nf : \u03b9 \u2192 Polynomial R\ninst\u271d : Nontrivial R\nh : \u2200 i \u2208 s, (f i).Monic\n\u22a2 (\u220f i \u2208 s, f i).degree = \u2211 i \u2208 s, (f i).degree"}, {"line": "simpa using degree_multiset_prod_of_monic (s.1.map f) (by simpa using h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_multiset_prod_of_natDegree_le (n : \u2115) (hl : \u2200 p \u2208 t, natDegree p \u2264 n) :\n    coeff t.prod ((Multiset.card t) * n) = (t.map fun p => coeff p n).prod := by\n  induction t using Quotient.inductionOn\n  simpa using coeff_list_prod_of_natDegree_le _ _ hl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/BigOperators.lean", "context": {"open": ["Finset", "Multiset", "Polynomial"], "variables": ["{R : Type u} {\u03b9 : Type w}", "(s : Finset \u03b9)", "{S : Type*} [Semiring S]", "[CommSemiring R] (f : \u03b9 \u2192 R[X]) (t : Multiset R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nt : Multiset (Polynomial R)\nn : \u2115\nhl : \u2200 p \u2208 t, p.natDegree \u2264 n\n\u22a2 t.prod.coeff (t.card * n) = (Multiset.map (fun p => p.coeff n) t).prod"}, {"line": "induction t using Quotient.inductionOn", "tactic_state": "case h\nR : Type u\ninst\u271d : CommSemiring R\nt : Multiset (Polynomial R)\nn : \u2115\na\u271d : List (Polynomial R)\nhl : \u2200 p \u2208 \u27e6a\u271d\u27e7, p.natDegree \u2264 n\n\u22a2 (prod \u27e6a\u271d\u27e7).coeff (Multiset.card \u27e6a\u271d\u27e7 * n) = (Multiset.map (fun p => p.coeff n) \u27e6a\u271d\u27e7).prod"}, {"line": "simpa using coeff_list_prod_of_natDegree_le _ _ hl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_prod_of_natDegree_le (f : \u03b9 \u2192 R[X]) (n : \u2115) (h : \u2200 p \u2208 s, natDegree (f p) \u2264 n) :\n    coeff (\u220f i \u2208 s, f i) (#s * n) = \u220f i \u2208 s, coeff (f i) n := by\n  obtain \u27e8l, hl\u27e9 := s\n  convert coeff_multiset_prod_of_natDegree_le (l.map f) n ?_\n  \u00b7 simp\n  \u00b7 simp\n  \u00b7 simpa using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/BigOperators.lean", "context": {"open": ["Finset", "Multiset", "Polynomial"], "variables": ["{R : Type u} {\u03b9 : Type w}", "(s : Finset \u03b9)", "{S : Type*} [Semiring S]", "[CommSemiring R] (f : \u03b9 \u2192 R[X]) (t : Multiset R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03b9 : Type w\ns : Finset \u03b9\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 Polynomial R\nn : \u2115\nh : \u2200 p \u2208 s, (f p).natDegree \u2264 n\n\u22a2 (\u220f i \u2208 s, f i).coeff (s.card * n) = \u220f i \u2208 s, (f i).coeff n"}, {"line": "obtain \u27e8l, hl\u27e9 := s", "tactic_state": "case mk\nR : Type u\n\u03b9 : Type w\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 Polynomial R\nn : \u2115\nl : Multiset \u03b9\nhl : l.Nodup\nh : \u2200 p \u2208 { val := l, nodup := hl }, (f p).natDegree \u2264 n\n\u22a2 (\u220f i \u2208 { val := l, nodup := hl }, f i).coeff ({ val := l, nodup := hl }.card * n) =\n    \u220f i \u2208 { val := l, nodup := hl }, (f i).coeff n"}, {"line": "convert coeff_multiset_prod_of_natDegree_le (l.map f) n ?_", "tactic_state": "case h.e'_2.h.e'_4.h.e'_5\nR : Type u\n\u03b9 : Type w\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 Polynomial R\nn : \u2115\nl : Multiset \u03b9\nhl : l.Nodup\nh : \u2200 p \u2208 { val := l, nodup := hl }, (f p).natDegree \u2264 n\n\u22a2 { val := l, nodup := hl }.card = (Multiset.map f l).card\n---\ncase h.e'_3\nR : Type u\n\u03b9 : Type w\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 Polynomial R\nn : \u2115\nl : Multiset \u03b9\nhl : l.Nodup\nh : \u2200 p \u2208 { val := l, nodup := hl }, (f p).natDegree \u2264 n\n\u22a2 \u220f i \u2208 { val := l, nodup := hl }, (f i).coeff n = (Multiset.map (fun p => p.coeff n) (Multiset.map f l)).prod\n---\ncase mk\nR : Type u\n\u03b9 : Type w\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 Polynomial R\nn : \u2115\nl : Multiset \u03b9\nhl : l.Nodup\nh : \u2200 p \u2208 { val := l, nodup := hl }, (f p).natDegree \u2264 n\n\u22a2 \u2200 p \u2208 Multiset.map f l, p.natDegree \u2264 n"}, {"line": "\u00b7 simp", "tactic_state": "case h.e'_3\nR : Type u\n\u03b9 : Type w\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 Polynomial R\nn : \u2115\nl : Multiset \u03b9\nhl : l.Nodup\nh : \u2200 p \u2208 { val := l, nodup := hl }, (f p).natDegree \u2264 n\n\u22a2 \u220f i \u2208 { val := l, nodup := hl }, (f i).coeff n = (Multiset.map (fun p => p.coeff n) (Multiset.map f l)).prod\n---\ncase mk\nR : Type u\n\u03b9 : Type w\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 Polynomial R\nn : \u2115\nl : Multiset \u03b9\nhl : l.Nodup\nh : \u2200 p \u2208 { val := l, nodup := hl }, (f p).natDegree \u2264 n\n\u22a2 \u2200 p \u2208 Multiset.map f l, p.natDegree \u2264 n"}, {"line": "\u00b7 simp", "tactic_state": "case mk\nR : Type u\n\u03b9 : Type w\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 Polynomial R\nn : \u2115\nl : Multiset \u03b9\nhl : l.Nodup\nh : \u2200 p \u2208 { val := l, nodup := hl }, (f p).natDegree \u2264 n\n\u22a2 \u2200 p \u2208 Multiset.map f l, p.natDegree \u2264 n"}, {"line": "\u00b7 simpa using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_zero_prod : (\u220f i \u2208 s, f i).coeff 0 = \u220f i \u2208 s, (f i).coeff 0 := by\n  simpa using coeff_zero_multiset_prod (s.1.map f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/BigOperators.lean", "context": {"open": ["Finset", "Multiset", "Polynomial"], "variables": ["{R : Type u} {\u03b9 : Type w}", "(s : Finset \u03b9)", "{S : Type*} [Semiring S]", "[CommSemiring R] (f : \u03b9 \u2192 R[X]) (t : Multiset R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03b9 : Type w\ns : Finset \u03b9\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 Polynomial R\n\u22a2 (\u220f i \u2208 s, f i).coeff 0 = \u220f i \u2208 s, (f i).coeff 0"}, {"line": "simpa using coeff_zero_multiset_prod (s.1.map f)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_X_sub_C_coeff_card_pred (s : Finset \u03b9) (f : \u03b9 \u2192 R) (hs : 0 < #s) :\n    (\u220f i \u2208 s, (X - C (f i))).coeff (#s - 1) = -\u2211 i \u2208 s, f i := by\n  simpa using multiset_prod_X_sub_C_coeff_card_pred (s.1.map f) (by simpa using hs)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/BigOperators.lean", "context": {"open": ["Finset", "Multiset", "Polynomial", "Monic"], "variables": ["{R : Type u} {\u03b9 : Type w}", "(s : Finset \u03b9)", "{S : Type*} [Semiring S]", "[CommSemiring R] (f : \u03b9 \u2192 R[X]) (t : Multiset R[X])", "[CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03b9 : Type w\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommRing R\ns : Finset \u03b9\nf : \u03b9 \u2192 R\nhs : 0 < s.card\n\u22a2 sorry = -\u2211 i \u2208 s, f i"}, {"line": "simpa using multiset_prod_X_sub_C_coeff_card_pred (s.1.map f) (by simpa using hs)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma evalEval_list_prod (x y : R) (l : List R[X][Y]) :\n    l.prod.evalEval x y = (l.map <| evalEval x y).prod := by\n  simpa only [evalEval, eval_list_prod, List.map_map] using by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Bivariate.lean", "context": {"open": ["scoped Polynomial.Bivariate"], "variables": ["{R S : Type*}", "[Semiring R]", "[Ring R]", "[CommSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : CommSemiring R\nx\u271d : Sort u_3\nevalEval : x\u271d\nx y : R\nl : List (Polynomial (Polynomial R))\n\u22a2 Polynomial.evalEval x y l.prod = (List.map sorry l).prod"}, {"line": "simpa only [evalEval, eval_list_prod, List.map_map] using by rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardinalMk_le_max {R : Type u} [Semiring R] : #(R[X]) \u2264 max #R \u2135\u2080 := by\n  cases subsingleton_or_nontrivial R\n  \u00b7 exact (mk_eq_one _).trans_le (le_max_of_le_right one_le_aleph0)\n  \u00b7 exact cardinalMk_eq_max.le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Cardinal.lean", "context": {"open": ["Cardinal Polynomial", "Cardinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\n\u22a2 mk (Polynomial R) \u2264 max (mk R) aleph0"}, {"line": "cases subsingleton_or_nontrivial R", "tactic_state": "case inl\nR : Type u\ninst\u271d : Semiring R\nh\u271d : Subsingleton R\n\u22a2 mk (Polynomial R) \u2264 max (mk R) aleph0\n---\ncase inr\nR : Type u\ninst\u271d : Semiring R\nh\u271d : Nontrivial R\n\u22a2 mk (Polynomial R) \u2264 max (mk R) aleph0"}, {"line": "\u00b7 exact (mk_eq_one _).trans_le (le_max_of_le_right one_le_aleph0)", "tactic_state": "case inr\nR : Type u\ninst\u271d : Semiring R\nh\u271d : Nontrivial R\n\u22a2 mk (Polynomial R) \u2264 max (mk R) aleph0"}, {"line": "\u00b7 exact cardinalMk_eq_max.le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mkDerivation_X (a : A) : mkDerivation R a X = a := by simp [mkDerivation_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivation.lean", "context": {"open": [], "variables": ["{R A : Type*} [CommSemiring R]", "[AddCommMonoid A] [Module R A] [Module (Polynomial R) A]", "[IsScalarTower R (Polynomial R) A]", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\ninst\u271d : AddCommMonoid A\nx\u271d : Sort u_3\nmkDerivation : x\u271d\na : A\n\u22a2 sorry = a"}, {"line": "simp [mkDerivation_apply]", "tactic_state": "A : Type u_2\ninst\u271d : AddCommMonoid A\nx\u271d : Sort u_3\nmkDerivation : x\u271d\na : A\n\u22a2 sorry () = a"}]}
{"declaration": "theorem comp_aeval_eq (d : Derivation R A M) (f : R[X]) :\n    d (aeval a f) = aeval a (derivative f) \u2022 d a :=\n  calc\n    _ = (AEval.of R M a).symm (d.compAEval a f) := rfl\n    _ = _ := by simp [-compAEval_apply, compAEval_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivation.lean", "context": {"open": ["Polynomial Module"], "variables": ["{R A : Type*} [CommSemiring R]", "[AddCommMonoid A] [Module R A] [Module (Polynomial R) A]", "[IsScalarTower R (Polynomial R) A]", "(R)", "{R A M : Type*} [CommSemiring R] [CommSemiring A] [Algebra R A] [AddCommMonoid M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d : CommSemiring R\n\u03b1\u271d : Type u_6\na : \u03b1\u271d\nd : sorry\nf : Polynomial R\n\u22a2 sorry = ?m.14186"}, {"line": "simp [-compAEval_apply, compAEval_eq]", "tactic_state": "R : Type u_3\ninst\u271d : CommSemiring R\n\u03b1\u271d : Type u_6\na : \u03b1\u271d\nd : sorry\nf : Polynomial R\n\u22a2 sorry () = ?m.14186"}]}
{"declaration": "theorem smul_eval [MulSemiringAction G S] (g : G) (f : S[X]) (x : S) :\n    (g \u2022 f).eval x = g \u2022 f.eval (g\u207b\u00b9 \u2022 x) := by\n  rw [\u2190 smul_eval_smul]\n  rw [smul_inv_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/GroupRingAction.lean", "context": {"open": ["Polynomial"], "variables": ["(M : Type*) [Monoid M]", "(R : Type*) [Semiring R]", "{M} in", "{M R}", "[MulSemiringAction M R]", "(S : Type*) [CommSemiring S] [MulSemiringAction M S]", "(G : Type*) [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_3\ninst\u271d\u00b2 : CommSemiring S\nG : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : MulSemiringAction G S\ng : G\nf : Polynomial S\nx : S\n\u22a2 eval x (g \u2022 f) = g \u2022 eval (g\u207b\u00b9 \u2022 x) f"}, {"line": "rw [\u2190 smul_eval_smul]", "tactic_state": "S : Type u_3\ninst\u271d\u00b2 : CommSemiring S\nG : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : MulSemiringAction G S\ng : G\nf : Polynomial S\nx : S\n\u22a2 eval x (g \u2022 f) = eval (g \u2022 g\u207b\u00b9 \u2022 x) (g \u2022 f)"}, {"line": "rw [smul_inv_smul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prodXSubSMul.coeff (x : R) (g : G) (n : \u2115) :\n    g \u2022 (prodXSubSMul G R x).coeff n = (prodXSubSMul G R x).coeff n := by\n  rw [\u2190 Polynomial.coeff_smul]\n  rw [prodXSubSMul.smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/GroupRingAction.lean", "context": {"open": ["Polynomial", "MulAction"], "variables": ["(M : Type*) [Monoid M]", "(R : Type*) [Semiring R]", "{M} in", "{M R}", "[MulSemiringAction M R]", "(S : Type*) [CommSemiring S] [MulSemiringAction M S]", "(G : Type*) [Group G]", "(G : Type*) [Group G] [Fintype G]", "(R : Type*) [CommRing R] [MulSemiringAction G R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_5\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : Fintype G\nR : Type u_6\ninst\u271d\u00b9 : CommRing R\ninst\u271d : MulSemiringAction G R\nx : R\ng : G\nn : \u2115\n\u22a2 g \u2022 (prodXSubSMul G R x).coeff n = (prodXSubSMul G R x).coeff n"}, {"line": "rw [\u2190 Polynomial.coeff_smul]", "tactic_state": "G : Type u_5\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : Fintype G\nR : Type u_6\ninst\u271d\u00b9 : CommRing R\ninst\u271d : MulSemiringAction G R\nx : R\ng : G\nn : \u2115\n\u22a2 (g \u2022 prodXSubSMul G R x).coeff n = (prodXSubSMul G R x).coeff n"}, {"line": "rw [prodXSubSMul.smul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem divX_C_mul_X_pow : divX (C a * X ^ n) = if n = 0 then 0 else C a * X ^ (n - 1) := by\n  simp only [divX_C_mul]\n  simp only [divX_X_pow]\n  simp only [mul_ite]\n  simp only [mul_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Inductions.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\na : R\nn : \u2115\ninst\u271d : Semiring R\n\u22a2 (C a * X ^ n).divX = if n = 0 then 0 else C a * X ^ (n - 1)"}, {"line": "simp only [divX_C_mul]", "tactic_state": "R : Type u\na : R\nn : \u2115\ninst\u271d : Semiring R\n\u22a2 C a * (X ^ n).divX = if n = 0 then 0 else C a * X ^ (n - 1)"}, {"line": "simp only [divX_X_pow]", "tactic_state": "R : Type u\na : R\nn : \u2115\ninst\u271d : Semiring R\n\u22a2 (C a * if n = 0 then 0 else X ^ (n - 1)) = if n = 0 then 0 else C a * X ^ (n - 1)"}, {"line": "simp only [mul_ite]", "tactic_state": "R : Type u\na : R\nn : \u2115\ninst\u271d : Semiring R\n\u22a2 (if n = 0 then C a * 0 else C a * X ^ (n - 1)) = if n = 0 then 0 else C a * X ^ (n - 1)"}, {"line": "simp only [mul_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mirror_zero : (0 : R[X]).mirror = 0 := by simp [mirror]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Mirror.lean", "context": {"open": [], "variables": ["{R : Type*} [Semiring R] (p q : R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Type u_1\nR : x\u271d\u00b9\nx\u271d : Type u_2\nX : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [mirror]", "tactic_state": "x\u271d\u00b9 : Type u_1\nR : x\u271d\u00b9\nx\u271d : Type u_2\nX : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem mirror_natTrailingDegree : p.mirror.natTrailingDegree = p.natTrailingDegree := by\n  by_cases hp : p = 0\n  \u00b7 rw [hp, mirror_zero]\n  \u00b7 rw [mirror, natTrailingDegree_mul_X_pow ((mt reverse_eq_zero.mp) hp),\n      natTrailingDegree_reverse, zero_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Mirror.lean", "context": {"open": [], "variables": ["{R : Type*} [Semiring R] (p q : R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = sorry"}, {"line": "by_cases hp : p = 0", "tactic_state": "case pos\nhp : sorry = 0\n\u22a2 sorry = sorry\n---\ncase neg\nhp : \u00acsorry = 0\n\u22a2 sorry = sorry"}, {"line": "\u00b7 rw [hp, mirror_zero]", "tactic_state": "case neg\nhp : \u00acsorry = 0\n\u22a2 sorry = sorry"}, {"line": "\u00b7 rw [mirror, natTrailingDegree_mul_X_pow ((mt reverse_eq_zero.mp) hp),\n      natTrailingDegree_reverse, zero_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem degree_eq_degree_of_associated (h : Associated p q) : degree p = degree q := by\n  let \u27e8u, hu\u27e9 := h\n  simp [hu.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/RingDivision.lean", "context": {"open": ["Polynomial", "Finset", "scoped nonZeroDivisors"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {a b : R} {n : \u2115}", "[CommRing R] {p q : R[X]}", "[Semiring S]", "[Ring S]", "[Semiring R] [NoZeroDivisors R] {p q : R[X]}", "[CommRing R]", "[IsDomain R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : NoZeroDivisors R\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : Polynomial R\nh : Associated p q\n\u22a2 p.degree = q.degree"}, {"line": "let \u27e8u, hu\u27e9 := h", "tactic_state": "R : Type u\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : NoZeroDivisors R\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : Polynomial R\nh : Associated p q\nu : (Polynomial R)\u02e3\nhu : p * \u2191u = q\n\u22a2 p.degree = q.degree"}, {"line": "simp [hu.symm]", "tactic_state": "R : Type u\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : NoZeroDivisors R\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : Polynomial R\nh : Associated p q\nu : (Polynomial R)\u02e3\nhu : p * \u2191u = q\n\u22a2 p.degree = (p * \u2191u).degree"}]}
{"declaration": "theorem prime_X : Prime (X : R[X]) := by\n  convert prime_X_sub_C (0 : R)\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/RingDivision.lean", "context": {"open": ["Polynomial", "Finset", "scoped nonZeroDivisors"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {a b : R} {n : \u2115}", "[CommRing R] {p q : R[X]}", "[Semiring S]", "[Ring S]", "[Semiring R] [NoZeroDivisors R] {p q : R[X]}", "[CommRing R]", "[IsDomain R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry"}, {"line": "convert prime_X_sub_C (0 : R)", "tactic_state": "case a\n\u22a2 sorry \u2194 Prime (X - C 0)\n---\ncase convert_1\n\u22a2 CommRing sorry\n---\ncase convert_2\n\u22a2 IsDomain sorry\n---\ncase convert_3\n\u22a2 OfNat sorry 0"}, {"line": "simp", "tactic_state": "case a\n\u22a2 sorry () \u2194 Prime (X - C 0)\n---\ncase convert_1\n\u22a2 CommRing sorry\n---\ncase convert_2\n\u22a2 IsDomain sorry\n---\ncase convert_3\n\u22a2 OfNat sorry 0"}]}
{"declaration": "theorem Monic.prime_of_degree_eq_one (hp1 : degree p = 1) (hm : Monic p) : Prime p :=\n  have : p = X - C (-p.coeff 0) := by simpa [hm.leadingCoeff] using eq_X_add_C_of_degree_eq_one hp1\n  this.symm \u25b8 prime_X_sub_C _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/RingDivision.lean", "context": {"open": ["Polynomial", "Finset", "scoped nonZeroDivisors"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {a b : R} {n : \u2115}", "[CommRing R] {p q : R[X]}", "[Semiring S]", "[Ring S]", "[Semiring R] [NoZeroDivisors R] {p q : R[X]}", "[CommRing R]", "[IsDomain R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : NoZeroDivisors R\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np : Polynomial R\nhp1 : p.degree = 1\nhm : p.Monic\n\u22a2 p = X - C (-p.coeff 0)"}, {"line": "simpa [hm.leadingCoeff] using eq_X_add_C_of_degree_eq_one hp1\n  this.symm \u25b8 prime_X_sub_C _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_support_eq_three (hp : p.IsUnitTrinomial) : #p.support = 3 := by\n  obtain \u27e8k, m, n, hkm, hmn, u, v, w, rfl\u27e9 := hp\n  exact card_support_trinomial hkm hmn u.ne_zero v.ne_zero w.ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/UnitTrinomial.lean", "context": {"open": ["scoped Polynomial", "Finset"], "variables": ["{R : Type*} [Semiring R] (k m n : \u2115) (u v w : R)", "{k m n u v w}", "(p q : \u2124[X])", "{p q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Polynomial \u2124\nhp : p.IsUnitTrinomial\n\u22a2 p.support.card = 3"}, {"line": "obtain \u27e8k, m, n, hkm, hmn, u, v, w, rfl\u27e9 := hp", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro\nk m n : \u2115\nhkm : k < m\nhmn : m < n\nu v w : \u2124\u02e3\n\u22a2 (Polynomial.trinomial k m n \u2191u \u2191v \u2191w).support.card = 3"}, {"line": "exact card_support_trinomial hkm hmn u.ne_zero v.ne_zero w.ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ne_zero (hp : p.IsUnitTrinomial) : p \u2260 0 := by\n  rintro rfl\n  simpa using hp.card_support_eq_three\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/UnitTrinomial.lean", "context": {"open": ["scoped Polynomial", "Finset"], "variables": ["{R : Type*} [Semiring R] (k m n : \u2115) (u v w : R)", "{k m n u v w}", "(p q : \u2124[X])", "{p q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Polynomial \u2124\nhp : p.IsUnitTrinomial\n\u22a2 p \u2260 0"}, {"line": "rintro rfl", "tactic_state": "hp : Polynomial.IsUnitTrinomial 0\n\u22a2 False"}, {"line": "simpa using hp.card_support_eq_three", "tactic_state": "No Goals!"}]}
{"declaration": "theorem algEquivAevalXAddC_eq_iff {R : Type*} [CommRing R] (t t' : R) :\n    algEquivAevalXAddC t = algEquivAevalXAddC t' \u2194 t = t' := by\n  simp [algEquivAevalXAddC]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/AlgebraMap.lean", "context": {"open": ["Finset", "Polynomial", "AddMonoidAlgebra in"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {A : Type z} {A' B : Type*} {a b : R} {n : \u2115}", "[CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B]", "{p q r : R[X]}", "(R) in", "[CommSemiring R] [Semiring A] [CommSemiring A'] [Semiring B]", "[Algebra R A] [Algebra R B]", "{p q : R[X]} (x : A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nt t' : R\n\u22a2 algEquivAevalXAddC t = algEquivAevalXAddC t' \u2194 t = t'"}, {"line": "simp [algEquivAevalXAddC]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem algEquivAevalXAddC_symm {R : Type*} [CommRing R] (t : R) :\n    (algEquivAevalXAddC t).symm = algEquivAevalXAddC (-t) := by\n  simp [algEquivAevalXAddC, sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/AlgebraMap.lean", "context": {"open": ["Finset", "Polynomial", "AddMonoidAlgebra in"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {A : Type z} {A' B : Type*} {a b : R} {n : \u2115}", "[CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B]", "{p q r : R[X]}", "(R) in", "[CommSemiring R] [Semiring A] [CommSemiring A'] [Semiring B]", "[Algebra R A] [Algebra R B]", "{p q : R[X]} (x : A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nt : R\n\u22a2 (algEquivAevalXAddC t).symm = algEquivAevalXAddC (-t)"}, {"line": "simp [algEquivAevalXAddC, sub_eq_add_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_neg_X_comp_neg_X {R : Type*} [CommRing R] (p : R[X]) :\n    (p.comp (-X)).comp (-X) = p := by\n  rw [comp_assoc]\n  simp only [neg_comp]\n  simp only [X_comp]\n  simp only [neg_neg]\n  simp only [comp_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/AlgebraMap.lean", "context": {"open": ["Finset", "Polynomial", "AddMonoidAlgebra in"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {A : Type z} {A' B : Type*} {a b : R} {n : \u2115}", "[CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B]", "{p q r : R[X]}", "(R) in", "[CommSemiring R] [Semiring A] [CommSemiring A'] [Semiring B]", "[Algebra R A] [Algebra R B]", "{p q : R[X]} (x : A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\np : Polynomial R\n\u22a2 (p.comp (-X)).comp (-X) = p"}, {"line": "rw [comp_assoc]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\np : Polynomial R\n\u22a2 p.comp ((-X).comp (-X)) = p"}, {"line": "simp only [neg_comp]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\np : Polynomial R\n\u22a2 p.comp (-X.comp (-X)) = p"}, {"line": "simp only [X_comp]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\np : Polynomial R\n\u22a2 p.comp (- -X) = p"}, {"line": "simp only [neg_neg]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\np : Polynomial R\n\u22a2 p.comp X = p"}, {"line": "simp only [comp_X]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_unique (\u03c6 : R[X] \u2192\u2090[R] A) (p) : \u03c6 p = eval\u2082 (algebraMap R A) (\u03c6 X) p := by\n  rw [\u2190 aeval_def]\n  rw [aeval_algHom]\n  rw [aeval_X_left]\n  rw [AlgHom.comp_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/AlgebraMap.lean", "context": {"open": ["Finset", "Polynomial", "AddMonoidAlgebra in"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {A : Type z} {A' B : Type*} {a b : R} {n : \u2115}", "[CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B]", "{p q r : R[X]}", "(R) in", "[CommSemiring R] [Semiring A] [CommSemiring A'] [Semiring B]", "[Algebra R A] [Algebra R B]", "{p q : R[X]} (x : A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Semiring A\ninst\u271d\u00b9 inst\u271d : Algebra R A\n\u03c6 : Polynomial R \u2192\u2090[R] A\np : Polynomial R\n\u22a2 \u03c6 p = eval\u2082 (algebraMap R A) (\u03c6 X) p"}, {"line": "rw [\u2190 aeval_def]", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Semiring A\ninst\u271d\u00b9 inst\u271d : Algebra R A\n\u03c6 : Polynomial R \u2192\u2090[R] A\np : Polynomial R\n\u22a2 \u03c6 p = (aeval (\u03c6 X)) p"}, {"line": "rw [aeval_algHom]", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Semiring A\ninst\u271d\u00b9 inst\u271d : Algebra R A\n\u03c6 : Polynomial R \u2192\u2090[R] A\np : Polynomial R\n\u22a2 \u03c6 p = (\u03c6.comp (aeval X)) p"}, {"line": "rw [aeval_X_left]", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Semiring A\ninst\u271d\u00b9 inst\u271d : Algebra R A\n\u03c6 : Polynomial R \u2192\u2090[R] A\np : Polynomial R\n\u22a2 \u03c6 p = (\u03c6.comp (AlgHom.id R (Polynomial R))) p"}, {"line": "rw [AlgHom.comp_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aeval_prod_apply (x : A \u00d7 B) (p : Polynomial R) :\n    p.aeval x = (p.aeval x.1, p.aeval x.2) := by simp [aeval_prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/AlgebraMap.lean", "context": {"open": ["Finset", "Polynomial", "AddMonoidAlgebra in"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {A : Type z} {A' B : Type*} {a b : R} {n : \u2115}", "[CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B]", "{p q r : R[X]}", "(R) in", "[CommSemiring R] [Semiring A] [CommSemiring A'] [Semiring B]", "[Algebra R A] [Algebra R B]", "{p q : R[X]} (x : A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nA : Type u_1\nB : Type u_2\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Semiring B\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra R B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx : A \u00d7 B\np : Polynomial R\n\u22a2 (aeval x) p = ((aeval x.1) p, (aeval x.2) p)"}, {"line": "simp [aeval_prod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_zero_eq_aeval_zero (p : R[X]) : p.coeff 0 = aeval 0 p := by\n  simp [coeff_zero_eq_eval_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/AlgebraMap.lean", "context": {"open": ["Finset", "Polynomial", "AddMonoidAlgebra in"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {A : Type z} {A' B : Type*} {a b : R} {n : \u2115}", "[CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B]", "{p q r : R[X]}", "(R) in", "[CommSemiring R] [Semiring A] [CommSemiring A'] [Semiring B]", "[Algebra R A] [Algebra R B]", "{p q : R[X]} (x : A)", "{I : Type*} {A : I \u2192 Type*} [\u2200 i, Semiring (A i)] [\u2200 i, Algebra R (A i)]", "(x : \u03a0 i, A i) (p : R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d : CommSemiring R\np : Polynomial R\n\u22a2 p.coeff 0 = (aeval 0) p"}, {"line": "simp [coeff_zero_eq_eval_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aeval_eq_zero_of_dvd_aeval_eq_zero [CommSemiring S] [CommSemiring T] [Algebra S T]\n    {p q : S[X]} (h\u2081 : p \u2223 q) {a : T} (h\u2082 : aeval a p = 0) : aeval a q = 0 := by\n  rw [aeval_def] at h\u2082 \u22a2\n  rw [\u2190 eval_map] at h\u2082 \u22a2\n  exact eval_eq_zero_of_dvd_of_eval_eq_zero (Polynomial.map_dvd (algebraMap S T) h\u2081) h\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/AlgebraMap.lean", "context": {"open": ["Finset", "Polynomial", "AddMonoidAlgebra in"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {A : Type z} {A' B : Type*} {a b : R} {n : \u2115}", "[CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B]", "{p q r : R[X]}", "(R) in", "[CommSemiring R] [Semiring A] [CommSemiring A'] [Semiring B]", "[Algebra R A] [Algebra R B]", "{p q : R[X]} (x : A)", "{I : Type*} {A : I \u2192 Type*} [\u2200 i, Semiring (A i)] [\u2200 i, Algebra R (A i)]", "(x : \u03a0 i, A i) (p : R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_3\nT : Type u_4\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : CommSemiring T\ninst\u271d : Algebra S T\np q : Polynomial S\nh\u2081 : p \u2223 q\na : T\nh\u2082 : (aeval a) p = 0\n\u22a2 (aeval a) q = 0"}, {"line": "rw [aeval_def] at h\u2082 \u22a2", "tactic_state": "S : Type u_3\nT : Type u_4\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : CommSemiring T\ninst\u271d : Algebra S T\np q : Polynomial S\nh\u2081 : p \u2223 q\na : T\nh\u2082 : eval\u2082 (algebraMap S T) a p = 0\n\u22a2 eval\u2082 (algebraMap S T) a q = 0"}, {"line": "rw [\u2190 eval_map] at h\u2082 \u22a2", "tactic_state": "S : Type u_3\nT : Type u_4\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : CommSemiring T\ninst\u271d : Algebra S T\np q : Polynomial S\nh\u2081 : p \u2223 q\na : T\nh\u2082 : eval a (Polynomial.map (algebraMap S T) p) = 0\n\u22a2 eval a (Polynomial.map (algebraMap S T) q) = 0"}, {"line": "exact eval_eq_zero_of_dvd_of_eval_eq_zero (Polynomial.map_dvd (algebraMap S T) h\u2081) h\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aeval_eq_sum_range [Algebra R S] {p : R[X]} (x : S) :\n    aeval x p = \u2211 i \u2208 Finset.range (p.natDegree + 1), p.coeff i \u2022 x ^ i := by\n  simp_rw [Algebra.smul_def]\n  exact eval\u2082_eq_sum_range (algebraMap R S) x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/AlgebraMap.lean", "context": {"open": ["Finset", "Polynomial", "AddMonoidAlgebra in"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {A : Type z} {A' B : Type*} {a b : R} {n : \u2115}", "[CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B]", "{p q r : R[X]}", "(R) in", "[CommSemiring R] [Semiring A] [CommSemiring A'] [Semiring B]", "[Algebra R A] [Algebra R B]", "{p q : R[X]} (x : A)", "{I : Type*} {A : I \u2192 Type*} [\u2200 i, Semiring (A i)] [\u2200 i, Algebra R (A i)]", "(x : \u03a0 i, A i) (p : R[X])", "[Semiring S] {f : R \u2192+* S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nS : Type u_4\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Algebra R S\np : Polynomial R\nx : S\n\u22a2 (aeval x) p = \u2211 i \u2208 range (p.natDegree + 1), p.coeff i \u2022 x ^ i"}, {"line": "simp_rw [Algebra.smul_def]", "tactic_state": "R : Type u_3\nS : Type u_4\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Algebra R S\np : Polynomial R\nx : S\n\u22a2 (aeval x) p = \u2211 x_1 \u2208 range (p.natDegree + 1), (algebraMap R S) (p.coeff x_1) * x ^ x_1"}, {"line": "exact eval\u2082_eq_sum_range (algebraMap R S) x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aeval_eq_sum_range' [Algebra R S] {p : R[X]} {n : \u2115} (hn : p.natDegree < n) (x : S) :\n    aeval x p = \u2211 i \u2208 Finset.range n, p.coeff i \u2022 x ^ i := by\n  simp_rw [Algebra.smul_def]\n  exact eval\u2082_eq_sum_range' (algebraMap R S) hn x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/AlgebraMap.lean", "context": {"open": ["Finset", "Polynomial", "AddMonoidAlgebra in"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {A : Type z} {A' B : Type*} {a b : R} {n : \u2115}", "[CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B]", "{p q r : R[X]}", "(R) in", "[CommSemiring R] [Semiring A] [CommSemiring A'] [Semiring B]", "[Algebra R A] [Algebra R B]", "{p q : R[X]} (x : A)", "{I : Type*} {A : I \u2192 Type*} [\u2200 i, Semiring (A i)] [\u2200 i, Algebra R (A i)]", "(x : \u03a0 i, A i) (p : R[X])", "[Semiring S] {f : R \u2192+* S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nS : Type u_4\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Algebra R S\np : Polynomial R\nn : \u2115\nhn : p.natDegree < n\nx : S\n\u22a2 (aeval x) p = \u2211 i \u2208 range n, p.coeff i \u2022 x ^ i"}, {"line": "simp_rw [Algebra.smul_def]", "tactic_state": "R : Type u_3\nS : Type u_4\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Algebra R S\np : Polynomial R\nn : \u2115\nhn : p.natDegree < n\nx : S\n\u22a2 (aeval x) p = \u2211 x_1 \u2208 range n, (algebraMap R S) (p.coeff x_1) * x ^ x_1"}, {"line": "exact eval\u2082_eq_sum_range' (algebraMap R S) hn x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isRoot_of_eval\u2082_map_eq_zero (hf : Function.Injective f) {r : R} :\n    eval\u2082 f (f r) p = 0 \u2192 p.IsRoot r := by\n  intro h\n  apply hf\n  rw [\u2190 eval\u2082_hom]\n  rw [h]\n  rw [f.map_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/AlgebraMap.lean", "context": {"open": ["Finset", "Polynomial", "AddMonoidAlgebra in"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {A : Type z} {A' B : Type*} {a b : R} {n : \u2115}", "[CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B]", "{p q r : R[X]}", "(R) in", "[CommSemiring R] [Semiring A] [CommSemiring A'] [Semiring B]", "[Algebra R A] [Algebra R B]", "{p q : R[X]} (x : A)", "{I : Type*} {A : I \u2192 Type*} [\u2200 i, Semiring (A i)] [\u2200 i, Algebra R (A i)]", "(x : \u03a0 i, A i) (p : R[X])", "[Semiring S] {f : R \u2192+* S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : CommSemiring R\np : Polynomial R\ninst\u271d : Semiring S\nf : R \u2192+* S\nhf : Function.Injective \u21d1f\nr : R\n\u22a2 eval\u2082 f (f r) p = 0 \u2192 p.IsRoot r"}, {"line": "intro h", "tactic_state": "R : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : CommSemiring R\np : Polynomial R\ninst\u271d : Semiring S\nf : R \u2192+* S\nhf : Function.Injective \u21d1f\nr : R\nh : eval\u2082 f (f r) p = 0\n\u22a2 p.IsRoot r"}, {"line": "apply hf", "tactic_state": "case a\nR : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : CommSemiring R\np : Polynomial R\ninst\u271d : Semiring S\nf : R \u2192+* S\nhf : Function.Injective \u21d1f\nr : R\nh : eval\u2082 f (f r) p = 0\n\u22a2 f (eval r p) = f 0"}, {"line": "rw [\u2190 eval\u2082_hom]", "tactic_state": "case a\nR : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : CommSemiring R\np : Polynomial R\ninst\u271d : Semiring S\nf : R \u2192+* S\nhf : Function.Injective \u21d1f\nr : R\nh : eval\u2082 f (f r) p = 0\n\u22a2 eval\u2082 f (f r) p = f 0"}, {"line": "rw [h]", "tactic_state": "case a\nR : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : CommSemiring R\np : Polynomial R\ninst\u271d : Semiring S\nf : R \u2192+* S\nhf : Function.Injective \u21d1f\nr : R\nh : eval\u2082 f (f r) p = 0\n\u22a2 0 = f 0"}, {"line": "rw [f.map_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_eq_empty : p.support = \u2205 \u2194 p = 0 := by\n  rcases p with \u27e8\u27e9\n  simp [support]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Basic.lean", "context": {"open": ["AddMonoidAlgebra Finset", "Finsupp hiding single", "Function hiding Commute"], "variables": ["{R : Type u} {a b : R} {m n : \u2115}", "[Semiring R] {p q : R[X]}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nR : Type u\ninst\u271d : Semiring R\np : AddMonoidAlgebra R X\n\u22a2 p.support = \u2205 \u2194 p = 0"}, {"line": "rcases p with \u27e8\u27e9", "tactic_state": "case mk\nX : Type u_1\nR : Type u\ninst\u271d : Semiring R\nsupport\u271d : Finset X\ntoFun\u271d : X \u2192 R\nmem_support_toFun\u271d : \u2200 (a : X), a \u2208 support\u271d \u2194 toFun\u271d a \u2260 0\n\u22a2 { support := support\u271d, toFun := toFun\u271d, mem_support_toFun := mem_support_toFun\u271d }.support = \u2205 \u2194\n    { support := support\u271d, toFun := toFun\u271d, mem_support_toFun := mem_support_toFun\u271d } = 0"}, {"line": "simp [support]", "tactic_state": "case mk\nX : Type u_1\nR : Type u\ninst\u271d : Semiring R\nsupport\u271d : Finset X\ntoFun\u271d : X \u2192 R\nmem_support_toFun\u271d : \u2200 (a : X), a \u2208 support\u271d \u2194 toFun\u271d a \u2260 0\n\u22a2 support\u271d = \u2205 \u2194 { support := support\u271d, toFun := toFun\u271d, mem_support_toFun := mem_support_toFun\u271d } = 0"}]}
{"declaration": "theorem card_support_eq_zero : #p.support = 0 \u2194 p = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Basic.lean", "context": {"open": ["AddMonoidAlgebra Finset", "Finsupp hiding single", "Function hiding Commute"], "variables": ["{R : Type u} {a b : R} {m n : \u2115}", "[Semiring R] {p q : R[X]}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nR : Type u\ninst\u271d : Semiring R\np : AddMonoidAlgebra R X\n\u22a2 p.support.card = 0 \u2194 p = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinsupp_monomial (n : \u2115) (r : R) : (monomial n r).toFinsupp = Finsupp.single n r := by\n  simp [monomial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Basic.lean", "context": {"open": ["AddMonoidAlgebra Finset", "Finsupp hiding single", "Function hiding Commute"], "variables": ["{R : Type u} {a b : R} {m n : \u2115}", "[Semiring R] {p q : R[X]}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nx\u271d : Sort u_1\nmonomial : x\u271d\nn : \u2115\nr : R\n\u22a2 sorry = fun\u2080 | n => r"}, {"line": "simp [monomial]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nx\u271d : Sort u_1\nmonomial : x\u271d\nn : \u2115\nr : R\n\u22a2 sorry () = fun\u2080 | n => r"}]}
{"declaration": "theorem ofFinsupp_single (n : \u2115) (r : R) : (\u27e8Finsupp.single n r\u27e9 : R[X]) = monomial n r := by\n  simp [monomial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Basic.lean", "context": {"open": ["AddMonoidAlgebra Finset", "Finsupp hiding single", "Function hiding Commute"], "variables": ["{R : Type u} {a b : R} {m n : \u2115}", "[Semiring R] {p q : R[X]}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\nR : Type u\ninst\u271d : Semiring R\nx\u271d : Sort u_1\nmonomial : x\u271d\nn : \u2115\nr : R\n\u22a2 sorry = sorry"}, {"line": "simp [monomial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem C_0 : C (0 : R) = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Basic.lean", "context": {"open": ["AddMonoidAlgebra Finset", "Finsupp hiding single", "Function hiding Commute"], "variables": ["{R : Type u} {a b : R} {m n : \u2115}", "[Semiring R] {p q : R[X]}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nC : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nC : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem X_ne_C [Nontrivial R] (a : R) : X \u2260 C a := by\n  intro he\n  simpa using monomial_eq_monomial_iff.1 he\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Basic.lean", "context": {"open": ["AddMonoidAlgebra Finset", "Finsupp hiding single", "Function hiding Commute"], "variables": ["{R : Type u} {a b : R} {m n : \u2115}", "[Semiring R] {p q : R[X]}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\nR : Type u\ninst\u271d\u00b9 : Semiring R\nx\u271d : Sort u_1\nC : x\u271d\ninst\u271d : Nontrivial R\na : R\n\u22a2 X \u2260 sorry"}, {"line": "intro he", "tactic_state": "X : Type u_2\nR : Type u\ninst\u271d\u00b9 : Semiring R\nx\u271d : Sort u_1\nC : x\u271d\ninst\u271d : Nontrivial R\na : R\nhe : X = sorry\n\u22a2 False"}, {"line": "simpa using monomial_eq_monomial_iff.1 he", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_monomial : coeff (monomial n a) m = if n = m then a else 0 := by\n  simp [coeff, Finsupp.single_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Basic.lean", "context": {"open": ["AddMonoidAlgebra Finset", "Finsupp hiding single", "Function hiding Commute"], "variables": ["{R : Type u} {a b : R} {m n : \u2115}", "[Semiring R] {p q : R[X]}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\na : R\nm n : \u2115\ninst\u271d : Semiring R\nx\u271d : Sort u_1\ncoeff : x\u271d\n\u22a2 sorry = if n = m then a else 0"}, {"line": "simp [coeff, Finsupp.single_apply]", "tactic_state": "R : Type u\na : R\nm n : \u2115\ninst\u271d : Semiring R\nx\u271d : Sort u_1\ncoeff : x\u271d\n\u22a2 sorry () = if n = m then a else 0"}]}
{"declaration": "theorem coeff_one {n : \u2115} : coeff (1 : R[X]) n = if n = 0 then 1 else 0 := by\n  simp_rw [eq_comm (a := n) (b := 0)]\n  exact coeff_monomial\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Basic.lean", "context": {"open": ["AddMonoidAlgebra Finset", "Finsupp hiding single", "Function hiding Commute"], "variables": ["{R : Type u} {a b : R} {m n : \u2115}", "[Semiring R] {p q : R[X]}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncoeff : x\u271d\nn : \u2115\n\u22a2 sorry = if n = 0 then 1 else 0"}, {"line": "simp_rw [eq_comm (a := n) (b := 0)]", "tactic_state": "x\u271d : Sort u_1\ncoeff : x\u271d\nn : \u2115\n\u22a2 sorry = if 0 = n then 1 else 0"}, {"line": "exact coeff_monomial", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_one_zero : coeff (1 : R[X]) 0 = 1 := by\n  simp [coeff_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Basic.lean", "context": {"open": ["AddMonoidAlgebra Finset", "Finsupp hiding single", "Function hiding Commute"], "variables": ["{R : Type u} {a b : R} {m n : \u2115}", "[Semiring R] {p q : R[X]}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncoeff : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [coeff_one]", "tactic_state": "x\u271d : Sort u_1\ncoeff : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem coeff_monomial_succ : coeff (monomial (n + 1) a) 0 = 0 := by simp [coeff_monomial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Basic.lean", "context": {"open": ["AddMonoidAlgebra Finset", "Finsupp hiding single", "Function hiding Commute"], "variables": ["{R : Type u} {a b : R} {m n : \u2115}", "[Semiring R] {p q : R[X]}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncoeff : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [coeff_monomial]", "tactic_state": "x\u271d : Sort u_1\ncoeff : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem not_mem_support_iff : n \u2209 p.support \u2194 p.coeff n = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Basic.lean", "context": {"open": ["AddMonoidAlgebra Finset", "Finsupp hiding single", "Function hiding Commute"], "variables": ["{R : Type u} {a b : R} {m n : \u2115}", "[Semiring R] {p q : R[X]}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00acsorry \u2194 sorry = 0"}, {"line": "simp", "tactic_state": "\u22a2 \u00acsorry () \u2194 sorry () = 0"}]}
{"declaration": "lemma coeff_C_succ {r : R} {n : \u2115} : coeff (C r) (n + 1) = 0 := by simp [coeff_C]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Basic.lean", "context": {"open": ["AddMonoidAlgebra Finset", "Finsupp hiding single", "Function hiding Commute"], "variables": ["{R : Type u} {a b : R} {m n : \u2115}", "[Semiring R] {p q : R[X]}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nx\u271d : Sort u_1\ncoeff : x\u271d\nr : R\nn : \u2115\n\u22a2 sorry = 0"}, {"line": "simp [coeff_C]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nx\u271d : Sort u_1\ncoeff : x\u271d\nr : R\nn : \u2115\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem coeff_ofNat_succ (a n : \u2115) [h : a.AtLeastTwo] :\n    coeff (ofNat(a) : R[X]) (n + 1) = 0 := by\n  rw [\u2190 Nat.cast_ofNat]\n  simp [-Nat.cast_ofNat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Basic.lean", "context": {"open": ["AddMonoidAlgebra Finset", "Finsupp hiding single", "Function hiding Commute"], "variables": ["{R : Type u} {a b : R} {m n : \u2115}", "[Semiring R] {p q : R[X]}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncoeff : x\u271d\na n : \u2115\nh : a.AtLeastTwo\n\u22a2 sorry = 0"}, {"line": "rw [\u2190 Nat.cast_ofNat]", "tactic_state": "x\u271d : Sort u_1\ncoeff : x\u271d\na n : \u2115\nh : a.AtLeastTwo\n\u22a2 sorry\n      (const Lean.Name ()\n        ((((((((((Lean.Name.anonymous.num \u21919).num 4).num \u21919).num 35).num 4).num 35).str \"_sorry\").str \"_@\").str\n              \"_hyg\").num\n          357)) =\n    0"}, {"line": "simp [-Nat.cast_ofNat]", "tactic_state": "x\u271d : Sort u_1\ncoeff : x\u271d\na n : \u2115\nh : a.AtLeastTwo\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem forall_eq_iff_forall_eq : (\u2200 f g : R[X], f = g) \u2194 \u2200 a b : R, a = b := by\n  simpa only [\u2190 subsingleton_iff] using subsingleton_iff_subsingleton\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Basic.lean", "context": {"open": ["AddMonoidAlgebra Finset", "Finsupp hiding single", "Function hiding Commute"], "variables": ["{R : Type u} {a b : R} {m n : \u2115}", "[Semiring R] {p q : R[X]}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nR : Type u\ninst\u271d : Semiring R\n\u22a2 (\u2200 (f g : AddMonoidAlgebra R X), f = g) \u2194 \u2200 (a b : R), a = b"}, {"line": "simpa only [\u2190 subsingleton_iff] using subsingleton_iff_subsingleton", "tactic_state": "No Goals!"}]}
{"declaration": "theorem erase_same (p : R[X]) (n : \u2115) : coeff (p.erase n) n = 0 := by simp [coeff_erase]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Basic.lean", "context": {"open": ["AddMonoidAlgebra Finset", "Finsupp hiding single", "Function hiding Commute", "Finset"], "variables": ["{R : Type u} {a b : R} {m n : \u2115}", "[Semiring R] {p q : R[X]}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\nR : Type u\ninst\u271d : Semiring R\nx\u271d : Sort u_1\ncoeff : x\u271d\np : AddMonoidAlgebra R X\nn : \u2115\n\u22a2 sorry = 0"}, {"line": "simp [coeff_erase]", "tactic_state": "X : Type u_2\nR : Type u\ninst\u271d : Semiring R\nx\u271d : Sort u_1\ncoeff : x\u271d\np : AddMonoidAlgebra R X\nn : \u2115\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem C_eq_intCast (n : \u2124) : C (n : R) = n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Basic.lean", "context": {"open": ["AddMonoidAlgebra Finset", "Finsupp hiding single", "Function hiding Commute", "Finset"], "variables": ["{R : Type u} {a b : R} {m n : \u2115}", "[Semiring R] {p q : R[X]}", "(R)", "[CommSemiring R]", "[Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nC : x\u271d\nn : \u2124\n\u22a2 sorry = n"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nC : x\u271d\nn : \u2124\n\u22a2 sorry () = n"}]}
{"declaration": "theorem coeff_add (p q : R[X]) (n : \u2115) : coeff (p + q) n = coeff p n + coeff q n := by\n  rcases p with \u27e8\u27e9\n  rcases q with \u27e8\u27e9\n  simp_rw [\u2190 ofFinsupp_add, coeff]\n  exact Finsupp.add_apply _ _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Coeff.lean", "context": {"open": ["Finsupp Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nn : \u2115\n\u22a2 (p + q).coeff n = p.coeff n + q.coeff n"}, {"line": "rcases p with \u27e8\u27e9", "tactic_state": "case ofFinsupp\nR : Type u\ninst\u271d : Semiring R\nq : Polynomial R\nn : \u2115\ntoFinsupp\u271d : AddMonoidAlgebra R \u2115\n\u22a2 ({ toFinsupp := toFinsupp\u271d } + q).coeff n = { toFinsupp := toFinsupp\u271d }.coeff n + q.coeff n"}, {"line": "rcases q with \u27e8\u27e9", "tactic_state": "case ofFinsupp.ofFinsupp\nR : Type u\ninst\u271d : Semiring R\nn : \u2115\ntoFinsupp\u271d\u00b9 toFinsupp\u271d : AddMonoidAlgebra R \u2115\n\u22a2 ({ toFinsupp := toFinsupp\u271d\u00b9 } + { toFinsupp := toFinsupp\u271d }).coeff n =\n    { toFinsupp := toFinsupp\u271d\u00b9 }.coeff n + { toFinsupp := toFinsupp\u271d }.coeff n"}, {"line": "simp_rw [\u2190 ofFinsupp_add, coeff]", "tactic_state": "case ofFinsupp.ofFinsupp\nR : Type u\ninst\u271d : Semiring R\nn : \u2115\ntoFinsupp\u271d\u00b9 toFinsupp\u271d : AddMonoidAlgebra R \u2115\n\u22a2 (toFinsupp\u271d\u00b9 + toFinsupp\u271d) n = toFinsupp\u271d\u00b9 n + toFinsupp\u271d n"}, {"line": "exact Finsupp.add_apply _ _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_smul [SMulZeroClass S R] (r : S) (p : R[X]) (n : \u2115) :\n    coeff (r \u2022 p) n = r \u2022 coeff p n := by\n  rcases p with \u27e8\u27e9\n  simp_rw [\u2190 ofFinsupp_smul, coeff]\n  exact Finsupp.smul_apply _ _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Coeff.lean", "context": {"open": ["Finsupp Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : SMulZeroClass S R\nr : S\np : Polynomial R\nn : \u2115\n\u22a2 (r \u2022 p).coeff n = r \u2022 p.coeff n"}, {"line": "rcases p with \u27e8\u27e9", "tactic_state": "case ofFinsupp\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : SMulZeroClass S R\nr : S\nn : \u2115\ntoFinsupp\u271d : AddMonoidAlgebra R \u2115\n\u22a2 (r \u2022 { toFinsupp := toFinsupp\u271d }).coeff n = r \u2022 { toFinsupp := toFinsupp\u271d }.coeff n"}, {"line": "simp_rw [\u2190 ofFinsupp_smul, coeff]", "tactic_state": "case ofFinsupp\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : SMulZeroClass S R\nr : S\nn : \u2115\ntoFinsupp\u271d : AddMonoidAlgebra R \u2115\n\u22a2 (r \u2022 toFinsupp\u271d) n = r \u2022 toFinsupp\u271d n"}, {"line": "exact Finsupp.smul_apply _ _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_mul_X_zero (p : R[X]) : coeff (p * X) 0 = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Coeff.lean", "context": {"open": ["Finsupp Finset AddMonoidAlgebra", "Polynomial", "scoped Pointwise in"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : sorry\n\u22a2 sorry.coeff 0 = 0"}, {"line": "simp", "tactic_state": "p : sorry\n\u22a2 (sorry ()).coeff 0 = 0"}]}
{"declaration": "theorem coeff_X_mul_zero (p : R[X]) : coeff (X * p) 0 = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Coeff.lean", "context": {"open": ["Finsupp Finset AddMonoidAlgebra", "Polynomial", "scoped Pointwise in"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : sorry\n\u22a2 sorry.coeff 0 = 0"}, {"line": "simp", "tactic_state": "p : sorry\n\u22a2 (sorry ()).coeff 0 = 0"}]}
{"declaration": "theorem coeff_mul_X_pow' (p : R[X]) (n d : \u2115) :\n    (p * X ^ n).coeff d = ite (n \u2264 d) (p.coeff (d - n)) 0 := by\n  split_ifs with h\n  \u00b7 rw [\u2190 tsub_add_cancel_of_le h, coeff_mul_X_pow, add_tsub_cancel_right]\n  \u00b7 refine (coeff_mul _ _ _).trans (Finset.sum_eq_zero fun x hx => ?_)\n    rw [coeff_X_pow]\n    rw [if_neg]\n    rw [mul_zero]\n    exact ((le_of_add_le_right (mem_antidiagonal.mp hx).le).trans_lt <| not_le.mp h).ne\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Coeff.lean", "context": {"open": ["Finsupp Finset AddMonoidAlgebra", "Polynomial", "scoped Pointwise in", "Finset"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn d : \u2115\n\u22a2 (p * X ^ n).coeff d = if n \u2264 d then p.coeff (d - n) else 0"}, {"line": "split_ifs with h", "tactic_state": "case pos\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn d : \u2115\nh : n \u2264 d\n\u22a2 (p * X ^ n).coeff d = p.coeff (d - n)\n---\ncase neg\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn d : \u2115\nh : \u00acn \u2264 d\n\u22a2 (p * X ^ n).coeff d = 0"}, {"line": "\u00b7 rw [\u2190 tsub_add_cancel_of_le h, coeff_mul_X_pow, add_tsub_cancel_right]", "tactic_state": "case neg\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn d : \u2115\nh : \u00acn \u2264 d\n\u22a2 (p * X ^ n).coeff d = 0"}, {"line": "\u00b7 refine (coeff_mul _ _ _).trans (Finset.sum_eq_zero fun x hx => ?_)\n    rw [coeff_X_pow]\n    rw [if_neg]\n    rw [mul_zero]\n    exact ((le_of_add_le_right (mem_antidiagonal.mp hx).le).trans_lt <| not_le.mp h).ne", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_mul_X (p : R[X]) (n : \u2115) : coeff (p * X) (n + 1) = coeff p n := by\n  simpa only [pow_one] using coeff_mul_X_pow p 1 n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Coeff.lean", "context": {"open": ["Finsupp Finset AddMonoidAlgebra", "Polynomial", "scoped Pointwise in", "Finset"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\n\u22a2 (p * X).coeff (n + 1) = p.coeff n"}, {"line": "simpa only [pow_one] using coeff_mul_X_pow p 1 n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_mul_monomial (p : R[X]) (n d : \u2115) (r : R) :\n    coeff (p * monomial n r) (d + n) = coeff p d * r := by\n  rw [\u2190 C_mul_X_pow_eq_monomial]\n  rw [\u2190 X_pow_mul]\n  rw [\u2190 mul_assoc]\n  rw [coeff_mul_C]\n  rw [coeff_mul_X_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Coeff.lean", "context": {"open": ["Finsupp Finset AddMonoidAlgebra", "Polynomial", "scoped Pointwise in", "Finset"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn d : \u2115\nr : R\n\u22a2 (p * (monomial n) r).coeff (d + n) = p.coeff d * r"}, {"line": "rw [\u2190 C_mul_X_pow_eq_monomial]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn d : \u2115\nr : R\n\u22a2 (p * (C r * X ^ n)).coeff (d + n) = p.coeff d * r"}, {"line": "rw [\u2190 X_pow_mul]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn d : \u2115\nr : R\n\u22a2 (p * (X ^ n * C r)).coeff (d + n) = p.coeff d * r"}, {"line": "rw [\u2190 mul_assoc]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn d : \u2115\nr : R\n\u22a2 (p * X ^ n * C r).coeff (d + n) = p.coeff d * r"}, {"line": "rw [coeff_mul_C]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn d : \u2115\nr : R\n\u22a2 (p * X ^ n).coeff (d + n) * r = p.coeff d * r"}, {"line": "rw [coeff_mul_X_pow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_monomial_mul (p : R[X]) (n d : \u2115) (r : R) :\n    coeff (monomial n r * p) (d + n) = r * coeff p d := by\n  rw [\u2190 C_mul_X_pow_eq_monomial]\n  rw [mul_assoc]\n  rw [coeff_C_mul]\n  rw [X_pow_mul]\n  rw [coeff_mul_X_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Coeff.lean", "context": {"open": ["Finsupp Finset AddMonoidAlgebra", "Polynomial", "scoped Pointwise in", "Finset"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn d : \u2115\nr : R\n\u22a2 ((monomial n) r * p).coeff (d + n) = r * p.coeff d"}, {"line": "rw [\u2190 C_mul_X_pow_eq_monomial]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn d : \u2115\nr : R\n\u22a2 (C r * X ^ n * p).coeff (d + n) = r * p.coeff d"}, {"line": "rw [mul_assoc]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn d : \u2115\nr : R\n\u22a2 (C r * (X ^ n * p)).coeff (d + n) = r * p.coeff d"}, {"line": "rw [coeff_C_mul]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn d : \u2115\nr : R\n\u22a2 r * (X ^ n * p).coeff (d + n) = r * p.coeff d"}, {"line": "rw [X_pow_mul]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn d : \u2115\nr : R\n\u22a2 r * (p * X ^ n).coeff (d + n) = r * p.coeff d"}, {"line": "rw [coeff_mul_X_pow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_eq_C_mul (a : R) : a \u2022 p = C a * p := by simp [ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Coeff.lean", "context": {"open": ["Finsupp Finset AddMonoidAlgebra", "Polynomial", "scoped Pointwise in", "Finset"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\na : R\n\u22a2 a \u2022 p = C a * p"}, {"line": "simp [ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_coeff_zero {n : \u2115} {R : Type*} [Semiring R] : (n : R[X]).coeff 0 = n := by\n  simp only [coeff_natCast_ite]\n  simp only [ite_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Coeff.lean", "context": {"open": ["Finsupp Finset AddMonoidAlgebra", "Polynomial", "scoped Pointwise in", "Finset"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nR : Type u_1\ninst\u271d : Semiring R\n\u22a2 (\u2191n).coeff 0 = \u2191n"}, {"line": "simp only [coeff_natCast_ite]", "tactic_state": "n : \u2115\nR : Type u_1\ninst\u271d : Semiring R\n\u22a2 \u2191(if True then n else 0) = \u2191n"}, {"line": "simp only [ite_true]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intCast_coeff_zero {i : \u2124} {R : Type*} [Ring R] : (i : R[X]).coeff 0 = i := by\n  cases i <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Coeff.lean", "context": {"open": ["Finsupp Finset AddMonoidAlgebra", "Polynomial", "scoped Pointwise in", "Finset"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "i : \u2124\nR : Type u_1\ninst\u271d : Ring R\n\u22a2 (\u2191i).coeff 0 = \u2191i"}, {"line": "cases i <;> simp", "tactic_state": "case negSucc\nR : Type u_1\ninst\u271d : Ring R\na\u271d : \u2115\n\u22a2 -1 + -\u2191a\u271d = -(\u2191a\u271d + 1)"}]}
{"declaration": "theorem coeffList_neg : (-P).coeffList = P.coeffList.map (-\u00b7) := by\n  by_cases hp : P = 0\n  \u00b7 rw [hp, coeffList_zero, neg_zero, coeffList_zero, List.map_nil]\n  \u00b7 simp [coeffList, hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/CoeffList.lean", "context": {"open": [], "variables": ["{R : Type*}", "[Semiring R]", "{P : R[X]}", "(R) in", "[Ring R] (P : R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nX : ?m.27\n\u22a2 ?m.37 R X"}, {"line": "by_cases hp : P = 0", "tactic_state": "case pos\nR : Type u_1\ninst\u271d : Semiring R\nX : ?m.27\nhp : sorry = 0\n\u22a2 ?m.37 R X\n---\ncase neg\nR : Type u_1\ninst\u271d : Semiring R\nX : ?m.27\nhp : \u00acsorry = 0\n\u22a2 ?m.37 R X"}, {"line": "\u00b7 rw [hp, coeffList_zero, neg_zero, coeffList_zero, List.map_nil]", "tactic_state": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nX : ?m.27\nhp : \u00acsorry = 0\n\u22a2 ?m.37 R X"}, {"line": "\u00b7 simp [coeffList, hp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeffList_C_mul {x : R} (hx : x \u2260 0) : (C x * P).coeffList = P.coeffList.map (x * \u00b7) := by\n  by_cases hp : P = 0\n  \u00b7 simp [hp]\n  \u00b7 simp [coeffList, Polynomial.degree_C hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/CoeffList.lean", "context": {"open": [], "variables": ["{R : Type*}", "[Semiring R]", "{P : R[X]}", "(R) in", "[Ring R] (P : R[X])", "[DivisionSemiring R] (P : R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nX : ?m.27\n\u22a2 ?m.37 R X"}, {"line": "by_cases hp : P = 0", "tactic_state": "case pos\nR : Type u_1\ninst\u271d : Semiring R\nX : ?m.27\nhp : sorry = 0\n\u22a2 ?m.37 R X\n---\ncase neg\nR : Type u_1\ninst\u271d : Semiring R\nX : ?m.27\nhp : \u00acsorry = 0\n\u22a2 ?m.37 R X"}, {"line": "\u00b7 simp [hp]", "tactic_state": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nX : ?m.27\nhp : \u00acsorry = 0\n\u22a2 ?m.37 R X"}, {"line": "\u00b7 simp [coeffList, Polynomial.degree_C hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivative_monomial (a : R) (n : \u2115) :\n    derivative (monomial n a) = monomial (n - 1) (a * n) := by\n  rw [derivative_apply]\n  rw [sum_monomial_index]\n  rw [C_mul_X_pow_eq_monomial]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\nn : \u2115\n\u22a2 derivative ((monomial n) a) = (monomial (n - 1)) (a * \u2191n)"}, {"line": "rw [derivative_apply]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\nn : \u2115\n\u22a2 (((monomial n) a).sum fun n a => C (a * \u2191n) * X ^ (n - 1)) = (monomial (n - 1)) (a * \u2191n)"}, {"line": "rw [sum_monomial_index]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\nn : \u2115\n\u22a2 C (a * \u2191n) * X ^ (n - 1) = (monomial (n - 1)) (a * \u2191n)\n---\ncase hf\nR : Type u\ninst\u271d : Semiring R\na : R\nn : \u2115\n\u22a2 C (0 * \u2191n) * X ^ (n - 1) = 0"}, {"line": "rw [C_mul_X_pow_eq_monomial]", "tactic_state": "case hf\nR : Type u\ninst\u271d : Semiring R\na : R\nn : \u2115\n\u22a2 C (0 * \u2191n) * X ^ (n - 1) = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivative_monomial_succ (a : R) (n : \u2115) :\n    derivative (monomial (n + 1) a) = monomial n (a * (n + 1)) := by\n  rw [derivative_monomial]\n  rw [add_tsub_cancel_right]\n  rw [Nat.cast_add]\n  rw [Nat.cast_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\nn : \u2115\n\u22a2 derivative ((monomial (n + 1)) a) = (monomial n) (a * (\u2191n + 1))"}, {"line": "rw [derivative_monomial]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\nn : \u2115\n\u22a2 (monomial (n + 1 - 1)) (a * \u2191(n + 1)) = (monomial n) (a * (\u2191n + 1))"}, {"line": "rw [add_tsub_cancel_right]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\nn : \u2115\n\u22a2 (monomial n) (a * \u2191(n + 1)) = (monomial n) (a * (\u2191n + 1))"}, {"line": "rw [Nat.cast_add]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\nn : \u2115\n\u22a2 (monomial n) (a * (\u2191n + \u21911)) = (monomial n) (a * (\u2191n + 1))"}, {"line": "rw [Nat.cast_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivative_C_mul_X (a : R) : derivative (C a * X) = C a := by\n  simp [C_mul_X_eq_monomial, derivative_monomial, Nat.cast_one, mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\n\u22a2 derivative (C a * X) = C a"}, {"line": "simp [C_mul_X_eq_monomial, derivative_monomial, Nat.cast_one, mul_one]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\n\u22a2 C a * C 1 = C a"}]}
{"declaration": "theorem derivative_C_mul_X_pow (a : R) (n : \u2115) :\n    derivative (C a * X ^ n) = C (a * n) * X ^ (n - 1) := by\n  rw [C_mul_X_pow_eq_monomial]\n  rw [C_mul_X_pow_eq_monomial]\n  rw [derivative_monomial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\nn : \u2115\n\u22a2 derivative (C a * X ^ n) = C (a * \u2191n) * X ^ (n - 1)"}, {"line": "rw [C_mul_X_pow_eq_monomial]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\nn : \u2115\n\u22a2 derivative ((monomial n) a) = C (a * \u2191n) * X ^ (n - 1)"}, {"line": "rw [C_mul_X_pow_eq_monomial]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\nn : \u2115\n\u22a2 derivative ((monomial n) a) = (monomial (n - 1)) (a * \u2191n)"}, {"line": "rw [derivative_monomial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X := by\n  rw [derivative_C_mul_X_pow]\n  rw [Nat.cast_two]\n  rw [pow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\n\u22a2 derivative (C a * X ^ 2) = C (a * 2) * X"}, {"line": "rw [derivative_C_mul_X_pow]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\n\u22a2 C (a * \u21912) * X ^ (2 - 1) = C (a * 2) * X"}, {"line": "rw [Nat.cast_two]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\n\u22a2 C (a * 2) * X ^ (2 - 1) = C (a * 2) * X"}, {"line": "rw [pow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivative_X_pow_succ (n : \u2115) :\n    derivative (X ^ (n + 1) : R[X]) = C (n + 1 : R) * X ^ n := by\n  simp [derivative_X_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 derivative (X ^ (n + 1)) = C (\u2191n + 1) * X ^ n"}, {"line": "simp [derivative_X_pow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivative_X_sq : derivative (X ^ 2 : R[X]) = C 2 * X := by\n  rw [derivative_X_pow]\n  rw [Nat.cast_two]\n  rw [pow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\n\u22a2 derivative (X ^ 2) = C 2 * X"}, {"line": "rw [derivative_X_pow]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\n\u22a2 C \u21912 * X ^ (2 - 1) = C 2 * X"}, {"line": "rw [Nat.cast_two]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\n\u22a2 C 2 * X ^ (2 - 1) = C 2 * X"}, {"line": "rw [pow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivative_C {a : R} : derivative (C a) = 0 := by simp [derivative_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\n\u22a2 derivative (C a) = 0"}, {"line": "simp [derivative_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivative_X_add_C (c : R) : derivative (X + C c) = 1 := by\n  rw [derivative_add]\n  rw [derivative_X]\n  rw [derivative_C]\n  rw [add_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nc : R\n\u22a2 derivative (X + C c) = 1"}, {"line": "rw [derivative_add]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nc : R\n\u22a2 derivative X + derivative (C c) = 1"}, {"line": "rw [derivative_X]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nc : R\n\u22a2 1 + derivative (C c) = 1"}, {"line": "rw [derivative_C]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nc : R\n\u22a2 1 + 0 = 1"}, {"line": "rw [add_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iterate_derivative_sum (k : \u2115) (s : Finset \u03b9) (f : \u03b9 \u2192 R[X]) :\n    derivative^[k] (\u2211 b \u2208 s, f b) = \u2211 b \u2208 s, derivative^[k] (f b) := by\n  simp_rw [\u2190 Module.End.pow_apply, map_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03b9 : Type y\ninst\u271d : Semiring R\nk : \u2115\ns : Finset \u03b9\nf : \u03b9 \u2192 Polynomial R\n\u22a2 (\u21d1derivative)^[k] (\u2211 b \u2208 s, f b) = \u2211 b \u2208 s, (\u21d1derivative)^[k] (f b)"}, {"line": "simp_rw [\u2190 Module.End.pow_apply, map_sum]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_derivative_le (p : R[X]) : p.derivative.natDegree \u2264 p.natDegree - 1 := by\n  by_cases p0 : p.natDegree = 0\n  \u00b7 simp [p0, derivative_of_natDegree_zero]\n  \u00b7 exact Nat.le_sub_one_of_lt (natDegree_derivative_lt p0)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 (derivative p).natDegree \u2264 p.natDegree - 1"}, {"line": "by_cases p0 : p.natDegree = 0", "tactic_state": "case pos\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\np0 : sorry = 0\n\u22a2 (derivative p).natDegree \u2264 p.natDegree - 1\n---\ncase neg\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\np0 : \u00acsorry = 0\n\u22a2 (derivative p).natDegree \u2264 p.natDegree - 1"}, {"line": "\u00b7 simp [p0, derivative_of_natDegree_zero]", "tactic_state": "case neg\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\np0 : \u00acsorry = 0\n\u22a2 (derivative p).natDegree \u2264 p.natDegree - 1"}, {"line": "\u00b7 exact Nat.le_sub_one_of_lt (natDegree_derivative_lt p0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivative_natCast {n : \u2115} : derivative (n : R[X]) = 0 := by\n  rw [\u2190 map_natCast C n]\n  exact derivative_C\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 derivative \u2191n = 0"}, {"line": "rw [\u2190 map_natCast C n]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 derivative (C \u2191n) = 0"}, {"line": "exact derivative_C", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivative_eval (p : R[X]) (x : R) :\n    p.derivative.eval x = p.sum fun n a => a * n * x ^ (n - 1) := by\n  simp_rw [derivative_apply, eval_sum, eval_mul_X_pow, eval_C]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nx : R\n\u22a2 eval x (derivative p) = p.sum fun n a => a * \u2191n * x ^ (n - 1)"}, {"line": "simp_rw [derivative_apply, eval_sum, eval_mul_X_pow, eval_C]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iterate_derivative_map [Semiring S] (p : R[X]) (f : R \u2192+* S) (k : \u2115) :\n    Polynomial.derivative^[k] (p.map f) = (Polynomial.derivative^[k] p).map f := by\n  induction' k with k ih generalizing p\n  \u00b7 simp\n  \u00b7 simp only [ih, Function.iterate_succ, Polynomial.derivative_map, Function.comp_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : Polynomial R\nf : R \u2192+* S\nk : \u2115\n\u22a2 (\u21d1derivative)^[k] (Polynomial.map f p) = Polynomial.map f ((\u21d1derivative)^[k] p)"}, {"line": "induction' k with k ih generalizing p", "tactic_state": "case zero\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\np : Polynomial R\n\u22a2 (\u21d1derivative)^[0] (Polynomial.map f p) = Polynomial.map f ((\u21d1derivative)^[0] p)\n---\ncase succ\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nk : \u2115\nih : \u2200 (p : Polynomial R), (\u21d1derivative)^[k] (Polynomial.map f p) = Polynomial.map f ((\u21d1derivative)^[k] p)\np : Polynomial R\n\u22a2 (\u21d1derivative)^[k + 1] (Polynomial.map f p) = Polynomial.map f ((\u21d1derivative)^[k + 1] p)"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nk : \u2115\nih : \u2200 (p : Polynomial R), (\u21d1derivative)^[k] (Polynomial.map f p) = Polynomial.map f ((\u21d1derivative)^[k] p)\np : Polynomial R\n\u22a2 (\u21d1derivative)^[k + 1] (Polynomial.map f p) = Polynomial.map f ((\u21d1derivative)^[k + 1] p)"}, {"line": "\u00b7 simp only [ih, Function.iterate_succ, Polynomial.derivative_map, Function.comp_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivative_natCast_mul {n : \u2115} {f : R[X]} :\n    derivative ((n : R[X]) * f) = n * derivative f := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\nf : Polynomial R\n\u22a2 derivative (\u2191n * f) = \u2191n * derivative f"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iterate_derivative_natCast_mul {n k : \u2115} {f : R[X]} :\n    derivative^[k] ((n : R[X]) * f) = n * derivative^[k] f := by\n  induction' k with k ih generalizing f <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn k : \u2115\nf : Polynomial R\n\u22a2 (\u21d1derivative)^[k] (\u2191n * f) = \u2191n * (\u21d1derivative)^[k] f"}, {"line": "induction' k with k ih generalizing f <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_derivativeFinsupp_subset_range {p : R[X]} {n : \u2115} (h : p.natDegree < n) :\n    (derivativeFinsupp p).support \u2286 range n := by\n  dsimp [derivativeFinsupp]\n  exact Finsupp.support_onFinset_subset.trans (Finset.range_subset.mpr h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nh : p.natDegree < n\n\u22a2 (derivativeFinsupp p).support \u2286 range n"}, {"line": "dsimp [derivativeFinsupp]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nh : p.natDegree < n\n\u22a2 (Finsupp.onFinset (range (p.natDegree + 1)) (fun x => (\u21d1derivative)^[x] p) \u22ef).support \u2286 range n"}, {"line": "exact Finsupp.support_onFinset_subset.trans (Finset.range_subset.mpr h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivativeFinsupp_one : derivativeFinsupp (1 : R[X]) = .single 0 1 := by\n  simpa using derivativeFinsupp_C (1 : R)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\n\u22a2 derivativeFinsupp 1 = fun\u2080 | 0 => 1"}, {"line": "simpa using derivativeFinsupp_C (1 : R)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivativeFinsupp_map [Semiring S] (p : R[X]) (f : R \u2192+* S) :\n    derivativeFinsupp (p.map f) = (derivativeFinsupp p).mapRange (\u00b7.map f) (by simp) := by\n  ext i : 1\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : Polynomial R\nf : R \u2192+* S\n\u22a2 derivativeFinsupp (Polynomial.map f p) = Finsupp.mapRange (fun x => Polynomial.map f x) \u22ef (derivativeFinsupp p)"}, {"line": "ext i : 1", "tactic_state": "case h\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : Polynomial R\nf : R \u2192+* S\ni : \u2115\n\u22a2 (derivativeFinsupp (Polynomial.map f p)) i =\n    (Finsupp.mapRange (fun x => Polynomial.map f x) \u22ef (derivativeFinsupp p)) i"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivativeFinsupp_derivative (p : R[X]) :\n    derivativeFinsupp (derivative p) =\n      (derivativeFinsupp p).comapDomain Nat.succ Nat.succ_injective.injOn := by\n  ext i : 1\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 derivativeFinsupp (derivative p) = Finsupp.comapDomain Nat.succ (derivativeFinsupp p) \u22ef"}, {"line": "ext i : 1", "tactic_state": "case h\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\ni : \u2115\n\u22a2 (derivativeFinsupp (derivative p)) i = (Finsupp.comapDomain Nat.succ (derivativeFinsupp p) \u22ef) i"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivative_intCast_mul {n : \u2124} {f : R[X]} : derivative ((n : R[X]) * f) =\n    n * derivative f := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]", "[CommSemiring R]", "[Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\nn : \u2124\nf : Polynomial R\n\u22a2 sorry"}, {"line": "simp", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\nn : \u2124\nf : Polynomial R\n\u22a2 sorry ()"}]}
{"declaration": "theorem iterate_derivative_intCast_mul {n : \u2124} {k : \u2115} {f : R[X]} :\n    derivative^[k] ((n : R[X]) * f) = n * derivative^[k] f := by\n  induction' k with k ih generalizing f <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]", "[CommSemiring R]", "[Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\nn : \u2124\nk : \u2115\nf : Polynomial R\n\u22a2 sorry"}, {"line": "induction' k with k ih generalizing f <;> simp [*]", "tactic_state": "case zero\nR : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\nn : \u2124\nf : Polynomial R\n\u22a2 sorry ()\n---\ncase succ\nR : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\nn : \u2124\nk : \u2115\nih : {f : Polynomial R} \u2192 sorry\nf : Polynomial R\n\u22a2 sorry ()"}]}
{"declaration": "theorem derivative_comp_one_sub_X (p : R[X]) :\n    derivative (p.comp (1 - X)) = -p.derivative.comp (1 - X) := by simp [derivative_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]", "[CommSemiring R]", "[Ring R]", "[CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : CommRing R\np : Polynomial R\n\u22a2 sorry"}, {"line": "simp [derivative_comp]", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : CommRing R\np : Polynomial R\n\u22a2 sorry ()"}]}
{"declaration": "theorem iterate_derivative_comp_one_sub_X (p : R[X]) (k : \u2115) :\n    derivative^[k] (p.comp (1 - X)) = (-1) ^ k * (derivative^[k] p).comp (1 - X) := by\n  induction' k with k ih generalizing p\n  \u00b7 simp\n  \u00b7 simp [ih (derivative p), iterate_derivative_neg, derivative_comp, pow_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Derivative.lean", "context": {"open": ["Finset", "Polynomial", "scoped Nat"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]", "[CommSemiring R]", "[Ring R]", "[CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : CommRing R\np : Polynomial R\nk : \u2115\n\u22a2 sorry"}, {"line": "induction' k with k ih generalizing p", "tactic_state": "case zero\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : CommRing R\np : Polynomial R\n\u22a2 sorry\n---\ncase succ\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : CommRing R\nk : \u2115\nih : Polynomial R \u2192 sorry\np : Polynomial R\n\u22a2 sorry"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : CommRing R\nk : \u2115\nih : Polynomial R \u2192 sorry\np : Polynomial R\n\u22a2 sorry"}, {"line": "\u00b7 simp [ih (derivative p), iterate_derivative_neg, derivative_comp, pow_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem X_dvd_sub_C : X \u2223 p - C (p.coeff 0) := by\n  simp [X_dvd_iff, coeff_C]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Div.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {A : Type z} {a b : R} {n : \u2115}", "[Semiring R]", "{p q : R[X]}", "[Ring R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 X \u2223 sorry"}, {"line": "simp [X_dvd_iff, coeff_C]", "tactic_state": "\u22a2 X \u2223 sorry ()"}]}
{"declaration": "theorem eraseLead_support (f : R[X]) : f.eraseLead.support = f.support.erase f.natDegree := by\n  simp only [eraseLead]\n  simp only [support_erase]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 f.eraseLead.support = f.support.erase f.natDegree"}, {"line": "simp only [eraseLead]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 (Polynomial.erase f.natDegree f).support = f.support.erase f.natDegree"}, {"line": "simp only [support_erase]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eraseLead_coeff (i : \u2115) :\n    f.eraseLead.coeff i = if i = f.natDegree then 0 else f.coeff i := by\n  simp only [eraseLead]\n  simp only [coeff_erase]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\ni : \u2115\n\u22a2 f.eraseLead.coeff i = if i = f.natDegree then 0 else f.coeff i"}, {"line": "simp only [eraseLead]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\ni : \u2115\n\u22a2 (Polynomial.erase f.natDegree f).coeff i = if i = f.natDegree then 0 else f.coeff i"}, {"line": "simp only [coeff_erase]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eraseLead_coeff_natDegree : f.eraseLead.coeff f.natDegree = 0 := by simp [eraseLead_coeff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 f.eraseLead.coeff f.natDegree = 0"}, {"line": "simp [eraseLead_coeff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eraseLead_coeff_of_ne (i : \u2115) (hi : i \u2260 f.natDegree) : f.eraseLead.coeff i = f.coeff i := by\n  simp [eraseLead_coeff, hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\ni : \u2115\nhi : i \u2260 f.natDegree\n\u22a2 f.eraseLead.coeff i = f.coeff i"}, {"line": "simp [eraseLead_coeff, hi]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eraseLead_zero : eraseLead (0 : R[X]) = 0 := by simp only [eraseLead, erase_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\n\u22a2 eraseLead 0 = 0"}, {"line": "simp only [eraseLead, erase_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eraseLead_add_C_mul_X_pow (f : R[X]) :\n    f.eraseLead + C f.leadingCoeff * X ^ f.natDegree = f := by\n  rw [C_mul_X_pow_eq_monomial]\n  rw [eraseLead_add_monomial_natDegree_leadingCoeff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 f.eraseLead + C f.leadingCoeff * X ^ f.natDegree = f"}, {"line": "rw [C_mul_X_pow_eq_monomial]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 f.eraseLead + (monomial f.natDegree) f.leadingCoeff = f"}, {"line": "rw [eraseLead_add_monomial_natDegree_leadingCoeff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem self_sub_C_mul_X_pow {R : Type*} [Ring R] (f : R[X]) :\n    f - C f.leadingCoeff * X ^ f.natDegree = f.eraseLead := by\n  rw [C_mul_X_pow_eq_monomial]\n  rw [self_sub_monomial_natDegree_leadingCoeff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d : Ring R\nf : Polynomial R\n\u22a2 f - C f.leadingCoeff * X ^ f.natDegree = f.eraseLead"}, {"line": "rw [C_mul_X_pow_eq_monomial]", "tactic_state": "R : Type u_2\ninst\u271d : Ring R\nf : Polynomial R\n\u22a2 f - (monomial f.natDegree) f.leadingCoeff = f.eraseLead"}, {"line": "rw [self_sub_monomial_natDegree_leadingCoeff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eraseLead_ne_zero (f0 : 2 \u2264 #f.support) : eraseLead f \u2260 0 := by\n  rw [Ne]\n  rw [\u2190 card_support_eq_zero]\n  rw [eraseLead_support]\n  exact\n    (zero_lt_one.trans_le <| (tsub_le_tsub_right f0 1).trans Finset.pred_card_le_card_erase).ne.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nf0 : 2 \u2264 f.support.card\n\u22a2 f.eraseLead \u2260 0"}, {"line": "rw [Ne]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nf0 : 2 \u2264 f.support.card\n\u22a2 \u00acf.eraseLead = 0"}, {"line": "rw [\u2190 card_support_eq_zero]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nf0 : 2 \u2264 f.support.card\n\u22a2 \u00acf.eraseLead.support.card = 0"}, {"line": "rw [eraseLead_support]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nf0 : 2 \u2264 f.support.card\n\u22a2 \u00ac(f.support.erase f.natDegree).card = 0"}, {"line": "exact\n    (zero_lt_one.trans_le <| (tsub_le_tsub_right f0 1).trans Finset.pred_card_le_card_erase).ne.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_natDegree_of_mem_eraseLead_support {a : \u2115} (h : a \u2208 (eraseLead f).support) :\n    a < f.natDegree := by\n  rw [eraseLead_support] at h\n  rw [mem_erase] at h\n  exact (le_natDegree_of_mem_supp a h.2).lt_of_ne h.1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\na : \u2115\nh : a \u2208 f.eraseLead.support\n\u22a2 a < f.natDegree"}, {"line": "rw [eraseLead_support] at h", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\na : \u2115\nh : a \u2208 f.support.erase f.natDegree\n\u22a2 a < f.natDegree"}, {"line": "rw [mem_erase] at h", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\na : \u2115\nh : a \u2260 f.natDegree \u2227 a \u2208 f.support\n\u22a2 a < f.natDegree"}, {"line": "exact (le_natDegree_of_mem_supp a h.2).lt_of_ne h.1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eraseLead_support_card_lt (h : f \u2260 0) : #(eraseLead f).support < #f.support := by\n  rw [eraseLead_support]\n  exact card_lt_card (erase_ssubset <| natDegree_mem_support_of_nonzero h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nh : f \u2260 0\n\u22a2 f.eraseLead.support.card < f.support.card"}, {"line": "rw [eraseLead_support]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nh : f \u2260 0\n\u22a2 (f.support.erase f.natDegree).card < f.support.card"}, {"line": "exact card_lt_card (erase_ssubset <| natDegree_mem_support_of_nonzero h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_support_eraseLead : #f.eraseLead.support = #f.support - 1 := by\n  by_cases hf : f = 0\n  \u00b7 rw [hf, eraseLead_zero, support_zero, card_empty]\n  \u00b7 rw [\u2190 card_support_eraseLead_add_one hf, add_tsub_cancel_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 f.eraseLead.support.card = f.support.card - 1"}, {"line": "by_cases hf : f = 0", "tactic_state": "case pos\nR : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nhf : f = 0\n\u22a2 f.eraseLead.support.card = f.support.card - 1\n---\ncase neg\nR : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nhf : \u00acf = 0\n\u22a2 f.eraseLead.support.card = f.support.card - 1"}, {"line": "\u00b7 rw [hf, eraseLead_zero, support_zero, card_empty]", "tactic_state": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nhf : \u00acf = 0\n\u22a2 f.eraseLead.support.card = f.support.card - 1"}, {"line": "\u00b7 rw [\u2190 card_support_eraseLead_add_one hf, add_tsub_cancel_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_support_eraseLead' {c : \u2115} (fc : #f.support = c + 1) :\n    #f.eraseLead.support = c := by\n  rw [card_support_eraseLead]\n  rw [fc]\n  rw [add_tsub_cancel_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nc : \u2115\nfc : f.support.card = c + 1\n\u22a2 f.eraseLead.support.card = c"}, {"line": "rw [card_support_eraseLead]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nc : \u2115\nfc : f.support.card = c + 1\n\u22a2 f.support.card - 1 = c"}, {"line": "rw [fc]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nc : \u2115\nfc : f.support.card = c + 1\n\u22a2 c + 1 - 1 = c"}, {"line": "rw [add_tsub_cancel_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_support_le_one_of_eraseLead_eq_zero (h : f.eraseLead = 0) : #f.support \u2264 1 := by\n  by_cases hpz : f = 0\n  case pos => simp [hpz]\n  case neg => exact le_of_eq (card_support_eq_one_of_eraseLead_eq_zero hpz h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nh : f.eraseLead = 0\n\u22a2 f.support.card \u2264 1"}, {"line": "by_cases hpz : f = 0", "tactic_state": "case pos\nR : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nh : f.eraseLead = 0\nhpz : f = 0\n\u22a2 f.support.card \u2264 1\n---\ncase neg\nR : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nh : f.eraseLead = 0\nhpz : \u00acf = 0\n\u22a2 f.support.card \u2264 1"}, {"line": "case pos => simp [hpz]", "tactic_state": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nh : f.eraseLead = 0\nhpz : \u00acf = 0\n\u22a2 f.support.card \u2264 1"}, {"line": "case neg => exact le_of_eq (card_support_eq_one_of_eraseLead_eq_zero hpz h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eraseLead_X_pow (n : \u2115) : eraseLead (X ^ n : R[X]) = 0 := by\n  rw [X_pow_eq_monomial]\n  rw [eraseLead_monomial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 (X ^ n).eraseLead = 0"}, {"line": "rw [X_pow_eq_monomial]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 ((monomial n) 1).eraseLead = 0"}, {"line": "rw [eraseLead_monomial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eraseLead_C_mul_X_pow (r : R) (n : \u2115) : eraseLead (C r * X ^ n) = 0 := by\n  rw [C_mul_X_pow_eq_monomial]\n  rw [eraseLead_monomial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nr : R\nn : \u2115\n\u22a2 (C r * X ^ n).eraseLead = 0"}, {"line": "rw [C_mul_X_pow_eq_monomial]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nr : R\nn : \u2115\n\u22a2 ((monomial n) r).eraseLead = 0"}, {"line": "rw [eraseLead_monomial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nextCoeff_eq_zero_of_eraseLead_eq_zero (h : f.eraseLead = 0) : f.nextCoeff = 0 := by\n  by_contra h\u2082\n  exact leadingCoeff_ne_zero.mp (leadingCoeff_eraseLead_eq_nextCoeff h\u2082 \u25b8 h\u2082) h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nh : f.eraseLead = 0\n\u22a2 f.nextCoeff = 0"}, {"line": "by_contra h\u2082", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nh : f.eraseLead = 0\nh\u2082 : \u00acf.nextCoeff = 0\n\u22a2 False"}, {"line": "exact leadingCoeff_ne_zero.mp (leadingCoeff_eraseLead_eq_nextCoeff h\u2082 \u25b8 h\u2082) h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_support_eq_two :\n    #f.support = 2 \u2194\n      \u2203 (k m : \u2115) (_ : k < m) (x y : R) (_ : x \u2260 0) (_ : y \u2260 0),\n        f = C x * X ^ k + C y * X ^ m := by\n  refine \u27e8fun h => ?_, ?_\u27e9\n  \u00b7 obtain \u27e8k, x, hk, hx, rfl\u27e9 := card_support_eq.mp h\n    refine \u27e8k 0, k 1, hk Nat.zero_lt_one, x 0, x 1, hx 0, hx 1, ?_\u27e9\n    rw [Fin.sum_univ_castSucc]\n    rw [Fin.sum_univ_one]\n    rfl\n  \u00b7 rintro \u27e8k, m, hkm, x, y, hx, hy, rfl\u27e9\n    exact card_support_binomial hkm.ne hx hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 f.support.card = 2 \u2194 \u2203 k m, \u2203 (_ : k < m), \u2203 x y, \u2203 (_ : x \u2260 0) (_ : y \u2260 0), f = C x * X ^ k + C y * X ^ m"}, {"line": "refine \u27e8fun h => ?_, ?_\u27e9", "tactic_state": "case refine_1\nR : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nh : f.support.card = 2\n\u22a2 \u2203 k m, \u2203 (_ : k < m), \u2203 x y, \u2203 (_ : x \u2260 0) (_ : y \u2260 0), f = C x * X ^ k + C y * X ^ m\n---\ncase refine_2\nR : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 (\u2203 k m, \u2203 (_ : k < m), \u2203 x y, \u2203 (_ : x \u2260 0) (_ : y \u2260 0), f = C x * X ^ k + C y * X ^ m) \u2192 f.support.card = 2"}, {"line": "\u00b7 obtain \u27e8k, x, hk, hx, rfl\u27e9 := card_support_eq.mp h\n    refine \u27e8k 0, k 1, hk Nat.zero_lt_one, x 0, x 1, hx 0, hx 1, ?_\u27e9\n    rw [Fin.sum_univ_castSucc]\n    rw [Fin.sum_univ_one]\n    rfl", "tactic_state": "case refine_2\nR : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 (\u2203 k m, \u2203 (_ : k < m), \u2203 x y, \u2203 (_ : x \u2260 0) (_ : y \u2260 0), f = C x * X ^ k + C y * X ^ m) \u2192 f.support.card = 2"}, {"line": "\u00b7 rintro \u27e8k, m, hkm, x, y, hx, hy, rfl\u27e9\n    exact card_support_binomial hkm.ne hx hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_support_eq_three :\n    #f.support = 3 \u2194\n      \u2203 (k m n : \u2115) (_ : k < m) (_ : m < n) (x y z : R) (_ : x \u2260 0) (_ : y \u2260 0) (_ : z \u2260 0),\n        f = C x * X ^ k + C y * X ^ m + C z * X ^ n := by\n  refine \u27e8fun h => ?_, ?_\u27e9\n  \u00b7 obtain \u27e8k, x, hk, hx, rfl\u27e9 := card_support_eq.mp h\n    refine\n      \u27e8k 0, k 1, k 2, hk Nat.zero_lt_one, hk (Nat.lt_succ_self 1), x 0, x 1, x 2, hx 0, hx 1, hx 2,\n        ?_\u27e9\n    rw [Fin.sum_univ_castSucc]\n    rw [Fin.sum_univ_castSucc]\n    rw [Fin.sum_univ_one]\n    rfl\n  \u00b7 rintro \u27e8k, m, n, hkm, hmn, x, y, z, hx, hy, hz, rfl\u27e9\n    exact card_support_trinomial hkm hmn hx hy hz\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/EraseLead.lean", "context": {"open": ["Polynomial", "Polynomial Finset"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 f.support.card = 3 \u2194\n    \u2203 k m n,\n      \u2203 (_ : k < m) (_ : m < n),\n        \u2203 x y z, \u2203 (_ : x \u2260 0) (_ : y \u2260 0) (_ : z \u2260 0), f = C x * X ^ k + C y * X ^ m + C z * X ^ n"}, {"line": "refine \u27e8fun h => ?_, ?_\u27e9", "tactic_state": "case refine_1\nR : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\nh : f.support.card = 3\n\u22a2 \u2203 k m n,\n    \u2203 (_ : k < m) (_ : m < n),\n      \u2203 x y z, \u2203 (_ : x \u2260 0) (_ : y \u2260 0) (_ : z \u2260 0), f = C x * X ^ k + C y * X ^ m + C z * X ^ n\n---\ncase refine_2\nR : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 (\u2203 k m n,\n      \u2203 (_ : k < m) (_ : m < n),\n        \u2203 x y z, \u2203 (_ : x \u2260 0) (_ : y \u2260 0) (_ : z \u2260 0), f = C x * X ^ k + C y * X ^ m + C z * X ^ n) \u2192\n    f.support.card = 3"}, {"line": "\u00b7 obtain \u27e8k, x, hk, hx, rfl\u27e9 := card_support_eq.mp h\n    refine\n      \u27e8k 0, k 1, k 2, hk Nat.zero_lt_one, hk (Nat.lt_succ_self 1), x 0, x 1, x 2, hx 0, hx 1, hx 2,\n        ?_\u27e9\n    rw [Fin.sum_univ_castSucc]\n    rw [Fin.sum_univ_castSucc]\n    rw [Fin.sum_univ_one]\n    rfl", "tactic_state": "case refine_2\nR : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 (\u2203 k m n,\n      \u2203 (_ : k < m) (_ : m < n),\n        \u2203 x y z, \u2203 (_ : x \u2260 0) (_ : y \u2260 0) (_ : z \u2260 0), f = C x * X ^ k + C y * X ^ m + C z * X ^ n) \u2192\n    f.support.card = 3"}, {"line": "\u00b7 rintro \u27e8k, m, n, hkm, hmn, x, y, z, hx, hy, hz, rfl\u27e9\n    exact card_support_trinomial hkm hmn hx hy hz", "tactic_state": "No Goals!"}]}
{"declaration": "theorem expand_eq_sum {f : R[X]} : expand R p f = f.sum fun e a => C a * (X ^ p) ^ e := by\n  simp [expand, eval\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Expand.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["(R : Type u) [CommSemiring R] {S : Type v} [CommSemiring S] (p q : \u2115)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\np : \u2115\nf : Polynomial R\n\u22a2 (expand R p) f = f.sum fun e a => C a * (X ^ p) ^ e"}, {"line": "simp [expand, eval\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem expand_monomial (r : R) : expand R p (monomial q r) = monomial (q * p) r := by\n  simp_rw [\u2190 smul_X_eq_monomial, map_smul, map_pow, expand_X, mul_comm, pow_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Expand.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["(R : Type u) [CommSemiring R] {S : Type v} [CommSemiring S] (p q : \u2115)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\np q : \u2115\nr : R\n\u22a2 (expand R p) ((monomial q) r) = (monomial (q * p)) r"}, {"line": "simp_rw [\u2190 smul_X_eq_monomial, map_smul, map_pow, expand_X, mul_comm, pow_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem expand_zero (f : R[X]) : expand R 0 f = C (eval 1 f) := by simp [expand]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Expand.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["(R : Type u) [CommSemiring R] {S : Type v} [CommSemiring S] (p q : \u2115)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nf : Polynomial R\n\u22a2 (expand R 0) f = C (eval 1 f)"}, {"line": "simp [expand]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivative_expand (f : R[X]) : Polynomial.derivative (expand R p f) =\n    expand R p (Polynomial.derivative f) * (p * (X ^ (p - 1) : R[X])) := by\n  rw [coe_expand]\n  rw [derivative_eval\u2082_C]\n  rw [derivative_pow]\n  rw [C_eq_natCast]\n  rw [derivative_X]\n  rw [mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Expand.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["(R : Type u) [CommSemiring R] {S : Type v} [CommSemiring S] (p q : \u2115)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\np : \u2115\nf : Polynomial R\n\u22a2 derivative ((expand R p) f) = (expand R p) (derivative f) * (\u2191p * X ^ (p - 1))"}, {"line": "rw [coe_expand]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\np : \u2115\nf : Polynomial R\n\u22a2 derivative (eval\u2082 C (X ^ p) f) = eval\u2082 C (X ^ p) (derivative f) * (\u2191p * X ^ (p - 1))"}, {"line": "rw [derivative_eval\u2082_C]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\np : \u2115\nf : Polynomial R\n\u22a2 eval\u2082 C (X ^ p) (derivative f) * derivative (X ^ p) = eval\u2082 C (X ^ p) (derivative f) * (\u2191p * X ^ (p - 1))"}, {"line": "rw [derivative_pow]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\np : \u2115\nf : Polynomial R\n\u22a2 eval\u2082 C (X ^ p) (derivative f) * (C \u2191p * X ^ (p - 1) * derivative X) =\n    eval\u2082 C (X ^ p) (derivative f) * (\u2191p * X ^ (p - 1))"}, {"line": "rw [C_eq_natCast]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\np : \u2115\nf : Polynomial R\n\u22a2 eval\u2082 C (X ^ p) (derivative f) * (\u2191p * X ^ (p - 1) * derivative X) =\n    eval\u2082 C (X ^ p) (derivative f) * (\u2191p * X ^ (p - 1))"}, {"line": "rw [derivative_X]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\np : \u2115\nf : Polynomial R\n\u22a2 eval\u2082 C (X ^ p) (derivative f) * (\u2191p * X ^ (p - 1) * 1) = eval\u2082 C (X ^ p) (derivative f) * (\u2191p * X ^ (p - 1))"}, {"line": "rw [mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_expand_mul {p : \u2115} (hp : 0 < p) (f : R[X]) (n : \u2115) :\n    (expand R p f).coeff (n * p) = f.coeff n := by\n  rw [coeff_expand hp]\n  rw [if_pos (dvd_mul_left _ _)]\n  rw [Nat.mul_div_cancel _ hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Expand.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["(R : Type u) [CommSemiring R] {S : Type v} [CommSemiring S] (p q : \u2115)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\np : \u2115\nhp : 0 < p\nf : Polynomial R\nn : \u2115\n\u22a2 ((expand R p) f).coeff (n * p) = f.coeff n"}, {"line": "rw [coeff_expand hp]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\np : \u2115\nhp : 0 < p\nf : Polynomial R\nn : \u2115\n\u22a2 (if p \u2223 n * p then f.coeff (n * p / p) else 0) = f.coeff n"}, {"line": "rw [if_pos (dvd_mul_left _ _)]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\np : \u2115\nhp : 0 < p\nf : Polynomial R\nn : \u2115\n\u22a2 f.coeff (n * p / p) = f.coeff n"}, {"line": "rw [Nat.mul_div_cancel _ hp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_expand_mul' {p : \u2115} (hp : 0 < p) (f : R[X]) (n : \u2115) :\n    (expand R p f).coeff (p * n) = f.coeff n := by rw [mul_comm, coeff_expand_mul hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Expand.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["(R : Type u) [CommSemiring R] {S : Type v} [CommSemiring S] (p q : \u2115)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\np : \u2115\nhp : 0 < p\nf : Polynomial R\nn : \u2115\n\u22a2 ((expand R p) f).coeff (p * n) = f.coeff n"}, {"line": "rw [mul_comm, coeff_expand_mul hp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leadingCoeff_expand {p : \u2115} {f : R[X]} (hp : 0 < p) :\n    (expand R p f).leadingCoeff = f.leadingCoeff := by\n  simp_rw [leadingCoeff, natDegree_expand, coeff_expand_mul hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Expand.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["(R : Type u) [CommSemiring R] {S : Type v} [CommSemiring S] (p q : \u2115)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\np : \u2115\nf : Polynomial R\nhp : 0 < p\n\u22a2 ((expand R p) f).leadingCoeff = f.leadingCoeff"}, {"line": "simp_rw [leadingCoeff, natDegree_expand, coeff_expand_mul hp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem monic_expand_iff {p : \u2115} {f : R[X]} (hp : 0 < p) : (expand R p f).Monic \u2194 f.Monic := by\n  simp only [Monic]\n  simp only [leadingCoeff_expand hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Expand.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["(R : Type u) [CommSemiring R] {S : Type v} [CommSemiring S] (p q : \u2115)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\np : \u2115\nf : Polynomial R\nhp : 0 < p\n\u22a2 ((expand R p) f).Monic \u2194 f.Monic"}, {"line": "simp only [Monic]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\np : \u2115\nf : Polynomial R\nhp : 0 < p\n\u22a2 ((expand R p) f).leadingCoeff = 1 \u2194 f.leadingCoeff = 1"}, {"line": "simp only [leadingCoeff_expand hp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rootMultiplicity_expand :\n    (expand R p f).rootMultiplicity r = p * f.rootMultiplicity (r ^ p) := by\n  rw [\u2190 pow_one p]\n  rw [rootMultiplicity_expand_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Expand.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["(R : Type u) [CommSemiring R] {S : Type v} [CommSemiring S] (p q : \u2115)", "{R}", "[ExpChar R p]", "{R : Type u} [CommRing R] {p n : \u2115} [ExpChar R p] {f : R[X]} {r : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : CommRing R\np : \u2115\ninst\u271d : ExpChar R p\nf : Polynomial R\nr : R\n\u22a2 rootMultiplicity r ((expand R p) f) = p * rootMultiplicity (r ^ p) f"}, {"line": "rw [\u2190 pow_one p]", "tactic_state": "R : Type u\ninst\u271d\u00b9 : CommRing R\np : \u2115\ninst\u271d : ExpChar R p\nf : Polynomial R\nr : R\n\u22a2 rootMultiplicity r ((expand R (p ^ 1)) f) = p ^ 1 * rootMultiplicity (r ^ p ^ 1) f"}, {"line": "rw [rootMultiplicity_expand_pow]", "tactic_state": "R : Type u\ninst\u271d\u00b9 : CommRing R\np : \u2115\ninst\u271d : ExpChar R p\nf : Polynomial R\nr : R\n\u22a2 ExpChar R p"}]}
{"declaration": "theorem derivative_rootMultiplicity_of_root [CharZero R] {p : R[X]} {t : R} (hpt : p.IsRoot t) :\n    p.derivative.rootMultiplicity t = p.rootMultiplicity t - 1 := by\n  by_cases h : p = 0\n  \u00b7 rw [h, map_zero, rootMultiplicity_zero]\n  exact derivative_rootMultiplicity_of_root_of_mem_nonZeroDivisors hpt <|\n    mem_nonZeroDivisors_of_ne_zero <| Nat.cast_ne_zero.2 ((rootMultiplicity_pos h).2 hpt).ne'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/FieldDivision.lean", "context": {"open": ["Polynomial", "Finset in"], "variables": ["{R : Type u} {S : Type v} {k : Type y} {A : Type z} {a b : R} {n : \u2115}", "[CommRing R]", "[CommRing R] [IsDomain R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : CharZero R\np : Polynomial R\nt : R\nhpt : p.IsRoot t\n\u22a2 rootMultiplicity t (derivative p) = rootMultiplicity t p - 1"}, {"line": "by_cases h : p = 0", "tactic_state": "case pos\nR : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : CharZero R\np : Polynomial R\nt : R\nhpt : p.IsRoot t\nh : p = 0\n\u22a2 rootMultiplicity t (derivative p) = rootMultiplicity t p - 1\n---\ncase neg\nR : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : CharZero R\np : Polynomial R\nt : R\nhpt : p.IsRoot t\nh : \u00acp = 0\n\u22a2 rootMultiplicity t (derivative p) = rootMultiplicity t p - 1"}, {"line": "\u00b7 rw [h, map_zero, rootMultiplicity_zero]", "tactic_state": "case neg\nR : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : CharZero R\np : Polynomial R\nt : R\nhpt : p.IsRoot t\nh : \u00acp = 0\n\u22a2 rootMultiplicity t (derivative p) = rootMultiplicity t p - 1"}, {"line": "exact derivative_rootMultiplicity_of_root_of_mem_nonZeroDivisors hpt <|\n    mem_nonZeroDivisors_of_ne_zero <| Nat.cast_ne_zero.2 ((rootMultiplicity_pos h).2 hpt).ne'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_normUnit {p : R[X]} : (normUnit p : R[X]) = C \u2191(normUnit p.leadingCoeff) := by\n  simp [normUnit]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/FieldDivision.lean", "context": {"open": ["Polynomial", "Finset in"], "variables": ["{R : Type u} {S : Type v} {k : Type y} {A : Type z} {a b : R} {n : \u2115}", "[CommRing R]", "[CommRing R] [IsDomain R]", "[NormalizationMonoid R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizationMonoid R\np : Polynomial R\n\u22a2 \u2191(normUnit p) = C \u2191(normUnit p.leadingCoeff)"}, {"line": "simp [normUnit]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leadingCoeff_normalize (p : R[X]) :\n    leadingCoeff (normalize p) = normalize (leadingCoeff p) := by simp [normalize_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/FieldDivision.lean", "context": {"open": ["Polynomial", "Finset in"], "variables": ["{R : Type u} {S : Type v} {k : Type y} {A : Type z} {a b : R} {n : \u2115}", "[CommRing R]", "[CommRing R] [IsDomain R]", "[NormalizationMonoid R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizationMonoid R\np : Polynomial R\n\u22a2 (normalize p).leadingCoeff = normalize p.leadingCoeff"}, {"line": "simp [normalize_apply]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizationMonoid R\np : Polynomial R\n\u22a2 (p * C \u2191(normUnit p.leadingCoeff)).leadingCoeff = p.leadingCoeff * \u2191(normUnit p.leadingCoeff)"}]}
{"declaration": "theorem X_eq_normalize : (X : Polynomial R) = normalize X := by\n  simp only [normalize_apply]\n  simp only [normUnit_X]\n  simp only [Units.val_one]\n  simp only [mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/FieldDivision.lean", "context": {"open": ["Polynomial", "Finset in"], "variables": ["{R : Type u} {S : Type v} {k : Type y} {A : Type z} {a b : R} {n : \u2115}", "[CommRing R]", "[CommRing R] [IsDomain R]", "[NormalizationMonoid R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizationMonoid R\n\u22a2 X = normalize X"}, {"line": "simp only [normalize_apply]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizationMonoid R\n\u22a2 X = X * \u2191(normUnit X)"}, {"line": "simp only [normUnit_X]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizationMonoid R\n\u22a2 X = X * \u21911"}, {"line": "simp only [Units.val_one]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizationMonoid R\n\u22a2 X = X * 1"}, {"line": "simp only [mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem degree_div_le (p q : R[X]) : degree (p / q) \u2264 degree p := by\n  by_cases hq : q = 0\n  \u00b7 simp [hq]\n  \u00b7 rw [div_def, mul_comm, degree_mul_leadingCoeff_inv _ hq]; exact degree_divByMonic_le _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/FieldDivision.lean", "context": {"open": ["Polynomial", "Finset in"], "variables": ["{R : Type u} {S : Type v} {k : Type y} {A : Type z} {a b : R} {n : \u2115}", "[CommRing R]", "[CommRing R] [IsDomain R]", "[NormalizationMonoid R]", "[DivisionRing R] {p q : R[X]}", "[Field R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : NormalizationMonoid R\ninst\u271d\u00b9 : DivisionRing R\ninst\u271d : Field R\np q : Polynomial R\n\u22a2 (p / q).degree \u2264 p.degree"}, {"line": "by_cases hq : q = 0", "tactic_state": "case pos\nR : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : NormalizationMonoid R\ninst\u271d\u00b9 : DivisionRing R\ninst\u271d : Field R\np q : Polynomial R\nhq : q = 0\n\u22a2 (p / q).degree \u2264 p.degree\n---\ncase neg\nR : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : NormalizationMonoid R\ninst\u271d\u00b9 : DivisionRing R\ninst\u271d : Field R\np q : Polynomial R\nhq : \u00acq = 0\n\u22a2 (p / q).degree \u2264 p.degree"}, {"line": "\u00b7 simp [hq]", "tactic_state": "case neg\nR : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : NormalizationMonoid R\ninst\u271d\u00b9 : DivisionRing R\ninst\u271d : Field R\np q : Polynomial R\nhq : \u00acq = 0\n\u22a2 (p / q).degree \u2264 p.degree"}, {"line": "\u00b7 rw [div_def, mul_comm, degree_mul_leadingCoeff_inv _ hq]; exact degree_divByMonic_le _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem roots_C_mul_X_sub_C (b : R) (ha : a \u2260 0) : (C a * X - C b).roots = {a\u207b\u00b9 * b} := by\n  simp [roots_C_mul_X_sub_C_of_IsUnit b \u27e8a, a\u207b\u00b9, mul_inv_cancel\u2080 ha, inv_mul_cancel\u2080 ha\u27e9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/FieldDivision.lean", "context": {"open": ["Polynomial", "Finset in", "EuclideanDomain"], "variables": ["{R : Type u} {S : Type v} {k : Type y} {A : Type z} {a b : R} {n : \u2115}", "[CommRing R]", "[CommRing R] [IsDomain R]", "[NormalizationMonoid R]", "[DivisionRing R] {p q : R[X]}", "[Field R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\na : R\ninst\u271d\u2075 inst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : NormalizationMonoid R\ninst\u271d\u00b9 : DivisionRing R\ninst\u271d : Field R\nb : R\nha : a \u2260 0\n\u22a2 sorry = {a\u207b\u00b9 * b}"}, {"line": "simp [roots_C_mul_X_sub_C_of_IsUnit b \u27e8a, a\u207b\u00b9, mul_inv_cancel\u2080 ha, inv_mul_cancel\u2080 ha\u27e9]", "tactic_state": "R : Type u\na : R\ninst\u271d\u2075 inst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : NormalizationMonoid R\ninst\u271d\u00b9 : DivisionRing R\ninst\u271d : Field R\nb : R\nha : a \u2260 0\n\u22a2 sorry () = {a\u207b\u00b9 * b}"}]}
{"declaration": "theorem roots_C_mul_X_add_C (b : R) (ha : a \u2260 0) : (C a * X + C b).roots = {-(a\u207b\u00b9 * b)} := by\n  simp [roots_C_mul_X_add_C_of_IsUnit b \u27e8a, a\u207b\u00b9, mul_inv_cancel\u2080 ha, inv_mul_cancel\u2080 ha\u27e9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/FieldDivision.lean", "context": {"open": ["Polynomial", "Finset in", "EuclideanDomain"], "variables": ["{R : Type u} {S : Type v} {k : Type y} {A : Type z} {a b : R} {n : \u2115}", "[CommRing R]", "[CommRing R] [IsDomain R]", "[NormalizationMonoid R]", "[DivisionRing R] {p q : R[X]}", "[Field R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\na : R\ninst\u271d\u2075 inst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : NormalizationMonoid R\ninst\u271d\u00b9 : DivisionRing R\ninst\u271d : Field R\nb : R\nha : a \u2260 0\n\u22a2 sorry = {-(a\u207b\u00b9 * b)}"}, {"line": "simp [roots_C_mul_X_add_C_of_IsUnit b \u27e8a, a\u207b\u00b9, mul_inv_cancel\u2080 ha, inv_mul_cancel\u2080 ha\u27e9]", "tactic_state": "R : Type u\na : R\ninst\u271d\u2075 inst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : NormalizationMonoid R\ninst\u271d\u00b9 : DivisionRing R\ninst\u271d : Field R\nb : R\nha : a \u2260 0\n\u22a2 sorry () = {-(a\u207b\u00b9 * b)}"}]}
{"declaration": "theorem coe_normUnit_of_ne_zero [DecidableEq R] (hp : p \u2260 0) :\n    (normUnit p : R[X]) = C p.leadingCoeff\u207b\u00b9 := by\n  have : p.leadingCoeff \u2260 0 := mt leadingCoeff_eq_zero.mp hp\n  simp [CommGroupWithZero.coe_normUnit _ this]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/FieldDivision.lean", "context": {"open": ["Polynomial", "Finset in", "EuclideanDomain"], "variables": ["{R : Type u} {S : Type v} {k : Type y} {A : Type z} {a b : R} {n : \u2115}", "[CommRing R]", "[CommRing R] [IsDomain R]", "[NormalizationMonoid R]", "[DivisionRing R] {p q : R[X]}", "[Field R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2076 inst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : IsDomain R\ninst\u271d\u00b3 : NormalizationMonoid R\ninst\u271d\u00b2 : DivisionRing R\ninst\u271d\u00b9 : Field R\np : Polynomial R\ninst\u271d : DecidableEq R\nhp : p \u2260 0\n\u22a2 \u2191(normUnit p) = C p.leadingCoeff\u207b\u00b9"}, {"line": "have : p.leadingCoeff \u2260 0 := mt leadingCoeff_eq_zero.mp hp", "tactic_state": "R : Type u\ninst\u271d\u2076 inst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : IsDomain R\ninst\u271d\u00b3 : NormalizationMonoid R\ninst\u271d\u00b2 : DivisionRing R\ninst\u271d\u00b9 : Field R\np : Polynomial R\ninst\u271d : DecidableEq R\nhp : p \u2260 0\nthis : sorry \u2260 sorry\n\u22a2 \u2191(normUnit p) = C p.leadingCoeff\u207b\u00b9"}, {"line": "simp [CommGroupWithZero.coe_normUnit _ this]", "tactic_state": "R : Type u\ninst\u271d\u2076 inst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : IsDomain R\ninst\u271d\u00b3 : NormalizationMonoid R\ninst\u271d\u00b2 : DivisionRing R\ninst\u271d\u00b9 : Field R\np : Polynomial R\ninst\u271d : DecidableEq R\nhp : p \u2260 0\nthis : sorry \u2260 sorry\n\u22a2 \u2191(normUnit p.leadingCoeff) = p.leadingCoeff\u207b\u00b9"}]}
{"declaration": "theorem degree_normalize [DecidableEq R] : degree (normalize p) = degree p := by\n  simp [normalize_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/FieldDivision.lean", "context": {"open": ["Polynomial", "Finset in", "EuclideanDomain"], "variables": ["{R : Type u} {S : Type v} {k : Type y} {A : Type z} {a b : R} {n : \u2115}", "[CommRing R]", "[CommRing R] [IsDomain R]", "[NormalizationMonoid R]", "[DivisionRing R] {p q : R[X]}", "[Field R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2076 inst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : IsDomain R\ninst\u271d\u00b3 : NormalizationMonoid R\ninst\u271d\u00b2 : DivisionRing R\ninst\u271d\u00b9 : Field R\np : Polynomial R\ninst\u271d : DecidableEq R\n\u22a2 (normalize p).degree = p.degree"}, {"line": "simp [normalize_apply]", "tactic_state": "R : Type u\ninst\u271d\u2076 inst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : IsDomain R\ninst\u271d\u00b3 : NormalizationMonoid R\ninst\u271d\u00b2 : DivisionRing R\ninst\u271d\u00b9 : Field R\np : Polynomial R\ninst\u271d : DecidableEq R\n\u22a2 p.degree + (C \u2191(normUnit p.leadingCoeff)).degree = p.degree"}]}
{"declaration": "theorem X_sub_C_mul_divByMonic_eq_sub_modByMonic {K : Type*} [Ring K] (f : K[X]) (a : K) :\n    (X - C a) * (f /\u2098 (X - C a)) = f - f %\u2098 (X - C a) := by\n  rw [eq_sub_iff_add_eq]\n  rw [\u2190 eq_sub_iff_add_eq']\n  rw [modByMonic_eq_sub_mul_div]\n  exact monic_X_sub_C a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/FieldDivision.lean", "context": {"open": ["Polynomial", "Finset in", "EuclideanDomain"], "variables": ["{R : Type u} {S : Type v} {k : Type y} {A : Type z} {a b : R} {n : \u2115}", "[CommRing R]", "[CommRing R] [IsDomain R]", "[NormalizationMonoid R]", "[DivisionRing R] {p q : R[X]}", "[Field R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : Ring K\nf : Polynomial K\na : K\n\u22a2 (X - C a) * (f /\u2098 (X - C a)) = f - f %\u2098 (X - C a)"}, {"line": "rw [eq_sub_iff_add_eq]", "tactic_state": "K : Type u_1\ninst\u271d : Ring K\nf : Polynomial K\na : K\n\u22a2 (X - C a) * (f /\u2098 (X - C a)) + f %\u2098 (X - C a) = f"}, {"line": "rw [\u2190 eq_sub_iff_add_eq']", "tactic_state": "K : Type u_1\ninst\u271d : Ring K\nf : Polynomial K\na : K\n\u22a2 f %\u2098 (X - C a) = f - (X - C a) * (f /\u2098 (X - C a))"}, {"line": "rw [modByMonic_eq_sub_mul_div]", "tactic_state": "case _hq\nK : Type u_1\ninst\u271d : Ring K\nf : Polynomial K\na : K\n\u22a2 (X - C a).Monic"}, {"line": "exact monic_X_sub_C a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem divByMonic_add_X_sub_C_mul_derivate_divByMonic_eq_derivative\n    {K : Type*} [CommRing K] (f : K[X]) (a : K) :\n    f /\u2098 (X - C a) + (X - C a) * derivative (f /\u2098 (X - C a)) = derivative f := by\n  have key := by apply congrArg derivative <| X_sub_C_mul_divByMonic_eq_sub_modByMonic f a\n  simpa only [derivative_mul, derivative_sub, derivative_X, derivative_C, sub_zero, one_mul,\n    modByMonic_X_sub_C_eq_C_eval] using key\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/FieldDivision.lean", "context": {"open": ["Polynomial", "Finset in", "EuclideanDomain"], "variables": ["{R : Type u} {S : Type v} {k : Type y} {A : Type z} {a b : R} {n : \u2115}", "[CommRing R]", "[CommRing R] [IsDomain R]", "[NormalizationMonoid R]", "[DivisionRing R] {p q : R[X]}", "[Field R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : CommRing K\nf : Polynomial K\na : K\n\u22a2 f /\u2098 (X - C a) + (X - C a) * derivative (f /\u2098 (X - C a)) = derivative f"}, {"line": "have : key := sorry", "tactic_state": "K : Type u_1\ninst\u271d : CommRing K\nf : Polynomial K\na : K\nthis : sorry\n\u22a2 f /\u2098 (X - C a) + (X - C a) * derivative (f /\u2098 (X - C a)) = derivative f"}, {"line": "simpa only [derivative_mul, derivative_sub, derivative_X, derivative_C, sub_zero, one_mul,\n    modByMonic_X_sub_C_eq_C_eval] using key", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasseDeriv_eq_zero_of_lt_natDegree (p : R[X]) (n : \u2115) (h : p.natDegree < n) :\n    hasseDeriv n p = 0 := by\n  rw [hasseDeriv_apply]\n  rw [sum_def]\n  refine Finset.sum_eq_zero fun x hx => ?_\n  simp [Nat.choose_eq_zero_of_lt ((le_natDegree_of_mem_supp _ hx).trans_lt h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/HasseDeriv.lean", "context": {"open": ["Nat Polynomial", "Function"], "variables": ["{R : Type*} [Semiring R] (k : \u2115) (f : R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nh : p.natDegree < n\n\u22a2 (hasseDeriv n) p = 0"}, {"line": "rw [hasseDeriv_apply]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nh : p.natDegree < n\n\u22a2 (p.sum fun i r => (monomial (i - n)) (\u2191(i.choose n) * r)) = 0"}, {"line": "rw [sum_def]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nh : p.natDegree < n\n\u22a2 \u2211 n_1 \u2208 p.support, (monomial (n_1 - n)) (\u2191(n_1.choose n) * p.coeff n_1) = 0"}, {"line": "refine Finset.sum_eq_zero fun x hx => ?_", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nh : p.natDegree < n\nx : \u2115\nhx : x \u2208 p.support\n\u22a2 (monomial (x - n)) (\u2191(x.choose n) * p.coeff x) = 0"}, {"line": "simp [Nat.choose_eq_zero_of_lt ((le_natDegree_of_mem_supp _ hx).trans_lt h)]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nh : p.natDegree < n\nx : \u2115\nhx : x \u2208 p.support\n\u22a2 \u2191(x.choose n) * p.coeff x = 0"}]}
{"declaration": "theorem hasseDeriv_one' : hasseDeriv 1 f = derivative f := by\n  simp only [hasseDeriv_apply]\n  simp only [derivative_apply]\n  simp only [\u2190 C_mul_X_pow_eq_monomial]\n  simp only [Nat.choose_one_right]\n  simp only [(Nat.cast_commute _ _).eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/HasseDeriv.lean", "context": {"open": ["Nat Polynomial", "Function"], "variables": ["{R : Type*} [Semiring R] (k : \u2115) (f : R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 (hasseDeriv 1) f = derivative f"}, {"line": "simp only [hasseDeriv_apply]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 (f.sum fun i r => (monomial (i - 1)) (\u2191(i.choose 1) * r)) = derivative f"}, {"line": "simp only [derivative_apply]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 (f.sum fun i r => (monomial (i - 1)) (\u2191(i.choose 1) * r)) = f.sum fun n a => C (a * \u2191n) * X ^ (n - 1)"}, {"line": "simp only [\u2190 C_mul_X_pow_eq_monomial]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 (f.sum fun i r => C (\u2191(i.choose 1) * r) * X ^ (i - 1)) = f.sum fun n a => C (a * \u2191n) * X ^ (n - 1)"}, {"line": "simp only [Nat.choose_one_right]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 (f.sum fun i r => C (\u2191i * r) * X ^ (i - 1)) = f.sum fun n a => C (a * \u2191n) * X ^ (n - 1)"}, {"line": "simp only [(Nat.cast_commute _ _).eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasseDeriv_apply_one (hk : 0 < k) : hasseDeriv k (1 : R[X]) = 0 := by\n  rw [\u2190 C_1]\n  rw [hasseDeriv_C k _ hk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/HasseDeriv.lean", "context": {"open": ["Nat Polynomial", "Function"], "variables": ["{R : Type*} [Semiring R] (k : \u2115) (f : R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nk : \u2115\nhk : 0 < k\n\u22a2 (hasseDeriv k) 1 = 0"}, {"line": "rw [\u2190 C_1]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nk : \u2115\nhk : 0 < k\n\u22a2 (hasseDeriv k) (C 1) = 0"}, {"line": "rw [hasseDeriv_C k _ hk]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_hasseDeriv_le (p : R[X]) (n : \u2115) :\n    natDegree (hasseDeriv n p) \u2264 natDegree p - n := by\n  classical\n    rw [hasseDeriv_apply]\n    rw [sum_def]\n    refine (natDegree_sum_le _ _).trans ?_\n    simp_rw [Function.comp, natDegree_monomial]\n    rw [Finset.fold_ite]\n    rw [Finset.fold_const]\n    \u00b7 simp only [ite_self, max_eq_right, zero_le', Finset.fold_max_le, true_and, and_imp,\n        tsub_le_iff_right, mem_support_iff, Ne, Finset.mem_filter]\n      intro x hx hx'\n      have hxp : x \u2264 p.natDegree := le_natDegree_of_ne_zero hx\n      have hxn : n \u2264 x := by\n        contrapose! hx'\n        simp [Nat.choose_eq_zero_of_lt hx']\n      rwa [tsub_add_cancel_of_le (hxn.trans hxp)]\n    \u00b7 simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/HasseDeriv.lean", "context": {"open": ["Nat Polynomial", "Function"], "variables": ["{R : Type*} [Semiring R] (k : \u2115) (f : R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\n\u22a2 ((hasseDeriv n) p).natDegree \u2264 p.natDegree - n"}, {"line": "classical\n    rw [hasseDeriv_apply]\n    rw [sum_def]\n    refine (natDegree_sum_le _ _).trans ?_\n    simp_rw [Function.comp, natDegree_monomial]\n    rw [Finset.fold_ite]\n    rw [Finset.fold_const]\n    \u00b7 simp only [ite_self, max_eq_right, zero_le', Finset.fold_max_le, true_and, and_imp,\n        tsub_le_iff_right, mem_support_iff, Ne, Finset.mem_filter]\n      intro x hx hx'\n      have hxp : x \u2264 p.natDegree := le_natDegree_of_ne_zero hx\n      have hxn : n \u2264 x := by\n        contrapose! hx'\n        simp [Nat.choose_eq_zero_of_lt hx']\n      rwa [tsub_add_cancel_of_le (hxn.trans hxp)]\n    \u00b7 simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem T_sub (m n : \u2124) : (T (m - n) : R[T;T\u207b\u00b9]) = T m * T (-n) := by rw [\u2190 T_add, sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Laurent.lean", "context": {"open": ["Polynomial Function AddMonoidAlgebra Finsupp", "LaurentPolynomial"], "variables": ["{R S : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nm n : \u2124\n\u22a2 T (m - n) = T m * T (-n)"}, {"line": "rw [\u2190 T_add, sub_eq_add_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Polynomial.toLaurent_C (r : R) : toLaurent (Polynomial.C r) = C r := by\n  convert Polynomial.toLaurent_C_mul_T 0 r\n  simp only [Int.ofNat_zero]\n  simp only [T_zero]\n  simp only [mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Laurent.lean", "context": {"open": ["Polynomial Function AddMonoidAlgebra Finsupp", "LaurentPolynomial"], "variables": ["{R S : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nr : R\n\u22a2 toLaurent (Polynomial.C r) = sorry"}, {"line": "convert Polynomial.toLaurent_C_mul_T 0 r", "tactic_state": "case h.e'_3.h\nR : Type u_1\ninst\u271d : Semiring R\nr : R\n\u22a2 sorry = LaurentPolynomial.C r * T \u21910"}, {"line": "simp only [Int.ofNat_zero]", "tactic_state": "case h.e'_3.h\nR : Type u_1\ninst\u271d : Semiring R\nr : R\n\u22a2 sorry = LaurentPolynomial.C r * T 0"}, {"line": "simp only [T_zero]", "tactic_state": "case h.e'_3.h\nR : Type u_1\ninst\u271d : Semiring R\nr : R\n\u22a2 sorry = LaurentPolynomial.C r * 1"}, {"line": "simp only [mul_one]", "tactic_state": "case h.e'_3.h\nR : Type u_1\ninst\u271d : Semiring R\nr : R\n\u22a2 sorry = LaurentPolynomial.C r"}]}
{"declaration": "theorem _root_.Polynomial.toLaurent_X : (toLaurent Polynomial.X : R[T;T\u207b\u00b9]) = T 1 := by\n  have : (Polynomial.X : R[X]) = monomial 1 1 := by simp [\u2190 C_mul_X_pow_eq_monomial]\n  simp [this, Polynomial.toLaurent_C_mul_T]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Laurent.lean", "context": {"open": ["Polynomial Function AddMonoidAlgebra Finsupp", "LaurentPolynomial"], "variables": ["{R S : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\n\u22a2 toLaurent X = T 1"}, {"line": "have : (Polynomial.X : R[X]) = monomial 1 1 := by simp [\u2190 C_mul_X_pow_eq_monomial]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nthis : sorry = (monomial 1) 1\n\u22a2 toLaurent X = T 1"}, {"line": "simp [this, Polynomial.toLaurent_C_mul_T]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Polynomial.toLaurent_C_mul_eq (r : R) (f : R[X]) :\n    toLaurent (Polynomial.C r * f) = C r * toLaurent f := by\n  simp only [map_mul]\n  simp only [Polynomial.toLaurent_C]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Laurent.lean", "context": {"open": ["Polynomial Function AddMonoidAlgebra Finsupp", "LaurentPolynomial"], "variables": ["{R S : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nr : R\nf : Polynomial R\n\u22a2 toLaurent (Polynomial.C r * f) = sorry * toLaurent f"}, {"line": "simp only [map_mul]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nr : R\nf : Polynomial R\n\u22a2 toLaurent (Polynomial.C r) * toLaurent f = sorry * toLaurent f"}, {"line": "simp only [Polynomial.toLaurent_C]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nr : R\nf : Polynomial R\n\u22a2 LaurentPolynomial.C r * toLaurent f = sorry * toLaurent f"}]}
{"declaration": "theorem _root_.Polynomial.toLaurent_X_pow (n : \u2115) : toLaurent (X ^ n : R[X]) = T n := by\n  simp only [map_pow]\n  simp only [Polynomial.toLaurent_X]\n  simp only [T_pow]\n  simp only [mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Laurent.lean", "context": {"open": ["Polynomial Function AddMonoidAlgebra Finsupp", "LaurentPolynomial"], "variables": ["{R S : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 toLaurent (X ^ n) = T \u2191n"}, {"line": "simp only [map_pow]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 toLaurent X ^ n = T \u2191n"}, {"line": "simp only [Polynomial.toLaurent_X]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 T 1 ^ n = T \u2191n"}, {"line": "simp only [T_pow]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 T (\u2191n * 1) = T \u2191n"}, {"line": "simp only [mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Polynomial.toLaurent_C_mul_X_pow (n : \u2115) (r : R) :\n    toLaurent (Polynomial.C r * X ^ n) = C r * T n := by\n  simp only [map_mul]\n  simp only [Polynomial.toLaurent_C]\n  simp only [Polynomial.toLaurent_X_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Laurent.lean", "context": {"open": ["Polynomial Function AddMonoidAlgebra Finsupp", "LaurentPolynomial"], "variables": ["{R S : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\nr : R\n\u22a2 toLaurent (Polynomial.C r * X ^ n) = sorry * T \u2191n"}, {"line": "simp only [map_mul]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\nr : R\n\u22a2 toLaurent (Polynomial.C r) * toLaurent (X ^ n) = sorry * T \u2191n"}, {"line": "simp only [Polynomial.toLaurent_C]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\nr : R\n\u22a2 LaurentPolynomial.C r * toLaurent (X ^ n) = sorry * T \u2191n"}, {"line": "simp only [Polynomial.toLaurent_X_pow]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\nr : R\n\u22a2 LaurentPolynomial.C r * T \u2191n = sorry * T \u2191n"}]}
{"declaration": "theorem degree_C_mul_T_le (n : \u2124) (a : R) : degree (C a * T n) \u2264 n := by\n  by_cases a0 : a = 0\n  \u00b7 simp only [a0, map_zero, zero_mul, degree_zero, bot_le]\n  \u00b7 exact (degree_C_mul_T n a a0).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Laurent.lean", "context": {"open": ["Polynomial Function AddMonoidAlgebra Finsupp", "LaurentPolynomial"], "variables": ["{R S : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2124\na : R\n\u22a2 sorry \u2264 n"}, {"line": "by_cases a0 : a = 0", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2124\na : R\n\u22a2 OfNat R 0\n---\ncase pos\nR : Type u_1\ninst\u271d : Semiring R\nn : \u2124\na : R\na0 : a = 0\n\u22a2 sorry \u2264 n\n---\ncase neg\nR : Type u_1\ninst\u271d : Semiring R\nn : \u2124\na : R\na0 : \u00aca = 0\n\u22a2 sorry \u2264 n"}, {"line": "\u00b7 simp only [a0, map_zero, zero_mul, degree_zero, bot_le]", "tactic_state": "case pos\nR : Type u_1\ninst\u271d : Semiring R\nn : \u2124\na : R\na0 : a = 0\n\u22a2 sorry \u2264 n\n---\ncase neg\nR : Type u_1\ninst\u271d : Semiring R\nn : \u2124\na : R\na0 : \u00aca = 0\n\u22a2 sorry \u2264 n"}, {"line": "\u00b7 exact (degree_C_mul_T n a a0).le", "tactic_state": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nn : \u2124\na : R\na0 : \u00aca = 0\n\u22a2 sorry \u2264 n"}]}
{"declaration": "theorem eval\u2082_C_mul_T (r : R) (n : \u2124) : eval\u2082 f x (C r * T n) = f r * (x ^ n).val := by\n  by_cases hn : 0 \u2264 n\n  \u00b7 lift n to \u2115 using hn\n    rw [map_mul]\n    rw [eval\u2082_C]\n    rw [eval\u2082_T_n]\n    rw [zpow_natCast]\n    rw [Units.val_pow_eq_pow_val]\n  \u00b7 obtain \u27e8m, rfl\u27e9 := Int.exists_eq_neg_ofNat (Int.le_of_not_le hn)\n    rw [map_mul]\n    rw [eval\u2082_C]\n    rw [eval\u2082_T_neg_n]\n    rw [zpow_neg]\n    rw [zpow_natCast]\n    rw [\u2190 inv_pow]\n    rw [Units.val_pow_eq_pow_val]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Laurent.lean", "context": {"open": ["Polynomial Function AddMonoidAlgebra Finsupp", "LaurentPolynomial"], "variables": ["{R S : Type*}", "[Semiring R]", "[CommSemiring R] {S : Type*} [CommSemiring S] (f : R \u2192+* S) (x : S\u02e3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\nS : Type u_3\ninst\u271d : CommSemiring S\nf : R \u2192+* S\nx : S\u02e3\nr : R\nn : \u2124\n\u22a2 sorry = f r * \u2191(x ^ n)"}, {"line": "by_cases hn : 0 \u2264 n", "tactic_state": "case pos\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\nS : Type u_3\ninst\u271d : CommSemiring S\nf : R \u2192+* S\nx : S\u02e3\nr : R\nn : \u2124\nhn : 0 \u2264 n\n\u22a2 sorry = f r * \u2191(x ^ n)\n---\ncase neg\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\nS : Type u_3\ninst\u271d : CommSemiring S\nf : R \u2192+* S\nx : S\u02e3\nr : R\nn : \u2124\nhn : \u00ac0 \u2264 n\n\u22a2 sorry = f r * \u2191(x ^ n)"}, {"line": "\u00b7 lift n to \u2115 using hn\n    rw [map_mul]\n    rw [eval\u2082_C]\n    rw [eval\u2082_T_n]\n    rw [zpow_natCast]\n    rw [Units.val_pow_eq_pow_val]", "tactic_state": "case neg\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\nS : Type u_3\ninst\u271d : CommSemiring S\nf : R \u2192+* S\nx : S\u02e3\nr : R\nn : \u2124\nhn : \u00ac0 \u2264 n\n\u22a2 sorry = f r * \u2191(x ^ n)"}, {"line": "\u00b7 obtain \u27e8m, rfl\u27e9 := Int.exists_eq_neg_ofNat (Int.le_of_not_le hn)\n    rw [map_mul]\n    rw [eval\u2082_C]\n    rw [eval\u2082_T_neg_n]\n    rw [zpow_neg]\n    rw [zpow_natCast]\n    rw [\u2190 inv_pow]\n    rw [Units.val_pow_eq_pow_val]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lifts_iff_liftsRing (p : S[X]) : p \u2208 lifts f \u2194 p \u2208 liftsRing f := by\n  simp only [lifts]\n  simp only [liftsRing]\n  simp only [RingHom.mem_range]\n  simp only [RingHom.mem_rangeS]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Lifts.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type u} [Semiring R] {S : Type v} [Semiring S] {f : R \u2192+* S}", "{R : Type u} [Ring R] {S : Type v} [Ring S] (f : R \u2192+* S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Ring R\nS : Type v\ninst\u271d : Ring S\nf : R \u2192+* S\np : Polynomial S\n\u22a2 p \u2208 lifts f \u2194 p \u2208 liftsRing f"}, {"line": "simp only [lifts]", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Ring R\nS : Type v\ninst\u271d : Ring S\nf : R \u2192+* S\np : Polynomial S\n\u22a2 p \u2208 (mapRingHom f).rangeS \u2194 p \u2208 liftsRing f"}, {"line": "simp only [liftsRing]", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Ring R\nS : Type v\ninst\u271d : Ring S\nf : R \u2192+* S\np : Polynomial S\n\u22a2 p \u2208 (mapRingHom f).rangeS \u2194 p \u2208 (mapRingHom f).range"}, {"line": "simp only [RingHom.mem_range]", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Ring R\nS : Type v\ninst\u271d : Ring S\nf : R \u2192+* S\np : Polynomial S\n\u22a2 p \u2208 (mapRingHom f).rangeS \u2194 \u2203 x, (mapRingHom f) x = p"}, {"line": "simp only [RingHom.mem_rangeS]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ne_zero_of_ne_zero_of_monic (hp : p \u2260 0) (hq : Monic q) : q \u2260 0 := by\n  rintro rfl\n  rw [Monic.def] at hq\n  rw [leadingCoeff_zero] at hq\n  rw [\u2190 mul_one p] at hp\n  rw [\u2190 C_1] at hp\n  rw [\u2190 hq] at hp\n  rw [C_0] at hp\n  rw [mul_zero] at hp\n  exact hp rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Monic.lean", "context": {"open": ["Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {m n : \u2115} {\u03b9 : Type y}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nhp : p \u2260 0\nhq : q.Monic\n\u22a2 q \u2260 0"}, {"line": "rintro rfl", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhp : p \u2260 0\nhq : Monic 0\n\u22a2 False"}, {"line": "rw [Monic.def] at hq", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhp : p \u2260 0\nhq : leadingCoeff 0 = 1\n\u22a2 False"}, {"line": "rw [leadingCoeff_zero] at hq", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhp : p \u2260 0\nhq : 0 = 1\n\u22a2 False"}, {"line": "rw [\u2190 mul_one p] at hp", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhp : p * 1 \u2260 0\nhq : 0 = 1\n\u22a2 False"}, {"line": "rw [\u2190 C_1] at hp", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhp : p * C 1 \u2260 0\nhq : 0 = 1\n\u22a2 False"}, {"line": "rw [\u2190 hq] at hp", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhp : p * C 0 \u2260 0\nhq : 0 = 1\n\u22a2 False"}, {"line": "rw [C_0] at hp", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhp : p * 0 \u2260 0\nhq : 0 = 1\n\u22a2 False"}, {"line": "rw [mul_zero] at hp", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhp : 0 \u2260 0\nhq : 0 = 1\n\u22a2 False"}, {"line": "exact hp rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem monic_C_mul_of_mul_leadingCoeff_eq_one {b : R} (hp : b * p.leadingCoeff = 1) :\n    Monic (C b * p) := by\n  unfold Monic\n  nontriviality\n  rw [leadingCoeff_mul' _] <;> simp [leadingCoeff_C b, hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Monic.lean", "context": {"open": ["Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {m n : \u2115} {\u03b9 : Type y}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nb : R\nhp : b * p.leadingCoeff = 1\n\u22a2 (C b * p).Monic"}, {"line": "unfold Monic", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nb : R\nhp : b * p.leadingCoeff = 1\n\u22a2 (C b * p).leadingCoeff = 1"}, {"line": "nontriviality", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nb : R\nhp : b * p.leadingCoeff = 1\na\u271d : Nontrivial R\n\u22a2 (C b * p).leadingCoeff = 1"}, {"line": "rw [leadingCoeff_mul' _] <;> simp [leadingCoeff_C b, hp]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nb : R\nhp : b * p.leadingCoeff = 1\na\u271d : Nontrivial R\n\u22a2 \u00ac1 = 0"}]}
{"declaration": "theorem monic_mul_C_of_leadingCoeff_mul_eq_one {b : R} (hp : p.leadingCoeff * b = 1) :\n    Monic (p * C b) := by\n  unfold Monic\n  nontriviality\n  rw [leadingCoeff_mul' _] <;> simp [leadingCoeff_C b, hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Monic.lean", "context": {"open": ["Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {m n : \u2115} {\u03b9 : Type y}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nb : R\nhp : p.leadingCoeff * b = 1\n\u22a2 (p * C b).Monic"}, {"line": "unfold Monic", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nb : R\nhp : p.leadingCoeff * b = 1\n\u22a2 (p * C b).leadingCoeff = 1"}, {"line": "nontriviality", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nb : R\nhp : p.leadingCoeff * b = 1\na\u271d : Nontrivial R\n\u22a2 (p * C b).leadingCoeff = 1"}, {"line": "rw [leadingCoeff_mul' _] <;> simp [leadingCoeff_C b, hp]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nb : R\nhp : p.leadingCoeff * b = 1\na\u271d : Nontrivial R\n\u22a2 \u00ac1 = 0"}]}
{"declaration": "theorem nextCoeff_mul (hp : Monic p) (hq : Monic q) :\n    nextCoeff (p * q) = nextCoeff p + nextCoeff q := by\n  nontriviality\n  simp only [\u2190 coeff_one_reverse]\n  rw [reverse_mul] <;> simp [hp.leadingCoeff, hq.leadingCoeff, mul_coeff_one, add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Monic.lean", "context": {"open": ["Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {m n : \u2115} {\u03b9 : Type y}", "[Semiring R] {p q r : R[X]}", "(a) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nhp : p.Monic\nhq : q.Monic\n\u22a2 (p * q).nextCoeff = p.nextCoeff + q.nextCoeff"}, {"line": "nontriviality", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nhp : p.Monic\nhq : q.Monic\na\u271d : Nontrivial R\n\u22a2 (p * q).nextCoeff = p.nextCoeff + q.nextCoeff"}, {"line": "simp only [\u2190 coeff_one_reverse]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nhp : p.Monic\nhq : q.Monic\na\u271d : Nontrivial R\n\u22a2 (p * q).reverse.coeff 1 = p.reverse.coeff 1 + q.reverse.coeff 1"}, {"line": "rw [reverse_mul] <;> simp [hp.leadingCoeff, hq.leadingCoeff, mul_coeff_one, add_comm]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nhp : p.Monic\nhq : q.Monic\na\u271d : Nontrivial R\n\u22a2 p.leadingCoeff * q.nextCoeff + p.nextCoeff * q.leadingCoeff = p.nextCoeff + q.nextCoeff\n---\nR : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nhp : p.Monic\nhq : q.Monic\na\u271d : Nontrivial R\n\u22a2 \u00acp.leadingCoeff * q.leadingCoeff = 0"}]}
{"declaration": "theorem Monic.eq_one_of_isUnit (hm : Monic p) (hpu : IsUnit p) : p = 1 := by\n  nontriviality R\n  obtain \u27e8q, h\u27e9 := hpu.exists_right_inv\n  have := hm.natDegree_mul' (right_ne_zero_of_mul_eq_one h)\n  rw [h] at this\n  rw [natDegree_one] at this\n  rw [eq_comm] at this\n  rw [add_eq_zero] at this\n  exact hm.natDegree_eq_zero_iff_eq_one.mp this.1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Monic.lean", "context": {"open": ["Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {m n : \u2115} {\u03b9 : Type y}", "[Semiring R] {p q r : R[X]}", "(a) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhm : p.Monic\nhpu : IsUnit p\n\u22a2 p = 1"}, {"line": "nontriviality R", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhm : p.Monic\nhpu : IsUnit p\na\u271d : Nontrivial R\n\u22a2 p = 1"}, {"line": "obtain \u27e8q, h\u27e9 := hpu.exists_right_inv", "tactic_state": "case intro\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhm : p.Monic\nhpu : IsUnit p\na\u271d : Nontrivial R\nq : Polynomial R\nh : p * q = 1\n\u22a2 p = 1"}, {"line": "have := hm.natDegree_mul' (right_ne_zero_of_mul_eq_one h)", "tactic_state": "case intro\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhm : p.Monic\nhpu : IsUnit p\na\u271d : Nontrivial R\nq : Polynomial R\nh : p * q = 1\nthis : (p * q).natDegree = p.natDegree + q.natDegree\n\u22a2 p = 1"}, {"line": "rw [h] at this", "tactic_state": "case intro\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhm : p.Monic\nhpu : IsUnit p\na\u271d : Nontrivial R\nq : Polynomial R\nh : p * q = 1\nthis : natDegree 1 = p.natDegree + q.natDegree\n\u22a2 p = 1"}, {"line": "rw [natDegree_one] at this", "tactic_state": "case intro\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhm : p.Monic\nhpu : IsUnit p\na\u271d : Nontrivial R\nq : Polynomial R\nh : p * q = 1\nthis : 0 = p.natDegree + q.natDegree\n\u22a2 p = 1"}, {"line": "rw [eq_comm] at this", "tactic_state": "case intro\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhm : p.Monic\nhpu : IsUnit p\na\u271d : Nontrivial R\nq : Polynomial R\nh : p * q = 1\nthis : p.natDegree + q.natDegree = 0\n\u22a2 p = 1"}, {"line": "rw [add_eq_zero] at this", "tactic_state": "case intro\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhm : p.Monic\nhpu : IsUnit p\na\u271d : Nontrivial R\nq : Polynomial R\nh : p * q = 1\nthis : p.natDegree = 0 \u2227 q.natDegree = 0\n\u22a2 p = 1"}, {"line": "exact hm.natDegree_eq_zero_iff_eq_one.mp this.1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma irreducible_of_monic (hp : p.Monic) (hp1 : p \u2260 1) :\n    Irreducible p \u2194 \u2200 f g : R[X], f.Monic \u2192 g.Monic \u2192 f * g = p \u2192 f = 1 \u2228 g = 1 := by\n  refine\n    \u27e8fun h f g hf hg hp => (h.2 hp.symm).imp hf.eq_one_of_isUnit hg.eq_one_of_isUnit, fun h =>\n      \u27e8hp1 \u2218 hp.eq_one_of_isUnit, fun f g hfg =>\n        (h (g * C f.leadingCoeff) (f * C g.leadingCoeff) ?_ ?_ ?_).symm.imp\n          (isUnit_of_mul_eq_one f _)\n          (isUnit_of_mul_eq_one g _)\u27e9\u27e9\n  \u00b7 rwa [Monic, leadingCoeff_mul, leadingCoeff_C, \u2190 leadingCoeff_mul, mul_comm, \u2190 hfg, \u2190 Monic]\n  \u00b7 rwa [Monic, leadingCoeff_mul, leadingCoeff_C, \u2190 leadingCoeff_mul, \u2190 hfg, \u2190 Monic]\n  \u00b7 rw [mul_mul_mul_comm, \u2190 C_mul, \u2190 leadingCoeff_mul, \u2190 hfg, hp.leadingCoeff, C_1, mul_one,\n      mul_comm, \u2190 hfg]\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Monic.lean", "context": {"open": ["Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {m n : \u2115} {\u03b9 : Type y}", "[Semiring R] {p q r : R[X]}", "(a) in", "[CommSemiring R] {p : R[X]}", "[NoZeroDivisors R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nhp : p.Monic\nhp1 : p \u2260 1\n\u22a2 Irreducible p \u2194 \u2200 (f g : Polynomial R), f.Monic \u2192 g.Monic \u2192 f * g = p \u2192 f = 1 \u2228 g = 1"}, {"line": "refine\n    \u27e8fun h f g hf hg hp => (h.2 hp.symm).imp hf.eq_one_of_isUnit hg.eq_one_of_isUnit, fun h =>\n      \u27e8hp1 \u2218 hp.eq_one_of_isUnit, fun f g hfg =>\n        (h (g * C f.leadingCoeff) (f * C g.leadingCoeff) ?_ ?_ ?_).symm.imp\n          (isUnit_of_mul_eq_one f _)\n          (isUnit_of_mul_eq_one g _)\u27e9\u27e9", "tactic_state": "case refine_1\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nhp : p.Monic\nhp1 : p \u2260 1\nh : \u2200 (f g : Polynomial R), f.Monic \u2192 g.Monic \u2192 f * g = p \u2192 f = 1 \u2228 g = 1\nf g : Polynomial R\nhfg : p = f * g\n\u22a2 (g * sorry).Monic\n---\ncase refine_2\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nhp : p.Monic\nhp1 : p \u2260 1\nh : \u2200 (f g : Polynomial R), f.Monic \u2192 g.Monic \u2192 f * g = p \u2192 f = 1 \u2228 g = 1\nf g : Polynomial R\nhfg : p = f * g\n\u22a2 (f * sorry).Monic\n---\ncase refine_3\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nhp : p.Monic\nhp1 : p \u2260 1\nh : \u2200 (f g : Polynomial R), f.Monic \u2192 g.Monic \u2192 f * g = p \u2192 f = 1 \u2228 g = 1\nf g : Polynomial R\nhfg : p = f * g\n\u22a2 g * sorry * (f * sorry) = p"}, {"line": "\u00b7 rwa [Monic, leadingCoeff_mul, leadingCoeff_C, \u2190 leadingCoeff_mul, mul_comm, \u2190 hfg, \u2190 Monic]", "tactic_state": "case refine_2\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nhp : p.Monic\nhp1 : p \u2260 1\nh : \u2200 (f g : Polynomial R), f.Monic \u2192 g.Monic \u2192 f * g = p \u2192 f = 1 \u2228 g = 1\nf g : Polynomial R\nhfg : p = f * g\n\u22a2 (f * sorry).Monic\n---\ncase refine_3\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nhp : p.Monic\nhp1 : p \u2260 1\nh : \u2200 (f g : Polynomial R), f.Monic \u2192 g.Monic \u2192 f * g = p \u2192 f = 1 \u2228 g = 1\nf g : Polynomial R\nhfg : p = f * g\n\u22a2 g * sorry * (f * sorry) = p"}, {"line": "\u00b7 rwa [Monic, leadingCoeff_mul, leadingCoeff_C, \u2190 leadingCoeff_mul, \u2190 hfg, \u2190 Monic]", "tactic_state": "case refine_3\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nhp : p.Monic\nhp1 : p \u2260 1\nh : \u2200 (f g : Polynomial R), f.Monic \u2192 g.Monic \u2192 f * g = p \u2192 f = 1 \u2228 g = 1\nf g : Polynomial R\nhfg : p = f * g\n\u22a2 g * sorry * (f * sorry) = p"}, {"line": "\u00b7 rw [mul_mul_mul_comm, \u2190 C_mul, \u2190 leadingCoeff_mul, \u2190 hfg, hp.leadingCoeff, C_1, mul_one,\n      mul_comm, \u2190 hfg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Monic.degree_map [Semiring S] [Nontrivial S] {P : R[X]} (hmo : P.Monic) (f : R \u2192+* S) :\n    (P.map f).degree = P.degree := by\n  by_cases hP : P = 0\n  \u00b7 simp [hP]\n  \u00b7 refine le_antisymm degree_map_le ?_\n    rw [degree_eq_natDegree hP]\n    refine le_degree_of_ne_zero ?_\n    rw [coeff_map]\n    rw [Monic.coeff_natDegree hmo]\n    rw [RingHom.map_one]\n    exact one_ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Monic.lean", "context": {"open": ["Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {m n : \u2115} {\u03b9 : Type y}", "[Semiring R] {p q r : R[X]}", "(a) in", "[CommSemiring R] {p : R[X]}", "[NoZeroDivisors R] {p q : R[X]}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : NoZeroDivisors R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nP : Polynomial R\nhmo : P.Monic\nf : R \u2192+* S\n\u22a2 (Polynomial.map f P).degree = P.degree"}, {"line": "by_cases hP : P = 0", "tactic_state": "case pos\nR : Type u\nS : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : NoZeroDivisors R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nP : Polynomial R\nhmo : P.Monic\nf : R \u2192+* S\nhP : P = 0\n\u22a2 (Polynomial.map f P).degree = P.degree\n---\ncase neg\nR : Type u\nS : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : NoZeroDivisors R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nP : Polynomial R\nhmo : P.Monic\nf : R \u2192+* S\nhP : \u00acP = 0\n\u22a2 (Polynomial.map f P).degree = P.degree"}, {"line": "\u00b7 simp [hP]", "tactic_state": "case neg\nR : Type u\nS : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : NoZeroDivisors R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nP : Polynomial R\nhmo : P.Monic\nf : R \u2192+* S\nhP : \u00acP = 0\n\u22a2 (Polynomial.map f P).degree = P.degree"}, {"line": "\u00b7 refine le_antisymm degree_map_le ?_\n    rw [degree_eq_natDegree hP]\n    refine le_degree_of_ne_zero ?_\n    rw [coeff_map]\n    rw [Monic.coeff_natDegree hmo]\n    rw [RingHom.map_one]\n    exact one_ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Monic.mul_right_eq_zero_iff (h : Monic p) {q : R[X]} : p * q = 0 \u2194 q = 0 := by\n  by_cases hq : q = 0 <;> simp [h.mul_right_ne_zero, hq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Monic.lean", "context": {"open": ["Finset", "Polynomial", "Function"], "variables": ["{R : Type u} {S : Type v} {a b : R} {m n : \u2115} {\u03b9 : Type y}", "[Semiring R] {p q r : R[X]}", "(a) in", "[CommSemiring R] {p : R[X]}", "[NoZeroDivisors R] {p q : R[X]}", "[Semiring R]", "[Semiring S] {f : R \u2192+* S}", "[Ring R] {p : R[X]}", "[Semiring R] [Nontrivial R] {p q : R[X]}", "[Semiring R] {p : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : NoZeroDivisors R\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : Semiring R\np : Polynomial R\nh : p.Monic\nq : Polynomial R\n\u22a2 p * q = 0 \u2194 q = 0"}, {"line": "by_cases hq : q = 0 <;> simp [h.mul_right_ne_zero, hq]", "tactic_state": "case neg\nR : Type u\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : NoZeroDivisors R\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : Semiring R\np : Polynomial R\nh : p.Monic\nq : Polynomial R\nhq : \u00acq = 0\n\u22a2 \u00acp * q = 0"}]}
{"declaration": "theorem Monic.mul_left_eq_zero_iff (h : Monic p) {q : R[X]} : q * p = 0 \u2194 q = 0 := by\n  by_cases hq : q = 0 <;> simp [h.mul_left_ne_zero, hq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Monic.lean", "context": {"open": ["Finset", "Polynomial", "Function"], "variables": ["{R : Type u} {S : Type v} {a b : R} {m n : \u2115} {\u03b9 : Type y}", "[Semiring R] {p q r : R[X]}", "(a) in", "[CommSemiring R] {p : R[X]}", "[NoZeroDivisors R] {p q : R[X]}", "[Semiring R]", "[Semiring S] {f : R \u2192+* S}", "[Ring R] {p : R[X]}", "[Semiring R] [Nontrivial R] {p q : R[X]}", "[Semiring R] {p : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : NoZeroDivisors R\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : Semiring R\np : Polynomial R\nh : p.Monic\nq : Polynomial R\n\u22a2 q * p = 0 \u2194 q = 0"}, {"line": "by_cases hq : q = 0 <;> simp [h.mul_left_ne_zero, hq]", "tactic_state": "case neg\nR : Type u\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : NoZeroDivisors R\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : Semiring R\np : Polynomial R\nh : p.Monic\nq : Polynomial R\nhq : \u00acq = 0\n\u22a2 \u00acq * p = 0"}]}
{"declaration": "lemma revAt_eq_self_of_lt {N i : \u2115} (h : N < i) : revAt N i = i := by simp [revAt, Nat.not_le.mpr h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Reverse.lean", "context": {"open": ["Finsupp Finset", "scoped Polynomial"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nrevAt : x\u271d\nN i : \u2115\nh : N < i\n\u22a2 sorry = i"}, {"line": "simp [revAt, Nat.not_le.mpr h]", "tactic_state": "x\u271d : Sort u_2\nrevAt : x\u271d\nN i : \u2115\nh : N < i\n\u22a2 sorry () = i"}]}
{"declaration": "theorem revAt_zero (N : \u2115) : revAt N 0 = N := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Reverse.lean", "context": {"open": ["Finsupp Finset", "scoped Polynomial"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nrevAt : x\u271d\nN : \u2115\n\u22a2 sorry = N"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_2\nrevAt : x\u271d\nN : \u2115\n\u22a2 sorry () = N"}]}
{"declaration": "theorem reverse_eq_zero : f.reverse = 0 \u2194 f = 0 := by simp [reverse]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Reverse.lean", "context": {"open": ["Finsupp Finset", "scoped Polynomial"], "variables": ["{R : Type*} [Semiring R] {f : R[X]}", "{S : Type*} [CommSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nf : Polynomial R\n\u22a2 f.reverse = 0 \u2194 f = 0"}, {"line": "simp [reverse]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem roots_X_add_C (r : R) : roots (X + C r) = {-r} := by simpa using roots_X_sub_C (-r)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Roots.lean", "context": {"open": ["Multiset Finset"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {a b : R} {n : \u2115}", "[CommRing R] [IsDomain R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\nX : ?m.157\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\n\u22a2 ?m.263 R X"}, {"line": "simpa using roots_X_sub_C (-r)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_mem_nthRootsFinset {S F : Type*} [CommRing S] [IsDomain S] [FunLike F R S]\n    [MonoidHomClass F R S] {a : R} {x : R} (hx : x \u2208 nthRootsFinset n a) (f : F) :\n    f x \u2208 nthRootsFinset n (f a) := by\n  by_cases hn : n = 0\n  \u00b7 simp [hn] at hx\n  \u00b7 rw [mem_nthRootsFinset <| Nat.pos_of_ne_zero hn, \u2190 map_pow, (mem_nthRootsFinset\n      (Nat.pos_of_ne_zero hn) a).1 hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Roots.lean", "context": {"open": ["Multiset Finset"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {a b : R} {n : \u2115}", "[CommRing R] [IsDomain R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\nX : ?m.157\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\n\u22a2 ?m.263 R X"}, {"line": "by_cases hn : n = 0", "tactic_state": "case pos\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\nX : ?m.157\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nhn : n = 0\n\u22a2 ?m.263 R X\n---\ncase neg\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\nX : ?m.157\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nhn : \u00acn = 0\n\u22a2 ?m.263 R X"}, {"line": "\u00b7 simp [hn] at hx", "tactic_state": "case neg\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\nX : ?m.157\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nhn : \u00acn = 0\n\u22a2 ?m.263 R X"}, {"line": "\u00b7 rw [mem_nthRootsFinset <| Nat.pos_of_ne_zero hn, \u2190 map_pow, (mem_nthRootsFinset\n      (Nat.pos_of_ne_zero hn) a).1 hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem count_map_roots_of_injective [IsDomain A] [DecidableEq B] (p : A[X]) {f : A \u2192+* B}\n    (hf : Function.Injective f) (b : B) :\n    (p.roots.map f).count b \u2264 rootMultiplicity b (p.map f) := by\n  by_cases hp0 : p = 0\n  \u00b7 simp only [hp0, roots_zero, Multiset.map_zero, Multiset.count_zero, Polynomial.map_zero,\n      rootMultiplicity_zero, le_refl]\n  \u00b7 exact count_map_roots ((Polynomial.map_ne_zero_iff hf).mpr hp0) b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Roots.lean", "context": {"open": ["Multiset Finset", "Cardinal in", "Cardinal in"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {a b : R} {n : \u2115}", "[CommRing R] [IsDomain R] {p q : R[X]}", "[CommRing T]", "(R S) in", "{A B : Type*} [CommRing A] [CommRing B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type ?u.152\nX : ?m.149\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\n\u22a2 ?m.279 R X"}, {"line": "by_cases hp0 : p = 0", "tactic_state": "case pos\nR : Type ?u.152\nX : ?m.149\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nhp0 : sorry = 0\n\u22a2 ?m.279 R X\n---\ncase neg\nR : Type ?u.152\nX : ?m.149\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nhp0 : \u00acsorry = 0\n\u22a2 ?m.279 R X"}, {"line": "\u00b7 simp only [hp0, roots_zero, Multiset.map_zero, Multiset.count_zero, Polynomial.map_zero,\n      rootMultiplicity_zero, le_refl]", "tactic_state": "case neg\nR : Type ?u.152\nX : ?m.149\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nhp0 : \u00acsorry = 0\n\u22a2 ?m.279 R X"}, {"line": "\u00b7 exact count_map_roots ((Polynomial.map_ne_zero_iff hf).mpr hp0) b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_roots_le_of_injective [IsDomain A] [IsDomain B] (p : A[X]) {f : A \u2192+* B}\n    (hf : Function.Injective f) : p.roots.map f \u2264 (p.map f).roots := by\n  by_cases hp0 : p = 0\n  \u00b7 simp only [hp0, roots_zero, Multiset.map_zero, Polynomial.map_zero, le_rfl]\n  exact map_roots_le ((Polynomial.map_ne_zero_iff hf).mpr hp0)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Roots.lean", "context": {"open": ["Multiset Finset", "Cardinal in", "Cardinal in"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {a b : R} {n : \u2115}", "[CommRing R] [IsDomain R] {p q : R[X]}", "[CommRing T]", "(R S) in", "{A B : Type*} [CommRing A] [CommRing B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type ?u.152\nX : ?m.149\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\n\u22a2 ?m.279 R X"}, {"line": "by_cases hp0 : p = 0", "tactic_state": "case pos\nR : Type ?u.152\nX : ?m.149\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nhp0 : sorry = 0\n\u22a2 ?m.279 R X\n---\ncase neg\nR : Type ?u.152\nX : ?m.149\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nhp0 : \u00acsorry = 0\n\u22a2 ?m.279 R X"}, {"line": "\u00b7 simp only [hp0, roots_zero, Multiset.map_zero, Polynomial.map_zero, le_rfl]", "tactic_state": "case neg\nR : Type ?u.152\nX : ?m.149\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nhp0 : \u00acsorry = 0\n\u22a2 ?m.279 R X"}, {"line": "exact map_roots_le ((Polynomial.map_ne_zero_iff hf).mpr hp0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_roots_le_map_of_injective [IsDomain A] [IsDomain B] {p : A[X]} {f : A \u2192+* B}\n    (hf : Function.Injective f) : Multiset.card p.roots \u2264 Multiset.card (p.map f).roots := by\n  by_cases hp0 : p = 0\n  \u00b7 simp only [hp0, roots_zero, Polynomial.map_zero, Multiset.card_zero, le_rfl]\n  exact card_roots_le_map ((Polynomial.map_ne_zero_iff hf).mpr hp0)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Roots.lean", "context": {"open": ["Multiset Finset", "Cardinal in", "Cardinal in"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {a b : R} {n : \u2115}", "[CommRing R] [IsDomain R] {p q : R[X]}", "[CommRing T]", "(R S) in", "{A B : Type*} [CommRing A] [CommRing B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type ?u.152\nX : ?m.149\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\n\u22a2 ?m.279 R X"}, {"line": "by_cases hp0 : p = 0", "tactic_state": "case pos\nR : Type ?u.152\nX : ?m.149\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nhp0 : sorry = 0\n\u22a2 ?m.279 R X\n---\ncase neg\nR : Type ?u.152\nX : ?m.149\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nhp0 : \u00acsorry = 0\n\u22a2 ?m.279 R X"}, {"line": "\u00b7 simp only [hp0, roots_zero, Polynomial.map_zero, Multiset.card_zero, le_rfl]", "tactic_state": "case neg\nR : Type ?u.152\nX : ?m.149\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nhp0 : \u00acsorry = 0\n\u22a2 ?m.279 R X"}, {"line": "exact card_roots_le_map ((Polynomial.map_ne_zero_iff hf).mpr hp0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem splits_map_iff (j : L \u2192+* F) {f : K[X]} : Splits j (f.map i) \u2194 Splits (j.comp i) f := by\n  simp [Splits, Polynomial.map_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Splits.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*} {F : Type u} {K : Type v} {L : Type w}", "[CommRing K] [Field L] [Field F]", "(i : K \u2192+* L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nK : Type v\nL : Type w\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Field L\ninst\u271d : Field F\ni : K \u2192+* L\nj : L \u2192+* F\nf : Polynomial K\n\u22a2 Splits j (map i f) \u2194 Splits (j.comp i) f"}, {"line": "simp [Splits, Polynomial.map_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem splits_pow {f : K[X]} (hf : f.Splits i) (n : \u2115) : (f ^ n).Splits i := by\n  rw [\u2190 Finset.card_range n]\n  rw [\u2190 Finset.prod_const]\n  exact splits_prod i fun j _ => hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Splits.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*} {F : Type u} {K : Type v} {L : Type w}", "[CommRing K] [Field L] [Field F]", "(i : K \u2192+* L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type v\nL : Type w\ninst\u271d\u00b9 : CommRing K\ninst\u271d : Field L\ni : K \u2192+* L\nf : Polynomial K\nhf : Splits i f\nn : \u2115\n\u22a2 Splits i (f ^ n)"}, {"line": "rw [\u2190 Finset.card_range n]", "tactic_state": "K : Type v\nL : Type w\ninst\u271d\u00b9 : CommRing K\ninst\u271d : Field L\ni : K \u2192+* L\nf : Polynomial K\nhf : Splits i f\nn : \u2115\n\u22a2 Splits i (f ^ (Finset.range n).card)"}, {"line": "rw [\u2190 Finset.prod_const]", "tactic_state": "K : Type v\nL : Type w\ninst\u271d\u00b9 : CommRing K\ninst\u271d : Field L\ni : K \u2192+* L\nf : Polynomial K\nhf : Splits i f\nn : \u2115\n\u22a2 Splits i (\u220f _x \u2208 Finset.range n, f)"}, {"line": "exact splits_prod i fun j _ => hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem splits_id_iff_splits {f : K[X]} : (f.map i).Splits (RingHom.id L) \u2194 f.Splits i := by\n  rw [splits_map_iff]\n  rw [RingHom.id_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Splits.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*} {F : Type u} {K : Type v} {L : Type w}", "[CommRing K] [Field L] [Field F]", "(i : K \u2192+* L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type v\nL : Type w\ninst\u271d\u00b9 : CommRing K\ninst\u271d : Field L\ni : K \u2192+* L\nf : Polynomial K\n\u22a2 Splits (RingHom.id L) (map i f) \u2194 Splits i f"}, {"line": "rw [splits_map_iff]", "tactic_state": "K : Type v\nL : Type w\ninst\u271d\u00b9 : CommRing K\ninst\u271d : Field L\ni : K \u2192+* L\nf : Polynomial K\n\u22a2 Splits ((RingHom.id L).comp i) f \u2194 Splits i f"}, {"line": "rw [RingHom.id_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem splits_of_splits_of_dvd {f g : K[X]} (hf0 : f \u2260 0) (hf : Splits i f) (hgf : g \u2223 f) :\n    Splits i g := by\n  obtain \u27e8f, rfl\u27e9 := hgf\n  exact (splits_of_splits_mul i hf0 hf).1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Splits.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*} {F : Type u} {K : Type v} {L : Type w}", "[CommRing K] [Field L] [Field F]", "(i : K \u2192+* L)", "{i}", "(i)", "[CommRing R] [Field K] [Field L] [Field F]", "(i : K \u2192+* L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type v\ninst\u271d\u00b9 : CommRing K\ninst\u271d : Field K\nf g : Polynomial K\nhf0 : f \u2260 0\nhf : sorry\nhgf : g \u2223 f\n\u22a2 sorry"}, {"line": "obtain \u27e8f, rfl\u27e9 := hgf", "tactic_state": "case intro\nK : Type v\ninst\u271d\u00b9 : CommRing K\ninst\u271d : Field K\ng : Polynomial K\nhf : sorry\nf : Polynomial K\nhf0 : g * f \u2260 0\n\u22a2 sorry"}, {"line": "exact (splits_of_splits_mul i hf0 hf).1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_prod_roots_of_monic_of_splits_id {p : K[X]} (m : Monic p)\n    (hsplit : Splits (RingHom.id K) p) : p = (p.roots.map fun a => X - C a).prod := by\n  convert eq_prod_roots_of_splits_id hsplit\n  simp [m]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Splits.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*} {F : Type u} {K : Type v} {L : Type w}", "[CommRing K] [Field L] [Field F]", "(i : K \u2192+* L)", "{i}", "(i)", "[CommRing R] [Field K] [Field L] [Field F]", "(i : K \u2192+* L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type v\ninst\u271d\u00b9 : CommRing K\ninst\u271d : Field K\np : Polynomial K\nm : p.Monic\nhsplit : sorry\n\u22a2 p = sorry"}, {"line": "convert eq_prod_roots_of_splits_id hsplit", "tactic_state": "case h.e'_3\nK : Type v\ninst\u271d\u00b9 : CommRing K\ninst\u271d : Field K\np : Polynomial K\nm : p.Monic\nhsplit : sorry\n\u22a2 sorry = C p.leadingCoeff * (Multiset.map (fun a => X - C a) p.roots).prod"}, {"line": "simp [m]", "tactic_state": "case h.e'_3\nK : Type v\ninst\u271d\u00b9 : CommRing K\ninst\u271d : Field K\np : Polynomial K\nm : p.Monic\nhsplit : sorry\n\u22a2 sorry () = C 1 * (Multiset.map (fun a => X - C a) p.roots).prod"}]}
{"declaration": "theorem aeval_eq_prod_aroots_sub_of_monic_of_splits [Algebra K L] {p : K[X]} (m : Monic p)\n    (hsplit : Splits (algebraMap K L) p) (v : L) :\n    aeval v p = ((p.aroots L).map fun a \u21a6 v - a).prod := by\n  simp [aeval_eq_prod_aroots_sub_of_splits hsplit, m]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Splits.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*} {F : Type u} {K : Type v} {L : Type w}", "[CommRing K] [Field L] [Field F]", "(i : K \u2192+* L)", "{i}", "(i)", "[CommRing R] [Field K] [Field L] [Field F]", "(i : K \u2192+* L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type v\nL : Type w\ninst\u271d\u2074 : CommRing K\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\np : Polynomial K\nm : p.Monic\nhsplit : sorry\nv : L\n\u22a2 (aeval v) p = sorry"}, {"line": "simp [aeval_eq_prod_aroots_sub_of_splits hsplit, m]", "tactic_state": "K : Type v\nL : Type w\ninst\u271d\u2074 : CommRing K\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\np : Polynomial K\nm : p.Monic\nhsplit : sorry\nv : L\n\u22a2 (aeval v) p = sorry ()"}]}
{"declaration": "theorem eval_eq_prod_roots_sub_of_monic_of_splits_id {p : K[X]} (m : Monic p)\n    (hsplit : Splits (RingHom.id K) p) (v : K) :\n    eval v p = (p.roots.map fun a \u21a6 v - a).prod := by\n  simp [eval_eq_prod_roots_sub_of_splits_id hsplit, m]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Splits.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type*} {F : Type u} {K : Type v} {L : Type w}", "[CommRing K] [Field L] [Field F]", "(i : K \u2192+* L)", "{i}", "(i)", "[CommRing R] [Field K] [Field L] [Field F]", "(i : K \u2192+* L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type v\ninst\u271d\u00b9 : CommRing K\ninst\u271d : Field K\np : Polynomial K\nm : p.Monic\nhsplit : sorry\nv : K\n\u22a2 eval v p = sorry"}, {"line": "simp [eval_eq_prod_roots_sub_of_splits_id hsplit, m]", "tactic_state": "K : Type v\ninst\u271d\u00b9 : CommRing K\ninst\u271d : Field K\np : Polynomial K\nm : p.Monic\nhsplit : sorry\nv : K\n\u22a2 eval v p = sorry ()"}]}
{"declaration": "theorem splits_iff_card_roots {p : K[X]} :\n    Splits (RingHom.id K) p \u2194 Multiset.card p.roots = p.natDegree := by\n  constructor\n  \u00b7 intro H\n    rw [natDegree_eq_card_roots H]\n    rw [map_id]\n  \u00b7 intro hroots\n    rw [splits_iff_exists_multiset (RingHom.id K)]\n    use p.roots\n    simp only [RingHom.id_apply]\n    simp only [map_id]\n    exact (C_leadingCoeff_mul_prod_multiset_X_sub_C hroots).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Splits.lean", "context": {"open": ["Polynomial", "UniqueFactorizationMonoid Associates"], "variables": ["{R : Type*} {F : Type u} {K : Type v} {L : Type w}", "[CommRing K] [Field L] [Field F]", "(i : K \u2192+* L)", "{i}", "(i)", "[CommRing R] [Field K] [Field L] [Field F]", "(i : K \u2192+* L)", "(R) in", "[Algebra R K] [Algebra R L]", "(L) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type v\ninst\u271d\u00b9 : CommRing K\ninst\u271d : Field K\np : Polynomial K\n\u22a2 sorry \u2194 sorry.card = p.natDegree"}, {"line": "constructor", "tactic_state": "case mp\nK : Type v\ninst\u271d\u00b9 : CommRing K\ninst\u271d : Field K\np : Polynomial K\n\u22a2 sorry \u2192 sorry.card = p.natDegree\n---\ncase mpr\nK : Type v\ninst\u271d\u00b9 : CommRing K\ninst\u271d : Field K\np : Polynomial K\n\u22a2 sorry.card = p.natDegree \u2192 sorry"}, {"line": "\u00b7 intro H\n    rw [natDegree_eq_card_roots H]\n    rw [map_id]", "tactic_state": "case mpr\nK : Type v\ninst\u271d\u00b9 : CommRing K\ninst\u271d : Field K\np : Polynomial K\n\u22a2 sorry.card = p.natDegree \u2192 sorry"}, {"line": "\u00b7 intro hroots\n    rw [splits_iff_exists_multiset (RingHom.id K)]\n    use p.roots\n    simp only [RingHom.id_apply]\n    simp only [map_id]\n    exact (C_leadingCoeff_mul_prod_multiset_X_sub_C hroots).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_sumIDeriv_of_pos\n    [CommRing R] [Nontrivial R] [NoZeroDivisors R] (p : R[X]) {q : \u2115} (hq : 0 < q) :\n    \u2203 gp : R[X], gp.natDegree \u2264 p.natDegree - q \u2227\n      \u2200 (r : R) {p' : R[X]},\n        p = ((X : R[X]) - C r) ^ (q - 1) * p' \u2192\n        eval r (sumIDeriv p) = (q - 1)! \u2022 p'.eval r + q ! \u2022 eval r gp := by\n  simpa using aeval_sumIDeriv_of_pos R p hq Function.injective_id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/SumIteratedDerivative.lean", "context": {"open": ["Finset", "scoped Nat"], "variables": ["{R S : Type*}", "[Semiring R] [Semiring S]", "[CommSemiring R] {A : Type*} [CommRing A] [Algebra R A]", "(A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring S\ninst\u271d\u2075 : CommSemiring R\nA : Type u_3\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Algebra R A\nX : ?m.702\nC : ?m.1280\neval : ?m.2157\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : NoZeroDivisors R\n\u22a2 ?m.2351 R X"}, {"line": "simpa using aeval_sumIDeriv_of_pos R p hq Function.injective_id", "tactic_state": "No Goals!"}]}
{"declaration": "theorem taylor_C (x : R) : taylor r (C x) = C x := by simp only [taylor_apply, C_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Taylor.lean", "context": {"open": [], "variables": ["{R : Type*} [Semiring R] (r : R) (f : R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Sort u_1\nx\u271d\u00b9 : Sort u_2\ntaylor : x\u271d\u00b9\nx\u271d : Sort u_3\nC : x\u271d\nx : R\n\u22a2 sorry = sorry"}, {"line": "simp only [taylor_apply, C_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem taylor_monomial (i : \u2115) (k : R) : taylor r (monomial i k) = C k * (X + C r) ^ i := by\n  simp [taylor_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Taylor.lean", "context": {"open": [], "variables": ["{R : Type*} [Semiring R] (r : R) (f : R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Sort u_1\nx\u271d\u00b9 : Sort u_2\ntaylor : x\u271d\u00b9\nx\u271d : Sort u_3\nC : x\u271d\n\u03b1\u271d : Type u_4\nX : \u03b1\u271d\ni : \u2115\nk : R\n\u22a2 sorry = sorry * (X + sorry) ^ i"}, {"line": "simp [taylor_apply]", "tactic_state": "R : Sort u_1\nx\u271d\u00b9 : Sort u_2\ntaylor : x\u271d\u00b9\nx\u271d : Sort u_3\nC : x\u271d\n\u03b1\u271d : Type u_4\nX : \u03b1\u271d\ni : \u2115\nk : R\n\u22a2 sorry () = sorry () * (X + sorry ()) ^ i"}]}
{"declaration": "theorem toFn_zero (n : \u2115) : toFn n (0 : R[X]) = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/ofFn.lean", "context": {"open": [], "variables": ["{R : Type*} [Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\ntoFn : x\u271d\nn : \u2115\n\u22a2 sorry = 0"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_2\ntoFn : x\u271d\nn : \u2115\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem ofFn_zero (n : \u2115) : ofFn n (0 : Fin n \u2192 R) = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/ofFn.lean", "context": {"open": [], "variables": ["{R : Type*} [Semiring R]", "{R : Type*} [Semiring R] [DecidableEq R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nofFn : x\u271d\nn : \u2115\n\u22a2 sorry = 0"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_3\nofFn : x\u271d\nn : \u2115\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma ne_zero_of_ofFn_ne_zero {n : \u2115} {v : Fin n \u2192 R} (h : ofFn n v \u2260 0) : n \u2260 0 := by\n  contrapose! h\n  subst h\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/ofFn.lean", "context": {"open": [], "variables": ["{R : Type*} [Semiring R]", "{R : Type*} [Semiring R] [DecidableEq R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : Semiring R\ninst\u271d : DecidableEq R\nx\u271d : Sort u_3\nofFn : x\u271d\nn : \u2115\nv : Fin n \u2192 R\nh : sorry \u2260 0\n\u22a2 n \u2260 0"}, {"line": "contrapose! h", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : Semiring R\ninst\u271d : DecidableEq R\nx\u271d : Sort u_3\nofFn : x\u271d\nn : \u2115\nv : Fin n \u2192 R\nh : n = 0\n\u22a2 sorry = 0"}, {"line": "subst h", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : Semiring R\ninst\u271d : DecidableEq R\nx\u271d : Sort u_3\nofFn : x\u271d\nv : Fin 0 \u2192 R\n\u22a2 sorry = 0"}, {"line": "simp", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : Semiring R\ninst\u271d : DecidableEq R\nx\u271d : Sort u_3\nofFn : x\u271d\nv : Fin 0 \u2192 R\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem ofFn_coeff_eq_val_of_lt {n i : \u2115} (v : Fin n \u2192 R) (hi : i < n) :\n    (ofFn n v).coeff i = v \u27e8i, hi\u27e9 := by\n  simp [ofFn, hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/ofFn.lean", "context": {"open": [], "variables": ["{R : Type*} [Semiring R]", "{R : Type*} [Semiring R] [DecidableEq R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : Semiring R\ninst\u271d : DecidableEq R\nx\u271d : Sort u_3\nofFn : x\u271d\nn i : \u2115\nv : Fin n \u2192 R\nhi : i < n\n\u22a2 sorry = v \u27e8i, hi\u27e9"}, {"line": "simp [ofFn, hi]", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : Semiring R\ninst\u271d : DecidableEq R\nx\u271d : Sort u_3\nofFn : x\u271d\nn i : \u2115\nv : Fin n \u2192 R\nhi : i < n\n\u22a2 sorry () = v \u27e8i, hi\u27e9"}]}
{"declaration": "theorem ofFn_coeff_eq_zero_of_ge {n i : \u2115} (v : Fin n \u2192 R) (hi : n \u2264 i) : (ofFn n v).coeff i = 0 :=\n  by simp [ofFn, hi, Nat.not_lt_of_ge hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/ofFn.lean", "context": {"open": [], "variables": ["{R : Type*} [Semiring R]", "{R : Type*} [Semiring R] [DecidableEq R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : Semiring R\ninst\u271d : DecidableEq R\nx\u271d : Sort u_3\nofFn : x\u271d\nn i : \u2115\nv : Fin n \u2192 R\nhi : n \u2264 i\n\u22a2 sorry = 0"}, {"line": "simp [ofFn, hi, Nat.not_lt_of_ge hi]", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : Semiring R\ninst\u271d : DecidableEq R\nx\u271d : Sort u_3\nofFn : x\u271d\nn i : \u2115\nv : Fin n \u2192 R\nhi : n \u2264 i\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem toFn_comp_ofFn_eq_id (n : \u2115) (v : Fin n \u2192 R) : toFn n (ofFn n v) = v := by\n  simp [toFn, ofFn, LinearMap.pi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/ofFn.lean", "context": {"open": [], "variables": ["{R : Type*} [Semiring R]", "{R : Type*} [Semiring R] [DecidableEq R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : Semiring R\ninst\u271d : DecidableEq R\nx\u271d : Sort u_3\ntoFn : x\u271d\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 sorry = v"}, {"line": "simp [toFn, ofFn, LinearMap.pi]", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : Semiring R\ninst\u271d : DecidableEq R\nx\u271d : Sort u_3\ntoFn : x\u271d\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 sorry () = v"}]}
{"declaration": "theorem zero_le_degree_iff : 0 \u2264 degree p \u2194 p \u2260 0 := by\n  rw [\u2190 not_lt]\n  rw [Nat.WithBot.lt_zero_iff]\n  rw [degree_eq_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/SmallDegree.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring R] {p q : R[X]} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 inst\u271d : Semiring R\np : Polynomial R\n\u22a2 0 \u2264 p.degree \u2194 p \u2260 0"}, {"line": "rw [\u2190 not_lt]", "tactic_state": "R : Type u\ninst\u271d\u00b9 inst\u271d : Semiring R\np : Polynomial R\n\u22a2 \u00acp.degree < 0 \u2194 p \u2260 0"}, {"line": "rw [Nat.WithBot.lt_zero_iff]", "tactic_state": "R : Type u\ninst\u271d\u00b9 inst\u271d : Semiring R\np : Polynomial R\n\u22a2 \u00acp.degree = \u22a5 \u2194 p \u2260 0"}, {"line": "rw [degree_eq_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_support_C_mul_X_pow_le_one {c : R} {n : \u2115} : #(support (C c * X ^ n)) \u2264 1 := by\n  rw [\u2190 card_singleton n]\n  apply card_le_card (support_C_mul_X_pow' n c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Support.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nc : R\nn : \u2115\n\u22a2 (C c * X ^ n).support.card \u2264 1"}, {"line": "rw [\u2190 card_singleton n]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nc : R\nn : \u2115\n\u22a2 (C c * X ^ n).support.card \u2264 {n}.card"}, {"line": "apply card_le_card (support_C_mul_X_pow' n c)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma natDegree_eq_zero_of_isUnit (h : IsUnit p) : natDegree p = 0 := by\n  nontriviality R\n  obtain \u27e8q, hq\u27e9 := h.exists_right_inv\n  have := natDegree_mul (left_ne_zero_of_mul_eq_one hq) (right_ne_zero_of_mul_eq_one hq)\n  rw [hq] at this\n  rw [natDegree_one] at this\n  rw [eq_comm] at this\n  rw [add_eq_zero] at this\n  exact this.1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Units.lean", "context": {"open": ["Finsupp Finset Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [NoZeroDivisors R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nh : IsUnit p\n\u22a2 p.natDegree = 0"}, {"line": "nontriviality R", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nh : IsUnit p\na\u271d : Nontrivial R\n\u22a2 p.natDegree = 0"}, {"line": "obtain \u27e8q, hq\u27e9 := h.exists_right_inv", "tactic_state": "case intro\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nh : IsUnit p\na\u271d : Nontrivial R\nq : Polynomial R\nhq : p * q = 1\n\u22a2 p.natDegree = 0"}, {"line": "have := natDegree_mul (left_ne_zero_of_mul_eq_one hq) (right_ne_zero_of_mul_eq_one hq)", "tactic_state": "case intro\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nh : IsUnit p\na\u271d : Nontrivial R\nq : Polynomial R\nhq : p * q = 1\nthis : (p * q).natDegree = p.natDegree + q.natDegree\n\u22a2 p.natDegree = 0"}, {"line": "rw [hq] at this", "tactic_state": "case intro\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nh : IsUnit p\na\u271d : Nontrivial R\nq : Polynomial R\nhq : p * q = 1\nthis : natDegree 1 = p.natDegree + q.natDegree\n\u22a2 p.natDegree = 0"}, {"line": "rw [natDegree_one] at this", "tactic_state": "case intro\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nh : IsUnit p\na\u271d : Nontrivial R\nq : Polynomial R\nhq : p * q = 1\nthis : 0 = p.natDegree + q.natDegree\n\u22a2 p.natDegree = 0"}, {"line": "rw [eq_comm] at this", "tactic_state": "case intro\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nh : IsUnit p\na\u271d : Nontrivial R\nq : Polynomial R\nhq : p * q = 1\nthis : p.natDegree + q.natDegree = 0\n\u22a2 p.natDegree = 0"}, {"line": "rw [add_eq_zero] at this", "tactic_state": "case intro\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nh : IsUnit p\na\u271d : Nontrivial R\nq : Polynomial R\nhq : p * q = 1\nthis : p.natDegree = 0 \u2227 q.natDegree = 0\n\u22a2 p.natDegree = 0"}, {"line": "exact this.1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardPowDegree_apply [DecidableEq Fq] (p : Fq[X]) :\n    cardPowDegree p = if p = 0 then 0 else (Fintype.card Fq : \u2124) ^ natDegree p := by\n  rw [cardPowDegree]\n  dsimp\n  convert rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/CardPowDegree.lean", "context": {"open": ["AbsoluteValue", "Polynomial"], "variables": ["{Fq : Type*} [Field Fq] [Fintype Fq]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Fq : Type u_1\ninst\u271d\u00b2 : Field Fq\ninst\u271d\u00b9 : Fintype Fq\ninst\u271d : DecidableEq Fq\np : Polynomial Fq\n\u22a2 cardPowDegree p = if p = 0 then 0 else \u2191(Fintype.card Fq) ^ p.natDegree"}, {"line": "rw [cardPowDegree]", "tactic_state": "Fq : Type u_1\ninst\u271d\u00b2 : Field Fq\ninst\u271d\u00b9 : Fintype Fq\ninst\u271d : DecidableEq Fq\np : Polynomial Fq\n\u22a2 { toFun := fun p => if p = 0 then 0 else \u2191(Fintype.card Fq) ^ p.natDegree, map_mul' := \u22ef, nonneg' := \u22ef, eq_zero' := \u22ef,\n        add_le' := \u22ef }\n      p =\n    if p = 0 then 0 else \u2191(Fintype.card Fq) ^ p.natDegree"}, {"line": "dsimp", "tactic_state": "Fq : Type u_1\ninst\u271d\u00b2 : Field Fq\ninst\u271d\u00b9 : Fintype Fq\ninst\u271d : DecidableEq Fq\np : Polynomial Fq\n\u22a2 (if p = 0 then 0 else \u2191(Fintype.card Fq) ^ p.natDegree) = if p = 0 then 0 else \u2191(Fintype.card Fq) ^ p.natDegree"}, {"line": "convert rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem degree_eq_iff_natDegree_eq_of_pos {p : R[X]} {n : \u2115} (hn : 0 < n) :\n    p.degree = n \u2194 p.natDegree = n := by\n  obtain rfl|h := eq_or_ne p 0\n  \u00b7 simp [hn.ne]\n  \u00b7 exact degree_eq_iff_natDegree_eq h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nhn : 0 < n\n\u22a2 p.degree = \u2191n \u2194 p.natDegree = n"}, {"line": "obtain rfl|h := eq_or_ne p 0", "tactic_state": "case inl\nR : Type u\ninst\u271d : Semiring R\nn : \u2115\nhn : 0 < n\n\u22a2 Polynomial.degree 0 = \u2191n \u2194 natDegree 0 = n\n---\ncase inr\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nhn : 0 < n\nh : p \u2260 0\n\u22a2 p.degree = \u2191n \u2194 p.natDegree = n"}, {"line": "\u00b7 simp [hn.ne]", "tactic_state": "case inr\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nhn : 0 < n\nh : p \u2260 0\n\u22a2 p.degree = \u2191n \u2194 p.natDegree = n"}, {"line": "\u00b7 exact degree_eq_iff_natDegree_eq h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_eq_of_degree_eq_some {p : R[X]} {n : \u2115} (h : degree p = n) : natDegree p = n := by\n  rw [natDegree]\n  rw [h]\n  rw [Nat.cast_withBot]\n  rw [WithBot.unbotD_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nh : p.degree = \u2191n\n\u22a2 p.natDegree = n"}, {"line": "rw [natDegree]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nh : p.degree = \u2191n\n\u22a2 WithBot.unbotD 0 p.degree = n"}, {"line": "rw [h]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nh : p.degree = \u2191n\n\u22a2 WithBot.unbotD 0 \u2191n = n"}, {"line": "rw [Nat.cast_withBot]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nh : p.degree = \u2191n\n\u22a2 WithBot.unbotD 0 \u2191n = n"}, {"line": "rw [WithBot.unbotD_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_degree_of_ne_zero (h : coeff p n \u2260 0) : (n : WithBot \u2115) \u2264 degree p := by\n  rw [Nat.cast_withBot]\n  exact Finset.le_sup (mem_support_iff.2 h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nn : \u2115\ninst\u271d : Semiring R\np : Polynomial R\nh : p.coeff n \u2260 0\n\u22a2 \u2191n \u2264 p.degree"}, {"line": "rw [Nat.cast_withBot]", "tactic_state": "R : Type u\nn : \u2115\ninst\u271d : Semiring R\np : Polynomial R\nh : p.coeff n \u2260 0\n\u22a2 \u2191n \u2264 p.degree"}, {"line": "exact Finset.le_sup (mem_support_iff.2 h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_natCast (n : \u2115) : natDegree (n : R[X]) = 0 := by\n  simp only [\u2190 C_eq_natCast]\n  simp only [natDegree_C]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 (\u2191n).natDegree = 0"}, {"line": "simp only [\u2190 C_eq_natCast]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 (C \u2191n).natDegree = 0"}, {"line": "simp only [natDegree_C]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem degree_C_mul_X (ha : a \u2260 0) : degree (C a * X) = 1 := by\n  simpa only [pow_one] using degree_C_mul_X_pow 1 ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\na : R\ninst\u271d : Semiring R\nha : a \u2260 0\n\u22a2 (C a * X).degree = 1"}, {"line": "simpa only [pow_one] using degree_C_mul_X_pow 1 ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem degree_C_mul_X_le (a : R) : degree (C a * X) \u2264 1 := by\n  simpa only [pow_one] using degree_C_mul_X_pow_le 1 a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\n\u22a2 (C a * X).degree \u2264 1"}, {"line": "simpa only [pow_one] using degree_C_mul_X_pow_le 1 a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_C_mul_X (a : R) (ha : a \u2260 0) : natDegree (C a * X) = 1 := by\n  simpa only [pow_one] using natDegree_C_mul_X_pow 1 a ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\nha : a \u2260 0\n\u22a2 (C a * X).natDegree = 1"}, {"line": "simpa only [pow_one] using natDegree_C_mul_X_pow 1 a ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_monomial [DecidableEq R] (i : \u2115) (r : R) :\n    natDegree (monomial i r) = if r = 0 then 0 else i := by\n  split_ifs with hr\n  \u00b7 simp [hr]\n  \u00b7 rw [\u2190 C_mul_X_pow_eq_monomial, natDegree_C_mul_X_pow i r hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : DecidableEq R\ni : \u2115\nr : R\n\u22a2 ((monomial i) r).natDegree = if r = 0 then 0 else i"}, {"line": "split_ifs with hr", "tactic_state": "case pos\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : DecidableEq R\ni : \u2115\nr : R\nhr : r = 0\n\u22a2 ((monomial i) r).natDegree = 0\n---\ncase neg\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : DecidableEq R\ni : \u2115\nr : R\nhr : \u00acr = 0\n\u22a2 ((monomial i) r).natDegree = i"}, {"line": "\u00b7 simp [hr]", "tactic_state": "case neg\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : DecidableEq R\ni : \u2115\nr : R\nhr : \u00acr = 0\n\u22a2 ((monomial i) r).natDegree = i"}, {"line": "\u00b7 rw [\u2190 C_mul_X_pow_eq_monomial, natDegree_C_mul_X_pow i r hr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem degree_X_pow_le (n : \u2115) : degree (X ^ n : R[X]) \u2264 n := by\n  simpa only [C_1, one_mul] using degree_C_mul_X_pow_le n (1 : R)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 (X ^ n).degree \u2264 \u2191n"}, {"line": "simpa only [C_1, one_mul] using degree_C_mul_X_pow_le n (1 : R)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nextCoeff_ne_zero : p.nextCoeff \u2260 0 \u2194 p.natDegree \u2260 0 \u2227 p.coeff (p.natDegree - 1) \u2260 0 := by\n  simp [nextCoeff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring R] [Nontrivial R] {p q : R[X]}", "[Ring R]", "[Semiring R] {p : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 p.nextCoeff \u2260 0 \u2194 p.natDegree \u2260 0 \u2227 p.coeff (p.natDegree - 1) \u2260 0"}, {"line": "simp [nextCoeff]", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 \u00ac(if p.natDegree = 0 then 0 else p.coeff (p.natDegree - 1)) = 0 \u2194 \u00acp.natDegree = 0 \u2227 \u00acp.coeff (p.natDegree - 1) = 0"}]}
{"declaration": "theorem nextCoeff_C_eq_zero (c : R) : nextCoeff (C c) = 0 := by\n  rw [nextCoeff]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring R] [Nontrivial R] {p q : R[X]}", "[Ring R]", "[Semiring R] {p : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\nc : R\n\u22a2 (C c).nextCoeff = 0"}, {"line": "rw [nextCoeff]", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\nc : R\n\u22a2 (if (C c).natDegree = 0 then 0 else (C c).coeff ((C c).natDegree - 1)) = 0"}, {"line": "simp", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\nc : R\n\u22a2 0 = 0"}]}
{"declaration": "theorem nextCoeff_of_natDegree_pos (hp : 0 < p.natDegree) :\n    nextCoeff p = p.coeff (p.natDegree - 1) := by\n  rw [nextCoeff]\n  rw [if_neg]\n  contrapose! hp\n  simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring R] [Nontrivial R] {p q : R[X]}", "[Ring R]", "[Semiring R] {p : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\np : Polynomial R\nhp : 0 < p.natDegree\n\u22a2 p.nextCoeff = p.coeff (p.natDegree - 1)"}, {"line": "rw [nextCoeff]", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\np : Polynomial R\nhp : 0 < p.natDegree\n\u22a2 (if p.natDegree = 0 then 0 else p.coeff (p.natDegree - 1)) = p.coeff (p.natDegree - 1)"}, {"line": "rw [if_neg]", "tactic_state": "case hnc\nR : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\np : Polynomial R\nhp : 0 < p.natDegree\n\u22a2 \u00acp.natDegree = 0"}, {"line": "contrapose! hp", "tactic_state": "case hnc\nR : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\np : Polynomial R\nhp : p.natDegree = 0\n\u22a2 p.natDegree \u2264 0"}, {"line": "simpa", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_add_le (p q : R[X]) : natDegree (p + q) \u2264 max (natDegree p) (natDegree q) := by\n  rcases le_max_iff.1 (degree_add_le p q) with h | h <;> simp [natDegree_le_natDegree h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring R] [Nontrivial R] {p q : R[X]}", "[Ring R]", "[Semiring R] {p : R[X]}", "{p q : R[X]} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\np q : Polynomial R\n\u22a2 (p + q).natDegree \u2264 max p.natDegree q.natDegree"}, {"line": "rcases le_max_iff.1 (degree_add_le p q) with h | h <;> simp [natDegree_le_natDegree h]", "tactic_state": "case inl\nR : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\np q : Polynomial R\nh : (p + q).degree \u2264 p.degree\n\u22a2 (p + q).natDegree \u2264 p.natDegree \u2228 (p + q).natDegree \u2264 q.natDegree\n---\ncase inr\nR : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\np q : Polynomial R\nh : (p + q).degree \u2264 q.degree\n\u22a2 (p + q).natDegree \u2264 p.natDegree \u2228 (p + q).natDegree \u2264 q.natDegree"}]}
{"declaration": "theorem leadingCoeff_C_mul_X_pow (a : R) (n : \u2115) : leadingCoeff (C a * X ^ n) = a := by\n  rw [C_mul_X_pow_eq_monomial]\n  rw [leadingCoeff_monomial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring R] [Nontrivial R] {p q : R[X]}", "[Ring R]", "[Semiring R] {p : R[X]}", "{p q : R[X]} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\na : R\nn : \u2115\n\u22a2 (C a * X ^ n).leadingCoeff = a"}, {"line": "rw [C_mul_X_pow_eq_monomial]", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\na : R\nn : \u2115\n\u22a2 ((monomial n) a).leadingCoeff = a"}, {"line": "rw [leadingCoeff_monomial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leadingCoeff_C_mul_X (a : R) : leadingCoeff (C a * X) = a := by\n  simpa only [pow_one] using leadingCoeff_C_mul_X_pow a 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring R] [Nontrivial R] {p q : R[X]}", "[Ring R]", "[Semiring R] {p : R[X]}", "{p q : R[X]} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\na : R\n\u22a2 (C a * X).leadingCoeff = a"}, {"line": "simpa only [pow_one] using leadingCoeff_C_mul_X_pow a 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leadingCoeff_X_pow (n : \u2115) : leadingCoeff ((X : R[X]) ^ n) = 1 := by\n  simpa only [C_1, one_mul] using leadingCoeff_C_mul_X_pow (1 : R) n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring R] [Nontrivial R] {p q : R[X]}", "[Ring R]", "[Semiring R] {p : R[X]}", "{p q : R[X]} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 (X ^ n).leadingCoeff = 1"}, {"line": "simpa only [C_1, one_mul] using leadingCoeff_C_mul_X_pow (1 : R) n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leadingCoeff_X : leadingCoeff (X : R[X]) = 1 := by\n  simpa only [pow_one] using @leadingCoeff_X_pow R _ 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring R] [Nontrivial R] {p q : R[X]}", "[Ring R]", "[Semiring R] {p : R[X]}", "{p q : R[X]} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\n\u22a2 X.leadingCoeff = 1"}, {"line": "simpa only [pow_one] using @leadingCoeff_X_pow R _ 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Monic.ne_zero {R : Type*} [Semiring R] [Nontrivial R] {p : R[X]} (hp : p.Monic) :\n    p \u2260 0 := by\n  rintro rfl\n  simp [Monic] at hp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring R] [Nontrivial R] {p q : R[X]}", "[Ring R]", "[Semiring R] {p : R[X]}", "{p q : R[X]} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\np : Polynomial R\nhp : p.Monic\n\u22a2 p \u2260 0"}, {"line": "rintro rfl", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\nhp : Monic 0\n\u22a2 False"}, {"line": "simp [Monic] at hp", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\nhp : 0 = 1\n\u22a2 False"}]}
{"declaration": "theorem Monic.ne_zero_of_ne (h : (0 : R) \u2260 1) {p : R[X]} (hp : p.Monic) : p \u2260 0 := by\n  nontriviality R\n  exact hp.ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring R] [Nontrivial R] {p q : R[X]}", "[Ring R]", "[Semiring R] {p : R[X]}", "{p q : R[X]} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\nh : 0 \u2260 1\np : Polynomial R\nhp : p.Monic\n\u22a2 p \u2260 0"}, {"line": "nontriviality R", "tactic_state": "R : Type u\ninst\u271d\u2075 inst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Semiring R\nh : 0 \u2260 1\np : Polynomial R\nhp : p.Monic\ninst\u271d : Nontrivial R\n\u22a2 p \u2260 0"}, {"line": "exact hp.ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_eq_zero_iff_degree_le_zero : p.natDegree = 0 \u2194 p.degree \u2264 0 := by\n  rw [\u2190 nonpos_iff_eq_zero]\n  rw [natDegree_le_iff_degree_le]\n  rw [Nat.cast_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Definitions.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring R] [Nontrivial R] {p q : R[X]}", "[Ring R]", "[Semiring R] {p : R[X]}", "{p q : R[X]} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 p.natDegree = 0 \u2194 p.degree \u2264 0"}, {"line": "rw [\u2190 nonpos_iff_eq_zero]", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 p.natDegree \u2264 0 \u2194 p.degree \u2264 0"}, {"line": "rw [natDegree_le_iff_degree_le]", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 p.degree \u2264 \u21910 \u2194 p.degree \u2264 0"}, {"line": "rw [Nat.cast_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_zero_of_dvd_of_degree_lt (h\u2081 : p \u2223 q) (h\u2082 : degree q < degree p) : q = 0 := by\n  by_contra hc\n  exact (lt_iff_not_ge _ _).mp h\u2082 (degree_le_of_dvd h\u2081 hc)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Domain.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [NoZeroDivisors R] {p q : R[X]}", "(p) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np q : Polynomial R\nh\u2081 : p \u2223 q\nh\u2082 : q.degree < p.degree\n\u22a2 q = 0"}, {"line": "by_contra hc", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np q : Polynomial R\nh\u2081 : p \u2223 q\nh\u2082 : q.degree < p.degree\nhc : \u00acq = 0\n\u22a2 False"}, {"line": "exact (lt_iff_not_ge _ _).mp h\u2082 (degree_le_of_dvd h\u2081 hc)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_zero_of_dvd_of_natDegree_lt (h\u2081 : p \u2223 q) (h\u2082 : natDegree q < natDegree p) :\n    q = 0 := by\n  by_contra hc\n  exact (lt_iff_not_ge _ _).mp h\u2082 (natDegree_le_of_dvd h\u2081 hc)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Domain.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [NoZeroDivisors R] {p q : R[X]}", "(p) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np q : Polynomial R\nh\u2081 : p \u2223 q\nh\u2082 : q.natDegree < p.natDegree\n\u22a2 q = 0"}, {"line": "by_contra hc", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np q : Polynomial R\nh\u2081 : p \u2223 q\nh\u2082 : q.natDegree < p.natDegree\nhc : \u00acq = 0\n\u22a2 False"}, {"line": "exact (lt_iff_not_ge _ _).mp h\u2082 (natDegree_le_of_dvd h\u2081 hc)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_dvd_of_degree_lt (h0 : q \u2260 0) (hl : q.degree < p.degree) : \u00acp \u2223 q := by\n  by_contra hcontra\n  exact h0 (eq_zero_of_dvd_of_degree_lt hcontra hl)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Domain.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [NoZeroDivisors R] {p q : R[X]}", "(p) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np q : Polynomial R\nh0 : q \u2260 0\nhl : q.degree < p.degree\n\u22a2 \u00acp \u2223 q"}, {"line": "by_contra hcontra", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np q : Polynomial R\nh0 : q \u2260 0\nhl : q.degree < p.degree\nhcontra : p \u2223 q\n\u22a2 False"}, {"line": "exact h0 (eq_zero_of_dvd_of_degree_lt hcontra hl)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_dvd_of_natDegree_lt (h0 : q \u2260 0) (hl : q.natDegree < p.natDegree) :\n    \u00acp \u2223 q := by\n  by_contra hcontra\n  exact h0 (eq_zero_of_dvd_of_natDegree_lt hcontra hl)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Domain.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [NoZeroDivisors R] {p q : R[X]}", "(p) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np q : Polynomial R\nh0 : q \u2260 0\nhl : q.natDegree < p.natDegree\n\u22a2 \u00acp \u2223 q"}, {"line": "by_contra hcontra", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np q : Polynomial R\nh0 : q \u2260 0\nhl : q.natDegree < p.natDegree\nhcontra : p \u2223 q\n\u22a2 False"}, {"line": "exact h0 (eq_zero_of_dvd_of_natDegree_lt hcontra hl)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_le_iff_coeff_eq_zero : p.natDegree \u2264 n \u2194 \u2200 N : \u2115, n < N \u2192 p.coeff N = 0 := by\n  simp_rw [natDegree_le_iff_degree_le, degree_le_iff_coeff_zero, Nat.cast_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Lemmas.lean", "context": {"open": ["Polynomial", "Finsupp Finset"], "variables": ["{R : Type u} {S : Type v} {\u03b9 : Type w} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nn : \u2115\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 p.natDegree \u2264 n \u2194 \u2200 (N : \u2115), n < N \u2192 p.coeff N = 0"}, {"line": "simp_rw [natDegree_le_iff_degree_le, degree_le_iff_coeff_zero, Nat.cast_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_add_le_iff_right {n : \u2115} (p q : R[X]) (pn : p.natDegree \u2264 n) :\n    (p + q).natDegree \u2264 n \u2194 q.natDegree \u2264 n := by\n  rw [add_comm]\n  exact natDegree_add_le_iff_left _ _ pn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Lemmas.lean", "context": {"open": ["Polynomial", "Finsupp Finset"], "variables": ["{R : Type u} {S : Type v} {\u03b9 : Type w} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\np q : Polynomial R\npn : p.natDegree \u2264 n\n\u22a2 (p + q).natDegree \u2264 n \u2194 q.natDegree \u2264 n"}, {"line": "rw [add_comm]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\np q : Polynomial R\npn : p.natDegree \u2264 n\n\u22a2 (q + p).natDegree \u2264 n \u2194 q.natDegree \u2264 n"}, {"line": "exact natDegree_add_le_iff_left _ _ pn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_C_mul_le (a : R) (f : R[X]) : (C a * f).natDegree \u2264 f.natDegree := by\n  simpa using natDegree_mul_le (p := C a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Lemmas.lean", "context": {"open": ["Polynomial", "Finsupp Finset"], "variables": ["{R : Type u} {S : Type v} {\u03b9 : Type w} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\na : R\nf : Polynomial R\n\u22a2 (C a * f).natDegree \u2264 f.natDegree"}, {"line": "simpa using natDegree_mul_le (p := C a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_mul_C_le (f : R[X]) (a : R) : (f * C a).natDegree \u2264 f.natDegree := by\n  simpa using natDegree_mul_le (q := C a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Lemmas.lean", "context": {"open": ["Polynomial", "Finsupp Finset"], "variables": ["{R : Type u} {S : Type v} {\u03b9 : Type w} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nf : Polynomial R\na : R\n\u22a2 (f * C a).natDegree \u2264 f.natDegree"}, {"line": "simpa using natDegree_mul_le (q := C a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_add_coeff_mul (f g : R[X]) :\n    (f * g).coeff (f.natDegree + g.natDegree) = f.coeff f.natDegree * g.coeff g.natDegree := by\n  simp only [coeff_natDegree]\n  simp only [coeff_mul_degree_add_degree]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Lemmas.lean", "context": {"open": ["Polynomial", "Finsupp Finset"], "variables": ["{R : Type u} {S : Type v} {\u03b9 : Type w} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nf g : Polynomial R\n\u22a2 (f * g).coeff (f.natDegree + g.natDegree) = f.coeff f.natDegree * g.coeff g.natDegree"}, {"line": "simp only [coeff_natDegree]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nf g : Polynomial R\n\u22a2 (f * g).coeff (f.natDegree + g.natDegree) = f.leadingCoeff * g.leadingCoeff"}, {"line": "simp only [coeff_mul_degree_add_degree]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_pow_eq_ite_of_natDegree_le_of_le {o : \u2115}\n    (pn : natDegree p \u2264 n) (mno : m * n \u2264 o) :\n    coeff (p ^ m) o = if o = m * n then (coeff p n) ^ m else 0 := by\n  rcases eq_or_ne o (m * n) with rfl | h\n  \u00b7 simpa only [ite_true] using coeff_pow_of_natDegree_le pn\n  \u00b7 simpa only [h, ite_false] using coeff_eq_zero_of_natDegree_lt <|\n      lt_of_le_of_lt (natDegree_pow_le_of_le m pn) (lt_of_le_of_ne mno h.symm)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Lemmas.lean", "context": {"open": ["Polynomial", "Finsupp Finset"], "variables": ["{R : Type u} {S : Type v} {\u03b9 : Type w} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nm n : \u2115\ninst\u271d : Semiring R\np : Polynomial R\no : \u2115\npn : p.natDegree \u2264 n\nmno : m * n \u2264 o\n\u22a2 (p ^ m).coeff o = if o = m * n then p.coeff n ^ m else 0"}, {"line": "rcases eq_or_ne o (m * n) with rfl | h", "tactic_state": "case inl\nR : Type u\nm n : \u2115\ninst\u271d : Semiring R\np : Polynomial R\npn : p.natDegree \u2264 n\nmno : m * n \u2264 m * n\n\u22a2 (p ^ m).coeff (m * n) = if m * n = m * n then p.coeff n ^ m else 0\n---\ncase inr\nR : Type u\nm n : \u2115\ninst\u271d : Semiring R\np : Polynomial R\no : \u2115\npn : p.natDegree \u2264 n\nmno : m * n \u2264 o\nh : o \u2260 m * n\n\u22a2 (p ^ m).coeff o = if o = m * n then p.coeff n ^ m else 0"}, {"line": "\u00b7 simpa only [ite_true] using coeff_pow_of_natDegree_le pn", "tactic_state": "case inr\nR : Type u\nm n : \u2115\ninst\u271d : Semiring R\np : Polynomial R\no : \u2115\npn : p.natDegree \u2264 n\nmno : m * n \u2264 o\nh : o \u2260 m * n\n\u22a2 (p ^ m).coeff o = if o = m * n then p.coeff n ^ m else 0"}, {"line": "\u00b7 simpa only [h, ite_false] using coeff_eq_zero_of_natDegree_lt <|\n      lt_of_le_of_lt (natDegree_pow_le_of_le m pn) (lt_of_le_of_ne mno h.symm)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_add_eq_right_of_lt (pn : p.natDegree < n) : (p + q).coeff n = q.coeff n := by\n  rw [add_comm]\n  exact coeff_add_eq_left_of_lt pn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Lemmas.lean", "context": {"open": ["Polynomial", "Finsupp Finset"], "variables": ["{R : Type u} {S : Type v} {\u03b9 : Type w} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nn : \u2115\ninst\u271d : Semiring R\np q : Polynomial R\npn : p.natDegree < n\n\u22a2 (p + q).coeff n = q.coeff n"}, {"line": "rw [add_comm]", "tactic_state": "R : Type u\nn : \u2115\ninst\u271d : Semiring R\np q : Polynomial R\npn : p.natDegree < n\n\u22a2 (q + p).coeff n = q.coeff n"}, {"line": "exact coeff_add_eq_left_of_lt pn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_lt_degree {p : R[X]} {n : \u2115} : (n : WithBot \u2115) < degree p \u2194 n < natDegree p := by\n  by_cases h : p = 0\n  \u00b7 simp [h]\n  simp [degree_eq_natDegree h, Nat.cast_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Lemmas.lean", "context": {"open": ["Polynomial", "Finsupp Finset", "scoped Function -- required for scoped `on` notation"], "variables": ["{R : Type u} {S : Type v} {\u03b9 : Type w} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\n\u22a2 \u2191n < p.degree \u2194 n < p.natDegree"}, {"line": "by_cases h : p = 0", "tactic_state": "case pos\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nh : p = 0\n\u22a2 \u2191n < p.degree \u2194 n < p.natDegree\n---\ncase neg\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nh : \u00acp = 0\n\u22a2 \u2191n < p.degree \u2194 n < p.natDegree"}, {"line": "\u00b7 simp [h]", "tactic_state": "case neg\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nh : \u00acp = 0\n\u22a2 \u2191n < p.degree \u2194 n < p.natDegree"}, {"line": "simp [degree_eq_natDegree h, Nat.cast_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_map_eq_iff {f : R \u2192+* S} {p : Polynomial R} :\n    natDegree (map f p) = natDegree p \u2194 f (p.leadingCoeff) \u2260 0 \u2228 natDegree p = 0 := by\n  rcases eq_or_ne (natDegree p) 0 with h|h\n  \u00b7 simp_rw [h, ne_eq, or_true, iff_true, \u2190 Nat.le_zero, \u2190 h, natDegree_map_le]\n  have h2 : p \u2260 0 := by rintro rfl; simp at h\n  simp_all [natDegree, WithBot.unbotD_eq_unbotD_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Lemmas.lean", "context": {"open": ["Polynomial", "Finsupp Finset", "scoped Function -- required for scoped `on` notation"], "variables": ["{R : Type u} {S : Type v} {\u03b9 : Type w} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\np : Polynomial R\n\u22a2 (Polynomial.map f p).natDegree = p.natDegree \u2194 f p.leadingCoeff \u2260 0 \u2228 p.natDegree = 0"}, {"line": "rcases eq_or_ne (natDegree p) 0 with h|h", "tactic_state": "case inl\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\np : Polynomial R\nh : sorry = 0\n\u22a2 (Polynomial.map f p).natDegree = p.natDegree \u2194 f p.leadingCoeff \u2260 0 \u2228 p.natDegree = 0\n---\ncase inr\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\np : Polynomial R\nh : sorry \u2260 0\n\u22a2 (Polynomial.map f p).natDegree = p.natDegree \u2194 f p.leadingCoeff \u2260 0 \u2228 p.natDegree = 0"}, {"line": "\u00b7 simp_rw [h, ne_eq, or_true, iff_true, \u2190 Nat.le_zero, \u2190 h, natDegree_map_le]", "tactic_state": "case inr\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\np : Polynomial R\nh : sorry \u2260 0\n\u22a2 (Polynomial.map f p).natDegree = p.natDegree \u2194 f p.leadingCoeff \u2260 0 \u2228 p.natDegree = 0"}, {"line": "have h2 : p \u2260 0 := sorry", "tactic_state": "case inr\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\np : Polynomial R\nh : sorry \u2260 0\nh2 : p \u2260 0\n\u22a2 (Polynomial.map f p).natDegree = p.natDegree \u2194 f p.leadingCoeff \u2260 0 \u2228 p.natDegree = 0"}, {"line": "simp_all [natDegree, WithBot.unbotD_eq_unbotD_iff]", "tactic_state": "case inr\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\np : Polynomial R\nh : \u00acsorry () = 0\nh2 : \u00acp = 0\n\u22a2 \u00acf p.leadingCoeff = 0 \u2228 Polynomial.map f p = 0 \u2227 p.degree = 0 \u2194 \u00acf p.leadingCoeff = 0 \u2228 p.degree = 0"}]}
{"declaration": "theorem natDegree_pos_of_nextCoeff_ne_zero (h : p.nextCoeff \u2260 0) : 0 < p.natDegree := by\n  rw [nextCoeff] at h\n  by_cases hpz : p.natDegree = 0\n  \u00b7 simp_all only [ne_eq, zero_le, ite_true, not_true_eq_false]\n  \u00b7 apply Nat.zero_lt_of_ne_zero hpz\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Lemmas.lean", "context": {"open": ["Polynomial", "Finsupp Finset", "scoped Function -- required for scoped `on` notation"], "variables": ["{R : Type u} {S : Type v} {\u03b9 : Type w} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nh : p.nextCoeff \u2260 0\n\u22a2 0 < p.natDegree"}, {"line": "rw [nextCoeff] at h", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nh : (if p.natDegree = 0 then 0 else p.coeff (p.natDegree - 1)) \u2260 0\n\u22a2 0 < p.natDegree"}, {"line": "by_cases hpz : p.natDegree = 0", "tactic_state": "case pos\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nh : (if p.natDegree = 0 then 0 else p.coeff (p.natDegree - 1)) \u2260 0\nhpz : sorry = 0\n\u22a2 0 < p.natDegree\n---\ncase neg\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nh : (if p.natDegree = 0 then 0 else p.coeff (p.natDegree - 1)) \u2260 0\nhpz : \u00acsorry = 0\n\u22a2 0 < p.natDegree"}, {"line": "\u00b7 simp_all only [ne_eq, zero_le, ite_true, not_true_eq_false]", "tactic_state": "case neg\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nh : (if p.natDegree = 0 then 0 else p.coeff (p.natDegree - 1)) \u2260 0\nhpz : \u00acsorry = 0\n\u22a2 0 < p.natDegree"}, {"line": "\u00b7 apply Nat.zero_lt_of_ne_zero hpz", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nextCoeff_C_mul_X_add_C (ha : a \u2260 0) (c : R) : nextCoeff (C a * X + C c) = c := by\n  rw [nextCoeff_of_natDegree_pos] <;> simp [ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Lemmas.lean", "context": {"open": ["Polynomial", "Finsupp Finset", "scoped Function -- required for scoped `on` notation"], "variables": ["{R : Type u} {S : Type v} {\u03b9 : Type w} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "[Ring R] {p q : R[X]}", "[Semiring R] {p q : R[X]} {a : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\na : R\nha : a \u2260 0\nc : R\n\u22a2 (C a * X + C c).nextCoeff = c"}, {"line": "rw [nextCoeff_of_natDegree_pos] <;> simp [ha]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\na : R\nha : a \u2260 0\nc : R\n\u22a2 a * X.coeff ((C a * X).natDegree - 1) + (C c).coeff ((C a * X).natDegree - 1) = c\n---\nR : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\na : R\nha : a \u2260 0\nc : R\n\u22a2 0 < (C a * X).natDegree"}]}
{"declaration": "theorem natDegree_comp : natDegree (p.comp q) = natDegree p * natDegree q := by\n  by_cases q0 : q.natDegree = 0\n  \u00b7 rw [degree_le_zero_iff.mp (natDegree_eq_zero_iff_degree_le_zero.mp q0), comp_C, natDegree_C,\n      natDegree_C, mul_zero]\n  \u00b7 by_cases p0 : p = 0\n    \u00b7 simp only [p0, zero_comp, natDegree_zero, zero_mul]\n    \u00b7 simp only [Ne, mul_eq_zero, leadingCoeff_eq_zero, p0, natDegree_comp_eq_of_mul_ne_zero,\n        ne_zero_of_natDegree_gt (Nat.pos_of_ne_zero q0), not_false_eq_true, pow_ne_zero, or_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Lemmas.lean", "context": {"open": ["Polynomial", "Finsupp Finset", "scoped Function -- required for scoped `on` notation"], "variables": ["{R : Type u} {S : Type v} {\u03b9 : Type w} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "[Ring R] {p q : R[X]}", "[Semiring R] {p q : R[X]} {a : R}", "[NoZeroDivisors R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Semiring R\np q : Polynomial R\ninst\u271d : NoZeroDivisors R\n\u22a2 (p.comp q).natDegree = p.natDegree * q.natDegree"}, {"line": "by_cases q0 : q.natDegree = 0", "tactic_state": "case pos\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Semiring R\np q : Polynomial R\ninst\u271d : NoZeroDivisors R\nq0 : sorry = 0\n\u22a2 (p.comp q).natDegree = p.natDegree * q.natDegree\n---\ncase neg\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Semiring R\np q : Polynomial R\ninst\u271d : NoZeroDivisors R\nq0 : \u00acsorry = 0\n\u22a2 (p.comp q).natDegree = p.natDegree * q.natDegree"}, {"line": "\u00b7 rw [degree_le_zero_iff.mp (natDegree_eq_zero_iff_degree_le_zero.mp q0), comp_C, natDegree_C,\n      natDegree_C, mul_zero]", "tactic_state": "case neg\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Semiring R\np q : Polynomial R\ninst\u271d : NoZeroDivisors R\nq0 : \u00acsorry = 0\n\u22a2 (p.comp q).natDegree = p.natDegree * q.natDegree"}, {"line": "\u00b7 by_cases p0 : p = 0\n    \u00b7 simp only [p0, zero_comp, natDegree_zero, zero_mul]\n    \u00b7 simp only [Ne, mul_eq_zero, leadingCoeff_eq_zero, p0, natDegree_comp_eq_of_mul_ne_zero,\n        ne_zero_of_natDegree_gt (Nat.pos_of_ne_zero q0), not_false_eq_true, pow_ne_zero, or_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irreducible_mul_leadingCoeff_inv {p : K[X]} :\n    Irreducible (p * C (leadingCoeff p)\u207b\u00b9) \u2194 Irreducible p := by\n  by_cases hp0 : p = 0\n  \u00b7 simp [hp0]\n  exact irreducible_mul_isUnit\n    (isUnit_C.mpr (IsUnit.mk0 _ (inv_ne_zero (leadingCoeff_ne_zero.mpr hp0))))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Lemmas.lean", "context": {"open": ["Polynomial", "Finsupp Finset", "scoped Function -- required for scoped `on` notation"], "variables": ["{R : Type u} {S : Type v} {\u03b9 : Type w} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "[Ring R] {p q : R[X]}", "[Semiring R] {p q : R[X]} {a : R}", "[NoZeroDivisors R]", "{K : Type*} [DivisionRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : DivisionRing K\np : Polynomial K\n\u22a2 Irreducible (p * C p.leadingCoeff\u207b\u00b9) \u2194 Irreducible p"}, {"line": "by_cases hp0 : p = 0", "tactic_state": "case pos\nK : Type u_1\ninst\u271d : DivisionRing K\np : Polynomial K\nhp0 : p = 0\n\u22a2 Irreducible (p * C p.leadingCoeff\u207b\u00b9) \u2194 Irreducible p\n---\ncase neg\nK : Type u_1\ninst\u271d : DivisionRing K\np : Polynomial K\nhp0 : \u00acp = 0\n\u22a2 Irreducible (p * C p.leadingCoeff\u207b\u00b9) \u2194 Irreducible p"}, {"line": "\u00b7 simp [hp0]", "tactic_state": "case neg\nK : Type u_1\ninst\u271d : DivisionRing K\np : Polynomial K\nhp0 : \u00acp = 0\n\u22a2 Irreducible (p * C p.leadingCoeff\u207b\u00b9) \u2194 Irreducible p"}, {"line": "exact irreducible_mul_isUnit\n    (isUnit_C.mpr (IsUnit.mk0 _ (inv_ne_zero (leadingCoeff_ne_zero.mpr hp0))))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem degree_mul_leadingCoeff_self_inv (p : K[X]) :\n    degree (p * C (leadingCoeff p)\u207b\u00b9) = degree p := by\n  by_cases hp : p = 0\n  \u00b7 simp [hp]\n  exact degree_mul_leadingCoeff_inv _ hp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Lemmas.lean", "context": {"open": ["Polynomial", "Finsupp Finset", "scoped Function -- required for scoped `on` notation"], "variables": ["{R : Type u} {S : Type v} {\u03b9 : Type w} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "[Ring R] {p q : R[X]}", "[Semiring R] {p q : R[X]} {a : R}", "[NoZeroDivisors R]", "{K : Type*} [DivisionRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : DivisionRing K\np : Polynomial K\n\u22a2 (p * C p.leadingCoeff\u207b\u00b9).degree = p.degree"}, {"line": "by_cases hp : p = 0", "tactic_state": "case pos\nK : Type u_1\ninst\u271d : DivisionRing K\np : Polynomial K\nhp : p = 0\n\u22a2 (p * C p.leadingCoeff\u207b\u00b9).degree = p.degree\n---\ncase neg\nK : Type u_1\ninst\u271d : DivisionRing K\np : Polynomial K\nhp : \u00acp = 0\n\u22a2 (p * C p.leadingCoeff\u207b\u00b9).degree = p.degree"}, {"line": "\u00b7 simp [hp]", "tactic_state": "case neg\nK : Type u_1\ninst\u271d : DivisionRing K\np : Polynomial K\nhp : \u00acp = 0\n\u22a2 (p * C p.leadingCoeff\u207b\u00b9).degree = p.degree"}, {"line": "exact degree_mul_leadingCoeff_inv _ hp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_natDegree_of_ne_zero (h : coeff p n \u2260 0) : n \u2264 natDegree p := by\n  rw [\u2190 Nat.cast_le (\u03b1 := WithBot \u2115)]\n  rw [\u2190 degree_eq_natDegree]\n  \u00b7 exact le_degree_of_ne_zero h\n  \u00b7 rintro rfl\n    exact h rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Operations.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [Semiring S] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nn : \u2115\ninst\u271d : Semiring R\np : Polynomial R\nh : p.coeff n \u2260 0\n\u22a2 n \u2264 p.natDegree"}, {"line": "rw [\u2190 Nat.cast_le (\u03b1 := WithBot \u2115)]", "tactic_state": "R : Type u\nn : \u2115\ninst\u271d : Semiring R\np : Polynomial R\nh : p.coeff n \u2260 0\n\u22a2 \u2191n \u2264 \u2191p.natDegree"}, {"line": "rw [\u2190 degree_eq_natDegree]", "tactic_state": "R : Type u\nn : \u2115\ninst\u271d : Semiring R\np : Polynomial R\nh : p.coeff n \u2260 0\n\u22a2 \u2191n \u2264 p.degree\n---\nR : Type u\nn : \u2115\ninst\u271d : Semiring R\np : Polynomial R\nh : p.coeff n \u2260 0\n\u22a2 p \u2260 0"}, {"line": "\u00b7 exact le_degree_of_ne_zero h", "tactic_state": "R : Type u\nn : \u2115\ninst\u271d : Semiring R\np : Polynomial R\nh : p.coeff n \u2260 0\n\u22a2 p \u2260 0"}, {"line": "\u00b7 rintro rfl\n    exact h rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma natDegree_eq_natDegree {q : S[X]} (hpq : p.degree = q.degree) :\n    p.natDegree = q.natDegree := by simp [natDegree, hpq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Operations.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [Semiring S] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : Polynomial R\nq : Polynomial S\nhpq : p.degree = q.degree\n\u22a2 p.natDegree = q.natDegree"}, {"line": "simp [natDegree, hpq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ext_iff_natDegree_le {p q : R[X]} {n : \u2115} (hp : p.natDegree \u2264 n) (hq : q.natDegree \u2264 n) :\n    p = q \u2194 \u2200 i \u2264 n, p.coeff i = q.coeff i := by\n  refine Iff.trans Polynomial.ext_iff ?_\n  refine forall_congr' fun i => \u27e8fun h _ => h, fun h => ?_\u27e9\n  refine (le_or_lt i n).elim h fun k => ?_\n  exact\n    (coeff_eq_zero_of_natDegree_lt (hp.trans_lt k)).trans\n      (coeff_eq_zero_of_natDegree_lt (hq.trans_lt k)).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Operations.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [Semiring S] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nn : \u2115\nhp : p.natDegree \u2264 n\nhq : q.natDegree \u2264 n\n\u22a2 p = q \u2194 \u2200 i \u2264 n, p.coeff i = q.coeff i"}, {"line": "refine Iff.trans Polynomial.ext_iff ?_", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nn : \u2115\nhp : p.natDegree \u2264 n\nhq : q.natDegree \u2264 n\n\u22a2 (\u2200 (n : \u2115), p.coeff n = q.coeff n) \u2194 \u2200 i \u2264 n, p.coeff i = q.coeff i"}, {"line": "refine forall_congr' fun i => \u27e8fun h _ => h, fun h => ?_\u27e9", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nn : \u2115\nhp : p.natDegree \u2264 n\nhq : q.natDegree \u2264 n\ni : \u2115\nh : i \u2264 n \u2192 p.coeff i = q.coeff i\n\u22a2 p.coeff i = q.coeff i"}, {"line": "refine (le_or_lt i n).elim h fun k => ?_", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nn : \u2115\nhp : p.natDegree \u2264 n\nhq : q.natDegree \u2264 n\ni : \u2115\nh : i \u2264 n \u2192 p.coeff i = q.coeff i\nk : n < i\n\u22a2 p.coeff i = q.coeff i"}, {"line": "exact\n    (coeff_eq_zero_of_natDegree_lt (hp.trans_lt k)).trans\n      (coeff_eq_zero_of_natDegree_lt (hq.trans_lt k)).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ite_le_natDegree_coeff (p : R[X]) (n : \u2115) (I : Decidable (n < 1 + natDegree p)) :\n    @ite _ (n < 1 + natDegree p) I (coeff p n) 0 = coeff p n := by\n  split_ifs with h\n  \u00b7 rfl\n  \u00b7 exact (coeff_eq_zero_of_natDegree_lt (not_le.1 fun w => h (Nat.lt_one_add_iff.2 w))).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Operations.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [Semiring S] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nI : Decidable (n < 1 + p.natDegree)\n\u22a2 (if n < 1 + p.natDegree then p.coeff n else 0) = p.coeff n"}, {"line": "split_ifs with h", "tactic_state": "case pos\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nI : Decidable (n < 1 + p.natDegree)\nh : n < 1 + p.natDegree\n\u22a2 p.coeff n = p.coeff n\n---\ncase neg\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nI : Decidable (n < 1 + p.natDegree)\nh : \u00acn < 1 + p.natDegree\n\u22a2 0 = p.coeff n"}, {"line": "\u00b7 rfl", "tactic_state": "case neg\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nI : Decidable (n < 1 + p.natDegree)\nh : \u00acn < 1 + p.natDegree\n\u22a2 0 = p.coeff n"}, {"line": "\u00b7 exact (coeff_eq_zero_of_natDegree_lt (not_le.1 fun w => h (Nat.lt_one_add_iff.2 w))).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leadingCoeff_add_of_degree_lt' (h : degree q < degree p) :\n    leadingCoeff (p + q) = leadingCoeff p := by\n  rw [add_comm]\n  exact leadingCoeff_add_of_degree_lt h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Operations.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [Semiring S] {p q r : R[X]}", "[Ring R]", "[Semiring R] {p q : R[X]} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\np q : Polynomial R\nh : q.degree < p.degree\n\u22a2 (p + q).leadingCoeff = p.leadingCoeff"}, {"line": "rw [add_comm]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\np q : Polynomial R\nh : q.degree < p.degree\n\u22a2 (q + p).leadingCoeff = p.leadingCoeff"}, {"line": "exact leadingCoeff_add_of_degree_lt h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma natDegree_C_mul_of_isUnit (ha : IsUnit a) (p : R[X]) : (C a * p).natDegree = p.natDegree := by\n  simp [natDegree, degree_C_mul_of_isUnit ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Operations.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [Semiring S] {p q r : R[X]}", "[Ring R]", "[Semiring R] {p q : R[X]} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\na : R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\nha : IsUnit a\np : Polynomial R\n\u22a2 (C a * p).natDegree = p.natDegree"}, {"line": "simp [natDegree, degree_C_mul_of_isUnit ha]", "tactic_state": "R : Type u\na : R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\nha : IsUnit a\np : Polynomial R\n\u22a2 WithBot.unbotD 0 (C a * p).degree = WithBot.unbotD 0 p.degree"}]}
{"declaration": "lemma natDegree_mul_C_of_isUnit (ha : IsUnit a) (p : R[X]) : (p * C a).natDegree = p.natDegree := by\n  simp [natDegree, degree_mul_C_of_isUnit ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Operations.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [Semiring S] {p q r : R[X]}", "[Ring R]", "[Semiring R] {p q : R[X]} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\na : R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\nha : IsUnit a\np : Polynomial R\n\u22a2 (p * C a).natDegree = p.natDegree"}, {"line": "simp [natDegree, degree_mul_C_of_isUnit ha]", "tactic_state": "R : Type u\na : R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\nha : IsUnit a\np : Polynomial R\n\u22a2 WithBot.unbotD 0 (p * C a).degree = WithBot.unbotD 0 p.degree"}]}
{"declaration": "theorem degree_smul_le (a : R) (p : R[X]) : degree (a \u2022 p) \u2264 degree p := by\n  refine (degree_le_iff_coeff_zero _ _).2 fun m hm => ?_\n  rw [degree_lt_iff_coeff_zero] at hm\n  simp [hm m le_rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Operations.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [Semiring S] {p q r : R[X]}", "[Ring R]", "[Semiring R] {p q : R[X]} {\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\na : R\np : Polynomial R\n\u22a2 (a \u2022 p).degree \u2264 p.degree"}, {"line": "refine (degree_le_iff_coeff_zero _ _).2 fun m hm => ?_", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\na : R\np : Polynomial R\nm : \u2115\nhm : p.degree < \u2191m\n\u22a2 (a \u2022 p).coeff m = 0"}, {"line": "rw [degree_lt_iff_coeff_zero] at hm", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\na : R\np : Polynomial R\nm : \u2115\nhm : \u2200 (m_1 : \u2115), m \u2264 m_1 \u2192 p.coeff m_1 = 0\n\u22a2 (a \u2022 p).coeff m = 0"}, {"line": "simp [hm m le_rfl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_X_pow_le {R : Type*} [Semiring R] (n : \u2115) : (X ^ n : R[X]).natDegree \u2264 n := by\n  nontriviality R\n  rw [Polynomial.natDegree_X_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Operations.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [Semiring S] {p q r : R[X]}", "[Ring R]", "[Semiring R] {p q : R[X]} {\u03b9 : Type*}", "[Semiring R] [Nontrivial R] {p q : R[X]} (n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 (X ^ n).natDegree \u2264 n"}, {"line": "nontriviality R", "tactic_state": "R : Type u_2\ninst\u271d : Semiring R\nn : \u2115\na\u271d : Nontrivial R\n\u22a2 (X ^ n).natDegree \u2264 n"}, {"line": "rw [Polynomial.natDegree_X_pow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem degree_mul_X : degree (p * X) = degree p + 1 := by simp [monic_X.degree_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Operations.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [Semiring S] {p q r : R[X]}", "[Ring R]", "[Semiring R] {p q : R[X]} {\u03b9 : Type*}", "[Semiring R] [Nontrivial R] {p q : R[X]} (n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 inst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\np : Polynomial R\n\u22a2 (p * X).degree = p.degree + 1"}, {"line": "simp [monic_X.degree_mul]", "tactic_state": "R : Type u\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 inst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\np : Polynomial R\n\u22a2 p.degree + X.degree = p.degree + 1"}]}
{"declaration": "theorem degree_mul_X_pow : degree (p * X ^ n) = degree p + n := by simp [(monic_X_pow n).degree_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Operations.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [Semiring S] {p q r : R[X]}", "[Ring R]", "[Semiring R] {p q : R[X]} {\u03b9 : Type*}", "[Semiring R] [Nontrivial R] {p q : R[X]} (n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 inst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\np : Polynomial R\nn : \u2115\n\u22a2 (p * X ^ n).degree = p.degree + \u2191n"}, {"line": "simp [(monic_X_pow n).degree_mul]", "tactic_state": "R : Type u\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 inst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\np : Polynomial R\nn : \u2115\n\u22a2 p.degree + (X ^ n).degree = p.degree + \u2191n"}]}
{"declaration": "theorem nextCoeff_X_add_C [Semiring S] (c : S) : nextCoeff (X + C c) = c := by\n  nontriviality S\n  simp [nextCoeff_of_natDegree_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Operations.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [Semiring S] {p q r : R[X]}", "[Ring R]", "[Semiring R] {p q : R[X]} {\u03b9 : Type*}", "[Semiring R] [Nontrivial R] {p q : R[X]} (n : \u2115)", "[Ring R] {p q : R[X]}", "[Nontrivial R]", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type v\ninst\u271d\u00b9 inst\u271d : Semiring S\nc : S\n\u22a2 (X + C c).nextCoeff = c"}, {"line": "nontriviality S", "tactic_state": "S : Type v\ninst\u271d\u00b9 inst\u271d : Semiring S\nc : S\na\u271d : Nontrivial S\n\u22a2 (X + C c).nextCoeff = c"}, {"line": "simp [nextCoeff_of_natDegree_pos]", "tactic_state": "S : Type v\ninst\u271d\u00b9 inst\u271d : Semiring S\nc : S\na\u271d : Nontrivial S\n\u22a2 0 + c = c"}]}
{"declaration": "theorem natDegree_X_pow_add_C {n : \u2115} {r : R} : (X ^ n + C r).natDegree = n := by\n  by_cases hn : n = 0\n  \u00b7 rw [hn, pow_zero, \u2190 C_1, \u2190 RingHom.map_add, natDegree_C]\n  \u00b7 exact natDegree_eq_of_degree_eq_some (degree_X_pow_add_C (pos_iff_ne_zero.mpr hn) r)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Operations.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [Semiring S] {p q r : R[X]}", "[Ring R]", "[Semiring R] {p q : R[X]} {\u03b9 : Type*}", "[Semiring R] [Nontrivial R] {p q : R[X]} (n : \u2115)", "[Ring R] {p q : R[X]}", "[Nontrivial R]", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 inst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : Semiring R\nn : \u2115\nr : R\n\u22a2 (X ^ n + C r).natDegree = n"}, {"line": "by_cases hn : n = 0", "tactic_state": "case pos\nR : Type u\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 inst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : Semiring R\nn : \u2115\nr : R\nhn : n = 0\n\u22a2 (X ^ n + C r).natDegree = n\n---\ncase neg\nR : Type u\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 inst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : Semiring R\nn : \u2115\nr : R\nhn : \u00acn = 0\n\u22a2 (X ^ n + C r).natDegree = n"}, {"line": "\u00b7 rw [hn, pow_zero, \u2190 C_1, \u2190 RingHom.map_add, natDegree_C]", "tactic_state": "case neg\nR : Type u\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 inst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : Semiring R\nn : \u2115\nr : R\nhn : \u00acn = 0\n\u22a2 (X ^ n + C r).natDegree = n"}, {"line": "\u00b7 exact natDegree_eq_of_degree_eq_some (degree_X_pow_add_C (pos_iff_ne_zero.mpr hn) r)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leadingCoeff_pow_X_add_C (r : R) (i : \u2115) : leadingCoeff ((X + C r) ^ i) = 1 := by\n  nontriviality\n  rw [leadingCoeff_pow'] <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Operations.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [Semiring S] {p q r : R[X]}", "[Ring R]", "[Semiring R] {p q : R[X]} {\u03b9 : Type*}", "[Semiring R] [Nontrivial R] {p q : R[X]} (n : \u2115)", "[Ring R] {p q : R[X]}", "[Nontrivial R]", "[Semiring R]", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 inst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 inst\u271d : Semiring R\nr : R\ni : \u2115\n\u22a2 ((X + C r) ^ i).leadingCoeff = 1"}, {"line": "nontriviality", "tactic_state": "R : Type u\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 inst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Nontrivial R\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : Semiring R\nr : R\ni : \u2115\ninst\u271d : Nontrivial R\n\u22a2 ((X + C r) ^ i).leadingCoeff = 1"}, {"line": "rw [leadingCoeff_pow'] <;> simp", "tactic_state": "R : Type u\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 inst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Nontrivial R\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : Semiring R\nr : R\ni : \u2115\ninst\u271d : Nontrivial R\n\u22a2 1 ^ i = 1\n---\nR : Type u\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 inst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Nontrivial R\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : Semiring R\nr : R\ni : \u2115\ninst\u271d : Nontrivial R\n\u22a2 \u00ac1 ^ i = 0"}]}
{"declaration": "lemma leadingCoeff_mul (p q : R[X]) : leadingCoeff (p * q) = leadingCoeff p * leadingCoeff q := by\n  by_cases hp : p = 0\n  \u00b7 simp only [hp, zero_mul, leadingCoeff_zero]\n  \u00b7 by_cases hq : q = 0\n    \u00b7 simp only [hq, mul_zero, leadingCoeff_zero]\n    \u00b7 rw [leadingCoeff_mul']\n      exact mul_ne_zero (mt leadingCoeff_eq_zero.1 hp) (mt leadingCoeff_eq_zero.1 hq)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/Operations.lean", "context": {"open": ["Finsupp Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b c d : R} {n m : \u2115}", "[Semiring R] [Semiring S] {p q r : R[X]}", "[Ring R]", "[Semiring R] {p q : R[X]} {\u03b9 : Type*}", "[Semiring R] [Nontrivial R] {p q : R[X]} (n : \u2115)", "[Ring R] {p q : R[X]}", "[Nontrivial R]", "[Semiring R]", "[Semiring R]", "[NoZeroDivisors R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 inst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Nontrivial R\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np q : Polynomial R\n\u22a2 (p * q).leadingCoeff = p.leadingCoeff * q.leadingCoeff"}, {"line": "by_cases hp : p = 0", "tactic_state": "case pos\nR : Type u\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 inst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Nontrivial R\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np q : Polynomial R\nhp : p = 0\n\u22a2 (p * q).leadingCoeff = p.leadingCoeff * q.leadingCoeff\n---\ncase neg\nR : Type u\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 inst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Nontrivial R\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np q : Polynomial R\nhp : \u00acp = 0\n\u22a2 (p * q).leadingCoeff = p.leadingCoeff * q.leadingCoeff"}, {"line": "\u00b7 simp only [hp, zero_mul, leadingCoeff_zero]", "tactic_state": "case neg\nR : Type u\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 inst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Nontrivial R\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np q : Polynomial R\nhp : \u00acp = 0\n\u22a2 (p * q).leadingCoeff = p.leadingCoeff * q.leadingCoeff"}, {"line": "\u00b7 by_cases hq : q = 0\n    \u00b7 simp only [hq, mul_zero, leadingCoeff_zero]\n    \u00b7 rw [leadingCoeff_mul']\n      exact mul_ne_zero (mt leadingCoeff_eq_zero.1 hp) (mt leadingCoeff_eq_zero.1 hq)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem trailingDegree_eq_iff_natTrailingDegree_eq_of_pos {p : R[X]} {n : \u2115} (hn : n \u2260 0) :\n    p.trailingDegree = n \u2194 p.natTrailingDegree = n := by\n  rw [natTrailingDegree]\n  rw [ENat.toNat_eq_iff hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean", "context": {"open": ["Function Polynomial Finsupp Finset", "scoped Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nhn : n \u2260 0\n\u22a2 p.trailingDegree = \u2191n \u2194 p.natTrailingDegree = n"}, {"line": "rw [natTrailingDegree]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nhn : n \u2260 0\n\u22a2 p.trailingDegree = \u2191n \u2194 p.trailingDegree.toNat = n"}, {"line": "rw [ENat.toNat_eq_iff hn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natTrailingDegree_eq_of_trailingDegree_eq_some {p : R[X]} {n : \u2115}\n    (h : trailingDegree p = n) : natTrailingDegree p = n := by\n  simp [natTrailingDegree, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean", "context": {"open": ["Function Polynomial Finsupp Finset", "scoped Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\nh : p.trailingDegree = \u2191n\n\u22a2 p.natTrailingDegree = n"}, {"line": "simp [natTrailingDegree, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem trailingDegree_one_le : (0 : \u2115\u221e) \u2264 trailingDegree (1 : R[X]) := by\n  rw [\u2190 C_1]\n  exact le_trailingDegree_C\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean", "context": {"open": ["Function Polynomial Finsupp Finset", "scoped Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\n\u22a2 0 \u2264 trailingDegree 1"}, {"line": "rw [\u2190 C_1]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\n\u22a2 0 \u2264 (C 1).trailingDegree"}, {"line": "exact le_trailingDegree_C", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natTrailingDegree_natCast (n : \u2115) : natTrailingDegree (n : R[X]) = 0 := by\n  simp only [\u2190 C_eq_natCast]\n  simp only [natTrailingDegree_C]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean", "context": {"open": ["Function Polynomial Finsupp Finset", "scoped Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 (\u2191n).natTrailingDegree = 0"}, {"line": "simp only [\u2190 C_eq_natCast]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 (C \u2191n).natTrailingDegree = 0"}, {"line": "simp only [natTrailingDegree_C]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_trailingDegree_C_mul_X_pow (n : \u2115) (a : R) :\n    (n : \u2115\u221e) \u2264 trailingDegree (C a * X ^ n) := by\n  rw [C_mul_X_pow_eq_monomial]\n  exact le_trailingDegree_monomial\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean", "context": {"open": ["Function Polynomial Finsupp Finset", "scoped Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\na : R\n\u22a2 \u2191n \u2264 (C a * X ^ n).trailingDegree"}, {"line": "rw [C_mul_X_pow_eq_monomial]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\na : R\n\u22a2 \u2191n \u2264 ((monomial n) a).trailingDegree"}, {"line": "exact le_trailingDegree_monomial", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_trailingDegree_X_pow (n : \u2115) : (n : \u2115\u221e) \u2264 trailingDegree (X ^ n : R[X]) := by\n  simpa only [C_1, one_mul] using le_trailingDegree_C_mul_X_pow n (1 : R)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean", "context": {"open": ["Function Polynomial Finsupp Finset", "scoped Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 \u2191n \u2264 (X ^ n).trailingDegree"}, {"line": "simpa only [C_1, one_mul] using le_trailingDegree_C_mul_X_pow n (1 : R)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natTrailingDegree_eq_support_min' (h : p \u2260 0) :\n    natTrailingDegree p = p.support.min' (nonempty_support_iff.mpr h) := by\n  rw [natTrailingDegree]\n  rw [trailingDegree]\n  rw [\u2190 Finset.coe_min']\n  rw [ENat.some_eq_coe]\n  rw [ENat.toNat_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean", "context": {"open": ["Function Polynomial Finsupp Finset", "scoped Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nh : p \u2260 0\n\u22a2 p.natTrailingDegree = p.support.min' \u22ef"}, {"line": "rw [natTrailingDegree]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nh : p \u2260 0\n\u22a2 p.trailingDegree.toNat = p.support.min' \u22ef"}, {"line": "rw [trailingDegree]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nh : p \u2260 0\n\u22a2 ENat.toNat p.support.min = p.support.min' \u22ef"}, {"line": "rw [\u2190 Finset.coe_min']", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nh : p \u2260 0\n\u22a2 ENat.toNat \u2191(p.support.min' ?m.1193) = p.support.min' \u22ef\n---\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nh : p \u2260 0\n\u22a2 p.support.Nonempty"}, {"line": "rw [ENat.some_eq_coe]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nh : p \u2260 0\n\u22a2 ENat.toNat \u2191(p.support.min' ?m.1193) = p.support.min' \u22ef\n---\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nh : p \u2260 0\n\u22a2 p.support.Nonempty"}, {"line": "rw [ENat.toNat_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natTrailingDegree_le_natDegree (p : R[X]) : p.natTrailingDegree \u2264 p.natDegree := by\n  by_cases hp : p = 0\n  \u00b7 rw [hp, natDegree_zero, natTrailingDegree_zero]\n  \u00b7 exact le_natDegree_of_ne_zero (mt trailingCoeff_eq_zero.mp hp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean", "context": {"open": ["Function Polynomial Finsupp Finset", "scoped Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 p.natTrailingDegree \u2264 p.natDegree"}, {"line": "by_cases hp : p = 0", "tactic_state": "case pos\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhp : p = 0\n\u22a2 p.natTrailingDegree \u2264 p.natDegree\n---\ncase neg\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhp : \u00acp = 0\n\u22a2 p.natTrailingDegree \u2264 p.natDegree"}, {"line": "\u00b7 rw [hp, natDegree_zero, natTrailingDegree_zero]", "tactic_state": "case neg\nR : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhp : \u00acp = 0\n\u22a2 p.natTrailingDegree \u2264 p.natDegree"}, {"line": "\u00b7 exact le_natDegree_of_ne_zero (mt trailingCoeff_eq_zero.mp hp)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma trailingDegree_X_pow (n : \u2115) :\n    (X ^ n : R[X]).trailingDegree = n := by\n  rw [X_pow_eq_monomial]\n  rw [trailingDegree_monomial one_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean", "context": {"open": ["Function Polynomial Finsupp Finset", "scoped Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring R] [Nontrivial R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\nn : \u2115\n\u22a2 (X ^ n).trailingDegree = \u2191n"}, {"line": "rw [X_pow_eq_monomial]", "tactic_state": "R : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\nn : \u2115\n\u22a2 ((monomial n) 1).trailingDegree = \u2191n"}, {"line": "rw [trailingDegree_monomial one_ne_zero]", "tactic_state": "R : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\nn : \u2115\n\u22a2 NeZero 1"}]}
{"declaration": "lemma natTrailingDegree_X_pow (n : \u2115) :\n    (X ^ n : R[X]).natTrailingDegree = n := by\n  rw [X_pow_eq_monomial]\n  rw [natTrailingDegree_monomial one_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean", "context": {"open": ["Function Polynomial Finsupp Finset", "scoped Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring R] [Nontrivial R] {p q : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\nn : \u2115\n\u22a2 (X ^ n).natTrailingDegree = n"}, {"line": "rw [X_pow_eq_monomial]", "tactic_state": "R : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\nn : \u2115\n\u22a2 ((monomial n) 1).natTrailingDegree = n"}, {"line": "rw [natTrailingDegree_monomial one_ne_zero]", "tactic_state": "R : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\nn : \u2115\n\u22a2 NeZero 1"}]}
{"declaration": "theorem nextCoeffUp_C_eq_zero (c : R) : nextCoeffUp (C c) = 0 := by\n  rw [nextCoeffUp]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean", "context": {"open": ["Function Polynomial Finsupp Finset", "scoped Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring R] [Nontrivial R] {p q : R[X]}", "[Ring R]", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\nc : R\n\u22a2 (C c).nextCoeffUp = 0"}, {"line": "rw [nextCoeffUp]", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\nc : R\n\u22a2 (if (C c).natTrailingDegree = 0 then 0 else (C c).coeff ((C c).natTrailingDegree + 1)) = 0"}, {"line": "simp", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\nc : R\n\u22a2 0 = 0"}]}
{"declaration": "theorem nextCoeffUp_of_constantCoeff_eq_zero (p : R[X]) (hp : coeff p 0 = 0) :\n    nextCoeffUp p = p.coeff (p.natTrailingDegree + 1) := by\n  obtain rfl | hp\u2080 := eq_or_ne p 0\n  \u00b7 simp\n  \u00b7 rw [nextCoeffUp, if_neg (natTrailingDegree_ne_zero.2 \u27e8hp\u2080, hp\u27e9)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean", "context": {"open": ["Function Polynomial Finsupp Finset", "scoped Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {n m : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring R] [Nontrivial R] {p q : R[X]}", "[Ring R]", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\np : Polynomial R\nhp : p.coeff 0 = 0\n\u22a2 p.nextCoeffUp = p.coeff (p.natTrailingDegree + 1)"}, {"line": "obtain rfl | hp\u2080 := eq_or_ne p 0", "tactic_state": "case inl\nR : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\nhp : coeff 0 0 = 0\n\u22a2 nextCoeffUp 0 = coeff 0 (natTrailingDegree 0 + 1)\n---\ncase inr\nR : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\np : Polynomial R\nhp : p.coeff 0 = 0\nhp\u2080 : p \u2260 0\n\u22a2 p.nextCoeffUp = p.coeff (p.natTrailingDegree + 1)"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nR : Type u\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring R\np : Polynomial R\nhp : p.coeff 0 = 0\nhp\u2080 : p \u2260 0\n\u22a2 p.nextCoeffUp = p.coeff (p.natTrailingDegree + 1)"}, {"line": "\u00b7 rw [nextCoeffUp, if_neg (natTrailingDegree_ne_zero.2 \u27e8hp\u2080, hp\u27e9)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval\u2082_mul' :\n    (p * q).eval\u2082 (algebraMap R S) x = p.eval\u2082 (algebraMap R S) x * q.eval\u2082 (algebraMap R S) x := by\n  exact eval\u2082_mul_noncomm _ _ fun k => Algebra.commute_algebraMap_left (coeff q k) x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Algebra.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[CommSemiring R] [Semiring S] [Algebra R S] (x : S) (p q : R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Algebra R S\nx : S\np q : Polynomial R\n\u22a2 eval\u2082 (algebraMap R S) x (p * q) = eval\u2082 (algebraMap R S) x p * eval\u2082 (algebraMap R S) x q"}, {"line": "exact eval\u2082_mul_noncomm _ _ fun k => Algebra.commute_algebraMap_left (coeff q k) x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval\u2082_at_zero : p.eval\u2082 f 0 = f (coeff p 0) := by\n  simp +contextual only [eval\u2082_eq_sum, zero_pow_eq, mul_ite, mul_zero,\n    mul_one, sum, Classical.not_not, mem_support_iff, sum_ite_eq', ite_eq_left_iff,\n    RingHom.map_zero, imp_true_iff, eq_self_iff_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Coeff.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\np : Polynomial R\ninst\u271d : Semiring S\nf : R \u2192+* S\n\u22a2 eval\u2082 f 0 p = f (p.coeff 0)"}, {"line": "simp +contextual only [eval\u2082_eq_sum, zero_pow_eq, mul_ite, mul_zero,\n    mul_one, sum, Classical.not_not, mem_support_iff, sum_ite_eq', ite_eq_left_iff,\n    RingHom.map_zero, imp_true_iff, eq_self_iff_true]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\np : Polynomial R\ninst\u271d : Semiring S\nf : R \u2192+* S\n\u22a2 \u2211 x \u2208 p.support, f (p.coeff x) * 0 ^ x = f (p.coeff 0)"}]}
{"declaration": "theorem zero_isRoot_of_coeff_zero_eq_zero {p : R[X]} (hp : p.coeff 0 = 0) : IsRoot p 0 := by\n  rwa [coeff_zero_eq_eval_zero] at hp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Coeff.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nhp : p.coeff 0 = 0\n\u22a2 p.IsRoot 0"}, {"line": "rwa [coeff_zero_eq_eval_zero] at hp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_id : p.map (RingHom.id _) = p := by simp [Polynomial.ext_iff, coeff_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Coeff.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "{x : R}", "[Semiring S]", "(f : R \u2192+* S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 Polynomial.map (RingHom.id R) p = p"}, {"line": "simp [Polynomial.ext_iff, coeff_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_zero_map (f : R \u2192+* S) (p : R[X]) : (p.map f).eval 0 = f (p.eval 0) := by\n  simp [\u2190 coeff_zero_eq_eval_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Coeff.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "{x : R}", "[Semiring S]", "(f : R \u2192+* S)", "{f}", "(f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 inst\u271d : Semiring S\nf : R \u2192+* S\np : Polynomial R\n\u22a2 eval 0 (Polynomial.map f p) = f (eval 0 p)"}, {"line": "simp [\u2190 coeff_zero_eq_eval_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hom_eval\u2082 (x : S) : g (p.eval\u2082 f x) = p.eval\u2082 (g.comp f) (g x) := by\n  rw [\u2190 eval\u2082_map]\n  rw [eval\u2082_at_apply]\n  rw [eval_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Coeff.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "{x : R}", "[Semiring S]", "(f : R \u2192+* S)", "{f}", "(f)", "[Semiring S] [Semiring T] (f : R \u2192+* S) (g : S \u2192+* T) (p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : Semiring R\np : Polynomial R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Semiring S\ninst\u271d : Semiring T\nf : R \u2192+* S\ng : S \u2192+* T\nx : S\n\u22a2 g (eval\u2082 f x p) = eval\u2082 (g.comp f) (g x) p"}, {"line": "rw [\u2190 eval\u2082_map]", "tactic_state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : Semiring R\np : Polynomial R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Semiring S\ninst\u271d : Semiring T\nf : R \u2192+* S\ng : S \u2192+* T\nx : S\n\u22a2 g (eval\u2082 f x p) = eval\u2082 g (g x) (Polynomial.map f p)"}, {"line": "rw [eval\u2082_at_apply]", "tactic_state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : Semiring R\np : Polynomial R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Semiring S\ninst\u271d : Semiring T\nf : R \u2192+* S\ng : S \u2192+* T\nx : S\n\u22a2 g (eval\u2082 f x p) = g (eval x (Polynomial.map f p))"}, {"line": "rw [eval_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_map_subset [Semiring R] [Semiring S] (f : R \u2192+* S) (p : R[X]) :\n    (map f p).support \u2286 p.support := by\n  intro x\n  contrapose!\n  simp +contextual\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Coeff.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "{x : R}", "[Semiring S]", "(f : R \u2192+* S)", "{f}", "(f)", "[Semiring S] [Semiring T] (f : R \u2192+* S) (g : S \u2192+* T) (p)", "[Semiring R] {p q : R[X]} {x : R} [Semiring S] (f : R \u2192+* S)", "[CommSemiring R] {p q : R[X]} {x : R} [CommSemiring S] (f : R \u2192+* S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 : Semiring S\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Semiring S\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\np : Polynomial R\n\u22a2 (Polynomial.map f p).support \u2286 p.support"}, {"line": "intro x", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 : Semiring S\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Semiring S\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\np : Polynomial R\nx : \u2115\n\u22a2 x \u2208 (Polynomial.map f p).support \u2192 x \u2208 p.support"}, {"line": "contrapose!", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 : Semiring S\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Semiring S\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\np : Polynomial R\nx : \u2115\n\u22a2 x \u2209 p.support \u2192 x \u2209 (Polynomial.map f p).support"}, {"line": "simp +contextual", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_map_of_injective [Semiring R] [Semiring S] (p : R[X]) {f : R \u2192+* S}\n    (hf : Function.Injective f) : (map f p).support = p.support := by\n  simp_rw [Finset.ext_iff, mem_support_iff, coeff_map, \u2190 map_zero f, hf.ne_iff,\n    forall_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Coeff.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "{x : R}", "[Semiring S]", "(f : R \u2192+* S)", "{f}", "(f)", "[Semiring S] [Semiring T] (f : R \u2192+* S) (g : S \u2192+* T) (p)", "[Semiring R] {p q : R[X]} {x : R} [Semiring S] (f : R \u2192+* S)", "[CommSemiring R] {p q : R[X]} {x : R} [CommSemiring S] (f : R \u2192+* S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 inst\u271d\u2077 inst\u271d\u2076 : Semiring S\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Semiring S\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : Polynomial R\nf : R \u2192+* S\nhf : Function.Injective \u21d1f\n\u22a2 (Polynomial.map f p).support = p.support"}, {"line": "simp_rw [Finset.ext_iff, mem_support_iff, coeff_map, \u2190 map_zero f, hf.ne_iff,\n    forall_const]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma degree_map_le : degree (p.map f) \u2264 degree p := by\n  refine (degree_le_iff_coeff_zero _ _).2 fun m hm => ?_\n  rw [degree_lt_iff_coeff_zero] at hm\n  simp [hm m le_rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Degree.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S] (f : R \u2192+* S) (x : S)", "{x : R}", "[Semiring S] {f : R \u2192+* S} {p : R[X]}", "(f) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 inst\u271d : Semiring S\nf : R \u2192+* S\np : Polynomial R\n\u22a2 (Polynomial.map f p).degree \u2264 p.degree"}, {"line": "refine (degree_le_iff_coeff_zero _ _).2 fun m hm => ?_", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 inst\u271d : Semiring S\nf : R \u2192+* S\np : Polynomial R\nm : \u2115\nhm : p.degree < \u2191m\n\u22a2 (Polynomial.map f p).coeff m = 0"}, {"line": "rw [degree_lt_iff_coeff_zero] at hm", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 inst\u271d : Semiring S\nf : R \u2192+* S\np : Polynomial R\nm : \u2115\nhm : \u2200 (m_1 : \u2115), m \u2264 m_1 \u2192 p.coeff m_1 = 0\n\u22a2 (Polynomial.map f p).coeff m = 0"}, {"line": "simp [hm m le_rfl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval\u2082_eq_sum {f : R \u2192+* S} {x : S} : p.eval\u2082 f x = p.sum fun e a => f a * x ^ e := by\n  rw [eval\u2082_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\np : Polynomial R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\n\u22a2 eval\u2082 f x p = p.sum fun e a => f a * x ^ e"}, {"line": "rw [eval\u2082_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval\u2082_zero : (0 : R[X]).eval\u2082 f x = 0 := by simp [eval\u2082_eq_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\n\u22a2 eval\u2082 f x 0 = 0"}, {"line": "simp [eval\u2082_eq_sum]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval\u2082_C : (C a).eval\u2082 f x = f a := by simp [eval\u2082_eq_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\na : R\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\n\u22a2 eval\u2082 f x (C a) = f a"}, {"line": "simp [eval\u2082_eq_sum]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval\u2082_X : X.eval\u2082 f x = x := by simp [eval\u2082_eq_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\n\u22a2 eval\u2082 f x X = x"}, {"line": "simp [eval\u2082_eq_sum]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\n\u22a2 (X.sum fun e a => f a * x ^ e) = x"}]}
{"declaration": "theorem eval\u2082_monomial {n : \u2115} {r : R} : (monomial n r).eval\u2082 f x = f r * x ^ n := by\n  simp [eval\u2082_eq_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\nn : \u2115\nr : R\n\u22a2 eval\u2082 f x ((monomial n) r) = f r * x ^ n"}, {"line": "simp [eval\u2082_eq_sum]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\nn : \u2115\nr : R\n\u22a2 (((monomial n) r).sum fun e a => f a * x ^ e) = f r * x ^ n"}]}
{"declaration": "theorem eval\u2082_one : (1 : R[X]).eval\u2082 f x = 1 := by rw [\u2190 C_1, eval\u2082_C, f.map_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\n\u22a2 eval\u2082 f x 1 = 1"}, {"line": "rw [\u2190 C_1, eval\u2082_C, f.map_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eval\u2082_ofNat {S : Type*} [Semiring S] (n : \u2115) [n.AtLeastTwo] (f : R \u2192+* S) (a : S) :\n    (ofNat(n) : R[X]).eval\u2082 f a = ofNat(n) := by\n  simp [OfNat.ofNat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type u_1\ninst\u271d\u00b9 : Semiring S\nn : \u2115\ninst\u271d : n.AtLeastTwo\nf : R \u2192+* S\na : S\n\u22a2 eval\u2082 f a (OfNat.ofNat n) = OfNat.ofNat n"}, {"line": "simp [OfNat.ofNat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval\u2082_X_mul : eval\u2082 f x (X * p) = eval\u2082 f x p * x := by rw [X_mul, eval\u2082_mul_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\np : Polynomial R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\n\u22a2 eval\u2082 f x (X * p) = eval\u2082 f x p * x"}, {"line": "rw [X_mul, eval\u2082_mul_X]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval\u2082_mul_C' (h : Commute (f a) x) : eval\u2082 f x (p * C a) = eval\u2082 f x p * f a := by\n  rw [eval\u2082_mul_noncomm]\n  rw [eval\u2082_C]\n  intro k\n  by_cases hk : k = 0\n  \u00b7 simp only [hk, h, coeff_C_zero, coeff_C_ne_zero]\n  \u00b7 simp only [coeff_C_ne_zero hk, RingHom.map_zero, Commute.zero_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\na : R\ninst\u271d\u00b9 : Semiring R\np : Polynomial R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\nh : Commute (f a) x\n\u22a2 eval\u2082 f x (p * C a) = eval\u2082 f x p * f a"}, {"line": "rw [eval\u2082_mul_noncomm]", "tactic_state": "R : Type u\nS : Type v\na : R\ninst\u271d\u00b9 : Semiring R\np : Polynomial R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\nh : Commute (f a) x\n\u22a2 eval\u2082 f x p * eval\u2082 f x (C a) = eval\u2082 f x p * f a\n---\ncase hf\nR : Type u\nS : Type v\na : R\ninst\u271d\u00b9 : Semiring R\np : Polynomial R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\nh : Commute (f a) x\n\u22a2 \u2200 (k : \u2115), Commute (f ((C a).coeff k)) x"}, {"line": "rw [eval\u2082_C]", "tactic_state": "case hf\nR : Type u\nS : Type v\na : R\ninst\u271d\u00b9 : Semiring R\np : Polynomial R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\nh : Commute (f a) x\n\u22a2 \u2200 (k : \u2115), Commute (f ((C a).coeff k)) x"}, {"line": "intro k", "tactic_state": "case hf\nR : Type u\nS : Type v\na : R\ninst\u271d\u00b9 : Semiring R\np : Polynomial R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\nh : Commute (f a) x\nk : \u2115\n\u22a2 Commute (f ((C a).coeff k)) x"}, {"line": "by_cases hk : k = 0", "tactic_state": "case pos\nR : Type u\nS : Type v\na : R\ninst\u271d\u00b9 : Semiring R\np : Polynomial R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\nh : Commute (f a) x\nk : \u2115\nhk : k = 0\n\u22a2 Commute (f ((C a).coeff k)) x\n---\ncase neg\nR : Type u\nS : Type v\na : R\ninst\u271d\u00b9 : Semiring R\np : Polynomial R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\nh : Commute (f a) x\nk : \u2115\nhk : \u00ack = 0\n\u22a2 Commute (f ((C a).coeff k)) x"}, {"line": "\u00b7 simp only [hk, h, coeff_C_zero, coeff_C_ne_zero]", "tactic_state": "case neg\nR : Type u\nS : Type v\na : R\ninst\u271d\u00b9 : Semiring R\np : Polynomial R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\nh : Commute (f a) x\nk : \u2115\nhk : \u00ack = 0\n\u22a2 Commute (f ((C a).coeff k)) x"}, {"line": "\u00b7 simp only [coeff_C_ne_zero hk, RingHom.map_zero, Commute.zero_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_eq_sum : p.eval x = p.sum fun e a => a * x ^ e := by\n  rw [eval]\n  rw [eval\u2082_eq_sum]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nx : R\n\u22a2 eval x p = p.sum fun e a => a * x ^ e"}, {"line": "rw [eval]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nx : R\n\u22a2 eval\u2082 (RingHom.id R) x p = p.sum fun e a => a * x ^ e"}, {"line": "rw [eval\u2082_eq_sum]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nx : R\n\u22a2 (p.sum fun e a => (RingHom.id R) a * x ^ e) = p.sum fun e a => a * x ^ e"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval\u2082_at_natCast {S : Type*} [Semiring S] (f : R \u2192+* S) (n : \u2115) :\n    p.eval\u2082 f n = f (p.eval n) := by\n  convert eval\u2082_at_apply (p := p) f n\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Semiring R\np : Polynomial R\nS : Type u_1\ninst\u271d : Semiring S\nf : R \u2192+* S\nn : \u2115\n\u22a2 eval\u2082 f (\u2191n) p = f (eval (\u2191n) p)"}, {"line": "convert eval\u2082_at_apply (p := p) f n", "tactic_state": "case h.e'_2.h.e'_6\nR : Type u\ninst\u271d\u00b9 : Semiring R\np : Polynomial R\nS : Type u_1\ninst\u271d : Semiring S\nf : R \u2192+* S\nn : \u2115\n\u22a2 \u2191n = f sorry\n---\ncase h.e'_3.h.e'_6.h.e'_3\nR : Type u\ninst\u271d\u00b9 : Semiring R\np : Polynomial R\nS : Type u_1\ninst\u271d : Semiring S\nf : R \u2192+* S\nn : \u2115\n\u22a2 \u2191n = sorry"}, {"line": "simp", "tactic_state": "case h.e'_2.h.e'_6\nR : Type u\ninst\u271d\u00b9 : Semiring R\np : Polynomial R\nS : Type u_1\ninst\u271d : Semiring S\nf : R \u2192+* S\nn : \u2115\n\u22a2 \u2191n = f (sorry ())\n---\ncase h.e'_3.h.e'_6.h.e'_3\nR : Type u\ninst\u271d\u00b9 : Semiring R\np : Polynomial R\nS : Type u_1\ninst\u271d : Semiring S\nf : R \u2192+* S\nn : \u2115\n\u22a2 \u2191n = sorry"}]}
{"declaration": "theorem eval\u2082_at_ofNat {S : Type*} [Semiring S] (f : R \u2192+* S) (n : \u2115) [n.AtLeastTwo] :\n    p.eval\u2082 f ofNat(n) = f (p.eval (ofNat(n))) := by\n  simp [OfNat.ofNat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\np : Polynomial R\nS : Type u_1\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\nn : \u2115\ninst\u271d : n.AtLeastTwo\n\u22a2 eval\u2082 f (OfNat.ofNat n) p = f (eval (OfNat.ofNat n) p)"}, {"line": "simp [OfNat.ofNat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_natCast {n : \u2115} : (n : R[X]).eval x = n := by simp only [\u2190 C_eq_natCast, eval_C]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nx : R\nn : \u2115\n\u22a2 eval x \u2191n = \u2191n"}, {"line": "simp only [\u2190 C_eq_natCast, eval_C]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eval_ofNat (n : \u2115) [n.AtLeastTwo] (a : R) :\n    (ofNat(n) : R[X]).eval a = ofNat(n) := by\n  simp only [OfNat.ofNat]\n  simp only [eval_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Semiring R\nn : \u2115\ninst\u271d : n.AtLeastTwo\na : R\n\u22a2 eval a (OfNat.ofNat n) = OfNat.ofNat n"}, {"line": "simp only [OfNat.ofNat]", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Semiring R\nn : \u2115\ninst\u271d : n.AtLeastTwo\na : R\n\u22a2 eval a \u2191n = \u2191n"}, {"line": "simp only [eval_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_natCast_mul {n : \u2115} : ((n : R[X]) * p).eval x = n * p.eval x := by\n  rw [\u2190 C_eq_natCast]\n  rw [eval_C_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nx : R\nn : \u2115\n\u22a2 eval x (\u2191n * p) = \u2191n * eval x p"}, {"line": "rw [\u2190 C_eq_natCast]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nx : R\nn : \u2115\n\u22a2 eval x (C \u2191n * p) = \u2191n * eval x p"}, {"line": "rw [eval_C_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_isRoot_C (r a : R) (hr : r \u2260 0) : \u00acIsRoot (C r) a := by simpa using hr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nr a : R\nhr : r \u2260 0\n\u22a2 \u00ac(C r).IsRoot a"}, {"line": "simpa using hr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_eq_sum_left : p.comp q = p.sum fun e a => C a * q ^ e := by rw [comp, eval\u2082_eq_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\n\u22a2 p.comp q = p.sum fun e a => C a * q ^ e"}, {"line": "rw [comp, eval\u2082_eq_sum]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_X : p.comp X = p := by\n  simp only [comp]\n  simp only [eval\u2082_def]\n  simp only [C_mul_X_pow_eq_monomial]\n  exact sum_monomial_eq _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 p.comp X = p"}, {"line": "simp only [comp]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 eval\u2082 C X p = p"}, {"line": "simp only [eval\u2082_def]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 (p.sum fun e a => C a * X ^ e) = p"}, {"line": "simp only [C_mul_X_pow_eq_monomial]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 (p.sum fun e a => (monomial e) a) = p"}, {"line": "exact sum_monomial_eq _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_C : p.comp (C a) = C (p.eval a) := by simp [comp, map_sum (C : R \u2192+* _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\na : R\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 p.comp (C a) = C (eval a p)"}, {"line": "simp [comp, map_sum (C : R \u2192+* _)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_comp {n : \u2115} : (n : R[X]).comp p = n := by rw [\u2190 C_eq_natCast, C_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\nn : \u2115\n\u22a2 (\u2191n).comp p = \u2191n"}, {"line": "rw [\u2190 C_eq_natCast, C_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_zero : p.comp (0 : R[X]) = C (p.eval 0) := by rw [\u2190 C_0, comp_C]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 p.comp 0 = C (eval 0 p)"}, {"line": "rw [\u2190 C_0, comp_C]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_comp : comp (0 : R[X]) p = 0 := by rw [\u2190 C_0, C_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 comp 0 p = 0"}, {"line": "rw [\u2190 C_0, C_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_one : p.comp 1 = C (p.eval 1) := by rw [\u2190 C_1, comp_C]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 p.comp 1 = C (eval 1 p)"}, {"line": "rw [\u2190 C_1, comp_C]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_comp : comp (1 : R[X]) p = 1 := by rw [\u2190 C_1, C_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 comp 1 p = 1"}, {"line": "rw [\u2190 C_1, C_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_mul_comp {n : \u2115} : ((n : R[X]) * p).comp r = n * p.comp r := by\n  rw [\u2190 C_eq_natCast]\n  rw [C_mul_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np r : Polynomial R\nn : \u2115\n\u22a2 (\u2191n * p).comp r = \u2191n * p.comp r"}, {"line": "rw [\u2190 C_eq_natCast]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np r : Polynomial R\nn : \u2115\n\u22a2 (C \u2191n * p).comp r = C \u2191n * p.comp r"}, {"line": "rw [C_mul_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_X_add_natCast_comp {n : \u2115} :\n    (p * (X + (n : R[X]))).comp q = p.comp q * (q + n) := by\n  rw [mul_add]\n  rw [add_comp]\n  rw [mul_X_comp]\n  rw [\u2190 Nat.cast_comm]\n  rw [natCast_mul_comp]\n  rw [Nat.cast_comm]\n  rw [mul_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nn : \u2115\n\u22a2 (p * (X + \u2191n)).comp q = p.comp q * (q + \u2191n)"}, {"line": "rw [mul_add]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nn : \u2115\n\u22a2 (p * X + p * \u2191n).comp q = p.comp q * (q + \u2191n)"}, {"line": "rw [add_comp]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nn : \u2115\n\u22a2 (p * X).comp q + (p * \u2191n).comp q = p.comp q * (q + \u2191n)"}, {"line": "rw [mul_X_comp]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nn : \u2115\n\u22a2 p.comp q * q + (p * \u2191n).comp q = p.comp q * (q + \u2191n)"}, {"line": "rw [\u2190 Nat.cast_comm]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nn : \u2115\n\u22a2 p.comp q * q + (\u2191n * p).comp q = p.comp q * (q + \u2191n)"}, {"line": "rw [natCast_mul_comp]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nn : \u2115\n\u22a2 p.comp q * q + \u2191n * p.comp q = p.comp q * (q + \u2191n)"}, {"line": "rw [Nat.cast_comm]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np q : Polynomial R\nn : \u2115\n\u22a2 p.comp q * q + p.comp q * \u2191n = p.comp q * (q + \u2191n)"}, {"line": "rw [mul_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_assoc {R : Type*} [CommSemiring R] (\u03c6 \u03c8 \u03c7 : R[X]) :\n    (\u03c6.comp \u03c8).comp \u03c7 = \u03c6.comp (\u03c8.comp \u03c7) := by\n  refine Polynomial.induction_on \u03c6 ?_ ?_ ?_ <;>\n    \u00b7 intros\n      simp_all only [add_comp, mul_comp, C_comp, X_comp, pow_succ, \u2190 mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\n\u03c6 \u03c8 \u03c7 : Polynomial R\n\u22a2 (\u03c6.comp \u03c8).comp \u03c7 = \u03c6.comp (\u03c8.comp \u03c7)"}, {"line": "refine Polynomial.induction_on \u03c6 ?_ ?_ ?_ <;>\n    \u00b7 intros\n      simp_all only [add_comp, mul_comp, C_comp, X_comp, pow_succ, \u2190 mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isRoot_comp {R} [CommSemiring R] {p q : R[X]} {r : R} :\n    (p.comp q).IsRoot r \u2194 p.IsRoot (q.eval r) := by simp_rw [IsRoot, eval_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}", "[Semiring S]", "(f : R \u2192+* S)", "[CommSemiring R] {p q : R[X]} {x : R} [CommSemiring S] (f : R \u2192+* S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\np q : Polynomial R\nr : R\n\u22a2 (p.comp q).IsRoot r \u2194 p.IsRoot (eval r q)"}, {"line": "simp_rw [IsRoot, eval_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_geom_sum {R} [CommSemiring R] {n : \u2115} {x : R} :\n    eval x (\u2211 i \u2208 range n, X ^ i) = \u2211 i \u2208 range n, x ^ i := by simp [eval_finset_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}", "[Semiring S]", "(f : R \u2192+* S)", "[CommSemiring R] {p q : R[X]} {x : R} [CommSemiring S] (f : R \u2192+* S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\nn : \u2115\nx : R\n\u22a2 eval x (\u2211 i \u2208 range n, X ^ i) = \u2211 i \u2208 range n, x ^ i"}, {"line": "simp [eval_finset_sum]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intCast_comp (i : \u2124) : comp (i : R[X]) p = i := by cases i <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}", "[Semiring S]", "(f : R \u2192+* S)", "[CommSemiring R] {p q : R[X]} {x : R} [CommSemiring S] (f : R \u2192+* S)", "[NoZeroDivisors R]", "[CommSemiring R] [CommSemiring S] (f : R \u2192+* S)", "[Ring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "i : \u2124\n\u22a2 sorry"}, {"line": "cases i <;> simp", "tactic_state": "case ofNat\na\u271d : \u2115\n\u22a2 sorry ()\n---\ncase negSucc\na\u271d : \u2115\n\u22a2 sorry ()"}]}
{"declaration": "theorem eval\u2082_at_intCast {S : Type*} [Ring S] (f : R \u2192+* S) (n : \u2124) :\n    p.eval\u2082 f n = f (p.eval n) := by\n  convert eval\u2082_at_apply (p := p) f n\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Eval/Defs.lean", "context": {"open": ["Finset AddMonoidAlgebra", "Polynomial"], "variables": ["{R : Type u} {S : Type v} {T : Type w} {\u03b9 : Type y} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]", "(f : R \u2192+* S) (x : S)", "[Semiring T]", "[CommSemiring S] (f : R \u2192+* S) (x : S)", "{x : R}", "[Semiring S]", "(f : R \u2192+* S)", "[CommSemiring R] {p q : R[X]} {x : R} [CommSemiring S] (f : R \u2192+* S)", "[NoZeroDivisors R]", "[CommSemiring R] [CommSemiring S] (f : R \u2192+* S)", "[Ring R] {p q r : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NoZeroDivisors R\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring R\np : Polynomial R\nS : Type u_1\ninst\u271d : Ring S\nf : R \u2192+* S\nn : \u2124\n\u22a2 eval\u2082 f (\u2191n) p = f (eval (\u2191n) p)"}, {"line": "convert eval\u2082_at_apply (p := p) f n", "tactic_state": "case h.e'_2.h.e'_6\nR : Type u\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NoZeroDivisors R\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring R\np : Polynomial R\nS : Type u_1\ninst\u271d : Ring S\nf : R \u2192+* S\nn : \u2124\n\u22a2 \u2191n = f sorry\n---\ncase h.e'_3.h.e'_6.h.e'_3\nR : Type u\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NoZeroDivisors R\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring R\np : Polynomial R\nS : Type u_1\ninst\u271d : Ring S\nf : R \u2192+* S\nn : \u2124\n\u22a2 \u2191n = sorry"}, {"line": "simp", "tactic_state": "case h.e'_2.h.e'_6\nR : Type u\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NoZeroDivisors R\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring R\np : Polynomial R\nS : Type u_1\ninst\u271d : Ring S\nf : R \u2192+* S\nn : \u2124\n\u22a2 \u2191n = f (sorry ())\n---\ncase h.e'_3.h.e'_6.h.e'_3\nR : Type u\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NoZeroDivisors R\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring R\np : Polynomial R\nS : Type u_1\ninst\u271d : Ring S\nf : R \u2192+* S\nn : \u2124\n\u22a2 \u2191n = sorry"}]}
{"declaration": "lemma smul_def (f : R[X]) (m : PolynomialModule R M) :\n    f \u2022 m = aeval (Finsupp.lmapDomain M R Nat.succ) f m := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Polynomial/Module/Basic.lean", "context": {"open": ["Polynomial"], "variables": ["(R M : Type*) [CommRing R] [AddCommGroup M] [Module R M] (I : Ideal R)", "{M}", "{S : Type*} [CommSemiring S] [Algebra S R] [Module S M] [IsScalarTower S R M]", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : Polynomial R\nm : PolynomialModule R M\n\u22a2 f \u2022 m = ((aeval (Finsupp.lmapDomain M R Nat.succ)) f) m"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DvdNotUnit.isUnit_of_irreducible_right [CommMonoidWithZero M] {p q : M}\n    (h : DvdNotUnit p q) (hq : Irreducible q) : IsUnit p := by\n  obtain \u27e8_, x, hx, hx'\u27e9 := h\n  exact ((irreducible_iff.1 hq).right hx').resolve_right hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Prime/Lemmas.lean", "context": {"open": [], "variables": ["{M N : Type*}", "[CommMonoidWithZero M]", "[CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]", "[MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]", "(f : F) (g : G) {p : M}", "[CancelCommMonoidWithZero M] {a p : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u00b2 : CommMonoidWithZero M\ninst\u271d\u00b9 : CancelCommMonoidWithZero M\ninst\u271d : CommMonoidWithZero M\np q : M\nh : DvdNotUnit p q\nhq : Irreducible q\n\u22a2 IsUnit p"}, {"line": "obtain \u27e8_, x, hx, hx'\u27e9 := h", "tactic_state": "case intro.intro.intro\nM : Type u_1\ninst\u271d\u00b2 : CommMonoidWithZero M\ninst\u271d\u00b9 : CancelCommMonoidWithZero M\ninst\u271d : CommMonoidWithZero M\np q : M\nhq : Irreducible q\nleft\u271d : p \u2260 0\nx : M\nhx : \u00acIsUnit x\nhx' : q = p * x\n\u22a2 IsUnit p"}, {"line": "exact ((irreducible_iff.1 hq).right hx').resolve_right hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsUnit.isRegular (ua : IsUnit a) : IsRegular a := by\n  rcases ua with \u27e8a, rfl\u27e9\n  exact Units.isRegular a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Regular/Basic.lean", "context": {"open": [], "variables": ["{R : Type*}", "[Mul R]", "[Semigroup R] {a b : R}", "[MulZeroClass R] {a b : R}", "[MulOneClass R]", "[CommSemigroup R] {a b : R}", "[Monoid R] {a b : R} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Mul R\ninst\u271d\u2074 : Semigroup R\ninst\u271d\u00b3 : MulZeroClass R\ninst\u271d\u00b2 : MulOneClass R\ninst\u271d\u00b9 : CommSemigroup R\ninst\u271d : Monoid R\na : R\nua : IsUnit a\n\u22a2 IsRegular a"}, {"line": "rcases ua with \u27e8a, rfl\u27e9", "tactic_state": "case intro\nR : Type u_1\ninst\u271d\u2075 : Mul R\ninst\u271d\u2074 : Semigroup R\ninst\u271d\u00b3 : MulZeroClass R\ninst\u271d\u00b2 : MulOneClass R\ninst\u271d\u00b9 : CommSemigroup R\ninst\u271d : Monoid R\na : R\u02e3\n\u22a2 IsRegular \u2191a"}, {"line": "exact Units.isRegular a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_mul [Mul R] [IsScalarTower R R M] (ab : IsSMulRegular M (a * b)) :\n    IsSMulRegular M b := by\n  rw [\u2190 smul_eq_mul] at ab\n  exact ab.of_smul _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Regular/SMul.lean", "context": {"open": [], "variables": ["{R S : Type*} (M : Type*) {a b : R} {s : S}", "{M}", "[SMul R M] [SMul R S] [SMul S M] [IsScalarTower R S M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_3\na b : R\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : Mul R\ninst\u271d : IsScalarTower R R M\nab : IsSMulRegular M (a * b)\n\u22a2 IsSMulRegular M b"}, {"line": "rw [\u2190 smul_eq_mul] at ab", "tactic_state": "R : Type u_1\nM : Type u_3\na b : R\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : Mul R\ninst\u271d : IsScalarTower R R M\nab : IsSMulRegular M (a \u2022 b)\n\u22a2 IsSMulRegular M b"}, {"line": "exact ab.of_smul _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pow_iff {n : \u2115} (n0 : 0 < n) : IsSMulRegular M (a ^ n) \u2194 IsSMulRegular M a := by\n  refine \u27e8?_, pow n\u27e9\n  rw [\u2190 Nat.succ_pred_eq_of_pos n0]\n  rw [pow_succ]\n  rw [\u2190 smul_eq_mul]\n  exact of_smul _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Regular/SMul.lean", "context": {"open": [], "variables": ["{R S : Type*} (M : Type*) {a b : R} {s : S}", "{M}", "[SMul R M] [SMul R S] [SMul S M] [IsScalarTower R S M]", "[Monoid R] [MulAction R M]", "(M)", "{M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_3\na : R\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : Monoid R\ninst\u271d : MulAction R M\nn : \u2115\nn0 : 0 < n\n\u22a2 IsSMulRegular M (a ^ n) \u2194 IsSMulRegular M a"}, {"line": "refine \u27e8?_, pow n\u27e9", "tactic_state": "R : Type u_1\nM : Type u_3\na : R\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : Monoid R\ninst\u271d : MulAction R M\nn : \u2115\nn0 : 0 < n\n\u22a2 IsSMulRegular M (a ^ n) \u2192 IsSMulRegular M a"}, {"line": "rw [\u2190 Nat.succ_pred_eq_of_pos n0]", "tactic_state": "R : Type u_1\nM : Type u_3\na : R\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : Monoid R\ninst\u271d : MulAction R M\nn : \u2115\nn0 : 0 < n\n\u22a2 IsSMulRegular M (a ^ n.pred.succ) \u2192 IsSMulRegular M a"}, {"line": "rw [pow_succ]", "tactic_state": "R : Type u_1\nM : Type u_3\na : R\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : Monoid R\ninst\u271d : MulAction R M\nn : \u2115\nn0 : 0 < n\n\u22a2 IsSMulRegular M (a ^ n.pred * a) \u2192 IsSMulRegular M a"}, {"line": "rw [\u2190 smul_eq_mul]", "tactic_state": "R : Type u_1\nM : Type u_3\na : R\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : Monoid R\ninst\u271d : MulAction R M\nn : \u2115\nn0 : 0 < n\n\u22a2 IsSMulRegular M (a ^ n.pred \u2022 a) \u2192 IsSMulRegular M a"}, {"line": "exact of_smul _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsUnit.isSMulRegular (ua : IsUnit a) : IsSMulRegular M a := by\n  rcases ua with \u27e8a, rfl\u27e9\n  exact a.isSMulRegular M\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Regular/SMul.lean", "context": {"open": [], "variables": ["{R S : Type*} (M : Type*) {a b : R} {s : S}", "{M}", "[SMul R M] [SMul R S] [SMul S M] [IsScalarTower R S M]", "[Monoid R] [MulAction R M]", "(M)", "{M}", "[Monoid S] [SMul R M] [SMul R S] [MulAction S M] [IsScalarTower R S M]", "[MonoidWithZero R] [Zero M] [MulActionWithZero R M]", "[CommSemigroup R] [SMul R M] [IsScalarTower R R M]", "{G : Type*} [Group G]", "[Monoid R] [MulAction R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_3\na : R\ninst\u271d\u00b9\u00b9 : SMul R M\ninst\u271d\u00b9\u2070 : Monoid R\ninst\u271d\u2079 : MulAction R M\ninst\u271d\u2078 : SMul R M\ninst\u271d\u2077 : MonoidWithZero R\ninst\u271d\u2076 : Zero M\ninst\u271d\u2075 : MulActionWithZero R M\ninst\u271d\u2074 : CommSemigroup R\ninst\u271d\u00b3 : SMul R M\ninst\u271d\u00b2 : IsScalarTower R R M\ninst\u271d\u00b9 : Monoid R\ninst\u271d : MulAction R M\nua : IsUnit a\n\u22a2 IsSMulRegular M a"}, {"line": "rcases ua with \u27e8a, rfl\u27e9", "tactic_state": "case intro\nR : Type u_1\nM : Type u_3\ninst\u271d\u00b9\u00b9 : SMul R M\ninst\u271d\u00b9\u2070 : Monoid R\ninst\u271d\u2079 : MulAction R M\ninst\u271d\u2078 : SMul R M\ninst\u271d\u2077 : MonoidWithZero R\ninst\u271d\u2076 : Zero M\ninst\u271d\u2075 : MulActionWithZero R M\ninst\u271d\u2074 : CommSemigroup R\ninst\u271d\u00b3 : SMul R M\ninst\u271d\u00b2 : IsScalarTower R R M\ninst\u271d\u00b9 : Monoid R\ninst\u271d : MulAction R M\na : R\u02e3\n\u22a2 IsSMulRegular M \u2191a"}, {"line": "exact a.isSMulRegular M", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofBoolAlg_symmDiff (a b : AsBoolAlg \u03b1) : ofBoolAlg (a \u2206 b) = ofBoolAlg a + ofBoolAlg b := by\n  rw [symmDiff_eq_sup_sdiff_inf]\n  exact of_boolalg_symmDiff_aux _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/BooleanRing.lean", "context": {"open": ["scoped symmDiff", "BooleanAlgebraOfBooleanRing", "BooleanRing"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[BooleanRing \u03b1] (a b : \u03b1)", "[BooleanRing \u03b1] [BooleanRing \u03b2] [BooleanRing \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : BooleanRing \u03b1\na b : AsBoolAlg \u03b1\n\u22a2 ofBoolAlg (symmDiff a b) = ofBoolAlg a + ofBoolAlg b"}, {"line": "rw [symmDiff_eq_sup_sdiff_inf]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : BooleanRing \u03b1\na b : AsBoolAlg \u03b1\n\u22a2 ofBoolAlg ((a \u2294 b) \\ (a \u2293 b)) = ofBoolAlg a + ofBoolAlg b"}, {"line": "exact of_boolalg_symmDiff_aux _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sq_add_sq_mul_sq_add_sq :\n    (x\u2081 ^ 2 + x\u2082 ^ 2) * (y\u2081 ^ 2 + y\u2082 ^ 2) = (x\u2081 * y\u2081 - x\u2082 * y\u2082) ^ 2 + (x\u2081 * y\u2082 + x\u2082 * y\u2081) ^ 2 := by\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Identities.lean", "context": {"open": [], "variables": ["{R : Type*} [CommRing R] {a b x\u2081 x\u2082 x\u2083 x\u2084 x\u2085 x\u2086 x\u2087 x\u2088 y\u2081 y\u2082 y\u2083 y\u2084 y\u2085 y\u2086 y\u2087 y\u2088 n : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nx\u2081 x\u2082 y\u2081 y\u2082 : R\n\u22a2 (x\u2081 ^ 2 + x\u2082 ^ 2) * (y\u2081 ^ 2 + y\u2082 ^ 2) = (x\u2081 * y\u2081 - x\u2082 * y\u2082) ^ 2 + (x\u2081 * y\u2082 + x\u2082 * y\u2081) ^ 2"}, {"line": "ring", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nx\u2081 x\u2082 y\u2081 y\u2082 : R\n\u22a2 (x\u2081 ^ 2 + x\u2082 ^ 2) * (y\u2081 ^ 2 + y\u2082 ^ 2) = (x\u2081 * y\u2081 - x\u2082 * y\u2082) ^ 2 + (x\u2081 * y\u2082 + x\u2082 * y\u2081) ^ 2"}]}
{"declaration": "theorem sq_add_mul_sq_mul_sq_add_mul_sq :\n    (x\u2081 ^ 2 + n * x\u2082 ^ 2) * (y\u2081 ^ 2 + n * y\u2082 ^ 2) =\n    (x\u2081 * y\u2081 - n * x\u2082 * y\u2082) ^ 2 + n * (x\u2081 * y\u2082 + x\u2082 * y\u2081) ^ 2 := by\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Identities.lean", "context": {"open": [], "variables": ["{R : Type*} [CommRing R] {a b x\u2081 x\u2082 x\u2083 x\u2084 x\u2085 x\u2086 x\u2087 x\u2088 y\u2081 y\u2082 y\u2083 y\u2084 y\u2085 y\u2086 y\u2087 y\u2088 n : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nx\u2081 x\u2082 y\u2081 y\u2082 n : R\n\u22a2 (x\u2081 ^ 2 + n * x\u2082 ^ 2) * (y\u2081 ^ 2 + n * y\u2082 ^ 2) = (x\u2081 * y\u2081 - n * x\u2082 * y\u2082) ^ 2 + n * (x\u2081 * y\u2082 + x\u2082 * y\u2081) ^ 2"}, {"line": "ring", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nx\u2081 x\u2082 y\u2081 y\u2082 n : R\n\u22a2 (x\u2081 ^ 2 + n * x\u2082 ^ 2) * (y\u2081 ^ 2 + n * y\u2082 ^ 2) = (x\u2081 * y\u2081 - n * x\u2082 * y\u2082) ^ 2 + n * (x\u2081 * y\u2082 + x\u2082 * y\u2081) ^ 2"}]}
{"declaration": "theorem pow_four_add_four_mul_pow_four :\n    a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2) := by\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Identities.lean", "context": {"open": [], "variables": ["{R : Type*} [CommRing R] {a b x\u2081 x\u2082 x\u2083 x\u2084 x\u2085 x\u2086 x\u2087 x\u2088 y\u2081 y\u2082 y\u2083 y\u2084 y\u2085 y\u2086 y\u2087 y\u2088 n : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b : R\n\u22a2 a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)"}, {"line": "ring", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b : R\n\u22a2 a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)"}]}
{"declaration": "theorem pow_four_add_four_mul_pow_four' :\n    a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2) := by\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Identities.lean", "context": {"open": [], "variables": ["{R : Type*} [CommRing R] {a b x\u2081 x\u2082 x\u2083 x\u2084 x\u2085 x\u2086 x\u2087 x\u2088 y\u2081 y\u2082 y\u2083 y\u2084 y\u2085 y\u2086 y\u2087 y\u2088 n : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b : R\n\u22a2 a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)"}, {"line": "ring", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na b : R\n\u22a2 a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)"}]}
{"declaration": "theorem sum_four_sq_mul_sum_four_sq :\n    (x\u2081 ^ 2 + x\u2082 ^ 2 + x\u2083 ^ 2 + x\u2084 ^ 2) * (y\u2081 ^ 2 + y\u2082 ^ 2 + y\u2083 ^ 2 + y\u2084 ^ 2) =\n      (x\u2081 * y\u2081 - x\u2082 * y\u2082 - x\u2083 * y\u2083 - x\u2084 * y\u2084) ^ 2 + (x\u2081 * y\u2082 + x\u2082 * y\u2081 + x\u2083 * y\u2084 - x\u2084 * y\u2083) ^ 2 +\n          (x\u2081 * y\u2083 - x\u2082 * y\u2084 + x\u2083 * y\u2081 + x\u2084 * y\u2082) ^ 2 +\n        (x\u2081 * y\u2084 + x\u2082 * y\u2083 - x\u2083 * y\u2082 + x\u2084 * y\u2081) ^ 2 := by\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Identities.lean", "context": {"open": [], "variables": ["{R : Type*} [CommRing R] {a b x\u2081 x\u2082 x\u2083 x\u2084 x\u2085 x\u2086 x\u2087 x\u2088 y\u2081 y\u2082 y\u2083 y\u2084 y\u2085 y\u2086 y\u2087 y\u2088 n : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nx\u2081 x\u2082 x\u2083 x\u2084 y\u2081 y\u2082 y\u2083 y\u2084 : R\n\u22a2 (x\u2081 ^ 2 + x\u2082 ^ 2 + x\u2083 ^ 2 + x\u2084 ^ 2) * (y\u2081 ^ 2 + y\u2082 ^ 2 + y\u2083 ^ 2 + y\u2084 ^ 2) =\n    (x\u2081 * y\u2081 - x\u2082 * y\u2082 - x\u2083 * y\u2083 - x\u2084 * y\u2084) ^ 2 + (x\u2081 * y\u2082 + x\u2082 * y\u2081 + x\u2083 * y\u2084 - x\u2084 * y\u2083) ^ 2 +\n        (x\u2081 * y\u2083 - x\u2082 * y\u2084 + x\u2083 * y\u2081 + x\u2084 * y\u2082) ^ 2 +\n      (x\u2081 * y\u2084 + x\u2082 * y\u2083 - x\u2083 * y\u2082 + x\u2084 * y\u2081) ^ 2"}, {"line": "ring", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nx\u2081 x\u2082 x\u2083 x\u2084 y\u2081 y\u2082 y\u2083 y\u2084 : R\n\u22a2 (x\u2081 ^ 2 + x\u2082 ^ 2 + x\u2083 ^ 2 + x\u2084 ^ 2) * (y\u2081 ^ 2 + y\u2082 ^ 2 + y\u2083 ^ 2 + y\u2084 ^ 2) =\n    (x\u2081 * y\u2081 - x\u2082 * y\u2082 - x\u2083 * y\u2083 - x\u2084 * y\u2084) ^ 2 + (x\u2081 * y\u2082 + x\u2082 * y\u2081 + x\u2083 * y\u2084 - x\u2084 * y\u2083) ^ 2 +\n        (x\u2081 * y\u2083 - x\u2082 * y\u2084 + x\u2083 * y\u2081 + x\u2084 * y\u2082) ^ 2 +\n      (x\u2081 * y\u2084 + x\u2082 * y\u2083 - x\u2083 * y\u2082 + x\u2084 * y\u2081) ^ 2"}]}
{"declaration": "theorem sum_eight_sq_mul_sum_eight_sq :\n    (x\u2081 ^ 2 + x\u2082 ^ 2 + x\u2083 ^ 2 + x\u2084 ^ 2 + x\u2085 ^ 2 + x\u2086 ^ 2 + x\u2087 ^ 2 + x\u2088 ^ 2) *\n      (y\u2081 ^ 2 + y\u2082 ^ 2 + y\u2083 ^ 2 + y\u2084 ^ 2 + y\u2085 ^ 2 + y\u2086 ^ 2 + y\u2087 ^ 2 + y\u2088 ^ 2) =\n    (x\u2081 * y\u2081 - x\u2082 * y\u2082 - x\u2083 * y\u2083 - x\u2084 * y\u2084 - x\u2085 * y\u2085 - x\u2086 * y\u2086 - x\u2087 * y\u2087 - x\u2088 * y\u2088) ^ 2 +\n      (x\u2081 * y\u2082 + x\u2082 * y\u2081 + x\u2083 * y\u2084 - x\u2084 * y\u2083 + x\u2085 * y\u2086 - x\u2086 * y\u2085 - x\u2087 * y\u2088 + x\u2088 * y\u2087) ^ 2 +\n      (x\u2081 * y\u2083 - x\u2082 * y\u2084 + x\u2083 * y\u2081 + x\u2084 * y\u2082 + x\u2085 * y\u2087 + x\u2086 * y\u2088 - x\u2087 * y\u2085 - x\u2088 * y\u2086) ^ 2 +\n      (x\u2081 * y\u2084 + x\u2082 * y\u2083 - x\u2083 * y\u2082 + x\u2084 * y\u2081 + x\u2085 * y\u2088 - x\u2086 * y\u2087 + x\u2087 * y\u2086 - x\u2088 * y\u2085) ^ 2 +\n      (x\u2081 * y\u2085 - x\u2082 * y\u2086 - x\u2083 * y\u2087 - x\u2084 * y\u2088 + x\u2085 * y\u2081 + x\u2086 * y\u2082 + x\u2087 * y\u2083 + x\u2088 * y\u2084) ^ 2 +\n      (x\u2081 * y\u2086 + x\u2082 * y\u2085 - x\u2083 * y\u2088 + x\u2084 * y\u2087 - x\u2085 * y\u2082 + x\u2086 * y\u2081 - x\u2087 * y\u2084 + x\u2088 * y\u2083) ^ 2 +\n      (x\u2081 * y\u2087 + x\u2082 * y\u2088 + x\u2083 * y\u2085 - x\u2084 * y\u2086 - x\u2085 * y\u2083 + x\u2086 * y\u2084 + x\u2087 * y\u2081 - x\u2088 * y\u2082) ^ 2 +\n      (x\u2081 * y\u2088 - x\u2082 * y\u2087 + x\u2083 * y\u2086 + x\u2084 * y\u2085 - x\u2085 * y\u2084 - x\u2086 * y\u2083 + x\u2087 * y\u2082 + x\u2088 * y\u2081) ^ 2 := by\n  ring", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Identities.lean", "context": {"open": [], "variables": ["{R : Type*} [CommRing R] {a b x\u2081 x\u2082 x\u2083 x\u2084 x\u2085 x\u2086 x\u2087 x\u2088 y\u2081 y\u2082 y\u2083 y\u2084 y\u2085 y\u2086 y\u2087 y\u2088 n : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nx\u2081 x\u2082 x\u2083 x\u2084 x\u2085 x\u2086 x\u2087 x\u2088 y\u2081 y\u2082 y\u2083 y\u2084 y\u2085 y\u2086 y\u2087 y\u2088 : R\n\u22a2 (x\u2081 ^ 2 + x\u2082 ^ 2 + x\u2083 ^ 2 + x\u2084 ^ 2 + x\u2085 ^ 2 + x\u2086 ^ 2 + x\u2087 ^ 2 + x\u2088 ^ 2) *\n      (y\u2081 ^ 2 + y\u2082 ^ 2 + y\u2083 ^ 2 + y\u2084 ^ 2 + y\u2085 ^ 2 + y\u2086 ^ 2 + y\u2087 ^ 2 + y\u2088 ^ 2) =\n    (x\u2081 * y\u2081 - x\u2082 * y\u2082 - x\u2083 * y\u2083 - x\u2084 * y\u2084 - x\u2085 * y\u2085 - x\u2086 * y\u2086 - x\u2087 * y\u2087 - x\u2088 * y\u2088) ^ 2 +\n                  (x\u2081 * y\u2082 + x\u2082 * y\u2081 + x\u2083 * y\u2084 - x\u2084 * y\u2083 + x\u2085 * y\u2086 - x\u2086 * y\u2085 - x\u2087 * y\u2088 + x\u2088 * y\u2087) ^ 2 +\n                (x\u2081 * y\u2083 - x\u2082 * y\u2084 + x\u2083 * y\u2081 + x\u2084 * y\u2082 + x\u2085 * y\u2087 + x\u2086 * y\u2088 - x\u2087 * y\u2085 - x\u2088 * y\u2086) ^ 2 +\n              (x\u2081 * y\u2084 + x\u2082 * y\u2083 - x\u2083 * y\u2082 + x\u2084 * y\u2081 + x\u2085 * y\u2088 - x\u2086 * y\u2087 + x\u2087 * y\u2086 - x\u2088 * y\u2085) ^ 2 +\n            (x\u2081 * y\u2085 - x\u2082 * y\u2086 - x\u2083 * y\u2087 - x\u2084 * y\u2088 + x\u2085 * y\u2081 + x\u2086 * y\u2082 + x\u2087 * y\u2083 + x\u2088 * y\u2084) ^ 2 +\n          (x\u2081 * y\u2086 + x\u2082 * y\u2085 - x\u2083 * y\u2088 + x\u2084 * y\u2087 - x\u2085 * y\u2082 + x\u2086 * y\u2081 - x\u2087 * y\u2084 + x\u2088 * y\u2083) ^ 2 +\n        (x\u2081 * y\u2087 + x\u2082 * y\u2088 + x\u2083 * y\u2085 - x\u2084 * y\u2086 - x\u2085 * y\u2083 + x\u2086 * y\u2084 + x\u2087 * y\u2081 - x\u2088 * y\u2082) ^ 2 +\n      (x\u2081 * y\u2088 - x\u2082 * y\u2087 + x\u2083 * y\u2086 + x\u2084 * y\u2085 - x\u2085 * y\u2084 - x\u2086 * y\u2083 + x\u2087 * y\u2082 + x\u2088 * y\u2081) ^ 2"}, {"line": "ring", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nx\u2081 x\u2082 x\u2083 x\u2084 x\u2085 x\u2086 x\u2087 x\u2088 y\u2081 y\u2082 y\u2083 y\u2084 y\u2085 y\u2086 y\u2087 y\u2088 : R\n\u22a2 (x\u2081 ^ 2 + x\u2082 ^ 2 + x\u2083 ^ 2 + x\u2084 ^ 2 + x\u2085 ^ 2 + x\u2086 ^ 2 + x\u2087 ^ 2 + x\u2088 ^ 2) *\n      (y\u2081 ^ 2 + y\u2082 ^ 2 + y\u2083 ^ 2 + y\u2084 ^ 2 + y\u2085 ^ 2 + y\u2086 ^ 2 + y\u2087 ^ 2 + y\u2088 ^ 2) =\n    (x\u2081 * y\u2081 - x\u2082 * y\u2082 - x\u2083 * y\u2083 - x\u2084 * y\u2084 - x\u2085 * y\u2085 - x\u2086 * y\u2086 - x\u2087 * y\u2087 - x\u2088 * y\u2088) ^ 2 +\n                  (x\u2081 * y\u2082 + x\u2082 * y\u2081 + x\u2083 * y\u2084 - x\u2084 * y\u2083 + x\u2085 * y\u2086 - x\u2086 * y\u2085 - x\u2087 * y\u2088 + x\u2088 * y\u2087) ^ 2 +\n                (x\u2081 * y\u2083 - x\u2082 * y\u2084 + x\u2083 * y\u2081 + x\u2084 * y\u2082 + x\u2085 * y\u2087 + x\u2086 * y\u2088 - x\u2087 * y\u2085 - x\u2088 * y\u2086) ^ 2 +\n              (x\u2081 * y\u2084 + x\u2082 * y\u2083 - x\u2083 * y\u2082 + x\u2084 * y\u2081 + x\u2085 * y\u2088 - x\u2086 * y\u2087 + x\u2087 * y\u2086 - x\u2088 * y\u2085) ^ 2 +\n            (x\u2081 * y\u2085 - x\u2082 * y\u2086 - x\u2083 * y\u2087 - x\u2084 * y\u2088 + x\u2085 * y\u2081 + x\u2086 * y\u2082 + x\u2087 * y\u2083 + x\u2088 * y\u2084) ^ 2 +\n          (x\u2081 * y\u2086 + x\u2082 * y\u2085 - x\u2083 * y\u2088 + x\u2084 * y\u2087 - x\u2085 * y\u2082 + x\u2086 * y\u2081 - x\u2087 * y\u2084 + x\u2088 * y\u2083) ^ 2 +\n        (x\u2081 * y\u2087 + x\u2082 * y\u2088 + x\u2083 * y\u2085 - x\u2084 * y\u2086 - x\u2085 * y\u2083 + x\u2086 * y\u2084 + x\u2087 * y\u2081 - x\u2088 * y\u2082) ^ 2 +\n      (x\u2081 * y\u2088 - x\u2082 * y\u2087 + x\u2083 * y\u2086 + x\u2084 * y\u2085 - x\u2085 * y\u2084 - x\u2086 * y\u2083 + x\u2087 * y\u2082 + x\u2088 * y\u2081) ^ 2"}]}
{"declaration": "theorem invOf_two_add_invOf_two [NonAssocSemiring R] [Invertible (2 : R)] :\n    (\u215f 2 : R) + (\u215f 2 : R) = 1 := by rw [\u2190 two_mul, mul_invOf_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Invertible.lean", "context": {"open": [], "variables": ["{R : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : Invertible 2\n\u22a2 \u215f 2 + \u215f 2 = 1"}, {"line": "rw [\u2190 two_mul, mul_invOf_self]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma negOnePow_abs (n : \u2124) : |n|.negOnePow = n.negOnePow := by\n  obtain h|h := abs_choice n <;> simp only [h, negOnePow_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/NegOnePow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 |n|.negOnePow = n.negOnePow"}, {"line": "obtain h|h := abs_choice n <;> simp only [h, negOnePow_neg]", "tactic_state": "case inr\nn : \u2124\nh : |n| = -n\n\u22a2 (-n).negOnePow = n.negOnePow"}]}
{"declaration": "lemma negOnePow_mul_self (n : \u2124) : (n * n).negOnePow = n.negOnePow := by\n  simpa [mul_sub, negOnePow_eq_iff] using n.even_mul_pred_self\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/NegOnePow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 (n * n).negOnePow = n.negOnePow"}, {"line": "simpa [mul_sub, negOnePow_eq_iff] using n.even_mul_pred_self", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cast_negOnePow_natCast (R : Type*) [Ring R] (n : \u2115) : negOnePow n = (-1 : R) ^ n := by\n  obtain \u27e8k, rfl | rfl\u27e9 := Nat.even_or_odd' n <;> simp [pow_succ, pow_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/NegOnePow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nnegOnePow : x\u271d\nR : Type u_1\ninst\u271d : Ring R\nn : \u2115\n\u22a2 sorry = (-1) ^ n"}, {"line": "obtain \u27e8k, rfl | rfl\u27e9 := Nat.even_or_odd' n <;> simp [pow_succ, pow_mul]", "tactic_state": "case intro.inl\nx\u271d : Sort u_2\nnegOnePow : x\u271d\nR : Type u_1\ninst\u271d : Ring R\nk : \u2115\n\u22a2 sorry () = (-1 * -1) ^ k\n---\ncase intro.inr\nx\u271d : Sort u_2\nnegOnePow : x\u271d\nR : Type u_1\ninst\u271d : Ring R\nk : \u2115\n\u22a2 sorry () = (-1 * -1) ^ k * -1"}]}
{"declaration": "protected theorem Periodic.comp [Add \u03b1] (h : Periodic f c) (g : \u03b2 \u2192 \u03b3) : Periodic (g \u2218 f) c := by\n  simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : Add \u03b1\nh : sorry\ng : \u03b2 \u2192 \u03b3\n\u22a2 sorry"}, {"line": "simp_all", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : Add \u03b1\nh : sorry\ng : \u03b2 \u2192 \u03b3\n\u22a2 sorry ()"}]}
{"declaration": "protected theorem Periodic.mul [Add \u03b1] [Mul \u03b2] (hf : Periodic f c) (hg : Periodic g c) :\n    Periodic (f * g) c := by simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d\u00b9 : Add \u03b1\ninst\u271d : Mul \u03b2\nhf : sorry\nhg : sorry\n\u22a2 sorry"}, {"line": "simp_all", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d\u00b9 : Add \u03b1\ninst\u271d : Mul \u03b2\nhf : sorry\nhg : sorry\n\u22a2 sorry ()"}]}
{"declaration": "protected theorem Periodic.div [Add \u03b1] [Div \u03b2] (hf : Periodic f c) (hg : Periodic g c) :\n    Periodic (f / g) c := by simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d\u00b9 : Add \u03b1\ninst\u271d : Div \u03b2\nhf : sorry\nhg : sorry\n\u22a2 sorry"}, {"line": "simp_all", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d\u00b9 : Add \u03b1\ninst\u271d : Div \u03b2\nhf : sorry\nhg : sorry\n\u22a2 sorry ()"}]}
{"declaration": "protected theorem Periodic.smul [Add \u03b1] [SMul \u03b3 \u03b2] (h : Periodic f c) (a : \u03b3) :\n    Periodic (a \u2022 f) c := by simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d\u00b9 : Add \u03b1\ninst\u271d : SMul \u03b3 \u03b2\nh : sorry\na : \u03b3\n\u22a2 sorry"}, {"line": "simp_all", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d\u00b9 : Add \u03b1\ninst\u271d : SMul \u03b3 \u03b2\nh : sorry\na : \u03b3\n\u22a2 sorry ()"}]}
{"declaration": "theorem Periodic.const_inv_smul [AddMonoid \u03b1] [Group \u03b3] [DistribMulAction \u03b3 \u03b1] (h : Periodic f c)\n    (a : \u03b3) : Periodic (fun x => f (a\u207b\u00b9 \u2022 x)) (a \u2022 c) := by\n  simpa only [inv_inv] using h.const_smul a\u207b\u00b9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b3 : Type u_3\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d\u00b2 : AddMonoid \u03b1\ninst\u271d\u00b9 : Group \u03b3\ninst\u271d : DistribMulAction \u03b3 \u03b1\nh : sorry\na : \u03b3\n\u22a2 sorry"}, {"line": "simpa only [inv_inv] using h.const_smul a\u207b\u00b9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Periodic.add_period [AddSemigroup \u03b1] (h1 : Periodic f c\u2081) (h2 : Periodic f c\u2082) :\n    Periodic f (c\u2081 + c\u2082) := by simp_all [\u2190 add_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddSemigroup \u03b1\nh1 : sorry\nh2 : sorry\n\u22a2 sorry"}, {"line": "simp_all [\u2190 add_assoc]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddSemigroup \u03b1\nh1 : sorry\nh2 : sorry\n\u22a2 sorry ()"}]}
{"declaration": "theorem Periodic.sub_eq [AddGroup \u03b1] (h : Periodic f c) (x : \u03b1) : f (x - c) = f x := by\n  simpa only [sub_add_cancel] using (h (x - c)).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc : \u03b1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddGroup \u03b1\nh : sorry\nx : \u03b1\n\u22a2 f (x - c) = f x"}, {"line": "simpa only [sub_add_cancel] using (h (x - c)).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Periodic.sub_eq' [SubtractionCommMonoid \u03b1] (h : Periodic f c) : f (c - x) = f (-x) := by\n  simpa only [sub_eq_neg_add] using h (-x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc x : \u03b1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : SubtractionCommMonoid \u03b1\nh : sorry\n\u22a2 f (c - x) = f (-x)"}, {"line": "simpa only [sub_eq_neg_add] using h (-x)", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Periodic.neg [AddGroup \u03b1] (h : Periodic f c) : Periodic f (-c) := by\n  simpa only [sub_eq_add_neg, Periodic] using h.sub_eq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddGroup \u03b1\nh : sorry\n\u22a2 sorry"}, {"line": "simpa only [sub_eq_add_neg, Periodic] using h.sub_eq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Periodic.sub_const [SubtractionCommMonoid \u03b1] (h : Periodic f c) (a : \u03b1) :\n    Periodic (fun x => f (x - a)) c := by\n  simpa only [sub_eq_add_neg] using h.add_const (-a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : SubtractionCommMonoid \u03b1\nh : sorry\na : \u03b1\n\u22a2 sorry"}, {"line": "simpa only [sub_eq_add_neg] using h.add_const (-a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Periodic.nsmul [AddMonoid \u03b1] (h : Periodic f c) (n : \u2115) : Periodic f (n \u2022 c) := by\n  induction n <;> simp_all [add_nsmul, \u2190 add_assoc, zero_nsmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddMonoid \u03b1\nh : sorry\nn : \u2115\n\u22a2 sorry"}, {"line": "induction n <;> simp_all [add_nsmul, \u2190 add_assoc, zero_nsmul]", "tactic_state": "case zero\n\u03b1 : Type u_1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddMonoid \u03b1\nh : sorry\n\u22a2 sorry ()\n---\ncase succ\n\u03b1 : Type u_1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddMonoid \u03b1\nh : sorry\nn\u271d : \u2115\na\u271d : sorry\n\u22a2 sorry ()"}]}
{"declaration": "theorem Periodic.nat_mul [NonAssocSemiring \u03b1] (h : Periodic f c) (n : \u2115) : Periodic f (n * c) := by\n  simpa only [nsmul_eq_mul] using h.nsmul n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : NonAssocSemiring \u03b1\nh : sorry\nn : \u2115\n\u22a2 sorry"}, {"line": "simpa only [nsmul_eq_mul] using h.nsmul n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Periodic.sub_nsmul_eq [AddGroup \u03b1] (h : Periodic f c) (n : \u2115) : f (x - n \u2022 c) = f x := by\n  simpa only [sub_eq_add_neg] using h.neg_nsmul n x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc x : \u03b1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddGroup \u03b1\nh : sorry\nn : \u2115\n\u22a2 f (x - n \u2022 c) = f x"}, {"line": "simpa only [sub_eq_add_neg] using h.neg_nsmul n x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Periodic.sub_nat_mul_eq [NonAssocRing \u03b1] (h : Periodic f c) (n : \u2115) :\n    f (x - n * c) = f x := by\n  simpa only [nsmul_eq_mul] using h.sub_nsmul_eq n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc x : \u03b1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : NonAssocRing \u03b1\nh : sorry\nn : \u2115\n\u22a2 f (x - \u2191n * c) = f x"}, {"line": "simpa only [nsmul_eq_mul] using h.sub_nsmul_eq n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Periodic.nat_mul_sub_eq [NonAssocRing \u03b1] (h : Periodic f c) (n : \u2115) :\n    f (n * c - x) = f (-x) := by\n  simpa only [sub_eq_neg_add] using h.nat_mul n (-x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc x : \u03b1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : NonAssocRing \u03b1\nh : sorry\nn : \u2115\n\u22a2 f (\u2191n * c - x) = f (-x)"}, {"line": "simpa only [sub_eq_neg_add] using h.nat_mul n (-x)", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Periodic.zsmul [AddGroup \u03b1] (h : Periodic f c) (n : \u2124) : Periodic f (n \u2022 c) := by\n  rcases n with n | n\n  \u00b7 simpa only [Int.ofNat_eq_coe, natCast_zsmul] using h.nsmul n\n  \u00b7 simpa only [negSucc_zsmul] using (h.nsmul (n + 1)).neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddGroup \u03b1\nh : sorry\nn : \u2124\n\u22a2 sorry"}, {"line": "rcases n with n | n", "tactic_state": "case ofNat\n\u03b1 : Type u_1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddGroup \u03b1\nh : sorry\nn : \u2115\n\u22a2 sorry\n---\ncase negSucc\n\u03b1 : Type u_1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddGroup \u03b1\nh : sorry\nn : \u2115\n\u22a2 sorry"}, {"line": "\u00b7 simpa only [Int.ofNat_eq_coe, natCast_zsmul] using h.nsmul n", "tactic_state": "case negSucc\n\u03b1 : Type u_1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddGroup \u03b1\nh : sorry\nn : \u2115\n\u22a2 sorry"}, {"line": "\u00b7 simpa only [negSucc_zsmul] using (h.nsmul (n + 1)).neg", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Periodic.int_mul [NonAssocRing \u03b1] (h : Periodic f c) (n : \u2124) :\n    Periodic f (n * c) := by\n  simpa only [zsmul_eq_mul] using h.zsmul n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : NonAssocRing \u03b1\nh : sorry\nn : \u2124\n\u22a2 sorry"}, {"line": "simpa only [zsmul_eq_mul] using h.zsmul n", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Periodic.eq [AddZeroClass \u03b1] (h : Periodic f c) : f c = f 0 := by\n  simpa only [zero_add] using h 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc : \u03b1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddZeroClass \u03b1\nh : sorry\n\u22a2 f c = f 0"}, {"line": "simpa only [zero_add] using h 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Periodic.map_vadd_zmultiples [AddCommGroup \u03b1] (hf : Periodic f c)\n    (a : AddSubgroup.zmultiples c) (x : \u03b1) : f (a +\u1d65 x) = f x := by\n  rcases a with \u27e8_, m, rfl\u27e9\n  simp [AddSubgroup.vadd_def, add_comm _ x, hf.zsmul m x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc : \u03b1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddCommGroup \u03b1\nhf : sorry\na : \u21a5(AddSubgroup.zmultiples c)\nx : \u03b1\n\u22a2 f (a +\u1d65 x) = f x"}, {"line": "rcases a with \u27e8_, m, rfl\u27e9", "tactic_state": "case mk.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc : \u03b1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddCommGroup \u03b1\nhf : sorry\nx : \u03b1\nm : \u2124\n\u22a2 f (\u27e8(fun x => x \u2022 c) m, \u22ef\u27e9 +\u1d65 x) = f x"}, {"line": "simp [AddSubgroup.vadd_def, add_comm _ x, hf.zsmul m x]", "tactic_state": "case mk.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc : \u03b1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddCommGroup \u03b1\nhf : sorry\nx : \u03b1\nm : \u2124\n\u22a2 f (m \u2022 c + x) = f x"}]}
{"declaration": "theorem Periodic.map_vadd_multiples [AddCommMonoid \u03b1] (hf : Periodic f c)\n    (a : AddSubmonoid.multiples c) (x : \u03b1) : f (a +\u1d65 x) = f x := by\n  rcases a with \u27e8_, m, rfl\u27e9\n  simp [AddSubmonoid.vadd_def, add_comm _ x, hf.nsmul m x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc : \u03b1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddCommMonoid \u03b1\nhf : sorry\na : \u21a5(AddSubmonoid.multiples c)\nx : \u03b1\n\u22a2 f (a +\u1d65 x) = f x"}, {"line": "rcases a with \u27e8_, m, rfl\u27e9", "tactic_state": "case mk.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc : \u03b1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddCommMonoid \u03b1\nhf : sorry\nx : \u03b1\nm : \u2115\n\u22a2 f (\u27e8(fun i => i \u2022 c) m, \u22ef\u27e9 +\u1d65 x) = f x"}, {"line": "simp [AddSubmonoid.vadd_def, add_comm _ x, hf.nsmul m x]", "tactic_state": "case mk.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc : \u03b1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : AddCommMonoid \u03b1\nhf : sorry\nx : \u03b1\nm : \u2115\n\u22a2 f (m \u2022 c + x) = f x"}]}
{"declaration": "protected theorem Antiperiodic.periodic [AddMonoid \u03b1] [InvolutiveNeg \u03b2]\n    (h : Antiperiodic f c) : Periodic f (2 \u2022 c) := by simp [two_nsmul, \u2190 add_assoc, h _]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_4\nAntiperiodic : x\u271d\u00b9\nx\u271d : Sort u_5\nPeriodic : x\u271d\ninst\u271d\u00b9 : AddMonoid \u03b1\ninst\u271d : InvolutiveNeg \u03b2\nh : sorry\n\u22a2 sorry"}, {"line": "simp [two_nsmul, \u2190 add_assoc, h _]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_4\nAntiperiodic : x\u271d\u00b9\nx\u271d : Sort u_5\nPeriodic : x\u271d\ninst\u271d\u00b9 : AddMonoid \u03b1\ninst\u271d : InvolutiveNeg \u03b2\nh : sorry\n\u22a2 sorry ()"}]}
{"declaration": "protected theorem Antiperiodic.eq [AddZeroClass \u03b1] [Neg \u03b2] (h : Antiperiodic f c) : f c = -f 0 := by\n  simpa only [zero_add] using h 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc : \u03b1\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b9 : AddZeroClass \u03b1\ninst\u271d : Neg \u03b2\nh : sorry\n\u22a2 f c = -f 0"}, {"line": "simpa only [zero_add] using h 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antiperiodic.sub_eq [AddGroup \u03b1] [InvolutiveNeg \u03b2] (h : Antiperiodic f c) (x : \u03b1) :\n    f (x - c) = -f x := by simp only [\u2190 neg_eq_iff_eq_neg, \u2190 h (x - c), sub_add_cancel]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc : \u03b1\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b9 : AddGroup \u03b1\ninst\u271d : InvolutiveNeg \u03b2\nh : sorry\nx : \u03b1\n\u22a2 f (x - c) = -f x"}, {"line": "simp only [\u2190 neg_eq_iff_eq_neg, \u2190 h (x - c), sub_add_cancel]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc : \u03b1\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b9 : AddGroup \u03b1\ninst\u271d : InvolutiveNeg \u03b2\nh : sorry\nx : \u03b1\n\u22a2 -f (x - c) = f x"}]}
{"declaration": "theorem Antiperiodic.sub_eq' [SubtractionCommMonoid \u03b1] [Neg \u03b2] (h : Antiperiodic f c) :\n    f (c - x) = -f (-x) := by simpa only [sub_eq_neg_add] using h (-x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc x : \u03b1\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b9 : SubtractionCommMonoid \u03b1\ninst\u271d : Neg \u03b2\nh : sorry\n\u22a2 f (c - x) = -f (-x)"}, {"line": "simpa only [sub_eq_neg_add] using h (-x)", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Antiperiodic.neg [AddGroup \u03b1] [InvolutiveNeg \u03b2] (h : Antiperiodic f c) :\n    Antiperiodic f (-c) := by simpa only [sub_eq_add_neg, Antiperiodic] using h.sub_eq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b9 : AddGroup \u03b1\ninst\u271d : InvolutiveNeg \u03b2\nh : sorry\n\u22a2 sorry"}, {"line": "simpa only [sub_eq_add_neg, Antiperiodic] using h.sub_eq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antiperiodic.neg_eq [AddGroup \u03b1] [InvolutiveNeg \u03b2] (h : Antiperiodic f c) :\n    f (-c) = -f 0 := by\n  simpa only [zero_add] using h.neg 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc : \u03b1\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b9 : AddGroup \u03b1\ninst\u271d : InvolutiveNeg \u03b2\nh : sorry\n\u22a2 f (-c) = -f 0"}, {"line": "simpa only [zero_add] using h.neg 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antiperiodic.sub_nsmul_eq [AddGroup \u03b1] [SubtractionMonoid \u03b2] (h : Antiperiodic f c)\n    (n : \u2115) : f (x - n \u2022 c) = (-1) ^ n \u2022 f x := by\n  simpa only [Int.reduceNeg, natCast_zsmul] using h.sub_zsmul_eq n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc x : \u03b1\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b9 : AddGroup \u03b1\ninst\u271d : SubtractionMonoid \u03b2\nh : sorry\nn : \u2115\n\u22a2 f (x - n \u2022 c) = (-1) ^ n \u2022 f x"}, {"line": "simpa only [Int.reduceNeg, natCast_zsmul] using h.sub_zsmul_eq n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antiperiodic.nsmul_sub_eq [AddCommGroup \u03b1] [SubtractionMonoid \u03b2] (h : Antiperiodic f c)\n    (n : \u2115) : f (n \u2022 c - x) = (-1) ^ n \u2022 f (-x) := by\n  simpa only [Int.reduceNeg, natCast_zsmul] using h.zsmul_sub_eq n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc x : \u03b1\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b9 : AddCommGroup \u03b1\ninst\u271d : SubtractionMonoid \u03b2\nh : sorry\nn : \u2115\n\u22a2 f (n \u2022 c - x) = (-1) ^ n \u2022 f (-x)"}, {"line": "simpa only [Int.reduceNeg, natCast_zsmul] using h.zsmul_sub_eq n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antiperiodic.sub_const [SubtractionCommMonoid \u03b1] [Neg \u03b2] (h : Antiperiodic f c) (a : \u03b1) :\n    Antiperiodic (fun x => f (x - a)) c := by\n  simpa only [sub_eq_add_neg] using h.add_const (-a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b9 : SubtractionCommMonoid \u03b1\ninst\u271d : Neg \u03b2\nh : sorry\na : \u03b1\n\u22a2 sorry"}, {"line": "simpa only [sub_eq_add_neg] using h.add_const (-a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antiperiodic.smul [Add \u03b1] [Monoid \u03b3] [AddGroup \u03b2] [DistribMulAction \u03b3 \u03b2]\n    (h : Antiperiodic f c) (a : \u03b3) : Antiperiodic (a \u2022 f) c := by simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b3 : Add \u03b1\ninst\u271d\u00b2 : Monoid \u03b3\ninst\u271d\u00b9 : AddGroup \u03b2\ninst\u271d : DistribMulAction \u03b3 \u03b2\nh : sorry\na : \u03b3\n\u22a2 sorry"}, {"line": "simp_all", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b3 : Add \u03b1\ninst\u271d\u00b2 : Monoid \u03b3\ninst\u271d\u00b9 : AddGroup \u03b2\ninst\u271d : DistribMulAction \u03b3 \u03b2\nh : sorry\na : \u03b3\n\u22a2 sorry ()"}]}
{"declaration": "theorem Antiperiodic.const_inv_smul [AddMonoid \u03b1] [Neg \u03b2] [Group \u03b3] [DistribMulAction \u03b3 \u03b1]\n    (h : Antiperiodic f c) (a : \u03b3) : Antiperiodic (fun x => f (a\u207b\u00b9 \u2022 x)) (a \u2022 c) := by\n  simpa only [inv_inv] using h.const_smul a\u207b\u00b9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b3 : AddMonoid \u03b1\ninst\u271d\u00b2 : Neg \u03b2\ninst\u271d\u00b9 : Group \u03b3\ninst\u271d : DistribMulAction \u03b3 \u03b1\nh : sorry\na : \u03b3\n\u22a2 sorry"}, {"line": "simpa only [inv_inv] using h.const_smul a\u207b\u00b9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antiperiodic.add [AddSemigroup \u03b1] [InvolutiveNeg \u03b2] (h1 : Antiperiodic f c\u2081)\n    (h2 : Antiperiodic f c\u2082) : Periodic f (c\u2081 + c\u2082) := by simp_all [\u2190 add_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_4\nAntiperiodic : x\u271d\u00b9\nx\u271d : Sort u_5\nPeriodic : x\u271d\ninst\u271d\u00b9 : AddSemigroup \u03b1\ninst\u271d : InvolutiveNeg \u03b2\nh1 : sorry\nh2 : sorry\n\u22a2 sorry"}, {"line": "simp_all [\u2190 add_assoc]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_4\nAntiperiodic : x\u271d\u00b9\nx\u271d : Sort u_5\nPeriodic : x\u271d\ninst\u271d\u00b9 : AddSemigroup \u03b1\ninst\u271d : InvolutiveNeg \u03b2\nh1 : sorry\nh2 : sorry\n\u22a2 sorry ()"}]}
{"declaration": "theorem Antiperiodic.sub [AddGroup \u03b1] [InvolutiveNeg \u03b2] (h1 : Antiperiodic f c\u2081)\n    (h2 : Antiperiodic f c\u2082) : Periodic f (c\u2081 - c\u2082) := by\n  simpa only [sub_eq_add_neg] using h1.add h2.neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_4\nAntiperiodic : x\u271d\u00b9\nx\u271d : Sort u_5\nPeriodic : x\u271d\ninst\u271d\u00b9 : AddGroup \u03b1\ninst\u271d : InvolutiveNeg \u03b2\nh1 : sorry\nh2 : sorry\n\u22a2 sorry"}, {"line": "simpa only [sub_eq_add_neg] using h1.add h2.neg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Periodic.add_antiperiod [AddSemigroup \u03b1] [Neg \u03b2] (h1 : Periodic f c\u2081)\n    (h2 : Antiperiodic f c\u2082) : Antiperiodic f (c\u2081 + c\u2082) := by simp_all [\u2190 add_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_4\nPeriodic : x\u271d\u00b9\nx\u271d : Sort u_5\nAntiperiodic : x\u271d\ninst\u271d\u00b9 : AddSemigroup \u03b1\ninst\u271d : Neg \u03b2\nh1 : sorry\nh2 : sorry\n\u22a2 sorry"}, {"line": "simp_all [\u2190 add_assoc]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_4\nPeriodic : x\u271d\u00b9\nx\u271d : Sort u_5\nAntiperiodic : x\u271d\ninst\u271d\u00b9 : AddSemigroup \u03b1\ninst\u271d : Neg \u03b2\nh1 : sorry\nh2 : sorry\n\u22a2 sorry ()"}]}
{"declaration": "theorem Periodic.sub_antiperiod [AddGroup \u03b1] [InvolutiveNeg \u03b2] (h1 : Periodic f c\u2081)\n    (h2 : Antiperiodic f c\u2082) : Antiperiodic f (c\u2081 - c\u2082) := by\n  simpa only [sub_eq_add_neg] using h1.add_antiperiod h2.neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_4\nPeriodic : x\u271d\u00b9\nx\u271d : Sort u_5\nAntiperiodic : x\u271d\ninst\u271d\u00b9 : AddGroup \u03b1\ninst\u271d : InvolutiveNeg \u03b2\nh1 : sorry\nh2 : sorry\n\u22a2 sorry"}, {"line": "simpa only [sub_eq_add_neg] using h1.add_antiperiod h2.neg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antiperiodic.mul [Add \u03b1] [Mul \u03b2] [HasDistribNeg \u03b2] (hf : Antiperiodic f c)\n    (hg : Antiperiodic g c) : Periodic (f * g) c := by simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_4\nAntiperiodic : x\u271d\u00b9\nx\u271d : Sort u_5\nPeriodic : x\u271d\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Mul \u03b2\ninst\u271d : HasDistribNeg \u03b2\nhf : sorry\nhg : sorry\n\u22a2 sorry"}, {"line": "simp_all", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_4\nAntiperiodic : x\u271d\u00b9\nx\u271d : Sort u_5\nPeriodic : x\u271d\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Mul \u03b2\ninst\u271d : HasDistribNeg \u03b2\nhf : sorry\nhg : sorry\n\u22a2 sorry ()"}]}
{"declaration": "theorem Antiperiodic.div [Add \u03b1] [DivisionMonoid \u03b2] [HasDistribNeg \u03b2] (hf : Antiperiodic f c)\n    (hg : Antiperiodic g c) : Periodic (f / g) c := by simp_all [neg_div_neg_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_4\nAntiperiodic : x\u271d\u00b9\nx\u271d : Sort u_5\nPeriodic : x\u271d\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b2\ninst\u271d : HasDistribNeg \u03b2\nhf : sorry\nhg : sorry\n\u22a2 sorry"}, {"line": "simp_all [neg_div_neg_eq]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d\u00b9 : Sort u_4\nAntiperiodic : x\u271d\u00b9\nx\u271d : Sort u_5\nPeriodic : x\u271d\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b2\ninst\u271d : HasDistribNeg \u03b2\nhf : sorry\nhg : sorry\n\u22a2 sorry ()"}]}
{"declaration": "theorem IsSumSq.add [AddMonoid R] [Mul R] {s\u2081 s\u2082 : R}\n    (h\u2081 : IsSumSq s\u2081) (h\u2082 : IsSumSq s\u2082) : IsSumSq (s\u2081 + s\u2082) := by\n  induction h\u2081 <;> simp_all [add_assoc, sq_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/SumsOfSquares.lean", "context": {"open": [], "variables": ["{R : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : AddMonoid R\ninst\u271d : Mul R\ns\u2081 s\u2082 : R\nh\u2081 : IsSumSq s\u2081\nh\u2082 : IsSumSq s\u2082\n\u22a2 IsSumSq (s\u2081 + s\u2082)"}, {"line": "induction h\u2081 <;> simp_all [add_assoc, sq_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsSumSq.sum [AddCommMonoid R] [Mul R] {\u03b9 : Type*} {I : Finset \u03b9} {s : \u03b9 \u2192 R}\n    (hs : \u2200 i \u2208 I, IsSumSq <| s i) : IsSumSq (\u2211 i \u2208 I, s i) := by\n  simpa using sum_mem (S := AddSubmonoid.sumSq _) hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/SumsOfSquares.lean", "context": {"open": [], "variables": ["{R : Type*}", "{T : Type*} [AddMonoid T] [Mul T] {s : T}", "(T) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : Mul R\n\u03b9 : Type u_3\nI : Finset \u03b9\ns : \u03b9 \u2192 R\nhs : \u2200 i \u2208 I, IsSumSq (s i)\n\u22a2 IsSumSq (\u2211 i \u2208 I, s i)"}, {"line": "simpa using sum_mem (S := AddSubmonoid.sumSq _) hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsSumSq.mul [NonUnitalCommSemiring R] {s\u2081 s\u2082 : R}\n    (h\u2081 : IsSumSq s\u2081) (h\u2082 : IsSumSq s\u2082) : IsSumSq (s\u2081 * s\u2082) := by\n  simpa using mul_mem (by simpa : _ \u2208 NonUnitalSubsemiring.sumSq R) (by simpa)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/SumsOfSquares.lean", "context": {"open": [], "variables": ["{R : Type*}", "{T : Type*} [AddMonoid T] [Mul T] {s : T}", "(T) in", "{T : Type*} [NonUnitalCommSemiring T]", "(T) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : NonUnitalCommSemiring R\ns\u2081 s\u2082 : R\nh\u2081 : IsSumSq s\u2081\nh\u2082 : IsSumSq s\u2082\n\u22a2 IsSumSq (s\u2081 * s\u2082)"}, {"line": "simpa using mul_mem (by simpa : _ \u2208 NonUnitalSubsemiring.sumSq R) (by simpa)", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem Submonoid.square_subsemiringClosure {T : Type*} [CommSemiring T] :\n    (Submonoid.square T).subsemiringClosure = .closure {x : T | IsSquare x} := by\n  simp [Submonoid.subsemiringClosure_eq_closure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/SumsOfSquares.lean", "context": {"open": [], "variables": ["{R : Type*}", "{T : Type*} [AddMonoid T] [Mul T] {s : T}", "(T) in", "{T : Type*} [NonUnitalCommSemiring T]", "(T) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : Type u_3\ninst\u271d : CommSemiring T\n\u22a2 (square T).subsemiringClosure = Subsemiring.closure {x | IsSquare x}"}, {"line": "simp [Submonoid.subsemiringClosure_eq_closure]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsSumSq.prod [CommSemiring R] {\u03b9 : Type*} {I : Finset \u03b9} {x : \u03b9 \u2192 R}\n    (hx : \u2200 i \u2208 I, IsSumSq <| x i) : IsSumSq (\u220f i \u2208 I, x i) := by\n  simpa using prod_mem (S := Subsemiring.sumSq R) (by simpa)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/SumsOfSquares.lean", "context": {"open": [], "variables": ["{R : Type*}", "{T : Type*} [AddMonoid T] [Mul T] {s : T}", "(T) in", "{T : Type*} [NonUnitalCommSemiring T]", "(T) in", "{T : Type*} [CommSemiring T]", "(T) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\n\u03b9 : Type u_3\nI : Finset \u03b9\nx : \u03b9 \u2192 R\nhx : \u2200 i \u2208 I, IsSumSq (x i)\n\u22a2 IsSumSq (\u220f i \u2208 I, x i)"}, {"line": "simpa using prod_mem (S := Subsemiring.sumSq R) (by simpa)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isDomain_iff_noZeroDivisors_and_nontrivial [Ring \u03b1] :\n    IsDomain \u03b1 \u2194 NoZeroDivisors \u03b1 \u2227 Nontrivial \u03b1 := by\n  rw [\u2190 isCancelMulZero_iff_noZeroDivisors]\n  rw [isDomain_iff_cancelMulZero_and_nontrivial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Basic.lean", "context": {"open": ["Function", "MulOpposite"], "variables": ["{R : Type*}", "{\u03b1 : Type*} [Mul \u03b1] [HasDistribNeg \u03b1]", "{\u03b1 : Type*} [NonUnitalCommRing \u03b1]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b9 : NonUnitalCommRing \u03b1\ninst\u271d : Ring \u03b1\n\u22a2 IsDomain \u03b1 \u2194 NoZeroDivisors \u03b1 \u2227 Nontrivial \u03b1"}, {"line": "rw [\u2190 isCancelMulZero_iff_noZeroDivisors]", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b9 : NonUnitalCommRing \u03b1\ninst\u271d : Ring \u03b1\n\u22a2 IsDomain \u03b1 \u2194 IsCancelMulZero \u03b1 \u2227 Nontrivial \u03b1"}, {"line": "rw [isDomain_iff_cancelMulZero_and_nontrivial]", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b9 : NonUnitalCommRing \u03b1\ninst\u271d : Ring \u03b1\n\u22a2 IsCancelMulZero \u03b1 \u2227 Nontrivial \u03b1 \u2194 IsCancelMulZero \u03b1 \u2227 Nontrivial \u03b1"}]}
{"declaration": "lemma neg_div (a b : R) : -b / a = -(b / a) := by\n  rw [neg_eq_neg_one_mul]\n  rw [mul_div_assoc]\n  rw [\u2190 neg_eq_neg_one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Basic.lean", "context": {"open": ["Function", "MulOpposite"], "variables": ["{R : Type*}", "{\u03b1 : Type*} [Mul \u03b1] [HasDistribNeg \u03b1]", "{\u03b1 : Type*} [NonUnitalCommRing \u03b1]", "(\u03b1)", "[DivisionMonoid R] [HasDistribNeg R] {a b : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : DivisionMonoid R\ninst\u271d : HasDistribNeg R\na b : R\n\u22a2 -b / a = -(b / a)"}, {"line": "rw [neg_eq_neg_one_mul]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : DivisionMonoid R\ninst\u271d : HasDistribNeg R\na b : R\n\u22a2 -1 * b / a = -(b / a)"}, {"line": "rw [mul_div_assoc]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : DivisionMonoid R\ninst\u271d : HasDistribNeg R\na b : R\n\u22a2 -1 * (b / a) = -(b / a)"}, {"line": "rw [\u2190 neg_eq_neg_one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma neg_div' (a b : R) : -(b / a) = -b / a := by simp [neg_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Basic.lean", "context": {"open": ["Function", "MulOpposite"], "variables": ["{R : Type*}", "{\u03b1 : Type*} [Mul \u03b1] [HasDistribNeg \u03b1]", "{\u03b1 : Type*} [NonUnitalCommRing \u03b1]", "(\u03b1)", "[DivisionMonoid R] [HasDistribNeg R] {a b : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : DivisionMonoid R\ninst\u271d : HasDistribNeg R\na b : R\n\u22a2 -(b / a) = -b / a"}, {"line": "simp [neg_div]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma neg_div_neg_eq (a b : R) : -a / -b = a / b := by rw [div_neg_eq_neg_div, neg_div, neg_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Basic.lean", "context": {"open": ["Function", "MulOpposite"], "variables": ["{R : Type*}", "{\u03b1 : Type*} [Mul \u03b1] [HasDistribNeg \u03b1]", "{\u03b1 : Type*} [NonUnitalCommRing \u03b1]", "(\u03b1)", "[DivisionMonoid R] [HasDistribNeg R] {a b : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : DivisionMonoid R\ninst\u271d : HasDistribNeg R\na b : R\n\u22a2 -a / -b = a / b"}, {"line": "rw [div_neg_eq_neg_div, neg_div, neg_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma neg_inv : -a\u207b\u00b9 = (-a)\u207b\u00b9 := by rw [inv_eq_one_div, inv_eq_one_div, div_neg_eq_neg_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Basic.lean", "context": {"open": ["Function", "MulOpposite"], "variables": ["{R : Type*}", "{\u03b1 : Type*} [Mul \u03b1] [HasDistribNeg \u03b1]", "{\u03b1 : Type*} [NonUnitalCommRing \u03b1]", "(\u03b1)", "[DivisionMonoid R] [HasDistribNeg R] {a b : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : DivisionMonoid R\ninst\u271d : HasDistribNeg R\na : R\n\u22a2 -a\u207b\u00b9 = (-a)\u207b\u00b9"}, {"line": "rw [inv_eq_one_div, inv_eq_one_div, div_neg_eq_neg_div]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma div_neg (a : R) : a / -b = -(a / b) := by rw [\u2190 div_neg_eq_neg_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Basic.lean", "context": {"open": ["Function", "MulOpposite"], "variables": ["{R : Type*}", "{\u03b1 : Type*} [Mul \u03b1] [HasDistribNeg \u03b1]", "{\u03b1 : Type*} [NonUnitalCommRing \u03b1]", "(\u03b1)", "[DivisionMonoid R] [HasDistribNeg R] {a b : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : DivisionMonoid R\ninst\u271d : HasDistribNeg R\nb a : R\n\u22a2 a / -b = -(a / b)"}, {"line": "rw [\u2190 div_neg_eq_neg_div]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_neg : (-a)\u207b\u00b9 = -a\u207b\u00b9 := by rw [neg_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Basic.lean", "context": {"open": ["Function", "MulOpposite"], "variables": ["{R : Type*}", "{\u03b1 : Type*} [Mul \u03b1] [HasDistribNeg \u03b1]", "{\u03b1 : Type*} [NonUnitalCommRing \u03b1]", "(\u03b1)", "[DivisionMonoid R] [HasDistribNeg R] {a b : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : DivisionMonoid R\ninst\u271d : HasDistribNeg R\na : R\n\u22a2 (-a)\u207b\u00b9 = -a\u207b\u00b9"}, {"line": "rw [neg_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_neg_one : (-1 : R)\u207b\u00b9 = -1 := by rw [\u2190 neg_inv, inv_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Basic.lean", "context": {"open": ["Function", "MulOpposite"], "variables": ["{R : Type*}", "{\u03b1 : Type*} [Mul \u03b1] [HasDistribNeg \u03b1]", "{\u03b1 : Type*} [NonUnitalCommRing \u03b1]", "(\u03b1)", "[DivisionMonoid R] [HasDistribNeg R] {a b : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : DivisionMonoid R\ninst\u271d : HasDistribNeg R\n\u22a2 (-1)\u207b\u00b9 = -1"}, {"line": "rw [\u2190 neg_inv, inv_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma neg_sq (a : R) : (-a) ^ 2 = a ^ 2 := by simp [sq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Commute.lean", "context": {"open": ["Function"], "variables": ["{R : Type u}", "[Mul R] [HasDistribNeg R] {a b : R}", "[MulOneClass R] [HasDistribNeg R]", "[NonUnitalNonAssocRing R] {a b c : R}", "[Ring R] {a b : R}", "[NoZeroDivisors R]", "(R)", "[Monoid R] [HasDistribNeg R]", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2078 : Mul R\ninst\u271d\u2077 : HasDistribNeg R\ninst\u271d\u2076 : MulOneClass R\ninst\u271d\u2075 : HasDistribNeg R\ninst\u271d\u2074 : NonUnitalNonAssocRing R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : NoZeroDivisors R\ninst\u271d\u00b9 : Monoid R\ninst\u271d : HasDistribNeg R\na : R\n\u22a2 (-a) ^ 2 = a ^ 2"}, {"line": "simp [sq]", "tactic_state": "R : Type u\ninst\u271d\u2078 : Mul R\ninst\u271d\u2077 : HasDistribNeg R\ninst\u271d\u2076 : MulOneClass R\ninst\u271d\u2075 : HasDistribNeg R\ninst\u271d\u2074 : NonUnitalNonAssocRing R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : NoZeroDivisors R\ninst\u271d\u00b9 : Monoid R\ninst\u271d : HasDistribNeg R\na : R\n\u22a2 -a * -a = a * a"}]}
{"declaration": "theorem mul_add_one [LeftDistribClass \u03b1] (a b : \u03b1) : a * (b + 1) = a * b + a := by\n  rw [mul_add]\n  rw [mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {R : Type v}", "[Add \u03b1] [MulOneClass \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : LeftDistribClass \u03b1\na b : \u03b1\n\u22a2 a * (b + 1) = a * b + a"}, {"line": "rw [mul_add]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : LeftDistribClass \u03b1\na b : \u03b1\n\u22a2 a * b + a * 1 = a * b + a\n---\n\u03b1 : Type u\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : LeftDistribClass \u03b1\na b : \u03b1\n\u22a2 LeftDistribClass \u03b1"}, {"line": "rw [mul_one]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : LeftDistribClass \u03b1\na b : \u03b1\n\u22a2 LeftDistribClass \u03b1"}]}
{"declaration": "theorem one_add_mul [RightDistribClass \u03b1] (a b : \u03b1) : (1 + a) * b = b + a * b := by\n  rw [add_mul]\n  rw [one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {R : Type v}", "[Add \u03b1] [MulOneClass \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : RightDistribClass \u03b1\na b : \u03b1\n\u22a2 (1 + a) * b = b + a * b"}, {"line": "rw [add_mul]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : RightDistribClass \u03b1\na b : \u03b1\n\u22a2 1 * b + a * b = b + a * b\n---\n\u03b1 : Type u\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : RightDistribClass \u03b1\na b : \u03b1\n\u22a2 RightDistribClass \u03b1"}, {"line": "rw [one_mul]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : RightDistribClass \u03b1\na b : \u03b1\n\u22a2 RightDistribClass \u03b1"}]}
{"declaration": "theorem mul_one_add [LeftDistribClass \u03b1] (a b : \u03b1) : a * (1 + b) = a + a * b := by\n  rw [mul_add]\n  rw [mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {R : Type v}", "[Add \u03b1] [MulOneClass \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : LeftDistribClass \u03b1\na b : \u03b1\n\u22a2 a * (1 + b) = a + a * b"}, {"line": "rw [mul_add]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : LeftDistribClass \u03b1\na b : \u03b1\n\u22a2 a * 1 + a * b = a + a * b\n---\n\u03b1 : Type u\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : LeftDistribClass \u03b1\na b : \u03b1\n\u22a2 LeftDistribClass \u03b1"}, {"line": "rw [mul_one]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : LeftDistribClass \u03b1\na b : \u03b1\n\u22a2 LeftDistribClass \u03b1"}]}
{"declaration": "lemma ite_zero_mul : ite P a 0 * b = ite P (a * b) 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {R : Type v}", "[Add \u03b1] [MulOneClass \u03b1]", "[NonAssocSemiring \u03b1]", "[MulZeroClass \u03b1] (P Q : Prop) [Decidable P] [Decidable Q] (a b : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 : Add \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : NonAssocSemiring \u03b1\ninst\u271d\u00b9 : MulZeroClass \u03b1\nP : Prop\ninst\u271d : Decidable P\na b : \u03b1\n\u22a2 (if P then a else 0) * b = if P then a * b else 0"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 : Add \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : NonAssocSemiring \u03b1\ninst\u271d\u00b9 : MulZeroClass \u03b1\nP : Prop\ninst\u271d : Decidable P\na b : \u03b1\n\u22a2 (if P then a * b else 0 * b) = if P then a * b else 0"}]}
{"declaration": "lemma mul_ite_zero : a * ite P b 0 = ite P (a * b) 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {R : Type v}", "[Add \u03b1] [MulOneClass \u03b1]", "[NonAssocSemiring \u03b1]", "[MulZeroClass \u03b1] (P Q : Prop) [Decidable P] [Decidable Q] (a b : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 : Add \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : NonAssocSemiring \u03b1\ninst\u271d\u00b9 : MulZeroClass \u03b1\nP : Prop\ninst\u271d : Decidable P\na b : \u03b1\n\u22a2 (a * if P then b else 0) = if P then a * b else 0"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 : Add \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : NonAssocSemiring \u03b1\ninst\u271d\u00b9 : MulZeroClass \u03b1\nP : Prop\ninst\u271d : Decidable P\na b : \u03b1\n\u22a2 (if P then a * b else a * 0) = if P then a * b else 0"}]}
{"declaration": "theorem mul_boole {\u03b1} [MulZeroOneClass \u03b1] (P : Prop) [Decidable P] (a : \u03b1) :\n    (a * if P then 1 else 0) = if P then a else 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {R : Type v}", "[Add \u03b1] [MulOneClass \u03b1]", "[NonAssocSemiring \u03b1]", "[MulZeroClass \u03b1] (P Q : Prop) [Decidable P] [Decidable Q] (a b : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : MulZeroOneClass \u03b1\nP : Prop\ninst\u271d : Decidable P\na : \u03b1\n\u22a2 (a * if P then 1 else 0) = if P then a else 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem boole_mul {\u03b1} [MulZeroOneClass \u03b1] (P : Prop) [Decidable P] (a : \u03b1) :\n    (if P then 1 else 0) * a = if P then a else 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {R : Type v}", "[Add \u03b1] [MulOneClass \u03b1]", "[NonAssocSemiring \u03b1]", "[MulZeroClass \u03b1] (P Q : Prop) [Decidable P] [Decidable Q] (a b : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : MulZeroOneClass \u03b1\nP : Prop\ninst\u271d : Decidable P\na : \u03b1\n\u22a2 (if P then 1 else 0) * a = if P then a else 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_mul_neg (a b : \u03b1) : -a * -b = a * b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {R : Type v}", "[Add \u03b1] [MulOneClass \u03b1]", "[NonAssocSemiring \u03b1]", "[MulZeroClass \u03b1] (P Q : Prop) [Decidable P] [Decidable Q] (a b : \u03b1)", "[CommSemiring \u03b1]", "[Mul \u03b1] [HasDistribNeg \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2076 : Add \u03b1\ninst\u271d\u2075 : MulOneClass \u03b1\ninst\u271d\u2074 : NonAssocSemiring \u03b1\ninst\u271d\u00b3 : MulZeroClass \u03b1\ninst\u271d\u00b2 : CommSemiring \u03b1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : HasDistribNeg \u03b1\na b : \u03b1\n\u22a2 -a * -b = a * b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_mul_comm (a b : \u03b1) : -a * b = a * -b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {R : Type v}", "[Add \u03b1] [MulOneClass \u03b1]", "[NonAssocSemiring \u03b1]", "[MulZeroClass \u03b1] (P Q : Prop) [Decidable P] [Decidable Q] (a b : \u03b1)", "[CommSemiring \u03b1]", "[Mul \u03b1] [HasDistribNeg \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2076 : Add \u03b1\ninst\u271d\u2075 : MulOneClass \u03b1\ninst\u271d\u2074 : NonAssocSemiring \u03b1\ninst\u271d\u00b3 : MulZeroClass \u03b1\ninst\u271d\u00b2 : CommSemiring \u03b1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : HasDistribNeg \u03b1\na b : \u03b1\n\u22a2 -a * b = a * -b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_eq_neg_one_mul (a : \u03b1) : -a = -1 * a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {R : Type v}", "[Add \u03b1] [MulOneClass \u03b1]", "[NonAssocSemiring \u03b1]", "[MulZeroClass \u03b1] (P Q : Prop) [Decidable P] [Decidable Q] (a b : \u03b1)", "[CommSemiring \u03b1]", "[Mul \u03b1] [HasDistribNeg \u03b1]", "[MulOneClass \u03b1] [HasDistribNeg \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2078 : Add \u03b1\ninst\u271d\u2077 : MulOneClass \u03b1\ninst\u271d\u2076 : NonAssocSemiring \u03b1\ninst\u271d\u2075 : MulZeroClass \u03b1\ninst\u271d\u2074 : CommSemiring \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : HasDistribNeg \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : HasDistribNeg \u03b1\na : \u03b1\n\u22a2 -a = -1 * a"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2078 : Add \u03b1\ninst\u271d\u2077 : MulOneClass \u03b1\ninst\u271d\u2076 : NonAssocSemiring \u03b1\ninst\u271d\u2075 : MulZeroClass \u03b1\ninst\u271d\u2074 : CommSemiring \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : HasDistribNeg \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : HasDistribNeg \u03b1\na : \u03b1\n\u22a2 a = 1 * a"}]}
{"declaration": "theorem mul_neg_one (a : \u03b1) : a * -1 = -a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {R : Type v}", "[Add \u03b1] [MulOneClass \u03b1]", "[NonAssocSemiring \u03b1]", "[MulZeroClass \u03b1] (P Q : Prop) [Decidable P] [Decidable Q] (a b : \u03b1)", "[CommSemiring \u03b1]", "[Mul \u03b1] [HasDistribNeg \u03b1]", "[MulOneClass \u03b1] [HasDistribNeg \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2078 : Add \u03b1\ninst\u271d\u2077 : MulOneClass \u03b1\ninst\u271d\u2076 : NonAssocSemiring \u03b1\ninst\u271d\u2075 : MulZeroClass \u03b1\ninst\u271d\u2074 : CommSemiring \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : HasDistribNeg \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : HasDistribNeg \u03b1\na : \u03b1\n\u22a2 a * -1 = -a"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2078 : Add \u03b1\ninst\u271d\u2077 : MulOneClass \u03b1\ninst\u271d\u2076 : NonAssocSemiring \u03b1\ninst\u271d\u2075 : MulZeroClass \u03b1\ninst\u271d\u2074 : CommSemiring \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : HasDistribNeg \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : HasDistribNeg \u03b1\na : \u03b1\n\u22a2 a * 1 = a"}]}
{"declaration": "theorem neg_one_mul (a : \u03b1) : -1 * a = -a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {R : Type v}", "[Add \u03b1] [MulOneClass \u03b1]", "[NonAssocSemiring \u03b1]", "[MulZeroClass \u03b1] (P Q : Prop) [Decidable P] [Decidable Q] (a b : \u03b1)", "[CommSemiring \u03b1]", "[Mul \u03b1] [HasDistribNeg \u03b1]", "[MulOneClass \u03b1] [HasDistribNeg \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2078 : Add \u03b1\ninst\u271d\u2077 : MulOneClass \u03b1\ninst\u271d\u2076 : NonAssocSemiring \u03b1\ninst\u271d\u2075 : MulZeroClass \u03b1\ninst\u271d\u2074 : CommSemiring \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : HasDistribNeg \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : HasDistribNeg \u03b1\na : \u03b1\n\u22a2 -1 * a = -a"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2078 : Add \u03b1\ninst\u271d\u2077 : MulOneClass \u03b1\ninst\u271d\u2076 : NonAssocSemiring \u03b1\ninst\u271d\u2075 : MulZeroClass \u03b1\ninst\u271d\u2074 : CommSemiring \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : HasDistribNeg \u03b1\ninst\u271d\u00b9 : MulOneClass \u03b1\ninst\u271d : HasDistribNeg \u03b1\na : \u03b1\n\u22a2 1 * a = a"}]}
{"declaration": "theorem mul_sub_left_distrib (a b c : \u03b1) : a * (b - c) = a * b - a * c := by\n  simpa only [sub_eq_add_neg, neg_mul_eq_mul_neg] using mul_add a b (-c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {R : Type v}", "[Add \u03b1] [MulOneClass \u03b1]", "[NonAssocSemiring \u03b1]", "[MulZeroClass \u03b1] (P Q : Prop) [Decidable P] [Decidable Q] (a b : \u03b1)", "[CommSemiring \u03b1]", "[Mul \u03b1] [HasDistribNeg \u03b1]", "[MulOneClass \u03b1] [HasDistribNeg \u03b1]", "[MulZeroClass \u03b1] [HasDistribNeg \u03b1]", "[NonUnitalNonAssocRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : Add \u03b1\ninst\u271d\u00b9\u2070 : MulOneClass \u03b1\ninst\u271d\u2079 : NonAssocSemiring \u03b1\ninst\u271d\u2078 : MulZeroClass \u03b1\ninst\u271d\u2077 : CommSemiring \u03b1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : HasDistribNeg \u03b1\ninst\u271d\u2074 : MulOneClass \u03b1\ninst\u271d\u00b3 : HasDistribNeg \u03b1\ninst\u271d\u00b2 : MulZeroClass \u03b1\ninst\u271d\u00b9 : HasDistribNeg \u03b1\ninst\u271d : NonUnitalNonAssocRing \u03b1\na b c : \u03b1\n\u22a2 a * (b - c) = a * b - a * c"}, {"line": "simpa only [sub_eq_add_neg, neg_mul_eq_mul_neg] using mul_add a b (-c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_sub_right_distrib (a b c : \u03b1) : (a - b) * c = a * c - b * c := by\n  simpa only [sub_eq_add_neg, neg_mul_eq_neg_mul] using add_mul a (-b) c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {R : Type v}", "[Add \u03b1] [MulOneClass \u03b1]", "[NonAssocSemiring \u03b1]", "[MulZeroClass \u03b1] (P Q : Prop) [Decidable P] [Decidable Q] (a b : \u03b1)", "[CommSemiring \u03b1]", "[Mul \u03b1] [HasDistribNeg \u03b1]", "[MulOneClass \u03b1] [HasDistribNeg \u03b1]", "[MulZeroClass \u03b1] [HasDistribNeg \u03b1]", "[NonUnitalNonAssocRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b9 : Add \u03b1\ninst\u271d\u00b9\u2070 : MulOneClass \u03b1\ninst\u271d\u2079 : NonAssocSemiring \u03b1\ninst\u271d\u2078 : MulZeroClass \u03b1\ninst\u271d\u2077 : CommSemiring \u03b1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : HasDistribNeg \u03b1\ninst\u271d\u2074 : MulOneClass \u03b1\ninst\u271d\u00b3 : HasDistribNeg \u03b1\ninst\u271d\u00b2 : MulZeroClass \u03b1\ninst\u271d\u00b9 : HasDistribNeg \u03b1\ninst\u271d : NonUnitalNonAssocRing \u03b1\na b c : \u03b1\n\u22a2 (a - b) * c = a * c - b * c"}, {"line": "simpa only [sub_eq_add_neg, neg_mul_eq_neg_mul] using add_mul a (-b) c", "tactic_state": "No Goals!"}]}
{"declaration": "lemma even_iff_exists_two_mul : Even a \u2194 \u2203 b, a = 2 * b := by simp [even_iff_exists_two_nsmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Parity.lean", "context": {"open": ["MulOpposite"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115} {a : \u03b1}", "[DivisionMonoid \u03b1] [HasDistribNeg \u03b1] {a : \u03b1} {n : \u2124}", "[Semiring \u03b1] [Semiring \u03b2] {a b : \u03b1} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Monoid \u03b1\ninst\u271d\u00b3 : HasDistribNeg \u03b1\ninst\u271d\u00b2 : DivisionMonoid \u03b1\ninst\u271d\u00b9 : HasDistribNeg \u03b1\ninst\u271d : Semiring \u03b1\na : \u03b1\n\u22a2 Even a \u2194 \u2203 b, a = 2 * b"}, {"line": "simp [even_iff_exists_two_nsmul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma even_iff_two_dvd : Even a \u2194 2 \u2223 a := by simp [Even, Dvd.dvd, two_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Parity.lean", "context": {"open": ["MulOpposite"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115} {a : \u03b1}", "[DivisionMonoid \u03b1] [HasDistribNeg \u03b1] {a : \u03b1} {n : \u2124}", "[Semiring \u03b1] [Semiring \u03b2] {a b : \u03b1} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Monoid \u03b1\ninst\u271d\u00b3 : HasDistribNeg \u03b1\ninst\u271d\u00b2 : DivisionMonoid \u03b1\ninst\u271d\u00b9 : HasDistribNeg \u03b1\ninst\u271d : Semiring \u03b1\na : \u03b1\n\u22a2 Even a \u2194 2 \u2223 a"}, {"line": "simp [Even, Dvd.dvd, two_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma even_neg_two : Even (-2 : \u03b1) := by simp only [even_neg, even_two]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Parity.lean", "context": {"open": ["MulOpposite"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115} {a : \u03b1}", "[DivisionMonoid \u03b1] [HasDistribNeg \u03b1] {a : \u03b1} {n : \u2124}", "[Semiring \u03b1] [Semiring \u03b2] {a b : \u03b1} {m n : \u2115}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115}", "[Ring \u03b1] {a b : \u03b1} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2077 : Monoid \u03b1\ninst\u271d\u2076 : HasDistribNeg \u03b1\ninst\u271d\u2075 : DivisionMonoid \u03b1\ninst\u271d\u2074 : HasDistribNeg \u03b1\ninst\u271d\u00b3 : Semiring \u03b1\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : HasDistribNeg \u03b1\ninst\u271d : Ring \u03b1\n\u22a2 Even (-2)"}, {"line": "simp only [even_neg, even_two]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma even_xor_odd (n : \u2115) : Xor' (Even n) (Odd n) := by\n  simp [Xor', \u2190 not_even_iff_odd, Decidable.em (Even n)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Parity.lean", "context": {"open": ["MulOpposite"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115} {a : \u03b1}", "[DivisionMonoid \u03b1] [HasDistribNeg \u03b1] {a : \u03b1} {n : \u2124}", "[Semiring \u03b1] [Semiring \u03b2] {a b : \u03b1} {m n : \u2115}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115}", "[Ring \u03b1] {a b : \u03b1} {n : \u2115}", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 Xor' (Even n) (Odd n)"}, {"line": "simp [Xor', \u2190 not_even_iff_odd, Decidable.em (Even n)]", "tactic_state": "n : \u2115\n\u22a2 Even n \u2228 Odd n"}]}
{"declaration": "lemma even_or_odd' (n : \u2115) : \u2203 k, n = 2 * k \u2228 n = 2 * k + 1 := by\n  simpa only [\u2190 two_mul, exists_or, Odd, Even] using even_or_odd n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Parity.lean", "context": {"open": ["MulOpposite"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115} {a : \u03b1}", "[DivisionMonoid \u03b1] [HasDistribNeg \u03b1] {a : \u03b1} {n : \u2124}", "[Semiring \u03b1] [Semiring \u03b2] {a b : \u03b1} {m n : \u2115}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115}", "[Ring \u03b1] {a b : \u03b1} {n : \u2115}", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2203 k, n = 2 * k \u2228 n = 2 * k + 1"}, {"line": "simpa only [\u2190 two_mul, exists_or, Odd, Even] using even_or_odd n", "tactic_state": "No Goals!"}]}
{"declaration": "example (m n : \u2115) (h : Even m) : \u00acEven (n + 3) \u2194 Even (m ^ 2 + m + n) := by\n  simp [*, two_ne_zero, parity_simps]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Parity.lean", "context": {"open": ["MulOpposite"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115} {a : \u03b1}", "[DivisionMonoid \u03b1] [HasDistribNeg \u03b1] {a : \u03b1} {n : \u2124}", "[Semiring \u03b1] [Semiring \u03b2] {a b : \u03b1} {m n : \u2115}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115}", "[Ring \u03b1] {a b : \u03b1} {n : \u2115}", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2078 : Monoid \u03b1\ninst\u271d\u2077 : HasDistribNeg \u03b1\nn\u271d\u2075 : \u2115\na\u271d\u00b2 : \u03b1\ninst\u271d\u2076 : DivisionMonoid \u03b1\ninst\u271d\u2075 : HasDistribNeg \u03b1\na\u271d\u00b9 : \u03b1\nn\u271d\u2074 : \u2124\ninst\u271d\u2074 : Semiring \u03b1\ninst\u271d\u00b3 : Semiring \u03b2\na\u271d b\u271d : \u03b1\nm\u271d\u00b9 n\u271d\u00b3 : \u2115\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : HasDistribNeg \u03b1\nn\u271d\u00b2 : \u2115\ninst\u271d : Ring \u03b1\na b : \u03b1\nn\u271d\u00b9 m\u271d n\u271d m n : \u2115\nh : Even m\n\u22a2 \u00acEven (n + 3) \u2194 Even (m ^ 2 + m + n)"}, {"line": "simp [*, two_ne_zero, parity_simps]", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u00acEven 25394535 := by decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Parity.lean", "context": {"open": ["MulOpposite"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115} {a : \u03b1}", "[DivisionMonoid \u03b1] [HasDistribNeg \u03b1] {a : \u03b1} {n : \u2124}", "[Semiring \u03b1] [Semiring \u03b2] {a b : \u03b1} {m n : \u2115}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115}", "[Ring \u03b1] {a b : \u03b1} {n : \u2115}", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2078 : Monoid \u03b1\ninst\u271d\u2077 : HasDistribNeg \u03b1\nn\u271d\u2074 : \u2115\na\u271d\u00b2 : \u03b1\ninst\u271d\u2076 : DivisionMonoid \u03b1\ninst\u271d\u2075 : HasDistribNeg \u03b1\na\u271d\u00b9 : \u03b1\nn\u271d\u00b3 : \u2124\ninst\u271d\u2074 : Semiring \u03b1\ninst\u271d\u00b3 : Semiring \u03b2\na\u271d b\u271d : \u03b1\nm\u271d n\u271d\u00b2 : \u2115\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : HasDistribNeg \u03b1\nn\u271d\u00b9 : \u2115\ninst\u271d : Ring \u03b1\na b : \u03b1\nn\u271d m n : \u2115\n\u22a2 \u00acEven 25394535"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "lemma neg_one_pow_congr (h : Even m \u2194 Even n) : (-1 : R) ^ m = (-1) ^ n := by\n  simp [h, neg_one_pow_eq_ite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Parity.lean", "context": {"open": ["MulOpposite", "Nat"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115} {a : \u03b1}", "[DivisionMonoid \u03b1] [HasDistribNeg \u03b1] {a : \u03b1} {n : \u2124}", "[Semiring \u03b1] [Semiring \u03b2] {a b : \u03b1} {m n : \u2115}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115}", "[Ring \u03b1] {a b : \u03b1} {n : \u2115}", "{m n : \u2115}", "{\u03b1 : Type*} {f : \u03b1 \u2192 \u03b1} {n : \u2115}", "{R : Type*} [Monoid R] [HasDistribNeg R] {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\ninst\u271d\u00b9 : Monoid R\ninst\u271d : HasDistribNeg R\nm n : \u2115\nh : Even m \u2194 Even n\n\u22a2 (-1) ^ m = (-1) ^ n"}, {"line": "simp [h, neg_one_pow_eq_ite]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma neg_one_pow_eq_one_iff_even (h : (-1 : R) \u2260 1) :\n    (-1 : R) ^ n = 1 \u2194 Even n := by simp [neg_one_pow_eq_ite, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Parity.lean", "context": {"open": ["MulOpposite", "Nat"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115} {a : \u03b1}", "[DivisionMonoid \u03b1] [HasDistribNeg \u03b1] {a : \u03b1} {n : \u2124}", "[Semiring \u03b1] [Semiring \u03b2] {a b : \u03b1} {m n : \u2115}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115}", "[Ring \u03b1] {a b : \u03b1} {n : \u2115}", "{m n : \u2115}", "{\u03b1 : Type*} {f : \u03b1 \u2192 \u03b1} {n : \u2115}", "{R : Type*} [Monoid R] [HasDistribNeg R] {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\ninst\u271d\u00b9 : Monoid R\ninst\u271d : HasDistribNeg R\nn : \u2115\nh : -1 \u2260 1\n\u22a2 (-1) ^ n = 1 \u2194 Even n"}, {"line": "simp [neg_one_pow_eq_ite, h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma neg_one_pow_eq_neg_one_iff_odd (h : (-1 : R) \u2260 1) :\n    (-1 : R) ^ n = -1 \u2194 Odd n := by simp [neg_one_pow_eq_ite, h.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Parity.lean", "context": {"open": ["MulOpposite", "Nat"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115} {a : \u03b1}", "[DivisionMonoid \u03b1] [HasDistribNeg \u03b1] {a : \u03b1} {n : \u2124}", "[Semiring \u03b1] [Semiring \u03b2] {a b : \u03b1} {m n : \u2115}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115}", "[Ring \u03b1] {a b : \u03b1} {n : \u2115}", "{m n : \u2115}", "{\u03b1 : Type*} {f : \u03b1 \u2192 \u03b1} {n : \u2115}", "{R : Type*} [Monoid R] [HasDistribNeg R] {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\ninst\u271d\u00b9 : Monoid R\ninst\u271d : HasDistribNeg R\nn : \u2115\nh : -1 \u2260 1\n\u22a2 (-1) ^ n = -1 \u2194 Odd n"}, {"line": "simp [neg_one_pow_eq_ite, h.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_eq_zero_or_one_of_two_eq_zero (n : \u2115) (h : (2 : R) = 0) :\n    (n : R) = 0 \u2228 (n : R) = 1 := by\n  obtain hn | hn := Nat.even_or_odd n\n  \u00b7 exact Or.inl <| natCast_eq_zero_of_even_of_two_eq_zero hn h\n  \u00b7 exact Or.inr <| natCast_eq_one_of_odd_of_two_eq_zero hn h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Parity.lean", "context": {"open": ["MulOpposite", "Nat"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115} {a : \u03b1}", "[DivisionMonoid \u03b1] [HasDistribNeg \u03b1] {a : \u03b1} {n : \u2124}", "[Semiring \u03b1] [Semiring \u03b2] {a b : \u03b1} {m n : \u2115}", "[Monoid \u03b1] [HasDistribNeg \u03b1] {n : \u2115}", "[Ring \u03b1] {a b : \u03b1} {n : \u2115}", "{m n : \u2115}", "{\u03b1 : Type*} {f : \u03b1 \u2192 \u03b1} {n : \u2115}", "{R : Type*} [Monoid R] [HasDistribNeg R] {m n : \u2115}", "{R : Type*} [AddMonoidWithOne R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\ninst\u271d : AddMonoidWithOne R\nn : \u2115\nh : 2 = 0\n\u22a2 \u2191n = 0 \u2228 \u2191n = 1"}, {"line": "obtain hn | hn := Nat.even_or_odd n", "tactic_state": "case inl\nR : Type u_6\ninst\u271d : AddMonoidWithOne R\nn : \u2115\nh : 2 = 0\nhn : Even n\n\u22a2 \u2191n = 0 \u2228 \u2191n = 1\n---\ncase inr\nR : Type u_6\ninst\u271d : AddMonoidWithOne R\nn : \u2115\nh : 2 = 0\nhn : Odd n\n\u22a2 \u2191n = 0 \u2228 \u2191n = 1"}, {"line": "\u00b7 exact Or.inl <| natCast_eq_zero_of_even_of_two_eq_zero hn h", "tactic_state": "case inr\nR : Type u_6\ninst\u271d : AddMonoidWithOne R\nn : \u2115\nh : 2 = 0\nhn : Odd n\n\u22a2 \u2191n = 0 \u2228 \u2191n = 1"}, {"line": "\u00b7 exact Or.inr <| natCast_eq_one_of_odd_of_two_eq_zero hn h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_one_right (a : R) : SemiconjBy a (-1) (-1) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Semiconj.lean", "context": {"open": ["Function"], "variables": ["{R : Type u}", "[Mul R] [HasDistribNeg R] {a x y : R}", "[MulOneClass R] [HasDistribNeg R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Mul R\ninst\u271d\u00b2 : HasDistribNeg R\ninst\u271d\u00b9 : MulOneClass R\ninst\u271d : HasDistribNeg R\na : R\n\u22a2 SemiconjBy a (-1) (-1)"}, {"line": "simp", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Mul R\ninst\u271d\u00b2 : HasDistribNeg R\ninst\u271d\u00b9 : MulOneClass R\ninst\u271d : HasDistribNeg R\na : R\n\u22a2 SemiconjBy a 1 1"}]}
{"declaration": "theorem neg_one_left (x : R) : SemiconjBy (-1) x x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Semiconj.lean", "context": {"open": ["Function"], "variables": ["{R : Type u}", "[Mul R] [HasDistribNeg R] {a x y : R}", "[MulOneClass R] [HasDistribNeg R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Mul R\ninst\u271d\u00b2 : HasDistribNeg R\ninst\u271d\u00b9 : MulOneClass R\ninst\u271d : HasDistribNeg R\nx : R\n\u22a2 SemiconjBy (-1) x x"}, {"line": "simp", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Mul R\ninst\u271d\u00b2 : HasDistribNeg R\ninst\u271d\u00b9 : MulOneClass R\ninst\u271d : HasDistribNeg R\nx : R\n\u22a2 SemiconjBy 1 x x"}]}
{"declaration": "theorem neg_divp (a : \u03b1) (u : \u03b1\u02e3) : -(a /\u209a u) = -a /\u209a u := by simp only [divp, neg_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Units.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {R : Type x}", "[Monoid \u03b1] [HasDistribNeg \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : HasDistribNeg \u03b1\na : \u03b1\nu : \u03b1\u02e3\n\u22a2 -(a /\u209a u) = -a /\u209a u"}, {"line": "simp only [divp, neg_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_smul_subset (a b : \u03b1) (s : Set \u03b2) : (a + b) \u2022 s \u2286 a \u2022 s + b \u2022 s := by\n  rintro _ \u27e8x, hx, rfl\u27e9\n  simpa only [add_smul] using add_mem_add (smul_mem_smul_set hx) (smul_mem_smul_set hx)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Action/Pointwise/Set.lean", "context": {"open": ["Function", "scoped Pointwise"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [AddGroup \u03b2] [DistribMulAction \u03b1 \u03b2] (a : \u03b1) (s : Set \u03b1) (t : Set \u03b2)", "[Semiring \u03b1] [AddCommMonoid \u03b2] [Module \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : Monoid \u03b1\ninst\u271d\u2074 : AddGroup \u03b2\ninst\u271d\u00b3 : DistribMulAction \u03b1 \u03b2\ninst\u271d\u00b2 : Semiring \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b2\ninst\u271d : Module \u03b1 \u03b2\na b : \u03b1\ns : Set \u03b2\n\u22a2 (a + b) \u2022 s \u2286 a \u2022 s + b \u2022 s"}, {"line": "rintro _ \u27e8x, hx, rfl\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : Monoid \u03b1\ninst\u271d\u2074 : AddGroup \u03b2\ninst\u271d\u00b3 : DistribMulAction \u03b1 \u03b2\ninst\u271d\u00b2 : Semiring \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b2\ninst\u271d : Module \u03b1 \u03b2\na b : \u03b1\ns : Set \u03b2\nx : \u03b2\nhx : x \u2208 s\n\u22a2 (fun x => (a + b) \u2022 x) x \u2208 a \u2022 s + b \u2022 s"}, {"line": "simpa only [add_smul] using add_mem_add (smul_mem_smul_set hx) (smul_mem_smul_set hx)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dvd_sub (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b - c := by\n  simpa only [\u2190 sub_eq_add_neg] using h\u2081.add h\u2082.neg_right\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Divisibility/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[Semigroup \u03b1] [Semigroup \u03b2] {F : Type*} [EquivLike F \u03b1 \u03b2] [MulEquivClass F \u03b1 \u03b2]", "[Add \u03b1] [Semigroup \u03b1]", "[Semiring \u03b1] {a b c : \u03b1} {m n : \u2115}", "[NonUnitalCommSemiring \u03b1]", "[Semigroup \u03b1] [HasDistribNeg \u03b1] {a b : \u03b1}", "[NonUnitalRing \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : Semigroup \u03b1\ninst\u271d\u2076 : Add \u03b1\ninst\u271d\u2075 : Semigroup \u03b1\ninst\u271d\u2074 : Semiring \u03b1\ninst\u271d\u00b3 : NonUnitalCommSemiring \u03b1\ninst\u271d\u00b2 : Semigroup \u03b1\ninst\u271d\u00b9 : HasDistribNeg \u03b1\ninst\u271d : NonUnitalRing \u03b1\na b c : \u03b1\nh\u2081 : a \u2223 b\nh\u2082 : a \u2223 c\n\u22a2 a \u2223 b - c"}, {"line": "simpa only [\u2190 sub_eq_add_neg] using h\u2081.add h\u2082.neg_right", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toMonoidWithZeroHom_eq_coe (f : \u03b1 \u2192+* \u03b2) : (f.toMonoidWithZeroHom : \u03b1 \u2192 \u03b2) = f := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Hom/Defs.lean", "context": {"open": ["Function"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[NonUnitalNonAssocSemiring \u03b1] [NonUnitalNonAssocSemiring \u03b2] [FunLike F \u03b1 \u03b2]", "[NonUnitalRingHomClass F \u03b1 \u03b2]", "[NonUnitalNonAssocSemiring \u03b1] [NonUnitalNonAssocSemiring \u03b2]", "[NonUnitalNonAssocSemiring \u03b1] [NonUnitalNonAssocSemiring \u03b2]", "[NonUnitalNonAssocSemiring \u03b1] [NonUnitalNonAssocSemiring \u03b2]", "[NonUnitalNonAssocSemiring \u03b3]", "[FunLike F \u03b1 \u03b2]", "{_ : NonAssocSemiring \u03b1} {_ : NonAssocSemiring \u03b2} [RingHomClass F \u03b1 \u03b2]", "{_ : NonAssocSemiring \u03b1} {_ : NonAssocSemiring \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2077 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2076 : NonUnitalNonAssocSemiring \u03b2\ninst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b2\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b2\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b2\nx\u271d\u00b9 : NonAssocSemiring \u03b1\nx\u271d : NonAssocSemiring \u03b2\nf : \u03b1 \u2192+* \u03b2\n\u22a2 \u21d1f.toMonoidWithZeroHom = \u21d1f"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem codomain_trivial_iff_map_one_eq_zero : (0 : \u03b2) = 1 \u2194 f 1 = 0 := by rw [map_one, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Hom/Defs.lean", "context": {"open": ["Function"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[NonUnitalNonAssocSemiring \u03b1] [NonUnitalNonAssocSemiring \u03b2] [FunLike F \u03b1 \u03b2]", "[NonUnitalRingHomClass F \u03b1 \u03b2]", "[NonUnitalNonAssocSemiring \u03b1] [NonUnitalNonAssocSemiring \u03b2]", "[NonUnitalNonAssocSemiring \u03b1] [NonUnitalNonAssocSemiring \u03b2]", "[NonUnitalNonAssocSemiring \u03b1] [NonUnitalNonAssocSemiring \u03b2]", "[NonUnitalNonAssocSemiring \u03b3]", "[FunLike F \u03b1 \u03b2]", "{_ : NonAssocSemiring \u03b1} {_ : NonAssocSemiring \u03b2} [RingHomClass F \u03b1 \u03b2]", "{_ : NonAssocSemiring \u03b1} {_ : NonAssocSemiring \u03b2}", "{_ : NonAssocSemiring \u03b1} {_ : NonAssocSemiring \u03b2} (f : \u03b1 \u2192+* \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2077 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2076 : NonUnitalNonAssocSemiring \u03b2\ninst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b2\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b2\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b2\nx\u271d\u00b9 : NonAssocSemiring \u03b1\nx\u271d : NonAssocSemiring \u03b2\nf : \u03b1 \u2192+* \u03b2\n\u22a2 0 = 1 \u2194 f 1 = 0"}, {"line": "rw [map_one, eq_comm]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2077 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2076 : NonUnitalNonAssocSemiring \u03b2\ninst\u271d\u2075 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2074 : NonUnitalNonAssocSemiring \u03b2\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b2\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b2\nx\u271d\u00b9 : NonAssocSemiring \u03b1\nx\u271d : NonAssocSemiring \u03b2\nf : \u03b1 \u2192+* \u03b2\n\u22a2 OneHomClass (\u03b1 \u2192+* \u03b2) \u03b1 \u03b2"}]}
{"declaration": "lemma even_or_odd' (n : \u2124) : \u2203 k, n = 2 * k \u2228 n = 2 * k + 1 := by\n  simpa only [two_mul, exists_or, Odd, Even] using even_or_odd n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Int/Parity.lean", "context": {"open": [], "variables": ["{m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 \u2203 k, n = 2 * k \u2228 n = 2 * k + 1"}, {"line": "simpa only [two_mul, exists_or, Odd, Even] using even_or_odd n", "tactic_state": "No Goals!"}]}
{"declaration": "lemma even_mul_succ_self (n : \u2124) : Even (n * (n + 1)) := by\n  simpa [even_mul, parity_simps] using n.even_or_odd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Int/Parity.lean", "context": {"open": [], "variables": ["{m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 Even (n * (n + 1))"}, {"line": "simpa [even_mul, parity_simps] using n.even_or_odd", "tactic_state": "No Goals!"}]}
{"declaration": "lemma even_mul_pred_self (n : \u2124) : Even (n * (n - 1)) := by\n  simpa [even_mul, parity_simps] using n.even_or_odd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Int/Parity.lean", "context": {"open": [], "variables": ["{m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 Even (n * (n - 1))"}, {"line": "simpa [even_mul, parity_simps] using n.even_or_odd", "tactic_state": "No Goals!"}]}
{"declaration": "lemma four_dvd_add_or_sub_of_odd {a b : \u2124} (ha : Odd a) (hb : Odd b) :\n    4 \u2223 a + b \u2228 4 \u2223 a - b := by\n  obtain \u27e8m, rfl\u27e9 := ha\n  obtain \u27e8n, rfl\u27e9 := hb\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Int/Parity.lean", "context": {"open": [], "variables": ["{m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\nha : Odd a\nhb : Odd b\n\u22a2 4 \u2223 a + b \u2228 4 \u2223 a - b"}, {"line": "obtain \u27e8m, rfl\u27e9 := ha", "tactic_state": "case intro\nb : \u2124\nhb : Odd b\nm : \u2124\n\u22a2 4 \u2223 2 * m + 1 + b \u2228 4 \u2223 2 * m + 1 - b"}, {"line": "obtain \u27e8n, rfl\u27e9 := hb", "tactic_state": "case intro.intro\nm n : \u2124\n\u22a2 4 \u2223 2 * m + 1 + (2 * n + 1) \u2228 4 \u2223 2 * m + 1 - (2 * n + 1)"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ediv_two_mul_two_add_one_of_odd : Odd n \u2192 n / 2 * 2 + 1 = n := by\n  rintro \u27e8c, rfl\u27e9\n  convert Int.ediv_add_emod' (2 * c + 1) 2\n  simp [Int.add_emod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Int/Parity.lean", "context": {"open": [], "variables": ["{m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 Odd n \u2192 n / 2 * 2 + 1 = n"}, {"line": "rintro \u27e8c, rfl\u27e9", "tactic_state": "case intro\nc : \u2124\n\u22a2 (2 * c + 1) / 2 * 2 + 1 = 2 * c + 1"}, {"line": "convert Int.ediv_add_emod' (2 * c + 1) 2", "tactic_state": "case h.e'_2.h.e'_6\nc : \u2124\n\u22a2 1 = (2 * c + 1) % 2"}, {"line": "simp [Int.add_emod]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_one_ediv_two_mul_two_of_odd : Odd n \u2192 1 + n / 2 * 2 = n := by\n  rintro \u27e8c, rfl\u27e9\n  rw [add_comm]\n  convert Int.ediv_add_emod' (2 * c + 1) 2\n  simp [Int.add_emod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Int/Parity.lean", "context": {"open": [], "variables": ["{m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 Odd n \u2192 1 + n / 2 * 2 = n"}, {"line": "rintro \u27e8c, rfl\u27e9", "tactic_state": "case intro\nc : \u2124\n\u22a2 1 + (2 * c + 1) / 2 * 2 = 2 * c + 1"}, {"line": "rw [add_comm]", "tactic_state": "case intro\nc : \u2124\n\u22a2 (2 * c + 1) / 2 * 2 + 1 = 2 * c + 1"}, {"line": "convert Int.ediv_add_emod' (2 * c + 1) 2", "tactic_state": "case h.e'_2.h.e'_6\nc : \u2124\n\u22a2 1 = (2 * c + 1) % 2"}, {"line": "simp [Int.add_emod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isSquare_natCast_iff {n : \u2115} : IsSquare (n : \u2124) \u2194 IsSquare n := by\n  constructor <;> rintro \u27e8x, h\u27e9\n  \u00b7 exact \u27e8x.natAbs, (natAbs_mul_natAbs_eq h.symm).symm\u27e9\n  \u00b7 exact \u27e8x, mod_cast h\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Int/Parity.lean", "context": {"open": [], "variables": ["{m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 IsSquare \u2191n \u2194 IsSquare n"}, {"line": "constructor <;> rintro \u27e8x, h\u27e9", "tactic_state": "case mp.intro\nn : \u2115\nx : \u2124\nh : \u2191n = x * x\n\u22a2 IsSquare n\n---\ncase mpr.intro\nn x : \u2115\nh : n = x * x\n\u22a2 IsSquare \u2191n"}, {"line": "\u00b7 exact \u27e8x.natAbs, (natAbs_mul_natAbs_eq h.symm).symm\u27e9", "tactic_state": "case mpr.intro\nn x : \u2115\nh : n = x * x\n\u22a2 IsSquare \u2191n"}, {"line": "\u00b7 exact \u27e8x, mod_cast h\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma units_eq_one_or (u : \u2124\u02e3) : u = 1 \u2228 u = -1 := by\n  simpa only [Units.ext_iff] using isUnit_eq_one_or u.isUnit\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Int/Units.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "u : \u2124\u02e3\n\u22a2 u = 1 \u2228 u = -1"}, {"line": "simpa only [Units.ext_iff] using isUnit_eq_one_or u.isUnit", "tactic_state": "No Goals!"}]}
{"declaration": "lemma units_ne_iff_eq_neg {u v : \u2124\u02e3} : u \u2260 v \u2194 u = -v := by\n  simpa only [Ne, Units.ext_iff] using isUnit_ne_iff_eq_neg u.isUnit v.isUnit\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Int/Units.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "u v : \u2124\u02e3\n\u22a2 u \u2260 v \u2194 u = -v"}, {"line": "simpa only [Ne, Units.ext_iff] using isUnit_ne_iff_eq_neg u.isUnit v.isUnit", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intCast_mem (n : \u2124) : (n : R) \u2208 s := by simp only [\u2190 zsmul_one, zsmul_mem, one_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Subring/Defs.lean", "context": {"open": [], "variables": ["{R : Type u} {S : Type v} {T : Type w} [Ring R]", "[SetLike S R] [hSR : SubringClass S R] (s : S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : SetLike S R\nhSR : SubringClass S R\ns : S\nn : \u2124\n\u22a2 \u2191n \u2208 s"}, {"line": "simp only [\u2190 zsmul_one, zsmul_mem, one_mem]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : SetLike S R\nhSR : SubringClass S R\ns : S\nn : \u2124\n\u22a2 n \u2022 1 \u2208 s"}]}
{"declaration": "theorem map_range : f.range.map g = (g.comp f).range := by\n  simpa only [range_eq_map] using (\u22a4 : Subring R).map_map g f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Subring/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} {S : Type v} {T : Type w} [Ring R]", "[Ring S] [Ring T]", "{s t : Subring R}", "(s : Subring R)", "(g : S \u2192+* T) (f : R \u2192+* S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Ring S\ninst\u271d : Ring T\ng : S \u2192+* T\nf : R \u2192+* S\n\u22a2 Subring.map g f.range = (g.comp f).range"}, {"line": "simpa only [range_eq_map] using (\u22a4 : Subring R).map_map g f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_iInf {\u03b9 : Sort*} [Nonempty \u03b9] (f : R \u2192+* S) (hf : Function.Injective f)\n    (s : \u03b9 \u2192 Subring R) : (iInf s).map f = \u2a05 i, (s i).map f := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe \u2218 s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Subring/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} {S : Type v} {T : Type w} [Ring R]", "[Ring S] [Ring T]", "{s t : Subring R}", "(s : Subring R)", "(g : S \u2192+* T) (f : R \u2192+* S)", "(R)", "{R}", "{K : Type u} [DivisionRing K]", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Ring S\n\u03b9 : Sort u_1\ninst\u271d : Nonempty \u03b9\nf : R \u2192+* S\nhf : Function.Injective \u21d1f\ns : \u03b9 \u2192 Subring R\n\u22a2 Subring.map f (iInf s) = \u2a05 i, Subring.map f (s i)"}, {"line": "apply SetLike.coe_injective", "tactic_state": "case a\nR : Type u\nS : Type v\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Ring S\n\u03b9 : Sort u_1\ninst\u271d : Nonempty \u03b9\nf : R \u2192+* S\nhf : Function.Injective \u21d1f\ns : \u03b9 \u2192 Subring R\n\u22a2 \u2191(Subring.map f (iInf s)) = \u2191(\u2a05 i, Subring.map f (s i))"}, {"line": "simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe \u2218 s)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_mem [AddSubmonoidWithOneClass S R] (n : \u2115) : (n : R) \u2208 s := by\n  induction n <;> simp [zero_mem, add_mem, one_mem, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Subsemiring/Defs.lean", "context": {"open": [], "variables": ["{S R : Type*} [AddMonoidWithOne R] [SetLike S R] (s : S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : AddMonoidWithOne R\ninst\u271d\u00b9 : SetLike S R\ns : S\ninst\u271d : AddSubmonoidWithOneClass S R\nn : \u2115\n\u22a2 \u2191n \u2208 s"}, {"line": "induction n <;> simp [zero_mem, add_mem, one_mem, *]", "tactic_state": "case zero\nS : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : AddMonoidWithOne R\ninst\u271d\u00b9 : SetLike S R\ns : S\ninst\u271d : AddSubmonoidWithOneClass S R\n\u22a2 0 \u2208 s\n---\ncase succ\nS : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : AddMonoidWithOne R\ninst\u271d\u00b9 : SetLike S R\ns : S\ninst\u271d : AddSubmonoidWithOneClass S R\nn\u271d : \u2115\na\u271d : \u2191n\u271d \u2208 s\n\u22a2 \u2191n\u271d + 1 \u2208 s"}]}
{"declaration": "theorem map_rangeS : f.rangeS.map g = (g.comp f).rangeS := by\n  simpa only [rangeS_eq_map] using (\u22a4 : Subsemiring R).map_map g f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Subsemiring/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} {S : Type v} {T : Type w} [NonAssocSemiring R] (M : Submonoid R)", "[SetLike S R] [hSR : SubsemiringClass S R] (s : S)", "[NonAssocSemiring S] [NonAssocSemiring T]", "(s : Subsemiring R)", "(g : S \u2192+* T) (f : R \u2192+* S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u00b3 : NonAssocSemiring R\ninst\u271d\u00b2 : SetLike S R\nhSR : SubsemiringClass S R\ninst\u271d\u00b9 : NonAssocSemiring S\ninst\u271d : NonAssocSemiring T\ng : S \u2192+* T\nf : R \u2192+* S\n\u22a2 Subsemiring.map g f.rangeS = (g.comp f).rangeS"}, {"line": "simpa only [rangeS_eq_map] using (\u22a4 : Subsemiring R).map_map g f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_map_equiv {f : R \u2243+* S} {K : Subsemiring R} {x : S} :\n    x \u2208 K.map (f : R \u2192+* S) \u2194 f.symm x \u2208 K := by\n  convert @Set.mem_image_equiv _ _ (\u2191K) f.toEquiv x using 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Subsemiring/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} {S : Type v} {T : Type w} [NonAssocSemiring R] (M : Submonoid R)", "[SetLike S R] [hSR : SubsemiringClass S R] (s : S)", "[NonAssocSemiring S] [NonAssocSemiring T]", "(s : Subsemiring R)", "(g : S \u2192+* T) (f : R \u2192+* S)", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : NonAssocSemiring R\ninst\u271d\u00b9 : SetLike S R\nhSR : SubsemiringClass S R\ninst\u271d : NonAssocSemiring S\nf : R \u2243+* S\nK : Subsemiring R\nx : S\n\u22a2 x \u2208 Subsemiring.map (\u2191f) K \u2194 f.symm x \u2208 K"}, {"line": "convert @Set.mem_image_equiv _ _ (\u2191K) f.toEquiv x using 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_closure_eq (s : Set R) :\n    (closure s : Set R) = AddSubmonoid.closure (Submonoid.closure s : Set R) := by\n  simp [\u2190 Submonoid.subsemiringClosure_toAddSubmonoid, Submonoid.subsemiringClosure_eq_closure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Subsemiring/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} {S : Type v} {T : Type w} [NonAssocSemiring R] (M : Submonoid R)", "[SetLike S R] [hSR : SubsemiringClass S R] (s : S)", "[NonAssocSemiring S] [NonAssocSemiring T]", "(s : Subsemiring R)", "(g : S \u2192+* T) (f : R \u2192+* S)", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : NonAssocSemiring R\ns : Set R\n\u22a2 sorry = \u2191(AddSubmonoid.closure \u2191(Submonoid.closure s))"}, {"line": "simp [\u2190 Submonoid.subsemiringClosure_toAddSubmonoid, Submonoid.subsemiringClosure_eq_closure]", "tactic_state": "R : Type u\ninst\u271d : NonAssocSemiring R\ns : Set R\n\u22a2 sorry () = \u2191(Subsemiring.closure s)"}]}
{"declaration": "theorem map_iInf {\u03b9 : Sort*} [Nonempty \u03b9] (f : R \u2192+* S) (hf : Function.Injective f)\n    (s : \u03b9 \u2192 Subsemiring R) : (iInf s).map f = \u2a05 i, (s i).map f := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe \u2218 s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Subsemiring/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} {S : Type v} {T : Type w} [NonAssocSemiring R] (M : Submonoid R)", "[SetLike S R] [hSR : SubsemiringClass S R] (s : S)", "[NonAssocSemiring S] [NonAssocSemiring T]", "(s : Subsemiring R)", "(g : S \u2192+* T) (f : R \u2192+* S)", "(R)", "{R}", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b3 : NonAssocSemiring R\ninst\u271d\u00b2 : SetLike S R\nhSR : SubsemiringClass S R\ninst\u271d\u00b9 : NonAssocSemiring S\n\u03b9 : Sort u_1\ninst\u271d : Nonempty \u03b9\nf : R \u2192+* S\nhf : Function.Injective \u21d1f\ns : \u03b9 \u2192 Subsemiring R\n\u22a2 Subsemiring.map f (iInf s) = \u2a05 i, Subsemiring.map f (s i)"}, {"line": "apply SetLike.coe_injective", "tactic_state": "case a\nR : Type u\nS : Type v\ninst\u271d\u00b3 : NonAssocSemiring R\ninst\u271d\u00b2 : SetLike S R\nhSR : SubsemiringClass S R\ninst\u271d\u00b9 : NonAssocSemiring S\n\u03b9 : Sort u_1\ninst\u271d : Nonempty \u03b9\nf : R \u2192+* S\nhf : Function.Injective \u21d1f\ns : \u03b9 \u2192 Subsemiring R\n\u22a2 \u2191(Subsemiring.map f (iInf s)) = \u2191(\u2a05 i, Subsemiring.map f (s i))"}, {"line": "simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe \u2218 s)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_comap_eq_self\n    {f : R \u2192+* S} {t : Subsemiring S} (h : t \u2264 f.rangeS) : (t.comap f).map f = t := by\n  simpa only [inf_of_le_left h] using map_comap_eq f t\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Ring/Subsemiring/Basic.lean", "context": {"open": ["Subsemiring", "RingHom"], "variables": ["{R : Type u} {S : Type v} {T : Type w} [NonAssocSemiring R] (M : Submonoid R)", "[SetLike S R] [hSR : SubsemiringClass S R] (s : S)", "[NonAssocSemiring S] [NonAssocSemiring T]", "(s : Subsemiring R)", "(g : S \u2192+* T) (f : R \u2192+* S)", "(R)", "{R}", "(R) in", "[NonAssocSemiring T] {s : Subsemiring R}", "{\u03c3R \u03c3S : Type*}", "[SetLike \u03c3R R] [SetLike \u03c3S S] [SubsemiringClass \u03c3R R] [SubsemiringClass \u03c3S S]", "{s t : Subsemiring R}", "{R' \u03b1 \u03b2 : Type*}", "{S' : Type*} [SetLike S' R'] (s : S)", "[NonAssocSemiring R']", "[Semiring R']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : NonAssocSemiring R\ninst\u271d\u00b9 : SetLike S R\nhSR : SubsemiringClass S R\ninst\u271d : NonAssocSemiring S\nf : R \u2192+* S\nt : Subsemiring S\nh : t \u2264 f.rangeS\n\u22a2 map f (comap f t) = t"}, {"line": "simpa only [inf_of_le_left h] using map_comap_eq f t", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_single_apply {a a' : G} {b : k} [Decidable (a = a')] :\n    coeff (single a b) a' = if a = a' then b else 0 := by\n  simp [coeff, Finsupp.single_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/SkewMonoidAlgebra/Basic.lean", "context": {"open": ["Function"], "variables": ["{k G : Type*}", "[AddCommMonoid k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : AddCommMonoid k\nx\u271d : Sort u_3\ncoeff : x\u271d\na a' : G\nb : k\ninst\u271d : Decidable (a = a')\n\u22a2 sorry = if a = a' then b else 0"}, {"line": "simp [coeff, Finsupp.single_apply]", "tactic_state": "k : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : AddCommMonoid k\nx\u271d : Sort u_3\ncoeff : x\u271d\na a' : G\nb : k\ninst\u271d : Decidable (a = a')\n\u22a2 sorry () = if a = a' then b else 0"}]}
{"declaration": "theorem sum_zero_index {S : Type*} [AddCommMonoid S] {f : G \u2192 k \u2192 S} :\n    (0 : SkewMonoidAlgebra k G).sum f = 0 := by simp [sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/SkewMonoidAlgebra/Basic.lean", "context": {"open": ["Function"], "variables": ["{k G : Type*}", "[AddCommMonoid k]", "[One G] [One k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\nG : Type u_2\ninst\u271d\u00b3 : AddCommMonoid k\ninst\u271d\u00b2 : One G\ninst\u271d\u00b9 : One k\nS : Type u_3\ninst\u271d : AddCommMonoid S\nf : G \u2192 k \u2192 S\n\u22a2 SkewMonoidAlgebra.sum 0 f = 0"}, {"line": "simp [sum]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma equivShrink_symm_mul [Mul \u03b1] [Small \u03b1] (x y : Shrink \u03b1) :\n    (equivShrink \u03b1).symm (x * y) = (equivShrink \u03b1).symm x * (equivShrink \u03b1).symm y := by\n  rw [Equiv.mul_def]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Small/Group.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : Small.{u_2, u_1} \u03b1\nx y : Shrink.{u_2, u_1} \u03b1\n\u22a2 (equivShrink \u03b1).symm (x * y) = (equivShrink \u03b1).symm x * (equivShrink \u03b1).symm y"}, {"line": "rw [Equiv.mul_def]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : Small.{u_2, u_1} \u03b1\nx y : Shrink.{u_2, u_1} \u03b1\n\u22a2 (equivShrink \u03b1).symm ((equivShrink \u03b1).symm.symm ((equivShrink \u03b1).symm x * (equivShrink \u03b1).symm y)) =\n    (equivShrink \u03b1).symm x * (equivShrink \u03b1).symm y"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma equivShrink_mul [Mul \u03b1] [Small \u03b1] (x y : \u03b1) :\n    equivShrink \u03b1 (x * y) = equivShrink \u03b1 x * equivShrink \u03b1 y := by\n  rw [Equiv.mul_def]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Small/Group.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : Small.{u_2, u_1} \u03b1\nx y : \u03b1\n\u22a2 (equivShrink \u03b1) (x * y) = (equivShrink \u03b1) x * (equivShrink \u03b1) y"}, {"line": "rw [Equiv.mul_def]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : Small.{u_2, u_1} \u03b1\nx y : \u03b1\n\u22a2 (equivShrink \u03b1) (x * y) =\n    (equivShrink \u03b1).symm.symm ((equivShrink \u03b1).symm ((equivShrink \u03b1) x) * (equivShrink \u03b1).symm ((equivShrink \u03b1) y))"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma equivShrink_symm_smul {R : Type*} [SMul R \u03b1] [Small \u03b1] (r : R) (x : Shrink \u03b1) :\n    (equivShrink \u03b1).symm (r \u2022 x) = r \u2022 (equivShrink \u03b1).symm x := by\n  rw [Equiv.smul_def]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Small/Group.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : SMul R \u03b1\ninst\u271d : Small.{u_3, u_1} \u03b1\nr : R\nx : Shrink.{u_3, u_1} \u03b1\n\u22a2 (equivShrink \u03b1).symm (r \u2022 x) = r \u2022 (equivShrink \u03b1).symm x"}, {"line": "rw [Equiv.smul_def]", "tactic_state": "\u03b1 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : SMul R \u03b1\ninst\u271d : Small.{u_3, u_1} \u03b1\nr : R\nx : Shrink.{u_3, u_1} \u03b1\n\u22a2 (equivShrink \u03b1).symm ((equivShrink \u03b1).symm.symm (r \u2022 (equivShrink \u03b1).symm x)) = r \u2022 (equivShrink \u03b1).symm x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma equivShrink_smul {R : Type*} [SMul R \u03b1] [Small \u03b1] (r : R) (x : \u03b1) :\n    equivShrink \u03b1 (r \u2022 x) = r \u2022 equivShrink \u03b1 x := by\n  rw [Equiv.smul_def]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Small/Group.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : SMul R \u03b1\ninst\u271d : Small.{u_3, u_1} \u03b1\nr : R\nx : \u03b1\n\u22a2 (equivShrink \u03b1) (r \u2022 x) = r \u2022 (equivShrink \u03b1) x"}, {"line": "rw [Equiv.smul_def]", "tactic_state": "\u03b1 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : SMul R \u03b1\ninst\u271d : Small.{u_3, u_1} \u03b1\nr : R\nx : \u03b1\n\u22a2 (equivShrink \u03b1) (r \u2022 x) = (equivShrink \u03b1).symm.symm (r \u2022 (equivShrink \u03b1).symm ((equivShrink \u03b1) x))"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma equivShrink_symm_div [Div \u03b1] [Small \u03b1] (x y : Shrink \u03b1) :\n    (equivShrink \u03b1).symm (x / y) = (equivShrink \u03b1).symm x / (equivShrink \u03b1).symm y := by\n  rw [Equiv.div_def]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Small/Group.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Div \u03b1\ninst\u271d : Small.{u_2, u_1} \u03b1\nx y : Shrink.{u_2, u_1} \u03b1\n\u22a2 (equivShrink \u03b1).symm (x / y) = (equivShrink \u03b1).symm x / (equivShrink \u03b1).symm y"}, {"line": "rw [Equiv.div_def]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Div \u03b1\ninst\u271d : Small.{u_2, u_1} \u03b1\nx y : Shrink.{u_2, u_1} \u03b1\n\u22a2 (equivShrink \u03b1).symm ((equivShrink \u03b1).symm.symm ((equivShrink \u03b1).symm x / (equivShrink \u03b1).symm y)) =\n    (equivShrink \u03b1).symm x / (equivShrink \u03b1).symm y"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma equivShrink_div [Div \u03b1] [Small \u03b1] (x y : \u03b1) :\n    equivShrink \u03b1 (x / y) = equivShrink \u03b1 x / equivShrink \u03b1 y := by\n  rw [Equiv.div_def]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Small/Group.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Div \u03b1\ninst\u271d : Small.{u_2, u_1} \u03b1\nx y : \u03b1\n\u22a2 (equivShrink \u03b1) (x / y) = (equivShrink \u03b1) x / (equivShrink \u03b1) y"}, {"line": "rw [Equiv.div_def]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Div \u03b1\ninst\u271d : Small.{u_2, u_1} \u03b1\nx y : \u03b1\n\u22a2 (equivShrink \u03b1) (x / y) =\n    (equivShrink \u03b1).symm.symm ((equivShrink \u03b1).symm ((equivShrink \u03b1) x) / (equivShrink \u03b1).symm ((equivShrink \u03b1) y))"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma equivShrink_symm_inv [Inv \u03b1] [Small \u03b1] (x : Shrink \u03b1) :\n    (equivShrink \u03b1).symm x\u207b\u00b9 = ((equivShrink \u03b1).symm x)\u207b\u00b9 := by\n  rw [Equiv.inv_def]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Small/Group.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Inv \u03b1\ninst\u271d : Small.{u_2, u_1} \u03b1\nx : Shrink.{u_2, u_1} \u03b1\n\u22a2 (equivShrink \u03b1).symm x\u207b\u00b9 = ((equivShrink \u03b1).symm x)\u207b\u00b9"}, {"line": "rw [Equiv.inv_def]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Inv \u03b1\ninst\u271d : Small.{u_2, u_1} \u03b1\nx : Shrink.{u_2, u_1} \u03b1\n\u22a2 (equivShrink \u03b1).symm ((equivShrink \u03b1).symm.symm ((equivShrink \u03b1).symm x)\u207b\u00b9) = ((equivShrink \u03b1).symm x)\u207b\u00b9"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma equivShrink_inv [Inv \u03b1] [Small \u03b1] (x : \u03b1) :\n    equivShrink \u03b1 x\u207b\u00b9 = (equivShrink \u03b1 x)\u207b\u00b9 := by\n  rw [Equiv.inv_def]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Small/Group.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Inv \u03b1\ninst\u271d : Small.{u_2, u_1} \u03b1\nx : \u03b1\n\u22a2 (equivShrink \u03b1) x\u207b\u00b9 = ((equivShrink \u03b1) x)\u207b\u00b9"}, {"line": "rw [Equiv.inv_def]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Inv \u03b1\ninst\u271d : Small.{u_2, u_1} \u03b1\nx : \u03b1\n\u22a2 (equivShrink \u03b1) x\u207b\u00b9 = (equivShrink \u03b1).symm.symm ((equivShrink \u03b1).symm ((equivShrink \u03b1) x))\u207b\u00b9"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_squarefree_zero [MonoidWithZero R] [Nontrivial R] : \u00acSquarefree (0 : R) := by\n  erw [not_forall]\n  exact \u27e80, by simp\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Squarefree/Basic.lean", "context": {"open": [], "variables": ["{R : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : MonoidWithZero R\ninst\u271d : Nontrivial R\n\u22a2 \u00acSquarefree 0"}, {"line": "erw [not_forall]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : MonoidWithZero R\ninst\u271d : Nontrivial R\n\u22a2 \u2203 x, \u00ac(x * x \u2223 0 \u2192 IsUnit x)"}, {"line": "exact \u27e80, by simp\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Squarefree.ne_zero [MonoidWithZero R] [Nontrivial R] {m : R} (hm : Squarefree (m : R)) :\n    m \u2260 0 := by\n  rintro rfl\n  exact not_squarefree_zero hm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Squarefree/Basic.lean", "context": {"open": [], "variables": ["{R : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : MonoidWithZero R\ninst\u271d : Nontrivial R\nm : R\nhm : Squarefree m\n\u22a2 m \u2260 0"}, {"line": "rintro rfl", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : MonoidWithZero R\ninst\u271d : Nontrivial R\nhm : Squarefree 0\n\u22a2 False"}, {"line": "exact not_squarefree_zero hm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Squarefree.pow_dvd_of_pow_dvd [Monoid R] {x y : R} {n : \u2115}\n    (hx : Squarefree y) (h : x ^ n \u2223 y) : x ^ n \u2223 x := by\n  by_cases hu : IsUnit x\n  \u00b7 exact (hu.pow n).dvd\n  \u00b7 rcases (hx.squarefree_of_dvd h).eq_zero_or_one_of_pow_of_not_isUnit hu with rfl | rfl <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Squarefree/Basic.lean", "context": {"open": [], "variables": ["{R : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Monoid R\nx y : R\nn : \u2115\nhx : Squarefree y\nh : x ^ n \u2223 y\n\u22a2 x ^ n \u2223 x"}, {"line": "by_cases hu : IsUnit x", "tactic_state": "case pos\nR : Type u_1\ninst\u271d : Monoid R\nx y : R\nn : \u2115\nhx : Squarefree y\nh : x ^ n \u2223 y\nhu : sorry\n\u22a2 x ^ n \u2223 x\n---\ncase neg\nR : Type u_1\ninst\u271d : Monoid R\nx y : R\nn : \u2115\nhx : Squarefree y\nh : x ^ n \u2223 y\nhu : \u00acsorry\n\u22a2 x ^ n \u2223 x"}, {"line": "\u00b7 exact (hu.pow n).dvd", "tactic_state": "case neg\nR : Type u_1\ninst\u271d : Monoid R\nx y : R\nn : \u2115\nhx : Squarefree y\nh : x ^ n \u2223 y\nhu : \u00acsorry\n\u22a2 x ^ n \u2223 x"}, {"line": "\u00b7 rcases (hx.squarefree_of_dvd h).eq_zero_or_one_of_pow_of_not_isUnit hu with rfl | rfl <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem squarefree_iff_emultiplicity_le_one [CommMonoid R] (r : R) :\n    Squarefree r \u2194 \u2200 x : R, emultiplicity x r \u2264 1 \u2228 IsUnit x := by\n  refine forall_congr' fun a => ?_\n  rw [\u2190 sq]\n  rw [pow_dvd_iff_le_emultiplicity]\n  rw [or_iff_not_imp_left]\n  rw [not_le]\n  rw [imp_congr _ Iff.rfl]\n  norm_cast\n  rw [\u2190 one_add_one_eq_two]\n  exact Order.add_one_le_iff_of_not_isMax (by simp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Squarefree/Basic.lean", "context": {"open": [], "variables": ["{R : Type*}", "{\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommMonoid R\nr : R\n\u22a2 Squarefree r \u2194 \u2200 (x : R), emultiplicity x r \u2264 1 \u2228 IsUnit x"}, {"line": "refine forall_congr' fun a => ?_", "tactic_state": "R : Type u_1\ninst\u271d : CommMonoid R\nr a : R\n\u22a2 a * a \u2223 r \u2192 IsUnit a \u2194 emultiplicity a r \u2264 1 \u2228 IsUnit a"}, {"line": "rw [\u2190 sq]", "tactic_state": "R : Type u_1\ninst\u271d : CommMonoid R\nr a : R\n\u22a2 a ^ 2 \u2223 r \u2192 IsUnit a \u2194 emultiplicity a r \u2264 1 \u2228 IsUnit a"}, {"line": "rw [pow_dvd_iff_le_emultiplicity]", "tactic_state": "R : Type u_1\ninst\u271d : CommMonoid R\nr a : R\n\u22a2 \u21912 \u2264 emultiplicity a r \u2192 IsUnit a \u2194 emultiplicity a r \u2264 1 \u2228 IsUnit a"}, {"line": "rw [or_iff_not_imp_left]", "tactic_state": "R : Type u_1\ninst\u271d : CommMonoid R\nr a : R\n\u22a2 \u21912 \u2264 emultiplicity a r \u2192 IsUnit a \u2194 \u00acemultiplicity a r \u2264 1 \u2192 IsUnit a"}, {"line": "rw [not_le]", "tactic_state": "R : Type u_1\ninst\u271d : CommMonoid R\nr a : R\n\u22a2 \u21912 \u2264 emultiplicity a r \u2192 IsUnit a \u2194 1 < emultiplicity a r \u2192 IsUnit a"}, {"line": "rw [imp_congr _ Iff.rfl]", "tactic_state": "R : Type u_1\ninst\u271d : CommMonoid R\nr a : R\n\u22a2 \u21912 \u2264 emultiplicity a r \u2194 1 < emultiplicity a r"}, {"line": "norm_cast", "tactic_state": "R : Type u_1\ninst\u271d : CommMonoid R\nr a : R\n\u22a2 2 \u2264 emultiplicity a r \u2194 1 < emultiplicity a r"}, {"line": "rw [\u2190 one_add_one_eq_two]", "tactic_state": "R : Type u_1\ninst\u271d : CommMonoid R\nr a : R\n\u22a2 1 + 1 \u2264 emultiplicity a r \u2194 1 < emultiplicity a r"}, {"line": "exact Order.add_one_le_iff_of_not_isMax (by simp)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem squarefree_iff_irreducible_sq_not_dvd_of_ne_zero {r : R} (hr : r \u2260 0) :\n    Squarefree r \u2194 \u2200 x : R, Irreducible x \u2192 \u00acx * x \u2223 r := by\n  simpa [hr] using (irreducible_sq_not_dvd_iff_eq_zero_and_no_irreducibles_or_squarefree r).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Squarefree/Basic.lean", "context": {"open": [], "variables": ["{R : Type*}", "{\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]", "[CommMonoidWithZero R] [WfDvdMonoid R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommMonoidWithZero R\ninst\u271d : WfDvdMonoid R\nr : R\nhr : r \u2260 0\n\u22a2 Squarefree r \u2194 \u2200 (x : R), Irreducible x \u2192 \u00acx * x \u2223 r"}, {"line": "simpa [hr] using (irreducible_sq_not_dvd_iff_eq_zero_and_no_irreducibles_or_squarefree r).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Set.star_centralizer : star s.centralizer = (star s).centralizer := by\n  simp_rw [centralizer, \u2190 commute_iff_eq]\n  conv_lhs => simp only [\u2190 star_preimage, preimage_setOf_eq, \u2190 commute_star_comm]\n  conv_rhs => simp only [\u2190 image_star, forall_mem_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/Center.lean", "context": {"open": [], "variables": ["{R : Type*} [Mul R] [StarMul R] {a : R} {s : Set R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Mul R\ninst\u271d : StarMul R\ns : Set R\n\u22a2 star s.centralizer = (star s).centralizer"}, {"line": "simp_rw [centralizer, \u2190 commute_iff_eq]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Mul R\ninst\u271d : StarMul R\ns : Set R\n\u22a2 star {c | \u2200 m \u2208 s, Commute m c} = {c | \u2200 m \u2208 star s, Commute m c}"}, {"line": "conv_lhs => simp only [\u2190 star_preimage, preimage_setOf_eq, \u2190 commute_star_comm]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Mul R\ninst\u271d : StarMul R\ns : Set R\n\u22a2 {a | \u2200 m \u2208 s, Commute (star m) a} = {c | \u2200 m \u2208 star s, Commute m c}"}, {"line": "conv_rhs => simp only [\u2190 image_star, forall_mem_image]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem star_\u03b9 (x : X) : star (\u03b9 R x) = \u03b9 R x := by simp [star, Star.star]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/Free.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "{R : Type*} [CommSemiring R] {X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_3\nx\u271d : Sort u_4\n\u03b9 : x\u271d\nx : X\n\u22a2 star sorry = sorry"}, {"line": "simp [star, Star.star]", "tactic_state": "X : Type u_3\nx\u271d : Sort u_4\n\u03b9 : x\u271d\nx : X\n\u22a2 star (sorry ()) = sorry ()"}]}
{"declaration": "theorem star_algebraMap (r : R) : star (algebraMap R (FreeAlgebra R X) r) = algebraMap R _ r := by\n  simp [star, Star.star]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/Free.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "{R : Type*} [CommSemiring R] {X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d : CommSemiring R\nX : Type u_3\nr : R\n\u22a2 star ((algebraMap R (FreeAlgebra R X)) r) = (algebraMap R (FreeAlgebra R X)) r"}, {"line": "simp [star, Star.star]", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma IsSelfAdjoint.algebraMap {r : R} (hr : IsSelfAdjoint r) :\n    IsSelfAdjoint (algebraMap R A r) := by\n  simpa using congr(algebraMap R A $(hr.star_eq))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/Module.lean", "context": {"open": [], "variables": ["{R M : Type*}", "(R : Type*) (A : Type*) [Semiring R] [StarMul R] [TrivialStar R] [AddCommGroup A]", "{A} [Invertible (2 : R)]", "(A)", "{R A : Type*} [CommSemiring R] [StarRing R] [Semiring A]", "[StarMul A] [Algebra R A] [StarModule R A]", "(A) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\nA : Type u_6\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : StarRing R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : StarMul A\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : StarModule R A\nr : R\nhr : IsSelfAdjoint r\n\u22a2 IsSelfAdjoint ((algebraMap R A) r)"}, {"line": "simpa using congr(algebraMap R A $(hr.star_eq))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem star_iff [InvolutiveStar R] {x : R} : IsSelfAdjoint (star x) \u2194 IsSelfAdjoint x := by\n  simpa only [IsSelfAdjoint, star_star] using eq_comm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/SelfAdjoint.lean", "context": {"open": ["Function"], "variables": ["{R A : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : InvolutiveStar R\nx : R\n\u22a2 IsSelfAdjoint (star x) \u2194 IsSelfAdjoint x"}, {"line": "simpa only [IsSelfAdjoint, star_star] using eq_comm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem star_mul_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (star x * x) := by\n  simp only [IsSelfAdjoint]\n  simp only [star_mul]\n  simp only [star_star]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/SelfAdjoint.lean", "context": {"open": ["Function"], "variables": ["{R A : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Mul R\ninst\u271d : StarMul R\nx : R\n\u22a2 IsSelfAdjoint (star x * x)"}, {"line": "simp only [IsSelfAdjoint]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Mul R\ninst\u271d : StarMul R\nx : R\n\u22a2 star (star x * x) = star x * x"}, {"line": "simp only [star_mul]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Mul R\ninst\u271d : StarMul R\nx : R\n\u22a2 star x * star (star x) = star x * x"}, {"line": "simp only [star_star]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_star_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (x * star x) := by\n  simpa only [star_star] using star_mul_self (star x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/SelfAdjoint.lean", "context": {"open": ["Function"], "variables": ["{R A : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Mul R\ninst\u271d : StarMul R\nx : R\n\u22a2 IsSelfAdjoint (x * star x)"}, {"line": "simpa only [star_star] using star_mul_self (star x)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma commute_iff {R : Type*} [Mul R] [StarMul R] {x y : R}\n    (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : Commute x y \u2194 IsSelfAdjoint (x * y) := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 rw [isSelfAdjoint_iff, star_mul, hx.star_eq, hy.star_eq, h.eq]\n  \u00b7 simpa only [star_mul, hx.star_eq, hy.star_eq] using h.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/SelfAdjoint.lean", "context": {"open": ["Function"], "variables": ["{R A : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b9 : Mul R\ninst\u271d : StarMul R\nx y : R\nhx : IsSelfAdjoint x\nhy : IsSelfAdjoint y\n\u22a2 Commute x y \u2194 IsSelfAdjoint (x * y)"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9", "tactic_state": "case refine_1\nR : Type u_3\ninst\u271d\u00b9 : Mul R\ninst\u271d : StarMul R\nx y : R\nhx : IsSelfAdjoint x\nhy : IsSelfAdjoint y\nh : Commute x y\n\u22a2 IsSelfAdjoint (x * y)\n---\ncase refine_2\nR : Type u_3\ninst\u271d\u00b9 : Mul R\ninst\u271d : StarMul R\nx y : R\nhx : IsSelfAdjoint x\nhy : IsSelfAdjoint y\nh : IsSelfAdjoint (x * y)\n\u22a2 Commute x y"}, {"line": "\u00b7 rw [isSelfAdjoint_iff, star_mul, hx.star_eq, hy.star_eq, h.eq]", "tactic_state": "case refine_2\nR : Type u_3\ninst\u271d\u00b9 : Mul R\ninst\u271d : StarMul R\nx y : R\nhx : IsSelfAdjoint x\nhy : IsSelfAdjoint y\nh : IsSelfAdjoint (x * y)\n\u22a2 Commute x y"}, {"line": "\u00b7 simpa only [star_mul, hx.star_eq, hy.star_eq] using h.symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isSelfAdjoint {x : selfAdjoint R} : IsSelfAdjoint (x : R) := by simp [isSelfAdjoint_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/SelfAdjoint.lean", "context": {"open": ["Function", "scoped ComplexConjugate"], "variables": ["{R A : Type*}", "[AddMonoid R] [StarAddMonoid R]", "(R) in", "[AddGroup R] [StarAddMonoid R]", "[AddCommMonoid R] [StarAddMonoid R]", "[Semigroup R] [StarMul R]", "[MulOneClass R] [StarMul R]", "(R)", "[Monoid R] [StarMul R]", "[Semiring R] [StarRing R]", "[CommSemigroup R] [StarMul R]", "{\u03b1 : Type*} [CommSemiring \u03b1] [StarRing \u03b1] {a : \u03b1}", "[Ring R] [StarRing R]", "[Group R] [StarMul R]", "[GroupWithZero R] [StarMul R]", "[DivisionRing R] [StarRing R]", "[Semifield R] [StarRing R]", "(R)", "{R}", "[AddGroup R] [StarAddMonoid R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : sorry\n\u22a2 IsSelfAdjoint sorry"}, {"line": "simp [isSelfAdjoint_iff]", "tactic_state": "x : sorry\n\u22a2 IsSelfAdjoint (sorry ())"}]}
{"declaration": "theorem eq_star_of_eq_star [InvolutiveStar R] {r s : R} (h : r = star s) : s = star r := by\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/Basic.lean", "context": {"open": ["MulOpposite"], "variables": ["{R : Type u}", "{S : Type w} [Star R] [SetLike S R] [hS : StarMemClass S R] (s : S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Star R\ninst\u271d : InvolutiveStar R\nr s : R\nh : r = star s\n\u22a2 s = star r"}, {"line": "simp [h]", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Star R\ninst\u271d : InvolutiveStar R\nr s : R\nh : r = star s\n\u22a2 s = star (star s)"}]}
{"declaration": "theorem tsirelson_inequality_aux : \u221a2 * \u221a2 ^ 3 = \u221a2 * (2 * (\u221a2)\u207b\u00b9 + 4 * ((\u221a2)\u207b\u00b9 * 2\u207b\u00b9)) := by\n  ring_nf\n  rw [mul_inv_cancel\u2080 (ne_of_gt (Real.sqrt_pos.2 (show (2 : \u211d) > 0 by norm_num)))]\n  convert congr_arg (\u00b7 ^ 2) (@Real.sq_sqrt 2 (by norm_num)) using 1 <;>\n    (try simp only [\u2190 pow_mul]) <;> norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/CHSH.lean", "context": {"open": [], "variables": ["{R : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u221a2 * \u221a2 ^ 3 = \u221a2 * (2 * (\u221a2)\u207b\u00b9 + 4 * ((\u221a2)\u207b\u00b9 * 2\u207b\u00b9))"}, {"line": "ring_nf", "tactic_state": "\u22a2 \u221a2 ^ 4 = \u221a2 * (\u221a2)\u207b\u00b9 * 4"}, {"line": "rw [mul_inv_cancel\u2080 (ne_of_gt (Real.sqrt_pos.2 (show (2 : \u211d) > 0 by norm_num)))]", "tactic_state": "\u22a2 \u221a2 ^ 4 = 1 * 4"}, {"line": "convert congr_arg (\u00b7 ^ 2) (@Real.sq_sqrt 2 (by norm_num)) using 1 <;>\n    (try simp only [\u2190 pow_mul]) <;> norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sqrt_two_inv_mul_self : (\u221a2)\u207b\u00b9 * (\u221a2)\u207b\u00b9 = (2\u207b\u00b9 : \u211d) := by\n  rw [\u2190 mul_inv]\n  norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/CHSH.lean", "context": {"open": [], "variables": ["{R : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (\u221a2)\u207b\u00b9 * (\u221a2)\u207b\u00b9 = 2\u207b\u00b9"}, {"line": "rw [\u2190 mul_inv]", "tactic_state": "\u22a2 (\u221a2 * \u221a2)\u207b\u00b9 = 2\u207b\u00b9"}, {"line": "norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem star_mem_star_iff (S : NonUnitalSubalgebra R A) (x : A) : star x \u2208 star S \u2194 x \u2208 S := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/NonUnitalSubalgebra.lean", "context": {"open": ["scoped Pointwise"], "variables": ["{F : Type v'} {R' : Type u'} {R : Type u}", "{A : Type v} {B : Type w} {C : Type w'}", "[CommSemiring R] [NonUnitalNonAssocSemiring A]", "[Star A] [Module R A]", "{S : Type w''} [SetLike S A] [NonUnitalSubsemiringClass S A]", "[hSR : SMulMemClass S R A] [StarMemClass S A] (s : S)", "{s} in", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [Star A]", "[NonUnitalNonAssocSemiring B] [Module R B] [Star B]", "[NonUnitalNonAssocSemiring C] [Module R C] [Star C]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B] [StarHomClass F A B]", "(S : NonUnitalStarSubalgebra R A)", "[CommSemiring R] [NonUnitalSemiring A] [Module R A] [Star A]", "(s : NonUnitalSubalgebra R A)", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [Star A]", "[NonUnitalNonAssocSemiring B] [Module R B] [Star B]", "[NonUnitalNonAssocSemiring C] [Module R C] [Star C]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B] [StarHomClass F A B]", "[CommSemiring R]", "[NonUnitalSemiring A] [Module R A] [Star A]", "[NonUnitalSemiring B] [Module R B] [Star B]", "[NonUnitalSemiring C] [Module R C] [Star C]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B] [StarHomClass F A B]", "[CommSemiring R] [StarRing R]", "[NonUnitalSemiring A] [StarRing A] [Module R A]", "[StarModule R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2\u2074 : CommSemiring R\ninst\u271d\u00b2\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2\u00b2 : Star A\ninst\u271d\u00b2\u00b9 : Module R A\ninst\u271d\u00b2\u2070 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b9\u2079 : Module R A\ninst\u271d\u00b9\u2078 : Star A\ninst\u271d\u00b9\u2077 : CommSemiring R\ninst\u271d\u00b9\u2076 : NonUnitalSemiring A\ninst\u271d\u00b9\u2075 : Module R A\ninst\u271d\u00b9\u2074 : Star A\ninst\u271d\u00b9\u00b3 : CommSemiring R\ninst\u271d\u00b9\u00b2 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b9\u00b9 : Module R A\ninst\u271d\u00b9\u2070 : Star A\ninst\u271d\u2079 : CommSemiring R\ninst\u271d\u2078 : NonUnitalSemiring A\ninst\u271d\u2077 : Module R A\ninst\u271d\u2076 : Star A\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : StarRing R\ninst\u271d\u00b3 : NonUnitalSemiring A\ninst\u271d\u00b2 : StarRing A\ninst\u271d\u00b9 : Module R A\ninst\u271d : StarModule R A\nS : NonUnitalSubalgebra R A\nx : A\n\u22a2 star x \u2208 sorry \u2194 x \u2208 S"}, {"line": "simp", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2\u2074 : CommSemiring R\ninst\u271d\u00b2\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2\u00b2 : Star A\ninst\u271d\u00b2\u00b9 : Module R A\ninst\u271d\u00b2\u2070 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b9\u2079 : Module R A\ninst\u271d\u00b9\u2078 : Star A\ninst\u271d\u00b9\u2077 : CommSemiring R\ninst\u271d\u00b9\u2076 : NonUnitalSemiring A\ninst\u271d\u00b9\u2075 : Module R A\ninst\u271d\u00b9\u2074 : Star A\ninst\u271d\u00b9\u00b3 : CommSemiring R\ninst\u271d\u00b9\u00b2 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b9\u00b9 : Module R A\ninst\u271d\u00b9\u2070 : Star A\ninst\u271d\u2079 : CommSemiring R\ninst\u271d\u2078 : NonUnitalSemiring A\ninst\u271d\u2077 : Module R A\ninst\u271d\u2076 : Star A\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : StarRing R\ninst\u271d\u00b3 : NonUnitalSemiring A\ninst\u271d\u00b2 : StarRing A\ninst\u271d\u00b9 : Module R A\ninst\u271d : StarModule R A\nS : NonUnitalSubalgebra R A\nx : A\n\u22a2 star x \u2208 sorry () \u2194 x \u2208 S"}]}
{"declaration": "lemma span_eq_toSubmodule {R} [CommSemiring R] [Module R A] (s : NonUnitalStarSubalgebra R A) :\n    Submodule.span R (s : Set A) = s.toSubmodule := by\n  simp [SetLike.ext'_iff, Submodule.coe_span_eq_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/NonUnitalSubalgebra.lean", "context": {"open": ["scoped Pointwise", "scoped Pointwise", "NonUnitalStarSubalgebra"], "variables": ["{F : Type v'} {R' : Type u'} {R : Type u}", "{A : Type v} {B : Type w} {C : Type w'}", "[CommSemiring R] [NonUnitalNonAssocSemiring A]", "[Star A] [Module R A]", "{S : Type w''} [SetLike S A] [NonUnitalSubsemiringClass S A]", "[hSR : SMulMemClass S R A] [StarMemClass S A] (s : S)", "{s} in", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [Star A]", "[NonUnitalNonAssocSemiring B] [Module R B] [Star B]", "[NonUnitalNonAssocSemiring C] [Module R C] [Star C]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B] [StarHomClass F A B]", "(S : NonUnitalStarSubalgebra R A)", "[CommSemiring R] [NonUnitalSemiring A] [Module R A] [Star A]", "(s : NonUnitalSubalgebra R A)", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [Star A]", "[NonUnitalNonAssocSemiring B] [Module R B] [Star B]", "[NonUnitalNonAssocSemiring C] [Module R C] [Star C]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B] [StarHomClass F A B]", "[CommSemiring R]", "[NonUnitalSemiring A] [Module R A] [Star A]", "[NonUnitalSemiring B] [Module R B] [Star B]", "[NonUnitalSemiring C] [Module R C] [Star C]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B] [StarHomClass F A B]", "[CommSemiring R] [StarRing R]", "[NonUnitalSemiring A] [StarRing A] [Module R A]", "[StarModule R A]", "(R)", "[IsScalarTower R A A] [SMulCommClass R A A]", "{R}", "[CommSemiring R] [StarRing R]", "[NonUnitalSemiring A] [StarRing A] [Module R A]", "[NonUnitalSemiring B] [StarRing B] [Module R B]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B] [StarHomClass F A B]", "[IsScalarTower R A A] [SMulCommClass R A A] [StarModule R A]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type v\ninst\u271d\u00b9\u2075 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b9\u2074 : Star A\ninst\u271d\u00b9\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b9\u00b2 : Star A\ninst\u271d\u00b9\u00b9 : NonUnitalSemiring A\ninst\u271d\u00b9\u2070 : Star A\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Star A\ninst\u271d\u2077 : NonUnitalSemiring A\ninst\u271d\u2076 : Star A\ninst\u271d\u2075 : NonUnitalSemiring A\ninst\u271d\u2074 : StarRing A\ninst\u271d\u00b3 : NonUnitalSemiring A\ninst\u271d\u00b2 : StarRing A\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Module R A\ns : NonUnitalStarSubalgebra R A\n\u22a2 Submodule.span R \u2191s = s.toSubmodule"}, {"line": "simp [SetLike.ext'_iff, Submodule.coe_span_eq_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 NonUnitalStarSubalgebra R A} :\n    (\u2191(\u2a05 i, S i) : Set A) = \u22c2 i, S i := by simp [iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/NonUnitalSubalgebra.lean", "context": {"open": ["scoped Pointwise", "scoped Pointwise", "NonUnitalStarSubalgebra"], "variables": ["{F : Type v'} {R' : Type u'} {R : Type u}", "{A : Type v} {B : Type w} {C : Type w'}", "[CommSemiring R] [NonUnitalNonAssocSemiring A]", "[Star A] [Module R A]", "{S : Type w''} [SetLike S A] [NonUnitalSubsemiringClass S A]", "[hSR : SMulMemClass S R A] [StarMemClass S A] (s : S)", "{s} in", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [Star A]", "[NonUnitalNonAssocSemiring B] [Module R B] [Star B]", "[NonUnitalNonAssocSemiring C] [Module R C] [Star C]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B] [StarHomClass F A B]", "(S : NonUnitalStarSubalgebra R A)", "[CommSemiring R] [NonUnitalSemiring A] [Module R A] [Star A]", "(s : NonUnitalSubalgebra R A)", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [Star A]", "[NonUnitalNonAssocSemiring B] [Module R B] [Star B]", "[NonUnitalNonAssocSemiring C] [Module R C] [Star C]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B] [StarHomClass F A B]", "[CommSemiring R]", "[NonUnitalSemiring A] [Module R A] [Star A]", "[NonUnitalSemiring B] [Module R B] [Star B]", "[NonUnitalSemiring C] [Module R C] [Star C]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B] [StarHomClass F A B]", "[CommSemiring R] [StarRing R]", "[NonUnitalSemiring A] [StarRing A] [Module R A]", "[StarModule R A]", "(R)", "[IsScalarTower R A A] [SMulCommClass R A A]", "{R}", "[CommSemiring R] [StarRing R]", "[NonUnitalSemiring A] [StarRing A] [Module R A]", "[NonUnitalSemiring B] [StarRing B] [Module R B]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B] [StarHomClass F A B]", "[IsScalarTower R A A] [SMulCommClass R A A] [StarModule R A]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b3\u2074 : CommSemiring R\ninst\u271d\u00b3\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b3\u00b2 : Star A\ninst\u271d\u00b3\u00b9 : Module R A\ninst\u271d\u00b3\u2070 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2\u2079 : Module R A\ninst\u271d\u00b2\u2078 : Star A\ninst\u271d\u00b2\u2077 : CommSemiring R\ninst\u271d\u00b2\u2076 : NonUnitalSemiring A\ninst\u271d\u00b2\u2075 : Module R A\ninst\u271d\u00b2\u2074 : Star A\ninst\u271d\u00b2\u00b3 : CommSemiring R\ninst\u271d\u00b2\u00b2 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2\u00b9 : Module R A\ninst\u271d\u00b2\u2070 : Star A\ninst\u271d\u00b9\u2079 : CommSemiring R\ninst\u271d\u00b9\u2078 : NonUnitalSemiring A\ninst\u271d\u00b9\u2077 : Module R A\ninst\u271d\u00b9\u2076 : Star A\ninst\u271d\u00b9\u2075 : CommSemiring R\ninst\u271d\u00b9\u2074 : StarRing R\ninst\u271d\u00b9\u00b3 : NonUnitalSemiring A\ninst\u271d\u00b9\u00b2 : StarRing A\ninst\u271d\u00b9\u00b9 : Module R A\ninst\u271d\u00b9\u2070 : StarModule R A\ninst\u271d\u2079 : IsScalarTower R A A\ninst\u271d\u2078 : SMulCommClass R A A\ninst\u271d\u2077 : CommSemiring R\ninst\u271d\u2076 : StarRing R\ninst\u271d\u2075 : NonUnitalSemiring A\ninst\u271d\u2074 : StarRing A\ninst\u271d\u00b3 : Module R A\ninst\u271d\u00b2 : IsScalarTower R A A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : StarModule R A\n\u03b9 : Sort u_1\nS : \u03b9 \u2192 NonUnitalStarSubalgebra R A\n\u22a2 sorry = \u22c2 i, \u2191(S i)"}, {"line": "simp [iInf]", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b3\u2074 : CommSemiring R\ninst\u271d\u00b3\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b3\u00b2 : Star A\ninst\u271d\u00b3\u00b9 : Module R A\ninst\u271d\u00b3\u2070 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2\u2079 : Module R A\ninst\u271d\u00b2\u2078 : Star A\ninst\u271d\u00b2\u2077 : CommSemiring R\ninst\u271d\u00b2\u2076 : NonUnitalSemiring A\ninst\u271d\u00b2\u2075 : Module R A\ninst\u271d\u00b2\u2074 : Star A\ninst\u271d\u00b2\u00b3 : CommSemiring R\ninst\u271d\u00b2\u00b2 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2\u00b9 : Module R A\ninst\u271d\u00b2\u2070 : Star A\ninst\u271d\u00b9\u2079 : CommSemiring R\ninst\u271d\u00b9\u2078 : NonUnitalSemiring A\ninst\u271d\u00b9\u2077 : Module R A\ninst\u271d\u00b9\u2076 : Star A\ninst\u271d\u00b9\u2075 : CommSemiring R\ninst\u271d\u00b9\u2074 : StarRing R\ninst\u271d\u00b9\u00b3 : NonUnitalSemiring A\ninst\u271d\u00b9\u00b2 : StarRing A\ninst\u271d\u00b9\u00b9 : Module R A\ninst\u271d\u00b9\u2070 : StarModule R A\ninst\u271d\u2079 : IsScalarTower R A A\ninst\u271d\u2078 : SMulCommClass R A A\ninst\u271d\u2077 : CommSemiring R\ninst\u271d\u2076 : StarRing R\ninst\u271d\u2075 : NonUnitalSemiring A\ninst\u271d\u2074 : StarRing A\ninst\u271d\u00b3 : Module R A\ninst\u271d\u00b2 : IsScalarTower R A A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : StarModule R A\n\u03b9 : Sort u_1\nS : \u03b9 \u2192 NonUnitalStarSubalgebra R A\n\u22a2 sorry () = \u22c2 i, \u2191(S i)"}]}
{"declaration": "theorem map_iInf {\u03b9 : Sort*} [Nonempty \u03b9]\n    [IsScalarTower R B B] [SMulCommClass R B B] [StarModule R B] (f : F)\n    (hf : Function.Injective f) (S : \u03b9 \u2192 NonUnitalStarSubalgebra R A) :\n    ((\u2a05 i, S i).map f : NonUnitalStarSubalgebra R B) = \u2a05 i, (S i).map f := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe \u2218 S)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/NonUnitalSubalgebra.lean", "context": {"open": ["scoped Pointwise", "scoped Pointwise", "NonUnitalStarSubalgebra"], "variables": ["{F : Type v'} {R' : Type u'} {R : Type u}", "{A : Type v} {B : Type w} {C : Type w'}", "[CommSemiring R] [NonUnitalNonAssocSemiring A]", "[Star A] [Module R A]", "{S : Type w''} [SetLike S A] [NonUnitalSubsemiringClass S A]", "[hSR : SMulMemClass S R A] [StarMemClass S A] (s : S)", "{s} in", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [Star A]", "[NonUnitalNonAssocSemiring B] [Module R B] [Star B]", "[NonUnitalNonAssocSemiring C] [Module R C] [Star C]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B] [StarHomClass F A B]", "(S : NonUnitalStarSubalgebra R A)", "[CommSemiring R] [NonUnitalSemiring A] [Module R A] [Star A]", "(s : NonUnitalSubalgebra R A)", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [Star A]", "[NonUnitalNonAssocSemiring B] [Module R B] [Star B]", "[NonUnitalNonAssocSemiring C] [Module R C] [Star C]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B] [StarHomClass F A B]", "[CommSemiring R]", "[NonUnitalSemiring A] [Module R A] [Star A]", "[NonUnitalSemiring B] [Module R B] [Star B]", "[NonUnitalSemiring C] [Module R C] [Star C]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B] [StarHomClass F A B]", "[CommSemiring R] [StarRing R]", "[NonUnitalSemiring A] [StarRing A] [Module R A]", "[StarModule R A]", "(R)", "[IsScalarTower R A A] [SMulCommClass R A A]", "{R}", "[CommSemiring R] [StarRing R]", "[NonUnitalSemiring A] [StarRing A] [Module R A]", "[NonUnitalSemiring B] [StarRing B] [Module R B]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B] [StarHomClass F A B]", "[IsScalarTower R A A] [SMulCommClass R A A] [StarModule R A]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type v'\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076\u00b2 : CommSemiring R\ninst\u271d\u2076\u00b9 : NonUnitalNonAssocSemiring A\ninst\u271d\u2076\u2070 : Star A\ninst\u271d\u2075\u2079 : Module R A\ninst\u271d\u2075\u2078 : NonUnitalNonAssocSemiring A\ninst\u271d\u2075\u2077 : Module R A\ninst\u271d\u2075\u2076 : Star A\ninst\u271d\u2075\u2075 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075\u2074 : Module R B\ninst\u271d\u2075\u00b3 : Star B\ninst\u271d\u2075\u00b2 : FunLike F A B\ninst\u271d\u2075\u00b9 : NonUnitalAlgHomClass F R A B\ninst\u271d\u2075\u2070 : StarHomClass F A B\ninst\u271d\u2074\u2079 : CommSemiring R\ninst\u271d\u2074\u2078 : NonUnitalSemiring A\ninst\u271d\u2074\u2077 : Module R A\ninst\u271d\u2074\u2076 : Star A\ninst\u271d\u2074\u2075 : CommSemiring R\ninst\u271d\u2074\u2074 : NonUnitalNonAssocSemiring A\ninst\u271d\u2074\u00b3 : Module R A\ninst\u271d\u2074\u00b2 : Star A\ninst\u271d\u2074\u00b9 : NonUnitalNonAssocSemiring B\ninst\u271d\u2074\u2070 : Module R B\ninst\u271d\u00b3\u2079 : Star B\ninst\u271d\u00b3\u2078 : FunLike F A B\ninst\u271d\u00b3\u2077 : NonUnitalAlgHomClass F R A B\ninst\u271d\u00b3\u2076 : StarHomClass F A B\ninst\u271d\u00b3\u2075 : CommSemiring R\ninst\u271d\u00b3\u2074 : NonUnitalSemiring A\ninst\u271d\u00b3\u00b3 : Module R A\ninst\u271d\u00b3\u00b2 : Star A\ninst\u271d\u00b3\u00b9 : NonUnitalSemiring B\ninst\u271d\u00b3\u2070 : Module R B\ninst\u271d\u00b2\u2079 : Star B\ninst\u271d\u00b2\u2078 : FunLike F A B\ninst\u271d\u00b2\u2077 : NonUnitalAlgHomClass F R A B\ninst\u271d\u00b2\u2076 : StarHomClass F A B\ninst\u271d\u00b2\u2075 : CommSemiring R\ninst\u271d\u00b2\u2074 : StarRing R\ninst\u271d\u00b2\u00b3 : NonUnitalSemiring A\ninst\u271d\u00b2\u00b2 : StarRing A\ninst\u271d\u00b2\u00b9 : Module R A\ninst\u271d\u00b2\u2070 : StarModule R A\ninst\u271d\u00b9\u2079 : IsScalarTower R A A\ninst\u271d\u00b9\u2078 : SMulCommClass R A A\ninst\u271d\u00b9\u2077 : CommSemiring R\ninst\u271d\u00b9\u2076 : StarRing R\ninst\u271d\u00b9\u2075 : NonUnitalSemiring A\ninst\u271d\u00b9\u2074 : StarRing A\ninst\u271d\u00b9\u00b3 : Module R A\ninst\u271d\u00b9\u00b2 : NonUnitalSemiring B\ninst\u271d\u00b9\u00b9 : StarRing B\ninst\u271d\u00b9\u2070 : Module R B\ninst\u271d\u2079 : FunLike F A B\ninst\u271d\u2078 : NonUnitalAlgHomClass F R A B\ninst\u271d\u2077 : StarHomClass F A B\ninst\u271d\u2076 : IsScalarTower R A A\ninst\u271d\u2075 : SMulCommClass R A A\ninst\u271d\u2074 : StarModule R A\n\u03b9 : Sort u_1\ninst\u271d\u00b3 : Nonempty \u03b9\ninst\u271d\u00b2 : IsScalarTower R B B\ninst\u271d\u00b9 : SMulCommClass R B B\ninst\u271d : StarModule R B\nf : F\nhf : Function.Injective \u21d1f\nS : \u03b9 \u2192 NonUnitalStarSubalgebra R A\n\u22a2 sorry = sorry"}, {"line": "apply SetLike.coe_injective", "tactic_state": "case a\nF : Type v'\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076\u00b2 : CommSemiring R\ninst\u271d\u2076\u00b9 : NonUnitalNonAssocSemiring A\ninst\u271d\u2076\u2070 : Star A\ninst\u271d\u2075\u2079 : Module R A\ninst\u271d\u2075\u2078 : NonUnitalNonAssocSemiring A\ninst\u271d\u2075\u2077 : Module R A\ninst\u271d\u2075\u2076 : Star A\ninst\u271d\u2075\u2075 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075\u2074 : Module R B\ninst\u271d\u2075\u00b3 : Star B\ninst\u271d\u2075\u00b2 : FunLike F A B\ninst\u271d\u2075\u00b9 : NonUnitalAlgHomClass F R A B\ninst\u271d\u2075\u2070 : StarHomClass F A B\ninst\u271d\u2074\u2079 : CommSemiring R\ninst\u271d\u2074\u2078 : NonUnitalSemiring A\ninst\u271d\u2074\u2077 : Module R A\ninst\u271d\u2074\u2076 : Star A\ninst\u271d\u2074\u2075 : CommSemiring R\ninst\u271d\u2074\u2074 : NonUnitalNonAssocSemiring A\ninst\u271d\u2074\u00b3 : Module R A\ninst\u271d\u2074\u00b2 : Star A\ninst\u271d\u2074\u00b9 : NonUnitalNonAssocSemiring B\ninst\u271d\u2074\u2070 : Module R B\ninst\u271d\u00b3\u2079 : Star B\ninst\u271d\u00b3\u2078 : FunLike F A B\ninst\u271d\u00b3\u2077 : NonUnitalAlgHomClass F R A B\ninst\u271d\u00b3\u2076 : StarHomClass F A B\ninst\u271d\u00b3\u2075 : CommSemiring R\ninst\u271d\u00b3\u2074 : NonUnitalSemiring A\ninst\u271d\u00b3\u00b3 : Module R A\ninst\u271d\u00b3\u00b2 : Star A\ninst\u271d\u00b3\u00b9 : NonUnitalSemiring B\ninst\u271d\u00b3\u2070 : Module R B\ninst\u271d\u00b2\u2079 : Star B\ninst\u271d\u00b2\u2078 : FunLike F A B\ninst\u271d\u00b2\u2077 : NonUnitalAlgHomClass F R A B\ninst\u271d\u00b2\u2076 : StarHomClass F A B\ninst\u271d\u00b2\u2075 : CommSemiring R\ninst\u271d\u00b2\u2074 : StarRing R\ninst\u271d\u00b2\u00b3 : NonUnitalSemiring A\ninst\u271d\u00b2\u00b2 : StarRing A\ninst\u271d\u00b2\u00b9 : Module R A\ninst\u271d\u00b2\u2070 : StarModule R A\ninst\u271d\u00b9\u2079 : IsScalarTower R A A\ninst\u271d\u00b9\u2078 : SMulCommClass R A A\ninst\u271d\u00b9\u2077 : CommSemiring R\ninst\u271d\u00b9\u2076 : StarRing R\ninst\u271d\u00b9\u2075 : NonUnitalSemiring A\ninst\u271d\u00b9\u2074 : StarRing A\ninst\u271d\u00b9\u00b3 : Module R A\ninst\u271d\u00b9\u00b2 : NonUnitalSemiring B\ninst\u271d\u00b9\u00b9 : StarRing B\ninst\u271d\u00b9\u2070 : Module R B\ninst\u271d\u2079 : FunLike F A B\ninst\u271d\u2078 : NonUnitalAlgHomClass F R A B\ninst\u271d\u2077 : StarHomClass F A B\ninst\u271d\u2076 : IsScalarTower R A A\ninst\u271d\u2075 : SMulCommClass R A A\ninst\u271d\u2074 : StarModule R A\n\u03b9 : Sort u_1\ninst\u271d\u00b3 : Nonempty \u03b9\ninst\u271d\u00b2 : IsScalarTower R B B\ninst\u271d\u00b9 : SMulCommClass R B B\ninst\u271d : StarModule R B\nf : F\nhf : Function.Injective \u21d1f\nS : \u03b9 \u2192 NonUnitalStarSubalgebra R A\n\u22a2 \u2191sorry = \u2191sorry"}, {"line": "simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe \u2218 S)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma StarMemClass.star_coe_eq {S \u03b1 : Type*} [InvolutiveStar \u03b1] [SetLike S \u03b1]\n    [StarMemClass S \u03b1] (s : S) : star (s : Set \u03b1) = s := by\n  ext x\n  simp only [Set.mem_star]\n  simp only [SetLike.mem_coe]\n  exact \u27e8by simpa only [star_star] using star_mem (s := s) (r := star x), star_mem\u27e9", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/Pointwise.lean", "context": {"open": ["Pointwise"], "variables": ["{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b2 : InvolutiveStar \u03b1\ninst\u271d\u00b9 : SetLike S \u03b1\ninst\u271d : StarMemClass S \u03b1\ns : S\n\u22a2 star \u2191s = \u2191s"}, {"line": "ext x", "tactic_state": "case h\nS : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b2 : InvolutiveStar \u03b1\ninst\u271d\u00b9 : SetLike S \u03b1\ninst\u271d : StarMemClass S \u03b1\ns : S\nx : \u03b1\n\u22a2 x \u2208 star \u2191s \u2194 x \u2208 \u2191s"}, {"line": "simp only [Set.mem_star]", "tactic_state": "case h\nS : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b2 : InvolutiveStar \u03b1\ninst\u271d\u00b9 : SetLike S \u03b1\ninst\u271d : StarMemClass S \u03b1\ns : S\nx : \u03b1\n\u22a2 star x \u2208 \u2191s \u2194 x \u2208 \u2191s"}, {"line": "simp only [SetLike.mem_coe]", "tactic_state": "case h\nS : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b2 : InvolutiveStar \u03b1\ninst\u271d\u00b9 : SetLike S \u03b1\ninst\u271d : StarMemClass S \u03b1\ns : S\nx : \u03b1\n\u22a2 star x \u2208 s \u2194 x \u2208 s"}, {"line": "exact \u27e8by simpa only [star_star] using star_mem (s := s) (r := star x), star_mem\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem star_mem_star_iff (S : Subalgebra R A) (x : A) : star x \u2208 star S \u2194 x \u2208 S := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/Subalgebra.lean", "context": {"open": ["Set in", "Pointwise"], "variables": ["{F R A B C : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [StarRing A] [Algebra R A] [StarModule R A]", "[Semiring B] [StarRing B] [Algebra R B] [StarModule R B]", "[Semiring C] [StarRing C] [Algebra R C] [StarModule R C]", "(S : StarSubalgebra R A)", "(R)", "{F R A B : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [Algebra R A] [StarRing A] [StarModule R A]", "[Semiring B] [Algebra R B] [StarRing B] [StarModule R B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_7\nA : Type u_8\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : StarRing R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : StarModule R A\nS : Subalgebra R A\nx : A\n\u22a2 star x \u2208 star S \u2194 x \u2208 S"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_sInf {S : Set (StarSubalgebra R A)} {x : A} : x \u2208 sInf S \u2194 \u2200 p \u2208 S, x \u2208 p := by\n  simp only [\u2190 SetLike.mem_coe]\n  simp only [coe_sInf]\n  simp only [Set.mem_iInter\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/Subalgebra.lean", "context": {"open": ["Set in", "Pointwise", "StarSubalgebra", "Submodule in", "Submodule in"], "variables": ["{F R A B C : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [StarRing A] [Algebra R A] [StarModule R A]", "[Semiring B] [StarRing B] [Algebra R B] [StarModule R B]", "[Semiring C] [StarRing C] [Algebra R C] [StarModule R C]", "(S : StarSubalgebra R A)", "(R)", "{F R A B : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [Algebra R A] [StarRing A] [StarModule R A]", "[Semiring B] [Algebra R B] [StarRing B] [StarModule R B]", "(R) in", "{F R A B : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [Algebra R A] [StarRing A] [StarModule R A]", "[Semiring B] [Algebra R B] [StarRing B] [StarModule R B]", "(R)", "{R}", "(R)", "{F R A B : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [Algebra R A] [StarRing A] [StarModule R A]", "[Semiring B] [Algebra R B] [StarRing B] [StarModule R B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\nA : Type u_7\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : StarRing R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : StarModule R A\nS : Set (StarSubalgebra R A)\nx : A\n\u22a2 x \u2208 sInf S \u2194 \u2200 p \u2208 S, x \u2208 p"}, {"line": "simp only [\u2190 SetLike.mem_coe]", "tactic_state": "R : Type u_6\nA : Type u_7\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : StarRing R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : StarModule R A\nS : Set (StarSubalgebra R A)\nx : A\n\u22a2 x \u2208 \u2191(sInf S) \u2194 \u2200 p \u2208 S, x \u2208 \u2191p"}, {"line": "simp only [coe_sInf]", "tactic_state": "R : Type u_6\nA : Type u_7\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : StarRing R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : StarModule R A\nS : Set (StarSubalgebra R A)\nx : A\n\u22a2 x \u2208 \u22c2 s \u2208 S, \u2191s \u2194 \u2200 p \u2208 S, x \u2208 \u2191p"}, {"line": "simp only [Set.mem_iInter\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 StarSubalgebra R A} : (\u2191(\u2a05 i, S i) : Set A) = \u22c2 i, S i := by\n  simp [iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/Subalgebra.lean", "context": {"open": ["Set in", "Pointwise", "StarSubalgebra", "Submodule in", "Submodule in"], "variables": ["{F R A B C : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [StarRing A] [Algebra R A] [StarModule R A]", "[Semiring B] [StarRing B] [Algebra R B] [StarModule R B]", "[Semiring C] [StarRing C] [Algebra R C] [StarModule R C]", "(S : StarSubalgebra R A)", "(R)", "{F R A B : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [Algebra R A] [StarRing A] [StarModule R A]", "[Semiring B] [Algebra R B] [StarRing B] [StarModule R B]", "(R) in", "{F R A B : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [Algebra R A] [StarRing A] [StarModule R A]", "[Semiring B] [Algebra R B] [StarRing B] [StarModule R B]", "(R)", "{R}", "(R)", "{F R A B : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [Algebra R A] [StarRing A] [StarModule R A]", "[Semiring B] [Algebra R B] [StarRing B] [StarModule R B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\nA : Type u_7\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : StarRing R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : StarModule R A\n\u03b9 : Sort u_9\nS : \u03b9 \u2192 StarSubalgebra R A\n\u22a2 \u2191(\u2a05 i, S i) = \u22c2 i, \u2191(S i)"}, {"line": "simp [iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 StarSubalgebra R A} {x : A} :\n    (x \u2208 \u2a05 i, S i) \u2194 \u2200 i, x \u2208 S i := by simp only [iInf, mem_sInf, Set.forall_mem_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/Subalgebra.lean", "context": {"open": ["Set in", "Pointwise", "StarSubalgebra", "Submodule in", "Submodule in"], "variables": ["{F R A B C : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [StarRing A] [Algebra R A] [StarModule R A]", "[Semiring B] [StarRing B] [Algebra R B] [StarModule R B]", "[Semiring C] [StarRing C] [Algebra R C] [StarModule R C]", "(S : StarSubalgebra R A)", "(R)", "{F R A B : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [Algebra R A] [StarRing A] [StarModule R A]", "[Semiring B] [Algebra R B] [StarRing B] [StarModule R B]", "(R) in", "{F R A B : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [Algebra R A] [StarRing A] [StarModule R A]", "[Semiring B] [Algebra R B] [StarRing B] [StarModule R B]", "(R)", "{R}", "(R)", "{F R A B : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [Algebra R A] [StarRing A] [StarModule R A]", "[Semiring B] [Algebra R B] [StarRing B] [StarModule R B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\nA : Type u_7\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : StarRing R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : StarModule R A\n\u03b9 : Sort u_9\nS : \u03b9 \u2192 StarSubalgebra R A\nx : A\n\u22a2 x \u2208 \u2a05 i, S i \u2194 \u2200 (i : \u03b9), x \u2208 S i"}, {"line": "simp only [iInf, mem_sInf, Set.forall_mem_range]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_iInf {\u03b9 : Sort*} [Nonempty \u03b9] (f : A \u2192\u22c6\u2090[R] B) (hf : Function.Injective f)\n    (s : \u03b9 \u2192 StarSubalgebra R A) : map f (iInf s) = \u2a05 (i : \u03b9), map f (s i) := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe \u2218 s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/Subalgebra.lean", "context": {"open": ["Set in", "Pointwise", "StarSubalgebra", "Submodule in", "Submodule in"], "variables": ["{F R A B C : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [StarRing A] [Algebra R A] [StarModule R A]", "[Semiring B] [StarRing B] [Algebra R B] [StarModule R B]", "[Semiring C] [StarRing C] [Algebra R C] [StarModule R C]", "(S : StarSubalgebra R A)", "(R)", "{F R A B : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [Algebra R A] [StarRing A] [StarModule R A]", "[Semiring B] [Algebra R B] [StarRing B] [StarModule R B]", "(R) in", "{F R A B : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [Algebra R A] [StarRing A] [StarModule R A]", "[Semiring B] [Algebra R B] [StarRing B] [StarModule R B]", "(R)", "{R}", "(R)", "{F R A B : Type*} [CommSemiring R] [StarRing R]", "[Semiring A] [Algebra R A] [StarRing A] [StarModule R A]", "[Semiring B] [Algebra R B] [StarRing B] [StarModule R B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\nA : Type u_7\nB : Type u_8\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : StarRing R\ninst\u271d\u2078 : Semiring A\ninst\u271d\u2077 : Algebra R A\ninst\u271d\u2076 : StarRing A\ninst\u271d\u2075 : StarModule R A\ninst\u271d\u2074 : Semiring B\ninst\u271d\u00b3 : Algebra R B\ninst\u271d\u00b2 : StarRing B\ninst\u271d\u00b9 : StarModule R B\n\u03b9 : Sort u_9\ninst\u271d : Nonempty \u03b9\nf : A \u2192\u22c6\u2090[R] B\nhf : Function.Injective \u21d1f\ns : \u03b9 \u2192 StarSubalgebra R A\n\u22a2 map f (iInf s) = \u2a05 i, map f (s i)"}, {"line": "apply SetLike.coe_injective", "tactic_state": "case a\nR : Type u_6\nA : Type u_7\nB : Type u_8\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : StarRing R\ninst\u271d\u2078 : Semiring A\ninst\u271d\u2077 : Algebra R A\ninst\u271d\u2076 : StarRing A\ninst\u271d\u2075 : StarModule R A\ninst\u271d\u2074 : Semiring B\ninst\u271d\u00b3 : Algebra R B\ninst\u271d\u00b2 : StarRing B\ninst\u271d\u00b9 : StarModule R B\n\u03b9 : Sort u_9\ninst\u271d : Nonempty \u03b9\nf : A \u2192\u22c6\u2090[R] B\nhf : Function.Injective \u21d1f\ns : \u03b9 \u2192 StarSubalgebra R A\n\u22a2 \u2191(map f (iInf s)) = \u2191(\u2a05 i, map f (s i))"}, {"line": "simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe \u2218 s)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_mem {r : R} (hr : r \u2208 unitary R) : f r \u2208 unitary S := by\n  rw [unitary.mem_iff] at hr\n  simpa [map_star, map_mul] using And.intro congr(f $(hr.1)) congr(f $(hr.2))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/Unitary.lean", "context": {"open": [], "variables": ["{R : Type*}", "[Monoid R] [StarMul R]", "{F R S : Type*} [Monoid R] [StarMul R] [Monoid S] [StarMul S]", "[FunLike F R S] [StarHomClass F R S] [MonoidHomClass F R S] (f : F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_2\nR : Type u_3\nS : Type u_4\ninst\u271d\u2076 : Monoid R\ninst\u271d\u2075 : StarMul R\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : StarMul S\ninst\u271d\u00b2 : FunLike F R S\ninst\u271d\u00b9 : StarHomClass F R S\ninst\u271d : MonoidHomClass F R S\nf : F\nr : R\nhr : r \u2208 unitary R\n\u22a2 f r \u2208 unitary S"}, {"line": "rw [unitary.mem_iff] at hr", "tactic_state": "F : Type u_2\nR : Type u_3\nS : Type u_4\ninst\u271d\u2076 : Monoid R\ninst\u271d\u2075 : StarMul R\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : StarMul S\ninst\u271d\u00b2 : FunLike F R S\ninst\u271d\u00b9 : StarHomClass F R S\ninst\u271d : MonoidHomClass F R S\nf : F\nr : R\nhr : star r * r = 1 \u2227 r * star r = 1\n\u22a2 f r \u2208 unitary S"}, {"line": "simpa [map_star, map_mul] using And.intro congr(f $(hr.1)) congr(f $(hr.2))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_zpow (U : unitary R) (z : \u2124) : \u2191(U ^ z) = (U : R) ^ z := by\n  cases z\n  \u00b7 simp [SubmonoidClass.coe_pow]\n  \u00b7 simp [coe_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/Unitary.lean", "context": {"open": [], "variables": ["{R : Type*}", "[Monoid R] [StarMul R]", "{F R S : Type*} [Monoid R] [StarMul R] [Monoid S] [StarMul S]", "[FunLike F R S] [StarHomClass F R S] [MonoidHomClass F R S] (f : F)", "[CommMonoid R] [StarMul R]", "[GroupWithZero R] [StarMul R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u2075 : Monoid R\ninst\u271d\u2074 : StarMul R\ninst\u271d\u00b3 : CommMonoid R\ninst\u271d\u00b2 : StarMul R\ninst\u271d\u00b9 : GroupWithZero R\ninst\u271d : StarMul R\nU : \u21a5(unitary R)\nz : \u2124\n\u22a2 \u2191(U ^ z) = \u2191U ^ z"}, {"line": "cases z", "tactic_state": "case ofNat\nR : Type u_3\ninst\u271d\u2075 : Monoid R\ninst\u271d\u2074 : StarMul R\ninst\u271d\u00b3 : CommMonoid R\ninst\u271d\u00b2 : StarMul R\ninst\u271d\u00b9 : GroupWithZero R\ninst\u271d : StarMul R\nU : \u21a5(unitary R)\na\u271d : \u2115\n\u22a2 \u2191(U ^ Int.ofNat a\u271d) = \u2191U ^ Int.ofNat a\u271d\n---\ncase negSucc\nR : Type u_3\ninst\u271d\u2075 : Monoid R\ninst\u271d\u2074 : StarMul R\ninst\u271d\u00b3 : CommMonoid R\ninst\u271d\u00b2 : StarMul R\ninst\u271d\u00b9 : GroupWithZero R\ninst\u271d : StarMul R\nU : \u21a5(unitary R)\na\u271d : \u2115\n\u22a2 \u2191(U ^ Int.negSucc a\u271d) = \u2191U ^ Int.negSucc a\u271d"}, {"line": "\u00b7 simp [SubmonoidClass.coe_pow]", "tactic_state": "case negSucc\nR : Type u_3\ninst\u271d\u2075 : Monoid R\ninst\u271d\u2074 : StarMul R\ninst\u271d\u00b3 : CommMonoid R\ninst\u271d\u00b2 : StarMul R\ninst\u271d\u00b9 : GroupWithZero R\ninst\u271d : StarMul R\nU : \u21a5(unitary R)\na\u271d : \u2115\n\u22a2 \u2191(U ^ Int.negSucc a\u271d) = \u2191U ^ Int.negSucc a\u271d"}, {"line": "\u00b7 simp [coe_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma spectrum.unitary_conjugate' {a : A} {u : unitary A} :\n    spectrum R ((star u : A) * a * u) = spectrum R a := by\n  simpa using spectrum.unitary_conjugate (u := star u)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Star/Unitary.lean", "context": {"open": [], "variables": ["{R : Type*}", "[Monoid R] [StarMul R]", "{F R S : Type*} [Monoid R] [StarMul R] [Monoid S] [StarMul S]", "[FunLike F R S] [StarHomClass F R S] [MonoidHomClass F R S] (f : F)", "[CommMonoid R] [StarMul R]", "[GroupWithZero R] [StarMul R]", "[Ring R] [StarRing R]", "{R A : Type*} [CommSemiring R] [Ring A] [Algebra R A] [StarMul A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\nA : Type u_6\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Ring A\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : StarMul A\na : A\nu : \u21a5(unitary A)\n\u22a2 spectrum R (star \u2191u * a * \u2191u) = spectrum R a"}, {"line": "simpa using spectrum.unitary_conjugate (u := star u)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem List.trop_sum [AddMonoid R] (l : List R) : trop l.sum = List.prod (l.map trop) := by\n  induction' l with hd tl IH\n  \u00b7 simp\n  \u00b7 simp [\u2190 IH]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Tropical/BigOperators.lean", "context": {"open": ["Tropical Finset"], "variables": ["{R S : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : AddMonoid R\nl : List R\n\u22a2 trop l.sum = (map trop l).prod"}, {"line": "induction' l with hd tl IH", "tactic_state": "case nil\nR : Type u_1\ninst\u271d : AddMonoid R\n\u22a2 trop [].sum = (map trop []).prod\n---\ncase cons\nR : Type u_1\ninst\u271d : AddMonoid R\nhd : R\ntl : List R\nIH : trop tl.sum = (map trop tl).prod\n\u22a2 trop (hd :: tl).sum = (map trop (hd :: tl)).prod"}, {"line": "\u00b7 simp", "tactic_state": "case cons\nR : Type u_1\ninst\u271d : AddMonoid R\nhd : R\ntl : List R\nIH : trop tl.sum = (map trop tl).prod\n\u22a2 trop (hd :: tl).sum = (map trop (hd :: tl)).prod"}, {"line": "\u00b7 simp [\u2190 IH]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem trop_sum [AddCommMonoid R] (s : Finset S) (f : S \u2192 R) :\n    trop (\u2211 i \u2208 s, f i) = \u220f i \u2208 s, trop (f i) := by\n  convert Multiset.trop_sum (s.val.map f)\n  simp only [Multiset.map_map]\n  simp only [Function.comp_apply]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Tropical/BigOperators.lean", "context": {"open": ["Tropical Finset"], "variables": ["{R S : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 R\n\u22a2 trop (\u2211 i \u2208 s, f i) = \u220f i \u2208 s, trop (f i)"}, {"line": "convert Multiset.trop_sum (s.val.map f)", "tactic_state": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 R\n\u22a2 \u220f i \u2208 s, trop (f i) = (Multiset.map trop (Multiset.map f s.val)).prod"}, {"line": "simp only [Multiset.map_map]", "tactic_state": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 R\n\u22a2 \u220f i \u2208 s, trop (f i) = (Multiset.map (trop \u2218 f) s.val).prod"}, {"line": "simp only [Function.comp_apply]", "tactic_state": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 R\n\u22a2 \u220f i \u2208 s, trop (f i) = (Multiset.map (fun i => trop (f i)) s.val).prod"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem List.untrop_prod [AddMonoid R] (l : List (Tropical R)) :\n    untrop l.prod = List.sum (l.map untrop) := by\n  induction' l with hd tl IH\n  \u00b7 simp\n  \u00b7 simp [\u2190 IH]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Tropical/BigOperators.lean", "context": {"open": ["Tropical Finset"], "variables": ["{R S : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : AddMonoid R\nl : List (Tropical R)\n\u22a2 untrop l.prod = (map untrop l).sum"}, {"line": "induction' l with hd tl IH", "tactic_state": "case nil\nR : Type u_1\ninst\u271d : AddMonoid R\n\u22a2 untrop [].prod = (map untrop []).sum\n---\ncase cons\nR : Type u_1\ninst\u271d : AddMonoid R\nhd : Tropical R\ntl : List (Tropical R)\nIH : untrop tl.prod = (map untrop tl).sum\n\u22a2 untrop (hd :: tl).prod = (map untrop (hd :: tl)).sum"}, {"line": "\u00b7 simp", "tactic_state": "case cons\nR : Type u_1\ninst\u271d : AddMonoid R\nhd : Tropical R\ntl : List (Tropical R)\nIH : untrop tl.prod = (map untrop tl).sum\n\u22a2 untrop (hd :: tl).prod = (map untrop (hd :: tl)).sum"}, {"line": "\u00b7 simp [\u2190 IH]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem untrop_prod [AddCommMonoid R] (s : Finset S) (f : S \u2192 Tropical R) :\n    untrop (\u220f i \u2208 s, f i) = \u2211 i \u2208 s, untrop (f i) := by\n  convert Multiset.untrop_prod (s.val.map f)\n  simp only [Multiset.map_map]\n  simp only [Function.comp_apply]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Tropical/BigOperators.lean", "context": {"open": ["Tropical Finset"], "variables": ["{R S : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 untrop (\u220f i \u2208 s, f i) = \u2211 i \u2208 s, untrop (f i)"}, {"line": "convert Multiset.untrop_prod (s.val.map f)", "tactic_state": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 \u2211 i \u2208 s, untrop (f i) = (Multiset.map untrop (Multiset.map f s.val)).sum"}, {"line": "simp only [Multiset.map_map]", "tactic_state": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 \u2211 i \u2208 s, untrop (f i) = (Multiset.map (untrop \u2218 f) s.val).sum"}, {"line": "simp only [Function.comp_apply]", "tactic_state": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 \u2211 i \u2208 s, untrop (f i) = (Multiset.map (fun i => untrop (f i)) s.val).sum"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem List.trop_minimum [LinearOrder R] (l : List R) :\n    trop l.minimum = List.sum (l.map (trop \u2218 WithTop.some)) := by\n  induction' l with hd tl IH\n  \u00b7 simp\n  \u00b7 simp [List.minimum_cons, \u2190 IH]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Tropical/BigOperators.lean", "context": {"open": ["Tropical Finset"], "variables": ["{R S : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : LinearOrder R\nl : List R\n\u22a2 trop l.minimum = (map (trop \u2218 WithTop.some) l).sum"}, {"line": "induction' l with hd tl IH", "tactic_state": "case nil\nR : Type u_1\ninst\u271d : LinearOrder R\n\u22a2 trop [].minimum = (map (trop \u2218 WithTop.some) []).sum\n---\ncase cons\nR : Type u_1\ninst\u271d : LinearOrder R\nhd : R\ntl : List R\nIH : trop tl.minimum = (map (trop \u2218 WithTop.some) tl).sum\n\u22a2 trop (hd :: tl).minimum = (map (trop \u2218 WithTop.some) (hd :: tl)).sum"}, {"line": "\u00b7 simp", "tactic_state": "case cons\nR : Type u_1\ninst\u271d : LinearOrder R\nhd : R\ntl : List R\nIH : trop tl.minimum = (map (trop \u2218 WithTop.some) tl).sum\n\u22a2 trop (hd :: tl).minimum = (map (trop \u2218 WithTop.some) (hd :: tl)).sum"}, {"line": "\u00b7 simp [List.minimum_cons, \u2190 IH]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Multiset.trop_inf [LinearOrder R] [OrderTop R] (s : Multiset R) :\n    trop s.inf = Multiset.sum (s.map trop) := by\n  induction' s using Multiset.induction with s x IH\n  \u00b7 simp\n  \u00b7 simp [\u2190 IH]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Tropical/BigOperators.lean", "context": {"open": ["Tropical Finset"], "variables": ["{R S : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Multiset R\n\u22a2 trop s.inf = (map trop s).sum"}, {"line": "induction' s using Multiset.induction with s x IH", "tactic_state": "case empty\nR : Type u_1\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\n\u22a2 trop (inf 0) = (map trop 0).sum\n---\ncase cons\nR : Type u_1\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : R\nx : Multiset R\nIH : trop x.inf = (map trop x).sum\n\u22a2 trop (s ::\u2098 x).inf = (map trop (s ::\u2098 x)).sum"}, {"line": "\u00b7 simp", "tactic_state": "case cons\nR : Type u_1\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : R\nx : Multiset R\nIH : trop x.inf = (map trop x).sum\n\u22a2 trop (s ::\u2098 x).inf = (map trop (s ::\u2098 x)).sum"}, {"line": "\u00b7 simp [\u2190 IH]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finset.trop_inf [LinearOrder R] [OrderTop R] (s : Finset S) (f : S \u2192 R) :\n    trop (s.inf f) = \u2211 i \u2208 s, trop (f i) := by\n  convert Multiset.trop_inf (s.val.map f)\n  simp only [Multiset.map_map]\n  simp only [Function.comp_apply]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Tropical/BigOperators.lean", "context": {"open": ["Tropical Finset"], "variables": ["{R S : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 R\n\u22a2 trop (s.inf f) = \u2211 i \u2208 s, trop (f i)"}, {"line": "convert Multiset.trop_inf (s.val.map f)", "tactic_state": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 R\n\u22a2 \u2211 i \u2208 s, trop (f i) = (Multiset.map trop (Multiset.map f s.val)).sum"}, {"line": "simp only [Multiset.map_map]", "tactic_state": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 R\n\u22a2 \u2211 i \u2208 s, trop (f i) = (Multiset.map (trop \u2218 f) s.val).sum"}, {"line": "simp only [Function.comp_apply]", "tactic_state": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 R\n\u22a2 \u2211 i \u2208 s, trop (f i) = (Multiset.map (fun i => trop (f i)) s.val).sum"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem trop_iInf [ConditionallyCompleteLinearOrder R] [Fintype S] (f : S \u2192 WithTop R) :\n    trop (\u2a05 i : S, f i) = \u2211 i : S, trop (f i) := by\n  rw [iInf]\n  rw [\u2190 Set.image_univ]\n  rw [\u2190 coe_univ]\n  rw [trop_sInf_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Tropical/BigOperators.lean", "context": {"open": ["Tropical Finset"], "variables": ["{R S : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder R\ninst\u271d : Fintype S\nf : S \u2192 WithTop R\n\u22a2 trop (\u2a05 i, f i) = \u2211 i, trop (f i)"}, {"line": "rw [iInf]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder R\ninst\u271d : Fintype S\nf : S \u2192 WithTop R\n\u22a2 trop (sInf (Set.range fun i => f i)) = \u2211 i, trop (f i)"}, {"line": "rw [\u2190 Set.image_univ]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder R\ninst\u271d : Fintype S\nf : S \u2192 WithTop R\n\u22a2 trop (sInf ((fun i => f i) '' Set.univ)) = \u2211 i, trop (f i)"}, {"line": "rw [\u2190 coe_univ]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder R\ninst\u271d : Fintype S\nf : S \u2192 WithTop R\n\u22a2 trop (sInf ((fun i => f i) '' \u2191univ)) = \u2211 i, trop (f i)\n---\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder R\ninst\u271d : Fintype S\nf : S \u2192 WithTop R\n\u22a2 Fintype S"}, {"line": "rw [trop_sInf_image]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Multiset.untrop_sum [LinearOrder R] [OrderTop R] (s : Multiset (Tropical R)) :\n    untrop s.sum = Multiset.inf (s.map untrop) := by\n  induction' s using Multiset.induction with s x IH\n  \u00b7 simp\n  \u00b7 simp only [sum_cons, untrop_add, untrop_le_iff, map_cons, inf_cons, \u2190 IH]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Tropical/BigOperators.lean", "context": {"open": ["Tropical Finset"], "variables": ["{R S : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Multiset (Tropical R)\n\u22a2 untrop s.sum = (map untrop s).inf"}, {"line": "induction' s using Multiset.induction with s x IH", "tactic_state": "case empty\nR : Type u_1\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\n\u22a2 untrop (sum 0) = (map untrop 0).inf\n---\ncase cons\nR : Type u_1\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Tropical R\nx : Multiset (Tropical R)\nIH : untrop x.sum = (map untrop x).inf\n\u22a2 untrop (s ::\u2098 x).sum = (map untrop (s ::\u2098 x)).inf"}, {"line": "\u00b7 simp", "tactic_state": "case cons\nR : Type u_1\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Tropical R\nx : Multiset (Tropical R)\nIH : untrop x.sum = (map untrop x).inf\n\u22a2 untrop (s ::\u2098 x).sum = (map untrop (s ::\u2098 x)).inf"}, {"line": "\u00b7 simp only [sum_cons, untrop_add, untrop_le_iff, map_cons, inf_cons, \u2190 IH]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finset.untrop_sum' [LinearOrder R] [OrderTop R] (s : Finset S) (f : S \u2192 Tropical R) :\n    untrop (\u2211 i \u2208 s, f i) = s.inf (untrop \u2218 f) := by\n  convert Multiset.untrop_sum (s.val.map f)\n  simp only [Multiset.map_map]\n  simp only [Function.comp_apply]\n  simp only [inf_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Tropical/BigOperators.lean", "context": {"open": ["Tropical Finset"], "variables": ["{R S : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 untrop (\u2211 i \u2208 s, f i) = s.inf (untrop \u2218 f)"}, {"line": "convert Multiset.untrop_sum (s.val.map f)", "tactic_state": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 s.inf (untrop \u2218 f) = (Multiset.map untrop (Multiset.map f s.val)).inf"}, {"line": "simp only [Multiset.map_map]", "tactic_state": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 s.inf (untrop \u2218 f) = (Multiset.map (untrop \u2218 f) s.val).inf"}, {"line": "simp only [Function.comp_apply]", "tactic_state": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 s.inf (untrop \u2218 f) = (Multiset.map (fun x => untrop (f x)) s.val).inf"}, {"line": "simp only [inf_def]", "tactic_state": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 (Multiset.map (untrop \u2218 f) s.val).inf = (Multiset.map (fun x => untrop (f x)) s.val).inf"}]}
{"declaration": "theorem untrop_sum_eq_sInf_image [ConditionallyCompleteLinearOrder R] (s : Finset S)\n    (f : S \u2192 Tropical (WithTop R)) : untrop (\u2211 i \u2208 s, f i) = sInf (untrop \u2218 f '' s) := by\n  rcases s.eq_empty_or_nonempty with (rfl | h)\n  \u00b7 simp only [Set.image_empty, coe_empty, sum_empty, WithTop.sInf_empty, untrop_zero]\n  \u00b7 rw [\u2190 inf'_eq_csInf_image _ h, inf'_eq_inf, Finset.untrop_sum']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Tropical/BigOperators.lean", "context": {"open": ["Tropical Finset"], "variables": ["{R S : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrder R\ns : Finset S\nf : S \u2192 Tropical (WithTop R)\n\u22a2 untrop (\u2211 i \u2208 s, f i) = sInf (untrop \u2218 f '' \u2191s)"}, {"line": "rcases s.eq_empty_or_nonempty with (rfl | h)", "tactic_state": "case inl\nR : Type u_1\nS : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrder R\nf : S \u2192 Tropical (WithTop R)\n\u22a2 untrop (\u2211 i \u2208 \u2205, f i) = sInf (untrop \u2218 f '' \u2191\u2205)\n---\ncase inr\nR : Type u_1\nS : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrder R\ns : Finset S\nf : S \u2192 Tropical (WithTop R)\nh : s.Nonempty\n\u22a2 untrop (\u2211 i \u2208 s, f i) = sInf (untrop \u2218 f '' \u2191s)"}, {"line": "\u00b7 simp only [Set.image_empty, coe_empty, sum_empty, WithTop.sInf_empty, untrop_zero]", "tactic_state": "case inr\nR : Type u_1\nS : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrder R\ns : Finset S\nf : S \u2192 Tropical (WithTop R)\nh : s.Nonempty\n\u22a2 untrop (\u2211 i \u2208 s, f i) = sInf (untrop \u2218 f '' \u2191s)"}, {"line": "\u00b7 rw [\u2190 inf'_eq_csInf_image _ h, inf'_eq_inf, Finset.untrop_sum']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem untrop_sum [ConditionallyCompleteLinearOrder R] [Fintype S] (f : S \u2192 Tropical (WithTop R)) :\n    untrop (\u2211 i : S, f i) = \u2a05 i : S, untrop (f i) := by\n  rw [iInf]\n  rw [\u2190 Set.image_univ]\n  rw [\u2190 coe_univ]\n  rw [untrop_sum_eq_sInf_image]\n  rw [Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Tropical/BigOperators.lean", "context": {"open": ["Tropical Finset"], "variables": ["{R S : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder R\ninst\u271d : Fintype S\nf : S \u2192 Tropical (WithTop R)\n\u22a2 untrop (\u2211 i, f i) = \u2a05 i, untrop (f i)"}, {"line": "rw [iInf]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder R\ninst\u271d : Fintype S\nf : S \u2192 Tropical (WithTop R)\n\u22a2 untrop (\u2211 i, f i) = sInf (Set.range fun i => untrop (f i))"}, {"line": "rw [\u2190 Set.image_univ]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder R\ninst\u271d : Fintype S\nf : S \u2192 Tropical (WithTop R)\n\u22a2 untrop (\u2211 i, f i) = sInf ((fun i => untrop (f i)) '' Set.univ)"}, {"line": "rw [\u2190 coe_univ]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder R\ninst\u271d : Fintype S\nf : S \u2192 Tropical (WithTop R)\n\u22a2 untrop (\u2211 i, f i) = sInf ((fun i => untrop (f i)) '' \u2191univ)\n---\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder R\ninst\u271d : Fintype S\nf : S \u2192 Tropical (WithTop R)\n\u22a2 Fintype S"}, {"line": "rw [untrop_sum_eq_sInf_image]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder R\ninst\u271d : Fintype S\nf : S \u2192 Tropical (WithTop R)\n\u22a2 sInf (untrop \u2218 f '' \u2191univ) = sInf ((fun i => untrop (f i)) '' \u2191univ)\n---\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder R\ninst\u271d : Fintype S\nf : S \u2192 Tropical (WithTop R)\n\u22a2 Fintype S"}, {"line": "rw [Function.comp_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_coeff_apply_coeff (f : \u2124 \u2192 Module.End R V)\n    (hf : \u2200 (x : V), \u2203 n, \u2200 m < n, (f m) x = 0) (x : V) (n : \u2124) :\n    ((HahnModule.of R).symm ((of_coeff f hf) x)).coeff n = (f n) x := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Vertex/VertexOperator.lean", "context": {"open": ["HVertexOperator"], "variables": ["{R V : Type*} [CommRing R] [AddCommGroup V] [Module R V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module R V\nf : \u2124 \u2192 Module.End R V\nhf : \u2200 (x : V), \u2203 n, \u2200 m < n, (f m) x = 0\nx : V\nn : \u2124\n\u22a2 ((HahnModule.of R).symm ((of_coeff f \u22ef) x)).coeff n = (f n) x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isNoetherian_iff_of_finite_affine_openCover {\ud835\udcb0 : Scheme.OpenCover.{v, u} X}\n    [Finite \ud835\udcb0.J] [\u2200 i, IsAffine (\ud835\udcb0.obj i)] :\n    IsNoetherian X \u2194 \u2200 (i : \ud835\udcb0.J), IsNoetherianRing \u0393(\ud835\udcb0.obj i, \u22a4) := by\n  constructor\n  \u00b7 intro h i\n    apply (isLocallyNoetherian_iff_of_affine_openCover _).mp\n    exact h.toIsLocallyNoetherian\n  \u00b7 intro hNoeth\n    convert IsNoetherian.mk\n    \u00b7 exact (isLocallyNoetherian_iff_of_affine_openCover _).mpr hNoeth\n    \u00b7 exact Scheme.OpenCover.compactSpace \ud835\udcb0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/Noetherian.lean", "context": {"open": ["Opposite AlgebraicGeometry Localization IsLocalization TopologicalSpace", "CategoryTheory in"], "variables": ["{R : Type u} [CommRing R] (S : Finset R) (hS : Ideal.span (\u03b1 := R) S = \u22a4)", "{X : Scheme}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Scheme\n\ud835\udcb0 : X.OpenCover\ninst\u271d\u00b9 : Finite \ud835\udcb0.J\ninst\u271d : \u2200 (i : \ud835\udcb0.J), IsAffine (\ud835\udcb0.obj i)\n\u22a2 AlgebraicGeometry.IsNoetherian X \u2194 \u2200 (i : \ud835\udcb0.J), IsNoetherianRing \u2191((\ud835\udcb0.obj i).presheaf.obj (op \u22a4))"}, {"line": "constructor", "tactic_state": "case mp\nX : Scheme\n\ud835\udcb0 : X.OpenCover\ninst\u271d\u00b9 : Finite \ud835\udcb0.J\ninst\u271d : \u2200 (i : \ud835\udcb0.J), IsAffine (\ud835\udcb0.obj i)\n\u22a2 AlgebraicGeometry.IsNoetherian X \u2192 \u2200 (i : \ud835\udcb0.J), IsNoetherianRing \u2191((\ud835\udcb0.obj i).presheaf.obj (op \u22a4))\n---\ncase mpr\nX : Scheme\n\ud835\udcb0 : X.OpenCover\ninst\u271d\u00b9 : Finite \ud835\udcb0.J\ninst\u271d : \u2200 (i : \ud835\udcb0.J), IsAffine (\ud835\udcb0.obj i)\n\u22a2 (\u2200 (i : \ud835\udcb0.J), IsNoetherianRing \u2191((\ud835\udcb0.obj i).presheaf.obj (op \u22a4))) \u2192 AlgebraicGeometry.IsNoetherian X"}, {"line": "\u00b7 intro h i\n    apply (isLocallyNoetherian_iff_of_affine_openCover _).mp\n    exact h.toIsLocallyNoetherian", "tactic_state": "case mpr\nX : Scheme\n\ud835\udcb0 : X.OpenCover\ninst\u271d\u00b9 : Finite \ud835\udcb0.J\ninst\u271d : \u2200 (i : \ud835\udcb0.J), IsAffine (\ud835\udcb0.obj i)\n\u22a2 (\u2200 (i : \ud835\udcb0.J), IsNoetherianRing \u2191((\ud835\udcb0.obj i).presheaf.obj (op \u22a4))) \u2192 AlgebraicGeometry.IsNoetherian X"}, {"line": "\u00b7 intro hNoeth\n    convert IsNoetherian.mk\n    \u00b7 exact (isLocallyNoetherian_iff_of_affine_openCover _).mpr hNoeth\n    \u00b7 exact Scheme.OpenCover.compactSpace \ud835\udcb0", "tactic_state": "No Goals!"}]}
{"declaration": "lemma restrict_id_hom (f : X.PartialMap Y) :\n    (f.restrict f.domain f.dense_domain le_rfl).hom = f.hom := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/RationalMap.lean", "context": {"open": ["CategoryTheory hiding Quotient"], "variables": ["{X Y Z S : Scheme.{u}} (sX : X \u27f6 S) (sY : Y \u27f6 S)", "(S) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Scheme : ?m.1397\nX : sorry\nY : sorry\nZ : sorry\nS : sorry\nsX : sorry\nsY : sorry\nf : sorry\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "Scheme : ?m.1397\nX : sorry\nY : sorry\nZ : sorry\nS : sorry\nsX : sorry\nsY : sorry\nf : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma Opens.isDominant_homOfLE {U V : X.Opens} (hU : Dense (X := X) U) (hU' : U \u2264 V) :\n    IsDominant (X.homOfLE hU') :=\n  have : IsDominant (X.homOfLE hU' \u226b Opens.\u03b9 _) := by simpa using Opens.isDominant_\u03b9 hU\n  IsDominant.of_comp_of_isOpenImmersion (g := Opens.\u03b9 _) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/RationalMap.lean", "context": {"open": ["CategoryTheory hiding Quotient"], "variables": ["{X Y Z S : Scheme.{u}} (sX : X \u27f6 S) (sY : Y \u27f6 S)", "(S) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Scheme : ?m.1397\nX : sorry\nY : sorry\nZ : sorry\nS : sorry\nsX : sorry\nsY : sorry\nx\u271d : Sort u_1\nIsDominant : x\u271d\nU : sorry\nV : sorry\nhU : sorry\nhU' : sorry\n\u22a2 sorry"}, {"line": "simpa using Opens.isDominant_\u03b9 hU\n  IsDominant.of_comp_of_isOpenImmersion (g := Opens.\u03b9 _) _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Spec.map_eq_id {R : CommRingCat} {\u03d5 : R \u27f6 R} : Spec.map \u03d5 = \ud835\udfd9 (Spec R) \u2194 \u03d5 = \ud835\udfd9 R := by\n  simp [\u2190 map_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/GammaSpecAdjunction.lean", "context": {"open": ["PrimeSpectrum", "Opposite", "CategoryTheory", "StructureSheaf", "Spec (structureSheaf)", "TopologicalSpace", "AlgebraicGeometry.LocallyRingedSpace", "TopCat.Presheaf", "TopCat.Presheaf.SheafCondition"], "variables": ["(X : LocallyRingedSpace.{u})", "(r : \u0393.obj (op X))", "{R S : CommRingCat.{u}} {\u03c6 \u03c8 : R \u27f6 S} (f : Spec S \u27f6 Spec R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "LocallyRingedSpace : ?m.4519\nSpec : ?m.6218\nX : sorry\nr : \u2191(\u0393.obj (op sorry))\nR\u271d S : CommRingCat\n\u03c6 \u03c8 : R\u271d \u27f6 S\nf : sorry \u27f6 sorry\nR : CommRingCat\n\u03d5 : R \u27f6 R\n\u22a2 sorry = CategoryStruct.id sorry \u2194 \u03d5 = CategoryStruct.id R"}, {"line": "simp [\u2190 map_inj]", "tactic_state": "LocallyRingedSpace : ?m.4519\nSpec : ?m.6218\nX : sorry\nr : \u2191(\u0393.obj (op sorry))\nR\u271d S : CommRingCat\n\u03c6 \u03c8 : R\u271d \u27f6 S\nf : sorry \u27f6 sorry\nR : CommRingCat\n\u03d5 : R \u27f6 R\n\u22a2 sorry () = CategoryStruct.id (sorry ()) \u2194 \u03d5 = CategoryStruct.id R"}]}
{"declaration": "lemma Ideal.span_eq_top_of_span_image_evalRingHom\n    {\u03b9} {R : \u03b9 \u2192 Type*} [\u2200 i, CommRing (R i)] (s : Set (\u03a0 i, R i))\n    (hs : s.Finite) (hs' : \u2200 i, Ideal.span (Pi.evalRingHom (R \u00b7) i '' s) = \u22a4) :\n    Ideal.span s = \u22a4 := by\n  simp only [Ideal.eq_top_iff_one] at hs' \u22a2\n  simp only [\u2190 Subtype.range_val (s := s)] at hs' \u22a2\n  simp only [\u2190 Set.range_comp] at hs' \u22a2\n  simp only [Finsupp.mem_ideal_span_range_iff_exists_finsupp] at hs' \u22a2\n  choose f hf using hs'\n  have : Fintype s := hs.fintype\n  refine \u27e8Finsupp.equivFunOnFinite.symm fun i x \u21a6 f x i, ?_\u27e9\n  ext i\n  simpa [Finsupp.sum_fintype] using hf i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/PointsPi.lean", "context": {"open": ["CategoryTheory Limits PrimeSpectrum"], "variables": ["{\u03b9 : Type u} (R : \u03b9 \u2192 CommRingCat.{u})"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\nR : \u03b9 \u2192 Type u_1\ninst\u271d : (i : \u03b9) \u2192 CommRing (R i)\ns : Set ((i : \u03b9) \u2192 R i)\nhs : s.Finite\nhs' : \u2200 (i : \u03b9), span (\u21d1(Pi.evalRingHom (fun x => R x) i) '' s) = \u22a4\n\u22a2 span s = \u22a4"}, {"line": "simp only [Ideal.eq_top_iff_one] at hs' \u22a2", "tactic_state": "\u03b9 : Type u_2\nR : \u03b9 \u2192 Type u_1\ninst\u271d : (i : \u03b9) \u2192 CommRing (R i)\ns : Set ((i : \u03b9) \u2192 R i)\nhs : s.Finite\nhs' : \u2200 (i : \u03b9), 1 \u2208 span (\u21d1(Pi.evalRingHom (fun x => R x) i) '' s)\n\u22a2 1 \u2208 span s"}, {"line": "simp only [\u2190 Subtype.range_val (s := s)] at hs' \u22a2", "tactic_state": "\u03b9 : Type u_2\nR : \u03b9 \u2192 Type u_1\ninst\u271d : (i : \u03b9) \u2192 CommRing (R i)\ns : Set ((i : \u03b9) \u2192 R i)\nhs : s.Finite\nhs' : \u2200 (i : \u03b9), 1 \u2208 span (\u21d1(Pi.evalRingHom (fun x => R x) i) '' Set.range Subtype.val)\n\u22a2 1 \u2208 span (Set.range Subtype.val)"}, {"line": "simp only [\u2190 Set.range_comp] at hs' \u22a2", "tactic_state": "\u03b9 : Type u_2\nR : \u03b9 \u2192 Type u_1\ninst\u271d : (i : \u03b9) \u2192 CommRing (R i)\ns : Set ((i : \u03b9) \u2192 R i)\nhs : s.Finite\nhs' : \u2200 (i : \u03b9), 1 \u2208 span (Set.range (\u21d1(Pi.evalRingHom (fun x => R x) i) \u2218 Subtype.val))\n\u22a2 1 \u2208 span (Set.range Subtype.val)"}, {"line": "simp only [Finsupp.mem_ideal_span_range_iff_exists_finsupp] at hs' \u22a2", "tactic_state": "\u03b9 : Type u_2\nR : \u03b9 \u2192 Type u_1\ninst\u271d : (i : \u03b9) \u2192 CommRing (R i)\ns : Set ((i : \u03b9) \u2192 R i)\nhs : s.Finite\nhs' : \u2200 (i : \u03b9), \u2203 c, (c.sum fun i_1 a => a * (\u21d1(Pi.evalRingHom (fun x => R x) i) \u2218 Subtype.val) i_1) = 1\n\u22a2 \u2203 c, (c.sum fun i a => a * \u2191i) = 1"}, {"line": "choose f hf using hs'", "tactic_state": "\u03b9 : Type u_2\nR : \u03b9 \u2192 Type u_1\ninst\u271d : (i : \u03b9) \u2192 CommRing (R i)\ns : Set ((i : \u03b9) \u2192 R i)\nhs : s.Finite\nf : (i : \u03b9) \u2192 { x // x \u2208 s } \u2192\u2080 R i\nhf : \u2200 (i : \u03b9), ((f i).sum fun i_1 a => a * (\u21d1(Pi.evalRingHom (fun x => R x) i) \u2218 Subtype.val) i_1) = 1\n\u22a2 \u2203 c, (c.sum fun i a => a * \u2191i) = 1"}, {"line": "have : Fintype s := hs.fintype", "tactic_state": "\u03b9 : Type u_2\nR : \u03b9 \u2192 Type u_1\ninst\u271d : (i : \u03b9) \u2192 CommRing (R i)\ns : Set ((i : \u03b9) \u2192 R i)\nhs : s.Finite\nf : (i : \u03b9) \u2192 { x // x \u2208 s } \u2192\u2080 R i\nhf : \u2200 (i : \u03b9), ((f i).sum fun i_1 a => a * (\u21d1(Pi.evalRingHom (fun x => R x) i) \u2218 Subtype.val) i_1) = 1\nthis : Fintype \u2191s\n\u22a2 \u2203 c, (c.sum fun i a => a * \u2191i) = 1"}, {"line": "refine \u27e8Finsupp.equivFunOnFinite.symm fun i x \u21a6 f x i, ?_\u27e9", "tactic_state": "\u03b9 : Type u_2\nR : \u03b9 \u2192 Type u_1\ninst\u271d : (i : \u03b9) \u2192 CommRing (R i)\ns : Set ((i : \u03b9) \u2192 R i)\nhs : s.Finite\nf : (i : \u03b9) \u2192 { x // x \u2208 s } \u2192\u2080 R i\nhf : \u2200 (i : \u03b9), ((f i).sum fun i_1 a => a * (\u21d1(Pi.evalRingHom (fun x => R x) i) \u2218 Subtype.val) i_1) = 1\nthis : Fintype \u2191s\n\u22a2 ((Finsupp.equivFunOnFinite.symm fun i x => (f x) i).sum fun i a => a * \u2191i) = 1"}, {"line": "ext i", "tactic_state": "case h\n\u03b9 : Type u_2\nR : \u03b9 \u2192 Type u_1\ninst\u271d : (i : \u03b9) \u2192 CommRing (R i)\ns : Set ((i : \u03b9) \u2192 R i)\nhs : s.Finite\nf : (i : \u03b9) \u2192 { x // x \u2208 s } \u2192\u2080 R i\nhf : \u2200 (i : \u03b9), ((f i).sum fun i_1 a => a * (\u21d1(Pi.evalRingHom (fun x => R x) i) \u2218 Subtype.val) i_1) = 1\nthis : Fintype \u2191s\ni : \u03b9\n\u22a2 (Finsupp.equivFunOnFinite.symm fun i x => (f x) i).sum (fun i a => a * \u2191i) i = 1 i"}, {"line": "simpa [Finsupp.sum_fintype] using hf i", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gluedLiftPullbackMap_snd (i j : \ud835\udcb0.J) :\n    gluedLiftPullbackMap \ud835\udcb0 f g s i j \u226b pullback.snd _ _ = pullback.snd _ _ \u226b pullback.snd _ _ := by\n  simp [gluedLiftPullbackMap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/Pullbacks.lean", "context": {"open": ["CategoryTheory CategoryTheory.Limits AlgebraicGeometry"], "variables": ["{C : Type u} [Category.{v} C]", "{X Y Z : Scheme.{u}} (\ud835\udcb0 : OpenCover.{u} X) (f : X \u27f6 Z) (g : Y \u27f6 Z)", "[\u2200 i, HasPullback (\ud835\udcb0.map i \u226b f) g]", "(s : PullbackCone f g)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "OpenCover : ?m.3538\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y Z : Scheme\n\ud835\udcb0 : sorry\nf : X \u27f6 Z\ng : Y \u27f6 Z\ninst\u271d : \u2200 (i : ?m.5475 \ud835\udcb0 f g), HasPullback (CategoryStruct.comp sorry f) g\ns : PullbackCone f g\nx\u271d : Sort u_1\ngluedLiftPullbackMap : x\u271d\ni : sorry\nj : sorry\n\u22a2 CategoryStruct.comp sorry (pullback.snd (?m.41025 i j) (?m.41026 i j)) =\n    CategoryStruct.comp (pullback.snd (?m.41020 i j) (?m.41021 i j)) (pullback.snd (?m.41016 i j) (?m.41017 i j))"}, {"line": "simp [gluedLiftPullbackMap]", "tactic_state": "OpenCover : ?m.3538\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y Z : Scheme\n\ud835\udcb0 : sorry\nf : X \u27f6 Z\ng : Y \u27f6 Z\ninst\u271d : \u2200 (i : ?m.5475 \ud835\udcb0 f g), HasPullback (CategoryStruct.comp sorry f) g\ns : PullbackCone f g\nx\u271d : Sort u_1\ngluedLiftPullbackMap : x\u271d\ni : sorry\nj : sorry\n\u22a2 CategoryStruct.comp (sorry ()) (pullback.snd (?m.41025 i j) (?m.41026 i j)) =\n    CategoryStruct.comp (pullback.snd (?m.41020 i j) (?m.41021 i j)) (pullback.snd (?m.41016 i j) (?m.41017 i j))"}]}
{"declaration": "theorem pullbackFst\u03b9ToV_fst (i j : \ud835\udcb0.J) :\n    pullbackFst\u03b9ToV \ud835\udcb0 f g i j \u226b pullback.fst _ _ = pullback.snd _ _ := by\n  simp [pullbackFst\u03b9ToV, p1]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/Pullbacks.lean", "context": {"open": ["CategoryTheory CategoryTheory.Limits AlgebraicGeometry"], "variables": ["{C : Type u} [Category.{v} C]", "{X Y Z : Scheme.{u}} (\ud835\udcb0 : OpenCover.{u} X) (f : X \u27f6 Z) (g : Y \u27f6 Z)", "[\u2200 i, HasPullback (\ud835\udcb0.map i \u226b f) g]", "(s : PullbackCone f g)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "OpenCover : ?m.3538\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y Z : Scheme\n\ud835\udcb0 : sorry\nf : X \u27f6 Z\ng : Y \u27f6 Z\ninst\u271d : \u2200 (i : ?m.5475 \ud835\udcb0 f g), HasPullback (CategoryStruct.comp sorry f) g\ns : PullbackCone f g\nx\u271d : Sort u_1\npullbackFst\u03b9ToV : x\u271d\ni : sorry\nj : sorry\n\u22a2 CategoryStruct.comp sorry (pullback.fst (?m.27109 i j) (?m.27110 i j)) = pullback.snd (?m.27104 i j) (?m.27105 i j)"}, {"line": "simp [pullbackFst\u03b9ToV, p1]", "tactic_state": "OpenCover : ?m.3538\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y Z : Scheme\n\ud835\udcb0 : sorry\nf : X \u27f6 Z\ng : Y \u27f6 Z\ninst\u271d : \u2200 (i : ?m.5475 \ud835\udcb0 f g), HasPullback (CategoryStruct.comp sorry f) g\ns : PullbackCone f g\nx\u271d : Sort u_1\npullbackFst\u03b9ToV : x\u271d\ni : sorry\nj : sorry\n\u22a2 CategoryStruct.comp (sorry ()) (pullback.fst (?m.27109 i j) (?m.27110 i j)) =\n    pullback.snd (?m.27104 i j) (?m.27105 i j)"}]}
{"declaration": "theorem pullbackFst\u03b9ToV_snd (i j : \ud835\udcb0.J) :\n    pullbackFst\u03b9ToV \ud835\udcb0 f g i j \u226b pullback.snd _ _ = pullback.fst _ _ \u226b pullback.snd _ _ := by\n  simp [pullbackFst\u03b9ToV, p1]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/Pullbacks.lean", "context": {"open": ["CategoryTheory CategoryTheory.Limits AlgebraicGeometry"], "variables": ["{C : Type u} [Category.{v} C]", "{X Y Z : Scheme.{u}} (\ud835\udcb0 : OpenCover.{u} X) (f : X \u27f6 Z) (g : Y \u27f6 Z)", "[\u2200 i, HasPullback (\ud835\udcb0.map i \u226b f) g]", "(s : PullbackCone f g)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "OpenCover : ?m.3538\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y Z : Scheme\n\ud835\udcb0 : sorry\nf : X \u27f6 Z\ng : Y \u27f6 Z\ninst\u271d : \u2200 (i : ?m.5475 \ud835\udcb0 f g), HasPullback (CategoryStruct.comp sorry f) g\ns : PullbackCone f g\nx\u271d : Sort u_1\npullbackFst\u03b9ToV : x\u271d\ni : sorry\nj : sorry\n\u22a2 CategoryStruct.comp sorry (pullback.snd (?m.41025 i j) (?m.41026 i j)) =\n    CategoryStruct.comp (pullback.fst (?m.41020 i j) (?m.41021 i j)) (pullback.snd (?m.41015 i j) (?m.41016 i j))"}, {"line": "simp [pullbackFst\u03b9ToV, p1]", "tactic_state": "OpenCover : ?m.3538\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y Z : Scheme\n\ud835\udcb0 : sorry\nf : X \u27f6 Z\ng : Y \u27f6 Z\ninst\u271d : \u2200 (i : ?m.5475 \ud835\udcb0 f g), HasPullback (CategoryStruct.comp sorry f) g\ns : PullbackCone f g\nx\u271d : Sort u_1\npullbackFst\u03b9ToV : x\u271d\ni : sorry\nj : sorry\n\u22a2 CategoryStruct.comp (sorry ()) (pullback.snd (?m.41025 i j) (?m.41026 i j)) =\n    CategoryStruct.comp (pullback.fst (?m.41020 i j) (?m.41021 i j)) (pullback.snd (?m.41015 i j) (?m.41016 i j))"}]}
{"declaration": "lemma fromSpecResidueField_apply (x : X.carrier) (s : Spec (X.residueField x)) :\n    (X.fromSpecResidueField x).base s = x := by\n  simp [fromSpecResidueField]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/AlgebraicGeometry/ResidueField.lean", "context": {"open": ["CategoryTheory TopologicalSpace Opposite IsLocalRing"], "variables": ["(X : Scheme.{u}) {U : X.Opens}", "{X Y : Scheme.{u}} (f : X \u27f6 Y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Scheme : ?m.401\nX\u271d : sorry\nU : sorry\nX : sorry\nY : sorry\nf : sorry\nx\u271d : Sort u_1\nSpec : x\u271d\nx : sorry\ns : sorry\n\u22a2 sorry = x"}, {"line": "simp [fromSpecResidueField]", "tactic_state": "Scheme : ?m.401\nX\u271d : sorry\nU : sorry\nX : sorry\nY : sorry\nf : sorry\nx\u271d : Sort u_1\nSpec : x\u271d\nx : sorry\ns : sorry\n\u22a2 sorry () = x"}]}
