{"declaration": "example (\u03b5 : \u211d) (l : \u2115) : 0 < SzemerediRegularity.initialBound \u03b5 l := by positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Regularity/Bound.lean", "context": {"open": ["Finset Fintype Function Real", "SzemerediRegularity", "scoped SzemerediRegularity.Positivity", "Lean.Meta Qq"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] [Fintype \u03b1] {P : Finpartition (univ : Finset \u03b1)}", "(P \u03b5) (l : \u2115)", "{\u03b9 \ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] {s t : Finset \u03b9} {x : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : Fintype \u03b1\nP : Finpartition univ\n\u03b5\u271d : ?m.2796\nl\u271d : \u2115\n\u03b9 : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d\u00b2 : Field \ud835\udd5c\ninst\u271d\u00b9 : LinearOrder \ud835\udd5c\ninst\u271d : IsStrictOrderedRing \ud835\udd5c\ns t : Finset \u03b9\nx : \ud835\udd5c\n\u03b5 : \u211d\nl : \u2115\n\u22a2 0 < initialBound \u03b5 l"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "example (\u03b5 : \u211d) (l : \u2115) : 0 < SzemerediRegularity.bound \u03b5 l := by positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Regularity/Bound.lean", "context": {"open": ["Finset Fintype Function Real", "SzemerediRegularity", "scoped SzemerediRegularity.Positivity", "Lean.Meta Qq"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] [Fintype \u03b1] {P : Finpartition (univ : Finset \u03b1)}", "(P \u03b5) (l : \u2115)", "{\u03b9 \ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] {s t : Finset \u03b9} {x : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : Fintype \u03b1\nP : Finpartition univ\n\u03b5\u271d : ?m.2796\nl\u271d : \u2115\n\u03b9 : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d\u00b2 : Field \ud835\udd5c\ninst\u271d\u00b9 : LinearOrder \ud835\udd5c\ninst\u271d : IsStrictOrderedRing \ud835\udd5c\ns t : Finset \u03b9\nx : \ud835\udd5c\n\u03b5 : \u211d\nl : \u2115\n\u22a2 0 < bound \u03b5 l"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isUniformOfEmpty (hP : P.parts = \u2205) : P.IsUniform G \u03b5 := by\n  simp [IsUniform, hP, nonUniforms]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Regularity/Uniform.lean", "context": {"open": ["Finset", "scoped Classical in"], "variables": ["{\u03b1 \ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "(G : SimpleGraph \u03b1) [DecidableRel G.Adj] (\u03b5 : \ud835\udd5c) {s t : Finset \u03b1} {a b : \u03b1}", "{G \u03b5}", "(G)", "{G}", "(G)", "[DecidableEq \u03b1] {A : Finset \u03b1} (P : Finpartition A) (G : SimpleGraph \u03b1)", "{P G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nA : Finset \u03b1\nP : Finpartition A\nhP : P.parts = \u2205\n\u22a2 sorry"}, {"line": "simp [IsUniform, hP, nonUniforms]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nA : Finset \u03b1\nP : Finpartition A\nhP : P.parts = \u2205\n\u22a2 sorry ()"}]}
{"declaration": "private lemma aux {n k : \u2115} (hk : 0 < k) (hn : k \u2264 n) : n < 2 * k * (n / k) := by\n  rw [mul_assoc]\n  rw [two_mul]\n  rw [\u2190 add_lt_add_iff_right (n % k)]\n  rw [add_right_comm]\n  rw [add_assoc]\n  rw [mod_add_div n k]\n  rw [add_comm]\n  rw [add_lt_add_iff_right]\n  apply (mod_lt n hk).trans_le\n  simpa using Nat.mul_le_mul_left k ((Nat.one_le_div_iff hk).2 hn)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Triangle/Removal.lean", "context": {"open": ["Finset Fintype Nat SzemerediRegularity"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] [Fintype \u03b1] {G : SimpleGraph \u03b1} [DecidableRel G.Adj]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\nhk : 0 < k\nhn : k \u2264 n\n\u22a2 n < 2 * k * (n / k)"}, {"line": "rw [mul_assoc]", "tactic_state": "n k : \u2115\nhk : 0 < k\nhn : k \u2264 n\n\u22a2 n < 2 * (k * (n / k))"}, {"line": "rw [two_mul]", "tactic_state": "n k : \u2115\nhk : 0 < k\nhn : k \u2264 n\n\u22a2 n < k * (n / k) + k * (n / k)"}, {"line": "rw [\u2190 add_lt_add_iff_right (n % k)]", "tactic_state": "n k : \u2115\nhk : 0 < k\nhn : k \u2264 n\n\u22a2 n + n % k < k * (n / k) + k * (n / k) + n % k"}, {"line": "rw [add_right_comm]", "tactic_state": "n k : \u2115\nhk : 0 < k\nhn : k \u2264 n\n\u22a2 n + n % k < k * (n / k) + n % k + k * (n / k)"}, {"line": "rw [add_assoc]", "tactic_state": "n k : \u2115\nhk : 0 < k\nhn : k \u2264 n\n\u22a2 n + n % k < k * (n / k) + (n % k + k * (n / k))"}, {"line": "rw [mod_add_div n k]", "tactic_state": "n k : \u2115\nhk : 0 < k\nhn : k \u2264 n\n\u22a2 n + n % k < k * (n / k) + n"}, {"line": "rw [add_comm]", "tactic_state": "n k : \u2115\nhk : 0 < k\nhn : k \u2264 n\n\u22a2 n % k + n < k * (n / k) + n"}, {"line": "rw [add_lt_add_iff_right]", "tactic_state": "n k : \u2115\nhk : 0 < k\nhn : k \u2264 n\n\u22a2 n % k < k * (n / k)"}, {"line": "apply (mod_lt n hk).trans_le", "tactic_state": "n k : \u2115\nhk : 0 < k\nhn : k \u2264 n\n\u22a2 k \u2264 k * (n / k)"}, {"line": "simpa using Nat.mul_le_mul_left k ((Nat.one_le_div_iff hk).2 hn)", "tactic_state": "No Goals!"}]}
{"declaration": "example (\u03b5 : \u211d) (h\u03b5\u2080 : 0 < \u03b5) (h\u03b5\u2081 : \u03b5 \u2264 1) : 0 < triangleRemovalBound \u03b5 := by positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/SimpleGraph/Triangle/Removal.lean", "context": {"open": ["Finset Fintype Nat SzemerediRegularity", "Lean.Meta Qq SimpleGraph"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] [Fintype \u03b1] {G : SimpleGraph \u03b1} [DecidableRel G.Adj]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 : \u211d\nh\u03b5\u2080 : 0 < \u03b5\nh\u03b5\u2081 : \u03b5 \u2264 1\n\u22a2 0 < triangleRemovalBound \u03b5"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem row_weak_of_le {\u03bc : YoungDiagram} (T : SemistandardYoungTableau \u03bc) {i j1 j2 : \u2115}\n    (hj : j1 \u2264 j2) (cell : (i, j2) \u2208 \u03bc) : T i j1 \u2264 T i j2 := by\n  rcases eq_or_lt_of_le hj with h | h\n  \u00b7 rw [h]\n  \u00b7 exact T.row_weak h cell\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Young/SemistandardTableau.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni j1 j2 : \u2115\nhj : j1 \u2264 j2\ncell : (i, j2) \u2208 \u03bc\n\u22a2 T i j1 \u2264 T i j2"}, {"line": "rcases eq_or_lt_of_le hj with h | h", "tactic_state": "case inl\n\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni j1 j2 : \u2115\nhj : j1 \u2264 j2\ncell : (i, j2) \u2208 \u03bc\nh : j1 = j2\n\u22a2 T i j1 \u2264 T i j2\n---\ncase inr\n\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni j1 j2 : \u2115\nhj : j1 \u2264 j2\ncell : (i, j2) \u2208 \u03bc\nh : j1 < j2\n\u22a2 T i j1 \u2264 T i j2"}, {"line": "\u00b7 rw [h]", "tactic_state": "case inr\n\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni j1 j2 : \u2115\nhj : j1 \u2264 j2\ncell : (i, j2) \u2208 \u03bc\nh : j1 < j2\n\u22a2 T i j1 \u2264 T i j2"}, {"line": "\u00b7 exact T.row_weak h cell", "tactic_state": "No Goals!"}]}
{"declaration": "theorem col_weak {\u03bc : YoungDiagram} (T : SemistandardYoungTableau \u03bc) {i1 i2 j : \u2115} (hi : i1 \u2264 i2)\n    (cell : (i2, j) \u2208 \u03bc) : T i1 j \u2264 T i2 j := by\n  rcases eq_or_lt_of_le hi with h | h\n  \u00b7 rw [h]\n  \u00b7 exact le_of_lt (T.col_strict h cell)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Young/SemistandardTableau.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni1 i2 j : \u2115\nhi : i1 \u2264 i2\ncell : (i2, j) \u2208 \u03bc\n\u22a2 T i1 j \u2264 T i2 j"}, {"line": "rcases eq_or_lt_of_le hi with h | h", "tactic_state": "case inl\n\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni1 i2 j : \u2115\nhi : i1 \u2264 i2\ncell : (i2, j) \u2208 \u03bc\nh : i1 = i2\n\u22a2 T i1 j \u2264 T i2 j\n---\ncase inr\n\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni1 i2 j : \u2115\nhi : i1 \u2264 i2\ncell : (i2, j) \u2208 \u03bc\nh : i1 < i2\n\u22a2 T i1 j \u2264 T i2 j"}, {"line": "\u00b7 rw [h]", "tactic_state": "case inr\n\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni1 i2 j : \u2115\nhi : i1 \u2264 i2\ncell : (i2, j) \u2208 \u03bc\nh : i1 < i2\n\u22a2 T i1 j \u2264 T i2 j"}, {"line": "\u00b7 exact le_of_lt (T.col_strict h cell)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_transpose {\u03bc : YoungDiagram} {c : \u2115 \u00d7 \u2115} : c \u2208 \u03bc.transpose \u2194 c.swap \u2208 \u03bc := by\n  simp [transpose]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Young/YoungDiagram.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03bc : YoungDiagram\nc : \u2115 \u00d7 \u2115\n\u22a2 c \u2208 \u03bc.transpose \u2194 c.swap \u2208 \u03bc"}, {"line": "simp [transpose]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transpose_transpose (\u03bc : YoungDiagram) : \u03bc.transpose.transpose = \u03bc := by\n  ext x\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Young/YoungDiagram.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03bc : YoungDiagram\n\u22a2 \u03bc.transpose.transpose = \u03bc"}, {"line": "ext x", "tactic_state": "case cells.h\n\u03bc : YoungDiagram\nx : \u2115 \u00d7 \u2115\n\u22a2 x \u2208 \u03bc.transpose.transpose.cells \u2194 x \u2208 \u03bc.cells"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transpose_eq_iff_eq_transpose {\u03bc \u03bd : YoungDiagram} : \u03bc.transpose = \u03bd \u2194 \u03bc = \u03bd.transpose := by\n  constructor <;>\n    \u00b7 rintro rfl\n      simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Young/YoungDiagram.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03bc \u03bd : YoungDiagram\n\u22a2 \u03bc.transpose = \u03bd \u2194 \u03bc = \u03bd.transpose"}, {"line": "constructor <;>\n    \u00b7 rintro rfl\n      simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem colLen_transpose (\u03bc : YoungDiagram) (j : \u2115) : \u03bc.transpose.colLen j = \u03bc.rowLen j := by\n  simp [rowLen, colLen]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Young/YoungDiagram.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03bc : YoungDiagram\nj : \u2115\n\u22a2 \u03bc.transpose.colLen j = \u03bc.rowLen j"}, {"line": "simp [rowLen, colLen]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rowLen_transpose (\u03bc : YoungDiagram) (i : \u2115) : \u03bc.transpose.rowLen i = \u03bc.colLen i := by\n  simp [rowLen, colLen]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Young/YoungDiagram.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03bc : YoungDiagram\ni : \u2115\n\u22a2 \u03bc.transpose.rowLen i = \u03bc.colLen i"}, {"line": "simp [rowLen, colLen]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem colLen_anti (\u03bc : YoungDiagram) (j1 j2 : \u2115) (hj : j1 \u2264 j2) : \u03bc.colLen j2 \u2264 \u03bc.colLen j1 := by\n  convert \u03bc.transpose.rowLen_anti j1 j2 hj using 1 <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Young/YoungDiagram.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03bc : YoungDiagram\nj1 j2 : \u2115\nhj : j1 \u2264 j2\n\u22a2 \u03bc.colLen j2 \u2264 \u03bc.colLen j1"}, {"line": "convert \u03bc.transpose.rowLen_anti j1 j2 hj using 1 <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rowLen_ofRowLens {w : List \u2115} {hw : w.Sorted (\u00b7 \u2265 \u00b7)} (i : Fin w.length) :\n    (ofRowLens w hw).rowLen i = w[i] := by\n  simp [rowLen, Nat.find_eq_iff, mem_ofRowLens]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Combinatorics/Young/YoungDiagram.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nofRowLens : x\u271d\nw : List \u2115\nhw : List.Sorted (fun x1 x2 => x1 \u2265 x2) w\ni : Fin w.length\n\u22a2 sorry = w[i]"}, {"line": "simp [rowLen, Nat.find_eq_iff, mem_ofRowLens]", "tactic_state": "x\u271d : Sort u_1\nofRowLens : x\u271d\nw : List \u2115\nhw : List.Sorted (fun x1 x2 => x1 \u2265 x2) w\ni : Fin w.length\n\u22a2 sorry () = w[\u2191i]"}]}
{"declaration": "lemma mem_language_iff (g : ContextFreeGrammar T) (w : List T) :\n    w \u2208 g.language \u2194 g.Derives [Symbol.nonterminal g.initial] (w.map Symbol.terminal) := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/ContextFreeGrammar.lean", "context": {"open": ["Function"], "variables": ["{T : Type*}", "{N : Type*} {r : ContextFreeRule T N} {u v : List (Symbol T N)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : Type u_1\ng : ContextFreeGrammar T\nw : List T\n\u22a2 w \u2208 g.language \u2194 g.Derives [Symbol.nonterminal g.initial] (List.map Symbol.terminal w)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Produces.exists_nonterminal_input_mem {u v : List (Symbol T g.NT)} (hguv : g.Produces u v) :\n    \u2203 r \u2208 g.rules, .nonterminal r.input \u2208 u := by\n  obtain \u27e8w, l, r\u27e9 := hguv\n  exact \u27e8w, l, r.nonterminal_input_mem\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/ContextFreeGrammar.lean", "context": {"open": ["Function"], "variables": ["{T : Type*}", "{N : Type*} {r : ContextFreeRule T N} {u v : List (Symbol T N)}", "{g : ContextFreeGrammar T}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : Type u_1\ng : ContextFreeGrammar T\nu v : List (Symbol T g.NT)\nhguv : g.Produces u v\n\u22a2 \u2203 r \u2208 g.rules, Symbol.nonterminal r.input \u2208 u"}, {"line": "obtain \u27e8w, l, r\u27e9 := hguv", "tactic_state": "case intro.intro\nT : Type u_1\ng : ContextFreeGrammar T\nu v : List (Symbol T g.NT)\nw : ContextFreeRule T g.NT\nl : w \u2208 g.rules\nr : w.Rewrites u v\n\u22a2 \u2203 r \u2208 g.rules, Symbol.nonterminal r.input \u2208 u"}, {"line": "exact \u27e8w, l, r.nonterminal_input_mem\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma generates_reverse : g.reverse.Generates u.reverse \u2194 g.Generates u := by simp [Generates]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/ContextFreeGrammar.lean", "context": {"open": ["Function"], "variables": ["{T : Type*}", "{N : Type*} {r : ContextFreeRule T N} {u v : List (Symbol T N)}", "{g : ContextFreeGrammar T}", "{N : Type*} {r : ContextFreeRule T N} {u v : List (Symbol T N)}", "{g : ContextFreeGrammar T} {u v : List (Symbol T g.NT)} {w : List T}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : Type u_1\ng : ContextFreeGrammar T\nu : List (Symbol T g.NT)\n\u22a2 g.reverse.Generates u.reverse \u2194 g.Generates u"}, {"line": "simp [Generates]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leftQuotient_append (x y : List \u03b1) :\n    L.leftQuotient (x ++ y) = (L.leftQuotient x).leftQuotient y := by\n  simp [leftQuotient, Language]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/MyhillNerode.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03c3 : Type v} {L : Language \u03b1}", "(L) in", "(L) in", "(L) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nL : Language \u03b1\nx y : List \u03b1\n\u22a2 L.leftQuotient (x ++ y) = (L.leftQuotient x).leftQuotient y"}, {"line": "simp [leftQuotient, Language]", "tactic_state": "\u03b1 : Type u\nL : Language \u03b1\nx y : List \u03b1\n\u22a2 L.leftQuotient (x ++ y) = (L.leftQuotient x).leftQuotient y"}]}
{"declaration": "theorem leftQuotient_accepts_apply (M : DFA \u03b1 \u03c3) (x : List \u03b1) :\n    leftQuotient M.accepts x = M.acceptsFrom (M.eval x) := by\n  ext y\n  simp [DFA.mem_accepts, DFA.mem_acceptsFrom, DFA.eval, DFA.evalFrom_of_append]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/MyhillNerode.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03c3 : Type v} {L : Language \u03b1}", "(L) in", "(L) in", "(L) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nx\u271d : Sort u_1\nleftQuotient : x\u271d\nM : DFA \u03b1 \u03c3\nx : List \u03b1\n\u22a2 sorry = M.acceptsFrom (M.eval x)"}, {"line": "ext y", "tactic_state": "case h\n\u03b1 : Type u\n\u03c3 : Type v\nx\u271d : Sort u_1\nleftQuotient : x\u271d\nM : DFA \u03b1 \u03c3\nx y : List \u03b1\n\u22a2 y \u2208 sorry \u2194 y \u2208 M.acceptsFrom (M.eval x)"}, {"line": "simp [DFA.mem_accepts, DFA.mem_acceptsFrom, DFA.eval, DFA.evalFrom_of_append]", "tactic_state": "case h\n\u03b1 : Type u\n\u03c3 : Type v\nx\u271d : Sort u_1\nleftQuotient : x\u271d\nM : DFA \u03b1 \u03c3\nx y : List \u03b1\n\u22a2 y \u2208 sorry () \u2194 M.evalFrom (M.evalFrom M.start x) y \u2208 M.accept"}]}
{"declaration": "theorem toNat_manyOneEquiv {p : Set \u03b1} : ManyOneEquiv (toNat p) p := by simp [ManyOneEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Reduce.lean", "context": {"open": ["Function", "Computable", "Nat.Primrec"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} [Primcodable \u03b1] [Primcodable \u03b2]", "{\u03b1 : Type u} [Primcodable \u03b1] [Inhabited \u03b1] {\u03b2 : Type v} [Primcodable \u03b2] [Inhabited \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : Primcodable \u03b1\ninst\u271d : Inhabited \u03b1\np : Set \u03b1\n\u22a2 ManyOneEquiv (toNat p) p"}, {"line": "simp [ManyOneEquiv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem manyOneEquiv_toNat (p : Set \u03b1) (q : Set \u03b2) :\n    ManyOneEquiv (toNat p) (toNat q) \u2194 ManyOneEquiv p q := by simp [ManyOneEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Reduce.lean", "context": {"open": ["Function", "Computable", "Nat.Primrec"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} [Primcodable \u03b1] [Primcodable \u03b2]", "{\u03b1 : Type u} [Primcodable \u03b1] [Inhabited \u03b1] {\u03b2 : Type v} [Primcodable \u03b2] [Inhabited \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b3 : Primcodable \u03b1\ninst\u271d\u00b2 : Inhabited \u03b1\n\u03b2 : Type v\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Inhabited \u03b2\np : Set \u03b1\nq : Set \u03b2\n\u22a2 ManyOneEquiv (toNat p) (toNat q) \u2194 ManyOneEquiv p q"}, {"line": "simp [ManyOneEquiv]", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem le_trans {d\u2081 d\u2082 d\u2083 : ManyOneDegree} : d\u2081 \u2264 d\u2082 \u2192 d\u2082 \u2264 d\u2083 \u2192 d\u2081 \u2264 d\u2083 := by\n  induction d\u2081 using ManyOneDegree.ind_on\n  induction d\u2082 using ManyOneDegree.ind_on\n  induction d\u2083 using ManyOneDegree.ind_on\n  apply ManyOneReducible.trans\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Reduce.lean", "context": {"open": ["Function", "Computable", "Nat.Primrec"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} [Primcodable \u03b1] [Primcodable \u03b2]", "{\u03b1 : Type u} [Primcodable \u03b1] [Inhabited \u03b1] {\u03b2 : Type v} [Primcodable \u03b2] [Inhabited \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d\u2081 d\u2082 d\u2083 : ManyOneDegree\n\u22a2 d\u2081 \u2264 d\u2082 \u2192 d\u2082 \u2264 d\u2083 \u2192 d\u2081 \u2264 d\u2083"}, {"line": "induction d\u2081 using ManyOneDegree.ind_on", "tactic_state": "case h\nd\u2082 d\u2083 : ManyOneDegree\np\u271d : Set \u2115\n\u22a2 ManyOneDegree.of p\u271d \u2264 d\u2082 \u2192 d\u2082 \u2264 d\u2083 \u2192 ManyOneDegree.of p\u271d \u2264 d\u2083"}, {"line": "induction d\u2082 using ManyOneDegree.ind_on", "tactic_state": "case h.h\nd\u2083 : ManyOneDegree\np\u271d\u00b9 p\u271d : Set \u2115\n\u22a2 ManyOneDegree.of p\u271d\u00b9 \u2264 ManyOneDegree.of p\u271d \u2192 ManyOneDegree.of p\u271d \u2264 d\u2083 \u2192 ManyOneDegree.of p\u271d\u00b9 \u2264 d\u2083"}, {"line": "induction d\u2083 using ManyOneDegree.ind_on", "tactic_state": "case h.h.h\np\u271d\u00b2 p\u271d\u00b9 p\u271d : Set \u2115\n\u22a2 ManyOneDegree.of p\u271d\u00b2 \u2264 ManyOneDegree.of p\u271d\u00b9 \u2192\n    ManyOneDegree.of p\u271d\u00b9 \u2264 ManyOneDegree.of p\u271d \u2192 ManyOneDegree.of p\u271d\u00b2 \u2264 ManyOneDegree.of p\u271d"}, {"line": "apply ManyOneReducible.trans", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ack_zero (n : \u2115) : ack 0 n = n + 1 := by rw [ack]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Ackermann.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 ack 0 n = n + 1"}, {"line": "rw [ack]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ack_succ_zero (m : \u2115) : ack (m + 1) 0 = ack m 1 := by rw [ack]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Ackermann.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\n\u22a2 ack (m + 1) 0 = ack m 1"}, {"line": "rw [ack]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ack_succ_succ (m n : \u2115) : ack (m + 1) (n + 1) = ack m (ack (m + 1) n) := by rw [ack]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Ackermann.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 ack (m + 1) (n + 1) = ack m (ack (m + 1) n)"}, {"line": "rw [ack]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ack_one (n : \u2115) : ack 1 n = n + 2 := by\n  induction' n with n IH\n  \u00b7 simp\n  \u00b7 simp [IH]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Ackermann.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 ack 1 n = n + 2"}, {"line": "induction' n with n IH", "tactic_state": "case zero\n\u22a2 ack 1 0 = 0 + 2\n---\ncase succ\nn : \u2115\nIH : ack 1 n = n + 2\n\u22a2 ack 1 (n + 1) = n + 1 + 2"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nn : \u2115\nIH : ack 1 n = n + 2\n\u22a2 ack 1 (n + 1) = n + 1 + 2"}, {"line": "\u00b7 simp [IH]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ack_two (n : \u2115) : ack 2 n = 2 * n + 3 := by\n  induction' n with n IH\n  \u00b7 simp\n  \u00b7 simpa [mul_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Ackermann.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 ack 2 n = 2 * n + 3"}, {"line": "induction' n with n IH", "tactic_state": "case zero\n\u22a2 ack 2 0 = 2 * 0 + 3\n---\ncase succ\nn : \u2115\nIH : ack 2 n = 2 * n + 3\n\u22a2 ack 2 (n + 1) = 2 * (n + 1) + 3"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nn : \u2115\nIH : ack 2 n = 2 * n + 3\n\u22a2 ack 2 (n + 1) = 2 * (n + 1) + 3"}, {"line": "\u00b7 simpa [mul_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_primrec_ack_self : \u00acPrimrec fun n => ack n n := by\n  rw [Primrec.nat_iff]\n  exact not_nat_primrec_ack_self\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Ackermann.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00acPrimrec fun n => ack n n"}, {"line": "rw [Primrec.nat_iff]", "tactic_state": "\u22a2 \u00acNat.Primrec fun n => ack n n"}, {"line": "exact not_nat_primrec_ack_self", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_acceptsFrom {s : \u03c3} {x : List \u03b1} :\n    x \u2208 M.acceptsFrom s \u2194 M.evalFrom s x \u2208 M.accept := by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/DFA.lean", "context": {"open": ["Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\ns : \u03c3\nx : List \u03b1\n\u22a2 x \u2208 M.acceptsFrom s \u2194 M.evalFrom s x \u2208 M.accept"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_accepts {x : List \u03b1} : x \u2208 M.accepts \u2194 M.eval x \u2208 M.accept := by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/DFA.lean", "context": {"open": ["Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\nx : List \u03b1\n\u22a2 x \u2208 M.accepts \u2194 M.eval x \u2208 M.accept"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_comap (f : \u03b1' \u2192 \u03b1) (x : List \u03b1') : (M.comap f).eval x = M.eval (x.map f) := by\n  simp [eval]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/DFA.lean", "context": {"open": ["Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3)", "{\u03b1' \u03c3' : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\n\u03b1' : Type u_1\nf : \u03b1' \u2192 \u03b1\nx : List \u03b1'\n\u22a2 (DFA.comap f M).eval x = M.eval (List.map f x)"}, {"line": "simp [eval]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_reindex (g : \u03c3 \u2243 \u03c3') (x : List \u03b1) : (reindex g M).eval x = g (M.eval x) := by\n  simp [eval]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/DFA.lean", "context": {"open": ["Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3)", "{\u03b1' \u03c3' : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\n\u03c3' : Type u_2\nx\u271d : Sort u_3\nreindex : x\u271d\ng : \u03c3 \u2243 \u03c3'\nx : List \u03b1\n\u22a2 sorry = g (M.eval x)"}, {"line": "simp [eval]", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\n\u03c3' : Type u_2\nx\u271d : Sort u_3\nreindex : x\u271d\ng : \u03c3 \u2243 \u03c3'\nx : List \u03b1\n\u22a2 sorry () = g (M.eval x)"}]}
{"declaration": "theorem accepts_reindex (g : \u03c3 \u2243 \u03c3') : (reindex g M).accepts = M.accepts := by\n  ext x\n  simp [mem_accepts]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/DFA.lean", "context": {"open": ["Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3)", "{\u03b1' \u03c3' : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\n\u03c3' : Type u_2\nx\u271d : Sort u_3\nreindex : x\u271d\ng : \u03c3 \u2243 \u03c3'\n\u22a2 sorry = M.accepts"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\n\u03c3' : Type u_2\nx\u271d : Sort u_3\nreindex : x\u271d\ng : \u03c3 \u2243 \u03c3'\nx : List \u03b1\n\u22a2 x \u2208 sorry \u2194 x \u2208 M.accepts"}, {"line": "simp [mem_accepts]", "tactic_state": "case h\n\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\n\u03c3' : Type u_2\nx\u271d : Sort u_3\nreindex : x\u271d\ng : \u03c3 \u2243 \u03c3'\nx : List \u03b1\n\u22a2 x \u2208 sorry () \u2194 x \u2208 M.accepts"}]}
{"declaration": "theorem evalFrom_empty (x : List \u03b1) : M.evalFrom \u2205 x = \u2205 := by\n  induction' x using List.reverseRecOn with x a ih\n  \u00b7 rw [evalFrom_nil, \u03b5Closure_empty]\n  \u00b7 rw [evalFrom_append_singleton, ih, stepSet_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/EpsilonNFA.lean", "context": {"open": ["Set", "Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 : Type v} (M : \u03b5NFA \u03b1 \u03c3) {S : Set \u03c3} {s t u : \u03c3} {a : \u03b1}", "{M}", "(M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : \u03b5NFA \u03b1 \u03c3\nx : List \u03b1\n\u22a2 M.evalFrom \u2205 x = \u2205"}, {"line": "induction' x using List.reverseRecOn with x a ih", "tactic_state": "case nil\n\u03b1 : Type u\n\u03c3 : Type v\nM : \u03b5NFA \u03b1 \u03c3\n\u22a2 M.evalFrom \u2205 [] = \u2205\n---\ncase append_singleton\n\u03b1 : Type u\n\u03c3 : Type v\nM : \u03b5NFA \u03b1 \u03c3\nx : List \u03b1\na : \u03b1\nih : M.evalFrom \u2205 x = \u2205\n\u22a2 M.evalFrom \u2205 (x ++ [a]) = \u2205"}, {"line": "\u00b7 rw [evalFrom_nil, \u03b5Closure_empty]", "tactic_state": "case append_singleton\n\u03b1 : Type u\n\u03c3 : Type v\nM : \u03b5NFA \u03b1 \u03c3\nx : List \u03b1\na : \u03b1\nih : M.evalFrom \u2205 x = \u2205\n\u22a2 M.evalFrom \u2205 (x ++ [a]) = \u2205"}, {"line": "\u00b7 rw [evalFrom_append_singleton, ih, stepSet_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem to\u03b5NFA_\u03b5Closure (M : NFA \u03b1 \u03c3) (S : Set \u03c3) : M.to\u03b5NFA.\u03b5Closure S = S := by\n  ext a\n  refine \u27e8?_, \u03b5NFA.\u03b5Closure.base _\u27e9\n  rintro (\u27e8_, h\u27e9 | \u27e8_, _, h, _\u27e9)\n  \u00b7 exact h\n  \u00b7 cases h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/EpsilonNFA.lean", "context": {"open": ["Set", "Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 : Type v} (M : \u03b5NFA \u03b1 \u03c3) {S : Set \u03c3} {s t u : \u03c3} {a : \u03b1}", "{M}", "(M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : NFA \u03b1 \u03c3\nS : Set \u03c3\n\u22a2 M.to\u03b5NFA.\u03b5Closure S = S"}, {"line": "ext a", "tactic_state": "case h\n\u03b1 : Type u\n\u03c3 : Type v\nM : NFA \u03b1 \u03c3\nS : Set \u03c3\na : \u03c3\n\u22a2 a \u2208 M.to\u03b5NFA.\u03b5Closure S \u2194 a \u2208 S"}, {"line": "refine \u27e8?_, \u03b5NFA.\u03b5Closure.base _\u27e9", "tactic_state": "case h\n\u03b1 : Type u\n\u03c3 : Type v\nM : NFA \u03b1 \u03c3\nS : Set \u03c3\na : \u03c3\n\u22a2 a \u2208 M.to\u03b5NFA.\u03b5Closure S \u2192 a \u2208 S"}, {"line": "rintro (\u27e8_, h\u27e9 | \u27e8_, _, h, _\u27e9)", "tactic_state": "case h.base\n\u03b1 : Type u\n\u03c3 : Type v\nM : NFA \u03b1 \u03c3\nS : Set \u03c3\na : \u03c3\nh : a \u2208 S\n\u22a2 a \u2208 S\n---\ncase h.step\n\u03b1 : Type u\n\u03c3 : Type v\nM : NFA \u03b1 \u03c3\nS : Set \u03c3\na s\u271d : \u03c3\na\u271d : M.to\u03b5NFA.\u03b5Closure S s\u271d\nh : a \u2208 M.to\u03b5NFA.step s\u271d none\n\u22a2 a \u2208 S"}, {"line": "\u00b7 exact h", "tactic_state": "case h.step\n\u03b1 : Type u\n\u03c3 : Type v\nM : NFA \u03b1 \u03c3\nS : Set \u03c3\na s\u271d : \u03c3\na\u271d : M.to\u03b5NFA.\u03b5Closure S s\u271d\nh : a \u2208 M.to\u03b5NFA.step s\u271d none\n\u22a2 a \u2208 S"}, {"line": "\u00b7 cases h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ite {f\u2081 f\u2082 : \u2115 \u2192 \u2115} (hf\u2081 : Computable f\u2081) (hf\u2082 : Computable f\u2082)\n    {c : \u2115 \u2192 Prop} [DecidablePred c] (hc : ComputablePred c) :\n    Computable fun k \u21a6 if c k then f\u2081 k else f\u2082 k := by\n  simp_rw [\u2190 Bool.cond_decide]\n  obtain \u27e8inst, hc\u27e9 := hc\n  convert hc.cond hf\u2081 hf\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Halting.lean", "context": {"open": ["List (Vector)", "Encodable Denumerable", "Computable Part", "Computable Part", "Nat.Partrec (Code)", "Nat.Partrec.Code", "Nat.Partrec (Code)", "Nat.Partrec.Code Computable"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f\u2081 f\u2082 : \u2115 \u2192 \u2115\nhf\u2081 : Computable f\u2081\nhf\u2082 : Computable f\u2082\nc : \u2115 \u2192 Prop\ninst\u271d : DecidablePred c\nhc : ComputablePred c\n\u22a2 Computable fun k => if c k then f\u2081 k else f\u2082 k"}, {"line": "simp_rw [\u2190 Bool.cond_decide]", "tactic_state": "f\u2081 f\u2082 : \u2115 \u2192 \u2115\nhf\u2081 : Computable f\u2081\nhf\u2082 : Computable f\u2082\nc : \u2115 \u2192 Prop\ninst\u271d : DecidablePred c\nhc : ComputablePred c\n\u22a2 Computable fun k => bif decide (c k) then f\u2081 k else f\u2082 k"}, {"line": "obtain \u27e8inst, hc\u27e9 := hc", "tactic_state": "case intro\nf\u2081 f\u2082 : \u2115 \u2192 \u2115\nhf\u2081 : Computable f\u2081\nhf\u2082 : Computable f\u2082\nc : \u2115 \u2192 Prop\ninst\u271d inst : DecidablePred c\nhc : Computable fun a => decide (c a)\n\u22a2 Computable fun k => bif decide (c k) then f\u2081 k else f\u2082 k"}, {"line": "convert hc.cond hf\u2081 hf\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rice\u2082 (C : Set Code) (H : \u2200 cf cg, eval cf = eval cg \u2192 (cf \u2208 C \u2194 cg \u2208 C)) :\n    (ComputablePred fun c => c \u2208 C) \u2194 C = \u2205 \u2228 C = Set.univ := by\n  classical exact\n      have hC : \u2200 f, f \u2208 C \u2194 eval f \u2208 eval '' C := fun f =>\n        \u27e8Set.mem_image_of_mem _, fun \u27e8g, hg, e\u27e9 => (H _ _ e).1 hg\u27e9\n      \u27e8fun h =>\n        or_iff_not_imp_left.2 fun C0 =>\n          Set.eq_univ_of_forall fun cg =>\n            let \u27e8cf, fC\u27e9 := Set.nonempty_iff_ne_empty.2 C0\n            (hC _).2 <|\n              rice (eval '' C) (h.of_eq hC)\n                (Partrec.nat_iff.1 <| eval_part.comp (const cf) Computable.id)\n                (Partrec.nat_iff.1 <| eval_part.comp (const cg) Computable.id) ((hC _).1 fC),\n        fun h => by {\n          obtain rfl | rfl := h <;> simpa [ComputablePred, Set.mem_empty_iff_false] using\n            Computable.const _}\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Halting.lean", "context": {"open": ["List (Vector)", "Encodable Denumerable", "Computable Part", "Computable Part", "Nat.Partrec (Code)", "Nat.Partrec.Code", "Nat.Partrec (Code)", "Nat.Partrec.Code Computable"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Set Code\nH : \u2200 (cf cg : Code), cf.eval = cg.eval \u2192 (cf \u2208 C \u2194 cg \u2208 C)\n\u22a2 (ComputablePred fun c => c \u2208 C) \u2194 C = \u2205 \u2228 C = Set.univ"}, {"line": "classical exact\n      have hC : \u2200 f, f \u2208 C \u2194 eval f \u2208 eval '' C := fun f =>\n        \u27e8Set.mem_image_of_mem _, fun \u27e8g, hg, e\u27e9 => (H _ _ e).1 hg\u27e9\n      \u27e8fun h =>\n        or_iff_not_imp_left.2 fun C0 =>\n          Set.eq_univ_of_forall fun cg =>\n            let \u27e8cf, fC\u27e9 := Set.nonempty_iff_ne_empty.2 C0\n            (hC _).2 <|\n              rice (eval '' C) (h.of_eq hC)\n                (Partrec.nat_iff.1 <| eval_part.comp (const cf) Computable.id)\n                (Partrec.nat_iff.1 <| eval_part.comp (const cg) Computable.id) ((hC _).1 fC),\n        fun h => by {\n          obtain rfl | rfl := h <;> simpa [ComputablePred, Set.mem_empty_iff_false] using\n            Computable.const _}\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem computable_iff_re_compl_re' {p : \u03b1 \u2192 Prop} :\n    ComputablePred p \u2194 REPred p \u2227 REPred fun a => \u00acp a := by\n  classical exact computable_iff_re_compl_re\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Halting.lean", "context": {"open": ["List (Vector)", "Encodable Denumerable", "Computable Part", "Computable Part", "Nat.Partrec (Code)", "Nat.Partrec.Code", "Nat.Partrec (Code)", "Nat.Partrec.Code Computable"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d : Primcodable \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 ComputablePred p \u2194 REPred p \u2227 REPred fun a => \u00acp a"}, {"line": "classical exact computable_iff_re_compl_re", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp\u2081 {n} (f : \u2115 \u2192. \u2115) {g : List.Vector \u2115 n \u2192 \u2115} (hf : @Partrec' 1 fun v => f v.head)\n    (hg : @Partrec' n g) : @Partrec' n fun v => f (g v) := by\n  simpa using hf.comp' (Partrec'.cons hg Partrec'.nil)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Halting.lean", "context": {"open": ["List (Vector)", "Encodable Denumerable", "Computable Part", "Computable Part", "Nat.Partrec (Code)", "Nat.Partrec.Code", "Nat.Partrec (Code)", "Nat.Partrec.Code Computable", "Vector Part", "List.Vector Partrec Computable", "Nat.Partrec'"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_6\nPartrec' : x\u271d\nn : \u2115\nf : \u2115 \u2192. \u2115\ng : List.Vector \u2115 n \u2192 \u2115\nhf : sorry\nhg : sorry\n\u22a2 sorry"}, {"line": "simpa using hf.comp' (Partrec'.cons hg Partrec'.nil)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_one (x : List \u03b1) : x \u2208 (1 : Language \u03b1) \u2194 x = [] := by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Language.lean", "context": {"open": ["List Set Computability"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{l m : Language \u03b1} {a b x : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : List \u03b1\n\u22a2 x \u2208 1 \u2194 x = []"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_map (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) (l : Language \u03b1) : map g (map f l) = map (g \u2218 f) l := by\n  simp [map, image_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Language.lean", "context": {"open": ["List Set Computability"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{l m : Language \u03b1} {a b x : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ng : \u03b2 \u2192 \u03b3\nf : \u03b1 \u2192 \u03b2\nl : Language \u03b1\n\u22a2 map g (map f sorry) = map (g \u2218 f) sorry"}, {"line": "simp [map, image_image]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma reverse_one : (1 : Language \u03b1).reverse = 1 := by\n  simp [reverse, \u2190 one_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Language.lean", "context": {"open": ["List Set Computability"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{l m : Language \u03b1} {a b x : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 Language.reverse 1 = 1"}, {"line": "simp [reverse, \u2190 one_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem stepSet_empty (a : \u03b1) : M.stepSet \u2205 a = \u2205 := by simp [stepSet]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/NFA.lean", "context": {"open": ["Set", "Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 \u03c3' : Type v} (M : NFA \u03b1 \u03c3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : NFA \u03b1 \u03c3\na : \u03b1\n\u22a2 M.stepSet \u2205 a = \u2205"}, {"line": "simp [stepSet]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_accepts {x : List \u03b1} : x \u2208 M.accepts \u2194 \u2203 S \u2208 M.accept, S \u2208 M.evalFrom M.start x := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/NFA.lean", "context": {"open": ["Set", "Computability"], "variables": ["{\u03b1 : Type u} {\u03c3 \u03c3' : Type v} (M : NFA \u03b1 \u03c3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c3 : Type v\nM : NFA \u03b1 \u03c3\nx : List \u03b1\n\u22a2 x \u2208 M.accepts \u2194 \u2203 S \u2208 M.accept, S \u2208 M.evalFrom M.start x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map {f : \u03b1 \u2192. \u03b2} {g : \u03b1 \u2192 \u03b2 \u2192 \u03c3} (hf : Partrec f) (hg : Computable\u2082 g) :\n    Partrec fun a => (f a).map (g a) := by\n  simpa [bind_some_eq_map] using Partrec.bind (g := fun a x => some (g a x)) hf hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Partrec.lean", "context": {"open": ["List (Vector)", "Encodable Denumerable Part", "Computable"], "variables": ["(p : \u2115 \u2192. Bool)", "(H : \u2203 n, true \u2208 p n \u2227 \u2200 k < n, (p k).Dom)", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\n\u03c3 : Type u_7\ninst\u271d\u00b2 : Primcodable \u03b1\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192. \u03b2\ng : \u03b1 \u2192 \u03b2 \u2192 \u03c3\nhf : Partrec f\nhg : Computable\u2082 g\n\u22a2 Partrec fun a => Part.map (g a) (f a)"}, {"line": "simpa [bind_some_eq_map] using Partrec.bind (g := fun a x => some (g a x)) hf hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nat_iff {f : \u2115 \u2192. \u2115} : Partrec f \u2194 Nat.Partrec f := by simp [Partrec, map_id']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Partrec.lean", "context": {"open": ["List (Vector)", "Encodable Denumerable Part", "Computable"], "variables": ["(p : \u2115 \u2192. Bool)", "(H : \u2203 n, true \u2208 p n \u2227 \u2200 k < n, (p k).Dom)", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192. \u2115\n\u22a2 Partrec f \u2194 Nat.Partrec f"}, {"line": "simp [Partrec, map_id']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_decode_iff {f : \u03b1 \u2192 \u03b2 \u2192 \u03c3} :\n    (Computable\u2082 fun a n => (decode (\u03b1 := \u03b2) n).map (f a)) \u2194 Computable\u2082 f := by\n  convert (bind_decode_iff (f := fun a => Option.some \u2218 f a)).trans option_some_iff\n  apply Option.map_eq_bind\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Partrec.lean", "context": {"open": ["List (Vector)", "Encodable Denumerable Part", "Computable", "Computable"], "variables": ["(p : \u2115 \u2192. Bool)", "(H : \u2203 n, true \u2208 p n \u2227 \u2200 k < n, (p k).Dom)", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03c3 : Type*} [Primcodable \u03b1] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_24\n\u03b2 : Type u_25\n\u03c3 : Type u_27\ninst\u271d\u00b2 : Primcodable \u03b1\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03c3\n\u22a2 (Computable\u2082 fun a n => Option.map (f a) (decode n)) \u2194 Computable\u2082 f"}, {"line": "convert (bind_decode_iff (f := fun a => Option.some \u2218 f a)).trans option_some_iff", "tactic_state": "case h.e'_1.h.e'_7.h.h\n\u03b1 : Type u_24\n\u03b2 : Type u_25\n\u03c3 : Type u_27\ninst\u271d\u00b2 : Primcodable \u03b1\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03c3\nx\u271d\u00b9 : \u03b1\nx\u271d : \u2115\n\u22a2 Option.map (f x\u271d\u00b9) (decode x\u271d) = (decode x\u271d).bind (Option.some \u2218 f x\u271d\u00b9)"}, {"line": "apply Option.map_eq_bind", "tactic_state": "No Goals!"}]}
{"declaration": "theorem option_map {f : \u03b1 \u2192 Option \u03b2} {g : \u03b1 \u2192 \u03b2 \u2192 \u03c3} (hf : Computable f) (hg : Computable\u2082 g) :\n    Computable fun a => (f a).map (g a) := by\n  convert option_bind hf (option_some.comp\u2082 hg)\n  apply Option.map_eq_bind\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Partrec.lean", "context": {"open": ["List (Vector)", "Encodable Denumerable Part", "Computable", "Computable"], "variables": ["(p : \u2115 \u2192. Bool)", "(H : \u2203 n, true \u2208 p n \u2227 \u2200 k < n, (p k).Dom)", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03c3 : Type*} [Primcodable \u03b1] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_24\n\u03b2 : Type u_25\n\u03c3 : Type u_27\ninst\u271d\u00b2 : Primcodable \u03b1\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192 Option \u03b2\ng : \u03b1 \u2192 \u03b2 \u2192 \u03c3\nhf : Computable f\nhg : Computable\u2082 g\n\u22a2 Computable fun a => Option.map (g a) (f a)"}, {"line": "convert option_bind hf (option_some.comp\u2082 hg)", "tactic_state": "case h.e'_5.h\n\u03b1 : Type u_24\n\u03b2 : Type u_25\n\u03c3 : Type u_27\ninst\u271d\u00b2 : Primcodable \u03b1\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192 Option \u03b2\ng : \u03b1 \u2192 \u03b2 \u2192 \u03c3\nhf : Computable f\nhg : Computable\u2082 g\nx\u271d : \u03b1\n\u22a2 Option.map (g x\u271d) (f x\u271d) = (f x\u271d).bind fun b => Option.some (g x\u271d b)"}, {"line": "apply Option.map_eq_bind", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fix {f : \u03b1 \u2192. \u03c3 \u2295 \u03b1} (hf : Partrec f) : Partrec (PFun.fix f) := by\n  let F : \u03b1 \u2192 \u2115 \u2192. \u03c3 \u2295 \u03b1 := fun a n =>\n    n.rec (some (Sum.inr a)) fun _ IH => IH.bind fun s => Sum.casesOn s (fun _ => Part.some s) f\n  have hF : Partrec\u2082 F :=\n    Partrec.nat_rec snd (sumInr.comp fst).partrec\n      (sumCasesOn_right (snd.comp snd) (snd.comp <| snd.comp fst).to\u2082 (hf.comp snd).to\u2082).to\u2082\n  let p a n := @Part.map _ Bool (fun s => Sum.casesOn s (fun _ => true) fun _ => false) (F a n)\n  have hp : Partrec\u2082 p :=\n    hF.map ((sumCasesOn Computable.id (const true).to\u2082 (const false).to\u2082).comp snd).to\u2082\n  exact ((Partrec.rfind hp).bind (hF.bind (sumCasesOn_right snd snd.to\u2082 none.to\u2082).to\u2082).to\u2082).of_eq\n    fun a => ext fun b => by simpa [p] using fix_aux f _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Partrec.lean", "context": {"open": ["List (Vector)", "Encodable Denumerable Part", "Computable", "Computable", "Computable"], "variables": ["(p : \u2115 \u2192. Bool)", "(H : \u2203 n, true \u2208 p n \u2227 \u2200 k < n, (p k).Dom)", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03c3 : Type*} [Primcodable \u03b1] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_28\n\u03c3 : Type u_31\ninst\u271d\u00b9 : Primcodable \u03b1\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192. \u03c3 \u2295 \u03b1\nhf : Partrec f\n\u22a2 Partrec f.fix"}, {"line": "let F : \u03b1 \u2192 \u2115 \u2192. \u03c3 \u2295 \u03b1 := fun a n =>\n    n.rec (some (Sum.inr a)) fun _ IH => IH.bind fun s => Sum.casesOn s (fun _ => Part.some s) f", "tactic_state": "\u03b1 : Type u_28\n\u03c3 : Type u_31\ninst\u271d\u00b9 : Primcodable \u03b1\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192. \u03c3 \u2295 \u03b1\nhf : Partrec f\nF : \u03b1 \u2192 \u2115 \u2192. \u03c3 \u2295 \u03b1 :=\n  fun a n => Nat.rec (Part.some (Sum.inr a)) (fun x IH => IH.bind fun s => Sum.casesOn s (fun x => Part.some s) f) n\n\u22a2 Partrec f.fix"}, {"line": "have hF : Partrec\u2082 F :=\n    Partrec.nat_rec snd (sumInr.comp fst).partrec\n      (sumCasesOn_right (snd.comp snd) (snd.comp <| snd.comp fst).to\u2082 (hf.comp snd).to\u2082).to\u2082", "tactic_state": "\u03b1 : Type u_28\n\u03c3 : Type u_31\ninst\u271d\u00b9 : Primcodable \u03b1\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192. \u03c3 \u2295 \u03b1\nhf : Partrec f\nF : \u03b1 \u2192 \u2115 \u2192. \u03c3 \u2295 \u03b1 :=\n  fun a n => Nat.rec (Part.some (Sum.inr a)) (fun x IH => IH.bind fun s => Sum.casesOn s (fun x => Part.some s) f) n\nhF : sorry\n\u22a2 Partrec f.fix"}, {"line": "let p a n := @Part.map _ Bool (fun s => Sum.casesOn s (fun _ => true) fun _ => false) (F a n)", "tactic_state": "\u03b1 : Type u_28\n\u03c3 : Type u_31\ninst\u271d\u00b9 : Primcodable \u03b1\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192. \u03c3 \u2295 \u03b1\nhf : Partrec f\nF : \u03b1 \u2192 \u2115 \u2192. \u03c3 \u2295 \u03b1 :=\n  fun a n => Nat.rec (Part.some (Sum.inr a)) (fun x IH => IH.bind fun s => Sum.casesOn s (fun x => Part.some s) f) n\nhF : sorry\np : \u03b1 \u2192 \u2115 \u2192 Part Bool := fun a n => map (fun s => Sum.casesOn s (fun x => true) fun x => false) (F a n)\n\u22a2 Partrec f.fix"}, {"line": "have hp : Partrec\u2082 p :=\n    hF.map ((sumCasesOn Computable.id (const true).to\u2082 (const false).to\u2082).comp snd).to\u2082", "tactic_state": "\u03b1 : Type u_28\n\u03c3 : Type u_31\ninst\u271d\u00b9 : Primcodable \u03b1\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192. \u03c3 \u2295 \u03b1\nhf : Partrec f\nF : \u03b1 \u2192 \u2115 \u2192. \u03c3 \u2295 \u03b1 :=\n  fun a n => Nat.rec (Part.some (Sum.inr a)) (fun x IH => IH.bind fun s => Sum.casesOn s (fun x => Part.some s) f) n\nhF : sorry\np : \u03b1 \u2192 \u2115 \u2192 Part Bool := fun a n => map (fun s => Sum.casesOn s (fun x => true) fun x => false) (F a n)\nhp : sorry\n\u22a2 Partrec f.fix"}, {"line": "exact ((Partrec.rfind hp).bind (hF.bind (sumCasesOn_right snd snd.to\u2082 none.to\u2082).to\u2082).to\u2082).of_eq\n    fun a => ext fun b => by simpa [p] using fix_aux f _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_id (n) : eval Code.id n = Part.some n := by simp! [Seq.seq, Code.id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/PartrecCode.lean", "context": {"open": ["Encodable Denumerable", "Primrec", "Computable"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\neval : x\u271d\nn : ?m.427\n\u22a2 sorry = Part.some n"}, {"line": "simp! [Seq.seq, Code.id]", "tactic_state": "x\u271d : Sort u_1\neval : x\u271d\nn : ?m.427\n\u22a2 sorry () = Part.some n"}]}
{"declaration": "theorem eval_curry (c n x) : eval (curry c n) x = eval c (Nat.pair n x) := by simp! [Seq.seq, curry]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/PartrecCode.lean", "context": {"open": ["Encodable Denumerable", "Primrec", "Computable"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\neval : x\u271d\nc : ?m.844\nn : ?m.845 c\nx : ?m.846 c n\n\u22a2 sorry = sorry"}, {"line": "simp! [Seq.seq, curry]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nat_iff {f : \u03b1 \u2192 \u03b2 \u2192 \u03c3} : Primrec\u2082 f \u2194 Nat.Primrec\n    (.unpaired fun m n => encode <| (@decode \u03b1 _ m).bind fun a => (@decode \u03b2 _ n).map (f a)) := by\n  have :\n    \u2200 (a : Option \u03b1) (b : Option \u03b2),\n      Option.map (fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2)\n          (Option.bind a fun a : \u03b1 => Option.map (Prod.mk a) b) =\n        Option.bind a fun a => Option.map (f a) b := fun a b => by\n          cases a <;> cases b <;> rfl\n  simp [Primrec\u2082, Primrec, this]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Primrec.lean", "context": {"open": ["List (Vector)", "Denumerable Encodable Function", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_13\n\u03b2 : Type u_14\n\u03c3 : Type u_15\ninst\u271d\u00b2 : Primcodable \u03b1\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03c3\n\u22a2 Primrec\u2082 f \u2194 Nat.Primrec (Nat.unpaired fun m n => encode ((decode m).bind fun a => Option.map (f a) (decode n)))"}, {"line": "have :\n    \u2200 (a : Option \u03b1) (b : Option \u03b2),\n      Option.map (fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2)\n          (Option.bind a fun a : \u03b1 => Option.map (Prod.mk a) b) =\n        Option.bind a fun a => Option.map (f a) b := fun a b => by\n          cases a <;> cases b <;> rfl", "tactic_state": "\u03b1 : Type u_13\n\u03b2 : Type u_14\n\u03c3 : Type u_15\ninst\u271d\u00b2 : Primcodable \u03b1\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03c3\nthis :\n  \u2200 (a : Option \u03b1) (b : Option \u03b2),\n    Option.map (fun p => f p.1 p.2) (a.bind fun a => Option.map (Prod.mk a) b) = a.bind fun a => Option.map (f a) b\n\u22a2 Primrec\u2082 f \u2194 Nat.Primrec (Nat.unpaired fun m n => encode ((decode m).bind fun a => Option.map (f a) (decode n)))"}, {"line": "simp [Primrec\u2082, Primrec, this]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_decode_iff {f : \u03b1 \u2192 \u03b2 \u2192 \u03c3} :\n    (Primrec\u2082 fun a n => (@decode \u03b2 _ n).map (f a)) \u2194 Primrec\u2082 f := by\n  simp only [Option.map_eq_bind]\n  exact bind_decode_iff.trans Primrec\u2082.option_some_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Primrec.lean", "context": {"open": ["List (Vector)", "Denumerable Encodable Function", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_16\n\u03b2 : Type u_17\n\u03c3 : Type u_18\ninst\u271d\u00b2 : Primcodable \u03b1\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03c3\n\u22a2 (Primrec\u2082 fun a n => Option.map (f a) (decode n)) \u2194 Primrec\u2082 f"}, {"line": "simp only [Option.map_eq_bind]", "tactic_state": "\u03b1 : Type u_16\n\u03b2 : Type u_17\n\u03c3 : Type u_18\ninst\u271d\u00b2 : Primcodable \u03b1\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03c3\n\u22a2 (Primrec\u2082 fun a n => (decode n).bind (some \u2218 f a)) \u2194 Primrec\u2082 f"}, {"line": "exact bind_decode_iff.trans Primrec\u2082.option_some_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem list_getD (d : \u03b1) : Primrec\u2082 fun l n => List.getD l n d := by\n  simp only [List.getD_eq_getElem?_getD]\n  exact option_getD.comp\u2082 list_getElem? (const _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Primrec.lean", "context": {"open": ["List (Vector)", "Denumerable Encodable Function", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Primrec", "Primrec"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "(H : Nat.Primrec fun n => Encodable.encode (@decode (List \u03b2) _ n))", "{\u03b1 : Type*} {\u03b2 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_24\ninst\u271d : Primcodable \u03b1\nd : \u03b1\n\u22a2 Primrec\u2082 fun l n => l.getD n d"}, {"line": "simp only [List.getD_eq_getElem?_getD]", "tactic_state": "\u03b1 : Type u_24\ninst\u271d : Primcodable \u03b1\nd : \u03b1\n\u22a2 Primrec\u2082 fun l n => l[n]?.getD d"}, {"line": "exact option_getD.comp\u2082 list_getElem? (const _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nat_omega_rec' (f : \u03b2 \u2192 \u03c3) {m : \u03b2 \u2192 \u2115} {l : \u03b2 \u2192 List \u03b2} {g : \u03b2 \u2192 List \u03c3 \u2192 Option \u03c3}\n    (hm : Primrec m) (hl : Primrec l) (hg : Primrec\u2082 g)\n    (Ord : \u2200 b, \u2200 b' \u2208 l b, m b' < m b)\n    (H : \u2200 b, g b ((l b).map f) = some (f b)) : Primrec f := by\n  haveI : DecidableEq \u03b2 := Encodable.decidableEqOfEncodable \u03b2\n  let mapGraph (M : List (\u03b2 \u00d7 \u03c3)) (bs : List \u03b2) : List \u03c3 := bs.flatMap (Option.toList <| M.lookup \u00b7)\n  let bindList (b : \u03b2) : \u2115 \u2192 List \u03b2 := fun n \u21a6 n.rec [b] fun _ bs \u21a6 bs.flatMap l\n  let graph (b : \u03b2) : \u2115 \u2192 List (\u03b2 \u00d7 \u03c3) := fun i \u21a6 i.rec [] fun i ih \u21a6\n    (bindList b (m b - i)).filterMap fun b' \u21a6 (g b' <| mapGraph ih (l b')).map (b', \u00b7)\n  have mapGraph_primrec : Primrec\u2082 mapGraph :=\n    to\u2082 <| list_flatMap snd <| optionToList.comp\u2082 <| listLookup.comp\u2082 .right (fst.comp\u2082 .left)\n  have bindList_primrec : Primrec\u2082 (bindList) :=\n    nat_rec' snd\n      (list_cons.comp fst (const []))\n      (to\u2082 <| list_flatMap (snd.comp snd) (hl.comp\u2082 .right))\n  have graph_primrec : Primrec\u2082 (graph) :=\n    to\u2082 <| nat_rec' snd (const []) <|\n      to\u2082 <| listFilterMap\n        (bindList_primrec.comp\n          (fst.comp fst)\n          (nat_sub.comp (hm.comp <| fst.comp fst) (fst.comp snd))) <|\n            to\u2082 <| option_map\n              (hg.comp snd (mapGraph_primrec.comp (snd.comp <| snd.comp fst) (hl.comp snd)))\n              (Primrec\u2082.pair.comp\u2082 (snd.comp\u2082 .left) .right)\n  have : Primrec (fun b => (graph b (m b + 1))[0]?.map Prod.snd) :=\n    option_map (list_getElem?.comp (graph_primrec.comp Primrec.id (succ.comp hm)) (const 0))\n      (snd.comp\u2082 Primrec\u2082.right)\n  exact option_some_iff.mp <| this.of_eq <| fun b \u21a6 by\n    have graph_eq_map_bindList (i : \u2115) (hi : i \u2264 m b + 1) :\n        graph b i = (bindList b (m b + 1 - i)).map fun x \u21a6 (x, f x) := by\n      have bindList_eq_nil : bindList b (m b + 1) = [] :=\n        have bindList_m_lt (k : \u2115) : \u2200 b' \u2208 bindList b k, m b' < m b + 1 - k := by\n          induction' k with k ih <;> simp [bindList]\n          intro a\u2082 a\u2081 ha\u2081 ha\u2082\n          have : k \u2264 m b :=\n            Nat.lt_succ.mp (by simpa using Nat.add_lt_of_lt_sub <| Nat.zero_lt_of_lt (ih a\u2081 ha\u2081))\n          have : m a\u2081 \u2264 m b - k :=\n            Nat.lt_succ.mp (by rw [\u2190 Nat.succ_sub this]; simpa using ih a\u2081 ha\u2081)\n          exact lt_of_lt_of_le (Ord a\u2081 a\u2082 ha\u2082) this\n        List.eq_nil_iff_forall_not_mem.mpr\n          (by intro b' ha'; by_contra; simpa using bindList_m_lt (m b + 1) b' ha')\n      have mapGraph_graph {bs bs' : List \u03b2} (has : bs' \u2286 bs) :\n          mapGraph (bs.map <| fun x => (x, f x)) bs' = bs'.map f := by\n        induction' bs' with b bs' ih <;> simp [mapGraph]\n        \u00b7 have : b \u2208 bs \u2227 bs' \u2286 bs := by simpa using has\n          rcases this with \u27e8ha, has'\u27e9\n          simpa [List.lookup_graph f ha] using ih has'\n      have graph_succ : \u2200 i, graph b (i + 1) =\n        (bindList b (m b - i)).filterMap fun b' =>\n          (g b' <| mapGraph (graph b i) (l b')).map (b', \u00b7) := fun _ => rfl\n      have bindList_succ : \u2200 i, bindList b (i + 1) = (bindList b i).flatMap l := fun _ => rfl\n      induction' i with i ih\n      \u00b7 symm; simpa [graph] using bindList_eq_nil\n      \u00b7 simp only [graph_succ, ih (Nat.le_of_lt hi), Nat.succ_sub (Nat.lt_succ.mp hi),\n          Nat.succ_eq_add_one, bindList_succ, Nat.reduceSubDiff]\n        apply List.filterMap_eq_map_iff_forall_eq_some.mpr\n        intro b' ha'; simp; rw [mapGraph_graph]\n        \u00b7 exact H b'\n        \u00b7 exact (List.infix_flatMap_of_mem ha' l).subset\n    simp [graph_eq_map_bindList (m b + 1) (Nat.le_refl _), bindList]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Primrec.lean", "context": {"open": ["List (Vector)", "Denumerable Encodable Function", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Primrec", "Primrec"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "(H : Nat.Primrec fun n => Encodable.encode (@decode (List \u03b2) _ n))", "{\u03b1 : Type*} {\u03b2 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_25\n\u03c3 : Type u_27\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b2 \u2192 \u03c3\nm : \u03b2 \u2192 \u2115\nl : \u03b2 \u2192 List \u03b2\ng : \u03b2 \u2192 List \u03c3 \u2192 Option \u03c3\nhm : Primrec m\nhl : Primrec l\nhg : Primrec\u2082 g\nOrd : \u2200 (b b' : \u03b2), b' \u2208 l b \u2192 m b' < m b\nH : \u2200 (b : \u03b2), g b (List.map f (l b)) = some (f b)\n\u22a2 Primrec f"}, {"line": "haveI : DecidableEq \u03b2 := Encodable.decidableEqOfEncodable \u03b2", "tactic_state": "\u03b2 : Type u_25\n\u03c3 : Type u_27\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b2 \u2192 \u03c3\nm : \u03b2 \u2192 \u2115\nl : \u03b2 \u2192 List \u03b2\ng : \u03b2 \u2192 List \u03c3 \u2192 Option \u03c3\nhm : Primrec m\nhl : Primrec l\nhg : Primrec\u2082 g\nOrd : \u2200 (b b' : \u03b2), b' \u2208 l b \u2192 m b' < m b\nH : \u2200 (b : \u03b2), g b (List.map f (l b)) = some (f b)\nthis : DecidableEq \u03b2\n\u22a2 Primrec f"}, {"line": "let mapGraph (M : List (\u03b2 \u00d7 \u03c3)) (bs : List \u03b2) : List \u03c3 := bs.flatMap (Option.toList <| M.lookup \u00b7)", "tactic_state": "\u03b2 : Type u_25\n\u03c3 : Type u_27\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b2 \u2192 \u03c3\nm : \u03b2 \u2192 \u2115\nl : \u03b2 \u2192 List \u03b2\ng : \u03b2 \u2192 List \u03c3 \u2192 Option \u03c3\nhm : Primrec m\nhl : Primrec l\nhg : Primrec\u2082 g\nOrd : \u2200 (b b' : \u03b2), b' \u2208 l b \u2192 m b' < m b\nH : \u2200 (b : \u03b2), g b (List.map f (l b)) = some (f b)\nthis : DecidableEq \u03b2\nmapGraph : List (\u03b2 \u00d7 \u03c3) \u2192 List \u03b2 \u2192 List \u03c3 := fun M bs => List.flatMap (fun x => (List.lookup x M).toList) bs\n\u22a2 Primrec f"}, {"line": "let bindList (b : \u03b2) : \u2115 \u2192 List \u03b2 := fun n \u21a6 n.rec [b] fun _ bs \u21a6 bs.flatMap l", "tactic_state": "\u03b2 : Type u_25\n\u03c3 : Type u_27\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b2 \u2192 \u03c3\nm : \u03b2 \u2192 \u2115\nl : \u03b2 \u2192 List \u03b2\ng : \u03b2 \u2192 List \u03c3 \u2192 Option \u03c3\nhm : Primrec m\nhl : Primrec l\nhg : Primrec\u2082 g\nOrd : \u2200 (b b' : \u03b2), b' \u2208 l b \u2192 m b' < m b\nH : \u2200 (b : \u03b2), g b (List.map f (l b)) = some (f b)\nthis : DecidableEq \u03b2\nmapGraph : List (\u03b2 \u00d7 \u03c3) \u2192 List \u03b2 \u2192 List \u03c3 := fun M bs => List.flatMap (fun x => (List.lookup x M).toList) bs\nbindList : \u03b2 \u2192 \u2115 \u2192 List \u03b2 := fun b n => Nat.rec [b] (fun x bs => List.flatMap l bs) n\n\u22a2 Primrec f"}, {"line": "let graph (b : \u03b2) : \u2115 \u2192 List (\u03b2 \u00d7 \u03c3) := fun i \u21a6 i.rec [] fun i ih \u21a6\n    (bindList b (m b - i)).filterMap fun b' \u21a6 (g b' <| mapGraph ih (l b')).map (b', \u00b7)", "tactic_state": "\u03b2 : Type u_25\n\u03c3 : Type u_27\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b2 \u2192 \u03c3\nm : \u03b2 \u2192 \u2115\nl : \u03b2 \u2192 List \u03b2\ng : \u03b2 \u2192 List \u03c3 \u2192 Option \u03c3\nhm : Primrec m\nhl : Primrec l\nhg : Primrec\u2082 g\nOrd : \u2200 (b b' : \u03b2), b' \u2208 l b \u2192 m b' < m b\nH : \u2200 (b : \u03b2), g b (List.map f (l b)) = some (f b)\nthis : DecidableEq \u03b2\nmapGraph : List (\u03b2 \u00d7 \u03c3) \u2192 List \u03b2 \u2192 List \u03c3 := fun M bs => List.flatMap (fun x => (List.lookup x M).toList) bs\nbindList : \u03b2 \u2192 \u2115 \u2192 List \u03b2 := fun b n => Nat.rec [b] (fun x bs => List.flatMap l bs) n\ngraph : \u03b2 \u2192 \u2115 \u2192 List (\u03b2 \u00d7 \u03c3) :=\n  fun b i =>\n    Nat.rec []\n      (fun i ih =>\n        List.filterMap (fun b' => Option.map (fun x => (b', x)) (g b' (mapGraph ih (l b')))) (bindList b (m b - i)))\n      i\n\u22a2 Primrec f"}, {"line": "have mapGraph_primrec : Primrec\u2082 mapGraph :=\n    to\u2082 <| list_flatMap snd <| optionToList.comp\u2082 <| listLookup.comp\u2082 .right (fst.comp\u2082 .left)", "tactic_state": "\u03b2 : Type u_25\n\u03c3 : Type u_27\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b2 \u2192 \u03c3\nm : \u03b2 \u2192 \u2115\nl : \u03b2 \u2192 List \u03b2\ng : \u03b2 \u2192 List \u03c3 \u2192 Option \u03c3\nhm : Primrec m\nhl : Primrec l\nhg : Primrec\u2082 g\nOrd : \u2200 (b b' : \u03b2), b' \u2208 l b \u2192 m b' < m b\nH : \u2200 (b : \u03b2), g b (List.map f (l b)) = some (f b)\nthis : DecidableEq \u03b2\nmapGraph : List (\u03b2 \u00d7 \u03c3) \u2192 List \u03b2 \u2192 List \u03c3 := fun M bs => List.flatMap (fun x => (List.lookup x M).toList) bs\nbindList : \u03b2 \u2192 \u2115 \u2192 List \u03b2 := fun b n => Nat.rec [b] (fun x bs => List.flatMap l bs) n\ngraph : \u03b2 \u2192 \u2115 \u2192 List (\u03b2 \u00d7 \u03c3) :=\n  fun b i =>\n    Nat.rec []\n      (fun i ih =>\n        List.filterMap (fun b' => Option.map (fun x => (b', x)) (g b' (mapGraph ih (l b')))) (bindList b (m b - i)))\n      i\nmapGraph_primrec : sorry\n\u22a2 Primrec f"}, {"line": "have bindList_primrec : Primrec\u2082 (bindList) :=\n    nat_rec' snd\n      (list_cons.comp fst (const []))\n      (to\u2082 <| list_flatMap (snd.comp snd) (hl.comp\u2082 .right))", "tactic_state": "\u03b2 : Type u_25\n\u03c3 : Type u_27\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b2 \u2192 \u03c3\nm : \u03b2 \u2192 \u2115\nl : \u03b2 \u2192 List \u03b2\ng : \u03b2 \u2192 List \u03c3 \u2192 Option \u03c3\nhm : Primrec m\nhl : Primrec l\nhg : Primrec\u2082 g\nOrd : \u2200 (b b' : \u03b2), b' \u2208 l b \u2192 m b' < m b\nH : \u2200 (b : \u03b2), g b (List.map f (l b)) = some (f b)\nthis : DecidableEq \u03b2\nmapGraph : List (\u03b2 \u00d7 \u03c3) \u2192 List \u03b2 \u2192 List \u03c3 := fun M bs => List.flatMap (fun x => (List.lookup x M).toList) bs\nbindList : \u03b2 \u2192 \u2115 \u2192 List \u03b2 := fun b n => Nat.rec [b] (fun x bs => List.flatMap l bs) n\ngraph : \u03b2 \u2192 \u2115 \u2192 List (\u03b2 \u00d7 \u03c3) :=\n  fun b i =>\n    Nat.rec []\n      (fun i ih =>\n        List.filterMap (fun b' => Option.map (fun x => (b', x)) (g b' (mapGraph ih (l b')))) (bindList b (m b - i)))\n      i\nmapGraph_primrec : sorry\nbindList_primrec : sorry\n\u22a2 Primrec f"}, {"line": "have graph_primrec : Primrec\u2082 (graph) :=\n    to\u2082 <| nat_rec' snd (const []) <|\n      to\u2082 <| listFilterMap\n        (bindList_primrec.comp\n          (fst.comp fst)\n          (nat_sub.comp (hm.comp <| fst.comp fst) (fst.comp snd))) <|\n            to\u2082 <| option_map\n              (hg.comp snd (mapGraph_primrec.comp (snd.comp <| snd.comp fst) (hl.comp snd)))\n              (Primrec\u2082.pair.comp\u2082 (snd.comp\u2082 .left) .right)", "tactic_state": "\u03b2 : Type u_25\n\u03c3 : Type u_27\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b2 \u2192 \u03c3\nm : \u03b2 \u2192 \u2115\nl : \u03b2 \u2192 List \u03b2\ng : \u03b2 \u2192 List \u03c3 \u2192 Option \u03c3\nhm : Primrec m\nhl : Primrec l\nhg : Primrec\u2082 g\nOrd : \u2200 (b b' : \u03b2), b' \u2208 l b \u2192 m b' < m b\nH : \u2200 (b : \u03b2), g b (List.map f (l b)) = some (f b)\nthis : DecidableEq \u03b2\nmapGraph : List (\u03b2 \u00d7 \u03c3) \u2192 List \u03b2 \u2192 List \u03c3 := fun M bs => List.flatMap (fun x => (List.lookup x M).toList) bs\nbindList : \u03b2 \u2192 \u2115 \u2192 List \u03b2 := fun b n => Nat.rec [b] (fun x bs => List.flatMap l bs) n\ngraph : \u03b2 \u2192 \u2115 \u2192 List (\u03b2 \u00d7 \u03c3) :=\n  fun b i =>\n    Nat.rec []\n      (fun i ih =>\n        List.filterMap (fun b' => Option.map (fun x => (b', x)) (g b' (mapGraph ih (l b')))) (bindList b (m b - i)))\n      i\nmapGraph_primrec : sorry\nbindList_primrec : sorry\ngraph_primrec : sorry\n\u22a2 Primrec f"}, {"line": "have : Primrec (fun b => (graph b (m b + 1))[0]?.map Prod.snd) :=\n    option_map (list_getElem?.comp (graph_primrec.comp Primrec.id (succ.comp hm)) (const 0))\n      (snd.comp\u2082 Primrec\u2082.right)", "tactic_state": "\u03b2 : Type u_25\n\u03c3 : Type u_27\ninst\u271d\u00b9 : Primcodable \u03b2\ninst\u271d : Primcodable \u03c3\nf : \u03b2 \u2192 \u03c3\nm : \u03b2 \u2192 \u2115\nl : \u03b2 \u2192 List \u03b2\ng : \u03b2 \u2192 List \u03c3 \u2192 Option \u03c3\nhm : Primrec m\nhl : Primrec l\nhg : Primrec\u2082 g\nOrd : \u2200 (b b' : \u03b2), b' \u2208 l b \u2192 m b' < m b\nH : \u2200 (b : \u03b2), g b (List.map f (l b)) = some (f b)\nthis\u271d : DecidableEq \u03b2\nmapGraph : List (\u03b2 \u00d7 \u03c3) \u2192 List \u03b2 \u2192 List \u03c3 := fun M bs => List.flatMap (fun x => (List.lookup x M).toList) bs\nbindList : \u03b2 \u2192 \u2115 \u2192 List \u03b2 := fun b n => Nat.rec [b] (fun x bs => List.flatMap l bs) n\ngraph : \u03b2 \u2192 \u2115 \u2192 List (\u03b2 \u00d7 \u03c3) :=\n  fun b i =>\n    Nat.rec []\n      (fun i ih =>\n        List.filterMap (fun b' => Option.map (fun x => (b', x)) (g b' (mapGraph ih (l b')))) (bindList b (m b - i)))\n      i\nmapGraph_primrec : sorry\nbindList_primrec : sorry\ngraph_primrec : sorry\nthis : sorry\n\u22a2 Primrec f"}, {"line": "exact option_some_iff.mp <| this.of_eq <| fun b \u21a6 by\n    have graph_eq_map_bindList (i : \u2115) (hi : i \u2264 m b + 1) :\n        graph b i = (bindList b (m b + 1 - i)).map fun x \u21a6 (x, f x) := by\n      have bindList_eq_nil : bindList b (m b + 1) = [] :=\n        have bindList_m_lt (k : \u2115) : \u2200 b' \u2208 bindList b k, m b' < m b + 1 - k := by\n          induction' k with k ih <;> simp [bindList]\n          intro a\u2082 a\u2081 ha\u2081 ha\u2082\n          have : k \u2264 m b :=\n            Nat.lt_succ.mp (by simpa using Nat.add_lt_of_lt_sub <| Nat.zero_lt_of_lt (ih a\u2081 ha\u2081))\n          have : m a\u2081 \u2264 m b - k :=\n            Nat.lt_succ.mp (by rw [\u2190 Nat.succ_sub this]; simpa using ih a\u2081 ha\u2081)\n          exact lt_of_lt_of_le (Ord a\u2081 a\u2082 ha\u2082) this\n        List.eq_nil_iff_forall_not_mem.mpr\n          (by intro b' ha'; by_contra; simpa using bindList_m_lt (m b + 1) b' ha')\n      have mapGraph_graph {bs bs' : List \u03b2} (has : bs' \u2286 bs) :\n          mapGraph (bs.map <| fun x => (x, f x)) bs' = bs'.map f := by\n        induction' bs' with b bs' ih <;> simp [mapGraph]\n        \u00b7 have : b \u2208 bs \u2227 bs' \u2286 bs := by simpa using has\n          rcases this with \u27e8ha, has'\u27e9\n          simpa [List.lookup_graph f ha] using ih has'\n      have graph_succ : \u2200 i, graph b (i + 1) =\n        (bindList b (m b - i)).filterMap fun b' =>\n          (g b' <| mapGraph (graph b i) (l b')).map (b', \u00b7) := fun _ => rfl\n      have bindList_succ : \u2200 i, bindList b (i + 1) = (bindList b i).flatMap l := fun _ => rfl\n      induction' i with i ih\n      \u00b7 symm; simpa [graph] using bindList_eq_nil\n      \u00b7 simp only [graph_succ, ih (Nat.le_of_lt hi), Nat.succ_sub (Nat.lt_succ.mp hi),\n          Nat.succ_eq_add_one, bindList_succ, Nat.reduceSubDiff]\n        apply List.filterMap_eq_map_iff_forall_eq_some.mpr\n        intro b' ha'; simp; rw [mapGraph_graph]\n        \u00b7 exact H b'\n        \u00b7 exact (List.infix_flatMap_of_mem ha' l).subset\n    simp [graph_eq_map_bindList (m b + 1) (Nat.le_refl _), bindList]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fin_val_iff {n} {f : \u03b1 \u2192 Fin n} : (Primrec fun a => (f a).1) \u2194 Primrec f := by\n  letI : Primcodable { a // id a < n } := Primcodable.subtype (nat_lt.comp .id (const _))\n  exact (Iff.trans (by rfl) subtype_val_iff).trans (of_equiv_iff _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Primrec.lean", "context": {"open": ["List (Vector)", "Denumerable Encodable Function", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Primrec", "Primrec", "Primrec"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "(H : Nat.Primrec fun n => Encodable.encode (@decode (List \u03b2) _ n))", "{\u03b1 : Type*} {\u03b2 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_29\ninst\u271d : Primcodable \u03b1\nn : \u2115\nf : \u03b1 \u2192 Fin n\n\u22a2 (Primrec fun a => \u2191(f a)) \u2194 Primrec f"}, {"line": "letI : Primcodable { a // id a < n } := Primcodable.subtype (nat_lt.comp .id (const _))", "tactic_state": "\u03b1 : Type u_29\ninst\u271d : Primcodable \u03b1\nn : \u2115\nf : \u03b1 \u2192 Fin n\nthis : Primcodable { a // id a < n } := Primcodable.subtype \u22ef\n\u22a2 (Primrec fun a => \u2191(f a)) \u2194 Primrec f"}, {"line": "exact (Iff.trans (by rfl) subtype_val_iff).trans (of_equiv_iff _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp\u2082 (f : \u2115 \u2192 \u2115 \u2192 \u2115) (hf : @Primrec' 2 fun v => f v.head v.tail.head) {n g h}\n    (hg : @Primrec' n g) (hh : @Primrec' n h) : Primrec' fun v => f (g v) (h v) := by\n  simpa using hf.comp' (hg.cons <| hh.cons Primrec'.nil)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Primrec.lean", "context": {"open": ["List (Vector)", "Denumerable Encodable Function", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Primrec", "Primrec", "Primrec", "List.Vector", "List.Vector Primrec"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "(H : Nat.Primrec fun n => Encodable.encode (@decode (List \u03b2) _ n))", "{\u03b1 : Type*} {\u03b2 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_32\nPrimrec' : x\u271d\nf : \u2115 \u2192 \u2115 \u2192 \u2115\nhf : sorry\nn : ?m.4819 f hf\ng : ?m.4820 f hf\nh : ?m.4821 f hf\nhg : sorry\nhh : sorry\n\u22a2 sorry"}, {"line": "simpa using hf.comp' (hg.cons <| hh.cons Primrec'.nil)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prec' {n f g h} (hf : @Primrec' n f) (hg : @Primrec' n g) (hh : @Primrec' (n + 2) h) :\n    @Primrec' n fun v => (f v).rec (g v) fun y IH : \u2115 => h (y ::\u1d65 IH ::\u1d65 v) := by\n  simpa using comp' (prec hg hh) (hf.cons idv)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Primrec.lean", "context": {"open": ["List (Vector)", "Denumerable Encodable Function", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Nat.Primrec", "Primrec", "Primrec", "Primrec", "List.Vector", "List.Vector Primrec"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03b4] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]", "(H : Nat.Primrec fun n => Encodable.encode (@decode (List \u03b2) _ n))", "{\u03b1 : Type*} {\u03b2 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] [Primcodable \u03c3]", "{\u03b1 : Type*} [Primcodable \u03b1]", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*}", "[Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_32\nPrimrec' : x\u271d\nn : ?m.4820\nf : ?m.4821\ng : ?m.4822\nh : ?m.4823\nhf : sorry\nhg : sorry\nhh : sorry\n\u22a2 sorry"}, {"line": "simpa using comp' (prec hg hh) (hf.cons idv)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_rmatch_iff (x : List \u03b1) : rmatch 1 x \u2194 x = [] := by\n  induction x <;> simp [rmatch, matchEpsilon, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/RegularExpressions.lean", "context": {"open": ["List Set", "Computability"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{a b : \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_4\nrmatch : x\u271d\nx : List \u03b1\n\u22a2 sorry \u2194 x = []"}, {"line": "induction x <;> simp [rmatch, matchEpsilon, *]", "tactic_state": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_4\nrmatch : x\u271d\n\u22a2 sorry ()\n---\ncase cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_4\nrmatch : x\u271d\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : sorry \u2194 tail\u271d = []\n\u22a2 \u00actail\u271d = []"}]}
{"declaration": "theorem zero'_eval : zero'.eval = fun v => pure (0 :: v) := by simp [eval]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = fun v => pure (0 :: v)"}, {"line": "simp [eval]", "tactic_state": "\u22a2 sorry () = fun v => pure (0 :: v)"}]}
{"declaration": "theorem succ_eval : succ.eval = fun v => pure [v.headI.succ] := by simp [eval]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = fun v => pure [?m.16]"}, {"line": "simp [eval]", "tactic_state": "\u22a2 sorry () = fun v => pure [?m.16]"}]}
{"declaration": "theorem tail_eval : tail.eval = fun v => pure v.tail := by simp [eval]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = fun v => pure ?m.14"}, {"line": "simp [eval]", "tactic_state": "\u22a2 sorry () = fun v => pure ?m.14"}]}
{"declaration": "theorem cons_eval (f fs) : (cons f fs).eval = fun v => do {\n    let n \u2190 Code.eval f v\n    let ns \u2190 Code.eval fs v\n    pure (n.headI :: ns) } := by simp [eval]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncons : x\u271d\nf : ?m.722\nfs : ?m.723 f\n\u22a2 sorry = fun v => ?m.34"}, {"line": "simp [eval]", "tactic_state": "x\u271d : Sort u_1\ncons : x\u271d\nf : ?m.722\nfs : ?m.723 f\n\u22a2 sorry () = fun v => ?m.34"}]}
{"declaration": "theorem comp_eval (f g) : (comp f g).eval = fun v => g.eval v >>= f.eval := by simp [eval]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncomp : x\u271d\nf : ?m.539\ng : ?m.540 f\n\u22a2 sorry = fun v => ?m.38 >>= ?m.39"}, {"line": "simp [eval]", "tactic_state": "x\u271d : Sort u_1\ncomp : x\u271d\nf : ?m.539\ng : ?m.540 f\n\u22a2 sorry () = fun v => ?m.38 >>= ?m.39"}]}
{"declaration": "theorem case_eval (f g) :\n    (case f g).eval = fun v => v.headI.rec (f.eval v.tail) fun y _ => g.eval (y::v.tail) := by\n  simp [eval]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncase : x\u271d\nf : ?m.466\ng : ?m.467 f\n\u22a2 sorry = fun v => ?m.34"}, {"line": "simp [eval]", "tactic_state": "x\u271d : Sort u_1\ncase : x\u271d\nf : ?m.466\ng : ?m.467 f\n\u22a2 sorry () = fun v => ?m.34"}]}
{"declaration": "theorem fix_eval (f) : (fix f).eval =\n    PFun.fix fun v => (f.eval v).map fun v =>\n      if v.headI = 0 then Sum.inl v.tail else Sum.inr v.tail := by\n  simp [eval]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfix : x\u271d\nf : ?m.470\n\u22a2 sorry = PFun.fix fun v => ?m.33"}, {"line": "simp [eval]", "tactic_state": "x\u271d : Sort u_1\nfix : x\u271d\nf : ?m.470\n\u22a2 sorry () = PFun.fix fun v => ?m.33"}]}
{"declaration": "theorem nil_eval (v) : nil.eval v = pure [] := by simp [nil]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "v : ?m.2\n\u22a2 sorry = pure []"}, {"line": "simp [nil]", "tactic_state": "v : ?m.2\n\u22a2 sorry () = pure []"}]}
{"declaration": "theorem head_eval (v) : head.eval v = pure [v.headI] := by simp [head]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "v : ?m.2\n\u22a2 sorry = pure [sorry]"}, {"line": "simp [head]", "tactic_state": "v : ?m.2\n\u22a2 sorry () = pure [sorry ()]"}]}
{"declaration": "theorem zero_eval (v) : zero.eval v = pure [0] := by simp [zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/TMConfig.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "v : ?m.2\n\u22a2 sorry = pure [0]"}, {"line": "simp [zero]", "tactic_state": "v : ?m.2\n\u22a2 sorry () = pure [0]"}]}
{"declaration": "theorem codeSupp_case (f g k) :\n    codeSupp (Code.case f g) k =\n      trStmts\u2081 (trNormal (Code.case f g) k) \u222a (codeSupp f k \u222a codeSupp g k) := by\n  simp [codeSupp, codeSupp', contSupp, Finset.union_assoc, Finset.union_left_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/TMToPartrec.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation", "ToPartrec", "K'", "TM2.Stmt"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\ncodeSupp : x\u271d\u00b9\nx\u271d : Sort u_2\ntrStmts\u2081 : x\u271d\nf : ?m.2253\ng : ?m.2254 f\nk : ?m.2255 f g\n\u22a2 sorry = sorry \u222a (sorry \u222a sorry)"}, {"line": "simp [codeSupp, codeSupp', contSupp, Finset.union_assoc, Finset.union_left_comm]", "tactic_state": "x\u271d\u00b9 : Sort u_1\ncodeSupp : x\u271d\u00b9\nx\u271d : Sort u_2\ntrStmts\u2081 : x\u271d\nf : ?m.2253\ng : ?m.2254 f\nk : ?m.2255 f g\n\u22a2 sorry () = sorry () \u222a (sorry () \u222a sorry ())"}]}
{"declaration": "theorem codeSupp_fix (f k) :\n    codeSupp (Code.fix f) k = trStmts\u2081 (trNormal (Code.fix f) k) \u222a codeSupp f (Cont'.fix f k) := by\n  simp [codeSupp, codeSupp', contSupp, Finset.union_assoc, Finset.union_left_comm,\n    Finset.union_left_idem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/TMToPartrec.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation", "ToPartrec", "K'", "TM2.Stmt"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\ncodeSupp : x\u271d\u00b9\nx\u271d : Sort u_2\ntrStmts\u2081 : x\u271d\nf : ?m.1523\nk : ?m.1524 f\n\u22a2 sorry = sorry \u222a sorry"}, {"line": "simp [codeSupp, codeSupp', contSupp, Finset.union_assoc, Finset.union_left_comm,\n    Finset.union_left_idem]", "tactic_state": "x\u271d\u00b9 : Sort u_1\ncodeSupp : x\u271d\u00b9\nx\u271d : Sort u_2\ntrStmts\u2081 : x\u271d\nf : ?m.1523\nk : ?m.1524 f\n\u22a2 sorry () = sorry () \u222a sorry ()"}]}
{"declaration": "theorem contSupp_cons\u2081 (fs k) :\n    contSupp (Cont'.cons\u2081 fs k) =\n      trStmts\u2081\n          (move\u2082 (fun _ => false) main aux <|\n            move\u2082 (fun s => s = \u0393'.cons\u2097) stack main <|\n              move\u2082 (fun _ => false) aux stack <| trNormal fs (Cont'.cons\u2082 k)) \u222a\n        codeSupp fs (Cont'.cons\u2082 k) := by\n  simp [codeSupp, codeSupp', contSupp, Finset.union_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/TMToPartrec.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation", "ToPartrec", "K'", "TM2.Stmt"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_1\ncontSupp : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\ntrStmts\u2081 : x\u271d\u00b9\nx\u271d : Sort u_3\ncodeSupp : x\u271d\nfs : ?m.1541\nk : ?m.1542 fs\n\u22a2 sorry = sorry \u222a sorry"}, {"line": "simp [codeSupp, codeSupp', contSupp, Finset.union_assoc]", "tactic_state": "x\u271d\u00b2 : Sort u_1\ncontSupp : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\ntrStmts\u2081 : x\u271d\u00b9\nx\u271d : Sort u_3\ncodeSupp : x\u271d\nfs : ?m.1541\nk : ?m.1542 fs\n\u22a2 sorry () = sorry () \u222a sorry ()"}]}
{"declaration": "theorem contSupp_fix (f k) : contSupp (Cont'.fix f k) = codeSupp f (Cont'.fix f k) := by\n  simp +contextual [codeSupp, codeSupp', contSupp, Finset.union_assoc,\n    Finset.subset_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/TMToPartrec.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation", "ToPartrec", "K'", "TM2.Stmt"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\ncontSupp : x\u271d\u00b9\nx\u271d : Sort u_2\ncodeSupp : x\u271d\nf : ?m.852\nk : ?m.853 f\n\u22a2 sorry = sorry"}, {"line": "simp +contextual [codeSupp, codeSupp', contSupp, Finset.union_assoc,\n    Finset.subset_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem supports_insert {K S q} :\n    Supports (insert q K) S \u2194 TM2.SupportsStmt S (tr q) \u2227 Supports K S := by simp [Supports]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/TMToPartrec.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation", "ToPartrec", "K'", "TM2.Stmt"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nSupports : x\u271d\nK : ?m.836\nS : ?m.837\nq : ?m.838\n\u22a2 sorry \u2194 sorry \u2227 sorry"}, {"line": "simp [Supports]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem supports_singleton {S q} : Supports {q} S \u2194 TM2.SupportsStmt S (tr q) := by simp [Supports]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/TMToPartrec.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation", "ToPartrec", "K'", "TM2.Stmt"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nSupports : x\u271d\nS : ?m.425\nq : ?m.426\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [Supports]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem supports_union {K\u2081 K\u2082 S} : Supports (K\u2081 \u222a K\u2082) S \u2194 Supports K\u2081 S \u2227 Supports K\u2082 S := by\n  simp [Supports, or_imp, forall_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/TMToPartrec.lean", "context": {"open": ["List (Vector)", "Function (update)", "Relation", "ToPartrec", "K'", "TM2.Stmt"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nSupports : x\u271d\nK\u2081 : ?m.1241\nK\u2082 : ?m.1242\nS : ?m.1243\n\u22a2 sorry \u2194 sorry \u2227 sorry"}, {"line": "simp [Supports, or_imp, forall_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Tape.right\u2080_nth {\u0393} [Inhabited \u0393] (T : Tape \u0393) (n : \u2115) : T.right\u2080.nth n = T.nth n := by\n  cases n <;> simp only [Tape.nth, Tape.right\u2080, Int.ofNat_zero, ListBlank.nth_zero,\n    ListBlank.nth_succ, ListBlank.head_cons, ListBlank.tail_cons]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Tape.lean", "context": {"open": ["Function (iterate_succ iterate_succ_apply iterate_zero_apply)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nTape : x\u271d\n\u0393 : Sort u_2\ninst\u271d : Inhabited \u0393\nT : sorry\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "cases n <;> simp only [Tape.nth, Tape.right\u2080, Int.ofNat_zero, ListBlank.nth_zero,\n    ListBlank.nth_succ, ListBlank.head_cons, ListBlank.tail_cons]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Tape.move_right_n_head {\u0393} [Inhabited \u0393] (T : Tape \u0393) (i : \u2115) :\n    ((Tape.move Dir.right)^[i] T).head = T.nth i := by\n  induction i generalizing T\n  \u00b7 rfl\n  \u00b7 simp only [*, Tape.move_right_nth, Int.natCast_succ, iterate_succ, Function.comp_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/Tape.lean", "context": {"open": ["Function (iterate_succ iterate_succ_apply iterate_zero_apply)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nTape : x\u271d\n\u0393 : Sort u_2\ninst\u271d : Inhabited \u0393\nT : sorry\ni : \u2115\n\u22a2 sorry = sorry"}, {"line": "induction i generalizing T", "tactic_state": "case zero\nx\u271d : Sort u_1\nTape : x\u271d\n\u0393 : Sort u_2\ninst\u271d : Inhabited \u0393\nT : sorry\n\u22a2 sorry = sorry\n---\ncase succ\nx\u271d : Sort u_1\nTape : x\u271d\n\u0393 : Sort u_2\ninst\u271d : Inhabited \u0393\nn\u271d : \u2115\na\u271d : \u2200 (T : sorry), sorry = sorry\nT : sorry\n\u22a2 sorry = sorry"}, {"line": "\u00b7 rfl", "tactic_state": "case succ\nx\u271d : Sort u_1\nTape : x\u271d\n\u0393 : Sort u_2\ninst\u271d : Inhabited \u0393\nn\u271d : \u2115\na\u271d : \u2200 (T : sorry), sorry = sorry\nT : sorry\n\u22a2 sorry = sorry"}, {"line": "\u00b7 simp only [*, Tape.move_right_nth, Int.natCast_succ, iterate_succ, Function.comp_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isLittleO_self_div_log_id :\n    (fun (n : \u2115) => n / log n ^ 2) =o[atTop] (fun (n : \u2115) => (n : \u211d)) := by\n  calc (fun (n : \u2115) => (n : \u211d) / log n ^ 2) = fun (n : \u2115) => (n : \u211d) * ((log n) ^ 2)\u207b\u00b9 := by\n                  simp_rw [div_eq_mul_inv]\n         _ =o[atTop] fun (n : \u2115) => (n : \u211d) * 1\u207b\u00b9 := by\n                  refine IsBigO.mul_isLittleO (isBigO_refl _ _) ?_\n                  refine IsLittleO.inv_rev ?main ?zero\n                  case zero => simp\n                  case main => calc\n                    _ = (fun (_ : \u2115) => ((1 : \u211d) ^ 2))     := by simp\n                    _ =o[atTop] (fun (n : \u2115) => (log n)^2) :=\n                          IsLittleO.pow (IsLittleO.natCast_atTop\n                            <| isLittleO_const_log_atTop) (by norm_num)\n         _ = (fun (n : \u2115) => (n : \u211d)) := by ext; simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (fun n => \u2191n / log \u2191n ^ 2) =o[atTop] fun n => \u2191n"}, {"line": "calc (fun (n : \u2115) => (n : \u211d) / log n ^ 2) = fun (n : \u2115) => (n : \u211d) * ((log n) ^ 2)\u207b\u00b9 := by\n                  simp_rw [div_eq_mul_inv]\n         _ =o[atTop] fun (n : \u2115) => (n : \u211d) * 1\u207b\u00b9 := by\n                  refine IsBigO.mul_isLittleO (isBigO_refl _ _) ?_\n                  refine IsLittleO.inv_rev ?main ?zero\n                  case zero => simp\n                  case main => calc\n                    _ = (fun (_ : \u2115) => ((1 : \u211d) ^ 2))     := by simp\n                    _ =o[atTop] (fun (n : \u2115) => (log n)^2) :=\n                          IsLittleO.pow (IsLittleO.natCast_atTop\n                            <| isLittleO_const_log_atTop) (by norm_num)\n         _ = (fun (n : \u2115) => (n : \u211d)) := by ext; simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eventually_b_le_r : \u2200\u1da0 (n : \u2115) in atTop, \u2200 i, (b i : \u211d) * n - (n / log n ^ 2) \u2264 r i n := by\n  filter_upwards [R.dist_r_b'] with n hn\n  intro i\n  have h\u2081 : 0 \u2264 b i := le_of_lt <| R.b_pos _\n  rw [sub_le_iff_le_add]\n  rw [add_comm]\n  rw [\u2190 sub_le_iff_le_add]\n  calc (b i : \u211d) * n - r i n = \u2016b i * n\u2016 - \u2016(r i n : \u211d)\u2016 := by\n                            simp only [norm_mul]\n                            simp only [RCLike.norm_natCast]\n                            simp only [sub_left_inj]\n                            simp only [Nat.cast_eq_zero]\n                            simp only [Real.norm_of_nonneg h\u2081]\n                         _ \u2264 \u2016(b i * n : \u211d) - r i n\u2016 := norm_sub_norm_le _ _\n                         _ = \u2016(r i n : \u211d) - b i * n\u2016 := norm_sub_rev _ _\n                         _ \u2264 n / log n ^ 2 := hn i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), b i * \u2191n - \u2191n / log \u2191n ^ 2 \u2264 \u2191(r i n)"}, {"line": "filter_upwards [R.dist_r_b'] with n hn", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nn : \u2115\nhn : n \u2208 ?m.2061\n\u22a2 \u2200 (i : \u03b1), b i * \u2191n - \u2191n / log \u2191n ^ 2 \u2264 \u2191(r i n)"}, {"line": "intro i", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nn : \u2115\nhn : n \u2208 ?m.2061\ni : \u03b1\n\u22a2 b i * \u2191n - \u2191n / log \u2191n ^ 2 \u2264 \u2191(r i n)"}, {"line": "have h\u2081 : 0 \u2264 b i := le_of_lt <| R.b_pos _", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nn : \u2115\nhn : n \u2208 ?m.2061\ni : \u03b1\nh\u2081 : 0 \u2264 b i\n\u22a2 b i * \u2191n - \u2191n / log \u2191n ^ 2 \u2264 \u2191(r i n)"}, {"line": "rw [sub_le_iff_le_add]", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nn : \u2115\nhn : n \u2208 ?m.2061\ni : \u03b1\nh\u2081 : 0 \u2264 b i\n\u22a2 b i * \u2191n \u2264 \u2191(r i n) + \u2191n / log \u2191n ^ 2"}, {"line": "rw [add_comm]", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nn : \u2115\nhn : n \u2208 ?m.2061\ni : \u03b1\nh\u2081 : 0 \u2264 b i\n\u22a2 b i * \u2191n \u2264 \u2191n / log \u2191n ^ 2 + \u2191(r i n)"}, {"line": "rw [\u2190 sub_le_iff_le_add]", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nn : \u2115\nhn : n \u2208 ?m.2061\ni : \u03b1\nh\u2081 : 0 \u2264 b i\n\u22a2 b i * \u2191n - \u2191(r i n) \u2264 \u2191n / log \u2191n ^ 2"}, {"line": "calc (b i : \u211d) * n - r i n = \u2016b i * n\u2016 - \u2016(r i n : \u211d)\u2016 := by\n                            simp only [norm_mul]\n                            simp only [RCLike.norm_natCast]\n                            simp only [sub_left_inj]\n                            simp only [Nat.cast_eq_zero]\n                            simp only [Real.norm_of_nonneg h\u2081]\n                         _ \u2264 \u2016(b i * n : \u211d) - r i n\u2016 := norm_sub_norm_le _ _\n                         _ = \u2016(r i n : \u211d) - b i * n\u2016 := norm_sub_rev _ _\n                         _ \u2264 n / log n ^ 2 := hn i", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eventually_r_le_b : \u2200\u1da0 (n : \u2115) in atTop, \u2200 i, r i n \u2264 (b i : \u211d) * n + (n / log n ^ 2) := by\n  filter_upwards [R.dist_r_b'] with n hn\n  intro i\n  calc r i n = b i * n + (r i n - b i * n) := by ring\n             _ \u2264 b i * n + \u2016r i n - b i * n\u2016 := by gcongr; exact Real.le_norm_self _\n             _ \u2264 b i * n + n / log n ^ 2 := by gcongr; exact hn i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), \u2191(r i n) \u2264 b i * \u2191n + \u2191n / log \u2191n ^ 2"}, {"line": "filter_upwards [R.dist_r_b'] with n hn", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nn : \u2115\nhn : n \u2208 ?m.3202\n\u22a2 \u2200 (i : \u03b1), \u2191(r i n) \u2264 b i * \u2191n + \u2191n / log \u2191n ^ 2"}, {"line": "intro i", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nn : \u2115\nhn : n \u2208 ?m.3202\ni : \u03b1\n\u22a2 \u2191(r i n) \u2264 b i * \u2191n + \u2191n / log \u2191n ^ 2"}, {"line": "calc r i n = b i * n + (r i n - b i * n) := by ring\n             _ \u2264 b i * n + \u2016r i n - b i * n\u2016 := by gcongr; exact Real.le_norm_self _\n             _ \u2264 b i * n + n / log n ^ 2 := by gcongr; exact hn i", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eventually_r_lt_n : \u2200\u1da0 (n : \u2115) in atTop, \u2200 i, r i n < n := by\n  filter_upwards [eventually_ge_atTop R.n\u2080] with n hn\n  exact fun i => R.r_lt_n i n hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), r i n < n"}, {"line": "filter_upwards [eventually_ge_atTop R.n\u2080] with n hn", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nn : \u2115\nhn : sorry \u2264 n\n\u22a2 \u2200 (i : \u03b1), r i n < n"}, {"line": "exact fun i => R.r_lt_n i n hn", "tactic_state": "No Goals!"}]}
{"declaration": "lemma bi_min_div_two_lt_one : b (min_bi b) / 2 < 1 := by\n  have gt_zero : 0 < b (min_bi b) := R.b_pos (min_bi b)\n  calc b (min_bi b) / 2 < b (min_bi b) := by aesop (add safe apply div_two_lt_of_pos)\n                      _ < 1 := R.b_lt_one _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\nx\u271d : Sort u_3\nmin_bi : x\u271d\n\u22a2 b sorry / 2 < 1"}, {"line": "have gt_zero : 0 < b (min_bi b) := R.b_pos (min_bi b)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\nx\u271d : Sort u_3\nmin_bi : x\u271d\ngt_zero : 0 < b sorry\n\u22a2 b sorry / 2 < 1"}, {"line": "calc b (min_bi b) / 2 < b (min_bi b) := by aesop (add safe apply div_two_lt_of_pos)\n                      _ < 1 := R.b_lt_one _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_eventually_const_mul_le_r :\n    \u2203 c \u2208 Set.Ioo (0 : \u211d) 1, \u2200\u1da0 (n : \u2115) in atTop, \u2200 i, c * n \u2264 r i n := by\n  have gt_zero : 0 < b (min_bi b) := R.b_pos (min_bi b)\n  exact \u27e8b (min_bi b) / 2, \u27e8\u27e8by positivity, R.bi_min_div_two_lt_one\u27e9, R.eventually_bi_mul_le_r\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2203 c \u2208 Set.Ioo 0 1, \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c * \u2191n \u2264 \u2191(r i n)"}, {"line": "have gt_zero : 0 < b (min_bi b) := R.b_pos (min_bi b)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\ngt_zero : 0 < sorry\n\u22a2 \u2203 c \u2208 Set.Ioo 0 1, \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c * \u2191n \u2264 \u2191(r i n)"}, {"line": "exact \u27e8b (min_bi b) / 2, \u27e8\u27e8by positivity, R.bi_min_div_two_lt_one\u27e9, R.eventually_bi_mul_le_r\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eventually_r_pos : \u2200\u1da0 (n : \u2115) in atTop, \u2200 i, 0 < r i n := by\n  rw [Filter.eventually_all]\n  exact fun i => (R.tendsto_atTop_r i).eventually_gt_atTop 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), 0 < r i n"}, {"line": "rw [Filter.eventually_all]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2200 (i : \u03b1), \u2200\u1da0 (x : \u2115) in atTop, 0 < r i x\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\n\u22a2 Finite \u03b1"}, {"line": "exact fun i => (R.tendsto_atTop_r i).eventually_gt_atTop 0", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\n\u22a2 Finite \u03b1"}]}
{"declaration": "lemma eventually_log_b_mul_pos : \u2200\u1da0 (n : \u2115) in atTop, \u2200 i, 0 < log (b i * n) := by\n  rw [Filter.eventually_all]\n  intro i\n  have h : Tendsto (fun (n : \u2115) => log (b i * n)) atTop atTop :=\n    Tendsto.comp tendsto_log_atTop\n      <| Tendsto.const_mul_atTop (b_pos R i) tendsto_natCast_atTop_atTop\n  exact h.eventually_gt_atTop 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), 0 < log (b i * \u2191n)"}, {"line": "rw [Filter.eventually_all]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2200 (i : \u03b1), \u2200\u1da0 (x : \u2115) in atTop, 0 < log (b i * \u2191x)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 Finite \u03b1"}, {"line": "intro i", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\ni : \u03b1\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, 0 < log (b i * \u2191x)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 Finite \u03b1"}, {"line": "have h : Tendsto (fun (n : \u2115) => log (b i * n)) atTop atTop :=\n    Tendsto.comp tendsto_log_atTop\n      <| Tendsto.const_mul_atTop (b_pos R i) tendsto_natCast_atTop_atTop", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\ni : \u03b1\nh : Tendsto (fun n => log (b i * \u2191n)) atTop atTop\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, 0 < log (b i * \u2191x)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 Finite \u03b1"}, {"line": "exact h.eventually_gt_atTop 0", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 Finite \u03b1"}]}
{"declaration": "lemma deriv_smoothingFn {x : \u211d} (hx : 1 < x) : deriv \u03b5 x = -x\u207b\u00b9 / (log x ^ 2) := by\n  have : log x \u2260 0 := Real.log_ne_zero_of_pos_of_ne_one (by positivity) (ne_of_gt hx)\n  show deriv (fun z => 1 / log z) x = -x\u207b\u00b9 / (log x ^ 2)\n  rw [deriv_div] <;> aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b5 : \u211d \u2192 \u211d\nx : \u211d\nhx : 1 < x\n\u22a2 deriv \u03b5 x = -x\u207b\u00b9 / log x ^ 2"}, {"line": "have : log x \u2260 0 := Real.log_ne_zero_of_pos_of_ne_one (by positivity) (ne_of_gt hx)", "tactic_state": "\u03b5 : \u211d \u2192 \u211d\nx : \u211d\nhx : 1 < x\nthis : log x \u2260 0\n\u22a2 deriv \u03b5 x = -x\u207b\u00b9 / log x ^ 2"}, {"line": "show deriv (fun z => 1 / log z) x = -x\u207b\u00b9 / (log x ^ 2)", "tactic_state": "\u03b5 : \u211d \u2192 \u211d\nx : \u211d\nhx : 1 < x\nthis : log x \u2260 0\n\u22a2 deriv (fun z => 1 / log z) x = -x\u207b\u00b9 / log x ^ 2"}, {"line": "rw [deriv_div] <;> aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictMonoOn_one_sub_smoothingFn :\n    StrictMonoOn (fun (x : \u211d) => (1 : \u211d) - \u03b5 x) (Set.Ioi 1) := by\n  simp_rw [sub_eq_add_neg]\n  exact StrictMonoOn.const_add (StrictAntiOn.neg <| strictAntiOn_smoothingFn) 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\n\u03b5 : x\u271d\n\u22a2 StrictMonoOn (fun x => 1 - sorry) (Set.Ioi 1)"}, {"line": "simp_rw [sub_eq_add_neg]", "tactic_state": "x\u271d : Sort u_3\n\u03b5 : x\u271d\n\u22a2 StrictMonoOn (fun x => 1 + -sorry) (Set.Ioi 1)"}, {"line": "exact StrictMonoOn.const_add (StrictAntiOn.neg <| strictAntiOn_smoothingFn) 1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma continuous_sumCoeffsExp : Continuous (fun (p : \u211d) => \u2211 i, a i * (b i) ^ p) := by\n  refine continuous_finset_sum Finset.univ fun i _ => Continuous.mul (by fun_prop) ?_\n  exact Continuous.rpow continuous_const continuous_id (fun x => Or.inl (ne_of_gt (R.b_pos i)))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 Continuous fun p => \u2211 i, a i * b i ^ p"}, {"line": "refine continuous_finset_sum Finset.univ fun i _ => Continuous.mul (by fun_prop) ?_", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\ni : \u03b1\nx\u271d : i \u2208 univ\n\u22a2 Continuous (HPow.hPow (b i))"}, {"line": "exact Continuous.rpow continuous_const continuous_id (fun x => Or.inl (ne_of_gt (R.b_pos i)))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictAnti_sumCoeffsExp : StrictAnti (fun (p : \u211d) => \u2211 i, a i * (b i) ^ p) := by\n  rw [\u2190 Finset.sum_fn]\n  refine Finset.sum_induction_nonempty _ _ (fun _ _ => StrictAnti.add) univ_nonempty ?terms\n  refine fun i _ => StrictAnti.const_mul ?_ (R.a_pos i)\n  exact Real.strictAnti_rpow_of_base_lt_one (R.b_pos i) (R.b_lt_one i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 StrictAnti fun p => \u2211 i, a i * b i ^ p"}, {"line": "rw [\u2190 Finset.sum_fn]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 StrictAnti (\u2211 c, fun p => a c * b c ^ p)"}, {"line": "refine Finset.sum_induction_nonempty _ _ (fun _ _ => StrictAnti.add) univ_nonempty ?terms", "tactic_state": "case terms\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2200 x \u2208 univ, StrictAnti fun p => a x * b x ^ p"}, {"line": "refine fun i _ => StrictAnti.const_mul ?_ (R.a_pos i)", "tactic_state": "case terms\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\ni : \u03b1\nx\u271d : i \u2208 univ\n\u22a2 StrictAnti (HPow.hPow (b i))"}, {"line": "exact Real.strictAnti_rpow_of_base_lt_one (R.b_pos i) (R.b_lt_one i)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tendsto_atTop_sumCoeffsExp : Tendsto (fun (p : \u211d) => \u2211 i, a i * (b i) ^ p) atBot atTop := by\n  have h\u2081 : Tendsto (fun p : \u211d => (a (max_bi b) : \u211d) * b (max_bi b) ^ p) atBot atTop :=\n    Tendsto.const_mul_atTop (R.a_pos (max_bi b)) <| tendsto_rpow_atBot_of_base_lt_one _\n      (by have := R.b_pos (max_bi b); linarith) (R.b_lt_one _)\n  refine tendsto_atTop_mono (fun p => ?_) h\u2081\n  refine Finset.single_le_sum (f := fun i => (a i : \u211d) * b i ^ p) (fun i _ => ?_) (mem_univ _)\n  have h\u2081 : 0 < a i := R.a_pos i\n  have h\u2082 : 0 < b i := R.b_pos i\n  positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 Tendsto (fun p => \u2211 i, a i * b i ^ p) atBot atTop"}, {"line": "have h\u2081 : Tendsto (fun p : \u211d => (a (max_bi b) : \u211d) * b (max_bi b) ^ p) atBot atTop :=\n    Tendsto.const_mul_atTop (R.a_pos (max_bi b)) <| tendsto_rpow_atBot_of_base_lt_one _\n      (by have := R.b_pos (max_bi b); linarith) (R.b_lt_one _)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\nh\u2081 : Tendsto (fun p => a sorry * b sorry ^ p) atBot atTop\n\u22a2 Tendsto (fun p => \u2211 i, a i * b i ^ p) atBot atTop"}, {"line": "refine tendsto_atTop_mono (fun p => ?_) h\u2081", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\nh\u2081 : Tendsto (fun p => a sorry * b sorry ^ p) atBot atTop\np : \u211d\n\u22a2 a sorry * b sorry ^ p \u2264 \u2211 i, a i * b i ^ p"}, {"line": "refine Finset.single_le_sum (f := fun i => (a i : \u211d) * b i ^ p) (fun i _ => ?_) (mem_univ _)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\nh\u2081 : Tendsto (fun p => a sorry * b sorry ^ p) atBot atTop\np : \u211d\ni : \u03b1\nx\u271d : i \u2208 univ\n\u22a2 0 \u2264 (fun i => a i * b i ^ p) i"}, {"line": "have h\u2081 : 0 < a i := R.a_pos i", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\nh\u2081\u271d : Tendsto (fun p => a sorry * b sorry ^ p) atBot atTop\np : \u211d\ni : \u03b1\nx\u271d : i \u2208 univ\nh\u2081 : 0 < a i\n\u22a2 0 \u2264 (fun i => a i * b i ^ p) i"}, {"line": "have h\u2082 : 0 < b i := R.b_pos i", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\nh\u2081\u271d : Tendsto (fun p => a sorry * b sorry ^ p) atBot atTop\np : \u211d\ni : \u03b1\nx\u271d : i \u2208 univ\nh\u2081 : 0 < a i\nh\u2082 : 0 < b i\n\u22a2 0 \u2264 (fun i => a i * b i ^ p) i"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_mem_range_sumCoeffsExp : 1 \u2208 Set.range (fun (p : \u211d) => \u2211 i, a i * (b i) ^ p) := by\n  refine mem_range_of_exists_le_of_exists_ge R.continuous_sumCoeffsExp ?le_one ?ge_one\n  case le_one =>\n    exact R.tendsto_zero_sumCoeffsExp.eventually_le_const zero_lt_one |>.exists\n  case ge_one =>\n    exact R.tendsto_atTop_sumCoeffsExp.eventually_ge_atTop _ |>.exists\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 1 \u2208 Set.range fun p => \u2211 i, a i * b i ^ p"}, {"line": "refine mem_range_of_exists_le_of_exists_ge R.continuous_sumCoeffsExp ?le_one ?ge_one", "tactic_state": "case le_one\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2203 a_1, \u2211 i, a i * b i ^ a_1 \u2264 1\n---\ncase ge_one\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2203 b_1, 1 \u2264 \u2211 i, a i * b i ^ b_1"}, {"line": "case le_one =>\n    exact R.tendsto_zero_sumCoeffsExp.eventually_le_const zero_lt_one |>.exists", "tactic_state": "case ge_one\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2203 b_1, 1 \u2264 \u2211 i, a i * b i ^ b_1"}, {"line": "case ge_one =>\n    exact R.tendsto_atTop_sumCoeffsExp.eventually_ge_atTop _ |>.exists", "tactic_state": "No Goals!"}]}
{"declaration": "lemma asympBound_def' {\u03b1} [Fintype \u03b1] (a b : \u03b1 \u2192 \u211d) {n : \u2115} :\n    asympBound g a b n = n ^ p a b * (1 + (\u2211 u \u2208 range n, g u / u ^ (p a b + 1))) := by\n  simp [asympBound_def, sumTransform, mul_add, mul_one, Finset.sum_Ico_eq_sum_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)", "(a b) in", "(g) (a) (b)", "{g} {a} {b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "g : \u211d \u2192 \u211d\nx\u271d\u00b9 : Sort u_3\nasympBound : x\u271d\u00b9\nx\u271d : Sort u_4\np : x\u271d\n\u03b1 : Type u_5\ninst\u271d : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\nn : \u2115\n\u22a2 sorry = \u2191n ^ sorry * (1 + \u2211 u \u2208 range n, g \u2191u / \u2191u ^ (sorry + 1))"}, {"line": "simp [asympBound_def, sumTransform, mul_add, mul_one, Finset.sum_Ico_eq_sum_range]", "tactic_state": "g : \u211d \u2192 \u211d\nx\u271d\u00b9 : Sort u_3\nasympBound : x\u271d\u00b9\nx\u271d : Sort u_4\np : x\u271d\n\u03b1 : Type u_5\ninst\u271d : Fintype \u03b1\na b : \u03b1 \u2192 \u211d\nn : \u2115\n\u22a2 sorry () = \u2191n ^ sorry () + \u2191n ^ sorry () * \u2211 x \u2208 range n, g \u2191x / \u2191x ^ (sorry () + 1)"}]}
{"declaration": "lemma eventually_asympBound_pos : \u2200\u1da0 (n : \u2115) in atTop, 0 < asympBound g a b n := by\n  filter_upwards [eventually_gt_atTop 0] with n hn\n  exact R.asympBound_pos n hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)", "(a b) in", "(g) (a) (b)", "{g} {a} {b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nasympBound : x\u271d\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, 0 < sorry"}, {"line": "filter_upwards [eventually_gt_atTop 0] with n hn", "tactic_state": "case h\nx\u271d : Sort u_3\nasympBound : x\u271d\nn : \u2115\nhn : 0 < n\n\u22a2 0 < sorry"}, {"line": "exact R.asympBound_pos n hn", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_p_mul_one_sub_smoothingFn_le :\n    \u2200\u1da0 (n : \u2115) in atTop, \u2200 i, (r i n) ^ (p a b) * (1 - \u03b5 (r i n))\n      \u2264 (b i) ^ (p a b) * n ^ (p a b) * (1 - \u03b5 n) := by\n  rw [Filter.eventually_all]\n  intro i\n  let q : \u211d \u2192 \u211d := fun x => x ^ (p a b) * (1 - \u03b5 x)\n  have h_diff_q : DifferentiableOn \u211d q (Set.Ioi 1) := by\n    refine DifferentiableOn.mul\n      (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)\n        differentiableOn_one_sub_smoothingFn\n    rw [Set.mem_compl_singleton_iff]\n    rw [Set.mem_Ioi] at hz\n    exact ne_of_gt <| zero_lt_one.trans hz\n  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc\n    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 - \u03b5 z) x := by rfl\n          _ =\u1da0[atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 - \u03b5 x) +\n                  x ^ (p a b) * deriv (fun z => 1 - \u03b5 z) x := by\n              filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'\n              rw [deriv_mul] <;> aesop\n          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by\n              refine IsBigO.add ?left ?right\n              case left => calc\n                (fun x => deriv (fun z => z ^ (p a b)) x * (1 - \u03b5 x))\n                    =O[atTop] fun x => x ^ ((p a b) - 1) * (1 - \u03b5 x) := by\n                      exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)\n                  _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 := by\n                      refine IsBigO.mul (isBigO_refl _ _)\n                        isEquivalent_one_sub_smoothingFn_one.isBigO\n                  _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]\n              case right => calc\n                (fun x => x ^ (p a b) * deriv (fun z => 1 - \u03b5 z) x)\n                    =O[atTop] (fun x => x ^ (p a b) * x\u207b\u00b9) := by\n                      exact IsBigO.mul (isBigO_refl _ _) isLittleO_deriv_one_sub_smoothingFn.isBigO\n                  _ =\u1da0[atTop] fun x => x ^ ((p a b) - 1) := by\n                      filter_upwards [eventually_gt_atTop 0] with x hx\n                      rw [\u2190 Real.rpow_neg_one]\n                      rw [\u2190 Real.rpow_add hx]\n                      rw [\u2190 sub_eq_add_neg]\n  have h_main_norm : (fun (n : \u2115) => \u2016q (r i n) - q (b i * n)\u2016)\n      \u2264\u1da0[atTop] fun (n : \u2115) => \u2016(b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n)\u2016 := by\n    refine IsLittleO.eventuallyLE ?_\n    calc\n      (fun (n : \u2115) => q (r i n) - q (b i * n))\n          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by\n              exact R.isBigO_apply_r_sub_b q h_diff_q\n                (growsPolynomially_deriv_rpow_p_mul_one_sub_smoothingFn (p a b)) i\n        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by\n              exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)\n        _ =O[atTop] fun n => n^((p a b) - 1) * (n / log n ^ 2) := by\n              exact IsBigO.mul (IsBigO.natCast_atTop h_deriv_q) (isBigO_refl _ _)\n        _ =\u1da0[atTop] fun n => n^(p a b) / (log n) ^ 2 := by\n              filter_upwards [eventually_ne_atTop 0] with n hn\n              have hn' : (n : \u211d) \u2260 0 := by positivity\n              simp [\u2190 mul_div_assoc, \u2190 Real.rpow_add_one hn']\n        _ = fun (n : \u2115) => (n : \u211d) ^ (p a b) * (1 / (log n)^2) := by\n              simp_rw [mul_div, mul_one]\n        _ =\u0398[atTop] fun (n : \u2115) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n)^2) := by\n              refine IsTheta.symm ?_\n              simp_rw [mul_assoc]\n              refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)\n              have := R.b_pos i; positivity\n        _ =\u0398[atTop] fun (n : \u2115) => (b i)^(p a b) * n^(p a b) * (\u03b5 (b i * n) - \u03b5 n) := by\n              exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)\n                <| R.isTheta_smoothingFn_sub_self i\n  have h_main : (fun (n : \u2115) => q (r i n) - q (b i * n))\n      \u2264\u1da0[atTop] fun (n : \u2115) => (b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n) := by\n    calc (fun (n : \u2115) => q (r i n) - q (b i * n))\n           \u2264\u1da0[atTop] fun (n : \u2115) => \u2016q (r i n) - q (b i * n)\u2016 := by\n                filter_upwards with _; exact le_norm_self _\n         _ \u2264\u1da0[atTop] fun (n : \u2115) => \u2016(b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n)\u2016 :=\n                h_main_norm\n         _ =\u1da0[atTop] fun (n : \u2115) => (b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n) := by\n                filter_upwards [eventually_gt_atTop \u2308(b i)\u207b\u00b9\u2309\u208a, eventually_gt_atTop 1] with n hn hn'\n                refine norm_of_nonneg ?_\n                have h\u2081 := R.b_pos i\n                have h\u2082 : 0 \u2264 \u03b5 (b i * n) - \u03b5 n := by\n                  refine sub_nonneg_of_le <|\n                    (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le\n                  case n_gt_one =>\n                    rwa [Set.mem_Ioi, Nat.one_lt_cast]\n                  case bn_gt_one =>\n                    calc 1 = b i * (b i)\u207b\u00b9 := by rw [mul_inv_cancel\u2080 (by positivity)]\n                        _ \u2264 b i * \u2308(b i)\u207b\u00b9\u2309\u208a := by gcongr; exact Nat.le_ceil _\n                        _ < b i * n := by gcongr\n                  case le => calc b i * n \u2264 1 * n := by have := R.b_lt_one i; gcongr\n                                          _ = n := by rw [one_mul]\n                positivity\n  filter_upwards [h_main] with n hn\n  have h\u2081 : q (b i * n) + (b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n)\n      = (b i) ^ (p a b) * n ^ (p a b) * (1 - \u03b5 n) := by\n    have := R.b_pos i\n    simp only [q]\n    simp only [mul_rpow (by positivity : (0 : \u211d) \u2264 b i) (by positivity : (0 : \u211d) \u2264 n)]\n    ring\n  show q (r i n) \u2264 (b i) ^ (p a b) * n ^ (p a b) * (1 - \u03b5 n)\n  rw [\u2190 h\u2081]\n  rw [\u2190 sub_le_iff_le_add']\n  exact hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)", "(a b) in", "(g) (a) (b)", "{g} {a} {b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), \u2191(r i n) ^ sorry * (1 - sorry) \u2264 b i ^ sorry * \u2191n ^ sorry * (1 - sorry)"}, {"line": "rw [Filter.eventually_all]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 \u2200 (i : \u03b1), \u2200\u1da0 (x : \u2115) in atTop, \u2191(r i x) ^ sorry * (1 - sorry) \u2264 b i ^ sorry * \u2191x ^ sorry * (1 - sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "intro i", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, \u2191(r i x) ^ sorry * (1 - sorry) \u2264 b i ^ sorry * \u2191x ^ sorry * (1 - sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "let q : \u211d \u2192 \u211d := fun x => x ^ (p a b) * (1 - \u03b5 x)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 - sorry)\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, \u2191(r i x) ^ sorry * (1 - sorry) \u2264 b i ^ sorry * \u2191x ^ sorry * (1 - sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "have h_diff_q : DifferentiableOn \u211d q (Set.Ioi 1) := sorry", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 - sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, \u2191(r i x) ^ sorry * (1 - sorry) \u2264 b i ^ sorry * \u2191x ^ sorry * (1 - sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc\n    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 - \u03b5 z) x := by rfl\n          _ =\u1da0[atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 - \u03b5 x) +\n                  x ^ (p a b) * deriv (fun z => 1 - \u03b5 z) x := by\n              filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'\n              rw [deriv_mul] <;> aesop\n          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by\n              refine IsBigO.add ?left ?right\n              case left => calc\n                (fun x => deriv (fun z => z ^ (p a b)) x * (1 - \u03b5 x))\n                    =O[atTop] fun x => x ^ ((p a b) - 1) * (1 - \u03b5 x) := by\n                      exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)\n                  _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 := by\n                      refine IsBigO.mul (isBigO_refl _ _)\n                        isEquivalent_one_sub_smoothingFn_one.isBigO\n                  _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]\n              case right => calc\n                (fun x => x ^ (p a b) * deriv (fun z => 1 - \u03b5 z) x)\n                    =O[atTop] (fun x => x ^ (p a b) * x\u207b\u00b9) := by\n                      exact IsBigO.mul (isBigO_refl _ _) isLittleO_deriv_one_sub_smoothingFn.isBigO\n                  _ =\u1da0[atTop] fun x => x ^ ((p a b) - 1) := by\n                      filter_upwards [eventually_gt_atTop 0] with x hx\n                      rw [\u2190 Real.rpow_neg_one]\n                      rw [\u2190 Real.rpow_add hx]\n                      rw [\u2190 sub_eq_add_neg]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 - sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x => x ^ (sorry - 1)\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, \u2191(r i x) ^ sorry * (1 - sorry) \u2264 b i ^ sorry * \u2191x ^ sorry * (1 - sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "have h_main_norm : (fun (n : \u2115) => \u2016q (r i n) - q (b i * n)\u2016)\n      \u2264\u1da0[atTop] fun (n : \u2115) => \u2016(b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n)\u2016 := by\n    refine IsLittleO.eventuallyLE ?_\n    calc\n      (fun (n : \u2115) => q (r i n) - q (b i * n))\n          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by\n              exact R.isBigO_apply_r_sub_b q h_diff_q\n                (growsPolynomially_deriv_rpow_p_mul_one_sub_smoothingFn (p a b)) i\n        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by\n              exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)\n        _ =O[atTop] fun n => n^((p a b) - 1) * (n / log n ^ 2) := by\n              exact IsBigO.mul (IsBigO.natCast_atTop h_deriv_q) (isBigO_refl _ _)\n        _ =\u1da0[atTop] fun n => n^(p a b) / (log n) ^ 2 := by\n              filter_upwards [eventually_ne_atTop 0] with n hn\n              have hn' : (n : \u211d) \u2260 0 := by positivity\n              simp [\u2190 mul_div_assoc, \u2190 Real.rpow_add_one hn']\n        _ = fun (n : \u2115) => (n : \u211d) ^ (p a b) * (1 / (log n)^2) := by\n              simp_rw [mul_div, mul_one]\n        _ =\u0398[atTop] fun (n : \u2115) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n)^2) := by\n              refine IsTheta.symm ?_\n              simp_rw [mul_assoc]\n              refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)\n              have := R.b_pos i; positivity\n        _ =\u0398[atTop] fun (n : \u2115) => (b i)^(p a b) * n^(p a b) * (\u03b5 (b i * n) - \u03b5 n) := by\n              exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)\n                <| R.isTheta_smoothingFn_sub_self i", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 - sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x => x ^ (sorry - 1)\nh_main_norm : (fun n => \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n => \u2016b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\u2016\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, \u2191(r i x) ^ sorry * (1 - sorry) \u2264 b i ^ sorry * \u2191x ^ sorry * (1 - sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "have h_main : (fun (n : \u2115) => q (r i n) - q (b i * n))\n      \u2264\u1da0[atTop] fun (n : \u2115) => (b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n) := by\n    calc (fun (n : \u2115) => q (r i n) - q (b i * n))\n           \u2264\u1da0[atTop] fun (n : \u2115) => \u2016q (r i n) - q (b i * n)\u2016 := by\n                filter_upwards with _; exact le_norm_self _\n         _ \u2264\u1da0[atTop] fun (n : \u2115) => \u2016(b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n)\u2016 :=\n                h_main_norm\n         _ =\u1da0[atTop] fun (n : \u2115) => (b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n) := by\n                filter_upwards [eventually_gt_atTop \u2308(b i)\u207b\u00b9\u2309\u208a, eventually_gt_atTop 1] with n hn hn'\n                refine norm_of_nonneg ?_\n                have h\u2081 := R.b_pos i\n                have h\u2082 : 0 \u2264 \u03b5 (b i * n) - \u03b5 n := by\n                  refine sub_nonneg_of_le <|\n                    (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le\n                  case n_gt_one =>\n                    rwa [Set.mem_Ioi, Nat.one_lt_cast]\n                  case bn_gt_one =>\n                    calc 1 = b i * (b i)\u207b\u00b9 := by rw [mul_inv_cancel\u2080 (by positivity)]\n                        _ \u2264 b i * \u2308(b i)\u207b\u00b9\u2309\u208a := by gcongr; exact Nat.le_ceil _\n                        _ < b i * n := by gcongr\n                  case le => calc b i * n \u2264 1 * n := by have := R.b_lt_one i; gcongr\n                                          _ = n := by rw [one_mul]\n                positivity", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 - sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x => x ^ (sorry - 1)\nh_main_norm : (fun n => \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n => \u2016b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\u2016\nh_main : (fun n => q \u2191(r i n) - q (b i * \u2191n)) \u2264\u1da0[atTop] fun n => b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, \u2191(r i x) ^ sorry * (1 - sorry) \u2264 b i ^ sorry * \u2191x ^ sorry * (1 - sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "filter_upwards [h_main] with n hn", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 - sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x => x ^ (sorry - 1)\nh_main_norm : (fun n => \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n => \u2016b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\u2016\nh_main : (fun n => q \u2191(r i n) - q (b i * \u2191n)) \u2264\u1da0[atTop] fun n => b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nn : \u2115\nhn : q \u2191(r i n) - q (b i * \u2191n) \u2264 b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\n\u22a2 \u2191(r i n) ^ sorry * (1 - sorry) \u2264 b i ^ sorry * \u2191n ^ sorry * (1 - sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "have h\u2081 : q (b i * n) + (b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n)\n      = (b i) ^ (p a b) * n ^ (p a b) * (1 - \u03b5 n) := by\n    have := R.b_pos i\n    simp only [q]\n    simp only [mul_rpow (by positivity : (0 : \u211d) \u2264 b i) (by positivity : (0 : \u211d) \u2264 n)]\n    ring", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 - sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x => x ^ (sorry - 1)\nh_main_norm : (fun n => \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n => \u2016b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\u2016\nh_main : (fun n => q \u2191(r i n) - q (b i * \u2191n)) \u2264\u1da0[atTop] fun n => b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nn : \u2115\nhn : q \u2191(r i n) - q (b i * \u2191n) \u2264 b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nh\u2081 : q (b i * \u2191n) + b i ^ sorry * \u2191n ^ sorry * (sorry - sorry) = b i ^ sorry * \u2191n ^ sorry * (1 - sorry)\n\u22a2 \u2191(r i n) ^ sorry * (1 - sorry) \u2264 b i ^ sorry * \u2191n ^ sorry * (1 - sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "show q (r i n) \u2264 (b i) ^ (p a b) * n ^ (p a b) * (1 - \u03b5 n)", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 - sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x => x ^ (sorry - 1)\nh_main_norm : (fun n => \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n => \u2016b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\u2016\nh_main : (fun n => q \u2191(r i n) - q (b i * \u2191n)) \u2264\u1da0[atTop] fun n => b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nn : \u2115\nhn : q \u2191(r i n) - q (b i * \u2191n) \u2264 b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nh\u2081 : q (b i * \u2191n) + b i ^ sorry * \u2191n ^ sorry * (sorry - sorry) = b i ^ sorry * \u2191n ^ sorry * (1 - sorry)\n\u22a2 q \u2191(r i n) \u2264 b i ^ sorry * \u2191n ^ sorry * (1 - sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "rw [\u2190 h\u2081]", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 - sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x => x ^ (sorry - 1)\nh_main_norm : (fun n => \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n => \u2016b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\u2016\nh_main : (fun n => q \u2191(r i n) - q (b i * \u2191n)) \u2264\u1da0[atTop] fun n => b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nn : \u2115\nhn : q \u2191(r i n) - q (b i * \u2191n) \u2264 b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nh\u2081 : q (b i * \u2191n) + b i ^ sorry * \u2191n ^ sorry * (sorry - sorry) = b i ^ sorry * \u2191n ^ sorry * (1 - sorry)\n\u22a2 q \u2191(r i n) \u2264 q (b i * \u2191n) + b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "rw [\u2190 sub_le_iff_le_add']", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 - sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x => x ^ (sorry - 1)\nh_main_norm : (fun n => \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n => \u2016b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\u2016\nh_main : (fun n => q \u2191(r i n) - q (b i * \u2191n)) \u2264\u1da0[atTop] fun n => b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nn : \u2115\nhn : q \u2191(r i n) - q (b i * \u2191n) \u2264 b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nh\u2081 : q (b i * \u2191n) + b i ^ sorry * \u2191n ^ sorry * (sorry - sorry) = b i ^ sorry * \u2191n ^ sorry * (1 - sorry)\n\u22a2 q \u2191(r i n) - q (b i * \u2191n) \u2264 b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "exact hn", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}]}
{"declaration": "lemma rpow_p_mul_one_add_smoothingFn_ge :\n    \u2200\u1da0 (n : \u2115) in atTop, \u2200 i, (b i) ^ (p a b) * n ^ (p a b) * (1 + \u03b5 n)\n      \u2264 (r i n) ^ (p a b) * (1 + \u03b5 (r i n)) := by\n  rw [Filter.eventually_all]\n  intro i\n  let q : \u211d \u2192 \u211d := fun x => x ^ (p a b) * (1 + \u03b5 x)\n  have h_diff_q : DifferentiableOn \u211d q (Set.Ioi 1) := by\n    refine DifferentiableOn.mul\n        (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)\n        differentiableOn_one_add_smoothingFn\n    rw [Set.mem_compl_singleton_iff]\n    rw [Set.mem_Ioi] at hz\n    exact ne_of_gt <| zero_lt_one.trans hz\n  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc\n    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 + \u03b5 z) x := by rfl\n          _ =\u1da0[atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 + \u03b5 x)\n              + x ^ (p a b) * deriv (fun z => 1 + \u03b5 z) x := by\n                filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'\n                rw [deriv_mul] <;> aesop\n          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by\n                refine IsBigO.add ?left ?right\n                case left => calc\n                  (fun x => deriv (fun z => z ^ (p a b)) x * (1 + \u03b5 x))\n                      =O[atTop] fun x => x ^ ((p a b) - 1) * (1 + \u03b5 x) := by\n                        exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)\n                    _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 :=\n                        IsBigO.mul (isBigO_refl _ _) isEquivalent_one_add_smoothingFn_one.isBigO\n                    _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]\n                case right => calc\n                  (fun x => x ^ (p a b) * deriv (fun z => 1 + \u03b5 z) x)\n                      =O[atTop] (fun x => x ^ (p a b) * x\u207b\u00b9) := by\n                        exact IsBigO.mul (isBigO_refl _ _)\n                          isLittleO_deriv_one_add_smoothingFn.isBigO\n                    _ =\u1da0[atTop] fun x => x ^ ((p a b) - 1) := by\n                        filter_upwards [eventually_gt_atTop 0] with x hx\n                        rw [\u2190 Real.rpow_neg_one]\n                        rw [\u2190 Real.rpow_add hx]\n                        rw [\u2190 sub_eq_add_neg]\n  have h_main_norm : (fun (n : \u2115) => \u2016q (r i n) - q (b i * n)\u2016)\n      \u2264\u1da0[atTop] fun (n : \u2115) => \u2016(b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n)\u2016 := by\n    refine IsLittleO.eventuallyLE ?_\n    calc\n      (fun (n : \u2115) => q (r i n) - q (b i * n))\n          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by\n            exact R.isBigO_apply_r_sub_b q h_diff_q\n              (growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p a b)) i\n        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by\n            exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)\n        _ =O[atTop] fun n => n ^ ((p a b) - 1) * (n / log n ^ 2) := by\n            exact IsBigO.mul (IsBigO.natCast_atTop h_deriv_q) (isBigO_refl _ _)\n        _ =\u1da0[atTop] fun n => n ^ (p a b) / (log n) ^ 2 := by\n            filter_upwards [eventually_ne_atTop 0] with n hn\n            have hn' : (n : \u211d) \u2260 0 := by positivity\n            simp [\u2190 mul_div_assoc, \u2190 Real.rpow_add_one hn']\n        _ = fun (n : \u2115) => (n : \u211d) ^ (p a b) * (1 / (log n) ^ 2) := by simp_rw [mul_div, mul_one]\n        _ =\u0398[atTop] fun (n : \u2115) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n) ^ 2) := by\n            refine IsTheta.symm ?_\n            simp_rw [mul_assoc]\n            refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)\n            have := R.b_pos i; positivity\n        _ =\u0398[atTop] fun (n : \u2115) => (b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n) := by\n            exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)\n                  <| R.isTheta_smoothingFn_sub_self i\n  have h_main : (fun (n : \u2115) => q (b i * n) - q (r i n))\n      \u2264\u1da0[atTop] fun (n : \u2115) => (b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n) := by\n    calc (fun (n : \u2115) => q (b i * n) - q (r i n))\n           \u2264\u1da0[atTop] fun (n : \u2115) => \u2016q (r i n) - q (b i * n)\u2016 := by\n              filter_upwards with _; rw [norm_sub_rev]; exact le_norm_self _\n         _ \u2264\u1da0[atTop] fun (n : \u2115) => \u2016(b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n)\u2016 :=\n              h_main_norm\n         _ =\u1da0[atTop] fun (n : \u2115) => (b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n) := by\n              filter_upwards [eventually_gt_atTop \u2308(b i)\u207b\u00b9\u2309\u208a, eventually_gt_atTop 1] with n hn hn'\n              refine norm_of_nonneg ?_\n              have h\u2081 := R.b_pos i\n              have h\u2082 : 0 \u2264 \u03b5 (b i * n) - \u03b5 n := by\n                refine sub_nonneg_of_le <|\n                  (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le\n                case n_gt_one =>\n                  show 1 < (n : \u211d)\n                  rw [Nat.one_lt_cast]\n                  exact hn'\n                case bn_gt_one =>\n                  calc 1 = b i * (b i)\u207b\u00b9 := by rw [mul_inv_cancel\u2080 (by positivity)]\n                      _ \u2264 b i * \u2308(b i)\u207b\u00b9\u2309\u208a := by gcongr; exact Nat.le_ceil _\n                      _ < b i * n := by gcongr\n                case le => calc b i * n \u2264 1 * n := by have := R.b_lt_one i; gcongr\n                                        _ = n := by rw [one_mul]\n              positivity\n  filter_upwards [h_main] with n hn\n  have h\u2081 : q (b i * n) - (b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n)\n      = (b i) ^ (p a b) * n ^ (p a b) * (1 + \u03b5 n) := by\n    have := R.b_pos i\n    simp only [q]\n    simp only [mul_rpow (by positivity : (0 : \u211d) \u2264 b i) (by positivity : (0 : \u211d) \u2264 n)]\n    ring\n  show (b i) ^ (p a b) * n ^ (p a b) * (1 + \u03b5 n) \u2264 q (r i n)\n  rw [\u2190 h\u2081]\n  rw [sub_le_iff_le_add']\n  rw [\u2190 sub_le_iff_le_add]\n  exact hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)", "(a b) in", "(g) (a) (b)", "{g} {a} {b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), b i ^ sorry * \u2191n ^ sorry * (1 + sorry) \u2264 \u2191(r i n) ^ sorry * (1 + sorry)"}, {"line": "rw [Filter.eventually_all]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 \u2200 (i : \u03b1), \u2200\u1da0 (x : \u2115) in atTop, b i ^ sorry * \u2191x ^ sorry * (1 + sorry) \u2264 \u2191(r i x) ^ sorry * (1 + sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "intro i", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, b i ^ sorry * \u2191x ^ sorry * (1 + sorry) \u2264 \u2191(r i x) ^ sorry * (1 + sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "let q : \u211d \u2192 \u211d := fun x => x ^ (p a b) * (1 + \u03b5 x)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 + sorry)\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, b i ^ sorry * \u2191x ^ sorry * (1 + sorry) \u2264 \u2191(r i x) ^ sorry * (1 + sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "have h_diff_q : DifferentiableOn \u211d q (Set.Ioi 1) := sorry", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 + sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, b i ^ sorry * \u2191x ^ sorry * (1 + sorry) \u2264 \u2191(r i x) ^ sorry * (1 + sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc\n    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 + \u03b5 z) x := by rfl\n          _ =\u1da0[atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 + \u03b5 x)\n              + x ^ (p a b) * deriv (fun z => 1 + \u03b5 z) x := by\n                filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'\n                rw [deriv_mul] <;> aesop\n          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by\n                refine IsBigO.add ?left ?right\n                case left => calc\n                  (fun x => deriv (fun z => z ^ (p a b)) x * (1 + \u03b5 x))\n                      =O[atTop] fun x => x ^ ((p a b) - 1) * (1 + \u03b5 x) := by\n                        exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)\n                    _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 :=\n                        IsBigO.mul (isBigO_refl _ _) isEquivalent_one_add_smoothingFn_one.isBigO\n                    _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]\n                case right => calc\n                  (fun x => x ^ (p a b) * deriv (fun z => 1 + \u03b5 z) x)\n                      =O[atTop] (fun x => x ^ (p a b) * x\u207b\u00b9) := by\n                        exact IsBigO.mul (isBigO_refl _ _)\n                          isLittleO_deriv_one_add_smoothingFn.isBigO\n                    _ =\u1da0[atTop] fun x => x ^ ((p a b) - 1) := by\n                        filter_upwards [eventually_gt_atTop 0] with x hx\n                        rw [\u2190 Real.rpow_neg_one]\n                        rw [\u2190 Real.rpow_add hx]\n                        rw [\u2190 sub_eq_add_neg]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 + sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x => x ^ (sorry - 1)\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, b i ^ sorry * \u2191x ^ sorry * (1 + sorry) \u2264 \u2191(r i x) ^ sorry * (1 + sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "have h_main_norm : (fun (n : \u2115) => \u2016q (r i n) - q (b i * n)\u2016)\n      \u2264\u1da0[atTop] fun (n : \u2115) => \u2016(b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n)\u2016 := by\n    refine IsLittleO.eventuallyLE ?_\n    calc\n      (fun (n : \u2115) => q (r i n) - q (b i * n))\n          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by\n            exact R.isBigO_apply_r_sub_b q h_diff_q\n              (growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p a b)) i\n        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by\n            exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)\n        _ =O[atTop] fun n => n ^ ((p a b) - 1) * (n / log n ^ 2) := by\n            exact IsBigO.mul (IsBigO.natCast_atTop h_deriv_q) (isBigO_refl _ _)\n        _ =\u1da0[atTop] fun n => n ^ (p a b) / (log n) ^ 2 := by\n            filter_upwards [eventually_ne_atTop 0] with n hn\n            have hn' : (n : \u211d) \u2260 0 := by positivity\n            simp [\u2190 mul_div_assoc, \u2190 Real.rpow_add_one hn']\n        _ = fun (n : \u2115) => (n : \u211d) ^ (p a b) * (1 / (log n) ^ 2) := by simp_rw [mul_div, mul_one]\n        _ =\u0398[atTop] fun (n : \u2115) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n) ^ 2) := by\n            refine IsTheta.symm ?_\n            simp_rw [mul_assoc]\n            refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)\n            have := R.b_pos i; positivity\n        _ =\u0398[atTop] fun (n : \u2115) => (b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n) := by\n            exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)\n                  <| R.isTheta_smoothingFn_sub_self i", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 + sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x => x ^ (sorry - 1)\nh_main_norm : (fun n => \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n => \u2016b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\u2016\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, b i ^ sorry * \u2191x ^ sorry * (1 + sorry) \u2264 \u2191(r i x) ^ sorry * (1 + sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "have h_main : (fun (n : \u2115) => q (b i * n) - q (r i n))\n      \u2264\u1da0[atTop] fun (n : \u2115) => (b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n) := by\n    calc (fun (n : \u2115) => q (b i * n) - q (r i n))\n           \u2264\u1da0[atTop] fun (n : \u2115) => \u2016q (r i n) - q (b i * n)\u2016 := by\n              filter_upwards with _; rw [norm_sub_rev]; exact le_norm_self _\n         _ \u2264\u1da0[atTop] fun (n : \u2115) => \u2016(b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n)\u2016 :=\n              h_main_norm\n         _ =\u1da0[atTop] fun (n : \u2115) => (b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n) := by\n              filter_upwards [eventually_gt_atTop \u2308(b i)\u207b\u00b9\u2309\u208a, eventually_gt_atTop 1] with n hn hn'\n              refine norm_of_nonneg ?_\n              have h\u2081 := R.b_pos i\n              have h\u2082 : 0 \u2264 \u03b5 (b i * n) - \u03b5 n := by\n                refine sub_nonneg_of_le <|\n                  (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le\n                case n_gt_one =>\n                  show 1 < (n : \u211d)\n                  rw [Nat.one_lt_cast]\n                  exact hn'\n                case bn_gt_one =>\n                  calc 1 = b i * (b i)\u207b\u00b9 := by rw [mul_inv_cancel\u2080 (by positivity)]\n                      _ \u2264 b i * \u2308(b i)\u207b\u00b9\u2309\u208a := by gcongr; exact Nat.le_ceil _\n                      _ < b i * n := by gcongr\n                case le => calc b i * n \u2264 1 * n := by have := R.b_lt_one i; gcongr\n                                        _ = n := by rw [one_mul]\n              positivity", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 + sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x => x ^ (sorry - 1)\nh_main_norm : (fun n => \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n => \u2016b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\u2016\nh_main : (fun n => q (b i * \u2191n) - q \u2191(r i n)) \u2264\u1da0[atTop] fun n => b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, b i ^ sorry * \u2191x ^ sorry * (1 + sorry) \u2264 \u2191(r i x) ^ sorry * (1 + sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "filter_upwards [h_main] with n hn", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 + sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x => x ^ (sorry - 1)\nh_main_norm : (fun n => \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n => \u2016b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\u2016\nh_main : (fun n => q (b i * \u2191n) - q \u2191(r i n)) \u2264\u1da0[atTop] fun n => b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nn : \u2115\nhn : q (b i * \u2191n) - q \u2191(r i n) \u2264 b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\n\u22a2 b i ^ sorry * \u2191n ^ sorry * (1 + sorry) \u2264 \u2191(r i n) ^ sorry * (1 + sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "have h\u2081 : q (b i * n) - (b i) ^ (p a b) * n ^ (p a b) * (\u03b5 (b i * n) - \u03b5 n)\n      = (b i) ^ (p a b) * n ^ (p a b) * (1 + \u03b5 n) := by\n    have := R.b_pos i\n    simp only [q]\n    simp only [mul_rpow (by positivity : (0 : \u211d) \u2264 b i) (by positivity : (0 : \u211d) \u2264 n)]\n    ring", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 + sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x => x ^ (sorry - 1)\nh_main_norm : (fun n => \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n => \u2016b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\u2016\nh_main : (fun n => q (b i * \u2191n) - q \u2191(r i n)) \u2264\u1da0[atTop] fun n => b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nn : \u2115\nhn : q (b i * \u2191n) - q \u2191(r i n) \u2264 b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nh\u2081 : q (b i * \u2191n) - b i ^ sorry * \u2191n ^ sorry * (sorry - sorry) = b i ^ sorry * \u2191n ^ sorry * (1 + sorry)\n\u22a2 b i ^ sorry * \u2191n ^ sorry * (1 + sorry) \u2264 \u2191(r i n) ^ sorry * (1 + sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "show (b i) ^ (p a b) * n ^ (p a b) * (1 + \u03b5 n) \u2264 q (r i n)", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 + sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x => x ^ (sorry - 1)\nh_main_norm : (fun n => \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n => \u2016b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\u2016\nh_main : (fun n => q (b i * \u2191n) - q \u2191(r i n)) \u2264\u1da0[atTop] fun n => b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nn : \u2115\nhn : q (b i * \u2191n) - q \u2191(r i n) \u2264 b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nh\u2081 : q (b i * \u2191n) - b i ^ sorry * \u2191n ^ sorry * (sorry - sorry) = b i ^ sorry * \u2191n ^ sorry * (1 + sorry)\n\u22a2 b i ^ sorry * \u2191n ^ sorry * (1 + sorry) \u2264 q \u2191(r i n)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "rw [\u2190 h\u2081]", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 + sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x => x ^ (sorry - 1)\nh_main_norm : (fun n => \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n => \u2016b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\u2016\nh_main : (fun n => q (b i * \u2191n) - q \u2191(r i n)) \u2264\u1da0[atTop] fun n => b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nn : \u2115\nhn : q (b i * \u2191n) - q \u2191(r i n) \u2264 b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nh\u2081 : q (b i * \u2191n) - b i ^ sorry * \u2191n ^ sorry * (sorry - sorry) = b i ^ sorry * \u2191n ^ sorry * (1 + sorry)\n\u22a2 q (b i * \u2191n) - b i ^ sorry * \u2191n ^ sorry * (sorry - sorry) \u2264 q \u2191(r i n)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "rw [sub_le_iff_le_add']", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 + sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x => x ^ (sorry - 1)\nh_main_norm : (fun n => \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n => \u2016b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\u2016\nh_main : (fun n => q (b i * \u2191n) - q \u2191(r i n)) \u2264\u1da0[atTop] fun n => b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nn : \u2115\nhn : q (b i * \u2191n) - q \u2191(r i n) \u2264 b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nh\u2081 : q (b i * \u2191n) - b i ^ sorry * \u2191n ^ sorry * (sorry - sorry) = b i ^ sorry * \u2191n ^ sorry * (1 + sorry)\n\u22a2 q (b i * \u2191n) \u2264 b i ^ sorry * \u2191n ^ sorry * (sorry - sorry) + q \u2191(r i n)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "rw [\u2190 sub_le_iff_le_add]", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 + sorry)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x => x ^ (sorry - 1)\nh_main_norm : (fun n => \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n => \u2016b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\u2016\nh_main : (fun n => q (b i * \u2191n) - q \u2191(r i n)) \u2264\u1da0[atTop] fun n => b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nn : \u2115\nhn : q (b i * \u2191n) - q \u2191(r i n) \u2264 b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\nh\u2081 : q (b i * \u2191n) - b i ^ sorry * \u2191n ^ sorry * (sorry - sorry) = b i ^ sorry * \u2191n ^ sorry * (1 + sorry)\n\u22a2 q (b i * \u2191n) - q \u2191(r i n) \u2264 b i ^ sorry * \u2191n ^ sorry * (sorry - sorry)\n---\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}, {"line": "exact hn", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nx\u271d\u00b9 : Sort u_3\np : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03b5 : x\u271d\n\u22a2 Finite \u03b1"}]}
{"declaration": "lemma base_nonempty {n : \u2115} (hn : 0 < n) : (Finset.Ico (\u230ab (min_bi b) / 2 * n\u230b\u208a) n).Nonempty := by\n  let b' := b (min_bi b)\n  have hb_pos : 0 < b' := R.b_pos _\n  simp_rw [Finset.nonempty_Ico]\n  exact_mod_cast calc \u230ab' / 2 * n\u230b\u208a \u2264 b' / 2 * n := by exact Nat.floor_le (by positivity)\n                                 _ < 1 / 2 * n   := by gcongr; exact R.b_lt_one (min_bi b)\n                                 _ \u2264 1 * n       := by gcongr; norm_num\n                                 _ = n           := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Computability/AkraBazzi/AkraBazzi.lean", "context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)", "(a b) in", "(g) (a) (b)", "{g} {a} {b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\nx\u271d : Sort u_3\nmin_bi : x\u271d\nn : \u2115\nhn : 0 < n\n\u22a2 (Ico \u230ab sorry / 2 * \u2191n\u230b\u208a n).Nonempty"}, {"line": "let b' := b (min_bi b)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\nx\u271d : Sort u_3\nmin_bi : x\u271d\nn : \u2115\nhn : 0 < n\nb' : \u211d := b sorry\n\u22a2 (Ico \u230ab sorry / 2 * \u2191n\u230b\u208a n).Nonempty"}, {"line": "have hb_pos : 0 < b' := R.b_pos _", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\nx\u271d : Sort u_3\nmin_bi : x\u271d\nn : \u2115\nhn : 0 < n\nb' : \u211d := b sorry\nhb_pos : 0 < b'\n\u22a2 (Ico \u230ab sorry / 2 * \u2191n\u230b\u208a n).Nonempty"}, {"line": "simp_rw [Finset.nonempty_Ico]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\nb : \u03b1 \u2192 \u211d\ninst\u271d : Nonempty \u03b1\nx\u271d : Sort u_3\nmin_bi : x\u271d\nn : \u2115\nhn : 0 < n\nb' : \u211d := b sorry\nhb_pos : 0 < b'\n\u22a2 \u230ab sorry / 2 * \u2191n\u230b\u208a < n"}, {"line": "exact_mod_cast calc \u230ab' / 2 * n\u230b\u208a \u2264 b' / 2 * n := by exact Nat.floor_le (by positivity)\n                                 _ < 1 / 2 * n   := by gcongr; exact R.b_lt_one (min_bi b)\n                                 _ \u2264 1 * n       := by gcongr; norm_num\n                                 _ = n           := by simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hasExactLimitsOfShape [HasLimitsOfShape J A] [HasExactLimitsOfShape J A]\n    [HasFiniteColimits A] : HasExactLimitsOfShape J (Condensed.{u} A) := by\n  let e : Condensed.{u} A \u224c Sheaf (extensiveTopology Stonean.{u}) A :=\n    (StoneanCompHaus.equivalence A).symm.trans Presheaf.coherentExtensiveEquivalence\n  have : HasLimitsOfShape J (Sheaf (extensiveTopology Stonean.{u}) A) :=\n    hasLimitsOfShape_of_hasLimitsOfShape_createsLimitsOfShape e.inverse\n  exact HasExactLimitsOfShape.domain_of_functor _ e.functor\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Condensed/AB.lean", "context": {"open": ["Condensed CategoryTheory Limits"], "variables": ["(A J : Type*) [Category A] [Category J] [Preadditive A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\nJ : Type u_2\ninst\u271d\u2075 : Category.{u_4, u_1} A\ninst\u271d\u2074 : Category.{u_3, u_2} J\ninst\u271d\u00b3 : Preadditive A\ninst\u271d\u00b2 : HasLimitsOfShape J A\ninst\u271d\u00b9 : HasExactLimitsOfShape J A\ninst\u271d : HasFiniteColimits A\n\u22a2 HasExactLimitsOfShape J (Condensed A)"}, {"line": "let e : Condensed.{u} A \u224c Sheaf (extensiveTopology Stonean.{u}) A :=\n    (StoneanCompHaus.equivalence A).symm.trans Presheaf.coherentExtensiveEquivalence", "tactic_state": "A : Type u_1\nJ : Type u_2\ninst\u271d\u2075 : Category.{u_4, u_1} A\ninst\u271d\u2074 : Category.{u_3, u_2} J\ninst\u271d\u00b3 : Preadditive A\ninst\u271d\u00b2 : HasLimitsOfShape J A\ninst\u271d\u00b9 : HasExactLimitsOfShape J A\ninst\u271d : HasFiniteColimits A\ne : sorry := sorry\n\u22a2 HasExactLimitsOfShape J (Condensed A)"}, {"line": "have : HasLimitsOfShape J (Sheaf (extensiveTopology Stonean.{u}) A) :=\n    hasLimitsOfShape_of_hasLimitsOfShape_createsLimitsOfShape e.inverse", "tactic_state": "A : Type u_1\nJ : Type u_2\ninst\u271d\u2075 : Category.{u_4, u_1} A\ninst\u271d\u2074 : Category.{u_3, u_2} J\ninst\u271d\u00b3 : Preadditive A\ninst\u271d\u00b2 : HasLimitsOfShape J A\ninst\u271d\u00b9 : HasExactLimitsOfShape J A\ninst\u271d : HasFiniteColimits A\ne : sorry := sorry\nthis : sorry\n\u22a2 HasExactLimitsOfShape J (Condensed A)"}, {"line": "exact HasExactLimitsOfShape.domain_of_functor _ e.functor", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_locallyConstant_essImage_of_isColimit_mapCocone (X : LightCondSet.{u})\n    (h : \u2200 S : LightProfinite.{u}, IsColimit <|\n      X.val.mapCocone (coconeRightOpOfCone S.asLimitCone)) :\n    LightCondSet.LocallyConstant.functor.essImage X := by\n  let i : X.val \u2245 (LightCondSet.LocallyConstant.functor.obj _).val :=\n    LightCondensed.isoLocallyConstantOfIsColimit _ h\n  exact \u27e8_, \u27e8((sheafToPresheaf _ _).preimageIso i.symm)\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Condensed/Discrete/Characterization.lean", "context": {"open": ["CategoryTheory Limits Functor FintypeCat", "CompHausLike.LocallyConstant", "Condensed", "CondensedSet.LocallyConstant List in", "CondensedMod.LocallyConstant List in"], "variables": ["{C : Type*} [Category C] [HasWeakSheafify (coherentTopology CompHaus.{u}) C]", "(R : Type (u + 1)) [Ring R]", "{C : Type*} [Category C] [HasWeakSheafify (coherentTopology LightProfinite.{u}) C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : LightCondSet\nh : (S : LightProfinite) \u2192 IsColimit (X.val.mapCocone (coconeRightOpOfCone S.asLimitCone))\n\u22a2 LightCondSet.LocallyConstant.functor.essImage X"}, {"line": "let i : X.val \u2245 (LightCondSet.LocallyConstant.functor.obj _).val :=\n    LightCondensed.isoLocallyConstantOfIsColimit _ h", "tactic_state": "X : LightCondSet\nh : (S : LightProfinite) \u2192 IsColimit (X.val.mapCocone (coconeRightOpOfCone S.asLimitCone))\ni : X.val \u2245\n  (LightCondSet.LocallyConstant.functor.obj\n      (X.val.obj (toLightProfinite.op.obj (Opposite.op (FintypeCat.of PUnit.{u + 1}))))).val :=\n  LightCondensed.isoLocallyConstantOfIsColimit X.val h\n\u22a2 LightCondSet.LocallyConstant.functor.essImage X"}, {"line": "exact \u27e8_, \u27e8((sheafToPresheaf _ _).preimageIso i.symm)\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lanPresheafNatIso_hom_app (hF : \u2200 S : Profinite, IsColimit <| F.mapCocone S.asLimitCone.op)\n    (S : Profinite\u1d52\u1d56) : (lanPresheafNatIso hF).hom.app S =\n      colimit.desc _ (Profinite.Extend.cocone _ _) := by\n  simp [lanPresheafNatIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Condensed/Discrete/Colimit.lean", "context": {"open": ["CategoryTheory Functor Limits FintypeCat CompHausLike.LocallyConstant"], "variables": ["{I : Type u} [Category.{u} I] [IsCofiltered I] {F : I \u2964 FintypeCat.{u}}", "{S : Profinite.{u}} {F : Profinite.{u}\u1d52\u1d56 \u2964 Type (u + 1)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : CategoryTheory.Functor Profinite\u1d52\u1d56 (Type (u + 1))\nx\u271d : Sort u_1\nlanPresheafNatIso : x\u271d\nhF : (S : Profinite) \u2192 IsColimit (F.mapCocone S.asLimitCone.op)\nS : Profinite\u1d52\u1d56\n\u22a2 sorry =\n    colimit.desc\n      ((CostructuredArrow.proj toProfinite.op (Opposite.op (?m.17793 hF S))).comp (toProfinite.op.comp (?m.17794 hF S)))\n      (Profinite.Extend.cocone (?m.17794 hF S) (?m.17793 hF S))"}, {"line": "simp [lanPresheafNatIso]", "tactic_state": "F : CategoryTheory.Functor Profinite\u1d52\u1d56 (Type (u + 1))\nx\u271d : Sort u_1\nlanPresheafNatIso : x\u271d\nhF : (S : Profinite) \u2192 IsColimit (F.mapCocone S.asLimitCone.op)\nS : Profinite\u1d52\u1d56\n\u22a2 sorry () =\n    colimit.desc\n      ((CostructuredArrow.proj toProfinite.op (Opposite.op (?m.17793 hF S))).comp (toProfinite.op.comp (?m.17794 hF S)))\n      (Profinite.Extend.cocone (?m.17794 hF S) (?m.17793 hF S))"}]}
{"declaration": "lemma lanPresheafNatIso_hom_app\n    (hF : \u2200 S : LightProfinite, IsColimit <| F.mapCocone (coconeRightOpOfCone S.asLimitCone))\n    (S : LightProfinite\u1d52\u1d56) : (lanPresheafNatIso hF).hom.app S =\n      colimit.desc _ (LightProfinite.Extend.cocone _ _) := by\n  simp [lanPresheafNatIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Condensed/Discrete/Colimit.lean", "context": {"open": ["CategoryTheory Functor Limits FintypeCat CompHausLike.LocallyConstant"], "variables": ["{I : Type u} [Category.{u} I] [IsCofiltered I] {F : I \u2964 FintypeCat.{u}}", "{S : Profinite.{u}} {F : Profinite.{u}\u1d52\u1d56 \u2964 Type (u + 1)}", "(F : Profinite.{u}\u1d52\u1d56 \u2964 Type (u + 1))", "[PreservesFiniteProducts F]", "{F : \u2115\u1d52\u1d56 \u2964 FintypeCat.{u}} (c : Cone <| F \u22d9 toLightProfinite) (X : Type u)", "{S : LightProfinite.{u}} {F : LightProfinite.{u}\u1d52\u1d56 \u2964 Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : CategoryTheory.Functor LightProfinite\u1d52\u1d56 (Type u)\nx\u271d : Sort u_1\nlanPresheafNatIso : x\u271d\nhF : (S : LightProfinite) \u2192 IsColimit (F.mapCocone (coconeRightOpOfCone S.asLimitCone))\nS : LightProfinite\u1d52\u1d56\n\u22a2 sorry =\n    colimit.desc\n      ((CostructuredArrow.proj toLightProfinite.op (Opposite.op (?m.32861 hF S))).comp\n        (toLightProfinite.op.comp (?m.32862 hF S)))\n      (LightProfinite.Extend.cocone (?m.32862 hF S) (?m.32861 hF S))"}, {"line": "simp [lanPresheafNatIso]", "tactic_state": "F : CategoryTheory.Functor LightProfinite\u1d52\u1d56 (Type u)\nx\u271d : Sort u_1\nlanPresheafNatIso : x\u271d\nhF : (S : LightProfinite) \u2192 IsColimit (F.mapCocone (coconeRightOpOfCone S.asLimitCone))\nS : LightProfinite\u1d52\u1d56\n\u22a2 sorry () =\n    colimit.desc\n      ((CostructuredArrow.proj toLightProfinite.op (Opposite.op (?m.32861 hF S))).comp\n        (toLightProfinite.op.comp (?m.32862 hF S)))\n      (LightProfinite.Extend.cocone (?m.32862 hF S) (?m.32861 hF S))"}]}
{"declaration": "theorem Applicative.map_seq_map (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (g : \u03c3 \u2192 \u03b2) (x : F \u03b1) (y : F \u03c3) :\n    f <$> x <*> g <$> y = ((\u00b7 \u2218 g) \u2218 f) <$> x <*> y := by\n  simp [flip, functor_norm, Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Applicative.lean", "context": {"open": ["Function"], "variables": ["{F : Type u \u2192 Type v}", "[Applicative F] [LawfulApplicative F]", "{\u03b1 \u03b2 \u03b3 \u03c3 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u \u2192 Type v\ninst\u271d\u00b9 : Applicative F\ninst\u271d : LawfulApplicative F\n\u03b1 \u03b2 \u03b3 \u03c3 : Type u\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng : \u03c3 \u2192 \u03b2\nx : F \u03b1\ny : F \u03c3\n\u22a2 f <$> x <*> g <$> y = ((fun x => x \u2218 g) \u2218 f) <$> x <*> y"}, {"line": "simp [flip, functor_norm, Function.comp_def]", "tactic_state": "F : Type u \u2192 Type v\ninst\u271d\u00b9 : Applicative F\ninst\u271d : LawfulApplicative F\n\u03b1 \u03b2 \u03b3 \u03c3 : Type u\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng : \u03c3 \u2192 \u03b2\nx : F \u03b1\ny : F \u03c3\n\u22a2 f <$> x <*> g <$> y = (fun x x_1 => f x (g x_1)) <$> x <*> y"}]}
{"declaration": "theorem fish_pipe {\u03b1 \u03b2} (f : \u03b1 \u2192 m \u03b2) : pure >=> f = f := by\n  simp +unfoldPartialApp only [(\u00b7 >=> \u00b7), functor_norm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type u}", "{F : Type u \u2192 Type v} [Applicative F]", "[LawfulApplicative F]", "{m : Type u \u2192 Type v} [Monad m] [LawfulMonad m]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 \u03b2 : Type u\nf : \u03b1 \u2192 m \u03b2\n\u22a2 pure >=> f = f"}, {"line": "simp +unfoldPartialApp only [(\u00b7 >=> \u00b7), functor_norm]", "tactic_state": "m : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 \u03b2 : Type u\nf : \u03b1 \u2192 m \u03b2\n\u22a2 (fun a => pure a >>= f) = f"}]}
{"declaration": "theorem fish_assoc {\u03b1 \u03b2 \u03b3 \u03c6} (f : \u03b1 \u2192 m \u03b2) (g : \u03b2 \u2192 m \u03b3) (h : \u03b3 \u2192 m \u03c6) :\n    (f >=> g) >=> h = f >=> g >=> h := by\n  simp +unfoldPartialApp only [(\u00b7 >=> \u00b7), functor_norm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type u}", "{F : Type u \u2192 Type v} [Applicative F]", "[LawfulApplicative F]", "{m : Type u \u2192 Type v} [Monad m] [LawfulMonad m]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\n\u03b2 \u03b3 \u03c6 : Type u\nf : \u03b1 \u2192 m \u03b2\ng : \u03b2 \u2192 m \u03b3\nh : \u03b3 \u2192 m \u03c6\n\u22a2 (f >=> g) >=> h = f >=> g >=> h"}, {"line": "simp +unfoldPartialApp only [(\u00b7 >=> \u00b7), functor_norm]", "tactic_state": "m : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\n\u03b2 \u03b3 \u03c6 : Type u\nf : \u03b1 \u2192 m \u03b2\ng : \u03b2 \u2192 m \u03b3\nh : \u03b3 \u2192 m \u03c6\n\u22a2 (fun a => f a >>= g >>= h) = fun a => f a >>= fun a => g a >>= h"}]}
{"declaration": "theorem guard_true {h : Decidable True} : @guard F _ True h = pure () := by simp [guard, if_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type u}", "{F : Type u \u2192 Type v} [Applicative F]", "[LawfulApplicative F]", "{m : Type u \u2192 Type v} [Monad m] [LawfulMonad m]", "{\u03b2' \u03b3' : Type v}", "{m' : Type v \u2192 Type w} [Monad m']", "{m : Type u \u2192 Type u} [Monad m] [LawfulMonad m]", "{F : Type \u2192 Type v} [Alternative F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type \u2192 Type v\ninst\u271d : Alternative F\nh : Decidable True\n\u22a2 guard True = pure ()"}, {"line": "simp [guard, if_pos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem guard_false {h : Decidable False} : @guard F _ False h = failure := by\n  simp [guard, if_neg not_false]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type u}", "{F : Type u \u2192 Type v} [Applicative F]", "[LawfulApplicative F]", "{m : Type u \u2192 Type v} [Monad m] [LawfulMonad m]", "{\u03b2' \u03b3' : Type v}", "{m' : Type v \u2192 Type w} [Monad m']", "{m : Type u \u2192 Type u} [Monad m] [LawfulMonad m]", "{F : Type \u2192 Type v} [Alternative F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type \u2192 Type v\ninst\u271d : Alternative F\nh : Decidable False\n\u22a2 guard False = failure"}, {"line": "simp [guard, if_neg not_false]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem foldrm.ofFreeMonoid_comp_of {m} [Monad m] [LawfulMonad m] (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b1) :\n    foldrM.ofFreeMonoid f \u2218 FreeMonoid.of = foldrM.mk \u2218 f := by\n  ext\n  simp [(\u00b7 \u2218 \u00b7), foldrM.ofFreeMonoid, foldrM.mk, Function.flip_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Fold.lean", "context": {"open": ["ULift CategoryTheory MulOpposite", "Monoid Functor", "Function hiding const", "LawfulTraversable", "LawfulTraversable", "List (cons)"], "variables": ["{m : Type u \u2192 Type u} [Monad m]", "{\u03b1 \u03b2 : Type u}", "{\u03b1 \u03b2 : Type u} {t : Type u \u2192 Type u} [Traversable t]", "{m : Type u \u2192 Type u} [Monad m]", "{\u03b1 \u03b2 \u03b3 : Type u}", "{t : Type u \u2192 Type u} [Traversable t] [LawfulTraversable t]", "{\u03b1 \u03b2 \u03b3 : Type u}", "{t : Type u \u2192 Type u} [Traversable t] [LawfulTraversable t]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type u\nm : Type u \u2192 Type u\ninst\u271d\u00b9 : _root_.Monad m\ninst\u271d : LawfulMonad m\nf : \u03b2 \u2192 \u03b1 \u2192 m \u03b1\n\u22a2 \u21d1(foldrM.ofFreeMonoid f) \u2218 FreeMonoid.of = foldrM.mk \u2218 f"}, {"line": "ext", "tactic_state": "case h\n\u03b1 \u03b2 : Type u\nm : Type u \u2192 Type u\ninst\u271d\u00b9 : _root_.Monad m\ninst\u271d : LawfulMonad m\nf : \u03b2 \u2192 \u03b1 \u2192 m \u03b1\nx\u271d : \u03b2\n\u22a2 (\u21d1(foldrM.ofFreeMonoid f) \u2218 FreeMonoid.of) x\u271d = (foldrM.mk \u2218 f) x\u271d"}, {"line": "simp [(\u00b7 \u2218 \u00b7), foldrM.ofFreeMonoid, foldrM.mk, Function.flip_def]", "tactic_state": "case h\n\u03b1 \u03b2 : Type u\nm : Type u \u2192 Type u\ninst\u271d\u00b9 : _root_.Monad m\ninst\u271d : LawfulMonad m\nf : \u03b2 \u2192 \u03b1 \u2192 m \u03b1\nx\u271d : \u03b2\n\u22a2 (fun a => List.foldrM f a [x\u271d]) = f x\u271d"}]}
{"declaration": "theorem comp_fst {\u03b1\u2080 \u03b1\u2081 \u03b1\u2082 \u03b2} (f : \u03b1\u2080 \u2192 \u03b1\u2081) (f' : \u03b1\u2081 \u2192 \u03b1\u2082) (x : F \u03b1\u2080 \u03b2) :\n    fst f' (fst f x) = fst (f' \u2218 f) x := by simp [fst, bimap_bimap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Bifunctor.lean", "context": {"open": ["Function"], "variables": ["{F : Type u\u2080 \u2192 Type u\u2081 \u2192 Type u\u2082} [Bifunctor F]", "[LawfulBifunctor F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\u2080 \u2192 Type u\u2081 \u2192 Type u\u2082\ninst\u271d\u00b9 : Bifunctor F\ninst\u271d : LawfulBifunctor F\nx\u271d : Sort u_1\nfst : x\u271d\n\u03b1\u2080 : Type u\u2080\n\u03b1\u2081 : Sort u_2\n\u03b1\u2082 : Sort u_3\n\u03b2 : Type u\u2081\nf : \u03b1\u2080 \u2192 \u03b1\u2081\nf' : \u03b1\u2081 \u2192 \u03b1\u2082\nx : F \u03b1\u2080 \u03b2\n\u22a2 sorry = sorry"}, {"line": "simp [fst, bimap_bimap]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fst_snd {\u03b1\u2080 \u03b1\u2081 \u03b2\u2080 \u03b2\u2081} (f : \u03b1\u2080 \u2192 \u03b1\u2081) (f' : \u03b2\u2080 \u2192 \u03b2\u2081) (x : F \u03b1\u2080 \u03b2\u2080) :\n    fst f (snd f' x) = bimap f f' x := by simp [fst, bimap_bimap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Bifunctor.lean", "context": {"open": ["Function"], "variables": ["{F : Type u\u2080 \u2192 Type u\u2081 \u2192 Type u\u2082} [Bifunctor F]", "[LawfulBifunctor F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\u2080 \u2192 Type u\u2081 \u2192 Type u\u2082\ninst\u271d\u00b9 : Bifunctor F\ninst\u271d : LawfulBifunctor F\nx\u271d : Sort u_1\nfst : x\u271d\n\u03b1\u2080 \u03b1\u2081 : Type u\u2080\n\u03b2\u2080 \u03b2\u2081 : Type u\u2081\nf : \u03b1\u2080 \u2192 \u03b1\u2081\nf' : \u03b2\u2080 \u2192 \u03b2\u2081\nx : F \u03b1\u2080 \u03b2\u2080\n\u22a2 sorry = bimap f f' x"}, {"line": "simp [fst, bimap_bimap]", "tactic_state": "F : Type u\u2080 \u2192 Type u\u2081 \u2192 Type u\u2082\ninst\u271d\u00b9 : Bifunctor F\ninst\u271d : LawfulBifunctor F\nx\u271d : Sort u_1\nfst : x\u271d\n\u03b1\u2080 \u03b1\u2081 : Type u\u2080\n\u03b2\u2080 \u03b2\u2081 : Type u\u2081\nf : \u03b1\u2080 \u2192 \u03b1\u2081\nf' : \u03b2\u2080 \u2192 \u03b2\u2081\nx : F \u03b1\u2080 \u03b2\u2080\n\u22a2 sorry () = bimap f f' x"}]}
{"declaration": "theorem snd_fst {\u03b1\u2080 \u03b1\u2081 \u03b2\u2080 \u03b2\u2081} (f : \u03b1\u2080 \u2192 \u03b1\u2081) (f' : \u03b2\u2080 \u2192 \u03b2\u2081) (x : F \u03b1\u2080 \u03b2\u2080) :\n    snd f' (fst f x) = bimap f f' x := by simp [snd, bimap_bimap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Bifunctor.lean", "context": {"open": ["Function"], "variables": ["{F : Type u\u2080 \u2192 Type u\u2081 \u2192 Type u\u2082} [Bifunctor F]", "[LawfulBifunctor F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\u2080 \u2192 Type u\u2081 \u2192 Type u\u2082\ninst\u271d\u00b9 : Bifunctor F\ninst\u271d : LawfulBifunctor F\nx\u271d : Sort u_1\nsnd : x\u271d\n\u03b1\u2080 \u03b1\u2081 : Type u\u2080\n\u03b2\u2080 \u03b2\u2081 : Type u\u2081\nf : \u03b1\u2080 \u2192 \u03b1\u2081\nf' : \u03b2\u2080 \u2192 \u03b2\u2081\nx : F \u03b1\u2080 \u03b2\u2080\n\u22a2 sorry = bimap f f' x"}, {"line": "simp [snd, bimap_bimap]", "tactic_state": "F : Type u\u2080 \u2192 Type u\u2081 \u2192 Type u\u2082\ninst\u271d\u00b9 : Bifunctor F\ninst\u271d : LawfulBifunctor F\nx\u271d : Sort u_1\nsnd : x\u271d\n\u03b1\u2080 \u03b1\u2081 : Type u\u2080\n\u03b2\u2080 \u03b2\u2081 : Type u\u2081\nf : \u03b1\u2080 \u2192 \u03b1\u2081\nf' : \u03b2\u2080 \u2192 \u03b2\u2081\nx : F \u03b1\u2080 \u03b2\u2080\n\u22a2 sorry () = bimap f f' x"}]}
{"declaration": "theorem comp_snd {\u03b1 \u03b2\u2080 \u03b2\u2081 \u03b2\u2082} (g : \u03b2\u2080 \u2192 \u03b2\u2081) (g' : \u03b2\u2081 \u2192 \u03b2\u2082) (x : F \u03b1 \u03b2\u2080) :\n    snd g' (snd g x) = snd (g' \u2218 g) x := by simp [snd, bimap_bimap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Bifunctor.lean", "context": {"open": ["Function"], "variables": ["{F : Type u\u2080 \u2192 Type u\u2081 \u2192 Type u\u2082} [Bifunctor F]", "[LawfulBifunctor F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\u2080 \u2192 Type u\u2081 \u2192 Type u\u2082\ninst\u271d\u00b9 : Bifunctor F\ninst\u271d : LawfulBifunctor F\nx\u271d : Sort u_1\nsnd : x\u271d\n\u03b1 : Type u\u2080\n\u03b2\u2080 : Type u\u2081\n\u03b2\u2081 : Sort u_2\n\u03b2\u2082 : Sort u_3\ng : \u03b2\u2080 \u2192 \u03b2\u2081\ng' : \u03b2\u2081 \u2192 \u03b2\u2082\nx : F \u03b1 \u03b2\u2080\n\u22a2 sorry = sorry"}, {"line": "simp [snd, bimap_bimap]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fix_eq_\u03c9Sup_of_\u03c9ScottContinuous (hc : \u03c9ScottContinuous g) : Part.fix g =\n    \u03c9Sup (approxChain (\u27e8g,hc.monotone\u27e9 : ((a : _) \u2192 Part <| \u03b2 a) \u2192o (a : _) \u2192 Part <| \u03b2 a)) := by\n  rw [\u2190 fix_eq_\u03c9Sup]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/LawfulFix.lean", "context": {"open": ["OmegaCompletePartialOrder", "Part Nat Nat.Upto", "Fix", "OmegaCompletePartialOrder", "Part hiding \u03c9Sup", "Nat", "Nat.Upto OmegaCompletePartialOrder"], "variables": ["{\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*}", "(f : ((a : _) \u2192 Part <| \u03b2 a) \u2192o (a : _) \u2192 Part <| \u03b2 a)", "{\u03b1 : Type*}", "(f : ((a : _) \u2192 Part <| \u03b2 a) \u2192o (a : _) \u2192 Part <| \u03b2 a)", "{g : ((a : _) \u2192 Part <| \u03b2 a) \u2192 (a : _) \u2192 Part <| \u03b2 a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\ng : ((a : \u03b1) \u2192 Part (\u03b2 a)) \u2192 (a : \u03b1) \u2192 Part (\u03b2 a)\nhc : \u03c9ScottContinuous g\n\u22a2 Part.fix g = \u03c9Sup (approxChain { toFun := g, monotone' := \u22ef })"}, {"line": "rw [\u2190 fix_eq_\u03c9Sup]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\ng : ((a : \u03b1) \u2192 Part (\u03b2 a)) \u2192 (a : \u03b1) \u2192 Part (\u03b2 a)\nhc : \u03c9ScottContinuous g\n\u22a2 Part.fix g = Part.fix \u21d1{ toFun := g, monotone' := \u22ef }"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_inj \u2983\u03b7 \u03b7' : ApplicativeTransformation F G\u2984 (h : (\u03b7 : \u2200 \u03b1, F \u03b1 \u2192 G \u03b1) = \u03b7') :\n    \u03b7 = \u03b7' := by\n  cases \u03b7\n  cases \u03b7'\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Traversable/Basic.lean", "context": {"open": ["Function hiding comp"], "variables": ["(F : Type u \u2192 Type v) [Applicative F]", "(G : Type u \u2192 Type w) [Applicative G]", "(F : Type u \u2192 Type v) [Applicative F]", "(G : Type u \u2192 Type w) [Applicative G]", "{F G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u \u2192 Type v\ninst\u271d\u00b9 : Applicative F\nG : Type u \u2192 Type w\ninst\u271d : Applicative G\n\u03b7 \u03b7' : ApplicativeTransformation F G\nh : (fun {\u03b1} => \u03b7.app \u03b1) = fun {\u03b1} => \u03b7'.app \u03b1\n\u22a2 \u03b7 = \u03b7'"}, {"line": "cases \u03b7", "tactic_state": "case mk\nF : Type u \u2192 Type v\ninst\u271d\u00b9 : Applicative F\nG : Type u \u2192 Type w\ninst\u271d : Applicative G\n\u03b7' : ApplicativeTransformation F G\napp\u271d : (\u03b1 : Type u) \u2192 F \u03b1 \u2192 G \u03b1\npreserves_pure'\u271d : \u2200 {\u03b1 : Type u} (x : \u03b1), app\u271d \u03b1 (pure x) = pure x\npreserves_seq'\u271d : \u2200 {\u03b1 \u03b2 : Type u} (x : F (\u03b1 \u2192 \u03b2)) (y : F \u03b1), app\u271d \u03b2 (x <*> y) = app\u271d (\u03b1 \u2192 \u03b2) x <*> app\u271d \u03b1 y\nh :\n  (fun {\u03b1} => { app := app\u271d, preserves_pure' := preserves_pure'\u271d, preserves_seq' := preserves_seq'\u271d }.app \u03b1) =\n    fun {\u03b1} => \u03b7'.app \u03b1\n\u22a2 { app := app\u271d, preserves_pure' := preserves_pure'\u271d, preserves_seq' := preserves_seq'\u271d } = \u03b7'"}, {"line": "cases \u03b7'", "tactic_state": "case mk.mk\nF : Type u \u2192 Type v\ninst\u271d\u00b9 : Applicative F\nG : Type u \u2192 Type w\ninst\u271d : Applicative G\napp\u271d\u00b9 : (\u03b1 : Type u) \u2192 F \u03b1 \u2192 G \u03b1\npreserves_pure'\u271d\u00b9 : \u2200 {\u03b1 : Type u} (x : \u03b1), app\u271d\u00b9 \u03b1 (pure x) = pure x\npreserves_seq'\u271d\u00b9 : \u2200 {\u03b1 \u03b2 : Type u} (x : F (\u03b1 \u2192 \u03b2)) (y : F \u03b1), app\u271d\u00b9 \u03b2 (x <*> y) = app\u271d\u00b9 (\u03b1 \u2192 \u03b2) x <*> app\u271d\u00b9 \u03b1 y\napp\u271d : (\u03b1 : Type u) \u2192 F \u03b1 \u2192 G \u03b1\npreserves_pure'\u271d : \u2200 {\u03b1 : Type u} (x : \u03b1), app\u271d \u03b1 (pure x) = pure x\npreserves_seq'\u271d : \u2200 {\u03b1 \u03b2 : Type u} (x : F (\u03b1 \u2192 \u03b2)) (y : F \u03b1), app\u271d \u03b2 (x <*> y) = app\u271d (\u03b1 \u2192 \u03b2) x <*> app\u271d \u03b1 y\nh :\n  (fun {\u03b1} => { app := app\u271d\u00b9, preserves_pure' := preserves_pure'\u271d\u00b9, preserves_seq' := preserves_seq'\u271d\u00b9 }.app \u03b1) =\n    fun {\u03b1} => { app := app\u271d, preserves_pure' := preserves_pure'\u271d, preserves_seq' := preserves_seq'\u271d }.app \u03b1\n\u22a2 { app := app\u271d\u00b9, preserves_pure' := preserves_pure'\u271d\u00b9, preserves_seq' := preserves_seq'\u271d\u00b9 } =\n    { app := app\u271d, preserves_pure' := preserves_pure'\u271d, preserves_seq' := preserves_seq'\u271d }"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preserves_map' {\u03b1 \u03b2} (x : \u03b1 \u2192 \u03b2) : @\u03b7 _ \u2218 Functor.map x = Functor.map x \u2218 @\u03b7 _ := by\n  ext y\n  exact preserves_map \u03b7 x y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Traversable/Basic.lean", "context": {"open": ["Function hiding comp"], "variables": ["(F : Type u \u2192 Type v) [Applicative F]", "(G : Type u \u2192 Type w) [Applicative G]", "(F : Type u \u2192 Type v) [Applicative F]", "(G : Type u \u2192 Type w) [Applicative G]", "{F G}", "(\u03b7 : ApplicativeTransformation F G)", "[LawfulApplicative F] [LawfulApplicative G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u \u2192 Type v\ninst\u271d\u00b3 : Applicative F\nG : Type u \u2192 Type w\ninst\u271d\u00b2 : Applicative G\n\u03b7 : ApplicativeTransformation F G\ninst\u271d\u00b9 : LawfulApplicative F\ninst\u271d : LawfulApplicative G\n\u03b1 \u03b2 : Type u\nx : \u03b1 \u2192 \u03b2\n\u22a2 (fun {\u03b1} => \u03b7.app \u03b1) \u2218 Functor.map x = Functor.map x \u2218 fun {\u03b1} => \u03b7.app \u03b1"}, {"line": "ext y", "tactic_state": "case h\nF : Type u \u2192 Type v\ninst\u271d\u00b3 : Applicative F\nG : Type u \u2192 Type w\ninst\u271d\u00b2 : Applicative G\n\u03b7 : ApplicativeTransformation F G\ninst\u271d\u00b9 : LawfulApplicative F\ninst\u271d : LawfulApplicative G\n\u03b1 \u03b2 : Type u\nx : \u03b1 \u2192 \u03b2\ny : F \u03b1\n\u22a2 ((fun {\u03b1} => \u03b7.app \u03b1) \u2218 Functor.map x) y = (Functor.map x \u2218 fun {\u03b1} => \u03b7.app \u03b1) y"}, {"line": "exact preserves_map \u03b7 x y", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Option.id_traverse {\u03b1} (x : Option \u03b1) : Option.traverse (pure : \u03b1 \u2192 Id \u03b1) x = x := by\n  cases x <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Traversable/Instances.lean", "context": {"open": ["Functor"], "variables": ["{F G : Type u \u2192 Type u}", "[Applicative F] [Applicative G]", "[LawfulApplicative G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : Option \u03b1\n\u22a2 Option.traverse pure x = x"}, {"line": "cases x <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Option.traverse_eq_map_id {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (x : Option \u03b1) :\n    Option.traverse ((pure : _ \u2192 Id _) \u2218 f) x = (pure : _ \u2192 Id _) (f <$> x) := by cases x <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Traversable/Instances.lean", "context": {"open": ["Functor"], "variables": ["{F G : Type u \u2192 Type u}", "[Applicative F] [Applicative G]", "[LawfulApplicative G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\nx : Option \u03b1\n\u22a2 Option.traverse (pure \u2218 f) x = pure (f <$> x)"}, {"line": "cases x <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Option.naturality [LawfulApplicative F] {\u03b1 \u03b2} (f : \u03b1 \u2192 F \u03b2) (x : Option \u03b1) :\n    \u03b7 (Option.traverse f x) = Option.traverse (@\u03b7 _ \u2218 f) x := by\n  -- Porting note: added `ApplicativeTransformation` theorems\n  rcases x with - | x <;> simp! [*, functor_norm, ApplicativeTransformation.preserves_map,\n    ApplicativeTransformation.preserves_seq, ApplicativeTransformation.preserves_pure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Traversable/Instances.lean", "context": {"open": ["Functor"], "variables": ["{F G : Type u \u2192 Type u}", "[Applicative F] [Applicative G]", "[LawfulApplicative G]", "(\u03b7 : ApplicativeTransformation F G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F G : Type u \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : Applicative G\ninst\u271d\u00b9 : LawfulApplicative G\n\u03b7 : ApplicativeTransformation F G\ninst\u271d : LawfulApplicative F\n\u03b1 : Type u_1\n\u03b2 : Type u\nf : \u03b1 \u2192 F \u03b2\nx : Option \u03b1\n\u22a2 (fun {\u03b1} => \u03b7.app \u03b1) (Option.traverse f x) = Option.traverse ((fun {\u03b1} => \u03b7.app \u03b1) \u2218 f) x"}, {"line": "rcases x with - | x <;> simp! [*, functor_norm, ApplicativeTransformation.preserves_map,\n    ApplicativeTransformation.preserves_seq, ApplicativeTransformation.preserves_pure]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem id_sequence (x : t \u03b1) : sequence (f := Id) (pure <$> x) = pure x := by\n  simp [sequence, traverse_map, id_traverse]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Traversable/Lemmas.lean", "context": {"open": ["LawfulTraversable", "Function hiding comp", "Functor"], "variables": ["{t : Type u \u2192 Type u}", "[Traversable t] [LawfulTraversable t]", "(F G : Type u \u2192 Type u)", "[Applicative F] [LawfulApplicative F]", "[Applicative G] [LawfulApplicative G]", "{\u03b1 \u03b2 \u03b3 : Type u}", "(g : \u03b1 \u2192 F \u03b2)", "(f : \u03b2 \u2192 \u03b3)", "{F G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "t : Type u \u2192 Type u\ninst\u271d\u00b9 : Traversable t\ninst\u271d : LawfulTraversable t\n\u03b1 : Type u\nx : t \u03b1\n\u22a2 sequence (pure <$> x) = pure x"}, {"line": "simp [sequence, traverse_map, id_traverse]", "tactic_state": "t : Type u \u2192 Type u\ninst\u271d\u00b9 : Traversable t\ninst\u271d : LawfulTraversable t\n\u03b1 : Type u\nx : t \u03b1\n\u22a2 traverse id (pure <$> x) = x"}]}
{"declaration": "theorem naturality' (\u03b7 : ApplicativeTransformation F G) (x : t (F \u03b1)) :\n    \u03b7 (sequence x) = sequence (@\u03b7 _ <$> x) := by simp [sequence, naturality, traverse_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Traversable/Lemmas.lean", "context": {"open": ["LawfulTraversable", "Function hiding comp", "Functor"], "variables": ["{t : Type u \u2192 Type u}", "[Traversable t] [LawfulTraversable t]", "(F G : Type u \u2192 Type u)", "[Applicative F] [LawfulApplicative F]", "[Applicative G] [LawfulApplicative G]", "{\u03b1 \u03b2 \u03b3 : Type u}", "(g : \u03b1 \u2192 F \u03b2)", "(f : \u03b2 \u2192 \u03b3)", "{F G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "t : Type u \u2192 Type u\ninst\u271d\u2075 : Traversable t\ninst\u271d\u2074 : LawfulTraversable t\nF G : Type u \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : LawfulApplicative F\ninst\u271d\u00b9 : Applicative G\ninst\u271d : LawfulApplicative G\n\u03b1 : Type u\n\u03b7 : ApplicativeTransformation F G\nx : t (F \u03b1)\n\u22a2 (fun {\u03b1} => \u03b7.app \u03b1) (sequence x) = sequence ((fun {\u03b1} => \u03b7.app \u03b1) <$> x)"}, {"line": "simp [sequence, naturality, traverse_map]", "tactic_state": "t : Type u \u2192 Type u\ninst\u271d\u2075 : Traversable t\ninst\u271d\u2074 : LawfulTraversable t\nF G : Type u \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : LawfulApplicative F\ninst\u271d\u00b9 : Applicative G\ninst\u271d : LawfulApplicative G\n\u03b1 : Type u\n\u03b7 : ApplicativeTransformation F G\nx : t (F \u03b1)\n\u22a2 \u03b7.app (t \u03b1) (traverse id x) = traverse id (\u03b7.app \u03b1 <$> x)"}]}
{"declaration": "theorem traverse_id : traverse pure = (pure : t \u03b1 \u2192 Id (t \u03b1)) := by\n  ext\n  exact id_traverse _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Traversable/Lemmas.lean", "context": {"open": ["LawfulTraversable", "Function hiding comp", "Functor"], "variables": ["{t : Type u \u2192 Type u}", "[Traversable t] [LawfulTraversable t]", "(F G : Type u \u2192 Type u)", "[Applicative F] [LawfulApplicative F]", "[Applicative G] [LawfulApplicative G]", "{\u03b1 \u03b2 \u03b3 : Type u}", "(g : \u03b1 \u2192 F \u03b2)", "(f : \u03b2 \u2192 \u03b3)", "{F G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "t : Type u \u2192 Type u\ninst\u271d\u00b9 : Traversable t\ninst\u271d : LawfulTraversable t\n\u03b1 : Type u\n\u22a2 traverse pure = pure"}, {"line": "ext", "tactic_state": "case h\nt : Type u \u2192 Type u\ninst\u271d\u00b9 : Traversable t\ninst\u271d : LawfulTraversable t\n\u03b1 : Type u\nx\u271d : t \u03b1\n\u22a2 traverse pure x\u271d = pure x\u271d"}, {"line": "exact id_traverse _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem traverse_comp (g : \u03b1 \u2192 F \u03b2) (h : \u03b2 \u2192 G \u03b3) :\n    traverse (Comp.mk \u2218 map h \u2218 g) =\n      (Comp.mk \u2218 map (traverse h) \u2218 traverse g : t \u03b1 \u2192 Comp F G (t \u03b3)) := by\n  ext\n  exact comp_traverse _ _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Traversable/Lemmas.lean", "context": {"open": ["LawfulTraversable", "Function hiding comp", "Functor"], "variables": ["{t : Type u \u2192 Type u}", "[Traversable t] [LawfulTraversable t]", "(F G : Type u \u2192 Type u)", "[Applicative F] [LawfulApplicative F]", "[Applicative G] [LawfulApplicative G]", "{\u03b1 \u03b2 \u03b3 : Type u}", "(g : \u03b1 \u2192 F \u03b2)", "(f : \u03b2 \u2192 \u03b3)", "{F G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "t : Type u \u2192 Type u\ninst\u271d\u2075 : Traversable t\ninst\u271d\u2074 : LawfulTraversable t\nF G : Type u \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : LawfulApplicative F\ninst\u271d\u00b9 : Applicative G\ninst\u271d : LawfulApplicative G\n\u03b1 \u03b2 \u03b3 : Type u\ng : \u03b1 \u2192 F \u03b2\nh : \u03b2 \u2192 G \u03b3\n\u22a2 traverse (Comp.mk \u2218 map h \u2218 g) = Comp.mk \u2218 map (traverse h) \u2218 traverse g"}, {"line": "ext", "tactic_state": "case h\nt : Type u \u2192 Type u\ninst\u271d\u2075 : Traversable t\ninst\u271d\u2074 : LawfulTraversable t\nF G : Type u \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : LawfulApplicative F\ninst\u271d\u00b9 : Applicative G\ninst\u271d : LawfulApplicative G\n\u03b1 \u03b2 \u03b3 : Type u\ng : \u03b1 \u2192 F \u03b2\nh : \u03b2 \u2192 G \u03b3\nx\u271d : t \u03b1\n\u22a2 traverse (Comp.mk \u2218 map h \u2218 g) x\u271d = (Comp.mk \u2218 map (traverse h) \u2218 traverse g) x\u271d"}, {"line": "exact comp_traverse _ _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem traverse_eq_map_id' (f : \u03b2 \u2192 \u03b3) :\n    traverse (m := Id) (pure \u2218 f) = pure \u2218 (map f : t \u03b2 \u2192 t \u03b3) := by\n  ext\n  exact traverse_eq_map_id _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Traversable/Lemmas.lean", "context": {"open": ["LawfulTraversable", "Function hiding comp", "Functor"], "variables": ["{t : Type u \u2192 Type u}", "[Traversable t] [LawfulTraversable t]", "(F G : Type u \u2192 Type u)", "[Applicative F] [LawfulApplicative F]", "[Applicative G] [LawfulApplicative G]", "{\u03b1 \u03b2 \u03b3 : Type u}", "(g : \u03b1 \u2192 F \u03b2)", "(f : \u03b2 \u2192 \u03b3)", "{F G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "t : Type u \u2192 Type u\ninst\u271d\u00b9 : Traversable t\ninst\u271d : LawfulTraversable t\n\u03b2 \u03b3 : Type u\nf : \u03b2 \u2192 \u03b3\n\u22a2 traverse (pure \u2218 f) = pure \u2218 map f"}, {"line": "ext", "tactic_state": "case h\nt : Type u \u2192 Type u\ninst\u271d\u00b9 : Traversable t\ninst\u271d : LawfulTraversable t\n\u03b2 \u03b3 : Type u\nf : \u03b2 \u2192 \u03b3\nx\u271d : t \u03b2\n\u22a2 traverse (pure \u2218 f) x\u271d = (pure \u2218 map f) x\u271d"}, {"line": "exact traverse_eq_map_id _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem naturality_pf (\u03b7 : ApplicativeTransformation F G) (f : \u03b1 \u2192 F \u03b2) :\n    traverse (@\u03b7 _ \u2218 f) = @\u03b7 _ \u2218 (traverse f : t \u03b1 \u2192 F (t \u03b2)) := by\n  ext\n  rw [comp_apply]\n  rw [naturality]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Control/Traversable/Lemmas.lean", "context": {"open": ["LawfulTraversable", "Function hiding comp", "Functor"], "variables": ["{t : Type u \u2192 Type u}", "[Traversable t] [LawfulTraversable t]", "(F G : Type u \u2192 Type u)", "[Applicative F] [LawfulApplicative F]", "[Applicative G] [LawfulApplicative G]", "{\u03b1 \u03b2 \u03b3 : Type u}", "(g : \u03b1 \u2192 F \u03b2)", "(f : \u03b2 \u2192 \u03b3)", "{F G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "t : Type u \u2192 Type u\ninst\u271d\u2075 : Traversable t\ninst\u271d\u2074 : LawfulTraversable t\nF G : Type u \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : LawfulApplicative F\ninst\u271d\u00b9 : Applicative G\ninst\u271d : LawfulApplicative G\n\u03b1 \u03b2 : Type u\n\u03b7 : ApplicativeTransformation F G\nf : \u03b1 \u2192 F \u03b2\n\u22a2 traverse ((fun {\u03b1} => \u03b7.app \u03b1) \u2218 f) = (fun {\u03b1} => \u03b7.app \u03b1) \u2218 traverse f"}, {"line": "ext", "tactic_state": "case h\nt : Type u \u2192 Type u\ninst\u271d\u2075 : Traversable t\ninst\u271d\u2074 : LawfulTraversable t\nF G : Type u \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : LawfulApplicative F\ninst\u271d\u00b9 : Applicative G\ninst\u271d : LawfulApplicative G\n\u03b1 \u03b2 : Type u\n\u03b7 : ApplicativeTransformation F G\nf : \u03b1 \u2192 F \u03b2\nx\u271d : t \u03b1\n\u22a2 traverse ((fun {\u03b1} => \u03b7.app \u03b1) \u2218 f) x\u271d = ((fun {\u03b1} => \u03b7.app \u03b1) \u2218 traverse f) x\u271d"}, {"line": "rw [comp_apply]", "tactic_state": "case h\nt : Type u \u2192 Type u\ninst\u271d\u2075 : Traversable t\ninst\u271d\u2074 : LawfulTraversable t\nF G : Type u \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : LawfulApplicative F\ninst\u271d\u00b9 : Applicative G\ninst\u271d : LawfulApplicative G\n\u03b1 \u03b2 : Type u\n\u03b7 : ApplicativeTransformation F G\nf : \u03b1 \u2192 F \u03b2\nx\u271d : t \u03b1\n\u22a2 traverse ((fun {\u03b1} => \u03b7.app \u03b1) \u2218 f) x\u271d = (fun {\u03b1} => \u03b7.app \u03b1) (traverse f x\u271d)"}, {"line": "rw [naturality]", "tactic_state": "t : Type u \u2192 Type u\ninst\u271d\u2075 : Traversable t\ninst\u271d\u2074 : LawfulTraversable t\nF G : Type u \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : LawfulApplicative F\ninst\u271d\u00b9 : Applicative G\ninst\u271d : LawfulApplicative G\n\u03b1 \u03b2 : Type u\n\u03b7 : ApplicativeTransformation F G\nf : \u03b1 \u2192 F \u03b2\nx\u271d : t \u03b1\n\u22a2 LawfulTraversable t\n---\nt : Type u \u2192 Type u\ninst\u271d\u2075 : Traversable t\ninst\u271d\u2074 : LawfulTraversable t\nF G : Type u \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : LawfulApplicative F\ninst\u271d\u00b9 : Applicative G\ninst\u271d : LawfulApplicative G\n\u03b1 \u03b2 : Type u\n\u03b7 : ApplicativeTransformation F G\nf : \u03b1 \u2192 F \u03b2\nx\u271d : t \u03b1\n\u22a2 LawfulApplicative F\n---\nt : Type u \u2192 Type u\ninst\u271d\u2075 : Traversable t\ninst\u271d\u2074 : LawfulTraversable t\nF G : Type u \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : LawfulApplicative F\ninst\u271d\u00b9 : Applicative G\ninst\u271d : LawfulApplicative G\n\u03b1 \u03b2 : Type u\n\u03b7 : ApplicativeTransformation F G\nf : \u03b1 \u2192 F \u03b2\nx\u271d : t \u03b1\n\u22a2 LawfulApplicative G"}]}
{"declaration": "theorem map_out {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} (a : Erased \u03b1) : (a.map f).out = f a.out := by simp [map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Erased.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\na : Erased \u03b1\n\u22a2 (Erased.map f a).out = f a.out"}, {"line": "simp [map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFin_intCast (z : \u2124) : toFin (z : BitVec w) = z := by\n  apply toFin_inj.mpr <| (ofFin_intCast z).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/BitVec.lean", "context": {"open": [], "variables": ["{w : Nat}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoFin : x\u271d\nz : \u2124\n\u22a2 sorry = z"}, {"line": "apply toFin_inj.mpr <| (ofFin_intCast z).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TotalSpace.mk_inj {b : B} {y y' : E b} : mk' F b y = mk' F b y' \u2194 y = y' := by\n  simp [TotalSpace.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bundle.lean", "context": {"open": ["Function Set"], "variables": ["{B F : Type*} (E : B \u2192 Type*)", "{E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_1\nE : B \u2192 Type u_3\nx\u271d : Sort u_4\nmk' : x\u271d\nb : B\ny y' : E b\n\u22a2 sorry = sorry \u2194 y = y'"}, {"line": "simp [TotalSpace.ext_iff]", "tactic_state": "B : Type u_1\nE : B \u2192 Type u_3\nx\u271d : Sort u_4\nmk' : x\u271d\nb : B\ny y' : E b\n\u22a2 sorry () = sorry () \u2194 y = y'"}]}
{"declaration": "theorem TotalSpace.range_mk (b : B) : range ((\u2191) : E b \u2192 TotalSpace F E) = \u03c0 F E \u207b\u00b9' {b} := by\n  apply Subset.antisymm\n  \u00b7 rintro _ \u27e8x, rfl\u27e9\n    rfl\n  \u00b7 rintro \u27e8_, x\u27e9 rfl\n    exact \u27e8x, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bundle.lean", "context": {"open": ["Function Set"], "variables": ["{B F : Type*} (E : B \u2192 Type*)", "{E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_1\nE : B \u2192 Type u_3\nx\u271d\u00b9 : Sort u_4\nTotalSpace : x\u271d\u00b9\nx\u271d : Sort u_5\n\u03c0 : x\u271d\nb : B\n\u22a2 range sorry = sorry \u207b\u00b9' {b}"}, {"line": "apply Subset.antisymm", "tactic_state": "case h\u2081\nB : Type u_1\nE : B \u2192 Type u_3\nx\u271d\u00b9 : Sort u_4\nTotalSpace : x\u271d\u00b9\nx\u271d : Sort u_5\n\u03c0 : x\u271d\nb : B\n\u22a2 range sorry \u2286 sorry \u207b\u00b9' {b}\n---\ncase h\u2082\nB : Type u_1\nE : B \u2192 Type u_3\nx\u271d\u00b9 : Sort u_4\nTotalSpace : x\u271d\u00b9\nx\u271d : Sort u_5\n\u03c0 : x\u271d\nb : B\n\u22a2 sorry \u207b\u00b9' {b} \u2286 range sorry"}, {"line": "\u00b7 rintro _ \u27e8x, rfl\u27e9\n    rfl", "tactic_state": "case h\u2082\nB : Type u_1\nE : B \u2192 Type u_3\nx\u271d\u00b9 : Sort u_4\nTotalSpace : x\u271d\u00b9\nx\u271d : Sort u_5\n\u03c0 : x\u271d\nb : B\n\u22a2 sorry \u207b\u00b9' {b} \u2286 range sorry"}, {"line": "\u00b7 rintro \u27e8_, x\u27e9 rfl\n    exact \u27e8x, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AList.toFinmap_eq {s\u2081 s\u2082 : AList \u03b2} :\n    toFinmap s\u2081 = toFinmap s\u2082 \u2194 s\u2081.entries ~ s\u2082.entries := by\n  cases s\u2081\n  cases s\u2082\n  simp [AList.toFinmap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finmap.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ns\u2081 s\u2082 : AList \u03b2\n\u22a2 s\u2081.toFinmap = s\u2082.toFinmap \u2194 s\u2081.entries.Perm s\u2082.entries"}, {"line": "cases s\u2081", "tactic_state": "case mk\n\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ns\u2082 : AList \u03b2\nentries\u271d : List (Sigma \u03b2)\nnodupKeys\u271d : entries\u271d.NodupKeys\n\u22a2 { entries := entries\u271d, nodupKeys := nodupKeys\u271d }.toFinmap = s\u2082.toFinmap \u2194\n    { entries := entries\u271d, nodupKeys := nodupKeys\u271d }.entries.Perm s\u2082.entries"}, {"line": "cases s\u2082", "tactic_state": "case mk.mk\n\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\nentries\u271d\u00b9 : List (Sigma \u03b2)\nnodupKeys\u271d\u00b9 : entries\u271d\u00b9.NodupKeys\nentries\u271d : List (Sigma \u03b2)\nnodupKeys\u271d : entries\u271d.NodupKeys\n\u22a2 { entries := entries\u271d\u00b9, nodupKeys := nodupKeys\u271d\u00b9 }.toFinmap =\n      { entries := entries\u271d, nodupKeys := nodupKeys\u271d }.toFinmap \u2194\n    { entries := entries\u271d\u00b9, nodupKeys := nodupKeys\u271d\u00b9 }.entries.Perm\n      { entries := entries\u271d, nodupKeys := nodupKeys\u271d }.entries"}, {"line": "simp [AList.toFinmap]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem keys_ext {s\u2081 s\u2082 : AList \u03b2} : keys \u27e6s\u2081\u27e7 = keys \u27e6s\u2082\u27e7 \u2194 s\u2081.keys ~ s\u2082.keys := by\n  simp [keys, AList.keys]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finmap.lean", "context": {"open": ["List", "AList"], "variables": ["{\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ns\u2081 s\u2082 : AList \u03b2\n\u22a2 sorry = sorry \u2194 s\u2081.keys.Perm s\u2082.keys"}, {"line": "simp [keys, AList.keys]", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ns\u2081 s\u2082 : AList \u03b2\n\u22a2 s\u2081.entries.keys.Perm s\u2082.entries.keys"}]}
{"declaration": "theorem replace_toFinmap (a : \u03b1) (b : \u03b2 a) (s : AList \u03b2) :\n    replace a b \u27e6s\u27e7 = (\u27e6s.replace a b\u27e7 : Finmap \u03b2) := by\n  simp [replace]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finmap.lean", "context": {"open": ["List", "AList"], "variables": ["{\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nb : \u03b2 a\ns : AList \u03b2\n\u22a2 sorry = sorry"}, {"line": "simp [replace]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem keys_erase_toFinset (a : \u03b1) (s : AList \u03b2) : keys \u27e6s.erase a\u27e7 = (keys \u27e6s\u27e7).erase a := by\n  simp [Finset.erase, keys, AList.erase, keys_kerase]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finmap.lean", "context": {"open": ["List", "AList"], "variables": ["{\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\na : \u03b1\ns : AList \u03b2\n\u22a2 sorry = sorry"}, {"line": "simp [Finset.erase, keys, AList.erase, keys_kerase]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem insert_toFinmap (a : \u03b1) (b : \u03b2 a) (s : AList \u03b2) :\n    insert a b (AList.toFinmap s) = AList.toFinmap (s.insert a b) := by\n  simp [insert]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finmap.lean", "context": {"open": ["List", "AList"], "variables": ["{\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\na : \u03b1\nb : \u03b2 a\ns : AList \u03b2\n\u22a2 sorry = (AList.insert a b s).toFinmap"}, {"line": "simp [insert]", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\na : \u03b1\nb : \u03b2 a\ns : AList \u03b2\n\u22a2 sorry () = (AList.insert a b s).toFinmap"}]}
{"declaration": "theorem union_toFinmap (s\u2081 s\u2082 : AList \u03b2) : (toFinmap s\u2081) \u222a (toFinmap s\u2082) = toFinmap (s\u2081 \u222a s\u2082) := by\n  simp [(\u00b7 \u222a \u00b7), union]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finmap.lean", "context": {"open": ["List", "AList"], "variables": ["{\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : AList \u03b2\n\u22a2 s\u2081.toFinmap \u222a s\u2082.toFinmap = (s\u2081 \u222a s\u2082).toFinmap"}, {"line": "simp [(\u00b7 \u222a \u00b7), union]", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : AList \u03b2\n\u22a2 s\u2081.toFinmap.union s\u2082.toFinmap = { entries := s\u2081.entries.kunion s\u2082.entries, nodupKeys := \u22ef }.toFinmap"}]}
{"declaration": "theorem disjoint_union_left (x y z : Finmap \u03b2) :\n    Disjoint (x \u222a y) z \u2194 Disjoint x z \u2227 Disjoint y z := by\n  simp [Disjoint, Finmap.mem_union, or_imp, forall_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finmap.lean", "context": {"open": ["List", "AList"], "variables": ["{\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nx y z : Finmap \u03b2\n\u22a2 sorry \u2194 sorry \u2227 sorry"}, {"line": "simp [Disjoint, Finmap.mem_union, or_imp, forall_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_assoc [Semigroup \u03b1] (x : Holor \u03b1 ds\u2081) (y : Holor \u03b1 ds\u2082) (z : Holor \u03b1 ds\u2083) :\n    HEq (mul (mul x y) z) (mul x (mul y z)) := by simp [cast_heq, mul_assoc0, assocLeft]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Holor.lean", "context": {"open": ["List"], "variables": ["{ds\u2081 ds\u2082 ds\u2083 : List \u2115}", "{\u03b1 : Type} {d : \u2115} {ds : List \u2115} {ds\u2081 : List \u2115} {ds\u2082 : List \u2115} {ds\u2083 : List \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\nds\u2081 ds\u2082 ds\u2083 : List \u2115\nx\u271d : Sort u_1\nmul : x\u271d\ninst\u271d : Semigroup \u03b1\nx : Holor \u03b1 ds\u2081\ny : Holor \u03b1 ds\u2082\nz : Holor \u03b1 ds\u2083\n\u22a2 HEq sorry sorry"}, {"line": "simp [cast_heq, mul_assoc0, assocLeft]", "tactic_state": "\u03b1 : Type\nds\u2081 ds\u2082 ds\u2083 : List \u2115\nx\u271d : Sort u_1\nmul : x\u271d\ninst\u271d : Semigroup \u03b1\nx : Holor \u03b1 ds\u2081\ny : Holor \u03b1 ds\u2082\nz : Holor \u03b1 ds\u2083\n\u22a2 HEq (sorry ()) (sorry ())"}]}
{"declaration": "theorem mem_dom (f : \u03b1 \u2192. \u03b2) (x : \u03b1) : x \u2208 Dom f \u2194 \u2203 y, y \u2208 f x := by simp [Dom, Part.dom_iff_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PFun.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_7\nDom : x\u271d\nf : \u03b1 \u2192. \u03b2\nx : \u03b1\n\u22a2 x \u2208 sorry \u2194 \u2203 y, y \u2208 f x"}, {"line": "simp [Dom, Part.dom_iff_mem]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_7\nDom : x\u271d\nf : \u03b1 \u2192. \u03b2\nx : \u03b1\n\u22a2 x \u2208 sorry () \u2194 \u2203 y, y \u2208 f x"}]}
{"declaration": "theorem mem_restrict {f : \u03b1 \u2192. \u03b2} {s : Set \u03b1} (h : s \u2286 f.Dom) (a : \u03b1) (b : \u03b2) :\n    b \u2208 f.restrict h a \u2194 a \u2208 s \u2227 b \u2208 f a := by simp [restrict]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PFun.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192. \u03b2\ns : Set \u03b1\nh : s \u2286 f.Dom\na : \u03b1\nb : \u03b2\n\u22a2 b \u2208 f.restrict h a \u2194 a \u2208 s \u2227 b \u2208 f a"}, {"line": "simp [restrict]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_res (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (a : \u03b1) (b : \u03b2) : b \u2208 res f s a \u2194 a \u2208 s \u2227 f a = b := by\n  simp [res, @eq_comm _ b]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PFun.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_7\nres : x\u271d\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na : \u03b1\nb : \u03b2\n\u22a2 b \u2208 sorry \u2194 a \u2208 s \u2227 f a = b"}, {"line": "simp [res, @eq_comm _ b]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_7\nres : x\u271d\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na : \u03b1\nb : \u03b2\n\u22a2 b \u2208 sorry () \u2194 a \u2208 s \u2227 f a = b"}]}
{"declaration": "theorem fix_stop {f : \u03b1 \u2192. \u03b2 \u2295 \u03b1} {b : \u03b2} {a : \u03b1} (hb : Sum.inl b \u2208 f a) : b \u2208 f.fix a := by\n  rw [PFun.mem_fix_iff]\n  exact Or.inl hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PFun.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192. \u03b2 \u2295 \u03b1\nb : \u03b2\na : \u03b1\nhb : Sum.inl b \u2208 f a\n\u22a2 b \u2208 f.fix a"}, {"line": "rw [PFun.mem_fix_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192. \u03b2 \u2295 \u03b1\nb : \u03b2\na : \u03b1\nhb : Sum.inl b \u2208 f a\n\u22a2 Sum.inl b \u2208 f a \u2228 \u2203 a', Sum.inr a' \u2208 f a \u2227 b \u2208 f.fix a'"}, {"line": "exact Or.inl hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_prodLift {f : \u03b1 \u2192. \u03b2} {g : \u03b1 \u2192. \u03b3} {x : \u03b1} {y : \u03b2 \u00d7 \u03b3} :\n    y \u2208 f.prodLift g x \u2194 y.1 \u2208 f x \u2227 y.2 \u2208 g x := by\n  trans \u2203 hp hq, (f x).get hp = y.1 \u2227 (g x).get hq = y.2\n  \u00b7 simp only [prodLift, Part.mem_mk_iff, And.exists, Prod.ext_iff]\n  \u00b7 simp only [exists_and_left, exists_and_right, Membership.mem, Part.Mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PFun.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b9 : Type*}", "(f : \u03b1 \u2192. \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192. \u03b2\ng : \u03b1 \u2192. \u03b3\nx : \u03b1\ny : \u03b2 \u00d7 \u03b3\n\u22a2 y \u2208 f.prodLift g x \u2194 y.1 \u2208 f x \u2227 y.2 \u2208 g x"}, {"line": "trans \u2203 hp hq, (f x).get hp = y.1 \u2227 (g x).get hq = y.2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192. \u03b2\ng : \u03b1 \u2192. \u03b3\nx : \u03b1\ny : \u03b2 \u00d7 \u03b3\n\u22a2 y \u2208 f.prodLift g x \u2194 \u2203 (hp : (f x).Dom) (hq : (g x).Dom), (f x).get hp = y.1 \u2227 (g x).get hq = y.2\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192. \u03b2\ng : \u03b1 \u2192. \u03b3\nx : \u03b1\ny : \u03b2 \u00d7 \u03b3\n\u22a2 (\u2203 (hp : (f x).Dom) (hq : (g x).Dom), (f x).get hp = y.1 \u2227 (g x).get hq = y.2) \u2194 y.1 \u2208 f x \u2227 y.2 \u2208 g x"}, {"line": "\u00b7 simp only [prodLift, Part.mem_mk_iff, And.exists, Prod.ext_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192. \u03b2\ng : \u03b1 \u2192. \u03b3\nx : \u03b1\ny : \u03b2 \u00d7 \u03b3\n\u22a2 (\u2203 (hp : (f x).Dom) (hq : (g x).Dom), (f x).get hp = y.1 \u2227 (g x).get hq = y.2) \u2194 y.1 \u2208 f x \u2227 y.2 \u2208 g x"}, {"line": "\u00b7 simp only [exists_and_left, exists_and_right, Membership.mem, Part.Mem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_prodMap {f : \u03b1 \u2192. \u03b3} {g : \u03b2 \u2192. \u03b4} {x : \u03b1 \u00d7 \u03b2} {y : \u03b3 \u00d7 \u03b4} :\n    y \u2208 f.prodMap g x \u2194 y.1 \u2208 f x.1 \u2227 y.2 \u2208 g x.2 := by\n  trans \u2203 hp hq, (f x.1).get hp = y.1 \u2227 (g x.2).get hq = y.2\n  \u00b7 simp only [prodMap, Part.mem_mk_iff, And.exists, Prod.ext_iff]\n  \u00b7 simp only [exists_and_left, exists_and_right, Membership.mem, Part.Mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PFun.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b9 : Type*}", "(f : \u03b1 \u2192. \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192. \u03b3\ng : \u03b2 \u2192. \u03b4\nx : \u03b1 \u00d7 \u03b2\ny : \u03b3 \u00d7 \u03b4\n\u22a2 y \u2208 f.prodMap g x \u2194 y.1 \u2208 f x.1 \u2227 y.2 \u2208 g x.2"}, {"line": "trans \u2203 hp hq, (f x.1).get hp = y.1 \u2227 (g x.2).get hq = y.2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192. \u03b3\ng : \u03b2 \u2192. \u03b4\nx : \u03b1 \u00d7 \u03b2\ny : \u03b3 \u00d7 \u03b4\n\u22a2 y \u2208 f.prodMap g x \u2194 \u2203 (hp : (f x.1).Dom) (hq : (g x.2).Dom), (f x.1).get hp = y.1 \u2227 (g x.2).get hq = y.2\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192. \u03b3\ng : \u03b2 \u2192. \u03b4\nx : \u03b1 \u00d7 \u03b2\ny : \u03b3 \u00d7 \u03b4\n\u22a2 (\u2203 (hp : (f x.1).Dom) (hq : (g x.2).Dom), (f x.1).get hp = y.1 \u2227 (g x.2).get hq = y.2) \u2194 y.1 \u2208 f x.1 \u2227 y.2 \u2208 g x.2"}, {"line": "\u00b7 simp only [prodMap, Part.mem_mk_iff, And.exists, Prod.ext_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192. \u03b3\ng : \u03b2 \u2192. \u03b4\nx : \u03b1 \u00d7 \u03b2\ny : \u03b3 \u00d7 \u03b4\n\u22a2 (\u2203 (hp : (f x.1).Dom) (hq : (g x.2).Dom), (f x.1).get hp = y.1 \u2227 (g x.2).get hq = y.2) \u2194 y.1 \u2208 f x.1 \u2227 y.2 \u2208 g x.2"}, {"line": "\u00b7 simp only [exists_and_left, exists_and_right, Membership.mem, Part.Mem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prodMap_id_id : (PFun.id \u03b1).prodMap (PFun.id \u03b2) = PFun.id _ := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PFun.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b9 : Type*}", "(f : \u03b1 \u2192. \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 (PFun.id \u03b1).prodMap (PFun.id \u03b2) = PFun.id (\u03b1 \u00d7 \u03b2)"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem some_ne_none (x : \u03b1) : some x \u2260 none := by\n  intro h\n  exact true_ne_false (congr_arg Dom h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Part.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\n\u22a2 some x \u2260 none"}, {"line": "intro h", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\nh : some x = none\n\u22a2 False"}, {"line": "exact true_ne_false (congr_arg Dom h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem get_eq_get_of_eq (a : Part \u03b1) (ha : a.Dom) {b : Part \u03b1} (h : a = b) :\n    a.get ha = b.get (h \u25b8 ha) := by\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Part.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : Part \u03b1\nha : a.Dom\nb : Part \u03b1\nh : a = b\n\u22a2 a.get ha = b.get \u22ef"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_map (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) (o : Part \u03b1) : map g (map f o) = map (g \u2218 f) o := by\n  simp [map, Function.comp_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Part.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx\u271d : Sort u_4\nmap : x\u271d\ng : \u03b2 \u2192 \u03b3\nf : \u03b1 \u2192 \u03b2\no : Part \u03b1\n\u22a2 sorry = sorry"}, {"line": "simp [map, Function.comp_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem some_mul_some [Mul \u03b1] (a b : \u03b1) : some a * some b = some (a * b) := by simp [mul_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Part.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Mul \u03b1\na b : \u03b1\n\u22a2 sorry"}, {"line": "simp [mul_def]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Mul \u03b1\na b : \u03b1\n\u22a2 sorry ()"}]}
{"declaration": "theorem some_div_some [Div \u03b1] (a b : \u03b1) : some a / some b = some (a / b) := by simp [div_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Part.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Div \u03b1\na b : \u03b1\n\u22a2 sorry"}, {"line": "simp [div_def]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Div \u03b1\na b : \u03b1\n\u22a2 sorry ()"}]}
{"declaration": "theorem some_mod_some [Mod \u03b1] (a b : \u03b1) : some a % some b = some (a % b) := by simp [mod_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Part.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Mod \u03b1\na b : \u03b1\n\u22a2 sorry"}, {"line": "simp [mod_def]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Mod \u03b1\na b : \u03b1\n\u22a2 sorry ()"}]}
{"declaration": "theorem some_append_some [Append \u03b1] (a b : \u03b1) : some a ++ some b = some (a ++ b) := by\n  simp [append_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Part.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Append \u03b1\na b : \u03b1\n\u22a2 sorry"}, {"line": "simp [append_def]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Append \u03b1\na b : \u03b1\n\u22a2 sorry ()"}]}
{"declaration": "theorem some_inter_some [Inter \u03b1] (a b : \u03b1) : some a \u2229 some b = some (a \u2229 b) := by\n  simp [inter_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Part.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Inter \u03b1\na b : \u03b1\n\u22a2 sorry = some (a \u2229 b)"}, {"line": "simp [inter_def]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Inter \u03b1\na b : \u03b1\n\u22a2 sorry () = some (a \u2229 b)"}]}
{"declaration": "theorem some_union_some [Union \u03b1] (a b : \u03b1) : some a \u222a some b = some (a \u222a b) := by simp [union_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Part.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Union \u03b1\na b : \u03b1\n\u22a2 sorry = some (a \u222a b)"}, {"line": "simp [union_def]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Union \u03b1\na b : \u03b1\n\u22a2 sorry () = some (a \u222a b)"}]}
{"declaration": "theorem some_sdiff_some [SDiff \u03b1] (a b : \u03b1) : some a \\ some b = some (a \\ b) := by simp [sdiff_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Part.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : SDiff \u03b1\na b : \u03b1\n\u22a2 sorry = some (a \\ b)"}, {"line": "simp [sdiff_def]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : SDiff \u03b1\na b : \u03b1\n\u22a2 sorry () = some (a \\ b)"}]}
{"declaration": "theorem Quotient.eq_mk_iff_out {s : Setoid \u03b1} {x : Quotient s} {y : \u03b1} :\n    x = \u27e6y\u27e7 \u2194 Quotient.out x \u2248 y := by\n  refine Iff.trans ?_ Quotient.eq\n  rw [Quotient.out_eq x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Quot.lean", "context": {"open": [], "variables": ["{\u03b1 : Sort*} {\u03b2 : Sort*}", "{ra : \u03b1 \u2192 \u03b1 \u2192 Prop} {rb : \u03b2 \u2192 \u03b2 \u2192 Prop} {\u03c6 : Quot ra \u2192 Quot rb \u2192 Sort*}", "{\u03b3 : Sort*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{t : \u03b3 \u2192 \u03b3 \u2192 Prop}", "{sa : Setoid \u03b1} {sb : Setoid \u03b2}", "{\u03c6 : Quotient sa \u2192 Quotient sb \u2192 Sort*}", "{\u03b3 : Sort*} {sc : Setoid \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\ns : Setoid \u03b1\nx : Quotient s\ny : \u03b1\n\u22a2 x = \u27e6y\u27e7 \u2194 x.out \u2248 y"}, {"line": "refine Iff.trans ?_ Quotient.eq", "tactic_state": "\u03b1 : Sort u_1\ns : Setoid \u03b1\nx : Quotient s\ny : \u03b1\n\u22a2 x = \u27e6y\u27e7 \u2194 \u27e6x.out\u27e7 = \u27e6y\u27e7"}, {"line": "rw [Quotient.out_eq x]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Quotient.out_equiv_out {s : Setoid \u03b1} {x y : Quotient s} : x.out \u2248 y.out \u2194 x = y := by\n  rw [\u2190 Quotient.eq_mk_iff_out]\n  rw [Quotient.out_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Quot.lean", "context": {"open": [], "variables": ["{\u03b1 : Sort*} {\u03b2 : Sort*}", "{ra : \u03b1 \u2192 \u03b1 \u2192 Prop} {rb : \u03b2 \u2192 \u03b2 \u2192 Prop} {\u03c6 : Quot ra \u2192 Quot rb \u2192 Sort*}", "{\u03b3 : Sort*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{t : \u03b3 \u2192 \u03b3 \u2192 Prop}", "{sa : Setoid \u03b1} {sb : Setoid \u03b2}", "{\u03c6 : Quotient sa \u2192 Quotient sb \u2192 Sort*}", "{\u03b3 : Sort*} {sc : Setoid \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\ns : Setoid \u03b1\nx y : Quotient s\n\u22a2 x.out \u2248 y.out \u2194 x = y"}, {"line": "rw [\u2190 Quotient.eq_mk_iff_out]", "tactic_state": "\u03b1 : Sort u_1\ns : Setoid \u03b1\nx y : Quotient s\n\u22a2 x = \u27e6y.out\u27e7 \u2194 x = y"}, {"line": "rw [Quotient.out_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Quotient.induction_on_pi {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Sort*} {s : \u2200 i, Setoid (\u03b1 i)}\n    {p : (\u2200 i, Quotient (s i)) \u2192 Prop} (f : \u2200 i, Quotient (s i))\n    (h : \u2200 a : \u2200 i, \u03b1 i, p fun i \u21a6 \u27e6a i\u27e7) : p f := by\n  rw [\u2190 (funext fun i \u21a6 Quotient.out_eq (f i) : (fun i \u21a6 \u27e6(f i).out\u27e7) = f)]\n  apply h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Quot.lean", "context": {"open": [], "variables": ["{\u03b1 : Sort*} {\u03b2 : Sort*}", "{ra : \u03b1 \u2192 \u03b1 \u2192 Prop} {rb : \u03b2 \u2192 \u03b2 \u2192 Prop} {\u03c6 : Quot ra \u2192 Quot rb \u2192 Sort*}", "{\u03b3 : Sort*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{t : \u03b3 \u2192 \u03b3 \u2192 Prop}", "{sa : Setoid \u03b1} {sb : Setoid \u03b2}", "{\u03c6 : Quotient sa \u2192 Quotient sb \u2192 Sort*}", "{\u03b3 : Sort*} {sc : Setoid \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Sort u_8\ns : (i : \u03b9) \u2192 Setoid (\u03b1 i)\np : ((i : \u03b9) \u2192 Quotient (s i)) \u2192 Prop\nf : (i : \u03b9) \u2192 Quotient (s i)\nh : \u2200 (a : (i : \u03b9) \u2192 \u03b1 i), p fun i => \u27e6a i\u27e7\n\u22a2 p f"}, {"line": "rw [\u2190 (funext fun i \u21a6 Quotient.out_eq (f i) : (fun i \u21a6 \u27e6(f i).out\u27e7) = f)]", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Sort u_8\ns : (i : \u03b9) \u2192 Setoid (\u03b1 i)\np : ((i : \u03b9) \u2192 Quotient (s i)) \u2192 Prop\nf : (i : \u03b9) \u2192 Quotient (s i)\nh : \u2200 (a : (i : \u03b9) \u2192 \u03b1 i), p fun i => \u27e6a i\u27e7\n\u22a2 p fun i => \u27e6(f i).out\u27e7"}, {"line": "apply h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem codom_inv : r.inv.codom = r.dom := by\n  ext x\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rel.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(r : Rel \u03b1 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : Rel \u03b1 \u03b2\n\u22a2 r.inv.codom = r.dom"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : Rel \u03b1 \u03b2\nx : \u03b1\n\u22a2 x \u2208 r.inv.codom \u2194 x \u2208 r.dom"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dom_inv : r.inv.dom = r.codom := by\n  ext x\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rel.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(r : Rel \u03b1 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : Rel \u03b1 \u03b2\n\u22a2 r.inv.dom = r.codom"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : Rel \u03b1 \u03b2\nx : \u03b2\n\u22a2 x \u2208 r.inv.dom \u2194 x \u2208 r.codom"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_bot : (\u22a5 : Rel \u03b1 \u03b2).inv = (\u22a5 : Rel \u03b2 \u03b1) := by\n  simp [Bot.bot, inv, Function.flip_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rel.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(r : Rel \u03b1 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 \u22a5.inv = \u22a5"}, {"line": "simp [Bot.bot, inv, Function.flip_def]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 (Rel.inv fun x x => False) = fun x x => False"}]}
{"declaration": "theorem inv_top : (\u22a4 : Rel \u03b1 \u03b2).inv = (\u22a4 : Rel \u03b2 \u03b1) := by\n  simp [Top.top, inv, Function.flip_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rel.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(r : Rel \u03b1 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 \u22a4.inv = \u22a4"}, {"line": "simp [Top.top, inv, Function.flip_def]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 (Rel.inv fun x x => True) = fun x x => True"}]}
{"declaration": "theorem image_id (s : Set \u03b1) : image (@Eq \u03b1) s = s := by\n  ext x\n  simp [mem_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rel.lean", "context": {"open": ["scoped Relator in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(r : Rel \u03b1 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nx\u271d : Sort u_1\nimage : x\u271d\ns : Set \u03b1\n\u22a2 sorry = s"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_2\nx\u271d : Sort u_1\nimage : x\u271d\ns : Set \u03b1\nx : \u03b1\n\u22a2 x \u2208 sorry \u2194 x \u2208 s"}, {"line": "simp [mem_image]", "tactic_state": "case h\n\u03b1 : Type u_2\nx\u271d : Sort u_1\nimage : x\u271d\ns : Set \u03b1\nx : \u03b1\n\u22a2 x \u2208 sorry () \u2194 x \u2208 s"}]}
{"declaration": "theorem image_empty : r.image \u2205 = \u2205 := by\n  ext x\n  simp [mem_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rel.lean", "context": {"open": ["scoped Relator in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(r : Rel \u03b1 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nr : Rel \u03b1 \u03b2\n\u22a2 r.image \u2205 = \u2205"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_2\n\u03b2 : Type u_1\nr : Rel \u03b1 \u03b2\nx : \u03b2\n\u22a2 x \u2208 r.image \u2205 \u2194 x \u2208 \u2205"}, {"line": "simp [mem_image]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_bot (s : Set \u03b1) : (\u22a5 : Rel \u03b1 \u03b2).image s = \u2205 := by\n  rw [Set.eq_empty_iff_forall_not_mem]\n  intro x h\n  simp [mem_image, Bot.bot] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rel.lean", "context": {"open": ["scoped Relator in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(r : Rel \u03b1 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\n\u22a2 \u22a5.image s = \u2205"}, {"line": "rw [Set.eq_empty_iff_forall_not_mem]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\n\u22a2 \u2200 (x : \u03b2), x \u2209 \u22a5.image s"}, {"line": "intro x h", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nx : \u03b2\nh : x \u2208 \u22a5.image s\n\u22a2 False"}, {"line": "simp [mem_image, Bot.bot] at h", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nx : \u03b2\nh : x \u2208 Rel.image (fun x x => False) s\n\u22a2 False"}]}
{"declaration": "theorem preimage_eq_codom_of_domain_subset {s : Set \u03b1} (h : r.dom \u2286 s) : r.image s = r.codom := by\n  apply r.inv.image_eq_dom_of_codomain_subset (by rwa [\u2190 codom_inv] at h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rel.lean", "context": {"open": ["scoped Relator in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(r : Rel \u03b1 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\nh : r.dom \u2286 s\n\u22a2 r.image s = r.codom"}, {"line": "apply r.inv.image_eq_dom_of_codomain_subset (by rwa [\u2190 codom_inv] at h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem core_id (s : Set \u03b1) : core (@Eq \u03b1) s = s := by simp [core]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rel.lean", "context": {"open": ["scoped Relator in", "scoped Relator in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(r : Rel \u03b1 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nx\u271d : Sort u_1\ncore : x\u271d\ns : Set \u03b1\n\u22a2 sorry = s"}, {"line": "simp [core]", "tactic_state": "\u03b1 : Type u_2\nx\u271d : Sort u_1\ncore : x\u271d\ns : Set \u03b1\n\u22a2 sorry () = s"}]}
{"declaration": "theorem Equiv.graph_inv (f : \u03b1 \u2243 \u03b2) : (f.symm : \u03b2 \u2192 \u03b1).graph = Rel.inv (f : \u03b1 \u2192 \u03b2).graph := by\n  ext x y\n  aesop (add norm Rel.inv_def)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rel.lean", "context": {"open": ["scoped Relator in", "scoped Relator in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(r : Rel \u03b1 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2243 \u03b2\n\u22a2 Function.graph \u21d1f.symm = (Function.graph \u21d1f).inv"}, {"line": "ext x y", "tactic_state": "case a.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2243 \u03b2\nx : \u03b2\ny : \u03b1\n\u22a2 Function.graph (\u21d1f.symm) x y \u2194 (Function.graph \u21d1f).inv x y"}, {"line": "aesop (add norm Rel.inv_def)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_eq (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : f '' s = (Function.graph f).image s := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rel.lean", "context": {"open": ["scoped Relator in", "scoped Relator in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(r : Rel \u03b1 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 f '' s = (Function.graph f).image s"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_eq (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2) : f \u207b\u00b9' s = (Function.graph f).preimage s := by\n  simp [Set.preimage, Rel.preimage, Rel.inv, flip, Rel.image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rel.lean", "context": {"open": ["scoped Relator in", "scoped Relator in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(r : Rel \u03b1 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 f \u207b\u00b9' s = (Function.graph f).preimage s"}, {"line": "simp [Set.preimage, Rel.preimage, Rel.inv, flip, Rel.image]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_eq_core (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2) : f \u207b\u00b9' s = (Function.graph f).core s := by\n  simp [Set.preimage, Rel.core]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rel.lean", "context": {"open": ["scoped Relator in", "scoped Relator in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(r : Rel \u03b1 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 f \u207b\u00b9' s = (Function.graph f).core s"}, {"line": "simp [Set.preimage, Rel.core]", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma mul_comm : \u2200 (a b : SignType), a * b = b * a := by rintro \u27e8\u27e9 \u27e8\u27e9 <;> rfl", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (a b : SignType), a * b = b * a"}, {"line": "rintro \u27e8\u27e9 \u27e8\u27e9 <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma mul_assoc : \u2200 (a b c : SignType), (a * b) * c = a * (b * c) := by\n  rintro \u27e8\u27e9 \u27e8\u27e9 \u27e8\u27e9 <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (a b c : SignType), a * b * c = a * (b * c)"}, {"line": "rintro \u27e8\u27e9 \u27e8\u27e9 \u27e8\u27e9 <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma le_antisymm (a b : SignType) (_ : a \u2264 b) (_ : b \u2264 a) : a = b := by\n  cases a <;> cases b <;> trivial\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : SignType\nx\u271d\u00b9 : a \u2264 b\nx\u271d : b \u2264 a\n\u22a2 a = b"}, {"line": "cases a <;> cases b <;> trivial", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma le_trans (a b c : SignType) (_ : a \u2264 b) (_ : b \u2264 c) : a \u2264 c := by\n  cases a <;> cases b <;> cases c <;> tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : SignType\nx\u271d\u00b9 : a \u2264 b\nx\u271d : b \u2264 c\n\u22a2 a \u2264 c"}, {"line": "cases a <;> cases b <;> cases c <;> tauto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonneg_iff {a : SignType} : 0 \u2264 a \u2194 a = 0 \u2228 a = 1 := by decide +revert\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : SignType\n\u22a2 0 \u2264 a \u2194 a = 0 \u2228 a = 1"}, {"line": "decide +revert", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonneg_iff_ne_neg_one {a : SignType} : 0 \u2264 a \u2194 a \u2260 -1 := by decide +revert\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : SignType\n\u22a2 0 \u2264 a \u2194 a \u2260 -1"}, {"line": "decide +revert", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_one_lt_iff {a : SignType} : -1 < a \u2194 0 \u2264 a := by decide +revert\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : SignType\n\u22a2 -1 < a \u2194 0 \u2264 a"}, {"line": "decide +revert", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonpos_iff {a : SignType} : a \u2264 0 \u2194 a = -1 \u2228 a = 0 := by decide +revert\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : SignType\n\u22a2 a \u2264 0 \u2194 a = -1 \u2228 a = 0"}, {"line": "decide +revert", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonpos_iff_ne_one {a : SignType} : a \u2264 0 \u2194 a \u2260 1 := by decide +revert\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : SignType\n\u22a2 a \u2264 0 \u2194 a \u2260 1"}, {"line": "decide +revert", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_one_iff {a : SignType} : a < 1 \u2194 a \u2264 0 := by decide +revert\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : SignType\n\u22a2 a < 1 \u2194 a \u2264 0"}, {"line": "decide +revert", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_iff {a : SignType} : a < 0 \u2194 a = -1 := by decide +revert\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : SignType\n\u22a2 a < 0 \u2194 a = -1"}, {"line": "decide +revert", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pos_iff {a : SignType} : 0 < a \u2194 a = 1 := by decide +revert\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : SignType\n\u22a2 0 < a \u2194 a = 1"}, {"line": "decide +revert", "tactic_state": "No Goals!"}]}
{"declaration": "theorem self_eq_neg_iff (a : SignType) : a = -a \u2194 a = 0 := by decide +revert\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : SignType\n\u22a2 a = -a \u2194 a = 0"}, {"line": "decide +revert", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_eq_self_iff (a : SignType) : -a = a \u2194 a = 0 := by decide +revert\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : SignType\n\u22a2 -a = a \u2194 a = 0"}, {"line": "decide +revert", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_cast' {\u03b2 : Type*} [One \u03b2] [Neg \u03b2] [Zero \u03b2]\n    (f : \u03b1 \u2192 \u03b2) (h\u2081 : f 1 = 1) (h\u2082 : f 0 = 0) (h\u2083 : f (-1) = -1) (s : SignType) :\n    f s = s := by\n  cases s <;> simp only [SignType.cast, h\u2081, h\u2082, h\u2083]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [Zero \u03b1] [One \u03b1] [Neg \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : One \u03b1\ninst\u271d\u00b3 : Neg \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : One \u03b2\ninst\u271d\u00b9 : Neg \u03b2\ninst\u271d : Zero \u03b2\nf : \u03b1 \u2192 \u03b2\nh\u2081 : f 1 = 1\nh\u2082 : f 0 = 0\nh\u2083 : f (-1) = -1\ns : SignType\n\u22a2 f \u2191s = \u2191s"}, {"line": "cases s <;> simp only [SignType.cast, h\u2081, h\u2082, h\u2083]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_cast {\u03b1 \u03b2 F : Type*} [AddGroupWithOne \u03b1] [One \u03b2] [SubtractionMonoid \u03b2]\n    [FunLike F \u03b1 \u03b2] [AddMonoidHomClass F \u03b1 \u03b2] [OneHomClass F \u03b1 \u03b2] (f : F) (s : SignType) :\n    f s = s := by\n  apply map_cast' <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [Zero \u03b1] [One \u03b1] [Neg \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\nF : Type u_4\ninst\u271d\u2075 : AddGroupWithOne \u03b1\ninst\u271d\u2074 : One \u03b2\ninst\u271d\u00b3 : SubtractionMonoid \u03b2\ninst\u271d\u00b2 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b9 : AddMonoidHomClass F \u03b1 \u03b2\ninst\u271d : OneHomClass F \u03b1 \u03b2\nf : F\ns : SignType\n\u22a2 f \u2191s = \u2191s"}, {"line": "apply map_cast' <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_neg {\u03b1 : Type*} [One \u03b1] [SubtractionMonoid \u03b1] (s : SignType) :\n    (\u2191(-s) : \u03b1) = -\u2191s := by\n  cases s <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [Zero \u03b1] [One \u03b1] [Neg \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : SubtractionMonoid \u03b1\ns : SignType\n\u22a2 \u2191(-s) = -\u2191s"}, {"line": "cases s <;> simp", "tactic_state": "case neg\n\u03b1 : Type u_2\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : SubtractionMonoid \u03b1\n\u22a2 1 = - -1"}]}
{"declaration": "theorem univ_eq : (Finset.univ : Finset SignType) = {0, -1, 1} := by\n  decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [Zero \u03b1] [One \u03b1] [Neg \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Finset.univ = {0, -1, 1}"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sign_zero : sign (0 : \u03b1) = 0 := by simp [sign_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": ["SignType"], "variables": ["{\u03b1 : Type*} [Zero \u03b1] [One \u03b1] [Neg \u03b1]", "{\u03b1 : Type u}", "[Zero \u03b1] [Preorder \u03b1] [DecidableLT \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableLT \u03b1\n\u22a2 sign 0 = 0"}, {"line": "simp [sign_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sign_pos (ha : 0 < a) : sign a = 1 := by rwa [sign_apply, if_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": ["SignType"], "variables": ["{\u03b1 : Type*} [Zero \u03b1] [One \u03b1] [Neg \u03b1]", "{\u03b1 : Type u}", "[Zero \u03b1] [Preorder \u03b1] [DecidableLT \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableLT \u03b1\na : \u03b1\nha : 0 < a\n\u22a2 sign a = 1"}, {"line": "rwa [sign_apply, if_pos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sign_neg (ha : a < 0) : sign a = -1 := by rwa [sign_apply, if_neg <| asymm ha, if_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": ["SignType"], "variables": ["{\u03b1 : Type*} [Zero \u03b1] [One \u03b1] [Neg \u03b1]", "{\u03b1 : Type u}", "[Zero \u03b1] [Preorder \u03b1] [DecidableLT \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableLT \u03b1\na : \u03b1\nha : a < 0\n\u22a2 sign a = -1"}, {"line": "rwa [sign_apply, if_neg <| asymm ha, if_pos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sign_eq_neg_one_iff : sign a = -1 \u2194 a < 0 := by\n  refine \u27e8fun h => ?_, fun h => sign_neg h\u27e9\n  rw [sign_apply] at h\n  split_ifs at h\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": ["SignType"], "variables": ["{\u03b1 : Type*} [Zero \u03b1] [One \u03b1] [Neg \u03b1]", "{\u03b1 : Type u}", "[Zero \u03b1] [Preorder \u03b1] [DecidableLT \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableLT \u03b1\na : \u03b1\n\u22a2 sign a = -1 \u2194 a < 0"}, {"line": "refine \u27e8fun h => ?_, fun h => sign_neg h\u27e9", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableLT \u03b1\na : \u03b1\nh : sign a = -1\n\u22a2 a < 0"}, {"line": "rw [sign_apply] at h", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableLT \u03b1\na : \u03b1\nh : (if 0 < a then 1 else if a < 0 then -1 else 0) = -1\n\u22a2 a < 0"}, {"line": "split_ifs at h", "tactic_state": "case pos\n\u03b1 : Type u\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableLT \u03b1\na : \u03b1\nh\u271d\u00b9 : \u00ac0 < a\nh\u271d : a < 0\nh : -1 = -1\n\u22a2 a < 0"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sign_eq_sign (n : \u2124) : Int.sign n = SignType.sign n := by\n  obtain (n | _) | _ := n <;> simp [sign, Int.sign_neg, negSucc_lt_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": ["SignType"], "variables": ["{\u03b1 : Type*} [Zero \u03b1] [One \u03b1] [Neg \u03b1]", "{\u03b1 : Type u}", "[Zero \u03b1] [Preorder \u03b1] [DecidableLT \u03b1] {a : \u03b1}", "[Zero \u03b1] [LinearOrder \u03b1] {a : \u03b1}", "[Semiring \u03b1] [PartialOrder \u03b1] [IsOrderedRing \u03b1] [DecidableLT \u03b1] [Nontrivial \u03b1]", "[Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[AddGroup \u03b1] [Preorder \u03b1] [DecidableLT \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 n.sign = \u2191(sign n)"}, {"line": "obtain (n | _) | _ := n <;> simp [sign, Int.sign_neg, negSucc_lt_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem exists_signed_sum_aux [DecidableEq \u03b1] (s : Finset \u03b1) (f : \u03b1 \u2192 \u2124) :\n    \u2203 (\u03b2 : Type u) (t : Finset \u03b2) (sgn : \u03b2 \u2192 SignType) (g : \u03b2 \u2192 \u03b1),\n      (\u2200 b, g b \u2208 s) \u2227\n        (#t = \u2211 a \u2208 s, (f a).natAbs) \u2227\n          \u2200 a \u2208 s, (\u2211 b \u2208 t, if g b = a then (sgn b : \u2124) else 0) = f a := by\n  refine\n    \u27e8(\u03a3 _ : { x // x \u2208 s }, \u2115), Finset.univ.sigma fun a => range (f a).natAbs,\n      fun a => sign (f a.1), fun a => a.1, fun a => a.1.2, ?_, ?_\u27e9\n  \u00b7 simp [sum_attach (f := fun a => (f a).natAbs)]\n  \u00b7 intro x hx\n    simp [sum_sigma, hx, \u2190 Int.sign_eq_sign, Int.sign_mul_abs, mul_comm |f _|,\n      sum_attach (s := s) (f := fun y => if y = x then f y else 0)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sign.lean", "context": {"open": ["SignType", "Finset Nat"], "variables": ["{\u03b1 : Type*} [Zero \u03b1] [One \u03b1] [Neg \u03b1]", "{\u03b1 : Type u}", "[Zero \u03b1] [Preorder \u03b1] [DecidableLT \u03b1] {a : \u03b1}", "[Zero \u03b1] [LinearOrder \u03b1] {a : \u03b1}", "[Semiring \u03b1] [PartialOrder \u03b1] [IsOrderedRing \u03b1] [DecidableLT \u03b1] [Nontrivial \u03b1]", "[Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[AddGroup \u03b1] [Preorder \u03b1] [DecidableLT \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2079 : Zero \u03b1\ninst\u271d\u00b9\u2078 : Preorder \u03b1\ninst\u271d\u00b9\u2077 : DecidableLT \u03b1\ninst\u271d\u00b9\u2076 : Zero \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : Semiring \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedRing \u03b1\ninst\u271d\u00b9\u00b9 : DecidableLT \u03b1\ninst\u271d\u00b9\u2070 : Nontrivial \u03b1\ninst\u271d\u2079 : Ring \u03b1\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : IsStrictOrderedRing \u03b1\ninst\u271d\u2076 : AddGroup \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : DecidableLT \u03b1\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsOrderedAddMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nf : \u03b1 \u2192 \u2124\n\u22a2 \u2203 \u03b2 t sgn g,\n    (\u2200 (b : \u03b2), g b \u2208 s) \u2227 t.card = \u2211 a \u2208 s, (f a).natAbs \u2227 \u2200 a \u2208 s, (\u2211 b \u2208 t, if g b = a then \u2191(sgn b) else 0) = f a"}, {"line": "refine\n    \u27e8(\u03a3 _ : { x // x \u2208 s }, \u2115), Finset.univ.sigma fun a => range (f a).natAbs,\n      fun a => sign (f a.1), fun a => a.1, fun a => a.1.2, ?_, ?_\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u\ninst\u271d\u00b9\u2079 : Zero \u03b1\ninst\u271d\u00b9\u2078 : Preorder \u03b1\ninst\u271d\u00b9\u2077 : DecidableLT \u03b1\ninst\u271d\u00b9\u2076 : Zero \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : Semiring \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedRing \u03b1\ninst\u271d\u00b9\u00b9 : DecidableLT \u03b1\ninst\u271d\u00b9\u2070 : Nontrivial \u03b1\ninst\u271d\u2079 : Ring \u03b1\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : IsStrictOrderedRing \u03b1\ninst\u271d\u2076 : AddGroup \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : DecidableLT \u03b1\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsOrderedAddMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nf : \u03b1 \u2192 \u2124\n\u22a2 (univ.sigma fun a => range (f \u2191a).natAbs).card = \u2211 a \u2208 s, (f a).natAbs\n---\ncase refine_2\n\u03b1 : Type u\ninst\u271d\u00b9\u2079 : Zero \u03b1\ninst\u271d\u00b9\u2078 : Preorder \u03b1\ninst\u271d\u00b9\u2077 : DecidableLT \u03b1\ninst\u271d\u00b9\u2076 : Zero \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : Semiring \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedRing \u03b1\ninst\u271d\u00b9\u00b9 : DecidableLT \u03b1\ninst\u271d\u00b9\u2070 : Nontrivial \u03b1\ninst\u271d\u2079 : Ring \u03b1\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : IsStrictOrderedRing \u03b1\ninst\u271d\u2076 : AddGroup \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : DecidableLT \u03b1\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsOrderedAddMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nf : \u03b1 \u2192 \u2124\n\u22a2 \u2200 a \u2208 s,\n    (\u2211 b \u2208 univ.sigma fun a => range (f \u2191a).natAbs,\n        if (fun a => \u2191a.fst) b = a then \u2191((fun a => sign (f \u2191a.fst)) b) else 0) =\n      f a"}, {"line": "\u00b7 simp [sum_attach (f := fun a => (f a).natAbs)]", "tactic_state": "case refine_2\n\u03b1 : Type u\ninst\u271d\u00b9\u2079 : Zero \u03b1\ninst\u271d\u00b9\u2078 : Preorder \u03b1\ninst\u271d\u00b9\u2077 : DecidableLT \u03b1\ninst\u271d\u00b9\u2076 : Zero \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : Semiring \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedRing \u03b1\ninst\u271d\u00b9\u00b9 : DecidableLT \u03b1\ninst\u271d\u00b9\u2070 : Nontrivial \u03b1\ninst\u271d\u2079 : Ring \u03b1\ninst\u271d\u2078 : LinearOrder \u03b1\ninst\u271d\u2077 : IsStrictOrderedRing \u03b1\ninst\u271d\u2076 : AddGroup \u03b1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : DecidableLT \u03b1\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsOrderedAddMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nf : \u03b1 \u2192 \u2124\n\u22a2 \u2200 a \u2208 s,\n    (\u2211 b \u2208 univ.sigma fun a => range (f \u2191a).natAbs,\n        if (fun a => \u2191a.fst) b = a then \u2191((fun a => sign (f \u2191a.fst)) b) else 0) =\n      f a"}, {"line": "\u00b7 intro x hx\n    simp [sum_sigma, hx, \u2190 Int.sign_eq_sign, Int.sign_mul_abs, mul_comm |f _|,\n      sum_attach (s := s) (f := fun y => if y = x then f y else 0)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma heq_iff_coe_heq {\u03b1 \u03b2 : Sort _} {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {a : {x // p x}}\n    {b : {y // q y}} (h : \u03b1 = \u03b2) (h' : HEq p q) : HEq a b \u2194 HEq (a : \u03b1) (b : \u03b2) := by\n  subst h\n  subst h'\n  rw [heq_iff_eq]\n  rw [heq_iff_eq]\n  rw [Subtype.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Subtype.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {p q : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Sort u_4\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\na : { x // p x }\nb : { y // q y }\nh : \u03b1 = \u03b2\nh' : HEq p q\n\u22a2 HEq a b \u2194 HEq \u2191a \u2191b"}, {"line": "subst h", "tactic_state": "\u03b1 : Sort u_4\np : \u03b1 \u2192 Prop\na : { x // p x }\nq : \u03b1 \u2192 Prop\nb : { y // q y }\nh' : HEq p q\n\u22a2 HEq a b \u2194 HEq \u2191a \u2191b"}, {"line": "subst h'", "tactic_state": "\u03b1 : Sort u_4\np : \u03b1 \u2192 Prop\na b : { y // p y }\n\u22a2 HEq a b \u2194 HEq \u2191a \u2191b"}, {"line": "rw [heq_iff_eq]", "tactic_state": "\u03b1 : Sort u_4\np : \u03b1 \u2192 Prop\na b : { y // p y }\n\u22a2 a = b \u2194 HEq \u2191a \u2191b"}, {"line": "rw [heq_iff_eq]", "tactic_state": "\u03b1 : Sort u_4\np : \u03b1 \u2192 Prop\na b : { y // p y }\n\u22a2 a = b \u2194 \u2191a = \u2191b"}, {"line": "rw [Subtype.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_eq_mk {a h a' h'} : @mk \u03b1 p a h = @mk \u03b1 p a' h' \u2194 a = a' := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Subtype.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {p q : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nmk : x\u271d\na : ?m.887\nh : ?m.888\na' : ?m.887\nh' : ?m.889\n\u22a2 sorry = sorry \u2194 a = a'"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_4\nmk : x\u271d\na : ?m.887\nh : ?m.888\na' : ?m.887\nh' : ?m.889\n\u22a2 sorry () = sorry () \u2194 a = a'"}]}
{"declaration": "theorem eq_of_drop_last_eq {\u03b1 \u03b2 : TypeVec (n + 1)} {f g : \u03b1 \u27f9 \u03b2} (h\u2080 : dropFun f = dropFun g)\n    (h\u2081 : lastFun f = lastFun g) : f = g := by\n  refine funext (fun x => ?_)\n  cases x\n  \u00b7 apply h\u2081\n  \u00b7 apply congr_fun h\u2080\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/TypeVec.lean", "context": {"open": ["MvFunctor"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d\u00b9 : Sort u_1\ndropFun : x\u271d\u00b9\nx\u271d : Sort u_2\nlastFun : x\u271d\n\u03b1 : TypeVec.{u_3} (n + 1)\n\u03b2 : TypeVec.{u_4} (n + 1)\nf g : \u03b1.Arrow \u03b2\nh\u2080 : sorry = sorry\nh\u2081 : sorry = sorry\n\u22a2 f = g"}, {"line": "refine funext (fun x => ?_)", "tactic_state": "n : \u2115\nx\u271d\u00b9 : Sort u_1\ndropFun : x\u271d\u00b9\nx\u271d : Sort u_2\nlastFun : x\u271d\n\u03b1 : TypeVec.{u_3} (n + 1)\n\u03b2 : TypeVec.{u_4} (n + 1)\nf g : \u03b1.Arrow \u03b2\nh\u2080 : sorry = sorry\nh\u2081 : sorry = sorry\nx : Fin2 (n + 1)\n\u22a2 f x = g x"}, {"line": "cases x", "tactic_state": "case fz\nn : \u2115\nx\u271d\u00b9 : Sort u_1\ndropFun : x\u271d\u00b9\nx\u271d : Sort u_2\nlastFun : x\u271d\n\u03b1 : TypeVec.{u_3} (n + 1)\n\u03b2 : TypeVec.{u_4} (n + 1)\nf g : \u03b1.Arrow \u03b2\nh\u2080 : sorry = sorry\nh\u2081 : sorry = sorry\n\u22a2 f Fin2.fz = g Fin2.fz\n---\ncase fs\nn : \u2115\nx\u271d\u00b9 : Sort u_1\ndropFun : x\u271d\u00b9\nx\u271d : Sort u_2\nlastFun : x\u271d\n\u03b1 : TypeVec.{u_3} (n + 1)\n\u03b2 : TypeVec.{u_4} (n + 1)\nf g : \u03b1.Arrow \u03b2\nh\u2080 : sorry = sorry\nh\u2081 : sorry = sorry\na\u271d : Fin2 n\n\u22a2 f a\u271d.fs = g a\u271d.fs"}, {"line": "\u00b7 apply h\u2081", "tactic_state": "case fs\nn : \u2115\nx\u271d\u00b9 : Sort u_1\ndropFun : x\u271d\u00b9\nx\u271d : Sort u_2\nlastFun : x\u271d\n\u03b1 : TypeVec.{u_3} (n + 1)\n\u03b2 : TypeVec.{u_4} (n + 1)\nf g : \u03b1.Arrow \u03b2\nh\u2080 : sorry = sorry\nh\u2081 : sorry = sorry\na\u271d : Fin2 n\n\u22a2 f a\u271d.fs = g a\u271d.fs"}, {"line": "\u00b7 apply congr_fun h\u2080", "tactic_state": "No Goals!"}]}
{"declaration": "theorem repeat_eq_append1 {\u03b2} {n} (\u03b1 : TypeVec n) :\n    repeatEq (\u03b1 ::: \u03b2) = splitFun (\u03b1 := (\u03b1 \u2297 \u03b1) ::: _)\n    (\u03b1' := (\u00abrepeat\u00bb n Prop) ::: _) (repeatEq \u03b1) (uncurry Eq) := by\n  induction n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/TypeVec.lean", "context": {"open": ["MvFunctor", "Nat", "Function (uncurry)"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nrepeatEq : x\u271d\u00b9\nx\u271d : Sort u_2\nsplitFun : x\u271d\n\u03b2 : ?m.865\nn : \u2115\n\u03b1 : TypeVec.{u_3} n\n\u22a2 sorry = sorry"}, {"line": "induction n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ne_bot_iff {f : Filter \u03b1} (F : f.Realizer) : f \u2260 \u22a5 \u2194 \u2200 a : F.\u03c3, (F.F a).Nonempty := by\n  rw [not_iff_comm]\n  rw [\u2190 le_bot_iff]\n  rw [F.le_iff Realizer.bot]\n  rw [not_forall]\n  simp only [Set.not_nonempty_iff_eq_empty]\n  exact \u27e8fun \u27e8x, e\u27e9 _ \u21a6 \u27e8x, le_of_eq e\u27e9, fun h \u21a6\n    let \u27e8x, h\u27e9 := h ()\n    \u27e8x, le_bot_iff.1 h\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Analysis/Filter.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}", "[PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PartialOrder \u03b1\nf : Filter \u03b1\nF : f.Realizer\n\u22a2 f \u2260 \u22a5 \u2194 \u2200 (a : F.\u03c3), (F.F.f a).Nonempty"}, {"line": "rw [not_iff_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PartialOrder \u03b1\nf : Filter \u03b1\nF : f.Realizer\n\u22a2 (\u00ac\u2200 (a : F.\u03c3), (F.F.f a).Nonempty) \u2194 f = \u22a5"}, {"line": "rw [\u2190 le_bot_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PartialOrder \u03b1\nf : Filter \u03b1\nF : f.Realizer\n\u22a2 (\u00ac\u2200 (a : F.\u03c3), (F.F.f a).Nonempty) \u2194 f \u2264 \u22a5"}, {"line": "rw [F.le_iff Realizer.bot]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PartialOrder \u03b1\nf : Filter \u03b1\nF : f.Realizer\n\u22a2 (\u00ac\u2200 (a : F.\u03c3), (F.F.f a).Nonempty) \u2194 \u2200 (b : Realizer.bot.\u03c3), \u2203 a, F.F.f a \u2264 Realizer.bot.F.f b"}, {"line": "rw [not_forall]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PartialOrder \u03b1\nf : Filter \u03b1\nF : f.Realizer\n\u22a2 (\u2203 x, \u00ac(F.F.f x).Nonempty) \u2194 \u2200 (b : Realizer.bot.\u03c3), \u2203 a, F.F.f a \u2264 Realizer.bot.F.f b"}, {"line": "simp only [Set.not_nonempty_iff_eq_empty]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PartialOrder \u03b1\nf : Filter \u03b1\nF : f.Realizer\n\u22a2 (\u2203 x, F.F.f x = \u2205) \u2194 \u2200 (b : Realizer.bot.\u03c3), \u2203 a, F.F.f a \u2264 Realizer.bot.F.f b"}, {"line": "exact \u27e8fun \u27e8x, e\u27e9 _ \u21a6 \u27e8x, le_of_eq e\u27e9, fun h \u21a6\n    let \u27e8x, h\u27e9 := h ()\n    \u27e8x, le_bot_iff.1 h\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ext' [T : TopologicalSpace \u03b1] {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (H : \u2200 a s, s \u2208 \ud835\udcdd a \u2194 \u2203 b, a \u2208 F b \u2227 F b \u2286 s) : F.toTopsp = T := by\n  refine TopologicalSpace.ext_nhds fun x \u21a6 ?_\n  ext s\n  rw [mem_nhds_toTopsp]\n  rw [H]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Analysis/Topology.lean", "context": {"open": ["Set", "Filter hiding Realizer", "Topology", "Ctop"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}", "(F : Ctop \u03b1 \u03c3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nT : TopologicalSpace \u03b1\n\u03c3 : Type u_5\nF : Ctop \u03b1 \u03c3\nH : \u2200 (a : \u03b1) (s : Set \u03b1), s \u2208 nhds a \u2194 \u2203 b, a \u2208 F.f b \u2227 F.f b \u2286 s\n\u22a2 F.toTopsp = T"}, {"line": "refine TopologicalSpace.ext_nhds fun x \u21a6 ?_", "tactic_state": "\u03b1 : Type u_1\nT : TopologicalSpace \u03b1\n\u03c3 : Type u_5\nF : Ctop \u03b1 \u03c3\nH : \u2200 (a : \u03b1) (s : Set \u03b1), s \u2208 nhds a \u2194 \u2203 b, a \u2208 F.f b \u2227 F.f b \u2286 s\nx : \u03b1\n\u22a2 nhds x = nhds x"}, {"line": "ext s", "tactic_state": "case h\n\u03b1 : Type u_1\nT : TopologicalSpace \u03b1\n\u03c3 : Type u_5\nF : Ctop \u03b1 \u03c3\nH : \u2200 (a : \u03b1) (s : Set \u03b1), s \u2208 nhds a \u2194 \u2203 b, a \u2208 F.f b \u2227 F.f b \u2286 s\nx : \u03b1\ns : Set \u03b1\n\u22a2 s \u2208 nhds x \u2194 s \u2208 nhds x"}, {"line": "rw [mem_nhds_toTopsp]", "tactic_state": "case h\n\u03b1 : Type u_1\nT : TopologicalSpace \u03b1\n\u03c3 : Type u_5\nF : Ctop \u03b1 \u03c3\nH : \u2200 (a : \u03b1) (s : Set \u03b1), s \u2208 nhds a \u2194 \u2203 b, a \u2208 F.f b \u2227 F.f b \u2286 s\nx : \u03b1\ns : Set \u03b1\n\u22a2 (\u2203 b, x \u2208 F.f b \u2227 F.f b \u2286 s) \u2194 s \u2208 nhds x"}, {"line": "rw [H]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem all_iff_forall_prop : (all l fun a => p a) \u2194 \u2200 a \u2208 l, p a := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/AllAny.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {p : \u03b1 \u2192 Prop} [DecidablePred p] {l : List \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nl : List \u03b1\nx\u271d : Sort u_2\nall : x\u271d\n\u22a2 sorry \u2194 \u2200 a \u2208 l, p a"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nl : List \u03b1\nx\u271d : Sort u_2\nall : x\u271d\n\u22a2 sorry () \u2194 \u2200 a \u2208 l, p a"}]}
{"declaration": "theorem any_iff_exists_prop : (any l fun a => p a) \u2194 \u2203 a \u2208 l, p a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/AllAny.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {p : \u03b1 \u2192 Prop} [DecidablePred p] {l : List \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nl : List \u03b1\nx\u271d : Sort u_2\nany : x\u271d\n\u22a2 sorry \u2194 \u2203 a \u2208 l, p a"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nl : List \u03b1\nx\u271d : Sort u_2\nany : x\u271d\n\u22a2 sorry () \u2194 \u2203 a \u2208 l, p a"}]}
{"declaration": "theorem true_eq_false_eq_False : \u00actrue = false := by decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00actrue = false"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "theorem false_eq_true_eq_False : \u00acfalse = true := by decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00acfalse = true"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_false_eq_not_eq_true (b : Bool) : (\u00acb = true) = (b = false) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : Bool\n\u22a2 (\u00acb = true) = (b = false)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_true_eq_not_eq_false (b : Bool) : (\u00acb = false) = (b = true) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : Bool\n\u22a2 (\u00acb = false) = (b = true)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem and_eq_true_eq_eq_true_and_eq_true (a b : Bool) :\n    ((a && b) = true) = (a = true \u2227 b = true) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Bool\n\u22a2 ((a && b) = true) = (a = true \u2227 b = true)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem or_eq_true_eq_eq_true_or_eq_true (a b : Bool) :\n    ((a || b) = true) = (a = true \u2228 b = true) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Bool\n\u22a2 ((a || b) = true) = (a = true \u2228 b = true)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_eq_true_eq_eq_false (a : Bool) : (not a = true) = (a = false) := by cases a <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Bool\n\u22a2 ((!a) = true) = (a = false)"}, {"line": "cases a <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem and_eq_false_eq_eq_false_or_eq_false (a b : Bool) :\n    ((a && b) = false) = (a = false \u2228 b = false) := by\n  cases a <;> cases b <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Bool\n\u22a2 ((a && b) = false) = (a = false \u2228 b = false)"}, {"line": "cases a <;> cases b <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem or_eq_false_eq_eq_false_and_eq_false (a b : Bool) :\n    ((a || b) = false) = (a = false \u2227 b = false) := by\n  cases a <;> cases b <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Bool\n\u22a2 ((a || b) = false) = (a = false \u2227 b = false)"}, {"line": "cases a <;> cases b <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_eq_false_eq_eq_true (a : Bool) : (not a = false) = (a = true) := by cases a <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Bool\n\u22a2 ((!a) = false) = (a = true)"}, {"line": "cases a <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_false : \u2191false = False := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (false = true) = False"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_true : \u2191true = True := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (true = true) = True"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_sort_false : (false : Prop) = False := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (false = true) = False"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_sort_true : (true : Prop) = True := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (true = true) = True"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem decide_iff (p : Prop) [d : Decidable p] : decide p = true \u2194 p := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\nd : Decidable p\n\u22a2 decide p = true \u2194 p"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bool_iff_false {b : Bool} : \u00acb \u2194 b = false := by cases b <;> decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : Bool\n\u22a2 \u00acb = true \u2194 b = false"}, {"line": "cases b <;> decide", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_xor_iff (a b : Bool) : xor a b \u2194 Xor' (a = true) (b = true) := by\n  cases a <;> cases b <;> decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Bool\n\u22a2 (a ^^ b) = true \u2194 Xor' (a = true) (b = true)"}, {"line": "cases a <;> cases b <;> decide", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dichotomy (b : Bool) : b = false \u2228 b = true := by cases b <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : Bool\n\u22a2 b = false \u2228 b = true"}, {"line": "cases b <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem or_inl {a b : Bool} (H : a) : a || b := by simp [H]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Bool\nH : a = true\n\u22a2 (a || b) = true"}, {"line": "simp [H]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem or_inr {a b : Bool} (H : b) : a || b := by cases a <;> simp [H]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Bool\nH : b = true\n\u22a2 (a || b) = true"}, {"line": "cases a <;> simp [H]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_ne_self : \u2200 b : Bool, (!b) \u2260 b := by decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (b : Bool), (!b) \u2260 b"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "lemma self_ne_not : \u2200 b : Bool, b \u2260 !b := by decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (b : Bool), b \u2260 !b"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_or_eq_not : \u2200 a b, a = b \u2228 a = !b := by decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (a b : Bool), a = b \u2228 a = !b"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_iff_not : \u2200 {b : Bool}, !b \u2194 \u00acb := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b\u271d : Bool\n\u22a2 (!b\u271d) = true \u2194 \u00acb\u271d = true"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_true_of_not_eq_false' {a : Bool} : !a = false \u2192 a = true := by\n  cases a <;> decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Bool\n\u22a2 (!decide (a = false)) = true \u2192 a = true"}, {"line": "cases a <;> decide", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_false_of_not_eq_true' {a : Bool} : !a = true \u2192 a = false := by\n  cases a <;> decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Bool\n\u22a2 (!decide (a = true)) = true \u2192 a = false"}, {"line": "cases a <;> decide", "tactic_state": "No Goals!"}]}
{"declaration": "theorem and_le_left : \u2200 x y : Bool, (x && y) \u2264 x := by decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (x y : Bool), (x && y) \u2264 x"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "theorem and_le_right : \u2200 x y : Bool, (x && y) \u2264 y := by decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (x y : Bool), (x && y) \u2264 y"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "theorem right_le_or : \u2200 x y : Bool, y \u2264 (x || y) := by decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (x y : Bool), y \u2264 (x || y)"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "theorem apply_apply_apply (f : Bool \u2192 Bool) (x : Bool) : f (f (f x)) = f x := by\n  cases x <;> cases h\u2081 : f true <;> cases h\u2082 : f false <;> simp only [h\u2081, h\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : Bool \u2192 Bool\nx : Bool\n\u22a2 f (f (f x)) = f x"}, {"line": "cases x <;> cases h\u2081 : f true <;> cases h\u2082 : f false <;> simp only [h\u2081, h\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_div_two_le_count_bool (hl : Chain' (\u00b7 \u2260 \u00b7) l) (b : Bool) :\n    length l / 2 \u2264 count b l := by\n  rw [Nat.div_le_iff_le_mul_add_pred two_pos]\n  rw [\u2190 tsub_le_iff_right]\n  exact length_sub_one_le_two_mul_count_bool hl b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Bool/Count.lean", "context": {"open": [], "variables": ["{l : List Bool}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_1\nChain' : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nlength : x\u271d\u00b9\nx\u271d : Sort u_3\ncount : x\u271d\nhl : sorry\nb : Bool\n\u22a2 sorry / 2 \u2264 sorry"}, {"line": "rw [Nat.div_le_iff_le_mul_add_pred two_pos]", "tactic_state": "x\u271d\u00b2 : Sort u_1\nChain' : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nlength : x\u271d\u00b9\nx\u271d : Sort u_3\ncount : x\u271d\nhl : sorry\nb : Bool\n\u22a2 sorry \u2264 2 * sorry + (2 - 1)"}, {"line": "rw [\u2190 tsub_le_iff_right]", "tactic_state": "x\u271d\u00b2 : Sort u_1\nChain' : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nlength : x\u271d\u00b9\nx\u271d : Sort u_3\ncount : x\u271d\nhl : sorry\nb : Bool\n\u22a2 sorry - (2 - 1) \u2264 2 * sorry"}, {"line": "exact length_sub_one_le_two_mul_count_bool hl b", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ofReal_balance [Fintype \u03b1] (f : \u03b1 \u2192 \u211d) (a : \u03b1) :\n    ((balance f a : \u211d) : \u2102) = balance ((\u2191) \u2218 f) a := by simp [balance]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/BigOperators.lean", "context": {"open": ["Fintype", "scoped BigOperators"], "variables": ["{\u03b1 : Type*} (s : Finset \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Fintype \u03b1\nf : \u03b1 \u2192 \u211d\na : \u03b1\n\u22a2 \u2191(balance f a) = balance (Complex.ofReal \u2218 f) a"}, {"line": "simp [balance]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Cardinal.mk_complex : #\u2102 = \ud835\udd20 := by\n  rw [mk_congr Complex.equivRealProd]\n  rw [mk_prod]\n  rw [lift_id]\n  rw [mk_real]\n  rw [continuum_mul_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Cardinality.lean", "context": {"open": ["Cardinal Set", "Cardinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 mk \u2102 = continuum"}, {"line": "rw [mk_congr Complex.equivRealProd]", "tactic_state": "\u22a2 mk (\u211d \u00d7 \u211d) = continuum"}, {"line": "rw [mk_prod]", "tactic_state": "\u22a2 lift.{0, 0} (mk \u211d) * lift.{0, 0} (mk \u211d) = continuum"}, {"line": "rw [lift_id]", "tactic_state": "\u22a2 mk \u211d * mk \u211d = continuum"}, {"line": "rw [mk_real]", "tactic_state": "\u22a2 continuum * continuum = continuum"}, {"line": "rw [continuum_mul_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Cardinal.mk_univ_complex : #(Set.univ : Set \u2102) = \ud835\udd20 := by rw [mk_univ, mk_complex]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Cardinality.lean", "context": {"open": ["Cardinal Set", "Cardinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 mk \u2191Set.univ = continuum"}, {"line": "rw [mk_univ, mk_complex]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_countable_complex : \u00ac(Set.univ : Set \u2102).Countable := by\n  rw [\u2190 le_aleph0_iff_set_countable]\n  rw [not_le]\n  rw [Cardinal.mk_univ_complex]\n  apply cantor", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Cardinality.lean", "context": {"open": ["Cardinal Set", "Cardinal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00acSet.univ.Countable"}, {"line": "rw [\u2190 le_aleph0_iff_set_countable]", "tactic_state": "\u22a2 \u00acmk \u2191Set.univ \u2264 aleph0"}, {"line": "rw [not_le]", "tactic_state": "\u22a2 aleph0 < mk \u2191Set.univ"}, {"line": "rw [Cardinal.mk_univ_complex]", "tactic_state": "\u22a2 aleph0 < continuum"}, {"line": "apply cantor", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rank_real_complex : Module.rank \u211d \u2102 = 2 := by simp [\u2190 finrank_eq_rank, finrank_real_complex]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/FiniteDimensional.lean", "context": {"open": ["Module"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Module.rank \u211d \u2102 = 2"}, {"line": "simp [\u2190 finrank_eq_rank, finrank_real_complex]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Real.rank_rat_real : Module.rank \u211a \u211d = continuum := by\n  refine (Free.rank_eq_mk_of_infinite_lt \u211a \u211d ?_).trans mk_real\n  simpa [mk_real] using aleph0_lt_continuum\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/FiniteDimensional.lean", "context": {"open": ["Module", "Cardinal Module"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Module.rank \u211a \u211d = continuum"}, {"line": "refine (Free.rank_eq_mk_of_infinite_lt \u211a \u211d ?_).trans mk_real", "tactic_state": "\u22a2 lift.{0, 0} (Cardinal.mk \u211a) < lift.{0, 0} (Cardinal.mk \u211d)"}, {"line": "simpa [mk_real] using aleph0_lt_continuum", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Complex.rank_rat_complex : Module.rank \u211a \u2102 = continuum := by\n  refine (Free.rank_eq_mk_of_infinite_lt \u211a \u2102 ?_).trans Cardinal.mk_complex\n  simpa using aleph0_lt_continuum\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/FiniteDimensional.lean", "context": {"open": ["Module", "Cardinal Module"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Module.rank \u211a \u2102 = continuum"}, {"line": "refine (Free.rank_eq_mk_of_infinite_lt \u211a \u2102 ?_).trans Cardinal.mk_complex", "tactic_state": "\u22a2 Cardinal.lift.{0, 0} (Cardinal.mk \u211a) < Cardinal.lift.{0, 0} (Cardinal.mk \u2102)"}, {"line": "simpa using aleph0_lt_continuum", "tactic_state": "No Goals!"}]}
{"declaration": "lemma \u00abforall\u00bb {p : \u2102 \u2192 Prop} : (\u2200 x, p x) \u2194 \u2200 a b, p \u27e8a, b\u27e9 := by aesop", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2102 \u2192 Prop\n\u22a2 (\u2200 (x : \u2102), p x) \u2194 \u2200 (a b : \u211d), p { re := a, im := b }"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma \u00abexists\u00bb {p : \u2102 \u2192 Prop} : (\u2203 x, p x) \u2194 \u2203 a b, p \u27e8a, b\u27e9 := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2102 \u2192 Prop\n\u22a2 (\u2203 x, p x) \u2194 \u2203 a b, p { re := a, im := b }"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem re_ofReal_mul (r : \u211d) (z : \u2102) : (r * z).re = r * z.re := by simp [ofReal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\nz : \u2102\n\u22a2 (\u2191r * z).re = r * z.re"}, {"line": "simp [ofReal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem im_ofReal_mul (r : \u211d) (z : \u2102) : (r * z).im = r * z.im := by simp [ofReal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\nz : \u2102\n\u22a2 (\u2191r * z).im = r * z.im"}, {"line": "simp [ofReal]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma re_mul_ofReal (z : \u2102) (r : \u211d) : (z * r).re = z.re *  r := by simp [ofReal]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2102\nr : \u211d\n\u22a2 (z * \u2191r).re = z.re * r"}, {"line": "simp [ofReal]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma im_mul_ofReal (z : \u2102) (r : \u211d) : (z * r).im = z.im *  r := by simp [ofReal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2102\nr : \u211d\n\u22a2 (z * \u2191r).im = z.im * r"}, {"line": "simp [ofReal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_I_im (z : \u2102) : (z * I).im = z.re := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "I z : \u2102\n\u22a2 (z * I).im = z.re"}, {"line": "simp", "tactic_state": "I z : \u2102\n\u22a2 z.re * I.im + z.im * I.re = z.re"}]}
{"declaration": "theorem I_mul_re (z : \u2102) : (I * z).re = -z.im := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "I z : \u2102\n\u22a2 (I * z).re = -z.im"}, {"line": "simp", "tactic_state": "I z : \u2102\n\u22a2 I.re * z.re - I.im * z.im = -z.im"}]}
{"declaration": "theorem I_mul_im (z : \u2102) : (I * z).im = z.re := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "I z : \u2102\n\u22a2 (I * z).im = z.re"}, {"line": "simp", "tactic_state": "I z : \u2102\n\u22a2 I.re * z.im + I.im * z.re = z.re"}]}
{"declaration": "theorem smul_re (r : R) (z : \u2102) : (r \u2022 z).re = r \u2022 z.re := by simp [(\u00b7 \u2022 \u00b7), SMul.smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : SMul R \u211d\nr : R\nz : \u2102\n\u22a2 sorry = r \u2022 z.re"}, {"line": "simp [(\u00b7 \u2022 \u00b7), SMul.smul]", "tactic_state": "R : Type u_1\ninst\u271d : SMul R \u211d\nr : R\nz : \u2102\n\u22a2 sorry () = SMul.smul r z.re"}]}
{"declaration": "theorem smul_im (r : R) (z : \u2102) : (r \u2022 z).im = r \u2022 z.im := by simp [(\u00b7 \u2022 \u00b7), SMul.smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : SMul R \u211d\nr : R\nz : \u2102\n\u22a2 sorry = r \u2022 z.im"}, {"line": "simp [(\u00b7 \u2022 \u00b7), SMul.smul]", "tactic_state": "R : Type u_1\ninst\u271d : SMul R \u211d\nr : R\nz : \u2102\n\u22a2 sorry () = SMul.smul r z.im"}]}
{"declaration": "theorem conj_neg_I : conj (-I) = I := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : \u2124\n\u22a2 (starRingEnd \u2124) (-I) = I"}, {"line": "simp", "tactic_state": "I : \u2124\n\u22a2 -I = I"}]}
{"declaration": "theorem normSq_ofReal (r : \u211d) : normSq r = r * r := by\n  simp [normSq, ofReal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nnormSq : x\u271d\nr : \u211d\n\u22a2 sorry = r * r"}, {"line": "simp [normSq, ofReal]", "tactic_state": "x\u271d : Sort u_2\nnormSq : x\u271d\nr : \u211d\n\u22a2 sorry () = r * r"}]}
{"declaration": "theorem normSq_zero : normSq 0 = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nnormSq : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_2\nnormSq : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem normSq_one : normSq 1 = 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nnormSq : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_2\nnormSq : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem normSq_I : normSq I = 1 := by simp [normSq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nnormSq : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [normSq]", "tactic_state": "x\u271d : Sort u_2\nnormSq : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem normSq_neg (z : \u2102) : normSq (-z) = normSq z := by simp [normSq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nnormSq : x\u271d\nz : \u2102\n\u22a2 sorry = sorry"}, {"line": "simp [normSq]", "tactic_state": "x\u271d : Sort u_2\nnormSq : x\u271d\nz : \u2102\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem normSq_conj (z : \u2102) : normSq (conj z) = normSq z := by simp [normSq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nnormSq : x\u271d\nz : \u2102\n\u22a2 sorry = sorry"}, {"line": "simp [normSq]", "tactic_state": "x\u271d : Sort u_2\nnormSq : x\u271d\nz : \u2102\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem ofReal_pow (r : \u211d) (n : \u2115) : ((r ^ n : \u211d) : \u2102) = (r : \u2102) ^ n := by\n  induction n <;> simp [*, ofReal_mul, pow_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\nn : \u2115\n\u22a2 \u2191(r ^ n) = \u2191r ^ n"}, {"line": "induction n <;> simp [*, ofReal_mul, pow_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_re (z : \u2102) : z\u207b\u00b9.re = z.re / normSq z := by simp [inv_def, division_def, ofReal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nnormSq : x\u271d\nz : \u2102\n\u22a2 z\u207b\u00b9.re = z.re / sorry"}, {"line": "simp [inv_def, division_def, ofReal]", "tactic_state": "x\u271d : Sort u_3\nnormSq : x\u271d\nz : \u2102\n\u22a2 Complex.normSq z = sorry () \u2228 z.re = 0"}]}
{"declaration": "theorem inv_im (z : \u2102) : z\u207b\u00b9.im = -z.im / normSq z := by simp [inv_def, division_def, ofReal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nnormSq : x\u271d\nz : \u2102\n\u22a2 z\u207b\u00b9.im = -z.im / sorry"}, {"line": "simp [inv_def, division_def, ofReal]", "tactic_state": "x\u271d : Sort u_3\nnormSq : x\u271d\nz : \u2102\n\u22a2 Complex.normSq z = sorry () \u2228 z.im = 0"}]}
{"declaration": "lemma div_re (z w : \u2102) : (z / w).re = z.re * w.re / normSq w + z.im * w.im / normSq w := by\n  simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nnormSq : x\u271d\nz w : \u2102\n\u22a2 (z / w).re = z.re * w.re / sorry + z.im * w.im / sorry"}, {"line": "simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg]", "tactic_state": "x\u271d : Sort u_3\nnormSq : x\u271d\nz w : \u2102\n\u22a2 z.re * (w.re * (Complex.normSq w)\u207b\u00b9) + z.im * (w.im * (Complex.normSq w)\u207b\u00b9) =\n    z.re * (w.re * (sorry ())\u207b\u00b9) + z.im * (w.im * (sorry ())\u207b\u00b9)"}]}
{"declaration": "lemma div_im (z w : \u2102) : (z / w).im = z.im * w.re / normSq w - z.re * w.im / normSq w := by\n  simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg, add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nnormSq : x\u271d\nz w : \u2102\n\u22a2 (z / w).im = z.im * w.re / sorry - z.re * w.im / sorry"}, {"line": "simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg, add_comm]", "tactic_state": "x\u271d : Sort u_3\nnormSq : x\u271d\nz w : \u2102\n\u22a2 z.im * (w.re * (Complex.normSq w)\u207b\u00b9) + -(z.re * (w.im * (Complex.normSq w)\u207b\u00b9)) =\n    z.im * (w.re * (sorry ())\u207b\u00b9) + -(z.re * (w.im * (sorry ())\u207b\u00b9))"}]}
{"declaration": "lemma ofReal_nnqsmul (q : \u211a\u22650) (r : \u211d) : ofReal (q \u2022 r) = q \u2022 r := by simp [NNRat.smul_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nofReal : x\u271d\nq : \u211a\u22650\nr : \u211d\n\u22a2 sorry = q \u2022 r"}, {"line": "simp [NNRat.smul_def]", "tactic_state": "x\u271d : Sort u_3\nofReal : x\u271d\nq : \u211a\u22650\nr : \u211d\n\u22a2 sorry () = \u2191q * r"}]}
{"declaration": "lemma ofReal_qsmul (q : \u211a) (r : \u211d) : ofReal (q \u2022 r) = q \u2022 r := by simp [Rat.smul_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nofReal : x\u271d\nq : \u211a\nr : \u211d\n\u22a2 sorry = q \u2022 r"}, {"line": "simp [Rat.smul_def]", "tactic_state": "x\u271d : Sort u_3\nofReal : x\u271d\nq : \u211a\nr : \u211d\n\u22a2 sorry () = \u2191q * r"}]}
{"declaration": "theorem normSq_inv (z : \u2102) : normSq z\u207b\u00b9 = (normSq z)\u207b\u00b9 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nnormSq : x\u271d\nz : \u2102\n\u22a2 sorry = sorry\u207b\u00b9"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_3\nnormSq : x\u271d\nz : \u2102\n\u22a2 sorry () = (sorry ())\u207b\u00b9"}]}
{"declaration": "theorem normSq_div (z w : \u2102) : normSq (z / w) = normSq z / normSq w := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nnormSq : x\u271d\nz w : \u2102\n\u22a2 sorry = sorry / sorry"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_3\nnormSq : x\u271d\nz w : \u2102\n\u22a2 sorry () = sorry () / sorry ()"}]}
{"declaration": "lemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 := by\n  convert prod_subset_prod_iff\n  exact reProdIm_subset_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Basic.lean", "context": {"open": ["Set Function", "ComplexConjugate", "scoped SMul"], "variables": ["{R : Type*} [SMul R \u211d]", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s s\u2081 t t\u2081 : Set \u211d\n\u22a2 s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205"}, {"line": "convert prod_subset_prod_iff", "tactic_state": "case h.e'_1.a\ns s\u2081 t t\u2081 : Set \u211d\n\u22a2 s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081"}, {"line": "exact reProdIm_subset_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_add : exp (x + y) = exp x * exp y := by\n  have hj : \u2200 j : \u2115, (\u2211 m \u2208 range j, (x + y) ^ m / m.factorial) =\n        \u2211 i \u2208 range j, \u2211 k \u2208 range (i + 1), x ^ k / k.factorial *\n          (y ^ (i - k) / (i - k).factorial) := by\n    intro j\n    refine Finset.sum_congr rfl fun m _ => ?_\n    rw [add_pow]\n    rw [div_eq_mul_inv]\n    rw [sum_mul]\n    refine Finset.sum_congr rfl fun I hi => ?_\n    have h\u2081 : (m.choose I : \u2102) \u2260 0 :=\n      Nat.cast_ne_zero.2 (pos_iff_ne_zero.1 (Nat.choose_pos (Nat.le_of_lt_succ (mem_range.1 hi))))\n    have h\u2082 := Nat.choose_mul_factorial_mul_factorial (Nat.le_of_lt_succ <| Finset.mem_range.1 hi)\n    rw [\u2190 h\u2082]\n    rw [Nat.cast_mul]\n    rw [Nat.cast_mul]\n    rw [mul_inv]\n    rw [mul_inv]\n    simp only [mul_left_comm (m.choose I : \u2102)]\n    simp only [mul_assoc]\n    simp only [mul_left_comm (m.choose I : \u2102)\u207b\u00b9]\n    simp only [mul_comm (m.choose I : \u2102)]\n    rw [inv_mul_cancel\u2080 h\u2081]\n    simp [div_eq_mul_inv, mul_comm, mul_assoc, mul_left_comm]\n  simp_rw [exp, exp', lim_mul_lim]\n  apply (lim_eq_lim_of_equiv _).symm\n  simp only [hj]\n  exact cauchy_product (isCauSeq_norm_exp x) (isCauSeq_exp y)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 exp (x + y) = exp x * exp y"}, {"line": "have hj : \u2200 j : \u2115, (\u2211 m \u2208 range j, (x + y) ^ m / m.factorial) =\n        \u2211 i \u2208 range j, \u2211 k \u2208 range (i + 1), x ^ k / k.factorial *\n          (y ^ (i - k) / (i - k).factorial) := by\n    intro j\n    refine Finset.sum_congr rfl fun m _ => ?_\n    rw [add_pow]\n    rw [div_eq_mul_inv]\n    rw [sum_mul]\n    refine Finset.sum_congr rfl fun I hi => ?_\n    have h\u2081 : (m.choose I : \u2102) \u2260 0 :=\n      Nat.cast_ne_zero.2 (pos_iff_ne_zero.1 (Nat.choose_pos (Nat.le_of_lt_succ (mem_range.1 hi))))\n    have h\u2082 := Nat.choose_mul_factorial_mul_factorial (Nat.le_of_lt_succ <| Finset.mem_range.1 hi)\n    rw [\u2190 h\u2082]\n    rw [Nat.cast_mul]\n    rw [Nat.cast_mul]\n    rw [mul_inv]\n    rw [mul_inv]\n    simp only [mul_left_comm (m.choose I : \u2102)]\n    simp only [mul_assoc]\n    simp only [mul_left_comm (m.choose I : \u2102)\u207b\u00b9]\n    simp only [mul_comm (m.choose I : \u2102)]\n    rw [inv_mul_cancel\u2080 h\u2081]\n    simp [div_eq_mul_inv, mul_comm, mul_assoc, mul_left_comm]", "tactic_state": "x y : \u2102\nhj :\n  \u2200 (j : \u2115),\n    \u2211 m \u2208 range j, (x + y) ^ m / \u2191m.factorial =\n      \u2211 i \u2208 range j, \u2211 k \u2208 range (i + 1), x ^ k / \u2191k.factorial * (y ^ (i - k) / \u2191(i - k).factorial)\n\u22a2 exp (x + y) = exp x * exp y"}, {"line": "simp_rw [exp, exp', lim_mul_lim]", "tactic_state": "x y : \u2102\nhj :\n  \u2200 (j : \u2115),\n    \u2211 m \u2208 range j, (x + y) ^ m / \u2191m.factorial =\n      \u2211 i \u2208 range j, \u2211 k \u2208 range (i + 1), x ^ k / \u2191k.factorial * (y ^ (i - k) / \u2191(i - k).factorial)\n\u22a2 CauSeq.lim \u27e8fun n => \u2211 m \u2208 range n, (x + y) ^ m / \u2191m.factorial, \u22ef\u27e9 =\n    (\u27e8fun n => \u2211 m \u2208 range n, x ^ m / \u2191m.factorial, \u22ef\u27e9 * \u27e8fun n => \u2211 m \u2208 range n, y ^ m / \u2191m.factorial, \u22ef\u27e9).lim"}, {"line": "apply (lim_eq_lim_of_equiv _).symm", "tactic_state": "x y : \u2102\nhj :\n  \u2200 (j : \u2115),\n    \u2211 m \u2208 range j, (x + y) ^ m / \u2191m.factorial =\n      \u2211 i \u2208 range j, \u2211 k \u2208 range (i + 1), x ^ k / \u2191k.factorial * (y ^ (i - k) / \u2191(i - k).factorial)\n\u22a2 \u27e8fun n => \u2211 m \u2208 range n, x ^ m / \u2191m.factorial, \u22ef\u27e9 * \u27e8fun n => \u2211 m \u2208 range n, y ^ m / \u2191m.factorial, \u22ef\u27e9 \u2248\n    \u27e8fun n => \u2211 m \u2208 range n, (x + y) ^ m / \u2191m.factorial, \u22ef\u27e9"}, {"line": "simp only [hj]", "tactic_state": "x y : \u2102\nhj :\n  \u2200 (j : \u2115),\n    \u2211 m \u2208 range j, (x + y) ^ m / \u2191m.factorial =\n      \u2211 i \u2208 range j, \u2211 k \u2208 range (i + 1), x ^ k / \u2191k.factorial * (y ^ (i - k) / \u2191(i - k).factorial)\n\u22a2 \u27e8fun n => \u2211 m \u2208 range n, x ^ m / \u2191m.factorial, \u22ef\u27e9 * \u27e8fun n => \u2211 m \u2208 range n, y ^ m / \u2191m.factorial, \u22ef\u27e9 \u2248\n    \u27e8fun n => \u2211 i \u2208 range n, \u2211 k \u2208 range (i + 1), x ^ k / \u2191k.factorial * (y ^ (i - k) / \u2191(i - k).factorial), \u22ef\u27e9"}, {"line": "exact cauchy_product (isCauSeq_norm_exp x) (isCauSeq_exp y)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_sub : exp (x - y) = exp x / exp y := by\n  simp [sub_eq_add_neg, exp_add, exp_neg, div_eq_mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 exp (x - y) = exp x / exp y"}, {"line": "simp [sub_eq_add_neg, exp_add, exp_neg, div_eq_mul_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_int_mul (z : \u2102) (n : \u2124) : Complex.exp (n * z) = Complex.exp z ^ n := by\n  cases n\n  \u00b7 simp [exp_nat_mul]\n  \u00b7 simp [exp_add, add_mul, pow_add, exp_neg, exp_nat_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2102\nn : \u2124\n\u22a2 exp (\u2191n * z) = exp z ^ n"}, {"line": "cases n", "tactic_state": "case ofNat\nz : \u2102\na\u271d : \u2115\n\u22a2 exp (\u2191(Int.ofNat a\u271d) * z) = exp z ^ Int.ofNat a\u271d\n---\ncase negSucc\nz : \u2102\na\u271d : \u2115\n\u22a2 exp (\u2191(Int.negSucc a\u271d) * z) = exp z ^ Int.negSucc a\u271d"}, {"line": "\u00b7 simp [exp_nat_mul]", "tactic_state": "case negSucc\nz : \u2102\na\u271d : \u2115\n\u22a2 exp (\u2191(Int.negSucc a\u271d) * z) = exp z ^ Int.negSucc a\u271d"}, {"line": "\u00b7 simp [exp_add, add_mul, pow_add, exp_neg, exp_nat_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_conj : exp (conj x) = conj (exp x) := by\n  dsimp [exp]\n  rw [\u2190 lim_conj]\n  refine congr_arg CauSeq.lim (CauSeq.ext fun _ => ?_)\n  dsimp [exp', Function.comp_def, cauSeqConj]\n  rw [map_sum (starRingEnd _)]\n  refine sum_congr rfl fun n _ => ?_\n  rw [map_div\u2080]\n  rw [map_pow]\n  rw [\u2190 ofReal_natCast]\n  rw [conj_ofReal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 exp ((starRingEnd \u2102) x) = (starRingEnd \u2102) (exp x)"}, {"line": "dsimp [exp]", "tactic_state": "x : \u2102\n\u22a2 (exp' ((starRingEnd \u2102) x)).lim = (starRingEnd \u2102) (exp' x).lim"}, {"line": "rw [\u2190 lim_conj]", "tactic_state": "x : \u2102\n\u22a2 (exp' ((starRingEnd \u2102) x)).lim = (cauSeqConj (exp' x)).lim"}, {"line": "refine congr_arg CauSeq.lim (CauSeq.ext fun _ => ?_)", "tactic_state": "x : \u2102\nx\u271d : \u2115\n\u22a2 \u2191(exp' ((starRingEnd \u2102) x)) x\u271d = \u2191(cauSeqConj (exp' x)) x\u271d"}, {"line": "dsimp [exp', Function.comp_def, cauSeqConj]", "tactic_state": "x : \u2102\nx\u271d : \u2115\n\u22a2 \u2211 m \u2208 range x\u271d, (starRingEnd \u2102) x ^ m / \u2191m.factorial = (starRingEnd \u2102) (\u2211 m \u2208 range x\u271d, x ^ m / \u2191m.factorial)"}, {"line": "rw [map_sum (starRingEnd _)]", "tactic_state": "x : \u2102\nx\u271d : \u2115\n\u22a2 \u2211 m \u2208 range x\u271d, (starRingEnd \u2102) x ^ m / \u2191m.factorial = \u2211 x_1 \u2208 range x\u271d, (starRingEnd \u2102) (x ^ x_1 / \u2191x_1.factorial)"}, {"line": "refine sum_congr rfl fun n _ => ?_", "tactic_state": "x : \u2102\nx\u271d\u00b9 n : \u2115\nx\u271d : n \u2208 range x\u271d\u00b9\n\u22a2 (starRingEnd \u2102) x ^ n / \u2191n.factorial = (starRingEnd \u2102) (x ^ n / \u2191n.factorial)"}, {"line": "rw [map_div\u2080]", "tactic_state": "x : \u2102\nx\u271d\u00b9 n : \u2115\nx\u271d : n \u2208 range x\u271d\u00b9\n\u22a2 (starRingEnd \u2102) x ^ n / \u2191n.factorial = (starRingEnd \u2102) (x ^ n) / (starRingEnd \u2102) \u2191n.factorial"}, {"line": "rw [map_pow]", "tactic_state": "x : \u2102\nx\u271d\u00b9 n : \u2115\nx\u271d : n \u2208 range x\u271d\u00b9\n\u22a2 (starRingEnd \u2102) x ^ n / \u2191n.factorial = (starRingEnd \u2102) x ^ n / (starRingEnd \u2102) \u2191n.factorial"}, {"line": "rw [\u2190 ofReal_natCast]", "tactic_state": "x : \u2102\nx\u271d\u00b9 n : \u2115\nx\u271d : n \u2208 range x\u271d\u00b9\n\u22a2 (starRingEnd \u2102) x ^ n / \u2191\u2191n.factorial = (starRingEnd \u2102) x ^ n / (starRingEnd \u2102) \u2191\u2191n.factorial"}, {"line": "rw [conj_ofReal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_ofReal_im (x : \u211d) : (exp x).im = 0 := by rw [\u2190 ofReal_exp_ofReal_re, ofReal_im]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 (exp \u2191x).im = 0"}, {"line": "rw [\u2190 ofReal_exp_ofReal_re, ofReal_im]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_zero : exp 0 = 1 := by simp [Real.exp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 exp 0 = 1"}, {"line": "simp [Real.exp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_sub : exp (x - y) = exp x / exp y := by\n  simp [sub_eq_add_neg, exp_add, exp_neg, div_eq_mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 exp (\u2191x - \u2191y) = exp \u2191x / exp \u2191y"}, {"line": "simp [sub_eq_add_neg, exp_add, exp_neg, div_eq_mul_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma norm_exp_le_exp_norm (x : \u2102) : \u2016exp x\u2016 \u2264 Real.exp \u2016x\u2016 := by\n  convert norm_exp_sub_sum_le_exp_norm_sub_sum x 0 using 1 <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 \u2016exp x\u2016 \u2264 Real.exp \u2016x\u2016"}, {"line": "convert norm_exp_sub_sum_le_exp_norm_sub_sum x 0 using 1 <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_bound' {x : \u211d} (h1 : 0 \u2264 x) (h2 : x \u2264 1) {n : \u2115} (hn : 0 < n) :\n    Real.exp x \u2264 (\u2211 m \u2208 Finset.range n, x ^ m / m.factorial) +\n      x ^ n * (n + 1) / (n.factorial * n) := by\n  have h3 : |x| = x := by simpa\n  have h4 : |x| \u2264 1 := by rwa [h3]\n  have h' := Real.exp_bound h4 hn\n  rw [h3] at h'\n  have h'' := (abs_sub_le_iff.1 h').1\n  have t := sub_le_iff_le_add'.1 h''\n  simpa [mul_div_assoc] using t\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nh1 : 0 \u2264 x\nh2 : x \u2264 1\nn : \u2115\nhn : 0 < n\n\u22a2 Real.exp x \u2264 \u2211 m \u2208 range n, x ^ m / \u2191m.factorial + x ^ n * (\u2191n + 1) / (\u2191n.factorial * \u2191n)"}, {"line": "have h3 : |x| = x := by simpa", "tactic_state": "x : \u211d\nh1 : 0 \u2264 x\nh2 : x \u2264 1\nn : \u2115\nhn : 0 < n\nh3 : |x| = x\n\u22a2 Real.exp x \u2264 \u2211 m \u2208 range n, x ^ m / \u2191m.factorial + x ^ n * (\u2191n + 1) / (\u2191n.factorial * \u2191n)"}, {"line": "have h4 : |x| \u2264 1 := sorry", "tactic_state": "x : \u211d\nh1 : 0 \u2264 x\nh2 : x \u2264 1\nn : \u2115\nhn : 0 < n\nh3 : |x| = x\nh4 : |x| \u2264 1\n\u22a2 Real.exp x \u2264 \u2211 m \u2208 range n, x ^ m / \u2191m.factorial + x ^ n * (\u2191n + 1) / (\u2191n.factorial * \u2191n)"}, {"line": "have h' := Real.exp_bound h4 hn", "tactic_state": "x : \u211d\nh1 : 0 \u2264 x\nh2 : x \u2264 1\nn : \u2115\nhn : 0 < n\nh3 : |x| = x\nh4 : |x| \u2264 1\nh' : |Real.exp x - \u2211 m \u2208 range n, x ^ m / \u2191m.factorial| \u2264 |x| ^ n * (\u2191n.succ / (\u2191n.factorial * \u2191n))\n\u22a2 Real.exp x \u2264 \u2211 m \u2208 range n, x ^ m / \u2191m.factorial + x ^ n * (\u2191n + 1) / (\u2191n.factorial * \u2191n)"}, {"line": "rw [h3] at h'", "tactic_state": "x : \u211d\nh1 : 0 \u2264 x\nh2 : x \u2264 1\nn : \u2115\nhn : 0 < n\nh3 : |x| = x\nh4 : |x| \u2264 1\nh' : |Real.exp x - \u2211 m \u2208 range n, x ^ m / \u2191m.factorial| \u2264 x ^ n * (\u2191n.succ / (\u2191n.factorial * \u2191n))\n\u22a2 Real.exp x \u2264 \u2211 m \u2208 range n, x ^ m / \u2191m.factorial + x ^ n * (\u2191n + 1) / (\u2191n.factorial * \u2191n)"}, {"line": "have h'' := (abs_sub_le_iff.1 h').1", "tactic_state": "x : \u211d\nh1 : 0 \u2264 x\nh2 : x \u2264 1\nn : \u2115\nhn : 0 < n\nh3 : |x| = x\nh4 : |x| \u2264 1\nh' : |Real.exp x - \u2211 m \u2208 range n, x ^ m / \u2191m.factorial| \u2264 x ^ n * (\u2191n.succ / (\u2191n.factorial * \u2191n))\nh'' : Real.exp x - \u2211 m \u2208 range n, x ^ m / \u2191m.factorial \u2264 x ^ n * (\u2191n.succ / (\u2191n.factorial * \u2191n))\n\u22a2 Real.exp x \u2264 \u2211 m \u2208 range n, x ^ m / \u2191m.factorial + x ^ n * (\u2191n + 1) / (\u2191n.factorial * \u2191n)"}, {"line": "have t := sub_le_iff_le_add'.1 h''", "tactic_state": "x : \u211d\nh1 : 0 \u2264 x\nh2 : x \u2264 1\nn : \u2115\nhn : 0 < n\nh3 : |x| = x\nh4 : |x| \u2264 1\nh' : |Real.exp x - \u2211 m \u2208 range n, x ^ m / \u2191m.factorial| \u2264 x ^ n * (\u2191n.succ / (\u2191n.factorial * \u2191n))\nh'' : Real.exp x - \u2211 m \u2208 range n, x ^ m / \u2191m.factorial \u2264 x ^ n * (\u2191n.succ / (\u2191n.factorial * \u2191n))\nt : Real.exp x \u2264 \u2211 m \u2208 range n, x ^ m / \u2191m.factorial + x ^ n * (\u2191n.succ / (\u2191n.factorial * \u2191n))\n\u22a2 Real.exp x \u2264 \u2211 m \u2208 range n, x ^ m / \u2191m.factorial + x ^ n * (\u2191n + 1) / (\u2191n.factorial * \u2191n)"}, {"line": "simpa [mul_div_assoc] using t", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_exp_sub_one_le {x : \u211d} (hx : |x| \u2264 1) : |exp x - 1| \u2264 2 * |x| := by\n  have : \u2016(x : \u2102)\u2016 \u2264 1 := mod_cast hx\n  exact_mod_cast Complex.norm_exp_sub_one_le (x := x) this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : |x| \u2264 1\n\u22a2 sorry \u2264 2 * |x|"}, {"line": "have : \u2016(x : \u2102)\u2016 \u2264 1 := mod_cast hx", "tactic_state": "x : \u211d\nhx : |x| \u2264 1\nthis : \u2016\u2191x\u2016 \u2264 1\n\u22a2 sorry \u2264 2 * |x|"}, {"line": "exact_mod_cast Complex.norm_exp_sub_one_le (x := x) this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_exp_sub_one_sub_id_le {x : \u211d} (hx : |x| \u2264 1) : |exp x - 1 - x| \u2264 x ^ 2 := by\n  rw [\u2190 sq_abs]\n  have : \u2016(x : \u2102)\u2016 \u2264 1 := mod_cast hx\n  exact_mod_cast Complex.norm_exp_sub_one_sub_id_le this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : |x| \u2264 1\n\u22a2 sorry \u2264 x ^ 2"}, {"line": "rw [\u2190 sq_abs]", "tactic_state": "x : \u211d\nhx : |x| \u2264 1\n\u22a2 sorry \u2264 |x| ^ 2"}, {"line": "have : \u2016(x : \u2102)\u2016 \u2264 1 := mod_cast hx", "tactic_state": "x : \u211d\nhx : |x| \u2264 1\nthis : \u2016\u2191x\u2016 \u2264 1\n\u22a2 sorry \u2264 |x| ^ 2"}, {"line": "exact_mod_cast Complex.norm_exp_sub_one_sub_id_le this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem expNear_zero (x r) : expNear 0 x r = r := by simp [expNear]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nexpNear : x\u271d\nx : ?m.452\nr : ?m.453 x\n\u22a2 sorry = r"}, {"line": "simp [expNear]", "tactic_state": "x\u271d : Sort u_1\nexpNear : x\u271d\nx : ?m.452\nr : ?m.453 x\n\u22a2 sorry () = r"}]}
{"declaration": "theorem expNear_succ (n x r) : expNear (n + 1) x r = expNear n x (1 + x / (n + 1) * r) := by\n  simp [expNear, range_succ, mul_add, add_left_comm, add_assoc, pow_succ, div_eq_mul_inv,\n      mul_inv, Nat.factorial]\n  ac_rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nexpNear : x\u271d\nn : ?m.864\nx : ?m.865 n\nr : ?m.866 n x\n\u22a2 sorry = sorry"}, {"line": "simp [expNear, range_succ, mul_add, add_left_comm, add_assoc, pow_succ, div_eq_mul_inv,\n      mul_inv, Nat.factorial]", "tactic_state": "x\u271d : Sort u_1\nexpNear : x\u271d\nn : ?m.864\nx : ?m.865 n\nr : ?m.866 n x\n\u22a2 sorry () = sorry ()"}, {"line": "ac_rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem expNear_sub (n x r\u2081 r\u2082) : expNear n x r\u2081 -\n    expNear n x r\u2082 = x ^ n / n.factorial * (r\u2081 - r\u2082) := by\n  simp [expNear, mul_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nexpNear : x\u271d\nn : ?m.6410\nx : ?m.6411 n\nr\u2081 : ?m.6412 n x\nr\u2082 : ?m.6413 n x r\u2081\n\u22a2 sorry - sorry = x ^ n / sorry * (r\u2081 - r\u2082)"}, {"line": "simp [expNear, mul_sub]", "tactic_state": "x\u271d : Sort u_1\nexpNear : x\u271d\nn : ?m.6410\nx : ?m.6411 n\nr\u2081 : ?m.6412 n x\nr\u2082 : ?m.6413 n x r\u2081\n\u22a2 sorry () - sorry () = x ^ n / sorry () * (r\u2081 - r\u2082)"}]}
{"declaration": "theorem exp_approx_end' {n} {x a b : \u211d} (m : \u2115) (e\u2081 : n + 1 = m) (rm : \u211d) (er : \u2191m = rm)\n    (h : |x| \u2264 1) (e : |1 - a| \u2264 b - |x| / rm * ((rm + 1) / rm)) :\n    |exp x - expNear n x a| \u2264 |x| ^ n / n.factorial * b := by\n  subst er\n  exact exp_approx_succ _ e\u2081 _ _ (by simpa using e) (exp_approx_end _ _ _ e\u2081 h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nexpNear : x\u271d\nn : \u2115\nx a b : \u211d\nm : \u2115\ne\u2081 : n + 1 = m\nrm : \u211d\ner : \u2191m = rm\nh : |x| \u2264 1\ne : |1 - a| \u2264 b - |x| / rm * ((rm + 1) / rm)\n\u22a2 sorry \u2264 |x| ^ n / \u2191n.factorial * b"}, {"line": "subst er", "tactic_state": "x\u271d : Sort u_1\nexpNear : x\u271d\nn : \u2115\nx a b : \u211d\nm : \u2115\ne\u2081 : n + 1 = m\nh : |x| \u2264 1\ne : |1 - a| \u2264 b - |x| / \u2191m * ((\u2191m + 1) / \u2191m)\n\u22a2 sorry \u2264 |x| ^ n / \u2191n.factorial * b"}, {"line": "exact exp_approx_succ _ e\u2081 _ _ (by simpa using e) (exp_approx_end _ _ _ e\u2081 h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_approx_start (x a b : \u211d) (h : |exp x - expNear 0 x a| \u2264 |x| ^ 0 / Nat.factorial 0 * b) :\n    |exp x - a| \u2264 b := by simpa using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nexpNear : x\u271d\nx a b : \u211d\nh : sorry \u2264 |x| ^ 0 / \u2191(factorial 0) * b\n\u22a2 sorry \u2264 b"}, {"line": "simpa using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_bound_div_one_sub_of_interval {x : \u211d} (h1 : 0 \u2264 x) (h2 : x < 1) :\n    Real.exp x \u2264 1 / (1 - x) := by\n  rcases eq_or_lt_of_le h1 with (rfl | h1)\n  \u00b7 simp\n  \u00b7 exact (exp_bound_div_one_sub_of_interval' h1 h2).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nh1 : 0 \u2264 x\nh2 : x < 1\n\u22a2 Real.exp x \u2264 1 / (1 - x)"}, {"line": "rcases eq_or_lt_of_le h1 with (rfl | h1)", "tactic_state": "case inl\nh1 : 0 \u2264 0\nh2 : 0 < 1\n\u22a2 Real.exp 0 \u2264 1 / (1 - 0)\n---\ncase inr\nx : \u211d\nh1\u271d : 0 \u2264 x\nh2 : x < 1\nh1 : 0 < x\n\u22a2 Real.exp x \u2264 1 / (1 - x)"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nx : \u211d\nh1\u271d : 0 \u2264 x\nh2 : x < 1\nh1 : 0 < x\n\u22a2 Real.exp x \u2264 1 / (1 - x)"}, {"line": "\u00b7 exact (exp_bound_div_one_sub_of_interval' h1 h2).le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_one_le_exp (x : \u211d) : x + 1 \u2264 Real.exp x := by\n  obtain rfl | hx := eq_or_ne x 0\n  \u00b7 simp\n  \u00b7 exact (add_one_lt_exp hx).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 x + 1 \u2264 Real.exp x"}, {"line": "obtain rfl | hx := eq_or_ne x 0", "tactic_state": "case inl\n\u22a2 0 + 1 \u2264 Real.exp 0\n---\ncase inr\nx : \u211d\nhx : x \u2260 0\n\u22a2 x + 1 \u2264 Real.exp x"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nx : \u211d\nhx : x \u2260 0\n\u22a2 x + 1 \u2264 Real.exp x"}, {"line": "\u00b7 exact (add_one_lt_exp hx).le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_exp_ofReal (x : \u211d) : \u2016exp x\u2016 = Real.exp x := by\n  rw [\u2190 ofReal_exp]\n  exact Complex.norm_of_nonneg (le_of_lt (Real.exp_pos _))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Exponential.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset", "Lean.Meta Qq"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 \u2016exp \u2191x\u2016 = Real.exp x"}, {"line": "rw [\u2190 ofReal_exp]", "tactic_state": "x : \u211d\n\u22a2 \u2016\u2191(Real.exp x)\u2016 = Real.exp x"}, {"line": "exact Complex.norm_of_nonneg (le_of_lt (Real.exp_pos _))", "tactic_state": "No Goals!"}]}
{"declaration": "example {A : Type*} [Ring A] [inst : Algebra \u2102 A] :\n    (inst.complexToReal).toModule = (inst.toModule).complexToReal := by\n  with_reducible_and_instances rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Module.lean", "context": {"open": ["ComplexConjugate", "scoped SMul", "Submodule"], "variables": ["{R : Type*} {S : Type*}", "{A : Type*} [Semiring A] [Algebra \u211d A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\nA\u271d : Type u_3\ninst\u271d\u00b2 : Semiring A\u271d\ninst\u271d\u00b9 : Algebra \u211d A\u271d\nA : Type u_4\ninst\u271d : Ring A\ninst : Algebra \u2102 A\n\u22a2 Algebra.toModule = Module.complexToReal A"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toMatrix_conjAe :\n    LinearMap.toMatrix basisOneI basisOneI conjAe.toLinearMap = !![1, 0; 0, -1] := by\n  ext i j\n  fin_cases i <;> fin_cases j <;> simp [LinearMap.toMatrix_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Module.lean", "context": {"open": ["ComplexConjugate", "scoped SMul", "Submodule", "ComplexConjugate"], "variables": ["{R : Type*} {S : Type*}", "{A : Type*} [Semiring A] [Algebra \u211d A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M\u271d : Type u_4\ninst\u271d\u00b9 : AddCommMonoid M\u271d\ninst\u271d : Module \u2124 M\u271d\nbasisOneI : Basis (Fin 2) \u2124 M\u271d\n\u22a2 (LinearMap.toMatrix basisOneI basisOneI) sorry = !![1, 0; 0, -1]"}, {"line": "ext i j", "tactic_state": "case a\nM\u271d : Type u_4\ninst\u271d\u00b9 : AddCommMonoid M\u271d\ninst\u271d : Module \u2124 M\u271d\nbasisOneI : Basis (Fin 2) \u2124 M\u271d\ni j : Fin 2\n\u22a2 (LinearMap.toMatrix basisOneI basisOneI) sorry i j = !![1, 0; 0, -1] i j"}, {"line": "fin_cases i <;> fin_cases j <;> simp [LinearMap.toMatrix_apply]", "tactic_state": "case a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab0\u00bb.\u00ab0\u00bb\nM\u271d : Type u_4\ninst\u271d\u00b9 : AddCommMonoid M\u271d\ninst\u271d : Module \u2124 M\u271d\nbasisOneI : Basis (Fin 2) \u2124 M\u271d\n\u22a2 (basisOneI.repr ((sorry ()) (basisOneI 0))) 0 = 1\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab0\u00bb.\u00ab1\u00bb\nM\u271d : Type u_4\ninst\u271d\u00b9 : AddCommMonoid M\u271d\ninst\u271d : Module \u2124 M\u271d\nbasisOneI : Basis (Fin 2) \u2124 M\u271d\n\u22a2 (basisOneI.repr ((sorry ()) (basisOneI 1))) 0 = 0\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab1\u00bb.\u00ab0\u00bb\nM\u271d : Type u_4\ninst\u271d\u00b9 : AddCommMonoid M\u271d\ninst\u271d : Module \u2124 M\u271d\nbasisOneI : Basis (Fin 2) \u2124 M\u271d\n\u22a2 (basisOneI.repr ((sorry ()) (basisOneI 0))) 1 = 0\n---\ncase a.\u00ab_@\u00bb.Mathlib.Data.Matrix.Defs._hyg.155.\u00ab1\u00bb.\u00ab1\u00bb\nM\u271d : Type u_4\ninst\u271d\u00b9 : AddCommMonoid M\u271d\ninst\u271d : Module \u2124 M\u271d\nbasisOneI : Basis (Fin 2) \u2124 M\u271d\n\u22a2 (basisOneI.repr ((sorry ()) (basisOneI 1))) 1 = -1"}]}
{"declaration": "theorem liftAux_apply_I (I' : A) (hI') : liftAux I' hI' I = I' := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Module.lean", "context": {"open": ["ComplexConjugate", "scoped SMul", "Submodule", "ComplexConjugate"], "variables": ["{R : Type*} {S : Type*}", "{A : Type*} [Semiring A] [Algebra \u211d A]", "{A : Type*} [Ring A] [Algebra \u211d A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_4\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra \u211d A\nx\u271d : Sort u_5\nliftAux : x\u271d\nI' : A\nhI' : ?m.904 I'\n\u22a2 sorry = I'"}, {"line": "simp", "tactic_state": "A : Type u_4\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra \u211d A\nx\u271d : Sort u_5\nliftAux : x\u271d\nI' : A\nhI' : ?m.904 I'\n\u22a2 sorry () = I'"}]}
{"declaration": "theorem realPart_apply_coe (a : A) : (\u211c a : A) = (2 : \u211d)\u207b\u00b9 \u2022 (a + star a) := by\n  unfold realPart\n  simp only [selfAdjointPart_apply_coe]\n  simp only [invOf_eq_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Module.lean", "context": {"open": ["ComplexConjugate", "scoped SMul", "Submodule", "ComplexConjugate", "Complex", "ComplexStarModule"], "variables": ["{R : Type*} {S : Type*}", "{A : Type*} [Semiring A] [Algebra \u211d A]", "{A : Type*} [Ring A] [Algebra \u211d A]", "{A : Type*} [AddCommGroup A] [Module \u2102 A] [StarAddMonoid A] [StarModule \u2102 A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_5\ninst\u271d\u00b3 : AddCommGroup A\ninst\u271d\u00b2 : Module \u2102 A\ninst\u271d\u00b9 : StarAddMonoid A\ninst\u271d : StarModule \u2102 A\na : A\n\u22a2 \u2191(realPart a) = 2\u207b\u00b9 \u2022 (a + star a)"}, {"line": "unfold realPart", "tactic_state": "A : Type u_5\ninst\u271d\u00b3 : AddCommGroup A\ninst\u271d\u00b2 : Module \u2102 A\ninst\u271d\u00b9 : StarAddMonoid A\ninst\u271d : StarModule \u2102 A\na : A\n\u22a2 \u2191((selfAdjointPart \u211d) a) = 2\u207b\u00b9 \u2022 (a + star a)"}, {"line": "simp only [selfAdjointPart_apply_coe]", "tactic_state": "A : Type u_5\ninst\u271d\u00b3 : AddCommGroup A\ninst\u271d\u00b2 : Module \u2102 A\ninst\u271d\u00b9 : StarAddMonoid A\ninst\u271d : StarModule \u2102 A\na : A\n\u22a2 \u215f 2 \u2022 (a + star a) = 2\u207b\u00b9 \u2022 (a + star a)"}, {"line": "simp only [invOf_eq_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem realPart_add_I_smul_imaginaryPart (a : A) : (\u211c a : A) + I \u2022 (\u2111 a : A) = a := by\n  simpa only [smul_smul,realPart_apply_coe,imaginaryPart_apply_coe,neg_smul,I_mul_I,one_smul,neg_sub,add_add_sub_cancel,smul_sub,smul_add,neg_sub_neg,invOf_eq_inv] using\n    invOf_two_smul_add_invOf_two_smul \u211d a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Module.lean", "context": {"open": ["ComplexConjugate", "scoped SMul", "Submodule", "ComplexConjugate", "Complex", "ComplexStarModule"], "variables": ["{R : Type*} {S : Type*}", "{A : Type*} [Semiring A] [Algebra \u211d A]", "{A : Type*} [Ring A] [Algebra \u211d A]", "{A : Type*} [AddCommGroup A] [Module \u2102 A] [StarAddMonoid A] [StarModule \u2102 A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_5\ninst\u271d\u00b3 : AddCommGroup A\ninst\u271d\u00b2 : Module \u2102 A\ninst\u271d\u00b9 : StarAddMonoid A\ninst\u271d : StarModule \u2102 A\na : A\n\u22a2 \u2191(realPart a) + I \u2022 \u2191(imaginaryPart a) = a"}, {"line": "simpa only [smul_smul,realPart_apply_coe,imaginaryPart_apply_coe,neg_smul,I_mul_I,one_smul,neg_sub,add_add_sub_cancel,smul_sub,smul_add,neg_sub_neg,invOf_eq_inv] using\n    invOf_two_smul_add_invOf_two_smul \u211d a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem realPart_I_smul (a : A) : \u211c (I \u2022 a) = -\u2111 a := by\n  ext\n  simp [realPart_apply_coe, imaginaryPart_apply_coe, smul_comm I, sub_eq_add_neg, add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Module.lean", "context": {"open": ["ComplexConjugate", "scoped SMul", "Submodule", "ComplexConjugate", "Complex", "ComplexStarModule"], "variables": ["{R : Type*} {S : Type*}", "{A : Type*} [Semiring A] [Algebra \u211d A]", "{A : Type*} [Ring A] [Algebra \u211d A]", "{A : Type*} [AddCommGroup A] [Module \u2102 A] [StarAddMonoid A] [StarModule \u2102 A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_5\ninst\u271d\u00b3 : AddCommGroup A\ninst\u271d\u00b2 : Module \u2102 A\ninst\u271d\u00b9 : StarAddMonoid A\ninst\u271d : StarModule \u2102 A\na : A\n\u22a2 realPart (I \u2022 a) = -imaginaryPart a"}, {"line": "ext", "tactic_state": "case a\nA : Type u_5\ninst\u271d\u00b3 : AddCommGroup A\ninst\u271d\u00b2 : Module \u2102 A\ninst\u271d\u00b9 : StarAddMonoid A\ninst\u271d : StarModule \u2102 A\na : A\n\u22a2 \u2191(realPart (I \u2022 a)) = \u2191(-imaginaryPart a)"}, {"line": "simp [realPart_apply_coe, imaginaryPart_apply_coe, smul_comm I, sub_eq_add_neg, add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem imaginaryPart_I_smul (a : A) : \u2111 (I \u2022 a) = \u211c a := by\n  ext\n  simp [realPart_apply_coe, imaginaryPart_apply_coe, smul_comm I (2\u207b\u00b9 : \u211d), smul_smul I]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Module.lean", "context": {"open": ["ComplexConjugate", "scoped SMul", "Submodule", "ComplexConjugate", "Complex", "ComplexStarModule"], "variables": ["{R : Type*} {S : Type*}", "{A : Type*} [Semiring A] [Algebra \u211d A]", "{A : Type*} [Ring A] [Algebra \u211d A]", "{A : Type*} [AddCommGroup A] [Module \u2102 A] [StarAddMonoid A] [StarModule \u2102 A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_5\ninst\u271d\u00b3 : AddCommGroup A\ninst\u271d\u00b2 : Module \u2102 A\ninst\u271d\u00b9 : StarAddMonoid A\ninst\u271d : StarModule \u2102 A\na : A\n\u22a2 imaginaryPart (I \u2022 a) = realPart a"}, {"line": "ext", "tactic_state": "case a\nA : Type u_5\ninst\u271d\u00b3 : AddCommGroup A\ninst\u271d\u00b2 : Module \u2102 A\ninst\u271d\u00b9 : StarAddMonoid A\ninst\u271d : StarModule \u2102 A\na : A\n\u22a2 \u2191(imaginaryPart (I \u2022 a)) = \u2191(realPart a)"}, {"line": "simp [realPart_apply_coe, imaginaryPart_apply_coe, smul_comm I (2\u207b\u00b9 : \u211d), smul_smul I]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma skewAdjointPart_eq_I_smul_imaginaryPart (x : A) :\n    (skewAdjointPart \u211d x : A) = I \u2022 (imaginaryPart x : A) := by\n  simp [imaginaryPart_apply_coe, smul_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Module.lean", "context": {"open": ["ComplexConjugate", "scoped SMul", "Submodule", "ComplexConjugate", "Complex", "ComplexStarModule"], "variables": ["{R : Type*} {S : Type*}", "{A : Type*} [Semiring A] [Algebra \u211d A]", "{A : Type*} [Ring A] [Algebra \u211d A]", "{A : Type*} [AddCommGroup A] [Module \u2102 A] [StarAddMonoid A] [StarModule \u2102 A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_5\ninst\u271d\u00b3 : AddCommGroup A\ninst\u271d\u00b2 : Module \u2102 A\ninst\u271d\u00b9 : StarAddMonoid A\ninst\u271d : StarModule \u2102 A\nx : A\n\u22a2 \u2191((skewAdjointPart \u211d) x) = I \u2022 \u2191(imaginaryPart x)"}, {"line": "simp [imaginaryPart_apply_coe, smul_smul]", "tactic_state": "A : Type u_5\ninst\u271d\u00b3 : AddCommGroup A\ninst\u271d\u00b2 : Module \u2102 A\ninst\u271d\u00b9 : StarAddMonoid A\ninst\u271d : StarModule \u2102 A\nx : A\n\u22a2 2\u207b\u00b9 \u2022 (x - star x) = - -(2\u207b\u00b9 \u2022 (x - star x))"}]}
{"declaration": "lemma Complex.coe_selfAdjointEquiv (z : selfAdjoint \u2102) :\n    (selfAdjointEquiv z : \u2102) = z := by\n  simpa [selfAdjointEquiv_symm_apply]\n    using (congr_arg Subtype.val <| Complex.selfAdjointEquiv.left_inv z)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Module.lean", "context": {"open": ["ComplexConjugate", "scoped SMul", "Submodule", "ComplexConjugate", "Complex", "ComplexStarModule", "Submodule"], "variables": ["{R : Type*} {S : Type*}", "{A : Type*} [Semiring A] [Algebra \u211d A]", "{A : Type*} [Ring A] [Algebra \u211d A]", "{A : Type*} [AddCommGroup A] [Module \u2102 A] [StarAddMonoid A] [StarModule \u2102 A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u21a5(selfAdjoint \u2102)\n\u22a2 \u2191(selfAdjointEquiv z) = \u2191z"}, {"line": "simpa [selfAdjointEquiv_symm_apply]\n    using (congr_arg Subtype.val <| Complex.selfAdjointEquiv.left_inv z)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma realPart_ofReal (r : \u211d) : (\u211c (r : \u2102) : \u2102) = r := by\n  rw [realPart_apply_coe]\n  rw [star_def]\n  rw [conj_ofReal]\n  rw [\u2190 two_smul \u211d (r : \u2102)]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Module.lean", "context": {"open": ["ComplexConjugate", "scoped SMul", "Submodule", "ComplexConjugate", "Complex", "ComplexStarModule", "Submodule"], "variables": ["{R : Type*} {S : Type*}", "{A : Type*} [Semiring A] [Algebra \u211d A]", "{A : Type*} [Ring A] [Algebra \u211d A]", "{A : Type*} [AddCommGroup A] [Module \u2102 A] [StarAddMonoid A] [StarModule \u2102 A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\n\u22a2 \u2191(realPart \u2191r) = \u2191r"}, {"line": "rw [realPart_apply_coe]", "tactic_state": "r : \u211d\n\u22a2 2\u207b\u00b9 \u2022 (\u2191r + star \u2191r) = \u2191r"}, {"line": "rw [star_def]", "tactic_state": "r : \u211d\n\u22a2 2\u207b\u00b9 \u2022 (\u2191r + (starRingEnd \u2102) \u2191r) = \u2191r"}, {"line": "rw [conj_ofReal]", "tactic_state": "r : \u211d\n\u22a2 2\u207b\u00b9 \u2022 (\u2191r + \u2191r) = \u2191r"}, {"line": "rw [\u2190 two_smul \u211d (r : \u2102)]", "tactic_state": "r : \u211d\n\u22a2 2\u207b\u00b9 \u2022 2 \u2022 \u2191r = \u2191r"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_conj (z : \u2102) : \u2016conj z\u2016 = \u2016z\u2016 := by simp [norm_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Norm.lean", "context": {"open": ["ComplexConjugate Topology Filter Set"], "variables": ["{z : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2102\n\u22a2 \u2016(starRingEnd \u2102) z\u2016 = \u2016z\u2016"}, {"line": "simp [norm_def]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma norm_real (r : \u211d) : \u2016(r : \u2102)\u2016 = \u2016r\u2016 := by\n  simp [norm_def, Real.sqrt_mul_self_eq_abs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Norm.lean", "context": {"open": ["ComplexConjugate Topology Filter Set"], "variables": ["{z : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\n\u22a2 \u2016\u2191r\u2016 = \u2016r\u2016"}, {"line": "simp [norm_def, Real.sqrt_mul_self_eq_abs]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nnnorm_nnratCast (q : \u211a\u22650) : \u2016(q : \u2102)\u2016\u208a = q := by simp [nnnorm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Norm.lean", "context": {"open": ["ComplexConjugate Topology Filter Set"], "variables": ["{z : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : \u211a\u22650\n\u22a2 \u2016\u2191q\u2016\u208a = \u2191q"}, {"line": "simp [nnnorm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma normSq_eq_norm_sq (z : \u2102) : normSq z = \u2016z\u2016 ^ 2 := by\n  simp [norm_def, sq, Real.mul_self_sqrt (normSq_nonneg _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Norm.lean", "context": {"open": ["ComplexConjugate Topology Filter Set"], "variables": ["{z : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nnormSq : x\u271d\nz : \u2102\n\u22a2 sorry = \u2016z\u2016 ^ 2"}, {"line": "simp [norm_def, sq, Real.mul_self_sqrt (normSq_nonneg _)]", "tactic_state": "x\u271d : Sort u_1\nnormSq : x\u271d\nz : \u2102\n\u22a2 sorry () = \u2016z\u2016 * \u2016z\u2016"}]}
{"declaration": "theorem abs_im_lt_norm {z : \u2102} : |z.im| < \u2016z\u2016 \u2194 z.re \u2260 0 := by\n  simpa using @abs_re_lt_norm (z * I)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Norm.lean", "context": {"open": ["ComplexConjugate Topology Filter Set"], "variables": ["{z : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2102\n\u22a2 |z.im| < \u2016z\u2016 \u2194 z.re \u2260 0"}, {"line": "simpa using @abs_re_lt_norm (z * I)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_eq_re_im (z w : \u2102) : dist z w = \u221a((z.re - w.re) ^ 2 + (z.im - w.im) ^ 2) := by\n  rw [sq]\n  rw [sq]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Norm.lean", "context": {"open": ["ComplexConjugate Topology Filter Set"], "variables": ["{z : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z w : \u2102\n\u22a2 dist z w = \u221a((z.re - w.re) ^ 2 + (z.im - w.im) ^ 2)"}, {"line": "rw [sq]", "tactic_state": "z w : \u2102\n\u22a2 dist z w = \u221a((z.re - w.re) * (z.re - w.re) + (z.im - w.im) ^ 2)"}, {"line": "rw [sq]", "tactic_state": "z w : \u2102\n\u22a2 dist z w = \u221a((z.re - w.re) * (z.re - w.re) + (z.im - w.im) * (z.im - w.im))"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem real_le_real {x y : \u211d} : (x : \u2102) \u2264 (y : \u2102) \u2194 x \u2264 y := by simp [le_def, ofReal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Order.lean", "context": {"open": ["ComplexOrder"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 \u2191x \u2264 \u2191y \u2194 x \u2264 y"}, {"line": "simp [le_def, ofReal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem real_lt_real {x y : \u211d} : (x : \u2102) < (y : \u2102) \u2194 x < y := by simp [lt_def, ofReal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Order.lean", "context": {"open": ["ComplexOrder"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 \u2191x < \u2191y \u2194 x < y"}, {"line": "simp [lt_def, ofReal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_zero : sinh 0 = 0 := by simp [sinh]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sinh 0 = 0"}, {"line": "simp [sinh]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_neg : sinh (-x) = -sinh x := by simp [sinh, exp_neg, (neg_div _ _).symm, add_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 sinh (-x) = -sinh x"}, {"line": "simp [sinh, exp_neg, (neg_div _ _).symm, add_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem sinh_add_aux {a b c d : \u2102} :\n    (a - b) * (c + d) + (a + b) * (c - d) = 2 * (a * c - b * d) := by ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2102\n\u22a2 (a - b) * (c + d) + (a + b) * (c - d) = 2 * (a * c - b * d)"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_add : sinh (x + y) = sinh x * cosh y + cosh x * sinh y := by\n  rw [\u2190 mul_right_inj' (two_ne_zero' \u2102)]\n  rw [two_sinh]\n  rw [exp_add]\n  rw [neg_add]\n  rw [exp_add]\n  rw [eq_comm]\n  rw [mul_add]\n  rw [\u2190     mul_assoc]\n  rw [two_sinh]\n  rw [mul_left_comm]\n  rw [two_sinh]\n  rw [\u2190 mul_right_inj' (two_ne_zero' \u2102)]\n  rw [mul_add]\n  rw [mul_left_comm]\n  rw [two_cosh]\n  rw [\u2190 mul_assoc]\n  rw [two_cosh]\n  exact sinh_add_aux\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 sinh (x + y) = sinh x * cosh y + cosh x * sinh y"}, {"line": "rw [\u2190 mul_right_inj' (two_ne_zero' \u2102)]", "tactic_state": "x y : \u2102\n\u22a2 2 * sinh (x + y) = 2 * (sinh x * cosh y + cosh x * sinh y)"}, {"line": "rw [two_sinh]", "tactic_state": "x y : \u2102\n\u22a2 exp (x + y) - exp (-(x + y)) = 2 * (sinh x * cosh y + cosh x * sinh y)"}, {"line": "rw [exp_add]", "tactic_state": "x y : \u2102\n\u22a2 exp x * exp y - exp (-(x + y)) = 2 * (sinh x * cosh y + cosh x * sinh y)"}, {"line": "rw [neg_add]", "tactic_state": "x y : \u2102\n\u22a2 exp x * exp y - exp (-x + -y) = 2 * (sinh x * cosh y + cosh x * sinh y)"}, {"line": "rw [exp_add]", "tactic_state": "x y : \u2102\n\u22a2 exp x * exp y - exp (-x) * exp (-y) = 2 * (sinh x * cosh y + cosh x * sinh y)"}, {"line": "rw [eq_comm]", "tactic_state": "x y : \u2102\n\u22a2 2 * (sinh x * cosh y + cosh x * sinh y) = exp x * exp y - exp (-x) * exp (-y)"}, {"line": "rw [mul_add]", "tactic_state": "x y : \u2102\n\u22a2 2 * (sinh x * cosh y) + 2 * (cosh x * sinh y) = exp x * exp y - exp (-x) * exp (-y)"}, {"line": "rw [\u2190     mul_assoc]", "tactic_state": "x y : \u2102\n\u22a2 2 * sinh x * cosh y + 2 * (cosh x * sinh y) = exp x * exp y - exp (-x) * exp (-y)"}, {"line": "rw [two_sinh]", "tactic_state": "x y : \u2102\n\u22a2 (exp x - exp (-x)) * cosh y + 2 * (cosh x * sinh y) = exp x * exp y - exp (-x) * exp (-y)"}, {"line": "rw [mul_left_comm]", "tactic_state": "x y : \u2102\n\u22a2 (exp x - exp (-x)) * cosh y + cosh x * (2 * sinh y) = exp x * exp y - exp (-x) * exp (-y)"}, {"line": "rw [two_sinh]", "tactic_state": "x y : \u2102\n\u22a2 (exp x - exp (-x)) * cosh y + cosh x * (exp y - exp (-y)) = exp x * exp y - exp (-x) * exp (-y)"}, {"line": "rw [\u2190 mul_right_inj' (two_ne_zero' \u2102)]", "tactic_state": "x y : \u2102\n\u22a2 2 * ((exp x - exp (-x)) * cosh y + cosh x * (exp y - exp (-y))) = 2 * (exp x * exp y - exp (-x) * exp (-y))"}, {"line": "rw [mul_add]", "tactic_state": "x y : \u2102\n\u22a2 2 * ((exp x - exp (-x)) * cosh y) + 2 * (cosh x * (exp y - exp (-y))) = 2 * (exp x * exp y - exp (-x) * exp (-y))"}, {"line": "rw [mul_left_comm]", "tactic_state": "x y : \u2102\n\u22a2 (exp x - exp (-x)) * (2 * cosh y) + 2 * (cosh x * (exp y - exp (-y))) = 2 * (exp x * exp y - exp (-x) * exp (-y))"}, {"line": "rw [two_cosh]", "tactic_state": "x y : \u2102\n\u22a2 (exp x - exp (-x)) * (exp y + exp (-y)) + 2 * (cosh x * (exp y - exp (-y))) =\n    2 * (exp x * exp y - exp (-x) * exp (-y))"}, {"line": "rw [\u2190 mul_assoc]", "tactic_state": "x y : \u2102\n\u22a2 (exp x - exp (-x)) * (exp y + exp (-y)) + 2 * cosh x * (exp y - exp (-y)) = 2 * (exp x * exp y - exp (-x) * exp (-y))"}, {"line": "rw [two_cosh]", "tactic_state": "x y : \u2102\n\u22a2 (exp x - exp (-x)) * (exp y + exp (-y)) + (exp x + exp (-x)) * (exp y - exp (-y)) =\n    2 * (exp x * exp y - exp (-x) * exp (-y))"}, {"line": "exact sinh_add_aux", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cosh_zero : cosh 0 = 1 := by simp [cosh]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 cosh 0 = 1"}, {"line": "simp [cosh]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cosh_neg : cosh (-x) = cosh x := by simp [add_comm, cosh, exp_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cosh (-x) = cosh x"}, {"line": "simp [add_comm, cosh, exp_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem cosh_add_aux {a b c d : \u2102} :\n    (a + b) * (c + d) + (a - b) * (c - d) = 2 * (a * c + b * d) := by ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2102\n\u22a2 (a + b) * (c + d) + (a - b) * (c - d) = 2 * (a * c + b * d)"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cosh_add : cosh (x + y) = cosh x * cosh y + sinh x * sinh y := by\n  rw [\u2190 mul_right_inj' (two_ne_zero' \u2102)]\n  rw [two_cosh]\n  rw [exp_add]\n  rw [neg_add]\n  rw [exp_add]\n  rw [eq_comm]\n  rw [mul_add]\n  rw [\u2190     mul_assoc]\n  rw [two_cosh]\n  rw [\u2190 mul_assoc]\n  rw [two_sinh]\n  rw [\u2190 mul_right_inj' (two_ne_zero' \u2102)]\n  rw [mul_add]\n  rw [mul_left_comm]\n  rw [two_cosh]\n  rw [mul_left_comm]\n  rw [two_sinh]\n  exact cosh_add_aux\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 cosh (x + y) = cosh x * cosh y + sinh x * sinh y"}, {"line": "rw [\u2190 mul_right_inj' (two_ne_zero' \u2102)]", "tactic_state": "x y : \u2102\n\u22a2 2 * cosh (x + y) = 2 * (cosh x * cosh y + sinh x * sinh y)"}, {"line": "rw [two_cosh]", "tactic_state": "x y : \u2102\n\u22a2 exp (x + y) + exp (-(x + y)) = 2 * (cosh x * cosh y + sinh x * sinh y)"}, {"line": "rw [exp_add]", "tactic_state": "x y : \u2102\n\u22a2 exp x * exp y + exp (-(x + y)) = 2 * (cosh x * cosh y + sinh x * sinh y)"}, {"line": "rw [neg_add]", "tactic_state": "x y : \u2102\n\u22a2 exp x * exp y + exp (-x + -y) = 2 * (cosh x * cosh y + sinh x * sinh y)"}, {"line": "rw [exp_add]", "tactic_state": "x y : \u2102\n\u22a2 exp x * exp y + exp (-x) * exp (-y) = 2 * (cosh x * cosh y + sinh x * sinh y)"}, {"line": "rw [eq_comm]", "tactic_state": "x y : \u2102\n\u22a2 2 * (cosh x * cosh y + sinh x * sinh y) = exp x * exp y + exp (-x) * exp (-y)"}, {"line": "rw [mul_add]", "tactic_state": "x y : \u2102\n\u22a2 2 * (cosh x * cosh y) + 2 * (sinh x * sinh y) = exp x * exp y + exp (-x) * exp (-y)"}, {"line": "rw [\u2190     mul_assoc]", "tactic_state": "x y : \u2102\n\u22a2 2 * cosh x * cosh y + 2 * (sinh x * sinh y) = exp x * exp y + exp (-x) * exp (-y)"}, {"line": "rw [two_cosh]", "tactic_state": "x y : \u2102\n\u22a2 (exp x + exp (-x)) * cosh y + 2 * (sinh x * sinh y) = exp x * exp y + exp (-x) * exp (-y)"}, {"line": "rw [\u2190 mul_assoc]", "tactic_state": "x y : \u2102\n\u22a2 (exp x + exp (-x)) * cosh y + 2 * sinh x * sinh y = exp x * exp y + exp (-x) * exp (-y)"}, {"line": "rw [two_sinh]", "tactic_state": "x y : \u2102\n\u22a2 (exp x + exp (-x)) * cosh y + (exp x - exp (-x)) * sinh y = exp x * exp y + exp (-x) * exp (-y)"}, {"line": "rw [\u2190 mul_right_inj' (two_ne_zero' \u2102)]", "tactic_state": "x y : \u2102\n\u22a2 2 * ((exp x + exp (-x)) * cosh y + (exp x - exp (-x)) * sinh y) = 2 * (exp x * exp y + exp (-x) * exp (-y))"}, {"line": "rw [mul_add]", "tactic_state": "x y : \u2102\n\u22a2 2 * ((exp x + exp (-x)) * cosh y) + 2 * ((exp x - exp (-x)) * sinh y) = 2 * (exp x * exp y + exp (-x) * exp (-y))"}, {"line": "rw [mul_left_comm]", "tactic_state": "x y : \u2102\n\u22a2 (exp x + exp (-x)) * (2 * cosh y) + 2 * ((exp x - exp (-x)) * sinh y) = 2 * (exp x * exp y + exp (-x) * exp (-y))"}, {"line": "rw [two_cosh]", "tactic_state": "x y : \u2102\n\u22a2 (exp x + exp (-x)) * (exp y + exp (-y)) + 2 * ((exp x - exp (-x)) * sinh y) =\n    2 * (exp x * exp y + exp (-x) * exp (-y))"}, {"line": "rw [mul_left_comm]", "tactic_state": "x y : \u2102\n\u22a2 (exp x + exp (-x)) * (exp y + exp (-y)) + (exp x - exp (-x)) * (2 * sinh y) =\n    2 * (exp x * exp y + exp (-x) * exp (-y))"}, {"line": "rw [two_sinh]", "tactic_state": "x y : \u2102\n\u22a2 (exp x + exp (-x)) * (exp y + exp (-y)) + (exp x - exp (-x)) * (exp y - exp (-y)) =\n    2 * (exp x * exp y + exp (-x) * exp (-y))"}, {"line": "exact cosh_add_aux", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_sub : sinh (x - y) = sinh x * cosh y - cosh x * sinh y := by\n  simp [sub_eq_add_neg, sinh_add, sinh_neg, cosh_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 sinh (x - y) = sinh x * cosh y - cosh x * sinh y"}, {"line": "simp [sub_eq_add_neg, sinh_add, sinh_neg, cosh_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cosh_sub : cosh (x - y) = cosh x * cosh y - sinh x * sinh y := by\n  simp [sub_eq_add_neg, cosh_add, sinh_neg, cosh_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 cosh (x - y) = cosh x * cosh y - sinh x * sinh y"}, {"line": "simp [sub_eq_add_neg, cosh_add, sinh_neg, cosh_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_conj : sinh (conj x) = conj (sinh x) := by\n  rw [sinh]\n  rw [\u2190 RingHom.map_neg]\n  rw [exp_conj]\n  rw [exp_conj]\n  rw [\u2190 RingHom.map_sub]\n  rw [sinh]\n  rw [map_div\u2080]\n  rw [map_ofNat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 sinh ((starRingEnd \u2102) x) = (starRingEnd \u2102) (sinh x)"}, {"line": "rw [sinh]", "tactic_state": "x : \u2102\n\u22a2 (exp ((starRingEnd \u2102) x) - exp (-(starRingEnd \u2102) x)) / 2 = (starRingEnd \u2102) (sinh x)"}, {"line": "rw [\u2190 RingHom.map_neg]", "tactic_state": "x : \u2102\n\u22a2 (exp ((starRingEnd \u2102) x) - exp ((starRingEnd \u2102) (-x))) / 2 = (starRingEnd \u2102) (sinh x)"}, {"line": "rw [exp_conj]", "tactic_state": "x : \u2102\n\u22a2 ((starRingEnd \u2102) (exp x) - exp ((starRingEnd \u2102) (-x))) / 2 = (starRingEnd \u2102) (sinh x)"}, {"line": "rw [exp_conj]", "tactic_state": "x : \u2102\n\u22a2 ((starRingEnd \u2102) (exp x) - (starRingEnd \u2102) (exp (-x))) / 2 = (starRingEnd \u2102) (sinh x)"}, {"line": "rw [\u2190 RingHom.map_sub]", "tactic_state": "x : \u2102\n\u22a2 (starRingEnd \u2102) (exp x - exp (-x)) / 2 = (starRingEnd \u2102) (sinh x)"}, {"line": "rw [sinh]", "tactic_state": "x : \u2102\n\u22a2 (starRingEnd \u2102) (exp x - exp (-x)) / 2 = (starRingEnd \u2102) ((exp x - exp (-x)) / 2)"}, {"line": "rw [map_div\u2080]", "tactic_state": "x : \u2102\n\u22a2 (starRingEnd \u2102) (exp x - exp (-x)) / 2 = (starRingEnd \u2102) (exp x - exp (-x)) / (starRingEnd \u2102) 2"}, {"line": "rw [map_ofNat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_ofReal_im (x : \u211d) : (sinh x).im = 0 := by rw [\u2190 ofReal_sinh_ofReal_re, ofReal_im]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 (sinh \u2191x).im = 0"}, {"line": "rw [\u2190 ofReal_sinh_ofReal_re, ofReal_im]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cosh_conj : cosh (conj x) = conj (cosh x) := by\n  rw [cosh]\n  rw [\u2190 RingHom.map_neg]\n  rw [exp_conj]\n  rw [exp_conj]\n  rw [\u2190 RingHom.map_add]\n  rw [cosh]\n  rw [map_div\u2080]\n  rw [map_ofNat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cosh ((starRingEnd \u2102) x) = (starRingEnd \u2102) (cosh x)"}, {"line": "rw [cosh]", "tactic_state": "x : \u2102\n\u22a2 (exp ((starRingEnd \u2102) x) + exp (-(starRingEnd \u2102) x)) / 2 = (starRingEnd \u2102) (cosh x)"}, {"line": "rw [\u2190 RingHom.map_neg]", "tactic_state": "x : \u2102\n\u22a2 (exp ((starRingEnd \u2102) x) + exp ((starRingEnd \u2102) (-x))) / 2 = (starRingEnd \u2102) (cosh x)"}, {"line": "rw [exp_conj]", "tactic_state": "x : \u2102\n\u22a2 ((starRingEnd \u2102) (exp x) + exp ((starRingEnd \u2102) (-x))) / 2 = (starRingEnd \u2102) (cosh x)"}, {"line": "rw [exp_conj]", "tactic_state": "x : \u2102\n\u22a2 ((starRingEnd \u2102) (exp x) + (starRingEnd \u2102) (exp (-x))) / 2 = (starRingEnd \u2102) (cosh x)"}, {"line": "rw [\u2190 RingHom.map_add]", "tactic_state": "x : \u2102\n\u22a2 (starRingEnd \u2102) (exp x + exp (-x)) / 2 = (starRingEnd \u2102) (cosh x)"}, {"line": "rw [cosh]", "tactic_state": "x : \u2102\n\u22a2 (starRingEnd \u2102) (exp x + exp (-x)) / 2 = (starRingEnd \u2102) ((exp x + exp (-x)) / 2)"}, {"line": "rw [map_div\u2080]", "tactic_state": "x : \u2102\n\u22a2 (starRingEnd \u2102) (exp x + exp (-x)) / 2 = (starRingEnd \u2102) (exp x + exp (-x)) / (starRingEnd \u2102) 2"}, {"line": "rw [map_ofNat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cosh_ofReal_im (x : \u211d) : (cosh x).im = 0 := by rw [\u2190 ofReal_cosh_ofReal_re, ofReal_im]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 (cosh \u2191x).im = 0"}, {"line": "rw [\u2190 ofReal_cosh_ofReal_re, ofReal_im]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tanh_zero : tanh 0 = 0 := by simp [tanh]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 tanh 0 = 0"}, {"line": "simp [tanh]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tanh_neg : tanh (-x) = -tanh x := by simp [tanh, neg_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 tanh (-x) = -tanh x"}, {"line": "simp [tanh, neg_div]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tanh_conj : tanh (conj x) = conj (tanh x) := by\n  rw [tanh]\n  rw [sinh_conj]\n  rw [cosh_conj]\n  rw [\u2190 map_div\u2080]\n  rw [tanh]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 tanh ((starRingEnd \u2102) x) = (starRingEnd \u2102) (tanh x)"}, {"line": "rw [tanh]", "tactic_state": "x : \u2102\n\u22a2 sinh ((starRingEnd \u2102) x) / cosh ((starRingEnd \u2102) x) = (starRingEnd \u2102) (tanh x)"}, {"line": "rw [sinh_conj]", "tactic_state": "x : \u2102\n\u22a2 (starRingEnd \u2102) (sinh x) / cosh ((starRingEnd \u2102) x) = (starRingEnd \u2102) (tanh x)"}, {"line": "rw [cosh_conj]", "tactic_state": "x : \u2102\n\u22a2 (starRingEnd \u2102) (sinh x) / (starRingEnd \u2102) (cosh x) = (starRingEnd \u2102) (tanh x)"}, {"line": "rw [\u2190 map_div\u2080]", "tactic_state": "x : \u2102\n\u22a2 (starRingEnd \u2102) (sinh x / cosh x) = (starRingEnd \u2102) (tanh x)"}, {"line": "rw [tanh]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tanh_ofReal_im (x : \u211d) : (tanh x).im = 0 := by rw [\u2190 ofReal_tanh_ofReal_re, ofReal_im]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 (tanh \u2191x).im = 0"}, {"line": "rw [\u2190 ofReal_tanh_ofReal_re, ofReal_im]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cosh_add_sinh : cosh x + sinh x = exp x := by\n  rw [\u2190 mul_right_inj' (two_ne_zero' \u2102)]\n  rw [mul_add]\n  rw [two_cosh]\n  rw [two_sinh]\n  rw [add_add_sub_cancel]\n  rw [two_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cosh x + sinh x = exp x"}, {"line": "rw [\u2190 mul_right_inj' (two_ne_zero' \u2102)]", "tactic_state": "x : \u2102\n\u22a2 2 * (cosh x + sinh x) = 2 * exp x"}, {"line": "rw [mul_add]", "tactic_state": "x : \u2102\n\u22a2 2 * cosh x + 2 * sinh x = 2 * exp x"}, {"line": "rw [two_cosh]", "tactic_state": "x : \u2102\n\u22a2 exp x + exp (-x) + 2 * sinh x = 2 * exp x"}, {"line": "rw [two_sinh]", "tactic_state": "x : \u2102\n\u22a2 exp x + exp (-x) + (exp x - exp (-x)) = 2 * exp x"}, {"line": "rw [add_add_sub_cancel]", "tactic_state": "x : \u2102\n\u22a2 exp x + exp x = 2 * exp x"}, {"line": "rw [two_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_add_cosh : sinh x + cosh x = exp x := by rw [add_comm, cosh_add_sinh]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 sinh x + cosh x = exp x"}, {"line": "rw [add_comm, cosh_add_sinh]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cosh_sub_sinh : cosh x - sinh x = exp (-x) := by\n  rw [\u2190 mul_right_inj' (two_ne_zero' \u2102)]\n  rw [mul_sub]\n  rw [two_cosh]\n  rw [two_sinh]\n  rw [add_sub_sub_cancel]\n  rw [two_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cosh x - sinh x = exp (-x)"}, {"line": "rw [\u2190 mul_right_inj' (two_ne_zero' \u2102)]", "tactic_state": "x : \u2102\n\u22a2 2 * (cosh x - sinh x) = 2 * exp (-x)"}, {"line": "rw [mul_sub]", "tactic_state": "x : \u2102\n\u22a2 2 * cosh x - 2 * sinh x = 2 * exp (-x)"}, {"line": "rw [two_cosh]", "tactic_state": "x : \u2102\n\u22a2 exp x + exp (-x) - 2 * sinh x = 2 * exp (-x)"}, {"line": "rw [two_sinh]", "tactic_state": "x : \u2102\n\u22a2 exp x + exp (-x) - (exp x - exp (-x)) = 2 * exp (-x)"}, {"line": "rw [add_sub_sub_cancel]", "tactic_state": "x : \u2102\n\u22a2 exp (-x) + exp (-x) = 2 * exp (-x)"}, {"line": "rw [two_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_sub_cosh : sinh x - cosh x = -exp (-x) := by rw [\u2190 neg_sub, cosh_sub_sinh]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 sinh x - cosh x = -exp (-x)"}, {"line": "rw [\u2190 neg_sub, cosh_sub_sinh]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cosh_sq_sub_sinh_sq : cosh x ^ 2 - sinh x ^ 2 = 1 := by\n  rw [sq_sub_sq]\n  rw [cosh_add_sinh]\n  rw [cosh_sub_sinh]\n  rw [\u2190 exp_add]\n  rw [add_neg_cancel]\n  rw [exp_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cosh x ^ 2 - sinh x ^ 2 = 1"}, {"line": "rw [sq_sub_sq]", "tactic_state": "x : \u2102\n\u22a2 (cosh x + sinh x) * (cosh x - sinh x) = 1"}, {"line": "rw [cosh_add_sinh]", "tactic_state": "x : \u2102\n\u22a2 exp x * (cosh x - sinh x) = 1"}, {"line": "rw [cosh_sub_sinh]", "tactic_state": "x : \u2102\n\u22a2 exp x * exp (-x) = 1"}, {"line": "rw [\u2190 exp_add]", "tactic_state": "x : \u2102\n\u22a2 exp (x + -x) = 1"}, {"line": "rw [add_neg_cancel]", "tactic_state": "x : \u2102\n\u22a2 exp 0 = 1"}, {"line": "rw [exp_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cosh_sq : cosh x ^ 2 = sinh x ^ 2 + 1 := by\n  rw [\u2190 cosh_sq_sub_sinh_sq x]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cosh x ^ 2 = sinh x ^ 2 + 1"}, {"line": "rw [\u2190 cosh_sq_sub_sinh_sq x]", "tactic_state": "x : \u2102\n\u22a2 cosh x ^ 2 = sinh x ^ 2 + (cosh x ^ 2 - sinh x ^ 2)"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_sq : sinh x ^ 2 = cosh x ^ 2 - 1 := by\n  rw [\u2190 cosh_sq_sub_sinh_sq x]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 sinh x ^ 2 = cosh x ^ 2 - 1"}, {"line": "rw [\u2190 cosh_sq_sub_sinh_sq x]", "tactic_state": "x : \u2102\n\u22a2 sinh x ^ 2 = cosh x ^ 2 - (cosh x ^ 2 - sinh x ^ 2)"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cosh_two_mul : cosh (2 * x) = cosh x ^ 2 + sinh x ^ 2 := by rw [two_mul, cosh_add, sq, sq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cosh (2 * x) = cosh x ^ 2 + sinh x ^ 2"}, {"line": "rw [two_mul, cosh_add, sq, sq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_two_mul : sinh (2 * x) = 2 * sinh x * cosh x := by\n  rw [two_mul]\n  rw [sinh_add]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 sinh (2 * x) = 2 * sinh x * cosh x"}, {"line": "rw [two_mul]", "tactic_state": "x : \u2102\n\u22a2 sinh (x + x) = 2 * sinh x * cosh x"}, {"line": "rw [sinh_add]", "tactic_state": "x : \u2102\n\u22a2 sinh x * cosh x + cosh x * sinh x = 2 * sinh x * cosh x"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cosh_three_mul : cosh (3 * x) = 4 * cosh x ^ 3 - 3 * cosh x := by\n  have h1 : x + 2 * x = 3 * x := by ring\n  rw [\u2190 h1]\n  rw [cosh_add x (2 * x)]\n  simp only [cosh_two_mul]\n  simp only [sinh_two_mul]\n  have h2 : sinh x * (2 * sinh x * cosh x) = 2 * cosh x * sinh x ^ 2 := by ring\n  rw [h2]\n  rw [sinh_sq]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cosh (3 * x) = 4 * cosh x ^ 3 - 3 * cosh x"}, {"line": "have h1 : x + 2 * x = 3 * x := by ring", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 cosh (3 * x) = 4 * cosh x ^ 3 - 3 * cosh x"}, {"line": "rw [\u2190 h1]", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 cosh (x + 2 * x) = 4 * cosh x ^ 3 - 3 * cosh x"}, {"line": "rw [cosh_add x (2 * x)]", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 cosh x * cosh (2 * x) + sinh x * sinh (2 * x) = 4 * cosh x ^ 3 - 3 * cosh x"}, {"line": "simp only [cosh_two_mul]", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 cosh x * (cosh x ^ 2 + sinh x ^ 2) + sinh x * sinh (2 * x) = 4 * cosh x ^ 3 - 3 * cosh x"}, {"line": "simp only [sinh_two_mul]", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 cosh x * (cosh x ^ 2 + sinh x ^ 2) + sinh x * (2 * sinh x * cosh x) = 4 * cosh x ^ 3 - 3 * cosh x"}, {"line": "have h2 : sinh x * (2 * sinh x * cosh x) = 2 * cosh x * sinh x ^ 2 := by ring", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\nh2 : sinh x * (2 * sinh x * cosh x) = 2 * cosh x * sinh x ^ 2\n\u22a2 cosh x * (cosh x ^ 2 + sinh x ^ 2) + sinh x * (2 * sinh x * cosh x) = 4 * cosh x ^ 3 - 3 * cosh x"}, {"line": "rw [h2]", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\nh2 : sinh x * (2 * sinh x * cosh x) = 2 * cosh x * sinh x ^ 2\n\u22a2 cosh x * (cosh x ^ 2 + sinh x ^ 2) + 2 * cosh x * sinh x ^ 2 = 4 * cosh x ^ 3 - 3 * cosh x"}, {"line": "rw [sinh_sq]", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\nh2 : sinh x * (2 * sinh x * cosh x) = 2 * cosh x * sinh x ^ 2\n\u22a2 cosh x * (cosh x ^ 2 + (cosh x ^ 2 - 1)) + 2 * cosh x * (cosh x ^ 2 - 1) = 4 * cosh x ^ 3 - 3 * cosh x"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_three_mul : sinh (3 * x) = 4 * sinh x ^ 3 + 3 * sinh x := by\n  have h1 : x + 2 * x = 3 * x := by ring\n  rw [\u2190 h1]\n  rw [sinh_add x (2 * x)]\n  simp only [cosh_two_mul]\n  simp only [sinh_two_mul]\n  have h2 : cosh x * (2 * sinh x * cosh x) = 2 * sinh x * cosh x ^ 2 := by ring\n  rw [h2]\n  rw [cosh_sq]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 sinh (3 * x) = 4 * sinh x ^ 3 + 3 * sinh x"}, {"line": "have h1 : x + 2 * x = 3 * x := by ring", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 sinh (3 * x) = 4 * sinh x ^ 3 + 3 * sinh x"}, {"line": "rw [\u2190 h1]", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 sinh (x + 2 * x) = 4 * sinh x ^ 3 + 3 * sinh x"}, {"line": "rw [sinh_add x (2 * x)]", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 sinh x * cosh (2 * x) + cosh x * sinh (2 * x) = 4 * sinh x ^ 3 + 3 * sinh x"}, {"line": "simp only [cosh_two_mul]", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 sinh x * (cosh x ^ 2 + sinh x ^ 2) + cosh x * sinh (2 * x) = 4 * sinh x ^ 3 + 3 * sinh x"}, {"line": "simp only [sinh_two_mul]", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 sinh x * (cosh x ^ 2 + sinh x ^ 2) + cosh x * (2 * sinh x * cosh x) = 4 * sinh x ^ 3 + 3 * sinh x"}, {"line": "have h2 : cosh x * (2 * sinh x * cosh x) = 2 * sinh x * cosh x ^ 2 := by ring", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\nh2 : cosh x * (2 * sinh x * cosh x) = 2 * sinh x * cosh x ^ 2\n\u22a2 sinh x * (cosh x ^ 2 + sinh x ^ 2) + cosh x * (2 * sinh x * cosh x) = 4 * sinh x ^ 3 + 3 * sinh x"}, {"line": "rw [h2]", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\nh2 : cosh x * (2 * sinh x * cosh x) = 2 * sinh x * cosh x ^ 2\n\u22a2 sinh x * (cosh x ^ 2 + sinh x ^ 2) + 2 * sinh x * cosh x ^ 2 = 4 * sinh x ^ 3 + 3 * sinh x"}, {"line": "rw [cosh_sq]", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\nh2 : cosh x * (2 * sinh x * cosh x) = 2 * sinh x * cosh x ^ 2\n\u22a2 sinh x * (sinh x ^ 2 + 1 + sinh x ^ 2) + 2 * sinh x * (sinh x ^ 2 + 1) = 4 * sinh x ^ 3 + 3 * sinh x"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_zero : sin 0 = 0 := by simp [sin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sin 0 = 0"}, {"line": "simp [sin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_neg : sin (-x) = -sin x := by\n  simp [sin, sub_eq_add_neg, exp_neg, (neg_div _ _).symm, add_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 sin (-x) = -sin x"}, {"line": "simp [sin, sub_eq_add_neg, exp_neg, (neg_div _ _).symm, add_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_mul_I : sinh (x * I) = sin x * I := by\n  rw [\u2190 mul_right_inj' (two_ne_zero' \u2102)]\n  rw [two_sinh]\n  rw [\u2190 mul_assoc]\n  rw [two_sin]\n  rw [mul_assoc]\n  rw [I_mul_I]\n  rw [mul_neg_one]\n  rw [neg_sub]\n  rw [neg_mul_eq_neg_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 sinh (x * I) = sin x * I"}, {"line": "rw [\u2190 mul_right_inj' (two_ne_zero' \u2102)]", "tactic_state": "x : \u2102\n\u22a2 2 * sinh (x * I) = 2 * (sin x * I)"}, {"line": "rw [two_sinh]", "tactic_state": "x : \u2102\n\u22a2 exp (x * I) - exp (-(x * I)) = 2 * (sin x * I)"}, {"line": "rw [\u2190 mul_assoc]", "tactic_state": "x : \u2102\n\u22a2 exp (x * I) - exp (-(x * I)) = 2 * sin x * I"}, {"line": "rw [two_sin]", "tactic_state": "x : \u2102\n\u22a2 exp (x * I) - exp (-(x * I)) = (exp (-x * I) - exp (x * I)) * I * I"}, {"line": "rw [mul_assoc]", "tactic_state": "x : \u2102\n\u22a2 exp (x * I) - exp (-(x * I)) = (exp (-x * I) - exp (x * I)) * (I * I)"}, {"line": "rw [I_mul_I]", "tactic_state": "x : \u2102\n\u22a2 exp (x * I) - exp (-(x * I)) = (exp (-x * I) - exp (x * I)) * -1"}, {"line": "rw [mul_neg_one]", "tactic_state": "x : \u2102\n\u22a2 exp (x * I) - exp (-(x * I)) = -(exp (-x * I) - exp (x * I))"}, {"line": "rw [neg_sub]", "tactic_state": "x : \u2102\n\u22a2 exp (x * I) - exp (-(x * I)) = exp (x * I) - exp (-x * I)"}, {"line": "rw [neg_mul_eq_neg_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cosh_mul_I : cosh (x * I) = cos x := by\n  rw [\u2190 mul_right_inj' (two_ne_zero' \u2102)]\n  rw [two_cosh]\n  rw [two_cos]\n  rw [neg_mul_eq_neg_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cosh (x * I) = cos x"}, {"line": "rw [\u2190 mul_right_inj' (two_ne_zero' \u2102)]", "tactic_state": "x : \u2102\n\u22a2 2 * cosh (x * I) = 2 * cos x"}, {"line": "rw [two_cosh]", "tactic_state": "x : \u2102\n\u22a2 exp (x * I) + exp (-(x * I)) = 2 * cos x"}, {"line": "rw [two_cos]", "tactic_state": "x : \u2102\n\u22a2 exp (x * I) + exp (-(x * I)) = exp (x * I) + exp (-x * I)"}, {"line": "rw [neg_mul_eq_neg_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tanh_mul_I : tanh (x * I) = tan x * I := by\n  rw [tanh_eq_sinh_div_cosh]\n  rw [cosh_mul_I]\n  rw [sinh_mul_I]\n  rw [mul_div_right_comm]\n  rw [tan]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 tanh (x * I) = tan x * I"}, {"line": "rw [tanh_eq_sinh_div_cosh]", "tactic_state": "x : \u2102\n\u22a2 sinh (x * I) / cosh (x * I) = tan x * I"}, {"line": "rw [cosh_mul_I]", "tactic_state": "x : \u2102\n\u22a2 sinh (x * I) / cos x = tan x * I"}, {"line": "rw [sinh_mul_I]", "tactic_state": "x : \u2102\n\u22a2 sin x * I / cos x = tan x * I"}, {"line": "rw [mul_div_right_comm]", "tactic_state": "x : \u2102\n\u22a2 sin x / cos x * I = tan x * I"}, {"line": "rw [tan]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_mul_I : sin (x * I) = sinh x * I := by\n  have h : I * sin (x * I) = -sinh x := by\n    rw [mul_comm]\n    rw [\u2190 sinh_mul_I]\n    ring_nf\n    simp\n  rw [\u2190 neg_neg (sinh x)]\n  rw [\u2190 h]\n  apply Complex.ext <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 sin (x * I) = sinh x * I"}, {"line": "have h : I * sin (x * I) = -sinh x := by\n    rw [mul_comm]\n    rw [\u2190 sinh_mul_I]\n    ring_nf\n    simp", "tactic_state": "x : \u2102\nh : I * sin (x * I) = -sinh x\n\u22a2 sin (x * I) = sinh x * I"}, {"line": "rw [\u2190 neg_neg (sinh x)]", "tactic_state": "x : \u2102\nh : I * sin (x * I) = -sinh x\n\u22a2 sin (x * I) = - -sinh x * I"}, {"line": "rw [\u2190 h]", "tactic_state": "x : \u2102\nh : I * sin (x * I) = -sinh x\n\u22a2 sin (x * I) = -(I * sin (x * I)) * I"}, {"line": "apply Complex.ext <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_mul_I : tan (x * I) = tanh x * I := by\n  rw [tan]\n  rw [sin_mul_I]\n  rw [cos_mul_I]\n  rw [mul_div_right_comm]\n  rw [tanh_eq_sinh_div_cosh]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 tan (x * I) = tanh x * I"}, {"line": "rw [tan]", "tactic_state": "x : \u2102\n\u22a2 sin (x * I) / cos (x * I) = tanh x * I"}, {"line": "rw [sin_mul_I]", "tactic_state": "x : \u2102\n\u22a2 sinh x * I / cos (x * I) = tanh x * I"}, {"line": "rw [cos_mul_I]", "tactic_state": "x : \u2102\n\u22a2 sinh x * I / cosh x = tanh x * I"}, {"line": "rw [mul_div_right_comm]", "tactic_state": "x : \u2102\n\u22a2 sinh x / cosh x * I = tanh x * I"}, {"line": "rw [tanh_eq_sinh_div_cosh]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_add : sin (x + y) = sin x * cos y + cos x * sin y := by\n  rw [\u2190 mul_left_inj' I_ne_zero]\n  rw [\u2190 sinh_mul_I]\n  rw [add_mul]\n  rw [add_mul]\n  rw [mul_right_comm]\n  rw [\u2190 sinh_mul_I]\n  rw [mul_assoc]\n  rw [\u2190 sinh_mul_I]\n  rw [\u2190 cosh_mul_I]\n  rw [\u2190 cosh_mul_I]\n  rw [sinh_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 sin (x + y) = sin x * cos y + cos x * sin y"}, {"line": "rw [\u2190 mul_left_inj' I_ne_zero]", "tactic_state": "x y : \u2102\n\u22a2 sin (x + y) * I = (sin x * cos y + cos x * sin y) * I"}, {"line": "rw [\u2190 sinh_mul_I]", "tactic_state": "x y : \u2102\n\u22a2 sinh ((x + y) * I) = (sin x * cos y + cos x * sin y) * I"}, {"line": "rw [add_mul]", "tactic_state": "x y : \u2102\n\u22a2 sinh (x * I + y * I) = (sin x * cos y + cos x * sin y) * I"}, {"line": "rw [add_mul]", "tactic_state": "x y : \u2102\n\u22a2 sinh (x * I + y * I) = sin x * cos y * I + cos x * sin y * I"}, {"line": "rw [mul_right_comm]", "tactic_state": "x y : \u2102\n\u22a2 sinh (x * I + y * I) = sin x * I * cos y + cos x * sin y * I"}, {"line": "rw [\u2190 sinh_mul_I]", "tactic_state": "x y : \u2102\n\u22a2 sinh (x * I + y * I) = sinh (x * I) * cos y + cos x * sin y * I"}, {"line": "rw [mul_assoc]", "tactic_state": "x y : \u2102\n\u22a2 sinh (x * I + y * I) = sinh (x * I) * cos y + cos x * (sin y * I)"}, {"line": "rw [\u2190 sinh_mul_I]", "tactic_state": "x y : \u2102\n\u22a2 sinh (x * I + y * I) = sinh (x * I) * cos y + cos x * sinh (y * I)"}, {"line": "rw [\u2190 cosh_mul_I]", "tactic_state": "x y : \u2102\n\u22a2 sinh (x * I + y * I) = sinh (x * I) * cosh (y * I) + cos x * sinh (y * I)"}, {"line": "rw [\u2190 cosh_mul_I]", "tactic_state": "x y : \u2102\n\u22a2 sinh (x * I + y * I) = sinh (x * I) * cosh (y * I) + cosh (x * I) * sinh (y * I)"}, {"line": "rw [sinh_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_zero : cos 0 = 1 := by simp [cos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 cos 0 = 1"}, {"line": "simp [cos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_neg : cos (-x) = cos x := by simp [cos, sub_eq_add_neg, exp_neg, add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cos (-x) = cos x"}, {"line": "simp [cos, sub_eq_add_neg, exp_neg, add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_add : cos (x + y) = cos x * cos y - sin x * sin y := by\n  rw [\u2190 cosh_mul_I]\n  rw [add_mul]\n  rw [cosh_add]\n  rw [cosh_mul_I]\n  rw [cosh_mul_I]\n  rw [sinh_mul_I]\n  rw [sinh_mul_I]\n  rw [mul_mul_mul_comm]\n  rw [I_mul_I]\n  rw [mul_neg_one]\n  rw [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 cos (x + y) = cos x * cos y - sin x * sin y"}, {"line": "rw [\u2190 cosh_mul_I]", "tactic_state": "x y : \u2102\n\u22a2 cosh ((x + y) * I) = cos x * cos y - sin x * sin y"}, {"line": "rw [add_mul]", "tactic_state": "x y : \u2102\n\u22a2 cosh (x * I + y * I) = cos x * cos y - sin x * sin y"}, {"line": "rw [cosh_add]", "tactic_state": "x y : \u2102\n\u22a2 cosh (x * I) * cosh (y * I) + sinh (x * I) * sinh (y * I) = cos x * cos y - sin x * sin y"}, {"line": "rw [cosh_mul_I]", "tactic_state": "x y : \u2102\n\u22a2 cos x * cosh (y * I) + sinh (x * I) * sinh (y * I) = cos x * cos y - sin x * sin y"}, {"line": "rw [cosh_mul_I]", "tactic_state": "x y : \u2102\n\u22a2 cos x * cos y + sinh (x * I) * sinh (y * I) = cos x * cos y - sin x * sin y"}, {"line": "rw [sinh_mul_I]", "tactic_state": "x y : \u2102\n\u22a2 cos x * cos y + sin x * I * sinh (y * I) = cos x * cos y - sin x * sin y"}, {"line": "rw [sinh_mul_I]", "tactic_state": "x y : \u2102\n\u22a2 cos x * cos y + sin x * I * (sin y * I) = cos x * cos y - sin x * sin y"}, {"line": "rw [mul_mul_mul_comm]", "tactic_state": "x y : \u2102\n\u22a2 cos x * cos y + sin x * sin y * (I * I) = cos x * cos y - sin x * sin y"}, {"line": "rw [I_mul_I]", "tactic_state": "x y : \u2102\n\u22a2 cos x * cos y + sin x * sin y * -1 = cos x * cos y - sin x * sin y"}, {"line": "rw [mul_neg_one]", "tactic_state": "x y : \u2102\n\u22a2 cos x * cos y + -(sin x * sin y) = cos x * cos y - sin x * sin y"}, {"line": "rw [sub_eq_add_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_sub : sin (x - y) = sin x * cos y - cos x * sin y := by\n  simp [sub_eq_add_neg, sin_add, sin_neg, cos_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 sin (x - y) = sin x * cos y - cos x * sin y"}, {"line": "simp [sub_eq_add_neg, sin_add, sin_neg, cos_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_sub : cos (x - y) = cos x * cos y + sin x * sin y := by\n  simp [sub_eq_add_neg, cos_add, sin_neg, cos_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 cos (x - y) = cos x * cos y + sin x * sin y"}, {"line": "simp [sub_eq_add_neg, cos_add, sin_neg, cos_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_add_mul_I (x y : \u2102) : sin (x + y * I) = sin x * cosh y + cos x * sinh y * I := by\n  rw [sin_add]\n  rw [cos_mul_I]\n  rw [sin_mul_I]\n  rw [mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 sin (x + y * I) = sin x * cosh y + cos x * sinh y * I"}, {"line": "rw [sin_add]", "tactic_state": "x y : \u2102\n\u22a2 sin x * cos (y * I) + cos x * sin (y * I) = sin x * cosh y + cos x * sinh y * I"}, {"line": "rw [cos_mul_I]", "tactic_state": "x y : \u2102\n\u22a2 sin x * cosh y + cos x * sin (y * I) = sin x * cosh y + cos x * sinh y * I"}, {"line": "rw [sin_mul_I]", "tactic_state": "x y : \u2102\n\u22a2 sin x * cosh y + cos x * (sinh y * I) = sin x * cosh y + cos x * sinh y * I"}, {"line": "rw [mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_add_mul_I (x y : \u2102) : cos (x + y * I) = cos x * cosh y - sin x * sinh y * I := by\n  rw [cos_add]\n  rw [cos_mul_I]\n  rw [sin_mul_I]\n  rw [mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 cos (x + y * I) = cos x * cosh y - sin x * sinh y * I"}, {"line": "rw [cos_add]", "tactic_state": "x y : \u2102\n\u22a2 cos x * cos (y * I) - sin x * sin (y * I) = cos x * cosh y - sin x * sinh y * I"}, {"line": "rw [cos_mul_I]", "tactic_state": "x y : \u2102\n\u22a2 cos x * cosh y - sin x * sin (y * I) = cos x * cosh y - sin x * sinh y * I"}, {"line": "rw [sin_mul_I]", "tactic_state": "x y : \u2102\n\u22a2 cos x * cosh y - sin x * (sinh y * I) = cos x * cosh y - sin x * sinh y * I"}, {"line": "rw [mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_sub_sin : sin x - sin y = 2 * sin ((x - y) / 2) * cos ((x + y) / 2) := by\n  have s1 := sin_add ((x + y) / 2) ((x - y) / 2)\n  have s2 := sin_sub ((x + y) / 2) ((x - y) / 2)\n  rw [div_add_div_same] at s1\n  rw [add_sub] at s1\n  rw [add_right_comm] at s1\n  rw [add_sub_cancel_right] at s1\n  rw [add_self_div_two] at s1\n  rw [div_sub_div_same] at s2\n  rw [\u2190 sub_add] at s2\n  rw [add_sub_cancel_left] at s2\n  rw [add_self_div_two] at s2\n  rw [s1]\n  rw [s2]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 sin x - sin y = 2 * sin ((x - y) / 2) * cos ((x + y) / 2)"}, {"line": "have s1 := sin_add ((x + y) / 2) ((x - y) / 2)", "tactic_state": "x y : \u2102\ns1 : sin ((x + y) / 2 + (x - y) / 2) = sin ((x + y) / 2) * cos ((x - y) / 2) + cos ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 sin x - sin y = 2 * sin ((x - y) / 2) * cos ((x + y) / 2)"}, {"line": "have s2 := sin_sub ((x + y) / 2) ((x - y) / 2)", "tactic_state": "x y : \u2102\ns1 : sin ((x + y) / 2 + (x - y) / 2) = sin ((x + y) / 2) * cos ((x - y) / 2) + cos ((x + y) / 2) * sin ((x - y) / 2)\ns2 : sin ((x + y) / 2 - (x - y) / 2) = sin ((x + y) / 2) * cos ((x - y) / 2) - cos ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 sin x - sin y = 2 * sin ((x - y) / 2) * cos ((x + y) / 2)"}, {"line": "rw [div_add_div_same] at s1", "tactic_state": "x y : \u2102\ns1 : sin ((x + y + (x - y)) / 2) = sin ((x + y) / 2) * cos ((x - y) / 2) + cos ((x + y) / 2) * sin ((x - y) / 2)\ns2 : sin ((x + y) / 2 - (x - y) / 2) = sin ((x + y) / 2) * cos ((x - y) / 2) - cos ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 sin x - sin y = 2 * sin ((x - y) / 2) * cos ((x + y) / 2)"}, {"line": "rw [add_sub] at s1", "tactic_state": "x y : \u2102\ns1 : sin ((x + y + x - y) / 2) = sin ((x + y) / 2) * cos ((x - y) / 2) + cos ((x + y) / 2) * sin ((x - y) / 2)\ns2 : sin ((x + y) / 2 - (x - y) / 2) = sin ((x + y) / 2) * cos ((x - y) / 2) - cos ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 sin x - sin y = 2 * sin ((x - y) / 2) * cos ((x + y) / 2)"}, {"line": "rw [add_right_comm] at s1", "tactic_state": "x y : \u2102\ns1 : sin ((x + x + y - y) / 2) = sin ((x + y) / 2) * cos ((x - y) / 2) + cos ((x + y) / 2) * sin ((x - y) / 2)\ns2 : sin ((x + y) / 2 - (x - y) / 2) = sin ((x + y) / 2) * cos ((x - y) / 2) - cos ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 sin x - sin y = 2 * sin ((x - y) / 2) * cos ((x + y) / 2)"}, {"line": "rw [add_sub_cancel_right] at s1", "tactic_state": "x y : \u2102\ns1 : sin ((x + x) / 2) = sin ((x + y) / 2) * cos ((x - y) / 2) + cos ((x + y) / 2) * sin ((x - y) / 2)\ns2 : sin ((x + y) / 2 - (x - y) / 2) = sin ((x + y) / 2) * cos ((x - y) / 2) - cos ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 sin x - sin y = 2 * sin ((x - y) / 2) * cos ((x + y) / 2)"}, {"line": "rw [add_self_div_two] at s1", "tactic_state": "x y : \u2102\ns1 : sin x = sin ((x + y) / 2) * cos ((x - y) / 2) + cos ((x + y) / 2) * sin ((x - y) / 2)\ns2 : sin ((x + y) / 2 - (x - y) / 2) = sin ((x + y) / 2) * cos ((x - y) / 2) - cos ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 sin x - sin y = 2 * sin ((x - y) / 2) * cos ((x + y) / 2)"}, {"line": "rw [div_sub_div_same] at s2", "tactic_state": "x y : \u2102\ns1 : sin x = sin ((x + y) / 2) * cos ((x - y) / 2) + cos ((x + y) / 2) * sin ((x - y) / 2)\ns2 : sin ((x + y - (x - y)) / 2) = sin ((x + y) / 2) * cos ((x - y) / 2) - cos ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 sin x - sin y = 2 * sin ((x - y) / 2) * cos ((x + y) / 2)"}, {"line": "rw [\u2190 sub_add] at s2", "tactic_state": "x y : \u2102\ns1 : sin x = sin ((x + y) / 2) * cos ((x - y) / 2) + cos ((x + y) / 2) * sin ((x - y) / 2)\ns2 : sin ((x + y - x + y) / 2) = sin ((x + y) / 2) * cos ((x - y) / 2) - cos ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 sin x - sin y = 2 * sin ((x - y) / 2) * cos ((x + y) / 2)"}, {"line": "rw [add_sub_cancel_left] at s2", "tactic_state": "x y : \u2102\ns1 : sin x = sin ((x + y) / 2) * cos ((x - y) / 2) + cos ((x + y) / 2) * sin ((x - y) / 2)\ns2 : sin ((y + y) / 2) = sin ((x + y) / 2) * cos ((x - y) / 2) - cos ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 sin x - sin y = 2 * sin ((x - y) / 2) * cos ((x + y) / 2)"}, {"line": "rw [add_self_div_two] at s2", "tactic_state": "x y : \u2102\ns1 : sin x = sin ((x + y) / 2) * cos ((x - y) / 2) + cos ((x + y) / 2) * sin ((x - y) / 2)\ns2 : sin y = sin ((x + y) / 2) * cos ((x - y) / 2) - cos ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 sin x - sin y = 2 * sin ((x - y) / 2) * cos ((x + y) / 2)"}, {"line": "rw [s1]", "tactic_state": "x y : \u2102\ns1 : sin x = sin ((x + y) / 2) * cos ((x - y) / 2) + cos ((x + y) / 2) * sin ((x - y) / 2)\ns2 : sin y = sin ((x + y) / 2) * cos ((x - y) / 2) - cos ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 sin ((x + y) / 2) * cos ((x - y) / 2) + cos ((x + y) / 2) * sin ((x - y) / 2) - sin y =\n    2 * sin ((x - y) / 2) * cos ((x + y) / 2)"}, {"line": "rw [s2]", "tactic_state": "x y : \u2102\ns1 : sin x = sin ((x + y) / 2) * cos ((x - y) / 2) + cos ((x + y) / 2) * sin ((x - y) / 2)\ns2 : sin y = sin ((x + y) / 2) * cos ((x - y) / 2) - cos ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 sin ((x + y) / 2) * cos ((x - y) / 2) + cos ((x + y) / 2) * sin ((x - y) / 2) -\n      (sin ((x + y) / 2) * cos ((x - y) / 2) - cos ((x + y) / 2) * sin ((x - y) / 2)) =\n    2 * sin ((x - y) / 2) * cos ((x + y) / 2)"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_sub_cos : cos x - cos y = -2 * sin ((x + y) / 2) * sin ((x - y) / 2) := by\n  have s1 := cos_add ((x + y) / 2) ((x - y) / 2)\n  have s2 := cos_sub ((x + y) / 2) ((x - y) / 2)\n  rw [div_add_div_same] at s1\n  rw [add_sub] at s1\n  rw [add_right_comm] at s1\n  rw [add_sub_cancel_right] at s1\n  rw [add_self_div_two] at s1\n  rw [div_sub_div_same] at s2\n  rw [\u2190 sub_add] at s2\n  rw [add_sub_cancel_left] at s2\n  rw [add_self_div_two] at s2\n  rw [s1]\n  rw [s2]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 cos x - cos y = -2 * sin ((x + y) / 2) * sin ((x - y) / 2)"}, {"line": "have s1 := cos_add ((x + y) / 2) ((x - y) / 2)", "tactic_state": "x y : \u2102\ns1 : cos ((x + y) / 2 + (x - y) / 2) = cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 cos x - cos y = -2 * sin ((x + y) / 2) * sin ((x - y) / 2)"}, {"line": "have s2 := cos_sub ((x + y) / 2) ((x - y) / 2)", "tactic_state": "x y : \u2102\ns1 : cos ((x + y) / 2 + (x - y) / 2) = cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2)\ns2 : cos ((x + y) / 2 - (x - y) / 2) = cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 cos x - cos y = -2 * sin ((x + y) / 2) * sin ((x - y) / 2)"}, {"line": "rw [div_add_div_same] at s1", "tactic_state": "x y : \u2102\ns1 : cos ((x + y + (x - y)) / 2) = cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2)\ns2 : cos ((x + y) / 2 - (x - y) / 2) = cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 cos x - cos y = -2 * sin ((x + y) / 2) * sin ((x - y) / 2)"}, {"line": "rw [add_sub] at s1", "tactic_state": "x y : \u2102\ns1 : cos ((x + y + x - y) / 2) = cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2)\ns2 : cos ((x + y) / 2 - (x - y) / 2) = cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 cos x - cos y = -2 * sin ((x + y) / 2) * sin ((x - y) / 2)"}, {"line": "rw [add_right_comm] at s1", "tactic_state": "x y : \u2102\ns1 : cos ((x + x + y - y) / 2) = cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2)\ns2 : cos ((x + y) / 2 - (x - y) / 2) = cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 cos x - cos y = -2 * sin ((x + y) / 2) * sin ((x - y) / 2)"}, {"line": "rw [add_sub_cancel_right] at s1", "tactic_state": "x y : \u2102\ns1 : cos ((x + x) / 2) = cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2)\ns2 : cos ((x + y) / 2 - (x - y) / 2) = cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 cos x - cos y = -2 * sin ((x + y) / 2) * sin ((x - y) / 2)"}, {"line": "rw [add_self_div_two] at s1", "tactic_state": "x y : \u2102\ns1 : cos x = cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2)\ns2 : cos ((x + y) / 2 - (x - y) / 2) = cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 cos x - cos y = -2 * sin ((x + y) / 2) * sin ((x - y) / 2)"}, {"line": "rw [div_sub_div_same] at s2", "tactic_state": "x y : \u2102\ns1 : cos x = cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2)\ns2 : cos ((x + y - (x - y)) / 2) = cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 cos x - cos y = -2 * sin ((x + y) / 2) * sin ((x - y) / 2)"}, {"line": "rw [\u2190 sub_add] at s2", "tactic_state": "x y : \u2102\ns1 : cos x = cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2)\ns2 : cos ((x + y - x + y) / 2) = cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 cos x - cos y = -2 * sin ((x + y) / 2) * sin ((x - y) / 2)"}, {"line": "rw [add_sub_cancel_left] at s2", "tactic_state": "x y : \u2102\ns1 : cos x = cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2)\ns2 : cos ((y + y) / 2) = cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 cos x - cos y = -2 * sin ((x + y) / 2) * sin ((x - y) / 2)"}, {"line": "rw [add_self_div_two] at s2", "tactic_state": "x y : \u2102\ns1 : cos x = cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2)\ns2 : cos y = cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 cos x - cos y = -2 * sin ((x + y) / 2) * sin ((x - y) / 2)"}, {"line": "rw [s1]", "tactic_state": "x y : \u2102\ns1 : cos x = cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2)\ns2 : cos y = cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2) - cos y =\n    -2 * sin ((x + y) / 2) * sin ((x - y) / 2)"}, {"line": "rw [s2]", "tactic_state": "x y : \u2102\ns1 : cos x = cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2)\ns2 : cos y = cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2) -\n      (cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)) =\n    -2 * sin ((x + y) / 2) * sin ((x - y) / 2)"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_add_sin : sin x + sin y = 2 * sin ((x + y) / 2) * cos ((x - y) / 2) := by\n  simpa using sin_sub_sin x (-y)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 sin x + sin y = 2 * sin ((x + y) / 2) * cos ((x - y) / 2)"}, {"line": "simpa using sin_sub_sin x (-y)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_add_cos : cos x + cos y = 2 * cos ((x + y) / 2) * cos ((x - y) / 2) := by\n  calc\n    cos x + cos y = cos ((x + y) / 2 + (x - y) / 2) + cos ((x + y) / 2 - (x - y) / 2) := ?_\n    _ =\n        cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2) +\n          (cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)) :=\n      ?_\n    _ = 2 * cos ((x + y) / 2) * cos ((x - y) / 2) := ?_\n\n  \u00b7 congr <;> field_simp\n  \u00b7 rw [cos_add, cos_sub]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 cos x + cos y = 2 * cos ((x + y) / 2) * cos ((x - y) / 2)"}, {"line": "calc\n    cos x + cos y = cos ((x + y) / 2 + (x - y) / 2) + cos ((x + y) / 2 - (x - y) / 2) := ?_\n    _ =\n        cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2) +\n          (cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)) :=\n      ?_\n    _ = 2 * cos ((x + y) / 2) * cos ((x - y) / 2) := ?_", "tactic_state": "case calc_1\nx y : \u2102\n\u22a2 cos x + cos y = cos ((x + y) / 2 + (x - y) / 2) + cos ((x + y) / 2 - (x - y) / 2)\n---\ncase calc_2\nx y : \u2102\n\u22a2 cos ((x + y) / 2 + (x - y) / 2) + cos ((x + y) / 2 - (x - y) / 2) =\n    cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2) +\n      (cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2))\n---\ncase calc_3\nx y : \u2102\n\u22a2 cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2) +\n      (cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)) =\n    2 * cos ((x + y) / 2) * cos ((x - y) / 2)"}, {"line": "\u00b7 congr <;> field_simp", "tactic_state": "case calc_2\nx y : \u2102\n\u22a2 cos ((x + y) / 2 + (x - y) / 2) + cos ((x + y) / 2 - (x - y) / 2) =\n    cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2) +\n      (cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2))\n---\ncase calc_3\nx y : \u2102\n\u22a2 cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2) +\n      (cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)) =\n    2 * cos ((x + y) / 2) * cos ((x - y) / 2)"}, {"line": "\u00b7 rw [cos_add, cos_sub]", "tactic_state": "case calc_3\nx y : \u2102\n\u22a2 cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2) +\n      (cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)) =\n    2 * cos ((x + y) / 2) * cos ((x - y) / 2)"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_conj : sin (conj x) = conj (sin x) := by\n  rw [\u2190 mul_left_inj' I_ne_zero]\n  rw [\u2190 sinh_mul_I]\n  rw [\u2190 conj_neg_I]\n  rw [\u2190 RingHom.map_mul]\n  rw [\u2190 RingHom.map_mul]\n  rw [sinh_conj]\n  rw [mul_neg]\n  rw [sinh_neg]\n  rw [sinh_mul_I]\n  rw [mul_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 sin ((starRingEnd \u2102) x) = (starRingEnd \u2102) (sin x)"}, {"line": "rw [\u2190 mul_left_inj' I_ne_zero]", "tactic_state": "x : \u2102\n\u22a2 sin ((starRingEnd \u2102) x) * I = (starRingEnd \u2102) (sin x) * I"}, {"line": "rw [\u2190 sinh_mul_I]", "tactic_state": "x : \u2102\n\u22a2 sinh ((starRingEnd \u2102) x * I) = (starRingEnd \u2102) (sin x) * I"}, {"line": "rw [\u2190 conj_neg_I]", "tactic_state": "x : \u2102\n\u22a2 sinh ((starRingEnd \u2102) x * (starRingEnd \u2102) (-I)) = (starRingEnd \u2102) (sin x) * (starRingEnd \u2102) (-I)"}, {"line": "rw [\u2190 RingHom.map_mul]", "tactic_state": "x : \u2102\n\u22a2 sinh ((starRingEnd \u2102) (x * -I)) = (starRingEnd \u2102) (sin x) * (starRingEnd \u2102) (-I)"}, {"line": "rw [\u2190 RingHom.map_mul]", "tactic_state": "x : \u2102\n\u22a2 sinh ((starRingEnd \u2102) (x * -I)) = (starRingEnd \u2102) (sin x * -I)"}, {"line": "rw [sinh_conj]", "tactic_state": "x : \u2102\n\u22a2 (starRingEnd \u2102) (sinh (x * -I)) = (starRingEnd \u2102) (sin x * -I)"}, {"line": "rw [mul_neg]", "tactic_state": "x : \u2102\n\u22a2 (starRingEnd \u2102) (sinh (-(x * I))) = (starRingEnd \u2102) (sin x * -I)"}, {"line": "rw [sinh_neg]", "tactic_state": "x : \u2102\n\u22a2 (starRingEnd \u2102) (-sinh (x * I)) = (starRingEnd \u2102) (sin x * -I)"}, {"line": "rw [sinh_mul_I]", "tactic_state": "x : \u2102\n\u22a2 (starRingEnd \u2102) (-(sin x * I)) = (starRingEnd \u2102) (sin x * -I)"}, {"line": "rw [mul_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_ofReal_im (x : \u211d) : (sin x).im = 0 := by rw [\u2190 ofReal_sin_ofReal_re, ofReal_im]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 (sin \u2191x).im = 0"}, {"line": "rw [\u2190 ofReal_sin_ofReal_re, ofReal_im]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_conj : cos (conj x) = conj (cos x) := by\n  rw [\u2190 cosh_mul_I]\n  rw [\u2190 conj_neg_I]\n  rw [\u2190 RingHom.map_mul]\n  rw [\u2190 cosh_mul_I]\n  rw [cosh_conj]\n  rw [mul_neg]\n  rw [cosh_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cos ((starRingEnd \u2102) x) = (starRingEnd \u2102) (cos x)"}, {"line": "rw [\u2190 cosh_mul_I]", "tactic_state": "x : \u2102\n\u22a2 cosh ((starRingEnd \u2102) x * I) = (starRingEnd \u2102) (cos x)"}, {"line": "rw [\u2190 conj_neg_I]", "tactic_state": "x : \u2102\n\u22a2 cosh ((starRingEnd \u2102) x * (starRingEnd \u2102) (-I)) = (starRingEnd \u2102) (cos x)"}, {"line": "rw [\u2190 RingHom.map_mul]", "tactic_state": "x : \u2102\n\u22a2 cosh ((starRingEnd \u2102) (x * -I)) = (starRingEnd \u2102) (cos x)"}, {"line": "rw [\u2190 cosh_mul_I]", "tactic_state": "x : \u2102\n\u22a2 cosh ((starRingEnd \u2102) (x * -I)) = (starRingEnd \u2102) (cosh (x * I))"}, {"line": "rw [cosh_conj]", "tactic_state": "x : \u2102\n\u22a2 (starRingEnd \u2102) (cosh (x * -I)) = (starRingEnd \u2102) (cosh (x * I))"}, {"line": "rw [mul_neg]", "tactic_state": "x : \u2102\n\u22a2 (starRingEnd \u2102) (cosh (-(x * I))) = (starRingEnd \u2102) (cosh (x * I))"}, {"line": "rw [cosh_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_ofReal_im (x : \u211d) : (cos x).im = 0 := by rw [\u2190 ofReal_cos_ofReal_re, ofReal_im]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 (cos \u2191x).im = 0"}, {"line": "rw [\u2190 ofReal_cos_ofReal_re, ofReal_im]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_zero : tan 0 = 0 := by simp [tan]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 tan 0 = 0"}, {"line": "simp [tan]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_mul_cos {x : \u2102} (hx : cos x \u2260 0) : tan x * cos x = sin x := by\n  rw [tan_eq_sin_div_cos]\n  rw [div_mul_cancel\u2080 _ hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\nhx : cos x \u2260 0\n\u22a2 tan x * cos x = sin x"}, {"line": "rw [tan_eq_sin_div_cos]", "tactic_state": "x : \u2102\nhx : cos x \u2260 0\n\u22a2 sin x / cos x * cos x = sin x"}, {"line": "rw [div_mul_cancel\u2080 _ hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_neg : tan (-x) = -tan x := by simp [tan, neg_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 tan (-x) = -tan x"}, {"line": "simp [tan, neg_div]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_conj : tan (conj x) = conj (tan x) := by rw [tan, sin_conj, cos_conj, \u2190 map_div\u2080, tan]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 tan ((starRingEnd \u2102) x) = (starRingEnd \u2102) (tan x)"}, {"line": "rw [tan, sin_conj, cos_conj, \u2190 map_div\u2080, tan]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cot_conj : cot (conj x) = conj (cot x) := by rw [cot, sin_conj, cos_conj, \u2190 map_div\u2080, cot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 ((starRingEnd \u2102) x).cot = (starRingEnd \u2102) x.cot"}, {"line": "rw [cot, sin_conj, cos_conj, \u2190 map_div\u2080, cot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_ofReal_im (x : \u211d) : (tan x).im = 0 := by rw [\u2190 ofReal_tan_ofReal_re, ofReal_im]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 (tan \u2191x).im = 0"}, {"line": "rw [\u2190 ofReal_tan_ofReal_re, ofReal_im]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_sub_sin_I : cos x - sin x * I = exp (-x * I) := by\n  rw [neg_mul]\n  rw [\u2190 cosh_sub_sinh]\n  rw [sinh_mul_I]\n  rw [cosh_mul_I]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cos x - sin x * I = exp (-x * I)"}, {"line": "rw [neg_mul]", "tactic_state": "x : \u2102\n\u22a2 cos x - sin x * I = exp (-(x * I))"}, {"line": "rw [\u2190 cosh_sub_sinh]", "tactic_state": "x : \u2102\n\u22a2 cos x - sin x * I = cosh (x * I) - sinh (x * I)"}, {"line": "rw [sinh_mul_I]", "tactic_state": "x : \u2102\n\u22a2 cos x - sin x * I = cosh (x * I) - sin x * I"}, {"line": "rw [cosh_mul_I]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_sq_add_sin_sq : cos x ^ 2 + sin x ^ 2 = 1 := by rw [add_comm, sin_sq_add_cos_sq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cos x ^ 2 + sin x ^ 2 = 1"}, {"line": "rw [add_comm, sin_sq_add_cos_sq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_two_mul' : cos (2 * x) = cos x ^ 2 - sin x ^ 2 := by rw [two_mul, cos_add, \u2190 sq, \u2190 sq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cos (2 * x) = cos x ^ 2 - sin x ^ 2"}, {"line": "rw [two_mul, cos_add, \u2190 sq, \u2190 sq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_two_mul : cos (2 * x) = 2 * cos x ^ 2 - 1 := by\n  rw [cos_two_mul']\n  rw [eq_sub_iff_add_eq.2 (sin_sq_add_cos_sq x)]\n  rw [\u2190 sub_add]\n  rw [sub_add_eq_add_sub]\n  rw [two_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cos (2 * x) = 2 * cos x ^ 2 - 1"}, {"line": "rw [cos_two_mul']", "tactic_state": "x : \u2102\n\u22a2 cos x ^ 2 - sin x ^ 2 = 2 * cos x ^ 2 - 1"}, {"line": "rw [eq_sub_iff_add_eq.2 (sin_sq_add_cos_sq x)]", "tactic_state": "x : \u2102\n\u22a2 cos x ^ 2 - (1 - cos x ^ 2) = 2 * cos x ^ 2 - 1"}, {"line": "rw [\u2190 sub_add]", "tactic_state": "x : \u2102\n\u22a2 cos x ^ 2 - 1 + cos x ^ 2 = 2 * cos x ^ 2 - 1"}, {"line": "rw [sub_add_eq_add_sub]", "tactic_state": "x : \u2102\n\u22a2 cos x ^ 2 + cos x ^ 2 - 1 = 2 * cos x ^ 2 - 1"}, {"line": "rw [two_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_two_mul : sin (2 * x) = 2 * sin x * cos x := by\n  rw [two_mul]\n  rw [sin_add]\n  rw [two_mul]\n  rw [add_mul]\n  rw [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 sin (2 * x) = 2 * sin x * cos x"}, {"line": "rw [two_mul]", "tactic_state": "x : \u2102\n\u22a2 sin (x + x) = 2 * sin x * cos x"}, {"line": "rw [sin_add]", "tactic_state": "x : \u2102\n\u22a2 sin x * cos x + cos x * sin x = 2 * sin x * cos x"}, {"line": "rw [two_mul]", "tactic_state": "x : \u2102\n\u22a2 sin x * cos x + cos x * sin x = (sin x + sin x) * cos x"}, {"line": "rw [add_mul]", "tactic_state": "x : \u2102\n\u22a2 sin x * cos x + cos x * sin x = sin x * cos x + sin x * cos x"}, {"line": "rw [mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2 := by\n  simp [cos_two_mul, div_add_div_same, mul_div_cancel_left\u2080, two_ne_zero, -one_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cos x ^ 2 = 1 / 2 + cos (2 * x) / 2"}, {"line": "simp [cos_two_mul, div_add_div_same, mul_div_cancel_left\u2080, two_ne_zero, -one_div]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_sq' : cos x ^ 2 = 1 - sin x ^ 2 := by rw [\u2190 sin_sq_add_cos_sq x, add_sub_cancel_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cos x ^ 2 = 1 - sin x ^ 2"}, {"line": "rw [\u2190 sin_sq_add_cos_sq x, add_sub_cancel_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_sq : sin x ^ 2 = 1 - cos x ^ 2 := by rw [\u2190 sin_sq_add_cos_sq x, add_sub_cancel_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 sin x ^ 2 = 1 - cos x ^ 2"}, {"line": "rw [\u2190 sin_sq_add_cos_sq x, add_sub_cancel_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_one_add_tan_sq {x : \u2102} (hx : cos x \u2260 0) : (1 + tan x ^ 2)\u207b\u00b9 = cos x ^ 2 := by\n  rw [tan_eq_sin_div_cos]\n  rw [div_pow]\n  field_simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\nhx : cos x \u2260 0\n\u22a2 (1 + tan x ^ 2)\u207b\u00b9 = cos x ^ 2"}, {"line": "rw [tan_eq_sin_div_cos]", "tactic_state": "x : \u2102\nhx : cos x \u2260 0\n\u22a2 (1 + (sin x / cos x) ^ 2)\u207b\u00b9 = cos x ^ 2"}, {"line": "rw [div_pow]", "tactic_state": "x : \u2102\nhx : cos x \u2260 0\n\u22a2 (1 + sin x ^ 2 / cos x ^ 2)\u207b\u00b9 = cos x ^ 2"}, {"line": "field_simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_three_mul : sin (3 * x) = 3 * sin x - 4 * sin x ^ 3 := by\n  have h1 : x + 2 * x = 3 * x := by ring\n  rw [\u2190 h1]\n  rw [sin_add x (2 * x)]\n  simp only [cos_two_mul]\n  simp only [sin_two_mul]\n  simp only [cos_sq']\n  have h2 : cos x * (2 * sin x * cos x) = 2 * sin x * cos x ^ 2 := by ring\n  rw [h2]\n  rw [cos_sq']\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 sin (3 * x) = 3 * sin x - 4 * sin x ^ 3"}, {"line": "have h1 : x + 2 * x = 3 * x := by ring", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 sin (3 * x) = 3 * sin x - 4 * sin x ^ 3"}, {"line": "rw [\u2190 h1]", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 sin (x + 2 * x) = 3 * sin x - 4 * sin x ^ 3"}, {"line": "rw [sin_add x (2 * x)]", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 sin x * cos (2 * x) + cos x * sin (2 * x) = 3 * sin x - 4 * sin x ^ 3"}, {"line": "simp only [cos_two_mul]", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 sin x * (2 * cos x ^ 2 - 1) + cos x * sin (2 * x) = 3 * sin x - 4 * sin x ^ 3"}, {"line": "simp only [sin_two_mul]", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 sin x * (2 * cos x ^ 2 - 1) + cos x * (2 * sin x * cos x) = 3 * sin x - 4 * sin x ^ 3"}, {"line": "simp only [cos_sq']", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 sin x * (2 * (1 - sin x ^ 2) - 1) + cos x * (2 * sin x * cos x) = 3 * sin x - 4 * sin x ^ 3"}, {"line": "have h2 : cos x * (2 * sin x * cos x) = 2 * sin x * cos x ^ 2 := by ring", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\nh2 : cos x * (2 * sin x * cos x) = 2 * sin x * cos x ^ 2\n\u22a2 sin x * (2 * (1 - sin x ^ 2) - 1) + cos x * (2 * sin x * cos x) = 3 * sin x - 4 * sin x ^ 3"}, {"line": "rw [h2]", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\nh2 : cos x * (2 * sin x * cos x) = 2 * sin x * cos x ^ 2\n\u22a2 sin x * (2 * (1 - sin x ^ 2) - 1) + 2 * sin x * cos x ^ 2 = 3 * sin x - 4 * sin x ^ 3"}, {"line": "rw [cos_sq']", "tactic_state": "x : \u2102\nh1 : x + 2 * x = 3 * x\nh2 : cos x * (2 * sin x * cos x) = 2 * sin x * cos x ^ 2\n\u22a2 sin x * (2 * (1 - sin x ^ 2) - 1) + 2 * sin x * (1 - sin x ^ 2) = 3 * sin x - 4 * sin x ^ 3"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_add_mul_I : exp (x + y * I) = exp x * (cos y + sin y * I) := by rw [exp_add, exp_mul_I]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 exp (x + y * I) = exp x * (cos y + sin y * I)"}, {"line": "rw [exp_add, exp_mul_I]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_eq_exp_re_mul_sin_add_cos : exp x = exp x.re * (cos x.im + sin x.im * I) := by\n  rw [\u2190 exp_add_mul_I]\n  rw [re_add_im]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 exp x = exp \u2191x.re * (cos \u2191x.im + sin \u2191x.im * I)"}, {"line": "rw [\u2190 exp_add_mul_I]", "tactic_state": "x : \u2102\n\u22a2 exp x = exp (\u2191x.re + \u2191x.im * I)"}, {"line": "rw [re_add_im]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_re : (exp x).re = Real.exp x.re * Real.cos x.im := by\n  rw [exp_eq_exp_re_mul_sin_add_cos]\n  simp [exp_ofReal_re, cos_ofReal_re]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 (exp x).re = Real.exp x.re * Real.cos x.im"}, {"line": "rw [exp_eq_exp_re_mul_sin_add_cos]", "tactic_state": "x : \u2102\n\u22a2 (exp \u2191x.re * (cos \u2191x.im + sin \u2191x.im * I)).re = Real.exp x.re * Real.cos x.im"}, {"line": "simp [exp_ofReal_re, cos_ofReal_re]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_im : (exp x).im = Real.exp x.re * Real.sin x.im := by\n  rw [exp_eq_exp_re_mul_sin_add_cos]\n  simp [exp_ofReal_re, sin_ofReal_re]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 (exp x).im = Real.exp x.re * Real.sin x.im"}, {"line": "rw [exp_eq_exp_re_mul_sin_add_cos]", "tactic_state": "x : \u2102\n\u22a2 (exp \u2191x.re * (cos \u2191x.im + sin \u2191x.im * I)).im = Real.exp x.re * Real.sin x.im"}, {"line": "simp [exp_ofReal_re, sin_ofReal_re]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_ofReal_mul_I_re (x : \u211d) : (exp (x * I)).re = Real.cos x := by\n  simp [exp_mul_I, cos_ofReal_re]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 (exp (\u2191x * I)).re = Real.cos x"}, {"line": "simp [exp_mul_I, cos_ofReal_re]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_ofReal_mul_I_im (x : \u211d) : (exp (x * I)).im = Real.sin x := by\n  simp [exp_mul_I, sin_ofReal_re]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 (exp (\u2191x * I)).im = Real.sin x"}, {"line": "simp [exp_mul_I, sin_ofReal_re]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_add_sin_mul_I_pow (n : \u2115) (z : \u2102) :\n    (cos z + sin z * I) ^ n = cos (\u2191n * z) + sin (\u2191n * z) * I := by\n  rw [\u2190 exp_mul_I]\n  rw [\u2190 exp_mul_I]\n  rw [\u2190 exp_nat_mul]\n  rw [mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex"], "variables": ["(x y : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nz : \u2102\n\u22a2 (cos z + sin z * I) ^ n = cos (\u2191n * z) + sin (\u2191n * z) * I"}, {"line": "rw [\u2190 exp_mul_I]", "tactic_state": "n : \u2115\nz : \u2102\n\u22a2 exp (z * I) ^ n = cos (\u2191n * z) + sin (\u2191n * z) * I"}, {"line": "rw [\u2190 exp_mul_I]", "tactic_state": "n : \u2115\nz : \u2102\n\u22a2 exp (z * I) ^ n = exp (\u2191n * z * I)"}, {"line": "rw [\u2190 exp_nat_mul]", "tactic_state": "n : \u2115\nz : \u2102\n\u22a2 exp (\u2191n * (z * I)) = exp (\u2191n * z * I)"}, {"line": "rw [mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_zero : sin 0 = 0 := by simp [sin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sin 0 = 0"}, {"line": "simp [sin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_neg : sin (-x) = -sin x := by simp [sin, exp_neg, (neg_div _ _).symm, add_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 sin (-\u2191x) = -sin \u2191x"}, {"line": "simp [sin, exp_neg, (neg_div _ _).symm, add_mul]", "tactic_state": "x : \u211d\n\u22a2 (exp (\u2191x * I) - (exp (\u2191x * I))\u207b\u00b9) * I / 2 = -(((exp (\u2191x * I))\u207b\u00b9 - exp (\u2191x * I)) * I) / 2"}]}
{"declaration": "theorem cos_zero : cos 0 = 1 := by simp [cos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 cos 0 = 1"}, {"line": "simp [cos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_neg : cos (-x) = cos x := by simp [cos, exp_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 cos (-\u2191x) = cos \u2191x"}, {"line": "simp [cos, exp_neg]", "tactic_state": "x : \u211d\n\u22a2 ((exp (\u2191x * I))\u207b\u00b9 + exp (\u2191x * I)) / 2 = (exp (\u2191x * I) + (exp (\u2191x * I))\u207b\u00b9) / 2"}]}
{"declaration": "theorem sin_sub : sin (x - y) = sin x * cos y - cos x * sin y := by\n  simp [sub_eq_add_neg, sin_add, sin_neg, cos_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 sin (\u2191x - \u2191y) = sin \u2191x * cos \u2191y - cos \u2191x * sin \u2191y"}, {"line": "simp [sub_eq_add_neg, sin_add, sin_neg, cos_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_sub : cos (x - y) = cos x * cos y + sin x * sin y := by\n  simp [sub_eq_add_neg, cos_add, sin_neg, cos_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 cos (\u2191x - \u2191y) = cos \u2191x * cos \u2191y + sin \u2191x * sin \u2191y"}, {"line": "simp [sub_eq_add_neg, cos_add, sin_neg, cos_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_mul_sin_mul_sin (x y : \u211d) : 2 * sin x * sin y = cos (x - y) - cos (x + y) := by\n  simp [cos_add, cos_sub]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 2 * sin \u2191x * sin \u2191y = cos (\u2191x - \u2191y) - cos (\u2191x + \u2191y)"}, {"line": "simp [cos_add, cos_sub]", "tactic_state": "x y : \u211d\n\u22a2 2 * sin \u2191x * sin \u2191y = sin \u2191x * sin \u2191y + sin \u2191x * sin \u2191y"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_mul_cos_mul_cos (x y : \u211d) : 2 * cos x * cos y = cos (x - y) + cos (x + y) := by\n  simp [cos_add, cos_sub]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 2 * cos \u2191x * cos \u2191y = cos (\u2191x - \u2191y) + cos (\u2191x + \u2191y)"}, {"line": "simp [cos_add, cos_sub]", "tactic_state": "x y : \u211d\n\u22a2 2 * cos \u2191x * cos \u2191y = cos \u2191x * cos \u2191y + cos \u2191x * cos \u2191y"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_mul_sin_mul_cos (x y : \u211d) : 2 * sin x * cos y = sin (x - y) + sin (x + y) := by\n  simp [sin_add, sin_sub]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 2 * sin \u2191x * cos \u2191y = sin (\u2191x - \u2191y) + sin (\u2191x + \u2191y)"}, {"line": "simp [sin_add, sin_sub]", "tactic_state": "x y : \u211d\n\u22a2 2 * sin \u2191x * cos \u2191y = sin \u2191x * cos \u2191y + sin \u2191x * cos \u2191y"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_mul_cos {x : \u211d} (hx : cos x \u2260 0) : tan x * cos x = sin x := by\n  rw [tan_eq_sin_div_cos]\n  rw [div_mul_cancel\u2080 _ hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : cos \u2191x \u2260 0\n\u22a2 tan \u2191x * cos \u2191x = sin \u2191x"}, {"line": "rw [tan_eq_sin_div_cos]", "tactic_state": "x : \u211d\nhx : cos \u2191x \u2260 0\n\u22a2 sin \u2191x / cos \u2191x * cos \u2191x = sin \u2191x"}, {"line": "rw [div_mul_cancel\u2080 _ hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_zero : tan 0 = 0 := by simp [tan]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 tan 0 = 0"}, {"line": "simp [tan]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_neg : tan (-x) = -tan x := by simp [tan, neg_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 tan (-\u2191x) = -tan \u2191x"}, {"line": "simp [tan, neg_div]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_sq_add_sin_sq : cos x ^ 2 + sin x ^ 2 = 1 := by rw [add_comm, sin_sq_add_cos_sq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 cos \u2191x ^ 2 + sin \u2191x ^ 2 = 1"}, {"line": "rw [add_comm, sin_sq_add_cos_sq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_sq' : cos x ^ 2 = 1 - sin x ^ 2 := by rw [\u2190 sin_sq_add_cos_sq x, add_sub_cancel_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 cos \u2191x ^ 2 = 1 - sin \u2191x ^ 2"}, {"line": "rw [\u2190 sin_sq_add_cos_sq x, add_sub_cancel_left]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sin_sq_eq_half_sub : sin x ^ 2 = 1 / 2 - cos (2 * x) / 2 := by\n  rw [sin_sq]\n  rw [cos_sq]\n  rw [\u2190 sub_sub]\n  rw [sub_half]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 sin \u2191x ^ 2 = 1 / 2 - cos (2 * \u2191x) / 2"}, {"line": "rw [sin_sq]", "tactic_state": "x : \u211d\n\u22a2 1 - cos \u2191x ^ 2 = 1 / 2 - cos (2 * \u2191x) / 2"}, {"line": "rw [cos_sq]", "tactic_state": "x : \u211d\n\u22a2 1 - (1 / 2 + cos (2 * \u2191x) / 2) = 1 / 2 - cos (2 * \u2191x) / 2"}, {"line": "rw [\u2190 sub_sub]", "tactic_state": "x : \u211d\n\u22a2 1 - 1 / 2 - cos (2 * \u2191x) / 2 = 1 / 2 - cos (2 * \u2191x) / 2"}, {"line": "rw [sub_half]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_zero : sinh 0 = 0 := by simp [sinh]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sinh 0 = 0"}, {"line": "simp [sinh]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_neg : sinh (-x) = -sinh x := by simp [sinh, exp_neg, (neg_div _ _).symm, add_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 sinh (-\u2191x) = -sinh \u2191x"}, {"line": "simp [sinh, exp_neg, (neg_div _ _).symm, add_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cosh_zero : cosh 0 = 1 := by simp [cosh]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 cosh 0 = 1"}, {"line": "simp [cosh]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cosh_abs : cosh |x| = cosh x := by\n  cases le_total x 0 <;> simp [*, abs_of_nonneg, abs_of_nonpos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 cosh sorry = cosh \u2191x"}, {"line": "cases le_total x 0 <;> simp [*, abs_of_nonneg, abs_of_nonpos]", "tactic_state": "case inl\nx : \u211d\nh\u271d : x \u2264 0\n\u22a2 cosh (sorry ()) = cosh \u2191x\n---\ncase inr\nx : \u211d\nh\u271d : 0 \u2264 x\n\u22a2 cosh (sorry ()) = cosh \u2191x"}]}
{"declaration": "theorem sinh_sub : sinh (x - y) = sinh x * cosh y - cosh x * sinh y := by\n  simp [sub_eq_add_neg, sinh_add, sinh_neg, cosh_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 sinh (\u2191x - \u2191y) = sinh \u2191x * cosh \u2191y - cosh \u2191x * sinh \u2191y"}, {"line": "simp [sub_eq_add_neg, sinh_add, sinh_neg, cosh_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cosh_sub : cosh (x - y) = cosh x * cosh y - sinh x * sinh y := by\n  simp [sub_eq_add_neg, cosh_add, sinh_neg, cosh_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 cosh (\u2191x - \u2191y) = cosh \u2191x * cosh \u2191y - sinh \u2191x * sinh \u2191y"}, {"line": "simp [sub_eq_add_neg, cosh_add, sinh_neg, cosh_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tanh_zero : tanh 0 = 0 := by simp [tanh]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 tanh 0 = 0"}, {"line": "simp [tanh]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tanh_neg : tanh (-x) = -tanh x := by simp [tanh, neg_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 tanh (-\u2191x) = -tanh \u2191x"}, {"line": "simp [tanh, neg_div]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_add_cosh : sinh x + cosh x = exp x := by rw [add_comm, cosh_add_sinh]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 sinh \u2191x + cosh \u2191x = exp \u2191x"}, {"line": "rw [add_comm, cosh_add_sinh]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sinh_sub_cosh : sinh x - cosh x = -exp (-x) := by rw [\u2190 neg_sub, cosh_sub_sinh]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 sinh \u2191x - cosh \u2191x = -exp (-\u2191x)"}, {"line": "rw [\u2190 neg_sub, cosh_sub_sinh]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_one_le : cos 1 \u2264 5 / 9 :=\n  calc\n    cos 1 \u2264 |(1 : \u211d)| ^ 4 * (5 / 96) + (1 - 1 ^ 2 / 2) :=\n      sub_le_iff_le_add.1 (abs_sub_le_iff.1 (cos_bound (by simp))).1\n    _ \u2264 5 / 9 := by norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Function.const Lean.Name () `12.4.12.54.4.54._sorry._@._hyg.85 \u2264 5 / 9"}, {"line": "norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : \u211d) : 0 < x.cosh := by positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset", "Lean.Meta Qq"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 y\u271d : \u2102\nx\u271d y x : \u211d\n\u22a2 0 < Real.cosh x"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_cos_add_sin_mul_I (x : \u211d) : \u2016cos x + sin x * I\u2016 = 1 := by\n  have := Real.sin_sq_add_cos_sq x\n  simp_all [add_comm, norm_def, normSq, sq, sin_ofReal_re, cos_ofReal_re, mul_re]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset", "Lean.Meta Qq"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 \u2016cos \u2191x + sin \u2191x * I\u2016 = 1"}, {"line": "have := Real.sin_sq_add_cos_sq x", "tactic_state": "x : \u211d\nthis : Real.sin x ^ 2 + Real.cos x ^ 2 = 1\n\u22a2 \u2016cos \u2191x + sin \u2191x * I\u2016 = 1"}, {"line": "simp_all [add_comm, norm_def, normSq, sq, sin_ofReal_re, cos_ofReal_re, mul_re]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_exp_ofReal_mul_I (x : \u211d) : \u2016exp (x * I)\u2016 = 1 := by\n  rw [exp_mul_I]\n  rw [norm_cos_add_sin_mul_I]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset", "Lean.Meta Qq"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 \u2016exp (\u2191x * I)\u2016 = 1"}, {"line": "rw [exp_mul_I]", "tactic_state": "x : \u211d\n\u22a2 \u2016cos \u2191x + sin \u2191x * I\u2016 = 1"}, {"line": "rw [norm_cos_add_sin_mul_I]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_exp (z : \u2102) : \u2016exp z\u2016 = Real.exp z.re := by\n  rw [exp_eq_exp_re_mul_sin_add_cos]\n  rw [Complex.norm_mul]\n  rw [norm_exp_ofReal]\n  rw [norm_cos_add_sin_mul_I]\n  rw [mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset", "Lean.Meta Qq"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2102\n\u22a2 \u2016exp z\u2016 = Real.exp z.re"}, {"line": "rw [exp_eq_exp_re_mul_sin_add_cos]", "tactic_state": "z : \u2102\n\u22a2 \u2016exp \u2191z.re * (cos \u2191z.im + sin \u2191z.im * I)\u2016 = Real.exp z.re"}, {"line": "rw [Complex.norm_mul]", "tactic_state": "z : \u2102\n\u22a2 \u2016exp \u2191z.re\u2016 * \u2016cos \u2191z.im + sin \u2191z.im * I\u2016 = Real.exp z.re"}, {"line": "rw [norm_exp_ofReal]", "tactic_state": "z : \u2102\n\u22a2 Real.exp z.re * \u2016cos \u2191z.im + sin \u2191z.im * I\u2016 = Real.exp z.re"}, {"line": "rw [norm_cos_add_sin_mul_I]", "tactic_state": "z : \u2102\n\u22a2 Real.exp z.re * 1 = Real.exp z.re"}, {"line": "rw [mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_exp_eq_iff_re_eq {x y : \u2102} : \u2016exp x\u2016 = \u2016exp y\u2016 \u2194 x.re = y.re := by\n  rw [norm_exp]\n  rw [norm_exp]\n  rw [Real.exp_eq_exp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Complex/Trigonometric.lean", "context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset", "Lean.Meta Qq"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\n\u22a2 \u2016exp x\u2016 = \u2016exp y\u2016 \u2194 x.re = y.re"}, {"line": "rw [norm_exp]", "tactic_state": "x y : \u2102\n\u22a2 Real.exp x.re = \u2016exp y\u2016 \u2194 x.re = y.re"}, {"line": "rw [norm_exp]", "tactic_state": "x y : \u2102\n\u22a2 Real.exp x.re = Real.exp y.re \u2194 x.re = y.re"}, {"line": "rw [Real.exp_eq_exp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uncountable_iff_isEmpty_embedding : Uncountable \u03b1 \u2194 IsEmpty (\u03b1 \u21aa \u2115) := by\n  rw [\u2190 not_countable_iff]\n  rw [countable_iff_nonempty_embedding]\n  rw [not_nonempty_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Countable/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u\n\u22a2 Uncountable \u03b1 \u2194 IsEmpty (\u03b1 \u21aa \u2115)"}, {"line": "rw [\u2190 not_countable_iff]", "tactic_state": "\u03b1 : Sort u\n\u22a2 \u00acCountable \u03b1 \u2194 IsEmpty (\u03b1 \u21aa \u2115)"}, {"line": "rw [countable_iff_nonempty_embedding]", "tactic_state": "\u03b1 : Sort u\n\u22a2 \u00acNonempty (\u03b1 \u21aa \u2115) \u2194 IsEmpty (\u03b1 \u21aa \u2115)"}, {"line": "rw [not_nonempty_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma countable_left_of_prod_of_nonempty [Nonempty \u03b2] (h : Countable (\u03b1 \u00d7 \u03b2)) : Countable \u03b1 := by\n  contrapose h\n  rw [not_countable_iff] at *\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Countable/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03c0 : \u03b1 \u2192 Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Nonempty \u03b2\nh : Countable (\u03b1 \u00d7 \u03b2)\n\u22a2 Countable \u03b1"}, {"line": "contrapose h", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Nonempty \u03b2\nh : \u00acCountable \u03b1\n\u22a2 \u00acCountable (\u03b1 \u00d7 \u03b2)"}, {"line": "rw [not_countable_iff] at *", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Nonempty \u03b2\nh : Uncountable \u03b1\n\u22a2 Uncountable (\u03b1 \u00d7 \u03b2)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "lemma countable_right_of_prod_of_nonempty [Nonempty \u03b1] (h : Countable (\u03b1 \u00d7 \u03b2)) : Countable \u03b2 := by\n  contrapose h\n  rw [not_countable_iff] at *\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Countable/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v}", "{\u03b1 : Type u} {\u03b2 : Type v} {\u03c0 : \u03b1 \u2192 Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Nonempty \u03b1\nh : Countable (\u03b1 \u00d7 \u03b2)\n\u22a2 Countable \u03b2"}, {"line": "contrapose h", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Nonempty \u03b1\nh : \u00acCountable \u03b2\n\u22a2 \u00acCountable (\u03b1 \u00d7 \u03b2)"}, {"line": "rw [not_countable_iff] at *", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Nonempty \u03b1\nh : Uncountable \u03b2\n\u22a2 Uncountable (\u03b1 \u00d7 \u03b2)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uncountable_iff_forall_not_surjective [Nonempty \u03b1] :\n    Uncountable \u03b1 \u2194 \u2200 f : \u2115 \u2192 \u03b1, \u00acSurjective f := by\n  rw [\u2190 not_countable_iff]\n  rw [countable_iff_exists_surjective]\n  rw [not_exists]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Countable/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u\ninst\u271d : Nonempty \u03b1\n\u22a2 Uncountable \u03b1 \u2194 \u2200 (f : \u2115 \u2192 \u03b1), \u00acSurjective f"}, {"line": "rw [\u2190 not_countable_iff]", "tactic_state": "\u03b1 : Sort u\ninst\u271d : Nonempty \u03b1\n\u22a2 \u00acCountable \u03b1 \u2194 \u2200 (f : \u2115 \u2192 \u03b1), \u00acSurjective f"}, {"line": "rw [countable_iff_exists_surjective]", "tactic_state": "\u03b1 : Sort u\ninst\u271d : Nonempty \u03b1\n\u22a2 (\u00ac\u2203 f, Surjective f) \u2194 \u2200 (f : \u2115 \u2192 \u03b1), \u00acSurjective f\n---\n\u03b1 : Sort u\ninst\u271d : Nonempty \u03b1\n\u22a2 Nonempty \u03b1"}, {"line": "rw [not_exists]", "tactic_state": "\u03b1 : Sort u\ninst\u271d : Nonempty \u03b1\n\u22a2 Nonempty \u03b1"}]}
{"declaration": "theorem Uncountable.of_not_small {\u03b1 : Type v} (h : \u00ac Small.{w} \u03b1) : Uncountable \u03b1 := by\n  rw [uncountable_iff_not_countable]\n  exact mt (@Countable.toSmall \u03b1) h", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Countable/Small.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type v\nh : \u00acSmall.{w, v} \u03b1\n\u22a2 Uncountable \u03b1"}, {"line": "rw [uncountable_iff_not_countable]", "tactic_state": "\u03b1 : Type v\nh : \u00acSmall.{w, v} \u03b1\n\u22a2 \u00acCountable \u03b1"}, {"line": "exact mt (@Countable.toSmall \u03b1) h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dfinsuppSumAddHom_mem [\u2200 i, AddZeroClass (\u03b2 i)] [AddCommMonoid \u03b3] {S : Type*}\n    [SetLike S \u03b3] [AddSubmonoidClass S \u03b3] (s : S) (f : \u03a0\u2080 i, \u03b2 i) (g : \u2200 i, \u03b2 i \u2192+ \u03b3)\n    (h : \u2200 c, f c \u2260 0 \u2192 g c (f c) \u2208 s) : DFinsupp.sumAddHom g f \u2208 s := by\n  classical\n    rw [DFinsupp.sumAddHom_apply]\n    exact dfinsuppSum_mem s f (g \u00b7) h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/Submonoid.lean", "context": {"open": ["DFinsupp"], "variables": ["{\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082}", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b2 : AddCommMonoid \u03b3\nS : Type u_1\ninst\u271d\u00b9 : SetLike S \u03b3\ninst\u271d : AddSubmonoidClass S \u03b3\ns : S\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ng : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nh : \u2200 (c : \u03b9), f c \u2260 0 \u2192 (g c) (f c) \u2208 s\n\u22a2 (sumAddHom g) f \u2208 s"}, {"line": "classical\n    rw [DFinsupp.sumAddHom_apply]\n    exact dfinsuppSum_mem s f (g \u00b7) h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem liftAddHom_apply_single [\u2200 i, AddZeroClass (\u03b2 i)] [AddCommMonoid \u03b3] (f : \u2200 i, \u03b2 i \u2192+ \u03b3)\n    (i : \u03b9) (x : \u03b2 i) : liftAddHom f (single i x) = f i x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/BigOperators.lean", "context": {"open": [], "variables": ["{\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082}", "[DecidableEq \u03b9]", "[\u03a0 i, Zero (\u03b2 i)] [CommMonoidWithZero \u03b3] [Nontrivial \u03b3] [NoZeroDivisors \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2074 : CommMonoidWithZero \u03b3\ninst\u271d\u00b3 : Nontrivial \u03b3\ninst\u271d\u00b2 : NoZeroDivisors \u03b3\nx\u271d : Sort u_1\nliftAddHom : x\u271d\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d : AddCommMonoid \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\ni : \u03b9\nx : \u03b2 i\n\u22a2 sorry = (f i) x"}, {"line": "simp", "tactic_state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2074 : CommMonoidWithZero \u03b3\ninst\u271d\u00b3 : Nontrivial \u03b3\ninst\u271d\u00b2 : NoZeroDivisors \u03b3\nx\u271d : Sort u_1\nliftAddHom : x\u271d\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d : AddCommMonoid \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\ni : \u03b9\nx : \u03b2 i\n\u22a2 sorry () = (f i) x"}]}
{"declaration": "theorem liftAddHom_comp_single [\u2200 i, AddZeroClass (\u03b2 i)] [AddCommMonoid \u03b3] (f : \u2200 i, \u03b2 i \u2192+ \u03b3)\n    (i : \u03b9) : (liftAddHom f).comp (singleAddHom \u03b2 i) = f i := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/BigOperators.lean", "context": {"open": [], "variables": ["{\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082}", "[DecidableEq \u03b9]", "[\u03a0 i, Zero (\u03b2 i)] [CommMonoidWithZero \u03b3] [Nontrivial \u03b3] [NoZeroDivisors \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2074 : CommMonoidWithZero \u03b3\ninst\u271d\u00b3 : Nontrivial \u03b3\ninst\u271d\u00b2 : NoZeroDivisors \u03b3\nx\u271d : Sort u_1\nliftAddHom : x\u271d\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d : AddCommMonoid \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\ni : \u03b9\n\u22a2 sorry = f i"}, {"line": "simp", "tactic_state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2074 : CommMonoidWithZero \u03b3\ninst\u271d\u00b3 : Nontrivial \u03b3\ninst\u271d\u00b2 : NoZeroDivisors \u03b3\nx\u271d : Sort u_1\nliftAddHom : x\u271d\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d : AddCommMonoid \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\ni : \u03b9\n\u22a2 sorry () = f i"}]}
{"declaration": "theorem prod_subtypeDomain_index [\u2200 i, Zero (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)]\n    [CommMonoid \u03b3] {v : \u03a0\u2080 i, \u03b2 i} {p : \u03b9 \u2192 Prop} [DecidablePred p] {h : \u2200 i, \u03b2 i \u2192 \u03b3}\n    (hp : \u2200 x \u2208 v.support, p x) : (v.subtypeDomain p).prod (fun i b => h i b) = v.prod h := by\n  refine Finset.prod_bij (fun p _ \u21a6 p) ?_ ?_ ?_ ?_ <;> aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/BigOperators.lean", "context": {"open": [], "variables": ["{\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082}", "[DecidableEq \u03b9]", "[\u03a0 i, Zero (\u03b2 i)] [CommMonoidWithZero \u03b3] [Nontrivial \u03b3] [NoZeroDivisors \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2078 : DecidableEq \u03b9\ninst\u271d\u2077 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2076 : CommMonoidWithZero \u03b3\ninst\u271d\u2075 : Nontrivial \u03b3\ninst\u271d\u2074 : NoZeroDivisors \u03b3\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d\u00b9 : CommMonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), \u03b2 i\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\nh : (i : \u03b9) \u2192 \u03b2 i \u2192 \u03b3\nhp : \u2200 x \u2208 v.support, p x\n\u22a2 ((DFinsupp.subtypeDomain p v).prod fun i b => h (\u2191i) b) = v.prod h"}, {"line": "refine Finset.prod_bij (fun p _ \u21a6 p) ?_ ?_ ?_ ?_ <;> aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem single_eq_of_sigma_eq {i j} {xi : \u03b2 i} {xj : \u03b2 j} (h : (\u27e8i, xi\u27e9 : Sigma \u03b2) = \u27e8j, xj\u27e9) :\n    DFinsupp.single i xi = DFinsupp.single j xj := by\n  cases h\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/Defs.lean", "context": {"open": [], "variables": ["{\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082}", "(\u03b2) in", "[\u2200 i, Zero (\u03b2 i)] [\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(x y : \u03a0\u2080 i, \u03b2 i) (s : Set \u03b9) [\u2200 i, Decidable (i \u2208 s)]", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "[\u2200 i, Zero (\u03b2 i)]", "[DecidableEq \u03b9]", "{s : Finset \u03b9} {x : \u2200 i : (\u2191s : Set \u03b9), \u03b2 i} {i : \u03b9}", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b9\ni j : \u03b9\nxi : \u03b2 i\nxj : \u03b2 j\nh : \u27e8i, xi\u27e9 = \u27e8j, xj\u27e9\n\u22a2 (fun\u2080 | i => xi) = fun\u2080 | j => xj"}, {"line": "cases h", "tactic_state": "case refl\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b9\ni : \u03b9\nxi : \u03b2 i\n\u22a2 (fun\u2080 | i => xi) = fun\u2080 | i => xi"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem equivFunOnFintype_single [Fintype \u03b9] (i : \u03b9) (m : \u03b2 i) :\n    (@DFinsupp.equivFunOnFintype \u03b9 \u03b2 _ _) (DFinsupp.single i m) = Pi.single i m := by\n  ext x\n  dsimp [Pi.single, Function.update]\n  simp [DFinsupp.single_eq_pi_single, @eq_comm _ i]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/Defs.lean", "context": {"open": [], "variables": ["{\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082}", "(\u03b2) in", "[\u2200 i, Zero (\u03b2 i)] [\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(x y : \u03a0\u2080 i, \u03b2 i) (s : Set \u03b9) [\u2200 i, Decidable (i \u2208 s)]", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "[\u2200 i, Zero (\u03b2 i)]", "[DecidableEq \u03b9]", "{s : Finset \u03b9} {x : \u2200 i : (\u2191s : Set \u03b9), \u03b2 i} {i : \u03b9}", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ni : \u03b9\nm : \u03b2 i\n\u22a2 (DFinsupp.equivFunOnFintype fun\u2080 | i => m) = Pi.single i m"}, {"line": "ext x", "tactic_state": "case h\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ni : \u03b9\nm : \u03b2 i\nx : \u03b9\n\u22a2 DFinsupp.equivFunOnFintype (fun\u2080 | i => m) x = Pi.single i m x"}, {"line": "dsimp [Pi.single, Function.update]", "tactic_state": "case h\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ni : \u03b9\nm : \u03b2 i\nx : \u03b9\n\u22a2 (fun\u2080 | i => m) x = if h : x = i then \u22ef \u25b8 m else 0"}, {"line": "simp [DFinsupp.single_eq_pi_single, @eq_comm _ i]", "tactic_state": "case h\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ni : \u03b9\nm : \u03b2 i\nx : \u03b9\n\u22a2 (if h : i = x then h \u25b8 m else 0) = if h : x = i then \u22ef \u25b8 m else 0"}]}
{"declaration": "theorem erase_same {i : \u03b9} {f : \u03a0\u2080 i, \u03b2 i} : (f.erase i) i = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/Defs.lean", "context": {"open": [], "variables": ["{\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082}", "(\u03b2) in", "[\u2200 i, Zero (\u03b2 i)] [\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(x y : \u03a0\u2080 i, \u03b2 i) (s : Set \u03b9) [\u2200 i, Decidable (i \u2208 s)]", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "[\u2200 i, Zero (\u03b2 i)]", "[DecidableEq \u03b9]", "{s : Finset \u03b9} {x : \u2200 i : (\u2191s : Set \u03b9), \u03b2 i} {i : \u03b9}", "[DecidableEq \u03b9]", "[\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b9\ni : \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\n\u22a2 (DFinsupp.erase i f) i = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem erase_ne {i i' : \u03b9} {f : \u03a0\u2080 i, \u03b2 i} (h : i' \u2260 i) : (f.erase i) i' = f i' := by simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/Defs.lean", "context": {"open": [], "variables": ["{\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082}", "(\u03b2) in", "[\u2200 i, Zero (\u03b2 i)] [\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(x y : \u03a0\u2080 i, \u03b2 i) (s : Set \u03b9) [\u2200 i, Decidable (i \u2208 s)]", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "[\u2200 i, Zero (\u03b2 i)]", "[DecidableEq \u03b9]", "{s : Finset \u03b9} {x : \u2200 i : (\u2191s : Set \u03b9), \u03b2 i} {i : \u03b9}", "[DecidableEq \u03b9]", "[\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b9\ni i' : \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\nh : i' \u2260 i\n\u22a2 (DFinsupp.erase i f) i' = f i'"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_mk_support (f : \u03a0\u2080 i, \u03b2 i) : f = mk f.support fun i => f i := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/Defs.lean", "context": {"open": [], "variables": ["{\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082}", "(\u03b2) in", "[\u2200 i, Zero (\u03b2 i)] [\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(x y : \u03a0\u2080 i, \u03b2 i) (s : Set \u03b9) [\u2200 i, Decidable (i \u2208 s)]", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "[\u2200 i, Zero (\u03b2 i)]", "[DecidableEq \u03b9]", "{s : Finset \u03b9} {x : \u2200 i : (\u2191s : Set \u03b9), \u03b2 i} {i : \u03b9}", "[DecidableEq \u03b9]", "[\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(f : \u03a0\u2080 i, \u03b2 i) (i) (b : \u03b2 i)", "(j : \u03b9)", "[DecidableEq \u03b9]", "[\u2200 i, AddZeroClass (\u03b2 i)]", "(\u03b2)", "{\u03b2}", "[\u2200 i, Zero (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2076 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\nx\u271d : Sort u_1\nmk : x\u271d\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\n\u22a2 f = sorry"}, {"line": "aesop", "tactic_state": "\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst_1 inst_2 inst_3 : DecidableEq \u03b9\ninst_4 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst_5 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst_6 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\nx : Sort u_1\nmk : x\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\n\u22a2 f = sorry ()"}]}
{"declaration": "theorem support_subset_iff {s : Set \u03b9} {f : \u03a0\u2080 i, \u03b2 i} : \u2191f.support \u2286 s \u2194 \u2200 i \u2209 s, f i = 0 := by\n  simpa [Set.subset_def] using forall_congr' fun i => not_imp_comm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/Defs.lean", "context": {"open": [], "variables": ["{\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082}", "(\u03b2) in", "[\u2200 i, Zero (\u03b2 i)] [\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(x y : \u03a0\u2080 i, \u03b2 i) (s : Set \u03b9) [\u2200 i, Decidable (i \u2208 s)]", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "[\u2200 i, Zero (\u03b2 i)]", "[DecidableEq \u03b9]", "{s : Finset \u03b9} {x : \u2200 i : (\u2191s : Set \u03b9), \u03b2 i} {i : \u03b9}", "[DecidableEq \u03b9]", "[\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(f : \u03a0\u2080 i, \u03b2 i) (i) (b : \u03b2 i)", "(j : \u03b9)", "[DecidableEq \u03b9]", "[\u2200 i, AddZeroClass (\u03b2 i)]", "(\u03b2)", "{\u03b2}", "[\u2200 i, Zero (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2076 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ns : Set \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\n\u22a2 \u2191f.support \u2286 s \u2194 \u2200 i \u2209 s, f i = 0"}, {"line": "simpa [Set.subset_def] using forall_congr' fun i => not_imp_comm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_mapRange {f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i} {hf : \u2200 i, f i 0 = 0} {g : \u03a0\u2080 i, \u03b2\u2081 i} :\n    (mapRange f hf g).support \u2286 g.support := by simp [mapRange_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/Defs.lean", "context": {"open": [], "variables": ["{\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082}", "(\u03b2) in", "[\u2200 i, Zero (\u03b2 i)] [\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(x y : \u03a0\u2080 i, \u03b2 i) (s : Set \u03b9) [\u2200 i, Decidable (i \u2208 s)]", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "[\u2200 i, Zero (\u03b2 i)]", "[DecidableEq \u03b9]", "{s : Finset \u03b9} {x : \u2200 i : (\u2191s : Set \u03b9), \u03b2 i} {i : \u03b9}", "[DecidableEq \u03b9]", "[\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(f : \u03a0\u2080 i, \u03b2 i) (i) (b : \u03b2 i)", "(j : \u03b9)", "[DecidableEq \u03b9]", "[\u2200 i, AddZeroClass (\u03b2 i)]", "(\u03b2)", "{\u03b2}", "[\u2200 i, Zero (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)]", "[\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "[\u2200 (i) (x : \u03b2\u2081 i), Decidable (x \u2260 0)] [\u2200 (i) (x : \u03b2\u2082 i), Decidable (x \u2260 0)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ninst\u271d\u2078 inst\u271d\u2077 : DecidableEq \u03b9\ninst\u271d\u2076 : (i : \u03b9) \u2192 Zero (\u03b2\u2081 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 Zero (\u03b2\u2082 i)\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Zero (\u03b2\u2081 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2\u2082 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2\u2081 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2\u2082 i) \u2192 Decidable (x \u2260 0)\nx\u271d : Sort u_1\nmapRange : x\u271d\nf : (i : \u03b9) \u2192 \u03b2\u2081 i \u2192 \u03b2\u2082 i\nhf : \u2200 (i : \u03b9), f i 0 = 0\ng : \u03a0\u2080 (i : \u03b9), \u03b2\u2081 i\n\u22a2 sorry \u2286 g.support"}, {"line": "simp [mapRange_def]", "tactic_state": "\u03b9 : Type u\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ninst\u271d\u2078 inst\u271d\u2077 : DecidableEq \u03b9\ninst\u271d\u2076 : (i : \u03b9) \u2192 Zero (\u03b2\u2081 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 Zero (\u03b2\u2082 i)\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Zero (\u03b2\u2081 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2\u2082 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2\u2081 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2\u2082 i) \u2192 Decidable (x \u2260 0)\nx\u271d : Sort u_1\nmapRange : x\u271d\nf : (i : \u03b9) \u2192 \u03b2\u2081 i \u2192 \u03b2\u2082 i\nhf : \u2200 (i : \u03b9), f i 0 = 0\ng : \u03a0\u2080 (i : \u03b9), \u03b2\u2081 i\n\u22a2 sorry () \u2286 g.support"}]}
{"declaration": "theorem support_zipWith {f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i \u2192 \u03b2 i} {hf : \u2200 i, f i 0 0 = 0} {g\u2081 : \u03a0\u2080 i, \u03b2\u2081 i}\n    {g\u2082 : \u03a0\u2080 i, \u03b2\u2082 i} : (zipWith f hf g\u2081 g\u2082).support \u2286 g\u2081.support \u222a g\u2082.support := by\n  simp [zipWith_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/Defs.lean", "context": {"open": [], "variables": ["{\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082}", "(\u03b2) in", "[\u2200 i, Zero (\u03b2 i)] [\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(x y : \u03a0\u2080 i, \u03b2 i) (s : Set \u03b9) [\u2200 i, Decidable (i \u2208 s)]", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "[\u2200 i, Zero (\u03b2 i)]", "[DecidableEq \u03b9]", "{s : Finset \u03b9} {x : \u2200 i : (\u2191s : Set \u03b9), \u03b2 i} {i : \u03b9}", "[DecidableEq \u03b9]", "[\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(f : \u03a0\u2080 i, \u03b2 i) (i) (b : \u03b2 i)", "(j : \u03b9)", "[DecidableEq \u03b9]", "[\u2200 i, AddZeroClass (\u03b2 i)]", "(\u03b2)", "{\u03b2}", "[\u2200 i, Zero (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)]", "[\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "[\u2200 (i) (x : \u03b2\u2081 i), Decidable (x \u2260 0)] [\u2200 (i) (x : \u03b2\u2082 i), Decidable (x \u2260 0)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 : DecidableEq \u03b9\ninst\u271d\u2079 : (i : \u03b9) \u2192 Zero (\u03b2\u2081 i)\ninst\u271d\u2078 : (i : \u03b9) \u2192 Zero (\u03b2\u2082 i)\ninst\u271d\u2077 : DecidableEq \u03b9\ninst\u271d\u2076 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2074 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Zero (\u03b2\u2081 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2\u2082 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2\u2081 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2\u2082 i) \u2192 Decidable (x \u2260 0)\nx\u271d : Sort u_1\nzipWith : x\u271d\nf : (i : \u03b9) \u2192 \u03b2\u2081 i \u2192 \u03b2\u2082 i \u2192 \u03b2 i\nhf : \u2200 (i : \u03b9), f i 0 0 = 0\ng\u2081 : \u03a0\u2080 (i : \u03b9), \u03b2\u2081 i\ng\u2082 : \u03a0\u2080 (i : \u03b9), \u03b2\u2082 i\n\u22a2 sorry \u2286 g\u2081.support \u222a g\u2082.support"}, {"line": "simp [zipWith_def]", "tactic_state": "\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 : DecidableEq \u03b9\ninst\u271d\u2079 : (i : \u03b9) \u2192 Zero (\u03b2\u2081 i)\ninst\u271d\u2078 : (i : \u03b9) \u2192 Zero (\u03b2\u2082 i)\ninst\u271d\u2077 : DecidableEq \u03b9\ninst\u271d\u2076 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2074 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Zero (\u03b2\u2081 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2\u2082 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2\u2081 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2\u2082 i) \u2192 Decidable (x \u2260 0)\nx\u271d : Sort u_1\nzipWith : x\u271d\nf : (i : \u03b9) \u2192 \u03b2\u2081 i \u2192 \u03b2\u2082 i \u2192 \u03b2 i\nhf : \u2200 (i : \u03b9), f i 0 0 = 0\ng\u2081 : \u03a0\u2080 (i : \u03b9), \u03b2\u2081 i\ng\u2082 : \u03a0\u2080 (i : \u03b9), \u03b2\u2082 i\n\u22a2 sorry () \u2286 g\u2081.support \u222a g\u2082.support"}]}
{"declaration": "theorem support_erase (i : \u03b9) (f : \u03a0\u2080 i, \u03b2 i) : (f.erase i).support = f.support.erase i := by\n  ext j\n  by_cases h1 : j = i\n  \u00b7 simp only [h1, mem_support_toFun, erase_apply, ite_true, ne_eq, not_true, not_not,\n      Finset.mem_erase, false_and]\n  by_cases h2 : f j \u2260 0 <;> simp at h2 <;> simp [h1, h2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/Defs.lean", "context": {"open": [], "variables": ["{\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082}", "(\u03b2) in", "[\u2200 i, Zero (\u03b2 i)] [\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(x y : \u03a0\u2080 i, \u03b2 i) (s : Set \u03b9) [\u2200 i, Decidable (i \u2208 s)]", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "[\u2200 i, Zero (\u03b2 i)]", "[DecidableEq \u03b9]", "{s : Finset \u03b9} {x : \u2200 i : (\u2191s : Set \u03b9), \u03b2 i} {i : \u03b9}", "[DecidableEq \u03b9]", "[\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(f : \u03a0\u2080 i, \u03b2 i) (i) (b : \u03b2 i)", "(j : \u03b9)", "[DecidableEq \u03b9]", "[\u2200 i, AddZeroClass (\u03b2 i)]", "(\u03b2)", "{\u03b2}", "[\u2200 i, Zero (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)]", "[\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "[\u2200 (i) (x : \u03b2\u2081 i), Decidable (x \u2260 0)] [\u2200 (i) (x : \u03b2\u2082 i), Decidable (x \u2260 0)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2076 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ni : \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\n\u22a2 (DFinsupp.erase i f).support = f.support.erase i"}, {"line": "ext j", "tactic_state": "case h\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2076 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ni : \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\nj : \u03b9\n\u22a2 j \u2208 (DFinsupp.erase i f).support \u2194 j \u2208 f.support.erase i"}, {"line": "by_cases h1 : j = i", "tactic_state": "case pos\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2076 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ni : \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\nj : \u03b9\nh1 : j = i\n\u22a2 j \u2208 (DFinsupp.erase i f).support \u2194 j \u2208 f.support.erase i\n---\ncase neg\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2076 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ni : \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\nj : \u03b9\nh1 : \u00acj = i\n\u22a2 j \u2208 (DFinsupp.erase i f).support \u2194 j \u2208 f.support.erase i"}, {"line": "\u00b7 simp only [h1, mem_support_toFun, erase_apply, ite_true, ne_eq, not_true, not_not,\n      Finset.mem_erase, false_and]", "tactic_state": "case neg\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2076 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ni : \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\nj : \u03b9\nh1 : \u00acj = i\n\u22a2 j \u2208 (DFinsupp.erase i f).support \u2194 j \u2208 f.support.erase i"}, {"line": "by_cases h2 : f j \u2260 0 <;> simp at h2 <;> simp [h1, h2]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_update (f : \u03a0\u2080 i, \u03b2 i) (i : \u03b9) (b : \u03b2 i) [Decidable (b = 0)] :\n    support (f.update i b) = if b = 0 then support (f.erase i) else insert i f.support := by\n  ext j\n  split_ifs with hb\n  \u00b7 subst hb\n    simp [update_eq_erase, support_erase]\n  \u00b7 rw [support_update_ne_zero f _ hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/Defs.lean", "context": {"open": [], "variables": ["{\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082}", "(\u03b2) in", "[\u2200 i, Zero (\u03b2 i)] [\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(x y : \u03a0\u2080 i, \u03b2 i) (s : Set \u03b9) [\u2200 i, Decidable (i \u2208 s)]", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "[\u2200 i, Zero (\u03b2 i)]", "[DecidableEq \u03b9]", "{s : Finset \u03b9} {x : \u2200 i : (\u2191s : Set \u03b9), \u03b2 i} {i : \u03b9}", "[DecidableEq \u03b9]", "[\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(f : \u03a0\u2080 i, \u03b2 i) (i) (b : \u03b2 i)", "(j : \u03b9)", "[DecidableEq \u03b9]", "[\u2200 i, AddZeroClass (\u03b2 i)]", "(\u03b2)", "{\u03b2}", "[\u2200 i, Zero (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)]", "[\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "[\u2200 (i) (x : \u03b2\u2081 i), Decidable (x \u2260 0)] [\u2200 (i) (x : \u03b2\u2082 i), Decidable (x \u2260 0)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2077 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\nx\u271d : Sort u_1\nsupport : x\u271d\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\nb : \u03b2 i\ninst\u271d : Decidable (b = 0)\n\u22a2 sorry = if b = 0 then sorry else insert i f.support"}, {"line": "ext j", "tactic_state": "case h\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2077 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\nx\u271d : Sort u_1\nsupport : x\u271d\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\nb : \u03b2 i\ninst\u271d : Decidable (b = 0)\nj : \u03b9\n\u22a2 j \u2208 sorry \u2194 j \u2208 if b = 0 then sorry else insert i f.support"}, {"line": "split_ifs with hb", "tactic_state": "case pos\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2077 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\nx\u271d : Sort u_1\nsupport : x\u271d\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\nb : \u03b2 i\ninst\u271d : Decidable (b = 0)\nj : \u03b9\nhb : b = 0\n\u22a2 j \u2208 sorry \u2194 j \u2208 sorry\n---\ncase neg\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2077 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\nx\u271d : Sort u_1\nsupport : x\u271d\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\nb : \u03b2 i\ninst\u271d : Decidable (b = 0)\nj : \u03b9\nhb : \u00acb = 0\n\u22a2 j \u2208 sorry \u2194 j \u2208 insert i f.support"}, {"line": "\u00b7 subst hb\n    simp [update_eq_erase, support_erase]", "tactic_state": "case neg\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2077 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\nx\u271d : Sort u_1\nsupport : x\u271d\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\nb : \u03b2 i\ninst\u271d : Decidable (b = 0)\nj : \u03b9\nhb : \u00acb = 0\n\u22a2 j \u2208 sorry \u2194 j \u2208 insert i f.support"}, {"line": "\u00b7 rw [support_update_ne_zero f _ hb]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_subtypeDomain {f : \u03a0\u2080 i, \u03b2 i} :\n    (subtypeDomain p f).support = f.support.subtype p := by\n  ext i\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/Defs.lean", "context": {"open": [], "variables": ["{\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082}", "(\u03b2) in", "[\u2200 i, Zero (\u03b2 i)] [\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(x y : \u03a0\u2080 i, \u03b2 i) (s : Set \u03b9) [\u2200 i, Decidable (i \u2208 s)]", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "(\u03b3 \u03b2)", "{\u03b3 \u03b2}", "[\u2200 i, Zero (\u03b2 i)]", "[DecidableEq \u03b9]", "{s : Finset \u03b9} {x : \u2200 i : (\u2191s : Set \u03b9), \u03b2 i} {i : \u03b9}", "[DecidableEq \u03b9]", "[\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "(f : \u03a0\u2080 i, \u03b2 i) (i) (b : \u03b2 i)", "(j : \u03b9)", "[DecidableEq \u03b9]", "[\u2200 i, AddZeroClass (\u03b2 i)]", "(\u03b2)", "{\u03b2}", "[\u2200 i, Zero (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)]", "[\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)]", "[\u2200 (i) (x : \u03b2\u2081 i), Decidable (x \u2260 0)] [\u2200 (i) (x : \u03b2\u2082 i), Decidable (x \u2260 0)]", "{p : \u03b9 \u2192 Prop} [DecidablePred p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2077 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\nsubtypeDomain : x\u271d\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\n\u22a2 sorry = Finset.subtype p f.support"}, {"line": "ext i", "tactic_state": "case h\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2077 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\nsubtypeDomain : x\u271d\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : Subtype p\n\u22a2 i \u2208 sorry \u2194 i \u2208 Finset.subtype p f.support"}, {"line": "simp", "tactic_state": "case h\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u2077 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\nsubtypeDomain : x\u271d\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : Subtype p\n\u22a2 i \u2208 sorry () \u2194 \u00acf \u2191i = 0"}]}
{"declaration": "theorem mem_dfinsupp_iff_of_support_subset {t : \u03a0\u2080 i, Finset (\u03b1 i)} (ht : t.support \u2286 s) :\n    f \u2208 s.dfinsupp t \u2194 \u2200 i, f i \u2208 t i := by\n  refine mem_dfinsupp_iff.trans (forall_and.symm.trans <| forall_congr' fun i =>\n      \u27e8 fun h => ?_,\n        fun h => \u27e8fun hi => ht <| mem_support_iff.2 fun H => mem_support_iff.1 hi ?_, fun _ => h\u27e9\u27e9)\n  \u00b7 by_cases hi : i \u2208 s\n    \u00b7 exact h.2 hi\n    \u00b7 rw [not_mem_support_iff.1 (mt h.1 hi), not_mem_support_iff.1 (not_mem_mono ht hi)]\n      exact zero_mem_zero\n  \u00b7 rwa [H, mem_zero] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/Interval.lean", "context": {"open": ["DFinsupp Finset", "Pointwise"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "[DecidableEq \u03b9] [\u2200 i, Zero (\u03b1 i)] {s : Finset \u03b9} {f : \u03a0\u2080 i, \u03b1 i} {t : \u2200 i, Finset (\u03b1 i)}", "[\u2200 i, DecidableEq (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b1 i)\ns : Finset \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b1 i\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b1 i)\nt : \u03a0\u2080 (i : \u03b9), Finset (\u03b1 i)\nht : t.support \u2286 s\n\u22a2 f \u2208 s.dfinsupp \u21d1t \u2194 \u2200 (i : \u03b9), f i \u2208 t i"}, {"line": "refine mem_dfinsupp_iff.trans (forall_and.symm.trans <| forall_congr' fun i =>\n      \u27e8 fun h => ?_,\n        fun h => \u27e8fun hi => ht <| mem_support_iff.2 fun H => mem_support_iff.1 hi ?_, fun _ => h\u27e9\u27e9)", "tactic_state": "case refine_1\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b1 i)\ns : Finset \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b1 i\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b1 i)\nt : \u03a0\u2080 (i : \u03b9), Finset (\u03b1 i)\nht : t.support \u2286 s\n\u22a2 (i : \u03b9) \u2192 DecidableEq (\u03b1 i)\n---\ncase refine_2\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b1 i)\ns : Finset \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b1 i\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b1 i)\nt : \u03a0\u2080 (i : \u03b9), Finset (\u03b1 i)\nht : t.support \u2286 s\ni : \u03b9\nh : (i \u2208 f.support \u2192 i \u2208 s) \u2227 (i \u2208 s \u2192 f i \u2208 t i)\n\u22a2 f i \u2208 t i\n---\ncase refine_3\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b1 i)\ns : Finset \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b1 i\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b1 i)\nt : \u03a0\u2080 (i : \u03b9), Finset (\u03b1 i)\nht : t.support \u2286 s\ni : \u03b9\nh : f i \u2208 t i\nhi : i \u2208 f.support\nH : t i = 0\n\u22a2 f i = 0"}, {"line": "\u00b7 by_cases hi : i \u2208 s\n    \u00b7 exact h.2 hi\n    \u00b7 rw [not_mem_support_iff.1 (mt h.1 hi), not_mem_support_iff.1 (not_mem_mono ht hi)]\n      exact zero_mem_zero", "tactic_state": "case refine_2\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b1 i)\ns : Finset \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b1 i\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b1 i)\nt : \u03a0\u2080 (i : \u03b9), Finset (\u03b1 i)\nht : t.support \u2286 s\ni : \u03b9\nh : (i \u2208 f.support \u2192 i \u2208 s) \u2227 (i \u2208 s \u2192 f i \u2208 t i)\n\u22a2 f i \u2208 t i\n---\ncase refine_3\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b1 i)\ns : Finset \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b1 i\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b1 i)\nt : \u03a0\u2080 (i : \u03b9), Finset (\u03b1 i)\nht : t.support \u2286 s\ni : \u03b9\nh : f i \u2208 t i\nhi : i \u2208 f.support\nH : t i = 0\n\u22a2 f i = 0"}, {"line": "\u00b7 rwa [H, mem_zero] at h", "tactic_state": "case refine_3\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b1 i)\ns : Finset \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b1 i\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b1 i)\nt : \u03a0\u2080 (i : \u03b9), Finset (\u03b1 i)\nht : t.support \u2286 s\ni : \u03b9\nh : f i \u2208 t i\nhi : i \u2208 f.support\nH : t i = 0\n\u22a2 f i = 0"}]}
{"declaration": "theorem toDFinsupp_le_toDFinsupp : toDFinsupp s \u2264 toDFinsupp t \u2194 s \u2264 t := by\n  simp [Multiset.le_iff_count, DFinsupp.le_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/Multiset.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1] {s t : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\nx\u271d : Sort u_2\ntoDFinsupp : x\u271d\n\u22a2 sorry \u2264 sorry \u2194 s \u2264 t"}, {"line": "simp [Multiset.le_iff_count, DFinsupp.le_def]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\nx\u271d : Sort u_2\ntoDFinsupp : x\u271d\n\u22a2 sorry () \u2264 sorry () \u2194 s \u2264 t"}]}
{"declaration": "theorem support_tsub : (f - g).support \u2286 f.support := by\n  simp +contextual only [subset_iff, tsub_eq_zero_iff_le, mem_support_iff,\n    Ne, coe_tsub, Pi.sub_apply, not_imp_not, zero_le, imp_true_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/Order.lean", "context": {"open": ["Finset"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "[\u2200 i, Zero (\u03b1 i)]", "[\u2200 i, LE (\u03b1 i)] {f g : \u03a0\u2080 i, \u03b1 i}", "[\u2200 i, Preorder (\u03b1 i)] {f g : \u03a0\u2080 i, \u03b1 i}", "[\u2200 i, Lattice (\u03b1 i)] (f g : \u03a0\u2080 i, \u03b1 i)", "[DecidableEq \u03b9] [\u2200 (i) (x : \u03b1 i), Decidable (x \u2260 0)]", "{\u03b1 : Type*} {\u03b2 : \u03b9 \u2192 Type*} [Semiring \u03b1] [Preorder \u03b1] [\u2200 i, AddCommMonoid (\u03b2 i)]", "{\u03b1 : Type*} {\u03b2 : \u03b9 \u2192 Type*} [Semiring \u03b1] [PartialOrder \u03b1] [\u2200 i, AddCommMonoid (\u03b2 i)]", "(\u03b1) [\u2200 i, AddCommMonoid (\u03b1 i)] [\u2200 i, PartialOrder (\u03b1 i)] [\u2200 i, CanonicallyOrderedAdd (\u03b1 i)]", "{\u03b1}", "[DecidableEq \u03b9]", "[\u2200 (i) (x : \u03b1 i), Decidable (x \u2260 0)] {f g : \u03a0\u2080 i, \u03b1 i} {s : Finset \u03b9}", "(\u03b1) in", "(\u03b1) [\u2200 i, Sub (\u03b1 i)] [\u2200 i, OrderedSub (\u03b1 i)] {f g : \u03a0\u2080 i, \u03b1 i} {i : \u03b9} {a b : \u03b1 i}", "{\u03b1}", "(\u03b1)", "{\u03b1} [DecidableEq \u03b9]", "[\u2200 (i) (x : \u03b1 i), Decidable (x \u2260 0)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u2077 : (i : \u03b9) \u2192 Zero (\u03b1 i)\ninst\u271d\u2076 : (i : \u03b9) \u2192 LE (\u03b1 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 Preorder (\u03b1 i)\ninst\u271d\u2074 : (i : \u03b9) \u2192 Lattice (\u03b1 i)\nf : \u03a0\u2080 (i : \u03b9), \u03b1 i\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 (x : \u03b1 i) \u2192 Decidable (x \u2260 0)\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b9\n\u22a2 sorry \u2286 f.support"}, {"line": "simp +contextual only [subset_iff, tsub_eq_zero_iff_le, mem_support_iff,\n    Ne, coe_tsub, Pi.sub_apply, not_imp_not, zero_le, imp_true_iff]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u2077 : (i : \u03b9) \u2192 Zero (\u03b1 i)\ninst\u271d\u2076 : (i : \u03b9) \u2192 LE (\u03b1 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 Preorder (\u03b1 i)\ninst\u271d\u2074 : (i : \u03b9) \u2192 Lattice (\u03b1 i)\nf : \u03a0\u2080 (i : \u03b9), \u03b1 i\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 (x : \u03b1 i) \u2192 Decidable (x \u2260 0)\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b9\n\u22a2 \u2200 \u2983x : \u03b9\u2984, x \u2208 sorry \u2192 x \u2208 f.support"}]}
{"declaration": "theorem subset_support_tsub : f.support \\ g.support \u2286 (f - g).support := by\n  simp +contextual [subset_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/Order.lean", "context": {"open": ["Finset"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "[\u2200 i, Zero (\u03b1 i)]", "[\u2200 i, LE (\u03b1 i)] {f g : \u03a0\u2080 i, \u03b1 i}", "[\u2200 i, Preorder (\u03b1 i)] {f g : \u03a0\u2080 i, \u03b1 i}", "[\u2200 i, Lattice (\u03b1 i)] (f g : \u03a0\u2080 i, \u03b1 i)", "[DecidableEq \u03b9] [\u2200 (i) (x : \u03b1 i), Decidable (x \u2260 0)]", "{\u03b1 : Type*} {\u03b2 : \u03b9 \u2192 Type*} [Semiring \u03b1] [Preorder \u03b1] [\u2200 i, AddCommMonoid (\u03b2 i)]", "{\u03b1 : Type*} {\u03b2 : \u03b9 \u2192 Type*} [Semiring \u03b1] [PartialOrder \u03b1] [\u2200 i, AddCommMonoid (\u03b2 i)]", "(\u03b1) [\u2200 i, AddCommMonoid (\u03b1 i)] [\u2200 i, PartialOrder (\u03b1 i)] [\u2200 i, CanonicallyOrderedAdd (\u03b1 i)]", "{\u03b1}", "[DecidableEq \u03b9]", "[\u2200 (i) (x : \u03b1 i), Decidable (x \u2260 0)] {f g : \u03a0\u2080 i, \u03b1 i} {s : Finset \u03b9}", "(\u03b1) in", "(\u03b1) [\u2200 i, Sub (\u03b1 i)] [\u2200 i, OrderedSub (\u03b1 i)] {f g : \u03a0\u2080 i, \u03b1 i} {i : \u03b9} {a b : \u03b1 i}", "{\u03b1}", "(\u03b1)", "{\u03b1} [DecidableEq \u03b9]", "[\u2200 (i) (x : \u03b1 i), Decidable (x \u2260 0)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u2077 : (i : \u03b9) \u2192 Zero (\u03b1 i)\ninst\u271d\u2076 : (i : \u03b9) \u2192 LE (\u03b1 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 Preorder (\u03b1 i)\ninst\u271d\u2074 : (i : \u03b9) \u2192 Lattice (\u03b1 i)\nf g : \u03a0\u2080 (i : \u03b9), \u03b1 i\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 (x : \u03b1 i) \u2192 Decidable (x \u2260 0)\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b9\n\u22a2 f.support \\ g.support \u2286 sorry"}, {"line": "simp +contextual [subset_iff]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u2077 : (i : \u03b9) \u2192 Zero (\u03b1 i)\ninst\u271d\u2076 : (i : \u03b9) \u2192 LE (\u03b1 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 Preorder (\u03b1 i)\ninst\u271d\u2074 : (i : \u03b9) \u2192 Lattice (\u03b1 i)\nf g : \u03a0\u2080 (i : \u03b9), \u03b1 i\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 (x : \u03b1 i) \u2192 Decidable (x \u2260 0)\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b9\n\u22a2 \u2200 \u2983x : \u03b9\u2984, \u00acf x = 0 \u2192 g x = 0 \u2192 x \u2208 sorry ()"}]}
{"declaration": "theorem Lex.acc_of_single_erase [DecidableEq \u03b9] {x : \u03a0\u2080 i, \u03b1 i} (i : \u03b9)\n    (hs : Acc (DFinsupp.Lex r s) <| single i (x i)) (hu : Acc (DFinsupp.Lex r s) <| x.erase i) :\n    Acc (DFinsupp.Lex r s) x := by\n  classical\n    convert \u2190 @Acc.of_fibration _ _ _ _ _ (lex_fibration r s) \u27e8{i}, _\u27e9\n      (InvImage.accessible snd <| hs.prod_gameAdd hu)\n    convert piecewise_single_erase x i\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/DFinsupp/WellFounded.lean", "context": {"open": ["Relation Prod"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "[\u2200 i, Zero (\u03b1 i)] (r : \u03b9 \u2192 \u03b9 \u2192 Prop) (s : \u2200 i, \u03b1 i \u2192 \u03b1 i \u2192 Prop)", "{r s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b1 i)\nr : \u03b9 \u2192 \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b1 i \u2192 Prop\nx\u271d : Sort u_3\nsingle : x\u271d\ninst\u271d : DecidableEq \u03b9\nx : \u03a0\u2080 (i : \u03b9), \u03b1 i\ni : \u03b9\nhs : Acc (DFinsupp.Lex r s) sorry\nhu : Acc (DFinsupp.Lex r s) (DFinsupp.erase i x)\n\u22a2 Acc (DFinsupp.Lex r s) x"}, {"line": "classical\n    convert \u2190 @Acc.of_fibration _ _ _ _ _ (lex_fibration r s) \u27e8{i}, _\u27e9\n      (InvImage.accessible snd <| hs.prod_gameAdd hu)\n    convert piecewise_single_erase x i", "tactic_state": "case convert_1\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b1 i)\nr : \u03b9 \u2192 \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b1 i \u2192 Prop\nx\u271d : Sort u_3\nsingle : x\u271d\ninst\u271d : DecidableEq \u03b9\nx : \u03a0\u2080 (i : \u03b9), \u03b1 i\ni : \u03b9\nhs : Acc (DFinsupp.Lex r s) sorry\nhu : Acc (DFinsupp.Lex r s) (DFinsupp.erase i x)\n\u22a2 Type ?u.3008\n---\ncase convert_2\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b1 i)\nr : \u03b9 \u2192 \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b1 i \u2192 Prop\nx\u271d : Sort u_3\nsingle : x\u271d\ninst\u271d : DecidableEq \u03b9\nx : \u03a0\u2080 (i : \u03b9), \u03b1 i\ni : \u03b9\nhs : Acc (DFinsupp.Lex r s) sorry\nhu : Acc (DFinsupp.Lex r s) (DFinsupp.erase i x)\n\u22a2 ?convert_1 \u2192 ?convert_1 \u2192 Prop\n---\ncase convert_3\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b1 i)\nr : \u03b9 \u2192 \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b1 i \u2192 Prop\nx\u271d : Sort u_3\nsingle : x\u271d\ninst\u271d : DecidableEq \u03b9\nx : \u03a0\u2080 (i : \u03b9), \u03b1 i\ni : \u03b9\nhs : Acc (DFinsupp.Lex r s) sorry\nhu : Acc (DFinsupp.Lex r s) (DFinsupp.erase i x)\n\u22a2 (?convert_4 \u00d7 (\u03a0\u2080 (i : \u03b9), \u03b1 i) \u00d7 \u03a0\u2080 (i : \u03b9), \u03b1 i) \u2192 ?convert_1\n---\ncase convert_4\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b1 i)\nr : \u03b9 \u2192 \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b1 i \u2192 Prop\nx\u271d : Sort u_3\nsingle : x\u271d\ninst\u271d : DecidableEq \u03b9\nx : \u03a0\u2080 (i : \u03b9), \u03b1 i\ni : \u03b9\nhs : Acc (DFinsupp.Lex r s) sorry\nhu : Acc (DFinsupp.Lex r s) (DFinsupp.erase i x)\n\u22a2 Type ?u.3642\n---\ncase convert_5\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b1 i)\nr : \u03b9 \u2192 \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b1 i \u2192 Prop\nx\u271d : Sort u_3\nsingle : x\u271d\ninst\u271d : DecidableEq \u03b9\nx : \u03a0\u2080 (i : \u03b9), \u03b1 i\ni : \u03b9\nhs : Acc (DFinsupp.Lex r s) sorry\nhu : Acc (DFinsupp.Lex r s) (DFinsupp.erase i x)\n\u22a2 Singleton \u03b9 ?convert_4"}]}
{"declaration": "lemma nnreal_smul_lt_top_iff {x : \u211d\u22650} {y : \u211d\u22650\u221e} (hx : x \u2260 0) : x \u2022 y < \u22a4 \u2194 y < \u22a4 := by\n  rw [lt_top_iff_ne_top]\n  rw [lt_top_iff_ne_top]\n  rw [nnreal_smul_ne_top_iff hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Action.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : NNReal\ny : ENNReal\nhx : x \u2260 0\n\u22a2 x \u2022 y < \u22a4 \u2194 y < \u22a4"}, {"line": "rw [lt_top_iff_ne_top]", "tactic_state": "x : NNReal\ny : ENNReal\nhx : x \u2260 0\n\u22a2 x \u2022 y \u2260 \u22a4 \u2194 y < \u22a4"}, {"line": "rw [lt_top_iff_ne_top]", "tactic_state": "x : NNReal\ny : ENNReal\nhx : x \u2260 0\n\u22a2 x \u2022 y \u2260 \u22a4 \u2194 y \u2260 \u22a4"}, {"line": "rw [nnreal_smul_ne_top_iff hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toReal_smul (r : \u211d\u22650) (s : \u211d\u22650\u221e) : (r \u2022 s).toReal = r \u2022 s.toReal := by\n  rw [ENNReal.smul_def]\n  rw [smul_eq_mul]\n  rw [toReal_mul]\n  rw [coe_toReal]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Action.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : NNReal\ns : ENNReal\n\u22a2 (r \u2022 s).toReal = r \u2022 s.toReal"}, {"line": "rw [ENNReal.smul_def]", "tactic_state": "r : NNReal\ns : ENNReal\n\u22a2 (\u2191r \u2022 s).toReal = r \u2022 s.toReal"}, {"line": "rw [smul_eq_mul]", "tactic_state": "r : NNReal\ns : ENNReal\n\u22a2 (\u2191r * s).toReal = r \u2022 s.toReal"}, {"line": "rw [toReal_mul]", "tactic_state": "r : NNReal\ns : ENNReal\n\u22a2 (\u2191r).toReal * s.toReal = r \u2022 s.toReal"}, {"line": "rw [coe_toReal]", "tactic_state": "r : NNReal\ns : ENNReal\n\u22a2 \u2191r * s.toReal = r \u2022 s.toReal"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toReal_sum {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200 a \u2208 s, f a \u2260 \u221e) :\n    ENNReal.toReal (\u2211 a \u2208 s, f a) = \u2211 a \u2208 s, ENNReal.toReal (f a) := by\n  rw [ENNReal.toReal]\n  rw [toNNReal_sum hf]\n  rw [NNReal.coe_sum]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/BigOperators.lean", "context": {"open": ["Set NNReal ENNReal", "Finset"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b1 : Type*}", "{\u03b1 : Type*} {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ns : Finset \u03b1\nf : \u03b1 \u2192 ENNReal\nhf : \u2200 a \u2208 s, f a \u2260 \u22a4\n\u22a2 (\u2211 a \u2208 s, f a).toReal = \u2211 a \u2208 s, (f a).toReal"}, {"line": "rw [ENNReal.toReal]", "tactic_state": "\u03b1 : Type u_2\ns : Finset \u03b1\nf : \u03b1 \u2192 ENNReal\nhf : \u2200 a \u2208 s, f a \u2260 \u22a4\n\u22a2 \u2191(\u2211 a \u2208 s, f a).toNNReal = \u2211 a \u2208 s, (f a).toReal"}, {"line": "rw [toNNReal_sum hf]", "tactic_state": "\u03b1 : Type u_2\ns : Finset \u03b1\nf : \u03b1 \u2192 ENNReal\nhf : \u2200 a \u2208 s, f a \u2260 \u22a4\n\u22a2 \u2191(\u2211 a \u2208 s, (f a).toNNReal) = \u2211 a \u2208 s, (f a).toReal"}, {"line": "rw [NNReal.coe_sum]", "tactic_state": "\u03b1 : Type u_2\ns : Finset \u03b1\nf : \u03b1 \u2192 ENNReal\nhf : \u2200 a \u2208 s, f a \u2260 \u22a4\n\u22a2 \u2211 i \u2208 s, \u2191(f i).toNNReal = \u2211 a \u2208 s, (f a).toReal"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_le_of_sum_le {s : Finset \u03b1} (hs : s.Nonempty) {f g : \u03b1 \u2192 \u211d\u22650\u221e}\n    (Hle : \u2211 i \u2208 s, f i \u2264 \u2211 i \u2208 s, g i) : \u2203 i \u2208 s, f i \u2264 g i := by\n  contrapose! Hle\n  apply ENNReal.sum_lt_sum_of_nonempty hs Hle\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/BigOperators.lean", "context": {"open": ["Set NNReal ENNReal", "Finset"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b1 : Type*}", "{\u03b1 : Type*} {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ns : Finset \u03b1\nhs : s.Nonempty\nf g : \u03b1 \u2192 ENNReal\nHle : \u2211 i \u2208 s, f i \u2264 \u2211 i \u2208 s, g i\n\u22a2 \u2203 i \u2208 s, f i \u2264 g i"}, {"line": "contrapose! Hle", "tactic_state": "\u03b1 : Type u_2\ns : Finset \u03b1\nhs : s.Nonempty\nf g : \u03b1 \u2192 ENNReal\nHle : \u2200 i \u2208 s, g i < f i\n\u22a2 \u2211 i \u2208 s, g i < \u2211 i \u2208 s, f i"}, {"line": "apply ENNReal.sum_lt_sum_of_nonempty hs Hle", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_inv_distrib {\u03b9 : Type*} {f : \u03b9 \u2192 \u211d\u22650\u221e} {s : Finset \u03b9}\n    (hf : s.toSet.Pairwise fun i j \u21a6 f i \u2260 0 \u2228 f j \u2260 \u221e) : (\u220f i \u2208 s, f i)\u207b\u00b9 = \u220f i \u2208 s, (f i)\u207b\u00b9 := by\n  induction' s using Finset.cons_induction with i s hi ih\n  \u00b7 simp\n  simp [\u2190 ih (hf.mono <| by simp)]\n  refine ENNReal.mul_inv (not_or_of_imp fun hi\u2080 \u21a6 prod_ne_top fun j hj \u21a6 ?_)\n    (not_or_of_imp fun hi\u2080 \u21a6 Finset.prod_ne_zero_iff.2 fun j hj \u21a6 ?_)\n  \u00b7 exact imp_iff_not_or.2 (hf (by simp) (by simp [hj]) <| .symm <| ne_of_mem_of_not_mem hj hi) hi\u2080\n  \u00b7 exact imp_iff_not_or.2 (hf (by simp [hj]) (by simp) <| ne_of_mem_of_not_mem hj hi).symm hi\u2080\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/BigOperators.lean", "context": {"open": ["Set NNReal ENNReal", "Finset"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b1 : Type*}", "{\u03b1 : Type*} {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_3\nf : \u03b9 \u2192 ENNReal\ns : Finset \u03b9\nhf : (\u2191s).Pairwise fun i j => f i \u2260 0 \u2228 f j \u2260 \u22a4\n\u22a2 (\u220f i \u2208 s, f i)\u207b\u00b9 = \u220f i \u2208 s, (f i)\u207b\u00b9"}, {"line": "induction' s using Finset.cons_induction with i s hi ih", "tactic_state": "case empty\n\u03b9 : Type u_3\nf : \u03b9 \u2192 ENNReal\nhf : (\u2191\u2205).Pairwise fun i j => f i \u2260 0 \u2228 f j \u2260 \u22a4\n\u22a2 (\u220f i \u2208 \u2205, f i)\u207b\u00b9 = \u220f i \u2208 \u2205, (f i)\u207b\u00b9\n---\ncase cons\n\u03b9 : Type u_3\nf : \u03b9 \u2192 ENNReal\ni : \u03b9\ns : Finset \u03b9\nhi : i \u2209 s\nih : ((\u2191s).Pairwise fun i j => f i \u2260 0 \u2228 f j \u2260 \u22a4) \u2192 (\u220f i \u2208 s, f i)\u207b\u00b9 = \u220f i \u2208 s, (f i)\u207b\u00b9\nhf : (\u2191(cons i s hi)).Pairwise fun i j => f i \u2260 0 \u2228 f j \u2260 \u22a4\n\u22a2 (\u220f i \u2208 cons i s hi, f i)\u207b\u00b9 = \u220f i \u2208 cons i s hi, (f i)\u207b\u00b9"}, {"line": "\u00b7 simp", "tactic_state": "case cons\n\u03b9 : Type u_3\nf : \u03b9 \u2192 ENNReal\ni : \u03b9\ns : Finset \u03b9\nhi : i \u2209 s\nih : ((\u2191s).Pairwise fun i j => f i \u2260 0 \u2228 f j \u2260 \u22a4) \u2192 (\u220f i \u2208 s, f i)\u207b\u00b9 = \u220f i \u2208 s, (f i)\u207b\u00b9\nhf : (\u2191(cons i s hi)).Pairwise fun i j => f i \u2260 0 \u2228 f j \u2260 \u22a4\n\u22a2 (\u220f i \u2208 cons i s hi, f i)\u207b\u00b9 = \u220f i \u2208 cons i s hi, (f i)\u207b\u00b9"}, {"line": "simp [\u2190 ih (hf.mono <| by simp)]", "tactic_state": "case cons\n\u03b9 : Type u_3\nf : \u03b9 \u2192 ENNReal\ni : \u03b9\ns : Finset \u03b9\nhi : i \u2209 s\nih : ((\u2191s).Pairwise fun i j => f i \u2260 0 \u2228 f j \u2260 \u22a4) \u2192 (\u220f i \u2208 s, f i)\u207b\u00b9 = \u220f i \u2208 s, (f i)\u207b\u00b9\nhf : (\u2191(cons i s hi)).Pairwise fun i j => f i \u2260 0 \u2228 f j \u2260 \u22a4\n\u22a2 (f i * \u220f i \u2208 s, f i)\u207b\u00b9 = (f i)\u207b\u00b9 * (\u220f i \u2208 s, f i)\u207b\u00b9"}, {"line": "refine ENNReal.mul_inv (not_or_of_imp fun hi\u2080 \u21a6 prod_ne_top fun j hj \u21a6 ?_)\n    (not_or_of_imp fun hi\u2080 \u21a6 Finset.prod_ne_zero_iff.2 fun j hj \u21a6 ?_)", "tactic_state": "case cons.refine_1\n\u03b9 : Type u_3\nf : \u03b9 \u2192 ENNReal\ni : \u03b9\ns : Finset \u03b9\nhi : i \u2209 s\nih : ((\u2191s).Pairwise fun i j => f i \u2260 0 \u2228 f j \u2260 \u22a4) \u2192 (\u220f i \u2208 s, f i)\u207b\u00b9 = \u220f i \u2208 s, (f i)\u207b\u00b9\nhf : (\u2191(cons i s hi)).Pairwise fun i j => f i \u2260 0 \u2228 f j \u2260 \u22a4\nhi\u2080 : f i = 0\nj : \u03b9\nhj : j \u2208 s\n\u22a2 f j \u2260 \u22a4\n---\ncase cons.refine_2\n\u03b9 : Type u_3\nf : \u03b9 \u2192 ENNReal\ni : \u03b9\ns : Finset \u03b9\nhi : i \u2209 s\nih : ((\u2191s).Pairwise fun i j => f i \u2260 0 \u2228 f j \u2260 \u22a4) \u2192 (\u220f i \u2208 s, f i)\u207b\u00b9 = \u220f i \u2208 s, (f i)\u207b\u00b9\nhf : (\u2191(cons i s hi)).Pairwise fun i j => f i \u2260 0 \u2228 f j \u2260 \u22a4\nhi\u2080 : f i = \u22a4\nj : \u03b9\nhj : j \u2208 s\n\u22a2 f j \u2260 0"}, {"line": "\u00b7 exact imp_iff_not_or.2 (hf (by simp) (by simp [hj]) <| .symm <| ne_of_mem_of_not_mem hj hi) hi\u2080", "tactic_state": "case cons.refine_2\n\u03b9 : Type u_3\nf : \u03b9 \u2192 ENNReal\ni : \u03b9\ns : Finset \u03b9\nhi : i \u2209 s\nih : ((\u2191s).Pairwise fun i j => f i \u2260 0 \u2228 f j \u2260 \u22a4) \u2192 (\u220f i \u2208 s, f i)\u207b\u00b9 = \u220f i \u2208 s, (f i)\u207b\u00b9\nhf : (\u2191(cons i s hi)).Pairwise fun i j => f i \u2260 0 \u2228 f j \u2260 \u22a4\nhi\u2080 : f i = \u22a4\nj : \u03b9\nhj : j \u2208 s\n\u22a2 f j \u2260 0"}, {"line": "\u00b7 exact imp_iff_not_or.2 (hf (by simp [hj]) (by simp) <| ne_of_mem_of_not_mem hj hi).symm hi\u2080", "tactic_state": "No Goals!"}]}
{"declaration": "lemma finsetSum_iSup {\u03b1 \u03b9 : Type*} {s : Finset \u03b1} {f : \u03b1 \u2192 \u03b9 \u2192 \u211d\u22650\u221e}\n    (hf : \u2200 i j, \u2203 k, \u2200 a, f a i \u2264 f a k \u2227 f a j \u2264 f a k) :\n    \u2211 a \u2208 s, \u2a06 i, f a i = \u2a06 i, \u2211 a \u2208 s, f a i := by\n  induction' s using Finset.cons_induction with a s ha ihs\n  \u00b7 simp\n  simp_rw [Finset.sum_cons, ihs]\n  refine iSup_add_iSup fun i j \u21a6 (hf i j).imp fun k hk \u21a6 ?_\n  gcongr\n  exacts [(hk a).1, (hk _).2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/BigOperators.lean", "context": {"open": ["Set NNReal ENNReal", "Finset"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b1 : Type*}", "{\u03b1 : Type*} {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b9 : Type u_4\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b9 \u2192 ENNReal\nhf : \u2200 (i j : \u03b9), \u2203 k, \u2200 (a : \u03b1), f a i \u2264 f a k \u2227 f a j \u2264 f a k\n\u22a2 \u2211 a \u2208 s, \u2a06 i, f a i = \u2a06 i, \u2211 a \u2208 s, f a i"}, {"line": "induction' s using Finset.cons_induction with a s ha ihs", "tactic_state": "case empty\n\u03b1 : Type u_3\n\u03b9 : Type u_4\nf : \u03b1 \u2192 \u03b9 \u2192 ENNReal\nhf : \u2200 (i j : \u03b9), \u2203 k, \u2200 (a : \u03b1), f a i \u2264 f a k \u2227 f a j \u2264 f a k\n\u22a2 \u2211 a \u2208 \u2205, \u2a06 i, f a i = \u2a06 i, \u2211 a \u2208 \u2205, f a i\n---\ncase cons\n\u03b1 : Type u_3\n\u03b9 : Type u_4\nf : \u03b1 \u2192 \u03b9 \u2192 ENNReal\nhf : \u2200 (i j : \u03b9), \u2203 k, \u2200 (a : \u03b1), f a i \u2264 f a k \u2227 f a j \u2264 f a k\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nihs : \u2211 a \u2208 s, \u2a06 i, f a i = \u2a06 i, \u2211 a \u2208 s, f a i\n\u22a2 \u2211 a \u2208 cons a s ha, \u2a06 i, f a i = \u2a06 i, \u2211 a \u2208 cons a s ha, f a i"}, {"line": "\u00b7 simp", "tactic_state": "case cons\n\u03b1 : Type u_3\n\u03b9 : Type u_4\nf : \u03b1 \u2192 \u03b9 \u2192 ENNReal\nhf : \u2200 (i j : \u03b9), \u2203 k, \u2200 (a : \u03b1), f a i \u2264 f a k \u2227 f a j \u2264 f a k\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nihs : \u2211 a \u2208 s, \u2a06 i, f a i = \u2a06 i, \u2211 a \u2208 s, f a i\n\u22a2 \u2211 a \u2208 cons a s ha, \u2a06 i, f a i = \u2a06 i, \u2211 a \u2208 cons a s ha, f a i"}, {"line": "simp_rw [Finset.sum_cons, ihs]", "tactic_state": "case cons\n\u03b1 : Type u_3\n\u03b9 : Type u_4\nf : \u03b1 \u2192 \u03b9 \u2192 ENNReal\nhf : \u2200 (i j : \u03b9), \u2203 k, \u2200 (a : \u03b1), f a i \u2264 f a k \u2227 f a j \u2264 f a k\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nihs : \u2211 a \u2208 s, \u2a06 i, f a i = \u2a06 i, \u2211 a \u2208 s, f a i\n\u22a2 (\u2a06 i, f a i) + \u2a06 i, \u2211 a \u2208 s, f a i = \u2a06 i, f a i + \u2211 a \u2208 s, f a i"}, {"line": "refine iSup_add_iSup fun i j \u21a6 (hf i j).imp fun k hk \u21a6 ?_", "tactic_state": "case cons\n\u03b1 : Type u_3\n\u03b9 : Type u_4\nf : \u03b1 \u2192 \u03b9 \u2192 ENNReal\nhf : \u2200 (i j : \u03b9), \u2203 k, \u2200 (a : \u03b1), f a i \u2264 f a k \u2227 f a j \u2264 f a k\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nihs : \u2211 a \u2208 s, \u2a06 i, f a i = \u2a06 i, \u2211 a \u2208 s, f a i\ni j k : \u03b9\nhk : \u2200 (a : \u03b1), f a i \u2264 f a k \u2227 f a j \u2264 f a k\n\u22a2 f a i + \u2211 a \u2208 s, f a j \u2264 f a k + \u2211 a \u2208 s, f a k"}, {"line": "gcongr", "tactic_state": "case cons.h\u2081\n\u03b1 : Type u_3\n\u03b9 : Type u_4\nf : \u03b1 \u2192 \u03b9 \u2192 ENNReal\nhf : \u2200 (i j : \u03b9), \u2203 k, \u2200 (a : \u03b1), f a i \u2264 f a k \u2227 f a j \u2264 f a k\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nihs : \u2211 a \u2208 s, \u2a06 i, f a i = \u2a06 i, \u2211 a \u2208 s, f a i\ni j k : \u03b9\nhk : \u2200 (a : \u03b1), f a i \u2264 f a k \u2227 f a j \u2264 f a k\n\u22a2 f a i \u2264 f a k\n---\ncase cons.h\u2082.h\n\u03b1 : Type u_3\n\u03b9 : Type u_4\nf : \u03b1 \u2192 \u03b9 \u2192 ENNReal\nhf : \u2200 (i j : \u03b9), \u2203 k, \u2200 (a : \u03b1), f a i \u2264 f a k \u2227 f a j \u2264 f a k\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nihs : \u2211 a \u2208 s, \u2a06 i, f a i = \u2a06 i, \u2211 a \u2208 s, f a i\ni j k : \u03b9\nhk : \u2200 (a : \u03b1), f a i \u2264 f a k \u2227 f a j \u2264 f a k\ni\u271d : \u03b1\na\u271d : i\u271d \u2208 s\n\u22a2 f i\u271d j \u2264 f i\u271d k"}, {"line": "exacts [(hk a).1, (hk _).2]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le : r \u2264 p := by\n  simp [\u2190 ENNReal.inv_le_inv, \u2190 @inv_inv_add_inv p q r, inv_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Holder.lean", "context": {"open": [], "variables": ["(p q r : \u211d\u22650\u221e) [HolderTriple p q r]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry"}, {"line": "simp [\u2190 ENNReal.inv_le_inv, \u2190 @inv_inv_add_inv p q r, inv_inv]", "tactic_state": "\u22a2 sorry ()"}]}
{"declaration": "theorem coe_mem_upperBounds {s : Set \u211d\u22650} :\n    \u2191r \u2208 upperBounds (ofNNReal '' s) \u2194 r \u2208 upperBounds s := by\n  simp +contextual [upperBounds, forall_mem_image, -mem_image, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Basic.lean", "context": {"open": ["Function Set NNReal"], "variables": ["{\u03b1 : Type*}", "{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "ofNNReal : NNReal \u2192 NNReal\nr : NNReal\ns : Set NNReal\n\u22a2 r \u2208 upperBounds (ofNNReal '' s) \u2194 r \u2208 upperBounds s"}, {"line": "simp +contextual [upperBounds, forall_mem_image, -mem_image, *]", "tactic_state": "ofNNReal : NNReal \u2192 NNReal\nr : NNReal\ns : Set NNReal\n\u22a2 (\u2200 \u2983x : NNReal\u2984, x \u2208 s \u2192 ofNNReal x \u2264 r) \u2194 \u2200 \u2983a : NNReal\u2984, a \u2208 s \u2192 a \u2264 r"}]}
{"declaration": "theorem image_coe_nnreal_ennreal (h : t.OrdConnected) : ((\u2191) '' t : Set \u211d\u22650\u221e).OrdConnected := by\n  refine \u27e8forall_mem_image.2 fun x hx => forall_mem_image.2 fun y hy z hz => ?_\u27e9\n  rcases ENNReal.le_coe_iff.1 hz.2 with \u27e8z, rfl, -\u27e9\n  exact mem_image_of_mem _ (h.out hx hy \u27e8ENNReal.coe_le_coe.1 hz.1, ENNReal.coe_le_coe.1 hz.2\u27e9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Basic.lean", "context": {"open": ["Function Set NNReal", "ENNReal"], "variables": ["{\u03b1 : Type*}", "{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d\u22650}", "{s : Set \u211d} {t : Set \u211d\u22650} {u : Set \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "t : Set NNReal\nh : t.OrdConnected\n\u22a2 (ofNNReal '' t).OrdConnected"}, {"line": "refine \u27e8forall_mem_image.2 fun x hx => forall_mem_image.2 fun y hy z hz => ?_\u27e9", "tactic_state": "t : Set NNReal\nh : t.OrdConnected\nx : NNReal\nhx : x \u2208 t\ny : NNReal\nhy : y \u2208 t\nz : ENNReal\nhz : z \u2208 Icc \u2191x \u2191y\n\u22a2 z \u2208 ofNNReal '' t"}, {"line": "rcases ENNReal.le_coe_iff.1 hz.2 with \u27e8z, rfl, -\u27e9", "tactic_state": "case intro.intro\nt : Set NNReal\nh : t.OrdConnected\nx : NNReal\nhx : x \u2208 t\ny : NNReal\nhy : y \u2208 t\nz : NNReal\nhz : \u2191z \u2208 Icc \u2191x \u2191y\n\u22a2 \u2191z \u2208 ofNNReal '' t"}, {"line": "exact mem_image_of_mem _ (h.out hx hy \u27e8ENNReal.coe_le_coe.1 hz.1, ENNReal.coe_le_coe.1 hz.2\u27e9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_ennreal_ofReal (h : s.OrdConnected) : (ENNReal.ofReal '' s).OrdConnected := by\n  simpa only [image_image] using h.image_real_toNNReal.image_coe_nnreal_ennreal\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Basic.lean", "context": {"open": ["Function Set NNReal", "ENNReal"], "variables": ["{\u03b1 : Type*}", "{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d\u22650}", "{s : Set \u211d} {t : Set \u211d\u22650} {u : Set \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set \u211d\nh : s.OrdConnected\n\u22a2 (ENNReal.ofReal '' s).OrdConnected"}, {"line": "simpa only [image_image] using h.image_real_toNNReal.image_coe_nnreal_ennreal", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_le_of_le_div (h : a \u2264 b / c) : a * c \u2264 b := by\n  rw [\u2190 inv_inv c]\n  exact div_le_of_le_mul h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Inv.lean", "context": {"open": ["Set NNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : NNReal\nh : a \u2264 b / c\n\u22a2 a * c \u2264 b"}, {"line": "rw [\u2190 inv_inv c]", "tactic_state": "a b c : NNReal\nh : a \u2264 b / c\n\u22a2 a * c\u207b\u00b9\u207b\u00b9 \u2264 b"}, {"line": "exact div_le_of_le_mul h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_lt_zero : \u00aca < 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Operations.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : ENNReal\n\u22a2 \u00aca < 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_add_right (ha : a \u2260 \u221e) (hb : b \u2260 0) : a < a + b := by\n  rwa [\u2190 pos_iff_ne_zero, \u2190 ENNReal.add_lt_add_iff_left ha, add_zero] at hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Operations.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : ENNReal\nha : a \u2260 \u22a4\nhb : b \u2260 0\n\u22a2 a < a + b"}, {"line": "rwa [\u2190 pos_iff_ne_zero, \u2190 ENNReal.add_lt_add_iff_left ha, add_zero] at hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toReal_le_add' (hle : a \u2264 b + c) (hb : b = \u221e \u2192 a = \u221e) (hc : c = \u221e \u2192 a = \u221e) :\n    a.toReal \u2264 b.toReal + c.toReal := by\n  refine le_trans (toReal_mono' hle ?_) toReal_add_le\n  simpa only [add_eq_top,or_imp] using And.intro hb hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Operations.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b1 : Type*} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : ENNReal\nhle : a \u2264 b + c\nhb : b = \u22a4 \u2192 a = \u22a4\nhc : c = \u22a4 \u2192 a = \u22a4\n\u22a2 a.toReal \u2264 b.toReal + c.toReal"}, {"line": "refine le_trans (toReal_mono' hle ?_) toReal_add_le", "tactic_state": "a b c : ENNReal\nhle : a \u2264 b + c\nhb : b = \u22a4 \u2192 a = \u22a4\nhc : c = \u22a4 \u2192 a = \u22a4\n\u22a2 b + c = \u22a4 \u2192 a = \u22a4"}, {"line": "simpa only [add_eq_top,or_imp] using And.intro hb hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_lt_top {x : \u211d\u22650\u221e} : \u00acx < \u221e \u2194 x = \u221e := by rw [lt_top_iff_ne_top, Classical.not_not]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Operations.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b1 : Type*} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ENNReal\n\u22a2 \u00acx < \u22a4 \u2194 x = \u22a4"}, {"line": "rw [lt_top_iff_ne_top, Classical.not_not]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_ne_top : a + b \u2260 \u221e \u2194 a \u2260 \u221e \u2227 b \u2260 \u221e := by simpa only [lt_top_iff_ne_top] using add_lt_top\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Operations.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b1 : Type*} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : ENNReal\n\u22a2 a + b \u2260 \u22a4 \u2194 a \u2260 \u22a4 \u2227 b \u2260 \u22a4"}, {"line": "simpa only [lt_top_iff_ne_top] using add_lt_top", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_top' : a * \u221e = if a = 0 then 0 else \u221e := by convert WithTop.mul_top' a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Operations.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b1 : Type*} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : ENNReal\n\u22a2 a * \u22a4 = if a = 0 then 0 else \u22a4"}, {"line": "convert WithTop.mul_top' a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem top_mul' : \u221e * a = if a = 0 then 0 else \u221e := by convert WithTop.top_mul' a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Operations.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b1 : Type*} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : ENNReal\n\u22a2 \u22a4 * a = if a = 0 then 0 else \u22a4"}, {"line": "convert WithTop.top_mul' a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_lt_top_iff {a b : \u211d\u22650\u221e} : a * b < \u221e \u2194 a < \u221e \u2227 b < \u221e \u2228 a = 0 \u2228 b = 0 := by\n  constructor\n  \u00b7 intro h\n    rw [\u2190 or_assoc]\n    rw [or_iff_not_imp_right]\n    rw [or_iff_not_imp_right]\n    intro hb ha\n    exact \u27e8lt_top_of_mul_ne_top_left h.ne hb, lt_top_of_mul_ne_top_right h.ne ha\u27e9\n  \u00b7 rintro (\u27e8ha, hb\u27e9 | rfl | rfl) <;> [exact mul_lt_top ha hb; simp; simp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Operations.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b1 : Type*} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : ENNReal\n\u22a2 a * b < \u22a4 \u2194 a < \u22a4 \u2227 b < \u22a4 \u2228 a = 0 \u2228 b = 0"}, {"line": "constructor", "tactic_state": "case mp\na b : ENNReal\n\u22a2 a * b < \u22a4 \u2192 a < \u22a4 \u2227 b < \u22a4 \u2228 a = 0 \u2228 b = 0\n---\ncase mpr\na b : ENNReal\n\u22a2 a < \u22a4 \u2227 b < \u22a4 \u2228 a = 0 \u2228 b = 0 \u2192 a * b < \u22a4"}, {"line": "\u00b7 intro h\n    rw [\u2190 or_assoc]\n    rw [or_iff_not_imp_right]\n    rw [or_iff_not_imp_right]\n    intro hb ha\n    exact \u27e8lt_top_of_mul_ne_top_left h.ne hb, lt_top_of_mul_ne_top_right h.ne ha\u27e9", "tactic_state": "case mpr\na b : ENNReal\n\u22a2 a < \u22a4 \u2227 b < \u22a4 \u2228 a = 0 \u2228 b = 0 \u2192 a * b < \u22a4"}, {"line": "\u00b7 rintro (\u27e8ha, hb\u27e9 | rfl | rfl) <;> [exact mul_lt_top ha hb; simp; simp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_self_lt_top_iff {a : \u211d\u22650\u221e} : a * a < \u22a4 \u2194 a < \u22a4 := by\n  rw [ENNReal.mul_lt_top_iff]\n  rw [and_self]\n  rw [or_self]\n  rw [or_iff_left_iff_imp]\n  rintro rfl\n  exact zero_lt_top\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Operations.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b1 : Type*} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : ENNReal\n\u22a2 a * a < \u22a4 \u2194 a < \u22a4"}, {"line": "rw [ENNReal.mul_lt_top_iff]", "tactic_state": "a : ENNReal\n\u22a2 a < \u22a4 \u2227 a < \u22a4 \u2228 a = 0 \u2228 a = 0 \u2194 a < \u22a4"}, {"line": "rw [and_self]", "tactic_state": "a : ENNReal\n\u22a2 a < \u22a4 \u2228 a = 0 \u2228 a = 0 \u2194 a < \u22a4"}, {"line": "rw [or_self]", "tactic_state": "a : ENNReal\n\u22a2 a < \u22a4 \u2228 a = 0 \u2194 a < \u22a4"}, {"line": "rw [or_iff_left_iff_imp]", "tactic_state": "a : ENNReal\n\u22a2 a = 0 \u2192 a < \u22a4"}, {"line": "rintro rfl", "tactic_state": "\u22a2 0 < \u22a4"}, {"line": "exact zero_lt_top", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toReal_sub_of_le (hba : b \u2264 a) (ha : a \u2260 \u221e) : (a - b).toReal = a.toReal - b.toReal := by\n  simp [ENNReal.toReal, ne_top_of_le_ne_top ha hba, toNNReal_mono ha hba]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Operations.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b1 : Type*} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : ENNReal\nhba : b \u2264 a\nha : a \u2260 \u22a4\n\u22a2 (a - b).toReal = a.toReal - b.toReal"}, {"line": "simp [ENNReal.toReal, ne_top_of_le_ne_top ha hba, toNNReal_mono ha hba]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofReal_sub (p : \u211d) {q : \u211d} (hq : 0 \u2264 q) :\n    ENNReal.ofReal (p - q) = ENNReal.ofReal p - ENNReal.ofReal q := by\n  obtain h | h := le_total p q\n  \u00b7 rw [ofReal_of_nonpos (sub_nonpos_of_le h), tsub_eq_zero_of_le (ofReal_le_ofReal h)]\n  refine ENNReal.eq_sub_of_add_eq ofReal_ne_top ?_\n  rw [\u2190 ofReal_add (sub_nonneg_of_le h) hq]\n  rw [sub_add_cancel]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Operations.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b1 : Type*} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u211d\nhq : 0 \u2264 q\n\u22a2 ENNReal.ofReal (p - q) = ENNReal.ofReal p - ENNReal.ofReal q"}, {"line": "obtain h | h := le_total p q", "tactic_state": "case inl\np q : \u211d\nhq : 0 \u2264 q\nh : p \u2264 q\n\u22a2 ENNReal.ofReal (p - q) = ENNReal.ofReal p - ENNReal.ofReal q\n---\ncase inr\np q : \u211d\nhq : 0 \u2264 q\nh : q \u2264 p\n\u22a2 ENNReal.ofReal (p - q) = ENNReal.ofReal p - ENNReal.ofReal q"}, {"line": "\u00b7 rw [ofReal_of_nonpos (sub_nonpos_of_le h), tsub_eq_zero_of_le (ofReal_le_ofReal h)]", "tactic_state": "case inr\np q : \u211d\nhq : 0 \u2264 q\nh : q \u2264 p\n\u22a2 ENNReal.ofReal (p - q) = ENNReal.ofReal p - ENNReal.ofReal q"}, {"line": "refine ENNReal.eq_sub_of_add_eq ofReal_ne_top ?_", "tactic_state": "case inr\np q : \u211d\nhq : 0 \u2264 q\nh : q \u2264 p\n\u22a2 ENNReal.ofReal (p - q) + ENNReal.ofReal q = ENNReal.ofReal p"}, {"line": "rw [\u2190 ofReal_add (sub_nonneg_of_le h) hq]", "tactic_state": "case inr\np q : \u211d\nhq : 0 \u2264 q\nh : q \u2264 p\n\u22a2 ENNReal.ofReal (p - q + q) = ENNReal.ofReal p"}, {"line": "rw [sub_add_cancel]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_coe_uIcc (x y : \u211d\u22650) : (\u2191) '' uIcc x y = uIcc (x : \u211d\u22650\u221e) y := by simp [uIcc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Operations.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b1 : Type*} {n : \u2115}", "{x y z : \u211d\u22650\u221e} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s : Set \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : NNReal\n\u22a2 ofNNReal '' uIcc x y = uIcc \u2191x \u2191y"}, {"line": "simp [uIcc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_coe_uIoc (x y : \u211d\u22650) : (\u2191) '' uIoc x y = uIoc (x : \u211d\u22650\u221e) y := by simp [uIoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Operations.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b1 : Type*} {n : \u2115}", "{x y z : \u211d\u22650\u221e} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s : Set \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : NNReal\n\u22a2 ofNNReal '' uIoc x y = uIoc \u2191x \u2191y"}, {"line": "simp [uIoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_coe_uIoo (x y : \u211d\u22650) : (\u2191) '' uIoo x y = uIoo (x : \u211d\u22650\u221e) y := by simp [uIoo]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Operations.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b1 : Type*} {n : \u2115}", "{x y z : \u211d\u22650\u221e} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s : Set \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : NNReal\n\u22a2 ofNNReal '' uIoo x y = uIoo \u2191x \u2191y"}, {"line": "simp [uIoo]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNReal_strict_mono (hb : b \u2260 \u221e) (h : a < b) : a.toNNReal < b.toNNReal := by\n  simpa [\u2190 ENNReal.coe_lt_coe, hb, h.ne_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : ENNReal\nhb : b \u2260 \u22a4\nh : a < b\n\u22a2 a.toNNReal < b.toNNReal"}, {"line": "simpa [\u2190 ENNReal.coe_lt_coe, hb, h.ne_top]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNReal_pos_iff : 0 < a.toNNReal \u2194 0 < a \u2227 a < \u221e := by\n  induction a <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : ENNReal\n\u22a2 0 < a.toNNReal \u2194 0 < a \u2227 a < \u22a4"}, {"line": "induction a <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofReal_le_ofReal {p q : \u211d} (h : p \u2264 q) : ENNReal.ofReal p \u2264 ENNReal.ofReal q := by\n  simp [ENNReal.ofReal, Real.toNNReal_le_toNNReal h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u211d\nh : p \u2264 q\n\u22a2 ENNReal.ofReal p \u2264 ENNReal.ofReal q"}, {"line": "simp [ENNReal.ofReal, Real.toNNReal_le_toNNReal h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofReal_pos {p : \u211d} : 0 < ENNReal.ofReal p \u2194 0 < p := by simp [ENNReal.ofReal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\n\u22a2 0 < ENNReal.ofReal p \u2194 0 < p"}, {"line": "simp [ENNReal.ofReal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofReal_eq_zero {p : \u211d} : ENNReal.ofReal p = 0 \u2194 p \u2264 0 := by simp [ENNReal.ofReal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\n\u22a2 ENNReal.ofReal p = 0 \u2194 p \u2264 0"}, {"line": "simp [ENNReal.ofReal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofReal_ne_zero_iff {r : \u211d} : ENNReal.ofReal r \u2260 0 \u2194 0 < r := by\n  rw [\u2190 zero_lt_iff]\n  rw [ENNReal.ofReal_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\n\u22a2 ENNReal.ofReal r \u2260 0 \u2194 0 < r"}, {"line": "rw [\u2190 zero_lt_iff]", "tactic_state": "r : \u211d\n\u22a2 0 < ENNReal.ofReal r \u2194 0 < r"}, {"line": "rw [ENNReal.ofReal_pos]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ofReal_lt_natCast {p : \u211d} {n : \u2115} (hn : n \u2260 0) : ENNReal.ofReal p < n \u2194 p < n := by\n  exact mod_cast ofReal_lt_ofReal_iff (Nat.cast_pos.2 hn.bot_lt)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\nn : \u2115\nhn : n \u2260 0\n\u22a2 ENNReal.ofReal p < \u2191n \u2194 p < \u2191n"}, {"line": "exact mod_cast ofReal_lt_ofReal_iff (Nat.cast_pos.2 hn.bot_lt)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ofReal_lt_one {p : \u211d} : ENNReal.ofReal p < 1 \u2194 p < 1 := by\n  exact mod_cast ofReal_lt_natCast one_ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\n\u22a2 ENNReal.ofReal p < 1 \u2194 p < 1"}, {"line": "exact mod_cast ofReal_lt_natCast one_ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "lemma natCast_le_ofReal {n : \u2115} {p : \u211d} (hn : n \u2260 0) : n \u2264 ENNReal.ofReal p \u2194 n \u2264 p := by\n  simp only [\u2190 not_lt]\n  simp only [ofReal_lt_natCast hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np : \u211d\nhn : n \u2260 0\n\u22a2 \u2191n \u2264 ENNReal.ofReal p \u2194 \u2191n \u2264 p"}, {"line": "simp only [\u2190 not_lt]", "tactic_state": "n : \u2115\np : \u211d\nhn : n \u2260 0\n\u22a2 \u00acENNReal.ofReal p < \u2191n \u2194 \u00acp < \u2191n"}, {"line": "simp only [ofReal_lt_natCast hn]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_le_ofReal {p : \u211d} : 1 \u2264 ENNReal.ofReal p \u2194 1 \u2264 p := by\n  exact mod_cast natCast_le_ofReal one_ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\n\u22a2 1 \u2264 ENNReal.ofReal p \u2194 1 \u2264 p"}, {"line": "exact mod_cast natCast_le_ofReal one_ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofReal_mul {p q : \u211d} (hp : 0 \u2264 p) :\n    ENNReal.ofReal (p * q) = ENNReal.ofReal p * ENNReal.ofReal q := by\n  simp only [ENNReal.ofReal]\n  simp only [\u2190 coe_mul]\n  simp only [Real.toNNReal_mul hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u211d\nhp : 0 \u2264 p\n\u22a2 ENNReal.ofReal (p * q) = ENNReal.ofReal p * ENNReal.ofReal q"}, {"line": "simp only [ENNReal.ofReal]", "tactic_state": "p q : \u211d\nhp : 0 \u2264 p\n\u22a2 \u2191(p * q).toNNReal = \u2191p.toNNReal * \u2191q.toNNReal"}, {"line": "simp only [\u2190 coe_mul]", "tactic_state": "p q : \u211d\nhp : 0 \u2264 p\n\u22a2 \u2191(p * q).toNNReal = \u2191(p.toNNReal * q.toNNReal)"}, {"line": "simp only [Real.toNNReal_mul hp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofReal_mul' {p q : \u211d} (hq : 0 \u2264 q) :\n    ENNReal.ofReal (p * q) = ENNReal.ofReal p * ENNReal.ofReal q := by\n  rw [mul_comm]\n  rw [ofReal_mul hq]\n  rw [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u211d\nhq : 0 \u2264 q\n\u22a2 ENNReal.ofReal (p * q) = ENNReal.ofReal p * ENNReal.ofReal q"}, {"line": "rw [mul_comm]", "tactic_state": "p q : \u211d\nhq : 0 \u2264 q\n\u22a2 ENNReal.ofReal (q * p) = ENNReal.ofReal p * ENNReal.ofReal q"}, {"line": "rw [ofReal_mul hq]", "tactic_state": "p q : \u211d\nhq : 0 \u2264 q\n\u22a2 ENNReal.ofReal q * ENNReal.ofReal p = ENNReal.ofReal p * ENNReal.ofReal q"}, {"line": "rw [mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofReal_nsmul {x : \u211d} {n : \u2115} : ENNReal.ofReal (n \u2022 x) = n \u2022 ENNReal.ofReal x := by\n  simp only [nsmul_eq_mul]\n  simp only [\u2190 ofReal_natCast n]\n  simp only [\u2190 ofReal_mul n.cast_nonneg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nn : \u2115\n\u22a2 ENNReal.ofReal (n \u2022 x) = n \u2022 ENNReal.ofReal x"}, {"line": "simp only [nsmul_eq_mul]", "tactic_state": "x : \u211d\nn : \u2115\n\u22a2 ENNReal.ofReal (\u2191n * x) = \u2191n * ENNReal.ofReal x"}, {"line": "simp only [\u2190 ofReal_natCast n]", "tactic_state": "x : \u211d\nn : \u2115\n\u22a2 ENNReal.ofReal (\u2191n * x) = ENNReal.ofReal \u2191n * ENNReal.ofReal x"}, {"line": "simp only [\u2190 ofReal_mul n.cast_nonneg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNReal_mul_top (a : \u211d\u22650\u221e) : ENNReal.toNNReal (a * \u221e) = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : ENNReal\n\u22a2 (a * \u22a4).toNNReal = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNReal_top_mul (a : \u211d\u22650\u221e) : ENNReal.toNNReal (\u221e * a) = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : ENNReal\n\u22a2 (\u22a4 * a).toNNReal = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toReal_nsmul (a : \u211d\u22650\u221e) (n : \u2115) : (n \u2022 a).toReal = n \u2022 a.toReal := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : ENNReal\nn : \u2115\n\u22a2 (n \u2022 a).toReal = n \u2022 a.toReal"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toReal_ofReal_mul (c : \u211d) (a : \u211d\u22650\u221e) (h : 0 \u2264 c) :\n    ENNReal.toReal (ENNReal.ofReal c * a) = c * ENNReal.toReal a := by\n  rw [ENNReal.toReal_mul]\n  rw [ENNReal.toReal_ofReal h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u211d\na : ENNReal\nh : 0 \u2264 c\n\u22a2 (ENNReal.ofReal c * a).toReal = c * a.toReal"}, {"line": "rw [ENNReal.toReal_mul]", "tactic_state": "c : \u211d\na : ENNReal\nh : 0 \u2264 c\n\u22a2 (ENNReal.ofReal c).toReal * a.toReal = c * a.toReal"}, {"line": "rw [ENNReal.toReal_ofReal h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toReal_mul_top (a : \u211d\u22650\u221e) : ENNReal.toReal (a * \u221e) = 0 := by\n  rw [toReal_mul]\n  rw [toReal_top]\n  rw [mul_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : ENNReal\n\u22a2 (a * \u22a4).toReal = 0"}, {"line": "rw [toReal_mul]", "tactic_state": "a : ENNReal\n\u22a2 a.toReal * \u22a4.toReal = 0"}, {"line": "rw [toReal_top]", "tactic_state": "a : ENNReal\n\u22a2 a.toReal * 0 = 0"}, {"line": "rw [mul_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toReal_top_mul (a : \u211d\u22650\u221e) : ENNReal.toReal (\u221e * a) = 0 := by\n  rw [mul_comm]\n  exact toReal_mul_top _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : ENNReal\n\u22a2 (\u22a4 * a).toReal = 0"}, {"line": "rw [mul_comm]", "tactic_state": "a : ENNReal\n\u22a2 (a * \u22a4).toReal = 0"}, {"line": "exact toReal_mul_top _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNReal_iInf (hf : \u2200 i, f i \u2260 \u221e) : (iInf f).toNNReal = \u2a05 i, (f i).toNNReal := by\n  cases isEmpty_or_nonempty \u03b9\n  \u00b7 rw [iInf_of_empty, toNNReal_top, NNReal.iInf_empty]\n  \u00b7 lift f to \u03b9 \u2192 \u211d\u22650 using hf\n    simp_rw [\u2190 coe_iInf, toNNReal_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b9 : Sort*} {f g : \u03b9 \u2192 \u211d\u22650\u221e}", "{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 ENNReal\nhf : \u2200 (i : \u03b9), f i \u2260 \u22a4\n\u22a2 (iInf f).toNNReal = \u2a05 i, (f i).toNNReal"}, {"line": "cases isEmpty_or_nonempty \u03b9", "tactic_state": "case inl\n\u03b9 : Sort u_1\nf : \u03b9 \u2192 ENNReal\nhf : \u2200 (i : \u03b9), f i \u2260 \u22a4\nh\u271d : IsEmpty \u03b9\n\u22a2 (iInf f).toNNReal = \u2a05 i, (f i).toNNReal\n---\ncase inr\n\u03b9 : Sort u_1\nf : \u03b9 \u2192 ENNReal\nhf : \u2200 (i : \u03b9), f i \u2260 \u22a4\nh\u271d : Nonempty \u03b9\n\u22a2 (iInf f).toNNReal = \u2a05 i, (f i).toNNReal"}, {"line": "\u00b7 rw [iInf_of_empty, toNNReal_top, NNReal.iInf_empty]", "tactic_state": "case inr\n\u03b9 : Sort u_1\nf : \u03b9 \u2192 ENNReal\nhf : \u2200 (i : \u03b9), f i \u2260 \u22a4\nh\u271d : Nonempty \u03b9\n\u22a2 (iInf f).toNNReal = \u2a05 i, (f i).toNNReal"}, {"line": "\u00b7 lift f to \u03b9 \u2192 \u211d\u22650 using hf\n    simp_rw [\u2190 coe_iInf, toNNReal_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toReal_iInf (hf : \u2200 i, f i \u2260 \u221e) : (iInf f).toReal = \u2a05 i, (f i).toReal := by\n  simp only [ENNReal.toReal]\n  simp only [toNNReal_iInf hf]\n  simp only [NNReal.coe_iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b9 : Sort*} {f g : \u03b9 \u2192 \u211d\u22650\u221e}", "{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 ENNReal\nhf : \u2200 (i : \u03b9), f i \u2260 \u22a4\n\u22a2 (iInf f).toReal = \u2a05 i, (f i).toReal"}, {"line": "simp only [ENNReal.toReal]", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 ENNReal\nhf : \u2200 (i : \u03b9), f i \u2260 \u22a4\n\u22a2 \u2191(iInf f).toNNReal = \u2a05 i, \u2191(f i).toNNReal"}, {"line": "simp only [toNNReal_iInf hf]", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 ENNReal\nhf : \u2200 (i : \u03b9), f i \u2260 \u22a4\n\u22a2 \u2191(\u2a05 i, (f i).toNNReal) = \u2a05 i, \u2191(f i).toNNReal"}, {"line": "simp only [NNReal.coe_iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toReal_sInf (s : Set \u211d\u22650\u221e) (hf : \u2200 r \u2208 s, r \u2260 \u221e) :\n    (sInf s).toReal = sInf (ENNReal.toReal '' s) := by\n  simp only [ENNReal.toReal]\n  simp only [toNNReal_sInf s hf]\n  simp only [NNReal.coe_sInf]\n  simp only [Set.image_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b9 : Sort*} {f g : \u03b9 \u2192 \u211d\u22650\u221e}", "{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set ENNReal\nhf : \u2200 r \u2208 s, r \u2260 \u22a4\n\u22a2 (sInf s).toReal = sInf (ENNReal.toReal '' s)"}, {"line": "simp only [ENNReal.toReal]", "tactic_state": "s : Set ENNReal\nhf : \u2200 r \u2208 s, r \u2260 \u22a4\n\u22a2 \u2191(sInf s).toNNReal = sInf ((fun a => \u2191a.toNNReal) '' s)"}, {"line": "simp only [toNNReal_sInf s hf]", "tactic_state": "s : Set ENNReal\nhf : \u2200 r \u2208 s, r \u2260 \u22a4\n\u22a2 \u2191(sInf (ENNReal.toNNReal '' s)) = sInf ((fun a => \u2191a.toNNReal) '' s)"}, {"line": "simp only [NNReal.coe_sInf]", "tactic_state": "s : Set ENNReal\nhf : \u2200 r \u2208 s, r \u2260 \u22a4\n\u22a2 sInf (toReal '' (ENNReal.toNNReal '' s)) = sInf ((fun a => \u2191a.toNNReal) '' s)"}, {"line": "simp only [Set.image_image]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toReal_iSup (hf : \u2200 i, f i \u2260 \u221e) : (iSup f).toReal = \u2a06 i, (f i).toReal := by\n  simp only [ENNReal.toReal]\n  simp only [toNNReal_iSup hf]\n  simp only [NNReal.coe_iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b9 : Sort*} {f g : \u03b9 \u2192 \u211d\u22650\u221e}", "{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 ENNReal\nhf : \u2200 (i : \u03b9), f i \u2260 \u22a4\n\u22a2 (iSup f).toReal = \u2a06 i, (f i).toReal"}, {"line": "simp only [ENNReal.toReal]", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 ENNReal\nhf : \u2200 (i : \u03b9), f i \u2260 \u22a4\n\u22a2 \u2191(iSup f).toNNReal = \u2a06 i, \u2191(f i).toNNReal"}, {"line": "simp only [toNNReal_iSup hf]", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 ENNReal\nhf : \u2200 (i : \u03b9), f i \u2260 \u22a4\n\u22a2 \u2191(\u2a06 i, (f i).toNNReal) = \u2a06 i, \u2191(f i).toNNReal"}, {"line": "simp only [NNReal.coe_iSup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toReal_sSup (s : Set \u211d\u22650\u221e) (hf : \u2200 r \u2208 s, r \u2260 \u221e) :\n    (sSup s).toReal = sSup (ENNReal.toReal '' s) := by\n  simp only [ENNReal.toReal]\n  simp only [toNNReal_sSup s hf]\n  simp only [NNReal.coe_sSup]\n  simp only [Set.image_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b9 : Sort*} {f g : \u03b9 \u2192 \u211d\u22650\u221e}", "{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set ENNReal\nhf : \u2200 r \u2208 s, r \u2260 \u22a4\n\u22a2 (sSup s).toReal = sSup (ENNReal.toReal '' s)"}, {"line": "simp only [ENNReal.toReal]", "tactic_state": "s : Set ENNReal\nhf : \u2200 r \u2208 s, r \u2260 \u22a4\n\u22a2 \u2191(sSup s).toNNReal = sSup ((fun a => \u2191a.toNNReal) '' s)"}, {"line": "simp only [toNNReal_sSup s hf]", "tactic_state": "s : Set ENNReal\nhf : \u2200 r \u2208 s, r \u2260 \u22a4\n\u22a2 \u2191(sSup (ENNReal.toNNReal '' s)) = sSup ((fun a => \u2191a.toNNReal) '' s)"}, {"line": "simp only [NNReal.coe_sSup]", "tactic_state": "s : Set ENNReal\nhf : \u2200 r \u2208 s, r \u2260 \u22a4\n\u22a2 sSup (toReal '' (ENNReal.toNNReal '' s)) = sSup ((fun a => \u2191a.toNNReal) '' s)"}, {"line": "simp only [Set.image_image]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_iInf : (a - \u2a05 i, f i) = \u2a06 i, a - f i := by\n  refine eq_of_forall_ge_iff fun c => ?_\n  rw [tsub_le_iff_right]\n  rw [add_comm]\n  rw [iInf_add]\n  simp [tsub_le_iff_right, sub_eq_add_neg, add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b9 : Sort*} {f g : \u03b9 \u2192 \u211d\u22650\u221e}", "{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 ENNReal\na : ENNReal\n\u22a2 a - \u2a05 i, f i = \u2a06 i, a - f i"}, {"line": "refine eq_of_forall_ge_iff fun c => ?_", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 ENNReal\na c : ENNReal\n\u22a2 a - \u2a05 i, f i \u2264 c \u2194 \u2a06 i, a - f i \u2264 c"}, {"line": "rw [tsub_le_iff_right]", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 ENNReal\na c : ENNReal\n\u22a2 a \u2264 c + \u2a05 i, f i \u2194 \u2a06 i, a - f i \u2264 c"}, {"line": "rw [add_comm]", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 ENNReal\na c : ENNReal\n\u22a2 a \u2264 (\u2a05 i, f i) + c \u2194 \u2a06 i, a - f i \u2264 c"}, {"line": "rw [iInf_add]", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 ENNReal\na c : ENNReal\n\u22a2 a \u2264 \u2a05 i, f i + c \u2194 \u2a06 i, a - f i \u2264 c"}, {"line": "simp [tsub_le_iff_right, sub_eq_add_neg, add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInf_add {s : Set \u211d\u22650\u221e} : sInf s + a = \u2a05 b \u2208 s, b + a := by simp [sInf_eq_iInf, iInf_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b9 : Sort*} {f g : \u03b9 \u2192 \u211d\u22650\u221e}", "{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : ENNReal\ns : Set ENNReal\n\u22a2 sInf s + a = \u2a05 b \u2208 s, b + a"}, {"line": "simp [sInf_eq_iInf, iInf_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iInf_add_iInf (h : \u2200 i j, \u2203 k, f k + g k \u2264 f i + g j) : iInf f + iInf g = \u2a05 a, f a + g a :=\n  suffices \u2a05 a, f a + g a \u2264 iInf f + iInf g from\n    le_antisymm (le_iInf fun _ => add_le_add (iInf_le _ _) (iInf_le _ _)) this\n  calc\n    \u2a05 a, f a + g a \u2264 \u2a05 (a) (a'), f a + g a' :=\n      le_iInf\u2082 fun a a' => let \u27e8k, h\u27e9 := h a a'; iInf_le_of_le k h\n    _ = iInf f + iInf g := by simp_rw [iInf_add, add_iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENNReal/Real.lean", "context": {"open": ["Set NNReal ENNReal"], "variables": ["{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}", "{\u03b9 : Sort*} {f g : \u03b9 \u2192 \u211d\u22650\u221e}", "{a b c d : \u211d\u22650\u221e} {r p q : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nf g : \u03b9 \u2192 ENNReal\nh : \u2200 (i j : \u03b9), \u2203 k, f k + g k \u2264 f i + g j\n\u22a2 \u2a05 a, \u2a05 a', f a + g a' = iInf f + iInf g"}, {"line": "simp_rw [iInf_add, add_iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iInf_toNat : (\u2a05 i, (f i : \u2115\u221e)).toNat = \u2a05 i, f i := by\n  cases isEmpty_or_nonempty \u03b9\n  \u00b7 simp\n  \u00b7 norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Lattice.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {f : \u03b9 \u2192 \u2115} {s : Set \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nf : \u03b9 \u2192 \u2115\n\u22a2 (\u2a05 i, \u2191(f i)).toNat = \u2a05 i, f i"}, {"line": "cases isEmpty_or_nonempty \u03b9", "tactic_state": "case inl\n\u03b9 : Sort u_1\nf : \u03b9 \u2192 \u2115\nh\u271d : IsEmpty \u03b9\n\u22a2 (\u2a05 i, \u2191(f i)).toNat = \u2a05 i, f i\n---\ncase inr\n\u03b9 : Sort u_1\nf : \u03b9 \u2192 \u2115\nh\u271d : Nonempty \u03b9\n\u22a2 (\u2a05 i, \u2191(f i)).toNat = \u2a05 i, f i"}, {"line": "\u00b7 simp", "tactic_state": "case inr\n\u03b9 : Sort u_1\nf : \u03b9 \u2192 \u2115\nh\u271d : Nonempty \u03b9\n\u22a2 (\u2a05 i, \u2191(f i)).toNat = \u2a05 i, f i"}, {"line": "\u00b7 norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "lemma finite_of_sSup_lt_top (h : sSup s < \u22a4) : s.Finite := by\n  contrapose! h\n  simp only [top_le_iff]\n  exact sSup_eq_top_of_infinite h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Lattice.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {f : \u03b9 \u2192 \u2115} {s : Set \u2115}", "{f : \u03b9 \u2192 \u2115\u221e} {s : Set \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set \u2115\u221e\nh : sSup s < \u22a4\n\u22a2 s.Finite"}, {"line": "contrapose! h", "tactic_state": "s : Set \u2115\u221e\nh : \u00acs.Finite\n\u22a2 \u22a4 \u2264 sSup s"}, {"line": "simp only [top_le_iff]", "tactic_state": "s : Set \u2115\u221e\nh : \u00acs.Finite\n\u22a2 sSup s = \u22a4"}, {"line": "exact sSup_eq_top_of_infinite h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_eq_iSup\u2082_of_lt_top {\u03b9\u2081 \u03b9\u2082 : Type*} {f : \u03b9\u2081 \u2192 \u03b9\u2082 \u2192 \u2115\u221e} [Nonempty \u03b9\u2081] [Nonempty \u03b9\u2082]\n    (h : \u2a06 i, \u2a06 j, f i j < \u22a4) : \u2203 i j, f i j = \u2a06 i, \u2a06 j, f i j := by\n  rw [iSup_prod'] at h \u22a2\n  exact Prod.exists'.mp (exists_eq_iSup_of_lt_top h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Lattice.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {f : \u03b9 \u2192 \u2115} {s : Set \u2115}", "{f : \u03b9 \u2192 \u2115\u221e} {s : Set \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9\u2081 : Type u_2\n\u03b9\u2082 : Type u_3\nf : \u03b9\u2081 \u2192 \u03b9\u2082 \u2192 \u2115\u221e\ninst\u271d\u00b9 : Nonempty \u03b9\u2081\ninst\u271d : Nonempty \u03b9\u2082\nh : \u2a06 i, \u2a06 j, f i j < \u22a4\n\u22a2 \u2203 i j, f i j = \u2a06 i, \u2a06 j, f i j"}, {"line": "rw [iSup_prod'] at h \u22a2", "tactic_state": "\u03b9\u2081 : Type u_2\n\u03b9\u2082 : Type u_3\nf : \u03b9\u2081 \u2192 \u03b9\u2082 \u2192 \u2115\u221e\ninst\u271d\u00b9 : Nonempty \u03b9\u2081\ninst\u271d : Nonempty \u03b9\u2082\nh : \u2a06 x, f x.1 x.2 < \u22a4\n\u22a2 \u2203 i j, f i j = \u2a06 x, f x.1 x.2"}, {"line": "exact Prod.exists'.mp (exists_eq_iSup_of_lt_top h)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iSup_mul (f : \u03b9 \u2192 \u2115\u221e) (a : \u2115\u221e) : (\u2a06 i, f i) * a = \u2a06 i, f i * a := by\n  simp_rw [mul_comm, ENat.mul_iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Lattice.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {f : \u03b9 \u2192 \u2115} {s : Set \u2115}", "{f : \u03b9 \u2192 \u2115\u221e} {s : Set \u2115\u221e}", "{\u03b9 \u03ba : Sort*} {f g : \u03b9 \u2192 \u2115\u221e} {s : Set \u2115\u221e} {a : \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_2\nf : \u03b9 \u2192 \u2115\u221e\na : \u2115\u221e\n\u22a2 (\u2a06 i, f i) * a = \u2a06 i, f i * a"}, {"line": "simp_rw [mul_comm, ENat.mul_iSup]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_iSup [Nonempty \u03b9] (f : \u03b9 \u2192 \u2115\u221e) : a + \u2a06 i, f i = \u2a06 i, a + f i := by\n  obtain rfl | ha := eq_or_ne a \u22a4\n  \u00b7 simp\n  refine le_antisymm ?_ <| iSup_le fun i \u21a6 add_le_add_left (le_iSup ..) _\n  refine add_le_of_le_tsub_left_of_le (le_iSup_of_le (Classical.arbitrary _) le_self_add) ?_\n  exact iSup_le fun i \u21a6 ENat.le_sub_of_add_le_left ha <| le_iSup (a + f \u00b7) i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Lattice.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {f : \u03b9 \u2192 \u2115} {s : Set \u2115}", "{f : \u03b9 \u2192 \u2115\u221e} {s : Set \u2115\u221e}", "{\u03b9 \u03ba : Sort*} {f g : \u03b9 \u2192 \u2115\u221e} {s : Set \u2115\u221e} {a : \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_2\na : \u2115\u221e\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 \u2115\u221e\n\u22a2 a + \u2a06 i, f i = \u2a06 i, a + f i"}, {"line": "obtain rfl | ha := eq_or_ne a \u22a4", "tactic_state": "case inl\n\u03b9 : Sort u_2\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 \u2115\u221e\n\u22a2 \u22a4 + \u2a06 i, f i = \u2a06 i, \u22a4 + f i\n---\ncase inr\n\u03b9 : Sort u_2\na : \u2115\u221e\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 \u2115\u221e\nha : a \u2260 \u22a4\n\u22a2 a + \u2a06 i, f i = \u2a06 i, a + f i"}, {"line": "\u00b7 simp", "tactic_state": "case inr\n\u03b9 : Sort u_2\na : \u2115\u221e\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 \u2115\u221e\nha : a \u2260 \u22a4\n\u22a2 a + \u2a06 i, f i = \u2a06 i, a + f i"}, {"line": "refine le_antisymm ?_ <| iSup_le fun i \u21a6 add_le_add_left (le_iSup ..) _", "tactic_state": "case inr\n\u03b9 : Sort u_2\na : \u2115\u221e\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 \u2115\u221e\nha : a \u2260 \u22a4\n\u22a2 a + \u2a06 i, f i \u2264 \u2a06 i, a + f i"}, {"line": "refine add_le_of_le_tsub_left_of_le (le_iSup_of_le (Classical.arbitrary _) le_self_add) ?_", "tactic_state": "case inr\n\u03b9 : Sort u_2\na : \u2115\u221e\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 \u2115\u221e\nha : a \u2260 \u22a4\n\u22a2 \u2a06 i, f i \u2264 (\u2a06 i, a + f i) - a"}, {"line": "exact iSup_le fun i \u21a6 ENat.le_sub_of_add_le_left ha <| le_iSup (a + f \u00b7) i", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iSup_add [Nonempty \u03b9] (f : \u03b9 \u2192 \u2115\u221e) : (\u2a06 i, f i) + a = \u2a06 i, f i + a := by\n  simp [add_comm, add_iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Lattice.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {f : \u03b9 \u2192 \u2115} {s : Set \u2115}", "{f : \u03b9 \u2192 \u2115\u221e} {s : Set \u2115\u221e}", "{\u03b9 \u03ba : Sort*} {f g : \u03b9 \u2192 \u2115\u221e} {s : Set \u2115\u221e} {a : \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_2\na : \u2115\u221e\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 \u2115\u221e\n\u22a2 (\u2a06 i, f i) + a = \u2a06 i, f i + a"}, {"line": "simp [add_comm, add_iSup]", "tactic_state": "\u03b9 : Sort u_2\na : \u2115\u221e\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 \u2115\u221e\n\u22a2 a + \u2a06 i, f i = \u2a06 i, a + f i"}]}
{"declaration": "lemma biSup_add' {p : \u03b9 \u2192 Prop} (h : \u2203 i, p i) (f : \u03b9 \u2192 \u2115\u221e) :\n    (\u2a06 i, \u2a06 _ : p i, f i) + a = \u2a06 i, \u2a06 _ : p i, f i + a := by simp only [add_comm, add_biSup' h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Lattice.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {f : \u03b9 \u2192 \u2115} {s : Set \u2115}", "{f : \u03b9 \u2192 \u2115\u221e} {s : Set \u2115\u221e}", "{\u03b9 \u03ba : Sort*} {f g : \u03b9 \u2192 \u2115\u221e} {s : Set \u2115\u221e} {a : \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_2\na : \u2115\u221e\np : \u03b9 \u2192 Prop\nh : \u2203 i, p i\nf : \u03b9 \u2192 \u2115\u221e\n\u22a2 (\u2a06 i, \u2a06 (_ : p i), f i) + a = \u2a06 i, \u2a06 (_ : p i), f i + a"}, {"line": "simp only [add_comm, add_biSup' h]", "tactic_state": "\u03b9 : Sort u_2\na : \u2115\u221e\np : \u03b9 \u2192 Prop\nh : \u2203 i, p i\nf : \u03b9 \u2192 \u2115\u221e\n\u22a2 a + \u2a06 i, \u2a06 (_ : p i), f i = \u2a06 i, \u2a06 (_ : p i), a + f i"}]}
{"declaration": "lemma smul_iSup {R} [SMul R \u2115\u221e] [IsScalarTower R \u2115\u221e \u2115\u221e] (f : \u03b9 \u2192 \u2115\u221e) (c : R) :\n    c \u2022 \u2a06 i, f i = \u2a06 i, c \u2022 f i := by\n  simpa using mul_iSup (c \u2022 1) f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Lattice.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {f : \u03b9 \u2192 \u2115} {s : Set \u2115}", "{f : \u03b9 \u2192 \u2115\u221e} {s : Set \u2115\u221e}", "{\u03b9 \u03ba : Sort*} {f g : \u03b9 \u2192 \u2115\u221e} {s : Set \u2115\u221e} {a : \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_2\nR : Type u_4\ninst\u271d\u00b9 : SMul R \u2115\u221e\ninst\u271d : IsScalarTower R \u2115\u221e \u2115\u221e\nf : \u03b9 \u2192 \u2115\u221e\nc : R\n\u22a2 c \u2022 \u2a06 i, f i = \u2a06 i, c \u2022 f i"}, {"line": "simpa using mul_iSup (c \u2022 1) f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_lt_zero (n : \u2115\u221e) : \u00ac n < 0 := by\n  cases n <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Basic.lean", "context": {"open": ["Function"], "variables": ["{a b c m n : \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\u221e\n\u22a2 \u00acn < 0"}, {"line": "cases n <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_lt_coe {n m : \u2115} : (n : \u2115\u221e) < (m : \u2115\u221e) \u2194 n < m := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Basic.lean", "context": {"open": ["Function"], "variables": ["{a b c m n : \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\n\u22a2 \u2191n < \u2191m \u2194 n < m"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_le_coe {n m : \u2115} : (n : \u2115\u221e) \u2264 (m : \u2115\u221e) \u2194 n \u2264 m := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Basic.lean", "context": {"open": ["Function"], "variables": ["{a b c m n : \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\n\u22a2 \u2191n \u2264 \u2191m \u2194 n \u2264 m"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nat_induction {P : \u2115\u221e \u2192 Prop} (a : \u2115\u221e) (h0 : P 0) (hsuc : \u2200 n : \u2115, P n \u2192 P n.succ)\n    (htop : (\u2200 n : \u2115, P n) \u2192 P \u22a4) : P a := by\n  have A : \u2200 n : \u2115, P n := fun n => Nat.recOn n h0 hsuc\n  cases a\n  \u00b7 exact htop A\n  \u00b7 exact A _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Basic.lean", "context": {"open": ["Function"], "variables": ["{a b c m n : \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : \u2115\u221e \u2192 Prop\na : \u2115\u221e\nh0 : P 0\nhsuc : \u2200 (n : \u2115), P \u2191n \u2192 P \u2191n.succ\nhtop : (\u2200 (n : \u2115), P \u2191n) \u2192 P \u22a4\n\u22a2 P a"}, {"line": "have A : \u2200 n : \u2115, P n := fun n => Nat.recOn n h0 hsuc", "tactic_state": "P : \u2115\u221e \u2192 Prop\na : \u2115\u221e\nh0 : P 0\nhsuc : \u2200 (n : \u2115), P \u2191n \u2192 P \u2191n.succ\nhtop : (\u2200 (n : \u2115), P \u2191n) \u2192 P \u22a4\nA : \u2200 (n : \u2115), P \u2191n\n\u22a2 P a"}, {"line": "cases a", "tactic_state": "case top\nP : \u2115\u221e \u2192 Prop\nh0 : P 0\nhsuc : \u2200 (n : \u2115), P \u2191n \u2192 P \u2191n.succ\nhtop : (\u2200 (n : \u2115), P \u2191n) \u2192 P \u22a4\nA : \u2200 (n : \u2115), P \u2191n\n\u22a2 P \u22a4\n---\ncase coe\nP : \u2115\u221e \u2192 Prop\nh0 : P 0\nhsuc : \u2200 (n : \u2115), P \u2191n \u2192 P \u2191n.succ\nhtop : (\u2200 (n : \u2115), P \u2191n) \u2192 P \u22a4\nA : \u2200 (n : \u2115), P \u2191n\na\u271d : \u2115\n\u22a2 P \u2191a\u271d"}, {"line": "\u00b7 exact htop A", "tactic_state": "case coe\nP : \u2115\u221e \u2192 Prop\nh0 : P 0\nhsuc : \u2200 (n : \u2115), P \u2191n \u2192 P \u2191n.succ\nhtop : (\u2200 (n : \u2115), P \u2191n) \u2192 P \u22a4\nA : \u2200 (n : \u2115), P \u2191n\na\u271d : \u2115\n\u22a2 P \u2191a\u271d"}, {"line": "\u00b7 exact A _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_left_injective_of_ne_top {n : \u2115\u221e} (hn : n \u2260 \u22a4) : Function.Injective (\u00b7 + n) := by\n  intro a b e\n  exact le_antisymm\n    ((WithTop.add_le_add_iff_right hn).mp e.le)\n    ((WithTop.add_le_add_iff_right hn).mp e.ge)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Basic.lean", "context": {"open": ["Function"], "variables": ["{a b c m n : \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\u221e\nhn : n \u2260 \u22a4\n\u22a2 Injective fun x => x + n"}, {"line": "intro a b e", "tactic_state": "n : \u2115\u221e\nhn : n \u2260 \u22a4\na b : \u2115\u221e\ne : (fun x => x + n) a = (fun x => x + n) b\n\u22a2 a = b"}, {"line": "exact le_antisymm\n    ((WithTop.add_le_add_iff_right hn).mp e.le)\n    ((WithTop.add_le_add_iff_right hn).mp e.ge)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_right_injective_of_ne_top {n : \u2115\u221e} (hn : n \u2260 \u22a4) : Function.Injective (n + \u00b7) := by\n  simp_rw [add_comm n _]\n  exact add_left_injective_of_ne_top hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Basic.lean", "context": {"open": ["Function"], "variables": ["{a b c m n : \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\u221e\nhn : n \u2260 \u22a4\n\u22a2 Injective fun x => n + x"}, {"line": "simp_rw [add_comm n _]", "tactic_state": "n : \u2115\u221e\nhn : n \u2260 \u22a4\n\u22a2 Injective fun x => x + n"}, {"line": "exact add_left_injective_of_ne_top hn", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_le_mul_of_le_right {x y : \u2115\u221e} (hxy : x \u2264 y) (ha : a \u2260 0) (h_top : a \u2260 \u22a4) :\n    x * a \u2264 y * a := by\n  simpa [ha, h_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Basic.lean", "context": {"open": ["Function"], "variables": ["{a b c m n : \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a x y : \u2115\u221e\nhxy : x \u2264 y\nha : a \u2260 0\nh_top : a \u2260 \u22a4\n\u22a2 x * a \u2264 y * a"}, {"line": "simpa [ha, h_top]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma self_le_mul_right (a : \u2115\u221e) (hc : c \u2260 0) : a \u2264 a * c := by\n  obtain rfl | hne := eq_or_ne a \u22a4\n  \u00b7 simp [top_mul hc]\n  obtain rfl | h0 := eq_or_ne a 0\n  \u00b7 simp\n  nth_rewrite 1 [\u2190 mul_one a, ENat.mul_le_mul_left_iff h0 hne, ENat.one_le_iff_ne_zero]\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Basic.lean", "context": {"open": ["Function"], "variables": ["{a b c m n : \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c a : \u2115\u221e\nhc : c \u2260 0\n\u22a2 a \u2264 a * c"}, {"line": "obtain rfl | hne := eq_or_ne a \u22a4", "tactic_state": "case inl\nc : \u2115\u221e\nhc : c \u2260 0\n\u22a2 \u22a4 \u2264 \u22a4 * c\n---\ncase inr\nc a : \u2115\u221e\nhc : c \u2260 0\nhne : a \u2260 \u22a4\n\u22a2 a \u2264 a * c"}, {"line": "\u00b7 simp [top_mul hc]", "tactic_state": "case inr\nc a : \u2115\u221e\nhc : c \u2260 0\nhne : a \u2260 \u22a4\n\u22a2 a \u2264 a * c"}, {"line": "obtain rfl | h0 := eq_or_ne a 0", "tactic_state": "case inr.inl\nc : \u2115\u221e\nhc : c \u2260 0\nhne : 0 \u2260 \u22a4\n\u22a2 0 \u2264 0 * c\n---\ncase inr.inr\nc a : \u2115\u221e\nhc : c \u2260 0\nhne : a \u2260 \u22a4\nh0 : a \u2260 0\n\u22a2 a \u2264 a * c"}, {"line": "\u00b7 simp", "tactic_state": "case inr.inr\nc a : \u2115\u221e\nhc : c \u2260 0\nhne : a \u2260 \u22a4\nh0 : a \u2260 0\n\u22a2 a \u2264 a * c"}, {"line": "nth_rewrite 1 [\u2190 mul_one a, ENat.mul_le_mul_left_iff h0 hne, ENat.one_le_iff_ne_zero]", "tactic_state": "case inr.inr\nc a : \u2115\u221e\nhc : c \u2260 0\nhne : a \u2260 \u22a4\nh0 : a \u2260 0\n\u22a2 c \u2260 0"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "lemma self_le_mul_left (a : \u2115\u221e) (hc : c \u2260 0) : a \u2264 c * a := by\n  rw [mul_comm]\n  exact ENat.self_le_mul_right a hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Basic.lean", "context": {"open": ["Function"], "variables": ["{a b c m n : \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c a : \u2115\u221e\nhc : c \u2260 0\n\u22a2 a \u2264 c * a"}, {"line": "rw [mul_comm]", "tactic_state": "c a : \u2115\u221e\nhc : c \u2260 0\n\u22a2 a \u2264 a * c"}, {"line": "exact ENat.self_le_mul_right a hc", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithBot.lt_add_one_iff {n : WithBot \u2115\u221e} {m : \u2115} : n < m + 1 \u2194 n \u2264 m := by\n  rw [\u2190 WithBot.coe_one]\n  rw [\u2190 ENat.coe_one]\n  rw [WithBot.coe_natCast]\n  rw [\u2190 Nat.cast_add]\n  rw [\u2190 WithBot.coe_natCast]\n  cases n\n  \u00b7 simp only [bot_le, iff_true, WithBot.bot_lt_coe]\n  \u00b7 rw [WithBot.coe_lt_coe, Nat.cast_add, ENat.coe_one, ENat.lt_add_one_iff (ENat.coe_ne_top _),\n      \u2190 WithBot.coe_le_coe, WithBot.coe_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Basic.lean", "context": {"open": ["Function"], "variables": ["{a b c m n : \u2115\u221e}", "{\u03b1 : Type*}", "[AddMonoidWithOne \u03b1] [PartialOrder \u03b1] [AddLeftMono \u03b1] [ZeroLEOneClass \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : WithBot \u2115\u221e\nm : \u2115\n\u22a2 n < \u2191m + 1 \u2194 n \u2264 \u2191m"}, {"line": "rw [\u2190 WithBot.coe_one]", "tactic_state": "n : WithBot \u2115\u221e\nm : \u2115\n\u22a2 n < \u2191m + \u21911 \u2194 n \u2264 \u2191m"}, {"line": "rw [\u2190 ENat.coe_one]", "tactic_state": "n : WithBot \u2115\u221e\nm : \u2115\n\u22a2 n < \u2191m + \u2191\u21911 \u2194 n \u2264 \u2191m"}, {"line": "rw [WithBot.coe_natCast]", "tactic_state": "n : WithBot \u2115\u221e\nm : \u2115\n\u22a2 n < \u2191m + \u21911 \u2194 n \u2264 \u2191m"}, {"line": "rw [\u2190 Nat.cast_add]", "tactic_state": "n : WithBot \u2115\u221e\nm : \u2115\n\u22a2 n < \u2191(m + 1) \u2194 n \u2264 \u2191m"}, {"line": "rw [\u2190 WithBot.coe_natCast]", "tactic_state": "n : WithBot \u2115\u221e\nm : \u2115\n\u22a2 n < \u2191\u2191(m + 1) \u2194 n \u2264 \u2191m"}, {"line": "cases n", "tactic_state": "case bot\nm : \u2115\n\u22a2 \u22a5 < \u2191\u2191(m + 1) \u2194 \u22a5 \u2264 \u2191m\n---\ncase coe\nm : \u2115\na\u271d : \u2115\u221e\n\u22a2 \u2191a\u271d < \u2191\u2191(m + 1) \u2194 \u2191a\u271d \u2264 \u2191m"}, {"line": "\u00b7 simp only [bot_le, iff_true, WithBot.bot_lt_coe]", "tactic_state": "case coe\nm : \u2115\na\u271d : \u2115\u221e\n\u22a2 \u2191a\u271d < \u2191\u2191(m + 1) \u2194 \u2191a\u271d \u2264 \u2191m"}, {"line": "\u00b7 rw [WithBot.coe_lt_coe, Nat.cast_add, ENat.coe_one, ENat.lt_add_one_iff (ENat.coe_ne_top _),\n      \u2190 WithBot.coe_le_coe, WithBot.coe_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithBot.add_one_le_iff {n : \u2115} {m : WithBot \u2115\u221e} : n + 1 \u2264 m \u2194 n < m := by\n  rw [\u2190 WithBot.coe_one]\n  rw [\u2190 ENat.coe_one]\n  rw [WithBot.coe_natCast]\n  rw [\u2190 Nat.cast_add]\n  rw [\u2190 WithBot.coe_natCast]\n  cases m\n  \u00b7 simp\n  \u00b7 rw [WithBot.coe_le_coe, ENat.coe_add, ENat.coe_one, ENat.add_one_le_iff (ENat.coe_ne_top n),\n      \u2190 WithBot.coe_lt_coe, WithBot.coe_natCast]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ENat/Basic.lean", "context": {"open": ["Function"], "variables": ["{a b c m n : \u2115\u221e}", "{\u03b1 : Type*}", "[AddMonoidWithOne \u03b1] [PartialOrder \u03b1] [AddLeftMono \u03b1] [ZeroLEOneClass \u03b1]", "[CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nm : WithBot \u2115\u221e\n\u22a2 \u2191n + 1 \u2264 m \u2194 \u2191n < m"}, {"line": "rw [\u2190 WithBot.coe_one]", "tactic_state": "n : \u2115\nm : WithBot \u2115\u221e\n\u22a2 \u2191n + \u21911 \u2264 m \u2194 \u2191n < m"}, {"line": "rw [\u2190 ENat.coe_one]", "tactic_state": "n : \u2115\nm : WithBot \u2115\u221e\n\u22a2 \u2191n + \u2191\u21911 \u2264 m \u2194 \u2191n < m"}, {"line": "rw [WithBot.coe_natCast]", "tactic_state": "n : \u2115\nm : WithBot \u2115\u221e\n\u22a2 \u2191n + \u21911 \u2264 m \u2194 \u2191n < m"}, {"line": "rw [\u2190 Nat.cast_add]", "tactic_state": "n : \u2115\nm : WithBot \u2115\u221e\n\u22a2 \u2191(n + 1) \u2264 m \u2194 \u2191n < m"}, {"line": "rw [\u2190 WithBot.coe_natCast]", "tactic_state": "n : \u2115\nm : WithBot \u2115\u221e\n\u22a2 \u2191\u2191(n + 1) \u2264 m \u2194 \u2191n < m"}, {"line": "cases m", "tactic_state": "case bot\nn : \u2115\n\u22a2 \u2191\u2191(n + 1) \u2264 \u22a5 \u2194 \u2191n < \u22a5\n---\ncase coe\nn : \u2115\na\u271d : \u2115\u221e\n\u22a2 \u2191\u2191(n + 1) \u2264 \u2191a\u271d \u2194 \u2191n < \u2191a\u271d"}, {"line": "\u00b7 simp", "tactic_state": "case coe\nn : \u2115\na\u271d : \u2115\u221e\n\u22a2 \u2191\u2191(n + 1) \u2264 \u2191a\u271d \u2194 \u2191n < \u2191a\u271d"}, {"line": "\u00b7 rw [WithBot.coe_le_coe, ENat.coe_add, ENat.coe_one, ENat.add_one_le_iff (ENat.coe_ne_top n),\n      \u2190 WithBot.coe_lt_coe, WithBot.coe_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_coe_eq_Ioo : range Real.toEReal = Ioo \u22a5 \u22a4 := by\n  ext x\n  induction x <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 range Real.toEReal = Ioo \u22a5 \u22a4"}, {"line": "ext x", "tactic_state": "case h\nx : EReal\n\u22a2 x \u2208 range Real.toEReal \u2194 x \u2208 Ioo \u22a5 \u22a4"}, {"line": "induction x <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toReal_eq_zero_iff {x : EReal} : x.toReal = 0 \u2194 x = 0 \u2228 x = \u22a4 \u2228 x = \u22a5 := by\n  cases x <;> norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\n\u22a2 x.toReal = 0 \u2194 x = 0 \u2228 x = \u22a4 \u2228 x = \u22a5"}, {"line": "cases x <;> norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toReal_eq_toReal {x y : EReal} (hx_top : x \u2260 \u22a4) (hx_bot : x \u2260 \u22a5)\n    (hy_top : y \u2260 \u22a4) (hy_bot : y \u2260 \u22a5) :\n    x.toReal = y.toReal \u2194 x = y := by\n  lift x to \u211d using \u27e8hx_top, hx_bot\u27e9\n  lift y to \u211d using \u27e8hy_top, hy_bot\u27e9\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : EReal\nhx_top : x \u2260 \u22a4\nhx_bot : x \u2260 \u22a5\nhy_top : y \u2260 \u22a4\nhy_bot : y \u2260 \u22a5\n\u22a2 x.toReal = y.toReal \u2194 x = y"}, {"line": "lift x to \u211d using \u27e8hx_top, hx_bot\u27e9", "tactic_state": "case intro\ny : EReal\nhy_top : y \u2260 \u22a4\nhy_bot : y \u2260 \u22a5\nx : \u211d\nhx_top : \u2191x \u2260 \u22a4\nhx_bot : \u2191x \u2260 \u22a5\n\u22a2 (\u2191x).toReal = y.toReal \u2194 \u2191x = y"}, {"line": "lift y to \u211d using \u27e8hy_top, hy_bot\u27e9", "tactic_state": "case intro.intro\nx : \u211d\nhx_top : \u2191x \u2260 \u22a4\nhx_bot : \u2191x \u2260 \u22a5\ny : \u211d\nhy_top : \u2191y \u2260 \u22a4\nhy_bot : \u2191y \u2260 \u22a5\n\u22a2 (\u2191x).toReal = (\u2191y).toReal \u2194 \u2191x = \u2191y"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toReal_nonneg {x : EReal} (hx : 0 \u2264 x) : 0 \u2264 x.toReal := by\n  cases x\n  \u00b7 norm_num\n  \u00b7 exact toReal_coe _ \u25b8 EReal.coe_nonneg.mp hx\n  \u00b7 norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\nhx : 0 \u2264 x\n\u22a2 0 \u2264 x.toReal"}, {"line": "cases x", "tactic_state": "case bot\nhx : 0 \u2264 \u22a5\n\u22a2 0 \u2264 \u22a5.toReal\n---\ncase coe\na\u271d : \u211d\nhx : 0 \u2264 \u2191a\u271d\n\u22a2 0 \u2264 (\u2191a\u271d).toReal\n---\ncase top\nhx : 0 \u2264 \u22a4\n\u22a2 0 \u2264 \u22a4.toReal"}, {"line": "\u00b7 norm_num", "tactic_state": "case coe\na\u271d : \u211d\nhx : 0 \u2264 \u2191a\u271d\n\u22a2 0 \u2264 (\u2191a\u271d).toReal\n---\ncase top\nhx : 0 \u2264 \u22a4\n\u22a2 0 \u2264 \u22a4.toReal"}, {"line": "\u00b7 exact toReal_coe _ \u25b8 EReal.coe_nonneg.mp hx", "tactic_state": "case top\nhx : 0 \u2264 \u22a4\n\u22a2 0 \u2264 \u22a4.toReal"}, {"line": "\u00b7 norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toReal_nonpos {x : EReal} (hx : x \u2264 0) : x.toReal \u2264 0 := by\n  cases x\n  \u00b7 norm_num\n  \u00b7 exact toReal_coe _ \u25b8 EReal.coe_nonpos.mp hx\n  \u00b7 norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\nhx : x \u2264 0\n\u22a2 x.toReal \u2264 0"}, {"line": "cases x", "tactic_state": "case bot\nhx : \u22a5 \u2264 0\n\u22a2 \u22a5.toReal \u2264 0\n---\ncase coe\na\u271d : \u211d\nhx : \u2191a\u271d \u2264 0\n\u22a2 (\u2191a\u271d).toReal \u2264 0\n---\ncase top\nhx : \u22a4 \u2264 0\n\u22a2 \u22a4.toReal \u2264 0"}, {"line": "\u00b7 norm_num", "tactic_state": "case coe\na\u271d : \u211d\nhx : \u2191a\u271d \u2264 0\n\u22a2 (\u2191a\u271d).toReal \u2264 0\n---\ncase top\nhx : \u22a4 \u2264 0\n\u22a2 \u22a4.toReal \u2264 0"}, {"line": "\u00b7 exact toReal_coe _ \u25b8 EReal.coe_nonpos.mp hx", "tactic_state": "case top\nhx : \u22a4 \u2264 0\n\u22a2 \u22a4.toReal \u2264 0"}, {"line": "\u00b7 norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toReal_le_toReal {x y : EReal} (h : x \u2264 y) (hx : x \u2260 \u22a5) (hy : y \u2260 \u22a4) :\n    x.toReal \u2264 y.toReal := by\n  lift x to \u211d using \u27e8ne_top_of_le_ne_top hy h, hx\u27e9\n  lift y to \u211d using \u27e8hy, ne_bot_of_le_ne_bot hx h\u27e9\n  simpa using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : EReal\nh : x \u2264 y\nhx : x \u2260 \u22a5\nhy : y \u2260 \u22a4\n\u22a2 x.toReal \u2264 y.toReal"}, {"line": "lift x to \u211d using \u27e8ne_top_of_le_ne_top hy h, hx\u27e9", "tactic_state": "case intro\ny : EReal\nhy : y \u2260 \u22a4\nx : \u211d\nh : \u2191x \u2264 y\nhx : \u2191x \u2260 \u22a5\n\u22a2 (\u2191x).toReal \u2264 y.toReal"}, {"line": "lift y to \u211d using \u27e8hy, ne_bot_of_le_ne_bot hx h\u27e9", "tactic_state": "case intro.intro\nx : \u211d\nhx : \u2191x \u2260 \u22a5\ny : \u211d\nhy : \u2191y \u2260 \u22a4\nh : \u2191x \u2264 \u2191y\n\u22a2 (\u2191x).toReal \u2264 (\u2191y).toReal"}, {"line": "simpa using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_toReal {x : EReal} (hx : x \u2260 \u22a4) (h'x : x \u2260 \u22a5) : (x.toReal : EReal) = x := by\n  lift x to \u211d using \u27e8hx, h'x\u27e9\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\nhx : x \u2260 \u22a4\nh'x : x \u2260 \u22a5\n\u22a2 \u2191x.toReal = x"}, {"line": "lift x to \u211d using \u27e8hx, h'x\u27e9", "tactic_state": "case intro\nx : \u211d\nhx : \u2191x \u2260 \u22a4\nh'x : \u2191x \u2260 \u22a5\n\u22a2 \u2191(\u2191x).toReal = \u2191x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_coe_toReal {x : EReal} (h : x \u2260 \u22a4) : x \u2264 x.toReal := by\n  by_cases h' : x = \u22a5\n  \u00b7 simp only [h', bot_le]\n  \u00b7 simp only [le_refl, coe_toReal h h']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\nh : x \u2260 \u22a4\n\u22a2 x \u2264 \u2191x.toReal"}, {"line": "by_cases h' : x = \u22a5", "tactic_state": "case pos\nx : EReal\nh : x \u2260 \u22a4\nh' : x = \u22a5\n\u22a2 x \u2264 \u2191x.toReal\n---\ncase neg\nx : EReal\nh : x \u2260 \u22a4\nh' : \u00acx = \u22a5\n\u22a2 x \u2264 \u2191x.toReal"}, {"line": "\u00b7 simp only [h', bot_le]", "tactic_state": "case neg\nx : EReal\nh : x \u2260 \u22a4\nh' : \u00acx = \u22a5\n\u22a2 x \u2264 \u2191x.toReal"}, {"line": "\u00b7 simp only [le_refl, coe_toReal h h']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_toReal_le {x : EReal} (h : x \u2260 \u22a5) : \u2191x.toReal \u2264 x := by\n  by_cases h' : x = \u22a4\n  \u00b7 simp only [h', le_top]\n  \u00b7 simp only [le_refl, coe_toReal h' h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\nh : x \u2260 \u22a5\n\u22a2 \u2191x.toReal \u2264 x"}, {"line": "by_cases h' : x = \u22a4", "tactic_state": "case pos\nx : EReal\nh : x \u2260 \u22a5\nh' : x = \u22a4\n\u22a2 \u2191x.toReal \u2264 x\n---\ncase neg\nx : EReal\nh : x \u2260 \u22a5\nh' : \u00acx = \u22a4\n\u22a2 \u2191x.toReal \u2264 x"}, {"line": "\u00b7 simp only [h', le_top]", "tactic_state": "case neg\nx : EReal\nh : x \u2260 \u22a5\nh' : \u00acx = \u22a4\n\u22a2 \u2191x.toReal \u2264 x"}, {"line": "\u00b7 simp only [le_refl, coe_toReal h' h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma image_coe_Icc (x y : \u211d) : Real.toEReal '' Icc x y = Icc \u2191x \u2191y := by\n  refine (image_comp WithBot.some WithTop.some _).trans ?_\n  rw [WithTop.image_coe_Icc]\n  rw [WithBot.image_coe_Icc]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 Real.toEReal '' Icc x y = Icc \u2191x \u2191y"}, {"line": "refine (image_comp WithBot.some WithTop.some _).trans ?_", "tactic_state": "x y : \u211d\n\u22a2 WithBot.some '' (WithTop.some '' Icc x y) = Icc \u2191x \u2191y"}, {"line": "rw [WithTop.image_coe_Icc]", "tactic_state": "x y : \u211d\n\u22a2 WithBot.some '' Icc \u2191x \u2191y = Icc \u2191x \u2191y"}, {"line": "rw [WithBot.image_coe_Icc]", "tactic_state": "x y : \u211d\n\u22a2 Icc \u2191\u2191x \u2191\u2191y = Icc \u2191x \u2191y"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma image_coe_Ico (x y : \u211d) : Real.toEReal '' Ico x y = Ico \u2191x \u2191y := by\n  refine (image_comp WithBot.some WithTop.some _).trans ?_\n  rw [WithTop.image_coe_Ico]\n  rw [WithBot.image_coe_Ico]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 Real.toEReal '' Ico x y = Ico \u2191x \u2191y"}, {"line": "refine (image_comp WithBot.some WithTop.some _).trans ?_", "tactic_state": "x y : \u211d\n\u22a2 WithBot.some '' (WithTop.some '' Ico x y) = Ico \u2191x \u2191y"}, {"line": "rw [WithTop.image_coe_Ico]", "tactic_state": "x y : \u211d\n\u22a2 WithBot.some '' Ico \u2191x \u2191y = Ico \u2191x \u2191y"}, {"line": "rw [WithBot.image_coe_Ico]", "tactic_state": "x y : \u211d\n\u22a2 Ico \u2191\u2191x \u2191\u2191y = Ico \u2191x \u2191y"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma image_coe_Ici (x : \u211d) : Real.toEReal '' Ici x = Ico \u2191x \u22a4 := by\n  refine (image_comp WithBot.some WithTop.some _).trans ?_\n  rw [WithTop.image_coe_Ici]\n  rw [WithBot.image_coe_Ico]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 Real.toEReal '' Ici x = Ico \u2191x \u22a4"}, {"line": "refine (image_comp WithBot.some WithTop.some _).trans ?_", "tactic_state": "x : \u211d\n\u22a2 WithBot.some '' (WithTop.some '' Ici x) = Ico \u2191x \u22a4"}, {"line": "rw [WithTop.image_coe_Ici]", "tactic_state": "x : \u211d\n\u22a2 WithBot.some '' Ico \u2191x \u22a4 = Ico \u2191x \u22a4"}, {"line": "rw [WithBot.image_coe_Ico]", "tactic_state": "x : \u211d\n\u22a2 Ico \u2191\u2191x \u2191\u22a4 = Ico \u2191x \u22a4"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma image_coe_Ioc (x y : \u211d) : Real.toEReal '' Ioc x y = Ioc \u2191x \u2191y := by\n  refine (image_comp WithBot.some WithTop.some _).trans ?_\n  rw [WithTop.image_coe_Ioc]\n  rw [WithBot.image_coe_Ioc]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 Real.toEReal '' Ioc x y = Ioc \u2191x \u2191y"}, {"line": "refine (image_comp WithBot.some WithTop.some _).trans ?_", "tactic_state": "x y : \u211d\n\u22a2 WithBot.some '' (WithTop.some '' Ioc x y) = Ioc \u2191x \u2191y"}, {"line": "rw [WithTop.image_coe_Ioc]", "tactic_state": "x y : \u211d\n\u22a2 WithBot.some '' Ioc \u2191x \u2191y = Ioc \u2191x \u2191y"}, {"line": "rw [WithBot.image_coe_Ioc]", "tactic_state": "x y : \u211d\n\u22a2 Ioc \u2191\u2191x \u2191\u2191y = Ioc \u2191x \u2191y"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma image_coe_Ioo (x y : \u211d) : Real.toEReal '' Ioo x y = Ioo \u2191x \u2191y := by\n  refine (image_comp WithBot.some WithTop.some _).trans ?_\n  rw [WithTop.image_coe_Ioo]\n  rw [WithBot.image_coe_Ioo]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 Real.toEReal '' Ioo x y = Ioo \u2191x \u2191y"}, {"line": "refine (image_comp WithBot.some WithTop.some _).trans ?_", "tactic_state": "x y : \u211d\n\u22a2 WithBot.some '' (WithTop.some '' Ioo x y) = Ioo \u2191x \u2191y"}, {"line": "rw [WithTop.image_coe_Ioo]", "tactic_state": "x y : \u211d\n\u22a2 WithBot.some '' Ioo \u2191x \u2191y = Ioo \u2191x \u2191y"}, {"line": "rw [WithBot.image_coe_Ioo]", "tactic_state": "x y : \u211d\n\u22a2 Ioo \u2191\u2191x \u2191\u2191y = Ioo \u2191x \u2191y"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma image_coe_Ioi (x : \u211d) : Real.toEReal '' Ioi x = Ioo \u2191x \u22a4 := by\n  refine (image_comp WithBot.some WithTop.some _).trans ?_\n  rw [WithTop.image_coe_Ioi]\n  rw [WithBot.image_coe_Ioo]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 Real.toEReal '' Ioi x = Ioo \u2191x \u22a4"}, {"line": "refine (image_comp WithBot.some WithTop.some _).trans ?_", "tactic_state": "x : \u211d\n\u22a2 WithBot.some '' (WithTop.some '' Ioi x) = Ioo \u2191x \u22a4"}, {"line": "rw [WithTop.image_coe_Ioi]", "tactic_state": "x : \u211d\n\u22a2 WithBot.some '' Ioo \u2191x \u22a4 = Ioo \u2191x \u22a4"}, {"line": "rw [WithBot.image_coe_Ioo]", "tactic_state": "x : \u211d\n\u22a2 Ioo \u2191\u2191x \u2191\u22a4 = Ioo \u2191x \u22a4"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma image_coe_Iic (x : \u211d) : Real.toEReal '' Iic x = Ioc \u22a5 \u2191x := by\n  refine (image_comp WithBot.some WithTop.some _).trans ?_\n  rw [WithTop.image_coe_Iic]\n  rw [WithBot.image_coe_Iic]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 Real.toEReal '' Iic x = Ioc \u22a5 \u2191x"}, {"line": "refine (image_comp WithBot.some WithTop.some _).trans ?_", "tactic_state": "x : \u211d\n\u22a2 WithBot.some '' (WithTop.some '' Iic x) = Ioc \u22a5 \u2191x"}, {"line": "rw [WithTop.image_coe_Iic]", "tactic_state": "x : \u211d\n\u22a2 WithBot.some '' Iic \u2191x = Ioc \u22a5 \u2191x"}, {"line": "rw [WithBot.image_coe_Iic]", "tactic_state": "x : \u211d\n\u22a2 Ioc \u22a5 \u2191\u2191x = Ioc \u22a5 \u2191x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma image_coe_Iio (x : \u211d) : Real.toEReal '' Iio x = Ioo \u22a5 \u2191x := by\n  refine (image_comp WithBot.some WithTop.some _).trans ?_\n  rw [WithTop.image_coe_Iio]\n  rw [WithBot.image_coe_Iio]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 Real.toEReal '' Iio x = Ioo \u22a5 \u2191x"}, {"line": "refine (image_comp WithBot.some WithTop.some _).trans ?_", "tactic_state": "x : \u211d\n\u22a2 WithBot.some '' (WithTop.some '' Iio x) = Ioo \u22a5 \u2191x"}, {"line": "rw [WithTop.image_coe_Iio]", "tactic_state": "x : \u211d\n\u22a2 WithBot.some '' Iio \u2191x = Ioo \u22a5 \u2191x"}, {"line": "rw [WithBot.image_coe_Iio]", "tactic_state": "x : \u211d\n\u22a2 Ioo \u22a5 \u2191\u2191x = Ioo \u22a5 \u2191x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_coe_Ici (x : \u211d) : Real.toEReal \u207b\u00b9' Ici x = Ici x := by\n  change (WithBot.some \u2218 WithTop.some) \u207b\u00b9' (Ici (WithBot.some (WithTop.some x))) = _\n  refine preimage_comp.trans ?_\n  simp only [WithBot.preimage_coe_Ici]\n  simp only [WithTop.preimage_coe_Ici]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' Ici \u2191x = Ici x"}, {"line": "change (WithBot.some \u2218 WithTop.some) \u207b\u00b9' (Ici (WithBot.some (WithTop.some x))) = _", "tactic_state": "x : \u211d\n\u22a2 WithBot.some \u2218 WithTop.some \u207b\u00b9' Ici \u2191\u2191x = Ici x"}, {"line": "refine preimage_comp.trans ?_", "tactic_state": "x : \u211d\n\u22a2 WithTop.some \u207b\u00b9' (WithBot.some \u207b\u00b9' Ici \u2191\u2191x) = Ici x"}, {"line": "simp only [WithBot.preimage_coe_Ici]", "tactic_state": "x : \u211d\n\u22a2 WithTop.some \u207b\u00b9' Ici \u2191x = Ici x"}, {"line": "simp only [WithTop.preimage_coe_Ici]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_coe_Ioi (x : \u211d) : Real.toEReal \u207b\u00b9' Ioi x = Ioi x := by\n  change (WithBot.some \u2218 WithTop.some) \u207b\u00b9' (Ioi (WithBot.some (WithTop.some x))) = _\n  refine preimage_comp.trans ?_\n  simp only [WithBot.preimage_coe_Ioi]\n  simp only [WithTop.preimage_coe_Ioi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' Ioi \u2191x = Ioi x"}, {"line": "change (WithBot.some \u2218 WithTop.some) \u207b\u00b9' (Ioi (WithBot.some (WithTop.some x))) = _", "tactic_state": "x : \u211d\n\u22a2 WithBot.some \u2218 WithTop.some \u207b\u00b9' Ioi \u2191\u2191x = Ioi x"}, {"line": "refine preimage_comp.trans ?_", "tactic_state": "x : \u211d\n\u22a2 WithTop.some \u207b\u00b9' (WithBot.some \u207b\u00b9' Ioi \u2191\u2191x) = Ioi x"}, {"line": "simp only [WithBot.preimage_coe_Ioi]", "tactic_state": "x : \u211d\n\u22a2 WithTop.some \u207b\u00b9' Ioi \u2191x = Ioi x"}, {"line": "simp only [WithTop.preimage_coe_Ioi]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_coe_Ioi_bot : Real.toEReal \u207b\u00b9' Ioi \u22a5 = univ := by\n  change (WithBot.some \u2218 WithTop.some) \u207b\u00b9' (Ioi \u22a5) = _\n  refine preimage_comp.trans ?_\n  simp only [WithBot.preimage_coe_Ioi_bot]\n  simp only [preimage_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Real.toEReal \u207b\u00b9' Ioi \u22a5 = univ"}, {"line": "change (WithBot.some \u2218 WithTop.some) \u207b\u00b9' (Ioi \u22a5) = _", "tactic_state": "\u22a2 WithBot.some \u2218 WithTop.some \u207b\u00b9' Ioi \u22a5 = univ"}, {"line": "refine preimage_comp.trans ?_", "tactic_state": "\u22a2 WithTop.some \u207b\u00b9' (WithBot.some \u207b\u00b9' Ioi \u22a5) = univ"}, {"line": "simp only [WithBot.preimage_coe_Ioi_bot]", "tactic_state": "\u22a2 WithTop.some \u207b\u00b9' univ = univ"}, {"line": "simp only [preimage_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_coe_Iic (y : \u211d) : Real.toEReal \u207b\u00b9' Iic y = Iic y := by\n  change (WithBot.some \u2218 WithTop.some) \u207b\u00b9' (Iic (WithBot.some (WithTop.some y))) = _\n  refine preimage_comp.trans ?_\n  simp only [WithBot.preimage_coe_Iic]\n  simp only [WithTop.preimage_coe_Iic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' Iic \u2191y = Iic y"}, {"line": "change (WithBot.some \u2218 WithTop.some) \u207b\u00b9' (Iic (WithBot.some (WithTop.some y))) = _", "tactic_state": "y : \u211d\n\u22a2 WithBot.some \u2218 WithTop.some \u207b\u00b9' Iic \u2191\u2191y = Iic y"}, {"line": "refine preimage_comp.trans ?_", "tactic_state": "y : \u211d\n\u22a2 WithTop.some \u207b\u00b9' (WithBot.some \u207b\u00b9' Iic \u2191\u2191y) = Iic y"}, {"line": "simp only [WithBot.preimage_coe_Iic]", "tactic_state": "y : \u211d\n\u22a2 WithTop.some \u207b\u00b9' Iic \u2191y = Iic y"}, {"line": "simp only [WithTop.preimage_coe_Iic]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_coe_Iio (y : \u211d) : Real.toEReal \u207b\u00b9' Iio y = Iio y := by\n  change (WithBot.some \u2218 WithTop.some) \u207b\u00b9' (Iio (WithBot.some (WithTop.some y))) = _\n  refine preimage_comp.trans ?_\n  simp only [WithBot.preimage_coe_Iio]\n  simp only [WithTop.preimage_coe_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' Iio \u2191y = Iio y"}, {"line": "change (WithBot.some \u2218 WithTop.some) \u207b\u00b9' (Iio (WithBot.some (WithTop.some y))) = _", "tactic_state": "y : \u211d\n\u22a2 WithBot.some \u2218 WithTop.some \u207b\u00b9' Iio \u2191\u2191y = Iio y"}, {"line": "refine preimage_comp.trans ?_", "tactic_state": "y : \u211d\n\u22a2 WithTop.some \u207b\u00b9' (WithBot.some \u207b\u00b9' Iio \u2191\u2191y) = Iio y"}, {"line": "simp only [WithBot.preimage_coe_Iio]", "tactic_state": "y : \u211d\n\u22a2 WithTop.some \u207b\u00b9' Iio \u2191y = Iio y"}, {"line": "simp only [WithTop.preimage_coe_Iio]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_coe_Iio_top : Real.toEReal \u207b\u00b9' Iio \u22a4 = univ := by\n  change (WithBot.some \u2218 WithTop.some) \u207b\u00b9' (Iio (WithBot.some \u22a4)) = _\n  refine preimage_comp.trans ?_\n  simp only [WithBot.preimage_coe_Iio]\n  simp only [WithTop.preimage_coe_Iio_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Real.toEReal \u207b\u00b9' Iio \u22a4 = univ"}, {"line": "change (WithBot.some \u2218 WithTop.some) \u207b\u00b9' (Iio (WithBot.some \u22a4)) = _", "tactic_state": "\u22a2 WithBot.some \u2218 WithTop.some \u207b\u00b9' Iio \u2191\u22a4 = univ"}, {"line": "refine preimage_comp.trans ?_", "tactic_state": "\u22a2 WithTop.some \u207b\u00b9' (WithBot.some \u207b\u00b9' Iio \u2191\u22a4) = univ"}, {"line": "simp only [WithBot.preimage_coe_Iio]", "tactic_state": "\u22a2 WithTop.some \u207b\u00b9' Iio \u22a4 = univ"}, {"line": "simp only [WithTop.preimage_coe_Iio_top]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_coe_Icc (x y : \u211d) : Real.toEReal \u207b\u00b9' Icc x y = Icc x y := by\n  simp_rw [\u2190 Ici_inter_Iic]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' Icc \u2191x \u2191y = Icc x y"}, {"line": "simp_rw [\u2190 Ici_inter_Iic]", "tactic_state": "x y : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' (Ici \u2191x \u2229 Iic \u2191y) = Ici x \u2229 Iic y"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_coe_Ico (x y : \u211d) : Real.toEReal \u207b\u00b9' Ico x y = Ico x y := by\n  simp_rw [\u2190 Ici_inter_Iio]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' Ico \u2191x \u2191y = Ico x y"}, {"line": "simp_rw [\u2190 Ici_inter_Iio]", "tactic_state": "x y : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' (Ici \u2191x \u2229 Iio \u2191y) = Ici x \u2229 Iio y"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_coe_Ioc (x y : \u211d) : Real.toEReal \u207b\u00b9' Ioc x y = Ioc x y := by\n  simp_rw [\u2190 Ioi_inter_Iic]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' Ioc \u2191x \u2191y = Ioc x y"}, {"line": "simp_rw [\u2190 Ioi_inter_Iic]", "tactic_state": "x y : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' (Ioi \u2191x \u2229 Iic \u2191y) = Ioi x \u2229 Iic y"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_coe_Ioo (x y : \u211d) : Real.toEReal \u207b\u00b9' Ioo x y = Ioo x y := by\n  simp_rw [\u2190 Ioi_inter_Iio]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' Ioo \u2191x \u2191y = Ioo x y"}, {"line": "simp_rw [\u2190 Ioi_inter_Iio]", "tactic_state": "x y : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' (Ioi \u2191x \u2229 Iio \u2191y) = Ioi x \u2229 Iio y"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_coe_Ico_top (x : \u211d) : Real.toEReal \u207b\u00b9' Ico x \u22a4 = Ici x := by\n  rw [\u2190 Ici_inter_Iio]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' Ico \u2191x \u22a4 = Ici x"}, {"line": "rw [\u2190 Ici_inter_Iio]", "tactic_state": "x : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' (Ici \u2191x \u2229 Iio \u22a4) = Ici x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_coe_Ioo_top (x : \u211d) : Real.toEReal \u207b\u00b9' Ioo x \u22a4 = Ioi x := by\n  rw [\u2190 Ioi_inter_Iio]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' Ioo \u2191x \u22a4 = Ioi x"}, {"line": "rw [\u2190 Ioi_inter_Iio]", "tactic_state": "x : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' (Ioi \u2191x \u2229 Iio \u22a4) = Ioi x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_coe_Ioc_bot (y : \u211d) : Real.toEReal \u207b\u00b9' Ioc \u22a5 y = Iic y := by\n  rw [\u2190 Ioi_inter_Iic]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' Ioc \u22a5 \u2191y = Iic y"}, {"line": "rw [\u2190 Ioi_inter_Iic]", "tactic_state": "y : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' (Ioi \u22a5 \u2229 Iic \u2191y) = Iic y"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_coe_Ioo_bot (y : \u211d) : Real.toEReal \u207b\u00b9' Ioo \u22a5 y = Iio y := by\n  rw [\u2190 Ioi_inter_Iio]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' Ioo \u22a5 \u2191y = Iio y"}, {"line": "rw [\u2190 Ioi_inter_Iio]", "tactic_state": "y : \u211d\n\u22a2 Real.toEReal \u207b\u00b9' (Ioi \u22a5 \u2229 Iio \u2191y) = Iio y"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_coe_Ioo_bot_top : Real.toEReal \u207b\u00b9' Ioo \u22a5 \u22a4 = univ := by\n  rw [\u2190 Ioi_inter_Iio]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Real.toEReal \u207b\u00b9' Ioo \u22a5 \u22a4 = univ"}, {"line": "rw [\u2190 Ioi_inter_Iio]", "tactic_state": "\u22a2 Real.toEReal \u207b\u00b9' (Ioi \u22a5 \u2229 Iio \u22a4) = univ"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_ennreal_add (x y : ENNReal) : ((x + y : \u211d\u22650\u221e) : EReal) = x + y := by\n  cases x <;> cases y <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : ENNReal\n\u22a2 \u2191(x + y) = \u2191x + \u2191y"}, {"line": "cases x <;> cases y <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toENNReal_eq_top_iff {x : EReal} : x.toENNReal = \u22a4 \u2194 x = \u22a4 := by\n  by_cases h : x = \u22a4\n  \u00b7 simp [h]\n  \u00b7 simp [h, toENNReal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\n\u22a2 x.toENNReal = \u22a4 \u2194 x = \u22a4"}, {"line": "by_cases h : x = \u22a4", "tactic_state": "case pos\nx : EReal\nh : x = \u22a4\n\u22a2 x.toENNReal = \u22a4 \u2194 x = \u22a4\n---\ncase neg\nx : EReal\nh : \u00acx = \u22a4\n\u22a2 x.toENNReal = \u22a4 \u2194 x = \u22a4"}, {"line": "\u00b7 simp [h]", "tactic_state": "case neg\nx : EReal\nh : \u00acx = \u22a4\n\u22a2 x.toENNReal = \u22a4 \u2194 x = \u22a4"}, {"line": "\u00b7 simp [h, toENNReal]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toENNReal_eq_zero_iff {x : EReal} : x.toENNReal = 0 \u2194 x \u2264 0 := by\n  induction x <;> simp [toENNReal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\n\u22a2 x.toENNReal = 0 \u2194 x \u2264 0"}, {"line": "induction x <;> simp [toENNReal]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toENNReal_ne_zero_iff {x : EReal} : x.toENNReal \u2260 0 \u2194 0 < x := by\n  simp [toENNReal_eq_zero_iff.not]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\n\u22a2 x.toENNReal \u2260 0 \u2194 0 < x"}, {"line": "simp [toENNReal_eq_zero_iff.not]", "tactic_state": "x : EReal\n\u22a2 \u00acx.toENNReal = 0 \u2194 0 < x"}]}
{"declaration": "lemma coe_toENNReal_eq_max {x : EReal} : x.toENNReal = max 0 x := by\n  rcases le_total 0 x with (hx | hx)\n  \u00b7 rw [coe_toENNReal hx, max_eq_right hx]\n  \u00b7 rw [toENNReal_of_nonpos hx, max_eq_left hx, coe_ennreal_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\n\u22a2 \u2191x.toENNReal = max 0 x"}, {"line": "rcases le_total 0 x with (hx | hx)", "tactic_state": "case inl\nx : EReal\nhx : 0 \u2264 x\n\u22a2 \u2191x.toENNReal = max 0 x\n---\ncase inr\nx : EReal\nhx : x \u2264 0\n\u22a2 \u2191x.toENNReal = max 0 x"}, {"line": "\u00b7 rw [coe_toENNReal hx, max_eq_right hx]", "tactic_state": "case inr\nx : EReal\nhx : x \u2264 0\n\u22a2 \u2191x.toENNReal = max 0 x"}, {"line": "\u00b7 rw [toENNReal_of_nonpos hx, max_eq_left hx, coe_ennreal_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toReal_toENNReal {x : EReal} (hx : 0 \u2264 x) : x.toENNReal.toReal = x.toReal := by\n  by_cases h : x = \u22a4\n  \u00b7 simp [h]\n  \u00b7 simp [h, toReal_nonneg hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\nhx : 0 \u2264 x\n\u22a2 x.toENNReal.toReal = x.toReal"}, {"line": "by_cases h : x = \u22a4", "tactic_state": "case pos\nx : EReal\nhx : 0 \u2264 x\nh : x = \u22a4\n\u22a2 x.toENNReal.toReal = x.toReal\n---\ncase neg\nx : EReal\nhx : 0 \u2264 x\nh : \u00acx = \u22a4\n\u22a2 x.toENNReal.toReal = x.toReal"}, {"line": "\u00b7 simp [h]", "tactic_state": "case neg\nx : EReal\nhx : 0 \u2264 x\nh : \u00acx = \u22a4\n\u22a2 x.toENNReal.toReal = x.toReal"}, {"line": "\u00b7 simp [h, toReal_nonneg hx]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toENNReal_eq_toENNReal {x y : EReal} (hx : 0 \u2264 x) (hy : 0 \u2264 y) :\n    x.toENNReal = y.toENNReal \u2194 x = y := by\n  induction x <;> induction y <;> simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Basic.lean", "context": {"open": ["Function ENNReal NNReal Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : EReal\nhx : 0 \u2264 x\nhy : 0 \u2264 y\n\u22a2 x.toENNReal = y.toENNReal \u2194 x = y"}, {"line": "induction x <;> induction y <;> simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_eq_zero_iff {x : EReal} : x.abs = 0 \u2194 x = 0 := by\n  induction x\n  \u00b7 simp only [abs_bot, ENNReal.top_ne_zero, bot_ne_zero]\n  \u00b7 simp only [abs_def, coe_eq_zero, ENNReal.ofReal_eq_zero, abs_nonpos_iff]\n  \u00b7 simp only [abs_top, ENNReal.top_ne_zero, top_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Inv.lean", "context": {"open": ["ENNReal Set SignType"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\n\u22a2 x.abs = 0 \u2194 x = 0"}, {"line": "induction x", "tactic_state": "case bot\n\u22a2 \u22a5.abs = 0 \u2194 \u22a5 = 0\n---\ncase coe\na\u271d : \u211d\n\u22a2 (\u2191a\u271d).abs = 0 \u2194 \u2191a\u271d = 0\n---\ncase top\n\u22a2 \u22a4.abs = 0 \u2194 \u22a4 = 0"}, {"line": "\u00b7 simp only [abs_bot, ENNReal.top_ne_zero, bot_ne_zero]", "tactic_state": "case coe\na\u271d : \u211d\n\u22a2 (\u2191a\u271d).abs = 0 \u2194 \u2191a\u271d = 0\n---\ncase top\n\u22a2 \u22a4.abs = 0 \u2194 \u22a4 = 0"}, {"line": "\u00b7 simp only [abs_def, coe_eq_zero, ENNReal.ofReal_eq_zero, abs_nonpos_iff]", "tactic_state": "case top\n\u22a2 \u22a4.abs = 0 \u2194 \u22a4 = 0"}, {"line": "\u00b7 simp only [abs_top, ENNReal.top_ne_zero, top_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sign_coe (x : \u211d) : sign (x : EReal) = sign x := by\n  simp only [sign]\n  simp only [OrderHom.coe_mk]\n  simp only [EReal.coe_pos]\n  simp only [EReal.coe_neg']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Inv.lean", "context": {"open": ["ENNReal Set SignType", "SignType (sign)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 sign \u2191x = sign x"}, {"line": "simp only [sign]", "tactic_state": "x : \u211d\n\u22a2 { toFun := fun a => if 0 < a then 1 else if a < 0 then -1 else 0, monotone' := \u22ef } \u2191x =\n    { toFun := fun a => if 0 < a then 1 else if a < 0 then -1 else 0, monotone' := \u22ef } x"}, {"line": "simp only [OrderHom.coe_mk]", "tactic_state": "x : \u211d\n\u22a2 (if 0 < \u2191x then 1 else if \u2191x < 0 then -1 else 0) = if 0 < x then 1 else if x < 0 then -1 else 0"}, {"line": "simp only [EReal.coe_pos]", "tactic_state": "x : \u211d\n\u22a2 (if 0 < x then 1 else if \u2191x < 0 then -1 else 0) = if 0 < x then 1 else if x < 0 then -1 else 0"}, {"line": "simp only [EReal.coe_neg']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_coe_sign (x : SignType) : ((x : \u211d) : EReal) = x := by cases x <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Inv.lean", "context": {"open": ["ENNReal Set SignType", "SignType (sign)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : SignType\n\u22a2 \u2191\u2191x = \u2191x"}, {"line": "cases x <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma min_neg_neg (x y : EReal) : min (-x) (-y) = -max x y := by\n  rcases le_total x y with (h | h) <;> simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Inv.lean", "context": {"open": ["ENNReal Set SignType", "SignType (sign)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : EReal\n\u22a2 min (-x) (-y) = -max x y"}, {"line": "rcases le_total x y with (h | h) <;> simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "lemma max_neg_neg (x y : EReal) : max (-x) (-y) = -min x y := by\n  rcases le_total x y with (h | h) <;> simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Inv.lean", "context": {"open": ["ENNReal Set SignType", "SignType (sign)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : EReal\n\u22a2 max (-x) (-y) = -min x y"}, {"line": "rcases le_total x y with (h | h) <;> simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_div (a b c : EReal) : a * (b / c) = (a * b) / c := by\n  change a * (b * c\u207b\u00b9) = (a * b) * c\u207b\u00b9\n  rw [mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Inv.lean", "context": {"open": ["ENNReal Set SignType", "SignType (sign)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : EReal\n\u22a2 a * (b / c) = a * b / c"}, {"line": "change a * (b * c\u207b\u00b9) = (a * b) * c\u207b\u00b9", "tactic_state": "a b c : EReal\n\u22a2 a * (b * c\u207b\u00b9) = a * b * c\u207b\u00b9"}, {"line": "rw [mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_div_right (a b c : EReal) : a / b * c = a * c / b := by\n  rw [mul_comm]\n  rw [EReal.mul_div]\n  rw [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Inv.lean", "context": {"open": ["ENNReal Set SignType", "SignType (sign)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : EReal\n\u22a2 a / b * c = a * c / b"}, {"line": "rw [mul_comm]", "tactic_state": "a b c : EReal\n\u22a2 c * (a / b) = a * c / b"}, {"line": "rw [EReal.mul_div]", "tactic_state": "a b c : EReal\n\u22a2 c * a / b = a * c / b"}, {"line": "rw [mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_div_left_comm (a b c : EReal) : a * (b / c) = b * (a / c) := by\n  rw [mul_div a b c]\n  rw [mul_comm a b]\n  rw [\u2190 mul_div b a c]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Inv.lean", "context": {"open": ["ENNReal Set SignType", "SignType (sign)"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : EReal\n\u22a2 a * (b / c) = b * (a / c)"}, {"line": "rw [mul_div a b c]", "tactic_state": "a b c : EReal\n\u22a2 a * b / c = b * (a / c)"}, {"line": "rw [mul_comm a b]", "tactic_state": "a b c : EReal\n\u22a2 b * a / c = b * (a / c)"}, {"line": "rw [\u2190 mul_div b a c]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma div_eq_iff (hbot : b \u2260 \u22a5) (htop : b \u2260 \u22a4) (hzero : b \u2260 0) : c / b = a \u2194 c = a * b := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 rw [\u2190 @mul_div_cancel c b hbot htop hzero, h, mul_comm a b]\n  \u00b7 rw [h, mul_comm a b, \u2190 mul_div b a b, @mul_div_cancel a b hbot htop hzero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Inv.lean", "context": {"open": ["ENNReal Set SignType", "SignType (sign)"], "variables": ["{a b c : EReal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : EReal\nhbot : b \u2260 \u22a5\nhtop : b \u2260 \u22a4\nhzero : b \u2260 0\n\u22a2 c / b = a \u2194 c = a * b"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9", "tactic_state": "case refine_1\na b c : EReal\nhbot : b \u2260 \u22a5\nhtop : b \u2260 \u22a4\nhzero : b \u2260 0\nh : c / b = a\n\u22a2 c = a * b\n---\ncase refine_2\na b c : EReal\nhbot : b \u2260 \u22a5\nhtop : b \u2260 \u22a4\nhzero : b \u2260 0\nh : c = a * b\n\u22a2 c / b = a"}, {"line": "\u00b7 rw [\u2190 @mul_div_cancel c b hbot htop hzero, h, mul_comm a b]", "tactic_state": "case refine_2\na b c : EReal\nhbot : b \u2260 \u22a5\nhtop : b \u2260 \u22a4\nhzero : b \u2260 0\nh : c = a * b\n\u22a2 c / b = a"}, {"line": "\u00b7 rw [h, mul_comm a b, \u2190 mul_div b a b, @mul_div_cancel a b hbot htop hzero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictAnti_div_right_of_neg (h : b < 0) (h' : b \u2260 \u22a5) : StrictAnti fun a \u21a6 a / b := by\n  intro a a' a_lt_a'\n  simp only\n  apply lt_of_le_of_ne <| div_le_div_right_of_nonpos (le_of_lt h) (le_of_lt a_lt_a')\n  intro hyp\n  apply ne_of_lt a_lt_a'\n  rw [\u2190 @EReal.mul_div_cancel a b h' (ne_top_of_lt h) (ne_of_lt h)]\n  rw [\u2190 hyp]\n  rw [@EReal.mul_div_cancel a' b h' (ne_top_of_lt h) (ne_of_lt h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Inv.lean", "context": {"open": ["ENNReal Set SignType", "SignType (sign)"], "variables": ["{a b c : EReal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : EReal\nh : b < 0\nh' : b \u2260 \u22a5\n\u22a2 StrictAnti fun a => a / b"}, {"line": "intro a a' a_lt_a'", "tactic_state": "b : EReal\nh : b < 0\nh' : b \u2260 \u22a5\na a' : EReal\na_lt_a' : a < a'\n\u22a2 (fun a => a / b) a' < (fun a => a / b) a"}, {"line": "simp only", "tactic_state": "b : EReal\nh : b < 0\nh' : b \u2260 \u22a5\na a' : EReal\na_lt_a' : a < a'\n\u22a2 a' / b < a / b"}, {"line": "apply lt_of_le_of_ne <| div_le_div_right_of_nonpos (le_of_lt h) (le_of_lt a_lt_a')", "tactic_state": "b : EReal\nh : b < 0\nh' : b \u2260 \u22a5\na a' : EReal\na_lt_a' : a < a'\n\u22a2 a' / b \u2260 a / b"}, {"line": "intro hyp", "tactic_state": "b : EReal\nh : b < 0\nh' : b \u2260 \u22a5\na a' : EReal\na_lt_a' : a < a'\nhyp : a' / b = a / b\n\u22a2 False"}, {"line": "apply ne_of_lt a_lt_a'", "tactic_state": "b : EReal\nh : b < 0\nh' : b \u2260 \u22a5\na a' : EReal\na_lt_a' : a < a'\nhyp : a' / b = a / b\n\u22a2 a = a'"}, {"line": "rw [\u2190 @EReal.mul_div_cancel a b h' (ne_top_of_lt h) (ne_of_lt h)]", "tactic_state": "b : EReal\nh : b < 0\nh' : b \u2260 \u22a5\na a' : EReal\na_lt_a' : a < a'\nhyp : a' / b = a / b\n\u22a2 b * (a / b) = a'"}, {"line": "rw [\u2190 hyp]", "tactic_state": "b : EReal\nh : b < 0\nh' : b \u2260 \u22a5\na a' : EReal\na_lt_a' : a < a'\nhyp : a' / b = a / b\n\u22a2 b * (a' / b) = a'"}, {"line": "rw [@EReal.mul_div_cancel a' b h' (ne_top_of_lt h) (ne_of_lt h)]", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma exists_lt_mul_right_of_nonneg (ha : 0 \u2264 a) (hc : 0 \u2264 c) (h : c < a * b) :\n    \u2203 b' \u2208 Ioo 0 b, c < a * b' := by\n  have hb : 0 < b := pos_of_mul_pos_right (hc.trans_lt h) ha\n  simp_rw [mul_comm a] at h \u22a2\n  exact exists_lt_mul_left_of_nonneg hb.le hc h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Inv.lean", "context": {"open": ["ENNReal Set SignType", "SignType (sign)"], "variables": ["{a b c : EReal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : EReal\nha : 0 \u2264 a\nhc : 0 \u2264 c\nh : c < a * b\n\u22a2 \u2203 b' \u2208 Ioo 0 b, c < a * b'"}, {"line": "have hb : 0 < b := pos_of_mul_pos_right (hc.trans_lt h) ha", "tactic_state": "a b c : EReal\nha : 0 \u2264 a\nhc : 0 \u2264 c\nh : c < a * b\nhb : 0 < b\n\u22a2 \u2203 b' \u2208 Ioo 0 b, c < a * b'"}, {"line": "simp_rw [mul_comm a] at h \u22a2", "tactic_state": "a b c : EReal\nha : 0 \u2264 a\nhc : 0 \u2264 c\nhb : 0 < b\nh : c < b * a\n\u22a2 \u2203 b' \u2208 Ioo 0 b, c < b' * a"}, {"line": "exact exists_lt_mul_left_of_nonneg hb.le hc h", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma exists_mul_right_lt (h\u2081 : 0 < a \u2228 b \u2260 \u22a4) (h\u2082 : a \u2260 \u22a4 \u2228 b \u2260 0) (hc : a * b < c) :\n    \u2203 b' \u2208 Ioo b \u22a4, a * b' < c := by\n  simp_rw [mul_comm a] at hc \u22a2\n  exact exists_mul_left_lt h\u2082.symm h\u2081.symm hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Inv.lean", "context": {"open": ["ENNReal Set SignType", "SignType (sign)"], "variables": ["{a b c : EReal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : EReal\nh\u2081 : 0 < a \u2228 b \u2260 \u22a4\nh\u2082 : a \u2260 \u22a4 \u2228 b \u2260 0\nhc : a * b < c\n\u22a2 \u2203 b' \u2208 Ioo b \u22a4, a * b' < c"}, {"line": "simp_rw [mul_comm a] at hc \u22a2", "tactic_state": "a b c : EReal\nh\u2081 : 0 < a \u2228 b \u2260 \u22a4\nh\u2082 : a \u2260 \u22a4 \u2228 b \u2260 0\nhc : b * a < c\n\u22a2 \u2203 b' \u2208 Ioo b \u22a4, b' * a < c"}, {"line": "exact exists_mul_left_lt h\u2082.symm h\u2081.symm hc", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_div_of_nonneg_right (h : 0 \u2264 c) :\n    (a + b) / c = a / c + b / c := by\n  apply right_distrib_of_nonneg_of_ne_top (inv_nonneg_of_nonneg h) (inv_lt_top c).ne\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Inv.lean", "context": {"open": ["ENNReal Set SignType", "SignType (sign)"], "variables": ["{a b c : EReal}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : EReal\nh : 0 \u2264 c\n\u22a2 (a + b) / c = a / c + b / c"}, {"line": "apply right_distrib_of_nonneg_of_ne_top (inv_nonneg_of_nonneg h) (inv_lt_top c).ne", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bot_lt_add_iff {x y : EReal} : \u22a5 < x + y \u2194 \u22a5 < x \u2227 \u22a5 < y := by\n  simp [bot_lt_iff_ne_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : EReal\n\u22a2 \u22a5 < x + y \u2194 \u22a5 < x \u2227 \u22a5 < y"}, {"line": "simp [bot_lt_iff_ne_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem top_add_of_ne_bot {x : EReal} (h : x \u2260 \u22a5) : \u22a4 + x = \u22a4 := by\n  induction x\n  \u00b7 exfalso; exact h (Eq.refl \u22a5)\n  \u00b7 exact top_add_coe _\n  \u00b7 exact top_add_top\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\nh : x \u2260 \u22a5\n\u22a2 \u22a4 + x = \u22a4"}, {"line": "induction x", "tactic_state": "case bot\nh : \u22a5 \u2260 \u22a5\n\u22a2 \u22a4 + \u22a5 = \u22a4\n---\ncase coe\na\u271d : \u211d\nh : \u2191a\u271d \u2260 \u22a5\n\u22a2 \u22a4 + \u2191a\u271d = \u22a4\n---\ncase top\nh : \u22a4 \u2260 \u22a5\n\u22a2 \u22a4 + \u22a4 = \u22a4"}, {"line": "\u00b7 exfalso; exact h (Eq.refl \u22a5)", "tactic_state": "case coe\na\u271d : \u211d\nh : \u2191a\u271d \u2260 \u22a5\n\u22a2 \u22a4 + \u2191a\u271d = \u22a4\n---\ncase top\nh : \u22a4 \u2260 \u22a5\n\u22a2 \u22a4 + \u22a4 = \u22a4"}, {"line": "\u00b7 exact top_add_coe _", "tactic_state": "case top\nh : \u22a4 \u2260 \u22a5\n\u22a2 \u22a4 + \u22a4 = \u22a4"}, {"line": "\u00b7 exact top_add_top", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toENNReal_add_le {x y : EReal} : (x + y).toENNReal \u2264 x.toENNReal + y.toENNReal := by\n  induction x <;> induction y <;> try {\u00b7 simp}\n  exact ENNReal.ofReal_add_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : EReal\n\u22a2 (x + y).toENNReal \u2264 x.toENNReal + y.toENNReal"}, {"line": "induction x <;> induction y <;> try {\u00b7 simp}", "tactic_state": "case coe.coe\na\u271d\u00b9 a\u271d : \u211d\n\u22a2 (\u2191a\u271d\u00b9 + \u2191a\u271d).toENNReal \u2264 (\u2191a\u271d\u00b9).toENNReal + (\u2191a\u271d).toENNReal"}, {"line": "exact ENNReal.ofReal_add_le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_lt_add_left_coe {x y : EReal} (h : x < y) (z : \u211d) : (z : EReal) + x < z + y := by\n  simpa [add_comm] using add_lt_add_right_coe h z\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : EReal\nh : x < y\nz : \u211d\n\u22a2 \u2191z + x < \u2191z + y"}, {"line": "simpa [add_comm] using add_lt_add_right_coe h z", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_ne_top_iff_ne_top_left {x y : EReal} (hy : y \u2260 \u22a5) (hy' : y \u2260 \u22a4) :\n    x + y \u2260 \u22a4 \u2194 x \u2260 \u22a4 := by\n  cases x <;> simp [add_ne_top_iff_ne_top\u2082, hy, hy']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : EReal\nhy : y \u2260 \u22a5\nhy' : y \u2260 \u22a4\n\u22a2 x + y \u2260 \u22a4 \u2194 x \u2260 \u22a4"}, {"line": "cases x <;> simp [add_ne_top_iff_ne_top\u2082, hy, hy']", "tactic_state": "case coe\ny : EReal\nhy : y \u2260 \u22a5\nhy' : y \u2260 \u22a4\na\u271d : \u211d\n\u22a2 \u00ac\u2191a\u271d + y = \u22a4"}]}
{"declaration": "lemma add_ne_top_iff_of_ne_bot {x y : EReal} (hx : x \u2260 \u22a5) (hy : y \u2260 \u22a5) :\n    x + y \u2260 \u22a4 \u2194 x \u2260 \u22a4 \u2227 y \u2260 \u22a4 := by\n  refine \u27e8?_, fun h \u21a6 add_ne_top h.1 h.2\u27e9\n  induction x <;> simp_all\n  induction y <;> simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : EReal\nhx : x \u2260 \u22a5\nhy : y \u2260 \u22a5\n\u22a2 x + y \u2260 \u22a4 \u2194 x \u2260 \u22a4 \u2227 y \u2260 \u22a4"}, {"line": "refine \u27e8?_, fun h \u21a6 add_ne_top h.1 h.2\u27e9", "tactic_state": "x y : EReal\nhx : x \u2260 \u22a5\nhy : y \u2260 \u22a5\n\u22a2 x + y \u2260 \u22a4 \u2192 x \u2260 \u22a4 \u2227 y \u2260 \u22a4"}, {"line": "induction x <;> simp_all", "tactic_state": "case coe\ny : EReal\na\u271d : \u211d\nhy : \u00acy = \u22a5\n\u22a2 \u00ac\u2191a\u271d + y = \u22a4 \u2192 \u00acy = \u22a4"}, {"line": "induction y <;> simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_ne_top_iff_of_ne_bot_of_ne_top {x y : EReal} (hy : y \u2260 \u22a5) (hy' : y \u2260 \u22a4) :\n    x + y \u2260 \u22a4 \u2194 x \u2260 \u22a4 := by\n  induction x <;> simp [add_ne_top_iff_of_ne_bot, hy, hy']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : EReal\nhy : y \u2260 \u22a5\nhy' : y \u2260 \u22a4\n\u22a2 x + y \u2260 \u22a4 \u2194 x \u2260 \u22a4"}, {"line": "induction x <;> simp [add_ne_top_iff_of_ne_bot, hy, hy']", "tactic_state": "case coe\ny : EReal\nhy : y \u2260 \u22a5\nhy' : y \u2260 \u22a4\na\u271d : \u211d\n\u22a2 \u00ac\u2191a\u271d + y = \u22a4"}]}
{"declaration": "lemma sub_bot {x : EReal} (h : x \u2260 \u22a5) : x - \u22a5 = \u22a4 := by\n  cases x <;> tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\nh : x \u2260 \u22a5\n\u22a2 x - \u22a5 = \u22a4"}, {"line": "cases x <;> tauto", "tactic_state": "No Goals!"}]}
{"declaration": "lemma top_sub {x : EReal} (hx : x \u2260 \u22a4) : \u22a4 - x = \u22a4 := by\n  cases x <;> tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\nhx : x \u2260 \u22a4\n\u22a2 \u22a4 - x = \u22a4"}, {"line": "cases x <;> tauto", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub_self {x : EReal} (h_top : x \u2260 \u22a4) (h_bot : x \u2260 \u22a5) : x - x = 0 := by\n  cases x <;> simp_all [\u2190 coe_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\nh_top : x \u2260 \u22a4\nh_bot : x \u2260 \u22a5\n\u22a2 x - x = 0"}, {"line": "cases x <;> simp_all [\u2190 coe_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub_self_le_zero {x : EReal} : x - x \u2264 0 := by\n  cases x <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\n\u22a2 x - x \u2264 0"}, {"line": "cases x <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub_nonneg {x y : EReal} (h_top : x \u2260 \u22a4 \u2228 y \u2260 \u22a4) (h_bot : x \u2260 \u22a5 \u2228 y \u2260 \u22a5) :\n    0 \u2264 x - y \u2194 y \u2264 x := by\n  cases x <;> cases y <;> simp_all [\u2190 EReal.coe_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : EReal\nh_top : x \u2260 \u22a4 \u2228 y \u2260 \u22a4\nh_bot : x \u2260 \u22a5 \u2228 y \u2260 \u22a5\n\u22a2 0 \u2264 x - y \u2194 y \u2264 x"}, {"line": "cases x <;> cases y <;> simp_all [\u2190 EReal.coe_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub_nonpos {x y : EReal} : x - y \u2264 0 \u2194 x \u2264 y := by\n  cases x <;> cases y <;> simp [\u2190 EReal.coe_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : EReal\n\u22a2 x - y \u2264 0 \u2194 x \u2264 y"}, {"line": "cases x <;> cases y <;> simp [\u2190 EReal.coe_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub_pos {x y : EReal} : 0 < x - y \u2194 y < x := by\n  cases x <;> cases y <;> simp [\u2190 EReal.coe_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : EReal\n\u22a2 0 < x - y \u2194 y < x"}, {"line": "cases x <;> cases y <;> simp [\u2190 EReal.coe_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub_neg {x y : EReal} (h_top : x \u2260 \u22a4 \u2228 y \u2260 \u22a4) (h_bot : x \u2260 \u22a5 \u2228 y \u2260 \u22a5) :\n    x - y < 0 \u2194 x < y := by\n  cases x <;> cases y <;> simp_all [\u2190 EReal.coe_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : EReal\nh_top : x \u2260 \u22a4 \u2228 y \u2260 \u22a4\nh_bot : x \u2260 \u22a5 \u2228 y \u2260 \u22a5\n\u22a2 x - y < 0 \u2194 x < y"}, {"line": "cases x <;> cases y <;> simp_all [\u2190 EReal.coe_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_sub_cancel_right {a : EReal} {b : Real} : a + b - b = a := by\n  cases a <;> norm_cast\n  exact _root_.add_sub_cancel_right _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : EReal\nb : \u211d\n\u22a2 a + \u2191b - \u2191b = a"}, {"line": "cases a <;> norm_cast", "tactic_state": "case coe\nb a\u271d : \u211d\n\u22a2 a\u271d + b - b = a\u271d"}, {"line": "exact _root_.add_sub_cancel_right _ _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_sub_cancel_left {a : EReal} {b : Real} : b + a - b = a := by\n  rw [add_comm]\n  rw [EReal.add_sub_cancel_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : EReal\nb : \u211d\n\u22a2 \u2191b + a - \u2191b = a"}, {"line": "rw [add_comm]", "tactic_state": "a : EReal\nb : \u211d\n\u22a2 a + \u2191b - \u2191b = a"}, {"line": "rw [EReal.add_sub_cancel_right]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub_add_cancel_right {a : EReal} {b : Real} : b - (a + b) = -a := by\n  cases a <;> norm_cast\n  exact _root_.sub_add_cancel_right _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : EReal\nb : \u211d\n\u22a2 \u2191b - (a + \u2191b) = -a"}, {"line": "cases a <;> norm_cast", "tactic_state": "case coe\nb a\u271d : \u211d\n\u22a2 b - (a\u271d + b) = -a\u271d"}, {"line": "exact _root_.sub_add_cancel_right _ _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub_le_iff_le_add {a b c : EReal} (h\u2081 : b \u2260 \u22a5 \u2228 c \u2260 \u22a4) (h\u2082 : b \u2260 \u22a4 \u2228 c \u2260 \u22a5) :\n    a - b \u2264 c \u2194 a \u2264 c + b := by\n  suffices a + (-b) \u2264 c \u2194 a \u2264 c - (-b) by simpa [sub_eq_add_neg]\n  refine (le_sub_iff_add_le ?_ ?_).symm <;> simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : EReal\nh\u2081 : b \u2260 \u22a5 \u2228 c \u2260 \u22a4\nh\u2082 : b \u2260 \u22a4 \u2228 c \u2260 \u22a5\n\u22a2 a - b \u2264 c \u2194 a \u2264 c + b"}, {"line": "suffices a + (-b) \u2264 c \u2194 a \u2264 c - (-b) by simpa [sub_eq_add_neg]", "tactic_state": "a b c : EReal\nh\u2081 : b \u2260 \u22a5 \u2228 c \u2260 \u22a4\nh\u2082 : b \u2260 \u22a4 \u2228 c \u2260 \u22a5\n\u22a2 a + -b \u2264 c \u2194 a \u2264 c - -b"}, {"line": "refine (le_sub_iff_add_le ?_ ?_).symm <;> simpa", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_le_of_le_sub {a b c : EReal} (h : a \u2264 b - c) : a + c \u2264 b := by\n  rw [\u2190 neg_neg c]\n  exact sub_le_of_le_add h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : EReal\nh : a \u2264 b - c\n\u22a2 a + c \u2264 b"}, {"line": "rw [\u2190 neg_neg c]", "tactic_state": "a b c : EReal\nh : a \u2264 b - c\n\u22a2 a + - -c \u2264 b"}, {"line": "exact sub_le_of_le_add h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_lt_of_lt_sub {a b c : EReal} (h : a < b - c) : a + c < b := by\n  contrapose! h\n  exact sub_le_of_le_add h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : EReal\nh : a < b - c\n\u22a2 a + c < b"}, {"line": "contrapose! h", "tactic_state": "a b c : EReal\nh : b \u2264 a + c\n\u22a2 b - c \u2264 a"}, {"line": "exact sub_le_of_le_add h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_of_forall_lt_iff_le {x y : EReal} : (\u2200 z : \u211d, x < z \u2192 y \u2264 z) \u2194 y \u2264 x := by\n  refine \u27e8fun h \u21a6 WithBot.le_of_forall_lt_iff_le.1 ?_, fun h _ x_z \u21a6 h.trans x_z.le\u27e9\n  rw [WithTop.forall]\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : EReal\n\u22a2 (\u2200 (z : \u211d), x < \u2191z \u2192 y \u2264 \u2191z) \u2194 y \u2264 x"}, {"line": "refine \u27e8fun h \u21a6 WithBot.le_of_forall_lt_iff_le.1 ?_, fun h _ x_z \u21a6 h.trans x_z.le\u27e9", "tactic_state": "x y : EReal\nh : \u2200 (z : \u211d), x < \u2191z \u2192 y \u2264 \u2191z\n\u22a2 \u2200 (z : WithTop \u211d), x < \u2191z \u2192 y \u2264 \u2191z"}, {"line": "rw [WithTop.forall]", "tactic_state": "x y : EReal\nh : \u2200 (z : \u211d), x < \u2191z \u2192 y \u2264 \u2191z\n\u22a2 (x < \u2191\u22a4 \u2192 y \u2264 \u2191\u22a4) \u2227 \u2200 (x_1 : \u211d), x < \u2191\u2191x_1 \u2192 y \u2264 \u2191\u2191x_1"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ge_of_forall_gt_iff_ge {x y : EReal} : (\u2200 z : \u211d, z < y \u2192 z \u2264 x) \u2194 y \u2264 x := by\n  refine \u27e8fun h \u21a6 WithBot.ge_of_forall_gt_iff_ge.1 ?_, fun h _ x_z \u21a6 x_z.le.trans h\u27e9\n  rw [WithTop.forall]\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : EReal\n\u22a2 (\u2200 (z : \u211d), \u2191z < y \u2192 \u2191z \u2264 x) \u2194 y \u2264 x"}, {"line": "refine \u27e8fun h \u21a6 WithBot.ge_of_forall_gt_iff_ge.1 ?_, fun h _ x_z \u21a6 x_z.le.trans h\u27e9", "tactic_state": "x y : EReal\nh : \u2200 (z : \u211d), \u2191z < y \u2192 \u2191z \u2264 x\n\u22a2 \u2200 (z : WithTop \u211d), \u2191z < y \u2192 \u2191z \u2264 x"}, {"line": "rw [WithTop.forall]", "tactic_state": "x y : EReal\nh : \u2200 (z : \u211d), \u2191z < y \u2192 \u2191z \u2264 x\n\u22a2 (\u2191\u22a4 < y \u2192 \u2191\u22a4 \u2264 x) \u2227 \u2200 (x_1 : \u211d), \u2191\u2191x_1 < y \u2192 \u2191\u2191x_1 \u2264 x"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma top_mul_of_pos {x : EReal} (h : 0 < x) : \u22a4 * x = \u22a4 := by\n  rw [EReal.mul_comm]\n  exact mul_top_of_pos h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\nh : 0 < x\n\u22a2 \u22a4 * x = \u22a4"}, {"line": "rw [EReal.mul_comm]", "tactic_state": "x : EReal\nh : 0 < x\n\u22a2 x * \u22a4 = \u22a4"}, {"line": "exact mul_top_of_pos h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma top_mul_of_neg {x : EReal} (h : x < 0) : \u22a4 * x = \u22a5 := by\n  rw [EReal.mul_comm]\n  exact mul_top_of_neg h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\nh : x < 0\n\u22a2 \u22a4 * x = \u22a5"}, {"line": "rw [EReal.mul_comm]", "tactic_state": "x : EReal\nh : x < 0\n\u22a2 x * \u22a4 = \u22a5"}, {"line": "exact mul_top_of_neg h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma bot_mul_of_pos {x : EReal} (h : 0 < x) : \u22a5 * x = \u22a5 := by\n  rw [EReal.mul_comm]\n  exact mul_bot_of_pos h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\nh : 0 < x\n\u22a2 \u22a5 * x = \u22a5"}, {"line": "rw [EReal.mul_comm]", "tactic_state": "x : EReal\nh : 0 < x\n\u22a2 x * \u22a5 = \u22a5"}, {"line": "exact mul_bot_of_pos h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma bot_mul_of_neg {x : EReal} (h : x < 0) : \u22a5 * x = \u22a4 := by\n  rw [EReal.mul_comm]\n  exact mul_bot_of_neg h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\nh : x < 0\n\u22a2 \u22a5 * x = \u22a4"}, {"line": "rw [EReal.mul_comm]", "tactic_state": "x : EReal\nh : x < 0\n\u22a2 x * \u22a5 = \u22a4"}, {"line": "exact mul_bot_of_neg h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma right_distrib_of_nonneg {a b c : EReal} (ha : 0 \u2264 a) (hb : 0 \u2264 b) :\n    (a + b) * c = a * c + b * c := by\n  rcases eq_or_lt_of_le ha with (rfl | a_pos)\n  \u00b7 simp\n  rcases eq_or_lt_of_le hb with (rfl | b_pos)\n  \u00b7 simp\n  rcases lt_trichotomy c 0 with (c_neg | rfl | c_pos)\n  \u00b7 induction c\n    \u00b7 rw [mul_bot_of_pos a_pos, mul_bot_of_pos b_pos, mul_bot_of_pos (add_pos a_pos b_pos),\n        add_bot \u22a5]\n    \u00b7 induction a\n      \u00b7 exfalso; exact not_lt_bot a_pos\n      \u00b7 induction b\n        \u00b7 norm_cast\n        \u00b7 norm_cast; exact right_distrib _ _ _\n        \u00b7 norm_cast\n          rw [add_top_of_ne_bot (coe_ne_bot _)]\n          rw [top_mul_of_neg c_neg]\n          rw [add_bot]\n      \u00b7 rw [top_add_of_ne_bot (ne_bot_of_gt b_pos), top_mul_of_neg c_neg, bot_add]\n    \u00b7 exfalso; exact not_top_lt c_neg\n  \u00b7 simp\n  \u00b7 induction c\n    \u00b7 exfalso; exact not_lt_bot c_pos\n    \u00b7 induction a\n      \u00b7 exfalso; exact not_lt_bot a_pos\n      \u00b7 induction b\n        \u00b7 norm_cast\n        \u00b7 norm_cast; exact right_distrib _ _ _\n        \u00b7 norm_cast\n          rw [add_top_of_ne_bot (coe_ne_bot _)]\n          rw [top_mul_of_pos c_pos]\n          rw [add_top_of_ne_bot (coe_ne_bot _)]\n      \u00b7 rw [top_add_of_ne_bot (ne_bot_of_gt b_pos), top_mul_of_pos c_pos,\n          top_add_of_ne_bot (ne_bot_of_gt (mul_pos b_pos c_pos))]\n    \u00b7 rw [mul_top_of_pos a_pos, mul_top_of_pos b_pos, mul_top_of_pos (add_pos a_pos b_pos),\n        top_add_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : EReal\nha : 0 \u2264 a\nhb : 0 \u2264 b\n\u22a2 (a + b) * c = a * c + b * c"}, {"line": "rcases eq_or_lt_of_le ha with (rfl | a_pos)", "tactic_state": "case inl\nb c : EReal\nhb : 0 \u2264 b\nha : 0 \u2264 0\n\u22a2 (0 + b) * c = 0 * c + b * c\n---\ncase inr\na b c : EReal\nha : 0 \u2264 a\nhb : 0 \u2264 b\na_pos : 0 < a\n\u22a2 (a + b) * c = a * c + b * c"}, {"line": "\u00b7 simp", "tactic_state": "case inr\na b c : EReal\nha : 0 \u2264 a\nhb : 0 \u2264 b\na_pos : 0 < a\n\u22a2 (a + b) * c = a * c + b * c"}, {"line": "rcases eq_or_lt_of_le hb with (rfl | b_pos)", "tactic_state": "case inr.inl\na c : EReal\nha : 0 \u2264 a\na_pos : 0 < a\nhb : 0 \u2264 0\n\u22a2 (a + 0) * c = a * c + 0 * c\n---\ncase inr.inr\na b c : EReal\nha : 0 \u2264 a\nhb : 0 \u2264 b\na_pos : 0 < a\nb_pos : 0 < b\n\u22a2 (a + b) * c = a * c + b * c"}, {"line": "\u00b7 simp", "tactic_state": "case inr.inr\na b c : EReal\nha : 0 \u2264 a\nhb : 0 \u2264 b\na_pos : 0 < a\nb_pos : 0 < b\n\u22a2 (a + b) * c = a * c + b * c"}, {"line": "rcases lt_trichotomy c 0 with (c_neg | rfl | c_pos)", "tactic_state": "case inr.inr.inl\na b c : EReal\nha : 0 \u2264 a\nhb : 0 \u2264 b\na_pos : 0 < a\nb_pos : 0 < b\nc_neg : c < 0\n\u22a2 (a + b) * c = a * c + b * c\n---\ncase inr.inr.inr.inl\na b : EReal\nha : 0 \u2264 a\nhb : 0 \u2264 b\na_pos : 0 < a\nb_pos : 0 < b\n\u22a2 (a + b) * 0 = a * 0 + b * 0\n---\ncase inr.inr.inr.inr\na b c : EReal\nha : 0 \u2264 a\nhb : 0 \u2264 b\na_pos : 0 < a\nb_pos : 0 < b\nc_pos : 0 < c\n\u22a2 (a + b) * c = a * c + b * c"}, {"line": "\u00b7 induction c\n    \u00b7 rw [mul_bot_of_pos a_pos, mul_bot_of_pos b_pos, mul_bot_of_pos (add_pos a_pos b_pos),\n        add_bot \u22a5]\n    \u00b7 induction a\n      \u00b7 exfalso; exact not_lt_bot a_pos\n      \u00b7 induction b\n        \u00b7 norm_cast\n        \u00b7 norm_cast; exact right_distrib _ _ _\n        \u00b7 norm_cast\n          rw [add_top_of_ne_bot (coe_ne_bot _)]\n          rw [top_mul_of_neg c_neg]\n          rw [add_bot]\n      \u00b7 rw [top_add_of_ne_bot (ne_bot_of_gt b_pos), top_mul_of_neg c_neg, bot_add]\n    \u00b7 exfalso; exact not_top_lt c_neg", "tactic_state": "case inr.inr.inr.inl\na b : EReal\nha : 0 \u2264 a\nhb : 0 \u2264 b\na_pos : 0 < a\nb_pos : 0 < b\n\u22a2 (a + b) * 0 = a * 0 + b * 0\n---\ncase inr.inr.inr.inr\na b c : EReal\nha : 0 \u2264 a\nhb : 0 \u2264 b\na_pos : 0 < a\nb_pos : 0 < b\nc_pos : 0 < c\n\u22a2 (a + b) * c = a * c + b * c"}, {"line": "\u00b7 simp", "tactic_state": "case inr.inr.inr.inr\na b c : EReal\nha : 0 \u2264 a\nhb : 0 \u2264 b\na_pos : 0 < a\nb_pos : 0 < b\nc_pos : 0 < c\n\u22a2 (a + b) * c = a * c + b * c"}, {"line": "\u00b7 induction c\n    \u00b7 exfalso; exact not_lt_bot c_pos\n    \u00b7 induction a\n      \u00b7 exfalso; exact not_lt_bot a_pos\n      \u00b7 induction b\n        \u00b7 norm_cast\n        \u00b7 norm_cast; exact right_distrib _ _ _\n        \u00b7 norm_cast\n          rw [add_top_of_ne_bot (coe_ne_bot _)]\n          rw [top_mul_of_pos c_pos]\n          rw [add_top_of_ne_bot (coe_ne_bot _)]\n      \u00b7 rw [top_add_of_ne_bot (ne_bot_of_gt b_pos), top_mul_of_pos c_pos,\n          top_add_of_ne_bot (ne_bot_of_gt (mul_pos b_pos c_pos))]\n    \u00b7 rw [mul_top_of_pos a_pos, mul_top_of_pos b_pos, mul_top_of_pos (add_pos a_pos b_pos),\n        top_add_top]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma right_distrib_of_nonneg_of_ne_top {x : EReal} (hx_nonneg : 0 \u2264 x)\n    (hx_ne_top : x \u2260 \u22a4) (y z : EReal) :\n    (y + z) * x = y * x + z * x := by\n  simpa only [EReal.mul_comm] using left_distrib_of_nonneg_of_ne_top hx_nonneg hx_ne_top y z\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/EReal/Operations.lean", "context": {"open": ["ENNReal NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\nhx_nonneg : 0 \u2264 x\nhx_ne_top : x \u2260 \u22a4\ny z : EReal\n\u22a2 (y + z) * x = y * x + z * x"}, {"line": "simpa only [EReal.mul_comm] using left_distrib_of_nonneg_of_ne_top hx_nonneg hx_ne_top y z", "tactic_state": "No Goals!"}]}
{"declaration": "lemma orderSucc_last (n : \u2115)  :\n    Order.succ (Fin.last n) = Fin.last n := by\n  simp [orderSucc_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/SuccPred.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 Order.succ (Fin.last n) = Fin.last n"}, {"line": "simp [orderSucc_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma orderSucc_castSucc {n : \u2115} (i : Fin n) :\n    Order.succ i.castSucc = i.succ := by\n  simp [orderSucc_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/SuccPred.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 Order.succ i.castSucc = i.succ"}, {"line": "simp [orderSucc_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cons_val_succ (x : \u03b1) (u : Fin m \u2192 \u03b1) (i : Fin m) : vecCons x u i.succ = u i := by\n  simp [vecCons]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/VecNotation.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u}", "{m n : \u2115}", "{m n o : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nm : \u2115\nx\u271d : Sort u_1\nvecCons : x\u271d\nx : \u03b1\nu : Fin m \u2192 \u03b1\ni : Fin m\n\u22a2 sorry = u i"}, {"line": "simp [vecCons]", "tactic_state": "\u03b1 : Type u\nm : \u2115\nx\u271d : Sort u_1\nvecCons : x\u271d\nx : \u03b1\nu : Fin m \u2192 \u03b1\ni : Fin m\n\u22a2 sorry () = u i"}]}
{"declaration": "theorem tail_cons (x : \u03b1) (u : Fin m \u2192 \u03b1) : vecTail (vecCons x u) = u := by\n  ext\n  simp [vecTail]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/VecNotation.lean", "context": {"open": ["Lean Qq", "Qq in"], "variables": ["{\u03b1 : Type u}", "{m n : \u2115}", "{m n o : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\n\u03b1 : Sort u_1\nx\u271d : Sort u_2\nvecTail : x\u271d\nx : \u03b1\nu : Fin m \u2192 \u03b1\n\u22a2 sorry = u"}, {"line": "ext", "tactic_state": "case h\nm : \u2115\n\u03b1 : Sort u_1\nx\u271d\u00b9 : Sort u_2\nvecTail : x\u271d\u00b9\nx : \u03b1\nu : Fin m \u2192 \u03b1\nx\u271d : Fin m\n\u22a2 sorry x\u271d = u x\u271d"}, {"line": "simp [vecTail]", "tactic_state": "case h\nm : \u2115\n\u03b1 : Sort u_1\nx\u271d\u00b9 : Sort u_2\nvecTail : x\u271d\u00b9\nx : \u03b1\nu : Fin m \u2192 \u03b1\nx\u271d : Fin m\n\u22a2 sorry () x\u271d = u x\u271d"}]}
{"declaration": "theorem empty_vecAppend (v : Fin n \u2192 \u03b1) : vecAppend n.zero_add.symm ![] v = v := by\n  ext\n  simp [vecAppend_eq_ite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/VecNotation.lean", "context": {"open": ["Lean Qq", "Qq in", "Lean Qq in", "Lean Qq in"], "variables": ["{\u03b1 : Type u}", "{m n : \u2115}", "{m n o : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b1 : Sort u_1\nx\u271d : Sort u_2\nvecAppend : x\u271d\nv : Fin n \u2192 \u03b1\n\u22a2 sorry = v"}, {"line": "ext", "tactic_state": "case h\nn : \u2115\n\u03b1 : Sort u_1\nx\u271d\u00b9 : Sort u_2\nvecAppend : x\u271d\u00b9\nv : Fin n \u2192 \u03b1\nx\u271d : Fin n\n\u22a2 sorry x\u271d = v x\u271d"}, {"line": "simp [vecAppend_eq_ite]", "tactic_state": "case h\nn : \u2115\n\u03b1 : Sort u_1\nx\u271d\u00b9 : Sort u_2\nvecAppend : x\u271d\u00b9\nv : Fin n \u2192 \u03b1\nx\u271d : Fin n\n\u22a2 sorry () x\u271d = v x\u271d"}]}
{"declaration": "theorem vecHead_vecAlt1 (hm : m + 2 = n + 1 + (n + 1)) (v : Fin (m + 2) \u2192 \u03b1) :\n    vecHead (vecAlt1 hm v) = v 1 := by simp [vecHead, vecAlt1]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/VecNotation.lean", "context": {"open": ["Lean Qq", "Qq in", "Lean Qq in", "Lean Qq in"], "variables": ["{\u03b1 : Type u}", "{m n : \u2115}", "{m n o : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u03b1 : Sort u_1\nx\u271d : Sort u_2\nvecHead : x\u271d\nhm : m + 2 = n + 1 + (n + 1)\nv : Fin (m + 2) \u2192 \u03b1\n\u22a2 sorry = v 1"}, {"line": "simp [vecHead, vecAlt1]", "tactic_state": "m n : \u2115\n\u03b1 : Sort u_1\nx\u271d : Sort u_2\nvecHead : x\u271d\nhm : m + 2 = n + 1 + (n + 1)\nv : Fin (m + 2) \u2192 \u03b1\n\u22a2 sorry () = v 1"}]}
{"declaration": "theorem empty_vecAlt0 (\u03b1) {h} : vecAlt0 h (![] : Fin 0 \u2192 \u03b1) = ![] := by\n  simp [eq_iff_true_of_subsingleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/VecNotation.lean", "context": {"open": ["Lean Qq", "Qq in", "Lean Qq in", "Lean Qq in"], "variables": ["{\u03b1 : Type u}", "{m n : \u2115}", "{m n o : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nvecAlt0 : x\u271d\n\u03b1 : ?m.464\nh : ?m.465 \u03b1\n\u22a2 sorry = ![]"}, {"line": "simp [eq_iff_true_of_subsingleton]", "tactic_state": "x\u271d : Sort u_1\nvecAlt0 : x\u271d\n\u03b1 : ?m.464\nh : ?m.465 \u03b1\n\u22a2 sorry () = ![]"}]}
{"declaration": "theorem empty_vecAlt1 (\u03b1) {h} : vecAlt1 h (![] : Fin 0 \u2192 \u03b1) = ![] := by\n  simp [eq_iff_true_of_subsingleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/VecNotation.lean", "context": {"open": ["Lean Qq", "Qq in", "Lean Qq in", "Lean Qq in"], "variables": ["{\u03b1 : Type u}", "{m n : \u2115}", "{m n o : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nvecAlt1 : x\u271d\n\u03b1 : ?m.464\nh : ?m.465 \u03b1\n\u22a2 sorry = ![]"}, {"line": "simp [eq_iff_true_of_subsingleton]", "tactic_state": "x\u271d : Sort u_1\nvecAlt1 : x\u271d\n\u03b1 : ?m.464\nh : ?m.465 \u03b1\n\u22a2 sorry () = ![]"}]}
{"declaration": "lemma lt_last_iff_ne_last {a : Fin (n + 1)} : a < last n \u2194 a \u2260 last n := by\n  simp [Fin.lt_iff_le_and_ne, le_last]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na : Fin (n + 1)\n\u22a2 a < last n \u2194 a \u2260 last n"}, {"line": "simp [Fin.lt_iff_le_and_ne, le_last]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem min_val {a : Fin n} : min (a : \u2115) n = a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na : Fin n\n\u22a2 min (\u2191a) n = \u2191a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem max_val {a : Fin n} : max (a : \u2115) n = n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na : Fin n\n\u22a2 max (\u2191a) n = n"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_eq_zero_iff [NeZero n] {a : Fin n} : a.val = 0 \u2194 a = 0 := by\n  rw [Fin.ext_iff]\n  rw [val_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\na : Fin n\n\u22a2 \u2191a = 0 \u2194 a = 0"}, {"line": "rw [Fin.ext_iff]", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\na : Fin n\n\u22a2 \u2191a = 0 \u2194 \u2191a = \u21910"}, {"line": "rw [val_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_pos_iff [NeZero n] {a : Fin n} : 0 < a.val \u2194 0 < a := by\n  rw [\u2190 val_fin_lt]\n  rw [val_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\na : Fin n\n\u22a2 0 < \u2191a \u2194 0 < a"}, {"line": "rw [\u2190 val_fin_lt]", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\na : Fin n\n\u22a2 0 < \u2191a \u2194 \u21910 < \u2191a"}, {"line": "rw [val_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pos_iff_ne_zero' [NeZero n] (a : Fin n) : 0 < a \u2194 a \u2260 0 := by\n  rw [\u2190 val_pos_iff]\n  rw [Nat.pos_iff_ne_zero]\n  rw [val_ne_zero_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\na : Fin n\n\u22a2 0 < a \u2194 a \u2260 0"}, {"line": "rw [\u2190 val_pos_iff]", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\na : Fin n\n\u22a2 0 < \u2191a \u2194 a \u2260 0"}, {"line": "rw [Nat.pos_iff_ne_zero]", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\na : Fin n\n\u22a2 \u2191a \u2260 0 \u2194 a \u2260 0"}, {"line": "rw [val_ne_zero_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_last [NeZero n] : 1 < last (n + 1) := by\n  rw [lt_iff_val_lt_val]\n  rw [val_one]\n  rw [val_last]\n  rw [Nat.lt_add_left_iff_pos]\n  rw [Nat.pos_iff_ne_zero]\n  exact NeZero.ne n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\n\u22a2 1 < last (n + 1)"}, {"line": "rw [lt_iff_val_lt_val]", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\n\u22a2 \u21911 < \u2191(last (n + 1))"}, {"line": "rw [val_one]", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\n\u22a2 1 < \u2191(last (n + 1))"}, {"line": "rw [val_last]", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\n\u22a2 1 < n + 1"}, {"line": "rw [Nat.lt_add_left_iff_pos]", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\n\u22a2 0 < n"}, {"line": "rw [Nat.pos_iff_ne_zero]", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\n\u22a2 n \u2260 0"}, {"line": "exact NeZero.ne n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_int_sub_eq_ite {n : Nat} (u v : Fin n) :\n    ((u - v : Fin n) : Int) = if v \u2264 u then (u - v : Int) else (u - v : Int) + n := by\n  rw [Fin.sub_def]\n  split\n  \u00b7 rw [natCast_emod, Int.emod_eq_sub_self_emod, Int.emod_eq_of_lt] <;> omega\n  \u00b7 rw [natCast_emod, Int.emod_eq_of_lt] <;> omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nu v : Fin n\n\u22a2 \u2191\u2191(u - v) = if v \u2264 u then \u2191\u2191u - \u2191\u2191v else \u2191\u2191u - \u2191\u2191v + \u2191n"}, {"line": "rw [Fin.sub_def]", "tactic_state": "n : \u2115\nu v : Fin n\n\u22a2 \u2191\u2191\u27e8(n - \u2191v + \u2191u) % n, \u22ef\u27e9 = if v \u2264 u then \u2191\u2191u - \u2191\u2191v else \u2191\u2191u - \u2191\u2191v + \u2191n"}, {"line": "split", "tactic_state": "case isTrue\nn : \u2115\nu v : Fin n\nh\u271d : v \u2264 u\n\u22a2 \u2191\u2191\u27e8(n - \u2191v + \u2191u) % n, \u22ef\u27e9 = \u2191\u2191u - \u2191\u2191v\n---\ncase isFalse\nn : \u2115\nu v : Fin n\nh\u271d : \u00acv \u2264 u\n\u22a2 \u2191\u2191\u27e8(n - \u2191v + \u2191u) % n, \u22ef\u27e9 = \u2191\u2191u - \u2191\u2191v + \u2191n"}, {"line": "\u00b7 rw [natCast_emod, Int.emod_eq_sub_self_emod, Int.emod_eq_of_lt] <;> omega", "tactic_state": "case isFalse\nn : \u2115\nu v : Fin n\nh\u271d : \u00acv \u2264 u\n\u22a2 \u2191\u2191\u27e8(n - \u2191v + \u2191u) % n, \u22ef\u27e9 = \u2191\u2191u - \u2191\u2191v + \u2191n"}, {"line": "\u00b7 rw [natCast_emod, Int.emod_eq_of_lt] <;> omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_int_sub_eq_mod {n : Nat} (u v : Fin n) :\n    ((u - v : Fin n) : Int) = ((u : Int) - (v : Int)) % n := by\n  rw [coe_int_sub_eq_ite]\n  split\n  \u00b7 rw [Int.emod_eq_of_lt] <;> omega\n  \u00b7 rw [Int.emod_eq_add_self_emod, Int.emod_eq_of_lt] <;> omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nu v : Fin n\n\u22a2 \u2191\u2191(u - v) = (\u2191\u2191u - \u2191\u2191v) % \u2191n"}, {"line": "rw [coe_int_sub_eq_ite]", "tactic_state": "n : \u2115\nu v : Fin n\n\u22a2 (if v \u2264 u then \u2191\u2191u - \u2191\u2191v else \u2191\u2191u - \u2191\u2191v + \u2191n) = (\u2191\u2191u - \u2191\u2191v) % \u2191n"}, {"line": "split", "tactic_state": "case isTrue\nn : \u2115\nu v : Fin n\nh\u271d : v \u2264 u\n\u22a2 \u2191\u2191u - \u2191\u2191v = (\u2191\u2191u - \u2191\u2191v) % \u2191n\n---\ncase isFalse\nn : \u2115\nu v : Fin n\nh\u271d : \u00acv \u2264 u\n\u22a2 \u2191\u2191u - \u2191\u2191v + \u2191n = (\u2191\u2191u - \u2191\u2191v) % \u2191n"}, {"line": "\u00b7 rw [Int.emod_eq_of_lt] <;> omega", "tactic_state": "case isFalse\nn : \u2115\nu v : Fin n\nh\u271d : \u00acv \u2264 u\n\u22a2 \u2191\u2191u - \u2191\u2191v + \u2191n = (\u2191\u2191u - \u2191\u2191v) % \u2191n"}, {"line": "\u00b7 rw [Int.emod_eq_add_self_emod, Int.emod_eq_of_lt] <;> omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_int_add_eq_ite {n : Nat} (u v : Fin n) :\n    ((u + v : Fin n) : Int) = if (u + v : \u2115) < n then (u + v : Int) else (u + v : Int) - n := by\n  rw [Fin.add_def]\n  split\n  \u00b7 rw [natCast_emod, Int.emod_eq_of_lt] <;> omega\n  \u00b7 rw [natCast_emod, Int.emod_eq_sub_self_emod, Int.emod_eq_of_lt] <;> omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nu v : Fin n\n\u22a2 \u2191\u2191(u + v) = if \u2191u + \u2191v < n then \u2191\u2191u + \u2191\u2191v else \u2191\u2191u + \u2191\u2191v - \u2191n"}, {"line": "rw [Fin.add_def]", "tactic_state": "n : \u2115\nu v : Fin n\n\u22a2 \u2191\u2191\u27e8(\u2191u + \u2191v) % n, \u22ef\u27e9 = if \u2191u + \u2191v < n then \u2191\u2191u + \u2191\u2191v else \u2191\u2191u + \u2191\u2191v - \u2191n"}, {"line": "split", "tactic_state": "case isTrue\nn : \u2115\nu v : Fin n\nh\u271d : \u2191u + \u2191v < n\n\u22a2 \u2191\u2191\u27e8(\u2191u + \u2191v) % n, \u22ef\u27e9 = \u2191\u2191u + \u2191\u2191v\n---\ncase isFalse\nn : \u2115\nu v : Fin n\nh\u271d : \u00ac\u2191u + \u2191v < n\n\u22a2 \u2191\u2191\u27e8(\u2191u + \u2191v) % n, \u22ef\u27e9 = \u2191\u2191u + \u2191\u2191v - \u2191n"}, {"line": "\u00b7 rw [natCast_emod, Int.emod_eq_of_lt] <;> omega", "tactic_state": "case isFalse\nn : \u2115\nu v : Fin n\nh\u271d : \u00ac\u2191u + \u2191v < n\n\u22a2 \u2191\u2191\u27e8(\u2191u + \u2191v) % n, \u22ef\u27e9 = \u2191\u2191u + \u2191\u2191v - \u2191n"}, {"line": "\u00b7 rw [natCast_emod, Int.emod_eq_sub_self_emod, Int.emod_eq_of_lt] <;> omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_int_add_eq_mod {n : Nat} (u v : Fin n) :\n    ((u + v : Fin n) : Int) = ((u : Int) + (v : Int)) % n := by\n  rw [coe_int_add_eq_ite]\n  split\n  \u00b7 rw [Int.emod_eq_of_lt] <;> omega\n  \u00b7 rw [Int.emod_eq_sub_self_emod, Int.emod_eq_of_lt] <;> omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nu v : Fin n\n\u22a2 \u2191\u2191(u + v) = (\u2191\u2191u + \u2191\u2191v) % \u2191n"}, {"line": "rw [coe_int_add_eq_ite]", "tactic_state": "n : \u2115\nu v : Fin n\n\u22a2 (if \u2191u + \u2191v < n then \u2191\u2191u + \u2191\u2191v else \u2191\u2191u + \u2191\u2191v - \u2191n) = (\u2191\u2191u + \u2191\u2191v) % \u2191n"}, {"line": "split", "tactic_state": "case isTrue\nn : \u2115\nu v : Fin n\nh\u271d : \u2191u + \u2191v < n\n\u22a2 \u2191\u2191u + \u2191\u2191v = (\u2191\u2191u + \u2191\u2191v) % \u2191n\n---\ncase isFalse\nn : \u2115\nu v : Fin n\nh\u271d : \u00ac\u2191u + \u2191v < n\n\u22a2 \u2191\u2191u + \u2191\u2191v - \u2191n = (\u2191\u2191u + \u2191\u2191v) % \u2191n"}, {"line": "\u00b7 rw [Int.emod_eq_of_lt] <;> omega", "tactic_state": "case isFalse\nn : \u2115\nu v : Fin n\nh\u271d : \u00ac\u2191u + \u2191v < n\n\u22a2 \u2191\u2191u + \u2191\u2191v - \u2191n = (\u2191\u2191u + \u2191\u2191v) % \u2191n"}, {"line": "\u00b7 rw [Int.emod_eq_sub_self_emod, Int.emod_eq_of_lt] <;> omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_add_eq_of_add_lt {n : \u2115} {a b : Fin n} (huv : a.val + b.val < n) :\n    (a + b).val = a.val + b.val := by\n  rw [val_add]\n  simp [Nat.mod_eq_of_lt huv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : Fin n\nhuv : \u2191a + \u2191b < n\n\u22a2 \u2191(a + b) = \u2191a + \u2191b"}, {"line": "rw [val_add]", "tactic_state": "n : \u2115\na b : Fin n\nhuv : \u2191a + \u2191b < n\n\u22a2 (\u2191a + \u2191b) % n = \u2191a + \u2191b"}, {"line": "simp [Nat.mod_eq_of_lt huv]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma intCast_val_sub_eq_sub_add_ite {n : \u2115} (a b : Fin n) :\n    ((a - b).val : \u2124) = a.val - b.val + if b \u2264 a then 0 else n := by\n  split <;> fin_omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : Fin n\n\u22a2 \u2191\u2191(a - b) = \u2191\u2191a - \u2191\u2191b + \u2191(if b \u2264 a then 0 else n)"}, {"line": "split <;> fin_omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma val_sub_one_of_ne_zero [NeZero n] {i : Fin n} (hi : i \u2260 0) : (i - 1).val = i - 1 := by\n  obtain \u27e8n, rfl\u27e9 := Nat.exists_eq_succ_of_ne_zero (NeZero.ne n)\n  rw [Fin.sub_val_of_le (one_le_of_ne_zero hi)]\n  rw [Fin.val_one']\n  rw [Nat.mod_eq_of_lt     (Nat.succ_le_iff.mpr (nontrivial_iff_two_le.mp <| nontrivial_of_ne i 0 hi))]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\ni : Fin n\nhi : i \u2260 0\n\u22a2 \u2191(i - 1) = \u2191i - 1"}, {"line": "obtain \u27e8n, rfl\u27e9 := Nat.exists_eq_succ_of_ne_zero (NeZero.ne n)", "tactic_state": "case intro\nn : \u2115\ninst\u271d : NeZero n.succ\ni : Fin n.succ\nhi : i \u2260 0\n\u22a2 \u2191(i - 1) = \u2191i - 1"}, {"line": "rw [Fin.sub_val_of_le (one_le_of_ne_zero hi)]", "tactic_state": "case intro\nn : \u2115\ninst\u271d : NeZero n.succ\ni : Fin n.succ\nhi : i \u2260 0\n\u22a2 \u2191i - \u21911 = \u2191i - 1"}, {"line": "rw [Fin.val_one']", "tactic_state": "case intro\nn : \u2115\ninst\u271d : NeZero n.succ\ni : Fin n.succ\nhi : i \u2260 0\n\u22a2 \u2191i - 1 % n.succ = \u2191i - 1"}, {"line": "rw [Nat.mod_eq_of_lt     (Nat.succ_le_iff.mpr (nontrivial_iff_two_le.mp <| nontrivial_of_ne i 0 hi))]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_val_last (i : Fin (n + 1)) : i \u2264 n := by\n  rw [Fin.natCast_eq_last]\n  exact Fin.le_last i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin (n + 1)\n\u22a2 i \u2264 \u2191n"}, {"line": "rw [Fin.natCast_eq_last]", "tactic_state": "n : \u2115\ni : Fin (n + 1)\n\u22a2 i \u2264 last n"}, {"line": "exact Fin.le_last i", "tactic_state": "No Goals!"}]}
{"declaration": "lemma natCast_le_natCast (han : a \u2264 n) (hbn : b \u2264 n) : (a : Fin (n + 1)) \u2264 b \u2194 a \u2264 b := by\n  rw [\u2190 Nat.lt_succ_iff] at han hbn\n  simp [le_iff_val_le_val, -val_fin_le, Nat.mod_eq_of_lt, han, hbn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n a b : \u2115\nhan : a \u2264 n\nhbn : b \u2264 n\n\u22a2 \u2191a \u2264 \u2191b \u2194 a \u2264 b"}, {"line": "rw [\u2190 Nat.lt_succ_iff] at han hbn", "tactic_state": "n a b : \u2115\nhan : a < n.succ\nhbn : b < n.succ\n\u22a2 \u2191a \u2264 \u2191b \u2194 a \u2264 b"}, {"line": "simp [le_iff_val_le_val, -val_fin_le, Nat.mod_eq_of_lt, han, hbn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem succ_zero_eq_one' [NeZero n] : Fin.succ (0 : Fin n) = 1 := by\n  cases n\n  \u00b7 exact (NeZero.ne 0 rfl).elim\n  \u00b7 rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\n\u22a2 Fin.succ 0 = 1"}, {"line": "cases n", "tactic_state": "case zero\ninst\u271d : NeZero 0\n\u22a2 Fin.succ 0 = 1\n---\ncase succ\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\n\u22a2 Fin.succ 0 = 1"}, {"line": "\u00b7 exact (NeZero.ne 0 rfl).elim", "tactic_state": "case succ\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\n\u22a2 Fin.succ 0 = 1"}, {"line": "\u00b7 rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem succ_one_eq_two' [NeZero n] : Fin.succ (1 : Fin (n + 1)) = 2 := by\n  cases n\n  \u00b7 exact (NeZero.ne 0 rfl).elim\n  \u00b7 rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\n\u22a2 Fin.succ 1 = 2"}, {"line": "cases n", "tactic_state": "case zero\ninst\u271d : NeZero 0\n\u22a2 Fin.succ 1 = 2\n---\ncase succ\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\n\u22a2 Fin.succ 1 = 2"}, {"line": "\u00b7 exact (NeZero.ne 0 rfl).elim", "tactic_state": "case succ\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\n\u22a2 Fin.succ 1 = 2"}, {"line": "\u00b7 rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_of_injective_castLE_symm {n k : \u2115} (h : n \u2264 k) (i : Fin k) (hi) :\n    ((Equiv.ofInjective _ (castLE_injective h)).symm \u27e8i, hi\u27e9 : \u2115) = i := by\n  rw [\u2190 coe_castLE h]\n  exact congr_arg Fin.val (Equiv.apply_ofInjective_symm _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\nh : n \u2264 k\ni : Fin k\nhi : i \u2208 Set.range (castLE h)\n\u22a2 \u2191((Equiv.ofInjective (castLE h) \u22ef).symm \u27e8i, hi\u27e9) = \u2191i"}, {"line": "rw [\u2190 coe_castLE h]", "tactic_state": "n k : \u2115\nh : n \u2264 k\ni : Fin k\nhi : i \u2208 Set.range (castLE h)\n\u22a2 \u2191(castLE h ((Equiv.ofInjective (castLE h) \u22ef).symm \u27e8i, hi\u27e9)) = \u2191i"}, {"line": "exact congr_arg Fin.val (Equiv.apply_ofInjective_symm _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_inj (eq : n = m) {a b : Fin n} : a.cast eq = b.cast eq \u2194 a = b := by\n  simp [\u2190 val_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\neq : n = m\na b : Fin n\n\u22a2 Fin.cast eq a = Fin.cast eq b \u2194 a = b"}, {"line": "simp [\u2190 val_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_eq_cast (h : n = m) : (Fin.cast h : Fin n \u2192 Fin m) = _root_.cast (h \u25b8 rfl) := by\n  subst h\n  ext\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\n\u22a2 Fin.cast h = cast \u22ef"}, {"line": "subst h", "tactic_state": "n : \u2115\n\u22a2 Fin.cast \u22ef = cast \u22ef"}, {"line": "ext", "tactic_state": "case h.h\nn : \u2115\nx\u271d : Fin n\n\u22a2 \u2191(Fin.cast \u22ef x\u271d) = \u2191(cast \u22ef x\u271d)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem castSucc_pos_iff [NeZero n] {i : Fin n} : 0 < castSucc i \u2194 0 < i := by simp [\u2190 val_pos_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\ni : Fin n\n\u22a2 0 < i.castSucc \u2194 0 < i"}, {"line": "simp [\u2190 val_pos_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a := by\n  ext\n  exact val_cast_of_lt (Nat.lt.step a.is_lt)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na : Fin n\n\u22a2 \u2191\u2191a = a.castSucc"}, {"line": "ext", "tactic_state": "case h\nn : \u2115\na : Fin n\n\u22a2 \u2191\u2191\u2191a = \u2191a.castSucc"}, {"line": "exact val_cast_of_lt (Nat.lt.step a.is_lt)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_succ_lt_iff_lt {n : \u2115} {j k : Fin n} : (j : Fin <| n + 1) < k \u2194 j < k := by\n  simp only [coe_eq_castSucc]\n  simp only [castSucc_lt_castSucc_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nj k : Fin n\n\u22a2 \u2191\u2191j < \u2191\u2191k \u2194 j < k"}, {"line": "simp only [coe_eq_castSucc]", "tactic_state": "n : \u2115\nj k : Fin n\n\u22a2 j.castSucc < k.castSucc \u2194 j < k"}, {"line": "simp only [castSucc_lt_castSucc_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_of_injective_castSucc_symm {n : \u2115} (i : Fin n.succ) (hi) :\n    ((Equiv.ofInjective castSucc (castSucc_injective _)).symm \u27e8i, hi\u27e9 : \u2115) = i := by\n  rw [\u2190 coe_castSucc]\n  exact congr_arg val (Equiv.apply_ofInjective_symm _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin n.succ\nhi : i \u2208 Set.range castSucc\n\u22a2 \u2191((Equiv.ofInjective castSucc \u22ef).symm \u27e8i, hi\u27e9) = \u2191i"}, {"line": "rw [\u2190 coe_castSucc]", "tactic_state": "n : \u2115\ni : Fin n.succ\nhi : i \u2208 Set.range castSucc\n\u22a2 \u2191((Equiv.ofInjective castSucc \u22ef).symm \u27e8i, hi\u27e9).castSucc = \u2191i"}, {"line": "exact congr_arg val (Equiv.apply_ofInjective_symm _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pred_one' [NeZero n] (h := (zero_ne_one' (n := n)).symm) :\n    Fin.pred (1 : Fin (n + 1)) h = 0 := by\n  simp_rw [Fin.ext_iff, coe_pred, val_one', val_zero, Nat.sub_eq_zero_iff_le, Nat.mod_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\nh : optParam (1 \u2260 0) \u22ef\n\u22a2 Fin.pred 1 h = 0"}, {"line": "simp_rw [Fin.ext_iff, coe_pred, val_one', val_zero, Nat.sub_eq_zero_iff_le, Nat.mod_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem castSucc_pred_add_one_eq {a : Fin (n + 1)} (ha : a \u2260 0) :\n    (a.pred ha).castSucc + 1 = a := by\n  cases a using cases\n  \u00b7 exact (ha rfl).elim\n  \u00b7 rw [pred_succ, coeSucc_eq_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na : Fin (n + 1)\nha : a \u2260 0\n\u22a2 (a.pred ha).castSucc + 1 = a"}, {"line": "cases a using cases", "tactic_state": "case zero\nn : \u2115\nha : 0 \u2260 0\n\u22a2 (Fin.pred 0 ha).castSucc + 1 = 0\n---\ncase succ\nn : \u2115\ni\u271d : Fin n\nha : i\u271d.succ \u2260 0\n\u22a2 (i\u271d.succ.pred ha).castSucc + 1 = i\u271d.succ"}, {"line": "\u00b7 exact (ha rfl).elim", "tactic_state": "case succ\nn : \u2115\ni\u271d : Fin n\nha : i\u271d.succ \u2260 0\n\u22a2 (i\u271d.succ.pred ha).castSucc + 1 = i\u271d.succ"}, {"line": "\u00b7 rw [pred_succ, coeSucc_eq_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_pred_castSucc_iff {a b : Fin (n + 1)} (ha : castSucc a \u2260 0) :\n    b \u2264 (castSucc a).pred ha \u2194 b < a := by\n  rw [le_pred_iff]\n  rw [succ_le_castSucc_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : Fin (n + 1)\nha : a.castSucc \u2260 0\n\u22a2 b \u2264 a.castSucc.pred ha \u2194 b < a"}, {"line": "rw [le_pred_iff]", "tactic_state": "n : \u2115\na b : Fin (n + 1)\nha : a.castSucc \u2260 0\n\u22a2 b.succ \u2264 a.castSucc \u2194 b < a"}, {"line": "rw [succ_le_castSucc_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pred_castSucc_lt_iff {a b : Fin (n + 1)} (ha : castSucc a \u2260 0) :\n    (castSucc a).pred ha < b \u2194 a \u2264 b := by\n  rw [pred_lt_iff]\n  rw [castSucc_lt_succ_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : Fin (n + 1)\nha : a.castSucc \u2260 0\n\u22a2 a.castSucc.pred ha < b \u2194 a \u2264 b"}, {"line": "rw [pred_lt_iff]", "tactic_state": "n : \u2115\na b : Fin (n + 1)\nha : a.castSucc \u2260 0\n\u22a2 a.castSucc < b.succ \u2194 a \u2264 b"}, {"line": "rw [castSucc_lt_succ_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_castSucc_pred_iff {a b : Fin (n + 1)} (ha : a \u2260 0) :\n    b \u2264 castSucc (a.pred ha) \u2194 b < a := by\n  rw [castSucc_pred_eq_pred_castSucc]\n  rw [le_pred_castSucc_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : Fin (n + 1)\nha : a \u2260 0\n\u22a2 b \u2264 (a.pred ha).castSucc \u2194 b < a"}, {"line": "rw [castSucc_pred_eq_pred_castSucc]", "tactic_state": "n : \u2115\na b : Fin (n + 1)\nha : a \u2260 0\n\u22a2 b \u2264 a.castSucc.pred \u22ef \u2194 b < a"}, {"line": "rw [le_pred_castSucc_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem castSucc_pred_lt_iff {a b : Fin (n + 1)} (ha : a \u2260 0) :\n    castSucc (a.pred ha) < b \u2194 a \u2264 b := by\n  rw [castSucc_pred_eq_pred_castSucc]\n  rw [pred_castSucc_lt_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : Fin (n + 1)\nha : a \u2260 0\n\u22a2 (a.pred ha).castSucc < b \u2194 a \u2264 b"}, {"line": "rw [castSucc_pred_eq_pred_castSucc]", "tactic_state": "n : \u2115\na b : Fin (n + 1)\nha : a \u2260 0\n\u22a2 a.castSucc.pred \u22ef < b \u2194 a \u2264 b"}, {"line": "rw [pred_castSucc_lt_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem castSucc_castPred (i : Fin (n + 1)) (h : i \u2260 last n) :\n    castSucc (i.castPred h) = i := by\n  rcases exists_castSucc_eq.mpr h with \u27e8y, rfl\u27e9\n  rw [castPred_castSucc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin (n + 1)\nh : i \u2260 last n\n\u22a2 (i.castPred h).castSucc = i"}, {"line": "rcases exists_castSucc_eq.mpr h with \u27e8y, rfl\u27e9", "tactic_state": "case intro\nn : \u2115\ny : Fin n\nh : y.castSucc \u2260 last n\n\u22a2 (y.castSucc.castPred h).castSucc = y.castSucc"}, {"line": "rw [castPred_castSucc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem castPred_lt_iff {j : Fin n} {i : Fin (n + 1)} (hi : i \u2260 last n) :\n    castPred i hi < j \u2194 i < castSucc j := by\n  rw [\u2190 castSucc_lt_castSucc_iff]\n  rw [castSucc_castPred]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nj : Fin n\ni : Fin (n + 1)\nhi : i \u2260 last n\n\u22a2 i.castPred hi < j \u2194 i < j.castSucc"}, {"line": "rw [\u2190 castSucc_lt_castSucc_iff]", "tactic_state": "n : \u2115\nj : Fin n\ni : Fin (n + 1)\nhi : i \u2260 last n\n\u22a2 (i.castPred hi).castSucc < j.castSucc \u2194 i < j.castSucc"}, {"line": "rw [castSucc_castPred]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_castPred_iff {j : Fin n} {i : Fin (n + 1)} (hi : i \u2260 last n) :\n    j < castPred i hi \u2194 castSucc j < i := by\n  rw [\u2190 castSucc_lt_castSucc_iff]\n  rw [castSucc_castPred]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nj : Fin n\ni : Fin (n + 1)\nhi : i \u2260 last n\n\u22a2 j < i.castPred hi \u2194 j.castSucc < i"}, {"line": "rw [\u2190 castSucc_lt_castSucc_iff]", "tactic_state": "n : \u2115\nj : Fin n\ni : Fin (n + 1)\nhi : i \u2260 last n\n\u22a2 j.castSucc < (i.castPred hi).castSucc \u2194 j.castSucc < i"}, {"line": "rw [castSucc_castPred]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem castPred_le_iff {j : Fin n} {i : Fin (n + 1)} (hi : i \u2260 last n) :\n    castPred i hi \u2264 j \u2194 i \u2264 castSucc j := by\n  rw [\u2190 castSucc_le_castSucc_iff]\n  rw [castSucc_castPred]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nj : Fin n\ni : Fin (n + 1)\nhi : i \u2260 last n\n\u22a2 i.castPred hi \u2264 j \u2194 i \u2264 j.castSucc"}, {"line": "rw [\u2190 castSucc_le_castSucc_iff]", "tactic_state": "n : \u2115\nj : Fin n\ni : Fin (n + 1)\nhi : i \u2260 last n\n\u22a2 (i.castPred hi).castSucc \u2264 j.castSucc \u2194 i \u2264 j.castSucc"}, {"line": "rw [castSucc_castPred]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_castPred_iff {j : Fin n} {i : Fin (n + 1)} (hi : i \u2260 last n) :\n    j \u2264 castPred i hi \u2194 castSucc j \u2264 i := by\n  rw [\u2190 castSucc_le_castSucc_iff]\n  rw [castSucc_castPred]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nj : Fin n\ni : Fin (n + 1)\nhi : i \u2260 last n\n\u22a2 j \u2264 i.castPred hi \u2194 j.castSucc \u2264 i"}, {"line": "rw [\u2190 castSucc_le_castSucc_iff]", "tactic_state": "n : \u2115\nj : Fin n\ni : Fin (n + 1)\nhi : i \u2260 last n\n\u22a2 j.castSucc \u2264 (i.castPred hi).castSucc \u2194 j.castSucc \u2264 i"}, {"line": "rw [castSucc_castPred]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem castPred_eq_zero [NeZero n] {i : Fin (n + 1)} (h : i \u2260 last n) :\n    Fin.castPred i h = 0 \u2194 i = 0 := by\n  rw [\u2190 castPred_zero']\n  rw [castPred_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\ni : Fin (n + 1)\nh : i \u2260 last n\n\u22a2 i.castPred h = 0 \u2194 i = 0"}, {"line": "rw [\u2190 castPred_zero']", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\ni : Fin (n + 1)\nh : i \u2260 last n\n\u22a2 i.castPred h = castPred 0 \u22ef \u2194 i = 0"}, {"line": "rw [castPred_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem castPred_le_pred_iff {a b : Fin (n + 1)} (ha : a \u2260 last n) (hb : b \u2260 0) :\n    castPred a ha \u2264 pred b hb \u2194 a < b := by\n  rw [le_pred_iff]\n  rw [succ_castPred_le_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : Fin (n + 1)\nha : a \u2260 last n\nhb : b \u2260 0\n\u22a2 a.castPred ha \u2264 b.pred hb \u2194 a < b"}, {"line": "rw [le_pred_iff]", "tactic_state": "n : \u2115\na b : Fin (n + 1)\nha : a \u2260 last n\nhb : b \u2260 0\n\u22a2 (a.castPred ha).succ \u2264 b \u2194 a < b"}, {"line": "rw [succ_castPred_le_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pred_lt_castPred_iff {a b : Fin (n + 1)} (ha : a \u2260 0) (hb : b \u2260 last n) :\n    pred a ha < castPred b hb \u2194 a \u2264 b := by\n  rw [lt_castPred_iff]\n  rw [castSucc_pred_lt_iff ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : Fin (n + 1)\nha : a \u2260 0\nhb : b \u2260 last n\n\u22a2 a.pred ha < b.castPred hb \u2194 a \u2264 b"}, {"line": "rw [lt_castPred_iff]", "tactic_state": "n : \u2115\na b : Fin (n + 1)\nha : a \u2260 0\nhb : b \u2260 last n\n\u22a2 (a.pred ha).castSucc < b \u2194 a \u2264 b"}, {"line": "rw [castSucc_pred_lt_iff ha]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma succAbove_castPred_of_lt (p i : Fin (n + 1)) (h : i < p)\n    (hi := Fin.ne_of_lt <| Nat.lt_of_lt_of_le h p.le_last) : succAbove p (i.castPred hi) = i := by\n  rw [succAbove_of_castSucc_lt _ _ (castSucc_castPred _ _ \u25b8 h)]\n  rw [castSucc_castPred]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np i : Fin (n + 1)\nh : i < p\nhi : optParam (i \u2260 last n) \u22ef\n\u22a2 p.succAbove (i.castPred hi) = i"}, {"line": "rw [succAbove_of_castSucc_lt _ _ (castSucc_castPred _ _ \u25b8 h)]", "tactic_state": "n : \u2115\np i : Fin (n + 1)\nh : i < p\nhi : optParam (i \u2260 last n) \u22ef\n\u22a2 (i.castPred hi).castSucc = i"}, {"line": "rw [castSucc_castPred]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma succAbove_ne_zero_zero [NeZero n] {a : Fin (n + 1)} (ha : a \u2260 0) : a.succAbove 0 = 0 := by\n  rw [Fin.succAbove_of_castSucc_lt]\n  \u00b7 exact castSucc_zero'\n  \u00b7 exact Fin.pos_iff_ne_zero.2 ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\na : Fin (n + 1)\nha : a \u2260 0\n\u22a2 a.succAbove 0 = 0"}, {"line": "rw [Fin.succAbove_of_castSucc_lt]", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\na : Fin (n + 1)\nha : a \u2260 0\n\u22a2 castSucc 0 = 0\n---\ncase h\nn : \u2115\ninst\u271d : NeZero n\na : Fin (n + 1)\nha : a \u2260 0\n\u22a2 castSucc 0 < a"}, {"line": "\u00b7 exact castSucc_zero'", "tactic_state": "case h\nn : \u2115\ninst\u271d : NeZero n\na : Fin (n + 1)\nha : a \u2260 0\n\u22a2 castSucc 0 < a"}, {"line": "\u00b7 exact Fin.pos_iff_ne_zero.2 ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma succAbove_zero_apply (i : Fin n) : succAbove 0 i = succ i := by rw [succAbove_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 succAbove 0 i = sorry"}, {"line": "rw [succAbove_zero]", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 i.succ = sorry"}]}
{"declaration": "lemma succAbove_eq_last_iff {a : Fin (n + 2)} {b : Fin (n + 1)} (ha : a \u2260 last _) :\n    a.succAbove b = last _ \u2194 b = last _ := by\n  rw [\u2190 succAbove_ne_last_last ha]\n  rw [succAbove_right_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na : Fin (n + 2)\nb : Fin (n + 1)\nha : a \u2260 last (n + 1)\n\u22a2 a.succAbove b = last (n + 1) \u2194 b = last n"}, {"line": "rw [\u2190 succAbove_ne_last_last ha]", "tactic_state": "n : \u2115\na : Fin (n + 2)\nb : Fin (n + 1)\nha : a \u2260 last (n + 1)\n\u22a2 a.succAbove b = a.succAbove (last n) \u2194 b = last n"}, {"line": "rw [succAbove_right_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma succAbove_last_apply (i : Fin n) : succAbove (last n) i = castSucc i := by rw [succAbove_last]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 (last n).succAbove i = i.castSucc"}, {"line": "rw [succAbove_last]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma succAbove_lt_iff_succ_le (p : Fin (n + 1)) (i : Fin n) :\n    p.succAbove i < p \u2194 succ i \u2264 p := by\n  rw [succAbove_lt_iff_castSucc_lt]\n  rw [castSucc_lt_iff_succ_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np : Fin (n + 1)\ni : Fin n\n\u22a2 p.succAbove i < p \u2194 sorry \u2264 p"}, {"line": "rw [succAbove_lt_iff_castSucc_lt]", "tactic_state": "n : \u2115\np : Fin (n + 1)\ni : Fin n\n\u22a2 i.castSucc < p \u2194 sorry \u2264 p"}, {"line": "rw [castSucc_lt_iff_succ_le]", "tactic_state": "n : \u2115\np : Fin (n + 1)\ni : Fin n\n\u22a2 i.succ \u2264 p \u2194 sorry \u2264 p"}]}
{"declaration": "lemma lt_succAbove_iff_lt_castSucc (p : Fin (n + 1)) (i : Fin n) :\n    p < p.succAbove i \u2194 p < succ i := by rw [lt_succAbove_iff_le_castSucc, le_castSucc_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np : Fin (n + 1)\ni : Fin n\n\u22a2 p < p.succAbove i \u2194 p < sorry"}, {"line": "rw [lt_succAbove_iff_le_castSucc, le_castSucc_iff]", "tactic_state": "n : \u2115\np : Fin (n + 1)\ni : Fin n\n\u22a2 p < i.succ \u2194 p < sorry"}]}
{"declaration": "lemma succAbove_pos [NeZero n] (p : Fin (n + 1)) (i : Fin n) (h : 0 < i) : 0 < p.succAbove i := by\n  by_cases H : castSucc i < p\n  \u00b7 simpa [succAbove_of_castSucc_lt _ _ H] using castSucc_pos' h\n  \u00b7 simp [succAbove_of_le_castSucc _ _ (Fin.not_lt.1 H)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\np : Fin (n + 1)\ni : Fin n\nh : 0 < i\n\u22a2 0 < p.succAbove i"}, {"line": "by_cases H : castSucc i < p", "tactic_state": "case pos\nn : \u2115\ninst\u271d : NeZero n\np : Fin (n + 1)\ni : Fin n\nh : 0 < i\nH : i.castSucc < p\n\u22a2 0 < p.succAbove i\n---\ncase neg\nn : \u2115\ninst\u271d : NeZero n\np : Fin (n + 1)\ni : Fin n\nh : 0 < i\nH : \u00aci.castSucc < p\n\u22a2 0 < p.succAbove i"}, {"line": "\u00b7 simpa [succAbove_of_castSucc_lt _ _ H] using castSucc_pos' h", "tactic_state": "case neg\nn : \u2115\ninst\u271d : NeZero n\np : Fin (n + 1)\ni : Fin n\nh : 0 < i\nH : \u00aci.castSucc < p\n\u22a2 0 < p.succAbove i"}, {"line": "\u00b7 simp [succAbove_of_le_castSucc _ _ (Fin.not_lt.1 H)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma castPred_succAbove (x : Fin n) (y : Fin (n + 1)) (h : castSucc x < y)\n    (h' := Fin.ne_last_of_lt <| (succAbove_lt_iff_castSucc_lt ..).2 h) :\n    (y.succAbove x).castPred h' = x := by\n  rw [castPred_eq_iff_eq_castSucc]\n  rw [succAbove_of_castSucc_lt _ _ h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx : Fin n\ny : Fin (n + 1)\nh : x.castSucc < y\nh' : optParam (y.succAbove x \u2260 last n) \u22ef\n\u22a2 (y.succAbove x).castPred h' = x"}, {"line": "rw [castPred_eq_iff_eq_castSucc]", "tactic_state": "n : \u2115\nx : Fin n\ny : Fin (n + 1)\nh : x.castSucc < y\nh' : optParam (y.succAbove x \u2260 last n) \u22ef\n\u22a2 y.succAbove x = x.castSucc"}, {"line": "rw [succAbove_of_castSucc_lt _ _ h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pred_succAbove (x : Fin n) (y : Fin (n + 1)) (h : y \u2264 castSucc x)\n    (h' := Fin.ne_zero_of_lt <| (lt_succAbove_iff_le_castSucc ..).2 h) :\n    (y.succAbove x).pred h' = x := by simp only [succAbove_of_le_castSucc _ _ h, pred_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx : Fin n\ny : Fin (n + 1)\nh : y \u2264 x.castSucc\nh' : optParam (y.succAbove x \u2260 0) \u22ef\n\u22a2 (y.succAbove x).pred h' = x"}, {"line": "simp only [succAbove_of_le_castSucc _ _ h, pred_succ]", "tactic_state": "n : \u2115\nx : Fin n\ny : Fin (n + 1)\nh : y \u2264 x.castSucc\nh' : optParam (y.succAbove x \u2260 0) \u22ef\n\u22a2 x.succ.pred \u22ef = x"}]}
{"declaration": "lemma exists_succAbove_eq {x y : Fin (n + 1)} (h : x \u2260 y) : \u2203 z, y.succAbove z = x := by\n  obtain hxy | hyx := Fin.lt_or_lt_of_ne h\n  exacts [\u27e8_, succAbove_castPred_of_lt _ _ hxy\u27e9, \u27e8_, succAbove_pred_of_lt _ _ hyx\u27e9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx y : Fin (n + 1)\nh : x \u2260 y\n\u22a2 \u2203 z, y.succAbove z = x"}, {"line": "obtain hxy | hyx := Fin.lt_or_lt_of_ne h", "tactic_state": "case inl\nn : \u2115\nx y : Fin (n + 1)\nh : x \u2260 y\nhxy : x < y\n\u22a2 \u2203 z, y.succAbove z = x\n---\ncase inr\nn : \u2115\nx y : Fin (n + 1)\nh : x \u2260 y\nhyx : y < x\n\u22a2 \u2203 z, y.succAbove z = x"}, {"line": "exacts [\u27e8_, succAbove_castPred_of_lt _ _ hxy\u27e9, \u27e8_, succAbove_pred_of_lt _ _ hyx\u27e9]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma succ_succAbove_zero {n : \u2115} [NeZero n] (i : Fin n) : succAbove i.succ 0 = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\ni : Fin n\n\u22a2 i.succ.succAbove 0 = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma castSucc_succAbove_castSucc {n : \u2115} {i : Fin (n + 1)} {j : Fin n} :\n    i.castSucc.succAbove j.castSucc = (i.succAbove j).castSucc := by\n  rcases i.le_or_lt (castSucc j) with (h | h)\n  \u00b7 rw [succAbove_of_le_castSucc _ _ h, succAbove_castSucc_of_le _ _ h, succ_castSucc]\n  \u00b7 rw [succAbove_of_castSucc_lt _ _ h, succAbove_castSucc_of_lt _ _ h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin (n + 1)\nj : Fin n\n\u22a2 i.castSucc.succAbove j.castSucc = (i.succAbove j).castSucc"}, {"line": "rcases i.le_or_lt (castSucc j) with (h | h)", "tactic_state": "case inl\nn : \u2115\ni : Fin (n + 1)\nj : Fin n\nh : i \u2264 j.castSucc\n\u22a2 i.castSucc.succAbove j.castSucc = (i.succAbove j).castSucc\n---\ncase inr\nn : \u2115\ni : Fin (n + 1)\nj : Fin n\nh : j.castSucc < i\n\u22a2 i.castSucc.succAbove j.castSucc = (i.succAbove j).castSucc"}, {"line": "\u00b7 rw [succAbove_of_le_castSucc _ _ h, succAbove_castSucc_of_le _ _ h, succ_castSucc]", "tactic_state": "case inr\nn : \u2115\ni : Fin (n + 1)\nj : Fin n\nh : j.castSucc < i\n\u22a2 i.castSucc.succAbove j.castSucc = (i.succAbove j).castSucc"}, {"line": "\u00b7 rw [succAbove_of_castSucc_lt _ _ h, succAbove_castSucc_of_lt _ _ h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma castPred_succAbove_castPred {a : Fin (n + 2)} {b : Fin (n + 1)} (ha : a \u2260 last (n + 1))\n    (hb : b \u2260 last n) (hk := succAbove_ne_last ha hb) :\n    (a.castPred ha).succAbove (b.castPred hb) = (a.succAbove b).castPred hk := by\n  simp_rw [\u2190 castSucc_inj (b := (a.succAbove b).castPred hk), \u2190 castSucc_succAbove_castSucc,\n    castSucc_castPred]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na : Fin (n + 2)\nb : Fin (n + 1)\nha : a \u2260 last (n + 1)\nhb : b \u2260 last n\nhk : optParam (a.succAbove b \u2260 last (n + 1)) \u22ef\n\u22a2 (a.castPred ha).succAbove (b.castPred hb) = (a.succAbove b).castPred hk"}, {"line": "simp_rw [\u2190 castSucc_inj (b := (a.succAbove b).castPred hk), \u2190 castSucc_succAbove_castSucc,\n    castSucc_castPred]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_succAbove_zero {n : \u2115} : (1 : Fin (n + 2)).succAbove 0 = 0 := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 succAbove 1 0 = 0"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma predAbove_castSucc_of_lt (p i : Fin n) (h : p < i) (hi := castSucc_ne_zero_of_lt h) :\n    p.predAbove (castSucc i) = i.castSucc.pred hi := by\n  rw [predAbove_of_castSucc_lt _ _ (castSucc_lt_castSucc_iff.2 h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np i : Fin n\nh : p < i\nhi : optParam (i.castSucc \u2260 0) \u22ef\n\u22a2 p.predAbove i.castSucc = i.castSucc.pred hi"}, {"line": "rw [predAbove_of_castSucc_lt _ _ (castSucc_lt_castSucc_iff.2 h)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma predAbove_castSucc_of_le (p i : Fin n) (h : i \u2264 p) : p.predAbove (castSucc i) = i := by\n  rw [predAbove_of_le_castSucc _ _ (castSucc_le_castSucc_iff.mpr h)]\n  rw [castPred_castSucc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np i : Fin n\nh : i \u2264 p\n\u22a2 p.predAbove i.castSucc = i"}, {"line": "rw [predAbove_of_le_castSucc _ _ (castSucc_le_castSucc_iff.mpr h)]", "tactic_state": "n : \u2115\np i : Fin n\nh : i \u2264 p\n\u22a2 i.castSucc.castPred \u22ef = i"}, {"line": "rw [castPred_castSucc]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma predAbove_pred_of_lt (p i : Fin (n + 1)) (h : i < p) (hp := Fin.ne_zero_of_lt h)\n    (hi := Fin.ne_last_of_lt h) : (pred p hp).predAbove i = castPred i hi := by\n  rw [predAbove_of_lt_succ _ _ (succ_pred _ _ \u25b8 h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np i : Fin (n + 1)\nh : i < p\nhp : optParam (p \u2260 0) \u22ef\nhi : optParam (i \u2260 last n) \u22ef\n\u22a2 (p.pred hp).predAbove i = i.castPred hi"}, {"line": "rw [predAbove_of_lt_succ _ _ (succ_pred _ _ \u25b8 h)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma predAbove_pred_of_le (p i : Fin (n + 1)) (h : p \u2264 i) (hp : p \u2260 0)\n    (hi := Fin.ne_of_gt <| Fin.lt_of_lt_of_le (Fin.pos_iff_ne_zero.2 hp) h) :\n  (pred p hp).predAbove i = pred i hi := by rw [predAbove_of_succ_le _ _ (succ_pred _ _ \u25b8 h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np i : Fin (n + 1)\nh : p \u2264 i\nhp : p \u2260 0\nhi : optParam (i \u2260 0) \u22ef\n\u22a2 (p.pred hp).predAbove i = i.pred hi"}, {"line": "rw [predAbove_of_succ_le _ _ (succ_pred _ _ \u25b8 h)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma predAbove_castPred_of_lt (p i : Fin (n + 1)) (h : p < i) (hp := Fin.ne_last_of_lt h)\n  (hi := Fin.ne_zero_of_lt h) : (castPred p hp).predAbove i = pred i hi := by\n  rw [predAbove_of_castSucc_lt _ _ (castSucc_castPred _ _ \u25b8 h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np i : Fin (n + 1)\nh : p < i\nhp : optParam (p \u2260 last n) \u22ef\nhi : optParam (i \u2260 0) \u22ef\n\u22a2 (p.castPred hp).predAbove i = i.pred hi"}, {"line": "rw [predAbove_of_castSucc_lt _ _ (castSucc_castPred _ _ \u25b8 h)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma predAbove_castPred_of_le (p i : Fin (n + 1)) (h : i \u2264 p) (hp : p \u2260 last n)\n    (hi := Fin.ne_of_lt <| Fin.lt_of_le_of_lt h <| Fin.lt_last_iff_ne_last.2 hp) :\n    (castPred p hp).predAbove i = castPred i hi := by\n  rw [predAbove_of_le_castSucc _ _ (castSucc_castPred _ _ \u25b8 h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np i : Fin (n + 1)\nh : i \u2264 p\nhp : p \u2260 last n\nhi : optParam (i \u2260 last n) \u22ef\n\u22a2 (p.castPred hp).predAbove i = i.castPred hi"}, {"line": "rw [predAbove_of_le_castSucc _ _ (castSucc_castPred _ _ \u25b8 h)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma predAbove_zero_succ [NeZero n] {i : Fin n} : predAbove 0 i.succ = i := by\n  rw [predAbove_succ_of_le _ _ (Fin.zero_le' _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\ni : Fin n\n\u22a2 predAbove 0 i.succ = i"}, {"line": "rw [predAbove_succ_of_le _ _ (Fin.zero_le' _)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma predAbove_zero [NeZero n] {i : Fin (n + 1)} :\n    predAbove (0 : Fin n) i = if hi : i = 0 then 0 else i.pred hi := by\n  split_ifs with hi\n  \u00b7 rw [hi, predAbove_right_zero]\n  \u00b7 rw [predAbove_zero_of_ne_zero hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\ni : Fin (n + 1)\n\u22a2 predAbove 0 i = if hi : i = 0 then 0 else i.pred hi"}, {"line": "split_ifs with hi", "tactic_state": "case pos\nn : \u2115\ninst\u271d : NeZero n\ni : Fin (n + 1)\nhi : i = 0\n\u22a2 predAbove 0 i = 0\n---\ncase neg\nn : \u2115\ninst\u271d : NeZero n\ni : Fin (n + 1)\nhi : \u00aci = 0\n\u22a2 predAbove 0 i = i.pred hi"}, {"line": "\u00b7 rw [hi, predAbove_right_zero]", "tactic_state": "case neg\nn : \u2115\ninst\u271d : NeZero n\ni : Fin (n + 1)\nhi : \u00aci = 0\n\u22a2 predAbove 0 i = i.pred hi"}, {"line": "\u00b7 rw [predAbove_zero_of_ne_zero hi]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma predAbove_last_castSucc {i : Fin (n + 1)} : predAbove (last n) (i.castSucc) = i := by\n  rw [predAbove_of_le_castSucc _ _ (castSucc_le_castSucc_iff.mpr (le_last _))]\n  rw [castPred_castSucc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin (n + 1)\n\u22a2 (last n).predAbove i.castSucc = i"}, {"line": "rw [predAbove_of_le_castSucc _ _ (castSucc_le_castSucc_iff.mpr (le_last _))]", "tactic_state": "n : \u2115\ni : Fin (n + 1)\n\u22a2 i.castSucc.castPred \u22ef = i"}, {"line": "rw [castPred_castSucc]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma predAbove_last_apply {i : Fin (n + 2)} :\n    predAbove (last n) i = if hi : i = last _ then last _ else i.castPred hi := by\n  split_ifs with hi\n  \u00b7 rw [hi, predAbove_right_last]\n  \u00b7 rw [predAbove_last_of_ne_last hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin (n + 2)\n\u22a2 (last n).predAbove i = if hi : i = last (n + 1) then last n else i.castPred hi"}, {"line": "split_ifs with hi", "tactic_state": "case pos\nn : \u2115\ni : Fin (n + 2)\nhi : i = last (n + 1)\n\u22a2 (last n).predAbove i = last n\n---\ncase neg\nn : \u2115\ni : Fin (n + 2)\nhi : \u00aci = last (n + 1)\n\u22a2 (last n).predAbove i = i.castPred hi"}, {"line": "\u00b7 rw [hi, predAbove_right_last]", "tactic_state": "case neg\nn : \u2115\ni : Fin (n + 2)\nhi : \u00aci = last (n + 1)\n\u22a2 (last n).predAbove i = i.castPred hi"}, {"line": "\u00b7 rw [predAbove_last_of_ne_last hi]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma succAbove_predAbove {p : Fin n} {i : Fin (n + 1)} (h : i \u2260 castSucc p) :\n    p.castSucc.succAbove (p.predAbove i) = i := by\n  obtain h | h := Fin.lt_or_lt_of_ne h\n  \u00b7 rw [predAbove_of_le_castSucc _ _ (Fin.le_of_lt h), succAbove_castPred_of_lt _ _ h]\n  \u00b7 rw [predAbove_of_castSucc_lt _ _ h, succAbove_pred_of_lt _ _ h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np : Fin n\ni : Fin (n + 1)\nh : i \u2260 p.castSucc\n\u22a2 p.castSucc.succAbove (p.predAbove i) = i"}, {"line": "obtain h | h := Fin.lt_or_lt_of_ne h", "tactic_state": "case inl\nn : \u2115\np : Fin n\ni : Fin (n + 1)\nh\u271d : i \u2260 p.castSucc\nh : i < p.castSucc\n\u22a2 p.castSucc.succAbove (p.predAbove i) = i\n---\ncase inr\nn : \u2115\np : Fin n\ni : Fin (n + 1)\nh\u271d : i \u2260 p.castSucc\nh : p.castSucc < i\n\u22a2 p.castSucc.succAbove (p.predAbove i) = i"}, {"line": "\u00b7 rw [predAbove_of_le_castSucc _ _ (Fin.le_of_lt h), succAbove_castPred_of_lt _ _ h]", "tactic_state": "case inr\nn : \u2115\np : Fin n\ni : Fin (n + 1)\nh\u271d : i \u2260 p.castSucc\nh : p.castSucc < i\n\u22a2 p.castSucc.succAbove (p.predAbove i) = i"}, {"line": "\u00b7 rw [predAbove_of_castSucc_lt _ _ h, succAbove_pred_of_lt _ _ h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma succ_succAbove_predAbove {n : \u2115} {p : Fin n} {i : Fin (n + 1)} (h : i \u2260 p.succ) :\n    p.succ.succAbove (p.predAbove i) = i := by\n  obtain h | h := Fin.lt_or_lt_of_ne h\n  \u00b7 rw [predAbove_of_le_castSucc _ _ (le_castSucc_iff.2 h),\n      succAbove_castPred_of_lt _ _ h]\n  \u00b7 rw [predAbove_of_castSucc_lt _ _ (Fin.lt_of_le_of_lt (p.castSucc_le_succ) h),\n      succAbove_pred_of_lt _ _ h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np : Fin n\ni : Fin (n + 1)\nh : i \u2260 p.succ\n\u22a2 p.succ.succAbove (p.predAbove i) = i"}, {"line": "obtain h | h := Fin.lt_or_lt_of_ne h", "tactic_state": "case inl\nn : \u2115\np : Fin n\ni : Fin (n + 1)\nh\u271d : i \u2260 p.succ\nh : i < p.succ\n\u22a2 p.succ.succAbove (p.predAbove i) = i\n---\ncase inr\nn : \u2115\np : Fin n\ni : Fin (n + 1)\nh\u271d : i \u2260 p.succ\nh : p.succ < i\n\u22a2 p.succ.succAbove (p.predAbove i) = i"}, {"line": "\u00b7 rw [predAbove_of_le_castSucc _ _ (le_castSucc_iff.2 h),\n      succAbove_castPred_of_lt _ _ h]", "tactic_state": "case inr\nn : \u2115\np : Fin n\ni : Fin (n + 1)\nh\u271d : i \u2260 p.succ\nh : p.succ < i\n\u22a2 p.succ.succAbove (p.predAbove i) = i"}, {"line": "\u00b7 rw [predAbove_of_castSucc_lt _ _ (Fin.lt_of_le_of_lt (p.castSucc_le_succ) h),\n      succAbove_pred_of_lt _ _ h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma predAbove_succAbove (p : Fin n) (i : Fin n) : p.predAbove ((castSucc p).succAbove i) = i := by\n  obtain h | h := p.le_or_lt i\n  \u00b7 rw [succAbove_castSucc_of_le _ _ h, predAbove_succ_of_le _ _ h]\n  \u00b7 rw [succAbove_castSucc_of_lt _ _ h, predAbove_castSucc_of_le _ _ <| Fin.le_of_lt h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np i : Fin n\n\u22a2 p.predAbove (p.castSucc.succAbove i) = i"}, {"line": "obtain h | h := p.le_or_lt i", "tactic_state": "case inl\nn : \u2115\np i : Fin n\nh : p \u2264 i\n\u22a2 p.predAbove (p.castSucc.succAbove i) = i\n---\ncase inr\nn : \u2115\np i : Fin n\nh : i < p\n\u22a2 p.predAbove (p.castSucc.succAbove i) = i"}, {"line": "\u00b7 rw [succAbove_castSucc_of_le _ _ h, predAbove_succ_of_le _ _ h]", "tactic_state": "case inr\nn : \u2115\np i : Fin n\nh : i < p\n\u22a2 p.predAbove (p.castSucc.succAbove i) = i"}, {"line": "\u00b7 rw [succAbove_castSucc_of_lt _ _ h, predAbove_castSucc_of_le _ _ <| Fin.le_of_lt h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem modNat_rev (i : Fin (m * n)) : i.rev.modNat = i.modNat.rev := by\n  ext\n  have H\u2081 : i % n + 1 \u2264 n := i.modNat.is_lt\n  have H\u2082 : i / n < m := i.divNat.is_lt\n  simp only [coe_modNat]\n  simp only [val_rev]\n  calc\n    (m * n - (i + 1)) % n = (m * n - ((i / n) * n + i % n + 1)) % n := by rw [Nat.div_add_mod']\n    _ = ((m - i / n - 1) * n + (n - (i % n + 1))) % n := by\n      rw [Nat.mul_sub_right_distrib]\n      rw [Nat.one_mul]\n      rw [Nat.sub_add_sub_cancel _ H\u2081]\n      rw [Nat.mul_sub_right_distrib]\n      rw [Nat.sub_sub]\n      rw [Nat.add_assoc]\n      exact Nat.le_mul_of_pos_left _ <| Nat.le_sub_of_add_le' H\u2082\n    _ = n - (i % n + 1) := by\n      rw [Nat.mul_comm]; exact i.modNat.rev.is_lt\n      rw [Nat.mul_add_mod]; exact i.modNat.rev.is_lt\n      rw [Nat.mod_eq_of_lt]; exact i.modNat.rev.is_lt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\ni : Fin (m * n)\n\u22a2 i.rev.modNat = i.modNat.rev"}, {"line": "ext", "tactic_state": "case h\nn m : \u2115\ni : Fin (m * n)\n\u22a2 \u2191i.rev.modNat = \u2191i.modNat.rev"}, {"line": "have H\u2081 : i % n + 1 \u2264 n := i.modNat.is_lt", "tactic_state": "case h\nn m : \u2115\ni : Fin (m * n)\nH\u2081 : \u2191i % n + 1 \u2264 n\n\u22a2 \u2191i.rev.modNat = \u2191i.modNat.rev"}, {"line": "have H\u2082 : i / n < m := i.divNat.is_lt", "tactic_state": "case h\nn m : \u2115\ni : Fin (m * n)\nH\u2081 : \u2191i % n + 1 \u2264 n\nH\u2082 : \u2191i / n < m\n\u22a2 \u2191i.rev.modNat = \u2191i.modNat.rev"}, {"line": "simp only [coe_modNat]", "tactic_state": "case h\nn m : \u2115\ni : Fin (m * n)\nH\u2081 : \u2191i % n + 1 \u2264 n\nH\u2082 : \u2191i / n < m\n\u22a2 \u2191i.rev % n = \u2191i.modNat.rev"}, {"line": "simp only [val_rev]", "tactic_state": "case h\nn m : \u2115\ni : Fin (m * n)\nH\u2081 : \u2191i % n + 1 \u2264 n\nH\u2082 : \u2191i / n < m\n\u22a2 (m * n - (\u2191i + 1)) % n = n - (\u2191i.modNat + 1)"}, {"line": "calc\n    (m * n - (i + 1)) % n = (m * n - ((i / n) * n + i % n + 1)) % n := by rw [Nat.div_add_mod']\n    _ = ((m - i / n - 1) * n + (n - (i % n + 1))) % n := by\n      rw [Nat.mul_sub_right_distrib]\n      rw [Nat.one_mul]\n      rw [Nat.sub_add_sub_cancel _ H\u2081]\n      rw [Nat.mul_sub_right_distrib]\n      rw [Nat.sub_sub]\n      rw [Nat.add_assoc]\n      exact Nat.le_mul_of_pos_left _ <| Nat.le_sub_of_add_le' H\u2082\n    _ = n - (i % n + 1) := by\n      rw [Nat.mul_comm]; exact i.modNat.rev.is_lt\n      rw [Nat.mul_add_mod]; exact i.modNat.rev.is_lt\n      rw [Nat.mod_eq_of_lt]; exact i.modNat.rev.is_lt", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_one_of_ne_zero (i : Fin 2) (hi : i \u2260 0) : i = 1 := by fin_omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int", "scoped Relator in", "Nat Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "i : Fin 2\nhi : i \u2260 0\n\u22a2 i = 1"}, {"line": "fin_omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_neg_one : \u2191(-1 : Fin (n + 1)) = n := by\n  cases n\n  \u00b7 simp\n  rw [Fin.coe_neg]\n  rw [Fin.val_one]\n  rw [Nat.add_one_sub_one]\n  rw [Nat.mod_eq_of_lt]\n  constructor\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int", "scoped Relator in", "Nat Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2191(-1) = n"}, {"line": "cases n", "tactic_state": "case zero\n\u22a2 \u2191(-1) = 0\n---\ncase succ\nn\u271d : \u2115\n\u22a2 \u2191(-1) = n\u271d + 1"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nn\u271d : \u2115\n\u22a2 \u2191(-1) = n\u271d + 1"}, {"line": "rw [Fin.coe_neg]", "tactic_state": "case succ\nn\u271d : \u2115\n\u22a2 (n\u271d + 1 + 1 - \u21911) % (n\u271d + 1 + 1) = n\u271d + 1"}, {"line": "rw [Fin.val_one]", "tactic_state": "case succ\nn\u271d : \u2115\n\u22a2 (n\u271d + 1 + 1 - 1) % (n\u271d + 1 + 1) = n\u271d + 1"}, {"line": "rw [Nat.add_one_sub_one]", "tactic_state": "case succ\nn\u271d : \u2115\n\u22a2 (n\u271d + 1) % (n\u271d + 1 + 1) = n\u271d + 1"}, {"line": "rw [Nat.mod_eq_of_lt]", "tactic_state": "case succ\nn\u271d : \u2115\n\u22a2 n\u271d + 1 < n\u271d + 1 + 1"}, {"line": "constructor", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_one_le_of_lt {n : \u2115} {a b : Fin (n + 1)} (h : a < b) : a + 1 \u2264 b := by\n  cases n <;> fin_omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int", "scoped Relator in", "Nat Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : Fin (n + 1)\nh : a < b\n\u22a2 a + 1 \u2264 b"}, {"line": "cases n <;> fin_omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_eq_add_of_le {n : \u2115} {a b : Fin n} (h : a \u2264 b) : \u2203 k \u2264 b, b = a + k := by\n  obtain \u27e8k, hk\u27e9 : \u2203 k : \u2115, (b : \u2115) = a + k := Nat.exists_eq_add_of_le h\n  have hkb : k \u2264 b := by omega\n  refine \u27e8\u27e8k, hkb.trans_lt b.is_lt\u27e9, hkb, ?_\u27e9\n  simp [Fin.ext_iff, Fin.val_add, \u2190 hk, Nat.mod_eq_of_lt b.is_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int", "scoped Relator in", "Nat Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : Fin n\nh : a \u2264 b\n\u22a2 \u2203 k \u2264 b, b = a + k"}, {"line": "obtain \u27e8k, hk\u27e9 : \u2203 k : \u2115, (b : \u2115) = a + k := Nat.exists_eq_add_of_le h", "tactic_state": "case intro\nn : \u2115\na b : Fin n\nh : a \u2264 b\nk : \u2115\nhk : \u2191b = \u2191a + k\n\u22a2 \u2203 k \u2264 b, b = a + k"}, {"line": "have hkb : k \u2264 b := sorry", "tactic_state": "case intro\nn : \u2115\na b : Fin n\nh : a \u2264 b\nk : \u2115\nhk : \u2191b = \u2191a + k\nhkb : k \u2264 \u2191b\n\u22a2 \u2203 k \u2264 b, b = a + k"}, {"line": "refine \u27e8\u27e8k, hkb.trans_lt b.is_lt\u27e9, hkb, ?_\u27e9", "tactic_state": "case intro\nn : \u2115\na b : Fin n\nh : a \u2264 b\nk : \u2115\nhk : \u2191b = \u2191a + k\nhkb : k \u2264 \u2191b\n\u22a2 b = a + \u27e8k, \u22ef\u27e9"}, {"line": "simp [Fin.ext_iff, Fin.val_add, \u2190 hk, Nat.mod_eq_of_lt b.is_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_eq_add_of_lt {n : \u2115} {a b : Fin (n + 1)} (h : a < b) :\n    \u2203 k < b, k + 1 \u2264 b \u2227 b = a + k + 1 := by\n  cases n\n  \u00b7 omega\n  obtain \u27e8k, hk\u27e9 : \u2203 k : \u2115, (b : \u2115) = a + k + 1 := Nat.exists_eq_add_of_lt h\n  have hkb : k < b := by omega\n  refine \u27e8\u27e8k, hkb.trans b.is_lt\u27e9, hkb, by fin_omega, ?_\u27e9\n  simp [Fin.ext_iff, Fin.val_add, \u2190 hk, Nat.mod_eq_of_lt b.is_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int", "scoped Relator in", "Nat Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : Fin (n + 1)\nh : a < b\n\u22a2 \u2203 k < b, k + 1 \u2264 b \u2227 b = a + k + 1"}, {"line": "cases n", "tactic_state": "case zero\na b : Fin (0 + 1)\nh : a < b\n\u22a2 \u2203 k < b, k + 1 \u2264 b \u2227 b = a + k + 1\n---\ncase succ\nn\u271d : \u2115\na b : Fin (n\u271d + 1 + 1)\nh : a < b\n\u22a2 \u2203 k < b, k + 1 \u2264 b \u2227 b = a + k + 1"}, {"line": "\u00b7 omega", "tactic_state": "case succ\nn\u271d : \u2115\na b : Fin (n\u271d + 1 + 1)\nh : a < b\n\u22a2 \u2203 k < b, k + 1 \u2264 b \u2227 b = a + k + 1"}, {"line": "obtain \u27e8k, hk\u27e9 : \u2203 k : \u2115, (b : \u2115) = a + k + 1 := Nat.exists_eq_add_of_lt h", "tactic_state": "case succ.intro\nn\u271d : \u2115\na b : Fin (n\u271d + 1 + 1)\nh : a < b\nk : \u2115\nhk : \u2191b = \u2191a + k + 1\n\u22a2 \u2203 k < b, k + 1 \u2264 b \u2227 b = a + k + 1"}, {"line": "have hkb : k < b := sorry", "tactic_state": "case succ.intro\nn\u271d : \u2115\na b : Fin (n\u271d + 1 + 1)\nh : a < b\nk : \u2115\nhk : \u2191b = \u2191a + k + 1\nhkb : k < \u2191b\n\u22a2 \u2203 k < b, k + 1 \u2264 b \u2227 b = a + k + 1"}, {"line": "refine \u27e8\u27e8k, hkb.trans b.is_lt\u27e9, hkb, by fin_omega, ?_\u27e9", "tactic_state": "case succ.intro\nn\u271d : \u2115\na b : Fin (n\u271d + 1 + 1)\nh : a < b\nk : \u2115\nhk : \u2191b = \u2191a + k + 1\nhkb : k < \u2191b\n\u22a2 b = a + \u27e8k, \u22ef\u27e9 + 1"}, {"line": "simp [Fin.ext_iff, Fin.val_add, \u2190 hk, Nat.mod_eq_of_lt b.is_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub_succ_le_sub_of_le {n : \u2115} {u v : Fin (n + 2)} (h : u < v) : v - (u + 1) < v - u := by\n  fin_omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Basic.lean", "context": {"open": ["Fin Nat Function", "Int", "scoped Relator in", "Nat Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nu v : Fin (n + 2)\nh : u < v\n\u22a2 v - (u + 1) < v - u"}, {"line": "fin_omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem even_succAbove_add_predAbove (i : Fin (n + 1)) (j : Fin n) :\n    Even (i.succAbove j + j.predAbove i : \u2115) \u2194 Odd (i + j : \u2115) := by\n  rcases lt_or_le j.castSucc i with hji | hij\n  \u00b7 have : 1 \u2264 (i : \u2115) := (Nat.zero_le j).trans_lt hji\n    simp [succAbove_of_castSucc_lt _ _ hji, predAbove_of_castSucc_lt _ _ hji, this, iff_comm,\n      parity_simps]\n  \u00b7 simp [succAbove_of_le_castSucc _ _ hij, predAbove_of_le_castSucc _ _ hij,\n      \u2190 Nat.not_even_iff_odd, not_iff, not_iff_comm, parity_simps]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Parity.lean", "context": {"open": ["Fin"], "variables": ["{n : \u2115} {k : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin (n + 1)\nj : Fin n\n\u22a2 Even (\u2191(i.succAbove j) + \u2191(j.predAbove i)) \u2194 Odd (\u2191i + \u2191j)"}, {"line": "rcases lt_or_le j.castSucc i with hji | hij", "tactic_state": "case inl\nn : \u2115\ni : Fin (n + 1)\nj : Fin n\nhji : j.castSucc < i\n\u22a2 Even (\u2191(i.succAbove j) + \u2191(j.predAbove i)) \u2194 Odd (\u2191i + \u2191j)\n---\ncase inr\nn : \u2115\ni : Fin (n + 1)\nj : Fin n\nhij : i \u2264 j.castSucc\n\u22a2 Even (\u2191(i.succAbove j) + \u2191(j.predAbove i)) \u2194 Odd (\u2191i + \u2191j)"}, {"line": "\u00b7 have : 1 \u2264 (i : \u2115) := (Nat.zero_le j).trans_lt hji\n    simp [succAbove_of_castSucc_lt _ _ hji, predAbove_of_castSucc_lt _ _ hji, this, iff_comm,\n      parity_simps]", "tactic_state": "case inr\nn : \u2115\ni : Fin (n + 1)\nj : Fin n\nhij : i \u2264 j.castSucc\n\u22a2 Even (\u2191(i.succAbove j) + \u2191(j.predAbove i)) \u2194 Odd (\u2191i + \u2191j)"}, {"line": "\u00b7 simp [succAbove_of_le_castSucc _ _ hij, predAbove_of_le_castSucc _ _ hij,\n      \u2190 Nat.not_even_iff_odd, not_iff, not_iff_comm, parity_simps]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma even_of_val (h : Even k.val) : Even k := by\n  have : NeZero n := \u27e8k.pos.ne'\u27e9\n  rw [\u2190 Fin.cast_val_eq_self k]\n  exact h.natCast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Parity.lean", "context": {"open": ["Fin"], "variables": ["{n : \u2115} {k : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nk : Fin n\nh : Even \u2191k\n\u22a2 Even k"}, {"line": "have : NeZero n := \u27e8k.pos.ne'\u27e9", "tactic_state": "n : \u2115\nk : Fin n\nh : Even \u2191k\nthis : NeZero n\n\u22a2 Even k"}, {"line": "rw [\u2190 Fin.cast_val_eq_self k]", "tactic_state": "n : \u2115\nk : Fin n\nh : Even \u2191k\nthis : NeZero n\n\u22a2 Even \u2191\u2191k"}, {"line": "exact h.natCast", "tactic_state": "No Goals!"}]}
{"declaration": "lemma even_of_odd (hn : Odd n) (k : Fin n) : Even k := by\n  have : NeZero n := \u27e8k.pos.ne'\u27e9\n  rcases k.val.even_or_odd with hk | hk\n  \u00b7 exact even_of_val hk\n  \u00b7 simpa using (hk.add_odd hn).natCast (\u03b1 := Fin n)\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Parity.lean", "context": {"open": ["Fin"], "variables": ["{n : \u2115} {k : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : Odd n\nk : Fin n\n\u22a2 Even k"}, {"line": "have : NeZero n := \u27e8k.pos.ne'\u27e9", "tactic_state": "n : \u2115\nhn : Odd n\nk : Fin n\nthis : NeZero n\n\u22a2 Even k"}, {"line": "rcases k.val.even_or_odd with hk | hk", "tactic_state": "case inl\nn : \u2115\nhn : Odd n\nk : Fin n\nthis : NeZero n\nhk : Even \u2191k\n\u22a2 Even k\n---\ncase inr\nn : \u2115\nhn : Odd n\nk : Fin n\nthis : NeZero n\nhk : Odd \u2191k\n\u22a2 Even k"}, {"line": "\u00b7 exact even_of_val hk", "tactic_state": "case inr\nn : \u2115\nhn : Odd n\nk : Fin n\nthis : NeZero n\nhk : Odd \u2191k\n\u22a2 Even k"}, {"line": "\u00b7 simpa using (hk.add_odd hn).natCast (\u03b1 := Fin n)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma odd_of_odd [NeZero n] (hn : Odd n) (k : Fin n) : Odd k := by\n  rcases k.val.even_or_odd with hk | hk\n  \u00b7 simpa using (Even.add_odd hk hn).natCast (R := Fin n)\n  \u00b7 exact odd_of_val hk\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Parity.lean", "context": {"open": ["Fin"], "variables": ["{n : \u2115} {k : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\nhn : Odd n\nk : Fin n\n\u22a2 Odd k"}, {"line": "rcases k.val.even_or_odd with hk | hk", "tactic_state": "case inl\nn : \u2115\ninst\u271d : NeZero n\nhn : Odd n\nk : Fin n\nhk : Even \u2191k\n\u22a2 Odd k\n---\ncase inr\nn : \u2115\ninst\u271d : NeZero n\nhn : Odd n\nk : Fin n\nhk : Odd \u2191k\n\u22a2 Odd k"}, {"line": "\u00b7 simpa using (Even.add_odd hk hn).natCast (R := Fin n)", "tactic_state": "case inr\nn : \u2115\ninst\u271d : NeZero n\nhn : Odd n\nk : Fin n\nhk : Odd \u2191k\n\u22a2 Odd k"}, {"line": "\u00b7 exact odd_of_val hk", "tactic_state": "No Goals!"}]}
{"declaration": "lemma even_iff_of_even (hn : Even n) : Even k \u2194 Even k.val := by\n  rcases hn with \u27e8n, rfl\u27e9\n  refine \u27e8?_, even_of_val\u27e9\n  rintro \u27e8l, rfl\u27e9\n  rw [val_add_eq_ite]\n  split_ifs with h <;> simp [Nat.even_sub, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Parity.lean", "context": {"open": ["Fin"], "variables": ["{n : \u2115} {k : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nk : Fin n\nhn : Even n\n\u22a2 Even k \u2194 Even \u2191k"}, {"line": "rcases hn with \u27e8n, rfl\u27e9", "tactic_state": "case intro\nn : \u2115\nk : Fin (n + n)\n\u22a2 Even k \u2194 Even \u2191k"}, {"line": "refine \u27e8?_, even_of_val\u27e9", "tactic_state": "case intro\nn : \u2115\nk : Fin (n + n)\n\u22a2 Even k \u2192 Even \u2191k"}, {"line": "rintro \u27e8l, rfl\u27e9", "tactic_state": "case intro.intro\nn : \u2115\nl : Fin (n + n)\n\u22a2 Even \u2191(l + l)"}, {"line": "rw [val_add_eq_ite]", "tactic_state": "case intro.intro\nn : \u2115\nl : Fin (n + n)\n\u22a2 Even (if n + n \u2264 \u2191l + \u2191l then \u2191l + \u2191l - (n + n) else \u2191l + \u2191l)"}, {"line": "split_ifs with h <;> simp [Nat.even_sub, *]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma even_iff : Even k \u2194 (Odd n \u2228 Even k.val) := by\n  refine \u27e8fun hk \u21a6 ?_, or_imp.mpr \u27e8(even_of_odd \u00b7 k), even_of_val\u27e9\u27e9\n  rw [\u2190 Nat.not_even_iff_odd]\n  rw [\u2190 imp_iff_not_or]\n  exact fun hn \u21a6 (even_iff_of_even hn).mp hk\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Parity.lean", "context": {"open": ["Fin"], "variables": ["{n : \u2115} {k : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nk : Fin n\n\u22a2 Even k \u2194 Odd n \u2228 Even \u2191k"}, {"line": "refine \u27e8fun hk \u21a6 ?_, or_imp.mpr \u27e8(even_of_odd \u00b7 k), even_of_val\u27e9\u27e9", "tactic_state": "n : \u2115\nk : Fin n\nhk : Even k\n\u22a2 Odd n \u2228 Even \u2191k"}, {"line": "rw [\u2190 Nat.not_even_iff_odd]", "tactic_state": "n : \u2115\nk : Fin n\nhk : Even k\n\u22a2 \u00acEven n \u2228 Even \u2191k"}, {"line": "rw [\u2190 imp_iff_not_or]", "tactic_state": "n : \u2115\nk : Fin n\nhk : Even k\n\u22a2 Even n \u2192 Even \u2191k"}, {"line": "exact fun hn \u21a6 (even_iff_of_even hn).mp hk", "tactic_state": "No Goals!"}]}
{"declaration": "lemma even_iff_imp : Even k \u2194 (Even n \u2192 Even k.val) := by\n  rw [imp_iff_not_or]\n  rw [Nat.not_even_iff_odd]\n  exact even_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Parity.lean", "context": {"open": ["Fin"], "variables": ["{n : \u2115} {k : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nk : Fin n\n\u22a2 Even k \u2194 Even n \u2192 Even \u2191k"}, {"line": "rw [imp_iff_not_or]", "tactic_state": "n : \u2115\nk : Fin n\n\u22a2 Even k \u2194 \u00acEven n \u2228 Even \u2191k"}, {"line": "rw [Nat.not_even_iff_odd]", "tactic_state": "n : \u2115\nk : Fin n\n\u22a2 Even k \u2194 Odd n \u2228 Even \u2191k"}, {"line": "exact even_iff", "tactic_state": "No Goals!"}]}
{"declaration": "lemma odd_iff_imp [NeZero n] : Odd k \u2194 (Even n \u2192 Odd k.val) := by\n  rw [imp_iff_not_or]\n  rw [Nat.not_even_iff_odd]\n  exact odd_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Parity.lean", "context": {"open": ["Fin"], "variables": ["{n : \u2115} {k : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nk : Fin n\ninst\u271d : NeZero n\n\u22a2 Odd k \u2194 Even n \u2192 Odd \u2191k"}, {"line": "rw [imp_iff_not_or]", "tactic_state": "n : \u2115\nk : Fin n\ninst\u271d : NeZero n\n\u22a2 Odd k \u2194 \u00acEven n \u2228 Odd \u2191k"}, {"line": "rw [Nat.not_even_iff_odd]", "tactic_state": "n : \u2115\nk : Fin n\ninst\u271d : NeZero n\n\u22a2 Odd k \u2194 Odd n \u2228 Odd \u2191k"}, {"line": "exact odd_iff", "tactic_state": "No Goals!"}]}
{"declaration": "lemma even_iff_mod_of_even (hn : Even n) : Even k \u2194 k.val % 2 = 0 := by\n  rw [even_iff_of_even hn]\n  exact Nat.even_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Parity.lean", "context": {"open": ["Fin"], "variables": ["{n : \u2115} {k : Fin n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nk : Fin n\nhn : Even n\n\u22a2 Even k \u2194 \u2191k % 2 = 0"}, {"line": "rw [even_iff_of_even hn]", "tactic_state": "n : \u2115\nk : Fin n\nhn : Even n\n\u22a2 Even \u2191k \u2194 \u2191k % 2 = 0"}, {"line": "exact Nat.even_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rev_eq_iff {i j : Fin n} : rev i = j \u2194 i = rev j := by\n  rw [\u2190 rev_inj]\n  rw [rev_rev]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Rev.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 i.rev = j \u2194 i = j.rev"}, {"line": "rw [\u2190 rev_inj]", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 i.rev.rev = j.rev \u2194 i = j.rev"}, {"line": "rw [rev_rev]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rev_lt_iff {i j : Fin n} : rev i < j \u2194 rev j < i := by\n  rw [\u2190 rev_lt_rev]\n  rw [rev_rev]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Rev.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 i.rev < j \u2194 j.rev < i"}, {"line": "rw [\u2190 rev_lt_rev]", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 j.rev < i.rev.rev \u2194 j.rev < i"}, {"line": "rw [rev_rev]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rev_le_iff {i j : Fin n} : rev i \u2264 j \u2194 rev j \u2264 i := by\n  rw [\u2190 rev_le_rev]\n  rw [rev_rev]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Rev.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 i.rev \u2264 j \u2194 j.rev \u2264 i"}, {"line": "rw [\u2190 rev_le_rev]", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 j.rev \u2264 i.rev.rev \u2194 j.rev \u2264 i"}, {"line": "rw [rev_rev]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_rev_iff {i j : Fin n} : i < rev j \u2194 j < rev i := by\n  rw [\u2190 rev_lt_rev]\n  rw [rev_rev]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Rev.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 i < j.rev \u2194 j < i.rev"}, {"line": "rw [\u2190 rev_lt_rev]", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 j.rev.rev < i.rev \u2194 j < i.rev"}, {"line": "rw [rev_rev]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_rev_iff {i j : Fin n} : i \u2264 rev j \u2194 j \u2264 rev i := by\n  rw [\u2190 rev_le_rev]\n  rw [rev_rev]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Rev.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 i \u2264 j.rev \u2194 j \u2264 i.rev"}, {"line": "rw [\u2190 rev_le_rev]", "tactic_state": "n : \u2115\ni j : Fin n\n\u22a2 j.rev.rev \u2264 i.rev \u2194 j \u2264 i.rev"}, {"line": "rw [rev_rev]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma succAbove_rev_left (p : Fin (n + 1)) (i : Fin n) :\n    p.rev.succAbove i = (p.succAbove i.rev).rev := by\n  obtain h | h := (rev p).succ_le_or_le_castSucc i\n  \u00b7 rw [succAbove_of_succ_le _ _ h,\n      succAbove_of_le_castSucc _ _ (rev_succ _ \u25b8 (le_rev_iff.mpr h)), rev_succ, rev_rev]\n  \u00b7 rw [succAbove_of_le_castSucc _ _ h,\n      succAbove_of_succ_le _ _ (rev_castSucc _ \u25b8 (rev_le_iff.mpr h)), rev_castSucc, rev_rev]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Rev.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np : Fin (n + 1)\ni : Fin n\n\u22a2 p.rev.succAbove i = (p.succAbove i.rev).rev"}, {"line": "obtain h | h := (rev p).succ_le_or_le_castSucc i", "tactic_state": "case inl\nn : \u2115\np : Fin (n + 1)\ni : Fin n\nh : i.succ \u2264 p.rev\n\u22a2 p.rev.succAbove i = (p.succAbove i.rev).rev\n---\ncase inr\nn : \u2115\np : Fin (n + 1)\ni : Fin n\nh : p.rev \u2264 i.castSucc\n\u22a2 p.rev.succAbove i = (p.succAbove i.rev).rev"}, {"line": "\u00b7 rw [succAbove_of_succ_le _ _ h,\n      succAbove_of_le_castSucc _ _ (rev_succ _ \u25b8 (le_rev_iff.mpr h)), rev_succ, rev_rev]", "tactic_state": "case inr\nn : \u2115\np : Fin (n + 1)\ni : Fin n\nh : p.rev \u2264 i.castSucc\n\u22a2 p.rev.succAbove i = (p.succAbove i.rev).rev"}, {"line": "\u00b7 rw [succAbove_of_le_castSucc _ _ h,\n      succAbove_of_succ_le _ _ (rev_castSucc _ \u25b8 (rev_le_iff.mpr h)), rev_castSucc, rev_rev]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma succAbove_rev_right (p : Fin (n + 1)) (i : Fin n) :\n    p.succAbove i.rev = (p.rev.succAbove i).rev := by rw [succAbove_rev_left, rev_rev]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Rev.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np : Fin (n + 1)\ni : Fin n\n\u22a2 p.succAbove i.rev = (p.rev.succAbove i).rev"}, {"line": "rw [succAbove_rev_left, rev_rev]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rev_succAbove (p : Fin (n + 1)) (i : Fin n) :\n    rev (succAbove p i) = succAbove (rev p) (rev i) := by\n  rw [succAbove_rev_left]\n  rw [rev_rev]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Rev.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np : Fin (n + 1)\ni : Fin n\n\u22a2 (p.succAbove i).rev = p.rev.succAbove i.rev"}, {"line": "rw [succAbove_rev_left]", "tactic_state": "n : \u2115\np : Fin (n + 1)\ni : Fin n\n\u22a2 (p.succAbove i).rev = (p.succAbove i.rev.rev).rev"}, {"line": "rw [rev_rev]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma predAbove_rev_left (p : Fin n) (i : Fin (n + 1)) :\n    p.rev.predAbove i = (p.predAbove i.rev).rev := by\n  obtain h | h := (rev i).succ_le_or_le_castSucc p\n  \u00b7 rw [predAbove_of_succ_le _ _ h, rev_pred,\n      predAbove_of_le_castSucc _ _ (rev_succ _ \u25b8 (le_rev_iff.mpr h)), castPred_inj, rev_rev]\n  \u00b7 rw [predAbove_of_le_castSucc _ _ h, rev_castPred,\n      predAbove_of_succ_le _ _ (rev_castSucc _ \u25b8 (rev_le_iff.mpr h)), pred_inj, rev_rev]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Rev.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np : Fin n\ni : Fin (n + 1)\n\u22a2 p.rev.predAbove i = (p.predAbove i.rev).rev"}, {"line": "obtain h | h := (rev i).succ_le_or_le_castSucc p", "tactic_state": "case inl\nn : \u2115\np : Fin n\ni : Fin (n + 1)\nh : p.succ \u2264 i.rev\n\u22a2 p.rev.predAbove i = (p.predAbove i.rev).rev\n---\ncase inr\nn : \u2115\np : Fin n\ni : Fin (n + 1)\nh : i.rev \u2264 p.castSucc\n\u22a2 p.rev.predAbove i = (p.predAbove i.rev).rev"}, {"line": "\u00b7 rw [predAbove_of_succ_le _ _ h, rev_pred,\n      predAbove_of_le_castSucc _ _ (rev_succ _ \u25b8 (le_rev_iff.mpr h)), castPred_inj, rev_rev]", "tactic_state": "case inr\nn : \u2115\np : Fin n\ni : Fin (n + 1)\nh : i.rev \u2264 p.castSucc\n\u22a2 p.rev.predAbove i = (p.predAbove i.rev).rev"}, {"line": "\u00b7 rw [predAbove_of_le_castSucc _ _ h, rev_castPred,\n      predAbove_of_succ_le _ _ (rev_castSucc _ \u25b8 (rev_le_iff.mpr h)), pred_inj, rev_rev]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma predAbove_rev_right (p : Fin n) (i : Fin (n + 1)) :\n    p.predAbove i.rev = (p.rev.predAbove i).rev := by rw [predAbove_rev_left, rev_rev]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Rev.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np : Fin n\ni : Fin (n + 1)\n\u22a2 p.predAbove i.rev = (p.rev.predAbove i).rev"}, {"line": "rw [predAbove_rev_left, rev_rev]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rev_predAbove {n : \u2115} (p : Fin n) (i : Fin (n + 1)) :\n    (predAbove p i).rev = predAbove p.rev i.rev := by rw [predAbove_rev_left, rev_rev]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Rev.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np : Fin n\ni : Fin (n + 1)\n\u22a2 (p.predAbove i).rev = p.rev.predAbove i.rev"}, {"line": "rw [predAbove_rev_left, rev_rev]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_rev_cast (j : Fin (n+1)) : j.1 + j.rev.1 = n := by\n  obtain \u27e8j, hj\u27e9 := j\n  simp [Nat.add_sub_cancel' <| le_of_lt_succ hj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Rev.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nj : Fin (n + 1)\n\u22a2 \u2191j + \u2191j.rev = n"}, {"line": "obtain \u27e8j, hj\u27e9 := j", "tactic_state": "case mk\nn j : \u2115\nhj : j < n + 1\n\u22a2 \u2191\u27e8j, hj\u27e9 + \u2191\u27e8j, hj\u27e9.rev = n"}, {"line": "simp [Nat.add_sub_cancel' <| le_of_lt_succ hj]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rev_add_cast (j : Fin (n+1)) : j.rev.1 + j.1 = n := by\n  rw [Nat.add_comm]\n  rw [j.add_rev_cast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Rev.lean", "context": {"open": ["Fin Nat Function"], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nj : Fin (n + 1)\n\u22a2 \u2191j.rev + \u2191j = n"}, {"line": "rw [Nat.add_comm]", "tactic_state": "n : \u2115\nj : Fin (n + 1)\n\u22a2 \u2191j + \u2191j.rev = n"}, {"line": "rw [j.add_rev_cast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem take_eq_self (v : (i : Fin n) \u2192 \u03b1 i) : take n (le_refl n) v = v := by\n  ext i\n  simp [take]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Take.lean", "context": {"open": ["Function"], "variables": ["{n : \u2115} {\u03b1 : Fin n \u2192 Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b1 : Fin n \u2192 Sort u_1\nx\u271d : Sort u_2\ntake : x\u271d\nv : (i : Fin n) \u2192 \u03b1 i\n\u22a2 sorry = v"}, {"line": "ext i", "tactic_state": "case h\nn : \u2115\n\u03b1 : Fin n \u2192 Sort u_1\nx\u271d : Sort u_2\ntake : x\u271d\nv : (i : Fin n) \u2192 \u03b1 i\ni : Fin n\n\u22a2 sorry i = v i"}, {"line": "simp [take]", "tactic_state": "case h\nn : \u2115\n\u03b1 : Fin n \u2192 Sort u_1\nx\u271d : Sort u_2\ntake : x\u271d\nv : (i : Fin n) \u2192 \u03b1 i\ni : Fin n\n\u22a2 sorry () i = v i"}]}
{"declaration": "theorem get_take_ofFn_eq_take_comp_cast {\u03b1 : Type*} {m : \u2115} (v : Fin n \u2192 \u03b1) (h : m \u2264 n) :\n    ((List.ofFn v).take m).get = take m h v \u2218 Fin.cast (by simp [h]) := by\n  ext i\n  simp [castLE]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Take.lean", "context": {"open": ["Function"], "variables": ["{n : \u2115} {\u03b1 : Fin n \u2192 Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_3\ntake : x\u271d\n\u03b1 : Type u_2\nm : \u2115\nv : Fin n \u2192 \u03b1\nh : m \u2264 n\n\u22a2 (List.take m (List.ofFn v)).get = sorry \u2218 Fin.cast \u22ef"}, {"line": "ext i", "tactic_state": "case h\nn : \u2115\nx\u271d : Sort u_3\ntake : x\u271d\n\u03b1 : Type u_2\nm : \u2115\nv : Fin n \u2192 \u03b1\nh : m \u2264 n\ni : Fin (List.take m (List.ofFn v)).length\n\u22a2 (List.take m (List.ofFn v)).get i = (sorry \u2218 Fin.cast \u22ef) i"}, {"line": "simp [castLE]", "tactic_state": "case h\nn : \u2115\nx\u271d : Sort u_3\ntake : x\u271d\n\u03b1 : Type u_2\nm : \u2115\nv : Fin n \u2192 \u03b1\nh : m \u2264 n\ni : Fin (List.take m (List.ofFn v)).length\n\u22a2 v \u27e8\u2191i, \u22ef\u27e9 = sorry () (Fin.cast \u22ef i)"}]}
{"declaration": "example (\u03b1 : Fin 0 \u2192 Sort u) : Unique (\u2200 i : Fin 0, \u03b1 i) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u03b1 : Fin 0 \u2192 Sort u\n\u22a2 Unique ((i : Fin 0) \u2192 \u03b1 i)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tail_cons : tail (cons x p) = p := by\n  simp +unfoldPartialApp [tail, cons]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Sort u\np : (i : Fin n) \u2192 \u03b1 i.succ\nx\u271d : Sort u_1\ntail : x\u271d\n\u22a2 sorry = p"}, {"line": "simp +unfoldPartialApp [tail, cons]", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Sort u\np : (i : Fin n) \u2192 \u03b1 i.succ\nx\u271d : Sort u_1\ntail : x\u271d\n\u22a2 sorry () = p"}]}
{"declaration": "theorem cons_succ : cons x p i.succ = p i := by simp [cons]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Sort u\np : (i : Fin n) \u2192 \u03b1 i.succ\ni : Fin n\nx\u271d : Sort u_1\ncons : x\u271d\n\u22a2 sorry = p i"}, {"line": "simp [cons]", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Sort u\np : (i : Fin n) \u2192 \u03b1 i.succ\ni : Fin n\nx\u271d : Sort u_1\ncons : x\u271d\n\u22a2 sorry () = p i"}]}
{"declaration": "theorem cons_zero : cons x p 0 = x := by simp [cons]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Sort u\nx : \u03b1 0\nx\u271d : Sort u_1\ncons : x\u271d\n\u22a2 sorry = x"}, {"line": "simp [cons]", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Sort u\nx : \u03b1 0\nx\u271d : Sort u_1\ncons : x\u271d\n\u22a2 sorry () = x"}]}
{"declaration": "theorem append_left_eq_cons {n : \u2115} (x\u2080 : Fin 1 \u2192 \u03b1) (x : Fin n \u2192 \u03b1) :\n    Fin.append x\u2080 x = Fin.cons (x\u2080 0) x \u2218 Fin.cast (Nat.add_comm ..) := by\n  ext i\n  refine Fin.addCases ?_ ?_ i <;> clear i\n  \u00b7 intro i\n    rw [Subsingleton.elim i 0]\n    rw [Fin.append_left]\n    rw [Function.comp_apply]\n    rw [eq_comm]\n    exact Fin.cons_zero _ _\n  \u00b7 intro i\n    rw [Fin.append_right]\n    rw [Function.comp_apply]\n    rw [Fin.cast_natAdd]\n    rw [eq_comm]\n    rw [Fin.addNat_one]\n    exact Fin.cons_succ _ _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)", "{\u03b1 : Fin (n + 1) \u2192 Type*}", "{\u03b1 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_2\nn : \u2115\nx\u2080 : Fin 1 \u2192 \u03b1\nx : Fin n \u2192 \u03b1\n\u22a2 Fin.append x\u2080 x = Fin.cons (x\u2080 0) x \u2218 Fin.cast \u22ef"}, {"line": "ext i", "tactic_state": "case h\n\u03b1 : Sort u_2\nn : \u2115\nx\u2080 : Fin 1 \u2192 \u03b1\nx : Fin n \u2192 \u03b1\ni : Fin (1 + n)\n\u22a2 Fin.append x\u2080 x i = (Fin.cons (x\u2080 0) x \u2218 Fin.cast \u22ef) i"}, {"line": "refine Fin.addCases ?_ ?_ i <;> clear i", "tactic_state": "case h.refine_1\n\u03b1 : Sort u_2\nn : \u2115\nx\u2080 : Fin 1 \u2192 \u03b1\nx : Fin n \u2192 \u03b1\n\u22a2 \u2200 (i : Fin 1), Fin.append x\u2080 x (Fin.castAdd n i) = (Fin.cons (x\u2080 0) x \u2218 Fin.cast \u22ef) (Fin.castAdd n i)\n---\ncase h.refine_2\n\u03b1 : Sort u_2\nn : \u2115\nx\u2080 : Fin 1 \u2192 \u03b1\nx : Fin n \u2192 \u03b1\n\u22a2 \u2200 (i : Fin n), Fin.append x\u2080 x (Fin.natAdd 1 i) = (Fin.cons (x\u2080 0) x \u2218 Fin.cast \u22ef) (Fin.natAdd 1 i)"}, {"line": "\u00b7 intro i\n    rw [Subsingleton.elim i 0]\n    rw [Fin.append_left]\n    rw [Function.comp_apply]\n    rw [eq_comm]\n    exact Fin.cons_zero _ _", "tactic_state": "case h.refine_2\n\u03b1 : Sort u_2\nn : \u2115\nx\u2080 : Fin 1 \u2192 \u03b1\nx : Fin n \u2192 \u03b1\n\u22a2 \u2200 (i : Fin n), Fin.append x\u2080 x (Fin.natAdd 1 i) = (Fin.cons (x\u2080 0) x \u2218 Fin.cast \u22ef) (Fin.natAdd 1 i)"}, {"line": "\u00b7 intro i\n    rw [Fin.append_right]\n    rw [Function.comp_apply]\n    rw [Fin.cast_natAdd]\n    rw [eq_comm]\n    rw [Fin.addNat_one]\n    exact Fin.cons_succ _ _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem repeat_one (a : Fin n \u2192 \u03b1) : Fin.repeat 1 a = a \u2218 Fin.cast (Nat.one_mul _) := by\n  generalize_proofs h\n  apply funext\n  rw [(Fin.rightInverse_cast h.symm).surjective.forall]\n  intro i\n  simp [modNat, Nat.mod_eq_of_lt i.is_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)", "{\u03b1 : Fin (n + 1) \u2192 Type*}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b1 : Sort u_3\na : Fin n \u2192 \u03b1\n\u22a2 Fin.repeat 1 a = a \u2218 Fin.cast \u22ef"}, {"line": "generalize_proofs h", "tactic_state": "n : \u2115\n\u03b1 : Sort u_3\na : Fin n \u2192 \u03b1\nh : 1 * n = n\n\u22a2 Fin.repeat 1 a = a \u2218 Fin.cast h"}, {"line": "apply funext", "tactic_state": "case h\nn : \u2115\n\u03b1 : Sort u_3\na : Fin n \u2192 \u03b1\nh : 1 * n = n\n\u22a2 \u2200 (x : Fin (1 * n)), Fin.repeat 1 a x = (a \u2218 Fin.cast h) x"}, {"line": "rw [(Fin.rightInverse_cast h.symm).surjective.forall]", "tactic_state": "case h\nn : \u2115\n\u03b1 : Sort u_3\na : Fin n \u2192 \u03b1\nh : 1 * n = n\n\u22a2 \u2200 (x : Fin n), Fin.repeat 1 a (Fin.cast \u22ef x) = (a \u2218 Fin.cast h) (Fin.cast \u22ef x)"}, {"line": "intro i", "tactic_state": "case h\nn : \u2115\n\u03b1 : Sort u_3\na : Fin n \u2192 \u03b1\nh : 1 * n = n\ni : Fin n\n\u22a2 Fin.repeat 1 a (Fin.cast \u22ef i) = (a \u2218 Fin.cast h) (Fin.cast \u22ef i)"}, {"line": "simp [modNat, Nat.mod_eq_of_lt i.is_lt]", "tactic_state": "case h\nn : \u2115\n\u03b1 : Sort u_3\na : Fin n \u2192 \u03b1\nh : 1 * n = n\ni : Fin n\n\u22a2 a (Fin.cast \u22ef i).modNat = a i"}]}
{"declaration": "theorem repeat_succ (a : Fin n \u2192 \u03b1) (m : \u2115) :\n    Fin.repeat m.succ a =\n      append a (Fin.repeat m a) \u2218 Fin.cast ((Nat.succ_mul _ _).trans (Nat.add_comm ..)) := by\n  generalize_proofs h\n  apply funext\n  rw [(Fin.rightInverse_cast h.symm).surjective.forall]\n  refine Fin.addCases (fun l => ?_) fun r => ?_\n  \u00b7 simp [modNat, Nat.mod_eq_of_lt l.is_lt]\n  \u00b7 simp [modNat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)", "{\u03b1 : Fin (n + 1) \u2192 Type*}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b1 : Sort u_3\nx\u271d : Sort u_4\nappend : x\u271d\na : Fin n \u2192 \u03b1\nm : \u2115\n\u22a2 Fin.repeat m.succ a = sorry \u2218 Fin.cast \u22ef"}, {"line": "generalize_proofs h", "tactic_state": "n : \u2115\n\u03b1 : Sort u_3\nx\u271d : Sort u_4\nappend : x\u271d\na : Fin n \u2192 \u03b1\nm : \u2115\nh : m.succ * n = n + m * n\n\u22a2 Fin.repeat m.succ a = sorry \u2218 Fin.cast h"}, {"line": "apply funext", "tactic_state": "case h\nn : \u2115\n\u03b1 : Sort u_3\nx\u271d : Sort u_4\nappend : x\u271d\na : Fin n \u2192 \u03b1\nm : \u2115\nh : m.succ * n = n + m * n\n\u22a2 \u2200 (x : Fin (m.succ * n)), Fin.repeat m.succ a x = (sorry \u2218 Fin.cast h) x"}, {"line": "rw [(Fin.rightInverse_cast h.symm).surjective.forall]", "tactic_state": "case h\nn : \u2115\n\u03b1 : Sort u_3\nx\u271d : Sort u_4\nappend : x\u271d\na : Fin n \u2192 \u03b1\nm : \u2115\nh : m.succ * n = n + m * n\n\u22a2 \u2200 (x : Fin (n + m * n)), Fin.repeat m.succ a (Fin.cast \u22ef x) = (sorry \u2218 Fin.cast h) (Fin.cast \u22ef x)"}, {"line": "refine Fin.addCases (fun l => ?_) fun r => ?_", "tactic_state": "case h.refine_1\nn : \u2115\n\u03b1 : Sort u_3\nx\u271d : Sort u_4\nappend : x\u271d\na : Fin n \u2192 \u03b1\nm : \u2115\nh : m.succ * n = n + m * n\nl : Fin n\n\u22a2 Fin.repeat m.succ a (Fin.cast \u22ef (Fin.castAdd (m * n) l)) = (sorry \u2218 Fin.cast h) (Fin.cast \u22ef (Fin.castAdd (m * n) l))\n---\ncase h.refine_2\nn : \u2115\n\u03b1 : Sort u_3\nx\u271d : Sort u_4\nappend : x\u271d\na : Fin n \u2192 \u03b1\nm : \u2115\nh : m.succ * n = n + m * n\nr : Fin (m * n)\n\u22a2 Fin.repeat m.succ a (Fin.cast \u22ef (Fin.natAdd n r)) = (sorry \u2218 Fin.cast h) (Fin.cast \u22ef (Fin.natAdd n r))"}, {"line": "\u00b7 simp [modNat, Nat.mod_eq_of_lt l.is_lt]", "tactic_state": "case h.refine_2\nn : \u2115\n\u03b1 : Sort u_3\nx\u271d : Sort u_4\nappend : x\u271d\na : Fin n \u2192 \u03b1\nm : \u2115\nh : m.succ * n = n + m * n\nr : Fin (m * n)\n\u22a2 Fin.repeat m.succ a (Fin.cast \u22ef (Fin.natAdd n r)) = (sorry \u2218 Fin.cast h) (Fin.cast \u22ef (Fin.natAdd n r))"}, {"line": "\u00b7 simp [modNat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem repeat_add (a : Fin n \u2192 \u03b1) (m\u2081 m\u2082 : \u2115) : Fin.repeat (m\u2081 + m\u2082) a =\n    append (Fin.repeat m\u2081 a) (Fin.repeat m\u2082 a) \u2218 Fin.cast (Nat.add_mul ..) := by\n  generalize_proofs h\n  apply funext\n  rw [(Fin.rightInverse_cast h.symm).surjective.forall]\n  refine Fin.addCases (fun l => ?_) fun r => ?_\n  \u00b7 simp [modNat, Nat.mod_eq_of_lt l.is_lt]\n  \u00b7 simp [modNat, Nat.add_mod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)", "{\u03b1 : Fin (n + 1) \u2192 Type*}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b1 : Sort u_3\nx\u271d : Sort u_4\nappend : x\u271d\na : Fin n \u2192 \u03b1\nm\u2081 m\u2082 : \u2115\n\u22a2 Fin.repeat (m\u2081 + m\u2082) a = sorry \u2218 Fin.cast \u22ef"}, {"line": "generalize_proofs h", "tactic_state": "n : \u2115\n\u03b1 : Sort u_3\nx\u271d : Sort u_4\nappend : x\u271d\na : Fin n \u2192 \u03b1\nm\u2081 m\u2082 : \u2115\nh : (m\u2081 + m\u2082) * n = m\u2081 * n + m\u2082 * n\n\u22a2 Fin.repeat (m\u2081 + m\u2082) a = sorry \u2218 Fin.cast h"}, {"line": "apply funext", "tactic_state": "case h\nn : \u2115\n\u03b1 : Sort u_3\nx\u271d : Sort u_4\nappend : x\u271d\na : Fin n \u2192 \u03b1\nm\u2081 m\u2082 : \u2115\nh : (m\u2081 + m\u2082) * n = m\u2081 * n + m\u2082 * n\n\u22a2 \u2200 (x : Fin ((m\u2081 + m\u2082) * n)), Fin.repeat (m\u2081 + m\u2082) a x = (sorry \u2218 Fin.cast h) x"}, {"line": "rw [(Fin.rightInverse_cast h.symm).surjective.forall]", "tactic_state": "case h\nn : \u2115\n\u03b1 : Sort u_3\nx\u271d : Sort u_4\nappend : x\u271d\na : Fin n \u2192 \u03b1\nm\u2081 m\u2082 : \u2115\nh : (m\u2081 + m\u2082) * n = m\u2081 * n + m\u2082 * n\n\u22a2 \u2200 (x : Fin (m\u2081 * n + m\u2082 * n)), Fin.repeat (m\u2081 + m\u2082) a (Fin.cast \u22ef x) = (sorry \u2218 Fin.cast h) (Fin.cast \u22ef x)"}, {"line": "refine Fin.addCases (fun l => ?_) fun r => ?_", "tactic_state": "case h.refine_1\nn : \u2115\n\u03b1 : Sort u_3\nx\u271d : Sort u_4\nappend : x\u271d\na : Fin n \u2192 \u03b1\nm\u2081 m\u2082 : \u2115\nh : (m\u2081 + m\u2082) * n = m\u2081 * n + m\u2082 * n\nl : Fin (m\u2081 * n)\n\u22a2 Fin.repeat (m\u2081 + m\u2082) a (Fin.cast \u22ef (Fin.castAdd (m\u2082 * n) l)) =\n    (sorry \u2218 Fin.cast h) (Fin.cast \u22ef (Fin.castAdd (m\u2082 * n) l))\n---\ncase h.refine_2\nn : \u2115\n\u03b1 : Sort u_3\nx\u271d : Sort u_4\nappend : x\u271d\na : Fin n \u2192 \u03b1\nm\u2081 m\u2082 : \u2115\nh : (m\u2081 + m\u2082) * n = m\u2081 * n + m\u2082 * n\nr : Fin (m\u2082 * n)\n\u22a2 Fin.repeat (m\u2081 + m\u2082) a (Fin.cast \u22ef (Fin.natAdd (m\u2081 * n) r)) =\n    (sorry \u2218 Fin.cast h) (Fin.cast \u22ef (Fin.natAdd (m\u2081 * n) r))"}, {"line": "\u00b7 simp [modNat, Nat.mod_eq_of_lt l.is_lt]", "tactic_state": "case h.refine_2\nn : \u2115\n\u03b1 : Sort u_3\nx\u271d : Sort u_4\nappend : x\u271d\na : Fin n \u2192 \u03b1\nm\u2081 m\u2082 : \u2115\nh : (m\u2081 + m\u2082) * n = m\u2081 * n + m\u2082 * n\nr : Fin (m\u2082 * n)\n\u22a2 Fin.repeat (m\u2081 + m\u2082) a (Fin.cast \u22ef (Fin.natAdd (m\u2081 * n) r)) =\n    (sorry \u2218 Fin.cast h) (Fin.cast \u22ef (Fin.natAdd (m\u2081 * n) r))"}, {"line": "\u00b7 simp [modNat, Nat.add_mod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem snoc_last : snoc p x (last n) = x := by simp [snoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)", "{\u03b1 : Fin (n + 1) \u2192 Type*}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*}", "{\u03b1 : Fin (n + 1) \u2192 Sort*} (x : \u03b1 (last n)) (q : \u2200 i, \u03b1 i)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "last : ?m.1982\nm n\u271d : \u2115\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b2 : \u03b1\u271d\u2074 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2074 i\np : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2074 i.succ\ni : Fin n\u271d\n\u03b1\u271d\u00b3 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b2 : Sort u_2\n\u03b1\u271d\u00b9 : Sort u_3\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_4\nx\u271d\u00b9 : \u03b1\u271d sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d i\nn : \u2115\n\u03b1 : Fin (n + 1) \u2192 Sort u_4\nx : \u03b1 sorry\nx\u271d : Sort u_5\nsnoc : x\u271d\n\u22a2 sorry = x"}, {"line": "simp [snoc]", "tactic_state": "last : ?m.1982\nm n\u271d : \u2115\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b2 : \u03b1\u271d\u2074 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2074 i\np : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2074 i.succ\ni : Fin n\u271d\n\u03b1\u271d\u00b3 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b2 : Sort u_2\n\u03b1\u271d\u00b9 : Sort u_3\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_4\nx\u271d\u00b9 : \u03b1\u271d sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d i\nn : \u2115\n\u03b1 : Fin (n + 1) \u2192 Sort u_4\nx : \u03b1 sorry\nx\u271d : Sort u_5\nsnoc : x\u271d\n\u22a2 sorry () = x"}]}
{"declaration": "theorem append_right_eq_snoc {\u03b1 : Sort*} {n : \u2115} (x : Fin n \u2192 \u03b1) (x\u2080 : Fin 1 \u2192 \u03b1) :\n    Fin.append x x\u2080 = Fin.snoc x (x\u2080 0) := by\n  ext i\n  refine Fin.addCases ?_ ?_ i <;> clear i\n  \u00b7 intro i\n    rw [Fin.append_left]\n    exact (@snoc_castSucc _ (fun _ => \u03b1) _ _ i).symm\n  \u00b7 intro i\n    rw [Subsingleton.elim i 0]\n    rw [Fin.append_right]\n    exact (@snoc_last _ (fun _ => \u03b1) _ _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)", "{\u03b1 : Fin (n + 1) \u2192 Type*}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*}", "{\u03b1 : Fin (n + 1) \u2192 Sort*} (x : \u03b1 (last n)) (q : \u2200 i, \u03b1 i)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "last : ?m.1982\nm n\u271d : \u2115\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2074 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2074 i\np : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2074 i.succ\ni : Fin n\u271d\n\u03b1\u271d\u00b3 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b2 : Sort u_2\n\u03b1\u271d\u00b9 : Sort u_3\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_4\nx\u271d : \u03b1\u271d sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d i\n\u03b1 : Sort u_5\nn : \u2115\nx : Fin n \u2192 \u03b1\nx\u2080 : Fin 1 \u2192 \u03b1\n\u22a2 Fin.append x x\u2080 = Fin.snoc x (x\u2080 0)"}, {"line": "ext i", "tactic_state": "case h\nlast : ?m.1982\nm n\u271d : \u2115\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2074 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2074 i\np : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2074 i.succ\ni\u271d : Fin n\u271d\n\u03b1\u271d\u00b3 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b2 : Sort u_2\n\u03b1\u271d\u00b9 : Sort u_3\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_4\nx\u271d : \u03b1\u271d sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d i\n\u03b1 : Sort u_5\nn : \u2115\nx : Fin n \u2192 \u03b1\nx\u2080 : Fin 1 \u2192 \u03b1\ni : Fin (n + 1)\n\u22a2 Fin.append x x\u2080 i = Fin.snoc x (x\u2080 0) i"}, {"line": "refine Fin.addCases ?_ ?_ i <;> clear i", "tactic_state": "case h.refine_1\nlast : ?m.1982\nm n\u271d : \u2115\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2074 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2074 i\np : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2074 i.succ\ni : Fin n\u271d\n\u03b1\u271d\u00b3 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b2 : Sort u_2\n\u03b1\u271d\u00b9 : Sort u_3\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_4\nx\u271d : \u03b1\u271d sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d i\n\u03b1 : Sort u_5\nn : \u2115\nx : Fin n \u2192 \u03b1\nx\u2080 : Fin 1 \u2192 \u03b1\n\u22a2 \u2200 (i : Fin n), Fin.append x x\u2080 (Fin.castAdd 1 i) = Fin.snoc x (x\u2080 0) (Fin.castAdd 1 i)\n---\ncase h.refine_2\nlast : ?m.1982\nm n\u271d : \u2115\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2074 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2074 i\np : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2074 i.succ\ni : Fin n\u271d\n\u03b1\u271d\u00b3 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b2 : Sort u_2\n\u03b1\u271d\u00b9 : Sort u_3\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_4\nx\u271d : \u03b1\u271d sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d i\n\u03b1 : Sort u_5\nn : \u2115\nx : Fin n \u2192 \u03b1\nx\u2080 : Fin 1 \u2192 \u03b1\n\u22a2 \u2200 (i : Fin 1), Fin.append x x\u2080 (Fin.natAdd n i) = Fin.snoc x (x\u2080 0) (Fin.natAdd n i)"}, {"line": "\u00b7 intro i\n    rw [Fin.append_left]\n    exact (@snoc_castSucc _ (fun _ => \u03b1) _ _ i).symm", "tactic_state": "case h.refine_2\nlast : ?m.1982\nm n\u271d : \u2115\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2074 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2074 i\np : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2074 i.succ\ni : Fin n\u271d\n\u03b1\u271d\u00b3 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b2 : Sort u_2\n\u03b1\u271d\u00b9 : Sort u_3\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_4\nx\u271d : \u03b1\u271d sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d i\n\u03b1 : Sort u_5\nn : \u2115\nx : Fin n \u2192 \u03b1\nx\u2080 : Fin 1 \u2192 \u03b1\n\u22a2 \u2200 (i : Fin 1), Fin.append x x\u2080 (Fin.natAdd n i) = Fin.snoc x (x\u2080 0) (Fin.natAdd n i)"}, {"line": "\u00b7 intro i\n    rw [Subsingleton.elim i 0]\n    rw [Fin.append_right]\n    exact (@snoc_last _ (fun _ => \u03b1) _ _).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem insertNth_apply_same (i : Fin (n + 1)) (x : \u03b1 i) (p : \u2200 j, \u03b1 (i.succAbove j)) :\n    insertNth i x p i = x := by simp [insertNth, succAboveCases]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)", "{\u03b1 : Fin (n + 1) \u2192 Type*}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*}", "{\u03b1 : Fin (n + 1) \u2192 Sort*} (x : \u03b1 (last n)) (q : \u2200 i, \u03b1 i)", "{\u03b1 : Fin (n + 1) \u2192 Sort*} {\u03b2 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "last : ?m.2998\nm n\u271d : \u2115\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b2 : \u03b1\u271d\u2075 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2075 i\np\u271d : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2075 i.succ\ni\u271d : Fin n\u271d\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b3 : Sort u_2\n\u03b1\u271d\u00b2 : Sort u_3\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_4\nx\u271d\u00b9 : \u03b1\u271d\u00b9 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b9 i\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\nn : \u2115\n\u03b1 : Fin (n + 1) \u2192 Sort u_5\nx\u271d : Sort u_7\ninsertNth : x\u271d\ni : Fin (n + 1)\nx : \u03b1 i\np : (j : Fin n) \u2192 \u03b1 (i.succAbove j)\n\u22a2 sorry = x"}, {"line": "simp [insertNth, succAboveCases]", "tactic_state": "last : ?m.2998\nm n\u271d : \u2115\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b2 : \u03b1\u271d\u2075 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2075 i\np\u271d : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2075 i.succ\ni\u271d : Fin n\u271d\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b3 : Sort u_2\n\u03b1\u271d\u00b2 : Sort u_3\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_4\nx\u271d\u00b9 : \u03b1\u271d\u00b9 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b9 i\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\nn : \u2115\n\u03b1 : Fin (n + 1) \u2192 Sort u_5\nx\u271d : Sort u_7\ninsertNth : x\u271d\ni : Fin (n + 1)\nx : \u03b1 i\np : (j : Fin n) \u2192 \u03b1 (i.succAbove j)\n\u22a2 sorry () = x"}]}
{"declaration": "theorem insertNth_eq_iff {p : Fin (n + 1)} {a : \u03b1 p} {f : \u2200 i, \u03b1 (p.succAbove i)} {g : \u2200 j, \u03b1 j} :\n    insertNth p a f = g \u2194 a = g p \u2227 f = removeNth p g := by\n  simp [funext_iff, forall_iff_succAbove p, removeNth]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)", "{\u03b1 : Fin (n + 1) \u2192 Type*}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*}", "{\u03b1 : Fin (n + 1) \u2192 Sort*} (x : \u03b1 (last n)) (q : \u2200 i, \u03b1 i)", "{\u03b1 : Fin (n + 1) \u2192 Sort*} {\u03b2 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "last : ?m.2998\nm n\u271d : \u2115\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b2 : \u03b1\u271d\u2075 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2075 i\np\u271d : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2075 i.succ\ni : Fin n\u271d\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b3 : Sort u_2\n\u03b1\u271d\u00b2 : Sort u_3\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_4\nx : \u03b1\u271d\u00b9 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b9 i\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\nn : \u2115\n\u03b1 : Fin (n + 1) \u2192 Sort u_5\nx\u271d\u00b9 : Sort u_7\ninsertNth : x\u271d\u00b9\nx\u271d : Sort u_8\nremoveNth : x\u271d\np : Fin (n + 1)\na : \u03b1 p\nf : (i : Fin n) \u2192 \u03b1 (p.succAbove i)\ng : (j : Fin (n + 1)) \u2192 \u03b1 j\n\u22a2 sorry = g \u2194 a = g p \u2227 f = sorry"}, {"line": "simp [funext_iff, forall_iff_succAbove p, removeNth]", "tactic_state": "last : ?m.2998\nm n\u271d : \u2115\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b2 : \u03b1\u271d\u2075 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2075 i\np\u271d : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2075 i.succ\ni : Fin n\u271d\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b3 : Sort u_2\n\u03b1\u271d\u00b2 : Sort u_3\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_4\nx : \u03b1\u271d\u00b9 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b9 i\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\nn : \u2115\n\u03b1 : Fin (n + 1) \u2192 Sort u_5\nx\u271d\u00b9 : Sort u_7\ninsertNth : x\u271d\u00b9\nx\u271d : Sort u_8\nremoveNth : x\u271d\np : Fin (n + 1)\na : \u03b1 p\nf : (i : Fin n) \u2192 \u03b1 (p.succAbove i)\ng : (j : Fin (n + 1)) \u2192 \u03b1 j\n\u22a2 (\u2200 (x : Fin (n + 1)), sorry () x = g x) \u2194 a = g p \u2227 \u2200 (x : Fin n), f x = sorry () x"}]}
{"declaration": "theorem eq_insertNth_iff {p : Fin (n + 1)} {a : \u03b1 p} {f : \u2200 i, \u03b1 (p.succAbove i)} {g : \u2200 j, \u03b1 j} :\n    g = insertNth p a f \u2194 g p = a \u2227 removeNth p g = f := by\n  simpa [eq_comm] using insertNth_eq_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)", "{\u03b1 : Fin (n + 1) \u2192 Type*}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*}", "{\u03b1 : Fin (n + 1) \u2192 Sort*} (x : \u03b1 (last n)) (q : \u2200 i, \u03b1 i)", "{\u03b1 : Fin (n + 1) \u2192 Sort*} {\u03b2 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "last : ?m.2998\nm n\u271d : \u2115\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b2 : \u03b1\u271d\u2075 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2075 i\np\u271d : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2075 i.succ\ni : Fin n\u271d\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b3 : Sort u_2\n\u03b1\u271d\u00b2 : Sort u_3\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_4\nx : \u03b1\u271d\u00b9 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b9 i\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\nn : \u2115\n\u03b1 : Fin (n + 1) \u2192 Sort u_5\nx\u271d\u00b9 : Sort u_7\ninsertNth : x\u271d\u00b9\nx\u271d : Sort u_8\nremoveNth : x\u271d\np : Fin (n + 1)\na : \u03b1 p\nf : (i : Fin n) \u2192 \u03b1 (p.succAbove i)\ng : (j : Fin (n + 1)) \u2192 \u03b1 j\n\u22a2 g = sorry \u2194 g p = a \u2227 sorry = f"}, {"line": "simpa [eq_comm] using insertNth_eq_iff", "tactic_state": "No Goals!"}]}
{"declaration": "lemma insertNth_rev {\u03b1 : Sort*} (i : Fin (n + 1)) (a : \u03b1) (f : Fin n \u2192 \u03b1) (j : Fin (n + 1)) :\n    insertNth (\u03b1 := fun _ \u21a6 \u03b1) i a f (rev j) = insertNth (\u03b1 := fun _ \u21a6 \u03b1) i.rev a (f \u2218 rev) j := by\n  induction j using Fin.succAboveCases\n  \u00b7 exact rev i\n  \u00b7 simp\n  \u00b7 simp [rev_succAbove]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)", "{\u03b1 : Fin (n + 1) \u2192 Type*}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*}", "{\u03b1 : Fin (n + 1) \u2192 Sort*} (x : \u03b1 (last n)) (q : \u2200 i, \u03b1 i)", "{\u03b1 : Fin (n + 1) \u2192 Sort*} {\u03b2 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "last : ?m.2998\nm n\u271d : \u2115\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2075 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2075 i\np : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2075 i.succ\ni\u271d : Fin n\u271d\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b3 : Sort u_2\n\u03b1\u271d\u00b2 : Sort u_3\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_4\nx : \u03b1\u271d\u00b9 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b9 i\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\nn : \u2115\nx\u271d : Sort u_8\ninsertNth : x\u271d\n\u03b1 : Sort u_7\ni : Fin (n + 1)\na : \u03b1\nf : Fin n \u2192 \u03b1\nj : Fin (n + 1)\n\u22a2 sorry = sorry"}, {"line": "induction j using Fin.succAboveCases", "tactic_state": "case i\nlast : ?m.2998\nm n\u271d : \u2115\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2075 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2075 i\np : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2075 i.succ\ni\u271d : Fin n\u271d\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b3 : Sort u_2\n\u03b1\u271d\u00b2 : Sort u_3\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_4\nx : \u03b1\u271d\u00b9 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b9 i\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\nn : \u2115\nx\u271d : Sort u_8\ninsertNth : x\u271d\n\u03b1 : Sort u_7\ni : Fin (n + 1)\na : \u03b1\nf : Fin n \u2192 \u03b1\n\u22a2 Fin (n + 1)\n---\ncase x\nlast : ?m.2998\nm n\u271d : \u2115\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2075 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2075 i\np : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2075 i.succ\ni\u271d : Fin n\u271d\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b3 : Sort u_2\n\u03b1\u271d\u00b2 : Sort u_3\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_4\nx : \u03b1\u271d\u00b9 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b9 i\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\nn : \u2115\nx\u271d : Sort u_8\ninsertNth : x\u271d\n\u03b1 : Sort u_7\ni : Fin (n + 1)\na : \u03b1\nf : Fin n \u2192 \u03b1\n\u22a2 sorry = sorry\n---\ncase p\nlast : ?m.2998\nm n\u271d : \u2115\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2075 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2075 i\np : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2075 i.succ\ni\u271d : Fin n\u271d\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b3 : Sort u_2\n\u03b1\u271d\u00b2 : Sort u_3\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_4\nx : \u03b1\u271d\u00b9 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b9 i\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\nn : \u2115\nx\u271d : Sort u_8\ninsertNth : x\u271d\n\u03b1 : Sort u_7\ni : Fin (n + 1)\na : \u03b1\nf : Fin n \u2192 \u03b1\nj\u271d : Fin n\n\u22a2 sorry = sorry"}, {"line": "\u00b7 exact rev i", "tactic_state": "case x\nlast : ?m.2998\nm n\u271d : \u2115\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2075 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2075 i\np : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2075 i.succ\ni\u271d : Fin n\u271d\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b3 : Sort u_2\n\u03b1\u271d\u00b2 : Sort u_3\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_4\nx : \u03b1\u271d\u00b9 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b9 i\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\nn : \u2115\nx\u271d : Sort u_8\ninsertNth : x\u271d\n\u03b1 : Sort u_7\ni : Fin (n + 1)\na : \u03b1\nf : Fin n \u2192 \u03b1\n\u22a2 sorry = sorry\n---\ncase p\nlast : ?m.2998\nm n\u271d : \u2115\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2075 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2075 i\np : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2075 i.succ\ni\u271d : Fin n\u271d\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b3 : Sort u_2\n\u03b1\u271d\u00b2 : Sort u_3\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_4\nx : \u03b1\u271d\u00b9 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b9 i\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\nn : \u2115\nx\u271d : Sort u_8\ninsertNth : x\u271d\n\u03b1 : Sort u_7\ni : Fin (n + 1)\na : \u03b1\nf : Fin n \u2192 \u03b1\nj\u271d : Fin n\n\u22a2 sorry = sorry"}, {"line": "\u00b7 simp", "tactic_state": "case p\nlast : ?m.2998\nm n\u271d : \u2115\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2075 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2075 i\np : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2075 i.succ\ni\u271d : Fin n\u271d\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b3 : Sort u_2\n\u03b1\u271d\u00b2 : Sort u_3\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_4\nx : \u03b1\u271d\u00b9 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b9 i\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\nn : \u2115\nx\u271d : Sort u_8\ninsertNth : x\u271d\n\u03b1 : Sort u_7\ni : Fin (n + 1)\na : \u03b1\nf : Fin n \u2192 \u03b1\nj\u271d : Fin n\n\u22a2 sorry = sorry"}, {"line": "\u00b7 simp [rev_succAbove]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem insertNth_comp_rev {\u03b1} (i : Fin (n + 1)) (x : \u03b1) (p : Fin n \u2192 \u03b1) :\n    (Fin.insertNth i x p) \u2218 Fin.rev = Fin.insertNth (Fin.rev i) x (p \u2218 Fin.rev) := by\n  funext x\n  apply insertNth_rev\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)", "{\u03b1 : Fin (n + 1) \u2192 Type*}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*}", "{\u03b1 : Fin (n + 1) \u2192 Sort*} (x : \u03b1 (last n)) (q : \u2200 i, \u03b1 i)", "{\u03b1 : Fin (n + 1) \u2192 Sort*} {\u03b2 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "last : ?m.2998\nm n\u271d : \u2115\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2075 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2075 i\np\u271d : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2075 i.succ\ni\u271d : Fin n\u271d\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b3 : Sort u_2\n\u03b1\u271d\u00b2 : Sort u_3\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_4\nx\u271d : \u03b1\u271d\u00b9 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b9 i\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\nn : \u2115\n\u03b1 : Sort u_7\ni : Fin (n + 1)\nx : \u03b1\np : Fin n \u2192 \u03b1\n\u22a2 i.insertNth x p \u2218 Fin.rev = i.rev.insertNth x (p \u2218 Fin.rev)"}, {"line": "funext x", "tactic_state": "case h\nlast : ?m.2998\nm n\u271d : \u2115\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b2 : \u03b1\u271d\u2075 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2075 i\np\u271d : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2075 i.succ\ni\u271d : Fin n\u271d\n\u03b1\u271d\u2074 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u00b3 : Sort u_2\n\u03b1\u271d\u00b2 : Sort u_3\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_4\nx\u271d\u00b9 : \u03b1\u271d\u00b9 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b9 i\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\nn : \u2115\n\u03b1 : Sort u_7\ni : Fin (n + 1)\nx\u271d : \u03b1\np : Fin n \u2192 \u03b1\nx : Fin (n + 1)\n\u22a2 (i.insertNth x\u271d p \u2218 Fin.rev) x = i.rev.insertNth x\u271d (p \u2218 Fin.rev) x"}, {"line": "apply insertNth_rev", "tactic_state": "No Goals!"}]}
{"declaration": "theorem insertNth_le_iff {i : Fin (n + 1)} {x : \u03b1 i} {p : \u2200 j, \u03b1 (i.succAbove j)} {q : \u2200 j, \u03b1 j} :\n    i.insertNth x p \u2264 q \u2194 x \u2264 q i \u2227 p \u2264 fun j \u21a6 q (i.succAbove j) := by\n  simp [Pi.le_def, forall_iff_succAbove i]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)", "{\u03b1 : Fin (n + 1) \u2192 Type*}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*}", "{\u03b1 : Fin (n + 1) \u2192 Sort*} (x : \u03b1 (last n)) (q : \u2200 i, \u03b1 i)", "{\u03b1 : Fin (n + 1) \u2192 Sort*} {\u03b2 : Sort*}", "{\u03b1 : Fin (n + 1) \u2192 Type*} [\u2200 i, Preorder (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "last : ?m.4084\nm n\u271d : \u2115\n\u03b1\u271d\u2076 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2076 0\nq\u271d\u00b9 : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2076 i\np\u271d : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2076 i.succ\ni\u271d : Fin n\u271d\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u2074 : Sort u_2\n\u03b1\u271d\u00b3 : Sort u_3\n\u03b1\u271d\u00b2 : Fin (n\u271d + 1) \u2192 Sort u_4\nx\u271d : \u03b1\u271d\u00b2 sorry\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b2 i\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Type u_7\ninst\u271d\u00b9 : (i : Fin (n\u271d + 1)) \u2192 Preorder (\u03b1\u271d i)\nn : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_7\ninst\u271d : (i : Fin (n + 1)) \u2192 Preorder (\u03b1 i)\ni : Fin (n + 1)\nx : \u03b1 i\np : (j : Fin n) \u2192 \u03b1 (i.succAbove j)\nq : (j : Fin (n + 1)) \u2192 \u03b1 j\n\u22a2 i.insertNth x p \u2264 q \u2194 x \u2264 q i \u2227 p \u2264 fun j => q (i.succAbove j)"}, {"line": "simp [Pi.le_def, forall_iff_succAbove i]", "tactic_state": "last : ?m.4084\nm n\u271d : \u2115\n\u03b1\u271d\u2076 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2076 0\nq\u271d\u00b9 : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2076 i\np\u271d : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2076 i.succ\ni\u271d : Fin n\u271d\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u2074 : Sort u_2\n\u03b1\u271d\u00b3 : Sort u_3\n\u03b1\u271d\u00b2 : Fin (n\u271d + 1) \u2192 Sort u_4\nx\u271d : \u03b1\u271d\u00b2 sorry\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b2 i\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Type u_7\ninst\u271d\u00b9 : (i : Fin (n\u271d + 1)) \u2192 Preorder (\u03b1\u271d i)\nn : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_7\ninst\u271d : (i : Fin (n + 1)) \u2192 Preorder (\u03b1 i)\ni : Fin (n + 1)\nx : \u03b1 i\np : (j : Fin n) \u2192 \u03b1 (i.succAbove j)\nq : (j : Fin (n + 1)) \u2192 \u03b1 j\n\u22a2 (\u2200 (i_1 : Fin (n + 1)), i.insertNth x p i_1 \u2264 q i_1) \u2194 x \u2264 q i \u2227 \u2200 (i_1 : Fin n), p i_1 \u2264 q (i.succAbove i_1)"}]}
{"declaration": "theorem le_insertNth_iff {i : Fin (n + 1)} {x : \u03b1 i} {p : \u2200 j, \u03b1 (i.succAbove j)} {q : \u2200 j, \u03b1 j} :\n    q \u2264 i.insertNth x p \u2194 q i \u2264 x \u2227 (fun j \u21a6 q (i.succAbove j)) \u2264 p := by\n  simp [Pi.le_def, forall_iff_succAbove i]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)", "{\u03b1 : Fin (n + 1) \u2192 Type*}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*}", "{\u03b1 : Fin (n + 1) \u2192 Sort*} (x : \u03b1 (last n)) (q : \u2200 i, \u03b1 i)", "{\u03b1 : Fin (n + 1) \u2192 Sort*} {\u03b2 : Sort*}", "{\u03b1 : Fin (n + 1) \u2192 Type*} [\u2200 i, Preorder (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "last : ?m.4084\nm n\u271d : \u2115\n\u03b1\u271d\u2076 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2076 0\nq\u271d\u00b9 : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2076 i\np\u271d : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2076 i.succ\ni\u271d : Fin n\u271d\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u2074 : Sort u_2\n\u03b1\u271d\u00b3 : Sort u_3\n\u03b1\u271d\u00b2 : Fin (n\u271d + 1) \u2192 Sort u_4\nx\u271d : \u03b1\u271d\u00b2 sorry\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b2 i\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Type u_7\ninst\u271d\u00b9 : (i : Fin (n\u271d + 1)) \u2192 Preorder (\u03b1\u271d i)\nn : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_7\ninst\u271d : (i : Fin (n + 1)) \u2192 Preorder (\u03b1 i)\ni : Fin (n + 1)\nx : \u03b1 i\np : (j : Fin n) \u2192 \u03b1 (i.succAbove j)\nq : (j : Fin (n + 1)) \u2192 \u03b1 j\n\u22a2 q \u2264 i.insertNth x p \u2194 q i \u2264 x \u2227 (fun j => q (i.succAbove j)) \u2264 p"}, {"line": "simp [Pi.le_def, forall_iff_succAbove i]", "tactic_state": "last : ?m.4084\nm n\u271d : \u2115\n\u03b1\u271d\u2076 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2076 0\nq\u271d\u00b9 : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2076 i\np\u271d : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2076 i.succ\ni\u271d : Fin n\u271d\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u2074 : Sort u_2\n\u03b1\u271d\u00b3 : Sort u_3\n\u03b1\u271d\u00b2 : Fin (n\u271d + 1) \u2192 Sort u_4\nx\u271d : \u03b1\u271d\u00b2 sorry\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b2 i\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Type u_7\ninst\u271d\u00b9 : (i : Fin (n\u271d + 1)) \u2192 Preorder (\u03b1\u271d i)\nn : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_7\ninst\u271d : (i : Fin (n + 1)) \u2192 Preorder (\u03b1 i)\ni : Fin (n + 1)\nx : \u03b1 i\np : (j : Fin n) \u2192 \u03b1 (i.succAbove j)\nq : (j : Fin (n + 1)) \u2192 \u03b1 j\n\u22a2 (\u2200 (i_1 : Fin (n + 1)), q i_1 \u2264 i.insertNth x p i_1) \u2194 q i \u2264 x \u2227 \u2200 (i_1 : Fin n), q (i.succAbove i_1) \u2264 p i_1"}]}
{"declaration": "lemma insertNth_self_removeNth (p : Fin (n + 1)) (f : \u2200 j, \u03b1 j) :\n    insertNth p (f p) (removeNth p f) = f := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function", "Set"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)", "{\u03b1 : Fin (n + 1) \u2192 Type*}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*}", "{\u03b1 : Fin (n + 1) \u2192 Sort*} (x : \u03b1 (last n)) (q : \u2200 i, \u03b1 i)", "{\u03b1 : Fin (n + 1) \u2192 Sort*} {\u03b2 : Sort*}", "{\u03b1 : Fin (n + 1) \u2192 Type*} [\u2200 i, Preorder (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "last : ?m.4084\nm n\u271d : \u2115\n\u03b1\u271d\u2076 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2076 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2076 i\np\u271d : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2076 i.succ\ni : Fin n\u271d\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u2074 : Sort u_2\n\u03b1\u271d\u00b3 : Sort u_3\n\u03b1\u271d\u00b2 : Fin (n\u271d + 1) \u2192 Sort u_4\nx : \u03b1\u271d\u00b2 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b2 i\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Type u_7\ninst\u271d\u00b9 : (i : Fin (n\u271d + 1)) \u2192 Preorder (\u03b1\u271d i)\nn : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_7\ninst\u271d : (i : Fin (n + 1)) \u2192 Preorder (\u03b1 i)\nx\u271d : Sort u_8\ninsertNth : x\u271d\np : Fin (n + 1)\nf : (j : Fin (n + 1)) \u2192 \u03b1 j\n\u22a2 sorry = f"}, {"line": "simp", "tactic_state": "last : ?m.4084\nm n\u271d : \u2115\n\u03b1\u271d\u2076 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2076 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2076 i\np\u271d : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2076 i.succ\ni : Fin n\u271d\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u2074 : Sort u_2\n\u03b1\u271d\u00b3 : Sort u_3\n\u03b1\u271d\u00b2 : Fin (n\u271d + 1) \u2192 Sort u_4\nx : \u03b1\u271d\u00b2 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b2 i\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Type u_7\ninst\u271d\u00b9 : (i : Fin (n\u271d + 1)) \u2192 Preorder (\u03b1\u271d i)\nn : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_7\ninst\u271d : (i : Fin (n + 1)) \u2192 Preorder (\u03b1 i)\nx\u271d : Sort u_8\ninsertNth : x\u271d\np : Fin (n + 1)\nf : (j : Fin (n + 1)) \u2192 \u03b1 j\n\u22a2 sorry () = f"}]}
{"declaration": "theorem update_insertNth (p : Fin (n + 1)) (x y : \u03b1 p) (f : \u2200 i, \u03b1 (p.succAbove i)) :\n    update (p.insertNth x f) p y = p.insertNth y f := by\n  ext i\n  cases i using p.succAboveCases <;> simp [succAbove_ne]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Basic.lean", "context": {"open": ["Function", "Set"], "variables": ["{m n : \u2115}", "{\u03b1 : Fin (n + 1) \u2192 Sort u} (x : \u03b1 0) (q : \u2200 i, \u03b1 i) (p : \u2200 i : Fin n, \u03b1 i.succ) (i : Fin n)", "{\u03b1 : Fin (n + 1) \u2192 Type*}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*}", "{\u03b1 : Fin (n + 1) \u2192 Sort*} (x : \u03b1 (last n)) (q : \u2200 i, \u03b1 i)", "{\u03b1 : Fin (n + 1) \u2192 Sort*} {\u03b2 : Sort*}", "{\u03b1 : Fin (n + 1) \u2192 Type*} [\u2200 i, Preorder (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "last : ?m.4084\nm n\u271d : \u2115\n\u03b1\u271d\u2076 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2076 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2076 i\np\u271d : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2076 i.succ\ni : Fin n\u271d\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u2074 : Sort u_2\n\u03b1\u271d\u00b3 : Sort u_3\n\u03b1\u271d\u00b2 : Fin (n\u271d + 1) \u2192 Sort u_4\nx\u271d : \u03b1\u271d\u00b2 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b2 i\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Type u_7\ninst\u271d\u00b9 : (i : Fin (n\u271d + 1)) \u2192 Preorder (\u03b1\u271d i)\nn : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_7\ninst\u271d : (i : Fin (n + 1)) \u2192 Preorder (\u03b1 i)\np : Fin (n + 1)\nx y : \u03b1 p\nf : (i : Fin n) \u2192 \u03b1 (p.succAbove i)\n\u22a2 update (p.insertNth x f) p y = p.insertNth y f"}, {"line": "ext i", "tactic_state": "case h\nlast : ?m.4084\nm n\u271d : \u2115\n\u03b1\u271d\u2076 : Fin (n\u271d + 1) \u2192 Sort u\nx\u271d\u00b9 : \u03b1\u271d\u2076 0\nq\u271d : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u2076 i\np\u271d : (i : Fin n\u271d) \u2192 \u03b1\u271d\u2076 i.succ\ni\u271d : Fin n\u271d\n\u03b1\u271d\u2075 : Fin (n\u271d + 1) \u2192 Type u_1\n\u03b1\u271d\u2074 : Sort u_2\n\u03b1\u271d\u00b3 : Sort u_3\n\u03b1\u271d\u00b2 : Fin (n\u271d + 1) \u2192 Sort u_4\nx\u271d : \u03b1\u271d\u00b2 sorry\nq : (i : Fin (n\u271d + 1)) \u2192 \u03b1\u271d\u00b2 i\n\u03b1\u271d\u00b9 : Fin (n\u271d + 1) \u2192 Sort u_5\n\u03b2 : Sort u_6\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Type u_7\ninst\u271d\u00b9 : (i : Fin (n\u271d + 1)) \u2192 Preorder (\u03b1\u271d i)\nn : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_7\ninst\u271d : (i : Fin (n + 1)) \u2192 Preorder (\u03b1 i)\np : Fin (n + 1)\nx y : \u03b1 p\nf : (i : Fin n) \u2192 \u03b1 (p.succAbove i)\ni : Fin (n + 1)\n\u22a2 update (p.insertNth x f) p y i = p.insertNth y f i"}, {"line": "cases i using p.succAboveCases <;> simp [succAbove_ne]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_piFinset_iff_last_init :\n    f \u2208 piFinset s \u2194 f (last n) \u2208 s (last n) \u2227 init f \u2208 piFinset (init s) := by\n  simp only [Fintype.mem_piFinset]\n  simp only [forall_fin_succ']\n  simp only [init]\n  simp only [and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Finset.lean", "context": {"open": ["Fin Fintype", "Fintype"], "variables": ["{n : \u2115} {\u03b1 : Fin (n + 1) \u2192 Type*} {f : \u2200 i, \u03b1 i} {s : \u2200 i, Finset (\u03b1 i)} {p : Fin (n + 1)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_1\nf : (i : Fin (n + 1)) \u2192 \u03b1 i\ns : (i : Fin (n + 1)) \u2192 Finset (\u03b1 i)\n\u22a2 f \u2208 piFinset s \u2194 f (last n) \u2208 s (last n) \u2227 init f \u2208 piFinset (init s)"}, {"line": "simp only [Fintype.mem_piFinset]", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_1\nf : (i : Fin (n + 1)) \u2192 \u03b1 i\ns : (i : Fin (n + 1)) \u2192 Finset (\u03b1 i)\n\u22a2 (\u2200 (a : Fin (n + 1)), f a \u2208 s a) \u2194 f (last n) \u2208 s (last n) \u2227 \u2200 (a : Fin n), init f a \u2208 init s a"}, {"line": "simp only [forall_fin_succ']", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_1\nf : (i : Fin (n + 1)) \u2192 \u03b1 i\ns : (i : Fin (n + 1)) \u2192 Finset (\u03b1 i)\n\u22a2 (\u2200 (i : Fin n), f i.castSucc \u2208 s i.castSucc) \u2227 f (last n) \u2208 s (last n) \u2194\n    f (last n) \u2208 s (last n) \u2227 \u2200 (a : Fin n), init f a \u2208 init s a"}, {"line": "simp only [init]", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_1\nf : (i : Fin (n + 1)) \u2192 \u03b1 i\ns : (i : Fin (n + 1)) \u2192 Finset (\u03b1 i)\n\u22a2 (\u2200 (i : Fin n), f i.castSucc \u2208 s i.castSucc) \u2227 f (last n) \u2208 s (last n) \u2194\n    f (last n) \u2208 s (last n) \u2227 \u2200 (a : Fin n), f a.castSucc \u2208 s a.castSucc"}, {"line": "simp only [and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_piFinset_iff_pivot_removeNth (p : Fin (n + 1)) :\n    f \u2208 piFinset s \u2194 f p \u2208 s p \u2227 removeNth p f \u2208 piFinset (removeNth p s) := by\n  simp only [Fintype.mem_piFinset]\n  simp only [forall_iff_succAbove p]\n  simp only [removeNth]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Finset.lean", "context": {"open": ["Fin Fintype", "Fintype"], "variables": ["{n : \u2115} {\u03b1 : Fin (n + 1) \u2192 Type*} {f : \u2200 i, \u03b1 i} {s : \u2200 i, Finset (\u03b1 i)} {p : Fin (n + 1)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_1\nf : (i : Fin (n + 1)) \u2192 \u03b1 i\ns : (i : Fin (n + 1)) \u2192 Finset (\u03b1 i)\np : Fin (n + 1)\n\u22a2 f \u2208 piFinset s \u2194 f p \u2208 s p \u2227 p.removeNth f \u2208 piFinset (p.removeNth s)"}, {"line": "simp only [Fintype.mem_piFinset]", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_1\nf : (i : Fin (n + 1)) \u2192 \u03b1 i\ns : (i : Fin (n + 1)) \u2192 Finset (\u03b1 i)\np : Fin (n + 1)\n\u22a2 (\u2200 (a : Fin (n + 1)), f a \u2208 s a) \u2194 f p \u2208 s p \u2227 \u2200 (a : Fin n), p.removeNth f a \u2208 p.removeNth s a"}, {"line": "simp only [forall_iff_succAbove p]", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_1\nf : (i : Fin (n + 1)) \u2192 \u03b1 i\ns : (i : Fin (n + 1)) \u2192 Finset (\u03b1 i)\np : Fin (n + 1)\n\u22a2 (f p \u2208 s p \u2227 \u2200 (i : Fin n), f (p.succAbove i) \u2208 s (p.succAbove i)) \u2194\n    f p \u2208 s p \u2227 \u2200 (a : Fin n), p.removeNth f a \u2208 p.removeNth s a"}, {"line": "simp only [removeNth]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cons_mem_piFinset_cons {x_zero : \u03b1 0} {x_tail : (i : Fin n) \u2192 \u03b1 i.succ}\n    {s_zero : Finset (\u03b1 0)} {s_tail : (i : Fin n) \u2192 Finset (\u03b1 i.succ)} :\n    cons x_zero x_tail \u2208 piFinset (cons s_zero s_tail) \u2194\n      x_zero \u2208 s_zero \u2227 x_tail \u2208 piFinset s_tail := by\n  simp_rw [mem_piFinset_iff_zero_tail, cons_zero, tail_cons]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Finset.lean", "context": {"open": ["Fin Fintype", "Fintype"], "variables": ["{n : \u2115} {\u03b1 : Fin (n + 1) \u2192 Type*} {f : \u2200 i, \u03b1 i} {s : \u2200 i, Finset (\u03b1 i)} {p : Fin (n + 1)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_1\nx_zero : \u03b1 0\nx_tail : (i : Fin n) \u2192 \u03b1 i.succ\ns_zero : Finset (\u03b1 0)\ns_tail : (i : Fin n) \u2192 Finset (\u03b1 i.succ)\n\u22a2 cons x_zero x_tail \u2208 piFinset (cons s_zero s_tail) \u2194 x_zero \u2208 s_zero \u2227 x_tail \u2208 piFinset s_tail"}, {"line": "simp_rw [mem_piFinset_iff_zero_tail, cons_zero, tail_cons]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma snoc_mem_piFinset_snoc {x_last : \u03b1 (last n)} {x_init : (i : Fin n) \u2192 \u03b1 i.castSucc}\n    {s_last : Finset (\u03b1 (last n))} {s_init : (i : Fin n) \u2192 Finset (\u03b1 i.castSucc)} :\n    snoc x_init x_last \u2208 piFinset (snoc s_init s_last) \u2194\n      x_last \u2208 s_last \u2227 x_init \u2208 piFinset s_init := by\n  simp_rw [mem_piFinset_iff_last_init, init_snoc, snoc_last]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Finset.lean", "context": {"open": ["Fin Fintype", "Fintype"], "variables": ["{n : \u2115} {\u03b1 : Fin (n + 1) \u2192 Type*} {f : \u2200 i, \u03b1 i} {s : \u2200 i, Finset (\u03b1 i)} {p : Fin (n + 1)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_1\nx_last : \u03b1 (last n)\nx_init : (i : Fin n) \u2192 \u03b1 i.castSucc\ns_last : Finset (\u03b1 (last n))\ns_init : (i : Fin n) \u2192 Finset (\u03b1 i.castSucc)\n\u22a2 snoc x_init x_last \u2208 piFinset (snoc s_init s_last) \u2194 x_last \u2208 s_last \u2227 x_init \u2208 piFinset s_init"}, {"line": "simp_rw [mem_piFinset_iff_last_init, init_snoc, snoc_last]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma insertNth_mem_piFinset_insertNth {x_pivot : \u03b1 p} {x_remove : \u2200 i, \u03b1 (succAbove p i)}\n    {s_pivot : Finset (\u03b1 p)} {s_remove : \u2200 i, Finset (\u03b1 (succAbove p i))} :\n    insertNth p x_pivot x_remove \u2208 piFinset (insertNth p s_pivot s_remove) \u2194\n      x_pivot \u2208 s_pivot \u2227 x_remove \u2208 piFinset s_remove := by\n  simp [mem_piFinset_iff_pivot_removeNth p]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Finset.lean", "context": {"open": ["Fin Fintype", "Fintype"], "variables": ["{n : \u2115} {\u03b1 : Fin (n + 1) \u2192 Type*} {f : \u2200 i, \u03b1 i} {s : \u2200 i, Finset (\u03b1 i)} {p : Fin (n + 1)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u_1\np : Fin (n + 1)\nx_pivot : \u03b1 p\nx_remove : (i : Fin n) \u2192 \u03b1 (p.succAbove i)\ns_pivot : Finset (\u03b1 p)\ns_remove : (i : Fin n) \u2192 Finset (\u03b1 (p.succAbove i))\n\u22a2 p.insertNth x_pivot x_remove \u2208 piFinset (p.insertNth s_pivot s_remove) \u2194\n    x_pivot \u2208 s_pivot \u2227 x_remove \u2208 piFinset s_remove"}, {"line": "simp [mem_piFinset_iff_pivot_removeNth p]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem antitone_pair_of_not_sorted' (h : f \u2218 \u03c3 \u2260 f \u2218 sort f) :\n    \u2203 i j, i < j \u2227 (f \u2218 \u03c3) j < (f \u2218 \u03c3) i := by\n  contrapose! h\n  exact comp_sort_eq_comp_iff_monotone.mpr (monotone_iff_forall_lt.mpr h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Fin/Tuple/Sort.lean", "context": {"open": ["List"], "variables": ["{n : \u2115}", "{\u03b1 : Type*} [LinearOrder \u03b1]", "{n : \u2115} {\u03b1 : Type*}", "[LinearOrder \u03b1] {f : Fin n \u2192 \u03b1} {\u03c3 : Equiv.Perm (Fin n)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b1 : Type u_2\ninst\u271d : LinearOrder \u03b1\nf : Fin n \u2192 \u03b1\n\u03c3 : Equiv.Perm (Fin n)\nx\u271d : Sort u_3\nsort : x\u271d\nh : f \u2218 \u21d1\u03c3 \u2260 f \u2218 sorry\n\u22a2 \u2203 i j, i < j \u2227 (f \u2218 \u21d1\u03c3) j < (f \u2218 \u21d1\u03c3) i"}, {"line": "contrapose! h", "tactic_state": "n : \u2115\n\u03b1 : Type u_2\ninst\u271d : LinearOrder \u03b1\nf : Fin n \u2192 \u03b1\n\u03c3 : Equiv.Perm (Fin n)\nx\u271d : Sort u_3\nsort : x\u271d\nh : \u2200 (i j : Fin n), i < j \u2192 \u00ac(f \u2218 \u21d1\u03c3) j < (f \u2218 \u21d1\u03c3) i\n\u22a2 f \u2218 \u21d1\u03c3 = f \u2218 sorry"}, {"line": "exact comp_sort_eq_comp_iff_monotone.mpr (monotone_iff_forall_lt.mpr h)", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Finite.prod (hs : s.Finite) (ht : t.Finite) : (s \u00d7\u02e2 t : Set (\u03b1 \u00d7 \u03b2)).Finite := by\n  have := hs.to_subtype\n  have := ht.to_subtype\n  apply toFinite\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finite/Prod.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b3 : Type*}", "{s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\nhs : s.Finite\nht : t.Finite\n\u22a2 (s \u00d7\u02e2 t).Finite"}, {"line": "have := hs.to_subtype", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\nhs : s.Finite\nht : t.Finite\nthis : Finite \u2191s\n\u22a2 (s \u00d7\u02e2 t).Finite"}, {"line": "have := ht.to_subtype", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\nhs : s.Finite\nht : t.Finite\nthis\u271d : Finite \u2191s\nthis : Finite \u2191t\n\u22a2 (s \u00d7\u02e2 t).Finite"}, {"line": "apply toFinite", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finite_prod : (s \u00d7\u02e2 t).Finite \u2194 (s.Finite \u2228 t = \u2205) \u2227 (t.Finite \u2228 s = \u2205) := by\n  simp only [\u2190 not_infinite]\n  simp only [Set.infinite_prod]\n  simp only [not_or]\n  simp only [not_and_or]\n  simp only [not_nonempty_iff_eq_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finite/Prod.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b3 : Type*}", "{s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 (s \u00d7\u02e2 t).Finite \u2194 (s.Finite \u2228 t = \u2205) \u2227 (t.Finite \u2228 s = \u2205)"}, {"line": "simp only [\u2190 not_infinite]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 \u00ac(s \u00d7\u02e2 t).Infinite \u2194 (\u00acs.Infinite \u2228 t = \u2205) \u2227 (\u00act.Infinite \u2228 s = \u2205)"}, {"line": "simp only [Set.infinite_prod]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 \u00ac(s.Infinite \u2227 t.Nonempty \u2228 t.Infinite \u2227 s.Nonempty) \u2194 (\u00acs.Infinite \u2228 t = \u2205) \u2227 (\u00act.Infinite \u2228 s = \u2205)"}, {"line": "simp only [not_or]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 \u00ac(s.Infinite \u2227 t.Nonempty) \u2227 \u00ac(t.Infinite \u2227 s.Nonempty) \u2194 (\u00acs.Infinite \u2228 t = \u2205) \u2227 (\u00act.Infinite \u2228 s = \u2205)"}, {"line": "simp only [not_and_or]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 (\u00acs.Infinite \u2228 \u00act.Nonempty) \u2227 (\u00act.Infinite \u2228 \u00acs.Nonempty) \u2194 (\u00acs.Infinite \u2228 t = \u2205) \u2227 (\u00act.Infinite \u2228 s = \u2205)"}, {"line": "simp only [not_nonempty_iff_eq_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Finite.image2 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (hs : s.Finite) (ht : t.Finite) :\n    (image2 f s t).Finite := by\n  have := hs.to_subtype\n  have := ht.to_subtype\n  apply toFinite\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finite/Prod.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b3 : Type*}", "{s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nhs : s.Finite\nht : t.Finite\n\u22a2 (image2 f s t).Finite"}, {"line": "have := hs.to_subtype", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nhs : s.Finite\nht : t.Finite\nthis : Finite \u2191s\n\u22a2 (image2 f s t).Finite"}, {"line": "have := ht.to_subtype", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nhs : s.Finite\nht : t.Finite\nthis\u271d : Finite \u2191s\nthis : Finite \u2191t\n\u22a2 (image2 f s t).Finite"}, {"line": "apply toFinite", "tactic_state": "No Goals!"}]}
{"declaration": "lemma finite_image2 (hfs : \u2200 b \u2208 t, InjOn (f \u00b7 b) s) (hft : \u2200 a \u2208 s, InjOn (f a) t) :\n    (image2 f s t).Finite \u2194 s.Finite \u2227 t.Finite \u2228 s = \u2205 \u2228 t = \u2205 := by\n  rw [\u2190 not_infinite]\n  rw [infinite_image2 hfs hft]\n  simp [not_or, -not_and, not_and_or, not_nonempty_iff_eq_empty]\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finite/Prod.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b3 : Type*}", "{s : Set \u03b1} {t : Set \u03b2}", "{s t : Set \u03b1}", "{f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nhfs : \u2200 b \u2208 t, InjOn (fun x => f x b) s\nhft : \u2200 a \u2208 s, InjOn (f a) t\n\u22a2 (image2 f s t).Finite \u2194 s.Finite \u2227 t.Finite \u2228 s = \u2205 \u2228 t = \u2205"}, {"line": "rw [\u2190 not_infinite]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nhfs : \u2200 b \u2208 t, InjOn (fun x => f x b) s\nhft : \u2200 a \u2208 s, InjOn (f a) t\n\u22a2 \u00ac(image2 f s t).Infinite \u2194 s.Finite \u2227 t.Finite \u2228 s = \u2205 \u2228 t = \u2205"}, {"line": "rw [infinite_image2 hfs hft]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nhfs : \u2200 b \u2208 t, InjOn (fun x => f x b) s\nhft : \u2200 a \u2208 s, InjOn (f a) t\n\u22a2 \u00ac(s.Infinite \u2227 t.Nonempty \u2228 t.Infinite \u2227 s.Nonempty) \u2194 s.Finite \u2227 t.Finite \u2228 s = \u2205 \u2228 t = \u2205"}, {"line": "simp [not_or, -not_and, not_and_or, not_nonempty_iff_eq_empty]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nhfs : \u2200 b \u2208 t, InjOn (fun x => f x b) s\nhft : \u2200 a \u2208 s, InjOn (f a) t\n\u22a2 (s.Finite \u2228 t = \u2205) \u2227 (t.Finite \u2228 s = \u2205) \u2194 s.Finite \u2227 t.Finite \u2228 s = \u2205 \u2228 t = \u2205"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.card_pos_iff [Finite \u03b1] : 0 < Nat.card \u03b1 \u2194 Nonempty \u03b1 := by\n  haveI := Fintype.ofFinite \u03b1\n  rw [Nat.card_eq_fintype_card]\n  rw [Fintype.card_pos_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finite/Card.lean", "context": {"open": ["scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\n\u22a2 0 < Nat.card \u03b1 \u2194 Nonempty \u03b1"}, {"line": "haveI := Fintype.ofFinite \u03b1", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\nthis : Fintype \u03b1\n\u22a2 0 < Nat.card \u03b1 \u2194 Nonempty \u03b1"}, {"line": "rw [Nat.card_eq_fintype_card]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\nthis : Fintype \u03b1\n\u22a2 0 < Fintype.card \u03b1 \u2194 Nonempty \u03b1"}, {"line": "rw [Fintype.card_pos_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_eq [Finite \u03b1] [Finite \u03b2] : Nat.card \u03b1 = Nat.card \u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2) := by\n  haveI := Fintype.ofFinite \u03b1\n  haveI := Fintype.ofFinite \u03b2\n  simp only [Nat.card_eq_fintype_card]\n  simp only [Fintype.card_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finite/Card.lean", "context": {"open": ["scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\n\u22a2 Nat.card \u03b1 = Nat.card \u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)"}, {"line": "haveI := Fintype.ofFinite \u03b1", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis : Fintype \u03b1\n\u22a2 Nat.card \u03b1 = Nat.card \u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)"}, {"line": "haveI := Fintype.ofFinite \u03b2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis\u271d : Fintype \u03b1\nthis : Fintype \u03b2\n\u22a2 Nat.card \u03b1 = Nat.card \u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)"}, {"line": "simp only [Nat.card_eq_fintype_card]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis\u271d : Fintype \u03b1\nthis : Fintype \u03b2\n\u22a2 Fintype.card \u03b1 = Fintype.card \u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)"}, {"line": "simp only [Fintype.card_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_le_one_iff_subsingleton [Finite \u03b1] : Nat.card \u03b1 \u2264 1 \u2194 Subsingleton \u03b1 := by\n  haveI := Fintype.ofFinite \u03b1\n  simp only [Nat.card_eq_fintype_card]\n  simp only [Fintype.card_le_one_iff_subsingleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finite/Card.lean", "context": {"open": ["scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\n\u22a2 Nat.card \u03b1 \u2264 1 \u2194 Subsingleton \u03b1"}, {"line": "haveI := Fintype.ofFinite \u03b1", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\nthis : Fintype \u03b1\n\u22a2 Nat.card \u03b1 \u2264 1 \u2194 Subsingleton \u03b1"}, {"line": "simp only [Nat.card_eq_fintype_card]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\nthis : Fintype \u03b1\n\u22a2 Fintype.card \u03b1 \u2264 1 \u2194 Subsingleton \u03b1"}, {"line": "simp only [Fintype.card_le_one_iff_subsingleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_card_iff_nontrivial [Finite \u03b1] : 1 < Nat.card \u03b1 \u2194 Nontrivial \u03b1 := by\n  haveI := Fintype.ofFinite \u03b1\n  simp only [Nat.card_eq_fintype_card]\n  simp only [Fintype.one_lt_card_iff_nontrivial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finite/Card.lean", "context": {"open": ["scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\n\u22a2 1 < Nat.card \u03b1 \u2194 Nontrivial \u03b1"}, {"line": "haveI := Fintype.ofFinite \u03b1", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\nthis : Fintype \u03b1\n\u22a2 1 < Nat.card \u03b1 \u2194 Nontrivial \u03b1"}, {"line": "simp only [Nat.card_eq_fintype_card]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\nthis : Fintype \u03b1\n\u22a2 1 < Fintype.card \u03b1 \u2194 Nontrivial \u03b1"}, {"line": "simp only [Fintype.one_lt_card_iff_nontrivial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_option [Finite \u03b1] : Nat.card (Option \u03b1) = Nat.card \u03b1 + 1 := by\n  haveI := Fintype.ofFinite \u03b1\n  simp only [Nat.card_eq_fintype_card]\n  simp only [Fintype.card_option]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finite/Card.lean", "context": {"open": ["scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\n\u22a2 Nat.card (Option \u03b1) = Nat.card \u03b1 + 1"}, {"line": "haveI := Fintype.ofFinite \u03b1", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\nthis : Fintype \u03b1\n\u22a2 Nat.card (Option \u03b1) = Nat.card \u03b1 + 1"}, {"line": "simp only [Nat.card_eq_fintype_card]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\nthis : Fintype \u03b1\n\u22a2 Fintype.card (Option \u03b1) = Fintype.card \u03b1 + 1"}, {"line": "simp only [Fintype.card_option]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_le_of_injective [Finite \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Function.Injective f) :\n    Nat.card \u03b1 \u2264 Nat.card \u03b2 := by\n  haveI := Fintype.ofFinite \u03b2\n  haveI := Fintype.ofInjective f hf\n  simpa only [Nat.card_eq_fintype_card] using Fintype.card_le_of_injective f hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finite/Card.lean", "context": {"open": ["scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : Finite \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Function.Injective f\n\u22a2 Nat.card \u03b1 \u2264 Nat.card \u03b2"}, {"line": "haveI := Fintype.ofFinite \u03b2", "tactic_state": "\u03b2 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : Finite \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Function.Injective f\nthis : Fintype \u03b2\n\u22a2 Nat.card \u03b1 \u2264 Nat.card \u03b2"}, {"line": "haveI := Fintype.ofInjective f hf", "tactic_state": "\u03b2 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : Finite \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Function.Injective f\nthis\u271d : Fintype \u03b2\nthis : Fintype \u03b1\n\u22a2 Nat.card \u03b1 \u2264 Nat.card \u03b2"}, {"line": "simpa only [Nat.card_eq_fintype_card] using Fintype.card_le_of_injective f hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_eq_zero_iff [Finite \u03b1] : Nat.card \u03b1 = 0 \u2194 IsEmpty \u03b1 := by\n  haveI := Fintype.ofFinite \u03b1\n  simp only [Nat.card_eq_fintype_card]\n  simp only [Fintype.card_eq_zero_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finite/Card.lean", "context": {"open": ["scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\n\u22a2 Nat.card \u03b1 = 0 \u2194 IsEmpty \u03b1"}, {"line": "haveI := Fintype.ofFinite \u03b1", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\nthis : Fintype \u03b1\n\u22a2 Nat.card \u03b1 = 0 \u2194 IsEmpty \u03b1"}, {"line": "simp only [Nat.card_eq_fintype_card]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\nthis : Fintype \u03b1\n\u22a2 Fintype.card \u03b1 = 0 \u2194 IsEmpty \u03b1"}, {"line": "simp only [Fintype.card_eq_zero_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_eq_zero_of_surjective {f : \u03b1 \u2192 \u03b2} (hf : Function.Surjective f) (h : Nat.card \u03b2 = 0) :\n    Nat.card \u03b1 = 0 := by\n  cases finite_or_infinite \u03b2\n  \u00b7 haveI := card_eq_zero_iff.mp h\n    haveI := Function.isEmpty f\n    exact Nat.card_of_isEmpty\n  \u00b7 haveI := Infinite.of_surjective f hf\n    exact Nat.card_eq_zero_of_infinite\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finite/Card.lean", "context": {"open": ["scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Function.Surjective f\nh : Nat.card \u03b2 = 0\n\u22a2 Nat.card \u03b1 = 0"}, {"line": "cases finite_or_infinite \u03b2", "tactic_state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Function.Surjective f\nh : Nat.card \u03b2 = 0\nh\u271d : Finite \u03b2\n\u22a2 Nat.card \u03b1 = 0\n---\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Function.Surjective f\nh : Nat.card \u03b2 = 0\nh\u271d : Infinite \u03b2\n\u22a2 Nat.card \u03b1 = 0"}, {"line": "\u00b7 haveI := card_eq_zero_iff.mp h\n    haveI := Function.isEmpty f\n    exact Nat.card_of_isEmpty", "tactic_state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Function.Surjective f\nh : Nat.card \u03b2 = 0\nh\u271d : Infinite \u03b2\n\u22a2 Nat.card \u03b1 = 0"}, {"line": "\u00b7 haveI := Infinite.of_surjective f hf\n    exact Nat.card_eq_zero_of_infinite", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_sum [Finite \u03b1] [Finite \u03b2] : Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2 := by\n  haveI := Fintype.ofFinite \u03b1\n  haveI := Fintype.ofFinite \u03b2\n  simp only [Nat.card_eq_fintype_card]\n  simp only [Fintype.card_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finite/Card.lean", "context": {"open": ["scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2"}, {"line": "haveI := Fintype.ofFinite \u03b1", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis : Fintype \u03b1\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2"}, {"line": "haveI := Fintype.ofFinite \u03b2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis\u271d : Fintype \u03b1\nthis : Fintype \u03b2\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2"}, {"line": "simp only [Nat.card_eq_fintype_card]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis\u271d : Fintype \u03b1\nthis : Fintype \u03b2\n\u22a2 Fintype.card (\u03b1 \u2295 \u03b2) = Fintype.card \u03b1 + Fintype.card \u03b2"}, {"line": "simp only [Fintype.card_sum]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_lt_card (ht : t.Finite) (hsub : s \u2282 t) : Nat.card s < Nat.card t := by\n  have : Fintype t := Finite.fintype ht\n  have : Fintype s := Finite.fintype (subset ht (subset_of_ssubset hsub))\n  simp only [Nat.card_eq_fintype_card]\n  exact Set.card_lt_card hsub\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finite/Card.lean", "context": {"open": ["scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\nht : t.Finite\nhsub : s \u2282 t\n\u22a2 Nat.card \u2191s < Nat.card \u2191t"}, {"line": "have : Fintype t := Finite.fintype ht", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\nht : t.Finite\nhsub : s \u2282 t\nthis : Fintype \u2191t\n\u22a2 Nat.card \u2191s < Nat.card \u2191t"}, {"line": "have : Fintype s := Finite.fintype (subset ht (subset_of_ssubset hsub))", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\nht : t.Finite\nhsub : s \u2282 t\nthis\u271d : Fintype \u2191t\nthis : Fintype \u2191s\n\u22a2 Nat.card \u2191s < Nat.card \u2191t"}, {"line": "simp only [Nat.card_eq_fintype_card]", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\nht : t.Finite\nhsub : s \u2282 t\nthis\u271d : Fintype \u2191t\nthis : Fintype \u2191s\n\u22a2 Fintype.card \u2191s < Fintype.card \u2191t"}, {"line": "exact Set.card_lt_card hsub", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_subset : s.toFinset \u2286 t.toFinset \u2194 s \u2286 t := by\n  simp only [Finset.subset_iff]\n  simp only [Multiset.subset_iff]\n  simp only [Multiset.mem_toFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Dedup.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s t : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\n\u22a2 s.toFinset \u2286 t.toFinset \u2194 s \u2286 t"}, {"line": "simp only [Finset.subset_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\n\u22a2 (\u2200 \u2983x : \u03b1\u2984, x \u2208 s.toFinset \u2192 x \u2208 t.toFinset) \u2194 s \u2286 t"}, {"line": "simp only [Multiset.subset_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\n\u22a2 (\u2200 \u2983x : \u03b1\u2984, x \u2208 s.toFinset \u2192 x \u2208 t.toFinset) \u2194 \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 x \u2208 t"}, {"line": "simp only [Multiset.mem_toFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_ssubset : s.toFinset \u2282 t.toFinset \u2194 s \u2282 t := by\n  simp_rw [Finset.ssubset_def, toFinset_subset]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Dedup.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s t : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\n\u22a2 s.toFinset \u2282 t.toFinset \u2194 s \u2282 t"}, {"line": "simp_rw [Finset.ssubset_def, toFinset_subset]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\n\u22a2 s \u2286 t \u2227 \u00act \u2286 s \u2194 s \u2282 t"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_dedup (m : Multiset \u03b1) : m.dedup.toFinset = m.toFinset := by\n  simp_rw [toFinset, dedup_idem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Dedup.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s t : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nm : Multiset \u03b1\n\u22a2 m.dedup.toFinset = m.toFinset"}, {"line": "simp_rw [toFinset, dedup_idem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toList_toFinset [DecidableEq \u03b1] (s : Finset \u03b1) : s.toList.toFinset = s := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Dedup.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s t : Multiset \u03b1}", "[DecidableEq \u03b1] {l l' : List \u03b1} {a : \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 s.toList.toFinset = s"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 s.toList.toFinset \u2194 a\u271d \u2208 s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem filter_congr_decidable (s : Finset \u03b1) (p : \u03b1 \u2192 Prop) (h : DecidablePred p)\n    [DecidablePred p] : @filter \u03b1 p h s = s.filter p := by congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Filter.lean", "context": {"open": ["Multiset Subtype Function", "Lean Elab Term Meta Batteries.ExtendedBinder"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "{p}", "(p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\np : \u03b1 \u2192 Prop\nh inst\u271d : DecidablePred p\n\u22a2 sorry"}, {"line": "congr", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\np : \u03b1 \u2192 Prop\nh inst\u271d : DecidablePred p\n\u22a2 sorry"}]}
{"declaration": "lemma filter_eq_self : s.filter p = s \u2194 \u2200 x \u2208 s, p x := by simp [Finset.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Filter.lean", "context": {"open": ["Multiset Subtype Function", "Lean Elab Term Meta Batteries.ExtendedBinder"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "{p}", "(p)", "{p q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\ns : Finset \u03b1\n\u22a2 Finset.filter p s = s \u2194 \u2200 x \u2208 s, p x"}, {"line": "simp [Finset.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem filter_eq_empty_iff : s.filter p = \u2205 \u2194 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u00acp x := by simp [Finset.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Filter.lean", "context": {"open": ["Multiset Subtype Function", "Lean Elab Term Meta Batteries.ExtendedBinder"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "{p}", "(p)", "{p q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\ns : Finset \u03b1\n\u22a2 Finset.filter p s = \u2205 \u2194 \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 \u00acp x"}, {"line": "simp [Finset.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem filter_const (p : Prop) [Decidable p] (s : Finset \u03b1) :\n    (s.filter fun _a => p) = if p then s else \u2205 := by split_ifs <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Filter.lean", "context": {"open": ["Multiset Subtype Function", "Lean Elab Term Meta Batteries.ExtendedBinder"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "{p}", "(p)", "{p q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : Prop\ninst\u271d : Decidable p\ns : Finset \u03b1\n\u22a2 {_a \u2208 s | p} = if p then s else \u2205"}, {"line": "split_ifs <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.Set.pairwiseDisjoint_filter [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2) (t : Finset \u03b1) :\n    s.PairwiseDisjoint fun x \u21a6 t.filter (f \u00b7 = x) := by\n  rintro i - j - h u hi hj x hx\n  obtain \u27e8-, rfl\u27e9 : x \u2208 t \u2227 f x = i := by simpa using hi hx\n  obtain \u27e8-, rfl\u27e9 : x \u2208 t \u2227 f x = j := by simpa using hj hx\n  contradiction\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Filter.lean", "context": {"open": ["Multiset Subtype Function", "Lean Elab Term Meta Batteries.ExtendedBinder"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "{p}", "(p)", "{p q}", "(p q)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt : Finset \u03b1\n\u22a2 s.PairwiseDisjoint fun x => {x_1 \u2208 t | f x_1 = x}"}, {"line": "rintro i - j - h u hi hj x hx", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt : Finset \u03b1\ni j : \u03b2\nh : i \u2260 j\nu : Finset \u03b1\nhi : u \u2264 (fun x => {x_1 \u2208 t | f x_1 = x}) i\nhj : u \u2264 (fun x => {x_1 \u2208 t | f x_1 = x}) j\nx : \u03b1\nhx : x \u2208 u\n\u22a2 x \u2208 \u22a5"}, {"line": "obtain \u27e8-, rfl\u27e9 : x \u2208 t \u2227 f x = i := by simpa using hi hx", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt : Finset \u03b1\nj : \u03b2\nu : Finset \u03b1\nhj : u \u2264 (fun x => {x_1 \u2208 t | f x_1 = x}) j\nx : \u03b1\nhx : x \u2208 u\nh : f x \u2260 j\nhi : u \u2264 (fun x => {x_1 \u2208 t | f x_1 = x}) (f x)\n\u22a2 x \u2208 \u22a5"}, {"line": "obtain \u27e8-, rfl\u27e9 : x \u2208 t \u2227 f x = j := by simpa using hj hx", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt u : Finset \u03b1\nx : \u03b1\nhx : x \u2208 u\nhi hj : u \u2264 (fun x => {x_1 \u2208 t | f x_1 = x}) (f x)\nh : f x \u2260 f x\n\u22a2 x \u2208 \u22a5"}, {"line": "contradiction", "tactic_state": "No Goals!"}]}
{"declaration": "lemma filter_inj : s.filter p = t.filter p \u2194 \u2200 \u2983a\u2984, p a \u2192 (a \u2208 s \u2194 a \u2208 t) := by\n  simp [Finset.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Filter.lean", "context": {"open": ["Multiset Subtype Function", "Lean Elab Term Meta Batteries.ExtendedBinder"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "{p}", "(p)", "{p q}", "(p q)", "{p q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\ns t : Finset \u03b1\n\u22a2 Finset.filter p s = Finset.filter p t \u2194 \u2200 \u2983a : \u03b1\u2984, p a \u2192 (a \u2208 s \u2194 a \u2208 t)"}, {"line": "simp [Finset.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma filter_inj' : s.filter p = s.filter q \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 (p a \u2194 q a) := by\n  simp [Finset.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Filter.lean", "context": {"open": ["Multiset Subtype Function", "Lean Elab Term Meta Batteries.ExtendedBinder"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "{p}", "(p)", "{p q}", "(p q)", "{p q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ns : Finset \u03b1\n\u22a2 Finset.filter p s = Finset.filter q s \u2194 \u2200 \u2983a : \u03b1\u2984, a \u2208 s \u2192 (p a \u2194 q a)"}, {"line": "simp [Finset.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_valEmbedding_attachFin {s : Finset \u2115} (h : \u2200 m \u2208 s, m < n) :\n    map Fin.valEmbedding (s.attachFin h) = s := by\n  simp [map_eq_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Fin.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nmap : x\u271d\ns : Finset \u2115\nh : \u2200 m \u2208 s, m < n\n\u22a2 sorry = s"}, {"line": "simp [map_eq_image]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nmap : x\u271d\ns : Finset \u2115\nh : \u2200 m \u2208 s, m < n\n\u22a2 sorry () = s"}]}
{"declaration": "lemma attachFin_subset_attachFin_iff {s t : Finset \u2115} (hs : \u2200 m \u2208 s, m < n) (ht : \u2200 m \u2208 t, m < n) :\n    s.attachFin hs \u2286 t.attachFin ht \u2194 s \u2286 t := by\n  simp [\u2190 map_subset_map (f := Fin.valEmbedding)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Fin.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ns t : Finset \u2115\nhs : \u2200 m \u2208 s, m < n\nht : \u2200 m \u2208 t, m < n\n\u22a2 s.attachFin hs \u2286 t.attachFin ht \u2194 s \u2286 t"}, {"line": "simp [\u2190 map_subset_map (f := Fin.valEmbedding)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma attachFin_subset_attachFin {s t : Finset \u2115} (hst : s \u2286 t) (ht : \u2200 m \u2208 t, m < n) :\n    s.attachFin (fun m hm \u21a6 ht m (hst hm)) \u2286 t.attachFin ht := by simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Fin.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ns t : Finset \u2115\nhst : s \u2286 t\nht : \u2200 m \u2208 t, m < n\n\u22a2 s.attachFin \u22ef \u2286 t.attachFin ht"}, {"line": "simpa", "tactic_state": "No Goals!"}]}
{"declaration": "lemma attachFin_ssubset_attachFin {s t : Finset \u2115} (hst : s \u2282 t) (ht : \u2200 m \u2208 t, m < n) :\n    s.attachFin (fun m hm \u21a6 ht m (hst.subset hm)) \u2282 t.attachFin ht := by simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Fin.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ns t : Finset \u2115\nhst : s \u2282 t\nht : \u2200 m \u2208 t, m < n\n\u22a2 s.attachFin \u22ef \u2282 t.attachFin ht"}, {"line": "simpa", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fin_map {s : Finset \u2115} : (s.fin n).map Fin.valEmbedding = s.filter (\u00b7 < n) := by\n  simp [Finset.fin, Finset.map_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Fin.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ns : Finset \u2115\n\u22a2 Finset.map Fin.valEmbedding (Finset.fin n s) = {x \u2208 s | x < n}"}, {"line": "simp [Finset.fin, Finset.map_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem attachFin_eq_fin {s : Finset \u2115} (h : \u2200 m \u2208 s, m < n) :\n    attachFin s h = s.fin n := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Fin.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nattachFin : x\u271d\ns : Finset \u2115\nh : \u2200 m \u2208 s, m < n\n\u22a2 sorry = Finset.fin n s"}, {"line": "ext", "tactic_state": "case h\nn : \u2115\nx\u271d : Sort u_1\nattachFin : x\u271d\ns : Finset \u2115\nh : \u2200 m \u2208 s, m < n\na\u271d : Fin n\n\u22a2 a\u271d \u2208 sorry \u2194 a\u271d \u2208 Finset.fin n s"}, {"line": "simp", "tactic_state": "case h\nn : \u2115\nx\u271d : Sort u_1\nattachFin : x\u271d\ns : Finset \u2115\nh : \u2200 m \u2208 s, m < n\na\u271d : Fin n\n\u22a2 a\u271d \u2208 sorry () \u2194 \u2191a\u271d \u2208 s"}]}
{"declaration": "lemma isAtom_iff : IsAtom s \u2194 \u2203 a, s = {a} := by simp [\u2190 bot_covBy_iff, covBy_iff, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Grade.lean", "context": {"open": ["Order"], "variables": ["{\u03b1 : Type*}", "{s t : Multiset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Multiset \u03b1\n\u22a2 IsAtom s \u2194 \u2203 a, s = {a}"}, {"line": "simp [\u2190 bot_covBy_iff, covBy_iff, eq_comm]", "tactic_state": "\u03b1 : Type u_1\ns : Multiset \u03b1\n\u22a2 0 \u22d6 s \u2194 \u2203 a, s = {a}"}]}
{"declaration": "lemma Nat.divisors_mul (m n : \u2115) : divisors (m * n) = divisors m * divisors n := by\n  ext k\n  simp_rw [mem_mul, mem_divisors, Nat.dvd_mul, mul_ne_zero_iff, \u2190 exists_and_left,\n    \u2190 exists_and_right]\n  simp only [and_assoc]\n  simp only [and_comm]\n  simp only [and_left_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/NatDivisors.lean", "context": {"open": ["Nat Finset", "scoped Pointwise"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 (m * n).divisors = m.divisors * n.divisors"}, {"line": "ext k", "tactic_state": "case h\nm n k : \u2115\n\u22a2 k \u2208 (m * n).divisors \u2194 k \u2208 m.divisors * n.divisors"}, {"line": "simp_rw [mem_mul, mem_divisors, Nat.dvd_mul, mul_ne_zero_iff, \u2190 exists_and_left,\n    \u2190 exists_and_right]", "tactic_state": "case h\nm n k : \u2115\n\u22a2 (\u2203 x x_1, (x \u2223 m \u2227 x_1 \u2223 n \u2227 x * x_1 = k) \u2227 m \u2260 0 \u2227 n \u2260 0) \u2194 \u2203 y x, (y \u2223 m \u2227 m \u2260 0) \u2227 (x \u2223 n \u2227 n \u2260 0) \u2227 y * x = k"}, {"line": "simp only [and_assoc]", "tactic_state": "case h\nm n k : \u2115\n\u22a2 (\u2203 x x_1, x \u2223 m \u2227 x_1 \u2223 n \u2227 x * x_1 = k \u2227 m \u2260 0 \u2227 n \u2260 0) \u2194 \u2203 y x, y \u2223 m \u2227 m \u2260 0 \u2227 x \u2223 n \u2227 n \u2260 0 \u2227 y * x = k"}, {"line": "simp only [and_comm]", "tactic_state": "case h\nm n k : \u2115\n\u22a2 (\u2203 x x_1, x \u2223 m \u2227 x_1 \u2223 n \u2227 x * x_1 = k \u2227 m \u2260 0 \u2227 n \u2260 0) \u2194 \u2203 y x, y \u2223 m \u2227 m \u2260 0 \u2227 x \u2223 n \u2227 y * x = k \u2227 n \u2260 0"}, {"line": "simp only [and_left_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Nat.Prime.divisors_sq {p : \u2115} (hp : p.Prime) : (p ^ 2).divisors = {p ^ 2, p, 1} := by\n  simp [divisors_prime_pow hp, range_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/NatDivisors.lean", "context": {"open": ["Nat Finset", "scoped Pointwise"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Prime p\n\u22a2 (p ^ 2).divisors = {p ^ 2, p, 1}"}, {"line": "simp [divisors_prime_pow hp, range_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_toFinset {a : \u03b1} {o : Option \u03b1} : a \u2208 o.toFinset \u2194 a \u2208 o := by\n  cases o <;> simp [eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Option.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\no : Option \u03b1\n\u22a2 a \u2208 o.toFinset \u2194 a \u2208 o"}, {"line": "cases o <;> simp [eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_toFinset (o : Option \u03b1) : o.toFinset.card = o.elim 0 1 := by cases o <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Option.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\no : Option \u03b1\n\u22a2 o.toFinset.card = o.elim 0 1"}, {"line": "cases o <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem some_mem_insertNone {s : Finset \u03b1} {a : \u03b1} : some a \u2208 insertNone s \u2194 a \u2208 s := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Option.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\ninsertNone : x\u271d\ns : Finset \u03b1\na : \u03b1\n\u22a2 some a \u2208 sorry \u2194 a \u2208 s"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\ninsertNone : x\u271d\ns : Finset \u03b1\na : \u03b1\n\u22a2 some a \u2208 sorry () \u2194 a \u2208 s"}]}
{"declaration": "lemma none_mem_insertNone {s : Finset \u03b1} : none \u2208 insertNone s := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Option.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\ninsertNone : x\u271d\ns : Finset \u03b1\n\u22a2 none \u2208 sorry"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\ninsertNone : x\u271d\ns : Finset \u03b1\n\u22a2 none \u2208 sorry ()"}]}
{"declaration": "theorem card_insertNone (s : Finset \u03b1) : s.insertNone.card = s.card + 1 := by simp [insertNone]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Option.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\n\u22a2 (Finset.insertNone s).card = s.card + 1"}, {"line": "simp [insertNone]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_eraseNone {s : Finset (Option \u03b1)} {x : \u03b1} : x \u2208 eraseNone s \u2194 some x \u2208 s := by\n  simp [eraseNone]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Option.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\neraseNone : x\u271d\ns : Finset (Option \u03b1)\nx : \u03b1\n\u22a2 x \u2208 sorry \u2194 some x \u2208 s"}, {"line": "simp [eraseNone]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\neraseNone : x\u271d\ns : Finset (Option \u03b1)\nx : \u03b1\n\u22a2 x \u2208 sorry () \u2194 some x \u2208 s"}]}
{"declaration": "theorem eraseNone_eq_biUnion [DecidableEq \u03b1] (s : Finset (Option \u03b1)) :\n    eraseNone s = s.biUnion Option.toFinset := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Option.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\neraseNone : x\u271d\ninst\u271d : DecidableEq \u03b1\ns : Finset (Option \u03b1)\n\u22a2 sorry = s.biUnion Option.toFinset"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\nx\u271d : Sort u_3\neraseNone : x\u271d\ninst\u271d : DecidableEq \u03b1\ns : Finset (Option \u03b1)\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 sorry \u2194 a\u271d \u2208 s.biUnion Option.toFinset"}, {"line": "simp", "tactic_state": "case h\n\u03b1 : Type u_1\nx\u271d : Sort u_3\neraseNone : x\u271d\ninst\u271d : DecidableEq \u03b1\ns : Finset (Option \u03b1)\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 sorry () \u2194 some a\u271d \u2208 s"}]}
{"declaration": "theorem eraseNone_map_some (s : Finset \u03b1) : eraseNone (s.map Embedding.some) = s := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Option.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\neraseNone : x\u271d\ns : Finset \u03b1\n\u22a2 sorry = s"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\nx\u271d : Sort u_3\neraseNone : x\u271d\ns : Finset \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 sorry \u2194 a\u271d \u2208 s"}, {"line": "simp", "tactic_state": "case h\n\u03b1 : Type u_1\nx\u271d : Sort u_3\neraseNone : x\u271d\ns : Finset \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 sorry () \u2194 a\u271d \u2208 s"}]}
{"declaration": "theorem eraseNone_image_some [DecidableEq (Option \u03b1)] (s : Finset \u03b1) :\n    eraseNone (s.image some) = s := by simpa only [map_eq_image] using eraseNone_map_some s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Option.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\neraseNone : x\u271d\ninst\u271d : DecidableEq (Option \u03b1)\ns : Finset \u03b1\n\u22a2 sorry = s"}, {"line": "simpa only [map_eq_image] using eraseNone_map_some s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_some_eraseNone [DecidableEq (Option \u03b1)] (s : Finset (Option \u03b1)) :\n    (eraseNone s).image some = s.erase none := by ext (_ | x) <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Option.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\neraseNone : x\u271d\ninst\u271d : DecidableEq (Option \u03b1)\ns : Finset (Option \u03b1)\n\u22a2 sorry = s.erase none"}, {"line": "ext (_ | x) <;> simp", "tactic_state": "case h.none\n\u03b1 : Type u_1\nx\u271d : Sort u_3\neraseNone : x\u271d\ninst\u271d : DecidableEq (Option \u03b1)\ns : Finset (Option \u03b1)\n\u22a2 none \u2209 sorry ()\n---\ncase h.some\n\u03b1 : Type u_1\nx\u271d : Sort u_3\neraseNone : x\u271d\ninst\u271d : DecidableEq (Option \u03b1)\ns : Finset (Option \u03b1)\nx : \u03b1\n\u22a2 some x \u2208 sorry () \u2194 some x \u2208 s"}]}
{"declaration": "theorem insertNone_eraseNone [DecidableEq (Option \u03b1)] (s : Finset (Option \u03b1)) :\n    insertNone (eraseNone s) = insert none s := by ext (_ | x) <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Option.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\ninsertNone : x\u271d\ninst\u271d : DecidableEq (Option \u03b1)\ns : Finset (Option \u03b1)\n\u22a2 sorry = insert none s"}, {"line": "ext (_ | x) <;> simp", "tactic_state": "case h.none\n\u03b1 : Type u_1\nx\u271d : Sort u_3\ninsertNone : x\u271d\ninst\u271d : DecidableEq (Option \u03b1)\ns : Finset (Option \u03b1)\n\u22a2 none \u2208 sorry ()\n---\ncase h.some\n\u03b1 : Type u_1\nx\u271d : Sort u_3\ninsertNone : x\u271d\ninst\u271d : DecidableEq (Option \u03b1)\ns : Finset (Option \u03b1)\nx : \u03b1\n\u22a2 some x \u2208 sorry () \u2194 some x \u2208 s"}]}
{"declaration": "theorem eraseNone_insertNone (s : Finset \u03b1) : eraseNone (insertNone s) = s := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Option.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\neraseNone : x\u271d\ns : Finset \u03b1\n\u22a2 sorry = s"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\nx\u271d : Sort u_3\neraseNone : x\u271d\ns : Finset \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 sorry \u2194 a\u271d \u2208 s"}, {"line": "simp", "tactic_state": "case h\n\u03b1 : Type u_1\nx\u271d : Sort u_3\neraseNone : x\u271d\ns : Finset \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 sorry () \u2194 a\u271d \u2208 s"}]}
{"declaration": "theorem mem_toFinset {o : Part \u03b1} [Decidable o.Dom] {x : \u03b1} : x \u2208 o.toFinset \u2194 x \u2208 o := by\n  simp [toFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/PImage.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\no : Part \u03b1\ninst\u271d : Decidable o.Dom\nx : \u03b1\n\u22a2 x \u2208 o.toFinset \u2194 x \u2208 o"}, {"line": "simp [toFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_some {a : \u03b1} [Decidable (some a).Dom] : (some a).toFinset = {a} := by\n  simp [toFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/PImage.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\ninst\u271d : Decidable sorry\n\u22a2 (some a).toFinset = {a}"}, {"line": "simp [toFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pimage_some (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) [\u2200 x, Decidable (Part.some <| f x).Dom] :\n    (s.pimage fun x => Part.some (f x)) = s.image f := by\n  ext\n  simp [eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/PImage.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b2] {f g : \u03b1 \u2192. \u03b2} [\u2200 x, Decidable (f x).Dom] [\u2200 x, Decidable (g x).Dom]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : (x : \u03b1) \u2192 Decidable (Part.some (f x)).Dom\n\u22a2 Finset.pimage (fun x => Part.some (f x)) s = Finset.image f s"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : (x : \u03b1) \u2192 Decidable (Part.some (f x)).Dom\na\u271d : \u03b2\n\u22a2 a\u271d \u2208 Finset.pimage (fun x => Part.some (f x)) s \u2194 a\u271d \u2208 Finset.image f s"}, {"line": "simp [eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pimage_congr (h\u2081 : s = t) (h\u2082 : \u2200 x \u2208 t, f x = g x) : s.pimage f = t.pimage g := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/PImage.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b2] {f g : \u03b1 \u2192. \u03b2} [\u2200 x, Decidable (f x).Dom] [\u2200 x, Decidable (g x).Dom]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b2\nf g : \u03b1 \u2192. \u03b2\ninst\u271d\u00b9 : (x : \u03b1) \u2192 Decidable (f x).Dom\ninst\u271d : (x : \u03b1) \u2192 Decidable (g x).Dom\n\u03b1\u271d : Type u_3\ns t : \u03b1\u271d\nh\u2081 : s = t\nh\u2082 : \u2200 x \u2208 t, f x = g x\n\u22a2 sorry = sorry"}, {"line": "aesop", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst : DecidableEq \u03b2\nf g : \u03b1 \u2192. \u03b2\ninst_1 : (x : \u03b1) \u2192 Decidable (f x).Dom\ninst_2 : (x : \u03b1) \u2192 Decidable (g x).Dom\ns t : ?m.1000\nh\u2081 : s = t\nh\u2082 : \u2200 x \u2208 t, f x = g x\n\u22a2 Sort u_4"}]}
{"declaration": "theorem pimage_eq_image_filter : s.pimage f =\n    {x \u2208 s | (f x).Dom}.attach.image\n      fun x : { x // x \u2208 filter (fun x => (f x).Dom) s } =>\n        (f x).get (mem_filter.mp x.coe_prop).2 := by\n  aesop (add simp Part.mem_eq)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/PImage.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b2] {f g : \u03b1 \u2192. \u03b2} [\u2200 x, Decidable (f x).Dom] [\u2200 x, Decidable (g x).Dom]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Type u_3\ns : x\u271d\n\u22a2 sorry = sorry"}, {"line": "aesop (add simp Part.mem_eq)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b2\nf g : \u03b1 \u2192. \u03b2\ninst\u271d\u00b9 : (x : \u03b1) \u2192 Decidable (f x).Dom\ninst\u271d : (x : \u03b1) \u2192 Decidable (g x).Dom\ns : ?m.107\n\u22a2 Sort u_4"}]}
{"declaration": "theorem Finset.pairwiseDisjoint_range_singleton :\n    (Set.range (singleton : \u03b1 \u2192 Finset \u03b1)).PairwiseDisjoint id := by\n  rintro _ \u27e8a, rfl\u27e9 _ \u27e8b, rfl\u27e9 h\n  exact disjoint_singleton.2 (ne_of_apply_ne _ h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Pairwise.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 \u03b9 \u03b9' : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 (Set.range singleton).PairwiseDisjoint id"}, {"line": "rintro _ \u27e8a, rfl\u27e9 _ \u27e8b, rfl\u27e9 h", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\na b : \u03b1\nh : {a} \u2260 {b}\n\u22a2 Function.onFun Disjoint id {a} {b}"}, {"line": "exact disjoint_singleton.2 (ne_of_apply_ne _ h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PairwiseDisjoint.image_finset_of_le [DecidableEq \u03b9] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}\n    (hs : (s : Set \u03b9).PairwiseDisjoint f) {g : \u03b9 \u2192 \u03b9} (hf : \u2200 a, f (g a) \u2264 f a) :\n    (s.image g : Set \u03b9).PairwiseDisjoint f := by\n  rw [coe_image]\n  exact hs.image_of_le hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Pairwise.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 \u03b9 \u03b9' : Type*}", "[SemilatticeInf \u03b1] [OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : DecidableEq \u03b9\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : (\u2191s).PairwiseDisjoint f\ng : \u03b9 \u2192 \u03b9\nhf : \u2200 (a : \u03b9), f (g a) \u2264 f a\n\u22a2 (\u2191(image g s)).PairwiseDisjoint f"}, {"line": "rw [coe_image]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : DecidableEq \u03b9\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : (\u2191s).PairwiseDisjoint f\ng : \u03b9 \u2192 \u03b9\nhf : \u2200 (a : \u03b9), f (g a) \u2264 f a\n\u22a2 (g '' \u2191s).PairwiseDisjoint f"}, {"line": "exact hs.image_of_le hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PairwiseDisjoint.biUnion_finset {s : Set \u03b9'} {g : \u03b9' \u2192 Finset \u03b9} {f : \u03b9 \u2192 \u03b1}\n    (hs : s.PairwiseDisjoint fun i' : \u03b9' => (g i').sup f)\n    (hg : \u2200 i \u2208 s, (g i : Set \u03b9).PairwiseDisjoint f) : (\u22c3 i \u2208 s, \u2191(g i)).PairwiseDisjoint f := by\n  rintro a ha b hb hab\n  simp_rw [Set.mem_iUnion] at ha hb\n  obtain \u27e8c, hc, ha\u27e9 := ha\n  obtain \u27e8d, hd, hb\u27e9 := hb\n  obtain hcd | hcd := eq_or_ne (g c) (g d)\n  \u00b7 exact hg d hd (by rwa [hcd] at ha) hb hab\n  \u00b7 exact (hs hc hd (ne_of_apply_ne _ hcd)).mono (Finset.le_sup ha) (Finset.le_sup hb)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Pairwise.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 \u03b9 \u03b9' : Type*}", "[SemilatticeInf \u03b1] [OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}", "[Lattice \u03b1] [OrderBot \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint fun i' => sorry\nhg : \u2200 i \u2208 s, (\u2191(g i)).PairwiseDisjoint f\n\u22a2 (\u22c3 i \u2208 s, \u2191(g i)).PairwiseDisjoint f"}, {"line": "rintro a ha b hb hab", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint fun i' => sorry\nhg : \u2200 i \u2208 s, (\u2191(g i)).PairwiseDisjoint f\na : \u03b9\nha : a \u2208 \u22c3 i \u2208 s, \u2191(g i)\nb : \u03b9\nhb : b \u2208 \u22c3 i \u2208 s, \u2191(g i)\nhab : a \u2260 b\n\u22a2 Function.onFun Disjoint f a b"}, {"line": "simp_rw [Set.mem_iUnion] at ha hb", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint fun i' => sorry\nhg : \u2200 i \u2208 s, (\u2191(g i)).PairwiseDisjoint f\na b : \u03b9\nhab : a \u2260 b\nha : \u2203 i, \u2203 (_ : i \u2208 s), a \u2208 \u2191(g i)\nhb : \u2203 i, \u2203 (_ : i \u2208 s), b \u2208 \u2191(g i)\n\u22a2 Function.onFun Disjoint f a b"}, {"line": "obtain \u27e8c, hc, ha\u27e9 := ha", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint fun i' => sorry\nhg : \u2200 i \u2208 s, (\u2191(g i)).PairwiseDisjoint f\na b : \u03b9\nhab : a \u2260 b\nhb : \u2203 i, \u2203 (_ : i \u2208 s), b \u2208 \u2191(g i)\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 \u2191(g c)\n\u22a2 Function.onFun Disjoint f a b"}, {"line": "obtain \u27e8d, hd, hb\u27e9 := hb", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint fun i' => sorry\nhg : \u2200 i \u2208 s, (\u2191(g i)).PairwiseDisjoint f\na b : \u03b9\nhab : a \u2260 b\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 \u2191(g c)\nd : \u03b9'\nhd : d \u2208 s\nhb : b \u2208 \u2191(g d)\n\u22a2 Function.onFun Disjoint f a b"}, {"line": "obtain hcd | hcd := eq_or_ne (g c) (g d)", "tactic_state": "case intro.intro.intro.intro.inl\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint fun i' => sorry\nhg : \u2200 i \u2208 s, (\u2191(g i)).PairwiseDisjoint f\na b : \u03b9\nhab : a \u2260 b\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 \u2191(g c)\nd : \u03b9'\nhd : d \u2208 s\nhb : b \u2208 \u2191(g d)\nhcd : g c = g d\n\u22a2 Function.onFun Disjoint f a b\n---\ncase intro.intro.intro.intro.inr\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint fun i' => sorry\nhg : \u2200 i \u2208 s, (\u2191(g i)).PairwiseDisjoint f\na b : \u03b9\nhab : a \u2260 b\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 \u2191(g c)\nd : \u03b9'\nhd : d \u2208 s\nhb : b \u2208 \u2191(g d)\nhcd : g c \u2260 g d\n\u22a2 Function.onFun Disjoint f a b"}, {"line": "\u00b7 exact hg d hd (by rwa [hcd] at ha) hb hab", "tactic_state": "case intro.intro.intro.intro.inr\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b3 : SemilatticeInf \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint fun i' => sorry\nhg : \u2200 i \u2208 s, (\u2191(g i)).PairwiseDisjoint f\na b : \u03b9\nhab : a \u2260 b\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 \u2191(g c)\nd : \u03b9'\nhd : d \u2208 s\nhb : b \u2208 \u2191(g d)\nhcd : g c \u2260 g d\n\u22a2 Function.onFun Disjoint f a b"}, {"line": "\u00b7 exact (hs hc hd (ne_of_apply_ne _ hcd)).mono (Finset.le_sup ha) (Finset.le_sup hb)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sigma_preimage_mk {\u03b2 : \u03b1 \u2192 Type*} [DecidableEq \u03b1] (s : Finset (\u03a3 a, \u03b2 a)) (t : Finset \u03b1) :\n    t.sigma (fun a => s.preimage (Sigma.mk a) sigma_mk_injective.injOn) = {a \u2208 s | a.1 \u2208 t} := by\n  ext x\n  simp [and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Preimage.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset ((a : \u03b1) \u00d7 \u03b2 a)\nt : Finset \u03b1\n\u22a2 (t.sigma fun a => s.preimage (Sigma.mk a) \u22ef) = {a \u2208 s | a.fst \u2208 t}"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset ((a : \u03b1) \u00d7 \u03b2 a)\nt : Finset \u03b1\nx : (i : \u03b1) \u00d7 \u03b2 i\n\u22a2 (x \u2208 t.sigma fun a => s.preimage (Sigma.mk a) \u22ef) \u2194 x \u2208 {a \u2208 s | a.fst \u2208 t}"}, {"line": "simp [and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_disjiUnion {h} : (s.disjiUnion t h : Set \u03b2) = \u22c3 x \u2208 (s : Set \u03b1), t x := by\n  simp [Set.ext_iff, mem_disjiUnion, Set.mem_iUnion, mem_coe, imp_true_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Union.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {s s\u2081 s\u2082 : Finset \u03b1} {t t\u2081 t\u2082 : \u03b1 \u2192 Finset \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\nt : \u03b1 \u2192 Finset \u03b2\nh : (\u2191s).PairwiseDisjoint t\n\u22a2 \u2191(s.disjiUnion t h) = \u22c3 x \u2208 \u2191s, \u2191(t x)"}, {"line": "simp [Set.ext_iff, mem_disjiUnion, Set.mem_iUnion, mem_coe, imp_true_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma biUnion_congr (hs : s\u2081 = s\u2082) (ht : \u2200 a \u2208 s\u2081, t\u2081 a = t\u2082 a) :\n    s\u2081.biUnion t\u2081 = s\u2082.biUnion t\u2082 := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Union.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {s s\u2081 s\u2082 : Finset \u03b1} {t t\u2081 t\u2082 : \u03b1 \u2192 Finset \u03b2}", "[DecidableEq \u03b2] {s : Finset \u03b1} {t : Finset \u03b2} {f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {op : \u03b2 \u2192 \u03b2 \u2192 \u03b2} [hc : Std.Commutative op] [ha : Std.Associative op]", "[DecidableEq \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns\u2081 s\u2082 : Finset \u03b1\nt\u2081 t\u2082 : \u03b1 \u2192 Finset \u03b2\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b2\nhs : s\u2081 = s\u2082\nht : \u2200 a \u2208 s\u2081, t\u2081 a = t\u2082 a\n\u22a2 s\u2081.biUnion t\u2081 = s\u2082.biUnion t\u2082"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma biUnion_filter_eq_of_maps_to [DecidableEq \u03b1] {s : Finset \u03b1} {t : Finset \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (h : \u2200 x \u2208 s, f x \u2208 t) : (t.biUnion fun a \u21a6 s.filter fun c \u21a6 f c = a) = s := by\n  simpa only [disjiUnion_eq_biUnion] using disjiUnion_filter_eq_of_maps_to h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Union.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {s s\u2081 s\u2082 : Finset \u03b1} {t t\u2081 t\u2082 : \u03b1 \u2192 Finset \u03b2}", "[DecidableEq \u03b2] {s : Finset \u03b1} {t : Finset \u03b2} {f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {op : \u03b2 \u2192 \u03b2 \u2192 \u03b2} [hc : Std.Commutative op] [ha : Std.Associative op]", "[DecidableEq \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nt : Finset \u03b2\nf : \u03b1 \u2192 \u03b2\nh : \u2200 x \u2208 s, f x \u2208 t\n\u22a2 (t.biUnion fun a => {c \u2208 s | f c = a}) = s"}, {"line": "simpa only [disjiUnion_eq_biUnion] using disjiUnion_filter_eq_of_maps_to h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma disjoint_biUnion_right (s : Finset \u03b2) (t : Finset \u03b1) (f : \u03b1 \u2192 Finset \u03b2) :\n    Disjoint s (t.biUnion f) \u2194 \u2200 i \u2208 t, Disjoint s (f i) := by\n  simpa only [_root_.disjoint_comm] using disjoint_biUnion_left t f s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Union.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {s s\u2081 s\u2082 : Finset \u03b1} {t t\u2081 t\u2082 : \u03b1 \u2192 Finset \u03b2}", "[DecidableEq \u03b2] {s : Finset \u03b1} {t : Finset \u03b2} {f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {op : \u03b2 \u2192 \u03b2 \u2192 \u03b2} [hc : Std.Commutative op] [ha : Std.Associative op]", "[DecidableEq \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b2\ns : Finset \u03b2\nt : Finset \u03b1\nf : \u03b1 \u2192 Finset \u03b2\n\u22a2 Disjoint s (t.biUnion f) \u2194 \u2200 i \u2208 t, Disjoint s (f i)"}, {"line": "simpa only [_root_.disjoint_comm] using disjoint_biUnion_left t f s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem updateFinset_singleton {i y} :\n    updateFinset x {i} y = Function.update x i (y \u27e8i, mem_singleton_self i\u27e9) := by\n  congr with j\n  by_cases hj : j = i\n  \u00b7 cases hj\n    simp only [dif_pos]\n    simp only [Finset.mem_singleton]\n    simp only [update_self]\n    simp only [updateFinset]\n  \u00b7 simp [hj, updateFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Update.lean", "context": {"open": ["Finset Equiv"], "variables": ["{\u03b9 : Sort _} {\u03c0 : \u03b9 \u2192 Sort _} {x : \u2200 i, \u03c0 i} [DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_2\n\u03c0 : \u03b9 \u2192 Sort u_3\nx : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_1\nupdateFinset : x\u271d\ni : \u03b9\ny : ?m.939\n\u22a2 sorry = Function.update x i sorry"}, {"line": "congr with j", "tactic_state": "case h\n\u03b9 : Sort u_2\n\u03c0 : \u03b9 \u2192 Sort u_3\nx : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_1\nupdateFinset : x\u271d\ni : \u03b9\ny : ?m.939\nj : \u03b9\n\u22a2 sorry j = Function.update x i sorry j"}, {"line": "by_cases hj : j = i", "tactic_state": "case pos\n\u03b9 : Sort u_2\n\u03c0 : \u03b9 \u2192 Sort u_3\nx : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_1\nupdateFinset : x\u271d\ni : \u03b9\ny : ?m.939\nj : \u03b9\nhj : j = i\n\u22a2 sorry j = Function.update x i sorry j\n---\ncase neg\n\u03b9 : Sort u_2\n\u03c0 : \u03b9 \u2192 Sort u_3\nx : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_1\nupdateFinset : x\u271d\ni : \u03b9\ny : ?m.939\nj : \u03b9\nhj : \u00acj = i\n\u22a2 sorry j = Function.update x i sorry j"}, {"line": "\u00b7 cases hj\n    simp only [dif_pos]\n    simp only [Finset.mem_singleton]\n    simp only [update_self]\n    simp only [updateFinset]", "tactic_state": "case neg\n\u03b9 : Sort u_2\n\u03c0 : \u03b9 \u2192 Sort u_3\nx : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_1\nupdateFinset : x\u271d\ni : \u03b9\ny : ?m.939\nj : \u03b9\nhj : \u00acj = i\n\u22a2 sorry j = Function.update x i sorry j"}, {"line": "\u00b7 simp [hj, updateFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem update_eq_updateFinset {i y} :\n    Function.update x i y = updateFinset x {i} (uniqueElim y) := by\n  congr with j\n  by_cases hj : j = i\n  \u00b7 cases hj\n    simp only [dif_pos]\n    simp only [Finset.mem_singleton]\n    simp only [update_self]\n    simp only [updateFinset]\n    exact uniqueElim_default (\u03b1 := fun j : ({i} : Finset \u03b9) => \u03c0 j) y\n  \u00b7 simp [hj, updateFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Update.lean", "context": {"open": ["Finset Equiv"], "variables": ["{\u03b9 : Sort _} {\u03c0 : \u03b9 \u2192 Sort _} {x : \u2200 i, \u03c0 i} [DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_2\n\u03c0 : \u03b9 \u2192 Sort u_3\nx : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_1\nupdateFinset : x\u271d\ni : \u03b9\ny : \u03c0 i\n\u22a2 Function.update x i y = sorry"}, {"line": "congr with j", "tactic_state": "case h\n\u03b9 : Sort u_2\n\u03c0 : \u03b9 \u2192 Sort u_3\nx : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_1\nupdateFinset : x\u271d\ni : \u03b9\ny : \u03c0 i\nj : \u03b9\n\u22a2 Function.update x i y j = sorry j"}, {"line": "by_cases hj : j = i", "tactic_state": "case pos\n\u03b9 : Sort u_2\n\u03c0 : \u03b9 \u2192 Sort u_3\nx : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_1\nupdateFinset : x\u271d\ni : \u03b9\ny : \u03c0 i\nj : \u03b9\nhj : j = i\n\u22a2 Function.update x i y j = sorry j\n---\ncase neg\n\u03b9 : Sort u_2\n\u03c0 : \u03b9 \u2192 Sort u_3\nx : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_1\nupdateFinset : x\u271d\ni : \u03b9\ny : \u03c0 i\nj : \u03b9\nhj : \u00acj = i\n\u22a2 Function.update x i y j = sorry j"}, {"line": "\u00b7 cases hj\n    simp only [dif_pos]\n    simp only [Finset.mem_singleton]\n    simp only [update_self]\n    simp only [updateFinset]\n    exact uniqueElim_default (\u03b1 := fun j : ({i} : Finset \u03b9) => \u03c0 j) y", "tactic_state": "case neg\n\u03b9 : Sort u_2\n\u03c0 : \u03b9 \u2192 Sort u_3\nx : (i : \u03b9) \u2192 \u03c0 i\ninst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_1\nupdateFinset : x\u271d\ni : \u03b9\ny : \u03c0 i\nj : \u03b9\nhj : \u00acj = i\n\u22a2 Function.update x i y j = sorry j"}, {"line": "\u00b7 simp [hj, updateFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.DependsOn.update {\u03b1 : Type*} {f : (\u03a0 i, \u03c0 i) \u2192 \u03b1} {s : Finset \u03b9} (hf : DependsOn f s)\n    (i : \u03b9) (y : \u03c0 i) : DependsOn (fun x \u21a6 f (Function.update x i y)) (s.erase i) := by\n  simp_rw [Function.update_eq_updateFinset, erase_eq, coe_sdiff]\n  exact hf.updateFinset _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Update.lean", "context": {"open": ["Finset Equiv"], "variables": ["{\u03b9 : Sort _} {\u03c0 : \u03b9 \u2192 Sort _} {x : \u2200 i, \u03c0 i} [DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\ninst\u271d : DecidableEq \u03b9\n\u03b1 : Type u_1\nf : ((i : \u03b9) \u2192 \u03c0 i) \u2192 \u03b1\ns : Finset \u03b9\nhf : DependsOn f \u2191s\ni : \u03b9\ny : \u03c0 i\n\u22a2 DependsOn (fun x => f (Function.update x i y)) \u2191(s.erase i)"}, {"line": "simp_rw [Function.update_eq_updateFinset, erase_eq, coe_sdiff]", "tactic_state": "\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\ninst\u271d : DecidableEq \u03b9\n\u03b1 : Type u_1\nf : ((i : \u03b9) \u2192 \u03c0 i) \u2192 \u03b1\ns : Finset \u03b9\nhf : DependsOn f \u2191s\ni : \u03b9\ny : \u03c0 i\n\u22a2 DependsOn (fun x => f (Function.updateFinset x {i} (uniqueElim y))) (\u2191s \\ \u2191{i})"}, {"line": "exact hf.updateFinset _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma restrict_updateFinset_of_subset {s t : Finset \u03b9} (hst : s \u2286 t) (x : \u03a0 i, \u03c0 i)\n    (y : \u03a0 i : t, \u03c0 i) : s.restrict (updateFinset x t y) = restrict\u2082 hst y := by\n  ext i\n  simp [updateFinset, dif_pos (hst i.2)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Update.lean", "context": {"open": ["Finset Equiv"], "variables": ["{\u03b9 : Sort _} {\u03c0 : \u03b9 \u2192 Sort _} {x : \u2200 i, \u03c0 i} [DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\ninst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_1\nupdateFinset : x\u271d\ns t : Finset \u03b9\nhst : s \u2286 t\nx : (i : \u03b9) \u2192 \u03c0 i\ny : (i : { x // x \u2208 t }) \u2192 \u03c0 \u2191i\n\u22a2 s.restrict sorry = restrict\u2082 hst y"}, {"line": "ext i", "tactic_state": "case h\n\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\ninst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_1\nupdateFinset : x\u271d\ns t : Finset \u03b9\nhst : s \u2286 t\nx : (i : \u03b9) \u2192 \u03c0 i\ny : (i : { x // x \u2208 t }) \u2192 \u03c0 \u2191i\ni : { x // x \u2208 s }\n\u22a2 s.restrict sorry i = restrict\u2082 hst y i"}, {"line": "simp [updateFinset, dif_pos (hst i.2)]", "tactic_state": "case h\n\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\ninst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_1\nupdateFinset : x\u271d\ns t : Finset \u03b9\nhst : s \u2286 t\nx : (i : \u03b9) \u2192 \u03c0 i\ny : (i : { x // x \u2208 t }) \u2192 \u03c0 \u2191i\ni : { x // x \u2208 s }\n\u22a2 sorry () \u2191i = y \u27e8\u2191i, \u22ef\u27e9"}]}
{"declaration": "lemma updateFinset_restrict {s : Finset \u03b9} (x : \u03a0 i, \u03c0 i) :\n    updateFinset x s (s.restrict x) = x := by\n  ext i\n  simp [updateFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Update.lean", "context": {"open": ["Finset Equiv"], "variables": ["{\u03b9 : Sort _} {\u03c0 : \u03b9 \u2192 Sort _} {x : \u2200 i, \u03c0 i} [DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Sort u_3\ninst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_1\nupdateFinset : x\u271d\ns : Finset \u03b9\nx : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 sorry = x"}, {"line": "ext i", "tactic_state": "case h\n\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Sort u_3\ninst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_1\nupdateFinset : x\u271d\ns : Finset \u03b9\nx : (i : \u03b9) \u2192 \u03c0 i\ni : \u03b9\n\u22a2 sorry i = x i"}, {"line": "simp [updateFinset]", "tactic_state": "case h\n\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Sort u_3\ninst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_1\nupdateFinset : x\u271d\ns : Finset \u03b9\nx : (i : \u03b9) \u2192 \u03c0 i\ni : \u03b9\n\u22a2 sorry () i = x i"}]}
{"declaration": "theorem sizeOf_lt_sizeOf_of_mem [SizeOf \u03b1] {x : \u03b1} {s : Finset \u03b1} (hx : x \u2208 s) :\n    SizeOf.sizeOf x < SizeOf.sizeOf s := by\n  cases s\n  dsimp [SizeOf.sizeOf, SizeOf.sizeOf, Multiset.sizeOf]\n  rw [Nat.add_comm]\n  refine lt_trans ?_ (Nat.lt_succ_self _)\n  exact Multiset.sizeOf_lt_sizeOf_of_mem hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Basic.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : SizeOf \u03b1\nx : \u03b1\ns : Finset \u03b1\nhx : x \u2208 s\n\u22a2 sizeOf x < sizeOf s"}, {"line": "cases s", "tactic_state": "case mk\n\u03b1 : Type u_1\ninst\u271d : SizeOf \u03b1\nx : \u03b1\nval\u271d : Multiset \u03b1\nnodup\u271d : val\u271d.Nodup\nhx : x \u2208 { val := val\u271d, nodup := nodup\u271d }\n\u22a2 sizeOf x < sizeOf { val := val\u271d, nodup := nodup\u271d }"}, {"line": "dsimp [SizeOf.sizeOf, SizeOf.sizeOf, Multiset.sizeOf]", "tactic_state": "case mk\n\u03b1 : Type u_1\ninst\u271d : SizeOf \u03b1\nx : \u03b1\nval\u271d : Multiset \u03b1\nnodup\u271d : val\u271d.Nodup\nhx : x \u2208 { val := val\u271d, nodup := nodup\u271d }\n\u22a2 sizeOf x < 1 + Quot.liftOn val\u271d (fun m => m._sizeOf_1) \u22ef"}, {"line": "rw [Nat.add_comm]", "tactic_state": "case mk\n\u03b1 : Type u_1\ninst\u271d : SizeOf \u03b1\nx : \u03b1\nval\u271d : Multiset \u03b1\nnodup\u271d : val\u271d.Nodup\nhx : x \u2208 { val := val\u271d, nodup := nodup\u271d }\n\u22a2 sizeOf x < Quot.liftOn val\u271d (fun m => m._sizeOf_1) \u22ef + 1"}, {"line": "refine lt_trans ?_ (Nat.lt_succ_self _)", "tactic_state": "case mk\n\u03b1 : Type u_1\ninst\u271d : SizeOf \u03b1\nx : \u03b1\nval\u271d : Multiset \u03b1\nnodup\u271d : val\u271d.Nodup\nhx : x \u2208 { val := val\u271d, nodup := nodup\u271d }\n\u22a2 sizeOf x < Quot.liftOn val\u271d (fun m => m._sizeOf_1) \u22ef"}, {"line": "exact Multiset.sizeOf_lt_sizeOf_of_mem hx", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pairwiseDisjoint_iff {\u03b9 : Type*} {s : Set \u03b9} {f : \u03b9 \u2192 Finset \u03b1} :\n    s.PairwiseDisjoint f \u2194 \u2200 \u2983i\u2984, i \u2208 s \u2192 \u2200 \u2983j\u2984, j \u2208 s \u2192 (f i \u2229 f j).Nonempty \u2192 i = j := by\n  simp [Set.PairwiseDisjoint, Set.Pairwise, Function.onFun, not_imp_comm (a := _ = _),\n    not_disjoint_iff_nonempty_inter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Basic.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b9 : Type u_4\ns : Set \u03b9\nf : \u03b9 \u2192 Finset \u03b1\n\u22a2 s.PairwiseDisjoint f \u2194 \u2200 \u2983i : \u03b9\u2984, i \u2208 s \u2192 \u2200 \u2983j : \u03b9\u2984, j \u2208 s \u2192 (f i \u2229 f j).Nonempty \u2192 i = j"}, {"line": "simp [Set.PairwiseDisjoint, Set.Pairwise, Function.onFun, not_imp_comm (a := _ = _),\n    not_disjoint_iff_nonempty_inter]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b9 : Type u_4\ns : Set \u03b9\nf : \u03b9 \u2192 Finset \u03b1\n\u22a2 (\u2200 \u2983x : \u03b9\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u03b9\u2984, y \u2208 s \u2192 \u00acDisjoint (f x) (f y) \u2192 x = y) \u2194\n    \u2200 \u2983i : \u03b9\u2984, i \u2208 s \u2192 \u2200 \u2983j : \u03b9\u2984, j \u2208 s \u2192 (f i \u2229 f j).Nonempty \u2192 i = j"}]}
{"declaration": "theorem erase_singleton (a : \u03b1) : ({a} : Finset \u03b1).erase a = \u2205 := by\n  ext x\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Basic.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\na : \u03b1\n\u22a2 {a}.erase a = \u2205"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\na x : \u03b1\n\u22a2 x \u2208 {a}.erase a \u2194 x \u2208 \u2205"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem erase_inter (a : \u03b1) (s t : Finset \u03b1) : s.erase a \u2229 t = (s \u2229 t).erase a := by\n  simpa only [inter_comm t] using inter_erase a t s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Basic.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\na : \u03b1\ns t : Finset \u03b1\n\u22a2 s.erase a \u2229 t = (s \u2229 t).erase a"}, {"line": "simpa only [inter_comm t] using inter_erase a t s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem attach_nonempty_iff {s : Finset \u03b1} : s.attach.Nonempty \u2194 s.Nonempty := by\n  simp [Finset.Nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Basic.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 s.attach.Nonempty \u2194 s.Nonempty"}, {"line": "simp [Finset.Nonempty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem attach_eq_empty_iff {s : Finset \u03b1} : s.attach = \u2205 \u2194 s = \u2205 := by\n  simp [eq_empty_iff_forall_not_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Basic.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 s.attach = \u2205 \u2194 s = \u2205"}, {"line": "simp [eq_empty_iff_forall_not_mem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem filter_cons {a : \u03b1} (s : Finset \u03b1) (ha : a \u2209 s) :\n    filter p (cons a s ha) =\n      if p a then cons a (filter p s) ((mem_of_mem_filter _).mt ha) else filter p s := by\n  split_ifs with h\n  \u00b7 rw [filter_cons_of_pos _ _ _ ha h]\n  \u00b7 rw [filter_cons_of_neg _ _ _ ha h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Basic.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\n\u22a2 filter p sorry = if p a then sorry else filter p sorry"}, {"line": "split_ifs with h", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nh : p a\n\u22a2 filter p sorry = sorry\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nh : \u00acp a\n\u22a2 filter p sorry = filter p sorry"}, {"line": "\u00b7 rw [filter_cons_of_pos _ _ _ ha h]", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nh : \u00acp a\n\u22a2 filter p sorry = filter p sorry"}, {"line": "\u00b7 rw [filter_cons_of_neg _ _ _ ha h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem filter_inter_distrib (s t : Finset \u03b1) : (s \u2229 t).filter p = s.filter p \u2229 t.filter p := by\n  ext\n  simp [mem_filter, mem_inter, and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Basic.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\n\u22a2 Finset.filter p (s \u2229 t) = Finset.filter p s \u2229 Finset.filter p t"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 Finset.filter p (s \u2229 t) \u2194 a\u271d \u2208 Finset.filter p s \u2229 Finset.filter p t"}, {"line": "simp [mem_filter, mem_inter, and_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subset_union_elim {s : Finset \u03b1} {t\u2081 t\u2082 : Set \u03b1} (h : \u2191s \u2286 t\u2081 \u222a t\u2082) :\n    \u2203 s\u2081 s\u2082 : Finset \u03b1, s\u2081 \u222a s\u2082 = s \u2227 \u2191s\u2081 \u2286 t\u2081 \u2227 \u2191s\u2082 \u2286 t\u2082 \\ t\u2081 := by\n  classical\n    refine \u27e8s.filter (\u00b7 \u2208 t\u2081), s.filter (\u00b7 \u2209 t\u2081), ?_, ?_, ?_\u27e9\n    \u00b7 simp [filter_union_right, em]\n    \u00b7 intro x\n      simp\n    \u00b7 intro x\n      simp only [not_not]\n      simp only [coe_filter]\n      simp only [Set.mem_setOf_eq]\n      simp only [Set.mem_diff]\n      simp only [and_imp]\n      intro hx hx\u2082\n      exact \u27e8Or.resolve_left (h hx) hx\u2082, hx\u2082\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Basic.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nt\u2081 t\u2082 : Set \u03b1\nh : \u2191s \u2286 t\u2081 \u222a t\u2082\n\u22a2 \u2203 s\u2081 s\u2082, s\u2081 \u222a s\u2082 = s \u2227 \u2191s\u2081 \u2286 t\u2081 \u2227 \u2191s\u2082 \u2286 t\u2082 \\ t\u2081"}, {"line": "classical\n    refine \u27e8s.filter (\u00b7 \u2208 t\u2081), s.filter (\u00b7 \u2209 t\u2081), ?_, ?_, ?_\u27e9\n    \u00b7 simp [filter_union_right, em]\n    \u00b7 intro x\n      simp\n    \u00b7 intro x\n      simp only [not_not]\n      simp only [coe_filter]\n      simp only [Set.mem_setOf_eq]\n      simp only [Set.mem_diff]\n      simp only [and_imp]\n      intro hx hx\u2082\n      exact \u27e8Or.resolve_left (h hx) hx\u2082, hx\u2082\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_union (l l' : List \u03b1) : (l \u222a l').toFinset = l.toFinset \u222a l'.toFinset := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Basic.lean", "context": {"open": ["Multiset Subtype Function", "Nat"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "[DecidableEq \u03b1]", "{n m l : \u2115}", "[DecidableEq \u03b1] {s t : Multiset \u03b1}", "[DecidableEq \u03b1] {l l' : List \u03b1} {a : \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nl l' : List \u03b1\n\u22a2 (l \u222a l').toFinset = l.toFinset \u222a l'.toFinset"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nl l' : List \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 (l \u222a l').toFinset \u2194 a\u271d \u2208 l.toFinset \u222a l'.toFinset"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_inter (l l' : List \u03b1) : (l \u2229 l').toFinset = l.toFinset \u2229 l'.toFinset := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Basic.lean", "context": {"open": ["Multiset Subtype Function", "Nat"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "[DecidableEq \u03b1]", "{n m l : \u2115}", "[DecidableEq \u03b1] {s t : Multiset \u03b1}", "[DecidableEq \u03b1] {l l' : List \u03b1} {a : \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nl l' : List \u03b1\n\u22a2 (l \u2229 l').toFinset = l.toFinset \u2229 l'.toFinset"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nl l' : List \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 (l \u2229 l').toFinset \u2194 a\u271d \u2208 l.toFinset \u2229 l'.toFinset"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem empty_toList {s : Finset \u03b1} : s.toList.isEmpty \u2194 s = \u2205 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Basic.lean", "context": {"open": ["Multiset Subtype Function", "Nat"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1}", "(p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}", "[DecidableEq \u03b1]", "{n m l : \u2115}", "[DecidableEq \u03b1] {s t : Multiset \u03b1}", "[DecidableEq \u03b1] {l l' : List \u03b1} {a : \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 s.toList.isEmpty = true \u2194 s = \u2205"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nonempty.eq_univ [Subsingleton \u03b1] : s.Nonempty \u2192 s = univ := by\n  rintro \u27e8x, hx\u27e9\n  exact eq_univ_of_forall fun y => by rwa [Subsingleton.elim y x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/BooleanAlgebra.lean", "context": {"open": ["Function", "Nat"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Finset \u03b1}", "[Fintype \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\nuniv : Finset \u03b1\ninst\u271d : Subsingleton \u03b1\n\u22a2 s.Nonempty \u2192 s = univ"}, {"line": "rintro \u27e8x, hx\u27e9", "tactic_state": "case intro\n\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\nuniv : Finset \u03b1\ninst\u271d : Subsingleton \u03b1\nx : \u03b1\nhx : x \u2208 s\n\u22a2 s = univ"}, {"line": "exact eq_univ_of_forall fun y => by rwa [Subsingleton.elim y x]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem univ_nontrivial_iff :\n    (Finset.univ : Finset \u03b1).Nontrivial \u2194 Nontrivial \u03b1 := by\n  rw [Finset.Nontrivial]\n  rw [Finset.coe_univ]\n  rw [Set.nontrivial_univ_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/BooleanAlgebra.lean", "context": {"open": ["Function", "Nat"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Finset \u03b1}", "[Fintype \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Fintype \u03b1\n\u22a2 Finset.univ.Nontrivial \u2194 Nontrivial \u03b1"}, {"line": "rw [Finset.Nontrivial]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Fintype \u03b1\n\u22a2 (\u2191Finset.univ).Nontrivial \u2194 Nontrivial \u03b1"}, {"line": "rw [Finset.coe_univ]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Fintype \u03b1\n\u22a2 Set.univ.Nontrivial \u2194 Nontrivial \u03b1"}, {"line": "rw [Set.nontrivial_univ_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_compl : a \u2208 s\u1d9c \u2194 a \u2209 s := by simp [compl_eq_univ_sdiff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/BooleanAlgebra.lean", "context": {"open": ["Function", "Nat"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Finset \u03b1}", "[Fintype \u03b1]", "[DecidableEq \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\n\u22a2 a \u2208 s\u1d9c \u2194 a \u2209 s"}, {"line": "simp [compl_eq_univ_sdiff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_ne_univ_iff_nonempty (s : Finset \u03b1) : s\u1d9c \u2260 univ \u2194 s.Nonempty := by\n  simp [eq_univ_iff_forall, Finset.Nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/BooleanAlgebra.lean", "context": {"open": ["Function", "Nat"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Finset \u03b1}", "[Fintype \u03b1]", "[DecidableEq \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nuniv s : Finset \u03b1\n\u22a2 s\u1d9c \u2260 univ \u2194 s.Nonempty"}, {"line": "simp [eq_univ_iff_forall, Finset.Nonempty]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nuniv s : Finset \u03b1\n\u22a2 \u00acs\u1d9c = univ \u2194 \u2203 x, x \u2208 s"}]}
{"declaration": "theorem univ_filter_exists (f : \u03b1 \u2192 \u03b2) [Fintype \u03b2] [DecidablePred fun y => \u2203 x, f x = y]\n    [DecidableEq \u03b2] : (Finset.univ.filter fun y => \u2203 x, f x = y) = Finset.univ.image f := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/BooleanAlgebra.lean", "context": {"open": ["Function", "Nat"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Finset \u03b1}", "[Fintype \u03b1]", "[DecidableEq \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : Fintype \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : Fintype \u03b2\ninst\u271d\u00b9 : DecidablePred fun y => \u2203 x, f x = y\ninst\u271d : DecidableEq \u03b2\n\u22a2 {y | \u2203 x, f x = y} = Finset.image f Finset.univ"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : Fintype \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : Fintype \u03b2\ninst\u271d\u00b9 : DecidablePred fun y => \u2203 x, f x = y\ninst\u271d : DecidableEq \u03b2\na\u271d : \u03b2\n\u22a2 a\u271d \u2208 {y | \u2203 x, f x = y} \u2194 a\u271d \u2208 Finset.image f Finset.univ"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem univ_filter_mem_range (f : \u03b1 \u2192 \u03b2) [Fintype \u03b2] [DecidablePred fun y => y \u2208 Set.range f]\n    [DecidableEq \u03b2] : (Finset.univ.filter fun y => y \u2208 Set.range f) = Finset.univ.image f := by\n  letI : DecidablePred (fun y => \u2203 x, f x = y) := by simpa using \u2039_\u203a\n  exact univ_filter_exists f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/BooleanAlgebra.lean", "context": {"open": ["Function", "Nat"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Finset \u03b1}", "[Fintype \u03b1]", "[DecidableEq \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : Fintype \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : Fintype \u03b2\ninst\u271d\u00b9 : DecidablePred fun y => y \u2208 Set.range f\ninst\u271d : DecidableEq \u03b2\n\u22a2 {y | y \u2208 Set.range f} = Finset.image f Finset.univ"}, {"line": "letI : DecidablePred (fun y => \u2203 x, f x = y) := by simpa using \u2039_\u203a", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : Fintype \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : Fintype \u03b2\ninst\u271d\u00b9 : DecidablePred fun y => y \u2208 Set.range f\ninst\u271d : DecidableEq \u03b2\nthis : DecidablePred fun y => \u2203 x, f x = y := inst\u271d\u00b9\n\u22a2 {y | y \u2208 Set.range f} = Finset.image f Finset.univ"}, {"line": "exact univ_filter_exists f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_filter_univ (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    (univ.filter p : Set \u03b1) = { x | p x } := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/BooleanAlgebra.lean", "context": {"open": ["Function", "Nat"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Finset \u03b1}", "[Fintype \u03b1]", "[DecidableEq \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 sorry = {x | p x}"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 sorry () = {x | p x}"}]}
{"declaration": "lemma filter_univ_mem (s : Finset \u03b1) : univ.filter (\u00b7 \u2208 s) = s := by simp [filter_mem_eq_inter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/BooleanAlgebra.lean", "context": {"open": ["Function", "Nat"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s t : Finset \u03b1}", "[Fintype \u03b1]", "[DecidableEq \u03b1] {a : \u03b1}", "[Fintype \u03b1] [DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 sorry = s"}, {"line": "simp [filter_mem_eq_inter]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 sorry () = s"}]}
{"declaration": "theorem card_mono : Monotone (@card \u03b1) := by apply card_le_card\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Card.lean", "context": {"open": ["Function Multiset Nat"], "variables": ["{\u03b1 \u03b2 R : Type*}", "{s t : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 Monotone card"}, {"line": "apply card_le_card", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_image_le [DecidableEq \u03b2] : #(s.image f) \u2264 #s := by\n  simpa only [card_map] using (s.1.map f).toFinset_card_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Card.lean", "context": {"open": ["Function Multiset Nat", "scoped Finset"], "variables": ["{\u03b1 \u03b2 R : Type*}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1]", "{a b c d e f : \u03b1}", "[DecidableEq \u03b1] (m : Multiset \u03b1) (l : List \u03b1)", "{s t u : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : DecidableEq \u03b2\n\u22a2 (Finset.image f s).card \u2264 s.card"}, {"line": "simpa only [card_map] using (s.1.map f).toFinset_card_le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_subtype (p : \u03b1 \u2192 Prop) [DecidablePred p] (s : Finset \u03b1) :\n    #(s.subtype p) = #(s.filter p) := by simp [Finset.subtype]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Card.lean", "context": {"open": ["Function Multiset Nat", "scoped Finset"], "variables": ["{\u03b1 \u03b2 R : Type*}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1]", "{a b c d e f : \u03b1}", "[DecidableEq \u03b1] (m : Multiset \u03b1) (l : List \u03b1)", "{s t u : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\ns : Finset \u03b1\n\u22a2 (Finset.subtype p s).card = (Finset.filter p s).card"}, {"line": "simp [Finset.subtype]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_equiv (e : \u03b1 \u2243 \u03b2) (hst : \u2200 i, i \u2208 s \u2194 e i \u2208 t) : #s = #t := by\n  refine card_nbij' e e.symm ?_ ?_ ?_ ?_ <;> simp [hst]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Card.lean", "context": {"open": ["Function Multiset Nat", "scoped Finset"], "variables": ["{\u03b1 \u03b2 R : Type*}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1]", "{a b c d e f : \u03b1}", "[DecidableEq \u03b1] (m : Multiset \u03b1) (l : List \u03b1)", "{s t u : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} {n : \u2115}", "{t : Finset \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nt : Finset \u03b2\ne : \u03b1 \u2243 \u03b2\nhst : \u2200 (i : \u03b1), i \u2208 s \u2194 e i \u2208 t\n\u22a2 s.card = t.card"}, {"line": "refine card_nbij' e e.symm ?_ ?_ ?_ ?_ <;> simp [hst]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_le_card_of_injective {f : s \u2192 t} (hf : f.Injective) : #s \u2264 #t := by\n  rcases s.eq_empty_or_nonempty with rfl | \u27e8a\u2080, ha\u2080\u27e9\n  \u00b7 simp\n  \u00b7 classical\n    let f' : \u03b1 \u2192 \u03b2 := fun a => f (if ha : a \u2208 s then \u27e8a, ha\u27e9 else \u27e8a\u2080, ha\u2080\u27e9)\n    apply card_le_card_of_injOn f'\n    \u00b7 aesop\n    \u00b7 intro a\u2081 ha\u2081 a\u2082 ha\u2082 haa\n      rw [mem_coe] at ha\u2081 ha\u2082\n      simp only [f'] at haa\n      simp only [ha\u2081] at haa\n      simp only [ha\u2082] at haa\n      simp only [\u2190 Subtype.ext_iff] at haa\n      exact Subtype.ext_iff.mp (hf haa)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Card.lean", "context": {"open": ["Function Multiset Nat", "scoped Finset"], "variables": ["{\u03b1 \u03b2 R : Type*}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1]", "{a b c d e f : \u03b1}", "[DecidableEq \u03b1] (m : Multiset \u03b1) (l : List \u03b1)", "{s t u : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} {n : \u2115}", "{t : Finset \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nt : Finset \u03b2\nf : { x // x \u2208 s } \u2192 { x // x \u2208 t }\nhf : Injective f\n\u22a2 s.card \u2264 t.card"}, {"line": "rcases s.eq_empty_or_nonempty with rfl | \u27e8a\u2080, ha\u2080\u27e9", "tactic_state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nt : Finset \u03b2\nf : { x // x \u2208 \u2205 } \u2192 { x // x \u2208 t }\nhf : Injective f\n\u22a2 \u2205.card \u2264 t.card\n---\ncase inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nt : Finset \u03b2\nf : { x // x \u2208 s } \u2192 { x // x \u2208 t }\nhf : Injective f\na\u2080 : \u03b1\nha\u2080 : a\u2080 \u2208 s\n\u22a2 s.card \u2264 t.card"}, {"line": "\u00b7 simp", "tactic_state": "case inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nt : Finset \u03b2\nf : { x // x \u2208 s } \u2192 { x // x \u2208 t }\nhf : Injective f\na\u2080 : \u03b1\nha\u2080 : a\u2080 \u2208 s\n\u22a2 s.card \u2264 t.card"}, {"line": "\u00b7 classical\n    let f' : \u03b1 \u2192 \u03b2 := fun a => f (if ha : a \u2208 s then \u27e8a, ha\u27e9 else \u27e8a\u2080, ha\u2080\u27e9)\n    apply card_le_card_of_injOn f'\n    \u00b7 aesop\n    \u00b7 intro a\u2081 ha\u2081 a\u2082 ha\u2082 haa\n      rw [mem_coe] at ha\u2081 ha\u2082\n      simp only [f'] at haa\n      simp only [ha\u2081] at haa\n      simp only [ha\u2082] at haa\n      simp only [\u2190 Subtype.ext_iff] at haa\n      exact Subtype.ext_iff.mp (hf haa)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_mem_not_mem_of_card_lt_card (h : #s < #t) : \u2203 e, e \u2208 t \u2227 e \u2209 s := by\n  classical simpa [Finset.Nonempty] using sdiff_nonempty_of_card_lt_card h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Card.lean", "context": {"open": ["Function Multiset Nat", "scoped Finset"], "variables": ["{\u03b1 \u03b2 R : Type*}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1]", "{a b c d e f : \u03b1}", "[DecidableEq \u03b1] (m : Multiset \u03b1) (l : List \u03b1)", "{s t u : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} {n : \u2115}", "{t : Finset \u03b2}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\nt : Finset \u03b2\ninst\u271d : DecidableEq \u03b1\nh : s.card < t.card\n\u22a2 \u2203 e \u2208 t, \u00acsorry"}, {"line": "classical simpa [Finset.Nonempty] using sdiff_nonempty_of_card_lt_card h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_subset_card_eq (hns : n \u2264 #s) : \u2203 t \u2286 s, #t = n := by\n  simpa using exists_subsuperset_card_eq s.empty_subset (by simp) hns\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Card.lean", "context": {"open": ["Function Multiset Nat", "scoped Finset"], "variables": ["{\u03b1 \u03b2 R : Type*}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1]", "{a b c d e f : \u03b1}", "[DecidableEq \u03b1] (m : Multiset \u03b1) (l : List \u03b1)", "{s t u : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} {n : \u2115}", "{t : Finset \u03b2}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\nn : \u2115\ninst\u271d : DecidableEq \u03b1\nhns : n \u2264 s.card\n\u22a2 \u2203 t \u2286 s, t.card = n"}, {"line": "simpa using exists_subsuperset_card_eq s.empty_subset (by simp) hns", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_card_iff_exists_subset_card : n \u2264 #s \u2194 \u2203 t \u2286 s, #t = n := by\n  refine \u27e8fun h => ?_, fun \u27e8t, hst, ht\u27e9 => ht \u25b8 card_le_card hst\u27e9\n  exact exists_subset_card_eq h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Card.lean", "context": {"open": ["Function Multiset Nat", "scoped Finset"], "variables": ["{\u03b1 \u03b2 R : Type*}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1]", "{a b c d e f : \u03b1}", "[DecidableEq \u03b1] (m : Multiset \u03b1) (l : List \u03b1)", "{s t u : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} {n : \u2115}", "{t : Finset \u03b2}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\nn : \u2115\ninst\u271d : DecidableEq \u03b1\n\u22a2 n \u2264 s.card \u2194 \u2203 t \u2286 s, t.card = n"}, {"line": "refine \u27e8fun h => ?_, fun \u27e8t, hst, ht\u27e9 => ht \u25b8 card_le_card hst\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\nn : \u2115\ninst\u271d : DecidableEq \u03b1\nh : n \u2264 s.card\n\u22a2 \u2203 t \u2286 s, t.card = n"}, {"line": "exact exists_subset_card_eq h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_le_one : #s \u2264 1 \u2194 \u2200 a \u2208 s, \u2200 b \u2208 s, a = b := by\n  obtain rfl | \u27e8x, hx\u27e9 := s.eq_empty_or_nonempty\n  \u00b7 simp\n  refine (Nat.succ_le_of_lt (card_pos.2 \u27e8x, hx\u27e9)).le_iff_eq.trans (card_eq_one.trans \u27e8?_, ?_\u27e9)\n  \u00b7 rintro \u27e8y, rfl\u27e9\n    simp\n  \u00b7 exact fun h => \u27e8x, eq_singleton_iff_unique_mem.2 \u27e8hx, fun y hy => h _ hy _ hx\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Card.lean", "context": {"open": ["Function Multiset Nat", "scoped Finset"], "variables": ["{\u03b1 \u03b2 R : Type*}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1]", "{a b c d e f : \u03b1}", "[DecidableEq \u03b1] (m : Multiset \u03b1) (l : List \u03b1)", "{s t u : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} {n : \u2115}", "{t : Finset \u03b2}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 s.card \u2264 1 \u2194 \u2200 a \u2208 s, \u2200 b \u2208 s, a = b"}, {"line": "obtain rfl | \u27e8x, hx\u27e9 := s.eq_empty_or_nonempty", "tactic_state": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\n\u22a2 \u2205.card \u2264 1 \u2194 \u2200 a \u2208 \u2205, \u2200 b \u2208 \u2205, a = b\n---\ncase inr.intro\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\nx : \u03b1\nhx : x \u2208 s\n\u22a2 s.card \u2264 1 \u2194 \u2200 a \u2208 s, \u2200 b \u2208 s, a = b"}, {"line": "\u00b7 simp", "tactic_state": "case inr.intro\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\nx : \u03b1\nhx : x \u2208 s\n\u22a2 s.card \u2264 1 \u2194 \u2200 a \u2208 s, \u2200 b \u2208 s, a = b"}, {"line": "refine (Nat.succ_le_of_lt (card_pos.2 \u27e8x, hx\u27e9)).le_iff_eq.trans (card_eq_one.trans \u27e8?_, ?_\u27e9)", "tactic_state": "case inr.intro.refine_1\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (\u2203 a, s.val = {a}) \u2192 \u2200 a \u2208 s, \u2200 b \u2208 s, a = b\n---\ncase inr.intro.refine_2\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (\u2200 a \u2208 s, \u2200 b \u2208 s, a = b) \u2192 \u2203 a, s.val = {a}"}, {"line": "\u00b7 rintro \u27e8y, rfl\u27e9\n    simp", "tactic_state": "case inr.intro.refine_2\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (\u2200 a \u2208 s, \u2200 b \u2208 s, a = b) \u2192 \u2203 a, s.val = {a}"}, {"line": "\u00b7 exact fun h => \u27e8x, eq_singleton_iff_unique_mem.2 \u27e8hx, fun y hy => h _ hy _ hx\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_mem_ne (hs : 1 < #s) (a : \u03b1) : \u2203 b \u2208 s, b \u2260 a := by\n  have : Nonempty \u03b1 := \u27e8a\u27e9\n  by_contra!\n  exact hs.not_le (card_le_one_iff_subset_singleton.2 \u27e8a, subset_singleton_iff'.2 this\u27e9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Card.lean", "context": {"open": ["Function Multiset Nat", "scoped Finset"], "variables": ["{\u03b1 \u03b2 R : Type*}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1]", "{a b c d e f : \u03b1}", "[DecidableEq \u03b1] (m : Multiset \u03b1) (l : List \u03b1)", "{s t u : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} {n : \u2115}", "{t : Finset \u03b2}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\nhs : 1 < s.card\na : \u03b1\n\u22a2 \u2203 b \u2208 s, b \u2260 a"}, {"line": "have : Nonempty \u03b1 := \u27e8a\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\nhs : 1 < s.card\na : \u03b1\nthis : Nonempty \u03b1\n\u22a2 \u2203 b \u2208 s, b \u2260 a"}, {"line": "by_contra!", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\nhs : 1 < s.card\na : \u03b1\nthis\u271d : Nonempty \u03b1\nthis : \u2200 b \u2208 s, b = a\n\u22a2 False"}, {"line": "exact hs.not_le (card_le_one_iff_subset_singleton.2 \u27e8a, subset_singleton_iff'.2 this\u27e9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_card : 1 < #s \u2194 \u2203 a \u2208 s, \u2203 b \u2208 s, a \u2260 b := by\n  rw [\u2190 not_iff_not]\n  push_neg\n  exact card_le_one\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Card.lean", "context": {"open": ["Function Multiset Nat", "scoped Finset"], "variables": ["{\u03b1 \u03b2 R : Type*}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1]", "{a b c d e f : \u03b1}", "[DecidableEq \u03b1] (m : Multiset \u03b1) (l : List \u03b1)", "{s t u : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} {n : \u2115}", "{t : Finset \u03b2}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 1 < s.card \u2194 \u2203 a \u2208 s, \u2203 b \u2208 s, a \u2260 b"}, {"line": "rw [\u2190 not_iff_not]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 \u00ac1 < s.card \u2194 \u00ac\u2203 a \u2208 s, \u2203 b \u2208 s, a \u2260 b"}, {"line": "push_neg", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 s.card \u2264 1 \u2194 \u2200 a \u2208 s, \u2200 b \u2208 s, a = b"}, {"line": "exact card_le_one", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_ne_of_one_lt_card (hs : 1 < #s) (a : \u03b1) : \u2203 b, b \u2208 s \u2227 b \u2260 a := by\n  obtain \u27e8x, hx, y, hy, hxy\u27e9 := Finset.one_lt_card.mp hs\n  by_cases ha : y = a\n  \u00b7 exact \u27e8x, hx, ne_of_ne_of_eq hxy ha\u27e9\n  \u00b7 exact \u27e8y, hy, ha\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Card.lean", "context": {"open": ["Function Multiset Nat", "scoped Finset"], "variables": ["{\u03b1 \u03b2 R : Type*}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1]", "{a b c d e f : \u03b1}", "[DecidableEq \u03b1] (m : Multiset \u03b1) (l : List \u03b1)", "{s t u : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} {n : \u2115}", "{t : Finset \u03b2}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\nhs : 1 < s.card\na : \u03b1\n\u22a2 \u2203 b \u2208 s, b \u2260 a"}, {"line": "obtain \u27e8x, hx, y, hy, hxy\u27e9 := Finset.one_lt_card.mp hs", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\nhs : 1 < s.card\na x : \u03b1\nhx : x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nhxy : x \u2260 y\n\u22a2 \u2203 b \u2208 s, b \u2260 a"}, {"line": "by_cases ha : y = a", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\nhs : 1 < s.card\na x : \u03b1\nhx : x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nhxy : x \u2260 y\nha : y = a\n\u22a2 \u2203 b \u2208 s, b \u2260 a\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\nhs : 1 < s.card\na x : \u03b1\nhx : x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nhxy : x \u2260 y\nha : \u00acy = a\n\u22a2 \u2203 b \u2208 s, b \u2260 a"}, {"line": "\u00b7 exact \u27e8x, hx, ne_of_ne_of_eq hxy ha\u27e9", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\nhs : 1 < s.card\na x : \u03b1\nhx : x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nhxy : x \u2260 y\nha : \u00acy = a\n\u22a2 \u2203 b \u2208 s, b \u2260 a"}, {"line": "\u00b7 exact \u27e8y, hy, ha\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dens_image [Fintype \u03b2] [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Bijective f) (s : Finset \u03b1) :\n    (s.image f).dens = s.dens := by\n  simpa [map_eq_image, -dens_map_equiv] using dens_map_equiv (.ofBijective f hf)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Density.lean", "context": {"open": ["Function Multiset Nat"], "variables": ["{\ud835\udd5c \u03b1 \u03b2 : Type*} [Fintype \u03b1]", "{s t : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Bijective f\ns : Finset \u03b1\n\u22a2 (Finset.image f s).dens = s.dens"}, {"line": "simpa [map_eq_image, -dens_map_equiv] using dens_map_equiv (.ofBijective f hf)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_toFinset {m1 m2 : Multiset \u03b1} :\n    _root_.Disjoint m1.toFinset m2.toFinset \u2194 Disjoint m1 m2 := by\n  simp [disjoint_left, Finset.disjoint_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Disjoint.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{f : \u03b1 \u2192 \u03b2} {s t u : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1] {s t u v : Finset \u03b1} {a b : \u03b1} {f : \u03b1 \u2192 \u03b2}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nm1 m2 : Multiset \u03b1\n\u22a2 Disjoint m1.toFinset m2.toFinset \u2194 Disjoint m1 m2"}, {"line": "simp [disjoint_left, Finset.disjoint_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isEmpty_coe_sort {s : Finset \u03b1} : IsEmpty (s : Type _) \u2194 s = \u2205 := by\n  simpa using @Set.isEmpty_coe_sort \u03b1 s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Empty.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "{s : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\n\u22a2 IsEmpty { x // x \u2208 s } \u2194 s = \u2205"}, {"line": "simpa using @Set.isEmpty_coe_sort \u03b1 s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fold_const [hd : Decidable (s = \u2205)] (c : \u03b2) (h : op c (op b c) = op b c) :\n    Finset.fold op b (fun _ => c) s = if s = \u2205 then b else op b c := by\n  classical\n    induction' s using Finset.induction_on with x s hx IH generalizing hd\n    \u00b7 simp\n    \u00b7 simp only [Finset.fold_insert hx, IH, if_false, Finset.insert_ne_empty]\n      split_ifs\n      \u00b7 rw [hc.comm]\n      \u00b7 exact h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Fold.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(op : \u03b2 \u2192 \u03b2 \u2192 \u03b2) [hc : Std.Commutative op] [ha : Std.Associative op]", "{op} {f : \u03b1 \u2192 \u03b2} {b : \u03b2} {s : Finset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha : Std.Associative op\nb : \u03b2\ns : Finset \u03b1\nhd : Decidable (s = \u2205)\nc : \u03b2\nh : op c (op b c) = op b c\n\u22a2 Finset.fold op b (fun x => c) s = if s = \u2205 then b else op b c"}, {"line": "classical\n    induction' s using Finset.induction_on with x s hx IH generalizing hd\n    \u00b7 simp\n    \u00b7 simp only [Finset.fold_insert hx, IH, if_false, Finset.insert_ne_empty]\n      split_ifs\n      \u00b7 rw [hc.comm]\n      \u00b7 exact h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fold_image_idem [DecidableEq \u03b1] {g : \u03b3 \u2192 \u03b1} {s : Finset \u03b3} [hi : Std.IdempotentOp op] :\n    (image g s).fold op b f = s.fold op b (f \u2218 g) := by\n  induction' s using Finset.cons_induction with x xs hx ih\n  \u00b7 rw [fold_empty, image_empty, fold_empty]\n  \u00b7 haveI := Classical.decEq \u03b3\n    rw [fold_cons]\n    rw [cons_eq_insert]\n    rw [image_insert]\n    rw [fold_insert_idem]\n    rw [ih]\n    simp only [Function.comp_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Fold.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(op : \u03b2 \u2192 \u03b2 \u2192 \u03b2) [hc : Std.Commutative op] [ha : Std.Associative op]", "{op} {f : \u03b1 \u2192 \u03b2} {b : \u03b2} {s : Finset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\nx\u271d : Sort u_4\nimage : x\u271d\ninst\u271d : DecidableEq \u03b1\ng : \u03b3 \u2192 \u03b1\ns : Finset \u03b3\nhi : Std.IdempotentOp op\n\u22a2 sorry = Finset.fold op b (f \u2218 g) s"}, {"line": "induction' s using Finset.cons_induction with x xs hx ih", "tactic_state": "case empty\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\nx\u271d : Sort u_4\nimage : x\u271d\ninst\u271d : DecidableEq \u03b1\ng : \u03b3 \u2192 \u03b1\nhi : Std.IdempotentOp op\n\u22a2 sorry = Finset.fold op b (f \u2218 g) \u2205\n---\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\nx\u271d : Sort u_4\nimage : x\u271d\ninst\u271d : DecidableEq \u03b1\ng : \u03b3 \u2192 \u03b1\nhi : Std.IdempotentOp op\nx : \u03b3\nxs : Finset \u03b3\nhx : x \u2209 xs\nih : sorry = Finset.fold op b (f \u2218 g) xs\n\u22a2 sorry = Finset.fold op b (f \u2218 g) (Finset.cons x xs hx)"}, {"line": "\u00b7 rw [fold_empty, image_empty, fold_empty]", "tactic_state": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\nx\u271d : Sort u_4\nimage : x\u271d\ninst\u271d : DecidableEq \u03b1\ng : \u03b3 \u2192 \u03b1\nhi : Std.IdempotentOp op\nx : \u03b3\nxs : Finset \u03b3\nhx : x \u2209 xs\nih : sorry = Finset.fold op b (f \u2218 g) xs\n\u22a2 sorry = Finset.fold op b (f \u2218 g) (Finset.cons x xs hx)"}, {"line": "\u00b7 haveI := Classical.decEq \u03b3\n    rw [fold_cons]\n    rw [cons_eq_insert]\n    rw [image_insert]\n    rw [fold_insert_idem]\n    rw [ih]\n    simp only [Function.comp_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fold_ite' {g : \u03b1 \u2192 \u03b2} (hb : op b b = b) (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    Finset.fold op b (fun i => ite (p i) (f i) (g i)) s =\n      op (Finset.fold op b f (s.filter p)) (Finset.fold op b g (s.filter fun i => \u00acp i)) := by\n  classical\n    induction' s using Finset.induction_on with x s hx IH\n    \u00b7 simp [hb]\n    \u00b7 simp only [Finset.fold_insert hx]\n      split_ifs with h\n      \u00b7 have : x \u2209 Finset.filter p s := by simp [hx]\n        simp [Finset.filter_insert, h, Finset.fold_insert this, ha.assoc, IH]\n      \u00b7 have : x \u2209 Finset.filter (fun i => \u00ac p i) s := by simp [hx]\n        simp [Finset.filter_insert, h, Finset.fold_insert this, IH, \u2190 ha.assoc, hc.comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Fold.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(op : \u03b2 \u2192 \u03b2 \u2192 \u03b2) [hc : Std.Commutative op] [ha : Std.Associative op]", "{op} {f : \u03b1 \u2192 \u03b2} {b : \u03b2} {s : Finset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns : Finset \u03b1\ng : \u03b1 \u2192 \u03b2\nhb : op b b = b\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 Finset.fold op b (fun i => if p i then f i else g i) s =\n    op (Finset.fold op b f (Finset.filter p s)) (Finset.fold op b g ({i \u2208 s | \u00acp i}))"}, {"line": "classical\n    induction' s using Finset.induction_on with x s hx IH\n    \u00b7 simp [hb]\n    \u00b7 simp only [Finset.fold_insert hx]\n      split_ifs with h\n      \u00b7 have : x \u2209 Finset.filter p s := by simp [hx]\n        simp [Finset.filter_insert, h, Finset.fold_insert this, ha.assoc, IH]\n      \u00b7 have : x \u2209 Finset.filter (fun i => \u00ac p i) s := by simp [hx]\n        simp [Finset.filter_insert, h, Finset.fold_insert this, IH, \u2190 ha.assoc, hc.comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fold_op_rel_iff_and {r : \u03b2 \u2192 \u03b2 \u2192 Prop} (hr : \u2200 {x y z}, r x (op y z) \u2194 r x y \u2227 r x z)\n    {c : \u03b2} : r c (s.fold op b f) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x) := by\n  classical\n    induction' s using Finset.induction_on with a s ha IH\n    \u00b7 simp\n    rw [Finset.fold_insert ha]\n    rw [hr]\n    rw [IH]\n    rw [\u2190 and_assoc]\n    rw [@and_comm (r c (f a))]\n    rw [and_assoc]\n    apply and_congr Iff.rfl\n    constructor\n    \u00b7 rintro \u27e8h\u2081, h\u2082\u27e9\n      intro b hb\n      rw [Finset.mem_insert] at hb\n      rcases hb with (rfl | hb) <;> solve_by_elim\n    \u00b7 intro h\n      constructor\n      \u00b7 exact h a (Finset.mem_insert_self _ _)\n      \u00b7 exact fun b hb => h b <| Finset.mem_insert_of_mem hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Fold.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(op : \u03b2 \u2192 \u03b2 \u2192 \u03b2) [hc : Std.Commutative op] [ha : Std.Associative op]", "{op} {f : \u03b1 \u2192 \u03b2} {b : \u03b2} {s : Finset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns : Finset \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\n\u22a2 r c (Finset.fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)"}, {"line": "classical\n    induction' s using Finset.induction_on with a s ha IH\n    \u00b7 simp\n    rw [Finset.fold_insert ha]\n    rw [hr]\n    rw [IH]\n    rw [\u2190 and_assoc]\n    rw [@and_comm (r c (f a))]\n    rw [and_assoc]\n    apply and_congr Iff.rfl\n    constructor\n    \u00b7 rintro \u27e8h\u2081, h\u2082\u27e9\n      intro b hb\n      rw [Finset.mem_insert] at hb\n      rcases hb with (rfl | hb) <;> solve_by_elim\n    \u00b7 intro h\n      constructor\n      \u00b7 exact h a (Finset.mem_insert_self _ _)\n      \u00b7 exact fun b hb => h b <| Finset.mem_insert_of_mem hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fold_op_rel_iff_or {r : \u03b2 \u2192 \u03b2 \u2192 Prop} (hr : \u2200 {x y z}, r x (op y z) \u2194 r x y \u2228 r x z)\n    {c : \u03b2} : r c (s.fold op b f) \u2194 r c b \u2228 \u2203 x \u2208 s, r c (f x) := by\n  classical\n    induction' s using Finset.induction_on with a s ha IH\n    \u00b7 simp\n    rw [Finset.fold_insert ha]\n    rw [hr]\n    rw [IH]\n    rw [\u2190 or_assoc]\n    rw [@or_comm (r c (f a))]\n    rw [or_assoc]\n    apply or_congr Iff.rfl\n    constructor\n    \u00b7 rintro (h\u2081 | \u27e8x, hx, h\u2082\u27e9)\n      \u00b7 use a\n        simp [h\u2081]\n      \u00b7 refine \u27e8x, by simp [hx], h\u2082\u27e9\n    \u00b7 rintro \u27e8x, hx, h\u27e9\n      exact (mem_insert.mp hx).imp (fun hx => by rwa [hx] at h) (fun hx => \u27e8x, hx, h\u27e9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Fold.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(op : \u03b2 \u2192 \u03b2 \u2192 \u03b2) [hc : Std.Commutative op] [ha : Std.Associative op]", "{op} {f : \u03b1 \u2192 \u03b2} {b : \u03b2} {s : Finset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns : Finset \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2228 r x z\nc : \u03b2\n\u22a2 r c (Finset.fold op b f s) \u2194 r c b \u2228 \u2203 x \u2208 s, r c (f x)"}, {"line": "classical\n    induction' s using Finset.induction_on with a s ha IH\n    \u00b7 simp\n    rw [Finset.fold_insert ha]\n    rw [hr]\n    rw [IH]\n    rw [\u2190 or_assoc]\n    rw [@or_comm (r c (f a))]\n    rw [or_assoc]\n    apply or_congr Iff.rfl\n    constructor\n    \u00b7 rintro (h\u2081 | \u27e8x, hx, h\u2082\u27e9)\n      \u00b7 use a\n        simp [h\u2081]\n      \u00b7 refine \u27e8x, by simp [hx], h\u2082\u27e9\n    \u00b7 rintro \u27e8x, hx, h\u27e9\n      exact (mem_insert.mp hx).imp (fun hx => by rwa [hx] at h) (fun hx => \u27e8x, hx, h\u27e9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fold_union_empty_singleton [DecidableEq \u03b1] (s : Finset \u03b1) :\n    Finset.fold (\u00b7 \u222a \u00b7) \u2205 singleton s = s := by\n  induction' s using Finset.induction_on with a s has ih\n  \u00b7 simp only [fold_empty]\n  \u00b7 rw [fold_insert has, ih, insert_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Fold.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(op : \u03b2 \u2192 \u03b2 \u2192 \u03b2) [hc : Std.Commutative op] [ha : Std.Associative op]", "{op} {f : \u03b1 \u2192 \u03b2} {b : \u03b2} {s : Finset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 Finset.fold (fun x1 x2 => x1 \u222a x2) \u2205 singleton s = s"}, {"line": "induction' s using Finset.induction_on with a s has ih", "tactic_state": "case empty\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u22a2 Finset.fold (fun x1 x2 => x1 \u222a x2) \u2205 singleton \u2205 = \u2205\n---\ncase insert\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns\u271d : Finset \u03b1\na : \u03b1\ns : Finset \u03b1\nhas : a \u2209 s\nih : Finset.fold (fun x1 x2 => x1 \u222a x2) \u2205 singleton s = s\n\u22a2 Finset.fold (fun x1 x2 => x1 \u222a x2) \u2205 singleton (insert a s) = insert a s\n---\ncase inst\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 DecidableEq \u03b1"}, {"line": "\u00b7 simp only [fold_empty]", "tactic_state": "case insert\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns\u271d : Finset \u03b1\na : \u03b1\ns : Finset \u03b1\nhas : a \u2209 s\nih : Finset.fold (fun x1 x2 => x1 \u222a x2) \u2205 singleton s = s\n\u22a2 Finset.fold (fun x1 x2 => x1 \u222a x2) \u2205 singleton (insert a s) = insert a s\n---\ncase inst\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 DecidableEq \u03b1"}, {"line": "\u00b7 rw [fold_insert has, ih, insert_eq]", "tactic_state": "case inst\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 DecidableEq \u03b1"}]}
{"declaration": "theorem image\u2082_def {\u03b1 \u03b2 \u03b3 : Type u} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (s : Finset \u03b1) (t : Finset \u03b2) :\n    image\u2082 f s t = f <$> s <*> t := by\n  ext\n  simp [mem_sup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Functor.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 : Type u} [\u2200 P, Decidable P]", "{\u03b1 \u03b2 : Type u} [\u2200 P, Decidable P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "inst\u271d\u00b9 inst\u271d : (P : Prop) \u2192 Decidable P\nx\u271d : Sort u_1\nimage\u2082 : x\u271d\n\u03b1 \u03b2 \u03b3 : Type u\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Finset \u03b1\nt : Finset \u03b2\n\u22a2 sorry = f <$> s <*> t"}, {"line": "ext", "tactic_state": "case h\ninst\u271d\u00b9 inst\u271d : (P : Prop) \u2192 Decidable P\nx\u271d : Sort u_1\nimage\u2082 : x\u271d\n\u03b1 \u03b2 \u03b3 : Type u\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Finset \u03b1\nt : Finset \u03b2\na\u271d : \u03b3\n\u22a2 a\u271d \u2208 sorry \u2194 a\u271d \u2208 f <$> s <*> t"}, {"line": "simp [mem_sup]", "tactic_state": "case h\ninst\u271d\u00b9 inst\u271d : (P : Prop) \u2192 Decidable P\nx\u271d : Sort u_1\nimage\u2082 : x\u271d\n\u03b1 \u03b2 \u03b3 : Type u\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Finset \u03b1\nt : Finset \u03b2\na\u271d : \u03b3\n\u22a2 a\u271d \u2208 sorry () \u2194 \u2203 i \u2208 s, \u2203 a \u2208 t, f i a = a\u271d"}]}
{"declaration": "theorem map_cast_heq {\u03b1 \u03b2} (h : \u03b1 = \u03b2) (s : Finset \u03b1) :\n    HEq (s.map (Equiv.cast h).toEmbedding) s := by\n  subst h\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Image.lean", "context": {"open": ["Multiset", "Function", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{f : \u03b1 \u21aa \u03b2} {s : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type u_4\nh : \u03b1 = \u03b2\ns : Finset \u03b1\n\u22a2 HEq (Finset.map (Equiv.cast h).toEmbedding s) s"}, {"line": "subst h", "tactic_state": "\u03b1 : Type u_4\ns : Finset \u03b1\n\u22a2 HEq (Finset.map (Equiv.cast \u22ef).toEmbedding s) s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_add_one' (n : \u2115) :\n    range (n + 1) = insert 0 ((range n).map \u27e8fun i => i + 1, fun i j => by simp\u27e9) := by\n  ext (\u27e8\u27e9 | \u27e8n\u27e9) <;> simp [Nat.zero_lt_succ n]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Image.lean", "context": {"open": ["Multiset", "Function", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{f : \u03b1 \u21aa \u03b2} {s : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 range (n + 1) = insert 0 (map sorry (range n))"}, {"line": "ext (\u27e8\u27e9 | \u27e8n\u27e9) <;> simp [Nat.zero_lt_succ n]", "tactic_state": "case a.zero\nn : \u2115\n\u22a2 count 0 (n ::\u2098 range n) = count 0 (map (fun x => sorry () x) (range n)) + 1\n---\ncase a.succ\nn\u271d n : \u2115\n\u22a2 count (n + 1) (n\u271d ::\u2098 range n\u271d) = count (n + 1) (map (fun x => sorry () x) (range n\u271d))"}]}
{"declaration": "lemma exists_mem_image {p : \u03b2 \u2192 Prop} : (\u2203 y \u2208 s.image f, p y) \u2194 \u2203 x \u2208 s, p (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Image.lean", "context": {"open": ["Multiset", "Function", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{f : \u03b1 \u21aa \u03b2} {s : Finset \u03b1}", "[DecidableEq \u03b2]", "{f g : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} {t : Finset \u03b2} {a : \u03b1} {b c : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 (\u2203 y \u2208 Finset.image f s, p y) \u2194 \u2203 x \u2208 s, p (f x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fiber_nonempty_iff_mem_image {y : \u03b2} : (s.filter (f \u00b7 = y)).Nonempty \u2194 y \u2208 s.image f := by\n  simp [Finset.Nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Image.lean", "context": {"open": ["Multiset", "Function", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{f : \u03b1 \u21aa \u03b2} {s : Finset \u03b1}", "[DecidableEq \u03b2]", "{f g : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} {t : Finset \u03b2} {a : \u03b1} {b c : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\ny : \u03b2\n\u22a2 {x \u2208 s | f x = y}.Nonempty \u2194 y \u2208 Finset.image f s"}, {"line": "simp [Finset.Nonempty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.List.toFinset_filterMap [DecidableEq \u03b1] [DecidableEq \u03b2] (s : List \u03b1) :\n    (s.filterMap f).toFinset = s.toFinset.filterMap f f_inj := by\n  simp [\u2190 Finset.coe_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Image.lean", "context": {"open": ["Multiset", "Function", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{f : \u03b1 \u21aa \u03b2} {s : Finset \u03b1}", "[DecidableEq \u03b2]", "{f g : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} {t : Finset \u03b2} {a : \u03b1} {b c : \u03b2}", "(f : \u03b1 \u2192 Option \u03b2) (s' : Finset \u03b1) {s t : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b2\nf : \u03b1 \u2192 Option \u03b2\nf_inj : \u2200 (a a' : \u03b1), \u2200 b \u2208 f a, b \u2208 f a' \u2192 a = a'\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\ns : List \u03b1\n\u22a2 (List.filterMap f s).toFinset = Finset.filterMap f s.toFinset f_inj"}, {"line": "simp [\u2190 Finset.coe_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subtype_eq_empty {p : \u03b1 \u2192 Prop} [DecidablePred p] {s : Finset \u03b1} :\n    s.subtype p = \u2205 \u2194 \u2200 x, p x \u2192 x \u2209 s := by simp [Finset.ext_iff, Subtype.forall, Subtype.coe_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Image.lean", "context": {"open": ["Multiset", "Function", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{f : \u03b1 \u21aa \u03b2} {s : Finset \u03b1}", "[DecidableEq \u03b2]", "{f g : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} {t : Finset \u03b2} {a : \u03b1} {b c : \u03b2}", "(f : \u03b1 \u2192 Option \u03b2) (s' : Finset \u03b1) {s t : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\ns : Finset \u03b1\n\u22a2 Finset.subtype p s = \u2205 \u2194 \u2200 (x : \u03b1), p x \u2192 x \u2209 s"}, {"line": "simp [Finset.ext_iff, Subtype.forall, Subtype.coe_mk]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subtype_map (p : \u03b1 \u2192 Prop) [DecidablePred p] {s : Finset \u03b1} :\n    (s.subtype p).map (Embedding.subtype _) = s.filter p := by\n  ext x\n  simp [@and_comm _ (_ = _), @and_left_comm _ (_ = _), @and_comm (p x) (x \u2208 s)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Image.lean", "context": {"open": ["Multiset", "Function", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{f : \u03b1 \u21aa \u03b2} {s : Finset \u03b1}", "[DecidableEq \u03b2]", "{f g : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} {t : Finset \u03b2} {a : \u03b1} {b c : \u03b2}", "(f : \u03b1 \u2192 Option \u03b2) (s' : Finset \u03b1) {s t : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\ns : Finset \u03b1\n\u22a2 Finset.map (Embedding.subtype p) (Finset.subtype p s) = Finset.filter p s"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\ns : Finset \u03b1\nx : \u03b1\n\u22a2 x \u2208 Finset.map (Embedding.subtype p) (Finset.subtype p s) \u2194 x \u2208 Finset.filter p s"}, {"line": "simp [@and_comm _ (_ = _), @and_left_comm _ (_ = _), @and_comm (p x) (x \u2208 s)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem property_of_mem_map_subtype {p : \u03b1 \u2192 Prop} (s : Finset { x // p x }) {a : \u03b1}\n    (h : a \u2208 s.map (Embedding.subtype _)) : p a := by\n  rcases mem_map.1 h with \u27e8x, _, rfl\u27e9\n  exact x.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Image.lean", "context": {"open": ["Multiset", "Function", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{f : \u03b1 \u21aa \u03b2} {s : Finset \u03b1}", "[DecidableEq \u03b2]", "{f g : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} {t : Finset \u03b2} {a : \u03b1} {b c : \u03b2}", "(f : \u03b1 \u2192 Option \u03b2) (s' : Finset \u03b1) {s t : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\ns : Finset { x // p x }\na : \u03b1\nh : a \u2208 Finset.map (Embedding.subtype fun x => p x) s\n\u22a2 p a"}, {"line": "rcases mem_map.1 h with \u27e8x, _, rfl\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\ns : Finset { x // p x }\nx : { x // p x }\nleft\u271d : x \u2208 s.val\nh : (Embedding.subtype fun x => p x) x \u2208 Finset.map (Embedding.subtype fun x => p x) s\n\u22a2 p ((Embedding.subtype fun x => p x) x)"}, {"line": "exact x.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finsetCongr_refl : (Equiv.refl \u03b1).finsetCongr = Equiv.refl _ := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Image.lean", "context": {"open": ["Multiset", "Function", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{f : \u03b1 \u21aa \u03b2} {s : Finset \u03b1}", "[DecidableEq \u03b2]", "{f g : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} {t : Finset \u03b2} {a : \u03b1} {b c : \u03b2}", "(f : \u03b1 \u2192 Option \u03b2) (s' : Finset \u03b1) {s t : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 (Equiv.refl \u03b1).finsetCongr = Equiv.refl (Finset \u03b1)"}, {"line": "ext", "tactic_state": "case H.h\n\u03b1 : Type u_1\nx\u271d : Finset \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 (Equiv.refl \u03b1).finsetCongr x\u271d \u2194 a\u271d \u2208 (Equiv.refl (Finset \u03b1)) x\u271d"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finsetCongr_trans (e : \u03b1 \u2243 \u03b2) (e' : \u03b2 \u2243 \u03b3) :\n    e.finsetCongr.trans e'.finsetCongr = (e.trans e').finsetCongr := by\n  ext\n  simp [-Finset.mem_map, -Equiv.trans_toEmbedding]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Image.lean", "context": {"open": ["Multiset", "Function", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{f : \u03b1 \u21aa \u03b2} {s : Finset \u03b1}", "[DecidableEq \u03b2]", "{f g : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} {t : Finset \u03b2} {a : \u03b1} {b c : \u03b2}", "(f : \u03b1 \u2192 Option \u03b2) (s' : Finset \u03b1) {s t : Finset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\ne : \u03b1 \u2243 \u03b2\ne' : \u03b2 \u2243 \u03b3\n\u22a2 e.finsetCongr.trans e'.finsetCongr = (e.trans e').finsetCongr"}, {"line": "ext", "tactic_state": "case H.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\ne : \u03b1 \u2243 \u03b2\ne' : \u03b2 \u2243 \u03b3\nx\u271d : Finset \u03b1\na\u271d : \u03b3\n\u22a2 a\u271d \u2208 (e.finsetCongr.trans e'.finsetCongr) x\u271d \u2194 a\u271d \u2208 (e.trans e').finsetCongr x\u271d"}, {"line": "simp [-Finset.mem_map, -Equiv.trans_toEmbedding]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_singleton (a : \u03b1) : (({a} : Finset \u03b1) : Set \u03b1) = {a} := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Insert.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "{s : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\n\u22a2 \u2191{a} = {a}"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\na x\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u2191{a} \u2194 x\u271d \u2208 {a}"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singleton_subset_singleton : ({a} : Finset \u03b1) \u2286 {b} \u2194 a = b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Insert.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "{s : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b : \u03b1\n\u22a2 {a} \u2286 {b} \u2194 a = b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_nontrivial_empty : \u00ac (\u2205 : Finset \u03b1).Nontrivial := by simp [Finset.Nontrivial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Insert.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "{s : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 \u00ac\u2205.Nontrivial"}, {"line": "simp [Finset.Nontrivial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_nontrivial_singleton : \u00ac ({a} : Finset \u03b1).Nontrivial := by simp [Finset.Nontrivial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Insert.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "{s : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\n\u22a2 \u00ac{a}.Nontrivial"}, {"line": "simp [Finset.Nontrivial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonempty_mk {m : Multiset \u03b1} {hm} : (\u27e8m, hm\u27e9 : Finset \u03b1).Nonempty \u2194 m \u2260 0 := by\n  induction m using Multiset.induction_on <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Insert.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "{s : Finset \u03b1} {a b : \u03b1}", "{s t : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : Multiset \u03b1\nhm : m.Nodup\n\u22a2 { val := m, nodup := hm }.Nonempty \u2194 m \u2260 0"}, {"line": "induction m using Multiset.induction_on <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_cons {a s h} : (@cons \u03b1 a s h : Set \u03b1) = insert a (s : Set \u03b1) := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Insert.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "{s : Finset \u03b1} {a b : \u03b1}", "{s t : Finset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\ns : Multiset \u03b1\nh : ?m.2436\n\u22a2 sorry = insert a sorry"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\na : \u03b1\ns : Multiset \u03b1\nh : ?m.2436\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 sorry \u2194 x\u271d \u2208 insert a sorry"}, {"line": "simp", "tactic_state": "case h\n\u03b1 : Type u_1\na : \u03b1\ns : Multiset \u03b1\nh : ?m.2436\nx\u271d : \u03b1\n\u22a2 x\u271d = a \u2192 x\u271d \u2208 sorry ()"}]}
{"declaration": "theorem mem_insert_coe {s : Finset \u03b1} {x y : \u03b1} : x \u2208 insert y s \u2194 x \u2208 insert y (s : Set \u03b1) := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Insert.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "{s : Finset \u03b1} {a b : \u03b1}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t : Finset \u03b1} {a b : \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nx y : \u03b1\n\u22a2 x \u2208 insert y s \u2194 x \u2208 insert y \u2191s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_pair {a b : \u03b1} : (({a, b} : Finset \u03b1) : Set \u03b1) = {a, b} := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Insert.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "{s : Finset \u03b1} {a b : \u03b1}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t : Finset \u03b1} {a b : \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\n\u22a2 \u2191{a, b} = {a, b}"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b x\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u2191{a, b} \u2194 x\u271d \u2208 {a, b}"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ne_insert_of_not_mem (s t : Finset \u03b1) {a : \u03b1} (h : a \u2209 s) : s \u2260 insert a t := by\n  contrapose! h\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Insert.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "{s : Finset \u03b1} {a b : \u03b1}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t : Finset \u03b1} {a b : \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\na : \u03b1\nh : a \u2209 s\n\u22a2 s \u2260 insert a t"}, {"line": "contrapose! h", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\na : \u03b1\nh : s = insert a t\n\u22a2 a \u2208 s"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_singleton (a : \u03b1) : toFinset ({a} : Multiset \u03b1) = {a} := by\n  rw [\u2190 cons_zero]\n  rw [toFinset_cons]\n  rw [toFinset_zero]\n  rw [LawfulSingleton.insert_empty_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Insert.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "{s : Finset \u03b1} {a b : \u03b1}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t : Finset \u03b1} {a b : \u03b1} {f : \u03b1 \u2192 \u03b2}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\na : \u03b1\n\u22a2 {a}.toFinset = {a}"}, {"line": "rw [\u2190 cons_zero]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\na : \u03b1\n\u22a2 (a ::\u2098 0).toFinset = {a}"}, {"line": "rw [toFinset_cons]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\na : \u03b1\n\u22a2 insert a (toFinset 0) = {a}"}, {"line": "rw [toFinset_zero]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\na : \u03b1\n\u22a2 insert a \u2205 = {a}"}, {"line": "rw [LawfulSingleton.insert_empty_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_replicate_of_ne_zero {n : \u2115} (hn : n \u2260 0) :\n    (List.replicate n a).toFinset = {a} := by\n  ext x\n  simp [hn, List.mem_replicate]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Insert.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "{s : Finset \u03b1} {a b : \u03b1}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t : Finset \u03b1} {a b : \u03b1} {f : \u03b1 \u2192 \u03b2}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1] {l : List \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\na : \u03b1\nn : \u2115\nhn : n \u2260 0\n\u22a2 (List.replicate n a).toFinset = {a}"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\na : \u03b1\nn : \u2115\nhn : n \u2260 0\nx : \u03b1\n\u22a2 x \u2208 (List.replicate n a).toFinset \u2194 x \u2208 {a}"}, {"line": "simp [hn, List.mem_replicate]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_eq_empty_iff (l : List \u03b1) : l.toFinset = \u2205 \u2194 l = nil := by\n  cases l <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Insert.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "{s : Finset \u03b1} {a b : \u03b1}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t : Finset \u03b1} {a b : \u03b1} {f : \u03b1 \u2192 \u03b2}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1] {l : List \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nnil l : List \u03b1\n\u22a2 l.toFinset = \u2205 \u2194 l = nil"}, {"line": "cases l <;> simp", "tactic_state": "case nil\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nnil : List \u03b1\n\u22a2 nil = []\n---\ncase cons\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nnil : List \u03b1\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\n\u22a2 \u00achead\u271d :: tail\u271d = nil"}]}
{"declaration": "theorem toFinset_nonempty_iff (l : List \u03b1) : l.toFinset.Nonempty \u2194 l \u2260 [] := by\n  simp [Finset.nonempty_iff_ne_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Insert.lean", "context": {"open": ["Multiset Subtype Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "{s : Finset \u03b1} {a b : \u03b1}", "{s t : Finset \u03b1} {a b : \u03b1}", "[DecidableEq \u03b1] {s t : Finset \u03b1} {a b : \u03b1} {f : \u03b1 \u2192 \u03b2}", "[DecidableEq \u03b1]", "[DecidableEq \u03b1] {l : List \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nl : List \u03b1\n\u22a2 l.toFinset.Nonempty \u2194 l \u2260 []"}, {"line": "simp [Finset.nonempty_iff_ne_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem min_eq_top {s : Finset \u03b1} : s.min = \u22a4 \u2194 s = \u2205 := by\n  simp [Finset.min, eq_empty_iff_forall_not_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Max.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : LinearOrder \u03b1\ns : Finset \u03b1\n\u22a2 s.min = \u22a4 \u2194 s = \u2205"}, {"line": "simp [Finset.min, eq_empty_iff_forall_not_mem]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : LinearOrder \u03b1\ns : Finset \u03b1\n\u22a2 (\u2200 (s_1 : \u03b1), s_1 \u2209 s) \u2194 s = \u2205"}]}
{"declaration": "theorem min'_singleton (a : \u03b1) : ({a} : Finset \u03b1).min' (singleton_nonempty _) = a := by simp [min']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Max.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[LinearOrder \u03b1]", "(s : Finset \u03b1) (H : s.Nonempty) {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : LinearOrder \u03b1\nx\u271d : Sort u_7\nsingleton_nonempty : x\u271d\na : \u03b1\n\u22a2 {a}.min' \u22ef = a"}, {"line": "simp [min']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem max'_singleton (a : \u03b1) : ({a} : Finset \u03b1).max' (singleton_nonempty _) = a := by simp [max']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Max.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[LinearOrder \u03b1]", "(s : Finset \u03b1) (H : s.Nonempty) {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : LinearOrder \u03b1\nx\u271d : Sort u_7\nsingleton_nonempty : x\u271d\na : \u03b1\n\u22a2 {a}.max' \u22ef = a"}, {"line": "simp [max']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem induction_on_max [DecidableEq \u03b1] {p : Finset \u03b1 \u2192 Prop} (s : Finset \u03b1) (h0 : p \u2205)\n    (step : \u2200 a s, (\u2200 x \u2208 s, x < a) \u2192 p s \u2192 p (insert a s)) : p s := by\n  induction' s using Finset.strongInductionOn with s ihs\n  rcases s.eq_empty_or_nonempty with (rfl | hne)\n  \u00b7 exact h0\n  \u00b7 have H : s.max' hne \u2208 s := max'_mem s hne\n    rw [\u2190 insert_erase H]\n    exact step _ _ (fun x => s.lt_max'_of_mem_erase_max' hne) (ihs _ <| erase_ssubset H)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Max.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[LinearOrder \u03b1]", "(s : Finset \u03b1) (H : s.Nonempty) {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : DecidableEq \u03b1\np : Finset \u03b1 \u2192 Prop\ns : Finset \u03b1\nh0 : p \u2205\nstep : \u2200 (a : \u03b1) (s : Finset \u03b1), (\u2200 x \u2208 s, x < a) \u2192 p s \u2192 p (insert a s)\n\u22a2 p s"}, {"line": "induction' s using Finset.strongInductionOn with s ihs", "tactic_state": "case a\n\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : DecidableEq \u03b1\np : Finset \u03b1 \u2192 Prop\nh0 : p \u2205\nstep : \u2200 (a : \u03b1) (s : Finset \u03b1), (\u2200 x \u2208 s, x < a) \u2192 p s \u2192 p (insert a s)\ns : Finset \u03b1\nihs : \u2200 t \u2282 s, p t\n\u22a2 p s"}, {"line": "rcases s.eq_empty_or_nonempty with (rfl | hne)", "tactic_state": "case a.inl\n\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : DecidableEq \u03b1\np : Finset \u03b1 \u2192 Prop\nh0 : p \u2205\nstep : \u2200 (a : \u03b1) (s : Finset \u03b1), (\u2200 x \u2208 s, x < a) \u2192 p s \u2192 p (insert a s)\nihs : \u2200 t \u2282 \u2205, p t\n\u22a2 p \u2205\n---\ncase a.inr\n\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : DecidableEq \u03b1\np : Finset \u03b1 \u2192 Prop\nh0 : p \u2205\nstep : \u2200 (a : \u03b1) (s : Finset \u03b1), (\u2200 x \u2208 s, x < a) \u2192 p s \u2192 p (insert a s)\ns : Finset \u03b1\nihs : \u2200 t \u2282 s, p t\nhne : s.Nonempty\n\u22a2 p s"}, {"line": "\u00b7 exact h0", "tactic_state": "case a.inr\n\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : DecidableEq \u03b1\np : Finset \u03b1 \u2192 Prop\nh0 : p \u2205\nstep : \u2200 (a : \u03b1) (s : Finset \u03b1), (\u2200 x \u2208 s, x < a) \u2192 p s \u2192 p (insert a s)\ns : Finset \u03b1\nihs : \u2200 t \u2282 s, p t\nhne : s.Nonempty\n\u22a2 p s"}, {"line": "\u00b7 have H : s.max' hne \u2208 s := max'_mem s hne\n    rw [\u2190 insert_erase H]\n    exact step _ _ (fun x => s.lt_max'_of_mem_erase_max' hne) (ihs _ <| erase_ssubset H)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isGLB_iff_isLeast [LinearOrder \u03b1] (i : \u03b1) (s : Finset \u03b1) (hs : s.Nonempty) :\n    IsGLB (s : Set \u03b1) i \u2194 IsLeast (\u2191s) i := by\n  refine \u27e8fun his => ?_, IsLeast.isGLB\u27e9\n  suffices i = min' s hs by\n    rw [this]\n    exact isLeast_min' s hs\n  rw [IsGLB] at his\n  rw [IsGreatest] at his\n  rw [mem_lowerBounds] at his\n  rw [mem_upperBounds] at his\n  exact le_antisymm (his.1 (Finset.min' s hs) (Finset.min'_mem s hs)) (his.2 _ (Finset.min'_le s))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Finset/Max.lean", "context": {"open": ["Function Multiset OrderDual"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b9 \u03ba : Type*}", "[LinearOrder \u03b1]", "(s : Finset \u03b1) (H : s.Nonempty) {x : \u03b1}", "[LinearOrder \u03b1] [LinearOrder \u03b2]", "[LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : LinearOrder \u03b1\ni : \u03b1\ns : Finset \u03b1\nhs : s.Nonempty\n\u22a2 IsGLB (\u2191s) i \u2194 IsLeast (\u2191s) i"}, {"line": "refine \u27e8fun his => ?_, IsLeast.isGLB\u27e9", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : LinearOrder \u03b1\ni : \u03b1\ns : Finset \u03b1\nhs : s.Nonempty\nhis : IsGLB (\u2191s) i\n\u22a2 IsLeast (\u2191s) i"}, {"line": "suffices i = min' s hs by\n    rw [this]\n    exact isLeast_min' s hs", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : LinearOrder \u03b1\ni : \u03b1\ns : Finset \u03b1\nhs : s.Nonempty\nhis : IsGLB (\u2191s) i\n\u22a2 i = sorry"}, {"line": "rw [IsGLB] at his", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : LinearOrder \u03b1\ni : \u03b1\ns : Finset \u03b1\nhs : s.Nonempty\nhis : IsGreatest (lowerBounds \u2191s) i\n\u22a2 i = sorry"}, {"line": "rw [IsGreatest] at his", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : LinearOrder \u03b1\ni : \u03b1\ns : Finset \u03b1\nhs : s.Nonempty\nhis : i \u2208 lowerBounds \u2191s \u2227 i \u2208 upperBounds (lowerBounds \u2191s)\n\u22a2 i = sorry"}, {"line": "rw [mem_lowerBounds] at his", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : LinearOrder \u03b1\ni : \u03b1\ns : Finset \u03b1\nhs : s.Nonempty\nhis : (\u2200 x \u2208 \u2191s, i \u2264 x) \u2227 i \u2208 upperBounds (lowerBounds \u2191s)\n\u22a2 i = sorry"}, {"line": "rw [mem_upperBounds] at his", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : LinearOrder \u03b1\ni : \u03b1\ns : Finset \u03b1\nhs : s.Nonempty\nhis : (\u2200 x \u2208 \u2191s, i \u2264 x) \u2227 \u2200 x \u2208 lowerBounds \u2191s, x \u2264 i\n\u22a2 i = sorry"}, {"line": "exact le_antisymm (his.1 (Finset.min' s hs) (Finset.min'_mem s hs)) (his.2 _ (Finset.min'_le s))", "tactic_state": "No Goals!"}]}
