{"declaration": "theorem count_span_normalizedFactors_eq_of_normUnit {r X : R}\n    (hr : r \u2260 0) (hX\u2081 : normUnit X = 1) (hX : Prime X) :\n      Multiset.count (Ideal.span {X} : Ideal R) (normalizedFactors (Ideal.span {r})) =\n        Multiset.count X (normalizedFactors r) := by\n  simpa [hX\u2081, normalize_apply] using count_span_normalizedFactors_eq hr hX\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/DedekindDomain/Ideal.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "Submodule Submodule.IsPrincipal", "FractionalIdeal", "Ring", "Ideal", "FractionalIdeal", "Ideal", "Submodule.IsPrincipal in", "UniqueFactorizationMonoid in", "UniqueFactorizationMonoid", "FractionalIdeal", "Multiset UniqueFactorizationMonoid Ideal", "Ideal", "UniqueFactorizationMonoid", "Ideal UniqueFactorizationMonoid", "scoped Classical in", "UniqueFactorizationMonoid Ideal"], "variables": ["(R A K : Type*) [CommRing R] [CommRing A] [Field K]", "{R\u2081 : Type*} [CommRing R\u2081] [IsDomain R\u2081] [Algebra R\u2081 K] [IsFractionRing R\u2081 K]", "{I J : FractionalIdeal R\u2081\u2070 K}", "{K}", "(K)", "{K' : Type*} [Field K'] [Algebra R\u2081 K'] [IsFractionRing R\u2081 K']", "{K}", "[IsDomain A]", "{R A K}", "[Algebra A K] [IsFractionRing A K] (h : IsDedekindDomainInv A)", "[Algebra A K] [IsFractionRing A K]", "{A K}", "{R A}", "[IsDedekindDomain A] [Algebra A K] [IsFractionRing A K]", "{K}", "{T : Type*} [CommRing T] [IsDedekindDomain T] {I J : Ideal T}", "[IsDedekindDomain R]", "(v : HeightOneSpectrum R) {R}", "(R)", "{R A}", "[IsDedekindDomain A] {I : Ideal R} {J : Ideal A}", "{B : Type*} [CommRing B] [IsDedekindDomain B] {L : Ideal B}", "[IsDedekindDomain R] (f : R \u29f8 I \u2243+* A \u29f8 J)", "{R}", "[IsDedekindDomain R]", "{R}", "[IsDomain R] [IsPrincipalIdealRing R]", "[NormalizationMonoid R]", "[DecidableEq R] [DecidableEq (Ideal R)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : IsDedekindDomain R\ninst\u271d\u2074 : IsDomain R\ninst\u271d\u00b3 : IsPrincipalIdealRing R\ninst\u271d\u00b2 : NormalizationMonoid R\ninst\u271d\u00b9 : DecidableEq R\ninst\u271d : DecidableEq (Ideal R)\nr X : R\nhr : r \u2260 0\nhX\u2081 : normUnit X = 1\nhX : Prime X\n\u22a2 Multiset.count (Ideal.span {X}) (normalizedFactors (Ideal.span {r})) = Multiset.count X (normalizedFactors r)"}, {"line": "simpa [hX\u2081, normalize_apply] using count_span_normalizedFactors_eq hr hX", "tactic_state": "No Goals!"}]}
{"declaration": "lemma liftOfSurjective_apply {f : F} (hf : Function.Surjective f)\n    {d : Derivation R A A} (hd : \u2200 x, f x = 0 \u2192 f (d x) = 0) (x : A) :\n    Derivation.liftOfSurjective hf hd (f x) = f (d x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Derivation/Basic.lean", "context": {"open": ["Algebra", "Polynomial in"], "variables": ["{R : Type*} {A : Type*} {B : Type*} {M : Type*}", "[CommSemiring R] [CommSemiring A] [CommSemiring B] [AddCommMonoid M]", "[Algebra R A] [Algebra R B]", "[Module A M] [Module B M] [Module R M]", "(D : Derivation R A M) {D1 D2 : Derivation R A M} (r : R) (a b : A)", "{S T : Type*}", "[Monoid S] [DistribMulAction S M] [SMulCommClass R S M] [SMulCommClass S A M]", "[Monoid T] [DistribMulAction T M] [SMulCommClass R T M] [SMulCommClass T A M]", "{N : Type*} [AddCommMonoid N] [Module A N] [Module R N] [IsScalarTower R A M]", "(f : M \u2192\u2097[A] N) (e : M \u2243\u2097[A] N)", "(A) in", "{S : Type*} [CommSemiring S]", "[Algebra S A] [Module S M] [LinearMap.CompatibleSMul A M R S]", "(R)", "{R : Type*} {A : Type*} {M : Type*}", "[CommSemiring R] [CommRing A] [CommRing M]", "[Algebra R A] [Algebra R M]", "{F : Type*} [FunLike F A M] [AlgHomClass F R A M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\nA : Type u_5\nM : Type u_6\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : CommRing M\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra R M\nF : Type u_7\ninst\u271d\u00b9 : FunLike F A M\ninst\u271d : AlgHomClass F R A M\nf : F\nhf : Function.Surjective \u21d1f\nd : Derivation R A A\nhd : \u2200 (x : A), f x = 0 \u2192 f (d x) = 0\nx : A\n\u22a2 (Derivation.liftOfSurjective hf hd) (f x) = f (d x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leibniz_inv (a : K) : D a\u207b\u00b9 = -a\u207b\u00b9 ^ 2 \u2022 D a := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  \u00b7 simp\n  \u00b7 exact D.leibniz_of_mul_eq_one (inv_mul_cancel\u2080 ha)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Derivation/Basic.lean", "context": {"open": ["Algebra", "Polynomial in"], "variables": ["{R : Type*} {A : Type*} {B : Type*} {M : Type*}", "[CommSemiring R] [CommSemiring A] [CommSemiring B] [AddCommMonoid M]", "[Algebra R A] [Algebra R B]", "[Module A M] [Module B M] [Module R M]", "(D : Derivation R A M) {D1 D2 : Derivation R A M} (r : R) (a b : A)", "{S T : Type*}", "[Monoid S] [DistribMulAction S M] [SMulCommClass R S M] [SMulCommClass S A M]", "[Monoid T] [DistribMulAction T M] [SMulCommClass R T M] [SMulCommClass T A M]", "{N : Type*} [AddCommMonoid N] [Module A N] [Module R N] [IsScalarTower R A M]", "(f : M \u2192\u2097[A] N) (e : M \u2243\u2097[A] N)", "(A) in", "{S : Type*} [CommSemiring S]", "[Algebra S A] [Module S M] [LinearMap.CompatibleSMul A M R S]", "(R)", "{R : Type*} {A : Type*} {M : Type*}", "[CommSemiring R] [CommRing A] [CommRing M]", "[Algebra R A] [Algebra R M]", "{F : Type*} [FunLike F A M] [AlgHomClass F R A M]", "{R : Type*} [CommSemiring R] {A : Type*} [CommSemiring A] [Algebra R A] {M : Type*}", "{R : Type*} [CommRing R]", "{A : Type*} [CommRing A] [Algebra R A]", "{M : Type*} [AddCommGroup M] [Module A M] [Module R M]", "(D : Derivation R A M) {D1 D2 : Derivation R A M} (r : R) (a b : A)", "{K : Type*} [Field K] [Module K M] [Algebra R K] (D : Derivation R K M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_11\ninst\u271d\u2075 : CommRing R\nM : Type u_13\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nK : Type u_14\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Module K M\ninst\u271d : Algebra R K\nD : Derivation R K M\na : K\n\u22a2 D a\u207b\u00b9 = -a\u207b\u00b9 ^ 2 \u2022 D a"}, {"line": "rcases eq_or_ne a 0 with (rfl | ha)", "tactic_state": "case inl\nR : Type u_11\ninst\u271d\u2075 : CommRing R\nM : Type u_13\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nK : Type u_14\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Module K M\ninst\u271d : Algebra R K\nD : Derivation R K M\n\u22a2 D sorry\u207b\u00b9 = -sorry\u207b\u00b9 ^ 2 \u2022 D sorry\n---\ncase inr\nR : Type u_11\ninst\u271d\u2075 : CommRing R\nM : Type u_13\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nK : Type u_14\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Module K M\ninst\u271d : Algebra R K\nD : Derivation R K M\na : K\nha : a \u2260 sorry\n\u22a2 D a\u207b\u00b9 = -a\u207b\u00b9 ^ 2 \u2022 D a"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nR : Type u_11\ninst\u271d\u2075 : CommRing R\nM : Type u_13\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nK : Type u_14\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Module K M\ninst\u271d : Algebra R K\nD : Derivation R K M\na : K\nha : a \u2260 sorry\n\u22a2 D a\u207b\u00b9 = -a\u207b\u00b9 ^ 2 \u2022 D a"}, {"line": "\u00b7 exact D.leibniz_of_mul_eq_one (inv_mul_cancel\u2080 ha)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem liftOfDerivationToSquareZero_mk_apply [IsScalarTower R A B] (d : Derivation R A I) (x : A) :\n    Ideal.Quotient.mk I (liftOfDerivationToSquareZero I hI d x) = algebraMap A (B \u29f8 I) x := by\n  rw [liftOfDerivationToSquareZero_apply]\n  rw [map_add]\n  rw [Ideal.Quotient.eq_zero_iff_mem.mpr (d x).prop]\n  rw [zero_add]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Derivation/ToSquareZero.lean", "context": {"open": [], "variables": ["{R : Type u} {A : Type v} {B : Type w} [CommSemiring R] [CommSemiring A] [CommRing B]", "[Algebra R A] [Algebra R B] (I : Ideal B)", "[Algebra A B]", "(hI : I ^ 2 = \u22a5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : CommRing B\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra R B\nI : Ideal B\ninst\u271d\u00b9 : Algebra A B\nhI : I ^ 2 = \u22a5\ninst\u271d : IsScalarTower R A B\nd : Derivation R A \u21a5I\nx : A\n\u22a2 (Ideal.Quotient.mk I) ((liftOfDerivationToSquareZero I hI d) x) = (algebraMap A (B \u29f8 I)) x"}, {"line": "rw [liftOfDerivationToSquareZero_apply]", "tactic_state": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : CommRing B\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra R B\nI : Ideal B\ninst\u271d\u00b9 : Algebra A B\nhI : I ^ 2 = \u22a5\ninst\u271d : IsScalarTower R A B\nd : Derivation R A \u21a5I\nx : A\n\u22a2 (Ideal.Quotient.mk I) (\u2191(d x) + (algebraMap A B) x) = (algebraMap A (B \u29f8 I)) x"}, {"line": "rw [map_add]", "tactic_state": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : CommRing B\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra R B\nI : Ideal B\ninst\u271d\u00b9 : Algebra A B\nhI : I ^ 2 = \u22a5\ninst\u271d : IsScalarTower R A B\nd : Derivation R A \u21a5I\nx : A\n\u22a2 (Ideal.Quotient.mk I) \u2191(d x) + (Ideal.Quotient.mk I) ((algebraMap A B) x) = (algebraMap A (B \u29f8 I)) x"}, {"line": "rw [Ideal.Quotient.eq_zero_iff_mem.mpr (d x).prop]", "tactic_state": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : CommRing B\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra R B\nI : Ideal B\ninst\u271d\u00b9 : Algebra A B\nhI : I ^ 2 = \u22a5\ninst\u271d : IsScalarTower R A B\nd : Derivation R A \u21a5I\nx : A\n\u22a2 0 + (Ideal.Quotient.mk I) ((algebraMap A B) x) = (algebraMap A (B \u29f8 I)) x"}, {"line": "rw [zero_add]", "tactic_state": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : CommRing B\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra R B\nI : Ideal B\ninst\u271d\u00b9 : Algebra A B\nhI : I ^ 2 = \u22a5\ninst\u271d : IsScalarTower R A B\nd : Derivation R A \u21a5I\nx : A\n\u22a2 (Ideal.Quotient.mk I) ((algebraMap A B) x) = (algebraMap A (B \u29f8 I)) x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem liftOfDerivationToSquareZero_mk_apply' (d : Derivation R A I) (x : A) :\n    (Ideal.Quotient.mk I) (d x) + (algebraMap A (B \u29f8 I)) x = algebraMap A (B \u29f8 I) x := by\n  simp only [Ideal.Quotient.eq_zero_iff_mem.mpr (d x).prop]\n  simp only [zero_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Derivation/ToSquareZero.lean", "context": {"open": [], "variables": ["{R : Type u} {A : Type v} {B : Type w} [CommSemiring R] [CommSemiring A] [CommRing B]", "[Algebra R A] [Algebra R B] (I : Ideal B)", "[Algebra A B]", "(hI : I ^ 2 = \u22a5)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : CommSemiring A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Algebra R B\nI : Ideal B\ninst\u271d : Algebra A B\nd : Derivation R A \u21a5I\nx : A\n\u22a2 (Ideal.Quotient.mk I) \u2191(d x) + (algebraMap A (B \u29f8 I)) x = (algebraMap A (B \u29f8 I)) x"}, {"line": "simp only [Ideal.Quotient.eq_zero_iff_mem.mpr (d x).prop]", "tactic_state": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : CommSemiring A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Algebra R B\nI : Ideal B\ninst\u271d : Algebra A B\nd : Derivation R A \u21a5I\nx : A\n\u22a2 0 + (algebraMap A (B \u29f8 I)) x = (algebraMap A (B \u29f8 I)) x"}, {"line": "simp only [zero_add]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mapCoeffs_X :\n    d.mapCoeffs (X : A[X]) = 0 := by simp [\u2190 monomial_one_one_eq_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Derivation/MapCoeffs.lean", "context": {"open": ["Polynomial Module"], "variables": ["{R A M : Type*} [CommRing R] [CommRing A] [Algebra R A] [AddCommGroup M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = 0"}, {"line": "simp [\u2190 monomial_one_one_eq_X]", "tactic_state": "\u22a2 sorry () = 0"}]}
{"declaration": "lemma mapCoeffs_X :\n    mapCoeffs (X : A[X]) = 0 := by simp [\u2190 monomial_one_one_eq_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Derivation/MapCoeffs.lean", "context": {"open": ["Polynomial Module"], "variables": ["{R A M : Type*} [CommRing R] [CommRing A] [Algebra R A] [AddCommGroup M]", "{B M' : Type*} [CommRing B] [Algebra R B] [Algebra A B]", "{A : Type*} [CommRing A] [Differential A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_7\nmapCoeffs : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [\u2190 monomial_one_one_eq_X]", "tactic_state": "x\u271d : Sort u_7\nmapCoeffs : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem addVal_uniformizer {\u03d6 : R} (h\u03d6 : Irreducible \u03d6) : addVal R \u03d6 = 1 := by\n  simpa only [one_mul,eq_self_iff_true,Units.val_one,pow_one,forall_true_left,Nat.cast_one]\n    using addVal_def \u03d6 1 h\u03d6 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/DiscreteValuationRing/Basic.lean", "context": {"open": ["Ideal IsLocalRing", "PrincipalIdealRing", "Submodule.IsPrincipal", "Classical in"], "variables": ["(R : Type u) [CommRing R] [IsDomain R] [IsDiscreteValuationRing R]", "{R}", "(R)", "(R : Type*)", "{R} [CommRing R]", "[IsDomain R]", "[CommRing R] [IsDomain R] [IsDiscreteValuationRing R]", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDiscreteValuationRing R\nx\u271d : Sort u_2\naddVal : x\u271d\n\u03d6 : R\nh\u03d6 : Irreducible \u03d6\n\u22a2 sorry = 1"}, {"line": "simpa only [one_mul,eq_self_iff_true,Units.val_one,pow_one,forall_true_left,Nat.cast_one]\n    using addVal_def \u03d6 1 h\u03d6 1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsLocalRing.finrank_CotangentSpace_eq_one_iff [IsNoetherianRing R] [IsLocalRing R]\n    [IsDomain R] : finrank (ResidueField R) (CotangentSpace R) = 1 \u2194 IsDiscreteValuationRing R := by\n  by_cases hR : IsField R\n  \u00b7 letI := hR.toField\n    simp only [finrank_cotangentSpace_eq_zero]\n    simp only [zero_ne_one]\n    simp only [false_iff]\n    exact fun h \u21a6 h.3 maximalIdeal_eq_bot\n  \u00b7 exact (IsDiscreteValuationRing.TFAE R hR).out 5 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/DiscreteValuationRing/TFAE.lean", "context": {"open": ["scoped Multiplicative", "IsLocalRing Module"], "variables": ["(R : Type*) [CommRing R]", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsNoetherianRing R\ninst\u271d\u00b9 : IsLocalRing R\ninst\u271d : IsDomain R\n\u22a2 finrank (ResidueField R) (CotangentSpace R) = 1 \u2194 IsDiscreteValuationRing R"}, {"line": "by_cases hR : IsField R", "tactic_state": "case pos\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsNoetherianRing R\ninst\u271d\u00b9 : IsLocalRing R\ninst\u271d : IsDomain R\nhR : sorry\n\u22a2 finrank (ResidueField R) (CotangentSpace R) = 1 \u2194 IsDiscreteValuationRing R\n---\ncase neg\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsNoetherianRing R\ninst\u271d\u00b9 : IsLocalRing R\ninst\u271d : IsDomain R\nhR : \u00acsorry\n\u22a2 finrank (ResidueField R) (CotangentSpace R) = 1 \u2194 IsDiscreteValuationRing R"}, {"line": "\u00b7 letI := hR.toField\n    simp only [finrank_cotangentSpace_eq_zero]\n    simp only [zero_ne_one]\n    simp only [false_iff]\n    exact fun h \u21a6 h.3 maximalIdeal_eq_bot", "tactic_state": "case neg\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsNoetherianRing R\ninst\u271d\u00b9 : IsLocalRing R\ninst\u271d : IsDomain R\nhR : \u00acsorry\n\u22a2 finrank (ResidueField R) (CotangentSpace R) = 1 \u2194 IsDiscreteValuationRing R"}, {"line": "\u00b7 exact (IsDiscreteValuationRing.TFAE R hR).out 5 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DividedPowers.ext (hI : DividedPowers I) (hI' : DividedPowers I)\n    (h_eq : \u2200 (n : \u2115) {x : A} (_ : x \u2208 I), hI.dpow n x = hI'.dpow n x) :\n    hI = hI' := by\n  obtain \u27e8hI, h\u2080, _\u27e9 := hI\n  obtain \u27e8hI', h\u2080', _\u27e9 := hI'\n  simp only [mk.injEq]\n  ext n x\n  by_cases hx : x \u2208 I\n  \u00b7 exact h_eq n hx\n  \u00b7 rw [h\u2080 hx, h\u2080' hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/DividedPowers/Basic.lean", "context": {"open": ["Finset Nat Ideal"], "variables": ["{A : Type*} [CommSemiring A] (I : Ideal A)", "(A) in", "{I} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\ninst\u271d : CommSemiring A\nI : Ideal A\nhI hI' : DividedPowers I\nh_eq : \u2200 (n : \u2115) {x : A}, x \u2208 I \u2192 hI.dpow n x = hI'.dpow n x\n\u22a2 hI = hI'"}, {"line": "obtain \u27e8hI, h\u2080, _\u27e9 := hI", "tactic_state": "case mk\nA : Type u_1\ninst\u271d : CommSemiring A\nI : Ideal A\nhI' : DividedPowers I\nhI : \u2115 \u2192 A \u2192 A\nh\u2080 : \u2200 {n : \u2115} {x : A}, x \u2209 I \u2192 hI n x = 0\ndpow_zero\u271d : \u2200 {x : A}, x \u2208 I \u2192 hI 0 x = 1\ndpow_one\u271d : \u2200 {x : A}, x \u2208 I \u2192 hI 1 x = x\ndpow_mem\u271d : \u2200 {n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI n x \u2208 I\ndpow_add\u271d : \u2200 {n : \u2115} {x y : A}, x \u2208 I \u2192 y \u2208 I \u2192 hI n (x + y) = \u2211 k \u2208 antidiagonal n, hI k.1 x * hI k.2 y\ndpow_mul\u271d : \u2200 {n : \u2115} {a x : A}, x \u2208 I \u2192 hI n (a * x) = a ^ n * hI n x\nmul_dpow\u271d : \u2200 {m n : \u2115} {x : A}, x \u2208 I \u2192 hI m x * hI n x = \u2191((m + n).choose m) * hI (m + n) x\ndpow_comp\u271d : \u2200 {m n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI m (hI n x) = \u2191(m.uniformBell n) * hI (m * n) x\nh_eq :\n  \u2200 (n : \u2115) {x : A},\n    x \u2208 I \u2192\n      { dpow := hI, dpow_null := h\u2080, dpow_zero := dpow_zero\u271d, dpow_one := dpow_one\u271d, dpow_mem := dpow_mem\u271d,\n              dpow_add := dpow_add\u271d, dpow_mul := dpow_mul\u271d, mul_dpow := mul_dpow\u271d, dpow_comp := dpow_comp\u271d }.dpow\n          n x =\n        hI'.dpow n x\n\u22a2 { dpow := hI, dpow_null := h\u2080, dpow_zero := dpow_zero\u271d, dpow_one := dpow_one\u271d, dpow_mem := dpow_mem\u271d,\n      dpow_add := dpow_add\u271d, dpow_mul := dpow_mul\u271d, mul_dpow := mul_dpow\u271d, dpow_comp := dpow_comp\u271d } =\n    hI'"}, {"line": "obtain \u27e8hI', h\u2080', _\u27e9 := hI'", "tactic_state": "case mk.mk\nA : Type u_1\ninst\u271d : CommSemiring A\nI : Ideal A\nhI : \u2115 \u2192 A \u2192 A\nh\u2080 : \u2200 {n : \u2115} {x : A}, x \u2209 I \u2192 hI n x = 0\ndpow_zero\u271d\u00b9 : \u2200 {x : A}, x \u2208 I \u2192 hI 0 x = 1\ndpow_one\u271d\u00b9 : \u2200 {x : A}, x \u2208 I \u2192 hI 1 x = x\ndpow_mem\u271d\u00b9 : \u2200 {n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI n x \u2208 I\ndpow_add\u271d\u00b9 : \u2200 {n : \u2115} {x y : A}, x \u2208 I \u2192 y \u2208 I \u2192 hI n (x + y) = \u2211 k \u2208 antidiagonal n, hI k.1 x * hI k.2 y\ndpow_mul\u271d\u00b9 : \u2200 {n : \u2115} {a x : A}, x \u2208 I \u2192 hI n (a * x) = a ^ n * hI n x\nmul_dpow\u271d\u00b9 : \u2200 {m n : \u2115} {x : A}, x \u2208 I \u2192 hI m x * hI n x = \u2191((m + n).choose m) * hI (m + n) x\ndpow_comp\u271d\u00b9 : \u2200 {m n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI m (hI n x) = \u2191(m.uniformBell n) * hI (m * n) x\nhI' : \u2115 \u2192 A \u2192 A\nh\u2080' : \u2200 {n : \u2115} {x : A}, x \u2209 I \u2192 hI' n x = 0\ndpow_zero\u271d : \u2200 {x : A}, x \u2208 I \u2192 hI' 0 x = 1\ndpow_one\u271d : \u2200 {x : A}, x \u2208 I \u2192 hI' 1 x = x\ndpow_mem\u271d : \u2200 {n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI' n x \u2208 I\ndpow_add\u271d : \u2200 {n : \u2115} {x y : A}, x \u2208 I \u2192 y \u2208 I \u2192 hI' n (x + y) = \u2211 k \u2208 antidiagonal n, hI' k.1 x * hI' k.2 y\ndpow_mul\u271d : \u2200 {n : \u2115} {a x : A}, x \u2208 I \u2192 hI' n (a * x) = a ^ n * hI' n x\nmul_dpow\u271d : \u2200 {m n : \u2115} {x : A}, x \u2208 I \u2192 hI' m x * hI' n x = \u2191((m + n).choose m) * hI' (m + n) x\ndpow_comp\u271d : \u2200 {m n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI' m (hI' n x) = \u2191(m.uniformBell n) * hI' (m * n) x\nh_eq :\n  \u2200 (n : \u2115) {x : A},\n    x \u2208 I \u2192\n      { dpow := hI, dpow_null := h\u2080, dpow_zero := dpow_zero\u271d\u00b9, dpow_one := dpow_one\u271d\u00b9, dpow_mem := dpow_mem\u271d\u00b9,\n              dpow_add := dpow_add\u271d\u00b9, dpow_mul := dpow_mul\u271d\u00b9, mul_dpow := mul_dpow\u271d\u00b9, dpow_comp := dpow_comp\u271d\u00b9 }.dpow\n          n x =\n        { dpow := hI', dpow_null := h\u2080', dpow_zero := dpow_zero\u271d, dpow_one := dpow_one\u271d, dpow_mem := dpow_mem\u271d,\n              dpow_add := dpow_add\u271d, dpow_mul := dpow_mul\u271d, mul_dpow := mul_dpow\u271d, dpow_comp := dpow_comp\u271d }.dpow\n          n x\n\u22a2 { dpow := hI, dpow_null := h\u2080, dpow_zero := dpow_zero\u271d\u00b9, dpow_one := dpow_one\u271d\u00b9, dpow_mem := dpow_mem\u271d\u00b9,\n      dpow_add := dpow_add\u271d\u00b9, dpow_mul := dpow_mul\u271d\u00b9, mul_dpow := mul_dpow\u271d\u00b9, dpow_comp := dpow_comp\u271d\u00b9 } =\n    { dpow := hI', dpow_null := h\u2080', dpow_zero := dpow_zero\u271d, dpow_one := dpow_one\u271d, dpow_mem := dpow_mem\u271d,\n      dpow_add := dpow_add\u271d, dpow_mul := dpow_mul\u271d, mul_dpow := mul_dpow\u271d, dpow_comp := dpow_comp\u271d }"}, {"line": "simp only [mk.injEq]", "tactic_state": "case mk.mk\nA : Type u_1\ninst\u271d : CommSemiring A\nI : Ideal A\nhI : \u2115 \u2192 A \u2192 A\nh\u2080 : \u2200 {n : \u2115} {x : A}, x \u2209 I \u2192 hI n x = 0\ndpow_zero\u271d\u00b9 : \u2200 {x : A}, x \u2208 I \u2192 hI 0 x = 1\ndpow_one\u271d\u00b9 : \u2200 {x : A}, x \u2208 I \u2192 hI 1 x = x\ndpow_mem\u271d\u00b9 : \u2200 {n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI n x \u2208 I\ndpow_add\u271d\u00b9 : \u2200 {n : \u2115} {x y : A}, x \u2208 I \u2192 y \u2208 I \u2192 hI n (x + y) = \u2211 k \u2208 antidiagonal n, hI k.1 x * hI k.2 y\ndpow_mul\u271d\u00b9 : \u2200 {n : \u2115} {a x : A}, x \u2208 I \u2192 hI n (a * x) = a ^ n * hI n x\nmul_dpow\u271d\u00b9 : \u2200 {m n : \u2115} {x : A}, x \u2208 I \u2192 hI m x * hI n x = \u2191((m + n).choose m) * hI (m + n) x\ndpow_comp\u271d\u00b9 : \u2200 {m n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI m (hI n x) = \u2191(m.uniformBell n) * hI (m * n) x\nhI' : \u2115 \u2192 A \u2192 A\nh\u2080' : \u2200 {n : \u2115} {x : A}, x \u2209 I \u2192 hI' n x = 0\ndpow_zero\u271d : \u2200 {x : A}, x \u2208 I \u2192 hI' 0 x = 1\ndpow_one\u271d : \u2200 {x : A}, x \u2208 I \u2192 hI' 1 x = x\ndpow_mem\u271d : \u2200 {n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI' n x \u2208 I\ndpow_add\u271d : \u2200 {n : \u2115} {x y : A}, x \u2208 I \u2192 y \u2208 I \u2192 hI' n (x + y) = \u2211 k \u2208 antidiagonal n, hI' k.1 x * hI' k.2 y\ndpow_mul\u271d : \u2200 {n : \u2115} {a x : A}, x \u2208 I \u2192 hI' n (a * x) = a ^ n * hI' n x\nmul_dpow\u271d : \u2200 {m n : \u2115} {x : A}, x \u2208 I \u2192 hI' m x * hI' n x = \u2191((m + n).choose m) * hI' (m + n) x\ndpow_comp\u271d : \u2200 {m n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI' m (hI' n x) = \u2191(m.uniformBell n) * hI' (m * n) x\nh_eq :\n  \u2200 (n : \u2115) {x : A},\n    x \u2208 I \u2192\n      { dpow := hI, dpow_null := h\u2080, dpow_zero := dpow_zero\u271d\u00b9, dpow_one := dpow_one\u271d\u00b9, dpow_mem := dpow_mem\u271d\u00b9,\n              dpow_add := dpow_add\u271d\u00b9, dpow_mul := dpow_mul\u271d\u00b9, mul_dpow := mul_dpow\u271d\u00b9, dpow_comp := dpow_comp\u271d\u00b9 }.dpow\n          n x =\n        { dpow := hI', dpow_null := h\u2080', dpow_zero := dpow_zero\u271d, dpow_one := dpow_one\u271d, dpow_mem := dpow_mem\u271d,\n              dpow_add := dpow_add\u271d, dpow_mul := dpow_mul\u271d, mul_dpow := mul_dpow\u271d, dpow_comp := dpow_comp\u271d }.dpow\n          n x\n\u22a2 hI = hI'"}, {"line": "ext n x", "tactic_state": "case mk.mk.h.h\nA : Type u_1\ninst\u271d : CommSemiring A\nI : Ideal A\nhI : \u2115 \u2192 A \u2192 A\nh\u2080 : \u2200 {n : \u2115} {x : A}, x \u2209 I \u2192 hI n x = 0\ndpow_zero\u271d\u00b9 : \u2200 {x : A}, x \u2208 I \u2192 hI 0 x = 1\ndpow_one\u271d\u00b9 : \u2200 {x : A}, x \u2208 I \u2192 hI 1 x = x\ndpow_mem\u271d\u00b9 : \u2200 {n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI n x \u2208 I\ndpow_add\u271d\u00b9 : \u2200 {n : \u2115} {x y : A}, x \u2208 I \u2192 y \u2208 I \u2192 hI n (x + y) = \u2211 k \u2208 antidiagonal n, hI k.1 x * hI k.2 y\ndpow_mul\u271d\u00b9 : \u2200 {n : \u2115} {a x : A}, x \u2208 I \u2192 hI n (a * x) = a ^ n * hI n x\nmul_dpow\u271d\u00b9 : \u2200 {m n : \u2115} {x : A}, x \u2208 I \u2192 hI m x * hI n x = \u2191((m + n).choose m) * hI (m + n) x\ndpow_comp\u271d\u00b9 : \u2200 {m n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI m (hI n x) = \u2191(m.uniformBell n) * hI (m * n) x\nhI' : \u2115 \u2192 A \u2192 A\nh\u2080' : \u2200 {n : \u2115} {x : A}, x \u2209 I \u2192 hI' n x = 0\ndpow_zero\u271d : \u2200 {x : A}, x \u2208 I \u2192 hI' 0 x = 1\ndpow_one\u271d : \u2200 {x : A}, x \u2208 I \u2192 hI' 1 x = x\ndpow_mem\u271d : \u2200 {n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI' n x \u2208 I\ndpow_add\u271d : \u2200 {n : \u2115} {x y : A}, x \u2208 I \u2192 y \u2208 I \u2192 hI' n (x + y) = \u2211 k \u2208 antidiagonal n, hI' k.1 x * hI' k.2 y\ndpow_mul\u271d : \u2200 {n : \u2115} {a x : A}, x \u2208 I \u2192 hI' n (a * x) = a ^ n * hI' n x\nmul_dpow\u271d : \u2200 {m n : \u2115} {x : A}, x \u2208 I \u2192 hI' m x * hI' n x = \u2191((m + n).choose m) * hI' (m + n) x\ndpow_comp\u271d : \u2200 {m n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI' m (hI' n x) = \u2191(m.uniformBell n) * hI' (m * n) x\nh_eq :\n  \u2200 (n : \u2115) {x : A},\n    x \u2208 I \u2192\n      { dpow := hI, dpow_null := h\u2080, dpow_zero := dpow_zero\u271d\u00b9, dpow_one := dpow_one\u271d\u00b9, dpow_mem := dpow_mem\u271d\u00b9,\n              dpow_add := dpow_add\u271d\u00b9, dpow_mul := dpow_mul\u271d\u00b9, mul_dpow := mul_dpow\u271d\u00b9, dpow_comp := dpow_comp\u271d\u00b9 }.dpow\n          n x =\n        { dpow := hI', dpow_null := h\u2080', dpow_zero := dpow_zero\u271d, dpow_one := dpow_one\u271d, dpow_mem := dpow_mem\u271d,\n              dpow_add := dpow_add\u271d, dpow_mul := dpow_mul\u271d, mul_dpow := mul_dpow\u271d, dpow_comp := dpow_comp\u271d }.dpow\n          n x\nn : \u2115\nx : A\n\u22a2 hI n x = hI' n x"}, {"line": "by_cases hx : x \u2208 I", "tactic_state": "case pos\nA : Type u_1\ninst\u271d : CommSemiring A\nI : Ideal A\nhI : \u2115 \u2192 A \u2192 A\nh\u2080 : \u2200 {n : \u2115} {x : A}, x \u2209 I \u2192 hI n x = 0\ndpow_zero\u271d\u00b9 : \u2200 {x : A}, x \u2208 I \u2192 hI 0 x = 1\ndpow_one\u271d\u00b9 : \u2200 {x : A}, x \u2208 I \u2192 hI 1 x = x\ndpow_mem\u271d\u00b9 : \u2200 {n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI n x \u2208 I\ndpow_add\u271d\u00b9 : \u2200 {n : \u2115} {x y : A}, x \u2208 I \u2192 y \u2208 I \u2192 hI n (x + y) = \u2211 k \u2208 antidiagonal n, hI k.1 x * hI k.2 y\ndpow_mul\u271d\u00b9 : \u2200 {n : \u2115} {a x : A}, x \u2208 I \u2192 hI n (a * x) = a ^ n * hI n x\nmul_dpow\u271d\u00b9 : \u2200 {m n : \u2115} {x : A}, x \u2208 I \u2192 hI m x * hI n x = \u2191((m + n).choose m) * hI (m + n) x\ndpow_comp\u271d\u00b9 : \u2200 {m n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI m (hI n x) = \u2191(m.uniformBell n) * hI (m * n) x\nhI' : \u2115 \u2192 A \u2192 A\nh\u2080' : \u2200 {n : \u2115} {x : A}, x \u2209 I \u2192 hI' n x = 0\ndpow_zero\u271d : \u2200 {x : A}, x \u2208 I \u2192 hI' 0 x = 1\ndpow_one\u271d : \u2200 {x : A}, x \u2208 I \u2192 hI' 1 x = x\ndpow_mem\u271d : \u2200 {n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI' n x \u2208 I\ndpow_add\u271d : \u2200 {n : \u2115} {x y : A}, x \u2208 I \u2192 y \u2208 I \u2192 hI' n (x + y) = \u2211 k \u2208 antidiagonal n, hI' k.1 x * hI' k.2 y\ndpow_mul\u271d : \u2200 {n : \u2115} {a x : A}, x \u2208 I \u2192 hI' n (a * x) = a ^ n * hI' n x\nmul_dpow\u271d : \u2200 {m n : \u2115} {x : A}, x \u2208 I \u2192 hI' m x * hI' n x = \u2191((m + n).choose m) * hI' (m + n) x\ndpow_comp\u271d : \u2200 {m n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI' m (hI' n x) = \u2191(m.uniformBell n) * hI' (m * n) x\nh_eq :\n  \u2200 (n : \u2115) {x : A},\n    x \u2208 I \u2192\n      { dpow := hI, dpow_null := h\u2080, dpow_zero := dpow_zero\u271d\u00b9, dpow_one := dpow_one\u271d\u00b9, dpow_mem := dpow_mem\u271d\u00b9,\n              dpow_add := dpow_add\u271d\u00b9, dpow_mul := dpow_mul\u271d\u00b9, mul_dpow := mul_dpow\u271d\u00b9, dpow_comp := dpow_comp\u271d\u00b9 }.dpow\n          n x =\n        { dpow := hI', dpow_null := h\u2080', dpow_zero := dpow_zero\u271d, dpow_one := dpow_one\u271d, dpow_mem := dpow_mem\u271d,\n              dpow_add := dpow_add\u271d, dpow_mul := dpow_mul\u271d, mul_dpow := mul_dpow\u271d, dpow_comp := dpow_comp\u271d }.dpow\n          n x\nn : \u2115\nx : A\nhx : x \u2208 I\n\u22a2 hI n x = hI' n x\n---\ncase neg\nA : Type u_1\ninst\u271d : CommSemiring A\nI : Ideal A\nhI : \u2115 \u2192 A \u2192 A\nh\u2080 : \u2200 {n : \u2115} {x : A}, x \u2209 I \u2192 hI n x = 0\ndpow_zero\u271d\u00b9 : \u2200 {x : A}, x \u2208 I \u2192 hI 0 x = 1\ndpow_one\u271d\u00b9 : \u2200 {x : A}, x \u2208 I \u2192 hI 1 x = x\ndpow_mem\u271d\u00b9 : \u2200 {n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI n x \u2208 I\ndpow_add\u271d\u00b9 : \u2200 {n : \u2115} {x y : A}, x \u2208 I \u2192 y \u2208 I \u2192 hI n (x + y) = \u2211 k \u2208 antidiagonal n, hI k.1 x * hI k.2 y\ndpow_mul\u271d\u00b9 : \u2200 {n : \u2115} {a x : A}, x \u2208 I \u2192 hI n (a * x) = a ^ n * hI n x\nmul_dpow\u271d\u00b9 : \u2200 {m n : \u2115} {x : A}, x \u2208 I \u2192 hI m x * hI n x = \u2191((m + n).choose m) * hI (m + n) x\ndpow_comp\u271d\u00b9 : \u2200 {m n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI m (hI n x) = \u2191(m.uniformBell n) * hI (m * n) x\nhI' : \u2115 \u2192 A \u2192 A\nh\u2080' : \u2200 {n : \u2115} {x : A}, x \u2209 I \u2192 hI' n x = 0\ndpow_zero\u271d : \u2200 {x : A}, x \u2208 I \u2192 hI' 0 x = 1\ndpow_one\u271d : \u2200 {x : A}, x \u2208 I \u2192 hI' 1 x = x\ndpow_mem\u271d : \u2200 {n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI' n x \u2208 I\ndpow_add\u271d : \u2200 {n : \u2115} {x y : A}, x \u2208 I \u2192 y \u2208 I \u2192 hI' n (x + y) = \u2211 k \u2208 antidiagonal n, hI' k.1 x * hI' k.2 y\ndpow_mul\u271d : \u2200 {n : \u2115} {a x : A}, x \u2208 I \u2192 hI' n (a * x) = a ^ n * hI' n x\nmul_dpow\u271d : \u2200 {m n : \u2115} {x : A}, x \u2208 I \u2192 hI' m x * hI' n x = \u2191((m + n).choose m) * hI' (m + n) x\ndpow_comp\u271d : \u2200 {m n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI' m (hI' n x) = \u2191(m.uniformBell n) * hI' (m * n) x\nh_eq :\n  \u2200 (n : \u2115) {x : A},\n    x \u2208 I \u2192\n      { dpow := hI, dpow_null := h\u2080, dpow_zero := dpow_zero\u271d\u00b9, dpow_one := dpow_one\u271d\u00b9, dpow_mem := dpow_mem\u271d\u00b9,\n              dpow_add := dpow_add\u271d\u00b9, dpow_mul := dpow_mul\u271d\u00b9, mul_dpow := mul_dpow\u271d\u00b9, dpow_comp := dpow_comp\u271d\u00b9 }.dpow\n          n x =\n        { dpow := hI', dpow_null := h\u2080', dpow_zero := dpow_zero\u271d, dpow_one := dpow_one\u271d, dpow_mem := dpow_mem\u271d,\n              dpow_add := dpow_add\u271d, dpow_mul := dpow_mul\u271d, mul_dpow := mul_dpow\u271d, dpow_comp := dpow_comp\u271d }.dpow\n          n x\nn : \u2115\nx : A\nhx : x \u2209 I\n\u22a2 hI n x = hI' n x"}, {"line": "\u00b7 exact h_eq n hx", "tactic_state": "case neg\nA : Type u_1\ninst\u271d : CommSemiring A\nI : Ideal A\nhI : \u2115 \u2192 A \u2192 A\nh\u2080 : \u2200 {n : \u2115} {x : A}, x \u2209 I \u2192 hI n x = 0\ndpow_zero\u271d\u00b9 : \u2200 {x : A}, x \u2208 I \u2192 hI 0 x = 1\ndpow_one\u271d\u00b9 : \u2200 {x : A}, x \u2208 I \u2192 hI 1 x = x\ndpow_mem\u271d\u00b9 : \u2200 {n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI n x \u2208 I\ndpow_add\u271d\u00b9 : \u2200 {n : \u2115} {x y : A}, x \u2208 I \u2192 y \u2208 I \u2192 hI n (x + y) = \u2211 k \u2208 antidiagonal n, hI k.1 x * hI k.2 y\ndpow_mul\u271d\u00b9 : \u2200 {n : \u2115} {a x : A}, x \u2208 I \u2192 hI n (a * x) = a ^ n * hI n x\nmul_dpow\u271d\u00b9 : \u2200 {m n : \u2115} {x : A}, x \u2208 I \u2192 hI m x * hI n x = \u2191((m + n).choose m) * hI (m + n) x\ndpow_comp\u271d\u00b9 : \u2200 {m n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI m (hI n x) = \u2191(m.uniformBell n) * hI (m * n) x\nhI' : \u2115 \u2192 A \u2192 A\nh\u2080' : \u2200 {n : \u2115} {x : A}, x \u2209 I \u2192 hI' n x = 0\ndpow_zero\u271d : \u2200 {x : A}, x \u2208 I \u2192 hI' 0 x = 1\ndpow_one\u271d : \u2200 {x : A}, x \u2208 I \u2192 hI' 1 x = x\ndpow_mem\u271d : \u2200 {n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI' n x \u2208 I\ndpow_add\u271d : \u2200 {n : \u2115} {x y : A}, x \u2208 I \u2192 y \u2208 I \u2192 hI' n (x + y) = \u2211 k \u2208 antidiagonal n, hI' k.1 x * hI' k.2 y\ndpow_mul\u271d : \u2200 {n : \u2115} {a x : A}, x \u2208 I \u2192 hI' n (a * x) = a ^ n * hI' n x\nmul_dpow\u271d : \u2200 {m n : \u2115} {x : A}, x \u2208 I \u2192 hI' m x * hI' n x = \u2191((m + n).choose m) * hI' (m + n) x\ndpow_comp\u271d : \u2200 {m n : \u2115} {x : A}, n \u2260 0 \u2192 x \u2208 I \u2192 hI' m (hI' n x) = \u2191(m.uniformBell n) * hI' (m * n) x\nh_eq :\n  \u2200 (n : \u2115) {x : A},\n    x \u2208 I \u2192\n      { dpow := hI, dpow_null := h\u2080, dpow_zero := dpow_zero\u271d\u00b9, dpow_one := dpow_one\u271d\u00b9, dpow_mem := dpow_mem\u271d\u00b9,\n              dpow_add := dpow_add\u271d\u00b9, dpow_mul := dpow_mul\u271d\u00b9, mul_dpow := mul_dpow\u271d\u00b9, dpow_comp := dpow_comp\u271d\u00b9 }.dpow\n          n x =\n        { dpow := hI', dpow_null := h\u2080', dpow_zero := dpow_zero\u271d, dpow_one := dpow_one\u271d, dpow_mem := dpow_mem\u271d,\n              dpow_add := dpow_add\u271d, dpow_mul := dpow_mul\u271d, mul_dpow := mul_dpow\u271d, dpow_comp := dpow_comp\u271d }.dpow\n          n x\nn : \u2115\nx : A\nhx : x \u2209 I\n\u22a2 hI n x = hI' n x"}, {"line": "\u00b7 rw [h\u2080 hx, h\u2080' hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofRingEquiv_dpow_apply (hI : DividedPowers I) {n : \u2115} {a : A} :\n    (ofRingEquiv h hI).dpow n (e a) = e (hI.dpow n a) := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/DividedPowers/Basic.lean", "context": {"open": ["Finset Nat Ideal"], "variables": ["{A : Type*} [CommSemiring A] (I : Ideal A)", "(A) in", "{I} in", "{A : Type*} [CommSemiring A] {I : Ideal A} {a b : A}", "(hI : DividedPowers I)", "{A B : Type*} [CommSemiring A] {I : Ideal A} [CommSemiring B] {J : Ideal B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\ninst\u271d : CommSemiring A\nI : Ideal A\nx\u271d\u00b9 : Sort u_4\nofRingEquiv : x\u271d\u00b9\nx\u271d : Sort u_5\ne : x\u271d\nhI : DividedPowers I\nn : \u2115\na : A\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "A : Type u_2\ninst\u271d : CommSemiring A\nI : Ideal A\nx\u271d\u00b9 : Sort u_4\nofRingEquiv : x\u271d\u00b9\nx\u271d : Sort u_5\ne : x\u271d\nhI : DividedPowers I\nn : \u2115\na : A\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem fg_induction (R M : Type*) [Semiring R] [AddCommMonoid M] [Module R M]\n    (P : Submodule R M \u2192 Prop) (h\u2081 : \u2200 x, P (Submodule.span R {x}))\n    (h\u2082 : \u2200 M\u2081 M\u2082, P M\u2081 \u2192 P M\u2082 \u2192 P (M\u2081 \u2294 M\u2082)) (N : Submodule R M) (hN : N.FG) : P N := by\n  classical\n    obtain \u27e8s, rfl\u27e9 := hN\n    induction s using Finset.induction with\n    | empty =>\n      rw [Finset.coe_empty]\n      rw [Submodule.span_empty]\n      rw [\u2190 Submodule.span_zero_singleton]\n      exact h\u2081 _\n    | insert _ _ _ ih =>\n      rw [Finset.coe_insert]\n      rw [Submodule.span_insert]\n      exact h\u2082 _ _ (h\u2081 _) ih\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Finiteness/Basic.lean", "context": {"open": ["Function (Surjective)", "Finsupp", "Set"], "variables": ["{R : Type*} {M : Type*} [Semiring R] [AddCommMonoid M] [Module R M]", "{S P : Type*} [Semiring S] [AddCommMonoid P] [Module S P]", "{\u03c3 : R \u2192+* S} [RingHomSurjective \u03c3] (f : M \u2192\u209b\u2097[\u03c3] P)", "{P : Type*} [AddCommMonoid P] [Module R P]", "{f : M \u2192\u2097[R] P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\nM : Type u_7\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nP : Submodule R M \u2192 Prop\nh\u2081 : \u2200 (x : M), P (Submodule.span R {x})\nh\u2082 : \u2200 (M\u2081 M\u2082 : Submodule R M), P M\u2081 \u2192 P M\u2082 \u2192 P (M\u2081 \u2294 M\u2082)\nN : Submodule R M\nhN : N.FG\n\u22a2 P N"}, {"line": "classical\n    obtain \u27e8s, rfl\u27e9 := hN\n    induction s using Finset.induction with\n    | empty =>\n      rw [Finset.coe_empty]\n      rw [Submodule.span_empty]\n      rw [\u2190 Submodule.span_zero_singleton]\n      exact h\u2081 _\n    | insert _ _ _ ih =>\n      rw [Finset.coe_insert]\n      rw [Submodule.span_insert]\n      exact h\u2082 _ _ (h\u2081 _) ih", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fg_restrictScalars {R S M : Type*} [CommSemiring R] [Semiring S] [Algebra R S]\n    [AddCommMonoid M] [Module S M] [Module R M] [IsScalarTower R S M] (N : Submodule S M)\n    (hfin : N.FG) (h : Function.Surjective (algebraMap R S)) :\n    (Submodule.restrictScalars R N).FG := by\n  obtain \u27e8X, rfl\u27e9 := hfin\n  use X\n  exact (Submodule.restrictScalars_span R S h (X : Set M)).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Finiteness/Basic.lean", "context": {"open": ["Function (Surjective)", "Finsupp", "Set"], "variables": ["{R : Type*} {M : Type*} [Semiring R] [AddCommMonoid M] [Module R M]", "{S P : Type*} [Semiring S] [AddCommMonoid P] [Module S P]", "{\u03c3 : R \u2192+* S} [RingHomSurjective \u03c3] (f : M \u2192\u209b\u2097[\u03c3] P)", "{P : Type*} [AddCommMonoid P] [Module R P]", "{f : M \u2192\u2097[R] P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\nS : Type u_7\nM : Type u_8\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring S\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module S M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsScalarTower R S M\nN : Submodule S M\nhfin : N.FG\nh : Surjective \u21d1(algebraMap R S)\n\u22a2 (Submodule.restrictScalars R N).FG"}, {"line": "obtain \u27e8X, rfl\u27e9 := hfin", "tactic_state": "case intro\nR : Type u_6\nS : Type u_7\nM : Type u_8\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring S\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module S M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsScalarTower R S M\nh : Surjective \u21d1(algebraMap R S)\nX : Finset M\n\u22a2 (Submodule.restrictScalars R (Submodule.span S \u2191X)).FG"}, {"line": "use X", "tactic_state": "case h\nR : Type u_6\nS : Type u_7\nM : Type u_8\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring S\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module S M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsScalarTower R S M\nh : Surjective \u21d1(algebraMap R S)\nX : Finset M\n\u22a2 Submodule.span R \u2191X = Submodule.restrictScalars R (Submodule.span S \u2191X)"}, {"line": "exact (Submodule.restrictScalars_span R S h (X : Set M)).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem small_span [Small.{u} R] (s : Set M) [Small.{u} s] :\n    Small.{u} (span R s) := by\n  suffices span R s = iSup (fun i : s \u21a6 span R ({(\u2191i : M)} : Set M)) by\n    rw [this]\n    apply small_iSup\n  simp [\u2190 Submodule.span_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Finiteness/Small.lean", "context": {"open": [], "variables": ["{R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M]", "(R M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nx\u271d : Sort u_3\nspan : x\u271d\ninst\u271d\u00b9 : Small.{u, u_1} R\ns : Set M\ninst\u271d : Small.{u, u_2} \u2191s\n\u22a2 Small.{u, u_4} sorry"}, {"line": "suffices span R s = iSup (fun i : s \u21a6 span R ({(\u2191i : M)} : Set M)) by\n    rw [this]\n    apply small_iSup", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nx\u271d : Sort u_3\nspan : x\u271d\ninst\u271d\u00b9 : Small.{u, u_1} R\ns : Set M\ninst\u271d : Small.{u, u_2} \u2191s\n\u22a2 sorry = \u2a06 i, sorry"}, {"line": "simp [\u2190 Submodule.span_iUnion]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nx\u271d : Sort u_3\nspan : x\u271d\ninst\u271d\u00b9 : Small.{u, u_1} R\ns : Set M\ninst\u271d : Small.{u, u_2} \u2191s\n\u22a2 sorry () = \u2a06 i, sorry ()"}]}
{"declaration": "theorem FG.map {R S : Type*} [Semiring R] [Semiring S] {I : Ideal R} (h : I.FG) (f : R \u2192+* S) :\n    (I.map f).FG := by\n  classical\n    obtain \u27e8s, hs\u27e9 := h\n    refine \u27e8s.image f, ?_\u27e9\n    rw [Finset.coe_image]\n    rw [\u2190 Ideal.map_span]\n    rw [hs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Finiteness/Ideal.lean", "context": {"open": ["Function (Surjective)", "Finsupp"], "variables": ["{R : Type*} {M : Type*} [Semiring R] [AddCommMonoid M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nI : Ideal R\nh : I.FG\nf : R \u2192+* S\n\u22a2 (Ideal.map f I).FG"}, {"line": "classical\n    obtain \u27e8s, hs\u27e9 := h\n    refine \u27e8s.image f, ?_\u27e9\n    rw [Finset.coe_image]\n    rw [\u2190 Ideal.map_span]\n    rw [hs]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iff_lTensor_injective' :\n    Flat R M \u2194 \u2200 (I : Ideal R), Function.Injective (lTensor M I.subtype) := by\n  simpa [\u2190 comm_comp_rTensor_comp_comm_eq] using iff_rTensor_injective'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Flat/Basic.lean", "context": {"open": ["TensorProduct", "Function (Surjective)", "LinearMap Submodule DirectSum"], "variables": ["{R : Type u} {M : Type v} {N P Q : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "(R M) in", "{\u03b9 : Type v} {M : \u03b9 \u2192 Type w} [\u03a0 i, AddCommMonoid (M i)] [\u03a0 i, Module R (M i)]", "{R : Type u} {M : Type v} [CommRing R] [AddCommGroup M] [Module R M]", "{N : Type w} [AddCommGroup N] [Module R N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx\u271d : Sort u_4\nFlat : x\u271d\n\u22a2 sorry \u2194 \u2200 (I : Ideal R), Function.Injective \u21d1(lTensor M (Submodule.subtype I))"}, {"line": "simpa [\u2190 comm_comp_rTensor_comp_comm_eq] using iff_rTensor_injective'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iff_lTensor_injective :\n    Flat R M \u2194 \u2200 \u2983I : Ideal R\u2984, I.FG \u2192 Function.Injective (I.subtype.lTensor M) := by\n  simpa [\u2190 comm_comp_rTensor_comp_comm_eq] using iff_rTensor_injective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Flat/Basic.lean", "context": {"open": ["TensorProduct", "Function (Surjective)", "LinearMap Submodule DirectSum"], "variables": ["{R : Type u} {M : Type v} {N P Q : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "(R M) in", "{\u03b9 : Type v} {M : \u03b9 \u2192 Type w} [\u03a0 i, AddCommMonoid (M i)] [\u03a0 i, Module R (M i)]", "{R : Type u} {M : Type v} [CommRing R] [AddCommGroup M] [Module R M]", "{N : Type w} [AddCommGroup N] [Module R N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx\u271d : Sort u_4\nFlat : x\u271d\n\u22a2 sorry \u2194 \u2200 \u2983I : Ideal R\u2984, I.FG \u2192 Function.Injective \u21d1(lTensor M (Submodule.subtype I))"}, {"line": "simpa [\u2190 comm_comp_rTensor_comp_comm_eq] using iff_rTensor_injective", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iff_lift_lsmul_comp_subtype_injective : Flat R M \u2194 \u2200 \u2983I : Ideal R\u2984, I.FG \u2192\n    Function.Injective (TensorProduct.lift ((lsmul R M).comp I.subtype)) := by\n  simp [iff_rTensor_injective, \u2190 lid_comp_rTensor]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Flat/Basic.lean", "context": {"open": ["TensorProduct", "Function (Surjective)", "LinearMap Submodule DirectSum"], "variables": ["{R : Type u} {M : Type v} {N P Q : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "(R M) in", "{\u03b9 : Type v} {M : \u03b9 \u2192 Type w} [\u03a0 i, AddCommMonoid (M i)] [\u03a0 i, Module R (M i)]", "{R : Type u} {M : Type v} [CommRing R] [AddCommGroup M] [Module R M]", "{N : Type w} [AddCommGroup N] [Module R N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx\u271d : Sort u_4\nFlat : x\u271d\n\u22a2 sorry \u2194 \u2200 \u2983I : Ideal R\u2984, I.FG \u2192 Function.Injective \u21d1(lift (lsmul R M \u2218\u2097 Submodule.subtype I))"}, {"line": "simp [iff_rTensor_injective, \u2190 lid_comp_rTensor]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx\u271d : Sort u_4\nFlat : x\u271d\n\u22a2 sorry () \u2194 \u2200 \u2983I : Ideal R\u2984, I.FG \u2192 Function.Injective \u21d1(rTensor M (Submodule.subtype I))"}]}
{"declaration": "lemma map_injective_of_flat_flat\n    (f : P \u2192\u2097[R] M) (g : Q \u2192\u2097[R] N) [Module.Flat R M] [Module.Flat R Q]\n    (hf : Function.Injective f) (hg : Function.Injective g) :\n    Function.Injective (TensorProduct.map f g) := by\n  rw [\u2190 LinearMap.lTensor_comp_rTensor]\n  exact (Module.Flat.lTensor_preserves_injective_linearMap g hg).comp\n    (Module.Flat.rTensor_preserves_injective_linearMap f hf)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Flat/Basic.lean", "context": {"open": ["TensorProduct", "Function (Surjective)", "LinearMap Submodule DirectSum"], "variables": ["{R : Type u} {M : Type v} {N P Q : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "(R M) in", "{\u03b9 : Type v} {M : \u03b9 \u2192 Type w} [\u03a0 i, AddCommMonoid (M i)] [\u03a0 i, Module R (M i)]", "{R : Type u} {M : Type v} [CommRing R] [AddCommGroup M] [Module R M]", "{N : Type w} [AddCommGroup N] [Module R N]", "(M) in", "(M) in", "{R S A B : Type*} [CommSemiring R] [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]", "(R : Type*) [CommSemiring R]", "(M N : Type*) [AddCommMonoid M] [AddCommMonoid N] [Module R M] [Module R N]", "{R M N}", "{P Q : Type*} [AddCommMonoid P] [Module R P] [AddCommMonoid Q] [Module R Q]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d\u00b9\u2070 : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : AddCommMonoid N\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R N\nP : Type u_7\nQ : Type u_8\ninst\u271d\u2075 : AddCommMonoid P\ninst\u271d\u2074 : Module R P\ninst\u271d\u00b3 : AddCommMonoid Q\ninst\u271d\u00b2 : Module R Q\nf : P \u2192\u2097[R] M\ng : Q \u2192\u2097[R] N\ninst\u271d\u00b9 : Module.Flat R M\ninst\u271d : Module.Flat R Q\nhf : Function.Injective \u21d1f\nhg : Function.Injective \u21d1g\n\u22a2 Function.Injective \u21d1(TensorProduct.map f g)"}, {"line": "rw [\u2190 LinearMap.lTensor_comp_rTensor]", "tactic_state": "R : Type u_4\ninst\u271d\u00b9\u2070 : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : AddCommMonoid N\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R N\nP : Type u_7\nQ : Type u_8\ninst\u271d\u2075 : AddCommMonoid P\ninst\u271d\u2074 : Module R P\ninst\u271d\u00b3 : AddCommMonoid Q\ninst\u271d\u00b2 : Module R Q\nf : P \u2192\u2097[R] M\ng : Q \u2192\u2097[R] N\ninst\u271d\u00b9 : Module.Flat R M\ninst\u271d : Module.Flat R Q\nhf : Function.Injective \u21d1f\nhg : Function.Injective \u21d1g\n\u22a2 Function.Injective \u21d1(lTensor M g \u2218\u2097 rTensor Q f)"}, {"line": "exact (Module.Flat.lTensor_preserves_injective_linearMap g hg).comp\n    (Module.Flat.rTensor_preserves_injective_linearMap f hf)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_injective_of_flat_flat'\n    (f : P \u2192\u2097[R] M) (g : Q \u2192\u2097[R] N) [Module.Flat R P] [Module.Flat R N]\n    (hf : Function.Injective f) (hg : Function.Injective g) :\n    Function.Injective (TensorProduct.map f g) := by\n  rw [\u2190 LinearMap.rTensor_comp_lTensor]\n  exact (Module.Flat.rTensor_preserves_injective_linearMap f hf).comp\n    (Module.Flat.lTensor_preserves_injective_linearMap g hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Flat/Basic.lean", "context": {"open": ["TensorProduct", "Function (Surjective)", "LinearMap Submodule DirectSum"], "variables": ["{R : Type u} {M : Type v} {N P Q : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]", "(R M) in", "{\u03b9 : Type v} {M : \u03b9 \u2192 Type w} [\u03a0 i, AddCommMonoid (M i)] [\u03a0 i, Module R (M i)]", "{R : Type u} {M : Type v} [CommRing R] [AddCommGroup M] [Module R M]", "{N : Type w} [AddCommGroup N] [Module R N]", "(M) in", "(M) in", "{R S A B : Type*} [CommSemiring R] [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]", "(R : Type*) [CommSemiring R]", "(M N : Type*) [AddCommMonoid M] [AddCommMonoid N] [Module R M] [Module R N]", "{R M N}", "{P Q : Type*} [AddCommMonoid P] [Module R P] [AddCommMonoid Q] [Module R Q]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d\u00b9\u2070 : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : AddCommMonoid N\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R N\nP : Type u_7\nQ : Type u_8\ninst\u271d\u2075 : AddCommMonoid P\ninst\u271d\u2074 : Module R P\ninst\u271d\u00b3 : AddCommMonoid Q\ninst\u271d\u00b2 : Module R Q\nf : P \u2192\u2097[R] M\ng : Q \u2192\u2097[R] N\ninst\u271d\u00b9 : Module.Flat R P\ninst\u271d : Module.Flat R N\nhf : Function.Injective \u21d1f\nhg : Function.Injective \u21d1g\n\u22a2 Function.Injective \u21d1(TensorProduct.map f g)"}, {"line": "rw [\u2190 LinearMap.rTensor_comp_lTensor]", "tactic_state": "R : Type u_4\ninst\u271d\u00b9\u2070 : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : AddCommMonoid N\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R N\nP : Type u_7\nQ : Type u_8\ninst\u271d\u2075 : AddCommMonoid P\ninst\u271d\u2074 : Module R P\ninst\u271d\u00b3 : AddCommMonoid Q\ninst\u271d\u00b2 : Module R Q\nf : P \u2192\u2097[R] M\ng : Q \u2192\u2097[R] N\ninst\u271d\u00b9 : Module.Flat R P\ninst\u271d : Module.Flat R N\nhf : Function.Injective \u21d1f\nhg : Function.Injective \u21d1g\n\u22a2 Function.Injective \u21d1(rTensor N f \u2218\u2097 lTensor P g)"}, {"line": "exact (Module.Flat.rTensor_preserves_injective_linearMap f hf).comp\n    (Module.Flat.lTensor_preserves_injective_linearMap g hg)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeIdeal_mul (I J : Ideal R) : (\u2191(I * J) : FractionalIdeal S P) = I * J := by\n  simp only [mul_def]\n  exact coeToSubmodule_injective (coeSubmodule_mul _ _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/FractionalIdeal/Basic.lean", "context": {"open": ["IsLocalization Pointwise nonZeroDivisors", "Set Submodule"], "variables": ["{R : Type*} [CommRing R] {S : Submonoid R} {P : Type*} [CommRing P]", "[Algebra R P]", "(S)", "(P)", "{R : Type*} [CommRing R] {S : Submonoid R} {P : Type*} [CommRing P]", "[Algebra R P]", "(S)", "{S}", "[loc : IsLocalization S P]", "(P) in", "(S)", "{S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b2 : CommRing R\nS : Submonoid R\nP : Type u_4\ninst\u271d\u00b9 : CommRing P\ninst\u271d : Algebra R P\nloc : IsLocalization S P\nI J : Ideal R\n\u22a2 \u2191(I * J) = \u2191I * \u2191J"}, {"line": "simp only [mul_def]", "tactic_state": "R : Type u_3\ninst\u271d\u00b2 : CommRing R\nS : Submonoid R\nP : Type u_4\ninst\u271d\u00b9 : CommRing P\ninst\u271d : Algebra R P\nloc : IsLocalization S P\nI J : Ideal R\n\u22a2 \u2191(span R (\u2191I * \u2191J)) = \u2191I * \u2191J"}, {"line": "exact coeToSubmodule_injective (coeSubmodule_mul _ _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma fg_of_isNoetherianRing [hR : IsNoetherianRing R] (hS : S \u2264 R\u2070) (I : FractionalIdeal S P) :\n    FG I.coeToSubmodule := by\n  have := hR.noetherian I.num\n  rw [\u2190 fg_top] at this \u22a2\n  exact fg_of_linearEquiv (I.equivNum <| coe_ne_zero \u27e8(I.den : R), hS (SetLike.coe_mem I.den)\u27e9) this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/FractionalIdeal/Basic.lean", "context": {"open": ["IsLocalization Pointwise nonZeroDivisors", "Set Submodule"], "variables": ["{R : Type*} [CommRing R] {S : Submonoid R} {P : Type*} [CommRing P]", "[Algebra R P]", "(S)", "(P)", "{R : Type*} [CommRing R] {S : Submonoid R} {P : Type*} [CommRing P]", "[Algebra R P]", "(S)", "{S}", "[loc : IsLocalization S P]", "(P) in", "(S)", "{S}", "(S P)", "{S P}", "(S P)", "{R : Type*} [CommRing R] [Nontrivial R] {S : Submonoid R}", "{P : Type*} [Nontrivial P] [CommRing P] [Algebra R P] [NoZeroSMulDivisors R P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : Nontrivial R\nS : Submonoid R\nP : Type u_6\ninst\u271d\u00b3 : Nontrivial P\ninst\u271d\u00b2 : CommRing P\ninst\u271d\u00b9 : Algebra R P\ninst\u271d : NoZeroSMulDivisors R P\nhR : IsNoetherianRing R\nhS : S \u2264 nonZeroDivisors R\nI : FractionalIdeal S P\n\u22a2 (\u2191I).FG"}, {"line": "have := hR.noetherian I.num", "tactic_state": "R : Type u_5\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : Nontrivial R\nS : Submonoid R\nP : Type u_6\ninst\u271d\u00b3 : Nontrivial P\ninst\u271d\u00b2 : CommRing P\ninst\u271d\u00b9 : Algebra R P\ninst\u271d : NoZeroSMulDivisors R P\nhR : IsNoetherianRing R\nhS : S \u2264 nonZeroDivisors R\nI : FractionalIdeal S P\nthis : sorry.FG\n\u22a2 (\u2191I).FG"}, {"line": "rw [\u2190 fg_top] at this \u22a2", "tactic_state": "R : Type u_5\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : Nontrivial R\nS : Submonoid R\nP : Type u_6\ninst\u271d\u00b3 : Nontrivial P\ninst\u271d\u00b2 : CommRing P\ninst\u271d\u00b9 : Algebra R P\ninst\u271d : NoZeroSMulDivisors R P\nhR : IsNoetherianRing R\nhS : S \u2264 nonZeroDivisors R\nI : FractionalIdeal S P\nthis : \u22a4.FG\n\u22a2 \u22a4.FG"}, {"line": "exact fg_of_linearEquiv (I.equivNum <| coe_ne_zero \u27e8(I.den : R), hS (SetLike.coe_mem I.den)\u27e9) this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem absNorm_one : absNorm (1 : FractionalIdeal R\u2070 K) = 1 := by convert absNorm.map_one'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/FractionalIdeal/Norm.lean", "context": {"open": ["scoped Pointwise nonZeroDivisors"], "variables": ["{R : Type*} [CommRing R] [IsDedekindDomain R] [Module.Free \u2124 R] [Module.Finite \u2124 R]", "{K : Type*} [CommRing K] [Algebra R K] [IsFractionRing R K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nabsNorm : x\u271d\n\u22a2 sorry = 1"}, {"line": "convert absNorm.map_one'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeIdeal_eq_one {I : Ideal R} : (I : FractionalIdeal R\u2070 K) = 1 \u2194 I = 1 := by\n  simpa only [Ideal.one_eq_top] using coeIdeal_inj\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/FractionalIdeal/Operations.lean", "context": {"open": ["IsLocalization Pointwise nonZeroDivisors", "Set Submodule"], "variables": ["{R : Type*} [CommRing R] {S : Submonoid R} {P : Type*} [CommRing P]", "[Algebra R P]", "{P' : Type*} [CommRing P'] [Algebra R P']", "{P'' : Type*} [CommRing P''] [Algebra R P'']", "(I J : FractionalIdeal S P) (g : P \u2192\u2090[R] P')", "(S) in", "(S P P')", "[IsLocalization S P] [IsLocalization S P']", "{K K' : Type*} [Field K] [Field K']", "[Algebra R K] [IsFractionRing R K] [Algebra R K'] [IsFractionRing R K']", "{I J : FractionalIdeal R\u2070 K} (h : K \u2192\u2090[R] K')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommRing R\nK : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\nI : Ideal R\n\u22a2 \u2191I = 1 \u2194 I = 1"}, {"line": "simpa only [Ideal.one_eq_top] using coeIdeal_inj", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_one_div (I : FractionalIdeal R\u2081\u2070 K) (h : K \u2243\u2090[R\u2081] K') :\n    (1 / I).map (h : K \u2192\u2090[R\u2081] K') = 1 / I.map h := by\n  rw [FractionalIdeal.map_div]\n  rw [FractionalIdeal.map_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/FractionalIdeal/Operations.lean", "context": {"open": ["IsLocalization Pointwise nonZeroDivisors", "Set Submodule", "Classical in"], "variables": ["{R : Type*} [CommRing R] {S : Submonoid R} {P : Type*} [CommRing P]", "[Algebra R P]", "{P' : Type*} [CommRing P'] [Algebra R P']", "{P'' : Type*} [CommRing P''] [Algebra R P'']", "(I J : FractionalIdeal S P) (g : P \u2192\u2090[R] P')", "(S) in", "(S P P')", "[IsLocalization S P] [IsLocalization S P']", "{K K' : Type*} [Field K] [Field K']", "[Algebra R K] [IsFractionRing R K] [Algebra R K'] [IsFractionRing R K']", "{I J : FractionalIdeal R\u2070 K} (h : K \u2192\u2090[R] K')", "{R\u2081 : Type*} [CommRing R\u2081] {K : Type*} [Field K]", "[Algebra R\u2081 K]", "[IsFractionRing R\u2081 K] [IsDomain R\u2081]", "{I J : FractionalIdeal R\u2081\u2070 K}", "{K' : Type*} [Field K'] [Algebra R\u2081 K'] [IsFractionRing R\u2081 K']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Submonoid ?m.106476\nP : Type ?u.106285\nR : Type ?u.107664\nP' : Type ?u.107662\nI\u271d\u00b2 : sorry\nJ\u271d\u00b9 : sorry\ng : sorry\nK\u271d\u00b9 : Type u_1\nK'\u271d\u00b9 : Type u_2\ninst\u271d\u00b9\u2077 : Field K\u271d\u00b9\ninst\u271d\u00b9\u2076 : Field K'\u271d\u00b9\nI\u271d\u00b9 : FractionalIdeal sorry K\u271d\u00b9\nJ\u271d : FractionalIdeal sorry K\u271d\u00b9\nh\u271d : sorry\nR\u2081\u271d : Type u_3\ninst\u271d\u00b9\u2075 : CommRing R\u2081\u271d\nK\u271d : Type u_4\ninst\u271d\u00b9\u2074 : Field K\u271d\ninst\u271d\u00b9\u00b3 : Algebra R\u2081\u271d K\u271d\ninst\u271d\u00b9\u00b2 : IsFractionRing R\u2081\u271d K\u271d\ninst\u271d\u00b9\u00b9 : IsDomain R\u2081\u271d\nI\u271d J : FractionalIdeal (nonZeroDivisors R\u2081\u271d) K\u271d\nK'\u271d : Type u_5\ninst\u271d\u00b9\u2070 : Field K'\u271d\ninst\u271d\u2079 : Algebra R\u2081\u271d K'\u271d\ninst\u271d\u2078 : IsFractionRing R\u2081\u271d K'\u271d\nR\u2081 : Type u_3\ninst\u271d\u2077 : CommRing R\u2081\nK : Type u_4\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R\u2081 K\ninst\u271d\u2074 : IsFractionRing R\u2081 K\ninst\u271d\u00b3 : IsDomain R\u2081\nK' : Type u_5\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R\u2081 K'\ninst\u271d : IsFractionRing R\u2081 K'\nI : FractionalIdeal (nonZeroDivisors R\u2081) K\nh : K \u2243\u2090[R\u2081] K'\n\u22a2 FractionalIdeal.map (\u2191h) (1 / I) = 1 / FractionalIdeal.map (\u2191h) I"}, {"line": "rw [FractionalIdeal.map_div]", "tactic_state": "S : Submonoid ?m.106476\nP : Type ?u.106285\nR : Type ?u.107664\nP' : Type ?u.107662\nI\u271d\u00b2 : sorry\nJ\u271d\u00b9 : sorry\ng : sorry\nK\u271d\u00b9 : Type u_1\nK'\u271d\u00b9 : Type u_2\ninst\u271d\u00b9\u2077 : Field K\u271d\u00b9\ninst\u271d\u00b9\u2076 : Field K'\u271d\u00b9\nI\u271d\u00b9 : FractionalIdeal sorry K\u271d\u00b9\nJ\u271d : FractionalIdeal sorry K\u271d\u00b9\nh\u271d : sorry\nR\u2081\u271d : Type u_3\ninst\u271d\u00b9\u2075 : CommRing R\u2081\u271d\nK\u271d : Type u_4\ninst\u271d\u00b9\u2074 : Field K\u271d\ninst\u271d\u00b9\u00b3 : Algebra R\u2081\u271d K\u271d\ninst\u271d\u00b9\u00b2 : IsFractionRing R\u2081\u271d K\u271d\ninst\u271d\u00b9\u00b9 : IsDomain R\u2081\u271d\nI\u271d J : FractionalIdeal (nonZeroDivisors R\u2081\u271d) K\u271d\nK'\u271d : Type u_5\ninst\u271d\u00b9\u2070 : Field K'\u271d\ninst\u271d\u2079 : Algebra R\u2081\u271d K'\u271d\ninst\u271d\u2078 : IsFractionRing R\u2081\u271d K'\u271d\nR\u2081 : Type u_3\ninst\u271d\u2077 : CommRing R\u2081\nK : Type u_4\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R\u2081 K\ninst\u271d\u2074 : IsFractionRing R\u2081 K\ninst\u271d\u00b3 : IsDomain R\u2081\nK' : Type u_5\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R\u2081 K'\ninst\u271d : IsFractionRing R\u2081 K'\nI : FractionalIdeal (nonZeroDivisors R\u2081) K\nh : K \u2243\u2090[R\u2081] K'\n\u22a2 FractionalIdeal.map (\u2191h) 1 / FractionalIdeal.map (\u2191h) I = 1 / FractionalIdeal.map (\u2191h) I\n---\nS : Submonoid ?m.106476\nP : Type ?u.106285\nR : Type ?u.107664\nP' : Type ?u.107662\nI\u271d\u00b2 : sorry\nJ\u271d\u00b9 : sorry\ng : sorry\nK\u271d\u00b9 : Type u_1\nK'\u271d\u00b9 : Type u_2\ninst\u271d\u00b9\u2077 : Field K\u271d\u00b9\ninst\u271d\u00b9\u2076 : Field K'\u271d\u00b9\nI\u271d\u00b9 : FractionalIdeal sorry K\u271d\u00b9\nJ\u271d : FractionalIdeal sorry K\u271d\u00b9\nh\u271d : sorry\nR\u2081\u271d : Type u_3\ninst\u271d\u00b9\u2075 : CommRing R\u2081\u271d\nK\u271d : Type u_4\ninst\u271d\u00b9\u2074 : Field K\u271d\ninst\u271d\u00b9\u00b3 : Algebra R\u2081\u271d K\u271d\ninst\u271d\u00b9\u00b2 : IsFractionRing R\u2081\u271d K\u271d\ninst\u271d\u00b9\u00b9 : IsDomain R\u2081\u271d\nI\u271d J : FractionalIdeal (nonZeroDivisors R\u2081\u271d) K\u271d\nK'\u271d : Type u_5\ninst\u271d\u00b9\u2070 : Field K'\u271d\ninst\u271d\u2079 : Algebra R\u2081\u271d K'\u271d\ninst\u271d\u2078 : IsFractionRing R\u2081\u271d K'\u271d\nR\u2081 : Type u_3\ninst\u271d\u2077 : CommRing R\u2081\nK : Type u_4\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra R\u2081 K\ninst\u271d\u2074 : IsFractionRing R\u2081 K\ninst\u271d\u00b3 : IsDomain R\u2081\nK' : Type u_5\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R\u2081 K'\ninst\u271d : IsFractionRing R\u2081 K'\nI : FractionalIdeal (nonZeroDivisors R\u2081) K\nh : K \u2243\u2090[R\u2081] K'\n\u22a2 IsFractionRing R\u2081 K'"}, {"line": "rw [FractionalIdeal.map_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem spanFinset_ne_zero {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 K} :\n    spanFinset R\u2081 s f \u2260 0 \u2194 \u2203 j \u2208 s, f j \u2260 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/FractionalIdeal/Operations.lean", "context": {"open": ["IsLocalization Pointwise nonZeroDivisors", "Set Submodule", "Classical in"], "variables": ["{R : Type*} [CommRing R] {S : Submonoid R} {P : Type*} [CommRing P]", "[Algebra R P]", "{P' : Type*} [CommRing P'] [Algebra R P']", "{P'' : Type*} [CommRing P''] [Algebra R P'']", "(I J : FractionalIdeal S P) (g : P \u2192\u2090[R] P')", "(S) in", "(S P P')", "[IsLocalization S P] [IsLocalization S P']", "{K K' : Type*} [Field K] [Field K']", "[Algebra R K] [IsFractionRing R K] [Algebra R K'] [IsFractionRing R K']", "{I J : FractionalIdeal R\u2070 K} (h : K \u2192\u2090[R] K')", "{R\u2081 : Type*} [CommRing R\u2081] {K : Type*} [Field K]", "[Algebra R\u2081 K]", "[IsFractionRing R\u2081 K] [IsDomain R\u2081]", "{I J : FractionalIdeal R\u2081\u2070 K}", "{K' : Type*} [Field K'] [Algebra R\u2081 K'] [IsFractionRing R\u2081 K']", "{R\u2081 K L : Type*} [CommRing R\u2081] [Field K] [Field L]", "[Algebra R\u2081 K] [IsFractionRing R\u2081 K] [Algebra K L] [IsFractionRing K L]", "{R\u2081 : Type*} [CommRing R\u2081] {K : Type*} [Field K]", "[Algebra R\u2081 K] [IsFractionRing R\u2081 K]", "(R\u2081)", "{R\u2081}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Submonoid ?m.181296\nP : Type ?u.181105\nR : Type ?u.182484\nP' : Type ?u.182482\nI\u271d\u00b9 : sorry\nJ\u271d\u00b9 : sorry\ng : sorry\nK\u271d\u00b3 : Type u_1\nK'\u271d : Type u_2\ninst\u271d\u00b2\u00b9 : Field K\u271d\u00b3\ninst\u271d\u00b2\u2070 : Field K'\u271d\nI\u271d : FractionalIdeal sorry K\u271d\u00b3\nJ\u271d : FractionalIdeal sorry K\u271d\u00b3\nh : sorry\nR\u2081\u271d\u00b9 : Type u_3\ninst\u271d\u00b9\u2079 : CommRing R\u2081\u271d\u00b9\nK\u271d\u00b2 : Type u_4\ninst\u271d\u00b9\u2078 : Field K\u271d\u00b2\ninst\u271d\u00b9\u2077 : Algebra R\u2081\u271d\u00b9 K\u271d\u00b2\ninst\u271d\u00b9\u2076 : IsFractionRing R\u2081\u271d\u00b9 K\u271d\u00b2\ninst\u271d\u00b9\u2075 : IsDomain R\u2081\u271d\u00b9\nI J : FractionalIdeal (nonZeroDivisors R\u2081\u271d\u00b9) K\u271d\u00b2\nK' : Type u_5\ninst\u271d\u00b9\u2074 : Field K'\ninst\u271d\u00b9\u00b3 : Algebra R\u2081\u271d\u00b9 K'\ninst\u271d\u00b9\u00b2 : IsFractionRing R\u2081\u271d\u00b9 K'\nR\u2081\u271d : Type u_6\nK\u271d\u00b9 : Type u_7\nL : Type u_8\ninst\u271d\u00b9\u00b9 : CommRing R\u2081\u271d\ninst\u271d\u00b9\u2070 : Field K\u271d\u00b9\ninst\u271d\u2079 : Field L\ninst\u271d\u2078 : Algebra R\u2081\u271d K\u271d\u00b9\ninst\u271d\u2077 : IsFractionRing R\u2081\u271d K\u271d\u00b9\ninst\u271d\u2076 : Algebra K\u271d\u00b9 L\ninst\u271d\u2075 : IsFractionRing K\u271d\u00b9 L\nR\u2081 : Type u_9\ninst\u271d\u2074 : CommRing R\u2081\nK\u271d : Type u_10\ninst\u271d\u00b3 : Field K\u271d\ninst\u271d\u00b2 : Algebra R\u2081 K\u271d\ninst\u271d\u00b9 : IsFractionRing R\u2081 K\u271d\nK : Type u_10\ninst\u271d : Field K\nx\u271d : Sort u_12\nspanFinset : x\u271d\n\u03b9 : Type u_11\ns : Finset \u03b9\nf : \u03b9 \u2192 K\n\u22a2 sorry \u2260 0 \u2194 \u2203 j \u2208 s, f j \u2260 0"}, {"line": "simp", "tactic_state": "S : Submonoid ?m.181296\nP : Type ?u.181105\nR : Type ?u.182484\nP' : Type ?u.182482\nI\u271d\u00b9 : sorry\nJ\u271d\u00b9 : sorry\ng : sorry\nK\u271d\u00b3 : Type u_1\nK'\u271d : Type u_2\ninst\u271d\u00b2\u00b9 : Field K\u271d\u00b3\ninst\u271d\u00b2\u2070 : Field K'\u271d\nI\u271d : FractionalIdeal sorry K\u271d\u00b3\nJ\u271d : FractionalIdeal sorry K\u271d\u00b3\nh : sorry\nR\u2081\u271d\u00b9 : Type u_3\ninst\u271d\u00b9\u2079 : CommRing R\u2081\u271d\u00b9\nK\u271d\u00b2 : Type u_4\ninst\u271d\u00b9\u2078 : Field K\u271d\u00b2\ninst\u271d\u00b9\u2077 : Algebra R\u2081\u271d\u00b9 K\u271d\u00b2\ninst\u271d\u00b9\u2076 : IsFractionRing R\u2081\u271d\u00b9 K\u271d\u00b2\ninst\u271d\u00b9\u2075 : IsDomain R\u2081\u271d\u00b9\nI J : FractionalIdeal (nonZeroDivisors R\u2081\u271d\u00b9) K\u271d\u00b2\nK' : Type u_5\ninst\u271d\u00b9\u2074 : Field K'\ninst\u271d\u00b9\u00b3 : Algebra R\u2081\u271d\u00b9 K'\ninst\u271d\u00b9\u00b2 : IsFractionRing R\u2081\u271d\u00b9 K'\nR\u2081\u271d : Type u_6\nK\u271d\u00b9 : Type u_7\nL : Type u_8\ninst\u271d\u00b9\u00b9 : CommRing R\u2081\u271d\ninst\u271d\u00b9\u2070 : Field K\u271d\u00b9\ninst\u271d\u2079 : Field L\ninst\u271d\u2078 : Algebra R\u2081\u271d K\u271d\u00b9\ninst\u271d\u2077 : IsFractionRing R\u2081\u271d K\u271d\u00b9\ninst\u271d\u2076 : Algebra K\u271d\u00b9 L\ninst\u271d\u2075 : IsFractionRing K\u271d\u00b9 L\nR\u2081 : Type u_9\ninst\u271d\u2074 : CommRing R\u2081\nK\u271d : Type u_10\ninst\u271d\u00b3 : Field K\u271d\ninst\u271d\u00b2 : Algebra R\u2081 K\u271d\ninst\u271d\u00b9 : IsFractionRing R\u2081 K\u271d\nK : Type u_10\ninst\u271d : Field K\nx\u271d : Sort u_12\nspanFinset : x\u271d\n\u03b9 : Type u_11\ns : Finset \u03b9\nf : \u03b9 \u2192 K\n\u22a2 \u00acsorry () = 0 \u2194 \u2203 j \u2208 s, \u00acf j = 0"}]}
{"declaration": "theorem spanSingleton_pow (x : P) (n : \u2115) : spanSingleton S x ^ n = spanSingleton S (x ^ n) := by\n  induction' n with n hn\n  \u00b7 rw [pow_zero, pow_zero, spanSingleton_one]\n  \u00b7 rw [pow_succ, hn, spanSingleton_mul_spanSingleton, pow_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/FractionalIdeal/Operations.lean", "context": {"open": ["IsLocalization Pointwise nonZeroDivisors", "Set Submodule", "Classical in", "Submodule.IsPrincipal"], "variables": ["{R : Type*} [CommRing R] {S : Submonoid R} {P : Type*} [CommRing P]", "[Algebra R P]", "{P' : Type*} [CommRing P'] [Algebra R P']", "{P'' : Type*} [CommRing P''] [Algebra R P'']", "(I J : FractionalIdeal S P) (g : P \u2192\u2090[R] P')", "(S) in", "(S P P')", "[IsLocalization S P] [IsLocalization S P']", "{K K' : Type*} [Field K] [Field K']", "[Algebra R K] [IsFractionRing R K] [Algebra R K'] [IsFractionRing R K']", "{I J : FractionalIdeal R\u2070 K} (h : K \u2192\u2090[R] K')", "{R\u2081 : Type*} [CommRing R\u2081] {K : Type*} [Field K]", "[Algebra R\u2081 K]", "[IsFractionRing R\u2081 K] [IsDomain R\u2081]", "{I J : FractionalIdeal R\u2081\u2070 K}", "{K' : Type*} [Field K'] [Algebra R\u2081 K'] [IsFractionRing R\u2081 K']", "{R\u2081 K L : Type*} [CommRing R\u2081] [Field K] [Field L]", "[Algebra R\u2081 K] [IsFractionRing R\u2081 K] [Algebra K L] [IsFractionRing K L]", "{R\u2081 : Type*} [CommRing R\u2081] {K : Type*} [Field K]", "[Algebra R\u2081 K] [IsFractionRing R\u2081 K]", "(R\u2081)", "{R\u2081}", "[IsLocalization S P]", "(S)", "(P) in", "{S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_2\ninst\u271d : CommRing P\nx\u271d : Sort u_15\nspanSingleton : x\u271d\nx : P\nn : \u2115\n\u22a2 sorry ^ n = sorry"}, {"line": "induction' n with n hn", "tactic_state": "case zero\nP : Type u_2\ninst\u271d : CommRing P\nx\u271d : Sort u_15\nspanSingleton : x\u271d\nx : P\n\u22a2 sorry ^ 0 = sorry\n---\ncase succ\nP : Type u_2\ninst\u271d : CommRing P\nx\u271d : Sort u_15\nspanSingleton : x\u271d\nx : P\nn : \u2115\nhn : sorry ^ n = sorry\n\u22a2 sorry ^ (n + 1) = sorry"}, {"line": "\u00b7 rw [pow_zero, pow_zero, spanSingleton_one]", "tactic_state": "case succ\nP : Type u_2\ninst\u271d : CommRing P\nx\u271d : Sort u_15\nspanSingleton : x\u271d\nx : P\nn : \u2115\nhn : sorry ^ n = sorry\n\u22a2 sorry ^ (n + 1) = sorry"}, {"line": "\u00b7 rw [pow_succ, hn, spanSingleton_mul_spanSingleton, pow_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem GradedRing.proj_recompose (a : \u2a01 i, \ud835\udc9c i) (i : \u03b9) :\n    GradedRing.proj \ud835\udc9c i ((decompose \ud835\udc9c).symm a) = (decompose \ud835\udc9c).symm (DirectSum.of _ i (a i)) := by\n  rw [GradedRing.proj_apply]\n  rw [decompose_symm_of]\n  rw [Equiv.apply_symm_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/GradedAlgebra/Basic.lean", "context": {"open": ["DirectSum", "DirectSum"], "variables": ["{\u03b9 R A \u03c3 : Type*}", "[DecidableEq \u03b9] [AddMonoid \u03b9] [CommSemiring R] [Semiring A] [Algebra R A]", "[SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3)", "[GradedRing \ud835\udc9c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nA : Type u_3\n\u03c3 : Type u_4\ninst\u271d\u2075 : DecidableEq \u03b9\ninst\u271d\u2074 : AddMonoid \u03b9\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d : GradedRing \ud835\udc9c\na : DirectSum \u03b9 fun i => \u21a5(\ud835\udc9c i)\ni : \u03b9\n\u22a2 (proj \ud835\udc9c i) ((decompose \ud835\udc9c).symm a) = (decompose \ud835\udc9c).symm ((of (fun i => \u21a5(\ud835\udc9c i)) i) (a i))"}, {"line": "rw [GradedRing.proj_apply]", "tactic_state": "\u03b9 : Type u_1\nA : Type u_3\n\u03c3 : Type u_4\ninst\u271d\u2075 : DecidableEq \u03b9\ninst\u271d\u2074 : AddMonoid \u03b9\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d : GradedRing \ud835\udc9c\na : DirectSum \u03b9 fun i => \u21a5(\ud835\udc9c i)\ni : \u03b9\n\u22a2 \u2191(((decompose \ud835\udc9c) ((decompose \ud835\udc9c).symm a)) i) = (decompose \ud835\udc9c).symm ((of (fun i => \u21a5(\ud835\udc9c i)) i) (a i))"}, {"line": "rw [decompose_symm_of]", "tactic_state": "\u03b9 : Type u_1\nA : Type u_3\n\u03c3 : Type u_4\ninst\u271d\u2075 : DecidableEq \u03b9\ninst\u271d\u2074 : AddMonoid \u03b9\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d : GradedRing \ud835\udc9c\na : DirectSum \u03b9 fun i => \u21a5(\ud835\udc9c i)\ni : \u03b9\n\u22a2 \u2191(((decompose \ud835\udc9c) ((decompose \ud835\udc9c).symm a)) i) = \u2191(a i)"}, {"line": "rw [Equiv.apply_symm_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem GradedAlgebra.proj_recompose (a : \u2a01 i, \ud835\udc9c i) (i : \u03b9) :\n    GradedAlgebra.proj \ud835\udc9c i ((decompose \ud835\udc9c).symm a) = (decompose \ud835\udc9c).symm (of _ i (a i)) := by\n  rw [GradedAlgebra.proj_apply]\n  rw [decompose_symm_of]\n  rw [Equiv.apply_symm_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/GradedAlgebra/Basic.lean", "context": {"open": ["DirectSum", "DirectSum", "DirectSum", "DirectSum"], "variables": ["{\u03b9 R A \u03c3 : Type*}", "[DecidableEq \u03b9] [AddMonoid \u03b9] [CommSemiring R] [Semiring A] [Algebra R A]", "[SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3)", "[GradedRing \ud835\udc9c]", "[DecidableEq \u03b9] [Semiring A] [SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3)", "{i j : \u03b9}", "[DecidableEq \u03b9] [AddMonoid \u03b9] [CommSemiring R] [Semiring A] [Algebra R A]", "(\ud835\udc9c : \u03b9 \u2192 Submodule R A)", "[GradedAlgebra \ud835\udc9c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nA : Type u_3\ninst\u271d\u00b9\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b9 : AddMonoid \u03b9\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : Semiring A\ninst\u271d\u2078 : Algebra R A\ninst\u271d\u2077 : DecidableEq \u03b9\ninst\u271d\u2076 : Semiring A\ninst\u271d\u2075 : DecidableEq \u03b9\ninst\u271d\u2074 : AddMonoid \u03b9\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Semiring A\ninst\u271d\u00b9 : Algebra R A\n\ud835\udc9c : \u03b9 \u2192 Submodule R A\ninst\u271d : GradedAlgebra \ud835\udc9c\na : DirectSum \u03b9 fun i => \u21a5(\ud835\udc9c i)\ni : \u03b9\n\u22a2 (proj \ud835\udc9c i) ((decompose \ud835\udc9c).symm a) = (decompose \ud835\udc9c).symm ((of (fun i => \u21a5(\ud835\udc9c i)) i) (a i))"}, {"line": "rw [GradedAlgebra.proj_apply]", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nA : Type u_3\ninst\u271d\u00b9\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b9 : AddMonoid \u03b9\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : Semiring A\ninst\u271d\u2078 : Algebra R A\ninst\u271d\u2077 : DecidableEq \u03b9\ninst\u271d\u2076 : Semiring A\ninst\u271d\u2075 : DecidableEq \u03b9\ninst\u271d\u2074 : AddMonoid \u03b9\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Semiring A\ninst\u271d\u00b9 : Algebra R A\n\ud835\udc9c : \u03b9 \u2192 Submodule R A\ninst\u271d : GradedAlgebra \ud835\udc9c\na : DirectSum \u03b9 fun i => \u21a5(\ud835\udc9c i)\ni : \u03b9\n\u22a2 \u2191(((decompose \ud835\udc9c) ((decompose \ud835\udc9c).symm a)) i) = (decompose \ud835\udc9c).symm ((of (fun i => \u21a5(\ud835\udc9c i)) i) (a i))"}, {"line": "rw [decompose_symm_of]", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nA : Type u_3\ninst\u271d\u00b9\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b9 : AddMonoid \u03b9\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : Semiring A\ninst\u271d\u2078 : Algebra R A\ninst\u271d\u2077 : DecidableEq \u03b9\ninst\u271d\u2076 : Semiring A\ninst\u271d\u2075 : DecidableEq \u03b9\ninst\u271d\u2074 : AddMonoid \u03b9\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Semiring A\ninst\u271d\u00b9 : Algebra R A\n\ud835\udc9c : \u03b9 \u2192 Submodule R A\ninst\u271d : GradedAlgebra \ud835\udc9c\na : DirectSum \u03b9 fun i => \u21a5(\ud835\udc9c i)\ni : \u03b9\n\u22a2 \u2191(((decompose \ud835\udc9c) ((decompose \ud835\udc9c).symm a)) i) = \u2191(a i)"}, {"line": "rw [Equiv.apply_symm_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem den_smul_val (f : HomogeneousLocalization \ud835\udc9c x) :\n    f.den \u2022 f.val = algebraMap _ _ f.num := by\n  rw [eq_num_div_den]\n  rw [Localization.mk_eq_mk']\n  rw [IsLocalization.smul_mk']\n  exact IsLocalization.mk'_mul_cancel_left _ \u27e8_, _\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/GradedAlgebra/HomogeneousLocalization.lean", "context": {"open": ["DirectSum Pointwise", "DirectSum SetLike", "SetLike.GradedMonoid Submodule", "HomogeneousLocalization HomogeneousLocalization.NumDenSameDeg", "HomogeneousLocalization HomogeneousLocalization.NumDenSameDeg"], "variables": ["{\u03b9 R A : Type*}", "[CommRing R] [CommRing A] [Algebra R A]", "(\ud835\udc9c : \u03b9 \u2192 Submodule R A)", "(x : Submonoid A)", "{\ud835\udc9c}", "{\u03b1 : Type*} [SMul \u03b1 R] [SMul \u03b1 A] [IsScalarTower \u03b1 R A]", "[AddCommMonoid \u03b9] [DecidableEq \u03b9] [GradedAlgebra \ud835\udc9c]", "(\ud835\udc9c)", "{\ud835\udc9c} {x}", "(x)", "(\ud835\udc9c) {x} in", "{\u03b1 : Type*} [SMul \u03b1 R] [SMul \u03b1 A] [IsScalarTower \u03b1 R A]", "[IsScalarTower \u03b1 A A]", "[AddCommMonoid \u03b9] [DecidableEq \u03b9] [GradedAlgebra \ud835\udc9c]", "{x}", "(\ud835\udc9c x) in", "{\ud835\udc9c} {x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nA : Type u_3\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing A\ninst\u271d\u2076 : Algebra R A\n\ud835\udc9c : \u03b9 \u2192 Submodule R A\nx : Submonoid A\ninst\u271d\u2075 : AddCommMonoid \u03b9\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : GradedAlgebra \ud835\udc9c\ninst\u271d\u00b2 : AddCommMonoid \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : GradedAlgebra \ud835\udc9c\nf : HomogeneousLocalization \ud835\udc9c x\n\u22a2 f.den \u2022 f.val = (algebraMap A (Localization x)) f.num"}, {"line": "rw [eq_num_div_den]", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nA : Type u_3\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing A\ninst\u271d\u2076 : Algebra R A\n\ud835\udc9c : \u03b9 \u2192 Submodule R A\nx : Submonoid A\ninst\u271d\u2075 : AddCommMonoid \u03b9\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : GradedAlgebra \ud835\udc9c\ninst\u271d\u00b2 : AddCommMonoid \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : GradedAlgebra \ud835\udc9c\nf : HomogeneousLocalization \ud835\udc9c x\n\u22a2 f.den \u2022 Localization.mk f.num \u27e8f.den, \u22ef\u27e9 = (algebraMap A (Localization x)) f.num"}, {"line": "rw [Localization.mk_eq_mk']", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nA : Type u_3\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing A\ninst\u271d\u2076 : Algebra R A\n\ud835\udc9c : \u03b9 \u2192 Submodule R A\nx : Submonoid A\ninst\u271d\u2075 : AddCommMonoid \u03b9\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : GradedAlgebra \ud835\udc9c\ninst\u271d\u00b2 : AddCommMonoid \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : GradedAlgebra \ud835\udc9c\nf : HomogeneousLocalization \ud835\udc9c x\n\u22a2 f.den \u2022 IsLocalization.mk' (Localization x) f.num \u27e8f.den, \u22ef\u27e9 = (algebraMap A (Localization x)) f.num"}, {"line": "rw [IsLocalization.smul_mk']", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nA : Type u_3\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing A\ninst\u271d\u2076 : Algebra R A\n\ud835\udc9c : \u03b9 \u2192 Submodule R A\nx : Submonoid A\ninst\u271d\u2075 : AddCommMonoid \u03b9\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : GradedAlgebra \ud835\udc9c\ninst\u271d\u00b2 : AddCommMonoid \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : GradedAlgebra \ud835\udc9c\nf : HomogeneousLocalization \ud835\udc9c x\n\u22a2 IsLocalization.mk' (Localization x) (f.den * f.num) \u27e8f.den, \u22ef\u27e9 = (algebraMap A (Localization x)) f.num"}, {"line": "exact IsLocalization.mk'_mul_cancel_left _ \u27e8_, _\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma val_awayMap (a) : (awayMap \ud835\udc9c hg hx a).val = Localization.awayLift (algebraMap A _) _\n    (isUnit_of_dvd_unit (map_dvd _ \u27e8_, hx\u27e9) (IsLocalization.Away.algebraMap_isUnit x)) a.val := by\n  rw [val_awayMap_eq_aux]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/GradedAlgebra/HomogeneousLocalization.lean", "context": {"open": ["DirectSum Pointwise", "DirectSum SetLike", "SetLike.GradedMonoid Submodule", "HomogeneousLocalization HomogeneousLocalization.NumDenSameDeg", "HomogeneousLocalization HomogeneousLocalization.NumDenSameDeg"], "variables": ["{\u03b9 R A : Type*}", "[CommRing R] [CommRing A] [Algebra R A]", "(\ud835\udc9c : \u03b9 \u2192 Submodule R A)", "(x : Submonoid A)", "{\ud835\udc9c}", "{\u03b1 : Type*} [SMul \u03b1 R] [SMul \u03b1 A] [IsScalarTower \u03b1 R A]", "[AddCommMonoid \u03b9] [DecidableEq \u03b9] [GradedAlgebra \ud835\udc9c]", "(\ud835\udc9c)", "{\ud835\udc9c} {x}", "(x)", "(\ud835\udc9c) {x} in", "{\u03b1 : Type*} [SMul \u03b1 R] [SMul \u03b1 A] [IsScalarTower \u03b1 R A]", "[IsScalarTower \u03b1 A A]", "[AddCommMonoid \u03b9] [DecidableEq \u03b9] [GradedAlgebra \ud835\udc9c]", "{x}", "(\ud835\udc9c x) in", "{\ud835\udc9c} {x}", "[AddCommMonoid \u03b9] [DecidableEq \u03b9] [GradedAlgebra \ud835\udc9c]", "(\ud835\udc9c) (\ud835\udd2d : Ideal A) [Ideal.IsPrime \ud835\udd2d]", "(\ud835\udc9c) (f : A)", "[AddCommMonoid \u03b9] [DecidableEq \u03b9] [GradedAlgebra \ud835\udc9c]", "{\ud835\udc9c} {f}", "[AddCommMonoid \u03b9] [DecidableEq \u03b9] [GradedAlgebra \ud835\udc9c]", "(\ud835\udc9c)", "{B : Type*} [CommRing B] [Algebra R B]", "(\u212c : \u03b9 \u2192 Submodule R B) [GradedAlgebra \u212c]", "{P : Submonoid A} {Q : Submonoid B}", "[AddCommMonoid \u03b9] [DecidableEq \u03b9] [GradedAlgebra \ud835\udc9c]", "{e : \u03b9} {f : A} {g : A} (hg : g \u2208 \ud835\udc9c e) {x : A} (hx : x = f * g)", "(\ud835\udc9c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nA : Type u_3\ninst\u271d\u00b2\u2070 : CommRing R\ninst\u271d\u00b9\u2079 : CommRing A\ninst\u271d\u00b9\u2078 : Algebra R A\n\ud835\udc9c : \u03b9 \u2192 Submodule R A\ninst\u271d\u00b9\u2077 : AddCommMonoid \u03b9\ninst\u271d\u00b9\u2076 : DecidableEq \u03b9\ninst\u271d\u00b9\u2075 : GradedAlgebra \ud835\udc9c\ninst\u271d\u00b9\u2074 : AddCommMonoid \u03b9\ninst\u271d\u00b9\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b2 : GradedAlgebra \ud835\udc9c\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b9\ninst\u271d\u00b9\u2070 : DecidableEq \u03b9\ninst\u271d\u2079 : GradedAlgebra \ud835\udc9c\ninst\u271d\u2078 : AddCommMonoid \u03b9\ninst\u271d\u2077 : DecidableEq \u03b9\ninst\u271d\u2076 : GradedAlgebra \ud835\udc9c\ninst\u271d\u2075 : AddCommMonoid \u03b9\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : GradedAlgebra \ud835\udc9c\ninst\u271d\u00b2 : AddCommMonoid \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : GradedAlgebra \ud835\udc9c\ne : \u03b9\nf g : A\nhg : g \u2208 \ud835\udc9c e\nx : A\nhx : x = f * g\na : Away \ud835\udc9c f\n\u22a2 val ((awayMap \ud835\udc9c hg hx) a) = (Localization.awayLift (algebraMap A (Localization (Submonoid.powers x))) f \u22ef) (val a)"}, {"line": "rw [val_awayMap_eq_aux]", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nA : Type u_3\ninst\u271d\u00b2\u2070 : CommRing R\ninst\u271d\u00b9\u2079 : CommRing A\ninst\u271d\u00b9\u2078 : Algebra R A\n\ud835\udc9c : \u03b9 \u2192 Submodule R A\ninst\u271d\u00b9\u2077 : AddCommMonoid \u03b9\ninst\u271d\u00b9\u2076 : DecidableEq \u03b9\ninst\u271d\u00b9\u2075 : GradedAlgebra \ud835\udc9c\ninst\u271d\u00b9\u2074 : AddCommMonoid \u03b9\ninst\u271d\u00b9\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b2 : GradedAlgebra \ud835\udc9c\ninst\u271d\u00b9\u00b9 : AddCommMonoid \u03b9\ninst\u271d\u00b9\u2070 : DecidableEq \u03b9\ninst\u271d\u2079 : GradedAlgebra \ud835\udc9c\ninst\u271d\u2078 : AddCommMonoid \u03b9\ninst\u271d\u2077 : DecidableEq \u03b9\ninst\u271d\u2076 : GradedAlgebra \ud835\udc9c\ninst\u271d\u2075 : AddCommMonoid \u03b9\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : GradedAlgebra \ud835\udc9c\ninst\u271d\u00b2 : AddCommMonoid \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : GradedAlgebra \ud835\udc9c\ne : \u03b9\nf g : A\nhg : g \u2208 \ud835\udc9c e\nx : A\nhx : x = f * g\na : Away \ud835\udc9c f\n\u22a2 (HomogeneousLocalization.awayMapAux\u271d \ud835\udc9c \u22ef) a =\n    (Localization.awayLift (algebraMap A (Localization (Submonoid.powers x))) f \u22ef) (val a)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ideal.IsHomogeneous.radical_eq {I : Ideal A} (hI : I.IsHomogeneous \ud835\udc9c) :\n    I.radical = InfSet.sInf { J | Ideal.IsHomogeneous \ud835\udc9c J \u2227 I \u2264 J \u2227 J.IsPrime } := by\n  rw [Ideal.radical_eq_sInf]\n  apply le_antisymm\n  \u00b7 exact sInf_le_sInf fun J => And.right\n  \u00b7 refine sInf_le_sInf_of_forall_exists_le ?_\n    rintro J \u27e8HJ\u2081, HJ\u2082\u27e9\n    refine \u27e8(J.homogeneousCore \ud835\udc9c).toIdeal, ?_, J.toIdeal_homogeneousCore_le _\u27e9\n    refine \u27e8HomogeneousIdeal.isHomogeneous _, ?_, HJ\u2082.homogeneousCore\u27e9\n    exact hI.toIdeal_homogeneousCore_eq_self.symm.trans_le (Ideal.homogeneousCore_mono _ HJ\u2081)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/GradedAlgebra/Radical.lean", "context": {"open": ["GradedRing DirectSum SetLike Finset"], "variables": ["{\u03b9 \u03c3 A : Type*}", "[CommRing A]", "[AddCommMonoid \u03b9] [LinearOrder \u03b9] [IsOrderedCancelAddMonoid \u03b9]", "[SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] {\ud835\udc9c : \u03b9 \u2192 \u03c3} [GradedRing \ud835\udc9c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c3 : Type u_2\nA : Type u_3\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : AddCommMonoid \u03b9\ninst\u271d\u2074 : LinearOrder \u03b9\ninst\u271d\u00b3 : IsOrderedCancelAddMonoid \u03b9\ninst\u271d\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d : GradedRing \ud835\udc9c\nI : Ideal A\nhI : IsHomogeneous \ud835\udc9c I\n\u22a2 I.radical = InfSet.sInf {J | IsHomogeneous \ud835\udc9c J \u2227 I \u2264 J \u2227 J.IsPrime}"}, {"line": "rw [Ideal.radical_eq_sInf]", "tactic_state": "\u03b9 : Type u_1\n\u03c3 : Type u_2\nA : Type u_3\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : AddCommMonoid \u03b9\ninst\u271d\u2074 : LinearOrder \u03b9\ninst\u271d\u00b3 : IsOrderedCancelAddMonoid \u03b9\ninst\u271d\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d : GradedRing \ud835\udc9c\nI : Ideal A\nhI : IsHomogeneous \ud835\udc9c I\n\u22a2 InfSet.sInf {J | I \u2264 J \u2227 J.IsPrime} = InfSet.sInf {J | IsHomogeneous \ud835\udc9c J \u2227 I \u2264 J \u2227 J.IsPrime}"}, {"line": "apply le_antisymm", "tactic_state": "case a\n\u03b9 : Type u_1\n\u03c3 : Type u_2\nA : Type u_3\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : AddCommMonoid \u03b9\ninst\u271d\u2074 : LinearOrder \u03b9\ninst\u271d\u00b3 : IsOrderedCancelAddMonoid \u03b9\ninst\u271d\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d : GradedRing \ud835\udc9c\nI : Ideal A\nhI : IsHomogeneous \ud835\udc9c I\n\u22a2 InfSet.sInf {J | I \u2264 J \u2227 J.IsPrime} \u2264 InfSet.sInf {J | IsHomogeneous \ud835\udc9c J \u2227 I \u2264 J \u2227 J.IsPrime}\n---\ncase a\n\u03b9 : Type u_1\n\u03c3 : Type u_2\nA : Type u_3\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : AddCommMonoid \u03b9\ninst\u271d\u2074 : LinearOrder \u03b9\ninst\u271d\u00b3 : IsOrderedCancelAddMonoid \u03b9\ninst\u271d\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d : GradedRing \ud835\udc9c\nI : Ideal A\nhI : IsHomogeneous \ud835\udc9c I\n\u22a2 InfSet.sInf {J | IsHomogeneous \ud835\udc9c J \u2227 I \u2264 J \u2227 J.IsPrime} \u2264 InfSet.sInf {J | I \u2264 J \u2227 J.IsPrime}"}, {"line": "\u00b7 exact sInf_le_sInf fun J => And.right", "tactic_state": "case a\n\u03b9 : Type u_1\n\u03c3 : Type u_2\nA : Type u_3\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : AddCommMonoid \u03b9\ninst\u271d\u2074 : LinearOrder \u03b9\ninst\u271d\u00b3 : IsOrderedCancelAddMonoid \u03b9\ninst\u271d\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d : GradedRing \ud835\udc9c\nI : Ideal A\nhI : IsHomogeneous \ud835\udc9c I\n\u22a2 InfSet.sInf {J | IsHomogeneous \ud835\udc9c J \u2227 I \u2264 J \u2227 J.IsPrime} \u2264 InfSet.sInf {J | I \u2264 J \u2227 J.IsPrime}"}, {"line": "\u00b7 refine sInf_le_sInf_of_forall_exists_le ?_\n    rintro J \u27e8HJ\u2081, HJ\u2082\u27e9\n    refine \u27e8(J.homogeneousCore \ud835\udc9c).toIdeal, ?_, J.toIdeal_homogeneousCore_le _\u27e9\n    refine \u27e8HomogeneousIdeal.isHomogeneous _, ?_, HJ\u2082.homogeneousCore\u27e9\n    exact hI.toIdeal_homogeneousCore_eq_self.symm.trans_le (Ideal.homogeneousCore_mono _ HJ\u2081)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ideal.IsHomogeneous.iff_exists :\n    I.IsHomogeneous \ud835\udc9c \u2194 \u2203 S : Set (homogeneousSubmonoid \ud835\udc9c), I = Ideal.span ((\u2191) '' S) := by\n  rw [Ideal.IsHomogeneous.iff_eq]\n  rw [eq_comm]\n  exact ((Set.image_preimage.compose (Submodule.gi _ _).gc).exists_eq_l _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/GradedAlgebra/Homogeneous/Ideal.lean", "context": {"open": ["SetLike DirectSum Set", "Pointwise DirectSum"], "variables": ["{\u03b9 \u03c3 A : Type*}", "[Semiring A]", "[SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3)", "[DecidableEq \u03b9] [AddMonoid \u03b9] [GradedRing \ud835\udc9c]", "(I : Ideal A)", "{\ud835\udc9c}", "[Semiring A]", "[SetLike \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3)", "(I : Ideal A)", "[Semiring A]", "[SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3)", "[DecidableEq \u03b9] [AddMonoid \u03b9] [GradedRing \ud835\udc9c]", "(I : Ideal A)", "{\ud835\udc9c I}", "(\ud835\udc9c I)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c3 : Type u_2\nA : Type u_3\ninst\u271d\u00b9\u00b2 : Semiring A\ninst\u271d\u00b9\u00b9 : SetLike \u03c3 A\ninst\u271d\u00b9\u2070 : AddSubmonoidClass \u03c3 A\ninst\u271d\u2079 : DecidableEq \u03b9\ninst\u271d\u2078 : AddMonoid \u03b9\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : SetLike \u03c3 A\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : SetLike \u03c3 A\ninst\u271d\u00b3 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : AddMonoid \u03b9\ninst\u271d : GradedRing \ud835\udc9c\nI : Ideal A\n\u22a2 IsHomogeneous \ud835\udc9c I \u2194 \u2203 S, I = span (Subtype.val '' S)"}, {"line": "rw [Ideal.IsHomogeneous.iff_eq]", "tactic_state": "\u03b9 : Type u_1\n\u03c3 : Type u_2\nA : Type u_3\ninst\u271d\u00b9\u00b2 : Semiring A\ninst\u271d\u00b9\u00b9 : SetLike \u03c3 A\ninst\u271d\u00b9\u2070 : AddSubmonoidClass \u03c3 A\ninst\u271d\u2079 : DecidableEq \u03b9\ninst\u271d\u2078 : AddMonoid \u03b9\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : SetLike \u03c3 A\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : SetLike \u03c3 A\ninst\u271d\u00b3 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : AddMonoid \u03b9\ninst\u271d : GradedRing \ud835\udc9c\nI : Ideal A\n\u22a2 (homogeneousCore \ud835\udc9c I).toIdeal = I \u2194 \u2203 S, I = span (Subtype.val '' S)"}, {"line": "rw [eq_comm]", "tactic_state": "\u03b9 : Type u_1\n\u03c3 : Type u_2\nA : Type u_3\ninst\u271d\u00b9\u00b2 : Semiring A\ninst\u271d\u00b9\u00b9 : SetLike \u03c3 A\ninst\u271d\u00b9\u2070 : AddSubmonoidClass \u03c3 A\ninst\u271d\u2079 : DecidableEq \u03b9\ninst\u271d\u2078 : AddMonoid \u03b9\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : SetLike \u03c3 A\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : SetLike \u03c3 A\ninst\u271d\u00b3 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : AddMonoid \u03b9\ninst\u271d : GradedRing \ud835\udc9c\nI : Ideal A\n\u22a2 I = (homogeneousCore \ud835\udc9c I).toIdeal \u2194 \u2203 S, I = span (Subtype.val '' S)"}, {"line": "exact ((Set.image_preimage.compose (Submodule.gi _ _).gc).exists_eq_l _).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sSup {\u2110 : Set (Ideal A)} (h : \u2200 I \u2208 \u2110, Ideal.IsHomogeneous \ud835\udc9c I) :\n    (sSup \u2110).IsHomogeneous \ud835\udc9c := by\n  rw [sSup_eq_iSup]\n  exact iSup\u2082 h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/GradedAlgebra/Homogeneous/Ideal.lean", "context": {"open": ["SetLike DirectSum Set", "Pointwise DirectSum"], "variables": ["{\u03b9 \u03c3 A : Type*}", "[Semiring A]", "[SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3)", "[DecidableEq \u03b9] [AddMonoid \u03b9] [GradedRing \ud835\udc9c]", "(I : Ideal A)", "{\ud835\udc9c}", "[Semiring A]", "[SetLike \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3)", "(I : Ideal A)", "[Semiring A]", "[SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3)", "[DecidableEq \u03b9] [AddMonoid \u03b9] [GradedRing \ud835\udc9c]", "(I : Ideal A)", "{\ud835\udc9c I}", "(\ud835\udc9c I)", "[Semiring A] [DecidableEq \u03b9] [AddMonoid \u03b9]", "[SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3) [GradedRing \ud835\udc9c]", "{\ud835\udc9c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c3 : Type u_2\nA : Type u_3\ninst\u271d\u00b9\u2077 : Semiring A\ninst\u271d\u00b9\u2076 : SetLike \u03c3 A\ninst\u271d\u00b9\u2075 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b9\u2074 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b3 : AddMonoid \u03b9\ninst\u271d\u00b9\u00b2 : Semiring A\ninst\u271d\u00b9\u00b9 : SetLike \u03c3 A\ninst\u271d\u00b9\u2070 : Semiring A\ninst\u271d\u2079 : SetLike \u03c3 A\ninst\u271d\u2078 : AddSubmonoidClass \u03c3 A\ninst\u271d\u2077 : DecidableEq \u03b9\ninst\u271d\u2076 : AddMonoid \u03b9\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : AddMonoid \u03b9\ninst\u271d\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d : GradedRing \ud835\udc9c\n\u2110 : Set (Ideal A)\nh : \u2200 I \u2208 \u2110, Ideal.IsHomogeneous \ud835\udc9c I\n\u22a2 Ideal.IsHomogeneous \ud835\udc9c (SupSet.sSup \u2110)"}, {"line": "rw [sSup_eq_iSup]", "tactic_state": "\u03b9 : Type u_1\n\u03c3 : Type u_2\nA : Type u_3\ninst\u271d\u00b9\u2077 : Semiring A\ninst\u271d\u00b9\u2076 : SetLike \u03c3 A\ninst\u271d\u00b9\u2075 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b9\u2074 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b3 : AddMonoid \u03b9\ninst\u271d\u00b9\u00b2 : Semiring A\ninst\u271d\u00b9\u00b9 : SetLike \u03c3 A\ninst\u271d\u00b9\u2070 : Semiring A\ninst\u271d\u2079 : SetLike \u03c3 A\ninst\u271d\u2078 : AddSubmonoidClass \u03c3 A\ninst\u271d\u2077 : DecidableEq \u03b9\ninst\u271d\u2076 : AddMonoid \u03b9\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : AddMonoid \u03b9\ninst\u271d\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d : GradedRing \ud835\udc9c\n\u2110 : Set (Ideal A)\nh : \u2200 I \u2208 \u2110, Ideal.IsHomogeneous \ud835\udc9c I\n\u22a2 Ideal.IsHomogeneous \ud835\udc9c (\u2a06 a \u2208 \u2110, a)"}, {"line": "exact iSup\u2082 h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInf {\u2110 : Set (Ideal A)} (h : \u2200 I \u2208 \u2110, Ideal.IsHomogeneous \ud835\udc9c I) :\n    (sInf \u2110).IsHomogeneous \ud835\udc9c := by\n  rw [sInf_eq_iInf]\n  exact iInf\u2082 h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/GradedAlgebra/Homogeneous/Ideal.lean", "context": {"open": ["SetLike DirectSum Set", "Pointwise DirectSum"], "variables": ["{\u03b9 \u03c3 A : Type*}", "[Semiring A]", "[SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3)", "[DecidableEq \u03b9] [AddMonoid \u03b9] [GradedRing \ud835\udc9c]", "(I : Ideal A)", "{\ud835\udc9c}", "[Semiring A]", "[SetLike \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3)", "(I : Ideal A)", "[Semiring A]", "[SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3)", "[DecidableEq \u03b9] [AddMonoid \u03b9] [GradedRing \ud835\udc9c]", "(I : Ideal A)", "{\ud835\udc9c I}", "(\ud835\udc9c I)", "[Semiring A] [DecidableEq \u03b9] [AddMonoid \u03b9]", "[SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3) [GradedRing \ud835\udc9c]", "{\ud835\udc9c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c3 : Type u_2\nA : Type u_3\ninst\u271d\u00b9\u2077 : Semiring A\ninst\u271d\u00b9\u2076 : SetLike \u03c3 A\ninst\u271d\u00b9\u2075 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b9\u2074 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b3 : AddMonoid \u03b9\ninst\u271d\u00b9\u00b2 : Semiring A\ninst\u271d\u00b9\u00b9 : SetLike \u03c3 A\ninst\u271d\u00b9\u2070 : Semiring A\ninst\u271d\u2079 : SetLike \u03c3 A\ninst\u271d\u2078 : AddSubmonoidClass \u03c3 A\ninst\u271d\u2077 : DecidableEq \u03b9\ninst\u271d\u2076 : AddMonoid \u03b9\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : AddMonoid \u03b9\ninst\u271d\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d : GradedRing \ud835\udc9c\n\u2110 : Set (Ideal A)\nh : \u2200 I \u2208 \u2110, Ideal.IsHomogeneous \ud835\udc9c I\n\u22a2 Ideal.IsHomogeneous \ud835\udc9c (InfSet.sInf \u2110)"}, {"line": "rw [sInf_eq_iInf]", "tactic_state": "\u03b9 : Type u_1\n\u03c3 : Type u_2\nA : Type u_3\ninst\u271d\u00b9\u2077 : Semiring A\ninst\u271d\u00b9\u2076 : SetLike \u03c3 A\ninst\u271d\u00b9\u2075 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b9\u2074 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b3 : AddMonoid \u03b9\ninst\u271d\u00b9\u00b2 : Semiring A\ninst\u271d\u00b9\u00b9 : SetLike \u03c3 A\ninst\u271d\u00b9\u2070 : Semiring A\ninst\u271d\u2079 : SetLike \u03c3 A\ninst\u271d\u2078 : AddSubmonoidClass \u03c3 A\ninst\u271d\u2077 : DecidableEq \u03b9\ninst\u271d\u2076 : AddMonoid \u03b9\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : AddMonoid \u03b9\ninst\u271d\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d : GradedRing \ud835\udc9c\n\u2110 : Set (Ideal A)\nh : \u2200 I \u2208 \u2110, Ideal.IsHomogeneous \ud835\udc9c I\n\u22a2 Ideal.IsHomogeneous \ud835\udc9c (\u2a05 a \u2208 \u2110, a)"}, {"line": "exact iInf\u2082 h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ideal.IsHomogeneous.toIdeal_homogeneousHull_eq_self (h : I.IsHomogeneous \ud835\udc9c) :\n    (Ideal.homogeneousHull \ud835\udc9c I).toIdeal = I := by\n  apply le_antisymm _ (Ideal.le_toIdeal_homogeneousHull _ _)\n  apply Ideal.span_le.2\n  rintro _ \u27e8i, x, rfl\u27e9\n  exact h _ x.prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/GradedAlgebra/Homogeneous/Ideal.lean", "context": {"open": ["SetLike DirectSum Set", "Pointwise DirectSum", "HomogeneousIdeal", "HomogeneousIdeal"], "variables": ["{\u03b9 \u03c3 A : Type*}", "[Semiring A]", "[SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3)", "[DecidableEq \u03b9] [AddMonoid \u03b9] [GradedRing \ud835\udc9c]", "(I : Ideal A)", "{\ud835\udc9c}", "[Semiring A]", "[SetLike \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3)", "(I : Ideal A)", "[Semiring A]", "[SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3)", "[DecidableEq \u03b9] [AddMonoid \u03b9] [GradedRing \ud835\udc9c]", "(I : Ideal A)", "{\ud835\udc9c I}", "(\ud835\udc9c I)", "[Semiring A] [DecidableEq \u03b9] [AddMonoid \u03b9]", "[SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3) [GradedRing \ud835\udc9c]", "{\ud835\udc9c}", "{\ud835\udc9c}", "[CommSemiring A]", "[DecidableEq \u03b9] [AddMonoid \u03b9]", "[SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] {\ud835\udc9c : \u03b9 \u2192 \u03c3} [GradedRing \ud835\udc9c]", "(I : Ideal A)", "[Semiring A] [DecidableEq \u03b9] [AddMonoid \u03b9]", "[SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3) [GradedRing \ud835\udc9c]", "(I : Ideal A)", "[Semiring A] [DecidableEq \u03b9] [AddMonoid \u03b9]", "[SetLike \u03c3 A] [AddSubmonoidClass \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3) [GradedRing \ud835\udc9c]", "(I : Ideal A)", "{I \ud835\udc9c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c3 : Type u_2\nA : Type u_3\ninst\u271d\u00b3\u00b2 : Semiring A\ninst\u271d\u00b3\u00b9 : SetLike \u03c3 A\ninst\u271d\u00b3\u2070 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b2\u2079 : DecidableEq \u03b9\ninst\u271d\u00b2\u2078 : AddMonoid \u03b9\ninst\u271d\u00b2\u2077 : Semiring A\ninst\u271d\u00b2\u2076 : SetLike \u03c3 A\ninst\u271d\u00b2\u2075 : Semiring A\ninst\u271d\u00b2\u2074 : SetLike \u03c3 A\ninst\u271d\u00b2\u00b3 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b2\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b2\u00b9 : AddMonoid \u03b9\ninst\u271d\u00b2\u2070 : Semiring A\ninst\u271d\u00b9\u2079 : DecidableEq \u03b9\ninst\u271d\u00b9\u2078 : AddMonoid \u03b9\ninst\u271d\u00b9\u2077 : SetLike \u03c3 A\ninst\u271d\u00b9\u2076 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b9\u2075 : CommSemiring A\ninst\u271d\u00b9\u2074 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b3 : AddMonoid \u03b9\ninst\u271d\u00b9\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9\u00b9 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b9\u2070 : Semiring A\ninst\u271d\u2079 : DecidableEq \u03b9\ninst\u271d\u2078 : AddMonoid \u03b9\ninst\u271d\u2077 : SetLike \u03c3 A\ninst\u271d\u2076 : AddSubmonoidClass \u03c3 A\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : AddMonoid \u03b9\ninst\u271d\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d : GradedRing \ud835\udc9c\nI : Ideal A\nh : IsHomogeneous \ud835\udc9c I\n\u22a2 (homogeneousHull \ud835\udc9c I).toIdeal = I"}, {"line": "apply le_antisymm _ (Ideal.le_toIdeal_homogeneousHull _ _)", "tactic_state": "\u03b9 : Type u_1\n\u03c3 : Type u_2\nA : Type u_3\ninst\u271d\u00b3\u00b2 : Semiring A\ninst\u271d\u00b3\u00b9 : SetLike \u03c3 A\ninst\u271d\u00b3\u2070 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b2\u2079 : DecidableEq \u03b9\ninst\u271d\u00b2\u2078 : AddMonoid \u03b9\ninst\u271d\u00b2\u2077 : Semiring A\ninst\u271d\u00b2\u2076 : SetLike \u03c3 A\ninst\u271d\u00b2\u2075 : Semiring A\ninst\u271d\u00b2\u2074 : SetLike \u03c3 A\ninst\u271d\u00b2\u00b3 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b2\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b2\u00b9 : AddMonoid \u03b9\ninst\u271d\u00b2\u2070 : Semiring A\ninst\u271d\u00b9\u2079 : DecidableEq \u03b9\ninst\u271d\u00b9\u2078 : AddMonoid \u03b9\ninst\u271d\u00b9\u2077 : SetLike \u03c3 A\ninst\u271d\u00b9\u2076 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b9\u2075 : CommSemiring A\ninst\u271d\u00b9\u2074 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b3 : AddMonoid \u03b9\ninst\u271d\u00b9\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9\u00b9 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b9\u2070 : Semiring A\ninst\u271d\u2079 : DecidableEq \u03b9\ninst\u271d\u2078 : AddMonoid \u03b9\ninst\u271d\u2077 : SetLike \u03c3 A\ninst\u271d\u2076 : AddSubmonoidClass \u03c3 A\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : AddMonoid \u03b9\ninst\u271d\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d : GradedRing \ud835\udc9c\nI : Ideal A\nh : IsHomogeneous \ud835\udc9c I\n\u22a2 (homogeneousHull \ud835\udc9c I).toIdeal \u2264 I"}, {"line": "apply Ideal.span_le.2", "tactic_state": "\u03b9 : Type u_1\n\u03c3 : Type u_2\nA : Type u_3\ninst\u271d\u00b3\u00b2 : Semiring A\ninst\u271d\u00b3\u00b9 : SetLike \u03c3 A\ninst\u271d\u00b3\u2070 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b2\u2079 : DecidableEq \u03b9\ninst\u271d\u00b2\u2078 : AddMonoid \u03b9\ninst\u271d\u00b2\u2077 : Semiring A\ninst\u271d\u00b2\u2076 : SetLike \u03c3 A\ninst\u271d\u00b2\u2075 : Semiring A\ninst\u271d\u00b2\u2074 : SetLike \u03c3 A\ninst\u271d\u00b2\u00b3 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b2\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b2\u00b9 : AddMonoid \u03b9\ninst\u271d\u00b2\u2070 : Semiring A\ninst\u271d\u00b9\u2079 : DecidableEq \u03b9\ninst\u271d\u00b9\u2078 : AddMonoid \u03b9\ninst\u271d\u00b9\u2077 : SetLike \u03c3 A\ninst\u271d\u00b9\u2076 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b9\u2075 : CommSemiring A\ninst\u271d\u00b9\u2074 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b3 : AddMonoid \u03b9\ninst\u271d\u00b9\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9\u00b9 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b9\u2070 : Semiring A\ninst\u271d\u2079 : DecidableEq \u03b9\ninst\u271d\u2078 : AddMonoid \u03b9\ninst\u271d\u2077 : SetLike \u03c3 A\ninst\u271d\u2076 : AddSubmonoidClass \u03c3 A\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : AddMonoid \u03b9\ninst\u271d\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d : GradedRing \ud835\udc9c\nI : Ideal A\nh : IsHomogeneous \ud835\udc9c I\n\u22a2 {r | \u2203 i x, \u2191(((decompose \ud835\udc9c) \u2191x) i) = r} \u2286 \u2191I"}, {"line": "rintro _ \u27e8i, x, rfl\u27e9", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\n\u03c3 : Type u_2\nA : Type u_3\ninst\u271d\u00b3\u00b2 : Semiring A\ninst\u271d\u00b3\u00b9 : SetLike \u03c3 A\ninst\u271d\u00b3\u2070 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b2\u2079 : DecidableEq \u03b9\ninst\u271d\u00b2\u2078 : AddMonoid \u03b9\ninst\u271d\u00b2\u2077 : Semiring A\ninst\u271d\u00b2\u2076 : SetLike \u03c3 A\ninst\u271d\u00b2\u2075 : Semiring A\ninst\u271d\u00b2\u2074 : SetLike \u03c3 A\ninst\u271d\u00b2\u00b3 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b2\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b2\u00b9 : AddMonoid \u03b9\ninst\u271d\u00b2\u2070 : Semiring A\ninst\u271d\u00b9\u2079 : DecidableEq \u03b9\ninst\u271d\u00b9\u2078 : AddMonoid \u03b9\ninst\u271d\u00b9\u2077 : SetLike \u03c3 A\ninst\u271d\u00b9\u2076 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b9\u2075 : CommSemiring A\ninst\u271d\u00b9\u2074 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b3 : AddMonoid \u03b9\ninst\u271d\u00b9\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9\u00b9 : AddSubmonoidClass \u03c3 A\ninst\u271d\u00b9\u2070 : Semiring A\ninst\u271d\u2079 : DecidableEq \u03b9\ninst\u271d\u2078 : AddMonoid \u03b9\ninst\u271d\u2077 : SetLike \u03c3 A\ninst\u271d\u2076 : AddSubmonoidClass \u03c3 A\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : AddMonoid \u03b9\ninst\u271d\u00b2 : SetLike \u03c3 A\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 A\n\ud835\udc9c : \u03b9 \u2192 \u03c3\ninst\u271d : GradedRing \ud835\udc9c\nI : Ideal A\nh : IsHomogeneous \ud835\udc9c I\ni : \u03b9\nx : \u21a5I\n\u22a2 \u2191(((decompose \ud835\udc9c) \u2191x) i) \u2208 \u2191I"}, {"line": "exact h _ x.prop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma addOppositeEquiv_support (x : HahnSeries \u0393 (R\u1d43\u1d52\u1d56)) :\n    (addOppositeEquiv x).unop.support = x.support := by\n  ext\n  simp [addOppositeEquiv_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Addition.lean", "context": {"open": ["Finset Function"], "variables": ["{\u0393 \u0393' R S U V \u03b1 : Type*}", "[PartialOrder \u0393]", "[AddMonoid R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0393 : Type u_1\nR : Type u_3\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddMonoid R\nx\u271d : Sort u_8\naddOppositeEquiv : x\u271d\nx : HahnSeries \u0393 R\u1d43\u1d52\u1d56\n\u22a2 sorry = x.support"}, {"line": "ext", "tactic_state": "case h\n\u0393 : Type u_1\nR : Type u_3\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddMonoid R\nx\u271d\u00b9 : Sort u_8\naddOppositeEquiv : x\u271d\u00b9\nx : HahnSeries \u0393 R\u1d43\u1d52\u1d56\nx\u271d : \u0393\n\u22a2 x\u271d \u2208 sorry \u2194 x\u271d \u2208 x.support"}, {"line": "simp [addOppositeEquiv_apply]", "tactic_state": "case h\n\u0393 : Type u_1\nR : Type u_3\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddMonoid R\nx\u271d\u00b9 : Sort u_8\naddOppositeEquiv : x\u271d\u00b9\nx : HahnSeries \u0393 R\u1d43\u1d52\u1d56\nx\u271d : \u0393\n\u22a2 x\u271d \u2208 sorry () \u2194 \u00acx.coeff x\u271d = 0"}]}
{"declaration": "theorem orderTop_add_eq_right {\u0393} [LinearOrder \u0393] {x y : HahnSeries \u0393 R}\n    (hxy : y.orderTop < x.orderTop) : (x + y).orderTop = y.orderTop := by\n  simpa [\u2190 map_add, \u2190 AddOpposite.op_add, hxy] using orderTop_add_eq_left\n    (x := addOppositeEquiv.symm (.op y))\n    (y := addOppositeEquiv.symm (.op x))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Addition.lean", "context": {"open": ["Finset Function"], "variables": ["{\u0393 \u0393' R S U V \u03b1 : Type*}", "[PartialOrder \u0393]", "[AddMonoid R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b9 : AddMonoid R\n\u0393 : Type u_8\ninst\u271d : LinearOrder \u0393\nx y : HahnSeries \u0393 R\nhxy : y.orderTop < x.orderTop\n\u22a2 (x + y).orderTop = y.orderTop"}, {"line": "simpa [\u2190 map_add, \u2190 AddOpposite.op_add, hxy] using orderTop_add_eq_left\n    (x := addOppositeEquiv.symm (.op y))\n    (y := addOppositeEquiv.symm (.op x))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leadingCoeff_add_eq_right {\u0393} [LinearOrder \u0393] {x y : HahnSeries \u0393 R}\n    (hxy : y.orderTop < x.orderTop) : (x + y).leadingCoeff = y.leadingCoeff := by\n  simpa [\u2190 map_add, \u2190 AddOpposite.op_add, hxy] using leadingCoeff_add_eq_left\n    (x := addOppositeEquiv.symm (.op y))\n    (y := addOppositeEquiv.symm (.op x))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Addition.lean", "context": {"open": ["Finset Function"], "variables": ["{\u0393 \u0393' R S U V \u03b1 : Type*}", "[PartialOrder \u0393]", "[AddMonoid R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b9 : AddMonoid R\n\u0393 : Type u_8\ninst\u271d : LinearOrder \u0393\nx y : HahnSeries \u0393 R\nhxy : y.orderTop < x.orderTop\n\u22a2 (x + y).leadingCoeff = y.leadingCoeff"}, {"line": "simpa [\u2190 map_add, \u2190 AddOpposite.op_add, hxy] using leadingCoeff_add_eq_left\n    (x := addOppositeEquiv.symm (.op y))\n    (y := addOppositeEquiv.symm (.op x))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_neg {x : HahnSeries \u0393 R} : (-x).support = x.support := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Addition.lean", "context": {"open": ["Finset Function", "BigOperators"], "variables": ["{\u0393 \u0393' R S U V \u03b1 : Type*}", "[PartialOrder \u0393]", "[AddMonoid R]", "[PartialOrder \u0393']", "[AddCommMonoid R]", "[AddGroup R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0393 : Type u_1\nR : Type u_3\ninst\u271d\u00b3 : PartialOrder \u0393\ninst\u271d\u00b2 : AddMonoid R\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : AddGroup R\nx : HahnSeries \u0393 R\n\u22a2 (-x).support = x.support"}, {"line": "ext", "tactic_state": "case h\n\u0393 : Type u_1\nR : Type u_3\ninst\u271d\u00b3 : PartialOrder \u0393\ninst\u271d\u00b2 : AddMonoid R\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : AddGroup R\nx : HahnSeries \u0393 R\nx\u271d : \u0393\n\u22a2 x\u271d \u2208 (-x).support \u2194 x\u271d \u2208 x.support"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_sub' {x y : HahnSeries \u0393 R} : (x - y).coeff = x.coeff - y.coeff := by\n  ext\n  simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Addition.lean", "context": {"open": ["Finset Function", "BigOperators"], "variables": ["{\u0393 \u0393' R S U V \u03b1 : Type*}", "[PartialOrder \u0393]", "[AddMonoid R]", "[PartialOrder \u0393']", "[AddCommMonoid R]", "[AddGroup R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0393 : Type u_1\nR : Type u_3\ninst\u271d\u00b3 : PartialOrder \u0393\ninst\u271d\u00b2 : AddMonoid R\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : AddGroup R\nx y : HahnSeries \u0393 R\n\u22a2 (x - y).coeff = x.coeff - y.coeff"}, {"line": "ext", "tactic_state": "case h\n\u0393 : Type u_1\nR : Type u_3\ninst\u271d\u00b3 : PartialOrder \u0393\ninst\u271d\u00b2 : AddMonoid R\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : AddGroup R\nx y : HahnSeries \u0393 R\nx\u271d : \u0393\n\u22a2 (x - y).coeff x\u271d = (x.coeff - y.coeff) x\u271d"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_sub {x y : HahnSeries \u0393 R} {a : \u0393} : (x - y).coeff a = x.coeff a - y.coeff a := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Addition.lean", "context": {"open": ["Finset Function", "BigOperators"], "variables": ["{\u0393 \u0393' R S U V \u03b1 : Type*}", "[PartialOrder \u0393]", "[AddMonoid R]", "[PartialOrder \u0393']", "[AddCommMonoid R]", "[AddGroup R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0393 : Type u_1\nR : Type u_3\ninst\u271d\u00b3 : PartialOrder \u0393\ninst\u271d\u00b2 : AddMonoid R\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : AddGroup R\nx y : HahnSeries \u0393 R\na : \u0393\n\u22a2 (x - y).coeff a = x.coeff a - y.coeff a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_single_same (a : \u0393) (r : R) : (single a r).coeff a = r := by\n  classical exact Pi.single_eq_same (f := fun _ => R) a r\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Basic.lean", "context": {"open": ["Finset Function", "Classical in"], "variables": ["{\u0393 \u0393' R S : Type*}", "[PartialOrder \u0393] [Zero R]", "{a b : \u0393} {r : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0393 : Type u_3\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : Zero R\nx\u271d : Sort u_1\nsingle : x\u271d\na : \u0393\nr : R\n\u22a2 sorry = r"}, {"line": "classical exact Pi.single_eq_same (f := fun _ => R) a r", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_single_of_ne (h : b \u2260 a) : (single a r).coeff b = 0 := by\n  classical exact Pi.single_eq_of_ne (f := fun _ => R) h r\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Basic.lean", "context": {"open": ["Finset Function", "Classical in"], "variables": ["{\u0393 \u0393' R S : Type*}", "[PartialOrder \u0393] [Zero R]", "{a b : \u0393} {r : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0393 : Type u_2\ninst\u271d : PartialOrder \u0393\na b : \u0393\nx\u271d : Sort u_1\nsingle : x\u271d\nh : b \u2260 a\n\u22a2 sorry = 0"}, {"line": "classical exact Pi.single_eq_of_ne (f := fun _ => R) h r", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_single_of_ne (h : r \u2260 0) : support (single a r) = {a} := by\n  classical exact Pi.support_single_of_ne h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Basic.lean", "context": {"open": ["Finset Function", "Classical in", "Classical in"], "variables": ["{\u0393 \u0393' R S : Type*}", "[PartialOrder \u0393] [Zero R]", "{a b : \u0393} {r : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0393 : Type u_3\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : Zero R\na : \u0393\nr : R\nx\u271d : Sort u_1\nsingle : x\u271d\nh : r \u2260 0\n\u22a2 support sorry = {a}"}, {"line": "classical exact Pi.support_single_of_ne h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orderTop_single_le : a \u2264 (single a r).orderTop := by\n  by_cases hr : r = 0\n  \u00b7 simp only [hr, map_zero, orderTop_zero, le_top]\n  \u00b7 rw [orderTop_single hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Basic.lean", "context": {"open": ["Finset Function", "Classical in", "Classical in", "Classical in"], "variables": ["{\u0393 \u0393' R S : Type*}", "[PartialOrder \u0393] [Zero R]", "{a b : \u0393} {r : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0393 : Type u_2\ninst\u271d : PartialOrder \u0393\na : \u0393\nx\u271d : Sort u_1\nsingle : x\u271d\n\u22a2 a \u2264 sorry"}, {"line": "by_cases hr : r = 0", "tactic_state": "case pos\n\u0393 : Type u_2\ninst\u271d : PartialOrder \u0393\na : \u0393\nx\u271d : Sort u_1\nsingle : x\u271d\nhr : sorry = 0\n\u22a2 a \u2264 sorry\n---\ncase neg\n\u0393 : Type u_2\ninst\u271d : PartialOrder \u0393\na : \u0393\nx\u271d : Sort u_1\nsingle : x\u271d\nhr : \u00acsorry = 0\n\u22a2 a \u2264 sorry"}, {"line": "\u00b7 simp only [hr, map_zero, orderTop_zero, le_top]", "tactic_state": "case neg\n\u0393 : Type u_2\ninst\u271d : PartialOrder \u0393\na : \u0393\nx\u271d : Sort u_1\nsingle : x\u271d\nhr : \u00acsorry = 0\n\u22a2 a \u2264 sorry"}, {"line": "\u00b7 rw [orderTop_single hr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leadingCoeff_eq_iff {x : HahnSeries \u0393 R} : x.leadingCoeff = 0 \u2194 x = 0 := by\n  refine { mp := ?_, mpr := fun hx => hx \u25b8 leadingCoeff_zero }\n  contrapose!\n  exact fun hx => (leadingCoeff_of_ne hx) \u25b8 coeff_orderTop_ne (orderTop_of_ne hx)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Basic.lean", "context": {"open": ["Finset Function", "Classical in", "Classical in", "Classical in", "Classical in"], "variables": ["{\u0393 \u0393' R S : Type*}", "[PartialOrder \u0393] [Zero R]", "{a b : \u0393} {r : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : Zero R\nx : HahnSeries \u0393 R\n\u22a2 x.leadingCoeff = 0 \u2194 x = 0"}, {"line": "refine { mp := ?_, mpr := fun hx => hx \u25b8 leadingCoeff_zero }", "tactic_state": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : Zero R\nx : HahnSeries \u0393 R\n\u22a2 x.leadingCoeff = 0 \u2192 x = 0"}, {"line": "contrapose!", "tactic_state": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : Zero R\nx : HahnSeries \u0393 R\n\u22a2 x \u2260 0 \u2192 x.leadingCoeff \u2260 0"}, {"line": "exact fun hx => (leadingCoeff_of_ne hx) \u25b8 coeff_orderTop_ne (orderTop_of_ne hx)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_lt_orderTop_iff {x : HahnSeries \u0393 R} (hx : x \u2260 0) :\n    0 < x.orderTop \u2194 0 < x.order := by\n  simp_all [orderTop_of_ne hx, order_of_ne hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Basic.lean", "context": {"open": ["Finset Function", "Classical in", "Classical in", "Classical in", "Classical in", "Classical in"], "variables": ["{\u0393 \u0393' R S : Type*}", "[PartialOrder \u0393] [Zero R]", "{a b : \u0393} {r : R}", "[Zero \u0393]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\ninst\u271d : Zero \u0393\nx : HahnSeries \u0393 R\nhx : x \u2260 0\n\u22a2 0 < x.orderTop \u2194 0 < x.order"}, {"line": "simp_all [orderTop_of_ne hx, order_of_ne hx]", "tactic_state": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\ninst\u271d : Zero \u0393\nx : HahnSeries \u0393 R\nhx : \u00acx.orderTop = \u22a4\n\u22a2 0 < x.orderTop \u2194 0 < x.order"}]}
{"declaration": "theorem zero_lt_orderTop_of_order {x : HahnSeries \u0393 R} (hx : 0 < x.order) : 0 < x.orderTop := by\n  by_cases h : x = 0\n  \u00b7 simp_all only [order_zero, lt_self_iff_false]\n  \u00b7 exact (zero_lt_orderTop_iff h).mpr hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Basic.lean", "context": {"open": ["Finset Function", "Classical in", "Classical in", "Classical in", "Classical in", "Classical in"], "variables": ["{\u0393 \u0393' R S : Type*}", "[PartialOrder \u0393] [Zero R]", "{a b : \u0393} {r : R}", "[Zero \u0393]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\ninst\u271d : Zero \u0393\nx : HahnSeries \u0393 R\nhx : 0 < x.order\n\u22a2 0 < x.orderTop"}, {"line": "by_cases h : x = 0", "tactic_state": "case pos\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\ninst\u271d : Zero \u0393\nx : HahnSeries \u0393 R\nhx : 0 < x.order\nh : x = 0\n\u22a2 0 < x.orderTop\n---\ncase neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\ninst\u271d : Zero \u0393\nx : HahnSeries \u0393 R\nhx : 0 < x.order\nh : \u00acx = 0\n\u22a2 0 < x.orderTop"}, {"line": "\u00b7 simp_all only [order_zero, lt_self_iff_false]", "tactic_state": "case neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\ninst\u271d : Zero \u0393\nx : HahnSeries \u0393 R\nhx : 0 < x.order\nh : \u00acx = 0\n\u22a2 0 < x.orderTop"}, {"line": "\u00b7 exact (zero_lt_orderTop_iff h).mpr hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_le_orderTop_iff {x : HahnSeries \u0393 R} : 0 \u2264 x.orderTop \u2194 0 \u2264 x.order := by\n  by_cases h : x = 0\n  \u00b7 simp_all\n  \u00b7 simp_all [order_of_ne h, orderTop_of_ne h, zero_lt_orderTop_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Basic.lean", "context": {"open": ["Finset Function", "Classical in", "Classical in", "Classical in", "Classical in", "Classical in"], "variables": ["{\u0393 \u0393' R S : Type*}", "[PartialOrder \u0393] [Zero R]", "{a b : \u0393} {r : R}", "[Zero \u0393]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\ninst\u271d : Zero \u0393\nx : HahnSeries \u0393 R\n\u22a2 0 \u2264 x.orderTop \u2194 0 \u2264 x.order"}, {"line": "by_cases h : x = 0", "tactic_state": "case pos\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\ninst\u271d : Zero \u0393\nx : HahnSeries \u0393 R\nh : x = 0\n\u22a2 0 \u2264 x.orderTop \u2194 0 \u2264 x.order\n---\ncase neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\ninst\u271d : Zero \u0393\nx : HahnSeries \u0393 R\nh : \u00acx = 0\n\u22a2 0 \u2264 x.orderTop \u2194 0 \u2264 x.order"}, {"line": "\u00b7 simp_all", "tactic_state": "case neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\ninst\u271d : Zero \u0393\nx : HahnSeries \u0393 R\nh : \u00acx = 0\n\u22a2 0 \u2264 x.orderTop \u2194 0 \u2264 x.order"}, {"line": "\u00b7 simp_all [order_of_ne h, orderTop_of_ne h, zero_lt_orderTop_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leadingCoeff_eq {x : HahnSeries \u0393 R} : x.leadingCoeff = x.coeff x.order := by\n  by_cases h : x = 0\n  \u00b7 rw [h, leadingCoeff_zero, coeff_zero]\n  \u00b7 rw [leadingCoeff_of_ne h, order_of_ne h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Basic.lean", "context": {"open": ["Finset Function", "Classical in", "Classical in", "Classical in", "Classical in", "Classical in"], "variables": ["{\u0393 \u0393' R S : Type*}", "[PartialOrder \u0393] [Zero R]", "{a b : \u0393} {r : R}", "[Zero \u0393]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\ninst\u271d : Zero \u0393\nx : HahnSeries \u0393 R\n\u22a2 x.leadingCoeff = x.coeff x.order"}, {"line": "by_cases h : x = 0", "tactic_state": "case pos\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\ninst\u271d : Zero \u0393\nx : HahnSeries \u0393 R\nh : x = 0\n\u22a2 x.leadingCoeff = x.coeff x.order\n---\ncase neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\ninst\u271d : Zero \u0393\nx : HahnSeries \u0393 R\nh : \u00acx = 0\n\u22a2 x.leadingCoeff = x.coeff x.order"}, {"line": "\u00b7 rw [h, leadingCoeff_zero, coeff_zero]", "tactic_state": "case neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\ninst\u271d : Zero \u0393\nx : HahnSeries \u0393 R\nh : \u00acx = 0\n\u22a2 x.leadingCoeff = x.coeff x.order"}, {"line": "\u00b7 rw [leadingCoeff_of_ne h, order_of_ne h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem order_one [MulZeroOneClass R] : order (1 : HahnSeries \u0393 R) = 0 := by\n  cases subsingleton_or_nontrivial R\n  \u00b7 rw [Subsingleton.elim (1 : HahnSeries \u0393 R) 0, order_zero]\n  \u00b7 exact order_single one_ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Multiplication.lean", "context": {"open": ["Finset Function Pointwise", "Classical in"], "variables": ["{\u0393 \u0393' R S V : Type*}", "[Zero \u0393] [PartialOrder \u0393]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nx\u271d : Sort u_2\norder : x\u271d\ninst\u271d : MulZeroOneClass R\n\u22a2 sorry = 0"}, {"line": "cases subsingleton_or_nontrivial R", "tactic_state": "case inl\nR : Type u_1\nx\u271d : Sort u_2\norder : x\u271d\ninst\u271d : MulZeroOneClass R\nh\u271d : Subsingleton R\n\u22a2 sorry = 0\n---\ncase inr\nR : Type u_1\nx\u271d : Sort u_2\norder : x\u271d\ninst\u271d : MulZeroOneClass R\nh\u271d : Nontrivial R\n\u22a2 sorry = 0"}, {"line": "\u00b7 rw [Subsingleton.elim (1 : HahnSeries \u0393 R) 0, order_zero]", "tactic_state": "case inr\nR : Type u_1\nx\u271d : Sort u_2\norder : x\u271d\ninst\u271d : MulZeroOneClass R\nh\u271d : Nontrivial R\n\u22a2 sorry = 0"}, {"line": "\u00b7 exact order_single one_ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leadingCoeff_one [MulZeroOneClass R] : (1 : HahnSeries \u0393 R).leadingCoeff = 1 := by\n  simp [leadingCoeff_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Multiplication.lean", "context": {"open": ["Finset Function Pointwise", "Classical in"], "variables": ["{\u0393 \u0393' R S V : Type*}", "[Zero \u0393] [PartialOrder \u0393]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0393 : Type u_2\ninst\u271d\u00b2 : Zero \u0393\ninst\u271d\u00b9 : PartialOrder \u0393\nR : Type u_1\ninst\u271d : MulZeroOneClass R\n\u22a2 HahnSeries.leadingCoeff 1 = 1"}, {"line": "simp [leadingCoeff_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_smul_subset_vadd_support [MulZeroClass R] [SMulWithZero R V] {x : HahnSeries \u0393 R}\n    {y : HahnModule \u0393' R V} :\n    ((of R).symm (x \u2022 y)).support \u2286 x.support +\u1d65 ((of R).symm y).support := by\n  exact support_smul_subset_vadd_support'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Multiplication.lean", "context": {"open": ["Finset Function Pointwise", "Classical in"], "variables": ["{\u0393 \u0393' R S V : Type*}", "[Zero \u0393] [PartialOrder \u0393]", "[PartialOrder \u0393] [Zero V] [SMul R V]", "[PartialOrder \u0393] [AddCommMonoid V] [SMul R V]", "[PartialOrder \u0393'] [VAdd \u0393 \u0393'] [IsOrderedCancelVAdd \u0393 \u0393']", "[PartialOrder \u0393] [PartialOrder \u0393'] [VAdd \u0393 \u0393'] [IsOrderedCancelVAdd \u0393 \u0393']", "[Zero R]", "[PartialOrder \u0393] [PartialOrder \u0393'] [VAdd \u0393 \u0393'] [IsOrderedCancelVAdd \u0393 \u0393'] [AddCommMonoid V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0393 : Type u_4\nV : Type u_3\nR : Type u_2\n\u0393' : Type u_5\ninst\u271d\u00b2\u00b2 : Zero \u0393\ninst\u271d\u00b2\u00b9 inst\u271d\u00b2\u2070 : PartialOrder \u0393\ninst\u271d\u00b9\u2079 : Zero V\ninst\u271d\u00b9\u2078 : SMul R V\ninst\u271d\u00b9\u2077 : PartialOrder \u0393\ninst\u271d\u00b9\u2076 : AddCommMonoid V\ninst\u271d\u00b9\u2075 : SMul R V\ninst\u271d\u00b9\u2074 : PartialOrder \u0393'\ninst\u271d\u00b9\u00b3 : VAdd \u0393 \u0393'\ninst\u271d\u00b9\u00b2 : IsOrderedCancelVAdd \u0393 \u0393'\ninst\u271d\u00b9\u00b9 : PartialOrder \u0393\ninst\u271d\u00b9\u2070 : PartialOrder \u0393'\ninst\u271d\u2079 : VAdd \u0393 \u0393'\ninst\u271d\u2078 : IsOrderedCancelVAdd \u0393 \u0393'\ninst\u271d\u2077 : Zero R\ninst\u271d\u2076 : PartialOrder \u0393\ninst\u271d\u2075 : PartialOrder \u0393'\ninst\u271d\u2074 : VAdd \u0393 \u0393'\ninst\u271d\u00b3 : IsOrderedCancelVAdd \u0393 \u0393'\ninst\u271d\u00b2 : AddCommMonoid V\nx\u271d : Sort u_1\nof : x\u271d\ninst\u271d\u00b9 : MulZeroClass R\ninst\u271d : SMulWithZero R V\nx : HahnSeries \u0393 R\ny : HahnModule \u0393' R V\n\u22a2 sorry \u2286 x.support +\u1d65 sorry"}, {"line": "exact support_smul_subset_vadd_support'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem single_pow (a : \u0393) (n : \u2115) (r : R) : single a r ^ n = single (n \u2022 a) (r ^ n) := by\n  induction' n with n IH\n  \u00b7 ext; simp only [pow_zero, coeff_one, zero_smul, coeff_single]\n  \u00b7 rw [pow_succ, pow_succ, IH, single_mul_single, succ_nsmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Multiplication.lean", "context": {"open": ["Finset Function Pointwise", "Classical in"], "variables": ["{\u0393 \u0393' R S V : Type*}", "[Zero \u0393] [PartialOrder \u0393]", "[PartialOrder \u0393] [Zero V] [SMul R V]", "[PartialOrder \u0393] [AddCommMonoid V] [SMul R V]", "[PartialOrder \u0393'] [VAdd \u0393 \u0393'] [IsOrderedCancelVAdd \u0393 \u0393']", "[PartialOrder \u0393] [PartialOrder \u0393'] [VAdd \u0393 \u0393'] [IsOrderedCancelVAdd \u0393 \u0393']", "[Zero R]", "[PartialOrder \u0393] [PartialOrder \u0393'] [VAdd \u0393 \u0393'] [IsOrderedCancelVAdd \u0393 \u0393'] [AddCommMonoid V]", "[AddCommMonoid \u0393] [PartialOrder \u0393] [IsOrderedCancelAddMonoid \u0393]", "{\u0393 : Type*} [AddCommMonoid \u0393] [LinearOrder \u0393] [IsOrderedCancelAddMonoid \u0393]", "[PartialOrder \u0393'] [AddAction \u0393 \u0393'] [IsOrderedCancelVAdd \u0393 \u0393'] [AddCommMonoid V]", "[NonUnitalNonAssocSemiring R]", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\ninst\u271d\u2075 : Zero R\n\u0393 : Type u_1\ninst\u271d\u2074 : AddCommMonoid \u0393\ninst\u271d\u00b3 : LinearOrder \u0393\ninst\u271d\u00b2 : IsOrderedCancelAddMonoid \u0393\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring R\ninst\u271d : Semiring R\nx\u271d : Sort u_2\nsingle : x\u271d\na : \u0393\nn : \u2115\nr : R\n\u22a2 sorry ^ n = sorry"}, {"line": "induction' n with n IH", "tactic_state": "case zero\nR : Type u_5\ninst\u271d\u2075 : Zero R\n\u0393 : Type u_1\ninst\u271d\u2074 : AddCommMonoid \u0393\ninst\u271d\u00b3 : LinearOrder \u0393\ninst\u271d\u00b2 : IsOrderedCancelAddMonoid \u0393\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring R\ninst\u271d : Semiring R\nx\u271d : Sort u_2\nsingle : x\u271d\na : \u0393\nr : R\n\u22a2 sorry ^ 0 = sorry\n---\ncase succ\nR : Type u_5\ninst\u271d\u2075 : Zero R\n\u0393 : Type u_1\ninst\u271d\u2074 : AddCommMonoid \u0393\ninst\u271d\u00b3 : LinearOrder \u0393\ninst\u271d\u00b2 : IsOrderedCancelAddMonoid \u0393\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring R\ninst\u271d : Semiring R\nx\u271d : Sort u_2\nsingle : x\u271d\na : \u0393\nr : R\nn : \u2115\nIH : sorry ^ n = sorry\n\u22a2 sorry ^ (n + 1) = sorry"}, {"line": "\u00b7 ext; simp only [pow_zero, coeff_one, zero_smul, coeff_single]", "tactic_state": "case succ\nR : Type u_5\ninst\u271d\u2075 : Zero R\n\u0393 : Type u_1\ninst\u271d\u2074 : AddCommMonoid \u0393\ninst\u271d\u00b3 : LinearOrder \u0393\ninst\u271d\u00b2 : IsOrderedCancelAddMonoid \u0393\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring R\ninst\u271d : Semiring R\nx\u271d : Sort u_2\nsingle : x\u271d\na : \u0393\nr : R\nn : \u2115\nIH : sorry ^ n = sorry\n\u22a2 sorry ^ (n + 1) = sorry"}, {"line": "\u00b7 rw [pow_succ, pow_succ, IH, single_mul_single, succ_nsmul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_C [NonAssocSemiring S] (a : R) (f : R \u2192+* S) :\n    ((C a).map f : HahnSeries \u0393 S) = C (f a) := by\n  ext g\n  by_cases h : g = 0 <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Multiplication.lean", "context": {"open": ["Finset Function Pointwise", "Classical in"], "variables": ["{\u0393 \u0393' R S V : Type*}", "[Zero \u0393] [PartialOrder \u0393]", "[PartialOrder \u0393] [Zero V] [SMul R V]", "[PartialOrder \u0393] [AddCommMonoid V] [SMul R V]", "[PartialOrder \u0393'] [VAdd \u0393 \u0393'] [IsOrderedCancelVAdd \u0393 \u0393']", "[PartialOrder \u0393] [PartialOrder \u0393'] [VAdd \u0393 \u0393'] [IsOrderedCancelVAdd \u0393 \u0393']", "[Zero R]", "[PartialOrder \u0393] [PartialOrder \u0393'] [VAdd \u0393 \u0393'] [IsOrderedCancelVAdd \u0393 \u0393'] [AddCommMonoid V]", "[AddCommMonoid \u0393] [PartialOrder \u0393] [IsOrderedCancelAddMonoid \u0393]", "{\u0393 : Type*} [AddCommMonoid \u0393] [LinearOrder \u0393] [IsOrderedCancelAddMonoid \u0393]", "[PartialOrder \u0393'] [AddAction \u0393 \u0393'] [IsOrderedCancelVAdd \u0393 \u0393'] [AddCommMonoid V]", "[NonUnitalNonAssocSemiring R]", "[Semiring R]", "[NonAssocSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d\u2077 : Zero R\n\u0393 : Type u_1\ninst\u271d\u2076 : AddCommMonoid \u0393\ninst\u271d\u2075 : LinearOrder \u0393\ninst\u271d\u2074 : IsOrderedCancelAddMonoid \u0393\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : NonAssocSemiring R\nS : Type u_2\nx\u271d : Sort u_3\nC : x\u271d\ninst\u271d : NonAssocSemiring S\na : R\nf : R \u2192+* S\n\u22a2 sorry = sorry"}, {"line": "ext g", "tactic_state": "case coeff.h\nR : Type u_4\ninst\u271d\u2077 : Zero R\n\u0393 : Type u_1\ninst\u271d\u2076 : AddCommMonoid \u0393\ninst\u271d\u2075 : LinearOrder \u0393\ninst\u271d\u2074 : IsOrderedCancelAddMonoid \u0393\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : NonAssocSemiring R\nS : Type u_2\nx\u271d : Sort u_3\nC : x\u271d\ninst\u271d : NonAssocSemiring S\na : R\nf : R \u2192+* S\ng : \u0393\n\u22a2 sorry.coeff g = sorry.coeff g"}, {"line": "by_cases h : g = 0 <;> simp [h]", "tactic_state": "case coeff.h\nR : Type u_4\ninst\u271d\u2077 : Zero R\n\u0393 : Type u_1\ninst\u271d\u2076 : AddCommMonoid \u0393\ninst\u271d\u2075 : LinearOrder \u0393\ninst\u271d\u2074 : IsOrderedCancelAddMonoid \u0393\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : NonAssocSemiring R\nS : Type u_2\nx\u271d : Sort u_3\nC : x\u271d\ninst\u271d : NonAssocSemiring S\na : R\nf : R \u2192+* S\ng : \u0393\n\u22a2 OfNat \u0393 0"}]}
{"declaration": "theorem order_C {r : R} : order (C r : HahnSeries \u0393 R) = 0 := by\n  by_cases h : r = 0\n  \u00b7 rw [h, C_zero, order_zero]\n  \u00b7 exact order_single h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/Multiplication.lean", "context": {"open": ["Finset Function Pointwise", "Classical in"], "variables": ["{\u0393 \u0393' R S V : Type*}", "[Zero \u0393] [PartialOrder \u0393]", "[PartialOrder \u0393] [Zero V] [SMul R V]", "[PartialOrder \u0393] [AddCommMonoid V] [SMul R V]", "[PartialOrder \u0393'] [VAdd \u0393 \u0393'] [IsOrderedCancelVAdd \u0393 \u0393']", "[PartialOrder \u0393] [PartialOrder \u0393'] [VAdd \u0393 \u0393'] [IsOrderedCancelVAdd \u0393 \u0393']", "[Zero R]", "[PartialOrder \u0393] [PartialOrder \u0393'] [VAdd \u0393 \u0393'] [IsOrderedCancelVAdd \u0393 \u0393'] [AddCommMonoid V]", "[AddCommMonoid \u0393] [PartialOrder \u0393] [IsOrderedCancelAddMonoid \u0393]", "{\u0393 : Type*} [AddCommMonoid \u0393] [LinearOrder \u0393] [IsOrderedCancelAddMonoid \u0393]", "[PartialOrder \u0393'] [AddAction \u0393 \u0393'] [IsOrderedCancelVAdd \u0393 \u0393'] [AddCommMonoid V]", "[NonUnitalNonAssocSemiring R]", "[Semiring R]", "[NonAssocSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NonAssocSemiring R\nx\u271d : Sort u_2\norder : x\u271d\nr : R\n\u22a2 sorry = 0"}, {"line": "by_cases h : r = 0", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NonAssocSemiring R\nx\u271d : Sort u_2\norder : x\u271d\nr : R\n\u22a2 OfNat R 0\n---\ncase pos\nR : Type u_3\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NonAssocSemiring R\nx\u271d : Sort u_2\norder : x\u271d\nr : R\nh : r = 0\n\u22a2 sorry = 0\n---\ncase neg\nR : Type u_3\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NonAssocSemiring R\nx\u271d : Sort u_2\norder : x\u271d\nr : R\nh : \u00acr = 0\n\u22a2 sorry = 0"}, {"line": "\u00b7 rw [h, C_zero, order_zero]", "tactic_state": "case pos\nR : Type u_3\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NonAssocSemiring R\nx\u271d : Sort u_2\norder : x\u271d\nr : R\nh : r = 0\n\u22a2 sorry = 0\n---\ncase neg\nR : Type u_3\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NonAssocSemiring R\nx\u271d : Sort u_2\norder : x\u271d\nr : R\nh : \u00acr = 0\n\u22a2 sorry = 0"}, {"line": "\u00b7 exact order_single h", "tactic_state": "case neg\nR : Type u_3\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NonAssocSemiring R\nx\u271d : Sort u_2\norder : x\u271d\nr : R\nh : \u00acr = 0\n\u22a2 sorry = 0"}]}
{"declaration": "theorem ofPowerSeries_apply_coeff (x : PowerSeries R) (n : \u2115) :\n    (ofPowerSeries \u0393 R x).coeff n = PowerSeries.coeff R n x := by simp [ofPowerSeries_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/PowerSeries.lean", "context": {"open": ["Finset Function Pointwise Polynomial"], "variables": ["{\u0393 R : Type*}", "[Semiring R]", "(\u0393 R) [Semiring \u0393] [PartialOrder \u0393] [IsStrictOrderedRing \u0393]", "{\u0393} {R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d : Semiring R\nx\u271d : Sort u_3\nofPowerSeries : x\u271d\nx : PowerSeries R\nn : \u2115\n\u22a2 sorry = (PowerSeries.coeff R n) x"}, {"line": "simp [ofPowerSeries_apply]", "tactic_state": "R : Type u_2\ninst\u271d : Semiring R\nx\u271d : Sort u_3\nofPowerSeries : x\u271d\nx : PowerSeries R\nn : \u2115\n\u22a2 sorry () = (PowerSeries.coeff R n) x"}]}
{"declaration": "theorem ofPowerSeries_X_pow {R} [Semiring R] (n : \u2115) :\n    ofPowerSeries \u0393 R (PowerSeries.X ^ n) = single (n : \u0393) 1 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HahnSeries/PowerSeries.lean", "context": {"open": ["Finset Function Pointwise Polynomial"], "variables": ["{\u0393 R : Type*}", "[Semiring R]", "(\u0393 R) [Semiring \u0393] [PartialOrder \u0393] [IsStrictOrderedRing \u0393]", "{\u0393} {R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_3\nofPowerSeries : x\u271d\u00b9\nx\u271d : Sort u_4\nsingle : x\u271d\nR : Type u_5\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "x\u271d\u00b9 : Sort u_3\nofPowerSeries : x\u271d\u00b9\nx\u271d : Sort u_4\nsingle : x\u271d\nR : Type u_5\ninst\u271d : Semiring R\nn : \u2115\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem antipode_one :\n    HopfAlgebra.antipode (R := R) (1 : A) = 1 := by\n  simpa [Algebra.TensorProduct.one_def] using mul_antipode_rTensor_comul_apply (R := R) (1 : A)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HopfAlgebra/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [HopfAlgebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : HopfAlgebra R A\n\u22a2 HopfAlgebraStruct.antipode 1 = 1"}, {"line": "simpa [Algebra.TensorProduct.one_def] using mul_antipode_rTensor_comul_apply (R := R) (1 : A)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sum_antipode_mul_eq {a : A} (repr : Repr R a) :\n    \u2211 i \u2208 repr.index, antipode (R := R) (repr.left i) * repr.right i =\n      algebraMap R A (counit a) := by\n  simpa [\u2190 repr.eq, map_sum] using congr($(mul_antipode_rTensor_comul (R := R)) a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HopfAlgebra/Basic.lean", "context": {"open": ["Coalgebra"], "variables": ["{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [HopfAlgebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : HopfAlgebra R A\nx\u271d : Sort u_1\nantipode : x\u271d\na : A\nrepr : Coalgebra.Repr R a\n\u22a2 \u2211 i \u2208 repr.index, sorry * repr.right i = (algebraMap R A) (counit a)"}, {"line": "simpa [\u2190 repr.eq, map_sum] using congr($(mul_antipode_rTensor_comul (R := R)) a)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sum_mul_antipode_eq {a : A} (repr : Repr R a) :\n    \u2211 i \u2208 repr.index, repr.left i * antipode (R := R) (repr.right i) =\n      algebraMap R A (counit a) := by\n  simpa [\u2190 repr.eq, map_sum] using congr($(mul_antipode_lTensor_comul (R := R)) a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HopfAlgebra/Basic.lean", "context": {"open": ["Coalgebra"], "variables": ["{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [HopfAlgebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : HopfAlgebra R A\nx\u271d : Sort u_1\nantipode : x\u271d\na : A\nrepr : Coalgebra.Repr R a\n\u22a2 \u2211 i \u2208 repr.index, repr.left i * sorry = (algebraMap R A) (counit a)"}, {"line": "simpa [\u2190 repr.eq, map_sum] using congr($(mul_antipode_lTensor_comul (R := R)) a)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma antipode_single (g : G) (a : A) :\n    antipode (R := R) (single g a) = single g\u207b\u00b9 (antipode (R := R) a) := by\n  simp [MonoidAlgebra, antipode]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HopfAlgebra/MonoidAlgebra.lean", "context": {"open": ["HopfAlgebra"], "variables": ["{R A : Type*} [CommSemiring R] [Semiring A] [HopfAlgebra R A]", "{G : Type*} [Group G]", "(R A G) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Semiring A\ninst\u271d\u00b9 : HopfAlgebra R A\nG : Type u_3\ninst\u271d : Group G\nx\u271d : Sort u_4\nsingle : x\u271d\ng : G\na : A\n\u22a2 antipode sorry = sorry"}, {"line": "simp [MonoidAlgebra, antipode]", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Semiring A\ninst\u271d\u00b9 : HopfAlgebra R A\nG : Type u_3\ninst\u271d : Group G\nx\u271d : Sort u_4\nsingle : x\u271d\ng : G\na : A\n\u22a2 antipode (sorry ()) = sorry ()"}]}
{"declaration": "lemma antipode_single (g : G) (a : A) :\n    antipode (R := R) (single g a) = single (-g) (antipode (R := R) a) := by\n  simp [AddMonoidAlgebra, antipode]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HopfAlgebra/MonoidAlgebra.lean", "context": {"open": ["HopfAlgebra", "Coalgebra in"], "variables": ["{R A : Type*} [CommSemiring R] [Semiring A] [HopfAlgebra R A]", "{G : Type*} [Group G]", "(R A G) in", "{R A : Type*} [CommSemiring R] [Semiring A] [HopfAlgebra R A]", "{G : Type*} [AddGroup G]", "(R A G) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d : AddGroup G\nR : Type u_5\nA : Sort u_6\nx\u271d : Sort u_3\nsingle : x\u271d\ng : G\na : A\n\u22a2 antipode sorry = sorry"}, {"line": "simp [AddMonoidAlgebra, antipode]", "tactic_state": "G : Type u_2\ninst\u271d : AddGroup G\nR : Type u_5\nA : Sort u_6\nx\u271d : Sort u_3\nsingle : x\u271d\ng : G\na : A\n\u22a2 antipode (sorry ()) = sorry ()"}]}
{"declaration": "theorem antipode_C_mul_T (a : A) (n : \u2124) :\n    HopfAlgebra.antipode (R := R) (C a * T n) = C (HopfAlgebra.antipode (R := R) a) * T (-n) := by\n  simp [\u2190 single_eq_C_mul_T]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/HopfAlgebra/MonoidAlgebra.lean", "context": {"open": ["HopfAlgebra", "Coalgebra in", "Coalgebra in", "Finsupp"], "variables": ["{R A : Type*} [CommSemiring R] [Semiring A] [HopfAlgebra R A]", "{G : Type*} [Group G]", "(R A G) in", "{R A : Type*} [CommSemiring R] [Semiring A] [HopfAlgebra R A]", "{G : Type*} [AddGroup G]", "(R A G) in", "(R A : Type*) [CommSemiring R] [Semiring A] [HopfAlgebra R A]", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : HopfAlgebra R A\nx\u271d\u00b9 : Sort u_5\nC : x\u271d\u00b9\nx\u271d : Sort u_6\nT : x\u271d\na : A\nn : \u2124\n\u22a2 antipode (sorry * sorry) = sorry * sorry"}, {"line": "simp [\u2190 single_eq_C_mul_T]", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : HopfAlgebra R A\nx\u271d\u00b9 : Sort u_5\nC : x\u271d\u00b9\nx\u271d : Sort u_6\nT : x\u271d\na : A\nn : \u2124\n\u22a2 antipode (sorry () * sorry ()) = sorry () * sorry ()"}]}
{"declaration": "theorem pow_mem_of_pow_mem {m n : \u2115} (ha : a ^ m \u2208 I) (h : m \u2264 n) : a ^ n \u2208 I := by\n  rw [\u2190 Nat.add_sub_of_le h]\n  rw [add_comm]\n  rw [pow_add]\n  exact I.mul_mem_left _ ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Defs.lean", "context": {"open": ["Set Function", "Pointwise"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {F : Type w}", "[Semiring \u03b1] (I : Ideal \u03b1) {a b : \u03b1}", "(a)", "{a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Semiring \u03b1\nI : Ideal \u03b1\na : \u03b1\nm n : \u2115\nha : a ^ m \u2208 I\nh : m \u2264 n\n\u22a2 a ^ n \u2208 I"}, {"line": "rw [\u2190 Nat.add_sub_of_le h]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Semiring \u03b1\nI : Ideal \u03b1\na : \u03b1\nm n : \u2115\nha : a ^ m \u2208 I\nh : m \u2264 n\n\u22a2 a ^ (m + (n - m)) \u2208 I"}, {"line": "rw [add_comm]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Semiring \u03b1\nI : Ideal \u03b1\na : \u03b1\nm n : \u2115\nha : a ^ m \u2208 I\nh : m \u2264 n\n\u22a2 a ^ (n - m + m) \u2208 I"}, {"line": "rw [pow_add]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Semiring \u03b1\nI : Ideal \u03b1\na : \u03b1\nm n : \u2115\nha : a ^ m \u2208 I\nh : m \u2264 n\n\u22a2 a ^ (n - m) * a ^ m \u2208 I"}, {"line": "exact I.mul_mem_left _ ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Ideal.exists_ideal_le_liesOver_of_le [Algebra.HasGoingDown R S]\n    {p q : Ideal R} [p.IsPrime] [q.IsPrime] (Q : Ideal S) [Q.IsPrime] [Q.LiesOver q]\n    (hle : p \u2264 q) :\n    \u2203 P \u2264 Q, P.IsPrime \u2227 P.LiesOver p := by\n  by_cases h : p = q\n  \u00b7 subst h\n    use Q\n  \u00b7 have := Q.over_def q\n    subst this\n    exact Algebra.HasGoingDown.exists_ideal_le_liesOver_of_lt Q (lt_of_le_of_ne hle h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/GoingDown.lean", "context": {"open": [], "variables": ["{R S : Type*} [CommRing R] [CommRing S] [Algebra R S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Algebra.HasGoingDown R S\np q : Ideal R\ninst\u271d\u00b3 : p.IsPrime\ninst\u271d\u00b2 : q.IsPrime\nQ : Ideal S\ninst\u271d\u00b9 : Q.IsPrime\ninst\u271d : Q.LiesOver q\nhle : p \u2264 q\n\u22a2 \u2203 P \u2264 Q, P.IsPrime \u2227 P.LiesOver p"}, {"line": "by_cases h : p = q", "tactic_state": "case pos\nR : Type u_1\nS : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Algebra.HasGoingDown R S\np q : Ideal R\ninst\u271d\u00b3 : p.IsPrime\ninst\u271d\u00b2 : q.IsPrime\nQ : Ideal S\ninst\u271d\u00b9 : Q.IsPrime\ninst\u271d : Q.LiesOver q\nhle : p \u2264 q\nh : p = q\n\u22a2 \u2203 P \u2264 Q, P.IsPrime \u2227 P.LiesOver p\n---\ncase neg\nR : Type u_1\nS : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Algebra.HasGoingDown R S\np q : Ideal R\ninst\u271d\u00b3 : p.IsPrime\ninst\u271d\u00b2 : q.IsPrime\nQ : Ideal S\ninst\u271d\u00b9 : Q.IsPrime\ninst\u271d : Q.LiesOver q\nhle : p \u2264 q\nh : \u00acp = q\n\u22a2 \u2203 P \u2264 Q, P.IsPrime \u2227 P.LiesOver p"}, {"line": "\u00b7 subst h\n    use Q", "tactic_state": "case neg\nR : Type u_1\nS : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Algebra.HasGoingDown R S\np q : Ideal R\ninst\u271d\u00b3 : p.IsPrime\ninst\u271d\u00b2 : q.IsPrime\nQ : Ideal S\ninst\u271d\u00b9 : Q.IsPrime\ninst\u271d : Q.LiesOver q\nhle : p \u2264 q\nh : \u00acp = q\n\u22a2 \u2203 P \u2264 Q, P.IsPrime \u2227 P.LiesOver p"}, {"line": "\u00b7 have := Q.over_def q\n    subst this\n    exact Algebra.HasGoingDown.exists_ideal_le_liesOver_of_lt Q (lt_of_le_of_ne hle h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y \u2194 (x - y : R) \u2208 I ^ 2 := by\n  rw [\u2190 sub_eq_zero]\n  exact I.mem_toCotangent_ker\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Cotangent.lean", "context": {"open": [], "variables": ["{R : Type u} {S : Type v} {S' : Type w} [CommRing R] [CommSemiring S] [Algebra S R]", "[CommSemiring S'] [Algebra S' R] [Algebra S S'] [IsScalarTower S S' R] (I : Ideal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nI : Ideal R\nx y : \u21a5I\n\u22a2 I.toCotangent x = I.toCotangent y \u2194 \u2191x - \u2191y \u2208 I ^ 2"}, {"line": "rw [\u2190 sub_eq_zero]", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nI : Ideal R\nx y : \u21a5I\n\u22a2 I.toCotangent x - I.toCotangent y = 0 \u2194 \u2191x - \u2191y \u2208 I ^ 2"}, {"line": "exact I.mem_toCotangent_ker", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cotangent_subsingleton_iff : Subsingleton I.Cotangent \u2194 IsIdempotentElem I := by\n  constructor\n  \u00b7 intro H\n    refine (pow_two I).symm.trans (le_antisymm (Ideal.pow_le_self two_ne_zero) ?_)\n    exact fun x hx => (I.toCotangent_eq_zero \u27e8x, hx\u27e9).mp (Subsingleton.elim _ _)\n  \u00b7 exact fun e =>\n      \u27e8fun x y =>\n        Quotient.inductionOn\u2082' x y fun x y =>\n          I.toCotangent_eq.mpr <| ((pow_two I).trans e).symm \u25b8 I.sub_mem x.prop y.prop\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Cotangent.lean", "context": {"open": [], "variables": ["{R : Type u} {S : Type v} {S' : Type w} [CommRing R] [CommSemiring S] [Algebra S R]", "[CommSemiring S'] [Algebra S' R] [Algebra S S'] [IsScalarTower S S' R] (I : Ideal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nI : Ideal R\n\u22a2 Subsingleton I.Cotangent \u2194 IsIdempotentElem I"}, {"line": "constructor", "tactic_state": "case mp\nR : Type u\ninst\u271d : CommRing R\nI : Ideal R\n\u22a2 Subsingleton I.Cotangent \u2192 IsIdempotentElem I\n---\ncase mpr\nR : Type u\ninst\u271d : CommRing R\nI : Ideal R\n\u22a2 IsIdempotentElem I \u2192 Subsingleton I.Cotangent"}, {"line": "\u00b7 intro H\n    refine (pow_two I).symm.trans (le_antisymm (Ideal.pow_le_self two_ne_zero) ?_)\n    exact fun x hx => (I.toCotangent_eq_zero \u27e8x, hx\u27e9).mp (Subsingleton.elim _ _)", "tactic_state": "case mpr\nR : Type u\ninst\u271d : CommRing R\nI : Ideal R\n\u22a2 IsIdempotentElem I \u2192 Subsingleton I.Cotangent"}, {"line": "\u00b7 exact fun e =>\n      \u27e8fun x y =>\n        Quotient.inductionOn\u2082' x y fun x y =>\n          I.toCotangent_eq.mpr <| ((pow_two I).trans e).symm \u25b8 I.sub_mem x.prop y.prop\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_cotangentToQuotientSquare :\n    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by\n  trans LinearMap.range (I.cotangentToQuotientSquare.comp I.toCotangent)\n  \u00b7 rw [LinearMap.range_comp, I.toCotangent_range, Submodule.map_top]\n  \u00b7 rw [to_quotient_square_comp_toCotangent, LinearMap.range_comp, I.range_subtype]; ext; rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Cotangent.lean", "context": {"open": [], "variables": ["{R : Type u} {S : Type v} {S' : Type w} [CommRing R] [CommSemiring S] [Algebra S R]", "[CommSemiring S'] [Algebra S' R] [Algebra S S'] [IsScalarTower S S' R] (I : Ideal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nI : Ideal R\n\u22a2 LinearMap.range I.cotangentToQuotientSquare = Submodule.restrictScalars R I.cotangentIdeal"}, {"line": "trans LinearMap.range (I.cotangentToQuotientSquare.comp I.toCotangent)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nI : Ideal R\n\u22a2 LinearMap.range I.cotangentToQuotientSquare = sorry\n---\nR : Type u\ninst\u271d : CommRing R\nI : Ideal R\n\u22a2 sorry = Submodule.restrictScalars R I.cotangentIdeal"}, {"line": "\u00b7 rw [LinearMap.range_comp, I.toCotangent_range, Submodule.map_top]", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nI : Ideal R\n\u22a2 sorry = Submodule.restrictScalars R I.cotangentIdeal"}, {"line": "\u00b7 rw [to_quotient_square_comp_toCotangent, LinearMap.range_comp, I.range_subtype]; ext; rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.AlgHom.ker_kerSquareLift (f : A \u2192\u2090[R] B) :\n    RingHom.ker f.kerSquareLift.toRingHom = (RingHom.ker f.toRingHom).cotangentIdeal := by\n  apply le_antisymm\n  \u00b7 intro x hx; obtain \u27e8x, rfl\u27e9 := Ideal.Quotient.mk_surjective x; exact \u27e8x, hx, rfl\u27e9\n  \u00b7 rintro _ \u27e8x, hx, rfl\u27e9; exact hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Cotangent.lean", "context": {"open": [], "variables": ["{R : Type u} {S : Type v} {S' : Type w} [CommRing R] [CommSemiring S] [Algebra S R]", "[CommSemiring S'] [Algebra S' R] [Algebra S S'] [IsScalarTower S S' R] (I : Ideal R)", "{A B : Type*} [CommRing A] [CommRing B] [Algebra R A] [Algebra R B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 : CommRing R\nA : Type u_1\nB : Type u_2\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nf : A \u2192\u2090[R] B\n\u22a2 RingHom.ker f.kerSquareLift.toRingHom = (RingHom.ker f.toRingHom).cotangentIdeal"}, {"line": "apply le_antisymm", "tactic_state": "case a\nR : Type u\ninst\u271d\u2074 : CommRing R\nA : Type u_1\nB : Type u_2\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nf : A \u2192\u2090[R] B\n\u22a2 RingHom.ker f.kerSquareLift.toRingHom \u2264 (RingHom.ker f.toRingHom).cotangentIdeal\n---\ncase a\nR : Type u\ninst\u271d\u2074 : CommRing R\nA : Type u_1\nB : Type u_2\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nf : A \u2192\u2090[R] B\n\u22a2 (RingHom.ker f.toRingHom).cotangentIdeal \u2264 RingHom.ker f.kerSquareLift.toRingHom"}, {"line": "\u00b7 intro x hx; obtain \u27e8x, rfl\u27e9 := Ideal.Quotient.mk_surjective x; exact \u27e8x, hx, rfl\u27e9", "tactic_state": "case a\nR : Type u\ninst\u271d\u2074 : CommRing R\nA : Type u_1\nB : Type u_2\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nf : A \u2192\u2090[R] B\n\u22a2 (RingHom.ker f.toRingHom).cotangentIdeal \u2264 RingHom.ker f.kerSquareLift.toRingHom"}, {"line": "\u00b7 rintro _ \u27e8x, hx, rfl\u27e9; exact hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_bot_of_comap_eq_bot [Nontrivial R] [IsDomain S] [Algebra.IsIntegral R S]\n    (hI : I.comap (algebraMap R S) = \u22a5) : I = \u22a5 := by\n  refine eq_bot_iff.2 fun x hx => ?_\n  by_cases hx0 : x = 0\n  \u00b7 exact hx0.symm \u25b8 Ideal.zero_mem \u22a5\n  \u00b7 exact absurd hI (comap_ne_bot_of_integral_mem hx0 hx (Algebra.IsIntegral.isIntegral x))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/GoingUp.lean", "context": {"open": ["Polynomial Submodule", "scoped Pointwise"], "variables": ["{R : Type*} [CommRing R]", "{S : Type*} [CommRing S] {f : R \u2192+* S} {I J : Ideal S}", "{R : Type*} [CommRing R]", "{S : Type*} [CommRing S] {f : R \u2192+* S} {I J : Ideal S}", "[Algebra R S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u2075 : CommRing R\nS : Type u_4\ninst\u271d\u2074 : CommRing S\nI : Ideal S\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : Algebra.IsIntegral R S\nhI : Ideal.comap (algebraMap R S) I = \u22a5\n\u22a2 I = \u22a5"}, {"line": "refine eq_bot_iff.2 fun x hx => ?_", "tactic_state": "R : Type u_3\ninst\u271d\u2075 : CommRing R\nS : Type u_4\ninst\u271d\u2074 : CommRing S\nI : Ideal S\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : Algebra.IsIntegral R S\nhI : Ideal.comap (algebraMap R S) I = \u22a5\nx : S\nhx : x \u2208 I\n\u22a2 x \u2208 \u22a5"}, {"line": "by_cases hx0 : x = 0", "tactic_state": "R : Type u_3\ninst\u271d\u2075 : CommRing R\nS : Type u_4\ninst\u271d\u2074 : CommRing S\nI : Ideal S\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : Algebra.IsIntegral R S\nhI : Ideal.comap (algebraMap R S) I = \u22a5\nx : S\nhx : x \u2208 I\n\u22a2 OfNat S 0\n---\ncase pos\nR : Type u_3\ninst\u271d\u2075 : CommRing R\nS : Type u_4\ninst\u271d\u2074 : CommRing S\nI : Ideal S\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : Algebra.IsIntegral R S\nhI : Ideal.comap (algebraMap R S) I = \u22a5\nx : S\nhx : x \u2208 I\nhx0 : x = 0\n\u22a2 x \u2208 \u22a5\n---\ncase neg\nR : Type u_3\ninst\u271d\u2075 : CommRing R\nS : Type u_4\ninst\u271d\u2074 : CommRing S\nI : Ideal S\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : Algebra.IsIntegral R S\nhI : Ideal.comap (algebraMap R S) I = \u22a5\nx : S\nhx : x \u2208 I\nhx0 : \u00acx = 0\n\u22a2 x \u2208 \u22a5"}, {"line": "\u00b7 exact hx0.symm \u25b8 Ideal.zero_mem \u22a5", "tactic_state": "case pos\nR : Type u_3\ninst\u271d\u2075 : CommRing R\nS : Type u_4\ninst\u271d\u2074 : CommRing S\nI : Ideal S\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : Algebra.IsIntegral R S\nhI : Ideal.comap (algebraMap R S) I = \u22a5\nx : S\nhx : x \u2208 I\nhx0 : x = 0\n\u22a2 x \u2208 \u22a5\n---\ncase neg\nR : Type u_3\ninst\u271d\u2075 : CommRing R\nS : Type u_4\ninst\u271d\u2074 : CommRing S\nI : Ideal S\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : Algebra.IsIntegral R S\nhI : Ideal.comap (algebraMap R S) I = \u22a5\nx : S\nhx : x \u2208 I\nhx0 : \u00acx = 0\n\u22a2 x \u2208 \u22a5"}, {"line": "\u00b7 exact absurd hI (comap_ne_bot_of_integral_mem hx0 hx (Algebra.IsIntegral.isIntegral x))", "tactic_state": "case neg\nR : Type u_3\ninst\u271d\u2075 : CommRing R\nS : Type u_4\ninst\u271d\u2074 : CommRing S\nI : Ideal S\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : Algebra.IsIntegral R S\nhI : Ideal.comap (algebraMap R S) I = \u22a5\nx : S\nhx : x \u2208 I\nhx0 : \u00acx = 0\n\u22a2 x \u2208 \u22a5"}]}
{"declaration": "lemma Ideal.finiteHeight_iff_lt {I : Ideal R} :\n    Ideal.FiniteHeight I \u2194 I = \u22a4 \u2228 I.height < \u22a4 := by\n  rw [Ideal.finiteHeight_iff]\n  rw [lt_top_iff_ne_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Height.lean", "context": {"open": ["Ideal"], "variables": ["{R : Type*} [CommRing R] (I : Ideal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nI : Ideal R\n\u22a2 I.FiniteHeight \u2194 I = \u22a4 \u2228 I.height < \u22a4"}, {"line": "rw [Ideal.finiteHeight_iff]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nI : Ideal R\n\u22a2 I = \u22a4 \u2228 I.height \u2260 \u22a4 \u2194 I = \u22a4 \u2228 I.height < \u22a4"}, {"line": "rw [lt_top_iff_ne_top]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Ideal.primeHeight_mono {I J : Ideal R} [I.IsPrime] [J.IsPrime] (h : I \u2264 J) :\n    I.primeHeight \u2264 J.primeHeight := by\n  unfold primeHeight\n  gcongr\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Height.lean", "context": {"open": ["Ideal"], "variables": ["{R : Type*} [CommRing R] (I : Ideal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nI J : Ideal R\ninst\u271d\u00b9 : I.IsPrime\ninst\u271d : J.IsPrime\nh : I \u2264 J\n\u22a2 I.primeHeight \u2264 J.primeHeight"}, {"line": "unfold primeHeight", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nI J : Ideal R\ninst\u271d\u00b9 : I.IsPrime\ninst\u271d : J.IsPrime\nh : I \u2264 J\n\u22a2 Order.height { asIdeal := I, isPrime := inst\u271d\u00b9 } \u2264 Order.height { asIdeal := J, isPrime := inst\u271d }"}, {"line": "gcongr", "tactic_state": "case hab\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nI J : Ideal R\ninst\u271d\u00b9 : I.IsPrime\ninst\u271d : J.IsPrime\nh : I \u2264 J\n\u22a2 { asIdeal := I, isPrime := inst\u271d\u00b9 } \u2264 { asIdeal := J, isPrime := inst\u271d }"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Ideal.primeHeight_add_one_le_of_lt {I J : Ideal R} [I.IsPrime] [J.IsPrime] (h : I < J) :\n    I.primeHeight + 1 \u2264 J.primeHeight := by\n  unfold primeHeight\n  exact Order.height_add_one_le h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Height.lean", "context": {"open": ["Ideal"], "variables": ["{R : Type*} [CommRing R] (I : Ideal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nI J : Ideal R\ninst\u271d\u00b9 : I.IsPrime\ninst\u271d : J.IsPrime\nh : I < J\n\u22a2 I.primeHeight + 1 \u2264 J.primeHeight"}, {"line": "unfold primeHeight", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nI J : Ideal R\ninst\u271d\u00b9 : I.IsPrime\ninst\u271d : J.IsPrime\nh : I < J\n\u22a2 Order.height { asIdeal := I, isPrime := inst\u271d\u00b9 } + 1 \u2264 Order.height { asIdeal := J, isPrime := inst\u271d }"}, {"line": "exact Order.height_add_one_le h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ideal.height_top : (\u22a4 : Ideal R).height = \u22a4 := by\n  simp [height, minimalPrimes_top, iInf\u2082_eq_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Height.lean", "context": {"open": ["Ideal"], "variables": ["{R : Type*} [CommRing R] (I : Ideal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\n\u22a2 \u22a4.height = \u22a4"}, {"line": "simp [height, minimalPrimes_top, iInf\u2082_eq_top]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsLocalRing.maximalIdeal_height_eq_ringKrullDim [IsLocalRing R] :\n    (IsLocalRing.maximalIdeal R).height = ringKrullDim R := by\n  rw [Ideal.height_eq_primeHeight]\n  rw [IsLocalRing.maximalIdeal_primeHeight_eq_ringKrullDim]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Height.lean", "context": {"open": ["Ideal"], "variables": ["{R : Type*} [CommRing R] (I : Ideal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsLocalRing R\n\u22a2 \u2191(maximalIdeal R).height = ringKrullDim R"}, {"line": "rw [Ideal.height_eq_primeHeight]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsLocalRing R\n\u22a2 \u2191(maximalIdeal R).primeHeight = ringKrullDim R"}, {"line": "rw [IsLocalRing.maximalIdeal_primeHeight_eq_ringKrullDim]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ideal.primeHeight_eq_ringKrullDim_iff [FiniteRingKrullDim R] [IsLocalRing R] {I : Ideal R}\n    [I.IsPrime] : Ideal.primeHeight I = ringKrullDim R \u2194 I = IsLocalRing.maximalIdeal R := by\n  constructor\n  \u00b7 intro h\n    exact IsLocalRing.eq_maximalIdeal (Ideal.isMaximal_of_primeHeight_eq_ringKrullDim h)\n  \u00b7 rintro rfl\n    exact IsLocalRing.maximalIdeal_primeHeight_eq_ringKrullDim\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Height.lean", "context": {"open": ["Ideal"], "variables": ["{R : Type*} [CommRing R] (I : Ideal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : FiniteRingKrullDim R\ninst\u271d\u00b9 : IsLocalRing R\nI : Ideal R\ninst\u271d : I.IsPrime\n\u22a2 \u2191I.primeHeight = ringKrullDim R \u2194 I = IsLocalRing.maximalIdeal R"}, {"line": "constructor", "tactic_state": "case mp\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : FiniteRingKrullDim R\ninst\u271d\u00b9 : IsLocalRing R\nI : Ideal R\ninst\u271d : I.IsPrime\n\u22a2 \u2191I.primeHeight = ringKrullDim R \u2192 I = IsLocalRing.maximalIdeal R\n---\ncase mpr\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : FiniteRingKrullDim R\ninst\u271d\u00b9 : IsLocalRing R\nI : Ideal R\ninst\u271d : I.IsPrime\n\u22a2 I = IsLocalRing.maximalIdeal R \u2192 \u2191I.primeHeight = ringKrullDim R"}, {"line": "\u00b7 intro h\n    exact IsLocalRing.eq_maximalIdeal (Ideal.isMaximal_of_primeHeight_eq_ringKrullDim h)", "tactic_state": "case mpr\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : FiniteRingKrullDim R\ninst\u271d\u00b9 : IsLocalRing R\nI : Ideal R\ninst\u271d : I.IsPrime\n\u22a2 I = IsLocalRing.maximalIdeal R \u2192 \u2191I.primeHeight = ringKrullDim R"}, {"line": "\u00b7 rintro rfl\n    exact IsLocalRing.maximalIdeal_primeHeight_eq_ringKrullDim", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isMaximal_map_iff_of_bijective : IsMaximal (map f I) \u2194 IsMaximal I := by\n  simpa only [isMaximal_def] using (relIsoOfBijective _ hf).symm.isCoatom_iff _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Maps.lean", "context": {"open": ["Pointwise", "Function", "Function in"], "variables": ["{R : Type u} {S : Type v}", "{F : Type*} [Semiring R] [Semiring S]", "[FunLike F R S]", "(f : F)", "{I J : Ideal R} {K L : Ideal S}", "{f}", "(f)", "{G : Type*} [FunLike G S R]", "[RingHomClass F R S]", "(I J K L)", "{f I J K L}", "(f I J K L)", "{\u03b9 : Sort*}", "{I J K L}", "(hf : Function.Surjective f)", "(hf : Function.Bijective f) {I : Ideal R} {K : Ideal S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nIsMaximal : x\u271d\n\u22a2 sorry \u2194 sorry"}, {"line": "simpa only [isMaximal_def] using (relIsoOfBijective _ hf).symm.isCoatom_iff _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isMaximal_comap_iff_of_bijective : IsMaximal (comap f K) \u2194 IsMaximal K := by\n  simpa only [isMaximal_def] using (relIsoOfBijective _ hf).isCoatom_iff _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Maps.lean", "context": {"open": ["Pointwise", "Function", "Function in"], "variables": ["{R : Type u} {S : Type v}", "{F : Type*} [Semiring R] [Semiring S]", "[FunLike F R S]", "(f : F)", "{I J : Ideal R} {K L : Ideal S}", "{f}", "(f)", "{G : Type*} [FunLike G S R]", "[RingHomClass F R S]", "(I J K L)", "{f I J K L}", "(f I J K L)", "{\u03b9 : Sort*}", "{I J K L}", "(hf : Function.Surjective f)", "(hf : Function.Bijective f) {I : Ideal R} {K : Ideal S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nIsMaximal : x\u271d\n\u22a2 sorry \u2194 sorry"}, {"line": "simpa only [isMaximal_def] using (relIsoOfBijective _ hf).isCoatom_iff _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma disjoint_map_primeCompl_iff_comap_le {S : Type*} [Semiring S] {f : R \u2192+* S}\n    {p : Ideal R} {I : Ideal S} [p.IsPrime] :\n    Disjoint (I : Set S) (p.primeCompl.map f) \u2194 I.comap f \u2264 p := by\n  rw [disjoint_comm]\n  simp [Set.disjoint_iff, Set.ext_iff, Ideal.primeCompl, not_imp_not, SetLike.le_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Maps.lean", "context": {"open": ["Pointwise", "Function", "Function in"], "variables": ["{R : Type u} {S : Type v}", "{F : Type*} [Semiring R] [Semiring S]", "[FunLike F R S]", "(f : F)", "{I J : Ideal R} {K L : Ideal S}", "{f}", "(f)", "{G : Type*} [FunLike G S R]", "[RingHomClass F R S]", "(I J K L)", "{f I J K L}", "(f I J K L)", "{\u03b9 : Sort*}", "{I J K L}", "(hf : Function.Surjective f)", "(hf : Function.Bijective f) {I : Ideal R} {K : Ideal S}", "{F : Type*} [Ring R] [Ring S]", "[FunLike F R S] [RingHomClass F R S] (f : F) {I : Ideal R}", "{F : Type*} [CommSemiring R] [CommSemiring S]", "[FunLike F R S] [rc : RingHomClass F R S]", "(f : F)", "(I J : Ideal R) (K L : Ideal S)", "{K}", "{I J L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_7\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : CommSemiring R\nS : Type u_6\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\np : Ideal R\nI : Ideal S\ninst\u271d : p.IsPrime\n\u22a2 Disjoint \u2191I \u2191(Submonoid.map f p.primeCompl) \u2194 Ideal.comap f I \u2264 p"}, {"line": "rw [disjoint_comm]", "tactic_state": "R : Type u_7\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : CommSemiring R\nS : Type u_6\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\np : Ideal R\nI : Ideal S\ninst\u271d : p.IsPrime\n\u22a2 Disjoint \u2191(Submonoid.map f p.primeCompl) \u2191I \u2194 Ideal.comap f I \u2264 p"}, {"line": "simp [Set.disjoint_iff, Set.ext_iff, Ideal.primeCompl, not_imp_not, SetLike.le_def]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comap_map_eq_self_iff_of_isPrime {S : Type*} [CommSemiring S] {f : R \u2192+* S}\n    (p : Ideal R) [p.IsPrime] :\n    (p.map f).comap f = p \u2194 (\u2203 (q : Ideal S), q.IsPrime \u2227 q.comap f = p) := by\n  refine \u27e8fun hp \u21a6 ?_, ?_\u27e9\n  \u00b7 obtain \u27e8q, hq\u2081, hq\u2082, hq\u2083\u27e9 := Ideal.exists_le_prime_disjoint _ _\n      (disjoint_map_primeCompl_iff_comap_le.mpr hp.le)\n    exact \u27e8q, hq\u2081, le_antisymm (disjoint_map_primeCompl_iff_comap_le.mp hq\u2083)\n      (map_le_iff_le_comap.mp hq\u2082)\u27e9\n  \u00b7 rintro \u27e8q, hq, rfl\u27e9\n    simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Maps.lean", "context": {"open": ["Pointwise", "Function", "Function in"], "variables": ["{R : Type u} {S : Type v}", "{F : Type*} [Semiring R] [Semiring S]", "[FunLike F R S]", "(f : F)", "{I J : Ideal R} {K L : Ideal S}", "{f}", "(f)", "{G : Type*} [FunLike G S R]", "[RingHomClass F R S]", "(I J K L)", "{f I J K L}", "(f I J K L)", "{\u03b9 : Sort*}", "{I J K L}", "(hf : Function.Surjective f)", "(hf : Function.Bijective f) {I : Ideal R} {K : Ideal S}", "{F : Type*} [Ring R] [Ring S]", "[FunLike F R S] [RingHomClass F R S] (f : F) {I : Ideal R}", "{F : Type*} [CommSemiring R] [CommSemiring S]", "[FunLike F R S] [rc : RingHomClass F R S]", "(f : F)", "(I J : Ideal R) (K L : Ideal S)", "{K}", "{I J L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_7\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : CommSemiring R\nS : Type u_6\ninst\u271d\u00b9 : CommSemiring S\nf : R \u2192+* S\np : Ideal R\ninst\u271d : p.IsPrime\n\u22a2 Ideal.comap f (Ideal.map f p) = p \u2194 \u2203 q, q.IsPrime \u2227 Ideal.comap f q = p"}, {"line": "refine \u27e8fun hp \u21a6 ?_, ?_\u27e9", "tactic_state": "case refine_1\nR : Type u_7\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : CommSemiring R\nS : Type u_6\ninst\u271d\u00b9 : CommSemiring S\nf : R \u2192+* S\np : Ideal R\ninst\u271d : p.IsPrime\nhp : Ideal.comap f (Ideal.map f p) = p\n\u22a2 \u2203 q, q.IsPrime \u2227 Ideal.comap f q = p\n---\ncase refine_2\nR : Type u_7\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : CommSemiring R\nS : Type u_6\ninst\u271d\u00b9 : CommSemiring S\nf : R \u2192+* S\np : Ideal R\ninst\u271d : p.IsPrime\n\u22a2 (\u2203 q, q.IsPrime \u2227 Ideal.comap f q = p) \u2192 Ideal.comap f (Ideal.map f p) = p"}, {"line": "\u00b7 obtain \u27e8q, hq\u2081, hq\u2082, hq\u2083\u27e9 := Ideal.exists_le_prime_disjoint _ _\n      (disjoint_map_primeCompl_iff_comap_le.mpr hp.le)\n    exact \u27e8q, hq\u2081, le_antisymm (disjoint_map_primeCompl_iff_comap_le.mp hq\u2083)\n      (map_le_iff_le_comap.mp hq\u2082)\u27e9", "tactic_state": "case refine_2\nR : Type u_7\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : CommSemiring R\nS : Type u_6\ninst\u271d\u00b9 : CommSemiring S\nf : R \u2192+* S\np : Ideal R\ninst\u271d : p.IsPrime\n\u22a2 (\u2203 q, q.IsPrime \u2227 Ideal.comap f q = p) \u2192 Ideal.comap f (Ideal.map f p) = p"}, {"line": "\u00b7 rintro \u27e8q, hq, rfl\u27e9\n    simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_annihilator_span (s : Set M) (r : R) :\n    r \u2208 (Submodule.span R s).annihilator \u2194 \u2200 n : s, r \u2022 (n : M) = 0 := by\n  rw [Submodule.mem_annihilator]\n  constructor\n  \u00b7 intro h n\n    exact h _ (Submodule.subset_span n.prop)\n  \u00b7 intro h n hn\n    refine Submodule.span_induction ?_ ?_ ?_ ?_ hn\n    \u00b7 intro x hx\n      exact h \u27e8x, hx\u27e9\n    \u00b7 exact smul_zero _\n    \u00b7 intro x y _ _ hx hy\n      rw [smul_add]\n      rw [hx]\n      rw [hy]\n      rw [zero_add]\n    \u00b7 intro a x _ hx\n      rw [smul_comm]\n      rw [hx]\n      rw [smul_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Maps.lean", "context": {"open": ["Pointwise", "Function", "Function in"], "variables": ["{R : Type u} {S : Type v}", "{F : Type*} [Semiring R] [Semiring S]", "[FunLike F R S]", "(f : F)", "{I J : Ideal R} {K L : Ideal S}", "{f}", "(f)", "{G : Type*} [FunLike G S R]", "[RingHomClass F R S]", "(I J K L)", "{f I J K L}", "(f I J K L)", "{\u03b9 : Sort*}", "{I J K L}", "(hf : Function.Surjective f)", "(hf : Function.Bijective f) {I : Ideal R} {K : Ideal S}", "{F : Type*} [Ring R] [Ring S]", "[FunLike F R S] [RingHomClass F R S] (f : F) {I : Ideal R}", "{F : Type*} [CommSemiring R] [CommSemiring S]", "[FunLike F R S] [rc : RingHomClass F R S]", "(f : F)", "(I J : Ideal R) (K L : Ideal S)", "{K}", "{I J L}", "{R : Type u} {S : Type v} {T : Type w}", "{F : Type*} {G : Type*} [Semiring R] [Semiring S] [Semiring T]", "[FunLike F R S] [rcf : RingHomClass F R S] [FunLike G T S] [rcg : RingHomClass G T S]", "(f : F) (g : G)", "{f} in", "{F : Type*} [Ring R] [Semiring S] [FunLike F R S] [rc : RingHomClass F R S] (f : F)", "{F : Type*} [Ring R] [Ring S] [FunLike F R S] [rc : RingHomClass F R S] (f : F)", "{R M M' : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(R M) in", "{I J : Ideal R} {N P : Submodule R M}", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M] {N : Submodule R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_12\nM : Type u_13\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\ns : Set M\nr : R\n\u22a2 r \u2208 (Submodule.span R s).annihilator \u2194 \u2200 (n : \u2191s), r \u2022 \u2191n = 0"}, {"line": "rw [Submodule.mem_annihilator]", "tactic_state": "R : Type u_12\nM : Type u_13\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\ns : Set M\nr : R\n\u22a2 (\u2200 n \u2208 Submodule.span R s, r \u2022 n = 0) \u2194 \u2200 (n : \u2191s), r \u2022 \u2191n = 0"}, {"line": "constructor", "tactic_state": "case mp\nR : Type u_12\nM : Type u_13\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\ns : Set M\nr : R\n\u22a2 (\u2200 n \u2208 Submodule.span R s, r \u2022 n = 0) \u2192 \u2200 (n : \u2191s), r \u2022 \u2191n = 0\n---\ncase mpr\nR : Type u_12\nM : Type u_13\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\ns : Set M\nr : R\n\u22a2 (\u2200 (n : \u2191s), r \u2022 \u2191n = 0) \u2192 \u2200 n \u2208 Submodule.span R s, r \u2022 n = 0"}, {"line": "\u00b7 intro h n\n    exact h _ (Submodule.subset_span n.prop)", "tactic_state": "case mpr\nR : Type u_12\nM : Type u_13\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\ns : Set M\nr : R\n\u22a2 (\u2200 (n : \u2191s), r \u2022 \u2191n = 0) \u2192 \u2200 n \u2208 Submodule.span R s, r \u2022 n = 0"}, {"line": "\u00b7 intro h n hn\n    refine Submodule.span_induction ?_ ?_ ?_ ?_ hn\n    \u00b7 intro x hx\n      exact h \u27e8x, hx\u27e9\n    \u00b7 exact smul_zero _\n    \u00b7 intro x y _ _ hx hy\n      rw [smul_add]\n      rw [hx]\n      rw [hy]\n      rw [zero_add]\n    \u00b7 intro a x _ hx\n      rw [smul_comm]\n      rw [hx]\n      rw [smul_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem annihilator_span_singleton (g : M) :\n    (Submodule.span R {g}).annihilator = ker (toSpanSingleton R M g) := by\n  simp [annihilator_span]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Maps.lean", "context": {"open": ["Pointwise", "Function", "Function in", "LinearMap in", "LinearMap in"], "variables": ["{R : Type u} {S : Type v}", "{F : Type*} [Semiring R] [Semiring S]", "[FunLike F R S]", "(f : F)", "{I J : Ideal R} {K L : Ideal S}", "{f}", "(f)", "{G : Type*} [FunLike G S R]", "[RingHomClass F R S]", "(I J K L)", "{f I J K L}", "(f I J K L)", "{\u03b9 : Sort*}", "{I J K L}", "(hf : Function.Surjective f)", "(hf : Function.Bijective f) {I : Ideal R} {K : Ideal S}", "{F : Type*} [Ring R] [Ring S]", "[FunLike F R S] [RingHomClass F R S] (f : F) {I : Ideal R}", "{F : Type*} [CommSemiring R] [CommSemiring S]", "[FunLike F R S] [rc : RingHomClass F R S]", "(f : F)", "(I J : Ideal R) (K L : Ideal S)", "{K}", "{I J L}", "{R : Type u} {S : Type v} {T : Type w}", "{F : Type*} {G : Type*} [Semiring R] [Semiring S] [Semiring T]", "[FunLike F R S] [rcf : RingHomClass F R S] [FunLike G T S] [rcg : RingHomClass G T S]", "(f : F) (g : G)", "{f} in", "{F : Type*} [Ring R] [Semiring S] [FunLike F R S] [rc : RingHomClass F R S] (f : F)", "{F : Type*} [Ring R] [Ring S] [FunLike F R S] [rc : RingHomClass F R S] (f : F)", "{R M M' : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(R M) in", "{I J : Ideal R} {N P : Submodule R M}", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M] {N : Submodule R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_12\nM : Type u_13\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nx\u271d : Sort u_14\nker : x\u271d\ng : M\n\u22a2 (Submodule.span R {g}).annihilator = sorry"}, {"line": "simp [annihilator_span]", "tactic_state": "R : Type u_12\nM : Type u_13\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nx\u271d : Sort u_14\nker : x\u271d\ng : M\n\u22a2 (Submodule.span R {g}).annihilator = sorry ()"}]}
{"declaration": "theorem eq_liftOfRightInverse (hf : Function.RightInverse f_inv f) (g : A \u2192+* C)\n    (hg : RingHom.ker f \u2264 RingHom.ker g) (h : B \u2192+* C) (hh : h.comp f = g) :\n    h = f.liftOfRightInverse f_inv hf \u27e8g, hg\u27e9 := by\n  simp_rw [\u2190 hh]\n  exact ((f.liftOfRightInverse f_inv hf).apply_symm_apply _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Maps.lean", "context": {"open": ["Pointwise", "Function", "Function in", "LinearMap in", "LinearMap in"], "variables": ["{R : Type u} {S : Type v}", "{F : Type*} [Semiring R] [Semiring S]", "[FunLike F R S]", "(f : F)", "{I J : Ideal R} {K L : Ideal S}", "{f}", "(f)", "{G : Type*} [FunLike G S R]", "[RingHomClass F R S]", "(I J K L)", "{f I J K L}", "(f I J K L)", "{\u03b9 : Sort*}", "{I J K L}", "(hf : Function.Surjective f)", "(hf : Function.Bijective f) {I : Ideal R} {K : Ideal S}", "{F : Type*} [Ring R] [Ring S]", "[FunLike F R S] [RingHomClass F R S] (f : F) {I : Ideal R}", "{F : Type*} [CommSemiring R] [CommSemiring S]", "[FunLike F R S] [rc : RingHomClass F R S]", "(f : F)", "(I J : Ideal R) (K L : Ideal S)", "{K}", "{I J L}", "{R : Type u} {S : Type v} {T : Type w}", "{F : Type*} {G : Type*} [Semiring R] [Semiring S] [Semiring T]", "[FunLike F R S] [rcf : RingHomClass F R S] [FunLike G T S] [rcg : RingHomClass G T S]", "(f : F) (g : G)", "{f} in", "{F : Type*} [Ring R] [Semiring S] [FunLike F R S] [rc : RingHomClass F R S] (f : F)", "{F : Type*} [Ring R] [Ring S] [FunLike F R S] [rc : RingHomClass F R S] (f : F)", "{R M M' : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "(R M) in", "{I J : Ideal R} {N P : Submodule R M}", "{R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M] {N : Submodule R M}", "{R : Type*} {S : Type*} {F : Type*}", "[Semiring R] [Semiring S] [FunLike F R S] [rc : RingHomClass F R S]", "[Ring R] [Ring S] [FunLike F R S] [rc : RingHomClass F R S]", "[CommRing R] [CommRing S]", "{A B C : Type*} [Ring A] [Ring B] [Ring C]", "(f : A \u2192+* B) (f_inv : B \u2192 A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_17\nB : Type u_18\nC : Type u_19\ninst\u271d\u00b2 : Ring A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Ring C\nf : A \u2192+* B\nf_inv : B \u2192 A\nhf : RightInverse f_inv \u21d1f\ng : A \u2192+* C\nhg : RingHom.ker f \u2264 RingHom.ker g\nh : B \u2192+* C\nhh : h.comp f = g\n\u22a2 h = (f.liftOfRightInverse f_inv hf) \u27e8g, hg\u27e9"}, {"line": "simp_rw [\u2190 hh]", "tactic_state": "A : Type u_17\nB : Type u_18\nC : Type u_19\ninst\u271d\u00b2 : Ring A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Ring C\nf : A \u2192+* B\nf_inv : B \u2192 A\nhf : RightInverse f_inv \u21d1f\ng : A \u2192+* C\nhg : RingHom.ker f \u2264 RingHom.ker g\nh : B \u2192+* C\nhh : h.comp f = g\n\u22a2 h = (f.liftOfRightInverse f_inv hf) \u27e8h.comp f, \u22ef\u27e9"}, {"line": "exact ((f.liftOfRightInverse f_inv hf).apply_symm_apply _).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsMaximal.coprime_of_ne {M M' : Ideal \u03b1} (hM : M.IsMaximal) (hM' : M'.IsMaximal)\n    (hne : M \u2260 M') : M \u2294 M' = \u22a4 := by\n  contrapose! hne with h\n  exact hM.eq_of_le hM'.ne_top (le_sup_left.trans_eq (hM'.eq_of_le h le_sup_right).symm)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Maximal.lean", "context": {"open": ["Set Function", "Pointwise"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {F : Type w}", "[Semiring \u03b1] (I : Ideal \u03b1) {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Semiring \u03b1\nM M' : Ideal \u03b1\nhM : M.IsMaximal\nhM' : M'.IsMaximal\nhne : M \u2260 M'\n\u22a2 M \u2294 M' = \u22a4"}, {"line": "contrapose! hne with h", "tactic_state": "\u03b1 : Type u\ninst\u271d : Semiring \u03b1\nM M' : Ideal \u03b1\nhM : M.IsMaximal\nhM' : M'.IsMaximal\nh : M \u2294 M' \u2260 \u22a4\n\u22a2 M = M'"}, {"line": "exact hM.eq_of_le hM'.ne_top (le_sup_left.trans_eq (hM'.eq_of_le h le_sup_right).symm)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem span_singleton_prime {p : \u03b1} (hp : p \u2260 0) : IsPrime (span ({p} : Set \u03b1)) \u2194 Prime p := by\n  simp [isPrime_iff, Prime, span_singleton_eq_top, hp, mem_span_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Maximal.lean", "context": {"open": ["Set Function", "Pointwise"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {F : Type w}", "[Semiring \u03b1] (I : Ideal \u03b1) {a b : \u03b1}", "(\u03b1) in", "{a b : \u03b1}", "[CommSemiring \u03b1] (I : Ideal \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : CommSemiring \u03b1\nx\u271d : Sort u_1\nIsPrime : x\u271d\np : \u03b1\nhp : p \u2260 0\n\u22a2 sorry \u2194 Prime p"}, {"line": "simp [isPrime_iff, Prime, span_singleton_eq_top, hp, mem_span_singleton]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : CommSemiring \u03b1\nx\u271d : Sort u_1\nIsPrime : x\u271d\np : \u03b1\nhp : p \u2260 0\n\u22a2 sorry () \u2194 \u00acp = 0 \u2227 \u00acIsUnit p \u2227 \u2200 (a b : \u03b1), p \u2223 a * b \u2192 p \u2223 a \u2228 p \u2223 b"}]}
{"declaration": "lemma span_singleton_toAddSubgroup_eq_zmultiples (a : \u2124) :\n    (span \u2124 {a}).toAddSubgroup = AddSubgroup.zmultiples a := by\n  ext i\n  simp [Ideal.mem_span_singleton', AddSubgroup.mem_zmultiples_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Operations.lean", "context": {"open": ["Pointwise"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nspan : x\u271d\na : \u2124\n\u22a2 sorry = AddSubgroup.zmultiples a"}, {"line": "ext i", "tactic_state": "case h\nx\u271d : Sort u_1\nspan : x\u271d\na i : \u2124\n\u22a2 i \u2208 sorry \u2194 i \u2208 AddSubgroup.zmultiples a"}, {"line": "simp [Ideal.mem_span_singleton', AddSubgroup.mem_zmultiples_iff]", "tactic_state": "case h\nx\u271d : Sort u_1\nspan : x\u271d\na i : \u2124\n\u22a2 i \u2208 sorry () \u2194 \u2203 k, k * a = i"}]}
{"declaration": "theorem mul_bot : I * \u22a5 = \u22a5 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Operations.lean", "context": {"open": ["Pointwise", "Pointwise", "Pointwise in"], "variables": ["{R : Type u} {M : Type v} {M' F G : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "{I J : Ideal R} {N : Submodule R M}", "(I J N)", "{M' : Type w} [AddCommMonoid M'] [Module R M']", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "{I J : Ideal R} {N P : Submodule R M}", "(S : Set R) (T : Set M)", "(I)", "{R : Type u} [Semiring R]", "{R : Type u} [Semiring R] {I J K L : Ideal R}", "(I)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nI : Ideal R\n\u22a2 I * \u22a5 = \u22a5"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bot_mul : \u22a5 * I = \u22a5 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Operations.lean", "context": {"open": ["Pointwise", "Pointwise", "Pointwise in"], "variables": ["{R : Type u} {M : Type v} {M' F G : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "{I J : Ideal R} {N : Submodule R M}", "(I J N)", "{M' : Type w} [AddCommMonoid M'] [Module R M']", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "{I J : Ideal R} {N P : Submodule R M}", "(S : Set R) (T : Set M)", "(I)", "{R : Type u} [Semiring R]", "{R : Type u} [Semiring R] {I J K L : Ideal R}", "(I)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nI : Ideal R\n\u22a2 \u22a5 * I = \u22a5"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pow_le_pow_right {m n : \u2115} (h : m \u2264 n) : I ^ n \u2264 I ^ m := by\n  obtain _ | m := m\n  \u00b7 rw [Submodule.pow_zero, one_eq_top]; exact le_top\n  obtain \u27e8n, rfl\u27e9 := Nat.exists_eq_add_of_le h\n  rw [add_comm]\n  rw [Submodule.pow_add _ m.add_one_ne_zero]\n  exact mul_le_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Operations.lean", "context": {"open": ["Pointwise", "Pointwise", "Pointwise in"], "variables": ["{R : Type u} {M : Type v} {M' F G : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "{I J : Ideal R} {N : Submodule R M}", "(I J N)", "{M' : Type w} [AddCommMonoid M'] [Module R M']", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "{I J : Ideal R} {N P : Submodule R M}", "(S : Set R) (T : Set M)", "(I)", "{R : Type u} [Semiring R]", "{R : Type u} [Semiring R] {I J K L : Ideal R}", "(I)", "{I}", "(I J K)", "{I J K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nI : Ideal R\nm n : \u2115\nh : m \u2264 n\n\u22a2 I ^ n \u2264 I ^ m"}, {"line": "obtain _ | m := m", "tactic_state": "case zero\nR : Type u\ninst\u271d : Semiring R\nI : Ideal R\nn : \u2115\nh : 0 \u2264 n\n\u22a2 I ^ n \u2264 I ^ 0\n---\ncase succ\nR : Type u\ninst\u271d : Semiring R\nI : Ideal R\nn m : \u2115\nh : m + 1 \u2264 n\n\u22a2 I ^ n \u2264 I ^ (m + 1)"}, {"line": "\u00b7 rw [Submodule.pow_zero, one_eq_top]; exact le_top", "tactic_state": "case succ\nR : Type u\ninst\u271d : Semiring R\nI : Ideal R\nn m : \u2115\nh : m + 1 \u2264 n\n\u22a2 I ^ n \u2264 I ^ (m + 1)"}, {"line": "obtain \u27e8n, rfl\u27e9 := Nat.exists_eq_add_of_le h", "tactic_state": "case succ.intro\nR : Type u\ninst\u271d : Semiring R\nI : Ideal R\nm n : \u2115\nh : m + 1 \u2264 m + 1 + n\n\u22a2 I ^ (m + 1 + n) \u2264 I ^ (m + 1)"}, {"line": "rw [add_comm]", "tactic_state": "case succ.intro\nR : Type u\ninst\u271d : Semiring R\nI : Ideal R\nm n : \u2115\nh : m + 1 \u2264 m + 1 + n\n\u22a2 I ^ (n + (m + 1)) \u2264 I ^ (m + 1)"}, {"line": "rw [Submodule.pow_add _ m.add_one_ne_zero]", "tactic_state": "case succ.intro\nR : Type u\ninst\u271d : Semiring R\nI : Ideal R\nm n : \u2115\nh : m + 1 \u2264 m + 1 + n\n\u22a2 I ^ n * I ^ (m + 1) \u2264 I ^ (m + 1)"}, {"line": "exact mul_le_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pow_eq_zero_of_mem {I : Ideal R} {n m : \u2115} (hnI : I ^ n = 0) (hmn : n \u2264 m) {x : R}\n    (hx : x \u2208 I) : x ^ m = 0 := by\n  simpa [hnI] using pow_le_pow_right hmn <| pow_mem_pow hx m\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Operations.lean", "context": {"open": ["Pointwise", "Pointwise", "Pointwise in"], "variables": ["{R : Type u} {M : Type v} {M' F G : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "{I J : Ideal R} {N : Submodule R M}", "(I J N)", "{M' : Type w} [AddCommMonoid M'] [Module R M']", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "{I J : Ideal R} {N P : Submodule R M}", "(S : Set R) (T : Set M)", "(I)", "{R : Type u} [Semiring R]", "{R : Type u} [Semiring R] {I J K L : Ideal R}", "(I)", "{I}", "(I J K)", "{I J K}", "[I.IsTwoSided] (m n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nI : Ideal R\nn m : \u2115\nhnI : I ^ n = 0\nhmn : n \u2264 m\nx : R\nhx : x \u2208 I\n\u22a2 x ^ m = 0"}, {"line": "simpa [hnI] using pow_le_pow_right hmn <| pow_mem_pow hx m", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_mem_prod {\u03b9 : Type*} {s : Finset \u03b9} {I : \u03b9 \u2192 Ideal R} {x : \u03b9 \u2192 R} :\n    (\u2200 i \u2208 s, x i \u2208 I i) \u2192 (\u220f i \u2208 s, x i) \u2208 \u220f i \u2208 s, I i := by\n  classical\n    refine Finset.induction_on s ?_ ?_\n    \u00b7 intro\n      rw [Finset.prod_empty]\n      rw [Finset.prod_empty]\n      rw [one_eq_top]\n      exact Submodule.mem_top\n    \u00b7 intro a s ha IH h\n      rw [Finset.prod_insert ha]\n      rw [Finset.prod_insert ha]\n      exact\n        mul_mem_mul (h a <| Finset.mem_insert_self a s)\n          (IH fun i hi => h i <| Finset.mem_insert_of_mem hi)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Operations.lean", "context": {"open": ["Pointwise", "Pointwise", "Pointwise in"], "variables": ["{R : Type u} {M : Type v} {M' F G : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "{I J : Ideal R} {N : Submodule R M}", "(I J N)", "{M' : Type w} [AddCommMonoid M'] [Module R M']", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "{I J : Ideal R} {N P : Submodule R M}", "(S : Set R) (T : Set M)", "(I)", "{R : Type u} [Semiring R]", "{R : Type u} [Semiring R] {I J K L : Ideal R}", "(I)", "{I}", "(I J K)", "{I J K}", "[I.IsTwoSided] (m n : \u2115)", "{R : Type u} {\u03b9 : Type*} [CommSemiring R]", "{I J K L : Ideal R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\n\u03b9 : Type u_2\ns : Finset \u03b9\nI : \u03b9 \u2192 Ideal R\nx : \u03b9 \u2192 R\n\u22a2 (\u2200 i \u2208 s, x i \u2208 I i) \u2192 \u220f i \u2208 s, x i \u2208 \u220f i \u2208 s, I i"}, {"line": "classical\n    refine Finset.induction_on s ?_ ?_\n    \u00b7 intro\n      rw [Finset.prod_empty]\n      rw [Finset.prod_empty]\n      rw [one_eq_top]\n      exact Submodule.mem_top\n    \u00b7 intro a s ha IH h\n      rw [Finset.prod_insert ha]\n      rw [Finset.prod_insert ha]\n      exact\n        mul_mem_mul (h a <| Finset.mem_insert_self a s)\n          (IH fun i hi => h i <| Finset.mem_insert_of_mem hi)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sup_pow_add_le_pow_sup_pow {n m : \u2115} : (I \u2294 J) ^ (n + m) \u2264 I ^ n \u2294 J ^ m := by\n  rw [\u2190 Ideal.add_eq_sup]\n  rw [\u2190 Ideal.add_eq_sup]\n  rw [add_pow]\n  rw [Ideal.sum_eq_sup]\n  apply Finset.sup_le\n  intros i hi\n  by_cases hn : n \u2264 i\n  \u00b7 exact (Ideal.mul_le_right.trans (Ideal.mul_le_right.trans\n      ((Ideal.pow_le_pow_right hn).trans le_sup_left)))\n  \u00b7 refine (Ideal.mul_le_right.trans (Ideal.mul_le_left.trans\n      ((Ideal.pow_le_pow_right ?_).trans le_sup_right)))\n    omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Operations.lean", "context": {"open": ["Pointwise", "Pointwise", "Pointwise in"], "variables": ["{R : Type u} {M : Type v} {M' F G : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "{I J : Ideal R} {N : Submodule R M}", "(I J N)", "{M' : Type w} [AddCommMonoid M'] [Module R M']", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "{I J : Ideal R} {N P : Submodule R M}", "(S : Set R) (T : Set M)", "(I)", "{R : Type u} [Semiring R]", "{R : Type u} [Semiring R] {I J K L : Ideal R}", "(I)", "{I}", "(I J K)", "{I J K}", "[I.IsTwoSided] (m n : \u2115)", "{R : Type u} {\u03b9 : Type*} [CommSemiring R]", "{I J K L : Ideal R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nn m : \u2115\n\u22a2 (I \u2294 J) ^ (n + m) \u2264 I ^ n \u2294 J ^ m"}, {"line": "rw [\u2190 Ideal.add_eq_sup]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nn m : \u2115\n\u22a2 (I + J) ^ (n + m) \u2264 I ^ n \u2294 J ^ m"}, {"line": "rw [\u2190 Ideal.add_eq_sup]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nn m : \u2115\n\u22a2 (I + J) ^ (n + m) \u2264 I ^ n + J ^ m"}, {"line": "rw [add_pow]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nn m : \u2115\n\u22a2 \u2211 m_1 \u2208 Finset.range (n + m + 1), I ^ m_1 * J ^ (n + m - m_1) * \u2191((n + m).choose m_1) \u2264 I ^ n + J ^ m"}, {"line": "rw [Ideal.sum_eq_sup]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nn m : \u2115\n\u22a2 ((Finset.range (n + m + 1)).sup fun m_1 => I ^ m_1 * J ^ (n + m - m_1) * \u2191((n + m).choose m_1)) \u2264 I ^ n + J ^ m"}, {"line": "apply Finset.sup_le", "tactic_state": "case a\nR : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nn m : \u2115\n\u22a2 \u2200 b \u2208 Finset.range (n + m + 1), I ^ b * J ^ (n + m - b) * \u2191((n + m).choose b) \u2264 I ^ n + J ^ m"}, {"line": "intros i hi", "tactic_state": "case a\nR : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nn m i : \u2115\nhi : i \u2208 Finset.range (n + m + 1)\n\u22a2 I ^ i * J ^ (n + m - i) * \u2191((n + m).choose i) \u2264 I ^ n + J ^ m"}, {"line": "by_cases hn : n \u2264 i", "tactic_state": "case pos\nR : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nn m i : \u2115\nhi : i \u2208 Finset.range (n + m + 1)\nhn : n \u2264 i\n\u22a2 I ^ i * J ^ (n + m - i) * \u2191((n + m).choose i) \u2264 I ^ n + J ^ m\n---\ncase neg\nR : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nn m i : \u2115\nhi : i \u2208 Finset.range (n + m + 1)\nhn : \u00acn \u2264 i\n\u22a2 I ^ i * J ^ (n + m - i) * \u2191((n + m).choose i) \u2264 I ^ n + J ^ m"}, {"line": "\u00b7 exact (Ideal.mul_le_right.trans (Ideal.mul_le_right.trans\n      ((Ideal.pow_le_pow_right hn).trans le_sup_left)))", "tactic_state": "case neg\nR : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nn m i : \u2115\nhi : i \u2208 Finset.range (n + m + 1)\nhn : \u00acn \u2264 i\n\u22a2 I ^ i * J ^ (n + m - i) * \u2191((n + m).choose i) \u2264 I ^ n + J ^ m"}, {"line": "\u00b7 refine (Ideal.mul_le_right.trans (Ideal.mul_le_left.trans\n      ((Ideal.pow_le_pow_right ?_).trans le_sup_right)))\n    omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem span_singleton_mul_left_mono [IsDomain R] {x : R} (hx : x \u2260 0) :\n    I * span {x} \u2264 J * span {x} \u2194 I \u2264 J := by\n  simpa only [mul_comm I,mul_comm J] using span_singleton_mul_right_mono hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Operations.lean", "context": {"open": ["Pointwise", "Pointwise", "Pointwise in"], "variables": ["{R : Type u} {M : Type v} {M' F G : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "{I J : Ideal R} {N : Submodule R M}", "(I J N)", "{M' : Type w} [AddCommMonoid M'] [Module R M']", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "{I J : Ideal R} {N P : Submodule R M}", "(S : Set R) (T : Set M)", "(I)", "{R : Type u} [Semiring R]", "{R : Type u} [Semiring R] {I J K L : Ideal R}", "(I)", "{I}", "(I J K)", "{I J K}", "[I.IsTwoSided] (m n : \u2115)", "{R : Type u} {\u03b9 : Type*} [CommSemiring R]", "{I J K L : Ideal R}", "(I J K)", "{I J K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\nI J : Ideal R\nx\u271d : Sort u_2\nspan : x\u271d\ninst\u271d : IsDomain R\nx : R\nhx : x \u2260 0\n\u22a2 I * sorry \u2264 J * sorry \u2194 I \u2264 J"}, {"line": "simpa only [mul_comm I,mul_comm J] using span_singleton_mul_right_mono hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiset_prod_le_inf {s : Multiset (Ideal R)} : s.prod \u2264 s.inf := by\n  classical\n    refine s.induction_on ?_ ?_\n    \u00b7 rw [Multiset.inf_zero]\n      exact le_top\n    intro a s ih\n    rw [Multiset.prod_cons]\n    rw [Multiset.inf_cons]\n    exact le_trans mul_le_inf (inf_le_inf le_rfl ih)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Operations.lean", "context": {"open": ["Pointwise", "Pointwise", "Pointwise in", "scoped Function in -- required for scoped `on` notation"], "variables": ["{R : Type u} {M : Type v} {M' F G : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "{I J : Ideal R} {N : Submodule R M}", "(I J N)", "{M' : Type w} [AddCommMonoid M'] [Module R M']", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "{I J : Ideal R} {N P : Submodule R M}", "(S : Set R) (T : Set M)", "(I)", "{R : Type u} [Semiring R]", "{R : Type u} [Semiring R] {I J K L : Ideal R}", "(I)", "{I}", "(I J K)", "{I J K}", "[I.IsTwoSided] (m n : \u2115)", "{R : Type u} {\u03b9 : Type*} [CommSemiring R]", "{I J K L : Ideal R}", "(I J K)", "{I J K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\ns : Multiset (Ideal R)\n\u22a2 s.prod \u2264 s.inf"}, {"line": "classical\n    refine s.induction_on ?_ ?_\n    \u00b7 rw [Multiset.inf_zero]\n      exact le_top\n    intro a s ih\n    rw [Multiset.prod_cons]\n    rw [Multiset.inf_cons]\n    exact le_trans mul_le_inf (inf_le_inf le_rfl ih)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_mul_eq_of_coprime_right (h : I \u2294 K = \u22a4) : I \u2294 J * K = I \u2294 J := by\n  rw [mul_comm]\n  exact sup_mul_eq_of_coprime_left h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Operations.lean", "context": {"open": ["Pointwise", "Pointwise", "Pointwise in", "scoped Function in -- required for scoped `on` notation"], "variables": ["{R : Type u} {M : Type v} {M' F G : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "{I J : Ideal R} {N : Submodule R M}", "(I J N)", "{M' : Type w} [AddCommMonoid M'] [Module R M']", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "{I J : Ideal R} {N P : Submodule R M}", "(S : Set R) (T : Set M)", "(I)", "{R : Type u} [Semiring R]", "{R : Type u} [Semiring R] {I J K L : Ideal R}", "(I)", "{I}", "(I J K)", "{I J K}", "[I.IsTwoSided] (m n : \u2115)", "{R : Type u} {\u03b9 : Type*} [CommSemiring R]", "{I J K L : Ideal R}", "(I J K)", "{I J K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI J K : Ideal R\nh : I \u2294 K = \u22a4\n\u22a2 I \u2294 J * K = I \u2294 J"}, {"line": "rw [mul_comm]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI J K : Ideal R\nh : I \u2294 K = \u22a4\n\u22a2 I \u2294 K * J = I \u2294 J"}, {"line": "exact sup_mul_eq_of_coprime_left h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_pow_eq_top {n : \u2115} (h : I \u2294 J = \u22a4) : I \u2294 J ^ n = \u22a4 := by\n  rw [\u2190 Finset.card_range n]\n  rw [\u2190 Finset.prod_const]\n  exact sup_prod_eq_top fun _ _ => h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Operations.lean", "context": {"open": ["Pointwise", "Pointwise", "Pointwise in", "scoped Function in -- required for scoped `on` notation"], "variables": ["{R : Type u} {M : Type v} {M' F G : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "{I J : Ideal R} {N : Submodule R M}", "(I J N)", "{M' : Type w} [AddCommMonoid M'] [Module R M']", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "{I J : Ideal R} {N P : Submodule R M}", "(S : Set R) (T : Set M)", "(I)", "{R : Type u} [Semiring R]", "{R : Type u} [Semiring R] {I J K L : Ideal R}", "(I)", "{I}", "(I J K)", "{I J K}", "[I.IsTwoSided] (m n : \u2115)", "{R : Type u} {\u03b9 : Type*} [CommSemiring R]", "{I J K L : Ideal R}", "(I J K)", "{I J K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nn : \u2115\nh : I \u2294 J = \u22a4\n\u22a2 I \u2294 J ^ n = \u22a4"}, {"line": "rw [\u2190 Finset.card_range n]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nn : \u2115\nh : I \u2294 J = \u22a4\n\u22a2 I \u2294 J ^ (Finset.range n).card = \u22a4"}, {"line": "rw [\u2190 Finset.prod_const]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nn : \u2115\nh : I \u2294 J = \u22a4\n\u22a2 I \u2294 \u220f _x \u2208 Finset.range n, J = \u22a4"}, {"line": "exact sup_prod_eq_top fun _ _ => h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pow_sup_eq_top {n : \u2115} (h : I \u2294 J = \u22a4) : I ^ n \u2294 J = \u22a4 := by\n  rw [\u2190 Finset.card_range n]\n  rw [\u2190 Finset.prod_const]\n  exact prod_sup_eq_top fun _ _ => h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Operations.lean", "context": {"open": ["Pointwise", "Pointwise", "Pointwise in", "scoped Function in -- required for scoped `on` notation"], "variables": ["{R : Type u} {M : Type v} {M' F G : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "{I J : Ideal R} {N : Submodule R M}", "(I J N)", "{M' : Type w} [AddCommMonoid M'] [Module R M']", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "{I J : Ideal R} {N P : Submodule R M}", "(S : Set R) (T : Set M)", "(I)", "{R : Type u} [Semiring R]", "{R : Type u} [Semiring R] {I J K L : Ideal R}", "(I)", "{I}", "(I J K)", "{I J K}", "[I.IsTwoSided] (m n : \u2115)", "{R : Type u} {\u03b9 : Type*} [CommSemiring R]", "{I J K L : Ideal R}", "(I J K)", "{I J K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nn : \u2115\nh : I \u2294 J = \u22a4\n\u22a2 I ^ n \u2294 J = \u22a4"}, {"line": "rw [\u2190 Finset.card_range n]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nn : \u2115\nh : I \u2294 J = \u22a4\n\u22a2 I ^ (Finset.range n).card \u2294 J = \u22a4"}, {"line": "rw [\u2190 Finset.prod_const]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nn : \u2115\nh : I \u2294 J = \u22a4\n\u22a2 (\u220f _x \u2208 Finset.range n, I) \u2294 J = \u22a4"}, {"line": "exact prod_sup_eq_top fun _ _ => h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPrime.multiset_prod_mem_iff_exists_mem {I : Ideal R} (hI : I.IsPrime) (s : Multiset R) :\n    s.prod \u2208 I \u2194 \u2203 p \u2208 s, p \u2208 I := by\n  simpa [span_singleton_le_iff_mem] using (hI.multiset_prod_map_le (span {\u00b7}))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Operations.lean", "context": {"open": ["Pointwise", "Pointwise", "Pointwise in", "scoped Function in -- required for scoped `on` notation", "List in", "Finset in"], "variables": ["{R : Type u} {M : Type v} {M' F G : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "{I J : Ideal R} {N : Submodule R M}", "(I J N)", "{M' : Type w} [AddCommMonoid M'] [Module R M']", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "{I J : Ideal R} {N P : Submodule R M}", "(S : Set R) (T : Set M)", "(I)", "{R : Type u} [Semiring R]", "{R : Type u} [Semiring R] {I J K L : Ideal R}", "(I)", "{I}", "(I J K)", "{I J K}", "[I.IsTwoSided] (m n : \u2115)", "{R : Type u} {\u03b9 : Type*} [CommSemiring R]", "{I J K L : Ideal R}", "(I J K)", "{I J K}", "(I) in", "(R) in", "(I)", "{I}", "(I J)", "{I J} in", "{I J}", "(R) in", "(I)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI : Ideal R\nhI : I.IsPrime\ns : Multiset R\n\u22a2 s.prod \u2208 I \u2194 \u2203 p \u2208 s, p \u2208 I"}, {"line": "simpa [span_singleton_le_iff_mem] using (hI.multiset_prod_map_le (span {\u00b7}))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPrime.pow_le_iff {I P : Ideal R} [hP : P.IsPrime] {n : \u2115} (hn : n \u2260 0) :\n    I ^ n \u2264 P \u2194 I \u2264 P := by\n  have h : (Multiset.replicate n I).prod \u2264 P \u2194 _ := hP.multiset_prod_le\n  simp_rw [Multiset.prod_replicate, Multiset.mem_replicate, ne_eq, hn, not_false_eq_true,\n    true_and, exists_eq_left] at h\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Operations.lean", "context": {"open": ["Pointwise", "Pointwise", "Pointwise in", "scoped Function in -- required for scoped `on` notation", "List in", "Finset in"], "variables": ["{R : Type u} {M : Type v} {M' F G : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "{I J : Ideal R} {N : Submodule R M}", "(I J N)", "{M' : Type w} [AddCommMonoid M'] [Module R M']", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "{I J : Ideal R} {N P : Submodule R M}", "(S : Set R) (T : Set M)", "(I)", "{R : Type u} [Semiring R]", "{R : Type u} [Semiring R] {I J K L : Ideal R}", "(I)", "{I}", "(I J K)", "{I J K}", "[I.IsTwoSided] (m n : \u2115)", "{R : Type u} {\u03b9 : Type*} [CommSemiring R]", "{I J K L : Ideal R}", "(I J K)", "{I J K}", "(I) in", "(R) in", "(I)", "{I}", "(I J)", "{I J} in", "{I J}", "(R) in", "(I)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI P : Ideal R\nhP : P.IsPrime\nn : \u2115\nhn : n \u2260 0\n\u22a2 I ^ n \u2264 P \u2194 I \u2264 P"}, {"line": "have h : (Multiset.replicate n I).prod \u2264 P \u2194 _ := hP.multiset_prod_le", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI P : Ideal R\nhP : P.IsPrime\nn : \u2115\nhn : n \u2260 0\nh : (Multiset.replicate n I).prod \u2264 P \u2194 \u2203 I_1 \u2208 Multiset.replicate n I, I_1 \u2264 P\n\u22a2 I ^ n \u2264 P \u2194 I \u2264 P"}, {"line": "simp_rw [Multiset.prod_replicate, Multiset.mem_replicate, ne_eq, hn, not_false_eq_true,\n    true_and, exists_eq_left] at h", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI P : Ideal R\nhP : P.IsPrime\nn : \u2115\nhn : n \u2260 0\nh : I ^ n \u2264 P \u2194 I \u2264 P\n\u22a2 I ^ n \u2264 P \u2194 I \u2264 P"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPrime.prod_mem_iff_exists_mem {I : Ideal R} (hI : I.IsPrime) (s : Finset R) :\n    s.prod (fun x \u21a6 x) \u2208 I \u2194 \u2203 p \u2208 s, p \u2208 I := by\n  rw [Finset.prod_eq_multiset_prod]\n  rw [Multiset.map_id']\n  exact hI.multiset_prod_mem_iff_exists_mem s.val\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Operations.lean", "context": {"open": ["Pointwise", "Pointwise", "Pointwise in", "scoped Function in -- required for scoped `on` notation", "List in", "Finset in"], "variables": ["{R : Type u} {M : Type v} {M' F G : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "{I J : Ideal R} {N : Submodule R M}", "(I J N)", "{M' : Type w} [AddCommMonoid M'] [Module R M']", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "{I J : Ideal R} {N P : Submodule R M}", "(S : Set R) (T : Set M)", "(I)", "{R : Type u} [Semiring R]", "{R : Type u} [Semiring R] {I J K L : Ideal R}", "(I)", "{I}", "(I J K)", "{I J K}", "[I.IsTwoSided] (m n : \u2115)", "{R : Type u} {\u03b9 : Type*} [CommSemiring R]", "{I J K L : Ideal R}", "(I J K)", "{I J K}", "(I) in", "(R) in", "(I)", "{I}", "(I J)", "{I J} in", "{I J}", "(R) in", "(I)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI : Ideal R\nhI : I.IsPrime\ns : Finset R\n\u22a2 \u220f x \u2208 s, x \u2208 I \u2194 \u2203 p \u2208 s, p \u2208 I"}, {"line": "rw [Finset.prod_eq_multiset_prod]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI : Ideal R\nhI : I.IsPrime\ns : Finset R\n\u22a2 (Multiset.map (fun x => x) s.val).prod \u2208 I \u2194 \u2203 p \u2208 s, p \u2208 I"}, {"line": "rw [Multiset.map_id']", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nI : Ideal R\nhI : I.IsPrime\ns : Finset R\n\u22a2 s.val.prod \u2208 I \u2194 \u2203 p \u2208 s, p \u2208 I"}, {"line": "exact hI.multiset_prod_mem_iff_exists_mem s.val", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Associates.mk_ne_zero' {R : Type*} [CommSemiring R] {r : R} :\n    Associates.mk (Ideal.span {r} : Ideal R) \u2260 0 \u2194 r \u2260 0 := by\n  rw [Associates.mk_ne_zero]\n  rw [Ideal.zero_eq_bot]\n  rw [Ne]\n  rw [Ideal.span_singleton_eq_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Operations.lean", "context": {"open": ["Pointwise", "Pointwise", "Pointwise in", "scoped Function in -- required for scoped `on` notation", "List in", "Finset in"], "variables": ["{R : Type u} {M : Type v} {M' F G : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]", "{I J : Ideal R} {N : Submodule R M}", "(I J N)", "{M' : Type w} [AddCommMonoid M'] [Module R M']", "[CommSemiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M'] [Module R M']", "{I J : Ideal R} {N P : Submodule R M}", "(S : Set R) (T : Set M)", "(I)", "{R : Type u} [Semiring R]", "{R : Type u} [Semiring R] {I J K L : Ideal R}", "(I)", "{I}", "(I J K)", "{I J K}", "[I.IsTwoSided] (m n : \u2115)", "{R : Type u} {\u03b9 : Type*} [CommSemiring R]", "{I J K L : Ideal R}", "(I J K)", "{I J K}", "(I) in", "(R) in", "(I)", "{I}", "(I J)", "{I J} in", "{I J}", "(R) in", "(I)", "(\u03b9 : Type*)", "(M : Type*) [AddCommGroup M] {R : Type*} [CommRing R] [Module R M] (I : Ideal R)", "(v : \u03b9 \u2192 M) (hv : Submodule.span R (Set.range v) = \u22a4)", "{\u03b9 M v}", "{\u03b1 R : Type*} [Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_7\ninst\u271d : CommSemiring R\nr : R\n\u22a2 Associates.mk (Ideal.span {r}) \u2260 0 \u2194 r \u2260 0"}, {"line": "rw [Associates.mk_ne_zero]", "tactic_state": "R : Type u_7\ninst\u271d : CommSemiring R\nr : R\n\u22a2 Ideal.span {r} \u2260 0 \u2194 r \u2260 0"}, {"line": "rw [Ideal.zero_eq_bot]", "tactic_state": "R : Type u_7\ninst\u271d : CommSemiring R\nr : R\n\u22a2 Ideal.span {r} \u2260 \u22a5 \u2194 r \u2260 0"}, {"line": "rw [Ne]", "tactic_state": "R : Type u_7\ninst\u271d : CommSemiring R\nr : R\n\u22a2 \u00acIdeal.span {r} = \u22a5 \u2194 r \u2260 0"}, {"line": "rw [Ideal.span_singleton_eq_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_isPrime_iff {I : Ideal \u03b1} :\n    \u00acI.IsPrime \u2194 I = \u22a4 \u2228 \u2203 (x : \u03b1) (_hx : x \u2209 I) (y : \u03b1) (_hy : y \u2209 I), x * y \u2208 I := by\n  simp_rw [Ideal.isPrime_iff, not_and_or, Ne, Classical.not_not, not_forall, not_or]\n  exact\n    or_congr Iff.rfl\n      \u27e8fun \u27e8x, y, hxy, hx, hy\u27e9 => \u27e8x, hx, y, hy, hxy\u27e9, fun \u27e8x, hx, y, hy, hxy\u27e9 =>\n        \u27e8x, y, hxy, hx, hy\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Prime.lean", "context": {"open": ["Set Function", "Pointwise"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {F : Type w}", "[Semiring \u03b1] (I : Ideal \u03b1) {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Semiring \u03b1\nI : Ideal \u03b1\n\u22a2 \u00acI.IsPrime \u2194 I = \u22a4 \u2228 \u2203 x, \u2203 (_ : x \u2209 I), \u2203 y, \u2203 (_ : y \u2209 I), x * y \u2208 I"}, {"line": "simp_rw [Ideal.isPrime_iff, not_and_or, Ne, Classical.not_not, not_forall, not_or]", "tactic_state": "\u03b1 : Type u\ninst\u271d : Semiring \u03b1\nI : Ideal \u03b1\n\u22a2 (I = \u22a4 \u2228 \u2203 x x_1, \u2203 (_ : x * x_1 \u2208 I), x \u2209 I \u2227 x_1 \u2209 I) \u2194 I = \u22a4 \u2228 \u2203 x, \u2203 (_ : x \u2209 I), \u2203 y, \u2203 (_ : y \u2209 I), x * y \u2208 I"}, {"line": "exact\n    or_congr Iff.rfl\n      \u27e8fun \u27e8x, y, hxy, hx, hy\u27e9 => \u27e8x, hx, y, hy, hxy\u27e9, fun \u27e8x, hx, y, hy, hxy\u27e9 =>\n        \u27e8x, y, hxy, hx, hy\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsAssociatedPrime.annihilator_le (h : IsAssociatedPrime I M) :\n    (\u22a4 : Submodule R M).annihilator \u2264 I := by\n  obtain \u27e8hI, x, rfl\u27e9 := h\n  rw [\u2190 Submodule.annihilator_span_singleton]\n  exact Submodule.annihilator_mono le_top\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/AssociatedPrime/Basic.lean", "context": {"open": ["LinearMap"], "variables": ["{R : Type*} [CommRing R] (I J : Ideal R) (M : Type*) [AddCommGroup M] [Module R M]", "(R)", "{I J M R}", "{M' : Type*} [AddCommGroup M'] [Module R M'] (f : M \u2192\u2097[R] M')", "(R) in", "{f} {M'' : Type*} [AddCommGroup M''] [Module R M''] {g : M' \u2192\u2097[R] M''}", "(R M M') in", "(R M)", "{R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\nI : Ideal R\nM : Type u_2\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nh : IsAssociatedPrime I M\n\u22a2 \u22a4.annihilator \u2264 I"}, {"line": "obtain \u27e8hI, x, rfl\u27e9 := h", "tactic_state": "case intro.intro\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx : M\nhI : Ideal.IsPrime (ker (toSpanSingleton R M x))\n\u22a2 \u22a4.annihilator \u2264 ker (toSpanSingleton R M x)"}, {"line": "rw [\u2190 Submodule.annihilator_span_singleton]", "tactic_state": "case intro.intro\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx : M\nhI : Ideal.IsPrime (ker (toSpanSingleton R M x))\n\u22a2 \u22a4.annihilator \u2264 (Submodule.span R {x}).annihilator"}, {"line": "exact Submodule.annihilator_mono le_top", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ideal.minimalPrimes_top : (\u22a4 : Ideal R).minimalPrimes = \u2205 := by\n  ext p\n  simp only [Set.not_mem_empty]\n  simp only [iff_false]\n  intro h\n  exact h.1.1.ne_top (top_le_iff.mp h.1.2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/MinimalPrime/Basic.lean", "context": {"open": [], "variables": ["{R S : Type*} [CommSemiring R] [CommSemiring S] (I J : Ideal R)", "(R) in", "{I J}", "{R S : Type*} [CommRing R] [CommRing S] {I J : Ideal R}", "{R : Type*} [CommSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\ninst\u271d : CommSemiring R\n\u22a2 \u22a4.minimalPrimes = \u2205"}, {"line": "ext p", "tactic_state": "case h\nR : Type u_5\ninst\u271d : CommSemiring R\np : Ideal R\n\u22a2 p \u2208 \u22a4.minimalPrimes \u2194 p \u2208 \u2205"}, {"line": "simp only [Set.not_mem_empty]", "tactic_state": "case h\nR : Type u_5\ninst\u271d : CommSemiring R\np : Ideal R\n\u22a2 p \u2208 \u22a4.minimalPrimes \u2194 False"}, {"line": "simp only [iff_false]", "tactic_state": "case h\nR : Type u_5\ninst\u271d : CommSemiring R\np : Ideal R\n\u22a2 p \u2209 \u22a4.minimalPrimes"}, {"line": "intro h", "tactic_state": "case h\nR : Type u_5\ninst\u271d : CommSemiring R\np : Ideal R\nh : p \u2208 \u22a4.minimalPrimes\n\u22a2 False"}, {"line": "exact h.1.1.ne_top (top_le_iff.mp h.1.2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ideal.minimalPrimes_eq_comap :\n    I.minimalPrimes = Ideal.comap (Ideal.Quotient.mk I) '' minimalPrimes (R \u29f8 I) := by\n  rw [minimalPrimes]\n  rw [\u2190 Ideal.comap_minimalPrimes_eq_of_surjective Ideal.Quotient.mk_surjective]\n  rw [\u2190 RingHom.ker_eq_comap_bot]\n  rw [Ideal.mk_ker]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/MinimalPrime/Localization.lean", "context": {"open": [], "variables": ["{R S : Type*} [CommSemiring R] [CommSemiring S] {I J : Ideal R}", "{R S : Type*} [CommRing R] [CommRing S] {I J : Ideal R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d : CommRing R\nI : Ideal R\n\u22a2 I.minimalPrimes = comap (Quotient.mk I) '' minimalPrimes (R \u29f8 I)"}, {"line": "rw [minimalPrimes]", "tactic_state": "R : Type u_3\ninst\u271d : CommRing R\nI : Ideal R\n\u22a2 I.minimalPrimes = comap (Quotient.mk I) '' \u22a5.minimalPrimes"}, {"line": "rw [\u2190 Ideal.comap_minimalPrimes_eq_of_surjective Ideal.Quotient.mk_surjective]", "tactic_state": "R : Type u_3\ninst\u271d : CommRing R\nI : Ideal R\n\u22a2 I.minimalPrimes = (comap (Quotient.mk I) \u22a5).minimalPrimes"}, {"line": "rw [\u2190 RingHom.ker_eq_comap_bot]", "tactic_state": "R : Type u_3\ninst\u271d : CommRing R\nI : Ideal R\n\u22a2 I.minimalPrimes = (RingHom.ker (Quotient.mk I)).minimalPrimes"}, {"line": "rw [Ideal.mk_ker]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardQuot_mul_of_coprime\n    {I J : Ideal S} (coprime : IsCoprime I J) : cardQuot (I * J) = cardQuot I * cardQuot J := by\n  rw [cardQuot_apply]\n  rw [cardQuot_apply]\n  rw [cardQuot_apply]\n  rw [Nat.card_congr (Ideal.quotientMulEquivQuotientProd I J coprime).toEquiv]\n  rw [Nat.card_prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Norm/AbsNorm.lean", "context": {"open": ["scoped nonZeroDivisors", "Submodule"], "variables": ["{R M : Type*} [Ring R] [AddCommGroup M] [Module R M]", "(R M)", "{R M}", "{S : Type*} [CommRing S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_3\ninst\u271d : CommRing S\nI J : Ideal S\ncoprime : IsCoprime I J\n\u22a2 cardQuot (I * J) = cardQuot I * cardQuot J"}, {"line": "rw [cardQuot_apply]", "tactic_state": "S : Type u_3\ninst\u271d : CommRing S\nI J : Ideal S\ncoprime : IsCoprime I J\n\u22a2 Nat.card (S \u29f8 I * J) = cardQuot I * cardQuot J"}, {"line": "rw [cardQuot_apply]", "tactic_state": "S : Type u_3\ninst\u271d : CommRing S\nI J : Ideal S\ncoprime : IsCoprime I J\n\u22a2 Nat.card (S \u29f8 I * J) = Nat.card (S \u29f8 I) * cardQuot J"}, {"line": "rw [cardQuot_apply]", "tactic_state": "S : Type u_3\ninst\u271d : CommRing S\nI J : Ideal S\ncoprime : IsCoprime I J\n\u22a2 Nat.card (S \u29f8 I * J) = Nat.card (S \u29f8 I) * Nat.card (S \u29f8 J)"}, {"line": "rw [Nat.card_congr (Ideal.quotientMulEquivQuotientProd I J coprime).toEquiv]", "tactic_state": "S : Type u_3\ninst\u271d : CommRing S\nI J : Ideal S\ncoprime : IsCoprime I J\n\u22a2 Nat.card ?m.13596 = Nat.card (S \u29f8 I) * Nat.card (S \u29f8 J)\n---\nS : Type u_3\ninst\u271d : CommRing S\nI J : Ideal S\ncoprime : IsCoprime I J\n\u22a2 Type ?u.13593"}, {"line": "rw [Nat.card_prod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem spanNorm_top : spanNorm R (\u22a4 : Ideal S) = \u22a4 := by\n  simp [\u2190 Ideal.span_singleton_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Ideal/Norm/RelNorm.lean", "context": {"open": ["scoped nonZeroDivisors", "Submodule"], "variables": ["(R S : Type*) [CommRing R] [IsDomain R] {S : Type*} [CommRing S] [IsDomain S]", "[IsIntegrallyClosed R] [IsIntegrallyClosed S] [Algebra R S] [Module.Finite R S]", "[NoZeroSMulDivisors R S] [Algebra.IsSeparable (FractionRing R) (FractionRing S)]", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nspanNorm : x\u271d\n\u22a2 sorry = \u22a4"}, {"line": "simp [\u2190 Ideal.span_singleton_one]", "tactic_state": "x\u271d : Sort u_4\nspanNorm : x\u271d\n\u22a2 sorry () = \u22a4"}]}
{"declaration": "theorem Int.Prime.dvd_mul {m n : \u2124} {p : \u2115} (hp : Nat.Prime p) (h : (p : \u2124) \u2223 m * n) :\n    p \u2223 m.natAbs \u2228 p \u2223 n.natAbs := by\n  rwa [\u2190 hp.dvd_mul, \u2190 Int.natAbs_mul, \u2190 Int.natCast_dvd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Int/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2124\np : \u2115\nhp : Nat.Prime p\nh : \u2191p \u2223 m * n\n\u22a2 p \u2223 m.natAbs \u2228 p \u2223 n.natAbs"}, {"line": "rwa [\u2190 hp.dvd_mul, \u2190 Int.natAbs_mul, \u2190 Int.natCast_dvd]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Int.Prime.dvd_mul' {m n : \u2124} {p : \u2115} (hp : Nat.Prime p) (h : (p : \u2124) \u2223 m * n) :\n    (p : \u2124) \u2223 m \u2228 (p : \u2124) \u2223 n := by\n  rw [Int.natCast_dvd]\n  rw [Int.natCast_dvd]\n  exact Int.Prime.dvd_mul hp h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Int/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2124\np : \u2115\nhp : Nat.Prime p\nh : \u2191p \u2223 m * n\n\u22a2 \u2191p \u2223 m \u2228 \u2191p \u2223 n"}, {"line": "rw [Int.natCast_dvd]", "tactic_state": "m n : \u2124\np : \u2115\nhp : Nat.Prime p\nh : \u2191p \u2223 m * n\n\u22a2 p \u2223 m.natAbs \u2228 \u2191p \u2223 n"}, {"line": "rw [Int.natCast_dvd]", "tactic_state": "m n : \u2124\np : \u2115\nhp : Nat.Prime p\nh : \u2191p \u2223 m * n\n\u22a2 p \u2223 m.natAbs \u2228 p \u2223 n.natAbs"}, {"line": "exact Int.Prime.dvd_mul hp h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Int.Prime.dvd_pow {n : \u2124} {k p : \u2115} (hp : Nat.Prime p) (h : (p : \u2124) \u2223 n ^ k) :\n    p \u2223 n.natAbs := by\n  rw [Int.natCast_dvd] at h\n  rw [Int.natAbs_pow] at h\n  exact hp.dvd_of_dvd_pow h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Int/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\nk p : \u2115\nhp : Nat.Prime p\nh : \u2191p \u2223 n ^ k\n\u22a2 p \u2223 n.natAbs"}, {"line": "rw [Int.natCast_dvd] at h", "tactic_state": "n : \u2124\nk p : \u2115\nhp : Nat.Prime p\nh : p \u2223 (n ^ k).natAbs\n\u22a2 p \u2223 n.natAbs"}, {"line": "rw [Int.natAbs_pow] at h", "tactic_state": "n : \u2124\nk p : \u2115\nhp : Nat.Prime p\nh : p \u2223 n.natAbs ^ k\n\u22a2 p \u2223 n.natAbs"}, {"line": "exact hp.dvd_of_dvd_pow h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Int.Prime.dvd_pow' {n : \u2124} {k p : \u2115} (hp : Nat.Prime p) (h : (p : \u2124) \u2223 n ^ k) :\n    (p : \u2124) \u2223 n := by\n  rw [Int.natCast_dvd]\n  exact Int.Prime.dvd_pow hp h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Int/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\nk p : \u2115\nhp : Nat.Prime p\nh : \u2191p \u2223 n ^ k\n\u22a2 \u2191p \u2223 n"}, {"line": "rw [Int.natCast_dvd]", "tactic_state": "n : \u2124\nk p : \u2115\nhp : Nat.Prime p\nh : \u2191p \u2223 n ^ k\n\u22a2 p \u2223 n.natAbs"}, {"line": "exact Int.Prime.dvd_pow hp h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Int.exists_prime_and_dvd {n : \u2124} (hn : n.natAbs \u2260 1) : \u2203 p, Prime p \u2227 p \u2223 n := by\n  obtain \u27e8p, pp, pd\u27e9 := Nat.exists_prime_and_dvd hn\n  exact \u27e8p, Nat.prime_iff_prime_int.mp pp, Int.natCast_dvd.mpr pd\u27e9\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Int/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\nhn : n.natAbs \u2260 1\n\u22a2 \u2203 p, Prime p \u2227 p \u2223 n"}, {"line": "obtain \u27e8p, pp, pd\u27e9 := Nat.exists_prime_and_dvd hn", "tactic_state": "case intro.intro\nn : \u2124\nhn : n.natAbs \u2260 1\np : \u2115\npp : Nat.Prime p\npd : p \u2223 n.natAbs\n\u22a2 \u2203 p, Prime p \u2227 p \u2223 n"}, {"line": "exact \u27e8p, Nat.prime_iff_prime_int.mp pp, Int.natCast_dvd.mpr pd\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem span_natAbs (a : \u2124) : Ideal.span ({(a.natAbs : \u2124)} : Set \u2124) = Ideal.span {a} := by\n  rw [Ideal.span_singleton_eq_span_singleton]\n  exact (associated_natAbs _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Int/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2124\n\u22a2 Ideal.span {\u2191a.natAbs} = Ideal.span {a}"}, {"line": "rw [Ideal.span_singleton_eq_span_singleton]", "tactic_state": "a : \u2124\n\u22a2 Associated (\u2191a.natAbs) a"}, {"line": "exact (associated_natAbs _).symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Algebra.intNorm_ne_zero {x : B} : Algebra.intNorm A B x \u2260 0 \u2194 x \u2260 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IntegralClosure/IntegralRestrict.lean", "context": {"open": ["nonZeroDivisors", "nonZeroDivisors"], "variables": ["(A K L B : Type*) [CommRing A] [CommRing B] [Algebra A B] [Field K] [Field L]", "[Algebra.IsAlgebraic K L]", "{K L}", "{B}", "[FiniteDimensional K L]", "{A\u2098 B\u2098} [CommRing A\u2098] [CommRing B\u2098] [Algebra A\u2098 B\u2098] [Algebra A A\u2098] [Algebra B B\u2098]", "[Algebra A B\u2098] [IsScalarTower A A\u2098 B\u2098] [IsScalarTower A B B\u2098]", "(M : Submonoid A) [IsLocalization M A\u2098]", "[IsLocalization (Algebra.algebraMapSubmonoid B M) B\u2098]", "{A K L B}", "(A B)", "[IsDomain A] [IsIntegrallyClosed A] [IsDomain B] [IsIntegrallyClosed B]", "[Module.Finite A B] [NoZeroSMulDivisors A B]", "{A B}", "(A B)", "[IsDomain A\u2098] [IsIntegrallyClosed A\u2098] [IsDomain B\u2098] [IsIntegrallyClosed B\u2098]", "[NoZeroSMulDivisors A\u2098 B\u2098] [Module.Finite A\u2098 B\u2098]", "[IsIntegrallyClosed A]", "{A K L B}", "(A B)", "[IsDomain A] [IsDomain B] [IsIntegrallyClosed B]", "[Module.Finite A B] [NoZeroSMulDivisors A B]", "[Algebra.IsSeparable (FractionRing A) (FractionRing B)] -- TODO: remove this", "{A B}", "(A B)", "{A B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2074 : CommRing A\ninst\u271d\u00b9\u00b3 : CommRing B\ninst\u271d\u00b9\u00b2 : Algebra A B\ninst\u271d\u00b9\u00b9 : IsDomain A\ninst\u271d\u00b9\u2070 : IsIntegrallyClosed A\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : IsIntegrallyClosed B\ninst\u271d\u2077 : Module.Finite A B\ninst\u271d\u2076 : NoZeroSMulDivisors A B\ninst\u271d\u2075 : IsIntegrallyClosed A\ninst\u271d\u2074 : IsDomain A\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : IsIntegrallyClosed B\ninst\u271d\u00b9 : Module.Finite A B\ninst\u271d : NoZeroSMulDivisors A B\nx : B\n\u22a2 sorry \u2260 0 \u2194 x \u2260 0"}, {"line": "simp", "tactic_state": "A : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2074 : CommRing A\ninst\u271d\u00b9\u00b3 : CommRing B\ninst\u271d\u00b9\u00b2 : Algebra A B\ninst\u271d\u00b9\u00b9 : IsDomain A\ninst\u271d\u00b9\u2070 : IsIntegrallyClosed A\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : IsIntegrallyClosed B\ninst\u271d\u2077 : Module.Finite A B\ninst\u271d\u2076 : NoZeroSMulDivisors A B\ninst\u271d\u2075 : IsIntegrallyClosed A\ninst\u271d\u2074 : IsDomain A\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : IsIntegrallyClosed B\ninst\u271d\u00b9 : Module.Finite A B\ninst\u271d : NoZeroSMulDivisors A B\nx : B\n\u22a2 \u00acsorry () = 0 \u2194 \u00acx = 0"}]}
{"declaration": "theorem isIntegrallyClosed_iff :\n    IsIntegrallyClosed R \u2194 \u2200 {x : K}, IsIntegral R x \u2192 \u2203 y, algebraMap R K y = x := by\n  simp [isIntegrallyClosed_iff_isIntegrallyClosedIn K, isIntegrallyClosedIn_iff,\n        IsFractionRing.injective R K]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IntegralClosure/IntegrallyClosed.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "Polynomial"], "variables": ["{R : Type*} [CommRing R]", "{A B : Type*} [CommRing A] [CommRing B] [Algebra R A] [Algebra R B]", "(K : Type*) [CommRing K] [Algebra R K] [IsFractionRing R K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommRing R\nK : Type u_4\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\n\u22a2 IsIntegrallyClosed R \u2194 \u2200 {x : K}, IsIntegral R x \u2192 \u2203 y, (algebraMap R K) y = x"}, {"line": "simp [isIntegrallyClosed_iff_isIntegrallyClosedIn K, isIntegrallyClosedIn_iff,\n        IsFractionRing.injective R K]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommRing R\nK : Type u_4\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\n\u22a2 (Function.Injective \u21d1(algebraMap R (FractionRing R)) \u2227\n      \u2200 {x : FractionRing R}, IsIntegral R x \u2192 \u2203 y, (algebraMap R (FractionRing R)) y = x) \u2194\n    \u2200 {x : K}, IsIntegral R x \u2192 \u2203 y, (algebraMap R K) y = x"}]}
{"declaration": "theorem integralClosure_eq_bot_iff (hRA : Function.Injective (algebraMap R A)) :\n    integralClosure R A = \u22a5 \u2194 IsIntegrallyClosedIn R A := by\n  refine eq_bot_iff.trans ?_\n  constructor\n  \u00b7 intro h\n    refine \u27e8 hRA, fun hx => Set.mem_range.mp (Algebra.mem_bot.mp (h hx)), ?_\u27e9\n    rintro \u27e8y, rfl\u27e9\n    apply isIntegral_algebraMap\n  \u00b7 intro h x hx\n    rw [Algebra.mem_bot]\n    rw [Set.mem_range]\n    exact isIntegral_iff.mp hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IntegralClosure/IntegrallyClosed.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "Polynomial"], "variables": ["{R : Type*} [CommRing R]", "{A B : Type*} [CommRing A] [CommRing B] [Algebra R A] [Algebra R B]", "(K : Type*) [CommRing K] [Algebra R K] [IsFractionRing R K]", "{R A : Type*} [CommRing R] [CommRing A] [Algebra R A]", "(A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\nA : Type u_6\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhRA : Function.Injective \u21d1(algebraMap R A)\n\u22a2 integralClosure R A = \u22a5 \u2194 IsIntegrallyClosedIn R A"}, {"line": "refine eq_bot_iff.trans ?_", "tactic_state": "R : Type u_5\nA : Type u_6\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhRA : Function.Injective \u21d1(algebraMap R A)\n\u22a2 integralClosure R A \u2264 \u22a5 \u2194 IsIntegrallyClosedIn R A"}, {"line": "constructor", "tactic_state": "case mp\nR : Type u_5\nA : Type u_6\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhRA : Function.Injective \u21d1(algebraMap R A)\n\u22a2 integralClosure R A \u2264 \u22a5 \u2192 IsIntegrallyClosedIn R A\n---\ncase mpr\nR : Type u_5\nA : Type u_6\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhRA : Function.Injective \u21d1(algebraMap R A)\n\u22a2 IsIntegrallyClosedIn R A \u2192 integralClosure R A \u2264 \u22a5"}, {"line": "\u00b7 intro h\n    refine \u27e8 hRA, fun hx => Set.mem_range.mp (Algebra.mem_bot.mp (h hx)), ?_\u27e9\n    rintro \u27e8y, rfl\u27e9\n    apply isIntegral_algebraMap", "tactic_state": "case mpr\nR : Type u_5\nA : Type u_6\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nhRA : Function.Injective \u21d1(algebraMap R A)\n\u22a2 IsIntegrallyClosedIn R A \u2192 integralClosure R A \u2264 \u22a5"}, {"line": "\u00b7 intro h x hx\n    rw [Algebra.mem_bot]\n    rw [Set.mem_range]\n    exact isIntegral_iff.mp hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem RingHom.IsIntegralElem.sub {x y : S} (hx : f.IsIntegralElem x) (hy : f.IsIntegralElem y) :\n    f.IsIntegralElem (x - y) := by\n  simpa only [sub_eq_add_neg] using hx.add f (hy.neg f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IntegralClosure/Algebra/Basic.lean", "context": {"open": ["Polynomial Submodule"], "variables": ["{R A B S : Type*}", "[CommRing R] [CommRing A] [Ring B] [CommRing S]", "[Algebra R A] [Algebra R B] (f : R \u2192+* S)", "{A B : Type*} [Ring A] [Ring B] [Algebra R A] [Algebra R B]", "(R) in", "(R B) in", "{f}", "(f)", "(f : R \u2192+* B)", "(f : R \u2192+* S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_4\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nf : R \u2192+* S\nx y : S\nhx : f.IsIntegralElem x\nhy : f.IsIntegralElem y\n\u22a2 f.IsIntegralElem (x - y)"}, {"line": "simpa only [sub_eq_add_neg] using hx.add f (hy.neg f)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsIntegral.pair {x : A \u00d7 B} (hx\u2081 : IsIntegral R x.1) (hx\u2082 : IsIntegral R x.2) :\n    IsIntegral R x := by\n  obtain \u27e8p\u2081, \u27e8hp\u2081Monic, hp\u2081Eval\u27e9\u27e9 := hx\u2081\n  obtain \u27e8p\u2082, \u27e8hp\u2082Monic, hp\u2082Eval\u27e9\u27e9 := hx\u2082\n  refine \u27e8p\u2081 * p\u2082, \u27e8hp\u2081Monic.mul hp\u2082Monic, ?_\u27e9\u27e9\n  rw [\u2190 aeval_def] at *\n  rw [aeval_prod_apply]\n  rw [aeval_mul]\n  rw [hp\u2081Eval]\n  rw [zero_mul]\n  rw [aeval_mul]\n  rw [hp\u2082Eval]\n  rw [mul_zero]\n  rw [Prod.zero_eq_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IntegralClosure/IsIntegral/Basic.lean", "context": {"open": ["Polynomial Submodule", "Classical in"], "variables": ["{R S A : Type*}", "[CommRing R] [Ring A] [Ring S] (f : R \u2192+* S)", "[Algebra R A]", "{R A B S : Type*}", "[CommRing R] [CommRing A] [Ring B] [CommRing S]", "[Algebra R A] (f : R \u2192+* S)", "{A B : Type*} [Ring A] [Ring B] [Algebra R A] [Algebra R B]", "(f : R \u2192+* B)", "(f : R \u2192+* S)", "{R A B S : Type*}", "[CommRing R] [CommRing A] [Ring B] [CommRing S]", "[Algebra R A] [Algebra R B] (f : R \u2192+* S)", "{R A B : Type*}", "[CommRing R] [Ring A] [Ring B] [Algebra R A] [Algebra R B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_11\nA : Type u_12\nB : Type u_13\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx : A \u00d7 B\nhx\u2081 : IsIntegral R x.1\nhx\u2082 : IsIntegral R x.2\n\u22a2 IsIntegral R x"}, {"line": "obtain \u27e8p\u2081, \u27e8hp\u2081Monic, hp\u2081Eval\u27e9\u27e9 := hx\u2081", "tactic_state": "case intro.intro\nR : Type u_11\nA : Type u_12\nB : Type u_13\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx : A \u00d7 B\nhx\u2082 : IsIntegral R x.2\np\u2081 : Polynomial R\nhp\u2081Monic : p\u2081.Monic\nhp\u2081Eval : eval\u2082 (algebraMap R A) x.1 p\u2081 = 0\n\u22a2 IsIntegral R x"}, {"line": "obtain \u27e8p\u2082, \u27e8hp\u2082Monic, hp\u2082Eval\u27e9\u27e9 := hx\u2082", "tactic_state": "case intro.intro.intro.intro\nR : Type u_11\nA : Type u_12\nB : Type u_13\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx : A \u00d7 B\np\u2081 : Polynomial R\nhp\u2081Monic : p\u2081.Monic\nhp\u2081Eval : eval\u2082 (algebraMap R A) x.1 p\u2081 = 0\np\u2082 : Polynomial R\nhp\u2082Monic : p\u2082.Monic\nhp\u2082Eval : eval\u2082 (algebraMap R B) x.2 p\u2082 = 0\n\u22a2 IsIntegral R x"}, {"line": "refine \u27e8p\u2081 * p\u2082, \u27e8hp\u2081Monic.mul hp\u2082Monic, ?_\u27e9\u27e9", "tactic_state": "case intro.intro.intro.intro\nR : Type u_11\nA : Type u_12\nB : Type u_13\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx : A \u00d7 B\np\u2081 : Polynomial R\nhp\u2081Monic : p\u2081.Monic\nhp\u2081Eval : eval\u2082 (algebraMap R A) x.1 p\u2081 = 0\np\u2082 : Polynomial R\nhp\u2082Monic : p\u2082.Monic\nhp\u2082Eval : eval\u2082 (algebraMap R B) x.2 p\u2082 = 0\n\u22a2 eval\u2082 (algebraMap R (A \u00d7 B)) x (p\u2081 * p\u2082) = 0"}, {"line": "rw [\u2190 aeval_def] at *", "tactic_state": "case intro.intro.intro.intro\nR : Type u_11\nA : Type u_12\nB : Type u_13\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx : A \u00d7 B\np\u2081 : Polynomial R\nhp\u2081Monic : p\u2081.Monic\nhp\u2081Eval : (aeval x.1) p\u2081 = 0\np\u2082 : Polynomial R\nhp\u2082Monic : p\u2082.Monic\nhp\u2082Eval : (aeval x.2) p\u2082 = 0\n\u22a2 (aeval x) (p\u2081 * p\u2082) = 0"}, {"line": "rw [aeval_prod_apply]", "tactic_state": "case intro.intro.intro.intro\nR : Type u_11\nA : Type u_12\nB : Type u_13\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx : A \u00d7 B\np\u2081 : Polynomial R\nhp\u2081Monic : p\u2081.Monic\nhp\u2081Eval : (aeval x.1) p\u2081 = 0\np\u2082 : Polynomial R\nhp\u2082Monic : p\u2082.Monic\nhp\u2082Eval : (aeval x.2) p\u2082 = 0\n\u22a2 ((aeval x.1) (p\u2081 * p\u2082), (aeval x.2) (p\u2081 * p\u2082)) = 0"}, {"line": "rw [aeval_mul]", "tactic_state": "case intro.intro.intro.intro\nR : Type u_11\nA : Type u_12\nB : Type u_13\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx : A \u00d7 B\np\u2081 : Polynomial R\nhp\u2081Monic : p\u2081.Monic\nhp\u2081Eval : (aeval x.1) p\u2081 = 0\np\u2082 : Polynomial R\nhp\u2082Monic : p\u2082.Monic\nhp\u2082Eval : (aeval x.2) p\u2082 = 0\n\u22a2 ((aeval x.1) p\u2081 * (aeval x.1) p\u2082, (aeval x.2) (p\u2081 * p\u2082)) = 0"}, {"line": "rw [hp\u2081Eval]", "tactic_state": "case intro.intro.intro.intro\nR : Type u_11\nA : Type u_12\nB : Type u_13\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx : A \u00d7 B\np\u2081 : Polynomial R\nhp\u2081Monic : p\u2081.Monic\nhp\u2081Eval : (aeval x.1) p\u2081 = 0\np\u2082 : Polynomial R\nhp\u2082Monic : p\u2082.Monic\nhp\u2082Eval : (aeval x.2) p\u2082 = 0\n\u22a2 (0 * (aeval x.1) p\u2082, (aeval x.2) (p\u2081 * p\u2082)) = 0"}, {"line": "rw [zero_mul]", "tactic_state": "case intro.intro.intro.intro\nR : Type u_11\nA : Type u_12\nB : Type u_13\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx : A \u00d7 B\np\u2081 : Polynomial R\nhp\u2081Monic : p\u2081.Monic\nhp\u2081Eval : (aeval x.1) p\u2081 = 0\np\u2082 : Polynomial R\nhp\u2082Monic : p\u2082.Monic\nhp\u2082Eval : (aeval x.2) p\u2082 = 0\n\u22a2 (0, (aeval x.2) (p\u2081 * p\u2082)) = 0"}, {"line": "rw [aeval_mul]", "tactic_state": "case intro.intro.intro.intro\nR : Type u_11\nA : Type u_12\nB : Type u_13\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx : A \u00d7 B\np\u2081 : Polynomial R\nhp\u2081Monic : p\u2081.Monic\nhp\u2081Eval : (aeval x.1) p\u2081 = 0\np\u2082 : Polynomial R\nhp\u2082Monic : p\u2082.Monic\nhp\u2082Eval : (aeval x.2) p\u2082 = 0\n\u22a2 (0, (aeval x.2) p\u2081 * (aeval x.2) p\u2082) = 0"}, {"line": "rw [hp\u2082Eval]", "tactic_state": "case intro.intro.intro.intro\nR : Type u_11\nA : Type u_12\nB : Type u_13\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx : A \u00d7 B\np\u2081 : Polynomial R\nhp\u2081Monic : p\u2081.Monic\nhp\u2081Eval : (aeval x.1) p\u2081 = 0\np\u2082 : Polynomial R\nhp\u2082Monic : p\u2082.Monic\nhp\u2082Eval : (aeval x.2) p\u2082 = 0\n\u22a2 (0, (aeval x.2) p\u2081 * 0) = 0"}, {"line": "rw [mul_zero]", "tactic_state": "case intro.intro.intro.intro\nR : Type u_11\nA : Type u_12\nB : Type u_13\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx : A \u00d7 B\np\u2081 : Polynomial R\nhp\u2081Monic : p\u2081.Monic\nhp\u2081Eval : (aeval x.1) p\u2081 = 0\np\u2082 : Polynomial R\nhp\u2082Monic : p\u2082.Monic\nhp\u2082Eval : (aeval x.2) p\u2082 = 0\n\u22a2 (0, 0) = 0"}, {"line": "rw [Prod.zero_eq_mk]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Algebra.isIntegral_sup {S T : Subalgebra R A} :\n    Algebra.IsIntegral R (S \u2294 T : Subalgebra R A) \u2194\n      Algebra.IsIntegral R S \u2227 Algebra.IsIntegral R T := by\n  simp_rw [\u2190 le_integralClosure_iff_isIntegral, sup_le_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IntegralClosure/IsIntegralClosure/Basic.lean", "context": {"open": ["Polynomial Submodule", "Algebra"], "variables": ["{R S : Type*}", "[Field R] [DivisionRing S] [Algebra R S] {x : S} {A : Subalgebra R S}", "{R A B S : Type*}", "[CommRing R] [CommRing A] [Ring B] [CommRing S]", "[Algebra R A] [Algebra R B] {f : R \u2192+* S}", "(f : R \u2192+* S) (R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nA : Type u_4\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nS T : Subalgebra R A\n\u22a2 Algebra.IsIntegral R \u21a5(S \u2294 T) \u2194 Algebra.IsIntegral R \u21a5S \u2227 Algebra.IsIntegral R \u21a5T"}, {"line": "simp_rw [\u2190 le_integralClosure_iff_isIntegral, sup_le_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Algebra.isIntegral_iSup {\u03b9} (S : \u03b9 \u2192 Subalgebra R A) :\n    Algebra.IsIntegral R \u2191(iSup S) \u2194 \u2200 i, Algebra.IsIntegral R (S i) := by\n  simp_rw [\u2190 le_integralClosure_iff_isIntegral, iSup_le_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IntegralClosure/IsIntegralClosure/Basic.lean", "context": {"open": ["Polynomial Submodule", "Algebra"], "variables": ["{R S : Type*}", "[Field R] [DivisionRing S] [Algebra R S] {x : S} {A : Subalgebra R S}", "{R A B S : Type*}", "[CommRing R] [CommRing A] [Ring B] [CommRing S]", "[Algebra R A] [Algebra R B] {f : R \u2192+* S}", "(f : R \u2192+* S) (R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nA : Type u_4\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\n\u03b9 : Sort u_7\nS : \u03b9 \u2192 Subalgebra R A\n\u22a2 Algebra.IsIntegral R \u21a5(iSup S) \u2194 \u2200 (i : \u03b9), Algebra.IsIntegral R \u21a5(S i)"}, {"line": "simp_rw [\u2190 le_integralClosure_iff_isIntegral, iSup_le_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsIntegral.det {n : Type*} [Fintype n] [DecidableEq n] {M : Matrix n n A}\n    (h : \u2200 i j, IsIntegral R (M i j)) : IsIntegral R M.det := by\n  rw [Matrix.det_apply]\n  exact IsIntegral.sum _ fun \u03c3 _h\u03c3 \u21a6 (IsIntegral.prod _ fun i _hi => h _ _).zsmul _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IntegralClosure/IsIntegralClosure/Basic.lean", "context": {"open": ["Polynomial Submodule", "Algebra"], "variables": ["{R S : Type*}", "[Field R] [DivisionRing S] [Algebra R S] {x : S} {A : Subalgebra R S}", "{R A B S : Type*}", "[CommRing R] [CommRing A] [Ring B] [CommRing S]", "[Algebra R A] [Algebra R B] {f : R \u2192+* S}", "(f : R \u2192+* S) (R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nA : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Algebra R A\nn : Type u_7\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nM : Matrix n n A\nh : \u2200 (i j : n), IsIntegral R (M i j)\n\u22a2 IsIntegral R M.det"}, {"line": "rw [Matrix.det_apply]", "tactic_state": "R : Type u_3\nA : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Algebra R A\nn : Type u_7\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nM : Matrix n n A\nh : \u2200 (i j : n), IsIntegral R (M i j)\n\u22a2 IsIntegral R (\u2211 \u03c3, Equiv.Perm.sign \u03c3 \u2022 \u220f i, M (\u03c3 i) i)"}, {"line": "exact IsIntegral.sum _ fun \u03c3 _h\u03c3 \u21a6 (IsIntegral.prod _ fun i _hi => h _ _).zsmul _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isIntegral_leadingCoeff_smul [Algebra R S] (h : aeval x p = 0) :\n    IsIntegral R (p.leadingCoeff \u2022 x) := by\n  rw [aeval_def] at h\n  rw [Algebra.smul_def]\n  exact (algebraMap R S).isIntegralElem_leadingCoeff_mul p x h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/IntegralClosure/IsIntegralClosure/Basic.lean", "context": {"open": ["Polynomial Submodule", "Algebra", "TensorProduct"], "variables": ["{R S : Type*}", "[Field R] [DivisionRing S] [Algebra R S] {x : S} {A : Subalgebra R S}", "{R A B S : Type*}", "[CommRing R] [CommRing A] [Ring B] [CommRing S]", "[Algebra R A] [Algebra R B] {f : R \u2192+* S}", "(f : R \u2192+* S) (R A)", "{R A}", "(p : R[X]) (x : S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nS : Type u_6\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\np : Polynomial R\nx : S\ninst\u271d : Algebra R S\nh : (aeval x) p = 0\n\u22a2 IsIntegral R (p.leadingCoeff \u2022 x)"}, {"line": "rw [aeval_def] at h", "tactic_state": "R : Type u_3\nS : Type u_6\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\np : Polynomial R\nx : S\ninst\u271d : Algebra R S\nh : eval\u2082 (algebraMap R S) x p = 0\n\u22a2 IsIntegral R (p.leadingCoeff \u2022 x)"}, {"line": "rw [Algebra.smul_def]", "tactic_state": "R : Type u_3\nS : Type u_6\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\np : Polynomial R\nx : S\ninst\u271d : Algebra R S\nh : eval\u2082 (algebraMap R S) x p = 0\n\u22a2 IsIntegral R ((algebraMap R S) p.leadingCoeff * x)"}, {"line": "exact (algebraMap R S).isIntegralElem_leadingCoeff_mul p x h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_jacobson_iff {x : R} {I : TwoSidedIdeal R} :\n    x \u2208 jacobson I \u2194 \u2200 y, \u2203 z, z * y * x + z - 1 \u2208 I := by\n  simp [jacobson, Ideal.mem_jacobson_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Jacobson/Ideal.lean", "context": {"open": [], "variables": ["{R : Type u} {S : Type v}", "[Ring R] [Ring S] {I : Ideal R}", "[CommRing R] [CommRing S] {I : Ideal R}", "[CommRing R]", "{R : Type u} [Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Ring R\nx\u271d : Sort u_1\njacobson : x\u271d\nx : R\nI : TwoSidedIdeal R\n\u22a2 x \u2208 sorry \u2194 \u2200 (y : R), \u2203 z, z * y * x + z - 1 \u2208 I"}, {"line": "simp [jacobson, Ideal.mem_jacobson_iff]", "tactic_state": "R : Type u\ninst\u271d : Ring R\nx\u271d : Sort u_1\njacobson : x\u271d\nx : R\nI : TwoSidedIdeal R\n\u22a2 x \u2208 sorry () \u2194 \u2200 (y : R), \u2203 z, z * y * x + z - 1 \u2208 I"}]}
{"declaration": "theorem FG.jacobson_smul_lt {N : Submodule R M} (ne_bot : N \u2260 \u22a5) (fg : N.FG) :\n    Ring.jacobson R \u2022 N < N := by\n  rw [\u2190 Module.Finite.iff_fg] at fg\n  rw [\u2190 nontrivial_iff_ne_bot] at ne_bot\n  convert map_strictMono_of_injective N.injective_subtype (jacobson_smul_lt_top \u22a4)\n  on_goal 1 => rw [map_smul'']\n  all_goals rw [Submodule.map_top, range_subtype]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Jacobson/Radical.lean", "context": {"open": ["Submodule"], "variables": ["(R R\u2082 M M\u2082 : Type*) [Ring R] [Ring R\u2082]", "[AddCommGroup M] [Module R M] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} [RingHomSurjective \u03c4\u2081\u2082]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082] (f : F)", "{R R\u2082 M M\u2082}", "{f}", "(R M)", "{\u03b9} (M : \u03b9 \u2192 Type*) [\u2200 i, AddCommGroup (M i)] [\u2200 i, Module R (M i)]", "(R R\u2082 : Type*) [Ring R] [Ring R\u2082] (f : R \u2192+* R\u2082) [RingHomSurjective f]", "(M : Type*) [AddCommGroup M] [Module R M]", "{R R\u2082}", "{f} in", "(R)", "{R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_7\ninst\u271d\u00b2 : Ring R\nM : Type u_9\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nN : Submodule R M\nne_bot : N \u2260 \u22a5\nfg : N.FG\n\u22a2 Ring.jacobson R \u2022 N < N"}, {"line": "rw [\u2190 Module.Finite.iff_fg] at fg", "tactic_state": "R : Type u_7\ninst\u271d\u00b2 : Ring R\nM : Type u_9\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nN : Submodule R M\nne_bot : N \u2260 \u22a5\nfg : Module.Finite R \u21a5N\n\u22a2 Ring.jacobson R \u2022 N < N"}, {"line": "rw [\u2190 nontrivial_iff_ne_bot] at ne_bot", "tactic_state": "R : Type u_7\ninst\u271d\u00b2 : Ring R\nM : Type u_9\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nN : Submodule R M\nne_bot : Nontrivial \u21a5N\nfg : Module.Finite R \u21a5N\n\u22a2 Ring.jacobson R \u2022 N < N"}, {"line": "convert map_strictMono_of_injective N.injective_subtype (jacobson_smul_lt_top \u22a4)", "tactic_state": "case h.e'_3\nR : Type u_7\ninst\u271d\u00b2 : Ring R\nM : Type u_9\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nN : Submodule R M\nne_bot : Nontrivial \u21a5N\nfg : Module.Finite R \u21a5N\n\u22a2 Ring.jacobson R \u2022 N = map N.subtype (Ring.jacobson R \u2022 \u22a4)\n---\ncase h.e'_4\nR : Type u_7\ninst\u271d\u00b2 : Ring R\nM : Type u_9\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nN : Submodule R M\nne_bot : Nontrivial \u21a5N\nfg : Module.Finite R \u21a5N\n\u22a2 N = map N.subtype \u22a4"}, {"line": "on_goal 1 => rw [map_smul'']", "tactic_state": "case h.e'_3\nR : Type u_7\ninst\u271d\u00b2 : Ring R\nM : Type u_9\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nN : Submodule R M\nne_bot : Nontrivial \u21a5N\nfg : Module.Finite R \u21a5N\n\u22a2 Ring.jacobson R \u2022 N = Ring.jacobson R \u2022 map N.subtype \u22a4\n---\ncase h.e'_4\nR : Type u_7\ninst\u271d\u00b2 : Ring R\nM : Type u_9\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nN : Submodule R M\nne_bot : Nontrivial \u21a5N\nfg : Module.Finite R \u21a5N\n\u22a2 N = map N.subtype \u22a4"}, {"line": "all_goals rw [Submodule.map_top, range_subtype]", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem quotient_mk_comp_C_isIntegral_of_isJacobsonRing'\n    {R : Type*} [CommRing R] [IsJacobsonRing R]\n    (P : Ideal (MvPolynomial (Fin n) R)) (hP : P.IsMaximal) :\n    RingHom.IsIntegral (algebraMap R (MvPolynomial (Fin n) R \u29f8 P)) := by\n  induction' n with n IH\n  \u00b7 apply RingHom.isIntegral_of_surjective\n    apply Function.Surjective.comp Quotient.mk_surjective\n    exact C_surjective (Fin 0)\n  \u00b7 apply aux_IH IH (finSuccEquiv R n).symm P hP\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Jacobson/Ring.lean", "context": {"open": ["Polynomial", "Ideal", "IsLocalization Submonoid", "MvPolynomial RingHom"], "variables": ["{R S : Type*} [CommRing R] [CommRing S] {I : Ideal R}", "{R S : Type*} [CommRing R] [CommRing S]", "(y : R) [Algebra R S] [IsLocalization.Away y S]", "(S) in", "{R S : Type*} [CommRing R] [CommRing S] [IsDomain S]", "{R\u2098 S\u2098 : Type*} [CommRing R\u2098] [CommRing S\u2098]", "{R : Type*} [CommRing R]", "(P : Ideal R[X]) [hP : P.IsMaximal]", "[IsJacobsonRing R]", "{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nR : Type u_8\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsJacobsonRing R\nP : Ideal (MvPolynomial (Fin n) R)\nhP : P.IsMaximal\n\u22a2 (algebraMap R (MvPolynomial (Fin n) R \u29f8 P)).IsIntegral"}, {"line": "induction' n with n IH", "tactic_state": "case zero\nn : \u2115\nR : Type u_8\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsJacobsonRing R\nP : Ideal (MvPolynomial (Fin 0) R)\nhP : P.IsMaximal\n\u22a2 (algebraMap R (MvPolynomial (Fin 0) R \u29f8 P)).IsIntegral\n---\ncase succ\nn\u271d : \u2115\nR : Type u_8\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsJacobsonRing R\nn : \u2115\nIH : \u2200 (P : Ideal (MvPolynomial (Fin n) R)), P.IsMaximal \u2192 (algebraMap R (MvPolynomial (Fin n) R \u29f8 P)).IsIntegral\nP : Ideal (MvPolynomial (Fin (n + 1)) R)\nhP : P.IsMaximal\n\u22a2 (algebraMap R (MvPolynomial (Fin (n + 1)) R \u29f8 P)).IsIntegral"}, {"line": "\u00b7 apply RingHom.isIntegral_of_surjective\n    apply Function.Surjective.comp Quotient.mk_surjective\n    exact C_surjective (Fin 0)", "tactic_state": "case succ\nn\u271d : \u2115\nR : Type u_8\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsJacobsonRing R\nn : \u2115\nIH : \u2200 (P : Ideal (MvPolynomial (Fin n) R)), P.IsMaximal \u2192 (algebraMap R (MvPolynomial (Fin n) R \u29f8 P)).IsIntegral\nP : Ideal (MvPolynomial (Fin (n + 1)) R)\nhP : P.IsMaximal\n\u22a2 (algebraMap R (MvPolynomial (Fin (n + 1)) R \u29f8 P)).IsIntegral"}, {"line": "\u00b7 apply aux_IH IH (finSuccEquiv R n).symm P hP", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isJacobsonRing_of_finiteType {A B : Type*} [CommRing A] [CommRing B]\n    [Algebra A B] [IsJacobsonRing A] [Algebra.FiniteType A B] : IsJacobsonRing B := by\n  obtain \u27e8\u03b9, h\u03b9, f, hf\u27e9 := Algebra.FiniteType.iff_quotient_mvPolynomial'.mp \u2039_\u203a\n  exact isJacobsonRing_of_surjective \u27e8f.toRingHom, hf\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Jacobson/Ring.lean", "context": {"open": ["Polynomial", "Ideal", "IsLocalization Submonoid", "MvPolynomial RingHom"], "variables": ["{R S : Type*} [CommRing R] [CommRing S] {I : Ideal R}", "{R S : Type*} [CommRing R] [CommRing S]", "(y : R) [Algebra R S] [IsLocalization.Away y S]", "(S) in", "{R S : Type*} [CommRing R] [CommRing S] [IsDomain S]", "{R\u2098 S\u2098 : Type*} [CommRing R\u2098] [CommRing S\u2098]", "{R : Type*} [CommRing R]", "(P : Ideal R[X]) [hP : P.IsMaximal]", "[IsJacobsonRing R]", "{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_8\nB : Type u_9\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : IsJacobsonRing A\ninst\u271d : Algebra.FiniteType A B\n\u22a2 IsJacobsonRing B"}, {"line": "obtain \u27e8\u03b9, h\u03b9, f, hf\u27e9 := Algebra.FiniteType.iff_quotient_mvPolynomial'.mp \u2039_\u203a", "tactic_state": "case intro.intro.intro\nA : Type u_8\nB : Type u_9\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : IsJacobsonRing A\ninst\u271d : Algebra.FiniteType A B\n\u03b9 : Type u_9\nh\u03b9 : Fintype \u03b9\nf : MvPolynomial \u03b9 A \u2192\u2090[A] B\nhf : Function.Surjective \u21d1f\n\u22a2 IsJacobsonRing B"}, {"line": "exact isJacobsonRing_of_surjective \u27e8f.toRingHom, hf\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem KaehlerDifferential.one_smul_sub_smul_one_mem_ideal (a : S) :\n    (1 : S) \u2297\u209c[R] a - a \u2297\u209c[R] (1 : S) \u2208 KaehlerDifferential.ideal R S := by simp [RingHom.mem_ker]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Kaehler/Basic.lean", "context": {"open": ["scoped TensorProduct", "Algebra Finsupp"], "variables": ["(R : Type u) (S : Type v) [CommRing R] [CommRing S] [Algebra R S]", "{S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\na : S\n\u22a2 1 \u2297\u209c[R] a - a \u2297\u209c[R] 1 \u2208 ideal R S"}, {"line": "simp [RingHom.mem_ker]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\na : S\n\u22a2 (TensorProduct.lmul' R) (1 \u2297\u209c[R] a - a \u2297\u209c[R] 1) = 0"}]}
{"declaration": "theorem KaehlerDifferential.D_tensorProductTo (x : KaehlerDifferential.ideal R S) :\n    (KaehlerDifferential.D R S).tensorProductTo x =\n      (KaehlerDifferential.ideal R S).toCotangent x := by\n  rw [\u2190 Derivation.liftKaehlerDifferential_apply]\n  rw [Derivation.liftKaehlerDifferential_D]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Kaehler/Basic.lean", "context": {"open": ["scoped TensorProduct", "Algebra Finsupp"], "variables": ["(R : Type u) (S : Type v) [CommRing R] [CommRing S] [Algebra R S]", "{S}", "{R}", "{M : Type*} [AddCommGroup M] [Module R M] [Module S M] [IsScalarTower R S M]", "(R S)", "{R S}", "(R S)", "{R S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : \u21a5(ideal R S)\n\u22a2 (D R S).tensorProductTo \u2191x = (ideal R S).toCotangent x"}, {"line": "rw [\u2190 Derivation.liftKaehlerDifferential_apply]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : \u21a5(ideal R S)\n\u22a2 (D R S).liftKaehlerDifferential ((ideal R S).toCotangent x) = (ideal R S).toCotangent x"}, {"line": "rw [Derivation.liftKaehlerDifferential_D]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : \u21a5(ideal R S)\n\u22a2 LinearMap.id ((ideal R S).toCotangent x) = (ideal R S).toCotangent x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem KaehlerDifferential.linearCombination_surjective :\n    Function.Surjective (Finsupp.linearCombination S (KaehlerDifferential.D R S)) := by\n  rw [\u2190 LinearMap.range_eq_top]\n  rw [range_linearCombination]\n  rw [span_range_derivation]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Kaehler/Basic.lean", "context": {"open": ["scoped TensorProduct", "Algebra Finsupp", "KaehlerDifferential (D)", "Finsupp (single)"], "variables": ["(R : Type u) (S : Type v) [CommRing R] [CommRing S] [Algebra R S]", "{S}", "{R}", "{M : Type*} [AddCommGroup M] [Module R M] [Module S M] [IsScalarTower R S M]", "(R S)", "{R S}", "(R S)", "{R S}", "(R S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\n\u22a2 Function.Surjective \u21d1(linearCombination S \u21d1(D R S))"}, {"line": "rw [\u2190 LinearMap.range_eq_top]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\n\u22a2 LinearMap.range (linearCombination S \u21d1(D R S)) = \u22a4"}, {"line": "rw [range_linearCombination]", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\n\u22a2 Submodule.span S (Set.range \u21d1(D R S)) = \u22a4"}, {"line": "rw [span_range_derivation]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma KaehlerDifferential.mapBaseChange_surjective\n    (h : Function.Surjective (algebraMap A B)) :\n    Function.Surjective (KaehlerDifferential.mapBaseChange R A B) := by\n  have := subsingleton_of_surjective A B h\n  rw [\u2190 LinearMap.range_eq_top]\n  rw [range_mapBaseChange]\n  rw [\u2190 top_le_iff]\n  exact fun x _ \u21a6 Subsingleton.elim _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Kaehler/Basic.lean", "context": {"open": ["scoped TensorProduct", "Algebra Finsupp", "KaehlerDifferential (D)", "Finsupp (single)", "IsScalarTower (toAlgHom)"], "variables": ["(R : Type u) (S : Type v) [CommRing R] [CommRing S] [Algebra R S]", "{S}", "{R}", "{M : Type*} [AddCommGroup M] [Module R M] [Module S M] [IsScalarTower R S M]", "(R S)", "{R S}", "(R S)", "{R S}", "(R S)", "(A B : Type*) [CommRing A] [CommRing B] [Algebra R A]", "[Algebra A B] [Algebra S B]", "[Algebra R B] [IsScalarTower R A B] [IsScalarTower R S B] [SMulCommClass S A B]", "[Algebra R B] [IsScalarTower R A B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2078 : CommRing R\nA : Type u_2\nB : Type u_3\ninst\u271d\u2077 : CommRing A\ninst\u271d\u2076 : CommRing B\ninst\u271d\u2075 : Algebra R A\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Algebra R B\ninst\u271d\u00b2 : IsScalarTower R A B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsScalarTower R A B\nh : Function.Surjective \u21d1(algebraMap A B)\n\u22a2 Function.Surjective \u21d1(mapBaseChange R A B)"}, {"line": "have := subsingleton_of_surjective A B h", "tactic_state": "R : Type u\ninst\u271d\u2078 : CommRing R\nA : Type u_2\nB : Type u_3\ninst\u271d\u2077 : CommRing A\ninst\u271d\u2076 : CommRing B\ninst\u271d\u2075 : Algebra R A\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Algebra R B\ninst\u271d\u00b2 : IsScalarTower R A B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsScalarTower R A B\nh : Function.Surjective \u21d1(algebraMap A B)\nthis : Subsingleton (\u03a9[B\u2044A])\n\u22a2 Function.Surjective \u21d1(mapBaseChange R A B)"}, {"line": "rw [\u2190 LinearMap.range_eq_top]", "tactic_state": "R : Type u\ninst\u271d\u2078 : CommRing R\nA : Type u_2\nB : Type u_3\ninst\u271d\u2077 : CommRing A\ninst\u271d\u2076 : CommRing B\ninst\u271d\u2075 : Algebra R A\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Algebra R B\ninst\u271d\u00b2 : IsScalarTower R A B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsScalarTower R A B\nh : Function.Surjective \u21d1(algebraMap A B)\nthis : Subsingleton (\u03a9[B\u2044A])\n\u22a2 LinearMap.range (mapBaseChange R A B) = \u22a4"}, {"line": "rw [range_mapBaseChange]", "tactic_state": "R : Type u\ninst\u271d\u2078 : CommRing R\nA : Type u_2\nB : Type u_3\ninst\u271d\u2077 : CommRing A\ninst\u271d\u2076 : CommRing B\ninst\u271d\u2075 : Algebra R A\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Algebra R B\ninst\u271d\u00b2 : IsScalarTower R A B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsScalarTower R A B\nh : Function.Surjective \u21d1(algebraMap A B)\nthis : Subsingleton (\u03a9[B\u2044A])\n\u22a2 LinearMap.ker (map R A B B) = \u22a4"}, {"line": "rw [\u2190 top_le_iff]", "tactic_state": "R : Type u\ninst\u271d\u2078 : CommRing R\nA : Type u_2\nB : Type u_3\ninst\u271d\u2077 : CommRing A\ninst\u271d\u2076 : CommRing B\ninst\u271d\u2075 : Algebra R A\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Algebra R B\ninst\u271d\u00b2 : IsScalarTower R A B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsScalarTower R A B\nh : Function.Surjective \u21d1(algebraMap A B)\nthis : Subsingleton (\u03a9[B\u2044A])\n\u22a2 \u22a4 \u2264 LinearMap.ker (map R A B B)"}, {"line": "exact fun x _ \u21a6 Subsingleton.elim _ _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cotangentSpaceBasis_apply (i) :\n    P.cotangentSpaceBasis i = ((1 : S) \u2297\u209c[P.Ring] D R P.Ring (.X i) :) := by\n  simp [cotangentSpaceBasis, toExtension]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Kaehler/CotangentComplex.lean", "context": {"open": ["KaehlerDifferential TensorProduct MvPolynomial"], "variables": ["{R : Type u} {S : Type v} [CommRing R] [CommRing S] [Algebra R S]", "(P : Extension.{w} R S)", "{R' : Type u'} {S' : Type v'} [CommRing R'] [CommRing S'] [Algebra R' S']", "(P' : Extension.{w'} R' S')", "[Algebra R R'] [Algebra S S'] [Algebra R S'] [IsScalarTower R R' S']", "{P P'}", "{R'' : Type u''} {S'' : Type v''} [CommRing R''] [CommRing S''] [Algebra R'' S'']", "{P'' : Extension.{w''} R'' S''}", "[Algebra R R''] [Algebra S S''] [Algebra R S'']", "[Algebra R' R''] [Algebra S' S''] [Algebra R' S'']", "[IsScalarTower R R' R''] [IsScalarTower S S' S'']", "[IsScalarTower R S S'] in", "[IsScalarTower R S S']", "(P) in", "(P) in", "{P : Extension R S}", "(P : Generators.{w} R S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Extension : ?m.27392\nGenerators : ?m.29769\nR : Type u\nS : Type v\ninst\u271d\u00b2\u2070 : CommRing R\ninst\u271d\u00b9\u2079 : CommRing S\ninst\u271d\u00b9\u2078 : Algebra R S\nP\u271d : sorry\nR' : Type u'\nS' : Type v'\ninst\u271d\u00b9\u2077 : CommRing R'\ninst\u271d\u00b9\u2076 : CommRing S'\ninst\u271d\u00b9\u2075 : Algebra R' S'\nP' : sorry\ninst\u271d\u00b9\u2074 : Algebra R R'\ninst\u271d\u00b9\u00b3 : Algebra S S'\ninst\u271d\u00b9\u00b2 : Algebra R S'\ninst\u271d\u00b9\u00b9 : IsScalarTower R R' S'\nR'' : Type u''\nS'' : Type v''\ninst\u271d\u00b9\u2070 : CommRing R''\ninst\u271d\u2079 : CommRing S''\ninst\u271d\u2078 : Algebra R'' S''\nP'' : sorry\ninst\u271d\u2077 : Algebra R R''\ninst\u271d\u2076 : Algebra S S''\ninst\u271d\u2075 : Algebra R S''\ninst\u271d\u2074 : Algebra R' R''\ninst\u271d\u00b3 : Algebra S' S''\ninst\u271d\u00b2 : Algebra R' S''\ninst\u271d\u00b9 : IsScalarTower R R' R''\ninst\u271d : IsScalarTower S S' S''\nP : sorry\ni : ?m.31946\n\u22a2 sorry = sorry"}, {"line": "simp [cotangentSpaceBasis, toExtension]", "tactic_state": "Extension : ?m.27392\nGenerators : ?m.29769\nR : Type u\nS : Type v\ninst\u271d\u00b2\u2070 : CommRing R\ninst\u271d\u00b9\u2079 : CommRing S\ninst\u271d\u00b9\u2078 : Algebra R S\nP\u271d : sorry\nR' : Type u'\nS' : Type v'\ninst\u271d\u00b9\u2077 : CommRing R'\ninst\u271d\u00b9\u2076 : CommRing S'\ninst\u271d\u00b9\u2075 : Algebra R' S'\nP' : sorry\ninst\u271d\u00b9\u2074 : Algebra R R'\ninst\u271d\u00b9\u00b3 : Algebra S S'\ninst\u271d\u00b9\u00b2 : Algebra R S'\ninst\u271d\u00b9\u00b9 : IsScalarTower R R' S'\nR'' : Type u''\nS'' : Type v''\ninst\u271d\u00b9\u2070 : CommRing R''\ninst\u271d\u2079 : CommRing S''\ninst\u271d\u2078 : Algebra R'' S''\nP'' : sorry\ninst\u271d\u2077 : Algebra R R''\ninst\u271d\u2076 : Algebra S S''\ninst\u271d\u2075 : Algebra R S''\ninst\u271d\u2074 : Algebra R' R''\ninst\u271d\u00b3 : Algebra S' S''\ninst\u271d\u00b2 : Algebra R' S''\ninst\u271d\u00b9 : IsScalarTower R R' R''\ninst\u271d : IsScalarTower S S' S''\nP : sorry\ni : ?m.31946\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma KaehlerDifferential.mvPolynomialBasis_repr_D_X (\u03c3) (i) :\n    (mvPolynomialBasis R \u03c3).repr (D _ _ (.X i)) = Finsupp.single i 1 := by\n  simp [mvPolynomialBasis_repr_D]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Kaehler/Polynomial.lean", "context": {"open": ["scoped TensorProduct", "Algebra"], "variables": ["(R : Type u) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\n\u03c3 : Type u_1\ni : \u03c3\n\u22a2 (mvPolynomialBasis R \u03c3).repr ((D R (MvPolynomial \u03c3 R)) (MvPolynomial.X i)) = fun\u2080 | i => 1"}, {"line": "simp [mvPolynomialBasis_repr_D]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Ring.KrullDimLE.mk\u2080 (H : \u2200 I : Ideal R, I.IsPrime \u2192 I.IsMaximal) : Ring.KrullDimLE 0 R := by\n  rwa [Ring.krullDimLE_zero_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/KrullDimension/Basic.lean", "context": {"open": ["Order"], "variables": ["{R S : Type*} [CommSemiring R] [CommSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\nH : \u2200 (I : _root_.Ideal R), I.IsPrime \u2192 I.IsMaximal\n\u22a2 KrullDimLE 0 R"}, {"line": "rwa [Ring.krullDimLE_zero_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Ring.KrullDimLE.mk\u2081 (H : \u2200 I : Ideal R, I.IsPrime \u2192 I \u2208 minimalPrimes R \u2228 I.IsMaximal) :\n    Ring.KrullDimLE 1 R := by\n  rwa [Ring.krullDimLE_one_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/KrullDimension/Basic.lean", "context": {"open": ["Order"], "variables": ["{R S : Type*} [CommSemiring R] [CommSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\nH : \u2200 (I : _root_.Ideal R), I.IsPrime \u2192 I \u2208 minimalPrimes R \u2228 I.IsMaximal\n\u22a2 KrullDimLE 1 R"}, {"line": "rwa [Ring.krullDimLE_one_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Ring.krullDimLE_one_iff_of_noZeroDivisors [NoZeroDivisors R] :\n    Ring.KrullDimLE 1 R \u2194 \u2200 I : Ideal R, I \u2260 \u22a5 \u2192 I.IsPrime \u2192 I.IsMaximal := by\n  cases subsingleton_or_nontrivial R\n  \u00b7 exact iff_of_true inferInstance fun I h \u21a6 (h <| Subsingleton.elim ..).elim\n  have := Ideal.bot_prime (\u03b1 := R)\n  exact Ring.krullDimLE_one_iff_of_isPrime_bot\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/KrullDimension/Basic.lean", "context": {"open": ["Order"], "variables": ["{R S : Type*} [CommSemiring R] [CommSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : NoZeroDivisors R\n\u22a2 KrullDimLE 1 R \u2194 \u2200 (I : _root_.Ideal R), I \u2260 \u22a5 \u2192 I.IsPrime \u2192 I.IsMaximal"}, {"line": "cases subsingleton_or_nontrivial R", "tactic_state": "case inl\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : NoZeroDivisors R\nh\u271d : Subsingleton R\n\u22a2 KrullDimLE 1 R \u2194 \u2200 (I : _root_.Ideal R), I \u2260 \u22a5 \u2192 I.IsPrime \u2192 I.IsMaximal\n---\ncase inr\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : NoZeroDivisors R\nh\u271d : Nontrivial R\n\u22a2 KrullDimLE 1 R \u2194 \u2200 (I : _root_.Ideal R), I \u2260 \u22a5 \u2192 I.IsPrime \u2192 I.IsMaximal"}, {"line": "\u00b7 exact iff_of_true inferInstance fun I h \u21a6 (h <| Subsingleton.elim ..).elim", "tactic_state": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : NoZeroDivisors R\nh\u271d : Nontrivial R\n\u22a2 KrullDimLE 1 R \u2194 \u2200 (I : _root_.Ideal R), I \u2260 \u22a5 \u2192 I.IsPrime \u2192 I.IsMaximal"}, {"line": "have := Ideal.bot_prime (\u03b1 := R)", "tactic_state": "case inr.refine_2\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : NoZeroDivisors R\nh\u271d : Nontrivial R\nthis : \u22a5.IsPrime\n\u22a2 KrullDimLE 1 R \u2194 \u2200 (I : _root_.Ideal R), I \u2260 \u22a5 \u2192 I.IsPrime \u2192 I.IsMaximal\n---\ncase inr.refine_1\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : NoZeroDivisors R\nh\u271d : Nontrivial R\n\u22a2 Semiring R"}, {"line": "exact Ring.krullDimLE_one_iff_of_isPrime_bot", "tactic_state": "case inr.refine_1\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : NoZeroDivisors R\nh\u271d : Nontrivial R\n\u22a2 Semiring R"}]}
{"declaration": "lemma Ring.KrullDimLE.mk\u2081' (H : \u2200 I : Ideal R, I \u2260 \u22a5 \u2192 I.IsPrime \u2192 I.IsMaximal) :\n    Ring.KrullDimLE 1 R := by\n  by_cases hR : (\u22a5 : Ideal R).IsPrime\n  \u00b7 rwa [Ring.krullDimLE_one_iff_of_isPrime_bot]\n  suffices Ring.KrullDimLE 0 R from inferInstance\n  exact .mk\u2080 fun I hI \u21a6 H I (fun e \u21a6 hR (e \u25b8 hI)) hI\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/KrullDimension/Basic.lean", "context": {"open": ["Order"], "variables": ["{R S : Type*} [CommSemiring R] [CommSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\nH : \u2200 (I : _root_.Ideal R), I \u2260 \u22a5 \u2192 I.IsPrime \u2192 I.IsMaximal\n\u22a2 KrullDimLE 1 R"}, {"line": "by_cases hR : (\u22a5 : Ideal R).IsPrime", "tactic_state": "case pos\nR : Type u_1\ninst\u271d : CommSemiring R\nH : \u2200 (I : _root_.Ideal R), I \u2260 \u22a5 \u2192 I.IsPrime \u2192 I.IsMaximal\nhR : sorry\n\u22a2 KrullDimLE 1 R\n---\ncase neg\nR : Type u_1\ninst\u271d : CommSemiring R\nH : \u2200 (I : _root_.Ideal R), I \u2260 \u22a5 \u2192 I.IsPrime \u2192 I.IsMaximal\nhR : \u00acsorry\n\u22a2 KrullDimLE 1 R"}, {"line": "\u00b7 rwa [Ring.krullDimLE_one_iff_of_isPrime_bot]", "tactic_state": "case neg\nR : Type u_1\ninst\u271d : CommSemiring R\nH : \u2200 (I : _root_.Ideal R), I \u2260 \u22a5 \u2192 I.IsPrime \u2192 I.IsMaximal\nhR : \u00acsorry\n\u22a2 KrullDimLE 1 R"}, {"line": "suffices Ring.KrullDimLE 0 R from inferInstance", "tactic_state": "case neg\nR : Type u_1\ninst\u271d : CommSemiring R\nH : \u2200 (I : _root_.Ideal R), I \u2260 \u22a5 \u2192 I.IsPrime \u2192 I.IsMaximal\nhR : \u00acsorry\n\u22a2 sorry"}, {"line": "exact .mk\u2080 fun I hI \u21a6 H I (fun e \u21a6 hR (e \u25b8 hI)) hI", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ringKrullDim_succ_le_of_surjective (f : R \u2192+* S) (hf : Function.Surjective f)\n    {r : R} (hr : r \u2208 R\u2070) (hr' : f r = 0) : ringKrullDim S + 1 \u2264 ringKrullDim R := by\n  refine le_trans ?_ (ringKrullDim_quotient_succ_le_of_nonZeroDivisor hr)\n  gcongr\n  exact ringKrullDim_le_of_surjective (Ideal.Quotient.lift _ f (RingHom.ker f\n    |>.span_singleton_le_iff_mem.mpr hr')) (Ideal.Quotient.lift_surjective_of_surjective _ _ hf)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/KrullDimension/NonZeroDivisors.lean", "context": {"open": ["nonZeroDivisors"], "variables": ["{R S : Type*} [CommRing R] [CommRing S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nf : R \u2192+* S\nhf : Function.Surjective \u21d1f\nr : R\nhr : r \u2208 nonZeroDivisors R\nhr' : f r = 0\n\u22a2 ringKrullDim S + 1 \u2264 ringKrullDim R"}, {"line": "refine le_trans ?_ (ringKrullDim_quotient_succ_le_of_nonZeroDivisor hr)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nf : R \u2192+* S\nhf : Function.Surjective \u21d1f\nr : R\nhr : r \u2208 nonZeroDivisors R\nhr' : f r = 0\n\u22a2 ringKrullDim S + 1 \u2264 ringKrullDim (R \u29f8 Ideal.span {r}) + 1"}, {"line": "gcongr", "tactic_state": "case bc\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nf : R \u2192+* S\nhf : Function.Surjective \u21d1f\nr : R\nhr : r \u2208 nonZeroDivisors R\nhr' : f r = 0\n\u22a2 ringKrullDim S \u2264 ringKrullDim (R \u29f8 Ideal.span {r})"}, {"line": "exact ringKrullDim_le_of_surjective (Ideal.Quotient.lift _ f (RingHom.ker f\n    |>.span_singleton_le_iff_mem.mpr hr')) (Ideal.Quotient.lift_surjective_of_surjective _ _ hf)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Ring.KrullDimLE.mem_minimalPrimes_iff_le_of_isPrime {I J : Ideal R} [I.IsPrime] :\n    I \u2208 J.minimalPrimes \u2194 J \u2264 I := by\n  rwa [mem_minimalPrimes_iff, and_iff_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/KrullDimension/Zero.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] [Ring.KrullDimLE 0 R] (I : Ideal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : KrullDimLE 0 R\nI J : Ideal R\ninst\u271d : I.IsPrime\n\u22a2 I \u2208 J.minimalPrimes \u2194 J \u2264 I"}, {"line": "rwa [mem_minimalPrimes_iff, and_iff_right]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : KrullDimLE 0 R\nI J : Ideal R\ninst\u271d : I.IsPrime\n\u22a2 KrullDimLE 0 R"}]}
{"declaration": "lemma Ring.KrullDimLE.isField_of_isDomain [IsDomain R] : IsField R := by\n  by_contra h\n  obtain \u27e8p, hp, h\u27e9 := Ring.not_isField_iff_exists_prime.mp h\n  exact hp.symm (Ideal.bot_prime.isMaximal'.eq_of_le h.ne_top bot_le)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/KrullDimension/Zero.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] [Ring.KrullDimLE 0 R] (I : Ideal R)", "(R) in", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : KrullDimLE 0 R\ninst\u271d : IsDomain R\n\u22a2 IsField R"}, {"line": "by_contra h", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : KrullDimLE 0 R\ninst\u271d : IsDomain R\nh : \u00acIsField R\n\u22a2 False"}, {"line": "obtain \u27e8p, hp, h\u27e9 := Ring.not_isField_iff_exists_prime.mp h", "tactic_state": "case intro.intro\nR : Type u_1\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : KrullDimLE 0 R\ninst\u271d : IsDomain R\nh\u271d : \u00acIsField R\np : Ideal R\nhp : p \u2260 \u22a5\nh : p.IsPrime\n\u22a2 False"}, {"line": "exact hp.symm (Ideal.bot_prime.isMaximal'.eq_of_le h.ne_top bot_le)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ringKrullDimZero_iff_ringKrullDim_eq_zero [Nontrivial R] :\n    Ring.KrullDimLE 0 R \u2194 ringKrullDim R = 0 := by\n  rw [Ring.KrullDimLE]\n  rw [Order.krullDimLE_iff]\n  rw [le_antisymm_iff]\n  rw [\u2190 ringKrullDim]\n  rw [Nat.cast_zero]\n  rw [iff_self_and]\n  exact fun _ \u21a6 ringKrullDim_nonneg_of_nontrivial\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/KrullDimension/Zero.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] [Ring.KrullDimLE 0 R] (I : Ideal R)", "(R) in", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring.KrullDimLE 0 R\ninst\u271d : Nontrivial R\n\u22a2 Ring.KrullDimLE 0 R \u2194 ringKrullDim R = 0"}, {"line": "rw [Ring.KrullDimLE]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring.KrullDimLE 0 R\ninst\u271d : Nontrivial R\n\u22a2 Order.KrullDimLE 0 (PrimeSpectrum R) \u2194 ringKrullDim R = 0"}, {"line": "rw [Order.krullDimLE_iff]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring.KrullDimLE 0 R\ninst\u271d : Nontrivial R\n\u22a2 Order.krullDim (PrimeSpectrum R) \u2264 \u21910 \u2194 ringKrullDim R = 0"}, {"line": "rw [le_antisymm_iff]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring.KrullDimLE 0 R\ninst\u271d : Nontrivial R\n\u22a2 Order.krullDim (PrimeSpectrum R) \u2264 \u21910 \u2194 ringKrullDim R \u2264 0 \u2227 0 \u2264 ringKrullDim R"}, {"line": "rw [\u2190 ringKrullDim]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring.KrullDimLE 0 R\ninst\u271d : Nontrivial R\n\u22a2 ringKrullDim R \u2264 \u21910 \u2194 ringKrullDim R \u2264 0 \u2227 0 \u2264 ringKrullDim R"}, {"line": "rw [Nat.cast_zero]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring.KrullDimLE 0 R\ninst\u271d : Nontrivial R\n\u22a2 ringKrullDim R \u2264 0 \u2194 ringKrullDim R \u2264 0 \u2227 0 \u2264 ringKrullDim R"}, {"line": "rw [iff_self_and]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring.KrullDimLE 0 R\ninst\u271d : Nontrivial R\n\u22a2 ringKrullDim R \u2264 0 \u2192 0 \u2264 ringKrullDim R"}, {"line": "exact fun _ \u21a6 ringKrullDim_nonneg_of_nontrivial", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Ring.krullDimLE_zero_and_isLocalRing_tfae :\n    List.TFAE\n    [ Ring.KrullDimLE 0 R \u2227 IsLocalRing R,\n      \u2203! I : Ideal R, I.IsPrime,\n      \u2200 x : R, IsNilpotent x \u2194 \u00ac IsUnit x,\n      (nilradical R).IsMaximal ] := by\n  tfae_have 1 \u2192 3 := by\n    intro \u27e8h\u2081, h\u2082\u27e9 x\n    show x \u2208 nilradical R \u2194 x \u2208 IsLocalRing.maximalIdeal R\n    rw [nilradical]\n    rw [Ideal.radical_eq_sInf]\n    simp [\u2190 Ideal.isMaximal_iff_isPrime, IsLocalRing.isMaximal_iff]\n  tfae_have 3 \u2192 4 := by\n    refine fun H \u21a6 \u27e8fun e \u21a6 ?_, fun I hI \u21a6 ?_\u27e9\n    \u00b7 obtain \u27e8n, hn\u27e9 := (Ideal.eq_top_iff_one _).mp e\n      exact (H 0).mp .zero ((show (1 : R) = 0 by simpa using hn) \u25b8 isUnit_one)\n    \u00b7 obtain \u27e8x, hx, hx'\u27e9 := (SetLike.lt_iff_le_and_exists.mp hI).2\n      exact Ideal.eq_top_of_isUnit_mem _ hx (not_not.mp ((H x).not.mp hx'))\n  tfae_have 4 \u2192 2 := fun H \u21a6 \u27e8_, H.isPrime, fun p (hp : p.IsPrime) \u21a6\n      (H.eq_of_le hp.ne_top (nilradical_le_prime p)).symm\u27e9\n  tfae_have 2 \u2192 1 := by\n    rintro \u27e8P, hP\u2081, hP\u2082\u27e9\n    obtain \u27e8P, hP\u2083, -\u27e9 := P.exists_le_maximal hP\u2081.ne_top\n    obtain rfl := hP\u2082 P hP\u2083.isPrime\n    exact \u27e8.mk\u2080 fun Q h \u21a6 hP\u2082 Q h \u25b8 hP\u2083, .of_unique_max_ideal \u27e8P, hP\u2083, fun Q h \u21a6 hP\u2082 Q h.isPrime\u27e9\u27e9\n  tfae_finish\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/KrullDimension/Zero.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] [Ring.KrullDimLE 0 R] (I : Ideal R)", "(R) in", "(R) in", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : KrullDimLE 0 R\n\u22a2 [KrullDimLE 0 R \u2227 IsLocalRing R, \u2203! I, I.IsPrime, \u2200 (x : R), IsNilpotent x \u2194 \u00acIsUnit x, (nilradical R).IsMaximal].TFAE"}, {"line": "tfae_have 1 \u2192 3 := by\n    intro \u27e8h\u2081, h\u2082\u27e9 x\n    show x \u2208 nilradical R \u2194 x \u2208 IsLocalRing.maximalIdeal R\n    rw [nilradical]\n    rw [Ideal.radical_eq_sInf]\n    simp [\u2190 Ideal.isMaximal_iff_isPrime, IsLocalRing.isMaximal_iff]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : KrullDimLE 0 R\ntfae_1_to_3 : KrullDimLE 0 R \u2227 IsLocalRing R \u2192 \u2200 (x : R), IsNilpotent x \u2194 \u00acIsUnit x\n\u22a2 [KrullDimLE 0 R \u2227 IsLocalRing R, \u2203! I, I.IsPrime, \u2200 (x : R), IsNilpotent x \u2194 \u00acIsUnit x, (nilradical R).IsMaximal].TFAE"}, {"line": "tfae_have 3 \u2192 4 := by\n    refine fun H \u21a6 \u27e8fun e \u21a6 ?_, fun I hI \u21a6 ?_\u27e9\n    \u00b7 obtain \u27e8n, hn\u27e9 := (Ideal.eq_top_iff_one _).mp e\n      exact (H 0).mp .zero ((show (1 : R) = 0 by simpa using hn) \u25b8 isUnit_one)\n    \u00b7 obtain \u27e8x, hx, hx'\u27e9 := (SetLike.lt_iff_le_and_exists.mp hI).2\n      exact Ideal.eq_top_of_isUnit_mem _ hx (not_not.mp ((H x).not.mp hx'))", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : KrullDimLE 0 R\ntfae_1_to_3 : KrullDimLE 0 R \u2227 IsLocalRing R \u2192 \u2200 (x : R), IsNilpotent x \u2194 \u00acIsUnit x\ntfae_3_to_4 : (\u2200 (x : R), IsNilpotent x \u2194 \u00acIsUnit x) \u2192 (nilradical R).IsMaximal\n\u22a2 [KrullDimLE 0 R \u2227 IsLocalRing R, \u2203! I, I.IsPrime, \u2200 (x : R), IsNilpotent x \u2194 \u00acIsUnit x, (nilradical R).IsMaximal].TFAE"}, {"line": "tfae_have 4 \u2192 2 := fun H \u21a6 \u27e8_, H.isPrime, fun p (hp : p.IsPrime) \u21a6\n      (H.eq_of_le hp.ne_top (nilradical_le_prime p)).symm\u27e9", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : KrullDimLE 0 R\ntfae_1_to_3 : KrullDimLE 0 R \u2227 IsLocalRing R \u2192 \u2200 (x : R), IsNilpotent x \u2194 \u00acIsUnit x\ntfae_3_to_4 : (\u2200 (x : R), IsNilpotent x \u2194 \u00acIsUnit x) \u2192 (nilradical R).IsMaximal\ntfae_4_to_2 : (nilradical R).IsMaximal \u2192 \u2203! I, I.IsPrime\n\u22a2 [KrullDimLE 0 R \u2227 IsLocalRing R, \u2203! I, I.IsPrime, \u2200 (x : R), IsNilpotent x \u2194 \u00acIsUnit x, (nilradical R).IsMaximal].TFAE"}, {"line": "tfae_have 2 \u2192 1 := by\n    rintro \u27e8P, hP\u2081, hP\u2082\u27e9\n    obtain \u27e8P, hP\u2083, -\u27e9 := P.exists_le_maximal hP\u2081.ne_top\n    obtain rfl := hP\u2082 P hP\u2083.isPrime\n    exact \u27e8.mk\u2080 fun Q h \u21a6 hP\u2082 Q h \u25b8 hP\u2083, .of_unique_max_ideal \u27e8P, hP\u2083, fun Q h \u21a6 hP\u2082 Q h.isPrime\u27e9\u27e9", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : KrullDimLE 0 R\ntfae_1_to_3 : KrullDimLE 0 R \u2227 IsLocalRing R \u2192 \u2200 (x : R), IsNilpotent x \u2194 \u00acIsUnit x\ntfae_3_to_4 : (\u2200 (x : R), IsNilpotent x \u2194 \u00acIsUnit x) \u2192 (nilradical R).IsMaximal\ntfae_4_to_2 : (nilradical R).IsMaximal \u2192 \u2203! I, I.IsPrime\ntfae_2_to_1 : (\u2203! I, I.IsPrime) \u2192 KrullDimLE 0 R \u2227 IsLocalRing R\n\u22a2 [KrullDimLE 0 R \u2227 IsLocalRing R, \u2203! I, I.IsPrime, \u2200 (x : R), IsNilpotent x \u2194 \u00acIsUnit x, (nilradical R).IsMaximal].TFAE"}, {"line": "tfae_finish", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Module.finrank_of_isLocalizedModule_of_free\n    (R\u209b : Type*) {M\u209b : Type*} [AddCommGroup M\u209b] [Module R M\u209b]\n    [CommRing R\u209b] [Algebra R R\u209b] [Module R\u209b M\u209b] [IsScalarTower R R\u209b M\u209b] (S : Submonoid R)\n    (f : M \u2192\u2097[R] M\u209b) [IsLocalization S R\u209b] [IsLocalizedModule S f] [Module.Free R M]\n    [Nontrivial R\u209b] :\n    Module.finrank R\u209b M\u209b = Module.finrank R M := by\n  simpa using congr(Cardinal.toNat $(Module.lift_rank_of_isLocalizedModule_of_free R\u209b S f))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LocalProperties/Projective.lean", "context": {"open": [], "variables": ["{R N N' : Type*} {M : Type uM} [CommRing R] [AddCommGroup M] [Module R M] [AddCommGroup N]", "[Module R N] [AddCommGroup N'] [Module R N'] (S : Submonoid R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type uM\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : AddCommGroup M\ninst\u271d\u00b9\u2070 : Module R M\nR\u209b : Type u_4\nM\u209b : Type u_5\ninst\u271d\u2079 : AddCommGroup M\u209b\ninst\u271d\u2078 : Module R M\u209b\ninst\u271d\u2077 : CommRing R\u209b\ninst\u271d\u2076 : Algebra R R\u209b\ninst\u271d\u2075 : Module R\u209b M\u209b\ninst\u271d\u2074 : IsScalarTower R R\u209b M\u209b\nS : Submonoid R\nf : M \u2192\u2097[R] M\u209b\ninst\u271d\u00b3 : IsLocalization S R\u209b\ninst\u271d\u00b2 : IsLocalizedModule S f\ninst\u271d\u00b9 : Free R M\ninst\u271d : Nontrivial R\u209b\n\u22a2 finrank R\u209b M\u209b = finrank R M"}, {"line": "simpa using congr(Cardinal.toNat $(Module.lift_rank_of_isLocalizedModule_of_free R\u209b S f))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isReduced_ofLocalizationMaximal : OfLocalizationMaximal fun R _ => IsReduced R := by\n  introv R h\n  constructor\n  intro x hx\n  apply eq_zero_of_localization\n  intro J hJ\n  specialize h J hJ\n  exact (hx.map <| algebraMap R <| Localization.AtPrime J).eq_zero", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LocalProperties/Reduced.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 OfLocalizationMaximal fun R x => IsReduced R"}, {"line": "introv R h", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nh : \u2200 (J : Ideal R) (x : J.IsMaximal), (fun R x => IsReduced R) (Localization.AtPrime J) OreLocalization.instCommRing\n\u22a2 IsReduced R"}, {"line": "constructor", "tactic_state": "case eq_zero\nR : Type u_1\ninst\u271d : CommRing R\nh : \u2200 (J : Ideal R) (x : J.IsMaximal), (fun R x => IsReduced R) (Localization.AtPrime J) OreLocalization.instCommRing\n\u22a2 \u2200 (x : R), IsNilpotent x \u2192 x = 0"}, {"line": "intro x hx", "tactic_state": "case eq_zero\nR : Type u_1\ninst\u271d : CommRing R\nh : \u2200 (J : Ideal R) (x : J.IsMaximal), (fun R x => IsReduced R) (Localization.AtPrime J) OreLocalization.instCommRing\nx : R\nhx : IsNilpotent x\n\u22a2 x = 0"}, {"line": "apply eq_zero_of_localization", "tactic_state": "case eq_zero.h\nR : Type u_1\ninst\u271d : CommRing R\nh : \u2200 (J : Ideal R) (x : J.IsMaximal), (fun R x => IsReduced R) (Localization.AtPrime J) OreLocalization.instCommRing\nx : R\nhx : IsNilpotent x\n\u22a2 \u2200 (J : Ideal R) (x_1 : J.IsMaximal), (algebraMap R (Localization.AtPrime J)) x = 0"}, {"line": "intro J hJ", "tactic_state": "case eq_zero.h\nR : Type u_1\ninst\u271d : CommRing R\nh : \u2200 (J : Ideal R) (x : J.IsMaximal), (fun R x => IsReduced R) (Localization.AtPrime J) OreLocalization.instCommRing\nx : R\nhx : IsNilpotent x\nJ : Ideal R\nhJ : J.IsMaximal\n\u22a2 (algebraMap R (Localization.AtPrime J)) x = 0"}, {"line": "specialize h J hJ", "tactic_state": "case eq_zero.h\nR : Type u_1\ninst\u271d : CommRing R\nx : R\nhx : IsNilpotent x\nJ : Ideal R\nhJ : J.IsMaximal\nh : IsReduced (Localization.AtPrime J)\n\u22a2 (algebraMap R (Localization.AtPrime J)) x = 0"}, {"line": "exact (hx.map <| algebraMap R <| Localization.AtPrime J).eq_zero", "tactic_state": "No Goals!"}]}
{"declaration": "lemma RingHom.HoldsForLocalizationAway.containsIdentities (hPl : HoldsForLocalizationAway P) :\n    ContainsIdentities P := by\n  introv R\n  exact hPl.of_bijective _ _ Function.bijective_id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LocalProperties/Basic.lean", "context": {"open": ["scoped Pointwise"], "variables": ["{R S : Type u} [CommRing R] [CommRing S] (f : R \u2192+* S)", "(R' S' : Type u) [CommRing R'] [CommRing S']", "[Algebra R R'] [Algebra S S']", "(P : \u2200 (R : Type u) [CommRing R], Prop)", "(P : \u2200 {R S : Type u} [CommRing R] [CommRing S] (_ : R \u2192+* S), Prop)", "{P f R' S'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nhPl : HoldsForLocalizationAway fun {R S} [CommRing R] [CommRing S] => P\n\u22a2 ContainsIdentities fun {R S} [CommRing R] [CommRing S] => P"}, {"line": "introv R", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nhPl : HoldsForLocalizationAway fun {R S} [CommRing R] [CommRing S] => P\nR : Type u\ninst\u271d : CommRing R\n\u22a2 P (id R)"}, {"line": "exact hPl.of_bijective _ _ Function.bijective_id", "tactic_state": "No Goals!"}]}
{"declaration": "lemma RingHom.PropertyIsLocal.HoldsForLocalizationAway (hP : RingHom.PropertyIsLocal @P)\n    (hPi : ContainsIdentities P) :\n    RingHom.HoldsForLocalizationAway @P := by\n  introv R _\n  have : algebraMap R S = (algebraMap R S).comp (RingHom.id R) := by simp\n  rw [this]\n  apply hP.StableUnderCompositionWithLocalizationAwayTarget S r\n  apply hPi\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LocalProperties/Basic.lean", "context": {"open": ["scoped Pointwise"], "variables": ["{R S : Type u} [CommRing R] [CommRing S] (f : R \u2192+* S)", "(R' S' : Type u) [CommRing R'] [CommRing S']", "[Algebra R R'] [Algebra S S']", "(P : \u2200 (R : Type u) [CommRing R], Prop)", "(P : \u2200 {R S : Type u} [CommRing R] [CommRing S] (_ : R \u2192+* S), Prop)", "{P f R' S'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nhP : PropertyIsLocal P\nhPi : ContainsIdentities fun {R S} [CommRing R] [CommRing S] => P\n\u22a2 RingHom.HoldsForLocalizationAway P"}, {"line": "introv R _", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nhP : PropertyIsLocal P\nhPi : ContainsIdentities fun {R S} [CommRing R] [CommRing S] => P\nR S : Type u\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\nr : R\ninst\u271d : IsLocalization.Away r S\n\u22a2 P (algebraMap R S)"}, {"line": "have : algebraMap R S = (algebraMap R S).comp (RingHom.id R) := by simp", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nhP : PropertyIsLocal P\nhPi : ContainsIdentities fun {R S} [CommRing R] [CommRing S] => P\nR S : Type u\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\nr : R\ninst\u271d : IsLocalization.Away r S\nthis : algebraMap R S = (algebraMap R S).comp (id R)\n\u22a2 P (algebraMap R S)"}, {"line": "rw [this]", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nhP : PropertyIsLocal P\nhPi : ContainsIdentities fun {R S} [CommRing R] [CommRing S] => P\nR S : Type u\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\nr : R\ninst\u271d : IsLocalization.Away r S\nthis : algebraMap R S = (algebraMap R S).comp (id R)\n\u22a2 P ((algebraMap R S).comp (id R))"}, {"line": "apply hP.StableUnderCompositionWithLocalizationAwayTarget S r", "tactic_state": "case a\nP : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nhP : PropertyIsLocal P\nhPi : ContainsIdentities fun {R S} [CommRing R] [CommRing S] => P\nR S : Type u\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\nr : R\ninst\u271d : IsLocalization.Away r S\nthis : algebraMap R S = (algebraMap R S).comp (id R)\n\u22a2 P (id R)"}, {"line": "apply hPi", "tactic_state": "No Goals!"}]}
{"declaration": "theorem RingHom.OfLocalizationSpanTarget.ofLocalizationSpan\n    (hP : RingHom.OfLocalizationSpanTarget @P)\n    (hP' : RingHom.StableUnderCompositionWithLocalizationAwaySource @P) :\n    RingHom.OfLocalizationSpan @P := by\n  introv R hs hs'\n  apply_fun Ideal.map f at hs\n  rw [Ideal.map_span] at hs\n  rw [Ideal.map_top] at hs\n  apply hP _ _ hs\n  rintro \u27e8_, r, hr, rfl\u27e9\n  rw [\u2190 IsLocalization.map_comp (M := Submonoid.powers r) (S := Localization.Away r)     (T := Submonoid.powers (f r))]\n  \u00b7 apply hP' _ r\n    exact hs' \u27e8r, hr\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LocalProperties/Basic.lean", "context": {"open": ["scoped Pointwise"], "variables": ["{R S : Type u} [CommRing R] [CommRing S] (f : R \u2192+* S)", "(R' S' : Type u) [CommRing R'] [CommRing S']", "[Algebra R R'] [Algebra S S']", "(P : \u2200 (R : Type u) [CommRing R], Prop)", "(P : \u2200 {R S : Type u} [CommRing R] [CommRing S] (_ : R \u2192+* S), Prop)", "{P f R' S'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nhP : OfLocalizationSpanTarget P\nhP' : StableUnderCompositionWithLocalizationAwaySource P\n\u22a2 OfLocalizationSpan P"}, {"line": "introv R hs hs'", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nhP : OfLocalizationSpanTarget P\nhP' : StableUnderCompositionWithLocalizationAwaySource P\nR S : Type u\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nf : R \u2192+* S\ns : Set R\nhs : Ideal.span s = \u22a4\nhs' : \u2200 (r : \u2191s), P (Localization.awayMap f \u2191r)\n\u22a2 P f"}, {"line": "apply_fun Ideal.map f at hs", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nhP : OfLocalizationSpanTarget P\nhP' : StableUnderCompositionWithLocalizationAwaySource P\nR S : Type u\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nf : R \u2192+* S\ns : Set R\nhs' : \u2200 (r : \u2191s), P (Localization.awayMap f \u2191r)\nhs : Ideal.map f (Ideal.span s) = Ideal.map f \u22a4\n\u22a2 P f"}, {"line": "rw [Ideal.map_span] at hs", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nhP : OfLocalizationSpanTarget P\nhP' : StableUnderCompositionWithLocalizationAwaySource P\nR S : Type u\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nf : R \u2192+* S\ns : Set R\nhs' : \u2200 (r : \u2191s), P (Localization.awayMap f \u2191r)\nhs : Ideal.span (\u21d1f '' s) = Ideal.map f \u22a4\n\u22a2 P f"}, {"line": "rw [Ideal.map_top] at hs", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nhP : OfLocalizationSpanTarget P\nhP' : StableUnderCompositionWithLocalizationAwaySource P\nR S : Type u\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nf : R \u2192+* S\ns : Set R\nhs' : \u2200 (r : \u2191s), P (Localization.awayMap f \u2191r)\nhs : Ideal.span (\u21d1f '' s) = \u22a4\n\u22a2 P f"}, {"line": "apply hP _ _ hs", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nhP : OfLocalizationSpanTarget P\nhP' : StableUnderCompositionWithLocalizationAwaySource P\nR S : Type u\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nf : R \u2192+* S\ns : Set R\nhs' : \u2200 (r : \u2191s), P (Localization.awayMap f \u2191r)\nhs : Ideal.span (\u21d1f '' s) = \u22a4\n\u22a2 \u2200 (r : \u2191(\u21d1f '' s)), P ((algebraMap S (Localization.Away \u2191r)).comp f)"}, {"line": "rintro \u27e8_, r, hr, rfl\u27e9", "tactic_state": "case mk.intro.intro\nP : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nhP : OfLocalizationSpanTarget P\nhP' : StableUnderCompositionWithLocalizationAwaySource P\nR S : Type u\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nf : R \u2192+* S\ns : Set R\nhs' : \u2200 (r : \u2191s), P (Localization.awayMap f \u2191r)\nhs : Ideal.span (\u21d1f '' s) = \u22a4\nr : R\nhr : r \u2208 s\n\u22a2 P ((algebraMap S (Localization.Away \u2191\u27e8f r, \u22ef\u27e9)).comp f)"}, {"line": "rw [\u2190 IsLocalization.map_comp (M := Submonoid.powers r) (S := Localization.Away r)     (T := Submonoid.powers (f r))]", "tactic_state": "case mk.intro.intro\nP : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nhP : OfLocalizationSpanTarget P\nhP' : StableUnderCompositionWithLocalizationAwaySource P\nR S : Type u\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nf : R \u2192+* S\ns : Set R\nhs' : \u2200 (r : \u2191s), P (Localization.awayMap f \u2191r)\nhs : Ideal.span (\u21d1f '' s) = \u22a4\nr : R\nhr : r \u2208 s\n\u22a2 P ((IsLocalization.map (Localization.Away \u2191\u27e8f r, \u22ef\u27e9) f ?mk.intro.intro).comp (algebraMap R (Localization.Away r)))\n---\ncase mk.intro.intro\nP : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nhP : OfLocalizationSpanTarget P\nhP' : StableUnderCompositionWithLocalizationAwaySource P\nR S : Type u\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nf : R \u2192+* S\ns : Set R\nhs' : \u2200 (r : \u2191s), P (Localization.awayMap f \u2191r)\nhs : Ideal.span (\u21d1f '' s) = \u22a4\nr : R\nhr : r \u2208 s\n\u22a2 Submonoid.powers r \u2264 Submonoid.comap f (Submonoid.powers (f r))"}, {"line": "\u00b7 apply hP' _ r\n    exact hs' \u27e8r, hr\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma RingHom.IsStableUnderBaseChange.localizationPreserves : LocalizationPreserves P := by\n  introv R hf\n  exact hP.isLocalization_map _ _ hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LocalProperties/Basic.lean", "context": {"open": ["scoped Pointwise"], "variables": ["{R S : Type u} [CommRing R] [CommRing S] (f : R \u2192+* S)", "(R' S' : Type u) [CommRing R'] [CommRing S']", "[Algebra R R'] [Algebra S S']", "(P : \u2200 (R : Type u) [CommRing R], Prop)", "(P : \u2200 {R S : Type u} [CommRing R] [CommRing S] (_ : R \u2192+* S), Prop)", "{P f R' S'}", "(hP : RingHom.IsStableUnderBaseChange @P)", "{R S R\u1d63 S\u1d63 : Type u} [CommRing R] [CommRing S] [CommRing R\u1d63] [CommRing S\u1d63] [Algebra R R\u1d63]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\n\u22a2 LocalizationPreserves fun {R S} [CommRing R] [CommRing S] => P"}, {"line": "introv R hf", "tactic_state": "P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nR S : Type u\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : CommRing S\nf : R \u2192+* S\nM : Submonoid R\nR' S' : Type u\ninst\u271d\u2075 : CommRing R'\ninst\u271d\u2074 : CommRing S'\ninst\u271d\u00b3 : Algebra R R'\ninst\u271d\u00b2 : Algebra S S'\ninst\u271d\u00b9 : IsLocalization M R'\ninst\u271d : IsLocalization (Submonoid.map f M) S'\nhf : P f\n\u22a2 P (IsLocalization.map S' f \u22ef)"}, {"line": "exact hP.isLocalization_map _ _ hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ideal.localized'_eq_map (I : Ideal R) :\n    Submodule.localized' S p (Algebra.linearMap R S) I = I.map (algebraMap R S) := by\n  rw [map]\n  rw [span]\n  rw [Submodule.localized'_eq_span]\n  rw [Algebra.coe_linearMap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LocalProperties/Basic.lean", "context": {"open": ["scoped Pointwise"], "variables": ["{R S : Type u} [CommRing R] [CommRing S] (f : R \u2192+* S)", "(R' S' : Type u) [CommRing R'] [CommRing S']", "[Algebra R R'] [Algebra S S']", "(P : \u2200 (R : Type u) [CommRing R], Prop)", "(P : \u2200 {R S : Type u} [CommRing R] [CommRing S] (_ : R \u2192+* S), Prop)", "{P f R' S'}", "(hP : RingHom.IsStableUnderBaseChange @P)", "{R S R\u1d63 S\u1d63 : Type u} [CommRing R] [CommRing S] [CommRing R\u1d63] [CommRing S\u1d63] [Algebra R R\u1d63]", "{R : Type*} (S : Type*) [CommSemiring R] [CommSemiring S] [Algebra R S]", "(p : Submonoid R) [IsLocalization p S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\np : Submonoid R\ninst\u271d : IsLocalization p S\nI : Ideal R\n\u22a2 Submodule.localized' S p (Algebra.linearMap R S) I = map (algebraMap R S) I"}, {"line": "rw [map]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\np : Submonoid R\ninst\u271d : IsLocalization p S\nI : Ideal R\n\u22a2 Submodule.localized' S p (Algebra.linearMap R S) I = span (\u21d1(algebraMap R S) '' \u2191I)"}, {"line": "rw [span]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\np : Submonoid R\ninst\u271d : IsLocalization p S\nI : Ideal R\n\u22a2 Submodule.localized' S p (Algebra.linearMap R S) I = Submodule.span S (\u21d1(algebraMap R S) '' \u2191I)"}, {"line": "rw [Submodule.localized'_eq_span]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\np : Submonoid R\ninst\u271d : IsLocalization p S\nI : Ideal R\n\u22a2 Submodule.span S (\u21d1(Algebra.linearMap R S) '' \u2191I) = Submodule.span S (\u21d1(algebraMap R S) '' \u2191I)"}, {"line": "rw [Algebra.coe_linearMap]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma residue_ne_zero_iff_isUnit (x : R) : residue R x \u2260 0 \u2194 IsUnit x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/LocalRing/ResidueField/Basic.lean", "context": {"open": [], "variables": ["{R S T : Type*}", "[CommRing R] [IsLocalRing R] [CommRing S] [IsLocalRing S] [CommRing T] [IsLocalRing T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsLocalRing R\nx\u271d : Sort u_4\nresidue : x\u271d\nx : R\n\u22a2 sorry \u2260 0 \u2194 IsUnit x"}, {"line": "simp", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsLocalRing R\nx\u271d : Sort u_4\nresidue : x\u271d\nx : R\n\u22a2 \u00acsorry () = 0 \u2194 IsUnit x"}]}
{"declaration": "theorem cardinalMk_le {L : Type u} [CommSemiring L] [Algebra R L]\n    (S : Submonoid R) [IsLocalization S L] : #L \u2264 #R := by\n  simpa using lift_cardinalMk_le (L := L) S\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/Cardinality.lean", "context": {"open": ["Cardinal nonZeroDivisors"], "variables": ["{R : Type u} [CommSemiring R] {L : Type v} [CommSemiring L] [Algebra R L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : CommSemiring R\nL : Type u\ninst\u271d\u00b2 : CommSemiring L\ninst\u271d\u00b9 : Algebra R L\nS : Submonoid R\ninst\u271d : IsLocalization S L\n\u22a2 mk L \u2264 mk R"}, {"line": "simpa using lift_cardinalMk_le (L := L) S", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardinalMk (L : Type u) [CommRing L] [Algebra R L]\n    (S : Submonoid R) [IsLocalization S L] (hS : S \u2264 R\u2070) : #L = #R := by\n  simpa using lift_cardinalMk L S hS\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/Cardinality.lean", "context": {"open": ["Cardinal nonZeroDivisors"], "variables": ["{R : Type u} [CommSemiring R] {L : Type v} [CommSemiring L] [Algebra R L]", "{R : Type u} [CommRing R] {L : Type v} [CommRing L] [Algebra R L]", "(L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : CommRing R\nL : Type u\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : Algebra R L\nS : Submonoid R\ninst\u271d : IsLocalization S L\nhS : S \u2264 nonZeroDivisors R\n\u22a2 mk L = mk R"}, {"line": "simpa using lift_cardinalMk L S hS", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_localizationSpan' (t : Set R) (ht : Ideal.span t = \u22a4)\n    {M\u209a : \u2200 (_ : t), Type*} [\u2200 (g : t), AddCommMonoid (M\u209a g)] [\u2200 (g : t), Module R (M\u209a g)]\n    {R\u209a : \u2200 (_ : t), Type u} [\u2200 (g : t), CommRing (R\u209a g)] [\u2200 (g : t), Algebra R (R\u209a g)]\n    [h\u2081 : \u2200 (g : t), IsLocalization.Away g.val (R\u209a g)]\n    [\u2200 (g : t), Module (R\u209a g) (M\u209a g)] [\u2200 (g : t), IsScalarTower R (R\u209a g) (M\u209a g)]\n    (f : \u2200 (g : t), M \u2192\u2097[R] M\u209a g) [h\u2082 : \u2200 (g : t), IsLocalizedModule (Submonoid.powers g.val) (f g)]\n    (H : \u2200 (g : t), Module.Finite (R\u209a g) (M\u209a g)) :\n    Module.Finite R M := by\n  rw [Ideal.span_eq_top_iff_finite] at ht\n  obtain \u27e8t', hc, ht'\u27e9 := ht\n  have (g : t') : IsLocalization.Away g.val (R\u209a \u27e8g.val, hc g.property\u27e9) :=\n    h\u2081 \u27e8g.val, hc g.property\u27e9\n  have (g : t') : IsLocalizedModule (Submonoid.powers g.val)\n    ((fun g \u21a6 f \u27e8g.val, hc g.property\u27e9) g) := h\u2082 \u27e8g.val, hc g.property\u27e9\n  apply of_localizationSpan_finite' t' ht' (fun g \u21a6 f \u27e8g.val, hc g.property\u27e9)\n    (fun g \u21a6 H \u27e8g.val, hc g.property\u27e9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/Finiteness.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (S : Submonoid R)", "{R\u209a : Type v} [CommSemiring R\u209a] [Algebra R R\u209a] [IsLocalization S R\u209a]", "{M : Type w} [AddCommMonoid M] [Module R M]", "{M\u209a : Type t} [AddCommMonoid M\u209a] [Module R M\u209a] [Module R\u209a M\u209a] [IsScalarTower R R\u209a M\u209a]", "(f : M \u2192\u2097[R] M\u209a) [IsLocalizedModule S f]", "{R : Type u} [CommRing R] {M : Type w} [AddCommMonoid M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2078 : CommRing R\nM : Type w\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\nt : Set R\nht : Ideal.span t = \u22a4\nM\u209a : \u2191t \u2192 Type u_1\ninst\u271d\u2075 : (g : \u2191t) \u2192 AddCommMonoid (M\u209a g)\ninst\u271d\u2074 : (g : \u2191t) \u2192 Module R (M\u209a g)\nR\u209a : \u2191t \u2192 Type u\ninst\u271d\u00b3 : (g : \u2191t) \u2192 CommRing (R\u209a g)\ninst\u271d\u00b2 : (g : \u2191t) \u2192 Algebra R (R\u209a g)\nh\u2081 : \u2200 (g : \u2191t), IsLocalization.Away (\u2191g) (R\u209a g)\ninst\u271d\u00b9 : (g : \u2191t) \u2192 Module (R\u209a g) (M\u209a g)\ninst\u271d : \u2200 (g : \u2191t), IsScalarTower R (R\u209a g) (M\u209a g)\nf : (g : \u2191t) \u2192 M \u2192\u2097[R] M\u209a g\nh\u2082 : \u2200 (g : \u2191t), IsLocalizedModule (Submonoid.powers \u2191g) (f g)\nH : \u2200 (g : \u2191t), Module.Finite (R\u209a g) (M\u209a g)\n\u22a2 Module.Finite R M"}, {"line": "rw [Ideal.span_eq_top_iff_finite] at ht", "tactic_state": "R : Type u\ninst\u271d\u2078 : CommRing R\nM : Type w\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\nt : Set R\nht : \u2203 s', \u2191s' \u2286 t \u2227 Ideal.span \u2191s' = \u22a4\nM\u209a : \u2191t \u2192 Type u_1\ninst\u271d\u2075 : (g : \u2191t) \u2192 AddCommMonoid (M\u209a g)\ninst\u271d\u2074 : (g : \u2191t) \u2192 Module R (M\u209a g)\nR\u209a : \u2191t \u2192 Type u\ninst\u271d\u00b3 : (g : \u2191t) \u2192 CommRing (R\u209a g)\ninst\u271d\u00b2 : (g : \u2191t) \u2192 Algebra R (R\u209a g)\nh\u2081 : \u2200 (g : \u2191t), IsLocalization.Away (\u2191g) (R\u209a g)\ninst\u271d\u00b9 : (g : \u2191t) \u2192 Module (R\u209a g) (M\u209a g)\ninst\u271d : \u2200 (g : \u2191t), IsScalarTower R (R\u209a g) (M\u209a g)\nf : (g : \u2191t) \u2192 M \u2192\u2097[R] M\u209a g\nh\u2082 : \u2200 (g : \u2191t), IsLocalizedModule (Submonoid.powers \u2191g) (f g)\nH : \u2200 (g : \u2191t), Module.Finite (R\u209a g) (M\u209a g)\n\u22a2 Module.Finite R M"}, {"line": "obtain \u27e8t', hc, ht'\u27e9 := ht", "tactic_state": "case intro.intro\nR : Type u\ninst\u271d\u2078 : CommRing R\nM : Type w\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\nt : Set R\nM\u209a : \u2191t \u2192 Type u_1\ninst\u271d\u2075 : (g : \u2191t) \u2192 AddCommMonoid (M\u209a g)\ninst\u271d\u2074 : (g : \u2191t) \u2192 Module R (M\u209a g)\nR\u209a : \u2191t \u2192 Type u\ninst\u271d\u00b3 : (g : \u2191t) \u2192 CommRing (R\u209a g)\ninst\u271d\u00b2 : (g : \u2191t) \u2192 Algebra R (R\u209a g)\nh\u2081 : \u2200 (g : \u2191t), IsLocalization.Away (\u2191g) (R\u209a g)\ninst\u271d\u00b9 : (g : \u2191t) \u2192 Module (R\u209a g) (M\u209a g)\ninst\u271d : \u2200 (g : \u2191t), IsScalarTower R (R\u209a g) (M\u209a g)\nf : (g : \u2191t) \u2192 M \u2192\u2097[R] M\u209a g\nh\u2082 : \u2200 (g : \u2191t), IsLocalizedModule (Submonoid.powers \u2191g) (f g)\nH : \u2200 (g : \u2191t), Module.Finite (R\u209a g) (M\u209a g)\nt' : Finset R\nhc : \u2191t' \u2286 t\nht' : Ideal.span \u2191t' = \u22a4\n\u22a2 Module.Finite R M"}, {"line": "have (g : t') : IsLocalization.Away g.val (R\u209a \u27e8g.val, hc g.property\u27e9) :=\n    h\u2081 \u27e8g.val, hc g.property\u27e9", "tactic_state": "case intro.intro\nR : Type u\ninst\u271d\u2078 : CommRing R\nM : Type w\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\nt : Set R\nM\u209a : \u2191t \u2192 Type u_1\ninst\u271d\u2075 : (g : \u2191t) \u2192 AddCommMonoid (M\u209a g)\ninst\u271d\u2074 : (g : \u2191t) \u2192 Module R (M\u209a g)\nR\u209a : \u2191t \u2192 Type u\ninst\u271d\u00b3 : (g : \u2191t) \u2192 CommRing (R\u209a g)\ninst\u271d\u00b2 : (g : \u2191t) \u2192 Algebra R (R\u209a g)\nh\u2081 : \u2200 (g : \u2191t), IsLocalization.Away (\u2191g) (R\u209a g)\ninst\u271d\u00b9 : (g : \u2191t) \u2192 Module (R\u209a g) (M\u209a g)\ninst\u271d : \u2200 (g : \u2191t), IsScalarTower R (R\u209a g) (M\u209a g)\nf : (g : \u2191t) \u2192 M \u2192\u2097[R] M\u209a g\nh\u2082 : \u2200 (g : \u2191t), IsLocalizedModule (Submonoid.powers \u2191g) (f g)\nH : \u2200 (g : \u2191t), Module.Finite (R\u209a g) (M\u209a g)\nt' : Finset R\nhc : \u2191t' \u2286 t\nht' : Ideal.span \u2191t' = \u22a4\nthis : { x // x \u2208 t' } \u2192 sorry\n\u22a2 Module.Finite R M"}, {"line": "have (g : t') : IsLocalizedModule (Submonoid.powers g.val)\n    ((fun g \u21a6 f \u27e8g.val, hc g.property\u27e9) g) := h\u2082 \u27e8g.val, hc g.property\u27e9", "tactic_state": "case intro.intro\nR : Type u\ninst\u271d\u2078 : CommRing R\nM : Type w\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\nt : Set R\nM\u209a : \u2191t \u2192 Type u_1\ninst\u271d\u2075 : (g : \u2191t) \u2192 AddCommMonoid (M\u209a g)\ninst\u271d\u2074 : (g : \u2191t) \u2192 Module R (M\u209a g)\nR\u209a : \u2191t \u2192 Type u\ninst\u271d\u00b3 : (g : \u2191t) \u2192 CommRing (R\u209a g)\ninst\u271d\u00b2 : (g : \u2191t) \u2192 Algebra R (R\u209a g)\nh\u2081 : \u2200 (g : \u2191t), IsLocalization.Away (\u2191g) (R\u209a g)\ninst\u271d\u00b9 : (g : \u2191t) \u2192 Module (R\u209a g) (M\u209a g)\ninst\u271d : \u2200 (g : \u2191t), IsScalarTower R (R\u209a g) (M\u209a g)\nf : (g : \u2191t) \u2192 M \u2192\u2097[R] M\u209a g\nh\u2082 : \u2200 (g : \u2191t), IsLocalizedModule (Submonoid.powers \u2191g) (f g)\nH : \u2200 (g : \u2191t), Module.Finite (R\u209a g) (M\u209a g)\nt' : Finset R\nhc : \u2191t' \u2286 t\nht' : Ideal.span \u2191t' = \u22a4\nthis\u271d : { x // x \u2208 t' } \u2192 sorry\nthis : { x // x \u2208 t' } \u2192 sorry\n\u22a2 Module.Finite R M"}, {"line": "apply of_localizationSpan_finite' t' ht' (fun g \u21a6 f \u27e8g.val, hc g.property\u27e9)\n    (fun g \u21a6 H \u27e8g.val, hc g.property\u27e9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isUnit_den_zero : IsUnit (den A (0 : K) : A) := by\n  simp [isUnit_den_iff, IsLocalization.isInteger_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/NumDen.lean", "context": {"open": ["IsLocalization"], "variables": ["(A : Type*) [CommRing A] [IsDomain A] [UniqueFactorizationMonoid A]", "{K : Type*} [Field K] [Algebra A K] [IsFractionRing A K]", "{A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : IsDomain A\ninst\u271d : UniqueFactorizationMonoid A\nx\u271d : Sort u_3\nden : x\u271d\n\u22a2 IsUnit sorry"}, {"line": "simp [isUnit_den_iff, IsLocalization.isInteger_zero]", "tactic_state": "A : Type u_1\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : IsDomain A\ninst\u271d : UniqueFactorizationMonoid A\nx\u271d : Sort u_3\nden : x\u271d\n\u22a2 IsUnit (sorry ())"}]}
{"declaration": "theorem AtPrime.Nontrivial [IsLocalization.AtPrime S P] : Nontrivial S :=\n  nontrivial_of_ne (0 : S) 1 fun hze => by\n    rw [\u2190 (algebraMap R S).map_one] at hze\n    rw [\u2190 (algebraMap R S).map_zero] at hze\n    obtain \u27e8t, ht\u27e9 := (eq_iff_exists P.primeCompl S).1 hze\n    have htz : (t : R) = 0 := by simpa using ht.symm\n    exact t.2 (htz.symm \u25b8 P.zero_mem : \u2191t \u2208 P)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/AtPrime.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] (S : Type*) [CommSemiring S]", "[Algebra R S] {P : Type*} [CommSemiring P]", "(P : Ideal R) [hp : P.IsPrime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\nP : Ideal R\nhp : P.IsPrime\ninst\u271d : IsLocalization.AtPrime S P\nhze : 0 = 1\n\u22a2 False"}, {"line": "simpa using ht.symm\n    exact t.2 (htz.symm \u25b8 P.zero_mem : \u2191t \u2208 P)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Ideal.isPrime_map_of_isLocalizationAtPrime {p : Ideal R} [p.IsPrime] (hpq : p \u2264 q) :\n    (p.map (algebraMap R S)).IsPrime := by\n  have disj : Disjoint (q.primeCompl : Set R) p := by\n    simp [Ideal.primeCompl, \u2190 le_compl_iff_disjoint_left, hpq]\n  apply IsLocalization.isPrime_of_isPrime_disjoint q.primeCompl _ p (by simpa) disj\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/AtPrime.lean", "context": {"open": ["IsLocalization"], "variables": ["{R : Type*} [CommSemiring R] (S : Type*) [CommSemiring S]", "[Algebra R S] {P : Type*} [CommSemiring P]", "(P : Ideal R) [hp : P.IsPrime]", "{A : Type*} [CommRing A] [IsDomain A]", "(I : Ideal R) [hI : I.IsPrime] [IsLocalization.AtPrime S I]", "(I : Ideal R) [hI : I.IsPrime]", "{I}", "(I)", "{A B : Type*} [CommRing A] [CommRing B] [Algebra A B]", "{\u03b9 : Type*} {R : \u03b9 \u2192 Type*} [\u2200 i, CommSemiring (R i)]", "{i : \u03b9} (I : Ideal (R i)) [I.IsPrime]", "{R : Type*} [CommRing R] (q : Ideal R) [q.IsPrime] {S : Type*} [CommRing S] [Algebra R S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_9\ninst\u271d\u2074 : CommRing R\nq : Ideal R\ninst\u271d\u00b3 : q.IsPrime\nS : Type u_10\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\np : Ideal R\ninst\u271d : p.IsPrime\nhpq : p \u2264 q\n\u22a2 (map (algebraMap R S) p).IsPrime"}, {"line": "have disj : Disjoint (q.primeCompl : Set R) p := sorry", "tactic_state": "R : Type u_9\ninst\u271d\u2074 : CommRing R\nq : Ideal R\ninst\u271d\u00b3 : q.IsPrime\nS : Type u_10\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\np : Ideal R\ninst\u271d : p.IsPrime\nhpq : p \u2264 q\ndisj : Disjoint sorry \u2191p\n\u22a2 (map (algebraMap R S) p).IsPrime"}, {"line": "apply IsLocalization.isPrime_of_isPrime_disjoint q.primeCompl _ p (by simpa) disj", "tactic_state": "No Goals!"}]}
{"declaration": "lemma LocalizedModule.equivTensorProduct_symm_apply_tmul (x : M) (r : R) (s : S) :\n    (equivTensorProduct S M).symm (Localization.mk r s \u2297\u209c[R] x) = r \u2022 mk x s := by\n  simp [equivTensorProduct, IsBaseChange.equiv_tmul, mk_smul_mk, smul'_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/BaseChange.lean", "context": {"open": ["TensorProduct"], "variables": ["{R : Type*} [CommSemiring R] (S : Submonoid R)", "(M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\nS : Submonoid R\nM : Type u_4\nx : M\nr : R\ns : \u21a5S\n\u22a2 sorry = r \u2022 sorry"}, {"line": "simp [equivTensorProduct, IsBaseChange.equiv_tmul, mk_smul_mk, smul'_mk]", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\nS : Submonoid R\nM : Type u_4\nx : M\nr : R\ns : \u21a5S\n\u22a2 sorry () = r \u2022 sorry ()"}]}
{"declaration": "lemma LocalizedModule.equivTensorProduct_symm_apply_tmul_one (x : M) :\n    (equivTensorProduct S M).symm (1 \u2297\u209c[R] x) = mk x 1 := by\n  simp [\u2190 Localization.mk_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/BaseChange.lean", "context": {"open": ["TensorProduct"], "variables": ["{R : Type*} [CommSemiring R] (S : Submonoid R)", "(M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\nx : M\n\u22a2 sorry = sorry"}, {"line": "simp [\u2190 Localization.mk_one]", "tactic_state": "M : Type u_3\nx : M\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem mk_natCast (m : \u2115) : (mk m 1 : Localization M) = m := by\n  simpa using mk_algebraMap (R := R) (A := \u2115) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/Basic.lean", "context": {"open": ["Function", "IsLocalization", "Function in", "IsLocalization"], "variables": ["{\u03b9 : Type*} {R : \u03b9 \u2192 Type*} [\u2200 i, CommSemiring (R i)]", "{i : \u03b9} (S : Submonoid (R i))", "{R : Type*} [CommSemiring R] {M N : Submonoid R} {S : Type*} [CommSemiring S]", "[Algebra R S] {P : Type*} [CommSemiring P]", "[IsLocalization M S]", "(M S) in", "{g : R \u2192+* P} (hg : \u2200 y : M, IsUnit (g y))", "(M) in", "{Q : Type*} [CommSemiring Q] [Algebra R Q] [IsLocalization M Q]", "(M S Q)", "(M) in", "{A : Type*} [CommSemiring A]", "{A : Type*} [CommSemiring A]", "{S Q h}", "(R M)", "(M N)", "(S) in", "(M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\n\u22a2 sorry = m"}, {"line": "simpa using mk_algebraMap (R := R) (A := \u2115) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_intCast (m : \u2124) : (mk m 1 : Localization M) = m := by\n  simpa using mk_algebraMap (R := R) (A := \u2124) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/Basic.lean", "context": {"open": ["Function", "IsLocalization", "Function in", "IsLocalization"], "variables": ["{\u03b9 : Type*} {R : \u03b9 \u2192 Type*} [\u2200 i, CommSemiring (R i)]", "{i : \u03b9} (S : Submonoid (R i))", "{R : Type*} [CommSemiring R] {M N : Submonoid R} {S : Type*} [CommSemiring S]", "[Algebra R S] {P : Type*} [CommSemiring P]", "[IsLocalization M S]", "(M S) in", "{g : R \u2192+* P} (hg : \u2200 y : M, IsUnit (g y))", "(M) in", "{Q : Type*} [CommSemiring Q] [Algebra R Q] [IsLocalization M Q]", "(M S Q)", "(M) in", "{A : Type*} [CommSemiring A]", "{A : Type*} [CommSemiring A]", "{S Q h}", "(R M)", "(M N)", "(S) in", "(M)", "[IsLocalization M S]", "(S) (M)", "{R : Type*} [CommRing R] {M : Submonoid R} (S : Type*) [CommRing S]", "[Algebra R S] {P : Type*} [CommRing P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2124\n\u22a2 sorry = m"}, {"line": "simpa using mk_algebraMap (R := R) (A := \u2124) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk'_zero (s : M) : IsLocalization.mk' S 0 s = 0 := by\n  rw [eq_comm]\n  rw [IsLocalization.eq_mk'_iff_mul_eq]\n  rw [zero_mul]\n  rw [map_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/Defs.lean", "context": {"open": ["Function"], "variables": ["{R : Type*} [CommSemiring R] (M : Submonoid R) (S : Type*) [CommSemiring S]", "[Algebra R S] {P : Type*} [CommSemiring P]", "{M}", "[IsLocalization M S]", "(M) {S}", "(S) in", "(S)", "(M) {S}", "{M}", "(M S)", "{M}", "{S}", "(M)", "(S)", "{M S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\ns : \u21a5M\n\u22a2 IsLocalization.mk' S 0 s = 0"}, {"line": "rw [eq_comm]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\ns : \u21a5M\n\u22a2 0 = IsLocalization.mk' S 0 s"}, {"line": "rw [IsLocalization.eq_mk'_iff_mul_eq]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\ns : \u21a5M\n\u22a2 0 * (algebraMap R S) \u2191s = (algebraMap R S) 0"}, {"line": "rw [zero_mul]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\ns : \u21a5M\n\u22a2 0 = (algebraMap R S) 0"}, {"line": "rw [map_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ne_zero_of_mk'_ne_zero {x : R} {y : M} (hxy : IsLocalization.mk' S x y \u2260 0) : x \u2260 0 := by\n  rintro rfl\n  exact hxy (IsLocalization.mk'_zero _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/Defs.lean", "context": {"open": ["Function"], "variables": ["{R : Type*} [CommSemiring R] (M : Submonoid R) (S : Type*) [CommSemiring S]", "[Algebra R S] {P : Type*} [CommSemiring P]", "{M}", "[IsLocalization M S]", "(M) {S}", "(S) in", "(S)", "(M) {S}", "{M}", "(M S)", "{M}", "{S}", "(M)", "(S)", "{M S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ny : \u21a5M\nhxy : IsLocalization.mk' S x y \u2260 0\n\u22a2 x \u2260 0"}, {"line": "rintro rfl", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\ny : \u21a5M\nhxy : IsLocalization.mk' S 0 y \u2260 0\n\u22a2 False"}, {"line": "exact hxy (IsLocalization.mk'_zero _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isDomain_of_le_nonZeroDivisors [Algebra A S] {M : Submonoid A} [IsLocalization M S]\n    (hM : M \u2264 nonZeroDivisors A) : IsDomain S := by\n  apply @NoZeroDivisors.to_isDomain _ _ (id _) (id _)\n  \u00b7 exact\n      \u27e8\u27e8(algebraMap A S) 0, (algebraMap A S) 1, fun h =>\n          zero_ne_one (IsLocalization.injective S hM h)\u27e9\u27e9\n  \u00b7 exact noZeroDivisors M\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/Defs.lean", "context": {"open": ["Function", "IsLocalization"], "variables": ["{R : Type*} [CommSemiring R] (M : Submonoid R) (S : Type*) [CommSemiring S]", "[Algebra R S] {P : Type*} [CommSemiring P]", "{M}", "[IsLocalization M S]", "(M) {S}", "(S) in", "(S)", "(M) {S}", "{M}", "(M S)", "{M}", "{S}", "(M)", "(S)", "{M S}", "(M) in", "(S)", "(M)", "{g : R \u2192+* P} (hg : \u2200 y : M, IsUnit (g y))", "(M)", "{M}", "(M) in", "{T : Submonoid P} {Q : Type*} [CommSemiring Q]", "[Algebra P Q] [IsLocalization T Q]", "(Q)", "(hy : M \u2264 T.comap g)", "(S Q)", "(M S) (Q : Type*) [CommSemiring Q] [Algebra P Q]", "(M)", "(M)", "{R : Type*} [CommRing R] {M : Submonoid R} (S : Type*) [CommRing S]", "[Algebra R S] {P : Type*} [CommRing P]", "{K : Type*} [IsLocalization M S]", "{S}", "{Q : Type*} [CommRing Q] {g : R \u2192+* P} [Algebra P Q]", "(A : Type*) [CommRing A] [IsDomain A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_6\ninst\u271d\u2074 : CommRing S\nA : Type u_10\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : IsDomain A\ninst\u271d\u00b9 : Algebra A S\nM : Submonoid A\ninst\u271d : IsLocalization M S\nhM : M \u2264 nonZeroDivisors A\n\u22a2 IsDomain S"}, {"line": "apply @NoZeroDivisors.to_isDomain _ _ (id _) (id _)", "tactic_state": "S : Type u_6\ninst\u271d\u2074 : CommRing S\nA : Type u_10\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : IsDomain A\ninst\u271d\u00b9 : Algebra A S\nM : Submonoid A\ninst\u271d : IsLocalization M S\nhM : M \u2264 nonZeroDivisors A\n\u22a2 Nontrivial S\n---\nS : Type u_6\ninst\u271d\u2074 : CommRing S\nA : Type u_10\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : IsDomain A\ninst\u271d\u00b9 : Algebra A S\nM : Submonoid A\ninst\u271d : IsLocalization M S\nhM : M \u2264 nonZeroDivisors A\n\u22a2 NoZeroDivisors S"}, {"line": "\u00b7 exact\n      \u27e8\u27e8(algebraMap A S) 0, (algebraMap A S) 1, fun h =>\n          zero_ne_one (IsLocalization.injective S hM h)\u27e9\u27e9", "tactic_state": "S : Type u_6\ninst\u271d\u2074 : CommRing S\nA : Type u_10\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : IsDomain A\ninst\u271d\u00b9 : Algebra A S\nM : Submonoid A\ninst\u271d : IsLocalization M S\nhM : M \u2264 nonZeroDivisors A\n\u22a2 NoZeroDivisors S"}, {"line": "\u00b7 exact noZeroDivisors M", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ringEquivOfRingEquiv_algebraMap\n    (a : A) : ringEquivOfRingEquiv h (algebraMap A K a) = algebraMap B L (h a) := by\n  simp [ringEquivOfRingEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/FractionRing.lean", "context": {"open": ["IsLocalization", "Function"], "variables": ["(R : Type*) [CommRing R] {M : Submonoid R} (S : Type*) [CommRing S]", "[Algebra R S] {P : Type*} [CommRing P]", "{A : Type*} [CommRing A] (K : Type*)", "{R K}", "[CommRing K] [Algebra R K] [IsFractionRing R K] [Algebra A K] [IsFractionRing A K]", "(R K)", "{R K}", "(A) [IsDomain A]", "{B : Type*} [CommRing B] [IsDomain B] [Field K] {L : Type*} [Field L] [Algebra A K]", "(A K) in", "{L : Type*} [Field L] {g : A \u2192+* L} {f : K \u2192+* L}", "[Algebra R A] [Algebra R K] [IsScalarTower R A K] [Algebra R L]", "{A K B L : Type*} [CommRing A] [CommRing B] [CommRing K] [CommRing L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_8\ninst\u271d : CommRing A\nh : Type u_12\na : A\n\u22a2 sorry = sorry"}, {"line": "simp [ringEquivOfRingEquiv]", "tactic_state": "A : Type u_8\ninst\u271d : CommRing A\nh : Type u_12\na : A\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma algEquivOfAlgEquiv_algebraMap\n    (a : A) : algEquivOfAlgEquiv h (algebraMap A K a) = algebraMap B L (h a) := by\n  simp [algEquivOfAlgEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/FractionRing.lean", "context": {"open": ["IsLocalization", "Function"], "variables": ["(R : Type*) [CommRing R] {M : Submonoid R} (S : Type*) [CommRing S]", "[Algebra R S] {P : Type*} [CommRing P]", "{A : Type*} [CommRing A] (K : Type*)", "{R K}", "[CommRing K] [Algebra R K] [IsFractionRing R K] [Algebra A K] [IsFractionRing A K]", "(R K)", "{R K}", "(A) [IsDomain A]", "{B : Type*} [CommRing B] [IsDomain B] [Field K] {L : Type*} [Field L] [Algebra A K]", "(A K) in", "{L : Type*} [Field L] {g : A \u2192+* L} {f : K \u2192+* L}", "[Algebra R A] [Algebra R K] [IsScalarTower R A K] [Algebra R L]", "{A K B L : Type*} [CommRing A] [CommRing B] [CommRing K] [CommRing L]", "{R A K B L : Type*} [CommSemiring R] [CommRing A] [CommRing B] [CommRing K] [CommRing L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_13\ninst\u271d : CommRing A\nh : Type u_17\na : A\n\u22a2 sorry = sorry"}, {"line": "simp [algEquivOfAlgEquiv]", "tactic_state": "A : Type u_13\ninst\u271d : CommRing A\nh : Type u_17\na : A\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem integerNormalization_coeff (p : S[X]) (i : \u2115) :\n    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by\n  simp +contextual [integerNormalization, coeff_monomial,\n    coeffIntegerNormalization_of_not_mem_support]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/Integral.lean", "context": {"open": ["Polynomial", "Polynomial", "scoped Classical in"], "variables": ["{R : Type*} [CommRing R] (M : Submonoid R) {S : Type*} [CommRing S]", "[Algebra R S]", "[IsLocalization M S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_1\nx\u271d\u00b9 : Sort u_2\nintegerNormalization : x\u271d\u00b9\nx\u271d : Sort u_3\ncoeffIntegerNormalization : x\u271d\np : sorry\ni : \u2115\n\u22a2 sorry = sorry"}, {"line": "simp +contextual [integerNormalization, coeff_monomial,\n    coeffIntegerNormalization_of_not_mem_support]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem submonoid_map_le_is_unit : M.map (algebraMap R S) \u2264 IsUnit.submonoid S := by\n  rintro _ \u27e8a, ha, rfl\u27e9\n  exact IsLocalization.map_units S \u27e8_, ha\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/InvSubmonoid.lean", "context": {"open": ["Function"], "variables": ["{R : Type*} [CommRing R] (M : Submonoid R) (S : Type*) [CommRing S]", "[Algebra R S]", "[IsLocalization M S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\n\u22a2 Submonoid.map (algebraMap R S) M \u2264 IsUnit.submonoid S"}, {"line": "rintro _ \u27e8a, ha, rfl\u27e9", "tactic_state": "case intro.intro\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\na : R\nha : a \u2208 \u2191M\n\u22a2 (algebraMap R S) a \u2208 IsUnit.submonoid S"}, {"line": "exact IsLocalization.map_units S \u27e8_, ha\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Algebra.traceMatrix_localizationLocalization (b : Basis \u03b9 R S) :\n    Algebra.traceMatrix R\u2098 (b.localizationLocalization R\u2098 M S\u2098) =\n      (algebraMap R R\u2098).mapMatrix (Algebra.traceMatrix R b) := by\n  have : Module.Finite R S := Module.Finite.of_basis b\n  have : Module.Free R S := Module.Free.of_basis b\n  ext i j : 2\n  simp_rw [RingHom.mapMatrix_apply, Matrix.map_apply, traceMatrix_apply, traceForm_apply,\n    Basis.localizationLocalization_apply, \u2190 map_mul]\n  exact Algebra.trace_localization R M _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/NormTrace.lean", "context": {"open": ["scoped nonZeroDivisors", "Algebra"], "variables": ["(R : Type*) {S : Type*} [CommRing R] [CommRing S] [Algebra R S]", "{R\u2098 S\u2098 : Type*} [CommRing R\u2098] [Algebra R R\u2098] [CommRing S\u2098] [Algebra S S\u2098]", "(M : Submonoid R)", "[IsLocalization M R\u2098] [IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098]", "[Algebra R\u2098 S\u2098] [Algebra R S\u2098] [IsScalarTower R R\u2098 S\u2098] [IsScalarTower R S S\u2098]", "{M} in", "(S\u2098 : Type*) [CommRing S\u2098] [Algebra S S\u2098] [Algebra R\u2098 S\u2098] [Algebra R S\u2098]", "[IsScalarTower R R\u2098 S\u2098] [IsScalarTower R S S\u2098]", "[IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098]", "{\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9\u2077 : CommRing R\ninst\u271d\u00b9\u2076 : CommRing S\ninst\u271d\u00b9\u2075 : Algebra R S\nR\u2098 : Type u_3\nS\u2098 : Type u_4\ninst\u271d\u00b9\u2074 : CommRing R\u2098\ninst\u271d\u00b9\u00b3 : Algebra R R\u2098\ninst\u271d\u00b9\u00b2 : CommRing S\u2098\ninst\u271d\u00b9\u00b9 : Algebra S S\u2098\nM : Submonoid R\ninst\u271d\u00b9\u2070 : IsLocalization M R\u2098\ninst\u271d\u2079 : IsLocalization (algebraMapSubmonoid S M) S\u2098\ninst\u271d\u2078 : Algebra R\u2098 S\u2098\ninst\u271d\u2077 : Algebra R S\u2098\ninst\u271d\u2076 : IsScalarTower R R\u2098 S\u2098\ninst\u271d\u2075 : IsScalarTower R S S\u2098\ninst\u271d\u2074 : IsScalarTower R R\u2098 S\u2098\ninst\u271d\u00b3 : IsScalarTower R S S\u2098\ninst\u271d\u00b2 : IsLocalization (algebraMapSubmonoid S M) S\u2098\n\u03b9 : Type u_5\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nb : Basis \u03b9 R S\n\u22a2 traceMatrix R\u2098 \u21d1(Basis.localizationLocalization R\u2098 M S\u2098 b) = (algebraMap R R\u2098).mapMatrix (traceMatrix R \u21d1b)"}, {"line": "have : Module.Finite R S := Module.Finite.of_basis b", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9\u2077 : CommRing R\ninst\u271d\u00b9\u2076 : CommRing S\ninst\u271d\u00b9\u2075 : Algebra R S\nR\u2098 : Type u_3\nS\u2098 : Type u_4\ninst\u271d\u00b9\u2074 : CommRing R\u2098\ninst\u271d\u00b9\u00b3 : Algebra R R\u2098\ninst\u271d\u00b9\u00b2 : CommRing S\u2098\ninst\u271d\u00b9\u00b9 : Algebra S S\u2098\nM : Submonoid R\ninst\u271d\u00b9\u2070 : IsLocalization M R\u2098\ninst\u271d\u2079 : IsLocalization (algebraMapSubmonoid S M) S\u2098\ninst\u271d\u2078 : Algebra R\u2098 S\u2098\ninst\u271d\u2077 : Algebra R S\u2098\ninst\u271d\u2076 : IsScalarTower R R\u2098 S\u2098\ninst\u271d\u2075 : IsScalarTower R S S\u2098\ninst\u271d\u2074 : IsScalarTower R R\u2098 S\u2098\ninst\u271d\u00b3 : IsScalarTower R S S\u2098\ninst\u271d\u00b2 : IsLocalization (algebraMapSubmonoid S M) S\u2098\n\u03b9 : Type u_5\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nb : Basis \u03b9 R S\nthis : sorry\n\u22a2 traceMatrix R\u2098 \u21d1(Basis.localizationLocalization R\u2098 M S\u2098 b) = (algebraMap R R\u2098).mapMatrix (traceMatrix R \u21d1b)"}, {"line": "have : Module.Free R S := Module.Free.of_basis b", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9\u2077 : CommRing R\ninst\u271d\u00b9\u2076 : CommRing S\ninst\u271d\u00b9\u2075 : Algebra R S\nR\u2098 : Type u_3\nS\u2098 : Type u_4\ninst\u271d\u00b9\u2074 : CommRing R\u2098\ninst\u271d\u00b9\u00b3 : Algebra R R\u2098\ninst\u271d\u00b9\u00b2 : CommRing S\u2098\ninst\u271d\u00b9\u00b9 : Algebra S S\u2098\nM : Submonoid R\ninst\u271d\u00b9\u2070 : IsLocalization M R\u2098\ninst\u271d\u2079 : IsLocalization (algebraMapSubmonoid S M) S\u2098\ninst\u271d\u2078 : Algebra R\u2098 S\u2098\ninst\u271d\u2077 : Algebra R S\u2098\ninst\u271d\u2076 : IsScalarTower R R\u2098 S\u2098\ninst\u271d\u2075 : IsScalarTower R S S\u2098\ninst\u271d\u2074 : IsScalarTower R R\u2098 S\u2098\ninst\u271d\u00b3 : IsScalarTower R S S\u2098\ninst\u271d\u00b2 : IsLocalization (algebraMapSubmonoid S M) S\u2098\n\u03b9 : Type u_5\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nb : Basis \u03b9 R S\nthis\u271d : sorry\nthis : sorry\n\u22a2 traceMatrix R\u2098 \u21d1(Basis.localizationLocalization R\u2098 M S\u2098 b) = (algebraMap R R\u2098).mapMatrix (traceMatrix R \u21d1b)"}, {"line": "ext i j : 2", "tactic_state": "case a\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9\u2077 : CommRing R\ninst\u271d\u00b9\u2076 : CommRing S\ninst\u271d\u00b9\u2075 : Algebra R S\nR\u2098 : Type u_3\nS\u2098 : Type u_4\ninst\u271d\u00b9\u2074 : CommRing R\u2098\ninst\u271d\u00b9\u00b3 : Algebra R R\u2098\ninst\u271d\u00b9\u00b2 : CommRing S\u2098\ninst\u271d\u00b9\u00b9 : Algebra S S\u2098\nM : Submonoid R\ninst\u271d\u00b9\u2070 : IsLocalization M R\u2098\ninst\u271d\u2079 : IsLocalization (algebraMapSubmonoid S M) S\u2098\ninst\u271d\u2078 : Algebra R\u2098 S\u2098\ninst\u271d\u2077 : Algebra R S\u2098\ninst\u271d\u2076 : IsScalarTower R R\u2098 S\u2098\ninst\u271d\u2075 : IsScalarTower R S S\u2098\ninst\u271d\u2074 : IsScalarTower R R\u2098 S\u2098\ninst\u271d\u00b3 : IsScalarTower R S S\u2098\ninst\u271d\u00b2 : IsLocalization (algebraMapSubmonoid S M) S\u2098\n\u03b9 : Type u_5\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nb : Basis \u03b9 R S\nthis\u271d : sorry\nthis : sorry\ni j : \u03b9\n\u22a2 traceMatrix R\u2098 (\u21d1(Basis.localizationLocalization R\u2098 M S\u2098 b)) i j = (algebraMap R R\u2098).mapMatrix (traceMatrix R \u21d1b) i j"}, {"line": "simp_rw [RingHom.mapMatrix_apply, Matrix.map_apply, traceMatrix_apply, traceForm_apply,\n    Basis.localizationLocalization_apply, \u2190 map_mul]", "tactic_state": "case a\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9\u2077 : CommRing R\ninst\u271d\u00b9\u2076 : CommRing S\ninst\u271d\u00b9\u2075 : Algebra R S\nR\u2098 : Type u_3\nS\u2098 : Type u_4\ninst\u271d\u00b9\u2074 : CommRing R\u2098\ninst\u271d\u00b9\u00b3 : Algebra R R\u2098\ninst\u271d\u00b9\u00b2 : CommRing S\u2098\ninst\u271d\u00b9\u00b9 : Algebra S S\u2098\nM : Submonoid R\ninst\u271d\u00b9\u2070 : IsLocalization M R\u2098\ninst\u271d\u2079 : IsLocalization (algebraMapSubmonoid S M) S\u2098\ninst\u271d\u2078 : Algebra R\u2098 S\u2098\ninst\u271d\u2077 : Algebra R S\u2098\ninst\u271d\u2076 : IsScalarTower R R\u2098 S\u2098\ninst\u271d\u2075 : IsScalarTower R S S\u2098\ninst\u271d\u2074 : IsScalarTower R R\u2098 S\u2098\ninst\u271d\u00b3 : IsScalarTower R S S\u2098\ninst\u271d\u00b2 : IsLocalization (algebraMapSubmonoid S M) S\u2098\n\u03b9 : Type u_5\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nb : Basis \u03b9 R S\nthis\u271d : sorry\nthis : sorry\ni j : \u03b9\n\u22a2 (trace R\u2098 S\u2098) ((algebraMap S S\u2098) (b i * b j)) = (algebraMap R R\u2098) ((trace R S) (b i * b j))"}, {"line": "exact Algebra.trace_localization R M _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sec_spec (s : S) : s * (algebraMap R S) (x ^ (IsLocalization.Away.sec x s).2) =\n    algebraMap R S (IsLocalization.Away.sec x s).1 := by\n  simp only [IsLocalization.Away.sec]\n  simp only [\u2190 IsLocalization.sec_spec]\n  congr\n  exact (IsLocalization.sec (Submonoid.powers x) s).2.property.choose_spec\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/Away/Basic.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] (M : Submonoid R) {S : Type*} [CommSemiring S]", "[Algebra R S] {P : Type*} [CommSemiring P]", "(x : R)", "[IsLocalization.Away x S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\nx : R\ninst\u271d : IsLocalization.Away x S\ns : S\n\u22a2 s * (algebraMap R S) (x ^ (IsLocalization.Away.sec x s).2) = (algebraMap R S) (IsLocalization.Away.sec x s).1"}, {"line": "simp only [IsLocalization.Away.sec]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\nx : R\ninst\u271d : IsLocalization.Away x S\ns : S\n\u22a2 s * (algebraMap R S) (x ^ Exists.choose \u22ef) = (algebraMap R S) (IsLocalization.sec (Submonoid.powers x) s).1"}, {"line": "simp only [\u2190 IsLocalization.sec_spec]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\nx : R\ninst\u271d : IsLocalization.Away x S\ns : S\n\u22a2 s * (algebraMap R S) (x ^ Exists.choose \u22ef) = s * (algebraMap R S) \u2191(IsLocalization.sec (Submonoid.powers x) s).2"}, {"line": "congr", "tactic_state": "case e_a.h.e_6.h\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\nx : R\ninst\u271d : IsLocalization.Away x S\ns : S\n\u22a2 x ^ Exists.choose \u22ef = \u2191(IsLocalization.sec (Submonoid.powers x) s).2"}, {"line": "exact (IsLocalization.sec (Submonoid.powers x) s).2.property.choose_spec", "tactic_state": "No Goals!"}]}
{"declaration": "lemma awayLift_mk {A : Type*} [CommSemiring A] (f : R \u2192+* A) (r : R)\n    (a : R) (v : A) (hv : f r * v = 1) (j : \u2115) :\n    Localization.awayLift f r (isUnit_iff_exists_inv.mpr \u27e8v, hv\u27e9)\n      (Localization.mk a \u27e8r ^ j, j, rfl\u27e9) = f a * v ^ j := by\n  simp [Localization.mk_eq_mk', awayLift, Away.lift, IsLocalization.lift_mk',\n    Units.mul_inv_eq_iff_eq_mul, IsUnit.liftRight, mul_assoc, \u2190 mul_pow, (mul_comm _ _).trans hv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/Away/Basic.lean", "context": {"open": ["IsLocalization"], "variables": ["{R : Type*} [CommSemiring R] (M : Submonoid R) {S : Type*} [CommSemiring S]", "[Algebra R S] {P : Type*} [CommSemiring P]", "(x : R)", "[IsLocalization.Away x S]", "{g : R \u2192+* P}", "(S) (Q : Type*) [CommSemiring Q] [Algebra P Q]", "{A : Type*} [CommSemiring A] [Algebra R A]", "{B : Type*} [CommSemiring B] [Algebra R B]", "(A\u209a : Type*) [CommSemiring A\u209a] [Algebra A A\u209a] [Algebra R A\u209a] [IsScalarTower R A A\u209a]", "(B\u209a : Type*) [CommSemiring B\u209a] [Algebra B B\u209a] [Algebra R B\u209a] [IsScalarTower R B B\u209a]", "{A\u209a} {B\u209a}", "[IsLocalization M S]", "(R) (S)", "{M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\nA : Type u_9\ninst\u271d : CommSemiring A\nf : R \u2192+* A\nr a : R\nv : A\nhv : f r * v = 1\nj : \u2115\n\u22a2 (Localization.awayLift f r \u22ef) (Localization.mk a \u27e8r ^ j, \u22ef\u27e9) = f a * v ^ j"}, {"line": "simp [Localization.mk_eq_mk', awayLift, Away.lift, IsLocalization.lift_mk',\n    Units.mul_inv_eq_iff_eq_mul, IsUnit.liftRight, mul_assoc, \u2190 mul_pow, (mul_comm _ _).trans hv]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\nA : Type u_9\ninst\u271d : CommSemiring A\nf : R \u2192+* A\nr a : R\nv : A\nhv : f r * v = 1\nj : \u2115\n\u22a2 f a = f a * v ^ j * f (r ^ j)"}]}
{"declaration": "theorem selfZPow_zero : selfZPow x B 0 = 1 := by\n  simp [selfZPow_of_nonneg _ _ le_rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/Away/Basic.lean", "context": {"open": ["IsLocalization", "Localization", "IsLocalization"], "variables": ["{R : Type*} [CommSemiring R] (M : Submonoid R) {S : Type*} [CommSemiring S]", "[Algebra R S] {P : Type*} [CommSemiring P]", "(x : R)", "[IsLocalization.Away x S]", "{g : R \u2192+* P}", "(S) (Q : Type*) [CommSemiring Q] [Algebra P Q]", "{A : Type*} [CommSemiring A] [Algebra R A]", "{B : Type*} [CommSemiring B] [Algebra R B]", "(A\u209a : Type*) [CommSemiring A\u209a] [Algebra A A\u209a] [Algebra R A\u209a] [IsScalarTower R A A\u209a]", "(B\u209a : Type*) [CommSemiring B\u209a] [Algebra B B\u209a] [Algebra R B\u209a] [IsScalarTower R B B\u209a]", "{A\u209a} {B\u209a}", "[IsLocalization M S]", "(R) (S)", "{M}", "{A : Type*} [CommSemiring A] [Algebra R A]", "{B : Type*} [CommSemiring B] [Algebra R B]", "{R : Type*} [CommSemiring R]", "(x : R)", "(B : Type*) [CommSemiring B] [Algebra R B] [IsLocalization.Away x B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_11\ninst\u271d\u00b3 : CommSemiring R\nx : R\nB : Type u_12\ninst\u271d\u00b2 : CommSemiring B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsLocalization.Away x B\n\u22a2 selfZPow x B 0 = 1"}, {"line": "simp [selfZPow_of_nonneg _ _ le_rfl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem selfZPow_of_nonpos {n : \u2124} (hn : n \u2264 0) :\n    selfZPow x B n = mk' _ (1 : R) (Submonoid.pow x n.natAbs) := by\n  by_cases hn0 : n = 0\n  \u00b7 simp [hn0, selfZPow_zero, Submonoid.pow_apply]\n  \u00b7 simp [selfZPow_of_neg _ _ (lt_of_le_of_ne hn hn0)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/Away/Basic.lean", "context": {"open": ["IsLocalization", "Localization", "IsLocalization"], "variables": ["{R : Type*} [CommSemiring R] (M : Submonoid R) {S : Type*} [CommSemiring S]", "[Algebra R S] {P : Type*} [CommSemiring P]", "(x : R)", "[IsLocalization.Away x S]", "{g : R \u2192+* P}", "(S) (Q : Type*) [CommSemiring Q] [Algebra P Q]", "{A : Type*} [CommSemiring A] [Algebra R A]", "{B : Type*} [CommSemiring B] [Algebra R B]", "(A\u209a : Type*) [CommSemiring A\u209a] [Algebra A A\u209a] [Algebra R A\u209a] [IsScalarTower R A A\u209a]", "(B\u209a : Type*) [CommSemiring B\u209a] [Algebra B B\u209a] [Algebra R B\u209a] [IsScalarTower R B B\u209a]", "{A\u209a} {B\u209a}", "[IsLocalization M S]", "(R) (S)", "{M}", "{A : Type*} [CommSemiring A] [Algebra R A]", "{B : Type*} [CommSemiring B] [Algebra R B]", "{R : Type*} [CommSemiring R]", "(x : R)", "(B : Type*) [CommSemiring B] [Algebra R B] [IsLocalization.Away x B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_11\ninst\u271d\u00b3 : CommSemiring R\nx : R\nB : Type u_12\ninst\u271d\u00b2 : CommSemiring B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsLocalization.Away x B\nn : \u2124\nhn : n \u2264 0\n\u22a2 selfZPow x B n = mk' B 1 (Submonoid.pow x n.natAbs)"}, {"line": "by_cases hn0 : n = 0", "tactic_state": "case pos\nR : Type u_11\ninst\u271d\u00b3 : CommSemiring R\nx : R\nB : Type u_12\ninst\u271d\u00b2 : CommSemiring B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsLocalization.Away x B\nn : \u2124\nhn : n \u2264 0\nhn0 : n = 0\n\u22a2 selfZPow x B n = mk' B 1 (Submonoid.pow x n.natAbs)\n---\ncase neg\nR : Type u_11\ninst\u271d\u00b3 : CommSemiring R\nx : R\nB : Type u_12\ninst\u271d\u00b2 : CommSemiring B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsLocalization.Away x B\nn : \u2124\nhn : n \u2264 0\nhn0 : \u00acn = 0\n\u22a2 selfZPow x B n = mk' B 1 (Submonoid.pow x n.natAbs)"}, {"line": "\u00b7 simp [hn0, selfZPow_zero, Submonoid.pow_apply]", "tactic_state": "case neg\nR : Type u_11\ninst\u271d\u00b3 : CommSemiring R\nx : R\nB : Type u_12\ninst\u271d\u00b2 : CommSemiring B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsLocalization.Away x B\nn : \u2124\nhn : n \u2264 0\nhn0 : \u00acn = 0\n\u22a2 selfZPow x B n = mk' B 1 (Submonoid.pow x n.natAbs)"}, {"line": "\u00b7 simp [selfZPow_of_neg _ _ (lt_of_le_of_ne hn hn0)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem selfZPow_neg_natCast (d : \u2115) : selfZPow x B (-d) = mk' _ (1 : R) (Submonoid.pow x d) := by\n  simp [selfZPow_of_nonpos _ _ (neg_nonpos.mpr (Int.natCast_nonneg d))]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Localization/Away/Basic.lean", "context": {"open": ["IsLocalization", "Localization", "IsLocalization"], "variables": ["{R : Type*} [CommSemiring R] (M : Submonoid R) {S : Type*} [CommSemiring S]", "[Algebra R S] {P : Type*} [CommSemiring P]", "(x : R)", "[IsLocalization.Away x S]", "{g : R \u2192+* P}", "(S) (Q : Type*) [CommSemiring Q] [Algebra P Q]", "{A : Type*} [CommSemiring A] [Algebra R A]", "{B : Type*} [CommSemiring B] [Algebra R B]", "(A\u209a : Type*) [CommSemiring A\u209a] [Algebra A A\u209a] [Algebra R A\u209a] [IsScalarTower R A A\u209a]", "(B\u209a : Type*) [CommSemiring B\u209a] [Algebra B B\u209a] [Algebra R B\u209a] [IsScalarTower R B B\u209a]", "{A\u209a} {B\u209a}", "[IsLocalization M S]", "(R) (S)", "{M}", "{A : Type*} [CommSemiring A] [Algebra R A]", "{B : Type*} [CommSemiring B] [Algebra R B]", "{R : Type*} [CommSemiring R]", "(x : R)", "(B : Type*) [CommSemiring B] [Algebra R B] [IsLocalization.Away x B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_11\ninst\u271d\u00b3 : CommSemiring R\nx : R\nB : Type u_12\ninst\u271d\u00b2 : CommSemiring B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsLocalization.Away x B\nd : \u2115\n\u22a2 selfZPow x B (-\u2191d) = mk' B 1 (Submonoid.pow x d)"}, {"line": "simp [selfZPow_of_nonpos _ _ (neg_nonpos.mpr (Int.natCast_nonneg d))]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isHomogeneous_monomial {d : \u03c3 \u2192\u2080 \u2115} (r : R) {n : \u2115} (hn : d.degree = n) :\n    IsHomogeneous (monomial d r) n := by\n  rw [degree_eq_weight_one] at hn\n  exact isWeightedHomogeneous_monomial 1 d r hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Homogeneous.lean", "context": {"open": ["Finsupp"], "variables": ["{\u03c3 : Type*} {\u03c4 : Type*} {R : Type*} {S : Type*}", "[CommSemiring R]", "(\u03c3 R)", "{\u03c3 R}", "(\u03c3 R)", "{\u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : CommSemiring R\nx\u271d : Sort u_5\nIsHomogeneous : x\u271d\nd : \u03c3 \u2192\u2080 \u2115\nr : R\nn : \u2115\nhn : d.degree = n\n\u22a2 sorry"}, {"line": "rw [degree_eq_weight_one] at hn", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : CommSemiring R\nx\u271d : Sort u_5\nIsHomogeneous : x\u271d\nd : \u03c3 \u2192\u2080 \u2115\nr : R\nn : \u2115\nhn : (weight fun x => 1) d = n\n\u22a2 sorry"}, {"line": "exact isWeightedHomogeneous_monomial 1 d r hn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_eq_zero (h\u03c6 : IsHomogeneous \u03c6 n) {d : \u03c3 \u2192\u2080 \u2115} (hd : d.degree \u2260 n) :\n    coeff d \u03c6 = 0 := by\n  rw [degree_eq_weight_one] at hd\n  exact IsWeightedHomogeneous.coeff_eq_zero h\u03c6 d hd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Homogeneous.lean", "context": {"open": ["Finsupp"], "variables": ["{\u03c3 : Type*} {\u03c4 : Type*} {R : Type*} {S : Type*}", "[CommSemiring R]", "(\u03c3 R)", "{\u03c3 R}", "(\u03c3 R)", "{\u03c3 R}", "(\u03c3)", "(R)", "{\u03c3}", "[CommSemiring S] {\u03c6 \u03c8 : MvPolynomial \u03c3 R} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nn : \u2115\nx\u271d\u00b9 : Sort u_5\nIsHomogeneous : x\u271d\u00b9\nx\u271d : Sort u_6\ncoeff : x\u271d\nh\u03c6 : sorry\nd : \u03c3 \u2192\u2080 \u2115\nhd : d.degree \u2260 n\n\u22a2 sorry = 0"}, {"line": "rw [degree_eq_weight_one] at hd", "tactic_state": "\u03c3 : Type u_1\nn : \u2115\nx\u271d\u00b9 : Sort u_5\nIsHomogeneous : x\u271d\u00b9\nx\u271d : Sort u_6\ncoeff : x\u271d\nh\u03c6 : sorry\nd : \u03c3 \u2192\u2080 \u2115\nhd : (weight fun x => 1) d \u2260 n\n\u22a2 sorry = 0"}, {"line": "exact IsWeightedHomogeneous.coeff_eq_zero h\u03c6 d hd", "tactic_state": "No Goals!"}]}
{"declaration": "lemma C_mul (h\u03c6 : \u03c6.IsHomogeneous m) (r : R) :\n    (C r * \u03c6).IsHomogeneous m := by\n  simpa only [zero_add] using (isHomogeneous_C _ _).mul h\u03c6\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Homogeneous.lean", "context": {"open": ["Finsupp"], "variables": ["{\u03c3 : Type*} {\u03c4 : Type*} {R : Type*} {S : Type*}", "[CommSemiring R]", "(\u03c3 R)", "{\u03c3 R}", "(\u03c3 R)", "{\u03c3 R}", "(\u03c3)", "(R)", "{\u03c3}", "[CommSemiring S] {\u03c6 \u03c8 : MvPolynomial \u03c3 R} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : CommSemiring R\n\u03c6 : MvPolynomial \u03c3 R\nm : \u2115\nx\u271d : Sort u_5\nC : x\u271d\nh\u03c6 : \u03c6.IsHomogeneous m\nr : R\n\u22a2 (sorry * \u03c6).IsHomogeneous m"}, {"line": "simpa only [zero_add] using (isHomogeneous_C _ _).mul h\u03c6", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.MvPolynomial.isHomogeneous_X_pow (i : \u03c3) (n : \u2115) :\n    (X (R := R) i ^ n).IsHomogeneous n := by\n  simpa only [one_mul] using (isHomogeneous_X _ _).pow n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Homogeneous.lean", "context": {"open": ["Finsupp"], "variables": ["{\u03c3 : Type*} {\u03c4 : Type*} {R : Type*} {S : Type*}", "[CommSemiring R]", "(\u03c3 R)", "{\u03c3 R}", "(\u03c3 R)", "{\u03c3 R}", "(\u03c3)", "(R)", "{\u03c3}", "[CommSemiring S] {\u03c6 \u03c8 : MvPolynomial \u03c3 R} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nx\u271d : Sort u_5\nX : x\u271d\ni : \u03c3\nn : \u2115\n\u22a2 sorry"}, {"line": "simpa only [one_mul] using (isHomogeneous_X _ _).pow n", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map (h\u03c6 : \u03c6.IsHomogeneous n) (f : R \u2192+* S) : (map f \u03c6).IsHomogeneous n := by\n  simpa only [one_mul] using h\u03c6.eval\u2082 _ _ (fun r \u21a6 isHomogeneous_C _ (f r)) (isHomogeneous_X _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Homogeneous.lean", "context": {"open": ["Finsupp"], "variables": ["{\u03c3 : Type*} {\u03c4 : Type*} {R : Type*} {S : Type*}", "[CommSemiring R]", "(\u03c3 R)", "{\u03c3 R}", "(\u03c3 R)", "{\u03c3 R}", "(\u03c3)", "(R)", "{\u03c3}", "[CommSemiring S] {\u03c6 \u03c8 : MvPolynomial \u03c3 R} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\n\u03c6 : MvPolynomial \u03c3 R\nn : \u2115\nh\u03c6 : \u03c6.IsHomogeneous n\nf : R \u2192+* S\n\u22a2 sorry"}, {"line": "simpa only [one_mul] using h\u03c6.eval\u2082 _ _ (fun r \u21a6 isHomogeneous_C _ (f r)) (isHomogeneous_X _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_homogeneousComponent (d : \u03c3 \u2192\u2080 \u2115) :\n    coeff d (homogeneousComponent n \u03c6) = if d.degree = n then coeff d \u03c6 else 0 := by\n  rw [degree_eq_weight_one]\n  convert coeff_weightedHomogeneousComponent n \u03c6 d\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Homogeneous.lean", "context": {"open": ["Finsupp", "Polynomial in", "Cardinal Polynomial", "Finset", "Finset Finsupp"], "variables": ["{\u03c3 : Type*} {\u03c4 : Type*} {R : Type*} {S : Type*}", "[CommSemiring R]", "(\u03c3 R)", "{\u03c3 R}", "(\u03c3 R)", "{\u03c3 R}", "(\u03c3)", "(R)", "{\u03c3}", "[CommSemiring S] {\u03c6 \u03c8 : MvPolynomial \u03c3 R} {m n : \u2115}", "{R \u03c3 : Type*} [CommRing R] {\u03c6 \u03c8 : MvPolynomial \u03c3 R} {n : \u2115}", "{R \u03c3 : Type*} [CommRing R] [IsDomain R] {F G : MvPolynomial \u03c3 R} {n : \u2115}", "(n : \u2115) (\u03c6 \u03c8 : MvPolynomial \u03c3 R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_8\nn : \u2115\nx\u271d : Sort u_9\ncoeff : x\u271d\nd : \u03c3 \u2192\u2080 \u2115\n\u22a2 sorry = if d.degree = n then sorry else 0"}, {"line": "rw [degree_eq_weight_one]", "tactic_state": "\u03c3 : Type u_8\nn : \u2115\nx\u271d : Sort u_9\ncoeff : x\u271d\nd : \u03c3 \u2192\u2080 \u2115\n\u22a2 sorry = if (weight fun x => 1) d = n then sorry else 0"}, {"line": "convert coeff_weightedHomogeneousComponent n \u03c6 d", "tactic_state": "No Goals!"}]}
{"declaration": "theorem homogeneousComponent_eq_zero'\n    (h : \u2200 d : \u03c3 \u2192\u2080 \u2115, d \u2208 \u03c6.support \u2192 d.degree \u2260 n) :\n    homogeneousComponent n \u03c6 = 0 := by\n  simp_rw [degree_eq_weight_one] at h\n  exact weightedHomogeneousComponent_eq_zero' n \u03c6 h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Homogeneous.lean", "context": {"open": ["Finsupp", "Polynomial in", "Cardinal Polynomial", "Finset", "Finset Finsupp"], "variables": ["{\u03c3 : Type*} {\u03c4 : Type*} {R : Type*} {S : Type*}", "[CommSemiring R]", "(\u03c3 R)", "{\u03c3 R}", "(\u03c3 R)", "{\u03c3 R}", "(\u03c3)", "(R)", "{\u03c3}", "[CommSemiring S] {\u03c6 \u03c8 : MvPolynomial \u03c3 R} {m n : \u2115}", "{R \u03c3 : Type*} [CommRing R] {\u03c6 \u03c8 : MvPolynomial \u03c3 R} {n : \u2115}", "{R \u03c3 : Type*} [CommRing R] [IsDomain R] {F G : MvPolynomial \u03c3 R} {n : \u2115}", "(n : \u2115) (\u03c6 \u03c8 : MvPolynomial \u03c3 R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_7\n\u03c3 : Type u_8\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nn : \u2115\n\u03c6 : MvPolynomial \u03c3 R\nx\u271d : Sort u_9\nhomogeneousComponent : x\u271d\nh : \u2200 d \u2208 \u03c6.support, d.degree \u2260 n\n\u22a2 sorry = 0"}, {"line": "simp_rw [degree_eq_weight_one] at h", "tactic_state": "R : Type u_7\n\u03c3 : Type u_8\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nn : \u2115\n\u03c6 : MvPolynomial \u03c3 R\nx\u271d : Sort u_9\nhomogeneousComponent : x\u271d\nh : \u2200 d \u2208 \u03c6.support, (weight fun x => 1) d \u2260 n\n\u22a2 sorry = 0"}, {"line": "exact weightedHomogeneousComponent_eq_zero' n \u03c6 h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mvPolynomial_aeval_coe (S : Subalgebra R A) (x : \u03c3 \u2192 S) (p : MvPolynomial \u03c3 R) :\n    aeval (fun i => (x i : A)) p = aeval x p := by convert aeval_algebraMap_apply A x p\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Tower.lean", "context": {"open": ["MvPolynomial"], "variables": ["(R A B : Type*) {\u03c3 : Type*}", "[CommSemiring R] [CommSemiring A] [CommSemiring B]", "[Algebra R A] [Algebra A B] [Algebra R B]", "[IsScalarTower R A B]", "{R B}", "[CommSemiring R] [CommSemiring A] [CommSemiring B]", "[Algebra R A] [Algebra A B] [Algebra R B] [IsScalarTower R A B]", "{R A}", "{R A} [CommSemiring R] [CommSemiring A] [Algebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nA : Type u_2\n\u03c3 : Type u_4\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : CommSemiring A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring A\ninst\u271d : Algebra R A\nS : Subalgebra R A\nx : \u03c3 \u2192 \u21a5S\np : MvPolynomial \u03c3 R\n\u22a2 (aeval fun i => \u2191(x i)) p = \u2191((aeval x) p)"}, {"line": "convert aeval_algebraMap_apply A x p", "tactic_state": "case convert_4\nR : Type u_1\nA : Type u_2\n\u03c3 : Type u_4\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : CommSemiring A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring A\ninst\u271d : Algebra R A\nS : Subalgebra R A\nx : \u03c3 \u2192 \u21a5S\np : MvPolynomial \u03c3 R\n\u22a2 IsScalarTower R (\u21a5S) A"}]}
{"declaration": "theorem degree_zero : m.degree (0 : MvPolynomial \u03c3 R) = 0 := by\n  simp [degree]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/MonomialOrder.lean", "context": {"open": ["MvPolynomial", "scoped MonomialOrder"], "variables": ["{\u03c3 : Type*} {m : MonomialOrder \u03c3}", "{R : Type*} [CommSemiring R]", "(m) in", "(m) in", "(m) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nm : MonomialOrder \u03c3\nR : Type u_2\ninst\u271d : CommSemiring R\n\u22a2 m.degree 0 = 0"}, {"line": "simp [degree]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leadingCoeff_zero : m.leadingCoeff (0 : MvPolynomial \u03c3 R) = 0 := by\n  simp [degree, leadingCoeff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/MonomialOrder.lean", "context": {"open": ["MvPolynomial", "scoped MonomialOrder"], "variables": ["{\u03c3 : Type*} {m : MonomialOrder \u03c3}", "{R : Type*} [CommSemiring R]", "(m) in", "(m) in", "(m) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nm : MonomialOrder \u03c3\nR : Type u_2\ninst\u271d : CommSemiring R\n\u22a2 m.leadingCoeff 0 = 0"}, {"line": "simp [degree, leadingCoeff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_eq_zero_of_lt {f : MvPolynomial \u03c3 R} {d : \u03c3 \u2192\u2080 \u2115} (hd : m.degree f \u227a[m] d) :\n    f.coeff d = 0 := by\n  rw [\u2190 not_le] at hd\n  by_contra hf\n  apply hd (m.le_degree (mem_support_iff.mpr hf))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/MonomialOrder.lean", "context": {"open": ["MvPolynomial", "scoped MonomialOrder"], "variables": ["{\u03c3 : Type*} {m : MonomialOrder \u03c3}", "{R : Type*} [CommSemiring R]", "(m) in", "(m) in", "(m) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nm : MonomialOrder \u03c3\nR : Type u_2\ninst\u271d : CommSemiring R\nf : MvPolynomial \u03c3 R\nd : \u03c3 \u2192\u2080 \u2115\nhd : m.toSyn (m.degree f) < m.toSyn d\n\u22a2 coeff d f = 0"}, {"line": "rw [\u2190 not_le] at hd", "tactic_state": "\u03c3 : Type u_1\nm : MonomialOrder \u03c3\nR : Type u_2\ninst\u271d : CommSemiring R\nf : MvPolynomial \u03c3 R\nd : \u03c3 \u2192\u2080 \u2115\nhd : \u00acm.toSyn d \u2264 m.toSyn (m.degree f)\n\u22a2 coeff d f = 0"}, {"line": "by_contra hf", "tactic_state": "\u03c3 : Type u_1\nm : MonomialOrder \u03c3\nR : Type u_2\ninst\u271d : CommSemiring R\nf : MvPolynomial \u03c3 R\nd : \u03c3 \u2192\u2080 \u2115\nhd : \u00acm.toSyn d \u2264 m.toSyn (m.degree f)\nhf : \u00accoeff d f = 0\n\u22a2 False"}, {"line": "apply hd (m.le_degree (mem_support_iff.mpr hf))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma monic_X_sub_C {\u03b9 : Type*} (m : MonomialOrder \u03b9) (i : \u03b9) (r : R) :\n    m.Monic (X i - C r) := by\n  rw [sub_eq_add_neg]\n  rw [\u2190 map_neg]\n  apply monic_X_add_C\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/MonomialOrder.lean", "context": {"open": ["MvPolynomial", "scoped MonomialOrder", "Finsupp MvPolynomial"], "variables": ["{\u03c3 : Type*} {m : MonomialOrder \u03c3}", "{R : Type*} [CommSemiring R]", "(m) in", "(m) in", "(m) in", "{R : Type*} [CommRing R]", "{R : Type*} [Field R]", "{R : Type*} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d : CommRing R\n\u03b9 : Type u_5\nm : MonomialOrder \u03b9\ni : \u03b9\nr : R\n\u22a2 m.Monic (X i - C r)"}, {"line": "rw [sub_eq_add_neg]", "tactic_state": "R : Type u_4\ninst\u271d : CommRing R\n\u03b9 : Type u_5\nm : MonomialOrder \u03b9\ni : \u03b9\nr : R\n\u22a2 m.Monic (X i + -C r)"}, {"line": "rw [\u2190 map_neg]", "tactic_state": "R : Type u_4\ninst\u271d : CommRing R\n\u03b9 : Type u_5\nm : MonomialOrder \u03b9\ni : \u03b9\nr : R\n\u22a2 m.Monic (X i + C (-r))\n---\nR : Type u_4\ninst\u271d : CommRing R\n\u03b9 : Type u_5\nm : MonomialOrder \u03b9\ni : \u03b9\nr : R\n\u22a2 AddGroup R\n---\nR : Type u_4\ninst\u271d : CommRing R\n\u03b9 : Type u_5\nm : MonomialOrder \u03b9\ni : \u03b9\nr : R\n\u22a2 AddMonoidHomClass (R \u2192+* MvPolynomial \u03b9 R) R (MvPolynomial \u03b9 R)"}, {"line": "apply monic_X_add_C", "tactic_state": "R : Type u_4\ninst\u271d : CommRing R\n\u03b9 : Type u_5\nm : MonomialOrder \u03b9\ni : \u03b9\nr : R\n\u22a2 AddGroup R\n---\nR : Type u_4\ninst\u271d : CommRing R\n\u03b9 : Type u_5\nm : MonomialOrder \u03b9\ni : \u03b9\nr : R\n\u22a2 AddGroup R\n---\nR : Type u_4\ninst\u271d : CommRing R\n\u03b9 : Type u_5\nm : MonomialOrder \u03b9\ni : \u03b9\nr : R\n\u22a2 AddMonoidHomClass (R \u2192+* MvPolynomial \u03b9 R) R (MvPolynomial \u03b9 R)"}]}
{"declaration": "theorem weightedDegree_eq_zero_iff [CanonicallyOrderedAdd M]\n    (hw : NonTorsionWeight w) {m : \u03c3 \u2192\u2080 \u2115} :\n    weight w m = 0 \u2194 \u2200 x : \u03c3, m x = 0 := by\n  simp only [weight]\n  simp only [Finsupp.linearCombination]\n  simp only [LinearMap.toAddMonoidHom_coe]\n  simp only [coe_lsum]\n  simp only [LinearMap.coe_smulRight]\n  simp only [LinearMap.id_coe]\n  simp only [id_eq]\n  rw [Finsupp.sum]\n  rw [Finset.sum_eq_zero_iff]\n  apply forall_congr'\n  intro x\n  rw [Finsupp.mem_support_iff]\n  constructor\n  \u00b7 intro hx\n    by_contra hx'\n    exact absurd (hw _ _ (hx hx')) hx'\n  \u00b7 intro hax _\n    simp only [hax]\n    simp only [zero_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean", "context": {"open": ["Set Function Finset Finsupp AddMonoidAlgebra", "DirectSum"], "variables": ["{R M : Type*} [CommSemiring R]", "{\u03c3 : Type*}", "[AddCommMonoid M]", "[SemilatticeSup M]", "[OrderBot M]", "(R)", "{R}", "(R)", "{R}", "{\u03c6 \u03c8 : MvPolynomial \u03c3 R} {m n : M}", "{R}", "{w : \u03c3 \u2192 M} (n : M) (\u03c6 \u03c8 : MvPolynomial \u03c3 R)", "(w)", "{w}", "(R w)", "[AddCommMonoid M] [PartialOrder M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 (weight w) m = 0 \u2194 \u2200 (x : \u03c3), m x = 0"}, {"line": "simp only [weight]", "tactic_state": "M : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 (linearCombination \u2115 w).toAddMonoidHom m = 0 \u2194 \u2200 (x : \u03c3), m x = 0"}, {"line": "simp only [Finsupp.linearCombination]", "tactic_state": "M : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 ((lsum \u2115) fun i => LinearMap.id.smulRight (w i)).toAddMonoidHom m = 0 \u2194 \u2200 (x : \u03c3), m x = 0"}, {"line": "simp only [LinearMap.toAddMonoidHom_coe]", "tactic_state": "M : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 ((lsum \u2115) fun i => LinearMap.id.smulRight (w i)) m = 0 \u2194 \u2200 (x : \u03c3), m x = 0"}, {"line": "simp only [coe_lsum]", "tactic_state": "M : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 (m.sum fun i => \u21d1(LinearMap.id.smulRight (w i))) = 0 \u2194 \u2200 (x : \u03c3), m x = 0"}, {"line": "simp only [LinearMap.coe_smulRight]", "tactic_state": "M : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 (m.sum fun i c => LinearMap.id c \u2022 w i) = 0 \u2194 \u2200 (x : \u03c3), m x = 0"}, {"line": "simp only [LinearMap.id_coe]", "tactic_state": "M : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 (m.sum fun i c => id c \u2022 w i) = 0 \u2194 \u2200 (x : \u03c3), m x = 0"}, {"line": "simp only [id_eq]", "tactic_state": "M : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 (m.sum fun i c => c \u2022 w i) = 0 \u2194 \u2200 (x : \u03c3), m x = 0"}, {"line": "rw [Finsupp.sum]", "tactic_state": "M : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 \u2211 a \u2208 m.support, m a \u2022 w a = 0 \u2194 \u2200 (x : \u03c3), m x = 0"}, {"line": "rw [Finset.sum_eq_zero_iff]", "tactic_state": "M : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 (\u2200 i \u2208 m.support, m i \u2022 w i = 0) \u2194 \u2200 (x : \u03c3), m x = 0\n---\nM : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 Subsingleton (AddUnits M)"}, {"line": "apply forall_congr'", "tactic_state": "case h\nM : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 \u2200 (a : \u03c3), a \u2208 m.support \u2192 m a \u2022 w a = 0 \u2194 m a = 0\n---\nM : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 Subsingleton (AddUnits M)"}, {"line": "intro x", "tactic_state": "case h\nM : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\nx : \u03c3\n\u22a2 x \u2208 m.support \u2192 m x \u2022 w x = 0 \u2194 m x = 0\n---\nM : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 Subsingleton (AddUnits M)"}, {"line": "rw [Finsupp.mem_support_iff]", "tactic_state": "case h\nM : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\nx : \u03c3\n\u22a2 m x \u2260 0 \u2192 m x \u2022 w x = 0 \u2194 m x = 0\n---\nM : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 Subsingleton (AddUnits M)"}, {"line": "constructor", "tactic_state": "case h.mp\nM : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\nx : \u03c3\n\u22a2 (m x \u2260 0 \u2192 m x \u2022 w x = 0) \u2192 m x = 0\n---\ncase h.mpr\nM : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\nx : \u03c3\n\u22a2 m x = 0 \u2192 m x \u2260 0 \u2192 m x \u2022 w x = 0\n---\nM : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 Subsingleton (AddUnits M)"}, {"line": "\u00b7 intro hx\n    by_contra hx'\n    exact absurd (hw _ _ (hx hx')) hx'", "tactic_state": "case h.mpr\nM : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\nx : \u03c3\n\u22a2 m x = 0 \u2192 m x \u2260 0 \u2192 m x \u2022 w x = 0\n---\nM : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 Subsingleton (AddUnits M)"}, {"line": "\u00b7 intro hax _\n    simp only [hax]\n    simp only [zero_smul]", "tactic_state": "M : Type u_2\n\u03c3 : Type u_3\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : SemilatticeSup M\ninst\u271d\u00b3 : OrderBot M\nw : \u03c3 \u2192 M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : CanonicallyOrderedAdd M\nhw : sorry\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 Subsingleton (AddUnits M)"}]}
{"declaration": "theorem esymm_one : esymm \u03c3 R 1 = \u2211 i, X i := by simp [esymm, powersetCard_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Symmetric/Defs.lean", "context": {"open": ["Equiv (Perm)", "Finset"], "variables": ["{R : Type*} [CommSemiring R]", "{\u03c3 \u03c4 : Type*} {R S : Type*}", "[CommSemiring R] [CommSemiring S] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "[CommRing R] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "(\u03c3 R : Type*) [CommSemiring R] [CommSemiring S] [Fintype \u03c3] [Fintype \u03c4]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_8\nesymm : x\u271d\u00b9\nx\u271d : Sort u_9\nX : x\u271d\n\u22a2 sorry = \u2211 i, ?m.1596"}, {"line": "simp [esymm, powersetCard_one]", "tactic_state": "x\u271d\u00b9 : Sort u_8\nesymm : x\u271d\u00b9\nx\u271d : Sort u_9\nX : x\u271d\n\u22a2 sorry () = \u2211 i, ?m.1596"}]}
{"declaration": "theorem esymmPart_zero : esymmPart \u03c3 R (.indiscrete 0) = 1 := by simp [esymmPart]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Symmetric/Defs.lean", "context": {"open": ["Equiv (Perm)", "Finset"], "variables": ["{R : Type*} [CommSemiring R]", "{\u03c3 \u03c4 : Type*} {R S : Type*}", "[CommSemiring R] [CommSemiring S] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "[CommRing R] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "(\u03c3 R : Type*) [CommSemiring R] [CommSemiring S] [Fintype \u03c3] [Fintype \u03c4]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_8\nesymmPart : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [esymmPart]", "tactic_state": "x\u271d : Sort u_8\nesymmPart : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem esymmPart_indiscrete (n : \u2115) : esymmPart \u03c3 R (.indiscrete n) = esymm \u03c3 R n := by\n  cases n <;> simp [esymmPart]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Symmetric/Defs.lean", "context": {"open": ["Equiv (Perm)", "Finset"], "variables": ["{R : Type*} [CommSemiring R]", "{\u03c3 \u03c4 : Type*} {R S : Type*}", "[CommSemiring R] [CommSemiring S] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "[CommRing R] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "(\u03c3 R : Type*) [CommSemiring R] [CommSemiring S] [Fintype \u03c3] [Fintype \u03c4]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_8\nesymmPart : x\u271d\u00b9\nx\u271d : Sort u_9\nesymm : x\u271d\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "cases n <;> simp [esymmPart]", "tactic_state": "case zero\nx\u271d\u00b9 : Sort u_8\nesymmPart : x\u271d\u00b9\nx\u271d : Sort u_9\nesymm : x\u271d\n\u22a2 sorry () = sorry ()\n---\ncase succ\nx\u271d\u00b9 : Sort u_8\nesymmPart : x\u271d\u00b9\nx\u271d : Sort u_9\nesymm : x\u271d\nn\u271d : \u2115\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem hsymm_zero : hsymm \u03c3 R 0 = 1 := by simp [hsymm, eq_nil_of_card_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Symmetric/Defs.lean", "context": {"open": ["Equiv (Perm)", "Finset", "Finset Multiset Sym"], "variables": ["{R : Type*} [CommSemiring R]", "{\u03c3 \u03c4 : Type*} {R S : Type*}", "[CommSemiring R] [CommSemiring S] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "[CommRing R] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "(\u03c3 R : Type*) [CommSemiring R] [CommSemiring S] [Fintype \u03c3] [Fintype \u03c4]", "[DecidableEq \u03c3] [DecidableEq \u03c4]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_8\nhsymm : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [hsymm, eq_nil_of_card_zero]", "tactic_state": "x\u271d : Sort u_8\nhsymm : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem hsymmPart_zero : hsymmPart \u03c3 R (.indiscrete 0) = 1 := by simp [hsymmPart]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Symmetric/Defs.lean", "context": {"open": ["Equiv (Perm)", "Finset", "Finset Multiset Sym"], "variables": ["{R : Type*} [CommSemiring R]", "{\u03c3 \u03c4 : Type*} {R S : Type*}", "[CommSemiring R] [CommSemiring S] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "[CommRing R] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "(\u03c3 R : Type*) [CommSemiring R] [CommSemiring S] [Fintype \u03c3] [Fintype \u03c4]", "[DecidableEq \u03c3] [DecidableEq \u03c4]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_8\nhsymmPart : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [hsymmPart]", "tactic_state": "x\u271d : Sort u_8\nhsymmPart : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem hsymmPart_indiscrete (n : \u2115) : hsymmPart \u03c3 R (.indiscrete n) = hsymm \u03c3 R n := by\n  cases n <;> simp [hsymmPart]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Symmetric/Defs.lean", "context": {"open": ["Equiv (Perm)", "Finset", "Finset Multiset Sym"], "variables": ["{R : Type*} [CommSemiring R]", "{\u03c3 \u03c4 : Type*} {R S : Type*}", "[CommSemiring R] [CommSemiring S] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "[CommRing R] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "(\u03c3 R : Type*) [CommSemiring R] [CommSemiring S] [Fintype \u03c3] [Fintype \u03c4]", "[DecidableEq \u03c3] [DecidableEq \u03c4]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_8\nhsymmPart : x\u271d\u00b9\nx\u271d : Sort u_9\nhsymm : x\u271d\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "cases n <;> simp [hsymmPart]", "tactic_state": "case zero\nx\u271d\u00b9 : Sort u_8\nhsymmPart : x\u271d\u00b9\nx\u271d : Sort u_9\nhsymm : x\u271d\n\u22a2 sorry () = sorry ()\n---\ncase succ\nx\u271d\u00b9 : Sort u_8\nhsymmPart : x\u271d\u00b9\nx\u271d : Sort u_9\nhsymm : x\u271d\nn\u271d : \u2115\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem map_hsymm (n : \u2115) (f : R \u2192+* S) : map f (hsymm \u03c3 R n) = hsymm \u03c3 S n := by\n  simp [hsymm, \u2190 Multiset.prod_hom']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Symmetric/Defs.lean", "context": {"open": ["Equiv (Perm)", "Finset", "Finset Multiset Sym"], "variables": ["{R : Type*} [CommSemiring R]", "{\u03c3 \u03c4 : Type*} {R S : Type*}", "[CommSemiring R] [CommSemiring S] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "[CommRing R] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "(\u03c3 R : Type*) [CommSemiring R] [CommSemiring S] [Fintype \u03c3] [Fintype \u03c4]", "[DecidableEq \u03c3] [DecidableEq \u03c4]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_5\ninst\u271d\u00b2 : CommSemiring S\nR : Type u_7\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nx\u271d : Sort u_8\nhsymm : x\u271d\nn : \u2115\nf : R \u2192+* S\n\u22a2 sorry = sorry"}, {"line": "simp [hsymm, \u2190 Multiset.prod_hom']", "tactic_state": "S : Type u_5\ninst\u271d\u00b2 : CommSemiring S\nR : Type u_7\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nx\u271d : Sort u_8\nhsymm : x\u271d\nn : \u2115\nf : R \u2192+* S\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem psum_zero : psum \u03c3 R 0 = Fintype.card \u03c3 := by simp [psum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Symmetric/Defs.lean", "context": {"open": ["Equiv (Perm)", "Finset", "Finset Multiset Sym", "Finset"], "variables": ["{R : Type*} [CommSemiring R]", "{\u03c3 \u03c4 : Type*} {R S : Type*}", "[CommSemiring R] [CommSemiring S] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "[CommRing R] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "(\u03c3 R : Type*) [CommSemiring R] [CommSemiring S] [Fintype \u03c3] [Fintype \u03c4]", "[DecidableEq \u03c3] [DecidableEq \u03c4]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_6\ninst\u271d\u00b9 : Fintype \u03c3\ninst\u271d : DecidableEq \u03c3\nx\u271d : Sort u_8\npsum : x\u271d\n\u22a2 sorry = Fintype.card \u03c3"}, {"line": "simp [psum]", "tactic_state": "\u03c3 : Type u_6\ninst\u271d\u00b9 : Fintype \u03c3\ninst\u271d : DecidableEq \u03c3\nx\u271d : Sort u_8\npsum : x\u271d\n\u22a2 sorry () = Fintype.card \u03c3"}]}
{"declaration": "theorem psum_one : psum \u03c3 R 1 = \u2211 i, X i := by simp [psum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Symmetric/Defs.lean", "context": {"open": ["Equiv (Perm)", "Finset", "Finset Multiset Sym", "Finset"], "variables": ["{R : Type*} [CommSemiring R]", "{\u03c3 \u03c4 : Type*} {R S : Type*}", "[CommSemiring R] [CommSemiring S] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "[CommRing R] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "(\u03c3 R : Type*) [CommSemiring R] [CommSemiring S] [Fintype \u03c3] [Fintype \u03c4]", "[DecidableEq \u03c3] [DecidableEq \u03c4]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_8\npsum : x\u271d\u00b9\nx\u271d : Sort u_9\nX : x\u271d\n\u22a2 sorry = \u2211 i, ?m.1713"}, {"line": "simp [psum]", "tactic_state": "x\u271d\u00b9 : Sort u_8\npsum : x\u271d\u00b9\nx\u271d : Sort u_9\nX : x\u271d\n\u22a2 sorry () = \u2211 i, ?m.1713"}]}
{"declaration": "theorem psumPart_zero : psumPart \u03c3 R (.indiscrete 0) = 1 := by simp [psumPart]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Symmetric/Defs.lean", "context": {"open": ["Equiv (Perm)", "Finset", "Finset Multiset Sym", "Finset"], "variables": ["{R : Type*} [CommSemiring R]", "{\u03c3 \u03c4 : Type*} {R S : Type*}", "[CommSemiring R] [CommSemiring S] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "[CommRing R] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "(\u03c3 R : Type*) [CommSemiring R] [CommSemiring S] [Fintype \u03c3] [Fintype \u03c4]", "[DecidableEq \u03c3] [DecidableEq \u03c4]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_8\npsumPart : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [psumPart]", "tactic_state": "x\u271d : Sort u_8\npsumPart : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem psumPart_indiscrete {n : \u2115} (npos : n \u2260 0) :\n    psumPart \u03c3 R (.indiscrete n) = psum \u03c3 R n := by simp [psumPart, npos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Symmetric/Defs.lean", "context": {"open": ["Equiv (Perm)", "Finset", "Finset Multiset Sym", "Finset"], "variables": ["{R : Type*} [CommSemiring R]", "{\u03c3 \u03c4 : Type*} {R S : Type*}", "[CommSemiring R] [CommSemiring S] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "[CommRing R] {\u03c6 \u03c8 : MvPolynomial \u03c3 R}", "(\u03c3 R : Type*) [CommSemiring R] [CommSemiring S] [Fintype \u03c3] [Fintype \u03c4]", "[DecidableEq \u03c3] [DecidableEq \u03c4]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_8\npsumPart : x\u271d\u00b9\nx\u271d : Sort u_9\npsum : x\u271d\nn : \u2115\nnpos : n \u2260 0\n\u22a2 sorry = sorry"}, {"line": "simp [psumPart, npos]", "tactic_state": "x\u271d\u00b9 : Sort u_8\npsumPart : x\u271d\u00b9\nx\u271d : Sort u_9\npsum : x\u271d\nn : \u2115\nnpos : n \u2260 0\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "private lemma pairMap_of_snd_mem_fst {t : Finset \u03c3 \u00d7 \u03c3} (h : t.snd \u2208 t.fst) :\n    pairMap \u03c3 t = (t.fst.erase t.snd, t.snd) := by\n  simp [pairMap, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Symmetric/NewtonIdentities.lean", "context": {"open": ["Equiv (Perm)", "MvPolynomial", "Finset Nat"], "variables": ["(\u03c3 : Type*) (R : Type*) [CommRing R]", "[DecidableEq \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\ninst\u271d : DecidableEq \u03c3\nx\u271d : Sort u_3\npairMap : x\u271d\nt : Finset \u03c3 \u00d7 \u03c3\nh : t.2 \u2208 t.1\n\u22a2 sorry = (t.1.erase t.2, t.2)"}, {"line": "simp [pairMap, h]", "tactic_state": "\u03c3 : Type u_1\ninst\u271d : DecidableEq \u03c3\nx\u271d : Sort u_3\npairMap : x\u271d\nt : Finset \u03c3 \u00d7 \u03c3\nh : t.2 \u2208 t.1\n\u22a2 sorry () = (t.1.erase t.2, t.2)"}]}
{"declaration": "private lemma pairMap_of_snd_nmem_fst {t : Finset \u03c3 \u00d7 \u03c3} (h : t.snd \u2209 t.fst) :\n    pairMap \u03c3 t = (t.fst.cons t.snd h, t.snd) := by\n  simp [pairMap, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Symmetric/NewtonIdentities.lean", "context": {"open": ["Equiv (Perm)", "MvPolynomial", "Finset Nat"], "variables": ["(\u03c3 : Type*) (R : Type*) [CommRing R]", "[DecidableEq \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\ninst\u271d : DecidableEq \u03c3\nx\u271d : Sort u_3\npairMap : x\u271d\nt : Finset \u03c3 \u00d7 \u03c3\nh : t.2 \u2209 t.1\n\u22a2 sorry = (cons t.2 t.1 h, t.2)"}, {"line": "simp [pairMap, h]", "tactic_state": "\u03c3 : Type u_1\ninst\u271d : DecidableEq \u03c3\nx\u271d : Sort u_3\npairMap : x\u271d\nt : Finset \u03c3 \u00d7 \u03c3\nh : t.2 \u2209 t.1\n\u22a2 sorry () = (cons t.2 t.1 h, t.2)"}]}
{"declaration": "private lemma mem_pairs (k : \u2115) (t : Finset \u03c3 \u00d7 \u03c3) :\n    t \u2208 pairs \u03c3 k \u2194 #t.1 \u2264 k \u2227 (#t.1 = k \u2192 t.snd \u2208 t.fst) := by\n  simp [pairs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Symmetric/NewtonIdentities.lean", "context": {"open": ["Equiv (Perm)", "MvPolynomial", "Finset Nat"], "variables": ["(\u03c3 : Type*) (R : Type*) [CommRing R]", "[DecidableEq \u03c3]", "[Fintype \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03c3\ninst\u271d : Fintype \u03c3\nx\u271d : Sort u_3\npairs : x\u271d\nk : \u2115\nt : Finset \u03c3 \u00d7 \u03c3\n\u22a2 t \u2208 sorry \u2194 t.1.card \u2264 k \u2227 (t.1.card = k \u2192 t.2 \u2208 t.1)"}, {"line": "simp [pairs]", "tactic_state": "\u03c3 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03c3\ninst\u271d : Fintype \u03c3\nx\u271d : Sort u_3\npairs : x\u271d\nk : \u2115\nt : Finset \u03c3 \u00d7 \u03c3\n\u22a2 t \u2208 sorry () \u2194 t.1.card \u2264 k \u2227 (t.1.card = k \u2192 t.2 \u2208 t.1)"}]}
{"declaration": "private theorem sum_filter_pairs_eq_sum_powersetCard_sum (k : \u2115)\n    (f : Finset \u03c3 \u00d7 \u03c3 \u2192 MvPolynomial \u03c3 R) :\n    \u2211 t \u2208 pairs \u03c3 k with #t.1 = k, f t = \u2211 A \u2208 powersetCard k univ, \u2211 j \u2208 A, f (A, j) := by\n  apply sum_finset_product\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Symmetric/NewtonIdentities.lean", "context": {"open": ["Equiv (Perm)", "MvPolynomial", "Finset Nat"], "variables": ["(\u03c3 : Type*) (R : Type*) [CommRing R]", "[DecidableEq \u03c3]", "[Fintype \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : DecidableEq \u03c3\ninst\u271d : Fintype \u03c3\nx\u271d : Sort u_3\npairs : x\u271d\nk : \u2115\nf : Finset \u03c3 \u00d7 \u03c3 \u2192 MvPolynomial \u03c3 R\n\u22a2 \u2211 t \u2208 {t \u2208 sorry | t.1.card = k}, f t = \u2211 A \u2208 powersetCard k univ, \u2211 j \u2208 A, f (A, j)"}, {"line": "apply sum_finset_product", "tactic_state": "case h\n\u03c3 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : DecidableEq \u03c3\ninst\u271d : Fintype \u03c3\nx\u271d : Sort u_3\npairs : x\u271d\nk : \u2115\nf : Finset \u03c3 \u00d7 \u03c3 \u2192 MvPolynomial \u03c3 R\n\u22a2 \u2200 (p : Finset \u03c3 \u00d7 \u03c3), p \u2208 {t \u2208 sorry | t.1.card = k} \u2194 p.1 \u2208 powersetCard k univ \u2227 p.2 \u2208 p.1"}, {"line": "aesop", "tactic_state": "case mp\n\u03c3 : Type u_1\nR : Type u_2\ninst : CommRing R\ninst_1 : DecidableEq \u03c3\ninst_2 : Fintype \u03c3\nx : Sort u_3\npairs : x\nf : Finset \u03c3 \u00d7 \u03c3 \u2192 MvPolynomial \u03c3 R\nfst : Finset \u03c3\nsnd : \u03c3\nleft : (fst, snd) \u2208 sorry ()\n\u22a2 snd \u2208 fst\n---\ncase mpr\n\u03c3 : Type u_1\nR : Type u_2\ninst : CommRing R\ninst_1 : DecidableEq \u03c3\ninst_2 : Fintype \u03c3\nx : Sort u_3\npairs : x\nf : Finset \u03c3 \u00d7 \u03c3 \u2192 MvPolynomial \u03c3 R\nfst : Finset \u03c3\nsnd : \u03c3\nright : snd \u2208 fst\n\u22a2 (fst, snd) \u2208 sorry ()"}]}
{"declaration": "private theorem esymm_summand_to_weight (k : \u2115) (A : Finset \u03c3) (h : A \u2208 powersetCard k univ) :\n    \u2211 j \u2208 A, weight \u03c3 R k (A, j) = k * (-1) ^ k * (\u220f i \u2208 A, X i : MvPolynomial \u03c3 R) := by\n  simp [weight, mem_powersetCard_univ.mp h, mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Symmetric/NewtonIdentities.lean", "context": {"open": ["Equiv (Perm)", "MvPolynomial", "Finset Nat"], "variables": ["(\u03c3 : Type*) (R : Type*) [CommRing R]", "[DecidableEq \u03c3]", "[Fintype \u03c3]", "[Fintype \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : DecidableEq \u03c3\ninst\u271d\u00b9 inst\u271d : Fintype \u03c3\nx\u271d : Sort u_3\nweight : x\u271d\nk : \u2115\nA : Finset \u03c3\nh : A \u2208 powersetCard k univ\n\u22a2 \u2211 j \u2208 A, sorry = \u2191k * (-1) ^ k * \u220f i \u2208 A, X i"}, {"line": "simp [weight, mem_powersetCard_univ.mp h, mul_assoc]", "tactic_state": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : DecidableEq \u03c3\ninst\u271d\u00b9 inst\u271d : Fintype \u03c3\nx\u271d : Sort u_3\nweight : x\u271d\nk : \u2115\nA : Finset \u03c3\nh : A \u2208 powersetCard k univ\n\u22a2 \u2191k * sorry () = \u2191k * ((-1) ^ k * \u220f i \u2208 A, X i)"}]}
{"declaration": "theorem sum_antidiagonal_card_esymm_psum_eq_zero :\n    \u2211 a \u2208 antidiagonal (Fintype.card \u03c3), (-1) ^ a.fst * esymm \u03c3 R a.fst * psum \u03c3 R a.snd = 0 := by\n  let k := Fintype.card \u03c3\n  suffices (-1 : MvPolynomial \u03c3 R) ^ (k + 1) *\n      \u2211 a \u2208 antidiagonal k, (-1) ^ a.fst * esymm \u03c3 R a.fst * psum \u03c3 R a.snd = 0 by\n    simpa using this\n  simp [k, \u2190 sum_filter_add_sum_filter_not (antidiagonal k) (fun a \u21a6 a.fst < k),\n    \u2190 mul_esymm_eq_sum, mul_add, \u2190 mul_assoc, \u2190 pow_add, mul_comm \u2191k (esymm \u03c3 R k)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPolynomial/Symmetric/NewtonIdentities.lean", "context": {"open": ["Equiv (Perm)", "MvPolynomial", "Finset Nat"], "variables": ["(\u03c3 : Type*) (R : Type*) [CommRing R]", "[DecidableEq \u03c3]", "[Fintype \u03c3]", "[Fintype \u03c3]", "(\u03c3 : Type*) [Fintype \u03c3] (R : Type*) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_3\ninst\u271d\u00b9 : Fintype \u03c3\nR : Type u_4\ninst\u271d : CommRing R\n\u22a2 \u2211 a \u2208 antidiagonal (Fintype.card \u03c3), (-1) ^ a.1 * esymm \u03c3 R a.1 * psum \u03c3 R a.2 = 0"}, {"line": "let k := Fintype.card \u03c3", "tactic_state": "\u03c3 : Type u_3\ninst\u271d\u00b9 : Fintype \u03c3\nR : Type u_4\ninst\u271d : CommRing R\nk : \u2115 := sorry\n\u22a2 \u2211 a \u2208 antidiagonal (Fintype.card \u03c3), (-1) ^ a.1 * esymm \u03c3 R a.1 * psum \u03c3 R a.2 = 0"}, {"line": "suffices (-1 : MvPolynomial \u03c3 R) ^ (k + 1) *\n      \u2211 a \u2208 antidiagonal k, (-1) ^ a.fst * esymm \u03c3 R a.fst * psum \u03c3 R a.snd = 0 by\n    simpa using this", "tactic_state": "\u03c3 : Type u_3\ninst\u271d\u00b9 : Fintype \u03c3\nR : Type u_4\ninst\u271d : CommRing R\nk : \u2115 := sorry\n\u22a2 sorry"}, {"line": "simp [k, \u2190 sum_filter_add_sum_filter_not (antidiagonal k) (fun a \u21a6 a.fst < k),\n    \u2190 mul_esymm_eq_sum, mul_add, \u2190 mul_assoc, \u2190 pow_add, mul_comm \u2191k (esymm \u03c3 R k)]", "tactic_state": "\u03c3 : Type u_3\ninst\u271d\u00b9 : Fintype \u03c3\nR : Type u_4\ninst\u271d : CommRing R\nk : \u2115 := sorry\n\u22a2 sorry ()"}]}
{"declaration": "theorem mem_basis_iff {f : MvPowerSeries \u03c3 R} {Jd : TwoSidedIdeal R \u00d7 (\u03c3 \u2192\u2080 \u2115)} :\n    f \u2208 basis \u03c3 R Jd \u2194 \u2200 e \u2264 Jd.2, coeff R e f \u2208 Jd.1 := by\n  simp [basis]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/LinearTopology.lean", "context": {"open": ["scoped Topology", "Set SetLike Filter"], "variables": ["{\u03c3 : Type*} {R : Type*} [Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : Ring R\nx\u271d\u00b9 : Sort u_3\nbasis : x\u271d\u00b9\nx\u271d : Sort u_4\ncoeff : x\u271d\nf : MvPowerSeries \u03c3 R\nJd : TwoSidedIdeal R \u00d7 (\u03c3 \u2192\u2080 \u2115)\n\u22a2 f \u2208 sorry \u2194 \u2200 e \u2264 Jd.2, sorry \u2208 Jd.1"}, {"line": "simp [basis]", "tactic_state": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : Ring R\nx\u271d\u00b9 : Sort u_3\nbasis : x\u271d\u00b9\nx\u271d : Sort u_4\ncoeff : x\u271d\nf : MvPowerSeries \u03c3 R\nJd : TwoSidedIdeal R \u00d7 (\u03c3 \u2192\u2080 \u2115)\n\u22a2 f \u2208 sorry () \u2194 \u2200 e \u2264 Jd.2, sorry () \u2208 Jd.1"}]}
{"declaration": "theorem coeff_trunc (m : \u03c3 \u2192\u2080 \u2115) (\u03c6 : MvPowerSeries \u03c3 R) :\n    (trunc R n \u03c6).coeff m = if m < n then coeff R m \u03c6 else 0 := by\n  classical simp [trunc, coeff_truncFun]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Trunc.lean", "context": {"open": ["Finset (antidiagonal mem_antidiagonal)", "Finsupp"], "variables": ["{\u03c3 R S : Type*}", "[DecidableEq \u03c3] [CommSemiring R] (n : \u03c3 \u2192\u2080 \u2115)", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03c3\ninst\u271d : CommSemiring R\nn : \u03c3 \u2192\u2080 \u2115\nx\u271d\u00b9 : Sort u_4\ntrunc : x\u271d\u00b9\nx\u271d : Sort u_5\ncoeff : x\u271d\nm : \u03c3 \u2192\u2080 \u2115\n\u03c6 : MvPowerSeries \u03c3 R\n\u22a2 sorry = if m < n then sorry else 0"}, {"line": "classical simp [trunc, coeff_truncFun]", "tactic_state": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03c3\ninst\u271d : CommSemiring R\nn : \u03c3 \u2192\u2080 \u2115\nx\u271d\u00b9 : Sort u_4\ntrunc : x\u271d\u00b9\nx\u271d : Sort u_5\ncoeff : x\u271d\nm : \u03c3 \u2192\u2080 \u2115\n\u03c6 : MvPowerSeries \u03c3 R\n\u22a2 sorry () = if m < n then sorry () else 0"}]}
{"declaration": "theorem coeff_mul_C (n : \u03c3 \u2192\u2080 \u2115) (\u03c6 : MvPowerSeries \u03c3 R) (a : R) :\n    coeff R n (\u03c6 * C \u03c3 R a) = coeff R n \u03c6 * a := by simpa using coeff_add_mul_monomial n 0 \u03c6 a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Basic.lean", "context": {"open": ["Finset (antidiagonal mem_antidiagonal)", "Finsupp"], "variables": ["{\u03c3 R : Type*}", "(R) [Semiring R]", "{R}", "(m n : \u03c3 \u2192\u2080 \u2115) (\u03c6 \u03c8 : MvPowerSeries \u03c3 R)", "[Semiring R]", "(\u03c3) (R)", "{\u03c3} {R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 inst\u271d : Semiring R\nx\u271d : Sort u_3\ncoeff : x\u271d\nn : \u03c3 \u2192\u2080 \u2115\n\u03c6 : MvPowerSeries \u03c3 R\na : R\n\u22a2 sorry = sorry * a"}, {"line": "simpa using coeff_add_mul_monomial n 0 \u03c6 a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_C_mul (n : \u03c3 \u2192\u2080 \u2115) (\u03c6 : MvPowerSeries \u03c3 R) (a : R) :\n    coeff R n (C \u03c3 R a * \u03c6) = a * coeff R n \u03c6 := by simpa using coeff_add_monomial_mul 0 n \u03c6 a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Basic.lean", "context": {"open": ["Finset (antidiagonal mem_antidiagonal)", "Finsupp"], "variables": ["{\u03c3 R : Type*}", "(R) [Semiring R]", "{R}", "(m n : \u03c3 \u2192\u2080 \u2115) (\u03c6 \u03c8 : MvPowerSeries \u03c3 R)", "[Semiring R]", "(\u03c3) (R)", "{\u03c3} {R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 inst\u271d : Semiring R\nx\u271d : Sort u_3\ncoeff : x\u271d\nn : \u03c3 \u2192\u2080 \u2115\n\u03c6 : MvPowerSeries \u03c3 R\na : R\n\u22a2 sorry = a * sorry"}, {"line": "simpa using coeff_add_monomial_mul 0 n \u03c6 a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_invOfUnit [DecidableEq \u03c3] (n : \u03c3 \u2192\u2080 \u2115) (\u03c6 : MvPowerSeries \u03c3 R) (u : R\u02e3) :\n    coeff R n (invOfUnit \u03c6 u) =\n      if n = 0 then \u2191u\u207b\u00b9\n      else\n        -\u2191u\u207b\u00b9 *\n          \u2211 x \u2208 antidiagonal n,\n            if x.2 < n then coeff R x.1 \u03c6 * coeff R x.2 (invOfUnit \u03c6 u) else 0 := by\n  convert coeff_inv_aux n (\u2191u\u207b\u00b9) \u03c6\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Inverse.lean", "context": {"open": ["Finset (antidiagonal mem_antidiagonal)", "Finsupp"], "variables": ["{\u03c3 R : Type*}", "[Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : Ring R\nx\u271d : Sort u_3\ncoeff : x\u271d\ninst\u271d : DecidableEq \u03c3\nn : \u03c3 \u2192\u2080 \u2115\n\u03c6 : MvPowerSeries \u03c3 R\nu : R\u02e3\n\u22a2 sorry = if n = 0 then u\u207b\u00b9 else -u\u207b\u00b9 * \u2211 x \u2208 antidiagonal n, if x.2 < n then sorry * sorry else 0"}, {"line": "convert coeff_inv_aux n (\u2191u\u207b\u00b9) \u03c6", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isUnit_iff_constantCoeff {\u03c6 : MvPowerSeries \u03c3 R} :\n    IsUnit \u03c6 \u2194 IsUnit (constantCoeff \u03c3 R \u03c6) := by\n  constructor\n  \u00b7 exact IsUnit.map _\n  \u00b7 intro \u27e8u, hu\u27e9\n    exact \u27e8\u27e8_, \u03c6.invOfUnit u, mul_invOfUnit \u03c6 u hu.symm, invOfUnit_mul \u03c6 u hu.symm\u27e9, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Inverse.lean", "context": {"open": ["Finset (antidiagonal mem_antidiagonal)", "Finsupp"], "variables": ["{\u03c3 R : Type*}", "[Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : Ring R\nx\u271d : Sort u_3\nconstantCoeff : x\u271d\n\u03c6 : MvPowerSeries \u03c3 R\n\u22a2 IsUnit \u03c6 \u2194 IsUnit sorry"}, {"line": "constructor", "tactic_state": "case mp\n\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : Ring R\nx\u271d : Sort u_3\nconstantCoeff : x\u271d\n\u03c6 : MvPowerSeries \u03c3 R\n\u22a2 IsUnit \u03c6 \u2192 IsUnit sorry\n---\ncase mpr\n\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : Ring R\nx\u271d : Sort u_3\nconstantCoeff : x\u271d\n\u03c6 : MvPowerSeries \u03c3 R\n\u22a2 IsUnit sorry \u2192 IsUnit \u03c6"}, {"line": "\u00b7 exact IsUnit.map _", "tactic_state": "case mpr\n\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : Ring R\nx\u271d : Sort u_3\nconstantCoeff : x\u271d\n\u03c6 : MvPowerSeries \u03c3 R\n\u22a2 IsUnit sorry \u2192 IsUnit \u03c6"}, {"line": "\u00b7 intro \u27e8u, hu\u27e9\n    exact \u27e8\u27e8_, \u03c6.invOfUnit u, mul_invOfUnit \u03c6 u hu.symm, invOfUnit_mul \u03c6 u hu.symm\u27e9, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_inv (r : k) (\u03c6 : MvPowerSeries \u03c3 k) : (r \u2022 \u03c6)\u207b\u00b9 = r\u207b\u00b9 \u2022 \u03c6\u207b\u00b9 := by\n  simp [smul_eq_C_mul, mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Inverse.lean", "context": {"open": ["Finset (antidiagonal mem_antidiagonal)", "Finsupp", "MvPowerSeries"], "variables": ["{\u03c3 R : Type*}", "[Ring R]", "[CommRing R]", "{S : Type*} [CommRing R] [CommRing S] (f : R \u2192+* S) [IsLocalHom f]", "{k : Type*} [Field k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nk : Type u_4\ninst\u271d : Field k\nr : k\n\u03c6 : MvPowerSeries \u03c3 k\n\u22a2 (r \u2022 \u03c6)\u207b\u00b9 = r\u207b\u00b9 \u2022 \u03c6\u207b\u00b9"}, {"line": "simp [smul_eq_C_mul, mul_comm]", "tactic_state": "\u03c3 : Type u_1\nk : Type u_4\ninst\u271d : Field k\nr : k\n\u03c6 : MvPowerSeries \u03c3 k\n\u22a2 \u03c6\u207b\u00b9 * (C \u03c3 k) r\u207b\u00b9 = (C \u03c3 k) r\u207b\u00b9 * \u03c6\u207b\u00b9"}]}
{"declaration": "theorem ne_zero_iff_exists_coeff_ne_zero_and_degree :\n    f \u2260 0 \u2194 (\u2203 n : \u2115, \u2203 d : \u03c3 \u2192\u2080 \u2115, coeff R d f \u2260 0 \u2227 degree d = n) := by\n  simp_rw [degree_eq_weight_one]\n  exact ne_zero_iff_exists_coeff_ne_zero_and_weight (fun _ => 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Order.lean", "context": {"open": ["ENat WithTop Finsupp"], "variables": ["{\u03c3 R : Type*} [Semiring R]", "(w : \u03c3 \u2192 \u2115) {f g : MvPowerSeries \u03c3 R}", "{R : Type*} [Ring R] {f g : MvPowerSeries \u03c3 R}", "{f g : MvPowerSeries \u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : Ring R\nf : MvPowerSeries \u03c3 R\nx\u271d : Sort u_4\ncoeff : x\u271d\n\u22a2 f \u2260 0 \u2194 \u2203 n d, sorry \u2260 0 \u2227 d.degree = n"}, {"line": "simp_rw [degree_eq_weight_one]", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : Ring R\nf : MvPowerSeries \u03c3 R\nx\u271d : Sort u_4\ncoeff : x\u271d\n\u22a2 f \u2260 0 \u2194 \u2203 n d, sorry \u2260 0 \u2227 (weight fun x => 1) d = n"}, {"line": "exact ne_zero_iff_exists_coeff_ne_zero_and_weight (fun _ => 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_coeff_ne_zero_and_order (h : f.order.toNat = f.order) :\n    \u2203 d : \u03c3 \u2192\u2080 \u2115, coeff R d f \u2260 0 \u2227 degree d = f.order := by\n  simp_rw [degree_eq_weight_one]\n  exact exists_coeff_ne_zero_and_weightedOrder _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Order.lean", "context": {"open": ["ENat WithTop Finsupp"], "variables": ["{\u03c3 R : Type*} [Semiring R]", "(w : \u03c3 \u2192 \u2115) {f g : MvPowerSeries \u03c3 R}", "{R : Type*} [Ring R] {f g : MvPowerSeries \u03c3 R}", "{f g : MvPowerSeries \u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : Ring R\nf : MvPowerSeries \u03c3 R\nx\u271d : Sort u_4\ncoeff : x\u271d\nh : \u2191f.order.toNat = f.order\n\u22a2 \u2203 d, sorry \u2260 0 \u2227 \u2191d.degree = f.order"}, {"line": "simp_rw [degree_eq_weight_one]", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : Ring R\nf : MvPowerSeries \u03c3 R\nx\u271d : Sort u_4\ncoeff : x\u271d\nh : \u2191f.order.toNat = f.order\n\u22a2 \u2203 d, sorry \u2260 0 \u2227 \u2191((weight fun x => 1) d) = f.order"}, {"line": "exact exists_coeff_ne_zero_and_weightedOrder _ h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem order_le {d : \u03c3 \u2192\u2080 \u2115} (h : coeff R d f \u2260 0) : f.order \u2264 degree d := by\n  rw [degree_eq_weight_one]\n  exact weightedOrder_le _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Order.lean", "context": {"open": ["ENat WithTop Finsupp"], "variables": ["{\u03c3 R : Type*} [Semiring R]", "(w : \u03c3 \u2192 \u2115) {f g : MvPowerSeries \u03c3 R}", "{R : Type*} [Ring R] {f g : MvPowerSeries \u03c3 R}", "{f g : MvPowerSeries \u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : Ring R\nf : MvPowerSeries \u03c3 R\nx\u271d : Sort u_4\ncoeff : x\u271d\nd : \u03c3 \u2192\u2080 \u2115\nh : sorry \u2260 0\n\u22a2 f.order \u2264 \u2191d.degree"}, {"line": "rw [degree_eq_weight_one]", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : Ring R\nf : MvPowerSeries \u03c3 R\nx\u271d : Sort u_4\ncoeff : x\u271d\nd : \u03c3 \u2192\u2080 \u2115\nh : sorry \u2260 0\n\u22a2 f.order \u2264 \u2191((weight fun x => 1) d)"}, {"line": "exact weightedOrder_le _ h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_of_lt_order {d : \u03c3 \u2192\u2080 \u2115} (h : degree d < f.order) :\n    coeff R d f = 0 := by\n  rw [degree_eq_weight_one] at h\n  exact coeff_eq_zero_of_lt_weightedOrder _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Order.lean", "context": {"open": ["ENat WithTop Finsupp"], "variables": ["{\u03c3 R : Type*} [Semiring R]", "(w : \u03c3 \u2192 \u2115) {f g : MvPowerSeries \u03c3 R}", "{R : Type*} [Ring R] {f g : MvPowerSeries \u03c3 R}", "{f g : MvPowerSeries \u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : Ring R\nf : MvPowerSeries \u03c3 R\nx\u271d : Sort u_4\ncoeff : x\u271d\nd : \u03c3 \u2192\u2080 \u2115\nh : \u2191d.degree < f.order\n\u22a2 sorry = 0"}, {"line": "rw [degree_eq_weight_one] at h", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : Ring R\nf : MvPowerSeries \u03c3 R\nx\u271d : Sort u_4\ncoeff : x\u271d\nd : \u03c3 \u2192\u2080 \u2115\nh : \u2191((weight fun x => 1) d) < f.order\n\u22a2 sorry = 0"}, {"line": "exact coeff_eq_zero_of_lt_weightedOrder _ h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_order {n : \u2115\u221e} (h : \u2200 d : \u03c3 \u2192\u2080 \u2115, degree d < n \u2192 coeff R d f = 0) :\n    n \u2264 f.order := by\n  simp_rw [degree_eq_weight_one] at h\n  exact le_weightedOrder _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Order.lean", "context": {"open": ["ENat WithTop Finsupp"], "variables": ["{\u03c3 R : Type*} [Semiring R]", "(w : \u03c3 \u2192 \u2115) {f g : MvPowerSeries \u03c3 R}", "{R : Type*} [Ring R] {f g : MvPowerSeries \u03c3 R}", "{f g : MvPowerSeries \u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : Ring R\nf : MvPowerSeries \u03c3 R\nx\u271d : Sort u_4\ncoeff : x\u271d\nn : \u2115\u221e\nh : \u2200 (d : \u03c3 \u2192\u2080 \u2115), \u2191d.degree < n \u2192 sorry = 0\n\u22a2 n \u2264 f.order"}, {"line": "simp_rw [degree_eq_weight_one] at h", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : Ring R\nf : MvPowerSeries \u03c3 R\nx\u271d : Sort u_4\ncoeff : x\u271d\nn : \u2115\u221e\nh : \u2200 (d : \u03c3 \u2192\u2080 \u2115), \u2191((weight fun x => 1) d) < n \u2192 sorry = 0\n\u22a2 n \u2264 f.order"}, {"line": "exact le_weightedOrder _ h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem order_monomial {d : \u03c3 \u2192\u2080 \u2115} {a : R} [Decidable (a = 0)] :\n    order (monomial R d a) = if a = 0 then (\u22a4 : \u2115\u221e) else \u2191(degree d) := by\n  rw [degree_eq_weight_one]\n  exact weightedOrder_monomial _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Order.lean", "context": {"open": ["ENat WithTop Finsupp"], "variables": ["{\u03c3 R : Type*} [Semiring R]", "(w : \u03c3 \u2192 \u2115) {f g : MvPowerSeries \u03c3 R}", "{R : Type*} [Ring R] {f g : MvPowerSeries \u03c3 R}", "{f g : MvPowerSeries \u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d\u00b9 : Ring R\nx\u271d : Sort u_4\norder : x\u271d\nd : \u03c3 \u2192\u2080 \u2115\na : R\ninst\u271d : Decidable (a = 0)\n\u22a2 sorry = if a = 0 then \u22a4 else \u2191d.degree"}, {"line": "rw [degree_eq_weight_one]", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d\u00b9 : Ring R\nx\u271d : Sort u_4\norder : x\u271d\nd : \u03c3 \u2192\u2080 \u2115\na : R\ninst\u271d : Decidable (a = 0)\n\u22a2 sorry = if a = 0 then \u22a4 else \u2191((weight fun x => 1) d)"}, {"line": "exact weightedOrder_monomial _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem order_monomial_of_ne_zero {d : \u03c3 \u2192\u2080 \u2115} {a : R} (h : a \u2260 0) :\n    order (monomial R d a) = degree d := by\n  rw [degree_eq_weight_one]\n  exact weightedOrder_monomial_of_ne_zero _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Order.lean", "context": {"open": ["ENat WithTop Finsupp"], "variables": ["{\u03c3 R : Type*} [Semiring R]", "(w : \u03c3 \u2192 \u2115) {f g : MvPowerSeries \u03c3 R}", "{R : Type*} [Ring R] {f g : MvPowerSeries \u03c3 R}", "{f g : MvPowerSeries \u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : Ring R\nx\u271d : Sort u_4\norder : x\u271d\nd : \u03c3 \u2192\u2080 \u2115\na : R\nh : a \u2260 0\n\u22a2 sorry = d.degree"}, {"line": "rw [degree_eq_weight_one]", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : Ring R\nx\u271d : Sort u_4\norder : x\u271d\nd : \u03c3 \u2192\u2080 \u2115\na : R\nh : a \u2260 0\n\u22a2 sorry = (weight fun x => 1) d"}, {"line": "exact weightedOrder_monomial_of_ne_zero _ h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_homogeneousComponent (p : \u2115) (d : \u03c3 \u2192\u2080 \u2115) (f : MvPowerSeries \u03c3 R) :\n    coeff R d (homogeneousComponent p f) =\n      if degree d = p then coeff R d f else 0 := by\n  rw [degree_eq_weight_one]\n  exact coeff_weightedHomogeneousComponent 1 p d f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Order.lean", "context": {"open": ["ENat WithTop Finsupp"], "variables": ["{\u03c3 R : Type*} [Semiring R]", "(w : \u03c3 \u2192 \u2115) {f g : MvPowerSeries \u03c3 R}", "{R : Type*} [Ring R] {f g : MvPowerSeries \u03c3 R}", "{f g : MvPowerSeries \u03c3 R}", "{R : Type*} [Ring R] {f g : MvPowerSeries \u03c3 R}", "(w : \u03c3 \u2192 \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_4\ninst\u271d : Ring R\nx\u271d : Sort u_5\ncoeff : x\u271d\np : \u2115\nd : \u03c3 \u2192\u2080 \u2115\nf : MvPowerSeries \u03c3 R\n\u22a2 sorry = if d.degree = p then sorry else 0"}, {"line": "rw [degree_eq_weight_one]", "tactic_state": "\u03c3 : Type u_1\nR : Type u_4\ninst\u271d : Ring R\nx\u271d : Sort u_5\ncoeff : x\u271d\np : \u2115\nd : \u03c3 \u2192\u2080 \u2115\nf : MvPowerSeries \u03c3 R\n\u22a2 sorry = if (weight fun x => 1) d = p then sorry else 0"}, {"line": "exact coeff_weightedHomogeneousComponent 1 p d f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coeff_zero_iff [TopologicalSpace S] [DiscreteTopology S] :\n    Filter.Tendsto a Filter.cofinite (nhds 0) \u2194\n      \u2200 d : \u03c4 \u2192\u2080 \u2115, {s | (a s).coeff S d \u2260 0}.Finite := by\n  simp [tendsto_iff_coeff_tendsto, coeff_zero, nhds_discrete]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Substitution.lean", "context": {"open": ["WithPiTopology"], "variables": ["{\u03c3 : Type*}", "{a : \u03c3 \u2192 MvPowerSeries \u03c4 S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c4 : Type u_3\nS : Type u_2\n\u03c3 : Type u_1\na : \u03c3 \u2192 MvPowerSeries \u03c4 S\ninst\u271d\u00b9 : TopologicalSpace S\ninst\u271d : DiscreteTopology S\n\u22a2 Filter.Tendsto a Filter.cofinite sorry \u2194 (\u03c4 \u2192\u2080 \u2115) \u2192 {s | sorry \u2260 sorry}.Finite"}, {"line": "simp [tendsto_iff_coeff_tendsto, coeff_zero, nhds_discrete]", "tactic_state": "\u03c4 : Type u_3\nS : Type u_2\n\u03c3 : Type u_1\na : \u03c3 \u2192 MvPowerSeries \u03c4 S\ninst\u271d\u00b9 : TopologicalSpace S\ninst\u271d : DiscreteTopology S\n\u22a2 Filter.Tendsto a Filter.cofinite (sorry ())"}]}
{"declaration": "theorem HasSubst.zero : HasSubst (fun (_ : \u03c3) \u21a6 (0 : MvPowerSeries \u03c4 S)) := by\n  letI : UniformSpace S := \u22a5\n  simpa [hasSubst_iff_hasEval_of_discreteTopology] using HasEval.zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Substitution.lean", "context": {"open": ["WithPiTopology"], "variables": ["{\u03c3 : Type*}", "{a : \u03c3 \u2192 MvPowerSeries \u03c4 S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nHasSubst : x\u271d\n\u22a2 sorry"}, {"line": "letI : UniformSpace S := \u22a5", "tactic_state": "x\u271d : Sort u_2\nHasSubst : x\u271d\nthis : UniformSpace sorry := \u22a5\n\u22a2 sorry"}, {"line": "simpa [hasSubst_iff_hasEval_of_discreteTopology] using HasEval.zero", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem HasSubst.X : HasSubst (fun (s : \u03c3) \u21a6 (X s : MvPowerSeries \u03c3 S)) := by\n  letI : UniformSpace S := \u22a5\n  simpa [hasSubst_iff_hasEval_of_discreteTopology] using HasEval.X\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Substitution.lean", "context": {"open": ["WithPiTopology"], "variables": ["{\u03c3 : Type*}", "{a : \u03c3 \u2192 MvPowerSeries \u03c4 S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nHasSubst : x\u271d\n\u22a2 sorry"}, {"line": "letI : UniformSpace S := \u22a5", "tactic_state": "x\u271d : Sort u_2\nHasSubst : x\u271d\nthis : UniformSpace sorry := \u22a5\n\u22a2 sorry"}, {"line": "simpa [hasSubst_iff_hasEval_of_discreteTopology] using HasEval.X", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_rescale (f : MvPowerSeries \u03c3 R) (a : \u03c3 \u2192 R) (n : \u03c3 \u2192\u2080 \u2115) :\n    coeff R n (rescale a f) = (n.prod fun s m \u21a6 a s ^ m) * f.coeff R n := by\n  simp [rescale, coeff_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Substitution.lean", "context": {"open": ["WithPiTopology"], "variables": ["{\u03c3 : Type*}", "{a : \u03c3 \u2192 MvPowerSeries \u03c4 S}", "{a : \u03c3 \u2192 MvPowerSeries \u03c4 S}", "", "[Algebra S T] [IsScalarTower R S T]", "{\u03c5 : Type*}", "{R : Type*} [CommSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : CommSemiring R\nx\u271d : Sort u_4\ncoeff : x\u271d\nf : MvPowerSeries \u03c3 R\na : \u03c3 \u2192 R\nn : \u03c3 \u2192\u2080 \u2115\n\u22a2 sorry = (n.prod fun s m => a s ^ m) * (MvPowerSeries.coeff R n) f"}, {"line": "simp [rescale, coeff_apply]", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : CommSemiring R\nx\u271d : Sort u_4\ncoeff : x\u271d\nf : MvPowerSeries \u03c3 R\na : \u03c3 \u2192 R\nn : \u03c3 \u2192\u2080 \u2115\n\u22a2 sorry () = (n.prod fun s m => a s ^ m) * (MvPowerSeries.coeff R n) f"}]}
{"declaration": "theorem rescale_one : rescale 1 = RingHom.id (MvPowerSeries \u03c3 R) := by\n  ext f n\n  simp [coeff_rescale, Finsupp.prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/MvPowerSeries/Substitution.lean", "context": {"open": ["WithPiTopology"], "variables": ["{\u03c3 : Type*}", "{a : \u03c3 \u2192 MvPowerSeries \u03c4 S}", "{a : \u03c3 \u2192 MvPowerSeries \u03c4 S}", "", "[Algebra S T] [IsScalarTower R S T]", "{\u03c5 : Type*}", "{R : Type*} [CommSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : CommSemiring R\nx\u271d : Sort u_4\nrescale : x\u271d\n\u22a2 sorry = RingHom.id (MvPowerSeries \u03c3 R)"}, {"line": "ext f n", "tactic_state": "case a\n\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : CommSemiring R\nx\u271d : Sort u_4\nrescale : x\u271d\nf : MvPowerSeries \u03c3 R\n\u22a2 sorry f = (RingHom.id (MvPowerSeries \u03c3 R)) f"}, {"line": "simp [coeff_rescale, Finsupp.prod]", "tactic_state": "case a\n\u03c3 : Type u_1\nR : Type u_3\ninst\u271d : CommSemiring R\nx\u271d : Sort u_4\nrescale : x\u271d\nf : MvPowerSeries \u03c3 R\n\u22a2 (sorry ()) f = f"}]}
{"declaration": "theorem isRadical_iff_span_singleton [CommSemiring R] :\n    IsRadical y \u2194 (Ideal.span ({y} : Set R)).IsRadical := by\n  simp_rw [IsRadical, \u2190 Ideal.mem_span_singleton]\n  exact forall_swap.trans (forall_congr' fun r => exists_imp.symm)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Nilpotent/Lemmas.lean", "context": {"open": ["Function Set"], "variables": ["{R S : Type*} {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ny : R\ninst\u271d : CommSemiring R\n\u22a2 IsRadical y \u2194 (Ideal.span {y}).IsRadical"}, {"line": "simp_rw [IsRadical, \u2190 Ideal.mem_span_singleton]", "tactic_state": "R : Type u_1\ny : R\ninst\u271d : CommSemiring R\n\u22a2 (\u2200 (n : \u2115) (x : R), x ^ n \u2208 Ideal.span {y} \u2192 x \u2208 Ideal.span {y}) \u2194 (Ideal.span {y}).IsRadical"}, {"line": "exact forall_swap.trans (forall_congr' fun r => exists_imp.symm)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nilpotent_iff_mem_prime : IsNilpotent x \u2194 \u2200 J : Ideal R, J.IsPrime \u2192 x \u2208 J := by\n  rw [\u2190 mem_nilradical]\n  rw [nilradical_eq_sInf]\n  rw [Submodule.mem_sInf]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Nilpotent/Lemmas.lean", "context": {"open": ["Function Set"], "variables": ["{R S : Type*} {x y : R}", "[CommSemiring R] {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\nx : R\n\u22a2 IsNilpotent x \u2194 \u2200 (J : Ideal R), J.IsPrime \u2192 x \u2208 J"}, {"line": "rw [\u2190 mem_nilradical]", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\nx : R\n\u22a2 x \u2208 nilradical R \u2194 \u2200 (J : Ideal R), J.IsPrime \u2192 x \u2208 J"}, {"line": "rw [nilradical_eq_sInf]", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\nx : R\n\u22a2 x \u2208 sInf {J | J.IsPrime} \u2194 \u2200 (J : Ideal R), J.IsPrime \u2192 x \u2208 J"}, {"line": "rw [Submodule.mem_sInf]", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\nx : R\n\u22a2 (\u2200 p \u2208 {J | J.IsPrime}, x \u2208 p) \u2194 \u2200 (J : Ideal R), J.IsPrime \u2192 x \u2208 J"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nilradical_eq_bot_iff {R : Type*} [CommSemiring R] : nilradical R = \u22a5 \u2194 IsReduced R := by\n  simp_rw [eq_bot_iff, SetLike.le_def, Submodule.mem_bot, mem_nilradical, isReduced_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Nilpotent/Lemmas.lean", "context": {"open": ["Function Set"], "variables": ["{R S : Type*} {x y : R}", "[CommSemiring R] {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d : CommSemiring R\n\u22a2 nilradical R = \u22a5 \u2194 IsReduced R"}, {"line": "simp_rw [eq_bot_iff, SetLike.le_def, Submodule.mem_bot, mem_nilradical, isReduced_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isNilpotent.restrict\n    {f : M \u2192\u2097[R] M} {p : Submodule R M} (hf : MapsTo f p p) (hnil : IsNilpotent f) :\n    IsNilpotent (f.restrict hf) := by\n  obtain \u27e8n, hn\u27e9 := hnil\n  exact \u27e8n, LinearMap.ext fun m \u21a6 by simp only [Module.End.pow_restrict n, hn,\n    LinearMap.restrict_apply, LinearMap.zero_apply]; rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Nilpotent/Lemmas.lean", "context": {"open": ["Function Set"], "variables": ["{R S : Type*} {x y : R}", "[CommSemiring R] {x y : R}", "(R) {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A]", "{R}", "{\u03b9 M : Type*} [Fintype \u03b9] [DecidableEq \u03b9] [AddCommMonoid M] [Module R M]", "{M : Type*} [Semiring R] [AddCommMonoid M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 : CommSemiring R\nM : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nf : M \u2192\u2097[R] M\np : Submodule R M\nhf : MapsTo \u21d1f \u2191p \u2191p\nhnil : IsNilpotent f\n\u22a2 IsNilpotent (f.restrict hf)"}, {"line": "obtain \u27e8n, hn\u27e9 := hnil", "tactic_state": "case intro\nR : Type u_1\ninst\u271d\u2074 inst\u271d\u00b3 : CommSemiring R\nM : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nf : M \u2192\u2097[R] M\np : Submodule R M\nhf : MapsTo \u21d1f \u2191p \u2191p\nn : \u2115\nhn : f ^ n = 0\n\u22a2 IsNilpotent (f.restrict hf)"}, {"line": "exact \u27e8n, LinearMap.ext fun m \u21a6 by simp only [Module.End.pow_restrict n, hn,\n    LinearMap.restrict_apply, LinearMap.zero_apply]; rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsUnit.not_isNilpotent [Ring R] [Nontrivial R] {x : R} (hx : IsUnit x) :\n    \u00ac IsNilpotent x := by\n  intro H\n  simpa using H.isUnit_add_right_of_commute hx.neg (by simp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Nilpotent/Basic.lean", "context": {"open": ["Function Set"], "variables": ["{R S : Type*} {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Nontrivial R\nx : R\nhx : IsUnit x\n\u22a2 \u00acIsNilpotent x"}, {"line": "intro H", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Nontrivial R\nx : R\nhx : IsUnit x\nH : IsNilpotent x\n\u22a2 False"}, {"line": "simpa using H.isUnit_add_right_of_commute hx.neg (by simp)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsIdempotentElem.eq_zero_of_isNilpotent [MonoidWithZero R] {e : R}\n    (idem : IsIdempotentElem e) (nilp : IsNilpotent e) : e = 0 := by\n  obtain \u27e8rfl | n, hn\u27e9 := nilp\n  \u00b7 rw [pow_zero] at hn; rw [\u2190 one_mul e, hn, zero_mul]\n  \u00b7 rw [\u2190 hn, idem.pow_succ_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Nilpotent/Basic.lean", "context": {"open": ["Function Set"], "variables": ["{R S : Type*} {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : MonoidWithZero R\ne : R\nidem : IsIdempotentElem e\nnilp : IsNilpotent e\n\u22a2 e = 0"}, {"line": "obtain \u27e8rfl | n, hn\u27e9 := nilp", "tactic_state": "case intro.zero\nR : Type u_1\ninst\u271d : MonoidWithZero R\ne : R\nidem : IsIdempotentElem e\nhn : e ^ 0 = 0\n\u22a2 e = 0\n---\ncase intro.succ\nR : Type u_1\ninst\u271d : MonoidWithZero R\ne : R\nidem : IsIdempotentElem e\nn : \u2115\nhn : e ^ (n + 1) = 0\n\u22a2 e = 0"}, {"line": "\u00b7 rw [pow_zero] at hn; rw [\u2190 one_mul e, hn, zero_mul]", "tactic_state": "case intro.succ\nR : Type u_1\ninst\u271d : MonoidWithZero R\ne : R\nidem : IsIdempotentElem e\nn : \u2115\nhn : e ^ (n + 1) = 0\n\u22a2 e = 0"}, {"line": "\u00b7 rw [\u2190 hn, idem.pow_succ_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsNilpotent.pow_succ (n : \u2115) {S : Type*} [MonoidWithZero S] {x : S}\n    (hx : IsNilpotent x) : IsNilpotent (x ^ n.succ) := by\n  obtain \u27e8N, hN\u27e9 := hx\n  use N\n  rw [\u2190 pow_mul]\n  rw [Nat.succ_mul]\n  rw [pow_add]\n  rw [hN]\n  rw [mul_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Nilpotent/Defs.lean", "context": {"open": ["Function Set"], "variables": ["{R S : Type*} {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nS : Type u_3\ninst\u271d : MonoidWithZero S\nx : S\nhx : IsNilpotent x\n\u22a2 IsNilpotent (x ^ n.succ)"}, {"line": "obtain \u27e8N, hN\u27e9 := hx", "tactic_state": "case intro\nn : \u2115\nS : Type u_3\ninst\u271d : MonoidWithZero S\nx : S\nN : \u2115\nhN : x ^ N = 0\n\u22a2 IsNilpotent (x ^ n.succ)"}, {"line": "use N", "tactic_state": "case h\nn : \u2115\nS : Type u_3\ninst\u271d : MonoidWithZero S\nx : S\nN : \u2115\nhN : x ^ N = 0\n\u22a2 (x ^ n.succ) ^ N = 0"}, {"line": "rw [\u2190 pow_mul]", "tactic_state": "case h\nn : \u2115\nS : Type u_3\ninst\u271d : MonoidWithZero S\nx : S\nN : \u2115\nhN : x ^ N = 0\n\u22a2 x ^ (n.succ * N) = 0"}, {"line": "rw [Nat.succ_mul]", "tactic_state": "case h\nn : \u2115\nS : Type u_3\ninst\u271d : MonoidWithZero S\nx : S\nN : \u2115\nhN : x ^ N = 0\n\u22a2 x ^ (n * N + N) = 0"}, {"line": "rw [pow_add]", "tactic_state": "case h\nn : \u2115\nS : Type u_3\ninst\u271d : MonoidWithZero S\nx : S\nN : \u2115\nhN : x ^ N = 0\n\u22a2 x ^ (n * N) * x ^ N = 0"}, {"line": "rw [hN]", "tactic_state": "case h\nn : \u2115\nS : Type u_3\ninst\u271d : MonoidWithZero S\nx : S\nN : \u2115\nhN : x ^ N = 0\n\u22a2 x ^ (n * N) * 0 = 0"}, {"line": "rw [mul_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsNilpotent.map [MonoidWithZero R] [MonoidWithZero S] {r : R} {F : Type*}\n    [FunLike F R S] [MonoidWithZeroHomClass F R S] (hr : IsNilpotent r) (f : F) :\n    IsNilpotent (f r) := by\n  use hr.choose\n  rw [\u2190 map_pow]\n  rw [hr.choose_spec]\n  rw [map_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Nilpotent/Defs.lean", "context": {"open": ["Function Set"], "variables": ["{R S : Type*} {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : MonoidWithZero R\ninst\u271d\u00b2 : MonoidWithZero S\nr : R\nF : Type u_3\ninst\u271d\u00b9 : FunLike F R S\ninst\u271d : MonoidWithZeroHomClass F R S\nhr : IsNilpotent r\nf : F\n\u22a2 IsNilpotent (f r)"}, {"line": "use hr.choose", "tactic_state": "case h\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : MonoidWithZero R\ninst\u271d\u00b2 : MonoidWithZero S\nr : R\nF : Type u_3\ninst\u271d\u00b9 : FunLike F R S\ninst\u271d : MonoidWithZeroHomClass F R S\nhr : IsNilpotent r\nf : F\n\u22a2 f r ^ Exists.choose hr = 0"}, {"line": "rw [\u2190 map_pow]", "tactic_state": "case h\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : MonoidWithZero R\ninst\u271d\u00b2 : MonoidWithZero S\nr : R\nF : Type u_3\ninst\u271d\u00b9 : FunLike F R S\ninst\u271d : MonoidWithZeroHomClass F R S\nhr : IsNilpotent r\nf : F\n\u22a2 f (r ^ Exists.choose hr) = 0\n---\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : MonoidWithZero R\ninst\u271d\u00b2 : MonoidWithZero S\nr : R\nF : Type u_3\ninst\u271d\u00b9 : FunLike F R S\ninst\u271d : MonoidWithZeroHomClass F R S\nhr : IsNilpotent r\nf : F\n\u22a2 Monoid R\n---\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : MonoidWithZero R\ninst\u271d\u00b2 : MonoidWithZero S\nr : R\nF : Type u_3\ninst\u271d\u00b9 : FunLike F R S\ninst\u271d : MonoidWithZeroHomClass F R S\nhr : IsNilpotent r\nf : F\n\u22a2 MonoidHomClass F R S"}, {"line": "rw [hr.choose_spec]", "tactic_state": "case h\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : MonoidWithZero R\ninst\u271d\u00b2 : MonoidWithZero S\nr : R\nF : Type u_3\ninst\u271d\u00b9 : FunLike F R S\ninst\u271d : MonoidWithZeroHomClass F R S\nhr : IsNilpotent r\nf : F\n\u22a2 f 0 = 0\n---\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : MonoidWithZero R\ninst\u271d\u00b2 : MonoidWithZero S\nr : R\nF : Type u_3\ninst\u271d\u00b9 : FunLike F R S\ninst\u271d : MonoidWithZeroHomClass F R S\nhr : IsNilpotent r\nf : F\n\u22a2 MonoidHomClass F R S"}, {"line": "rw [map_zero]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : MonoidWithZero R\ninst\u271d\u00b2 : MonoidWithZero S\nr : R\nF : Type u_3\ninst\u271d\u00b9 : FunLike F R S\ninst\u271d : MonoidWithZeroHomClass F R S\nhr : IsNilpotent r\nf : F\n\u22a2 ZeroHomClass F R S\n---\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : MonoidWithZero R\ninst\u271d\u00b2 : MonoidWithZero S\nr : R\nF : Type u_3\ninst\u271d\u00b9 : FunLike F R S\ninst\u271d : MonoidWithZeroHomClass F R S\nhr : IsNilpotent r\nf : F\n\u22a2 MonoidHomClass F R S"}]}
{"declaration": "lemma nilpotencyClass_eq_succ_iff {k : \u2115} :\n    nilpotencyClass x = k + 1 \u2194 x ^ (k + 1) = 0 \u2227 x ^ k \u2260 0 := by\n  let s : Set \u2115 := {k | x ^ k = 0}\n  have : \u2200 k\u2081 k\u2082 : \u2115, k\u2081 \u2264 k\u2082 \u2192 k\u2081 \u2208 s \u2192 k\u2082 \u2208 s := fun k\u2081 k\u2082 h_le hk\u2081 \u21a6 pow_eq_zero_of_le h_le hk\u2081\n  simp [s, nilpotencyClass, Nat.sInf_upward_closed_eq_succ_iff this]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Nilpotent/Defs.lean", "context": {"open": ["Function Set"], "variables": ["{R S : Type*} {x y : R}", "[Zero R] [Pow R \u2115]", "(x) in", "[MonoidWithZero R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nx : R\ninst\u271d\u00b9 : Zero R\ninst\u271d : Pow R \u2115\nk : \u2115\n\u22a2 nilpotencyClass x = k + 1 \u2194 x ^ (k + 1) = 0 \u2227 x ^ k \u2260 0"}, {"line": "let s : Set \u2115 := {k | x ^ k = 0}", "tactic_state": "R : Type u_1\nx : R\ninst\u271d\u00b9 : Zero R\ninst\u271d : Pow R \u2115\nk : \u2115\ns : Set \u2115 := {k | sorry}\n\u22a2 nilpotencyClass x = k + 1 \u2194 x ^ (k + 1) = 0 \u2227 x ^ k \u2260 0"}, {"line": "have : \u2200 k\u2081 k\u2082 : \u2115, k\u2081 \u2264 k\u2082 \u2192 k\u2081 \u2208 s \u2192 k\u2082 \u2208 s := fun k\u2081 k\u2082 h_le hk\u2081 \u21a6 pow_eq_zero_of_le h_le hk\u2081", "tactic_state": "R : Type u_1\nx : R\ninst\u271d\u00b9 : Zero R\ninst\u271d : Pow R \u2115\nk : \u2115\ns : Set \u2115 := {k | sorry}\nthis : \u2200 (k\u2081 k\u2082 : \u2115), k\u2081 \u2264 k\u2082 \u2192 k\u2081 \u2208 s \u2192 k\u2082 \u2208 s\n\u22a2 nilpotencyClass x = k + 1 \u2194 x ^ (k + 1) = 0 \u2227 x ^ k \u2260 0"}, {"line": "simp [s, nilpotencyClass, Nat.sInf_upward_closed_eq_succ_iff this]", "tactic_state": "R : Type u_1\nx : R\ninst\u271d\u00b9 : Zero R\ninst\u271d : Pow R \u2115\nk : \u2115\ns : Set \u2115 := {k | sorry}\nthis : \u2200 (k\u2081 k\u2082 : \u2115), k\u2081 \u2264 k\u2082 \u2192 k\u2081 \u2208 s \u2192 k\u2082 \u2208 s\n\u22a2 sInf {k | x ^ k = 0} = k + 1 \u2194 x ^ (k + 1) = 0 \u2227 \u00acx ^ k = 0"}]}
{"declaration": "theorem pow_eq_zero_iff' [MonoidWithZero R] [IsReduced R] [Nontrivial R] {n : \u2115} :\n    x ^ n = 0 \u2194 x = 0 \u2227 n \u2260 0 := by\n  cases n <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Nilpotent/Defs.lean", "context": {"open": ["Function Set"], "variables": ["{R S : Type*} {x y : R}", "[Zero R] [Pow R \u2115]", "(x) in", "[MonoidWithZero R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nx : R\ninst\u271d\u2074 : Zero R\ninst\u271d\u00b3 : Pow R \u2115\ninst\u271d\u00b2 : MonoidWithZero R\ninst\u271d\u00b9 : IsReduced R\ninst\u271d : Nontrivial R\nn : \u2115\n\u22a2 x ^ n = 0 \u2194 x = 0 \u2227 n \u2260 0"}, {"line": "cases n <;> simp", "tactic_state": "case zero\nR : Type u_1\nx : R\ninst\u271d\u2074 : Zero R\ninst\u271d\u00b3 : Pow R \u2115\ninst\u271d\u00b2 : MonoidWithZero R\ninst\u271d\u00b9 : IsReduced R\ninst\u271d : Nontrivial R\n\u22a2 \u00acx ^ 0 = 0\n---\ncase succ\nR : Type u_1\nx : R\ninst\u271d\u2074 : Zero R\ninst\u271d\u00b3 : Pow R \u2115\ninst\u271d\u00b2 : MonoidWithZero R\ninst\u271d\u00b9 : IsReduced R\ninst\u271d : Nontrivial R\nn\u271d : \u2115\n\u22a2 x ^ (n\u271d + 1) = 0 \u2194 x = 0"}]}
{"declaration": "theorem exp_zero :\n    exp (0 : A) = 1 := by\n  simp [exp_eq_sum (pow_one 0)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Nilpotent/Exp.lean", "context": {"open": ["Finset", "scoped Nat"], "variables": ["{A : Type*} [Ring A] [Module \u211a A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nexp : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [exp_eq_sum (pow_one 0)]", "tactic_state": "x\u271d : Sort u_2\nexp : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem exp_mul_exp_neg_self {a : A} (h : IsNilpotent a) :\n    exp a * exp (-a) = 1 := by\n  simp [\u2190 exp_add_of_commute (Commute.neg_right rfl) h h.neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Nilpotent/Exp.lean", "context": {"open": ["Finset", "scoped Nat"], "variables": ["{A : Type*} [Ring A] [Module \u211a A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\ninst\u271d\u00b9 : Ring A\ninst\u271d : Module \u211a A\nx\u271d : Sort u_2\nexp : x\u271d\na : A\nh : IsNilpotent a\n\u22a2 sorry * sorry = 1"}, {"line": "simp [\u2190 exp_add_of_commute (Commute.neg_right rfl) h h.neg]", "tactic_state": "A : Type u_1\ninst\u271d\u00b9 : Ring A\ninst\u271d : Module \u211a A\nx\u271d : Sort u_2\nexp : x\u271d\na : A\nh : IsNilpotent a\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem exp_neg_mul_exp_self {a : A} (h : IsNilpotent a) :\n    exp (- a) * exp a = 1 := by\n  simp [\u2190 exp_add_of_commute (Commute.neg_left rfl) h.neg h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Nilpotent/Exp.lean", "context": {"open": ["Finset", "scoped Nat"], "variables": ["{A : Type*} [Ring A] [Module \u211a A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\ninst\u271d\u00b9 : Ring A\ninst\u271d : Module \u211a A\nx\u271d : Sort u_2\nexp : x\u271d\na : A\nh : IsNilpotent a\n\u22a2 sorry * sorry = 1"}, {"line": "simp [\u2190 exp_add_of_commute (Commute.neg_left rfl) h.neg h]", "tactic_state": "A : Type u_1\ninst\u271d\u00b9 : Ring A\ninst\u271d : Module \u211a A\nx\u271d : Sort u_2\nexp : x\u271d\na : A\nh : IsNilpotent a\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem map_exp {B F : Type*} [Ring B] [FunLike F A B] [RingHomClass F A B] [Module \u211a B]\n    {a : A} (ha : IsNilpotent a) (f : F) :\n    f (exp a) = exp (f a) := by\n  obtain \u27e8k, hk\u27e9 := ha\n  have hk' : (f a) ^ k = 0 := by simp [\u2190 map_pow, hk]\n  simp [exp_eq_sum hk, exp_eq_sum hk', map_rat_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Nilpotent/Exp.lean", "context": {"open": ["Finset", "scoped Nat"], "variables": ["{A : Type*} [Ring A] [Module \u211a A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\ninst\u271d\u2075 : Ring A\ninst\u271d\u2074 : Module \u211a A\nx\u271d : Sort u_4\nexp : x\u271d\nB : Type u_2\nF : Type u_3\ninst\u271d\u00b3 : Ring B\ninst\u271d\u00b2 : FunLike F A B\ninst\u271d\u00b9 : RingHomClass F A B\ninst\u271d : Module \u211a B\na : A\nha : IsNilpotent a\nf : F\n\u22a2 f sorry = sorry"}, {"line": "obtain \u27e8k, hk\u27e9 := ha", "tactic_state": "case intro\nA : Type u_1\ninst\u271d\u2075 : Ring A\ninst\u271d\u2074 : Module \u211a A\nx\u271d : Sort u_4\nexp : x\u271d\nB : Type u_2\nF : Type u_3\ninst\u271d\u00b3 : Ring B\ninst\u271d\u00b2 : FunLike F A B\ninst\u271d\u00b9 : RingHomClass F A B\ninst\u271d : Module \u211a B\na : A\nf : F\nk : \u2115\nhk : a ^ k = 0\n\u22a2 f sorry = sorry"}, {"line": "have hk' : (f a) ^ k = 0 := by simp [\u2190 map_pow, hk]", "tactic_state": "case intro\nA : Type u_1\ninst\u271d\u2075 : Ring A\ninst\u271d\u2074 : Module \u211a A\nx\u271d : Sort u_4\nexp : x\u271d\nB : Type u_2\nF : Type u_3\ninst\u271d\u00b3 : Ring B\ninst\u271d\u00b2 : FunLike F A B\ninst\u271d\u00b9 : RingHomClass F A B\ninst\u271d : Module \u211a B\na : A\nf : F\nk : \u2115\nhk : a ^ k = 0\nhk' : sorry ^ k = 0\n\u22a2 f sorry = sorry"}, {"line": "simp [exp_eq_sum hk, exp_eq_sum hk', map_rat_smul]", "tactic_state": "case intro\nA : Type u_1\ninst\u271d\u2075 : Ring A\ninst\u271d\u2074 : Module \u211a A\nx\u271d : Sort u_4\nexp : x\u271d\nB : Type u_2\nF : Type u_3\ninst\u271d\u00b3 : Ring B\ninst\u271d\u00b2 : FunLike F A B\ninst\u271d\u00b9 : RingHomClass F A B\ninst\u271d : Module \u211a B\na : A\nf : F\nk : \u2115\nhk : a ^ k = 0\nhk' : sorry ^ k = 0\n\u22a2 f (sorry ()) = sorry ()"}]}
{"declaration": "theorem LinearMap.isNoetherian_iff_of_bijective {S P} [Semiring S] [AddCommMonoid P] [Module S P]\n    {\u03c3 : R \u2192+* S} [RingHomSurjective \u03c3] (l : M \u2192\u209b\u2097[\u03c3] P) (hl : Function.Bijective l) :\n    IsNoetherian R M \u2194 IsNoetherian S P := by\n  simp_rw [isNoetherian_iff']\n  let e := Submodule.orderIsoMapComapOfBijective l hl\n  exact \u27e8fun _ \u21a6 e.symm.strictMono.wellFoundedGT, fun _ \u21a6 e.strictMono.wellFoundedGT\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Noetherian/Basic.lean", "context": {"open": ["Set Pointwise", "IsNoetherian", "IsNoetherian", "IsNoetherian Submodule Function"], "variables": ["{R M P : Type*}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid P]", "[Module R M] [Module R P]", "(M) in", "{R M N : Type*}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid N] [Module R M] [Module R N]", "(R M)", "{R M}", "{R M N P : Type*}", "[Ring R] [AddCommGroup M] [AddCommGroup N] [AddCommGroup P]", "[Module R M] [Module R N] [Module R P]", "{\u03b9 : Type*} [Finite \u03b9]", "(R M N : Type*) [CommRing R] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "{R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_12\nM : Type u_13\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nS : Type u_14\nP : Type u_15\ninst\u271d\u00b3 : Semiring S\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module S P\n\u03c3 : R \u2192+* S\ninst\u271d : RingHomSurjective \u03c3\nl : M \u2192\u209b\u2097[\u03c3] P\nhl : Bijective \u21d1l\n\u22a2 IsNoetherian R M \u2194 IsNoetherian S P"}, {"line": "simp_rw [isNoetherian_iff']", "tactic_state": "R : Type u_12\nM : Type u_13\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nS : Type u_14\nP : Type u_15\ninst\u271d\u00b3 : Semiring S\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module S P\n\u03c3 : R \u2192+* S\ninst\u271d : RingHomSurjective \u03c3\nl : M \u2192\u209b\u2097[\u03c3] P\nhl : Bijective \u21d1l\n\u22a2 WellFoundedGT (Submodule R M) \u2194 WellFoundedGT (Submodule S P)"}, {"line": "let e := Submodule.orderIsoMapComapOfBijective l hl", "tactic_state": "R : Type u_12\nM : Type u_13\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nS : Type u_14\nP : Type u_15\ninst\u271d\u00b3 : Semiring S\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module S P\n\u03c3 : R \u2192+* S\ninst\u271d : RingHomSurjective \u03c3\nl : M \u2192\u209b\u2097[\u03c3] P\nhl : Bijective \u21d1l\ne : Submodule R M \u2243o Submodule S P := sorry\n\u22a2 WellFoundedGT (Submodule R M) \u2194 WellFoundedGT (Submodule S P)"}, {"line": "exact \u27e8fun _ \u21a6 e.symm.strictMono.wellFoundedGT, fun _ \u21a6 e.strictMono.wellFoundedGT\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsNoetherian.disjoint_partialSups_eventually_bot\n    (f : \u2115 \u2192 Submodule R M) (h : \u2200 n, Disjoint (partialSups f n) (f (n + 1))) :\n    \u2203 n : \u2115, \u2200 m, n \u2264 m \u2192 f m = \u22a5 := by\n  -- A little off-by-one cleanup first:\n  suffices t : \u2203 n : \u2115, \u2200 m, n \u2264 m \u2192 f (m + 1) = \u22a5 by\n    obtain \u27e8n, w\u27e9 := t\n    use n + 1\n    rintro (_ | m) p\n    \u00b7 cases p\n    \u00b7 apply w\n      exact Nat.succ_le_succ_iff.mp p\n  obtain \u27e8n, w\u27e9 := monotone_stabilizes_iff_noetherian.mpr inferInstance (partialSups f)\n  refine \u27e8n, fun m p \u21a6 (h m).eq_bot_of_ge <| sup_eq_left.mp ?_\u27e9\n  simpa only [partialSups_add_one] using (w (m + 1) <| le_add_right p).symm.trans <| w m p\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Noetherian/Basic.lean", "context": {"open": ["Set Pointwise", "IsNoetherian", "IsNoetherian", "IsNoetherian Submodule Function"], "variables": ["{R M P : Type*}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid P]", "[Module R M] [Module R P]", "(M) in", "{R M N : Type*}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid N] [Module R M] [Module R N]", "(R M)", "{R M}", "{R M N P : Type*}", "[Ring R] [AddCommGroup M] [AddCommGroup N] [AddCommGroup P]", "[Module R M] [Module R N] [Module R P]", "{\u03b9 : Type*} [Finite \u03b9]", "(R M N : Type*) [CommRing R] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "{R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M]", "{R M N P : Type*} [Semiring R] [AddCommMonoid M] [Module R M] [IsNoetherian R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_14\nM : Type u_15\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsNoetherian R M\nf : \u2115 \u2192 Submodule R M\nh : \u2200 (n : \u2115), Disjoint ((partialSups f) n) (f (n + 1))\n\u22a2 \u2203 n, \u2200 (m : \u2115), n \u2264 m \u2192 f m = \u22a5"}, {"line": "suffices t : \u2203 n : \u2115, \u2200 m, n \u2264 m \u2192 f (m + 1) = \u22a5 by\n    obtain \u27e8n, w\u27e9 := t\n    use n + 1\n    rintro (_ | m) p\n    \u00b7 cases p\n    \u00b7 apply w\n      exact Nat.succ_le_succ_iff.mp p", "tactic_state": "R : Type u_14\nM : Type u_15\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsNoetherian R M\nf : \u2115 \u2192 Submodule R M\nh : \u2200 (n : \u2115), Disjoint ((partialSups f) n) (f (n + 1))\n\u22a2 \u2203 n, \u2200 (m : \u2115), n \u2264 m \u2192 f (m + 1) = \u22a5"}, {"line": "obtain \u27e8n, w\u27e9 := monotone_stabilizes_iff_noetherian.mpr inferInstance (partialSups f)", "tactic_state": "case intro\nR : Type u_14\nM : Type u_15\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsNoetherian R M\nf : \u2115 \u2192 Submodule R M\nh : \u2200 (n : \u2115), Disjoint ((partialSups f) n) (f (n + 1))\nn : \u2115\nw : \u2200 (m : \u2115), n \u2264 m \u2192 (partialSups f) n = (partialSups f) m\n\u22a2 \u2203 n, \u2200 (m : \u2115), n \u2264 m \u2192 f (m + 1) = \u22a5"}, {"line": "refine \u27e8n, fun m p \u21a6 (h m).eq_bot_of_ge <| sup_eq_left.mp ?_\u27e9", "tactic_state": "case intro\nR : Type u_14\nM : Type u_15\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsNoetherian R M\nf : \u2115 \u2192 Submodule R M\nh : \u2200 (n : \u2115), Disjoint ((partialSups f) n) (f (n + 1))\nn : \u2115\nw : \u2200 (m : \u2115), n \u2264 m \u2192 (partialSups f) n = (partialSups f) m\nm : \u2115\np : n \u2264 m\n\u22a2 (partialSups f) m \u2294 f (m + 1) = (partialSups f) m"}, {"line": "simpa only [partialSups_add_one] using (w (m + 1) <| le_add_right p).symm.trans <| w m p", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isNoetherian_iff :\n    IsNoetherian R M \u2194 WellFounded ((\u00b7 > \u00b7) : Submodule R M \u2192 Submodule R M \u2192 Prop) := by\n  rw [isNoetherian_iff']\n  rw [\u2190 isWellFounded_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Noetherian/Defs.lean", "context": {"open": ["Set Pointwise", "IsNoetherian", "IsNoetherian Submodule Function"], "variables": ["{R : Type*} {M : Type*} {P : Type*}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid P]", "[Module R M] [Module R P]", "{R M P : Type*} {N : Type w} [Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\nM : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u22a2 IsNoetherian R M \u2194 WellFounded fun x1 x2 => x1 > x2"}, {"line": "rw [isNoetherian_iff']", "tactic_state": "R : Type u_4\nM : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u22a2 WellFoundedGT (Submodule R M) \u2194 WellFounded fun x1 x2 => x1 > x2"}, {"line": "rw [\u2190 isWellFounded_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem set_has_maximal_iff_noetherian :\n    (\u2200 a : Set <| Submodule R M, a.Nonempty \u2192 \u2203 M' \u2208 a, \u2200 I \u2208 a, \u00acM' < I) \u2194 IsNoetherian R M := by\n  rw [isNoetherian_iff]\n  rw [WellFounded.wellFounded_iff_has_min]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Noetherian/Defs.lean", "context": {"open": ["Set Pointwise", "IsNoetherian", "IsNoetherian Submodule Function"], "variables": ["{R : Type*} {M : Type*} {P : Type*}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid P]", "[Module R M] [Module R P]", "{R M P : Type*} {N : Type w} [Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\nM : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u22a2 (\u2200 (a : Set (Submodule R M)), a.Nonempty \u2192 \u2203 M' \u2208 a, \u2200 I \u2208 a, \u00acM' < I) \u2194 IsNoetherian R M"}, {"line": "rw [isNoetherian_iff]", "tactic_state": "R : Type u_4\nM : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u22a2 (\u2200 (a : Set (Submodule R M)), a.Nonempty \u2192 \u2203 M' \u2208 a, \u2200 I \u2208 a, \u00acM' < I) \u2194 WellFounded fun x1 x2 => x1 > x2"}, {"line": "rw [WellFounded.wellFounded_iff_has_min]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem monotone_stabilizes_iff_noetherian :\n    (\u2200 f : \u2115 \u2192o Submodule R M, \u2203 n, \u2200 m, n \u2264 m \u2192 f n = f m) \u2194 IsNoetherian R M := by\n  rw [isNoetherian_iff']\n  rw [wellFoundedGT_iff_monotone_chain_condition]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Noetherian/Defs.lean", "context": {"open": ["Set Pointwise", "IsNoetherian", "IsNoetherian Submodule Function"], "variables": ["{R : Type*} {M : Type*} {P : Type*}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid P]", "[Module R M] [Module R P]", "{R M P : Type*} {N : Type w} [Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\nM : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u22a2 (\u2200 (f : \u2115 \u2192o Submodule R M), \u2203 n, \u2200 (m : \u2115), n \u2264 m \u2192 f n = f m) \u2194 IsNoetherian R M"}, {"line": "rw [isNoetherian_iff']", "tactic_state": "R : Type u_4\nM : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u22a2 (\u2200 (f : \u2115 \u2192o Submodule R M), \u2203 n, \u2200 (m : \u2115), n \u2264 m \u2192 f n = f m) \u2194 WellFoundedGT (Submodule R M)"}, {"line": "rw [wellFoundedGT_iff_monotone_chain_condition]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 NonUnitalSubring R} {x : R} :\n    (x \u2208 \u2a05 i, S i) \u2194 \u2200 i, x \u2208 S i := by simp only [iInf, mem_sInf, Set.forall_mem_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/NonUnitalSubring/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} {S : Type v} [NonUnitalNonAssocRing R]", "(s : NonUnitalSubring R)", "{F : Type w} {R : Type u} {S : Type v} {T : Type*}", "{R : Type u} {S : Type v} {T : Type*}", "{R : Type u} [NonUnitalNonAssocRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : NonUnitalNonAssocRing R\n\u03b9 : Sort u_3\nS : \u03b9 \u2192 NonUnitalSubring R\nx : R\n\u22a2 x \u2208 \u2a05 i, S i \u2194 \u2200 (i : \u03b9), x \u2208 S i"}, {"line": "simp only [iInf, mem_sInf, Set.forall_mem_range]", "tactic_state": "R : Type u\ninst\u271d : NonUnitalNonAssocRing R\n\u03b9 : Sort u_3\nS : \u03b9 \u2192 NonUnitalSubring R\nx : R\n\u22a2 x \u2208 sInf (Set.range fun i => S i) \u2194 \u2200 (i : \u03b9), x \u2208 S i"}]}
{"declaration": "theorem map_srange (g : S \u2192\u2099+* T) (f : R \u2192\u2099+* S) : map g (srange f) = srange (g.comp f) := by\n  simpa only [srange_eq_map] using (\u22a4 : NonUnitalSubsemiring R).map_map g f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "context": {"open": ["NonUnitalSubsemiring"], "variables": ["{R : Type u} {S : Type v} {T : Type w} [NonUnitalNonAssocSemiring R] (M : Subsemigroup R)", "[NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring T]", "{F G : Type*} [FunLike F R S] [NonUnitalRingHomClass F R S]", "[NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring T]", "{F G : Type*} [FunLike F R S] [NonUnitalRingHomClass F R S]", "[FunLike G S T] [NonUnitalRingHomClass G S T] (f : F) (g : G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2074 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring S\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring T\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring S\ninst\u271d : NonUnitalNonAssocSemiring T\nx\u271d : Sort u_5\nsrange : x\u271d\ng : S \u2192\u2099+* T\nf : R \u2192\u2099+* S\n\u22a2 map g sorry = sorry"}, {"line": "simpa only [srange_eq_map] using (\u22a4 : NonUnitalSubsemiring R).map_map g f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 NonUnitalSubsemiring R} :\n    (\u2191(\u2a05 i, S i) : Set R) = \u22c2 i, S i := by\n  simp only [iInf]\n  simp only [coe_sInf]\n  simp only [Set.biInter_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "context": {"open": ["NonUnitalSubsemiring"], "variables": ["{R : Type u} {S : Type v} {T : Type w} [NonUnitalNonAssocSemiring R] (M : Subsemigroup R)", "[NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring T]", "{F G : Type*} [FunLike F R S] [NonUnitalRingHomClass F R S]", "[NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring T]", "{F G : Type*} [FunLike F R S] [NonUnitalRingHomClass F R S]", "[FunLike G S T] [NonUnitalRingHomClass G S T] (f : F) (g : G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : NonUnitalNonAssocSemiring R\n\u03b9 : Sort u_5\nS : \u03b9 \u2192 NonUnitalSubsemiring R\n\u22a2 \u2191(\u2a05 i, S i) = \u22c2 i, \u2191(S i)"}, {"line": "simp only [iInf]", "tactic_state": "R : Type u\ninst\u271d : NonUnitalNonAssocSemiring R\n\u03b9 : Sort u_5\nS : \u03b9 \u2192 NonUnitalSubsemiring R\n\u22a2 \u2191(sInf (Set.range fun i => S i)) = \u22c2 i, \u2191(S i)"}, {"line": "simp only [coe_sInf]", "tactic_state": "R : Type u\ninst\u271d : NonUnitalNonAssocSemiring R\n\u03b9 : Sort u_5\nS : \u03b9 \u2192 NonUnitalSubsemiring R\n\u22a2 \u22c2 s \u2208 Set.range fun i => S i, \u2191s = \u22c2 i, \u2191(S i)"}, {"line": "simp only [Set.biInter_range]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 NonUnitalSubsemiring R} {x : R} :\n    (x \u2208 \u2a05 i, S i) \u2194 \u2200 i, x \u2208 S i := by\n  simp only [iInf]\n  simp only [mem_sInf]\n  simp only [Set.forall_mem_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "context": {"open": ["NonUnitalSubsemiring"], "variables": ["{R : Type u} {S : Type v} {T : Type w} [NonUnitalNonAssocSemiring R] (M : Subsemigroup R)", "[NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring T]", "{F G : Type*} [FunLike F R S] [NonUnitalRingHomClass F R S]", "[NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring T]", "{F G : Type*} [FunLike F R S] [NonUnitalRingHomClass F R S]", "[FunLike G S T] [NonUnitalRingHomClass G S T] (f : F) (g : G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : NonUnitalNonAssocSemiring R\n\u03b9 : Sort u_5\nS : \u03b9 \u2192 NonUnitalSubsemiring R\nx : R\n\u22a2 x \u2208 \u2a05 i, S i \u2194 \u2200 (i : \u03b9), x \u2208 S i"}, {"line": "simp only [iInf]", "tactic_state": "R : Type u\ninst\u271d : NonUnitalNonAssocSemiring R\n\u03b9 : Sort u_5\nS : \u03b9 \u2192 NonUnitalSubsemiring R\nx : R\n\u22a2 x \u2208 sInf (Set.range fun i => S i) \u2194 \u2200 (i : \u03b9), x \u2208 S i"}, {"line": "simp only [mem_sInf]", "tactic_state": "R : Type u\ninst\u271d : NonUnitalNonAssocSemiring R\n\u03b9 : Sort u_5\nS : \u03b9 \u2192 NonUnitalSubsemiring R\nx : R\n\u22a2 (\u2200 p \u2208 Set.range fun i => S i, x \u2208 p) \u2194 \u2200 (i : \u03b9), x \u2208 S i"}, {"line": "simp only [Set.forall_mem_range]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.Set.mem_center_iff_addMonoidHom (a : R) :\n    a \u2208 Set.center R \u2194\n      AddMonoidHom.mulLeft a = .mulRight a \u2227\n      AddMonoidHom.compr\u2082 .mul (.mulLeft a) = .comp .mul (.mulLeft a) \u2227\n      AddMonoidHom.comp .mul (.mulRight a) = .compl\u2082 .mul (.mulLeft a) \u2227\n      AddMonoidHom.compr\u2082 .mul (.mulRight a) = .compl\u2082 .mul (.mulRight a) := by\n  rw [Set.mem_center_iff]\n  rw [isMulCentral_iff]\n  simp [DFunLike.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "context": {"open": ["NonUnitalSubsemiring"], "variables": ["{R : Type u} {S : Type v} {T : Type w} [NonUnitalNonAssocSemiring R] (M : Subsemigroup R)", "[NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring T]", "{F G : Type*} [FunLike F R S] [NonUnitalRingHomClass F R S]", "[NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring T]", "{F G : Type*} [FunLike F R S] [NonUnitalRingHomClass F R S]", "[FunLike G S T] [NonUnitalRingHomClass G S T] (f : F) (g : G)", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : NonUnitalNonAssocSemiring R\na : R\n\u22a2 a \u2208 Set.center R \u2194\n    AddMonoidHom.mulLeft a = AddMonoidHom.mulRight a \u2227\n      AddMonoidHom.mul.compr\u2082 (AddMonoidHom.mulLeft a) = AddMonoidHom.mul.comp (AddMonoidHom.mulLeft a) \u2227\n        AddMonoidHom.mul.comp (AddMonoidHom.mulRight a) = AddMonoidHom.mul.compl\u2082 (AddMonoidHom.mulLeft a) \u2227\n          AddMonoidHom.mul.compr\u2082 (AddMonoidHom.mulRight a) = AddMonoidHom.mul.compl\u2082 (AddMonoidHom.mulRight a)"}, {"line": "rw [Set.mem_center_iff]", "tactic_state": "R : Type u\ninst\u271d : NonUnitalNonAssocSemiring R\na : R\n\u22a2 IsMulCentral a \u2194\n    AddMonoidHom.mulLeft a = AddMonoidHom.mulRight a \u2227\n      AddMonoidHom.mul.compr\u2082 (AddMonoidHom.mulLeft a) = AddMonoidHom.mul.comp (AddMonoidHom.mulLeft a) \u2227\n        AddMonoidHom.mul.comp (AddMonoidHom.mulRight a) = AddMonoidHom.mul.compl\u2082 (AddMonoidHom.mulLeft a) \u2227\n          AddMonoidHom.mul.compr\u2082 (AddMonoidHom.mulRight a) = AddMonoidHom.mul.compl\u2082 (AddMonoidHom.mulRight a)"}, {"line": "rw [isMulCentral_iff]", "tactic_state": "R : Type u\ninst\u271d : NonUnitalNonAssocSemiring R\na : R\n\u22a2 ((\u2200 (a_1 : R), a * a_1 = a_1 * a) \u2227\n      (\u2200 (b c : R), a * (b * c) = a * b * c) \u2227\n        (\u2200 (a_1 c : R), a_1 * a * c = a_1 * (a * c)) \u2227 \u2200 (a_1 b : R), a_1 * b * a = a_1 * (b * a)) \u2194\n    AddMonoidHom.mulLeft a = AddMonoidHom.mulRight a \u2227\n      AddMonoidHom.mul.compr\u2082 (AddMonoidHom.mulLeft a) = AddMonoidHom.mul.comp (AddMonoidHom.mulLeft a) \u2227\n        AddMonoidHom.mul.comp (AddMonoidHom.mulRight a) = AddMonoidHom.mul.compl\u2082 (AddMonoidHom.mulLeft a) \u2227\n          AddMonoidHom.mul.compr\u2082 (AddMonoidHom.mulRight a) = AddMonoidHom.mul.compl\u2082 (AddMonoidHom.mulRight a)"}, {"line": "simp [DFunLike.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "example {R} [NonUnitalSemiring R] :\n    (center.instNonUnitalCommSemiring _).toNonUnitalSemiring =\n      NonUnitalSubsemiringClass.toNonUnitalSemiring (center R) := by\n  with_reducible_and_instances rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "context": {"open": ["NonUnitalSubsemiring"], "variables": ["{R : Type u} {S : Type v} {T : Type w} [NonUnitalNonAssocSemiring R] (M : Subsemigroup R)", "[NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring T]", "{F G : Type*} [FunLike F R S] [NonUnitalRingHomClass F R S]", "[NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring T]", "{F G : Type*} [FunLike F R S] [NonUnitalRingHomClass F R S]", "[FunLike G S T] [NonUnitalRingHomClass G S T] (f : F) (g : G)", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u271d : Type u\nS : Type v\nT : Type w\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring R\u271d\nM : Subsemigroup R\u271d\ninst\u271d\u00b9\u2070 : NonUnitalNonAssocSemiring S\ninst\u271d\u2079 : NonUnitalNonAssocSemiring T\nF\u271d : Type u_1\nG\u271d : Type u_2\ninst\u271d\u2078 : FunLike F\u271d R\u271d S\ninst\u271d\u2077 : NonUnitalRingHomClass F\u271d R\u271d S\ninst\u271d\u2076 : NonUnitalNonAssocSemiring S\ninst\u271d\u2075 : NonUnitalNonAssocSemiring T\nF : Type u_3\nG : Type u_4\ninst\u271d\u2074 : FunLike F R\u271d S\ninst\u271d\u00b3 : NonUnitalRingHomClass F R\u271d S\ninst\u271d\u00b2 : FunLike G S T\ninst\u271d\u00b9 : NonUnitalRingHomClass G S T\nf : F\ng : G\nR : Type u_5\ninst\u271d : NonUnitalSemiring R\n\u22a2 NonUnitalCommSemiring.toNonUnitalSemiring = NonUnitalSubsemiringClass.toNonUnitalSemiring (center R)"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_map_equiv {f : R \u2243+* S} {K : NonUnitalSubsemiring R} {x : S} :\n    x \u2208 K.map (f : R \u2192\u2099+* S) \u2194 f.symm x \u2208 K := by\n  convert @Set.mem_image_equiv _ _ (\u2191K) f.toEquiv x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "context": {"open": ["NonUnitalSubsemiring"], "variables": ["{R : Type u} {S : Type v} {T : Type w} [NonUnitalNonAssocSemiring R] (M : Subsemigroup R)", "[NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring T]", "{F G : Type*} [FunLike F R S] [NonUnitalRingHomClass F R S]", "[NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring T]", "{F G : Type*} [FunLike F R S] [NonUnitalRingHomClass F R S]", "[FunLike G S T] [NonUnitalRingHomClass G S T] (f : F) (g : G)", "(R)", "{R}", "[NonUnitalNonAssocSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : NonUnitalNonAssocSemiring S\nf : R \u2243+* S\nK : NonUnitalSubsemiring R\nx : S\n\u22a2 x \u2208 map (\u2191f) K \u2194 f.symm x \u2208 K"}, {"line": "convert @Set.mem_image_equiv _ _ (\u2191K) f.toEquiv x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_closure_eq (s : Set R) :\n    (closure s : Set R) = AddSubmonoid.closure (Subsemigroup.closure s : Set R) := by\n  simp [\u2190 Subsemigroup.nonUnitalSubsemiringClosure_toAddSubmonoid,\n    Subsemigroup.nonUnitalSubsemiringClosure_eq_closure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "context": {"open": ["NonUnitalSubsemiring"], "variables": ["{R : Type u} {S : Type v} {T : Type w} [NonUnitalNonAssocSemiring R] (M : Subsemigroup R)", "[NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring T]", "{F G : Type*} [FunLike F R S] [NonUnitalRingHomClass F R S]", "[NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring T]", "{F G : Type*} [FunLike F R S] [NonUnitalRingHomClass F R S]", "[FunLike G S T] [NonUnitalRingHomClass G S T] (f : F) (g : G)", "(R)", "{R}", "[NonUnitalNonAssocSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : NonUnitalNonAssocSemiring R\ns : Set R\n\u22a2 \u2191(NonUnitalSubsemiring.closure s) = \u2191(AddSubmonoid.closure \u2191(Subsemigroup.closure s))"}, {"line": "simp [\u2190 Subsemigroup.nonUnitalSubsemiringClosure_toAddSubmonoid,\n    Subsemigroup.nonUnitalSubsemiringClosure_eq_closure]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_iInf {\u03b9 : Sort*} [Nonempty \u03b9] (f : F) (hf : Function.Injective f)\n    (s : \u03b9 \u2192 NonUnitalSubsemiring R) :\n    (map f (iInf s) : NonUnitalSubsemiring S) = \u2a05 i, map f (s i) := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe \u2218 s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "context": {"open": ["NonUnitalSubsemiring"], "variables": ["{R : Type u} {S : Type v} {T : Type w} [NonUnitalNonAssocSemiring R] (M : Subsemigroup R)", "[NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring T]", "{F G : Type*} [FunLike F R S] [NonUnitalRingHomClass F R S]", "[NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring T]", "{F G : Type*} [FunLike F R S] [NonUnitalRingHomClass F R S]", "[FunLike G S T] [NonUnitalRingHomClass G S T] (f : F) (g : G)", "(R)", "{R}", "[NonUnitalNonAssocSemiring S]", "(R) in", "[NonUnitalNonAssocSemiring S]", "{F : Type*} [FunLike F R S] [NonUnitalRingHomClass F R S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u2076 : NonUnitalNonAssocSemiring R\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : NonUnitalNonAssocSemiring S\nF : Type u_5\ninst\u271d\u00b2 : FunLike F R S\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\n\u03b9 : Sort u_6\ninst\u271d : Nonempty \u03b9\nf : F\nhf : Function.Injective \u21d1f\ns : \u03b9 \u2192 NonUnitalSubsemiring R\n\u22a2 map f (iInf s) = \u2a05 i, map f (s i)"}, {"line": "apply SetLike.coe_injective", "tactic_state": "case a\nR : Type u\nS : Type v\ninst\u271d\u2076 : NonUnitalNonAssocSemiring R\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : NonUnitalNonAssocSemiring S\nF : Type u_5\ninst\u271d\u00b2 : FunLike F R S\ninst\u271d\u00b9 : NonUnitalRingHomClass F R S\n\u03b9 : Sort u_6\ninst\u271d : Nonempty \u03b9\nf : F\nhf : Function.Injective \u21d1f\ns : \u03b9 \u2192 NonUnitalSubsemiring R\n\u22a2 \u2191(map f (iInf s)) = \u2191(\u2a05 i, map f (s i))"}, {"line": "simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe \u2218 s)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_eq_zero_iff_of_basis [IsDomain R] [IsDomain S] (b : Basis \u03b9 R S) {x : S} :\n    Algebra.norm R x = 0 \u2194 x = 0 := by\n  haveI : Module.Free R S := Module.Free.of_basis b\n  haveI : Module.Finite R S := Module.Finite.of_basis b\n  exact norm_eq_zero_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Norm/Basic.lean", "context": {"open": ["Module", "LinearMap", "Matrix Polynomial", "scoped Matrix"], "variables": ["{R S T : Type*} [CommRing R] [Ring S]", "[Algebra R S]", "{K L F : Type*} [Field K] [Field L] [Field F]", "[Algebra K L] [Algebra K F]", "{\u03b9 : Type w}", "[Finite \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : Ring S\ninst\u271d\u00b3 : Algebra R S\n\u03b9 : Type w\ninst\u271d\u00b2 : Finite \u03b9\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDomain S\nb : Basis \u03b9 R S\nx : S\n\u22a2 (Algebra.norm R) x = 0 \u2194 x = 0"}, {"line": "haveI : Module.Free R S := Module.Free.of_basis b", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : Ring S\ninst\u271d\u00b3 : Algebra R S\n\u03b9 : Type w\ninst\u271d\u00b2 : Finite \u03b9\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDomain S\nb : Basis \u03b9 R S\nx : S\nthis : sorry\n\u22a2 (Algebra.norm R) x = 0 \u2194 x = 0"}, {"line": "haveI : Module.Finite R S := Module.Finite.of_basis b", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : Ring S\ninst\u271d\u00b3 : Algebra R S\n\u03b9 : Type w\ninst\u271d\u00b2 : Finite \u03b9\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDomain S\nb : Basis \u03b9 R S\nx : S\nthis\u271d : sorry\nthis : sorry\n\u22a2 (Algebra.norm R) x = 0 \u2194 x = 0"}, {"line": "exact norm_eq_zero_iff", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_auxMat_corner : (M * auxMat M k) k k = M k k := by simp [Matrix.mul_apply, auxMat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Norm/Transitivity.lean", "context": {"open": ["Matrix Polynomial"], "variables": ["{R S A n m : Type*} [CommRing R] [CommRing S]", "(M : Matrix m m S) [DecidableEq m] [DecidableEq n] (k : m)", "[Fintype m]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_2\nm : Type u_5\ninst\u271d\u00b2 : CommRing S\nM : Matrix m m S\ninst\u271d\u00b9 : DecidableEq m\nk : m\ninst\u271d : Fintype m\nx\u271d : Sort u_6\nauxMat : x\u271d\n\u22a2 sorry = M k k"}, {"line": "simp [Matrix.mul_apply, auxMat]", "tactic_state": "S : Type u_2\nm : Type u_5\ninst\u271d\u00b2 : CommRing S\nM : Matrix m m S\ninst\u271d\u00b9 : DecidableEq m\nk : m\ninst\u271d : Fintype m\nx\u271d : Sort u_6\nauxMat : x\u271d\n\u22a2 sorry () = M k k"}]}
{"declaration": "lemma polyToMatrix_cornerAddX :\n    f.polyToMatrix (cornerAddX M k k k) = (-f (M k k)).charmatrix := by\n  simp [cornerAddX, Matrix.add_apply, charmatrix,\n    RingHom.polyToMatrix, \u2190 AlgEquiv.symm_toRingEquiv, map_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Norm/Transitivity.lean", "context": {"open": ["Matrix Polynomial"], "variables": ["{R S A n m : Type*} [CommRing R] [CommRing S]", "(M : Matrix m m S) [DecidableEq m] [DecidableEq n] (k : m)", "[Fintype m]", "[Fintype n] (f : S \u2192+* Matrix n n R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\nn : Type u_4\nm : Type u_5\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing S\nM : Matrix m m S\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\nk : m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nf : S \u2192+* Matrix n n R\nx\u271d : Sort u_6\ncornerAddX : x\u271d\n\u22a2 f.polyToMatrix sorry = (-f (M k k)).charmatrix"}, {"line": "simp [cornerAddX, Matrix.add_apply, charmatrix,\n    RingHom.polyToMatrix, \u2190 AlgEquiv.symm_toRingEquiv, map_neg]", "tactic_state": "R : Type u_1\nS : Type u_2\nn : Type u_4\nm : Type u_5\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing S\nM : Matrix m m S\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\nk : m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nf : S \u2192+* Matrix n n R\nx\u271d : Sort u_6\ncornerAddX : x\u271d\n\u22a2 matPolyEquiv.symm (Polynomial.map f (sorry ())) = (diagonal fun x => X) - (-f (M k k)).map \u21d1C"}]}
{"declaration": "theorem zero_oreDiv' (s : S) : (0 : R) /\u2092 s = 0 := by\n  rw [OreLocalization.zero_def]\n  rw [oreDiv_eq_iff]\n  exact \u27e8s, 1, by simp [Submonoid.smul_def]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/OreLocalization/Basic.lean", "context": {"open": ["OreLocalization"], "variables": ["{R : Type*} [MonoidWithZero R] {S : Submonoid R} [OreSet S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : MonoidWithZero R\nS : Submonoid R\ninst\u271d : OreSet S\ns : \u21a5S\n\u22a2 0 /\u2092 s = 0"}, {"line": "rw [OreLocalization.zero_def]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : MonoidWithZero R\nS : Submonoid R\ninst\u271d : OreSet S\ns : \u21a5S\n\u22a2 0 /\u2092 s = 0 /\u2092 1"}, {"line": "rw [oreDiv_eq_iff]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : MonoidWithZero R\nS : Submonoid R\ninst\u271d : OreSet S\ns : \u21a5S\n\u22a2 \u2203 u v, u \u2022 0 = v \u2022 0 \u2227 \u2191u * \u21911 = v * \u2191s"}, {"line": "exact \u27e8s, 1, by simp [Submonoid.smul_def]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oreDiv_add_oreDiv {r r' : X} {s s' : S} :\n    r /\u2092 s + r' /\u2092 s' =\n      (oreDenom (s : R) s' \u2022 r + oreNum (s : R) s' \u2022 r') /\u2092 (oreDenom (s : R) s' * s) := by\n  with_unfolding_all rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/OreLocalization/Basic.lean", "context": {"open": ["OreLocalization"], "variables": ["{R : Type*} [MonoidWithZero R] {S : Submonoid R} [OreSet S]", "{R : Type*} [CommMonoidWithZero R] {S : Submonoid R} [OreSet S]", "{R : Type*} [Monoid R] {S : Submonoid R} [OreSet S] {X : Type*} [AddMonoid X]", "[DistribMulAction R X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : Monoid R\nS : Submonoid R\ninst\u271d\u00b2 : OreSet S\nX : Type u_4\ninst\u271d\u00b9 : AddMonoid X\ninst\u271d : DistribMulAction R X\nr r' : X\ns s' : \u21a5S\n\u22a2 r /\u2092 s + r' /\u2092 s' = (oreDenom (\u2191s) s' \u2022 r + oreNum (\u2191s) s' \u2022 r') /\u2092 (oreDenom (\u2191s) s' * s)"}, {"line": "with_unfolding_all rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oreDiv_add_char' {r r' : X} (s s' : S) (rb : R) (sb : R)\n    (h : sb * s = rb * s') (h' : sb * s \u2208 S) :\n    r /\u2092 s + r' /\u2092 s' = (sb \u2022 r + rb \u2022 r') /\u2092 \u27e8sb * s, h'\u27e9 := by\n  with_unfolding_all exact add''_char r s r' s' rb sb h h'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/OreLocalization/Basic.lean", "context": {"open": ["OreLocalization"], "variables": ["{R : Type*} [MonoidWithZero R] {S : Submonoid R} [OreSet S]", "{R : Type*} [CommMonoidWithZero R] {S : Submonoid R} [OreSet S]", "{R : Type*} [Monoid R] {S : Submonoid R} [OreSet S] {X : Type*} [AddMonoid X]", "[DistribMulAction R X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : Monoid R\nS : Submonoid R\ninst\u271d\u00b2 : OreSet S\nX : Type u_4\ninst\u271d\u00b9 : AddMonoid X\ninst\u271d : DistribMulAction R X\nr r' : X\ns s' : \u21a5S\nrb sb : R\nh : sb * \u2191s = rb * \u2191s'\nh' : sb * \u2191s \u2208 S\n\u22a2 r /\u2092 s + r' /\u2092 s' = (sb \u2022 r + rb \u2022 r') /\u2092 \u27e8sb * \u2191s, h'\u27e9"}, {"line": "with_unfolding_all exact add''_char r s r' s' rb sb h h'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_oreDiv {r r' : X} {s : S} : r /\u2092 s + r' /\u2092 s = (r + r') /\u2092 s := by\n  simp [oreDiv_add_char s s 1 1 (by simp)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/OreLocalization/Basic.lean", "context": {"open": ["OreLocalization"], "variables": ["{R : Type*} [MonoidWithZero R] {S : Submonoid R} [OreSet S]", "{R : Type*} [CommMonoidWithZero R] {S : Submonoid R} [OreSet S]", "{R : Type*} [Monoid R] {S : Submonoid R} [OreSet S] {X : Type*} [AddMonoid X]", "[DistribMulAction R X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : Monoid R\nS : Submonoid R\ninst\u271d\u00b2 : OreSet S\nX : Type u_4\ninst\u271d\u00b9 : AddMonoid X\ninst\u271d : DistribMulAction R X\nr r' : X\ns : \u21a5S\n\u22a2 r /\u2092 s + r' /\u2092 s = (r + r') /\u2092 s"}, {"line": "simp [oreDiv_add_char s s 1 1 (by simp)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_oreDiv (s : S) : (0 : X) /\u2092 s = 0 := by\n  rw [OreLocalization.zero_def]\n  rw [oreDiv_eq_iff]\n  exact \u27e8s, 1, by simp\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/OreLocalization/Basic.lean", "context": {"open": ["OreLocalization"], "variables": ["{R : Type*} [MonoidWithZero R] {S : Submonoid R} [OreSet S]", "{R : Type*} [CommMonoidWithZero R] {S : Submonoid R} [OreSet S]", "{R : Type*} [Monoid R] {S : Submonoid R} [OreSet S] {X : Type*} [AddMonoid X]", "[DistribMulAction R X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : Monoid R\nS : Submonoid R\ninst\u271d\u00b2 : OreSet S\nX : Type u_4\ninst\u271d\u00b9 : AddMonoid X\ninst\u271d : DistribMulAction R X\ns : \u21a5S\n\u22a2 0 /\u2092 s = 0"}, {"line": "rw [OreLocalization.zero_def]", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : Monoid R\nS : Submonoid R\ninst\u271d\u00b2 : OreSet S\nX : Type u_4\ninst\u271d\u00b9 : AddMonoid X\ninst\u271d : DistribMulAction R X\ns : \u21a5S\n\u22a2 0 /\u2092 s = 0 /\u2092 1"}, {"line": "rw [oreDiv_eq_iff]", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : Monoid R\nS : Submonoid R\ninst\u271d\u00b2 : OreSet S\nX : Type u_4\ninst\u271d\u00b9 : AddMonoid X\ninst\u271d : DistribMulAction R X\ns : \u21a5S\n\u22a2 \u2203 u v, u \u2022 0 = v \u2022 0 \u2227 \u2191u * \u21911 = v * \u2191s"}, {"line": "exact \u27e8s, 1, by simp\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_hilbertPoly_of_ne_zero\n    {p : F[X]} {d : \u2115} (hh : hilbertPoly p d \u2260 0) :\n    (hilbertPoly p d).natDegree = d - p.rootMultiplicity 1 - 1 := by\n  have hp : p \u2260 0 := by\n    intro h\n    rw [h] at hh\n    exact hh (hilbertPoly_zero_left d)\n  have hpd : p.rootMultiplicity 1 < d := by\n    by_contra h\n    exact hh (hilbertPoly_eq_zero_of_le_rootMultiplicity_one <| not_lt.1 h)\n  exact natDegree_hilbertPoly_of_ne_zero_of_rootMultiplicity_lt hp hpd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/HilbertPoly.lean", "context": {"open": ["Nat PowerSeries"], "variables": ["(F : Type*) [Field F]", "{F}", "(F) in", "[CharZero F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d\u00b9 : Field F\nR\u271d : Type u_2\nx\u271d : outParam (Type u_1 \u2192 PowerSeries R\u271d \u2192 Prop)\ninst\u271d : Semiring R\u271d\nhilbertPoly : x\u271d F X\np : sorry\nd : \u2115\nhh : sorry \u2260 0\n\u22a2 sorry = d - sorry - 1"}, {"line": "have hp : p \u2260 0 := sorry", "tactic_state": "F : Type u_1\ninst\u271d\u00b9 : Field F\nR\u271d : Type u_2\nx\u271d : outParam (Type u_1 \u2192 PowerSeries R\u271d \u2192 Prop)\ninst\u271d : Semiring R\u271d\nhilbertPoly : x\u271d F X\np : sorry\nd : \u2115\nhh : sorry \u2260 0\nhp : p \u2260 sorry\n\u22a2 sorry = d - sorry - 1"}, {"line": "have hpd : p.rootMultiplicity 1 < d := sorry", "tactic_state": "F : Type u_1\ninst\u271d\u00b9 : Field F\nR\u271d : Type u_2\nx\u271d : outParam (Type u_1 \u2192 PowerSeries R\u271d \u2192 Prop)\ninst\u271d : Semiring R\u271d\nhilbertPoly : x\u271d F X\np : sorry\nd : \u2115\nhh : sorry \u2260 0\nhp : p \u2260 sorry\nhpd : sorry < d\n\u22a2 sorry = d - sorry - 1"}, {"line": "exact natDegree_hilbertPoly_of_ne_zero_of_rootMultiplicity_lt hp hpd", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integralNormalization_zero : integralNormalization (0 : R[X]) = 0 := by\n  simp [integralNormalization]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/IntegralNormalization.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {m n : \u2115} {\u03b9 : Type y}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\n\u22a2 integralNormalization 0 = 0"}, {"line": "simp [integralNormalization]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integralNormalization_C {x : R} (hx : x \u2260 0) : integralNormalization (C x) = 1 := by\n  simp [integralNormalization, sum_def, support_C hx, degree_C hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/IntegralNormalization.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {m n : \u2115} {\u03b9 : Type y}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nx : R\nhx : x \u2260 0\n\u22a2 (C x).integralNormalization = 1"}, {"line": "simp [integralNormalization, sum_def, support_C hx, degree_C hx]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nx : R\nhx : x \u2260 0\n\u22a2 \u2211 n \u2208 (C x).support, (monomial n) (if (C x).degree = \u2191n then 1 else (C x).coeff n) = 1"}]}
{"declaration": "theorem support_integralNormalization_subset :\n    (integralNormalization p).support \u2286 p.support := by\n  intro\n  simp +contextual [sum_def, integralNormalization, coeff_monomial, mem_support_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/IntegralNormalization.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {m n : \u2115} {\u03b9 : Type y}", "[Semiring R]", "{p : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 p.integralNormalization.support \u2286 p.support"}, {"line": "intro", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\na\u271d : \u2115\n\u22a2 a\u271d \u2208 p.integralNormalization.support \u2192 a\u271d \u2208 p.support"}, {"line": "simp +contextual [sum_def, integralNormalization, coeff_monomial, mem_support_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integralNormalization_coeff_degree {i : \u2115} (hi : p.degree = i) :\n    (integralNormalization p).coeff i = 1 := by rw [integralNormalization_coeff, if_pos hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/IntegralNormalization.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {m n : \u2115} {\u03b9 : Type y}", "[Semiring R]", "{p : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\ni : \u2115\nhi : p.degree = \u2191i\n\u22a2 p.integralNormalization.coeff i = 1"}, {"line": "rw [integralNormalization_coeff, if_pos hi]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integralNormalization_coeff_degree_ne {i : \u2115} (hi : p.degree \u2260 i) :\n    coeff (integralNormalization p) i = coeff p i * p.leadingCoeff ^ (p.natDegree - 1 - i) := by\n  rw [integralNormalization_coeff]\n  rw [if_neg hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/IntegralNormalization.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {m n : \u2115} {\u03b9 : Type y}", "[Semiring R]", "{p : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\ni : \u2115\nhi : p.degree \u2260 \u2191i\n\u22a2 p.integralNormalization.coeff i = p.coeff i * p.leadingCoeff ^ (p.natDegree - 1 - i)"}, {"line": "rw [integralNormalization_coeff]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\np : Polynomial R\ni : \u2115\nhi : p.degree \u2260 \u2191i\n\u22a2 (if p.degree = \u2191i then 1 else p.coeff i * p.leadingCoeff ^ (p.natDegree - 1 - i)) =\n    p.coeff i * p.leadingCoeff ^ (p.natDegree - 1 - i)"}, {"line": "rw [if_neg hi]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leadingCoeff_smul_integralNormalization (p : S[X]) :\n    p.leadingCoeff \u2022 integralNormalization p = scaleRoots p p.leadingCoeff := by\n  rw [Algebra.smul_def]\n  rw [algebraMap_eq]\n  rw [mul_comm]\n  rw [integralNormalization_mul_C_leadingCoeff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/IntegralNormalization.lean", "context": {"open": ["Polynomial"], "variables": ["{R : Type u} {S : Type v} {a b : R} {m n : \u2115} {\u03b9 : Type y}", "[Semiring R]", "{p : R[X]}", "{A : Type*} [CommSemiring S] [Semiring A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type v\ninst\u271d : CommSemiring S\np : Polynomial S\n\u22a2 p.leadingCoeff \u2022 p.integralNormalization = p.scaleRoots p.leadingCoeff"}, {"line": "rw [Algebra.smul_def]", "tactic_state": "S : Type v\ninst\u271d : CommSemiring S\np : Polynomial S\n\u22a2 (algebraMap S (Polynomial S)) p.leadingCoeff * p.integralNormalization = p.scaleRoots p.leadingCoeff"}, {"line": "rw [algebraMap_eq]", "tactic_state": "S : Type v\ninst\u271d : CommSemiring S\np : Polynomial S\n\u22a2 C p.leadingCoeff * p.integralNormalization = p.scaleRoots p.leadingCoeff"}, {"line": "rw [mul_comm]", "tactic_state": "S : Type v\ninst\u271d : CommSemiring S\np : Polynomial S\n\u22a2 p.integralNormalization * C p.leadingCoeff = p.scaleRoots p.leadingCoeff"}, {"line": "rw [integralNormalization_mul_C_leadingCoeff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ascPochhammer_one : ascPochhammer S 1 = X := by simp [ascPochhammer]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial"], "variables": ["(S : Type u) [Semiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u\ninst\u271d : Semiring S\n\u22a2 ascPochhammer S 1 = X"}, {"line": "simp [ascPochhammer]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ascPochhammer_succ_left (n : \u2115) :\n    ascPochhammer S (n + 1) = X * (ascPochhammer S n).comp (X + 1) := by\n  rw [ascPochhammer]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial"], "variables": ["(S : Type u) [Semiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u\ninst\u271d : Semiring S\nn : \u2115\n\u22a2 ascPochhammer S (n + 1) = X * (ascPochhammer S n).comp (X + 1)"}, {"line": "rw [ascPochhammer]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem monic_ascPochhammer (n : \u2115) [Nontrivial S] [NoZeroDivisors S] :\n    Monic <| ascPochhammer S n := by\n  induction' n with n hn\n  \u00b7 simp\n  \u00b7 have : leadingCoeff (X + 1 : S[X]) = 1 := leadingCoeff_X_add_C 1\n    rw [ascPochhammer_succ_left]\n    rw [Monic.def]\n    rw [leadingCoeff_mul]\n    rw [leadingCoeff_comp (ne_zero_of_eq_one <| natDegree_X_add_C 1 : natDegree (X + 1) \u2260 0)]\n    rw [hn]\n    rw [monic_X]\n    rw [one_mul]\n    rw [one_mul]\n    rw [this]\n    rw [one_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial"], "variables": ["(S : Type u) [Semiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u\ninst\u271d\u00b2 : Semiring S\nn : \u2115\ninst\u271d\u00b9 : Nontrivial S\ninst\u271d : NoZeroDivisors S\n\u22a2 (ascPochhammer S n).Monic"}, {"line": "induction' n with n hn", "tactic_state": "case zero\nS : Type u\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Nontrivial S\ninst\u271d : NoZeroDivisors S\n\u22a2 (ascPochhammer S 0).Monic\n---\ncase succ\nS : Type u\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Nontrivial S\ninst\u271d : NoZeroDivisors S\nn : \u2115\nhn : (ascPochhammer S n).Monic\n\u22a2 (ascPochhammer S (n + 1)).Monic"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nS : Type u\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Nontrivial S\ninst\u271d : NoZeroDivisors S\nn : \u2115\nhn : (ascPochhammer S n).Monic\n\u22a2 (ascPochhammer S (n + 1)).Monic"}, {"line": "\u00b7 have : leadingCoeff (X + 1 : S[X]) = 1 := leadingCoeff_X_add_C 1\n    rw [ascPochhammer_succ_left]\n    rw [Monic.def]\n    rw [leadingCoeff_mul]\n    rw [leadingCoeff_comp (ne_zero_of_eq_one <| natDegree_X_add_C 1 : natDegree (X + 1) \u2260 0)]\n    rw [hn]\n    rw [monic_X]\n    rw [one_mul]\n    rw [one_mul]\n    rw [this]\n    rw [one_pow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ascPochhammer_eval_zero {n : \u2115} : (ascPochhammer S n).eval 0 = if n = 0 then 1 else 0 := by\n  cases n\n  \u00b7 simp\n  \u00b7 simp [X_mul, Nat.succ_ne_zero, ascPochhammer_succ_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u\ninst\u271d : Semiring S\nn : \u2115\n\u22a2 eval 0 (ascPochhammer S n) = if n = 0 then 1 else 0"}, {"line": "cases n", "tactic_state": "case zero\nS : Type u\ninst\u271d : Semiring S\n\u22a2 eval 0 (ascPochhammer S 0) = if 0 = 0 then 1 else 0\n---\ncase succ\nS : Type u\ninst\u271d : Semiring S\nn\u271d : \u2115\n\u22a2 eval 0 (ascPochhammer S (n\u271d + 1)) = if n\u271d + 1 = 0 then 1 else 0"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nS : Type u\ninst\u271d : Semiring S\nn\u271d : \u2115\n\u22a2 eval 0 (ascPochhammer S (n\u271d + 1)) = if n\u271d + 1 = 0 then 1 else 0"}, {"line": "\u00b7 simp [X_mul, Nat.succ_ne_zero, ascPochhammer_succ_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ascPochhammer_zero_eval_zero : (ascPochhammer S 0).eval 0 = 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u\ninst\u271d : Semiring S\n\u22a2 eval 0 (ascPochhammer S 0) = 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ascPochhammer_ne_zero_eval_zero {n : \u2115} (h : n \u2260 0) : (ascPochhammer S n).eval 0 = 0 := by\n  simp [ascPochhammer_eval_zero, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u\ninst\u271d : Semiring S\nn : \u2115\nh : n \u2260 0\n\u22a2 eval 0 (ascPochhammer S n) = 0"}, {"line": "simp [ascPochhammer_eval_zero, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ascPochhammer_succ_eval {S : Type*} [Semiring S] (n : \u2115) (k : S) :\n    (ascPochhammer S (n + 1)).eval k = (ascPochhammer S n).eval k * (k + n) := by\n  rw [ascPochhammer_succ_right]\n  rw [mul_add]\n  rw [eval_add]\n  rw [eval_mul_X]\n  rw [\u2190 Nat.cast_comm]\n  rw [\u2190 C_eq_natCast]\n  rw [eval_C_mul]\n  rw [Nat.cast_comm]\n  rw [\u2190 mul_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\nn : \u2115\nk : S\n\u22a2 eval k (ascPochhammer S (n + 1)) = eval k (ascPochhammer S n) * (k + \u2191n)"}, {"line": "rw [ascPochhammer_succ_right]", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\nn : \u2115\nk : S\n\u22a2 eval k (ascPochhammer S n * (X + \u2191n)) = eval k (ascPochhammer S n) * (k + \u2191n)"}, {"line": "rw [mul_add]", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\nn : \u2115\nk : S\n\u22a2 eval k (ascPochhammer S n * X + ascPochhammer S n * \u2191n) = eval k (ascPochhammer S n) * (k + \u2191n)"}, {"line": "rw [eval_add]", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\nn : \u2115\nk : S\n\u22a2 eval k (ascPochhammer S n * X) + eval k (ascPochhammer S n * \u2191n) = eval k (ascPochhammer S n) * (k + \u2191n)"}, {"line": "rw [eval_mul_X]", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\nn : \u2115\nk : S\n\u22a2 eval k (ascPochhammer S n) * k + eval k (ascPochhammer S n * \u2191n) = eval k (ascPochhammer S n) * (k + \u2191n)"}, {"line": "rw [\u2190 Nat.cast_comm]", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\nn : \u2115\nk : S\n\u22a2 eval k (ascPochhammer S n) * k + eval k (\u2191n * ascPochhammer S n) = eval k (ascPochhammer S n) * (k + \u2191n)"}, {"line": "rw [\u2190 C_eq_natCast]", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\nn : \u2115\nk : S\n\u22a2 eval k (ascPochhammer S n) * k + eval k (C \u2191n * ascPochhammer S n) = eval k (ascPochhammer S n) * (k + \u2191n)"}, {"line": "rw [eval_C_mul]", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\nn : \u2115\nk : S\n\u22a2 eval k (ascPochhammer S n) * k + \u2191n * eval k (ascPochhammer S n) = eval k (ascPochhammer S n) * (k + \u2191n)"}, {"line": "rw [Nat.cast_comm]", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\nn : \u2115\nk : S\n\u22a2 eval k (ascPochhammer S n) * k + eval k (ascPochhammer S n) * \u2191n = eval k (ascPochhammer S n) * (k + \u2191n)"}, {"line": "rw [\u2190 mul_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ascPochhammer_succ_comp_X_add_one (n : \u2115) :\n    (ascPochhammer S (n + 1)).comp (X + 1) =\n      ascPochhammer S (n + 1) + (n + 1) \u2022 (ascPochhammer S n).comp (X + 1) := by\n  suffices (ascPochhammer \u2115 (n + 1)).comp (X + 1) =\n      ascPochhammer \u2115 (n + 1) + (n + 1) * (ascPochhammer \u2115 n).comp (X + 1)\n    by simpa [map_comp] using congr_arg (Polynomial.map (Nat.castRingHom S)) this\n  nth_rw 2 [ascPochhammer_succ_left]\n  rw [\u2190 add_mul]\n  rw [ascPochhammer_succ_right \u2115 n]\n  rw [mul_comp]\n  rw [mul_comm]\n  rw [add_comp]\n  rw [X_comp]\n  rw [natCast_comp]\n  rw [add_comm]\n  rw [\u2190 add_assoc]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u\ninst\u271d : Semiring S\nn : \u2115\n\u22a2 (ascPochhammer S (n + 1)).comp (X + 1) = ascPochhammer S (n + 1) + (n + 1) \u2022 (ascPochhammer S n).comp (X + 1)"}, {"line": "suffices (ascPochhammer \u2115 (n + 1)).comp (X + 1) =\n      ascPochhammer \u2115 (n + 1) + (n + 1) * (ascPochhammer \u2115 n).comp (X + 1)\n    by simpa [map_comp] using congr_arg (Polynomial.map (Nat.castRingHom S)) this", "tactic_state": "S : Type u\ninst\u271d : Semiring S\nn : \u2115\n\u22a2 (ascPochhammer \u2115 (n + 1)).comp (X + 1) = ascPochhammer \u2115 (n + 1) + (\u2191n + 1) * (ascPochhammer \u2115 n).comp (X + 1)"}, {"line": "nth_rw 2 [ascPochhammer_succ_left]", "tactic_state": "S : Type u\ninst\u271d : Semiring S\nn : \u2115\n\u22a2 (ascPochhammer \u2115 (n + 1)).comp (X + 1) =\n    X * (ascPochhammer \u2115 n).comp (X + 1) + (\u2191n + 1) * (ascPochhammer \u2115 n).comp (X + 1)"}, {"line": "rw [\u2190 add_mul]", "tactic_state": "S : Type u\ninst\u271d : Semiring S\nn : \u2115\n\u22a2 (ascPochhammer \u2115 (n + 1)).comp (X + 1) = (X + (\u2191n + 1)) * (ascPochhammer \u2115 n).comp (X + 1)"}, {"line": "rw [ascPochhammer_succ_right \u2115 n]", "tactic_state": "S : Type u\ninst\u271d : Semiring S\nn : \u2115\n\u22a2 (ascPochhammer \u2115 n * (X + \u2191n)).comp (X + 1) = (X + (\u2191n + 1)) * (ascPochhammer \u2115 n).comp (X + 1)"}, {"line": "rw [mul_comp]", "tactic_state": "S : Type u\ninst\u271d : Semiring S\nn : \u2115\n\u22a2 (ascPochhammer \u2115 n).comp (X + 1) * (X + \u2191n).comp (X + 1) = (X + (\u2191n + 1)) * (ascPochhammer \u2115 n).comp (X + 1)"}, {"line": "rw [mul_comm]", "tactic_state": "S : Type u\ninst\u271d : Semiring S\nn : \u2115\n\u22a2 (X + \u2191n).comp (X + 1) * (ascPochhammer \u2115 n).comp (X + 1) = (X + (\u2191n + 1)) * (ascPochhammer \u2115 n).comp (X + 1)"}, {"line": "rw [add_comp]", "tactic_state": "S : Type u\ninst\u271d : Semiring S\nn : \u2115\n\u22a2 (X.comp (X + 1) + (\u2191n).comp (X + 1)) * (ascPochhammer \u2115 n).comp (X + 1) =\n    (X + (\u2191n + 1)) * (ascPochhammer \u2115 n).comp (X + 1)"}, {"line": "rw [X_comp]", "tactic_state": "S : Type u\ninst\u271d : Semiring S\nn : \u2115\n\u22a2 (X + 1 + (\u2191n).comp (X + 1)) * (ascPochhammer \u2115 n).comp (X + 1) = (X + (\u2191n + 1)) * (ascPochhammer \u2115 n).comp (X + 1)"}, {"line": "rw [natCast_comp]", "tactic_state": "S : Type u\ninst\u271d : Semiring S\nn : \u2115\n\u22a2 (X + 1 + \u2191n) * (ascPochhammer \u2115 n).comp (X + 1) = (X + (\u2191n + 1)) * (ascPochhammer \u2115 n).comp (X + 1)"}, {"line": "rw [add_comm]", "tactic_state": "S : Type u\ninst\u271d : Semiring S\nn : \u2115\n\u22a2 (\u2191n + (X + 1)) * (ascPochhammer \u2115 n).comp (X + 1) = (X + (\u2191n + 1)) * (ascPochhammer \u2115 n).comp (X + 1)"}, {"line": "rw [\u2190 add_assoc]", "tactic_state": "S : Type u\ninst\u271d : Semiring S\nn : \u2115\n\u22a2 (\u2191n + X + 1) * (ascPochhammer \u2115 n).comp (X + 1) = (X + (\u2191n + 1)) * (ascPochhammer \u2115 n).comp (X + 1)"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ascPochhammer_mul (n m : \u2115) :\n    ascPochhammer S n * (ascPochhammer S m).comp (X + (n : S[X])) = ascPochhammer S (n + m) := by\n  induction' m with m ih\n  \u00b7 simp\n  \u00b7 rw [ascPochhammer_succ_right, Polynomial.mul_X_add_natCast_comp, \u2190 mul_assoc, ih,\n      \u2190 add_assoc, ascPochhammer_succ_right, Nat.cast_add, add_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u\ninst\u271d : Semiring S\nn m : \u2115\n\u22a2 ascPochhammer S n * (ascPochhammer S m).comp (X + \u2191n) = ascPochhammer S (n + m)"}, {"line": "induction' m with m ih", "tactic_state": "case zero\nS : Type u\ninst\u271d : Semiring S\nn : \u2115\n\u22a2 ascPochhammer S n * (ascPochhammer S 0).comp (X + \u2191n) = ascPochhammer S (n + 0)\n---\ncase succ\nS : Type u\ninst\u271d : Semiring S\nn m : \u2115\nih : ascPochhammer S n * (ascPochhammer S m).comp (X + \u2191n) = ascPochhammer S (n + m)\n\u22a2 ascPochhammer S n * (ascPochhammer S (m + 1)).comp (X + \u2191n) = ascPochhammer S (n + (m + 1))"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nS : Type u\ninst\u271d : Semiring S\nn m : \u2115\nih : ascPochhammer S n * (ascPochhammer S m).comp (X + \u2191n) = ascPochhammer S (n + m)\n\u22a2 ascPochhammer S n * (ascPochhammer S (m + 1)).comp (X + \u2191n) = ascPochhammer S (n + (m + 1))"}, {"line": "\u00b7 rw [ascPochhammer_succ_right, Polynomial.mul_X_add_natCast_comp, \u2190 mul_assoc, ih,\n      \u2190 add_assoc, ascPochhammer_succ_right, Nat.cast_add, add_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ascPochhammer_nat_eq_natCast_ascFactorial (S : Type*) [Semiring S] (n k : \u2115) :\n    (ascPochhammer S k).eval (n : S) = n.ascFactorial k := by\n  norm_cast\n  rw [ascPochhammer_nat_eq_ascFactorial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\nn k : \u2115\n\u22a2 eval (\u2191n) (ascPochhammer S k) = \u2191(n.ascFactorial k)"}, {"line": "norm_cast", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\nn k : \u2115\n\u22a2 \u2191(eval n (ascPochhammer \u2115 k)) = \u2191(n.ascFactorial k)"}, {"line": "rw [ascPochhammer_nat_eq_ascFactorial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ascPochhammer_nat_eq_descFactorial (a b : \u2115) :\n    (ascPochhammer \u2115 b).eval a = (a + b - 1).descFactorial b := by\n  rw [ascPochhammer_nat_eq_ascFactorial]\n  rw [Nat.add_descFactorial_eq_ascFactorial']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 eval a (ascPochhammer \u2115 b) = (a + b - 1).descFactorial b"}, {"line": "rw [ascPochhammer_nat_eq_ascFactorial]", "tactic_state": "a b : \u2115\n\u22a2 a.ascFactorial b = (a + b - 1).descFactorial b"}, {"line": "rw [Nat.add_descFactorial_eq_ascFactorial']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ascPochhammer_nat_eq_natCast_descFactorial (S : Type*) [Semiring S] (a b : \u2115) :\n    (ascPochhammer S b).eval (a : S) = (a + b - 1).descFactorial b := by\n  norm_cast\n  rw [ascPochhammer_nat_eq_descFactorial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\na b : \u2115\n\u22a2 eval (\u2191a) (ascPochhammer S b) = \u2191((a + b - 1).descFactorial b)"}, {"line": "norm_cast", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\na b : \u2115\n\u22a2 \u2191(eval a (ascPochhammer \u2115 b)) = \u2191((a + b - 1).descFactorial b)"}, {"line": "rw [ascPochhammer_nat_eq_descFactorial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ascPochhammer_natDegree (n : \u2115) [NoZeroDivisors S] [Nontrivial S] :\n    (ascPochhammer S n).natDegree = n := by\n  induction' n with n hn\n  \u00b7 simp\n  \u00b7 have : natDegree (X + (n : S[X])) = 1 := natDegree_X_add_C (n : S)\n    rw [ascPochhammer_succ_right]\n    rw [natDegree_mul _ (ne_zero_of_natDegree_gt <| this.symm \u25b8 Nat.zero_lt_one)]\n    rw [hn]\n    rw [this]\n    cases n\n    \u00b7 simp\n    \u00b7 refine ne_zero_of_natDegree_gt <| hn.symm \u25b8 Nat.add_one_pos _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u\ninst\u271d\u00b2 : Semiring S\nn : \u2115\ninst\u271d\u00b9 : NoZeroDivisors S\ninst\u271d : Nontrivial S\n\u22a2 (ascPochhammer S n).natDegree = n"}, {"line": "induction' n with n hn", "tactic_state": "case zero\nS : Type u\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : NoZeroDivisors S\ninst\u271d : Nontrivial S\n\u22a2 (ascPochhammer S 0).natDegree = 0\n---\ncase succ\nS : Type u\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : NoZeroDivisors S\ninst\u271d : Nontrivial S\nn : \u2115\nhn : (ascPochhammer S n).natDegree = n\n\u22a2 (ascPochhammer S (n + 1)).natDegree = n + 1"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nS : Type u\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : NoZeroDivisors S\ninst\u271d : Nontrivial S\nn : \u2115\nhn : (ascPochhammer S n).natDegree = n\n\u22a2 (ascPochhammer S (n + 1)).natDegree = n + 1"}, {"line": "\u00b7 have : natDegree (X + (n : S[X])) = 1 := natDegree_X_add_C (n : S)\n    rw [ascPochhammer_succ_right]\n    rw [natDegree_mul _ (ne_zero_of_natDegree_gt <| this.symm \u25b8 Nat.zero_lt_one)]\n    rw [hn]\n    rw [this]\n    cases n\n    \u00b7 simp\n    \u00b7 refine ne_zero_of_natDegree_gt <| hn.symm \u25b8 Nat.add_one_pos _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorial_mul_ascPochhammer (S : Type*) [Semiring S] (r n : \u2115) :\n    (r ! : S) * (ascPochhammer S n).eval (r + 1 : S) = (r + n)! := by\n  rw_mod_cast [ascPochhammer_nat_eq_ascFactorial, Nat.factorial_mul_ascFactorial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial", "Nat"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]", "{S : Type*} [Semiring S] [PartialOrder S] [IsStrictOrderedRing S]", "(S : Type*) [Semiring S] (r n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_3\ninst\u271d : Semiring S\nr n : \u2115\n\u22a2 \u2191r.factorial * eval (\u2191r + 1) (ascPochhammer S n) = \u2191(r + n).factorial"}, {"line": "rw_mod_cast [ascPochhammer_nat_eq_ascFactorial, Nat.factorial_mul_ascFactorial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem descPochhammer_one : descPochhammer R 1 = X := by simp [descPochhammer]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial", "Nat"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]", "{S : Type*} [Semiring S] [PartialOrder S] [IsStrictOrderedRing S]", "(S : Type*) [Semiring S] (r n : \u2115)", "(R : Type u) [Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Ring R\n\u22a2 descPochhammer R 1 = X"}, {"line": "simp [descPochhammer]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem descPochhammer_succ_left (n : \u2115) :\n    descPochhammer R (n + 1) = X * (descPochhammer R n).comp (X - 1) := by\n  rw [descPochhammer]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial", "Nat"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]", "{S : Type*} [Semiring S] [PartialOrder S] [IsStrictOrderedRing S]", "(S : Type*) [Semiring S] (r n : \u2115)", "(R : Type u) [Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Ring R\nn : \u2115\n\u22a2 descPochhammer R (n + 1) = X * (descPochhammer R n).comp (X - 1)"}, {"line": "rw [descPochhammer]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem descPochhammer_eval_zero {n : \u2115} :\n    (descPochhammer R n).eval 0 = if n = 0 then 1 else 0 := by\n  cases n\n  \u00b7 simp\n  \u00b7 simp [X_mul, Nat.succ_ne_zero, descPochhammer_succ_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial", "Nat"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]", "{S : Type*} [Semiring S] [PartialOrder S] [IsStrictOrderedRing S]", "(S : Type*) [Semiring S] (r n : \u2115)", "(R : Type u) [Ring R]", "{R} {T : Type v} [Ring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Ring R\nn : \u2115\n\u22a2 eval 0 (descPochhammer R n) = if n = 0 then 1 else 0"}, {"line": "cases n", "tactic_state": "case zero\nR : Type u\ninst\u271d : Ring R\n\u22a2 eval 0 (descPochhammer R 0) = if 0 = 0 then 1 else 0\n---\ncase succ\nR : Type u\ninst\u271d : Ring R\nn\u271d : \u2115\n\u22a2 eval 0 (descPochhammer R (n\u271d + 1)) = if n\u271d + 1 = 0 then 1 else 0"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nR : Type u\ninst\u271d : Ring R\nn\u271d : \u2115\n\u22a2 eval 0 (descPochhammer R (n\u271d + 1)) = if n\u271d + 1 = 0 then 1 else 0"}, {"line": "\u00b7 simp [X_mul, Nat.succ_ne_zero, descPochhammer_succ_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem descPochhammer_zero_eval_zero : (descPochhammer R 0).eval 0 = 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial", "Nat"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]", "{S : Type*} [Semiring S] [PartialOrder S] [IsStrictOrderedRing S]", "(S : Type*) [Semiring S] (r n : \u2115)", "(R : Type u) [Ring R]", "{R} {T : Type v} [Ring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Ring R\n\u22a2 eval 0 (descPochhammer R 0) = 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem descPochhammer_ne_zero_eval_zero {n : \u2115} (h : n \u2260 0) : (descPochhammer R n).eval 0 = 0 := by\n  simp [descPochhammer_eval_zero, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial", "Nat"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]", "{S : Type*} [Semiring S] [PartialOrder S] [IsStrictOrderedRing S]", "(S : Type*) [Semiring S] (r n : \u2115)", "(R : Type u) [Ring R]", "{R} {T : Type v} [Ring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Ring R\nn : \u2115\nh : n \u2260 0\n\u22a2 eval 0 (descPochhammer R n) = 0"}, {"line": "simp [descPochhammer_eval_zero, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem descPochhammer_natDegree (n : \u2115) [NoZeroDivisors R] [Nontrivial R] :\n    (descPochhammer R n).natDegree = n := by\n  induction' n with n hn\n  \u00b7 simp\n  \u00b7 have : natDegree (X - (n : R[X])) = 1 := natDegree_X_sub_C (n : R)\n    rw [descPochhammer_succ_right]\n    rw [natDegree_mul _ (ne_zero_of_natDegree_gt <| this.symm \u25b8 Nat.zero_lt_one)]\n    rw [hn]\n    rw [this]\n    cases n\n    \u00b7 simp\n    \u00b7 refine ne_zero_of_natDegree_gt <| hn.symm \u25b8 Nat.add_one_pos _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial", "Nat"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]", "{S : Type*} [Semiring S] [PartialOrder S] [IsStrictOrderedRing S]", "(S : Type*) [Semiring S] (r n : \u2115)", "(R : Type u) [Ring R]", "{R} {T : Type v} [Ring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Ring R\nn : \u2115\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\n\u22a2 (descPochhammer R n).natDegree = n"}, {"line": "induction' n with n hn", "tactic_state": "case zero\nR : Type u\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\n\u22a2 (descPochhammer R 0).natDegree = 0\n---\ncase succ\nR : Type u\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nn : \u2115\nhn : (descPochhammer R n).natDegree = n\n\u22a2 (descPochhammer R (n + 1)).natDegree = n + 1"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nR : Type u\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nn : \u2115\nhn : (descPochhammer R n).natDegree = n\n\u22a2 (descPochhammer R (n + 1)).natDegree = n + 1"}, {"line": "\u00b7 have : natDegree (X - (n : R[X])) = 1 := natDegree_X_sub_C (n : R)\n    rw [descPochhammer_succ_right]\n    rw [natDegree_mul _ (ne_zero_of_natDegree_gt <| this.symm \u25b8 Nat.zero_lt_one)]\n    rw [hn]\n    rw [this]\n    cases n\n    \u00b7 simp\n    \u00b7 refine ne_zero_of_natDegree_gt <| hn.symm \u25b8 Nat.add_one_pos _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem descPochhammer_succ_comp_X_sub_one (n : \u2115) :\n    (descPochhammer R (n + 1)).comp (X - 1) =\n      descPochhammer R (n + 1) - (n + (1 : R[X])) \u2022 (descPochhammer R n).comp (X - 1) := by\n  suffices (descPochhammer \u2124 (n + 1)).comp (X - 1) =\n      descPochhammer \u2124 (n + 1) - (n + 1) * (descPochhammer \u2124 n).comp (X - 1)\n    by simpa [map_comp] using congr_arg (Polynomial.map (Int.castRingHom R)) this\n  nth_rw 2 [descPochhammer_succ_left]\n  rw [\u2190 sub_mul]\n  rw [descPochhammer_succ_right \u2124 n]\n  rw [mul_comp]\n  rw [mul_comm]\n  rw [sub_comp]\n  rw [X_comp]\n  rw [natCast_comp]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial", "Nat"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]", "{S : Type*} [Semiring S] [PartialOrder S] [IsStrictOrderedRing S]", "(S : Type*) [Semiring S] (r n : \u2115)", "(R : Type u) [Ring R]", "{R} {T : Type v} [Ring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Ring R\nn : \u2115\n\u22a2 (descPochhammer R (n + 1)).comp (X - 1) = descPochhammer R (n + 1) - (\u2191n + 1) \u2022 (descPochhammer R n).comp (X - 1)"}, {"line": "suffices (descPochhammer \u2124 (n + 1)).comp (X - 1) =\n      descPochhammer \u2124 (n + 1) - (n + 1) * (descPochhammer \u2124 n).comp (X - 1)\n    by simpa [map_comp] using congr_arg (Polynomial.map (Int.castRingHom R)) this", "tactic_state": "R : Type u\ninst\u271d : Ring R\nn : \u2115\n\u22a2 (descPochhammer \u2124 (n + 1)).comp (X - 1) = descPochhammer \u2124 (n + 1) - (\u2191n + 1) * (descPochhammer \u2124 n).comp (X - 1)"}, {"line": "nth_rw 2 [descPochhammer_succ_left]", "tactic_state": "R : Type u\ninst\u271d : Ring R\nn : \u2115\n\u22a2 (descPochhammer \u2124 (n + 1)).comp (X - 1) =\n    X * (descPochhammer \u2124 n).comp (X - 1) - (\u2191n + 1) * (descPochhammer \u2124 n).comp (X - 1)"}, {"line": "rw [\u2190 sub_mul]", "tactic_state": "R : Type u\ninst\u271d : Ring R\nn : \u2115\n\u22a2 (descPochhammer \u2124 (n + 1)).comp (X - 1) = (X - (\u2191n + 1)) * (descPochhammer \u2124 n).comp (X - 1)"}, {"line": "rw [descPochhammer_succ_right \u2124 n]", "tactic_state": "R : Type u\ninst\u271d : Ring R\nn : \u2115\n\u22a2 (descPochhammer \u2124 n * (X - \u2191n)).comp (X - 1) = (X - (\u2191n + 1)) * (descPochhammer \u2124 n).comp (X - 1)"}, {"line": "rw [mul_comp]", "tactic_state": "R : Type u\ninst\u271d : Ring R\nn : \u2115\n\u22a2 (descPochhammer \u2124 n).comp (X - 1) * (X - \u2191n).comp (X - 1) = (X - (\u2191n + 1)) * (descPochhammer \u2124 n).comp (X - 1)"}, {"line": "rw [mul_comm]", "tactic_state": "R : Type u\ninst\u271d : Ring R\nn : \u2115\n\u22a2 (X - \u2191n).comp (X - 1) * (descPochhammer \u2124 n).comp (X - 1) = (X - (\u2191n + 1)) * (descPochhammer \u2124 n).comp (X - 1)"}, {"line": "rw [sub_comp]", "tactic_state": "R : Type u\ninst\u271d : Ring R\nn : \u2115\n\u22a2 (X.comp (X - 1) - (\u2191n).comp (X - 1)) * (descPochhammer \u2124 n).comp (X - 1) =\n    (X - (\u2191n + 1)) * (descPochhammer \u2124 n).comp (X - 1)"}, {"line": "rw [X_comp]", "tactic_state": "R : Type u\ninst\u271d : Ring R\nn : \u2115\n\u22a2 (X - 1 - (\u2191n).comp (X - 1)) * (descPochhammer \u2124 n).comp (X - 1) = (X - (\u2191n + 1)) * (descPochhammer \u2124 n).comp (X - 1)"}, {"line": "rw [natCast_comp]", "tactic_state": "R : Type u\ninst\u271d : Ring R\nn : \u2115\n\u22a2 (X - 1 - \u2191n) * (descPochhammer \u2124 n).comp (X - 1) = (X - (\u2191n + 1)) * (descPochhammer \u2124 n).comp (X - 1)"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem descPochhammer_mul (n m : \u2115) :\n    descPochhammer R n * (descPochhammer R m).comp (X - (n : R[X])) = descPochhammer R (n + m) := by\n  induction' m with m ih\n  \u00b7 simp\n  \u00b7 rw [descPochhammer_succ_right, Polynomial.mul_X_sub_intCast_comp, \u2190 mul_assoc, ih,\n      \u2190 add_assoc, descPochhammer_succ_right, Nat.cast_add, sub_add_eq_sub_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial", "Nat"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]", "{S : Type*} [Semiring S] [PartialOrder S] [IsStrictOrderedRing S]", "(S : Type*) [Semiring S] (r n : \u2115)", "(R : Type u) [Ring R]", "{R} {T : Type v} [Ring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Ring R\nn m : \u2115\n\u22a2 descPochhammer R n * (descPochhammer R m).comp (X - \u2191n) = descPochhammer R (n + m)"}, {"line": "induction' m with m ih", "tactic_state": "case zero\nR : Type u\ninst\u271d : Ring R\nn : \u2115\n\u22a2 descPochhammer R n * (descPochhammer R 0).comp (X - \u2191n) = descPochhammer R (n + 0)\n---\ncase succ\nR : Type u\ninst\u271d : Ring R\nn m : \u2115\nih : descPochhammer R n * (descPochhammer R m).comp (X - \u2191n) = descPochhammer R (n + m)\n\u22a2 descPochhammer R n * (descPochhammer R (m + 1)).comp (X - \u2191n) = descPochhammer R (n + (m + 1))"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nR : Type u\ninst\u271d : Ring R\nn m : \u2115\nih : descPochhammer R n * (descPochhammer R m).comp (X - \u2191n) = descPochhammer R (n + m)\n\u22a2 descPochhammer R n * (descPochhammer R (m + 1)).comp (X - \u2191n) = descPochhammer R (n + (m + 1))"}, {"line": "\u00b7 rw [descPochhammer_succ_right, Polynomial.mul_X_sub_intCast_comp, \u2190 mul_assoc, ih,\n      \u2190 add_assoc, descPochhammer_succ_right, Nat.cast_add, sub_add_eq_sub_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem descPochhammer_int_eq_ascFactorial (a b : \u2115) :\n    (descPochhammer \u2124 b).eval (a + b : \u2124) = (a + 1).ascFactorial b := by\n  rw [\u2190 Nat.cast_add]\n  rw [descPochhammer_eval_eq_descFactorial \u2124 (a + b) b]\n  rw [Nat.add_descFactorial_eq_ascFactorial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial", "Nat"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]", "{S : Type*} [Semiring S] [PartialOrder S] [IsStrictOrderedRing S]", "(S : Type*) [Semiring S] (r n : \u2115)", "(R : Type u) [Ring R]", "{R} {T : Type v} [Ring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 eval (\u2191a + \u2191b) (descPochhammer \u2124 b) = \u2191((a + 1).ascFactorial b)"}, {"line": "rw [\u2190 Nat.cast_add]", "tactic_state": "a b : \u2115\n\u22a2 eval (\u2191(a + b)) (descPochhammer \u2124 b) = \u2191((a + 1).ascFactorial b)"}, {"line": "rw [descPochhammer_eval_eq_descFactorial \u2124 (a + b) b]", "tactic_state": "a b : \u2115\n\u22a2 \u2191((a + b).descFactorial b) = \u2191((a + 1).ascFactorial b)"}, {"line": "rw [Nat.add_descFactorial_eq_ascFactorial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ascPochhammer_eval_eq_zero_iff [IsDomain R]\n    (n : \u2115) (r : R) : (ascPochhammer R n).eval r = 0 \u2194 \u2203 k < n, k = -r := by\n  refine \u27e8fun zero' \u21a6 ?_, fun hrn \u21a6 ?_\u27e9\n  \u00b7 induction n with\n    | zero => simp only [ascPochhammer_zero, Polynomial.eval_one, one_ne_zero] at zero'\n    | succ n ih =>\n      rw [ascPochhammer_succ_eval] at zero'\n      rw [mul_eq_zero] at zero'\n      cases zero' with\n      | inl h =>\n        obtain \u27e8rn, hrn, rrn\u27e9 := ih h\n        exact \u27e8rn, by omega, rrn\u27e9\n      | inr h =>\n        exact \u27e8n, lt_add_one n, eq_neg_of_add_eq_zero_right h\u27e9\n  \u00b7 obtain \u27e8rn, hrn, rnn\u27e9 := hrn\n    convert ascPochhammer_eval_neg_coe_nat_of_lt hrn\n    simp [rnn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Pochhammer.lean", "context": {"open": ["Polynomial", "Nat"], "variables": ["(S : Type u) [Semiring S]", "{S} {T : Type v} [Semiring T]", "{S : Type*} [Semiring S] [PartialOrder S] [IsStrictOrderedRing S]", "(S : Type*) [Semiring S] (r n : \u2115)", "(R : Type u) [Ring R]", "{R} {T : Type v} [Ring T]", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Ring R\ninst\u271d : IsDomain R\nn : \u2115\nr : R\n\u22a2 eval r (ascPochhammer R n) = 0 \u2194 \u2203 k < n, \u2191k = -r"}, {"line": "refine \u27e8fun zero' \u21a6 ?_, fun hrn \u21a6 ?_\u27e9", "tactic_state": "case refine_1\nR : Type u\ninst\u271d\u00b9 : Ring R\ninst\u271d : IsDomain R\nn : \u2115\nr : R\nzero' : eval r (ascPochhammer R n) = 0\n\u22a2 \u2203 k < n, \u2191k = -r\n---\ncase refine_2\nR : Type u\ninst\u271d\u00b9 : Ring R\ninst\u271d : IsDomain R\nn : \u2115\nr : R\nhrn : \u2203 k < n, \u2191k = -r\n\u22a2 eval r (ascPochhammer R n) = 0"}, {"line": "\u00b7 induction n with\n    | zero => simp only [ascPochhammer_zero, Polynomial.eval_one, one_ne_zero] at zero'\n    | succ n ih =>\n      rw [ascPochhammer_succ_eval] at zero'\n      rw [mul_eq_zero] at zero'\n      cases zero' with\n      | inl h =>\n        obtain \u27e8rn, hrn, rrn\u27e9 := ih h\n        exact \u27e8rn, by omega, rrn\u27e9\n      | inr h =>\n        exact \u27e8n, lt_add_one n, eq_neg_of_add_eq_zero_right h\u27e9", "tactic_state": "case refine_2\nR : Type u\ninst\u271d\u00b9 : Ring R\ninst\u271d : IsDomain R\nn : \u2115\nr : R\nhrn : \u2203 k < n, \u2191k = -r\n\u22a2 eval r (ascPochhammer R n) = 0"}, {"line": "\u00b7 obtain \u27e8rn, hrn, rnn\u27e9 := hrn\n    convert ascPochhammer_eval_neg_coe_nat_of_lt hrn\n    simp [rnn]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eval_map_algebraMap (P : R[X]) (b : B) :\n    (map (algebraMap R B) P).eval b = aeval b P := by\n  rw [aeval_def]\n  rw [eval_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Tower.lean", "context": {"open": ["Polynomial"], "variables": ["(R A B : Type*)", "[CommSemiring R] [CommSemiring A] [Semiring B]", "[Algebra R A] [Algebra A B] [Algebra R B]", "[IsScalarTower R A B]", "{R B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nB : Type u_3\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring B\ninst\u271d : Algebra R B\nP : Polynomial R\nb : B\n\u22a2 eval b (map (algebraMap R B) P) = (aeval b) P"}, {"line": "rw [aeval_def]", "tactic_state": "R : Type u_1\nB : Type u_3\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring B\ninst\u271d : Algebra R B\nP : Polynomial R\nb : B\n\u22a2 eval b (map (algebraMap R B) P) = eval\u2082 (algebraMap R B) b P"}, {"line": "rw [eval_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_degreeLT {n : \u2115} {f : R[X]} : f \u2208 degreeLT R n \u2194 degree f < n := by\n  rw [degreeLT]\n  rw [Submodule.mem_iInf]\n  conv_lhs => intro i; rw [Submodule.mem_iInf]\n  rw [degree]\n  rw [Finset.max_eq_sup_coe]\n  rw [Finset.sup_lt_iff ?_]\n  rotate_left\n  \u00b7 apply WithBot.bot_lt_coe\n  conv_rhs =>\n    simp only [mem_support_iff]\n    intro b\n    rw [Nat.cast_withBot]\n    rw [WithBot.coe_lt_coe]\n    rw [lt_iff_not_le]\n    rw [Ne]\n    rw [not_imp_not]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Basic.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["{R : Type u} {S : Type*}", "[Semiring R]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\nf : Polynomial R\n\u22a2 f \u2208 degreeLT R n \u2194 f.degree < \u2191n"}, {"line": "rw [degreeLT]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\nf : Polynomial R\n\u22a2 f \u2208 \u2a05 k, \u2a05 (_ : k \u2265 n), LinearMap.ker (lcoeff R k) \u2194 f.degree < \u2191n"}, {"line": "rw [Submodule.mem_iInf]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\nf : Polynomial R\n\u22a2 (\u2200 (i : \u2115), f \u2208 \u2a05 (_ : i \u2265 n), LinearMap.ker (lcoeff R i)) \u2194 f.degree < \u2191n"}, {"line": "conv_lhs => intro i; rw [Submodule.mem_iInf]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\nf : Polynomial R\n\u22a2 (\u2200 i \u2265 n, f \u2208 LinearMap.ker (lcoeff R i)) \u2194 f.degree < \u2191n"}, {"line": "rw [degree]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\nf : Polynomial R\n\u22a2 (\u2200 i \u2265 n, f \u2208 LinearMap.ker (lcoeff R i)) \u2194 f.support.max < \u2191n"}, {"line": "rw [Finset.max_eq_sup_coe]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\nf : Polynomial R\n\u22a2 (\u2200 i \u2265 n, f \u2208 LinearMap.ker (lcoeff R i)) \u2194 f.support.sup WithBot.some < \u2191n"}, {"line": "rw [Finset.sup_lt_iff ?_]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\nf : Polynomial R\n\u22a2 (\u2200 i \u2265 n, f \u2208 LinearMap.ker (lcoeff R i)) \u2194 \u2200 b \u2208 f.support, \u2191b < \u2191n\n---\nR : Type u\ninst\u271d : Semiring R\nn : \u2115\nf : Polynomial R\n\u22a2 \u22a5 < \u2191n"}, {"line": "rotate_left", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\nf : Polynomial R\n\u22a2 \u22a5 < \u2191n\n---\nR : Type u\ninst\u271d : Semiring R\nn : \u2115\nf : Polynomial R\n\u22a2 (\u2200 i \u2265 n, f \u2208 LinearMap.ker (lcoeff R i)) \u2194 \u2200 b \u2208 f.support, \u2191b < \u2191n"}, {"line": "\u00b7 apply WithBot.bot_lt_coe", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\nf : Polynomial R\n\u22a2 (\u2200 i \u2265 n, f \u2208 LinearMap.ker (lcoeff R i)) \u2194 \u2200 b \u2208 f.support, \u2191b < \u2191n"}, {"line": "conv_rhs =>\n    simp only [mem_support_iff]\n    intro b\n    rw [Nat.cast_withBot]\n    rw [WithBot.coe_lt_coe]\n    rw [lt_iff_not_le]\n    rw [Ne]\n    rw [not_imp_not]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\nf : Polynomial R\n\u22a2 (\u2200 i \u2265 n, f \u2208 LinearMap.ker (lcoeff R i)) \u2194 \u2200 (b : \u2115), n \u2264 b \u2192 f.coeff b = 0"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_eq_sum_degreeLTEquiv {n : \u2115} {p : R[X]} (hp : p \u2208 degreeLT R n) (x : R) :\n    p.eval x = \u2211 i, degreeLTEquiv _ _ \u27e8p, hp\u27e9 i * x ^ (i : \u2115) := by\n  simp_rw [eval_eq_sum]\n  exact (sum_fin _ (by simp_rw [zero_mul, forall_const]) (mem_degreeLT.mp hp)).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Basic.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["{R : Type u} {S : Type*}", "[Semiring R]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\np : Polynomial R\nhp : p \u2208 degreeLT R n\nx : R\n\u22a2 eval x p = \u2211 i, (degreeLTEquiv R n) \u27e8p, hp\u27e9 i * x ^ \u2191i"}, {"line": "simp_rw [eval_eq_sum]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\np : Polynomial R\nhp : p \u2208 degreeLT R n\nx : R\n\u22a2 (p.sum fun e a => a * x ^ e) = \u2211 i, (degreeLTEquiv R n) \u27e8p, hp\u27e9 i * x ^ \u2191i"}, {"line": "exact (sum_fin _ (by simp_rw [zero_mul, forall_const]) (mem_degreeLT.mp hp)).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem monic_geom_sum_X {n : \u2115} (hn : n \u2260 0) : (\u2211 i \u2208 range n, (X : R[X]) ^ i).Monic := by\n  nontriviality R\n  apply monic_X.geom_sum _ hn\n  simp only [natDegree_X]\n  simp only [zero_lt_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Basic.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["{R : Type u} {S : Type*}", "[Semiring R]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\nhn : n \u2260 0\n\u22a2 (\u2211 i \u2208 range n, X ^ i).Monic"}, {"line": "nontriviality R", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\nhn : n \u2260 0\na\u271d : Nontrivial R\n\u22a2 (\u2211 i \u2208 range n, X ^ i).Monic"}, {"line": "apply monic_X.geom_sum _ hn", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\nhn : n \u2260 0\na\u271d : Nontrivial R\n\u22a2 0 < X.natDegree"}, {"line": "simp only [natDegree_X]", "tactic_state": "R : Type u\ninst\u271d : Semiring R\nn : \u2115\nhn : n \u2260 0\na\u271d : Nontrivial R\n\u22a2 0 < 1"}, {"line": "simp only [zero_lt_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Polynomial.coeff_prod_mem_ideal_pow_tsub {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 R[X])\n    (I : Ideal R) (n : \u03b9 \u2192 \u2115) (h : \u2200 i \u2208 s, \u2200 (k), (f i).coeff k \u2208 I ^ (n i - k)) (k : \u2115) :\n    (s.prod f).coeff k \u2208 I ^ (s.sum n - k) := by\n  classical\n    induction' s using Finset.induction with a s ha hs generalizing k\n    \u00b7 rw [sum_empty, prod_empty, coeff_one, zero_tsub, pow_zero, Ideal.one_eq_top]\n      exact Submodule.mem_top\n    \u00b7 rw [sum_insert ha, prod_insert ha, coeff_mul]\n      apply sum_mem\n      rintro \u27e8i, j\u27e9 e\n      obtain rfl : i + j = k := mem_antidiagonal.mp e\n      apply Ideal.pow_le_pow_right add_tsub_add_le_tsub_add_tsub\n      rw [pow_add]\n      exact\n        Ideal.mul_mem_mul (h _ (Finset.mem_insert.mpr <| Or.inl rfl) _)\n          (hs (fun i hi k => h _ (Finset.mem_insert.mpr <| Or.inr hi) _) j)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Basic.lean", "context": {"open": ["Polynomial", "Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type*}", "[Semiring R]", "(R)", "{R}", "[Ring R]", "[Semiring S] {f : R \u2192+* S} {x : S}", "(p : R[X]) (T : Subring R)", "(hp : (\u2191p.coeffs : Set R) \u2286 T)", "(T : Subring R)", "[Semiring R]", "{I : Ideal R[X]}", "(I)", "[CommSemiring R] [Semiring S]", "(I : Ideal R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Semiring R\ninst\u271d : CommSemiring R\n\u03b9 : Type u_2\ns : Finset \u03b9\nf : \u03b9 \u2192 Polynomial R\nI : Ideal R\nn : \u03b9 \u2192 \u2115\nh : \u2200 i \u2208 s, \u2200 (k : \u2115), (f i).coeff k \u2208 I ^ (n i - k)\nk : \u2115\n\u22a2 sorry \u2208 I ^ (s.sum n - k)"}, {"line": "classical\n    induction' s using Finset.induction with a s ha hs generalizing k\n    \u00b7 rw [sum_empty, prod_empty, coeff_one, zero_tsub, pow_zero, Ideal.one_eq_top]\n      exact Submodule.mem_top\n    \u00b7 rw [sum_insert ha, prod_insert ha, coeff_mul]\n      apply sum_mem\n      rintro \u27e8i, j\u27e9 e\n      obtain rfl : i + j = k := mem_antidiagonal.mp e\n      apply Ideal.pow_le_pow_right add_tsub_add_le_tsub_add_tsub\n      rw [pow_add]\n      exact\n        Ideal.mul_mem_mul (h _ (Finset.mem_insert.mpr <| Or.inl rfl) _)\n          (hs (fun i hi k => h _ (Finset.mem_insert.mpr <| Or.inr hi) _) j)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem polynomial_not_isField : \u00acIsField R[X] := by\n  nontriviality R\n  intro hR\n  obtain \u27e8p, hp\u27e9 := hR.mul_inv_cancel X_ne_zero\n  have hp0 : p \u2260 0 := right_ne_zero_of_mul_eq_one hp\n  have := degree_lt_degree_mul_X hp0\n  rw [\u2190 X_mul] at this\n  rw [congr_arg degree hp] at this\n  rw [degree_one] at this\n  rw [Nat.WithBot.lt_zero_iff] at this\n  rw [degree_eq_bot] at this\n  exact hp0 this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Basic.lean", "context": {"open": ["Polynomial", "Finset", "Polynomial"], "variables": ["{R : Type u} {S : Type*}", "[Semiring R]", "(R)", "{R}", "[Ring R]", "[Semiring S] {f : R \u2192+* S} {x : S}", "(p : R[X]) (T : Subring R)", "(hp : (\u2191p.coeffs : Set R) \u2286 T)", "(T : Subring R)", "[Semiring R]", "{I : Ideal R[X]}", "(I)", "[CommSemiring R] [Semiring S]", "(I : Ideal R[X])", "[Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\n\u22a2 \u00acIsField (Polynomial R)"}, {"line": "nontriviality R", "tactic_state": "R : Type u\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\na\u271d : Nontrivial R\n\u22a2 \u00acIsField (Polynomial R)"}, {"line": "intro hR", "tactic_state": "R : Type u\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField (Polynomial R)\n\u22a2 False"}, {"line": "obtain \u27e8p, hp\u27e9 := hR.mul_inv_cancel X_ne_zero", "tactic_state": "case intro\nR : Type u\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField (Polynomial R)\np : Polynomial R\nhp : X * p = 1\n\u22a2 False"}, {"line": "have hp0 : p \u2260 0 := right_ne_zero_of_mul_eq_one hp", "tactic_state": "case intro\nR : Type u\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField (Polynomial R)\np : Polynomial R\nhp : X * p = 1\nhp0 : p \u2260 0\n\u22a2 False"}, {"line": "have := degree_lt_degree_mul_X hp0", "tactic_state": "case intro\nR : Type u\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField (Polynomial R)\np : Polynomial R\nhp : X * p = 1\nhp0 : p \u2260 0\nthis : p.degree < (p * X).degree\n\u22a2 False"}, {"line": "rw [\u2190 X_mul] at this", "tactic_state": "case intro\nR : Type u\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField (Polynomial R)\np : Polynomial R\nhp : X * p = 1\nhp0 : p \u2260 0\nthis : p.degree < (X * p).degree\n\u22a2 False"}, {"line": "rw [congr_arg degree hp] at this", "tactic_state": "case intro\nR : Type u\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField (Polynomial R)\np : Polynomial R\nhp : X * p = 1\nhp0 : p \u2260 0\nthis : p.degree < degree 1\n\u22a2 False"}, {"line": "rw [degree_one] at this", "tactic_state": "case intro\nR : Type u\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField (Polynomial R)\np : Polynomial R\nhp : X * p = 1\nhp0 : p \u2260 0\nthis : p.degree < 0\n\u22a2 False"}, {"line": "rw [Nat.WithBot.lt_zero_iff] at this", "tactic_state": "case intro\nR : Type u\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField (Polynomial R)\np : Polynomial R\nhp : X * p = 1\nhp0 : p \u2260 0\nthis : p.degree = \u22a5\n\u22a2 False"}, {"line": "rw [degree_eq_bot] at this", "tactic_state": "case intro\nR : Type u\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField (Polynomial R)\np : Polynomial R\nhp : X * p = 1\nhp0 : p \u2260 0\nthis : p = 0\n\u22a2 False"}, {"line": "exact hp0 this", "tactic_state": "No Goals!"}]}
{"declaration": "example : bernsteinPolynomial \u2124 3 2 = 3 * X ^ 2 - 3 * X ^ 3 := by\n  norm_num [bernsteinPolynomial, choose]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Bernstein.lean", "context": {"open": ["Nat (choose)", "Polynomial (X)", "scoped Polynomial"], "variables": ["(R : Type*) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\n\u22a2 bernsteinPolynomial \u2124 3 2 = 3 * X ^ 2 - 3 * X ^ 3"}, {"line": "norm_num [bernsteinPolynomial, choose]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\n\u22a2 3 * X ^ 2 * (1 - X) = 3 * X ^ 2 - 3 * X ^ 3"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_zero_of_lt {n \u03bd : \u2115} (h : n < \u03bd) : bernsteinPolynomial R n \u03bd = 0 := by\n  simp [bernsteinPolynomial, Nat.choose_eq_zero_of_lt h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Bernstein.lean", "context": {"open": ["Nat (choose)", "Polynomial (X)", "scoped Polynomial"], "variables": ["(R : Type*) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn \u03bd : \u2115\nh : n < \u03bd\n\u22a2 bernsteinPolynomial R n \u03bd = 0"}, {"line": "simp [bernsteinPolynomial, Nat.choose_eq_zero_of_lt h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map (f : R \u2192+* S) (n \u03bd : \u2115) :\n    (bernsteinPolynomial R n \u03bd).map f = bernsteinPolynomial S n \u03bd := by simp [bernsteinPolynomial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Bernstein.lean", "context": {"open": ["Nat (choose)", "Polynomial (X)", "scoped Polynomial"], "variables": ["(R : Type*) [CommRing R]", "{R} {S : Type*} [CommRing S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nS : Type u_2\ninst\u271d : CommRing S\nf : R \u2192+* S\nn \u03bd : \u2115\n\u22a2 Polynomial.map f (bernsteinPolynomial R n \u03bd) = bernsteinPolynomial S n \u03bd"}, {"line": "simp [bernsteinPolynomial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem flip (n \u03bd : \u2115) (h : \u03bd \u2264 n) :\n    (bernsteinPolynomial R n \u03bd).comp (1 - X) = bernsteinPolynomial R n (n - \u03bd) := by\n  simp [bernsteinPolynomial, h, tsub_tsub_assoc, mul_right_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Bernstein.lean", "context": {"open": ["Nat (choose)", "Polynomial (X)", "scoped Polynomial"], "variables": ["(R : Type*) [CommRing R]", "{R} {S : Type*} [CommRing S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn \u03bd : \u2115\nh : \u03bd \u2264 n\n\u22a2 (bernsteinPolynomial R n \u03bd).comp (1 - X) = bernsteinPolynomial R n (n - \u03bd)"}, {"line": "simp [bernsteinPolynomial, h, tsub_tsub_assoc, mul_right_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_at_0 (n \u03bd : \u2115) : (bernsteinPolynomial R n \u03bd).eval 0 = if \u03bd = 0 then 1 else 0 := by\n  rw [bernsteinPolynomial]\n  split_ifs with h\n  \u00b7 subst h; simp\n  \u00b7 simp [zero_pow h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Bernstein.lean", "context": {"open": ["Nat (choose)", "Polynomial (X)", "scoped Polynomial"], "variables": ["(R : Type*) [CommRing R]", "{R} {S : Type*} [CommRing S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn \u03bd : \u2115\n\u22a2 Polynomial.eval 0 (bernsteinPolynomial R n \u03bd) = if \u03bd = 0 then 1 else 0"}, {"line": "rw [bernsteinPolynomial]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn \u03bd : \u2115\n\u22a2 Polynomial.eval 0 (\u2191(n.choose \u03bd) * X ^ \u03bd * (1 - X) ^ (n - \u03bd)) = if \u03bd = 0 then 1 else 0"}, {"line": "split_ifs with h", "tactic_state": "case pos\nR : Type u_1\ninst\u271d : CommRing R\nn \u03bd : \u2115\nh : \u03bd = 0\n\u22a2 Polynomial.eval 0 (\u2191(n.choose \u03bd) * X ^ \u03bd * (1 - X) ^ (n - \u03bd)) = 1\n---\ncase neg\nR : Type u_1\ninst\u271d : CommRing R\nn \u03bd : \u2115\nh : \u00ac\u03bd = 0\n\u22a2 Polynomial.eval 0 (\u2191(n.choose \u03bd) * X ^ \u03bd * (1 - X) ^ (n - \u03bd)) = 0"}, {"line": "\u00b7 subst h; simp", "tactic_state": "case neg\nR : Type u_1\ninst\u271d : CommRing R\nn \u03bd : \u2115\nh : \u00ac\u03bd = 0\n\u22a2 Polynomial.eval 0 (\u2191(n.choose \u03bd) * X ^ \u03bd * (1 - X) ^ (n - \u03bd)) = 0"}, {"line": "\u00b7 simp [zero_pow h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_at_1 (n \u03bd : \u2115) : (bernsteinPolynomial R n \u03bd).eval 1 = if \u03bd = n then 1 else 0 := by\n  rw [bernsteinPolynomial]\n  split_ifs with h\n  \u00b7 subst h; simp\n  \u00b7 obtain h\u03bdn | hn\u03bd := Ne.lt_or_lt h\n    \u00b7 simp [zero_pow <| Nat.sub_ne_zero_of_lt h\u03bdn]\n    \u00b7 simp [Nat.choose_eq_zero_of_lt hn\u03bd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Bernstein.lean", "context": {"open": ["Nat (choose)", "Polynomial (X)", "scoped Polynomial"], "variables": ["(R : Type*) [CommRing R]", "{R} {S : Type*} [CommRing S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn \u03bd : \u2115\n\u22a2 Polynomial.eval 1 (bernsteinPolynomial R n \u03bd) = if \u03bd = n then 1 else 0"}, {"line": "rw [bernsteinPolynomial]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn \u03bd : \u2115\n\u22a2 Polynomial.eval 1 (\u2191(n.choose \u03bd) * X ^ \u03bd * (1 - X) ^ (n - \u03bd)) = if \u03bd = n then 1 else 0"}, {"line": "split_ifs with h", "tactic_state": "case pos\nR : Type u_1\ninst\u271d : CommRing R\nn \u03bd : \u2115\nh : \u03bd = n\n\u22a2 Polynomial.eval 1 (\u2191(n.choose \u03bd) * X ^ \u03bd * (1 - X) ^ (n - \u03bd)) = 1\n---\ncase neg\nR : Type u_1\ninst\u271d : CommRing R\nn \u03bd : \u2115\nh : \u00ac\u03bd = n\n\u22a2 Polynomial.eval 1 (\u2191(n.choose \u03bd) * X ^ \u03bd * (1 - X) ^ (n - \u03bd)) = 0"}, {"line": "\u00b7 subst h; simp", "tactic_state": "case neg\nR : Type u_1\ninst\u271d : CommRing R\nn \u03bd : \u2115\nh : \u00ac\u03bd = n\n\u22a2 Polynomial.eval 1 (\u2191(n.choose \u03bd) * X ^ \u03bd * (1 - X) ^ (n - \u03bd)) = 0"}, {"line": "\u00b7 obtain h\u03bdn | hn\u03bd := Ne.lt_or_lt h\n    \u00b7 simp [zero_pow <| Nat.sub_ne_zero_of_lt h\u03bdn]\n    \u00b7 simp [Nat.choose_eq_zero_of_lt hn\u03bd]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivative_succ (n \u03bd : \u2115) : Polynomial.derivative (bernsteinPolynomial R n (\u03bd + 1)) =\n    n * (bernsteinPolynomial R (n - 1) \u03bd - bernsteinPolynomial R (n - 1) (\u03bd + 1)) := by\n  cases n\n  \u00b7 simp [bernsteinPolynomial]\n  \u00b7 rw [Nat.cast_succ]; apply derivative_succ_aux\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Bernstein.lean", "context": {"open": ["Nat (choose)", "Polynomial (X)", "scoped Polynomial"], "variables": ["(R : Type*) [CommRing R]", "{R} {S : Type*} [CommRing S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn \u03bd : \u2115\n\u22a2 Polynomial.derivative (bernsteinPolynomial R n (\u03bd + 1)) =\n    \u2191n * (bernsteinPolynomial R (n - 1) \u03bd - bernsteinPolynomial R (n - 1) (\u03bd + 1))"}, {"line": "cases n", "tactic_state": "case zero\nR : Type u_1\ninst\u271d : CommRing R\n\u03bd : \u2115\n\u22a2 Polynomial.derivative (bernsteinPolynomial R 0 (\u03bd + 1)) =\n    \u21910 * (bernsteinPolynomial R (0 - 1) \u03bd - bernsteinPolynomial R (0 - 1) (\u03bd + 1))\n---\ncase succ\nR : Type u_1\ninst\u271d : CommRing R\n\u03bd n\u271d : \u2115\n\u22a2 Polynomial.derivative (bernsteinPolynomial R (n\u271d + 1) (\u03bd + 1)) =\n    \u2191(n\u271d + 1) * (bernsteinPolynomial R (n\u271d + 1 - 1) \u03bd - bernsteinPolynomial R (n\u271d + 1 - 1) (\u03bd + 1))"}, {"line": "\u00b7 simp [bernsteinPolynomial]", "tactic_state": "case succ\nR : Type u_1\ninst\u271d : CommRing R\n\u03bd n\u271d : \u2115\n\u22a2 Polynomial.derivative (bernsteinPolynomial R (n\u271d + 1) (\u03bd + 1)) =\n    \u2191(n\u271d + 1) * (bernsteinPolynomial R (n\u271d + 1 - 1) \u03bd - bernsteinPolynomial R (n\u271d + 1 - 1) (\u03bd + 1))"}, {"line": "\u00b7 rw [Nat.cast_succ]; apply derivative_succ_aux", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivative_zero (n : \u2115) :\n    Polynomial.derivative (bernsteinPolynomial R n 0) = -n * bernsteinPolynomial R (n - 1) 0 := by\n  simp [bernsteinPolynomial, Polynomial.derivative_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Bernstein.lean", "context": {"open": ["Nat (choose)", "Polynomial (X)", "scoped Polynomial"], "variables": ["(R : Type*) [CommRing R]", "{R} {S : Type*} [CommRing S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\n\u22a2 Polynomial.derivative (bernsteinPolynomial R n 0) = -\u2191n * bernsteinPolynomial R (n - 1) 0"}, {"line": "simp [bernsteinPolynomial, Polynomial.derivative_pow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem T_neg_two : T R (-2) = 2 * X ^ 2 - 1 := by simp [T_two]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Chebyshev.lean", "context": {"open": ["Polynomial"], "variables": ["(R R' : Type*) [CommRing R] [CommRing R']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nT : x\u271d\n\u22a2 sorry = 2 * X ^ 2 - 1"}, {"line": "simp [T_two]", "tactic_state": "x\u271d : Sort u_3\nT : x\u271d\n\u22a2 sorry () = 2 * X ^ 2 - 1"}]}
{"declaration": "theorem U_neg_one : U R (-1) = 0 := by simpa using U_sub_one R 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Chebyshev.lean", "context": {"open": ["Polynomial"], "variables": ["(R R' : Type*) [CommRing R] [CommRing R']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nU : x\u271d\n\u22a2 sorry = 0"}, {"line": "simpa using U_sub_one R 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem U_neg_two : U R (-2) = -1 := by\n  simpa [zero_sub, Int.reduceNeg, U_neg_one, mul_zero, U_zero] using U_sub_two R 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Chebyshev.lean", "context": {"open": ["Polynomial"], "variables": ["(R R' : Type*) [CommRing R] [CommRing R']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nU : x\u271d\n\u22a2 sorry = -1"}, {"line": "simpa [zero_sub, Int.reduceNeg, U_neg_one, mul_zero, U_zero] using U_sub_two R 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem U_neg (n : \u2124) : U R (-n) = -U R (n - 2) := by simpa [sub_sub] using U_neg_sub_one R (n - 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Chebyshev.lean", "context": {"open": ["Polynomial"], "variables": ["(R R' : Type*) [CommRing R] [CommRing R']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nU : x\u271d\nn : \u2124\n\u22a2 sorry = -sorry"}, {"line": "simpa [sub_sub] using U_neg_sub_one R (n - 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem U_neg_sub_two (n : \u2124) : U R (-n - 2) = -U R n := by\n  simpa [sub_eq_add_neg, add_comm] using U_neg R (n + 2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Chebyshev.lean", "context": {"open": ["Polynomial"], "variables": ["(R R' : Type*) [CommRing R] [CommRing R']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nU : x\u271d\nn : \u2124\n\u22a2 sorry = -sorry"}, {"line": "simpa [sub_eq_add_neg, add_comm] using U_neg R (n + 2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem C_neg_two : C R (-2) = X ^ 2 - 2 := by simp [C_two]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Chebyshev.lean", "context": {"open": ["Polynomial"], "variables": ["(R R' : Type*) [CommRing R] [CommRing R']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = X ^ 2 - 2"}, {"line": "simp [C_two]", "tactic_state": "\u22a2 sorry () = X ^ 2 - 2"}]}
{"declaration": "theorem S_neg_one : S R (-1) = 0 := by simpa using S_sub_one R 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Chebyshev.lean", "context": {"open": ["Polynomial"], "variables": ["(R R' : Type*) [CommRing R] [CommRing R']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nS : x\u271d\n\u22a2 sorry = 0"}, {"line": "simpa using S_sub_one R 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem S_neg_two : S R (-2) = -1 := by\n  simpa [zero_sub, Int.reduceNeg, S_neg_one, mul_zero, S_zero] using S_sub_two R 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Chebyshev.lean", "context": {"open": ["Polynomial"], "variables": ["(R R' : Type*) [CommRing R] [CommRing R']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nS : x\u271d\n\u22a2 sorry = -1"}, {"line": "simpa [zero_sub, Int.reduceNeg, S_neg_one, mul_zero, S_zero] using S_sub_two R 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem S_neg (n : \u2124) : S R (-n) = -S R (n - 2) := by simpa [sub_sub] using S_neg_sub_one R (n - 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Chebyshev.lean", "context": {"open": ["Polynomial"], "variables": ["(R R' : Type*) [CommRing R] [CommRing R']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nS : x\u271d\nn : \u2124\n\u22a2 sorry = -sorry"}, {"line": "simpa [sub_sub] using S_neg_sub_one R (n - 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem S_neg_sub_two (n : \u2124) : S R (-n - 2) = -S R n := by\n  simpa [sub_eq_add_neg, add_comm] using S_neg R (n + 2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Chebyshev.lean", "context": {"open": ["Polynomial"], "variables": ["(R R' : Type*) [CommRing R] [CommRing R']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nS : x\u271d\nn : \u2124\n\u22a2 sorry = -sorry"}, {"line": "simpa [sub_eq_add_neg, add_comm] using S_neg R (n + 2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Irreducible.isPrimitive [NoZeroDivisors R]\n    {p : Polynomial R} (hp : Irreducible p) (hp' : p.natDegree \u2260 0) : p.IsPrimitive := by\n  rintro r \u27e8q, hq\u27e9\n  suffices \u00acIsUnit q by simpa using ((hp.2 hq).resolve_right this).map Polynomial.constantCoeff\n  intro H\n  have hr : r \u2260 0 := by rintro rfl; simp_all\n  obtain \u27e8s, hs, rfl\u27e9 := Polynomial.isUnit_iff.mp H\n  simp [hq, Polynomial.natDegree_C_mul hr] at hp'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Content.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nhp : Irreducible p\nhp' : p.natDegree \u2260 0\n\u22a2 p.IsPrimitive"}, {"line": "rintro r \u27e8q, hq\u27e9", "tactic_state": "case intro\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nhp : Irreducible p\nhp' : p.natDegree \u2260 0\nr : R\nq : Polynomial R\nhq : p = Polynomial.C r * q\n\u22a2 IsUnit r"}, {"line": "suffices \u00acIsUnit q by simpa using ((hp.2 hq).resolve_right this).map Polynomial.constantCoeff", "tactic_state": "case intro\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nhp : Irreducible p\nhp' : p.natDegree \u2260 0\nr : R\nq : Polynomial R\nhq : p = Polynomial.C r * q\n\u22a2 \u00acIsUnit q"}, {"line": "intro H", "tactic_state": "case intro\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nhp : Irreducible p\nhp' : p.natDegree \u2260 0\nr : R\nq : Polynomial R\nhq : p = Polynomial.C r * q\nH : IsUnit q\n\u22a2 False"}, {"line": "have hr : r \u2260 0 := sorry", "tactic_state": "case intro\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nhp : Irreducible p\nhp' : p.natDegree \u2260 0\nr : R\nq : Polynomial R\nhq : p = Polynomial.C r * q\nH : IsUnit q\nhr : r \u2260 sorry\n\u22a2 False"}, {"line": "obtain \u27e8s, hs, rfl\u27e9 := Polynomial.isUnit_iff.mp H", "tactic_state": "case intro.intro.intro\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nhp : Irreducible p\nhp' : p.natDegree \u2260 0\nr : R\nhr : r \u2260 sorry\ns : R\nhs : IsUnit s\nhq : p = Polynomial.C r * Polynomial.C s\nH : IsUnit (Polynomial.C s)\n\u22a2 False"}, {"line": "simp [hq, Polynomial.natDegree_C_mul hr] at hp'", "tactic_state": "case intro.intro.intro\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : NoZeroDivisors R\np : Polynomial R\nhp : Irreducible p\nr : R\nhr : r \u2260 sorry\ns : R\nhs : IsUnit s\nhq : p = Polynomial.C r * Polynomial.C s\nH : IsUnit (Polynomial.C s)\nhp' : \u00ac(Polynomial.C r * Polynomial.C s).natDegree = 0\n\u22a2 False"}]}
{"declaration": "theorem isIntegrallyClosed_iff' [IsDomain R] :\n    IsIntegrallyClosed R \u2194\n      \u2200 p : R[X], p.Monic \u2192 (Irreducible p \u2194 Irreducible (p.map <| algebraMap R K)) := by\n  constructor\n  \u00b7 intro hR p hp; exact Monic.irreducible_iff_irreducible_map_fraction_map hp\n  \u00b7 intro H\n    refine\n      (isIntegrallyClosed_iff K).mpr fun {x} hx =>\n        RingHom.mem_range.mp <| minpoly.mem_range_of_degree_eq_one R x ?_\n    rw [\u2190 Monic.degree_map (minpoly.monic hx) (algebraMap R K)]\n    apply\n      degree_eq_one_of_irreducible_of_root ((H _ <| minpoly.monic hx).mp (minpoly.irreducible hx))\n    rw [IsRoot]\n    rw [eval_map]\n    rw [\u2190 aeval_def]\n    rw [minpoly.aeval R x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/GaussLemma.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "Polynomial", "integralClosure", "IsIntegrallyClosed", "IsIntegrallyClosed"], "variables": ["{R : Type*} [CommRing R]", "(K : Type*) [Field K] [Algebra R K]", "[IsFractionRing R K]", "{S : Type*} [CommRing S] [IsDomain S]", "{\u03c6 : R \u2192+* S} (hinj : Function.Injective \u03c6) {f : R[X]} (hf : f.IsPrimitive)", "{K : Type*} [Field K] [Algebra R K] [IsFractionRing R K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nK : Type u_4\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra R K\ninst\u271d\u00b9 : IsFractionRing R K\ninst\u271d : IsDomain R\n\u22a2 IsIntegrallyClosed R \u2194 \u2200 (p : Polynomial R), p.Monic \u2192 (Irreducible p \u2194 Irreducible (map (algebraMap R K) p))"}, {"line": "constructor", "tactic_state": "case mp\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nK : Type u_4\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra R K\ninst\u271d\u00b9 : IsFractionRing R K\ninst\u271d : IsDomain R\n\u22a2 IsIntegrallyClosed R \u2192 \u2200 (p : Polynomial R), p.Monic \u2192 (Irreducible p \u2194 Irreducible (map (algebraMap R K) p))\n---\ncase mpr\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nK : Type u_4\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra R K\ninst\u271d\u00b9 : IsFractionRing R K\ninst\u271d : IsDomain R\n\u22a2 (\u2200 (p : Polynomial R), p.Monic \u2192 (Irreducible p \u2194 Irreducible (map (algebraMap R K) p))) \u2192 IsIntegrallyClosed R"}, {"line": "\u00b7 intro hR p hp; exact Monic.irreducible_iff_irreducible_map_fraction_map hp", "tactic_state": "case mpr\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nK : Type u_4\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra R K\ninst\u271d\u00b9 : IsFractionRing R K\ninst\u271d : IsDomain R\n\u22a2 (\u2200 (p : Polynomial R), p.Monic \u2192 (Irreducible p \u2194 Irreducible (map (algebraMap R K) p))) \u2192 IsIntegrallyClosed R"}, {"line": "\u00b7 intro H\n    refine\n      (isIntegrallyClosed_iff K).mpr fun {x} hx =>\n        RingHom.mem_range.mp <| minpoly.mem_range_of_degree_eq_one R x ?_\n    rw [\u2190 Monic.degree_map (minpoly.monic hx) (algebraMap R K)]\n    apply\n      degree_eq_one_of_irreducible_of_root ((H _ <| minpoly.monic hx).mp (minpoly.irreducible hx))\n    rw [IsRoot]\n    rw [eval_map]\n    rw [\u2190 aeval_def]\n    rw [minpoly.aeval R x]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ker_evalRingHom (x : R) : RingHom.ker (evalRingHom x) = Ideal.span {X - C x} := by\n  ext y\n  simp [Ideal.mem_span_singleton, dvd_iff_isRoot, RingHom.mem_ker]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Ideal.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["{R : Type*} [CommRing R] {a : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nx : R\n\u22a2 RingHom.ker (evalRingHom x) = Ideal.span {X - C x}"}, {"line": "ext y", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\nx : R\ny : Polynomial R\n\u22a2 y \u2208 RingHom.ker (evalRingHom x) \u2194 y \u2208 Ideal.span {X - C x}"}, {"line": "simp [Ideal.mem_span_singleton, dvd_iff_isRoot, RingHom.mem_ker]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem opRingEquiv_op_monomial (n : \u2115) (r : R) :\n    opRingEquiv R (op (monomial n r : R[X])) = monomial n (op r) := by\n  simp only [opRingEquiv]\n  simp only [RingEquiv.coe_trans]\n  simp only [Function.comp_apply]\n  simp only [AddMonoidAlgebra.opRingEquiv_apply]\n  simp only [RingEquiv.op_apply_apply]\n  simp only [toFinsuppIso_apply]\n  simp only [unop_op]\n  simp only [toFinsupp_monomial]\n  simp only [Finsupp.mapRange_single]\n  simp only [toFinsuppIso_symm_apply]\n  simp only [ofFinsupp_single]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Opposites.lean", "context": {"open": ["Polynomial", "Polynomial MulOpposite"], "variables": ["{R : Type*} [Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\nr : R\n\u22a2 (opRingEquiv R) (op ((monomial n) r)) = (monomial n) (op r)"}, {"line": "simp only [opRingEquiv]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\nr : R\n\u22a2 (((RingEquiv.op (toFinsuppIso R)).trans AddMonoidAlgebra.opRingEquiv).trans (toFinsuppIso R\u1d50\u1d52\u1d56).symm)\n      (op ((monomial n) r)) =\n    (monomial n) (op r)"}, {"line": "simp only [RingEquiv.coe_trans]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\nr : R\n\u22a2 (\u21d1(toFinsuppIso R\u1d50\u1d52\u1d56).symm \u2218 \u21d1AddMonoidAlgebra.opRingEquiv \u2218 \u21d1(RingEquiv.op (toFinsuppIso R))) (op ((monomial n) r)) =\n    (monomial n) (op r)"}, {"line": "simp only [Function.comp_apply]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\nr : R\n\u22a2 (toFinsuppIso R\u1d50\u1d52\u1d56).symm (AddMonoidAlgebra.opRingEquiv ((RingEquiv.op (toFinsuppIso R)) (op ((monomial n) r)))) =\n    (monomial n) (op r)"}, {"line": "simp only [AddMonoidAlgebra.opRingEquiv_apply]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\nr : R\n\u22a2 (toFinsuppIso R\u1d50\u1d52\u1d56).symm (Finsupp.mapRange op \u22ef (unop ((RingEquiv.op (toFinsuppIso R)) (op ((monomial n) r))))) =\n    (monomial n) (op r)"}, {"line": "simp only [RingEquiv.op_apply_apply]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\nr : R\n\u22a2 (toFinsuppIso R\u1d50\u1d52\u1d56).symm (Finsupp.mapRange op \u22ef (unop (op ((toFinsuppIso R) (unop (op ((monomial n) r))))))) =\n    (monomial n) (op r)"}, {"line": "simp only [toFinsuppIso_apply]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\nr : R\n\u22a2 (toFinsuppIso R\u1d50\u1d52\u1d56).symm (Finsupp.mapRange op \u22ef (unop (op (unop (op ((monomial n) r))).toFinsupp))) =\n    (monomial n) (op r)"}, {"line": "simp only [unop_op]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\nr : R\n\u22a2 (toFinsuppIso R\u1d50\u1d52\u1d56).symm (Finsupp.mapRange op \u22ef ((monomial n) r).toFinsupp) = (monomial n) (op r)"}, {"line": "simp only [toFinsupp_monomial]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\nr : R\n\u22a2 (toFinsuppIso R\u1d50\u1d52\u1d56).symm (Finsupp.mapRange op \u22ef fun\u2080 | n => r) = (monomial n) (op r)"}, {"line": "simp only [Finsupp.mapRange_single]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\nr : R\n\u22a2 ((toFinsuppIso R\u1d50\u1d52\u1d56).symm fun\u2080 | n => op r) = (monomial n) (op r)"}, {"line": "simp only [toFinsuppIso_symm_apply]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\nr : R\n\u22a2 { toFinsupp := fun\u2080 | n => op r } = (monomial n) (op r)"}, {"line": "simp only [ofFinsupp_single]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem opRingEquiv_symm_C_mul_X_pow (r : R\u1d50\u1d52\u1d56) (n : \u2115) :\n    (opRingEquiv R).symm (C r * X ^ n : R\u1d50\u1d52\u1d56[X]) = op (C (unop r) * X ^ n) := by\n  rw [C_mul_X_pow_eq_monomial]\n  rw [opRingEquiv_symm_monomial]\n  rw [C_mul_X_pow_eq_monomial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Opposites.lean", "context": {"open": ["Polynomial", "Polynomial MulOpposite"], "variables": ["{R : Type*} [Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nr : R\u1d50\u1d52\u1d56\nn : \u2115\n\u22a2 (opRingEquiv R).symm (C r * X ^ n) = op (C (unop r) * X ^ n)"}, {"line": "rw [C_mul_X_pow_eq_monomial]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nr : R\u1d50\u1d52\u1d56\nn : \u2115\n\u22a2 (opRingEquiv R).symm ((monomial n) r) = op (C (unop r) * X ^ n)"}, {"line": "rw [opRingEquiv_symm_monomial]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nr : R\u1d50\u1d52\u1d56\nn : \u2115\n\u22a2 op ((monomial n) (unop r)) = op (C (unop r) * X ^ n)"}, {"line": "rw [C_mul_X_pow_eq_monomial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_opRingEquiv (p : R[X]\u1d50\u1d52\u1d56) (n : \u2115) :\n    (opRingEquiv R p).coeff n = op ((unop p).coeff n) := by\n  induction' p with p\n  cases p\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Opposites.lean", "context": {"open": ["Polynomial", "Polynomial MulOpposite"], "variables": ["{R : Type*} [Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\np : (Polynomial R)\u1d50\u1d52\u1d56\nn : \u2115\n\u22a2 ((opRingEquiv R) p).coeff n = op ((unop p).coeff n)"}, {"line": "induction' p with p", "tactic_state": "case h\nR : Type u_1\ninst\u271d : Semiring R\nn : \u2115\np : Polynomial R\n\u22a2 ((opRingEquiv R) (op p)).coeff n = op ((unop (op p)).coeff n)"}, {"line": "cases p", "tactic_state": "case h.ofFinsupp\nR : Type u_1\ninst\u271d : Semiring R\nn : \u2115\ntoFinsupp\u271d : AddMonoidAlgebra R \u2115\n\u22a2 ((opRingEquiv R) (op { toFinsupp := toFinsupp\u271d })).coeff n = op ((unop (op { toFinsupp := toFinsupp\u271d })).coeff n)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_opRingEquiv (p : R[X]\u1d50\u1d52\u1d56) : (opRingEquiv R p).support = (unop p).support := by\n  induction' p with p\n  cases p\n  exact Finsupp.support_mapRange_of_injective (map_zero _) _ op_injective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Opposites.lean", "context": {"open": ["Polynomial", "Polynomial MulOpposite"], "variables": ["{R : Type*} [Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\np : (Polynomial R)\u1d50\u1d52\u1d56\n\u22a2 ((opRingEquiv R) p).support = (unop p).support"}, {"line": "induction' p with p", "tactic_state": "case h\nR : Type u_1\ninst\u271d : Semiring R\np : Polynomial R\n\u22a2 ((opRingEquiv R) (op p)).support = (unop (op p)).support"}, {"line": "cases p", "tactic_state": "case h.ofFinsupp\nR : Type u_1\ninst\u271d : Semiring R\ntoFinsupp\u271d : AddMonoidAlgebra R \u2115\n\u22a2 ((opRingEquiv R) (op { toFinsupp := toFinsupp\u271d })).support = (unop (op { toFinsupp := toFinsupp\u271d })).support"}, {"line": "exact Finsupp.support_mapRange_of_injective (map_zero _) _ op_injective", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_opRingEquiv (p : R[X]\u1d50\u1d52\u1d56) : (opRingEquiv R p).natDegree = (unop p).natDegree := by\n  by_cases p0 : p = 0\n  \u00b7 simp only [p0, map_zero, natDegree_zero, unop_zero]\n  \u00b7 simp only [p0, natDegree_eq_support_max', Ne, EmbeddingLike.map_eq_zero_iff, not_false_iff,\n      support_opRingEquiv, unop_eq_zero_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Opposites.lean", "context": {"open": ["Polynomial", "Polynomial MulOpposite"], "variables": ["{R : Type*} [Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\np : (Polynomial R)\u1d50\u1d52\u1d56\n\u22a2 ((opRingEquiv R) p).natDegree = (unop p).natDegree"}, {"line": "by_cases p0 : p = 0", "tactic_state": "case pos\nR : Type u_1\ninst\u271d : Semiring R\np : (Polynomial R)\u1d50\u1d52\u1d56\np0 : p = 0\n\u22a2 ((opRingEquiv R) p).natDegree = (unop p).natDegree\n---\ncase neg\nR : Type u_1\ninst\u271d : Semiring R\np : (Polynomial R)\u1d50\u1d52\u1d56\np0 : \u00acp = 0\n\u22a2 ((opRingEquiv R) p).natDegree = (unop p).natDegree"}, {"line": "\u00b7 simp only [p0, map_zero, natDegree_zero, unop_zero]", "tactic_state": "case neg\nR : Type u_1\ninst\u271d : Semiring R\np : (Polynomial R)\u1d50\u1d52\u1d56\np0 : \u00acp = 0\n\u22a2 ((opRingEquiv R) p).natDegree = (unop p).natDegree"}, {"line": "\u00b7 simp only [p0, natDegree_eq_support_max', Ne, EmbeddingLike.map_eq_zero_iff, not_false_iff,\n      support_opRingEquiv, unop_eq_zero_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leadingCoeff_opRingEquiv (p : R[X]\u1d50\u1d52\u1d56) :\n    (opRingEquiv R p).leadingCoeff = op (unop p).leadingCoeff := by\n  rw [leadingCoeff]\n  rw [coeff_opRingEquiv]\n  rw [natDegree_opRingEquiv]\n  rw [leadingCoeff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Opposites.lean", "context": {"open": ["Polynomial", "Polynomial MulOpposite"], "variables": ["{R : Type*} [Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\np : (Polynomial R)\u1d50\u1d52\u1d56\n\u22a2 ((opRingEquiv R) p).leadingCoeff = op (unop p).leadingCoeff"}, {"line": "rw [leadingCoeff]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\np : (Polynomial R)\u1d50\u1d52\u1d56\n\u22a2 ((opRingEquiv R) p).coeff ((opRingEquiv R) p).natDegree = op (unop p).leadingCoeff"}, {"line": "rw [coeff_opRingEquiv]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\np : (Polynomial R)\u1d50\u1d52\u1d56\n\u22a2 op ((unop p).coeff ((opRingEquiv R) p).natDegree) = op (unop p).leadingCoeff"}, {"line": "rw [natDegree_opRingEquiv]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\np : (Polynomial R)\u1d50\u1d52\u1d56\n\u22a2 op ((unop p).coeff (unop p).natDegree) = op (unop p).leadingCoeff"}, {"line": "rw [leadingCoeff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_radical_le {a : k[X]} :\n    (radical a).natDegree \u2264 a.natDegree := by\n  by_cases ha : a = 0\n  \u00b7 simp [ha]\n  \u00b7 exact natDegree_le_of_dvd (radical_dvd_self a) ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Radical.lean", "context": {"open": ["Polynomial UniqueFactorizationMonoid UniqueFactorizationDomain EuclideanDomain"], "variables": ["{k : Type*} [Field k] [DecidableEq k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\na : Polynomial k\n\u22a2 (radical a).natDegree \u2264 a.natDegree"}, {"line": "by_cases ha : a = 0", "tactic_state": "case pos\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\na : Polynomial k\nha : a = 0\n\u22a2 (radical a).natDegree \u2264 a.natDegree\n---\ncase neg\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\na : Polynomial k\nha : \u00aca = 0\n\u22a2 (radical a).natDegree \u2264 a.natDegree"}, {"line": "\u00b7 simp [ha]", "tactic_state": "case neg\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\na : Polynomial k\nha : \u00aca = 0\n\u22a2 (radical a).natDegree \u2264 a.natDegree"}, {"line": "\u00b7 exact natDegree_le_of_dvd (radical_dvd_self a) ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem divRadical_dvd_derivative (a : k[X]) : divRadical a \u2223 derivative a := by\n  induction a using induction_on_coprime\n  \u00b7 case h0 =>\n    rw [derivative_zero]\n    apply dvd_zero\n  \u00b7 case h1 a ha =>\n    exact (divRadical_isUnit ha).dvd\n  \u00b7 case hpr p i hp =>\n    cases i\n    \u00b7 rw [pow_zero, derivative_one]\n      apply dvd_zero\n    \u00b7 case succ i =>\n      rw [\u2190 mul_dvd_mul_iff_left (radical_ne_zero (p ^ i.succ))]\n      rw [radical_mul_divRadical]\n      rw [radical_pow_of_prime hp i.succ_pos]\n      rw [derivative_pow_succ]\n      rw [\u2190 mul_assoc]\n      apply dvd_mul_of_dvd_left\n      rw [mul_comm]\n      rw [mul_assoc]\n      apply dvd_mul_of_dvd_right\n      rw [pow_succ]\n      rw [mul_dvd_mul_iff_left (pow_ne_zero i hp.ne_zero)]\n      rw [dvd_normalize_iff]\n  \u00b7 -- If it holds for coprime pair a and b, then it also holds for a * b.\n    case hcp x y hpxy hx hy =>\n    have hc : IsCoprime x y :=\n      EuclideanDomain.isCoprime_of_dvd\n        (fun \u27e8hx, hy\u27e9 => not_isUnit_zero (hpxy (zero_dvd_iff.mpr hx) (zero_dvd_iff.mpr hy)))\n        fun p hp _ hpx hpy => hp (hpxy hpx hpy)\n    rw [divRadical_mul hc]\n    rw [derivative_mul]\n    exact dvd_add (mul_dvd_mul hx (divRadical_dvd_self y)) (mul_dvd_mul (divRadical_dvd_self x) hy)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Radical.lean", "context": {"open": ["Polynomial UniqueFactorizationMonoid UniqueFactorizationDomain EuclideanDomain"], "variables": ["{k : Type*} [Field k] [DecidableEq k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\na : Polynomial k\n\u22a2 divRadical a \u2223 derivative a"}, {"line": "induction a using induction_on_coprime", "tactic_state": "case h0\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\n\u22a2 divRadical 0 \u2223 derivative 0\n---\ncase h1\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\nx\u271d : Polynomial k\na\u271d : IsUnit x\u271d\n\u22a2 divRadical x\u271d \u2223 derivative x\u271d\n---\ncase hpr\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\np\u271d : Polynomial k\ni\u271d : \u2115\na\u271d : Prime p\u271d\n\u22a2 divRadical (p\u271d ^ i\u271d) \u2223 derivative (p\u271d ^ i\u271d)\n---\ncase hcp\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\nx\u271d y\u271d : Polynomial k\na\u271d\u00b2 : IsRelPrime x\u271d y\u271d\na\u271d\u00b9 : divRadical x\u271d \u2223 derivative x\u271d\na\u271d : divRadical y\u271d \u2223 derivative y\u271d\n\u22a2 divRadical (x\u271d * y\u271d) \u2223 derivative (x\u271d * y\u271d)"}, {"line": "\u00b7 case h0 =>\n    rw [derivative_zero]\n    apply dvd_zero", "tactic_state": "case h1\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\nx\u271d : Polynomial k\na\u271d : IsUnit x\u271d\n\u22a2 divRadical x\u271d \u2223 derivative x\u271d\n---\ncase hpr\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\np\u271d : Polynomial k\ni\u271d : \u2115\na\u271d : Prime p\u271d\n\u22a2 divRadical (p\u271d ^ i\u271d) \u2223 derivative (p\u271d ^ i\u271d)\n---\ncase hcp\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\nx\u271d y\u271d : Polynomial k\na\u271d\u00b2 : IsRelPrime x\u271d y\u271d\na\u271d\u00b9 : divRadical x\u271d \u2223 derivative x\u271d\na\u271d : divRadical y\u271d \u2223 derivative y\u271d\n\u22a2 divRadical (x\u271d * y\u271d) \u2223 derivative (x\u271d * y\u271d)"}, {"line": "\u00b7 case h1 a ha =>\n    exact (divRadical_isUnit ha).dvd", "tactic_state": "case hpr\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\np\u271d : Polynomial k\ni\u271d : \u2115\na\u271d : Prime p\u271d\n\u22a2 divRadical (p\u271d ^ i\u271d) \u2223 derivative (p\u271d ^ i\u271d)\n---\ncase hcp\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\nx\u271d y\u271d : Polynomial k\na\u271d\u00b2 : IsRelPrime x\u271d y\u271d\na\u271d\u00b9 : divRadical x\u271d \u2223 derivative x\u271d\na\u271d : divRadical y\u271d \u2223 derivative y\u271d\n\u22a2 divRadical (x\u271d * y\u271d) \u2223 derivative (x\u271d * y\u271d)"}, {"line": "\u00b7 case hpr p i hp =>\n    cases i\n    \u00b7 rw [pow_zero, derivative_one]\n      apply dvd_zero\n    \u00b7 case succ i =>\n      rw [\u2190 mul_dvd_mul_iff_left (radical_ne_zero (p ^ i.succ))]\n      rw [radical_mul_divRadical]\n      rw [radical_pow_of_prime hp i.succ_pos]\n      rw [derivative_pow_succ]\n      rw [\u2190 mul_assoc]\n      apply dvd_mul_of_dvd_left\n      rw [mul_comm]\n      rw [mul_assoc]\n      apply dvd_mul_of_dvd_right\n      rw [pow_succ]\n      rw [mul_dvd_mul_iff_left (pow_ne_zero i hp.ne_zero)]\n      rw [dvd_normalize_iff]", "tactic_state": "case hcp\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\nx\u271d y\u271d : Polynomial k\na\u271d\u00b2 : IsRelPrime x\u271d y\u271d\na\u271d\u00b9 : divRadical x\u271d \u2223 derivative x\u271d\na\u271d : divRadical y\u271d \u2223 derivative y\u271d\n\u22a2 divRadical (x\u271d * y\u271d) \u2223 derivative (x\u271d * y\u271d)"}, {"line": "\u00b7 -- If it holds for coprime pair a and b, then it also holds for a * b.\n    case hcp x y hpxy hx hy =>\n    have hc : IsCoprime x y :=\n      EuclideanDomain.isCoprime_of_dvd\n        (fun \u27e8hx, hy\u27e9 => not_isUnit_zero (hpxy (zero_dvd_iff.mpr hx) (zero_dvd_iff.mpr hy)))\n        fun p hp _ hpx hpy => hp (hpxy hpx hpy)\n    rw [divRadical_mul hc]\n    rw [derivative_mul]\n    exact dvd_add (mul_dvd_mul hx (divRadical_dvd_self y)) (mul_dvd_mul (divRadical_dvd_self x) hy)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem divRadical_dvd_wronskian_left (a b : k[X]) : divRadical a \u2223 wronskian a b := by\n  rw [wronskian]\n  apply dvd_sub\n  \u00b7 apply dvd_mul_of_dvd_left\n    exact divRadical_dvd_self a\n  \u00b7 apply dvd_mul_of_dvd_left\n    exact divRadical_dvd_derivative a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Radical.lean", "context": {"open": ["Polynomial UniqueFactorizationMonoid UniqueFactorizationDomain EuclideanDomain"], "variables": ["{k : Type*} [Field k] [DecidableEq k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\na b : Polynomial k\n\u22a2 divRadical a \u2223 a.wronskian b"}, {"line": "rw [wronskian]", "tactic_state": "k : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\na b : Polynomial k\n\u22a2 divRadical a \u2223 a * derivative b - derivative a * b"}, {"line": "apply dvd_sub", "tactic_state": "case h\u2081\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\na b : Polynomial k\n\u22a2 divRadical a \u2223 a * derivative b\n---\ncase h\u2082\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\na b : Polynomial k\n\u22a2 divRadical a \u2223 derivative a * b"}, {"line": "\u00b7 apply dvd_mul_of_dvd_left\n    exact divRadical_dvd_self a", "tactic_state": "case h\u2082\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\na b : Polynomial k\n\u22a2 divRadical a \u2223 derivative a * b"}, {"line": "\u00b7 apply dvd_mul_of_dvd_left\n    exact divRadical_dvd_derivative a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem divRadical_dvd_wronskian_right (a b : k[X]) : divRadical b \u2223 wronskian a b := by\n  rw [\u2190 wronskian_neg_eq]\n  rw [dvd_neg]\n  exact divRadical_dvd_wronskian_left _ _", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Radical.lean", "context": {"open": ["Polynomial UniqueFactorizationMonoid UniqueFactorizationDomain EuclideanDomain"], "variables": ["{k : Type*} [Field k] [DecidableEq k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\na b : Polynomial k\n\u22a2 divRadical b \u2223 a.wronskian b"}, {"line": "rw [\u2190 wronskian_neg_eq]", "tactic_state": "k : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\na b : Polynomial k\n\u22a2 divRadical b \u2223 -b.wronskian a"}, {"line": "rw [dvd_neg]", "tactic_state": "k : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\na b : Polynomial k\n\u22a2 divRadical b \u2223 b.wronskian a"}, {"line": "exact divRadical_dvd_wronskian_left _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_scaleRoots (p : R[X]) (s : R) (i : \u2115) :\n    (scaleRoots p s).coeff i = coeff p i * s ^ (p.natDegree - i) := by\n  simp +contextual [scaleRoots, coeff_monomial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/ScaleRoots.lean", "context": {"open": [], "variables": ["{R S A K : Type*}", "[Semiring R] [Semiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nidx\u271d : Type u_5\nX : idx\u271d\nx\u271d : Sort u_6\nscaleRoots : x\u271d\nvalid\u271d : outParam (Type u_1 \u2192 idx\u271d \u2192 Prop)\ncoeff : valid\u271d R X\np : R[X]\ns : R\ni : \u2115\n\u22a2 sorry = sorry * s ^ (sorry - i)"}, {"line": "simp +contextual [scaleRoots, coeff_monomial]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nidx\u271d : Type u_5\nX : idx\u271d\nx\u271d : Sort u_6\nscaleRoots : x\u271d\nvalid\u271d : outParam (Type u_1 \u2192 idx\u271d \u2192 Prop)\ncoeff : valid\u271d R X\np : R[X]\ns : R\ni : \u2115\n\u22a2 sorry () = sorry () * s ^ (sorry () - i)"}]}
{"declaration": "theorem IsSeparableContraction.dvd_degree' {g} (hf : IsSeparableContraction q f g) :\n    \u2203 m : \u2115, g.natDegree * q ^ m = f.natDegree := by\n  obtain \u27e8m, rfl\u27e9 := hf.2\n  use m\n  rw [natDegree_expand]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/SeparableDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{F : Type*} [CommSemiring F] (q : \u2115)", "{q} {f : F[X]} (hf : HasSeparableContraction q f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d : CommSemiring F\nq : \u2115\nf g : Polynomial F\nhf : IsSeparableContraction q f g\n\u22a2 \u2203 m, g.natDegree * q ^ m = f.natDegree"}, {"line": "obtain \u27e8m, rfl\u27e9 := hf.2", "tactic_state": "case intro\nF : Type u_1\ninst\u271d : CommSemiring F\nq : \u2115\ng : Polynomial F\nm : \u2115\nhf : IsSeparableContraction q ((expand F (q ^ m)) g) g\n\u22a2 \u2203 m_1, g.natDegree * q ^ m_1 = ((expand F (q ^ m)) g).natDegree"}, {"line": "use m", "tactic_state": "case h\nF : Type u_1\ninst\u271d : CommSemiring F\nq : \u2115\ng : Polynomial F\nm : \u2115\nhf : IsSeparableContraction q ((expand F (q ^ m)) g) g\n\u22a2 g.natDegree * q ^ m = ((expand F (q ^ m)) g).natDegree"}, {"line": "rw [natDegree_expand]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem contraction_degree_eq_or_insep [hq : NeZero q] [CharP F q] (g g' : F[X]) (m m' : \u2115)\n    (h_expand : expand F (q ^ m) g = expand F (q ^ m') g') (hg : g.Separable) (hg' : g'.Separable) :\n    g.natDegree = g'.natDegree := by\n  wlog hm : m \u2264 m'\n  \u00b7 exact (this q g' g m' m h_expand.symm hg' hg (le_of_not_le hm)).symm\n  obtain \u27e8s, rfl\u27e9 := exists_add_of_le hm\n  rw [pow_add] at h_expand\n  rw [expand_mul] at h_expand\n  rw [expand_inj (pow_pos (NeZero.pos q) m)] at h_expand\n  subst h_expand\n  rcases isUnit_or_eq_zero_of_separable_expand q s (NeZero.pos q) hg with (h | rfl)\n  \u00b7 rw [natDegree_expand, natDegree_eq_zero_of_isUnit h, zero_mul]\n  \u00b7 rw [natDegree_expand, pow_zero, mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/SeparableDegree.lean", "context": {"open": ["Polynomial"], "variables": ["{F : Type*} [CommSemiring F] (q : \u2115)", "{q} {f : F[X]} (hf : HasSeparableContraction q f)", "{F : Type*} [Field F]", "(q : \u2115) {f : F[X]} (hf : HasSeparableContraction q f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_2\ninst\u271d\u00b9 : Field F\nq : \u2115\nhq : NeZero q\ninst\u271d : CharP F q\ng g' : Polynomial F\nm m' : \u2115\nh_expand : (expand F (q ^ m)) g = (expand F (q ^ m')) g'\nhg : g.Separable\nhg' : g'.Separable\n\u22a2 g.natDegree = g'.natDegree"}, {"line": "wlog hm : m \u2264 m'", "tactic_state": "case inr\nF : Type u_2\ninst\u271d\u00b9 : Field F\nq : \u2115\nhq : NeZero q\ninst\u271d : CharP F q\ng g' : Polynomial F\nm m' : \u2115\nh_expand : (expand F (q ^ m)) g = (expand F (q ^ m')) g'\nhg : g.Separable\nhg' : g'.Separable\nthis :\n  \u2200 {F : Type u_2} [inst : Field F] (q : \u2115) [hq : NeZero q] [inst_1 : CharP F q] (g g' : Polynomial F) (m m' : \u2115),\n    (expand F (q ^ m)) g = (expand F (q ^ m')) g' \u2192 g.Separable \u2192 g'.Separable \u2192 m \u2264 m' \u2192 g.natDegree = g'.natDegree\nhm : \u00acm \u2264 m'\n\u22a2 g.natDegree = g'.natDegree\n---\nF\u271d : Type u_2\ninst\u271d\u00b2 : Field F\u271d\nq\u271d : \u2115\nF : Type u_2\ninst\u271d\u00b9 : Field F\nq : \u2115\nhq : NeZero q\ninst\u271d : CharP F q\ng g' : Polynomial F\nm m' : \u2115\nh_expand : (expand F (q ^ m)) g = (expand F (q ^ m')) g'\nhg : g.Separable\nhg' : g'.Separable\nhm : m \u2264 m'\n\u22a2 g.natDegree = g'.natDegree"}, {"line": "\u00b7 exact (this q g' g m' m h_expand.symm hg' hg (le_of_not_le hm)).symm", "tactic_state": "F\u271d : Type u_2\ninst\u271d\u00b2 : Field F\u271d\nq\u271d : \u2115\nF : Type u_2\ninst\u271d\u00b9 : Field F\nq : \u2115\nhq : NeZero q\ninst\u271d : CharP F q\ng g' : Polynomial F\nm m' : \u2115\nh_expand : (expand F (q ^ m)) g = (expand F (q ^ m')) g'\nhg : g.Separable\nhg' : g'.Separable\nhm : m \u2264 m'\n\u22a2 g.natDegree = g'.natDegree"}, {"line": "obtain \u27e8s, rfl\u27e9 := exists_add_of_le hm", "tactic_state": "case intro\nF\u271d : Type u_2\ninst\u271d\u00b2 : Field F\u271d\nq\u271d : \u2115\nF : Type u_2\ninst\u271d\u00b9 : Field F\nq : \u2115\nhq : NeZero q\ninst\u271d : CharP F q\ng g' : Polynomial F\nm : \u2115\nhg : g.Separable\nhg' : g'.Separable\ns : \u2115\nh_expand : (expand F (q ^ m)) g = (expand F (q ^ (m + s))) g'\nhm : m \u2264 m + s\n\u22a2 g.natDegree = g'.natDegree"}, {"line": "rw [pow_add] at h_expand", "tactic_state": "case intro\nF\u271d : Type u_2\ninst\u271d\u00b2 : Field F\u271d\nq\u271d : \u2115\nF : Type u_2\ninst\u271d\u00b9 : Field F\nq : \u2115\nhq : NeZero q\ninst\u271d : CharP F q\ng g' : Polynomial F\nm : \u2115\nhg : g.Separable\nhg' : g'.Separable\ns : \u2115\nh_expand : (expand F (q ^ m)) g = (expand F (q ^ m * q ^ s)) g'\nhm : m \u2264 m + s\n\u22a2 g.natDegree = g'.natDegree"}, {"line": "rw [expand_mul] at h_expand", "tactic_state": "case intro\nF\u271d : Type u_2\ninst\u271d\u00b2 : Field F\u271d\nq\u271d : \u2115\nF : Type u_2\ninst\u271d\u00b9 : Field F\nq : \u2115\nhq : NeZero q\ninst\u271d : CharP F q\ng g' : Polynomial F\nm : \u2115\nhg : g.Separable\nhg' : g'.Separable\ns : \u2115\nh_expand : (expand F (q ^ m)) g = (expand F (q ^ m)) ((expand F (q ^ s)) g')\nhm : m \u2264 m + s\n\u22a2 g.natDegree = g'.natDegree"}, {"line": "rw [expand_inj (pow_pos (NeZero.pos q) m)] at h_expand", "tactic_state": "case intro\nF\u271d : Type u_2\ninst\u271d\u00b2 : Field F\u271d\nq\u271d : \u2115\nF : Type u_2\ninst\u271d\u00b9 : Field F\nq : \u2115\nhq : NeZero q\ninst\u271d : CharP F q\ng g' : Polynomial F\nm : \u2115\nhg : g.Separable\nhg' : g'.Separable\ns : \u2115\nh_expand : g = (expand F (q ^ s)) g'\nhm : m \u2264 m + s\n\u22a2 g.natDegree = g'.natDegree"}, {"line": "subst h_expand", "tactic_state": "case intro\nF\u271d : Type u_2\ninst\u271d\u00b2 : Field F\u271d\nq\u271d : \u2115\nF : Type u_2\ninst\u271d\u00b9 : Field F\nq : \u2115\nhq : NeZero q\ninst\u271d : CharP F q\ng' : Polynomial F\nm : \u2115\nhg' : g'.Separable\ns : \u2115\nhm : m \u2264 m + s\nhg : ((expand F (q ^ s)) g').Separable\n\u22a2 ((expand F (q ^ s)) g').natDegree = g'.natDegree"}, {"line": "rcases isUnit_or_eq_zero_of_separable_expand q s (NeZero.pos q) hg with (h | rfl)", "tactic_state": "case intro.inl\nF\u271d : Type u_2\ninst\u271d\u00b2 : Field F\u271d\nq\u271d : \u2115\nF : Type u_2\ninst\u271d\u00b9 : Field F\nq : \u2115\nhq : NeZero q\ninst\u271d : CharP F q\ng' : Polynomial F\nm : \u2115\nhg' : g'.Separable\ns : \u2115\nhm : m \u2264 m + s\nhg : ((expand F (q ^ s)) g').Separable\nh : IsUnit g'\n\u22a2 ((expand F (q ^ s)) g').natDegree = g'.natDegree\n---\ncase intro.inr\nF\u271d : Type u_2\ninst\u271d\u00b2 : Field F\u271d\nq\u271d : \u2115\nF : Type u_2\ninst\u271d\u00b9 : Field F\nq : \u2115\nhq : NeZero q\ninst\u271d : CharP F q\ng' : Polynomial F\nm : \u2115\nhg' : g'.Separable\nhm : m \u2264 m + 0\nhg : ((expand F (q ^ 0)) g').Separable\n\u22a2 ((expand F (q ^ 0)) g').natDegree = g'.natDegree"}, {"line": "\u00b7 rw [natDegree_expand, natDegree_eq_zero_of_isUnit h, zero_mul]", "tactic_state": "case intro.inr\nF\u271d : Type u_2\ninst\u271d\u00b2 : Field F\u271d\nq\u271d : \u2115\nF : Type u_2\ninst\u271d\u00b9 : Field F\nq : \u2115\nhq : NeZero q\ninst\u271d : CharP F q\ng' : Polynomial F\nm : \u2115\nhg' : g'.Separable\nhm : m \u2264 m + 0\nhg : ((expand F (q ^ 0)) g').Separable\n\u22a2 ((expand F (q ^ 0)) g').natDegree = g'.natDegree"}, {"line": "\u00b7 rw [natDegree_expand, pow_zero, mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cyclotomic_two (R : Type*) [Ring R] : cyclotomic 2 R = X + 1 := by simp [cyclotomic_prime]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean", "context": {"open": ["scoped Polynomial", "Finset"], "variables": ["{R : Type*} [CommRing R] [IsDomain R]", "{K : Type*} [Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\ncyclotomic : x\u271d\nX : \u2115\nR : Type u_3\ninst\u271d : Ring R\n\u22a2 sorry = X + 1"}, {"line": "simp [cyclotomic_prime]", "tactic_state": "x\u271d : Sort u_4\ncyclotomic : x\u271d\nX : \u2115\nR : Type u_3\ninst\u271d : Ring R\n\u22a2 sorry () = X + 1"}]}
{"declaration": "theorem cyclotomic_three (R : Type*) [Ring R] : cyclotomic 3 R = X ^ 2 + X + 1 := by\n  simp [cyclotomic_prime, sum_range_succ']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean", "context": {"open": ["scoped Polynomial", "Finset"], "variables": ["{R : Type*} [CommRing R] [IsDomain R]", "{K : Type*} [Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\ncyclotomic : x\u271d\nX : \u2115\nR : Type u_3\ninst\u271d : Ring R\n\u22a2 sorry = X ^ 2 + X + 1"}, {"line": "simp [cyclotomic_prime, sum_range_succ']", "tactic_state": "x\u271d : Sort u_4\ncyclotomic : x\u271d\nX : \u2115\nR : Type u_3\ninst\u271d : Ring R\n\u22a2 sorry () = X ^ 2 + X + 1"}]}
{"declaration": "theorem eval\u2082_one_cyclotomic_prime {R S : Type*} [CommRing R] [Semiring S] (f : R \u2192+* S) {p : \u2115}\n    [Fact p.Prime] : eval\u2082 f 1 (cyclotomic p R) = p := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Cyclotomic/Eval.lean", "context": {"open": ["Finset Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\neval\u2082 : x\u271d\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 sorry = p"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_3\neval\u2082 : x\u271d\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 sorry () = p"}]}
{"declaration": "theorem eval\u2082_one_cyclotomic_prime_pow {R S : Type*} [CommRing R] [Semiring S] (f : R \u2192+* S)\n    {p : \u2115} (k : \u2115) [Fact p.Prime] : eval\u2082 f 1 (cyclotomic (p ^ (k + 1)) R) = p := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Cyclotomic/Eval.lean", "context": {"open": ["Finset Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\neval\u2082 : x\u271d\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\np k : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 sorry = p"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_3\neval\u2082 : x\u271d\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\np k : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 sorry () = p"}]}
{"declaration": "theorem map (hf : f.IsWeaklyEisensteinAt \ud835\udcdf) {A : Type v} [CommSemiring A] (\u03c6 : R \u2192+* A) :\n    (f.map \u03c6).IsWeaklyEisensteinAt (\ud835\udcdf.map \u03c6) := by\n  refine (isWeaklyEisensteinAt_iff _ _).2 fun hn => ?_\n  rw [coeff_map]\n  exact mem_map_of_mem _ (hf.mem (lt_of_lt_of_le hn natDegree_map_le))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Eisenstein/Basic.lean", "context": {"open": ["Ideal Algebra Finset", "Polynomial"], "variables": ["{R : Type u}", "[CommSemiring R] {\ud835\udcdf : Ideal R} {f : R[X]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\n\ud835\udcdf : Ideal R\nf : Polynomial R\nhf : f.IsWeaklyEisensteinAt \ud835\udcdf\nA : Type v\ninst\u271d : CommSemiring A\n\u03c6 : R \u2192+* A\n\u22a2 (Polynomial.map \u03c6 f).IsWeaklyEisensteinAt (Ideal.map \u03c6 \ud835\udcdf)"}, {"line": "refine (isWeaklyEisensteinAt_iff _ _).2 fun hn => ?_", "tactic_state": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\n\ud835\udcdf : Ideal R\nf : Polynomial R\nhf : f.IsWeaklyEisensteinAt \ud835\udcdf\nA : Type v\ninst\u271d : CommSemiring A\n\u03c6 : R \u2192+* A\nn\u271d : \u2115\nhn : n\u271d < (Polynomial.map \u03c6 f).natDegree\n\u22a2 (Polynomial.map \u03c6 f).coeff n\u271d \u2208 Ideal.map \u03c6 \ud835\udcdf"}, {"line": "rw [coeff_map]", "tactic_state": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\n\ud835\udcdf : Ideal R\nf : Polynomial R\nhf : f.IsWeaklyEisensteinAt \ud835\udcdf\nA : Type v\ninst\u271d : CommSemiring A\n\u03c6 : R \u2192+* A\nn\u271d : \u2115\nhn : n\u271d < (Polynomial.map \u03c6 f).natDegree\n\u22a2 \u03c6 (f.coeff n\u271d) \u2208 Ideal.map \u03c6 \ud835\udcdf"}, {"line": "exact mem_map_of_mem _ (hf.mem (lt_of_lt_of_le hn natDegree_map_le))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hermite_eq_deriv_gaussian (n : \u2115) (x : \u211d) : aeval x (hermite n) =\n    (-1 : \u211d) ^ n * deriv^[n] (fun y => Real.exp (-(y ^ 2 / 2))) x / Real.exp (-(x ^ 2 / 2)) := by\n  rw [deriv_gaussian_eq_hermite_mul_gaussian]\n  field_simp [Real.exp_ne_zero]\n  rw [\u2190 @smul_eq_mul \u211d _ ((-1) ^ n)]\n  rw [\u2190 inv_smul_eq_iff\u2080]\n  rw [mul_assoc]\n  rw [smul_eq_mul]\n  rw [\u2190 inv_pow]\n  rw [\u2190     neg_inv]\n  rw [inv_one]\n  exact pow_ne_zero _ (by norm_num)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Hermite/Gaussian.lean", "context": {"open": ["Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx : \u211d\n\u22a2 (aeval x) (hermite n) = (-1) ^ n * deriv^[n] (fun y => Real.exp (-(y ^ 2 / 2))) x / Real.exp (-(x ^ 2 / 2))"}, {"line": "rw [deriv_gaussian_eq_hermite_mul_gaussian]", "tactic_state": "n : \u2115\nx : \u211d\n\u22a2 (aeval x) (hermite n) =\n    (-1) ^ n * ((-1) ^ n * (aeval x) (hermite n) * Real.exp (-(x ^ 2 / 2))) / Real.exp (-(x ^ 2 / 2))"}, {"line": "field_simp [Real.exp_ne_zero]", "tactic_state": "n : \u2115\nx : \u211d\n\u22a2 (aeval x) (hermite n) * Real.exp (-x ^ 2 / 2) = (-1) ^ n * ((-1) ^ n * (aeval x) (hermite n) * Real.exp (-x ^ 2 / 2))"}, {"line": "rw [\u2190 @smul_eq_mul \u211d _ ((-1) ^ n)]", "tactic_state": "n : \u2115\nx : \u211d\n\u22a2 (aeval x) (hermite n) * Real.exp (-x ^ 2 / 2) = (-1) ^ n \u2022 ((-1) ^ n * (aeval x) (hermite n) * Real.exp (-x ^ 2 / 2))"}, {"line": "rw [\u2190 inv_smul_eq_iff\u2080]", "tactic_state": "n : \u2115\nx : \u211d\n\u22a2 ((-1) ^ n)\u207b\u00b9 \u2022 ((aeval x) (hermite n) * Real.exp (-x ^ 2 / 2)) =\n    (-1) ^ n * (aeval x) (hermite n) * Real.exp (-x ^ 2 / 2)\n---\ncase ha\nn : \u2115\nx : \u211d\n\u22a2 (-1) ^ n \u2260 0"}, {"line": "rw [mul_assoc]", "tactic_state": "n : \u2115\nx : \u211d\n\u22a2 ((-1) ^ n)\u207b\u00b9 \u2022 ((aeval x) (hermite n) * Real.exp (-x ^ 2 / 2)) =\n    (-1) ^ n * ((aeval x) (hermite n) * Real.exp (-x ^ 2 / 2))\n---\ncase ha\nn : \u2115\nx : \u211d\n\u22a2 (-1) ^ n \u2260 0"}, {"line": "rw [smul_eq_mul]", "tactic_state": "n : \u2115\nx : \u211d\n\u22a2 ((-1) ^ n)\u207b\u00b9 * ((aeval x) (hermite n) * Real.exp (-x ^ 2 / 2)) =\n    (-1) ^ n * ((aeval x) (hermite n) * Real.exp (-x ^ 2 / 2))\n---\ncase ha\nn : \u2115\nx : \u211d\n\u22a2 (-1) ^ n \u2260 0"}, {"line": "rw [\u2190 inv_pow]", "tactic_state": "n : \u2115\nx : \u211d\n\u22a2 (-1)\u207b\u00b9 ^ n * ((aeval x) (hermite n) * Real.exp (-x ^ 2 / 2)) =\n    (-1) ^ n * ((aeval x) (hermite n) * Real.exp (-x ^ 2 / 2))\n---\ncase ha\nn : \u2115\nx : \u211d\n\u22a2 (-1) ^ n \u2260 0"}, {"line": "rw [\u2190     neg_inv]", "tactic_state": "n : \u2115\nx : \u211d\n\u22a2 (-1\u207b\u00b9) ^ n * ((aeval x) (hermite n) * Real.exp (-x ^ 2 / 2)) =\n    (-1) ^ n * ((aeval x) (hermite n) * Real.exp (-x ^ 2 / 2))\n---\ncase ha\nn : \u2115\nx : \u211d\n\u22a2 (-1) ^ n \u2260 0"}, {"line": "rw [inv_one]", "tactic_state": "case ha\nn : \u2115\nx : \u211d\n\u22a2 (-1) ^ n \u2260 0"}, {"line": "exact pow_ne_zero _ (by norm_num)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hermite_eq_deriv_gaussian' (n : \u2115) (x : \u211d) : aeval x (hermite n) =\n    (-1 : \u211d) ^ n * deriv^[n] (fun y => Real.exp (-(y ^ 2 / 2))) x * Real.exp (x ^ 2 / 2) := by\n  rw [hermite_eq_deriv_gaussian]\n  rw [Real.exp_neg]\n  field_simp [Real.exp_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Hermite/Gaussian.lean", "context": {"open": ["Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx : \u211d\n\u22a2 (aeval x) (hermite n) = (-1) ^ n * deriv^[n] (fun y => Real.exp (-(y ^ 2 / 2))) x * Real.exp (x ^ 2 / 2)"}, {"line": "rw [hermite_eq_deriv_gaussian]", "tactic_state": "n : \u2115\nx : \u211d\n\u22a2 (-1) ^ n * deriv^[n] (fun y => Real.exp (-(y ^ 2 / 2))) x / Real.exp (-(x ^ 2 / 2)) =\n    (-1) ^ n * deriv^[n] (fun y => Real.exp (-(y ^ 2 / 2))) x * Real.exp (x ^ 2 / 2)"}, {"line": "rw [Real.exp_neg]", "tactic_state": "n : \u2115\nx : \u211d\n\u22a2 (-1) ^ n * deriv^[n] (fun y => Real.exp (-(y ^ 2 / 2))) x / (Real.exp (x ^ 2 / 2))\u207b\u00b9 =\n    (-1) ^ n * deriv^[n] (fun y => Real.exp (-(y ^ 2 / 2))) x * Real.exp (x ^ 2 / 2)"}, {"line": "field_simp [Real.exp_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hermite_one : hermite 1 = X := by\n  rw [hermite_succ]\n  rw [hermite_zero]\n  simp only [map_one]\n  simp only [mul_one]\n  simp only [derivative_one]\n  simp only [sub_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Hermite/Basic.lean", "context": {"open": ["Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 hermite 1 = X"}, {"line": "rw [hermite_succ]", "tactic_state": "\u22a2 X * hermite 0 - derivative (hermite 0) = X"}, {"line": "rw [hermite_zero]", "tactic_state": "\u22a2 X * C 1 - derivative (C 1) = X"}, {"line": "simp only [map_one]", "tactic_state": "\u22a2 X * 1 - derivative 1 = X"}, {"line": "simp only [mul_one]", "tactic_state": "\u22a2 X - derivative 1 = X"}, {"line": "simp only [derivative_one]", "tactic_state": "\u22a2 X - 0 = X"}, {"line": "simp only [sub_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_hermite_succ_zero (n : \u2115) : coeff (hermite (n + 1)) 0 = -coeff (hermite n) 1 := by\n  simp [coeff_derivative]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Hermite/Basic.lean", "context": {"open": ["Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 (hermite (n + 1)).coeff 0 = -(hermite n).coeff 1"}, {"line": "simp [coeff_derivative]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_hermite_succ_succ (n k : \u2115) : coeff (hermite (n + 1)) (k + 1) =\n    coeff (hermite n) k - (k + 2) * coeff (hermite n) (k + 2) := by\n  rw [hermite_succ]\n  rw [coeff_sub]\n  rw [coeff_X_mul]\n  rw [coeff_derivative]\n  rw [mul_comm]\n  norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Hermite/Basic.lean", "context": {"open": ["Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\n\u22a2 (hermite (n + 1)).coeff (k + 1) = (hermite n).coeff k - (\u2191k + 2) * (hermite n).coeff (k + 2)"}, {"line": "rw [hermite_succ]", "tactic_state": "n k : \u2115\n\u22a2 (X * hermite n - derivative (hermite n)).coeff (k + 1) = (hermite n).coeff k - (\u2191k + 2) * (hermite n).coeff (k + 2)"}, {"line": "rw [coeff_sub]", "tactic_state": "n k : \u2115\n\u22a2 (X * hermite n).coeff (k + 1) - (derivative (hermite n)).coeff (k + 1) =\n    (hermite n).coeff k - (\u2191k + 2) * (hermite n).coeff (k + 2)"}, {"line": "rw [coeff_X_mul]", "tactic_state": "n k : \u2115\n\u22a2 (hermite n).coeff k - (derivative (hermite n)).coeff (k + 1) =\n    (hermite n).coeff k - (\u2191k + 2) * (hermite n).coeff (k + 2)"}, {"line": "rw [coeff_derivative]", "tactic_state": "n k : \u2115\n\u22a2 (hermite n).coeff k - (hermite n).coeff (k + 1 + 1) * (\u2191(k + 1) + 1) =\n    (hermite n).coeff k - (\u2191k + 2) * (hermite n).coeff (k + 2)"}, {"line": "rw [mul_comm]", "tactic_state": "n k : \u2115\n\u22a2 (hermite n).coeff k - (\u2191(k + 1) + 1) * (hermite n).coeff (k + 1 + 1) =\n    (hermite n).coeff k - (\u2191k + 2) * (hermite n).coeff (k + 2)"}, {"line": "norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leadingCoeff_hermite (n : \u2115) : (hermite n).leadingCoeff = 1 := by\n  rw [\u2190 coeff_natDegree]\n  rw [natDegree_hermite]\n  rw [coeff_hermite_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Hermite/Basic.lean", "context": {"open": ["Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 (hermite n).leadingCoeff = 1"}, {"line": "rw [\u2190 coeff_natDegree]", "tactic_state": "n : \u2115\n\u22a2 (hermite n).coeff (hermite n).natDegree = 1"}, {"line": "rw [natDegree_hermite]", "tactic_state": "n : \u2115\n\u22a2 (hermite n).coeff n = 1"}, {"line": "rw [coeff_hermite_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_hermite (n k : \u2115) :\n    coeff (hermite n) k =\n      if Even (n + k) then (-1 : \u2124) ^ ((n - k) / 2) * (n - k - 1)\u203c * Nat.choose n k else 0 := by\n  split_ifs with h\n  \u00b7 exact coeff_hermite_of_even_add h\n  \u00b7 exact coeff_hermite_of_odd_add (Nat.not_even_iff_odd.1 h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Polynomial/Hermite/Basic.lean", "context": {"open": ["Polynomial", "scoped Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\n\u22a2 (hermite n).coeff k = if Even (n + k) then (-1) ^ ((n - k) / 2) * \u2191(n - k - 1).doubleFactorial * \u2191(n.choose k) else 0"}, {"line": "split_ifs with h", "tactic_state": "case pos\nn k : \u2115\nh : Even (n + k)\n\u22a2 (hermite n).coeff k = (-1) ^ ((n - k) / 2) * \u2191(n - k - 1).doubleFactorial * \u2191(n.choose k)\n---\ncase neg\nn k : \u2115\nh : \u00acEven (n + k)\n\u22a2 (hermite n).coeff k = 0"}, {"line": "\u00b7 exact coeff_hermite_of_even_add h", "tactic_state": "case neg\nn k : \u2115\nh : \u00acEven (n + k)\n\u22a2 (hermite n).coeff k = 0"}, {"line": "\u00b7 exact coeff_hermite_of_odd_add (Nat.not_even_iff_odd.1 h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PolynomialLaw.isCompat_apply'\n    {R : Type u} [CommSemiring R] {M : Type*} [AddCommMonoid M] [Module R M]\n    {N : Type*} [AddCommMonoid N] [Module R N] {f : M \u2192\u209a\u2097[R] N}\n    {S : Type u} [CommSemiring S] [Algebra R S] {S' : Type u} [CommSemiring S'] [Algebra R S']\n    (\u03c6 : S \u2192\u2090[R] S') (x : S \u2297[R] M) :\n    (\u03c6.toLinearMap.rTensor N) ((f.toFun' S) x) = (f.toFun' S') (\u03c6.toLinearMap.rTensor M x) := by\n  simpa only using congr_fun (f.isCompat' \u03c6) x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PolynomialLaw/Basic.lean", "context": {"open": ["scoped TensorProduct", "LinearMap TensorProduct AlgHom"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2078 : CommSemiring R\nM : Type u_1\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\nN : Type u_2\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\nf : M \u2192\u209a\u2097[R] N\nS : Type u\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nS' : Type u\ninst\u271d\u00b9 : CommSemiring S'\ninst\u271d : Algebra R S'\n\u03c6 : S \u2192\u2090[R] S'\nx : TensorProduct R S M\n\u22a2 (rTensor N \u03c6.toLinearMap) (f.toFun' S x) = f.toFun' S' ((rTensor M \u03c6.toLinearMap) x)"}, {"line": "simpa only using congr_fun (f.isCompat' \u03c6) x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem invUnitsSub_mul_sub (u : R\u02e3) : invUnitsSub u * (C R u - X) = 1 := by\n  simp [mul_sub, sub_sub_cancel]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerSeries/WellKnown.lean", "context": {"open": [], "variables": ["{R S : Type*} [Ring R] [Ring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\nx\u271d\u00b9 : Sort u_3\ninvUnitsSub : x\u271d\u00b9\nx\u271d : Sort u_4\nC : x\u271d\nX : \u2115\nu : R\u02e3\n\u22a2 sorry * (sorry - X) = 1"}, {"line": "simp [mul_sub, sub_sub_cancel]", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\nx\u271d\u00b9 : Sort u_3\ninvUnitsSub : x\u271d\u00b9\nx\u271d : Sort u_4\nC : x\u271d\nX : \u2115\nu : R\u02e3\n\u22a2 sorry () = 1 \u2227 sorry () - X = 1"}]}
{"declaration": "theorem invOneSubPow_val_one_eq_invUnitSub_one :\n    (invOneSubPow S 1).val = invUnitsSub (1 : S\u02e3) := by\n  simp [invOneSubPow, invUnitsSub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerSeries/WellKnown.lean", "context": {"open": [], "variables": ["{R S : Type*} [Ring R] [Ring S]", "(S : Type*) [CommRing S] (d : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_4\ninvOneSubPow : x\u271d\u00b9\nx\u271d : Sort u_5\ninvUnitsSub : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [invOneSubPow, invUnitsSub]", "tactic_state": "x\u271d\u00b9 : Sort u_4\ninvOneSubPow : x\u271d\u00b9\nx\u271d : Sort u_5\ninvUnitsSub : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem one_sub_pow_mul_invOneSubPow_val_add_eq_invOneSubPow_val (e : \u2115) :\n    (1 - X) ^ e * (invOneSubPow S (d + e)).val = (invOneSubPow S d).val := by\n  simp [invOneSubPow_add, Units.val_mul, mul_comm, mul_assoc, \u2190 invOneSubPow_inv_eq_one_sub_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerSeries/WellKnown.lean", "context": {"open": [], "variables": ["{R S : Type*} [Ring R] [Ring S]", "(S : Type*) [CommRing S] (d : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : \u2115\nx\u271d : Sort u_4\ninvOneSubPow : x\u271d\ne : \u2115\n\u22a2 (1 - X) ^ e * sorry = sorry"}, {"line": "simp [invOneSubPow_add, Units.val_mul, mul_comm, mul_assoc, \u2190 invOneSubPow_inv_eq_one_sub_pow]", "tactic_state": "X : \u2115\nx\u271d : Sort u_4\ninvOneSubPow : x\u271d\ne : \u2115\n\u22a2 (1 - X) ^ e * sorry () = sorry ()"}]}
{"declaration": "theorem one_sub_pow_add_mul_invOneSubPow_val_eq_one_sub_pow (e : \u2115) :\n    (1 - X) ^ (d + e) * (invOneSubPow S e).val = (1 - X) ^ d := by\n  simp [pow_add, mul_assoc, \u2190 invOneSubPow_inv_eq_one_sub_pow S e]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerSeries/WellKnown.lean", "context": {"open": [], "variables": ["{R S : Type*} [Ring R] [Ring S]", "(S : Type*) [CommRing S] (d : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d X : \u2115\nx\u271d : Sort u_4\ninvOneSubPow : x\u271d\ne : \u2115\n\u22a2 (1 - X) ^ (d + e) * sorry = (1 - X) ^ d"}, {"line": "simp [pow_add, mul_assoc, \u2190 invOneSubPow_inv_eq_one_sub_pow S e]", "tactic_state": "d X : \u2115\nx\u271d : Sort u_4\ninvOneSubPow : x\u271d\ne : \u2115\n\u22a2 (1 - X) ^ d * ((1 - X) ^ e * sorry ()) = (1 - X) ^ d"}]}
{"declaration": "theorem exp_mul_exp_neg_eq_one [Algebra \u211a A] : exp A * evalNegHom (exp A) = 1 := by\n  convert exp_mul_exp_eq_exp_add (1 : A) (-1) <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerSeries/WellKnown.lean", "context": {"open": ["Nat", "RingHom", "Finset Nat"], "variables": ["{R S : Type*} [Ring R] [Ring S]", "(S : Type*) [CommRing S] (d : \u2115)", "(A A' : Type*) [Ring A] [Ring A'] [Algebra \u211a A] [Algebra \u211a A']", "{A A'} (n : \u2115)", "(f : A \u2192+* A')", "{A : Type*} [CommRing A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_6\ninst\u271d\u00b9 : CommRing A\nx\u271d\u00b9 : Sort u_7\nexp : x\u271d\u00b9\nx\u271d : Sort u_8\nevalNegHom : x\u271d\ninst\u271d : Algebra \u211a A\n\u22a2 sorry * sorry = 1"}, {"line": "convert exp_mul_exp_eq_exp_add (1 : A) (-1) <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_pow_eq_rescale_exp [Algebra \u211a A] (k : \u2115) : exp A ^ k = rescale (k : A) (exp A) := by\n  induction' k with k h\n  \u00b7 simp only [rescale_zero, constantCoeff_exp, Function.comp_apply, map_one, cast_zero, zero_eq,\n      pow_zero (exp A), coe_comp]\n  \u00b7 simpa only [succ_eq_add_one,cast_add,\u2190 exp_mul_exp_eq_exp_add (k : A),\u2190 h,cast_one,id_apply,rescale_one] using pow_succ (exp A) k\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerSeries/WellKnown.lean", "context": {"open": ["Nat", "RingHom", "Finset Nat"], "variables": ["{R S : Type*} [Ring R] [Ring S]", "(S : Type*) [CommRing S] (d : \u2115)", "(A A' : Type*) [Ring A] [Ring A'] [Algebra \u211a A] [Algebra \u211a A']", "{A A'} (n : \u2115)", "(f : A \u2192+* A')", "{A : Type*} [CommRing A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_6\ninst\u271d\u00b9 : CommRing A\nx\u271d\u00b9 : Sort u_7\nexp : x\u271d\u00b9\nx\u271d : Sort u_8\nrescale : x\u271d\ninst\u271d : Algebra \u211a A\nk : \u2115\n\u22a2 sorry ^ k = sorry"}, {"line": "induction' k with k h", "tactic_state": "case zero\nA : Type u_6\ninst\u271d\u00b9 : CommRing A\nx\u271d\u00b9 : Sort u_7\nexp : x\u271d\u00b9\nx\u271d : Sort u_8\nrescale : x\u271d\ninst\u271d : Algebra \u211a A\n\u22a2 sorry ^ 0 = sorry\n---\ncase succ\nA : Type u_6\ninst\u271d\u00b9 : CommRing A\nx\u271d\u00b9 : Sort u_7\nexp : x\u271d\u00b9\nx\u271d : Sort u_8\nrescale : x\u271d\ninst\u271d : Algebra \u211a A\nk : \u2115\nh : sorry ^ k = sorry\n\u22a2 sorry ^ (k + 1) = sorry"}, {"line": "\u00b7 simp only [rescale_zero, constantCoeff_exp, Function.comp_apply, map_one, cast_zero, zero_eq,\n      pow_zero (exp A), coe_comp]", "tactic_state": "case succ\nA : Type u_6\ninst\u271d\u00b9 : CommRing A\nx\u271d\u00b9 : Sort u_7\nexp : x\u271d\u00b9\nx\u271d : Sort u_8\nrescale : x\u271d\ninst\u271d : Algebra \u211a A\nk : \u2115\nh : sorry ^ k = sorry\n\u22a2 sorry ^ (k + 1) = sorry"}, {"line": "\u00b7 simpa only [succ_eq_add_one,cast_add,\u2190 exp_mul_exp_eq_exp_add (k : A),\u2190 h,cast_one,id_apply,rescale_one] using pow_succ (exp A) k", "tactic_state": "No Goals!"}]}
{"declaration": "theorem monomial_zero_eq_C_apply (a : R) : monomial R 0 a = C R a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerSeries/Basic.lean", "context": {"open": ["Finset (antidiagonal mem_antidiagonal)", "Finsupp (single)"], "variables": ["{R : Type*}", "(R) [Semiring R]", "{R}", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nx\u271d\u00b9 : Sort u_2\nmonomial : x\u271d\u00b9\nx\u271d : Sort u_3\nC : x\u271d\na : R\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeff_zero_mul_X (\u03c6 : R\u27e6X\u27e7) : coeff R 0 (\u03c6 * X) = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerSeries/Basic.lean", "context": {"open": ["Finset (antidiagonal mem_antidiagonal)", "Finsupp (single)"], "variables": ["{R : Type*}", "(R) [Semiring R]", "{R}", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nA\u271d : Type u_2\nX : A\u271d\nx\u271d : Sort u_3\ncoeff : x\u271d\n\u03c6 : (CategoryTheory.shiftFunctor (Type u_1) X).obj R\n\u22a2 sorry = 0"}, {"line": "simp", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nA\u271d : Type u_2\nX : A\u271d\nx\u271d : Sort u_3\ncoeff : x\u271d\n\u03c6 : (CategoryTheory.shiftFunctor (Type u_1) X).obj R\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem coeff_zero_X_mul (\u03c6 : R\u27e6X\u27e7) : coeff R 0 (X * \u03c6) = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerSeries/Basic.lean", "context": {"open": ["Finset (antidiagonal mem_antidiagonal)", "Finsupp (single)"], "variables": ["{R : Type*}", "(R) [Semiring R]", "{R}", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nA\u271d : Type u_2\nX : A\u271d\nx\u271d : Sort u_3\ncoeff : x\u271d\n\u03c6 : (CategoryTheory.shiftFunctor (Type u_1) X).obj R\n\u22a2 sorry = 0"}, {"line": "simp", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nA\u271d : Type u_2\nX : A\u271d\nx\u271d : Sort u_3\ncoeff : x\u271d\n\u03c6 : (CategoryTheory.shiftFunctor (Type u_1) X).obj R\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem coeff_C_mul_X_pow (x : R) (k n : \u2115) :\n    coeff R n (C R x * X ^ k : R\u27e6X\u27e7) = if n = k then x else 0 := by\n  simp [X_pow_eq, coeff_monomial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerSeries/Basic.lean", "context": {"open": ["Finset (antidiagonal mem_antidiagonal)", "Finsupp (single)"], "variables": ["{R : Type*}", "(R) [Semiring R]", "{R}", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nx\u271d : Sort u_2\ncoeff : x\u271d\nx : R\nk n : \u2115\n\u22a2 sorry = if n = k then x else 0"}, {"line": "simp [X_pow_eq, coeff_monomial]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nx\u271d : Sort u_2\ncoeff : x\u271d\nx : R\nk n : \u2115\n\u22a2 sorry () = if n = k then x else 0"}]}
{"declaration": "theorem coeff_mul_X_pow' (p : R\u27e6X\u27e7) (n d : \u2115) :\n    coeff R d (p * X ^ n) = ite (n \u2264 d) (coeff R (d - n) p) 0 := by\n  split_ifs with h\n  \u00b7 rw [\u2190 tsub_add_cancel_of_le h, coeff_mul_X_pow, add_tsub_cancel_right]\n  \u00b7 refine (coeff_mul _ _ _).trans (Finset.sum_eq_zero fun x hx => ?_)\n    rw [coeff_X_pow]\n    rw [if_neg]\n    rw [mul_zero]\n    exact ((le_of_add_le_right (mem_antidiagonal.mp hx).le).trans_lt <| not_le.mp h).ne\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerSeries/Basic.lean", "context": {"open": ["Finset (antidiagonal mem_antidiagonal)", "Finsupp (single)"], "variables": ["{R : Type*}", "(R) [Semiring R]", "{R}", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nA\u271d : Type u_2\nX : A\u271d\nx\u271d : Sort u_3\ncoeff : x\u271d\np : (CategoryTheory.shiftFunctor (Type u_1) X).obj R\nn d : \u2115\n\u22a2 sorry = if n \u2264 d then sorry else 0"}, {"line": "split_ifs with h", "tactic_state": "case pos\nR : Type u_1\ninst\u271d : Semiring R\nA\u271d : Type u_2\nX : A\u271d\nx\u271d : Sort u_3\ncoeff : x\u271d\np : (CategoryTheory.shiftFunctor (Type u_1) X).obj R\nn d : \u2115\nh : n \u2264 d\n\u22a2 sorry = sorry\n---\ncase neg\nR : Type u_1\ninst\u271d : Semiring R\nA\u271d : Type u_2\nX : A\u271d\nx\u271d : Sort u_3\ncoeff : x\u271d\np : (CategoryTheory.shiftFunctor (Type u_1) X).obj R\nn d : \u2115\nh : \u00acn \u2264 d\n\u22a2 sorry = 0"}, {"line": "\u00b7 rw [\u2190 tsub_add_cancel_of_le h, coeff_mul_X_pow, add_tsub_cancel_right]", "tactic_state": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nA\u271d : Type u_2\nX : A\u271d\nx\u271d : Sort u_3\ncoeff : x\u271d\np : (CategoryTheory.shiftFunctor (Type u_1) X).obj R\nn d : \u2115\nh : \u00acn \u2264 d\n\u22a2 sorry = 0"}, {"line": "\u00b7 refine (coeff_mul _ _ _).trans (Finset.sum_eq_zero fun x hx => ?_)\n    rw [coeff_X_pow]\n    rw [if_neg]\n    rw [mul_zero]\n    exact ((le_of_add_le_right (mem_antidiagonal.mp hx).le).trans_lt <| not_le.mp h).ne", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_C (a : R) : ((C a : R[X]) : PowerSeries R) = PowerSeries.C R a := by\n  have := coe_monomial 0 a\n  rwa [PowerSeries.monomial_zero_eq_C_apply] at this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerSeries/Basic.lean", "context": {"open": ["Finset (antidiagonal mem_antidiagonal)", "Finsupp (single)", "Finset Nat", "Finset.HasAntidiagonal Finset", "Finsupp Polynomial"], "variables": ["{R : Type*}", "(R) [Semiring R]", "{R}", "(R)", "{R}", "{S : Type*} {T : Type*} [Semiring S] [Semiring T]", "(f : R \u2192+* S) (g : S \u2192+* T)", "[CommSemiring R]", "{R : Type*} [CommSemiring R] {\u03b9 : Type*} [DecidableEq \u03b9]", "{A : Type*} [CommRing A]", "{A B : Type*} [CommSemiring R] [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]", "{R : Type*} [Semiring R] (\u03c6 \u03c8 : R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_9\ninst\u271d : Semiring R\na : R\n\u22a2 \u2191(C a) = (PowerSeries.C R) a"}, {"line": "have := coe_monomial 0 a", "tactic_state": "case refine_2\nR : Type u_9\ninst\u271d : Semiring R\na : R\nthis : \u2191((monomial 0) a) = (PowerSeries.monomial R 0) a\n\u22a2 \u2191(C a) = (PowerSeries.C R) a\n---\ncase refine_1\nR : Type u_9\ninst\u271d : Semiring R\na : R\n\u22a2 Semiring R"}, {"line": "rwa [PowerSeries.monomial_zero_eq_C_apply] at this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pUnitAlgEquiv_symm_toPowerSeries {f : Polynomial R} :\n    ((f.toPowerSeries) : MvPowerSeries PUnit R)\n      = ((MvPolynomial.pUnitAlgEquiv R).symm f).toMvPowerSeries := by\n  set g := (MvPolynomial.pUnitAlgEquiv R).symm f\n  have : f = MvPolynomial.pUnitAlgEquiv R g := by simp only [g, AlgEquiv.apply_symm_apply]\n  rw [this]\n  rw [MvPolynomial.toMvPowerSeries_pUnitAlgEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerSeries/Basic.lean", "context": {"open": ["Finset (antidiagonal mem_antidiagonal)", "Finsupp (single)", "Finset Nat", "Finset.HasAntidiagonal Finset", "Finsupp Polynomial"], "variables": ["{R : Type*}", "(R) [Semiring R]", "{R}", "(R)", "{R}", "{S : Type*} {T : Type*} [Semiring S] [Semiring T]", "(f : R \u2192+* S) (g : S \u2192+* T)", "[CommSemiring R]", "{R : Type*} [CommSemiring R] {\u03b9 : Type*} [DecidableEq \u03b9]", "{A : Type*} [CommRing A]", "{A B : Type*} [CommSemiring R] [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]", "{R : Type*} [Semiring R] (\u03c6 \u03c8 : R[X])", "(R)", "{R \u03c6 \u03c8}", "{R : Type*} [CommSemiring R] (\u03c6 \u03c8 : R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_10\ninst\u271d : CommSemiring R\nf : Polynomial R\n\u22a2 \u2191f = \u2191((MvPolynomial.pUnitAlgEquiv R).symm f)"}, {"line": "set g := (MvPolynomial.pUnitAlgEquiv R).symm f", "tactic_state": "R : Type u_10\ninst\u271d : CommSemiring R\nf : Polynomial R\ng : ?m.2103 := sorry\n\u22a2 \u2191f = \u2191((MvPolynomial.pUnitAlgEquiv R).symm f)"}, {"line": "have : f = MvPolynomial.pUnitAlgEquiv R g := by simp only [g, AlgEquiv.apply_symm_apply]", "tactic_state": "R : Type u_10\ninst\u271d : CommSemiring R\nf : Polynomial R\ng : MvPolynomial PUnit.{?u.2223 + 1} R := sorry\nthis : f = sorry\n\u22a2 \u2191f = \u2191((MvPolynomial.pUnitAlgEquiv R).symm f)"}, {"line": "rw [this]", "tactic_state": "R : Type u_10\ninst\u271d : CommSemiring R\nf : Polynomial R\ng : MvPolynomial PUnit.{?u.2223 + 1} R := sorry\nthis : f = sorry\n\u22a2 \u2191sorry = \u2191((MvPolynomial.pUnitAlgEquiv R).symm sorry)"}, {"line": "rw [MvPolynomial.toMvPowerSeries_pUnitAlgEquiv]", "tactic_state": "R : Type u_10\ninst\u271d : CommSemiring R\nf : Polynomial R\ng : MvPolynomial PUnit.{?u.2223 + 1} R := sorry\nthis : f = sorry\n\u22a2 \u2191sorry = \u2191((MvPolynomial.pUnitAlgEquiv R) ((MvPolynomial.pUnitAlgEquiv R).symm sorry))"}]}
{"declaration": "theorem Inv_divided_by_X_pow_order_leftInv {f : k\u27e6X\u27e7} (hf : f \u2260 0) :\n    Inv_divided_by_X_pow_order hf * divXPowOrder f = 1 := by\n  rw [mul_comm]\n  exact mul_invOfUnit (divXPowOrder f) (firstUnitCoeff hf) rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerSeries/Inverse.lean", "context": {"open": ["Polynomial", "Finset (antidiagonal mem_antidiagonal)", "Finsupp (single)"], "variables": ["{R : Type*}", "[Ring R]", "{k : Type*} [Field k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_2\ninst\u271d : Field k\nx\u271d\u00b9 : Sort u_3\nInv_divided_by_X_pow_order : x\u271d\u00b9\nx\u271d : Sort u_4\ndivXPowOrder : x\u271d\nf : (CategoryTheory.shiftFunctor (Type u_2) X).obj k\nhf : f \u2260 sorry\n\u22a2 sorry * sorry = 1"}, {"line": "rw [mul_comm]", "tactic_state": "k : Type u_2\ninst\u271d : Field k\nx\u271d\u00b9 : Sort u_3\nInv_divided_by_X_pow_order : x\u271d\u00b9\nx\u271d : Sort u_4\ndivXPowOrder : x\u271d\nf : (CategoryTheory.shiftFunctor (Type u_2) X).obj k\nhf : f \u2260 sorry\n\u22a2 sorry * sorry = 1"}, {"line": "exact mul_invOfUnit (divXPowOrder f) (firstUnitCoeff hf) rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normUnit_X : normUnit (X : k\u27e6X\u27e7) = 1 := by\n  simp [normUnit, \u2190 Units.val_eq_one, Unit_of_divided_by_X_pow_order_nonzero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerSeries/Inverse.lean", "context": {"open": ["Polynomial", "Finset (antidiagonal mem_antidiagonal)", "Finsupp (single)", "scoped Classical in", "IsDiscreteValuationRing"], "variables": ["{R : Type*}", "[Ring R]", "{k : Type*} [Field k]", "{S : Type*} [CommRing R] [CommRing S] (f : R \u2192+* S) [IsLocalHom f]", "[IsLocalRing R]", "{k : Type*} [Field k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 normUnit sorry = 1"}, {"line": "simp [normUnit, \u2190 Units.val_eq_one, Unit_of_divided_by_X_pow_order_nonzero]", "tactic_state": "\u22a2 normUnit (sorry ()) = 1"}]}
{"declaration": "theorem order_X : order (X : R\u27e6X\u27e7) = 1 := by\n  simpa only [Nat.cast_one] using order_monomial_of_ne_zero 1 (1 : R) one_ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerSeries/Order.lean", "context": {"open": ["Polynomial", "Finset (antidiagonal mem_antidiagonal)", "Finsupp (single)"], "variables": ["{R : Type*}", "[Semiring R] {\u03c6 : R\u27e6X\u27e7}", "[Semiring R] [Nontrivial R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\norder : x\u271d\n\u22a2 sorry = 1"}, {"line": "simpa only [Nat.cast_one] using order_monomial_of_ne_zero 1 (1 : R) one_ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "lemma trunc_one_X : trunc (R := R) 1 X = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/PowerSeries/Trunc.lean", "context": {"open": ["Polynomial", "Finset (antidiagonal mem_antidiagonal)", "Finsupp (single)", "Finset Nat"], "variables": ["{R : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\ntrunc : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_2\ntrunc : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma _root_.RingHom.injective_stableUnderComposition :\n    RingHom.StableUnderComposition (fun f \u21a6 Function.Injective f) := by\n  intro R S T _ _ _ f g hf hg\n  simp only [RingHom.coe_comp]\n  exact Function.Injective.comp hg hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/RingHom/Injective.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 RingHom.StableUnderComposition fun {R S} [CommRing R] [CommRing S] f => Function.Injective \u21d1f"}, {"line": "intro R S T _ _ _ f g hf hg", "tactic_state": "R S T : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : CommRing T\nf : R \u2192+* S\ng : S \u2192+* T\nhf : Function.Injective \u21d1f\nhg : Function.Injective \u21d1g\n\u22a2 Function.Injective \u21d1(g.comp f)"}, {"line": "simp only [RingHom.coe_comp]", "tactic_state": "R S T : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : CommRing T\nf : R \u2192+* S\ng : S \u2192+* T\nhf : Function.Injective \u21d1f\nhg : Function.Injective \u21d1g\n\u22a2 Function.Injective (\u21d1g \u2218 \u21d1f)"}, {"line": "exact Function.Injective.comp hg hf", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.RingHom.injective_respectsIso :\n    RingHom.RespectsIso (fun f \u21a6 Function.Injective f) := by\n  apply RingHom.injective_stableUnderComposition.respectsIso\n  intro R S _ _ e\n  exact e.bijective.injective", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/RingHom/Injective.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] f => Function.Injective \u21d1f"}, {"line": "apply RingHom.injective_stableUnderComposition.respectsIso", "tactic_state": "\u22a2 \u2200 {R S : Type u_1} [inst : CommRing R] [inst_1 : CommRing S] (e : R \u2243+* S), Function.Injective \u21d1e.toRingHom"}, {"line": "intro R S _ _ e", "tactic_state": "R S : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\ne : R \u2243+* S\n\u22a2 Function.Injective \u21d1e.toRingHom"}, {"line": "exact e.bijective.injective", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPrimitiveRoot_exp (n : \u2115) (h0 : n \u2260 0) : IsPrimitiveRoot (exp (2 * \u03c0 * I / n)) n := by\n  simpa only [Nat.cast_one,one_div] using\n    isPrimitiveRoot_exp_of_coprime 1 n h0 n.coprime_one_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/RootsOfUnity/Complex.lean", "context": {"open": ["Polynomial Real", "scoped Nat Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : \u211d\nn : \u2115\nh0 : n \u2260 0\n\u22a2 IsPrimitiveRoot (exp (2 * Real.pi * I / \u2191n)) n"}, {"line": "simpa only [Nat.cast_one,one_div] using\n    isPrimitiveRoot_exp_of_coprime 1 n h0 n.coprime_one_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_primitiveRoots (k : \u2115) : (primitiveRoots k \u2102).card = \u03c6 k := by\n  by_cases h : k = 0\n  \u00b7 simp [h]\n  exact (isPrimitiveRoot_exp k h).card_primitiveRoots\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/RootsOfUnity/Complex.lean", "context": {"open": ["Polynomial Real", "scoped Nat Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2115\n\u22a2 (primitiveRoots k \u2102).card = k.totient"}, {"line": "by_cases h : k = 0", "tactic_state": "case pos\nk : \u2115\nh : k = 0\n\u22a2 (primitiveRoots k \u2102).card = k.totient\n---\ncase neg\nk : \u2115\nh : \u00ack = 0\n\u22a2 (primitiveRoots k \u2102).card = k.totient"}, {"line": "\u00b7 simp [h]", "tactic_state": "case neg\nk : \u2115\nh : \u00ack = 0\n\u22a2 (primitiveRoots k \u2102).card = k.totient"}, {"line": "exact (isPrimitiveRoot_exp k h).card_primitiveRoots", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Complex.norm_eq_one_of_mem_rootsOfUnity {\u03b6 : \u2102\u02e3} {n : \u2115} [NeZero n]\n    (h\u03b6 : \u03b6 \u2208 rootsOfUnity n \u2102) :\n    \u2016(\u03b6 : \u2102)\u2016 = 1 := by\n  refine norm_eq_one_of_pow_eq_one ?_ <| NeZero.ne n\n  norm_cast\n  rw [_root_.mem_rootsOfUnity] at h\u03b6\n  rw [h\u03b6]\n  rw [Units.val_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/RootsOfUnity/Complex.lean", "context": {"open": ["Polynomial Real", "scoped Nat Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b6 : \u2102\u02e3\nn : \u2115\ninst\u271d : NeZero n\nh\u03b6 : \u03b6 \u2208 rootsOfUnity n \u2102\n\u22a2 \u2016\u2191\u03b6\u2016 = 1"}, {"line": "refine norm_eq_one_of_pow_eq_one ?_ <| NeZero.ne n", "tactic_state": "\u03b6 : \u2102\u02e3\nn : \u2115\ninst\u271d : NeZero n\nh\u03b6 : \u03b6 \u2208 rootsOfUnity n \u2102\n\u22a2 \u2191\u03b6 ^ n = 1"}, {"line": "norm_cast", "tactic_state": "\u03b6 : \u2102\u02e3\nn : \u2115\ninst\u271d : NeZero n\nh\u03b6 : \u03b6 \u2208 rootsOfUnity n \u2102\n\u22a2 \u2191(\u03b6 ^ n) = 1"}, {"line": "rw [_root_.mem_rootsOfUnity] at h\u03b6", "tactic_state": "\u03b6 : \u2102\u02e3\nn : \u2115\ninst\u271d : NeZero n\nh\u03b6 : \u03b6 ^ n = 1\n\u22a2 \u2191(\u03b6 ^ n) = 1"}, {"line": "rw [h\u03b6]", "tactic_state": "\u03b6 : \u2102\u02e3\nn : \u2115\ninst\u271d : NeZero n\nh\u03b6 : \u03b6 ^ n = 1\n\u22a2 \u21911 = 1"}, {"line": "rw [Units.val_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rootsOfUnity_one (M : Type*) [CommMonoid M] : rootsOfUnity 1 M = \u22a5 := by\n  ext1\n  simp only [mem_rootsOfUnity]\n  simp only [pow_one]\n  simp only [Subgroup.mem_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/RootsOfUnity/Basic.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["{M N G R S F : Type*}", "[CommMonoid M] [CommMonoid N] [DivisionCommMonoid G]", "{k l : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_7\ninst\u271d : CommMonoid M\n\u22a2 rootsOfUnity 1 M = \u22a5"}, {"line": "ext1", "tactic_state": "case h\nM : Type u_7\ninst\u271d : CommMonoid M\nx\u271d : M\u02e3\n\u22a2 x\u271d \u2208 rootsOfUnity 1 M \u2194 x\u271d \u2208 \u22a5"}, {"line": "simp only [mem_rootsOfUnity]", "tactic_state": "case h\nM : Type u_7\ninst\u271d : CommMonoid M\nx\u271d : M\u02e3\n\u22a2 x\u271d ^ 1 = 1 \u2194 x\u271d \u2208 \u22a5"}, {"line": "simp only [pow_one]", "tactic_state": "case h\nM : Type u_7\ninst\u271d : CommMonoid M\nx\u271d : M\u02e3\n\u22a2 x\u271d = 1 \u2194 x\u271d \u2208 \u22a5"}, {"line": "simp only [Subgroup.mem_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rootsOfUnity_zero (M : Type*) [CommMonoid M] : rootsOfUnity 0 M = \u22a4 := by\n  ext1\n  simp only [mem_rootsOfUnity]\n  simp only [pow_zero]\n  simp only [Subgroup.mem_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/RootsOfUnity/Basic.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["{M N G R S F : Type*}", "[CommMonoid M] [CommMonoid N] [DivisionCommMonoid G]", "{k l : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_7\ninst\u271d : CommMonoid M\n\u22a2 rootsOfUnity 0 M = \u22a4"}, {"line": "ext1", "tactic_state": "case h\nM : Type u_7\ninst\u271d : CommMonoid M\nx\u271d : M\u02e3\n\u22a2 x\u271d \u2208 rootsOfUnity 0 M \u2194 x\u271d \u2208 \u22a4"}, {"line": "simp only [mem_rootsOfUnity]", "tactic_state": "case h\nM : Type u_7\ninst\u271d : CommMonoid M\nx\u271d : M\u02e3\n\u22a2 x\u271d ^ 0 = 1 \u2194 x\u271d \u2208 \u22a4"}, {"line": "simp only [pow_zero]", "tactic_state": "case h\nM : Type u_7\ninst\u271d : CommMonoid M\nx\u271d : M\u02e3\n\u22a2 True \u2194 x\u271d \u2208 \u22a4"}, {"line": "simp only [Subgroup.mem_top]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rootsOfUnity_le_of_dvd (h : k \u2223 l) : rootsOfUnity k M \u2264 rootsOfUnity l M := by\n  obtain \u27e8d, rfl\u27e9 := h\n  intro \u03b6 h\n  simp_all only [mem_rootsOfUnity, pow_mul, one_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/RootsOfUnity/Basic.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["{M N G R S F : Type*}", "[CommMonoid M] [CommMonoid N] [DivisionCommMonoid G]", "{k l : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d : CommMonoid M\nk l : \u2115\nh : k \u2223 l\n\u22a2 rootsOfUnity k M \u2264 rootsOfUnity l M"}, {"line": "obtain \u27e8d, rfl\u27e9 := h", "tactic_state": "case intro\nM : Type u_1\ninst\u271d : CommMonoid M\nk d : \u2115\n\u22a2 rootsOfUnity k M \u2264 rootsOfUnity (k * d) M"}, {"line": "intro \u03b6 h", "tactic_state": "case intro\nM : Type u_1\ninst\u271d : CommMonoid M\nk d : \u2115\n\u03b6 : M\u02e3\nh : \u03b6 \u2208 rootsOfUnity k M\n\u22a2 \u03b6 \u2208 rootsOfUnity (k * d) M"}, {"line": "simp_all only [mem_rootsOfUnity, pow_mul, one_pow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_rootsOfUnity (f : M\u02e3 \u2192* N\u02e3) (k : \u2115) : (rootsOfUnity k M).map f \u2264 rootsOfUnity k N := by\n  rintro _ \u27e8\u03b6, h, rfl\u27e9\n  simp_all only [\u2190 map_pow, mem_rootsOfUnity, SetLike.mem_coe, MonoidHom.map_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/RootsOfUnity/Basic.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["{M N G R S F : Type*}", "[CommMonoid M] [CommMonoid N] [DivisionCommMonoid G]", "{k l : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf : M\u02e3 \u2192* N\u02e3\nk : \u2115\n\u22a2 Subgroup.map f (rootsOfUnity k M) \u2264 rootsOfUnity k N"}, {"line": "rintro _ \u27e8\u03b6, h, rfl\u27e9", "tactic_state": "case intro.intro\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf : M\u02e3 \u2192* N\u02e3\nk : \u2115\n\u03b6 : M\u02e3\nh : \u03b6 \u2208 \u2191(rootsOfUnity k M)\n\u22a2 f \u03b6 \u2208 rootsOfUnity k N"}, {"line": "simp_all only [\u2190 map_pow, mem_rootsOfUnity, SetLike.mem_coe, MonoidHom.map_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rootsOfUnity.coe_pow [CommMonoid R] (\u03b6 : rootsOfUnity k R) (m : \u2115) :\n    (((\u03b6 ^ m :) : R\u02e3) : R) = ((\u03b6 : R\u02e3) : R) ^ m := by\n  rw [Subgroup.coe_pow]\n  rw [Units.val_pow_eq_pow_val]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/RootsOfUnity/Basic.lean", "context": {"open": ["Polynomial", "Finset"], "variables": ["{M N G R S F : Type*}", "[CommMonoid M] [CommMonoid N] [DivisionCommMonoid G]", "{k l : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\nk : \u2115\ninst\u271d : CommMonoid R\n\u03b6 : \u21a5(rootsOfUnity k R)\nm : \u2115\n\u22a2 \u2191\u2191(\u03b6 ^ m) = \u2191\u2191\u03b6 ^ m"}, {"line": "rw [Subgroup.coe_pow]", "tactic_state": "R : Type u_4\nk : \u2115\ninst\u271d : CommMonoid R\n\u03b6 : \u21a5(rootsOfUnity k R)\nm : \u2115\n\u22a2 \u2191(\u2191\u03b6 ^ m) = \u2191\u2191\u03b6 ^ m"}, {"line": "rw [Units.val_pow_eq_pow_val]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isIntegral (hpos : 0 < n) : IsIntegral \u2124 \u03bc := by\n  use X ^ n - 1\n  constructor\n  \u00b7 exact monic_X_pow_sub_C 1 (ne_of_lt hpos).symm\n  \u00b7 simp only [((IsPrimitiveRoot.iff_def \u03bc n).mp h).left, eval\u2082_one, eval\u2082_X_pow, eval\u2082_sub,\n      sub_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/RootsOfUnity/Minpoly.lean", "context": {"open": ["minpoly Polynomial", "scoped Polynomial"], "variables": ["{n : \u2115} {K : Type*} [CommRing K] {\u03bc : K} (h : IsPrimitiveRoot \u03bc n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nK : Type u_1\ninst\u271d : CommRing K\n\u03bc : K\nhpos : 0 < n\n\u22a2 IsIntegral \u2124 \u03bc"}, {"line": "use X ^ n - 1", "tactic_state": "case h\nn : \u2115\nK : Type u_1\ninst\u271d : CommRing K\n\u03bc : K\nhpos : 0 < n\n\u22a2 (X ^ n - 1).Monic \u2227 eval\u2082 (algebraMap \u2124 K) \u03bc (X ^ n - 1) = 0"}, {"line": "constructor", "tactic_state": "case h.left\nn : \u2115\nK : Type u_1\ninst\u271d : CommRing K\n\u03bc : K\nhpos : 0 < n\n\u22a2 (X ^ n - 1).Monic\n---\ncase h.right\nn : \u2115\nK : Type u_1\ninst\u271d : CommRing K\n\u03bc : K\nhpos : 0 < n\n\u22a2 eval\u2082 (algebraMap \u2124 K) \u03bc (X ^ n - 1) = 0"}, {"line": "\u00b7 exact monic_X_pow_sub_C 1 (ne_of_lt hpos).symm", "tactic_state": "case h.right\nn : \u2115\nK : Type u_1\ninst\u271d : CommRing K\n\u03bc : K\nhpos : 0 < n\n\u22a2 eval\u2082 (algebraMap \u2124 K) \u03bc (X ^ n - 1) = 0"}, {"line": "\u00b7 simp only [((IsPrimitiveRoot.iff_def \u03bc n).mp h).left, eval\u2082_one, eval\u2082_X_pow, eval\u2082_sub,\n      sub_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_submonoidClass_iff {M B : Type*} [CommMonoid M] [SetLike B M] [SubmonoidClass B M]\n    {N : B} {\u03b6 : N} : IsPrimitiveRoot (\u03b6 : M) k \u2194 IsPrimitiveRoot \u03b6 k := by\n  simp_rw [iff_def]\n  norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean", "context": {"open": ["Polynomial Finset", "scoped Classical in"], "variables": ["{M N G R S F : Type*} [CommMonoid M] [CommMonoid N] [DivisionCommMonoid G]", "{k : \u2115}", "[CommRing R] [IsDomain R]", "{k l : \u2115}", "{\u03b6 : M} {f : F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2115\nM : Type u_1\nB : Type u_2\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nN : B\n\u03b6 : \u21a5N\n\u22a2 IsPrimitiveRoot (\u2191\u03b6) k \u2194 IsPrimitiveRoot \u03b6 k"}, {"line": "simp_rw [iff_def]", "tactic_state": "k : \u2115\nM : Type u_1\nB : Type u_2\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nN : B\n\u03b6 : \u21a5N\n\u22a2 (IsPrimitiveRoot (\u2191\u03b6) k \u2192 IsPrimitiveRoot \u03b6 k) \u2227 (IsPrimitiveRoot \u03b6 k \u2192 IsPrimitiveRoot (\u2191\u03b6) k)"}, {"line": "norm_cast", "tactic_state": "k : \u2115\nM : Type u_1\nB : Type u_2\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nN : B\n\u03b6 : \u21a5N\n\u22a2 (IsPrimitiveRoot (\u2191\u03b6) k \u2192 IsPrimitiveRoot \u03b6 k) \u2227 (IsPrimitiveRoot \u03b6 k \u2192 IsPrimitiveRoot (\u2191\u03b6) k)"}]}
{"declaration": "theorem zpow_eq_one (h : IsPrimitiveRoot \u03b6 k) : \u03b6 ^ (k : \u2124) = 1 := by\n  exact_mod_cast h.pow_eq_one\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean", "context": {"open": ["Polynomial Finset", "scoped Classical in", "Function"], "variables": ["{M N G R S F : Type*} [CommMonoid M] [CommMonoid N] [DivisionCommMonoid G]", "{k : \u2115}", "[CommRing R] [IsDomain R]", "{k l : \u2115}", "{\u03b6 : M} {f : F}", "[FunLike F M N]", "{M\u2080 : Type*} [CommMonoidWithZero M\u2080]", "{M\u2080 : Type*} [CancelCommMonoidWithZero M\u2080]", "{\u03b6 : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d : DivisionCommMonoid G\nk : \u2115\n\u03b6 : G\nh : IsPrimitiveRoot \u03b6 k\n\u22a2 \u03b6 ^ \u2191k = 1"}, {"line": "exact_mod_cast h.pow_eq_one", "tactic_state": "No Goals!"}]}
{"declaration": "theorem primitiveRoots_one : primitiveRoots 1 R = {(1 : R)} := by\n  refine Finset.eq_singleton_iff_unique_mem.2 \u27e8?_, fun x hx \u21a6 ?_\u27e9\n  \u00b7 simp only [IsPrimitiveRoot.one_right_iff, mem_primitiveRoots zero_lt_one]\n  \u00b7 rwa [mem_primitiveRoots zero_lt_one, IsPrimitiveRoot.one_right_iff] at hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean", "context": {"open": ["Polynomial Finset", "scoped Classical in", "Function"], "variables": ["{M N G R S F : Type*} [CommMonoid M] [CommMonoid N] [DivisionCommMonoid G]", "{k : \u2115}", "[CommRing R] [IsDomain R]", "{k l : \u2115}", "{\u03b6 : M} {f : F}", "[FunLike F M N]", "{M\u2080 : Type*} [CommMonoidWithZero M\u2080]", "{M\u2080 : Type*} [CancelCommMonoidWithZero M\u2080]", "{\u03b6 : G}", "[CommRing R] {n : \u2115} {\u03b6 : R}", "{\u03b6 : R} [CommRing R] [IsDomain R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 inst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\n\u22a2 primitiveRoots 1 R = {1}"}, {"line": "refine Finset.eq_singleton_iff_unique_mem.2 \u27e8?_, fun x hx \u21a6 ?_\u27e9", "tactic_state": "case refine_1\nR : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 inst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\n\u22a2 1 \u2208 primitiveRoots 1 R\n---\ncase refine_2\nR : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 inst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nx : R\nhx : x \u2208 primitiveRoots 1 R\n\u22a2 x = 1"}, {"line": "\u00b7 simp only [IsPrimitiveRoot.one_right_iff, mem_primitiveRoots zero_lt_one]", "tactic_state": "case refine_2\nR : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 inst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nx : R\nhx : x \u2208 primitiveRoots 1 R\n\u22a2 x = 1"}, {"line": "\u00b7 rwa [mem_primitiveRoots zero_lt_one, IsPrimitiveRoot.one_right_iff] at hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nthRoots_one_eq_biUnion_primitiveRoots [DecidableEq R] {n : \u2115} :\n    nthRootsFinset n (1 : R) = (Nat.divisors n).biUnion fun i \u21a6 primitiveRoots i R := by\n  by_cases hn : n = 0\n  \u00b7 simp only [hn, nthRootsFinset_zero, Nat.divisors_zero, biUnion_empty]\n  have : NeZero n := \u27e8hn\u27e9\n  exact nthRoots_one_eq_biUnion_primitiveRoots'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean", "context": {"open": ["Polynomial Finset", "scoped Classical in", "Function", "scoped Classical in", "scoped Nat"], "variables": ["{M N G R S F : Type*} [CommMonoid M] [CommMonoid N] [DivisionCommMonoid G]", "{k : \u2115}", "[CommRing R] [IsDomain R]", "{k l : \u2115}", "{\u03b6 : M} {f : F}", "[FunLike F M N]", "{M\u2080 : Type*} [CommMonoidWithZero M\u2080]", "{M\u2080 : Type*} [CancelCommMonoidWithZero M\u2080]", "{\u03b6 : G}", "[CommRing R] {n : \u2115} {\u03b6 : R}", "{\u03b6 : R} [CommRing R] [IsDomain R]", "[CommRing R] {\u03b6 : R\u02e3} (h : IsPrimitiveRoot \u03b6 k)", "[IsDomain R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : IsDomain R\ninst\u271d\u2075 inst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : DecidableEq R\nn : \u2115\n\u22a2 nthRootsFinset n 1 = n.divisors.biUnion fun i => primitiveRoots i R"}, {"line": "by_cases hn : n = 0", "tactic_state": "case pos\nR : Type u_4\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : IsDomain R\ninst\u271d\u2075 inst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : DecidableEq R\nn : \u2115\nhn : n = 0\n\u22a2 nthRootsFinset n 1 = n.divisors.biUnion fun i => primitiveRoots i R\n---\ncase neg\nR : Type u_4\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : IsDomain R\ninst\u271d\u2075 inst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : DecidableEq R\nn : \u2115\nhn : \u00acn = 0\n\u22a2 nthRootsFinset n 1 = n.divisors.biUnion fun i => primitiveRoots i R"}, {"line": "\u00b7 simp only [hn, nthRootsFinset_zero, Nat.divisors_zero, biUnion_empty]", "tactic_state": "case neg\nR : Type u_4\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : IsDomain R\ninst\u271d\u2075 inst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : DecidableEq R\nn : \u2115\nhn : \u00acn = 0\n\u22a2 nthRootsFinset n 1 = n.divisors.biUnion fun i => primitiveRoots i R"}, {"line": "have : NeZero n := \u27e8hn\u27e9", "tactic_state": "case neg\nR : Type u_4\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : IsDomain R\ninst\u271d\u2075 inst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : DecidableEq R\nn : \u2115\nhn : \u00acn = 0\nthis : NeZero n\n\u22a2 nthRootsFinset n 1 = n.divisors.biUnion fun i => primitiveRoots i R"}, {"line": "exact nthRoots_one_eq_biUnion_primitiveRoots'", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ZMod.exists_monoidHom_apply_ne_one {M : Type*} [CommMonoid M] {n : \u2115} [NeZero n]\n    (hG : \u2203 \u03b6 : M, IsPrimitiveRoot \u03b6 n) {a : ZMod n} (ha : a \u2260 0) :\n    \u2203 \u03c6 : Multiplicative (ZMod n) \u2192* M\u02e3, \u03c6 (Multiplicative.ofAdd a) \u2260 1 := by\n  obtain \u27e8\u03b6, h\u03b6\u27e9 := hG\n  have hc : n = Nat.card (Multiplicative (ZMod n)) := by\n    simp only [Nat.card_eq_fintype_card]\n    simp only [Fintype.card_multiplicative]\n    simp only [card]\n  exact IsCyclic.exists_apply_ne_one\n    (hc \u25b8 \u27e8h\u03b6.toRootsOfUnity.val, IsPrimitiveRoot.coe_units_iff.mp h\u03b6\u27e9) <|\n    by simp only [ne_eq, ofAdd_eq_one, ha, not_false_eq_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean", "context": {"open": ["Polynomial Finset", "scoped Classical in", "Function", "scoped Classical in", "scoped Nat"], "variables": ["{M N G R S F : Type*} [CommMonoid M] [CommMonoid N] [DivisionCommMonoid G]", "{k : \u2115}", "[CommRing R] [IsDomain R]", "{k l : \u2115}", "{\u03b6 : M} {f : F}", "[FunLike F M N]", "{M\u2080 : Type*} [CommMonoidWithZero M\u2080]", "{M\u2080 : Type*} [CancelCommMonoidWithZero M\u2080]", "{\u03b6 : G}", "[CommRing R] {n : \u2115} {\u03b6 : R}", "{\u03b6 : R} [CommRing R] [IsDomain R]", "[CommRing R] {\u03b6 : R\u02e3} (h : IsPrimitiveRoot \u03b6 k)", "[IsDomain R]", "[CommRing S] [IsDomain S] {\u03bc : S} {n : \u2115} (h\u03bc : IsPrimitiveRoot \u03bc n) (R) [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_9\ninst\u271d\u00b9 : CommMonoid M\nn : \u2115\ninst\u271d : NeZero n\nhG : \u2203 \u03b6, IsPrimitiveRoot \u03b6 n\na : ZMod n\nha : a \u2260 0\n\u22a2 \u2203 \u03c6, \u03c6 (Multiplicative.ofAdd a) \u2260 1"}, {"line": "obtain \u27e8\u03b6, h\u03b6\u27e9 := hG", "tactic_state": "case intro\nM : Type u_9\ninst\u271d\u00b9 : CommMonoid M\nn : \u2115\ninst\u271d : NeZero n\na : ZMod n\nha : a \u2260 0\n\u03b6 : M\nh\u03b6 : IsPrimitiveRoot \u03b6 n\n\u22a2 \u2203 \u03c6, \u03c6 (Multiplicative.ofAdd a) \u2260 1"}, {"line": "have hc : n = Nat.card (Multiplicative (ZMod n)) := by\n    simp only [Nat.card_eq_fintype_card]\n    simp only [Fintype.card_multiplicative]\n    simp only [card]", "tactic_state": "case intro\nM : Type u_9\ninst\u271d\u00b9 : CommMonoid M\nn : \u2115\ninst\u271d : NeZero n\na : ZMod n\nha : a \u2260 0\n\u03b6 : M\nh\u03b6 : IsPrimitiveRoot \u03b6 n\nhc : n = Nat.card (Multiplicative (ZMod n))\n\u22a2 \u2203 \u03c6, \u03c6 (Multiplicative.ofAdd a) \u2260 1"}, {"line": "exact IsCyclic.exists_apply_ne_one\n    (hc \u25b8 \u27e8h\u03b6.toRootsOfUnity.val, IsPrimitiveRoot.coe_units_iff.mp h\u03b6\u27e9) <|\n    by simp only [ne_eq, ofAdd_eq_one, ha, not_false_eq_true]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isSimpleRing_iff_isTwoSided_imp {R : Type*} [Ring R] :\n    IsSimpleRing R \u2194 Nontrivial R \u2227 \u2200 I : Ideal R, I.IsTwoSided \u2192 I = \u22a5 \u2228 I = \u22a4 := by\n  let e := orderIsoIsTwoSided (R := R)\n  simp_rw [isSimpleRing_iff, isSimpleOrder_iff, orderIsoRingCon.toEquiv.nontrivial_congr,\n    RingCon.nontrivial_iff, e.forall_congr_left, Subtype.forall, \u2190 e.injective.eq_iff]\n  simp [e,Subtype.ext_iff]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/SimpleRing/Congr.lean", "context": {"open": ["TwoSidedIdeal in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Ring R\n\u22a2 IsSimpleRing R \u2194 Nontrivial R \u2227 \u2200 (I : Ideal R), I.IsTwoSided \u2192 I = \u22a5 \u2228 I = \u22a4"}, {"line": "let e := orderIsoIsTwoSided (R := R)", "tactic_state": "case refine_2\nR : Type u_1\ninst\u271d : Ring R\ne : TwoSidedIdeal R \u2243o { I // I.IsTwoSided } := sorry\n\u22a2 IsSimpleRing R \u2194 Nontrivial R \u2227 \u2200 (I : Ideal R), I.IsTwoSided \u2192 I = \u22a5 \u2228 I = \u22a4\n---\ncase refine_1\nR : Type u_1\ninst\u271d : Ring R\n\u22a2 Ring R"}, {"line": "simp_rw [isSimpleRing_iff, isSimpleOrder_iff, orderIsoRingCon.toEquiv.nontrivial_congr,\n    RingCon.nontrivial_iff, e.forall_congr_left, Subtype.forall, \u2190 e.injective.eq_iff]", "tactic_state": "case refine_2\nR : Type u_1\ninst\u271d : Ring R\ne : TwoSidedIdeal R \u2243o { I // I.IsTwoSided } := sorry\n\u22a2 (Nontrivial R \u2227 \u2200 (a : Ideal R) (b : a.IsTwoSided), e (e.symm \u27e8a, b\u27e9) = e \u22a5 \u2228 e (e.symm \u27e8a, b\u27e9) = e \u22a4) \u2194\n    Nontrivial R \u2227 \u2200 (I : Ideal R), I.IsTwoSided \u2192 I = \u22a5 \u2228 I = \u22a4\n---\ncase refine_1\nR : Type u_1\ninst\u271d : Ring R\n\u22a2 Ring R"}, {"line": "simp [e,Subtype.ext_iff]", "tactic_state": "case refine_2\nR : Type u_1\ninst\u271d : Ring R\ne : TwoSidedIdeal R \u2243o { I // I.IsTwoSided } := sorry\n\u22a2 Nontrivial R \u2192\n    ((\u2200 (a : Ideal R) (b : a.IsTwoSided),\n        \u2191((sorry ()) ((sorry ()).symm \u27e8a, b\u27e9)) = \u2191((sorry ()) \u22a5) \u2228\n          \u2191((sorry ()) ((sorry ()).symm \u27e8a, b\u27e9)) = \u2191((sorry ()) \u22a4)) \u2194\n      \u2200 (I : Ideal R), I.IsTwoSided \u2192 I = \u22a5 \u2228 I = \u22a4)\n---\ncase refine_1\nR : Type u_1\ninst\u271d : Ring R\n\u22a2 Ring R"}]}
{"declaration": "lemma jacobian_eq_jacobiMatrix_det : P.jacobian = algebraMap P.Ring S P.jacobiMatrix.det := by\n   simp [jacobiMatrix, jacobian]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Smooth/StandardSmooth.lean", "context": {"open": ["TensorProduct MvPolynomial"], "variables": ["(n m : \u2115)", "(R : Type u) (S : Type v) [CommRing R] [CommRing S] [Algebra R S]", "{R S}", "(P : PreSubmersivePresentation R S)", "[Fintype P.rels] [DecidableEq P.rels]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "PreSubmersivePresentation : ?m.2083\nn m : \u2115\nR : Type u\nS : Type v\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : Algebra R S\nP : sorry\ninst\u271d\u00b3 : Fintype sorry\ninst\u271d\u00b2 : DecidableEq sorry\ninst\u271d\u00b9 : Fintype sorry\ninst\u271d : DecidableEq sorry\n\u22a2 sorry = sorry"}, {"line": "simp [jacobiMatrix, jacobian]", "tactic_state": "PreSubmersivePresentation : ?m.2083\nn m : \u2115\nR : Type u\nS : Type v\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : Algebra R S\nP : sorry\ninst\u271d\u00b3 : Fintype sorry\ninst\u271d\u00b2 : DecidableEq sorry\ninst\u271d\u00b9 : Fintype sorry\ninst\u271d : DecidableEq sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma isOpenMap_comap_of_hasGoingDown_of_finitePresentation\n    [Algebra R S] [Algebra.HasGoingDown R S] [Algebra.FinitePresentation R S] :\n    IsOpenMap (comap (algebraMap R S)) := by\n  rw [isBasis_basic_opens.isOpenMap_iff]\n  rintro _ \u27e8_, \u27e8f, rfl\u27e9, rfl\u27e9\n  exact isOpen_of_stableUnderGeneralization_of_isConstructible\n    ((basicOpen f).2.stableUnderGeneralization.image\n      (Algebra.HasGoingDown.iff_generalizingMap_primeSpectrumComap.mp \u2039_\u203a))\n    (isConstructible_comap_image (RingHom.finitePresentation_algebraMap.mpr \u2039_\u203a)\n      isConstructible_basicOpen)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/Chevalley.lean", "context": {"open": ["Function Localization MvPolynomial Polynomial TensorProduct PrimeSpectrum Topology", "scoped Pointwise"], "variables": ["{R S : Type*} [CommRing R] [CommRing S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\ninst\u271d\u00b9 : Algebra.HasGoingDown R S\ninst\u271d : Algebra.FinitePresentation R S\n\u22a2 IsOpenMap \u21d1(PrimeSpectrum.comap (algebraMap R S))"}, {"line": "rw [isBasis_basic_opens.isOpenMap_iff]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\ninst\u271d\u00b9 : Algebra.HasGoingDown R S\ninst\u271d : Algebra.FinitePresentation R S\n\u22a2 \u2200 s \u2208 SetLike.coe '' Set.range basicOpen, IsOpen (\u21d1(PrimeSpectrum.comap (algebraMap R S)) '' s)"}, {"line": "rintro _ \u27e8_, \u27e8f, rfl\u27e9, rfl\u27e9", "tactic_state": "case intro.intro.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\ninst\u271d\u00b9 : Algebra.HasGoingDown R S\ninst\u271d : Algebra.FinitePresentation R S\nf : S\n\u22a2 IsOpen (\u21d1(PrimeSpectrum.comap (algebraMap R S)) '' \u2191(basicOpen f))"}, {"line": "exact isOpen_of_stableUnderGeneralization_of_isConstructible\n    ((basicOpen f).2.stableUnderGeneralization.image\n      (Algebra.HasGoingDown.iff_generalizingMap_primeSpectrumComap.mp \u2039_\u203a))\n    (isConstructible_comap_image (RingHom.finitePresentation_algebraMap.mpr \u2039_\u203a)\n      isConstructible_basicOpen)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_comp (\u03c6 : S \u2192+* T) (\u03c8 : R \u2192+* S) (C : BasicConstructibleSetData R) :\n    C.map (\u03c6.comp \u03c8) = (C.map \u03c8).map \u03c6 := by simp [map, image_image, Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/ConstructibleSet.lean", "context": {"open": ["Finset Topology", "scoped Polynomial"], "variables": ["{R S T : Type*} [CommSemiring R] [CommSemiring S] [CommSemiring T]", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring S\ninst\u271d : CommSemiring T\nx\u271d : Sort u_4\nBasicConstructibleSetData : x\u271d\n\u03c6 : S \u2192+* T\n\u03c8 : R \u2192+* S\nC : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [map, image_image, Function.comp_def]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toSet_map (\u03c6 : R \u2192+* S) (C : BasicConstructibleSetData R) :\n    (C.map \u03c6).toSet = comap \u03c6 \u207b\u00b9' C.toSet := by simp [toSet, map, \u2190 Set.range_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/ConstructibleSet.lean", "context": {"open": ["Finset Topology", "scoped Polynomial"], "variables": ["{R S T : Type*} [CommSemiring R] [CommSemiring S] [CommSemiring T]", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nx\u271d\u00b9 : Sort u_4\nBasicConstructibleSetData : x\u271d\u00b9\nx\u271d : Sort u_5\ncomap : x\u271d\n\u03c6 : R \u2192+* S\nC : sorry\n\u22a2 sorry = sorry \u207b\u00b9' sorry"}, {"line": "simp [toSet, map, \u2190 Set.range_comp]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nx\u271d\u00b9 : Sort u_4\nBasicConstructibleSetData : x\u271d\u00b9\nx\u271d : Sort u_5\ncomap : x\u271d\n\u03c6 : R \u2192+* S\nC : sorry\n\u22a2 sorry () = sorry () \u207b\u00b9' sorry ()"}]}
{"declaration": "lemma map_id (s : ConstructibleSetData R) : s.map (.id _) = s := by simp [map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/ConstructibleSet.lean", "context": {"open": ["Finset Topology", "scoped Polynomial"], "variables": ["{R S T : Type*} [CommSemiring R] [CommSemiring S] [CommSemiring T]", "(R) in", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nConstructibleSetData : x\u271d\ns : sorry\n\u22a2 sorry = s"}, {"line": "simp [map]", "tactic_state": "x\u271d : Sort u_4\nConstructibleSetData : x\u271d\ns : sorry\n\u22a2 sorry () = s"}]}
{"declaration": "lemma map_comp (f : S \u2192+* T) (g : R \u2192+* S) (s : ConstructibleSetData R) :\n    s.map (f.comp g) = (s.map g).map f := by\n  simp [map, image_image, Function.comp_def, BasicConstructibleSetData.map_comp']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/ConstructibleSet.lean", "context": {"open": ["Finset Topology", "scoped Polynomial"], "variables": ["{R S T : Type*} [CommSemiring R] [CommSemiring S] [CommSemiring T]", "(R) in", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring S\ninst\u271d : CommSemiring T\nx\u271d : Sort u_4\nConstructibleSetData : x\u271d\nf : S \u2192+* T\ng : R \u2192+* S\ns : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [map, image_image, Function.comp_def, BasicConstructibleSetData.map_comp']", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isOpen_of_stableUnderGeneralization_of_isConstructible {R : Type*} [CommRing R]\n    {s : Set (PrimeSpectrum R)} (hs : StableUnderGeneralization s) (hs' : IsConstructible s) :\n    IsOpen s := by\n  rw [\u2190 isClosed_compl_iff]\n  exact isClosed_of_stableUnderSpecialization_of_isConstructible hs.compl hs'.compl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/ConstructibleSet.lean", "context": {"open": ["Finset Topology", "scoped Polynomial"], "variables": ["{R S T : Type*} [CommSemiring R] [CommSemiring S] [CommSemiring T]", "(R) in", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d : CommRing R\ns : Set (PrimeSpectrum R)\nhs : StableUnderGeneralization s\nhs' : IsConstructible s\n\u22a2 IsOpen s"}, {"line": "rw [\u2190 isClosed_compl_iff]", "tactic_state": "R : Type u_4\ninst\u271d : CommRing R\ns : Set (PrimeSpectrum R)\nhs : StableUnderGeneralization s\nhs' : IsConstructible s\n\u22a2 IsClosed s\u1d9c"}, {"line": "exact isClosed_of_stableUnderSpecialization_of_isConstructible hs.compl hs'.compl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma image_comap_C_basicOpen (f : R[X]) :\n    comap C '' basicOpen f = (zeroLocus (Set.range f.coeff))\u1d9c := by\n  ext p\n  rw [mem_image_comap_C_basicOpen]\n  simp [Set.range_subset_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/Polynomial.lean", "context": {"open": ["Polynomial TensorProduct PrimeSpectrum"], "variables": ["{R M A} [CommRing R] [AddCommGroup M] [Module R M] [CommRing A] [Algebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nf : Polynomial R\n\u22a2 \u21d1(comap C) '' \u2191(basicOpen f) = (zeroLocus (Set.range f.coeff))\u1d9c"}, {"line": "ext p", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\nf : Polynomial R\np : PrimeSpectrum R\n\u22a2 p \u2208 \u21d1(comap C) '' \u2191(basicOpen f) \u2194 p \u2208 (zeroLocus (Set.range f.coeff))\u1d9c"}, {"line": "rw [mem_image_comap_C_basicOpen]", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\nf : Polynomial R\np : PrimeSpectrum R\n\u22a2 (\u2203 i, f.coeff i \u2209 p.asIdeal) \u2194 p \u2208 (zeroLocus (Set.range f.coeff))\u1d9c"}, {"line": "simp [Set.range_subset_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isOpenMap_comap_C : IsOpenMap (comap (R := R) C) := by\n  intro U hU\n  obtain \u27e8S, hS, rfl\u27e9 := isTopologicalBasis_basic_opens.open_eq_sUnion hU\n  rw [Set.image_sUnion]\n  apply isOpen_sUnion\n  rintro _ \u27e8t, ht, rfl\u27e9\n  obtain \u27e8r, rfl\u27e9 := hS ht\n  simp only [image_comap_C_basicOpen]\n  exact (isClosed_zeroLocus _).isOpen_compl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/Polynomial.lean", "context": {"open": ["Polynomial TensorProduct PrimeSpectrum"], "variables": ["{R M A} [CommRing R] [AddCommGroup M] [Module R M] [CommRing A] [Algebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\n\u22a2 IsOpenMap \u21d1(comap C)"}, {"line": "intro U hU", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nU : Set (PrimeSpectrum (Polynomial R))\nhU : IsOpen U\n\u22a2 IsOpen (\u21d1(comap C) '' U)"}, {"line": "obtain \u27e8S, hS, rfl\u27e9 := isTopologicalBasis_basic_opens.open_eq_sUnion hU", "tactic_state": "case intro.intro\nR : Type u_1\ninst\u271d : CommRing R\nS : Set (Set (PrimeSpectrum (Polynomial R)))\nhS : S \u2286 Set.range fun r => \u2191(basicOpen r)\nhU : IsOpen (\u22c3\u2080 S)\n\u22a2 IsOpen (\u21d1(comap C) '' \u22c3\u2080 S)"}, {"line": "rw [Set.image_sUnion]", "tactic_state": "case intro.intro\nR : Type u_1\ninst\u271d : CommRing R\nS : Set (Set (PrimeSpectrum (Polynomial R)))\nhS : S \u2286 Set.range fun r => \u2191(basicOpen r)\nhU : IsOpen (\u22c3\u2080 S)\n\u22a2 IsOpen (\u22c3\u2080 (Set.image \u21d1(comap C) '' S))"}, {"line": "apply isOpen_sUnion", "tactic_state": "case intro.intro.h\nR : Type u_1\ninst\u271d : CommRing R\nS : Set (Set (PrimeSpectrum (Polynomial R)))\nhS : S \u2286 Set.range fun r => \u2191(basicOpen r)\nhU : IsOpen (\u22c3\u2080 S)\n\u22a2 \u2200 t \u2208 Set.image \u21d1(comap C) '' S, IsOpen t"}, {"line": "rintro _ \u27e8t, ht, rfl\u27e9", "tactic_state": "case intro.intro.h.intro.intro\nR : Type u_1\ninst\u271d : CommRing R\nS : Set (Set (PrimeSpectrum (Polynomial R)))\nhS : S \u2286 Set.range fun r => \u2191(basicOpen r)\nhU : IsOpen (\u22c3\u2080 S)\nt : Set (PrimeSpectrum (Polynomial R))\nht : t \u2208 S\n\u22a2 IsOpen (\u21d1(comap C) '' t)"}, {"line": "obtain \u27e8r, rfl\u27e9 := hS ht", "tactic_state": "case intro.intro.h.intro.intro.intro\nR : Type u_1\ninst\u271d : CommRing R\nS : Set (Set (PrimeSpectrum (Polynomial R)))\nhS : S \u2286 Set.range fun r => \u2191(basicOpen r)\nhU : IsOpen (\u22c3\u2080 S)\nr : Polynomial R\nht : (fun r => \u2191(basicOpen r)) r \u2208 S\n\u22a2 IsOpen (\u21d1(comap C) '' (fun r => \u2191(basicOpen r)) r)"}, {"line": "simp only [image_comap_C_basicOpen]", "tactic_state": "case intro.intro.h.intro.intro.intro\nR : Type u_1\ninst\u271d : CommRing R\nS : Set (Set (PrimeSpectrum (Polynomial R)))\nhS : S \u2286 Set.range fun r => \u2191(basicOpen r)\nhU : IsOpen (\u22c3\u2080 S)\nr : Polynomial R\nht : (fun r => \u2191(basicOpen r)) r \u2208 S\n\u22a2 IsOpen (zeroLocus (Set.range r.coeff))\u1d9c"}, {"line": "exact (isClosed_zeroLocus _).isOpen_compl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_image_comap_of_monic (f g : R[X]) (hg : g.Monic) :\n    \u2203 t : Finset R, comap C '' (zeroLocus {g} \\ zeroLocus {f}) = (zeroLocus t)\u1d9c := by\n  apply (config := { allowSynthFailures := true }) exists_image_comap_of_finite_of_free\n  \u00b7 exact .of_basis (AdjoinRoot.powerBasis' hg).basis\n  \u00b7 exact .of_basis (AdjoinRoot.powerBasis' hg).basis\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/Polynomial.lean", "context": {"open": ["Polynomial TensorProduct PrimeSpectrum"], "variables": ["{R M A} [CommRing R] [AddCommGroup M] [Module R M] [CommRing A] [Algebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nf g : Polynomial R\nhg : g.Monic\n\u22a2 \u2203 t, \u21d1(comap C) '' (zeroLocus {g} \\ zeroLocus {f}) = (zeroLocus \u2191t)\u1d9c"}, {"line": "apply (config := { allowSynthFailures := true }) exists_image_comap_of_finite_of_free", "tactic_state": "case inst\nR : Type u_1\ninst\u271d : CommRing R\nf g : Polynomial R\nhg : g.Monic\n\u22a2 Module.Finite R (Polynomial R \u29f8 Ideal.span {g})\n---\ncase inst\nR : Type u_1\ninst\u271d : CommRing R\nf g : Polynomial R\nhg : g.Monic\n\u22a2 Module.Free R (Polynomial R \u29f8 Ideal.span {g})"}, {"line": "\u00b7 exact .of_basis (AdjoinRoot.powerBasis' hg).basis", "tactic_state": "case inst\nR : Type u_1\ninst\u271d : CommRing R\nf g : Polynomial R\nhg : g.Monic\n\u22a2 Module.Free R (Polynomial R \u29f8 Ideal.span {g})"}, {"line": "\u00b7 exact .of_basis (AdjoinRoot.powerBasis' hg).basis", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vanishingIdeal_singleton (x : PrimeSpectrum R) :\n    vanishingIdeal ({x} : Set (PrimeSpectrum R)) = x.asIdeal := by simp [vanishingIdeal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/Basic.lean", "context": {"open": ["scoped Pointwise"], "variables": ["(R : Type u) (S : Type v)", "[CommSemiring R] [CommSemiring S]", "{R S}", "(R S)", "{R S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nx\u271d : Sort u_1\nvanishingIdeal : x\u271d\nx : PrimeSpectrum R\n\u22a2 sorry = x.asIdeal"}, {"line": "simp [vanishingIdeal]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nx\u271d : Sort u_1\nvanishingIdeal : x\u271d\nx : PrimeSpectrum R\n\u22a2 sorry () = x.asIdeal"}]}
{"declaration": "theorem nilradical_eq_iInf : nilradical R = iInf asIdeal := by\n  apply range_asIdeal R \u25b8 nilradical_eq_sInf R\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/Basic.lean", "context": {"open": ["scoped Pointwise"], "variables": ["(R : Type u) (S : Type v)", "[CommSemiring R] [CommSemiring S]", "{R S}", "(R S)", "{R S}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\n\u03b9\u271d : Sort u_1\nasIdeal : \u03b9\u271d \u2192 Ideal R\n\u22a2 nilradical R = iInf asIdeal"}, {"line": "apply range_asIdeal R \u25b8 nilradical_eq_sInf R", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_freeLocus_iff_tensor (p : PrimeSpectrum R)\n    (R\u209a) [CommRing R\u209a] [Algebra R R\u209a] [IsLocalization.AtPrime R\u209a p.asIdeal] :\n    p \u2208 freeLocus R M \u2194 Module.Free R\u209a (R\u209a \u2297[R] M) := by\n  have := (isLocalizedModule_iff_isBaseChange p.asIdeal.primeCompl _ _).mpr\n    (TensorProduct.isBaseChange R M R\u209a)\n  exact mem_freeLocus_of_isLocalization p R\u209a (f := TensorProduct.mk R R\u209a M 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/FreeLocus.lean", "context": {"open": ["PrimeSpectrum TensorProduct"], "variables": ["(R : Type uR) (M : Type uM) [CommRing R] [AddCommGroup M] [Module R M]", "{R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type uR\nM : Type uM\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nx\u271d : Sort u_1\nfreeLocus : x\u271d\np : PrimeSpectrum R\nR\u209a : Type u_2\ninst\u271d\u00b2 : CommRing R\u209a\ninst\u271d\u00b9 : Algebra R R\u209a\ninst\u271d : IsLocalization.AtPrime R\u209a p.asIdeal\n\u22a2 p \u2208 sorry \u2194 Module.Free R\u209a (TensorProduct R R\u209a M)"}, {"line": "have := (isLocalizedModule_iff_isBaseChange p.asIdeal.primeCompl _ _).mpr\n    (TensorProduct.isBaseChange R M R\u209a)", "tactic_state": "case refine_7\nR : Type uR\nM : Type uM\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nx\u271d : Sort u_1\nfreeLocus : x\u271d\np : PrimeSpectrum R\nR\u209a : Type u_2\ninst\u271d\u00b2 : CommRing R\u209a\ninst\u271d\u00b9 : Algebra R R\u209a\ninst\u271d : IsLocalization.AtPrime R\u209a p.asIdeal\nthis : IsLocalizedModule sorry ((TensorProduct.mk R R\u209a M) 1)\n\u22a2 p \u2208 sorry \u2194 Module.Free R\u209a (TensorProduct R R\u209a M)\n---\ncase refine_1\nR : Type uR\nM : Type uM\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nx\u271d : Sort u_1\nfreeLocus : x\u271d\np : PrimeSpectrum R\nR\u209a : Type u_2\ninst\u271d\u00b2 : CommRing R\u209a\ninst\u271d\u00b9 : Algebra R R\u209a\ninst\u271d : IsLocalization.AtPrime R\u209a p.asIdeal\n\u22a2 IsLocalization sorry R\u209a\n---\ncase refine_2\nR : Type uR\nM : Type uM\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nx\u271d : Sort u_1\nfreeLocus : x\u271d\np : PrimeSpectrum R\nR\u209a : Type u_2\ninst\u271d\u00b2 : CommRing R\u209a\ninst\u271d\u00b9 : Algebra R R\u209a\ninst\u271d : IsLocalization.AtPrime R\u209a p.asIdeal\n\u22a2 AddCommMonoid M\n---\ncase refine_3\nR : Type uR\nM : Type uM\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nx\u271d : Sort u_1\nfreeLocus : x\u271d\np : PrimeSpectrum R\nR\u209a : Type u_2\ninst\u271d\u00b2 : CommRing R\u209a\ninst\u271d\u00b9 : Algebra R R\u209a\ninst\u271d : IsLocalization.AtPrime R\u209a p.asIdeal\n\u22a2 CommSemiring R\n---\ncase refine_4\nR : Type uR\nM : Type uM\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nx\u271d : Sort u_1\nfreeLocus : x\u271d\np : PrimeSpectrum R\nR\u209a : Type u_2\ninst\u271d\u00b2 : CommRing R\u209a\ninst\u271d\u00b9 : Algebra R R\u209a\ninst\u271d : IsLocalization.AtPrime R\u209a p.asIdeal\n\u22a2 CommSemiring R\u209a\n---\ncase refine_5\nR : Type uR\nM : Type uM\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nx\u271d : Sort u_1\nfreeLocus : x\u271d\np : PrimeSpectrum R\nR\u209a : Type u_2\ninst\u271d\u00b2 : CommRing R\u209a\ninst\u271d\u00b9 : Algebra R R\u209a\ninst\u271d : IsLocalization.AtPrime R\u209a p.asIdeal\n\u22a2 Algebra R R\u209a\n---\ncase refine_6\nR : Type uR\nM : Type uM\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nx\u271d : Sort u_1\nfreeLocus : x\u271d\np : PrimeSpectrum R\nR\u209a : Type u_2\ninst\u271d\u00b2 : CommRing R\u209a\ninst\u271d\u00b9 : Algebra R R\u209a\ninst\u271d : IsLocalization.AtPrime R\u209a p.asIdeal\n\u22a2 Module R M"}, {"line": "exact mem_freeLocus_of_isLocalization p R\u209a (f := TensorProduct.mk R R\u209a M 1)", "tactic_state": "case refine_1\nR : Type uR\nM : Type uM\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nx\u271d : Sort u_1\nfreeLocus : x\u271d\np : PrimeSpectrum R\nR\u209a : Type u_2\ninst\u271d\u00b2 : CommRing R\u209a\ninst\u271d\u00b9 : Algebra R R\u209a\ninst\u271d : IsLocalization.AtPrime R\u209a p.asIdeal\n\u22a2 IsLocalization sorry R\u209a\n---\ncase refine_2\nR : Type uR\nM : Type uM\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nx\u271d : Sort u_1\nfreeLocus : x\u271d\np : PrimeSpectrum R\nR\u209a : Type u_2\ninst\u271d\u00b2 : CommRing R\u209a\ninst\u271d\u00b9 : Algebra R R\u209a\ninst\u271d : IsLocalization.AtPrime R\u209a p.asIdeal\n\u22a2 AddCommMonoid M\n---\ncase refine_3\nR : Type uR\nM : Type uM\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nx\u271d : Sort u_1\nfreeLocus : x\u271d\np : PrimeSpectrum R\nR\u209a : Type u_2\ninst\u271d\u00b2 : CommRing R\u209a\ninst\u271d\u00b9 : Algebra R R\u209a\ninst\u271d : IsLocalization.AtPrime R\u209a p.asIdeal\n\u22a2 CommSemiring R\n---\ncase refine_4\nR : Type uR\nM : Type uM\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nx\u271d : Sort u_1\nfreeLocus : x\u271d\np : PrimeSpectrum R\nR\u209a : Type u_2\ninst\u271d\u00b2 : CommRing R\u209a\ninst\u271d\u00b9 : Algebra R R\u209a\ninst\u271d : IsLocalization.AtPrime R\u209a p.asIdeal\n\u22a2 CommSemiring R\u209a\n---\ncase refine_5\nR : Type uR\nM : Type uM\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nx\u271d : Sort u_1\nfreeLocus : x\u271d\np : PrimeSpectrum R\nR\u209a : Type u_2\ninst\u271d\u00b2 : CommRing R\u209a\ninst\u271d\u00b9 : Algebra R R\u209a\ninst\u271d : IsLocalization.AtPrime R\u209a p.asIdeal\n\u22a2 Algebra R R\u209a\n---\ncase refine_6\nR : Type uR\nM : Type uM\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nx\u271d : Sort u_1\nfreeLocus : x\u271d\np : PrimeSpectrum R\nR\u209a : Type u_2\ninst\u271d\u00b2 : CommRing R\u209a\ninst\u271d\u00b9 : Algebra R R\u209a\ninst\u271d : IsLocalization.AtPrime R\u209a p.asIdeal\n\u22a2 Module R M"}]}
{"declaration": "lemma LocalizedModule.subsingleton_iff_disjoint {f : R} :\n    Subsingleton (LocalizedModule (.powers f) M) \u2194\n      Disjoint \u2191(PrimeSpectrum.basicOpen f) (Module.support R M) := by\n  rw [subsingleton_iff_support_subset]\n  rw [PrimeSpectrum.basicOpen_eq_zeroLocus_compl]\n  rw [disjoint_compl_left_iff]\n  rw [Set.le_iff_subset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/Module.lean", "context": {"open": [], "variables": ["{R A M : Type*} [CommRing R] [AddCommGroup M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : R\n\u22a2 Subsingleton (LocalizedModule (Submonoid.powers f) M) \u2194 Disjoint (\u2191(PrimeSpectrum.basicOpen f)) (Module.support R M)"}, {"line": "rw [subsingleton_iff_support_subset]", "tactic_state": "R : Type u_1\nM : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : R\n\u22a2 Module.support R M \u2286 PrimeSpectrum.zeroLocus {f} \u2194 Disjoint (\u2191(PrimeSpectrum.basicOpen f)) (Module.support R M)"}, {"line": "rw [PrimeSpectrum.basicOpen_eq_zeroLocus_compl]", "tactic_state": "R : Type u_1\nM : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : R\n\u22a2 Module.support R M \u2286 PrimeSpectrum.zeroLocus {f} \u2194 Disjoint (PrimeSpectrum.zeroLocus {f})\u1d9c (Module.support R M)"}, {"line": "rw [disjoint_compl_left_iff]", "tactic_state": "R : Type u_1\nM : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : R\n\u22a2 Module.support R M \u2286 PrimeSpectrum.zeroLocus {f} \u2194 Module.support R M \u2264 PrimeSpectrum.zeroLocus {f}"}, {"line": "rw [Set.le_iff_subset]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Module.stableUnderSpecialization_support :\n    StableUnderSpecialization (Module.support R M) := by\n  intros x y e H\n  rw [mem_support_iff_exists_annihilator] at H \u22a2\n  obtain \u27e8m, hm\u27e9 := H\n  exact \u27e8m, hm.trans ((PrimeSpectrum.le_iff_specializes _ _).mpr e)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/Module.lean", "context": {"open": [], "variables": ["{R A M : Type*} [CommRing R] [AddCommGroup M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 StableUnderSpecialization (support R M)"}, {"line": "intros x y e H", "tactic_state": "R : Type u_1\nM : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : PrimeSpectrum R\ne : x \u2933 y\nH : x \u2208 support R M\n\u22a2 y \u2208 support R M"}, {"line": "rw [mem_support_iff_exists_annihilator] at H \u22a2", "tactic_state": "R : Type u_1\nM : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : PrimeSpectrum R\ne : x \u2933 y\nH : \u2203 m, (Submodule.span R {m}).annihilator \u2264 x.asIdeal\n\u22a2 \u2203 m, (Submodule.span R {m}).annihilator \u2264 y.asIdeal"}, {"line": "obtain \u27e8m, hm\u27e9 := H", "tactic_state": "case intro\nR : Type u_1\nM : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : PrimeSpectrum R\ne : x \u2933 y\nm : M\nhm : (Submodule.span R {m}).annihilator \u2264 x.asIdeal\n\u22a2 \u2203 m, (Submodule.span R {m}).annihilator \u2264 y.asIdeal"}, {"line": "exact \u27e8m, hm.trans ((PrimeSpectrum.le_iff_specializes _ _).mpr e)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_specComap_zeroLocus_aux (f : R \u2192+* S) (s : Set R) :\n    f.specComap \u207b\u00b9' zeroLocus s = zeroLocus (f '' s) := by\n  ext x\n  simp only [mem_zeroLocus]\n  simp only [Set.image_subset_iff]\n  simp only [Set.mem_preimage]\n  simp only [mem_zeroLocus]\n  simp only [Ideal.coe_comap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/RingHom.lean", "context": {"open": ["PrimeSpectrum", "RingHom"], "variables": ["(R : Type u) (S : Type v)", "{R S} {S' : Type*} [CommSemiring R] [CommSemiring S] [CommSemiring S']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nf : R \u2192+* S\ns : Set R\n\u22a2 f.specComap \u207b\u00b9' zeroLocus s = zeroLocus (\u21d1f '' s)"}, {"line": "ext x", "tactic_state": "case h\nR : Type u\nS : Type v\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nf : R \u2192+* S\ns : Set R\nx : PrimeSpectrum S\n\u22a2 x \u2208 f.specComap \u207b\u00b9' zeroLocus s \u2194 x \u2208 zeroLocus (\u21d1f '' s)"}, {"line": "simp only [mem_zeroLocus]", "tactic_state": "case h\nR : Type u\nS : Type v\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nf : R \u2192+* S\ns : Set R\nx : PrimeSpectrum S\n\u22a2 x \u2208 f.specComap \u207b\u00b9' zeroLocus s \u2194 \u21d1f '' s \u2286 \u2191x.asIdeal"}, {"line": "simp only [Set.image_subset_iff]", "tactic_state": "case h\nR : Type u\nS : Type v\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nf : R \u2192+* S\ns : Set R\nx : PrimeSpectrum S\n\u22a2 x \u2208 f.specComap \u207b\u00b9' zeroLocus s \u2194 s \u2286 \u21d1f \u207b\u00b9' \u2191x.asIdeal"}, {"line": "simp only [Set.mem_preimage]", "tactic_state": "case h\nR : Type u\nS : Type v\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nf : R \u2192+* S\ns : Set R\nx : PrimeSpectrum S\n\u22a2 f.specComap x \u2208 zeroLocus s \u2194 s \u2286 \u21d1f \u207b\u00b9' \u2191x.asIdeal"}, {"line": "simp only [mem_zeroLocus]", "tactic_state": "case h\nR : Type u\nS : Type v\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nf : R \u2192+* S\ns : Set R\nx : PrimeSpectrum S\n\u22a2 s \u2286 \u2191(Ideal.comap f x.asIdeal) \u2194 s \u2286 \u21d1f \u207b\u00b9' \u2191x.asIdeal"}, {"line": "simp only [Ideal.coe_comap]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma PrimeSpectrum.mem_range_comap_iff {p : PrimeSpectrum R} :\n    p \u2208 Set.range f.specComap \u2194 (p.asIdeal.map f).comap f = p.asIdeal := by\n  refine \u27e8fun \u27e8q, hq\u27e9 \u21a6 by simp [\u2190 hq], ?_\u27e9\n  rw [Ideal.comap_map_eq_self_iff_of_isPrime]\n  rintro \u27e8q, _, hq\u27e9\n  exact \u27e8\u27e8q, inferInstance\u27e9, PrimeSpectrum.ext hq\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/RingHom.lean", "context": {"open": ["PrimeSpectrum", "RingHom", "Function RingHom"], "variables": ["(R : Type u) (S : Type v)", "{R S} {S' : Type*} [CommSemiring R] [CommSemiring S] [CommSemiring S']", "(f : R \u2192+* S)", "{\u03b9} (R : \u03b9 \u2192 Type*) [\u2200 i, CommSemiring (R i)]", "[Infinite \u03b9] [\u2200 i, Nontrivial (R i)]", "[CommRing R] [CommRing S]", "(f : R \u2192+* S)", "{R}", "{S} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type v\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : CommRing sorry\ninst\u271d : CommRing S\nf : sorry \u2192+* S\np : PrimeSpectrum sorry\n\u22a2 p \u2208 Set.range f.specComap \u2194 Ideal.comap f (Ideal.map f p.asIdeal) = p.asIdeal"}, {"line": "refine \u27e8fun \u27e8q, hq\u27e9 \u21a6 by simp [\u2190 hq], ?_\u27e9", "tactic_state": "S : Type v\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : CommRing sorry\ninst\u271d : CommRing S\nf : sorry \u2192+* S\np : PrimeSpectrum sorry\n\u22a2 Ideal.comap f (Ideal.map f p.asIdeal) = p.asIdeal \u2192 p \u2208 Set.range f.specComap"}, {"line": "rw [Ideal.comap_map_eq_self_iff_of_isPrime]", "tactic_state": "S : Type v\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : CommRing sorry\ninst\u271d : CommRing S\nf : sorry \u2192+* S\np : PrimeSpectrum sorry\n\u22a2 (\u2203 q, q.IsPrime \u2227 Ideal.comap f q = p.asIdeal) \u2192 p \u2208 Set.range f.specComap"}, {"line": "rintro \u27e8q, _, hq\u27e9", "tactic_state": "case intro.intro\nS : Type v\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : CommRing sorry\ninst\u271d : CommRing S\nf : sorry \u2192+* S\np : PrimeSpectrum sorry\nq : Ideal S\nleft\u271d : q.IsPrime\nhq : Ideal.comap f q = p.asIdeal\n\u22a2 p \u2208 Set.range f.specComap"}, {"line": "exact \u27e8\u27e8q, inferInstance\u27e9, PrimeSpectrum.ext hq\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma existsUnique_idempotent_basicOpen_eq_of_isClopen {s : Set (PrimeSpectrum R)}\n    (hs : IsClopen s) : \u2203! e : R, IsIdempotentElem e \u2227 s = basicOpen e := by\n  refine existsUnique_of_exists_of_unique (exists_idempotent_basicOpen_eq_of_isClopen hs) ?_\n  rintro x y \u27e8hx, rfl\u27e9 \u27e8hy, eq\u27e9\n  exact basicOpen_injOn_isIdempotentElem hx hy (SetLike.ext' eq)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/Topology.lean", "context": {"open": ["Topology", "Function RingHom", "Function RingHom", "TopologicalSpace in", "Localization Polynomial Set in"], "variables": ["(R : Type u) (S : Type v)", "[CommSemiring R] [CommSemiring S]", "{R S}", "{S' : Type*} [CommSemiring S']", "(f : R \u2192+* S)", "(S)", "[CommRing R] [CommRing S]", "(f : R \u2192+* S)", "{R}", "{R S} [CommRing R] [CommRing S]", "[CommSemiring R] [CommSemiring S]", "{R S}", "(R) [DiscreteTopology (PrimeSpectrum R)]", "{R S : Type*} [CommSemiring R] [CommSemiring S] (f : R \u2192+* S)", "{f} in", "{R S : Type*} [CommSemiring R] [CommSemiring S] {f : R \u2192+* S}", "{R S : Type*} [CommSemiring R] [CommSemiring S] (f : R \u2192+* S)", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d : CommSemiring R\nx\u271d : Sort u_6\nbasicOpen : x\u271d\ns : Set (PrimeSpectrum R)\nhs : IsClopen s\n\u22a2 \u2203! e, IsIdempotentElem e \u2227 s = sorry"}, {"line": "refine existsUnique_of_exists_of_unique (exists_idempotent_basicOpen_eq_of_isClopen hs) ?_", "tactic_state": "R : Type u_4\ninst\u271d : CommSemiring R\nx\u271d : Sort u_6\nbasicOpen : x\u271d\ns : Set (PrimeSpectrum R)\nhs : IsClopen s\n\u22a2 \u2200 (y\u2081 y\u2082 : R), IsIdempotentElem y\u2081 \u2227 s = sorry \u2192 IsIdempotentElem y\u2082 \u2227 s = sorry \u2192 y\u2081 = y\u2082"}, {"line": "rintro x y \u27e8hx, rfl\u27e9 \u27e8hy, eq\u27e9", "tactic_state": "case intro.intro\nR : Type u_4\ninst\u271d : CommSemiring R\nx\u271d : Sort u_6\nbasicOpen : x\u271d\nx y : R\nhx : IsIdempotentElem x\nhs : IsClopen sorry\nhy : IsIdempotentElem y\neq : sorry = sorry\n\u22a2 x = y"}, {"line": "exact basicOpen_injOn_isIdempotentElem hx hy (SetLike.ext' eq)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isClopen_iff_mul_add {s : Set (PrimeSpectrum R)} :\n    IsClopen s \u2194 \u2203 e f : R, e * f = 0 \u2227 e + f = 1 \u2227 s = basicOpen e := by\n  refine \u27e8fun h \u21a6 ?_, ?_\u27e9\n  \u00b7 have \u27e8e, f, h\u27e9 := exists_mul_eq_zero_add_eq_one_basicOpen_eq_of_isClopen h\n    exact \u27e8e, f, by simp only [h, and_self]\u27e9\n  rintro \u27e8e, f, mul, add, rfl\u27e9\n  exact isClopen_basicOpen_of_mul_add e f mul add\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/Topology.lean", "context": {"open": ["Topology", "Function RingHom", "Function RingHom", "TopologicalSpace in", "Localization Polynomial Set in", "TopologicalSpace.Opens in"], "variables": ["(R : Type u) (S : Type v)", "[CommSemiring R] [CommSemiring S]", "{R S}", "{S' : Type*} [CommSemiring S']", "(f : R \u2192+* S)", "(S)", "[CommRing R] [CommRing S]", "(f : R \u2192+* S)", "{R}", "{R S} [CommRing R] [CommRing S]", "[CommSemiring R] [CommSemiring S]", "{R S}", "(R) [DiscreteTopology (PrimeSpectrum R)]", "{R S : Type*} [CommSemiring R] [CommSemiring S] (f : R \u2192+* S)", "{f} in", "{R S : Type*} [CommSemiring R] [CommSemiring S] {f : R \u2192+* S}", "{R S : Type*} [CommSemiring R] [CommSemiring S] (f : R \u2192+* S)", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d : CommSemiring R\nx\u271d : Sort u_6\nbasicOpen : x\u271d\ns : Set (PrimeSpectrum R)\n\u22a2 IsClopen s \u2194 \u2203 e f, e * f = 0 \u2227 e + f = 1 \u2227 s = sorry"}, {"line": "refine \u27e8fun h \u21a6 ?_, ?_\u27e9", "tactic_state": "case refine_1\nR : Type u_4\ninst\u271d : CommSemiring R\nx\u271d : Sort u_6\nbasicOpen : x\u271d\ns : Set (PrimeSpectrum R)\nh : IsClopen s\n\u22a2 \u2203 e f, e * f = 0 \u2227 e + f = 1 \u2227 s = sorry\n---\ncase refine_2\nR : Type u_4\ninst\u271d : CommSemiring R\nx\u271d : Sort u_6\nbasicOpen : x\u271d\ns : Set (PrimeSpectrum R)\n\u22a2 (\u2203 e f, e * f = 0 \u2227 e + f = 1 \u2227 s = sorry) \u2192 IsClopen s"}, {"line": "\u00b7 have \u27e8e, f, h\u27e9 := exists_mul_eq_zero_add_eq_one_basicOpen_eq_of_isClopen h\n    exact \u27e8e, f, by simp only [h, and_self]\u27e9", "tactic_state": "case refine_2\nR : Type u_4\ninst\u271d : CommSemiring R\nx\u271d : Sort u_6\nbasicOpen : x\u271d\ns : Set (PrimeSpectrum R)\n\u22a2 (\u2203 e f, e * f = 0 \u2227 e + f = 1 \u2227 s = sorry) \u2192 IsClopen s"}, {"line": "rintro \u27e8e, f, mul, add, rfl\u27e9", "tactic_state": "case refine_2.intro.intro.intro.intro\nR : Type u_4\ninst\u271d : CommSemiring R\nx\u271d : Sort u_6\nbasicOpen : x\u271d\ne f : R\nmul : e * f = 0\nadd : e + f = 1\n\u22a2 IsClopen sorry"}, {"line": "exact isClopen_basicOpen_of_mul_add e f mul add", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isRetrocompact_basicOpen {f : R} :\n    IsRetrocompact (basicOpen f : Set (PrimeSpectrum R)) := by\n  simpa using isRetrocompact_zeroLocus_compl (Set.finite_singleton f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Spectrum/Prime/Topology.lean", "context": {"open": ["Topology", "Function RingHom", "Function RingHom", "TopologicalSpace in", "Localization Polynomial Set in", "TopologicalSpace.Opens in", "TopologicalSpace (Clopens)"], "variables": ["(R : Type u) (S : Type v)", "[CommSemiring R] [CommSemiring S]", "{R S}", "{S' : Type*} [CommSemiring S']", "(f : R \u2192+* S)", "(S)", "[CommRing R] [CommRing S]", "(f : R \u2192+* S)", "{R}", "{R S} [CommRing R] [CommRing S]", "[CommSemiring R] [CommSemiring S]", "{R S}", "(R) [DiscreteTopology (PrimeSpectrum R)]", "{R S : Type*} [CommSemiring R] [CommSemiring S] (f : R \u2192+* S)", "{f} in", "{R S : Type*} [CommSemiring R] [CommSemiring S] {f : R \u2192+* S}", "{R S : Type*} [CommSemiring R] [CommSemiring S] (f : R \u2192+* S)", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d : CommSemiring R\nx\u271d : Sort u_6\nbasicOpen : x\u271d\nf : R\n\u22a2 IsRetrocompact sorry"}, {"line": "simpa using isRetrocompact_zeroLocus_compl (Set.finite_singleton f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma liftBaseChange_one_tmul (l : M \u2192\u2097[R] N) (y) : l.liftBaseChange A (1 \u2297\u209c y) = l y := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/TensorProduct/Basic.lean", "context": {"open": ["scoped TensorProduct", "TensorProduct", "TensorProduct"], "variables": ["{R A B M N P : Type*} [CommSemiring R]", "[Semiring A] [Algebra R A] [Semiring B] [Algebra R B]", "[AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P]", "[Module R M] [Module R N] [Module R P]", "(r : R) (f g : M \u2192\u2097[R] N)", "(A) in", "(R M) in", "(R A M N)", "{R A B M N : Type*} [CommRing R]", "[Ring A] [Algebra R A] [Ring B] [Algebra R B]", "[AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]", "(f g : M \u2192\u2097[R] N)", "{R M N} (A) [CommSemiring R] [CommSemiring A] [Algebra R A] [AddCommMonoid M]", "[AddCommMonoid N] [Module R M] [Module R N] [Module A N] [IsScalarTower R A N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_7\nM : Type u_10\nN : Type u_11\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nl : M \u2192\u2097[R] N\ny : M\n\u22a2 sorry = l y"}, {"line": "simp", "tactic_state": "R : Type u_7\nM : Type u_10\nN : Type u_11\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nl : M \u2192\u2097[R] N\ny : M\n\u22a2 sorry () = l y"}]}
{"declaration": "theorem tmul_pow (a : A) (b : B) (k : \u2115) : a \u2297\u209c[R] b ^ k = (a ^ k) \u2297\u209c[R] (b ^ k) := by\n  induction' k with k ih\n  \u00b7 simp [one_def]\n  \u00b7 simp [pow_succ, ih]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/TensorProduct/Basic.lean", "context": {"open": ["scoped TensorProduct", "TensorProduct", "TensorProduct", "LinearMap"], "variables": ["{R A B M N P : Type*} [CommSemiring R]", "[Semiring A] [Algebra R A] [Semiring B] [Algebra R B]", "[AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P]", "[Module R M] [Module R N] [Module R P]", "(r : R) (f g : M \u2192\u2097[R] N)", "(A) in", "(R M) in", "(R A M N)", "{R A B M N : Type*} [CommRing R]", "[Ring A] [Algebra R A] [Ring B] [Algebra R B]", "[AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]", "(f g : M \u2192\u2097[R] N)", "{R M N} (A) [CommSemiring R] [CommSemiring A] [Algebra R A] [AddCommMonoid M]", "[AddCommMonoid N] [Module R M] [Module R N] [Module A N] [IsScalarTower R A N]", "(R M N : Type*)", "{R : Type uR} {S : Type uS}", "{A : Type uA} {B : Type uB} {C : Type uC} {D : Type uD} {E : Type uE} {F : Type uF}", "[CommSemiring R]", "[AddCommMonoidWithOne A] [Module R A]", "[AddCommMonoidWithOne B] [Module R B]", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalNonAssocSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[NonAssocSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonAssocSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[NonUnitalSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[Semiring A] [Algebra R A]", "[Semiring B] [Algebra R B]", "[Semiring C] [Algebra R C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type uA\nB : Type uB\ninst\u271d\u2079 : AddCommMonoidWithOne A\ninst\u271d\u2078 : AddCommMonoidWithOne B\ninst\u271d\u2077 : NonUnitalNonAssocSemiring A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : NonAssocSemiring A\ninst\u271d\u2074 : NonAssocSemiring B\ninst\u271d\u00b3 : NonUnitalSemiring A\ninst\u271d\u00b2 : NonUnitalSemiring B\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Semiring B\na : A\nb : B\nk : \u2115\n\u22a2 sorry ^ k = sorry"}, {"line": "induction' k with k ih", "tactic_state": "case zero\nA : Type uA\nB : Type uB\ninst\u271d\u2079 : AddCommMonoidWithOne A\ninst\u271d\u2078 : AddCommMonoidWithOne B\ninst\u271d\u2077 : NonUnitalNonAssocSemiring A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : NonAssocSemiring A\ninst\u271d\u2074 : NonAssocSemiring B\ninst\u271d\u00b3 : NonUnitalSemiring A\ninst\u271d\u00b2 : NonUnitalSemiring B\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Semiring B\na : A\nb : B\n\u22a2 sorry ^ 0 = sorry\n---\ncase succ\nA : Type uA\nB : Type uB\ninst\u271d\u2079 : AddCommMonoidWithOne A\ninst\u271d\u2078 : AddCommMonoidWithOne B\ninst\u271d\u2077 : NonUnitalNonAssocSemiring A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : NonAssocSemiring A\ninst\u271d\u2074 : NonAssocSemiring B\ninst\u271d\u00b3 : NonUnitalSemiring A\ninst\u271d\u00b2 : NonUnitalSemiring B\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Semiring B\na : A\nb : B\nk : \u2115\nih : sorry ^ k = sorry\n\u22a2 sorry ^ (k + 1) = sorry"}, {"line": "\u00b7 simp [one_def]", "tactic_state": "case succ\nA : Type uA\nB : Type uB\ninst\u271d\u2079 : AddCommMonoidWithOne A\ninst\u271d\u2078 : AddCommMonoidWithOne B\ninst\u271d\u2077 : NonUnitalNonAssocSemiring A\ninst\u271d\u2076 : NonUnitalNonAssocSemiring B\ninst\u271d\u2075 : NonAssocSemiring A\ninst\u271d\u2074 : NonAssocSemiring B\ninst\u271d\u00b3 : NonUnitalSemiring A\ninst\u271d\u00b2 : NonUnitalSemiring B\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Semiring B\na : A\nb : B\nk : \u2115\nih : sorry ^ k = sorry\n\u22a2 sorry ^ (k + 1) = sorry"}, {"line": "\u00b7 simp [pow_succ, ih]", "tactic_state": "No Goals!"}]}
{"declaration": "example [Ring A] [Ring B] : Ring (A \u2297[\u2124] B) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/TensorProduct/Basic.lean", "context": {"open": ["scoped TensorProduct", "TensorProduct", "TensorProduct", "LinearMap"], "variables": ["{R A B M N P : Type*} [CommSemiring R]", "[Semiring A] [Algebra R A] [Semiring B] [Algebra R B]", "[AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P]", "[Module R M] [Module R N] [Module R P]", "(r : R) (f g : M \u2192\u2097[R] N)", "(A) in", "(R M) in", "(R A M N)", "{R A B M N : Type*} [CommRing R]", "[Ring A] [Algebra R A] [Ring B] [Algebra R B]", "[AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]", "(f g : M \u2192\u2097[R] N)", "{R M N} (A) [CommSemiring R] [CommSemiring A] [Algebra R A] [AddCommMonoid M]", "[AddCommMonoid N] [Module R M] [Module R N] [Module A N] [IsScalarTower R A N]", "(R M N : Type*)", "{R : Type uR} {S : Type uS}", "{A : Type uA} {B : Type uB} {C : Type uC} {D : Type uD} {E : Type uE} {F : Type uF}", "[CommSemiring R]", "[AddCommMonoidWithOne A] [Module R A]", "[AddCommMonoidWithOne B] [Module R B]", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalNonAssocSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[NonAssocSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonAssocSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[NonUnitalSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[Semiring A] [Algebra R A]", "[Semiring B] [Algebra R B]", "[Semiring C] [Algebra R C]", "[CommSemiring S] [Algebra S A]", "[Algebra R S] [Algebra S C] [IsScalarTower R S A] [IsScalarTower R S C]", "[CommSemiring R]", "[AddCommGroupWithOne A] [Module R A]", "[AddCommGroupWithOne B] [Module R B]", "[CommRing R]", "[NonUnitalNonAssocRing A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalNonAssocRing B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommRing R]", "[NonAssocRing A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonAssocRing B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommRing R]", "[NonUnitalRing A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalRing B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[CommSemiring A] [Algebra R A]", "[CommSemiring B] [Algebra R B]", "[CommRing R]", "[Ring A] [Algebra R A]", "[Ring B] [Algebra R B]", "[CommRing R]", "[CommRing A] [Algebra R A]", "[CommRing B] [Algebra R B]", "[CommSemiring R]", "[Semiring A] [Algebra R A]", "[CommSemiring B] [Algebra R B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u271d\u00b2 : Type u_1\nA\u271d\u00b9 : Type u_2\nB\u271d\u00b9 : Type u_3\nM\u271d\u00b9 : Type u_4\nN\u271d\u00b9 : Type u_5\nP : Type u_6\ninst\u271d\u00b9\u00b2\u00b3 : CommSemiring R\u271d\u00b2\ninst\u271d\u00b9\u00b2\u00b2 : Semiring A\u271d\u00b9\ninst\u271d\u00b9\u00b2\u00b9 : Algebra R\u271d\u00b2 A\u271d\u00b9\ninst\u271d\u00b9\u00b2\u2070 : Semiring B\u271d\u00b9\ninst\u271d\u00b9\u00b9\u2079 : Algebra R\u271d\u00b2 B\u271d\u00b9\ninst\u271d\u00b9\u00b9\u2078 : AddCommMonoid M\u271d\u00b9\ninst\u271d\u00b9\u00b9\u2077 : AddCommMonoid N\u271d\u00b9\ninst\u271d\u00b9\u00b9\u2076 : AddCommMonoid P\ninst\u271d\u00b9\u00b9\u2075 : Module R\u271d\u00b2 M\u271d\u00b9\ninst\u271d\u00b9\u00b9\u2074 : Module R\u271d\u00b2 N\u271d\u00b9\ninst\u271d\u00b9\u00b9\u00b3 : Module R\u271d\u00b2 P\nr : R\u271d\u00b2\nf\u271d g\u271d : M\u271d\u00b9 \u2192\u2097[R\u271d\u00b2] N\u271d\u00b9\nR\u271d\u00b9 : Type u_7\nA\u271d : Type u_8\nB\u271d : Type u_9\nM\u271d : Type u_10\nN\u271d : Type u_11\ninst\u271d\u00b9\u00b9\u00b2 : CommRing R\u271d\u00b9\ninst\u271d\u00b9\u00b9\u00b9 : Ring A\u271d\ninst\u271d\u00b9\u00b9\u2070 : Algebra R\u271d\u00b9 A\u271d\ninst\u271d\u00b9\u2070\u2079 : Ring B\u271d\ninst\u271d\u00b9\u2070\u2078 : Algebra R\u271d\u00b9 B\u271d\ninst\u271d\u00b9\u2070\u2077 : AddCommGroup M\u271d\ninst\u271d\u00b9\u2070\u2076 : Module R\u271d\u00b9 M\u271d\ninst\u271d\u00b9\u2070\u2075 : AddCommGroup N\u271d\ninst\u271d\u00b9\u2070\u2074 : Module R\u271d\u00b9 N\u271d\nf g : M\u271d \u2192\u2097[R\u271d\u00b9] N\u271d\ninst\u271d\u00b9\u2070\u00b3 : AddCommMonoid N\u271d\ninst\u271d\u00b9\u2070\u00b2 : Module R\u271d\u00b9 M\u271d\ninst\u271d\u00b9\u2070\u00b9 : Module R\u271d\u00b9 N\u271d\ninst\u271d\u00b9\u2070\u2070 : Module A\u271d N\u271d\ninst\u271d\u2079\u2079 : IsScalarTower R\u271d\u00b9 A\u271d N\u271d\nR\u271d : Type u_12\nM : Type u_13\nN : Type u_14\nR : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\nE : Type uE\nF : Type uF\ninst\u271d\u2079\u2078 : CommSemiring R\ninst\u271d\u2079\u2077 : AddCommMonoidWithOne A\ninst\u271d\u2079\u2076 : Module R A\ninst\u271d\u2079\u2075 : AddCommMonoidWithOne B\ninst\u271d\u2079\u2074 : Module R B\ninst\u271d\u2079\u00b3 : CommSemiring R\ninst\u271d\u2079\u00b2 : NonUnitalNonAssocSemiring A\ninst\u271d\u2079\u00b9 : Module R A\ninst\u271d\u2079\u2070 : SMulCommClass R A A\ninst\u271d\u2078\u2079 : IsScalarTower R A A\ninst\u271d\u2078\u2078 : NonUnitalNonAssocSemiring B\ninst\u271d\u2078\u2077 : Module R B\ninst\u271d\u2078\u2076 : SMulCommClass R B B\ninst\u271d\u2078\u2075 : IsScalarTower R B B\ninst\u271d\u2078\u2074 : CommSemiring R\ninst\u271d\u2078\u00b3 : NonAssocSemiring A\ninst\u271d\u2078\u00b2 : Module R A\ninst\u271d\u2078\u00b9 : SMulCommClass R A A\ninst\u271d\u2078\u2070 : IsScalarTower R A A\ninst\u271d\u2077\u2079 : NonAssocSemiring B\ninst\u271d\u2077\u2078 : Module R B\ninst\u271d\u2077\u2077 : SMulCommClass R B B\ninst\u271d\u2077\u2076 : IsScalarTower R B B\ninst\u271d\u2077\u2075 : CommSemiring R\ninst\u271d\u2077\u2074 : NonUnitalSemiring A\ninst\u271d\u2077\u00b3 : Module R A\ninst\u271d\u2077\u00b2 : SMulCommClass R A A\ninst\u271d\u2077\u00b9 : IsScalarTower R A A\ninst\u271d\u2077\u2070 : NonUnitalSemiring B\ninst\u271d\u2076\u2079 : Module R B\ninst\u271d\u2076\u2078 : SMulCommClass R B B\ninst\u271d\u2076\u2077 : IsScalarTower R B B\ninst\u271d\u2076\u2076 : CommSemiring R\ninst\u271d\u2076\u2075 : Semiring A\ninst\u271d\u2076\u2074 : Algebra R A\ninst\u271d\u2076\u00b3 : Semiring B\ninst\u271d\u2076\u00b2 : Algebra R B\ninst\u271d\u2076\u00b9 : Semiring C\ninst\u271d\u2076\u2070 : Algebra R C\ninst\u271d\u2075\u2079 : CommSemiring S\ninst\u271d\u2075\u2078 : Algebra S A\ninst\u271d\u2075\u2077 : Algebra R S\ninst\u271d\u2075\u2076 : Algebra S C\ninst\u271d\u2075\u2075 : IsScalarTower R S A\ninst\u271d\u2075\u2074 : IsScalarTower R S C\ninst\u271d\u2075\u00b3 : CommSemiring R\ninst\u271d\u2075\u00b2 : AddCommGroupWithOne A\ninst\u271d\u2075\u00b9 : Module R A\ninst\u271d\u2075\u2070 : AddCommGroupWithOne B\ninst\u271d\u2074\u2079 : Module R B\ninst\u271d\u2074\u2078 : CommRing R\ninst\u271d\u2074\u2077 : NonUnitalNonAssocRing A\ninst\u271d\u2074\u2076 : Module R A\ninst\u271d\u2074\u2075 : SMulCommClass R A A\ninst\u271d\u2074\u2074 : IsScalarTower R A A\ninst\u271d\u2074\u00b3 : NonUnitalNonAssocRing B\ninst\u271d\u2074\u00b2 : Module R B\ninst\u271d\u2074\u00b9 : SMulCommClass R B B\ninst\u271d\u2074\u2070 : IsScalarTower R B B\ninst\u271d\u00b3\u2079 : CommRing R\ninst\u271d\u00b3\u2078 : NonAssocRing A\ninst\u271d\u00b3\u2077 : Module R A\ninst\u271d\u00b3\u2076 : SMulCommClass R A A\ninst\u271d\u00b3\u2075 : IsScalarTower R A A\ninst\u271d\u00b3\u2074 : NonAssocRing B\ninst\u271d\u00b3\u00b3 : Module R B\ninst\u271d\u00b3\u00b2 : SMulCommClass R B B\ninst\u271d\u00b3\u00b9 : IsScalarTower R B B\ninst\u271d\u00b3\u2070 : CommRing R\ninst\u271d\u00b2\u2079 : NonUnitalRing A\ninst\u271d\u00b2\u2078 : Module R A\ninst\u271d\u00b2\u2077 : SMulCommClass R A A\ninst\u271d\u00b2\u2076 : IsScalarTower R A A\ninst\u271d\u00b2\u2075 : NonUnitalRing B\ninst\u271d\u00b2\u2074 : Module R B\ninst\u271d\u00b2\u00b3 : SMulCommClass R B B\ninst\u271d\u00b2\u00b2 : IsScalarTower R B B\ninst\u271d\u00b2\u00b9 : CommSemiring R\ninst\u271d\u00b2\u2070 : CommSemiring A\ninst\u271d\u00b9\u2079 : Algebra R A\ninst\u271d\u00b9\u2078 : CommSemiring B\ninst\u271d\u00b9\u2077 : Algebra R B\ninst\u271d\u00b9\u2076 : CommRing R\ninst\u271d\u00b9\u2075 : Ring A\ninst\u271d\u00b9\u2074 : Algebra R A\ninst\u271d\u00b9\u00b3 : Ring B\ninst\u271d\u00b9\u00b2 : Algebra R B\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : Algebra R A\ninst\u271d\u2078 : CommRing B\ninst\u271d\u2077 : Algebra R B\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : CommSemiring B\ninst\u271d\u00b2 : Algebra R B\ninst\u271d\u00b9 : Ring A\ninst\u271d : Ring B\n\u22a2 Ring sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example [CommRing A] [CommRing B] : CommRing (A \u2297[\u2124] B) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/TensorProduct/Basic.lean", "context": {"open": ["scoped TensorProduct", "TensorProduct", "TensorProduct", "LinearMap"], "variables": ["{R A B M N P : Type*} [CommSemiring R]", "[Semiring A] [Algebra R A] [Semiring B] [Algebra R B]", "[AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P]", "[Module R M] [Module R N] [Module R P]", "(r : R) (f g : M \u2192\u2097[R] N)", "(A) in", "(R M) in", "(R A M N)", "{R A B M N : Type*} [CommRing R]", "[Ring A] [Algebra R A] [Ring B] [Algebra R B]", "[AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]", "(f g : M \u2192\u2097[R] N)", "{R M N} (A) [CommSemiring R] [CommSemiring A] [Algebra R A] [AddCommMonoid M]", "[AddCommMonoid N] [Module R M] [Module R N] [Module A N] [IsScalarTower R A N]", "(R M N : Type*)", "{R : Type uR} {S : Type uS}", "{A : Type uA} {B : Type uB} {C : Type uC} {D : Type uD} {E : Type uE} {F : Type uF}", "[CommSemiring R]", "[AddCommMonoidWithOne A] [Module R A]", "[AddCommMonoidWithOne B] [Module R B]", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalNonAssocSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[NonAssocSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonAssocSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[NonUnitalSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[Semiring A] [Algebra R A]", "[Semiring B] [Algebra R B]", "[Semiring C] [Algebra R C]", "[CommSemiring S] [Algebra S A]", "[Algebra R S] [Algebra S C] [IsScalarTower R S A] [IsScalarTower R S C]", "[CommSemiring R]", "[AddCommGroupWithOne A] [Module R A]", "[AddCommGroupWithOne B] [Module R B]", "[CommRing R]", "[NonUnitalNonAssocRing A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalNonAssocRing B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommRing R]", "[NonAssocRing A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonAssocRing B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommRing R]", "[NonUnitalRing A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalRing B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[CommSemiring A] [Algebra R A]", "[CommSemiring B] [Algebra R B]", "[CommRing R]", "[Ring A] [Algebra R A]", "[Ring B] [Algebra R B]", "[CommRing R]", "[CommRing A] [Algebra R A]", "[CommRing B] [Algebra R B]", "[CommSemiring R]", "[Semiring A] [Algebra R A]", "[CommSemiring B] [Algebra R B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u271d\u00b2 : Type u_1\nA\u271d\u00b9 : Type u_2\nB\u271d\u00b9 : Type u_3\nM\u271d\u00b9 : Type u_4\nN\u271d\u00b9 : Type u_5\nP : Type u_6\ninst\u271d\u00b9\u00b2\u00b3 : CommSemiring R\u271d\u00b2\ninst\u271d\u00b9\u00b2\u00b2 : Semiring A\u271d\u00b9\ninst\u271d\u00b9\u00b2\u00b9 : Algebra R\u271d\u00b2 A\u271d\u00b9\ninst\u271d\u00b9\u00b2\u2070 : Semiring B\u271d\u00b9\ninst\u271d\u00b9\u00b9\u2079 : Algebra R\u271d\u00b2 B\u271d\u00b9\ninst\u271d\u00b9\u00b9\u2078 : AddCommMonoid M\u271d\u00b9\ninst\u271d\u00b9\u00b9\u2077 : AddCommMonoid N\u271d\u00b9\ninst\u271d\u00b9\u00b9\u2076 : AddCommMonoid P\ninst\u271d\u00b9\u00b9\u2075 : Module R\u271d\u00b2 M\u271d\u00b9\ninst\u271d\u00b9\u00b9\u2074 : Module R\u271d\u00b2 N\u271d\u00b9\ninst\u271d\u00b9\u00b9\u00b3 : Module R\u271d\u00b2 P\nr : R\u271d\u00b2\nf\u271d g\u271d : M\u271d\u00b9 \u2192\u2097[R\u271d\u00b2] N\u271d\u00b9\nR\u271d\u00b9 : Type u_7\nA\u271d : Type u_8\nB\u271d : Type u_9\nM\u271d : Type u_10\nN\u271d : Type u_11\ninst\u271d\u00b9\u00b9\u00b2 : CommRing R\u271d\u00b9\ninst\u271d\u00b9\u00b9\u00b9 : Ring A\u271d\ninst\u271d\u00b9\u00b9\u2070 : Algebra R\u271d\u00b9 A\u271d\ninst\u271d\u00b9\u2070\u2079 : Ring B\u271d\ninst\u271d\u00b9\u2070\u2078 : Algebra R\u271d\u00b9 B\u271d\ninst\u271d\u00b9\u2070\u2077 : AddCommGroup M\u271d\ninst\u271d\u00b9\u2070\u2076 : Module R\u271d\u00b9 M\u271d\ninst\u271d\u00b9\u2070\u2075 : AddCommGroup N\u271d\ninst\u271d\u00b9\u2070\u2074 : Module R\u271d\u00b9 N\u271d\nf g : M\u271d \u2192\u2097[R\u271d\u00b9] N\u271d\ninst\u271d\u00b9\u2070\u00b3 : AddCommMonoid N\u271d\ninst\u271d\u00b9\u2070\u00b2 : Module R\u271d\u00b9 M\u271d\ninst\u271d\u00b9\u2070\u00b9 : Module R\u271d\u00b9 N\u271d\ninst\u271d\u00b9\u2070\u2070 : Module A\u271d N\u271d\ninst\u271d\u2079\u2079 : IsScalarTower R\u271d\u00b9 A\u271d N\u271d\nR\u271d : Type u_12\nM : Type u_13\nN : Type u_14\nR : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\nE : Type uE\nF : Type uF\ninst\u271d\u2079\u2078 : CommSemiring R\ninst\u271d\u2079\u2077 : AddCommMonoidWithOne A\ninst\u271d\u2079\u2076 : Module R A\ninst\u271d\u2079\u2075 : AddCommMonoidWithOne B\ninst\u271d\u2079\u2074 : Module R B\ninst\u271d\u2079\u00b3 : CommSemiring R\ninst\u271d\u2079\u00b2 : NonUnitalNonAssocSemiring A\ninst\u271d\u2079\u00b9 : Module R A\ninst\u271d\u2079\u2070 : SMulCommClass R A A\ninst\u271d\u2078\u2079 : IsScalarTower R A A\ninst\u271d\u2078\u2078 : NonUnitalNonAssocSemiring B\ninst\u271d\u2078\u2077 : Module R B\ninst\u271d\u2078\u2076 : SMulCommClass R B B\ninst\u271d\u2078\u2075 : IsScalarTower R B B\ninst\u271d\u2078\u2074 : CommSemiring R\ninst\u271d\u2078\u00b3 : NonAssocSemiring A\ninst\u271d\u2078\u00b2 : Module R A\ninst\u271d\u2078\u00b9 : SMulCommClass R A A\ninst\u271d\u2078\u2070 : IsScalarTower R A A\ninst\u271d\u2077\u2079 : NonAssocSemiring B\ninst\u271d\u2077\u2078 : Module R B\ninst\u271d\u2077\u2077 : SMulCommClass R B B\ninst\u271d\u2077\u2076 : IsScalarTower R B B\ninst\u271d\u2077\u2075 : CommSemiring R\ninst\u271d\u2077\u2074 : NonUnitalSemiring A\ninst\u271d\u2077\u00b3 : Module R A\ninst\u271d\u2077\u00b2 : SMulCommClass R A A\ninst\u271d\u2077\u00b9 : IsScalarTower R A A\ninst\u271d\u2077\u2070 : NonUnitalSemiring B\ninst\u271d\u2076\u2079 : Module R B\ninst\u271d\u2076\u2078 : SMulCommClass R B B\ninst\u271d\u2076\u2077 : IsScalarTower R B B\ninst\u271d\u2076\u2076 : CommSemiring R\ninst\u271d\u2076\u2075 : Semiring A\ninst\u271d\u2076\u2074 : Algebra R A\ninst\u271d\u2076\u00b3 : Semiring B\ninst\u271d\u2076\u00b2 : Algebra R B\ninst\u271d\u2076\u00b9 : Semiring C\ninst\u271d\u2076\u2070 : Algebra R C\ninst\u271d\u2075\u2079 : CommSemiring S\ninst\u271d\u2075\u2078 : Algebra S A\ninst\u271d\u2075\u2077 : Algebra R S\ninst\u271d\u2075\u2076 : Algebra S C\ninst\u271d\u2075\u2075 : IsScalarTower R S A\ninst\u271d\u2075\u2074 : IsScalarTower R S C\ninst\u271d\u2075\u00b3 : CommSemiring R\ninst\u271d\u2075\u00b2 : AddCommGroupWithOne A\ninst\u271d\u2075\u00b9 : Module R A\ninst\u271d\u2075\u2070 : AddCommGroupWithOne B\ninst\u271d\u2074\u2079 : Module R B\ninst\u271d\u2074\u2078 : CommRing R\ninst\u271d\u2074\u2077 : NonUnitalNonAssocRing A\ninst\u271d\u2074\u2076 : Module R A\ninst\u271d\u2074\u2075 : SMulCommClass R A A\ninst\u271d\u2074\u2074 : IsScalarTower R A A\ninst\u271d\u2074\u00b3 : NonUnitalNonAssocRing B\ninst\u271d\u2074\u00b2 : Module R B\ninst\u271d\u2074\u00b9 : SMulCommClass R B B\ninst\u271d\u2074\u2070 : IsScalarTower R B B\ninst\u271d\u00b3\u2079 : CommRing R\ninst\u271d\u00b3\u2078 : NonAssocRing A\ninst\u271d\u00b3\u2077 : Module R A\ninst\u271d\u00b3\u2076 : SMulCommClass R A A\ninst\u271d\u00b3\u2075 : IsScalarTower R A A\ninst\u271d\u00b3\u2074 : NonAssocRing B\ninst\u271d\u00b3\u00b3 : Module R B\ninst\u271d\u00b3\u00b2 : SMulCommClass R B B\ninst\u271d\u00b3\u00b9 : IsScalarTower R B B\ninst\u271d\u00b3\u2070 : CommRing R\ninst\u271d\u00b2\u2079 : NonUnitalRing A\ninst\u271d\u00b2\u2078 : Module R A\ninst\u271d\u00b2\u2077 : SMulCommClass R A A\ninst\u271d\u00b2\u2076 : IsScalarTower R A A\ninst\u271d\u00b2\u2075 : NonUnitalRing B\ninst\u271d\u00b2\u2074 : Module R B\ninst\u271d\u00b2\u00b3 : SMulCommClass R B B\ninst\u271d\u00b2\u00b2 : IsScalarTower R B B\ninst\u271d\u00b2\u00b9 : CommSemiring R\ninst\u271d\u00b2\u2070 : CommSemiring A\ninst\u271d\u00b9\u2079 : Algebra R A\ninst\u271d\u00b9\u2078 : CommSemiring B\ninst\u271d\u00b9\u2077 : Algebra R B\ninst\u271d\u00b9\u2076 : CommRing R\ninst\u271d\u00b9\u2075 : Ring A\ninst\u271d\u00b9\u2074 : Algebra R A\ninst\u271d\u00b9\u00b3 : Ring B\ninst\u271d\u00b9\u00b2 : Algebra R B\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : Algebra R A\ninst\u271d\u2078 : CommRing B\ninst\u271d\u2077 : Algebra R B\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : CommSemiring B\ninst\u271d\u00b2 : Algebra R B\ninst\u271d\u00b9 : CommRing A\ninst\u271d : CommRing B\n\u22a2 CommRing sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem productMap_left_apply (a : A) : productMap f g (a \u2297\u209c 1) = f a := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/TensorProduct/Basic.lean", "context": {"open": ["scoped TensorProduct", "TensorProduct", "TensorProduct", "LinearMap"], "variables": ["{R A B M N P : Type*} [CommSemiring R]", "[Semiring A] [Algebra R A] [Semiring B] [Algebra R B]", "[AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P]", "[Module R M] [Module R N] [Module R P]", "(r : R) (f g : M \u2192\u2097[R] N)", "(A) in", "(R M) in", "(R A M N)", "{R A B M N : Type*} [CommRing R]", "[Ring A] [Algebra R A] [Ring B] [Algebra R B]", "[AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]", "(f g : M \u2192\u2097[R] N)", "{R M N} (A) [CommSemiring R] [CommSemiring A] [Algebra R A] [AddCommMonoid M]", "[AddCommMonoid N] [Module R M] [Module R N] [Module A N] [IsScalarTower R A N]", "(R M N : Type*)", "{R : Type uR} {S : Type uS}", "{A : Type uA} {B : Type uB} {C : Type uC} {D : Type uD} {E : Type uE} {F : Type uF}", "[CommSemiring R]", "[AddCommMonoidWithOne A] [Module R A]", "[AddCommMonoidWithOne B] [Module R B]", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalNonAssocSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[NonAssocSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonAssocSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[NonUnitalSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[Semiring A] [Algebra R A]", "[Semiring B] [Algebra R B]", "[Semiring C] [Algebra R C]", "[CommSemiring S] [Algebra S A]", "[Algebra R S] [Algebra S C] [IsScalarTower R S A] [IsScalarTower R S C]", "[CommSemiring R]", "[AddCommGroupWithOne A] [Module R A]", "[AddCommGroupWithOne B] [Module R B]", "[CommRing R]", "[NonUnitalNonAssocRing A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalNonAssocRing B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommRing R]", "[NonAssocRing A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonAssocRing B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommRing R]", "[NonUnitalRing A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalRing B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[CommSemiring A] [Algebra R A]", "[CommSemiring B] [Algebra R B]", "[CommRing R]", "[Ring A] [Algebra R A]", "[Ring B] [Algebra R B]", "[CommRing R]", "[CommRing A] [Algebra R A]", "[CommRing B] [Algebra R B]", "[CommSemiring R]", "[Semiring A] [Algebra R A]", "[CommSemiring B] [Algebra R B]", "[CommSemiring R] [CommSemiring S] [Algebra R S]", "[Semiring A] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "[Semiring B] [Algebra R B]", "[Semiring C] [Algebra S C]", "[Semiring D] [Algebra R D]", "[Algebra R C]", "[IsScalarTower R S C]", "[CommSemiring R] [CommSemiring S] [Algebra R S]", "[Semiring A] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "[Semiring B] [Algebra R B]", "[Semiring C] [Algebra R C] [Algebra S C] [IsScalarTower R S C]", "[Semiring D] [Algebra R D]", "[Semiring E] [Algebra R E] [Algebra S E] [IsScalarTower R S E]", "[Semiring F] [Algebra R F]", "(R A)", "{R} {A} in", "{A} in", "(S)", "{R A} in", "{A} in", "(R S A B : Type*) [CommSemiring R] [CommSemiring S] [Semiring A] [Semiring B]", "[Algebra R A] [Algebra R B] [Algebra S A] [Algebra S B]", "[SMulCommClass R S A] [CompatibleSMul R S A B]", "[Algebra R S] [CompatibleSMul R S S A] [CompatibleSMul S R S A]", "(B)", "{A B} in", "{A B} in", "{R A}", "(R A B C)", "{A B C}", "(T A B : Type*) [CommSemiring T] [CommSemiring A] [CommSemiring B]", "{R S A}", "(R A B C) in", "(R S A B C D) in", "[CommSemiring R] [CommSemiring S] [Algebra R S]", "[Semiring A] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "[Semiring B] [Algebra R B]", "[CommSemiring C] [Algebra R C] [Algebra S C] [IsScalarTower R S C]", "[CommSemiring R] [Semiring A] [Semiring B] [CommSemiring S]", "[Algebra R A] [Algebra R B] [Algebra R S]", "(f : A \u2192\u2090[R] S) (g : B \u2192\u2090[R] S)", "(R)", "{R}", "(R S) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type uR\nS : Type uS\ninst\u271d\u00b3\u2070 inst\u271d\u00b2\u2079 inst\u271d\u00b2\u2078 inst\u271d\u00b2\u2077 inst\u271d\u00b2\u2076 : CommSemiring R\ninst\u271d\u00b2\u2075 : CommSemiring S\ninst\u271d\u00b2\u2074 : Algebra R S\ninst\u271d\u00b2\u00b3 : CommSemiring R\ninst\u271d\u00b2\u00b2 inst\u271d\u00b2\u00b9 inst\u271d\u00b2\u2070 : CommRing R\ninst\u271d\u00b9\u2079 : CommSemiring R\ninst\u271d\u00b9\u2078 inst\u271d\u00b9\u2077 : CommRing R\ninst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 : CommSemiring R\ninst\u271d\u00b9\u2074 : CommSemiring S\ninst\u271d\u00b9\u00b3 : Algebra R S\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : CommSemiring S\ninst\u271d\u00b9\u2070 : Algebra R S\nA : Type u_16\ninst\u271d\u2079 : CommSemiring A\ninst\u271d\u2078 : Semiring A\ninst\u271d\u2077 : Algebra R A\ninst\u271d\u2076 : Algebra S A\ninst\u271d\u2075 : IsScalarTower R S A\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R S\nf : A \u2192\u2090[R] S\nx\u271d : Sort u_18\nproductMap : x\u271d\na : A\n\u22a2 sorry = f a"}, {"line": "simp", "tactic_state": "R : Type uR\nS : Type uS\ninst\u271d\u00b3\u2070 inst\u271d\u00b2\u2079 inst\u271d\u00b2\u2078 inst\u271d\u00b2\u2077 inst\u271d\u00b2\u2076 : CommSemiring R\ninst\u271d\u00b2\u2075 : CommSemiring S\ninst\u271d\u00b2\u2074 : Algebra R S\ninst\u271d\u00b2\u00b3 : CommSemiring R\ninst\u271d\u00b2\u00b2 inst\u271d\u00b2\u00b9 inst\u271d\u00b2\u2070 : CommRing R\ninst\u271d\u00b9\u2079 : CommSemiring R\ninst\u271d\u00b9\u2078 inst\u271d\u00b9\u2077 : CommRing R\ninst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 : CommSemiring R\ninst\u271d\u00b9\u2074 : CommSemiring S\ninst\u271d\u00b9\u00b3 : Algebra R S\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : CommSemiring S\ninst\u271d\u00b9\u2070 : Algebra R S\nA : Type u_16\ninst\u271d\u2079 : CommSemiring A\ninst\u271d\u2078 : Semiring A\ninst\u271d\u2077 : Algebra R A\ninst\u271d\u2076 : Algebra S A\ninst\u271d\u2075 : IsScalarTower R S A\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R S\nf : A \u2192\u2090[R] S\nx\u271d : Sort u_18\nproductMap : x\u271d\na : A\n\u22a2 sorry () = f a"}]}
{"declaration": "theorem productMap_right_apply (b : B) :\n    productMap f g (1 \u2297\u209c b) = g b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/TensorProduct/Basic.lean", "context": {"open": ["scoped TensorProduct", "TensorProduct", "TensorProduct", "LinearMap"], "variables": ["{R A B M N P : Type*} [CommSemiring R]", "[Semiring A] [Algebra R A] [Semiring B] [Algebra R B]", "[AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P]", "[Module R M] [Module R N] [Module R P]", "(r : R) (f g : M \u2192\u2097[R] N)", "(A) in", "(R M) in", "(R A M N)", "{R A B M N : Type*} [CommRing R]", "[Ring A] [Algebra R A] [Ring B] [Algebra R B]", "[AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]", "(f g : M \u2192\u2097[R] N)", "{R M N} (A) [CommSemiring R] [CommSemiring A] [Algebra R A] [AddCommMonoid M]", "[AddCommMonoid N] [Module R M] [Module R N] [Module A N] [IsScalarTower R A N]", "(R M N : Type*)", "{R : Type uR} {S : Type uS}", "{A : Type uA} {B : Type uB} {C : Type uC} {D : Type uD} {E : Type uE} {F : Type uF}", "[CommSemiring R]", "[AddCommMonoidWithOne A] [Module R A]", "[AddCommMonoidWithOne B] [Module R B]", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalNonAssocSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[NonAssocSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonAssocSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[NonUnitalSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[Semiring A] [Algebra R A]", "[Semiring B] [Algebra R B]", "[Semiring C] [Algebra R C]", "[CommSemiring S] [Algebra S A]", "[Algebra R S] [Algebra S C] [IsScalarTower R S A] [IsScalarTower R S C]", "[CommSemiring R]", "[AddCommGroupWithOne A] [Module R A]", "[AddCommGroupWithOne B] [Module R B]", "[CommRing R]", "[NonUnitalNonAssocRing A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalNonAssocRing B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommRing R]", "[NonAssocRing A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonAssocRing B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommRing R]", "[NonUnitalRing A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalRing B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[CommSemiring A] [Algebra R A]", "[CommSemiring B] [Algebra R B]", "[CommRing R]", "[Ring A] [Algebra R A]", "[Ring B] [Algebra R B]", "[CommRing R]", "[CommRing A] [Algebra R A]", "[CommRing B] [Algebra R B]", "[CommSemiring R]", "[Semiring A] [Algebra R A]", "[CommSemiring B] [Algebra R B]", "[CommSemiring R] [CommSemiring S] [Algebra R S]", "[Semiring A] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "[Semiring B] [Algebra R B]", "[Semiring C] [Algebra S C]", "[Semiring D] [Algebra R D]", "[Algebra R C]", "[IsScalarTower R S C]", "[CommSemiring R] [CommSemiring S] [Algebra R S]", "[Semiring A] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "[Semiring B] [Algebra R B]", "[Semiring C] [Algebra R C] [Algebra S C] [IsScalarTower R S C]", "[Semiring D] [Algebra R D]", "[Semiring E] [Algebra R E] [Algebra S E] [IsScalarTower R S E]", "[Semiring F] [Algebra R F]", "(R A)", "{R} {A} in", "{A} in", "(S)", "{R A} in", "{A} in", "(R S A B : Type*) [CommSemiring R] [CommSemiring S] [Semiring A] [Semiring B]", "[Algebra R A] [Algebra R B] [Algebra S A] [Algebra S B]", "[SMulCommClass R S A] [CompatibleSMul R S A B]", "[Algebra R S] [CompatibleSMul R S S A] [CompatibleSMul S R S A]", "(B)", "{A B} in", "{A B} in", "{R A}", "(R A B C)", "{A B C}", "(T A B : Type*) [CommSemiring T] [CommSemiring A] [CommSemiring B]", "{R S A}", "(R A B C) in", "(R S A B C D) in", "[CommSemiring R] [CommSemiring S] [Algebra R S]", "[Semiring A] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "[Semiring B] [Algebra R B]", "[CommSemiring C] [Algebra R C] [Algebra S C] [IsScalarTower R S C]", "[CommSemiring R] [Semiring A] [Semiring B] [CommSemiring S]", "[Algebra R A] [Algebra R B] [Algebra R S]", "(f : A \u2192\u2090[R] S) (g : B \u2192\u2090[R] S)", "(R)", "{R}", "(R S) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type uR\nS : Type uS\ninst\u271d\u00b2\u2078 inst\u271d\u00b2\u2077 inst\u271d\u00b2\u2076 inst\u271d\u00b2\u2075 inst\u271d\u00b2\u2074 : CommSemiring R\ninst\u271d\u00b2\u00b3 : CommSemiring S\ninst\u271d\u00b2\u00b2 : Algebra R S\ninst\u271d\u00b2\u00b9 : CommSemiring R\ninst\u271d\u00b2\u2070 inst\u271d\u00b9\u2079 inst\u271d\u00b9\u2078 : CommRing R\ninst\u271d\u00b9\u2077 : CommSemiring R\ninst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 : CommRing R\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 : CommSemiring R\ninst\u271d\u00b9\u00b2 : CommSemiring S\ninst\u271d\u00b9\u00b9 : Algebra R S\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : CommSemiring S\ninst\u271d\u2078 : Algebra R S\nB : Type u_17\ninst\u271d\u2077 : CommSemiring B\ninst\u271d\u2076 : Semiring B\ninst\u271d\u2075 : Algebra R B\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : Algebra R S\ng : B \u2192\u2090[R] S\nx\u271d : Sort u_18\nproductMap : x\u271d\nb : B\n\u22a2 sorry = g b"}, {"line": "simp", "tactic_state": "R : Type uR\nS : Type uS\ninst\u271d\u00b2\u2078 inst\u271d\u00b2\u2077 inst\u271d\u00b2\u2076 inst\u271d\u00b2\u2075 inst\u271d\u00b2\u2074 : CommSemiring R\ninst\u271d\u00b2\u00b3 : CommSemiring S\ninst\u271d\u00b2\u00b2 : Algebra R S\ninst\u271d\u00b2\u00b9 : CommSemiring R\ninst\u271d\u00b2\u2070 inst\u271d\u00b9\u2079 inst\u271d\u00b9\u2078 : CommRing R\ninst\u271d\u00b9\u2077 : CommSemiring R\ninst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 : CommRing R\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 : CommSemiring R\ninst\u271d\u00b9\u00b2 : CommSemiring S\ninst\u271d\u00b9\u00b9 : Algebra R S\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : CommSemiring S\ninst\u271d\u2078 : Algebra R S\nB : Type u_17\ninst\u271d\u2077 : CommSemiring B\ninst\u271d\u2076 : Semiring B\ninst\u271d\u2075 : Algebra R B\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : Algebra R S\ng : B \u2192\u2090[R] S\nx\u271d : Sort u_18\nproductMap : x\u271d\nb : B\n\u22a2 sorry () = g b"}]}
{"declaration": "lemma mk_one_injective_of_isScalarTower (M : Type*) [AddCommMonoid M]\n    [Module R M] [Module S M] [IsScalarTower R S M] :\n    Function.Injective (TensorProduct.mk R S M 1) := by\n  apply Function.RightInverse.injective (g := LinearMap.liftBaseChange S LinearMap.id)\n  intro m\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/TensorProduct/Basic.lean", "context": {"open": ["scoped TensorProduct", "TensorProduct", "TensorProduct", "LinearMap"], "variables": ["{R A B M N P : Type*} [CommSemiring R]", "[Semiring A] [Algebra R A] [Semiring B] [Algebra R B]", "[AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P]", "[Module R M] [Module R N] [Module R P]", "(r : R) (f g : M \u2192\u2097[R] N)", "(A) in", "(R M) in", "(R A M N)", "{R A B M N : Type*} [CommRing R]", "[Ring A] [Algebra R A] [Ring B] [Algebra R B]", "[AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]", "(f g : M \u2192\u2097[R] N)", "{R M N} (A) [CommSemiring R] [CommSemiring A] [Algebra R A] [AddCommMonoid M]", "[AddCommMonoid N] [Module R M] [Module R N] [Module A N] [IsScalarTower R A N]", "(R M N : Type*)", "{R : Type uR} {S : Type uS}", "{A : Type uA} {B : Type uB} {C : Type uC} {D : Type uD} {E : Type uE} {F : Type uF}", "[CommSemiring R]", "[AddCommMonoidWithOne A] [Module R A]", "[AddCommMonoidWithOne B] [Module R B]", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalNonAssocSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[NonAssocSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonAssocSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[NonUnitalSemiring A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalSemiring B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[Semiring A] [Algebra R A]", "[Semiring B] [Algebra R B]", "[Semiring C] [Algebra R C]", "[CommSemiring S] [Algebra S A]", "[Algebra R S] [Algebra S C] [IsScalarTower R S A] [IsScalarTower R S C]", "[CommSemiring R]", "[AddCommGroupWithOne A] [Module R A]", "[AddCommGroupWithOne B] [Module R B]", "[CommRing R]", "[NonUnitalNonAssocRing A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalNonAssocRing B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommRing R]", "[NonAssocRing A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonAssocRing B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommRing R]", "[NonUnitalRing A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalRing B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[CommSemiring R]", "[CommSemiring A] [Algebra R A]", "[CommSemiring B] [Algebra R B]", "[CommRing R]", "[Ring A] [Algebra R A]", "[Ring B] [Algebra R B]", "[CommRing R]", "[CommRing A] [Algebra R A]", "[CommRing B] [Algebra R B]", "[CommSemiring R]", "[Semiring A] [Algebra R A]", "[CommSemiring B] [Algebra R B]", "[CommSemiring R] [CommSemiring S] [Algebra R S]", "[Semiring A] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "[Semiring B] [Algebra R B]", "[Semiring C] [Algebra S C]", "[Semiring D] [Algebra R D]", "[Algebra R C]", "[IsScalarTower R S C]", "[CommSemiring R] [CommSemiring S] [Algebra R S]", "[Semiring A] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "[Semiring B] [Algebra R B]", "[Semiring C] [Algebra R C] [Algebra S C] [IsScalarTower R S C]", "[Semiring D] [Algebra R D]", "[Semiring E] [Algebra R E] [Algebra S E] [IsScalarTower R S E]", "[Semiring F] [Algebra R F]", "(R A)", "{R} {A} in", "{A} in", "(S)", "{R A} in", "{A} in", "(R S A B : Type*) [CommSemiring R] [CommSemiring S] [Semiring A] [Semiring B]", "[Algebra R A] [Algebra R B] [Algebra S A] [Algebra S B]", "[SMulCommClass R S A] [CompatibleSMul R S A B]", "[Algebra R S] [CompatibleSMul R S S A] [CompatibleSMul S R S A]", "(B)", "{A B} in", "{A B} in", "{R A}", "(R A B C)", "{A B C}", "(T A B : Type*) [CommSemiring T] [CommSemiring A] [CommSemiring B]", "{R S A}", "(R A B C) in", "(R S A B C D) in", "[CommSemiring R] [CommSemiring S] [Algebra R S]", "[Semiring A] [Algebra R A] [Algebra S A] [IsScalarTower R S A]", "[Semiring B] [Algebra R B]", "[CommSemiring C] [Algebra R C] [Algebra S C] [IsScalarTower R S C]", "[CommSemiring R] [Semiring A] [Semiring B] [CommSemiring S]", "[Algebra R A] [Algebra R B] [Algebra R S]", "(f : A \u2192\u2090[R] S) (g : B \u2192\u2090[R] S)", "(R)", "{R}", "(R S) in", "[CommSemiring R] [CommSemiring S] [Algebra R S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type uR\nS : Type uS\ninst\u271d\u00b2\u2077 inst\u271d\u00b2\u2076 inst\u271d\u00b2\u2075 inst\u271d\u00b2\u2074 inst\u271d\u00b2\u00b3 : CommSemiring R\ninst\u271d\u00b2\u00b2 : CommSemiring S\ninst\u271d\u00b2\u00b9 : Algebra R S\ninst\u271d\u00b2\u2070 : CommSemiring R\ninst\u271d\u00b9\u2079 inst\u271d\u00b9\u2078 inst\u271d\u00b9\u2077 : CommRing R\ninst\u271d\u00b9\u2076 : CommSemiring R\ninst\u271d\u00b9\u2075 inst\u271d\u00b9\u2074 : CommRing R\ninst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : CommSemiring S\ninst\u271d\u00b9\u2070 : Algebra R S\ninst\u271d\u2079 : CommSemiring R\ninst\u271d\u2078 : CommSemiring S\ninst\u271d\u2077 : Algebra R S\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : CommSemiring S\ninst\u271d\u2074 : Algebra R S\nM : Type u_18\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module S M\ninst\u271d : IsScalarTower R S M\n\u22a2 Function.Injective \u21d1((TensorProduct.mk R S M) 1)"}, {"line": "apply Function.RightInverse.injective (g := LinearMap.liftBaseChange S LinearMap.id)", "tactic_state": "R : Type uR\nS : Type uS\ninst\u271d\u00b2\u2077 inst\u271d\u00b2\u2076 inst\u271d\u00b2\u2075 inst\u271d\u00b2\u2074 inst\u271d\u00b2\u00b3 : CommSemiring R\ninst\u271d\u00b2\u00b2 : CommSemiring S\ninst\u271d\u00b2\u00b9 : Algebra R S\ninst\u271d\u00b2\u2070 : CommSemiring R\ninst\u271d\u00b9\u2079 inst\u271d\u00b9\u2078 inst\u271d\u00b9\u2077 : CommRing R\ninst\u271d\u00b9\u2076 : CommSemiring R\ninst\u271d\u00b9\u2075 inst\u271d\u00b9\u2074 : CommRing R\ninst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : CommSemiring S\ninst\u271d\u00b9\u2070 : Algebra R S\ninst\u271d\u2079 : CommSemiring R\ninst\u271d\u2078 : CommSemiring S\ninst\u271d\u2077 : Algebra R S\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : CommSemiring S\ninst\u271d\u2074 : Algebra R S\nM : Type u_18\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module S M\ninst\u271d : IsScalarTower R S M\n\u22a2 Function.RightInverse \u21d1((TensorProduct.mk R S M) 1) sorry"}, {"line": "intro m", "tactic_state": "R : Type uR\nS : Type uS\ninst\u271d\u00b2\u2077 inst\u271d\u00b2\u2076 inst\u271d\u00b2\u2075 inst\u271d\u00b2\u2074 inst\u271d\u00b2\u00b3 : CommSemiring R\ninst\u271d\u00b2\u00b2 : CommSemiring S\ninst\u271d\u00b2\u00b9 : Algebra R S\ninst\u271d\u00b2\u2070 : CommSemiring R\ninst\u271d\u00b9\u2079 inst\u271d\u00b9\u2078 inst\u271d\u00b9\u2077 : CommRing R\ninst\u271d\u00b9\u2076 : CommSemiring R\ninst\u271d\u00b9\u2075 inst\u271d\u00b9\u2074 : CommRing R\ninst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : CommSemiring S\ninst\u271d\u00b9\u2070 : Algebra R S\ninst\u271d\u2079 : CommSemiring R\ninst\u271d\u2078 : CommSemiring S\ninst\u271d\u2077 : Algebra R S\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : CommSemiring S\ninst\u271d\u2074 : Algebra R S\nM : Type u_18\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module S M\ninst\u271d : IsScalarTower R S M\nm : M\n\u22a2 sorry (((TensorProduct.mk R S M) 1) m) = m"}, {"line": "simp", "tactic_state": "R : Type uR\nS : Type uS\ninst\u271d\u00b2\u2077 inst\u271d\u00b2\u2076 inst\u271d\u00b2\u2075 inst\u271d\u00b2\u2074 inst\u271d\u00b2\u00b3 : CommSemiring R\ninst\u271d\u00b2\u00b2 : CommSemiring S\ninst\u271d\u00b2\u00b9 : Algebra R S\ninst\u271d\u00b2\u2070 : CommSemiring R\ninst\u271d\u00b9\u2079 inst\u271d\u00b9\u2078 inst\u271d\u00b9\u2077 : CommRing R\ninst\u271d\u00b9\u2076 : CommSemiring R\ninst\u271d\u00b9\u2075 inst\u271d\u00b9\u2074 : CommRing R\ninst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : CommSemiring S\ninst\u271d\u00b9\u2070 : Algebra R S\ninst\u271d\u2079 : CommSemiring R\ninst\u271d\u2078 : CommSemiring S\ninst\u271d\u2077 : Algebra R S\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : CommSemiring S\ninst\u271d\u2074 : Algebra R S\nM : Type u_18\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module S M\ninst\u271d : IsScalarTower R S M\nm : M\n\u22a2 sorry () (1 \u2297\u209c[R] m) = m"}]}
{"declaration": "lemma coeff_rTensorAlgHom_monomial_tmul\n    (e : \u03c3 \u2192\u2080 \u2115) (s : S) (n : N) (d : \u03c3 \u2192\u2080 \u2115) :\n    coeff d (rTensorAlgHom (monomial e s \u2297\u209c[R] n)) =\n      if e = d then s \u2297\u209c[R] n else 0 := by\n  simp [ite_tmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/TensorProduct/MvPolynomial.lean", "context": {"open": ["DirectSum TensorProduct", "Set LinearMap Submodule"], "variables": ["{R : Type u} {N : Type v} [CommSemiring R]", "{\u03c3 : Type*}", "{S : Type*} [CommSemiring S] [Algebra R S]", "[DecidableEq \u03c3]", "[AddCommMonoid N] [Module R N]", "[CommSemiring N] [Algebra R N]", "[DecidableEq \u03c3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nN : Type v\ninst\u271d\u2078 : CommSemiring R\n\u03c3 : Type u_1\nS : Type u_2\ninst\u271d\u2077 : CommSemiring S\ninst\u271d\u2076 : Algebra R S\ninst\u271d\u2075 : DecidableEq \u03c3\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : CommSemiring N\ninst\u271d\u00b9 : Algebra R N\ninst\u271d : DecidableEq \u03c3\nx\u271d : Sort u_3\ncoeff : x\u271d\ne : \u03c3 \u2192\u2080 \u2115\ns : S\nn : N\nd : \u03c3 \u2192\u2080 \u2115\n\u22a2 sorry = if e = d then s \u2297\u209c[R] n else 0"}, {"line": "simp [ite_tmul]", "tactic_state": "R : Type u\nN : Type v\ninst\u271d\u2078 : CommSemiring R\n\u03c3 : Type u_1\nS : Type u_2\ninst\u271d\u2077 : CommSemiring S\ninst\u271d\u2076 : Algebra R S\ninst\u271d\u2075 : DecidableEq \u03c3\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : CommSemiring N\ninst\u271d\u00b9 : Algebra R N\ninst\u271d : DecidableEq \u03c3\nx\u271d : Sort u_3\ncoeff : x\u271d\ne : \u03c3 \u2192\u2080 \u2115\ns : S\nn : N\nd : \u03c3 \u2192\u2080 \u2115\n\u22a2 sorry () = if e = d then s \u2297\u209c[R] n else 0"}]}
{"declaration": "lemma algebraTensorAlgEquiv_symm_X (s : \u03c3) :\n    (algebraTensorAlgEquiv R A).symm (X s) = 1 \u2297\u209c X s := by\n  simp [algebraTensorAlgEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/TensorProduct/MvPolynomial.lean", "context": {"open": ["DirectSum TensorProduct", "Set LinearMap Submodule"], "variables": ["{R : Type u} {N : Type v} [CommSemiring R]", "{\u03c3 : Type*}", "{S : Type*} [CommSemiring S] [Algebra R S]", "[DecidableEq \u03c3]", "[AddCommMonoid N] [Module R N]", "[CommSemiring N] [Algebra R N]", "[DecidableEq \u03c3]", "(R)", "(A : Type*) [CommSemiring A] [Algebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03c3\nx\u271d\u00b9 : Sort u_4\nalgebraTensorAlgEquiv : x\u271d\u00b9\nx\u271d : Sort u_5\nX : x\u271d\ns : \u03c3\n\u22a2 sorry = 1 \u2297\u209c[?m.23372 s] sorry"}, {"line": "simp [algebraTensorAlgEquiv]", "tactic_state": "\u03c3 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03c3\nx\u271d\u00b9 : Sort u_4\nalgebraTensorAlgEquiv : x\u271d\u00b9\nx\u271d : Sort u_5\nX : x\u271d\ns : \u03c3\n\u22a2 sorry () = 1 \u2297\u209c[?m.23372 s] sorry ()"}]}
{"declaration": "theorem traceMatrix_of_basis [Fintype \u03ba] [DecidableEq \u03ba] (b : Basis \u03ba A B) :\n    traceMatrix A b = BilinForm.toMatrix b (traceForm A B) := by\n  ext (i j)\n  rw [traceMatrix_apply]\n  rw [traceForm_apply]\n  rw [traceForm_toMatrix]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Trace/Basic.lean", "context": {"open": ["Module", "LinearMap (BilinForm)", "LinearMap", "Matrix", "scoped Matrix", "Algebra Polynomial", "IntermediateField", "IntermediateField", "Polynomial", "Algebra IntermediateField", "Finset"], "variables": ["{R S T : Type*} [CommRing R] [CommRing S] [CommRing T]", "[Algebra R S] [Algebra R T]", "{K L : Type*} [Field K] [Field L] [Algebra K L]", "{\u03b9 \u03ba : Type w} [Fintype \u03b9]", "{F : Type*} [Field F]", "[Algebra K S] [Algebra K F]", "(K)", "{K} in", "{K}", "{F : Type*} [Field F]", "[Algebra R L] [Algebra L F] [Algebra R F] [IsScalarTower R L F]", "[Algebra K F] [IsScalarTower K L F]", "(F) (E : Type*) [Field E] [Algebra K E]", "[IsAlgClosed E]", "(A : Type u) {B : Type v} (C : Type z)", "[CommRing A] [CommRing B] [Algebra A B] [CommRing C] [Algebra A C]", "{A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03ba : Type w\nA : Type u\nB : Type v\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : Fintype \u03ba\ninst\u271d : DecidableEq \u03ba\nb : Basis \u03ba A B\n\u22a2 traceMatrix A \u21d1b = (BilinForm.toMatrix b) (traceForm A B)"}, {"line": "ext (i j)", "tactic_state": "case a\n\u03ba : Type w\nA : Type u\nB : Type v\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : Fintype \u03ba\ninst\u271d : DecidableEq \u03ba\nb : Basis \u03ba A B\ni j : \u03ba\n\u22a2 traceMatrix A (\u21d1b) i j = (BilinForm.toMatrix b) (traceForm A B) i j"}, {"line": "rw [traceMatrix_apply]", "tactic_state": "case a\n\u03ba : Type w\nA : Type u\nB : Type v\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : Fintype \u03ba\ninst\u271d : DecidableEq \u03ba\nb : Basis \u03ba A B\ni j : \u03ba\n\u22a2 ((traceForm A B) (b i)) (b j) = (BilinForm.toMatrix b) (traceForm A B) i j"}, {"line": "rw [traceForm_apply]", "tactic_state": "case a\n\u03ba : Type w\nA : Type u\nB : Type v\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : Fintype \u03ba\ninst\u271d : DecidableEq \u03ba\nb : Basis \u03ba A B\ni j : \u03ba\n\u22a2 (Algebra.trace A B) (b i * b j) = (BilinForm.toMatrix b) (traceForm A B) i j"}, {"line": "rw [traceForm_toMatrix]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem trace_self_apply (a) : trace R R a = a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Trace/Defs.lean", "context": {"open": ["Module", "LinearMap (BilinForm)", "LinearMap", "Matrix", "scoped Matrix"], "variables": ["{R S T : Type*} [CommRing R] [CommRing S] [CommRing T]", "[Algebra R S] [Algebra R T]", "{\u03b9 : Type w} [Fintype \u03b9]", "(R S)", "{S}", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na : R \u2192\u2097[R] R\n\u22a2 sorry"}, {"line": "simp", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\na : R \u2192\u2097[R] R\n\u22a2 sorry ()"}]}
{"declaration": "theorem trace_algebraMap [StrongRankCondition R] [Module.Free R S] (x : R) :\n    trace R S (algebraMap R S x) = finrank R S \u2022 x := by\n  by_cases H : \u2203 s : Finset S, Nonempty (Basis s R S)\n  \u00b7 rw [trace_algebraMap_of_basis H.choose_spec.some, finrank_eq_card_basis H.choose_spec.some]\n  \u00b7 simp [trace_eq_zero_of_not_exists_basis R H, finrank_eq_zero_of_not_exists_basis_finset H]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/Trace/Defs.lean", "context": {"open": ["Module", "LinearMap (BilinForm)", "LinearMap", "Matrix", "scoped Matrix"], "variables": ["{R S T : Type*} [CommRing R] [CommRing S] [CommRing T]", "[Algebra R S] [Algebra R T]", "{\u03b9 : Type w} [Fintype \u03b9]", "(R S)", "{S}", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\ninst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Free R S\nx : R\n\u22a2 sorry = finrank R S \u2022 x"}, {"line": "by_cases H : \u2203 s : Finset S, Nonempty (Basis s R S)", "tactic_state": "case pos\nR : Type u_1\nS : Type u_2\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\ninst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Free R S\nx : R\nH : \u2203 s, Nonempty sorry\n\u22a2 sorry = finrank R S \u2022 x\n---\ncase neg\nR : Type u_1\nS : Type u_2\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\ninst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Free R S\nx : R\nH : \u00ac\u2203 s, Nonempty sorry\n\u22a2 sorry = finrank R S \u2022 x"}, {"line": "\u00b7 rw [trace_algebraMap_of_basis H.choose_spec.some, finrank_eq_card_basis H.choose_spec.some]", "tactic_state": "case neg\nR : Type u_1\nS : Type u_2\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\ninst\u271d\u00b9 : StrongRankCondition R\ninst\u271d : Free R S\nx : R\nH : \u00ac\u2203 s, Nonempty sorry\n\u22a2 sorry = finrank R S \u2022 x"}, {"line": "\u00b7 simp [trace_eq_zero_of_not_exists_basis R H, finrank_eq_zero_of_not_exists_basis_finset H]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma multiSetProd_mem {\u03b9 : Type*} (s : Multiset \u03b9) (f : \u03b9 \u2192 R) (hs : \u2203 x \u2208 s, f x \u2208 I) :\n    (s.map f).prod \u2208 I := by\n  rcases s\n  simpa using listProd_mem (hl := hs)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/TwoSidedIdeal/BigOperators.lean", "context": {"open": [], "variables": ["{R : Type*} [NonUnitalNonAssocRing R] (I : TwoSidedIdeal R)", "{R : Type*} [Ring R] (I : TwoSidedIdeal R)", "{R : Type*} [CommRing R] (I : TwoSidedIdeal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d : CommRing R\nI : TwoSidedIdeal R\n\u03b9 : Type u_4\ns : Multiset \u03b9\nf : \u03b9 \u2192 R\nhs : \u2203 x \u2208 s, f x \u2208 I\n\u22a2 (Multiset.map f s).prod \u2208 I"}, {"line": "rcases s", "tactic_state": "case mk\nR : Type u_3\ninst\u271d : CommRing R\nI : TwoSidedIdeal R\n\u03b9 : Type u_4\ns : Multiset \u03b9\nf : \u03b9 \u2192 R\na\u271d : List \u03b9\nhs : \u2203 x \u2208 Quot.mk (\u21d1(List.isSetoid \u03b9)) a\u271d, f x \u2208 I\n\u22a2 (Multiset.map f (Quot.mk (\u21d1(List.isSetoid \u03b9)) a\u271d)).prod \u2208 I"}, {"line": "simpa using listProd_mem (hl := hs)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma finsetProd_mem {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 R) (hs : \u2203 x \u2208 s, f x \u2208 I) :\n    s.prod f \u2208 I := by\n  rcases s\n  simpa using multiSetProd_mem (hs := hs)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/TwoSidedIdeal/BigOperators.lean", "context": {"open": [], "variables": ["{R : Type*} [NonUnitalNonAssocRing R] (I : TwoSidedIdeal R)", "{R : Type*} [Ring R] (I : TwoSidedIdeal R)", "{R : Type*} [CommRing R] (I : TwoSidedIdeal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d : CommRing R\nI : TwoSidedIdeal R\n\u03b9 : Type u_4\ns : Finset \u03b9\nf : \u03b9 \u2192 R\nhs : \u2203 x \u2208 s, f x \u2208 I\n\u22a2 s.prod f \u2208 I"}, {"line": "rcases s", "tactic_state": "case mk\nR : Type u_3\ninst\u271d : CommRing R\nI : TwoSidedIdeal R\n\u03b9 : Type u_4\nf : \u03b9 \u2192 R\nval\u271d : Multiset \u03b9\nnodup\u271d : val\u271d.Nodup\nhs : \u2203 x \u2208 { val := val\u271d, nodup := nodup\u271d }, f x \u2208 I\n\u22a2 { val := val\u271d, nodup := nodup\u271d }.prod f \u2208 I"}, {"line": "simpa using multiSetProd_mem (hs := hs)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_toTwoSided {I : Ideal R} [I.IsTwoSided] {x : R} :\n    x \u2208 I.toTwoSided \u2194 x \u2208 I := by\n  simp [toTwoSided]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/TwoSidedIdeal/Operations.lean", "context": {"open": ["AddSubgroup in", "Pointwise Set", "Pointwise Set in"], "variables": ["{R S : Type*} [NonUnitalNonAssocRing R] [NonUnitalNonAssocRing S]", "{F : Type*} [FunLike F R S]", "(f : F)", "[NonUnitalRingHomClass F R S]", "{R S T : Type*}", "[NonAssocRing R] [NonAssocRing S] [NonAssocRing T]", "{R : Type*} [NonUnitalRing R]", "{R : Type*} [Ring R]", "(I : TwoSidedIdeal R)", "{R : Type*} [CommRing R]", "{R : Type*} [Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_8\ninst\u271d\u00b9 : Ring R\nI : Ideal R\ninst\u271d : I.IsTwoSided\nx : R\n\u22a2 x \u2208 I.toTwoSided \u2194 x \u2208 I"}, {"line": "simp [toTwoSided]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_toTwoSided (I : Ideal R) [I.IsTwoSided] : (I.toTwoSided : Set R) = I := by\n  simp [toTwoSided]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/TwoSidedIdeal/Operations.lean", "context": {"open": ["AddSubgroup in", "Pointwise Set", "Pointwise Set in"], "variables": ["{R S : Type*} [NonUnitalNonAssocRing R] [NonUnitalNonAssocRing S]", "{F : Type*} [FunLike F R S]", "(f : F)", "[NonUnitalRingHomClass F R S]", "{R S T : Type*}", "[NonAssocRing R] [NonAssocRing S] [NonAssocRing T]", "{R : Type*} [NonUnitalRing R]", "{R : Type*} [Ring R]", "(I : TwoSidedIdeal R)", "{R : Type*} [CommRing R]", "{R : Type*} [Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_8\ninst\u271d\u00b9 : Ring R\nI : Ideal R\ninst\u271d : I.IsTwoSided\n\u22a2 \u2191I.toTwoSided = \u2191I"}, {"line": "simp [toTwoSided]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_mem {x y} (hx : x \u2208 I) (hy : y \u2208 I) : x + y \u2208 I := by simpa using I.ringCon.add hx hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/TwoSidedIdeal/Basic.lean", "context": {"open": ["MulOpposite"], "variables": ["{R : Type*} [NonUnitalNonAssocRing R] (I : TwoSidedIdeal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\nx y : R\nhx : x \u2208 I\nhy : y \u2208 I\n\u22a2 x + y \u2208 I"}, {"line": "simpa using I.ringCon.add hx hy", "tactic_state": "No Goals!"}]}
{"declaration": "lemma neg_mem {x} (hx : x \u2208 I) : -x \u2208 I := by simpa using I.ringCon.neg hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/TwoSidedIdeal/Basic.lean", "context": {"open": ["MulOpposite"], "variables": ["{R : Type*} [NonUnitalNonAssocRing R] (I : TwoSidedIdeal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\nx : R\nhx : x \u2208 I\n\u22a2 -x \u2208 I"}, {"line": "simpa using I.ringCon.neg hx", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_mem_left (x y) (hy : y \u2208 I) : x * y \u2208 I := by\n  simpa using I.ringCon.mul (I.ringCon.refl x) hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/TwoSidedIdeal/Basic.lean", "context": {"open": ["MulOpposite"], "variables": ["{R : Type*} [NonUnitalNonAssocRing R] (I : TwoSidedIdeal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\nx y : R\nhy : y \u2208 I\n\u22a2 x * y \u2208 I"}, {"line": "simpa using I.ringCon.mul (I.ringCon.refl x) hy", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_mem_right (x y) (hx : x \u2208 I) : x * y \u2208 I := by\n  simpa using I.ringCon.mul hx (I.ringCon.refl y)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/RingTheory/TwoSidedIdeal/Basic.lean", "context": {"open": ["MulOpposite"], "variables": ["{R : Type*} [NonUnitalNonAssocRing R] (I : TwoSidedIdeal R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\nx y : R\nhx : x \u2208 I\n\u22a2 x * y \u2208 I"}, {"line": "simpa using I.ringCon.mul hx (I.ringCon.refl y)", "tactic_state": "No Goals!"}]}
